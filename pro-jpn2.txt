_repositoryはDB操作をするための自作クラスの変数
GetStudentInfoでDBから情報を取得してくる ※情報取得部分は割愛
*var results = _repository.GetStudentInfo(model).ToList());
byte配列をつなぐ
*bytes_separate
ここの仕様が変わった？ 以前は "cw.Configuration.RegisterClassMap" のようにしていたと思う
*cw.Context.RegisterClassMap<;TMap>;();

UIが消える処理
*});
UIが消える処理
*})
UIを消す処理
*});

*m_texture.SetPixel( x, y, Color.black );
点を描画

CookieAuthenticationDefaults.AuthenticationSchemeのスキーム名は別の文字に変更することも可能
例えば：MyLoginScheme
だが変更され場合は利用する際はスキーム名を変更されたスキーム名と一致する必要があります。
.AddCookieでは認証用のCookieに関する設定です
*services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
AuthenticationSchemeという認証スキームの共通設定
HttpContext.ChallengeAsync(認証チャレンジ)で認証失敗した場合のリダイレクト先
簡単に言うとログインされていない時にログインが必要の機能へアクセスする時のリダイレクト先
*option.LoginPath = "/LoginController/LoginAction";
HttpContext.ForbidAsync（認証されているが、必要な権限がない時の禁止）でのリダイレクト先
ログインされている、だがアクセスする機能に必要な権限が足りない時のリダイレクト先
*option.AccessDeniedPath = "/LoginController/ForbidAction";
該当スキームのCookie名、デフォルトは.AspNetCore.Cookies
*option.Cookie.Name = "token";
Cookieの中に保存されている認証データの有効期限、ここでは5分以内にサーバーへアクセスがないと認証タイムアウトが発生する
*option.ExpireTimeSpan = TimeSpan.FromMinutes(5);
その他の設定に関しては省略する
*});
*var claims = new List<;Claim>;(){new Claim(ClaimTypes.Sid,loginId)};
ログインID,パスワードチェック処理省略、ログイン出来ると仮定する
認証サービス登録する際に設定したスキームと同じものを設定
*await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, identityPrincipal,
サーバーアクセスによる認証時間を更新する
*AllowRefresh = true,
認証の有効期間,認証cookieタイムアウト
*ExpiresUtc = DateTimeOffset.UtcNow.AddMinutes(5),
cookieの有効期間を優先かsessionを優先か
true:cookieが有効であれば、ブラウザを閉じても再ログインが必要ない
false:ブラウザ閉じたら再ログインが必要
*IsPersistent = false,
cookieの認証時間
*IssuedUtc = DateTime.UtcNow
セッションタイムアウト、5分以上操作がないと
デフォルトタイムアウトは20分
*option.IdleTimeout = TimeSpan.FromMinutes(5);
option.Cookieに関する設定はセッションのクライアントCookieに当たる
認証Cookieとは別物です。デフォルトCookie名は「.AspNetCore.Session」
*});

*1f);
継続時間は1秒
90°から360°まで回転移動するTween
*private TweenerCore<;Angle, Angle, AngleOptions>; GetBaseTween(float duration) =>;
角度を指定すると半径1のXY円周上の座標に移動する
*private void MoveOnCircumference(Angle angle) =>;
90°から360°まで
*GetBaseTween(1f);
90°から450°まで一周
*GetBaseTween(1f).SetRelative();
360°から90°まで
*GetBaseTween(1f).From();
180°から360°まで
*GetBaseTween(1f).From(Angle.FromDegree(180));
90°/sの速さで90°から360°まで
*GetBaseTween(90).SetSpeedBased(AngularVelocityUnit.DegreePerSecond);
0°から90°まで
*GetBaseTween(1f).From().SetOptions(AngleTweenDirection.Forward);

data_1,data_2は必ず存在するので、そのまま代入
*data_1.number = data_2.number = ResultData.no.Tostring();
*if (data_3 != null)*{
data_3,data_4は存在しない可能性があるため、nullでない場合に代入

*this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {this.toolStripMenuItem1,this.toolStripMenuItem4});
menuStrip1
*this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {this.toolStripMenuItem1,this.toolStripMenuItem4});

*this.toolStripMenuItem1.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {this.toolStripMenuItem2,this.toolStripMenuItem3});
toolStripMenuItem1
*this.toolStripMenuItem1.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {this.toolStripMenuItem2,this.toolStripMenuItem3});

*this.toolStripMenuItem4.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {this.toolStripMenuItem5,this.toolStripMenuItem6});
toolStripMenuItem4
*this.toolStripMenuItem4.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {this.toolStripMenuItem5,this.toolStripMenuItem6});

*this.statusStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {this.toolStripStatusLabel1,this.toolStripStatusLabel2,this.toolStripStatusLabel3});
statusStrip1
*this.statusStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {this.toolStripStatusLabel1,this.toolStripStatusLabel2,this.toolStripStatusLabel3});

*this.contextMenuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {this.toolStripMenuItem7,this.toolStripMenuItem8,this.toolStripMenuItem9});
contextMenuStrip1
*this.contextMenuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {this.toolStripMenuItem7,this.toolStripMenuItem8,this.toolStripMenuItem9});

*this.toolStripMenuItem4.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {this.toolStripMenuItem5,this.toolStripMenuItem6});
toolStripMenuItem4
*this.toolStripMenuItem4.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {this.toolStripMenuItem5,this.toolStripMenuItem6});


appsettings.jsonから"CorsUrl"の値を取得して設定。
*builder.WithOrigins(this.Configuration.GetSection("CorsUrl").Value)

*List<;int<; ls2 = new List<;int<;();
これに全ての要素を入れ直す
*foreach(int i in ls2) {*Console.WriteLine(i);
IEnumerable&lt;int[]&gt; ls3    = ls.Select(x =&gt; new int[x]);   戻り値は配列のコレクション
出力
*40

*public int PostalCodeContainAnyTownArea { get; set; }
一つの郵便番号で二以上の町域を表す場合の表示
ヘッダーtrueはしない
csv.Configuration.HasHeaderRecord = true;
読み込み を先に行う
*csv.Read();
ヘッダー　を次に行う
*csv.ReadHeader();
マッピングルールを登録　は使用しない
csv.Configuration.RegisterClassMap&lt;CsvMapperKenAll&gt;();
データを読み出し
*var records = csv.GetRecords<;KenAllCSV>;();
DataGridに出力
*tempDatas = new ObservableCollection<;KenAllCSV>;();

*{return (IEnumerable)obj.GetValue(SelectableDatesProperty);}
Getter
*{obj.SetValue(SelectableDatesProperty, value);}
Setter
添付プロパティを登録
*public static readonly DependencyProperty SelectableDatesProperty = DependencyProperty.RegisterAttached(
*{if (d is DatePicker datePicker &amp;&amp; e.NewValue is IEnumerable<;DateTime>; dates){var minDate = dates.Min();var maxDate = dates.Max();// 区間の最初と最後を設定datePicker.DisplayDateStart = minDate;datePicker.DisplayDateEnd = maxDate;// 選択できる日付の区間内は、1日ずつ判定して、含まれていなければ BlackoutDates に追加for (int i = 1; i <; (maxDate - minDate).Days; i++){if (!dates.Contains(minDate.AddDays(i))){datePicker.BlackoutDates.Add(new CalendarDateRange(minDate.AddDays(i)));}}}}
コールバック関数の定義
区間の最初と最後を設定
*datePicker.DisplayDateStart = minDate;
*for (int i = 1; i <; (maxDate - minDate).Days; i++)*{
選択できる日付の区間内は、1日ずつ判定して、含まれていなければ BlackoutDates に追加

X軸操作用Sliderの値の変更を監視
*_sliderX.OnValueChangedAsObservable()
Y軸操作用Sliderの値の変更を監視
*_sliderY.OnValueChangedAsObservable()
Z軸操作用Sliderの値の変更を監視
*_sliderZ.OnValueChangedAsObservable()
値の整形
*var arrangeValue = Mathf.Floor((value - 0.5f) * 100) / 100 * 360;
値の更新
*floatReactiveProperty.Value = arrangeValue;
テキストに値を反映
*valueText.text = arrangeValue.ToString();
Sliderの値の更新を監視
================================
*_sliderView.SliderValueRP_X

変更前の環境変数Pathの値を全て取得
*string base_paths = System.Environment.GetEnvironmentVariable("Path",
環境パス設定
*Environment.SetEnvironmentVariable("Path",

*oBorder = oBorders[Excel.XlBordersIndex.xlEdgeBottom];
xlEdgeLeft xlEdgeRight xlEdgeTop
*if (k>;0){sb.Append("\t");}*sb.Append(m.Groups[2].Value);
if(m.Success){

*iSample.Paint();
出力 --&gt; "Change Paint method"

*Thread.Sleep(5000);
所謂重たい処理
*{Thread.Sleep(5000);}
重たい処理はこの中で
*{MessageBox.Show("Done!");}
処理が終了したらこのイベントが発生する

*var conversationId = "<;ConversationID<;";
API経由で取得したConversationID

DataGridにバインドするModel
*readonly ObservableCollection<;Person>; tmpPeople = new ObservableCollection<;Person>;();
p =&gt; p."columnName"というラムダ式を生成
*var keyFunc = GetDynamicPropertyExpression(e.Column.Header.ToString()).Compile();
ColumnNameの中身でOrderBy
*sortedPeople = new List<;Person>;(tmpPeople.OrderBy(keyFunc));
ColumnNameの中身でorderByDescending
*sortedPeople = new List<;Person>;(tmpPeople.OrderByDescending(keyFunc));
ソート結果をUIに反映
*ReloadDataGrid(sortedPeople);
*foreach (var item in this.hihokenshaDatagrid.Columns)*{
他のカラムのソート状態をデフォルトにする
p."columnName"というプロパティアクセス
*var propertyAccess = Expression.MakeMemberAccess(param, prop);
p =&gt; p."columnName"というラムダ式を格納した式ツリーを返す
*return Expression.Lambda<;Func<;Person, string>;>;(propertyAccess, param);

numThreadsで指定した数まで同じ名前のパイプを作れる
*NamedPipeServerStream pipeServer = new NamedPipeServerStream(pipeName, PipeDirection.InOut, numThreads);
クライアントの接続待ち
*pipeServer.WaitForConnection();
受信待ち
*var read = ss.ReadString();
受信したら応答を送信
*var write = ss.WriteString("Server read OK.");
入力された文字列を送信する
*var writeData = Console.ReadLine();
応答待ち
*var read = ss.ReadString();
*{private Stream ioStream;private UnicodeEncoding streamEncoding;public StreamString(Stream ioStream){this.ioStream = ioStream;streamEncoding = new UnicodeEncoding();}public string ReadString(){int len = 0;len = ioStream.ReadByte() * 256;len += ioStream.ReadByte();byte[] inBuffer = new byte[len];ioStream.Read(inBuffer, 0, len);return streamEncoding.GetString(inBuffer);}public int WriteString(string outString){byte[] outBuffer = streamEncoding.GetBytes(outString);int len = outBuffer.Length;if (len >; UInt16.MaxValue){len = (int)UInt16.MaxValue;}ioStream.WriteByte((byte)(len / 256));ioStream.WriteByte((byte)(len &amp; 255));ioStream.Write(outBuffer, 0, len);ioStream.Flush();return outBuffer.Length + 2;}}
MSサンプルそのまま(streamに文字列を読み書きしてくれるクラス)

f1とf2がテスト済みなら、f3のテストは1個でいいでしょ？
*int result = f1(x) + f2(y);

*{try{await Task.Run(() =>;{throw new NotImplementedException();});}catch (Exception ex){Debug.WriteLine("1:" + ex.GetType());}}
awaitしたTaskの例外
*{try{Task.Run(() =>;{throw new NotImplementedException();}).Wait();}catch (Exception ex){Debug.WriteLine("a:" + ex.GetType());if (ex is AggregateException age){Debug.WriteLine("b:" + age.InnerException.GetType());}}}
Wait()したTaskの例外
*{try{var t = Task.Run(() =>;{throw new NotImplementedException();});t.ContinueWith((compt) =>;{Debug.WriteLine("A:" + compt.Exception.GetType());if (compt.Exception is AggregateException age){Debug.WriteLine("C:" + age.InnerException.GetType());}});}catch (Exception ex){// ここには来ないDebug.WriteLine("B:" + ex.GetType());}}
待たないTaskの例外
ここには来ない
*Debug.WriteLine("B:" + ex.GetType());
WhenAllのタスクのローカル変数を作って、それをtry catchする
*await all;
ex には例外のうちの1つしか入ってないので、
WhenAllのタスクのローカル変数のExceptionプロパティ
(それがAggregateExceptionになってる)を見て
すべての例外を取り出す
*if (all.Exception is AggregateException age)
excep はAggregateExceptionに包まれている個別の例外。
*Debug.WriteLine(excep.GetType());
trueにしたら、ここでもう処理済みということで例外を再throwしない
falseにしたら、まだ未処理ということで例外を再throwする。
*return true;

*var url = "https:
api.nhk.or.jpv2pglist130s1" + DateTime.Now.AddDays(0).ToString("yyyy-MM-dd")
無理やりだが要素数を取得
*var line1 = rawdata;
*for (int i=0; i<;max_count; i++)*{
放送があるかどうか確認
*var output = "Today's GREAT RACE : {hoso}";
Slack への出力準備
*{text = output,username = "GREAT RACE Bot",icon_emoji = emoji};
Slack に出力する

new Square(); に変更したら Assert に引っかかるようになる。しかもコンパイルエラーにならない。
*Rectangle rectangle = new Square();

*await Addressables.InitializeAsync();
ここ重要

ここに使用するカメラをセット
*public Camera cam;
カメラ位置をセット
*private const int count = 2 ;
*cam.transform.position = position.transform.position;*cam.transform.rotation = position.transform.rotation;
カメラを移動

*xmlns:behavior="clr-namespace:ControlTest.Behaviors"
この名前は任意で

*.AddDefaultUI();
←追加
*{_userManager = userManager;_signInManager = signInManager;_logger = logger;//_emailSender = emailSender;}
IEmailSender emailSender)
*//public string Email { get; set; }
[EmailAddress]
*//public string Email { get; set; }
[Display(Name = "Email")]
*[StringLength(100, ErrorMessage = "{0} は {2} ～ {1} 文字で入力してください。", MinimumLength = 6)]
public string Email { get; set; }
*var user = new SMSUser { SMSUserId = Input.UserId, SMSUserName = Input.UserName, IsLocked = false, LoginFailCount = 0, CreateDate = DateTime.Now, UpdateDate = DateTime.Now };
var user = new SMSUser { UserName = Input.Email, Email = Input.Email };
*//    values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },
"/Account/ConfirmEmail",
*//    values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },
pageHandler: null,
*//    $"Please confirm your account by <;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>;clicking here<;/a>;.");
protocol: Request.Scheme);
*//    $"Please confirm your account by <;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>;clicking here<;/a>;.");
await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",
*//if (_userManager.Options.SignIn.RequireConfirmedAccount)*//{
$"Please confirm your account by &lt;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'&gt;clicking here&lt;/a&gt;.");
*//{//    return RedirectToPage("RegisterConfirmation", new { email = Input.Email, returnUrl = returnUrl });//}
if (_userManager.Options.SignIn.RequireConfirmedAccount)
*//    return RedirectToPage("RegisterConfirmation", new { email = Input.Email, returnUrl = returnUrl });
{
*//{await _signInManager.SignInAsync(user, isPersistent: false);return LocalRedirect(returnUrl);//}
}
*//{await _signInManager.SignInAsync(user, isPersistent: false);return LocalRedirect(returnUrl);//}
else
*var user = new SMSUser { SMSUserId = Input.UserId, SMSUserName = Input.UserName, UserName = Input.UserName, IsLocked = false, LoginFailCount = 0, CreateDate = DateTime.Now, UpdateDate = DateTime.Now };
var user = new SMSUser { UserName = Input.Email, Email = Input.Email };
*{options.User.AllowedUserNameCharacters = null;})
.AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();

*csvDatas.Add(cell.Split(','));
','を目安にリストに格納していく

*String Name = info.Element("Name").Value;
ここで例外発生

重みの配列を[1, 10, 100, 1000, 10000]、いずれかの長さで用意。
*var source = ItemEnumerableGenerator.GenerateEnumerable(count).ToArray();
*for (int i = 0;values.Length >; i;i++) {values[i] = Random.value;}
選択に使用する[0.0f~1.0f]の値を用意する。
*for (int i = 0;k_Iterations.Length >; i;i++) {*int iteration = k_Iterations[i];
[1, 10, 100, 1000, 10000]、5通りの反復回数を試みる。
セットアップ
*var weightedSelector = source.ToWeightedSelector(x =>; x.item,x =>; x.weight,method);
*for (int k = 0;iteration >; k;k++) {*weightedSelector.SelectItem(values[k]);
WeightedSelectorからアイテムを選択する。

*oBorder = oBorders[Excel.XlBordersIndex.xlEdgeBottom];
xlEdgeLeft xlEdgeRight xlEdgeTop
*finally {if ( oExcelApp.Calculation != calcModeBackup ) {oExcelApp.Calculation = calcModeBackup;}if ( oExcelApp.ScreenUpdating != screenUpdatingBackup ) {oExcelApp.ScreenUpdating = screenUpdatingBackup;}}
処理を追加  ここまで

*SceneManager.LoadScene(sceneName);
シーンチェンジ

ロビーへ移動する
*PhotonNetwork.JoinLobby();
*{Debug.Log("[function]ReloadRooms");foreach(RoomInfo r in roomList){//プレイヤーが存在しているルームif (r.PlayerCount >; 0){RoomButtonCreate(r);}else{RoomButtonDelete(r);}}}
ルームに動きがあった場合
*if (r.PlayerCount >; 0)*{
プレイヤーが存在しているルーム
*{//すでに存在していたのなら情報の更新if (gameObject.transform.Find(r.Name)){RoomInfoUpdate(gameObject.transform.Find(r.Name).gameObject, r);}//新しく作られたルームならばボタンの作成else{var roomButton = (GameObject)Instantiate(RoomButton);roomButton.transform.SetParent(gameObject.transform, false);RoomInfoUpdate(roomButton, r);//生成したボタンの名前を作成するルームの名前にするroomButton.name = r.Name;}}
ルームボタンの作成
*if (gameObject.transform.Find(r.Name))*{
すでに存在していたのなら情報の更新
*{var roomButton = (GameObject)Instantiate(RoomButton);roomButton.transform.SetParent(gameObject.transform, false);RoomInfoUpdate(roomButton, r);//生成したボタンの名前を作成するルームの名前にするroomButton.name = r.Name;}
新しく作られたルームならばボタンの作成
生成したボタンの名前を作成するルームの名前にする
*roomButton.name = r.Name;
*{//ボタンが存在すれば削除if (gameObject.transform.Find(r.Name)){GameObject.Destroy(gameObject.transform.Find(r.Name).gameObject);}}
ルームボタンの削除
*if (gameObject.transform.Find(r.Name))*{
ボタンが存在すれば削除
*{foreach (Text t in button.GetComponentsInChildren<;Text>;()){if (t.name == "RoomName"){t.text = info.Name;}else if (t.name == "MaxPLayerCount"){t.text = info.MaxPlayers.ToString();}else if (t.name == "RoomInPlayerCount"){t.text = info.PlayerCount.ToString();}}}
ルームボタンのInfoの更新
ロビーへ移動する
*PhotonNetwork.JoinLobby();
*if (r.PlayerCount >; 0)*{
プレイヤーが存在しているルーム
*if (gameObject.transform.Find(r.Name))*{
すでに存在していたのなら情報の更新
*{var roomButton = (GameObject)Instantiate(RoomButton);roomButton.transform.SetParent(gameObject.transform, false);RoomInfoUpdate(roomButton, r);//生成したボタンの名前を作成するルームの名前にするroomButton.name = r.Name;}
新しく作られたルームならばボタンの作成
生成したボタンの名前を作成するルームの名前にする
*roomButton.name = r.Name;
*if (gameObject.transform.Find(r.Name))*{
ボタンが存在すれば削除

セリフ : Unityのインスペクタ(UI上)で会話文を定義する
（次項 : インスペクタでscriptを追加して、設定をする で説明）
*[SerializeField]
*protected override IEnumerator OnAction() {for (int i = 0; i <; messages.Count; ++i) {// 1フレーム分 処理を待機(下記説明1)yield;// 会話をwindowのtextフィールドに表示showMessage(messages[i]);// キー入力を待機 (下記説明1)yield return new WaitUntil(() =>; Input.anyKeyDown);}yield break;}
親クラスから呼ばれるコールバックメソッド (接触 &amp; ボタン押したときに実行)
1フレーム分 処理を待機(下記説明1)
*yield;
会話をwindowのtextフィールドに表示
*showMessage(messages[i]);
キー入力を待機 (下記説明1)
*yield return new WaitUntil(() =>; Input.anyKeyDown);

*if(createRoomName == "")*{
ルーム名が入力されてないなら自動生成
ルームのオプションの設定
*RoomOptions roomOptions = new RoomOptions();
==指定したルーム名と同じルーム名が存在している場合、PhotonNetworkの方で作成できないようになっている==
*PhotonNetwork.CreateRoom(createRoomName, roomOptions , null);

*{endpoints.MapControllerRoute(name: "default",pattern: "{controller=Home}/{action=Index}/{id?}");});
~~略~~
第一引数に実行Viewのパスを指定することが可能。
*return View("~/Views/HelloWorld/ModelTest.cshtml", ramens);

*if (IsSelected)
選択状態の場合のみ
*if (Stroke is null)*{
選択枠とリサイズハンドルを描画
*{if (e.LeftButton != MouseButtonState.Pressed){return;}//ActiveShapeだけTrue、それ以外はFalseforeach (var shape in shapes){shape.IsSelected = shape == activeShape;}skElement.InvalidateVisual();}
....
*foreach (var shape in shapes)*{
ActiveShapeだけTrue、それ以外はFalse
*{var (left, top, width, height) = (Bounds.Left, Bounds.Top, Bounds.Width, Bounds.Height);//幅がマイナスの場合if (Bounds.Width <; 0){//左右の座標を入れ替えて、幅の符号(-)を取るleft = Bounds.Right;width = Math.Abs(Bounds.Width);}//高さがマイナスの場合if (Bounds.Height <; 0){//上下の座標を入れ替えて、高さの符号(-)を取るtop = Bounds.Bottom;height = Math.Abs(Bounds.Height);}SetBounds(new Rectangle(left, top, width, height));}
...
*if (Bounds.Width <; 0)*{
幅がマイナスの場合
左右の座標を入れ替えて、幅の符号(-)を取る
*left = Bounds.Right;
*if (Bounds.Height <; 0)*{
高さがマイナスの場合
上下の座標を入れ替えて、高さの符号(-)を取る
*top = Bounds.Bottom;
*{if (e.LeftButton != MouseButtonState.Released){return;}if (activeShape is not null){activeShape.Drop();}}
....

*var task = beat.Start("https:
www.example.co.jp", 3000);

*xmlns:materialDesign="http:
materialdesigninxaml.netwinfxxamlthemes"

コルーチン処理
*}

*public struct Data{[DataMenber]public int hoge;}
Dataの構造体の定義
Dataのインスタンス
*private Data data;
*private void serializeData(){using(var memoryStream = new MemoryStream()){var dataContractJsonSerializer = new DataContractJsonSerializer(typeof(Data));//memoryStreamにDataのインスタンスをシリアライズしたJsonデータを書き込む//ここで問題が発生しましたdataContractJsonSerializer.WriteObject(memoryStream, data);//カーソル位置を最初に戻すmemoryStream.Position = 0;//memoryStreamの内容を読み込んで、全ての文字列をファイルに書き出すusing(var streamReader = new StreamReader(memoryStream, Encoding.UTF8)){var filePath = "任意のファイルのパス";File.WriteAllText(filePath, streamReader.ReadToEnd(), Encoding.UTF8);}}}
データのインスタンスのシリアライズを行う
memoryStreamにDataのインスタンスをシリアライズしたJsonデータを書き込む
ここで問題が発生しました
*dataContractJsonSerializer.WriteObject(memoryStream, data);
カーソル位置を最初に戻す
*memoryStream.Position = 0;
*using(var streamReader = new StreamReader(memoryStream, Encoding.UTF8)){var filePath = "任意のファイルのパス";File.WriteAllText(filePath, streamReader.ReadToEnd(), Encoding.UTF8);}
memoryStreamの内容を読み込んで、全ての文字列をファイルに書き出す

*[Authorize]
追加

*using (Transaction transaction = new Transaction(doc)) {if (transaction.Start("ExtensibleStorage") == TransactionStatus.Started) {try {/* ここで書き込み実行 */if (transaction.Commit() != TransactionStatus.Committed) {// コミットに失敗した時のエラー（Rollbackが必要）transaction.RollBack();}}catch (Exception ex) {// 途中で失敗した際のエラー（Rollbackが必要）transaction.RollBack();}}else {// トランザクションの開始に失敗した時のエラー}}
拡張ストレージに保存
コミットに失敗した時のエラー（Rollbackが必要）
*transaction.RollBack();
途中で失敗した際のエラー（Rollbackが必要）
*transaction.RollBack();
トランザクションの開始に失敗した時のエラー
*}
*if(sch == null){SchemaBuilder sb = new SchemaBuilder(new Guid("適当なGUID"));// 権限等sb.SetReadAccessLevel(AccessLevel.Public); // Public/Vendor/Applicationの3種類あります。とりあえずPublicで。sb.SetWriteAccessLevel(AccessLevel.Public);// スキーマ名sb.SetSchemaName("適当なスキーマ名");// フィールド名設定sb.AddSimpleField("適当なフィールド名", typeof(string));// スキーマを取得sch = sb.Finish();}
まず、スキーマがあるかどうかを判定
権限等
sb.SetReadAccessLevel(AccessLevel.Public);  Public/Vendor/Applicationの3種類あります。とりあえずPublicで。
*sb.SetWriteAccessLevel(AccessLevel.Public);
スキーマ名
*sb.SetSchemaName("適当なスキーマ名");
フィールド名設定
*sb.AddSimpleField("適当なフィールド名", typeof(string));
スキーマを取得
*sch = sb.Finish();
*Entity ent = doc.ProjectInformation.GetEntity(sch);*// XMLを設定
Entityを取得
XMLを設定
*ent.Set<;FieldType>;("適当なフィールド名", xmldata.ToString());
*doc.ProjectInformation.SetEntity(ent);*,,,
Docに設定
*if (sch == null) {*return default(T);
そもそも無い時
*if (!elem.GetEntity(sch).IsValid()) {*return default(T);
有効な値が無い時

*if (e.ErrorCode != 49)
エラー コード 49 は「認証失敗」

*public DbSet<;SalaryManagementSystem.Models.Salary<; Salary { get; set; }
移植箇所

*encode = encode ?? Encoding.GetEncoding("Shift-JIS");*var cutChars = text
エンコード未指定時はShift-JISを仮置き

*{thisInputField = GetComponent<;TMP_InputField>;();}
Start is called before the first frame update
*{if(thisInputField.isFocused &amp;&amp; Input.GetKeyDown(KeyCode.Tab)){nextInputField.Select();}}
Update is called once per frame

テンプレート画像で回してマッチするものを探す
*string[] templateFiles = Directory.GetFiles(@".\MatchTemplate", "*", SearchOption.TopDirectoryOnly);
マッチング
*var templateMat = new Mat(fileName);
*if (match <; 0)*{
マッチなし
確認用の画像表示
マッチした箇所を赤で囲む
*targetMat.Rectangle(maxPoint, new Point(maxPoint.X + templateMat.Width, maxPoint.Y + templateMat.Height), Scalar.Red, 2, LineTypes.AntiAlias, 0);
マッチ度を画面上部に表示
*targetMat.Rectangle(new Point(0, 0), new Point(800, 60), Scalar.White, -1, LineTypes.AntiAlias, 0);
探索画像を二値化
*var targetBinMat = new Mat();
テンプレ画像を二値化
*var templateBinMat = new Mat();
マッチング
*var resultMat = new Mat();
一番マッチした箇所のマッチ具合（0～1）と、その位置を取得する（画像内でマッチした左上座標）
*Cv2.MinMaxLoc(resultMat, out _, out var maxVal, out _, out matchPoint);
閾値超えのマッチ箇所を強調させておく
*var binMat = new Mat();

1.対象のGameObjectを取得。
Find()だったり、FindGameObjectWithTagだったり、インスペクターから直接指定したりなどなど
*GameObject _wb = GameObject.FindGameObjectWithTag("Whiteboard");
2.保存したいTextureをGameObjectから取得し、
3.取得したTextureをバイト配列に変換。
*texture = (Texture2D)_wb.GetComponent<;Renderer>;().material.mainTexture;
SendDataを呼び出す(コルーチンというらしい)
*StartCoroutine(SendData(picData));
4.サーバ上のphpに送信する
String url = "https:hagehoge/pic_save.php";httpにandroid端末から送る場合はパーミッション関連で何か必要だったような･･･
*var request = new UnityWebRequest(url, "POST");

*public int Interval { get; set; } = 10;
10 ミリ秒
ここにゲームパッドの処理を書く
*}
A ボタンを押していたら
*}
*if (GamepadIndex != null)*{
認識済みの場合、認識済みのゲームパッドを使う
認識済みのゲームパッドが無効になったとみなす
*GamepadIndex = null;
*for (var i = 0; i <; 4; ++i)*if (XInput.GetState(i, out var keystate))
未認識の場合、0 ～ 3 の順で有効なゲームパッドを探す
A ボタンを押したら
*}
A ボタンを押しっぱなしにしたら
*}
RB を押しながら A ボタンを押したら
*}

*&amp;&amp; targetHead.transform.InverseTransformPoint(playerHead.transform.position).z <;= 0)
対象にとって正面側にいるかどうか
*}else{
顔が向き合っている時の処理内容を記述
*}else{
顔が向き合ってない時の処理内容を記述
距離が離れている時の処理を記述
*}

2021/01のパッチだけ取得
*var date = new DateTime(2021, 1, 1, 0, 0, 0, 0);

*level.Value++;
.Valueで中身にアクセスする
bool can_press; とほぼ同じ使い方ができる。
*ReactiveProperty<;bool>; can_press = new ReactiveProperty<;bool>;();
*{can_press.BindToButtonOnClick(button, _ =>; Click());}
Start is called before the first frame update

フックの設定
*var hWnd = new WindowInteropHelper(Application.Current.MainWindow).EnsureHandle();
*registerConsoleDisplayHandle = RegisterPowerSettingNotification(hWnd, ref GUID_CONSOLE_DISPLAY_STATE, DEVICE_NOTIFY_WINDOW_HANDLE);*}
WM_POWERBROADCAST &gt; PBT_POWERSETTINGCHANGE &gt; GUID_CONSOLE_DISPLAY_STATE が取れるように登録
*{if (msg == WM_POWERBROADCAST){switch (wParam.ToInt32()){case PBT_POWERSETTINGCHANGE:var pbs = (POWERBROADCAST_SETTING)Marshal.PtrToStructure(lParam, typeof(POWERBROADCAST_SETTING));if (pbs.PowerSetting == GUID_CONSOLE_DISPLAY_STATE){if (pbs.Data == 0) Debug.WriteLine("--Display OFF");else                        Debug.WriteLine("--Display ON");}break;}}return IntPtr.Zero;}
メッセージループを記述したメソッド

*await ss.WaitAsync();
B     Aが先に実行される（非同期）
*list.Add(   Task.Run(   () =>; {Thread.Sleep(100);Console.WriteLine("-");ss.Release();}));
ss.Wait();                C     Aが後に実行される（同期）

*[MessagePack.Union(2, typeof(TargetClass<;GenericClass_2<;))]
対応させる必要クラス分、Unionをこの要領で追加すること
*{private static readonly global::System.Collections.Generic.Dictionary<;Type, int>; lookup;static GeneratedResolverGetFormatterHelper(){lookup = new global::System.Collections.Generic.Dictionary<;Type, int>;(193){// 中略{ typeof(global::TestClass.TargetClass<;global::GenericClass_0>;), 30 },{ typeof(global::TestClass.TargetClass<;global::GenericClass_1>;), 31 },{ typeof(global::TestClass.TargetClass<;global::GenericClass_2>;), 32 },// 後略,,,*{ typeof(global::TestClass.TargetClass<;global::GenericClass_0>;), 30 },{ typeof(global::TestClass.TargetClass<;global::GenericClass_1>;), 31 },{ typeof(global::TestClass.TargetClass<;global::GenericClass_2>;), 32 },// 後略,,,
appSettings.jsonのTest1キーが9999時は0が返却される
*Assert.AreEqual(0, target.WriteNumber());
appSettings.jsonのTest1キーが9999以外の時は1が返却される
*Assert.AreEqual(1, target.WriteNumber());

*var group = range.Group();
&lt;-- ここで落ちる

*AppTheme apptheme;
AppTheme:enum Dark, Light

ExecuteSqlRawとSaveChangesの部分を以下のように変更しました。
*dbContext.Database.OpenConnection();

*{reference.InstantiateAsync();}
Start is called before the first frame update

クエリ作成
*parameters.ADD("token",["トークン"]);
リクエストを送信し、レスポンスを取得
byte[] responceByte = client.Upload.Values("https:slack.com/api/chat.getPermalink",parameters)
*string responceStr = Encoding.UTF8.GetDtring(responceByte);
取得したメッセージのURLを返す
*return (responce.permalink);

*[DataType(DataType.Date)]
DataTypeの指定
*// To protect from overposting attacks, enable the specific properties you want to bind to.*// For more details, see http://go.microsoft.com/fwlink/?LinkId=317598.
POST: Salaries/Create
追加ここから
*salary.RegisterDate = DateTime.Now;
*if (ModelState.IsValid)*{
追加ここまで

*{foreach (object o in vs){try{A v = (A)o;}catch{}}}
tryとcatchで囲って()キャストする方法
*{foreach (object o in vs){A v = o as A;if (v == null) { }}}
asキーワードで変換してからnullチェックする方法
*{foreach (object o in vs){if (o is A v) { }}}
isキーワードで変換できるかをチェックし、そのまま変換する方法
*{foreach (object o in vs){if (o is A){A v = (A)o;}}}
isキーワードでチェックしてから()キャストする方法
*{foreach (object o in vs){if (o is A){A v = o as A;}}}
isキーワードでチェックしてからasキーワードで変換する方法
*{int separator = (int)(percentageOfA / 100f * ss.Length);object[] vs = ss.Select((s, i) =>; i <; separator ? (object)new A(s) : new B(s)).ToArray();Console.WriteLine($"{percentageOfA}%");Console.WriteLine($"Cast:\t\t{Measure(count, () =>; Cast(vs))}");Console.WriteLine($"AsIf:\t\t{Measure(count, () =>; AsIf(vs))}");Console.WriteLine($"IfIs:\t\t{Measure(count, () =>; IfIs(vs))}");Console.WriteLine($"IfIsCast:\t{Measure(count, () =>; IfIsCast(vs))}");Console.WriteLine($"IfIsAs:\t\t{Measure(count, () =>; IfIsAs(vs))}");Console.WriteLine();}
５つの変換方法を試す
*{Random random = new Random();for (int i = 0; i <; ss.Length; i++){int length = random.Next(10);for (int j = 0; j <; length; j++){ss[i] += (char)random.Next('A', 'z');}}Console.WriteLine($"count:\t{count}");Console.WriteLine($"length:\t{ss.Length}");Console.WriteLine();TryMethods(0);TryMethods(20);TryMethods(40);TryMethods(60);TryMethods(80);TryMethods(100);}
エントリポイント
*{DateTime time = DateTime.Now;for (int i = 0; i <; count; i++){action();}return DateTime.Now - time;}
関数の処理にかかる時間を計測する

*async Task<;(bool, string)<; TryGetMessageAsync(Uri uri) {
(省略）}
何かしらのエラーが起きるメソッド。
*RaiseError();
全ての例外をcatchする。
復帰処理などを行う必要がある例外が発生した場合、後から原因が特定しにくいバグとなり得る。
*catch (Exception ex)
*{try{RaiseError();}catch (Exception ex){Console.WriteLine($"Failed to {nameof(Rethrow)}. : {ex.Message}");// throw exとは書いてはいけない。StackTraceが消えるため。throw;}}
ログを出力のためにcatchし、再throwする。
throw exとは書いてはいけない。StackTraceが消えるため。
*throw;
*{try{RaiseError();}catch (Exception ex){// catchしたExceptionはInnerExceptionにする。throw new OriginalException($"Original exception occurred", ex);}}
別の例外に変換する
catchしたExceptionはInnerExceptionにする。
*throw new OriginalException($"Original exception occurred", ex);
*{try{RaiseError();}catch (Exception ex){// HandleErrorメソッドできちんと処理が行われることが前提。極力使わない。HandleError(ex);}}
独自のエラーハンドリングをする。
HandleErrorメソッドできちんと処理が行われることが前提。極力使わない。
*HandleError(ex);

デバッグ時のみ、プロセスにアタッチ
*System.Diagnostics.Debugger.Launch();
*if (args.Length >; 0 &amp;&amp; args[0].IndexOf("chrome-extension") >;= 0)*{
起動処理の確認（Chrome拡張機能 or その他（直接起動））
Chrome拡張機能
*NativeMessageFlg = true;
その他（直接起動）
*NativeMessageFlg = false;
Chrome拡張機能から取得
*Stream stdin = Console.OpenStandardInput();
Chrome拡張機能から受け取った「Action」によって処理を分ける
*Response response = new Response();

C#9.0以降のトップレベルステートメントを利用しています
*using System;
カレントカルチャ（日本）に依存する比較
*Console.WriteLine(string.Compare(str1, str2));
カレントカルチャ（日本）に依存しない比較
*Console.WriteLine(string.Compare(str1, str2, StringComparison.Ordinal));
カレントカルチャ（日本）に依存する比較
*Console.WriteLine(string.Compare(str1, str3));
カレントカルチャ（日本）に依存しない比較（大文字小文字を区別しない）
*Console.WriteLine(string.Compare(str1, str3, StringComparison.OrdinalIgnoreCase));

以下のドキュメントが参考になった。
CreateWithUserで特定のユーザとしてクレデンシャルを作成すると401にならない。
https:github.com/googleapis/google-api-dotnet-client/issues/1629
*var credential = GoogleCredential.FromFile(JsonPath).CreateScoped(Scopes).CreateWithUser(User);
*{HttpClientInitializer = credential,ApplicationName = ApplicationName,});
Create Reports API service.

*{public string name;public int age;//情報は直接変数にアクセスできない様にメソッド化するpublic Info(string name, int age){this.name = name;this.age = age;}}
ここのクラスに情報をまとめる
*{this.name = name;this.age = age;}
情報は直接変数にアクセスできない様にメソッド化する
今回はコンソールから入力したものとする
入力回数を指定
*var N = int.Parse(Console.ReadLine());
*Info[] src = new Info[] { };
Infoクラスをインスタンス化
操作しやすい様に格納するListを生成
*var list = new List<;Info>;();
*for (int i = 0; i <; N; i++)*{
コンソールからの入力をForループで可変長にする
*src = new Info[] { new Info(baseArray[0],intData) };
Info型の変数srcに新規内容として格納
listに要素を都度追加
*list.AddRange(src);
listをソート
*var c = new Comparison<;Info>;(Compare);
降順にしたい場合はReverseメソッドを使用
list.Reverse();
*Console.WriteLine("以下からがソート済の内容です");
xには２つの値の差が入る
*var x = a.age - b.age;

*"https:
management.core.windows.net{0}serviceshostedservices{1}deploymentslots{2}",
リクエスト出す
*HttpWebResponse response = (HttpWebResponse)request.GetResponse();
*if (response.StatusCode == HttpStatusCode.OK)*{
Status == OK なら呼び出し成功している
ここまできたら、body のなかに応答の XML が入っているので煮るなり焼くなりご自由に。
クエリをかけるときには、名前空間付きの XML であることに要注意です。
*}

*using Microsoft.Data.Sqlite;
ここを追加
--- ここから追加 ---
*const string dbName = "sample.db";
--- ここまで追加 ---
*}

*{
-360~0

`WixSharp.Project`に対する便利拡張メソッドを使用するため
using WixSharp.CommonTasks;
*var project = new WixSharp.Project("ProjectName");
コンストラクタ時に追加
*var dir = new Dir(new WixSharp.Id("DirID"), "%ProgramFiles%Hoge",
後から追加
ここで設定するIdはWixSharp上のIDで、MSIのコンポーネントに設定するGUIDのIDは別途設定されることに注意
*dir.Add(new WixSharp.File(new WixSharp.Id("File2"), "path/to/source2"));
プロジェクトインスタンスに追加
*project.Add(dir);
WixSharp側で参照するための名前を設定する
デフォルトはメソッド名がそのまま使われる
*[CustomAction("Method1")]
*{// MSIのログに出力session.Log("in customaction");// MSIプロパティを設定する// Execute=immediateの時に使えるが、他の場合は無視されるsession["A_PROPERTY"] = "ABCDE";// MSIプロパティを取得する// Execute=immediateの時に使えるが、他の時はnullになるstring propb = session["B_PROPERTY"];// CustomActionDataを取得する// Execute=deferredの時に、ここに値が入り、そうでないときはnullstring caData = session.CustomActionData;return ActionResult.Success;}
例外等エラーが起きてcatchしないと、制御が効かずにそのまま終わる可能性があるので注意
MSIのログに出力
*session.Log("in customaction");
MSIプロパティを設定する
Execute=immediateの時に使えるが、他の場合は無視される
*session["A_PROPERTY"] = "ABCDE";
MSIプロパティを取得する
Execute=immediateの時に使えるが、他の時はnullになる
*string propb = session["B_PROPERTY"];
CustomActionDataを取得する
Execute=deferredの時に、ここに値が入り、そうでないときはnull
*string caData = session.CustomActionData;
カスタムアクションメソッドが入っているアセンブリを指定する
%this%は、このプロジェクトのアセンブリを意味する特別な文字列(デフォルトは%this%)
*ActionAssembly = "%this%",
ActionAssemblyに、DTFとシステムアセンブリ以外の依存がある場合、ここにもれなく記述する
*RefAssemblies = new string[],
Execute=deferredの時、ここにプロパティ名をカンマ区切りで入れる必要がある
こうすると、CustomActionDataに"A_PROPERTY=[A_PROPERTYの値];B_PROPERTY=[B_PROPERTYの値]"のように、値が格納される
*UsesProperties = "A_PROPERTY,B_PROPERTY",

１．共通クラスライブラリ（DLL）
ネットのどこかにあるDebugLogのオーバーラップクラス
*using UnityEngine;
UnityのどこかのDebugLog出力ソースコード
参照設定やUsingは不要（でーん！）
*protected override void Initialize()
*{Ground.In.Value = level;}
ログ出力レベルの変更

PdfDocument obejctを作成します。
*PdfDocument doc = new PdfDocument();
PDFをロードします。
*doc.LoadFromFile(@"C:\Users\Administrator.SD-20151030NEMY\Desktop\java输出\吾輩.pdf");
スタンプを作成するページを取得します。
*PdfPageBase page = doc.Pages[4];
テンプレートオブジェクトを作成します。
*PdfTemplate template = new PdfTemplate(180, 50);
フォントを設定します。
*PdfCjkStandardFont font1 = new PdfCjkStandardFont(PdfCjkFontFamily.SinoTypeSongLight, 16f, PdfFontStyle.Bold | PdfFontStyle.Italic);
ソリッドブラシとグラデーションブラシを作成します。
*PdfSolidBrush brush = new PdfSolidBrush(Color.Purple);
角丸長方形のパスを作成します。
*int CornerRadius = 10;
テンプレートで角丸長方形のパスを描き、グラデーションで塗りつぶします。
*template.Graphics.DrawPath(gradientBrush, path);
テンプレートで角丸長方形のパスを描き、紫色でパスを塗りつぶします。
*template.Graphics.DrawPath(PdfPens.Purple, path);
テンプレートでテキスト、ユーザー名と日付を描きます。
*String s1 = "検証済みです。";
PdfRubberStampAnnotationオブジェクトを作成し、そのサイズを設定します。
*PdfRubberStampAnnotation stamp = new PdfRubberStampAnnotation(new RectangleF(new PointF(page.ActualSize.Width - 250, 200), template.Size));
PdfApperanceオブジェクトを作成し、テンプレートをnormalにします。
*PdfAppearance apprearance = new PdfAppearance(stamp);
スタンプでPdfApperanceオブジェクトを適用します。
*stamp.Appearance = apprearance;
スタンプをPdfAnnotationに追加します。
*page.AnnotationsWidget.Add(stamp);
保存します。
*doc.SaveToFile("output.pdf", FileFormat.PDF);

*public int Id { get; set; }
ID
受給者
*[Display(Name ="受給者")]
タイプ（給与、賞与）
*[Display(Name = "給与/賞与")]
支給日
*[Display(Name = "支給日")]
支給額
*[Display(Name = "支給額")]
*public decimal TravelExpence { get; set; }
交通費
*public decimal HealthInsurancePremium { get; set; }
健康保険料
*public decimal WelfarePension { get; set; }
厚生年金料
*public decimal EmploymentInsurancePremium { get; set; }
雇用保険料
*public decimal IncomeTax { get; set; }
所得税
*public decimal ResidentTax { get; set; }
住民税
*public decimal TotalPaymentAmount { get; set; }
総支給
*public decimal OvertimeAllowance { get; set; }
時間外手当
*public decimal MidnightAllowance { get; set; }
深夜手当
*public decimal HolidayAllowance { get; set; }
休日手当
*public string Remarks { get; set; }
備考
*public DateTime RegisterDate { get; set; }
登録日時
*public string RegisterUser { get; set; }
登録ユーザID
*public DateTime UpdateDate { get; set; }
更新日時
*public string UpdateUser { get; set; }
更新ユーザID

*double MaxFolder = 9999;
実際のフォルダ数はMaxFolder設定値+1となる。
作成日時の設定（現在の時間にする）
*System.IO.Directory.SetCreationTime(BasePath + "新しいフォルダー", DateTime.Now);
更新日時の設定
*System.IO.Directory.SetLastWriteTime(BasePath + "新しいフォルダー", DateTime.Now);
アクセス日時の設定
*System.IO.Directory.SetLastAccessTime(BasePath + "新しいフォルダー", DateTime.Now);
作成日時の設定（現在の時間にする）
*System.IO.Directory.SetCreationTime(BasePath + "新しいフォルダー(" + i + ")", DateTime.Now);
更新日時の設定
*System.IO.Directory.SetLastWriteTime(BasePath + "新しいフォルダー(" + i + ")", DateTime.Now);
アクセス日時の設定
*System.IO.Directory.SetLastAccessTime(BasePath + "新しいフォルダー(" + i + ")", DateTime.Now);

*await UniTask.WaitUntil(() =<; fetchBigDataList.All(i =<; i.IsReadyToLoad));
条件がfalseの間await

*ctx.SetIdentityServerOrigin("https:
foo.com");
... 略 ...
*}

*if (args.Length == 0)*{
Load commands from plugins
*foreach (ICommand command in commands)*{
Output the loaded commands.

pickerに演算子をセット
*picker.ItemsSource = operators;
初期値は"+"
*picker.SelectedIndex = 0;

認証情報
*var tokens = CoreTweet.Tokens.Create(apiKey, apiSecretKey, accessToken, accessTokenSecret);
大阪のトレンド情報取得
var TrendsJson = tokens.Trends.Place(15015370); Osaka
JSONデータを取得
*string JsonData = TrendsJson.Json.ToString();
*JsonData = "{ json_data: " + JsonData + "}";
うまくデシリアライズできないので、ちょとデータ加工。。
URLデコードする
*string UrlDec = System.Web.HttpUtility.UrlDecode(JsonData);
JSON文字列をデシリアライズ
*Root TrendData = JsonConvert.DeserializeObject<;Root>;(UrlDec);
練習数
*int DataCnt = 3;
ツイート
*tokens.Statuses.Update(status =>; DataCnt + "単語のフリック練習スタート！😤");
1秒待つ
*Thread.Sleep(1000);
取得トレンド総数
*int TrendCnt = TrendData.json_data[0].trends.Count;
ランダム数値生成
*Random Rnd = new Random();
トレンド文字列取得
*string TrendText = TrendData.json_data[0].trends[TrendRdm].query;
#はいらないので置換
*TrendText = TrendText.Replace("#","");
ツイート
*tokens.Statuses.Update(status =>; "【" + (idx + 1) + "】" + TrendText);
1秒待つ
*Thread.Sleep(1000);
ツイート
*tokens.Statuses.Update(status =>; "終了🥴");

*private Dictionary<;string, TimeRecordItem>; TimeRecordDic { get; set; }
Property
*{if (key == null) key = new System.Diagnostics.StackFrame(1).GetMethod().Name;if (!string.IsNullOrEmpty(suffix)) key = string.Join("_", key, suffix);if (!TimeRecordDic.ContainsKey(key)) TimeRecordDic.Add(key, new TimeRecordItem(key, DateTime.Now));else if (TimeRecordDic[key].IsEnd) TimeRecordDic[key].AddTimeSets(DateTime.Now);else TimeRecordDic[key].TimeSets.Last().SetEndTime(DateTime.Now);}
Public Method
*{var TimeSets = new List<;TimeSet>;();foreach (var item in TimeRecordDic.Values){TimeSets.AddRange(item.TimeSets);}foreach (var r in TimeSets.OrderBy(rr =>; rr.StartTime)){yield return string.Join(",", ClassName, r.Key, r.StartTime.ToString(), r.EndTime.ToString(), r.ExecutionTime.ToString());}}
Private Method
*{TimeRecordDic = new Dictionary<;string, TimeRecordItem>;();ClassName = new System.Diagnostics.StackFrame(1).GetMethod().ReflectedType.FullName;}
Constructor
*{//Propertypublic string Key { get; private set; }public List<;TimeSet>; TimeSets { get; private set; }public bool IsEnd {  get { return TimeSets.Last().EndTime != null; } }//Public Methodpublic void AddTimeSets(DateTime time){TimeSets.Add(new TimeSet(Key, time));}//Constructorpublic TimeRecordItem(string key, DateTime time){Key = key;TimeSets = new List<;TimeSet>; { new TimeSet(Key, time) };}}
Private Class
*public string Key { get; private set; }
Property
*{TimeSets.Add(new TimeSet(Key, time));}
Public Method
*{Key = key;TimeSets = new List<;TimeSet>; { new TimeSet(Key, time) };}
Constructor
*public string Key { get; private set; }
Property
*{EndTime = time;}
Public Method
*{Key = key;StartTime = time;}
Constructor

*<;ResourceDictionary Source="pack:
application:,,,MahApps.Metro;componentStylesThemesLight.Blue.xaml" &gt;
colorを設定ファイルから呼び出します
*var color = GetCurrentColor();
SetThemeの代わりにcolorも設定できるようにしたSetThemeAndColorを呼び出します
*SetThemeAndColor(theme, color);
*{if (App.Current.Properties.Contains("Color")){Color color = (Color)ColorConverter.ConvertFromString(App.Current.Properties["Color"].ToString());return color;}else{return Colors.Blue;}}
カラー設定を呼び出す
*{if (theme == AppTheme.Default){ThemeManager.Current.ThemeSyncMode = ThemeSyncMode.SyncAll;ThemeManager.Current.SyncTheme();ThemeManager.Current.ChangeTheme(Application.Current, ThemeManager.Current.AddTheme(RuntimeThemeGenerator.Current.GenerateRuntimeTheme("Light", color)));}else{ThemeManager.Current.ThemeSyncMode = ThemeSyncMode.SyncWithHighContrast;ThemeManager.Current.SyncTheme();ThemeManager.Current.ChangeTheme(Application.Current, ThemeManager.Current.AddTheme(RuntimeThemeGenerator.Current.GenerateRuntimeTheme(theme.ToString(), color)));}App.Current.Properties["Theme"] = theme.ToString();App.Current.Properties["Color"] = color.ToString();}
テーマ・カラーの両方を設定する

*xmlns:materialDesign="http:
materialdesigninxaml.netwinfxxamlthemes"

*public Stroke? Stroke { get; set; } = new Stroke(Color.Black, 1f);
外観は白で塗りつぶし、黒の輪郭（既定値）
リサイズハンドルではDragメソッドは使用しない
*throw new NotImplementedException();
*protected ResizeHandleCollection ResizeHandles { get; set; }
...(省略)
ResizeHandleColection作成後、Boundsに合わせて配置
*ResizeHandles = new ResizeHandleCollection(8, 8);
ResizeHandleColection作成後、Boundsに合わせて配置
*ResizeHandles = new ResizeHandleCollection(8, 8);
*{if (Fill is not null){g.FillRectangle(Bounds, Fill);}if (Stroke is not null){g.DrawRectangle(Bounds, Stroke);}//リサイズハンドルをまとめて描画ResizeHandles.Draw(g);}
...(省略)
リサイズハンドルをまとめて描画
*ResizeHandles.Draw(g);
リサイズハンドルにヒットしたらそのハンドルのHitResultを返却
図形本体にヒットしたらHitResult.Bodyを返却
ヒットしなかった場合はHitResult.Noneを返却
*var hitResult = ResizeHandles.HitTest(p);
ResizeHandleがActive(=ドラッグ対象)の場合
ハンドルのResize()メソッドを実行して、結果をRoundsに設定する
*if (ResizeHandles.ActiveHandle is not null)
ハンドル以外では、図形全体の移動処理を行う
*var (dx, dy) = (currentPointer.X - oldPointer.X, currentPointer.Y - oldPointer.Y);
図形の座標（Bounds）変更時、それに合わせてリサイズハンドルの位置も更新する
*Bounds = bounds;
*{case HitResult.Body:Cursor = Cursors.SizeAll;break;case HitResult.ResizeN:case HitResult.ResizeS:Cursor = Cursors.SizeNS;break;case HitResult.ResizeE:case HitResult.ResizeW:Cursor = Cursors.SizeWE;break;case HitResult.ResizeNW:case HitResult.ResizeSE:Cursor = Cursors.SizeNWSE;break;case HitResult.ResizeNE:case HitResult.ResizeSW:Cursor = Cursors.SizeNESW;break;}
ヒットした部位に応じてカーソルの形状を変更する

*public string Beneficiary { get; set; }
受給者
*public string PaymentType { get; set; }
タイプ（給与、賞与）
*public DateTime PaymentDate { get; set; }
支給日
*public decimal PaymentAmount { get; set; }
支給額
*public decimal TravelExpence { get; set; }
交通費
*public decimal HealthInsurancePremium { get; set; }
健康保険料
*public decimal WelfarePension { get; set; }
厚生年金料
*public decimal EmploymentInsurancePremium { get; set; }
雇用保険料
*public decimal IncomeTax { get; set; }
所得税
*public decimal ResidentTax { get; set; }
住民税
*public decimal TotalPaymentAmount { get; set; }
総支給
*public decimal OvertimeAllowance { get; set; }
時間外手当
*public decimal MidnightAllowance { get; set; }
深夜手当
*public decimal HolidayAllowance { get; set; }
休日手当
*public string Remarks { get; set; }
備考
*public DateTime RegisterDate { get; set; }
登録日時
*public string RegisterUser { get; set; }
登録ユーザID
*public DateTime UpdateDate { get; set; }
更新日時
*public string UpdateUser { get; set; }
更新ユーザID
*public int Id { get; set; }
ID
*public string Beneficiary { get; set; }
受給者
*public string PaymentType { get; set; }
タイプ（給与、賞与）
*public DateTime PaymentDate { get; set; }
支給日
*public decimal PaymentAmount { get; set; }
支給額
*public decimal TravelExpence { get; set; }
交通費
*public decimal HealthInsurancePremium { get; set; }
健康保険料
*public decimal WelfarePension { get; set; }
厚生年金料
*public decimal EmploymentInsurancePremium { get; set; }
雇用保険料
*public decimal IncomeTax { get; set; }
所得税
*public decimal ResidentTax { get; set; }
住民税
*public decimal TotalPaymentAmount { get; set; }
総支給
*public decimal OvertimeAllowance { get; set; }
時間外手当
*public decimal MidnightAllowance { get; set; }
深夜手当
*public decimal HolidayAllowance { get; set; }
休日手当
*public string Remarks { get; set; }
備考
*public DateTime RegisterDate { get; set; }
登録日時
*public string RegisterUser { get; set; }
登録ユーザID
*public DateTime UpdateDate { get; set; }
更新日時
*public string UpdateUser { get; set; }
更新ユーザID

Handleにアクセス
*typeof(T).TypeHandle;
IntPtrにアクセス
*typeof(T).TypeHandle.Value;
100をdataの中に入れる
*int data = (int)(object)100;
先頭の16byte分ずらしたところから8byte分だけ切り取る
*nested_ptr_arr [i] = *((byte*)data_ptr + 16 + i);

*if (wParam.ToInt32() == 0) {
なにかする(※WM_PAINTはwParamもlParamもなにも入ってない) }

これを表示していく
*public record Item(int X, int Y, string Content);
*private Random Random { get; } = new();
表示位置をランダムにするための Random クラス
ランダムな位置に、とりあえず現在時間の文字列を出すようなデータを作る
*Items.Add(new(Random.Next(500), Random.Next(500), DateTime.Now.ToString()));
*if (navigationContext.Parameters.TryGetValue<;int>;("x", out var x))*{
パラメーターから表示位置や表示する内容を取得してプロパティに保持
ここで true を返すとナビゲーション時に View が再利用されるので断固拒否
*public bool IsNavigationTarget(NavigationContext navigationContext) =>; false;

値がひとつだけの場合
*var single = Console.ReadLine();
複数ある場合
*var multiple = Console.ReadLine().Split(",");

... ここで ToListAsync()とかやる
*}

*Debug.Log(ObjectNames.NicifyVariableName("<;Level>;k__BackingField"));*,,,
Levelと表示された
*public int Level { get; private set; }
こんなことができればよかったのに

*byte[] responseBytes = client.UploadFile("https:
slack.comapifiles.upload",Filename);
結果を取得
*String responseString = Encoding.UTF8.GetString(responseBytes);

sourcesの要素を変換したコレクションを生成
*var targets = sources.Select(sourceToTarget).ToObservableCollection();
2つのコレクションを同期させる
*SyncCollectionTwoWay(sources, targets, sourceToTarget, targetToSource);
同期済みのコレクションを返す
*return targets;
変更イベントループしてしまわないように、ローカル変数(isChanging)でチェック
ローカル変数(isChanging)にアクセスするため、ローカル関数で記述
*void ExcuteIfNotChanging(Action action)

*Console.WriteLine(task.Result);
(4)

*if ((checkCount &amp; 1) == 0)*{
視認性の向上。クリップボードの操作を行うたびに背景とテキストの色が反転する。
*if (Clipboard.ContainsText())*{
適当な感覚でクリップボードを監視する。
クリップボードに対して何らかの処理を行う場所。
*nextText.Text = nextClipBoard;

*Console.WriteLine(gengoName);
平成

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

*Animator animator;
ToDo: - enable to access animator
*{return 5.0f;}
SETTING
*{return new Input[]{new DefaultW (),new DefaultA (),new DefaultS (),new DefaultD (),new DefaultSpace (),new DefaultI (),new DefaultL (),new DefaultJ (),new DefaultK ()};}
keys to input
*virtual public GameObject forwardAnchor ()*{
anchor object for definition the forward derection
*if (this.isGrounded () &amp;&amp; this.ySpeed <; 0)*{
refresh ySpeed
*foreach (var input in this.inputs)*{
check input
*{public bool isGrounded (){return this.controller.isGrounded;}public To direction (){var form = this.transform;var diffF = (-(this.fAnchorTransform.forward) - form.forward).sqrMagnitude;var diffL = (this.fAnchorTransform.right - form.forward).sqrMagnitude;var diffB = (this.fAnchorTransform.forward - form.forward).sqrMagnitude;var diffR = (-(this.fAnchorTransform.right) - form.forward).sqrMagnitude;var minDiff = diffF;var minTo = To.F;if (diffL <; minDiff){minDiff = diffL;minTo = To.L;}if (diffB <; minDiff){minDiff = diffB;minTo = To.B;}if (diffR <; minDiff){minDiff = diffR;minTo = To.R;}return minTo;}public void move (To to, float dTime){var direction = Vector3.zero;switch (to){case To.F:direction = this.fAnchorTransform.forward;break;case To.L:direction = -(this.fAnchorTransform.right);break;case To.B:direction = -(this.fAnchorTransform.forward);break;case To.R:direction = this.fAnchorTransform.right;break;}var v3 = direction * this.moveSpeed ();this.controller.Move (v3 * dTime);}public void jump (){if (this.isGrounded ()){this.ySpeed += Mathf.Sqrt (this.jumpHeight () * 3.0f * this.gravity ());}}public void turn (To to){var direction = Vector3.zero;switch (to){case To.F:direction = this.fAnchorTransform.forward;break;case To.L:direction = -(this.fAnchorTransform.right);break;case To.B:direction = -(this.fAnchorTransform.forward);break;case To.R:direction = this.fAnchorTransform.right;break;}var v3 = new Vector3 (direction.x, 0, direction.z);this.mainCamera.transform.parent = null;this.transform.forward = -(v3);this.mainCamera.transform.parent = this.transform;}public void lookL (float deltaTime){this.mainCamera.transform.RotateAround (this.transform.position, -(Vector3.up), this.lookSpeed () * deltaTime);}public void lookR (float deltaTime){this.mainCamera.transform.RotateAround (this.transform.position, Vector3.up, this.lookSpeed () * deltaTime);}public void lookU (float deltaTime){this.mainCamera.transform.RotateAround (this.transform.position, -(this.fAnchorTransform.right), this.lookSpeed () * deltaTime);}public void lookD (float deltaTime){this.mainCamera.transform.RotateAround (this.transform.position, this.fAnchorTransform.right, this.lookSpeed () * deltaTime);}}
***************************************************************
*{public KeyControl key (){return current.wKey;}public void onStart (IPlayer player){player.turn (To.F);}public void onMiddle (IPlayer player, float deltaTime){player.move (To.F, deltaTime);}public void onEnd (IPlayer player){}}
W (default)
*{public KeyControl key (){return current.aKey;}public void onStart (IPlayer player){player.turn (To.L);}public void onMiddle (IPlayer player, float deltaTime){player.move (To.L, deltaTime);}public void onEnd (IPlayer player){}}
A (default)
*{public KeyControl key (){return current.sKey;}public void onStart (IPlayer player){player.turn (To.B);}public void onMiddle (IPlayer player, float deltaTime){player.move (To.B, deltaTime);}public void onEnd (IPlayer player){ }}
S (default)
*{public KeyControl key (){return current.dKey;}public void onStart (IPlayer player){player.turn (To.R);}public void onMiddle (IPlayer player, float deltaTime){player.move (To.R, deltaTime);}public void onEnd (IPlayer player){ }}
D (default)
*{public KeyControl key (){return current.spaceKey;}public void onStart (IPlayer player){player.jump ();}public void onMiddle (IPlayer player, float deltaTime){ }public void onEnd (IPlayer player){ }}
Space (default)
*{public KeyControl key (){return current.iKey;}public void onStart (IPlayer player){ }public void onMiddle (IPlayer player, float deltaTime){player.lookU (deltaTime);}public void onEnd (IPlayer player){ }}
I (default)
*{public KeyControl key (){return current.kKey;}public void onStart (IPlayer player){ }public void onMiddle (IPlayer player, float deltaTime){player.lookD (deltaTime);}public void onEnd (IPlayer player){ }}
K (default)
*{public KeyControl key (){return current.lKey;}public void onStart (IPlayer player){ }public void onMiddle (IPlayer player, float deltaTime){player.lookR (deltaTime);}public void onEnd (IPlayer player){ }}
L (default)
*{public KeyControl key (){return current.jKey;}public void onStart (IPlayer player){ }public void onMiddle (IPlayer player, float deltaTime){player.lookL (deltaTime);}public void onEnd (IPlayer player){ }}
J (default)

ChatRPC RPC呼出側：送信者　RPC受信g側：受信者
*[PunRPC]
*{//送信者の名前用変数string senderName = "anonymous";if (mi.Sender != null){//送信者の名前があれば、、、IsNullOrEmptyはNullか空でTrueif (!string.IsNullOrEmpty(mi.Sender.NickName)){senderName = mi.Sender.NickName;}else{senderName = "player " + mi.Sender.UserId;}}//受信したチャットをログに追加showText.text = senderName + ": " + newLine;}
Vector3 senderposition,
送信者の名前用変数
*string senderName = "anonymous";
*if (!string.IsNullOrEmpty(mi.Sender.NickName))*{
送信者の名前があれば、、、IsNullOrEmptyはNullか空でTrue
受信したチャットをログに追加
*showText.text = senderName + ": " + newLine;

ハンバーガーボタンがONの状態ならメニューを開く
*Menu.IsPaneOpen = (sender as ToggleButton)?.IsChecked == true;
Tagに設定された文字サイズをメインコンテンツのテキストに設定
*MainContent.TxtContent.FontSize =

*if(SaveTrigger == 1)*{
保存が押された時の座標を保存
常にマーカーを描画
*e.Graphics.FillPolygon(semiTransBrush, curvePoints);

*{// 終了待ちjar.WaitForExit();// 結果取得(0:正常終了)if (jar.ExitCode == 0) result = true;}
.jarをプロセスとして起動
終了待ち
*jar.WaitForExit();
*if (jar.ExitCode == 0) result = true;*}
結果取得(0:正常終了)
コマンドプロンプトを表示して実行する場合
*Process.Start("java", "-jar (.jarファイル名orパス) (引数) (引数)…"))
コマンドプロンプトを表示せずに実行する場合
*Process.Start("javaw", "-jar (.jarファイル名orパス) (引数) (引数)…"))
終了待ち
*jar.WaitForExit();
結果取得(0:正常終了)
*jar.ExitCode();

*{//ControllerBaseクラスを継承しているため、その中のRequestプロパティを利用。Request.Headers.TryGetValue("TEST", out var extractedApiKey);if (string.IsNullOrEmpty(extractedApiKey)){return Unauthorized();}var rng = new Random();return Enumerable.Range(1, 5).Select(index =>; new WeatherForecast{Date = DateTime.Now.AddDays(index),TemperatureC = rng.Next(-20, 55),Summary = Summaries[rng.Next(Summaries.Length)]}).ToArray();}
エラー時の対処のために戻り値の型をActionResultで囲っています。
ControllerBaseクラスを継承しているため、その中のRequestプロパティを利用。
*Request.Headers.TryGetValue("TEST", out var extractedApiKey);

*[Table("Authors")]
←追加
*using (var db = new AuthorContext()) {// スキーマとかテーブルが無かったら作るよ。db.Database.EnsureCreated();//サンプルに山田さんを100人for (var j = 0; j <; 100; j++) {//AuthorIdは自動採番されるので未指定でいいよdb.Authors.Add(new Author{FirstName = "太郎",LastName = "山田",City = "東京",EmailAddress = "taro@tokyo.com",Salary = 10000000,Phone = "03-1234-4567"};);}// DBへ保存int recordsAffected = db.SaveChanges();// 順に取り出して表示foreach (var i in db.Authors) {Console.WriteLine("AuthorId: {0} , FirstName: {1} , LastName: {2}", i.AuthorId, i.FirstName, i.LastName);}// キー入力待ちConsole.ReadKey();}
コンテキスト・クラスを作成
スキーマとかテーブルが無かったら作るよ。
*db.Database.EnsureCreated();
*for (var j = 0; j <; 100; j++) {*//AuthorIdは自動採番されるので未指定でいいよ
サンプルに山田さんを100人
*{FirstName = "太郎",LastName = "山田",City = "東京",EmailAddress = "taro@tokyo.com",Salary = 10000000,Phone = "03-1234-4567"};);
AuthorIdは自動採番されるので未指定でいいよ
DBへ保存
*int recordsAffected = db.SaveChanges();
*foreach (var i in db.Authors) {*Console.WriteLine("AuthorId: {0} , FirstName: {1} , LastName: {2}", i.AuthorId, i.FirstName, i.LastName);
順に取り出して表示
キー入力待ち
*Console.ReadKey();
今は結果を返さないのでひとまずコメントアウト
var response = await ret.Content.ReadFromJsonAsync&lt;Author&gt;();
*}

*{return Observable.FromEvent<;InputAction.CallbackContext>;(h =>; inputAction.performed += h,h =>; inputAction.performed -= h).Select(x =>; x.ReadValue<;float>;()).ToReadOnlyReactiveProperty(0);}
Axis入力だと0等が反応しないためGetDeltaAxisPropertyのみの使用でもよさそうです
*{return Observable.EveryUpdate().Select(_ =>; inputAction.ReadValue<;float>;()).ToReadOnlyReactiveProperty(0);}
Delta入力はUpdate基準なのでUpdate基準に変換(主にマウスで使用)
ボタンに変換したIReactivePropertyを公開
*public IReadOnlyReactiveProperty<;bool>; Attack =>; attack;
Mouseの移動量に変換したIReactivePropertyを公開
*public IReadOnlyReactiveProperty<;float>; MouseX =>; mouseX;
Mouseの移動量に変換したIReactivePropertyを公開
*public IReadOnlyReactiveProperty<;float>; Horizontal =>; horizontal;

*await MouseActionMethod();
何かしらの処理を呼び出し

*date3.ToString("T");
12:24:36 PM

*Console.WriteLine(BitConverter.ToString(bytes));

デシリアライズ
*var human2 = new Human();

*graphicSwitch[a].FillRectangle(brush, 0, 0, canvasSwitch[a].Width, canvasSwitch[a].Height);
pictureBoxSwitchと同じサイズの四角形をGrayで塗りつぶし

*// {P1: a, P2: a} の重複が取り除かれていない
{P1: a, P2: a}{P1: a, P2: a}{P1: b, P2: b}{P1: b, P2: c}
*.GroupBy(x =>; new { x.P1, x.P2 })
{P1: a, P2: a} の重複が取り除かれていない

*.Replace("|", "{VBar}");
ADoc用
*if ( tag == "tr" ) {*sb.AppendLine("");
Console.WriteLine("&lt;/" + m.Groups[3].Value +"&gt;");

PPTファイルをロードします。
*Presentation ppt = new Presentation();
スライドを取得します。
*ISlide slide = ppt.Slides[0];
スライドに動画を挿入します。
*slide.Shapes.AppendVideoMedia(@"ビデオ.mp4", new RectangleF(300, 150, 300, 150));
PPTファイルをロードします。
*Presentation ppt = new Presentation();
*foreach (ISlide slide in ppt.Slides)*{
スライドをループします。
*foreach (IShape shape in slide.Shapes)*{
スライド内のシェイプをループします。
*if (shape is IVideo)*{
シェイプが動画なのか判断します。
*(shape as IVideo).EmbeddedVideoData.SaveToFile(string.Format(@"動画{0}.mp4", i));
動画を保存します。

*{...}
コルーチンは好きなように書く

配列サイズを１つ増やす
*Array.Resize(ref numbers, numbers.Length + 1);
numbersの配列長は配列カウント0スタートと違い1多いのでマイナス１
*numbers[numbers.Length - 1] = 7;
*//foreachの0番目の要素の値は4です。*//foreachの1番目の要素の値は5です。
〜出力結果〜
*//foreachの1番目の要素の値は5です。*//foreachの2番目の要素の値は6です。
foreachの0番目の要素の値は4です。
*//foreachの2番目の要素の値は6です。*//foreachの3番目の要素の値は7です。
foreachの1番目の要素の値は5です。
*//foreachの3番目の要素の値は7です。*,,,
foreachの2番目の要素の値は6です。
foreachの3番目の要素の値は7です。
*,,,
*class Car{//コンストラクタはpublic + class名と同じ名前で記載すること！(publicがないと外部クラスからアクセスできない)//     ↓↓↓public Car() {Console.WriteLine("Carクラスからコンストラクタとして呼び出されています");}static void Hello(string name){//このメソッドは呼び出されていないので出力されないConsole.WriteLine("Hi,{0}",name);}}
コンストラクタのためのCarクラス
*public Car() {Console.WriteLine("Carクラスからコンストラクタとして呼び出されています");}
コンストラクタはpublic + class名と同じ名前で記載すること！(publicがないと外部クラスからアクセスできない)
*public Car() {Console.WriteLine("Carクラスからコンストラクタとして呼び出されています");}
↓↓↓
*Console.WriteLine("Hi,{0}",name);
このメソッドは呼び出されていないので出力されない
出力結果
welcome!!
Carクラスからコンストラクタとして呼び出されています
*,,,
using System.Linq;が必要
空の配列を用意
*int[] numbers = new int[5];
*for (int i = 0; i <; 5; i++) {*numbers[i] = int.Parse (Console.ReadLine ());
今回はからの配列内にコンソールの入力値を格納
ex. 4 6 8 1 2 を入力
*}
*Console.WriteLine (”最大値：{0}”, numbers.Max ());
以下のMax,Minメソッドを使用するのにLinqが必要
〜出力結果〜
最大値:８
最小値:1
*}
出力結果
10の2乗は100になる
*,,,
まずは空のdictionary型を生成して変数に代入
&lt;&gt;内がKey, Valueの型になる(Key=string , Value=int)
*var myTable = new Dictionary<;string, int>;();
dictionary型の変数にkeyとvalueを追加
*myTable.Add("Hokkaido", 1);
Dictionary型のままでそれをForeachで回してもintを余剰加減できないのでListにする
*List<;string>; keyList = new List<;string>;(myTable.Keys);
*foreach (var item in keyList)*{
foreachで回すのは dictionaryでなく list
keyが一致した際のvalueを計算処理
*myTable[item] -= 1;
出力結果
Key:Hokkaido / Value:1
Key:Shimane / Value:2
Key:Aichi / Value:3
Key:Osaka / Value:8
*,,,
出力結果
1番目: A
2番目: B
3番目: C
||
略
||
24番目: X
25番目: Y
26番目: Z
*,,,
*bool[] line = new bool[] { true, true, true, false, false };
string[] line = new string[] {"a", "a", "a", "b", "c", "c"};
distinctメソッドにて、重複を省いたユニーク値の配列を用意。
(ex, ここではtrueとfalseの２種類のみ。　コメントアウトしている箇所だと、a,b,cの３種類のことを指す)
*var uniqArr = line.Distinct().ToArray();
*foreach (var x in uniqArr)*{
元の配列について、要素別にカウントして出力
uniqArrから元の配列の中の要素との重複をa == x の処理にて計算する
*Console.WriteLine(x + "=>;" + line.Count(a =>; a == x));
出力結果
True =&gt; 3
False =&gt; 2
*,,,
*Console.WriteLine("N = {0}", N);
.GetLength(1)の場合は 2 が取得できる
出力結果
N = 7
*,,,

*string secretName = "SecretName";
シークレット名

*public int baudRate = 115200;
ボーレート(Arduinoに記述したものに合わせる)

*uniTask.ToAsyncLazy();
AsyncLazyに変換
実装
*public static UniTask<;T>; ToUniTask<;T>;(this IObservable<;T>; source, bool useFirstValue = false, CancellationToken cancellationToken = default)
使用例
await subject.ToUniTask(cancellationToken:token);  OnCompletedが発行されるまで待つ
await subject.ToUniTask(true,token); 次に発行される最初のメッセージを待つ
*,,,
実装
*public static UniTask ToUniTask(this JobHandle jobHandle, PlayerLoopTiming waitTiming)
使用例
*await jobHandle;
CancellationTokenが指定できない
*await jobHandle.ToUniTask(PlayerLoopTiming.FixedUpdate);
指定したタイミングに切り替えてjobHandle.Complete();される
*await jobHandle.WaitAsync(PlayerLoopTiming.FixedUpdate,token);
実装
*public static UniTask<;AsyncGPUReadbackRequest>; ToUniTask(this AsyncGPUReadbackRequest asyncOperation, PlayerLoopTiming timing = PlayerLoopTiming.Update, CancellationToken cancellationToken = default(CancellationToken))

*var GetCommentsClient = new RestClient("https:
apiv2.twitcasting.tvmovies" + movie_id + "comments");
コメント情報を取得
*var GetCommentsresponse = GetCommentsClient.Execute(CommentsRequest);
レスポンスをデシリアライズ
*var JsonCommentsData = JsonSerializer.Deserialize<;Root>;(GetCommentsresponse.Content);
*foreach (var comment in JsonCommentsData.comments)*{
メッセージを取得
コンソールに出力
*Console.WriteLine(comment.message);

*// set of attributes. Change these attribute values to modify the information*// associated with an assembly.
General Information about an assembly is controlled through the following

*var partSum = jojo.Sum(el =<; el.Value.Part);
36

*CSharpArgumentInfo.Create(None, null),
0個目はダミーになる
*if (DelegateCache == null)*{
↓

*public const string GroupTitleHeader = "
";
EXEのパス取得
*string appPath = App.GetAppPath();
設定ファイルのフルパス組み立て
*string cfgFilePath = System.IO.Path.Combine(appPath, ConfigFileName);
*if (System.IO.File.Exists(cfgFilePath))*{
設定ファイル存在チェック
設定ファイルなし
*return string.Empty;

*main = lua.GetFunction("main");
実行する関数名

*Console.WriteLine(ReferenceEquals(s1, s2));
"false"
Exit時に Service と Reader も Dispose される。
*this.Exit += (_, _) =>; containerRegistry.GetContainer().Dispose();

*int paramLR = 140;
直角に傾けるくらいで左右モードにする
Xに係数をかけて左右のSpeedとする
*int ox = (int)(data.Orientation.X * 100 * paramX);
Yに係数をかけて前後のSpeedとする
*int oy = (int)(data.Orientation.Y * 100 * paramY);

コンソールからパラメーターを受け取る
*Console.WriteLine("bootstrap servers を入力してください（省略時 127.0.0.1）：");
キャンセルトークンを生成する
*using var cancelTokenSource = new CancellationTokenSource();
*{BootstrapServers = bootstrapServers};
動作設定を生成する
*{return new SampleMessageKey(Guid.NewGuid().ToString());}
キーを生成するメソッド
パブリッシャーを生成する
*var factory = new SampleMessagePublisherFactory(publisherSetting, new SampleLogger());
一定間隔でメッセージを発行する
*int sequence = 0;
コンソールからパラメーターを受け取る
*Console.WriteLine("bootstrap servers を入力してください（省略時 127.0.0.1）：");
キャンセルトークンを生成する
*using var cancelTokenSource = new CancellationTokenSource();
*{BootstrapServers = bootstrapServers,ConsumerGroupID = groupID};
動作設定を生成する
observable パターンでメッセージを監視する
*var factory = new SampleMessageSubscriberFactory(subscriberSetting, new SampleLogger());
*if (result.IsPartitionEOF) { continue; }*WriteLog(LogLevel.Debug, () =>; BuildLogMessage(result));
TODO: 今回の確認では IsPartitionEOF を発生させることができなかった。

1000行挿入ごとに少し待つ。
*await Task.Delay(deley);
1000行挿入ごとに少し待つ。
*await Task.Delay(deley);

*}).ToArray();
即時実行

*var rtb = new RenderTargetBitmap((int)width, (int)height, 96, 96, PixelFormats.Pbgra32);
Pbgra32である必要がある！！！
ビットマップにFrameworkElementの外観をまるごと描写する例
*VisualBrush brush = new VisualBrush(target);
testウィンドウにRenderTargetBitmapを表示する
*OpenCvSharpHelper.ImShow("test", rtb);

EV3に接続 (EV3上で'lejos-server'が動作している前提)
*var ev3 = new EV3("10.0.1.1", 6789);
ポートB/Cに接続されたLargeモーターを同時にスピード100で360度回転させる
*ev3.Wheels.GoForward(100, 360);

*{if (e.KeyData == Keys.Enter){// 画像貼り付けpictureBox1.Invalidate();}}
キーボード押下イベント
画像貼り付け
*pictureBox1.Invalidate();
*{return System.Windows.Forms.Cursor.Position.Y; ;}
マウスのY座標取得
*{// 座標取得int mouseY = GetMousePoint();Brush brush = new SolidBrush(Color.Black);PointF point1 = new PointF(0, mouseY - 10);PointF point2 = new PointF(pictureBox1.Width, mouseY - 10);PointF point3 = new PointF(pictureBox1.Width, mouseY);PointF point4 = new PointF(0, mouseY);PointF[] curvePoints ={point1,point2,point3,point4};for (int i = 0; i <; list.Count; i++){e.Graphics.FillPolygon(brush, list[i]);}// 古いcurvepointを保存するlist.Add(curvePoints);}
Paintイベント
座標取得
*int mouseY = GetMousePoint();
古いcurvepointを保存する
*list.Add(curvePoints);

EV3に接続 (EV3上で'lejos-server'が動作している前提)
*var ev3 = new EV3("10.0.1.1", 6789);
ポートB/Cに接続されたLargeモーターを同時にスピード100で360度回転させる
*ev3.Wheels.GoForward(100, 360);

*builder.AddFilter<;Microsoft.Extensions.Logging.ApplicationInsights.ApplicationInsightsLoggerProvider>;("", LogLevel.Information);*});
ログのフィルタを構成
*(config) =>; { config.TelemetryChannel = new InMemoryChannel(); });
テレメトリチャネルをInMemoryChannelに設定
サービスプロバイダーを構築
*IServiceProvider serviceProvider = services.BuildServiceProvider();
Loggerを取得
*ILogger<;Program>; logger = serviceProvider.GetRequiredService<;ILogger<;Program>;>;();
テレメトリクライアントを取得
*var telemetryClient = serviceProvider.GetRequiredService<;TelemetryClient>;();
*builder.AddFilter<;Microsoft.Extensions.Logging.ApplicationInsights.ApplicationInsightsLoggerProvider>;("", LogLevel.Information);*});
ログのフィルタを構成
*(config) =>; { config.TelemetryChannel = new InMemoryChannel(); });
テレメトリチャネルをInMemoryChannelに設定
サービスプロバイダーを構築
*IServiceProvider serviceProvider = services.BuildServiceProvider();
Loggerを取得
*ILogger<;Program>; logger = serviceProvider.GetRequiredService<;ILogger<;Program>;>;();
テレメトリクライアントを取得
*var telemetryClient = serviceProvider.GetRequiredService<;TelemetryClient>;();

*var uri = new Uri("https:
{サービスで利用するホスト名}", localPath);

*if (Input.GetKeyDown("r"))
このif文を追記

bool型変数には、「true」か「false」しか入れない。
Javaでのboolean型と同じ
*bool example = true;
string型では、文字列を格納できる。
*string example = "文字列";
int型変数には、大体-21憶から21億までの整数が格納される。
この範囲を超える整数は、long型で扱うことができる。
*int example = 64;
小数を格納することができる。
数値の末尾に「f」をつけることで、float型であることを表す
誤差が許容される有効桁数は、６～９桁
*float example = 3.2f;
*int arrays [] = new int [] {1,2,3};
配列の宣言
配列の長さ(大きさ)をコンソールに表示する。ここでは、「３」と表示される。
*Debug.Log(arrays.length);
配列の番号を指定してコンソールに表示する。ここでは、「１」と表示される。
*Debug.Log(arrays[0]);
配列の番号を指定して、内容を書き換える。
*arrays[0] = 900;
書き換えた内容の表示。ここでは、「900」と表示される。
*Debug.Log(arrays[0]);
*List <;int>; lists = new List <;int>; {1,2,3};
配列型は、最初に宣言した個数までの要素番号しか使えないが、
*List <;int>; lists = new List <;int>; {1,2,3};
List型では、後から追加していくことができる。
listsの中の個数をカウントする。ここでは、「3」と表示される。
*Debug.Log(lists.Count);
List型listsに「800」のデータを追加する。
*lists.add(800);
さっき追加したデータが、末尾に入っていることを確認する。
ここでは、「800」と表示される。
*Debug.Log(lists[3]);
*Dictionary <;String,int>; values = new Dictionary <;String,int>;{{"ひっかく",30},{"たいあたり",40},{"つつく",35},};
List型と異なるのは、値を取り出す際に指定した文字列を使うことができる点。
「ひっかく」の威力が100に変更される（チートです！）
*values["ひっかく"] = 100;
威力30の「ひのこ」が追加される。
*values.add("ひのこ",30);
*//ここでは、Easy,Normal,Difficultの3つしか入れることができなくなっている。*enum GAMEMODE{
enum型は、値の種類を先に宣言しておくことができる
*enum GAMEMODE{Easy,Normal,Difficult}
ここでは、Easy,Normal,Difficultの3つしか入れることができなくなっている。
constを付けると、その値は変更できなくなる。
Javaでのfinalと同じ
*const int example = 10;
varは型推論といって、勝手に型を補ってくれる。
*var position = new Vector3(0, 1, 2);
*transform.position = position;*//ベクトル同士の演算も可能。結果は、(2, 4, 6)
座標を(0,1,2)に移動させる。
ベクトル同士の演算も可能。結果は、(2, 4, 6)
*Debug.Log(new Vector3(0, 1, 2) + new Vector3(2, 3, 4));

*if (p.X >;= shape.Bounds.Left &amp;&amp; p.X <;= shape.Bounds.Right*&amp;&amp; p.Y >;= shape.Bounds.Top - 2 &amp;&amp; p.Y ;= shape.Bounds.Top + 2)
上辺との当たり判定
*if (p.X >;= shape.Bounds.Left &amp;&amp; p.X <;= shape.Bounds.Right*&amp;&amp; p.Y >;= shape.Bounds.Bottom - 2 &amp;&amp; p.Y ;= shape.Bounds.Bottom + 2)
下辺との当たり判定
*if (p.Y >;= shape.Bounds.Top &amp;&amp; p.Y <;= shape.Bounds.Bottom*&amp;&amp; p.X >;= shape.Bounds.Left - 2 &amp;&amp; p.X ;= shape.Bounds.Left + 2)
左辺との当たり判定
*if (p.Y >;= shape.Bounds.Top &amp;&amp; p.Y <;= shape.Bounds.Bottom*&amp;&amp; p.X >;= shape.Bounds.Right - 2 &amp;&amp; p.X ;= shape.Bounds.Right + 2)
右辺との当たり判定
*if (shape.Bounds.Left <;= p.X &amp;&amp; p.X <;= shape.Bounds.Right*&amp;&amp; shape.Bounds.Top ;= p.Y &amp;&amp; p.Y ;= shape.Bounds.Bottom)
図形内部の当たり判定
*private IList<;IShape>; shapes = new[]{new OvalShape(new CoreShape.Rectangle(100, 100, 200, 150)){Stroke = new Stroke(CoreShape.Color.Red, 2),//Fill = new Fill(CoreShape.Color.LightSkyBlue)},new RectangleShape(new CoreShape.Rectangle(350, 100, 100, 150)){Stroke = new Stroke(CoreShape.Color.Black, 2),Fill = new Fill(CoreShape.Color.LightPink)},};
描画する図形をListに定義
処理の対象となる図形
*private IShape? activeShape;
1フレーム前のマウス座標
*private CoreShape.Point oldPoint;
*{var g = new SkiaGraphics(e.Surface.Canvas);g.ClearCanvas(CoreShape.Color.Ivory);foreach (var shape in shapes){shape.Draw(g);}}
描画イベント
*{//マウスポインタの座標を取得var p = e.GetPosition(skElement);var currentPoint = new CoreShape.Point((float)p.X, (float)p.Y);if (e.LeftButton == MouseButtonState.Pressed){//左ボタン押下中、activeShapeがあればドラッグ処理を実行して描画更新if (activeShape is null){ return; }activeShape.Drag(oldPoint, currentPoint);skElement.InvalidateVisual();}else{//カーソルとactiveShapeを一旦初期化Cursor = Cursors.Arrow;activeShape = null;//当たり判定foreach (var shape in shapes){if (shape.HitTest(currentPoint)){//ヒットしたら十字矢印のカーソルに変更。ヒットした図形オブジェクトをactiveShapeに入れてループを抜けるCursor = Cursors.SizeAll;activeShape = shape;break;}}}//1フレーム前のポインタを更新oldPoint = currentPoint;}
マウス移動イベント
マウスポインタの座標を取得
*var p = e.GetPosition(skElement);
*if (activeShape is null)*{ return; }
左ボタン押下中、activeShapeがあればドラッグ処理を実行して描画更新
カーソルとactiveShapeを一旦初期化
*Cursor = Cursors.Arrow;
*foreach (var shape in shapes)*{
当たり判定
ヒットしたら十字矢印のカーソルに変更。ヒットした図形オブジェクトをactiveShapeに入れてループを抜ける
*Cursor = Cursors.SizeAll;
1フレーム前のポインタを更新
*oldPoint = currentPoint;
*{Stroke = new Stroke(Color.black,2),Fill = null}
テスト用
作成したPathに楕円を追加
*using var path = new SKPath();
描画スタイルを指定するSKPaintを作成
*using var paint = new SKPaint()
PathにSKPaintの設定（色、輪郭の太さなど）を反映する
*using var fillPath = paint.GetFillPath(path);
PathをRegionに変換
*using var region = new SKRegion(fillPath);
RegionのContaintsメソッドで領域の内部か否かの判定を行う
*return region.Contains((int)p.X, (int)p.Y);
中略...
*}
*if (stroke is not null &amp;&amp; stroke.Width <; 4)*{
輪郭の幅が４未満の場合は４に拡張して判定
*{Stroke = new Stroke(CoreShape.Color.Red, 2),Fill = new Fill(CoreShape.Color.LightSkyBlue)},
Regionを使った当たり判定を使用するように指定

*private bool canJudge = true;
フラグ
衝突判定時のアクションをここに書く
*canJudge = false;

今日の日付文字列を取得
*string yyyyMMdd = DateTime.Now.ToString("yyyyMMdd");
ユーザID（DMを送信するuser_id）
*Int64 useID = ＜ユーザID＞;
メッセージ
*string dmMessage = @"今日の一枚😘";
画像ファイルパス
*string imgFilePath = @"C:\Users\＜画像フォルダパス＞\img_" + yyyyMMdd + ".jpg";
認証情報
*var tokens = CoreTweet.Tokens.Create(apiKey, apiSecretKey, accessToken, accessTokenSecret);
画像ファイルを取得
*System.IO.FileInfo imgFileInfo = new System.IO.FileInfo(imgFilePath);
画像をアップロードしてmedia_idを取得
*var mediaId = tokens.Media.Upload(imgFileInfo);
JSONオブジェクトを生成
*Media jsonMedia = new Media();
JSONを文字列変換
*var jsonStr = JsonConvert.SerializeObject(jsonRoot);
バイト配列に変換
*byte[] jsonData = System.Text.Encoding.UTF8.GetBytes(jsonStr);
DM送信
tokens.PostContent("https:api.twitter.com/1.1/direct_messages/events/new.json", "application/json", jsonData);
*}

Dispose(bool disposing)　呼び出し回数チェック用
*public static int i = 1;
Dispose(bool disposing)を少なくとも1回呼び出したか
重複での呼び出し防止
*private bool disposedValue = false;
マネージ　リソースを　ここで解放
*WriteLine("■マネージ　リソースを　ここで解放。");
アンマネージリソース ここで解放する。
*WriteLine("■アンマネージリソース ここで解放。");
*{//アンマネージ　リソース　を明示的に解放//Dispose()を一度呼んでいれば//マネージ　リソース は解放済み　のはずDispose(false);}
ファイナライザ ( デストラクタ )
アンマネージ　リソース　を明示的に解放
Dispose()を一度呼んでいれば
マネージ　リソース は解放済み　のはず
*Dispose(false);
*{//マネージ　リソース を明示的に解放//アンマネージも ついでに? 解放Dispose(true);//ファイナライザを抑止GC.SuppressFinalize(this);}
このコードは、破棄可能なパターンを正しく実装できるように追加されました。
マネージ　リソース を明示的に解放
アンマネージも ついでに? 解放
*Dispose(true);
ファイナライザを抑止
*GC.SuppressFinalize(this);

*ISomeInterface<;SubClass<; sub = @base;
ジェネリックの反変性により可能となるコード
*{void SetValue(T value);T Prop { set; }}
このような書き込み専用インターフェイスがあるとします
*{//…省略}
SomeClassが実装しているとします
…省略
*}
SubClass型の型引数をもつのインターフェイスに、BaseClass型の型引数を持つ実体クラスを代入
*ISomeInterface<;SubClass>; sub = new SomeClass<;BaseClass>;();
subの実体の型引数はBaseClassだが、より具体的なSubClassを入力されるぶんには何も問題がない
*sub.SetValue(new SubClass());
書き込み専用じゃなくて読み取りができると…
subの実体はBaseClassなので、SubClassが出てくるという補償はないのに、SubClassで受けられてしまう！
*SubClass subCls = sub.Prop;

*FastLogger.Verbose?.Invoke("value: " + 1);
ログ出力

*{Home,Account,Document,None,}
新しいページが増えたら追加
*{Home,Account,Document,None,}
新しいページが増えたら追加
*{{NaviIcon.Home, typeof(Pages.HomePage)},{NaviIcon.Account, typeof(Pages.AccountPage)},{NaviIcon.Document, typeof(Pages.DocumentPage)},// 空ページ{NaviIcon.None, typeof(Pages.BlankPage)},};
新しいページが増えたら追加
*{NaviIcon.None, typeof(Pages.BlankPage)},
空ページ
Tag取得
*string iconName = selectedItem.Tag?.ToString();
ヘッダー設定
*sender.Header = iconName;
対応するページ表示
*ContentFrame.Navigate(_pages[icon]);
空ページ表示
*ContentFrame.Navigate(_pages[NaviIcon.None]);

*smartPlug.OutletPowered = true;
Turn on relay

*File.Delete(args[0]);
activate.txtを削除

*if (Input.GetMouseButtonDown(0))*{
マウス押した瞬間
*if (Input.GetMouseButton(0))*{
マウス押し続けている間
*if (Input.GetMouseButtonUp(0))*{
マウス離した瞬間
TrailRendererの頂点情報からメッシュを生成する
*TrailRenderer paintObjectTrailRenderer = _tmpPaintObj.GetComponent<;TrailRenderer>;();
子にコライダーだけ持つオブジェクトを作成する
*GameObject colliderContainer = new GameObject("Collider Container");

*.Pipe(String.Join("\n", _))
こうとか書けたらもっと楽だなあという妄想

*public void Sleep(GameObject sobj){
使い終わった後の処理

使用するファイルのパスを追加していく
*searchPaths.Add(Application.dataPath);
実行
*dynamic py = engine.ExecuteFile(Application.dataPath + @"\qiita.py");
クラスを取得
*dynamic viewCount = py.ViewCount();
関数が返す文字列をコンソールに表示
*Debug.Log(viewCount.count());

上記事前準備で作成されたアプリケーションID
*static string APPLICATION_ID = "";
APIのURL
static string API_URL = "https:xxxxxxx-api.azurewebsites.net";
Azure ADのテナント
*var AUTHORITY = "xxxxxx.onmicrosoft.com";
上記で作成したREST API用アプリケーションID（メモ帳に保存しているはず）
*var CLIENT_ID = "";
上記で作成したREST APIキー（メモ帳に保存しているはず）
*var CLIENT_SECRET = "";
96行目の結果は１回目はfalseで、２回目以降はtrueになる
*var canUserAccessWorkbench = await GatewayApi.Instance.CanCurrentUserCreateContractsForWorkflow(WORKFLOW_ID);
*workflowAction.WorkflowActionParameters.Add(new WorkflowActionParameter() { Name = "description", Value = "Computer" });
１３０行目にアセット情報を設定する。

これはLINQ中に副作用のあるメソッドを呼んでいる良くないコード
*var account = accounts

*() =<; ChartValues.RemoveAt(0));
ChartValuesの書き換えをUIスレッドでしか行わないようにすることでスレッドセーフでないChartValuesを安全に操作する

using System.Deployment.Application; 必要
using System.Diagnostics; バージョン取得に必要
using System.Reflection; バージョン取得に必要
*private void Form1_Load(object sender, EventArgs e)
バージョン情報取得＆表示
(後に、ちゃんとバージョンアップされたかの確認用)
*FileVersionInfo ver = FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location);
ClickOnceで起動した場合
*listBox1.Items.Add("<;<;<; ClickOnceで起動 >;>;>;");
*listBox1.Items.AddRange(AppDomain.CurrentDomain.SetupInformation.ActivationArguments.ActivationData);*}
(第2引数以降は来ない模様)
EXEを直接起動した場合(デバッガで動かしている時とか)
*listBox1.Items.Add("<;<;<; EXEを直接起動 >;>;>;");
ターゲットアプリ起動
*string app = Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory) + @"\FWWinFormsClickOnce1.appref-ms";
インストールされていない
*MessageBox.Show("アプリをインストールして下さい");

*if (!method.Match(state))*{
実行するタスクを見つける
現在のplanを保存
*var currentPlan = new Plan(plan);
*if(!method.TryPlanSubTasks(state, ref plan))*{
サブタスクを行う
失敗したときplanを元に戻す
*plan = currentPlan;
サブタスクが全て完了したので成功
*return true;
条件を満たすメソッドがなかったので失敗
*return false;
WorldStateのコピーを取って自由に書き換えられるようにする
*var tmpState = m_WorldStateHolder.WorldState.CreateCopy();
*{Transform Transform { get; }}
操作対象
*{string OperatorName { get; }IEnumerator Execute(IOperatable operatable);}
操作
*transform.position += (Vector3)( m_Velocity * dir * Time.deltaTime);*yield return null;
動かす
*{m_RunningCoroutines = new List<;IEnumerator>;();StartCoroutine(SetTaskRoutine(m_Task));}
Start is called before the first frame update
一定時間ごとにリプランニング
*SetTask(task);

*arrayData3.SequenceEqual(pokemons);
False

こちらの追加処理
*}
*var tween = Undo.AddComponent<;Tween>;(targetTransform.gameObject);*tween.hideFlags = HideFlags.HideInInspector;
選択したTweenBehaviourを対象のTweenAnimationへ追加する
SerializeObjectを更新
*_animationSerializeObject.Update();
追加する
*var tweenInfo = tweenAnimationInfos.GetArrayElementAtIndex(tweenAnimationInfos.arraySize - 1);
削除する
*tweenInfos.DeleteArrayElementAtIndex(i);
Durationはアニメーションの長さ
*var deltaRate = deltaTime / _tweenAnimation.Duration;
CurrentTimeRateは経過時間の割合
*var rate = _tweenAnimation.CurrentTimeRate + deltaRate;
*{_currentTimeRate = rate;}
TweenAnimationの経過時間割合を設定
*{_currentTimeRate = rate;for (int i = 0; i <; _tweenAnmationInfos.Length; i++){var targetInfo = _tweenAnmationInfos[i];if (targetInfo.TweenBase == null){continue;}var tweenDuration = targetInfo.TweenBase.Duration;// 現在時間がスタートタイムより前の場合if (currentTime <; targetInfo.StartTweenTime){return;}// 現在時間がTweenの時間を超えている場合if (currentTime >;= targetInfo.StartTweenTime + tweenDuration){return;}// Tweenへfloat time = tweenDuration >; float.Epsilon ? (currentTime - targetInfo.StartTweenTime) : 0.0f;targetInfo.TweenBase.SetCurrentTime(time);}}
TweenAnimationの経過時間割合を設定
*if (currentTime <; targetInfo.StartTweenTime)*{
現在時間がスタートタイムより前の場合
*if (currentTime >;= targetInfo.StartTweenTime + tweenDuration)*{
現在時間がTweenの時間を超えている場合
Tweenへ
*float time = tweenDuration >; float.Epsilon ? (currentTime - targetInfo.StartTweenTime) : 0.0f;
キャッシュ
*_currentTime = currentTime;
経過時間割合算出
*var rate = currentTime / _duration;
内部処理
*SetCurrentTimeRate(rate);
timeRateが経過時間
*var value = Mathf.Lerp(StartValue, EndValue, timeRate);
*{var value = Mathf.Lerp(0.0f, 1.0f, rate);if (_canvasGroup != null){_canvasGroup.alpha = value;}}
個別の内部処理
今回はTweenのIndex
*GUI.SetNextControlName(tweenIndex.ToString());
左判定
*var tweenRect = GUILayoutUtility.GetLastRect();
Indexをフォーカスする
*GUI.FocusControl(tweenIndex.ToString());

*var animationDuration = 1.0f;
長さは固定
終わりの位置
*boxRect.width = animationDuration / 0.02f * 10.0f + 1.0f;

*{DateTime date = (DateTime)value;return date.ToString("yyyy/MM/dd HH:mm:ss.fff");}
DateTimeを「yyyy/MM/dd HH:mm:ss.fff」形式の文字列に変換
*{string strValue = value as string;DateTime resultDateTime;if (DateTime.TryParse(strValue, out resultDateTime)){return resultDateTime;}return DependencyProperty.UnsetValue;}
文字列をDateTimeに変換
*{// setDt = DateTime.Now;}
テキストボックス ← プロパティ
*{// getAddLog(Dt.ToString("入力した日付は、yyyyねんMMがつddにち です"));}
テキストボックス → プロパティ
*{DateTime date = (DateTime)value;return date.ToString("yyyy/MM/dd HH:mm:ss.fff");}
DateTimeを「yyyy/MM/dd HH:mm:ss.fff」形式の文字列に変換
*{string strValue = value as string;DateTime resultDateTime;if (DateTime.TryParse(strValue, out resultDateTime)){return resultDateTime;}return DependencyProperty.UnsetValue;}
文字列をDateTimeに変換
*{Dt = DateTime.Now;}
テキストボックス ← プロパティ
*{AddLog(Dt.ToString("入力した日付は、yyyyねんMMがつddにち です"));}
テキストボックス → プロパティ

*const string RegionsUri = "https:
earthquake.usgs.govwsgeoserveregions.json";

*private Vector3 offset;
カメラとゲームオブジェクトの相対的な距離
*offset = transform.position - target.transform.position;*}
offsetに再生時の相対的な距離を代入
*{// 相対カメラの位置ベクトル = ゲームオブジェクトの位置ベクトル + offset位置ベクトルtransform.position = target.transform.position + offset;}
Upddate()だと他のスクリプトの処理が終わる前に動く可能性がある
*transform.position = target.transform.position + offset;*}
相対カメラの位置ベクトル = ゲームオブジェクトの位置ベクトル + offset位置ベクトル
*transform.position = target.position + offset;*,,,
相対カメラの位置ベクトル = ゲームオブジェクトの位置ベクトル + offset

*"",
no query parameters
リクエストヘッダに署名を追加
*headers.Add("Authorization", authorization);
リクエスト実行
HttpHelpers はUtilで定義
*HttpHelpers.InvokeHttpRequest(uri, "GET", headers, null);

*if (!b.HasValue) return (0, this, true);
b is too large
*if (ta == null) return a;*if (tb == null) return b;
指数部がint.MaxValue違う値を加算しても変化は0とみなせます。
*//{//    if (Equals(a, null) &amp;&amp; Equals(b, null)) return true;//    if (Equals(a, null) || Equals(b, null)) return false;//    return a.Equals(b);//}
public static bool operator ==(NumberRational a, NumberRational b)
*//    if (Equals(a, null) &amp;&amp; Equals(b, null)) return true;*//    if (Equals(a, null) || Equals(b, null)) return false;
{
*//    if (Equals(a, null) || Equals(b, null)) return false;*//    return a.Equals(b);
if (Equals(a, null) &amp;&amp; Equals(b, null)) return true;
*//{//    return !(a == b);//}
}
*//{//    return !(a == b);//}
public static bool operator !=(NumberRational a, NumberRational b)
*{if(ar==null || b == null){return new ErrorValue(new NullReferenceException());}NumberRational br;switch (b){case NumberRational number: br = number; break;case NumberDecimal number: br = number; break;case ErrorValue error: return error;default: return ErrorValue.ErrorValues.UnknownValueError;}var exp = BigInteger.Min(ar.Exponent, br.Exponent);var an = MathEx.ShiftExponent(ar.Numerator, ar.Exponent, exp);var bn = MathEx.ShiftExponent(br.Numerator, br.Exponent, exp);if (!bn.HasValue) return ar;if (!an.HasValue) return ErrorValue.ErrorValues.ExponentTooLargeError;#if DEBUGSystem.Diagnostics.Debug.Assert(an.Precise);System.Diagnostics.Debug.Assert(bn.Precise);#endifvar lcmDen = MathEx.LeastCommonMultiple(ar.Denominator, br.Denominator);BigInteger.DivRem(an.Value * lcmDen / ar.Denominator, bn.Value * lcmDen / ar.Denominator, out var remainNum);if (lcmDen == 1) return new NumberDecimal(remainNum, exp);else return new NumberRational(remainNum, lcmDen,  exp);}
}

*long value = 4294967296L;
0b100000000000000000000000000000000

*Database.EnsureCreated();
&lt;-- 追記

ここにAPI KEYを入力
*private const string API_KEY = "(API KEYを入力)"
ここにVideo IDを入力
*private const string VIDEO_ID = "(Video IDを入力)"
ここにAPI KEYを入力
*private const string API_KEY = "(API KEYを入力)"
ここにVideo IDを入力
*private const string VIDEO_ID = "(Video IDを入力)"
*{var request = youtubeService.CommentThreads.List("snippet");request.VideoId = videoId;request.Order = CommentThreadsResource.ListRequest.OrderEnum.Relevance;request.TextFormat = CommentThreadsResource.ListRequest.TextFormatEnum.PlainText;request.MaxResults = 100;request.PageToken = nextPageToken;var response = await request.ExecuteAsync();foreach (var item in response.Items){try{CommentInfo info = new CommentInfo();info.ParentNo = no;info.ChildNo = 0;info.Text = item.Snippet.TopLevelComment.Snippet.TextDisplay;info.LikeCount = (long)item.Snippet.TopLevelComment.Snippet.LikeCount;info.AuthorName = item.Snippet.TopLevelComment.Snippet.AuthorDisplayName;info.PublishedAt = JsonDateToDate(item.Snippet.TopLevelComment.Snippet.PublishedAt);info.ReplyCount = (long)item.Snippet.TotalReplyCount;string parentId = item.Snippet.TopLevelComment.Id;commentList.Add(info);if (item.Snippet.TotalReplyCount >; 0)await GetReplyComment(commentList, youtubeService, parentId, no, 1, null);no++;}catch { }}if (response.NextPageToken != null)await GetComment(commentList, videoId, youtubeService, no, response.NextPageToken);}
コメント取得
*{var request = youtubeService.Comments.List("snippet");request.TextFormat = CommentsResource.ListRequest.TextFormatEnum.PlainText;request.MaxResults = 50;request.ParentId = parentId;request.PageToken = nextPageToken;var response = await request.ExecuteAsync();foreach (var item in response.Items){try{CommentInfo info = new CommentInfo();info.ParentNo = no;info.ChildNo = cno;info.Text = item.Snippet.TextDisplay;info.LikeCount = (long)item.Snippet.LikeCount;info.AuthorName = item.Snippet.AuthorDisplayName;info.PublishedAt = JsonDateToDate(item.Snippet.PublishedAt);commentList.Add(info);cno++;}catch { }}if (response.NextPageToken != null)await GetReplyComment(commentList, youtubeService, parentId, no, cno, response.NextPageToken);}
返信コメント取得
*{DateTime result;DateTime.TryParse(dt, out result);return result;}
JSON日付変換

*{base.OnActivated(e);var topAppBar = Template.FindName("PART_TopAppBar", this) as Xamarin.Forms.Platform.WPF.Controls.FormsAppBar; ;if (topAppBar != null){topAppBar.Height = 0;}var commandsBar = Template.FindName("PART_CommandsBar", this) as System.Windows.Controls.Grid;if (commandsBar != null){var titleTextBlock = commandsBar.FindName("PART_System_Title") as System.Windows.Controls.TextBlock;if (titleTextBlock != null){titleTextBlock.Text = Application.MainPage.Title;}}}
省略

以下省略
*}

*keyLook = true;
キー操作をロックする

*Vector3 vn = v.Normalize();
エラー

*var data = Enumerable.Range(1, 10).Select(static x =<; x * p).ToArray();
ヒープアロケーションを回避

*xmlns:prism="http:
prismlibrary.com"
*{// 中略set{boolTrigger.OnNext(value);}}
...
*{boolTrigger.OnNext(value);}
中略
*if (IsRaiseLatestValueOnSubscribe)*{
中略
中略
*}
コンソール出力: True
*,,,

*if(tmpValue != n)
前回と値が変わっていたら
前回と値が異なるものだけ通す
*.DistinctUntilChanged()
その中から100より大きいものに絞り込む
*.Where(n =>; n >; 100)
FugaObservableと合成して次に流す
*.Merge(hogeClass.FugaObservable)
購読する
*.Subscribe(n =>; Console.WriteLine(n));
*class HaveInformationClass*{
情報を持っているクラス
*public void ReceiveInformation(Information information)*{
情報を受ける口を用意しておく。情報は受動的にもらう。
処理
*}
*class InformationRequiredClass*{
情報を必要とするクラス
*destination.ReceiveInformation(information);*}
「情報を必要とするクラス」が欲しい情報を渡しに行く
*class HaveInformationClass*{
情報を持っているクラス
*infoSource.ObservableInformation*.Subscribe(info =>; /* 処理 */);
情報を必要とするクラスが能動的に貰いに行く
*class InformationRequiredClass*{
情報を必要とするクラス
--省略--
*}

*ViewData["OgUrl"] = $"https:
{Request.Host.Value}{url}";
*if (new Uri(NavigationManager.Uri).AbsolutePath.Contains("_"))*{
URLの中に_があった場合
_を外してHTMLデコードして投げる
*NavigationManager.NavigateTo(WebUtility.HtmlDecode(NavigationManager.Uri.Replace("_", "")));

フックを行う
第1引数   フックするイベントの種類
13はキーボードフックを表す
第2引数 フック時のメソッドのアドレス
フックメソッドを登録する
第3引数   インスタンスハンドル
現在実行中のハンドルを渡す
第4引数   スレッドID
0を指定すると、すべてのスレッドでフックされる
*hookPtr = SetWindowsHookEx(
フックしたキー
*Console.WriteLine((Keys)(short)Marshal.ReadInt32(lParam));
1を戻すとフックしたキーが捨てられます
*return 1;
フックしたキー
*Console.WriteLine((Keys)(short)Marshal.ReadInt32(lParam));
1以外を戻すとフックしたキーがそのまま入力されます
return 1;
*return 0;
キーを押したとき
*case 256:
キーを離したとき
*case 257:
1はキーボードを入力
*type = 1,
74はJキー
*wVk = 74,
DirectInputを介してキーボード入力をフェッチしているソフトウェアの場合は
以下のようにスキャンコードをつけて送らないと無視されてしまうということがある
が今回はキーボードだけなので0(ゼロ)で
wScan = (short)MapVirtualKey((short)key, 0),
*wScan = 0,
キーボードダウンの場合は、0(ゼロ)
*dwFlags = 0,
3秒後にJキーが入力されます
*Thread.Sleep(3000);
1はキーボードを入力
*type = 1,
74はJキー
*wVk = 74,
DirectInputを介してキーボード入力をフェッチしているソフトウェアの場合は
以下のようにスキャンコードをつけて送らないと無視されてしまうということがある
が今回はキーボードだけなので0(ゼロ)で
wScan = (short)MapVirtualKey((short)key, 0),
*wScan = 0,
キーボードダウンの場合は、0(ゼロ)
*dwFlags = 0,
キーボードアップの場合は、2
*dwFlags = 2,
*if (v == Keys.J)*{
Jキーの入力の場合
キー押下の時
*case 256:
85はUキー
*wVk = 85,
キーボードダウンの場合は、0(ゼロ)
*dwFlags = 0,
キー離した時
*case 257:
85はUキー
*wVk = 85,
キーボードアップの場合は、2
*dwFlags = 2,

出力結果
Hello, World
*,,,
出力結果
Hello
World
*string sample = "Hello";
出力結果
HelloWorld
*,,,
出力結果
My friends are Taro and Hanako
*,,,
出力結果
20
*,,,
出力結果
The range of integers is -2147483648 to 2147483647
*,,,
出力結果
The answer is greater than 10.
*,,,
出力結果
The answer is not greater than 10
*,,,
出力結果
The counter is 0
The counter is 1
The counter is 2
*,,,
出力結果
The counter is 0
The counter is 1
The counter is 2
*,,,

*transform.Rotate(new Vector3(0, 0, 0));
タイヤ回転停止

bufferをこね回す重い処理が以降に入る
*}
bp~経由でbufferをこね回す重い処理が以降に入る
*}

Updateで実行する処理をここに記述します。
*await UniTask.Yield(PlayerLoopTiming.Update, cancellationToken);

*client.BaseAddress = new Uri("http:
localhost:7071api");

*private float gravity = 20;
9.81f;

*string sasUri = "http:
xxxxxxxxx";
*string[] targetFileNameList = {"testFile1.txt", "testFile2.txt"};
ダウンロード対象のファイル名
Blobストレージから取得したファイルをコピー
*await downloadInfo.Content.CopyToAsync(es);

実際には存在しないメソッドです
*public static void Sort<;T, TOp>;(T[] array, TOp comparer) where TOp : IComparer<;T>;;

*Debug.WriteLine($"{w1}");
elseブロックをコメントアウトすると、w1は"未割当"エラーになる

*"Echo".RemoveRichText();
リッチテキストを取り除く

*Bar(out a);
NG,割り当て済みだろうと、Bar関数はout引数の条件を満たしていない。
OK,割り当てがなされている。
*static void Foo(out int x) =>; x = 42;
*{}
NG,必ず割り当てなければならない。
Ok,Inを明示してもいい。
*Hoge(in a);
OK,変更を伴わないのでinを省略することもできる。
*Hoge(a);
NG,リテラルは参照する先が存在しないので引数として使えない。
Hoge(in 10);CS8156
*}
OK,内容を読み取っているだけ
*Console.WriteLine(x);
NG,内容を変更できない。
x=100;CS8331
*}
NG,xの参照している先を変更することはできない。
*x=new ClassEnvelope();
OK,xの内容ではなく、xのが参照している先を操作している。
*x.SetNewStringBuiler(new StringBuilder());
NG,xの参照先は値型なのでxの内容を変更することはできない。
*x.Builder=new StringBuilder();
OK,xが保持しているStringBuilderへの参照を元にして参照先を操作している。
*x.Builder.Append("hello world");

*if (string.IsNullOrEmpty(this.Text))*{
set DefaultText if nothing else selected

*string numFormat = string.Format("{0:#,0.000}", 123456.111111);
123,567.111
*string numFormat = string.Format("{0:#,0.000}", 0);
0.000
*string numFormat = string.Format("{0:#,0.###}", 0);
0
*string numFormat = string.Format("{0:#,#.###}", 0);
stringl.Empty
*string numFormat = string.Format("{0:0000}", 123);
0123
*string dateFormat = string.Format(@"{0:yyyy/MM/dd HH:mm:ss.fff}", DateTime.Now);
2021/01/01 13:01:01.123

*return Math.Ceiling(diffTotalDays * oneDayPricipal);
年利で発生した金額
*private double GetDifferenceTotalDays(int index)*{
現在日から支払日の差

*System.Console.WriteLine(Seasons.Winter.ToString());
Winter
TがEnumかどうかチェック
where T : Enum にすると、戻り値をNullableにできないので...
*if (!typeof(T).IsEnum) return null;
int, string以外は処理対象外とする
*return null;
TryParseする前に、定義されている値かチェックする
※ 数値の場合、定義されていない値でもTryParseが成功してしまうため
*if (!Enum.IsDefined(typeof(T), value)) return null;

データの発行が完了したことを通知する
*void OnCompleted();
データの発行元でエラーが発生したことを通知する
*void OnError(Exception error);
データを通知する
*void OnNext(T value);
データの発行を購読する
*IDisposable Subscribe(IObserver<;T>; observer);
購読されたIObserver&lt;int&gt;のリスト
*private List<;IObserver<;int>;>; m_observers = new List<;IObserver<;int>;>;();
発行先リスト
*private List<;IObserver<;int>;>; m_observers;
DisposeされたときにRemoveするIObserver&lt;int&gt;
*private IObserver<;int>; m_observer;
Disposeされたら発行先リストから対象の発行先を削除する
*m_observers.Remove(m_observer);
購読されたIObserver&lt;int&gt;のリスト
*private List<;IObserver<;int>;>; m_observers = new List<;IObserver<;int>;>;();
購読解除用のクラスをIDisposableとして返す
*return new Unsubscriber(m_observers, observer);
購読されたIObserver&lt;int&gt;のリスト
*private List<;IObserver<;int>;>; m_observers = new List<;IObserver<;int>;>;();
購読解除用のクラスをIDisposableとして返す
*return new Unsubscriber(m_observers, observer);
*{//発行先リストprivate List<;IObserver<;int>;>; m_observers;//DisposeされたときにRemoveするIObserver<;int>;private IObserver<;int>; m_observer;public Unsubscriber(List<;IObserver<;int>;>; observers, IObserver<;int>; observer){m_observers = observers;m_observer = observer;}public void Dispose(){//Disposeされたら発行先リストから対象の発行先を削除するm_observers.Remove(m_observer);}}
購読解除用内部クラス
発行先リスト
*private List<;IObserver<;int>;>; m_observers;
DisposeされたときにRemoveするIObserver&lt;int&gt;
*private IObserver<;int>; m_observer;
Disposeされたら発行先リストから対象の発行先を削除する
*m_observers.Remove(m_observer);
購読されたIObserver&lt;int&gt;のリスト
*private List<;IObserver<;int>;>; m_observers = new List<;IObserver<;int>;>;();
購読解除用のクラスをIDisposableとして返す
*return new Unsubscriber(m_observers, observer);
*foreach (var observer in m_observers)*{
すべての発行先に対して1,2,3を発行する
*{//発行先リストprivate List<;IObserver<;int>;>; m_observers;//DisposeされたときにRemoveするIObserver<;int>;private IObserver<;int>; m_observer;public Unsubscriber(List<;IObserver<;int>;>; observers, IObserver<;int>; observer){m_observers = observers;m_observer = observer;}public void Dispose(){//Disposeされたら発行先リストから対象の発行先を削除するm_observers.Remove(m_observer);}}
購読解除用内部クラス
発行先リスト
*private List<;IObserver<;int>;>; m_observers;
DisposeされたときにRemoveするIObserver&lt;int&gt;
*private IObserver<;int>; m_observer;
Disposeされたら発行先リストから対象の発行先を削除する
*m_observers.Remove(m_observer);
値を受け取るクラスを３つ作成
*Observer observerA = new Observer("Aさん");
値を発行するクラスを作成
*Observable observable = new Observable();
３つのObserverが、自分自身を発行先として登録する（=購読）
*IDisposable disposableA = observable.Subscribe(observerA);
Observableに値を発行させる
*observable.SendNotice();
Aさんが購読解除する
*disposableA.Dispose();
再び値を発行させる
*observable.SendNotice();
Bさんが購読解除する
*disposableB.Dispose();
再び値を発行させる
*observable.SendNotice();

*if (sourcePath.Contains (":
")) {
*while (!www.isDone) {;}
Wait for download to complete - not pretty at all but easy hack for now
*while (!www.isDone) {;}*if (String.IsNullOrEmpty(www.error)) {
and it would not take long since the data is on the local device.
*if (System.IO.File.Exists (sourcePath)) {//copy file - alle systems except AndroidSystem.IO.File.Copy (sourcePath, pathDB, true);} else {CanExQuery = false;Debug.Log ("ERROR: the file DB named " + dbName + " doesn't exist in the StreamingAssets Folder, please copy it there.");}
Mac, Windows, Iphone
*if (System.IO.File.Exists (sourcePath)) {*//copy file - alle systems except Android
validate the existens of the DB in the original folder (folder "streamingAssets")
*} else {
copy file - alle systems except Android
*//if DB does not exist in persistent data folder (folder "Documents" on iOS) or source DB is newer then copy it*if (!System.IO.File.Exists (pathDB) /*|| (System.IO.File.GetLastWriteTimeUtc(sourcePath) >; System.IO.File.GetLastWriteTimeUtc(pathDB))*/) {
string sourcePath = System.IO.Path.Combine (Application.streamingAssetsPath, dbName);
*if (!System.IO.File.Exists (pathDB) /*|| (System.IO.File.GetLastWriteTimeUtc(sourcePath) >; System.IO.File.GetLastWriteTimeUtc(pathDB))*/) {*TextAsset textAsset=(TextAsset)Resources.Load(dbName);
if DB does not exist in persistent data folder (folder "Documents" on iOS) or source DB is newer then copy it
*while (!www.isDone) {;}
Wait for download to complete - not pretty at all but easy hack for now
*while (!www.isDone) {;}*if (String.IsNullOrEmpty(www.error)) {
and it would not take long since the data is on the local device.
*if (System.IO.File.Exists (sourcePath)) {//copy file - alle systems except AndroidSystem.IO.File.Copy (sourcePath, pathDB, true);} else {CanExQuery = false;Debug.Log ("ERROR: the file DB named " + dbName + " doesn't exist in the StreamingAssets Folder, please copy it there.");}
Mac, Windows, Iphone
*if (System.IO.File.Exists (sourcePath)) {*//copy file - alle systems except Android
validate the existens of the DB in the original folder (folder "streamingAssets")
*} else {
copy file - alle systems except Android

*animator.SetTrigger("Death");
倒れるアニメに移行

*_com23 = new MySerialPort("COM23");
&lt;-- TeraTermを使うときはコメントアウト
_com21 = new MySerialPort("COM21");  &lt;-- TeraTermを使うときはコメントアウト
*_com22 = new MySerialPort("COM22");
_com23 = new MySerialPort("COM23");   &lt;-- TeraTermを使うときはコメントアウト
*}

*public override void Write()
overrideを使って定義し直す

*SceneManager.LoadSceneAsync("ScreenBreak");
シーンを遷移する

*containerRegistry.RegisterForNavigation<;MyTabbedPage, MyTabbedPageViewModel<;();
TabbedPage

*_printer = new LabelPrinter(new Uri("http:
webprinterapi"));
ILabelPrinterを実装したクラスを受け取れるように
コンストラクタを追加した
*public PrintService(ILabelPrinter printer)
以下全く同じのため省略
*}

*[XmlRoot("feed", Namespace = "http:
www.w3.org2005Atom")]

サブキーの一覧を取得
*var keys = Registry.Users.GetSubKeyNames();
第二引数でインデントをつけれる
*string j = Newtonsoft.Json.JsonConvert.SerializeObject(t, Newtonsoft.Json.Formatting.Indented);
file書き込み
*File.WriteAllText(@"write.json", j);
ファイルの内容をすべて読み込みます。
*string j = sr.ReadToEnd();
string型の文字列をもとにTargetJson型のオブジェクトにデシリアライズ
*TargetJson s = Newtonsoft.Json.JsonConvert.DeserializeObject<;TargetJson>;(j);
オブジェクトのプロパティにアクセス
*Console.WriteLine(s.ObS.Name);
AssemblyInfo.csの内容
アセンブリのバージョン情報は次の 4 つの値で構成されています:

メジャー バージョン
マイナー バージョン
ビルド番号
リビジョン

*[assembly: AssemblyVersion("1.0.0.0")]

初期化
*_auth = FirebaseAuth.DefaultInstance;
*if (_auth.CurrentUser.UserId == null)*{
すでにユーザーが作られているのか確認
*{if (result){Debug.Log($"成功: #{_user.UserId}");}else{Debug.Log("失敗");}});
まだユーザーができていないためユーザー作成
*if (_auth.CurrentUser.UserId == null)*{
すでにユーザーが作られているのか確認
*{if (task.IsCanceled){Debug.LogError("CreateUserWithEmailAndPasswordAsync was canceled.");callback(false);return;}if (task.IsFaulted){Debug.LogError("CreateUserWithEmailAndPasswordAsync encountered an error: " + task.Exception);callback(false);return;}_user = task.Result;Debug.Log($"Firebase user created successfully: {_user.DisplayName} ({_user.UserId})");callback(true);});
新規でユーザー作成
*_auth.CurrentUser.LinkWithCredentialAsync(credential).ContinueWith(task =>; {if (task.IsCanceled){Debug.LogError("LinkWithCredentialAsync was canceled.");callback(false);return;}if (task.IsFaulted){Debug.LogError("LinkWithCredentialAsync encountered an error: " + task.Exception);callback(false);return;}_user = task.Result;Debug.Log($"Credentials successfully linked to Firebase user: {_user.DisplayName} ({_user.UserId})");callback(true);});
認証方法追加
サンプル: 保存
*var userData = new UserPlayData("gremito", 10.5f);
*GetUserData((result) =>; {if(result == null){Debug.LogWarning("失敗");}else{Debug.Log($"username: {result.username}");Debug.Log($"time: {result.time}");}});
サンプル: 取得
公式サンプル方法: https:firebase.google.com/docs/database/unity/save-data?authuser=0#write_update_or_delete_data_at_a_reference
*var json = JsonUtility.ToJson(data);

*webBuilder.UseUrls("http:
*:5000");  &lt;- 新たに追加

usingを使うように修正
*using var paint = new SKPaint().SteStroke(stroke);
usingを使うように修正
*using var paint = new SKPaint().SetFill(fill);
*{using var paint = new SKPaint().SetStroke(stroke);Canvas.DrawOval(rectangle.ToSk(), paint );}
...

ここに図形描画の処理を記述します。
*}

親のサイズに合わせてサイズを設定
*this.StretchToParentSize();
ズームインアウト
*SetupZoom(ContentZoomer.DefaultMinScale, ContentZoomer.DefaultMaxScale);
ドラッグで描画範囲を移動
*this.AddManipulator(new ContentDragger());
ドラッグで選択した要素を移動
*this.AddManipulator(new SelectionDragger());
ドラッグで範囲選択
*this.AddManipulator(new RectangleSelector());
省略
ussファイルを読み込んでスタイルに追加
*this.styleSheets.Add(Resources.Load<;StyleSheet>;("GraphViewBackGround"));
背景を一番後ろに追加
*this.Insert(0, new GridBackground());
ノードのタイトル設定
*this.title = "Message";
ポート（後述）を作成
*var inputPort = Port.Create<;Edge>;(Orientation.Horizontal, Direction.Input, Port.Capacity.Multi, typeof(Port));
メイン部分に入力欄追加
*textField = new TextField();
複数行対応
*textField.multiline = true;
*textField.RegisterCallback<;FocusInEvent>;(evt =>; { Input.imeCompositionMode = IMECompositionMode.On; });
日本語入力対応
省略
*this.Add(new MessageNode());
ノードの生成位置をマウスの座標にする
*var worldMousePosition = _window.rootVisualElement.ChangeCoordinatesTo(_window.rootVisualElement.parent, context.screenMousePosition - _window.position.position);
省略
右クリックでノード作成するウィンドウ追加
*var searchWindowProvider = ScriptableObject.CreateInstance<;ScriptGraphSearchWindowProvider>;();
省略
*}
*if (startPort.node == port.node) continue;*// Input - Input , Output - Outputは繋げない
同じノードは繋げない
*if (startPort.direction == port.direction) continue;*// ポートタイプが違うものは繋げない
Input - Input , Output - Outputは繋げない
*if (startPort.portType != port.portType) continue;*compatiblePorts.Add(port);
ポートタイプが違うものは繋げない
省略
*node.SetPosition(new Rect(localMousePosition, new Vector2(100, 100)));
ここで追加しよう！
*_scriptGraphAsset.list.Add(data);

json読み込み
*JObject jObject = ReadJsonFile(Path.Combine(startupPath, "test.json"));
category要素をテーブル名とする
*string tableName = jObject["category"].ToString();
Insertするデータと、テーブル名を指定する
*executer.DynamicInsert(jObject, tableName);
xml（XMLを読込んで、Jsonに変換）
*XmlDocument doc = new XmlDocument();

*var copy = original;
代入
代入：実行結果
SampleStruct メンバー：コピー元
*original.Id     = 10      original.Name    = AAA
SampleClass メンバー：コピー元
*original.Id     = 10      original.Name    = AAA
SampleStruct メンバー：コピー先
*copy.Id         = 10      copy.Name        = AAA
SampleClass メンバー：コピー先
*copy.Id         = 10      copy.Name        = AAA
値を変更：実行結果
SampleStruct メンバー：コピー元
*original.Id     = 99      original.Name    = Hello, World!
SampleClass メンバー：コピー元
*original.Id     = 99      original.Name    = Hello, World!
SampleStruct メンバー：コピー先
*copy.Id         = 99      copy.Name        = Hello, World!
SampleClass メンバー：コピー先
*copy.Id         = 99      copy.Name        = Hello, World!
クラスの実装・初期化はクラスの代入時と同じなので省略
var copy = new SampleClass(original);;  コピーコンストラクタ
var copy = original.SharrowCopy();  SharrowCopy()内でMemberwiseClone()を実行
コピーコンストラクタ・MemberwiseClone：実行結果
SampleStruct メンバー：コピー元
*original.Id     = 10      original.Name    = AAA
SampleClass メンバー：コピー元
*original.Id     = 10      original.Name    = AAA
SampleStruct メンバー：コピー先
*copy.Id         = 10      copy.Name        = AAA
SampleClass メンバー：コピー先
*copy.Id         = 10      copy.Name        = AAA
値を変更：実行結果
SampleStruct メンバー：コピー元
*original.Id     = 99      original.Name    = Hello, World!
SampleClass メンバー：コピー元
*original.Id     = 99      original.Name    = Hello, World!
SampleStruct メンバー：コピー先
*copy.Id         = 10      copy.Name        = AAA
SampleClass メンバー：コピー先
*copy.Id         = 99      copy.Name        = Hello, World!
*{return (SampleClass) MemberwiseClone();}
↓ シャロ―コピー
*{var clone = SharrowCopy();// Array.Clone の戻り値は Object なのでキャストが必要if (clone.Ids != null){clone.Ids = (int[]) this.Ids.Clone();}if (clone.Names != null){clone.Names = (string[]) this.Names.Clone();}return clone;}
↓ ディープコピー
*if (clone.Ids != null)*{
Array.Clone の戻り値は Object なのでキャストが必要
ディープコピー：実行結果
*original.Id     = 10      original.Name    = AAA
値を変更：実行結果
*original.Id     = 99      original.Name    = Hello, World!

*}
*1

*{}
Start is called before the first frame update
*{for (int i = 0; i <; 1000; ++i){float f = Random.Range(-9999f, 9999f);string s = f.ToString();float v = float.Parse(s);float d = v - f;if (d <; 0f){if (d <; _minDif){_minDif = d;Debug.Log("MIN DIF:" + _minDif);}}else{if (d >; _maxDif){_maxDif = d;Debug.Log("MAX DIF:" + _maxDif);}}}}
Update is called once per frame

*var response = await Http.GetAsync(@"https:
hatenaXXXXXXX");

*int beforeChildCount;*// RectTransformからのデータ
Grid内オブジェクトの個数
*float beforeWidth, beforeHeight;*// GridLayoutGroupからのデータ
RectTransformからのデータ
*Vector2 beforeCellSize;*Vector2 beforeSpacing;
GridLayoutGroupからのデータ
*rect = GetComponent<;RectTransform>;();*while (rect.rect.width == 0 &amp;&amp; rect.rect.height == 0)
サイズ調整の基準となるRectTransformを取得
*rect = rect.transform.parent.GetComponent<;RectTransform>;();*}
Streach前提でサイズが取得できないときは、親・祖先オブジェクトに遡って取得しにいく
レイアウト状態に変更が無ければスキップ
*bool skipFlag =
*switch (grid.constraint) {case GridLayoutGroup.Constraint.FixedColumnCount:skipFlag &amp;= beforeCellSize.y == grid.cellSize.y;skipFlag &amp;= beforeConstraingCount == grid.constraintCount;break;case GridLayoutGroup.Constraint.FixedRowCount:skipFlag &amp;= beforeCellSize.x == grid.cellSize.x;skipFlag &amp;= beforeConstraingCount == grid.constraintCount;break;}
幅固定指定の場合は、前回サイズから変更がないか追加チェック
何かしら状況が変わったのでレイアウト設定を変える
*float x = grid.cellSize.x;
x,y:ともに可変（領域全体を埋める）
*case GridLayoutGroup.Constraint.Flexible:
縦方向優先に並べる動作は挙動が特殊
*yokoNum = i;
width のみ可変
*case GridLayoutGroup.Constraint.FixedColumnCount:
height のみ可変
*case GridLayoutGroup.Constraint.FixedRowCount:
*beforeChildCount = grid.transform.childCount;*beforeWidth = rect.rect.width;
更新処理スキップ判定用に諸々キャッシュ

定期的に実行したい処理
*private Action callbackAction;
繰り返し処理する
*this.timer.AutoReset = true;
TODO: マネージド状態を破棄します (マネージド オブジェクト)
*this.timer.Stop();
TODO: アンマネージド リソース (アンマネージド オブジェクト) を解放し、ファイナライザーをオーバーライドします
TODO: 大きなフィールドを null に設定します
*lock (this.lockObject)
*// {//     // このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します//     Dispose(disposing: false);// }
TODO: 'Dispose(bool disposing)' にアンマネージド リソースを解放するコードが含まれる場合にのみ、ファイナライザーをオーバーライドします
*// {//     // このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します//     Dispose(disposing: false);// }
~SafelyDisposableTimer()
このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します
Dispose(disposing: false);
}
*public void Dispose()
このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します
*Dispose(disposing: true);
処理を実行
*this.callbackAction();

*public T Top
listの先頭を返す
*public IEnumerator<;T>; GetEnumerator() { return new UnsafeListEnumerator(unsafe_array, unsafe_count); }
ここから下はforeachで回せるようにIEnumerableの実装をしている

*}
*1

*person.LastName = "Hoge";
これはコンパイルエラーとなる。
*{public string FirstName { get; }public string LastName { get; }public Person(string firstName, string lastName){this.FirstName = firstName;this.LastName = lastName;}}
C# 8.0以前で実装する場合
使い方
*var person = new Person("すけお", "ねくすと");
...省略...
*.method public hidebysig specialname
...省略...
*,,,
*var person = new Person() { FirstName = "すけお", LastName = "ねくすと" };
使い方
出力
*true
出力
*false
出力
*ねくすと すけお
Person定義
*public record Person(string FirstName, string LastName);
*var person1_1 = person1 with { LastName = "だいご" };

*Person { FirstName = すけお, LastName = だいご }
出力
↓↓↓OK:冗長な記述が必要
*private Dictionary<;string, List<;Person>;>; personDic1 = new Dictionary<;string, List<;Person>;>;();
↓↓↓エラー。varはフィールド定義に使用できない。
*private var personDic2 = new Dictionary<;string, List<;Person>;>;();
↓↓↓OK:new側で型の明示を省略。
*private Dictionary<;string, List<;Person>;>;  personDic3 = new();

*vec.x = 0;
X軸は補正したくない
*transform.Rotate(-vertical, horizontal, 0, Space.Self);*,,,
verticalはそのままの値を使いたい

*public string Name { get; set; }
署名

*throw new NoServiceException(SCardError.NoReadersAvailable);
Cannot find a smart card reader.
*private void Monitor_CardInserted(object sender, CardStatusEventArgs e) {Invoke(new Action(() =>; {ReadData();}));}
monitor event
*private void ReadData() {// readerusing var reader = context.ConnectReader(readerName, SCardShareMode.Shared, SCardProtocol.Any);var apdu = new CommandApdu(IsoCase.Case2Short, reader.Protocol){CLA = 0xff,Instruction = InstructionCode.GetData,P1 = 0x00,P2 = 0x00,Le = 0};using (reader.Transaction(SCardReaderDisposition.Leave)) {// paramvar sendPci = SCardPCI.GetPci(reader.Protocol);var receivePci = new SCardPCI();var receiveBuffer = new Byte[256];var command = apdu.ToArray();// sendvar bytesReceived = reader.Transmit(sendPci,command,command.Length,receivePci,receiveBuffer,receiveBuffer.Length);// responsevar responseApdu = new ResponseApdu(receiveBuffer, bytesReceived, IsoCase.Case2Short, reader.Protocol);if (responseApdu.HasData) {textBoxReadData.Text = new StringBuilder(BitConverter.ToString(responseApdu.GetData())).ToString();} else {textBoxReadData.Text = string.Empty;}}}
read data
*var apdu = new CommandApdu(IsoCase.Case2Short, reader.Protocol){CLA = 0xff,Instruction = InstructionCode.GetData,P1 = 0x00,P2 = 0x00,Le = 0};
reader
*if (responseApdu.HasData) {textBoxReadData.Text = new StringBuilder(BitConverter.ToString(responseApdu.GetData())).ToString();} else {textBoxReadData.Text = string.Empty;}
response
*private void Form1_FormClosing(object sender, FormClosingEventArgs e) {if(context != null) {context.Dispose();}if(monitor != null) {monitor.Dispose();}}
form event
*private void ButtonReset_Click(object sender, EventArgs e) {InitializePasori();}
更新button event

*p2.Attack();
ゼニガメの攻撃処理が実行される

int型
*var iNum = 1;
float型
*var fNum = 2.5;
string型
*var str = "hoge";
Dictionary&lt;string, List&lt;int&gt;&gt;型
*var myList = new Dictionary<;string, List<;int>;>;();
これはOK
*var myList = new Dictionary<;string, List<;int>;>;();
これはGetMyListが何の型を返してくるのかぱっと見でわからない
*var myList2 = GetMyList();
なにかしらの処理
*}

Android API 24(Android7.0)以前は古い方式で実装
*Android.Content.Res.Resources res = base.Resources;
Android API 25(Android7.1)以降は新しい方式で実装
*var config = new Configuration();

*{if (品詞 != szPartOfSpeech){return false;}if (szPartOfSpeechSC1 == null){return true;}if (品詞細分類1 != szPartOfSpeechSC1){return false;}if (szPartOfSpeechSC2 == null){return true;}if (品詞細分類2 != szPartOfSpeechSC2){return false;}if (szPartOfSpeechSC3 == null){return true;}if (品詞細分類3 != szPartOfSpeechSC3){return false;}return true;}
品詞とチャンクとの照合

null は undefined へ、bool は boolean へそれぞれ変換される。
undefined undefined
boolean true
boolean false
*await module.InvokeVoidAsync("outputLog", 123);
数値を渡した場合は number へ、文字列を渡した場合は string へ変換される。
number 123
string 456
string foo
enum MyEnum { Value1 = 7, Value2 = 5, Value3 = 6 }
*await module.InvokeVoidAsync("outputLog", MyEnum.Value1);
列挙型のメンバーは、対応する整数値へ変換される。
number 7
number 5
number 6
*var sampleList = new List<;string>;() { "aaa", "bbb", "ccc" };
IEnumerable インターフェイスを備えた型であれば配列へ変換される。
object (3) ["aaa", "bbb", "ccc"]
object (3) ["aaa", "bbb", "ccc"]
class SampleClass
{
private string _X = "private field";
public string X = "public field";
private string _Y { get; set; } = "private property";
public string Y { get; set; } = "public property";
}
*var sampleInstance = new SampleClass();
*//   object {y: "public property"}
クラスインスタンスは public プロパティのみを含んだ object へ変換される。
*await module.InvokeVoidAsync("outputLog", new Dictionary<;int, string>;() {{ 1, "value1" },{ 2, "value2" },{ 3, "value3" },});
object {y: "public property"}
*//   object {1: "value1", 2: "value2", 3: "value3"}
Dictionary は object へ変換される。
*{Item1 = "foo",Item2 = "hoo",Item3 = 123});
object {1: "value1", 2: "value2", 3: "value3"}
*//   object {item1: "foo", item2: "hoo", item3: 123}
匿名型も object へ変換される。
*//   object {}
Tuple は変換を行えない。
*//   object {}
ValueTuple も同様。
*{// 各データの日付をグラフの軸とするLabels = forecasts.Select(f =>; f.Date.ToShortDateString()),// 摂氏／華氏それぞれの気温情報をグラフの要素として指定するDatasets = new List<;LineData>;(){new LineData(){Label = "Temp. (C)",Data = forecasts.Select(f =>; f.TemperatureC),BorderColor = "coral",},new LineData(){Label = "Temp. (F)",Data = forecasts.Select(f =>; f.TemperatureF),BorderColor = "lightgreen",}}};
WeatherForecastService から得られたデータをグラフ出力用データに変換する
*Labels = forecasts.Select(f =>; f.Date.ToShortDateString()),*// 摂氏／華氏それぞれの気温情報をグラフの要素として指定する
各データの日付をグラフの軸とする
*{new LineData(){Label = "Temp. (C)",Data = forecasts.Select(f =>; f.TemperatureC),BorderColor = "coral",},new LineData(){Label = "Temp. (F)",Data = forecasts.Select(f =>; f.TemperatureF),BorderColor = "lightgreen",}}
摂氏／華氏それぞれの気温情報をグラフの要素として指定する
コンパニオン モジュールへデータを渡す
*var module = await JSRuntime.InvokeAsync<;IJSObjectReference>;(

ヘッダー分だけ進める
*_reader.ReadLine();
*while (!HasEnoughQuote(line)) {*line += "\n" + _reader.ReadLine();
改行を考慮して行を読み込む
改行コードを排除する
*line = NEW_LINE_REGEX.Replace(line, "");
要素分解を行う
*line += ",";
*for (int i = 0; i <; columns.Length; i++) {var attribute = _attirbuteInfos[i];attribute.Property.SetValue(data, Convert.ChangeType(columns[i], attribute.Property.PropertyType));}
データを作成する
*for (int i = 0; i <; 10; i++) {list.Add(new ProfileData() {Name = i.ToString(),Time = (i * i)});}
適当なテスト用のデータ作成
*using (var writer = new SimpleCsvWriter<;ProfileData>;(directory, "test", list.ToArray())) {writer.Write();}
書き込み部分
データ書き込み
*Write();
*foreach (var profile in profiles) {Debug.Log(profile.Name + " = " + profile.Time);}
データ読み込み

targetObjectをSirializedObjectに変換する
*var serializedObject = new SerializedObject(targetObject);
*{_text = GUILayout.TextField(_text);if (scope.changed){Debug.Log(_text);}}
TextFieldが変更されたにログが吐かれる
*{}
幅を300f指定
*{var rect = GUILayoutUtility.GetLastRect();}
VerticalScopeのRectを取得する
GenericMenuでの使用例
*var menu = new GenericMenu();
メニュー押した時のAction
*});
ToggleにloopIconを表示させる
*Texture loopIcon;
Toggleが切り替わったときに呼び出される
*}
PlayButton用のテクスチャを取得する
*EditorGUIUtility.FindTexture("PlayButton");
選択したときのコールバック
*},"");
*if (Event.current.button == 0)*{
左ボタン
*if (Event.current.type == EventType.MouseUp &amp;&amp; Event.current.button == 1)*{
判定
イベントを使い終わった
*Event.current.Use();
赤色にする
*GUI.backgroundColor = Color.red;
コントロールする名前を設定する
*GUI.SetNextControlName("Focus String");
指定した名前にフォーカスする
*GUI.FocusControl("Focus String");
フォーカスされている名前を取得する
*var focusString = GUI.GetNameOfFocusedControl()

コンソールにAの値が出力される
*System.Console.Writeline(hoge.A);
コンソールにBの値が出力される
*System.Console.Writeline(hoge.B);
コンパイルは通るが実行時エラーとなる
*System.Console.Writeline(hoge.C);
CosmosDB エンドポイント
*private static readonly string EndpointUri = "todo";
プライマリキー
*private static readonly string PrimaryKey = "todo";
CosmosDB クライアント
*public CosmosClient cosmosClient;
コンテナ
*public Container container;
DB名
*private string databaseName = "todo";
コンテナ名
*private string containerName = "todo";
DBへ接続する、存在しなければDBを作成する
*await app.CreateDatabaseAsync();
コンテナへ接続する、存在しなければコンテナを作成する
*await app.CreateContainerAsync();
SQLを実行し、検索結果の取得と各UPDATEを実行する
*await app.QueryAndUpdateItemsAsync();
コンテナ名とパーティションキーを指定する。
存在しなければ指定したコンテナ名とパーティションキーでコンテナが作成される
*this.container = await this.database.CreateContainerIfNotExistsAsync(containerName, "/partitionKey");
クエリ、今回は全件検索
*var sqlQueryText = "SELECT * FROM c ";
クエリを実行する
*QueryDefinition queryDefinition = new QueryDefinition(sqlQueryText);
データを整形する
*item.Date = example(item);
ドキュメントを更新する
*await this.container.ReplaceItemAsync<;dynamic>;(
コンテナ名とパーティションキーを指定する。
存在しなければ指定したコンテナ名とパーティションキーでコンテナが作成される
*this.container = await this.database.CreateContainerIfNotExistsAsync(containerName, "/partitionKey");
クエリ、今回は全件検索
*var sqlQueryText = "SELECT * FROM c ";
クエリを実行する
*QueryDefinition queryDefinition = new QueryDefinition(sqlQueryText);
データを整形する
*item.Date = example(item);
ドキュメントを更新する
*await this.container.ReplaceItemAsync<;dynamic>;(
クエリ、今回は全件検索
*var sqlQueryText = "SELECT * FROM c ";
クエリを実行する
*QueryDefinition queryDefinition = new QueryDefinition(sqlQueryText);
データを整形する
*item["Date"] = example(item);
ドキュメントを更新する
*await this.container.ReplaceItemAsync<;dynamic>;(

コード全体を取得する
*var root = action.Tree.GetRoot(action.CancellationToken);
Whitespace Trivia だけ取り出して
*var triviaList = root.DescendantTrivia()
*if (!trivia.ToString().Contains("　"))*{
全角スペースを拾う
違反位置を特定して通報
*}
違反位置を特定して通報
*var location = trivia.GetLocation();
同時に実行できるようにする
*context.EnableConcurrentExecution();
自動生成コードは検査しないようにする
*context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
Whitespace だけ取り出して
*var triviaList = root.DescendantTrivia()
*if (!trivia.ToString().Contains("　"))*{
全角スペースを拾う
違反位置を特定して通報
*var location = trivia.GetLocation();
*if (!(action.Node is MemberAccessExpressionSyntax expression))*{
メンバーアクセスでないのをフィルター
*if(!(action.SemanticModel.GetSymbolInfo(expression.Name).Symbol is IFieldSymbol field))*{
Name がフィールド変数かどうか
*if (field.Name.ToLower() != "empty")*{
Name が Empty でない
*if (field.Type.SpecialType != SpecialType.System_String)*{
System.String でない
string.Empty と断定し通報
*var diagnostic = Diagnostic.Create(Rule, expression.GetLocation(), expression.Expression.GetText());

*return Intrinsic.Result.Waiting;
変更
ログ出力先など初期設定
*_interpreter.hostData = this;
mes コマンド定義
*var f = Intrinsic.Create("mes");
スクリプトコンパイル、実行
*_interpreter.Reset(_scriptField);
スクリプトが終了する、または途中で中断(yield)されたり、一定の処理時間が経過するまで処理が実行されます
*_interpreter.RunUntilDone();

removeの方は検討範囲外なので省略
*}
敵死亡時の処理
*}

*mail.HtmlBody.AddLink("パスワード更新フォーム", Properties.Resources.Password_Updater);
UploaderのPath

*foreach (int color in GetValues(typeof(Colors)))*{
using static System.Enum がない場合は　Enum.GetValues と書く必要がある。
using static Colors がない場合は Colors.Blue と書く必要がある。
*var myFavoriteColor = Blue;
リソースを使用する権利取得：コンストラクタ(ファイルパス, ファイル操作のモード,
ファイル操作でのアクセスレベル, ファイルを開いている間の他のプログラムからのアクセス許可レベル = Noneは不許可)
*FileStream fs = new FileStream("hoge.txt", FileMode.Open, FileAccess.Read, FileShare.None);
何かしらの処理
*}
例外処理
*}

レポートの印刷
*oAccess = new Microsoft.Office.Interop.Access.ApplicationClass();

(補足：ViewAはUserControl型で定義されたコントロール)
*regionManager.RegisterViewWithRegion("ContentRegion", typeof(ViewA));

*var pivot = rectTransform.pivot;*var sprite = image.sprite;
スプライト内の座標空間での位置を計算する
どれかの多角形の内部にあればtrueを返す
*return true;
pからx軸の正方向への無限な半直線を考えて、多角形との交差回数によって判定する
*var n = polygon.Count;

*Console.WriteLine("for-each");*foreach(string s in str.Split(' ')) {
for-each
ラムダ式
*str.Split(' ').ToList().ForEach(s =>; Console.WriteLine(s));
*Console.WriteLine("for-each");*//文字列型配列の宣言と初期化
for-each
文字列型配列の宣言と初期化
*string[] strArray = str.Split(',');
*int[] num_foreach = new int[strArray.Length];*//インデックス変数の宣言と初期化
整数型配列の宣言
インデックス変数の宣言と初期化
*int i = 0;
*foreach(string s in strArray) {*num_foreach[i] = int.Parse(s);
整数型配列の代入
*foreach(int n in num_foreach) {*Console.WriteLine(n);
整数型配列の各要素の出力
ラムダ式
*Console.WriteLine("");
文字列の分割からの整数型配列の宣言と初期化
*int[] num_lambda = str.Split(',').Select(s =>; int.Parse(s)).ToArray();
*foreach(int j in num_lambda) {*Console.WriteLine(j);
整数型配列の各要素の出力

*e.Result = "!Unknown command";
仮設定、再設定しないとこれが表示される
文字列先頭の！は特別な色（一般には赤）で表示する指定文字
コマンドの前後の空白を取る
*string command = e.Command.Trim();
コマンドと引数に分割
*string[] com_arg =  Regex.Split(e.Command.Trim(),@"\s+");
*if (com_arg.Length == 1 &amp;&amp; com_arg[0] == "") { e.Result = ""; return; }*//トークン数が3以上なら「引数多すぎ」
トークン数が0なら何もしないでリターン
*if (com_arg.Length >; 3) { e.Result = "!Too many argument."; return; }*//「命令文字列のみ」に一致するか？
トークン数が3以上なら「引数多すぎ」
*if (Regex.IsMatch(command, @"^\w+$")) {e.Result = Do(com_arg[0], 0, 0); return;}*//「命令文字列　16進引数」に一致するか？
「命令文字列のみ」に一致するか？
*if (Regex.IsMatch(command, @"^\w+\s+[a-fA-F0-9]{1,4}$")) {*e.Result = Do(com_arg[0], System.Convert.ToUInt32(com_arg[1], 16), 0);
「命令文字列　16進引数」に一致するか？
*if (Regex.IsMatch(command, @"^\w+\s+[a-fA-F0-9]{1,4}\s+[a-fA-F0-9]{1,4}$")) {*e.Result = Do(com_arg[0], Convert.ToUInt32(com_arg[1], 16), Convert.ToUInt32(com_arg[2], 16));
「命令文字列　16進引数　16進引数」に一致するか？
*String Do(string command, uint arg1, uint arg2) {/// OPENif (command == "o") {uint sts = FT245.Open();if (sts == 0) return ("Open Success");return ("!Open error  (sts = " + Convert.ToString(sts) + ").");}/// CLOSEif (command == "c") {uint sts = FT245.Close();if (sts == 0) return ("Close Success");return ("!Close error  (sts = " + Convert.ToString(sts) + ").");}/// WRITE ONE BYTE (Write指定していないビットには出力しない)if (command == "w") {FT245.Put(arg1);uint sts = FT245.Flush();if (sts == 0) return ("Write Success");return ("!Writr error  (sts = " + Convert.ToString(sts) + ").");}/// READ ONE BYTE  (Read指定していないビットは0が入力される)if (command == "r") {int value = 0;uint sts = FT245.Get(ref value);if (sts == 0) return ("Get Success value = " + Convert.ToString(value));return ("!Get error  (sts = " + Convert.ToString(sts) + ").");}/// 意味不明なコマンドreturn ("!Unknown command : " + command + " " + Convert.ToString(arg1) + " " + Convert.ToString(arg2));}
コマンド自体は任意の文字列、コマンドの引数は0～255までの値が最大2個添付可能
*String Do(string command, uint arg1, uint arg2) {/// OPENif (command == "o") {uint sts = FT245.Open();if (sts == 0) return ("Open Success");return ("!Open error  (sts = " + Convert.ToString(sts) + ").");}/// CLOSEif (command == "c") {uint sts = FT245.Close();if (sts == 0) return ("Close Success");return ("!Close error  (sts = " + Convert.ToString(sts) + ").");}/// WRITE ONE BYTE (Write指定していないビットには出力しない)if (command == "w") {FT245.Put(arg1);uint sts = FT245.Flush();if (sts == 0) return ("Write Success");return ("!Writr error  (sts = " + Convert.ToString(sts) + ").");}/// READ ONE BYTE  (Read指定していないビットは0が入力される)if (command == "r") {int value = 0;uint sts = FT245.Get(ref value);if (sts == 0) return ("Get Success value = " + Convert.ToString(value));return ("!Get error  (sts = " + Convert.ToString(sts) + ").");}/// 意味不明なコマンドreturn ("!Unknown command : " + command + " " + Convert.ToString(arg1) + " " + Convert.ToString(arg2));}
但し、不要な（無意味な）引数を添付しても、エラーとはせず無視するだけとしている

*{IsSuccessful = true,IDToken = result.AccessToken};
トークンを取得

サーバー保存処理
*return true;
サーバー保存処理
*return true;
サーバー保存処理
ここで _name.Get() を使う。
*return true;
コンストラクタ代わりに実行される
*}

*return description ?? strValue;
descriptionがnullならstrValueを返す

dgvListはDataGridViewコントロール
*this.dgvList.Rows[0].Cells[0].Value
dgvListはDataGridViewコントロール
*this.dgvList[0, 0].Value
dgvListはDataGridViewコントロール
セルの値を取得したり変更したりする
*this.dgvList[0, 0].Value
セルの文字色を取得したり変更したりする
*this.dgvList[0, 0].Style.ForeColor
セルの背景色を取得したり変更したりする
*this.dgvList[0, 0].Style.BackColor
セルのエラーアイコンとメッセージを取得したり変更したりする
*this.dgvList[0, 0].ErrorText
セルのフォントを取得したり変更したりする
*this.dgvList[0, 0].Style.Font
行と紐付いているバインドオブジェクトを取得します。
*this.dgvList.Rows[0].DataBoundItem
dgvListはDataGridViewコントロール
カスタムクラスのバインドリストををバインドする場合、AutoGenerateColumnsプロパティをfalseにしないと勝手に列が追加されてしまう
*this.dgvList.AutoGenerateColumns = false;
整数を入力した場合
*field = intValue;
何も入力しない場合
*field = null;
文字や記号を含めて入力した場合
何もしない
*}
※sbListはSortableBindingList
DataGridViewの行を追加する
*this.sbList.Add(【カスタムクラス】);
DataGridViewの１行目に行を挿入する
*this.sbList.Insert(1, 【カスタムクラス】);
DataGridViewの１行目を削除する
*this.sbList.RemoveAt(1);
DataGridViewの行をすべてクリアする
*this.sbList.Clear();
DataGridViewのセルの値は基本的に次のように参照することができます。
*this.dgvList[0, 0].Value
ですが、カスタムクラスを使用すると、次のようにも参照することができます。
※rowBoundはカスタムクラス
*rowBound.Name
整数を入力した場合
*field = intValue;
何も入力しない場合
*field = null;
文字や記号を含めて入力した場合
何もしない
*}
*if (rowBound.Name == null || rowBound.Name.Trim().Length == 0)*{
名前
未入力
*cell.Style.BackColor = Color.LightPink;
入力有
*cell.Style.BackColor = Color.White;
*if (rowBound.Kyoka1Point != null &amp;&amp; rowBound.Kyoka1Point.Value <; 30)*{
国語の点数
赤点
*cell.Style.BackColor = Color.LightPink;
合格点
*cell.Style.BackColor = Color.White;
*if (rowBound.Kyoka2Point != null &amp;&amp; rowBound.Kyoka2Point.Value <; 30)*{
数学の点数
赤点
*cell.Style.BackColor = Color.LightPink;
合格点
*cell.Style.BackColor = Color.White;
*if (rowBound.Kyoka3Point != null &amp;&amp; rowBound.Kyoka3Point.Value <; 30)*{
理科の点数
赤点
*cell.Style.BackColor = Color.LightPink;
合格点
*cell.Style.BackColor = Color.White;
*if (rowBound.Kyoka4Point != null &amp;&amp; rowBound.Kyoka4Point.Value <; 30)*{
社会の点数
赤点
*cell.Style.BackColor = Color.LightPink;
合格点
*cell.Style.BackColor = Color.White;
*if (rowBound.Kyoka5Point != null &amp;&amp; rowBound.Kyoka5Point.Value <; 30)*{
英語の点数
赤点
*cell.Style.BackColor = Color.LightPink;
合格点
*cell.Style.BackColor = Color.White;
*if (rowBound.Name == null || rowBound.Name.Trim().Length == 0)*{
名前
未入力
*cell.ErrorText = "名前が未入力です。";
入力有
*cell.ErrorText = "";
*if (rowBound.Kyoka1Point != null &amp;&amp; rowBound.Kyoka1Point.Value <; 30)*{
国語の点数
赤点
*cell.ErrorText = "国語が赤点です。";
合格点
*cell.ErrorText = "";
赤点
*cell.ErrorText = "数学が赤点です。";
合格点
*cell.ErrorText = "";
*if (rowBound.Kyoka3Point != null &amp;&amp; rowBound.Kyoka3Point.Value <; 30)*{
理科の点数
赤点
*cell.ErrorText = "理科が赤点です。";
合格点
*cell.ErrorText = "";
*if (rowBound.Kyoka4Point != null &amp;&amp; rowBound.Kyoka4Point.Value <; 30)*{
社会の点数
赤点
*cell.ErrorText = "社会が赤点です。";
合格点
*cell.ErrorText = "";
*if (rowBound.Kyoka5Point != null &amp;&amp; rowBound.Kyoka5Point.Value <; 30)*{
英語の点数
赤点
*cell.ErrorText = "英語が赤点です。";
合格点
*cell.ErrorText = "";
親リストにデータソースを追加したとき勝手に列が追加されないようにする
*this.dgvList.AutoGenerateColumns = false;
子リストにデータソースを追加したとき勝手に列が追加されないようにする
*this.dgvListChild.AutoGenerateColumns = false;
親リストのデータソースを設定する
*this.dgvList.DataSource = this.sbList;
子リストのデータソースをセットする。
*this.dgvListChild.DataSource = rowBound.ChildList;

↑小技:最後の要素にも「,」をつけておくと、後ろに項目を追加するときに忘れなくて便利
*}
*{// 途中でreturnで抜けるので、1つもbreakが無い例になってしまいましたが、// (A)の３つ以上に分岐しているswitch (type){case Linetype.None:return Color.White;case Linetype.New:case Linetype.Add:case Linetype.Edit:// (B)フォールスルーを使い複数の条件について処理しているreturn Color.Yellow;case Linetype.Delete:// 削除行は灰色で…というああいう感じのreturn Color.Gray;default:return Color.White;}}
編集可能な行の状態によって背景色を変えるときに使うイメージのメソッド
途中でreturnで抜けるので、1つもbreakが無い例になってしまいましたが、
(A)の３つ以上に分岐している
*switch (type)
(B)フォールスルーを使い複数の条件について処理している
*return Color.Yellow;
削除行は灰色で…というああいう感じの
*return Color.Gray;

DefaultAssetのパスを取得する
*string path = AssetDatabase.GetAssetPath(DirectoryAsset);
取得したパスがディレクトリのパスの時だけ、パスを返す
*bool isDirectory = File.GetAttributes(path).HasFlag(FileAttributes.Directory);
ディレクトリを指定させる
*_directoryAsset = (DefaultAsset) EditorGUILayout.ObjectField("ディレクトリを指定", _directoryAsset, typeof(DefaultAsset), true);
DefaultAssetのパスを取得する
*string path = AssetDatabase.GetAssetPath(_directoryAsset);
ディレクトリでなければ、指定を解除する
*bool isDirectory = File.GetAttributes(path).HasFlag(FileAttributes.Directory);

*_ = GoToAsync("
AboutPage").ContinueWith(async (result) =&gt;
*{await DisplayAlert("Error", result.Exception.Message, "Close");});
エラーが起きてたら何か処理

*private string SendMail(){var toAddress = ~~~~;//_accessLogsを添付したメールをToAddressに送信する処理}
_accessLogsとtimeを使ってPDFを出力する処理を記述
_accessLogsを添付したメールをToAddressに送信する処理
*}
Humanクラス内のどのメソッドからもageに代入できる。産まれた後も同一人物でも毎年変わっていきます。
*private string age;
コンストラクタでしか代入できない。基本的に人は産まれてからずっと同じ名前で生きていきます。
*private readonly string _name;
インスタンスによらない変数を定義できる。人類みんなホモサピエンス。
*private static string scienceName;
*if(){*hogehoge
具体処理内容
*else if(vehicleType == vehicleType.bike){//自転車運転する}
車運転する
自転車運転する
*}

*var content = JsonContent.Create<;Message<;(message);
Content-Type: applicationjson; charset=utf-8

*}
*1

処理
*}

テストコード
*string text = "適当な値";
*@Html.Label(dynamicObj, htmlAttributes: new { @class = "control-label" })
コンパイルエラー
*@Html.Label(dynamicObj.Value as string, htmlAttributes: new { @class = "control-label" })
コンパイルOK

*{Invoke("transition", 0.5f);}
Start is called before the first frame update
*{}
Update is called once per frame
*{//raw imageの取得mask = GameObject.Find("Masking_Image");//画面全体に広げるmask.GetComponent<;RectTransform>;().sizeDelta = new Vector2(Screen.width, Screen.height);//透明度を最大にするColor color_before = mask.GetComponent<;RawImage>;().color;color_before.a = 0.0f;Color color_after = color_before;mask.GetComponent<;RawImage>;().color = color_after;//非活性にし画面を操作できるようにするmask.GetComponent<;RawImage>;().enabled = false;//画面遷移transition();}
Start is called before the first frame update
raw imageの取得
*mask = GameObject.Find("Masking_Image");
*mask.GetComponent<;RectTransform>;().sizeDelta = new Vector2(Screen.width, Screen.height);*//透明度を最大にする
画面全体に広げる
*Color color_before = mask.GetComponent<;RawImage>;().color;*color_before.a = 0.0f;
透明度を最大にする
非活性にし画面を操作できるようにする
*mask.GetComponent<;RawImage>;().enabled = false;
画面遷移
*transition();
*{}
Update is called once per frame
フェードアウト処理を呼ぶ
*Call_Fade();
シーン切り替え
*Invoke("Scene_2", 0.5f);
*{for (int i = 0; i <; 100; i++){Color color = mask.GetComponent<;RawImage>;().color;color.a += 0.01f;mask.GetComponent<;RawImage>;().color = color;if (i == 99){yield break;}else{yield return null;}}}
フェードアウト処理

*fFT.FFT2D_256_Dispatch(d_ht, d_ht_dmy);
d_htから高さデータを計算
レンダリングを開始
*renderingShader_Material.SetPass(0);
n個のオブジェクトをレンダリング
*Graphics.DrawProceduralNow(MeshTopology.Points, 256 * 256);
解放
*d_h0.Release();

*{// 出力ディレクトリにコピーした観測点情報を読み込むvar points = ObservationPoint.LoadFromMpk("ShindoObsPoints.mpk.lz4", true);// しっかりメモリを開放するためにusingをつけてAPIのクライアントを作成するusing var webApi = new WebApi();// 現時刻から1分前の時刻を取得するvar targetTime = DateTime.Now.AddMinutes(-1);// もとにする観測点情報と取得したい時間を添えて震度を取得するvar result = await webApi.ParseIntensityFromParameterAsync(points, targetTime);// Dataがnullの場合は取得に失敗しているif (result.Data == null){Console.WriteLine("取得に失敗しました");return;}// とりあえず観測点情報を出力してみるforeach (var point in result.Data){// AnalysisResultがnullの場合は取得できていない観測点のため表示しないif (point.AnalysisResult == null)continue;// 地域名 観測点名 震度 の形で出力してみるConsole.WriteLine(point.ObservationPoint.Region + " " + point.ObservationPoint.Name + " " + point.AnalysisResult);// point.Color で解析に使用された色// point.ObservationPoint.Location で地理座標// とかいろいろできるので活用しよう！}}
awaitが使えるようにasync Taskに
出力ディレクトリにコピーした観測点情報を読み込む
*var points = ObservationPoint.LoadFromMpk("ShindoObsPoints.mpk.lz4", true);
しっかりメモリを開放するためにusingをつけてAPIのクライアントを作成する
*using var webApi = new WebApi();
現時刻から1分前の時刻を取得する
*var targetTime = DateTime.Now.AddMinutes(-1);
もとにする観測点情報と取得したい時間を添えて震度を取得する
*var result = await webApi.ParseIntensityFromParameterAsync(points, targetTime);
*if (result.Data == null)*{
Dataがnullの場合は取得に失敗している
*foreach (var point in result.Data)*{
とりあえず観測点情報を出力してみる
*if (point.AnalysisResult == null)*continue;
AnalysisResultがnullの場合は取得できていない観測点のため表示しない
地域名 観測点名 震度 の形で出力してみる
*Console.WriteLine(point.ObservationPoint.Region + " " + point.ObservationPoint.Name + " " + point.AnalysisResult);
point.Color で解析に使用された色
point.ObservationPoint.Location で地理座標
とかいろいろできるので活用しよう！
*}
地中PGA画像データへのURLを作成
*WebApiUrlGenerator.Generate(WebApiUrlType.RealtimeImg, targetTime, RealtimeDataType.Pga, true);
地上1.0Hz応答速度画像データへのURLを作成
*WebApiUrlGenerator.Generate(WebApiUrlType.RealtimeImg, targetTime, RealtimeDataType.Response_1Hz);
P/S波画像データへのURLを作成
*WebApiUrlGenerator.Generate(WebApiUrlType.PSWave, targetTime);
緊急地震速報情報のURLを作成
*WebApiUrlGenerator.Generate(WebApiUrlType.EewJson, targetTime);

*//foreach (var root in allRoots)*//{
これでも大分マシな速度は出た
*//{//    root.Folders = folders.Where(f =>; f.RootID == root.ID).ToList();//}
foreach (var root in allRoots)
*foreach (var folder in folders.GroupBy(f =>; f.RootID))*{
↑に比べてループ部分は10分の1ぐらいで終わった

生座標は動きすぎるので適当に調整
*var jointPos = new Vector3(

*}
MssSampleExtensionAction

*while (buffer[pos] <; 48) { neg = buffer[pos] == 45; MoveNext(); }*do { res = checked(res * 10 + (buffer[pos] ^ 48)); MoveNext(); } while (48 ;= buffer[pos]);
'0' == 48

*int Add(int a, int b) {return a + b;}
通常のメソッド
*(int a, int b) =>; { return a + b; };
ラムダ式

中身は後でつくる
*}
トーストを組み立てる
*ToastContent toastContent = new ToastContentBuilder()
*var toast = new ToastNotification(toastContent.GetXml());*// トーストを表示
組み立てたやつをもとにToastNotificationを作成
*DesktopNotificationManagerCompat.CreateToastNotifier().Show(toast);*,,,
トーストを表示
ログ表示
*MainWindow.mw.AddLog("OnActivated()実行しました");
*if (App.Current.Windows.Count == 0)*{
ウインドウを開く (アプリが閉じている間にトーストが押されたとき(≒アクションセンターで押された時)等)
ウインドウをActivateして、フォーカスをあてる
*MainWindow.mw.AddLog("メインウインドウにフォーカス当てました");
最小化してたら通常の大きさに戻す
*App.Current.Windows[0].WindowState = WindowState.Normal;

ノーツの移動速度の計算方法
*speed  = "曲のノーツスピード" * "プレイヤーが設定したノーツスピード" * "曲のBPM" / 60;
この際、曲のノーツスピードは基本値を１にしておくこと
*,,,

navMeshPath.corners に移動経路が入っています
*,,,
path.vectorPath に移動経路が入っています
*}
各ステートクラスでの参照用
*Character character;
*{Move,Attack,}
ステート遷移用ID
*{protected override void Update(){Context.character.Move();// ターゲットに近づいたら攻撃ステートに遷移if (Context.character.IsNearTarget()){Context.stateMachine.SendEvent(TransitionEventId.Attack);}}}
移動ステート
*if (Context.character.IsNearTarget())*{
ターゲットに近づいたら攻撃ステートに遷移
*{protected override void Enter(){// ステート遷移時に攻撃開始Context.character.Attack();}protected override void Update(){// 攻撃が終わったら移動ステートに遷移if (!Context.character.IsAttacking()){Context.stateMachine.SendEvent(TransitionEventId.Move);}}}
攻撃ステート
ステート遷移時に攻撃開始
*Context.character.Attack();
*if (!Context.character.IsAttacking())*{
攻撃が終わったら移動ステートに遷移
遷移条件の設定
*stateMachine.AddTransition<;MoveState, AttackState>;(TransitionEventId.Attack);

トークンは非公開にするか、外部ソースから読み込むことを忘れないでください。
この例では、環境変数からトークンを読み取ります。
環境変数の設定方法がわからない場合は、インターネット上で、
または構成からの読み取りなどの他の方法を使用して、詳細情報を参照できます。
*await _client.LoginAsync(TokenType.Bot,
プログラムが終了するまで、このタスクをブロックします。
*await Task.Delay(-1);

*{WebSocketProvider = WS4NetProvider.Instance,UdpSocketProvider = UDPClientProvider.Instance,});
...

*public string? Remarks { get; }
C# 8.0
*public string Remarks { get; }
C# 7.3
*{Id = id;if (ReferenceEquals(name, null))throw new ArgumentNullException(nameof(name));Name = name;Remarks = remarks;ParentId = parentId;}
C# 6
*{id = Id;name = Name;remarks = Remarks;parentId = ParentId;}
C# 6
*public int Id { get; }
C# 6
*public int Id { get { return _id; } }
C# 5
*public int Id { get; private set; }
or
*{return Equals(obj as ImmutableValueClass);}
C# 5
*=>; $"{nameof(ImmutableValueClass)}: {{ {nameof(Id)}: {Id}, {nameof(Name)}: {Name}, {nameof(Remarks)}: {Remarks}, {nameof(ParentId)}: {ParentId} }}";
C# 6
*{return string.Format("ImmutableValueClass: {{ Id: {0}, Name: {1}, Remarks: {2}, ParentId: {3} }}", Id, Name, Remarks, ParentId);}
C# 5
*if (ReferenceEquals(name, null))*throw new ArgumentNullException(nameof(name));
C# 6
*if (ReferenceEquals(name, null))*throw new ArgumentNullException("name");
C# 5
*public ImmutableValueClass(int id, string name) : this(id, name, null, default(int?)) {}
C# 3
*public string Remarks { get; private set; }
C# 3
*public string Remarks { get { return _remarks; } }
C# 2

略
*}
本当はプロパティを準備したほうがいいが、サンプルのためpublicフィールド
*[Required] public string stringValue;
プロジェクト中のPrefabもシーン上のGameObjectも
どちらも参照設定できてしまう
*[SerializeField] GameObject target;
プロジェクト中のAsset（Prefab）を指定すべき場合は、AssetsOnlyを
[SerializeField, AssetsOnly] GameObject target;
シーン上のGameObjectを指定すべき場合はSceneObjectsOnlyを
[SerializeField, AssetsOnly] GameObject target;
*}

予約可能かどうか判定する?
*予約Id = 予約Id.Create();

*return String.Compare(a, b, true);
ignore case

*BaseAddress = new Uri("https:
localhost:59320api")

*input.Type = 0;
MOUSE = 0
アクティブなウィンドウのデバイスコンテキストを取得
*IntPtr hWnd = NativeMethods.GetForegroundWindow();
ウィンドウの大きさを取得
*RECT winRect = new RECT();
Graphicsのデバイスコンテキストを取得
*IntPtr hDC = g.GetHdc();
Bitmapに画像をコピーする
*NativeMethods.BitBlt(hDC, 0, 0, bmp.Width, bmp.Height, winDC, 0, 0, SRCCOPY);
停止させる
*tmr.Stop();
画面全体をコピーする
*g.CopyFromScreen(new Point(curScreen.Bounds.Left, curScreen.Bounds.Top), new Point(0, 0), bmp.Size);
*if ( !_timerIsRunning ) {_msBuffer = new List<;MemoryStream>;();_timerIsRunning = true;_countForStartDelay = StartDelayInMs/IntervalInMs;tmr.Start();}
btnSave.Enabled = false;

*var t = elem.Elements();
直下の子ノードたち
*if (args.Length==1){*Application.Run(new XmlTreeView(args[0]));
Application.Run(new XmlTreeView(@"hogehoge.xml"));

*public float Norm { get; }
自動生成対象外
*{(X, Y, Z) = (x, y, z);Norm = (float)Math.Sqrt(X * X + Y * Y + Z * Z);}
コンストラクタをこちらで定義した場合自動生成対象外

*lastnameText.SetFocus();
今のところそんなメソッドはない。

*(await client.GetAsync(@"https:
manda-yonda.comauthor")).IsSuccessStatusCode.IsTrue();
*{driver.Navigate().GoToUrl(TopPage);WaitState("top");driver.Title.Is("トップ|マンガ読んだ！！");//移動ClickElement("#navbar-search-button");//シリーズ画面WaitState("series");driver.Title.Is("シリーズ一覧|マンガ読んだ！！");}
作った時の実装
移動
*ClickElement("#navbar-search-button");
シリーズ画面
*WaitState("series");
今回リファクタリングまで終わった実装
*[TestMethod]

*public UnityEngine.UI.Button retryButton;
Inspectorで設定

SceneのアトリビュートはMirrorに用意されている便利機能
Inspectorでシーンを参照してコード内で文字列として使用できる
*[SerializeField,Scene] private string _gameSceneName;
シーン遷移などで破棄されたタイミングで検索をやめる
*StopDiscovery();
データ受信の準備
*NetworkClient.RegisterHandler<;SendHostReadyData>;(ReceivedReadyInfo);
*{//見つけたサーバーを辞書に登録_discoveredServer = serverResponse;Debug.Log("ServerFound");});
サーバー見つけたらこれが呼ばれる
見つけたサーバーを辞書に登録
*_discoveredServer = serverResponse;
*{Debug.Log("Search Connection");_backButton.transform.gameObject.SetActive(true);_multiPlayButton.transform.gameObject.SetActive(false);//接続を試みる_cancellationTokenSource = new CancellationTokenSource();CancellationToken token = _cancellationTokenSource.Token;TryConnectAsync(token).Forget();});
サーバーの検索＆接続開始
接続を試みる
*_cancellationTokenSource = new CancellationTokenSource();
*{Debug.Log("Cancel");//サーバーから抜ける//サーバーの検索停止StopDiscovery();NetworkManager.singleton.StopHost();//非同期処理止める_cancellationTokenSource.Cancel();_cancellationTokenSource.Dispose();});
最初の画面に戻る
サーバーから抜ける
サーバーの検索停止
*StopDiscovery();
非同期処理止める
*_cancellationTokenSource.Cancel();
*{Debug.Log("Ready Ok");//各クライアントにフラグデータを送るSendHostReadyData sendData = new SendHostReadyData() {IsHostReady = true};NetworkServer.SendToAll(sendData);_playButton.transform.gameObject.SetActive(false);});
ホスト側にのみ表示されるボタン プレイボタン押下で準備完了とする
*SendHostReadyData sendData = new SendHostReadyData() {IsHostReady = true};
各クライアントにフラグデータを送る
ローカルのフラグに反映
*_isHostReady = receivedData.IsHostReady;
サーバーの検索開始
*StartDiscovery();
*while (!_networkManager.isNetworkActive)*{
サーバーに接続するまでループ
n秒間隔で実行
*await UniTask.Delay(TimeSpan.FromSeconds(CONNECT_INTERVAL_TIME), cancellationToken: token);
*if (_discoveredServer.uri != null)*{
サーバー発見した場合
クライアントとして接続開始
*_networkManager.StartClient(_discoveredServer.uri);
接続ステータスの文言変更
*_connectionStateText.text =CONNECTION_STATUS_CLIENT_WAITING;
サーバーの検索停止
*StopDiscovery();
ここでホストの開始フラグを待つ
*await UniTask.WaitUntil(() =>; _isHostReady, cancellationToken: token);
接続ステータスの文言変更
*_connectionStateText.text = CONNECTION_STATUS_SUCCESS;
*{Debug.Log("Try Connect...");//接続を試みた回数をカウントアップtryCount++;//任意の回数以上接続に試みて失敗した場合は自身がホストになるif (tryCount >; CONNECT_TRY_COUNT){Debug.Log("Start Host");//ホストになる(サーバー)_networkManager.StartHost();//サーバーあるよーってお知らせするAdvertiseServer();//接続ステータスの文言変更_connectionStateText.text = CONNECTION_STATUS_HOST_WAITING;//プレイボタン表示_playButton.gameObject.SetActive(true);//ここでホストの開始フラグを待つawait UniTask.WaitUntil(() =>; _isHostReady, cancellationToken: token);//接続ステータスの文言変更_connectionStateText.text = CONNECTION_STATUS_SUCCESS;//n秒待つawait UniTask.Delay(TimeSpan.FromSeconds(WAIT_TIME), cancellationToken: token);//シーン遷移_networkManager.ServerChangeScene(_gameSceneName);}}
サーバー見つからない場合
接続を試みた回数をカウントアップ
*tryCount++;
*if (tryCount >; CONNECT_TRY_COUNT)*{
任意の回数以上接続に試みて失敗した場合は自身がホストになる
ホストになる(サーバー)
*_networkManager.StartHost();
サーバーあるよーってお知らせする
*AdvertiseServer();
接続ステータスの文言変更
*_connectionStateText.text = CONNECTION_STATUS_HOST_WAITING;
プレイボタン表示
*_playButton.gameObject.SetActive(true);
ここでホストの開始フラグを待つ
*await UniTask.WaitUntil(() =>; _isHostReady, cancellationToken: token);
接続ステータスの文言変更
*_connectionStateText.text = CONNECTION_STATUS_SUCCESS;
n秒待つ
*await UniTask.Delay(TimeSpan.FromSeconds(WAIT_TIME), cancellationToken: token);
シーン遷移
*_networkManager.ServerChangeScene(_gameSceneName);
*{Debug.Log("Ready Ok");//各クライアントにフラグデータを送るSendHostReadyData sendData = new SendHostReadyData() {IsHostReady = true};NetworkServer.SendToAll(sendData);_playButton.transform.gameObject.SetActive(false);});
ホスト側にのみ表示されるボタン プレイボタン押下で準備完了とする
*SendHostReadyData sendData = new SendHostReadyData() {IsHostReady = true};
各クライアントにフラグデータを送る
データ受信の準備
*NetworkClient.RegisterHandler<;SendHostReadyData>;(ReceivedReadyInfo);
ローカルのフラグに反映
*_isHostReady = receivedData.IsHostReady;
*if (_titleScene.Contains(SceneManager.GetActiveScene().name))*{
タイトルシーンでのみ実行
*SendPlayerCountData sendData = new SendPlayerCountData() {PlayerCount = NetworkServer.connections.Count};
接続中の人数表記を変える
*if (_mainScene.Contains(SceneManager.GetActiveScene().name))*{
メインシーンでのみ実行
プレイヤー生成
*GameObject player = Instantiate(playerPrefab);
今立ち上げているサーバーにプレイヤーを追加登録
*NetworkServer.AddPlayerForConnection(conn, player);
*SendPlayerCountData sendData = new SendPlayerCountData() {PlayerCount = NetworkServer.connections.Count};
接続中の人数表記を変える
*if (_titleScene.Contains(SceneManager.GetActiveScene().name))*{
タイトルシーンでのみ実行
*SendPlayerCountData sendData = new SendPlayerCountData() {PlayerCount = NetworkServer.connections.Count};
接続中の人数表記を変える
*if (_mainScene.Contains(SceneManager.GetActiveScene().name))*{
メインシーンでのみ実行
プレイヤー生成
*GameObject player = Instantiate(playerPrefab);
今立ち上げているサーバーにプレイヤーを追加登録
*NetworkServer.AddPlayerForConnection(conn, player);

ここでblendshape名を取得したい…
var morphPath = ?
後はなんやかんやパスを使った処理
*...
表情名から対応したFacialDataを取得する
*FacialData newFacialData = FacialData.GetFacialData(facialExpressionName);
以下メンバ変数にはblendshape名が含まれる
*public string BrwMorph;
ここでblendshape名を取得したい
Enumの値の文字列を含むFacialDataのメンバ変数が欲しい
*var morphPath = data.GetMorphPath(morphType.ToString());
後はなんやかんやパスを使った処理
*...
以下メンバ変数にはblendshape名が含まれる
*public string BrwMorph;

-------省略--------
*[MenuItem("Assets/Open C# Project")]
-------省略--------
*,,,

*{}
Start is called before the first frame update
*{}
Update is called once per frame

*isBounce = true;
接触可能に
*Vector2 force = new Vector2(0.5f, 10f);*rb.AddForce(force, ForceMode2D.Impulse);
加える力の大きさ
接触していない時は跳ねないように
*isBounce = false;

*{"Z:\\source\\repos\\SourceExpander\\Sample\\SampleProject\\obj\\Debug\\netcoreapp3.1\\SampleProject.AssemblyInfo.cs",SourceCode.FromDictionary(new Dictionary<;string,object<;{{"path","Z:\\source\\repos\\SourceExpander\\Sample\\SampleProject\\obj\\Debug\\netcoreapp3.1\\SampleProject.AssemblyInfo.cs"},{"code","[assembly: System.Reflection.AssemblyCompanyAttribute(\"naminodarie\")]\r\n[assembly: System.Reflection.AssemblyConfigurationAttribute(\"Debug\")]\r\n[assembly: System.Reflection.AssemblyFileVersionAttribute(\"2.2.0.101\")]\r\n[assembly: System.Reflection.AssemblyInformationalVersionAttribute(\"2.2.0\")]\r\n[assembly: System.Reflection.AssemblyProductAttribute(\"SampleProject\")]\r\n[assembly: System.Reflection.AssemblyTitleAttribute(\"SampleProject\")]\r\n[assembly: System.Reflection.AssemblyVersionAttribute(\"2.2.0.101\")]\r\n[assembly: System.Reflection.AssemblyMetadataAttribute(\"RepositoryUrl\", \"https:
github.comnaminodarieSourceExpander\")]\r\n\r\n MSBuild WriteCodeFragment クラスによって生成されました。\r\n\r\n#region Expanded\r\n#endregion Expanded\r\n"},})},
ソースコード
*}
ソースコード
*}

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

*GL.Enable(EnableCap.DepthTest);
Depthバッファの有効化(Z座標で手前に表示)
回転角度を更新する。
*Rotate++;
画面をクリアする。
*GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
手前から、Y軸を上に、原点を見る視点を作成。
*OpenTK.Matrix4 lookat = Matrix4.LookAt(-Vector3.UnitZ, Vector3.Zero, Vector3.UnitY);
*float[] eye = transform.GetEyeView();*OpenTK.Matrix4 eyeMat = MatrixFromArray(ref eye);
eyeMatをかけて左目または右目の視点にする。
図形を描画する。
*Shader.IdentityMatrix();

*Mutex mutex;
排他制御
*void Start() {string mutexName = "SensorAppMutex";bool createdNew = false;mutex = new Mutex(false, mutexName, out createdNew);}
下記のSampleObjectコンポーネントを取り付けたゲームオブジェクトのプレハブ
センサーから取得した結果
*SensorData data = null;
*Debug.LogError($"exception type: {ex.GetType()} msg: {ex.Message}");
なにかまずいことが起こった場合、ログに残す
*if (data != null) {*foreach (var point in data.points) {
データが取得できたので、その位置にオブジェクトを生成する
*{const float lifeTimeMax = 0.5f;float lifeTime = lifeTimeMax;void Update(){lifeTime -= Time.deltaTime;if (lifeTime <; 0){Destroy(this.gameObject);}}}
生成されて一定時間で消えるゲームオブジェクトの例

*return tcs.Task;
--- 完了が通知されるTaskを返す

*var resizedImageFile = await imageFile.RequestImageFileAsync(format, 100, 100);*var buffer = new byte[resizedImageFile.Size];
100*100の画像にリサイズ
*$"data:{format};base64,{Convert.ToBase64String(buffer)}";
ブラウザ上に表示するためにDataUrlに変換
REST APIなどからデータを取得するクラス
*private DummyPersonService _service = new DummyPersonService();
取得するデータの総数
*private int? totalCount;
*if (totalCount == null)*{
ロードするデータの総数を取得
開始位置と(StartIndex)データ数(Count)を指定して部分的にデータを取得
*var people = await _service.GetPeopleAsync(request.StartIndex, request.Count);
取得したデータ数とデータ総数を渡す
*return new ItemsProviderResult<;Person>;(people, totalCount ??= 0);

*Selection.objects = originalSelectedObjects;
操作前の選択状態に戻す。

publicなフィールドだからこれは良くない
*public float speed;
*public float Speed {get { return speed; }set { speed = value; }}
ちょっと古い書き方のプロパティー
publicなフィールドだからこれは良くない
*public float speed;

*{}
Start is called before the first frame update
*{if (Input.GetKey(KeyCode.UpArrow)){transform.position += new Vector3(0,0,-0.1f);}if (Input.GetKey(KeyCode.DownArrow)){transform.position += new Vector3(0,0,0.1f);}if (Input.GetKey(KeyCode.RightArrow)){transform.position += new Vector3(-0.1f,0,0);}if (Input.GetKey(KeyCode.LeftArrow)){transform.position += new Vector3(0.1f,0,0);}}
Update is called once per frame

*object Version9() { return new(); }
C# 9 target-typed new

*var data2 = default(Data);
1 = current, 2 = prev

*[Page(Url = "http:
www.selenium.academyExamplesInteraction.html")]

省略
*<;StackLayout Orientation="StackOrientation.Horizontal">;
省略
*<;/StackLayout>;

*person.Name = "ねこ";
コンパイルエラー
c is のあとは c に対する条件式
*public static bool IsLetterOrSpace(this char c) =>; c is >;= 'a' and <;= 'z' or >;= 'A' and <;= 'Z' or ' ';
従来の場合 c を何度も書く必要があった
*public static bool IsLetterOrSpace(this char c) =>; c >;= 'a' &amp;&amp; c <;= 'z' || c >;= 'A' &amp;&amp; c <;= 'Z' || ' ';

*float rotateSpeed=5.0f;
回転する速度
*this.transform.position += this.transform.forward * inputMove.Vertical *moveSpeed* Time.deltaTime;*//左スティックでの横移動
左スティックでの縦移動
*this.transform.position += this.transform.right * inputMove.Horizontal * moveSpeed*Time.deltaTime;*//右スティックでの回転
左スティックでの横移動
*transform.Rotate(new Vector3(0,rotateSpeed*inputRotate.Horizontal,0));*}
右スティックでの回転

*foreach (Worksheet sheet in workbook.Worksheets)*{
シートをループします。
*foreach (CellRange cell in sheet.Range)*{
セールをループします。
*if (cell.HasFormula)*{
計算式があるかどうか判定します。
結果の値を取得します。
*Object value = cell.FormulaValue;
セルのコンテンツを削除します。
*cell.Clear(ExcelClearOptions.ClearContent);
値をセルに追加します。
*cell.Value2 = value;
保存します。
*workbook.SaveToFile("DeleteFormula.xlsx", ExcelVersion.Version2013);

Workbookを作成します。
*Workbook workbook = new Workbook();
currentRow、currentFormulaを初期化します。
*int currentRow = 1;
1、2列の幅をせってします。
*sheet.SetColumnWidth(1, 32);
データを追加します。
*sheet.Range[currentRow, 1].Value = "テストデータ：";
テキストを追加します。
*currentRow += 2;
演算子を行います。
*currentFormula = "=1/2+3*4";
日付関数
*currentFormula = "=TODAY()";
時間関数
*currentFormula = "=NOW()";
IF関数
*currentFormula = "=IF(B1=5,\"Yes\",\"No\")";
PI関数
*currentFormula = "=PI()";
三角関数
*currentFormula = "=SIN(PI()/6)";
COUNT関数
*currentFormula = "=Count(B1:F1)";
MAX関数
*currentFormula = "=MAX(B1:F1)";
AVERAGE関数
*currentFormula = "=AVERAGE(B1:F1)";
SUM関数
*currentFormula = "=SUM(B1:F1)";
保存します。
*workbook.SaveToFile("Excel数式.xlsx", FileFormat.Version2013);
Workbook作成します。
*Workbook workbook = new Workbook();
Excelをロードします。
*workbook.LoadFromFile("Excel数式.xlsx");
シートを取得します。
*Worksheet sheet = workbook.Worksheets[0];
*foreach (var cell in sheet.Range["B1:B13"])*{
[B1：B13]のセルをループします。
*if (cell.HasFormula)*{
数式があるかどうか判定します。
*string certainCell = String.Format("Cell[{0},{1}]", cell.Row, cell.Column);
数式のあるセルを出力します。

*subwindow.ShowDialog();
Show()にすると後ろにあるMainWindowの操作が可能

ネイティブ関数呼び出し
*StringBuilder.ReplaceBufferInternal

作成ウィザードを表示する。
*DisplayWizard<;ViewCreateWizard>;("View Create Wizard");
文字列を指定のパスに書き出す。
*File.WriteAllText(path, builder.ToString());
Unityのプロジェクトに反映する。
*AssetDatabase.Refresh();
指定したゲームオブジェクトをプレハブ化する。
*PrefabUtility.SaveAsPrefabAsset(gameObject, prefabPath);
プレハブ化したゲームオブジェクトをHierarchyから破棄する。
*GameObject.DestroyImmediate(gameObject);
Assembly-CSharpアセンブリからクラスを取得する。
*var assembly = Assembly.Load("Assembly-CSharp");
*string className = $"{creatingViewName}ViewController";
作成情報をEditorPrefsから読み込む。
作成が済んだので、EditorPrefsから削除する。
*EditorPrefs.DeleteKey("CreatingViewName");
*string className = $"{viewName}ViewController";
作成情報をEditorPrefsへ保存しておく。

アクセス修飾子 戻り値の型 関数名(引数の型 引数名)
void は結果として特に返すものはない時に使用する
*public void Attack()
何かしらの処理
*}
キャラが死んでいるかどうかを返却
*}
前進する処理
*}
メソッドや変数等
*}
------------値型------------
データ型名　変数名
int(整数)
*int intNum = 2;
float(単精度浮動小数点)
*float floatNum = 1.234f;
double(倍精度浮動小数点)
*double doubleNum = 1.234;
bool(論理)
true か false 又は 1 か 0 です
*bool boolVal = true;
char(文字)
ローマ字一文字を``で囲みます
*char c = 'a';
DateTime(日付)
*DateTime date;
------------参照型------------
String(文字列)
文字列を""で囲みます
*String str = "hoge";
配列型
詳細は後述
*int[] array;
小数点以下切り捨て
num4 = 0
*int num4 = 1 / 2;
floatなので小数点が扱える
num5 = 0.5
*float num5 = 1 / 2;
余りの数の求め方
num6 = 1
*int num6 = 10 % 3;
複合代入演算子
num = 2
*num6 += 1;
11が表示される
*Console.WriteLine(++i);
10が表示される
*Console.WriteLine(k++);
以降は k の値は11となっている
*}
9が表示される
*Console.WriteLine(--i);
10が表示される
*Console.WriteLine(k--);
以降は k の値は9となっている
*}
メソッドや変数等
*}
誰からも見えるし、誰でも使える
*public GetHP();
このCharacterクラスの内部処理内でしか見えないし、使えない
*private void SetRotation();
HelloWorldクラス等
*}
なにかしらの処理
*}
型名[] 変数名;
*string[] array;
普通の配列
変数 = new 型名[配列の長さ]
*int array = new int[3];
配列の要素ごとに値を代入
*array[0] = 5;
*int array2 = new int[] { 0, 5, 10 };
初期データを指定
*{new[] {1, 2, 3},new[] {4, 5, 6, 7}};
ジャグ配列での初期化
*{{1, 1, 1},{2, 2, 2},{3, 3, 3}};
四角配列での初期化
*// if(isDead)でも可*if(isDead == true)
もし勇者が死んでいたら
*if(isDead == true)*{
if(isDead)でも可
Gameover処理
*}
*// else if(isDead != true)　や*// else if(!isDead)　とも書ける
生きていたらClear処理
*// else if(!isDead)　とも書ける*}
else if(isDead != true)　や
else if(!isDead)　とも書ける
*}
おやすむ処理
breakが書かれることで処理を抜けます
*break;
頑張ってお仕事するにゃんねぇの処理
caseにbreakを入れない場合は次のcaseの処理も続けて実行されます
*break;
defaultは変数の値がcaseで定義されている中のどれとも異なる場合に実行されます
今回はSaturdayが対象です。
*break;
整数だった場合の処理
*break;
文字列だった場合の処理
*break;
boolだった場合の処理
*break;
その他の場合の処理
*break;
ループ処理
*}
*if(i == 5)*{
何か処理
while文から抜ける
*break;
ループ処理
*}
continueを書くとここでループ処理が中断され、変数の更新後ループ処理の頭から再度開始します
*continue;
*int[] array = { 0, 5, 10 };
arrayの中身は 0, 15, 20となる
*foreach (int num in array)*{
foreach(変数宣言 in ループ処理したい配列)
例外が発生する可能性のある処理
*}
例外に対応した処理
*}

これだとEnemyAのインスタンスの数だけHP分のメモリも確保されていく
*const int MaxHP = 100;
これだとEnemyAが画面上にいなくてもメモリ上にはEnemyAのHP分のメモリは確保されてしまう
*public static int MaxHP = 100;
CreateAssetMenu属性を使用することで`Assets &gt; Create &gt; ScriptableObjects &gt; CreasteEnemyParamAsset`という項目が表示される
それを押すとこの`EnemyParamAsset`が`Data`という名前でアセット化されてassetsフォルダに入る
*[CreateAssetMenu(fileName = "Data", menuName = "ScriptableObjects/CreateEnemyParamAsset")]
データ群の先頭をstringにして名前等に設定するとInspectorで見たときに項目TOPに表示されるので見やすくなります。
*public string EnemyName = "スライム";
privateでも[SerializeField]をつけることでInspectorで確認できるようになります。
*[SerializeField]
System.SerializeField属性を使用することで、Inspector上で変更した値がアセットに保存されるようになります
*[System.Serializable]
*#if UNITY_EDITOR*public static class CreateEnemyParamDataAssetFromCsv
AssetDatabaseを使用しているため、ビルド時には含めないようにしないとビルドエラーが起きる
MenuItem属性を付けることでEditorの上部メニューに`ScriptableObjects &gt; CreateEnemyParamAsset`が表示されます
押下すると`CreateEnemyParamDataAsset()`が実行されます
*[MenuItem("ScriptableObjects/CreateEnemyParamAsset")]
この辺で外部ファイルパスを用いてデータを読みこみ、
作成したenemyParamAssetに値を流し込む処理を挟む....
例えばenemyParamAsset.EnemyParamList.Add(hogeParam); 的な
流し込んだ後は実際に作成します
ここで作ったアセットの置き場所であるパスの指定もできます
*var assetName = $"{AssetPath}{enemyType}Data.asset";
Asset作成後、反映させるために必要なメソッド
*AssetDatabase.Refresh();
あとは読み込んだ値を使って諸々セットなどの処理を行う
*...

*(null, null) =<; "まだまだだね",
網羅性チェックのためにあえて null, null。条件漏れ防いでる
input が NRT 対応で string?
ひそかに target-typed 条件演算子で value : null が成り立ってる
*int? parseOrNull(string? input) =>; int.TryParse(input, out var value) ? value : null;

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"
指定された部分を真偽反転させる
*=>; _curGeneration[i][j] = !_curGeneration[i][j];
世代交代
*_preGeneration = (from pair in _curGeneration select pair)
*for (int i = 0; i <; Rank; i++)*{
現世代の算出
誕生
*_curGeneration[i][j] = true;
過疎
*_curGeneration[i][j] = false;
生存
*_curGeneration[i][j] = true;
過密
*_curGeneration[i][j] = false;

*{services.AddControllersWithViews();}
This method gets called by the runtime. Use this method to add services to the container.
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseExceptionHandler("/Home/Error");// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.app.UseHsts();}app.UseHttpsRedirection();app.UseStaticFiles();app.UseRouting();app.UseAuthorization();app.UseEndpoints(endpoints =>;{endpoints.MapControllerRoute(name: "default",pattern: "{controller=Home}/{action=Index}/{id?}");});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

2バイトずつもどす
*byte[] tmp = new byte[2];
shiftjisは可変長なので、2バイトで区切るとくしゃくしゃになる
*byte[] tmp = new byte[2];

*{{ "name"   ,"John"},{ "age"   ,"12"},{ "city"  ,"Tokyo"},};
例えば個人データを表すpersonのDictionaryを作成
groupは個人データをまとめるためのDictionary
*var group = new Dictionary<;int, Dictionary<;string, string>;>;();
groupに個人データpersonを追加する
*group.Add(1, person1);
Dictionaryをシリアライズ
*var jsonstr = JsonSerializer.Serialize(group);
*Console.WriteLine("{0}", jsonstr);
コンソールに出力

*byte[] byteArrayArg = new byte[] { 1, 2, 3 };
byte[]を渡し、byte[]の戻り値を受け取る
_free()を行う関数追加
*[DllImport("__Internal")]
用が済んだら_free()を行う
*execFree((uint)ptr);
*byte[] byteArrayArg = new byte[] { 1, 2, 3 };
バイト配列を渡し、バイト配列の戻り値を受け取る

現在のHierarchyのRootにあるGameObjectの一覧
*var currentSceneGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();
まずDontDestroyOnLoadされたGameObjectを作る
*var go = new GameObject(string.Empty);
DontDestroyOnLoadはSceneの一種なので,GameObject.sceneから取得することができる
*var dontDestroyOnLoadGameObjects = go.scene.GetRootGameObjects();

C# 9.0より前ではコンパイルエラー
C# 9.0からは正常なコード
BossEnemyFactoryを使う際はこう書けた方が便利なことがある
*public override BossEnemy Create () { return new BossEnemy(); }
*// public override Enemy Create () { return new BossEnemy(); }
C# 9.0より前ではこうするしかなかった。

Document objectを作成します。
*Document doc = new Document();
Section対象を追加します。
*Section sec = doc.AddSection();
sectionに段落を追加します。
*Paragraph p = sec.AddParagraph();
段落の末尾をチェックマークの記号を追加します。この記号の16進コードは\u0052です
十進コード(char)82).ToString()で表示してもいいです。
TextRange tr=p.AppendText("\u0052");
*TextRange tr = p.AppendText(((char)82).ToString());
フォントを設定します。Wordで記号のフォントを参照ていいです。ここはWingdings2です。
*tr.CharacterFormat.FontName = "Wingdings 2";
新しい段落を追加し、メールの記号をいれます。
*Paragraph p1 = sec.AddParagraph();
新しい段落を追加し、笑顔の記号をいれます。
*Paragraph p2 = sec.AddParagraph();
保存します。
*doc.SaveToFile("記号を追加.docx");
Document objectを作成します。
*Document doc = new Document();
ファイルをロードします。
*doc.LoadFromFile("特殊記号.docx");
FindStringメソッドでメールの記号を探します。
*TextRange tr = doc.FindString("\u002A", true, true).GetAsOneRange();
TextRangeにあったところを発見し、このTextRangeを削除します。
*Paragraph p = tr.OwnerParagraph;
保存します。
*doc.SaveToFile("test.docx", FileFormat.Docx2013);

*if (string.Equals(key?.GetValue(null) as string, tbValue.Text, StringComparison.OrdinalIgnoreCase))*{
すでに指摘のキーに指定の値がある場合は、なにもせず終わりたい
書き込み実施
*key.SetValue(null, tbValue.Text);
読み込んで画面に表示
*tbValue.Text = (string)key.GetValue(null);

*int WAIT_TIME = 10;
seconds

*animator.speed = 0;
再生をポーズ

*TestContext.CurrentTestOutcome
〇:本来こっちには何も入れてない気がするが、このインスタンスはその時動いたテスト情報が入る

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"
内部的なデータテーブル
*private DataTable _dataTable = new DataTable();
次元
*private readonly int _rank = 50;
前世代
*private Dictionary<;int, List<;bool>;>; preGeneration = new Dictionary<;int, List<;bool>;>;();
現世代
*private Dictionary<;int, List<;bool>;>; curGeneration = new Dictionary<;int, List<;bool>;>;();
ボタンを画面上部に付けているのでその分を全体から引いて、行数で均等に割る
*dgSample.MinRowHeight = 0;
*foreach (var col in dgSample.Columns)*{
何故か親ウィンドウの幅をそのまま割ると少しズレるので-2というマジックナンバーをつけている
マウスクリックされたセルを取得して色を反転させる
*var curCellInfo = dgSample.CurrentCell;
とりあえず100世代ライフゲームを実行する
*int gen = 0;
データのコピー
*preGeneration[i][j] = curGeneration[i][j];
誕生
*curGeneration[i][j] = true;
過疎
*curGeneration[i][j] = false;
生存
*curGeneration[i][j] = true;
過密
*curGeneration[i][j] = false;
*if (preGeneration[i][j] != curGeneration[i][j])*{
前世と現世で状態が変われば反転させる
全体の1/3のセルを生存状態にする
*int totalCellCount = _rank * _rank;
黒
*curGeneration[i][j] = true;
白
*curGeneration[i][j] = false;

*textBox1.Text += "\r\n";
見栄えのための改行
カレントディレクトリを元の場所に戻す
*Directory.SetCurrentDirectory(@".\bin\Debug");

以下同じようなコードが続いていた
*,,,

*{Console.WriteLine("***** Action - Start *****");action("Action");Console.WriteLine("***** Action -  End  *****");}
戻り値の設定はできない
*{Console.WriteLine("***** Func - Start *****");func("Func");Console.WriteLine("***** func -  End  *****");}
戻りの型引数は必須

*public void ProcessMain(){// do something}
do something
*public void Terminate(){// do something}
do something
*public void ProcessMain(){// do something another type}
do something another type
*public void Terminate(){// do something another type}
do something another type

*var uri = new Uri("http:
httpbin.orgpost");
*Console.WriteLine($"{responseContent}");
Responseの表示

1. 全体をJObject型で受け取る。
jsonStringはResponseなどで受け取った、json構造のstring型変数とする。
string --&gt; JObjectの変換はJObject.Parse()で行う。
*JObject jsonObject = JObject.Parse(jsonString);
2. 1の中から"emoji"のValueをJObject型で受け取る。
["(KeyName)"]で特定のKeyのValueを、JObjectから取り出せる。
ここでは取り出すValueもJObject型のため、JObject型の変数に代入してやる。明示的なCastが必要。
*JObject emojis = (JObject)jsonObject["emoji"];
3. 2の中から各項目をKeyValuePairとして取り出す
JObject型はIEnumerableを継承しており、
GetEnumerator()でKeyValuePair&lt;string, JToken?&gt;を返す。
上の例では、KeyValuePairのKeyが絵文字の名前、Valueが絵文字のURIとなる。
*foreach (var emoji in emojis)
*Console.WriteLine($"EmojiName : {name}, EmojiUri : {uri}");
KeyValuePairのValueはJToken?型のため、stringに変換する。
emojisがJObject
emojisの実態は、
"bowtie": "https:my.slack.com/emoji/bowtie/46ec6f2bb0.png"
"squirrel": "https:my.slack.com/emoji/squirrel/f35f40c0e0.png", ...
というKeyとValueの羅列
*foreach (var emoji in emojis)

Mutexの名前
「Global\\」をつけると、自分以外のUserとも共有できるMutexになる
ただし、Create時に振るアクセスできるようにしておかないと、別Userが
Create時にアクセス拒否例外になる
*string mutexName = "Global\\MyMutex";
*{if (mutex == null){try{if (cbSecurity.IsChecked != false){var mutexSecurity = new MutexSecurity();mutexSecurity.AddAccessRule(new MutexAccessRule(new SecurityIdentifier(WellKnownSidType.WorldSid, null),MutexRights.Synchronize | MutexRights.Modify,AccessControlType.Allow));mutex = new Mutex(false, mutexName, out _, mutexSecurity);AddLog("MyMutex作成OK(フルアクセス)");}else{mutex = new Mutex(false, mutexName, out _, null);AddLog("MyMutex作成OK(通常アクセス)");}}catch (Exception ex){AddLog(ex.Message);}}else{AddLog("MyMutexすでに作成済み");}}
Mutex作成
*{bool signal = false;if (mutex == null){AddLog("MyMutex未作成");return;}else{AddLog("MyMutex WaitOne()実行");}try{// mutexの所有権を要求する// C++のCreateMutex()とOpenMutex()を一緒にやる感じsignal = mutex.WaitOne(5000);}catch (AbandonedMutexException ex){// 相手がmutexを解放する前に終了してしまった場合signal = true;AddLog(ex.Message);}if (signal){AddLog("MyMutex作成完了");}else{AddLog("MyMutexタイムアウト");mutex = null;}}
チェック
mutexの所有権を要求する
C++のCreateMutex()とOpenMutex()を一緒にやる感じ
*signal = mutex.WaitOne(5000);
相手がmutexを解放する前に終了してしまった場合
*signal = true;
*{if (mutex != null){AddLog("Mutex解放します");mutex.ReleaseMutex();mutex.Close();mutex = null;}else{AddLog("MutexすでにReleaseしてます");}}
解放

URLを開く
*System.Diagnostics.Process.Start(e.Uri.AbsoluteUri);
URLを開く
*p.Start();
*if (IsAnyNullOrEmpties(input, regPattern))*{
未入力がないかチェック
マッチング実行
*MatchCollection matches = reg.Matches(input);
結果を設定
*OutTxt.Text = sb.ToString();
未入力
*return true;
*if (ROptIgnoreCase.IsChecked == true)*{
大文字小文字の区別をしない
*if (ROptMultiLine.IsChecked == true)*{
複数行モード
*if (ROptSingleLine.IsChecked == true)*{
単一行モード

*if (isHeavy)*{
基本的にほぼほぼisHeavyはfalseとなる
非同期処理
*await xxxxAsync();

*new VTuberProfile("星街すいせい", "☄️", "https:
www.youtube.comchannelUC5CwaMl1eIgY8h02uZw7u8A"),
以下省略
*};

Bitmapの作成
*Bitmap bitmap = new Bitmap(Screen.PrimaryScreen.Bounds.Width,
Graphicsの作成
*Graphics g = Graphics.FromImage(bitmap);
画面全体をコピーする
*g.CopyFromScreen(new Point(0, 0), new Point(0, 0), bmp.Size);
解放
*g.Dispose();
using System.Drawing;ダブリ、単体で使う場合は有効に
*using System.Drawing.Imaging;
取得したキャプチャ画像をファイルとして保存
*var folder = Directory.GetCurrentDirectory();
*{BitmapDecoder decoder = await BitmapDecoder.CreateAsync(stream);softwareBitmap = await decoder.GetSoftwareBitmapAsync();}
保存した画像をSoftwareBitmap形式で読み込み
保存した画像ファイルの削除
*File.Delete(folder + "\\" + imageName);
SoftwareBitmap形式の画像を返す
*return softwareBitmap;
*{OcrEngine ocrEngine = OcrEngine.TryCreateFromUserProfileLanguages();// OCR実行var ocrResult = await ocrEngine.RecognizeAsync(snap);return ocrResult;}
using Windows.Graphics.Imaging;ダブリ
OCR実行
*var ocrResult = await ocrEngine.RecognizeAsync(snap);

*lineRenderer.SetColors(lineColor,lineColor);
色の設定

デフォルトでは5秒実行
*int sec = 5;
*if (req.Query.ContainsKey("sec"))*{
sec というパラメータに入れた数字を秒数として、その時間だけ実行する

Document objectを作成します。
*Document document = new Document();
Wordファイルをロードします。
*document.LoadFromFile("Input.docx");
*foreach(Section section in document.Sections)*{
文書をループして、段落全体を削除します。
保存します。
*document.SaveToFile("RemoveAllParagraphs.docx", FileFormat.Docx2013);
Document objectを作成します。
*Document document = new Document();
Wordファイルをロードします。
*document.LoadFromFile("Input.docx");
一つ目の段落を削除します。
*document.Sections[0].Paragraphs.RemoveAt(0);
保存します。
*document.SaveToFile("RemoveParagraph.docx", FileFormat.Docx2013);

*float theta = 0.08f;
閾値。設定は微妙なので要調整。

*{// InMemoryservices.AddDbContext<;AppDbContext>;(options =>;options.UseInMemoryDatabase(nameof(AppDbContext)).ConfigureWarnings(m =>; m.Ignore(InMemoryEventId.TransactionIgnoredWarning)));// Postgresservices.AddDbContextPool<;AppDbContext>;(options =>;{options.UseNpgsql(Configuration.GetConnectionString(typeof(AppDbContext).Name));});省略}
This method gets called by the runtime. Use this method to add services to the container.
*{options.UseNpgsql(Configuration.GetConnectionString(typeof(AppDbContext).Name));});
Postgres

PPTを作成します。
*Presentation ppt = new Presentation();
プロパティを設定します。
*ppt.DocumentProperty.Title = "パンダについて";
保存します。
*ppt.SaveToFile("プロパティ.pptx", FileFormat.Pptx2013);
PPTをロードします。
*Presentation ppt = new Presentation();
プロパティを読み込みます。
*Console.WriteLine("タイトル: " + ppt.DocumentProperty.Title);

line に一行ずつ入る （改行コードは入っていない）
*}

... 略 ...
*JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();
... 略 ...
*}
... 略 ...
*services.AddTransient<;ClaimsEnricher>;();
... 略 ...
*}
本来はここでロガーを初期化したい。
Log.Logger = new LoggerConfiguration()
.MinimumLevel.Information()
.Enrich.FromLogContext()
.WriteTo.Console(formatter: new JsonFormatter())
.CreateLogger();
*try

*}
コンストラクタが呼ばれたら New !! を出力する

DIされた内容が配列として渡ってきます
*var animalServices = provider.GetServices<;IAnimalService>;();

*TimeoutIOUtils.TimeoutSeconds = 2;
タイムアウトを2秒に設定
*if(TimeoutIOUtils.DirectoryExists(dir))*{
ディレクトリの有無確認
*if(TimeoutIOUtils.FileExists(file))*{
ファイルの有無確認

*{// 選択変更時のコマンドpublic ICommand SelectionChangedCommand { get; }}
SampleWindowViewModelのViewModel
*public ICommand SelectionChangedCommand { get; }
選択変更時のコマンド

Streamから
*public static PdfDocumentBase MergeFiles(Stream[] streams);
Stringから
*public static PdfDocumentBase MergeFiles(string[] InputFiles);
指定するパスから
*public static PdfDocumentBase MergeFiles(string firstInputFile, string secInputFile);

*{foreach (byte b in byteArray)binaryWriter.Write(b);}
write decrypted data to file

*airStayTime = 0.7f;
滞空時間を延長

参照型と値型のインスタンスを4つずつ用意
*var vals = Enumerable.Repeat(0, 4)
値型を値渡しでプロパティ書き換え
*OverwriteProperty(vals[0]);
値型を参照渡しでプロパティ書き換え
*OverwriteProperty(ref vals[1]);
値型を値渡しでインスタンス置き換え
*ReplaceInstance(vals[2]);
値型を参照渡しでインスタンス置き換え
*ReplaceInstance(ref vals[3]);
参照型を値渡しでプロパティ書き換え
*OverwriteProperty(refs[0]);
参照型を参照渡しでプロパティ書き換え
*OverwriteProperty(ref refs[1]);
参照型を値渡しでインスタンス置き換え
*ReplaceInstance(refs[2]);
参照型を参照渡しでインスタンス置き換え
*ReplaceInstance(ref refs[3]);

*private readonly string _endpoint = "https:
api.bing.microsoft.comv7.0";

*Player.player.playerHp--;
クラス名.変数名.変数で、Playerクラスの変数を取得できる。Playerで宣言したこと(int playerHp等)がplayerに入っているイメージ

*using ( var sw = new System.IO.StreamWriter("SampleOutput.xml", false, new System.Text.UTF8Encoding(false)) )
BOMなしUTF-8

*if(enemykillCount <;=enemyKillJudgment
{
もしもタスクオブジェクトの（実績条件の）達成量が達成規定よりも上回ったら
報酬を与える
*}

*if (targetDirectory[targetDirectory.Length - 1] != Path.DirectorySeparatorChar)*targetDirectory = targetDirectory + Path.DirectorySeparatorChar;
保存先のディレクトリ名の末尾に"\"をつける
タスクのキャンセルがされていたら例外を投げる
*_cancellationToken.ThrowIfCancellationRequested();
取得元ディレクトリ配下のファイルを検索し、条件に一致するファイルを取得する
*string[] files = Directory.GetFiles(originDirectory);
処理中のディレクトリを画面に表示
*Invoke(new Action<;string>;(SetExecuteMsg), file);
*if (!Directory.Exists(targetDirectory))*{
保存先のディレクトリがないときは作る（属性もコピー）
取得元ディレクトリ配下のディレクトリについて、再帰的に呼び出す
*string[] dirs = Directory.GetDirectories(originDirectory);
処理なし
処理キャンセルのメッセージは呼び出し元でセットする
*}
*if (!File.Exists(file))*return false;
存在チェック
属性チェック
非表示、システムファイルは除外
*FileAttributes attributes = File.GetAttributes(file);
対象日付範囲チェック
*DateTime lastWriteDateTime = File.GetLastWriteTime(file);
非表示、システムフォルダは除外
*FileAttributes attributes = File.GetAttributes(dir);
*if (strLastDir == "bin"*|| strLastDir == "obj"
特定フォルダ名は除外

配列に入れたTransformを順に巡る．AIを使っていればスムーズに曲がるがこれは鋭角に曲がる
*float step = speed * Time.deltaTime;

PowerPointを作成します。
*Presentation ppt = new Presentation();
スライドのサイズと方向を配置します。
*ppt.SlideSize.Type = SlideSizeType.Screen16x9;
スライドの背景画像を挿入します。
*string ImageFile ="picture.jpg";
図形を初めのスライドに追加します。
*IAutoShape textboxShape = ppt.Slides[0].Shapes.AppendShape(ShapeType.Rectangle, new RectangleF(50, 70, 600, 100));
図形での段落を削除します。
*textboxShape.TextFrame.Paragraphs.Clear();
図形で段落とコンテンツを追加します。
*textboxShape.TextFrame.Paragraphs.Append(new TextParagraph());
二つめの段落とそのコンテンツを追加します。
*textboxShape.TextFrame.Paragraphs.Append(new TextParagraph());
*foreach (TextParagraph para in textboxShape.TextFrame.Paragraphs)*{
段落の文字のフォント・サイズなどを配置します。
保存します。
*ppt.SaveToFile("PowerPoint.pptx", FileFormat.Pptx2013);

印刷範囲を設定します。
*sheet.PageSetup.PrintArea = "B2:F8";
タイトルを印刷します。
*sheet.PageSetup.PrintTitleColumns = "$A:$B";
印刷の順を設定します。
*sheet.PageSetup.Order = OrderType.DownThenOver;
PrintDialogを設定します。
*PrintDialog dialog = new PrintDialog();
片面印刷します。
*dialog.PrinterSettings.Duplex = Duplex.Simplex;
印刷範囲を設定します。
*dialog.PrinterSettings.FromPage = 0;
部数を設定します。
*dialog.PrinterSettings.Copies = 5;
プリンターの名前を設定します。
*dialog.PrinterSettings.PrinterName = "HP LasterJet P1007";
印刷します。
*workbook.PrintDialog = dialog;
Excelをロードします。
*Workbook workbook = new Workbook();
サイレント印刷します。
*workbook.PrintDocument.PrintController = new StandardPrintController();

*{// 1. 画面ごとのスクリーン座標に変換// ※ 各画面の左下隅を(0, 0)とする座標に変換されますvar relativePosition = Display.RelativeMouseAt(position);// ※ 気持ち悪いですが、z座標にディスプレイ番号がセットされます...var displayIndex = (int)relativePosition.z;if (displayIndex >;= cameras.Count) return null;// 2. 該当する画面のカメラでワールド座標に変換var camera = cameras[displayIndex];return camera.ScreenToWorldPoint(relativePosition);}
cameras という変数に、ディスプレイ番号順のカメラが保持されている想定です
1. 画面ごとのスクリーン座標に変換
※ 各画面の左下隅を(0, 0)とする座標に変換されます
*var relativePosition = Display.RelativeMouseAt(position);
※ 気持ち悪いですが、z座標にディスプレイ番号がセットされます...
*var displayIndex = (int)relativePosition.z;
2. 該当する画面のカメラでワールド座標に変換
*var camera = cameras[displayIndex];

*IsSecure = true,
HTTPSとして扱う
CefSharpを初期化する
*Cef.Initialize(settings, false, new BrowserProcessHandler());
*if (bCreateWebView)*{
WebView作成の指定がある場合は、WebViewを作成する
CefSharpのWebViewを作成する。
WebBrowser = new ChromiumWebBrowser("https:www.google.co.jp");
コントロールを追加する。
*this.webViewContainer.Controls.Add(WebBrowser);
WebViewの各種オプションを設定する
*WebBrowser.BrowserSettings.Javascript = CefState.Enabled;
CefSharpの各種ハンドラを設定する
*WebBrowser.KeyboardHandler = new Handlers.KeyboardHandler();
独自オブジェクトを公開する
*WebBrowser.JavascriptObjectRepository.Register("Test", new SimpleBrowser.Util.Test(), true, null);
親のbrowserからフォームを取得する
*SimpleBrowserFrame parent = SimpleBrowserFrame.getMainFrame(browser);
*{// WebView無しの空のコンテナフォームを作成する。SimpleBrowserFrame newWindows = new SimpleBrowserFrame(false);// WebViewのコンテナ（親ウィンドウ）の情報を設定する。Rectangle rect = newWindows.ClientRectangle;windowInfo.SetAsChild(newWindows.WebBrowserContainer.Handle, rect.Left, rect.Top, rect.Right, rect.Bottom);// フォームを表示するnewWindows.Show();}));
親フォームのコンテキストで実行させる
WebView無しの空のコンテナフォームを作成する。
*SimpleBrowserFrame newWindows = new SimpleBrowserFrame(false);
WebViewのコンテナ（親ウィンドウ）の情報を設定する。
*Rectangle rect = newWindows.ClientRectangle;
フォームを表示する
*newWindows.Show();
この引数は実験的な引数の用ですがNULLを設定する
*newBrowser = null;
CefSharpにWebViewの作成を任せるためにfalseを返却する
*return false;
新しく作成されたbrowserからコンテナのフォームを取得する
*SimpleBrowserFrame parent = SimpleBrowserFrame.getMainFrame(browser);
*{// 親フォームにIBrowserインスタンスの情報を設定するparent.Browser = browser;}));
コンテナフォームのコンテキストで実行
親フォームにIBrowserインスタンスの情報を設定する
*parent.Browser = browser;
(省略)
*public IBrowser Browser { get; set; }
(省略)
*}
*// LifeSpanHandlerをWebViewに設定する*WebBrowser.LifeSpanHandler = new Handlers.LifeSpanHandler();
（省略）
*WebBrowser.LifeSpanHandler = new Handlers.LifeSpanHandler();*// （省略）
LifeSpanHandlerをWebViewに設定する
（省略）
*}
*{if (Browser != null){// WebViewのウィンドウハンドルを取得するIntPtr hWnd = Browser.GetHost().GetWindowHandle();// WebViewのサイズを変更する。SetWindowPos(hWnd, HWND_TOP, 0, 0, webViewContainer.Width, webViewContainer.Height, SetWindowPosFlags.SWP_NOMOVE | SetWindowPosFlags.SWP_NOZORDER);}}
(省略)
WebViewのウィンドウハンドルを取得する
*IntPtr hWnd = Browser.GetHost().GetWindowHandle();
WebViewのサイズを変更する。
*SetWindowPos(hWnd, HWND_TOP, 0, 0, webViewContainer.Width, webViewContainer.Height, SetWindowPosFlags.SWP_NOMOVE | SetWindowPosFlags.SWP_NOZORDER);

*if(notesTime =<; 0)
判定位置に来たら

ノートと画像保存場所のリスト
*var slideList = new List<;(string, string)>;();
スライドを開く
*var ppt = app.Presentations.Open(SLIDE_PATH, MsoTriState.msoTrue, MsoTriState.msoFalse,
*if (ppt.Slides[i].SlideShowTransition.Hidden == MsoTriState.msoTrue) continue;*// ノート
非表示スライドは無視
ノート
*var note = ppt.Slides[i].NotesPage.Shapes.Placeholders[2].TextFrame.TextRange.Text;
*var file = FILE_PATH + $"/slide{i:0000}.jpg";
JPEGとして保存

*foreach (var i in ^10..^0 ) Console.WriteLine(i);
9  8  7  6  5  4  3  2  1
*{public static IEnumerator<;(int, int)>; GetEnumerator(this (Range, Range) range){foreach (var v1 in range.Item1)foreach (var v2 in range.Item2)yield return (v1, v2);}//同様に3項、4項...の実装があると便利かも}
(0, 0) (0, 1) (0, 2) (1, 0) (1, 1) (1, 2) (2, 0) (2, 1) (2, 2)
同様に3項、4項...の実装があると便利かも
*}

WebView.ExecuteScriptAsync("func1()").ResultをするとWebView2がフリーズする
*string str1 = await WebView.ExecuteScriptAsync("func1(\"C#からの呼び出し\")");
JavaScriptからC#のメソッドが実行できる様に仕込む
*WebView.CoreWebView2.AddHostObjectToScript("class", CsClass);
～～～一部省略～～～
*[ClassInterface(ClassInterfaceType.AutoDual)]
個人の環境に合わせて下さい
*};
WebView2のサイズをフォームのサイズに合わせる
*WebView.Size = this.Size;
WebView2のロード完了時のイベント
*WebView.NavigationCompleted += WebView_NavigationCompleted;
JavaScriptからC#のメソッドが実行できる様に仕込む
*WebView.CoreWebView2.AddHostObjectToScript("class", CsClass);
JavaScriptの関数を実行
*CsToJs();
WebView.ExecuteScriptAsync("func1()").ResultをするとWebView2がフリーズする
*string str1 = await WebView.ExecuteScriptAsync("func1(\"C#からの呼び出し\")");
↓属性設定が無いとエラーになります
*[ClassInterface(ClassInterfaceType.AutoDual)]

*Source = new Uri("https:
www.google.co.jp"),

API keyとAPI secret keyを用意する
*string apiKey = "abcdefg";
API keyとAPI secret keyをコロンでつなぐ
*string strBearerTokenCredentials = apiKey + ":" + apiSecretKey;
byteの配列に変換する
*byte[] byteBearerTokenCredentials = Encoding.ASCII.GetBytes(strBearerTokenCredentials);
stringのbase64に変換する
*string strBearerTokenCredentialsBase64 = Convert.ToBase64String(byteBearerTokenCredentials);

*Hash = SHA256.Create();
dummy
ハッシュ値を算出
*byte[] namebyte = Encoding.UTF8.GetBytes(name);
ソルトを作成(最低8byte必要)
*byte[] salt1 = new byte[8];
ハッシュ値を算出
*string hashstring = string.Empty;
*{byte[] hashbyte = pbkdf2.GetBytes(32);hashstring = BitConverter.ToString(hashbyte);}
ストレッチングの反復処理回数1000、アルゴリズムにSHA256
*Console.WriteLine($"今からお前の名前は{hashstring}だ。いいかい、{hashstring}だよ。分かったら返事をするんだ、{hashstring}!!");
出力
前回決めたソルト
*string salt = "AF-70-37-73-C6-E3-22-A9";
前回求めたハッシュ値
*string prevhash = "19-A3-4B-9E-D8-25-4E-A7-12-02-86-D7-AB-6D-D7-7B-8D-C6-CB-B9-0C-C8-70-18-44-64-6F-DF-2D-63-AF-C6";
ソルトをbyte配列に変換
*string[] saltstrings = salt.Split("-");
ハッシュ値を算出
*string hashstring = string.Empty;
*if (prevhash.Equals(hashstring))*{
結果判定を出力
ハッシュ値を算出
int cost = 11; ストレッチングの回数 (2^11回)
*string hashstring = Bcrypt.EnhancedHashPassword(name, cost);
*Console.WriteLine($"今からお前の名前は{hashstring}だ。いいかい、{hashstring}だよ。分かったら返事をするんだ、{hashstring}!!");
出力
ハッシュ値を算出
*string hashstring = Argon2.Hash(name);
*Console.WriteLine($"今からお前の名前は{hashstring}だ。いいかい、{hashstring}だよ。分かったら返事をするんだ、{hashstring}!!");
出力

*Transform objTransform= hogeObject.transform;*// その中からposition情報を取得
オブジェクトのtransform情報を取得
*Vector3 pos = objTransform.position;*// 上方向成分を加算
その中からposition情報を取得
上方向成分を加算
*pos.y += 0.001f;
*objTransform.position = pos;*}
反映

*{StreamReader sr = new StreamReader(filePath, Encoding.GetEncoding(encodingName));string allLine = sr.ReadToEnd();sr.Close();return allLine;}
ファイル読み込み
*{// 一致したときif (left.Length == right.Length){var result = new Dictionary<;string, string>;();// leftのListの数の分だけforを回すfor (int i = 0; i <; left.Length; i++){// resultに辞書を追加result.Add(left[i], right[i]);}return result;}// 不一致のときelse{return null;}}
List型をDictionary型に強引に変換する
*if (left.Length == right.Length)*{
一致したとき
*for (int i = 0; i <; left.Length; i++)*{
leftのListの数の分だけforを回す
resultに辞書を追加
*result.Add(left[i], right[i]);
*{return null;}
不一致のとき
*{try{string jsonfile = ReadAllLine(filename, "utf-8");hogejson jsonData = JsonSerializer.Deserialize<;hogejson>;(jsonfile);string[] json_key = { "hoge", "hogehoge", "hogehogehoge" };string[] json_value = { jsonData.hoge, jsonData.hogehoge, jsonData.hogehogehoge };var result = ListInDictionary(json_key, json_value);return result;}// jsonが読み込めない時catch (JsonException){return null;}}
hoge.jsonを読み込むためのメソッド
*{return null;}
jsonが読み込めない時

Word objectを作成し、ドキュメントをロードします。
*Document document = new Document();
初めの段落を取得します。
*Paragraph paragraph = document.Sections[0].Paragraphs[0];
脚注を追加します。
*Footnote footnote = paragraph.AppendFootnote(FootnoteType.Footnote);
初めの段落で"夏時間"という文字列を探し、脚注に追加します。
*DocumentObject obj = null;
String文字列の書式を設定します。
*textRange.CharacterFormat.Bold = true;
脚注を挿入します。
*paragraph.ChildObjects.Insert(i + 1, footnote);
脚注の内容を追加し、文字のフォントなどを設定します。
*TextRange text = footnote.TextBody.AddParagraph().AppendText("夏時間。カナダ、オーストラリアでも用いる）とは1年のうち夏を中心とする時期に太陽が出ている時間帯を有効に利用する目的で、標準時を1時間進める制度またはその進められた時刻のこと。ただし、オーストラリアのロード・ハウ島では夏時間と通常の時間の差が30分であるなど一律ではない。");
三つ目の段落を取得します。
*Paragraph paragraph2 = document.Sections[0].Paragraphs[2];
文末脚注を挿入し、スタイルを設定します。
*Footnote endnote = paragraph2.AppendFootnote(FootnoteType.Endnote);
保存します。
*document.SaveToFile("脚注.docx", FileFormat.Docx2010);

*Console.Write("*");
変化検出時に呼ばれた場合は*つける
ChargeRateInMilliwattsが0ならACアダプタ挿抜直後等
*Console.WriteLine(" Calcurating...");
ChargeRateInMilliwattsが＋なら充電中(AC)
*Console.WriteLine(" TimeToFull = " + TimeToFull + " min");
ChargeRateInMilliwattsが－なら放電中(SC)
*Console.WriteLine(" TimeToEmpty = " + (-TimeToEmpty) + " min");

*public int BirthDay { get; set; }
誕生日

*.Where(p =<; p.Id != current.Id)
←自分以外を指定(プロセス名は同じでも、プロセスIDはそれぞれ異なる)

PlayerタグをつけたGameObjectを配列で取得しリストへ変換
*List<;GameObject>; gameObjects = GameObject.FindGameObjectsWithTag("Player").ToList();
*gameObjects.ForEach(gameObj =>; print(gameObj.transform.name));*}
取得したGameObjectの名前をコンソールに出力
*List<;RaycastHit>; hits1 = Physics.SphereCastAll(transform.position,10.0f,transform.forward,0.01f).;*List;RaycastHit>; hits1_RH_list = new List;RaycastHit>;(hits1);
Case1：段階に分けて記述する場合
*var hits2 = Physics.SphereCastAll(transform.position,10.0f,transform.forward,0.01f)*.Select(h =>; h.transform.gameObject).ToList();
Case2：まとめて記述する場合

*Console.WriteLine(s);
赤 黄 青

Wi-Fiアダプタが有効
*}
SIMアダプタが有効
*}
接続中
*}

*IntPtr intPtr1 = (IntPtr)pointer;
どちらも同じ
unsafe不要
*byte b = Marshal.ReadByte(intPtr);
アライメントを考慮しない版
*MyStruct s = Unsafe.ReadUnaligned<;MyStruct>;(pointer);
unsafe不要
*Marshal.WriteByte(intPtr, 0x01);
アライメントを考慮しない版
*Unsafe.WriteUnaligned<;MyStruct>;(pointer1, myStruct);
アライメントを考慮しない版
*Unsafe.InitBlockUnaligned(pointer, 0x00, (uint)size);
アライメントを考慮しない版
*Unsafe.CopyBlockUnaligned(srcPointer, destPointer, (uint)size);
unsafe不要
*[DllImport("kernel32.dll", EntryPoint = "RtlMoveMemory", SetLastError = false)]
unsafe不要
*[DllImport("msvcrt.dll", EntryPoint = "memcpy", SetLastError = false)]
unsafe不要
*Marshal.Copy(srcIntPtr, destArray, startIndex: 0, destArray.Length);
unsafe不要
*Marshal.Copy(srcArray, startIndex: 0, destIntPtr, srcArray.Length);
unsafe不要
*IntPtr intPtr = Marshal.AllocCoTaskMem(allocSize);
unsafe不要
*IntPtr intPtr = Marshal.AllocHGlobal(allocSize);

*{private readonly InnerBroker innerBroker = new();private readonly InnerObserver innerObserver;// コンストラクタpublic PartialSubject() =>; this.innerObserver = new(this.innerBroker);// Broker.Subscribe()のラッパーpublic IDisposable Subscribe(IObserver<;T>; observer){// 自身の持つ内部Brokerに購読依頼をそのままスルーreturn this.innerBroker.Subscribe(observer);}// Observer.OnNext()のラッパーpublic void OnNext(T nextItem){// イベント発火タイミングが来た！// 内部Observerに通知をスルーthis.innerObserver.OnNext(nextItem);}// 親クラスのBrokerとなる内部クラスprivate class InnerBroker : IBroker<;T>;{private readonly List<;IObserver<;T>;>; observers = new();public IDisposable Subscribe(IObserver<;T>; observer){this.observers.Add(observer);// Dispose時の処理は解説範囲外なので省略return Disposable.Empty;}public void Publish(T value){// 購読依頼を受けていたObserver達に発行を知らせるthis.observers.ForEach(x =>; x.OnNext(value));}}// Subject利用クラスを購読するObserverとなる内部クラスprivate class InnerObserver : IObserver<;T>;{private readonly IObservable<;T>; broker;// コンストラクタpublic InnerObserver(IBroker<;T>; broker) =>; this.broker = broker;public void OnNext(T value){// 内部Observerの通知受信時の処理は、内部Brokerに発行を伝えることthis.broker.Publish(value);}}}
※UniRxの実装とは異なります
コンストラクタ
*public PartialSubject() =>; this.innerObserver = new(this.innerBroker);
*{// 自身の持つ内部Brokerに購読依頼をそのままスルーreturn this.innerBroker.Subscribe(observer);}
Broker.Subscribe()のラッパー
自身の持つ内部Brokerに購読依頼をそのままスルー
*return this.innerBroker.Subscribe(observer);
*{// イベント発火タイミングが来た！// 内部Observerに通知をスルーthis.innerObserver.OnNext(nextItem);}
Observer.OnNext()のラッパー
イベント発火タイミングが来た！
内部Observerに通知をスルー
*this.innerObserver.OnNext(nextItem);
*{private readonly List<;IObserver<;T>;>; observers = new();public IDisposable Subscribe(IObserver<;T>; observer){this.observers.Add(observer);// Dispose時の処理は解説範囲外なので省略return Disposable.Empty;}public void Publish(T value){// 購読依頼を受けていたObserver達に発行を知らせるthis.observers.ForEach(x =>; x.OnNext(value));}}
親クラスのBrokerとなる内部クラス
Dispose時の処理は解説範囲外なので省略
*return Disposable.Empty;
購読依頼を受けていたObserver達に発行を知らせる
*this.observers.ForEach(x =>; x.OnNext(value));
*{private readonly IObservable<;T>; broker;// コンストラクタpublic InnerObserver(IBroker<;T>; broker) =>; this.broker = broker;public void OnNext(T value){// 内部Observerの通知受信時の処理は、内部Brokerに発行を伝えることthis.broker.Publish(value);}}
Subject利用クラスを購読するObserverとなる内部クラス
コンストラクタ
*public InnerObserver(IBroker<;T>; broker) =>; this.broker = broker;
内部Observerの通知受信時の処理は、内部Brokerに発行を伝えること
*this.broker.Publish(value);
*public interface IBroker<;T>; : IObservable<;T>; {void Publish(T value);}
IBrokerは　IObservable + Publish()
1. Subjectを生成。
*private readonly Subject<;Unit>; someSubject = new Subject<;Unit>;();
2. Subject生成時にSubjectの内部Observerは利用クラスの観測を開始したと見なす。
こんなイメージ。
*private IObserver<;Unit>; SomeObserver =>; this.someSubject;
3. Subjectの内部Observableを公開してこれを中継役とする。
*public IObservable<;Unit>; SomeObservable =>; this.someSubject;
4. 3.のObservableに購読手続きを依頼。実際に購読するObserverを引数で渡す。
*var observer = Observer.Create<;Unit>;(onNext: _ =>; DoSomethingOnNext());
5. イベント発火タイミングが来たので、当クラスを監視していることになっているObserverに
通知受信時の処理を行うように命令する。
*this.SomeObserver.OnNext(Unit.Default);
6. 5.の命令を受けてSomeObserverはSomeObservable.Publish()を実行し、発行を依頼する。
7. 6.の命令を受けてSomeObservableは、4.で登録されていたObserverのOnNext()を呼び出し、
通知受信時の処理を行うように命令する。
*}

*@product.Name
Pen

自アドレスの秘密鍵(WIF形式)からBitcoinSecretを取得する
*var bitcoinPrivateKey = new BitcoinSecret("cPoEcLELGdXjHK5HB4tFxWf11UabeBJX4muBZSTZoavL8ZbDpBGa");
これから送金するためのトランザクションの左側(TxIn)をつくる
- UTXO = Unspent Transaction Output（自アドレス宛の未使用トランザクション）の確認
- トランザクションインプットの作成
*var client = new QBitNinjaClient(network);
これから送金するためのトランザクションの右側(TxOut)をつくる
- BitcoinAddressの生成
- 送金額の設定
*var destinationAddress = BitcoinAddress.Create("mhk39wXeb1ZsDegtPb6xnrUquctp6Rusko", network);
メッセージ編集
ブロックチェーンに永遠に残るオリジナルメッセージを付けて送金する
*var message = "From Qiita, Japan, @ysskjck.";
これから送金するためのトランザクションに署名する
(TxInにある自アドレス宛の送金額の所有権を証明する必要がある)
*transaction.Inputs[0].ScriptSig = bitcoinPrivateKey.ScriptPubKey;
トランザクションの出力（送金確定前の内容確認）
*Console.WriteLine(transaction.ToString());
送金確定
(ブロックチェーンへの書き込み)
*var broadcastResponse = client.Broadcast(transaction).Result;

*var workTo = td[2].TextContent.Trim();
退勤時間
Excelへの書き込み
テンプレートファイルの存在チェック
*string tmpFile = @"..\勤務表(XXXX)_yyyyMMdd.xlsm";
新規Excelに必用な情報を入力
*Console.WriteLine("勤務表作成者の苗字と作成年月を半角スペース区切りで指定してください。");
テンプレートから新規Excelを作成
*File.Copy(tmpFile, outFile);
中略（その他の処理）
*row++;
Webドライバーのインスタンス化
*IWebDriver driver = new ChromeDriver(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location));
自社サイト（ログインページ）へアクセス
*driver.Navigate().GoToUrl(loginPage);
*driver.FindElement(By.Id("{ID入力欄の要素id}")).SendKeys(Console.ReadLine());
ID・PASSを入力
*driver.FindElement(By.Name("{ログインボタンの要素id}")).Click();
ログインボタンのクリック
勤務時間取得用のページへ遷移し、HTML取得
*driver.Navigate().GoToUrl(targetPage);
ブラウザを閉じる
*driver.Quit();

*await publisher.SendAsync(new MyEvent());
← イベント送信処理が終わるまで待機される
*{// ISubscirberからIAｓｙncSubscirberに変更[Inject] private IAsyncSubscriber<;MyEvent>; _asyncSubscriber;public void Subscribe(){_asyncSubscriber.Subscribe(async (x, ctr) =>;{var time = Time.realtimeSinceStartup;// ここで非同期処理が可能// 大体1秒待機するawait UniTask.Delay(TimeSpan.FromSeconds(1), cancellationToken: ctr);time = Time.realtimeSinceStartup - time;Debug.Log($"イベント受信完了 待機秒数: {time}秒");});}}
イベント受け取る方
ISubscirberからIAｓｙncSubscirberに変更
*[Inject] private IAsyncSubscriber<;MyEvent>; _asyncSubscriber;
ここで非同期処理が可能
大体1秒待機する
*await UniTask.Delay(TimeSpan.FromSeconds(1), cancellationToken: ctr);
*{[Inject] private IAsyncSubscriber<;MyEvent>; _asyncSubscriber;public async UniTask WaitAsync(CancellationTokenSource cts){// MyEventがくるまでawaitで待つvar ev = await _asyncSubscriber.FirstAsync(cts.Token);Debug.Log($"イベント受信完了！！");}}
イベント受け取る方
MyEventがくるまでawaitで待つ
*var ev = await _asyncSubscriber.FirstAsync(cts.Token);
*{[Inject] private IAsyncPublisher<;MyEvent>; _asyncPublisher;public async UniTask SendAsync(MyEvent ev){// Subscriberの購読処理が終わるまで待つawait _asyncPublisher.PublishAsync(ev);Debug.Log("イベント送信完了");}}
イベント送る方
Subscriberの購読処理が終わるまで待つ
*await _asyncPublisher.PublishAsync(ev);
*{[Inject] private IAsyncSubscriber<;MyEvent>; _asyncSubscriber;[Inject] private ISubscriber<;MyEvent>; _subscriber;private CancellationTokenSource _cts = new CancellationTokenSource();private IDisposable _disposable;public void Subscribe(){var bag = DisposableBag.CreateBuilder();// イベントが来たら反応する_subscriber.Subscribe(ev =>;{Debug.Log($"イベント受信完了: {ev.Message}");}).AddTo(bag);_disposable = bag.Build();}/// <;summary>;/// 最初のイベントが来るまで待機/// <;/summary>;public async UniTask FirstAsync(){var ev = await _asyncSubscriber.FirstAsync(_cts.Token);Debug.Log($"イベント受信完了: {ev.Message}");}/// <;summary>;/// Subscribe内で待機/// <;/summary>;public void SubscribeAsync(System.Action onFinished){var bag = DisposableBag.CreateBuilder();_asyncSubscriber.Subscribe(async (x, ctr) =>;{var time = Time.realtimeSinceStartup;// ここで非同期処理が可能// 大体1秒待機await UniTask.Delay(TimeSpan.FromSeconds(1), cancellationToken: ctr);time = Time.realtimeSinceStartup - time;Debug.Log($"イベント受信完了: {x.Message} 待機秒数: {time}秒");// 終わったらよびだしonFinished?.Invoke();}).AddTo(bag);_disposable = bag.Build();}public void Close(){_disposable?.Dispose();}}
イベント受け取る方
イベントが来たら反応する
*_subscriber
ここで非同期処理が可能
大体1秒待機
*await UniTask.Delay(TimeSpan.FromSeconds(1), cancellationToken: ctr);
終わったらよびだし
*onFinished?.Invoke();
*{public string Message;}
送るイベント
イベントを受ける方
*var subscriber = _container.Instantiate<;Subscriber>;();
*await publisher.SendAsync(new MyEvent { Message = "イベント" });
イベントを投げる方
イベントを受ける方
*var subscriber = _container.Instantiate<;Subscriber>;();
終わったらフラグをtrueにして終了させる
*isFinished = true;
*await publisher.SendAsync(new MyEvent { Message = "イベント" });
イベントを投げる方
イベントを受ける方
*var subscriber = _container.Instantiate<;Subscriber>;();
*await publisher.SendAsync(new MyEvent { Message = "イベント" });
イベントを投げる方
GlobalMessagePipeを使用する前にSetProviderに設定する必要がある
*GlobalMessagePipe.SetProvider(_container.AsServiceProvider());
非同期用のPublisher/Subscriberを生成する
*var asyncSubscriber = GlobalMessagePipe.GetAsyncSubscriber<;MyEvent>;();
*Debug.Log($"イベント受信完了 : {ev.Message}");
イベントを受ける方
*await asyncPublisher.PublishAsync(new MyEvent { Message = "イベント" }, cts.Token);
イベントを投げる方

*root.Add(ce);
...2

以下は、取得したAPIキーに置き換えてください。
*private const string c_ConsumerKey = "xxxx";

ProgIDからOfficeアプリのCOMのTypeを取得する。
EXCEL:"Excel.Application"
ACCESS:"Access.Application"
Word:"Word.Application"
*var appType = Type.GetTypeFromProgID("Excel.Application");
*if (!Environment.Is64BitOperatingSystem)*{
64bitOSじゃない場合は無条件で32bit
COMオブジェクトを作成し、対象アプリのプロセス名を検索する。
EXCEL:"EXCEL"
ACCESS:"MSACCESS"
WORD:"WINWORD"
*app = Activator.CreateInstance(appType);
プロセスの実行にWOW64が使用されているかどうか確認する。
（使用されていたら32bit）
*bool bWow64;
インストールされていない場合はここにくる
*return null;
アプリ停止＆解放
*app.Quit();
GCを強制
*GC.Collect();
ProgIDからOfficeアプリのCOMのTypeを取得する。
EXCEL:"Excel.Application"
ACCESS:"Access.Application"
Word:"Word.Application"
*var appType = Type.GetTypeFromProgID("Excel.Application");
*if (!Environment.Is64BitOperatingSystem)*{
64bitOSじゃない場合は無条件で32bit
*string keyPath = $@"CLSID\{appType.GUID:B}\ProgID";
TypeのGUIDから64bit用のレジストリを検索する。

*IEnumerable<;int<; vs = uniReadOnlyCollection;
エラー！インターフェイスが絡んでいるので暗黙的な型変換が行われない

*StartCoroutine(ExecuteTaskCoroutin());
エンジンの初期化タイミング（ユーザーコードが走りだす前に）

値が等しい
*実際の値.Sholud().Be(期待値);
値がNULL
*実際の値.Sholud().BeNull();
値がNULLではない
*実際の値.Sholud().NotBeNull();
値がTrue
*実際の値.Sholud().BeTrue();
値がFalse
*実際の値.Sholud().BeFalse();
値が同じオブジェクト
*実際の値.Should().BeSameAs(期待値);
同じ要素を含む
*実際の値.Should().BeEquivalentTo(期待値);
空のコレクション
*実際の値.Should().BeEmpty();
期待値より後
*実際の値.Should().BeAfter(期待値);
*実際の値.Should().BeBefore(期待値);*// 期待値とズレ(単位:ms)の範囲内
期待値より前
期待値とズレ(単位:ms)の範囲内
*実際の値.Should().BeCloseTo(期待値,　ズレ);

*throw new ServiceException($"ユーザ名の取得に失敗しました。 ユーザID:{userId}");
だが、ここの行番号がログに出力される
*throw new ServiceException($"ユーザ名の取得に失敗しました。 ユーザID:{userId}", ex);
InnerExceptionに実際に起きた例外を入れてあげる
*public ServiceException(string message, Exception inner) : base(message, inner) { }
自作した例外の場合は発生した例外を InnerException に入れておくためのコンストラクタを作成する

*Console.WriteLine($"これから{methodCall.MethodName}処理に入ります。");
SampleMethod()情報が入ってきます
*Console.WriteLine($"{methodCall.MethodName}処理が終わりました。");
SampleMethod()実行

*callerContext.Post(() =<;
呼び出し元のContext（≒スレッド）に戻す

*foo(new("Tanaka"));
PropertyChangedEventArgs の new とかで使いそう

StreamReaderにCSVのパスを渡す
*using (var reader = new StreamReader("user.csv"))
ここに読み込んだCSVを処理を書く
*}
*public int Id { get; set; }
ヘッダーを名前で指定することでマッピングできる

*//（例）lipShape["k"] = { 0.1f, 0.0f, 0.1f, 0.0f, 0.0f }　　　"A","I","U","E","O" の各 BlendShape.Value
上記の他、口の形のデータを Dictionary&lt;string, float[]&gt;　で lipShape に読み込んでおきます。
（例）lipShape["k"] = { 0.1f, 0.0f, 0.1f, 0.0f, 0.0f }　　　"A","I","U","E","O" の各 BlendShape.Value
AudioSource での音声データ再生
実際には、以下の4行は PlayVoice というコルーチンで処理しています。
PlayVoice内から PlayLipSync(letters, dts) を実行しています。
*audioSource = this.GetComponent<;AudioSource>;();
【注】この例ではリミテッドアニメーションぽい処理になっています。
実際は Mathf.Lerp, Time.deltaTime等 を使ってフルアニメーションぽい感じにしています。
口の大きさを AudioSourceのvolumeで取得する。
リアルタイムでClipの音量を取得し口の大きさに反映させる方法は試したものの、思ったほど効果はありませんでした。
*float vv = 0.5f * audioSoure.volume + 0.5f;
1文字目の時間は0.05秒で固定
そもそも 1文字目で 0.05秒未満の発話時間しかない場合には、以下の処理を行わないようにしておきます。
*vrmBlendShapeProxy.AccumulateValue(BlendShapeKey.CreateFromPreset(BlendShapePreset.A), lipShape[let1][0] * vv);
1文字目の口の形で 0.05秒
*yield return new WaitForSecondsRealtime(0.05f);
2文字目
*vrmBlendShapeProxy.AccumulateValue(BlendShapeKey.CreateFromPreset(BlendShapePreset.A), lipShape[let2][0] * vv);
2文字目の口の形で （dts[i] - 0.05）秒
*yield return new WaitForSecondsRealtime(dts[i] - 0.05f);
【注】この例ではリミテッドアニメーションぽい処理になっていますが、
実際は Mathf.Lerp, Time.deltaTime等 を使ってフルアニメーションぽい感じにしています。
口の大きさを AudioSourceのvolumeで取得する。（音声波形の解析はしない）
リアルタイムでClipの音量を取得し口の大きさに反映させる方法は試したものの、思ったほど効果はありませんでした。
*float vv = 0.5f * audioSoure.volume + 0.5f;
英語は発音記号1文字毎の処理で良い
*string let = letters[i];

前進処理
*}

*img.CacheOption = BitmapCacheOption.OnLoad;
←ここが重要

*if (T != null)
取得できなかったら`null`になる。
StaticとNonPublicを両方指定しないといけない。
*var info = MyClass.GetProperty("Prop", BindingFlags.Static | BindingFlags.NonPublic);
ここでも`BindingFlags.Static`が必要。
*dynamic val = info.GetValue(MyClass, BindingFlags.Static, null, null, null);

*{return View(new TestViewModel());}
GET: HomeController
*{services.AddRazorPages();services.AddScoped<;ITestFilterAttribute, TestFilterAttribute>;();}
This method gets called by the runtime. Use this method to add services to the container.
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseExceptionHandler("/Error");// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.app.UseHsts();}app.UseHttpsRedirection();app.UseStaticFiles();app.UseRouting();app.UseAuthorization();app.UseEndpoints(endpoints =>;{endpoints.MapControllerRoute(name: "default", pattern: "{controller=Permission}/{action=Index}/{id?}");endpoints.MapRazorPages();});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
DIのServiceProviderからITestFilterAttributeを取り出す
*ITestFilterAttribute filter = serviceProvider.GetService<;ITestFilterAttribute>;();
*{return View(new TestViewModel());}
GET: HomeController

実験2で使用
createMat.Dispose();
*}
実験3で使用
CheckMemory();
GC.Collect();
*CheckMemory();
*Console.WriteLine(String.Format("現在のメモリ使用量はおよそ{0}MB、前回からの差分は{1}MBです。", currentMemory, currentMemory - lastMemory));
MB単位。
*if (i == 0)*{
動画フォルダ読み込み直後のメモリ使用量を確かめたい。
*if (i == 0)*{
動画フォルダ読み込み直後のメモリ使用量を確かめたい。
*if (i == 0)*{
動画フォルダ読み込み直後のメモリ使用量を確かめたい。

メンバ変数値変更
*privateObject.SetFieldOrProperty("_privateMember", 100);
Privateメソッド呼び出し
*var ret = privateObject.Invoke("PrivateMethod", 100, 200);
戻り値の型でくるんでawait
*var ret = await (privateObject.Invoke("PrivateMethodAsync", 100, 200) as Task<;int>;);
static変数値変更
*privateType.SetStaticFieldOrProperty("_privateStaticMember", "ヨシッ！");
staticメソッド呼び出し
*var ret = privateType.InvokeStatic("GetPrivateStaticMember");

*.Take(10)
上位 10 件

.NET 5 RC 1 以降
*using System.Text.RegularExpressions;

*var SeanConnery = arr[0][0];
値取得
*string[][] arr = { new string[3] { "あ", "い", "う" },
ジャグ配列の初期化
2次元のサイズを後で決める
*string[][] arr2 = new string[3][];
要素数を10に変更する
VBの「ReDim Preserve」と等価で代入済みの値を維持する
*Array.Resize(ref arr, 10);

...(中略)...
*[ResourceExposure(ResourceScope.None)]
...(中略)...
*[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
...(中略)...
*[ResourceExposure(ResourceScope.None)]

StoryBoardを検索
*var sb = FindResource("MyRoundingAnimation") as Storyboard;
*if (sender is ToggleButton tb)*{
トグルボタンを押すたびにstart/stopする

「一つ前の」スタックを参照する
*StackFrame CallStack = new StackFrame(1, true);

*Screen ownerScreen = Screen.FromControl(this);
所属している画面を取得
*if ( preferedSize.Width <;= rect.Width &amp;&amp; preferedSize.Width <;= rect.Height ) {ClientSize = preferedSize;}
画面に収まるときだけリサイズする
*if ( preferedSize.Width <;= rect.Width &amp;&amp; preferedSize.Width <;= rect.Height ) {*ClientSize = preferedSize;
（※厳密には、タイトルバーと枠線を考慮に入れていないので収まらない）

*using OpenCvSharp;
OpenCvSharp4 4.4.0.20200725 (2020年7月25日 土曜日 (20200725))
ラムダ式は、デリゲート型に変換できます。
*Func<;Mat>; function = () =>; capture_work();
Task.Run(Action) メソッドの引数として使用すると、バックグラウンドで実行
*matframe = await Task.Run(function);
*if (matframe != null)*{
画像取得出来ていれば
*if (!await Task.Run(() =>; Isface( path_img, path_img_face)))*{
顔認識
*if (!await Task.Run(() =>; Isface(path_img, path_img_face)))*{
顔認識
カメラ画像取得用のVideoCapture作成
*capture = new VideoCapture(0);
*if (!capture.IsOpened())*{
カメラが見つからない場合
取得先のMat作成
*Mat matframe = new Mat(HEIGHT, WIDTH, MatType.CV_8UC3);
表示用のBitmap作成
*bmp = new Bitmap(matframe.Cols, matframe.Rows, (int)matframe.Step(), System.Drawing.Imaging.PixelFormat.Format24bppRgb, matframe.Data);
エンコード
*ImageEncodingParam encodingParam = new ImageEncodingParam(ImwriteFlags.PngBilevel, 0);
デコードして保存する
*mat = Cv2.ImDecode(buffer, ImreadModes.Color);
画像の保存
*Cv2.ImWrite(path, mat);
*{// 分類機の用意using (CascadeClassifier cascade = new CascadeClassifier(path_xml)){foreach (Rect rectFace in cascade.DetectMultiScale(mat)){// 見つかった場所に赤枠を表示Rect rect = new Rect(rectFace.X, rectFace.Y, rectFace.Width, rectFace.Height);Cv2.Rectangle(mat, rect, new OpenCvSharp.Scalar(0, 0, 255), 2);}}//画像を保存save(path_img_face, mat);}
顔の矩形を抽出
*using (CascadeClassifier cascade = new CascadeClassifier(path_xml))*{
分類機の用意
見つかった場所に赤枠を表示
*Rect rect = new Rect(rectFace.X, rectFace.Y, rectFace.Width, rectFace.Height);
画像を保存
*save(path_img_face, mat);

*{foreach (DirectoryInfo dir in cDirs){sw.WriteLine(dir.Name);}}
Write each directory name to a file.
*{// Read the stream as a string, and write the string to the console.Console.WriteLine(sr.ReadToEnd());}
Open the text file using a stream reader.

Assemblyの遅延ローディング対象となるリストの一覧を読み込む
LoadAssemblyFrom(@"file:" + Path.GetFullPath(c_DirectryPath));
インスタンスの生成を試みる
*try
何もしない
*}
別ソリューションで作成します。
Assemblyが読み込めることが確認できれば良いので中身は空っぽです。
*namespace ClassLibrarySample

*FormClosed += (s,e)=<;{Value = txt.Text;};
SubFormが閉じられたときにデータをセットしておく

*var offset = 50;
取得した通りの値だと動きすぎるので少し調整してやります

*static class Patch_OcPl_charaChangeSteup
Steupは運営のtypoのまま
*{UnityEngine.Debug.Log("charaChangeSetup Postfix");// VRMモデルが読み込まれていなかったらif (vrmModel == null){// VRMモデル読み込みvrmModel = ImportVRM(VrmPath);}// VRMモデルをまだセットしていないPlayerインスタンスの場合if (!alreadyVrmSetList.Contains(__instance)){// VRMモデルを複製var model = GameObject.Instantiate(vrmModel);// 親を既存モデルにセットmodel.transform.SetParent(__instance.transform, false);alreadyVrmSetList.Add(__instance);}// 既存モデルのVRMモデル以外のSkinnedMeshRendererを非表示foreach (var smr in __instance.GetComponentsInChildren<;SkinnedMeshRenderer>;()){smr.enabled = false;Transform trans = smr.transform;while (vrmModel != null &amp;&amp; trans != null){if (trans.name.Contains(vrmModel.name)){smr.enabled = true;break;}trans = trans.parent;}}}
元のcharaChangeSteupが呼ばれた後に呼ばれるメソッド
*if (vrmModel == null)*{
VRMモデルが読み込まれていなかったら
VRMモデル読み込み
*vrmModel = ImportVRM(VrmPath);
*if (!alreadyVrmSetList.Contains(__instance))*{
VRMモデルをまだセットしていないPlayerインスタンスの場合
VRMモデルを複製
*var model = GameObject.Instantiate(vrmModel);
*model.transform.SetParent(__instance.transform, false);*alreadyVrmSetList.Add(__instance);
親を既存モデルにセット
*foreach (var smr in __instance.GetComponentsInChildren<;SkinnedMeshRenderer>;())*{
既存モデルのVRMモデル以外のSkinnedMeshRendererを非表示
*foreach (var mr in __instance.GetComponentsInChildren<;MeshRenderer>;())*{
既存モデルの頭部を非表示にする

*driver.Navigate().GoToUrl("https:
www.google.co.jp");

*string curDir = Environment.CurrentDirectory;
Directory.GetCurrentDirectory() でも同様

*Console.WriteLine("別ユーザー");
出力される。
dateA の翌日が欲しかったが 31 日であることに気付かず日付に 1 を足してしまった。
*var dateB = new DateTime(dateA.Year, dateA.Month, dateA.Day + 1);

*.Max();
一番新しい日付のものを取り出す

終了
*return;
終了処理をキャンセル
*e.Cancel = true;

*private const int WS_MAXIMIZEBOX = 0x0001_0000;
C#7より前の場合は 0x00010000

*private string baseURL = "wss:
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
この一文を追加する。
*webSocket.SslConfiguration.EnabledSslProtocols = System.Security.Authentication.SslProtocols.Tls12;

*if((obj is int x) == false) return;*//後々の処理にxを使おうとすると
こうしてobjのインスタンスの型が任意の型でない場合を弾いた後
後々の処理にxを使おうとすると
未初期化の可能性があると言われ怒られる
*Console.WriteLine(x);
同名変数の再宣言も不可で怒られる
*int x = 1;
怒られずにnullチェック済みのxを使って処理が可能
*Console.WriteLine(x);

PDFオブジェクト作成
*PdfDocument document = new PdfDocument()
file：結合するファイルのパス
PdfDocumentOpenMode.Import：PDFを読み取りモードで開く
結合するPDFオブジェクトを作成
*PdfDocument inputDocument = PdfReader.Open(file, PdfDocumentOpenMode.Import)
*foreach (PdfPage page in inputDocument.Pages)*{
頁全件ループ
PDF頁を追加
*document.AddPage(page);
結合するPDFを閉じる
*inputDocument.Close();
PDF保存
*document.Save(selectedPath);
PDFを閉じる
*document.Close();

*driver.Navigate().GoToUrl("https:
developer.mozilla.orgjadocsWebHTMLElementselect");

*var uri = new Uri(string.Format("https:
{0}{1}", RelayNamespace, ConnectionName));

*Console.WriteLine(t);
"hoge"

*WordWrap = false,
折り返し表示をしない

*int n = (int)nud.Value;
NumericUpDownのValueプロパティはdecimal型なので、整数にしたい場合は、キャストが必要
*checked {for ( int k=1; k<;=n; k++ ) {prod *= k;}}
checked {}で囲むと、オーバーフローを検出したときにエラーを発生させる。
*checked {for ( int k=1; k<;=n; k++ ) {prod *= k;}}
※13の階乗(13!)は C#の intの最大値 (2^31)-1 を超えてオーバーフローする

*FormattingEnabled = true,
頂いたコメントを受けて追加しました！

*lsv.Items.Clear();
※Itemsを忘れると列ヘッダごと消えます

*public void OnTouched() {Debug.Log("オブジェクトがタッチされました!!");}
タッチされた時に呼ばれる関数

*//▼カテゴリ. dotnet test --filter TestCategory={CategoryName}のオプションで特定のカテゴリのみテスト実行可能
▼テストケースの作者
▼カテゴリ. dotnet test --filter TestCategory={CategoryName}のオプションで特定のカテゴリのみテスト実行可能
*, Category="hogeCategory"
▼テストケースの説明
*, Description="説明だYO"
*, ExcludePlatform="Net-1.0,Windows8"*//▼想定結果。Assertクラス等によるアサーションではなく、戻り値に実行結果を返すようにする。
▼テストを実行しないプラットフォームをカンマ区切りで指定。OSや.NETバージョンなどを指定可能
▼想定結果。Assertクラス等によるアサーションではなく、戻り値に実行結果を返すようにする。
*, ExpectedResult="hoge"
▼テスト無効フラグ。trueにするとテストが実行されなくなる
*, Explicit=false
▼テスト無効理由。Explicitとセットで使う
*, Reason="hogeしか返ってこんし"
▼テスト無視フラグと理由。このAttributeが付いているとテストが実行されなくなる
*, Ignore="hogeしか返ってこんし"
▼Ignoreと全く同じ。どちらか1つでいい
*, IgnoreReason="hogeしか返ってこんし"
▼テスト名。デフォルトではメソッド名になる
*, TestName="Hogeテスト"
▼対象のテストクラス
*, TestOf=typeof(String)

*{services.AddRazorPages();}
This method gets called by the runtime. Use this method to add services to the container.
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseExceptionHandler("/Error");// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.app.UseHsts();}app.UseHttpsRedirection();app.UseStaticFiles();app.UseRouting();app.UseAuthorization();app.UseEndpoints(endpoints =>;{endpoints.MapRazorPages();});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*toDown = xxxCtrl.ToDown;
IXXXControlの実装が保証されている！

*Array.Copy(b.Data, 0, Data, Size, b.Size);
bの有効データを、thisの有効データの末尾(位置=Size)以降にコピーする
*{// This program ignores S5, S7, S8, S9.static Regex rSn = new Regex(@"^S([01235789])");static Regex rS0 = new Regex(@"^S(0)([0-9A-Fa-f]{2})((?:[0-9A-Fa-f]{2})*)([0-9A-Fa-f]{2})$");static Regex rS1 = new Regex(@"^S(1)([0-9A-Fa-f]{2})([0-9A-Fa-f]{4})((?:[0-9A-Fa-f]{2})+)([0-9A-Fa-f]{2})$");static Regex rS2 = new Regex(@"^S(2)([0-9A-Fa-f]{2})([0-9A-Fa-f]{6})((?:[0-9A-Fa-f]{2})+)([0-9A-Fa-f]{2})$");static Regex rS3 = new Regex(@"^S(3)([0-9A-Fa-f]{2})([0-9A-Fa-f]{8})((?:[0-9A-Fa-f]{2})+)([0-9A-Fa-f]{2})$");public int    RecordType{get;private set;}public int    RecordLength{get;private set;}public long   Address{get;private set;}public byte[] DataBytes{get;private set;}public byte   CheckSum{get;private set;}public int    DataLength{get{return DataBytes.Length;}}public long   EndAddress{get{return Address + DataBytes.Length -1;}}public bool IsValidSum{get{return CalcCheckSum()==CheckSum;}}byte CalcCheckSum(){int sum=0;sum +=  RecordLength;sum += (byte)(Address>;>;24);sum += (byte)(Address>;>;16);sum += (byte)(Address>;>; 8);sum += (byte) Address;foreach(byte b in DataBytes) {sum += b;}return (byte)(~sum);}OneRecord(){}public static OneRecord FromString(string s, bool checkFormat = true){Match m;m = rSn.Match(s);if ( !m.Success ) {return null;}m = rS1.Match(s);if ( !m.Success ) { m = rS2.Match(s); }if ( !m.Success ) { m = rS3.Match(s); }if ( !m.Success ) { return null; }var ret = new OneRecord();ret.RecordType   = Convert.ToInt32(m.Groups[1].Value);ret.RecordLength = Convert.ToInt32(m.Groups[2].Value, 16);ret.Address      = Convert.ToInt64(m.Groups[3].Value, 16);ret.DataBytes    = HexStrToByteArray(m.Groups[4].Value);ret.CheckSum     = Convert.ToByte(m.Groups[5].Value, 16);if ( checkFormat ) {if ( ret.RecordLength*2 != s.Length - 4) {Console.WriteLine("LengthError");return null;}if ( !ret.IsValidSum ){Console.WriteLine("ChkSumError");return null;}}return ret;}static int HexCharToInt(char c){if('0'<;=c&amp;&amp;c<;='9'){return  c-'0';}if('A'<;=c&amp;&amp;c<;='F'){return (c-'A')+10;}if('a'<;=c&amp;&amp;c<;='f'){return (c-'a')+10;}return -1;}static byte[] HexStrToByteArray(string s){// length of the argument `s` must be even value.byte[] a = new byte[s.Length/2];for (int pos=0 ; pos+1<;s.Length ; pos+=2) {a[pos/2] = (byte)( (HexCharToInt(s[pos])<;<;4) | HexCharToInt(s[pos+1]) );}return a;}}
S-Record 1行分のデータを扱う
*static Regex rS0 = new Regex(@"^S(0)([0-9A-Fa-f]{2})((?:[0-9A-Fa-f]{2})*)([0-9A-Fa-f]{2})$");
This program ignores S5, S7, S8, S9.
*for (int pos=0 ; pos+1<;s.Length ; pos+=2) {a[pos/2] = (byte)( (HexCharToInt(s[pos])<;<;4) | HexCharToInt(s[pos+1]) );}
length of the argument `s` must be even value.

*System.Console.WriteLine("samStruct2.x = " + samStruct2.x);
samStruct2.x = 100
*{sam.x = 100;}
値型の参照渡し

修正前(プロジェクト作成デフォルト状態)

*public string FunctionHandler(string input, ILambdaContext context)
引数で受け取った文字列を大文字にして返す
*return input?.ToUpper();
修正後

*public string FunctionHandler(object input, ILambdaContext context)
*context.Logger.LogLine($"Arg : [{input}]");
受け取った引数をログに出力
ＯＫ という文字列を返す
return "OK"; input?.ToUpper();
*}

*for (int i = 0; i <; 3; i++)*{
for (初期化式; ループ条件式; 更新式)
ループ処理
*Console.WriteLine(i);
*foreach (int even in arr)*{
foreach (一時変数宣言 in コレクション)
ループ処理
*Console.WriteLine(even);
変更不可
even *= 2;
*}
while (条件式)
*bool loop = true;
loop = 何らかの処理
*}
*} while (loop);*,,,
loop = 何らかの処理

コントロールの再描画要求
*Invalidate();

*new OpcodeDef("Jarl disp22,reg2"             ,true  ,RelJmp,   "rrrrr11110dddddd","ddddddddddddddd0",FormatId.V    ,DescReg123           ),
仮desc

*CellRendererToggle.Toggled += delegate(object o, ToggledArgs args) {TreeIter iter;if(testStore.GetIterFromString(out iter, args.Path)) {testModel testModel1 = (testModel)testStore.GetValue(iter, 0);}};
イベントハンドラ１
イベントハンドラ2
*CellRendererToggle.Toggled += new ToggledHandler(testToggled);

*var ano = strList.Select((str, index) =>; new { str, index });
anoはタプルではない！匿名型
↓NG : '&lt;anonymous type: string str, int index&gt;'を'(string str, int index)'に暗黙的に変換できません
(string str, int index) val = ano.FirstOrDefault();
*,,,
tupはタプル！
*var tup = strList.Select((str, index) =>; (str, index));

*Controls.Add(menuStrip);
注意：panel より先に登録してしまうと、panelとmenuStripが重なって表示されてしまう。

*NotifyObservers();
★ココ！で通知を受ける側へ状態変更を知らせる
System.ValueTapleの機能による要素の交換
*(array[j], array[j - 1]) = (array[j - 1], array[j]);
★ココ！で通知を受ける側へ状態変更を知らせる
*Items = array;
現在のソートの状態を数値の並び→横棒グラフ状の文字列に変換する。
*str += new string( Enumerable.Repeat( "■", n ).SelectMany( x =>; x ).ToArray() )
アニメの一コマ分として画面に表示する
*Animator.DisplaySingleFrame( str );
1~20の数値を生成・シャッフルし、バブルソートの初期値とする。
*var bubbleSort = new BubbleSortExecutable(
*{DataSource = bubbleSort};
バブルソート実行体を通知を受ける側へ設定する
バブルソートの実行。この処理内でソート処理のアニメーションが実行される。
*bubbleSort.Sort();

Dictionary&lt;キー型, 値型&gt;
*Dictionary<;int, string>; dic = new Dictionary<;int, string>;();

Dictionary オブジェクトを作成し、itemを追加します。
*Dictionary TagValues = new Dictionary();
PowerPointファイルをロードします。
*Presentation presentation = new Presentation();
ReplaceTagsメソッドで文字を置換します。
*ReplaceTags(presentation.Slides[0], TagValues);
保存します。
*presentation.SaveToFile("Result.pptx", FileFormat.Pptx2010);

*PersonRecord { LastName = Wagner, FirstName = Bill }
PersonRecordのToString

*{/// <;summary>;/// Custom editor to allow re-orderable lists/arrays in Unity Inspector automatically./// This custom editor overrides Unity's default SerializedProperty drawing for arrays and lists./// This is inspired by Valentin Simonov's blog article here:/// http://va.lent.in/unity-make-your-lists-functional-with-reorderablelist/ , along with additional tweaks/functionality./// <;/summary>;/// <;inheritdoc />;[CustomEditor(typeof(Object), true)][CanEditMultipleObjects]public class ReorderableListEditor : Editor{private Dictionary<;string, ReorderableListProperty>; _reorderableListDict;protected virtual void OnEnable(){_reorderableListDict = new Dictionary<;string, ReorderableListProperty>;();}protected virtual void OnDestroy(){_reorderableListDict.Clear();_reorderableListDict = null;}public override void OnInspectorGUI(){var propertyValueColor = GUI.color;serializedObject.Update();var property = serializedObject.GetIterator();if (property.NextVisible(true)){do{GUI.color = propertyValueColor;DrawProperty(property);} while (property.NextVisible(false));}serializedObject.ApplyModifiedProperties();}private void DrawProperty(SerializedProperty property){var isPropertyMonoBehaviourId = property.name.Equals("m_Script")&amp;&amp; property.type.Equals("PPtr<;MonoScript>;")&amp;&amp; (property.propertyType == SerializedPropertyType.ObjectReference)&amp;&amp; property.propertyPath.Equals("m_Script");if (isPropertyMonoBehaviourId){EditorGUI.BeginDisabledGroup(true);EditorGUILayout.PropertyField(property);EditorGUI.EndDisabledGroup();return;}if (property.isArray &amp;&amp; property.propertyType != SerializedPropertyType.String){this.DrawListProperty(property);}else{EditorGUILayout.PropertyField(property, property.isExpanded);}}private void DrawListProperty(SerializedProperty property){var reorderableListProperty = this.GetReorderableList(property);if (reorderableListProperty.property.isExpanded == false){reorderableListProperty.DoListHeader();}else{reorderableListProperty.DoLayoutList();}EditorGUILayout.GetControlRect(true, -2f);}private ReorderableListProperty GetReorderableList(SerializedProperty property){if (_reorderableListDict.TryGetValue(property.name, out var reorderableListProperty)){reorderableListProperty.property = property;return reorderableListProperty;}reorderableListProperty = new ReorderableListProperty(property);_reorderableListDict[property.name] = reorderableListProperty;return reorderableListProperty;}private class ReorderableListProperty{private const float HeaderLeftMargin = 10f;private const float ElementTopMargin = 2f;private const float ElementLeftMargin = 9f;private const float ElementVerticalMargin = 4f;private static readonly FieldInfo ReorderableListDefaultsField = typeof(ReorderableList).GetField("s_Defaults", BindingFlags.Static | BindingFlags.NonPublic);private static readonly MethodInfo DoListHeaderMethod = typeof(ReorderableList).GetMethod("DoListHeader", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.InvokeMethod);private ReorderableList _list;private SerializedProperty _property;public SerializedProperty property{get =>; _property;set{_property = value;_list.serializedProperty = _property;}}public ReorderableListProperty(SerializedProperty property){_property = property;_list = new ReorderableList(_property.serializedObject, _property, true, true, true, true);_list.drawHeaderCallback += this.OnDrawHeader;_list.drawElementCallback += this.OnDrawElement;_list.elementHeightCallback += this.OnElementHeight;_list.onCanRemoveCallback += this.OnCanRemove;}~ReorderableListProperty(){_property = null;_list = null;}private void OnDrawHeader(Rect rect){_property.isExpanded = EditorGUI.Foldout(new Rect(rect.x + HeaderLeftMargin, rect.y, rect.width, rect.height),_property.isExpanded,_property.displayName,true,EditorStyles.foldout);}private void OnDrawElement(Rect rect, int index, bool active, bool focused){rect.y += ElementTopMargin;rect.height = EditorGUIUtility.singleLineHeight;var propertyChild = _property.GetArrayElementAtIndex(index);if (propertyChild.propertyType == SerializedPropertyType.Generic){rect.x += ElementLeftMargin;rect.width -= ElementLeftMargin;EditorGUI.LabelField(rect, propertyChild.displayName);}EditorGUI.PropertyField(rect, propertyChild, GUIContent.none, true);_list.elementHeight = rect.height + ElementVerticalMargin;}private float OnElementHeight(int index){return Mathf.Max(EditorGUIUtility.singleLineHeight,EditorGUI.GetPropertyHeight(_property.GetArrayElementAtIndex(index), GUIContent.none, true)) + ElementVerticalMargin;}private bool OnCanRemove(ReorderableList list){return 0 <; _list.count;}public void DoListHeader(){if (ReorderableListDefaultsField.GetValue(null) == null){ReorderableListDefaultsField.SetValue(null, new ReorderableList.Defaults());}var rect = GUILayoutUtility.GetRect(0.0f, _list.headerHeight, GUILayout.ExpandWidth(true));DoListHeaderMethod.Invoke(_list, new object[] {rect});}public void DoLayoutList(){_list.DoLayoutList();}}}}
SEE: https:github.com/andeart/UnityLabs.ReorderableListEditor

*catch ( System.Runtime.InteropServices.ExternalException ) {
クリアに失敗
*try { Clipboard.SetText(s); }
1回だけリトライする
*{public ListViewItem    SelectedItem{get;private set;}public ListViewItem.ListViewSubItem SelectedSubItem{get;private set;}public ListViewContextMenuInfo(ListViewItem selectedItem, ListViewItem.ListViewSubItem selectedSubItem){SelectedItem = selectedItem;SelectedSubItem = selectedSubItem;}}
-----

*"",
no query parameters
リクエストヘッダに署名を追加
*headers.Add("Authorization", authorization);
リクエスト実行
HttpHelpers はUtilで定義
*HttpHelpers.InvokeHttpRequest(uri, "GET", headers, null);

ファイルをロードします。
*Workbook workbook = new Workbook();
*for (int i = 0; i <; workbook.Chartsheets.Count; i++)*{
ToSVGStream(Stream stream)メソッドでシートを別々にSVGで保存

*{// return 戻り値;return x + y;}
[修飾子] 戻り値 メソッド名(型 パラメータ1, 型 パラメータ2, ...)
return 戻り値;
*return x + y;
呼出し方は メソッド名(パラメータ, パラメータ, ...)
*Console.WriteLine(Add(1, 2));
3, 5が実引数
*Console.WriteLine(Add(3, 5));
*{return x + y;}
x, yは仮引数
xへの代入はエラー
x = 1;
*Console.WriteLine(x);
xが未割当てのままメソッドを抜けようとするとエラー
return;
*x = 2;

*// Start is called before the first frame update*void Start()
private Text RadText;
*{Player = GameObject.FindWithTag("Player");Burger = GameObject.FindGameObjectWithTag("Burger");Fries = GameObject.FindGameObjectWithTag("Fries");Drink = GameObject.FindGameObjectWithTag("Drink");//RadText = GetComponentInChildren<;Text>;();}
Start is called before the first frame update
*{UpdateEnemyImage(Burger, BurgerImage);if (Fries != null &amp;&amp; Fries.activeInHierarchy){UpdateEnemyImage(Fries, FriesImage);}else{FriesImage.enabled = false;}if (Drink != null &amp;&amp; Drink.activeInHierarchy){UpdateEnemyImage(Drink, DrinkImage);}else{DrinkImage.enabled = false;}}
Update is called once per frame
正規化することで角度を求めるときに大きさで割るのを省略する
*ToEnemyVec = ToEnemyVec.normalized;
プレイヤーの正面始まりなので、表示のための計算にはラジアンをπ/2だけ移動させる
*float RadOffset = Mathf.PI / 2;
第何象限に敵が位置しているか
*int State = 0;
*if (SinPlayerToEnemy >; 0 &amp;&amp; CosPlayerToEnemy >; 0)*{
第一象限のとき
*else if (SinPlayerToEnemy >; 0 &amp;&amp; CosPlayerToEnemy <; 0)*{
第二象限のとき
*else if (SinPlayerToEnemy <; 0 &amp;&amp; CosPlayerToEnemy <; 0)*{
第三象限のとき
*else if (SinPlayerToEnemy <; 0 &amp;&amp; CosPlayerToEnemy >; 0)*{
第四象限のとき
*{case 0:break;case 1:Rad = Mathf.PI - Rad;break;case 2:Rad = -Mathf.PI - Rad;break;case 3:break;}
Asinでは(-π/2,π/2)の範囲しか表せないので、象限によって範囲を(-π,π)に拡張する
プレイヤーの正面始まりなので、表示のための計算にはラジアンをπ/2だけ移動させる
*float RadOffset = Mathf.PI / 2;
*// Start is called before the first frame update*void Start()
private Text RadText;
*{Player = GameObject.FindWithTag("Player");Burger = GameObject.FindGameObjectWithTag("Burger");Fries = GameObject.FindGameObjectWithTag("Fries");Drink = GameObject.FindGameObjectWithTag("Drink");//RadText = GetComponentInChildren<;Text>;();}
Start is called before the first frame update
*{UpdateEnemyImage(Burger, BurgerImage);if (Fries != null &amp;&amp; Fries.activeInHierarchy){UpdateEnemyImage(Fries, FriesImage);}else{FriesImage.enabled = false;}if (Drink != null &amp;&amp; Drink.activeInHierarchy){UpdateEnemyImage(Drink, DrinkImage);}else{DrinkImage.enabled = false;}}
Update is called once per frame
正規化することで角度を求めるときに大きさで割るのを省略する
*ToEnemyVec = ToEnemyVec.normalized;
第何象限に敵が位置しているか
*int State = 0;
*if (SinPlayerToEnemy >; 0 &amp;&amp; CosPlayerToEnemy >; 0)*{
第一象限のとき
*else if (SinPlayerToEnemy >; 0 &amp;&amp; CosPlayerToEnemy <; 0)*{
第二象限のとき
*else if (SinPlayerToEnemy <; 0 &amp;&amp; CosPlayerToEnemy <; 0)*{
第三象限のとき
*else if (SinPlayerToEnemy <; 0 &amp;&amp; CosPlayerToEnemy >; 0)*{
第四象限のとき
*{case 0:break;case 1:Rad = Mathf.PI - Rad;break;case 2:Rad = -Mathf.PI - Rad;break;case 3:break;}
Asinでは(-π/2,π/2)の範囲しか表せないので、象限によって範囲を(-π,π)に拡張する
プレイヤーの正面始まりなので、表示のための計算にはラジアンをπ/2だけ移動させる
*float RadOffset = Mathf.PI / 2;

Test NG. (ディレクトリ配下のファイル内容は同じ)
*DirectoryAssert.AreEqual(

*public MainWindowViewModel()
コンストラクター内で
ボタンが押された時の動作を定義する
*Loaded_Command.Subscribe(()=>; System.Diagnostics.Debug.WriteLine("Loaded !!"));
これはひとまず気にしないでいい
*public event PropertyChangedEventHandler PropertyChanged;

*spl2.SplitterDistance = 200;
分割線の位置を指定[pixel] Verticalの場合は左端からの位置

*{return View();}
GET: SubSystemHome
defaultsに指定しているクラスのcontrollerプロパティを[Home]→[SubSystemHome]に変更
*routes.MapRoute(

*MimeType = "application
octet-stream",  適宜設定しましょう
新規追加
*var request = service.Files.Create(meta, stream, meta.MimeType);

*private MainPageViewModel ViewModel { get; } = new MainPageViewModel();
add

任意のフレームの描画処理が終わるまで待つ
*await UniTask.WaitForEndOfFrame(ct);
Cameraの描画領域をRenderTextureとして取り出す
*var rt = new RenderTexture(_camera.pixelWidth, _camera.pixelHeight, 24);
*NativeGallery.SaveImageToGallery(screenShot, "GalleryTest", $"{date}.png" );
CameraのRenderTextureを元に画像を作成して保存

*WWW www = new WWW("file:
" + path);
*while ( !www.isDone ) yield return new WaitForSeconds(0.25f);*audio.clip = www.GetAudioClip(false, false);
インポートが完了するまで待つ
wavファイルを削除
*System.IO.File.Delete(path);

*Console.WriteLine(++a);
a = a + 1してからaを表示

credential の作成
*var credentials = SdkContext.AzureCredentialsFactory
Azure オブジェクトの作成
*var azure = Microsoft.Azure.Management.Fluent.Azure
WebApps の config を取得
*var siteConfig = (await azure.WebApps.Inner.GetConfigurationWithHttpMessagesAsync(resourceGroupName, functionAppName)).Body;
config から CORS の一覧を取得
*var corsList = siteConfig.Cors.AllowedOrigins;
*var additionalDomain = "{登録するドメイン}";
COSR の一覧に登録するドメインを追加
*var newSiteConfig = new SiteConfigResourceInner() { Cors = new CorsSettings() };
CORS の一覧を設定
WebApps の config を更新
*await azure.WebApps.Inner.CreateOrUpdateConfigurationWithHttpMessagesAsync(resourceGroupName, functionAppName, newSiteConfig);

*public int Price { get; set; }
新しく追加したカラム

*"",
no query parameters
リクエストヘッダに署名を追加
*headers.Add("Authorization", authorization);
リクエスト実行
HttpHelpers はUtilで定義
*HttpHelpers.InvokeHttpRequest(uri, "GET", headers, null);

CSVファイルの読み込み
*string filePath  = @".\JUFx_KMJ\JUF1_KMJ.csv";
読み込んだ文字列をカンマ区切りで配列に格納
*string[] cols = reader.ReadLine().Split(',');
*if(Regex.IsMatch(cols[0], "^#")){continue;}*for (int n = 0; n ; cols.Length; n++)
コメント行を飛ばす
Dictionary生成
*myTable.Add(cols[0], cols[1]);
読み込んだ文字列をカンマ区切りで配列に格納
*string[] cols = reader2.ReadLine().Split(',');
*if(Regex.IsMatch(cols[0], "^#")){continue;}*for (int n = 0; n ; cols.Length; n++)
コメント行を飛ばす
Dictionary生成
*myTable2.Add(cols[0], cols[1]);
最後まで読み込む
*List<;string[]>; readCsvList = new List<;string[]>;();
*using (FileStream fs = new FileStream(filePath4, FileMode.Open, FileAccess.Read)) {using (FileStream fsout = new FileStream(filePath5, FileMode.Create, FileAccess.Write)) {using (var writer = new BinaryWriter(fsout)) {// バイナリファイル読み出しint fileSize = (int)fs.Length; // ファイルのサイズbyte[] buf = new byte[fileSize]; // データ格納用配列int readSize; // Readメソッドで読み込んだバイト数int remain = fileSize; // 読み込むべき残りのバイト数int bufPos = 0; // データ格納用配列内の追加位置//マルチレイアウトは許可しないDebug.Assert(fileSize%recSize == 0);while (remain >; 0) {readSize = fs.Read(buf, bufPos, Math.Min(recSize, remain));bufPos += readSize;remain -= readSize;}for(int i = 0; i <; fileSize; i++) {for(int j = 0; j <; readCsvList.Count; j++) {if((i != 0) &amp;&amp; ((i%recSize) == 0)){writer.Write(Convert.ToUInt16("000A", 16));}if((j != 0) &amp;&amp; ((i%recSize) == (Convert.ToInt32(readCsvList[j][1])-1))){writer.Write(Convert.ToUInt16("002C", 16));}// １バイトテーブルif(Regex.IsMatch(readCsvList[j][0], "EBC") &amp;&amp;((i%recSize) >;= (Convert.ToInt32(readCsvList[j][1])-1)) &amp;&amp;((i%recSize) <;  (Convert.ToInt32(readCsvList[j][1]) + Convert.ToInt32(readCsvList[j][2])-1))){//Console.Write(myTable[buf[i].ToString("X2")] + "\n");writer.Write(Convert.ToUInt16(myTable[buf[i].ToString("X2")], 16));break;}// ２バイトテーブルif(Regex.IsMatch(readCsvList[j][0], "EKJ") &amp;&amp;((i%recSize) >;= (Convert.ToInt32(readCsvList[j][1])-1)) &amp;&amp;((i%recSize) <;  (Convert.ToInt32(readCsvList[j][1]) + Convert.ToInt32(readCsvList[j][2])-1))){Encoding utf8 = Encoding.GetEncoding("UTF-8");int num = utf8.GetByteCount(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")]);if(utf8.GetByteCount(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")]) <;= 4){//Console.Write(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")] + "\n");writer.Write(Convert.ToUInt16(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")], 16));}else{//サロゲートペア計算（ライブラリが見つからなかった）var codePoint = Convert.ToInt32(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")],16);//Console.Write("codePoint: " + codePoint + "\n");var codePoint2 = (codePoint - 0x10000) >;>; 10;//Console.Write("plane: " + plane + "\n");var lead = (codePoint2 &amp; 0x3F) | 0xD800;//Console.Write("lead: " + lead + "\n");var trail = (codePoint &amp; 0x3FF) | 0xDC00;//Console.Write("trail: " + trail + "\n");writer.Write(Convert.ToUInt16(lead));writer.Write(Convert.ToUInt16(trail));}i++;break;}}}}}}
Console.Write("recSize: " + recSize + "\n");
*using (FileStream fs = new FileStream(filePath4, FileMode.Open, FileAccess.Read)) {using (FileStream fsout = new FileStream(filePath5, FileMode.Create, FileAccess.Write)) {using (var writer = new BinaryWriter(fsout)) {// バイナリファイル読み出しint fileSize = (int)fs.Length; // ファイルのサイズbyte[] buf = new byte[fileSize]; // データ格納用配列int readSize; // Readメソッドで読み込んだバイト数int remain = fileSize; // 読み込むべき残りのバイト数int bufPos = 0; // データ格納用配列内の追加位置//マルチレイアウトは許可しないDebug.Assert(fileSize%recSize == 0);while (remain >; 0) {readSize = fs.Read(buf, bufPos, Math.Min(recSize, remain));bufPos += readSize;remain -= readSize;}for(int i = 0; i <; fileSize; i++) {for(int j = 0; j <; readCsvList.Count; j++) {if((i != 0) &amp;&amp; ((i%recSize) == 0)){writer.Write(Convert.ToUInt16("000A", 16));}if((j != 0) &amp;&amp; ((i%recSize) == (Convert.ToInt32(readCsvList[j][1])-1))){writer.Write(Convert.ToUInt16("002C", 16));}// １バイトテーブルif(Regex.IsMatch(readCsvList[j][0], "EBC") &amp;&amp;((i%recSize) >;= (Convert.ToInt32(readCsvList[j][1])-1)) &amp;&amp;((i%recSize) <;  (Convert.ToInt32(readCsvList[j][1]) + Convert.ToInt32(readCsvList[j][2])-1))){//Console.Write(myTable[buf[i].ToString("X2")] + "\n");writer.Write(Convert.ToUInt16(myTable[buf[i].ToString("X2")], 16));break;}// ２バイトテーブルif(Regex.IsMatch(readCsvList[j][0], "EKJ") &amp;&amp;((i%recSize) >;= (Convert.ToInt32(readCsvList[j][1])-1)) &amp;&amp;((i%recSize) <;  (Convert.ToInt32(readCsvList[j][1]) + Convert.ToInt32(readCsvList[j][2])-1))){Encoding utf8 = Encoding.GetEncoding("UTF-8");int num = utf8.GetByteCount(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")]);if(utf8.GetByteCount(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")]) <;= 4){//Console.Write(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")] + "\n");writer.Write(Convert.ToUInt16(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")], 16));}else{//サロゲートペア計算（ライブラリが見つからなかった）var codePoint = Convert.ToInt32(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")],16);//Console.Write("codePoint: " + codePoint + "\n");var codePoint2 = (codePoint - 0x10000) >;>; 10;//Console.Write("plane: " + plane + "\n");var lead = (codePoint2 &amp; 0x3F) | 0xD800;//Console.Write("lead: " + lead + "\n");var trail = (codePoint &amp; 0x3FF) | 0xDC00;//Console.Write("trail: " + trail + "\n");writer.Write(Convert.ToUInt16(lead));writer.Write(Convert.ToUInt16(trail));}i++;break;}}}}}}
Console.Write(readCsvList.Count + "\n");
バイナリファイル読み出し
int fileSize = (int)fs.Length;  ファイルのサイズ
byte[] buf = new byte[fileSize];  データ格納用配列
int readSize;  Readメソッドで読み込んだバイト数
int remain = fileSize;  読み込むべき残りのバイト数
int bufPos = 0;  データ格納用配列内の追加位置
マルチレイアウトは許可しない
*Debug.Assert(fileSize%recSize == 0);
*if(Regex.IsMatch(readCsvList[j][0], "EBC") &amp;&amp;*((i%recSize) >;= (Convert.ToInt32(readCsvList[j][1])-1)) &amp;&amp;
１バイトテーブル
*if(Regex.IsMatch(readCsvList[j][0], "EKJ") &amp;&amp;*((i%recSize) >;= (Convert.ToInt32(readCsvList[j][1])-1)) &amp;&amp;
２バイトテーブル
サロゲートペア計算（ライブラリが見つからなかった）
*var codePoint = Convert.ToInt32(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")],16);

*int d = (int)c
エラー（オーバーフロー）
コンパイルエラー
型 'double' を 'int' に暗黙的に変換できません。
明示的な変換が存在します (cast が不足していないかどうかを確認してください)）
*,,,

*Minimum =  Int32.MinValue,
-0x80000000

*<;html xmlns="http:
www.w3.org1999xhtml"&gt;
Exceptionを投げたい
*throw new ApplicationException("エラー表示をします");
Request.Formが返すダミーを準備
*NameValueCollection dummyForm = new NameValueCollection();
Request.QueryStringが返すダミーを宣言
*NameValueCollection dummyQS = new NameValueCollection();
Request.Itemsが返すダミーを準備
*NameValueCollection dummyItems = new NameValueCollection();
*{// Formプロパティの偽装FormGet = () =>; dummyForm,// QueryStringの偽装QueryStringGet = () =>; dummyQS,ItemGetString = (string key) =>; dummyItems[key]};
HttpContext.Requestが返すダミーを準備
Formプロパティの偽装
*FormGet = () =>; dummyForm,
QueryStringの偽装
*QueryStringGet = () =>; dummyQS,
HttpContext.Sessionが返すダミーを準備
*DummySessionState dummySessionItem = new DummySessionState();
HttpContextのItemsが返すダミーを準備
*var fakeItems = new Hashtable();
HttpContext.Curretnの偽装
*System.Web.Fakes.ShimHttpContext.CurrentGet = ()
HttpContext.Current.Requestの偽装
*RequestGet = () =>; fakeRequest,
HttpContext.Current.Sessionの偽装
*SessionGet = () =>; fakeSessionState,
HttpContext.Current.Itemsの偽装
*ItemsGet = () =>; fakeItems,
例外を発生させる文言をセット
*dummyItems["presentation"] = "例外表示";

*Easing.Run((x) =<;
easeInExpoで375から3まで1000ミリ秒でアニメーションさせる
処理
*},Easing.Easings.easeOutCubic, 375, 3, 1000);

1秒に一回"ev1"イベントが発生する
停止機能はないので、Ctrl+C等を使用して止めること
*new C1().A();
*{// 解析処理};
汎用的なイベントを購読
解析処理
*};
解析スレッド
*Task.Run(() =>; evsrc.Process()),
停止スレッド
エンターキーを押したら終了する
*Task.Run(() =>;
*foreach(var pname in traceevt.PayloadNames)*{
TracEvent traceevt;
*if(pobj is IDictionary<;string, object>;[] pdicar)*{
object pobj = traceevt.PayloadByName(pname);
解析処理
*}

マーシャリング用クラス定義
*[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
メンバでやる方法
*int numA;
公開プロパティにする
このプロパティはマーシャリングに影響しない
*public int numAProperty
*public int numB { get; set; }
プロパティでやる方法
*public int numB { get; set; }
自動プロパティで適用可
文字列の場合
自動プロパティは不可（後述）
*[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 20)]
C++関数定義
*[DllImport("hoge.dll")]
*{numAProperty = 1,numB = 2,txtProperty = "piyo",};
使用例
*public string txt { get; set; }
以下エラーとなる

*if (time <;= 0.5f)
timeが0.5秒経ったらGameMainに遷移される

*{// ネイティブ関数の宣言// nint はネイティブ整数の意味である、IntPtr にコンパイルされます[DllImport("./foo.dll", EntryPoint = "foo")]static extern string Foo(delegate* unmanaged[Cdecl]<;int, nint>; gen, int count);// UnmanagedCallersOnly でマークされたメソッドには次の制限があります：// * "static" に設定する// * マネージコードから呼び出すことはダメ// * Blittable パラメータのみ[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]static nint Generate(int count){// count 個 'w' を含む文字列の生成var str = Enumerable.Repeat("w", count).Aggregate((a, b) =>; $"{a}{b}");return Marshal.StringToHGlobalAnsi(str);}static void Main(string[] args){// 関数ポインタの作成var f = (delegate* unmanaged[Cdecl]<;int, nint>;)(delegate*<;int, nint>;)&amp;Generate;// 呼び出すvar result = Foo(f, 5);Console.WriteLine(result);}}
unsafe が必要です
ネイティブ関数の宣言
nint はネイティブ整数の意味である、IntPtr にコンパイルされます
*[DllImport("./foo.dll", EntryPoint = "foo")]
UnmanagedCallersOnly でマークされたメソッドには次の制限があります：
* "static" に設定する
* マネージコードから呼び出すことはダメ
* Blittable パラメータのみ
*[UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]
*var str = Enumerable.Repeat("w", count).Aggregate((a, b) =>; $"{a}{b}");
count 個 'w' を含む文字列の生成
関数ポインタの作成
*var f = (delegate* unmanaged[Cdecl]<;int, nint>;)(delegate*<;int, nint>;)&amp;Generate;
呼び出す
*var result = Foo(f, 5);
*var str = Enumerable.Repeat("w", count).Aggregate((a, b) =>; $"{a}{b}");
count 個 'w' を含む文字列の生成
関数ポインタの作成
*var f = (delegate*<;int, string>;)&amp;Generate;
呼び出す
*var result = f(5);
関数ポインタの作成
*var f = (delegate*<;int, string>;)&amp;Generate;
呼び出す
*f(5);
デリゲートの作成
*var f = (Func<;int, string>;)Generate;
呼び出す
*f(5);

*} catch(FileNotFoundException e) {
読み込んだファイルに対して何かしらの処理を行う
*} catch(FileNotFoundException e) {
読み込んだファイルに対して何かしらの処理を行う
*} catch(FileNotFoundException e) {
読み込んだファイルに対して何かしらの処理を行う
引数がnullか空文字("")の場合に発生
*Console.WriteLine("ファイルを開けませんでした。");
ディレクトリが見つからなかった場合に発生
*Console.WriteLine("ファイルを開けませんでした。");
ファイルが見つからなかった場合に発生
*Console.WriteLine("ファイルを開けませんでした。");
CSVのフォーマットが不正な場合に発生
*Console.WriteLine("指定されたcsvファイルのフォーマットが不正です。");

Do something(イベント処理)
*}
もとからある実装
*}

*public int CurrentHp { get { return currentHp; } }
現在のHP
*{}
コンストラクタ
*{}
メソッドも同様に書いていく
最大HP計算用の定数
*private const int PIEACE_AMOUNT = 4;
*{if (initialHeartCount <;= 0){throw new TypeInitializationException(typeof(PlayerHp).FullName,new ArgumentOutOfRangeException());}int initHp = initialHeartCount * PIEACE_AMOUNT;maxHp = initHp;currentHp = initHp;}
コンストラクタ

*{var name = inputs.GetInput<;string>;();log.LogInformation($"Saying hello to {name}.");return $"Hello {name}!";}
public static string SayHello([ActivityTrigger] string name, ILogger log)
*log.LogInformation($"Started orchestration with ID = '{instanceId}'.");
Function input comes from the request content.

*var oid = context.User.Claims.FirstOrDefault(claim =<; claim.Type == "http:
schemas.microsoft.comidentityclaimsobjectidentifier");
appSettings.json の Admins にオブジェクト ID が含まれているか評価
*return this.Configuration.GetSection("Admins").Get<;string[]>;().Contains(oid?.Value);

*new ArrayList() {"hoge", "fuga", "hage"}, Type.GetType("System.String"));
Test OK.
*new ArrayList() {"hoge", "fuga", new Target()}, Type.GetType("System.String"));
Test NG.
*new ArrayList() {new Target(), new Target(), new TargetSub()}, Type.GetType("AssetionsTest.Target"));
Test OK.
*new List<;string>;() {"hoge", "fuga", "hage"});
Test OK.
*new List<;string>;() {"hoge", null, "hage"});
Test NG.
*new List<;string>;() {});
Test OK.
*new List<;string>;() {"hoge", "fuga", "hage"});
Test OK.
*new List<;string>;() {"hoge", "hoge", "hage"});
Test NG.
*new List<;string>;() {"hoge", null, "hage"});
Test OK.
*new List<;string>;() {new String("hoge"), new String("hoge"), new String("hage")});
Test NG.
*new List<;string>;() {"hoge", "fuga", "hage"},
Test OK.
*new List<;string>;() {"hoge", "fuga", "hage"},
Test NG.
*new List<;string>;() {"hoge", "fuga", "hage"},
Test NG.
*new List<;string>;() {"hoge", "fuga", "hage"},
Test OK.
*new List<;string>;() {"hoge", "fuga", "hage"},
Test OK.
*new List<;string>;() {"hoge", "fuga", "hage"},
Test NG.
*new List<;string>;() {"hoge", "fuga", "hage"},
Test OK.
*new List<;string>;() {"hoge", "fuga", "hage"},
Test OK.
*new List<;string>;() {"hoge", "fuga", "hage"},
Test OK.
*new List<;string>;() {"hoge", "fuga", "hage"},
Test NG.
*new List<;string>;() {"hoge", "fuga", "hage"},
Test OK.
*new List<;string>;() {"hoge", "fuga"},
Test OK.
*new List<;string>;() {"HOGE", "FUGA"},
Test NG.
*new List<;string>;() {"hoge", "fuga", "hage"},
Test NG.
*new List<;string>;() {});
Test OK.
*new List<;string>;() {"hoge"});
Test NG.
*new List<;string>;() {null});
Test NG.
*new List<;string>;() {"A", "B", "C"});
Test OK.
*new List<;string>;() {"C", "B", "A"});
Test NG.
*new List<;string>;() {null, "A", "B"});
Test OK.
*new List<;string>;() {"A", "B", null});
Test NG.
*new ArrayList() {"A", "B", new Target()});
Test ArgumentException.
*new List<;string>;() {"C", "B", "A"},
Test OK.

*Debug.LogError("You Click Area");
※わかりやすいようにLogErrorにしてある
*{position_manager pm = new position_manager();pm.set_koma_select_position(this.gameObject.transform.parent.gameObject.transform.parent.gameObject , 4, 8);this.gameObject.transform.parent.gameObject.SetActive(false);Debug.LogError("You Click Area");}
クリックしたら親オブジェクトの駒を移動する
Hierarchy状のタグのついたオブジェクトをすべて格納
*GameObject[] tags = GameObject.FindGameObjectsWithTag(tag);
*foreach (GameObject t in tags)*{
すべてのタグを非表示にする
*{// Imageの取得Image image = this.GetComponent<;Image>;();// 0=透明 1=不透明なので、1.0で完全に不透明になるimage.color = new Color(1.0f, 0.1401087f, 0.0f, 0.3f);}
マウスが重なったら色を濃くする
Imageの取得
*Image image = this.GetComponent<;Image>;();
0=透明 1=不透明なので、1.0で完全に不透明になる
*image.color = new Color(1.0f, 0.1401087f, 0.0f, 0.3f);
*{// Imageの取得Image image = this.GetComponent<;Image>;();// 0=透明 1=不透明なので、1.0で完全に不透明になるimage.color = new Color(1.0f, 0.1401087f, 0.0f, 0.8f);}
マウスが外れたら色を戻す
Imageの取得
*Image image = this.GetComponent<;Image>;();
0=透明 1=不透明なので、1.0で完全に不透明になる
*image.color = new Color(1.0f, 0.1401087f, 0.0f, 0.8f);
*{position_manager pm = new position_manager();pm.set_koma_select_position(this.gameObject.transform.parent.gameObject.transform.parent.gameObject , 4, 8);this.gameObject.transform.parent.gameObject.SetActive(false);Debug.LogError("You Click Area");}
クリックしたら親オブジェクトの駒を移動する

*camera.AddCommandBuffer(CameraEvent.BeforeImageEffects, commandBuffer);*}
ImageEffects前(OnRenderImageが呼ばれる前)に適用
レンダリング結果を格納するテクスチャ作成
*var id = Shader.PropertyToID("_OutlineTex");
アウトラインを表示させたいメッシュの描画
*commandBuffer.ClearRenderTarget(false, true, Color.clear);
アウトラインを抽出して合成
*commandBuffer.Blit(id, BuiltinRenderTextureType.CameraTarget, outlineMaterial);

*[TestCase("^[0-9]{3}hoge[A-Z]{3}$", "ABChoge123")]
Test OK.

*line.Draw(settings);
描画
*public struct LineSettings {public Transform[] paths;public Color color;public float width;public float edgeMarkLength;public float insideMarkLength;public int intervalCount;public LineSettings(Transform[] paths,Color color,float width,float edgeMarkLength,float insideMarkLength,int intervalCount) {this.paths = paths;this.color = color;this.width = width;this.edgeMarkLength = edgeMarkLength;this.insideMarkLength = insideMarkLength;this.intervalCount = intervalCount;}}
設定パラメータ用のstruct
*private void InitMaterial() {if (!lineMaterial) {lineMaterial = new Material(Shader.Find("Hidden/Internal-Colored"));lineMaterial.hideFlags = HideFlags.HideAndDontSave;lineMaterial.SetInt(SrcBlend, (int) BlendMode.SrcAlpha);lineMaterial.SetInt(DstBlend, (int) BlendMode.OneMinusSrcAlpha);lineMaterial.SetInt(Cull, (int) CullMode.Off);lineMaterial.SetInt(ZWrite, 0);}}
描画するために使うマテリアルの初期化
*if (!enabled || settings.paths.Length <;= 0 || settings.paths.Any(t =>; t == null)) return;*IReadOnlyList;Vector3>; vecPaths = settings.paths.Select(t =>; t.position).ToList();
座標が入っていなかったら描画しない
*if (_settings.Equals(settings) &amp;&amp; _paths.SequenceEqual(vecPaths)) {*DotVertexes(currentPaths.ToArray());
設定が変更されていなかったら計算しない
*for (int index = 0; index <; _paths.Count - 1; index++) {v0 = _paths[index];v1 = _paths[index + 1];//２点の単位ベクトルを求めるo = (new Vector3(v1.y, v0.x, 0.0f) - new Vector3(v0.y, v1.x, 0.0f)).normalized;DrawLine2D(v0, v1, o);DrawMark2D(v0, v1, o);}
解像度に対する幅を求める
２点の単位ベクトルを求める
*o = (new Vector3(v1.y, v0.x, 0.0f) - new Vector3(v0.y, v1.x, 0.0f)).normalized;
*void DrawLine2D(Vector3 v0, Vector3 v1, Vector3 o) {Vector3 n = o * relativeWidth;Vector3[] vertex = new[] {new Vector3(v0.x - n.x, v0.y - n.y, 0.0f),new Vector3(v0.x + n.x, v0.y + n.y, 0.0f),new Vector3(v1.x + n.x, v1.y + n.y, 0.0f),new Vector3(v1.x - n.x, v1.y - n.y, 0.0f),};DotVertexes(vertex);foreach (Vector3 v in vertex) {currentPaths.Add(v);}}
２点に線を引く関数
*void DrawMark2D(Vector3 v0, Vector3 v1, Vector3 o) {Vector3 markLength, _v0, _v1, _o;Vector3 _unitVec = (v1 - v0) / settings.intervalCount;List<;Vector3>; _pos = new List<;Vector3>;();for (int i = 0; i <; settings.intervalCount + 1; i++) {_pos.Add(v0 + _unitVec * i);}for (int i = 0; i <; _pos.Count; i++) {Vector3 vec = _pos[i];float length = (i == 0 || i == _pos.Count - 1 ? settings.edgeMarkLength : settings.insideMarkLength);markLength = o * length;_v0 = new Vector3(vec.x - markLength.x, vec.y - markLength.y, 0.0f);_v1 = new Vector3(vec.x + markLength.x, vec.y + markLength.y, 0.0f);_o = (new Vector3(_v1.y, _v0.x, 0.0f) - new Vector3(_v0.y, _v1.x, 0.0f)).normalized;DrawLine2D(_v0, _v1, _o);}}
2点にメモリをつける関数
*void DotVertexes(Vector3[] pos) {foreach (Vector3 v in pos) {GL.Vertex3(v.x, v.y, v.z);}}
与えられた座標配列に頂点を打つ関数
*void DrawLine2D(Vector3 v0, Vector3 v1, Vector3 o) {//単位ベクトルに設定された幅をかけるVector3 n = o * relativeWidth;//オフセットを足して、頂点座標を求めるVector3[] vertex = new[] {new Vector3(v0.x - n.x, v0.y - n.y, 0.0f),new Vector3(v0.x + n.x, v0.y + n.y, 0.0f),new Vector3(v1.x + n.x, v1.y + n.y, 0.0f),new Vector3(v1.x - n.x, v1.y - n.y, 0.0f),};//描画する（自作関数）DotVertexes(vertex);}
垂直なベクトルを求め、正規化する
単位ベクトルに設定された幅をかける
*Vector3 n = o * relativeWidth;
*Vector3[] vertex = new[] {new Vector3(v0.x - n.x, v0.y - n.y, 0.0f),new Vector3(v0.x + n.x, v0.y + n.y, 0.0f),new Vector3(v1.x + n.x, v1.y + n.y, 0.0f),new Vector3(v1.x - n.x, v1.y - n.y, 0.0f),};
オフセットを足して、頂点座標を求める
描画する（自作関数）
*DotVertexes(vertex);

*yield break;
処理が終わったら破棄する
*{targetPos = target.position;}
Start is called before the first frame update
StartCor()を使ってMove.csのMoveToを開始
*other.GetComponent<;Move>;().StartCor(targetPos);

Web Appsの場合、接続文字列はApplication Settingsから取るのがおそらく一般的。
*string connectionstring = ConfigurationManager.AppSettings["connectionstring"];
blobが保存されるコンテナ名
*string containername = ConfigurationManager.AppSettings["containername"];
アップロードされたファイルを取得
*HttpPostedFile file = HttpContext.Current.Request.Files["userfile"];
もしコンテナが存在しなかった場合は作成
*container.CreateIfNotExists();
*CloudBlockBlob blob = container.GetBlockBlobReference($"{file.FileName}");
一意となるファイル名でblobに対しての参照を取得する
ファイルをアップロードする
*blob.UploadFromStream(fileStream);
Web Appsの場合、接続文字列はApplication Settingsから取るのがおそらく一般的。
*string connectionstring = ConfigurationManager.AppSettings["connectionstring"];
blobが保存されるコンテナ名
*string containername = ConfigurationManager.AppSettings["containername"];
ダウンロードするファイル名
*string filename = HttpContext.Current.Request["filename"];
必要なbyte配列の長さを取得するためには、取得したblobの参照に対してFetchAttributesを行う必要がある
*blob.FetchAttributes();
ここでもちいてるcontextは利用しているクラス(HandlerとかPageとか)に応じて適当なものを利用してください
*context.Response.BinaryWrite(filecontent);

*public List<;bool<; Rest
拘束の境界条件
*{for (int i = 0; i <; data.elems.Count; i++){Node[] nodes = new Node[2];nodes[0].No = data.elems[i].NodeNo1;nodes[0].Point = data.nodes[nodes[0].No - 1].Point;nodes[1].No = data.elems[i].NodeNo2;nodes[1].Point = data.nodes[nodes[1].No - 1].Point;int materialNo = data.elems[i].MaterialNo - 1;double area = data.materials[materialNo].Area;double young = data.materials[materialNo].Young;elems.Add(new BeamElement(nodes, area, young));}}
要素の形式を変換して格納する
拘束条件の形式を変換して格納する
変位
*List<;double>; disp = new List<;double>;();
*{// 例外処理if (Rest == null){return null;}if (NodeNum <;= 0 || BeamElems == null || Rest.Count != NodeNum){return null;}DenseMatrix kMatrix = DenseMatrix.Create(NodeNum, NodeNum, 0.0);// 各要素のKeマトリックスを計算し、Kマトリックスに統合するfor (int i = 0; i <; BeamElems.Count; i++){Console.WriteLine("要素" + (i + 1).ToString());DenseMatrix keMatrix = BeamElems[i].makeKeMatrix();for (int r = 0; r <; 2; r++){int rt = BeamElems[i].Nodes[r].No - 1;for (int c = 0; c <; 2; c++){int ct = BeamElems[i].Nodes[c].No - 1;kMatrix[rt, ct] += keMatrix[r, c];}}}Console.WriteLine("Kマトリックス");Console.WriteLine(kMatrix);// 境界条件を考慮して修正するForceVector = ForceVector - kMatrix * DispVector;for (int i = 0; i <; Rest.Count; i++){if (Rest[i] == true){for (int j = 0; j <; kMatrix.ColumnCount; j++){kMatrix[i, j] = 0.0;}for (int k = 0; k <; kMatrix.RowCount; k++){kMatrix[k, i] = 0.0;}kMatrix[i, i] = 1.0;ForceVector[i] = DispVector[i];}}Console.WriteLine("Kマトリックス(境界条件考慮)");Console.WriteLine(kMatrix);Console.WriteLine("荷重ベクトル(境界条件考慮)");Console.WriteLine(ForceVector);return kMatrix;}
Kマトリックスを作成する
*if (Rest == null)*{
例外処理
*for (int i = 0; i <; BeamElems.Count; i++)*{
各要素のKeマトリックスを計算し、Kマトリックスに統合する
境界条件を考慮して修正する
*ForceVector = ForceVector - kMatrix * DispVector;
*public void setBoundaryCondition(DenseVector dispvector, DenseVector forcevector, List<;bool>; rest)*{
境界条件を設定する
変位を計算する
*DispVector = (DenseVector)(kMatrix.Inverse().Multiply(ForceVector));
各要素の応力を計算する
*DenseVector dispElemVector = DenseVector.Create(2, 0.0);
*{if (AnalysisFlg != true){return;}StreamWriter sw = new StreamWriter("output.csv");// 節点変位を書き込むList<;Node>; nodes = new List<;Node>;();for(int i = 0; i <; BeamElems.Count; i++){for (int j = 0; j <; 2; j++){nodes.Add(BeamElems[i].Nodes[j]);}}nodes = nodes.Distinct().ToList();nodes.Sort((a,b) =>; a.No - b.No);sw.WriteLine("Node, Coordinate, Ux");for (int i = 0; i <; NodeNum; i++){sw.WriteLine((i + 1).ToString() + ", " + nodes[i].Point + ", " + DispVector[i]);}// 要素情報を書き込むsw.WriteLine("Element, X-Stress");for(int i = 0; i <; BeamElems.Count; i++){sw.WriteLine((i + 1).ToString() + "," + BeamElems[i].StressVector[0]);}sw.Close();}
結果を出力する
節点変位を書き込む
*List<;Node>; nodes = new List<;Node>;();
要素情報を書き込む
*sw.WriteLine("Element, X-Stress");
*{// 例外処理if (Area <;= 0){return null;}double length = Nodes[1].Point - Nodes[0].Point;double[,] bmatrixArray = new double[1, 2];bmatrixArray[0, 0] = -1.0 / length;bmatrixArray[0, 1] = 1.0 / length;return DenseMatrix.OfArray(bmatrixArray);}
Bマトリックスを計算する
*if (Area <;= 0)*{
例外処理
*{// Bマトリックスを計算するDenseMatrix BMatrix = makeBMatirx();Console.WriteLine("Bマトリックス");Console.WriteLine(BMatrix);// 例外処理if (BMatrix == null || Young <;= 0){return null;}double Volume = Area * (Nodes[1].Point - Nodes[0].Point);var keMatrix = Young * Volume * BMatrix.Transpose() * BMatrix;DenseMatrix KeMatrix = DenseMatrix.OfColumnArrays(keMatrix.ToColumnArrays());Console.WriteLine("Keマトリックス");Console.WriteLine(KeMatrix);return KeMatrix;}
Keマトリックスを計算する
Bマトリックスを計算する
*DenseMatrix BMatrix = makeBMatirx();
*if (BMatrix == null || Young <;= 0)*{
例外処理
*{DenseMatrix bMatrix = makeBMatirx();StrainVector = (DenseVector)bMatrix.Multiply(dispvector);Console.WriteLine("ひずみベクトル");Console.WriteLine(StrainVector);}
ひずみベクトルを計算する
*{if (StrainVector == null || Young <;= 0){return;}StressVector = Young * StrainVector;Console.WriteLine("応力ベクトル");Console.WriteLine(StressVector);}
応力ベクトルを計算する

多重起動
*return;

*player = ConvertExtension.ChangeType<;Player<;(data[nameof(player)])
nullableなMapデータをPlayerに変換する

子要素クラスを使用して配列を作成
*public ChildArray[] array;
シリアライズされた子要素クラス
*[System.Serializable]

*.WithConnectionString("couchbase:
localhost")
戻り値のドキュメントに対する処理
*}
Taskリストの初期化
*var tasks = new List<;Task>;();
*for (var i = 0; i <;100; i++)*{
同期的にタスクを作成し、リストに格納（これらのタスクはまだスケジュールされていません）
リスト中の全てのタスクの完了を待つ
*await Task.WhenAll(tasks);
*foreach (var task in tasks)*{
リストから順次、結果を受け取る

*app.UseAuthentication();
認証ミドルウェアの追加

*string[] args1 = {"りんご", "バナナ", "オレンジ"};
Test OK.
*List<;string>; list1 = new List<;string>;(){ "りんご", "バナナ", "オレンジ"};
Test OK.
*string[] args1 = {"りんご", "バナナ", "オレンジ"};
Test NG.

*driver.Navigate().GoToUrl("https:
www.google.co.jp");

*DMatch[] matches;
特徴量ベクトル同士のマッチング結果を格納する配列
画像をグレースケールとして読み込む
*Mat Lsrc = new Mat(sLeftPictureFile, ImreadModes.Color);
画像をグレースケールとして読み込む
*Mat Rsrc = new Mat(sRightPictureFile, ImreadModes.Color);
特徴量の検出と特徴量ベクトルの計算
*akaze.DetectAndCompute(Lsrc, null, out keyPointsLeft, descriptorLeft);
画像1の特徴点をoutput1に出力
*Cv2.DrawKeypoints(Lsrc, keyPointsLeft, tokuLeft);
画像2の特徴点をoutput1に出力
*Cv2.DrawKeypoints(Rsrc, keyPointsRight, tokuRight);
総当たりでマッチング
*matcher = DescriptorMatcher.Create("BruteForce");
SrcをTargetにあわせこむ変換行列homを取得する。ロバスト推定法はRANZAC。
*var hom = Cv2.FindHomography(
行列homを用いてSrcに射影変換を適用する。
*Mat WarpedSrcMat = new Mat();
左右両方の画像を各チャンネルごとに分割
*Mat LmatFloat = new Mat();
*Cv2.Absdiff(LmatPlanes[0], RmatPlanes[0], diff0);*Cv2.Absdiff(LmatPlanes[1], RmatPlanes[1], diff1);
分割したチャンネルごとに差分を出す
*Cv2.MedianBlur(diff0, diff0, 5);*Cv2.MedianBlur(diff1, diff1, 5);
ブラーでノイズ除去
オープニング処理でノイズ緩和
*Mat openingMat = new Mat();
スレッショルドで差分をきれいにくっきりと
*Mat dilationMat = new Mat();
dilationMatはグレースケールなので合成先のMatと同じ色空間に変換する
*Mat dilationScaleMat = new Mat();
元画像 3:差分画像 7 で合成
*Cv2.AddWeighted(WarpedSrcMat, 0.3, dilationColorMat, 0.7, 0, LaddMat);

フォーム呼び出しで作成するボタン(Windowsフォームのボタン - Buttonを継承する)
*private Kazumi75Button[] manyButtons;
フォーム呼び出しで作成するテキストボックスとその識別名
*private TextBox[] manyTextBoxes;
配列の要素数(ここでは8個)
*private const int ElementNum = 8;
*private void formCallButton_Click(object sender, EventArgs e)*{
フォームを呼び出すボタン
ボタンの各メッセージはここであらかじめ設定する
*string[] msgs = new string[ElementNum];
テキストボックスの各識別名はここであらかじめ設定する
*this.txtbxNm = new string[ElementNum];
ボタン(Windowsフォームのボタンを継承する)とテキストボックスの作成
*this.manyButtons = new Kazumi75Button[ElementNum];
*for (int i = 0; i <; this.manyButtons.Length; i++)*{
ボタンとテキストボックスの各要素に対するプロパティ設定とフォーム配置
インスタンス作成
*this.manyButtons[i] = new Kazumi75Button();
ボタンの名前とテキストのプロパティを設定
*this.manyButtons[i].Name = "OriginalButton" + i;
テキストボックスの名前とテキストのプロパティを設定
*this.manyTextBoxes[i].Name = txtbxNm[i];
ボタンクリック時に参照するリストボックスを指定
*this.manyButtons[i].targetLbox = listBox1;
ボタンクリック時のメッセージを設定
*this.manyButtons[i].buttonMsg = msgs[i];
ボタンのサイズと配置
*this.manyButtons[i].Size = new Size(100, 20);
テキストボックスのサイズと配置
*this.manyTextBoxes[i].Size = new Size(150, 20);
フォームへの追加
*this.Controls.Add(this.manyButtons[i]);
クリック時のボタンごとのイベント動作を作成する
*this.manyButtons[i].eventMaking();
フォーム呼び出し後は、テキストボックスの内容確認ボタンを有効化する
*buttonCheckEntry.Enabled = true;
*{StringBuilder sb = new StringBuilder();// テキストボックスを識別名で探し、その内容を取得するfor (int i = 0; i <; ElementNum; i++){sb.Append("[" + i + "]");// フォーム上の識別名に該当するコントロールを探すControl[] txtboxctrls = this.Controls.Find(this.txtbxNm[i], false);for (int j = 0; j <; txtboxctrls.Length; j++){// 取得したテキストボックスの内容を文字列取得TextBox tbox = (TextBox)txtboxctrls[j];sb.Append(tbox.Text);}// 最終要素以外の場合は「/」で区切るif (i <; ElementNum - 1){sb.Append(" / ");}}// メッセージを表示するMessageBox.Show("入力したものは…" + sb.ToString() + " です。");}
動的に呼び出したテキストボックスの内容を確認するボタン
*for (int i = 0; i <; ElementNum; i++)*{
テキストボックスを識別名で探し、その内容を取得する
フォーム上の識別名に該当するコントロールを探す
*Control[] txtboxctrls = this.Controls.Find(this.txtbxNm[i], false);
取得したテキストボックスの内容を文字列取得
*TextBox tbox = (TextBox)txtboxctrls[j];
*if (i <; ElementNum - 1)*{
最終要素以外の場合は「/」で区切る
メッセージを表示する
*MessageBox.Show("入力したものは…" + sb.ToString() + " です。");
配列の要素数(ここでは11個)
*private const int ElementNum = 11;

*public void eventMaking()
Kazumi75Button.cs
*{this.targetLbox.Items.Add(this.buttonMsg);}
クリックイベントの実体(参照するリストボックスに文言テキストを追加)
配列の要素数(ここでは8個)
*private const int ElementNum = 8;

*{public string Name { get; set; }public string Attribute { get; set; }public int Status { get; set; }}
武器のステータスを格納するクラス
*{new weapon_status{Name = "どうの剣",Attribute = "なし",Status = 10},new weapon_status{Name = "はがねの剣",Attribute = "なし",Status = 50},new weapon_status{Name = "炎の剣",Attribute = "火",Status = 100},new weapon_status{Name = "ドラゴンの剣",Attribute = "竜",Status = 150},};
武器のリストを作成
攻撃力が100以上のものを、強武器としてStrong_Weaponsに格納
*var Strong_Weapons = weapons.Where(x =>; x.Status >;= 100);
Strong_Weaponsを表示する
炎の剣 , 火属性
ドラゴンの剣, 竜属性 ←のように表示される
*foreach (var item in Strong_Weapons)
*weapons.Add(new weapon_status { Name = "伝説の剣", Attribute = "光", Status = 255 });
武器のリストに新しく１つの武器を追加
Weaponsに武器を追加しただけなので、Strong_Weaponsを表示するときは
炎の剣 , 火属性
ドラゴンの剣, 竜属性 ←をのように表示される、はず？
*foreach (var item in Strong_Weapons)
攻撃力が100以上のものを、強武器とする
*var Strong_Weapons = weapons.Where(x =>; x.Status >;= 100);
攻撃力が100以上のものを、強武器とする
*var Strong_Weapons = weapons.Where(x =>; x.Status >;= 100).ToArray();

*static void makeDB(){using(var db=new SqliteConnection("Data Source=../sqlitest.db")){db.Open();var sql=db.CreateCommand();sql.CommandText=@"CREATE TABLE IF NOT EXISTS DMCARDS (ID INTEGER PRIMARY KEY AUTOINCREMENT,NAME TEXT,COLOR TEXT,COST INTEGER,POWER INTEGER)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('ラ・ウラ・ギガ','光',1,2000)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('アクア・ガード','水',1,2000)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('ボーン・スライム','闇',1,1000)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('ブレイズ・クロー','火',1,1000)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('スナイプ・モスキート','自然',1,2000)";sql.ExecuteNonQuery();}}
データベース(テーブル)を初期化
*static void updateDB(){using(var db=new SqliteConnection("Data Source=../sqlitest.db")){db.Open();var sql=db.CreateCommand();sql.CommandText="UPDATE DMCARDS SET COLOR='白' WHERE COLOR='光'";sql.ExecuteNonQuery();sql.CommandText="UPDATE DMCARDS SET COLOR='青' WHERE COLOR='水'";sql.ExecuteNonQuery();sql.CommandText="UPDATE DMCARDS SET COLOR='黒' WHERE COLOR='闇'";sql.ExecuteNonQuery();sql.CommandText="UPDATE DMCARDS SET COLOR='赤' WHERE COLOR='赤'";sql.ExecuteNonQuery();sql.CommandText="UPDATE DMCARDS SET COLOR='緑' WHERE COLOR='自然'";sql.ExecuteNonQuery();}}
データベースを変更
*static void dropDB(){using(var db=new SqliteConnection("Data Source=../sqlitest.db")){db.Open();var sql=db.CreateCommand();sql.CommandText="DROP TABLE IF EXISTS DMCARDS";sql.ExecuteNonQuery();}}
データベースを削除
*static void viewDB(){using(var db=new SqliteConnection("Data Source=../sqlitest.db")){db.Open();var sql=db.CreateCommand();sql.CommandText="SELECT * FROM DMCARDS";using(var row=sql.ExecuteReader()){Console.WriteLine("ID,NAME,COLOR,COST,POWER");while(row.Read()){Console.WriteLine($"{row["ID"]},{row["NAME"]},{row["COLOR"]},{row["COST"]},{row["POWER"]}");}}}}
データベースを表示

*element.Focus();
フォーカスを当てる

*//{//    endpoints.MapGet("/", async context =>;//    {//        context.Response.ContentType = "text/html";//        await context.Response.WriteAsync("<;html>;<;title>;ButterflyFishList<;/title>;<;/head>;");//        await context.Response.WriteAsync("<;body>;<;h1>;Chaetodontidae<;/h1>;");//        await context.Response.WriteAsync("<;i>;Chelmon rostratus<;/i>;");//        await context.Response.WriteAsync("<;i>;   Chaetodon daedalma<;/i>;");//        await context.Response.WriteAsync("<;/body>;<;/html>;");//    });//});
app.UseEndpoints(endpoints =&gt;
*//    {//        context.Response.ContentType = "text/html";//        await context.Response.WriteAsync("<;html>;<;title>;ButterflyFishList<;/title>;<;/head>;");//        await context.Response.WriteAsync("<;body>;<;h1>;Chaetodontidae<;/h1>;");//        await context.Response.WriteAsync("<;i>;Chelmon rostratus<;/i>;");//        await context.Response.WriteAsync("<;i>;   Chaetodon daedalma<;/i>;");//        await context.Response.WriteAsync("<;/body>;<;/html>;");//    });
{
*//    {//        context.Response.ContentType = "text/html";//        await context.Response.WriteAsync("<;html>;<;title>;ButterflyFishList<;/title>;<;/head>;");//        await context.Response.WriteAsync("<;body>;<;h1>;Chaetodontidae<;/h1>;");//        await context.Response.WriteAsync("<;i>;Chelmon rostratus<;/i>;");//        await context.Response.WriteAsync("<;i>;   Chaetodon daedalma<;/i>;");//        await context.Response.WriteAsync("<;/body>;<;/html>;");//    });
endpoints.MapGet("/", async context =&gt;

*{private int value1private int value2public void method1(int a, int b){this.value1 = a;this.value2 = b;}}
クラスの定義
デリゲート(関数を参照する変数の型…引数や戻り値の型の定義)
*public delegate void MyDelegate(string s);
クラスのインスタンス作成の仕方
*SomeClass class1 = new SomeClass();
デリゲートのインスタンス(関数そのものを参照するインスタンス)の作成は…
*MyDelegate dgref1 = new MyDelegate(Console.WriteLine);
2値を計算するメソッドデリゲート型の定義
*delegate double Culc2(int a, int b);
*{Console.WriteLine("Hello Ramda!");// 2値計算メソッドデリゲート変数「culc2Test」を定義する。ここではplus(a,b)を使うCulc2 culc2Test = new Culc2(plus);// デリゲート変数に格納されたメソッドを呼び出すdouble testnum = culc2Test(24, 33);Console.WriteLine("答えは" + testnum + "です。");}
メイン関数(プログラム開始)
2値計算メソッドデリゲート変数「culc2Test」を定義する。ここではplus(a,b)を使う
*Culc2 culc2Test = new Culc2(plus);
デリゲート変数に格納されたメソッドを呼び出す
*double testnum = culc2Test(24, 33);
*{return (double)a + (double)b;}
足し算
*{return (double)a - (double)b;}
引き算
*{return (double)a * (double)b;}
掛け算
*{if (b == 0){return -9999999999999999999.9;}else{return (double)a / (double)b;}}
割り算
*{int result = 1;for (int i = 0; i <; b; i++){result *= a;}return (double)result;}
aのb乗
2値を計算するメソッドデリゲート型の定義
*delegate double Culc2(int a, int b);
*{Console.WriteLine("Hello Ramda!");// 2値計算メソッドデリゲート配列「culc2tests」を定義する。5種類の計算をするため、5要素配列で定義するCulc2[] culc2tests = new Culc2[5];culc2tests[0] = new Culc2(plus);culc2tests[1] = new Culc2(minus);culc2tests[2] = new Culc2(mltpl);culc2tests[3] = new Culc2(divide);culc2tests[4] = new Culc2(pow2);// 5種類の計算を表示するfor (int i = 0; i <; 5; i++){double result = culc2tests[i](2, 7);Console.WriteLine("結果：" + result);}}
メイン関数(プログラム開始)
2値計算メソッドデリゲート配列「culc2tests」を定義する。5種類の計算をするため、5要素配列で定義する
*Culc2[] culc2tests = new Culc2[5];
*for (int i = 0; i <; 5; i++)*{
5種類の計算を表示する
*{return (double)a + (double)b;}
足し算
*{return (double)a - (double)b;}
引き算
*{return (double)a * (double)b;}
掛け算
*{if (b == 0){return -9999999999999999999.9;}else{return (double)a / (double)b;}}
割り算
*{int result = 1;for (int i = 0; i <; b; i++){result *= a;}return (double)result;}
aのb乗
2値を計算するメソッドデリゲート型の定義
*delegate double Culc2(int a, int b);
*{Console.WriteLine("Hello Ramda!");// 2値計算メソッドデリゲート配列「culc2tests」を定義する。6種類の計算をするため、6要素配列で定義するCulc2[] culc2tests = new Culc2[6];culc2tests[0] = new Culc2(plus);culc2tests[1] = new Culc2(minus);culc2tests[2] = new Culc2(mltpl);culc2tests[3] = new Culc2(divide);culc2tests[4] = new Culc2(pow2);// デリゲート配列6要素目は、匿名関数(ラムダ式)で、bのaに対する対数関数(log)計算を定義するculc2tests[5] = (int a, int b) =>;{// log(b)_base:a を計算するreturn Math.Log((double)b, (double)a);};// 5種類の計算を表示するfor (int i = 0; i <; 6; i++){double result = culc2tests[i](2, 7);Console.WriteLine("結果：" + result);}}
メイン関数(プログラム開始)
2値計算メソッドデリゲート配列「culc2tests」を定義する。6種類の計算をするため、6要素配列で定義する
*Culc2[] culc2tests = new Culc2[6];
*{// log(b)_base:a を計算するreturn Math.Log((double)b, (double)a);};
デリゲート配列6要素目は、匿名関数(ラムダ式)で、bのaに対する対数関数(log)計算を定義する
log(b)_base:a を計算する
*return Math.Log((double)b, (double)a);
*for (int i = 0; i <; 6; i++)*{
5種類の計算を表示する
*{return (double)a + (double)b;}
足し算
*{return (double)a - (double)b;}
引き算
*{return (double)a * (double)b;}
掛け算
*{if (b == 0){return -9999999999999999999.9;}else{return (double)a / (double)b;}}
割り算
*{int result = 1;for (int i = 0; i <; b; i++){result *= a;}return (double)result;}
aのb乗
log(b)_base:a を計算する
*return Math.Log((double)b, (double)a);
log(b)_base:a を計算する
*return Math.Log((double)b, (double)a);
対数関数の値のreturnの1行だけであれば、以下の省略型も可
*culc2tests[5] = (int a, int b) =>; Math.Log((double)b, (double)a);

*string data = selectResult.GetString(1);
カラムインデックスでのアクセス
*res += String.Format("{0}${1}\n", name, data);
ここでいい感じに処理
結果を閉じる
*selectResult.Close();

*public string LastName
普通はフィールド名からいい感じにプロパティ名作る
FullName プロパティに AutoNotify がついてるので、FullName プロパティで参照しているプロパティが変更されたときに自動で変更通知とばす
*PropertyChanged?.Invoke(this, FullNamePropertyChangedEventArgs);

*throw new 例外クラス(例外オブジェクトの詳細メッセージ);
メッセージは省略可
*catch (Exception e) {例外処理throw;}
呼び出されたメソッド内の例外ハンドラから呼び出し元に再度例外を投げる(例外の再throw)

*{public DiagnosticSource _D = new DiagnosticListener("Diag1");public void A(){if(_D.IsEnabled("ev1")){_D.Write("ev1", new { X = "str" });}}}
using System.Diagnostics;
1秒に一回"ev1"イベントが発生する
*new C1().A();

弾が当たったときの処理を以下に書く
*Debug.Log("Point!");
*public int[] fruitCount = { 0, 0, 0, 0,0 };
0番目がリンゴ、１番目がニンジン、２番目がバナナ、３番目がすいか
終了処理
*ResultMethod();
*//clickPos.z = transform.position.z + transform.forward.z * 1000;*//Vector3 dir = clickPos - bulletEnter.position;
Vector3 clickPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
弾が当たったときの処理
*Debug.Log("Point!");
終了処理
*ResultMethod();
ここからは弾の発射部分
*,,,
弾が当たったときの処理
*Debug.Log("Point!");

SSL通信の許可設定
これをやっとかないと、SSL(https)通信でエラーが発生する。
*System.Net.ServicePointManager.SecurityProtocol = System.Net.SecurityProtocolType.Tls11 | System.Net.SecurityProtocolType.Tls12;
Azureへ接続準備：接続情報の設定
*StorageSharedKeyCredential credential = new StorageSharedKeyCredential(accountName, accessKey);
Azureへ接続
*ShareClient share = new ShareClient(serverurl ,  credential);
Upload先(azure側)にフォルダがなければ作成。
*directory.CreateIfNotExists();
Upload先(azure側)にファイルインスタンスを作成。
*ShareFileClient file = directory.GetFileClient(azureFileName);
同名のファイルがあったら削除
*file.DeleteIfExists();
Upload対象のLocalファイルを開く。FileStream型で開くとバイナリ情報の取得が楽。
*FileStream stream = File.OpenRead( Path.Combine(localDirectoryPath , localFileName ) );
Upload先(azure側)にファイルインスタンスにバイナリ情報を注入
*file.Create(stream.Length);
ローカルファイルの開放
*stream.Dispose();

oddsの確率分布から、rの値に対応するインデックスを返す
*}
*public static int BinarySearchInOdds(double[] odds, double r) {if (r <; 0) return -1;if (odds.Length == 0) return -1;// 確率分布の部分和をあらかじめ求めておくdouble[] sum_from_left = new double[odds.Length];double[] sum_from_right = new double[odds.Length];double odd_total = odds.Sum();sum_from_left[0] = 0;sum_from_right[0] = odd_total;for (int i = 1; i <; odds.Length; i++) {sum_from_left[i] = sum_from_left[i-1] + odds[i-1];sum_from_right[i] = sum_from_right[i-1] - odds[i-1];}int left = 0;int right = odds.Length - 1;int mid = left + (right - left) / 2;double L_mid = sum_from_left[mid];while (right >;= left) {double R_mid = L_mid + odds[mid];if ((L_mid <;= r &amp;&amp; r <; R_mid) || (r == R_mid &amp;&amp; mid == odds.Length - 1)) {// キーがmid番目の要素の範囲内にある場合return mid;} else if (r <; L_mid) {// キーがmid番目の要素の範囲より小さい範囲にある場合right = mid - 1;mid = left + (right - left) / 2;R_mid = L_mid - (odd_total - sum_from_left[mid + 1] - sum_from_right[right + 1]);L_mid = R_mid - odds[mid];} else {// キーがmid番目の要素の範囲より大きい範囲にある場合left = mid + 1;mid = left + (right - left) / 2;if (mid >;= odds.Length) break;L_mid = R_mid + (odd_total - sum_from_left[left] - sum_from_right[mid]);R_mid = L_mid + odds[mid];}}return -1;}
確率分布の中で、 rに対応する要素のインデックスを返す
確率分布の部分和をあらかじめ求めておく
*double[] sum_from_left = new double[odds.Length];
*} else if (r <; L_mid) {
キーがmid番目の要素の範囲内にある場合
キーがmid番目の要素の範囲より小さい範囲にある場合
*right = mid - 1;
キーがmid番目の要素の範囲より大きい範囲にある場合
*left = mid + 1;
*public static int Draw(double[] odds) {Random rnd = new Random();double r = rnd.NextDouble() * odds.Sum();return BinarySearchInOdds(odds, r);}
確率分布にしたがって、ランダムに決定した要素のインデックスを返す
rがちょうど境目にある時、大きいほうのインデックスが返ってくる
*Console.WriteLine("r = 0.5  --->;  " + BinarySearchInOdds(odds1, 0.5));
rが確率分布の合計と等しい場合、最後の要素のインデックスが返ってくる
*Console.WriteLine("r = 8.0  --->;  " + BinarySearchInOdds(odds1, 8.0));
rが範囲外の場合、-1が返ってくる
*Console.WriteLine("r = 10.0  --->;  " + BinarySearchInOdds(odds1, 10.0));
rが負の場合も同様
*Console.WriteLine("r = -1.0  --->;  " + BinarySearchInOdds(odds1, -1.0));
確率分布の要素が1つでも問題ない
*Console.WriteLine("r = 0.0  --->;  " + BinarySearchInOdds(odds2, 0.0));
確率分布の要素がない場合、-1が返ってくる
*Console.WriteLine("odds3 = [" + string.Join(", ", odds3) + "]");
*for (int i = 0; i <; 1000000; i++) {int received = Draw(odds4);receivedCounts[received]++;}
100万回ガチャを引いて、排出確率を調べてみる

*string path = @"C:\Users\hogehoge\Desktop\";
ファイルの置き場所を記載
クラス名、項目名を取得
*string[] sourceWords = sourceCode[i].Trim().Substring(6).Split(' ');
*if (sourceCode[i].Trim().Equals("End"))*{
終了時
*if (list階層.Count <;= 0)*{
階層なし=データ無し
対象行の前後の空白と2つ以上続く空白を全て削除し、1つの空白しか残らないようにする
*string sourceWord = sourceCode[i].Trim();
*if (CheckData(sourceWord, "TabIndex ="))*{
TabIndexの取得
*if (CheckData(sourceWord, "Index ="))*{
Indexの取得
*if (CheckData(sourceWord, "Tag ="))*{
Tagの取得
*if (CheckData(sourceWord, "Top ="))*{
Topの取得
ファイル出力
*DateTime dtNow = DateTime.Now;
*if (list1 == null || list2 == null)*{
どちらかがNULLの場合
*if (!list1.Count.Equals(list2.Count))*{
件数が不一致の場合
*for (int i = 0; i <; list1.Count; i++)*{
値が不一致の場合

Windows 名前空間で始まるクラスが使える！？
*using Windows.Media.Capture;
カメラから画像取り込んで表示
*using var c = new MediaCapture();

チャンネルアクセストークンを変数へ格納
*var channelAccessToken = System.Environment.GetEnvironmentVariable("CHANNEL_ACCESS_TOKEN");
*{messages = new List<;Message>;(){new Message(){type="text",text=mm + "月"+ dd　+"日の"+ HH + "時になりました。本日のタスクは完了していますか？"}}};
リプライメッセージ作成
リプライメッセージをシリアライズ
*string json = JsonConvert.SerializeObject(rm, Formatting.Indented);
Line Messaging APIへのリクエストを作成する
var apiUrl = "https:api.line.me/v2/bot/message/broadcast";
*var req = new HttpRequestMessage(HttpMethod.Post, apiUrl);
*req.Headers.Add(@"Authorization", @"Bearer {" + channelAccessToken + "}");
ヘッダーにチャンネルアクセストークンを追加する
リクエストをJSON形式にシリアライズする
*req.Content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");
*{var response = await client.SendAsync(req);log.LogInformation($"{response}");}
リクエストを送信する

frameはtexture情報をバイナリで保持している独自クラス
*var texture2D = new Texture2D(frame.Width, frame.Height, TextureFormat.RGBA32, false);
これを追加した
*Destroy(material.mainTexture);

*blockingCollection.Add(command);
blocked if it reach the capacity
*if (blockingCollection.TryAdd(command, TimeSpan.FromSeconds(1)))*{
blockingCollection.Add(command);    blocked if it reach the capacity

*else if (num % 2 == 0) return false;
偶数はあらかじめ除く
素数ではない
*return false;
素数である
*return true;
*{if (judge(num) == true)return $"あなたが入力した数値：{num}は{category}です。";elsereturn $"あなたが入力した数値：{num}は{category}ではありません。";}
入力値の判定結果（文言）を返すメソッド
*{return num % 2 == 0;}
偶数ならTrueを返すメソッド
*{if (judge(num) == true)return $"あなたが入力した数値：{num}は{category}です。";elsereturn $"あなたが入力した数値：{num}は{category}ではありません。";}
入力値の判定結果（文言）を返すメソッド
*{if (judge(num) == true)return $"あなたが入力した数値：{num}は{category}です。";elsereturn $"あなたが入力した数値：{num}は{category}ではありません。";}
入力値の判定結果（文言）を返すメソッド

*string[] pokemons = new string[] { "ピカチュウ", "カイリュー", "ヤドラン", "ピジョン", "コダック", "コラッタ" };
手持ちポケモン作成
*string[] types = new string[] { "でんき", "ドラゴン", "みず", "ひこう", "みず", "ノーマル" };
手持ちポケモンのタイプ。上の配列と同じ要素番号で管理。TODO:複合タイプ
*int[] levels = new int[] { 50, 62, 28, 57, 78, 18 };
手持ちポケモンのレベル。上の配列と同じ要素番号で管理。
以下、諸々の処理を頑張って書く・・・
*}
割愛
*protected int syuzokuMaxHP;
この式はホンモノじゃないよ
*return (int)Math.Floor((decimal)(syuzokuMaxHP + kotaichiMaxHP) * 2 + (decimal)(Level / 100)) + Level + 10;
レベル
*Level = level;
個体値。初代は0～15の範囲でランダムに決定する
*Random r = new System.Random();
*{}
コンストラクタ追加
やせいの プリンが とびだしてきた！ ----------------------------------------------------
1体目：レベル3のプリン
*Purin purin1 = new Purin(3);
2体目：レベル5のプリン
*Purin purin2 = new Purin(5);
3体目：レベル7のプリン
*Purin purin3 = new Purin(7);
*if(string.IsNullOrEmpty(Waza1) || string.IsNullOrEmpty(Waza2) || string.IsNullOrEmpty(Waza3) || string.IsNullOrEmpty(Waza4))*{
技を覚えている数が3つ以下の場合、技をセットして終了
setWazaメソッド：新しい技をセット
*setWaza(wazaName);
技が4つの場合、プレイヤーに技を忘れさせるか確認する
askForgetWazaメソッド：技を忘れさせるか確認
忘れさせない場合、終了する
*if (!askForgetWaza(wazaName))
忘れさせる場合、プレイヤーに忘れさせる技を選択させる
selectForgetWazaメソッド：忘れさせる技を選択して忘れさせる
*selectForgetWaza(wazaName);
setWazaメソッド：新しい技をセット
*setWaza(wazaName);
ヌケニンのHPは常に1
*return 1;

*{foreach (TSource element in source) {yield return selector (element);}}
外側の関数の引数や変数をキャプチャできる
C# 8.0から使える
staticがついていると静的ローカル関数
外側の関数の引数や変数のキャプチャを許さない
*static IEnumerable<;TResult>; Impl(IEnumerable<;TSource>; source_, Func<;TSource,TResult>; selector_)
略
*yield break;
略
*yield break;

*// For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940*public void ConfigureServices(IServiceCollection services)
This method gets called by the runtime. Use this method to add services to the container.
*{}
For more information on how to configure your application, visit https:go.microsoft.com/fwlink/?LinkID=398940
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}app.UseRouting();app.UseEndpoints(endpoints =>;{endpoints.MapGet("/", async context =>;{await context.Response.WriteAsync("Hello World!");});});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

標準入力から読み込み
*int N = cin;
標準出力へ書き出し
*Console.WriteLine(N);

データセットのルートディレクトリを指定（必須）
*DumbAssertConfig.TestDataBaseDir = /*データセットのルートディレクトリ*/;
エンコーディングを指定（デフォルトはUTF-8）
*DumbAssertConfig.Encoding = Encoding.GetEncoding("UTF-8");
*DumbAssertConfig.DeleteBeforeInsert = true;*// NULLの代替文字列を指定（デフォルトは";NULL>;"）
前提データ投入前にデータを削除（デフォルトはtrue）
NULLの代替文字列を指定（デフォルトは"&lt;NULL&gt;"）
*DumbAssertConfig.NullString = "<;NULL>;";
DateTimeの文字列表現パターンを指定
※ToStringのパラメタ（デフォルトは"yyyy-MM-dd HH:mm:ss.fff"）
*DumbAssertConfig.DateTimePattern = "yyyy-MM-dd HH:mm:ss.fff";
生成されるSQLのカラム名をダブルクォートでクォートするか（デフォルトはtrue）
*DumbAssertConfig.QuoteColumnName = true;
改行コード
（デフォルトはEnvironment.NewLine ※WindowsならCRLF、Mac/LinuxならLF）
*DumbAssertConfig.NewLine = Environment.NewLine;

*month = month - 1;
旧暦月の補正
干支（天干、地支）
*int sy = jlc.GetSexagenaryYear(newDate);
六曜(大安・赤口・先勝・友引・先負・仏滅)
(月 + 日) % 6 の余り
*int rokuyo = (month + day) % 6;

*trans.Rollback();
例外発生時はロールバック

*ThreadId = ChatThreadClient.Id,
ThreadId も返す
*{// Configure メソッド使いたかったけど何回試しても動かなかったので泣く泣く…var c = sp.GetRequiredService<;IConfiguration>;();return new CommunicationServiceSettings{Endpoint = c[nameof(CommunicationServiceSettings)]};});
設定を読み込み
Configure メソッド使いたかったけど何回試しても動かなかったので泣く泣く…
*var c = sp.GetRequiredService<;IConfiguration>;();
*{var res = await _http.GetStringAsync("/api/GetToken");_getTokenResponse = JsonSerializer.Deserialize<;GetTokenResponse>;(res);_chatClient = new ChatClient(new Uri(_communicationServiceSettings.Endpoint),new CommunicationUserCredential(_getTokenResponse.Token));_chatThreadClient =  _chatClient.GetChatThreadClient(_getTokenResponse.ThreadId);}
チャットに参加
*{await _chatThreadClient.SendMessageAsync(message, senderDisplayName: name);}
チャットにメッセージを送信
チャットのメッセージを取得
*public IAsyncEnumerable<;ChatMessage>; GetMessagesAsync() =>; _chatThreadClient.GetMessagesAsync();

ジェネリック自体の型を取得
*t.MakeGenericType(指定したい型のType);
ジェネリック自体の型を取得
*Type t2 = t.MakeGenericType(指定したい型のType);

*public DbSet<;CompanyData<; CompanyStockPrice{get;set;}
このプロパティ名がテーブル名と一致してないとダメ
*{Console.WriteLine($"業種コード「{target}」の株価Top{tops}");// post SQL querycontext.CompanyStockPrice.FromSqlRaw("SELECT * FROM CompanyStockPrice"+ " WHERE IndustryCode = {0}"+ " ORDER BY StockPrice DESC"+ " LIMIT {1}", target, tops).ToList().ForEach(com =>; Console.Write($"[{com.StockCode}]{com.CompanyName} 株価={com.StockPrice}\n"));}
~~~~[中略]~~~~

略
*yield break;
*// return や { や }がいらない
式形式で記述
return や { や }がいらない
*public Coroutine Launch() =>; StartCoroutine(LaunchImpl());
略
*yield break;
フィールドをそのまま返すのにも使える
*public float X =>; x;
ロジックを記述したプロパティにも使える
*public float Area =>; Mathf.PI * radius * radius;
*public override string ToString() =>; $"Center ({X},{Y}) Radius:{Radius}";
ToStringの実装にも使える
内部的にはこんな感じ
バリュータプルを使っているけど、内部的にはバリュータプルは生成されませんhttps:sharplab.io/#v2:EYLgtghgzgLgpgJwDQBMQGoA+ABATARgFgAoE7AZgAI9KAFAewEsA7GSgbxMu+qpbYAaHSgHM4MANyUAvlx4VK/SgE1hYyTLnctvOk1YAKJQA8ki1pQCeASkoBeAHyUDAs8tt3npq9YklZxEA===
public class Point
{
[CompilerGenerated]
[DebuggerBrowsable(DebuggerBrowsableState.Never)]
private readonly int &lt;X&gt;k__BackingField;

[CompilerGenerated]
[DebuggerBrowsable(DebuggerBrowsableState.Never)]
private readonly int &lt;Y&gt;k__BackingField;

public int X
{
[CompilerGenerated]
get
{
return &lt;X&gt;k__BackingField;
}
}

public int Y
{
[CompilerGenerated]
get
{
return &lt;Y&gt;k__BackingField;
}
}

public Point(int x, int y)
{
&lt;X&gt;k__BackingField = x;
&lt;Y&gt;k__BackingField = y;
}
}
*,,,

*var service = provider.GetService<;IAppService<;();
IAppService型のサービスを取得

*if (service.Name == name) {
プロパティでサービスを判定

(ここから)実務ではDBから取得したデータをBindするが、サンプルなので、データを自作
*DataTable table = new DataTable();
(ここまで)実務ではDBから取得したデータをBindするが、サンプルなので、データを自作
C#側は、DataGridオブジェクトにデータを設定して、Bindするだけ。
*grd01.DataSource = table;

enumを利用したほうがわかりやすいと思いますが、今回はintで分岐処理を行います。
type = 0: DirectSound
type = 1: ASIO
type = 2: WASAPI(排他)
type = 3: WASAPI(共有)
*int type = 0;

*lock (client.SyncRoot)
スレッド処理のためロックする
IMAP INBOXフォルダの受信と保存
*save_mail_imap(client.Inbox, "1");
IMAP その他フォルダの受信と保存
*var personal = client.GetFolder(client.PersonalNamespaces[0]);
IMAPフォルダを開く
*folder.Open(FolderAccess.ReadOnly);
*if (m.To.Count <; 1)*{
例外エラーの発生を防ぐ処理
*if (Directory.Exists(save_path + folder.Name) == false)*{
フォルダ存在確認
'初回はフォルダがないから作る
*Directory.CreateDirectory(save_path + folder.Name);
*if (File.Exists(save_path + folder.Name + "\\" + uid.ToString() + "：" + m.Subject + ".eml") == false)*{
メッセージ本文をダウンロードしてファイルに保存する
ファイルへ書き出し
*m.WriteTo(save_path + folder.Name + "\\" + uid.ToString() + "：" + m.Subject + ".eml");
IMAPフォルダを開く
*folder.Open(FolderAccess.ReadOnly);
*if (m.To.Count <; 1)*{
例外エラーの発生を防ぐ処理
*if (Directory.Exists(save_path + folder.Name) == false)*{
フォルダ存在確認
初回はフォルダがないから作る
*Directory.CreateDirectory(save_path + folder.Name);
*if (File.Exists(save_path + folder.Name + "\\" + uid.ToString() + "：" + m.Subject + ".eml") == false)*{
メッセージ本文をダウンロードしてファイルに保存する
ファイルへ書き出し
*m.WriteTo(save_path + folder.Name + "\\" + uid.ToString() + "：" + m.Subject + ".eml");

100日後までの間で最も近い営業日を取得
100は適当な大きな数値でOK
*DateTime next = Enumerable.Range(1, 100).Select(x =>; date.AddDays(x)).First(

*while (DX.ProcessMessage() != -1)*{
メインループ
描画先を裏画面に設定
*SetDrawScreen(DX.DX_SCREEN_BACK);
画面をクリア
*DX.ClearDrawScreen();
処理();

裏画面の内容を表画面に反映する
*DX.ScreenFlip();

*xmlns:x="http:
schemas.microsoft.comwinfx2006xaml"

コールバック用のリスナー
*public event Action OnSomething;
コールバックをそれぞれ登録
*OnSomething += OnSomething1;
イベントを実行
*OnSomething?.Invoke();

始点から終点までの時間
*public float journeyTime = 1.0f;
弧の中心
*Vector3 center = (sunrise.position + sunset.position) * 0.5f;
弧を中心にするため調整
*center -= new Vector3(0, -1, 0);
中心を基準として円弧を補間する
*Vector3 riseRelCenter = sunrise.position - center;

*using System.Runtime.CompilerServices;
to use [MethodImpl(MethodImplOptions.NoInlining)]
*{Button btnStartTryGet;[MethodImpl(MethodImplOptions.NoInlining)]void TryGetActiveBook(){try {var oExcelApp = (Excel.Application)Marshal.GetActiveObject("Excel.Application");if (oExcelApp == null) {return;}dynamic book;book = oExcelApp.ActiveWorkbook;var res = MessageBox.Show("Are you sure to delete all names in the excel: \"" + book.Name+"\"", "Confirmation", MessageBoxButtons.OKCancel );if (res == DialogResult.OK ) {dynamic names = book.Names;int count=0;foreach(dynamic name in names){name.Delete();count++;GC.Collect();GC.WaitForPendingFinalizers();}Console.WriteLine(count.ToString() + " names are deleted.");}}catch(Exception e) {if (e is Microsoft.CSharp.RuntimeBinder.RuntimeBinderException ||e is COMException ) {Console.WriteLine(e);// もみ消すreturn;}throw e;}finally {}}ExcelNameRemover(){Controls.Add(btnStartTryGet = new Button(){Text = "Remove all names",Location = new Point(0, 0),Width = 200});btnStartTryGet.Click += (s,e)=>;{TryGetActiveBook();GC.Collect();GC.WaitForPendingFinalizers();};}[STAThread]static void Main(string[] args){//DumpTextOfActiveSheet();Application.Run(new ExcelNameRemover());}}
using Microsoft.Office.Core;
もみ消す
*return;

*SurfaceType.Ceiling,
天井.

*Client.Send(RequestData, RequestData.Length, new IPEndPoint(IPAddress.Broadcast, 8888));
ポート8888にブロードキャスト送信
送信データを受信した相手は、自分（クライアント）のエンドポイント情報を知ったはずなので、
そこに対してパケットを送信してくれるのを待つ
var ServerResponseData = Client.Receive(ref ServerEp);   サーバからのパケット受信、ServerEpにサーバのエンドポイント情報が入る
*var ServerResponse = Encoding.ASCII.GetString(ServerResponseData);
*Console.WriteLine("Recived {0} from {1}:{2}", ServerResponse, ServerEp.Address.ToString(), ServerEp.Port.ToString());
ServerEp.Address / ServerEp.Port でサーバのIP/ポート番号を取得

*<;#= CreateSwitchFields(0, count) #<;
★Indexのフィールドを参照

[AllowAnonymous]を付与するとログイン不要となる
*[AllowAnonymous]
[Authorize]を付与するとログイン必要となる
*[Authorize]

*Console.WriteLine($"AsyncMethod end : {Thread.CurrentThread.ManagedThreadId}");
5 (スレッドB)

*{get;private set;}
Public Properties:
*{//refs:mainCamera = Camera.main.transform;//requirements:if (FindObjectOfType<;MLSpatialMapper>;() == null){Debug.LogError("PlaceOnFloor requires and instance of the MLSpatialMapper in your scene.");}}
Init:
*mainCamera = Camera.main.transform;*//requirements:
refs:
*if (FindObjectOfType<;MLSpatialMapper>;() == null)*{
requirements:
*{//sets:headLocationHistory = new List<;Vector3>;();headRotationHistory = new List<;Quaternion>;();}
Flow:
*{//let headpose warmup a little:if (Time.frameCount <; 3){return;}HeadActivityDetermination();}
Loops:
*if (Time.frameCount <; 3)*{
let headpose warmup a little:
*{yield return new WaitForSeconds(HeadIdleRequiredDuration);headIdle = true;}
Coroutines:
*if (headLocationHistory.Count == HistoryCount)*{
location velocity:
*if (headLocationVelocity <;= HeadLocationIdleThreshold)*{
idle detection:
*if (headRotationHistory.Count == HistoryCount)*{
rotation velocity:
*if (headRotationVelocity <;= HeadRotationIdleThreshold)*{
idle detection:
*if (headLocationIdle &amp;&amp; headRotationIdle)*{
absolute idle head determination:

Androidバージョンによってはエラーが発生する書き方
*var context = Android.App.Application.Context;
正常に動作する書き方
*var context = (Context)Plugin.CurrentActivity.CrossCurrentActivity.Current.Activity;

セーブボタン
*_saveButton.OnPointerClickAsObservable()
保存
*ConvertToPngAndSave(GetSaveDirectoryPath(IMAGE_SAVE_FOLDER), GetSaveFilePath(IMAGE_SAVE_FOLDER, PNG));
リセット
*_painter.ResetTexture();
ロードボタン
*_loadButton.OnPointerClickAsObservable()
まだ存在してなかったら作成
*Directory.CreateDirectory(directoryPath);
古いものが先頭にくるようにファイルをソート
*List<;string>; imageFilePathList = Directory
Imageディレクトリ内の全ファイルを取得
*.GetFiles(directoryName, "*", SearchOption.AllDirectories)
.DS_Storeは除く
*.Where(filePath =>; Path.GetFileName(filePath) != ".DS_Store")
日付順に降順でソート
*.OrderBy(filePath =>; File.GetLastWriteTime(filePath).Date)
同じ日付内で時刻順に降順でソート
*.ThenBy(filePath =>; File.GetLastWriteTime(filePath).TimeOfDay)
指定したディレクトリー配下のファイルが全て入ったリストを取得
*List<;string>; imageFilePaths = GetAllFileFromDirectory(directoryPath);
*if (imageFilePaths.Count >;= UPPER_LIMIT_SAVE_PICTURE)*{
ファイル数の上限をチェック
上限に達していた場合、最も古いファイルを削除
*File.Delete(imageFilePaths[0]);
Pngに変換
*byte[] bytes = _paintImage.sprite.texture.EncodeToPNG();
保存
*File.WriteAllBytes(fileSavePath, bytes);
*foreach (Transform child in _loadImagesParentTransform)*{
ロード後、複数枚表示するためのImageリスト作成
指定したディレクトリー配下のファイルが全て入ったリストを取得
*List<;string>; imageFilePaths = GetAllFileFromDirectory(directoryPath);
インデックス用カウンター
*int count = 0;
*foreach (string imageFilePath in imageFilePaths)*{
ファイルのリストから古い順にロードしてImageに適用
読み込み
*byte[] bytes = File.ReadAllBytes(imageFilePath);
画像をテクスチャに変換
*Texture2D loadTexture = new Texture2D(2, 2);
テクスチャをスプライトに変換
*imageList[count].sprite = Sprite.Create(loadTexture, new Rect(0, 0, loadTexture.width, loadTexture.height), Vector2.zero);
インデックス用カウンターを進める
*count++;

*udpClient.Send(buff, buff.Length, endPoint);
受信内容をエコー

使い方↓
https:nn-hokuson.hatenablog.com/entry/2016/12/08/200133
*public class SmoothPaint : MonoBehaviour
*if (_prevPosition == Vector2.zero)*{
前回値がまだないなら現在の値を前回値として扱う
線形補間に使う入力の終点座標
*Vector2 endPosition = Input.mousePosition;
1フレームの線の距離
*float lineLength = Vector2.Distance(_prevPosition, endPosition);
線の長さに応じて変わる補間値　CeilToIntは小数点以下を切り上げ
*int lerpCountAdjustNum = 5;
Lerpの割合値を "現在の回数/合計回数" で出す
*float lerpWeight = (float) i / lerpCount;
前回の入力座標、現在の入力座標、割合を渡して補間する座標を算出
*Vector3 lerpPosition = Vector2.Lerp(_prevPosition, Input.mousePosition, lerpWeight);
前回の入力座標を記録
*_prevPosition = Input.mousePosition;
前回の入力座標をリセット
*_prevPosition = Vector2.zero;
*if (_prevPosition == Vector2.zero)*{
前回値がまだないなら現在の値を前回値として扱う
前回の入力座標をリセット
*_prevPosition = Vector2.zero;

*DataRow row = tbl.Rows[i];
データ行
右のリストボックスにアイテムを追加
*listBox1.Items.Add(row[1]);

このように直接文字列リテラルを埋め込むのは避けるべき
EnemyLauncher型のLaunchEnemyメソッドの名前が変更された場合、実行時エラーになってしまう
*SendMessage("LaunchEnemy");
EnemyLauncher型のLaunchEnemyメソッドの名前が変更された場合、コンパイルエラーになり、厄介な実行時エラーの原因を事前に気付ける
また、IDEのリネーム機能を使った場合、↓の内容もリネーム対象となる
*SendMessage(nameof(EnemyLauncher.LaunchEnemy));

*ary_bmp_file.Add(0);
0で埋める
一旦、バイト型配列の内容をファイルに書き出す
*fs.Write(ary_bmp_file.ToArray(), 0, ary_bmp_file.Count);
配列を、一旦、クリアする。
*ary_bmp_file.Clear();
■書き込みの後処理
fs.Close(); ファイルを閉じる
*}
バイナリ・メモリの占有を開放する。
*ary_bmp_file.Clear();
画像の解放
*Array.Clear(bmparr,0, bmparr.Length);

遷移を管理するクラス
*MyClass myClass = new MyClass();
ステートマシンの宣言
*StateMachine<;MyClass>; stateMachine = new StateMachine<;MyClass>;(myClass);
stateインターフェースを実装したクラス
*State<;MyClass>; myState = new MyState();
現在の状態を変更
*stateMachine.ChangeState(myState);
現在のステートを実行
*stateMachine.Update();

*inputs[2*k+1].Type = 1;
KeyBoard = 1

*catch (Exception e)
失敗した時の処理
デシリアライズした構造体を返す
*return jsonDeserializedData;
まだ存在してなかったら作成
*Directory.CreateDirectory(directoryPath);
*{SaveImageData("SoftCream");//リセット_painter.ResetTexture();_inputField.text = "";})
セーブボタン
リセット
*_painter.ResetTexture();
ロードボタン
*_loadButton.OnPointerClickAsObservable().Subscribe(_ =>; LoadImageData("SoftCream")).AddTo(this);
リセットボタン
*_resetButton.OnPointerClickAsObservable().Subscribe(_ =>; _painter.ResetTexture()).AddTo(this);;
構造体にパス、名前を入れる　これでひとつの塊
*ImageData imageData =new ImageData(pngPath,_inputText.text);
Pngに変換
*byte[] bytes = _paintImage.sprite.texture.EncodeToPNG();
保存
*File.WriteAllBytes(pngPath, bytes);
構造体をJsonに変換
*JsonDataUtility.Save(imageData,jsonPath);
読み込み
*byte[] bytes = File.ReadAllBytes(imageData.ImageSavePath);
画像をテクスチャに変換
*Texture2D loadTexture = new Texture2D(2, 2);
テクスチャをスプライトに変換
*_loadImage.sprite = Sprite.Create(loadTexture, new Rect(0, 0, loadTexture.width, loadTexture.height), Vector2.zero);
画像の名前を表示
*_loadText.text = imageData.ImageName;
まだ存在してなかったら作成
*Directory.CreateDirectory(directoryPath);

*using MySql.Data.MySqlClient;
これがMySQLを扱うためのオブジェクトを含んでいる
接続情報を文字列で与える
*string connStr = "server=127.0.0.1;user id=test;password=test1;database=manutest";
接続を開く
*conn.Open();
ここにSQLの処理を書く
接続を閉じる
*conn.Close();
MySqlの接続エラー処理をここに書く
*}

*StreamWriter writer = new StreamWriter(filePath, false);
true追記、false上書き

リストボックス1の選択アイテムを取り出す
*}
リストボックス2の選択アイテムを取り出す
*}
*{List<;ExampleClass>; selItems = new List<;ExampleClass>;();foreach (var oneItemLine in listBox.SelectedItems){ExampleClass item = oneItemLine as ExampleClass;selItems.Add(item);}return selItems;}
! SelectedItemsの中身を取り出すメソッド
*{// 操作するコントロールstring controlName = "ExampleList1";// リストボックスを探すobject controlObj = FindName(controlName);ListBox listBox = (ListBox)controlObj;// 選択項目が0 =>; メソッドを出るif (listBox.SelectedItems.Count == 0)return;// 選択中のアイテムを取得するList<;ExampleClass>; selItems = GetSelectedItems(listBox);// メッセージボックスに表示する内容string message = "";foreach (var line in selItems){message = message + string.Format("\r\nId：「{0}」　Nmae：「{1}」　Age：「{2}」", line.Id, line.Name, line.Age);}message = string.Format($"{controlName} で選択中の項目は\r\n{message}\r\n\r\nです");MessageBox.Show(message);}
! リストボックス1の選択中アイテムを表示する
操作するコントロール
*string controlName = "ExampleList1";
リストボックスを探す
*object controlObj = FindName(controlName);
*if (listBox.SelectedItems.Count == 0)*return;
選択項目が0 =&gt; メソッドを出る
選択中のアイテムを取得する
*List<;ExampleClass>; selItems = GetSelectedItems(listBox);
メッセージボックスに表示する内容
*string message = "";
*{// リスト1と大体同じ。ContorolNameを変えるのみ。}
! リストボックス2の選択中アイテムを表示する
リスト1と大体同じ。ContorolNameを変えるのみ。
*}
*{// 操作するコントロールstring controlName = "ExampleList1";ItemShow(controlName);}
! リストボックス1の選択中アイテムを表示する
操作するコントロール
*string controlName = "ExampleList1";
*{// 操作するコントロールstring controlName = "ExampleList2";ItemShow(controlName);}
! リストボックス2の選択中アイテムを表示する
操作するコントロール
*string controlName = "ExampleList2";
*{// リストボックスを探すobject controlObj = FindName(controlName);ListBox listBox = (ListBox)controlObj;// 選択項目が0 =>; メソッドを出るif (listBox.SelectedItems.Count == 0)return;// 選択中のアイテムを取得するList<;ExampleClass>; selItems = GetSelectedItems(listBox);// メッセージボックスに表示する内容string message = "";foreach (var line in selItems){message = message + string.Format("\r\nId：「{0}」　Nmae：「{1}」　Age：「{2}」", line.Id, line.Name, line.Age);}message = string.Format($"{controlName} で選択中の項目は\r\n{message}\r\n\r\nです");MessageBox.Show(message);}
SelectedItemsの中身を取り出す～メッセージ表示メソッド
リストボックスを探す
*object controlObj = FindName(controlName);
*if (listBox.SelectedItems.Count == 0)*return;
選択項目が0 =&gt; メソッドを出る
選択中のアイテムを取得する
*List<;ExampleClass>; selItems = GetSelectedItems(listBox);
メッセージボックスに表示する内容
*string message = "";
*{List<;ExampleClass>; selItems = new List<;ExampleClass>;();foreach (var oneItemLine in listBox.SelectedItems){ExampleClass item = oneItemLine as ExampleClass;selItems.Add(item);}return selItems;}
! SelectedItemsの中身を取り出すメソッド
*{var selItems = new List<;T>;();foreach (var oneItemLine in listBox.SelectedItems){var item = oneItemLine as T;selItems.Add(item);}return selItems;}
! SelectedItemsの中身を取り出すメソッド
リストボックスを探す
*object controlObj = FindName(controlName);
選択中のアイテムを取得する
*GetSelectedItems<;ExampleClass>; g = new GetSelectedItems<;ExampleClass>;(listBox);
*{// 操作するコントロールstring controlName = "ExampleList1";ItemShow(controlName);}
! リストボックス1の選択中アイテムを表示する
操作するコントロール
*string controlName = "ExampleList1";
*{// 操作するコントロールstring controlName = "ExampleList2";ItemShow(controlName);}
! リストボックス2の選択中アイテムを表示する
操作するコントロール
*string controlName = "ExampleList2";
*{// リストボックスを探すobject controlObj = FindName(controlName);ListBox listBox = (ListBox)controlObj;// 選択項目が0 =>; メソッドを出るif (listBox.SelectedItems.Count == 0)return;// 選択中のアイテムを取得するGetSelectedItems<;ExampleClass>; g = new GetSelectedItems<;ExampleClass>;(listBox);var selItems = g.Get();// メッセージボックスに表示する内容string message = "";foreach (var line in selItems){message = message + string.Format("\r\nId：「{0}」　Nmae：「{1}」　Age：「{2}」", line.Id, line.Name, line.Age);}message = string.Format($"{controlName} で選択中の項目は\r\n{message}\r\n\r\nです");MessageBox.Show(message);}
SelectedItemsの中身を取り出す～メッセージボックス表示メソッド
リストボックスを探す
*object controlObj = FindName(controlName);
*if (listBox.SelectedItems.Count == 0)*return;
選択項目が0 =&gt; メソッドを出る
選択中のアイテムを取得する
*GetSelectedItems<;ExampleClass>; g = new GetSelectedItems<;ExampleClass>;(listBox);
メッセージボックスに表示する内容
*string message = "";
*{var selItems = new List<;T>;();foreach (var oneItemLine in listBox.SelectedItems){var item = oneItemLine as T;selItems.Add(item);}return selItems;}
! SelectedItemsの中身を取り出すメソッド

*if (sc is SC_MOVE or SC_MAXIMIZE or SC_MINIMIZE)
C# 9.0 の書き方なので、それより前の場合は == と || 使って書いて

IWebHostEnvironment のインスタンス保存用
*private IWebHostEnvironment _webHostEnvironment;
IWebHostEnvironment のインスタンスを保存
*this._webHostEnvironment = env;
実行時コンパイルの有効化
*mvcBuilder.AddRazorRuntimeCompilation();

*if (ExampleList.SelectedItems.Count == 0)*return;
選択項目が0 =&gt; メソッドを出る
空の配列を宣言
*int[] _id = new int[0];
*foreach (var oneItemLine in ExampleList.SelectedItems)*{
SelectedItemsの中身を取り出す
配列の箱を一つ増やす
*int reLength = _id.Length + 1;
ExampleClassとして取り出す
*ExampleClass item = oneItemLine as ExampleClass;
*for (int n = 0; n <; ExampleList.SelectedItems.Count; n++)*{
三つ選択がある（SelectedItems.Count=3）としたら、3回ループして欲しい（n=0,1,2）ので n &lt; SelectedItems.count

*if (ExampleList.SelectedItems.Count == 0)*return;
選択項目が0 =&gt; メソッドを出る
ExampleClassとして取り出す
*ExampleClass selitem = ExampleList.SelectedItem as ExampleClass;
*Console.WriteLine("選択中の項目 Id:{0} Name:{1} Age{2}", selitem.Id, selitem.Name, selitem.Age);
中身の確認

*_list.RemoveRange(0, result);
リストのインデックス 0～result を削除

ブール値のロード
*bool isDemoMode = this._configuration.GetValue<;bool>;("UserSettings:IsDemoMode");
文字列値のロードは、インデクサで指定可能
*string defaultUserName = this._configuration["UserSettings:DefaultUser:Name"];
int 値のロード
*int defaultUserAge = this._configuration.GetValue<;int>;("UserSettings:DefaultUser:Age");
*{//構成情報の注入services.Configure<;UserSettings>;(this.Configuration.GetSection("UserSettings"));services.AddControllersWithViews();}
This method gets called by the runtime. Use this method to add services to the container.
構成情報の注入
*services.Configure<;UserSettings>;(this.Configuration.GetSection("UserSettings"));
構成情報の取得
*this._userSettings = userSettings.Value;
構成情報の参照
*return View(this._userSettings);

*{//キャストしてしまえばAddできる(rolist as IList<;int>;).Add(100);}
IReadOnlyListで受け取っても…
キャストしてしまえばAddできる
*(rolist as IList<;int>;).Add(100);
AsReadOnly()による生成
*ReadOnlyCollection<;int>; readonlyCollection = list.AsReadOnly();
コンストラクタによる生成
*ReadOnlyCollection<;int>; readonlyCollection = new ReadOnlyCollection<;int>;(list);
ToImmutable()による生成
*ImmutableList<;int>; immutableList = list.ToImmutable();
ImmutableList.CreateRangeによる生成
*ImmutableList <;int>; immutableList = ImmutableList.CreateRange(list);
ReadOnlyCollection, ImmutableListを生成したあとに元となるコレクションに変更を加える
*list.Add(100);
*{}
普通のインターフェイス実装
*{}
明示的なインターフェイスの実装

*public Transform startMarker;*//終点
始点
*public Transform endMarker;*//速度
終点
速度
*public float speed = 1.0f;
ColorLerpクラスのために非表示public
二点の補間値
*[System.NonSerialized]
動き出した時間
*startTime = Time.time;
二点間の距離
*distance = Vector3.Distance(startMarker.position, endMarker.position);
移動距離 =　経過時間　*　速度
*float distCovered = (Time.time - startTime) * speed;
移動距離の割合 = 移動距離 /　二点間の距離
*fractionOfJourney = distCovered / distance;
*transform.position = Vector3.Lerp(startMarker.position, endMarker.position, fractionOfJourney);*}
線形補間による移動
LerpExampleから補間値を取得
*mat = this.GetComponent<;Renderer>;().material;
青色→赤色へLerpExampleと同じ補間値で推移
*mat.color = Color.Lerp(Color.blue, Color.red, lerpExample.fractionOfJourney);

セーブボタン
*_saveButton.OnPointerClickAsObservable().Subscribe(_ =>; ConvertToPngAndSave(GetSavePath(IMAGE_SAVE_FOLDER))).AddTo(this);
ロードボタン
*_loadButton.OnPointerClickAsObservable().Subscribe(_ =>; ConvertToTextureAndLoad(GetSavePath(IMAGE_SAVE_FOLDER))).AddTo(this);
リセットボタン
*_resetButton.OnPointerClickAsObservable().Subscribe(_ =>; _painter.ResetTexture());
まだ存在してなかったら作成
*Directory.CreateDirectory(directoryPath);
Pngに変換
*byte[] bytes = _paintImage.sprite.texture.EncodeToPNG();
保存
*File.WriteAllBytes(path, bytes);
読み込み
*byte[] bytes = File.ReadAllBytes(path);
画像をテクスチャに変換
*Texture2D loadTexture = new Texture2D(2, 2);
テクスチャをスプライトに変換
*_paintImage.sprite = Sprite.Create(loadTexture, new Rect(0, 0, loadTexture.width, loadTexture.height), Vector2.zero);

*fileSystemMock.File.Exists(expectedRenamedFilePath)
☆変更

*private readonly HttpClient _httpClient;
私はいつ開放されるの！？
省略
*}

[exit]を送信するまでは何度でもプロットでき、その都度、画像データを取得できます。

*process.StandardInput.WriteLine("exit");
--- 省略 ---
*process.StandardInput.WriteLine("splot exp(-x*x) * exp(-y*y)");

Windowsインスタンスを生成した際に自動でそのインスタンスが
Application.MainWindowにセットされる。
*Window firstWindow = new MainWindow();
移行の処理は実行されません。
*secondWindow.ShowDialog();

*static T Gcd(T a, T b) =<; b <; a ? Gcd(b, a) : (b == 0 ? a : Gcd(b, a % b));
この行がコンパイル不能
LongOperator, UIntOperator, ULongOperator なども同様に定義
*,,,

*endpoints.MapRazorPages();
認証の為のページ遷移設定の読み込み

*[Table("blogs", Schema = "blogging")]
スキーマの設定

Rigidbody2Dコンポーネントを必須にする
*[RequireComponent(typeof(Rigidbody2D))]
移動スピード
*public float speed;
弾を撃つ間隔
*public float shotDelay;
弾のPrefab
*public GameObject bullet;
*public void Shot (Transform origin)*{
弾の作成
*{GetComponent<;Rigidbody2D>;().velocity = direction * speed;}
機体の移動
弾を撃つ間隔
*[SerializeField] float _shotDelay;
弾の Prefab
*[SerializeField] GameObject _bullet;
*public void Shot(Transform origin)*{
弾の作成
移動速度
*[SerializeField] float _speed;
SpaceshipのRigidbody
*[SerializeField] Rigidbody2D _rigidbody;
*{_rigidbody.velocity = direction * _speed;}
機体の移動

*if (this.paramA.SetValue(value, this))*this.Model.ParamA = int.Parse(this.ParamA);
入力エラーがなければModelに設定
*if (this.paramB.SetValue(value, this))*this.Model.ParamB = int.Parse(this.ParamB);
入力エラーがなければModelに設定
TODO: 本来ならDIコンテナから取得
*this.Model = new MainModel();
*{// 実行this.Model.Sum();}, paramA, paramB);
Sumボタン
実行
*this.Model.Sum();
・・・Modelから通知を受けたり、コマンドを受けてModelを実行したりだけ
*}

*"https:
raw.githubusercontent.comrunceelmockapimastermessage.json");
以下 2 行を追加
*containerRegistry.RegisterSingleton<;HttpClient>;();

テスト用.
*StringBuilder stringBuilder = new StringBuilder(512);
*{// テスト用,ターゲットの拡張子を変更する.targetExtension = EditorGUILayout.TextField("targetExtension", targetExtension);// 目的とするファイルの拡張子を指定してDrag &amp; Dropの領域を描画する.// 複数ファイルドロップに対応し、指定した拡張子以外のファイルがマスクされた配列がコールバックで呼ばれる.DrawFileDragArea(GUILayoutUtility.GetRect(0.0f, 75.0f, GUILayout.ExpandWidth(true)),"Drag &amp; Drop",targetExtension,(objs) =>;{stringBuilder.Clear();foreach (var obj in objs){stringBuilder.AppendLine(obj.name);}});if (GUILayout.Button("Clear")){stringBuilder.Clear();}// 取得したアイテムのリストを描画.EditorGUILayout.LabelField(stringBuilder.ToString(), GUILayout.Height(300));}
UI描画.
テスト用,ターゲットの拡張子を変更する.
*targetExtension = EditorGUILayout.TextField("targetExtension", targetExtension);
目的とするファイルの拡張子を指定してDrag &amp; Dropの領域を描画する.
複数ファイルドロップに対応し、指定した拡張子以外のファイルがマスクされた配列がコールバックで呼ばれる.
*DrawFileDragArea(
取得したアイテムのリストを描画.
*EditorGUILayout.LabelField(stringBuilder.ToString(), GUILayout.Height(300));
ドラッグ中.
*case EventType.DragUpdated:
Dragされている間のカーソルの見た目を変更.
*DragAndDrop.visualMode = visualMode;
オブジェクトを受け入れる.
*DragAndDrop.AcceptDrag();

*Console.WriteLine(string.Join(",",ary));
aryを連結して出力

学習用
*public GameObject pole;
*{//学習の初期化poleRB = pole.GetComponent<;Rigidbody>;();cartRB = gameObject.GetComponent<;Rigidbody>;();m_ResetParams = Academy.Instance.EnvironmentParameters;SetResetParameters();}
初期値
学習の初期化
*poleRB = pole.GetComponent<;Rigidbody>;();
*{sensor.AddObservation(gameObject.transform.localPosition.z);sensor.AddObservation(cartRB.velocity.z);sensor.AddObservation(pole.transform.localRotation.eulerAngles.x);sensor.AddObservation(poleRB.angularVelocity.x);}
センサーにデータを送る
*{//カートに力を加えるvar actionZ = 200f * Mathf.Clamp(verctorAction[0], -1f, 1f);cartRB.AddForce(new Vector3(0.0f, 0.0f, actionZ), ForceMode.Force);//カートの位置、ポールの角度と角速度float cart_z = this.gameObject.transform.localPosition.z;float angle_x = pole.transform.localRotation.eulerAngles.x;//angle_zを-180~180に変換if(180f <; angle_x &amp;&amp; angle_x <; 360f){angle_x = angle_x - 360f;}//カートが+-45度いないなら報酬+0.1 それ以外は -1if((-180f <; angle_x &amp;&amp; angle_x <; -45f) || (45f <; angle_x &amp;&amp; angle_x <; 180f)){SetReward(-1.0f);EndEpisode();}else{SetReward(0.1f);}//カートの位置が-10~10の範囲を超えたら報酬-1if(cart_z <; -10f || 10f <; cart_z){SetReward(-1.0f);EndEpisode();}}
各ステップでの行動
カートに力を加える
*var actionZ = 200f * Mathf.Clamp(verctorAction[0], -1f, 1f);
*float cart_z = this.gameObject.transform.localPosition.z;*float angle_x = pole.transform.localRotation.eulerAngles.x;
カートの位置、ポールの角度と角速度
*if(180f <; angle_x &amp;&amp; angle_x <; 360f)*{
angle_zを-180~180に変換
*if((-180f <; angle_x &amp;&amp; angle_x <; -45f) || (45f <; angle_x &amp;&amp; angle_x <; 180f))*{
カートが+-45度いないなら報酬+0.1 それ以外は -1
*if(cart_z <; -10f || 10f <; cart_z)*{
カートの位置が-10~10の範囲を超えたら報酬-1
*{//エージェントの状態をリセットgameObject.transform.localPosition = new Vector3(0f, 0f, 0f);pole.transform.localPosition = new Vector3(0f, 2.5f, 0f);pole.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);poleRB.angularVelocity = new Vector3(0f, 0f, 0f);poleRB.velocity = new Vector3(0f, 0f, 0f);//ポールにランダムな傾きを与えるpoleRB.angularVelocity = new Vector3(Random.Range(-0.1f, 0.1f), 0f, 0f);SetResetParameters();}
ステップ開始の初期条件を決定
*gameObject.transform.localPosition = new Vector3(0f, 0f, 0f);*pole.transform.localPosition = new Vector3(0f, 2.5f, 0f);
エージェントの状態をリセット
ポールにランダムな傾きを与える
*poleRB.angularVelocity = new Vector3(Random.Range(-0.1f, 0.1f), 0f, 0f);
*{actionsOut[0] = Input.GetAxis("Horizontal");}
キーボードから操作する場合
*{poleRB.mass = m_ResetParams.GetWithDefault("mass", 1.0f);pole.transform.localScale = new Vector3(0.4f, 2f, 0.4f);}
ポールの条件をリセット
*{SetPole();}
パラメータをリセットする関数
学習の初期化
*poleRB = pole.GetComponent<;Rigidbody>;();
*{//カートに力を加えるvar actionZ = 200f * Mathf.Clamp(verctorAction[0], -1f, 1f);cartRB.AddForce(new Vector3(0.0f, 0.0f, actionZ), ForceMode.Force);//カートの位置、ポールの角度と角速度float cart_z = this.gameObject.transform.localPosition.z;float angle_x = pole.transform.localRotation.eulerAngles.x;//angle_zを-180~180に変換if(180f <; angle_x &amp;&amp; angle_x <; 360f){angle_x = angle_x - 360f;}//カートが+-45度いないなら報酬+0.1 それ以外は -1if((-180f <; angle_x &amp;&amp; angle_x <; -45f) || (45f <; angle_x &amp;&amp; angle_x <; 180f)){SetReward(-1.0f);EndEpisode();}else{SetReward(0.1f);}//カートの位置が-10~10の範囲を超えたら報酬-1if(cart_z <; -10f || 10f <; cart_z){SetReward(-1.0f);EndEpisode();}}
各ステップでの行動
カートに力を加える
*var actionZ = 200f * Mathf.Clamp(verctorAction[0], -1f, 1f);
*float cart_z = this.gameObject.transform.localPosition.z;*float angle_x = pole.transform.localRotation.eulerAngles.x;
カートの位置、ポールの角度と角速度
*if(180f <; angle_x &amp;&amp; angle_x <; 360f)*{
angle_zを-180~180に変換
*if((-180f <; angle_x &amp;&amp; angle_x <; -45f) || (45f <; angle_x &amp;&amp; angle_x <; 180f))*{
カートが+-45度いないなら報酬+0.1 それ以外は -1
*if(cart_z <; -10f || 10f <; cart_z)*{
カートの位置が-10~10の範囲を超えたら報酬-1
カートに力を加える
*var actionZ = 200f * Mathf.Clamp(verctorAction[0], -1f, 1f);
*if((-180f <; angle_x &amp;&amp; angle_x <; -45f) || (45f <; angle_x &amp;&amp; angle_x <; 180f))*{
カートが+-45度いないなら報酬+0.1 それ以外は -1
*if(cart_z <; -10f || 10f <; cart_z)*{
カートの位置が-10~10の範囲を超えたら報酬-1
*{//エージェントの状態をリセットgameObject.transform.localPosition = new Vector3(0f, 0f, 0f);pole.transform.localPosition = new Vector3(0f, 2.5f, 0f);pole.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);poleRB.angularVelocity = new Vector3(0f, 0f, 0f);poleRB.velocity = new Vector3(0f, 0f, 0f);//ポールにランダムな傾きを与えるpoleRB.angularVelocity = new Vector3(Random.Range(-0.1f, 0.1f), 0f, 0f);SetResetParameters();}
ステップ開始の初期条件を決定
*gameObject.transform.localPosition = new Vector3(0f, 0f, 0f);*pole.transform.localPosition = new Vector3(0f, 2.5f, 0f);
エージェントの状態をリセット
ポールにランダムな傾きを与える
*poleRB.angularVelocity = new Vector3(Random.Range(-0.1f, 0.1f), 0f, 0f);
*{actionsOut[0] = Input.GetAxis("Horizontal");}
キーボードから操作する場合

*SelectionColor = ResultColor;
実行結果の表示色を設定
*if (ee.Result != null &amp;&amp; ee.Result.Length != 0 &amp;&amp; ee.Result[0] == COUTIONCHER) {*ee.Result = ee.Result.Remove(0, 1);
表示文字列の先頭が「！」なら、その一文字を削除し、表示色をCoutionColorに変更
実行結果の表示
*AppendText(LFCR + ee.Result + LFCR);

*IEnumerator TempoMake()
一定間隔で音を鳴らして、”Played”をコンソールに表示
invokerepeatingのつかいかた
https:docs.unity3d.com/ja/current/ScriptReference/MonoBehaviour.InvokeRepeating.html
*using System.Collections;
*{audioSource = GetComponent<;AudioSource>;();InvokeRepeating("PlaySound", START_SECONDS, INTERVAL_SECONDS);}
Start is called before the first frame update

*}
****

改行も入ります
*var num = 20;
コンマ区切り
*Console.WriteLine(string.Join(",", array));
スペース区切り
*Console.WriteLine(string.Join(" ", array));
改行区切り
*Console.WriteLine(string.Join("\r\n", array));

Qiitaの記事を書いた！
*QiitaPost post = new QiitaPost("タイトル", "本文");
Qiitaのサーバーに記事をアップロードした！
*QiitaServer.Upload(post);
Qiita記事を取得
QiitaPost downloadedPost = QiitaServer.Download("https:~");
取得した記事のタイトルと本文を読む
*string title = downloadedPost.Title;
記事をLGTMする
*downloadedPost.LGTM();
Qiita記事を取得
QiitaPost downloadedPost = QiitaServer.Download("https:~");
取得した記事のタイトルと本文を読む
*string title = downloadedPost.Title;
記事をLGTMする
*downloadedPost.LGTM();
勝手に人の書いた記事を消す！！
*downloadedPost.Delete();
記事を書く
*QiitaPost post = new QiitaPost("タイトル", "本文");
記事をアップロードする
*QiitaServer.Upload(post);
自分の記事にLGTMする！！
*post.LGTM();
~略~
*}
記事を書く
*IAuthorQiitaPost post = new QiitaPost("タイトル", "本文");
記事をアップロードする
*QiitaServer.Upload(post);
自分の記事にLGTMできない〜〜〜
post.LGTM();
*,,,
Qiita記事を取得
IReaderQiitaPost downloadedPost = QiitaServer.Download("https:~");
取得した記事のタイトルと本文を読む
*string title = downloadedPost.Title;
記事をLGTMする
*downloadedPost.LGTM();
勝手に人の書いた記事を消せない〜〜〜
downloadedPost.Delete();
*,,,
*{string Read(string path);}
疎結合を目的として作られたインターフェイス
テキストファイルを読み込んだ結果を返す処理
*}
テキストファイルを読み込んだ結果を返す処理
*}

*{return s.GetRequiredService<;IHttpClientFactory>;().CreateClient(string.Empty);});
Register default client as HttpClient

userListでプロパティをまとめて初期化
*this[name] = userList[i];
*{//GetEnumerator実装public IEnumerator<;string>; GetEnumerator(){for (var i = 0; i <; NameList.Count; i++){yield return this[i];}}//IEnumerable(非ジェネリック型)のGetEnumeratorも実装System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator(){return this.GetEnumerator();}}
UsefInfoの変更、追加部分のみ記述
*{for (var i = 0; i <; NameList.Count; i++){yield return this[i];}}
GetEnumerator実装
*{return this.GetEnumerator();}
IEnumerable(非ジェネリック型)のGetEnumeratorも実装
*foreach (var (name, index) in properties.Select((prop, index) =>; (prop.Name, index)))*{
propertiesから、各Name取り出し
配列の最後はthisプロパティなので、スキップする
*break;
UserInfoのプロパティ名のリストを作成
*NameList.Add(name);
全プロパティを初期化
*this[name] = headerlist[index];
プロパティのインデックス用途
*private List<;string>; NameList;
*{get =>; typeof(UserInfo).GetProperty(propertyName).GetValue(this).ToString();set =>; typeof(UserInfo).GetProperty(propertyName).SetValue(this, value);}
添字でのアクセス用
*{get =>; this[NameList[num]];set =>; this[NameList[num]] = value;}
インデクサでのアクセス用
*{var res = new List<;string>;();NameList.ForEach(name =>; res.Add(this[name]));return res;}
リスト型への代入用
添字でアクセス
*User[0] = "dummy";
一致
*}
*foreach(var val in User)*{
xx@xx.com

*{likeEffect = likeEffect.GetComponent<;ParticleSystem>;();}
Start is called before the first frame update

*public void GenerateTextPrefab()
テキストプレハブのテキストにインプットフィールドのテキストを代入して生成し、スピードを設定する。

*public GameObject viewcamera;
"viewcamera"という変数を定義
*viewcamera.transform.Rotate(-mouse_y, 0.0f, 0.0f);*}
このscriptに登録されているオブジェクトをX方向に-mouse_yの値分、回転する

*{}
このオブジェクトが作られたときに行われる処理
*{transform.position += new Vector3(0,0,1.0f) * moveSpeed;}
毎フレーム行われる処理
*{}
このオブジェクトが作られたときに行われる処理
*{transform.position += new Vector3(0, 0, 1.0f) * moveSpeed * Time.deltaTime;}
毎フレーム行われる処理
*{}
このオブジェクトが作られたときに行われる処理
*{float hor = Input.GetAxis("Horizontal");float ver = Input.GetAxis("Vertical");Vector3 moveDir = new Vector3(hor, 0, ver);transform.position += moveDir * moveSpeed * Time.deltaTime;}
毎フレーム行われる処理

Shell.xaml.csで作成したリージョンの名前と、画面のUserControlクラス名を指定して、画面遷移させる。
(パラメータを渡すこともできる)
*this.RegionManager.RequestNavigate("RedRegion", nameof(UserControl2), new NavigationParameters($"id=1"));
このメソッドの返す値により、画面のインスタンスを使いまわすかどうか制御できる。
true ：インスタンスを使いまわす(画面遷移してもコンストラクタ呼ばれない)
false：インスタンスを使いまわさない(画面遷移するとコンストラクタ呼ばれる)
メソッド実装なし：trueになる
*return IsNavigationTargetFlag;
この画面から他の画面に遷移するときの処理
*Debug.WriteLine("画面１ NavigatedFrom");
他の画面からこの画面に遷移したときの処理
*Debug.WriteLine("画面１ NavigatedTo");
画面遷移元から、この画面に遷移したときにパラメータを受け取れる。
*string Id = navigationContext.Parameters["id"] as string;

*SetReward (0f);
引き分け報酬

イベントに反応する
*LoadedCommand.Subscribe(OnLoaded);
*{_model = db.Foos.FirstOrDefault();}
ここでデータベース処理とか
プロパティ変更通知しないと新しいReactivePropertyが機能しない
*RaisePropertyChanged(null);

クリック点にRayを飛ばす
*ray = Camera.main.ScreenPointToRay(Input.mousePosition);
クリックした所から半径20mの範囲のColliderを取得
*Collider[] collider = Physics.OverlapSphere(hit.point, radius);
*if (cube.GetComponent<;Rigidbody>;())*{
範囲内のオブジェクトのRigidbodyに爆破の力を作用させる

*if(条件) await Task.Delay(~);
特定の条件下で発行間隔を増やす

*DX.SetDrawScreen(DX.DX_SCREEN_BACK);
裏画面処理を設定する

*DX.ScreenFlip();
2つの画面を入れ替える

*.CombineLatestValuesAreAllFalse()
すべてエラーなしの場合にアクティブ設定

*driver.Navigate().GoToUrl("https:
www.google.co.jp");

*{hellowWorldService.HelloWorld("Initialize");}
Start()直前に呼ばれる.
*{hellowWorldService.HelloWorld("Postinitialize");}
Start()直後に呼ばれる.
*{hellowWorldService.HelloWorld("FixedTick");}
FixedUpdate()直前に呼ばれる.
*{hellowWorldService.HelloWorld("PostFixedTick");}
FixedUpdate()直後に呼ばれる.
*{hellowWorldService.HelloWorld("Tick");}
Update()直前に呼ばれる.
*{hellowWorldService.HelloWorld("PostTick");}
Update()直後に呼ばれる.
*{hellowWorldService.HelloWorld("LateTick");}
LateUpdate()直前に呼ばれる.
*{hellowWorldService.HelloWorld("PostLateTick");}
LateUpdate()直後に呼ばれる.
コンテナから取得.
*[Inject]
TODO : GameObjectとの紐付け( これ以外の方法があるかはまだわからない ).
*builder.RegisterComponent(testObject);

ログイン処理
*.

nullを許容しない引数のメソッドに渡す際、!演算子が必要になる
*DisallowNullMethod(value!);
*if (TryGetValue("hoge", out string? value)*{
メソッドを呼び出す際は、null許容型な必要がある
ここではvalueをnull非許容として扱える
*DisallowNullMethod(value);

a,b共に、nullになる可能性がある
*var a = GetA();
*if(a != null)*{
変数bのnullチェックはしていない
なんらかの処理が続く
*}

*private const float reachMargin = 1.42f;
許容する接触誤差
エージェントが落ちていたら初期化
*rBody.angularVelocity = Vector3.zero;
ターゲットを新しい無作為な位置へ移動
*target.localPosition = new Vector3 (Random.value * 8 - 4, 0.5f, Random.value * 8 - 4);
ターゲットとエージェントの位置
*sensor.AddObservation (target.localPosition);
エージェントの速度
*sensor.AddObservation (rBody.velocity.x);
行動, size = 2
*var controlSignal = Vector3.zero;
*var distanceToTarget = Vector3.Distance (transform.localPosition, target.localPosition);*// ターゲットへの到達
報酬
*if (distanceToTarget <; reachMargin) {*SetReward (1.0f);
ターゲットへの到達
*if (transform.localPosition.y <; 0) {*EndEpisode ();
プラットフォームからの落下

*return json;
使いやすいように変換してください

*private static readonly List<;int<; numList;
検証リスト

タッチキーボードのON/OFF切替
*Toggle();
タッチキーボードのON/OFF切替
*Toggle();
*{UIHostNoLaunch uiHostNoLaunch = null;try{uiHostNoLaunch = new UIHostNoLaunch();var tipInvocation = (ITipInvocation)uiHostNoLaunch;tipInvocation.Toggle(GetDesktopWindow());}finally{if (uiHostNoLaunch != null){Marshal.ReleaseComObject(uiHostNoLaunch);}}}
UIHostNoLaunch.Toggle で表示切り替え
tabtip.exe が実行されていない場合、new UIHostNoLaunch() でCOMExceptionが発生する。
Process.GetProcessesByName で事前にチェックするべきかとも考えたが、
COMException無視でもそこまで有意な速度差が無いので、チェックしない。
*}
上記処理内で例外が発生した場合、tabtip.exe が起動していないので起動する
*var pi = new ProcessStartInfo();
タッチキーボードの位置・サイズを取得し、幅0なら非表示とみなす
*Rectangle bounds = GetBounds();
タッチキーボードの位置・サイズを取得し、幅0なら非表示とみなす
*inputPane = (IFrameworkInputPane)new FrameworkInputPane();

*e = e % 2;
eに、eを2で割った余りを代入する

以下にテスト実装を記述
*}
Setup で指定した引数構成のものがモック化されている
本来のメソッドは呼び出されず Returns で設定した戻り値が返却されている
*Assert.AreEqual("上書き", humanMock.Object.CreateFullNameWithAge("歳"));
*Assert.AreEqual($"{FamilyName} {GivenName} {Age}", humanMock.Object.CreateFullNameWithAge());
Setup で指定したメソッドと同名だが、引数構成が異なる
*Assert.AreEqual($"{FamilyName} {GivenName} {Age}", humanMock.Object.CreateFullNameWithAge());
モック化の対象外となるため、本来のメソッドが呼び出されている
Setup で指定したメソッド名と引数が一致している
モック化により本来のメソッドが呼び出されず Returns で設定した戻り値が返却されている
*Assert.AreEqual("上書き", humanMock.Object.CreateFullNameWithAge("歳"));
*Assert.AreEqual($"{FamilyName} {GivenName} {Age}才", humanMock.Object.CreateFullNameWithAge("才"));
Setup で指定したメソッドと同名、かつ、同じ型の引数構成だが、正確な設定値が異なる
*Assert.AreEqual($"{FamilyName} {GivenName} {Age}才", humanMock.Object.CreateFullNameWithAge("才"));
モック化の対象外となるため、本来のメソッドが呼び出されている
*Assert.AreEqual($"上書き {Age}", humanMock.Object.CreateFullNameWithAge());
上書きした戻り値が返却されている
*Assert.AreEqual($"{FamilyName} {GivenName}", methodInfo.Invoke(human, null));
引数付きメソッドの場合、第二引数は object[] 型の値を渡す
モック化の設定はクラスをもとにした場合と同様
*humanMock.Setup(m =>; m.CreateFullNameWithAge(It.IsAny<;string>;())).Returns("上書き");
Setup で指定した引数設定と同一のため、呼び出されず Returns で設定した戻り値が返却されている
*Assert.AreEqual("上書き", humanMock.Object.CreateFullNameWithAge("歳"));

*{Text = "Hello, World!"};
Set the text input to be synthesized.
*{LanguageCode = "en-US",SsmlGender = SsmlVoiceGender.Neutral};
and the SSML voice gender ("neutral").
*{AudioEncoding = AudioEncoding.Mp3};
Select the type of audio file you want returned.
*{Input = input,Voice = voice,AudioConfig = config});
with the selected voice parameters and audio file type
*{response.AudioContent.WriteTo(output);Debug.Log($"Audio content written to file " + saveFile);}
Write the binary AudioContent of the response to an MP3 file.

*if(gray<;158){
閾値は、適当に

現在時刻を基準時刻とする (DateTime.UtcNowでもOK)
*baseTime = Time.realtimeSinceStartup;
クライアントにホストの現在時刻を送信する
*RpcSetBaseTime(DateTime.UtcNow);
ホスト開始からの経過時間
*var t = Time.realtimeSinceStartup - baseTime;
tを使って動く床の位置を指定、と仮定
*SetPosition(t);
*{// 通信で起きたラグを算出var delay = (float)(DateTime.UtcNow - hostTime).TotalSeconds;// ラグを考慮した開始時間を設定、このbaseTimeがホストの基準時刻と一致するbaseTime = Time.realtimeSinceStartup - delay;}
ホストからRpcSetBaseTimeが呼ばれたと仮定
通信で起きたラグを算出
*var delay = (float)(DateTime.UtcNow - hostTime).TotalSeconds;
ラグを考慮した開始時間を設定、このbaseTimeがホストの基準時刻と一致する
*baseTime = Time.realtimeSinceStartup - delay;
tはホスト側のtと一致する
*var t = Time.realtimeSinceStartup - baseTime;
tを使って動く床の位置を指定、と仮定
*SetPosition(t);
*{var interval = (moveTime) * 2.0f;time = time % interval;if (time <;= moveTime){var t = time / moveTime;transform.position = Vector3.Lerp(from, to, t);}else{var t = (time - moveTime) / moveTime;transform.position = Vector3.Lerp(to, from, t);}}
時間で行ったり来たりする

*var client = new RestClient("https:
hogehoge.api1.1)
Digest認証の設定
*Authenticator = new DigestAuthenticator("username", "password");
JSONシリアライザーの設定（今回はUtf8Jsonを使用）
*client.UseUtf8Json();
リクエストの生成（Resourceとレスポンスのデータフォーマットを設定）
*var request = new RestRequest("foobaz", DataFormat.Json);
同期呼び出し
*var response = client.Get(request);
JSONデータをデシリアライズ
*var result = new Utf8JsonSerializer().Deserialize<;Foo>;(response);
非同期呼び出し（resultがFoo型として返ってくる）
*var result = await client.GetAsync<;Foo>;(request);

*.GetValue(this);
this は TextView
ここで nonPrintableCharacterTexts を調整
*cachedElements.GetType()

*p.StartInfo.StandardOutputEncoding = Encoding.GetEncoding("shift_jis");
Pythonの出力結果をshift-jisに変換
イベントハンドラの設定
pythonから出力があるたびに呼び出される
*p.OutputDataReceived += new DataReceivedEventHandler((sender, e) =>;

*transform.LookAt(p);*if (billDebug)
p.y = transform.position.y;
*if (Physics.Raycast(transform.position, Vector3.down, out hit, 10))*{
レイが当たったか判定

*dynamic lnk = shell.CreateShortcut(fullPath);
IWshRuntimeLibrary.IWshShortcut

*if (String.Compare(Path.GetFileName(tmp), "EXPLORER.EXE", true)==0) {
大文字小文字無視で比較
*var item = new ListViewItem(new string[]{Path.GetFileName(path),path});
Windows形式のパス表現に変換する
COMオブジェクト解放 ... これでいいはず
*GC.Collect();
*if ( NativeMethods.IsIconic(hwnd) ){// 最小化から戻すNativeMethods.ShowWindow(hwnd, NativeMethods.SW_RESTORE);}
NativeMethods.GetWindowThreadProcessId(hWnd, out pid);
*if ( NativeMethods.IsIconic(hwnd) ){*// 最小化から戻す
Process p = Process.GetProcessById(pid);
最小化から戻す
*NativeMethods.ShowWindow(hwnd, NativeMethods.SW_RESTORE);
フォーカス移動失敗
*}

*logger.Log($"{DateTime.Now}");
Loggerをnewする（Loggerに依存している）
*{public void Execute(){// FileLoggerをnewする（newするクラスを変更）var logger = new FileLogger("log.txt");logger.Log($"{DateTime.Now}");}}
方法２のプログラム
*logger.Log($"{DateTime.Now}");
FileLoggerをnewする（newするクラスを変更）
*{// メンバ変数に退避_logger = logger;}
コンストラクタでILoggerを実装するオブジェクトをもらう
メンバ変数に退避
*_logger = logger;
*_logger.Log($"{DateTime.Now}");
コンストラクタでもらったLoggerオブジェクトのLogメソッドを呼び出す
使用したいLoggerをnewする
*ILogger logger = new ConsoleLogger();
もしFileLoggerを使用したい場合は次のようにする
ILogger logger = new FileLogger("log.txt");
*MyServer server = new MyServer(logger);

--省略
*BackgroundService.DefaultProcess.StartThread();
通知の送信処理...
*}
--省略
*var affectedRecordCount = await sp.ExecuteNonQuery();

*source.Map(distination);
Above lambda will be called.

*PropertyInfo namePropertyInfo = Typeof(UserRecord).GetProperty("Name");
非常に遅い！
*{Contract.Ensures(Contract.ValueAtReturn<;String[]>;(out enumNames) != null);Contract.Ensures(Contract.ValueAtReturn<;Array>;(out enumValues) != null);FieldInfo[] flds = GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);object[] values = new object[flds.Length];string[] names = new string[flds.Length];for (int i = 0; i <; flds.Length; i++){names[i] = flds[i].Name;values[i] = flds[i].GetRawConstantValue();}// Insertion Sort these values in ascending order.// We use this O(n^2) algorithm, but it turns out that most of the time the elements are already in sorted order and// the common case performance will be faster than quick sorting this.IComparer comparer = Comparer.Default;for (int i = 1; i <; values.Length; i++){int j = i;string tempStr = names[i];object val = values[i];bool exchanged = false;// Since the elements are sorted we only need to do one comparision, we keep the check for j inside the loop.while (comparer.Compare(values[j - 1], val) >; 0){names[j] = names[j - 1];values[j] = values[j - 1];j--;exchanged = true;if (j == 0)break;}if (exchanged){names[j] = tempStr;values[j] = val;}}enumNames = names;enumValues = values;}
************************省略***************************
*// the common case performance will be faster than quick sorting this.*IComparer comparer = Comparer.Default;
We use this O(n^2) algorithm, but it turns out that most of the time the elements are already in sorted order and
*while (comparer.Compare(values[j - 1], val) >; 0)*{
Since the elements are sorted we only need to do one comparision, we keep the check for j inside the loop.

*var reference = databaseRoot.Child("users").Child(UserId).Child("backup");
user-id直ではなく、backupに保存
Action&lt;bool&gt; callback = xxx 何かコールバック関数を定義
*string data = JsonUtility.ToJson(saveData);
UIスレッドを触る可能性があるので、コールバックを渡すためのコンテキストを退避しておく
*var context = System.Threading.SynchronizationContext.Current;
Action&lt;UserSaveData&gt; callback = xxx 何かコールバック関数を定義
UIスレッドを触る可能性があるので、コールバックを渡すためのコンテキストを退避しておく
*var context = System.Threading.SynchronizationContext.Current;

*if (String.Compare(Path.GetFileName(        win.FullName), "EXPLORER.EXE", true)==0) {
キャスト無し

*foreach (var name in new[] { nameof(InputFileName), nameof(InputFilePath), nameof(IsReplaced) })*RaisePropertyChanged(name);
rename時にFileInfoが変更されるので、通知を上げておく
ファイル準備
*string targetFilePath = targetDir + targetFileName;
ファイル名の一部を変更する置換パターンを作成
*var regex = new Regex(regexPattern, RegexOptions.Compiled);
*fileElem.Replace(new[] { rpRegex });
リネームプレビュー実行
リネーム保存実行
*fileElem.Rename();

前に選んでいたポートの取得
*string prev_selected_port = "";
ポート一覧の更新
*string[] port_list = SerialPort.GetPortNames();
*for (int i = 0; i <; SerialPortComboBox.Items.Count; i++)*{
前に選択していたポートを再度選択
*if (SerialPortComboBox.Items.Count <;= 1)*SerialPortComboBox.SelectedIndex = 0;
ポート数が1以下であれば0番目を選択
受信処理
*}

*Console.WriteLine("ForAvg：" + String.Format(resultFormat, doForVerifyList.Average()));*Console.WriteLine("ForEachAvg：" + String.Format(resultFormat, doForEachVerifyList.Average()));
それぞれの平均値を出力

*yield return _button.OnClickAsync().ToCoroutine();
OnClickAsync()はUniTaskの機能です

~~~~~~以下他にもいろんな機能がある
・
・
・
*}

*uint t2Cast = (uint)t2;
ここで例外が発生する

ここで無理やり0番地にデータをコピーするようにした
*NativeMethods.CopyMemory((void*)0, src, realsrc.Length);

暗号化したい文字列をバイト配列に変換
*string encryptWord = "冷やし中華ｧァ～";
秘密鍵と公開鍵を生成
*RSA rsa = RSA.Create();
鍵情報を保存
*var publicKey = rsa.ToXmlString(false);
公開鍵情報の文字列からオブジェクトを復元
*byte[] encryptedByte;
*Console.WriteLine($"Encrypt: {encByteToString}");
暗号化したバイトデータを16進数文字列に変換
上記の方法で生成された16進数文字列を外部から受信したと仮定して、
秘密鍵を使って復元する

送信されてきた文字列をバイト配列に変換
*var encStrToBytes = encByteToString.Split('-').Select(r =>; Convert.ToByte(r, 16)).ToArray();
*{decRsa.FromXmlString(privateKey);decryptedByte = decRsa.Decrypt(encStrToBytes, RSAEncryptionPadding.Pkcs1);}
秘密鍵情報の文字列からオブジェクトを復元し、復号
試しにテキトーな鍵で復号してみる
*var invalidDec = string.Empty;

*public ActionResult<;Pet<; GetById(int id, bool dogsOnly)
id=2, dogsOnly=true
複合型の引数の場合、各プロパティの値はリクエストボディから取得される
リクエストボディのフォーマットはConsumes属性で指定するかContent-Typeヘッダの値を使用する
*[HttpPost]
*return CreatedAtAction(nameof(GetById), new { id = pet.Id }, pet);
受信したデータをDBへ登録したり…
*return CreatedAtAction(nameof(GetById), new { id = pet.Id }, pet);
201 Created を返す。レスポンスヘッダにLocationを追加しリソースのURLを返す。

このコードはテンプレートから生成されました。

このファイルを手動で変更すると、アプリケーションで予期しない動作が発生する可能性があります。
このファイルに対する手動の変更は、コードが再生成されると上書きされます。
&lt;/auto-generated&gt;
------------------------------------------------------------------------------
*namespace Mvc5LoginSample1.DAL
*if(hasUser)*{
if (model.Id == "test" &amp;&amp; model.Password == "passwd")
ユーザー認証 成功
*FormsAuthentication.SetAuthCookie(model.Id, true);
ユーザー認証 失敗
*this.ModelState.AddModelError(string.Empty, "指定されたユーザー名またはパスワードが正しくありません。");

日付・時刻あり
*string strDateTime = "2020/10/22 15:01:11";
時刻省略
*string strDate = "2020/10/22";
日付省略
*string strTime = "15:01:11";

*{ViewBag.SelectOptions = new SelectListItem[]{new SelectListItem(){Value="1",Text="text1"},new SelectListItem(){Value="2",Text="text2"},new SelectListItem(){Value="3",Text="text3"}};return View(input);}
ビュー表示用
キャンセルボタンが押されたときに呼び出される
*[HttpPost]
保存ボタンが押されたときに呼び出される
*[HttpPost]

*driver.Navigate().GoToUrl(@"https:
www.google.co.jp");

*inputs[1].Type = 1;
KeyBoard = 1

*Random rnd = new Random();
乱数インスタンス化
描画先とするImageオブジェクトを作成する
*Bitmap canvas = new Bitmap("画像のパス");
ImageオブジェクトのGraphicsオブジェクトを作成する
*g.DrawImage(canvas, rnd.Next(0, 1920), rnd.Next(0, 1000));

*NativeMethods.SetProcessDPIAware();
高解像度のスケーリング座標に対応するため

*Debug.Log($"{pose} {lr}");
左右の判定はこんな感じ.
*{case MLHandTracking.HandKeyPose.C: break;case MLHandTracking.HandKeyPose.Finger: break;case MLHandTracking.HandKeyPose.Fist: break;case MLHandTracking.HandKeyPose.L: break;case MLHandTracking.HandKeyPose.Ok: break;case MLHandTracking.HandKeyPose.Pinch: break;case MLHandTracking.HandKeyPose.Thumb: break;case MLHandTracking.HandKeyPose.NoHand: break;case MLHandTracking.HandKeyPose.NoPose: break;case MLHandTracking.HandKeyPose.OpenHand: break;}
取得されたジェスチャ.

*{services.AddDbContext<;ApplicationDbContext>;(options =>;options.UseNpgsql(Configuration.GetConnectionString("DefaultConnection")));...}
This method gets called by the runtime. Use this method to add services to the container.
初期設定できてないので初期設定画面を表示
*context.Response.Redirect("/Initialize");
初期設定できてないので初期設定画面を表示
*context.Response.Redirect("/Initialize");

接続中
*else
切断中
*};

*[Route("~
About")]  e.g https:localhost:5001About

*HttpResponseMessage responseMessage = await Http.PostAsJsonAsync<;SomeType<;("https:
localhost:12345apiGetPdf", parameter);

パスの取得
*var path = EditorUtility.OpenFilePanel("Open csv", "", "CSV");
読み込み
*var reader = new StreamReader(path);

*{ColorMap[] colorMap = new ColorMap[256];for (int j = 0; j <; colorMap.Length; j++){colorMap[j] = new ColorMap(){OldColor = Color.FromArgb(j, 255, 255, 255),NewColor = Color.FromArgb(j * catColor.A / 255, catColor.R, catColor.G, catColor.B),};}attr.SetRemapTable(colorMap);}
remap color table
*for (int i  = 0; i <; imgIconBufs.Length; i++)*{
recreate icons
*{Graphics g = Graphics.FromImage(imgBuf);g.Clear(bgColor);g.DrawImage(imgCat, new Rectangle(new Point(0, 0), imgCat.Size), 0, 0, imgCat.Width, imgCat.Height, GraphicsUnit.Pixel, attr);}
bg
再作成時、古いHICONは必ず廃棄する！
*DestroyIcon(icons[i].Handle);

*for (int i = 0; i <; inputCount; i++)*{
要素注入
自作
*sw.Start();
*{int ret = 0;for (int i = 0; i <; inputCount; i++){if (inputs[i] >;= target){ret++;}}return ret;}
targer以上の要素の個数を返す

*{
以下略

Configureメソッドを実行する前にランタイムから呼び出される
DIコンテナにサービスを登録する
登録したサービスはアプリケーション全体(Configureメソッドも含む)で使用できる
*public void ConfigureServices(IServiceCollection services)
ランタイムから呼び出される
httpリクエストを処理するパイプラインを定義する
*public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
*// https://docs.microsoft.com/en-us/aspnet/core/security/enforcing-ssl?view=aspnetcore-3.1&amp;tabs=visual-studio#usehttpsredirection*app.UseHttpsRedirection();
httpで接続してきたクライアントをhttpsで再接続させる
静的ファイルを返せるようにする
https:docs.microsoft.com/en-us/aspnet/core/fundamentals/static-files?view=aspnetcore-3.1
*app.UseStaticFiles();
リクエストの内容に応じて、アプリで定義したエンドポイントを選択する
https:docs.microsoft.com/ja-jp/aspnet/core/fundamentals/routing?view=aspnetcore-3.1
*app.UseRouting();
UseRoutingの後に配置したミドルウェアではhttpコンテキストからエンドポイントの情報を取得できる
リクエストに対応するエンドポイントが存在しない場合はendpointの値はnullになる
*var endpoint = context.GetEndpoint();
*{endpoints.MapRazorPages();});
エンドポイントとデリゲートを関連付ける
*{services.AddControllers();}
This method gets called by the runtime. Use this method to add services to the container.
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseExceptionHandler();}app.UseHttpsRedirection();app.UseRouting();// UseExtensions.Use// https://github.com/dotnet/aspnetcore/blob/425c196cba530b161b120a57af8f1dd513b96f67/src/Http/Http.Abstractions/src/Extensions/UseExtensions.cs#L21app.Use(async (context, next) =>;{// nextの前に実行したい処理await next();// nextの後に実行したい処理});// IApplicationBuilder.Use// https://github.com/dotnet/aspnetcore/blob/8efcca43ceaaf72281e17f25d759844f488914ac/src/Http/Http/src/Builder/ApplicationBuilder.cs#L72app.Use((next) =>;{// nextの前に実行したい処理return next;});// UseExtensions.Use の中では IApplicationBuilder.Use を使っていて// 意味的には大体こんな感じになっているapp.Use((next) =>;{// 型推論が効いているおかげで簡単に書ける。気持ちいい// Task RequestDelegate(HttpContext context)return async (context) =>;{// next の前に実行したい処理await next(context);// next の後に実行したい処理};});app.UseAuthorization();app.UseEndpoints(endpoints =>;{endpoints.MapControllers();});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
*{// nextの前に実行したい処理await next();// nextの後に実行したい処理});
https:github.com/dotnet/aspnetcore/blob/425c196cba530b161b120a57af8f1dd513b96f67/src/Http/Http.Abstractions/src/Extensions/UseExtensions.cs#L21
nextの前に実行したい処理
*await next();
nextの後に実行したい処理
*});
*{// nextの前に実行したい処理return next;});
https:github.com/dotnet/aspnetcore/blob/8efcca43ceaaf72281e17f25d759844f488914ac/src/Http/Http/src/Builder/ApplicationBuilder.cs#L72
nextの前に実行したい処理
*return next;
UseExtensions.Use の中では IApplicationBuilder.Use を使っていて
意味的には大体こんな感じになっている
*app.Use((next) =>;
型推論が効いているおかげで簡単に書ける。気持ちいい
Task RequestDelegate(HttpContext context)
*return async (context) =>;
next の前に実行したい処理
*await next(context);
next の後に実行したい処理
*};
ミドルウェアのコレクション
*private readonly IList<;Func<;RequestDelegate, RequestDelegate>;>; _components;

*IOSTClient = new Client("https:
api.iost.io");

*.ValidateEagerly();
起動時に設定を検証する StartupFilter を DI に追加

図形の回転
X軸周りで回転
*double X_x = x * 1;
Y軸周りで回転
*double X_y = X_x * Math.Cos(f_roty * rad) + Z_x * Math.Sin(f_roty * rad);
Z軸周りで回転
*double X_z = X_y * Math.Cos(f_rotz * rad) - Y_y * Math.Sin(f_rotz * rad);
視点の回転
*double X_ = Math.Cos(roty * rad) * Math.Cos(rotz * rad) * X_z

こうは書けません。
int? value = text == null ? null : 100;
*,,,

*t.Type = 0;
MOUSE = 0

*.ConfigureLogging((logging) =>; {logging.ClearProviders();var logger =new LoggerConfiguration().WriteTo.Map(keySelector: logEvent =>; new DateTime(logEvent.Timestamp.Year, logEvent.Timestamp.Month, logEvent.Timestamp.Day),configure: (month, writer) =>; {writer.File(path: $"./logs/{month:yyyy}/{month:yyyyMM}/log-{month:yyyyMMdd}.txt", rollingInterval: RollingInterval.Day, restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Information);},sinkMapCountLimit: 1).WriteTo.Console(restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Information).CreateLogger();logging.AddSerilog(logger);})
snip...

*string TweetURL = "https:
twitter.comintenttweet?text=" + esctext + "&amp;hashtags=" + esctag + "&amp;url=" + url;

*{services.AddLocalization(options =>; options.ResourcesPath = "Resources");services.AddControllersWithViews().AddViewLocalization();}
This method gets called by the runtime. Use this method to add services to the container.
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseExceptionHandler("/Home/Error");// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.app.UseHsts();}var supportedCultures = new[] {System.Globalization.CultureInfo.GetCultureInfo("ja"),System.Globalization.CultureInfo.GetCultureInfo("en")};app.UseRequestLocalization(new RequestLocalizationOptions{DefaultRequestCulture = new RequestCulture(System.Globalization.CultureInfo.GetCultureInfo("ja")),SupportedCultures = supportedCultures,SupportedUICultures = supportedCultures,RequestCultureProviders = new List<;IRequestCultureProvider>;{new QueryStringRequestCultureProvider(),new CookieRequestCultureProvider()}});app.UseStaticFiles();app.UseRouting();app.UseAuthorization();app.UseEndpoints(endpoints =>;{endpoints.MapControllerRoute(name: "default",pattern: "{controller=Home}/{action=Index}/{id?}");});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*public ReactiveCommand CloseWindow { get; } = new ReactiveCommand();
プロパティ宣言
コンストラクタ内
*CloseWindow.Subscribe(x =>; ((System.Windows.Window)x).Close());
*OK.Subscribe(x =>; {result = MessageBox.Show("ウィンドウを閉じてもよろしいですか？", "確認メッセージ", MessageBoxButtons.OKCancel);if (result == DialogResult.Cancel)return;elseCloseWindow.Execute(x);});
コンストラクタ内

*_raycastParams.Position = camTransform.position;*_raycastParams.Direction = camTransform.forward;
Update the orientation data in the raycast parameters.

取得する手（右手か左手か任意の手）
*public SteamVR_Input_Sources handTypeL;

*inSerializer.Populate(jObject.CreateReader(), result);
これでOK

*return actressSearch.ToActressList();
データベース用クラス変換

*driver.Navigate().GoToUrl($"https:
translate.google.com?sl=en&amp;tl=ja");

*var response = await client.GetAsync("http:
localhost:5001testsync");

*double rotateX = 1, rotateY = 0, rotateZ = 0;
カメラの回転による移動
glControlの追加
*GLControl glControl;
GLControlの初期化
*glControl = new GLControl();
イベントハンドラ
*glControl.Load += new EventHandler(glControl_Load);
*if (e.Button == MouseButtons.Right)*{
右ボタンが押された場合
*if (e.Button == MouseButtons.Right)*{
右ボタンが押された場合
*if (isCameraRotating)*{
カメラが回転状態の場合
*if (zoom >; 4.0f)*zoom = 4.0f;
拡大、縮小の制限
バッファのクリア
*GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
カメラ設定
*Vector3 vec_rotate = new Vector3((float)rotateX, (float)rotateY, (float)rotateZ);
表示設定
*GL.MatrixMode(MatrixMode.Modelview);
3D形状の表示
*DrawPolygons(polygon);
バッファの入れ替え
*glControl.SwapBuffers();
描画
*GL.Begin(PrimitiveType.Triangles);
*for (int l = 0; l <; polygon.Faces.Count; l++)*{![Something went wrong]()
三角形を描画
Numerics.Vector3をOpenTK.Vector3に変換します。
*private static OpenTK.Vector3 N2TK(System.Numerics.Vector3 vec3) =>; new Vector3(vec3.X, vec3.Z, vec3.Y);
*{int width = glControl.Width;int height = glControl.Height;float[] floatArr = new float[width * height * 3];OpenCvSharp.Mat ret = new OpenCvSharp.Mat(height, width, OpenCvSharp.MatType.CV_32FC3);// dataBufferへの画像の読み込みIntPtr dataBuffer = Marshal.AllocHGlobal(width * height * 12);GL.ReadBuffer(ReadBufferMode.Front);GL.ReadPixels(0, 0, width, height, PixelFormat.Bgr, PixelType.Float, dataBuffer);// imgへの読み込みMarshal.Copy(dataBuffer, floatArr, 0, floatArr.Length);// opencvsharp.Matへの変換Marshal.Copy(floatArr, 0, ret.Data, floatArr.Length);// 破棄Marshal.FreeHGlobal(dataBuffer);return ret;}
画像の保存
dataBufferへの画像の読み込み
*IntPtr dataBuffer = Marshal.AllocHGlobal(width * height * 12);
imgへの読み込み
*Marshal.Copy(dataBuffer, floatArr, 0, floatArr.Length);
opencvsharp.Matへの変換
*Marshal.Copy(floatArr, 0, ret.Data, floatArr.Length);
破棄
*Marshal.FreeHGlobal(dataBuffer);
形状の読み込み
*var polygon = SurfaceAnalyzer.LoadData.LoadSTL(@"local\cube3_とんがり2.STL", true);
形状のレンダリング
*viewer.Render(polygon);
形状の読み込み
*var polygon = SurfaceAnalyzer.LoadData.LoadSTL(@"local\cube3_とんがり2.STL", true);
形状のレンダリング
*viewer.Render(polygon);
*{// 画像の表示Cv2.ImShow("mat", mat);// 画像の保存Cv2.ImWrite(@"local\mat.jpg", mat * 256);}
viewerの画像の取得
画像の表示
*Cv2.ImShow("mat", mat);
画像の保存
*Cv2.ImWrite(@"local\mat.jpg", mat * 256);

*if (args.Length <; 0)
引数が指定されていればyournameに代入
*{Console.WriteLine("Hello. {0}さん!", name);}
挨拶を表示する処理
*if (args.Length == 0)*{
挨拶を返す処理はMainに書かずに関数に書くようにした
*{string[] yourname = System.Environment.GetCommandLineArgs();for (int ti = 1; ti <; yourname.Length; ti++){Console.WriteLine("Hello. {0}さん!", yourname[ti]);}}
挨拶を表示する処理

*if (loadCSV.csvFile == null)*{
ボタンを押されたらパース実行
csvファイルをstring形式に変換
*string csvText = loadCSV.csvFile.text;
改行ごとにパース
*string[] afterParse = csvText.Split('\n');
*for (int i = 1; i <; afterParse.Length; i++)*{
ヘッダー行を除いてインポート
*if (parseByComma[column] == "")*{
先頭の列が空であればその行は読み込まない
ファイルを作成
*string fileName = parseByComma[column] + ".asset";
一応今回はResourcesに生成
*string path = "Assets/Resources/" + fileName;
PokeDexのインスタンスをメモリ上に作成
*PokeDex pokedex = CreateInstance<;PokeDex>;();
*if (!String.IsNullOrEmpty(parseByComma[column]))*{
タイプ1
*if (!String.IsNullOrEmpty(parseByComma[column]))*{
タイプ2
*if (!String.IsNullOrEmpty(parseByComma[column]))*{
H種族値
*if (!String.IsNullOrEmpty(parseByComma[column]))*{
A種族値
*if (!String.IsNullOrEmpty(parseByComma[column]))*{
B種族値
*if (!String.IsNullOrEmpty(parseByComma[column]))*{
C種族値
*if (!String.IsNullOrEmpty(parseByComma[column]))*{
D種族値
*if (!String.IsNullOrEmpty(parseByComma[column]))*{
S種族値
*if (!String.IsNullOrEmpty(parseByComma[column]))*{
特性1
*if (!String.IsNullOrEmpty(parseByComma[column]))*{
特性2
*if (!String.IsNullOrEmpty(parseByComma[column]))*{
特性3
*if (!String.IsNullOrEmpty(parseByComma[column]))*{
図鑑No.
インスタンス化したものをアセットとして保存
*var asset = (PokeDex)AssetDatabase.LoadAssetAtPath(path, typeof(PokeDex));
指定のパスにファイルが存在しない場合は新規作成
*AssetDatabase.CreateAsset(pokedex, path);
指定のパスに既に同名のファイルが存在する場合は更新
*EditorUtility.CopySerialized(pokedex, asset);
*if (loadCSV.csvFile == null)*{
ボタンを押されたらパース実行
csvファイルをstring形式に変換
*string csvText = loadCSV.csvFile.text;
改行ごとにパース
*string[] afterParse = csvText.Split('\n');
*for (int i = 1; i <; afterParse.Length; i++)*{
ヘッダー行を除いてインポート
*if (parseByComma[column] == "")*{
先頭の列が空であればその行は読み込まない
ファイルを作成
*string fileName = parseByComma[column] + ".asset";
一応今回はResourcesに生成
*string path = "Assets/Resources/" + fileName;
PokeDexのインスタンスをメモリ上に作成
*PokeDex pokedex = CreateInstance<;PokeDex>;();
タイプ～図鑑Noまで取得(省略)
*List<;Sprite>; SpriteList = NonResources.LoadAll<;Sprite>;("Assets/Image/PokeDex");
インスタンス化したものをアセットとして保存
*var asset = (PokeDex)AssetDatabase.LoadAssetAtPath(path, typeof(PokeDex));
指定のパスにファイルが存在しない場合は新規作成
*AssetDatabase.CreateAsset(pokedex, path);
指定のパスに既に同名のファイルが存在する場合は更新
*EditorUtility.CopySerialized(pokedex, asset);

*using (UnityWebRequest www = UnityWebRequestMultimedia.GetAudioClip("file:
" + filename, AudioType.OGGVORBIS))

口のオブジェクトのY軸のスケールをLerpで滑らかに動かす
*float targetMouthSize = Mathf.Lerp(0.1f, 1.0f,100 * _voice.RecorderInUse.LevelMeter.CurrentAvgAmp);
口の動きを同期通信させる
*photonView.RPC(nameof(SyncMouth),RpcTarget.All,_mouthSize);

月～金が表示される
*}

*var requestUrl = "https:
" + storeUrl + endPoint + "?limit=250&amp;fields=email,first_name,last_name";
*ShopifyCustomerSavedSearcheCustomers.link = apiHeaderCollectionLinkKeyValuePairString;*,,,
Append page_info

*driver.Navigate().GoToUrl(@"https:
www.w3schools.comcsscss_selectors.asp");
FindElementで単数形
*IWebElement elm = driver.FindElement(By.CssSelector(".w3-example"));
FindElement"s"  で複数形
*ReadOnlyCollection<;IWebElement>;  itemList= driver.FindElements(By.CssSelector(".w3-example"));

*Console.WriteLine("{0} =>; {1}", new object[]{name, encInfo});
encInfo = "*************************";

*{public class MainWindowViewModel : BindableBase{private Visibility _MyUserControlVisibility = Visibility.Hidden;public Visibility MyUserControlVisibility{get { return _MyUserControlVisibility; }set { SetProperty(ref _MyUserControlVisibility, value); }}}public class MainWindow : Window{public MainWindow(){InitializeComponent();}}}
usingは省略。Prismを使用しています
*{public class MyUserControlViewModel : BindableBase{private Visibility _Visibility = Visibility.Hidden;public Visibility Visibility{get { return _Visibility; }set { SetProperty(ref _Visibility, value); }}}public class MyUserControl : UserControl{public MyUserControl(){InitializeComponent();}}}
usingは省略
*{public class MainWindowViewModel{private MyUserControlViewModel _MyControl1VM;public MyUserControlViewModel MyControl1VM{get { return _MyControl1VM; }set { SetProperty(ref _MyControl1VM, value); }}public class MainWindow : Window{public MainWindow(){InitializeComponent();MainWindowViewModel VM = DataContext;VM.MyControl1VM = MyControl1.DataContext;}}},,,
重複をチェックする
*var result1 = collection.HasDuplicate(c =>; c);
重複を除去する
*var result2 = collection.DistinctByKey(c =>; c);

*IndexName = "Date-Time-index"
利用する GSI を指定

ルームは全員固定
*const string roomName = "SampleRoom";
ルームに参加&amp;ルームを保持
*this.room = await this.Group.AddAsync(roomName);
自分の情報も保持
*me = player;
参加したことをルームに参加している全メンバーに通知
*this.Broadcast(room).OnJoin(me.Name);
ルーム内のメンバーから自分を削除
*await room.RemoveAsync(this.Context);
退室したことを全メンバーに通知
*this.Broadcast(room).OnLeave(me.Name);
発言した内容を全メンバーに通知
*this.Broadcast(room).OnSendMessage(me.Name, message);
サーバー上の情報を更新
*me.Position = position;
更新したプレイヤーの情報を全メンバーに通知
*this.Broadcast(room).OnMovePosition(me);
*Console.WriteLine($"client connected {this.Context.ContextId}");
handle connection if needed.
*// on disconnecting, if automatically removed this connection from group.*return CompletedTask;
handle disconnection if needed.
普通の API の呼び出しはコメントアウトしておきます
残しておいても問題はないです（リアルタイム通信と両方動きます）
this.SampleServiceTest(1, 2);
*this.SampleHubTest();
*{Name = "Minami",Position = new Vector3(0, 0, 0),Rotation = new Quaternion(0, 0, 0, 0)};
自分のプレイヤー情報を作ってみる
ゲームに接続する
*await this.sampleHub.JoinAsync(player);
チャットで発言してみる
*await this.sampleHub.SendMessageAsync("こんにちは！");
位置情報を更新してみる
*player.Position = new Vector3(1, 0, 0);
ゲームから切断してみる
*await this.sampleHub.LeaveAsync();

*services.AddScoped<;CookieService<;();
★この行を追加★
*if (firstRender)*{
IsPostbackプロパティのような感じ?
セッションIDを持っていなければクッキーに埋め込む
*var newSessionID = Guid.NewGuid().ToString();
セッションIDを持っていなければクッキーに埋め込む
*await CookieService.WriteCookieAsync(SessinID, newSessionID).ConfigureAwait(false);
セッションIDを持っておりローカルストレージにもログイン情報がある場合
*var loginData = await LocalStorage.GetItemAsync<;LoginData>;(sessionID.Value).ConfigureAwait(false);
セッションIDを持っていなければクッキーに埋め込む
*var newSessionID = Guid.NewGuid().ToString();

*if (invertYAxis)*i *= -1f;
handle inverting vertical input
*if (invertYAxis)*i *= -1f;
handle inverting vertical input

*public static Setting Values { get; private set;}
外部に公開する為の static プロパティ
シリアライズするプロパティは public にして getter と setter が必要。
ウィンドウが最小化された状態で閉じられると Location.X や Location.Y がとんでもない画面外になるが、対処は簡単なので省略。
シリアライズ時に public な getter が必須。 デシリアライズ時に public な setter が必須。
*public int FormLocationX { get; set;}
*public Setting(){}
public コンストラクタは JsonSerializer に必須な模様。
*{if(Values == null)Values = new Setting();File.WriteAllText("settings.json", JsonSerializer.Serialize(Values, new JsonSerializerOptions() { WriteIndented = true }), Encoding.UTF8);}
保存するメソッド
*{if (!File.Exists("settings.json"))Save();Values = JsonSerializer.Deserialize<;Setting>;(File.ReadAllText(ConfigFileName, Encoding.UTF8));}
読み出して Setting クラスのインスタンスを生成して Values プロパティに割り当てるメソッド
読み出し
*Setting.Load();
保存
*Setting.Values.FormLocationX = Location.X;

*var menuStrip1 = new MenuStrip();
https:dobon.netvbdotnetcontrolmenustrip.html
*//        fileMenuItem.DropDownItems.Add( new ToolStripMenuItem("保存(&amp;S)...", null, (s,e)=>;{SaveTemplateWithDialog();}, Keys.Control | Keys.S) );
fileMenuItem.DropDownItems.Add( new ToolStripMenuItem("開く(&amp;O)...", null, (s,e)=&gt;{OpenTemplateWithDialog();}, Keys.Control | Keys.O) );
*//        editMenuItem.DropDownItems.Add( new ToolStripMenuItem("アイコン(.ico)として保存(&amp;I)...", null, (s,e)=>;{SaveImageWithDialog("ico");}, Keys.Control | Keys.I) );
fileMenuItem.DropDownItems.Add( new ToolStripMenuItem("保存(&amp;S)...", null, (s,e)=&gt;{SaveTemplateWithDialog();}, Keys.Control | Keys.S) );
*//        editMenuItem.DropDownItems.Add( new ToolStripMenuItem("画像(.png)として保存(&amp;P)...",     null, (s,e)=>;{SaveImageWithDialog("png");}, Keys.Control | Keys.P) );
editMenuItem.DropDownItems.Add( new ToolStripMenuItem("アイコン(.ico)として保存(&amp;I)...", null, (s,e)=&gt;{SaveImageWithDialog("ico");}, Keys.Control | Keys.I) );
*dgv = new DataGridView() {//Location = new Point(0, 0),//Size = new Size(800, 400),Dock = DockStyle.Fill,AllowUserToAddRows = false,AutoGenerateColumns = false,AllowDrop = true,}
editMenuItem.DropDownItems.Add( new ToolStripMenuItem("画像(.png)として保存(&amp;P)...",     null, (s,e)=&gt;{SaveImageWithDialog("png");}, Keys.Control | Keys.P) );
*dgv.Columns.Add(new DataGridViewTextBoxColumn(){Width = 100, DataPropertyName = "FolderPath",    Name = "FolderPath",    HeaderText = "場所",       ReadOnly=true});
https:dobon.net/vb/dotnet/datagridview/addcolumn.html

workbookオブジェクトを作成します。
*Workbook workbook = new Workbook();
Excelをロードします。
*workbook.LoadFromFile("Sample.xlsx");
シートを取得します。
*Worksheet sheet = workbook.Worksheets[0];
イメージで保存します。
*sheet.SaveToImage("ExceltoImage.png", ImageFormat.Png);

Index.razorから参照するのでインスタンス生成をしておかないとエラーとなる
*LoginData = new LoginData();
Regionが「USEast1」なのは作成したPoolIDのプレフィックスと同じにしている為
*using var provider = new AmazonCognitoIdentityProviderClient(new AnonymousAWSCredentials(), Region);

*.WithAutomaticReconnect(new RandomRetryPolicy())
自動接続
入力文字列の中にURLが存在するかどうかを判定だけする
*var urlPattern = new Regex(@"(https?|ftp)(:\/\/[-_.!~*\'()a-zA-Z0-9;\/?:\@&amp;=+\$,%#]+)");
入力文字列をサニタイズする
*message = HttpUtility.HtmlEncode(message);
*if (urlPatternMatch.Success)*{
入力文字列の中にURLが存在する場合はアンカータグに変換する
画面の更新を行う
*await _hubConnection.StartAsync();
2～5秒の間でランダムに再接続を試みる
*return TimeSpan.FromSeconds(_random.Next(2, 5));
入力文字列の中にURLが存在するかどうかを判定だけする
*var urlPattern = new Regex(@"(https?|ftp)(:\/\/[-_.!~*\'()a-zA-Z0-9;\/?:\@&amp;=+\$,%#]+)");
入力文字列をサニタイズする
*message = HttpUtility.HtmlEncode(message);
*if (urlPatternMatch.Success)*{
入力文字列の中にURLが存在する場合はアンカータグに変換する
2～5秒の間でランダムに再接続を試みる
*return TimeSpan.FromSeconds(_random.Next(2, 5));

Index.razorから参照するのでインスタンス生成をしておかないとエラーとなる
*LoginData = new LoginData();

*pathTextBox1.Size.Height
テキストボックス高さ
*string PRBUTTON_NAME = $"progRefeButton{numberofAPBClicks+1}";
progRefeButton
ラベルを生成するメソッド
引数にはName属性、表示されるテキスト、ラベルの表示位置を渡す
*private void createLabel(string name, string text, int[] locate)
ラベルのインスタンス生成
*Label label = new Label();
プロパティ設定
*label.Name = name;
ラベルをパネルの子要素として追加
*allProgPanel.Controls.Add(label);
テキストボックスを生成するメソッド
引数にはName属性、ボックスの表示位置、ボックスの大きさを渡す
*private void createTextBox(string name, int[] locate, int[] size)
ボタンを生成するメソッド
引数にはName属性、ボタンに表示されるテキスト、ボタンの表示位置、ボタンの大きさを渡す
*private void createButton(string name, string text, int[] locate, int[] size)

*comboBox.DataSource = ItemList;
ItemListは、DBからSELECTしたエンティティクラスのリスト
上記のコードを実行すると、System.ArgumentOutOfRangeException が発生する。
Unhandled exception. System.ArgumentOutOfRangeException: '0' の InvalidArgument=Value は 'SelectedIndex' に対して有効ではありません。 (Parameter 'value')
Actual value was 0.
*,,,

処理
*}
直接叩く
*ObserveCPUTick(null, EventArgs.Empty);

*}
対策コード

*Console.WriteLine(ex.SqlState);
42703

エクスポートするパースを指定します。
*String inputFile = @"C:\Users\Administrator\Desktop\sample.pdf";
保存するパースを指定します。
*String outputFolder = @"C:\Users\Administrator\Desktop\Output\";
PdfStandardsConverterオブジェクトを作成します。
*PdfStandardsConverter converter = new PdfStandardsConverter(inputFile);
PdfA1Aで保存します。
*converter.ToPdfA1A(outputFolder + "ToPdfA1A.pdf");
PdfA1Bで保存します。
*converter.ToPdfA1B(outputFolder + "ToPdfA1B.pdf");
PdfA2Aで保存します。
*converter.ToPdfA2A(outputFolder + "ToPdfA2A.pdf");
PdfA2Bで保存します。
*converter.ToPdfA2B(outputFolder + "ToPdfA2B.pdf");
PdfA3Aで保存します。
*converter.ToPdfA3A(outputFolder + "ToPdfA3A.pdf");
PdfA3Bで保存します。
*converter.ToPdfA3B(outputFolder + "ToPdfA3B.pdf");

*.Range(1, 3)
1～3の数値を取得する
*channel.Writer.TryWrite($"Producer:{producerNumber} Message {i}");
await channel.Writer.WriteAsync($"Producer:{producerNumber} Message {i}");

メソッド内でなにか処理をできる
*name = e.Value.ToString();

gitのパスを取得する。
*string gitPath = GetGitPath();
gitのコマンドを設定する。
*string gitCommand = "config core.autocrlf";
コマンドを実行して標準出力を取得する。
*string autocrlf = GetStandardOutputFromProcess(gitPath, gitCommand).Trim();
*if (Application.platform == RuntimePlatform.OSXEditor)*{
Macのとき
*{"/usr/local/bin/git","/usr/bin/git"};
パスの候補
存在するパスで最初に見つかったもの
*return exePaths.FirstOrDefault(exePath =>; File.Exists(exePath));
Windowsはこれだけで十分
*return "git";
*{FileName = exePath,Arguments = arguments,WindowStyle = ProcessWindowStyle.Hidden,UseShellExecute = false,RedirectStandardOutput = true,};
プロセスの起動条件を設定する。
*{// 標準出力を取得する。string output = process.StandardOutput.ReadToEnd();// プロセスが終了するかタイムアウトするまで待つ。process.WaitForExit(TimeoutPeriod);return output;}
プロセスを起動する。
標準出力を取得する。
*string output = process.StandardOutput.ReadToEnd();
プロセスが終了するかタイムアウトするまで待つ。
*process.WaitForExit(TimeoutPeriod);

*services.AddSingleton<;Service<;();
ここでは引数に関する情報を伝えない
生成時に引数を渡せる。ただしprovider.GetService&lt;Service&gt;() という書き方はできない
引数が (ServiceProvider, params object[]) なのでIntellisenseも効かない
*var instance = ActivatorUtilities.CreateInstance<;Service>;(provider, "SomethingMessage");
型チェックがないので、stringを渡すべき場所に何でも渡せてしまう
これは実行時エラーになる
*var invalid = ActivatorUtilities.CreateInstance<;Service>;(provider, DateTime.Now);
*{public Service(string message) { }}
これは今からnewしたいクラス
ファクトリー定義の時点で引数の情報を伝えておく
*Service ResolveService(string message);
生成されるクラスは以下のような感じ
*internal partial class Factory : IFactory
生成時に引数を渡せる。静的コード生成なのでIntellisenseも効く
*var instance = factory.ResolveService("SomethingMessage");
型チェックが効くので、これはコンパイルエラーになる
*var invalid = factory.ResolveService(DateTime.Now);
*class Service { }
newしたいクラス Service, Service2, Client
ConfigureGenericHost 属性をつけると、GenericHostで使えるようになる
*[Factory]
GenericHost の ServiceCollection インスタンスに、ファクトリーのインスタンスを登録する
*services.UseDeptorygenFactory(new Factory());
Factory クラスで解決できる依存関係が、ServiceProvider からも解決できるようになる
*serviceProvider.GetService<;Client>;().Work();
*{// キャッシュはファクトリー側が管理するので、すべてTransientservices.AddTransient<;IFactory>;(provider =>; this);services.AddTransient<;Service>;(provider =>; ResolveService());services.AddTransient<;Service2>;(provider =>; ResolveService2());services.AddTransient<;Client>;(provider =>; ResolveClient());}
GenericHostと連携するためのメソッド
キャッシュはファクトリー側が管理するので、すべてTransient
*services.AddTransient<;IFactory>;(provider =>; this);

*transform.position += new Vector3(-x, 0, -z);
上下左右を反転させて、押したキーとキャラクターの動きにイメージとのズレがないようマイナス記号をつけた

*if (lastDragHoverd == null || !lastDragHoverd.SequenceEqual (eventData.hovered)) {
異なるときだけ

int型のデータを送信する場合
*ISnmpData data = new Integer32(val);
string型のデータを送信する場合
ISnmpData data = new OctetString(val);
*var test = new Variable(new ObjectIdentifier(oid), data);
*foreach (Variable v in reply.Pdu().Variables)*{
結果を出力
*var test = new Variable(new ObjectIdentifier(oid));*var vList = new List;Variable>;();
取得したいOID
*foreach (Variable v in reply.Pdu().Variables)*{
結果を出力

*source.OnComplete();
ソースが終了したタイミングで現在の値も Dispose される

値の設定
*Properties.Settings.Default.Setting1 = "a"
全部まとめて保存
*Properties.Settings.Default.Save();

*{textBox.ForeColor = Color.Blue;}
青くするのサブルーチン
*{if( textBox.Text != "0"){textBox.ForeColor = Color.Red;}}
赤くするのサブルーチン
*for (int jj = 1; jj <;= 9; jj++)*{
各マスの設定できる数字の初期化

*case ".mp3":
This is fall through so it's not that i forget break;

*LogFilePath = Path.Combine(LogDirPath, "Application.log");
出力ファイル名

コマンドライン引数はありません
*return;

*if ( filePath.EndsWith(".mp3", true, null) ) {
Note: 第2引数はignoreCase
new ListViewItem(new string[]{"コメント", id3v2.Comment}),
*}

*services.AddDbContext<;Models.wbContext<;();
この行

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

*Root myDeserializedClass = JsonConvert.DeserializeObject<;Root<;(myJsonResponse);
デシリアライズコード

*.ToReactiveCommand();
実行可能なコマンド
文字列から Dispose が必要なオブジェクトに変換
*.Select(x =>; new SomeDisposableClass(x))
最新の値以外は Dispose する
*.DisposePreviousValue()
ReadOnlyReactivePropertySlim 化
*.ToReadOnlyReactivePropertySlim();
first を元に SomeDisposableClass が作られる
*source.OnNext("first");
second を元に SomeDisposableClass が作られる
first を元に作られた SomeDisposableClass は Dispose が呼ばれる
*source.OnNext("second");
OnComplete が呼ばれると最新の値に対して Dispose が呼ばれる
*source.OnComplete();

*private const string winAppDriverURL = "http:
127.0.0.1:4723";
Desktopとsessionとる
*DesiredCapabilities desktopCapabilities = new DesiredCapabilities();
起動済みExcelとsessionとる
*DesiredCapabilities appCapabilities = new DesiredCapabilities();
*if (session != null)*{
Close the application and delete the session
*for (int i = 0; i <; 10; i++)*{
begin speed test
*for (int i = 0; i <; 10; i++)*{
begin speed test
*for (int i = 0; i <; 10; i++)*{
begin speed test

*string windowName = "net_clock";
Unityで設定するアプリ名とそろえる。

*{client.BaseAddress = Configuration.GetServiceUri("backend");});
ここから
ここまで
*}
*{o.Configuration = Configuration.GetConnectionString("redis");});
ここから
ここまで
*}

BBBタブを選択状態にする
*BBB.IsSelected = true;
CCCタブを選択状態にする
*CCC.IsSelected = true;

*cashDrawer.OpenDrawer();
キャッシュドロアを開く

*posPrinter.PrintMemoryBitmap(PrinterStation.Receipt, newBmp, PosPrinter.PrinterBitmapAsIs, PosPrinter.PrinterBitmapRight);
これでOK

*};
...(A)

*if (GetSystemMetrics(SM_REMOTESESSION) != 0)*return true;
Remote desktop
*{var subKey = Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Avalon.Graphics");if (subKey != null){var d = (int) subKey.GetValue("DisableHWAcceleration");if (d != 0)return true;}}
DisableHWAcceleration
初期化時
*SystemEvents.SessionSwitch += SystemEventsOnSessionSwitch;
後処理時
*SystemEvents.SessionSwitch -= SystemEventsOnSessionSwitch
*if (e.Reason == SessionSwitchReason.SessionUnlock)*isSoftwareRenderingMode = MakeIsSoftwareRenderingMode():
セッションのロックが解除されたとき、リモート接続されたとき

*using System.IO.Compression;
to use zip
*// if (File.Exists(destZipPath)) {//     File.Delete(destZipPath);// }
ZipFile.Open で Zipを作成するとき、すでにファイルが存在していると例外が発生する。
*// if (File.Exists(destZipPath)) {*//     File.Delete(destZipPath);
上書きしたい場合は、すでにファイルが存在する場合は削除しておく。
*using( ZipArchive archive = ZipFile.Open(destZipPath, ZipArchiveMode.Create) ) {ZipArchiveEntry entry;entry = archive.CreateEntry("Test1.txt", CompressionLevel.Optimal);using (StreamWriter writer = new StreamWriter(entry.Open())){writer.WriteLine("FileContentSample-1");}entry = archive.CreateEntry(@"hoge\Test2.txt", CompressionLevel.Optimal);using (StreamWriter writer = new StreamWriter(entry.Open())){writer.WriteLine("FileContentSample-2");}// 既存のファイル（第一引数）を読み込んでzip内にファイルをつくる場合// archive.CreateEntryFromFile( @"C:\Test.txt", "a.txt", CompressionLevel.Optimal );}
File.Delete(destZipPath);
*using( ZipArchive archive = ZipFile.Open(destZipPath, ZipArchiveMode.Create) ) {ZipArchiveEntry entry;entry = archive.CreateEntry("Test1.txt", CompressionLevel.Optimal);using (StreamWriter writer = new StreamWriter(entry.Open())){writer.WriteLine("FileContentSample-1");}entry = archive.CreateEntry(@"hoge\Test2.txt", CompressionLevel.Optimal);using (StreamWriter writer = new StreamWriter(entry.Open())){writer.WriteLine("FileContentSample-2");}// 既存のファイル（第一引数）を読み込んでzip内にファイルをつくる場合// archive.CreateEntryFromFile( @"C:\Test.txt", "a.txt", CompressionLevel.Optimal );}
}
既存のファイル（第一引数）を読み込んでzip内にファイルをつくる場合
archive.CreateEntryFromFile( @"C:\Test.txt", "a.txt", CompressionLevel.Optimal );
*}

各関節 + 手首の分, 配列をとる.
*Thumb = new Vector3[thumb.Length + 1];
*foreach (var line in lines)*{
LineRendererの初期セッティング.
*{Ok,Finger,Thumb,OpenHand,Fist,NoPose,NoHand,}
ジェスチャ.
HandTrackingを開始する.
*MLHandTracking.Start();
各ジェスチャを登録.
*gestures[0] = MLHandTracking.HandKeyPose.Ok;

*Console.WriteLine(RpnCalculator<;double<;.Calculate("-1 0
"));    -∞

*.AddTo(Disposables);
コマンド自身を追加する場合は AddTo
今回の ViewModel は不要になったタイミングで Dispose が呼ばれる想定
*public void Dispose() =>; Disposables.Dispose();

ここからIPアドレスやポートの設定
着信データ用のデータバッファー。
*byte[] bytes = new byte[1024];
ここまでIPアドレスやポートの設定
ソケットの作成
*Socket listener = new Socket(ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
通信の受け入れ準備
*listener.Bind(localEndPoint);
通信の確率
*Socket handler = listener.Accept();
任意の処理
データの受取をReceiveで行う。
*int bytesRec = handler.Receive(bytes);
大文字に変更
*data1 = data1.ToUpper();
クライアントにSendで返す。
*byte[] msg = Encoding.UTF8.GetBytes(data1);
ソケットの終了
*handler.Shutdown(SocketShutdown.Both);
今回送るHello World!
*string st = "Hello World!";
IPアドレスやポートを設定している。
*IPHostEntry ipHostInfo = Dns.GetHostEntry(Dns.GetHostName());
ソケットを作成
*Socket socket = new Socket(ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
接続する。失敗するとエラーで落ちる。
*socket.Connect(remoteEP);
Sendで送信している。
*byte[] msg = Encoding.UTF8.GetBytes(st + "<;EOF>;");
Receiveで受信している。
*byte[] bytes = new byte[1024];
ソケットを終了している。
*socket.Shutdown(SocketShutdown.Both);

X軸周りで回転
*double X_x = x * 1;
Y軸周りで回転
*double X_y = X_x * Math.Cos(roty * (Math.PI / 180)) + Z_x * Math.Sin(roty * (Math.PI / 180));
Z軸周りで回転
*double X_z = X_y * Math.Cos(rotz * (Math.PI / 180)) - Y_y * Math.Sin(rotz * (Math.PI / 180));

*Console.WriteLine(rp.Value);
okazuki のまま

メール送信用のパラメータを「appsettings.json」から抜きしてDIで利用できるようにしている
*services.Configure<;SendMailParams>;(Configuration.GetSection("SendMailParams"));
メール送信用のクラスを認証時に利用するメール送信サービスとして登録。これで認証時に確認メールが送信できるようになる
*services.AddScoped<;IEmailSender, MailSender.MailSender>;();
メールによる確認を有効にした認証を有効にする
*services.AddDefaultIdentity<;IdentityUser>;(options =>; options.SignIn.RequireConfirmedAccount = true)

*.AddRoles<;IdentityRole<;()
&lt;&lt;== ロールを利用するためにの追加
*{options.FallbackPolicy = new AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build();});
基本的に指定のないページはすべて認証が必要になるように設定
初期化時のロール
public static readonly string SystemManagerRole = "SystemManager";       システム管理権限
初期化時のシステム管理ユーザーID
public static readonly string StstemManageEmail = "system@test.com";             最初のシステム管理ユーザーのメールアドレス
public static readonly string StstemManagePassword = "!initialPassword01";       最初のシステム管理ユーザーの初期パスワード
public static readonly string NormalUserEmail = "user@test.com";                 テスト用一般ユーザーのメールアドレス
public static readonly string NormalUserPassword = "!User01";                    テスト用一般ユーザーの初期パスワード
*public static async Task Initialize(IServiceProvider serviceProvider)
ユーザー管理を取得(using Microsoft.Extensions.DependencyInjectionがないとエラーになる)
*var userManager = serviceProvider.GetService<;UserManager<;IdentityUser>;>;();
初期のユーザーマネージャーが存在しなければロールの作成と初期システムユーザーを作成する
*var systemManager = await userManager.FindByNameAsync(StstemManageEmail);
ロール管理を取得
*var roleManager = serviceProvider.GetService<;RoleManager<;IdentityRole>;>;();
ロールの追加
await roleManager.CreateAsync(new IdentityRole(SystemManagerRole));     システム管理ロール
初期システム管理者の作成
なぜか知らないが、デフォルトのログイン画面はユーザーIDではなくメールアドレスを要求し、バリデーションもメールで設定されている。
ところが、ログイン処理自体は「Email」ではなく「UserName」で行われるので両方に設定せざるを得ない。
なんでこんなことのなっているのか？　変更するにはログイン画面を変えればいい
*systemManager = new IdentityUser { UserName = StstemManageEmail, Email = StstemManageEmail, EmailConfirmed = true };
システム管理ユーザーにシステム管理ロールを追加
*systemManager = await userManager.FindByNameAsync(StstemManageEmail);
*var normalUser = new IdentityUser { UserName = NormalUserEmail, Email = NormalUserEmail, EmailConfirmed = true };
テスト用の一般ユーザー作成
これが元の1行
CreateHostBuilder(args).Build().Run();
*var host = CreateHostBuilder(args).Build();
サービスプロバイダーの取得
*var services = scope.ServiceProvider;
初期のユーザーとロールの作成
*IdentityUserInitializer.Initialize(services).Wait();
これが元の1行
CreateHostBuilder(args).Build().Run();
*var host = CreateHostBuilder(args).Build();
サービスプロバイダーの取得
*var services = scope.ServiceProvider;
データベースの自動マイグレーション
*var context = services.GetRequiredService<;ApplicationDbContext>;();
初期のユーザーとロールの作成
*IdentityUserInitializer.Initialize(services).Wait();
認証を有効にする
services.AddDefaultIdentity&lt;IdentityUser&gt;(options =&gt; options.SignIn.RequireConfirmedAccount = true)
services.AddDefaultIdentity&lt;IdentityUser&gt;()
*services.AddIdentity<;IdentityUser, IdentityRole>;()
.AddRoles&lt;IdentityRole&gt;()  &lt;&lt;== ロールを利用するためにの追加 &lt;= AddIdentityでは不要みたい
*.AddEntityFrameworkStores<;ApplicationDbContext>;()
AddMvc()の場合はオプションを設定する必要がありそうだが...
*services.AddRazorPages();
*{options.LoginPath = $"/Identity/Account/Login";options.LogoutPath = $"/Identity/Account/Logout";options.AccessDeniedPath = $"/Identity/Account/AccessDenied";});
これを追加する
*{options.FallbackPolicy = new AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build();});
基本的に指定のないページはすべて認証が必要になるように設定

Configureメソッド内
*app.UseDefaultFiles();

*{private static Dictionary<;string, Memento>; keyValuePairs = new();static void Main(){Console.WriteLine("朝食は何を食べようかな。");Food food = new();food.PrepareFood("パン");//最初に食べたものを記憶するkeyValuePairs.Add("最初に食べたもの", food.CreateMemento());food.PrepareFood("卵焼き");//2番目に食べたものを記憶するkeyValuePairs.Add("2番目に食べたもの", food.CreateMemento());Console.WriteLine("最初に何を食べたんだっけ？");food.SetMemento(keyValuePairs["最初に食べたもの"]);Console.WriteLine("最初に食べたものは・・・");Console.WriteLine(food.DisplayFood());}}
Caretaker
最初に食べたものを記憶する
*keyValuePairs.Add("最初に食べたもの", food.CreateMemento());
2番目に食べたものを記憶する
*keyValuePairs.Add("2番目に食べたもの", food.CreateMemento());
*{private string _morningFood;public void PrepareFood(string morningFood) =>; _morningFood = morningFood;public string DisplayFood() =>; _morningFood;public Memento CreateMemento() =>; new(_morningFood);public void SetMemento(Memento memento) =>; _morningFood = memento.Str;}
Originator
*{public string Str { get; }public Memento(string str) =>; Str = str;}
Memento

base.ConfigureViewModelLocator() で既定のファクトリが設定されるので、これを上書きします。
仮引数で View のインスタンスを取得できるため、ここに対応を一元化させます。
*ViewModelLocationProvider.SetDefaultViewModelFactory(

*var channel = GrpcChannel.ForAddress("https:
kaotagrpcweb.azurewebsites.net", new GrpcChannelOptions

*Sound.Mute = false;
音を戻す

*var pokomon4 = pokomonLibrary["アネﾞデパミ"];
6

Razor テンプレート
*string typeTemplate = @".\RazorTemplates\TypeTemplate.txt";
*{@".\LoadAssemblies\mxProject.Tools.ClassDoc.dll",@".\LoadAssemblies\mxProject.Tools.ClassDoc.Razor.dll",@".\LoadAssemblies\SampleLibrary1.dll",@".\LoadAssemblies\SampleLibrary2.dll"};
読み込むアセンブリ
*{RootDirectory = @".\Documents\",TypeDocumentTemplate = File.ReadAllText(typeTemplate, Encoding.UTF8),NamespaceDocumentTemplate = File.ReadAllText(namespaceTemplate, Encoding.UTF8),};
ライターを設定（.NET Framework バージョンの場合）
ライターを設定（.NET Core バージョンの場合）
*string typeDocTemplate = File.ReadAllText(typeTemplate, Encoding.UTF8);
*{// 出力対象を決定するフィルタメソッド// ここで設定している値は ClassDocContext の初期値として設定されているものと同じですConstructorFilter = ConstructorInfoExtensions.IsRecommendOutputToDocument,TypeFilter = TypeExtenstions.IsRecommendOutputToDocument,PropertyFilter = PropertyInfoExtensions.IsRecommendOutputToDocument,FieldFilter = FieldInfoExtensions.IsRecommendOutputToDocument,MethodFilter = MethodInfoExtensions.IsRecommendOutputToDocument,EventFilter = EventInfoExtensions.IsRecommendOutputToDocument,};
コンテキストとフォーマッターを設定
出力対象を決定するフィルタメソッド
ここで設定している値は ClassDocContext の初期値として設定されているものと同じです
*ConstructorFilter = ConstructorInfoExtensions.IsRecommendOutputToDocument,
*ConstructorAnchorDefaultFormat = "{0} Constructor",
アンカーのフォーマット
*ConstructorAnchorDefaultFormat = "{0} Constructor",
ここで設定している値は MarkdownFormatter の初期値として設定されているものと同じです
型情報を読み込みます
*IReadOnlyList<;TypeWithComment>; types = TypeLoader.LoadTypes(dlls, context, null);
*foreach (var group in types.GroupBy(type =>; type.Namespace).OrderBy(group =>; group.Key))*{
名前空間ごとにグループ化します
*writer.WriteNamespaceDocument(nameSpace, formatter);*// 型の情報をドキュメントに出力します
名前空間の情報をドキュメントに出力します
*foreach (var type in group.OrderBy(type =>; type.Name))*{
型の情報をドキュメントに出力します

*messageService.Add($"HeroService: fetched hero id={id}");
TODO: ヒーロー達を取得した __後で__ メッセージを送るようにする

*top.enabled = viewportRect.max.y <;= contentBound.max.y;
上までスクロールされているか？

*Grounded = true;
Groundedをtrueにする
*Quaternion rot = Quaternion.AngleAxis(rotate_direction * rotate_speed, transform.up);*// 現在の自信の回転の情報を取得する。
オブジェクトからみて垂直方向を軸として回転させるQuaternionを作成
*Quaternion q = this.transform.rotation;*// 合成して、自身に設定
現在の自信の回転の情報を取得する。
*this.transform.rotation = rot * q;*}
合成して、自身に設定
*private Transform myTransform;*//PlayerのRigidbody
PlayerのTransform
PlayerのRigidbody
*private Rigidbody rig = null;
重力減となる惑星
*private GameObject Planet;
「Planet」タグがついているオブジェクトを格納する配列
*private GameObject[] Planets;
重力の強さ
*public float Gravity;
惑星に対するPlayerの向き
*private Vector3 Direction;
Rayが接触した惑星のポリゴンの法線
*private Vector3 Normal_vec = new Vector3(0,0,0);
Rayが当たったオブジェクトの情報を入れる箱
*RaycastHit hit;
*if (Physics.Raycast(ray, out hit, Mathf.Infinity))*{
もしRayにオブジェクトが衝突したら
*if (hit.collider.tag == "Planet")*{
Rayが当たったオブジェクトのtagがPlanetだったら
*private Transform myTransform;*//PlayerのRigidbody
PlayerのTransform
PlayerのRigidbody
*private Rigidbody rig = null;
重力減となる惑星
*private GameObject Planet;
「Planet」タグがついているオブジェクトを格納する配列
*private GameObject[] Planets;
重力の強さ
*public float Gravity;
惑星に対するPlayerの向き
*private Vector3 Direction;
Rayが接触した惑星のポリゴンの法線
*private Vector3 Normal_vec = new Vector3(0,0,0);
Rayが当たったオブジェクトの情報を入れる箱
*RaycastHit hit;
*if (Physics.Raycast(ray, out hit, Mathf.Infinity))*{
もしRayにオブジェクトが衝突したら
*if (hit.collider.tag == "Planet")*{
Rayが当たったオブジェクトのtagがPlanetだったら

*catch (ExternalException) { }
makeshiftly ignore "System.Runtime.InteropServices.ExternalException (0x800401D0)" error

*//{//  if (n >;= 100_000) return n;//  return Recurse(n + 1);//}
static int Recurse(int n)
*//  if (n >;= 100_000) return n;*//  return Recurse(n + 1);
{
*{if (n >;= 100_000) return Task.FromResult(n);return Task.Run(() =>; Recurse(n + 1));}
}

*.WithLatestFrom(
ポインターが離れたとき、最後に押された時の情報と合体させる
押した時と離れたときの間隔が shortTapThreshold 以下のときだけ通す
*.Where(pair =>; (pair.up.Timestamp - pair.down.Timestamp) <;= TimeSpan.FromMilliseconds(shortTapThreshold))

*f();
呼び出し
初見殺し
*public Command OldCommand =>;
いいね
*public Command NewCommand =>;

*using System.Numerics;
←これが必要です
引数はuint、もしくはulongになるのでint やlongで扱ってるときはキャストする
Console.WriteLine(BitOperations.PopCount(12));   2
Console.WriteLine(BitOperations.PopCount(100000000));   12
Console.WriteLine(BitOperations.PopCount(2049));  2
*}

*var debugdummy = "dummy";
デバッグ用（ブラウザ表示した状態でブレークするため）ダミー行

*sf.SetStringAlignment(ContentAlignment.BottomCenter);
ContentAlignemnetからsfにAlignmentをコピー

*foreach (Transform child in _blockParent.transform)*{
空同然だけどリスト作っとく
*_randomNumber = Random.Range(0, _blockParent.transform.childCount);*_randomInterval = Random.Range(_MIN_INTERVAL_VALUE, _MAX_INTERVAL_VALUE);
ランダムな値
選ばれたブロックの位置
*Vector3 selectedBlockPosition =
選ばれたブロックの位置は比較対象から一旦削除
*_usePositionList.Remove(selectedBlockPosition);
*foreach (Vector3 position in _usePositionList)*{
現在使用中のポジションのリストから今利用検討中のポジションが利用可能か判定
表示位置被りがないかオブジェクトの大きさでチェック
*_isSetablePositionX =
*if (!_isSetablePositionX &amp;&amp; !_isSetablePositionY &amp;&amp; !_isSetablePositionZ)*{
座標のうち、全ての軸で被っていたら置けないのでやり直し
*if (_isSetablePositionX || _isSetablePositionY || _isSetablePositionZ)*{
位置被りがどれか1つの軸で無ければ実行する
ランダムな間隔でDelay
*await UniTask.Delay(TimeSpan.FromSeconds(_randomInterval));
新しい使用中のポジションをリストに追加
*_usePositionList.Add(randomPosition);
表示位置被りがないかオブジェクトの大きさでチェック
*_isSetablePositionX = Mathf.Abs(現在利用中のX座標 - ランダムに生成したX座標) >; _blockBoxCollider.bounds.size.x ;

*cam.GetComponent<;RippleEffect<;().SetNewRipplePosition(target);
新しい波紋を生成

*double  val8  = 1.23;
1.23dと明示的に表記してもOK

デシリアライズ
*var hoge = JsonSerializer.Deserialize<;Hoge>;(File.ReadAllText(@"C:\hoge.json"), options);
シリアライズ
*var json = JsonSerializer.Serialize<;Hoge>;(hoge, options);

コンストラクタ引数はファイル名
*using var context = new LiteDatabase("./data.db");
*{Title = "たいとるうううう",Body = "ぼでえええええええ"};
エンティティ
DBへ接続
*var posts = context.GetCollection<;Post>;("posts");
Titleをユニークインデックスにする
*posts.EnsureIndex(x =>; x.Title, true);
作成
*posts.Insert(post);
再代入はバグの元なので美しくないけど・・・
*post.Title = "更新したよおおおお";
更新
*posts.Update(post);
検索
Titleが「更」で始まるもの
*var results = posts.Find(x =>; x.Title.StartsWith("更"));

*Console.WriteLine("Hello world");
文字を表示

integer 型の使用例
*int firstNumber = 0;
初期値 5
*value += 5;
初期値 11
*value -= 5;
クラス名(クラスのオブジェクト名).メソッド名
*Random dice = new Random();

*public int Sum{ get; set; } = int.MinValue;
初期化
*public string Str { get { return $"===={Sum2}===="; } set { } }
Getter定義

*app.UseStaticFiles();
追加

*'　','、','。','「','」','（','）','｛','｝','・','！','？','；','：','＿','ー','－','～','‐','＋','＊','／','＝','＾',
全角系
*{this.IsVisibleReplacedOnly,...}
表示基準に変更があったら、表示判定対象に変更があったら、CollectionViewの表示を更新する
*if (currentView.IsAddingNew)*{
なぜかCollectionViewが追加中・編集中のことがある。

*Debug.Print(new Uri(new Uri(@"http:
localhost:9999"), "api5").AbsoluteUri);

*var res = await client.GetStringAsync("https:
www.jma.go.jpjpweek319.html");
HTML をパース
*var parser = new HtmlParser();
セレクターで目的の要素をゲット
*var nodes = doc.QuerySelectorAll("#infotablefont tr:nth-child(4) td");
整形して出力
*var tokyoWeathers = string.Join(", ", nodes.Select(x =>; x.TextContent.Trim()));

*for (int j = 0; j <; 10; j++)
試行回数：10回
それぞれの平均処理速度と速度改善率を計算
*var ave1 = timeSpans.Item1.Average();
*private void EnsureCapacity(int min) {if (_items.Length <; min) {int newCapacity = _items.Length == 0? _defaultCapacity : _items.Length * 2;// Allow the list to grow to maximum possible capacity (~2G elements) before encountering >;overflow.// Note that this check works even when _items.Length overflowed thanks to the (uint) castif ((uint)newCapacity >; Array.MaxArrayLength) newCapacity = Array.MaxArrayLength;if (newCapacity <; min) newCapacity = min;Capacity = newCapacity;}}
capacity is increased to twice the current capacity or to min,
*private void EnsureCapacity(int min) {if (_items.Length <; min) {int newCapacity = _items.Length == 0? _defaultCapacity : _items.Length * 2;// Allow the list to grow to maximum possible capacity (~2G elements) before encountering >;overflow.// Note that this check works even when _items.Length overflowed thanks to the (uint) castif ((uint)newCapacity >; Array.MaxArrayLength) newCapacity = Array.MaxArrayLength;if (newCapacity <; min) newCapacity = min;Capacity = newCapacity;}}
whichever is larger.
*if ((uint)newCapacity >; Array.MaxArrayLength) newCapacity = Array.MaxArrayLength;*if (newCapacity ; min) newCapacity = min;
Note that this check works even when _items.Length overflowed thanks to the (uint) cast

*wc.Dispose();
オブジェクトを破棄

null かもしれない参照型の非同期メソッドを呼び出す
*string content = await httpResponse.Content?.ReadAsStringAsync();
※実行順序を正しくするため`await`する内容を`()`で囲む必要があります。
*string content = await (httpResponse.Content?.ReadAsStringAsync() ?? Task.FromResult(string.Enmpty));

*rect.Height += 1;
高さを増やす
現在の大きさを保存
*File.WriteAllText(filePath, todayData.ToString() + "\n" +rect.Width.ToString());
*if(rect.X + rect.Width >;= ClientSize.Width)addX = false;*else if(rect.X ;= 0)addX = true;
フォームの外枠超えようとすると、移動方向反転
現在の大きさを表示
*lb.Text = rect.Width.ToString();
再描画
*Invalidate();
*{//base.OnPaint(e); //なにこれ。なんであるの？Graphics g = e.Graphics;SolidBrush whiteBrush = new SolidBrush(Color.FromArgb(0xff, 0xff, 0xff));//左目の位置とか大きさとか決める。Rectangle eyeLeft = new Rectangle(rect.X + rect.Width / 2 - rect.Width / 5,rect.Y + 15,rect.Width / 7,rect.Height / 7);//右目もRectangle eyeRight = new Rectangle(rect.X + rect.Width / 2 + rect.Width / 5,rect.Y + 15,rect.Width / 7,rect.Height / 7);//体を描画する実際の処理。g.FillEllipse(new SolidBrush(Color.FromArgb(0x00, 0xff, 0xff)),rect);//左目描画g.FillEllipse(whiteBrush,eyeLeft);//右目g.FillEllipse(whiteBrush,eyeRight);}
画像を描画する処理
base.OnPaint(e); なにこれ。なんであるの？
*Graphics g = e.Graphics;
左目の位置とか大きさとか決める。
*Rectangle eyeLeft = new Rectangle(
右目も
*Rectangle eyeRight = new Rectangle(
体を描画する実際の処理。
*g.FillEllipse(
左目描画
*g.FillEllipse(
右目
*g.FillEllipse(
*{//https://dobon.net/vb/dotnet/form/preventmaximize.html//フォームを最大化、最小化できないようにする//MaximizeBox = false;//MinimizeBox = false;//前回の記録を読み込み、開いてなかった時間を計算string[] txtArr = File.ReadAllLines(filePath);TimeSpan diffTime = todayData - DateTime.Parse(txtArr[0]);//上記で出た時間 = 大きさとして、差異をサイズに取り込む。int diffSize = (int)diffTime.TotalHours + int.Parse(txtArr[1]);rect = new Rectangle(10, 10, diffSize, diffSize);//大きさを表すラベルの位置を調整、コントロールに追加lb.Bounds = new Rectangle(10, 10, 200, 20);Controls.Add(lb);//ダブルバッファ処理//この塊はワンセットとしとけばたぶんOKSetStyle(ControlStyles.DoubleBuffer |ControlStyles.UserPaint |ControlStyles.AllPaintingInWmPaint, true);//突然出てくるタイマー、時間経過でイベント発生させるTimer timer = new Timer();timer.Interval = 10;timer.Tick += new EventHandler(Move_Tick);timer.Start();}
コンストラクタ
フォームを最大化、最小化できないようにする
MaximizeBox = false;
MinimizeBox = false;
前回の記録を読み込み、開いてなかった時間を計算
*string[] txtArr = File.ReadAllLines(filePath);
*int diffSize = (int)diffTime.TotalHours + int.Parse(txtArr[1]);*rect = new Rectangle(10, 10, diffSize, diffSize);
上記で出た時間 = 大きさとして、差異をサイズに取り込む。
大きさを表すラベルの位置を調整、コントロールに追加
*lb.Bounds = new Rectangle(10, 10, 200, 20);
ダブルバッファ処理
この塊はワンセットとしとけばたぶんOK
*SetStyle(
突然出てくるタイマー、時間経過でイベント発生させる
*Timer timer = new Timer();
*{WinMain win = new WinMain();win.Text = "放置ゲーム";Application.Run(win);}
メイン関数 アプリケーションラン実行のみ

*h(null, EventArgs.Empty);
メソッドのように呼べる
h.Invoke(null, EventArgs.Empty);  Invoke メソッドでも上と同じ
*}
*public int Value { get; private set; }
イベントを定義
イベントを呼び出す
イベントハンドラが登録されてないと Changed は null なので
null チェックをして呼び出す。（?. 演算子で一行で書ける
Changed?.Invoke(this, EventArgs.Empty);  第一引数が sender, 第二引数がイベント引数
*}
カウンターを作ってイベントハンドラーを登録
*var counter = new Counter();
インクリメントしてイベントを発火してもらう
*counter.Increment();
*{Console.WriteLine(((Counter)sender).Value);}
第一引数が sender (この場合カウンター), 第二引数がイベント引数
*public int Value { get; private set; }
イベントを定義。独自イベント引数を使う場合は型引数で指定する
イベントを呼び出す
イベント引数は自分で定義したイベント引数ようの型にする
*Changed?.Invoke(this, new CounterChangedEventArgs(Value));
カウンターを作ってイベントハンドラーを登録
*var counter = new Counter();
インクリメントしてイベントを発火してもらう
*counter.Increment();
イベント引数に設定されている値を使うようにすることもできる
*Console.WriteLine(e.Value);

*var memory = arr1.AsMemory()[1..^1];
System.Memory&lt;int&gt; : [0]|2, [1]|3, [2]|0

即座にDispose
*context.Dispose();
*// before*private GameObject[] _liveStocks;
アバターを管理する配列
*// before*Destroy(_liveStocks[changeIndex]);
アバターの破棄処理
拡張メソッドなので、こんな感じで読んでおけば自動でDisposeしてくれる
*context.AutoDispose();

*var horizontalAlignment = (HorizontalAlignment) 4;
HorizontalAlignmentの正常値は1～3

テスト用クラス
*private string Hensu_Private;
*{Hensu_Private = "";Hensu_Public = "";Hensu_Static = "";}
メソッドから変数をいじる用
*{Cmn_Script.Hensu_Private = "";Cmn_Script.Hensu_Public = "";Cmn_Script.Hensu_Static = "";}
A）クラスを直接いじる
*{Cmn_Script Cls_Set = new Cmn_Script();Cls_Set.Hensu_Private = "";Cls_Set.Hensu_Public = "";Cls_Set.Hensu_Static = "";}
B）クラス型変数を作って中身をいじる
*{Cmn_Script.SetHensu_Public();Cmn_Script.SetHensu_Static();Cmn_Script Cls_Set = new Cmn_Script();Cls_Set.SetHensu_Public();Cls_Set.SetHensu_Static();}
C）クラス内メソッドを作って中身をいじる

テクスチャのどの位置に書き込むかというオフセット
*public int columnOffset=0;
アバターのSkinned Mesh Rendererを取得する
*_skin = GetComponent<;SkinnedMeshRenderer>;();
レンダーテクスチャを書き込み可能にする
*pRt.enableRandomWrite = true;
SkinnedMeshRenderから現在のフレームのmeshを作る
*_skin.BakeMesh(mesh);
コンピュートシェーダーに値を渡す入れ物をつくる
C言語の動的メモリ確保みたいな感じで、頂点数 * Vector3のサイズのバッファをつくる
*posBuffer = new ComputeBuffer(vertexCount, System.Runtime.InteropServices.Marshal.SizeOf(typeof(Vector3)));
meshの頂点位置情報をセットする
*posBuffer.SetData(mesh.vertices);
必要なデータや参照を渡す
*infoTexGen.SetInt("VertCount", vertexCount);
コンピュートシェーダを実行する
引数はスレッド数
スレッド数は 頂点数 * 1 * 1
*infoTexGen.Dispatch(kernel, vertexCount, 1, 1);
取得した回転の8割くらい頭を回転させ、4割くらい腰を回転させます（この値は好み）
*head.localRotation = Quaternion.Lerp(headInitialLocalRotation, thisFrameHeadLocalRotation, 0.8f);
0 = A, 1 = A# で0~11まで　検出できなかった場合-1が返ってくる
*float.TryParse(message.values[0].GetString(), out pitch);
呼びたいカーネル（処理）を決める
*var kernel = NormalizedRGBValueTo64pxRGBBrightness.FindKernel("CSMain");
必要なデータやら参照やらを渡す
*NormalizedRGBValueTo64pxRGBBrightness.SetInt("row", rowInMethod);
コンピュートシェーダを実行する
*NormalizedRGBValueTo64pxRGBBrightness.Dispatch(kernel, 1, 1, 1);

*int cityId = 400040;
福岡県久留米の地域ID
リクエストに成功した場合
*getApi.response = getApi.Response<;Api.GetWeatherApi.Response>;();
リクエストに失敗した場合
*Debug.Log("天気予報APIリクエストに失敗しました");

LoadFromFileだとAssetBundleに対するキャッシュの仕方が違うらしいので
より実運用に近いと思われるメモリからの読み込みにします
*_sceneBundle = await AssetBundle.LoadFromStreamAsync(memoryStream);

*Console.WriteLine(L2.SelfIntroduction);
実行結果：私はキラです

*float distanceToTarget = Vector3.Distance(this.transform.localPosition, Target.localPosition);*// Reached target
Rewards
*if (distanceToTarget <; 1.42f)*{
Reached target
*if (this.transform.localPosition.y <; 0)*{
Fell off platform

*var endpoint = "https:
api.freee.co.jphrapiv1employees" + employeeId + "time_clocks";

*chrome.Url = "https:
www.google.com";
クラス名SearchResultList-boxの要素を取得
*ReadOnlyCollection<;IWebElement>; itemList_sb = chrome.FindElementsByClassName("SearchResultList-box");
クラス名SearchResultList-boxの下にある
クラス名List_itemの要素を取得
ここでSearchResultList-boxを検索した場合は、自身は含まれないので要素ゼロのListが生成される
*ReadOnlyCollection<;IWebElement>; itemList_li = itemList_sb[0].FindElements(By.ClassName("List_item"));
クラス名SearchResultList-boxの要素を取得
*ReadOnlyCollection<;IWebElement>; itemList_sb = chrome.FindElementsByClassName("SearchResultList-box");
クラス名SearchResultList-boxの下にあるすべての要素を取得
*ReadOnlyCollection<;IWebElement>; itemList_wc = itemList_sb[0].FindElements(By.CssSelector("*"));
クラス名List_itemの要素を取得
*ReadOnlyCollection<;IWebElement>; itemList = chrome.FindElementsByClassName("List_item");
List_item1個めのテキスト"Text1"を取得
*string text = itemList[0].Text;
Tag名"li"の要素を取得
*ReadOnlyCollection<;IWebElement>; itemList = chrome.FindElementsByTagName("li");
Tag名liの1個めのクラス名"List_item"を取得
*string text = itemList[0].GetAttribute("class");
Tag名"ul"の要素を取得
*ReadOnlyCollection<;IWebElement>; itemList = chrome.FindElementsByTagName("ul");
HTMLを取得
*string text = itemList[0].GetAttribute("innerHTML");
class名SearchResultList-boxの要素を取得
ReadOnlyCollection&lt;IWebElement&gt; itemList = chrome.FindElementsByClassName("SearchResultList-box");TagName
Tag名uiを取得
*string text = itemList[0].TagName;
class名SearchResultList-boxの要素を取得
*ReadOnlyCollection<;IWebElement>; itemList = chrome.FindElementsByClassName("URL-box");
URLを取得
string text = itemList[0].GetAttribute("href");textには"https:www.google.co.jp/"が代入される
*,,,
*{const int SWP_NOSIZE = 0x0001;const int SWP_NOMOVE = 0x0002;const int SWP_SHOWWINDOW = 0x0040;const int HWND_TOPMOST = -1;const int HWND_NOTOPMOST = -2;SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);SetWindowPos(hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);}
ウィンドウをアクティブにする
*{const int SW_RESTORE = 9;// 最小化状態なら元に戻すif (IsIconic(handle))ShowWindowAsync(handle, SW_RESTORE);int processId;// フォアグラウンドウィンドウを作成したスレッドのIDを取得int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);// 目的のウィンドウを作成したスレッドのIDを取得int targetID = GetWindowThreadProcessId(handle, out processId);// スレッドのインプット状態を結び付けるAttachThreadInput(targetID, foregroundID, true);// ウィンドウをフォアグラウンドに持ってくるSetForegroundWindow(handle);// スレッドのインプット状態を切り離すAttachThreadInput(targetID, foregroundID, false);}
ウィンドウを強制的にアクティブにする
*if (IsIconic(handle))*ShowWindowAsync(handle, SW_RESTORE);
最小化状態なら元に戻す
*int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);*// 目的のウィンドウを作成したスレッドのIDを取得
フォアグラウンドウィンドウを作成したスレッドのIDを取得
目的のウィンドウを作成したスレッドのIDを取得
*int targetID = GetWindowThreadProcessId(handle, out processId);
*AttachThreadInput(targetID, foregroundID, true);*// ウィンドウをフォアグラウンドに持ってくる
スレッドのインプット状態を結び付ける
ウィンドウをフォアグラウンドに持ってくる
*SetForegroundWindow(handle);
*AttachThreadInput(targetID, foregroundID, false);*}
スレッドのインプット状態を切り離す
*if (p.MainWindowTitle.Length != 0)*{
メインウィンドウのタイトルがある時だけ列挙する
FireFoxをアクティブに
*ForceActive(pFireFox.MainWindowHandle);
Ctrl+sを送る→保存画面が出る
*SendKeys.SendWait("^s");
*SendKeys.SendWait("{Enter}");
Enterを送って保存

*int h = ClientSize.Height;
- txtContent.Top;

*var display = fruit1.ToString();
string["04：パイナップル"]
静的メンバは，クラスをインスタンス化せず，[クラス名.メンバ]の記載形式でアクセス
var fruit2 = Fruit.FromId(2);        Fruit[Id = 2, Name = "いちご"]
var fruit3 = Fruit.FromId(3);        Fruit[Id = 3, Name = "メロン"]
*,,,
通常の静的メソッド呼び出し(前置き記法)
var display1 = string.Join(", ", pieces);    string["飛車, 角, 金, 銀, 桂馬, 香車"]
拡張メソッド呼び出し(後置き記法)
var display2 = pieces.Join(", ");            string["飛車, 角, 金, 銀, 桂馬, 香車"]
*,,,

*ViewData["Now"] = DateTime.Now;
追加
省略
*}

*var requestBaseUrl = "https:
slack.comapiconversations.history";
レスポンスのコンテンツをstringで読み出す
*var responseBodyString = await response.Content.ReadAsStringAsync();
読みだしたJsonを、オブジェクトにデシリアライズする
*var responceObject = JsonConvert.DeserializeObject<;GetSlackMessagesResponce>;(responseBodyString);
*foreach (var messageResponce in responceObject.messages)*{
戻り値用のメッセージ一覧を作成
*{Text = messageResponce.text};
本文を設定
*foreach (var file in messageResponce.files)*{
添付ファイルを設定

*pattern: "{controller=Hello}
{action=Index}{id?}"); Home =&gt; Hello

*{public VAR Test(VAR a1){ return a1; }}
型に依存していない場合
型に依存しているメソッドを呼び出す場合
*public class SampleJeneric<;VAR>;

*}).AddTo(this);
自分を渡してGameObjectの破棄時に削除をしてもらう
*{[Inject] private IPublisher<;MyEvent>; _publisher;public void Send(MyEvent ev) =>;_publisher.Publish(ev);}
イベント送る方
*{private readonly IDisposable _disposable;public Subscriber(ISubscriber<;MyEvent>; subscriber){var bag = DisposableBag.CreateBuilder();subscriber.Subscribe(x =>; Debug.Log($"{x.Message}")).AddTo(bag);_disposable = bag.Build();}void IDisposable.Dispose(){_disposable.Dispose();}}
イベント受け取る方
*{public string Message;}
送るイベント
*{// イベントを投げる方var publisher = _container.Instantiate<;Publisher>;();publisher.Send(new MyEvent { Message = "テストメッセージ" });}
イベントを受ける方
*publisher.Send(new MyEvent { Message = "テストメッセージ" });
イベントを投げる方

*Console.WriteLine(i);
0,1,2,3,4が出力される

*await using var stream = await httpClient.GetStreamAsync("https:
www.google.com");
ストリームから文字列を読みだすため、StreamReaderを生成する
*using var reader = new StreamReader(stream);

*//class User {//    public string Name { get; set; }//}
このようなクラスを読み込んでいます
*//    public string Name { get; set; }
class User {
*IEnumerable<;User>; users = new[] { "kato", "saito", "kondo" }
public string Name { get; set; }
*IEnumerable<;User>; users = new[] { "kato", "saito", "kondo" }
}
大文字に変換したはずなのに・・・
*user.Name = user.Name.ToUpper();
大文字に変換
*user.Name = user.Name.ToUpper();

スクリプトから画像を扱う場合に Texture または Spriteという形式に変換する必要がある
クラス変数として Texture型のクラス変数 wood_dark_AlbedoTransparencyを定義する
*public Texture wood_dark_AlbedoTransparency;
*{}
Update is called once per frame

クリップボードに画像があるか
*[DllImport("Clipboard")]
クリップボードの画像の大きさと、1ピクセル当たりのビット数
*[DllImport("Clipboard")]
Bufferに画像のピクセルを書き込む
*[DllImport("Clipboard")]
チャンネル数
*int channel = bitsPerPixel / 8;
C#側の領域を用意する
*byte[] buffer = new byte[width * height * channel];
GCによって移動しないように固定する。必ず開放する。
*GCHandle handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
確保したバッファのアドレス
*IntPtr bufferPtr = handle.AddrOfPinnedObject();
クリップボードからコピーする
*bool successCopy = false;
解放
*handle.Free();
*if(channel == 4)*{
BGRA
*else if (channel == 3)*{
BGR

*Console.WriteLine(expression.Compile()("f42"));
Unhandled exception. System.InvalidOperationException: variable 'a' of type 'System.String' referenced from scope '', but it is not defined

*Debug.Log("左下の座標は " + sqSr.bounds.min + " です");
左下の座標は (-1.0, -0.8, -0.1) です

includeParentCulturesを使ってない...
*IEnumerable<;string>; allKey = _dbLocalizedStringSource.GetAllKey();
...省略...
AddLocalizationより前にDbStringLocalizerFactoryを登録する
*services.AddTransient<;DbLocalizedStringSourceProvider>;();

型の登録
*var services = new ServiceCollection();
インスタンスを提供してくれる人を作る
*using var provider = services.BuildServiceProvider();
型の登録
*var services = new ServiceCollection();
インスタンスを提供してくれる人を作る
*using var provider = services.BuildServiceProvider();
型の登録
*var services = new ServiceCollection();
ここで任意の生成ロジックを入れることが出来る
*var printer = provider.GetRequiredService<;IMessagePrinter>;();
インスタンスを提供してくれる人を作る
*using var provider = services.BuildServiceProvider();
型の登録
*var services = new ServiceCollection();
Unity のコンテナに登録してログ機能も追加
*var container = new UnityContainer()
インスタンスを提供してくれる人を作る
*var provider = services.BuildServiceProvider(container);

進行状況ダイアログを表示する
*DialogResult result = pd.ShowDialog();
*if (result == DialogResult.Cancel)*{
結果を取得する
エラー情報を取得する
*Exception ex = pd.Error;
結果を取得する
*int stopTime = (int)pd.Result;
MessageBox.Show("成功しました: " + stopTime.ToString());
*}
後始末
*pd.Dispose();
*// https://docs.microsoft.com/ja-jp/visualstudio/vsto/how-to-programmatically-search-for-and-replace-text-in-documents?view=vs-2019*// プログラムによって検索後に選択を復元する
プログラムによって文書内のテキストを検索および置換する
プログラムによって検索後に選択を復元する
https:docs.microsoft.com/ja-jp/visualstudio/vsto/how-to-programmatically-restore-selections-after-searches?view=vs-2019
*public void 垂直タブを改行に(Document doc)
*{BackgroundWorker bw = (BackgroundWorker)sender;//パラメータを取得するint stopTime = (int)e.Argument;Document doc = danrakuG01.Globals.ThisAddIn.Application.ActiveDocument;var myPatDoc = new patDoc();Range rng = myPatDoc.書類名の範囲("明細書", doc);if (rng == null){System.Windows.Forms.MessageBox.Show("明細書が記載されていません。", "警告");e.Result = 0;return;}long endpos = rng.End;int counter = 0;int i = 0;rng.Find.MatchWildcards = true;int lastTick = Environment.TickCount;int currTick;bw.ReportProgress(i, i.ToString() + "% 終了しました");while (rng.Find.Execute("【[０-９]@】")){counter++;rng.Text = "";rng.SetRange(rng.End, rng.End);if (myPatDoc.パラグラフが空白か判定(rng.Paragraphs[1])){rng.Paragraphs[1].Range.Delete();}//キャンセルされたか調べるif (bw.CancellationPending){//キャンセルされたときe.Cancel = true;return;}currTick = Environment.TickCount;if( currTick - lastTick >; 1000 ){//指定された時間待機する//System.Threading.Thread.Sleep(stopTime);//ProgressChangedイベントハンドラを呼び出し、//コントロールの表示を変更するi = (int)(rng.End * 100 / endpos);bw.ReportProgress(i, i.ToString() + "% 終了しました");lastTick = currTick;}}i = 100;bw.ReportProgress(i, i.ToString() + "% 終了しました");System.Threading.Thread.Sleep(500);//結果を設定するe.Result = counter;}
段落の削除
パラメータを取得する
*int stopTime = (int)e.Argument;
*if (bw.CancellationPending)*{
キャンセルされたか調べる
キャンセルされたとき
*e.Cancel = true;
指定された時間待機する
System.Threading.Thread.Sleep(stopTime);
ProgressChangedイベントハンドラを呼び出し、
コントロールの表示を変更する
*i = (int)(rng.End * 100 / endpos);
結果を設定する
*e.Result = counter;
*if (doc.TrackRevisions == true)*{
myPatDoc.G_段落番号付与(doc);
ProgressDialogオブジェクトを作成する
*ProgressDialog pd = new ProgressDialog("段落番号の付与",
進行状況ダイアログを表示する
*DialogResult result = pd.ShowDialog();
*if (result == DialogResult.Cancel)*{
結果を取得する
後始末
*pd.Dispose();
エラー情報を取得する
*Exception ex = pd.Error;
後始末
*pd.Dispose();
結果を取得する
*int stopTime = (int)pd.Result;
MessageBox.Show("成功しました: " + stopTime.ToString());
*}
後始末
*pd.Dispose();
ProgressDialogオブジェクトを作成する
*pd = new ProgressDialog("段落番号の振り直し",
進行状況ダイアログを表示する
*result = pd.ShowDialog();
*if (result == DialogResult.Cancel)*{
結果を取得する
エラー情報を取得する
*Exception ex = pd.Error;
結果を取得する
*int stopTime = (int)pd.Result;
MessageBox.Show("成功しました: " + stopTime.ToString());
*}
後始末
*pd.Dispose();
*if (bw.CancellationPending)*{
キャンセルされたか調べる
キャンセルされたとき
*e.Cancel = true;
指定された時間待機する
System.Threading.Thread.Sleep(stopTime);
*currTick = Environment.TickCount;
ProgressChangedイベントハンドラを呼び出し、
コントロールの表示を変更する
*i = (int)(paraCurr.Range.End * 100 / rng.End);
*if (bw.CancellationPending)*{
キャンセルされたか調べる
キャンセルされたとき
*e.Cancel = true;
指定された時間待機する
System.Threading.Thread.Sleep(16);
*currTick = Environment.TickCount;
ProgressChangedイベントハンドラを呼び出し、
コントロールの表示を変更する
*i = (int)(rng.End * 100 / endpos);

キャンバスサイズは横500px、縦400px。
*this.bmp = new Bitmap(500, 400);
顔の輪郭を描く。
*g.DrawEllipse(new Pen(GetFaceBorderColor(), 5), GetFacePosition());
顔の色を塗る。
*g.FillEllipse(new SolidBrush(GetFaceColor()), GetFacePosition());
その他の顔のパーツを作る。
g.FillEllipse(Brushes.Black, 190, 200, 15, 50);   右目
g.FillEllipse(Brushes.Black, 295, 200, 15, 50);   左目
g.DrawArc(new Pen(Color.Black, 5), new Rectangle(190, 270, 60, 60), 0, 180);     口（右側）
g.DrawArc(new Pen(Color.Black, 5), new Rectangle(250, 270, 60, 60), 0, 180);     口（左側）
g.DrawLine(new Pen(Color.Black, 5), new Point(5, 210), new Point(120, 225));     ひげ1（右側）
g.DrawLine(new Pen(Color.Black, 5), new Point(0, 250), new Point(120, 250));     ひげ2（右側）
g.DrawLine(new Pen(Color.Black, 5), new Point(5, 290), new Point(120, 275));     ひげ3（右側）
g.DrawLine(new Pen(Color.Black, 5), new Point(380, 225), new Point(495, 210));     ひげ1（左側）
g.DrawLine(new Pen(Color.Black, 5), new Point(380, 250), new Point(500, 250));     ひげ2（左側）
g.DrawLine(new Pen(Color.Black, 5), new Point(380, 275), new Point(495, 290));     ひげ3（左側）
*}
画像をPNG形式で保存する。
*bmp.Save(filePath, System.Drawing.Imaging.ImageFormat.Png);

*isEnableBackKeyComp = null;
one shot

*new SomeApplication(new SomeRepository())
今回は未登場だけど Application は Repository にさらに依存するとしたらこんな感じのコードになる

*var coeff1 = (0.714 * 5
100)  maxval;  5IRE
*Scalar[] BGR = {new Scalar(1.0, 0.0, 1.0),new Scalar(0.0, 0.0, 1.0),new Scalar(0.0, 1.0, 1.0),new Scalar(0.0, 1.0, 0.0),new Scalar(1.0, 1.0, 0.0),new Scalar(1.0, 0.0, 0.0)};
M(60.8)/R(103.4)/Y(167.1)/G(240.8)/C(283.4)/B(347.1)

*Score = Sd.GetScore();
ScoreDataの中のGetScore関数を呼び出す
*tx.text = string.Format("Score  {0}", Score);
アタッチしたオブジェクトに反映したいテキストを紐づける。

*{// // 赤色に変更するgameObject.GetComponent<;Renderer>;().material.color = Color.red;}
Start is called before the first frame update
赤色に変更する
*gameObject.GetComponent<;Renderer>;().material.color = Color.red;
*{}
Update is called once per frame

*{Debug.Log("Hello, World");}
Start is called before the first frame update
*{}
Update is called once per frame

1:ラムダor式形式のメンバーの中
*static void test1() =>; throw new NotImplementeException();
2：Null合体演算子(??)の右辺
*var a = ex as string ?? throw new ArgumentException(nameof(obj));
3:条件演算子の2,3つ目の引数
*return a.Length == 0 ? "enmpty" :

*FormatableToString(UIntPtr.Zero, "X");
throws System.TypeInitializationException

*{}
Start is called before the first frame update
*{if (Input.GetKey(KeyCode.UpArrow)){transform.position += new Vector3(0,0,0.1f);}if (Input.GetKey(KeyCode.DownArrow)){transform.position += new Vector3(0,0,-0.1f);}if (Input.GetKey(KeyCode.RightArrow)){transform.position += new Vector3(0.1f,0,0);}if (Input.GetKey(KeyCode.LeftArrow)){transform.position += new Vector3(-0.1f,0,0);}}
Update is called once per frame

例外発生の可能性のある処理を記述
*}
例外が発生した場合の処理を記述
*}
例外の発生有無に関わらず実行する処理を記述
*}
またはスルーさせる
throw;
*}
例外発生の可能性のある処理を記述
*}
例外が発生した場合の処理を記述
*}

*string WindowClassName,
ここがstringになっている

*var c = new Container();
Container クラスが DI コンテナだとする
アプリの起動時あたりで、以下のようにアプリで使うインターフェースと実装クラスを登録していく
*c.RegisterType<;ISettingsProvider, SettingsProvider>;();
インスタンスが欲しいときは、コンテナから取得
*var productOrderService = c.Resolve<;IProductOrderService>;();

*(int a1, int a2[,int ……]) =<; uhen
型宣言ありの変数

型：List(Of ...) への対応
リストの内部情報はType.GetFieldsから解析する事ができないので、自前で解析する。
*buf.AppendLine(nestString + "▽" + targetFieldName + "(" + targetObject.GetType().ToString() + ")-------------------------------");

*{return Resources.Load<;T>;(path);}
ScriptableObjectのみ受け付けるジェネリクスメソッド
*{Debug.Log(LoadData.Instance.ScriptableLoader<;GameData>;("Data/MyGameData").Data1);}
Start is called before the first frame update

*return Content("Hello World!");
修正箇所

*var bytes = await httpClient.GetByteArrayAsync("https:
exapmle.comimage.png");
画像をリサイズ
*webImage.Mutate(w =>; w.Resize(180, 180));
座標を指定して書き込む
*ctx.DrawImage(webImage, new Point(240, 154), 1);
テキストを書き込む処理
*ctx.DrawText("MKTaro", font, Color.FromRgb(255, 255, 255), new PointF(240, 90));
*{point1,point2,point3,point4,point5};
要素を増やせば、増やした分の多角形となる

*Parallel.For(0, 10, i =>; {Console.WriteLine(i.ToString());});
インデックス0から9までの並列処理。
全ての並列処理が完了したら、処理がこの先へ進む。
*,,,
*var l = new List<;String>;{"a", "b", "c"};
リストの内容で並列処理。
全ての並列処理が完了したら、処理がこの先へ進む。
*,,,
繰り返しを使わない並列処理。
ここでは4つの処理を並列化しているが、処理数は自由。
*Parallel.Invoke(
全ての並列処理が完了したら、処理がこの先へ進む。
*,,,
*Task.Run(() =>; {Console.WriteLine("a");});
並列処理を立ち上げる。
処理の終了を待たずに、処理がこの先へ進む。
*,,,
*var t = Task.Run(() =>; {Console.WriteLine("a");});
並列処理を立ち上げる。
処理の終了を待ち合わせる所でこうする。
*t.Wait();
並列処理内で送出された例外は呼び出し元でキャッチされない。
このように、並列処理内で対処すると良い。
*try

省略
*}

交換したかのチェックフラグ
*bool isChanged = false;
櫛の間隔を定義します。
*int h = _array.Length;
*while (isChanged || h >; 1)*{
コムソートで配列の中身を昇順で並べ替えます。
*if (h >; 1)*{
櫛の間隔を計算します。
*if (_array[i] >; _array[i + h])*{
指定した間隔の要素と比較し、順序が逆であれば入れ替えます。
配列の要素の交換を行います。
*int temp = _array[i];
交換フラグをtrueにします。
*isChanged = true;

*.Select(x =<; x * x);
2 乗する
表示
*Console.WriteLine("結果を表示します！！");
元データかわちゃった
*list.Add(100);

接続情報
private static readonly string Server = "192.168.5.xxx";     ホスト名
private static readonly int Port = 3306;                     ポート番号
private static readonly string Database = "nation";          データベース名
private static readonly string Uid = "demo";                 ユーザ名
private static readonly string Pwd = "passwd";               パスワード
接続文字列
*private static readonly string ConnectionString = $"Server={Server}; Port={Port}; Database={Database}; Uid={Uid}; Pwd={Pwd}";

プレイヤーの番号
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
Hashtableにプレイヤーに割り振られた番号があれば取得する
*private static bool TryAndGetPlayerNum(this Hashtable hashtable, out int playerAssignNumber)
*{player.CustomProperties.TryAndGetPlayerNum(out int playerNum);return playerNum;}
プレイヤー番号を取得する
*{_hashtable[PLAYER_ASSIGN_NUMBER] = assignNum;player.SetCustomProperties(_hashtable);_hashtable.Clear();}
プレイヤーの割り当て番号のカスタムプロパティを更新する
*if (photonView.IsMine)*{
自分のクライアントの同期オブジェクトにのみ
*//例) 制限人数 = 4 の場合、{0,1,2,3}
制限人数までの数字のリストを作成
例) 制限人数 = 4 の場合、{0,1,2,3}
*int count = 0;
他の全プレイヤー取得
*Player[] otherPlayers = PhotonNetwork.PlayerListOthers;
*if (otherPlayers.Length <;= 0)*{
他のプレイヤーがいなければカスタムプロパティの値を"0"に設定
ローカルのプレイヤーのカスタムプロパティを設定
*int playerAssignNum = otherPlayers.Length;
他のプレイヤーのカスタムプロパティー取得してリスト作成
*List<;int>; playerAssignNums = new List<;int>;();
リスト同士を比較し、未使用の数字のリストを作成
例) 0,1にプレーヤーが存在する場合、返すリストは2,3
*playerSetableCountList.RemoveAll(playerAssignNums.Contains);
ローカルのプレイヤーのカスタムプロパティを設定
空いている場所のうち、一番若い数字の箇所を利用
*PhotonNetwork.LocalPlayer.UpdatePlayerNum(playerSetableCountList[0]);
プレーヤーのカスタムプロパティ更新
*SetMyCustomProperties();
*if (photonView.IsMine)*{
自分のクライアントの同期オブジェクトの設定
*{this.gameObject.transform.rotation = _playerInitTransform[photonView.Owner.GetPlayerNum()].rotation;this.gameObject.transform.position = _playerInitTransform[photonView.Owner.GetPlayerNum()].position;_avatarObjectMeshRenderer.sharedMaterial = _playerMaterials[photonView.Owner.GetPlayerNum()];}
他のクライアントの同期オブジェクトの設定

*using System.Windows.Media.Media3D;
3D行列使用

*Debug.Log($"{int1}, {int2}");
「1, 1」が出力される

TODO: ヒーロー達を取得した __後で__ メッセージを送るようにする
*messageService.Add("HeroService: fetched heroes");
*private void NotifyChange() =>; OnChange?.Invoke();*,,,
ハンドラが登録されていれば変更を通知

外積に使用　各指の根元
*private OVRSkeleton.BoneId _middleFingerRoot = OVRSkeleton.BoneId.Hand_Middle1;
外積に利用するベクトル
*Vector3 pinkyToMiddleDirection =
外積　手のひら正面方向　中指の根本を手のひらってことにする
*Vector3 handForward =
外積に使用　各指の根元
*private OVRSkeleton.BoneId _middleFingerRoot = OVRSkeleton.BoneId.Hand_Middle1;
外積に利用するベクトル
*Vector3 pinkyToMiddleDirection =
外積　手のひら正面方向　中指の根本を手のひらってことにする
*Vector3 handForward =

*labelValue.Text   = comboBox1.SelectedValue.ToString();
値はそのまま取りだせる

* 処理内容：滑らかなアナログ時計の動作を実現
*
*        MainWindow.xaml.cs ：アナログ時計表示
*
*        2020.07.03 ProOJI
*
********************************************************
*using System;
時間の針
*StartAnimation("HourHand", this.AngleHour.Angle);
分の針
*StartAnimation("MinuteHand", this.AngleMinute.Angle);
秒の針
*StartAnimation("SecondHand", this.AngleSecond.Angle);

FormsWebChromeClientクラス内
mainActivityはXamarin.AndroidでのMainActivity。FormsWebChromeClientにstatic変数として持たせて、
MainActivityのOnCreateでそのstatic変数にMainActivity自身を渡す。
REQUEST_IMAGE_CODEにはFormsWebChromeClient内で適当な値に設定しています。
*public override bool OnShowFileChooser(Android.Webkit.WebView webView, IValueCallback filePathCallback, FileChooserParams fileChooserParams)
MainActivity内
intentCallback
REQUEST_IMAGE_CODEにはFormsWebChromeClientでの値と同じにする。
*public IValueCallback intentCallback;
yourCodeは26である必要はなく、適当な数字で大丈夫ですが、後述のOnRequestPermissionResultでのものと一致させる必要はあります。
*const int yourCode = 26;
*HttpClient httpClient = new HttpClient{Timeout = TimeSpan.FromSeconds(15)};
Timeoutの時間も設定できます。
取得した画像や動画のByte列を格納する変数
*byte[] imageData;
*{if (httpResponse.StatusCode == System.Net.HttpStatusCode.OK){//正常に取得できたというレスポンス（System.Net.HttpStatusCode.OK）ならデータを取得imageData = await httpResponse.Content.ReadAsByteArrayAsync();}}
downloadUrlは画像や動画のUrl
正常に取得できたというレスポンス（System.Net.HttpStatusCode.OK）ならデータを取得
*imageData = await httpResponse.Content.ReadAsByteArrayAsync();
DCIMフォルダの取得（DCIMPathの取得は後述）
*IFolder DCIMFolder = await FileSystem.Current.GetFolderFromPathAsync(DCIMPath);
DCIM内に別につくる保存用フォルダ
*IFolder saveFolder;
保存用フォルダがすでにあれば取得、なければ新規作成
*ExistenceCheckResult exist = await DCIMFolder.CheckExistsAsync(saveFolderName);
保存するファイルを新規作成
*IFile file = await saveFolder.CreateFileAsync(saveFileName, CreationCollisionOption.ReplaceExisting);
*{stream.Write(imageData, 0, imageData.Length);}
ファイルに画像や動画のByte情報書き込み
Xamarin.AndroidでのDCIMパスの取得
*string path = Path.Combine(Android.OS.Environment.ExternalStorageDirectory.AbsolutePath, "DCIM");
_contextというメンバ変数をWebViewRendererに用意しておき、コンストラクタで引数のContextを代入しておく。
imagePathは、「DCIMフォルダへのメディアの保存」のプログラムにあるIFile型のfileからfile.Pathで取得できる。
_context.SendBroadcast(new Intent(Intent.ActionMediaScannerScanFile, Android.Net.Uri.Parse("file:" + imagePath)));
*,,,

*MessageBox.Show(("ここに表示したい文字列を入力します。"));
ポップアップwindowを表示する

ドライバー起動時に表示されるコンソール画面を非表示にする
*var service = EdgeDriverService.CreateChromiumService();
EdgeChromium版を使用
*var options = new EdgeOptions;
サイトを開く
driver.Navigate().GoToUrl("https:aaaa");
ユーザーID
*driver.FindElement(By.Name("pid")).SendKeys("userId");
パスワード
*driver.FindElement(By.Name("password")).SendKeys("pw");
ログインボタン
*IWebElement findbuttom = driver.FindElement(By.Name("btnname"));
ログインボタンをクリック
*findbuttom.Click();

*RedirectToAction();
処理が成功した後に遷移したいページに遷移

*for (int i = 0; i <; _array.Length-1; i++)*{
配列の回数分回す
*if (_array[i] >; _array[i + 1])*{
比較元より大きければ入れ替え
*if (_array[i] <; _array[i - 1])*{
比較元より大きければ入れ替え
*if (swapFlag==false)*{
一度も入れ替え処理が通らなければ
Sortした結果を返す
*return _array;

*for (int i = 0; i <; _array.Length; i++)*{
配列の回数分回す
*for (int j = 0; j <; _array.Length; j++)*{
配列の回数分回す
*if (_array[i] <; _array[j])*{
比較元より大きければ入れ替え
Sortした結果を返す
*return _array;
*for (int i = 0; i <; _array.Length; i++)*{
配列の回数分回す
*for (int j = i; j <; _array.Length; j++)*{
配列の回数分回す
*if (_array[i] <; _array[j])*{
比較元より大きければ入れ替え
Sortした結果を返す
*return _array;
*for (int i = 0; i <; _array.Length; i++)*{
配列の回数分回す
*for (int j = i+1; j <; _array.Length; j++)*{
配列の回数分回す
*if (_array[i] <; _array[j])*{
比較元より大きければ入れ替え
Sortした結果を返す
*return _array;

*var path_b = path_a
"b";  c:\a\b

除去する
Debug.WriteLine(truncate_trailing_zeros(1040000.00M));  -&gt; 1040000
Debug.WriteLine(truncate_trailing_zeros(1050000.00M));  -&gt; 1050000
Debug.WriteLine(truncate_trailing_zeros(10.0000400M));  -&gt; 10.00004
Debug.WriteLine(truncate_trailing_zeros(10.0000500M));  -&gt; 10.00005
カウントする
Debug.WriteLine(count_trailing_zeros(0.4400M));  -&gt; 2
Debug.WriteLine(count_trailing_zeros(1.0000M));  -&gt; 4
Debug.WriteLine(count_trailing_zeros(1.0001M));  -&gt; 0
Debug.WriteLine(count_trailing_zeros(100.00M));  -&gt; 2
*}

HierarchyにあるSayHelloMonoBehaviourのInitializeを発火。Resolveされる。
*}
SayHelloMonoBehaviourInjectorがInitializeの発火でResolveされる。
その際、コンストラクタ引数にSayHelloMonoBehaviourがあるのでsayHelloインスタンスがResolveされる。
builder.RegisterEntryPoint&lt;SayHelloMonoBehaviourInjector&gt;(Lifetime.Singleton);
で代用可能。
*}

*m_worker.Dispose();
終了時に破棄する

*Debug.WriteLine(calc_significant_figures(10.0000400M, 6, 2));
-&gt; 10.0001
*{case 0:{var scale = (decimal)Math.Pow(10, integer_part);var result = scale * Math.Round(value / scale, digits, MidpointRounding.AwayFromZero);//return Math.Round(result, decimal_part);var decimals = digits - integer_part;return Math.Round(result, (decimals <; 0) ? 0 : decimals);}case 1:{var scale = (decimal)Math.Pow(10, integer_part - digits);return scale * Math.Floor(value / scale);}case 2:{var scale = (decimal)Math.Pow(10, integer_part - digits);return scale * Math.Ceiling(value / scale);}}
var decimal_part = decimal.GetBits(value)[3] &gt;&gt; 16 &amp; 0x0FF;

色んなオブジェクトの定義
*Excel.Application excel = null;
フォルダの取得
*string folderPath = @"C:\Users\xyy\Desktop\Folder";
フォルダの中の拡張子が.xlsxのファイルの取得
*string[] files = Directory.GetFiles(Path.GetFullPath(folderPath), "*.xlsx");
Excelを起動する
*excel = new Excel.Application();
ブック一覧の定義
*books = excel.Workbooks;
*foreach (string file in files)*{
各ファイルに対して下記処理を繰り返し行う
ブックを開く
*book = books.Open(file);
シート一覧の定義
*sheets = book.Worksheets;
最初のシートの選択
*sheet = sheets[1];
セル一覧の定義
*cells = sheet.Cells;
セル[2,1]の選択
range = sheet.Cells[2, 1] という書き方だと、sheet.Cellsとsheet.Cells[2, 1]という二つのExcel.Rangeオブジェクトが隠れて、
オブジェクトの解放漏れが発生するので、注意してください。
*range = cells[2, 1];
セル[2,1]の値をtestに設定する
*range.Value = "test";
ブックを保存して閉じる
*book.Close(true);
Excelを終了する
*excel.Quit();
定義されたオブジェクトの解放、ループのたびに毎回解放しないとExcelのプロセスが残り続ける
*Marshal.FinalReleaseComObject(range);
ブック一覧とExcelオブジェクトの解放は最後に一回行っていい
*Marshal.FinalReleaseComObject(books);
列一覧の定義
*cells = sheet.Columns;
2列目の選択
*range = cells[2];
*for (int i = 0; i <; 3; i++)*{
3列を挿入する
セル一覧の定義
*cells = sheet.Cells;
セル[2, 2]の選択
*range1 = cells[2, 2];
セル[2, 4]の選択
*range2 = cells[2, 4];
セル[2, 2]から[2, 4]までの範囲の選択
*range3 = sheet.Range[range1,range2];
セルの結合
*range3.Merge();
セル[B2]から[D2]までの範囲の選択
*range = sheet.Range["B2:D2"];
セルの結合
*range.Merge();
フォントオブジェクトの定義
*Excel.Font font = null;
... 略
セル一覧の定義
*cells = sheet.Cells;
セル[2,1]の選択
*range = cells[2, 1];
セル[2,1]のフォントの選択
*font = range.Font;
文字色を赤にする
*font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.Red);
罫線オブジェクトの定義
*Excel.Borders border = null;
... 略
セル一覧の定義
*cells = sheet.Cells;
セル[2,2]の選択
*range = cells[2, 2];
セル[2,2]の罫線選択
*border = range.Borders;
罫線を実線に設定する
*border.LineStyle = Excel.XlLineStyle.xlContinuous;
罫線の太さの設定
*border.Weight = 2d;

省略...
ローカリゼーション周りのクラスをDIコンテナに登録する。
.resxファイルはResourcesフォルダに配置するのでResourcesPathを変更
*services.AddLocalization(options =>; options.ResourcesPath = "Resources");
省略...
ミドルウェアの登録及び、オプションの設定
*app.UseRequestLocalization(options =>;
*string[] supportedCultures = new string[] {"ja", "en"};
サポートするカルチャの設定
省略...
*}

*public int Score { set; get;}
値を保存用
↓これを呼び出せばDontDestroyObjectにできます
*DontDestroyOnLoad(gameObject);

*//if (predicate == null) throw Error.ArgumentNull("predicate");*foreach (TSource element in source)
if (source == null) throw Error.ArgumentNull("source");
*foreach (TSource element in source)*{
if (predicate == null) throw Error.ArgumentNull("predicate");
*//if (predicate == null) throw Error.ArgumentNull("predicate");*TSource result = defaultValue;
if (source == null) throw Error.ArgumentNull("source");
*//if (predicate == null) throw Error.ArgumentNull("predicate");*TSource result = defaultValue;
if (source == null) throw Error.ArgumentNull("source");
*if (index >;= 0)*{
if (source == null) throw Error.ArgumentNull("source");

*Random cRandom = new System.Random();
乱数
*{private readonly string apiKey;public ApiKeyServiceClientCredentials(string apiKey){this.apiKey = apiKey;}public override Task ProcessHttpRequestAsync(HttpRequestMessage request, CancellationToken cancellationToken){if (request == null){throw new ArgumentNullException("request");}request.Headers.Add("Ocp-Apim-Subscription-Key", this.apiKey);return base.ProcessHttpRequestAsync(request, cancellationToken);}}
for TextAnalytics

*Debug.WriteLine($"User Message: {message}");
引数messageの内容を出力
*{private readonly string apiKey;public ApiKeyServiceClientCredentials(string apiKey){this.apiKey = apiKey;}public override Task ProcessHttpRequestAsync(HttpRequestMessage request, CancellationToken cancellationToken){if (request == null){throw new ArgumentNullException("request");}request.Headers.Add("Ocp-Apim-Subscription-Key", this.apiKey);return base.ProcessHttpRequestAsync(request, cancellationToken);}}
for TextAnalytics

EditModeでも動作するようUpdateで更新を検出
*ReCalculate();
*{if (!_textMeshPro.havePropertiesChanged &amp;&amp; _isActive == isActive &amp;&amp; _flip == flip &amp;&amp;_lastRadius == radius &amp;&amp; _lastSpread == spread &amp;&amp; _rectTransform.rect == _lastRect) return;_isActive = isActive;_flip = flip;_lastRadius = radius;_lastSpread = spread;_lastRect = _rectTransform.rect;if(isActive) SetCurve();else _textMeshPro.ForceMeshUpdate();var enu = _textMeshPro.textInfo.meshInfo.SelectMany(m =>; m.vertices).Select(v =>; v.y).ToArray();_minY = enu.Min();_maxY = enu.Max();}
パラメータやTextMeshProの変更を監視し，変更があればメッシュの再変形を行う
*{_textMeshPro.ForceMeshUpdate();var textInfo = _textMeshPro.textInfo;var characterCount = textInfo.characterCount;var rect = _rectTransform.rect;var minX = rect.xMin + _textMeshPro.margin.x;var maxX = rect.xMax - _textMeshPro.margin.y;for (var i = 0; i <; characterCount; i++){if (!textInfo.characterInfo[i].isVisible) continue;var vertexIndex = textInfo.characterInfo[i].vertexIndex;var materialIndex = textInfo.characterInfo[i].materialReferenceIndex;var vertices = textInfo.meshInfo[materialIndex].vertices;// 文字の中点座標を計算Vector3 offsetToMidBaseline =new Vector2((vertices[vertexIndex + 0].x + vertices[vertexIndex + 2].x) / 2,textInfo.characterInfo[i].baseLine);// 変形後の文字の中心位置を計算var val = (offsetToMidBaseline.x - minX) / (maxX - minX);var pos0 = CalcPositionFromCircle(val);var pos1 = CalcPositionFromCircle(val + 0.0001f);var rotation = Quaternion.FromToRotation(Vector3.right, (pos1 - pos0).normalized);// 各文字の4頂点への処理for (var j = 0; j <; 4; ++j){var point = vertices[vertexIndex + j];// 中点からの相対ベクトルを算出point -= offsetToMidBaseline;// 移動と回転を適用point = rotation * point + new Vector3(pos0.x, offsetToMidBaseline.y, pos0.z);vertices[vertexIndex + j] = point;}}_textMeshPro.UpdateVertexData();}
Textに対しメッシュの変形を実行
文字の中点座標を計算
*Vector3 offsetToMidBaseline =
変形後の文字の中心位置を計算
*var val = (offsetToMidBaseline.x - minX) / (maxX - minX);
*for (var j = 0; j <; 4; ++j)*{
各文字の4頂点への処理
中点からの相対ベクトルを算出
*point -= offsetToMidBaseline;
移動と回転を適用
*point = rotation * point + new Vector3(pos0.x, offsetToMidBaseline.y, pos0.z);
*{var angle = (float) (1.5 * Math.PI + (val - 0.5f) * spread * Mathf.Deg2Rad);var x = radius * Mathf.Cos(angle);var z = (flip ? -1 : 1) * radius * (1 + Mathf.Sin(angle));return new Vector3(x, 0, z);}
0~1のvalueに対し，円周上の位置を返す
境界部での丸め込み
*var deg = i;

*{//商品IDが1の商品情報を取得_searchItemQuary.Execute(1);}
実行処理
商品IDが1の商品情報を取得
*_searchItemQuary.Execute(1);
ISearchItemQuaryのモックを作成
*var mockContext = new Mock<;ISearchItemQuary>;();
id「1」に紐づいた商品情報を取得
*return item.Execute(_id)

*var client = new GitHubClient(new ProductHeaderValue("lr")) {Credentials = tokenAuth};
接続情報の設定
GitHub Issueの取得
*var gitHubIssues = new List<;Issue>;();
*var client = new GitHubClient(new ProductHeaderValue(settings.Owner)) {Credentials = tokenAuth};
接続情報の設定
Issueを作成し、本文を設定
*var createIssue = new NewIssue(issueTitle);
Issueを追加
*var newIssue = await client.Issue.Create(settings.Owner, settings.Repository, createIssue);
*var client = new GitHubClient(new ProductHeaderValue("lr")) {Credentials = tokenAuth};
接続情報の設定
GitHub Issueの取得
*var gitHubIssues = new List<;Issue>;();
*var assigneeFilter = new RepositoryIssueRequest { State = ItemState.Open, Assignee = username };
GitHub Issueの取得
Issueを作成し、本文を設定
*var createIssue = new NewIssue(issueTitle);
Issueを追加
*var newIssue = await client.Issue.Create(settings.Owner, settings.Repository, createIssue);

空文字列ならnullで親のメソッドを呼ぶ
*base.AddParameter(cmd, null);
それ以外はそのまま
*base.AddParameter(cmd, value);

*{SystemEvents.SessionSwitch          += ((sender, e) =>; { AddLog("SessionSwitch       :" + e.Reason.ToString()); });SystemEvents.SessionEnding          += ((sender, e) =>; { AddLog("SessionEnding       :" + e.Reason.ToString()); });SystemEvents.SessionEnded           += ((sender, e) =>; { AddLog("SessionEnded        :" + e.Reason.ToString()); });SystemEvents.PowerModeChanged       += ((sender, e) =>; { AddLog("PowerModeChanged    :" + e.Mode.ToString()); });SystemEvents.EventsThreadShutdown   += ((sender, e) =>; { AddLog("EventsThreadShutdown:" + e.ToString()); });}
何のイベントハンドラが動いたのか、またイベントのArgの中身を表示する。

*IsVisible = true,
この部屋がロビーにリストされるか
PhotonServerSettingsに設定した内容を使ってマスターサーバーへ接続する
*PhotonNetwork.ConnectUsingSettings();
*{// "Test"という名前のルームに参加する（ルームが無ければ作成してから参加する）PhotonNetwork.JoinOrCreateRoom("Test", _roomOptions, TypedLobby.Default);}
マスターサーバーへの接続が成功した時に呼ばれるコールバック
"Test"という名前のルームに参加する（ルームが無ければ作成してから参加する）
*PhotonNetwork.JoinOrCreateRoom("Test", _roomOptions, TypedLobby.Default);
*{//アバターを生成GameObject avatar = PhotonNetwork.Instantiate(_avatar.name,Vector3.zero,Quaternion.identity);avatar.name = _avatar.name;}
部屋への接続が成功した時に呼ばれるコールバック
アバターを生成
*GameObject avatar = PhotonNetwork.Instantiate(
*if (stream.IsWriting)*{
自身のクライアントから相手クライアントの同期オブジェクトに送る情報
*for (var i = 0; i <; _bonesL.Count; ++i)*{
ボーンのリストに受け取った値を反映
*{_leftHandVisual.transform.localPosition = (Vector3) stream.ReceiveNext();_leftHandVisual.transform.localRotation = (Quaternion) stream.ReceiveNext();//ボーンのリストに受け取った値を反映for (var i = 0; i <; _bonesL.Count; ++i){_bonesL[i].transform.localRotation = (Quaternion) stream.ReceiveNext();}}
相手のクライアントから自身のクライアントの同期オブジェクトに送られてくる情報
*for (var i = 0; i <; _bonesL.Count; ++i)*{
ボーンのリストに受け取った値を反映

以下の文章をWebViewRenderクラスを宣言しているところの直前に記述します．
*[assembly: ExportRenderer(typeof(TLExtensionWebView), typeof(TLExtensionWebViewRenderer))]
以下の文章をjavascriptで呼び出したい，JSBridgeのメソッドの直前に記述します．
*[JavascriptInterface]
*{var page = new ContentPage{Content = view};await Application.Current.MainPage.Navigation.PushModalAsync(page);}
フルスクリーンを実現するためのメソッド
フルスクリーンを実現するためのメソッド　ここまで
*,,,
*{return webClient;}
フルスクリーンにするための追加メソッド
*app.On<;Xamarin.Forms.PlatformConfiguration.Android>;().*UseWindowSoftInputModeAdjust(WindowSoftInputModeAdjust.Resize);
appにはMainActivityでロードするAppクラスのオブジェクトを入れておく．
WebViewRednererのOnElementChanged内
reloadActionはWebView側の変数
*_webView = (TLExtensionWebView)e.NewElement;
thisTabbedPageはTabbedPageのオブジェクト
falseをtrueにすると，スライドによるタブ切替えができるようになる．
*thisTabbedPage.On<;Xamarin.Forms.PlatformConfiguration.Android>;().SetIsSwipePagingEnabled(false);

*if (list2.Any() &amp;&amp; list2.All(n =<; n <; 0))
← false

*sw.Start();
計測開始

*{// アカウント作成UnaryResult<;(string userId, string password)>; CreateAccount();// ログインUnaryResult<;string>; Login(string userId, string password);}
アカウント周りのサービスを定義するインターフェース
アカウント作成
*UnaryResult<;(string userId, string password)>; CreateAccount();
ログイン
*UnaryResult<;string>; Login(string userId, string password);
*{try{// サーバーにアカウント作成を要求、レスポンスは作成されたユーザIDとパスワードreturn await accountService.CreateAccount();}catch (Exception e){Debug.Log(e);return (null, null);}}
アカウント作成
サーバーにアカウント作成を要求、レスポンスは作成されたユーザIDとパスワード
*return await accountService.CreateAccount();
*{try{// ユーザIDとパスワードをサーバーに投げてログイン、レスポンスはセッション情報session = await accountService.Login(userId, password);return session != null;}catch (Exception e){Debug.Log(e);session = null;return false;}}
ログイン
ユーザIDとパスワードをサーバーに投げてログイン、レスポンスはセッション情報
*session = await accountService.Login(userId, password);
ネットワークマネージャ取得
*var network = GetComponent<;NetworkManager>;();
保存してあるユーザーデータ情報を読み込み
*UserData userData = null;
*if (userData == null)*{
ユーザーデータが存在しなかったらアカウント作成
TODO: アカウント作成失敗時の処理
*Debug.LogWarning("アカウント作成失敗。。。");
ユーザー情報保存(※本来は暗号化等する事！)
*var data = MessagePackSerializer.Serialize(userData);
ログイン
*Debug.Log("ログイン中...");
TODO: ログイン失敗時の処理
*Debug.LogWarning("ログイン失敗。。。");
TODO: ログインが通った後の処理
*Debug.Log("ログイン成功！");
コンソールにログ出力するように設定
*GrpcEnvironment.SetLogger(new Grpc.Core.Logging.ConsoleLogger());
MagicOnionを使ってホスト作成、起動
*await MagicOnionHost.CreateDefaultBuilder()
セッション情報管理（本来はRedis等用いる事！）
*private static Dictionary<;string, (string userId, DateTime expireAt)>; sessions = new Dictionary<;string, (string userId, DateTime expireAt)>;();
*{Logger.Info("CreateAccount Request");var userId = GenerateHash(20);var password = GenerateHash(12);// アカウント情報を仮でファイルに保存(本来はDBに入れる事！)try{if (!Directory.Exists("accounts")) Directory.CreateDirectory("accounts");File.WriteAllText("accounts/" + userId, password);}catch (Exception e){Logger.Error(e, "CreateAccount Error");return (null, null);}Logger.Info($"CreateAccount UserId:{userId}, Password:{password}");return (userId, password);}
アカウント作成
*{if (!Directory.Exists("accounts")) Directory.CreateDirectory("accounts");File.WriteAllText("accounts/" + userId, password);}
アカウント情報を仮でファイルに保存(本来はDBに入れる事！)
*{Logger.Info("Login Request");try{// アカウントがないif (!File.Exists("accounts/" + userId)) return null;// パスワードが一致しないif (File.ReadAllText("accounts/" + userId) != password){Logger.Warning("Login failed: " + (userId, password));return null;};}catch (Exception e){Logger.Error(e, "Login Error");return null;}// セッション情報作成var session = GenerateHash(20);lock (lockObject){// 一先ず1日有効なセッションを保存sessions[session] = (userId, DateTime.UtcNow.AddDays(1));}Logger.Info("【" + userId + "】Login succeeded!");// セッションを返すreturn session;}
ログイン
*if (!File.Exists("accounts/" + userId)) return null;*// パスワードが一致しない
アカウントがない
*if (File.ReadAllText("accounts/" + userId) != password)*{
パスワードが一致しない
セッション情報作成
*var session = GenerateHash(20);
一先ず1日有効なセッションを保存
*sessions[session] = (userId, DateTime.UtcNow.AddDays(1));
セッションを返す
*return session;
*{return Sha256(Guid.NewGuid().ToString("N")).Substring(0, length).ToLower();}
指定の長さのランダムハッシュ値を取得
*{var input = Encoding.ASCII.GetBytes(str);var sha = new SHA256CryptoServiceProvider();var sha256 = sha.ComputeHash(input);var sb = new StringBuilder();for (int i = 0; i <; sha256.Length; i++){sb.Append(string.Format("{0:X2}", sha256[i]));}return sb.ToString();}
Sha256ハッシュ

*HttpSample scoreHttp = new HttpSample("https:
xxxxxxxxxxxxxxx.comapi");
await を使うことで、結果を同期的に扱える。
*HttpSample.Scores result = await Observable.FromCoroutine<;HttpSample.Scores>;(observer =>; scoreHttp.Get(observer));

VisualStudioでデバッグすると、デバッガの「出力」にリダイレクトされることに注意
Consoleに出力させるためには、デバッガを利用せずに起動すること。
コンソール表示ボタン
*var btnShow = new Button() { Location = new Point(10, 10), Text = "Show cons" };
Console表示
*AllocConsole();
*Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = true });
コンソールとstdoutの紐づけを行う。無くても初回は出力できるが、表示、非表示を繰り返すとエラーになる。
*var btnWrite = new Button() { Location = new Point(10, 60), Text = "Write cons" };
コンソール出力ボタン
*var btnHide = new Button() { Location = new Point(10, 110), Text = "Hide cons" };
コンソール非表示ボタン
*var form1 = new Form();*form1.Controls.Add(btnShow);
フォームに表示

*getViewsCountUrl = "https:
qiita.comapiv2items" + model.Id;
DB接続文字列の取得
*var connectionString = Parameter.getConnectionString();
*{// データベースの接続開始connection.Open();try{// マスタテーブルの更新チェックDatabase.checkMasterData(models, log, connection);// データを保存Database.saveData(models, jstTime, log, connection);}catch (Exception exception){log.LogInformation(exception.Message);throw;}finally{// データベースの接続終了connection.Close();}}
データ保存
データベースの接続開始
*connection.Open();
マスタテーブルの更新チェック
*Database.checkMasterData(models, log, connection);
データを保存
*Database.saveData(models, jstTime, log, connection);
データベースの接続終了
*connection.Close();
OAuth 2.0 Authorization Headerの設定
*httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", Parameter.getQiitaAccessToken());
*public static void checkMasterData(List<;QiitaInformationModel>; models, ILogger log, SqlConnection connection)*{
新たに記事が投稿された場合はマスタテーブルを更新
SQLの準備
*selectCommand.CommandText = @"SELECT id FROM qiita_items";
SQLの実行
*var table = new DataTable();
存在フラグ
*bool flg = false;
SQLの準備
*insertCommand.CommandText = @"INSERT INTO qiita_items VALUES (@ID, @TITLE, @CREATED_AT)";
*log.LogInformation($"succeeded to insert master data: {model.Title}");
SQLの実行
コミット
*transaction.Commit();
ロールバック
*transaction.Rollback();
*public static void saveData(List<;QiitaInformationModel>; models, DateTime jstTime, ILogger log, SqlConnection connection)*{
各記事のview数を保存
SQLの準備
*command.CommandText = @"INSERT INTO page_views_count VALUES (@ID, @COUNTED_AT, @PAGE_VIEWS_COUNT)";
*log.LogInformation($"succeeded to insert data: {model.Title}");
SQLの実行
コミット
*transaction.Commit();
ロールバック
*transaction.Rollback();

警告
*List<;DateTime>; date = null;
警告
*player.hp -= atk;
*if (player != null)*{
OK
警告
*player = null;

hpゲージを取得
*hpGaugeImage = Tools.GetComponentInObject<;Image>;("hogeGauge");
StackFrameクラスでstackを2階層戻る
*System.Diagnostics.StackFrame objStackFrame = new System.Diagnostics.StackFrame(2);

*bitmapBody[posIco+3] = pixels[pos+3];
alpha
32bit色のiconだとmaskではなくalpha channelが使用されるっぽい
*bitmapBody[posIco+3] = 0x00;
*public int Count {get{return iconEntries.Count;}}
------------------------------------------------------------------------------
*public int Count {get{return iconEntries.Count;}}
public members
*using ( var fs = new FileStream(path, FileMode.Create) ) {using ( var writer = new BinaryWriter(fs) ) {CopyDataToByteArray<;IconEntry.IconDir>;(writer, iconDir);foreach(var t in iconEntries) {t.WriteIconDirEntryTo(writer);}foreach(var t in iconEntries) {t.WriteDataTo(writer);}}}
int size =

*title = type.Name.Replace("Node", "");
クラス名から "Node" を削除したもの

*{get { return _points; }set { _points = value; OnPropertyChanged(nameof(Points)); }}
------------------------------------------------
*{var oc = sender as ObservableCollection<;Point>;;OnPropertyChanged(nameof(Points));Debug.WriteLine("count = " + oc.Count);});
Point追加時に自動でOnPropertyChangedしてくれるようにする

*for (int i = 0; i <; contours2.GetLength(0); ++i)*{
ノイズ除去

*CvOptFlow.UpdateMotionHistory(black_diff, motion_history, timestamp, duration);*Cv2.Normalize(motion_history, hist_gray, 0, 255, NormTypes.MinMax, MatType.CV_8UC1);
履歴画像の更新
履歴画像のモーション方向の計算
*double delta1 = 0.25;
各座標のモーション方向を緑色の線で描画
*var width_i = GRID_WIDTH;
全体的なモーション方向を計算
*angle_deg = CvOptFlow.CalcGlobalOrientation(orientation, mask, motion_history, timestamp, duration);
全体のモーション方向を黄色い線で描画
*Cv2.Circle(hist_color,

*var dayOfWeek = DateTime.Now.DayOfWeek;
曜日

*public string Text
TextBlockのTextへバインド
*{ProcessStartInfo info = new ProcessStartInfo{FileName = "Test.exe",UseShellExecute = false,CreateNoWindow = true};using (Process process = new Process()){process.StartInfo = info;process.EnableRaisingEvents = true;process.Exited += new EventHandler(OnExited);Text = "外部プログラム起動中";process.Start();await Task.Run(() =>; process.WaitForExit());}//この後に、外部アプリ終了後に実行したいコードを書くText = "外部プログラム終了";}
Commandに登録(バインド)されたメソッド
この後に、外部アプリ終了後に実行したいコードを書く
*Text = "外部プログラム終了";

*static void Main(string[] args)
メソッドの宣言

キー入力に使用
*var outChar = "";
現在時刻
*DateTime dt = DateTime.Now;
EncodeをShift-Jisに対応
*Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
シリアルポート取得
*SerialPort sp = new SerialPort("COM3");
*var sw = new System.IO.StreamWriter(PATH, false, System.Text.Encoding.GetEncoding("shift_jis"));*//Arduino側のサンプリング周波数
csv出力
Arduino側のサンプリング周波数
*sp.BaudRate = 9600;
センサ値1行分取得
*string data = sp.ReadLine();
csv出力
*sw.WriteLine(data);
*if (Console.KeyAvailable)*{
Q入力でプログラム終了

コントロールを指定して添付プロパティを取得、設定する
*var remark = ControlAttachedProperty.GetRemark(this.textBlock);

依存関係プロパティ
*public static readonly DependencyProperty TextProperty =
*{get =>; (string) this.GetValue(TextProperty);set =>; this.SetValue(TextProperty, value);}
CLR ラッパープロパティ
依存関係プロパティ
*public static readonly DependencyProperty TextProperty =
*{get =>; (string) this.GetValue(TextProperty);set =>; this.SetValue(TextProperty, value);}
CLR ラッパープロパティ

*{// Create the decoder from the streamvar decoder = await MyWaitUtil<;BitmapDecoder>;.GetResultWithWaiting(BitmapDecoder.CreateAsync(stream));// Get the SoftwareBitmap representation of the filesoftwareBitmap = await MyWaitUtil<;SoftwareBitmap>;.GetResultWithWaiting((decoder.GetSoftwareBitmapAsync()));}
https:docs.microsoft.com/ja-jp/windows/uwp/audio-video-camera/imaging
*{public static async Task<;T>; GetResultWithWaiting(IAsyncOperation<;T>; task){while(task.Status != AsyncStatus.Completed){if (task.Status == AsyncStatus.Error || task.Status == AsyncStatus.Canceled){Console.WriteLine("Error or Canceled");return default(T);}await Task.Delay(1);};return task.GetResults();}}
IAsyncOperationのGetAwaiterがないとか謎のコンパイルエラーがでたので、その対策として実装した

実運用ではコンソールではなくILogger&lt;&gt;を使っている
*Console.WriteLine(fmtCmd);
共通列を定義した基底クラスを用意
各エンティティクラスはこれを継承
*public abstract class AbstractEntity
更新対象列指定時のUpdateがうまくいかないので
それに対応するには別途拡張した仕組みを用意する必要があります。
*aEntity.UpdatedAt = now;

*static void Resize(Rectangle baseRect, int requiredWidth, int requiredHeight)
同上

エラーメッセージを返す
*return String.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, OtherPropertyDisplayName ?? OtherProperty);
比較対象のPropertyInfo
*PropertyInfo propertyInfo = validationContext.ObjectType.GetProperty(OtherProperty);
比較対象のプロパティの値
*object propertyValue = propertyInfo.GetValue(validationContext.ObjectInstance, null);
*if ((DateTime)value >; (DateTime)propertyValue)*{
ここで値の比較。条件を満たしていれば検証成功を返す
*if (OtherPropertyDisplayName == null)*{
...other type
*{ICustomTypeDescriptor typeDescriptor = GetTypeDescriptor(containerType);PropertyDescriptor property = typeDescriptor.GetProperties().Find(propertyName, true);if (property == null){throw new ArgumentException();}IEnumerable<;Attribute>; attributes = property.Attributes.Cast<;Attribute>;();DisplayAttribute display = attributes.OfType<;DisplayAttribute>;().FirstOrDefault();if (display != null){// DisplayAttributeがついてたらその名称を返すreturn display.GetName();}DisplayNameAttribute displayName = attributes.OfType<;DisplayNameAttribute>;().FirstOrDefault();if (displayName != null){// DisplayNameAttributeがついてたらその名称を返すreturn displayName.DisplayName;}return propertyName;}
比較対象のプロパティ名を取得する。ここはオマケなので削っても問題ない
DisplayAttributeがついてたらその名称を返す
*return display.GetName();
DisplayNameAttributeがついてたらその名称を返す
*return displayName.DisplayName;
開始時刻
LessThanAttributeのコードは割愛
*[LessThan("EndDateTime")]
*public DateTime EndDateTime { get; set; }
終了時刻

MediaFoundation使用前にMediaManager.Startupが必要
*MediaManager.Startup();
MediaFoundation終了処理
*MediaManager.Shutdown();
SourceReaderに動画のパスを設定
*attr.Set(SourceReaderAttributeKeys.EnableVideoProcessing.Guid, true);
出力メディアタイプをRGB32bitに設定
*newMediaType.Set(MediaTypeAttributeKeys.MajorType, MediaTypeGuids.Video);
元のメディアタイプから動画情報を取得する
duration:ビデオの総フレーム数
frameSize:フレーム画像サイズ（上位32bit:幅 下位32bit:高さ）
stride:フレーム画像一ライン辺りのバイト数
*var mediaType = reader.GetCurrentMediaType(SourceReaderIndex.FirstVideoStream);
取得する動画の位置を設定
*var mulPositionOfPercent = Math.Min(Math.Max(positionOfPercent, 0), 100.0) / 100.0;
動画から1フレーム取得し、Bitmapオブジェクトを作成してメモリコピー
*int actualStreamIndex;

処理
*}
他のことを継続して実行
*await process;
非同期処理
*}
他のことを継続して実行
*await process;
非同期処理
*return x;
非同期処理
*}
非同期処理
*return x;
処理
*});

データを更新したことを通知する
*this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(HogeText)));
例えば、ナビゲーターの項目を押したタイミングで、HogeDataの内容を更新する
*var hogeData = Application.Current.Resources["HogeDataInstance"] as HogeData;

*{get =>; (double)GetValue(MyDoubleValue2Property);set { Console.WriteLine(" - UserControl DoubleValue2 = {0} ", value); SetValue(MyDoubleValue2Property, value); }}
---------------------------------------------------------------------------
*{get =>; (double)GetValue(MyDoubleValue3Property);set { Console.WriteLine(" - UserControl DoubleValue3 = {0} ", value); SetValue(MyDoubleValue3Property, value); }}
---------------------------------------------------------------------------
*{InitializeComponent();}
コンストラクタ

*Console.WriteLine(ReferenceEquals(r1, r2));
True

*{var func = GetMethod();args.ForEach(input =>; func(input).Work(input));}
本筋
*{IWorker human = null, robot = null;return (input) =>;{return input is int? (human ?? (human = new Human())): (robot ?? (robot = new Robot()));};}
本筋に書きたくない部分
*{public Human() =>; Console.WriteLine("Human new!!");public void Work(dynamic value) =>;  Console.WriteLine("human " + value);}
数字の時に働く
*{public Robot() =>; Console.WriteLine("Robot Created!!");public void Work(dynamic value) =>; Console.WriteLine("robot " + value);}
文字の時に動く

*stepMouseUp.Type = 0;
MOUSE = 0

Webページを開く
driver.Navigate().GoToUrl("https:www.google.co.jp");
検索ボックスに検索ワードを入力
*IWebElement el = wait.Until(SeleniumExtras.WaitHelpers.ExpectedConditions.ElementExists(By.Name("q")));
検索結果が出たという判定を何にするか?? は仕様依存??
*IWebElement firstResult = wait.Until(SeleniumExtras.WaitHelpers.ExpectedConditions.ElementExists(By.TagName("h3")));
ページソースの出力
*Console.WriteLine(driver.PageSource);

*int endPageIndex   = Int32.MaxValue-1;
no limit

*00100 == (00100)
=&gt; true

Pdf ファイルをロードします。
*PdfDocument doc = new PdfDocument();
UsedFontsでフォントを取得します。
*PdfUsedFont[] fonts = doc.UsedFonts;
新規フォントを作成します。
*Font newfont = new PdfFont(PdfFontFamily.TimesRoman, 18f, PdfFontStyle.Italic | PdfFontStyle.Bold);
*foreach (PdfUsedFont font in fonts)*{
ファイルのフォントをループして、新規フォントを適用します。
保存します。
*doc.SaveToFile(Result file);

OpenQA.Selenium.Chrome; を使用する版

*private void btnEdge_Click(object sender, EventArgs e)
Webページを開く
driver.Navigate().GoToUrl("https:www.google.co.jp");
検索ボックスに検索ワードを入力
*IWebElement el = wait.Until(SeleniumExtras.WaitHelpers.ExpectedConditions.ElementExists(By.Name("q")));
検索結果が出たという判定を何にするか??　は仕様依存??
*IWebElement elm = wait.Until(SeleniumExtras.WaitHelpers.ExpectedConditions.ElementExists(By.TagName("h3")));
ページソースの出力
*Console.WriteLine(driver.PageSource);
using OpenQA.Selenium.Chrome; を使用しない版

*private void btnEdgeTool_Click(object sender, EventArgs e)
Webページを開く
driver.Navigate().GoToUrl("https:www.google.co.jp");
検索ボックスに検索ワードを入力
*IWebElement el = wait.Until(ExpectedConditions.ElementExists(By.Name("q")));
検索結果が出たという判定を何にするか?? は仕様依存??
*IWebElement elm = wait.Until(ExpectedConditions.ElementExists(By.TagName("h3")));
ページソースの出力
*Console.WriteLine(driver.PageSource);

*Random rnd = new Random(3);
Randomオブジェクトを作成

スレッド間で共通のLoggerを定義
*public static LogFactory factory = new LogFactory();
Logの出力先を設定
*logger.Factory.Configuration.Variables["userId"] = userId.ToString();
Logの出力
*logger.Info(message);
*{logger.Factory.Configuration.Variables["userId"] = userId.ToString();logger.Factory.Configuration.Variables["outputDateTime"] = DateTime.Now.ToString();logger.Info(message);}
外からLoggerを渡すようにする
スレッドが立ちあがる際にインスタンス生成
*public Logger apiLogger = NLog.LogManager.GetLogger("API");
今生きているすべてのスレッドのloggerにuserIdとoutputDateTimeを反映してしまう
*logger.Factory.ReconfigExistingLoggers();
結果、スレッド間のタイミングでここに来た際に書き変わっていることがある。
*logger.Info(message);
スレッドが立ちあがる際にインスタンス生成
*public Logger apiLogger = NLog.LogManager.GetLogger("API");
static関数内でセットするとstaticのスレッドに適用されてしまうので、こちらに出しました。
*NLog.MappedDiagnosticsContext.Set("userId", userId.ToString());

sqlの用意
*string sql = @"
*{empId = "E0010",firstName = "たろー",createdAt = DateTime.Now,updatedAt = DateTime.Now,};
パラメータの用意
実行
*database.Execute(sql, param);
sqlの用意
*string sql = @"
*{deptCode = "001"};
パラメータの用意
実行
*List<;EmpAndDeptNameDto>; results = database.Fetch<;EmpAndDeptNameDto>;(sql, param);

*public void Open(Action onFinished){}
引数でコールバックを指定するようなよくある奴
*{var ret = new Awaiter();Open(() =>; { ret.SetResult(); });return ret;}
これを追加する
*{var simple = new SimpleCallbackComponent();simple.Open(() =>;{Debug.Log("1");var simple2 = new SimpleCallbackComponent();simple2.Open(() =>;{Debug.Log("2");var simple3 = new SimpleCallbackComponent();simple3.Open(() =>;{Debug.Log("3");});});});}
地獄の例
*{var simple = new SimpleCallbackComponent();await simple.OpenAwait();Debug.Log("1");var simple2 = new SimpleCallbackComponent();await simple2.OpenAwait();Debug.Log("2");var simple3 = new SimpleCallbackComponent();await simple3.OpenAwait();Debug.Log("3");}
幸せな例
*public void Open(Action onOpened,Action<;int>; onClosed){}
引数でコールバックを複数指定してそのあげくに引数を伴って呼ばれたりするよくある奴
*public void Open(Action onOpened,Action<;int>; onClosed){}
onOpened のあとに onClosed が呼ばれるものとする
*{var opened = new Awaiter();var closed = new Awaiter<;int>;();Open(() =>; { opened.SetResult(); },(result) =>; { closed.SetResult(result); });return Tuple.Create(opened, closed);}
こんなのを追加する
*{public void TestCallbacksComponent(){var simple = new CallbacksComponent();simple.Open(() =>; { Debug.Log("Opened 1"); },(result) =>;{Debug.Log("Closed 1");var simple2 = new CallbacksComponent();simple2.Open(() =>; { },(result2) =>;{Debug.Log($"Closed 2: {result2}");var simple3 = new CallbacksComponent();simple3.Open(() =>; { Debug.Log("Opened 3"); },(result3) =>; { });});});},,,public async void TestCallbacksComponentAwait(){var simple = new CallbacksComponent();var (opened, closed) = simple.OpenAwait();await opened;Debug.Log("Opened 1");// var result = await closed;await closed;Debug.Log("Closed 1");var simple2 = new CallbacksComponent();//(opened, closed) = simple2.OpenAwait();(_, closed) = simple2.OpenAwait();// await opened;var result2 = await closed;Debug.Log($"Closed 2: {result2}");var simple3 = new CallbacksComponent();(opened,_) = simple3.OpenAwait();await opened;Debug.Log("Opened 3");}}
地獄の例
*Debug.Log($"Closed 2: {result2}");
await opened;

塗りつぶし
*using (SolidBrush brush = new SolidBrush(backColor))
枠線
*using (Pen pen = new Pen(borderColor))
テキスト描画
*using (Font font = new Font("Meiryo UI", 10f))
列追加
*var cols = Enumerable.Range(0, colCount).Select(idx =>;
*foreach (int rowIdx in Enumerable.Range(0, rowCount))*{
行追加
塗りつぶし
*using (SolidBrush brush = new SolidBrush(backColor))
枠線
*using (Pen pen = new Pen(borderColor))
テキスト描画
*using (Font font = new Font("Meiryo UI", 10f))

スマートアートを挿入します。
*Presentation pres = new Presentation();
スマートアートのタイプを設定します。
*sa.Style = Spire.Presentation.Diagrams.SmartArtStyleType.SubtleEffect;
*foreach (object a in sa.Nodes)*sa.Nodes.RemoveNode(a);
図形をすべて除きます。
カスタムの図形を追加します。
*Spire.Presentation.Diagrams.ISmartArtNode node = sa.Nodes.AddNode();
保存します。
*pres.SaveToFile("SmartArtTest1.pptx", FileFormat.Pptx2007);

Webページを開く
driver.Navigate().GoToUrl("https:www.google.co.jp");
検索ボックスに検索ワードを入力
*IWebElement el = wait.Until(SeleniumExtras.WaitHelpers.ExpectedConditions.ElementExists(By.Name("q")));
検索結果が出たという判定を何にするか??　は仕様依存??
*IWebElement firstResult = wait.Until(SeleniumExtras.WaitHelpers.ExpectedConditions.ElementExists(By.TagName("h3")));
ページソースの出力
*Console.WriteLine(driver.PageSource);

メッセージを表示する
*}

文字列で指定
*[PrimaryKey("col1,col2")]
*[PrimaryKey(new string[] { "col1", "col2" })]
配列で指定
主キー指定で既存データの取得
*Emp updEmp = database.SingleOrDefaultById<;Emp>;("E0001");
スナップショットの取得
*var snapshot = database.StartSnapshot(updEmp);
更新対象列を指定したアップデート
UpdatedColumnsメソッドで変更のある列の一覧を取得できる。
*database.Update(updEmp, snapshot.UpdatedColumns());

*eff.GetComponent<;Renderer<;().material.SetFloat("_StartTime", Time.time);
ここに注目
*{Vector3 pos = GetComponent<;Transform>;().position;pos.x += BulletSpeed * Time.deltaTime;transform.position = pos;GameDataMemo Limit = GameDataMemo.GetComponent<;GameDataMemo>;();if(pos.x>;Limit.RightLimitGetter()|| pos.x <; Limit.LeftLimitGetter() || pos.y >; Limit.UpLimitGetter() || pos.y <; Limit.DownLimitGetter()){Destroy(gameObject);}}
Update is called once per frame

画面を表示せず、アプリケーションを実行します。
Application.Run(new MainForm());
*var form = new MainForm();
WindowsAPIのインポート
*[System.Runtime.InteropServices.DllImport("user32.dll",
アクティブなウィンドウのデバイスコンテキストを取得
*IntPtr hWnd = NativeMethods.GetForegroundWindow();
ウィンドウの大きさを取得
*NativeMethods.RECT winRect = new NativeMethods.RECT();
Bitmapの作成
*var offsetX = bounds.left - winRect.left;
*using (var g = Graphics.FromImage(bmp)) {//Graphicsのデバイスコンテキストを取得IntPtr hDC = g.GetHdc();//Bitmapに画像をコピーするConsole.WriteLine(winRect);NativeMethods.BitBlt(hDC, 0, 0, bmp.Width, bmp.Height, winDC, offsetX, offsetY, NativeMethods.SRCCOPY);//解放g.ReleaseHdc(hDC);}
Graphicsの作成
Graphicsのデバイスコンテキストを取得
*IntPtr hDC = g.GetHdc();
Bitmapに画像をコピーする
*Console.WriteLine(winRect);
解放
*g.ReleaseHdc(hDC);

*SkinnedMeshRenderer skinnedMeshRenderer = other.gameObject.transform.parent.parent.parent.GetComponent<;SkinnedMeshRenderer>;();*if (skinnedMeshRenderer != null)
この書き方については今回の本題ではないのでスルー安定
マテリアルを手に適用
*skinnedMeshRenderer.material = _meshRenderer.material;

*using System.Text.RegularExpressions;
これを追加
*if (Last == 'ー' || Last == '－')*{
長音一文字の単語はない前提
*{return PrecureList.Where(x =>; precure.Last == x.First).ToList();}
候補の単語を列挙する

*public JewelryBox(string item) : base(item)
コンストラクタはBoxと同じ内容
System.Console.WriteLine();  usingでSystemの名前空間を指定しているので、Systemが省略可能。
*Console.WriteLine();
デリゲート型の変数を宣言
*public delegate void Test();
デリゲートにメソッドの代入
*Test hoge = Hoge;
デリゲートを実行
*hoge();
*static void Hoge() {Console.WriteLine("hoge");}
デリゲートに代入するメソッド
デリゲート型の変数を宣言
*public delegate void Test();
*Test hoge = delegate(){Console.WriteLine("hoge")};
デリゲートにメソッドの定義を代入
デリゲートを実行
*hoge();
*var test = list.Select(delegate(int n){ return 0 <; n });
#0 匿名メソッド
*var test = list.Select((int n) =>; { return 0 <; n });
#1 delegateキーワードを演算子=&gt;に置き換え（位置がちょっと変わる）
*var test = list.Select((n) =>; { return 0 <; n });
#2 引数の型推論が出来るので、型を省略
#3 中身が1行なら[]とreturnは省略
*var test = list.Select((n) =>; 0 <; n);
#4 引数が一つなら()も省略（0はダメらしい）
*var test = list.Select(n =>; 0 <; n);

*workbook.LockStructure();
ワークブックの構造を保護(ただしパスワードはかからない)

*driver.Navigate().GoToUrl("https:
www.google.com");

*DisplayRootViewFor<;ShellViewModel<;();
←後半でエラーとなる警告がでるが、そのまま（後述）

モード指示子 英数字固定
*string modeIndicator = "0010";
*while (lenIndicator.Length <; 9) { lenIndicator = "0" + lenIndicator; }
文字数指示子
データ
*string data = "";
終端パターン
*string terminator = "0000";
*List<;int>; exponent = new List<;int>;() { 1 };
リードソロモン誤り訂正方式で誤り訂正コード語作成
QRコード生成
*int QRsize = 21;
*for (int i = 0; i <; QRsize; ++i)*{
初期化
*for (int i = 0; i <; QRsize; ++i)*{
タイミングパターン
位置検出パターン
*int startrow, startcol;
データを埋めていく
*int row = QRsize-1;
*for (int i = 0; i <;= 20; ++i)*{
マスク処理
*string formatStr = "000010111001100";*int index = 0;
string formatStr = "001100111010000";
コンソールでQRコード出力
*Console.WriteLine("");
モード指示子 英数字固定
*string modeIndicator = "0010";
*while (lenIndicator.Length <; 9) { lenIndicator = "0" + lenIndicator; }
文字数指示子
データ
*string data = "";
終端パターン
*string terminator = "0000";
*{for (int i = 25; i >;= 0; i--) { if (function[i] >; 0) { return i; } }return 0;}
多項式の最高次を求める
*for (int i = 0; i <; QRsize; ++i)*{
初期化
*for (int i = 0; i <; QRsize; ++i)*{
タイミングパターン
位置検出パターン
*int startrow, startcol;

*{var pos = transform.position;if (Input.GetKey("right")){pos = new Vector3(pos.x + speed,pos.y,pos.z);}if (Input.GetKey("left")){pos = new Vector3(pos.x - speed,pos.y,pos.z);}transform.position = pos;}
Update is called once per frame

*new Vector2(270, 0),
以下同様
*//Throw(3, 0); //forward(z+)方向に投げて3が出る*//Throw(1, 90, (o, pip) =>; Debug.Log(pip)); //right(x+)方向に投げて1が出る。サイコロが止まったらコンソールに1を出す。
使い方
Throw(3, 0); forward(z+)方向に投げて3が出る
Throw(1, 90, (o, pip) =&gt; Debug.Log(pip)); right(x+)方向に投げて1が出る。サイコロが止まったらコンソールに1を出す。
*}

*public string ParameterName { get; set; }
パラメータのnullチェックをするかどうか
*string message = $"バリデート:{ParameterName}に数字以外が含まれます。";
数字じゃない
actionContext.Result = new BadRequestResult(); こっちだと既定のbodyが返る
*}
*string message = string.Join("; ", actionContext.ModelState.Select(pair=>;$"{pair.Key} = {pair.Value.RawValue.ToString()} "));
Data Annotationsでひっかかった
actionContext.Result = new BadRequestResult(); こっちだと既定のbodyが返る
*}
その他チェックすべきものがあれば実装
*base.OnActionExecuting(actionContext);
*{[Route("api/[controller]")][ApiController]public class IdController : ControllerBase{// GET: api/<;IdController>;[HttpGet][ValidateId(ParameterName = "id")]public IEnumerable<;string>; Get(string id){return new string[] { "id", id };}}}
For more information on enabling Web API for empty projects, visit https:go.microsoft.com/fwlink/?LinkID=397860

EventTriggerコンポーネントを取得
*EventTrigger eventTrigger = gameObject.GetComponent<;EventTrigger>;();
イベントの設定に入る
*EventTrigger.Entry entry = new EventTrigger.Entry();
PointerDown(押した瞬間に実行する)イベントタイプを設定
*entry.eventID = EventTriggerType.PointerDown;
*{Trigger();});
関数を設定
イベントの設定をEventTriggerに反映
*eventTrigger.triggers.Add(entry);
ボタンクリックしたらボタンイベント関数を呼ぶ
*btn.onClick.AddListener(BtnEvent);
Rayを発射
*Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
*if (!hit2d)*{
Rayで何もヒットしなかったら画面タッチイベント関数を呼ぶ
*{txt.text = "Screen Pushed";}
画面タッチ用イベント
*{txt.text = "Button Pushed";}
ボタンクリック用イベント

*if(pnl.RunModal() == 1)
OK : 1, Cancel : 0

*command.CommandTimeout = 60000;
コマンドがタイムアウトする場合は秒数を変更(ms) デフォルトは 30秒

*method.Invoke(null, new object[] { IntPtr.Zero, "Run Invoke", "test1", 0});
Invokeで実行
Delegateで実行
*DlgMessageBox messageBox = (DlgMessageBox)method.CreateDelegate(typeof(DlgMessageBox));

*Vector3 cross = Vector3.Cross(norm, target);
外積
上のコードの続き
*cross = cross.normalized;

*options.User.AllowedUserNameCharacters = null;
null か "" で日本語にも対応する
*{// UserName 追加[Required][Display(Name = "UserName")]public string UserName { get; set; }[Required][EmailAddress][Display(Name = "Email")]public string Email { get; set; }//...}
...
UserName 追加
*[Required]
*var user = new IdentityUser { UserName = Input.UserName, Email = Input.Email };
UserName = Input.Email -&gt; Input.UserName に変更

ここで指定した秒数止める
*yield return new WaitForSeconds(_delayTime);
ここから処理
*}
この間に処理
この間に処理
ここで指定した秒数止める
*yield return new WaitForSeconds(_delayTime);
この間に処理
この間に処理
ここで指定した秒数止める
*yield return null;
*if (startUp==true)*{
この処理が動いていたら２重に呼び出されてもここで止める
↑で処理を止めるフラグをtureに
*startUp = true;
カラー情報を取得
*Color color = _sr.color;
*while (_sr.color.a>;=0)*{
α値を0になるまで減らす
α値を減らす
*color.a -= _decrease*Time.deltaTime;
カラーを適応
*_sr.color = color;
処理を1フレーム遅らせ続ける
*yield return null;
処理を終了
*startUp = false;
*if (startUp==true)*{
この処理が動いていたら２重に呼び出されてもここで止める
↑で処理を止めるフラグをtureに
*startUp = true;
カラー情報を取得
*Color color = _sr.color;
*while (_sr.color.a<;=1)*{
α値を0になるまで減らす
α値を増やす
*color.a += _add*Time.deltaTime;
カラーを適応
*_sr.color = color;
処理を1フレーム遅らせ続ける
*yield return null;
処理を終了
*startUp = false;

*command.CommandTimeout = 60000;
コマンドがタイムアウトする場合は秒数を変更(ms) デフォルトは 30秒

文字列でコルーチンの名前を書く
*StartCoroutine("Test");
コルーチンを関数呼び出しのように書く
*StartCoroutine(Test());
コルーチンを関数呼び出しのように書く
*StartCoroutine(Test(10,"名前"));
処理を止めて次のフレームに処理を開始する場所
*yield return null;
処理を止めて次のフレームに処理を開始する場所
*yield return 0;
ここで処理を強制的に止めます
*yield break;
処理をここで止めて引数で渡した数値秒経ったら処理をここから再開
*yield return new WaitForSeconds(1f);

アニメーション情報を読み込む
*var animationInfoHandle = Addressables.LoadAssetAsync<;SSpriteAnimationInfo>;(ScriptableResources.SPRITE_ANIMATION);

*[PrimaryKey("emp_id", AutoIncrement = false)]
AutoIncrement = falseとしておかないと自動採番対象とみなされてしまう。
PostgreSQL用接続文字列
*private const string connectionString = "Host=localhost;Database=test_db;Username=test_user;Password=test_user";
DbConnectionの準備
*using NpgsqlConnection con = new NpgsqlConnection(connectionString);
NPocoの操作の中心となるクラスを作成
*using Database database = new Database(con);
*{EmpId = "00001",FirstName = "Taro",FamilyName = "Tanaka",CreatedAt = DateTime.Now,};
インサート
セレクト
*Emp selectedEmp1 = database.Query<;Emp>;()
アップデート
*var ss = database.StartSnapshot(selectedEmp1);
変更した列だけ更新
*database.Update(selectedEmp1, ss.UpdatedColumns());
デリート
*database.Delete(selectedEmp2);
トランザクションをコミット
*database.CompleteTransaction();
例外時はロールバック
*database.AbortTransaction();

*command.CommandTimeout = 60000;
コマンドがタイムアウトする場合は秒数を変更(ms) デフォルトは 30秒

*Console.WriteLine("--ExitEveryRule");
{0},{1}--",context.Start,context.Stop);

*list.Remove(42);
will ALWAYS return true (otherwise, assertion failure at the line above)

*bool ret3 = Config.Entry.Exists("設定1","子階層");
=&gt; true

*random_array[chunkIndex] = random;
ランダム配列に書き戻しが必要
*if (gun.magazine >; 0) {gun.counter = gun.shotBlazeInterval;} else {gun.counter = gun.shotTimeInterval;}
残弾数があれば連射間隔をカウンタに設定
*if (gun.magazine >; 0) {*gun.counter = gun.shotBlazeInterval;
残弾数が0になっていたら停止間隔をカウンタに設定

*public int damage;
あたったときのダメージ量
まずはイベント登録
どこかのSceneContext
*public class SceneContextInstaller : MonoInstaller
BindMessageBrokerでイベント登録
*Container.BindMessageBroker<;LogEvent>;(option);
*{// Zenjectが勝手にInjectしてくれる[Inject] IPublisher<;BulletHitEvent>; _bulletHitEvent;[Inject] IPublisher<;LogEvent>; _logEvent;// 敵にあたったとき呼び出されるpublic void Hit(Enemy enemy){_bulletHitEvent.Publish(new BulletHitEvent { enemy = enemy, damage = 10 };}// なにか致命的なエラーが起きたときなどpublic void NanrakanoError(){_logEvent.Publish(new LogEvent{logMessage = "何らかのエラーが起きました",errorType = ErrorType.Error};}}
弾クラス
Zenjectが勝手にInjectしてくれる
*[Inject] IPublisher<;BulletHitEvent>; _bulletHitEvent;
*{_bulletHitEvent.Publish(new BulletHitEvent { enemy = enemy, damage = 10 };}
敵にあたったとき呼び出される
*{_logEvent.Publish(new LogEvent{logMessage = "何らかのエラーが起きました",errorType = ErrorType.Error};}
なにか致命的なエラーが起きたときなど
*{// Zenjectが勝手にInjectしてくれる[Inject] ISubscriber<;BulletHitEvent>; _bulletHitEvent;[Inject] ISubscriber<;LogEvent>; _logEvent;public void Setup(){// Subscribeしてイベントを受け取る_bulletHitEvent.Subscribe(....);_logEvent.Subscribe(....);}}
どこかのSceneでログを受け取る
Zenjectが勝手にInjectしてくれる
*[Inject] ISubscriber<;BulletHitEvent>; _bulletHitEvent;
Subscribeしてイベントを受け取る
*_bulletHitEvent.Subscribe(....);
*{public void Awake(){// GlobalMessagePipeから直接LogEventのSubscriberを取得できる。そして即購読var subscriber = GlobalMessagePipe.GetSubscriber<;LogEvent>;();subscriber.Subscribe(ev =>;{// コンソールに出したり、通信でログサーバーに送ったり});}}
Manager的な人がゲーム全体で発行されたLogEventを受信する
GlobalMessagePipeから直接LogEventのSubscriberを取得できる。そして即購読
*var subscriber = GlobalMessagePipe.GetSubscriber<;LogEvent>;();
コンソールに出したり、通信でログサーバーに送ったり
*});
*{public void NanrakanoError(){// 同じようにPublisherも直接取得して即時イベント発行var publisher = GlobalMessagePipe.GetPublisher<;LogEvent>;();_logEvent.Publish(new LogEvent{logMessage = "何らかのエラーが起きました",errorType = ErrorType.Error};}}
バトルシーン
同じようにPublisherも直接取得して即時イベント発行
*var publisher = GlobalMessagePipe.GetPublisher<;LogEvent>;();

*for (int j = 0; j <; types.Length; j++)*{
コンポーネントの初期値設定をする

点の基準平面上への射影点を求める
*Point3d onPlanePoint = plane.ClosestPoint(pts[i]);
射影点での基準平面上での座標を求める
*plane.ClosestParameter(onPlanePoint, out xi, out yi);
点の基準平面上での距離を求める
*zi = onPlanePoint.DistanceTo(pts[i]);
*if ((pts[i] - onPlanePoint) * plane.Normal <; 0) zi *= -1;*this.x[i] = xi;
基準平面の裏側にあったら負の値にする
RBF Model を宣言
*alglib.rbfmodel model;
入力が2次元、出力が１次元として RBF Model を初期化
*alglib.rbfcreate(2, 1, out model);
サンプル点を RBF Model にセット
*alglib.rbfsetpoints(model, this.samplePlanarCoordsScaled);
RBF Model のパイパーパラメータ設定
*alglib.rbfsetalgohierarchical(model, this.rBase, this.nLayers, this.smooth);
モデル構築に関する情報を入れるクラスを宣言
*alglib.rbfreport rep;
RBF Model 構築
*alglib.rbfbuildmodel(model, out rep);
クラスプロパティに代入
*this.Model = model;
U 方向のネットワークスプライン曲線群を作る
*Curve[] uCurves = new Curve[U + 1];
V 方向のネットワークスプライン曲線群を作る
*Curve[] vCurves = new Curve[V + 1];
Network Surface の構築
*int error;
U 方向のネットワークスプライン曲線群を作る
*Curve[] uCurves = new Curve[U + 1];
V 方向のネットワークスプライン曲線群を作る
*Curve[] vCurves = new Curve[V + 1];
Network Surface の構築
*int error;
点の基準平面上への射影点を求める
*Point3d onPlanePoint = plane.ClosestPoint(pts[i]);
射影点での基準平面上での座標を求める
*plane.ClosestParameter(onPlanePoint, out xi, out yi);
点の基準平面上での距離を求める
*zi = onPlanePoint.DistanceTo(pts[i]);
*if ((pts[i] - onPlanePoint) * plane.Normal <; 0) zi *= -1;*this.x[i] = xi;
基準平面の裏側にあったら負の値にする
RBF Model を宣言
*alglib.rbfmodel model;
入力が2次元、出力が１次元として RBF Model を初期化
*alglib.rbfcreate(2, 1, out model);
サンプル点を RBF Model にセット
*alglib.rbfsetpoints(model, this.samplePlanarCoordsScaled);
モデル構築に関する情報を入れるクラスを宣言
*alglib.rbfreport rep;
RBF Model 構築
*alglib.rbfbuildmodel(model, out rep);
クラスプロパティに代入
*this.Model = model;
*// You can use the _GrasshopperDeveloperSettings Rhino command for that.*namespace PCloud2Surface
folder in Grasshopper.
*{public class RBFComponent : GH_Component{/// <;summary>;/// Each implementation of GH_Component must provide a public/// constructor without any arguments./// Category represents the Tab in which the component will appear,/// Subcategory the panel. If you use non-existing tab or panel names,/// new tabs/panels will automatically be created./// <;/summary>;public RBFComponent(): base("RBF from PCloud", "RBF PCloud","Create a RBF instance.","Interpolation", "RBF"){}/// <;summary>;/// Registers all the input parameters for this component./// <;/summary>;protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager){pManager.AddPointParameter("Sample Pts", "Pts", "Sampling point to interpolate.", GH_ParamAccess.list);pManager.AddPlaneParameter("Plane", "P", "A reference plane.", GH_ParamAccess.item);pManager.AddIntegerParameter("Number of Layers", "nLayers", "A number of layers of a RBF network.", GH_ParamAccess.item);pManager.AddNumberParameter("Radius of Basis Function", "rBase", "A radius of the RBF.", GH_ParamAccess.item);pManager.AddNumberParameter("Smooth Prameter", "Smooth", "A parameter of smoothing of a RBF network", GH_ParamAccess.item);}/// <;summary>;/// Registers all the output parameters for this component./// <;/summary>;protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager){pManager.AddGenericParameter("RBF", "RBF", "A RBF Interpolation instance which create interpolated surface from the input point cloud.", GH_ParamAccess.item);}/// <;summary>;/// This is the method that actually does the work./// <;/summary>;/// <;param name="DA">;The DA object can be used to retrieve data from input parameters and/// to store data in output parameters.<;/param>;protected override void SolveInstance(IGH_DataAccess DA){List<;Point3d>; samplePts = new List<;Point3d>;();Plane plane = new Plane();int nLayers = 3;double rBase = 1;double smooth = 0;DA.GetDataList(0, samplePts);DA.GetData(1, ref plane);DA.GetData(2, ref nLayers);DA.GetData(3, ref rBase);DA.GetData(4, ref smooth);RBFInterpolation rbf = new RBFInterpolation(samplePts, plane, nLayers, rBase, smooth);DA.SetData(0, rbf);}/// <;summary>;/// Provides an Icon for every component that will be visible in the User Interface./// Icons need to be 24x24 pixels./// <;/summary>;protected override System.Drawing.Bitmap Icon{get{// You can add image files to your project resources and access them like this://return Resources.IconForThisComponent;return null;}}/// <;summary>;/// Each component must have a unique Guid to identify it./// It is vital this Guid doesn't change otherwise old ghx files/// that use the old ID will partially fail during loading./// <;/summary>;public override Guid ComponentGuid{get { return new Guid("4567ec83-ae6c-4e65-a7bd-bb52300d6c1e"); }}}}
You can use the _GrasshopperDeveloperSettings Rhino command for that.

敵の設定値を取得する
*var q = string.Format(SELECT, id);
敵ごとのコンポーネント一覧を取得する
*List<;int>; componentIds = new List<;int>;();

*"https:
some.blob.core.windows.nethealthcheckhello.json"
*Console.WriteLine($"StatusCode: {response.StatusCode}");
TODO Retry

*var htmlCode = GenerateHtml(textFor)
Inserts textFor to html code. Details are omitted here.

*var list = XDocument.Load("https:
some.blob.core.windows.nethealthcheck?restype=container&amp;comp=list")

*services.AddDbContext<;AppDbContext<;(options =<; options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
追加
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();app.UseWebAssemblyDebugging();}else{app.UseExceptionHandler("/Error");}app.UseBlazorFrameworkFiles();app.UseStaticFiles();app.UseRouting();app.UseEndpoints(endpoints =>;{endpoints.MapRazorPages();endpoints.MapControllers();endpoints.MapFallbackToFile("index.html");});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
*[HttpGet("{id}")]
ここから追加
ここまで追加
*}
*[HttpDelete("{id}")]
ここから追加
ここまで追加
*}
ここから追加
*[HttpPut]
ここまで追加
*}

*public string uri = "http:
weather.livedoor.comforecastwebservicejsonv1?city=130010";

ViewEnginesの削除・登録
*ViewEngines.Engines.Clear();
Controller.ControllerContextにMockオブジェクトを設定
*var controller = new TestController();

*[Authorize(Roles = "Admin")]
変更

*public static TweenerCore<;float, float, FloatOptions>; DOCurveAround(this Transform transform, Vector3 axis, Vector3 center, float degree, float duration)*{
centerを中心、axisを軸として、degree(度)回転する
*public static TweenerCore<;float, float, FloatOptions>; DOCurveAroundAndRotate(this Transform transform, Vector3 axis, Vector3 center, float degree, float duration)*{
オブジェクトそのものも回転させる
使い方
(x,y,z)=(2,0,0)を中心に3秒かけて90度回転させる。
transform.DOCurveAround(Vector3.up, new Vector3(2, 0, 0), 90, 3);
*}

skipのパラメーターをいじると任意の行を指定できる
*int n = 0;

*actions.Click(panel);
panel1をクリック

*if(typeof(T) == typeof(int))*{
1. typeof &amp; Unsafe.As
*if(value is Foo value_Foo)*{
2. is operator
*public static DoSomethingStrategy<;T>; Instance { get; }
3'. strategy pattern &amp; Activator
*public static DoSomethingStrategy<;T>; Instance { get; set; }
外部からデフォルトインスタンスを流し込む場合にはsetアクセサも公開する必要がある
*public static DoSomethingStrategy<;T>; Instance { get; }
Activatorによるインスタンス生成をすることで型制約を回避する

TODO: マネージド状態を破棄します (マネージド オブジェクト)
*}
TODO: アンマネージド リソース (アンマネージド オブジェクト) を解放し、ファイナライザーをオーバーライドします
TODO: 大きなフィールドを null に設定します
*disposedValue = true;
*// {//     // このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します//     Dispose(disposing: false);// }
TODO: 'Dispose(bool disposing)' にアンマネージド リソースを解放するコードが含まれる場合にのみ、ファイナライザーをオーバーライドします
*// {//     // このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します//     Dispose(disposing: false);// }
~A()
このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します
Dispose(disposing: false);
}
*public void Dispose()
このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します
*Dispose(disposing: true);
*{Console.WriteLine($"A.~A()");// このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述しますDispose(disposing: false);}
TODO: 'Dispose(bool disposing)' にアンマネージド リソースを解放するコードが含まれる場合にのみ、ファイナライザーをオーバーライドします
このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します
*Dispose(disposing: false);
このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します
*Dispose(disposing: true);
*// {//     // このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します//     Dispose(disposing: false);// }
TODO: 'Dispose(bool disposing)' にアンマネージド リソースを解放するコードが含まれる場合にのみ、ファイナライザーをオーバーライドします
*// {//     // このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します//     Dispose(disposing: false);// }
~A()
このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します
Dispose(disposing: false);
}
*public void Dispose()
このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します
*Dispose(disposing: true);
このコードを変更しないでください。クリーンアップ コードを 'Dispose(bool disposing)' メソッドに記述します
*Dispose(disposing: true);

配列の要素からインデックスの値を引いた値は同じになることを利用してグルーピングしています
*var result = number.Select((x , index) =>; (x , index))

HttpClientのインスタンスは再利用すべきです。
https:docs.microsoft.com/ja-jp/dotnet/api/system.net.http.httpclient?view=netcore-3.1#remarks
*private static readonly HttpClient httpClient = new HttpClient();
HTTPリクエストを送信するURL
ここではQiitaのURLをお借りしています。
var url = "https:qiita.com/";
URLに対するHTTP HEADリクエストメッセージを作成して送信
ここではResultを呼び出して同期処理にしています。
*var headMessage = new HttpRequestMessage(HttpMethod.Head, url);
ETagを出力する
nullの可能性があります。
*var headers = response.Headers;

接続文字列
*NpgsqlConnection conn = new NpgsqlConnection("Server=localhost;Port=5432;User ID=postgres;Database=postgres;Password=Chatdb01;Enlist=true");

接続文字列
*NpgsqlConnection conn = new NpgsqlConnection("Server=localhost;Port=5432;User ID=postgres;Database=postgres;Password=Chatdb01;Enlist=true");
PostgreSQLへ接続
*conn.Open();

*member2.Rows.Add(3, "五郎", 30, "大阪");
差異有
「member」テーブルのみに存在する行を取得
*DataRow[] rows =
「member」「member2」テーブル両方に存在する行を取得
*DataRow[] rows2 =

pointerの中身は2バイト（文字数N）＋N*2バイト（UTF-16文字列）の配列
*var pointer = NativeMethods.LockResource(memoryHandle);

*app.UseStaticFiles();
for wwwrootswaggerui

... 最後のページに達した場合の処理（0に戻す）
*imageName = images[index].FileLocation;
... 最初のページに達した場合の処理（最大ページに戻す）
*imageName = images[index].FileLocation;
... indexが正常値かどうかを確認
*imageName = images[index].FileLocation;
リストの初期化など
*}

*Cv2.SetMouseCallback("OpenCV", mcb);
変更

*if(num <; 5)*{
sourceから5未満のリストを作成
sourceを出力
*Console.WriteLine("source");
targetを出力
*Console.WriteLine("target");
sourceから5未満のリストを作成
*target = source.Where(num =>; num <; 5).ToList();
*source.ForEach(delegate (int num) { Console.WriteLine(num); });
sourceを出力
*target.ForEach(delegate (int num) { Console.WriteLine(num); });
targetを出力
5を乗算した値を追加
*target.Add(num * 5);

*{// IHttpClientFactory を使用するbuilder.Services.AddHttpClient<;HttpClientService>;();builder.Services.AddSingleton(provider =>;{ConnectionPolicy ConnectionPolicy = new ConnectionPolicy{ConnectionMode = ConnectionMode.Direct,ConnectionProtocol = Protocol.Tcp};return new DocumentClient(new Uri(AppSettings.Instance.COSMOSDB_ENDPOINT), AppSettings.Instance.COSMOSDB_KEY, ConnectionPolicy);});}
依存関係
IHttpClientFactory を使用する
*builder.Services.AddHttpClient<;HttpClientService>;();
*{// IHttpClientFactory を使用するbuilder.Services.AddHttpClient<;HttpClientService>;();builder.Services.AddSingleton(provider =>;{ConnectionPolicy ConnectionPolicy = new ConnectionPolicy{ConnectionMode = ConnectionMode.Direct,ConnectionProtocol = Protocol.Tcp};return new DocumentClient(new Uri(AppSettings.Instance.COSMOSDB_ENDPOINT), AppSettings.Instance.COSMOSDB_KEY, ConnectionPolicy);});}
依存関係
IHttpClientFactory を使用する
*builder.Services.AddHttpClient<;HttpClientService>;();

string型の引数を受け取り、戻り値はvoidのデリゲート
*delegate void OutputProcess(string str);
*{Console.WriteLine(str);}
引数のデリゲートに対応したメソッド
*{output(str);}
引数でもらったデリゲートに対応したメソッドを実行
newキーワードでデリゲートを生成
*var outProcess1 = new OutputProcess(Console.WriteLine);
デリゲートに対応したメソッドを代入
*OutputProcess outProcess2 = SayHello;
SayHelloWorldに引き渡し
*p.SayHelloWorld("Hello World", outProcess2);
string型の引数を受け取り、戻り値はstringのデリゲート
*delegate string Delegate(string str);
*{return $"[{str}]";}
引数のデリゲートに対応したメソッド
DisplayExtをデリゲートに代入
*Delegate outProcess = DisplayExt;
引数としてoutProcessを渡す
*p.Display(data, outProcess);
*{foreach (var val in data){Console.WriteLine(output(val));}}
引数のFuncデリゲートに指定された処理を実行する
匿名メソッド
delegateキーワードを利用、以降にメソッド本体
*p.Display(data, delegate (string str)
*{foreach (var val in data){Console.WriteLine(output(val));}}
引数のFuncデリゲートに指定された処理を実行する
*{return $"[{str}]";});
ラムダ式

*Console.WriteLine("result: {0}", d.loop(6));
result: 40

1.複数枚の画像を１つにパックする
*var texture = new Texture2D(maxsize, maxsize, TextureFormat.RGBA32, false);
2.SpriteのMultiple設定をパックした画像から作成
*var spritesheets = new List<;SpriteMetaData>;();
3.作成した情報をもとに画像をAtlas化
*var importer = AssetImporter.GetAtPath("Assets" + filename) as TextureImporter;

Updateメソッド内からコルーチン呼び出し（この場合は正常に実行できる）
*StartCoroutine("Event");
*{Debug.Log("あいうえお");//マウス左クリックを待つ処理yield return new WaitUntil(() =>; Input.GetMouseButtonDown(0));Debug.Log("かきくけこ");}
コルーチン関数"Event"を定義
マウス左クリックを待つ処理
*yield return new WaitUntil(() =>; Input.GetMouseButtonDown(0));
EventManager のオブジェクトをnewで生成
*EventManager eventManager = new EventManager();
コルーチン呼び出し（この場合はエラーが発生する）
*eventManager.StartCoroutine("Event");
*{Debug.Log("あいうえお");//マウス左クリックを待つ処理yield return new WaitUntil(() =>; Input.GetMouseButtonDown(0));Debug.Log("かきくけこ");}
コルーチン関数"Event"を定義
マウス左クリックを待つ処理
*yield return new WaitUntil(() =>; Input.GetMouseButtonDown(0));
AddComponentでオブジェクトを生成
*EventManager eventManager = (new GameObject("適当なオブジェクト名")).AddComponent<;EventManager>;();
コルーチン呼び出し（この場合は正常に実行できる）
*eventManager.StartCoroutine("Event");
*{Debug.Log("あいうえお");//マウス左クリックを待つ処理yield return new WaitUntil(() =>; Input.GetMouseButtonDown(0));Debug.Log("かきくけこ");}
コルーチン関数"Event"を定義
マウス左クリックを待つ処理
*yield return new WaitUntil(() =>; Input.GetMouseButtonDown(0));

*{using (var reader = new StreamReader(filepath))using (var csv = new CsvReader(reader, CultureInfo.CurrentCulture))return csv.GetRecords<;T>;().ToList();}
簡易バージョン
*{using (var reader = new StreamReader(filepath,encoding))using (var csv = new CsvReader(reader, CultureInfo.CurrentCulture)){csv.Configuration.Delimiter = delimiter;return csv.GetRecords<;T>;().ToList();}}
encoderと区切り文字設定できるバージョン
*var data=CsvParser.Read<;MyClass>;(@"filepath.csv",Encoding.GetEncoding("Shift_JIS"), ",");*//読み込んだデータをタブ区切りで新しいファイルに書き込む
Shift-JISでカンマ区切りのデータを読み込む
*CsvParser.Write<;MyClass>;(data,@"filepath.tsv",Encoding.GetEncoding("Shift_JIS"), "\t");*,,,
読み込んだデータをタブ区切りで新しいファイルに書き込む

*var t = Time.fixedTime - startTime - latency;
現在の時間
一定期間内に他キャラがいる
*var fromInfo = infoList[i];
補間時間を割り出す
*var rate = Mathf.InverseLerp(fromInfo.time, toInfo.time, t);
目的位置を割り出す
*targetPos = Vector3.Lerp(fromInfo.pos, toInfo.pos, rate);
*transform.rotation = Quaternion.Slerp(fromInfo.rot, toInfo.rot, rate);*// インデックス指定
回転はここで指定
インデックス指定
*infoListIdx = Mathf.Max(i - 1, 0);
*if (infoListIdx >; 0)*{
不要な他キャラ情報は削除
遅延なく参照できた場合は遅延を少し少なくする
*latency = Mathf.Max(latency - Time.fixedDeltaTime, 0.0f);
*if (i >;= infoList.Count - interval) latency += Time.fixedDeltaTime;*// 滑らかに移動するために固めの線形補間を使う
上手く参照できなかった場合は遅延を大きくする
*transform.position = Vector3.Lerp(transform.position, targetPos, Time.fixedDeltaTime * moveDamp);*}
滑らかに移動するために固めの線形補間を使う

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"
*{var mesh = new MeshGeometry3D();mesh.Positions.Add(new Point3D(-0.5, -0.5, 0));mesh.Positions.Add(new Point3D(0.5, -0.5, 0));mesh.Positions.Add(new Point3D(-0.5, 0.5, 0));mesh.Normals.Add(new Vector3D(0, 0, 1));mesh.Normals.Add(new Vector3D(0, 0, 1));mesh.Normals.Add(new Vector3D(0, 0, 1));mesh.TextureCoordinates.Add(new System.Windows.Point(0.0, 1.0));mesh.TextureCoordinates.Add(new System.Windows.Point(1.0, 1.0));mesh.TextureCoordinates.Add(new System.Windows.Point(0.0, 0.0));mesh.TriangleIndices.Add(0);mesh.TriangleIndices.Add(1);mesh.TriangleIndices.Add(2);var bitmapSource = BitmapSourceConverter.ToBitmapSource(colorImage);var imageBrush = new ImageBrush(bitmapSource);var material = new DiffuseMaterial(imageBrush);var geometry = new GeometryModel3D(mesh, material);var modelVisual = new ModelVisual3D();modelVisual.Content = geometry;this.Viewport.Children.Add(modelVisual);}
Create MeshModel - TextureCoorinates Range : [0-1]
*{...}
Create MeshModel - TextureCoorinates Range : [0-1]
*{var mesh = new MeshGeometry3D();mesh.Positions.Add(new Point3D(0.5, -0.5, 0));mesh.Positions.Add(new Point3D(0.5, 0.5, 0));mesh.Positions.Add(new Point3D(-0.5, 0.5, 0));mesh.Normals.Add(new Vector3D(0, 0, 1));mesh.Normals.Add(new Vector3D(0, 0, 1));mesh.Normals.Add(new Vector3D(0, 0, 1));mesh.TextureCoordinates.Add(new System.Windows.Point(7.0 / 8.0, 7.0 / 8.0));mesh.TextureCoordinates.Add(new System.Windows.Point(7.0 / 8.0, 1.0 / 8.0));mesh.TextureCoordinates.Add(new System.Windows.Point(1.0 / 8.0, 1.0 / 8.0));mesh.TriangleIndices.Add(0);mesh.TriangleIndices.Add(1);mesh.TriangleIndices.Add(2);var bitmapSource = BitmapSourceConverter.ToBitmapSource(colorImage);var imageBrush = new ImageBrush(bitmapSource);var material = new DiffuseMaterial(imageBrush);var geometry = new GeometryModel3D(mesh, material);var modelVisual = new ModelVisual3D();modelVisual.Content = geometry;this.Viewport.Children.Add(modelVisual);}
Create MeshModel - TextureCoorinates Range : [1/8-7/8]
*{...}
Create MeshModel - TextureCoorinates Range : [0-1]
*{var mesh = new MeshGeometry3D();mesh.Positions.Add(new Point3D(0.5, -0.5, 0));mesh.Positions.Add(new Point3D(0.5, 0.5, 0));mesh.Positions.Add(new Point3D(-0.5, 0.5, 0));mesh.Normals.Add(new Vector3D(0, 0, 1));mesh.Normals.Add(new Vector3D(0, 0, 1));mesh.Normals.Add(new Vector3D(0, 0, 1));mesh.TextureCoordinates.Add(new System.Windows.Point(7.0 / 8.0, 7.0 / 8.0));mesh.TextureCoordinates.Add(new System.Windows.Point(7.0 / 8.0, 1.0 / 8.0));mesh.TextureCoordinates.Add(new System.Windows.Point(1.0 / 8.0, 1.0 / 8.0));mesh.TriangleIndices.Add(0);mesh.TriangleIndices.Add(1);mesh.TriangleIndices.Add(2);// Set Dummy TextureCoordinates - Range [0-1]{mesh.Positions.Add(default(Point3D));mesh.Positions.Add(default(Point3D));mesh.Normals.Add(default(Vector3D));mesh.Normals.Add(default(Vector3D));mesh.TextureCoordinates.Add(new System.Windows.Point(0, 0));mesh.TextureCoordinates.Add(new System.Windows.Point(1, 1));}var bitmapSource = BitmapSourceConverter.ToBitmapSource(colorImage);var imageBrush = new ImageBrush(bitmapSource);var material = new DiffuseMaterial(imageBrush);var geometry = new GeometryModel3D(mesh, material);var modelVisual = new ModelVisual3D();modelVisual.Content = geometry;this.Viewport.Children.Add(modelVisual);}
Create MeshModel - TextureCoorinates Range : [1/8-7/8]
*{mesh.Positions.Add(default(Point3D));mesh.Positions.Add(default(Point3D));mesh.Normals.Add(default(Vector3D));mesh.Normals.Add(default(Vector3D));mesh.TextureCoordinates.Add(new System.Windows.Point(0, 0));mesh.TextureCoordinates.Add(new System.Windows.Point(1, 1));}
Set Dummy TextureCoordinates - Range [0-1]

*);
from net 5; otherwise you need to implement it.

*cefBrowser = new ChromiumWebBrowser("https:
www.google.co.jp");

*var repeatPoint = point * repeat;
繰り返し位置

*var repeatPoint = point * repeat;
繰り返し位置

*var ratio = (float)i
itemCount;  周期の位置 (1.0 = 100% の時 2π となる)

メッセージを表示する処理
*}

*System.Diagnostics.Process.Start(@"C:\Program Files\Google\Chrome\Application\chrome.exe", "https:
google.com");

ここで起動する Web サーバーの構成をテスト用に変える
*}
DB を SQL Server からインメモリーにする
*var descriptor = services.SingleOrDefault(
*{var db = scope.ServiceProvider.GetRequiredService<;WeatherContext>;();// DB を作り直しdb.Database.EnsureDeleted();db.Database.EnsureCreated();// テストデータの投入db.WeatherForecasts.AddRange(new WeatherForecast{City = "Tokyo",Summary = "Cold",Date = new DateTime(2020, 1, 1),TemperatureC = 0,},new WeatherForecast{City = "Tokyo",Summary = "Hot",Date = new DateTime(2020, 8, 6),TemperatureC = 35,},new WeatherForecast{City = "Hiroshima",Summary = "Cold",Date = new DateTime(2020, 1, 1),TemperatureC = -1,},new WeatherForecast{City = "Hiroshima",Summary = "Hot",Date = new DateTime(2020, 8, 6),TemperatureC = 32,});db.SaveChanges();}
Scope を作っておくことで DbContext が使いまわされないようにする
DB を作り直し
*db.Database.EnsureDeleted();
*{City = "Tokyo",Summary = "Cold",Date = new DateTime(2020, 1, 1),TemperatureC = 0,},
テストデータの投入
*{new Claim(ClaimTypes.Name, "Test user"),};
含めたいクレームを作る
*{services.AddAuthentication("Test").AddScheme<;AuthenticationSchemeOptions, TestAuthHandler>;("Test", options =>; { });});
テスト用の認証ハンドラーを設定する
*{services.AddAuthentication("Test").AddScheme<;AuthenticationSchemeOptions, TestAuthHandler>;("Test", options =>; { });});
テスト用の認証ハンドラーを設定する
サーバー側では、順序保障してないのでローカルでソートしてアサート
*responseContent = responseContent.OrderBy(x =>; x.TemperatureC).ToArray();
*{services.AddAuthentication("Test").AddScheme<;AuthenticationSchemeOptions, TestAuthHandler>;("Test", options =>; { });});
テスト用の認証ハンドラーを設定する
サーバー側では、順序保障してないのでローカルでソートしてアサート
*responseContent = responseContent.OrderBy(x =>; x.TemperatureC).ToArray();

COMのクラスが使える
*static void Main(string[] args) =>; new SpeechLib.SpVoice().Speak("Hello world");

Stringクラスを拡張したstaticクラス
クラス名は、(対象のクラス+Extensions)とするといい
*static class StringExtensions
thisキーワードでStringクラスを拡張することを指定
第2引数意向で、拡張メソッド本来の引数を指定する(この場合はcount)
*public static string Repeat(this string str, int count)
*{// thisキーワードでDateTimeクラスを拡張することを指定public static DateTime EndOfMonth(this DateTime date){return new DateTime(date.Year, date.Month, 1).AddMonths(1).AddDays(-1);}}
DateTimeクラスを拡張したstaticクラス
*{return new DateTime(date.Year, date.Month, 1).AddMonths(1).AddDays(-1);}
thisキーワードでDateTimeクラスを拡張することを指定
*{Salt,Soy_Sauce,Sugar}
調味料を列挙
*{public static string GetSeasoningString(this Seasoning kind){switch (kind){case Seasoning.Salt:return "塩";case Seasoning.Soy_Sauce:return "醤油";case Seasoning.Sugar:return "砂糖";default:return "";}}}
Seasoningの拡張メソッド
*foreach (Seasoning kind in Enum.GetValues(typeof(Seasoning)))*{
全ての列挙子(値)を取得して表示
*{foreach (var x in array)if (pred(x))yield return x;}
条件で絞る機能の追加
*{foreach (var x in array)yield return filter(x);}
値を加工する機能を追加

*public void _数字リテラルのパーズ_符号なし整数の場合() {var unum_p = Parser.Digit.AtLeastOnceString();var result1 = unum_p.Parse("8 ");Assert.That(result1.Success, Is.True, "[1]パーズは成功しなければならない");Assert.That(result1.Value, Is.EqualTo("8"), "[1]取り出された数字リテラル");var result2 = unum_p.Parse("9876543210987");Assert.That(result2.Success, Is.True, "[2]パーズは成功しなければならない");Assert.That(result2.Value, Is.EqualTo("9876543210987"), "[2]取り出された数字リテラル");var result3 = unum_p.Parse("9876543XYZ");Assert.That(result3.Success, Is.True);Assert.That(result3.Value, Is.EqualTo("9876543"), "[3]取り出された数字リテラル");}
(snip)
*public void _数字リテラルのパーズ_小数の場合() {var unum_p = Parser.Digit.AtLeastOnceString();var frac_num_p = Parser.Char('.').Then(unum_p, (left, right) =>; left + right);var result4 = frac_num_p.Parse(".654");Assert.That(result4.Success, Is.True, "[4]パーズは成功しなければならない");Assert.That(result4.Value, Is.EqualTo(".654"), "[4]取り出された数字リテラル");var decimal_p = unum_p.Then(frac_num_p.Optional(), (left, right) =>; right.HasValue ? left + right.Value : left);var result5 = decimal_p.Parse("1234.567");Assert.That(result5.Success, Is.True, "[5]パーズは成功しなければならない");Assert.That(result5.Value, Is.EqualTo("1234.567"), "[5]取り出された数字リテラル");var result6 = decimal_p.Parse("567");Assert.That(result6.Success, Is.True, "[6]パーズは成功しなければならない");Assert.That(result6.Value, Is.EqualTo("567"), "[6]取り出された数字リテラル");var decimal_p2 = decimal_p.Then(Parser<;char>;.End, (l, r) =>; l);var result7 = decimal_p2.Parse("5678UV");Assert.That(result7.Success, Is.Not.True, "[7]パーズは失敗しなければならない");Assert.That(result7.Error, Is.Not.Null, "[7]エラーあり");Assert.That(result7.Error.ErrorPos.Col, Is.EqualTo(5), "数字ではないところで失敗");}
(snip)
*public void _数字リテラルのパーズ_小数の場合() {var unum_p = Parser.Digit.AtLeastOnceString();var exp_part_p = Parser.CIChar('E').Then(unum_p, (l, r) =>; l + r);var result8 = exp_part_p.Parse("E31");Assert.That(result8.Success, Is.True, "[8]パーズは成功しなければならない");Assert.That(result8.Value, Is.EqualTo("E31"), "[8]取り出された数字リテラル");var result8_2 = exp_part_p.Parse("e13");Assert.That(result8_2.Success, Is.True, "[8_2]パーズは成功しなければならない");Assert.That(result8_2.Value, Is.EqualTo("e13"), "[8_2]取り出された数字リテラル");var exp_num_p = unum_p.Then(exp_part_p.Optional(), (l, r) =>; r.HasValue ? l + r.Value : l);var result9 = exp_num_p.Parse("1234E31");Assert.That(result9.Success, Is.True, "[9]パーズは成功しなければならない");Assert.That(result9.Value, Is.EqualTo("1234E31"), "[9]取り出された数字リテラル");var result10 = exp_num_p.Parse("234");Assert.That(result10.Success, Is.True, "[10]パーズは成功しなければならない");Assert.That(result10.Value, Is.EqualTo("234"), "[10]取り出された数字リテラル");}
(snip)
*public void _数字のパーズ_Parserのチョイス() {var uint_p = Parser.Digit.AtLeastOnceString();var frac_num_p = Parser.Char('.').Then(uint_p, (l, r) =>; l + r);var exact_num_p = uint_p.Then(frac_num_p, (l, r) =>; l + r);var exp_part_p = Parser.CIChar('E').Then(uint_p, (l, r) =>; l + r);var exp_num_p = uint_p.Then(exp_part_p.Optional(), (l, r) =>; r.HasValue ? l + r.Value : l);var unum_p = Parser.OneOf(Parser.Try(exact_num_p), Parser.Try(exp_num_p), uint_p);var result1_1 = uint_p.Parse("1234567890123");Assert.That(result1_1.Success, Is.True, "[1.1]パーズは成功しなければならない");Assert.That(result1_1.Value, Is.EqualTo("1234567890123"), "[1.1]取り出された数字リテラル");var result1_2 = unum_p.Parse("1234567890123");Assert.That(result1_2.Success, Is.True, "[1.2]パーズは成功しなければならない");Assert.That(result1_2.Value, Is.EqualTo("1234567890123"), "[1.2]取り出された数字リテラル");var result2 = unum_p.Parse("1234.567");Assert.That(result2.Success, Is.True, "[2]パーズは成功しなければならない");Assert.That(result2.Value, Is.EqualTo("1234.567"), "[2]取り出された数字リテラル");var result3 = unum_p.Parse("1234E31");Assert.That(result3.Success, Is.True, "[3]パーズは成功しなければならない");Assert.That(result3.Value, Is.EqualTo("1234E31"), "[3]取り出された数字リテラル");var sign_p = Parser.CIOneOf('+', '-');var snum_p = sign_p.Optional().Then(unum_p, (l, r) =>; l.HasValue ? l.Value  + r: r);var result4 = snum_p.Parse("1234567890123");Assert.That(result4.Success, Is.True, "[4]パーズは成功しなければならない");Assert.That(result4.Value, Is.EqualTo("1234567890123"), "[4]取り出された数字リテラル");var result5 = snum_p.Parse("-98765432");Assert.That(result5.Success, Is.True, "[5]パーズは成功しなければならない");Assert.That(result5.Value, Is.EqualTo("-98765432"), "[5]取り出された数字リテラル");var result6 = snum_p.Parse("+2224444");Assert.That(result6.Success, Is.True, "[6]パーズは成功しなければならない");Assert.That(result6.Value, Is.EqualTo("+2224444"), "[6]取り出された数字リテラル");}
(snip)

*if (cred != null)
取得に成功したデータを表示

取得するだけで何も使わない
*var velocity = _runner.GetCurrentVelocity();

*string maphtml = @"C:\Maps.html";
さっきのHTMLファイル
*settings.SetOffScreenRenderingBestPerformanceArgs();*Cef.Initialize(settings);
レンダリングを最適化(これをやらないとバグる)
Panelに合わせて表示
*panel1.Controls.Add(cefBrowser);
*Invoke((MethodInvoker)delegate {toolStripStatusLabel1.Text = "読み込み完了";button1.Enabled = true;});
読み込み完了時
Javascriptの実行
*cefBrowser.ExecuteScriptAsync("map = mapStart(" + textBox1.Text +

*public static class SemSymbolHelper {public static bool TryCResolveReturnTypeContext(Microsoft.CodeAnalysis.TypeInfo inReturnTypeInfo, out EntitiyContext outCtx) {outCtx = default;var typeSymbol = inReturnTypeInfo.Type as INamedTypeSymbol;if (typeSymbol == null) return false;var fmtFqcn = new SymbolDisplayFormat(typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable);(outCtx.ContainerType, outCtx.NamedType) = ResolveAsContainerType(typeSymbol);if (outCtx.NamedType == null) return false;var memberSymbols = outCtx.NamedType.GetMembers();outCtx.Constructors =memberSymbols.OfType<;IMethodSymbol>;().Where(s =>; s.MethodKind == MethodKind.Constructor).Where(s =>; s.Parameters.Length >; 0).Select(s =>; TypeVar.OfConstructor(s.Parameters)).ToArray();outCtx.PropertyTypeVars = TypeVar.OfProperties(memberSymbols.OfType<;IPropertySymbol>;().Where(s =>; ! s.IsReadOnly).ToImmutableArray());outCtx.FieldTypeVars = TypeVar.OfFields(memberSymbols.OfType<;IFieldSymbol>;().Where(s =>; ! s.IsImplicitlyDeclared).ToImmutableArray());return true;}private static System.ValueTuple<;SpecialType, INamedTypeSymbol>; ResolveAsContainerType(INamedTypeSymbol inSymbol) {var fmtFqcn = new SymbolDisplayFormat(typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable);returninSymbol.ToDisplayString(fmtFqcn) switch {"System.Nullable" =>;(SpecialType.System_Nullable_T, inSymbol.TypeArguments[0] as INamedTypeSymbol),"System.Collections.Generic.IEnumerable" =>;(SpecialType.System_Collections_Generic_IEnumerable_T, inSymbol.TypeArguments[0] as INamedTypeSymbol),_ =>;(SpecialType.None, inSymbol),};}}
(snip)

*Console.WriteLine("2");
2

*return sales;
結果を返す

*return;
PowerPointが起動していない、もしくは不明なエラー
pathあり
*lsvFiles.Items.Add(MakeLsvItem("PowerPoint", Path.GetFileName(t), Path.GetDirectoryName(t)));
*if (shell == null) {*var type = Type.GetTypeFromProgID("WScript.Shell");
WshShellを作成
リンク先
*shortcut.TargetPath = lnkDest;
実行時の大きさ 1が通常、3が最大化、7が最小化
*shortcut.WindowStyle = 1;
ショートカットを作成
*shortcut.Save();
FolderBrowserDialogクラスのインスタンスを作成
*FolderBrowserDialog fbd = new FolderBrowserDialog();
上部に表示する説明テキストを指定する
*fbd.Description = "フォルダを指定してください。";
ルートフォルダを指定する
デフォルトでDesktop
*fbd.RootFolder = Environment.SpecialFolder.Desktop;
最初に選択するフォルダを指定する
RootFolder以下にあるフォルダである必要がある
fbd.SelectedPath = Environment.SpecialFolder.Desktop;  @"C:\Windows";
ユーザーが新しいフォルダを作成できるようにする
デフォルトでTrue
*fbd.ShowNewFolderButton = true;
*if (fbd.ShowDialog(this) == DialogResult.OK) {*ExportAllLinks(fbd.SelectedPath);
ダイアログを表示する

*private readonly WebView2Controller webView2Controller = new();
WebView2Controllerのインスタンス生成
DockPanelの子要素にWebView2を追加する
*this.dockPanel.Children.Add(this.webView2Controller.GetWebView2());
Windowの子要素にDockPanelを追加する
*this.AddChild(this.dockPanel);
ナビゲートを指定
this.webView2Controller.Navigate("https:www.google.com/");
*this.InitializeComponent();
開発者ツールの無効化
*this.webView2.CoreWebView2.Settings.AreDevToolsEnabled = false;
コンテキストメニュー（右クリックメニュー）の無効化
*this.webView2.CoreWebView2.Settings.AreDefaultContextMenusEnabled = false;
ダイアログ無効化
*this.webView2.CoreWebView2.Settings.AreDefaultScriptDialogsEnabled = false;
ステータスバー非表示
*this.webView2.CoreWebView2.Settings.IsStatusBarEnabled = false;
内蔵されたエラーページを無効化
*this.webView2.CoreWebView2.Settings.IsBuiltInErrorPageEnabled = false;
ズームコントロールの無効化
*this.webView2.CoreWebView2.Settings.IsZoomControlEnabled = false;
イベントを処理済みとして扱うなら新しいウィンドウは開きません。デフォルトはfalseです。
*e.Handled = true;

*public int Code {get;private set;}
プロパティ（set は非公開）
*public Product(int code,string name,int price){this.Code=code;this.Name=name;this.Price=price;}
コンストラクタ(特殊メソッド)
*public int GetTax(){return (int)(Price * 0.08);}
税金メソッド

*Parameters = null
optional parameters here

AppDataのパスを取得
*var appdata = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
Local Stateのパスを取得
*var path = Path.GetFullPath(appdata + "\\..\\Local\\Google\\Chrome\\User Data\\Local State");
Local StateをJsonとして読み込む
*string v = File.ReadAllText(path);
Base64エンコード
*byte[] src = Convert.FromBase64String(key);
文字列「DPAPI」をスキップ
*byte[] encryptedKey = src.Skip(5).ToArray();
DPAPIで復号化
*byte[] decryptedKey = ProtectedData.Unprotect(encryptedKey, null, DataProtectionScope.CurrentUser);
AppDataのパスを取得
*var appdata = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
*if (File.Exists(p)) {Process[] chromeInstances = Process.GetProcessesByName("chrome");foreach (Process proc in chromeInstances)// Chromeを強制終了// これをやらないと「database is locked」エラーになるproc.Kill();// Login Dataファイルを読み込むusing (var conn = new SQLiteConnection($"Data Source={p};")) {conn.Open();using (var cmd = conn.CreateCommand()) {cmd.CommandText = "SELECT action_url, username_value, password_value FROM logins";using (var reader = cmd.ExecuteReader()) {if (reader.HasRows) {// マスターキーを取得byte[] key = GetKey();while (reader.Read()) {// 空のデータは無視if (reader[0].ToString() == "") continue;// 暗号化されたパスワードをbyte配列で読み込むbyte[] encryptedData = GetBytes(reader, 2);// 初期化ベクトルとパスワードデータに分離byte[] nonce, ciphertextTag;Prepare(encryptedData, out nonce, out ciphertextTag);// パスワードの復号化string password = Decrypt(ciphertextTag, key, nonce);var url = reader.GetString(0);var username = reader.GetString(1);Console.WriteLine("Url : " + url);Console.WriteLine("Username : " + username);Console.WriteLine("Password : " + password + "\n");}}}}conn.Close();Console.ReadKey(true);}
Login Dataのパスを取得
Chromeを強制終了
これをやらないと「database is locked」エラーになる
*proc.Kill();
*using (var conn = new SQLiteConnection($"Data Source={p};")) {
Login Dataファイルを読み込む
*while (reader.Read()) {// 空のデータは無視if (reader[0].ToString() == "") continue;// 暗号化されたパスワードをbyte配列で読み込むbyte[] encryptedData = GetBytes(reader, 2);// 初期化ベクトルとパスワードデータに分離byte[] nonce, ciphertextTag;Prepare(encryptedData, out nonce, out ciphertextTag);// パスワードの復号化string password = Decrypt(ciphertextTag, key, nonce);var url = reader.GetString(0);var username = reader.GetString(1);Console.WriteLine("Url : " + url);Console.WriteLine("Username : " + username);Console.WriteLine("Password : " + password + "\n");}
マスターキーを取得
*if (reader[0].ToString() == "") continue;*// 暗号化されたパスワードをbyte配列で読み込む
空のデータは無視
暗号化されたパスワードをbyte配列で読み込む
*byte[] encryptedData = GetBytes(reader, 2);
初期化ベクトルとパスワードデータに分離
*byte[] nonce, ciphertextTag;
パスワードの復号化
*string password = Decrypt(ciphertextTag, key, nonce);
*public static void Prepare(byte[] encryptedData, out byte[] nonce, out byte[] ciphertextTag) {nonce = new byte[12];ciphertextTag = new byte[encryptedData.Length - 3 - nonce.Length];System.Array.Copy(encryptedData, 3, nonce, 0, nonce.Length);System.Array.Copy(encryptedData, 3 + nonce.Length, ciphertextTag, 0, ciphertextTag.Length);}
暗号化データを初期化ベクトルとパスワードデータに分離
*public static string Decrypt(byte[] encryptedBytes, byte[] key, byte[] iv) {string sR = "";try {GcmBlockCipher cipher = new GcmBlockCipher(new AesFastEngine());AeadParameters parameters = new AeadParameters(new KeyParameter(key), 128, iv, null);cipher.Init(false, parameters);byte[] plainBytes = new byte[cipher.GetOutputSize(encryptedBytes.Length)];Int32 retLen = cipher.ProcessBytes(encryptedBytes, 0, encryptedBytes.Length, plainBytes, 0);cipher.DoFinal(plainBytes, retLen);sR = Encoding.UTF8.GetString(plainBytes).TrimEnd("\r\n\0".ToCharArray());}catch (Exception ex) {Console.WriteLine(ex.Message);Console.WriteLine(ex.StackTrace);}return sR;}
AES-256-GCM 復号化処理
*public static string Decrypt(byte[] encryptedBytes, byte[] key, byte[] iv) {string sR = "";try {GcmBlockCipher cipher = new GcmBlockCipher(new AesFastEngine());AeadParameters parameters = new AeadParameters(new KeyParameter(key), 128, iv, null);cipher.Init(false, parameters);byte[] plainBytes = new byte[cipher.GetOutputSize(encryptedBytes.Length)];Int32 retLen = cipher.ProcessBytes(encryptedBytes, 0, encryptedBytes.Length, plainBytes, 0);cipher.DoFinal(plainBytes, retLen);sR = Encoding.UTF8.GetString(plainBytes).TrimEnd("\r\n\0".ToCharArray());}catch (Exception ex) {Console.WriteLine(ex.Message);Console.WriteLine(ex.StackTrace);}return sR;}
暗号化されたパスワード、マスターキー、初期化ベクトルを指定
AppDataのパスを取得
*var appdata = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
Login Dataのパスを取得
*var p = Path.GetFullPath(appdata + "\\..\\Local\\Google\\Chrome\\User Data\\Default\\Login Data");
Chromeを強制終了
これをやらないと「database is locked」エラーになる
*proc.Kill();
*using (var conn = new SQLiteConnection($"Data Source={p};"))
Login Dataファイルを読み込む
マスターキーを取得
*byte[] key = GetKey();
*if (reader[0].ToString() == "") continue;*// 暗号化されたパスワードをbyte配列で読み込む
空のデータは無視
暗号化されたパスワードをbyte配列で読み込む
*byte[] encryptedData = GetBytes(reader, 2);
初期化ベクトルとパスワードデータに分離
*byte[] nonce, ciphertextTag;
パスワードの復号化
*string password = Decrypt(ciphertextTag, key, nonce);
AppDataのパスを取得
*var appdata = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
Local Stateのパスを取得
*var path = Path.GetFullPath(appdata + "\\..\\Local\\Google\\Chrome\\User Data\\Local State");
Local StateをJsonとして読み込む
*string v = File.ReadAllText(path);
Base64エンコード
*byte[] src = Convert.FromBase64String(key);
文字列「DPAPI」をスキップ
*byte[] encryptedKey = src.Skip(5).ToArray();
DPAPIで復号化
*byte[] decryptedKey = ProtectedData.Unprotect(encryptedKey, null, DataProtectionScope.CurrentUser);
*{string sR = "";try{GcmBlockCipher cipher = new GcmBlockCipher(new AesFastEngine());AeadParameters parameters = new AeadParameters(new KeyParameter(key), 128, iv, null);cipher.Init(false, parameters);byte[] plainBytes = new byte[cipher.GetOutputSize(encryptedBytes.Length)];Int32 retLen = cipher.ProcessBytes(encryptedBytes, 0, encryptedBytes.Length, plainBytes, 0);cipher.DoFinal(plainBytes, retLen);sR = Encoding.UTF8.GetString(plainBytes).TrimEnd("\r\n\0".ToCharArray());}catch (Exception ex){Console.WriteLine(ex.Message);Console.WriteLine(ex.StackTrace);}return sR;}
AES-256-GCM 復号化処理
*{nonce = new byte[12];ciphertextTag = new byte[encryptedData.Length - 3 - nonce.Length];System.Array.Copy(encryptedData, 3, nonce, 0, nonce.Length);System.Array.Copy(encryptedData, 3 + nonce.Length, ciphertextTag, 0, ciphertextTag.Length);}
暗号化データを初期化ベクトルとパスワードデータに分離
*{const int CHUNK_SIZE = 2 * 1024;byte[] buffer = new byte[CHUNK_SIZE];long bytesRead;long fieldOffset = 0;using (MemoryStream stream = new MemoryStream()){while ((bytesRead = reader.GetBytes(columnIndex, fieldOffset, buffer, 0, buffer.Length)) >; 0){stream.Write(buffer, 0, (int)bytesRead);fieldOffset += bytesRead;}return stream.ToArray();}}
SQLiteデータをbyte配列で読み込む

引数を取得したい場合
*config.AddCommandLine(args);
appsettings.json から NLog の設定情報を取得する
*logging.AddNLog(new NLogLoggingConfiguration(hostContext.Configuration.GetSection("NLog")));
必要なサービスのDIを記載する
*});

エイリアスは飛ばす
*continue;
省略
*}
省略
*}
エイリアスは飛ばす
*continue;
省略
*}
省略
*}
省略
*}
省略
*}
イニシャルリスト
*List<;string>; precureInitials = new List<;string>;();
イニシャル重複チェック
*bool initialsConflict = false;
万が一取得できなかった場合はスキップする
*continue;
省略
*}

*public string ExecuteName { get; set; }
取込処理名
*public string Arguments { get; set; }
取込処理の引数
*public AssemblyLoadContext Context { get; set; }
コンテキスト
*{InitializeComponent();}
コンストラクタ
*{// アセンブリ名を使ってクラス ライブラリーを動的に読み込みstring baseName = Path.GetFileNameWithoutExtension(ExecuteName);var myDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);var assemblyPath = Path.Combine(myDirectory, ExecuteName);Assembly assembly = Context.LoadFromAssemblyPath(assemblyPath);_myType = assembly.GetType(baseName + ".Program");_instance = Activator.CreateInstance(_myType);// アセンブリ内のクラスの Update イベントの EventInfo を取得EventInfo eventInfo = _myType.GetEvent("Update");var methodInfo = this.GetType().GetMethod("OnUpdate");Delegate handler = Delegate.CreateDelegate(eventInfo.EventHandlerType, this, methodInfo);// EventInfo に対してイベント ハンドラーを追加eventInfo.AddEventHandler(_instance, handler);// 閉じるボタンを無効にするbtnClose.Enabled = false;// ProgressChangedイベントが発生するようにするbgWorker.WorkerReportsProgress = true;// 処理を開始するbgWorker.RunWorkerAsync();}
画面初回表示時
アセンブリ名を使ってクラス ライブラリーを動的に読み込み
*string baseName = Path.GetFileNameWithoutExtension(ExecuteName);
アセンブリ内のクラスの Update イベントの EventInfo を取得
*EventInfo eventInfo = _myType.GetEvent("Update");
EventInfo に対してイベント ハンドラーを追加
*eventInfo.AddEventHandler(_instance, handler);
閉じるボタンを無効にする
*btnClose.Enabled = false;
ProgressChangedイベントが発生するようにする
*bgWorker.WorkerReportsProgress = true;
処理を開始する
*bgWorker.RunWorkerAsync();
*{Close();}
画面を閉じる
*{BackgroundWorker bgWorker = (BackgroundWorker)sender;// 処理を開始するint result = (int)_myType.InvokeMember("Main", BindingFlags.InvokeMethod, null, _instance, new object[] { Arguments.Split(',') });// 結果を設定するe.Result = result;}
取込処理
*int result = (int)_myType.InvokeMember("Main", BindingFlags.InvokeMethod, null, _instance, new object[] { Arguments.Split(',') });
処理を開始する
結果を設定する
*e.Result = result;
*{// ProgressBarの値を変更するInvoke((Action)delegate (){prbDowork.Value = e.ProgressPercentage;// タイトルのテキストを変更するlblTitle.Text = (e.ProgressPercentage).ToString() + " %";});}
途中経過イベント処理
*{prbDowork.Value = e.ProgressPercentage;// タイトルのテキストを変更するlblTitle.Text = (e.ProgressPercentage).ToString() + " %";});
ProgressBarの値を変更する
タイトルのテキストを変更する
*lblTitle.Text = (e.ProgressPercentage).ToString() + " %";
*{Invoke((Action)delegate (){if (e.Error != null){// エラーが発生したときlblTitle.Text = "エラー:" + e.Error.Message;}else{// ProgressBarの結果を取得するint result = (int)e.Result;if (result == -1){// エラーで中断したときlblTitle.Text = "処理を中断しました。";}else{// 正常に終了したときprbDowork.Value = prbDowork.Maximum;lblTitle.Text = "完了しました。";}}// 閉じるボタンを有効に戻すbtnClose.Enabled = true;});}
取込処理が終わったときに呼び出される
エラーが発生したとき
*lblTitle.Text = "エラー:" + e.Error.Message;
ProgressBarの結果を取得する
*int result = (int)e.Result;
エラーで中断したとき
*lblTitle.Text = "処理を中断しました。";
正常に終了したとき
*prbDowork.Value = prbDowork.Maximum;
閉じるボタンを有効に戻す
*btnClose.Enabled = true;
*{// ProgressChangedイベントハンドラを呼び出しbgWorker.ReportProgress(e.ProgressPercentage);}
進捗値の更新
ProgressChangedイベントハンドラを呼び出し
*bgWorker.ReportProgress(e.ProgressPercentage);
*{this.ExecuteName = executeName;this.Arguments = args;this.ShowDialog();}
実行処理
メッセージボックスを表示する
*DialogResult result = MessageBox.Show("実行します。よろしいですか ? ",
処理実行
*string path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
アンロードされるまで待つ
*int counter = 0;
アセンブリをロードするAssemblyLoadContextを作成
*var alc = new MyAssemblyLoadContext();
アセンブリをロード
*Assembly a = alc.LoadFromAssemblyPath(assemblyPath);
外からアンロードを検知するために弱参照を設定
*alcWeakRef = new WeakReference(alc, trackResurrection: true);
リフレクションで関数コール
*var type = a.GetType("DoWork.frmDoWork");
アンロード実施
*alc.Unload();
更新されると起きるイベント
*public event ProgressChangedEventHandler Update;
完了
*SetProgress(100);
*{System.Threading.Thread.Sleep(200);SetProgress(10);return true;}
処理10%
*{System.Threading.Thread.Sleep(200);SetProgress(30);return true;}
処理30%
*{System.Threading.Thread.Sleep(200);SetProgress(50);return true;}
処理50%
*{System.Threading.Thread.Sleep(200);SetProgress(70);return true;}
処理70%
*{System.Threading.Thread.Sleep(200);SetProgress(90);return true;}
処理90%
*{// 更新イベントを起こすProgressChangedEventArgs e = new ProgressChangedEventArgs(value, null);Update?.Invoke(this, e);}
進捗状況を標準出力に出力する
更新イベントを起こす
*ProgressChangedEventArgs e = new ProgressChangedEventArgs(value, null);

ここからテストケース追加
Act - click button to increment counter again
*cut.Find("button").Click();
略
*,,,
ここから追加(再度ボタンを押下)
Act - click button to increment counter again
*cut.Find("button").Click();
ダミーデータを作成して返す
*await Task.Delay(1500);
略
*builder.Services.AddSingleton<;IWeatherService, WeatherService>;();
略
*}
サービスをInject
*@inject IWeatherService WeatherService
*@code {private WeatherForecast[] forecasts;protected override async Task OnInitializedAsync(){forecasts = (await WeatherService.GetWeatherForecastAsync()).ToArray();}}
略
*var forecasts = new List<;WeatherForecast>;();*var mockService = new MockWeatherService();
set empty record mock
*var forecasts = new List<;WeatherForecast>;();*forecasts.Add(new WeatherForecast() { Date = new DateTime(2020, 5, 1), TemperatureC = 20, Summary = "Sunny" });
set dummy record mock

*bmpImage.CacheOption = BitmapCacheOption.OnLoad;
ここが重要

*return (int)Mathf.Abs(val);
絶対値にしてintで返すメソッド、なおエラーを吐く

指定されたオブジェクトのVisualTree上の親を順番に探索し、ItemsControlを探す。
ただし、DataGridは中間にいるDataGridCellsPresenterは無視する
*while (parent != null &amp;&amp; !(parent is ItemsControl) || parent is DataGridCellsPresenter)
ItemsControlの行にあたるオブジェクトを探索履歴の後ろから検索
*var item = parentTree
削除するIndexを取得
*int removeIndex = itemsControl.ItemContainerGenerator?.IndexFromContainer(item)
Bindingしていた場合はItemsSource、違うならItemsから削除する
*IList targetList = ((itemsControl.ItemsSource as IList) ?? itemsControl.Items);
*if ((index + 1) >;= targetList.Count)*return;
最後の行だったら何もしない
一度削除して、1つ大きいIndexに入れ直す
*var targetElement = targetList[index];
*if (index <;= 0)*return;
最初の行だったら何もしない
一度削除して、1つ少ないのIndexに入れ直す
*var targetElement = targetList[index];

フォーム上のテキストをChangedに変更
*this.Invoke(new Action<;string>;(this.TextChange),"Changed");
*{this.textBox.Text = text;}
フォーム上のテキストボックスを変更する関数
引数なし
*this.Invoke(new Action(関数));
引数あり
*this.Invoke(new Action<;引数の型名>;(関数),引数);
*this.Invoke(new Action(() =>; {処理}));
引数なし
100ミリ秒待機
*Thread.Sleep(100)
文字
*string hoge1 = Console.Read();
1行分
*string hoge2 = Console.ReadLine();
改行なし出力
*Console.Write(hoge);
改行あり出力
*Console.WriteLine(hoge);
0バイト目
*[FieldOffset(0)]
1バイト目
*[FieldOffset(1)]
2バイト目
*[FieldOffset(2)]
3バイト目
*[FieldOffset(3)]
float型
*[FieldOffset(0)]
int型
*[FieldOffset(0)]

*private Rigidbody PlRig = null;
プレイヤーのRigidbody
Playerに初速を与える
*PlRig.AddForce(vec, ForceMode.VelocityChange);

*Console.WriteLine(calc(1, 2));
3

例として面倒だから定義直下で判定してるけどメンバ変数として持って使用してる場合を想定
*GameObject gobj;

*.Queue()
Queueを挟む
1秒待って次の値を取りに行く
*await UniTask.Delay(1000, cancellationToken: ct);

アルゴリズムはこの中で動かす
色を指定
*drawer.SetColor(ConsoleColor.White, 0, 1);

*#pragma warning disable CS4014
この呼び出しは待機されなかったため、現在のメソッドの実行は呼び出しの完了を待たずに続行されます

*catch (Exception ex)
(7)

*command.CommandTimeout = 60000;
コマンドがタイムアウトする場合は秒数を変更(ms) デフォルトは 30秒

互いに参照できるよう定義
*[assembly: ExportRenderer(typeof(PCLCustomGridViewRenderer), typeof(AndroidCustomGridViewRenderer))]
*{base.OnElementChanged(e);if (e.OldElement != null){if (adapter != null)adapter.Element = null;}if (e.NewElement != null){if (Control == null){// Adpterの生成adapter = new AndroidCustomGridViewAdapter(Context);// GridViewの生成var gridView = new CustomGridView(new ContextThemeWrapper(Context, Resource.Style.VerticalScrollbarRecyclerView));// GridViewのパラメータを設定(親サイズに追従する設定)gridView.LayoutParameters = new LayoutParams(LayoutParams.MatchParent, LayoutParams.MatchParent);// カラム数gridView.NumColumns = 3;// Viewに対しAdpterを設定gridView.Adapter = adapter;//多分コントロールを実際に生成SetNativeControl(gridView);}if (adapter != null)// NewElementにはIList<;Person>;が入ってきます// ElementはAdpterクラスが私が定義しました。adapter.Element = e.NewElement;}}
生成時一度だけ呼ばれるイベント
Adpterの生成
*adapter = new AndroidCustomGridViewAdapter(Context);
GridViewの生成
*var gridView = new CustomGridView(new ContextThemeWrapper(Context, Resource.Style.VerticalScrollbarRecyclerView));
GridViewのパラメータを設定(親サイズに追従する設定)
*gridView.LayoutParameters = new LayoutParams(LayoutParams.MatchParent, LayoutParams.MatchParent);
カラム数
*gridView.NumColumns = 3;
Viewに対しAdpterを設定
*gridView.Adapter = adapter;
多分コントロールを実際に生成
*SetNativeControl(gridView);
NewElementにはIList&lt;Person&gt;が入ってきます
ElementはAdpterクラスが私が定義しました。
*adapter.Element = e.NewElement;
グリッドビューの表示時に、各要素の高さを図る
*AndroidCustomGridViewAdapter adapter = (AndroidCustomGridViewAdapter)Adapter;
列数と、要素数の設定
*CustomGridViewLinearLayout.initItemLayout(NumColumns, adapter.Count);
各要素の高さを測定
*adapter.measureItems(columnWidth);
要素の作成
*SetUp(view, viewModels[position]);
測定用のViewを設定
*itemView.setPosition(index);
強制的にViewのOnMeasureイベントを発火
*itemView.RequestLayout();

*StopAllCoroutines();
全てのコルーチンを止める

*group.AllowMembersEditMembership = true;
グループのメンバーシップを編集できるユーザー：グループメンバー

Directory.Moveはなぜか、大文字小文字だけの変更だとエラーする
なので、大文字小文字だけの変更の場合は一度別のファイル名に変更する
*if ((String.Compare(sourceFilePath, outputFilePath, true) == 0))

ボールを動かす力を調整
[SerializeField]でInspectorに表示
[Range(最小値,最大値)]でInspectorにスライダーを表示
*[SerializeField, Range(0, 100)] private float power = 10;
Rigidbody：物理挙動に関する設定を簡単に扱える便利Component
Rigidbodyの入れ物を用意する
*private Rigidbody rb;
*{//先程用意した入れ物にRigidbodyを入れる//この.ゲームオブジェクトから.コンポーネントを取得<;Rigidbodyを指定>;//this.gameObject.GetComponent<;Rigidbody>;();rb = this.gameObject.GetComponent<;Rigidbody>;();}
最初にStart関数内に書いた処理が実行される
先程用意した入れ物にRigidbodyを入れる
この.ゲームオブジェクトから.コンポーネントを取得&lt;Rigidbodyを指定&gt;
this.gameObject.GetComponent&lt;Rigidbody&gt;();
*rb = this.gameObject.GetComponent<;Rigidbody>;();
Start関数内に書いた処理が実行されたあと、Update関数内に書いた処理が実行される
Updateは毎フレーム呼ばれる
1秒間に60回フレームが更新されるなら→60fps
*private void Update()
Rigidbodyクラスに定義されているAddForceという関数を使う
もし、右矢印キーを押していたら、、、
*if (Input.GetKey(KeyCode.UpArrow))
*rb.AddForce(Vector3.forward * power);*}
ワールド空間の指定した方向に任意の力を加える
*if (Input.GetKey(KeyCode.DownArrow))*{
もし、下矢印キーを押していたら、、、
ワールド空間の指定した方向に任意の力を加える
*rb.AddForce(Vector3.back * power);
*if (Input.GetKey(KeyCode.RightArrow))*{
もし、右矢印キーを押していたら、、、
ワールド空間の指定した方向に任意の力を加える
*rb.AddForce(Vector3.right * power);
*if (Input.GetKey(KeyCode.LeftArrow))*{
もし、左矢印キーを押していたら、、、
ワールド空間の指定した方向に任意の力を加える
*rb.AddForce(Vector3.left * power);
*_collisionObjRigidbody = other.gameObject.transform.root.GetComponent<;Rigidbody>;();*}
Start関数内で名指しで取得する実装でも良いかも
*{case MagnetState.S:// 星に向かう向きの取得_direction = this.gameObject.transform.position - other.transform.position;// 星までの距離の２乗を取得_distance = _direction.magnitude;_distance *= _distance;// 万有引力計算_magnetPower = _accelerationScale * _distance;// 力を与える_collisionObjRigidbody.AddForce(_magnetPower * _direction.normalized, ForceMode.Force);break;case MagnetState.N:// 星に向かう向きの取得_direction =  other.transform.position - this.gameObject.transform.position;// 星までの距離の２乗を取得_distance = _direction.magnitude;_distance *= _distance;// 万有引力計算_magnetPower = _accelerationScale * _distance;// 力を与える_collisionObjRigidbody.AddForce(_magnetPower * _direction.normalized, ForceMode.Force);break;}
衝突したキャラがSかNの判定を入れた方がよさそう
*_direction = this.gameObject.transform.position - other.transform.position;*// 星までの距離の２乗を取得
星に向かう向きの取得
星までの距離の２乗を取得
*_distance = _direction.magnitude;
万有引力計算
*_magnetPower = _accelerationScale * _distance;
力を与える
*_collisionObjRigidbody.AddForce(_magnetPower * _direction.normalized, ForceMode.Force);
*_direction =  other.transform.position - this.gameObject.transform.position;*// 星までの距離の２乗を取得
星に向かう向きの取得
星までの距離の２乗を取得
*_distance = _direction.magnitude;
万有引力計算
*_magnetPower = _accelerationScale * _distance;
力を与える
*_collisionObjRigidbody.AddForce(_magnetPower * _direction.normalized, ForceMode.Force);

*widgetOptions: {filter_reset: 'button.reset-filter-button',resizable: true,}
フィルタのリセットボタンを追加する場合に設定する。

ListViewに仮想モードでデータを更新するイベントを追加
*this.listView1.RetrieveVirtualItem += new RetrieveVirtualItemEventHandler(listView1_RetrieveVirtualItem);
仮想モードをオンに
*this.listView1.VirtualMode = true;
1回仮想モードに表示されるデータ数を0にすることで、別のデータを入れたときに全て更新されるようになる
*this.listView1.VirtualListSize = 0;
追加
*ListViewItem listViewItem = new ListViewItem();
仮想モードの表示する数が一つ増えたので更新
*this.listView1.VirtualListSize = this.listViewItemList.Count;
選択された項目を削除
*ListView.SelectedIndexCollection selectedIndices = this.listView1.SelectedIndices;
仮想モードの表示する数が一つ減ったので更新
*this.listView1.VirtualListSize = this.listViewItemList.Count;

*new Node("GameObject", IAttribute[] {}, IVTree[] {});
UIRoot.cs
*{private IAttribute[] attrs;private IVTree[] kids;public ButtonWidget(IAttribute[] attrs, IVTree[] kids){this.attrs = attrs;this.kids = kids;}public override GameObject Init(GameObject go){var image = go.AddComponent<;UI.Image>;();var btn = go.GetComponent<;UI.Button>;();btn.targetGraphic = image;return go;}public override IVTree Render() =>;new Node<;UI.Button>;("Button",this.attrs,this.kids);public override void Destroy(GameObject go) { }public override IVTree[] GetKids() =>; this.kids;}
ButtonWidget.cs

*Set( Trig: "Boot", SineWave: new SineWave() { Freq = "20.0", Gain = "0.5" } );
Boot状態をトリガーにして、周波数２０ヘルツを出力。
Boot状態をトリガーにして、２秒後にA1状態に遷移。
*Wait( Trig: "Boot", Next: "A1", Time: 2.0 );
*Set( Trig: "A1", SineWave: new SineWave() { Freq = "60.0", Gain = "0.5" } );
A1状態をトリガーにして、周波数６０ヘルツを出力。
A1状態をトリガーにして、２秒後にA2状態に遷移。
*Wait( Trig: "A1", Next: "A2", Time: 2.0 );
*Set( Trig: "A2", SineWave: new SineWave() { Freq = "40.0", Gain = "0.5" } );
A2状態をトリガーにして、周波数４０ヘルツを出力。
A2状態をトリガーにして、４秒後にEnd状態に遷移。
*Wait( Trig: "A2", Next: "End", Time: 4.0 );
Boot から End まで波形取得
*GetWave( Trig: "Boot", Stop: "End", FileName: "test.wav", InId: "0, 1, 2, 3, 4, 5", OutId: "0");

*states.Add(name, c);
例外出すため
playerがダメージをうけたら
*playerState.SendMessage(PlayerMessage.TakeDamage);

*if (ContextCompat.CheckSelfPermission(this, Manifest.Permission.ReadExternalStorage) != (int)Permission.Granted)*{
追加します。
*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer

*{// 外部から変更できないようにするprivate static SingletonClass _singleInstance = new SingletonClass();// インスタンス取得public static SingletonClass GetInstance(){ return _singleInstance; }// 外部から生成できないようにするprivate SingletonClass(){//初期化処理}}
Singletonパターン
外部から変更できないようにする
*private static SingletonClass _singleInstance = new SingletonClass();
*public static SingletonClass GetInstance(){ return _singleInstance; }
インスタンス取得
*private SingletonClass(){//初期化処理}
外部から生成できないようにする
初期化処理
*}

*IEnumerable<;DMatch<; SelectedMatched;
マッチング結果
使用する特徴点の量だけベクトル用意
*int size = SelectedMatched.Count();
SrcとTarget画像の対応する特徴点の座標を取得し、ベクトル配列に格納していく。
*int count = 0;
SrcをTargetにあわせこむ変換行列homを取得する。ロバスト推定法はRANZAC。
*var hom = Cv2.FindHomography(
行列homを用いてSrcに射影変換を適用する。
*WarpedSrcMat = new Mat();

*var loop_i=1;
計算loop回数
配列
*List<;decimal>; result_temp = levelList.Select(x=>;Convert.ToDecimal( x* 100 / total)).ToList();
最大端数と最小端数のindexを算出
*var result_hasu_temp = result_hasu.Where(i =>; !(i == 0 || i==Convert.ToDecimal( 0.1 ) || i==Convert.ToDecimal(-0.1))).ToList();
最大端数、最小端数の項目は違う
0.1までの最小調整端数を算出し、最大端数は調整端数を足す、最小端数は調整端数を引く
*var add = Math.Min((decimal)0.1 - result_hasu[maxindex], result_hasu[minindex]);
端数すべて同じ
最大端数が0.1になるまで最小端数を移動
*if (max<;0)
端数＜0の場合
*var add = (decimal)0.1 - Math.Abs(result_hasu[maxindex]);
端数&gt;=0の場合
*var add = (decimal)0.1 - Math.Abs(result_hasu[maxindex]);
端数を結果に試し計上
*var t3 = result.Zip(result_hasu, (t1, t2) =>; Math.Round(t1 + Math.Round(t2, 1, MidpointRounding.AwayFromZero), 1, MidpointRounding.AwayFromZero)).ToList();
端数を結果に戻す
*result = result.Zip(result_hasu, (t1, t2) =>; Math.Round( t1 + Math.Round(t2, 1, MidpointRounding.AwayFromZero), 1, MidpointRounding.AwayFromZero)).ToList();

*var memoArranged = MemoDrafts.GroupBy(x =>; new { x.SlipDate, x.AccountingName,x.BalanceName, x.SubjectName })
メモの元MemoDraftsから同一会計名目や貸借項目は集約し金額は合計値を記述したいので
メモのヘッダー作成
*sb.AppendLine("出力日：" + DateTime.Now.Date.ToString("yyyy/mm/dd"));
集約結果からテキストに起こす
*var sb = new StringBuilder();
...中略
*}

*((A)b).Test_New();
a.Test_New()と同等

*System.Net.WebRequest.Create("http:
sample.comregist.php");
*{_reqStream.Write(_postData, 0, _postData.Length);_reqStream.Close();}
送信データの書き込み
*{switch(((HttpWebResponse)_response).StatusCode){case HttpStatusCode.OK:// OK時の処理break;default:// その他の処理break;}}
送信及び結果応答確認
OK時の処理
*break;
その他の処理
*break;

*command.CommandTimeout = 60000;
コマンドがタイムアウトする場合は秒数を変更(ms) デフォルトは 30秒

互いに参照できるよう定義
*[assembly: ExportRenderer(typeof(PCLCustomGridViewRenderer), typeof(AndroidCustomGridViewRenderer))]
*{base.OnElementChanged(e);if (e.OldElement != null){if (adapter != null)adapter.Element = null;}if (e.NewElement != null){if (Control == null){// Adpterの生成adapter = new GridViewAdapter(Context);// GridViewの生成var gridView = new CustomGridView(new ContextThemeWrapper(Context, Resource.Style.VerticalScrollbarRecyclerView));// GridViewのパラメータを設定(親サイズに追従する設定)gridView.LayoutParameters = new LayoutParams(LayoutParams.MatchParent, LayoutParams.MatchParent);// カラム数gridView.NumColumns = 3;// Viewに対しAdpterを設定gridView.Adapter = adapter;//多分コントロールを実際に生成SetNativeControl(gridView);}if (adapter != null)// NewElementにはIList<;Person>;が入ってきます// ElementはAdpterクラスが私が定義しました。adapter.Element = e.NewElement;}}
生成時一度だけ呼ばれるイベント
Adpterの生成
*adapter = new GridViewAdapter(Context);
GridViewの生成
*var gridView = new CustomGridView(new ContextThemeWrapper(Context, Resource.Style.VerticalScrollbarRecyclerView));
GridViewのパラメータを設定(親サイズに追従する設定)
*gridView.LayoutParameters = new LayoutParams(LayoutParams.MatchParent, LayoutParams.MatchParent);
カラム数
*gridView.NumColumns = 3;
Viewに対しAdpterを設定
*gridView.Adapter = adapter;
多分コントロールを実際に生成
*SetNativeControl(gridView);
NewElementにはIList&lt;Person&gt;が入ってきます
ElementはAdpterクラスが私が定義しました。
*adapter.Element = e.NewElement;
*{var view = LayoutInflater.From(parent.Context).Inflate(Resource.Layout.custom_gridview_item, parent, false);// 要素の作成SetUp(view, viewModels[position]);return view;}
Countプロパティの数だけ呼ばれるViewを生成する関数
要素の作成
*SetUp(view, viewModels[position]);

*戦士 たけし = new 戦士("たけし", 500, 100);
HP=500,  Attack=100
たけしは100ダメージを受けるところを、防御で50ダメージに軽減した
たけし.防御する(100);  HP=450
*}

outlookメールの立ち上げ
*var application = new Outlook.Application();
アドレス帳の表示名で表示できる
*mailItem.Recipients.ResolveAll();
件名
*mailItem.Subject = "件名";
本文
*mailItem.Body = "本文";
表示(Displayメソッド引数のtrue/falseでモーダル/モードレスウィンドウを指定して表示できる)
*mailItem.Display(true);
会議案内を予定
予定アイテムを会議出席依頼として設定するには、MeetingStatusプロパティをolMeetingに設定する必要がある。
*appointmentItem.MeetingStatus = OlMeetingStatus.olMeeting;
件名
*appointmentItem.Subject = "件名";
本文
*appointmentItem.Body = "本文";
翌日の9時開始
*appointmentItem.Start = DateTime.Today.AddDays(1) + new TimeSpan(0,9,0);
1時間で確保
*appointmentItem.Duration = "60";
必須出席者
*Recipient required =
任意出席者
*Recipient optional =
アドレス帳の表示名で表示できる
*mailItem.Recipients.ResolveAll();
表示
*appointmentItem.Display(true);

*Prod
本番環境

*pDest[blOffset + 4*x + 3] = (byte)255;
alpha

*+
The default HSTS value is 30 days. You may want to change this for production scenarios, see https:aka.msaspnetcore-hsts.

*{public string type = "Microsoft.Web/sites";public string apiVersion = "2019-08-01";public SiteModel(){},,,public SiteModel(string location, string name) : base(location: location, name: name){},,,using Newtonsoft.Json;using System;namespace jsontest2{class Program{static void Main(string[] args){var site = new SiteModel(location: "Japan East", name: "testSite");string json = JsonConvert.SerializeObject(site, Formatting.Indented);Console.WriteLine(json);}}},,,string jsonExcludeNull = JsonConvert.SerializeObject(site, new JsonSerializerSettings {NullValueHandling = NullValueHandling.Ignore,Formatting = Formatting.Indented });,,,
*{var parameters = new DialogParameters {{ nameof(MessageDialogViewModel.Title), "タイトル" },{ nameof(MessageDialogViewModel.Message), "メッセージ" },};this.DialogService.ShowDialog("MessageDialog", parameters, null);}
このメソッドを呼び出せばダイアログを表示できる

*public string Name { get; set; }
[EmailAddress]
*public string Name { get; set; }
[Display(Name = "Name")]
*//    values: new { area = "Identity", userId = user.Id, code = code },
"/Account/ConfirmEmail",
*//    values: new { area = "Identity", userId = user.Id, code = code },
pageHandler: null,
*//    $"Please confirm your account by <;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>;clicking here<;/a>;.");
protocol: Request.Scheme);
*//    $"Please confirm your account by <;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>;clicking here<;/a>;.");
await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",
*//if (_userManager.Options.SignIn.RequireConfirmedAccount)*//{
$"Please confirm your account by &lt;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'&gt;clicking here&lt;/a&gt;.");
*//{//    return RedirectToPage("RegisterConfirmation", new { email = Input.Email });//}
if (_userManager.Options.SignIn.RequireConfirmedAccount)
*//    return RedirectToPage("RegisterConfirmation", new { email = Input.Email });
{
*//{await _signInManager.SignInAsync(user, isPersistent: false);return LocalRedirect(returnUrl);//}
}
*//{await _signInManager.SignInAsync(user, isPersistent: false);return LocalRedirect(returnUrl);//}
else

*var index = i;
ループカウンタをラムダ式にキャプチャするために退避
最初のレバー入力は入れっぱなしでも許容したいので、初回のみ間隔チェックはパス
*.Where(b =>; index == 1 || b[1].Frame - b[0].Frame <; 10)
方向キーを識別するための関数
*bool isDirection(char c) =>; return '1' <;= c &amp;&amp; c <;= '9';
*if (command[index] != command[index - 1])*{
同じ入力が連続する場合、マージしてしまうと通知が重複して飛んでくるのを回避
最初の入力がボタンの場合は間隔チェックが必要
*.Where(b =>; (index == 1 &amp;&amp; isDirection(command[0]))
新たに持続フレームを保持するDurationを追加
*public int Duration;
これまでのStateは意味を変えず、0ならば押し下げ通知、1以上なら離し通知として扱う
*public bool State =>; Duration == 0;
方向の入力であることを識別可能なプロパティを追加
*public bool IsDirection =>; '1' <;= Key &amp;&amp; Key <;= '9';
*{switch (c){case '8':return Key == '7' || Key == '8' || Key == '9';case '2':return Key == '1' || Key == '2' || Key == '3';case '4':return Key == '7' || Key == '4' || Key == '1';case '6':return Key == '9' || Key == '6' || Key == '3';}// 厳密なエラーチェックは割愛return false;}
上下左右方向の要素を持つかを示すメソッドを追加
厳密なエラーチェックは割愛
*return false;
追加と修正のあるメンバ以外は省略
方向キーとボタンの押し下げ持続時間を保持するフィールド
*private int directionDuration = 0;
*{var value = 5;if (x >; 300) value += 1;if (x <; -300) value -= 1;if (y <; -300) value += 3;if (y >; 300) value -= 3;return value;}
テンキー表記変換をメソッド化
*{Key = ToDirection(this.prevState.X, this.prevState.Y).ToString()[0],Duration = this.directionDuration,Frame = this.frame,});
方向切り替わり時に持続フレームを通知
*{Key = ToDirection(state.X, state.Y).ToString()[0],Duration = this.directionDuration = 0,Frame = this.frame,});
持続フレームをリセットしつつ新たな方向を押し下げ通知
方向に変化がなかった場合は持続フレームをインクリメント
*++this.directionDuration;
*{Key = buttonName[i],Duration = state.Buttons[i] ? 0 : this.buttonsDuration[i],Frame = this.frame,});
押し下げ時は0を、離し時は持続フレームを通知
押し下げ継続時は持続フレームをインクリメント
*++this.buttonsDuration[i];

*if (!(selectSet[1] is SketchEntity entity)) return;
Indexは1から始まる
entityが、ActivatedObjectの直接の要素かどうか。
*bool isDirectChildOfActivatedObject = false;
*if (activeBlock == entity.ContainingSketchBlock)*{
Sketch環境でBlockをInPlace編集中は、entityの親が編集中のBlockかどうかで確認する。
*if (entity.Parent == activeSketch)*{
それ以外(通常のSketch編集、Blockのみを編集)の場合は、entityの親がactiveSketchかどうかで判断する。
*System.Diagnostics.Debug.WriteLine($"{nameof(isDirectChildOfActivatedObject)} : {isDirectChildOfActivatedObject}");
Debug
ActiveOccurrenceに含まれるかどうか
*bool inActiveOccurrence = false;
アセンブリ中の編集でなければ、常にtrue
*inActiveOccurrence = true;
*System.Diagnostics.Debug.WriteLine($"{nameof(inActiveOccurrence)} : {inActiveOccurrence}");
Debug

*{public string Name { get; set; }public string Param1 { get; set; }}
データクラス
*{public TestDataMap(){Map(x =>; x.Name).Name("Name");Map(x =>; x.Param1);}}
マップクラス

TODO: ここからUnityWebRequestを取得する
*internal static List<;UnityWebRequestAsyncOperation>; s_ActiveRequests = new List<;UnityWebRequestAsyncOperation>;();
*{// 通信処理がアクティブになる前に実行される可能性があるので、アクティブになるまで取得し続けるUnityWebRequest request;while ((request = FetchUnityWebRequestForProvider()) == null){yield return new WaitForSeconds(.1f);}// TODO: Provider内部でDisposeされるため、通信終了後に必ずArgumentExceptionが発生するwhile (!request.isDone){Debug.Log("Now Loading... " + (request.downloadProgress * 100).ToString("g2") + "%");yield return new WaitForSeconds(.1f);}}
AddressablesのPercentCompleteは正確じゃないので、内部のUnityWebRequestで進捗を表示
通信処理がアクティブになる前に実行される可能性があるので、アクティブになるまで取得し続ける
*UnityWebRequest request;
*while (!request.isDone)*{
TODO: Provider内部でDisposeされるため、通信終了後に必ずArgumentExceptionが発生する
*{var libAssembly = Assembly.GetAssembly(typeof(AssetBundleProvider));var type = libAssembly.GetType("UnityEngine.ResourceManagement.WebRequestQueue");var field = type.GetField("s_ActiveRequests", BindingFlags.Static | BindingFlags.NonPublic);var requests = (List<;UnityWebRequestAsyncOperation>;)field?.GetValue(type);if (requests == null) return null;// 初回はカタログファイルのダウンロードが入るので、bundleファイルの通信のみ取得するようにするforeach (var request in requests){if (request.webRequest.url.EndsWith(".bundle")) return request.webRequest;}return null;}
リフレクションでWebRequestQueueからUnityWebRequestを取得
*foreach (var request in requests)*{
初回はカタログファイルのダウンロードが入るので、bundleファイルの通信のみ取得するようにする

*Directory = "PictureTest", Name = $"{DateTime.UtcNow}.jpg"
保存ファイル名

*if(moveType == "swing") {transform.Rotate(0, 0, this.rotationSpeed * Time.deltaTime);//現在の向きによって速度の加速、原則を決定するif (transform.rotation.z >;= 0){rotationSpeed = rotationSpeed - rotationAcceleration * Time.deltaTime;}else {rotationSpeed = rotationSpeed + rotationAcceleration * Time.deltaTime;}}
パラメータ rotationSpeed で 回転させた後、rotationSpeedを全体の向きに応じで増減させる。
*if(moveType == "swing") {*transform.Rotate(0, 0, this.rotationSpeed * Time.deltaTime);
なるべく自然な動きにさせるため中央に向かって加速(または減速)させるイメージ
*if (transform.rotation.z >;= 0){*rotationSpeed = rotationSpeed - rotationAcceleration * Time.deltaTime;
現在の向きによって速度の加速、原則を決定する
prefab化したキャラクターを生成するタイミングで右回りか、左回りを決定したうえで
向きを回転させた後、キャラクターの向きに一定速度分進める。
Vector3.up と速度の積をとることで向いている方向へ進む(キャラクターはlocal軸に対して上を向いている前提)
*}else if(moveType == "move")
*if(rotationInclination == "left") {*deltaDegree = Random.Range(0.0f, 1.0f) * rotationAcceleration * Time.deltaTime;
update1回分でどれだけ回転するかランダムに決定する
*transform.Rotate(0, 0, deltaDegree);*transform.Translate(Vector3.up * Time.deltaTime * rotationSpeed);
ランダムに決定した分(360度表記)回転させた後、向いた方向へ進める。
Vector3.right に積をとることで、横報告へ移動します。
また、歩いているように見せたいので、deltaTimeの和を取得し、1秒を超えたらイメージのSpriteを差し替える、かつ、
わかりにくいですが足音を鳴らしています(apearClipは足音です)。
*}else if(moveType == "walk")

*if (other.gameObject.layer == LayerMask.NameToLayer("RetryPoint"))*{
リトライエリアをリストに追加
*if (other.gameObject.layer == LayerMask.NameToLayer("Enemy"))*{
敵に接触
*this.gameObject.transform.position = _retryPointList.Last().position;*//その他、フェードや諸々の設定を元に戻すなどのリトライ処理
座標を戻す
その他、フェードや諸々の設定を元に戻すなどのリトライ処理
元に戻したい処理が増えてくるなら、
Destroyして、Instantiateするってのもありかも
*}
*if (other.gameObject.layer == LayerMask.NameToLayer("RetryPoint"))*{
リトライエリアをスタックに追加
*if (other.gameObject.layer == LayerMask.NameToLayer("Enemy"))*{
敵に接触
*this.gameObject.transform.position = _retryPointStack.Peek().position;*//その他、フェードや諸々の設定を元に戻すなどのリトライ処理
座標を戻す
その他、フェードや諸々の設定を元に戻すなどのリトライ処理
元に戻したい処理が増えてくるなら、
Destroyして、Instantiateするってのもありかも
*}

文字列の場合
*Print("xxx");
*//　→　{0}
nがそのままpathになります。
*//　→　{0,0}
→　{0}
ブランチ
*DataTree.Branch(GH_path);
GH_pathで指定したlistを抽出する
DataTreeに要素を追加
*DataTree.Add(x, GH_path);
*// listをまとめて追加はできないのでforeachで入れる*foreach(class item in List)
x:追加したいオブジェクト
*foreach(class item in List)*{
listをまとめて追加はできないのでforeachで入れる

*if (SceneManager.GetActiveScene().name == "EasyScene")*{
どのシーンをクリアしたかでSetIntする数字を変更
念のためセーブしとく　クラッシュすることあるらしい
*PlayerPrefs.Save();
*{case 1:_normalImage.sprite = _normalSprite;break;case 2:_normalImage.sprite = _normalSprite;_hardImage.sprite = _hardSprite;break;case 3:_normalImage.sprite = _normalSprite;_hardImage.sprite = _hardSprite;_rankingImage.sprite = _rankingSprite;break;}
レベルに応じてUI画像入れ替え

ファイルをロードします。
*Presentation presentation = new Presentation();
OpenDocumentファイルで保存します。
*presentation.SaveToFile("OdptoPDF.pdf",FileFormat.PDF);

バリデーションが追加されている ReactiveProperty&lt;T&gt; 型の MyProp のバリデーションエラーメッセージを ReadOnlyReactiveProperty にするコード
*ReadOnlyReactiveProperty<;string>; MyPropErrorMessage = MyProp.ObserveValidationErrorMessage()

*static List<;GameObject<;[] listnerList = new List<;GameObject<;[(int)SendEventType.EventNum];
イベント受信登録者List
*{listnerList[(int)type].Add(go);}
イベント受信登録
*{// イベント種別と対応するListenerを取得SendEventType type = eventData.GetEventType();if (null == listnerList[(int)type]) return;// 実際の各種処理void Callback(IEventReceiverEx receiver, BaseEventData data){switch (type){case SendEventType.XxxEvent:receiver.OnXxxEvent();break;case SendEventType.XxxIntParamEvent:try{// 派生クラスに変換してパラメータを取得XxxIntParamEventData ev = (XxxIntParamEventData)eventData;receiver.OnXxxIntParamEvent(ev.Value);}catch (InvalidCastException){// イベント種別は送信側で設定しないのでダウンキャスト失敗しない想定だが一応Debug.Log("Invalid Event...");}break;case SendEventType.XxxMultipleParamEvent:try{// 派生クラスに変換してパラメータを取得XxxMultipleParamEventData ev = (XxxMultipleParamEventData)eventData;receiver.OnXxxMultipleParamEvent(ev.Value1, ev.Value2);}catch (InvalidCastException){// イベント種別は送信側で設定しないのでダウンキャスト失敗しない想定だが一応Debug.Log("Invalid Event...");}break;default:break;}return;}// メッセージシステムで順次処理を呼び出すforeach (GameObject listner in listnerList[(int)type]){if (null != listner){ExecuteEvents.Execute<;IEventReceiverEx>;(target: listner,eventData: null,functor: Callback);}}}
イベント送信処理
イベント種別と対応するListenerを取得
*SendEventType type = eventData.GetEventType();
*{switch (type){case SendEventType.XxxEvent:receiver.OnXxxEvent();break;case SendEventType.XxxIntParamEvent:try{// 派生クラスに変換してパラメータを取得XxxIntParamEventData ev = (XxxIntParamEventData)eventData;receiver.OnXxxIntParamEvent(ev.Value);}catch (InvalidCastException){// イベント種別は送信側で設定しないのでダウンキャスト失敗しない想定だが一応Debug.Log("Invalid Event...");}break;case SendEventType.XxxMultipleParamEvent:try{// 派生クラスに変換してパラメータを取得XxxMultipleParamEventData ev = (XxxMultipleParamEventData)eventData;receiver.OnXxxMultipleParamEvent(ev.Value1, ev.Value2);}catch (InvalidCastException){// イベント種別は送信側で設定しないのでダウンキャスト失敗しない想定だが一応Debug.Log("Invalid Event...");}break;default:break;}return;}
実際の各種処理
派生クラスに変換してパラメータを取得
*XxxIntParamEventData ev = (XxxIntParamEventData)eventData;
イベント種別は送信側で設定しないのでダウンキャスト失敗しない想定だが一応
*Debug.Log("Invalid Event...");
派生クラスに変換してパラメータを取得
*XxxMultipleParamEventData ev = (XxxMultipleParamEventData)eventData;
イベント種別は送信側で設定しないのでダウンキャスト失敗しない想定だが一応
*Debug.Log("Invalid Event...");
*foreach (GameObject listner in listnerList[(int)type])*{
メッセージシステムで順次処理を呼び出す
イベント受信登録
*EventHandlerEx.AddListner(this.gameObject, SendEventType.XxxEvent);

*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer

*public class SampleInMemoryDbContext : DbContext {public SampleInMemoryDbContext(DbContextOptions options) : base(options) { }public DbSet<;Book>; Books { get; set; }protected override void OnModelCreating(ModelBuilder modelBuilder) =>;modelBuilder.Entity<;Book>;().HasData(new Book { ID = 1, Name = "アンドロイドは電気羊の夢を見るか?" },new Book { ID = 2, Name = "幼年期の終り" },new Book { ID = 3, Name = "一九八四年" });}
using Microsoft.EntityFrameworkCore;
*public class SampleInMemoryDbContext : DbContext {public SampleInMemoryDbContext(DbContextOptions options) : base(options) { }public DbSet<;Book>; Books { get; set; }protected override void OnModelCreating(ModelBuilder modelBuilder) =>;modelBuilder.Entity<;Book>;().HasData(new Book { ID = 1, Name = "アンドロイドは電気羊の夢を見るか?" },new Book { ID = 2, Name = "幼年期の終り" },new Book { ID = 3, Name = "一九八四年" });}
using SeedingInMemoryDb.Models;
*public void ConfigureServices(IServiceCollection services) {services.AddDbContext<;SampleInMemoryDbContext>;(options =>;options.UseInMemoryDatabase("sample_in_memory_db"););services.AddControllers();}
using Microsoft.EntityFrameworkCore;
*public void ConfigureServices(IServiceCollection services) {services.AddDbContext<;SampleInMemoryDbContext>;(options =>;options.UseInMemoryDatabase("sample_in_memory_db"););services.AddControllers();}
using Microsoft.Extensions.DependencyInjection;
*public class Program {public static async Task Main(string[] args) {IHost host = BuildHost(args);using IServiceScope scope = host.Services.CreateScope();IServiceProvider provider = scope.ServiceProvider;using var context = provider.GetRequiredService<;SampleInMemoryDbContext>;();await context.Database.EnsureCreatedAsync();host.Run();}public static IHost BuildHost(string[] args) =>;Host.CreateDefaultBuilder(args).ConfigureWebHostDefaults(web =>; web.UseStartup<;Startup>;().Build();}
using Microsoft.Extensions.Hosting;
*public class Program {public static async Task Main(string[] args) {IHost host = BuildHost(args);using IServiceScope scope = host.Services.CreateScope();IServiceProvider provider = scope.ServiceProvider;using var context = provider.GetRequiredService<;SampleInMemoryDbContext>;();await context.Database.EnsureCreatedAsync();host.Run();}public static IHost BuildHost(string[] args) =>;Host.CreateDefaultBuilder(args).ConfigureWebHostDefaults(web =>; web.UseStartup<;Startup>;().Build();}
using System.Threading.Tasks;
*public class BooksController : Controller {private readonly SampleInMemoryDbContext _db;public BooksController(SampleInMemoryDbContext db) =>; _db = db;[HttpGet]public async Task<;ActionResult<;IEnumerable<;Book>;>;>; Get() =>;await _db.Books.ToListAsync();}
using System.Threading.Tasks;

ファイルをロードします。
*Document doc = new Document();
PCLファイルで保存します。
*doc.SaveToFile("Result.pcl", FileFormat.PCL);

*RpcOptionsToAll.InterestGroup = (byte)view.Group;
NOTE: Test-wise, this is static and re-used to avoid memory garbage

*compiler.CompilerOptions = "
optimize";オプション設定
使用するDLLの設定 compiler.ReferencedAssemblies.Add("System.dll");
*CompilerResults compilerResults = provider.CompileAssemblyFromSource(compiler, sauce);
*if (compilerResults.Errors.Count >; 0)*{
ソースファイルのコンパイルを呼び出します。
*foreach (CompilerError ce in compilerResults.Errors)*{
コンパイルエラーを表示します。
正常なコンパイルメッセージを表示します。
*Console.WriteLine("正常に実行されました");

*int count = surface.Vertices.Count;
頂点数
読み込み
*string loadFilePath = @"C:\Users\Desktop\ball_ascii.STL";
*PolygonModel subSurface = ShapeTransform.SubdivisionSurface(surface);*//保存
サブディビジョンサーフェス
保存
*string saveFilePath = @"C:\Users\Desktop\ball_ascii2.STL";

UIとの紐付けのため
*[SerializeField] private Button button;
カウントを記録する
*private int count = 0;
buttonのイベントが発行されたときにカウントアップmethodが走る
OnClickAsObservableはUniRxのプラグインのなかで定義されている
自分で定義を追加することもできる(別の記事書いたらやってみます)
*button.OnClickAsObservable()
クリックイベントの最後に呼ばれるのがSubscribe
ラムダ式で記入している．_が引数で(今回はないので仮引数の_)呼ばれるのがCountUp()
Addto()はいつこのイベントを破棄するかを決めている．詳しくは別記事か参考リンクから
*.Subscribe(_ =>; CountUp())
ここが重要！！
SubjectはIObservableとIObserverの2つを実装しており，「値を発行する」「値を購読できる」という2つの機能を持ったクラスである
*private Subject<;string>; _onClickButton = new Subject<;string>;();
*{get { return _onClickButton; }}
IObservableはイベントメッセージを購読できる」というふるまいを定義したインターフェース
インプットフィールドの入力が終わったらイベント発火
*inputField.OnEndEditAsObservable()
作成した_onClickButtonの値が変わったらイベント発火
*OnClickButton
*{count++;countText.text = count.ToString();}
カウントアップのメソッド
*{greetText.text = "おはようございます" + name + "さん";}
挨拶のメソッド

*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer

*new SomeClass
This is last item.
≪メソッド形式≫　※第3引数はソートの昇順・降順を指定するEnum
*Sort(ref targetList, "Prop1", SortType.Asc);
≪Linq風形式≫
*var sortedList = targetList
≪メソッド形式≫
*Sort(ref targetList, "Prop4.InnerProp3.DeepProp1", SortType.Desc);
≪Linq風形式≫
*var sortedList = targetList
*{{ "Prop1", SortType.Asc },{ "Prop4.InnerProp3.DeepProp1", SortType.Desc },{ "Prop4.InnerProp2", SortType.Desc },};
≪メソッド形式≫
≪Linq風形式≫
*var sortedList = targetList
変数「targetList」「sortKey」と「sortType」は、メソッドの引数で渡されたものを使用する。
ジェネリックのTには、このメソッドが呼び出されるときに「targetList」の要素の型が入る。
ここで呼び出している内部処理「AssembleOrderFunc」で、OrderBy句の引数となるラムダ式を動的に生成する。
*Func<;T, object>; orderFunc = AssembleOrderFunc<;T>;(sortKey);
ソートキーを「.」で分割する。
*List<;string>; sortKeyHierarchy = sortKey.Split('.').ToList();
*{object val = x;foreach (string key in sortKeyHierarchy){if (val == null){return val;}val = val.GetType().GetRuntimeProperty(key).GetValue(val);}return val;};
リフレクションを使用し、ソート対象となるプロパティ値を引っ張り出す。
*{{ "Property4.PropertyW.PropertyD.PropertyK.Property4.PropertyW.PropertyD.PropertyI", SortType.Desc },{ "Property1", SortType.Asc },{ "Property4.PropertyW.PropertyA", SortType.Desc },{ "Property2", SortType.Asc },{ "Property4.PropertyW.PropertyD.PropertyJ", SortType.Asc },}
メソッド形式
Linq風形式
*var sortedList = targetList

撮影画像の読み取り
*camera.Read(src);
歪み補正
*Cv2.Undistort(src, calib, mtx, dist);
画像処理
*var tmp = new Mat();
OpenCVのカラーの並びに変換
*Cv2.CvtColor(calib, tmp, OpenCvSharp.ColorConversionCodes.RGB2BGR);
BGR画像をHSV画像に変換
*var hsv = new Mat();
inRange関数で範囲指定２値化 -&gt; マスク画像として使う
*var msk = new Mat();
作業をクリア
*DobotDll.SetQueuedCmdClear();
コマンド開始
*DobotDll.SetQueuedCmdStartExec();
現在位置を取得
*var pose = GetCurrentPose();
対象の上部まで移動(Z座標は適当)
*var cmdIndex = ptp((byte)2, (float)target_x, (float)target_y, (float)0.0, pose.rHead);
対象物のZ座標計算
*var object_z = obj.PedestalZ + obj.ObjectHeight;
対象の位置まで下がる
*cmdIndex = ptp((byte)2, (float)target_x, (float)target_y, (float)object_z, pose.rHead);
下がったらサクションカップONしてつかむ
*DobotDll.SetEndEffectorSuctionCup(true, true, true, ref cmdIndex);
いったん上に持ち上げる
*cmdIndex = ptp((byte)2, (float)target_x, (float)target_y, (float)0.0, pose.rHead);
持っていく場所に移動
*cmdIndex = ptp((byte)2, (float)obj.PlacePoseXCoordinate, (float)obj.PlacePoseYCoordinate, (float)obj.PlacePoseZCoordinate, pose.rHead);
下がったらサクションカップOFFして放す
*DobotDll.SetEndEffectorSuctionCup(false, false, false, ref cmdIndex);
上がって終わり
*cmdIndex = ptp((byte)2, (float)obj.PlacePoseXCoordinate, (float)obj.PlacePoseYCoordinate, (float)0.0 ,pose.rHead);
コマンド終了
*DobotDll.SetQueuedCmdStopExec();

*services.AddSingleton<;DefaultAzureCredential<;();
追加

*// var certificate = new X509Certificate2(@"key.p12", "notasecret", X509KeyStorageFlags.Exportable);*// this works on Azure.
fine on local. but it doesn't work on Azure. not sure why.
*var certificate = new X509Certificate2(file, "notasecret", X509KeyStorageFlags.MachineKeySet |*X509KeyStorageFlags.PersistKeySet |
this works on Azure.
*{HttpClientInitializer = credential,ApplicationName = "PUSH API Sample",});
Create the service.
*var send = service.Projects.Messages.Send(requestBody, $"projects/{projectId}");
"Projects" is an instance of ProjectsResource. Projects.Messages is a REST resource.
*// Execute() returns a supposed-to-be "response" but no information in it, either success or error.*// Errors will be thrown as exceptions.
Send HttpRequest

*public static class SyntaxGeneratorHelper {// (snip)}
(snip)
*public void _クラス定義パートの生成() {var ns = (NamespaceDeclarationSyntax)syntaxRoot.Members[0];var intf = (TypeDeclarationSyntax)ns.Members[0];Assert.AreEqual(SyntaxKind.InterfaceDeclaration, intf.Kind(), "元の型のSyntax");var cls = intf.ToClassDeclaration("Impl");Assert.That(cls.Kind(), Is.EqualTo(SyntaxKind.ClassDeclaration), "生成したSyntax");Assert.That(cls.Modifiers.Any(SyntaxKind.PublicKeyword), Is.True, "生成したクラスのアクセス就職子");Assert.That(cls.Keyword.ToString(), Is.EqualTo("class"), "生成した型種");Assert.That(cls.Identifier.ToString(), Is.EqualTo("ColorDaoImpl"), "生成したクラスの型名");Assert.That(cls.BaseList.Types.Count, Is.EqualTo(1), "親クラス or インターフェースの数");Assert.That(cls.BaseList.Types[0].ToString(), Is.EqualTo("IColorDao"), "親インターフェース名");Assert.That(cls.Members.Count, Is.EqualTo(0), "生成されたメソッド数");}
(snip)
*public void _引数を持たないメソッドの生成() {var ns = (NamespaceDeclarationSyntax)syntaxRoot.Members[0];var intf = (TypeDeclarationSyntax)ns.Members[0];Assert.That(intf.Members.Count, Is.EqualTo(1), "用意されたインターフェースのメソッド数");Assert.That(intf.Members[0], Is.InstanceOf<;MethodDeclarationSyntax>;(), "用意されたインターフェースのメソッドSyntax");var meth = SyntaxGeneratorHelper.ToMethodStub((MethodDeclarationSyntax)intf.Members[0]);Assert.That(meth.Kind(), Is.EqualTo(SyntaxKind.MethodDeclaration), "生成したSyntax");Assert.That(meth.Modifiers.Any(SyntaxKind.PublicKeyword), Is.True, "生成したメソッドのアクセス就職子");Assert.That(meth.Identifier.ToString(), Is.EqualTo("ListAll"), "生成したメソッド名");Assert.That(meth.ReturnType.ToString(), Is.EqualTo("IEnumerable<;ColorData>;"), "生成したメソッドの戻り値型");Assert.That(meth.ParameterList.Parameters.Count, Is.EqualTo(0), "生成したメソッドの引数の数");Assert.That(meth.Body.Statements.Count, Is.EqualTo(1), "生成したメソッドの本文行数");}
(snip)
*public static SyntaxTokenList AsTokens(this SyntaxToken inSyntax) {return new SyntaxTokenList(inSyntax);}
(snip)
*public void _名前空間宣言の生成() {var u1 = SyntaxGeneratorHelper.ToUsingDirective("System");Assert.That(u1.Kind(), Is.EqualTo(SyntaxKind.UsingDirective), "生成されたusing[1]");Assert.That(u1.Name, Is.Not.InstanceOf<;QualifiedNameSyntax>;(), "生成された名前空間のSyntax[1]");Assert.That(u1.Name.ToString(), Is.EqualTo("System"), "生成された名前空間名[1]");var u2 = SyntaxGeneratorHelper.ToUsingDirective("System.Collections.Generic");Assert.That(u2.Kind(), Is.EqualTo(SyntaxKind.UsingDirective), "生成されたusing[2]");Assert.That(u2.Name, Is.InstanceOf<;QualifiedNameSyntax>;(), "生成された名前空間のSyntax[2]");Assert.That(u2.Name.ToString(), Is.EqualTo("System.Collections.Generic"), "生成された名前空間名[2]");var u2_3 = (QualifiedNameSyntax)u2.Name;Assert.That(u2_3.Right, Is.Not.InstanceOf<;QualifiedNameSyntax>;(), "生成された名前空間[2]の第3パートSyntax");Assert.That(u2_3.Right.ToString(), Is.EqualTo("Generic"), "生成された名前空間[2]の第3パート名");Assert.That(u2_3.Left, Is.InstanceOf<;QualifiedNameSyntax>;(), "生成された名前空間[2]の第2パートSyntax");var u2_2 = (QualifiedNameSyntax)u2_3.Left;Assert.That(u2_2.Right, Is.Not.InstanceOf<;QualifiedNameSyntax>;(), "生成された名前空間[2]の第2パートSyntax");Assert.That(u2_2.Right.ToString(), Is.EqualTo("Collections"), "生成された名前空間[2]の第2パート名");Assert.That(u2_2.Left, Is.Not.InstanceOf<;QualifiedNameSyntax>;(), "生成された名前空間[2]の第1パートSyntax");Assert.That(u2_2.Left.ToString(), Is.EqualTo("System"), "生成された名前空間[2]の第1パート名");}
(snip)
*public static UsingDirectiveSyntax ToUsingDirective(string inUsing) {returnSyntaxFactory.UsingDirective(SyntaxFactory.ParseName(inUsing).WithLeadingTrivia(SyntaxFactory.Space)).WithTrailingTrivia(SyntaxFactory.CarriageReturnLineFeed);}
(snip)
*public void _生成したクラスのビルド_and_実行() {var ns = (NamespaceDeclarationSyntax)syntaxRoot.Members[0];var intf = (TypeDeclarationSyntax)ns.Members[0];var cls = intf.ToClassDeclaration("Impl");cls = cls.AddMembers(intf.Members.CollectMethod().Select(SyntaxGeneratorHelper.ToMethodStub).ToArray());var usings = new[] {"System.Collections.Generic"};var newUnit =SyntaxFactory.CompilationUnit().AddMembers(ns.WithLeadingTrivia(null).WithMembers(cls.AsMemberDecls())).WithUsings(usings.Select(SyntaxGeneratorHelper.ToUsingDirective).ToSyntaxList());// TestContext.Progress.WriteLine(newUnit.ToFullString());}
(snip)
*public void _生成したクラスのビルド_and_実行() {// (snip)using(var stream = new MemoryStream()) {var dotnetCoreDirectory = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory();var opts = new CSharpCompilationOptions(outputKind: OutputKind.DynamicallyLinkedLibrary);var compiler = CSharpCompilation.Create("autoGen",syntaxTrees: new[] { SyntaxFactory.SyntaxTree(newUnit) },references: new[] {AssemblyMetadata.CreateFromFile(typeof(object).Assembly.Location).GetReference(),MetadataReference.CreateFromFile(Path.Combine(dotnetCoreDirectory, "netstandard.dll")),MetadataReference.CreateFromFile(Path.Combine(dotnetCoreDirectory, "System.Runtime.dll")),AssemblyMetadata.CreateFromFile(typeof(IColorDao).Assembly.Location).GetReference(),},options: opts);var emitResult = compiler.Emit(stream);Assert.That(emitResult.Success, Is.True, "コンパイル結果");}}
(snip)
*using(var stream = new MemoryStream()) {var dotnetCoreDirectory = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory();var opts = new CSharpCompilationOptions(outputKind: OutputKind.DynamicallyLinkedLibrary);var compiler = CSharpCompilation.Create("autoGen",syntaxTrees: new[] { SyntaxFactory.SyntaxTree(newUnit) },references: new[] {AssemblyMetadata.CreateFromFile(typeof(object).Assembly.Location).GetReference(),MetadataReference.CreateFromFile(Path.Combine(dotnetCoreDirectory, "netstandard.dll")),MetadataReference.CreateFromFile(Path.Combine(dotnetCoreDirectory, "System.Runtime.dll")),AssemblyMetadata.CreateFromFile(typeof(IColorDao).Assembly.Location).GetReference(),},options: opts);var emitResult = compiler.Emit(stream);Assert.That(emitResult.Success, Is.True, "コンパイル結果");}
(snip)
*namespace GenSyntaxTest {// (snip)public struct ColorData {}public interface IColorDao {IEnumerable<;ColorData>; ListAll();}}
(snip)
*public struct ColorData {}
(snip)
*public void _生成したクラスのビルド_and_実行() {// (snip)using(var stream = new MemoryStream()) {// (snip)Assert.That(stream.Length, Is.GreaterThan(0), "生成したバイナリサイズ");stream.Position = 0;var buf = new byte[stream.Length];stream.Read(buf, 0, buf.Length);var asm = Assembly.Load(buf);Assert.That(asm.GetTypes().Length, Is.EqualTo(1));Assert.That((asm.GetTypes()[0]).FullName, Is.EqualTo("GenSyntaxTest.ColorDaoImpl"), "生成された型名");var instance = (IColorDao)asm.CreateInstance("GenSyntaxTest.ColorDaoImpl");Assert.IsNull(instance.ListAll(), "スタブ関数へのアクセス");}}
(snip)
*using(var stream = new MemoryStream()) {// (snip)Assert.That(stream.Length, Is.GreaterThan(0), "生成したバイナリサイズ");stream.Position = 0;var buf = new byte[stream.Length];stream.Read(buf, 0, buf.Length);var asm = Assembly.Load(buf);Assert.That(asm.GetTypes().Length, Is.EqualTo(1));Assert.That((asm.GetTypes()[0]).FullName, Is.EqualTo("GenSyntaxTest.ColorDaoImpl"), "生成された型名");var instance = (IColorDao)asm.CreateInstance("GenSyntaxTest.ColorDaoImpl");Assert.IsNull(instance.ListAll(), "スタブ関数へのアクセス");}
(snip)

*ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(projectName, projectName + ".exe", true);
アセンブリのモデルを生成する
クラスを宣言する
TypeBuilder typeBuilder = moduleBuilder.DefineType("Program", TypeAttributes.Class);クラスを設定
MethodBuilder mainMethodBuilder = typeBuilder.DefineMethod("Main", MethodAttributes.Public | MethodAttributes.Static, typeof(void), Type.EmptyTypes);メソッドの設定
ILGenerator ilMain = mainMethodBuilder.GetILGenerator();ILを指定する
LocalBuilder msgLocal = ilMain.DeclareLocal(typeof(string));stringの変数を宣言する
msgLocal.SetLocalSymInfo("letter");変数名を決める
ilMain.Emit(OpCodes.Ldstr, "Hello World");スタックにHello Worldをプッシュする(文字列の時)
ilMain.Emit(OpCodes.Stloc, msgLocal);スタックの一番上から現在の値をポップし変数に格納する
ilMain.Emit(OpCodes.Ldloc, msgLocal);スタックに変数からプッシュする
ilMain.EmitCall(OpCodes.Call, Type.GetType("System.Console").GetMethod("WriteLine", new Type[] { typeof(string) }), null);呼び出す
*ilMain.Emit(OpCodes.Ret);

縦画面に固定する場合の設定です
Screen.autorotateToPortrait = true;  縦
Screen.autorotateToLandscapeLeft = false;  左
Screen.autorotateToLandscapeRight = false;  右
Screen.autorotateToPortraitUpsideDown = false;  上下逆
*Screen.orientation = ScreenOrientation.Portrait;

*{//// 解像度の指定FrameWidth = 1920,FrameHeight = 1080};
webカメラキャプチャ
*while (true)*{
ずっとループ
カメラ内部パラメータ格納用
*Mat mtx = new Mat();
*{mtx = fs["mtx"].ReadMat();dist = fs["dist"].ReadMat();}
ymlファイルを読み来み計算パラメータを取得
撮影画像の読み取り
*camera.Read(src);
歪み補正
*Cv2.Undistort(src, calib, mtx, dist);
マーカー検出
*OpenCvSharp.Aruco.CvAruco.DetectMarkers(calib, p_dict, out corners, out ids, detect_param, out rejectedImgPoints);
検出されたマーカ情報の描画
*OpenCvSharp.Aruco.CvAruco.DrawDetectedMarkers(calib, corners, ids, new Scalar(0, 255, 0));
*var markers = Enumerable.Zip(ids, corners, (i, c) =>; new { i, c })
番号順にする為にids,cornersを固めて
*var markers = Enumerable.Zip(ids, corners, (i, c) =>; new { i, c })
dictionaryにしてソート
*Console.WriteLine($"marker{cnt} X:{average_X}, Y:{average_Y}");
マーカーの中心座標を取得
マーカーの中心座標を描画
*midllePoints.ForEach(mp =>; calib.Circle(
*{//// 解像度の指定FrameWidth = 1920,FrameHeight = 1080};
webカメラキャプチャ
*while (true)*{
ずっとループ
カメラ内部パラメータ格納用
*Mat mtx = new Mat();
*{mtx = fs["mtx"].ReadMat();dist = fs["dist"].ReadMat();}
ymlファイルを読み来み計算パラメータを取得
撮影画像の読み取り
*camera.Read(src);
歪み補正
*Cv2.Undistort(src, calib, mtx, dist);
マーカー検出
*OpenCvSharp.Aruco.CvAruco.DetectMarkers(calib, p_dict, out corners, out ids, detect_param, out rejectedImgPoints);
検出されたマーカ情報の描画
OpenCvSharp.Aruco.CvAruco.DrawDetectedMarkers(calib, corners, ids, new Scalar(0, 255, 0));
番号順にする為にids,cornersを固めて
dictionaryにしてソート
*var markers = Enumerable.Zip(ids, corners, (i, c) =>; new { i, c })
*//Console.WriteLine($"marker{cnt} X:{average_X}, Y:{average_Y}");
マーカーの中心座標を取得
マーカーの中心座標を描画
*midllePoints.ForEach(mp =>; calib.Circle(
ここから座標変換
*var srcList = new List<;DenseVector>;(4);
射影変換行列を求めて
*var homo = HomographyHelper.FindHomography(srcList, dstList);
入力平面から出力平面上の座標に変換
試しにmarker0の位置を変換(画像座標系→ロボット座標系)
*(double X, double Y) = homo.Translate(667, 241);

*if (Topmost == true) extendStyle ^= Consts.WS_EX_TOPMOST;
TOP MOST分減算
クリックをスルー場合に値を保存
extendStyle |= Consts.WS_EX_TRANSPARENT; フラグの追加
if (Topmost == true) extendStyle ^= Consts.WS_EX_TOPMOST; TOP MOST分減算
*G.through_extendStyle = extendStyle;
初期はキャッチで設定
*NativeMethods.SetWindowLong(handle, Consts.GWL_EXSTYLE, G.catch_extendStyle);
ノティファイアイコン上でのコンテキストメニュー全般の処理
*MenuItem selectedItem = (MenuItem)sender;
中略
case "8":   Icon Mode click ignore on/off
*if (G.MODE == 2)
中略
*}
スタートアップに自身のショートカットを作成する
WshShellを作成
*var t = Type.GetTypeFromCLSID(new Guid("72C24DD5-D70A-438B-8A42-98424B88AFB8"));
ショートカット作成先（startupフォルダパス＋ショートカット名）
*var shortcutPath = Environment.GetFolderPath(Environment.SpecialFolder.StartMenu) + "\\Programs\\Startup\\Bootrecorder.lnk";
実行ファイルパス（なるべくならFromsは使いたくないのでAssenblyを利用）
*Assembly myAssembly = Assembly.GetEntryAssembly();
*object shortcut = t.InvokeMember("CreateShortcut", System.Reflection.BindingFlags.InvokeMethod, null, shell,new object[] { shortcutPath });
ショートカットを指定先に作成
フォルダを開けて見せてあげる
*System.Diagnostics.Process.Start("EXPLORER.EXE", "/select,\"" + shortcutPath + "\"");
起動開始解除。自身のショートカットをスタートアップフォルダから削除
*var shortcutPath = Environment.GetFolderPath(Environment.SpecialFolder.StartMenu) + "\\Programs\\Startup\\Bootrecorder.lnk";
フォルダを開けて見せてあげる
*var StartupFolder = Environment.GetFolderPath(Environment.SpecialFolder.StartMenu) + "\\Programs\\Startup\\";
ログファイルの個別指定
*var dialog = new OpenFileDialog();
時報画面の作成準備
*var SigWin = new signal();
時計描画
*DateTime dt = DateTime.Now;
中略
子供側でfade in/out して一定時間過ぎたら自身をcloseする
*}

カッコで囲まれた文字を抽出する
*string target = "4984988946484986486 (452E3D09047C8276)";
結果：body="452E3D09047C8276"
IPアドレスが該当しているか（122.10.*.*）[正規表現]
*string target2 = "122.10.1.1";
結果：result=true;
カンマ区切り文字列を配列にする
*string stCsvData = "csv1,csv2,csv3";
タブ区切り文字列を配列にする
*string stTsvData = "tsv1    tsv2    tsv3";
期間の開始日と終了日を分けて表示する
*string kikan = "2018/08/08 - 2020/07/09";

StreamingAssetsのファイルパス
*string path = Application.streamingAssetsPath;
起動
*System.Diagnostics.Process.Start(path);
*if (System.IO.File.Exists(path))*System.Diagnostics.Process.Start(path);
ファイルの存在確認

*string[] animals = {"dog","cat"};
変数は全て型を指定

*c.ii = i;
クロージャにiを束縛

NuGetパッケージから「ClosedXML」をインストールしておく。
*using System.Collections.Generic;
ワークブックを作成する
*var wb = new XLWorkbook();
ここで全テーブルのデータを "Dictionary&lt;テーブル名, テーブルのデータ&gt;" で取得
"getAllTablesメソッド" はMainメソッドは下記参照
*Dictionary<;string, DataTable>; data = getAllTables();
*foreach(KeyValuePair<;string, DataTable>; pair in data)*{
全テーブルデータdata をすべてループさせる
DictionaryのKey(ここではテーブル名)を取得
*string tableName = pair.Key;
DictionaryのValue(ここではテーブルデータ)を取得
*DataTable dt = pair.Value;
ワークシートを作成する
先ほど作ったワークブックwbに"Worksheets.Add(テーブルデータ)"で作れてしまう
*var ws = wb.Worksheets.Add(dt);
シート名をテーブル名に設定
*ws.Name = tableName;
表全体をまとめて列幅を自動調整する(必要に応じて)
*ws.ColumnsUsed().AdjustToContents();
ワークブックを任意のパスで保存
*wb.SaveAs(@"C:\Users\user\Desktop\AllDbData.xlsx");
DBに接続する接続文字列の取得
ちなみに、.mdfファイルに接続する場合は★に囲まれている部分を下記のように設定してください。
★
*var builder = new SqlConnectionStringBuilder()
mdfファイルの場合の例(上の★で囲まれた部分を削除して、これを入れてください。)
var connectionString = string.Empty;
connectionString += @"data source=.\sqlexpress;";
connectionString += @"attachdbfilename=";
connectionString += "(mdfファイルパス名)";
connectionString += @";";
connectionString += @"integrated security=true;";
connectionString += @"user instance=true;";
*using (SqlConnection connection = new SqlConnection(connectionString))
DBに接続する
*connection.Open();
全てのテーブル名を取得する
下記のSQLは全テーブル名を取得するsql
*string sql = "SELECT * FROM sys.objects WHERE TYPE = 'U';"
データベースとデータを結ぶSqlDataAdapterを生成
*SqlDataAdapter adapter = new SqlDataAdapter(sql, connection);
データを格納するDatasetを生成
*DataSet ds = new DataSet();
SqlDataAdapter のFillメソッドの引数に Dataset(ds)を渡すことで、
sqlで実行したデータがDatasetに格納される
*adapter.Fill(ds);
dsはTableを持っているので最初のテーブルをds.Tables[0]として取得し、
かつ、そのテーブルはDataRow(テーブルの行)を持っているので、その行の分
だけループを回してデータを取り出す。
*foreach(DataRow row in ds.Tables[0].Rows)
DataRowの最初(row[0])にテーブル名がある。
row[0]はObject型なので、指定の型でのキャストが必要。
ここではテーブル名なのでstringでキャスト。
*tableList.Add((string)row[0]);
取得したすべてのテーブルのデータを格納する辞書
*Dictionary<;string, DataTable>; allData = new Dictionary<;string, DataTable>;();
先ほど作成した全テーブル名のリストからテーブル名の分だけループを回し、
sqlにテーブル名を入れて、テーブルのデータを取得する。
*foreach (string table in tableList)
*adapter = new SqlDataAdapter($"SELECT * FROM {table}", connection);
DBとDataSetをつなぐSqlDataAdapterを生成する
読み込んだデータをdsにセットする
*adapter.Fill(d, table);
DataSetからテーブルを取得
"DataTable dt = d.Tables[0]"とするとエラーになるので、
.Copy()をつける。
*DataTable dt = d.Tables[0].Copy();
Dictionaryに格納する
*allData[table] = dt;

*public int Value;
3が入る

設定ファイルから接続文字列を取得
*var connectionString = appSettings.AzureStorageConfig.AZURE_STORAGE_CONNECTION_STRING;
ストレージアカウントのオブジェクトを作成
*_account = CloudStorageAccount.Parse(connectionString);
Blobクライアントを作成
*var client = _account.CreateCloudBlobClient();
Blobコンテナの参照を取得
*var container = client.GetContainerReference(_appSettings.AzureStorageConfig.ContainerName);
Blobコンテナが存在していなかったら作成
*await container.CreateIfNotExistsAsync();
*{// 引数に指定されたファイル名で作成するvar blob = container.GetBlockBlobReference(blobName + ".txt");// 引数に指定した内容がファイルに書き込まれるawait blob.UploadTextAsync("file content");}
Blobの追加
引数に指定されたファイル名で作成する
*var blob = container.GetBlockBlobReference(blobName + ".txt");
引数に指定した内容がファイルに書き込まれる
*await blob.UploadTextAsync("file content");

*loss();
パラメータ更新後、最終的な出力を得、表示。

取得対象の設定
var htmlUrl = $"https:weather.yahoo.co.jp/weather/jp/13/4410.html";
*var querySelector = $"#main >; div.forecastCity >; table >; tbody >; tr >; td:nth-child(2) >; div >; p.pict";
HTMLドキュメントの取得
*var document = BrowsingContext.New(Configuration.Default.WithDefaultLoader()).OpenAsync(htmlUrl).Result;
クエリセレクタでデータの取得
*var element = document.QuerySelector(querySelector);

*private const string GcpUrl = "https:
www.googleapis.comauthcloud-platform";
*{var str = inputField.text;if (string.IsNullOrEmpty(str)) return;inputField.text = "";CreateRequest(str);Debug.Log($"Send Request: {str}");});
ボタンを押したときのイベントを追加
認証情報をResourceから読み込む
*var credentialStr = Resources.Load<;TextAsset>;(credential).text;
*{AudioEncoding = AudioEncoding.Linear16,SampleRateHertz = 44100};
オプションを記述
声のパラメータを指定
https:cloud.google.com/text-to-speech/docs/voices?hl=jaに記載されているものから選択できます
*_voiceSelectionParams = new VoiceSelectionParams()
*Task.Run(async () =>; { SetAudioClip(await _client.SynthesizeSpeechAsync(request)); });
リクエストを非同期で送信し，返ってきた後に再生するメソッドに投げる
byte[]をAudioClipで利用できる形に変換する
*var wav = new WAV(bytes);
AudioSourceに新しいAudioClipを貼り付ける
*audioSource.clip = AudioClip.Create("TextToSpeech", wav.SampleCount, 1, wav.Frequency, false);
AudioClipを再生
*audioSource.Play();

*.Select(s =<; s.ToUpper())
警告
素朴な方法
*var numbers1 = array

*SynthesisInput input = new SynthesisInput {Text = "目的地は、日本橋です。"};
読み上げテキストの設定
*VoiceSelectionParams voice = new VoiceSelectionParams {Name = "ja-JP-Wavenet-D",LanguageCode = "ja-JP",SsmlGender = SsmlVoiceGender.Neutral};
音声タイプの設定
*AudioConfig config = new AudioConfig {AudioEncoding = AudioEncoding.Mp3,Pitch = -2.0};
オーディオ出力の設定
*var response = client.SynthesizeSpeech(new SynthesizeSpeechRequest {Input = input,Voice = voice,AudioConfig = config});
Text-to-Speech リクエストの生成
*using (Stream output = File.Create(fileName)) {response.AudioContent.WriteTo(output);Console.WriteLine($"音声コンテンツを '{fileName}' として保存しました。");}
Text-to-Speech レスポンス（音声ファイル）の保存

*public class Monster {
内部クラス

xsdファイルパスから型変換
*XmlTextReader reader = new XmlTextReader(xsdFilePath);
XMLファイルとXSDファイルを設定する。
*XmlDocument xmlDocument = new XmlDocument();
スキーマチェック
*xmlDocument.Validate(ValidationEventHandler);
仮の返却値
*return null;
*{//エラーあり（true）を返却return ex;}
xsd等の規約に対する例外？（そもそも必要？）
エラーあり（true）を返却
*return ex;

*var ns = (NamespaceDeclarationSyntax)m;
Microsoft.CodeAnalysis.CSharp.Syntax

どこかしらでBindする
*Container.Bind<;ITickable>;().To<;Ship>;().AsSingle();

*{static void Main(){IWakeUp wakeUp = new WakeUpProxy();wakeUp.MorningCall();wakeUp.WakeUpMorning();}}
Client(利用者)
*{public void MorningCall() =>; Console.WriteLine("--- 朝 ---");public void WakeUpMorning();}
Subject(主体・本人)
*{public WakeUp() =>; Console.WriteLine($"{nameof(WakeUp)}インスタンスが生成されました。");public void WakeUpMorning(){Thread.Sleep(2000);Console.WriteLine("眠いけど頑張って起きよう(´Д⊂ヽ");}}
RealSubject(真の主体・本人)
Proxy(代理人)
WakeupMorningメソッドが呼ばれるまでは重い処理のあるWakeUpクラスのインスタンスは生成されません。
*public class WakeUpProxy : IWakeUp

メモ帳のトップウィンドウのウィンドウハンドル（※見つかることを前提としている）
*var mainWindowHandle = Process.GetProcessesByName("notepad")[0].MainWindowHandle;
対象の編集領域を探す
*var hWnd = FindTargetEdit(GetWindow(mainWindowHandle));
キーボードにメッセージを送る
0x00000041 : "A"の文字コード
0x40000007 : キーが離された状態から押された状態へ遷移、7回キー入力を繰り返すことを表すパラメータ
（どんな値を埋めれば良いか分からない箇所は0埋めとしました）
*SendMessage(hWnd, WM_CHAR, 0x00000041, 0x40000007);
*{var all = GetAllChildWindows(top, new List<;Window>;());// クラス名からコントロールを取得する。メモ帳の場合はEditコントロールが編集領域。return all.Where(x =>; x.ClassName == "Edit").First().hWnd;}
全てのEditコントロールを列挙し、最初に見つけたEditコントロールのウィンドウハンドルを返す
クラス名からコントロールを取得する。メモ帳の場合はEditコントロールが編集領域。
*return all.Where(x =>; x.ClassName == "Edit").First().hWnd;

*{this.Top = top;this.Left = left;this.Show();// スライドイン表示for (int i = 1; i <; 15; i++){var newValue = this.Width + 30 * (i - 0.7);if (newValue <;= ownerWidth){this.Width = newValue;}else{break;}await Task.Delay(1);}this.Width = ownerWidth;}
メインウィンドウ側から呼んでもらう、メニューバー表示用のメソッド
*for (int i = 1; i <; 15; i++)*{
スライドイン表示

*[TokuiCode]
←集約した属性
その他の項目は省略...
*}

*Sp.Speak(n);
喋らせる

*{public string name;public int hp;public int at;public int cost;public Sprite icon;}
カードデータそのものとその処理
データ(model)に関することを操作
*CardModel model;
*{public new string name;public int hp;public int at;public int cost;public Sprite icon;}
カードデータそのもの
*{public string name;public int hp;public int at;public int cost;public Sprite icon;public CardModel(int cardID){CardEntity cardEntity = Resources.Load<;CardEntity>;("CardEntityList/Card"+cardID);name = cardEntity.name;hp = cardEntity.hp;at = cardEntity.at;cost = cardEntity.cost;icon = cardEntity.icon;}}
カードデータそのものとその処理
データ(model)に関することを操作
*CardModel model;
カードの生成とデータの受け渡し
*CardController card = Instantiate(cardPrefab, hand, false);

指定されたオブジェクトのVisualTree上の親を順番に探索し、ItemsControlを探す。
ただし、DataGridは中間にいるDataGridCellsPresenterは無視する
*while (parent != null &amp;&amp; !(parent is ItemsControl) || parent is DataGridCellsPresenter)
ItemsControlの行にあたるオブジェクトを探索履歴の後ろから検索
*var item = parentTree
Bindingしていた場合はItemsSource、違うならItemsから削除する
*IEnumerable targetList = (itemsControl.ItemsSource ?? itemsControl.Items);

*this.scopes = new[] { "https:
graph.microsoft.com.default" };

*=>; this.MessageRequest.Raise(new Notification { Title = "タイトル", Content = "メッセージ" });
このメソッドを呼び出せばダイアログを表示できる

*private static readonly StringBuilder img = new StringBuilder(@$"{exefolder}\test.png");
壁紙にしたい画像のパス

宣言時に初期化
*var intValue = 0;
サフィックスなしの場合、double型
*var doubleValue = 1.23;
double型からint型
*double doubleValue = 1.23d;
Parseを使用
*string stringValue = "10";
キャスト不可の場合、例外発生
*string stringValue = "abc";
TryParseを使用
型.TryParse(変換元, out 変換先) ： 戻り値bool
*string stringValue = "10";
*int[] array = { 1, 2, 3 };
宣言時に初期化
*var list = new List<;int>;{ 1, 2, 3 };
宣言時に初期化
要素の追加
*list.Add(4);
指定した添え字の要素を削除
*list.RemoveAt(2);
全削除
*list.Clear();
要素の取得
*var item = list[1];
等号
*a == b
不等号
*a != b
小なり
*a <; b
大なり
*a >; b
以下
*a <;= b
以上
*a >;= b
処理をスキップ
*continue;
処理を抜ける
*break;
*{~}
戻り値あり
*{~}
戻り値なし
条件式 ? 条件式True : 条件式False
*int intValue = 10;

シングルトン
*private static TestDll instance;
*{byte[,] listBuffer = new byte[5, 10];uint listCount = 0;int status = NativeMethods.GetList(listBuffer , out listCount);string[] StrBufferList = new string[listCount];for (int ii = 0; ii <; StrBufferList.Length; ii++){byte[] str = new byte[10];for (int jj = 0; jj <; str.Length; jj++){str[jj] = listBuffer[ii, jj];}StrBufferList[ii] = System.Text.Encoding.ASCII.GetString(str).TrimEnd('\0');}strList = new List<;string>;(StrBufferList);return status;}
文字列リスト取得（文字列配列の変換）
引数（char[5][10], uint32_t）の変換（文字列配列のマーシャリング）
*[DllImport(DLLName, EntryPoint = "GetList")]
引数（bool）の変換
*[DllImport(DLLName, EntryPoint = "Set1")]
引数（const char*）の変換
*[DllImport(DLLName, EntryPoint = "Set2", CharSet = CharSet.Ansi)]
引数（const void*）の変換
*[DllImport(DLLName, EntryPoint = "Set3")]
引数（構造体config）の変換（構造体のマーシャリング）
*[DllImport(DLLName, EntryPoint = "Set4")]
引数（コールバック）の変換
*[DllImport(DLLName, EntryPoint = "SetFunction")]

*if (NewWindowPos.Y + (Height * G.SR) + G.marginsize <; G.SH) NewWindowPos.Y = G.SH - (Height * G.SR);
底辺への吸着

VRM読み込み
*var bytes = File.ReadAllBytes(FilePath);
MToonをLitに置き換え
*var renderers = context.Root.GetComponentsInChildren<;Renderer>;();
通常と透過を使い分けて色とテクスチャを反映
*materials[j].color = renderers[i].materials[j].color;

*XNamespace ns= "http:
www.test";

A-Zの変換を0-25にするため1を引く
*index--;
ASCIIではAは10進数で65
*alphabet = Convert.ToChar(index % 26 + 65) + alphabet;
ASCIIではAは10進数で65
*int num = Convert.ToChar(alphabet[alphabet.Length - i - 1]) - 65;
A-Zの変換が0-25になっているため1を足して、A-Zが1-26になるようにする
*num++;

*var diff = MousePos - Input.mousePosition;*MousePos = Input.mousePosition;
マウスの移動量を取得
*var tmp = diff;*diff.x = +tmp.y;
左クリック（回転）
*var tmp = diff;*diff.x = -tmp.x;
右クリック（移動）
スクロール（拡縮というか前後）
*var scroll = Input.GetAxis("Mouse ScrollWheel");

*{public int Prop1 { get; set; }public string Prop2 { get; set; }public object Prop3 { get; set; }}
親クラス
*{// 子クラスで付け足すプロパティpublic object OriginalProp { get; set; }// 子クラスで付け足すメソッドpublic void OriginalMethod(){// Do something}}
子クラス
*public object OriginalProp { get; set; }
子クラスで付け足すプロパティ
*{// Do something}
子クラスで付け足すメソッド
*{// 子クラスのコンストラクタ内でプロパティを1つ1つ代入させるように実装する。public Child(Parent parent){this.Prop1 = parent.Prop1;this.Prop2 = parent.Prop2;this.Prop3 = parent.Prop3;}/* 以下略 （独自に足したプロパティやメソッド） */}
子クラス
*{this.Prop1 = parent.Prop1;this.Prop2 = parent.Prop2;this.Prop3 = parent.Prop3;}
子クラスのコンストラクタ内でプロパティを1つ1つ代入させるように実装する。
*{// このメソッドの中で子クラスを生成して使用する。public void SomeMethod(Parent parent){var child = new Child(parent);// Do something}}
子クラスを使用する業務ロジッククラス
*{var child = new Child(parent);// Do something}
このメソッドの中で子クラスを生成して使用する。
*{public Child(Parent parent){// 親クラスのプロパティ情報を一気に取得して使用する。List<;PropertyInfo>; props = parent.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public)?.ToList();props.ForEach(prop =>;{var propValue = prop.GetValue(parent);typeof(Child).GetProperty(prop.Name).SetValue(this, propValue);});}/* 以下略 （独自に足したプロパティやメソッド） */}
子クラス
親クラスのプロパティ情報を一気に取得して使用する。
*List<;PropertyInfo>; props = parent

*//smtp.ServerCertificateValidationCallback = (s, c, h, e) =>; true;*smtp.Connect(host, port, MailKit.Security.SecureSocketOptions.Auto);
開発用のSMTPサーバが暗号化に対応していないときは、次の行をコメントアウト
認証設定
*smtp.Authenticate("id", "password");
送信するメールを作成する
*var mail = new MimeKit.MimeMessage();
*if (!string.IsNullOrEmpty(filename))*{
添付ファイルがあった時の処理
メールを送信する
*smtp.Send(mail);
メールを送信する
*smtp.Send(mail);
SMTPサーバから切断する
*smtp.Disconnect(true);

*{protocolSerialize = new MOProtocol();protocolSerialize.msgID = "999999";protocolSerialize.Datas.Add("テスト1", "aaaaa");protocolSerialize.Datas.Add("テスト2", "bbbbb");using (var ms = new MemoryStream()){Serializer.Serialize(ms, protocolSerialize);byte[] bytes = ms.ToArray();//シリアライズ(デバッグ用途)Debug.Log(BitConverter.ToString(bytes));//デシリアライズ(デバッグ用途)var ms2 = new MemoryStream(bytes);protocolDeSerialize = Serializer.Deserialize<;MOProtocol>;(ms2);foreach (string Value in protocolDeSerialize.Datas.Values){Debug.Log(Value);}Debug.Log(protocolDeSerialize.msgID);}}
Start is called before the first frame update
シリアライズ(デバッグ用途)
*Debug.Log(BitConverter.ToString(bytes));
デシリアライズ(デバッグ用途)
*var ms2 = new MemoryStream(bytes);
*{}
Update is called once per frame

FullNameを大文字にしたgetter onlyプロパティを作る
*this.UpperFullName = this.FullName.Select(s =>; s?.ToUpper()).ToReadOnlyReactiveProperty().AddTo(_cd);

スタートアップに自身のショートカットを作成する
WshShellを作成
*var t = Type.GetTypeFromCLSID(new Guid("72C24DD5-D70A-438B-8A42-98424B88AFB8"));
ショートカット作成先（startupフォルダパス＋ショートカット名）
*var shortcutPath = Environment.GetFolderPath(Environment.SpecialFolder.StartMenu) + "\\Programs\\Startup\\Bootrecorder.lnk";
実行ファイルパス（なるべくならFromsは使いたくないのでAssenblyを利用）
*Assembly myAssembly = Assembly.GetEntryAssembly();
*object shortcut = t.InvokeMember("CreateShortcut", System.Reflection.BindingFlags.InvokeMethod, null, shell,new object[] { shortcutPath });
ショートカットを指定先に作成
フォルダを開けて見せてあげる
*System.Diagnostics.Process.Start("EXPLORER.EXE", "/select,\"" + shortcutPath + "\"");
起動開始解除。自身のショートカットをスタートアップフォルダから削除
*var shortcutPath = Environment.GetFolderPath(Environment.SpecialFolder.StartMenu) + "\\Programs\\Startup\\Bootrecorder.lnk";
フォルダを開けて見せてあげる
*var StartupFolder = Environment.GetFolderPath(Environment.SpecialFolder.StartMenu) + "\\Programs\\Startup\\";

*{ElementName = elementName,};
Create an XmlRootAttribute and set its element name and namespace.

*extendStyle ^= WS_EX_TOPMOST;
TopMostでない場合はその分の値を減算
・・・中略・・・
*}

*void Start () {capture_display = new Texture2D(Screen.width, Screen.height, TextureFormat.RGB24, false);writer = new System.IO.BinaryWriter(new System.IO.FileStream(fileName, System.IO.FileMode.Append));ary_size = Screen.width * Screen.height * 3;yxrgb = new byte[ary_size];}
Use this for initialization

wiringPiのセットアップ
*wiringPiSetupGpio();
*CallbackFunc callBackFunc = delegate () {Console.WriteLine("CallbackFunc is called !");};
GPIO をINPUTに設定する.
GPIO がONになったらコールバック関数を呼ぶ.
*ret = wiringPiISR(Tack_PIN, INT_EDGE_RISING, callBackFunc);
無限に待機する.
*Thread.Sleep(Int32.MaxValue);

*Console.WriteLine(oxet[i]);
192  168  1  0
2進数に変換した後、
00000000.00000000.00000000.00000000の表記にするため、頭に0付けていく
*for(int i = 0; i <; oxet.Length; i++)
*//最初これをそのままfor文に入れて、値が変わってうまくいかんかった。*int loopCounter = 8 - convertOxet[i].Length;
loopCounter にループ回数を代入。
最初これをそのままfor文に入れて、値が変わってうまくいかんかった。
*int loopCounter = 8 - convertOxet[i].Length;
*//Console.WriteLine("{0}", string.Join(".", convertOxet));
192.168.1.0 を 2進数表記 00000000.00000000.00000000.00000000で表示
*//Console.WriteLine("{0}", string.Join(".", convertOxet));
192.168.1.0 -&gt; 11000000.10101000.00000001.00000000
プレフィックス prefix を使って、割り当て可能ホスト数を割り出す。
ビットを2進数に直して、それをまた10進に直して、2引くでいこう
32 - 24 = 8 -&gt; 8bit = 256 -2 =&gt; 割り当て可能ホスト数 254 個 になるはず
うまくいかず。。32 - prefix はビットの数なので2進数に変換しても変になる
32 - prefix の数ぶん、１　を立てる
int bitCounter = 32 - int.Parse(prefix); 32 - 24 = 8
*string hostBit = "";

ここ、正しくは、「改行されそう！」ですが、そんなことは気にしない。
*}

*new PropertyMetadata(false, OnShowMessage)
ここの第1引数

*list.Add(new MyObjectClass());
OK!
型引数なしの方で定義されたメンバーのみ参照可能
*list.ForEach(item =>; Console.WriteLine(item.GetValueAsString()));

*using Plugin.TextToSpeech;
プラグインの導入
*var btn = new Button() { Text = "話す",FontSize=48 };
ボタンの定義
喋らせる
*CrossTextToSpeech.Current.Speak("ソシアル ディスタンス。\n2メートル以上離れてください。\nソシアル ディスタンス。\n2メートル以上離れてください。\n");

*public string UserId { get; set; }
SortKey = item_id (String)
*public string UserId { get; set; }
SortKey = item_id (String)
データの追加 (PutItem処理)

*var item = new SampleTableData
複数データの追加 (BatchWriteItem処理)

*var batchWrite = context.CreateBatchWrite<;SampleTableData>;();
データの取得 (Query処理)

*const int scanPartitionKey = 0;
データの削除 (DeleteItem処理)

*await context.DeleteAsync(queriedItems.First());
複数データの削除 (DeleteItem処理)

*var batchDelete = context.CreateBatchWrite<;SampleTableData>;();

*{if (lst_img.SelectedItem == null || lst_img.SelectedIndex <; 0) { return; }int idx = lst_img.SelectedIndex;if (idx <;= 0) { return; }object lo = lst_img.SelectedItem;lst_img.Items.Remove(lst_img.SelectedItem);lst_img.Items.Insert(idx - 1, lo);lst_img.SelectedIndex = idx - 1;}
項目をあげるボタン
*{if (lst_img.SelectedItem == null || lst_img.SelectedIndex <; 0) { return; }int idx = lst_img.SelectedIndex;if (idx + 1 >;= lst_img.Items.Count) { return; }object lo = lst_img.SelectedItem;lst_img.Items.Remove(lst_img.SelectedItem);lst_img.Items.Insert(idx + 1, lo);lst_img.SelectedIndex = idx + 1;}
項目をさげるボタン
*{if (lst_img.SelectedItem == null || lst_img.SelectedIndex <; 0) { return; }int idx = lst_img.SelectedIndex;lst_img.Items.Remove(lst_img.SelectedItem);if (lst_img.Items.Count != 0){lst_img.SelectedIndex = idx - 1;if (idx == 0) { lst_img.SelectedIndex = idx; }}}
項目を消すボタン

*psInfo.UseShellExecute = false;
シェル機能を使用しない
コマンドが成功した場合は 0、失敗した場合は -1
*ret = int.Parse(p.ExitCode.ToString());

プログラムでデータ成型
*sw.Start();
特定の生徒データ取得
*var students = _studentReposiroty.List();
クラブとかのIdを取得
*var clabIds = students.Select(x =>; x.ClabId).ToList();
IDに紐づく名称のリストを(ID, Name)のタプルで取得
*var classes = _classReposiroty.ListNameById(classIds);
*{var className = !string.IsNullOrEmpty(classes.Find(x =>; x.Item1.Equals(r.ClassId)).Item2)? classes.Find(x =>; x.Item1.Equals(r.ClassId)).Item2 : string.Empty;var clabName = !string.IsNullOrEmpty(clabs.Find(x =>; x.Item1.Equals(r.ClabId)).Item2)? clabs.Find(x =>; x.Item1.Equals(r.ClabId)).Item2 : string.Empty;var userName = !string.IsNullOrEmpty(users.Find(x =>; x.Item1.Equals(r.CreatedByUserId)).Item2)? users.Find(x =>; x.Item1.Equals(r.CreatedByUserId)).Item2 : string.Empty;var testViewModel = new TestViewModel{Id = r.Id,Name = r.Name,ClassName = className,ClabName = clabName,CreatedByUserName = userName,Age = r.Age};viewList.Add(testViewModel);});
データ内にあるIDをNameに置き換える。対応するものがなかったら空文字。

*drawContent.DrawEllipse(Brushes.Yellow, new Pen(Brushes.Green, 3), new Point(50, 50), 10, 10);
丸を描く
いろいろ書いたDrawingVisualを、RenderTargetBitmap(BitmapSourceの子クラス)に取り込む
*var bmp = new RenderTargetBitmap((int)image.Width, (int)image.Height, 96, 96, PixelFormats.Pbgra32);
画面に表示もできる
*MyImage.Source = bmp;
そいつをファイルに保存
*var encoder = new JpegBitmapEncoder();
元になる画像を読み込む
*var uri = new Uri(@"input.jpg", UriKind.Relative);
画像を書いて、その上にテキストを書く
*drawContent.DrawImage(image, new System.Windows.Rect(0, 0, image.PixelWidth, image.PixelHeight));
追加でいろんなものを書き込む
drawContent.DrawRectangle(Brushes.Red, new Pen(Brushes.Black, 3), new Rect(0, 0, 200, 200));     四角を描く
drawContent.DrawEllipse(Brushes.Yellow, new Pen(Brushes.Green, 3), new Point(50, 50), 10, 10);   丸を描く
*}
色々書き込んだものを使って、DrawingImageをつくって画面表示にセット
*MyImage.Source = new DrawingImage(drawingGroup);

*string rKeyName = @"SYSTEM\CurrentControlSet\Control\TimeZoneInformation";*// 取得処理を行う対象となるレジストリの値の名前
操作するレジストリ・キーの名前
取得処理を行う対象となるレジストリの値の名前
*string rGetValueName = "DynamicDaylightTimeDisabled";
*{// レジストリ・キーのパスを指定してレジストリを開くRegistryKey rKey = Registry.LocalMachine.OpenSubKey(rKeyName);// レジストリの値を取得Int32 location = (Int32)rKey.GetValue(rGetValueName);// 開いたレジストリを閉じるrKey.Close();// コンソールに取得したレジストリの値を表示Console.WriteLine("夏時間に合わせて自動的に調整しない：" +　location);Console.ReadLine();}
レジストリの取得
レジストリ・キーのパスを指定してレジストリを開く
*RegistryKey rKey = Registry.LocalMachine.OpenSubKey(rKeyName);
レジストリの値を取得
*Int32 location = (Int32)rKey.GetValue(rGetValueName);
開いたレジストリを閉じる
*rKey.Close();
コンソールに取得したレジストリの値を表示
*Console.WriteLine("夏時間に合わせて自動的に調整しない：" +　location);
レジストリ・キーまたは値が存在しない
*Console.WriteLine("レジストリ［" + rKeyName   + "］の［" + rGetValueName + "］がありません！");

*{services.AddDbContext<;ApplicationDbContext>;(options =>;options.UseMySql(Configuration.GetConnectionString("DefaultConnection")));services.AddDefaultIdentity<;IdentityUser>;(options =>; options.SignIn.RequireConfirmedAccount = false).AddEntityFrameworkStores<;ApplicationDbContext>;();services.AddControllersWithViews();services.AddRazorPages();}
This method gets called by the runtime. Use this method to add services to the container.
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();app.UseDatabaseErrorPage();}else{app.UseExceptionHandler("/Home/Error");// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.app.UseHsts();}app.UseHttpsRedirection();app.UseStaticFiles();app.UseRouting();app.UseAuthentication();app.UseAuthorization();app.UseEndpoints(endpoints =>;{endpoints.MapControllerRoute(name: "default",pattern: "{controller=Home}/{action=Index}/{id?}");endpoints.MapRazorPages();});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*There are no external authentication services configured. See <;a href="https:
go.microsoft.comfwlink?LinkID=532715"&gt;this article&lt;a&gt;

*| RigidbodyConstraints.FreezePositionY;
PositionのYのみオン
*{rb.constraints = RigidbodyConstraints.FreezeRotation| RigidbodyConstraints.FreezePositionY;}
collisionに接触している場合はRotationは全てオン、PositionはY軸のみオンにする。
*{rb.constraints = RigidbodyConstraints.FreezeRotation;}
collisionに接触してない時はPositionのY軸はオフ。Rotationは全てオンのまま。

音声認識用定数定義
*private const int VOICE = 10;
MainPageの開始ボタンか押された場合
*Xamarin.Forms.MessagingCenter.Subscribe<;Object, string>;(this, "StartVoice", StartVoice);
音声認識テキストをMainPageに送る
*Xamarin.Forms.MessagingCenter.Send<;Object, string>;(this, "EndOfVoice", txt);
*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer
音声認識の終了したメッセージを受け取る
*MessagingCenter.Subscribe<;Object, string>;(this, "EndOfVoice", EndOfVoice);
音声開始コマンドをMainActivityに送信
*MessagingCenter.Send<;Object, string>;(this, "StartVoice", "StartVoice");

*}
end MyClass

*double accelSpeed = 1;
加速速度
ボールの移動
加速判定
int x = int.Parse(keikaTime.Elapsed.ToString().Substring(9, 3)); リアルタイムのコンマ3桁を取得
if (Form4.accelFrag == true &amp;&amp; x/100 == 1) 0.1秒毎にスピードUP
*{
倍率設定
*double bairitsu = ((Form2.mode + 1) /10 * 2) + 1;
加速ONで倍率2倍
*bairitsu *= 2;

キャンバスの背景色を設定する。
*g.FillRectangle(this.backgroundColor, g.VisibleClipBounds);
縦・横の格子柄の繰り返し回数を求める。
繰り返し回数に余りが出る場合は格子柄がはみ出る形になるが、キャンバス外は描画されないので仕上がりの画像には影響しない。
*double widthCount = (double)this.bmp.Width / (double)this.gridSize;
*g.FillRectangle(this.foregroundColor, (i * this.gridSize), (j * this.gridSize), this.gridSize, this.gridSize);*}
前景色で塗りつぶされた長方形（格子柄）を描画する。
画像をPNG形式で保存する。
*bmp.Save(filePath, System.Drawing.Imaging.ImageFormat.Png);

*Console.WriteLine("key2={0}", key1Item["key2"]);
value1, value2

*private void Set(ILogger logger){Logger = logger;}
セッターがないのでこれは怒られる

*string[][] teams = {
2次元配列

改行を追加
*paragraph.Inlines.Add(new LineBreak());
*{ChangeType.Deleted =>; (Colors.Pink, "💣| "),ChangeType.Inserted =>; (Colors.GreenYellow, "➕| "),ChangeType.Imaginary =>; (Colors.SkyBlue, "📌| "),ChangeType.Modified =>; (Colors.Yellow, "✏| "),_ =>; (Colors.Transparent, "🔏| "),};
差分タイプによって、行頭の文字列内容と背景色を決定
見やすいように少し半透明にしておく
*color.A = 0xC0;
*if (lineVM.Type != ChangeType.Modified)*{
ChangeType.Modified以外は行全体で同じ書式
*{Text = preFix,Background = baseColorBrush,};
ChangeType.Modifiedだったら変更された部分だけハイライトしたいのでSubPieceからいろいろやる

山札の生成
*Deck_Prepare();
*for (int mark_i = 1; mark_i <;= 4; mark_i++)*{
Cardを生成して山札とする(52枚)
山札をシャッフルする
*Shuffle();
山札をシャッフルする
*cards = cards.OrderBy(a =>; Guid.NewGuid()).ToList();
必ず+1させる。(次のカードを引くため)
*_drawn_Card_Number++;
マーク
*private int _mark;
*if (no >; 10)*{
J(11)、Q(12)、K(13)は10として計算する
*if (MyHand.Count(x =>; x.No == 1) == 0)*{
手札にA(エース)が含まれない場合は終了
合計値計算用
*var tmpVal = 0;
A(エース)以外を抽出して計算
*var otherA_MyHand = MyHand.Where(x  =>; x.No != 1);
A(エース)を抽出して計算
*var onlyA_MyHand = MyHand.Where(x =>; x.No ==1);
バーストしなければA(エース)を[11」として計算
バーストする場合は、A(エース)を「1」として計算
*if ((tmpVal + 11) >; 21 )
合計値を更新する
*TotalValue = tmpVal;
プレイヤー番号の割り当て
*playerNumber = num;
バーストしていない間(isBusted=false)はループを続行
プレイヤーがスタンドした場合はループを終了
*while (! isBusted)
*if (! Game_Controller.Confilm(Properties.Resource.Msg_Stand))*{
カードを引くか尋ねる(false:カードを引くのをやめる)
カードを手札に加える
*var card = cards.Hit_Card();
バーストした
*Console.WriteLine(Properties.Resource.MSg_Busted);
*if (MyHand.Count != 2)*{
ディーラーの初期手札の2枚目を表示しない考慮
ディーラーの2枚目のカードをオープンする
*Console.WriteLine(Properties.Resource.Msg_Dealers_2nd, MyHand[1].ToString());
*while (TotalValue <; Boarder_TotalValue)*{
自分の手札の合計値が17以上になるまでカードを引く
カードを手札に加える
*var card = cards.Hit_Card();
バーストした
*Console.WriteLine(Properties.Resource.MSg_Busted);
ディーラー
*private IPlayer _dealer;
山札
*private Deck cards;
参加プレイヤー管理リスト
*private List<;IPlayer>; players;
*{// 参加プレイヤー数を取得するvar entryNum = Get_EntryNumber_Player();// 初期化Initialize(entryNum);// 最初の手札を配るDeal_Card();// プレイヤーのターンforeach (var player in players){player.MyTurn(cards);}// ディーラーのターン_dealer.MyTurn(cards);// 判定Judge();}
ゲームを開始するメソッド
参加プレイヤー数を取得する
*var entryNum = Get_EntryNumber_Player();
初期化
*Initialize(entryNum);
最初の手札を配る
*Deal_Card();
*foreach (var player in players)*{
プレイヤーのターン
ディーラーのターン
*_dealer.MyTurn(cards);
判定
*Judge();
*for (int i = 1; i <;= entryNum; i++)*{
プレイヤーをリストで管理
*for (int i = 1; i <;= 2; i++)*{
カードを引いて画面に表示する
プレイヤーとディーラーの両方がバースト　＝＞　引き分け
プレイヤーがバースト　＝＞　ディーラーの勝ち
ディーラーがバースト　＝＞　プレイヤーの勝ち
プレイヤーの得点がディーラーより大きい　＝＞　プレイヤーの勝ち
ディーラーの得点がプレイヤーより大きい　＝＞　ディーラーの勝ち
得点が同じ　＝＞　引き分け
プレイヤーごとにディーラーとの勝敗を表示
*foreach (var player in players)
A(エース)を考慮して再計算
*player.BestSelect_TotalValue();
ここまで来たら同点
*Console.WriteLine(Properties.Resource.Msg_Draw);

*var fullName2 = vm.FullName;
新しい FirstName と LastName 用の ReactiveProperty が別途作られて、それを加工した結果を格納する ReadOnlyReactivePropertySlim が作られる
値を設定しても
*f1.Value = "Kazuki";
別インスタンスなので当然同期されない
Console.WriteLine(f2.Value);  空文字
Console.WriteLine(l2.Value);  空文字
FullName もそうね
Console.WriteLine(fullName1.Value);  空白
Console.WriteLine(fullName2.Value);  空白
もちろん VM のもそう
Console.WriteLine(vm.FirstName.Value);  空文字
Console.WriteLine(vm.LastName.Value);  空文字
Console.WriteLine(vm.FullName.Value);  空白
*,,,

*markdownLink = (format != null) ? "![" + markdownLink : "[" + markdownLink;*Clipboard.SetDataObject(markdownLink, true);
画像形式とそれ以外でフォーマットを変える

サーバーのエンドポイント
*public IPEndPoint ServerEndPoint;
ブロードキャストのエンドポイント
*public IPEndPoint BroadCastEndPoint;
スレッド待機用
*private ManualResetEvent AllDone = new ManualResetEvent(false);
送受信文字列エンコード
*private Encoding enc = Encoding.UTF8;
*{// IPアドレス取得string hostname = Dns.GetHostName();var address = Dns.GetHostAddresses(hostname);foreach (var item in address){if (item.AddressFamily == AddressFamily.InterNetwork &amp;&amp; item.ToString().StartsWith("10.")){this.Address = item.ToString();Console.WriteLine($" サーバIPアドレス        ：{this.Address}");}}// サブネットマスクの取得var info = NetworkInterface.GetAllNetworkInterfaces();foreach (var item in info){if (item.OperationalStatus == OperationalStatus.Up &amp;&amp;item.NetworkInterfaceType != NetworkInterfaceType.Loopback &amp;&amp;item.NetworkInterfaceType != NetworkInterfaceType.Tunnel){var ipp = item.GetIPProperties();if (ipp != null){foreach (var ip in ipp.UnicastAddresses){if (this.Address == ip.Address.ToString()){this.SubnetMask = ip.IPv4Mask.ToString();Console.WriteLine($" サーバサブネットマスク  ：{this.SubnetMask}");}}}}}this.Port = port;Console.WriteLine($" サーバ待機ポート        ：{this.Port}");// ブロードキャストアドレスの取得byte[] ipb = new byte[4];var ips = this.Address.Split('.');var masks = this.SubnetMask.Split('.');for (int i = 0; i <; 4; i++){ipb[i] = (byte)(byte.Parse(ips[i]) | ~byte.Parse(masks[i]));}this.BroadCast = $"{ipb[0].ToString()}.{ipb[1].ToString()}.{ipb[2].ToString()}.{ipb[3].ToString()}";Console.WriteLine($" ブロードキャストアドレス：{this.BroadCast}\n");this.ServerEndPoint = new IPEndPoint(IPAddress.Parse(this.Address), Convert.ToInt32(this.Port));this.BroadCastEndPoint = new IPEndPoint(IPAddress.Parse(this.BroadCast), this.SENDPORT);}
コンストラクタ
IPアドレス取得
*string hostname = Dns.GetHostName();
サブネットマスクの取得
*var info = NetworkInterface.GetAllNetworkInterfaces();
ブロードキャストアドレスの取得
*byte[] ipb = new byte[4];
*{using(var listenerSocket = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp)){// ソケットをアドレスにバインドするlistenerSocket.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.ReuseAddress,true);listenerSocket.Bind(this.ServerEndPoint);// 接続待機開始listenerSocket.Listen(10);WriteLog($"接続待機開始", $"{listenerSocket.LocalEndPoint.ToString()}");// 接続待機のループwhile (true){AllDone.Reset();listenerSocket.BeginAccept(new AsyncCallback(AcceptCallback), listenerSocket);// 接続があるまでスレッドを待機させるAllDone.WaitOne();}}}
サーバー起動
ソケットをアドレスにバインドする
*listenerSocket.SetSocketOption(SocketOptionLevel.Socket,
*WriteLog($"接続待機開始", $"{listenerSocket.LocalEndPoint.ToString()}");
接続待機開始
*while (true)*{
接続待機のループ
接続があるまでスレッドを待機させる
*AllDone.WaitOne();
*{// 待機スレッドが進行するようにシグナルをセットAllDone.Set();// ソケットを取得var listenerSocket = asyncResult.AsyncState as Socket;var clientSocket = listenerSocket.EndAccept(asyncResult);// 接続中のクライアントを追加WriteLog($"接続確認", $"{clientSocket.RemoteEndPoint}");// StateObjectを作成var state = new StateObject();state.ClientSocket = clientSocket;// 受信時のコードバック処理を設定clientSocket.BeginReceive(state.Buffer,0,StateObject.BufferSize,0,new AsyncCallback(ReceiveCallback),state);}
接続受付時のコールバック処理
待機スレッドが進行するようにシグナルをセット
*AllDone.Set();
ソケットを取得
*var listenerSocket = asyncResult.AsyncState as Socket;
*WriteLog($"接続確認", $"{clientSocket.RemoteEndPoint}");
接続中のクライアントを追加
StateObjectを作成
*var state = new StateObject();
受信時のコードバック処理を設定
*clientSocket.BeginReceive(state.Buffer,
*{// StateObjectとクライアントソケットを取得var state = asyncResult.AsyncState as StateObject;var clientSocket = state.ClientSocket;try{// クライアントソケットから受信データを取得終了int bytes = clientSocket.EndReceive(asyncResult);string category = $"データ受信[{bytes,2}バイト]";string detail;if (bytes >; 0){// 受信した文字列を表示var content = enc.GetString(state.Buffer, 0, bytes);detail = $"\"{content}\"";Regex reg = new Regex("^([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])$");if (reg.IsMatch(content)){detail += $" MACアドレスデータを受信しました。";WriteLog(category, detail);byte[] sendBytes = new byte[HEADLEN + MACLEN * MACCOUNT];int i;// ヘッダデータを生成for (i = 0; i <; HEADLEN; i++){sendBytes[i] = 0xFF;}// マジックパケットを生成foreach (Match m in reg.Matches(content)){for (i = 0; i <; MACLEN; i++){byte convert = Convert.ToByte(m.Groups[i + 1].Value, 16);for (int j = 0; j <; MACCOUNT; j++){sendBytes[HEADLEN + MACLEN * j + i] = convert;}}}UdpClient udp = new UdpClient();// マジックパケットを送信するudp.Send(sendBytes, sendBytes.Length, this.BroadCastEndPoint);// ソケットクローズudp.Close();WriteLog($"データ送信", $"マジックパケットを送信しました。");}else{detail += $" 不明なデータを破棄しました。";WriteLog(category, detail);}// 受信時のコードバック処理を再設定clientSocket.BeginReceive(state.Buffer,0,StateObject.BufferSize,0,new AsyncCallback(ReceiveCallback),state);}else{// 0バイトデータの受信時は、切断されたときclientSocket.Close();WriteLog(category, $"通信を切断しました。");}}catch (SocketException e){if (e.NativeErrorCode.Equals(10054)){// 既存の接続が、リモート ホストによって強制的に切断されました// 保持しているクライアントの情報をクリアするclientSocket.Close();WriteLog($"強制切断", $"クライアントが強制切断しました。");}else{WriteLog($"強制切断", $"Error Code {e.NativeErrorCode} : {e.Message}");}}catch (Exception ex){WriteLog($"例外発生", $"{ex.Message}");}}
受信時のコードバック処理
StateObjectとクライアントソケットを取得
*var state = asyncResult.AsyncState as StateObject;
*string category = $"データ受信[{bytes,2}バイト]";
クライアントソケットから受信データを取得終了
*detail = $"\"{content}\"";
受信した文字列を表示
*for (i = 0; i <; HEADLEN; i++)*{
ヘッダデータを生成
*foreach (Match m in reg.Matches(content))*{
マジックパケットを生成
マジックパケットを送信する
*udp.Send(sendBytes, sendBytes.Length, this.BroadCastEndPoint);
ソケットクローズ
*udp.Close();
受信時のコードバック処理を再設定
*clientSocket.BeginReceive(state.Buffer,
0バイトデータの受信時は、切断されたとき
*clientSocket.Close();
既存の接続が、リモート ホストによって強制的に切断されました
保持しているクライアントの情報をクリアする
*clientSocket.Close();
*{public Socket ClientSocket { get; set; }public const int BufferSize = 1024;public byte[] Buffer { get; } = new byte[BufferSize];}
接続されたクライアントの情報を格納するクラス

*static public devPlc devPlc;
PLC制御のパッケージ
PLCとの通信を確立する
*devPlc = new devPlc(axActUtlType1, 1);
名前付きパイプのバインディング
const string addr = "net.pipe:localhost/wcfInterProcessComm";
*var binding = new NetNamedPipeBinding(NetNamedPipeSecurityMode.None);
10日間クライアントからのリクエストがなくてもタイムアウトしない
*binding.ReceiveTimeout = new TimeSpan(240, 0, 0);
エンドポイントを作成
*svc = new ServiceHost(typeof(Host));
サービスホストをスタート
*svc.Open();
名前付きパイプのバインディング
const string addr = "net.pipe:localhost/wcfInterProcessComm";
*var binding = new NetNamedPipeBinding(NetNamedPipeSecurityMode.None);
チャネルファクトリを作る
*ChannelFactory<;IHost>; factory
サービスコントラクトのインターフェースにチャネルを割り当てると、
*host = factory.CreateChannel();
これ以降、サーバー側のサービスコントラクトがローカルなクラスのように扱える
*host.grabPlc();

Fontという名のフィールドがすでにあるとする
適当なBitmapを生成
*var bitmap = new Bitmap(16, 16);
適当なGraphicsを生成
*var graphics = Graphics.FromImage(bitmap);
謎の空白付きの文字列のサイズを計測。
*var graphicsSize = graphics.MeasureString("成就した恋ほど語るに値しないものはない。", Font);
ちゃんとした文字列のサイズを計測。
*var trueGraphicsSize = graphics.MeasureString("成就した恋ほど語るに値しないものはない。", Font, (int)graphicsSize.Width, StringFormat.GenericTypographic);

*panel.Controls.Remove(c);
フォームに登録されたコントロールのオブジェクトを消す
*{Console.WriteLine("items1_Click");Console.WriteLine();}
追加したコンソールのメニューアイテム１番を選択した時のイベントハンドラ
*{Console.WriteLine("items2_Click");Console.WriteLine();}
追加したコンソールのメニューアイテム２番を選択した時のイベントハンドラ

１．コントロール（panel）上で左クリックしたときにコンテキストメニューを開き、コンテキストメニューを開いた時にあったマウスの先端に動的に新たにコントロールを作る。
参考資料
https:docs.microsoft.com/ja-jp/dotnet/api/system.windows.forms.contextmenustrip?view=netframework-4.8
https:dobon.net/vb/dotnet/control/cmclickpoint.html
*using System;
panelを左クリックしたときのContextMenuStripコントロールの宣言
*private ContextMenuStrip contextMenuStripOnPanel;
panelのコンテキストメニューを宣言とコンテキストメニューを開いた時のイベントハンドラーの定義
*contextMenuStripOnPanel = new ContextMenuStrip();
panelの上で、右クリックをした時のコンテキストメニューを開くためのデリゲードへの登録
contextMenuStripOnPanel.Opening += new CancelEventHandler(cms_Opening);  必ずForm3()で宣言する
*panel = new Panel();
*{ContextMenuStrip menuOnPanel = (ContextMenuStrip)sender;// マウスカーソルの位置を画面座標で取得Point mp = MousePosition;cp = menuOnPanel.SourceControl.PointToClient(mp);Console.WriteLine(cp);// コンテキストメニューの表示contextMenuStripOnPanel.Items.Clear();contextMenuStripOnPanel.Items.Add("ピクチャーボックスを追加");contextMenuStripOnPanel.Items.Add("テキストボックスを追加");contextMenuStripOnPanel.Items.Add("ラベルを追加");contextMenuStripOnPanel.Items[0].Click += PanelMenuItems0_Click;contextMenuStripOnPanel.Items[1].Click += PanelMenuItems1_Click;contextMenuStripOnPanel.Items[2].Click += PanelMenuItems2_Click;// キャンセルをfalseに設定します。(イベントをキャンセルするかどうかの設定）// 空のエントリに基づいてtrueに最適化されます。e.Cancel = false;   //trueにするとコンテキスメニューが表示されない}
panel上で右クリックをした時の処理
マウスカーソルの位置を画面座標で取得
*Point mp = MousePosition;
コンテキストメニューの表示
*contextMenuStripOnPanel.Items.Clear();
キャンセルをfalseに設定します。(イベントをキャンセルするかどうかの設定）
空のエントリに基づいてtrueに最適化されます。
e.Cancel = false;   trueにするとコンテキスメニューが表示されない
*}
*{PictureBox pictureBox = new PictureBox();pictureBox.Location = cp;pictureBox.BackColor = Color.White;pictureBox.Size = new Size(50, 50);pictureBox.Image = Image.FromFile("testPicture.bmp");pictureBox.Parent = panel;}
PictureBoxをつくるイベントハンドラ
*{TextBox textBox = new TextBox();textBox.Location = cp;textBox.BorderStyle = BorderStyle.FixedSingle;textBox.Text = "これはテキストボックスです。";textBox.Multiline=true;textBox.Size = new Size(100, 100);textBox.BackColor = Color.Yellow;textBox.Parent = panel;}
テキストボックスを作るイベントハンドラー
*{Label label = new Label();label.Location = cp;label.BorderStyle = BorderStyle.FixedSingle;label.BackColor = Color.Pink;label.Text = "これはラベルです。";label.Parent = panel;}
ラベルを作るイベントハンドラー

FlowDocumentは1つのRichTextBoxにしか設定できない。
すでに他のRichTextBoxに所属しているなら、コピーを作成・設定する
*richTextBox.Document = attachedDocument.Parent == null
もとのFlowDocumentをMemoryStream上に一度Serializeする
*var sourceRange = new TextRange(sourceDoc.ContentStart, sourceDoc.ContentEnd);
新しくFlowDocumentを作成
*var copyDoc = new FlowDocument();
MemoryStreamからDesirializeして書き込む
*copyRange.Load(stream, DataFormats.XamlPackage);

*private Vector3 StagePos;
StagePos変数を設定

シーン読み込み、アニメーション読み込みなどなど
*}

*private Vector3 offset;
カメラとの距離

*var sendBuffer = new byte[] { 0xff, 0xca, 0x00, 0x00, 0x00 };
IDmを取得するコマンド
受信データからIDmを抽出
*cardId = BitConverter.ToString(recvBuffer, 0, pcbRecvLength - 2);
ここで処理を行う
*}

nullの場合エラーメッセージ出力
*Debug.Assert(CreateButtonObj, "CreateButtonObj が null");
Buttonコンポーネントにクリックイベント追加
*CreateButtonObj.GetComponent<;Button>;().onClick.AddListener(OnClickCreateButton);
Resorcesフォルダからプレハブを取得
*GameObject resourceButtonObj = Resources.Load("Button") as GameObject;
不要になったらリソースは開放する
Resources.UnloadUnusedAssets();
コールバック処理
*System.Func<;GameObject, int>; callBack;
自身のオブジェクト取得
*GameObject obj = this.gameObject;
オブジェクトを検索して取得（非アクティブオブジェクトは検索できない）
GameObject.Findは処理が重いのでなるべく使わないこと
*GameObject canvas = GameObject.Find("Canvas");
*GameObject rootObj = this.transform.root.gameObject;*// シーンが移動しても消えないオブジェクトを登録
ルートオブジェクト取得
シーンが移動しても消えないオブジェクトを登録
シーンが呼ばれるごとに増えてしまうため登録するオブジェクトはシングルトンにする
*DontDestroyOnLoad(rootObj);
"cube"タグのついたオブジェクトをすべて格納
*GameObject[] cubes = GameObject.FindGameObjectsWithTag("cube");
*foreach (GameObject cube in cubes) {*Destroy(cube);
"cube"タグのついたオブジェクトをすべて削除
*objChild = this.gameObject.transform.Find("Viewport/Content").gameObject;*// 子オブジェクトの数取得
孫オブジェクトを検索して取得（階層を/で指定）（非アクティブオブジェクトも検索可能）
*int a = objChild.transform.childCount;*// 子オブジェクトを複数取得
子オブジェクトの数取得
子オブジェクトを複数取得
*int number = 0;
Buttonコンポーネントの取得
*Button button = child.GetComponent<;Button>;();
Buttonコンポーネントにクリックイベント追加（引数あり）
*button.onClick.AddListener(() =>; OnClickButton(child));
Buttonのテキスト変更（番号順）
*number++;
*{// Find系の処理は重いのでUpdate内では使わないこと// 現在選択中のオブジェクト（SetSelectedGameObject で変更できる）Debug.Log(UnityEngine.EventSystems.EventSystem.current.currentSelectedGameObject);// プラットフォームがアンドロイドかチェックif (Application.platform == RuntimePlatform.Android){// バックボタンのチェックif (Input.GetKeyDown(KeyCode.Escape)){// アプリケーション終了Application.Quit();return;}}}
Update is called once per frame
Find系の処理は重いのでUpdate内では使わないこと
現在選択中のオブジェクト（SetSelectedGameObject で変更できる）
*Debug.Log(UnityEngine.EventSystems.EventSystem.current.currentSelectedGameObject);
*if (Application.platform == RuntimePlatform.Android)*{
プラットフォームがアンドロイドかチェック
*if (Input.GetKeyDown(KeyCode.Escape))*{
バックボタンのチェック
アプリケーション終了
*Application.Quit();
プレハブを元にオブジェクトを生成する
*GameObject instance = Instantiate(resourceButtonObj, new Vector3(0.0f, 0.0f, 0.0f), Quaternion.identity);
Buttonの色を変える
*instance.GetComponent<;Image>;().color = new Color32(255, 0, 0, 128);
*instance.transform.SetParent(objChild.transform);*}
生成したオブジェクトを子として登録
メソッドを呼び出す（引数は１つだけ持たせられるが戻り値は持てない）
参照関係がわからなくなるためなるべく使用しない（非アクティブなオブジェクトにも使えない）
*SendMessage("OnClickCreateButton");
オブジェクトを破棄
*Destroy(button);
*int index = buttonObj.transform.GetSiblingIndex();*// 押されたボタンの名前出力
同階層におけるオブジェクトの順序取得
押されたボタンの名前出力
*Debug.Log(buttonObj.name + " index : " + index);
*GameObject parentObj = buttonObj.transform.parent.gameObject;*// 子オブジェクトの数取得
親オブジェクトを取得
*int childMax = parentObj.transform.childCount;*// Buttonオブジェクトの順序を一番下に移動（セットした時点で移動する）
子オブジェクトの数取得
*// buttonObj.transform.SetAsLastSibling(); でもいい*buttonObj.transform.SetSiblingIndex(childMax - 1);
Buttonオブジェクトの順序を一番下に移動（セットした時点で移動する）
*buttonObj.transform.SetSiblingIndex(childMax - 1);*}
buttonObj.transform.SetAsLastSibling(); でもいい
*// buttonObj.transform.SetAsFirstSibling(); でもいい*buttonObj.transform.SetSiblingIndex(0);
Buttonオブジェクトの順序を一番上に移動（セットした時点で移動する）
*buttonObj.transform.SetSiblingIndex(0);*}
buttonObj.transform.SetAsFirstSibling(); でもいい
スクロールバーをコルーチンを使って移動
*StartCoroutine(ScrollDelay(index));
*GameObject obj = this.gameObject.transform.Find("Scrollbar Vertical").gameObject;*// Scrollbarコンポーネント取得
子オブジェクトを検索して取得
Scrollbarコンポーネント取得
*Scrollbar bar = obj.GetComponent<;Scrollbar>;();
*while (true)*{
コルーチンの内容
0.01秒処理を待つ
*yield return new WaitForSeconds(0.01f);
1フレーム待つ（フレーム時間によって時間が変わるので注意）
yield return null;
*if (index <; 10)
スクロールバーを徐々に1番下へ移動
*bar.value -= 0.2f;
スクロールバーを徐々に1番上へ移動
*bar.value += 0.2f;
コルーチン終了
*yield break;
ブラウザでwebページを開く
*Application.OpenURL(url);
*{WWW www = new WWW(url);yield return www;RawImage img = GameObject.Find("WebRawImage").GetComponent<;RawImage>;();img.texture = www.texture;}
イメージファイルをダウンロードしてRawImageに表示
PlayerHPデータを保存
*PlayerPrefs.SetInt("Player", save.PlayerHP);
セーブデータをJSON形式に変換
*string json = JsonUtility.ToJson(save);
セーブデータを保存
*PlayerPrefs.SetString("SaveData", json);
セーブデータを読み込み
*string json = PlayerPrefs.GetString("SaveData");
読み込んだセーブデータをsaveに上書き
*JsonUtility.FromJsonOverwrite(json, save);
セーブデータを削除
*PlayerPrefs.DeleteKey("SaveData");
エラーログをファイルに出力
アプリ終了
*#if UNITY_EDITOR

*#elif __ANDROID__*// Android 固有処理
Windows 固有処理
*#elif __IOS__*// iOS 固有処理
Android 固有処理
*#elif __WASM__*// WebAssembly 固有処理
iOS 固有処理
*#endif*,,,
WebAssembly 固有処理
*public NativeView View { get; set; }
共通の型名で書けるようになる
Shared プロジェクトに定義
*using System.Diagnostics;
Droid プロジェクトに定義
*using Android.App;
iOS プロジェクトに定義
*using UIKit;
UWP プロジェクトに定義
*using System.Linq;
*if (!rootFrame.CanGoBack)*{
戻れない場合は何もしない
戻れる場合はフレームの GoBack メソッドを呼んで
*rootFrame.GoBack();
戻るボタンを処理したことを通知する
*args.Handled = true;

textBlock に添付プロパティを設定
*Canvas.SetTop(textBlock, 10);
*{Text = "Hello world",}.Row(1).Column(2).ColumnSpan(2);
Label は Xamarin.Forms で文字列を表示するためのコントロール

*public class MainPageViewModel : INotifyPropertyChanged
インターフェースを実装
プロパティに変更があったときに発行されるイベント
*public event PropertyChangedEventHandler PropertyChanged;
プロパティの値が変わったことを PropertyChanged イベントで外部に通知
*PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Message)));

*#pragma warning restore Uno0001
Uno type or member is not implemented

格納する変数
*public GameObject Player;
*transform.position = new Vector3(Pos.x + CameraX, Pos.y + CameraY, Pos.z + CameraZ);*}
カメラとプレイヤーの位置を同じにする

*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer
*{public object Tag{get { return (object)GetValue(TagProperty); }set { SetValue(TagProperty, value); }}public static readonly BindableProperty TagProperty =BindableProperty.Create(nameof(Tag), typeof(object), typeof(Mbutton), null);}
Button に　Tag プロパティを追加
*{"ManyButtons.Images.applications.ico" ,"ManyButtons.Images.audio_file.ico" ,"ManyButtons.Images.back.ico" ,"ManyButtons.Images.button_cancel.ico" ,"ManyButtons.Images.button_ok.ico" ,"ManyButtons.Images.cd.ico" ,"ManyButtons.Images.cdimage.ico" ,"ManyButtons.Images.cdr.ico" ,"ManyButtons.Images.clock.ico" ,"ManyButtons.Images.computer.ico" ,"ManyButtons.Images.configuration_settings.ico" ,"ManyButtons.Images.control_panel.ico" ,"ManyButtons.Images.desktop.ico" ,"ManyButtons.Images.down.ico" ,"ManyButtons.Images.exec.ico" ,"ManyButtons.Images.favorits.ico" ,};
Imagesのファイル定義
*{var g = new Grid() {HeightRequest=400 };var k = 0;for(var i = 0; i <; 4; i++){for (var j = 0; j <; 4; j++){if (k <; flist.Count){var b = new Mbutton(){Text = $"{k}",Tag = k,ImageSource = ImageSource.FromResource(flist[k]),};b.Clicked += B_Clicked;g.Children.Add(b, j, i);k++;}}}//余白部の作成var l=new Label();g.Children.Add(l, 0, 8);Content = g;}
16個のボタンを作成してグリットに配置
余白部の作成
*var l=new Label();
*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer
*{public object Tag{get { return (object)GetValue(TagProperty); }set { SetValue(TagProperty, value); }}public static readonly BindableProperty TagProperty =BindableProperty.Create(nameof(Tag), typeof(object), typeof(Mbutton), null);}
Button に　Tag プロパティを追加
*{"ManyButtons.Images.applications.ico" ,"ManyButtons.Images.audio_file.ico" ,"ManyButtons.Images.back.ico" ,"ManyButtons.Images.button_cancel.ico" ,"ManyButtons.Images.button_ok.ico" ,"ManyButtons.Images.cd.ico" ,"ManyButtons.Images.cdimage.ico" ,"ManyButtons.Images.cdr.ico" ,"ManyButtons.Images.clock.ico" ,"ManyButtons.Images.computer.ico" ,"ManyButtons.Images.configuration_settings.ico" ,"ManyButtons.Images.control_panel.ico" ,"ManyButtons.Images.desktop.ico" ,"ManyButtons.Images.down.ico" ,"ManyButtons.Images.exec.ico" ,"ManyButtons.Images.favorits.ico" ,};
Imagesのファイル定義
*{var g = new Grid() {HeightRequest=400 };var k = 0;for(var i = 0; i <; 4; i++){for (var j = 0; j <; 4; j++){if (k <; flist.Count){var b = new Mbutton(){Text = $"{k}",Tag = k,ImageSource = ImageSource.FromResource(flist[k]),};b.Clicked += B_Clicked1;g.Children.Add(b, j, i);k++;}}}//余白部の作成var l=new Label();g.Children.Add(l, 0, 8);Content = g;}
16個のボタンを作成してグリットに配置
余白部の作成
*var l=new Label();

*this.listener.Prefixes.Add(String.Format("http:
+:{0}{1}", Settings.Default.API_PORT, Settings.Default.API_PATH));

*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer
*{public object Tag{get { return (object)GetValue(TagProperty); }set { SetValue(TagProperty, value); }}public static readonly BindableProperty TagProperty =BindableProperty.Create(nameof(Tag), typeof(object), typeof(Mbutton), null);}
Button に　Tag プロパティを追加
*{var g = new Grid() {HeightRequest=400 };var k = 0;for(var i = 0; i <; 4; i++){for (var j = 0; j <; 4; j++){var b = new Mbutton() { Text = $"{k}",Tag=k};b.Clicked += B_Clicked;g.Children.Add(b, j, i);k++;}}//余白部の作成var l=new Label();g.Children.Add(l, 0, 8);Content = g;}
16個のボタンを作成してグリットに配置
余白部の作成
*var l=new Label();
*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer
*{public object Tag{get { return (object)GetValue(TagProperty); }set { SetValue(TagProperty, value); }}public static readonly BindableProperty TagProperty =BindableProperty.Create(nameof(Tag), typeof(object), typeof(Mbutton), null);}
Button に　Tag プロパティを追加
*{var g = new Grid() {HeightRequest=400 };var k = 0;for(var i = 0; i <; 4; i++){for (var j = 0; j <; 4; j++){var b = new Mbutton() { Text = $"{k}",Tag=k};b.Clicked += B_Clicked;g.Children.Add(b, j, i);k++;}}//余白部の作成var l=new Label();g.Children.Add(l, 0, 8);Content = g;}
16個のボタンを作成してグリットに配置
余白部の作成
*var l=new Label();

*Resource = "pfrn:api--
ClientGetContentDownloadUrl",   ←ポリシーを変更する API 名

*SceneManager.LoadScene("GameClear");
クリアシーンを表示

INotifyPropertyChnagedの実装（省略）
*private DelegateCommand _clearCommand;

*catch (Exception e)
失敗した時の処理
デシリアライズした構造体を返す
*return jsonDeserializedData;
色のプロパティIDをintで保持
*_propertyID = Shader.PropertyToID("_Color");
ここでTrailRendererの情報を構造体、及びリストに格納する
*PaintDataWrapper paintDataWrapper = new PaintDataWrapper();
*foreach (Transform child in _paintTrailRendererParent.transform)*{
Paintオブジェクト(TrailRenderer)のリストを作成
TrailRendererの情報を取得
*TrailRenderer tr = child.GetComponent<;TrailRenderer>;();
構造体にTrailRendererの座標を格納
*paintData.PaintObjectPosition = child.position;
構造体にTrailRendererの頂点座標の配列を格納
*paintData.PaintVertices = posArray;
*for (int i = 0; i <; vertCount; i++)*{
描画した頂点座標を確認
構造体に色情報を格納
*_materialPropertyBlock.SetColor(_propertyID,tr.material.color);
構造体をリストに追加
*paintDataWrapper.DataList.Add(paintData);
シリアライズ
*JsonDataManager.Save(paintDataWrapper);
デシリアライズ
*PaintDataWrapper paintDataWrapper =  JsonDataManager.Load();
リストのデータ分Instantiate
*GameObject paintObj = Instantiate(_paintTrailRendererPrefab, paintData.PaintObjectPosition ,Quaternion.identity,_paintTrailRendererParent);
TrailRenderer再設定
==============================================================================================================
*TrailRenderer paintObjTrailRenderer = paintObj.GetComponent<;TrailRenderer>;();
全ての頂点を復元
*paintObjTrailRenderer.AddPositions(paintData.PaintVertices);
色情報を復元
*_materialPropertyBlock.SetColor(_propertyID, paintData.PaintColor);

*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer
*{//ラベルのTextに時刻を表示します。label.Text = DateTime.Now.ToString("HH:mm:ss");}
イベントハンドラの定義追加
ラベルのTextに時刻を表示します。
*label.Text = DateTime.Now.ToString("HH:mm:ss");
*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer
*{//ラベルのTextに時刻を表示します。label.FontSize = 64; //font size指定label.Text = DateTime.Now.ToString("HH:mm:ss");}
イベントハンドラの定義追加
ラベルのTextに時刻を表示します。
label.FontSize = 64; font size指定
*label.Text = DateTime.Now.ToString("HH:mm:ss");
*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer
*{Button b = s as Button;label.FontSize = 64;b.IsEnabled = false;// タイマーインタラプトルーチンDevice.StartTimer(TimeSpan.FromSeconds(1),()=>; {label.Text = DateTime.Now.ToString("HH:mm:ss");return true;});}
イベントハンドラの定義追加
*()=>; {label.Text = DateTime.Now.ToString("HH:mm:ss");return true;});
タイマーインタラプトルーチン

*Discovery discovery = new Discovery {issuer = "http:
localhost:5000op", grant_types_supported = new string[] {"authorization_code","implicit","client_credentials","password","refresh_token"}, response_types_supported = new string[] {"code","id_token","token id_token"}, authorization_endpoint = "http:localhost:5000opauth", token_endpoint = "http:localhost:5000optoken", introspection_endpoint = "http:localhost:5000opintrospect", jwks_uri = "http:localhost:5000opkeys"};

Formアプリ側
*static string localIpString = "127.0.0.10";
Unity側
*static int unityPort = 8888;
受信用Thread
*static bool isReceiving;

アウトプットが多いので10に変更
*const int N = 10;
*{Console.WriteLine("ForEach Start Theread：" + Thread.CurrentThread.ManagedThreadId);Thread.Sleep(1);Console.WriteLine("ForEach End Theread：" + Thread.CurrentThread.ManagedThreadId);});
for
*{Console.WriteLine("PLINQ Start Theread：" + Thread.CurrentThread.ManagedThreadId);Thread.Sleep(1);Console.WriteLine("PLINQ End Theread：" + Thread.CurrentThread.ManagedThreadId);});
PLINQ

*if (result)*{
結果に応じた処理を記載する
Mockを作成(インターフェースを指定)
*var mock = new Mock<;IFooSample>;();
関数名と戻り値を指定
*mock.Setup(foo =>; foo.DoSomething("ping")).Returns(true);
評価対象クラスにMockを渡す
*var fooObject = new FooSample(mock.Object);
評価対象クラスで関数コール
*Assert.IsTrue(fooObject.DoSomething("ping"));

*Instantiate(PrefabObject, pos, Quaternion.identity);
オブジェクト、位置(省略可)、無回転（省略可）

*private CompositeDisposable Disposable { get; } = new CompositeDisposable();
メモリリーク対策。使用不可。
*private CompositeDisposable Disposable { get; } = new CompositeDisposable();
メモリリーク対策。使用不可。
*public ReactiveCommand<;MouseEventArgs>; SetNumber { get; set; } = new ReactiveCommand<;MouseEventArgs>;();
public ReactiveCommand SetNumber { get; set; } = new ReactiveCommand();

*watcher.Stop();
目的のサービスUUIDをみつけたらスキャン終了
*{byte[] data = new byte[eventArgs.CharacteristicValue.Length];Windows.Storage.Streams.DataReader.FromBuffer(eventArgs.CharacteristicValue).ReadBytes(data);RxData = data;textLog = "Notfy : " + RxData[0].ToString() + "," + RxData[1].ToString();return;}
Notifyによる受信時の処理
*{if (isBleFind == true) CHARACTERISTIC_UUID_RX.Service.Dispose();}
終了時の処理
*byte[] TXdata = { 0 };
ボタンがクリックされたときの処理

要求URLパラメータ取得
*CLIENT_ID = HttpContext.Request.Query["client_id"].ToString();
*if (client == null) {return Redirect("#error=unauthorized_client&amp;error_description=client authentication failed.");}
要求URLパラメータclient_idチェック
*if (client.RedirectUris != System.Web.HttpUtility.UrlDecode(REDIRECT_URI)) {*return Redirect("#error=invalid_request&amp;error_description=redirect_uri is not valid.");
要求URLパラメータredirect_uriチェック
*if (STATE == null) {*return Redirect(REDIRECT_URI + "#error=invalid_request&amp;error_description=state is not valid.");
要求URLパラメータstateチェック
access_token発番(token)
*string random = Guid.NewGuid().ToString("N").ToUpper();
refresh_token発番(code)
*string refresh = Guid.NewGuid().ToString("N").ToUpper();
応答URLパラメータにstateを引き継ぐ
*string param = "&amp;state="+STATE;
*if (RESPONSE_TYPE == "code") {*// クライアントがcodeをサポートしているかチェック
要求がAuthorization Code Flow(code)の場合
*if (client.GrantTypes != "authorization_code") {*return Redirect(REDIRECT_URI + "#error=unsupported_response_type&amp;error_description=the response_type value is not supported.");
クライアントがcodeをサポートしているかチェック
*var code = new Code {CodeId = random, UserId = User.Identity.Name, ClientId = CLIENT_ID, Nonce = NONCE, Iat=DateTime.Now};
認可コード(code)を発行
応答URLパラメータを生成
*param = "?code=" + random + param;
*} else if (RESPONSE_TYPE == "token") {*// クライアントがtokenをサポートしているかチェック
要求がImplicit Grant(token)の場合
*if (client.GrantTypes != "implicit") {*return Redirect(REDIRECT_URI + "#error=unsupported_response_type&amp;error_description=the response_type value is not supported.");
クライアントがtokenをサポートしているかチェック
*if (access_token != null) {_context.Tokens.Remove(access_token);await _context.SaveChangesAsync();}
削除タイミングがないためaccess_tokenは１ユーザーにつき１つの制限
*access_token = new Token {UserId = User.Identity.Name, AccessToken = random, ClientId = CLIENT_ID, Scope = SCOPE, Iat=DateTime.Now};
有効期限60秒固定のaccess_tokenを発行
応答URLパラメータを生成
*param = "#access_token=" + random + "&amp;token_type=bearer" + param;
*} else if (RESPONSE_TYPE == "id_token") {*// クライアントがid_tokenをサポートしているかチェック
要求がImplicit Flow(id_token)の場合
*if (client.GrantTypes != "implicit") {*return Redirect(REDIRECT_URI + "#error=unsupported_response_type&amp;error_description=the response_type value is not supported.");
クライアントがid_tokenをサポートしているかチェック
*var claims = new[] {new Claim(JwtRegisteredClaimNames.Sub, User.Identity.Name),new Claim(JwtRegisteredClaimNames.Nonce, NONCE)};
共通関数にてIDトークン(id_token)を生成
応答URLパラメータを生成
*param = "#id_token=" + id_token + param;
*} else if (RESPONSE_TYPE == "token id_token" || RESPONSE_TYPE == "id_token token") {*// クライアントがtoken id_tokenをサポートしているかチェック
要求がImplicit Flow(token id_token)の場合
*if (client.GrantTypes != "implicit") {*return Redirect(REDIRECT_URI + "#error=unsupported_response_type&amp;error_description=the response_type value is not supported.");
クライアントがtoken id_tokenをサポートしているかチェック
*if (access_token != null) {_context.Tokens.Remove(access_token);await _context.SaveChangesAsync();}
削除タイミングがないためaccess_tokenは１ユーザーにつき１つの制限
*access_token = new Token {UserId = User.Identity.Name, AccessToken = random, ClientId = CLIENT_ID, Scope = SCOPE, Iat=DateTime.Now};
有効期限60秒固定のaccess_tokenを発行
共通関数にてハッシュ値(at_hash)を生成
*AT_HASH = Util.GetAtHash(random);
*var claims = new[] {new Claim(JwtRegisteredClaimNames.Sub, User.Identity.Name),new Claim(JwtRegisteredClaimNames.AtHash, AT_HASH),new Claim(JwtRegisteredClaimNames.Nonce, NONCE)};
共通関数にてIDトークン(id_token)を生成
応答URLパラメータを生成
*param = "#access_token=" + random + "&amp;token_type=bearer&amp;id_token=" + id_token + param;
*} else {
不明の場合
応答をリダイレクト
*return Redirect(REDIRECT_URI + param);

*var force = new Vector3(a, 0f, b);
(x, y, z)平面方向がx,z上空方向がy

*var resourceId = $"AppSyncDemo.GraphQLs.{apiName}.gql";
GraphQL取得
*{Query = query,OperationName = "MyQuery",Variables = variables,};
リクエスト作成
Query実行
Mutation実行の場合はSendMutationAsync()を使用
*var response = await this.GraphQLHttpClient.SendQueryAsync<;JObject>;(request);
[apiName]から先が必要かどうかはレスポンスの構造に応じて変更する必要あり
*var json = response.Data[apiName]["data"].ToString();

*var url = $"https:
login.microsoftonline.com{Config.OAuth.TenantID}oauth2v2.0token";

*Console.WriteLine("Hello World! {0}", rangeValuePattern.Current.Value);
現在のスクロール位置
スクロール位置の変更
*rangeValuePattern.SetValue(50000);

*if (!_hubSpotService.ValidRequestHeader(jObject.ToString(Formatting.None)))*{
リクエストがHubspotウェブフックによるものか検証
(略)
*services.AddScoped<;IHubSpotService, HubSpotService>;();
hubspotアプリのclientsecretを指定。(e.g. 00000000-1111-2222-3333-444444444444)
*string secretId = "hubspot-client-secret";
ワークフローで指定したウェブフックURLを指定
string url = "https:hogehoge.com/webhook";
*byte[] bytes = Encoding.UTF8.GetBytes(secretId + method + url + requestBody);

拡張メソッドは、以下と同等の為、引数無しデリゲート型として渡せないと思われる。
Func(TestExt.IsTrue(true));
*,,,
以下は可能
*Func(() =>; true.IsTrue());
おそらく以下のように取り扱われているから？
Func(TestExt.IsTrue(true));
*,,,

Sql文を　[testTable].[test_id]から　[test_id]に変更する
*DapperExtensions.DapperExtensions.SqlDialect = new DapperExtensions.Sql.SqliteDialect();
DapperExtensionを使った処理
*testTable testTable1 = new testTable();
DapperExtensionを使った処理
*result.name += "qqqq111";

*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer

*private void form1_Closing(object sender, FormClosingEventArgs e)
×ボタン押下時

最小サイズ
*public Vector3 MinScale = Vector3.one;
縮んでいく比率
*public Vector3 ScaleRate = Vector3.one * 0.001f;

ログファイルを生成する
*CreateLogfile(new FileInfo(logFilePath));
ログファイルを圧縮する
*CompressLogFile();
古いログファイルを削除する
*DeleteOldLogFile();

*String url = "http:
api.openweathermap.orgdata2.5weather?q=Tokyo,jp&amp;units=metric&amp;APPID={Your API Key}";

*Console.WriteLine(i);
1,2,3,4,5
*if(num == 3)*{
カッコがいる
3じゃないよ
*,,,
*{return num1 + num2;}
戻り値の型 関数名(型 引数名)
普通に引数の型と同じものを入れたらよい
*plusWithNum(1,5)
追記
名前付き引数での呼び出し
*PlusWithNum(num1: 1, num2: 5);
名前付き引数の場合, 順番を前後させても問題ない
*PlusWithNum(num2: 5, num1: 1);

デノイズ処理を行い，その結果からエッジを抽出
*texture.ToRenderTexture().GaussianFilter5X5().ExtractEdge();

*var ユーザー = new ユーザー(new ユーザーId(100),
以下省略...

*private void mode_Select(object sender, EventArgs e)
モードセレクト
未選択時はNormal
*x = -3;

*{var option = new DbContextOptionsBuilder<;SampleDbContext>;();Options = option.UseSqlServer(DbSetting.SQLServerConnectionString).Options;break;}
本番環境
*{if (_dbConnection == null){_dbConnection = new SqliteConnection(DbSetting.SqliteInMemoryConnectionString);_dbConnection.Open();var option = new DbContextOptionsBuilder<;SampleDbContext>;();// InMemoryではトランザクション(スコープ)を使うとエラーになってしまうので回避コードoption.ConfigureWarnings(x =>; x.Ignore(Microsoft.EntityFrameworkCore.Diagnostics.RelationalEventId.AmbientTransactionWarning));Options = option.UseSqlite(_dbConnection).Options;using (var context = new SampleDbContext(Options)){context.Database.EnsureDeleted();context.Database.EnsureCreated();}}break;}
テスト環境
InMemoryではトランザクション(スコープ)を使うとエラーになってしまうので回避コード
*option.ConfigureWarnings(x =>; x.Ignore(Microsoft.EntityFrameworkCore.Diagnostics.RelationalEventId.AmbientTransactionWarning));
SqliteInMemoryに設定
*DbSetting.DataBaseName = "SqliteInMemory";
DB名はテストごとに変更すると競合しなくてすみます
*DbSetting.SqliteInMemoryConnectionString = $"DataSource=UnitTest1.db;mode=memory;";
DIは使用せずに直接実装から呼び出しています
*dbContextOptionsFactory = new DbContextOptionsFactory();
初期データ作成
*Seed();
最初に登録されてたメッセージは5種類
*Assert.IsTrue(count == 5);
後で使用するため、"おはよう"の主キーを取得しておきます
*testId = sampleDbContext.SampleModels.Where(x =>; x.Message == "おはよう").Select(x =>; x.SampleModelId).FirstOrDefault();
最初に登録されているメッセージは5種類
*Assert.IsTrue(count == 5);
追加
既存のメッセージがあるので数は変更ないはず
*dbAccess.AddMessage("おはよう");
新しいメッセージを追加
*dbAccess.AddMessage("ごちそうさま");
削除
存在しないメッセージは削除できず数の変更なしのはず
*dbAccess.DeleteMessage("おはようございます");
変更
おはよう =&gt; おはようございます
*dbAccess.UpdateMessage(testId, "おはようございます");
削除
こんどは"おはようございます"は存在するので削除できる
*dbAccess.DeleteMessage("おはようございます");

*SecValue = v ^ Seed;
あとはお好きに

Themeが変わった
*CurrentThemeName = themeName;

*get { return _num; }
外部に値を返す

念の為PhotonVoiceSettingも変更しておく
*PhotonVoiceSettings.Instance.MicrophoneType = IsMacOs()
*private bool IsMacOs() {#if UNITY_STANDALONE_OSX || UNITY_EDITOR_OSXreturn true;#endifreturn false;}
Macで実行されていたらtrue

モックの振る舞いを登録します
ref参照の変数で値を変更します
*mock.Setup(_ =>; _.DoSomething(It.IsAny<;string>;(), ref It.Ref<;string>;.IsAny))

POSTパラメータ取得
*string body = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync();
*if (client == null) {return new AccessToken {error = "unauthorized_client", error_description="client authentication failed."};}
POSTパラメータclient_idチェック
id_token生成(authorization_code)
*string idtoken = null;
access_token発番(authorization_code/client_credentials/password/refresh_token)
*string random = Guid.NewGuid().ToString("N").ToUpper();
refresh_token発番(authorization_code/password/refresh_token)
*string refresh = Guid.NewGuid().ToString("N").ToUpper();
*if (GRANT_TYPE == "refresh_token") {*// 要求がimplicit/client_credentialsではないかチェック
要求がrefresh_tokenの場合
*if (client.GrantTypes == "implicit" || client.GrantTypes == "client_credentials") {*return new AccessToken {error = "unsupported_response_type", error_description="the response_type value is not supported."};
要求がimplicit/client_credentialsではないかチェック
*if (refresh_token == null) {return new AccessToken {error = "unsupported_response_type", error_description="the response_type value is not supported."};} else {// 要求のclient_idをチェックif (CLIENT_ID != refresh_token.ClientId) return new AccessToken {error = "invalid_request", error_description = "client_id is not valid."};// 要求のrefresh_tokenの有効期限3600秒固定をチェックint unixTimestamp = (int)(DateTime.Now.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;int iat = (int)(refresh_token.Iat.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;if (unixTimestamp - iat >; 3600) {return new AccessToken {error = "access_denied", error_description="the refresh_token is not valid."};}// 要求のclient_idからusername/scopeを取得USERNAME = refresh_token.UserId;SCOPE = refresh_token.Scope;}
要求のrefresh_tokenをチェック
*if (CLIENT_ID != refresh_token.ClientId) return new AccessToken {error = "invalid_request", error_description = "client_id is not valid."};*// 要求のrefresh_tokenの有効期限3600秒固定をチェック
要求のclient_idをチェック
要求のrefresh_tokenの有効期限3600秒固定をチェック
*int unixTimestamp = (int)(DateTime.Now.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;
要求のclient_idからusername/scopeを取得
*USERNAME = refresh_token.UserId;
*if (client.GrantTypes != GRANT_TYPE) {*return new AccessToken {error = "unsupported_response_type", error_description="the response_type value is not supported."};
要求のgrant_typeをチェック
*if (client.GrantTypes == "client_credentials") {*// usernameはadmin固定
要求がclient_credentialsの場合
usernameはadmin固定
*USERNAME = "admin";
refresh_tokenは発行しない
*refresh = null;
*if (client.GrantTypes == "password") {*// 要求のusernameをチェック
要求がpasswordの場合
*if (user == null ) {return new AccessToken {error = "access_denied", error_description="user authentication failed."};}
要求のusernameをチェック
*if (!Util.PasswordEqual(user.PasswordHash, PASSWORD)) {*return new AccessToken {error = "access_denied", error_description="user authentication failed."};
要求のpasswordを共通関数でチェック
*if (client.GrantTypes == "authorization_code") {*// 要求のcodeをチェック
要求がauthorization_codeの場合
*if (code == null) {return new AccessToken {error = "invalid_request", error_description="the code is not valid."};}
要求のcodeをチェック
要求のcodeからusername/nonceを取得
*USERNAME=code.UserId;
要求のcodeを削除
*_context.Codes.Remove(code);
*if (CLIENT_ID != code.ClientId) return new AccessToken {error = "invalid_request", error_description = "client_id is not valid."};*// 要求のnonceをチェック
要求のclient_idをチェック
*if (NONCE == null) return new AccessToken {error = "invalid_request", error_description = "nonce is not valid."};*// 共通関数にてIDトークン(id_token)を生成
要求のnonceをチェック
*var claims = new[] {new Claim(JwtRegisteredClaimNames.Sub, USERNAME),new Claim(JwtRegisteredClaimNames.Nonce, NONCE)};
共通関数にてIDトークン(id_token)を生成
*if (SCOPE != null) {string[] s =  SCOPE.Split(' ');for (int j=0; j<;s.Length; j++){if (s[j]!="openid" &amp;&amp; client.AllowedScope.Contains(s[j])) t=t+" "+s[j];}}
scopeはopenidを最小限とする
要求scopeと許可scopeのANDをとる
*SCOPE=t;
*if (client.AccessType == "confidential") {*// 要求のclient_secretチェック
機密クライアントの場合
*if (client.ClientSecret != CLIENT_SECRET) {*return new AccessToken {error = "invalid_request", error_description="client authentication failed."};
要求のclient_secretチェック
*} else if (client.AccessType == "public") {*// 要求がclient_credentialsではないかチェック
公開クライアントの場合
*if (client.GrantTypes == "client_credentials") {*return new AccessToken {error = "invalid_request", error_description="client authentication failed."};
要求がclient_credentialsではないかチェック
*if (CLIENT_SECRET != null) {*return new AccessToken {error = "invalid_request", error_description="client authentication failed."};
要求にclient_secretは不要
*} else {
不明の場合
*if (token != null) {_context.Tokens.Remove(token);await _context.SaveChangesAsync();}
削除タイミングがないためaccess_tokenは１ユーザーにつき１つの制限
*token = new Token {UserId = USERNAME, AccessToken = random, ClientId = CLIENT_ID, RefreshToken=refresh, Scope = SCOPE, Iat=DateTime.Now};
有効期限60秒固定のaccess_tokenを発行
*if (client.GrantTypes == "client_credentials") {*return new AccessToken {access_token = random, expires_in=60, token_type="bearer", scope = SCOPE};
要求がclient_credentialsの場合、access_tokenを返す
*} else {
要求がathorization_code/password/refresh_tokenの場合、access_token/refresh_tokenを返す

*var cert = new X509Certificate2(file, pfxFilePassward);*//秘密鍵の取り出し
pfxファイルを読み込み
秘密鍵の取り出し
*var rsa = (RSACryptoServiceProvider)cert.PrivateKey;
署名実行
!!! 例外発生 !!!!
*var signature = rsa.SignData(byteData, HashAlgorithm.Create("SHA256"));
*var cert = new X509Certificate2(file);*//公開鍵の取り出し
crtファイルを読み込み
公開鍵の取り出し
*var rsa = (RSACryptoServiceProvider)cert.PublicKey.Key;
*var result = rsa.VerifyData(byteData, HashAlgorithm.Create("SHA256"), signature);*,,,
検証実行
*var cert = new X509Certificate2(file, pfxFilePassward);*//秘密鍵の取り出し
pfxファイルを読み込み
秘密鍵の取り出し
*var rsa = (RSACryptoServiceProvider)cert.PrivateKey;
以下の処理を行わないとSHA256アルゴリズムが使用できない
*var enhCsp = new RSACryptoServiceProvider().CspKeyContainerInfo;
署名実行
*var signature = privKey.SignData(byteData, HashAlgorithm.Create("SHA256"));

コピーしたオブジェクトのメンバーの値を変更する。
*s2.Num = 2;
MemberwiseCloneメソッドはobject型で返却するのでSample型へキャストする必要があります。
*public Sample ShallowCopy() =>; (Sample)MemberwiseClone();

*public class LifeStyle*{
元々あったライフスタイルクラスを使いまわしたい
*{public void SummerVacationWeekday();public void SummerVacationHoliday();}
夏休み用の過ごし方を表すインターフェースを用意します。
夏休み用ライフスタイルクラスで元々あったクラスを利用 + 独自にカスタマイズします。
今回は平日の過ごし方を夏休み用にカスタマイズしました。
*public class SummerVacationLifeStyle : ISummerVacation

*Status = 0;
0だったらCllisionのif文が実行される

*public int X
自動実装プロパティにすべきだが説明用

IConfiguration から AppSettings クラスにして DI できるようにしておく
*builder.Services.AddSingleton(p =>; p.GetRequiredService<;IConfiguration>;().Get<;AppSettings>;());
*{public string Message { get; set; }public string EnvMessage { get; set; }}
appsettings.json の値を入れるよう

*return method.Invoke(_instance, arg);
メソッドを実行する
エラーが発生したら「ここ」のエラー情報じゃなくて発生元のエラーを投げる
*throw e.InnerException;

値を読み込む
*var v = configuration_.GetValue<;int>;("test:abc");
値を読み込む
*var v = testConfiguration_.Value.abc;

*myPolygon.StrokeThickness = 1
1.25;    ここは解像度に変更

*Console.WriteLine($"JSON:{jsonRpText}");
JSON形式にシリアライズ
*Console.WriteLine($"MessagePack:{String.Join(" ", mPackRpText.Select(x =>; x.ToString("X2")))}");
MessagePack形式にシリアライズ
*public ReactivePropertySlim<;string>; NameRps { get; set; } = new ReactivePropertySlim<;string>;("Skywalker");
ReactivePropertyでもReactivePropertySlimでもできる。
*public ReadOnlyReactivePropertySlim<;string>; NameRorps { get; set; }
ReadOnlyはSerializeできない。
*.CombineLatest(NameRp, NameRps, (x, y) =>; $"{x}={y}")
姓と名の変更を購読して、フルネームにする
*public RpNames Names { get; } = new RpNames();
メモリリークを防ぐためのダミー実装
ReactiveProperty用を含んだResolverのセットをデフォルトに設定しておく
*var resolver = MessagePack.Resolvers.CompositeResolver.Create(
JSON側からデシリアライズ
*var mPack = MessagePack.MessagePackSerializer.ConvertFromJson(JsonSerializedNames.Value);

ログ・ファイルへの出力ストリームを生成
*StreamWriter sw = new StreamWriter(
日付、リクエストのユーザーエージェントを出力
*StringBuilder sb = new StringBuilder();

*helloText.enabled = true;
表示する

*var orderedNumber = number.OrderBy(x =<; x)
.OrderByDescending(x =&gt; x)
配列のように添え字でアクセスできます
*int item = list[1];

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"
*{var colorFrame = frames.ColorFrame.DisposeWith(frames);var depthFrame = frames.DepthFrame.DisposeWith(frames);// We colorize the depth frame for visualization purposesvar colorizedDepth = colorizer.Process<;VideoFrame>;(depthFrame).DisposeWith(frames);// Render the frames.Dispatcher.Invoke(DispatcherPriority.Render, updateDepth, colorizedDepth);Dispatcher.Invoke(DispatcherPriority.Render, updateColor, colorFrame);Dispatcher.Invoke(new Action(() =>;{String depth_dev_sn = depthFrame.Sensor.Info[CameraInfo.SerialNumber];txtTimeStamp.Text = depth_dev_sn + " : " + String.Format("{0,-20:0.00}", depthFrame.Timestamp) + "(" + depthFrame.TimestampDomain.ToString() + ")";}));}
at the end of scope.

*for (int i = 1; i <; 10; i++)*{
キューに１～９を追加
次のルンルン数をキューに追加する
*var num = LunLunNumber.Dequeue();

*{//スクリプトにPrehubをアタッチするpublic GameObject fields;void Start(){//Prehubを作成GameObject field = Instantiate(fields) as GameObject;//ここで位置情報を入力したり、名前を変えたり、後はお好みで。}}
最初にステージを生成する
スクリプトにPrehubをアタッチする
*public GameObject fields;
Prehubを作成
*GameObject field = Instantiate(fields) as GameObject;
ここで位置情報を入力したり、名前を変えたり、後はお好みで。
*}
*if(this.transform.position.x　>; 50)*{
一定範囲内にいないとこのオブジェクトを破壊する
*{//当たったものが"weapon"だったらこのオブジェクトを破壊if (other.gameObject.name == "weapon"){Destroy(this.gameObject);}}
何かに当たったら反応
*if (other.gameObject.name == "weapon")*{
当たったものが"weapon"だったらこのオブジェクトを破壊

*var hoge = Hoge();
taskが完了したかなど関係なく普通に進んでいく

*{// 線オブジェクト設定LineRenderer line = gameObject.GetComponent<;LineRenderer>;();// 線の幅を指定line.startWidth = 0.1f;line.endWidth = 0.1f;// 頂点の数を指定line.positionCount = 2;// 開始位置と終了位置を指定line.SetPosition(0, Vector3.zero);line.SetPosition(1, new Vector3(1f, 1f, 0f));}
Start is called before the first frame update
線オブジェクト設定
*LineRenderer line = gameObject.GetComponent<;LineRenderer>;();
線の幅を指定
*line.startWidth = 0.1f;
頂点の数を指定
*line.positionCount = 2;
開始位置と終了位置を指定
*line.SetPosition(0, Vector3.zero);
*{}
Update is called once per frame
*{// 線オブジェクト設定LineRenderer line = gameObject.GetComponent<;LineRenderer>;();// 線の幅を指定line.startWidth = 0.1f;line.endWidth = 0.1f;// 頂点の数を指定line.SetVertexCount(2);// 開始位置と終了位置を指定line.SetPosition(0, Vector3.zero);line.SetPosition(1, new Vector3(1f, 1f, 0f));}
Start is called before the first frame update
線オブジェクト設定
*LineRenderer line = gameObject.GetComponent<;LineRenderer>;();
線の幅を指定
*line.startWidth = 0.1f;
頂点の数を指定
*line.SetVertexCount(2);
開始位置と終了位置を指定
*line.SetPosition(0, Vector3.zero);
*{}
Update is called once per frame

*"https:
blazorsignin.onmicrosoft.comxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxxAPI.Manage");
これを追加
*@using Microsoft.AspNetCore.Components.Authorization

100個のint型要素が入る配列を生成。
*int[] arr = new int[100];
*for (int i = 0; i <; arr.length; i++)*{
1~100までの整数をランダムに生成し、配列に格納する

DependencyPropertyを自動実装するために属性を付ける
*[DependencyPropertyGen(typeof(string), "MyText")]
略
*}
DependencyPropertyを自動実装するために属性を付ける
*[DependencyPropertyGen(typeof(string), "MyText")]
略
*}

*AssetDatabase.Refresh ();
アセットを更新

*public ImageSource img { get; }
返す値はお好みで
*public ImageSource img { get; }
今回はプロジェクトプロパティのResource画像から

レンダリングするので重い処理はしない
*}
レンダリングしてないので重い処理を実行
*}

*else if (e.KeyChar == 's' &amp;&amp; paddlePos.Right <; this.Width)
S押下時

aに一つの文字列を入力
*string a = onestring();
bに複数の文字列を入力
*string[] b = arraystring();
cに一つの数字を入力
*int c = oneint();
dに複数の数字を入力
*int[] d = arrayint();
*{return Console.ReadLine();}
一つの文字列を受け渡す
複数の文字列を配列で受け渡す
文字列と文字列の間は" "で区切る
*static string[] arraystring()
*{return int.Parse(Console.ReadLine());}
一つの数字を受け渡す
複数の数字を配列で受け渡す
数字と数字の間は" "で区切る
*static int[] arrayint()

*&amp;&amp; Math.Abs(xy01 - xy02) <; 0.025
傾きの差が小さすぎる点は直線であろう。&lt;--------要調整
*{List<;OpenCvSharp.Point>; maskedContour = new List<;OpenCvSharp.Point>;();if (maskArea == null){//画像中の無視領域は指定されていないのでそのまま返す。maskedContour.AddRange(inputPoints);}else{foreach (var con in inputPoints){if (maskArea.Where(a =>; a.Left <; con.X &amp;&amp; a.Right >; con.X&amp;&amp; a.Top <; con.Y &amp;&amp; a.Bottom >; con.Y).Any()){continue;}maskedContour.Add(con);}}return maskedContour.ToArray();};
画像中の無視する範囲の輪郭を除去します。
画像中の無視領域は指定されていないのでそのまま返す。
*maskedContour.AddRange(inputPoints);
binaryにすると円以外の輪郭が強く出てしまい、これを除去する必要がある。今回は不採用
var bin_img = gray.Threshold(12, 255, ThresholdTypes.Binary);.Otsu);
ガウシアンフィルタのカーネルサイズは画像(画素数)によって要調整。画素数が多いほど大きくした方が良さそうである。
*var blur = gray.GaussianBlur(new OpenCvSharp.Size(9, 9), 0);
画像次第でここの数値は要調整 なるべく数値を上げて輪郭数を少なくした方が速いが、輪郭が短くブツ切れになると円の検出が厳しい。
*var canny_img = blur.Canny(100, 250);
検出した円弧を詰めるList
*var rtnList = new List<;Arc>;();
*foreach (var contour in contours)*{
見つけた輪郭を走査
輪郭中の計算点数
*int numOfPoints = 10;
画像中の処理対象外にある輪郭を除去する
*var maskedContour = getMaskContuour(contour);
完全な直線と疑われるものは除く
*var notStraightContour = searchNotStraightContour(maskedContour);
*if (!notStraightContour.Any()*|| notStraightContour.Count() ; numOfPoints)
対象が無ければ処理しない
間引きしてdouble型のPointコレクションを取得
*var subContour = notStraightContour
間引きする
*.Where((a, index) =>; index % (notStraightContour.Count() / numOfPoints) == 0)
外形トリミング分の座標補正
*.Select(a =>; new Point2d(a.X + outLine.X, a.Y + outLine.Y));
円弧を計算
*var arc = CalcArc.Calc(subContour);

*listView.Items[i] = fld;
こんな感じで配列をそのまま突っ込む

(1)キャリブレーション画像(補正前)の読み込み
*string[] imagePaths = System.IO.Directory.EnumerateFiles(ImagePath, "*", System.IO.SearchOption.AllDirectories).ToArray();
*{var mtx = fs["mtx"].ReadMat();var dist = fs["dist"].ReadMat();Mat calib = new Mat();Cv2.Undistort(src, calib, mtx, dist);Cv2.ImShow("src", srcImg[i]);Cv2.ImShow("calib", calib);OpenCvSharp.Cv2.WaitKey(0);}
ymlファイルを読み来み計算パラメータを取得

*Taro.SetNickName = "tataroro";
setの部分が呼び出される
ニックネームを表示する
Console.Write(Taro.SetNickName);     getの部分が呼び出される
*}
*public string SetNickName { get; set; }
上のプロパティは以下のように短縮できる

*.ToArray();
配列にする

*{return function.Method.MethodHandle.GetFunctionPointer();}
Func等をキャストなしで引数に渡せるのでジェネリックにしています。
*{public static bool operator ==(FuncPointer<;TResult, T0>; left, FuncPointer<;TResult, T0>; right) =>; left.Equals(right);public static bool operator !=(FuncPointer<;TResult, T0>; left, FuncPointer<;TResult, T0>; right) =>; !(left == right);public static int Arity =>; 1;public RuntimeMethodHandle Handle { get; }readonly IntPtr ptr;[MethodImpl(MethodImplOptions.AggressiveInlining)]public TResult Invoke(T0 arg0) =>; FunctionPointerUtility.Call<;TResult, T0>;(this.ptr, arg0);public override bool Equals(object obj) =>; obj is FuncPointer<;TResult, T0>; pointer &amp;&amp; this.Equals(pointer);public bool Equals(FuncPointer<;TResult, T0>; other) =>; this.Handle.Equals(other.Handle);public override int GetHashCode() =>; HashCode.Combine(this.Handle);public FuncPointer(Func<;TResult, T0>; func){FunctionPointersHelper.ValidateFunction(func, Arity);this.Handle = func.Method.MethodHandle;this.ptr = this.Handle.GetFunctionPointer();}}
項数1の戻り値有り・無しで一つずつ例示します。
*{public static void ValidateFunction(Delegate func, int arity){if (func is null) throw new ArgumentNullException(ResourceStrings.ExceptionMessage_FunctionIsNull);if (!func.Method.IsStatic) throw new ArgumentException(ResourceStrings.ExceptionMessage_FunctionIsNotStatic);//拡張メソッドだと項数が一致しない。if (func.Method.GetParameters().Length != arity) throw new ArgumentException(ResourceStrings.ExceptionMessage_FunctionArityMismatch);}}
ResourceStringsは特に重要でないので出しません。
*if (func.Method.GetParameters().Length != arity) throw new ArgumentException(ResourceStrings.ExceptionMessage_FunctionArityMismatch);*}
拡張メソッドだと項数が一致しない。

*int lenNow = Encoding.GetEncoding("Shift_JIS").GetByteCount(txt.Text);*// 未入力の場合
桁数取得（全角を2桁として扱う）
*if (lenNow.Equals(0))*{
未入力の場合
*if (maxOnly &amp;&amp; !lenNow.Equals(len))*{
最大桁数のみを受け付ける場合
*else if (lenNow >; len)*{
最大桁数を超える場合
*if (!CheckLength(this.TxtCode, this.LblCode.Text, this.TxtCode.MaxLength, true))*{
チェック処理
エラーメッセージを表示
*MessageBox.Show(ex.Message);

何か終了処理があればここに
*}
エラーメッセージを表示
*MessageBox.Show(ex.Message);
画面を終了する
*this.Close();

*using (var pngbmp = new Bitmap("touka.png"))
貼り付けたい画像を開く(この場合はpngで、透明部分を透過できる)
貼り付ける画像を(5,5)の位置に描画する
*g.DrawImage(pngbmp, 5, 5, pngbmp.Width, pngbmp.Height);
保存する
*bmp.Save(@"output.bmp");

*int[][] bingo = { new int[] { 0, 1, 2 }, new int[] { 3, 4, 5 }, new int[] { 6, 7, 8 }, new int[] { 0, 3, 6 }, new int[] { 1, 4, 7 }, new int[] { 2, 5, 8 }, new int[] { 0, 4, 8 }, new int[] { 2, 4, 6 } };
C#
*int[][] bingo = { new int[] { 0, 1, 2 }, new int[] { 3, 4, 5 }, new int[] { 6, 7, 8 }, new int[] { 0, 3, 6 }, new int[] { 1, 4, 7 }, new int[] { 2, 5, 8 }, new int[] { 0, 4, 8 }, new int[] { 2, 4, 6 } };
ある日あるときの配列
他のある日の配列
*int[,] day = new int[2,3];
*//要素数が3個の配列(中身{0,1,2})と2個の配列(中身{3,4})を、同じ配列に入れている
C#
*//要素数が3個の配列(中身{0,1,2})と2個の配列(中身{3,4})を、同じ配列に入れている
要素数が一定でないときの配列の使い方
*int[][] arr1 = { new int[] { 0, 1, 2 }, new int[] { 3, 4 }};
要素数が3個の配列(中身{0,1,2})と2個の配列(中身{3,4})を、同じ配列に入れている
*int[,] arr2 = new int[2,3]{ { 0, 1, 2 } { 3, 4, 5} };
要素数が一定な時の配列の使い方
*int[,] arr2 = new int[2,3]{ { 0, 1, 2 } { 3, 4, 5} };
前者と同じように中身を定義することもできる(定義していないと全部中身は0になる)

予想している結果
*var expected = 8;
実際の結果
*var actual = Calculation.add(x,y);

*var roleArn = $"AwsRoleArnAws{(byte)accountNo}";
accountNo: 1~N

*actual.AssertIs(new { Foo = "Foo1", Bar = new[] { 1, 2 } });
成功！

*await GeotagHelper.SetGeotagAsync(stbmp, gps);
→こっちは、拡張子はjpgだが実はbmpでjpgではないので、geotag付与時に例外発生

テンプレートのファイルパス
*private string templete = @"C:\tmp\templete.docx";
保存パス
*doc.SaveAs(@"C:\tmp\output.docx");

*panel2.Controls.Remove(deletingArrow);
panel2に登録されたArrow型のオブジェクトを消す

ダウンロードするファイル名を指定
*CloudAppendBlob appendBlob_download = container.GetAppendBlobReference(filename);
ダウンロード後のパスとファイル名を指定。
*string path = Directory.GetCurrentDirectory() + "\\log\\" + DateTime.Now.ToString("yyyyMMdd") + ".log";

パスワードのチェックのみなので、ReadOnlyモードで開きます。
*PdfReader.Open(path, PdfDocumentOpenMode.ReadOnly).Dispose();

*return (T)binaryFormatter.Deserialize(memoryStream);
デシリアライズ
値型を代入
*int b = a;
stringの代入（stringは参照型だが、例外的にディープコピーとなる）
*string b = a;
値型のListをコンストラクタでnew
*List<;int>; b = new List<;int>;(a);
配列、リスト等の参照型を代入
*int[] b = a;
多重Listをコンストラクタでnew
*List<;List<;int>;>; b = new List<;List<;int>;>;(a);
*foreach(var member in a)*//gourpbyの中身（下の例でgroupaを変更すると、aも変更される）
foreachの中身（下の例でmemberを変更すると、aも変更される）
gourpbyの中身（下の例でgroupaを変更すると、aも変更される）
*var groupa = a.Groupby(c =>; c.key)

*app.UseAuthentication();
この1行を追加

Doubleにキャストして処理を進める
*var doubleList = src.Select(a =>; Convert.ToDouble(a)).ToArray();
平均値算出
*double mean = doubleList.Average();
自乗和算出
*double sum2 = doubleList.Select(a =>; a * a).Sum();
分散 = 自乗和 / 要素数 - 平均値^2
*double variance = sum2 / doubleList.Count - mean * mean;
標準偏差 = 分散の平方根
*return Math.Sqrt(variance);
標準偏差(int)
*Console.WriteLine(iList.Stdev().ToString());
標準偏差(double)
*Console.WriteLine(dList.Stdev().ToString());
Doubleにキャストして処理を進める
*var doubleList = new List<;double>;();
平均値算出
*double mean = doubleList.Average();
自乗和算出
*double sum2 = doubleList.Select(a =>; a * a).Sum();
分散 = 自乗和 / 要素数 - 平均値^2
*double variance = sum2 / doubleList.Count - mean * mean;
標準偏差 = 分散の平方根
*return Math.Sqrt(variance);
テストその1（ジェネリックからキャスト）
*var sw = new System.Diagnostics.Stopwatch();
テストその2（ジェネリックからキャスト（旧））
*sw = new System.Diagnostics.Stopwatch();
テストその3（ジェネリックなしでキャスト）
*sw = new System.Diagnostics.Stopwatch();
平均値算出
*double mean = doubleList.Average();
自乗和算出
*double sum2 = doubleList.Select(c =>; c * c).Sum();
分散 = 自乗和 / 要素数 - 平均値^2
*double variance = sum2 / doubleList.Length - mean * mean;
標準偏差 = 分散の平方根
*double stdev = Math.Sqrt(variance);

*{//ジェネリックの四則演算用クラスvar ao = new ArithmeticOperation<;T>;();//昇順ソートvar sorted = src.OrderBy(a =>; a).ToArray();if (!sorted.Any()){throw new InvalidOperationException("Cannot compute median for an empty set.");}int medianIndex = sorted.Length / 2;//要素数が偶数のとき、真ん中の2要素の平均を出力if (sorted.Length % 2 == 0){//四則演算可能な時のみ算出if (ao.ArithmeticOperatable(typeof(T))){return ao.Divide(ao.Add(sorted[medianIndex], sorted[medianIndex - 1]), (T)(object)2.0);}else throw new InvalidOperationException("Cannot compute arithmetic operation");}//奇数のときは、真ん中の値を出力else{return sorted[medianIndex];}}
メディアン算出メソッド（Generics）
ジェネリックの四則演算用クラス
*var ao = new ArithmeticOperation<;T>;();
昇順ソート
*var sorted = src.OrderBy(a =>; a).ToArray();
*if (sorted.Length % 2 == 0)*{
要素数が偶数のとき、真ん中の2要素の平均を出力
*if (ao.ArithmeticOperatable(typeof(T)))*{
四則演算可能な時のみ算出
*{return sorted[medianIndex];}
奇数のときは、真ん中の値を出力
*{//昇順ソートvar sorted = src.OrderBy(a =>; a).ToArray();if (!sorted.Any()){throw new InvalidOperationException("Cannot compute median for an empty set.");}int medianIndex = sorted.Length / 2;//要素数が偶数のとき、真ん中の2要素の平均を出力if (sorted.Length % 2 == 0){return sorted[medianIndex] + new TimeSpan((sorted[medianIndex - 1] - sorted[medianIndex]).Ticks / 2);}//奇数のときは、真ん中の値を出力else{return sorted[medianIndex];}}
メディアン算出（DateTime型のみ別メソッド）
昇順ソート
*var sorted = src.OrderBy(a =>; a).ToArray();
*if (sorted.Length % 2 == 0)*{
要素数が偶数のとき、真ん中の2要素の平均を出力
*{return sorted[medianIndex];}
奇数のときは、真ん中の値を出力
*{/// <;summary>;/// 四則演算適用可能かを判定/// <;/summary>;/// <;param name="src">;判定したいタイプ<;/param>;/// <;returns>;<;/returns>;public bool ArithmeticOperatable(Type srcType){//四則演算可能な型の一覧var availableT = new Type[]{typeof(int), typeof(uint), typeof(short), typeof(ushort), typeof(long), typeof(ulong), typeof(byte),typeof(decimal), typeof(double)};if (availableT.Contains(srcType)) return true;else return false;}/// <;summary>;/// 四則演算可能なクラスに対しての処理/// <;/summary>;public ArithmeticOperation(){var availableT = new Type[]{typeof(int), typeof(uint), typeof(short), typeof(ushort), typeof(long), typeof(ulong), typeof(byte),typeof(decimal), typeof(double)};if (!availableT.Contains(typeof(T))){throw new NotSupportedException();}var p1 = Expression.Parameter(typeof(T));var p2 = Expression.Parameter(typeof(T));Add = Expression.Lambda<;Func<;T, T, T>;>;(Expression.Add(p1, p2), p1, p2).Compile();Subtract = Expression.Lambda<;Func<;T, T, T>;>;(Expression.Subtract(p1, p2), p1, p2).Compile();Multiply = Expression.Lambda<;Func<;T, T, T>;>;(Expression.Multiply(p1, p2), p1, p2).Compile();Divide = Expression.Lambda<;Func<;T, T, T>;>;(Expression.Divide(p1, p2), p1, p2).Compile();Modulo = Expression.Lambda<;Func<;T, T, T>;>;(Expression.Modulo(p1, p2), p1, p2).Compile();Equal = Expression.Lambda<;Func<;T, T, bool>;>;(Expression.Equal(p1, p2), p1, p2).Compile();GreaterThan = Expression.Lambda<;Func<;T, T, bool>;>;(Expression.GreaterThan(p1, p2), p1, p2).Compile();GreaterThanOrEqual = Expression.Lambda<;Func<;T, T, bool>;>;(Expression.GreaterThanOrEqual(p1, p2), p1, p2).Compile();LessThan = Expression.Lambda<;Func<;T, T, bool>;>;(Expression.LessThan(p1, p2), p1, p2).Compile();LessThanOrEqual = Expression.Lambda<;Func<;T, T, bool>;>;(Expression.LessThanOrEqual(p1, p2), p1, p2).Compile();}public Func<;T, T, T>; Add { get; private set; }public Func<;T, T, T>; Subtract { get; private set; }public Func<;T, T, T>; Multiply { get; private set; }public Func<;T, T, T>; Divide { get; private set; }public Func<;T, T, T>; Modulo { get; private set; }public Func<;T, T, bool>; Equal { get; private set; }public Func<;T, T, bool>; GreaterThan { get; private set; }public Func<;T, T, bool>; GreaterThanOrEqual { get; private set; }public Func<;T, T, bool>; LessThan { get; private set; }public Func<;T, T, bool>; LessThanOrEqual { get; private set; }}
ジェネリック四則演算用クラス
*{typeof(int), typeof(uint), typeof(short), typeof(ushort), typeof(long), typeof(ulong), typeof(byte),typeof(decimal), typeof(double)};
四則演算可能な型の一覧
メディアン(int)
*Console.WriteLine(iList.Median().ToString());
メディアン(double)
*Console.WriteLine(dList.Median().ToString());
メディアン(DateTime)
*Console.WriteLine(dtList.Median().ToString());

*const int WEEK_MAX = 7;
マジックナンバーは禁止

プロジェクト名の抽出
*string currDirPath = Directory.GetCurrentDirectory();
*string addition = $"<;CodeAnalysisRuleSet>;{projectName}.ruleset<;/CodeAnalysisRuleSet>;";
.csprojの内容を置換

引数で渡すメソッドの型をdelegateで宣言
*public delegate void DELEGATE_PARAM_FUNC(int count);
関数本体の宣言
*[DllImport("PInvokeTest_delegate.dll", CallingConvention = CallingConvention.Cdecl)]

*.OrderBy(x =<; x)
.OrderByDescending(x =&gt; x)

*Close();
ソフトを終了
*{Close();}
キャンセルボタン押すと実行
*{// xamlに書いたTextBlockにエラーメッセージを設定errorText.Text = text;// 警告音を鳴らすSystem.Media.SystemSounds.Exclamation.Play();// ドロワーを出すerrorDrawer.IsBottomDrawerOpen = true;}
エラードロワーを開く
xamlに書いたTextBlockにエラーメッセージを設定
*errorText.Text = text;
警告音を鳴らす
*System.Media.SystemSounds.Exclamation.Play();
ドロワーを出す
*errorDrawer.IsBottomDrawerOpen = true;

*else MessageBox.Show("選択したのはPictureBoxではありません！");
(追加変更）

左辺をFormattableStringにできる
*FormattableString s = $"";
文字列補間を使用しない場合は代入できない
型 'string' を 'System.FormattableString' に暗黙的に変換できません
*FormattableString s = "";
varを使用した場合はstringになる
*var s = $"";
*// hello {0}!
出力
*{var f = fs.Format;for (var i = 0; i <; fs.ArgumentCount; i++){var target = "{" + i + "}";f = f.Replace(target, target + target);}return string.Format(f, fs.GetArguments());}
挿入される文字列を2倍にするメソッド
出力
hello world!
hello worldworld!
*,,,
文字列を作る
*var s = Template(i, j);
*foreach (var line in s.Split('\n'))*{
文字列をパースしてDictionary&lt;string,string&gt;に変換する
出力
key:i value:100
key:j value:200
*,,,
テンプレートからキーの部分のみを取り出す
*var keys = GetKeys(template);
DictionaryBuilder.Createでテンプレートを作成
ネストも可能
*var builder = DictionaryBuilder.Create<;(int i, int j)>;(p =>; $@"
*foreach (var kv in builder.ToDictionary((30, 40)))*{
テンプレートを元にDictionaryを作成
SetTextを行うとTextMeshProが内部に持っているバッファに文字情報が設定される
内部に持っているバッファはcharの配列なので文字列をアロケーションする必要がない
逆に言うと文字列にできないのでフォーマットのパースやchar配列への変換などは全部自力でやらなければならない
*text.SetText("i: {0} j: {1}", 1, 2);
文字情報を内部のchar配列にためるBuilder
*var sb = new CharBufferedStringBuilder();
*var fsb = new FormatStringBuilder<;(int i, int j)>;(p =>; $"i: {p.P(t =>; t.i)}, j: {p.P(t =>; t.j)}");
文字列補間からテンプレートの作成
テンプレートを適用
バッファサイズが足りなくならない限りはゼロアロケーション
適用時に毎回パースしなくて済むので多少効率的(かもしれない)
*fsb.Apply(sb, (100, 200));

*{ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<;string>;(){"010-1111-2222","020-2222-3333",},};
シリアライズ
*Console.WriteLine(string.Join("\n", typeof(Account).GetProperties().Select(info =>; $"{info.Name}: {info.GetValue(obj)}")));
デシリアライズ
*{ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<;string>;(){"010-1111-2222","020-2222-3333",},};
シリアライズ
*public AccountRole Role { get; set; }
[JsonConverter]付けない
*var json = $@"{{""ID"": 999,""Name"": ""foo"",""IsActive"": true,""CreatedDate"": ""2020-01-02T03:04:05+09:00"",""Role"": ""Role2""}}";
デシリアライズ
*var json = $@"{""ID"": 999,""Name": ""foo"",""IsActive"": true,""CreatedDate"": ""2020-01-02T03:04:05+09:00""}}";
デシリアライズ
*var json = $@"{""ID"": 999,""Name"": ""foo"",""IsActive"": true,""CreatedDate"": ""2020-01-02T03:04:05+09:00"",""Role"": null}}";
デシリアライズ
*{ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<;string>;(){"010-1111-2222","020-2222-3333",},};
シリアライズ
*{ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<;string>;(){"010-1111-2222","020-2222-3333",},};
シリアライズ
*{ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<;string>;(){"010-1111-2222","020-2222-3333",},};
シリアライズ
*var json = $@"{{""ID"": 999,""Name"": ""foo"",""IsActive"": true,""CreatedDate"": ""2020/01/02 03:04:05"",""Role"": ""Role2""}}";
デシリアライズ
*var json = $@"{{""ID"": 999,""Name"": ""foo"",""IsActive"": true,""CreatedDate"": ""2020.01.02 03.04.05"",""Role"": ""Role2""}}";
デシリアライズ
*{ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<;string>;(){"010-1111-2222","020-2222-3333",},Address = new Account.AccountAddress(){Address1 = "address1",Address2 = "address2",},};
シリアライズ
*{ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<;string>;(){"010-1111-2222","020-2222-3333",},};
シリアライズ
*{ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<;string>;(){"010-1111-2222","020-2222-3333",},};
シリアライズ
*{ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<;string>;(){"010-1111-2222","020-2222-3333",},};
シリアライズ
*var json = $@"{{""user_id"": 999,""name"": ""foo"",""active"": true,""created_date"": ""2020/01/02 03:04:05"",""role"": ""Role2"",""note"": ""メモ"",""hoge"": ""fuga""}}";
デシリアライズ
*var json = $@"{{""user_id"": 999,""name"": ""foo"",""active"": true,""created_date"": ""2020/01/02 03:04:05"",""role"": ""Role2"",""telephone"": [""010-1111-2222"", ""020-2222-3333""],""address"": {{""address1"":""住所１"", ""address2"":""住所２""}}}}";
デシリアライズ
*{var serializer = new JsonSerializer();serializer.Serialize(writer, account);}
シリアライズ
*{var serializer = new JsonSerializer();var obj = (Account) serializer.Deserialize(reader, typeof(Account));Console.WriteLine($"ID: {obj.ID}");Console.WriteLine($"Name: {obj.Name}");Console.WriteLine($"IsActive: {obj.IsActive}");Console.WriteLine($"CreatedDate: {obj.CreatedDate}");Console.WriteLine($"Role: {obj.Role}");Console.WriteLine($"Note: {obj.Note}");Console.WriteLine($"Telephones: {string.Join(", ", obj.Telephones)}");Console.WriteLine($"Addresses: {obj.Address.Address1}, {obj.Address.Address2}");}
デシリアライズ

*new PivotColumn<;MockData>;("initial",(t)=>;t.car.Substring(0,1),(t)=>;t.car.Substring(0,1)){Order=PivotOrder.Descending,},
carの頭文字を逆順で集計
スペース区切りのJobの最初の単語をカテゴリとして集計
*new PivotColumn<;MockData>;("category",(t)=>;t.Job.Split(' ').First(),(t)=>;t.Job.Split(' ').First()),
スペース区切りのJobの2番め以降をJobとして集計
*new PivotColumn<;MockData>;("Job",(t)=>;string.Join(" ",t.Job.Split(' ').Skip(1))),
集計するのはcashの平均値
*PivotMeasure<;MockData>;.Average("Avg.Cash",(t)=>;t.cash),

*child[i] = parent.transform.GetChild(i).gameObject;
子オブジェクト取得

印刷するプリンタ名を取得
*var printerName = ConfigurationManager.AppSettings["PrinterName"];
UWPから渡ってきた値を取得する
*var text = Windows.Storage.ApplicationData.Current.LocalSettings.Values["Key"].ToString();
印刷
*printingText = text;
都合いい感じに印刷処理を書く
*e.Graphics.DrawString(printingText, printFont, Brushes.Black, 0, 0);

*Regex re = new Regex(@"https:
qiita-image-store.s3.amazonaws.com.*\.png");

*int[] numbers = new int[7] { 0, 1, 2, 3, 4, 5, 6 };
The Three Parts of a LINQ Query:
*int[] numbers = new int[7] { 0, 1, 2, 3, 4, 5, 6 };
1. Data source.
(クエリ式)
*var numQuery =
(メソッド式)
var numQuery = numbers.where(num =&gt; num % 2 == 0);
3. Query execution.
*foreach (int num in numQuery)

プロパティーのIDを取得しておく　SetColorをstringで指定しても結局intに変換してるらしく、無駄らしい
*propertyID = Shader.PropertyToID("_Color");
ランダムな値
*float randomValueA = Random.Range(-1.0f, 1.0f);
*float randomMagnification = Random.Range(0.0f, 5.0f);*//ランダムな位置にキューブ生成
ランダムな値
ランダムな位置にキューブ生成
*Vector3 randomPos = new Vector3(randomValueA, randomValueB, randomValueC);
MaterialPropertyBlockで色を変更　元のマテリアルの色はそのまま
*MeshRenderer mr = tmp.GetComponent<;MeshRenderer>;();

*{//kは非nullが確定しているが警告が出る//CS8629    Null 許容値型は Null になる場合があります。return Enumerable.Range(0, 10).Select((i) =>; ToIntOrNull(i)).Where((j) =>; j != null).Select((k) =>; (int)k);}

kは非nullが確定しているが警告が出る
CS8629    Null 許容値型は Null になる場合があります。
*return Enumerable.Range(0, 10)
!演算子をつければ警告は出ない
*return Enumerable.Range(0, 10)

*.HasForeignKey(x =<; new { x.Gaibuki });
子テーブル側の、外部キーの設定
ダメ
modelBuilder.Entity&lt;Table12&gt;()
.HasOptional(x =&gt; x.Table11)
.WithMany(x =&gt; x.Table12s)
.HasForeignKey(x =&gt; new { x.Gaibuki });
OK
*modelBuilder.Entity<;Table13>;()
これもOK
modelBuilder.Entity&lt;Table13&gt;()
.HasRequired(x =&gt; x.Table11)
.WithMany(x =&gt; x.Table13s)
.HasForeignKey(x =&gt; new { x.Gaibuki });
*,,,

*foreach (MyEnum id in Enum.GetValues(typeof(MyEnum)))*{
CS8605 null の可能性がある値をボックス化解除しています。
何かしらの処理
*}
*foreach (var id in Enum.GetValues(typeof(MyEnum)).Cast<;MyEnum>;())*{
警告が出ない。少し長くなったが、型名をvarに変更できていい感じ
何かしらの処理
*}

*while (!isAllBingo)
全てのカードがビンゴするまで繰り返す

*void LockRectTransformProperty()*{
Layout Groupみたいに「Some values driven by 〜」とInspector上の編集を禁止する

メンバー変数が変更されるかどうかわからない
*}
メンバー変数が変更されることはない
*}
引数のListが変更されるかどうかがわからない
*}
引数のListが変更されないことが明示的
*}
*public List<;int>; IntList { get { return m_IntList} }
そのまま返す場合
*public List<;int>; IntList { get { return m_IntList} }
中身の変更が可能なので変更されてもいい場合以外はだめ
*public int[] IntList { get { return m_IntList.ToArray(); } }
Arrayに変換する場合
*public int[] IntList { get { return m_IntList.ToArray(); } }
基本的にはこれで問題ないと思う
IReadOnlyListとして公開する
変更されたくないのが明示的。クラスの外からは基本的に変更されないはず
キャストすれば変更可能だけど...そこまでして変更する必要のある場合ともとれる？
*public IReadOnlyList<;int>; IntList { get { return m_IntList; } }
*public int AnyValue { set; get; }
クラスの外から変更可能
*public int AnyValue { private set; get; }
クラスの外から変更不可
変更の必要がない場合get-onlyプロパティ
*Name= name;
*string Hoge1 { get; }
プロパティはインターフェースでももてる
これはだめ。フィールドはもてない
*readonly string Hoge2;

*string ISS = "http:
localhost:5000op";

.csxだと直値を出力とかはできない. 以下はエラーとなるので注意.
"Hello, World!!"
*,,,
以下を追記して、VSCodeで開きなおす
*#r "nuget: Utf8Json"

*public GameObject explosionPrefab;
爆発エフェクトのPrefab
衝突したときにスコアを更新する
*GameObject.Find("Canvas").GetComponent<;UIController>;().AddScore();
*GameObject effect = Instantiate(explosionPrefab, transform.position, Quaternion.identity) as GameObject;*Destroy(effect, 1.0f);
爆発エフェクトを生成
Instantiate(第１関数,第２関数,第３関数);
*,,,
InvokeRepeating(第１関数, n, m);
*,,,
*GameObject effect = Instantiate(explosionPrefab, transform.position, Quaternion.identity) as GameObject;*Destroy(effect, 1.0f);
爆発エフェクトを生成

POSTパラメータ取得
*string body = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync();
*if (client == null) {return new AccessToken {error = "unauthorized_client", error_description="client authentication failed."};}
POSTパラメータclient_idチェック
access_token発番(authorization_code/client_credentials/password/refresh_token)
*string random = Guid.NewGuid().ToString("N").ToUpper();
refresh_token発番(authorization_code/password/refresh_token)
*string refresh = Guid.NewGuid().ToString("N").ToUpper();
*if (client.GrantTypes != GRANT_TYPE) {*return new AccessToken {error = "unsupported_response_type", error_description="the response_type value is not supported."};
要求のgrant_typeをチェック
*if (client.GrantTypes == "client_credentials") {*// usernameはadmin固定
要求がclient_credentialsの場合
usernameはadmin固定
*USERNAME = "admin";
refresh_tokenは発行しない
*refresh = null;
*if (client.GrantTypes == "password") {*// 要求のusernameをチェック
要求がpasswordの場合
*if (user == null ) {return new AccessToken {error = "access_denied", error_description="user authentication failed."};}
要求のusernameをチェック
*if (!Util.PasswordEqual(user.PasswordHash, PASSWORD)) {*return new AccessToken {error = "access_denied", error_description="user authentication failed."};
要求のpasswordを共通関数でチェック
*if (SCOPE != null) {string[] s =  SCOPE.Split(' ');for (int j=0; j<;s.Length; j++){if (s[j]!="openid" &amp;&amp; client.AllowedScope.Contains(s[j])) t=t+" "+s[j];}}
scopeはopenidを最小限とする
要求scopeと許可scopeのANDをとる
*SCOPE=t;
*if (client.AccessType == "confidential") {*// 要求のclient_secretチェック
機密クライアントの場合
*if (client.ClientSecret != CLIENT_SECRET) {*return new AccessToken {error = "invalid_request", error_description="client authentication failed."};
要求のclient_secretチェック
*} else if (client.AccessType == "public") {*// 要求がclient_credentialsではないかチェック
公開クライアントの場合
*if (client.GrantTypes == "client_credentials") {*return new AccessToken {error = "invalid_request", error_description="client authentication failed."};
要求がclient_credentialsではないかチェック
*if (CLIENT_SECRET != null) {*return new AccessToken {error = "invalid_request", error_description="client authentication failed."};
要求にclient_secretは不要
*} else {
不明の場合
*if (token != null) {_context.Tokens.Remove(token);await _context.SaveChangesAsync();}
削除タイミングがないためaccess_tokenは１ユーザーにつき１つの制限
*token = new Token {UserId = USERNAME, AccessToken = random, ClientId = CLIENT_ID, RefreshToken=refresh, Scope = SCOPE, Iat=DateTime.Now};
有効期限60秒固定のaccess_tokenを発行
*return new AccessToken {access_token = random, expires_in=60, token_type="bearer", scope = SCOPE};
access_tokenを返す

*int directionInt = 0;
0:上

2次元配列
* Table/表
*public class Sample : MonoBehaviour
宣言方法
１次元配列
*int[] arrayInt = new int[3];
2次元配列
*int[,] tabelInt = new int[3, 2];
代入方法
*tabelInt[0, 0] = 1;
取得方法
int x = tabelInt[0, 0];
長さ
Debug.Log(arrayInt.Length);
*Debug.Log(tabelInt.GetLength(0));

*issuer: "http:
localhost:5000op",
*//  {public DbSet<;Client>; Clients { get; set; }public DbSet<;Token>; Tokens { get; set; }public DbSet<;Code>; Codes { get; set; }//        protected override void OnConfiguring(DbContextOptionsBuilder options)//            =>; options.UseSqlite("Data Source=app.db");}
public class myopContext : DbContext
*public DbSet<;Client>; Clients { get; set; }
{

*return (ctx) =>; {// Schedule child activitiesif (Body != null)ctx.ScheduleAction<;IObjectContainer>;(Body, _objectContainer, OnCompleted, OnFaulted);// Outputs};
Inputs
*if (Body != null)*ctx.ScheduleAction;IObjectContainer>;(Body, _objectContainer, OnCompleted, OnFaulted);
Schedule child activities
*if (Body != null)*ctx.ScheduleAction;IObjectContainer>;(Body, _objectContainer, OnCompleted, OnFaulted);
Schedule child activities
*return (ctx) =>; {OutString.Set(ctx, str);};
Outputs

*Vector3 worldClickPos = Camera.main.ScreenToWorldPoint(Input.mousePosition +  Camera.main.transform.forward);*//マウス押した瞬間
スクリーン座標をワールド座標に変換
*if (Input.GetMouseButtonDown(0))*{
マウス押した瞬間
*if (Input.GetMouseButton(0))*{
マウス押し続けている間
全ての頂点を取ってくる
*int vertCount =  tr.GetPositions(posArray);
*for (int i = 0; i <; vertCount; i++)*{
描画した頂点座標を確認

*int[] lastBusinessDays = new int[7];
日、月、火、水、木、金、土

Hanbetsuメソッドは抽象メソッド
*public abstract double Hanbetsu(double a, double b, double c);
*{return Math.Pow(b, 2.0) - 4.0 * a * c;}
基本クラスの抽象メソッドは必ずオーバーライドする

*while(date.CompareTo(endDate) == -1)
-1で以前、0で同じ、1で以後

MakeCredentialAsync()、GetAssertionAsync()で
PIN認証が通ってFIDOキーのタッチ待ちになるとこのイベントが発生します
*}
*} else if (res.DeviceStatus == g.FIDO2.CTAP.DeviceStatus.Timeout) {
FIDOキーが接続されていない場合
*} else if (res.DeviceStatus == g.FIDO2.CTAP.DeviceStatus.Ok) {
FIDOキーのタッチ待ちでTimeoutした場合
*var v = new AttestationVerifier();*var verify = v.Verify(rpid,challenge, res.CTAPResponse.Attestation);
verify
*creid = verify.CredentialID.ToArray();*pubkey = verify.PublicKeyPem;
store
MakeCredentialAsync()、GetAssertionAsync()で
PIN認証が通ってFIDOキーのタッチ待ちになるとこのイベントが発生します
*}
*} else if (res.DeviceStatus == g.FIDO2.CTAP.DeviceStatus.Timeout) {
FIDOキーが接続されていない場合
*} else if (res.DeviceStatus == g.FIDO2.CTAP.DeviceStatus.Ok) {
FIDOキーのタッチ待ちでTimeoutした場合
*var v = new AssertionVerifier();*var verify = v.Verify(rpid,pubkey,challenge, res.CTAPResponse.Assertion);
verify

*private string URL = "https:
expired.badssl.com";
CefCharp初期設定
*CefSettings set = new CefSettings();
CefSharpのWebViewを作成する。
ページを表示。
*cefBrowser = new ChromiumWebBrowser(URL);
コントロールを追加する。
*this.Controls.Add(cefBrowser);
先ほど実装したRequestHandlerをインスタンス化
*cefBrowser.RequestHandler = new ExampleRequestHandler();

*int month = random.Next(1, 13);
無作為に選ぶ
year年month月13日が金曜日ですか？
*DateTime date = new DateTime(year, month, 13);

*sql += $" Where Author like '%{author}%'";
危険なコード！
省略...
*,,,
fuzz.txt の１行を１テストケースとして定義
※後述の Parameters プロパティを参照
*[Theory]
*{// テーブルを空にしておくdb.Posts.RemoveRange(db.Posts.ToArray());// SQL が正しく実行されれば、この Entity が帰ってくるはずdb.Posts.Add(new BlogPost() { Author = param, Title = "test" });// こっちは帰ってこないはずdb.Posts.Add(new BlogPost() { Author = "Dummy", Title = "Dummy" });db.SaveChanges();}
* Arrange
テーブルを空にしておく
*db.Posts.RemoveRange(db.Posts.ToArray());
*db.Posts.Add(new BlogPost() { Author = param, Title = "test" });
SQL が正しく実行されれば、この Entity が帰ってくるはず
*db.Posts.Add(new BlogPost() { Author = "Dummy", Title = "Dummy" });
こっちは帰ってこないはず
実行に5秒以上かかったら Blind な SQL Injection が成功してるのでNG
*Assert.True(sw.ElapsedMilliseconds <; 5000, "Blind SQL Injection");
正しいSQL文が発行されていれば１件の結果が返ってくるはず
*Assert.Equal(param, result.Single().Author);
*{get{var f = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "fuzz.txt");var r = File.ReadAllLines(f).Where(l =>; !string.IsNullOrWhiteSpace(l)).Select(l =>; new object[] { l }).ToArray();return r;}}
SqlInjectionTest で使う入力データ列

*cal[line][column] = string.Format("{0,2}", day);
プラスで右寄せ、マイナスで左寄せ

Redoボタンが押されたらFunctionステートを変更
*_redoButtonObj.InteractableStateChanged.AddListener(modeChangeToRedo);
Undoボタンが押されたらFunctionステートを変更
*_undoButtonObj.InteractableStateChanged.AddListener(modeChangeToUndo);
Paintボタンが押されたらFunctionステートを変更
*_paintButtonObj.InteractableStateChanged.AddListener(modeChangeToPaint);

コンパイルは、コマンドラインから以下
c:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:winexe scr_cap.cs
*using System;

*this.Controls.Add(panel4);
フォーム(this)上にパネルpanel4を追加
イベントハンドラを登録
this.LocationChanged += new EventHandler(Form1_LocationChanged);     フォームが移動したことを検出
*}
*{//panel1label11.Text = "panel1の左上の座標";p11 = panel1.Location;label12.Text = "(1) panel1.Locationで示される座標(" + p11.X + "," + p11.Y + ")";p12 = this.PointToScreen(p11);label13.Text = "(2) this.PointToScreen( (1)の座標系 ) で求められたスクリーン(モニタ)の左上を基準にした座標(" + p12.X + "," + p12.Y + ") <;--- フォームをドラッグして動かすと、座標の表示が変わります。";p13 = this.PointToClient(p12);label14.Text = "(3) this.PointToClient( (2)のスクリーン座標系 ) で求められたフォーム(this)の左上を基準にした座標(" + p13.X + "," + p13.Y + ")     フォームを動かしても、(1)と同じ値。";p14 = panel1.PointToClient(p12);label15.Text = "(3) panel1.PointToClient( (2)のスクリーン座標系 ) で求められたpanel1の左上を基準にした座標(" + p14.X + "," + p14.Y + ")";//panel2label21.Text = "panel2の左上の座標";p21 = panel2.Location;label22.Text = "(1) Locationメソッドで示される座標(" + p21.X + "," + p21.Y + ")";p22 = panel1.PointToScreen(p21);label23.Text = "(2) panel1.PointToScreen( (1)の座標系 ) で求められたスクリーン(モニタ)の左上を基準にした座標(" + p22.X + "," + p22.Y + ") <;--- フォームをドラッグして動かすと、座標の表示が変わります。";p23 = this.PointToClient(p22);label24.Text = "(3) this.PointToClient( (2)のスクリーン座標系 ) で求められたフォーム(this)の左上を基準にした座標(" + p23.X + "," + p23.Y + ") ";p24 = panel1.PointToClient(p22);label25.Text = "(4) panel1.PointToClient( (2)のスクリーン座標系 ) で求められたpanel1の左上を基準にした座標(" + p24.X + "," + p24.Y + ")     フォームを動かしても、(1)と同じ値。";p25 = panel2.PointToClient(p22);label26.Text = "(5) panel2.PointToClient( (2)のスクリーン座標系 ) で求められたpanel2の左上を基準にした座標(" + p25.X + "," + p25.Y + ")";//panel3label31.Text = "panel3の左上の座標";p31 = panel3.Location;label32.Text = "(1) Locationメソッドで示される座標(" + p31.X + "," + p31.Y + ")";p32 = panel2.PointToScreen(p31);label33.Text = "(2) panel2.PointToScreen( (1)の座標系 ) で求められたスクリーン(モニタ)の左上を基準にした座標(" + p32.X + "," + p32.Y + ") <;--- フォームをドラッグして動かすと、座標の表示が変わります。";p33 = this.PointToClient(p32);label34.Text = "(3) this.PointToClient( (2)のスクリーン座標系 ) で求められたフォーム(this)の左上を基準にした座標(" + p33.X + "," + p33.Y + ") ";p34 = panel1.PointToClient(p32);label35.Text = "(4) panel1.PointToClient( (2)のスクリーン座標系 ) で求められたpanel1の左上を基準にした座標(" + p34.X + "," + p34.Y + ")";p35 = panel2.PointToClient(p32);label36.Text = "(5) panel2.PointToClient( (2)のスクリーン座標系 ) で求められたpanel2の左上を基準にした座標(" + p35.X + "," + p35.Y + ")     フォームを動かしても、(1)と同じ値。";p36 = panel3.PointToClient(p32);label37.Text = "(6) panel3.PointToClient( (2)のスクリーン座標系 ) で求められたpanel3の左上を基準にした座標(" + p36.X + "," + p36.Y + ")";//panel4label41.Text = "panel4の左上の座標";p41 = panel4.Location;label42.Text = "(1) Locationメソッドで示される座標(" + p41.X + "," + p41.Y + ")";p42 = this.PointToScreen(p41);label43.Text = "(2) this.PointToScreen( (1)の座標系 ) で求められたスクリーン(モニタ)の左上を基準にした座標(" + p42.X + "," + p42.Y + ") <;--- フォームをドラッグして動かすと、座標の表示が変わります。";p43 = this.PointToClient(p42);label44.Text = "(3) this.PointToClient( (2)のスクリーン座標系 ) で求められたフォーム(this)の左上を基準にした座標(" + p43.X + "," + p43.Y + ")      フォームを動かしても、(1)と同じ値。";p44 = panel1.PointToClient(p42);label45.Text = "(4) panel1.PointToClient( (2)のスクリーン座標系 ) で求められたpanel1の左上を基準にした座標(" + p44.X + "," + p44.Y + ")";p45 = panel2.PointToClient(p42);label46.Text = "(5) panel2.PointToClient( (2)のスクリーン座標系 ) で求められたpanel2の左上を基準にした座標(" + p45.X + "," + p45.Y + ")";p46 = panel3.PointToClient(p42);label47.Text = "(6) panel3.PointToClient( (2)のスクリーン座標系 ) で求められたpanel3の左上を基準にした座標(" + p46.X + "," + p46.Y + ")";}
フォームを移動した時に実行

*__hogeName = db.GetHogeName(HogeCode) ;
DBから名前取ったりとか
名前を取り出す。名前は別テーブルに入ってるのでHogeCodeを元に取得
*string HogeName =>; dictionary.Get<;string>;(()=>; db.GetHogeName(HogeCode) );

DataTableを取得
string connectionString = "環境に合わせた接続文字列";  接続文字列
string commandText = "SELECT UserId, UserName FROM Users";  Usersテーブル取得SQL
*SqlDataAdapter adapter = new SqlDataAdapter(commandText, connectionString);
DataGridへセット
*UsersDataGrid.DataContext = ConvertDataTable(table);

*if (G.DispIcon != 0)*{
毎秒処理
bitmap =&gt; bitmapHandler =&gt; ImageSource(参考）
*IntPtr Hbitmap = bitmap.GetHbitmap();

指定ブラケットに一致するかどうか
*var sb = new StringBuilder();
*{// 文字長を超えるならブラケット処理なしif (value.Length - 1 <; index + startBracket.Length - 1){return;}// ブラケットに合致しなければ処理なしif (!IsMatchBracket(index, startBracket)){return;}openCount++;if (!started){startIndex = index;}started = true;};
開始ブラケット処理
*if (value.Length - 1 <; index + startBracket.Length - 1)*{
文字長を超えるならブラケット処理なし
*if (!IsMatchBracket(index, startBracket))*{
ブラケットに合致しなければ処理なし
*{// 文字長を超えるならブラケット処理なしif (value.Length - 1 <; index + endBracket.Length - 1){return;}// ブラケットに合致しなければ処理なしif (!IsMatchBracket(index, endBracket)){return;}openCount--;};
終了ブラケット処理
*if (value.Length - 1 <; index + endBracket.Length - 1)*{
文字長を超えるならブラケット処理なし
*if (!IsMatchBracket(index, endBracket))*{
ブラケットに合致しなければ処理なし

*int separater = 10;
分割ライン高さ

*var servers = (await c.GetStringAsync("http:
lst10s-sp.wni.co.jpserver_list.txt").ConfigureAwait(false)).Split('\n');
受信したら OnReceiveData が発火し、電文が渡される
*client.OnReceiveData += Console.WriteLine;

*return (ctx) =>; {C.Set(ctx, null);};
Outputs

*var isEqual = actual == expect
False

*Vector2 spos = RectTransformUtility.WorldToScreenPoint(Camera.main, trfTarget.position);*Vector2 pos;
World座標をUI座標へ変換
左下を計算上のpivotにする
*var imgsize = new Vector2(trfTarget.rect.width * trfTarget.localScale.x,trfTarget.rect.height * trfTarget.localScale.y);
CanvasのRectTransformから解像度とピボットを取り、左下0にする
*var resetpos = new Vector2(imgpos.x + (ressize.x * piv.x),imgpos.y + (ressize.y * piv.y));
リニア化　(minx,miny,解像度xに対する横の割合,解像度yに対する高さの割合)
*rct = new Vector4(resetpos.x / ressize.x, resetpos.y / ressize.y, imgsize.x / ressize.x, imgsize.y / ressize.y);

*{double[][] d = new double[p1.R][];if (p1.C == p2.C &amp;&amp; p1.R == p2.R){for (int i = 0; i <; p1.R; i++){d[i] = new double[p1.C];for (int j = 0; j <; p1.C; j++){d[i][j] = p1.Matrix_data[i][j] + p2.Matrix_data[i][j];}}}else{for (int k = 0; k <; p1.R; k++){d[k] = new double[2] { 0, 0 };}}return d;}
以下　演算子オーバーロード

パラメータIDのリスト
*List<;int>; parameterIds = new List<;int>;();
パラメータ名のリスト
*List<;String>; parameterNames = new List<;String>;();
パラメータID毎にデータが格納されたディクショナリ
*Dictionary<;int, Dictionary<;int, Double>;>; parameterId2ValueMap = new Dictionary<;int, Dictionary<;int, Double>;>;();
*if (i != j)*{
ScatterPlotを作成
データ
*int parameterIdX = parameterIds[j];
*{series.ChartType = SeriesChartType.Column;series.Color = Color.Blue;int parameterId = parameterIds[i];Dictionary<;int, double>; valueMap = parameterId2ValueMap[parameterId];Histogram hist = new Histogram(valueMap.Values, nBuckets, -50, 50);for (int k = 0; k <; nBuckets; k++){double mid = Math.Round((hist[k].UpperBound + hist[k].LowerBound) / 2, 1);series.Points.Add(new DataPoint(mid, hist[k].Count));}}
ヒストグラムを作成
*g.TranslateTransform(0, this.height);*// -90度回転
原点を移動
*g.RotateTransform(-90f);*// 文字列を描画
-90度回転
*for(int i=0; i<;parameterIds.Count; i++)*{
文字列を描画
*g.ResetTransform();*}
元に戻す

*int[] list = new int[N];
1 -&gt; 休業日、0 -&gt; 営業日
*if(list[left] == 1)*{
leftを増やす、oneとzeroを調整

*input = Console.ReadLine().Split(' ');
1なら休業日、0なら営業日

*B::hoge();
HOGEHOGE namespace内にあるBクラス。読み込み可

*prepos = pos;
今のフレームの位置を次のフレームにおける前のフレームの位置として保存

*{// 玉がぶつかった回数を記憶する int hitCountint hitCount = 0;// Start後にオブジェクト自身のRigidbodyを参照して情報を格納するためのrbpublic Rigidbody rb;// GameObject型のDamageLevels、GameObjectのもの(ボログルマ3形態)のみ配列に入れるpublic GameObject[] DamageLevels;// 煙エフェクト Unity側でSmokeをドロップするpublic GameObject SmokePt;void Start(){// 自分のRigidbodyを格納して参照するrb = GetComponent<;Rigidbody>;();// 3段階で壊れるボログルマを配列で用意DamageLevels = new GameObject[3];// ダメージレベルが上がったら各ダメージレベルのオブジェクトを呼ぶくりかえしfor(var n = 0; n <; 3; n++){// 1段階壊れたオブジェクトから後+1ずつ呼び出す、3段階目まで// 非アクティブ(ディアクティベート)状態の子オブジェクトも取得できるtransform.Find/*(子オブジェクトの参照先がみつからない、原因分からず)NullReferenceException: Object reference not set to aninstance of an objectDestruction.Start () (at Assets/Destruction.cs:35)*/DamageLevels[n] = transform.Find("damage_level1" + (n + 1)).gameObject;}}// BulletBehaviour.csから送られてきたら反応するAdd_Damageメソッドvoid Add_Damage(){// 玉がぶつかるたびに煙のsmをinstantiate(インスタンス化する、シーン中に表示させる)GameObject sm = Instantiate(SmokePt, transform.position, transform.rotation);// smoke出現後はボログルマを親とするsm.transform.parent = transform;// hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わりif (hitCount >; 2)return;// ボログルマのダメージが0の状態はSmokeを非表示DamageLevels[hitCount].SetActive(false);// インクリメント hitCountという整数の値に１を足すことhitCount++;// ボログルマのダメージ1以上の状態はSmokeを表示DamageLevels[hitCount].SetActive(true);}}
P.228 玉がボログルマに着弾するとボログルマがだんだん壊れていくスクリプト
玉がぶつかった回数を記憶する int hitCount
*int hitCount = 0;
Start後にオブジェクト自身のRigidbodyを参照して情報を格納するためのrb
*public Rigidbody rb;
GameObject型のDamageLevels、GameObjectのもの(ボログルマ3形態)のみ配列に入れる
*public GameObject[] DamageLevels;
煙エフェクト Unity側でSmokeをドロップする
*public GameObject SmokePt;
自分のRigidbodyを格納して参照する
*rb = GetComponent<;Rigidbody>;();
3段階で壊れるボログルマを配列で用意
*DamageLevels = new GameObject[3];
*for(var n = 0; n <; 3; n++)*{
ダメージレベルが上がったら各ダメージレベルのオブジェクトを呼ぶくりかえし
*// 非アクティブ(ディアクティベート)状態の子オブジェクトも取得できるtransform.Find*/*(子オブジェクトの参照先がみつからない、原因分からず)NullReferenceException: Object reference not set to an
1段階壊れたオブジェクトから後+1ずつ呼び出す、3段階目まで
非アクティブ(ディアクティベート)状態の子オブジェクトも取得できるtransform.Find
*/*(子オブジェクトの参照先がみつからない、原因分からず)NullReferenceException: Object reference not set to an
*{// 玉がぶつかるたびに煙のsmをinstantiate(インスタンス化する、シーン中に表示させる)GameObject sm = Instantiate(SmokePt, transform.position, transform.rotation);// smoke出現後はボログルマを親とするsm.transform.parent = transform;// hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わりif (hitCount >; 2)return;// ボログルマのダメージが0の状態はSmokeを非表示DamageLevels[hitCount].SetActive(false);// インクリメント hitCountという整数の値に１を足すことhitCount++;// ボログルマのダメージ1以上の状態はSmokeを表示DamageLevels[hitCount].SetActive(true);}
BulletBehaviour.csから送られてきたら反応するAdd_Damageメソッド
*GameObject sm = Instantiate(SmokePt, transform.position, transform.rotation);*// smoke出現後はボログルマを親とする
玉がぶつかるたびに煙のsmをinstantiate(インスタンス化する、シーン中に表示させる)
*sm.transform.parent = transform;*// hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わり
smoke出現後はボログルマを親とする
*if (hitCount >; 2)*return;
hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わり
ボログルマのダメージが0の状態はSmokeを非表示
*DamageLevels[hitCount].SetActive(false);
インクリメント hitCountという整数の値に１を足すこと
*hitCount++;
ボログルマのダメージ1以上の状態はSmokeを表示
*DamageLevels[hitCount].SetActive(true);
*{// 玉がぶつかった回数を記憶する int hitCountint hitCount = 0;// Start後にオブジェクト自身のRigidbodyを参照して情報を格納するためのrbpublic Rigidbody rb;// GameObject型のDamageLevels、GameObjectのもののみ配列に入れるpublic GameObject[] DamageLevels;// 煙エフェクト Unity側でSmokeをドロップするpublic GameObject SmokePt;// ビルトイン配列を定義 配列数を指定して子オブジェクトをtransform.Findで探す、damage_levelのGameObjectvoid Start(){rb = GetComponent<;Rigidbody>;();DamageLevels = new GameObject[3];DamageLevels[0] = transform.Find("damage_level1").gameObject;DamageLevels[1] = transform.Find("damage_level2").gameObject;DamageLevels[2] = transform.Find("damage_level3").gameObject;}/*// For文を使うともう少しすっきりする// (子オブジェクトの参照先がみつからない、原因分からず)NullReferenceException: Object reference not set to an instance of an objectDestruction.Start () (at Assets/Destruction.cs:47)void Start(){// 自分のRigidbodyを格納して参照するrb = GetComponent<;Rigidbody>;();// 3段階で壊れるボログルマを配列で用意DamageLevels = new GameObject[3];// ダメージレベルが上がったら各ダメージレベルのオブジェクトを呼ぶくりかえしfor(var n = 0; n <; 3; n++){// 1段階壊れたオブジェクトから後+1ずつ呼び出す、3段階目まで// 非アクティブ(ディアクティベート)状態の子オブジェクトも取得できるtransform.FindDamageLevels[n] = transform.Find("damage_level1" + (n + 1)).gameObject;}}*/// BulletBehaviour.csから送られてきたら反応するAdd_Damageメソッドvoid Add_Damage(){// 玉がぶつかるたびに煙のsmをinstantiate(インスタンス化する、シーン中に表示させる)GameObject sm = Instantiate(SmokePt, transform.position, transform.rotation);// smoke出現後はボログルマを親とするsm.transform.parent = transform;// hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わりif (hitCount >; 2)return;// ボログルマのダメージが0の状態はSmokeを非表示DamageLevels[hitCount].SetActive(false);// インクリメント hitCountという整数の値に１を足すことhitCount++;// ボログルマのダメージ1以上の状態はSmokeを表示DamageLevels[hitCount].SetActive(true);}}
P.228 玉がボログルマに着弾するとボログルマがだんだん壊れていくスクリプト
玉がぶつかった回数を記憶する int hitCount
*int hitCount = 0;
Start後にオブジェクト自身のRigidbodyを参照して情報を格納するためのrb
*public Rigidbody rb;
GameObject型のDamageLevels、GameObjectのもののみ配列に入れる
*public GameObject[] DamageLevels;
煙エフェクト Unity側でSmokeをドロップする
*public GameObject SmokePt;
*{rb = GetComponent<;Rigidbody>;();DamageLevels = new GameObject[3];DamageLevels[0] = transform.Find("damage_level1").gameObject;DamageLevels[1] = transform.Find("damage_level2").gameObject;DamageLevels[2] = transform.Find("damage_level3").gameObject;}
ビルトイン配列を定義 配列数を指定して子オブジェクトをtransform.Findで探す、damage_levelのGameObject
For文を使うともう少しすっきりする
(子オブジェクトの参照先がみつからない、原因分からず)NullReferenceException: Object reference not set to an instance of an object
*Destruction.Start () (at Assets/Destruction.cs:47)
自分のRigidbodyを格納して参照する
*rb = GetComponent<;Rigidbody>;();
3段階で壊れるボログルマを配列で用意
*DamageLevels = new GameObject[3];
*for(var n = 0; n <; 3; n++)*{
ダメージレベルが上がったら各ダメージレベルのオブジェクトを呼ぶくりかえし
*// 非アクティブ(ディアクティベート)状態の子オブジェクトも取得できるtransform.Find*DamageLevels[n] = transform.Find("damage_level1" + (n + 1)).gameObject;
1段階壊れたオブジェクトから後+1ずつ呼び出す、3段階目まで
*DamageLevels[n] = transform.Find("damage_level1" + (n + 1)).gameObject;*}
非アクティブ(ディアクティベート)状態の子オブジェクトも取得できるtransform.Find
*{// 玉がぶつかるたびに煙のsmをinstantiate(インスタンス化する、シーン中に表示させる)GameObject sm = Instantiate(SmokePt, transform.position, transform.rotation);// smoke出現後はボログルマを親とするsm.transform.parent = transform;// hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わりif (hitCount >; 2)return;// ボログルマのダメージが0の状態はSmokeを非表示DamageLevels[hitCount].SetActive(false);// インクリメント hitCountという整数の値に１を足すことhitCount++;// ボログルマのダメージ1以上の状態はSmokeを表示DamageLevels[hitCount].SetActive(true);}
BulletBehaviour.csから送られてきたら反応するAdd_Damageメソッド
*GameObject sm = Instantiate(SmokePt, transform.position, transform.rotation);*// smoke出現後はボログルマを親とする
玉がぶつかるたびに煙のsmをinstantiate(インスタンス化する、シーン中に表示させる)
*sm.transform.parent = transform;*// hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わり
smoke出現後はボログルマを親とする
*if (hitCount >; 2)*return;
hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わり
ボログルマのダメージが0の状態はSmokeを非表示
*DamageLevels[hitCount].SetActive(false);
インクリメント hitCountという整数の値に１を足すこと
*hitCount++;
ボログルマのダメージ1以上の状態はSmokeを表示
*DamageLevels[hitCount].SetActive(true);
自分のRigidbodyを格納して参照する
*rb = GetComponent<;Rigidbody>;();
3段階で壊れるボログルマを配列で用意
*DamageLevels = new GameObject[3];
*for (var n = 0; n <; 3; n++)*{
ダメージレベルが上がったら各ダメージレベルのオブジェクトを呼ぶくりかえし
*DamageLevels[n] = GameObject.Find("damaged_transporter_01").transform.Find("damage_level1").gameObject;*}
アクティブなオブジェクト"damaged_transporter_01"をまず見つけ出し、その子オブジェクトを探索して"damage_level1"を見つける

既にボタンにイベントを登録していたら削除する.
*UnityEditor.Events.UnityEventTools.RemovePersistentListener(hogehogeEvent, TestCallback);
ボタンにイベントを登録する.
*UnityEditor.Events.UnityEventTools.AddPersistentListener(hogehogeEvent, TestCallback);
イベントの呼び出し
*hogehogeEvent.Invoke();

*DoubleAccounting = 34
二重下線(会計)

以下処理
*:

（中略）
*outputCsv.WriteRecord(record);
（中略）
*outputCsv.WriteRecord(record);

Drop Shadow効果設定
*var DSE = new DropShadowEffect();
時針描画
*Line hhLine = new Line();

*items.Select(a =<; a + 10).ToArray();
=&gt; [11, 12, 13]

正面に移動
*float posSpeed = _positionLerpSpeed;
正面方向に回転
*float rotSpeed = _rotationLerpSpeed;

Console.WriteLineがvoidなのでこういうことができない
*.Select(s =>; Console.WriteLine(s))
*T Transform<;T>;(Action a) =>; a.DynamicInvoke() == null ? default(T) : default;*// 戻り値voidがintに変換可能!!
DynamicInvokeを使用するとnullを戻り値として取得することができる
*Transform<;int>;(() =>; Console.WriteLine());*,,,
戻り値voidがintに変換可能!!
oがHogeの場合はhに代入されている
*}
式中でi,jを宣言して足し算する
1 + 2 = 3;
*Console.WriteLine(1 is var i ? 2 is var j ? i + j : default : default);
再帰関数も作れる
null is var は常にtrueになるので変数宣言に使用できる
*var res = (Func<;int, int>;)null is var fib ?

*Console.WriteLine(getCount());
536870911

*var v = random.NextDouble();
0.0 - 1.0
int型2つを引数にとり、double型を返す関数を登録できる
*Func<;int, int, double>; func = CreateRandomNumber;
CreateRandomNumber(0, 100)が実行される
*var result = func(0, 100);
関数をデリゲートに登録
*Func<;int, int, int>; func1 = Add;
ラムダ式で作った関数を登録
*Func<;int, int, int>; func2 = (x, y) =>; x + y;
呼び出し
*Console.WriteLine(func1(10, 20));
5秒経ったらログを出す
*_ = WaitForAsync(5, () =>; Console.WriteLine("5!"));
10秒経ったら別のログを出す
*_ = WaitForAsync(10, () =>; Console.WriteLine("10!"));
*{Console.WriteLine("Bye!");Dispose();});
30秒経ったらログを出して削除
整数配列のそれぞれの逆数の総和を計算する
*var reciprocalSum = array
Func&lt;int, float&gt; に Reciprocal()を登録
*.Select(Reciprocal)
*{return 1.0f / x;}
逆数を返す関数

*{RandomIndexList.Clear();// 条件に一致する要素のindexを取得しますfor (int i = 0; i <; ie.Count(); i++){if (predicate(ie.ElementAt(i))){RandomIndexList.Add(i);}}if (RandomIndexList.Count <; 1){throw new Exception("一致する要素がありません！");}// 抽出したindexから抽選して返しますint randomIndex = RandomIndexList[Random.Range(0, RandomIndexList.Count)];return ie.ElementAt(randomIndex);}
非同期実行時に同時アクセスしないようlockします
*for (int i = 0; i <; ie.Count(); i++)*{
条件に一致する要素のindexを取得します
抽出したindexから抽選して返します
*int randomIndex = RandomIndexList[Random.Range(0, RandomIndexList.Count)];
*for (int i = 0; i <; 10; i++)*{
** Whereが要らなくなる！！ **
*for (int i = 0; i <; ir.Count; i++)*{
条件に一致する要素のindexを取得します
抽出したindexから抽選して返します
*int randomIndex = TempIndices[Random.Range(0, TempIndices.Length)];

*Console.WriteLine(increment());
=&gt; 102

*{services.AddApiVersioning();services.AddControllers();}
This method gets called by the runtime. Use this method to add services to the container.

*Debug.Log("<;color=#ff0000ff<;numの値は<;
color&gt;" + num + "&lt;size=20&gt;です&lt;size&gt;");  とコンソール画面に表示されます

*_ = 1;
ブレークポイントを置くためのタミープログラム

*if (LayerMask.LayerToName(j) != "") {*name.Add(LayerMask.LayerToName(j));
Debug
*if (LayerMask.LayerToName(i) != "") {*Debug.Log("[" + LayerMask.LayerToName(i) + "] is masked [" + string.Join(",", name) + "]");
Debug

*if (x is { }) Console.WriteLine("Never pass");
recursive pattern is not match null

*var multi = new int[5][];
ok

プロパティの値を変更してもトラッキングされない
*ID = value;
ArgumentException がスローされる
*item.ValueList = new List<;int>;();
TargetInvocationException がスローされる
Children プロパティの型が IList&lt;SampleItem&gt; であればOK
*item.Children = new List<;ISampleItem>;();
何れもトラッキング対象外です
DoNoTrack 属性が付与されている or setter がない or public でない
*[DoNoTrack]
何れもトラッキング対象外です
DoNoTrack 属性が付与されている or setter がない or public でない
*[DoNoTrack]
*public virtual SampleItem Parent { get; set; }
親への参照をトラッキング対象プロパティとして持つようにしてみます
proxy の型は SampleItem クラスから継承された Castle.Proxies.SampleItemProxy クラスです
*SampleItem proxy = original.AsTrackable();
proxy から本体／子／子リストのトラッキングオブジェクトを取得する
*IChangeTrackable<;SampleItem>; tracker = proxy.CastToIChangeTrackable();
InvalidCastException がスローされます
*childTracker = proxy.Children[proxy.Children.Count - 1].CastToIChangeTrackable();
プロキシを生成するとオリジナルのリストの要素もプロキシに差し換わってしまうため、
プロキシ生成前にリストをコピー
*originalChildren = original.Children.ToArray();
*{}
トラッキング対象であることを表すインターフェース
*{public static T AsTrackable<;T>;(this T target) where T : class, IChangeTracking{// ライブラリ標準の拡張メソッドを呼び出すreturn ChangeTracking.Core.AsTrackable(target);}// 残りは割愛}
IChangeTracking インターフェースに対する拡張メソッド
ライブラリ標準の拡張メソッドを呼び出す
*return ChangeTracking.Core.AsTrackable(target);
残りは割愛
*}

*{public void Morning() =>; Console.WriteLine("朝：早起きをします。");public void Afternoon() =>; Console.WriteLine("昼：仕事を一生懸命します。");}
平日の具体的な状態を作成します。
*{public void Morning() =>; Console.WriteLine("朝：寝ます。");public void Afternoon() =>; Console.WriteLine("昼：寝ます。");}
休日の具体的な状態を作成します。
*{private IState _state;public void SetState(string dayOfWeek){switch (dayOfWeek){case "Saturday" or "Sunday":_state = new Holiday();break;default:_state = new Weekday();break;}}public void GetMorning() =>; _state.Morning();public void GetAfternoon() =>; _state.Afternoon();}
状態を管理するクラスです。

*{}
Start is called before the first frame update
*{// ↑キー押下時if (Input.GetKeyDown(KeyCode.UpArrow)) {transform.Rotate(new Vector3(0f, 0f, 90f));}// ↓キー押下時if (Input.GetKeyDown(KeyCode.DownArrow)) {transform.Rotate(new Vector3(0f, 0f, -90f));}// →キー押下時if (Input.GetKeyDown(KeyCode.RightArrow)) {transform.Rotate(new Vector3(90f, 0f, 0f));}// ←キー押下時if (Input.GetKeyDown(KeyCode.LeftArrow)) {transform.Rotate(new Vector3(-90f, 0f, 0f));}}
Update is called once per frame
*if (Input.GetKeyDown(KeyCode.UpArrow)) {*transform.Rotate(new Vector3(0f, 0f, 90f));
↑キー押下時
*if (Input.GetKeyDown(KeyCode.DownArrow)) {*transform.Rotate(new Vector3(0f, 0f, -90f));
↓キー押下時
*if (Input.GetKeyDown(KeyCode.RightArrow)) {*transform.Rotate(new Vector3(90f, 0f, 0f));
→キー押下時
*if (Input.GetKeyDown(KeyCode.LeftArrow)) {*transform.Rotate(new Vector3(-90f, 0f, 0f));
←キー押下時
*{}
Start is called before the first frame update
*{// ↑キー押下時if (Input.GetKeyDown(KeyCode.UpArrow)) {Animation(new Vector3(0f, 0f, 2f));}// ↓キー押下時if (Input.GetKeyDown(KeyCode.DownArrow)) {Animation(new Vector3(0f, 0f, -2f));}// →キー押下時if (Input.GetKeyDown(KeyCode.RightArrow)) {Animation(new Vector3(2f, 0f, 0f));}// ←キー押下時if (Input.GetKeyDown(KeyCode.LeftArrow)) {Animation(new Vector3(-2f, 0f, 0f));}}
Update is called once per frame
*if (Input.GetKeyDown(KeyCode.UpArrow)) {*Animation(new Vector3(0f, 0f, 2f));
↑キー押下時
*if (Input.GetKeyDown(KeyCode.DownArrow)) {*Animation(new Vector3(0f, 0f, -2f));
↓キー押下時
*if (Input.GetKeyDown(KeyCode.RightArrow)) {*Animation(new Vector3(2f, 0f, 0f));
→キー押下時
*if (Input.GetKeyDown(KeyCode.LeftArrow)) {*Animation(new Vector3(-2f, 0f, 0f));
←キー押下時
*private void Animation(Vector3 angle) {for(int i=0; i<;45; i++){transform.Rotate(angle);}}
2度ずつ回転を45回行う
アニメーション中かどうか
*bool isAnimate;
回転の角度
*Vector3 angle;
回転回数
*int count;
*{}
Start is called before the first frame update
*{// アニメーションを行うかの判定if (isAnimate) {Animation();}// ↑キー押下時if (Input.GetKeyDown(KeyCode.UpArrow)) {isAnimate = true;angle = new Vector3(0f, 0f, 2f);count = 0;}// ↓キー押下時if (Input.GetKeyDown(KeyCode.DownArrow)) {isAnimate = true;angle = new Vector3(0f, 0f, -2f);count = 0;}// →キー押下時if (Input.GetKeyDown(KeyCode.RightArrow)) {isAnimate = true;angle = new Vector3(2f, 0f, 0f);count = 0;}// ←キー押下時if (Input.GetKeyDown(KeyCode.LeftArrow)) {isAnimate = true;angle = new Vector3(-2f, 0f, 0f);count = 0;}}
Update is called once per frame
*if (isAnimate) {*Animation();
アニメーションを行うかの判定
*if (Input.GetKeyDown(KeyCode.UpArrow)) {*isAnimate = true;
↑キー押下時
*if (Input.GetKeyDown(KeyCode.DownArrow)) {*isAnimate = true;
↓キー押下時
*if (Input.GetKeyDown(KeyCode.RightArrow)) {*isAnimate = true;
→キー押下時
*if (Input.GetKeyDown(KeyCode.LeftArrow)) {*isAnimate = true;
←キー押下時
*private void Animation() {transform.Rotate(angle);count++;// 45回回ったら終了if(count == 45) {isAnimate = false;}}
2度ずつ回転を45回行う
*if(count == 45) {*isAnimate = false;
45回回ったら終了
アニメーション中かどうか
*bool isAnimate;
回転の角度
*Vector3 angle;
回転回数
*int count;
*{}
Start is called before the first frame update
*{// アニメーションを行うかの判定if (isAnimate) {Animation();}// ↑キー押下時if (Input.GetKeyDown(KeyCode.UpArrow)) {isAnimate = true;angle = new Vector3(0f, 0f, 2f);count = 0;}// ↓キー押下時if (Input.GetKeyDown(KeyCode.DownArrow)) {isAnimate = true;angle = new Vector3(0f, 0f, -2f);count = 0;}// →キー押下時if (Input.GetKeyDown(KeyCode.RightArrow)) {isAnimate = true;angle = new Vector3(2f, 0f, 0f);count = 0;}// ←キー押下時if (Input.GetKeyDown(KeyCode.LeftArrow)) {isAnimate = true;angle = new Vector3(-2f, 0f, 0f);count = 0;}}
Update is called once per frame
*if (isAnimate) {*Animation();
アニメーションを行うかの判定
*if (Input.GetKeyDown(KeyCode.UpArrow)) {*isAnimate = true;
↑キー押下時
*if (Input.GetKeyDown(KeyCode.DownArrow)) {*isAnimate = true;
↓キー押下時
*if (Input.GetKeyDown(KeyCode.RightArrow)) {*isAnimate = true;
→キー押下時
*if (Input.GetKeyDown(KeyCode.LeftArrow)) {*isAnimate = true;
←キー押下時
*private void Animation() {transform.Rotate(angle,Space.World);count++;// 45回回ったら終了if(count == 45) {isAnimate = false;}}
2度ずつ回転を45回行う
*if(count == 45) {*isAnimate = false;
45回回ったら終了

*if (!(filterContext.ActionParameters["culture"] is string culture))
culture が null だったら、という書き方
リクエストされた URI。
*Uri requestUri = filterContext.HttpContext.Request.Url;
URI を変更。
デフォルトは ja だけれど、クッキーに値が入っていればそれをデフォルトとする。
*string initialDefaultCulture = "ja";
リダイレクト。
*filterContext.Result = new RedirectResult(uriBuilder.ToString());
*// NOTE: CurrentCulture is used to switch formats.*Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(culture);
RouteConfig で culture を ja か en に絞っているので culure の値チェックは不要。
*{Value = culture};
/ja や /en でアクセスされたらその値をクッキーに保存。

*int[] date = nextBusinessDate(M, D, d);
date[0]: 月、 date[1]: 日

*this.Opacity = 1;
main windowを表示
*for (int i = 0; i <; step; i ++)*{
画面トランジション

*float magnification_x = 0;*float magnification_y = 0;
縦横比率を変更してでも全画面に合わせる。

*class hoge{public void hoge(height, width){this.height = height;this.width = width;}}
C#

*int[] nextWorkingDay = new int[2];
翌営業日の日付
月～木、日なら翌日が営業日
金なら3日後が営業日
土なら2日後が営業日
*switch (d)
*{for(int i = 0; i <; a; i++){//翌日の日付を求めるday++;//月末を超えていた場合if(day >; lastDay(month)){day = 1;month++;}if(month >; 12){month = 1;}}return  new int[] { month, day };}
日付から何日後の日付を求める
翌日の日付を求める
*day++;
*if(day >; lastDay(month))*{
月末を超えていた場合
*{switch (month){case 2:return 28;case 4:case 6:case 9:case 11:return 30;default:return 31;}}
各月の最終日を返す

*businessHours: true,
display business hours

*public event PropertyChangedEventHandler PropertyChanged = delegate { };
INotifyPropertyChanged実装
*{if (propertyName != null)PropertyChanged(this, new PropertyChangedEventArgs(propertyName));}
INotifyPropertyChanged.PropertyChangedイベントを発生させる

Qiita2WPプロジェクトの方の処理を使いまわす
*await q2wp.Qiita2WPArticle();

ここでPlayerのAttack関数を実行したい
*}

*xmlns:Item="clr-namespace:Item"
New!
prismのRegionNameに文字列を登録している
文字列はx:static
xmlns:ItemというnamespaceのRegionNameクラスにあるRingoプロパティ
*<;ContentControl prism:RegionManager.RegionName="{x:Static Item:RegionName.Ringo}">;

*private const string TOP_URL = "http:
kurosu.s1009.xrea.com";
*var responce = await HpClient.GetAsync($"{TOP_URL}{url}?page={page}&amp;per_page=100");
1ページ単位、100件取得
100件区切りした場合のトータルのページ
例えば201件ある場合、3ページとなる
*var toalPage = responce.Headers.GetValues("X-WP-TotalPages").First();
再起処理 すべてのページの要素を収集
*tagArray.Merge(await this.GetList(url, ++page));
*{// 作成日時date = DateTime.Parse(qiita["created_at"].ToString()).ToString("s"),// 公開範囲status = "publish",// タイトルtitle = title,// 本文content = $"\n<;p>;{title}<;a href=\"{url}\">;{url}<;/a>;<;/p>;\n",// タグ(インサート処理は非同期で実行し、すべての処理が終わるのを待つ)tags = await Task.WhenAll(qiita["tags"].Select(async q =>; await this.GetAndAddTagListAsync(wpService, q, tagList)))};
リクエストBody作成
作成日時
*date = DateTime.Parse(qiita["created_at"].ToString()).ToString("s"),
公開範囲
*status = "publish",
タイトル
*title = title,
*content = $"\n<;p>;{title}<;a href=\"{url}\">;{url}<;/a>;<;/p>;\n",
本文
タグ(インサート処理は非同期で実行し、すべての処理が終わるのを待つ)
*tags = await Task.WhenAll(qiita["tags"].Select(async q =>; await this.GetAndAddTagListAsync(wpService, q, tagList)))
*var id = await wpService.InsertTag(new { name = tag["name"].ToString() });
Tag追加リクエスト
*wpTagList.Add(JToken.FromObject(new { id = id ?? -1, name = tag["name"].ToString() }));
リストに追加
リクエスト
*var result = await HpClient.SendAsync(request);
レスポンスbody
*var resultJson = JObject.Parse(await result.Content.ReadAsStringAsync());
追加したタグのIDを返却
*return resultJson["id"].Value<;int>;();
エラーメッセージ
*Console.WriteLine(resultJson["message"].ToString());

引数を指定しない場合は[DiagnosticName("[メソッド名]")]と等価
*[DiagnosticName("EventName1")]

*{[Required]public string a { get; set; }}
Request Body に使用するモデルクラス
Request されてきた値を JSON 形式で返します。
*[HttpPost]
*{return JsonConvert.SerializeObject(value);}
こちらも同じように Request されてきた値を JSON 形式で返します。
*{services.AddControllers().ConfigureApiBehaviorOptions(options =>;{options.SuppressModelStateInvalidFilter = true;});}
Startup.cs
FromBody のリクエストパラメーターが null または ModelState.IsValid == false の場合にステータスコード 400 を返すフィルタークラス
Note: もっと効率のよい実装や、わかりやすい実装があったら教えてください。
*public class ModelStateInvalidFilter : ActionFilterAttribute
*{public static void Register(HttpConfiguration config){// Web API configuration and servicesconfig.Filters.Add(new ModelStateInvalidFilter());// 以下、略 ...}}
WebApiConfig.cs
以下、略 ...
*}

*{services.AddDbContext<;HeroContext>;(opt =>; opt.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));services.AddControllers();}
This method gets called by the runtime. Use this method to add services to the container.
*// To protect from overposting attacks, please enable the specific properties you want to bind to, for*// more details see https://aka.ms/RazorPagesCRUD.
PUT: api/Heroes/5
*[HttpPut("{id}")]
To protect from overposting attacks, please enable the specific properties you want to bind to, for
*[HttpPut("{id}")]
more details see https:aka.ms/RazorPagesCRUD.

*return sum
count;  合計個数

*private const string TOP_URL = "http:
kurosu.s1009.xrea.com";
リクエスト
*var result = await HpClient.SendAsync(request);
エラーメッセージ
*var resultJson = JObject.Parse(await result.Content.ReadAsStringAsync());
リクエスト
*var result = await HpClient.SendAsync(request);
エラーメッセージ
*var resultJson = JObject.Parse(await result.Content.ReadAsStringAsync());
*request.Headers.Add("Authorization", $"Basic {credentials}");
Basi認証ヘッダー
Qiita記事取得
*var qiitaService = new QiitaService();
WP記事取得
*var wpService = new WPService("ユーザID:アプリケーションパスワード");
Qiitaの記事URLが含まれる物を取得
*var matchArticle = wpList.FirstOrDefault(w =>; w["content"]["rendered"].ToString().Contains(url));
*{// 公開範囲status= "publish",// タイトルtitle = title,// 本文content = $"\n<;p>;{title}<;a href=\"{url}\">;{url}<;/a>;<;/p>;\n"};
リクエストBody作成
公開範囲
*status= "publish",
タイトル
*title = title,
*content = $"\n<;p>;{title}<;a href=\"{url}\">;{url}<;/a>;<;/p>;\n"
本文
更新
*await wpService.UpdateWPArticle(matchArticle["id"].ToString(), json);
新規追加
*await wpService.InsertWPArticle(json);
Qiitaの記事をWordPressに反映
*await q2wp.Qiita2WPArticle();

*{}
Start is called before the first frame update
*{}
Update is called once per frame
*void Update () {this.GetComponent<;Text>;().text = score.toString();}
Update is called once per frame

*Debug.Log(nameList[0]);
これでもOK
0番目の値を"スタジオしまづアカデミア"に変更したい
*nameList[0] = "スタジオしまづアカデミア";
コンソールに0番目を表示したい
*Debug.Log(nameList[0]);
for文を使って以下と同じログを表示したい
*Debug.Log(nameList[0]);
nameListに"スタジオしまづアカデミア"を追加したい：Addってのを使う
追加したあと、全ての値をログに表示して追加されたのを確認したい
*}
nameListに"スタジオしまづアカデミア"を追加したい：Addってのを使う
*nameList.Add("スタジオしまづアカデミア");
*for (int i=0; i<;nameList.Count; i++)*{
追加したあと、全ての値をログに表示して追加されたのを確認したい
以下でもOK
*/*
nameListの"アンチスタジオしまづ"を消したい
*}
nameListの"アンチスタジオしまづ"を消したい
*nameList.Remove("アンチスタジオしまづ");
番号指定での削除もできるよ
nameList.RemoveAt(1);
*for (int i = 0; i <; nameList.Count; i++)
以下でもOK
*/*

*private const string URL_FIRST = "http:
kurosu.s1009.xrea.com";
TODO「Application Passwords」プラグインというプラグインを有効化にしていないせいかまだ動作しない
*var credentials = Convert.ToBase64String(Encoding.UTF8.GetBytes("XXXX:BBBBBBB"));
Qiita記事取得
*var qiitaService = new QiitaService();
WP記事取得
*var wpService = new WPService();
Qiitaの記事URLが含まれる物を取得
*var matchArticle = wpList.FirstOrDefault(w =>; w["content"]["rendered"].ToString().Contains(url));
*if (matchArticle != null)*{
記事更新
タイトル
*matchArticle["title"] = title;
*matchArticle["content"]["rendered"] = $"\n<;p>;{title}<;a href=\"{url}\">;{url}<;/a>;<;/p>;\n";
リンク部分
更新
*var result = await wpService.UpdateWPArticle(matchArticle["id"].ToString(), matchArticle.ToString());
*{// TODO}
記事新規追加
Qiitaの記事をWordPressに反映
*await q2wp.Qiita2WPArticle();

アクティビティ関数を並列で10回呼び出す
*tasks[index] = context.CallActivityAsync<;int>;("TaskActivity", index);
10個のタスクが終わるまで待つ
*await Task.WhenAll(tasks);
エラーが発生したことをキャッチする
*Console.WriteLine("Error has occured.");
成功の結果だけ集めてくる
*int total = tasks.Where(t =>; t.Status == TaskStatus.RanToCompletion).Sum(t =>; t.Result);
エラー結果だけを取得する
*var errors = tasks.Where(t =>; t.Status == TaskStatus.Faulted).ToList();
*log.LogInformation($"Started orchestration with ID = '{instanceId}'.");
Function input comes from the request content.
0以外の4の倍数の時に例外をスロー
*throw new Exception("number:" + number.ToString() + " is a mulriple of 4.");

右クリック Tools/Test で任意の場所に Test_ScriptableObject.asset ファイルを作成できる
*[CreateAssetMenu(menuName = "Tools/Test")]
場合により Exception や
*throw new System.IO.FileNotFoundException("Test_ScriptableObject does not found");
Log 出して return null
*Debug.LogWarning("Oh...");
*{var guid = AssetDatabase.FindAssets("t:" + typeof(T).Name).FirstOrDefault();var filePath = AssetDatabase.GUIDToAssetPath(guid);if (string.IsNullOrEmpty(filePath)){}return AssetDatabase.LoadAssetAtPath<;T>;(filePath);}
読み込みますよ

*builder.Services.AddScoped<;AppState<;();
&lt;-追加

(略)可変長配列を使った演算(Ls)
*Console.WriteLine(Txt + "\n値を2つ入力");

*string[] dayOfWeek = new string[] { "水", "木", "金", "土", "日", "月", "火" };
１８００年１月１日からの日数を計算する
*{switch (month){case 2:if(year % 400 == 0 || (year % 100 != 0 &amp;&amp; year % 4 == 0)){return 29;}else{return 28;}case 4:case 6:case 9:case 11:return 30;default:return 31;}}
ある年月の最終日を返す
*{day++;if(day >; lastDay(year,month)){day = 1;month++;}if(month >; 12){month = 1;year++;}return new long[] { year, month, day };}
次の日を計算するメソッド
*{long y = 1800, m = 1, d = 1;long count = 0;//400年分の日数を計算long DaysOf400Years = 365 * 400 + (400 / 400) - (400 / 100) + (400 / 4);//400の倍数年未来に飛ぶcount += ((year - 1800) / 400) * DaysOf400Years;y = year - (year - 1800) % 400;while(!(y == year &amp;&amp; m == month &amp;&amp; d == day)){//一日ずつ進めるcount++;long[] tomoorow = nextDay(y, m, d);y = tomoorow[0];m = tomoorow[1];d = tomoorow[2];}return count;}
１８００年１月１日からの日数を計算するメソッド
400年分の日数を計算
*long DaysOf400Years = 365 * 400 + (400 / 400) - (400 / 100) + (400 / 4);
400の倍数年未来に飛ぶ
*count += ((year - 1800) / 400) * DaysOf400Years;
一日ずつ進める
*count++;

*for (int i = 0; i <; 3; i++) {*float rand_x = Random.Range(-3.0f, 3.0f);
3つの分身を出す
*if (GameObject.FindGameObjectsWithTag("Avatar").Length >; 0) {*float r = Random.Range(1, 6);
分身が全滅するまで本体はランダムの方向に弾を撃つ
*Vector3 dir = player.transform.position - transform.position;*//角度を取得
プレイヤーまでの方向ベクトルを取得
角度を取得
*float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg;
*IEnumerator Attack14(int c) {for(int i = 1; i <; c; i++) {float angle = -(c + 1) * 10 / 2 + i * 10;NwayShot(angle);yield return new WaitForSeconds(0.02f);}AttackFlag = 0;}
らせん状に弾が飛んでいく
*IEnumerator Attack15(int NwayCount) {//最初の弾(p1として保持)float r1 = Random.Range(1, NwayCount + 1);float angle1 = -(NwayCount + 1) * 5 / 2 + r1 * 5;GameObject p = Instantiate(BossProjectilePrefab_slow2, transform.position, Quaternion.Euler(new Vector3(0.0f, 0.0f, angle1)));AudioSource.PlayClipAtPoint(BossShotSE, transform.position);yield return new WaitForSeconds(0.2f);//最初の弾からの1段階の分裂(分裂した弾をp2として保持)float r2 = Random.Range(1, NwayCount + 1);float angle2 = -(NwayCount + 1) * 5 / 2 + r2 * 5;GameObject p2=Instantiate(BossProjectilePrefab_slow2, p.transform.position, Quaternion.Euler(new Vector3(0.0f, 0.0f, angle2)));AudioSource.PlayClipAtPoint(BossShotSE, transform.position);yield return new WaitForSeconds(0.5f);//1段階で分裂したそれぞれの弾が分裂(p1とp2からそれぞれ分裂)float r3 = Random.Range(1, NwayCount + 1);float angle3 = -(NwayCount + 1) * 5 / 2 + r3 * 5;Instantiate(BossProjectilePrefab_slow2, p.transform.position, Quaternion.Euler(new Vector3(0.0f, 0.0f, angle3)));AudioSource.PlayClipAtPoint(BossShotSE, transform.position);float r4 = Random.Range(1, NwayCount + 1);float angle4 = -(NwayCount + 1) * 5 / 2 + r4 * 5;Instantiate(BossProjectilePrefab_slow2, p2.transform.position, Quaternion.Euler(new Vector3(0.0f, 0.0f, angle4)));AudioSource.PlayClipAtPoint(BossShotSE, transform.position);}
弾を発射したら数秒後に2段階分裂する
最初の弾(p1として保持)
*float r1 = Random.Range(1, NwayCount + 1);
最初の弾からの1段階の分裂(分裂した弾をp2として保持)
*float r2 = Random.Range(1, NwayCount + 1);
1段階で分裂したそれぞれの弾が分裂(p1とp2からそれぞれ分裂)
*float r3 = Random.Range(1, NwayCount + 1);

*Console.WriteLine(counter.Invoke());
3
指定したユーザのフルネームを取得する
今回の例題ではこのメソッドが使われている
*public string GetFullName()
*{return Find()["first_name"].ToString();}
指定したユーザの名前を取得する
*{return Find()["last_name"].ToString();}
指定したユーザの名字を取得する
*{var connection = new DBConnection();connection.Open();// SQLを作成し、DBにアクセスする// ここで時間がかかる!!Dictionary<;string, object>; record = connection.FindBySql("SELECT * FROM users WHERE id = ?", _userId);connection.Close();return record;}
usersテーブルから指定されたユーザIDに紐づくレコードを取得する
SQLを作成し、DBにアクセスする
ここで時間がかかる!!
*Dictionary<;string, object>; record = connection.FindBySql(
キャッシュ用のグローバル変数を用意する
*private Dictionary<;string, object>; _cache = null;
指定したユーザのフルネームを取得する
今回の例題ではこのメソッドが使われている
*public string GetFullName()
*{return Find()["first_name"].ToString();}
指定したユーザの名前を取得する
*{return Find()["last_name"].ToString();}
指定したユーザの名字を取得する
*{if(_cache != null){// キャッシュにすでにユーザ情報があればDBアクセスせずにキャッシュを返すreturn _cache;}var connection = new DBConnection();connection.Open();// SQLを作成し、DBにアクセスする// ここで時間がかかる!!Dictionary<;string, object>; record = connection.FindBySql("SELECT * FROM users WHERE id = ?", _userId);connection.Close();// キャッシュしておく_cache = record;return record;}
usersテーブルから指定されたユーザIDに紐づくレコードを取得する
キャッシュにすでにユーザ情報があればDBアクセスせずにキャッシュを返す
*return _cache;
SQLを作成し、DBにアクセスする
ここで時間がかかる!!
*Dictionary<;string, object>; record = connection.FindBySql(
キャッシュしておく
*_cache = record;
指定したユーザのフルネームを取得する
今回の例題ではこのメソッドが使われている
*public string GetFullName()
*{return Find()["first_name"].ToString();}
指定したユーザの名前を取得する
*{return Find()["last_name"].ToString();}
指定したユーザの名字を取得する
*{return FindUsingCache().Invoke();}
キャッシュするためにFindUsingCacheメソッドで作られるクロージャに処理を移動した
usersテーブルから指定されたユーザIDに紐づくレコードを取得する
キャッシュ対応版
*private Func<;Dictionary<;string, object>;>; FindUsingCache()
キャッシュ用の変数を用意する
*Dictionary<;string, object>; _cache = null;
*Func<;Dictionary<;string, object>;>; f = () =>; {if(_cache != null){// キャッシュにすでにユーザ情報があればキャッシュを返すreturn _cache;}var connection = new DBConnection();connection.Open();// SQLを作成し、DBにアクセスする// ここで時間がかかる!!Dictionary<;string, object>; record = connection.FindBySql("SELECT * FROM users WHERE id = ?", _userId);connection.Close();// キャッシュに入れておく_cache = record;return record;};
クロージャを作る
キャッシュにすでにユーザ情報があればキャッシュを返す
*return _cache;
SQLを作成し、DBにアクセスする
ここで時間がかかる!!
*Dictionary<;string, object>; record = connection.FindBySql(
キャッシュに入れておく
*_cache = record;
クロージャを返す
*return f;

一日進める
*date = nextDate(date[0], date[1], date[2]);
*{return year % 400 == 0 || year % 100 != 0 &amp;&amp; year % 4 == 0;}
うるう年か判断するメソッド
*{switch(month){case 2:if (isLeap(year)){return 29;}else{return 28;}case 4:case 6:case 9:case 11:return 30;default:return 31;}}
ある年月の最終日を計算
*{day++;if(day >; lastDay(year, month)){day = 1;month++;}if(month >; 12){month = 1;year++;}return new int[] { year, month, day };}
翌日の年月日を返す

SQL発行関数（SELECT）
*Reader ExecuteQuery(string query);
SQL発行関数（INSERT, UPDATE, DELETE）
*void ExecuteNonQuery(string query);
初期化
*void Initialize();
コネクションストリングの構築（DB毎に異なるので）
*void BuildSqlConnectionString();
トランザクション管理
*void BeginTransaction();
Nuget で SQLite 関連は読み込み済み
*private SQLiteConnection _SQLiteConnection;
SQLiteDB ファイルのパス
*private readonly string _path;
SQLiteDB ファイルの名称
*private readonly string _fileName;
*{_path = path;_fileName = fileName;Initialize();}
コンストラクタ
*{BuildSqlConnectionString();_SQLiteConnection = new SQLiteConnection(_dbConnectionString);_SQLiteConnection.Open();}
初期化：DB接続を確立させる
*{// DB ファイルネームが指定されなかった場合は、"default" を定義値にします。string fName = (_fileName.Length == 0) ? "default" : _fileName;if(_path.Length == 0)_dbConnectionString = $"Data Source ={fName}.db";else_dbConnectionString = $"Data Source ={_path}/{fName}.db";}
コネクションストリングを作成
DB ファイルネームが指定されなかった場合は、"default" を定義値にします。
*string fName = (_fileName.Length == 0) ? "default" : _fileName;
*{this.ExecuteNonQuery(query, new Dictionary<;string, object>;());}
SQL発行
*foreach (KeyValuePair<;string, object>; item in keyValuePairs)*{
パラメータをバインド
*foreach (KeyValuePair<;string, object>; item in keyValuePairs)*{
パラメータをバインド

･･･ 以下省略 ･･･
*}
･･･ 途中省略 ･･･
この部分にIQuerable&lt;Person&gt;selectedに、引数crt_nameとcrt_ageで指定された検索条件でデータを検索し、
sortfiledに指定されたソート条件で並べ替えを行った結果をセットする処理が記載されている。
･･･
*var people_pagelist = await PaginatedList<;Person>;.CreateAsync(

*for (int i = 0; i <;= 9; i++)*{
isInit = true;

*return new Uri("http:
localhost:8080");

1800年1月1日からy年m月d日の経過日数を計算
*int NumberOfDays = 0;
*if(y >; 1800)*{
1800年１月1日から(y-1)年の大晦日までの日数を計算
*for (int i = 1; i <; m; i++)*{
y年になってからの経過日数を計算
経過に日数の7の剰余が
*string dayOfWeek = null;
*if (y % 400 == 0)*{
400で割り切れるうるう年
*else if (y % 100 == 0)*{
100で割り切れるなら平年
*else if (y % 4 == 0)*{
4で割り切れるならうるう年

*//Recurrence = new string[] { "RRULE:FREQ=DAILY;COUNT=2" },
以下があるとエラーになるので・・・
*//Attendees = new EventAttendee[] {//    new EventAttendee() { Email = "lpage@example.com" },//    new EventAttendee() { Email = "sbrin@example.com" },//},
Recurrence = new string[] { "RRULE:FREQ=DAILY;COUNT=2" },
*//    new EventAttendee() { Email = "lpage@example.com" },
Attendees = new EventAttendee[] {
*//    new EventAttendee() { Email = "sbrin@example.com" },
new EventAttendee() { Email = "lpage@example.com" },
*//{//    UseDefault = false,//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }//}
},
*//{//    UseDefault = false,//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }//}
Reminders = new Event.RemindersData()
*//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }
{
*//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }
UseDefault = false,
*//        new EventReminder() { Method = "email", Minutes = 24 * 60 },
Overrides = new EventReminder[] {
*//        new EventReminder() { Method = "sms", Minutes = 10 },
new EventReminder() { Method = "email", Minutes = 24 * 60 },
カレンダーID
*var calendarId = "カレンダーID";
Googleカレンダーテストクラスインスタンス化
*var calApi = new CalendarAPITest(@"C:\job\TestProject\GoogleAPITest\testproject-269217-813bf9be17a5.json");
イベント読み取り
*calApi.ReadEvents(calendarId);
イベント追加
*var evt = calApi.InsertEvent(calendarId);
イベント更新
*calApi.UpdateEvent(calendarId, evt);
カレンダーID
*var calendarId = "カレンダーID";
Googleカレンダーテストクラスインスタンス化
*var calApi = new CalendarAPITest(@"C:\job\TestProject\GoogleAPITest\testproject-269217-813bf9be17a5.json");
イベント読み取り
*calApi.ReadEvents(calendarId);
イベント追加
*var evt = calApi.InsertEvent(calendarId);
イベント更新
*evt = calApi.UpdateEvent(calendarId, evt);
イベント削除
*calApi.DeleteEvent(calendarId, evt.Id);

Fluent Assertions で文字列が空文字であることを確認する例
*theString.Should().Be(string.Empty);
Chaining Assertion で文字列が空文字であることを確認する例
*theString.Is(string.Empty);
Fluent Assertions で対象の値が0以上10以下であることを確認する例
*theInt.Should().BeInRange(0, 10);
Chaining Assertion で対象の値が0以上10以下であることを確認する例
*theInt.Is(value =>; value >;= 0 &amp;&amp; value <;= 10);
Fluent Assertions でコレクションの要素に3より大きい値があることを確認する例
(何十個もあるコレクションのメソッドの中から適したメソッドを使う)
*collection.Should().HaveCountGreaterThan(3);
Chaining Assertion でコレクションの要素に3より大きい値があることを確認する例
(慣れ親しんだ Linq to Objects を使う)
*collection.Any(c =>; c >; 3).Is(true);
*{private string PrivateMethod(int number){return number;}}
privateメンバーを持つクラス
AsDynamic()の戻り値は dynamic型
AsDynamic()に続けて呼び出したいメンバーを書くことでリフレクションで実行される
*int number = myClass.AsDynamic().PrivateMethod(3);
*{public string Name{get;set;}public MyClass Child{get;set;}public MyClass Clone(){// 複製する処理}}
テスト対象クラス
複製する処理
*}
*{Name = "Test",Child = new MyClass(),};
テスト対象クラスを作成する
複製する
*var clone = myClass.Clone();
参照しているChildのフィールド値も含めて一致することを確認
*clone.IsStructuralEqual(myClass);

全選択
*SelectAll(listview1, true);
選択解除
*SelectAll(listview1, false);
iを使用した処理
*}

初期化処理（ただし、この時点ではまだ矩形情報が取れない！）
CreateWindowとかして、帰ってきたHWNDを返す
*}
Win32の後半のメッセージループの部分
DirectXのUpdate（Render）処理はここで
*}
終了処理
*}
Win32のWindowの初期化
*IntPtr hwnd = CreateWindowEx(
DirectX12の初期化
BuildWindowCoreでInitしたかったが、は矩形が0のままなのでDepthBufferが作れない。
本当はリサイズも考慮してデバイスのInitとRenderTarger/DepthBufferの生成を分けるべき。
*app = Init(hwnd, (int)ActualWidth, (int)ActualHeight);
DirectX12の描画（のリクエスト）処理
*Render(app);
Win32のWindowとDirectX12の終了処理
*DestroyWindow(hwnd.Handle);

*//Recurrence = new string[] { "RRULE:FREQ=DAILY;COUNT=2" },
以下があるとエラーになっていたのでコメントアウト・・・
*//Attendees = new EventAttendee[] {//    new EventAttendee() { Email = "lpage@example.com" },//    new EventAttendee() { Email = "sbrin@example.com" },//},
Recurrence = new string[] { "RRULE:FREQ=DAILY;COUNT=2" },
*//    new EventAttendee() { Email = "lpage@example.com" },
Attendees = new EventAttendee[] {
*//    new EventAttendee() { Email = "sbrin@example.com" },
new EventAttendee() { Email = "lpage@example.com" },
*//{//    UseDefault = false,//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }//}
},
*//{//    UseDefault = false,//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }//}
Reminders = new Event.RemindersData()
*//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }
{
*//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }
UseDefault = false,
*//        new EventReminder() { Method = "email", Minutes = 24 * 60 },
Overrides = new EventReminder[] {
*//        new EventReminder() { Method = "sms", Minutes = 10 },
new EventReminder() { Method = "email", Minutes = 24 * 60 },
ここで第2引数にサービスアカウントに公開したカレンダーIDを指定する
*var request = new EventsResource.ListRequest(this.Serive, calendarId);
*//Attendees = new EventAttendee[] {//    new EventAttendee() { Email = "lpage@example.com" },//    new EventAttendee() { Email = "sbrin@example.com" },//},
Recurrence = new string[] { "RRULE:FREQ=DAILY;COUNT=2" },
*//    new EventAttendee() { Email = "lpage@example.com" },
Attendees = new EventAttendee[] {
*//    new EventAttendee() { Email = "sbrin@example.com" },
new EventAttendee() { Email = "lpage@example.com" },
*//{//    UseDefault = false,//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }//}
},
*//{//    UseDefault = false,//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }//}
Reminders = new Event.RemindersData()
*//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }
{
*//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }
UseDefault = false,
*//        new EventReminder() { Method = "email", Minutes = 24 * 60 },
Overrides = new EventReminder[] {
*//        new EventReminder() { Method = "sms", Minutes = 10 },
new EventReminder() { Method = "email", Minutes = 24 * 60 },
カレンダーID
*var calendarId = "カレンダーID";
Googleカレンダーテストクラスインスタンス化
*var calApi = new CalendarAPITest(
イベント読み取り
*calApi.ReadEvents(calendarId);
イベント追加
*calApi.InsertEvent(calendarId);

*return;
DB has been seeded
こんな感じで投入データを書き加えていく。
*);

*advWatcher.Stop();
デバイスを見つけたので止める
接続
*BluetoothLEDevice device = await BluetoothLEDevice.FromBluetoothAddressAsync(args.BluetoothAddress);
サービス・キャラクタリスティックを列挙
*addLog("get service");
サービスUUIDを使って目的のサービスを取得
asyncバージョンは使えない
*var gattService = device.GetGattService(switchUUID);
キャラクタリスティックUUIDを使って目的のキャラクタリスティックを取得
asyncバージョンは使えない
*var characteristics = gattService.GetCharacteristics(commandUUID);
*if (characteristics.Count >; 0)*{
戻ってくるのが配列なので空じゃないか確認

trueだと出力を整形する
*WriteIndented = true,
UNICODEエスケープシーケンスにしない対象を指定。やらないと、ASCII文字以外すべてが　あ → \u3042　みたいな感じでエスケープされる。
*Encoder = System.Text.Encodings.Web.JavaScriptEncoder.Create(System.Text.Unicode.UnicodeRanges.All),

*var targetMac = "*******";
アプリで調べたMAC
*if (bleServiceUUID == switchUUID)*{
アドレスじゃなくてUUIDで選択
接続
*BluetoothLEDevice device = await BluetoothLEDevice.FromBluetoothAddressAsync(args.BluetoothAddress);
*var gattService = await device.GetGattServicesForUuidAsync(switchUUID);*if (gattService.Status == GattCommunicationStatus.Success)
サービスUUIDを使って目的のサービスを取得
コマンド送信用UUIDを使ってキャラクタリスティックを取得
*var characteristics = await gattService.Services.FirstOrDefault().GetCharacteristicsForUuidAsync(commandUUID);

簡単な例外処理をしてみよう
*using System;
*{Console.WriteLine("Hello World");int number = 0;// 0で割り算できないためエラーが起きる// ここで処理が中断され、catchブロックに飛ぶint answer = 100 / number;Console.WriteLine(answer);}
例外が投げられる可能性のあるコード
0で割り算できないためエラーが起きる
ここで処理が中断され、catchブロックに飛ぶ
*int answer = 100 / number;
例外が起きた場合の処理
Exception e の中に例外の詳細情報が格納されている
*catch(Exception e)
*{Console.WriteLine("Hello C#");}
例外発生の有無にかかわらず実行したいコード
throwで意図的に例外を投げよう
*using System;
意図的に例外を投げる
*throw new Exception();
*{Console.WriteLine("例外が発生しました。");Console.Error.WriteLine(e);}
throw で呼ばれる

*Direction direction = Direction.DOWN;
ここはDirection.DOWNでなくてもOK

*private static string[] Scopes = { CalendarService.Scope.CalendarReadonly };
If modifying these scopes, delete your previously saved credentials
*private static string[] Scopes = { CalendarService.Scope.CalendarReadonly };
at ~/.credentials/calendar-dotnet-quickstart.json
*{HttpClientInitializer = credential,ApplicationName = ApplicationName,});
Create Google Calendar API service.
おそらく不必要
Define parameters of request.
var request = service.Events.List("primary");
request.TimeMin = DateTime.Now;
request.ShowDeleted = false;
request.SingleEvents = true;
request.MaxResults = 10;
request.OrderBy = EventsResource.ListRequest.OrderByEnum.StartTime;
ここで第2引数にサービスアカウントに公開したカレンダーIDを指定する
*var request = new EventsResource.ListRequest(service, "公開したカレンダーのカレンダーID");

BitmapSourceの派生クラス「RenderTargetBitmap」で、画像を取ってくる
「RouletteWhole」は、Gridの名前。
*var canvas = new RenderTargetBitmap((int)RouletteWhole.ActualWidth, (int)RouletteWhole.ActualHeight, 96, 96, PixelFormats.Pbgra32);
*{BitmapEncoder encoder = new BmpBitmapEncoder();encoder.Frames.Add(BitmapFrame.Create(canvas));encoder.Save(stream);// BmpBitmapEncoderからSystem.Drawing.Bitmapをつくるvar bitmap = new System.Drawing.Bitmap(stream);bitmap.Save(@".\aaa.bmp");}
BmpBitmapEncoderに画像を入れる
BmpBitmapEncoderからSystem.Drawing.Bitmapをつくる
*var bitmap = new System.Drawing.Bitmap(stream);

*Console.WriteLine(addDelegate());
(4-2)

連携先の呼び出し、なければ何もしない
*PluginManager?.DoSomething?.Invoke();
*if(PluginManager?.DoSomething == null)*{
UIの無効化など

*{// ローカルの8080番ポート(ngrok起動時のオプションで指定した番号)で待ち受け開始。// ngrokが同じローカルマシンで動いているので、"127.0.0.1"だけで待ち受ければよい。// (外部の環境からリクエストを受ける必要がない)// また、"/webhook"のパスも入れておく。Prefix指定時は、"/"で終わるようにしておく必要がある。listener.Prefixes.Add("http://127.0.0.1:8080/webhook/");// HttpListenerの待ち受けを開始します。listener.Start();// スレッドプール上で待ち受けるようにする。// 今回は1スレッドだが、例えばループで64回Task作成すれば、64スレッドで待ち受けるようになる。Task.Run(async () =>;{// HttpListenerが待ち受け中はループする。while(listener.IsListening){////////////////////////////////////////////////////////////////// このサンプルの実装では、whileブロック内で例外が発生すると後続の待ち受けも中断されます。// 実際には、適切に例外を処理する必要があります。// どの例外をcatchすべきかは、whileブロック内での処理内容にもよります。// catchしすぎると、意図せずループが続く場合もあるので注意が必要です。// 基本的には、例外が発生しても待ち受けを継続したいような場合の例外は、whileブロックの中、// 待ち受けを継続しても意味がないような例外は、whileブロックの外側で受けるように実装します。// 先ほど登録したアドレス、ポート、パスに合致するリクエストが来ると、処理用のContextが取得できる。var context = await listener.GetContextAsync();// リクエストとレスポンス処理用のインスタンス取得。var request  = context.Request;var response = context.Response;try{if (request.HttpMethod != "POST" &amp;&amp; request.HttpMethod != "GET"){// Webhook通知元の仕様にもよるが、HTTPのPOSTかGETかで通知が来る前提にして、// それ以外は、"204 No Content"を返す。response.StatusCode = 204;}else{// Bodyの内容を読み込んで表示するだけ。if (request.HasEntityBody){using (var reader = new StreamReader(request.InputStream, request.ContentEncoding)){Console.WriteLine("RequestData: {0}", reader.ReadToEnd());}}////////////////////////////////////////////////////////////////// 以下、レスポンスで何を返すべきかは通知元のサービス側の仕様にもよる。// "204 No Content"を返せばいい場合は、以下にコメントアウトした1行だけでBody出力不要。// response.StatusCode = 204;// レスポンスヘッダで、Content-Type: application/jsonにする。response.ContentType = "application/json";// レスポンスのBodyは決め打ちで書き込む。using (var writer = new StreamWriter(response.OutputStream)){writer.Write("{\"status\" : \"OK\"}");}}}finally{// ResponseはClose()を呼ぶ必要があります。response.Close();}}});// 何かキーを押したら終了させる。Console.WriteLine("終了するには何かキーを押してください。");Console.ReadKey(false);}
System.Net.HttpListenerを利用してサーバを実装します。
ローカルの8080番ポート(ngrok起動時のオプションで指定した番号)で待ち受け開始。
ngrokが同じローカルマシンで動いているので、"127.0.0.1"だけで待ち受ければよい。
(外部の環境からリクエストを受ける必要がない)
また、"/webhook"のパスも入れておく。Prefix指定時は、"/"で終わるようにしておく必要がある。
listener.Prefixes.Add("http:127.0.0.1:8080/webhook/");
HttpListenerの待ち受けを開始します。
*listener.Start();
スレッドプール上で待ち受けるようにする。
今回は1スレッドだが、例えばループで64回Task作成すれば、64スレッドで待ち受けるようになる。
*Task.Run(
*while(listener.IsListening)*{
HttpListenerが待ち受け中はループする。
このサンプルの実装では、whileブロック内で例外が発生すると後続の待ち受けも中断されます。
実際には、適切に例外を処理する必要があります。
どの例外をcatchすべきかは、whileブロック内での処理内容にもよります。
catchしすぎると、意図せずループが続く場合もあるので注意が必要です。
基本的には、例外が発生しても待ち受けを継続したいような場合の例外は、whileブロックの中、
待ち受けを継続しても意味がないような例外は、whileブロックの外側で受けるように実装します。
先ほど登録したアドレス、ポート、パスに合致するリクエストが来ると、処理用のContextが取得できる。
*var context = await listener.GetContextAsync();
リクエストとレスポンス処理用のインスタンス取得。
*var request  = context.Request;
Webhook通知元の仕様にもよるが、HTTPのPOSTかGETかで通知が来る前提にして、
それ以外は、"204 No Content"を返す。
*response.StatusCode = 204;
*if (request.HasEntityBody)*{
Bodyの内容を読み込んで表示するだけ。
以下、レスポンスで何を返すべきかは通知元のサービス側の仕様にもよる。
"204 No Content"を返せばいい場合は、以下にコメントアウトした1行だけでBody出力不要。
response.StatusCode = 204;
レスポンスヘッダで、Content-Type: application/jsonにする。
*response.ContentType = "application/json";
*{writer.Write("{\"status\" : \"OK\"}");}
レスポンスのBodyは決め打ちで書き込む。
ResponseはClose()を呼ぶ必要があります。
*response.Close();
何かキーを押したら終了させる。
*Console.WriteLine("終了するには何かキーを押してください。");

*string uri = "http:
localhost";

SQL発行
*MySqlCommand selectCommand = new MySqlCommand("SELECT * FROM MyTable", conn);
*while(results.Read())*{
行ごとにループ
*public static void Main{MySqlConnection mySqlConnection = new MySqlConnection("ConnectionString");mySqlConnection.Open();var tableA = getTable("tableA");var tableB = getTable("tableB");}
メイン
*public async Task<;DataReader>; getTable(string tableName){using (var command = mySqlConnection.CreateCommand()) {command.CommandText = $"SELECT * FROM {tableName}";using (var reader = command.ExecuteReaderAsync()) {return reader;}}}
取得
*public Dictionary<;string, Dictionary<;string, string>;>; getTable(string tableName){using (var command = mySqlConnection.CreateCommand()) {command.CommandText = $"SELECT * FROM {tableName}";using (var reader = command.ExecuteReader()) {if (reader.HasRows) {while (reader.Read()) {JObject line = new JObject();for (int i = 0; i <; reader.FieldCount; i++) {line.Add(reader.GetName(i), reader.GetString(i));}ret.Add(reader.GetString("id"), line);}}}}return ret;}
取得
*public Dictionary<;string, Dictionary<;string, string>;>; getTable(string tableName){using (MySqlConnection mySqlConnection = new MySqlConnection("ConnectionString")) {mySqlConnection.Open();using (var command = mySqlConnection.CreateCommand()) {command.CommandText = $"SELECT * FROM {tableName}";using (var reader = command.ExecuteReader()) {if (reader.HasRows) {while (reader.Read()) {var line = new Dictionary<;string, string>;();for (int i = 0; i <; reader.FieldCount; i++) {line.Add(reader.GetName(i), reader.GetString(i));}ret.Add(reader.GetString("id"), line);}}}}}return ret;}
取得

接続文字列を利用してSQLDatabaseに接続
*conn.Open();
*log.LogInformation($"{rows} rows were updated");
SQLの実行はココ selectなのでExecuteScalarクラスを利用
SQLの実行はココ insertなのでExecuteNonQueryクラスを利用
*var rowsrows = cmdcmd.ExecuteNonQuery();

任意のブラウザ操作処理 ↓↓↓
driver.Url = "https:www.google.com";
*var q = driver.FindElementByName("q");
任意のブラウザ操作処理 ↑↑↑
*}

*using UniRx.Triggers;
これ必要

境界をなめらかに
*col = smoothstep(0.5, 0.51, col);
一定以下のalphaはゼロにする
*_Color.a *= step(1-col.a, 0.01);

*Vector3 distancePosition;
追加 半径設定用のベクトル
*{speed = 50.0f;//半径設定 高さをカメラと同一にすることで距離をそのまま半径として利用できるdistancePosition = new Vector3(parent.transform.position.x, transform.position.y, parent.transform.position.z);distance = Vector3.Distance(distancePosition, transform.position);}
Start is called before the first frame update
*distancePosition = new Vector3(parent.transform.position.x, transform.position.y, parent.transform.position.z);*distance = Vector3.Distance(distancePosition, transform.position);
半径設定 高さをカメラと同一にすることで距離をそのまま半径として利用できる
*{float x = Input.GetAxis("RightHorizontal");float y = Input.GetAxis("RightVirtical");//等速円運動をする物体の角速度(rad/s)の公式は 角速度(ベクトル) = 速度 / 半径 もしくは 角速度(ベクトル) = 角度 / 時間 (2π * 半径 / 時間)//今回は角速度(ベクトル) = 2π * 半径 / 時間 を利用する//今回の場合、秒間72°移動する処理であるfloat radSpeedValue = 2 * Mathf.PI * distance / 5.0f; //変更//RotateAroundと同等の動きをするVector3 radSpeed = x * transform.right * radSpeedValue;transform.position += radSpeed * Time.deltaTime;//振動を防ぐためにMathf.Clampは利用していない//振動を防ぐ方法として一定以上もしくは以下になったらそれ以上動きを足さない処理を利用するfloat eulerAnglesX = transform.eulerAngles.x;if (!((eulerAnglesX <; 180 &amp;&amp; eulerAnglesX >; 89.0f &amp;&amp; y >; 0) || (eulerAnglesX >; 180 &amp;&amp; eulerAnglesX <; 271.0f &amp;&amp; y <; 0)))transform.RotateAround(parent.transform.position, transform.right, y * speed * Time.deltaTime);transform.LookAt(parent.transform);//半径設定 高さをカメラと同一にすることで距離をそのまま半径として利用できるdistancePosition = new Vector3(parent.transform.position.x, transform.position.y, parent.transform.position.z);//y軸となす角度によって距離が変動するため、毎フレーム更新distance = Vector3.Distance(distancePosition, transform.position);}
Update is called once per frame
等速円運動をする物体の角速度(rad/s)の公式は 角速度(ベクトル) = 速度 / 半径 もしくは 角速度(ベクトル) = 角度 / 時間 (2π * 半径 / 時間)
今回は角速度(ベクトル) = 2π * 半径 / 時間 を利用する
今回の場合、秒間72°移動する処理である
float radSpeedValue = 2 * Mathf.PI * distance / 5.0f; 変更
RotateAroundと同等の動きをする
*Vector3 radSpeed = x * transform.right * radSpeedValue;
振動を防ぐためにMathf.Clampは利用していない
振動を防ぐ方法として一定以上もしくは以下になったらそれ以上動きを足さない処理を利用する
*float eulerAnglesX = transform.eulerAngles.x;
*distancePosition = new Vector3(parent.transform.position.x, transform.position.y, parent.transform.position.z);*//y軸となす角度によって距離が変動するため、毎フレーム更新
半径設定 高さをカメラと同一にすることで距離をそのまま半径として利用できる
*distance = Vector3.Distance(distancePosition, transform.position);*}
y軸となす角度によって距離が変動するため、毎フレーム更新

パラメーターを使用してキュー メッセージを作成するコードを追加
*outputQueueItem.Add(name);

*{which_cake += 1;Debug.Log("which_cake: " + which_cake);}
食材側で呼び出される、判定値を変更
足す値をインスペクター上で指定
*public int plus = 1;
ループ用の変数を定義
*int p = plus;
*while (p != 0)*{
+値が0になるまでJudgeで足す

*var secretValue = _configuration[secretName];
★配列みたいなもので一致しているものだけとっている？

*const string ServiceBusConnectionString = "Endpoint=sb:
***********.servicebus.windows.net;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=***********";

*string shopifyMpKey = "YOUR SECRET KEY HERE";*var sp = new ShopifyMultipassTokenGenerator.ShopifyMultipass(shopifyMpKey, "gyrocanopy-delivery-motor.myshopify.com");
To generate a valid multipass login token, you need the secret given to you in your Shopify admin.

*return DateTime.Today.Year - this.birth.Year + 1;
数え年

*else if (i == columns.Length - 1) sql.Append($", {column} = :{column.ToPascal()} ");
最後

*await foreach (var chunk in GetSampleData().Chunk(3))*{
3つずつ列挙する
*{await Task.Yield();for (int i = 0; i <; 10; ++i){yield return new SampleData(i);}}
10個のオブジェクトを返す

*return true;
それ以外はOKとする(setされた値になる)
*{InitializeComponent();}
コンストラクタ
*{Console.WriteLine(MethodBase.GetCurrentMethod().Name);// (仮にここでMyTextPropを書き換えたとしても画面側(DispText)には伝わらない！！！！)}
テキストが変化したときのイベント
(仮にここでMyTextPropを書き換えたとしても画面側(DispText)には伝わらない！！！！)
*}

データ表示したい型をuserに代入するとstringに変換される
*var dump = ObjectDumper.Dump(user);
*{test = this.gameObject.GetComponent<;Text>;();//API送るなにか作った想定APIManager.Api(hoge, GetRanking_Success, GetRanking_Failure);}
Start is called before the first frame update
API送るなにか作った想定
*APIManager.Api(hoge, GetRanking_Success, GetRanking_Failure);
受け取りたい型として変換
*GetRankingResponseForm getData = data as GetRankingResponseForm;
受け取った型をstringに変換
*string dump = ObjectDumper.Dump(getData);
表示
*test.text = "成功\n"+dump;

*.Build();
誕生日をセットしていないのでコンパイルエラーにしたい

透明度が変わるスピード
*float fadeSpeed = 0.75f;
画面をフェードさせるための画像をパブリックで取得
*public Image fadeImage;
画像のRGBA値設定用
*float red, green, blue, alfa;
シーン遷移のための型
*string afterScene;
フェードイン用のコルーチン
*IEnumerator fadeInCoroutine;
フェードアウト用のコルーチン
*IEnumerator fadeOutCoroutine;
*{fadeInCoroutine = FadeIn();fadeOutCoroutine = FadeOut();DontDestroyOnLoad(this);SetRGBA(0, 0, 0, 1);StartCoroutine(fadeInCoroutine);//シーン遷移が完了した際にフェードインを開始するように設定SceneManager.sceneLoaded += fadeInStart;}
Start is called before the first frame update
シーン遷移が完了した際にフェードインを開始するように設定
*SceneManager.sceneLoaded += fadeInStart;
*{fadeInCoroutine = FadeIn();StartCoroutine(fadeInCoroutine);}
シーン遷移が完了した際にフェードインを開始するように設定
不透明度を徐々に下げる
*alfa = Mathf.MoveTowards(alfa, 0f, fadeSpeed * Time.deltaTime);
変更した透明度を画像に反映させる関数を呼ぶ
*SetColor();
不透明度を徐々に上げる
*alfa = Mathf.MoveTowards(alfa, 1f, fadeSpeed * Time.deltaTime);
変更した透明度を画像に反映させる関数を呼ぶ
*SetColor();
*{fadeImage.color = new Color(red, green, blue, alfa);}
画像に色を代入する関数
*{red = r;green = g;blue = b;alfa = a;}
色の値を設定するための関数

*...
必要ならここになにかを記述

*return;
ボタン位置から得られたGameObjectとボタンのGameObjectが異なる＝別のもので遮られている ので処理しない
*if (_pointerEventData != null &amp;&amp; _pointerEventData.pointerPress != null &amp;&amp; Input.GetKeyUp(_bindKey))*{
指定したキーの押上

*var findEl = root.SelectSingleNode($"
testBtestTag[text()='{value1}']");
xml保存
*doc.Save(Path.Combine(Environment.CurrentDirectory, "test.xml"));

RenderTextureからTexture2Dに変換
*var original = RenderTexture.active;
3角ポリゴンをつくる3頂点のインデックスを取得
*int p1Index = Triangles[id.x * 3];
3頂点に対応したuv座標を取得
*float2 uv1 = UVs[p1Index];
テクスチャの座標に変換
*uint2 p1Pos = uint2(uv1.x * Width, uv1.y * Height);
*void drawline(uint2 p1, uint2 p2, float4 color) {int2 diffp12 = int2(p2.x-p1.x, p2.y-p1.y);float distp12 = distance(p1, p2);for (int i = 0; i <; distp12; i++){UVMap[p1 + diffp12 / distp12 * i] = color;}}
2点間に線を引く

*private const string BackButtonKey = "__BackButton";
←自作したタグヘルパーのname属性と同じであること。
*{var form = context.HttpContext.Request.Form;var factory = context.HttpContext.RequestServices.GetService(typeof(ITempDataDictionaryFactory)) as ITempDataDictionaryFactory;// ※Post先アクションメソッド(EditとかCreate)の第一引数と、確認画面で定義する「@model」は同じ型であること。※var parameter = context.ActionArguments.FirstOrDefault();// 登録ボタンが押された場合if (form.Any(f =>; f.Key == SubmitButtonKey)){// そのままアクションメソッドのpost処理を実行する。return;}// 確認ボタンが押された場合var viewName = (string)context.RouteData.Values["Action"];if (form.Any(f =>; f.Key == ConfirmButtonKey)){// モデルの検証でエラーが発生しているか調べるif (!context.ModelState.IsValid){// Viewに戻りエラーを表示するreturn;}// 確認画面を表示するためにビュー名を変更viewName += ViewSuffix;}var controller = context.Controller as Controller;// ビューを表示する（戻るボタンを押した場合は入力内容そのままで戻る）context.Result = new ViewResult{ViewName = viewName,// Viewにモデルの内容を渡すために必要。ViewのModelに値が入る。ViewData = new ViewDataDictionary(controller.ViewData) { Model = parameter.Value }};}
アクションメソッド実行前処理
※Post先アクションメソッド(EditとかCreate)の第一引数と、確認画面で定義する「@model」は同じ型であること。※
*var parameter = context.ActionArguments.FirstOrDefault();
*if (form.Any(f =>; f.Key == SubmitButtonKey))*{
登録ボタンが押された場合
そのままアクションメソッドのpost処理を実行する。
*return;
確認ボタンが押された場合
*var viewName = (string)context.RouteData.Values["Action"];
*if (!context.ModelState.IsValid)*{
モデルの検証でエラーが発生しているか調べる
Viewに戻りエラーを表示する
*return;
確認画面を表示するためにビュー名を変更
*viewName += ViewSuffix;
*{ViewName = viewName,// Viewにモデルの内容を渡すために必要。ViewのModelに値が入る。ViewData = new ViewDataDictionary(controller.ViewData) { Model = parameter.Value }};
ビューを表示する（戻るボタンを押した場合は入力内容そのままで戻る）
*ViewData = new ViewDataDictionary(controller.ViewData) { Model = parameter.Value }
Viewにモデルの内容を渡すために必要。ViewのModelに値が入る。
*{}
アクションメソッド実行後処理

*{}
Start is called before the first frame update
*{if (Input.GetKey(KeyCode.UpArrow)){transform.position += new Vector3(0,0,0.1f);}if (Input.GetKey(KeyCode.DownArrow)){transform.position += new Vector3(0,0,-0.1f);}if (Input.GetKey(KeyCode.RightArrow)){transform.position += new Vector3(0.1f,0,0);}if (Input.GetKey(KeyCode.LeftArrow)){transform.position += new Vector3(-0.1f,0,0);}}
Update is called once per frame

発時刻クラス型に変換した後、経過時間（分）の昇順でソートして、
最後に時刻文字列に戻してList化している。
*var sortedTimes = times.Select(time =>; new DepatureTime(time))

*rb.AddForce(1.0f, 2.0f, -1.0f);
加える力のベクトルをVectorで入れる

*{Name = "file1",FilePath = @"d:\test.csv"};
基底型で宣言
*{Name = "file1",FilePath = @"d:\test.csv"};
派生型で宣言
*{Name = "file1",FilePath = @"d:\test.csv"};
基底型で宣言
引数でインスタンスの型を渡す
*return JsonSerializer.Serialize(config, config.GetType(), GetOptions());
*{Name = "file1",FilePath = @"d:\test.csv"};
基底型で宣言
ジェネリックパラメーターで object を指定する
*return JsonSerializer.Serialize<;object>;(config, GetOptions());
*{[JsonIgnore]public DataSourceConfig DataSource { get; set; }[JsonPropertyName("DataSource")][Browsable(false)][EditorBrowsable( EditorBrowsableState.Never)]public object DataSourceObject{get { return DataSource; }set { DataSource = (DataSourceConfig)value; }}}
using System.Text.Json.Serialization;

*if (Input.touchCount >; 0) {*Touch touch = Input.GetTouch(0);
タッチ判定
*if (-3.1 <; transform.position.x) {*transform.Translate(-0.05f, 0, 0);
画面外に行かないようにする
押した時
*anim.SetBool("left_long", true);
長押しの時
*anim.SetBool("left_long", true);
指を離した時
*anim.SetBool("left_long",false);
*if (3.1 >; transform.position.x) {*transform.Translate(0.05f, 0, 0);
画面外に行かないようにする
押した時
*anim.SetBool("right_long", true);
長押しの時
*anim.SetBool("right_long", true);
指を離した時
*anim.SetBool("right_long",false);

localScaleを表すベクトルをワールドの向きに変換
*var worldDirectedLocalScale
ワールド上で上記ベクトルを示す場合のローカル上での表現方法を算出
これがlocalScale設定値の大きさをワールド上で実現するために必要なlocalScaleとなる
*var scaleUnaffectedByParents

*var newReader = jobject.CreateReader();
As JsonReader cannot be used twice, create new one and pass it.

*{var x = 0;while (true){// 割り切れたらif (a % b == 0){return b;}else{x = a % b;a = b;b = x;}}}
最大公約数
*if (a % b == 0)*{
割り切れたら
*{var x = Gcd(a, b);return a * b / x;}
最小公倍数

*{public DateTimeOffset Date { get; set; }public int TemperatureCelsius { get; set; }public string Summary { get; set; }public string SummaryField;public IList<;DateTimeOffset>; DatesAvailable { get; set; }public Dictionary<;string, HighLowTemps>; TemperatureRanges { get; set; }public string[] SummaryWords { get; set; }}
展開する先のクラス構造
*string jsonString = "{\"Date\":\"2019-08-01T00:00:00-07:00\",\"TemperatureCelsius\":25,\"Summary\":\"Hot\",\"DatesAvailable\":[\"2019-08-01T00:00:00-07:00\",\"2019-08-02T00:00:00-07:00\"],\"TemperatureRanges\":{\"Cold\":{\"High\":20,\"Low\":-10},\"Hot\":{\"High\":60,\"Low\":20}},\"SummaryWords\":[\"Cool\",\"Windy\",\"Humid\"]}";
JSON文字列の例
デシリアライズ
*var weatherForecast = JsonConvert.DeserializeObject<;WeatherForecastWithPOCOs>;(jsonString);
Newtonsoft.Jsonを使う
*var weatherForecast = JsonConvert.DeserializeObject(jsonString);
デシリアライズ
*JObject weatherForecast = JObject.Parse(jsonString);
直下の値を取得
*Console.WriteLine("Date: " + weatherForecast["Date"].ToString());
入れ子の値を取得
*Console.WriteLine("TemperatureRanges_Cold_High: " + weatherForecast["TemperatureRanges"]["Cold"]["High"].ToString());
キー
*Console.WriteLine("TemperatureRange Key: " + ((JProperty)TemperatureRange).Name);
値
*Console.WriteLine("TemperatureRange Value: " + TemperatureRange.First["High"]);
一部だけ定型クラスに取り出したい
*HighLowTemps highLowTemps = TemperatureRange.First.ToObject<;HighLowTemps>;();
トップレベルに追加
*weatherForecast["hoge"] = "fuga";
削除
*weatherForecast.Property("Summary").Remove();
*// {}に追加
[]に追加
*new JProperty("Lukewarm", JObject.Parse(@"{""High"": 10,""Low"": 10}"))
{}に追加
*weatherForecast["TemperatureRanges"]["Absolute"] = JObject.Parse(@"{""High"": -273,""Low"": -273}");
これでもいい
JSON文字列に戻す
*var jsonStringAfter = JsonConvert.SerializeObject(weatherForecast);

*{// 実行するラベル名を保存ExecuteScenario.Label = label;StartCoroutine(ExecuteScenarioCoroutine(utageSceneName));}
他シーンのUtage呼び出し
実行するラベル名を保存
*ExecuteScenario.Label = label;
シーン読み込みが完了したか
*private bool IsSceneLoaded;
*{IsSceneLoaded = true;}
シーン読み込み完了イベント
*{IsSceneLoaded = false;SceneManager.LoadScene(utageSceneName);yield return new WaitUntil(() =>; IsSceneLoaded);}
シナリオの呼び出しCorotine
*{// Utage Engine の起動を待つyield return new WaitUntil(() =>; !Engine.IsLoading);// 機能呼び出しyield return StartCoroutine(ExecuteLabel());}
シナリオを呼び出す
Utage Engine の起動を待つ
*yield return new WaitUntil(() =>; !Engine.IsLoading);
機能呼び出し
*yield return StartCoroutine(ExecuteLabel());
*{// 起動ラベルのラベル名を取得string label = ExecuteScenario.Label;// 機能呼び出しTitle.Close();MainGame.OpenStartLabel(label);yield return null;}
機能呼び出し
起動ラベルのラベル名を取得
*string label = ExecuteScenario.Label;
機能呼び出し
*Title.Close();
呼び出すラベル
*public static string Label;

*++index;
"\r"は追加せずにスキップ
*while (content.SafeSubstring(index, 1).IsStart行頭禁則文字())*{
行頭禁則の対応
*if (line.ToString().SafeSubstring(line.Length - 1, 1).IsEnd行末禁則文字())*{
行末禁則の対応
後続に文字がないか、半角スペースの場合は折り返し可能
*return true;
*if (prevChar == "\r")*{
最後に追加した文字が1バイト文字
改行コード
*return true;
１バイト文字が連続している場合
*return false;
1バイト文字と2バイト文字の境界
*return true;
最後に追加した文字がマルチバイト文字
*return true;
UTF-8で１バイトならASCII範囲の文字
*count += (enc.GetByteCount(enumerator.GetTextElement()) >; 1 ? 2 : 1);
UTF-8で１バイトならASCII範囲の文字
*count += (enc.GetByteCount(enumerator.GetTextElement()) >; 1 ? 2 : 1);

*private Transform InstantiateParent = null;
Instantiateで複製したオブジェクトの親
*var guids_prefab = AssetDatabase.FindAssets("t:prefab", new string[] { "Assets/Prefabs" });
指定フォルダのprefabを全取得
アタッチさせたいオブジェクト名を拡張子付きで書く
*prefab = AssetDatabase.LoadAssetAtPath<;GameObject>;("Assets/Prefabs/Info.prefab");
ヒエラルキー上のすべてのオブジェクトを取得
*Object[] allGameObject = Resources.FindObjectsOfTypeAll(typeof(GameObject));
*foreach (GameObject obj in allGameObject)*{
取得したオブジェクトの名前を表示
*if (obj.name == "InfoContent")*{
アタッチさせたいオブジェクト名を書く

*public ObservableCollection<;MyData>; DataList { get; set; } = new ObservableCollection<;MyData>;();
ガンダム情報を格納
*public CollectionViewSource UICollectionViewSource { get { return _UICollectionViewSource; } set { _UICollectionViewSource = value; } }
ソート/グルーピングに使うCollectionViewSource
CollectionViewSourceのソースにDataListを設定
*UICollectionViewSource = new CollectionViewSource();
*{DataList.Add(new MyData() { MachineName = "ガンダム", PilotName = "アムロ" });DataList.Add(new MyData() { MachineName = "シャアザク", PilotName = "シャア" });DataList.Add(new MyData() { MachineName = "グフ", PilotName = "誰やったっけ？" });DataList.Add(new MyData() { MachineName = "Zガンダム", PilotName = "カミーユ" });DataList.Add(new MyData() { MachineName = "ガンダムmk-Ⅱ", PilotName = "アムロ" });DataList.Add(new MyData() { MachineName = "ジ・オ", PilotName = "シロッコ" });DataList.Add(new MyData() { MachineName = "百式", PilotName = "シャア" });DataList.Add(new MyData() { MachineName = "ZZガンダム", PilotName = "ジュドー" });DataList.Add(new MyData() { MachineName = "νガンダム", PilotName = "アムロ" });//ソートの指定SortDescription sortDescription;UICollectionViewSource.SortDescriptions.Clear();sortDescription = new SortDescription{PropertyName = "MachineName",Direction = ListSortDirection.Ascending};UICollectionViewSource.SortDescriptions.Add(sortDescription);sortDescription = new SortDescription{PropertyName = "PilotName",Direction = ListSortDirection.Ascending};UICollectionViewSource.SortDescriptions.Add(sortDescription);//グループの指定PropertyGroupDescription groupDescription;UICollectionViewSource.GroupDescriptions.Clear();groupDescription = new MyDataGroupDescription{// なにでグループを作るか決めるPropertyName = "PilotName"};UICollectionViewSource.GroupDescriptions.Add(groupDescription);UICollectionViewSource.View.Refresh();}
ボタンをおしたらデータの中身を追加
ソートの指定
*SortDescription sortDescription;
グループの指定
*PropertyGroupDescription groupDescription;
なにでグループを作るか決める
*PropertyName = "PilotName"
*{public string MachineName { get; set; }public string PilotName { get; set; }}
ガンダム情報クラス
*{var uiobject = (MyData)item;return uiobject.PilotName;}
データの中身からグループのヘッダに出すものを決める

*{[SerializeField]private TextMeshProUGUI text = default;void Start(){_ = HogeAsync();}async UniTask HogeAsync(){for (var i = 0; ; i++){await UniTask.Delay(1000);text.text = $"count:{i}";}}}
1秒間隔で表示を更新する
破棄されるときにキャンセル状態になるCancellationToken
thisとtextの寿命が違う場合はこれではまずいがとりあえず一緒とする
*var cancellationToken = this.GetCancellationTokenOnDestroy();
CancellationTokenを挿入する
この後の処理でawaitを使用するとawait抜ける際にキャンセル状態がチェックされるようになる
*await YTask.Inject(token);
*for (var i = 0; ; i++)*{
無限ループなのでキャンセルしないと終わらない
CancellationTokenを渡してなくても勝手にキャンセルされる
*await Task.Delay(1000);
*{await Task.Delay(5000);cts.Cancel();});
5秒後にキャンセルする
最上位の非同期メソッドでstatic領域にInjectする
*await YTask.InjectToStatic(token);
await後にstatic領域のCancellationTokenがFugaAsyncの最初にInjectされたものに戻る
よって複数の非同期メソッドを別々のCancellationTokenで同時に動かしてもシングルスレッドの場合は正常に動作する
*await PiyoAsync(name);
下位の非同期メソッドではstatic領域から拾ってきてInjectする
*await YTask.InjectFromStatic();
FugaAsyncの中でも先頭でInjectしているはずなのでCancellationTokenを渡さない
*await FugaAsync();
適当な後続処理...
*}

*Commands = new[]{ProcessCommandFactory.FromCommandLine("command1", "コマンド1", filePath + " 5"), ProcessCommandFactory.FromCommandLine("command2", "コマンド2", filePath + " 4")}
実行するコマンド（並列実行）
終了コードの制御は既定
何れかのコマンドの終了コードが 0 でない場合、最初に見つかった終了コードを返す
*ExitCodeHandler = null
*{// 実行するコマンド（直列実行）Commands = new[]{ProcessCommandFactory.FromFile("command3", "コマンド3", filePath, "3"), ProcessCommandFactory.FromFile("command4", "コマンド4", filePath, "-2")},// 終了コードの制御ExitCodeHandler = ExitCodeHandlerFactory.Create(// 既定の終了コード-1, new[]{// command3 の終了コード = 0 &amp;&amp; command4 の終了コード = 0 =>; 0(new[] { ("command3", 0), ("command4", 0) }, 0)// command3 の終了コード = 1 &amp;&amp; command4 の終了コード = 1 =>; 11, (new[] { ("command3", 1), ("command4", 1) }, 11)// command4 の終了コード = 1 =>; 10, (new[] { ("command4", 1) }, 10)}),// 成功時の次処理NextOnSucceed = new WorkflowItem("root-succeed-succeed", "成功時の後処理"){Command = ProcessCommandFactory.FromFile("command5", "コマンド5", filePath, "1")},// 失敗時の次処理NextOnFailed = new WorkflowItem("root-succeed-failed", "失敗時の後処理"){// 実行するコマンドCommand = ProcessCommandFactory.FromFile("command6", "コマンド6", filePath, "2")}}
成功時の次処理
*{ProcessCommandFactory.FromFile("command3", "コマンド3", filePath, "3"), ProcessCommandFactory.FromFile("command4", "コマンド4", filePath, "-2")}
実行するコマンド（直列実行）
終了コードの制御
*ExitCodeHandler = ExitCodeHandlerFactory.Create(
既定の終了コード
*-1
*(new[] { ("command3", 0), ("command4", 0) }, 0)
command3 の終了コード = 0 &amp;&amp; command4 の終了コード = 0 =&gt; 0
*, (new[] { ("command3", 1), ("command4", 1) }, 11)
command3 の終了コード = 1 &amp;&amp; command4 の終了コード = 1 =&gt; 11
*, (new[] { ("command4", 1) }, 10)
command4 の終了コード = 1 =&gt; 10
*{Command = ProcessCommandFactory.FromFile("command5", "コマンド5", filePath, "1")}
成功時の次処理
*{// 実行するコマンドCommand = ProcessCommandFactory.FromFile("command6", "コマンド6", filePath, "2")}
失敗時の次処理
実行するコマンド
*Command = ProcessCommandFactory.FromFile("command6", "コマンド6", filePath, "2")
*{// 実行するコマンドCommand = ProcessCommandFactory.FromFile("command7", "コマンド7", filePath, "1")}
失敗時の次処理
実行するコマンド
*Command = ProcessCommandFactory.FromFile("command7", "コマンド7", filePath, "1")
ワークフローを実行する
*IWorkflowItem current = item;
環境変数から前処理の終了コードを取得して出力
*var variables = System.Environment.GetEnvironmentVariables();
*for (int i = 0; i <; args.Length; ++i)*{
引数を出力
*if (repeatCount <; 0) { return 1; }
先頭の引数は繰り返し回数を表すものとする

log4net使う準備ここから
*XmlDocument log4netConfig = new XmlDocument();
log4net使う準備ここまで
*logger.Info("Hello World!");
*if (repositoryType == null)*{
If the type is not set then use the default type
*LogLog.Debug(declaringType, "Creating repository for assembly [" + repositoryAssembly + "]");*// Must specify defaults
Not found, therefore create
*#if NETSTANDARD1_3*object[] configAttributes = assembly.GetCustomAttributes(typeof(log4net.Config.ConfiguratorAttribute)).ToArray();
Look for the Configurator attributes (e.g. XmlConfiguratorAttribute) on the assembly
*foreach(log4net.Config.ConfiguratorAttribute configAttr in configAttributes)*{
Delegate to the attribute the job of configuring the repository
*// Do this even if the repository has been configured (or claims to be), this allows overriding*// of the default config files etc, if that is required.
Try to configure the default repository using an AppSettings specified config file
*// of the default config files etc, if that is required.*string repositoryConfigFile = SystemInfo.GetAppSetting("log4net.Config");
Do this even if the repository has been configured (or claims to be), this allows overriding
*if (m_configFile == null || m_configFile.Length == 0)*{
Select the config file
*{fullPath2ConfigFile = SystemInfo.ConfigurationFileLocation;}
Use the default .config file for the AppDomain
*if (m_configFileExtension[0] != '.')*{
Force the extension to start with a '.'
*if (m_configureAndWatch)*{
Do we configure just once or do we configure and then watch?

*click = true;
クリックされた判定にする

*.OrderByDescending(s =<; s.id)
IDの降順

*using CustomInput;
自分で定義したやつ

*public ObservableCollection<;MyData>; DataList { get; set; } = new ObservableCollection<;MyData>;();
ガンダム情報を格納
*{DataList.Add(new MyData() { MachineName = "ガンダム", PilotName = "アムロ" });DataList.Add(new MyData() { MachineName = "シャアザク", PilotName = "シャア" });DataList.Add(new MyData() { MachineName = "グフ", PilotName = "誰やったっけ？" });DataList.Add(new MyData() { MachineName = "Zガンダム", PilotName = "カミーユ" });DataList.Add(new MyData() { MachineName = "ガンダムmk-Ⅱ", PilotName = "アムロ" });DataList.Add(new MyData() { MachineName = "ジ・オ", PilotName = "シロッコ" });DataList.Add(new MyData() { MachineName = "百式", PilotName = "シャア" });DataList.Add(new MyData() { MachineName = "ZZガンダム", PilotName = "ジュドー" });DataList.Add(new MyData() { MachineName = "νガンダム", PilotName = "アムロ" });}
ボタンをおしたらデータの中身を追加

*new public void Dispose()
警告 CS0108 避けに new を付ける.
ベースクラスのdispose簡易実装2.
Dispose() を virtual 宣言する
*public class MyBaseClass : IDisposable
サブクラスのdispose簡易実装２.
Dispose() を override 宣言する
*public class MySubClass : MyBaseClass
ベースクラスのdispose簡易実装３.
sealed 宣言して、派生を禁止する
*sealed public class MyBaseClass : IDisposable

*DateTime tmp = D_Date;
一時変数
*{case DayOfWeek.Sunday:DAY.GetChild(0).GetComponent<;Text>;().color = Color.red;break;case DayOfWeek.Saturday:DAY.GetChild(0).GetComponent<;Text>;().color = Color.blue;break;default:DAY.GetChild(0).GetComponent<;Text>;().color = Color.black;break;}
土曜日青・日曜日赤
*GameObject button = GameObject.Find("GameObject").transform.GetChild(i).gameObject;*button.GetComponent;Button>;().onClick.RemoveAllListeners();
以下3行追加
値を保存する処理など
*}

*options.RespectBrowserAcceptHeader = true;
false by default

ファイルパスを渡すと内部でFileStreamが生成されてそこにデータが流し込まれる
StreamWriterにMemoryStreamとかを渡せば書き込み先を変えられる
*using (var writer = new StreamWriter(@".\test.txt", append: true, encoding: Encoding.UTF8))
非同期でも書ける
*await writer.WriteLineAsync("hunngaaa!!");
*await stream.WriteAsync(new byte[] { 0x76, 0x12, 0x23, 0x99, 0x50, 0x43, 0x18, 0x66 });
バイナリの場合も非同期で書ける
*{Console.WriteLine(reader.ReadLine());Console.WriteLine(await reader.ReadLineAsync());}
StreamWriterと同じ要領で使える
*{var buffer = new byte[8];stream.Read(buffer, 0, 8);Console.WriteLine(string.Join(", ", buffer.Select(b =>; $"{b,2:x2}")));await stream.ReadAsync(buffer, 0, 8);Console.WriteLine(string.Join(", ", buffer.Select(b =>; $"{b,2:x2}")));}
あんまり使わない

SQL ファイルをリソースファイルに登録しておく。
*public string CommandText =>; Resources.FindUserQuery;
*private MyState State { get; }
状態へのアクセス
*private MyView View { get; }
UI へのアクセス
*private IDatabase Database { get; }
DI されるサービス
MyForm に配置してるテキストボックスのテキストを変更する。
MyTextBox フィールドのアクセス指定子を internal にしておけば、このように別のクラスから触れる。
*Form.MyTextBox.Text = text;
*{public long ItemId { get; }public string Text { get; }public bool IsDone { get; }}
entities/TodoList.cs

*public ObservableCollection<;MyData>; DataList { get; set; } = new ObservableCollection<;MyData>;();
ガンダム情報を格納
*{DataList.Add(new MyData() { MachineName = "ガンダム", PilotName = "アムロ" });DataList.Add(new MyData() { MachineName = "シャアザク", PilotName = "シャア" });DataList.Add(new MyData() { MachineName = "グフ", PilotName = "誰やったっけ？" });DataList.Add(new MyData() { MachineName = "Zガンダム", PilotName = "カミーユ" });DataList.Add(new MyData() { MachineName = "ジ・オ", PilotName = "シロッコ" });DataList.Add(new MyData() { MachineName = "百式", PilotName = "シャア" });DataList.Add(new MyData() { MachineName = "ZZガンダム", PilotName = "ジュドー" });}
ボタンをおしたらデータの中身を追加

*using System;
DateTimeを使用する為追加。
テキストUIをドラッグ&amp;ドロップ
*[SerializeField] Text DateTimeText;
DateTimeを使うため変数を設定
*DateTime TodayNow;
時間を取得
*TodayNow = DateTime.Now;
テキストUIに年・月・日・秒を表示させる
*DateTimeText.text = TodayNow.Year.ToString() + "年 " + TodayNow.Month.ToString() + "月" + TodayNow.Day.ToString() + "日" + DateTime.Now.ToLongTimeString();

*humanPose.muscles[58] = (1 - (2 * actionLeftSkeleton.thumbCurl))
2;  指の第1関節の曲がる量を半分にする
左人差し指
*humanPose.muscles[59] = 1 - (2 * actionLeftSkeleton.indexCurl);
左中指
*humanPose.muscles[63] = 1 - (2 * actionLeftSkeleton.middleCurl);
左薬指
*humanPose.muscles[67] = 1 - (2 * actionLeftSkeleton.ringCurl);
左小指
*humanPose.muscles[71] = 1 - (2 * actionLeftSkeleton.pinkyCurl);
右親指
humanPose.muscles[75] = 1 - (2 * actionRightSkeleton.thumbCurl);
*humanPose.muscles[77] = 1 - (2 * actionRightSkeleton.thumbCurl);
右人差し指
*humanPose.muscles[79] = 1 - (2 * actionRightSkeleton.indexCurl);
右中指
*humanPose.muscles[83] = 1 - (2 * actionRightSkeleton.middleCurl);
右薬指
*humanPose.muscles[87] = 1 - (2 * actionRightSkeleton.ringCurl);
右小指
*humanPose.muscles[91] = 1 - (2 * actionRightSkeleton.pinkyCurl);

*s =<; s.Created);
結果出力用

*buf[i + 1] = 0;
G
画像色用256配列を用意
*var histogram = new int[256];
Rの頻度を数える
*histogram[buf[i + 2]]++;
Gの頻度を数える
*histogram[buf[i + 1]]++;
Bの頻度を数える
*histogram[buf[i]]++;
Chartコントロール内のグラフ、凡例、目盛り領域を削除
*chart.Series.Clear();
目盛り領域の設定
*var ca = chart.ChartAreas.Add("Histogram");
X軸
ca.AxisX.Title = "Pixel";   タイトル
ca.AxisX.Minimum = 0;            最小値
ca.AxisX.Maximum = 256;          最大値
ca.AxisX.Interval = 64;          目盛りの間隔
ca.AxisY.Title = "Count";        Y軸
*ca.AxisY.Minimum = 0;
グラフの系列を追加
*var series = chart.Series.Add("Histogram");
グラフの種類を折れ線に設定する
*series.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;
*if (color == ColorEnum.Red)*{
輪郭線の色
*for (int i = 0; i <; data.Length; i++)*{
データ挿入

*if (FileName_IsError(fileName) == 1) return;*string filePath = Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory)
入力値が正常かチェック
*if (!File.Exists(filePath))*{
読み込むファイルの存在確認
*{string readText = sr.ReadToEnd();string[] splitReadText = readText.Split(new string[] { "\r\n" }, StringSplitOptions.None);List<;string>; logData = new List<;string>;(splitReadText);logData.RemoveRange(0,3);// データをロック・アンロックでわけるList<;string>; lockData = new List<;string>;();List<;string>; unlockData = new List<;string>;();foreach (string dataLine in logData){if (dataLine.EndsWith("4800")){lockData.Add(dataLine);}if (dataLine.EndsWith("4801")){unlockData.Add(dataLine);}}// 組み合わせのロック開始～アンロックの時間を算出int dataCount = Math.Min(lockData.Count(), unlockData.Count());for (int i = 0; i <; dataCount; i++){string[] splitLockData = lockData[i].Split(' ');string[] splitUnockData = unlockData[i].Split(' ');TimeSpan processTime = Convert.ToDateTime(splitUnockData[1])- Convert.ToDateTime(splitLockData[1]);string[] hhmmss = processTime.ToString().Split(':');outputData.Add(string.Concat(splitLockData[0], " ",splitLockData[1], " から\t", hhmmss[0], " 時間 ", hhmmss[1], " 分 ", hhmmss[2], " 秒"));}}
ファイル読み込み
データをロック・アンロックでわける
*List<;string>; lockData = new List<;string>;();
組み合わせのロック開始～アンロックの時間を算出
*int dataCount = Math.Min(lockData.Count(), unlockData.Count());
*foreach(string data in outputData)*{
保持したデータを画面に出力

*for (int i = n, i3 = n * 3; i <;= 0; i--, i3 -= 3)
対角要素の右隣の要素を対応するx（計算済み）にかけて引いて割る
*{for (int i = isLoop ? 0 : 1; i <; (isLoop ? n : (n-1)); i++){var ofs = (i+1) * 3;var next = (i + 1) % n;var prev = (i - 1 + n) % n;//ランクが下がってしまう場合微調整if (ts[i] == 1 &amp;&amp; ts[next] == 0 || !isLoop &amp;&amp; i == n - 2 &amp;&amp; ts[i] == 1)ts[i] = 0.99999f;if (!isLoop &amp;&amp; i == 1 &amp;&amp; ts[i] == 0)ts[i] = 0.00001f;var tmp = (1 - ts[i]) * (1 - ts[i]);A[ofs] = (1 - lambdas[prev]) * tmp;A[ofs + 1] = lambdas[prev] * tmp + (2 - (1 + lambdas[i]) * ts[i]) * ts[i];A[ofs + 2] = lambdas[i] * ts[i] * ts[i];}}
係数行列Aを構成（端の部分はStep0で初期化済）
*if (ts[i] == 1 &amp;&amp; ts[next] == 0 || !isLoop &amp;&amp; i == n - 2 &amp;&amp; ts[i] == 1)*ts[i] = 0.99999f;
ランクが下がってしまう場合微調整
入出力ベクトルを拡張
*var extendedPs = new ExtendedPlayerControls(ps,cs);
連立方程式を解く
*SolveTridiagonalEquation(A, extendedCs, extendedPs);
ベジェ制御点を計算
*var cs = CalcBezierControls(points, calcSpace, iteration, isLoop);
各セグメントについて、指定されたステップ数で分割した点を計算
*return CalcPlots(cs, plotSpace, stepPerSegment, isLoop);
イテレーション回数
*var iteration = 10;
ループするかどうか
*var isLoop = true;
セグメントごとの分割数
*var step = 20;
ユーザ制御点を更新
*Vector2[] input = /*更新処理*/;
計算用空間確保（本来はキャッシュしておく）
*var cSpace = new KCurves.CalcSpace(input.Length);
プロット用空間確保（本来はキャッシュしておく）
*var pSpace = new KCurves.PlotSpace(input.Length, step, isLoop);
実行
*var output = KCurves.CalcPlots(input, cSpace, pSpace, iteration, step, isLoop);
前略
*Step0(points, space.C, space.L, space.A, isLoop);

*ui.Keyin(true, ResultElement, "^c");
^ = CTRL
notepadを起動させます。
*Process notepad = Process.Start(@"notepad");
起動待ち
*Thread.Sleep(2000);
電卓のMainFRameのAutomationElementを取得
notepad = ui.UpdateTargetProcess("メモ帳");  更新
*AutomationElement notepadElement = ui.GetMainFrameElement(notepad);
で、ペーストします。
ui.Keyin(true, notepadElement, "^v");  ^ = CTRL
さらにメニューをクリック操作してバージョンを出します。
string notepadHelpMenuId = "Item 5";  「メニュー」のAutomationId
*ui.ClickElement(notepadElement, notepadHelpMenuId);
確認のメッセージです。
*Console.WriteLine("notepadの内容を確認して、<;enter>;して下さい（電卓は消しますがnotepadhaは残します）");
電卓プロセスを終了させます
*calc.CloseMainWindow();

*{protected abstract void Morning();protected abstract void Afternoon();protected abstract void Night();public void Play(){Morning();Afternoon();Night();}}
スーパークラスで処理の枠組みを決めます。

ExpandoObjectクラスのインスタンスを生成
*dynamic obj = new ExpandoObject();
プロパティを設定
*obj.Height = 100;
*Console.WriteLine("Height: {0}", obj.Height);
各プロパティを出力
ExpandoObjectクラスのインスタンスを生成
*dynamic obj = new ExpandoObject();
プロパティを設定
*obj.Height = 100;
*Console.WriteLine("Height: {0}", obj.Height);
各プロパティを出力
Jsonファイル読み込み
*var sr = new StreamReader(@"C:\work\sample.json");
ExpandoObjectクラスのインスタンスを生成
*dynamic obj = JsonConvert.DeserializeObject<;ExpandoObject>;(json);
プロパティ出力
*Console.WriteLine(obj.Name);

*if (record->;event.pressed) {key_timer = timer_read();layer_on(_LOWER);}else{layer_off(_LOWER);if(timer_elapsed(key_timer) <;= 120){tap_code16(LCTL(KC_SPC));}}
ここから上省略

ウルフラム・コードを2進数に変換し8桁0埋め
*var ruleBinArray = int.Parse(Convert.ToString(ruleDec, 2)).ToString("D8").ToCharArray();
近傍の状態を表す10進数
*var n = 7;
*foreach (var bin in ruleBinArray)*{
ルールを生成
第1世代のセル・オートマトンを生成し初期状態を与える
*var firstGene = "0".PadLeft(automatonSize + 2, '0').ToCharArray();
セルの状態に応じて描画
*var view = cell == '0' ? " " : "*";
左端は常に0
*var nextGene = "0";
*for (var i = 1; i <; automatonSize + 1; i++)*{
ルールに従って次世代のセル・オートマトンを生成
右端は常に0
*return nextGene + "0";

*{public static void Log(string message, [CallerMemberName] string callerMember = "", [CallerFilePath] string callerFilePath = "", [CallerLineNumber] int callerLineNumber = -1){Console.WriteLine($"[{callerMember}] {message} ({callerFilePath}:{callerLineNumber})")}}
using System.Runtime.CompilerServices;
のようなコードとしてコンパイルされます。
*LogUtility.Log("Start!");

または
*HogeAttribute hoge = Attribute.GetAttribute(typeof(TargetClass), typeof(HogeAttribute)) as HogeAttribute;

*{class Program{static void Main(string[] args){Foo.Bar.Print();Foo.Baz.Print();}}}
Program.exe
TypeForwadedToによりAssemblyBのFoo.Barへ転送される
*[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(Foo.Bar))]

*Beep(523, 500);
ド
*foreach(string s in str) {p(s);}
forループで分割
3秒スリープ
*System.Threading.Thread.Sleep(3000);
*string source = File.ReadAllText("main.cs", Encoding.GetEncoding("shift_jis"));*// 行末のスペースを無視しつつ、改行区切り
読み込み
行末のスペースを無視しつつ、改行区切り
*string pattern = @"\s*\r\n";
*foreach(var line in lines) {*p(line);
正規表現で分割

例外発生
*TimeSpan ts = TimeSpan.Parse("30:00");

*//public new ImeMode ImeMode { get { return base.ImeMode; } set { base.ImeMode = ImeMode.Disable; } }
[EditorBrowsable(EditorBrowsableState.Never)]
*{// テキスト開始位置をこの時点で取得selectionStart = base.SelectionStart;base.OnKeyPress(e);}
public new ImeMode ImeMode { get { return base.ImeMode; } set { base.ImeMode = ImeMode.Disable; } }
テキスト開始位置をこの時点で取得
*selectionStart = base.SelectionStart;

*childObject.gameObject.transform.localEulerAngles = new Vector3(0.0f, 0f, 0f);
親と同じ向き
*private void OnCollisionEnter(Collision col){if (col.gameObject.CompareTag("Player")){//衝突した時の処理}}
Playerタグを持ってるオブジェクトとの衝突
衝突した時の処理
*}

Tween開始
*Vector2 start = Vector2.zero;
Tween開始
*Vector2 start = Vector2.zero;
*if (DOTween.instance != null)*{
Tween破棄

*private List<;Linking>; linkings = new List<;Linking>;() {new Linking(){ Text="いぇ", Inputs=new []{ "ye" } },new Linking(){ Text="きゃ", Inputs=new []{ "kya" } },new Linking(){ Text="きゅ", Inputs=new []{ "kyu" } },new Linking(){ Text="きょ", Inputs=new []{ "kyo" } },new Linking(){ Text="ぎゃ", Inputs=new []{ "gya" } },new Linking(){ Text="ぎぃ", Inputs=new []{ "gyi" } },new Linking(){ Text="ぎゅ", Inputs=new []{ "gyu" } },new Linking(){ Text="ぎぇ", Inputs=new []{ "gye" } },new Linking(){ Text="ぎょ", Inputs=new []{ "gyo" } },new Linking(){ Text="くぁ", Inputs=new []{ "qya", "qwa", "qa", "kwa" } },：長過ぎるので割愛};
「し」「ゃ」とかを「しゃ」に連結したパターンを生成する
１文字ずつ解析していく
「しゃ」とかも「し」「ゃ」に分割される
*int index = 0;
１文字で表現できるものを取得
ローマ字は、文字は同じでも入力方法は複数ある
*var simpleChars = SimpleChars(c).ToList();
*foreach (var prevNode in currents)*{
前回からリストをつなげる
前回値を今回取得したやつにする
*currents.Clear();
インデクサをクリア
*currents.Clear();
最後に追加した要素
*currents.AddRange(lasts);
*if (at.Text.Equals("ん"))*{
「ん」の「n」だけでいいパターンを生成する
*{IndexOfWord = at.IndexOfWord,IndexOfSentence = this.IndexOfSentence,Game = this.Sentence.Game,};
次が「や」「な」「あ」行でないなら”n”だけでOK
*if (at.Text.Equals("っ"))*{
「っ」のパターンを生成する
前の要素（候補）
*prevs.AddRange(at.Prev);
前の要素は重複している可能性があるのでダイエット
*prevs = prevs.Distinct(new TypeCharEquality()).ToList();
先頭まで戻ってきたら終わり
*break;

*string P_s_名前 { get; set; }
名前、プロパティ
*bool P_b_名前があるか { get; }
名前があるか、プロパティ
名前を言え、メソッド
*void 名前を言え();
名前、プロパティ
*private string m_s_名前;
名前があるか、プロパティ
*public bool P_b_名前があるか =>; !string.IsNullOrWhiteSpace(P_s_名前);
*{if (P_b_名前があるか)MessageBox.Show($"こんにちは、{P_s_名前}さん");elseMessageBox.Show($"名前を入力してください", "お願い",MessageBoxButton.OK, MessageBoxImage.Exclamation);}
名前を言え、メソッド

*"https:
api.github.comgraphql",

以下略
*var esk = new Youmu();

*.Where(x =<; x)
FontTextureなど、ロードできないものを除外
*foreach (var icon in icons)*{
各項目のfoldoutを初期化
*if(evt.type == EventType.Repaint)*{
GUIStyleのキャッシュ
*if (maxLabelWidth <;= 0)*{
ラベル描画領域に必要な幅を計算
アイコン描画領域に必要な幅を計算
*RectOffset iconPadding = new RectOffset(10, 10, 4, 4);
フィルタ
*filter = FilterField(filter, Repaint);
ヘッダ
*var headerHeight = 24;
リスト
*var elementMinHeight = 20;
*if (!string.IsNullOrEmpty(filter) &amp;&amp; !icon.name.ToLower().Contains(filter.ToLower())) continue;*var iconRectHeight = Mathf.Max(elementMinHeight, icon.height + iconPadding.top + iconPadding.bottom);
フィルタ内容に応じてスキップ
*if (foldouts[icon.name])*{
コピー用フォーム・詳細情報
*if (evt.type == EventType.MouseDown &amp;&amp; evt.button == 0 &amp;&amp; elementMainRect.Contains(evt.mousePosition))*{
クリックでコピー用フォームを開閉
*if (GUI.GetNameOfFocusedControl() == controlName &amp;&amp; evt.type == EventType.KeyDown &amp;&amp; evt.keyCode == KeyCode.Return)*{
入力中にEnterキーでフォーカスを外す
入力欄
*GUI.SetNextControlName(controlName);
*if (evt.type == EventType.MouseDown &amp;&amp; evt.button == 0 &amp;&amp; !lastrect.Contains(evt.mousePosition))*{
入力欄以外でクリックされたらフォーカスを外す
*{if (GUILayout.Button("Clear", "SearchCancelButton")){filter = "";}}
クリアボタン

Assetsフォルダからのフルパス.
*string path = "Assets/";
GameObjectだったりScriptableObjectだったり.
*AssetDatabase.LoadAssetAtPath<;GameObject>;(path),

敵に当たったら音が鳴ってマテリアル変更→無敵時間を作って終わったらマテリアルを元に戻す
*this.OnTriggerEnterAsObservable()

*GeneratedResolver.Instance
今回事前生成しようとしているResolver

*scaleFactor *= 0.95f;
Reduce amplitude slightly to make highly compressed signals fit.
公式実装に倣って補正
*amplitudeScale *= 0.95f;
データ取得
*var audioImporter = InternalAudioUtil.GetImporterFromClip(clip);
全体の最大値・最小値を計算
*float minOfAll = 0;
チャンネル数・サンプル数
*int numChannels = clip.channels;
１チャンネルごとの専有height
*float h = rect.height / numChannels;
*for (int channel = 0; channel <; numChannels; channel++)*{
各チャンネルについて波形描画
描画範囲計算
*Rect channelRect = new Rect(rect.x, rect.y + h * channel, rect.width, h);
*{if (numSamples <;= 0){minValue = 0.0f;maxValue = 0.0f;}else{//minMaxDataの現在のx座標に対応する値を取得float p = Mathf.Clamp(x * (numSamples - 2), 0.0f, numSamples - 2);int i = (int)Mathf.Floor(p);int offset1 = (i * numChannels + channel) * 2;int offset2 = offset1 + numChannels * 2;minValue = Mathf.Min(minMaxData[offset1 + 1], minMaxData[offset2 + 1]) * amplitudeScale;maxValue = Mathf.Max(minMaxData[offset1 + 0], minMaxData[offset2 + 0]) * amplitudeScale;if (minValue >; maxValue) { float tmp = minValue; minValue = maxValue; maxValue = tmp; }}//色を指定col = colorSetter?.Invoke(channel, x, minValue, maxValue, minOfAll, maxOfAll) ?? new Color(1, 0.54902f, 0, 1);};
描画内容定義
minMaxDataの現在のx座標に対応する値を取得
*float p = Mathf.Clamp(x * (numSamples - 2), 0.0f, numSamples - 2);
色を指定
*col = colorSetter?.Invoke(channel, x, minValue, maxValue, minOfAll, maxOfAll) ?? new Color(1, 0.54902f, 0, 1);
描画
*AudioCurveRendering.DrawMinMaxFilledCurve(channelRect, dlg);
*{RenderPreview(rect, clip, (_, __, ___, ____, _____, ______) =>; color, amplitudeScale);}
単色指定ver
*{RenderPreview(rect, clip, (_, t, ___, ____, _____, ______) =>; Color.Lerp(start, finish, t), amplitudeScale);}
時間経過でグラデーションver
*{RenderPreview(rect, clip, (channel, _, min, max, minOfAll, maxOfAll) =>;Color.Lerp(lowAmp, highAmp, Mathf.Clamp01((max - min) / (maxOfAll - minOfAll))), amplitudeScale);}
振幅の大小でグラデーションver
ProjectWindowの型キャッシュ。Ping時にProjectWindowを開くために使用。
*readonly static Type tProjectWindow = typeof(Editor).Assembly.GetType("UnityEditor.ProjectBrowser");
ObjectPicker使用時の、対応するプロパティごとのControlID
*static Dictionary<;string, int>; objectPickerControls = new Dictionary<;string, int>;();
プロパティごとのユニークID生成器
*static string MakeUniquePropKey(SerializedProperty prop)
ヘッダ
*EditorGUI.DrawRect(headerRect, frameColor);
背景
*EditorGUI.DrawRect(waveRect, bgColor);
波形表示
*InternalAudioUtil.RenderAmplitudeAwarePreview(waveRect, clip, Color.yellow, Color.red, amplitudeScale);

*Console.WriteLine(pe.StandardOutput);
標準出力の結果を出力

*return false;
3

*internal class Class1 : INotifyPropertyChanged
バインディングさせるソースは、INotifyPropertyChangedが必要
オリジナルなUserControlのデータソースになるクラスのポインタ
Factoryによって、コンストラクタ引数で設定している
このClassLibrary1を利用する側 WpfApp14 には公開したくないので、internalになっている
*internal Class1 obj { set; get; } = null;
*{obj = sorce;// ★オリジナルなUserControlにデータソースを設定Control1.DataContext = (object)obj;// ★UserControl内の依存関係プロパティとデータソースのプロパティをバインドするControl1.SetBinding(UserControl1.値2Property, nameof(Class1.val1));}
コンストラクタ 上と同じく公開したくないので、internalになっている
★オリジナルなUserControlにデータソースを設定
*Control1.DataContext = (object)obj;
★UserControl内の依存関係プロパティとデータソースのプロパティをバインドする
*Control1.SetBinding(UserControl1.値2Property, nameof(Class1.val1));
*{obj.val1 += 1;}
内部を動かす処理関数
*public UserControl1 Control1 { private set; get; } = new UserControl1();
公開するユーザコントロール
オリジナルのUserControl1に表示される値とつながる依存関係プロパティ
*public static readonly DependencyProperty 値2Property = DependencyProperty.Register("値2", typeof(int), typeof(UserControl1),
値が変化したときに動く処理。値が設定されたときに動く訳ではないので、注意。
*UserControl1 ctrl = obj as UserControl1;
ここで画面更新
*ctrl.label2.Content = ctrl.値2;
このサンプルでは、WpfApp14プロジェクトが、ClassLibrary1プロジェクトを使って、機能実装するサンプル
ClassLibrary1プロジェクトは、Factoryクラスを持っていて、内部的にインスタンスを生成する
このWpfApp14のMainWindowは、ClassLibrary1が提供する機能を利用し、公開されているUserControlも利用するというサンプル
*ClassLibrary1Factory factory = ClassLibrary1Factory.GetInstance();
公開されているUserControlを取得
*UserControl ClassLibrary1から取得した実体のUserControl = factory.公開するものだけを持つクラス.Control1;
取得したUserControlをMainWindowに差し込む
*stackPanel1.Children.Add(ClassLibrary1から取得した実体のUserControl);
公開されている機能を実行すると、その機能の実行結果として、公開されているUserControlの値が更新されるサンプル
*factory.公開するものだけを持つクラス.Start();

MoveCubeはどこのどのIInputProviderを使えばいいかわからない
*IInputProvider inputProvider;
*if (inputProvider.InputRight(tmpFlag))*{
Right
適当な処理
*}
*if (inputProvider.InputLeft(tmpFlag))*{
Left
適当な処理
*}
*if (inputProvider.InputUp(tmpFlag))*{
Up
適当な処理
*}
*if (inputProvider.InputDown(tmpFlag))*{
Down
適当な処理
*}
*#if UNITY_ANDROID || UNITY_IOS*JoyStickInputInstaller.Install(Container);
スマホ用
*#if UNITY_WEBGL*KeyInputInstaller.Install(Container);
WebGL

*inStr = "
" + inStr;
通信～デシリアライズ前とは逆の変換
*inStr = inStr.Replace("/", "\\");

二度目は何も変わっていないが，メソッドは再び呼ばれている．
*var u2 = v.Property;

*List<;TurnableStone<; turnableStoneList = new List<;TurnableStone<;();
ひっくり返す石のリスト
ひっくり返す対象
*turnableStoneList.Add(new TurnableStone(_z, _x));
ひっくり返すことができる
*isTurnable = true;
*if (isTurnable)*{
ひっくり返す処理

*GameObject hogeGameObject = new GameObject(origin);
Hogeを複製

workフォルダにpythonファイルに書き込む
*String path = this.textBox3.Text.Trim() + System.IO.Path.DirectorySeparatorChar + this.pythonFileName;
前処理
*button1.Enabled = false;
実行
*RunCommandLineAsync(path);
非同期で出力とエラーの読み取りを開始
*p.BeginOutputReadLine();
吐き出されずに残っているデータの吐き出し
*this.Invoke((MethodInvoker)(() =>; AppendText(outStringBuilder.ToString(), false)));
pythonファイルを削除する
*String pythonFilepath = this.textBox3.Text.Trim() + System.IO.Path.DirectorySeparatorChar + this.pythonFileName;
完了メッセージ
*this.Invoke((MethodInvoker)(() =>; MessageBox.Show("処理をキャンセルしました")));
完了メッセージ
*this.Invoke((MethodInvoker)(() =>; MessageBox.Show("処理が完了しました")));
完了メッセージ
*this.Invoke((MethodInvoker)(() =>; MessageBox.Show("エラーが発生しました")));
*if (readCount % 5 == 0)*{
まとまったタイミングで吐き出し
*if (readCount % 1000 == 0)*{
スレッドを占有しないようスリープを入れる
Pythonコード部分のクリア
*this.textBox4.Clear();
標準出力エリアのクリア
*this.textBox1.Clear();

*public int processId { get; set; }
データグリッドで自動で見せる列
データグリッドで自動で見せない列
*private Process process;

*.RepeatSafe();
判定が終わったら繰り返し

*public int blackScore;
黒の枚数
石を64枚EMPTYで生成
*GameObject stone = GameObject.Instantiate<;GameObject>;(firstStone);

フェードアウト処理の開始、完了を管理するフラグ
*private bool isFadeOut = false;
フェードイン処理の開始、完了を管理するフラグ
*private bool isFadeIn = true;
透明度が変わるスピード
*float fadeSpeed = 0.75f;
画面をフェードさせるための画像をパブリックで取得
*public Image fadeImage;
シーン遷移のための型
*string afterScene;
*{DontDestroyOnLoad(this);SetRGBA(0, 0, 0, 1);//シーン遷移が完了した際にフェードインを開始するように設定SceneManager.sceneLoaded += fadeInStart;}
Start is called before the first frame update
シーン遷移が完了した際にフェードインを開始するように設定
*SceneManager.sceneLoaded += fadeInStart;
*{isFadeIn = true;}
シーン遷移が完了した際にフェードインを開始するように設定
*{if (isFadeIn == true){//不透明度を徐々に下げるalfa -= fadeSpeed * Time.deltaTime;//変更した透明度を画像に反映させる関数を呼ぶSetColor();if (alfa <;= 0)isFadeIn = false;}if (isFadeOut == true){//不透明度を徐々に上げるalfa += fadeSpeed * Time.deltaTime;//変更した透明度を画像に反映させる関数を呼ぶSetColor();if (alfa >;= 1){isFadeOut = false;SceneManager.LoadScene(afterScene);}}}
Update is called once per frame
不透明度を徐々に下げる
*alfa -= fadeSpeed * Time.deltaTime;
変更した透明度を画像に反映させる関数を呼ぶ
*SetColor();
不透明度を徐々に上げる
*alfa += fadeSpeed * Time.deltaTime;
変更した透明度を画像に反映させる関数を呼ぶ
*SetColor();
*{fadeImage.color = new Color(red, green, blue, alfa);}
画像に色を代入する関数
*{red = r;green = g;blue = b;alfa = a;}
色の値を設定するための関数
*{//SceneFadeManagerがアタッチされているオブジェクトを取得ManageObject = GameObject.Find("ManageObject");//オブジェクトの中のSceneFadeManagerを取得fadeManager = ManageObject.GetComponent<;SceneFadeManager>;();}
Start is called before the first frame update
SceneFadeManagerがアタッチされているオブジェクトを取得
*ManageObject = GameObject.Find("ManageObject");
オブジェクトの中のSceneFadeManagerを取得
*fadeManager = ManageObject.GetComponent<;SceneFadeManager>;();
*{if(Input.GetMouseButtonDown(0)){//SceneFadeManagerの中のフェードアウト開始関数を呼び出しfadeManager.fadeOutStart(0, 0, 0, 0, "Scene2");}}
Update is called once per frame
SceneFadeManagerの中のフェードアウト開始関数を呼び出し
*fadeManager.fadeOutStart(0, 0, 0, 0, "Scene2");

AudioUtil型
*static readonly Type tAudioUtil = typeof(Editor).Assembly.GetType("UnityEditor.AudioUtil");
コンパイル済みメソッドのキャッシュ
*static readonly ConcurrentDictionary<;Method, Func<;object[], object>;>;
*{return compiled.GetOrAdd(method, _m =>;{//キャッシュが存在しなければここに来る//MethodInfo取得var m = tAudioUtil.GetMethod(_m.ToString(), BindingFlags.Static | BindingFlags.Public);//voidメソッドのためのreturn先ラベルを定義var voidTarget = Expression.Label(typeof(object));//引数はobject[]var args = Expression.Parameter(typeof(object[]), "args");//MethodInfoのパラメータの型に引数をキャストするExpressionの束var parameters = m.GetParameters().Select((x, index) =>;Expression.Convert(Expression.ArrayIndex(args, Expression.Constant(index)),x.ParameterType)).ToArray();//式木構築var lambda = Expression.Lambda<;Func<;object[], object>;>;(m.ReturnType == typeof(void)//voidメソッドの場合、ブロックにしてreturn default(object)する必要がある? (Expression)Expression.Block(Expression.Call(null, m, parameters),Expression.Return(voidTarget, Expression.Default(typeof(object))),Expression.Label(voidTarget, Expression.Constant(null)))//返り値がある場合はCallして結果をobjectにキャストするだけ: Expression.Convert(Expression.Call(null, m, parameters),typeof(object)),args);//コンパイルしてキャッシュしつつ返すreturn lambda.Compile();});}
キャッシュからメソッドを取得する。コンパイル済みでなければコンパイルしてキャッシュし、それを返す。
キャッシュが存在しなければここに来る
MethodInfo取得
*var m = tAudioUtil.GetMethod(_m.ToString(), BindingFlags.Static | BindingFlags.Public);
voidメソッドのためのreturn先ラベルを定義
*var voidTarget = Expression.Label(typeof(object));
引数はobject[]
*var args = Expression.Parameter(typeof(object[]), "args");
MethodInfoのパラメータの型に引数をキャストするExpressionの束
*var parameters = m.GetParameters()
式木構築
*var lambda = Expression.Lambda<;Func<;object[], object>;>;(
voidメソッドの場合、ブロックにしてreturn default(object)する必要がある
*? (Expression)Expression.Block(
返り値がある場合はCallして結果をobjectにキャストするだけ
*: Expression.Convert(
コンパイルしてキャッシュしつつ返す
*return lambda.Compile();

*EditorApplication.update -= Repaint;
増殖を防ぐ
キャッシュ
*static readonly FieldInfo fi_m_NativeObjectPtr = typeof(SerializedObject)

*{// context = SynchronizationContext.Current;Debug.Log("Start Click Method : " + Thread.CurrentThread.ManagedThreadId);await Task.Run(HeavyMethod);FinalizeMethod();Debug.Log("End Click Method : " + Thread.CurrentThread.ManagedThreadId);}
private SynchronizationContext context;

*.WithOrigins(new string[] { "http:
localhost:8080" })
*{// ~省略~app.UseEndpoints(endpoints =>;{endpoints.MapControllerRoute(name: "default",pattern: "{controller}/{action=Index}/{id?}");});// ↓追加↓app.UseCors();}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
*{endpoints.MapControllerRoute(name: "default",pattern: "{controller}/{action=Index}/{id?}");});
~省略~
↓追加↓
*app.UseCors();

*class Class1 : INotifyPropertyChanged
バインディングさせるソースは、INotifyPropertyChangedが必要

*Console.WriteLine($"[{food}]");
以下のような変数を定義すると
このように出力される
*→ [     apple     ]
*Console.WriteLine($"[{trimFood}]");
先頭のみトリミング
*Console.WriteLine($"[{trimFood}]");
末尾のみトリミング
置き換えを行う時はReplaceメソッドを使用する
*fav = fav.Replace("Movie", "Running");

*while (iEnumerator.MoveNext()) {Debug.Log($"Coroutine Return {iEnumerator.Current}");}
iEnumerator.Reset();     &lt;- NotSupportedExceptionがスローされる

*{}
↓

*{Extension.Swap(ref sbyte,ref sbyte);Extension.Swap(ref byte,ref byte);Extension.Swap(ref short,ref short);Extension.Swap(ref ushort,ref ushort);Extension.Swap(ref int,ref int);Extension.Swap(ref uint,ref uint);Extension.Swap(ref long,ref long);Extension.Swap(ref ulong,ref ulong);Extension.Swap(ref char,ref char);Extension.Swap(ref float,ref float);Extension.Swap(ref double,ref double);Extension.Swap(ref string,ref string);Extension.Swap<;T>;(ref T, ref T)where T:UnityEngine.Object;}
入れ替え処理一部intなどは普通の入れ替えより少し処理速度が速いです。
trueならfalseにfalseならtrue。
*flag.Switching();
一番先頭の要素を返す。
*T t=array.First();
一番最後の要素を返す。
*T t=array.Last();
大量のソートを行う場合既存のソートより早いです。
*QuickSort(int[] array,int left,int right,bool ascending = true);
一番先頭の要素を返す。
*T t=list.First();
一番最後の要素を返す。
*T t=list.Last();
要素の中にあるnullを削除する
*list.RemoveNull();
要素の中にnullがあればそこに割り振る場合によってはAddする
*list.Allocation(T _add,bool _addFlag=false);
自身のオブジェクトから一番近いオブジェクトを返します
*GameObject game=gameObject.GetClosestObjectArray(GameObject[] array);
自身のオブジェクトから一番近いオブジェクトを返します
*game=gameObject.GetClosestObjectList(GameObject[] array);
自身を破壊
*gameObject.Destroy();
コンポーネントを取得、なければ追加
*gameObject.GetOrAddComponent<;T>;();
最上層の親オブジェクトを返します。親オブジェクトが存在しない場合自身を返す。
*game=gameObject.GetTopParent();
深い階層まで子オブジェクトを名前で検索します
*game=gameObject.GetTopParent(string name,bool includeInactive = false);
全ての子オブジェクトを返します
*GameObject[] games=gameObject.GetChildren(bool includeInactive = false);
X座標を設定します
*gameObject.SetPositionX(float x);
Y座標を設定します
*gameObject.SetPositionY(float y);
Z座標を設定します
*gameObject.SetPositionZ(float z);
X座標を加算します
*gameObject.AddPositionX(int x);
Y座標を加算します
*gameObject.AddPositionY(int y);
Z座標を加算します
*gameObject.AddPositionZ(int z);
座標を0にリセットします
*gameObject.ResetPosition();
*Transform tr = transform.GetTopParent();*//深い階層まで子オブジェクトを名前で検索します
最上層の親オブジェクトを返します。親オブジェクトが存在しない場合自身を返す。
*tr = transform.GetTopParent(string name,bool includeInactive = false);*//全ての子オブジェクトを返します
深い階層まで子オブジェクトを名前で検索します
*Transform[] trs=transform.GetChildren(bool includeInactive = false);*//X座標を設定します
全ての子オブジェクトを返します
*transform.SetPositionX(float x);*//Y座標を設定します
X座標を設定します
*transform.SetPositionY(float y);*//Z座標を設定します
Y座標を設定します
*transform.SetPositionZ(float z);*//X座標を加算します
Z座標を設定します
*transform.AddPositionX(int x);*//Y座標を加算します
X座標を加算します
*transform.AddPositionY(int y);*//Z座標を加算します
Y座標を加算します
*transform.AddPositionZ(int z);*//座標を0にリセットします
Z座標を加算します
*transform.ResetPosition();*}
座標を0にリセットします
レンダラーテクスチャからテクスチャ2Dを生成する(かなり重たい処理なので使用には注意)
*Texture2D tex2D=rt.CreateTexture2D(Camera camera);
Texture2DからSpriteを作成
*Sprite sprite=tex2D.CreateSprite();
指定した文字列が含まれているオブジェクトを取得
*GameObject[] game=GameObjectUtils.FindContainsName(string name);
配列の中の要素をランダムで返す
*T t=RandomUtils .RandomArray<;T>;(T[] array);;
listの中の要素をランダムで返す
*T t=RandomUtils .RandomList<;T>;(List<;T>; list);
ランダムでtrueかfalseを返す
*bool flag=RandomUtils .BoolValue();
ログを出力
*DebugUtils.Log(string message);
色を変更してログを出力
*DebugUtils.Log(string message, Color color);
サイズと色を変えてログを出力
*DebugUtils.Log(string message, float size,Color color);
エラーログを出力します
*DebugUtils.LogError(string message);
警告ログを出力します
*DebugUtils.LogWarning(string message);
配列のログを出します
*DebugUtils.ArrayLog(T[] array);
仮の保存用データ
*[Serializable]
セーブ
*SaveLoadSystem.Save(date,string fileName,string folderName=SaveFolder);
ロード
*date=(Date)SaveLoadSystem.Load(string fileName,string folderName=SaveFolder);
暗号化セーブ
*SaveLoadSystem.EncryptionSave(date,string fileName,string folderName=SaveFolder);
暗号化ロード
*date=(Date)SaveLoadSystem.EncryptionLoad(string fileName,string folderName=SaveFolder);
パスワードなどを設定、しなければ初期値でセーブします。
*SaveLoadSystem._password = "password";

*if (!DateTime.TryParse(inputText2, out DateTime _))
CS8183:「暗黙的に型指定された破棄の型を推論できません」対策として型を指定（ここでは、out の次の DateTime）

ReactivePropertyとして参照したい箇所ではこれを参照
*public IReadOnlyReactiveProperty<;int>; SomeIntReactiveProperty =>; someIntPropertyEntity;

*private void method(ref x){//処理}
定義側
処理
*}
呼出し側
*y = method(ref x)

ログプロバイダをクリア
*builder.ClearProviders();
コンソールログを追加
*builder.AddConsole();
デバッグログを追加
*builder.AddDebug();
イベントログを追加
*builder.AddEventLog();
イベントソースを追加
*builder.AddEventSourceLogger();
独自のログプロバイダを追加
*builder.AddProvider(new SampleLoggerProvider());
*{return true;}
指定されたログレベルが出力対象かどうかを取得します。
*void ILogger.Log<;TState>;(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<;TState, Exception, string>; formatter)*{
指定されたログを出力します。
*{Console.WriteLine(new string('\t', m_ScopeLevel) + message));}
指定されたログを出力します。
スコープのレベル
スレッドセーフは考慮していません
*private int m_ScopeLevel = 0;
*{WriteLogLine($"Begin {state}");++m_ScopeLevel;return new Scope<;TState>;(state, () =>;{// スコープが終了されたときの処理if (m_ScopeLevel >; 0) { --m_ScopeLevel; }WriteLogLine("End");});}
スコープが開始されたときの処理を行います。
*if (m_ScopeLevel >; 0) { --m_ScopeLevel; }*WriteLogLine("End");
スコープが終了されたときの処理
BeginScope の戻り値として返すオブジェクト。
dispose されたときにスコープの終了処理を行います。
*private struct Scope<;TState>; : IDisposable
ログレベルを設定
*builder.SetMinimumLevel(LogLevel.Debug);
カテゴリに対してフィルタを設定
*builder.AddFilter("System", LogLevel.Warning);
*{if (provider.EndsWith("ConsoleLoggerProvider")){if (category.StartsWith("Microsoft")){return (level.CompareTo(LogLevel.Warning) >;= 0);}}return true;});
フィルタメソッドで設定（Func&lt;string, string, LogLevel, bool&gt;）
*{// イベントソースが生成されたときの処理を行います。protected override void OnEventSourceCreated(EventSource eventSource){// EventSourceLogger は "Microsoft-Extensions-Logging" という名前のイベントソースにログを出力します。if (eventSource.Name == "Microsoft-Extensions-Logging"){// この例では FormattedMessage イベントのすべてのログを有効にしています。EnableEvents(eventSource, EventLevel.Verbose, LoggingEventSource.Keywords.FormattedMessage);}}// ログが書き込まれたときの処理を行います。protected override void OnEventWritten(EventWrittenEventArgs eventData){// この例ではイベントデータの内容をコンソールに出力しています。Console.WriteLine($"EventId = {e.EventId}");Console.WriteLine($"EventName = {e.EventName}");Console.WriteLine($"Keywords = {e.Keywords}");Console.WriteLine($"Level = {e.Level}");Console.WriteLine($"Message = {e.Message}");if (e.PayloadNames != null){for (int i = 0; i <; e.PayloadNames.Count; ++i){Console.WriteLine($"Payload[{e.PayloadNames[i]}] = {e.Payload[i]}");}}}}
Microsoft.Extensions.Logging.EventSourceLogger から出力されるログを取得するリスナー
*{// EventSourceLogger は "Microsoft-Extensions-Logging" という名前のイベントソースにログを出力します。if (eventSource.Name == "Microsoft-Extensions-Logging"){// この例では FormattedMessage イベントのすべてのログを有効にしています。EnableEvents(eventSource, EventLevel.Verbose, LoggingEventSource.Keywords.FormattedMessage);}}
イベントソースが生成されたときの処理を行います。
*if (eventSource.Name == "Microsoft-Extensions-Logging")*{
EventSourceLogger は "Microsoft-Extensions-Logging" という名前のイベントソースにログを出力します。
この例では FormattedMessage イベントのすべてのログを有効にしています。
*EnableEvents(eventSource, EventLevel.Verbose, LoggingEventSource.Keywords.FormattedMessage);
*{// この例ではイベントデータの内容をコンソールに出力しています。Console.WriteLine($"EventId = {e.EventId}");Console.WriteLine($"EventName = {e.EventName}");Console.WriteLine($"Keywords = {e.Keywords}");Console.WriteLine($"Level = {e.Level}");Console.WriteLine($"Message = {e.Message}");if (e.PayloadNames != null){for (int i = 0; i <; e.PayloadNames.Count; ++i){Console.WriteLine($"Payload[{e.PayloadNames[i]}] = {e.Payload[i]}");}}}
ログが書き込まれたときの処理を行います。
*Console.WriteLine($"EventId = {e.EventId}");
この例ではイベントデータの内容をコンソールに出力しています。
*{// イベントハンドラを使ってイベントソースが生成されたときの処理とログが書き込まれたときの処理を行うことも可能です。listener.EventSourceCreated += listener_EventSourceCreated;listener.EventWritten += listener_EventWritten;// アプリケーションの処理を実行// この中でイベントソースに対して出力されたログがリスナーによって取得されますawait CreateHostBuilder(args).RunConsoleAsync();}
リスナーを生成
イベントハンドラを使ってイベントソースが生成されたときの処理とログが書き込まれたときの処理を行うことも可能です。
*listener.EventSourceCreated += listener_EventSourceCreated;
アプリケーションの処理を実行
この中でイベントソースに対して出力されたログがリスナーによって取得されます
*await CreateHostBuilder(args).RunConsoleAsync();
*{// 割愛}
イベントソースが生成されたときの処理を行います。
割愛
*}
*{// 割愛}
ログが書き込まれたときの処理を行います。
割愛
*}

*_httpClient.PostAsync("https:
api.line.mev2botmessagereply", stringContent).Wait();

*using System;
Actionに必要
*StartCoroutine(DelayMethod(1, () =>; {Pause(); }));
1フレーム後にPauseする

arrayの要素数を表示
*Console.WriteLine(array.Length);
*for (int i = 0;i <;array.Length;i++)*{
要素数の数だけ繰り返す
*foreach (string a in array)*{
foreachで要素数の数だけ繰り返す

Program2のインスタンスを生成
*Program2 obj = new Program2();
Program2クラスのstarメソッドを実行
*obj.star();
*for (int i=1;i<;=5;i++)*{
五回繰り返す
*for (int j = 5; j >;= i; j--)*{
変数jが変数iの数以下になるまで繰り返す
*if (i == 3)*{
変数iが3の時はfor文を抜ける(Console.Write("☆")は実行されない)
*if (i == 3)*{
変数iのが3の時はcontinue以下の処理は実行しない

*{base.OnConfiguring(optionsBuilder);optionsBuilder.UseMySQL("MySQL接続文字列");}
一部省略
接続文字列記載のデータベースを削除
*this.sampleEntities.Database.EnsureDeleted();
接続文字列記載のデータベースを作成
*this.sampleEntities.Database.EnsureCreated();
エリアと店舗情報で1:nの関係を作成
*modelBuilder.Entity<;MShop>;()
店舗情報と売上高（日別）で1:nの関係を作成
*modelBuilder.Entity<;TDailySales>;()
店舗情報と売上高（月別）で1:nの関係を作成
*modelBuilder.Entity<;TMonthlySales>;()
長くなるため一部プロパティは省略
*[Column("AREA_ID")]
長くなるため一部プロパティは省略
*[Column("SHOP_ID")]
長くなるため一部プロパティは省略
*[Column("SHOP_ID")]
*public MArea Area { get; set; }
このプロパティが「navigation property」
*public int AreaId { get; set; }
「Area」が「navigation property name」、「Id」が「principal key property name」
*public MArea Area { get; set; }
このプロパティが「navigation property」
*public int AreaId { get; set; }
「Area」が「navigation property name」になり、その後ろに「Id」をつける。
*public int MAreaId { get; set; }
「MArea」が「principal entity name」、「Id」が「principal key property name」
*public int MAreaId { get; set; }
「MArea」が「principal entity name」になり、その後ろに「Id」をつける。
エリア、店舗、売上情報取得
*MArea area = sampleEntities.Areas
*MArea area1 = new MArea { AreaName = "北海道" };
エリア作成
*MShop shopHokkaido = new MShop { Area = area1, Address = "北海道xxxxxxxxxx", ShopName = "北海道店舗" };
エリアに店舗情報追加
*shopHokkaido.SalesDailies.Add(new TDailySales { Shop = shopHokkaido, /*紐づけに必要な情報以外は省略*/ });
店舗に売上情報追加：北海道
登録内容の追加
*sampleEntities.Areas.Add(area1);
登録内容の保存
*sampleEntities.SaveChanges();
エリア情報取得
子要素を取得しなくても、リレーションデータの削除されることを確認。
*MArea area = sampleEntities.Areas.FirstOrDefault();
DbSet経由の削除
*sampleEntities.Remove(area);
削除内容の保存
*sampleEntities.SaveChanges()

*driver.Navigate().GoToUrl("https:
www.google.com");

前略
*IEnumerable<;string>; s;
*//{//    // somthing...//}
if (s.Count() &gt; 0)

*min = randamValues[i] <; min ? randamValues[i] : min;
←ここの書き方で差は出るの？

*_context.Remove(d);
先頭を削除する

*Main.spawnTileY = (int)Main.worldSurface - 100 - 3;
多分-3じゃなくて-2程度がいいかも
なんかの処理
base.Close();  必須
*}

今日の日付
*public static DateTime? collectStartDate = DateTime.Today;
*{InitializeComponent();//VMクラスをxaml側に反映させるDataContext = myVM;}
コンストラクタ
VMクラスをxaml側に反映させる
*DataContext = myVM;
*public class MainVM : INotifyPropertyChanged*{
VMクラスを定義
日付
*private DateTime? _dayTime;
*{var e = new PropertyChangedEventArgs(PropertyName);PropertyChanged?.Invoke(this, e);}
変更通知
INotifyPropertyChangedに定義されているイベント
*public event PropertyChangedEventHandler PropertyChanged;

*By.XPath("
ol[@id='b_results']lih2a[contains(text(), 'Microsoft Azure')]")));
ページのタイトルに「Azure Pipelines」が含まれていたらテスト成功

*Assert.IsTrue(driver.Title.Contains("Azure Pipelines"), "Verified title of the page");

略
services.AddScoped&lt;IStateMessageService, StateMessageService&gt;();  追記
略
*}

*uint uiCommand,
RIDI_PREPARSEDDATA

*context.Result = new UnauthorizedResult();
未認証なら401を返す

*using UnityEngine.SceneManagement;
シーン移動するために必要
*{//[SerializeField]を使うことでpraivateの状態で//publicと同じようにunityのInspectorで入力できる[SerializeField] string loadsceneName = "";public void LoadSceneButtonDown(){//Inspectorで入力された名前が(loadsceneName)に入り//そのシーンをロードするSceneManager.LoadScene(loadsceneName);}}
using UnityEngine.UI;              UIを使う際に必要
[SerializeField]を使うことでpraivateの状態で
publicと同じようにunityのInspectorで入力できる
*[SerializeField] string loadsceneName = "";
Inspectorで入力された名前が(loadsceneName)に入り
そのシーンをロードする
*SceneManager.LoadScene(loadsceneName);

*public Dictionary<;string, Fish<; FishDict = new Dictionary<;string,Fish<;();
銛で突いた魚の名前と数を保存
シリアライズ、デシリアライズ時のコールバック
================================================
*public void OnBeforeSerialize()
Dictionaryはそのまま保存されないので、個別にシリアライズしてテキストで保存
*_fishDictJson = Serialize(FishDict);
*if (!string.IsNullOrEmpty(_fishDictJson))*{
保存されているテキストがあればDictionaryにデシリアライズ
取得
================================================
*public void Reload()
*if (!string.IsNullOrEmpty(_jsonText))*{
既にJsonを取得している場合はそれを返す。
Jsonを保存している場所のパスを取得
*string filePath = GetSaveFilePath();
*if (File.Exists(filePath))*{
Jsonが存在するか調べてから取得し変換する。存在しなければ新たなクラスを作成し、それをJsonに変換する。
保存
================================================
*public void Save()
削除
================================================
*public void Delete()
保存先のパス
================================================
*private static string GetSaveFilePath()
確認しやすいようにエディタではAssetsと同じ階層に保存
それ以外ではApplication.persistentDataPath以下に保存するように。
*#if UNITY_EDITOR
*{//保存しておいたデータを取得する//static変数を取得PlayerDataInstance _pInstance = PlayerDataInstance.Instance;dataList                      = gameObject.GetComponent<;DataList>;();//各データを保存していたファイルから取得string lanceName = _pInstance.GetLanceName();//初期状態だとlanceNameが""なので、初期装備を設定//lanceNameが存在するなら該当する装備を取得if (lanceName == ""){lance          = dataList.GetLance("ボロのモリ");lance.IsBought = true;}else{lance = dataList.GetLance(lanceName);}money  = _pInstance.GetMoney();fishes = _pInstance.GetFish();}
（中略）
保存しておいたデータを取得する
static変数を取得
*PlayerDataInstance _pInstance = PlayerDataInstance.Instance;
各データを保存していたファイルから取得
*string lanceName = _pInstance.GetLanceName();
初期状態だとlanceNameが""なので、初期装備を設定
lanceNameが存在するなら該当する装備を取得
*if (lanceName == "")
以下省略
*}

*if (collision.gameObject.CompareTag("gravity"))
オブジェクトにgravityタグ

*foreach (var block in block_list)*{
ブロックリストの中のブロックにスコープを当てる
文字列を16進数に変換. 実体はbyte配列
*var a = Encoding.ASCII.GetBytes(plain_text);
*uint[] result = { };
結果を格納する配列
16進数を2進数に変換
*var j = int.Parse(Convert.ToString(n, 2));
*if(len <; 8)*{
2進数を8桁に揃える  0を先頭に追加
2進数が8桁以下であったとき、埋めるべき数は |8 - len| である
*fill_len = Math.Abs(8 - len);
*uint[] buf = { };
処理する値を保持するバッファ
64桁右寄せゼロ埋め
0000000000000000000000000000000000000000000000000000000000011000
*bytStr = bytStr.ToString().PadLeft(64, '0');
*uint[] bytStr_array = { };
↑で得た64桁の数列を配列に変換
*uint[] bytStr_array = { };
(64)[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0 ]
*foreach(var b in bytStr_array)*{
位取り バッファにAppend
ブロックサイズはパディング後512である
Assert(buf.Length != 512)
PrintArray(buf); 512
*#endif
ブロックリストに追加
*result.Add(block);
例
バイナリ -&gt; ヘックスデシマル -&gt; uint OR バイナリ -&gt; demical
↓チャンクバイナリ 01100001011000100110001110000000 は ヘックスデミカル 0x61626380 である.
CHUNK: [ 32 ] [0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]
= 0x61626380 したがって uint は 1633837952
コピー先のチャンク配列
*uint[] chunk_array = new uint[32];
ブロックの x*32 から 32byte先までをコピー
*Array.Copy(block, x*32, chunk_array, 0, 32);
バイナリに変換
*var chunk_binary_str = ToBinary(chunk_array);
*int[] hoge = { 0, 1, 2, 3, 4 };
こんな配列が
こうすると
*Console.WriteLine(hoge);
こうなるから
Output: System.Int32
自作関数でラップすると
*PrintArray(hoge);
いい感じに出力される
Output: [ 0, 1, 2, 3, 4 ]
*,,,
int文字列から特定の位置にある数字を取り出す
12345
↑indexN
return 2
*private int StrMid(int source, int indexN)
ブロックが複数ある場合も想定されるので、
n*512から512先までをコピーしなければいけない。
*Array.Copy(plain_bits, n * BLOCK_SIZE, block, 0, BLOCK_SIZE);
*{var n = s.Select((v) =>; $"{v:X2}");return string.Join("", n).ToLower();}
これも不具合発生.

解析するやつ
*}

*<;a href="https:
docs.microsoft.comen-usaspnet" target="_blank"&gt;About&lt;a&gt;

*var claims = new[] {new Claim(ClaimTypes.Name, loginParam.Username)};
JWT内に入れるクレームです。
ここでトークンを生成しています。
*var token = handler.CreateJwtSecurityToken(
省略
JwtBearerOptionsの設定は別クラスでやる
*services
実際は、データベースを見たりする。
*return true;

各テキストボックスの値を取得
*string text1 = textBox1.Text;
日付を取得
*DateTime Today = dateTimePicker1.Value;
ダイアログの説明文を指定する
*fbDialog.Description = "週報保存先フォルダを選択";
デフォルトのフォルダを指定する
*fbDialog.SelectedPath = @"C:";
「新しいフォルダーの作成する」ボタンを表示する
*fbDialog.ShowNewFolderButton = true;
*if (fbDialog.ShowDialog() == DialogResult.OK)*{
フォルダを選択するダイアログを表示する
ファイル名決定
*string filename = filepath +
タイトル作成
*StringBuilder sb = new StringBuilder();
今週の報告
*sb.Append("■今週の報告\n");
全てのテキストボックスの値をクリアする
*textBox1.ResetText();

*s.Prefixes.Add("http:
IPアドレス:ポート番号");

*if (Input.GetKeyDown(KeyCode.LeftArrow) &amp;&amp; x_MoveCount >; -1)*{
左
*saveThisObjPosition = this.gameObject.transform.position;*thisObjPosition.x -= 1;
位置を保存
*this.gameObject.transform.position = thisObjPosition;*x_MoveCount -= 1;
位置を変更
*if (Input.GetKeyDown(KeyCode.RightArrow) &amp;&amp; x_MoveCount <; 1)*{
右
*if (Input.GetKeyDown(KeyCode.UpArrow) &amp;&amp; z_MoveCount <; 1)*{
上
*if (Input.GetKeyDown(KeyCode.DownArrow) &amp;&amp; z_MoveCount >; -1)*{
下
*if (other.gameObject.tag == "cube")*{
衝突してほしいゲームオブジェクトでなければ抜ける
接触したときにパズルの位置が入れ替わる
*Debug.Log("hit");

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"
Source追加
*Title="MainWindow" Height="300" Width="400" Source="Page1.xaml">;
Gridタグを消去
*,,,
*public partial class MainWindow : NavigationWindow {public MainWindow() {InitializeComponent();}}
NavigationWindowに変更
追加:Loaded
*Title="Page1" Loaded="Page1_Loaded">;
追加
*<;Grid>;
*public partial class Page1 : Page {private NavigationService _navigation;public Page1() {InitializeComponent();}private void Btn_Click(object sender, RoutedEventArgs e) {Application.Current.Properties["Name"] = _name.Text;var _page2 = new Page2();_navigation.Navigate(_page2);}private void Page1_Loaded(object sender, RoutedEventArgs e) {_navigation = this.NavigationService;}}
追加
追加
*<;Grid>;
*public partial class Page2 : Page {public Page2() {InitializeComponent();_named.Content = Application.Current.Properties["Name"];}}
変更

前処理
*button1.Enabled = false;
実行
*RunCommandLineAsync();
*{sw.Write(this.textBox5.Text.Trim());}
標準入力への書き込み
非同期で出力とエラーの読み取りを開始
*p.BeginOutputReadLine();
吐き出されずに残っているデータの吐き出し
*this.Invoke((MethodInvoker)(() =>; AppendText(outStringBuilder.ToString(), false)));
完了メッセージ
*this.Invoke((MethodInvoker)(() =>; MessageBox.Show("処理をキャンセルしました")));
完了メッセージ
*this.Invoke((MethodInvoker)(() =>; MessageBox.Show("処理が完了しました")));
完了メッセージ
*this.Invoke((MethodInvoker)(() =>; MessageBox.Show("エラーが発生しました")));
*if (readCount % 5 == 0)*{
まとまったタイミングで吐き出し
*if (readCount % 1000 == 0)*{
スレッドを占有しないようスリープを入れる
標準入力エリアのクリア
*this.textBox5.Clear();
標準出力エリアのクリア
*this.textBox1.Clear();

使うusingのみでOKです。
*using System;

*driver.Navigate().GoToUrl("http:
localhoststest.html");

*{// コンフィグを登録services.Configure<;SampleOption>;(context.Configuration);// JSONパーサーによってバインドできない内容の場合は独自の後処理を実装します。services.Configure<;SampleOption>;((SampleOption option) =>;{// 独自の後処理option.Database.ConnectionString = ModifyConnectionString(option);});// 次のどちらかの方法でサービスを登録// 既定のバインディング// コンフィグのインスタンスは SampleService クラスのコンストラクタを通じて受け取ります。services.AddSingleton<;IService, SampleService>;();// 既定のバインディングに加えて独自の処理を組み込む必要がある場合、// IServiceProvider.GetRequiredService メソッドでインスタンスを取得できます。// 次のコードはコンフィグインスタンスの注入しか行っていませんので、結果的に上と同じ内容になります。services.AddSingleton<;IService, SampleService>;((IServiceProvider provider) =>;{var option = provider.GetRequiredService<;IOptions<;SampleOption>;>;();return new SampleService(option);});});
サービスの構成
コンフィグを登録
*services.Configure<;SampleOption>;(context.Configuration);
*{// 独自の後処理option.Database.ConnectionString = ModifyConnectionString(option);});
JSONパーサーによってバインドできない内容の場合は独自の後処理を実装します。
*option.Database.ConnectionString = ModifyConnectionString(option);*});
独自の後処理
次のどちらかの方法でサービスを登録
既定のバインディング
コンフィグのインスタンスは SampleService クラスのコンストラクタを通じて受け取ります。
*services.AddSingleton<;IService, SampleService>;();
既定のバインディングに加えて独自の処理を組み込む必要がある場合、
IServiceProvider.GetRequiredService メソッドでインスタンスを取得できます。
次のコードはコンフィグインスタンスの注入しか行っていませんので、結果的に上と同じ内容になります。
*services.AddSingleton<;IService, SampleService>;((IServiceProvider provider) =>;
*{}
サービスの定義に従って IServiceCollection に登録されたコンフィグのインスタンスが注入されます。
*{// 実行フォルダの MyAppSettings.json を構成に追加します。// ファイルが存在しない可能性がある場合は optional に true を指定します。builder.AddJsonFile($"MyAppSettings.json", optional: true, reloadOnChange: true);builder.AddJsonFile($"MyAppSettings.{context.HostingEnvironment.EnvironmentName}.json", optional: true, reloadOnChange: true);})
コンフィグの構成
実行フォルダの MyAppSettings.json を構成に追加します。
ファイルが存在しない可能性がある場合は optional に true を指定します。
*builder.AddJsonFile($"MyAppSettings.json"
*{// コンフィグを登録services.Configure<;SampleOption>;(context.Configuration);// サービスを登録services.AddSingleton<;IService, SampleService>;();});
サービスの構成（前述している内容と同じですので割愛しています）
コンフィグを登録
*services.Configure<;SampleOption>;(context.Configuration);
サービスを登録
*services.AddSingleton<;IService, SampleService>;();
*{// 指定したプレフィクス（この例では "SAMPLEAPP_"）で始まる環境変数を構成に追加します。// プレフィクスが除かれたキーで読み込まれます。builder.AddEnvironmentVariables(prefix: "SAMPLEAPP_");})
コンフィグの構成
指定したプレフィクス（この例では "SAMPLEAPP_"）で始まる環境変数を構成に追加します。
プレフィクスが除かれたキーで読み込まれます。
*builder.AddEnvironmentVariables(prefix: "SAMPLEAPP_");
*{// コンフィグを登録services.Configure<;SampleOption>;(context.Configuration);// サービスを登録services.AddSingleton<;IService, SampleService>;();});
サービスの構成（前述している内容と同じですので割愛しています）
コンフィグを登録
*services.Configure<;SampleOption>;(context.Configuration);
サービスを登録
*services.AddSingleton<;IService, SampleService>;();
*{// 追加の構成ファイルbuilder.AddJsonFile($"MyAppSettings.json", optional: true);// 追加の環境変数builder.AddEnvironmentVariables(prefix: "SAMPLEAPP_");// 最後にコマンドライン引数を読み込んで上書きbuilder.AddCommandLine(args);})
コンフィグの構成
追加の構成ファイル
*builder.AddJsonFile($"MyAppSettings.json", optional: true);
追加の環境変数
*builder.AddEnvironmentVariables(prefix: "SAMPLEAPP_");
最後にコマンドライン引数を読み込んで上書き
*builder.AddCommandLine(args);
*{// コンフィグを登録services.Configure<;SampleOption>;(context.Configuration);// サービスを登録services.AddSingleton<;IService, SampleService>;();});
サービスの構成（前述している内容と同じですので割愛しています）
コンフィグを登録
*services.Configure<;SampleOption>;(context.Configuration);
サービスを登録
*services.AddSingleton<;IService, SampleService>;();

*num
= 2; この部分を変更

変換表
*static readonly string map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
エンコード後の長さを計算し、余る長さを求める
*var encodedLength = source.Length * 8 / 6;
*while (n <; source.Length)*{
変換の本体

using System.Linq;が必要
*private IEnumerable<;Toggle>; GetTogglesOf(ToggleGroup toggleGroup)

*{}
Start is called before the first frame update
*{var calendarTrigger = new iOSNotificationCalendarTrigger(){Year = 2020,Month = 1,Day = 1,Hour = 20,Minute = 20,Repeats = false};var notification = new iOSNotification(){// You can optionally specify a custom identifier which can later be// used to cancel the notification, if you don't set one, a unique// string will be generated automatically.Identifier = "_notification_01",Title = "Title",Body = "Scheduled at: 2020年1月1日20時20分",Subtitle = "This is a subtitle, something, something important...",ShowInForeground = true,ForegroundPresentationOption = (PresentationOption.Alert | PresentationOption.Sound),CategoryIdentifier = "category_a",ThreadIdentifier = "thread1",Trigger = calendarTrigger,};iOSNotificationCenter.ScheduleNotification(notification);}
ボタンが押された際に呼び出される関数
*// used to cancel the notification, if you don't set one, a unique*// string will be generated automatically.
You can optionally specify a custom identifier which can later be
*Identifier = "_notification_01",*Title = "Title",
string will be generated automatically.

クラスをインスタンス化し、クラスの変数(あれ、ポインタじゃない？)に格納
*ClassA classA = new ClassA();
int型のmember_aをUnityのコンソールへ出力
*Debug.Log(classA.member_a);
インスタンスを削除
*classA = null;

*string dirPath = Application.dataPath + $"
EditorLocalisations{lang}.lproj";  project内に設置したパスを指定
似たような関数があるので注意　project.GetUnityFrameworkTargetGuidではない
*string targetGuid = project.GetUnityMainTargetGuid();

*blockObj.transform.parent = parentBlockObj.transform;
生成したブロックの親が誰かを教える

Name[1-5]プロパティに動的にアクセスし、値を設定
*var nameProperty = typeof(Document).GetProperty("Name" + index.ToString());
Age[1-5]プロパティに動的にアクセスし、値を設定
*var ageProperty = typeof(Document).GetProperty("Age" + index.ToString());

MEMO : 角のPointコレクションと面積をペアで返します。
*return new Tuple<;Point[], double>;(outputMat.ToArray(), Cv2.ContourArea(c.ToArray()));
MEMO : 面積で区切ってゴミを除去してます。
*.Where(c =>; c.Item2 <; myMaxArea &amp;&amp; c.Item2 >; myMinArea);
MEMO : 角のPointコレクションと面積をペアで返します。
*return new Tuple<;Point2f[], double>;(corners, Cv2.ContourArea(c.ToArray()));
MEMO : 面積で区切ってゴミを除去してます。
*.Where(c =>; c.Item2 <; myMaxArea &amp;&amp; c.Item2 >; myMinArea);

クエリー送信先、トランザクションの指定
*sqlCom.Connection = this.sqlConnection;
SQLを実行
*sqlCom.ExecuteNonQuery();

*receiveBuffer.Length);
data buffer

クリックした位置を保存
位置の基準にするControlはなんでもいいが、MouseMoveのほうの基準Controlと合わせること。
*MouseDonwStartPoint = e.GetPosition(MyScrollViewer);
マウスの現在位置座標を取得（ScrollViewerからの相対位置）
ここは、位置の基準にするControl(GetPositionの引数)はScrollViewrでもthis(Window自体)でもなんでもいい。
Start時とマウス移動時の差分がわかりさえすればよし。
*MouseCurrentPoint = e.GetPosition(MyScrollViewer);
移動開始点と現在位置の差から、MouseMoveイベント1回分の移動量を算出
*double offsetX = MouseCurrentPoint.X - MouseDonwStartPoint.X;
動かす対象の図形からMatrixオブジェクトを取得
このMatrixオブジェクトを用いて図形を描画上移動させる
*Matrix matrix = ((MatrixTransform)MyTarget.RenderTransform).Matrix;
TranslateメソッドにX方向とY方向の移動量を渡し、移動後の状態を計算
*matrix.Translate(offsetX, offsetY);
*MyTarget.RenderTransform = new MatrixTransform(matrix);*// 移動開始点を現在位置で更新する
移動後の状態を計算したMatrixオブジェクトを描画に反映する
移動開始点を現在位置で更新する
（今回の現在位置が次回のMouseMoveイベントハンドラで使われる移動開始点となる）
*MouseDonwStartPoint = MouseCurrentPoint;
ScaleAt()の拡大中心点(引数3,4個目)に渡すための座標をとるときの基準Controlは、拡大縮小をしたいものの一つ上のControlにすること。
ここでは拡大縮小するGridを包んでいるScrollViewerを基準にした。
*MouseCurrentPoint = e.GetPosition(MyScrollViewer);
*if (e.Delta >; 0) scale = 1.25;*else scale = 1 / 1.25;
ホイール上に回す→拡大 / 下に回す→縮小
拡大実施
*matrix.ScaleAt(scale, scale, MouseCurrentPoint.X, MouseCurrentPoint.Y);

*req.Headers.TryGetValue("X-Shopify-Topic", out var topic);*req.Headers.TryGetValue("X-Shopify-Hmac-Sha256", out var hMacSha256);
Read all
*log.LogInformation("Topic was: " + topic );*}
do something if it's not the tipc you are looking for
*log.LogInformation("Domain was: " + domain);*}
do something if it's not the domain you are looking for

*this.DataContext = this;
Windowのクラス自身をDataContextにする

*{// --------------------------------------------------------------------public static string file_to_str_proc (string file_in){StreamReader fp_in = new StreamReader (file_in);string  buff;StringBuilder stb = new StringBuilder ();while ((buff = fp_in.ReadLine ()) != null){stb.Append (buff);}fp_in.Close();string  str_in = stb.ToString ();return  str_in;}}
--------------------------------------------------------------------
*{StreamReader fp_in = new StreamReader (file_in);string  buff;StringBuilder stb = new StringBuilder ();while ((buff = fp_in.ReadLine ()) != null){stb.Append (buff);}fp_in.Close();string  str_in = stb.ToString ();return  str_in;}
--------------------------------------------------------------------

NameSpaceTest名前空間内にある
*}

*using Microsoft.VisualStudio.TestTools.UnitTesting;
https:github.commicrosofttestfx
*{new KanriitakuKeiyaku(){keiyakukinAmount = 100,shohizeiRitsu = 8,// .// .// .// いろいろたくさん},108},
テストケース1
いろいろたくさん
*},
*{new KanriitakuKeiyaku(){keiyakukinAmount = 100,shohizeiRitsu = 10,// .// .// .// いろいろたくさん},110}
テストケース2
いろいろたくさん
*},

*{try{StreamWriter fp_out = new StreamWriter (file_name);fp_out.Write (str_out);fp_out.Close ();}catch{Console.Error.WriteLine ("*** error *** file_write_proc ***");}}
---------------------------------------------------------------------------
*{Console.Error.WriteLine("*** 開始 ***");Dictionary <;string,Object>; dict_aa= new Dictionary <;string,Object>; ();dict_aa = dict_append_proc (dict_aa,"t2381","名古屋",74125,"2009-1-7");dict_aa = dict_append_proc (dict_aa,"t0922","小山",17982,"2009-5-19");dict_aa = dict_append_proc (dict_aa,"t0923","佐野",46819,"2009-3-28");dict_aa = dict_append_proc (dict_aa,"t0924","足利",65297,"2009-12-21");dict_aa = dict_append_proc (dict_aa,"t0925","日光",14926,"2009-11-25");dict_aa = dict_append_proc (dict_aa,"t0926","下野",28145,"2009-1-26");dict_aa = dict_append_proc (dict_aa,"t0927","さくら",56784,"2009-1-21");string file_out = "/var/tmp/json/tochigi.json";file_write_proc (file_out,str_json);Console.Error.WriteLine("*** 終了 ***");}
---------------------------------------------------------------------------

*matrix.ScaleAt(scaleDelta, scaleDelta, orgX, orgY);
中心を指定して対象を拡大

アプリケーション設定のいろいろ
*var diContainer = new Container();
アプリケーション設定のいろいろ
*var diContainer = new Container();

必要なものを定義
*MemoryMappedFile share_mem = null;
共有メモリ名
*const string sharedMemoryName = "MySharedMemory";
使用する構造体
*public struct _MY_DATA_STRUCT
コンストラクタ
*public Form1()
「共有メモリを読む」ボタンをクリックしたときに発生するイベント
*private void btnRead_Click(object sender, EventArgs e)
「共有メモリに書き込み」ボタンをクリックしたときに発生するイベント
*private void btnWrite_Click(object sender, EventArgs e)
共有メモリを構造体として読み取るジェネリック関数
*private T ReadSharedMemoryAsStruct<;T>;(string sharedMemoryName, bool createOrOpen = false)
構造体を定義
*T result = new T();
共有メモリに構造体として書き込むジェネリック関数
*private bool WriteSharedMemoryAsStruct<;T>;(string sharedMemoryName, T targetStruct, bool createOrOpen = false)
リソースの破棄
*private void Form1_FormClosing(object sender, FormClosingEventArgs e)

*driver.FindElement(By.XPath("
ol[@id='b_results']lih2a[contains(text(), 'Microsoft Azure')]")).Click();

*if (!blobContainer.Exists())*{
If container does not exist
*{PublicAccess = BlobContainerPublicAccessType.Blob};
Set the permissions so the blobs are public.
*blockBlob.Properties.ContentType = formFile.ContentType;*// upload to blob
Set the object's content type
*blockBlob.UploadFromStream(formFile.OpenReadStream());*// get file uri
upload to blob

*{return creature.GetName().Length;}
名前をカウントする
*{foreach (var creature in creatures){creature.SpecialAttack();}}
全員スペシャルアタック！

１多重で実行したい処理
*}
１多重で実行したい処理
*}
１多重で実行したい処理
*}
取得完了まで待受
*waitEndEvent.Wait();
Mutex取得開始
*waitResult = instance.WaitOne();
Mutexの開放まで待機
*releaseEvent.Wait();
Mutex開放
*instance.ReleaseMutex();
取得完了まで待受
*waitEndEvent.Wait();
Mutex取得開始
*waitResult = instance.WaitOne();
Mutexの開放まで待機
*releaseEvent.Wait();
Mutex開放
*instance.ReleaseMutex();

印刷
*System.Drawing.Printing.PrintDocument pd = new System.Drawing.Printing.PrintDocument();
画像を読み込む
*Image img = Image.FromFile("outQR.png");
画像を描画する
*e.Graphics.DrawImage(img, e.MarginBounds);
次のページがないことを通知する
*e.HasMorePages = false;
後始末をする
*img.Dispose();
印刷
*printingText = @"QRの内容: " + args[0];
画像を読み込む
*Image img = Image.FromFile(QRfilename);
画像を描画する
e.Graphics.DrawImage(img, e.MarginBounds);  幅全体に描画する場合。
20, 10 の位置に表示
e.Graphics.DrawImage(img, 20, 10, img.Width, img.Height);  サイズ指定する場合
文字
*e.Graphics.DrawString(printingText, printFont, Brushes.Black, 0, 0);
次のページがないことを通知する
*e.HasMorePages = false;
後始末をする
*img.Dispose();
印刷
*printingText = @"QRの内容: " + args[0];
プリンターを指定して印刷
*string PrinterName;
画像を読み込む
*Image img = Image.FromFile(QRfilename);
画像を描画する
e.Graphics.DrawImage(img, e.MarginBounds);  幅全体に描画する場合。
20, 10 の位置に表示
e.Graphics.DrawImage(img, 20, 10, img.Width, img.Height);  サイズ指定する場合
文字
*e.Graphics.DrawString(printingText, printFont, Brushes.Black, 0, 0);
次のページがないことを通知する
*e.HasMorePages = false;
後始末をする
*img.Dispose();

一旦、固有の権限を削除してから、権限の継承を外す
その際に、実行ユーザー以外の権限をすべてクリアする
※ BreakRoleInheritance メソッドの copyRoleAssignments を false にする
*securableObject.ResetRoleInheritance();
*for (var index = securableObject.RoleAssignments.Count - 1; index >;= 0; index--)*{
実行ユーザーしか残ってないので、for 文は実質 1 回しか繰り返すことがない

◆追加：ここから１
*[System.Runtime.InteropServices.DllImport("NativeOpenCv")]
*{～～割愛～～// ◆追加：ここから２// 黒画像と白画像の割合を指定して、平均輝度値を求めるvar y0 = GetMatMeanY(1, 1);     // 255 * 1/2 = 127.5var y1 = GetMatMeanY(2, 1);     // 255 * 1/3 =  85.0var y2 = GetMatMeanY(200, 300); // 255 * 3/5 = 153.0// ◆追加：ここまで２}
◆追加：ここまで１
◆追加：ここから２
黒画像と白画像の割合を指定して、平均輝度値を求める
var y0 = GetMatMeanY(1, 1);      255 * 1/2 = 127.5
var y1 = GetMatMeanY(2, 1);      255 * 1/3 =  85.0
var y2 = GetMatMeanY(200, 300);  255 * 3/5 = 153.0
◆追加：ここまで２
*}

NLog.configを出力ディレクトリにコピーするように設定してください。
もしくは、以下の通り明示的にパスを指定することもできます。2つめの引数falseはエラーを無視するか否かの設定です（false=無視しない）
LogManager.Configuration = new XmlLoggingConfiguration("/path/to/NLog.config", false);
ロガーの初期化・取得
*var logger = LogManager.GetCurrentClassLogger();
*logger.Info("test message for info");*logger.Warn("test message for warn");
ログの書き込み
ロガーの終了。プロセスを終了する前にログを送信するために必要
*LogManager.Shutdown();

*await new BlobClient(new Uri("https:
aka.msbloburl")).DownloadToAsync(downloadPath);
*{await blob.UploadAsync(file);}
Open the file and upload its data

*var builder = new SQLiteConnectionStringBuilder() {DataSource = dbName,Version = 3,LegacyFormat = false,SyncMode = SynchronizationModes.Off,JournalMode = SQLiteJournalModeEnum.Memory};
SQLite設定
Database,CSVFileオープン
*using(var db = new SQLiteConnection(builder.ToString()))
*private void SkipCSV(SQLiteConnection db, StreamReader csv) {long len = context.GetTable<;PwnedPasswordsRow>;().Count();for(long i = 0; i <; len; i++) {csv.ReadLine();}}
DBから入力済みの行数を取得し、読み飛ばす。
*while(!csv.EndOfStream) {*InsertRowsMultiple(db, csv);
CSVFile終端まで繰り返し

*if ( (ts!=prevTs) &amp;&amp; tms == 0 ) {
xx.xxx から yy.000 になったときに表示

*var attack = new SlashAttack();
ここを変えるだけ

画像のピクセルを byte[] にコピーする
*var rect = new Rectangle(0, 0, bmp.Width, bmp.Height);
*for (int i = 3; i <; rgbValues.Length; i += 4)*{
透明でないピクセルを探す
*if (rgbValues[i] != 0)*{
Aの値が0なら透明ピクセル

*string HTMLtext;
前回記事のcs参照
XML解析
*XDocument xdoc = XDocument.Parse(HTMLtext);
出力パラメータ
単数（item以下に入れ子構造なし）
*var item_name = e.Element("itemName");
*foreach (var u in e.Element("mediumImageUrls").Elements("imageUrl"))*Console.WriteLine(u.Value);
複数（item以下に入れ子構造あり）
空白行
*Console.WriteLine();

*m_tr.minVertexDistance = 0.01f;
頂点間の距離 曲線の滑らかさに起因

オブジェクトの権限を読み込む
*w =>; w.RoleAssignments.Include(
対象オブジェクトの権限を与えられたユーザー or SPグループのアクセス許可レベルを読み込む
*r =>; r.RoleDefinitionBindings.Include(
*foreach (var roleAssignment in securableObject.RoleAssignments)*{
対象オブジェクトの権限を出力
出力結果
ContosoCommunication 所有者 | SharePointGroup | Administrator | 2147483646 | フル コントロール
ContosoCommunication 所有者 | SharePointGroup | WebDesigner | 1012866479 | デザイン
ContosoCommunication 閲覧者 | SharePointGroup | Reader | 138613009 | 閲覧
ContosoCommunication メンバー | SharePointGroup | Editor | 1011031199 | 編集
user 100 | User | None | 1011029151 | 投稿コピー
*,,,
サイトのアクセス許可レベルを読み込む
*w =>; w.RoleDefinitions.Include(
*foreach (var roleDefinition in web.RoleDefinitions)*{
サイトのアクセス許可レベルを出力
出力結果
Administrator | 2147483646 | フル コントロール || 完全な制御が可能です。
WebDesigner | 1012866479 | デザイン || 表示、追加、更新、削除、承認、カスタマイズができます。
Editor | 1011031199 | 編集 || リストを追加、編集、削除できます。リスト アイテムとドキュメントを表示、追加、更新、削除できます。
Contributor | 1011029151 | 投稿 || リスト アイテムとドキュメントを表示、追加、更新、および削除できます。
Reader | 138613009 | 閲覧 || ページとリスト アイテム の表示、およびドキュメントのダウンロードができます。
Guest | 134287408 | 制限付きアクセス || 権限を与えられている場合は、特定のリスト、ドキュメント ライブラリ、リスト アイテム、フォルダー、またはドキュメントを表示できます。
None | 1011029151 | 投稿コピー ||
*,,,

*{ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto});
・・・一部省略・・・

*// We can clear the index by deleting it if it exists and creating*// it again
If we have run the sample before, this index will be populated
*// See this link for more information*// https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.search.models.softdeletecolumndeletiondetectionpolicy
corresponding document from the search service
*// The sample data set uses SQL integrated change tracking for change detection*// This means that when the indexer runs, it will be able to detect which data has
https:docs.microsoft.com/en-us/dotnet/api/microsoft.azure.search.models.softdeletecolumndeletiondetectionpolicy
*// See this link for more information*// https://docs.microsoft.com/en-us/sql/relational-databases/track-changes/about-change-tracking-sql-server
changed since the last run using built in change tracking
*// but the connection string may need to be updated if it was changed*await searchService.DataSources.CreateOrUpdateAsync(dataSource);
The data source does not need to be deleted if it was already created,
*// To avoid this, reset the indexer if it exists*exists = await searchService.Indexers.ExistsAsync(indexer.Name);
indexed the sample data and not run again
*// but the connection string may need to be updated if it was changed*await searchService.DataSources.CreateOrUpdateAsync(dataSource);
The data source does not need to be deleted if it was already created,
*// To avoid this, reset the indexer if it exists*exists = await searchService.Indexers.ExistsAsync(indexer.Name);
indexed the sample data and not run again

*$"https:
script.google.commacross{gasId}exec",

壁の場合, transform.upがnormalになる
*var normal = _holeCanvas.up;
eularAngleのxz成分を0にすることで穴の向きを合わせる
*var euler = _holeCanvas.eulerAngles;

Shell の登録
*builder.RegisterType<;MainWindow>;();
共有オブジェクトの依存関係(ログ、interceptorなど)
*builder.RegisterType<;TraceInterceptor>;();
AutofacではPrism.Moduleを使えない
*}

SharePoint リストオブジェクトを取得すると同時に
既定でアクセスできない HasUniqueRoleAssignments プロパティを読み込む
*var listCsomByTitle = context.Web.Lists.GetByTitle("CsomByTitle");
2行で書くバージョン
*context.Load(listCsomByTitle);
1行で書くバージョン
context.Load(listCsomByTitle, l =&gt; l, l =&gt; l.HasUniqueRoleAssignments);
*context.ExecuteQueryRetry();

*else {if ( (long)wParam == NativeMethods.WM_LBUTTONDOWN ||(long)wParam == NativeMethods.WM_RBUTTONDOWN ) {_hookExitReq = true;var p = Cursor.Position;_lastPoint = new NativeMethods.POINT(){x=p.X, y=p.Y};timer.Start();}// cancelreturn new IntPtr(1);}
注意：WM_MOUSEMOVE をキャンセルすると、カーソル表示が更新されない

*ss = File.ReadAllLines(commandFile);
, Encoding.GetEncoding("SHIFT_JIS"));
ミューテックスの所有権を要求する
*hasHandle = mutex.WaitOne(0, false);
別のアプリケーションがミューテックスを解放しないで終了した時
*hasHandle = true;

*var results = client.DownloadString( $@"https:
qiita.com:443apiv2items?page={(i+1)}&amp;per_page={DocumentPerPage}" );

Arrange：今回の場合は単純で、Accountクラスの新しいインスタンスを作成するだけ
*var account = new Account();
Act：200mという金額を口座に入金
*account.AddTransaction(200m);
Assert：口座の金額が正しいかチェック
*Assert.AreEqual(200m, account.Balance);
*account.Verify();*}
Assert
*_accountServiceBuilder.MockAccount.Verify();*}
Assert

*user.IncrementSessionTicket();
②
何もしない
*}
*public bool IsNull {get { return false; }}
何もしない
Null Objectパターンを適用しないと、ここで例外がスローされる
*user.IncrementSessionTicket();
*public string Name {get { return "unknown"; }}
何もしない
*Console.WriteLine("The user's name is {0}", userName);
Null Objectパターンを適用しないと、ここで例外がスローされる
*class Program {static Adapter dependency = new Adapter();static void Main(string[] args) {dependency.MethodA();}}
クライアントコード
*class Program {static IExpectedInterface dependency = new Adapter(new TargetClass());static void Main(stirng[] args) {dependency.MethodA();}}
クライアントコード
呼び出しごとに戦略(ストラテジー)を切り替える
*currentStrategy = (currentStrategy == strategyA) ? strategyB : strategyA;

*dic.Add("format", "xml");
取得方法　json または xml
dic.Add("formatVersion", "2"); jsonのみ２を使える　Default 1
dic.Add("hits", "5");  1ページあたりの取得件数　Default 30
dic.Add("page", "1"); 取得ページ数　Default 1
入力パラメータここまで************************************************************************
*var mylist = new List<;string>;();
*try{   client = new HttpClient();  }
クライアント接続開始
URLでHTMLを取得する。
*Task<;string>; task_get = GetRequest(RequestURL);
*{//String型を16進数バイト型文字列に変換　”楽天”→”%E6%A5%BD%E5%A4%A9”byte[] bytedata = Encoding.UTF8.GetBytes(Keyword);Keyword = "%" + BitConverter.ToString(bytedata).Replace("-", "%");return Keyword;}
keywordだけUTF８のバイト変換が必要
String型を16進数バイト型文字列に変換　”楽天”→”%E6%A5%BD%E5%A4%A9”
*byte[] bytedata = Encoding.UTF8.GetBytes(Keyword);
*{HttpResponseMessage response = await client.GetAsync(url);string contentstr = response.StatusCode.ToString();Console.WriteLine("【GetRequest Response】" + contentstr);if (response.StatusCode == System.Net.HttpStatusCode.OK){contentstr = await response.Content.ReadAsStringAsync();}else if (response.StatusCode == HttpStatusCode.Redirect){//StatusCode リダイレクトのときの処理var r = client.GetAsync(url).Result;Uri uri = new Uri(new Uri(url), r.Headers.Location);contentstr = client.GetAsync(uri).Result.Content.ReadAsStringAsync().Result;}return contentstr;}
URLからHTMLをゲット
StatusCode リダイレクトのときの処理
*var r = client.GetAsync(url).Result;

*{private readonly ReactiveProperty<;int>; _countReactiveProperty = new ReactiveProperty<;int>;();public IReactiveProperty<;int>; CountReactiveProperty =>; _countReactiveProperty;public void CountUp(){_countReactiveProperty.Value++;}public void Dispose(){_countReactiveProperty?.Dispose();}}
Modelは、ScriptableObjectにするかPresenterないでnew して生成していた
*{_model.CountReactiveProperty.TakeUntilDestroy(this).Subscribe(_view.UpdateCount);}
Modelからパラメータの変更通知は全てここに書いていた
*{_view.OnCountUpAsObservable().TakeUntilDestroy(this).Subscribe(_ =>; _model.CountUp());}
Viewからの入力受け取りは全てここに書いていた
このように値の更新と更新通知は別のinterfaceに分けた方がいいよなぁ
と思いつつも、つい一緒にまとめてしまう
*public interface IEntity
このEntityが、防御力を管理している場合、防御力の変化とダメージ計算は用途が違うので
interfaceも別にする
*public interface IDamageReduceEntity
*{_reactiveProperty.Value = value;}
状態の更新、場合によっては別のEntityによって計算された値をUseCaseから受け取ることもある
例えば防御力など、受けたダメージから防御力の数値を引いた結果をUseCaseに返して
HPを管理しているEntityに渡すことも
*public int Calculation(int damage)
*{IReadOnlyReactiveProperty<;int>; OnDefenseChangeAsObservable();void TakeDamage(int damage);void FindCharacter(string charecterId);}
本来は、TakeDamageとFindCharacterは全く用途が違うので別のクラスに分ける
*{return _entity.ReactiveProperty;}
EntityのReactivePropertyをそのまま流しているだけなので必要なのか？というお気持ちにになることもしばしば
受け取った結果を現在参照しているCharacterを管理するEntityに書き込む
*}
上位レイヤからのイベントはOnを付ける
View からの入力はOnを付けないようにしている
*IObservable<;int>; TakeDamageAsObservable();
一時期、入力はController、出力はPresenterに分けようかと考えていたが
面倒になったのと、下記方法でさほど問題を感じなかったのでPresenterに入力も出力も全て書くようにした
*public void Initialize()
*{_useCase.OnDefenseChangeAsObservable().Subscribe(_outputPort.ChangeDefense).AddTo(_disposable);}
MV(R)P期と同じく上位レイヤからのイベント通知監視はこちらに書く
*{_inputPort.TakeDamageAsObservable().Subscribe(_useCase.TakeDamage).AddTo(_disposable);}
View からの入力イベント監視はこちら側に書く
*{void TakeDamage(int damage);}
View間の参照はViewのinterfaceに任せる
*{return _button.OnClickAsObservable();}
Button などの入力もIObservableで返すように統一
FactoryのみDiContainerをInjectすることを許可している。
*private readonly DiContainer _container = default;
SceneContextにBindするときはScriptableObjectInstaller
それ以外のときはMonoInstallerを使うことが多い
Installerが肥大化したしたときは、用途やレイヤなどの粒度でInstaller&lt;T&gt;に区切るようにする
*public class Installer : MonoInstaller<;Installer>;
使うのはほぼBindInterfacesTo&lt;T&gt;のみ
以前はMonoBehaviourのBindにはZenjectBindingを使っていたが、
FromComponentOnRootを見つけてからはこっちに以降
(ドキュメントはよく読もう)
*Container.BindInterfacesTo<;View>;().FromComponentOnRoot();

*// in the index for this property and it will only be used by code in the client.*[JsonIgnore]
The JsonIgnore attribute indicates that a field should not be created
*{IConfigurationBuilder builder = new ConfigurationBuilder().AddJsonFile("appsettings.json");IConfigurationRoot configuration = builder.Build();SearchServiceClient serviceClient = CreateSearchServiceClient(configuration);string indexName = configuration["SearchIndexName"];Console.WriteLine("{0}", "Deleting index...\n");DeleteIndexIfExists(indexName, serviceClient);Console.WriteLine("{0}", "Creating index...\n");CreateIndex(indexName, serviceClient);ISearchIndexClient indexClient = serviceClient.Indexes.GetClient(indexName);Console.WriteLine("{0}", "Uploading documents...\n");UploadDocuments(indexClient);ISearchIndexClient indexClientForQueries = CreateSearchIndexClient(indexName, configuration);RunQueries(indexClientForQueries);Console.WriteLine("{0}", "Complete.  Press any key to end application...\n");Console.ReadKey();}
This sample shows how to delete, create, upload documents and query an index
*{var hotels = new Hotel[]{new Hotel(){HotelId = "1",HotelName = "Secret Point Motel",Description = "The hotel is ideally located on the main commercial artery of the city in the heart of New York. A few minutes away is Time's Square and the historic centre of the city, as well as other places of interest that make New York one of America's most attractive and cosmopolitan cities.",DescriptionFr = "L'hôtel est idéalement situé sur la principale artère commerciale de la ville en plein cœur de New York. A quelques minutes se trouve la place du temps et le centre historique de la ville, ainsi que d'autres lieux d'intérêt qui font de New York l'une des villes les plus attractives et cosmopolites de l'Amérique.",Category = "Boutique",Tags = new[] { "pool", "air conditioning", "concierge" },ParkingIncluded = false,LastRenovationDate = new DateTimeOffset(1970, 1, 18, 0, 0, 0, TimeSpan.Zero),Rating = 3.6,Location = GeographyPoint.Create(40.760586, -73.975403),Address = new Address(){StreetAddress = "677 5th Ave",City = "New York",StateProvince = "NY",PostalCode = "10022",Country = "USA"},Rooms = new Room[]{new Room(){Description = "Budget Room, 1 Queen Bed (Cityside)",DescriptionFr = "Chambre Économique, 1 grand lit (côté ville)",Type = "Budget Room",BaseRate = 96.99,BedOptions = "1 Queen Bed",SleepsCount = 2,SmokingAllowed = true,Tags = new[] { "vcr/dvd" }},new Room(){Description = "Budget Room, 1 King Bed (Mountain View)",DescriptionFr = "Chambre Économique, 1 très grand lit (Mountain View)",Type = "Budget Room",BaseRate = 80.99,BedOptions = "1 King Bed",SleepsCount = 2,SmokingAllowed = true,Tags = new[] { "vcr/dvd", "jacuzzi tub" }},new Room(){Description = "Deluxe Room, 2 Double Beds (City View)",DescriptionFr = "Chambre Deluxe, 2 lits doubles (vue ville)",Type = "Deluxe Room",BaseRate = 150.99,BedOptions = "2 Double Beds",SleepsCount = 2,SmokingAllowed = false,Tags = new[] { "suite", "bathroom shower", "coffee maker" }}}},new Hotel(){HotelId = "2",HotelName = "Twin Dome Motel",Description = "The hotel is situated in a  nineteenth century plaza, which has been expanded and renovated to the highest architectural standards to create a modern, functional and first-class hotel in which art and unique historical elements coexist with the most modern comforts.",DescriptionFr = "L'hôtel est situé dans une place du XIXe siècle, qui a été agrandie et rénovée aux plus hautes normes architecturales pour créer un hôtel moderne, fonctionnel et de première classe dans lequel l'art et les éléments historiques uniques coexistent avec le confort le plus moderne.",Category = "Boutique",Tags = new[] { "pool", "free wifi", "concierge" },ParkingIncluded = false,LastRenovationDate =  new DateTimeOffset(1979, 2, 18, 0, 0, 0, TimeSpan.Zero),Rating = 3.60,Location = GeographyPoint.Create(27.384417, -82.452843),Address = new Address(){StreetAddress = "140 University Town Center Dr",City = "Sarasota",StateProvince = "FL",PostalCode = "34243",Country = "USA"},Rooms = new Room[]{new Room(){Description = "Suite, 2 Double Beds (Mountain View)",DescriptionFr = "Suite, 2 lits doubles (vue sur la montagne)",Type = "Suite",BaseRate = 250.99,BedOptions = "2 Double Beds",SleepsCount = 2,SmokingAllowed = false,Tags = new[] { "Room Tags" }},new Room(){Description = "Standard Room, 1 Queen Bed (City View)",DescriptionFr = "Chambre Standard, 1 grand lit (vue ville)",Type = "Standard Room",BaseRate = 121.99,BedOptions = "1 Queen Bed",SleepsCount = 2,SmokingAllowed = false,Tags = new[] { "jacuzzi tub" }},new Room(){Description = "Budget Room, 1 King Bed (Waterfront View)",DescriptionFr = "Chambre Économique, 1 très grand lit (vue sur le front de mer)",Type = "Budget Room",BaseRate = 88.99,BedOptions = "1 King Bed",SleepsCount = 2,SmokingAllowed = false,Tags = new[] { "suite", "tv", "jacuzzi tub" }}}},new Hotel(){HotelId = "3",HotelName = "Triple Landscape Hotel",Description = "The Hotel stands out for its gastronomic excellence under the management of William Dough, who advises on and oversees all of the Hotel’s restaurant services.",DescriptionFr = "L'hôtel est situé dans une place du XIXe siècle, qui a été agrandie et rénovée aux plus hautes normes architecturales pour créer un hôtel moderne, fonctionnel et de première classe dans lequel l'art et les éléments historiques uniques coexistent avec le confort le plus moderne.",Category = "Resort and Spa",Tags = new[] { "air conditioning", "bar", "continental breakfast" },ParkingIncluded = true,LastRenovationDate = new DateTimeOffset(2015, 9, 20, 0, 0, 0, TimeSpan.Zero),Rating = 4.80,Location = GeographyPoint.Create(33.84643, -84.362465),Address = new Address(){StreetAddress = "3393 Peachtree Rd",City = "Atlanta",StateProvince = "GA",PostalCode = "30326",Country = "USA"},Rooms = new Room[]{new Room(){Description = "Standard Room, 2 Queen Beds (Amenities)",DescriptionFr = "Chambre Standard, 2 grands lits (Services)",Type = "Standard Room",BaseRate = 101.99,BedOptions = "2 Queen Beds",SleepsCount = 4,SmokingAllowed = true,Tags = new[] { "vcr/dvd", "vcr/dvd" }},new Room (){Description = "Standard Room, 2 Double Beds (Waterfront View)",DescriptionFr = "Chambre Standard, 2 lits doubles (vue sur le front de mer)",Type = "Standard Room",BaseRate = 106.99,BedOptions = "2 Double Beds",SleepsCount = 2,SmokingAllowed = true,Tags = new[] { "coffee maker" }},new Room(){Description = "Deluxe Room, 2 Double Beds (Cityside)",DescriptionFr = "Chambre Deluxe, 2 lits doubles (Cityside)",Type = "Budget Room",BaseRate = 180.99,BedOptions = "2 Double Beds",SleepsCount = 2,SmokingAllowed = true,Tags = new[] { "suite" }}}}};var batch = IndexBatch.Upload(hotels);try{indexClient.Documents.Index(batch);}catch (IndexBatchException e){// Sometimes when your Search service is under load, indexing will fail for some of the documents in// the batch. Depending on your application, you can take compensating actions like delaying and// retrying. For this simple demo, we just log the failed document keys and continue.Console.WriteLine("Failed to index some of the documents: {0}",String.Join(", ", e.IndexingResults.Where(r =>; !r.Succeeded).Select(r =>; r.Key)));}Console.WriteLine("Waiting for documents to be indexed...\n");Thread.Sleep(2000);}
Upload documents in a single Upload request.
*Console.WriteLine("Failed to index some of the documents: {0}",
the batch. Depending on your application, you can take compensating actions like delaying and
*Console.WriteLine("Failed to index some of the documents: {0}",
retrying. For this simple demo, we just log the failed document keys and continue.

*using (var g = System.Drawing.Graphics.FromHdc(desktopDC)) {g.DrawLine(pen, (float)((p.X-5)*_highDpiScale), (float)((p.Y-5)*_highDpiScale), (float)((p.X+5)*_highDpiScale), (float)((p.Y+5)*_highDpiScale));g.DrawLine(pen, (float)((p.X-5)*_highDpiScale), (float)((p.Y+5)*_highDpiScale), (float)((p.X+5)*_highDpiScale), (float)((p.Y-5)*_highDpiScale));g.DrawRectangle(pen, (float)(rect.X*_highDpiScale), (float)(rect.Y*_highDpiScale), (float)(rect.Width*_highDpiScale), (float)(rect.Height*_highDpiScale));}
描画が欠ける Scalingがうまくいっていないっぽい
*_lastPoint = new NativeMethods.POINT(){x=p.X, y=p.Y};
NativeMethods.GetCursorPos(out _lastPoint);

*{public class GlossaryItem{public string Term { get; set; }public string Definition { get; set; }}}
GlossaryItem.cs
*{Term= "Access Token",Definition = "A credential that can be used by an application to access an API. It informs the API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that has been granted."},
leave the glossary untouched
*[Route("{term}")]
new code

*HttpResponseMessage response = await client.GetAsync("http:
192.168.10.254");

*"Path=
MacHomeDocumentsprojectORiN2TutorialCaoPingAppCaoPingApptutorial.xml");
ICMPプロバイダに接続
*icmpCtrl = caoWS.AddController("Sample", "CaoProv.ICMP", "",
pingの送信
*CaoVariable stVar = crdPingStatus.AddVariable(Result.Value);
CAOエンジンの生成
*eng = new CaoEngine();
ICMPプロバイダに接続
*icmpCtrl = caoWS.AddController("Sample", "CaoProv.ICMP", "",
pingの送信
*textBox_Message.Text = icmpVar.Value.ToString();

（画面中心を原点(0,0)とした）ターゲットのスクリーン座標を求める
*var pos = mainCamera.WorldToScreenPoint(target.position) - center;
*if (pos.z <; 0f) {*pos.x = Screen.width;
カメラ後方にあるターゲットのスクリーン座標は、画面外に移動する
*if (pos.z <; 0f) {*pos.x = -pos.x;
カメラ後方にあるターゲットのスクリーン座標は、画面中心に対する点対称の座標にする
*if (isOffscreen) {pos.x /= d;pos.y /= d;}
ターゲットのスクリーン座標が画面外なら、画面端になるよう調整する
*if (Mathf.Approximately(pos.y, 0f)) {*pos.y = -center.y;
カメラと水平なターゲットのスクリーン座標を補正する
*if (isOffscreen) {arrow.rectTransform.eulerAngles = new Vector3(0f, 0f,Mathf.Atan2(pos.y, pos.x) * Mathf.Rad2Deg);}
ターゲットのスクリーン座標が画面外なら、ターゲットの方向を指す矢印を表示する
*float canvasScale = transform.root.localScale.z;*,,,
ルート（Canvas）のスケール値を取得する
*var halfSize = 0.5f * canvasScale * rectTransform.sizeDelta;*,,,
UI座標系の値をスクリーン座標系の値に変換する
*rectTransform.anchoredPosition = pos / canvasScale;*,,,
スクリーン座標系の値をUI座標系の値に変換する

コマンドライン引数を取得
*string[] args = Environment.GetCommandLineArgs();
カスタムURLスキームを取り除いた文字列をファイルパスとみなして取得する
*var filePath = arg.Substring("XXX:".Length);
filePathを用いてファイルを開く
*...
コマンドライン引数を取得
*string[] args = Environment.GetCommandLineArgs();
カスタムURLスキームを取り除いた文字列をファイルパスとみなして取得する
*var filePath = arg.Substring("XXX:".Length);
(ここまでは、前の章のソースコードと同じ)
filePathをパラメータに指定して「notepad」でファイルを開く
*Process.Start("notepad.exe", filePath);

*{LoadingDelayTimer.Stop();LoadData();}
DelayTimerのTickイベントハンドラ
*{LoadingDelayTimer.Stop();LoadingDelayTimer.Start();}
ListViewのSelectedIndexChangedイベントハンドラ
*{...}
データ呼び出し処理

*for (int page番号 = 1; page番号 <;= reader.NumberOfPages; page番号++)
このpage番号は1オリジンです
制御の文字列（オペレータ）は以下に詳しく書かれています。
http:www.kobu.com/docs/pdf/pdfxhand.htm
*string debug_text_UTF8 = System.Text.Encoding.UTF8.GetString(data);
合致したケース
*match_count++;

*await Task.Delay(200);
何秒ごとにフラグが変わるかのポーリングの秒数なのでお好きにどうぞ

*istr = new C<;object<;();
NG コンパイルエラー

*wpfWindow.ShowDialog();
modalの場合
wpfWindow.Show();        modelessの場合
*,,,
Window Handleを操作するためのHelper
*var helper = new System.Windows.Interop.WindowInteropHelper(wpfWindow);
親を設定する
*helper.Owner = new System.IntPtr(InventorApplication.MainFrameHWND);
表示する
wpfWindow.ShowDialog();     modalの場合
wpfWindow.Show();        modelessの場合
*,,,
WPF Windowの初期化
*var wpfWindow = new WpfWindow();
WPF WindowのHandleを得る
*var helper = new WindowInteropHelper(wpfWindow);
Dockable Windowの作成
*var dockableWindow = InventorApplication.UserInterfaceManager.DockableWindows.Add(System.Guid.NewGuid().ToString(), "Test", "Test");
Key hookをセット
*HwndSource.FromHwnd(handle).AddHook(WndProc);

*var response = await Client.DeleteAsync("http:
localhost:19691apivalues5");
計測を開始する
*BenchmarkRunner.Run<;WebApiClient>;();
*{return new string[] { "value1", "value2" };}
GET api/values
*{return "value";}
GET api/values/5
*{}
POST api/values
*{}
PUT api/values/5
*{}
DELETE api/values/5

*else {
0の場合はエラーの可能性がある
*{[DllImport("user32.dll", SetLastError = true)]public static extern int GetWindowThreadProcessId(IntPtr hWnd, out int lpdwProcessId);}
定義部
*{int pid;NativeMethods.GetWindowThreadProcessId(hWnd, out pid);Process p = Process.GetProcessById(pid);}
使用部
*{[StructLayout(LayoutKind.Sequential)]public struct WINDOWINFO{public int   cbSize;public RECT  rcWindow;public RECT  rcClient;public int   dwStyle;public int   dwExStyle;public int   dwWindowStatus;public uint  cxWindowBorders;public uint  cyWindowBorders;public short atomWindowType;public short wCreatorVersion;}[StructLayout(LayoutKind.Sequential)]public struct RECT{public int left;public int top;public int right;public int bottom;}[DllImport("user32.dll",SetLastError = true)]public static extern int GetWindowInfo(IntPtr hwnd, ref WINDOWINFO pwi);}
定義部
*{var wi = new WINDOWINFO();wi.cbSize = Marshal.SizeOf(wi);retCode = NativeMethods.GetWindowInfo(hWnd, ref wi);return wi;}
使用部
*{[DllImport("user32")]public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);}
定義部
*{int[] tabarray = new int[] { tabSize*4 };int wparam = tabarray.Length;IntPtr parray = Marshal.AllocCoTaskMem(Marshal.SizeOf(typeof(int)) * tabarray.Length);Marshal.Copy(tabarray, 0, parray, tabarray.Length);IntPtr ret = SendMessage(t.Handle, EM_SETTABSTOPS, new IntPtr(wparam), parray);// 解放処理が漏れている。 Marshal.FreeCoTaskMem とかで解放してください。return ret;}
使用部
解放処理が漏れている。 Marshal.FreeCoTaskMem とかで解放してください。
*return ret;

*MixedType list = new MixedType.L(new List<;int>; { 1, 2 });
listにはIList&lt;int&gt;型の値が入る
MixedType型のtupleに対して(1, 1)というタプル値が入る
*var tuple = new MixedType.T(1, 1);
MixedType型のbResultに対してbool型のtrueという値が入る
*var bResult = new MixedType.U( B true);
tupleに入っている値がTのものなら (1,1) → 1+1 つまり2をxへ
*case T (x, y) : x + y,
*Verify.InRange(index, 0, array.Length - 1);*return array[index];
"index (6) cannot be greater than array.Length - 1 (5)."
*{new KeyValuePair<;string, string>;("Hoge", 1),new KeyValuePair<;string, string>;("Piyo", 3),}
簡略化前
*{new("Hoge", 1),new("Piyo", 3),}
簡略化後
*{new("Hoge", 1),new("Piyo", 3),}
更に簡略化後

テストクラスやテストメソッドのリネームに追随できるよう、nameofを使ってパスを定義
var testDataDir = Path.Combine(nameof(SomeTestClass), nameof(SomeTest));  &lt;- テストケースごとに書きかえる必要がある
ディレクトリ内のテストデータを読んでテストする
*var imgPath = Path.Combine(testDataDir, "foo.png");

Systemは省略可能
*System.Console.Write("Hello ");
上記の条件に当てはまらない場合
*処理C
*switch (変数){case 条件A:処理Abreak;case 条件B:処理Bbreak;default://上記の条件に当てはまらない場合処理Cbreak;}
switch
上記の条件に当てはまらない場合
*処理C
宣言
*var list = new List<;string>;();
var オブジェクト名　= new List&lt;型&gt;(要素数);
追加
*list.Add("Tokyo");
削除
*list.Remove("Osaka");
*Console.WriteLine("[{0}]", string.Join(", ", list));
出力
出力結果
*>;>;>; [Tokyo, Nagoya]
Dictionary&lt;Keyの型名, Valueの型名&gt; オブジェクト名 = new Dictionary&lt;Keyの型名, Valueの型名&gt;()
追加
*dict.Add(1,"aaa");
削除
*dict.Remove(2)
出力
*Console.WriteLine(dict[3])
*foreach (KeyValuePair<;int, string>; item in dict){*Console.WriteLine("[{0}:{1}]", item.Key, item.Value);
全件出力

*{Debug.LogFormat("<;color=cyan>;OnPreGeneratingCSProjectFiles<;/color>;");return false;}
Unity標準のジェネレータ「以外」でC#プロジェクトを生成するかどうか返すコールバック(UnityVS等で利用).
*{Debug.LogFormat("<;color=blue>;OnGeneratedCSProject:<;/color>; {0}\n\n{1}", path, content);return content;}
C#プロジェクトファイルが生成された後に、修正を適用するコールバック.
*{Debug.LogFormat("<;color=orange>;OnGeneratedSlnSolution:<;/color>; {0}\n\n{1}", path, content);return content;}
C#ソリューションファイルが生成された後に、修正を適用するコールバック.
VisualStudioのバージョンアップによってcsprojがUnityと互換性が無くなったときの「セーフガード」.
後処理でcsprojを修正、または作り直す. 願わくば、これが必要になりませんように.
...とソースコードに書いてあった(意訳)
*static void OnGeneratedCSProjectFiles()
プラットフォームに合ったコンパイラ（unity_csc）を探す
*var csc = Paths.Combine(EditorApplication.applicationContentsPath, "Tools", "RoslynScripts", "unity_csc");
*if (!File.Exists(csc))*ThrowCompilerNotFoundException(csc);
コンパイラが見つからなかったら例外
*if (assembly.GeneratedResponseFile == null)*{
responseファイルを生成する
*var psi = new ProcessStartInfo() { Arguments = "/noconfig @" + assembly.GeneratedResponseFile, FileName = csc, CreateNoWindow = true };
ProcessStartInfoを生成し、新しいコンパイルプロセスを開始
typesにはCSharpLanguageしか入っていないので、以下と同じ
SupportedLanguages.Add(new CSharpLanguage());
*foreach (var t in types)
SupportedLanguagesにはCSharpLanguageしか入っていないので以下略
*CSharpSupportedLanguage = SupportedLanguages.Single(l =>; l.GetType() == typeof(CSharpLanguage));
SupportedLanguagesにカスタムC#を追加.
*ScriptCompilers.SupportedLanguages.RemoveAll(x =>; x.GetType() == typeof(CustomCSharpLanguage));
CSharpSupportedLanguageはreadonlyなのでリフレクションで上書き.
*typeof(ScriptCompilers)
こちらも上書き.
*EditorBuildRules.GetPredefinedTargetAssemblies()
カスタムコンパイラを使うかどうかのフラグ.
ScriptAssemblyやMonoIslandにはファイル一覧、参照一覧、シンボル一覧、出力ファイル名などの情報が格納されている.
それに応じて必要なアセンブリのみコンパイラを切り替えることが可能。
*bool useCustomCompiler = true;
カスタムコンパイラを使う.
*return new CustomCSharpCompiler(island, runUpdater);
*return base.CreateCompiler(scriptAssembly, island, buildingForEditor, targetPlatform, runUpdater);*}
使わない場合はデフォルトのコンパイラを使う.
継承元のコンパイルプロセスは即終了させる.
*var p = base.StartCompiler();
*var outopt = string.Format("/out:\"{0}\"", m_Island._output);
最後に生成されたresponse fileを取得する.
*var outopt = string.Format("/out:\"{0}\"", m_Island._output);
複数のファイルが生成される場合があるので、outオプションで判定する.
*{Arguments = ...,FileName = ...,CreateNoWindow = true};
自作のコンパイラでresponse fileを処理する.
プロセスを開始する.
*var program = new Program(psi);

ログインページ
string url_login = "https:grp01.id.rakuten.co.jp/rms/nid/vc?__event=login&amp;service_id=top";
formタグ内のaction
*string url_action = "./logini";
POST要求先
*string url_post = url_login + url_action;
ログイン後にジャンプするページ(ホーム画面)
string url_history = "https:www.rakuten.co.jp/";
*string USER_ID = "XXXXXXXXXXXXXX@mineo.jp";
クライアント接続開始
*client = new HttpClient();
POST要求（ログインしてクッキー取得）
*Task<;bool>; task_login = PostRequest(url_post, USER_ID, PASSWORD);
*if (task_login.Result)*{
URLでHTMLを取得する。
HTMLテキスト確認
*Console.WriteLine(HTMLtext);
HTML構造解析
string resultstr = AnalizeHtml(50, HTMLtext);
ファイルの保存（別タスクで非同期処理　続けて処理をおこなうときはWait()を削除する）
Task task1 = Task.Run(() =&gt; { SaveFile(resultstr); });
task1.Wait();
End待機
Thread.Sleep(1000);
*Console.ReadKey();
*{//POSTで送る内容作成。mContent.Add(属性の値, 属性の名前)MultipartFormDataContent mContent = new MultipartFormDataContent();mContent.Add(new StringContent(user), "u");mContent.Add(new StringContent(password), "p");//ヘッダ情報確認Console.WriteLine("【PostRequest Headers】" + mContent.Headers);//POSTしてレスポンスの要求。（要求先、要求内容）HttpResponseMessage response = await client.PostAsync(url_post, mContent);Console.WriteLine("【PostRequest Response】 " + response.StatusCode.ToString());if (response.StatusCode == HttpStatusCode.OK){//応答ステータスがOKならHTML文字列を取得する。string contentstr = await response.Content.ReadAsStringAsync();Console.WriteLine("【PostRequest HTMLcontent】" + contentstr);Console.WriteLine("【PostRequest Cookie】" + response.Headers.GetValues("Set-Cookie").First());}return true;}
POST要求（ログイン）
POSTで送る内容作成。mContent.Add(属性の値, 属性の名前)
*MultipartFormDataContent mContent = new MultipartFormDataContent();
ヘッダ情報確認
*Console.WriteLine("【PostRequest Headers】" + mContent.Headers);
POSTしてレスポンスの要求。（要求先、要求内容）
*HttpResponseMessage response = await client.PostAsync(url_post, mContent);
応答ステータスがOKならHTML文字列を取得する。
*string contentstr = await response.Content.ReadAsStringAsync();
POSTで送る内容作成。mContent.Add(属性の値, 属性の名前)
*MultipartFormDataContent mContent = new MultipartFormDataContent();
ヘッダ情報確認
*Console.WriteLine("【PostRequest Headers】" + mContent.Headers);
POSTしてレスポンスの要求。（要求先、要求内容）
*HttpResponseMessage response = await client.PostAsync(url_post, mContent);
応答ステータスがOKならHTML文字列を取得する。
*string contentstr = await response.Content.ReadAsStringAsync();
StatusCode リダイレクトのときの処理
*var r = client.GetAsync(url).Result;

*private Transform cHips;*private Transform lUpperLeg;
transformを保管する変数
*cHips = transform.Find("Root")*.Find("J_Bip_C_Hips");
腰のtransformを取得
股関節のtransformを取得
*lUpperLeg = cHips.Find("J_Bip_L_UpperLeg");
脚を30°傾ける
*lUpperLeg.rotation = Quaternion.AngleAxis(-30.0f, Vector3.right);
1秒周期の振り子を用意する
*float pendulum = (float)Math.Sin(Time.time * Math.PI);
股関節を右軸（x軸）を中心に±60°幅で揺らす
*lUpperLeg.localRotation = Quaternion.AngleAxis(-60.0f * pendulum, Vector3.right);
膝のtransformを取得
*lLowerLeg = lUpperLeg.Find("J_Bip_L_LowerLeg");
股関節の動きを少し変更
*lUpperLeg.localRotation = Quaternion.AngleAxis(-60.0f * pendulum - 20.0f, Vector3.right);
膝を揺らす
*lLowerLeg.localRotation = Quaternion.AngleAxis(-60.0f * pendulum + 60.0f, Vector3.right);
*cHips = transform.Find("Root")*.Find("J_Bip_C_Hips");
全身の関節のtransformを取得
速度を3倍に変更
*float pendulum = (float)Math.Sin(Time.time * Math.PI * 3.0f);
脚を揺らす
*lUpperLeg.localRotation = Quaternion.AngleAxis(-60.0f * pendulum - 20.0f, Vector3.right);
腰にひねりを加える
*cHips.localRotation = Quaternion.AngleAxis(10.0f * pendulum, Vector3.up) * Quaternion.AngleAxis(10.0f, Vector3.right);
胸は腰と反対にひねる
*cChest.localRotation = Quaternion.AngleAxis(-10.0f * pendulum, Vector3.up);
*lUpperArm.localRotation = Quaternion.AngleAxis(60.0f * pendulum + 30.0f, Vector3.right) * Quaternion.AngleAxis(70.0f, Vector3.forward);*rUpperArm.localRotation = Quaternion.AngleAxis(-60.0f * pendulum + 30.0f, Vector3.right) * Quaternion.AngleAxis(-70.0f, Vector3.forward);
腕を揺らす
腰の初期位置を保管する変数
*private Vector3 firstHipsPosition;
腰の初期値を取得する
*firstHipsPosition = cHips.localPosition;
周期が半分の振り子を用意する
*float halfPendulum = (float)Math.Sin(Time.time * Math.PI * 3.0f * 2.0f);
腰の位置を上下させる
*cHips.localPosition = firstHipsPosition + new Vector3(0.0f, 0.04f * halfPendulum, 0.0f);

delegate 戻り値定義 デリゲート名(引数定義)
*delegate int AddDelegate(int a,int b);
宣言したデリゲート型インスタンスを生成
その際にメソッドを登録(Addメソッド)
*AddDelegate add = new AddDelegate(Add);
*{return a + b;}
2つの整数の加算結果を返すメソッド

*{public MainPage(){InitializeComponent();webView.Navigated += (s, e) =>;{progressView.IsVisible = false;webView.IsVisible = true;};}}
略
ココ！
*Plugin.CurrentActivity.CrossCurrentActivity.Current.Init(this, savedInstanceState);
ココ！
*PermissionsImplementation.Current.OnRequestPermissionsResult(requestCode, permissions, grantResults);
*{Permission.Location,Permission.Camera,};
許可を求める権限群
許可を得ていない権限群
*var notPermitteds = new List<;Permission>;();
許可を求めるダイアログボックスを出す
*var statusMap = await CrossPermissions.Current.RequestPermissionsAsync(notPermitteds.ToArray());
許可されたら Web アプリ起動
webView.Source = "https:5ce07f72.ngrok.io";
*}

*{if(s is null){throw new ArgumentNullException(nameof(s));}...}
これまでの書き方
*{...}
C# 9.0で提案されている書き方

セグメントの総数
*int NumKeys;
*{float d = distance / DistanceStepSize;int index = Mathf.FloorToInt(d);if(index>;=DistanceToTArray.Length-1)return DistanceToTArray[DistanceToTArray.Length-1];float t = d - index;return Mathf.Lerp(DistanceToTArray[index], DistanceToTArray[index+1], t);}
距離からtに変換
*{var tToDistance = new float[NumKeys];var pp = Paths[0].Pos;float t = 0;for (int n = 1; n <; NumKeys; n++){t += 1f / Segment;Vector3 p = CalcPos(t);float d = Vector3.Distance(pp, p);PathLength += d;pp = p;tToDistance[n] = PathLength;}return tToDistance;}
tをSegmentに分割して進んだ距離を配列に入れて返す
*{var distanceToT = new float[NumKeys];distanceToT[0] = 0;DistanceStepSize = PathLength/(NumKeys-1);float distance = 0;int tIndex=1;for (int i = 1; i <; NumKeys; i++){distance += DistanceStepSize;var d = tToDistance[tIndex];while (d <; distance &amp;&amp; tIndex <; NumKeys - 1){tIndex++;d = tToDistance[tIndex];}var prevD = tToDistance[tIndex - 1];float delta = d - prevD;float t = (distance - prevD) / delta;distanceToT[i] = (1f/Segment)*(t + tIndex - 1);}return distanceToT;}
距離をSegmentに分割してその位置のtを配列に入れて返す

データを取得
(1) 保存したいデータと現在のDBのデータを比較して保存する値を決める
*var saved = false;
(2)　ここで(1)と同じ操作をしなくてはならない
*}

プレイヤーのNavMeshAgentを取得
*Player_Nav = GetComponent<;NavMeshAgent>;();
目的地のオブジェクトを取得
*Destination = GameObject.Find("Destination");
*Player_Nav.SetDestination(Destination.transform.position);*}
目的地を設定

実行サンプル 文字を1文字ずつ出す
*ShowPerOne("ウホウホバナナヨコセ");
特定のキー入力で文字を1文字ずつ出す機能を止める
*m_updateDispose =  this.UpdateAsObservable()
特定のキー入力で文字を1文字ずつ出す機能を止める
*m_updateDispose =  this.UpdateAsObservable()

*string ret_text = System.Text.Encoding.Unicode.GetString(buf);
Unicodeは .Net では UTF-16 と同義です。

*.ToUniTask();
UniTask&lt;T[]&gt;

コード入れる
*}
コード入れる
*}
JSON作成とアプリのデータパスに保存します。
*string jsonData = JsonUtility.ToJson(r);

「左辺」 = 「右辺」
*builder = JWTBuilder.Create()

*{rigidbody = GetComponent<;Rigidbody>;();}
Start is called before the first frame update
*{float moveH = Input.GetAxis("Horizontal");float moveV = Input.GetAxis("Vertical");Vector3 move = new Vector3(moveH, 0, moveV);rigidbody.AddForce(move);}
Update is called once per frame

*{internal int CustomerID { get; set; }internal long ProductID { get; set; }internal double DiscountRate { get; set; }}
入力用クラス
*{internal int CustomerID { get; set; }internal int TotalPrice { get; set; }}
出力用クラス
*{internal long ProductID { get; set; }internal int Price { get; set; }}
商品クラス
*{internal Products(){Add(new Product() { ProductID = 10000000001, Price = 100 });Add(new Product() { ProductID = 10000000002, Price = 200 });Add(new Product() { ProductID = 10000000003, Price = 300 });Add(new Product() { ProductID = 20000000004, Price = 1000 });Add(new Product() { ProductID = 20000000005, Price = 2000 });Add(new Product() { ProductID = 20000000006, Price = 3000 });}}
商品マスタ
入力
*var inputs = getData();
出力
*var outputs = new Calculator().Calculation(inputs);
*{var input = new List<;InputClass>;();input.Add(new InputClass { CustomerID = 1, ProductID = 10000000001, DiscountRate = 0.88 });input.Add(new InputClass { CustomerID = 1, ProductID = 10000000002, DiscountRate = 0.19 });input.Add(new InputClass { CustomerID = 1, ProductID = 10000000003, DiscountRate = 0.52 });input.Add(new InputClass { CustomerID = 2, ProductID = 20000000004, DiscountRate = 0.33 });input.Add(new InputClass { CustomerID = 2, ProductID = 20000000005, DiscountRate = 0.56 });input.Add(new InputClass { CustomerID = 3, ProductID = 20000000006, DiscountRate = 0.75 });return input;}
DBからデータを取得。今回は手打ち。
*{// 計算を実施する。internal IEnumerable<;OutputClass>; Calculation(IEnumerable<;InputClass>; inputs){// 商品マスタの取得var products = new Products();// 中間エンティティを用いて1レコードごとの価格を計算する。var middles = JoinAndCalcProductPrice(inputs, products);// 顧客ごとの集計と同時に結果オブジェクトに変換する。var results = SumPriceAndConvertToOutputs(middles);return results;}// 商品マスタから価格を取得する。計算はオブジェクト側で行う。privete IEnumerable<;MiddleClass>; JoinAndCalcProductPrice(IEnumerable<;InputClass>; inputs, IEnumerable<;Product>; products) =>; inputs.Join(products,i =>; i.ProductID,p =>; p.ProductID,(input, product) =>; new MiddleClass{CustomerID = input.CustomerID,DiscountRate = input.DiscountRate,Price = product.Price});// 顧客ごとの金額合計を取得して出力クラスにマッピングする。private IEnumerable<;OutputClass>; SumPriceAndConvertToOutputs(IEnumerable<;MiddleClass>; middles) =>; middles.GroupBy(c =>; c.CustomerID).Select(c =>; new OutputClass{CustomerID = c.Key,TotalPrice = c.Sum(s =>; s.Price)});}
計算クラス
*{// 商品マスタの取得var products = new Products();// 中間エンティティを用いて1レコードごとの価格を計算する。var middles = JoinAndCalcProductPrice(inputs, products);// 顧客ごとの集計と同時に結果オブジェクトに変換する。var results = SumPriceAndConvertToOutputs(middles);return results;}
計算を実施する。
商品マスタの取得
*var products = new Products();
中間エンティティを用いて1レコードごとの価格を計算する。
*var middles = JoinAndCalcProductPrice(inputs, products);
顧客ごとの集計と同時に結果オブジェクトに変換する。
*var results = SumPriceAndConvertToOutputs(middles);
商品マスタから価格を取得する。計算はオブジェクト側で行う。
*privete IEnumerable<;MiddleClass>; JoinAndCalcProductPrice(IEnumerable<;InputClass>; inputs, IEnumerable<;Product>; products) =>; inputs
顧客ごとの金額合計を取得して出力クラスにマッピングする。
*private IEnumerable<;OutputClass>; SumPriceAndConvertToOutputs(IEnumerable<;MiddleClass>; middles) =>; middles
税率
*internal const double _tax = 0.1;
入力側プロパティ ▽
*internal int CustomerID;
出力用プロパティ ▽
入力値が設定されていれば参照時にこの値は決定する。大きいプログラムだとこのプロパティが増えていく。
後々使う可能性があるので割引後価格は単独で持つ。
*private int DiscountPrice =>; Price - (int)(Price * DiscountRate);
計算結果を持つプロパティ。入力が変われば割引後価格が変わり、計算結果も連動して変わる。
*internal int CalculatedPrice =>; DiscountPrice + (int)(discountPrice * _tax);

*if(isIndexStraight &amp;&amp; !isMiddleStraight  &amp;&amp; !isRingStraight  &amp;&amp; !isPinkyStraight ){
人差し指だけまっすぐで、その他が曲がっている

カメラを起動して画面のキャプチャを開始するJS側の関数を呼び出し
*await jsRuntime.InvokeVoidAsync("barcodeScan.startCapture", DotNetObjectReference.Create(this));
例外発生時にはカメラを止めて失敗イベントを発火
*await StopCapture();
バーコード検出時の処理
*}
APIを呼び出して情報を取得
*BookInfo = await BookInfoClient.GetBookInfoAsync(isbn13);

*public int Hp { get { return hp; }}
古いC#でのゲッターオンリーのプロパティ
新しいC#では短く書けるゲッターオンリーのプロパティ
*public int Hp =>; hp;
*{get { return hp; }set { hp = value; }}
古いC#でのセッター・ゲッタープロパティ
*{get =>; hp;set =>; hp = value;}
新しいC#でのセッター・ゲッタープロパティ
*public int Name { get; private set; }
自動実装プロパティ
古いC#では、readonlyのために自動実装プロパティでなく
バッキングフィールドを使う
*private readonly string name;
*public string Name { get; }
新しいC#では、readonlyの自動実装プロパティが使える
古いC#では初期値を設定するために、バッキングフィールドを使う
自動実装プロパティは使えない
*private  string name = "No Name";
*public string Name { get; set; } = "No Name";
新しいC#では初期値の設定とともに
*public string Name { get; set; } = "No Name";
自動実装プロパティを使える
*public int Hp { get; }
Unityでは使ってはいけない
ValueTupleを返すLoadNameAndLevel
*public static (string name, int level) LoadNameAndLevel() =>; (name: "Ryota", level: 31);
分解で返値を受け取る
stringのnameとintのlevel
*var (name, level) = LoadNameAndLevel();
古いC#では冗長
*Player player = LoadPlayer();
新しいC#ではこんな感じに簡潔に書ける
*var targetMonsterName = player?.Target?.Name;
古いC#の書き方
*Player player = LoadPlayer();
新しいC#ではこんな感じに簡潔に書ける
*var targetMonsterName = player?.Target?.Name ?? "Default Target Name";
*{switch (obj){case int n when n <; 0:Debug.Log("負の数だよ！");break;case 7:Debug.Log("ラッキーセブンだよ！");break;case int n:Debug.Log($"整数だよ！ {n}");break;case string s:Debug.Log($"文字列だよ : {s}");break;case null:Debug.Log("nullだよ");break;default:Debug.Log("それ意外だよ");break;}}
objはどんな型がくるかわからない
*{switch (shape){case Rect r when r.Width == r.Height:Debug.Log($"正方形だよ！ 面積: {r.Area}");break;case Rect r:Debug.Log($"長方形だよ！ 面積 : {r.Area}");break;case Circle c:Debug.Log($"円だよ！ {c.Area}");break;}}
抽象型のShape。列挙型じゃないよ！

対象プロセスのPIDを含んだ名前のメモリーマップドファイルを作成。
インジェクトされた側は自身のPIDを使用してこのメモリーマップドファイルを開く。
*using (var sharedMemory = MemoryMappedFile.CreateNew(GetMemoryMappedFileName(pid), memorySize))
アセンブリの位置、実行するメソッドが定義されている型、実行するメソッドの名前、通信用の名前付きパイプの名前を書き込む。
*accessor.Write(position, assemblyLocation, out position);
書き終わってからインジェクトする。
..略..
*}
*{// メモ帳のプロセスIDを取得するvar pid = (uint)Process.GetProcessesByName("notepad").First().Id;var injector = new Injector();// メモ帳に自身のDLLをインジェクトし、DLL内のEntoryPoint関数を実行させるusing (var con = await injector.InjectAsync(pid, c =>; EntryPoint(c))){var buffer = new byte[1024];while (con.IsConnected){// メモ帳にインジェクトしたマネージドコードからの返答を待つvar count = await con.Pipe.ReadAsync(buffer, 0, buffer.Length, CancellationToken.None);var str = Encoding.UTF8.GetString(buffer, 0, count);Console.WriteLine($"recv:{str}");}}}
インジェクトする側(ホスト)のメインメソッド
メモ帳のプロセスIDを取得する
*var pid = (uint)Process.GetProcessesByName("notepad").First().Id;
*{var buffer = new byte[1024];while (con.IsConnected){// メモ帳にインジェクトしたマネージドコードからの返答を待つvar count = await con.Pipe.ReadAsync(buffer, 0, buffer.Length, CancellationToken.None);var str = Encoding.UTF8.GetString(buffer, 0, count);Console.WriteLine($"recv:{str}");}}
メモ帳に自身のDLLをインジェクトし、DLL内のEntoryPoint関数を実行させる
メモ帳にインジェクトしたマネージドコードからの返答を待つ
*var count = await con.Pipe.ReadAsync(buffer, 0, buffer.Length, CancellationToken.None);
*{var text = "Hello from notepad.exe!";var buf = Encoding.UTF8.GetBytes(text);// 引数で渡されたConnectionを使用してホストと通信する。await con.Pipe.WriteAsync(buf, 0, buf.Length);}
インジェクトされた側で実行されるメソッド
引数で渡されたConnectionを使用してホストと通信する。
*await con.Pipe.WriteAsync(buf, 0, buf.Length);

*navAgent.destination = Player.transform.position;
navMeshAgentの操作
*{particle = GetComponent<;ParticleSystem>;();//Exploder = player.GetComponent<;Exploder>;();}
Exploder Exploder;
*{Debug.Log("Hit");if (other.gameObject.CompareTag("Enemy")){yield return new WaitForSeconds(0.3f);SceneManager.LoadScene("GameOver");}if (other.gameObject.CompareTag("DeathZone")){yield return new WaitForSeconds(0.01f);SceneManager.LoadScene("GameOver");}}
Use this for initialization

*{controller = new Controller();_model = this.FindCubismModel();modelfingers = new Dictionary<;Leap.Finger.FingerType, CubismParameter>;();modelfingers.Add(Leap.Finger.FingerType.TYPE_INDEX, _model.Parameters[1]);modelfingers.Add(Leap.Finger.FingerType.TYPE_MIDDLE, _model.Parameters[2]);modelfingers.Add(Leap.Finger.FingerType.TYPE_RING, _model.Parameters[3]);modelfingers.Add(Leap.Finger.FingerType.TYPE_PINKY, _model.Parameters[4]);modelfingers.Add(Leap.Finger.FingerType.TYPE_THUMB, _model.Parameters[5]);}
Start is called before the first frame update

*oldMonth = oldMonth - 1;
旧暦月の補正
ルールとしては
(月 + 日) % 6　の結果が六曜になり
大安→赤口→先勝→友引→先負→仏滅
*int rokuyo = (oldMonth + oldDay) % 6;

*{texture = new Texture2D(1, 1, TextureFormat.RGBAFloat, false);renderTexture = new RenderTexture(1, 1, 0, RenderTextureFormat.ARGB32);renderTexture.filterMode = FilterMode.Point;buf = new CommandBuffer();buf.name = "GBuffer Test";foreach (var cam in Camera.allCameras){if (!cam){break;}cam.AddCommandBuffer(CameraEvent.AfterGBuffer, buf);}#if UNITY_EDITORvar sceneViewCameras = SceneView.GetAllSceneCameras();foreach (var cam in sceneViewCameras){if (!cam){break;}cam.AddCommandBuffer(CameraEvent.AfterGBuffer, buf);}#endif}
Start is called before the first frame update
*{if (!Input.GetMouseButtonDown(0)) return;RenderTexture.active = renderTexture;texture.ReadPixels(new Rect(0, 0, 1, 1), 0, 0);color = texture.GetPixel(0, 0);Debug.Log($"Color:{color}");}
Update is called once per frame

*var castA = new CastA();
CastA型でインスタンス化する

*this.Opacity = 0;
移動前に表示されてしまうので透過させておく
*{Bitmap bmp = new Bitmap(16,16);using ( Graphics g = Graphics.FromImage(bmp) ) { g.Clear(Color.Blue); }return Icon.FromHandle(bmp.GetHicon());}
-------------------------------------------

シリアライズ
*string savePath = @"C:\DQ\param.yaml";
シリアライズ
*string savePath = @"C:\DQ\param.yaml";
1行目を直接記述
*var version = "---\nVersion: 1.0.0\n";
*root_node.Add("Date", $"{ new DateTime(1988, 2, 10) }");
先ほど書いた1行目を根ノードとして取得
シリアライズ
*string savePath = @"C:\DQ\param.yaml";
テキスト抽出
*var input = new StreamReader(yamlPath, Encoding.UTF8);
デシリアライザインスタンス作成
*var deserializer = new Deserializer();
yamlデータのオブジェクトを作成
*var deserializeObject = deserializer.Deserialize<;YamlData>;(input);

並列処理オプションの設定
*ParallelOptions parallelOptions = new ParallelOptions();
*{Console.Write(value);});
並列処理実行

*m_Nodes.Remove(node);
順序を保持するためのリストから削除

処理
*}

*pr.BeginOutputReadLine();
非同期で標準出力読み取り

*y = 2;
Bai(1)を2に置き換えた

*}).ConfigureAwait(false);
スレッド復帰しない
ここは同じワーカースレッド
*Debug.WriteLine("Callback");
*{// ここはワーカースレッド1}).ConfigureAwait(false);
ここは UI スレッド
ここはワーカースレッド1
*}).ConfigureAwait(false);
*{// ここはワーカースレッド2}).ConfigureAwait(true);
ここはワーカースレッド1
ここはワーカースレッド2
*}).ConfigureAwait(true);
***注意***
ここはワーカースレッド2
*,,,
*{// ここはワーカースレッド1}).ContinueWith(() =>;
ここは UI スレッド
*{// ここはワーカースレッド1}).ConfigureAwait(true);
ここはワーカースレッド1
ここはワーカースレッド1
*}).ConfigureAwait(true);

こんな感じ
*var texture = ScreenCapture.CaptureScreenshotAsTexture(1);

*string jsonString = JsonSerializer.Serialize(testString, new JsonSerializerOptions { WriteIndented = true});
シリアライズ
JSON文字列をテキストファイルに保存
*File.WriteAllText(@"C:\Users\user\test.txt", jsonString);

本来はStore処理をすべきだけど省略
*}
*{public class Console{public static void WriteLine(string value) =>;System.Console.WriteLine($"This is \"sys.Console\" class's WriteLine:{value}");}}
命名則に反してるけど笑って許して
当たり前だけど違う型なので変数も別々
*var b = new Base.Nested();
これは出来る。
*point.X = 100;
property setterの呼び出しはNG(CS0165発生)
*point.Y = 100;
当然、何も関係なくてもメソッドの呼び出しもNG(CS0165発生)
*point.Some();
こいつはExternalLibなる別のアセンブリにある
*NoEnveloped hoge = new NoEnveloped();
こいつは上のやつ
*OutOfNameSpace piyo = new OutOfNameSpace();
この場合、Advent.NoEnvelopedと解釈される
*NoEnveloped hoge = new NoEnveloped();
これも同様に、Advent.OutOfNameSpaceと解釈される
*OutOfNamespace piyo = new OutOfNamespace();
これがグローバル名前空間にあるOutOfNamespace
*global::OutOfNamespace foo=new global::OutOfNamespace();
こいつは、ExternalLibにあるグローバル名前空間にいたNoEnveloped
*global::NoEnveloped bar=new global::NoEnveloped();

*private string signedTxHex;
署名済みTxを入れる
Jsonの組み立て
*[Serializable]
public bool extended_tx_info = true; 何故かエラーになります
*}
*{public string result;}
未署名Txの格納
*{string url = "リクエスト先APIサーバー";MonapaApi monapaApi = new MonapaApi();string monapaJson = JsonUtility.ToJson(monapaApi);StartCoroutine(ReqUnSignTxHex(url , monapaJson));IEnumerator ReqUnSignTxHex(string url, string bodyJsonString){UnityWebRequest postRequest = new UnityWebRequest(url, "POST");byte[] bodyRaw = Encoding.UTF8.GetBytes(bodyJsonString);postRequest.uploadHandler = (UploadHandler)new UploadHandlerRaw(bodyRaw);postRequest.downloadHandler = (DownloadHandler)new DownloadHandlerBuffer();postRequest.SetRequestHeader("Content-Type", "application/json");yield return postRequest.SendWebRequest();UnSignTxData unSignTxData = new UnSignTxData();unSignTxData = JsonUtility.FromJson<;UnSignTxData>;(postRequest.downloadHandler.text);unSignTxHex = unSignTxData.result;if (postRequest.isHttpError || postRequest.isNetworkError){Debug.Log(postRequest.error);}else{Debug.Log(postRequest.downloadHandler.text);}},,,//上記の続きです。private void SignRawTx(){//MonacoinのMainnetに接続NBitcoin.Network network = NBitcoin.Altcoins.Monacoin.Instance.Mainnet;//秘密鍵の読み込みvar bitcoinPrivateKey = new BitcoinSecret("秘密鍵");network = bitcoinPrivateKey.Network;var transaction = Transaction.Create(network);transaction = Transaction.Parse(unSignTxHex, network);//署名するtransaction.Sign(bitcoinPrivateKey, false);signedTxHex = transaction.ToHex();},,,*{//MonacoinのMainnetに接続NBitcoin.Network network = NBitcoin.Altcoins.Monacoin.Instance.Mainnet;//秘密鍵の読み込みvar bitcoinPrivateKey = new BitcoinSecret("秘密鍵");network = bitcoinPrivateKey.Network;var transaction = Transaction.Create(network);transaction = Transaction.Parse(unSignTxHex, network);//署名するtransaction.Sign(bitcoinPrivateKey, false);signedTxHex = transaction.ToHex();},,,MonacoinのMainnetに接続
*NBitcoin.Network network = NBitcoin.Altcoins.Monacoin.Instance.Mainnet;
秘密鍵の読み込み
*var bitcoinPrivateKey = new BitcoinSecret("秘密鍵");
署名する
*transaction.Sign(bitcoinPrivateKey, false);

*{public ReservationDateTime(DateTime start, DateTime end){if (start.CompareTo(end) >;= 0)throw new ArgumentException("終了日時は開始日時よりも後にしてください。");Start = start;End = end;}public DateTime Start { get; }public DateTime End { get; }// 以下省略}
利用時間の ValueObject
以下省略
*}
*{public PurposeOfUse(string value){Assertion.ArgumentRange(value, 64, nameof(PurposeOfUse));Value = value;}public string Value { get; }// 以下省略}
利用目的 の ValueObject
以下省略
*}
以下省略
*}

のようにして、Constraintを有効にする
*}

臨時キャンペーンの追加
Azure functionsを利用している
アクセスするURL
*var url = "hogehoge";
JSONを受け取って独自クラスにコンバートする
*var result = await client.GetStringAsync(url);
*for (int i = 0; i <; ls.Count; i++)*{
データ格納処理
ここにエラー時処理
*}
[Table(“LPInfo”)]などでデータとバインディングしている。
詳しい記法は Azure Functions の公式ドキュメントを読んでください。
*[HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = null)] HttpRequest req,
Azure Table Strageにアクセスし、データをリストに格納する。
*var querySegment = cloudTable.ExecuteQuerySegmentedAsync(new TableQuery<;LPINFO>;(), null);
すべての格納が終了した後に、Jsonファイルを生成している。
*responseContent = new StringContent(JsonConvert.SerializeObject(ls,Formatting.Indented),Encoding.UTF8,"application/json");
*{Content = responseContent};
最後に生成したJsonファイルを返す。
レコードを取得する用のクラス。
これを作ることによってListでの管理が可能になる。
*public class LPINFO : TableEntity
*{var view = inflater.Inflate(Resource.Layout.Suggest, container, false);var button = view.FindViewById<;Button>;(Resource.Id.updateButton/* ボタンのId */);button.Click += Clicked;return view;}
本物の実装ではFragmentを用いているのでちょっと形式が違うと思います…
ここにクリック時の処理を記述...
*}
本当はDictionaryを用いたかったが、JavaList&lt;IDictionary&lt;string, object&gt;&gt;()へのキャストでExceptionを吐いてしまうためJavaDictionaryを用いた,
*private JavaDictionary<;string, string>; dic = new JavaDictionary<;string, string>;();
アダプター作成とセット
*var lsView = View.FindViewById<;ListView>;(Resource.Id.outputView);

*.Replace("\n", string.Empty);
Windowsだったらこの行は不要かも

*speak.cancelPlay();
音声再生をキャンセルする

*set { _text = value; PropertiesUpdated?.Invoke();}
プロパティの変更を通知する

*serializer.Serialize(writer, app, ns);
空白のnamespaceを使ってシリアライズ

現在再生中のTween
*Tween currentPlayTween;
*{PlayMoveTween();}
開始時
*{// 移動時間float duration = 2f;// 移動値Vector3 endValue = new Vector3(10, 10, 0);// Tweenの作成currentPlayTween = transform.DOMove(endValue, duration);// 相対に切り替えcurrentPlayTween.SetRelative();// イーズタイプの指定currentPlayTween.SetEase(Ease.Linear);// 再生currentPlayTween.Play();}
Tweenの再生
移動時間
*float duration = 2f;
移動値
*Vector3 endValue = new Vector3(10, 10, 0);
*currentPlayTween = transform.DOMove(endValue, duration);*// 相対に切り替え
Tweenの作成
相対に切り替え
*currentPlayTween.SetRelative();
イーズタイプの指定
*currentPlayTween.SetEase(Ease.Linear);
再生
*currentPlayTween.Play();
現在再生中のSequence
*Sequence currentPlaySequence;
*{spriteRenderer = GetComponent<;SpriteRenderer>;();PlaySequence();}
開始時
*{// 移動時間float moveDuration = 1f;// 移動の最終値Vector3 moveEndValue = new Vector3(10, 10, 0);// 待機時間float waitDuration = 1f;// 透過時間float fadeDuration = 1f;//  透過最終値float fadeEndValue = 0f;// 移動Tweenの作成Tween moveTween = transform.DOMove(moveEndValue, moveDuration).SetRelative().SetEase(Ease.Linear);// 透過Tweenの作成Tween fadeTween = spriteRenderer.DOFade(fadeEndValue, fadeDuration);// Sequenceを生成currentPlaySequence = DOTween.Sequence();// Sequenceの構築currentPlaySequence.Append(moveTween).AppendInterval(waitDuration).AppendCallback(()=>;Debug.Log("AppendCallback()")).Append(moveTween).Join(fadeTween);// 再生currentPlaySequence.Play();}
Sequenceの再生
移動時間
*float moveDuration = 1f;
移動の最終値
*Vector3 moveEndValue = new Vector3(10, 10, 0);
待機時間
*float waitDuration = 1f;
透過時間
*float fadeDuration = 1f;
透過最終値
*float fadeEndValue = 0f;
*Tween moveTween = transform.DOMove(moveEndValue, moveDuration).SetRelative().SetEase(Ease.Linear);*// 透過Tweenの作成
移動Tweenの作成
透過Tweenの作成
*Tween fadeTween = spriteRenderer.DOFade(fadeEndValue, fadeDuration);
Sequenceを生成
*currentPlaySequence = DOTween.Sequence();
Sequenceの構築
*currentPlaySequence
再生
*currentPlaySequence.Play();
時間
*float duration = 1f;
最終値
*int endValue = 100;
現在の値
*int currentValue = 0;
Tweenの生成
*currentPlayTween = DOTween.To
再生
*currentPlayTween.Play();
移動時間
*float duration = 1f;
移動の最終値
*Vector3 endValue = new Vector3(10, 10, 0);
*currentPlayTween = transform.DOMove(endValue, duration).SetRelative().SetEase(Ease.Linear);*// ループの指定
Tweenの生成
ループの指定
*currentPlayTween.SetLoops(-1, LoopType.Incremental);
コールバック群
*currentPlayTween.OnPlay(() =>; Debug.Log("OnPlay()"));
再生
*currentPlayTween.Play();
Tweenの破棄
*currentPlayTween.Kill();

・・・一部省略
*,,,
・・・一部省略
*,,,
Arrange・Act
*var response = await HttpClient.GetAsync(_url);

*{if (Directory.Exists("/sys/class/gpio/gpio" + gpio) == false){///sys/class/gpio/exportにGPIOピン番号を書き込む.using (var writer = new StreamWriter("/sys/class/gpio/export")){writer.WriteLine(gpio.ToString());}}System.Threading.Thread.Sleep(100);// /sys/class/gpio/gpioX/directionusing (var writer = new StreamWriter("/sys/class/gpio/gpio" + gpio + "/direction")){writer.WriteLine("out");writer.Close();}}
GPIOピンの初期設定を行う.
*{writer.WriteLine("out");writer.Close();}
/sys/class/gpio/gpioX/direction
*{// /sys/class/gpio/gpioX/valueの内容が0/1でOFF/ONが求まる.using (var writer = new StreamWriter("/sys/class/gpio/gpio" + gpio + "/value")){writer.WriteLine(level.ToString());writer.Close();}}
GPIOのON/OFFを制御する.
*{writer.WriteLine(level.ToString());writer.Close();}
/sys/class/gpio/gpioX/valueの内容が0/1でOFF/ONが求まる.
GPIO4を初期化する.
*initGPIOPin(4);
*switchGPIO(4, 1);*// 1秒待機.
LEDを点灯する.(GPIO4をONにする)
1秒待機.
*Thread.Sleep(1000);
*switchGPIO(4, 0);*// 1秒待機.
LEDを消灯する.(GPIO4をOFFにする)
1秒待機.
*Thread.Sleep(1000);
wiringPiのセットアップ
*wiringPiSetupGpio();
GPIO 14をOUTPUT(1)に設定する.
*pinMode(14, OUTPUT);
GPIO 15をOUTPUT(1)に設定する.
*pinMode(15, OUTPUT);
GPIO 18をPWM_OUTPUT(2)に設定する.
*pinMode(18, PWM_OUTPUT);
初期状態としてモーターを停止する.
*digitalWrite(14, 0);
モーターを正転する.
*digitalWrite(14, 1);
回転数を1/4に設定する
*pwmWrite(18, 256);
3秒待機する.
*Thread.Sleep(3000);
回転数を1/2に設定する
*pwmWrite(18, 512);
3秒待機する.
*Thread.Sleep(3000);
回転数を最大に設定する
*pwmWrite(18, 1024);
3秒待機する.
*Thread.Sleep(3000);
モーターをブレーキする.
*digitalWrite(14, 1);

InfoData[] resultで各値を参照
*[SerializeField] public InfoData[] result;
下で参照する項目を指定することで値を格納し表示する
*[SerializeField] public string address;

レポートイベントの登録
*client.OnRoAccessReportReceived +=
*for(int i = 0; i <; data.AirProtocolTagData.Count; ++i) {*IParameter airProtocol = data.AirProtocolTagData[i];
CRC, PC
*if(pEpc is PARAM_EPC_96) {epc = (pEpc as PARAM_EPC_96).EPC.ToHexString();} else if(pEpc is PARAM_EPCData) {epc = (pEpc as PARAM_EPCData).EPC.ToHexString();}
EPC
ROSpec の削除, 有効化, 無効化, 開始, 停止で同じ ROSpec ID を使用します.
*roSpec.ROSpecID      = 1234;
N個のタグを検出もしくは ROSpec の終了を条件にしてタグレポートを発行させる.
0 にしているため, この場合では ROSpec の終了のみを条件としている.
*reportSpec.N               = 0;
EPC 領域の先頭 2[word] CRC + PCBits の取得
*tagReportContentSelector.AirProtocolEPCMemorySelector = new UNION_AirProtocolEPCMemorySelector();
タグ受信時のレポートに
アンテナID, 周波数ID, [初-末]検出時刻, 受信感度, ROSpecID, タグ検出回数
を含める
*tagReportContentSelector.EnableAntennaID          = true;
使用するアンテナを指定
*aiSpec.AntennaIDs = new UInt16Array();
0 を指定するとリーダが対応しているアンテナすべてを有効化できます.
aiSpec.AntennaIDs.Add(0);
*aiSpec.AntennaIDs.Add(1);
*for(ushort i = 0; i <; 4; ++i) {*PARAM_AntennaConfiguration antennaConfig = new PARAM_AntennaConfiguration();
アンテナ設定
受信感度 -80.00[dBm]
*rfReceiver.ReceiverSensitivity = 1;
出力電力 30.00[dBm]
*rfTransmitter.TransmitPower = 81;
*} else if(msgErr != null) {*Console.Error.WriteLine(msgErr.LLRPStatus.ErrorDescription);
Success
*} else if(msgErr != null) {*Console.Error.WriteLine(msgErr.LLRPStatus.ErrorDescription);
Success
*} else if(msgErr != null) {*Console.Error.WriteLine(msgErr.LLRPStatus.ErrorDescription);
Success
*} else if(msgErr != null) {*Console.Error.WriteLine(msgErr.LLRPStatus.ErrorDescription);
Success
*} else if(msgErr != null) {*Console.Error.WriteLine(msgErr.LLRPStatus.ErrorDescription);
Success
*} else if(msgErr != null) {*Console.Error.WriteLine(msgErr.LLRPStatus.ErrorDescription);
Success

そのプロセス名のプロセスを全部取得し
*System.Diagnostics.Process[] ps = System.Diagnostics.Process.GetProcessesByName(ProcessName);
*foreach (System.Diagnostics.Process p in ps)*{
取得したプロセスのIDと名前を順にコレクションに格納

BoxCollider2D コンポーネント
*BoxCollider2D collider2d;
衝突結果を格納 (最大5個まで)
*Collider2D[] results = new Collider2D[5];
*{// Colliderをキャッシュcollider2d = GetComponent<;BoxCollider2D>; ();}
開始処理
Colliderをキャッシュ
*collider2d = GetComponent<;BoxCollider2D>; ();
*{if ( IsHitToEnemy ()  ) {Debug.Log ("衝突しています");}}
更新処理
*{// collider2dと衝突しているcolliderの数が返ってくるint hitCount = collider2d.OverlapCollider(new ContactFilter2D(), results);if ( hitCount >; 0 ){for ( int i = 0; i <; hitCount; i++ ){// 衝突したオブジェクトのTagがEnemyならreturnif ( results [ i ].tag == "Enemy"){return true;}}}return false;}
敵との衝突判定
collider2dと衝突しているcolliderの数が返ってくる
*int hitCount = collider2d.OverlapCollider(new ContactFilter2D(), results);
*if ( results [ i ].tag == "Enemy")*{
衝突したオブジェクトのTagがEnemyならreturn

クリックされてから次のクリックを受け付けるまでの秒数
*private const float ClickTimeSpanThreshould = 0.05f;
ボタンのクリックを受け付けるかどうか
*private bool _clickable = true;
カウンタ
*private float _timer = 0f;
注意：　UIGestureは、EventSystemの各種イベントハンドラを実装したクラス
*var gesture = GetComponent<;UIGesture>;();
クリックされた時の処理を実行
*onClickCallback?.Invoke();
ボタンのクリックを受け付けるかどうか
*private bool _clickable = true;
注意：　UIGestureは、EventSystemの各種イベントハンドラを実装したクラス
*var gesture = GetComponent<;UIGesture>;();
クリックされた時の処理を実行
*await onClickAsync?.Invoke();
注意：　UIGestureは、EventSystemの各種イベントハンドラを実装したクラス
*var gesture = GetComponent<;UIGesture>;();
*onBeforeClick?.Invoke();*// クリックされた時の処理を実行
ここで入力ブロッキングOn
クリックされた時の処理を実行
*await onClickAsync?.Invoke();
ここで入力ブロッキングOff
*onAfterClick?.Invoke();

レスポンス生成
*ResponseJson response = new ResponseJson();

*{Shader.SetGlobalFloat("GlobalVal",Mathf.Sin(Time.time));}
Update is called once per frame

*Debug.Log(history.Where(x =<; x % 2 == 0).Count());
linqも使える

*e is COMException ) {
Note: C#6以降なら when を使ってもう少しきれいに書ける
もみ消す
*return;

「アクティブでないアプリケーションアドイン」のチェック

*try
アクティブになっていないので「3」を設定する
*key.SetValue("LoadBehavior", 3, RegistryValueKind.DWord);
エラーは無視
*Console.Error.WriteLine("レジストリ[LoadBehavior]チェック:Exception\n" + e.ToString());
「無効なアプリケーションアドイン」のチェック

*try
*if (System.Text.Encoding.UTF8.GetString(data.ToList().Where(v =>; v != 0).ToArray()).Contains($"{addin}"))*{
キーで読みだした値から「0」を除去して結合。ASCIIから文字列を取得し、アドイン名が含まれている場合は該当のレジストリを消去。
エラーは無視
*Console.Error.WriteLine("レジストリ[DisabledItems]チェック:Exception\n" + e.ToString());
*if (System.Text.Encoding.UTF8.GetString(data.ToList().Where(v =>; v != 0).ToArray()).Contains($"{addin}"))*{
キーで読みだした値から「0」を除去して結合。ASCIIから文字列を取得し、アドイン名が含まれている場合は該当のレジストリを消去。
エラーは無視
*Console.Error.WriteLine("レジストリ[CrashingAddinList]チェック:Exception\n" + e.ToString());

*app = new WindowsAppFriend(Process);
魔法の時間、これで相手のプロセスに潜り込んでやりたい放題
UIインスタンスをつかんでみる
おなじみのApplication.Current.MainWindowですね、
MainWindowここにきてるように見えますが、実はきてません（相手プロセスにいます）
*AppVar mainWindow = app.Type<;Application>;().Current.MainWindow;
明らかに一個しかない場合はこれで特定できるが、上のXamlではエラーになります。
*var onlyOne = mainWindow.LogicalTree().ByType<;TextBox>;().Single();
普通はもう一段ByBinding書いて対象を絞る。
ByType,ByBidingはDependencyObjectのコレクションを返すのでメソッドチェンできる
*var textbox1 = mainWindow.LogicalTree().ByType<;TextBox>;().ByBinding("Text1").Single();
型参照できない場合は文字列のインターフェスを使う
*var unkwownType = mainWindow.LogicalTree().ByType("ThirdPartyTextBox").Single();
ちなみにあんまりおすすめできないがインデックスアクセスできます
*var command1Button = mainWindow.LogicalTree().ByType<;Button>;()[0];
x:Nameでの捕まえ方、実はリフレクションを使ったフィールドアクセス（と思います）
*var textbox2 = mainWindow.Dynamic()._text2;
リフレクションなのでVisablity関係ないですから、DataContextもとれる
MVVMを採用しれいれば、通常DataContextが内部API詰まってるので、ユニットテストに活用する手もありです
ちなみに、これは結合した状態の生きたインスタンスなので、普段ユニットテストで足場を作る作業は不要ですよ。
*var dataContext = mainWindow.Dynamic().DataContext;
staticメンバーへのアクセス
インスタンス前提で話してきたが、staticメンバーの場合はこれでアクセスできます。（結構はまりました）
*var staticMember = app.Type<;MainWindowVM>;().StaticMember
UIのふるまいをシミュレートする
*WPFTextBox wpfTextBox = new WPFTextBox(textbox1);
Asyncでクリックする、スレッドは止まらない
*var async = new Async();
モーダルダイアログが表示されるのを確実に待ち合わせる
*var dlg = mainWindow.WaitForNextModal();
ダイアログ上のボタンを押す、dlgからしか取れません。
*var buttonOK = new WPFButtonBase(dlg.Dynamic()._buttonOK);
非同期で実行したモーダルボタン押下の処理が完全に終了するのを待つ
*async.WaitForCompletion();

*string path2;
out file name
ここで抽出する色の条件を決める
一例。赤要素が１６０以上でかつ、
青緑の平均より、2割上回る部分（これがないと単に白色が抽出される）
if (r1 &gt; 160 )
*if (r1 >; 160 &amp;&amp; r1 >; ((g1+b1)/2*1.2))
単に白色に置き換えると返って浮く場合は色を調整
*}

自身のクラスのインスタンスを初期化（アプリ実行時にインスタンスはこの1つしか存在しない）
*private static SingletonClass _instance = new SingletonClass();
ロガーインスタンス取得コード
*private static readonly log4net.ILog _logger = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);
自身のインスタンスを外部から使うための手段を用意してあげる
プロパティを使った方法
*public static SingletonClass Instance =>; _instance;
メソッドを使った方法
*public static SingletonClass GetInstance() =>; _instance;
*{_logger.Debug("SingletonClassのインスタンスが生成されました");}
外部から直接呼べないコンストラクタ
シングルトンインスタンスを保持するフィールド
*private SingletonClass _singletonInstance;
シングルトンインスタンスを取得
*_singletonInstance = SingletonClass.GetInstance();
ロガーインスタンス取得コード
*private static readonly log4net.ILog _logger = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);
自身のクラスのインスタンスを初期化
*private static SingletonClass _instance = new SingletonClass();

*int step = 2;
(BUFFER_SIZE+WIDTH-1)WIDTH;

+1して返すだけの関数
*int Inc(int x) =>; x+1;
というのがあったとすると
*var b = new B();
とつかうとGetOne()内で直接B.One()というメソッドが呼ばれます
*IA a = new B();

*_numbers.Enqueue(number);
キューに番号を順に登録
*if (_numbers.Count <; 1) throw new Exception("Remaining numbers are already Empty.");*return _numbers.Dequeue();
例外処理：引くくじが残っていない

下 2 行を追加
*PlayFabSettings.staticSettings.TitleId = "ここに Title Id を入れます";
*if (env.IsDevelopment())*{
サンプルなので雑管理だけど許して欲しい

#error version -&gt; コンパイラ バージョン: '3.7.0-6.20371.12 (917b9dfa)'。言語バージョン: default。
いや、default ってなんや。
*,,,

*string deploymentUrl = "<;https:
***.***.jphoge.vsto";&gt;

*v.AddRange(vpp);
v配列に appデータを増やす
*//v.ForEach(a =>;{//    Console.Write(" {0}",a);//});
ラムダで書いたバージョン
*//    Console.Write(" {0}",a);
v.ForEach(a =&gt;{

*Marshal.FreeCoTaskMem(pStructure);
確保したアンマネージドメモリの解放

*| NativeMethods.AnimateWindowFlags.AW_BLEND
AW_SLIDE

*int Port = 8080;
ポート番号を指定
UdpClientを作成し、指定したポート番号にバインドする
*IPEndPoint EP = new IPEndPoint(IPAdd, Port);
非同期的な受信を開始する
*udp.BeginReceive(UdpServer, udp);
*{UdpClient udp = (UdpClient)ar.AsyncState;for (;;){//一度非同期受信を終了するIPEndPoint remoteEP = null;byte[] rcvBytes = udp.Receive(ref remoteEP);//受信したデータを文字列に変換string rcvMsg = System.Text.Encoding.UTF8.GetString(rcvBytes);//"exit"を受信したら終了if (rcvMsg == "exit"){break;}D = rcvMsg.Split(' ');for(i=0;D[i]== null; i++){d[i] = int.Parse(D[i]);}//受信したデータをTextBoxに表示するstring displayMsg = string.Format("{0}", rcvMsg);richTextBox1.BeginInvoke(new Action<;string>;(ShowReceivedString1), displayMsg);X_Data.BeginInvoke(new Action<;string>;(ShowReceivedString_x), D[0]);Y_Data.BeginInvoke(new Action<;string>;(ShowReceivedString_y), D[1]);Z_Data.BeginInvoke(new Action<;string>;(ShowReceivedString_z), D[2]);}rcvMsg = "終了しました";//UdpClientを閉じるudp.Close();richTextBox1.BeginInvoke(new Action<;string>;(ShowReceivedString1), rcvMsg);}
データを受信した時の処理
一度非同期受信を終了する
*IPEndPoint remoteEP = null;
受信したデータを文字列に変換
*string rcvMsg = System.Text.Encoding.UTF8.GetString(rcvBytes);
*if (rcvMsg == "exit")*{
"exit"を受信したら終了
*string displayMsg = string.Format("{0}", rcvMsg);
受信したデータをTextBoxに表示する
UdpClientを閉じる
*udp.Close();
*if (udpClient != null)*{
UdpClientを閉じる

*{ReloadUxml();});
メニューアイテムを登録。
一度ルートに紐付けられた要素を全て削除する。
*rootVisualElement.Clear();
UXMLの読み込み。
*var visualTree = AssetDatabase.LoadAssetAtPath<;VisualTreeAsset>;("...");
その他、レイアウトに関する各種処理。
*}
*if (1 <; results.Count())*{
同じ名前のUIElementsが複数存在する(名前空間が違う等)場合の警告。

*if(yY <;= coord.y &amp;&amp; coord.y <;= Yy)
y ≦ cy ≦ay
方角を示すEnum
*public enum ArrowVector
4方向から進むに最適なタイルを算出
*private static TileBlock GetBestTile(TileBlock origin, int cost)
*if (up      != null &amp;&amp; up.      GetTileType() != TileType.Walkable &amp;&amp; up.GetTileType()      != TileType.GoalTile) up      = null;*if (bottom  != null &amp;&amp; bottom.  GetTileType() != TileType.Walkable &amp;&amp; bottom.GetTileType()  != TileType.GoalTile) bottom  = null;
ふるいにかける
*if (up      != null &amp;&amp; up.      GetAnalyzed())  up     = null;*if (bottom  != null &amp;&amp; bottom.  GetAnalyzed())  bottom = null;
どれかが前のoriginだったらやめる
*if (up      != null &amp;&amp; up.      GetTileType() == TileType.GoalTile) DrawLineCenterTileToTile(origin.GetCoordinate(), up.    GetCoordinate());*if (bottom  != null &amp;&amp; bottom.  GetTileType() == TileType.GoalTile) DrawLineCenterTileToTile(origin.GetCoordinate(), bottom.GetCoordinate());
どれかがゴールだったらそこまで線を描画
*if (up      != null)    up_hcost        = CalculateHeuristic(up.    GetCoordinate(), goalCoord);*if (bottom  != null)    bottom_hcost    = CalculateHeuristic(bottom.GetCoordinate(), goalCoord);
推定コストを計算
*if (up      != null)    up.     SetAnalyzeData(     cost,   up_hcost       );*if (bottom  != null)    bottom. SetAnalyzeData(     cost,   bottom_hcost   );
データをセット
*for(int m = 0; m <; 4; m++)*{
一番スコアの低いものを探す
*if (origin != null)*{
自身をClose
マップを探索
*public static async void AnalyzeMap()
各タイル座標に属性を付与
*SetTileAttributesToAll();

*private void Form1_Paint(object sencdr, PaintEventArgs e) {Graphics g = e.Graphics;// Properties内のResourcesからtestという画像を探すimg = Properties.Resources.test;// 変数名, 設置する座標X, 設置する座標Y, 画像の幅Width, 画像の高さHeight);g.DrawImage(img, 10, 10, 48, 48);}
変数定義
Properties内のResourcesからtestという画像を探す
*img = Properties.Resources.test;
変数名, 設置する座標X, 設置する座標Y, 画像の幅Width, 画像の高さHeight);
*g.DrawImage(img, 10, 10, 48, 48);

*_ =<; first,
EQ
× 自然な定義だけどこれは無限再帰して動かない
*T Fix<;T>;(Func<;T, T>; f)
○ 値を関数で包んで評価タイミングを調整可能にしたもの
*Func<;T>; Fix<;T>;(Func<;Func<;T>;, Func<;T>;>; f)
◎ さらにパラメータを任意の T に一般化した形
*Func<;T, TResult>; Fix<;T, TResult>;(Func<;Func<;T, TResult>;, Func<;T, TResult>;>; f)

ローカルストレージからトークンとユーザ名を取得
*var savedToken = await _localStorage.GetItemAsync<;string>;("authToken");
トークンのチェックを入れる場合ここで一度だけ実施
トークンが見つからい場合は未ログイン
*if (string.IsNullOrWhiteSpace(savedToken))
HTTPの認証用のトークンを設定
*_httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("bearer", savedToken);
*return new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity(new[] { new Claim(ClaimTypes.Name, userID) }, "apiauth")));
認証情報を返す
ローカルストレージに認証情報を保持して変更通知を行う
*await _localStorage.SetItemAsync("userID", userID);
ローカルストレージの認証情報を削除して変更通知を行う
*await _localStorage.RemoveItemAsync("userID");
3秒待機させて本当の応答のように見せる
*await Task.Delay(3000);
*{IsSuccessful = true,IDToken = firebaseResult.FirebaseToken};
トークンを取得
*{// 保存したロールを取得var roles = await _localStorage.GetItemAsync<;List<;string>;>;("roles");var claims = new List<;Claim>;();claims.Add(new Claim(ClaimTypes.Name, userID));foreach(var role in roles){claims.Add(new Claim(ClaimTypes.Role,role));}return new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity(claims, "User")));}
略
保存したロールを取得
*var roles = await _localStorage.GetItemAsync<;List<;string>;>;("roles");
*if (user.Identity.IsAuthenticated)*{
認証済みの場合

こんな感じで実装すれば実現できそう
*Action<;ApplicationTitleDescriptor>; cb = x =>; x.title = "なにかしらのエモいタイトル";
ApplicationTitleDescriptorのTypeを取得.
*Type tEditorApplication = typeof(EditorApplication);
関係するイベントとメソッドのInfoを取得.
*EventInfo eiUpdateMainWindowTitle = tEditorApplication.GetEvent("updateMainWindowTitle", BindingFlags.Static | BindingFlags.NonPublic);
Action&lt;object&gt;をAction&lt;ApplicationTitleDescriptor&gt;に変換.
*Type delegateType = typeof(Action<;>;).MakeGenericType(tApplicationTitleDescriptor);
*eiUpdateMainWindowTitle.GetAddMethod(true).Invoke(null, new object[] { del });
UpdateMainWindowTitleを呼び出す前後にイベントの追加/削除.
UnityEditor.ApplicationTitleDescriptor.title = "Solution1_Reflection"; と同様
*typeof(EditorApplication).Assembly.GetTypes()
(以下、たくさんのInternalsVisibleToが羅列されている)
*[assembly: InternalsVisibleTo("Unity.InternalAPIEditorBridgeDev.001")]
あらかじめMicrosoft.CodeAnalysis.CSharpをnugetでインストールしておく
*using Microsoft.CodeAnalysis;
C#プロジェクトを読み込みます.
*string[] csproj = File.ReadAllLines(inputCsProjPath);
dllとしてコンパイルさせるオプションを生成します.
*CSharpCompilationOptions compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
BindingFlags.IgnoreAccessibility(1 &lt;&lt; 22)を有効化します.
*typeof(CSharpCompilationOptions)
プロジェクトからアセンブリ参照一覧を取得→IEnumerable&lt;PortableExecutableReference&gt;に変換します.
*Regex reg_dll = new Regex("<;HintPath>;(.*)<;/HintPath>;", RegexOptions.Compiled);
プロジェクトからシンボル一覧を取得→IEnumerable&lt;string&gt;に変換します.
*Regex reg_preprocessorSymbols = new Regex("<;DefineConstants>;(.*)<;/DefineConstants>;", RegexOptions.Compiled);
プロジェクトからソースコード一覧を取得→テキストとして読み込み→IEnumerable&lt;SyntaxTree&gt;に変換します.
*CSharpParseOptions parserOption = new CSharpParseOptions(LanguageVersion.Latest,
コンパイルを実行し、dllを生成します.
*CSharpCompilation.Create(outputAsemblyName, syntaxTrees, metadataReferences, compilationOptions)

*if (vignette)
該当するパラメータがPostProcessVolumeに存在する場合のみ処理をする

*string path2;
out file name
Jpenの保存品質。小さいほど悪い
*int quality = 0;

XMLファイルを読込む
*c.IncludeXmlComments(GetXmlCommentsPath());
type=file設定は必須
*type = "file",
*if(!Request.Content.IsMimeMultipartContent())*{
multipart/form-data以外、サポート外のメディア種類(Http Status 415)を返す
multipart/form-dataを保存する場所を指定する
*var root = HttpContext.Current.Server.MapPath("~/App_Data");
データを読み取る
*await Request.Content.ReadAsMultipartAsync(provider);
ファイルに格納する
*var fileInfo = new FileInfo(file.LocalFileName);

シーンが破棄された故タイミングのリスナ.
*static void SceneUnLoadedListener(
ランタイムマネージャはこのタイミングで破棄.
*Instance.managerDic?.Clear();
シーン変更検知,Unityの仕様上beforeには何も入っていない,afterにロードされたシーンがある.
*static void ActiveSceneChangeListener(

*@"^s?https?:
[-_.!~*'()a-zA-Z0-9;?:@&amp;=+$,%#]+$"

*{// "OnoTest"という名前のルームに参加する（ルームが無ければ作成してから参加する）PhotonNetwork.JoinOrCreateRoom("OnoTest", new RoomOptions(), TypedLobby.Default);print("ルーム作成完了");}
マスターサーバーへの接続が成功した時に呼ばれるコールバック
"OnoTest"という名前のルームに参加する（ルームが無ければ作成してから参加する）
*PhotonNetwork.JoinOrCreateRoom("OnoTest", new RoomOptions(), TypedLobby.Default);
*{PhotonNetwork.Instantiate(生成したいPrefabの名前, 生成したい場所, 生成したい向き(角度));}
部屋に入ったらアバター生成
PhotonServerSettingsに設定した内容を使ってマスターサーバーへ接続する
*PhotonNetwork.ConnectUsingSettings();
*{// "OnoTest"という名前のルームに参加する（ルームが無ければ作成してから参加する）PhotonNetwork.JoinOrCreateRoom("OnoTest", new RoomOptions(), TypedLobby.Default);print("ルーム作成完了");}
マスターサーバーへの接続が成功した時に呼ばれるコールバック
"OnoTest"という名前のルームに参加する（ルームが無ければ作成してから参加する）
*PhotonNetwork.JoinOrCreateRoom("OnoTest", new RoomOptions(), TypedLobby.Default);
*{int othersCount = PhotonNetwork.PlayerListOthers.Length;PhotonNetwork.Instantiate(networkPlayer.name, playerPositions[othersCount].position, Quaternion.identity);cameraRig.position = playerPositions[othersCount].position;}
部屋に入ったらアバター生成
*avater_Face.transform.parent = cameraTransform;*avater_RightHand.transform.parent = rightHandTransform;
親子関係を設定し、ローカルの座標系の原点に移動
*foreach (Transform child in  avater_Face.GetComponent<;Transform>;())*{
自分のアバターのみLayerを変更して視界に映らないようにする

*void TestCase(int testNumber, string format, string expected) {// Actvar actual = guid.ToString(format);// AssertAssert.AreEqual(expected, actual, $"No.{testNumber}");}
Arrange
*var actual = guid.ToString(format);*// Assert
Act
*Assert.AreEqual(expected, actual, $"No.{testNumber}");
Assert
*TestCase(2, "B", expected: "{01234567-89ab-cdef-0123-456789abcdef}");
Test cases
*Assert.AreEqual(expectedExceptionType, exceptionType, $"No.{testNumber}");
Assert
*void TestCase(int testNumber, string format, string expected = default, Type expectedExceptionType = default) {TestAA.Act(() =>; guid.ToString(format)).Assert(expected, expectedExceptionType, message: $"No.{testNumber}");}
Arrange
*TestCase(2, "B", expected: "{01234567-89ab-cdef-0123-456789abcdef}");
Test cases

*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer
*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer
*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer

*public int ID { get; set; }
ID
*public bool DoneFlg { get; set; }
完了チェック
やること
*[DisplayName("やること")]
期日
*[DisplayName("期日")]
備考
*[DisplayName("備考")]
*{return View(db.MVCList.ToList());}
一覧画面の表示
一覧画面のチェックボックスの状態を登録
*[HttpPost]
*{return View();}
新規登録画面の表示
新規登録
*[HttpPost]
*{if (id == null){return new HttpStatusCodeResult(HttpStatusCode.BadRequest);}MVCList mVCList = db.MVCList.Find(id);if (mVCList == null){return HttpNotFound();}return View(mVCList);}
編集画面の表示
リストの内容の編集
*[HttpPost]
*{if (id == null){return new HttpStatusCodeResult(HttpStatusCode.BadRequest);}MVCList mVCList = db.MVCList.Find(id);if (mVCList == null){return HttpNotFound();}return View(mVCList);}
削除画面の表示
削除処理
*[HttpPost, ActionName("Delete")]

独自ストレージを使用する場合、FASTER.core.IDeviceを実装したインスタンスを代わりに生成する
ファイルパスのみ必須。
基本的に同じフォルダに複数ファイルを作る設計なので、複数のログファイルを扱いたい場合、別フォルダに分けるのが良い
*IDevice logDevice = Devices.CreateLogDevice("[格納するファイルのパス]");
*{LogDevice = logDevice};
LogDeviceのみ必須
処理
flインスタンスはプロセス内で使い回すこと
*}
ReadOnlySpan&lt;byte&gt;でも可
Enqueueの時点ではまだ永続化はされない
*long recordAddress = fl.Enqueue(data);
ここで返ってくるaddress値は、WaitForCommit系のAPIでuntilAddressとして使用する
コミットデータの永続化
*fl.Commit(true);
*{// enumeratorで走査}
fl.Scan([論理開始アドレス], [論理終端アドレス])という風にして指定する
enumeratorで走査
*}
*{// dataの型はbyte[]// lenはデータ長(bytes)// 2019.11.18では二つだけだが、最新ソースでは更に long currentAddress も追加になる模様// https://github.com/microsoft/FASTER/commit/bf657635374873958d96b31db1299b58ef9a17b1await foreach(var (data, len, currentAddress, nextAddress) in iter.GetAsyncEnumerable()){// データの参照}}
fl.Scan([論理開始アドレス], [論理終端アドレス])という風にして指定する
dataの型はbyte[]
lenはデータ長(bytes)
2019.11.18では二つだけだが、最新ソースでは更に long currentAddress も追加になる模様
https:github.com/microsoft/FASTER/commit/bf657635374873958d96b31db1299b58ef9a17b1
*await foreach(var (data, len, currentAddress, nextAddress) in iter.GetAsyncEnumerable())
データの参照
*}
*{// 終端ではnextAddressが-1になるwhile(iter.NextAddress >;= 0){await iter.WaitAsync();// データを取り出すまでループと待機を行う// 引数は、データ本体、データ長、現在のアドレスの三つwhile(iter.GetNext(out var entry, out var length, out var currentAddress, out var nextAddress)){// データの参照}}}
FasterLog fl;
*while(iter.NextAddress >;= 0)*{
終端ではnextAddressが-1になる
データを取り出すまでループと待機を行う
引数は、データ本体、データ長、現在のアドレスの三つ
*while(iter.GetNext(out var entry, out var length, out var currentAddress, out var nextAddress))
データの参照
*}
処理
*untilAddress = iter.NextAddress;
最後にCommitすると変更が反映される
*fl.Commit(true);
*if (File.Exists("logcommittest.log.0"))*{
ensure using cleared data
データを追加するタスク
*long logicalAddress = 0;
コミットする方のタスク
*int commitCount = 0;

呼び出すメソッド情報を取得
*MethodInfo methodInfo = typeof(Test).GetMethod(nameof(TargetMethod));
out引数を定義(MakeByRefTypeを使う)
*ParameterExpression valueArg = Expression.Parameter(typeof(int).MakeByRefType());
ExpressionTreeでdelegateを作成
*TestDelegate compiled = Expression.Lambda<;TestDelegate>;(
*Console.WriteLine($"intValue={intValue}");
呼び出して結果を出力

*foreach(var t in Tasks.Where(x =>; x.Name.StartsWith("Task1"))*{
"Task1"から始まるタスクのみ実行する
Task1の依存が重複した
*.IsDependentOn("Task1")
*{public string X;}
型の宣言
"IsRelease"が引数に来た場合に実行されるようにする
*Task("Task1")
*Information($"{entry.Category}");*// 所要時間
Task,Setup,Teardownのどれか
*Information($"{entry.Duration}");*// Executed, Delegated, Skippedのどれか
所要時間
*Information($"{entry.ExecutionStatus}");*// タスクの名前
Executed, Delegated, Skippedのどれか
*Information($"{entry.TaskName}");*}
タスクの名前

全体に返すか、聞いてきた人だけに返すかの設定
*public override bool IsBroadcast =>; false;
HelpCommandで使用される、このコマンドの説明
*public override (string, string) DefaultCommandAndHelpMessage =>; ("date", "日にちと曜日を表示");
どういう日本語に、どれぐらいの優先度で引っ掛けたいか。
ほかのコマンドで同じ単語で引っかかった場合、優先度順に選ばれる。
*RegisterKeyword(CommandPriority.Low, "何日");
実際に頑張って結果を返す部分。
DefaultCommandまたはRegisterKeywordで選ばれたときしか呼ばれない。
*public override ValueTask<;string>; CreateOutputAsync(string user, string channel, string filteredKeyword, string rawWords)

*float distance = Mathf.Abs(Vector2.Distance(mousePos, prevMousePos));
マウスの移動した距離

*private EnumSample() {}
外部からのインスタンス生成不可
*private EnumSample2( int num ) {Num = num;// 重複チェックを入れるとしたらこの辺でやる// Dictionaryに詰めていってContainsKeyでチェックするのが楽そう}
外部からのインスタンス生成不可
重複チェックを入れるとしたらこの辺でやる
Dictionaryに詰めていってContainsKeyでチェックするのが楽そう
*}
*public interface IDropItem {string Name { get; }int Price { get; }string Description { get; }}
ドロップアイテムのインタフェース
*public abstract class Weapon : IDropItem {public static Weapon Sword = new WeaponSword();private class WeaponSword : Weapon {// コンストラクタがpublicでもクラス自体はprivateなので外部からはインスタンス生成不可public WeaponSword() {}public override string Name { get { return "剣"; } }public override int Price { get { return 100; } }public override string Description { get { return "いい感じの説明"; } }public override void Attack() {base.Slash();}}public static Weapon Spear = new WeaponSpear();private class WeaponSpear : Weapon {public WeaponSpear() {}public override string Name { get { return "槍"; } }public override int Price { get { return 50; } }public override string Description { get { return "そんな感じの説明"; } }public override void Attack() {base.Pierce();}}public static Weapon Club = new WeaponClub();private class WeaponClub : Weapon {public WeaponClub() {}public override string Name { get { return "棍棒"; } }public override int Price { get { return 10; } }public override string Description { get { return "とてもアレな説明"; } }// Attack()の実装は省略可能}protected Weapon() {}// 名前、価格、説明は必ず列挙子で定義するpublic abstract string Name { get; }public abstract int Price { get; }public abstract string Description { get; }// 攻撃処理の実装は省略可能public virtual void Attack() {// オーバーライドしない場合はデフォルトとして殴る処理Strike();}// protectedで宣言したプロパティやメソッドは列挙子側からアクセスできるprotected void Slash() {// 切る武器の処理}protected void Pierce() {// 刺す武器の処理}protected void Strike() {// 殴る武器の処理}}
ドロップアイテムとして扱える武器の列挙型
*public WeaponSword() {}
コンストラクタがpublicでもクラス自体はprivateなので外部からはインスタンス生成不可
*protected Weapon() {}
Attack()の実装は省略可能
*public abstract string Name { get; }
名前、価格、説明は必ず列挙子で定義する
*public virtual void Attack() {// オーバーライドしない場合はデフォルトとして殴る処理Strike();}
攻撃処理の実装は省略可能
オーバーライドしない場合はデフォルトとして殴る処理
*Strike();
*protected void Slash() {// 切る武器の処理}
protectedで宣言したプロパティやメソッドは列挙子側からアクセスできる
*protected void Pierce() {// 刺す武器の処理}
切る武器の処理
*protected void Strike() {// 殴る武器の処理}
刺す武器の処理
殴る武器の処理
*}

*if (!dictionary.TryGetValue(key, out var result)) return false;*// 型が一致しない場合はNG
キーがないならNG
型が一致しない場合はNG
*return IsTypeMatch(result.GetType(), value.GetType());
項目名称の取得
*var tables = worksheet.RangeUsed().AsTable();
生成開始
*var generator = new DataRecordGenerator(columnNames, values);
数値に関してはClosedXMLの読み取るとdoubleで取得される
*result[0].Age = (double)50;

*Action close = () =<; writer.Dispose();
閉じる。

CurrentUICulture の変更。
*System.Threading.Thread.CurrentThread.CurrentUICulture = new System.Globalization.CultureInfo("en-GB");

*for(var i = 1; i <;= 8; i++)*{
方向
*for(var j = 7; j >;= 2; j--)*{
石の数
*if (!CheckRangeValid(Row + j * RowDirection, Col + j * ColDirection) ||*!CheckReverse(Row, Col, Info, i, j)) continue;
ひとつでも変更があればturnChangeFlgをtrueにする。
*for(var k = 1; k <; j; k++)*{
チェックが通ったものの場合j - 1個ひっくり返す。
*for(var i = 1; i <;= 8; i++)*{
方向
*for(var j = 7; j >;= 2; j--)*{
石の数
*if (!CheckRangeValid(Row + j * RowDirection, Col + j * ColDirection) ||*!CheckReverse(Row, Col, Info, i, j)) continue;
ひとつでも変更があればturnChangeFlgをtrueにする。
*for(var k = 1; k <; j; k++)*{
チェックが通ったものの場合j - 1個ひっくり返す。

*public int K { get; private set; }
セキュリティパラメータ（バイト数）
デバッグ以外ならprivateに設定
*public BigInteger p;
*{get =>; (this.p, this.g, this.y);set{this.p = value.p;this.g = value.g;this.y = value.y;}}
公開鍵
秘密鍵
デバッグ以外ならprivateに設定
*public BigInteger Sk
*{p = GenerateRandomPrime(k);Console.WriteLine("ランダムな素数p = {0}", p);g = GenerateGroupGen(k, p);Console.WriteLine("原始元g = {0}", g);x = GenerateRandom(k, 0, p - 2);Console.WriteLine("ランダムな非負整数x = {0}", x);y = BigInteger.ModPow(g, x, p);Console.WriteLine("y = g^x mod p = {0}", y);}
鍵を生成する
*{for (int g = 2; ; g++){bool isGen = true;BigInteger a = 1;for (int i = 1; i <;= p - 2; i++){a *= g;if (a >;= p) a %= p;if (a == 1){isGen = false;break;}}if (isGen){return g;}}}
原始元を生成する
*{var r = GenerateRandom(K, 0, p - 2);Console.WriteLine("ランダムな数r = {0}", r);var c1 = BigInteger.ModPow(g, r, p);var c2 = (m * BigInteger.ModPow(y, r, p)) % p;return (c1, c2);}
暗号化する
*{return (c.c2 * BigInteger.ModPow(c.c1, p - 1 - x, p)) % p;}
復号する

*static readonly Uri BaseURL = new Uri("https:
api.openweathermap.org");

*else
多分ここから先はきちんと動くか分からないので、先に必ずSetUp関数を終了させておく方がよい
return LoadSprite(assetName);再帰的な処理をしたいがどうなるか分からないので呼び出し下でやりたい
*}

*{[Route("")]public class TopController : Controller{private FruitSqlService service = new FruitSqlService();[Route("")]public IActionResult Index(){ViewBag.list = service.All();return View();}[Route("/add")]public IActionResult Add(){return View();}[HttpPost][Route("/add")]public IActionResult AddPost(int Id, string Name, int Number, int Price){var fruit = new Fruit();fruit.Id = Id;fruit.Name = Name;fruit.Number = Number;fruit.Price = Price;service.INSERT(fruit);TempData.Add("result", "追加に成功しました。");return Redirect("/");}[HttpPost][Route("/delete")]public IActionResult DeletePost(int Id){service.DELETE(Id);TempData.Add("result", "削除に成功しました。");return Redirect("/");}[Route("/show/{id}")]public IActionResult Show(int Id){var fruit = service.FindById(Id);return View(fruit);}[HttpPost][Route("/update")]public IActionResult Update(int Id, string Name, int Number, int Price){var fruit = new Fruit();fruit.Id = Id;fruit.Name = Name;fruit.Number = Number;fruit.Price = Price;service.UPDATE(fruit);TempData.Add("result", "更新に成功しました。");return Redirect("/");}}}
For more information on enabling MVC for empty projects, visit https:go.microsoft.com/fwlink/?LinkID=397860

セルの上に引く
*cellStyle.BorderTop = NPOI.SS.UserModel.BorderStyle.Thin;
セルの下に引く
*cellStyle.BorderBottom = NPOI.SS.UserModel.BorderStyle.Thin;
セルの左に引く
*cellStyle.BorderLeft = NPOI.SS.UserModel.BorderStyle.Thin;
セルの右に引く
*cellStyle.BorderRight = NPOI.SS.UserModel.BorderStyle.Thin;
セルの斜めに引く
*cellStyle.BorderDiagonal = NPOI.SS.UserModel.BorderDiagonal.Forward;
セルのスタイルを保存
*cell.CellStyle = cellStyle;
*{book.Write(fs);}
ブックを保存

*{try{using (var reader = new StreamReader(File, Encoding.GetEncoding(EncodingName)))using (var csv = new CsvReader(reader)){csv.Configuration.HasHeaderRecord = HasHeaderRecord;csv.Configuration.RegisterClassMap<;CSV_Format_Mapper>;();return csv.GetRecords<;CSV_Format>;();}}catch (Exception ex){//..例外処理..}}
File,Encoding,HasHeaderRecordはどっかで設定
..例外処理..
*}
*{try{using (var reader = new StreamReader(File, Encoding.GetEncoding(EncodingName)))using (var csv = new CsvReader(reader)){csv.Configuration.HasHeaderRecord = HasHeaderRecord;//csv.Configuration.RegisterClassMap<;CSV_Format_Mapper>;(); //いらなくなったreturn csv.GetRecords<;T>;();}}catch (Exception ex){//..例外処理..}}
File,Encoding,HasHeaderRecordはどっかで設定
csv.Configuration.RegisterClassMap&lt;CSV_Format_Mapper&gt;(); いらなくなった
*return csv.GetRecords<;T>;();
..例外処理..
*}

*IMessage message = new SampleMessage();
データの用意は省略
名前を指定してDescriptorを取得する
*OneofDescriptor oneofField = message.Descriptor.FindDescriptor<;OneofDescriptor>;("oneof_field");
*foreatch (var oneofDescriptor in message.Descriptor.Oneofs)*{
全てのOneofを列挙する
*foreach (var field in oneofDescriptor.Fields)*{
そのOneofに宣言されているフィールドを列挙する
フィールド個別の処理...
*}
SampleMessage.oneof_fieldの場合
*IMessage message = new SampleMessage();
現在のOneofの値を取得する
*var currentOneof = oneofField.Accessor.GetCaseFieldDescriptor(message);
新しくOneofの値にexternal_messageを設定する ※MessageDescriptorからもOneofに属しているフィールドが取得できる
*var externalMessageField = message.Descriptor.FindFieldByName("external_message");
*{// フィールドの処理foreach (var field in message.Descriptor.Fields.InDeclarationOrder()){if (field.ContainingOneof != null){continue;}// Oneofに含まれない通常のフィールドの処理}// Oneofの処理foreach (var oneof in message.Descriptor.Oneofs){foreach (var field in oneof.Fields){// Oneofに含まれるフィールドの処理}}}
メッセージに対する何かしらの処理を行う関数
*foreach (var field in message.Descriptor.Fields.InDeclarationOrder())*{
フィールドの処理
Oneofに含まれない通常のフィールドの処理
*}
*foreach (var oneof in message.Descriptor.Oneofs)*{
Oneofの処理
Oneofに含まれるフィールドの処理
*}

*{// セーブデータ作成SavePlayerData player = CreateSavePlayerData();// バイナリ形式でシリアル化BinaryFormatter bf = new BinaryFormatter();// 指定したパスにファイルを作成FileStream file = File.Create(SaveFilePath);// Closeが確実に呼ばれるように例外処理を用いるtry{// 指定したオブジェクトを上で作成したストリームにシリアル化するbf.Serialize(file, player);}finally{// ファイル操作には明示的な破棄が必要です。Closeを忘れないように。if (file != null)file.Close();}}
----- 一部抜粋 -----
セーブデータ作成
*SavePlayerData player = CreateSavePlayerData();
バイナリ形式でシリアル化
*BinaryFormatter bf = new BinaryFormatter();
指定したパスにファイルを作成
*FileStream file = File.Create(SaveFilePath);
*{// 指定したオブジェクトを上で作成したストリームにシリアル化するbf.Serialize(file, player);}
Closeが確実に呼ばれるように例外処理を用いる
指定したオブジェクトを上で作成したストリームにシリアル化する
*bf.Serialize(file, player);
*if (file != null)*file.Close();
ファイル操作には明示的な破棄が必要です。Closeを忘れないように。
*{SavePlayerData player = new SavePlayerData();player.name = nameInput.text;player.age = int.Parse(ageDropdown.options[ageDropdown.value].text);player.color = colorDropdown.options[colorDropdown.value].text;return player;}
入力された情報をもとにセーブデータを作成
----- 一部抜粋 -----
*}
*{if (File.Exists(SaveFilePath)){// バイナリ形式でデシリアライズBinaryFormatter bf = new BinaryFormatter();// 指定したパスのファイルストリームを開くFileStream file = File.Open(SaveFilePath, FileMode.Open);try{// 指定したファイルストリームをオブジェクトにデシリアライズ。SavePlayerData player = (SavePlayerData)bf.Deserialize(file);// 読み込んだデータを反映。var playerObject = Instantiate(playerPrefab) as GameObject;playerObject.GetComponent<;PlayerController>;().Init(player.name, player.age, player.color);}finally{// ファイル操作には明示的な破棄が必要です。Closeを忘れないように。if (file != null)file.Close();}}else{Debug.Log("no load file");}}
----- 一部抜粋 -----
バイナリ形式でデシリアライズ
*BinaryFormatter bf = new BinaryFormatter();
指定したパスのファイルストリームを開く
*FileStream file = File.Open(SaveFilePath, FileMode.Open);
指定したファイルストリームをオブジェクトにデシリアライズ。
*SavePlayerData player = (SavePlayerData)bf.Deserialize(file);
読み込んだデータを反映。
*var playerObject = Instantiate(playerPrefab) as GameObject;
*if (file != null)*file.Close();
ファイル操作には明示的な破棄が必要です。Closeを忘れないように。
----- 一部抜粋 -----
*}

ターゲットへのベクトル
*Vector3 vTgt = target.position - player.position;
ターゲットへのベクトルを前方とするクォータニオン
第二引数はワールド空間的な上（Vector3.up）でいいので省略
*Quaternion qTgt = Quaternion.LookRotation(vTgt);
ずらすべき位置ベクトル
ずらしたい量をここでは後方5、高さ2とした場合
*Vector3 vOfs = qTgt * new Vector3(0f, 2f, -5f);
最終的なカメラ位置（ワールド座標）
*Vector3 cameraPosition = player.position + vOfs;
ターゲットへの向き
*Quaternion cameraRotation = Quaternion.LookRotation(target.position - cameraPosition);
ターゲットへのベクトル
*Vector3 targetVector = _lookTargetPosition - _attachTarget.position;
*Quaternion targetRotation = targetVector != Vector3.zero ? Quaternion.LookRotation(targetVector) : transform.rotation;*// 位置と向き
ターゲットへのベクトルを前方とするクォータニオン
位置と向き
*Vector3 position = _attachTarget.position + targetRotation * _attachOffset;
*if (_timer <; _changeDuration)*{
現在の注視点を更新
ターゲットへのベクトル
*Vector3 targetVector = _lookTargetPosition - _attachTarget.position;
*Quaternion targetRotation = targetVector != Vector3.zero ? Quaternion.LookRotation(targetVector) : transform.rotation;*// 位置と向き
ターゲットへのベクトルを前方とするクォータニオン
位置と向き
*Vector3 position = _attachTarget.position + targetRotation * _attachOffset;

*var file1 = dir2.CombineWithFilePath("d.txt");
abcd.txt
aというフォルダの拡張子".txt"というファイルを全て列挙する
*var files = GetFiles("a/**/*.txt");
引数付きのコマンドを実行する場合
*var args = new ProcessArgumentBuilder()
パスはcakeファイルからの相対パス
*DotNetCoreClean("./sampleproject/sampleproject.csproj");
a/b/c.txt, a/d.txtというファイルがフォルダに存在する場合、
b/c.txt, d.txtというファイルがoutput.zipファイルに圧縮される
*Zip(DirectoryPath.FromString("a"), "output.zip");

*ILogger logger = LogManager.GetCurrentClassLogger();
例えばNLogに出力

*[TestCase("https:
qiita.comnariakiraHaraitemsf1b4d091ed447a283d8d", "title", "業務で使用したC#の便利ライブラリ - Qiita")]
先程の画像のExcel Data.xlsxを読み込む
*private static readonly string DATA_PATH = @"resources/Data.xlsx";
*for(var j = 0; j <; tbl.Rows.Count; j++) {*if (j == 0) continue;
1行ずつ見ていく
*for(var i=0; i<;tbl.Columns.Count; i++) {*Console.Write($"{tbl.Rows[j][i]} ");
1カラムずつ見ていきます
*using(var stream = File.Open(path, FileMode.Open, FileAccess.Read)) {using(var reader = ExcelReaderFactory.CreateReader(stream)) {ds = reader.AsDataSet();}}
ファイルパスからExcelを読み込む

...省略...
*[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
...省略...
*FixedLengthCharArray32 szDevice;

*break;
置いたら抜ける

*ExtraModuleNames.AddRange( new string[] { "TestModuleEd" } );
←ここを追加

*private void LoadCsv(string csvPath){// TextFieldParserでCSVを読み込みTextFieldParser parser = new TextFieldParser(csvPath, Encoding.GetEncoding("shift_jis"));parser.TextFieldType = FieldType.Delimited;parser.SetDelimiters(",");while (parser.EndOfData == false) {string[] datas = parser.ReadFields();int cols = datas.length;// 列数が不正だったら終了if(cols != 4){return;}// A列処理if(string.IsNullOrEmpty(datas[0])){// ...略}// B列処理if(string.IsNullOrEmpty(datas[1])){// ...略}// C列処理if(string.IsNullOrEmpty(datas[2])){// ...略}// D列処理if(string.IsNullOrEmpty(datas[3])){// ...略}// 取得したデータをDBに書き込んだり...// その結果を画面に表示させたり...}}
...略
*TextFieldParser parser = new TextFieldParser(csvPath, Encoding.GetEncoding("shift_jis"));*parser.TextFieldType = FieldType.Delimited;
TextFieldParserでCSVを読み込み
*if(cols != 4){*return;
列数が不正だったら終了
*if(string.IsNullOrEmpty(datas[0])){*// ...略
A列処理
...略
*}
*if(string.IsNullOrEmpty(datas[1])){*// ...略
B列処理
...略
*}
*if(string.IsNullOrEmpty(datas[2])){*// ...略
C列処理
...略
*}
*if(string.IsNullOrEmpty(datas[3])){*// ...略
D列処理
...略
*}
取得したデータをDBに書き込んだり...
その結果を画面に表示させたり...
*}
*{// A列ColA = 0,// B列ColB = 1,// Bα列ColBalpha = 2,// C列ColC = 3,// D列ColD = 4}
列のインデックス定義
A列
*ColA = 0,
B列
*ColB = 1,
Bα列
*ColBalpha = 2,
C列
*ColC = 3,
D列
*ColD = 4
列数
*private static int CSV_COLS = Enum.GetNames(typeof(CsvCols)).Length;
*//if(cols != 4){*//    return;
列数が不正だったら終了(修正前)
*if(cols != CSV_COLS){return;}
}
*if(cols != CSV_COLS){*return;
列数が不正だったら終了(修正後)
*//if(string.IsNullOrEmpty(datas[0])){*//    // ...略
A列処理(修正前)
...略
}
A列処理(修正後)
*if(string.IsNullOrEmpty(datas[(int)CsvCols.ColA])){
...略
*}

*var globals = new Globals { foo = foo, bar = bar };
匿名型にしたいけれど、アクセスできないのでこうしてます

計測開始
*sw.Start();
クラスの型取得
*Type cType = Type.GetType("UI_Module.TestFunc");
クラスのメソッド取得
*MethodInfo m = cType.GetMethod("Func1");
インスタンス化
*object obj = Activator.CreateInstance(cType);
メソッド実行
*m.Invoke(obj, null);
計測終了
*sw.Stop();
結果表示
*var ts = sw.Elapsed;
計測開始
*sw.Start();
クラスの型取得
*Type cType = Type.GetType("UI_Module.TestFunc");
クラスのメソッド取得
*m = cType.GetMethod("Func1");
インスタンス化
*obj = Activator.CreateInstance(cType);
メソッド実行
*m.Invoke(obj, null);
計測終了
*sw.Stop();
結果表示
*var ts = sw.Elapsed;

*titleElementBy = By.XPath($"
*GroupText[@Name=\"{title}\"]");
タイトルの読み上げ
*new Actions(driver)
ダイアログ内をクリックしてアクティブにする
*.Click(titleElement)
タイトル欄の左上端まで移動
*.MoveToElement(whenElement, 0, -50)
ドラッグを開始し
*.ClickAndHold()
タイトル欄の右端で
*.MoveByOffset(titleElement.Size.Width + 10, titleElement.Size.Height - 20)
ドロップして
*.Release()
コンテキストメニューを開き
*.ContextClick()
音声読み上げのショートカットキー "U" を送る
*.SendKeys("U")
*{// 「選択部分を音声で読み上げる」の終了を待つvar readAloudBy = By.XPath("//*/Document[@Name=\"音声で読み上げる\"]");new WebDriverWait(driver, TimeSpan.FromSeconds(10)).Until(d =>; !d.FindElements(readAloudBy).Any());}
読み上げ終了待機
「選択部分を音声で読み上げる」の終了を待つ
var readAloudBy = By.XPath("*/Document[@Name=\"音声で読み上げる\"]");
*new WebDriverWait(driver, TimeSpan.FromSeconds(10))
「ここから音声で読み上げる」になっていた場合、強制的に打ち切る
var readAloudCloseButton = driver.FindElement(By.XPath("*/ToolBar[@Name=\"音声で読み上げる\"]/Group/Group/Button[@Name=\"閉じる\"]"));
*readAloudCloseButton.Click();
タイトル要素を再取得
*titleElement = (WindowsElement)dialog.FindElement(titleElementBy);
以降のショートカットを効かせるためにフォーカスを戻す
*titleElement.Click();
イベントダイアログを閉じる
*titleElement.SendKeys(Keys.Escape);

サーバーから受け取ったintへのプロパティ。読み取り専用
*public int SomeCount =>; someCount;
サーバーから受け取ったstringをenumに変換
*public SomeTypes SomeType;
*{get{...}}
データを元に判定を行ったりするプロパティ
*{......}
データ検索などを行うメソッド
文字列をenumに変換
*Enum.TryParse(someType, out SomeType);
サーバーから受け取るjsonをデシリアライズするためのクラス
半自動生成
*[Serializable]
*{// 画面遷移システム[Inject]private SceneLoader _sceneLoader;// View[SerializeField]private Text _text;// サブコントローラー[SerializeField]private SomeSubController _subController;// 画面遷移トゥイーン// インスペクタでリストにトゥイーンを登録するコンポーネントです[SerializeField]private Tweens _tweens;// 初期化private void Start(){_text.text = "";}// 画面遷移システムから画面開始時に呼び出される独自のコールバックです// IAdditiveSceneTaskを実装すると呼ばれますpublic async Task Activate(){/* 画面開始時の処理 */// 通信var someData = await WebRequest.Factory.SomeInfo(param).Send();// データをUIにセット_text.text = someData.name;// サブコントローラーの実行_subController.Execute();// UI出現アニメーションawait _tweens.PlayInAnimations();}public async Task Inactivate(){/* 画面終了時の処理 */// UIを消すアニメーションawait _tweens.PlayOutAnimations();// 各種アンロード}private void OnDestroy(){// 後処理}// ボタンが押されたときの処理// インスペクタでButtonコンポーネントから呼び出すように設定しますpublic void OnClickButton(){// 例でバトルトップ画面に遷移// 画面はシーンをAdditiveロードする仕組み// 次シーンをロードしてActivate()を呼び出し、現在シーンのInactivateを呼び出します_sceneLoader.LoadSceneAdditive(ScenesEnum.BattleTop, false);}}
画面のメインコントローラー
画面遷移システム
*[Inject]
サブコントローラー
*[SerializeField]
画面遷移トゥイーン
インスペクタでリストにトゥイーンを登録するコンポーネントです
*[SerializeField]
*{_text.text = "";}
初期化
画面遷移システムから画面開始時に呼び出される独自のコールバックです
IAdditiveSceneTaskを実装すると呼ばれます
*public async Task Activate()
通信
*var someData = await WebRequest.Factory.SomeInfo(param).Send();
データをUIにセット
*_text.text = someData.name;
サブコントローラーの実行
*_subController.Execute();
UI出現アニメーション
*await _tweens.PlayInAnimations();
UIを消すアニメーション
*await _tweens.PlayOutAnimations();
各種アンロード
*}
後処理
*}
ボタンが押されたときの処理
インスペクタでButtonコンポーネントから呼び出すように設定します
*public void OnClickButton()
例でバトルトップ画面に遷移
画面はシーンをAdditiveロードする仕組み
次シーンをロードしてActivate()を呼び出し、現在シーンのInactivateを呼び出します
*_sceneLoader.LoadSceneAdditive(ScenesEnum.BattleTop, false);
画面遷移のためのクラス
*[Inject]
シーンをAdditiveロード
*_sceneLoader.LoadSceneAdditive(
ダイアログ開く
*var dialog = await DialogLoader.Load<;SomeDialog>;();
ボタンが押されて閉じられるまで待つ
*bool isOk = dialog.WaitClose();
OKが押されたときの処理
*}
ダイアログ共通処理コンポーネント
*[SerializeField]
OKボタンを押した？
*private bool _isOk = false;
初期化
開く処理はDialogCommonによって自動的に行われます
*}
引数を使った処理
*}
*{_isOk = true;_common.Close();}
OKボタンを押した
*{_common.Close();}
キャンセルボタンを押した
ボタンが押されてダイアログが閉じるまで待つ
選択結果を返す
*public async Task<;bool>; WaitClose()
通信エラー時
*}
サーバーからデータ受信したときの処理
例. マッチングしたプレイヤーの情報を表示、チャットメッセージを表示
*});
アセットバンドルロードシステム
*[Inject]

事前に生成された単一インスタンスを返す
*instance = _instanceDict[type] as T;
インスタンスを生成して返す
*instance = Activator.CreateInstance(_typeDict[type]) as T;
正式な処理
*}
デバッグ用の処理
*}
この変数を切り替えることで生成するインスタンス切り替えます
単純化のためクラス内の#defineで定義しています
実際にはScripting Define Symbolsや設定ファイルを読み込んだりして切り替えます
*bool useDebugSystem;
正式な処理を行うインスタンスを登録
*Locator.Register<;ISomeSystem>;(new SomeSystem());
デバッグ用処理を行うインスタンスを登録
*Locator.Register<;ISomeSystem>;(new DebugSomeSystem());
システムの型を指定して登録されているインスタンスをServiceLocatorから取得
*var system = Locator.Resolve<;ISomeSystem>;();
newの場合
*var system2 = new SomeSystem();
staticの場合
*SomeSystem.SomeMethod();
シングルトンの場合
*SomeSystem.Instance.SomeMethod();

*obj = rect;
パースした結果はobjに格納する。

右クリックはcontextmenuを表示させるので、ここでは何もしない
*}

*if(length == 4 &amp;&amp; (str[start]=='t' || str[start]=='T')){*//true
true, false, nullなどのタイプをチェック
ms_digitsに入ったらindex返す
*int numIdx = GetNumberFromChar(nextChar);
*if(numIdx <; 0){ isNumber = false; break;}*// hogehoge
数字じゃないならやめる
１個ずつの数字を追加していく
num = (num*10)+numIdx 的な感じ
マイナス、少点数などの対応も忘れずに
*}
*if(isNumber)*return new JSONObject(number);
数字を返す
結局stringかオブジェクトだったらsubstringしちゃうかー
*return new JSONObject(str.Substring(start, length));

*{v.AddTransient<;IA>;(v =>; new A1());});
...

*[Command("Sample Command 01")]
引数にMonKey上のコマンド名を指定する
*foreach (var selectedGameObject in MonkeyEditorUtils.OrderedSelectedGameObjects)*{
OrderedSelectedGameObjectsから選択中のGameObjectを列挙できる。
親のGameObjectの名前を手前に連結していく。
*var pathBuilder = new System.Text.StringBuilder(selectedGameObject.name);

*Debug.WriteLine(code)
=&gt; Success

検証を実施して結果を取得
*bool isValid = editContext.Validate();
*//messages.AddRange(fieldIdentifier, validationResults.Errors.Select(error =>; error.ErrorMessage));*messages.Add(fieldIdentifier, validationResults.Errors.Select(error =>; error.ErrorMessage));
APIの仕様変更のため、Addに変更
*messages.Add(fieldIdentifier, validationResults.Errors.Select(error =>; error.ErrorMessage));*editContext.NotifyValidationStateChanged();
messages.AddRange(fieldIdentifier, validationResults.Errors.Select(error =&gt; error.ErrorMessage));

*{if (Input.GetKey(KeyCode.M)){if (SceneController.AlreadyLoadScene("Title")){SceneManager.UnloadSceneAsync("Title");}SceneManager.LoadScene("Main", LoadSceneMode.Additive);}}
Update is called once per frame

*count++;
腹筋カウント

*var decrypted = connector.SendPost($"https:
{メッセージ受信側HTTPサーバのIP:Port}rsaremote", encrypted).Result;
*Console.WriteLine($"Decrypted\r\n{decrypted}\r\n");
サーバで復号した結果を表示
PEMフォーマットの公開鍵を読み込んで KeyParam を生成
*var publicKeyReader = new PemReader(new StringReader(publickey));
RSA暗号オブジェクトを初期化（第１引数 true は「暗号化」を示す）
*rsa.Init(true, publicKeyParam);
対象のバイト列を渡し暗号化した結果のバイト列を受け取る
*byte[] encrypted = rsa.ProcessBlock(bytes, 0, bytes.Length);

インスタンス作成
*HtmlParser parser = new HtmlParser();
HTMLの文字列を分解します。
*IHtmlDocument doc = parser.ParseDocument(HTMLtext);
HTML内の&lt;div class="articles"&gt;抜き出したいところ&lt;/div&gt;
divは入れ子になっており同名のタグが大量にありますがインデントを目安にすると
抜き取りたいデータが上記タグ内にすべて収まっていることが分かります。
*var Nodes = doc.GetElementsByClassName("articles");
ここから分岐してdateNodes,bodyNodesにはそれぞれ違う絞り込みをかけます。
今回のHTMLにarticleクラスは1つしか存在しないためNodesの先頭Nodes[0]を参照します。
(取り出した要素が1つでもコレクションになるため必ず[index]が必要です)
*var dateNodes = Nodes[0].GetElementsByClassName("date");
これはのちのuser（ログインしているユーザー名）を探しています。
*string username = Nodes[0].GetElementsByClassName("user")[0].TextContent.Trim('『').Trim('』');
dateNodesの中身抜出し（TextContentはstring型の戻り値なのでTrimが使える）
*var datelist = new List<;string>;();
bodyNodesの中身抜出し＆正規表現で『』や()の間の文字列を取り出す。
*int Counter = 0;
ソートディクショナリを宣言して名前順（Key順）にソート
*var dic = new SortedDictionary<;string, string>;();
先頭にユーザーネームとデータを挿入。
*mylist.Add(username + "," + dic[username]);
*foreach (var t in dic)*{
ユーザー以外は名前順で並び替えて挿入。
並び替え後のリスト作成
*bodylist.Add(datelist[Counter] + "," + string.Join(",", mylist));
*if (DataCount <; Counter)*break;
Counterが指定のデータ数に到達したらループを抜ける

*{id = instances.Count;instances.Add(this);}
共通部分

*new object[] {"https:
yahoo.co.jp", 200},

文字列の入力
*string s = Console.ReadLine();
整数の入力
*long n = long.Parse(Console.ReadLine());
文字列配列の入力
*string[] inputStrArray = Console.ReadLine().Split(' ');
整数配列の入力
*long[] inputLongArray = Console.ReadLine().Split(' ').Select(i =>; long.Parse(i)).ToArray();

*engine.RecognizeAsync(RecognizeMode.Multiple);
開始

*{services.AddRazorPages();services.AddDbContext<;RazorPagesMovieContext>;(options =>;options.UseSqlite(Configuration.GetConnectionString("MovieContext")));}
This method gets called by the runtime. Use this method to add services to the container.
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseExceptionHandler("/Error");// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.app.UseHsts();}app.UseHttpsRedirection();app.UseStaticFiles();app.UseRouting();app.UseAuthorization();app.UseEndpoints(endpoints =>;{endpoints.MapRazorPages();});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*target.transform.rotation = rot * target.transform.rotation;
左から掛ける

Injectメソッドで準備された中間要素を受けっとってUseCaseを生成
*[Inject]
*public class BMISceneInstaller : MainInstallerBase {// inspectorからアタッチする[SerializeField] SharedScriptableObject sharedData = default;[SerializeField] BMIView bmiView = default;[SerializeField] HistoryView historyView = default;[SerializeField] HistoryElmView historyElmView = default;[SerializeField] AccountView accountView = default;// シーンの最初に呼ばれる。DIを行う。public override void InstallBindings() {base.InstallBindings();var dataStore = new PlayerPrefsHistoryDataStore(sharedData.CurrentUserId)as IHistoryDataStore;Container.Bind<;IHistoryListPresenter>;().FromInstance(new HistoryListPresenter(historyView, historyElmView)).AsCached().IfNotBound();Container.Bind<;IBMIHistoryRepository>;().FromInstance(new BMIHistoryRepository(dataStore)).AsCached().IfNotBound();Container.Bind<;IBMIPresenter>;().FromInstance(new BMIPresenter(bmiView)).AsCached().IfNotBound();Container.Bind<;IUserAccountRepository>;().FromInstance(new UserAccountRepository(sharedData)).AsCached().IfNotBound();Container.Bind<;IAccountPresenter>;().FromInstance(new AccountPresenter(accountView)).AsCached().IfNotBound();}}
MainInstallerBaseは後で説明します
inspectorからアタッチする
*[SerializeField] SharedScriptableObject sharedData = default;
*public override void InstallBindings() {base.InstallBindings();var dataStore = new PlayerPrefsHistoryDataStore(sharedData.CurrentUserId)as IHistoryDataStore;Container.Bind<;IHistoryListPresenter>;().FromInstance(new HistoryListPresenter(historyView, historyElmView)).AsCached().IfNotBound();Container.Bind<;IBMIHistoryRepository>;().FromInstance(new BMIHistoryRepository(dataStore)).AsCached().IfNotBound();Container.Bind<;IBMIPresenter>;().FromInstance(new BMIPresenter(bmiView)).AsCached().IfNotBound();Container.Bind<;IUserAccountRepository>;().FromInstance(new UserAccountRepository(sharedData)).AsCached().IfNotBound();Container.Bind<;IAccountPresenter>;().FromInstance(new AccountPresenter(accountView)).AsCached().IfNotBound();}
シーンの最初に呼ばれる。DIを行う。
*var canvas = GameObject.Find("Canvas").transform;*bmiView = canvas.Find("BMIView").GetComponent;BMIView>;();
find
最初は未入力
*Assert.IsEmpty(bmiView.NameInput.text);
名前/身長/体重を入力すると[保存]が押せるようになる
*bmiView.NameInput.onEndEdit.Invoke("test_name");
計算されたBMIと評価が表示される
*Assert.That(bmiView.BMIText.text, Is.EqualTo("37.0(肥満)"));
[保存]を押すとリストに追加される
*bmiView.SaveButton.onClick.Invoke();
内容が 日時-名前-BMI
*var elm = historyView.Content.GetChild(0)?.GetComponent<;HistoryElmView>;();
後から追加された方が上にくる
*bmiView.HeightInput.onEndEdit.Invoke("100");
リポジトリにも追加されている
*Assert.That(historyData.Datas.Count, Is.EqualTo(2));
[クリア]でデータが消える
*historyView.ClearButton.onClick.Invoke();
Bindの内容でテストによる実行かを判断し、
テストの場合はmainをここで非活性化し、
テストから任意のタイミングでAwakeを呼べるようにする
*if (Container.HasBinding<;ITest>;()) {

*{style = {fontSize = 64,color = new StyleColor(Color.magenta)}};
初期化と同時に設定
要素ごとに設定
*VisualElement label2 = new Label("Hello World! From C#");
子オブジェクトに左上整列を指示
*child.style.unityTextAlign = new StyleEnum<;TextAnchor>;(TextAnchor.UpperLeft);

毎回呼ばれる
*Text text = GetComponent<;Text>;();
テキストの文字を変更
*text.text = "文字";
キャッシュ用メンバ変数
*Text m_text = null;
最初の一回だけGetComponentを呼び出しキャッシュする
*m_text = GetComponent<;Text>;();
テキストの文字を変更
*m_text.text = "文字";
テキストの文字を変更
*m_text.text = "文字";
テキストの文字を変更
*m_text.text = "文字";

上記の別の書き方
string FilePath = Path.Combine(DesktopDir,FileName) + Extend;
コメントでいただきましたメソッドです。フォルダ階層が深い場合は有効そうですね。
*int FileIndex = 0;
*while (File.Exists(FilePath) == true)*{
上書しないよう被らないファイル名になるまでループ
*if (string.IsNullOrWhiteSpace(s) == false)*File.WriteAllText(FilePath, s);
文字列をファイルに保存
出力
*/*********
出力
*/*********
*Task task1 = Task.Run(() =>;{  SaveFile(resultstr);  });
ファイルの保存（別タスクで非同期処理　続けて処理をおこなうときはWait()を削除する）

*var response = await client.GetAsync($"https:
apps.autodesk.comwebservicescheckentitlement?{await new FormUrlEncodedContent(parameters).ReadAsStringAsync()}");
得られたjsonを解析する
*var serializer = new DataContractJsonSerializer(typeof(ServerResponse));
*if (serverResponse.IsValid != true)*{
結果の判定

*Console.WriteLine("visibleじゃないよ");
ifの計算の結果は0となっている。

メニューバーから呼び出すためのattribute
*[MenuItem("Window/UIElements/Test")]
↓タイトルの設定
*wnd.titleContent = new GUIContent("Test");
rootVisualElement（表示されるUIすべての親となるVisualElementの取得）
*VisualElement root = rootVisualElement;
VisualElementの一つ、ラベルを生成
*VisualElement label = new Label("Hello World! From C#");
rootの子要素として追加、デフォルトだと子要素は上から下にstackされていく
*root.Add(label);
レイアウトにかかわる部分はXX.styleから変更できる
*textField.style.height = 50;

1. まずはデリゲートを定義します。（デリゲートはあくまでメソッドへの参照を表す型です）
*public delegate void SimpleCalc(int a, int b);
*{Console.WriteLine($"{a} + {b} = {a + b}");}
SimpleCalcデリゲートと同じ戻り値の型とパラメーターリストであること関数を用意
2. デリゲートをインスタンス化。同じ戻り値の型、パラメーターリストを持つ関数を代入
*SimpleCalc del_calc = Add;
3. デリゲートインスタンスを通じて関数(この場合Add)を呼び出す
*del_calc(20, 10);
2, 3繰り返す
*del_calc = Subtract;
*{}
デリゲートをわざわざ定義しなくて良い

*tasklist.Start();
まとめて実行

*anotherList.AddRange(list);
2回入れている

*MessageBox.Show("Cannot find end mark\r\n
%%kob58im-ToolEnd%%");

*target.Hp -= singleDamage * 3;
実際にHPを減らす
最も優先度が高い候補を保持する変数。より優先度の高いスキルが現れれば、その都度更新される
*(Skill, int priority) candidate = (null, -context.Enemy.Hp);
*{Hp = context.Enemy.Hp,Defense = context.Enemy.Defense};
A. シミュレーション中に敵が受けるダメージを実際には反映しないためのクローン
B. スキルを実際に適用してみる
*skill.Run(context, clone);
C. スキルの仕様結果を評価する。
敵のHPが少ないほど好ましい状況のはず
*var priority = -clone.Hp;
*var source = new EnemyBattler() { Hp = 100 };
元のオブジェクト。
変数 source を変数 notClone に代入しただけ。クローンじゃない。
この2つの変数は参照先が同じ
*var notClone = source;
notClone.Hp を書き換えると source.Hp も書き換わってしまう。
*notClone.Hp = 99;
*var clone = new EnemyBattler() { Hp = source.Hp };
変数 source のメンバー変数の値だけを引き継ぐ新しいオブジェクト。これがクローン。
*var clone = new EnemyBattler() { Hp = source.Hp };
この2つの変数は参照先が違う
clone.Hp を書き換えても、 source.Hp は書き換わらない。
*clone.Hp = 50;
*{// isShownというprivateフィールドをBattleContextに追加しておく。if(isShown) Console.WriteLine(message);}
前略
*if(isShown) Console.WriteLine(message);*}
isShownというprivateフィールドをBattleContextに追加しておく。
後略
*,,,
Talkメソッド自体は表示の作業はせず、あくまでどのような機能へデータを流すかを制御するだけ。
もはや Console.WriteLine を読んでいるのかどうかを把握することは、呼び出し側の責任ではない
*context.View.Talk("あなたは狙いを定めて敵を撃ちぬいた！");
*{public void Talk(string text){Console.WriteLine(text);}}
コンソールに表示するモード
*{public void Talk(string text){// 何もしない}}
どこにも表示しないモード
何もしない
*}
コンストラクター引数から受け取って、読み取り専用プロパティに設定する
View プロパティの内容を後から書き換えることのない設計にするつもりのため
*public BattleContext(IView view)
*{Enemy = enemy1,Player = new PlayerBattler(){Hp = 100,Defense = 0,Skills = new Skill[]{new SingleAttackSkill(87),new TripleAttackSkill(39),}}};
前略
後略
*,,,
*{Enemy = enemy2,Player = new PlayerBattler(){Hp = 100,Defense = 0,Skills = new Skill[]{new SingleAttackSkill(87),new TripleAttackSkill(39),}}};
前略
後略
*,,,
*{Enemy = enemy2,Player = new PlayerBattler(){Hp = 100,Defense = 0,Skills = new Skill[]{new SingleAttackSkill(87),new TripleAttackSkill(39),}}};
前略
後略
*,,,
*{Enemy = context.Enemy,Player = context.Player};
*修正* シミュレーション中に発動するスキルのメッセージを表示しないようにするためのクローン
シミュレーション中に敵が受けるダメージを実際には反映しないためのクローン
割愛しているが、実際はプレイヤーのクローンも生成しておいたり、
敵のクローンはBattleContext.Enemyなどにもsetしておいたほうが
独特なスキルをたくさん実装する際に安全
*var clone = new EnemyBattler()
*修正* BattleContext を渡す場所には、メインの BattleContext ではなく
NullView を持たせてあるクローンのほうの BattleContext を渡す
*skill.Run(cloneContext, clone);

まだ未実装
*}
三項演算子,x.GenderがtrueであればIsMancheckedをみて、falseであればIsWomanCheckを見る。
*linq = linq.Where(x =>; x.Gender?MyVM.IsManChecked:MyVM.IsWomanChecked);
三項演算子,x.GenderがtrueであればIsMancheckedをみて、falseであればIsWomanCheckを見る。
*linq = linq.Where(x =>; x.Gender?MyVM.IsManChecked:MyVM.IsWomanChecked);

自動実装ではないプロパティを除外する。
*[JsonIgnore]

ログインページではなくHTML内の$.ajaxのurlを参照
string url_post = "https:pl.sega-mj.com/players/MjmidLogin";
ログイン後にジャンプするページ
string url_history = "https:pl.sega-mj.com/playdata_view/showHistory";
*string USER_ID = "mjm54XXXXXX";
クライアント接続開始
*client = new HttpClient();
POST要求（ログインしてクッキー取得）
*Task<;bool>; task_login = PostRequest(url_post, USER_ID, PASSWORD);
*if (task_login.Result)*{
URLでHTMLを取得する。
HTML構造解析
*string resultstr = AnalizeHtml(50, HTMLtext);
*Task task1 = Task.Run(() =>;{  SaveFile(resultstr);  });
ファイルの保存（別タスクで非同期処理　続けて処理をおこなうときはWait()を削除する）
End待機
Thread.Sleep(1000);
*Console.ReadKey();
*{//POSTで送る内容作成。mContent.Add(属性の値, 属性の名前)MultipartFormDataContent mContent = new MultipartFormDataContent();mContent.Add(new StringContent(user) ,  "mjm_id");mContent.Add(new StringContent(password) ,  "password");//ヘッダ情報確認Console.WriteLine("【PostRequest Headers】" + mContent.Headers);//POSTしてレスポンスの要求。（要求先、要求内容）HttpResponseMessage response = await client.PostAsync(url_post, mContent);Console.WriteLine("【PostRequest Response】 " + response.StatusCode.ToString());if (response.StatusCode == HttpStatusCode.OK){//応答ステータスがOKならHTML文字列を取得する。string contentstr = await response.Content.ReadAsStringAsync();Console.WriteLine("【PostRequest HTMLcontent】" + contentstr);Console.WriteLine("【PostRequest Cookie】" + response.Headers.GetValues("Set-Cookie").First() );}return true;}
POST要求（ログイン）
POSTで送る内容作成。mContent.Add(属性の値, 属性の名前)
*MultipartFormDataContent mContent = new MultipartFormDataContent();
ヘッダ情報確認
*Console.WriteLine("【PostRequest Headers】" + mContent.Headers);
POSTしてレスポンスの要求。（要求先、要求内容）
*HttpResponseMessage response = await client.PostAsync(url_post, mContent);
応答ステータスがOKならHTML文字列を取得する。
*string contentstr = await response.Content.ReadAsStringAsync();
*{HttpResponseMessage response = await client.GetAsync(url);string contentstr = response.StatusCode.ToString();Console.WriteLine("【GetRequest Response】" + contentstr);if (response.StatusCode == System.Net.HttpStatusCode.OK){contentstr = await response.Content.ReadAsStringAsync();}else if (response.StatusCode == HttpStatusCode.Redirect){//StatusCode リダイレクトのときの処理var r = client.GetAsync(url).Result;Uri uri = new Uri(new Uri(url), r.Headers.Location);contentstr = client.GetAsync(uri).Result.Content.ReadAsStringAsync().Result;}return contentstr;}
URLからHTMLをゲット（ログインには使用しない）
StatusCode リダイレクトのときの処理
*var r = client.GetAsync(url).Result;

*var b = new byte[W,H];
new

処理
*delvoid();
処理
*delint();
処理
*delstr();
処理
*}
処理
最後にstringを返す
*}
処理
最後にintを返す
*}

*return null;
置換対象ではない

AES暗号化キーの長さを強制的に16バイトで切る
*Array.Resize<;byte>;(ref encryptKey, AesBlockByteSize);
AES暗号化の設定
*aes.BlockSize = AesBlockBitSize;
ランダムなIVを生成
*var iv = new byte[AesBlockByteSize];
復号用にIVの値をファイル先頭に出力する
*outputStream.Write(iv, 0, AesBlockByteSize);

*class Skill{[JsonProperty("language")]public string language {get; set;}[JsonProperty("ex_year")]public int exyear {get; set;}public Skill(string lang,int year){this.language = lang;this.exyear = year;}}
クラス定義
JSONファイルを作る
*List<;Skill>; skillList= new List<;Skill>;();

PDFファイルをロードします。
*PdfDocument document = new PdfDocument();
*JoinTiffImages(SaveAsImage(document), "result.tiff", EncoderValue.CompressionLZW);*}
.tiffで保存します。
*{Image[] images = new Image[document.Pages.Count];for (int i = 0; i <; document.Pages.Count; i++){images[i] = document.SaveAsImage(i);}return images;}
SaveAsImage()
*{ImageCodecInfo[] encoders = ImageCodecInfo.GetImageEncoders();for (int j = 0; j <; encoders.Length; j++){if (encoders[j].MimeType == mimeType)return encoders[j];}throw new Exception(mimeType + " mime type not found in ImageCodecInfo");}
GetEncoderInfo()メソッドを定義します
*public static void JoinTiffImages(Image[] images, string outFile, EncoderValue compressEncoder)*{
JoinTiffImages()メソッドを定義します
*Image tiffImage = Image.FromFile("test.tiff");*Image[] imgs = SplitImages(tiffImage);
tiffをロードします。
PDFで画像を描きます。
*page.Canvas.DrawImage(pdfImg, x, 0, pageSize.Width,pageSize.Height);
Pdfで保存します。
*pdfDoc.SaveToFile("result.pdf");

LINQでこう書くと実際オサレ
return points.Select(matrix.MultiplyPoint).ToArray();
*}
Rustによる変換
*Profiler.BeginSample("#ByRust");
Rust(Releaseビルド)による変換
*Profiler.BeginSample("#ByRustR");
C#による変換
*Profiler.BeginSample("#ByCSharp");
*{var ret = new Vector3[points.Count];for (var count = 0; count <; points.Count; count++){ret[count] = matrix.MultiplyPoint(points[count]);}return ret;}
C#による変換
*{var ret = new Vector3[points.Count];for (var count = 0; count <; points.Count; count++){ret[count] = multiply_point(matrix, points[count]);}return ret;}
RustDebugビルドによる変換
*{var ret = new Vector3[points.Count];for (var count = 0; count <; points.Count; count++){ret[count] = multiply_point_r(matrix, points[count]);}return ret;}
RustReleaseビルドによる変換
*{var random = new System.Random();var points = new Vector3[length];for (var count = 0; count <; points.Length; count++){cancellationToken.ThrowIfCancellationRequested();// UnityEngine.RandomのAPIはメインスレッドからしか呼べない...// なので無理矢理ランダムなVector3を生成するpoints[count].x = (float) (random.NextDouble() * random.Next(-100, 100));points[count].y = (float) (random.NextDouble() * random.Next(-100, 100));points[count].z = (float) (random.NextDouble() * random.Next(-100, 100));}return Task.FromResult(points);}
ランダムなVector3の配列を生成
UnityEngine.RandomのAPIはメインスレッドからしか呼べない...
なので無理矢理ランダムなVector3を生成する
*points[count].x = (float) (random.NextDouble() * random.Next(-100, 100));

*{int b = ms.ReadByte();if ( b <; 0 ) {return true;}else {ms.Position--;return false;}}
---------------------------------------------
*while ( ( b = ms.ReadByte() ) >;= 0 ) {*if ('0';=b&amp;&amp;b;='9') {
Console.WriteLine("CheckNum");

*string outputBatPath = Path.Combine(Environment.CurrentDirectory, @"Register.bat");
保存先のパス
「ユーザーアカウント制御」ダイアログでキャンセルされたなどによって
起動できなかった時
*return true;

*string tempPath = "";
色々処理した結果の一時ファイルのパス
解像度を設定
*img.Density = new Density(densityX, DensityUnit.PixelsPerInch);
保存
*img.Write(outPath);

*int toHeight = 50;
拡大後の高さ
フィルター指定
*img.FilterType = ImageMagick.FilterType.Lanczos;
リサイズ実行
*img.Resize((int)Math.Ceiling(newWid), toHeight);
*img.Write(Path.Combine(outPath, $"{filename}_out{ext}"));
保存

接続するURL
private const string RegistrationURL = "http:localhost:5000/registration";
ゲームオブジェクトUI &gt; ButtonのInspector &gt; On Click()から呼び出すメソッド
*public void Registration()
*WWWForm form = new WWWForm();*form.AddField("user_id", m_idInputField.text, Encoding.UTF8);
POSTする情報
*UnityWebRequest webRequest = UnityWebRequest.Post(url, form);*//UnityWebRequestにバッファをセット
URLをPOSTで用意
UnityWebRequestにバッファをセット
*webRequest.downloadHandler = new DownloadHandlerBuffer();
URLに接続して結果が戻ってくるまで待機
*yield return webRequest.SendWebRequest();
*if (webRequest.isNetworkError)*{
エラーが出ていないかチェック
通信失敗
*Debug.Log(webRequest.error);
通信成功
*Debug.Log("Post"+" : "+webRequest.downloadHandler.text);
*WWWForm form = new WWWForm();*form.AddField("user_id", m_idInputField.text, Encoding.UTF8);
POSTする情報

エディタウインドウ生成
*GetWindow<;EditorWindowScript>;("SceneEditWindow");
テキストフィールド用変数
*string textField1 = "";
エディタレイアウト
２行開ける
*EditorGUILayout.Space();
*using (new GUILayout.HorizontalScope()){//セーブ用ボタン作成if (GUILayout.Button("Save Scene")){//Castle Object内のTag付きObjectを全てセーブしますGameObject castle = GameObject.Find("Castle");//Resources内のCastleObjectData(ScriptableObject)をtextField1を用いてアクセスCastleObjectData data = Resources.Load<;CastleObjectData>;("CastleObjectData/CastleObjectData"+textField1);//すでに存在するデータ名であれば上書きして良いか警告するif(data != null){//Canselボタンあり、OKかCanselかで処理分けする場合のUnityDialogbool b = EditorUtility.DisplayDialog("警告", "上書きしますか？?", "はい", "いいえ");if(!b) {//”いいえ”ならセーブに必要なTextField1をリセットtextField1 = "";}}Resources.UnloadUnusedAssets();if(textField1!=""){//データ保存用CastleObjectData(ScriptableObject)を作成CastleObjectData castleObjectData = ScriptableObject.CreateInstance<;CastleObjectData>;();//Castle Object以下の全てのTag付きObjectのPosition,Rotation,ObjectType(Tag)を保存します。（形式についてはCastleObjectDataクラスを参照）(GetAllメソッドについてはGetAllChildrenクラスを参照)List<;GameObject>; list = GetAllChildren.GetAll(castle);foreach (GameObject obj in list) {ObjectInfo objectInfo = new ObjectInfo();if(obj.tag!="Untagged"){objectInfo.objectTransform = obj.transform.position;objectInfo.objectRotation  = obj.transform.rotation;objectInfo.objectType = obj.tag;castleObjectData.castleObjects.Add(objectInfo);}}//ファイル書き出しAssetDatabase.CreateAsset(castleObjectData, "Assets/Resources/CastleObjectData/CastleObjectData"+textField1+".asset");}}}
セーブ用テキストフィールド作成
*if (GUILayout.Button("Save Scene")){*//Castle Object内のTag付きObjectを全てセーブします
セーブ用ボタン作成
Castle Object内のTag付きObjectを全てセーブします
*GameObject castle = GameObject.Find("Castle");
Resources内のCastleObjectData(ScriptableObject)をtextField1を用いてアクセス
*CastleObjectData data = Resources.Load<;CastleObjectData>;("CastleObjectData/CastleObjectData"+textField1);
*if(data != null){*//Canselボタンあり、OKかCanselかで処理分けする場合のUnityDialog
すでに存在するデータ名であれば上書きして良いか警告する
*if(!b) {//”いいえ”ならセーブに必要なTextField1をリセットtextField1 = "";}
Canselボタンあり、OKかCanselかで処理分けする場合のUnityDialog
”いいえ”ならセーブに必要なTextField1をリセット
*textField1 = "";
データ保存用CastleObjectData(ScriptableObject)を作成
*CastleObjectData castleObjectData = ScriptableObject.CreateInstance<;CastleObjectData>;();
*foreach (GameObject obj in list) {ObjectInfo objectInfo = new ObjectInfo();if(obj.tag!="Untagged"){objectInfo.objectTransform = obj.transform.position;objectInfo.objectRotation  = obj.transform.rotation;objectInfo.objectType = obj.tag;castleObjectData.castleObjects.Add(objectInfo);}}
Castle Object以下の全てのTag付きObjectのPosition,Rotation,ObjectType(Tag)を保存します。（形式についてはCastleObjectDataクラスを参照）(GetAllメソッドについてはGetAllChildrenクラスを参照)
ファイル書き出し
*AssetDatabase.CreateAsset(castleObjectData, "Assets/Resources/CastleObjectData/CastleObjectData"+textField1+".asset");
２行開ける
*EditorGUILayout.Space();
*using (new GUILayout.HorizontalScope()){//ロードボタンif (GUILayout.Button("Load Scene")){int prefabNum = 0;GameObject castle = GameObject.Find("Castle");//Canselボタンあり、OKかCanselかで処理分けする場合bool b = EditorUtility.DisplayDialog("警告", "ロードしますか？?", "はい", "いいえ");if(b) {//castle以下のObjectを取得（GetAllメソッドについてはGetAllChildrenクラスを参照）List<;GameObject>; list = GetAllChildren.GetAll(castle);//元々のシーン上のオブジェクトを破棄foreach(GameObject obj in list){DestroyImmediate(obj);}CastleObjectData data = Resources.Load<;CastleObjectData>;("CastleObjectData/CastleObjectData"+textField2);foreach(ObjectInfo objectInfo in data.castleObjects){prefabNum++;//プレハブを取得(Tag名とPrefab名は便宜上同じにしておく)GameObject prefab;prefab = (GameObject)Resources.Load("Prefabs/"+objectInfo.objectType);string prefabName = objectInfo.objectType;//プレハブからインスタンスを生成if(prefab!=null){var obj = Instantiate(prefab, objectInfo.objectTransform , objectInfo.objectRotation ,castle.transform);obj.name = prefabName;}}}}}
ロード用テキストフィールド作成
*if (GUILayout.Button("Load Scene")){*int prefabNum = 0;
ロードボタン
*if(b) {//castle以下のObjectを取得（GetAllメソッドについてはGetAllChildrenクラスを参照）List<;GameObject>; list = GetAllChildren.GetAll(castle);//元々のシーン上のオブジェクトを破棄foreach(GameObject obj in list){DestroyImmediate(obj);}CastleObjectData data = Resources.Load<;CastleObjectData>;("CastleObjectData/CastleObjectData"+textField2);foreach(ObjectInfo objectInfo in data.castleObjects){prefabNum++;//プレハブを取得(Tag名とPrefab名は便宜上同じにしておく)GameObject prefab;prefab = (GameObject)Resources.Load("Prefabs/"+objectInfo.objectType);string prefabName = objectInfo.objectType;//プレハブからインスタンスを生成if(prefab!=null){var obj = Instantiate(prefab, objectInfo.objectTransform , objectInfo.objectRotation ,castle.transform);obj.name = prefabName;}}}
Canselボタンあり、OKかCanselかで処理分けする場合
castle以下のObjectを取得（GetAllメソッドについてはGetAllChildrenクラスを参照）
*List<;GameObject>; list = GetAllChildren.GetAll(castle);
*foreach(GameObject obj in list){*DestroyImmediate(obj);
元々のシーン上のオブジェクトを破棄
プレハブを取得(Tag名とPrefab名は便宜上同じにしておく)
*GameObject prefab;
*if(prefab!=null){*var obj = Instantiate(prefab, objectInfo.objectTransform , objectInfo.objectRotation ,castle.transform);
プレハブからインスタンスを生成
*public enum ObjectType{Block = 0,Bomb = 1,FiveBlock = 2,TowerBlock = 3}
ここにPrefab名とTag名と同じObjectTypeをEnumで定義しておく
*public class CastleObjectData : ScriptableObject{//各ObjectのObjectInfoデータセットのListpublic List<;ObjectInfo>; castleObjects = new List<;ObjectInfo>;();}
ScriptableObjectの雛形を定義
各ObjectのObjectInfoデータセットのList
*public List<;ObjectInfo>; castleObjects = new List<;ObjectInfo>;();
*public class ObjectInfo{public Vector3 objectTransform;public Quaternion objectRotation;public string objectType;}
ObjectInfoにはTransformPosition、TransformRotation、TagをStringで保存
*{Transform children = obj.GetComponentInChildren<;Transform>; ();//子要素がいなければ終了if (children.childCount == 0) {return;}foreach (Transform ob in children) {allChildren.Add (ob.gameObject);GetChildren (ob.gameObject, ref allChildren);}}
子要素を取得してリストに追加
*if (children.childCount == 0) {*return;
子要素がいなければ終了

PDFをロードします。
*PdfDocument pdf = new PdfDocument();
htmlで保存します。
*pdf.SaveToFile("ToHtml.html", FileFormat.HTML);

*Handler.URL = "http:
localhostapiindex.php";

*using System.ComponentModel;
CancelEventArgsを使用するため
*NotifyIcon trayIcon = new NotifyIcon();*//trayIcon.Icon = new Icon("hogehoge.ico"); // 何かしらのアイコンを設定しないとタスクトレイに表示されない
this.ShowInTaskbar = false;  TaskTrayTestがFormを継承する場合はコメントアウトを外す
trayIcon.Icon = new Icon("hogehoge.ico");  何かしらのアイコンを設定しないとタスクトレイに表示されない
*Icon tmpIcon = MyIconUtil.Create16x16Icon(iconDot);

*SendMessage(128, 1, icon.Handle);
128 = WM_SETICON

*);
20191121 01:23:45

接続するURL
private const string URL = "http:localhost:5000/";
*void Start()
コルーチンを呼び出す
*StartCoroutine("OnSend", URL);
指定したURLでGET
*UnityWebRequest webRequest = UnityWebRequest.Get(url);
URLに接続して結果が戻ってくるまで待機
*yield return webRequest.SendWebRequest();
*if (webRequest.isNetworkError)*{
エラーが出ていないかチェック
通信失敗
*Debug.Log(webRequest.error);
通信成功
*Debug.Log("Get" + " : "+webRequest.downloadHandler.text);
*WWWForm form = new WWWForm();*form.AddField("user_id", idInputField.text, Encoding.UTF8);
POSTする情報

*for (int x = 0; x <;= 3; x++)
0,1,2 (3)
*if (x == 0) continue;*round_key[0, x] = (byte)(CURRENT_CHIPHER_KEY[ 0 + (1 * x)] ^ round_key[0, x - 1]);
0は除きたい（横インデックス1から埋め込んでいく）ので x は 1 2 3 のみに絞る

1レコードずつ取り出す処理
*}

*dgv.ColumnHeadersHeight = 0;
これは、うまくいかない
dgv は、DataGridView（を継承したクラス）のインスタンス
*dgv.GetType().BaseType

*for (double n = 1; n <; 1e9;)
l = 11 - 13 + 15 - 17 + ... 11e9

*{Audio   = 0,Stage   = 1,Save    = 2};
ここにセーブフォルダを追加すれば楽になるかも

*string profileUrl       = "https:
api.line.mev2profile";
*ApiResponseCustomTokenData data = new ApiResponseCustomTokenData() {Status      = 0,CustomToken = null};
response
*var verifyResponse  = await _httpClient.SendAsync(veryfyRequest);*data.Status         = (int)verifyResponse.StatusCode;
accessToken検証
*var verifyBody  = await verifyResponse.Content.ReadAsStringAsync();*JObject verify  = JObject.Parse(verifyBody);
channelId抽出
*if(clientId == m_AppSettings.SnsAuthentication.Line.ClientId) {*profileRequest.Headers.Add("Authorization", "Bearer " + accessToken);
profile取得
*if(_firebaseApp == null) {*_firebaseApp = FirebaseApp.Create(new AppOptions() {
Firebase初期化

コントロール配列で管理するクラスをDictionaryに入れる
（Listとかに使用と思ったらインデックス-1で登録されてくるケースがあったので
Dictionaryにしました。）
*protected Dictionary<;int, Control>; items = new Dictionary<;int, Control>;();
*{return checked((short)this.items.Count);}
コントロール配列内のコントロール数を返します。
*{}
何もしないがこれがないとコンパイルエラー
*{}
何もしないがこれがないとコンパイルエラー
*{if(disposing){items.Clear();}base.Dispose(disposing);}
気持ちの問題か
*{return 0;}
必要かどうか迷ったが入れておく
*{return (short)(items.Count - 1);}
必要かどうか迷ったが入れておく
*{}
コンストラクタの中で何かする必要はなかった
*{}
コンストラクタの中で何かする必要はなかった
KeyPressイベントハンドラ
*public event KeyPressEventHandler KeyPress;
*{return extendee is TextBox;}
与えられたこのコントロール配列に入れることが出来るかどうかを返す
*{return typeof(TextBox);}
コントロール配列の型を返す
*{items[index] = item;// コントロール配列のイベントを個々のコントロールに結び付けるif (KeyPress != null) item.KeyPress += KeyPress;}
コントロール配列にコントロールを登録
*if (KeyPress != null) item.KeyPress += KeyPress;*}
コントロール配列のイベントを個々のコントロールに結び付ける

たまに動作しない時があるため1F待機する
*await UniTask.DelayFrame(1);
依存関係のため_addedRaycasterから先に削除する
*Object.Destroy(_addedRaycaster);

*if ( s.EndsWith(".lnk", true, null) ) {
Note: 第2引数はignoreCase

*this.Invalidate();
to repaint

*{rb = GetComponent<;Rigidbody>;();count = 0;SetCountText();winText.text = "";}
See also:https:docs.unity3d.com/ja/2019.1/Manual/ExecutionOrder.html

*return Convert.ToByte(color_bits_str, 2);
2進数からbyteに変換
*//{   //指定されたバイト数値にデータを埋め込む所//    //基礎画像の下位4ビットをカットする。//    string base1_str = Convert.ToString(base1, 2).PadLeft(8, '0'); //8桁の二進数にする。//    base1_str = base1_str.Substring(0, 4); //上位4ビットのみ取得。//    string base2_str = Convert.ToString(base2, 2).PadLeft(8, '0'); //8桁の二進数にする。//    base2_str = base2_str.Substring(0, 4); //上位4ビットのみ取得。//    //空いた下位4ビットにデータを埋め込む//    string umekomi_str = Convert.ToString(umekomi_byte, 2).PadLeft(8, '0'); //8桁の二進数にする。//    base1_str = base1_str + umekomi_str.Substring(0, 4); //下位4ビットに埋め込む//    base1 = Convert.ToByte(base1_str, 2); //2進数からbyteに変換//    base2_str = base2_str + umekomi_str.Substring(4, 4); //下位4ビットに埋め込む//    base2 = Convert.ToByte(base2_str, 2); //2進数からbyteに変換//    //基礎側のバイナリは2つ進む//    base_cnt += 2;//}
ARGB8888なら以下の埋め込み方法だった。
*//{   //指定されたバイト数値にデータを埋め込む所//    //基礎画像の下位4ビットをカットする。//    string base1_str = Convert.ToString(base1, 2).PadLeft(8, '0'); //8桁の二進数にする。//    base1_str = base1_str.Substring(0, 4); //上位4ビットのみ取得。//    string base2_str = Convert.ToString(base2, 2).PadLeft(8, '0'); //8桁の二進数にする。//    base2_str = base2_str.Substring(0, 4); //上位4ビットのみ取得。//    //空いた下位4ビットにデータを埋め込む//    string umekomi_str = Convert.ToString(umekomi_byte, 2).PadLeft(8, '0'); //8桁の二進数にする。//    base1_str = base1_str + umekomi_str.Substring(0, 4); //下位4ビットに埋め込む//    base1 = Convert.ToByte(base1_str, 2); //2進数からbyteに変換//    base2_str = base2_str + umekomi_str.Substring(4, 4); //下位4ビットに埋め込む//    base2 = Convert.ToByte(base2_str, 2); //2進数からbyteに変換//    //基礎側のバイナリは2つ進む//    base_cnt += 2;//}
private void data_umekomi_b(ref byte base1, ref byte base2, byte umekomi_byte)
{   指定されたバイト数値にデータを埋め込む所
基礎画像の下位4ビットをカットする。
string base1_str = Convert.ToString(base1, 2).PadLeft(8, '0'); 8桁の二進数にする。
base1_str = base1_str.Substring(0, 4); 上位4ビットのみ取得。
string base2_str = Convert.ToString(base2, 2).PadLeft(8, '0'); 8桁の二進数にする。
base2_str = base2_str.Substring(0, 4); 上位4ビットのみ取得。
空いた下位4ビットにデータを埋め込む
string umekomi_str = Convert.ToString(umekomi_byte, 2).PadLeft(8, '0'); 8桁の二進数にする。
base1_str = base1_str + umekomi_str.Substring(0, 4); 下位4ビットに埋め込む
base1 = Convert.ToByte(base1_str, 2); 2進数からbyteに変換
base2_str = base2_str + umekomi_str.Substring(4, 4); 下位4ビットに埋め込む
base2 = Convert.ToByte(base2_str, 2); 2進数からbyteに変換
基礎側のバイナリは2つ進む
base_cnt += 2;
}
private byte data_toridashi_b(byte base1, byte base2)
{   指定されたバイト数値からデータを取り出す所
基礎画像の上位4ビットをカットする。
string base1_str = Convert.ToString(base1, 2).PadLeft(8, '0'); 8桁の二進数にする。
base1_str = base1_str.Substring(4, 4); 下位4ビットのみ取得。
string base2_str = Convert.ToString(base2, 2).PadLeft(8, '0'); 8桁の二進数にする。
base2_str = base2_str.Substring(4, 4); 下位4ビットのみ取得。
空いた下位4ビットにデータを埋め込む
string toridashi_str = base1_str + base2_str;
基礎側のバイナリは2つ進む
base_cnt += 2;
return Convert.ToByte(toridashi_str, 2); 2進数からbyteに変換
}
*,,,

*if (ValueInRange(rad, Mathf.PI * 0.25f, Mathf.PI * 0.75f))*{
rad in top
*else if (ValueInRange(rad, Mathf.PI * 0.75f, Mathf.PI * 1.25f))*{
rad in left
*else if (ValueInRange(rad, Mathf.PI * 1.25f, Mathf.PI * 1.75f))*{
rad in bottom
*{_vertices[i].x = 0.5f;_vertices[i].y = Mathf.Tan(rad) * _vertices[i].x;}
rad in right

*NamingStrategy = new DefaultNamingStrategy()
列挙型名をそのまま値とする
JsonHandlerAttributeの設定
*JsonHandlerAttribute.DefaultJsonResultFactory = () =>; new JsonNetResult();

*Console.WriteLine(b);
&lt;-- "GetString2"と出力される
*{public class Test2{public static string GetString2(){return Test1.GetString("GetString2");}}}
using Tests;  &lt;-- Program.csでglobal usingをしているのでコメントアウト(削除)しても大丈夫

*using System.Reflection;
これだけ先頭に追加。他はTestCodeクラス内

*viewer.ClipboardHandler += this.OnClipBoardChanged;
イベントハンドラを登録
*{Console.WriteLine(args.Text);}
クリップボードにテキストがコピーされると呼び出される

*string d = (string)b;
objectをstringにキャスト　dには"Hello"が入る(ボックス解除？)

*public override void OnBehaviourPlay (Playable playable, FrameData info) {if (!trackObj)return;// なんらかの処理}
各clip開始時に呼び出される
なんらかの処理
*}
TestBehaviourを作成
*var playable = ScriptPlayable<;TestBehaviour>;.Create (graph, template);
トラックに入っているGameObject
*public GameObject m_TrackBinding;
*public override void OnGraphStart (Playable playable) {if (!m_TrackBinding)return;// Trackの全clipの数を取得int inputCount = playable.GetInputCount ();for (int i = 0; i <; inputCount; i++) {// 各clipのbehaviour取得ScriptPlayable<;TestBehaviour>; inputPlayable =(ScriptPlayable<;TestBehaviour>;) playable.GetInput (i);TestBehaviour input = inputPlayable.GetBehaviour ();// trackのGameObjectを渡すinput.trackObj = m_TrackBinding;}}
timelineの開始時 初期化
*for (int i = 0; i <; inputCount; i++) {// 各clipのbehaviour取得ScriptPlayable<;TestBehaviour>; inputPlayable =(ScriptPlayable<;TestBehaviour>;) playable.GetInput (i);TestBehaviour input = inputPlayable.GetBehaviour ();// trackのGameObjectを渡すinput.trackObj = m_TrackBinding;}
Trackの全clipの数を取得
各clipのbehaviour取得
*ScriptPlayable<;TestBehaviour>; inputPlayable =
trackのGameObjectを渡す
*input.trackObj = m_TrackBinding;
TestMixerBehaviourを作成
*var playable = ScriptPlayable<;TestMixerBehaviour>;.Create (graph, inputCount);
TrackにバインドされたGameObjectをTestMixerBehaviourに渡す
*playable.GetBehaviour ().m_TrackBinding = trackBinding;

*private object lock_count2 = new object();
同じ

必要に応じて初期値を設定
初期のフォントを設定
*fontDialog1.Font = richTextBox1.Font;
初期の色を設定
*fontDialog1.Color = richTextBox1.ForeColor;
ユーザーが選択できるポイントサイズの最大値を設定する
*fontDialog1.MaxSize = 15;
存在しないフォントやスタイルをユーザーが選択すると
エラーメッセージを表示する
*fontDialog1.FontMustExist = true;
横書きフォントだけを表示する
*fontDialog1.AllowVerticalFonts = false;
色を選択できるようにする
*fontDialog1.ShowColor = true;
取り消し線、下線、テキストの色などのオプションを指定可能にする
デフォルトがTrueのため必要はない
*fontDialog1.ShowEffects = true;
固定ピッチフォント以外も表示する
デフォルトがFalseのため必要はない
*fontDialog1.FixedPitchOnly = false;
ベクタ フォントを選択できるようにする
デフォルトがTrueのため必要はない
*fontDialog1.AllowVectorFonts = true;
*{if (fontDialog1.ShowDialog() == DialogResult.OK){//OKボタンが押されたら、フォントを設定するrichTextBox1.SelectionFont = fontDialog1.Font;richTextBox1.SelectionColor = fontDialog1.Color;}}
フォントダイアログボックス呼び出しボタン
OKボタンが押されたら、フォントを設定する
*richTextBox1.SelectionFont = fontDialog1.Font;
*{var currentSize = richTextBox1.SelectionFont.Size;currentSize += 2.0F;richTextBox1.SelectionFont = new Font(richTextBox1.SelectionFont.Name,currentSize,richTextBox1.SelectionFont.Style,richTextBox1.SelectionFont.Unit);}
フォントを大きくするボタン
*{var currentSize = richTextBox1.SelectionFont.Size;currentSize -= 1;richTextBox1.SelectionFont = new Font(richTextBox1.SelectionFont.Name,currentSize,richTextBox1.SelectionFont.Style);}
フォントを小さくするボタン
*{richTextBox1.SelectionFont = new Font(richTextBox1.SelectionFont.FontFamily,richTextBox1.SelectionFont.Size,richTextBox1.SelectionFont.Style ^ FontStyle.Bold);}
フォントを太字にするボタン
*{richTextBox1.SelectionFont = new Font(richTextBox1.SelectionFont.FontFamily,richTextBox1.SelectionFont.Size,richTextBox1.SelectionFont.Style ^ FontStyle.Italic);}
フォントを斜字にするボタン
*{richTextBox1.SelectionFont = new Font(richTextBox1.SelectionFont.FontFamily,richTextBox1.SelectionFont.Size,richTextBox1.SelectionFont.Style ^ FontStyle.Underline);}
テキストに下線を引くボタン
*{richTextBox1.SelectionFont = new Font(richTextBox1.SelectionFont.FontFamily,richTextBox1.SelectionFont.Size,richTextBox1.SelectionFont.Style ^ FontStyle.Strikeout);}
テキストに取り消し線を付けるボタン
*{richTextBox1.SelectionAlignment = HorizontalAlignment.Left;}
左寄せボタン
*{richTextBox1.SelectionAlignment = HorizontalAlignment.Center;}
中央寄せボタン
*{richTextBox1.SelectionAlignment = HorizontalAlignment.Right;}
右寄せボタン
*{richTextBox1.SelectionBullet = !richTextBox1.SelectionBullet;}
箇条書きボタン
*{richTextBox1.SelectionIndent += 16;}
右インデントボタン
*{richTextBox1.SelectionIndent -= 16;}
左インデントボタン

*Destroy(gameObject);
オブジェクトを消す

*return str;
メソッド名はReverseであるが基本クラス制約の機能を
確認するためこのクラスでは反転させず、パラメータをそのまま戻す
*}
*{T obj;public Test(T o){obj = o;}public void ShowReverse(string str){String revStr = obj.ReverseStr(str);Console.WriteLine(revStr);Console.WriteLine();}}
ReverseClassで基本クラス制約をかける

*MapFridge.Add("野菜",new List<;string>;(){"きゅうり","トマト","玉ねぎ"});
ローカルで初期化
*foreach(string s in MapFridge.Keys){*Debug.Log(s);
Keyを取得して表示
*foreach(List<;string>; li in MapFridge.Values){*foreach(string s in li){
Valueを取得して表示
*foreach(KeyValuePair<;string,List<;string>;>; item in MapFridge){*Debug.Log(item.Key+"はこれがあります");
KeyとValueのPairを取得して表示

初期位置とzoomレベル
*Vector2d latLon = new Vector2d(37.784179f, -122.401583f);

*}
End class Program

*Log(msg + "_");
引数を処理させるためにちょいと加工

*if (mi == null) {
Stringクラスを引数とするRunメソッドがあるかをチェック

ビジネスロジック
string str1 = Result.Replace("ω", "　");
str1 = str1.Replace("Ω", "\t");
*string str1 = Result;

*public int ID { get; set; }
public string Title { get; set; }

selectedLabelが変化した瞬間を検知する
*selectedToggleName.Subscribe(x =>; Debug.Log("Changed:" + x));

*Task.Run(() =<; CheckDevice());
デバイスをチェック

*readOnlyArray[1] = "second update";
エラー発生
*string[] stringValuesBeforeClone = new string[] { "first", "second", "third" };*string[] cloneStringValues = (string[]) stringValuesBeforeClone.Clone();
first update , second , third =&gt; stringValuesの変更が反映されてしまう
first , second , third =&gt; stringValuesVeforeCloneの変更が反映されない
*Console.ReadKey();
*{if (x.ToString().Length <; y.ToString().Length){return -1;}else if (x.ToString().Length >; y.ToString().Length){return 1;}else{return 0;}}
Call CaseInsensitiveComparer.Compare with the parameters reversed.

ネットワークを経由するなら下の行を入れて反転させる必要がある
return (uint)IPAddress.NetworkToHostOrder(networkOrder);
*}

*DMatch[] good_matches = new DMatch[good_match_length];
閾値以下の要素数で定義
good_matchesに格納していく
*int j = 0;

*Debug.Log(enemyNameGenerator.GetUniqueItem());
null
履歴を削除
*enemyNameGenerator.ResetUsageHistory();
再び取り出せるようになる
*Debug.Log(enemyNameGenerator.GetUniqueItem());

*standardOutput.AutoFlush = true;
StreamWriter が呼び出されるたびに、Write(Char) によって基になるストリームに対するバッファーをフラッシュするかどうかを示す値を取得または設定します。
ディスプレイに出力
*Console.WriteLine("標準出力がファイルからディスプレイに戻る。");

コントロールの透明化
※親コントロール描画時に、本コントロールのRegion内の領域も描画してくれるようになる
※兄弟関係による最前面、最背面の概念がなくなる
この拡張コントロールと他のコントロールを兄弟関係で重ねると、重ねた領域の描画が後勝ちになる
※ControlStyles.OptimizedDoubleBufferは透明度をサポートしていないため、これと併用するとRegion内を黒で塗りつぶされる
よってバッファリングできないのでちらつくようになる。また、処理毎に描画するので動作が重くなる
*var WS_EX_TRANSPARENT = 0x20;
OnPaintBackgroundを無効化
*SetStyle(ControlStyles.Opaque, true);
アンチエイリアスを掛ける
*g.SmoothingMode = SmoothingMode.AntiAlias;
バック
*g.FillPath(new SolidBrush(BackColor), GetGraphicsPath(true));
*if(DisplayBorder)*g.DrawPath(new Pen(new SolidBrush(BorderColor)), GetGraphicsPath(true));
ボーダー
*var drawFormat = new StringFormat {Alignment = StringAlignment.Center,LineAlignment = StringAlignment.Center};
フォント
*diameter -= forPaint ? 2 : 0;*// 角丸
シュリンクすると、縦横-2pxなので、直径も-2px
角丸
*gp.StartFigure();
*var shrink = forPaint ? 1 : 0;*// 四角
何故か右辺と下辺にボーダーが付かないので-1pxしとく
四角
*gp.AddRectangle(new Rectangle(0, 0, Width - shrink, Height - shrink));

*Console.WriteLine($"typeof(int?) = {typeof(int?)}");
typeof(int?)はNullable&lt;int&gt;を返す
Nullable&lt;T&gt;.GetType()は未定義のため、object.GetType()が呼ばれる。(ボックス化)
その際HasValue == trueの場合はT型に、falseの場合はnullにボックス化される。(Nullable&lt;int&gt;にはボックス化されない)
int型にボックス化されるため、intを返す
*Console.WriteLine($"nullableThree type is {nullableThree.GetType()}");
nullにボックス化されるため、NullReferenceExceptionの例外発生
*Console.WriteLine(nullValue.GetType());
*Console.WriteLine($"nullableThree is int = {nullableThree is int}");
is演算子も同様。n is intとn is int?は同じ結果を返す(Nullable&lt;int&gt;に変えても同様)
*Console.WriteLine($"notNullTen is int? = {notNullTen is int?}");
int型の変数に対するn is int?に至っては「常にtrueを返すけどいい？」という注釈が出る
*Console.WriteLine($"IsNullableType(notNullTen) = {IsNullableType(notNullTen)}");
Nullable&lt;int&gt;とintの区別にはNullable.GetUnderlyingType(System名前空間)を使用する
リフレクションでプロパティやフィールドの型を取得した場合はNullable&lt;T&gt;になる
*Console.WriteLine(typeof(Foo).GetProperty(nameof(Foo.Value)).PropertyType);

*{/// <;summary>;/// An empty page that can be used on its own or navigated to within a Frame./// <;/summary>;public sealed partial class MainPage : Page{public static readonly DependencyProperty IssueItemProperty =DependencyProperty.Register(nameof(Item), typeof(IssueItem), typeof(MainPage), new PropertyMetadata(default(IssueItem)));public MainPage(){this.InitializeComponent();}public IssueItem Item{get =>; (IssueItem)GetValue(IssueItemProperty);set =>; SetValue(IssueItemProperty, value);}public IssueStatus[] StatusList =>; new[]{IssueStatus.Icebox,IssueStatus.Planned,IssueStatus.WIP,IssueStatus.Done,IssueStatus.Removed};public IssueType[] IssueTypeList =>; new[]{IssueType.Bug,IssueType.Feature,IssueType.Issue,IssueType.Task};protected override void OnNavigatedTo(NavigationEventArgs e){Item = new IssueItem{Id = 1232,Title = "Getting Started",Description = @"Create a page to enter Issues that we need to work on.## Acceptance Criteria- Display the issue Id- Provide an ability to select the issue Type (i.e. Bug, Feature, etc)- Include an Issue Title- Include a full issue description with support for Markdown- Include an issue effort- Include an ability for a developer to update the Status (i.e Icebox, WIP, etc)## Additional CommentsWe would like to have a visual indicator for the type of issue as well as something to visualize the effort involved",Effort = 3,Status = IssueStatus.WIP,Type = IssueType.Feature,CreatedAt = new DateTimeOffset(2019, 04, 03, 08, 0, 0, TimeSpan.FromHours(-8)),StartedAt = new DateTimeOffset(2019, 04, 30, 08, 0, 0, TimeSpan.FromHours(-8))};}// Sets the time when we Complete or Start an issue.private void StatusPicker_SelectionChanged(object sender, SelectionChangedEventArgs args){switch (Item.Status){case IssueStatus.Removed:case IssueStatus.Done:if (Item.CompletedAt is null)Item.CompletedAt = DateTimeOffset.Now.ToLocalTime();break;case IssueStatus.WIP:if (Item.StartedAt is null)Item.StartedAt = DateTimeOffset.Now.ToLocalTime();break;default:Item.StartedAt = null;Item.CompletedAt = null;break;}}// Provides a unique color based on the type of Issueprivate void IssueType_SelectionChanged(object sender, SelectionChangedEventArgs args){var color = Colors.Red;switch (IssueTypeBox.SelectedItem){case IssueType.Feature:color = Colors.Green;break;case IssueType.Issue:color = Colors.Blue;break;case IssueType.Task:color = Colors.Yellow;break;}IssueTypeIndicator.Background = new SolidColorBrush(color);}}}
The Blank Page item template is documented at http:go.microsoft.com/fwlink/?LinkId=402352&amp;clcid=0x409
*{switch (Item.Status){case IssueStatus.Removed:case IssueStatus.Done:if (Item.CompletedAt is null)Item.CompletedAt = DateTimeOffset.Now.ToLocalTime();break;case IssueStatus.WIP:if (Item.StartedAt is null)Item.StartedAt = DateTimeOffset.Now.ToLocalTime();break;default:Item.StartedAt = null;Item.CompletedAt = null;break;}}
Sets the time when we Complete or Start an issue.
*{var color = Colors.Red;switch (IssueTypeBox.SelectedItem){case IssueType.Feature:color = Colors.Green;break;case IssueType.Issue:color = Colors.Blue;break;case IssueType.Task:color = Colors.Yellow;break;}IssueTypeIndicator.Background = new SolidColorBrush(color);}
Provides a unique color based on the type of Issue

*var pa = (System.Windows.Controls.Panel)cc.Content;
Gridである場合もあるかもしれませんね。
なお、確実にChildrenの第1要素がButtonである場合は以下のように取得できています。
*var button = (System.Windows.Controls.Button)children[0];

*setting.VideoDeviceId = di.Id;
カメラ選択
調整しないと暗い場合があるので
*var vcon = mediaCapture.VideoDeviceController;
ビットマップにして表示
*System.IO.Stream stream = System.IO.WindowsRuntimeStreamExtensions.AsStream(randomAccessStream);

*Console.WriteLine("result name:{0}", result.Name);
var result = contexts.PetModels.Single(y=&gt;y.Id==1);
*Console.WriteLine("result name:{0}", result.Name);
var result = contexts.PetModels.First(y=&gt;y.Id==1);

*{}
Update is called once per frame
*{if (Input.GetKey(KeyCode.LeftArrow)){this.transform.position += Vector3.left * speed * Time.deltaTime;}if (Input.GetKey(KeyCode.RightArrow)){this.transform.position += Vector3.right * speed * Time.deltaTime;}}
Update is called once per frame
*{}
Start is called before the first frame update
*{}
Update is called once per frame

*httpClient.DeleteAsync(new URI("http:
samplebucket.s3.amazonaws.com"));

*{System.Console.WriteLine("start sample");/* sample code, but can't run with .net 2.0 , so commented outFunc<;string, bool>; handleFiles = (string path) =>; {Console.WriteLine(path);return true;};IEnumerable<;string>; results =BuildAndRunUtil.ProcessRecurcively("c:\\", "*.txt", handleFiles);*/System.Console.WriteLine("finish sample");}
--------------------------------------------------

*do { b = st.ReadByte(); } while (IsWhiteSpace(b));
skip whitespaces
奇数桁で終わっている場合は末尾に'0'を補填する( = (上位nibble&lt;&lt;4) + 0)
*ArrayAppend(ref ret, (byte)(upperNibble<;<;4));

*pg.WriteIndirectObj(5,"<;<;
Font &lt;&lt;F0 &lt;&lt;Type Font BaseFont Times-Roman Subtype Type1 &gt;&gt; &gt;&gt; &gt;&gt;");  [5] Resources

*//{//janken = Console.ReadLine();janken = jankMeNow.ToString();if (!(janken.Equals("0") || janken.Equals("1") || janken.Equals("2"))){Console.WriteLine("0か1か2で入れてください。");loopFlg = true;}else{loopFlg = false;}//}
while (loopFlg)

*modalViewController.ChangeText("hogehoge");
ChangeTextメソッド自体はprivateじゃないので呼び出せる

*public static void Sort(Dictionary<;GameObject,float<; itemTable)
取得したオブジェクトと距離のデータを距離が近い順でソートするメソッド

Rayを飛ばす初期位置を調整する
*position.y += adjast;
*if (raycastHit2D.Length == 0)*return false;
何も検知できなかった場合、処理を中断し、falseを返す

*_jumpInput.performed += callbackContext =>;*{
A事前にイベントを登録しておく
Buttonの入力はfloat
*var value = callbackContext.ReadValue<;float>;();
Enable()で有効化しないと動作しない
*_jumpInput.Enable();
*{private SampleControls.SampleMapsActions _sampleMapsActions = default;private void Awake(){// SampleControlsに登録したActionMapを生成ます。_sampleMapsActions = new SampleControls.SampleMapsActions(new SampleControls());// SampleControls.ISampleMapsActionsが実装されたクラスをSetCallbacksに指定します。_sampleMapsActions.SetCallbacks(this);}// SampleControls.ISampleMapsActionsによって定義されたMoveActionのコールバックpublic void OnMoveAction(InputAction.CallbackContext callbackContext){var value = callbackContext.ReadValue<;Vector2>;();Debug.Log($"position {value.x},{value.y}");}// SampleControls.ISampleMapsActionsによって定義されたJumpActionのコールバックpublic void OnJumpAction(InputAction.CallbackContext callbackContext){var value = callbackContext.ReadValue<;float>;();if (value >; 0){Debug.Log("On Jump.");}}private void OnEnable(){// 忘れずEnabl(）_sampleMapsActions.Enable();}private void OnDestroy(){// こっちはDisposeではなくDisable(）_sampleMapsActions.Disable();}}
生成されたクラスはI[ActionMap]インターフェスを持っているので、これを実装します。
SampleControlsに登録したActionMapを生成ます。
*_sampleMapsActions = new SampleControls.SampleMapsActions(new SampleControls());
SampleControls.ISampleMapsActionsが実装されたクラスをSetCallbacksに指定します。
*_sampleMapsActions.SetCallbacks(this);
*{var value = callbackContext.ReadValue<;Vector2>;();Debug.Log($"position {value.x},{value.y}");}
SampleControls.ISampleMapsActionsによって定義されたMoveActionのコールバック
*{var value = callbackContext.ReadValue<;float>;();if (value >; 0){Debug.Log("On Jump.");}}
SampleControls.ISampleMapsActionsによって定義されたJumpActionのコールバック
忘れずEnabl(）
*_sampleMapsActions.Enable();
こっちはDisposeではなくDisable(）
*_sampleMapsActions.Disable();

*Hoge hoge;
ローカル変数

*data[4 * (i + j * width) + 3] = c.Item1;
alpha
サーマル画像を作成
*WriteableBitmap bitmap = new WriteableBitmap(width, height);
EEPROM読み出し
*this.MLX90640_DumpEE();

*listener.Prefixes.Add("http:
192.168.0.16:80");
POSTする対象のURL
*string url = "ウェブフック用URL";
*var json = "{ \"content\" : \"hoge\"}";
POSTメソッドで渡すパラメータ

文字列を置換するようなﾋﾞｼﾞﾈｽﾛｼﾞｯｸ（もしあれば）
string str1 = Result.Replace("ω", "　");
str1 = str1.Replace("Ω", "\t");
*string str1 = Result

*public SelectList Genres { get; set; }
Requires using Microsoft.AspNetCore.Mvc.Rendering;
*if (!string.IsNullOrEmpty(SearchString)) {movies = movies.Where(s =>; s.Title.Contains(SearchString));}
Moviesをフィルタリング
ジャンル一覧を生成
*var genreList = await _context.Movies.OrderBy(m =>; m.Genre)

*var html = wc.DownloadString( $@"https:
www.nike.comjp" ); OK!!!

*Dispose();
-&gt; &lt;&gt;m__Finally1() -&gt; &lt;&gt;7__wrap1.Dispose()

*_mediaPlayer.URL = @"sound.wav";
mp3も使用可能

別の関数でもリストの値を使いたい。
*Function2(dataEnumerator);
*for (int i = 0; i <; 2; i++)*{
この中でも、dataEnumerator.MoveNext()を呼び出して、値をいくつか消費する。

*if (aCube.TargetPosition.x <; 3.0f) aCube.TargetPosition.x = 0.0f;
ある程度右へ行ったら最初の位置へ
var aPos = aCube.TargetPosition; わざわざ1回変数に入れるの無駄に見えるので
var bPos = bCube.TargetPosition;
bCube.TargetPosition = aCube.transform.localPosition; 入れ替えたいキューブの位置を直接指定
*aCube.TargetPosition = bCube.transform.localPosition;

*string hashed = string.Concat(hash.Select(b =<; $"{b:x2}"));
-&gt; 93541bd68ccf06f3d4f9cf56a3ca415f1d2d315f3f672ecec9f52b0c7c3ad9fc

*{// トランザクション開始using (var transaction = context.Database.BeginTransaction()){// 1つ目の SaveChanges()var product = await context.Products.SingleAsync(p =>; p.ProductID == 1).ConfigureAwait(false);product.ProductName = "New Product Name";await context.SaveChangesAsync().ConfigureAwait(false);// 2つ目の SaveChanges()var employee = await context.Employees.SingleAsync(e =>; e.EmployeeID == 1).ConfigureAwait(false);employee.Title = "New Title";await context.SaveChangesAsync().ConfigureAwait(false);// まとめてコミットtransaction.Commit();}}
コンテキスト
*{// 1つ目の SaveChanges()var product = await context.Products.SingleAsync(p =>; p.ProductID == 1).ConfigureAwait(false);product.ProductName = "New Product Name";await context.SaveChangesAsync().ConfigureAwait(false);// 2つ目の SaveChanges()var employee = await context.Employees.SingleAsync(e =>; e.EmployeeID == 1).ConfigureAwait(false);employee.Title = "New Title";await context.SaveChangesAsync().ConfigureAwait(false);// まとめてコミットtransaction.Commit();}
トランザクション開始
1つ目の SaveChanges()
*var product = await context.Products.SingleAsync(p =>; p.ProductID == 1).ConfigureAwait(false);
2つ目の SaveChanges()
*var employee = await context.Employees.SingleAsync(e =>; e.EmployeeID == 1).ConfigureAwait(false);
まとめてコミット
*transaction.Commit();
*{// あらかじめ接続を開いておく。sqlConnection.Open();// トランザクション開始using (var transaction = sqlConnection.BeginTransaction()){// 1つ目のコンテキストで保存using (var context = new NorthwindContext(sqlConnection, false)){context.Database.UseTransaction(transaction);var product = await context.Products.SingleAsync(p =>; p.ProductID == 1).ConfigureAwait(false);product.ProductName = "New Product Name";await context.SaveChangesAsync().ConfigureAwait(false);}// 2つ目のコンテキストで保存using (var context = new NorthwindContext(sqlConnection, false)){context.Database.UseTransaction(transaction);var employee = await context.Employees.SingleAsync(e =>; e.EmployeeID == 1).ConfigureAwait(false);employee.Title = "New Title";await context.SaveChangesAsync().ConfigureAwait(false);}// まとめてコミットtransaction.Commit();}}
接続準備
あらかじめ接続を開いておく。
*sqlConnection.Open();
*{// 1つ目のコンテキストで保存using (var context = new NorthwindContext(sqlConnection, false)){context.Database.UseTransaction(transaction);var product = await context.Products.SingleAsync(p =>; p.ProductID == 1).ConfigureAwait(false);product.ProductName = "New Product Name";await context.SaveChangesAsync().ConfigureAwait(false);}// 2つ目のコンテキストで保存using (var context = new NorthwindContext(sqlConnection, false)){context.Database.UseTransaction(transaction);var employee = await context.Employees.SingleAsync(e =>; e.EmployeeID == 1).ConfigureAwait(false);employee.Title = "New Title";await context.SaveChangesAsync().ConfigureAwait(false);}// まとめてコミットtransaction.Commit();}
トランザクション開始
*{context.Database.UseTransaction(transaction);var product = await context.Products.SingleAsync(p =>; p.ProductID == 1).ConfigureAwait(false);product.ProductName = "New Product Name";await context.SaveChangesAsync().ConfigureAwait(false);}
1つ目のコンテキストで保存
*{context.Database.UseTransaction(transaction);var employee = await context.Employees.SingleAsync(e =>; e.EmployeeID == 1).ConfigureAwait(false);employee.Title = "New Title";await context.SaveChangesAsync().ConfigureAwait(false);}
2つ目のコンテキストで保存
まとめてコミット
*transaction.Commit();
*{:/// <;summary>;/// コンストラクタ。/// <;/summary>;/// <;param name="existingConnection">;コンテキストで使用する接続。<;/param>;/// <;param name="contextOwnsConnection">;false を指定すると、コンテキストが Dispose されたときに接続を Dispose しない。<;/param>;public NorthwindContext(DbConnection existingConnection, bool contextOwnsConnection): base(existingConnection, contextOwnsConnection){}/// <;summary>;/// 接続文字列を取得する。/// <;/summary>;/// <;returns>;<;/returns>;public static string GetConnectionString(){using (var context = new NorthwindContext()){return context.Database.Connection.ConnectionString;}}:}
コンテキストクラス

初期化時は点灯状態
*is_active = true;
初回サイクルを短めに設定
*count = cycle - 5;
1秒間隔
*delay(1000);
*if (count == cycle){*count = 0;
1サイクル区切りでチェック
*if (!is_active &amp;&amp; is_reacts){*// 点灯
消灯時にセンサーの反応があったら
点灯
*analogWrite(LED_PIN, 250);
再カウント
*count = 0;
*if (digitalRead(PIR_PIN) == HIGH){*is_reacts = true;
センサに反応があった場合

スレッドの終了を待機
*backgroundWorker1.CancelAsync();
スレッドの終了を待機
*backgroundWorker1.CancelAsync();

*arcfour.Encrypt(ms, msDest, buf.Length);
decrypt
endobjが見つかるまでのデータをASCIIにして出力。(単語単位では検索してないのでよくない)
可読でない文字は ? に置き換える。
stream...endstreamはそのまま出力。
*static string GetPreviewData(FileStream fs)
たまたま "endobj" を構成する文字がすべて別の文字なので、検索アンマッチ時は単純に pos=0に戻しているだけでよいが、
"aab"とかだと "aaab"から検索していると"aa"のあと"ab"から検索が始まってとりこぼすおそれがある。
*pos = 0;

*MemoryStream src  = new MemoryStream(plain, false);
第2引数=falseでreadonly

この時点でcs.Task.IsCompletedはTrue
*return await cs.Task;

*public static readonly GenbaCatType ItsOkIThink = new ExtendedGenbaCatType(2);
それで大丈夫だと思います。
GenbaCatType dog = new GenbaCatType(); できません
GenbaCatType monkey; これはできちゃう(中身はnull)
Console.WriteLine(catNoProblem == catOk); False
Console.WriteLine(catNoProblem == GenbaCatType.NoProblem); True
*}

*string action = "Item";
Attack,Defense,Magic,Item,Escapeのどれかを""の中に入れる

プレイヤーのモデルは主にchildのところにいますので、ご忘れないように追加しましょう…
*public GameObject PlayerModel;

木構造の構築
ITreeItem を実装するクラスのリストと、 ITreeItem から ITreeNode を生成するメソッドを渡す。
渡す ITreeItem のリストは、Left順にソートしてある必要がある。
木構造が構築されて、ルートノードのリストが返ってくる。
*var roots = TreeBuilder.Rebuild(items, item =>; new Node(item));
木構造を表示したり、何らかの操作を加える
Left、Rightの更新
ルートノードのリストと、ITreeNode から ITreeItem を取得するメソッドを渡す。
ITreeItem はnodeの中に持っておくと便利。もしくはディクショナリにでもしておく。
*TreeBuilder.Update(roots, node =>; node.Item);

*{while(true){while(true){// ローカル変数をそのまま参照できる！counter++;// Return文でローカル巻子を抜ける ＝ 多重ループを抜けるif(counter >;= 10) return;}}}
多重ループをローカル関数で囲う
ローカル変数をそのまま参照できる！
*counter++;
*if(counter >;= 10) return;*}
Return文でローカル巻子を抜ける ＝ 多重ループを抜ける
ローカル関数を実行
*DoIt();
*Console.WriteLine($"counter={counter}");
do some other things here
*Console.WriteLine($"counter={counter}");
結果

ユーザが入力したパスワード
*string userInputPassword = "";
正解のパスワード
*string correctPassword = "3333";
*{}
パスワードの入力
*{if (correctPassword == userInputPassword){// 正解！}else{// 不正解}}
正解を確認する
正解！
*}
不正解
*}

*return;
DB has been seeded

*LineSeries.StrokeThickness = 2;
線の太さ
点を追加
*LineSeries.Points.Add(new DataPoint(1.0, 10.0 + 10.0 * i));
線グラフをモデルに追加
*Model.Series.Add(LineSeries);
セットした内容を反映させる
*Model.InvalidatePlot(true);
*{public object Convert(object value, Type targetType, object parameter, CultureInfo culture){if (value is LineSeries ls){var oc = ls.Color;return new SolidColorBrush(Color.FromArgb(oc.A, oc.R, oc.G, oc.B));}return null;}public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture){throw new NotImplementedException();}}
OxyColorから通常のColorのBrushに戻すコンバータ。

*using (var certificate = await GetCertificateAsync("https:
qiita.com"))

呼び出される側のスクリプト. GameObjectにアタッチしない.
StartやUpdateを使わないため, MonoBehaviourは不要.
他のスクリプトから読み込むため, publicを付ける.
*public class Callee
呼び出される変数
*public int exampleNumber = 17;
*{Debug.Log("Good!");}
呼び出されるメソッド
*{void Start(){// Another.csのCalleeのインスタンス化Callee _Callee = new Callee();// 変数の呼び出し.int _exampleNumber = _Callee.exampleNumber;Debug.Log("Eample number is " + _exampleNumber);// メソッドの呼び出し._Callee.Sup();}}
呼び出す側のスクリプト. GameObjectにアタッチする.
Another.csのCalleeのインスタンス化
*Callee _Callee = new Callee();
変数の呼び出し.
*int _exampleNumber = _Callee.exampleNumber;
メソッドの呼び出し.
*_Callee.Sup();

*private static Uri DevelopmentServerEndpoint { get; } = new Uri($"http:
localhost:{Port}");
*{services.AddControllers();// connect vue app - middlewareservices.AddSpaStaticFiles(options =>; options.RootPath = "client-app/dist");}
This method gets called by the runtime. Use this method to add services to the container.
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.app.UseHsts();}app.UseHttpsRedirection();app.UseRouting();app.UseAuthorization();app.UseEndpoints(endpoints =>;{endpoints.MapControllers();});// use middleware and launch server for Vueapp.UseSpaStaticFiles();app.UseSpa(spa =>;{spa.Options.SourcePath = "client-app";if (env.IsDevelopment()){spa.UseVueDevelopmentServer();}});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*{public enum CipherSuitesEnum{TLS_NULL_WITH_NULL_NULL = 0x0000,TLS_RSA_WITH_NULL_MD5 = 0x0001,TLS_RSA_WITH_NULL_SHA = 0x0002,TLS_RSA_EXPORT_WITH_RC4_40_MD5 = 0x0003,TLS_RSA_WITH_RC4_128_MD5 = 0x0004,TLS_RSA_WITH_RC4_128_SHA = 0x0005,TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = 0x0006,TLS_RSA_WITH_IDEA_CBC_SHA = 0x0007,TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x0008,TLS_RSA_WITH_DES_CBC_SHA = 0x0009,TLS_RSA_WITH_3DES_EDE_CBC_SHA = 0x000A,TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = 0x000B,TLS_DH_DSS_WITH_DES_CBC_SHA = 0x000C,TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = 0x000D,TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x000E,TLS_DH_RSA_WITH_DES_CBC_SHA = 0x000F,TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = 0x0010,TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = 0x0011,TLS_DHE_DSS_WITH_DES_CBC_SHA = 0x0012,TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 0x0013,TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x0014,TLS_DHE_RSA_WITH_DES_CBC_SHA = 0x0015,TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 0x0016,TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = 0x0017,TLS_DH_anon_WITH_RC4_128_MD5 = 0x0018,TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = 0x0019,TLS_DH_anon_WITH_DES_CBC_SHA = 0x001A,TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = 0x001B,/** Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are reserved to avoid* collision with Fortezza-based cipher suites in SSL 3.*//** RFC 3268*/TLS_RSA_WITH_AES_128_CBC_SHA = 0x002F,TLS_DH_DSS_WITH_AES_128_CBC_SHA = 0x0030,TLS_DH_RSA_WITH_AES_128_CBC_SHA = 0x0031,TLS_DHE_DSS_WITH_AES_128_CBC_SHA = 0x0032,TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 0x0033,TLS_DH_anon_WITH_AES_128_CBC_SHA = 0x0034,TLS_RSA_WITH_AES_256_CBC_SHA = 0x0035,TLS_DH_DSS_WITH_AES_256_CBC_SHA = 0x0036,TLS_DH_RSA_WITH_AES_256_CBC_SHA = 0x0037,TLS_DHE_DSS_WITH_AES_256_CBC_SHA = 0x0038,TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 0x0039,TLS_DH_anon_WITH_AES_256_CBC_SHA = 0x003A,/** RFC 5932*/TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0041,TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = 0x0042,TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0043,TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = 0x0044,TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0045,TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = 0x0046,TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0084,TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = 0x0085,TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0086,TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = 0x0087,TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0088,TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = 0x0089,TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BA,TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BB,TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BC,TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BD,TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BE,TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BF,TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C0,TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C1,TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C2,TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C3,TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C4,TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C5,/** RFC 4162*/TLS_RSA_WITH_SEED_CBC_SHA = 0x0096,TLS_DH_DSS_WITH_SEED_CBC_SHA = 0x0097,TLS_DH_RSA_WITH_SEED_CBC_SHA = 0x0098,TLS_DHE_DSS_WITH_SEED_CBC_SHA = 0x0099,TLS_DHE_RSA_WITH_SEED_CBC_SHA = 0x009A,TLS_DH_anon_WITH_SEED_CBC_SHA = 0x009B,/** RFC 4279*/TLS_PSK_WITH_RC4_128_SHA = 0x008A,TLS_PSK_WITH_3DES_EDE_CBC_SHA = 0x008B,TLS_PSK_WITH_AES_128_CBC_SHA = 0x008C,TLS_PSK_WITH_AES_256_CBC_SHA = 0x008D,TLS_DHE_PSK_WITH_RC4_128_SHA = 0x008E,TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = 0x008F,TLS_DHE_PSK_WITH_AES_128_CBC_SHA = 0x0090,TLS_DHE_PSK_WITH_AES_256_CBC_SHA = 0x0091,TLS_RSA_PSK_WITH_RC4_128_SHA = 0x0092,TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = 0x0093,TLS_RSA_PSK_WITH_AES_128_CBC_SHA = 0x0094,TLS_RSA_PSK_WITH_AES_256_CBC_SHA = 0x0095,/** RFC 4492*/TLS_ECDH_ECDSA_WITH_NULL_SHA = 0xC001,TLS_ECDH_ECDSA_WITH_RC4_128_SHA = 0xC002,TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC003,TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 0xC004,TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 0xC005,TLS_ECDHE_ECDSA_WITH_NULL_SHA = 0xC006,TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = 0xC007,TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC008,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 0xC009,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 0xC00A,TLS_ECDH_RSA_WITH_NULL_SHA = 0xC00B,TLS_ECDH_RSA_WITH_RC4_128_SHA = 0xC00C,TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = 0xC00D,TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 0xC00E,TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 0xC00F,TLS_ECDHE_RSA_WITH_NULL_SHA = 0xC010,TLS_ECDHE_RSA_WITH_RC4_128_SHA = 0xC011,TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = 0xC012,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 0xC013,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 0xC014,TLS_ECDH_anon_WITH_NULL_SHA = 0xC015,TLS_ECDH_anon_WITH_RC4_128_SHA = 0xC016,TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = 0xC017,TLS_ECDH_anon_WITH_AES_128_CBC_SHA = 0xC018,TLS_ECDH_anon_WITH_AES_256_CBC_SHA = 0xC019,/** RFC 4785*/TLS_PSK_WITH_NULL_SHA = 0x002C,TLS_DHE_PSK_WITH_NULL_SHA = 0x002D,TLS_RSA_PSK_WITH_NULL_SHA = 0x002E,/** RFC 5054*/TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = 0xC01A,TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = 0xC01B,TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = 0xC01C,TLS_SRP_SHA_WITH_AES_128_CBC_SHA = 0xC01D,TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = 0xC01E,TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = 0xC01F,TLS_SRP_SHA_WITH_AES_256_CBC_SHA = 0xC020,TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = 0xC021,TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = 0xC022,/** RFC 5246*/TLS_RSA_WITH_NULL_SHA256 = 0x003B,TLS_RSA_WITH_AES_128_CBC_SHA256 = 0x003C,TLS_RSA_WITH_AES_256_CBC_SHA256 = 0x003D,TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = 0x003E,TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = 0x003F,TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = 0x0040,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 0x0067,TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = 0x0068,TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = 0x0069,TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = 0x006A,TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 0x006B,TLS_DH_anon_WITH_AES_128_CBC_SHA256 = 0x006C,TLS_DH_anon_WITH_AES_256_CBC_SHA256 = 0x006D,/** RFC 5288*/TLS_RSA_WITH_AES_128_GCM_SHA256 = 0x009C,TLS_RSA_WITH_AES_256_GCM_SHA384 = 0x009D,TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = 0x009E,TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = 0x009F,TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = 0x00A0,TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = 0x00A1,TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = 0x00A2,TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = 0x00A3,TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = 0x00A4,TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = 0x00A5,TLS_DH_anon_WITH_AES_128_GCM_SHA256 = 0x00A6,TLS_DH_anon_WITH_AES_256_GCM_SHA384 = 0x00A7,/** RFC 5289*/TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC023,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC024,TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC025,TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC026,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 0xC027,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 0xC028,TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 0xC029,TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 0xC02A,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02B,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02C,TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02D,TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02E,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xC02F,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xC030,TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 0xC031,TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 0xC032,/** RFC 5487*/TLS_PSK_WITH_AES_128_GCM_SHA256 = 0x00A8,TLS_PSK_WITH_AES_256_GCM_SHA384 = 0x00A9,TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = 0x00AA,TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = 0x00AB,TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = 0x00AC,TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = 0x00AD,TLS_PSK_WITH_AES_128_CBC_SHA256 = 0x00AE,TLS_PSK_WITH_AES_256_CBC_SHA384 = 0x00AF,TLS_PSK_WITH_NULL_SHA256 = 0x00B0,TLS_PSK_WITH_NULL_SHA384 = 0x00B1,TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = 0x00B2,TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = 0x00B3,TLS_DHE_PSK_WITH_NULL_SHA256 = 0x00B4,TLS_DHE_PSK_WITH_NULL_SHA384 = 0x00B5,TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = 0x00B6,TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = 0x00B7,TLS_RSA_PSK_WITH_NULL_SHA256 = 0x00B8,TLS_RSA_PSK_WITH_NULL_SHA384 = 0x00B9,/** RFC 5489*/TLS_ECDHE_PSK_WITH_RC4_128_SHA = 0xC033,TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = 0xC034,TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = 0xC035,TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = 0xC036,TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = 0xC037,TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = 0xC038,TLS_ECDHE_PSK_WITH_NULL_SHA = 0xC039,TLS_ECDHE_PSK_WITH_NULL_SHA256 = 0xC03A,TLS_ECDHE_PSK_WITH_NULL_SHA384 = 0xC03B,/** RFC 5746*/TLS_EMPTY_RENEGOTIATION_INFO_SCSV = 0x00FF,/** RFC 6367*/TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC072,TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC073,TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC074,TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC075,TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC076,TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC077,TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC078,TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC079,TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC07A,TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC07B,TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC07C,TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC07D,TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC07E,TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC07F,TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = 0xC080,TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = 0xC081,TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = 0xC082,TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = 0xC083,TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = 0xC084,TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = 0xC085,TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC086,TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC087,TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC088,TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC089,TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC08A,TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC08B,TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC08C,TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC08D,TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 0xC08E,TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 0xC08F,TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 0xC090,TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 0xC091,TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 0xC092,TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 0xC093,TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC094,TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC095,TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC096,TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC097,TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC098,TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC099,TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC09A,TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC09B,/** RFC 6655*/TLS_RSA_WITH_AES_128_CCM = 0xC09C,TLS_RSA_WITH_AES_256_CCM = 0xC09D,TLS_DHE_RSA_WITH_AES_128_CCM = 0xC09E,TLS_DHE_RSA_WITH_AES_256_CCM = 0xC09F,TLS_RSA_WITH_AES_128_CCM_8 = 0xC0A0,TLS_RSA_WITH_AES_256_CCM_8 = 0xC0A1,TLS_DHE_RSA_WITH_AES_128_CCM_8 = 0xC0A2,TLS_DHE_RSA_WITH_AES_256_CCM_8 = 0xC0A3,TLS_PSK_WITH_AES_128_CCM = 0xC0A4,TLS_PSK_WITH_AES_256_CCM = 0xC0A5,TLS_DHE_PSK_WITH_AES_128_CCM = 0xC0A6,TLS_DHE_PSK_WITH_AES_256_CCM = 0xC0A7,TLS_PSK_WITH_AES_128_CCM_8 = 0xC0A8,TLS_PSK_WITH_AES_256_CCM_8 = 0xC0A9,TLS_PSK_DHE_WITH_AES_128_CCM_8 = 0xC0AA,TLS_PSK_DHE_WITH_AES_256_CCM_8 = 0xC0AB,/** RFC 7251*/TLS_ECDHE_ECDSA_WITH_AES_128_CCM = 0xC0AC,TLS_ECDHE_ECDSA_WITH_AES_256_CCM = 0xC0AD,TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = 0xC0AE,TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = 0xC0AF,/** RFC 7507*/TLS_FALLBACK_SCSV = 0x5600,/** draft-ietf-tls-chacha20-poly1305-04*/DRAFT_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA8,DRAFT_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA9,DRAFT_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAA,DRAFT_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAB,DRAFT_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAC,DRAFT_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAD,DRAFT_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAE,/** draft-zauner-tls-aes-ocb-04 (code points TBD)*/DRAFT_TLS_DHE_RSA_WITH_AES_128_OCB = 0xFF00,DRAFT_TLS_DHE_RSA_WITH_AES_256_OCB = 0xFF01,DRAFT_TLS_ECDHE_RSA_WITH_AES_128_OCB = 0xFF02,DRAFT_TLS_ECDHE_RSA_WITH_AES_256_OCB = 0xFF03,DRAFT_TLS_ECDHE_ECDSA_WITH_AES_128_OCB = 0xFF04,DRAFT_TLS_ECDHE_ECDSA_WITH_AES_256_OCB = 0xFF05,DRAFT_TLS_PSK_WITH_AES_128_OCB = 0xFF10,DRAFT_TLS_PSK_WITH_AES_256_OCB = 0xFF11,DRAFT_TLS_DHE_PSK_WITH_AES_128_OCB = 0xFF12,DRAFT_TLS_DHE_PSK_WITH_AES_256_OCB = 0xFF13,DRAFT_TLS_ECDHE_PSK_WITH_AES_128_OCB = 0xFF14,DRAFT_TLS_ECDHE_PSK_WITH_AES_256_OCB = 0xFF15,}}
from Org.BouncyCastle.Crypto.Tls.CipherSuite.cs ver 1.8.5

*e.Handled = true;
追加

*else if (t is MemoryStream) {var ms = t as MemoryStream;using ( var fs = new FileStream(destPath+".dat", FileMode.Create) ) {ms.WriteTo(fs);}}
Console.WriteLine(t);

*static readonly byte[]  InitialVerticalForceData        = { 0x00, 0x00, 0x00, 0x00, 0x00 };
初期加速度
*{OnGround,Jumping}
地面にいるかジャンプ中か
1フレ前のジャンプボタンの押下状態
*private bool JumpBtnPrevPress = false;
*{StartYpos = y;ResetParam();}
constructor
*if (PosYi >;= StartYpos)*{
着地判定
定数での上昇
*PosYi = PosYi - DY_I;
フレームカウンタ値から整数・少数を算出する
*int Breg = (Counter >;>; 4) &amp; 0x0f;
フレームカウンタ値による位置更新
*PosYi = PosYi + Breg;

*Console.WriteLine(str.Substring(index+length));
$'

*proj.AddBuildProperty(target, "OTHER_LDFLAGS", "-ObjC");
必須！

*{return await db.Set<;TEntity>;().FirstOrDefaultAsync(expression);}
Generic Repository
引数をLinq Expressionからidへ修正
*_customerRepository.GetOneByIdAsync(id);
引数をLinq Expressionからidへ修正
*_supplierRepository.GetOneByIdAsync(id.Value);
省略
Repository
*services.AddScoped(typeof(IRepository<;>;), typeof(GenericRepository<;>;));
省略
*}

コマンド生成：①
*ExecuteDelegateCommand = new DelegateCommand(Execute, CanExecute);
コマンド生成：②
*DelegateCommandObservesProperty = new DelegateCommand(Execute, CanExecute).ObservesProperty(() =>; IsEnabled);
コマンド生成：③
*DelegateCommandObservesCanExecute = new DelegateCommand(Execute).ObservesCanExecute(() =>; IsEnabled);
コマンド生成：④
*ExecuteGenericDelegateCommand = new DelegateCommand<;string>;(ExecuteGeneric).ObservesCanExecute(() =>; IsEnabled);

*[SerializeField] public float eyeHeight = 1.0f;
ターゲットの視点の高さ

*var salesTaxRate = new SalesTaxRate(birthday);
型が異なるのでコンパイルが通らない
*{_date = DateTime.Now;}
契約締結時に呼び出す用
*{_date = date;}
リポジトリからの読み出し用
*{_date = date;}
制約を無視した勝手なインスタンス生成を利用側にされないようprivateにする
*{return new ContractDate(DateTime.Now);}
契約締結時に呼び出す用
リポジトリからの読み出し用
リポジトリ以外からの生成に利用されないようinternalにする
*internal static ContractDate Reconstruct(DateTime date)
*{// ここで契約日と消費税施行日とを比較し、消費税率を決定する。,,,/// <;summary>;適用された消費税率<;/summary>;public class AppliedSalesTaxRate{private readonly decimal _rate;// コンストラクタで契約日を受け取るpublic AppliedSalesTaxRate(ContractDate contractDate){// ここで契約日と消費税施行日とを比較し、消費税率を決定する。,,,/// <;summary>;消費税適用ルール<;/summary>;internal class SalesTaxApplyRule{private readonly List<;SalesTax>; _salesTaxes;internal SalesTaxApplyRule(){_salesTaxes = new List<;SalesTax>;();// 最新の施行日から順に格納すること。// (開発者が順番を気にしなくても良いように設計するのがホントは望ましい)_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2019, 10, 1), rate: 0.10m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2014,  4, 1), rate: 0.08m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1997,  4, 1), rate: 0.05m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1989,  4, 1), rate: 0.03m));}internal decimal ApplyRule(ContractDate contractDate){var corresponded = _salesTaxes.Find(tax =>; tax.EnforcementDate <;= contractDate.Value);return corresponded != null ? corresponded.Rate : 0.00m;}},,,/// <;summary>;適用された消費税率<;/summary>;public class AppliedSalesTaxRate{// 税適用ルールは1つあれば良く、複数生成させないようstatic readonlyとする。private static readonly SalesTaxApplyRule _salesTaxApplyRule = new SalesTaxApplyRule();private readonly decimal _rate;public decimal Value { get { return _rate; } }public AppliedSalesTaxRate(ContractDate contractDate){_rate = _salesTaxApplyRule.ApplyRule(contractDate);}},,,/// <;summary>;税込金額<;/summary>;public class AmountIncludingTax{private readonly int _amount;public int Value { get { return _amount; } }public AmountIncludingTax(AmountExcludingTax amountExcludingTax,AppliedSalesTaxRate appliedSalesTaxRate){_amount = (int)(amountExcludingTax.Value * (1m + appliedSalesTaxRate.Value));}},,,/// <;summary>;税抜き金額<;/summary>;public class AmountExcludingTax{private readonly int _amount;public int Value { get { return _amount; } }/// <;summary>;コンストラクタ<;/summary>;/// <;param name="amount">;税抜き金額<;/param>;public AmountExcludingTax(int amount){if (!IsValid(amount)){throw new ArgumentOutOfRangeException();}_amount = amount;}/// <;summary>;税抜き金額を加算する<;/summary>;/// <;param name="amountExcludingTax">;税抜き金額<;/param>;/// <;returns>;税抜き金額<;/returns>;public AmountExcludingTax Add(AmountExcludingTax amountExcludingTax){return new AmountExcludingTax(_amount + amountExcludingTax._amount);}/// <;summary>;有効な税抜き金額であるかを返す<;/summary>;/// <;param name="amount">;税抜き金額<;/param>;/// <;returns>;有効な場合true<;/returns>;private static bool IsValid(int amount){return 0 <;= amount;}},,,/// <;summary>;契約日<;/summary>;public class ContractDate{private readonly DateTime _date;public DateTime Value { get { return _date; } }/// <;summary>;コンストラクタ<;/summary>;/// <;param name="date">;契約日<;/param>;/// <;remarks>;制約を無視した勝手なインスタンス生成を利用側にされないようprivateにしている。<;/remarks>;private ContractDate(DateTime date){_date = date;}/// <;summary>;契約締結時に呼び出す。<;/summary>;/// <;returns>;契約日<;/returns>;public static ContractDate Conclude(){return new ContractDate(DateTime.Now);}/// <;summary>;リポジトリから読み出した時に呼び出す。<;/summary>;/// <;param name="date">;リポジトリから読み出した契約日<;/param>;/// <;returns>;契約日<;/returns>;/// <;remarks>;リポジトリ以外からの生成に利用されないようinternalにしている。<;/remarks>;internal static ContractDate Reconstruct(DateTime date){return new ContractDate(date);}},,,/// <;summary>;消費税<;/summary>;internal class SalesTax{/// <;summary>;施行日<;/summary>;internal readonly DateTime EnforcementDate;/// <;summary>;税率<;/summary>;internal readonly decimal Rate;/// <;summary>;消費税<;/summary>;/// <;param name="enforcementDate">;施行日<;/param>;/// <;param name="rate">;税率<;/param>;internal SalesTax(DateTime enforcementDate, decimal rate){if (!IsValidRate(rate)){throw new ArgumentOutOfRangeException();}EnforcementDate = enforcementDate;Rate = rate;}/// <;summary>;有効な税率かどうかを返す<;/summary>;/// <;param name="rate">;税率<;/param>;/// <;returns>;有効な場合true<;/returns>;private static bool IsValidRate(decimal rate){return 0m <;= rate;}},,,/// <;summary>;消費税適用ルール<;/summary>;internal class SalesTaxApplyRule{private readonly List<;SalesTax>; _salesTaxes;internal SalesTaxApplyRule(){_salesTaxes = new List<;SalesTax>;();// 最新の施行日から順に格納すること。// (開発者が順番を気にしなくても良いように設計するのがホントは望ましい)_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2019, 10, 1), rate: 0.10m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2014,  4, 1), rate: 0.08m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1997,  4, 1), rate: 0.05m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1989,  4, 1), rate: 0.03m));}/// <;summary>;消費税ルールを適用する<;/summary>;/// <;param name="contractDate">;契約日<;/param>;/// <;returns>;適用された消費税率<;/returns>;internal decimal ApplyRule(ContractDate contractDate){var corresponded = _salesTaxes.Find(tax =>; tax.EnforcementDate <;= contractDate.Value);return corresponded != null ? corresponded.Rate : 0.00m;}},,,/// <;summary>;適用された消費税率<;/summary>;public class AppliedSalesTaxRate{private static readonly SalesTaxApplyRule _salesTaxApplyRule = new SalesTaxApplyRule();private readonly decimal _rate;public decimal Value { get { return _rate; } }/// <;summary>;コンストラクタ<;/summary>;/// <;param name="contractDate">;契約日<;/param>;public AppliedSalesTaxRate(ContractDate contractDate){_rate = _salesTaxApplyRule.ApplyRule(contractDate);}},,,/// <;summary>;税込金額<;/summary>;public class AmountIncludingTax{private readonly int _amount;public int Value { get { return _amount; } }/// <;summary>;コンストラクタ<;/summary>;/// <;param name="amountExcludingTax">;税抜き金額<;/param>;/// <;param name="appliedSalesTaxRate">;適用された消費税率<;/param>;public AmountIncludingTax(AmountExcludingTax amountExcludingTax,AppliedSalesTaxRate appliedSalesTaxRate){_amount = (int)(amountExcludingTax.Value * (1m + appliedSalesTaxRate.Value));}},,,ここで契約日と消費税施行日とを比較し、消費税率を決定する。
*,,,
*{// ここで契約日と消費税施行日とを比較し、消費税率を決定する。,,,/// <;summary>;消費税適用ルール<;/summary>;internal class SalesTaxApplyRule{private readonly List<;SalesTax>; _salesTaxes;internal SalesTaxApplyRule(){_salesTaxes = new List<;SalesTax>;();// 最新の施行日から順に格納すること。// (開発者が順番を気にしなくても良いように設計するのがホントは望ましい)_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2019, 10, 1), rate: 0.10m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2014,  4, 1), rate: 0.08m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1997,  4, 1), rate: 0.05m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1989,  4, 1), rate: 0.03m));}internal decimal ApplyRule(ContractDate contractDate){var corresponded = _salesTaxes.Find(tax =>; tax.EnforcementDate <;= contractDate.Value);return corresponded != null ? corresponded.Rate : 0.00m;}},,,/// <;summary>;適用された消費税率<;/summary>;public class AppliedSalesTaxRate{// 税適用ルールは1つあれば良く、複数生成させないようstatic readonlyとする。private static readonly SalesTaxApplyRule _salesTaxApplyRule = new SalesTaxApplyRule();private readonly decimal _rate;public decimal Value { get { return _rate; } }public AppliedSalesTaxRate(ContractDate contractDate){_rate = _salesTaxApplyRule.ApplyRule(contractDate);}},,,/// <;summary>;税込金額<;/summary>;public class AmountIncludingTax{private readonly int _amount;public int Value { get { return _amount; } }public AmountIncludingTax(AmountExcludingTax amountExcludingTax,AppliedSalesTaxRate appliedSalesTaxRate){_amount = (int)(amountExcludingTax.Value * (1m + appliedSalesTaxRate.Value));}},,,/// <;summary>;税抜き金額<;/summary>;public class AmountExcludingTax{private readonly int _amount;public int Value { get { return _amount; } }/// <;summary>;コンストラクタ<;/summary>;/// <;param name="amount">;税抜き金額<;/param>;public AmountExcludingTax(int amount){if (!IsValid(amount)){throw new ArgumentOutOfRangeException();}_amount = amount;}/// <;summary>;税抜き金額を加算する<;/summary>;/// <;param name="amountExcludingTax">;税抜き金額<;/param>;/// <;returns>;税抜き金額<;/returns>;public AmountExcludingTax Add(AmountExcludingTax amountExcludingTax){return new AmountExcludingTax(_amount + amountExcludingTax._amount);}/// <;summary>;有効な税抜き金額であるかを返す<;/summary>;/// <;param name="amount">;税抜き金額<;/param>;/// <;returns>;有効な場合true<;/returns>;private static bool IsValid(int amount){return 0 <;= amount;}},,,/// <;summary>;契約日<;/summary>;public class ContractDate{private readonly DateTime _date;public DateTime Value { get { return _date; } }/// <;summary>;コンストラクタ<;/summary>;/// <;param name="date">;契約日<;/param>;/// <;remarks>;制約を無視した勝手なインスタンス生成を利用側にされないようprivateにしている。<;/remarks>;private ContractDate(DateTime date){_date = date;}/// <;summary>;契約締結時に呼び出す。<;/summary>;/// <;returns>;契約日<;/returns>;public static ContractDate Conclude(){return new ContractDate(DateTime.Now);}/// <;summary>;リポジトリから読み出した時に呼び出す。<;/summary>;/// <;param name="date">;リポジトリから読み出した契約日<;/param>;/// <;returns>;契約日<;/returns>;/// <;remarks>;リポジトリ以外からの生成に利用されないようinternalにしている。<;/remarks>;internal static ContractDate Reconstruct(DateTime date){return new ContractDate(date);}},,,/// <;summary>;消費税<;/summary>;internal class SalesTax{/// <;summary>;施行日<;/summary>;internal readonly DateTime EnforcementDate;/// <;summary>;税率<;/summary>;internal readonly decimal Rate;/// <;summary>;消費税<;/summary>;/// <;param name="enforcementDate">;施行日<;/param>;/// <;param name="rate">;税率<;/param>;internal SalesTax(DateTime enforcementDate, decimal rate){if (!IsValidRate(rate)){throw new ArgumentOutOfRangeException();}EnforcementDate = enforcementDate;Rate = rate;}/// <;summary>;有効な税率かどうかを返す<;/summary>;/// <;param name="rate">;税率<;/param>;/// <;returns>;有効な場合true<;/returns>;private static bool IsValidRate(decimal rate){return 0m <;= rate;}},,,/// <;summary>;消費税適用ルール<;/summary>;internal class SalesTaxApplyRule{private readonly List<;SalesTax>; _salesTaxes;internal SalesTaxApplyRule(){_salesTaxes = new List<;SalesTax>;();// 最新の施行日から順に格納すること。// (開発者が順番を気にしなくても良いように設計するのがホントは望ましい)_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2019, 10, 1), rate: 0.10m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2014,  4, 1), rate: 0.08m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1997,  4, 1), rate: 0.05m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1989,  4, 1), rate: 0.03m));}/// <;summary>;消費税ルールを適用する<;/summary>;/// <;param name="contractDate">;契約日<;/param>;/// <;returns>;適用された消費税率<;/returns>;internal decimal ApplyRule(ContractDate contractDate){var corresponded = _salesTaxes.Find(tax =>; tax.EnforcementDate <;= contractDate.Value);return corresponded != null ? corresponded.Rate : 0.00m;}},,,/// <;summary>;適用された消費税率<;/summary>;public class AppliedSalesTaxRate{private static readonly SalesTaxApplyRule _salesTaxApplyRule = new SalesTaxApplyRule();private readonly decimal _rate;public decimal Value { get { return _rate; } }/// <;summary>;コンストラクタ<;/summary>;/// <;param name="contractDate">;契約日<;/param>;public AppliedSalesTaxRate(ContractDate contractDate){_rate = _salesTaxApplyRule.ApplyRule(contractDate);}},,,/// <;summary>;税込金額<;/summary>;public class AmountIncludingTax{private readonly int _amount;public int Value { get { return _amount; } }/// <;summary>;コンストラクタ<;/summary>;/// <;param name="amountExcludingTax">;税抜き金額<;/param>;/// <;param name="appliedSalesTaxRate">;適用された消費税率<;/param>;public AmountIncludingTax(AmountExcludingTax amountExcludingTax,AppliedSalesTaxRate appliedSalesTaxRate){_amount = (int)(amountExcludingTax.Value * (1m + appliedSalesTaxRate.Value));}},,,ここで契約日と消費税施行日とを比較し、消費税率を決定する。
*,,,
最新の施行日から順に格納すること。
(開発者が順番を気にしなくても良いように設計するのがホントは望ましい)
*_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2019, 10, 1), rate: 0.10m));
税適用ルールは1つあれば良く、複数生成させないようstatic readonlyとする。
*private static readonly SalesTaxApplyRule _salesTaxApplyRule = new SalesTaxApplyRule();
最新の施行日から順に格納すること。
(開発者が順番を気にしなくても良いように設計するのがホントは望ましい)
*_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2019, 10, 1), rate: 0.10m));

*{public class Factory : PlaceholderFactory<;Foo>;{}}
Pooling を行わない悪い実装例
*{_fooFactory = fooFactory;}
Constructor Injection
*{_foos.Add(_fooFactory.Create());}
AddFoo を呼び出たびに、新しいヒープメモリが割り当てられる
RemoveFoo が呼び出されるたびに、FooSpawnerからFooに対する参照が1つずつ失われ
最終的にガーベージコレクタによって回収される。その際、スパイクが発生してしまう。
*public void RemoveFoo()
*{}
Factoryと異なり、PlaceholderFactoryではなくMemoryPoolを継承する。
*{_fooPool = fooPool;}
Constructor Injection
AddFoo を呼び出たすと、生成時には新しくヒープが割り当てられるが、
未使用のFooがある場合そちらが再利用される。
*public void AddFoo()
Pool.Spawn()によってFooを生成、再利用する
*_foos.Add(_fooPool.Spawn());
RemoveFoo が呼び出されるとFooSpawnerからはFooに対する参照は失われるが
Pool内に未使用のFooとして山荘が残される。
*public void RemoveFoo()
Pool.Despawn()によってPoolに使用していたFooを戻す
*_fooPool.Despawn(foo);
BindFactoryではなくBindMemoryPoolになる
*Container.BindMemoryPool<;Foo, Foo.Pool>;();
*{protected override void OnCreated(Foo item){// オブジェクトがプールされた直後に呼ばれます。}protected override void OnDestroyed(Foo item){// オブジェクトがプールから削除された時によばれます。// WithMaxSizeを設定したときや、ShrinkBy、ResizeメソッドによってPoolのサイズ// が明示的に縮小したときに発生します。}protected override void OnSpawned(Foo item){// オブジェクトがPoolから取り出されたときに呼ばれます。}protected override void OnDespawned(Foo item){// オブジェクトがPoolに戻されたときに呼ばれます。}protected override void Reinitialize(int index, Foo foo){// OnSpawnedと呼ばれるタイミングはほぼ同じです。// ただし、Pool.Spawn（）で渡された引数はここで渡されます。foo.Reset(index);}}
パラメータを追加する場合は、引数を追加する。
オブジェクトがプールされた直後に呼ばれます。
*}
オブジェクトがプールから削除された時によばれます。
WithMaxSizeを設定したときや、ShrinkBy、ResizeメソッドによってPoolのサイズ
が明示的に縮小したときに発生します。
*}
オブジェクトがPoolから取り出されたときに呼ばれます。
*}
オブジェクトがPoolに戻されたときに呼ばれます。
*}
OnSpawnedと呼ばれるタイミングはほぼ同じです。
ただし、Pool.Spawn（）で渡された引数はここで渡されます。
*foo.Reset(index);
パラメータを追加するとSpawnに引数が追加される。
*_fooPool.Spawn(_index);
*{private IMemoryPool _pool = default;public void Dispose(){_pool.Despawn(this);}public void OnDespawned(){_pool = null;}// 生成時に呼ばれる。初期化を書くのはここpublic void OnSpawned(IMemoryPool pool){_pool = pool;}//　Factoryの時と同様にPlaceholderFactoryの派生クラスを作る。public class Factory : PlaceholderFactory<;Foo>;{}}
IPoolable&lt;IMemoryPool&gt;、IDisposableを実装する
*{_pool = pool;}
生成時に呼ばれる。初期化を書くのはここ
*{}
Factoryの時と同様にPlaceholderFactoryの派生クラスを作る。
Factory と同様にCreate()でオブジェクトを生成できる。
*_foos.Add(_factory.Create());
Poolに戻すときはDispose()を呼ぶ。
*foo.Dispose();
FromPoolableMemoryPoolを追加する
*Container.BindFactory<;Foo, Foo.Factory>;()
*{}
IL2CPP AOT エラーが発生する場合があるので、Poolクラスは明確に定義する必要がある。
*_originalParent = item.transform.parent;*}
Record the original parent which will be set to whatever is used in the UnderTransform method
*{transform.position = Vector3.zero;_pool = pool;_velocity = velocity;}
Create()で渡された引数がここに渡される
*{}
Factoryになり派生クラスにResetを描く必要がなくなった
SpawnからCreateに
*_foos.Add(_fooFactory.Create(
DespawnからDisposeに
*foo.Dispose();
本来ここではFromMonoPoolableMemoryPoolを用いますが、IL2CPPのAOTを回避するために
Poolクラスを明示的に宣言してFromPoolableMemoryPoolを使用します。
*.FromPoolableMemoryPool<;Vector3, Foo, FooPool>;(
*{}
IL2CPP AOT エラーが発生する場合があるので、Poolクラスは明確に定義する必要がある。

*model.SelectId = id;
選択したくじ番号をセット

*if (!ModelState.IsValid)*return View(model);
入力エラーがある時は何もしない
*if (name == "set")*{
[結果を設定する]ボタンを押下した場合
*while (model.NumberOfKuji <; model.Result.Count)*{
くじの数が減った場合は、結果入力欄を減らす
*while (model.NumberOfKuji >; model.Result.Count)*{
くじの数が増えた場合は、結果入力欄を増やす
くじコントローラーを呼ぶ
*return RedirectToAction("Index", "Kuji");
受け取ったTempDataからデータを取得する
*var json = TempData["kuji"]?.ToString();

*{if (!ModelState.IsValid){return Page();}_context.Movies.Add(Movie);await _context.SaveChangesAsync();return RedirectToPage("./Index");}
more details see https:aka.ms/RazorPagesCRUD.

*public string Title { get; set; }
タイトル
*public int NumberOfKuji { get; set; }
くじの数
*public List<;ResultModel>; Result { get; set; }
くじの結果
*public int SelectId { get; set; }
選択したくじ番号
*public string Item { get; set; }
内容
モデルのインスタンスを生成し、ビューに渡す
*var model = new KujiModel();
新しいくじモデルをビューに渡す
*var model = new KujiModel();
*if (!ModelState.IsValid)*return View(model);
入力エラーがある時は何もしない
*if (name == "set")*{
[結果を設定する]ボタンを押下した場合
*while (model.NumberOfKuji <; model.Result.Count)*{
くじの数が減った場合は、結果入力欄を減らす
*while (model.NumberOfKuji >; model.Result.Count)*{
くじの数が増えた場合は、結果入力欄を増やす
くじコントローラーを呼ぶ
*return RedirectToAction("Index", "Kuji");

*const string sayConst;
変数と区別するためにsayの後ろにConstを加えました
*void Start() {string say = "Hello World";Debug.Log(say);const string sayConst = "Hello World2";Debug.Log(say);}
例

*receiveBuffer.Length);
data buffer
*if (radioButtonNone.Checked) {id.Replace("-", string.Empty);} else if (radioButtonSpace.Checked) {id.Replace("-", " ");}
バイナリ文字列の整形
データグリッドビューに結果を追加し、連番をカウントアップする
*int seq = (int)numericUpDown.Value;

*.SkipWhile(e =<; e.Text != "https:
qiita.comdraftsnew").Skip(1)
*bool hasNew = Enumerable.Range(0, Math.Min(notificationBitmap.Width, notificationBitmap.Height))*.Any(xy =>; notificationBitmap.GetPixel(xy, xy).ToArgb() == arrivalBackgroundArgb);
左上から右下に向けて赤を探す（背景が赤なら見つかるはず）
新着の中に「いいね」はあるかは色では判定できません。
上のテキストによる検証と同じになるので省略します。
*}

*ushort delayTimeEndFrame = 100;
unit:[10ms]
最後のdelayを長くする
*bmps[bmps.Count-1].delayTime = delayTimeEndFrame;
*MyGifEncorder.SaveAnimatedGif("out.gif", bmps, LoopCount);*}
生成

〇〇で使う変数群
public const int a=1;    〇〇の数値a
public const int b=5;    〇〇の力量b
public const int c=10;   〇〇のスピードc
*}
Dataクラスの中の情報を呼び出す。
*Debug.Log("a:" + Data.a);
SerializeDataクラスの情報
*private static SerializeData serializeData;
*{serializeData = serializedata;}
シーン上にあるSerializeDataクラスを取得する。
*{get { return serializeData.obj; }}
ゲッターでSerializeDataクラスの情報を拾う。
ここで、"Serialize"というTag名のオブジェクトにアタッチされているSerializeDataクラスの情報をDataクラスに渡している。
*Data.OnStart(GameObject.FindGameObjectWithTag("Serialize").GetComponent<;SerializeData>;());
データクラスから呼び出す。
*Debug.Log("obj:" + Data.obj.name);

*var tokenResponse = await context.AcquireTokenAsync("https:
management.azure.com", clientCredential);
注意：Microsoft.Azure.Management.Storage.Fluent ではない
*var tenantId= "00000000-0000-0000-0000-000000000000";

*string hexhex = mHexHex.Groups[0].Value;
2桁の16進文字列 ("12"とか"fc"とか)
*//if ( x == (int)'\r' ) { return "\r"; }*//if ( x == (int)'\n' ) { return "\n"; }
if ( x == (int)'\t' ) { return "\t"; }
*//if ( x == (int)'\n' ) { return "\n"; }*return ";"+x.ToString("X2")+">;";
if ( x == (int)'\r' ) { return "\r"; }

*sf.LineAlignment = StringAlignment.Center;
縦中央 ・・・ にならない（？）
下記の各Y座標(pixel単位)で横線を引いてみた
float fontHeight = font.GetHeight(g);  g: 描画に使用するGraphicsクラス
*float ascentHeight  = fontHeight * ascent  / emHeight;

*sf.LineAlignment = StringAlignment.Center;
縦中央

*public string StudentNumber { get; set; }
生徒番号
*public string Name { get; set; }
名前
*public string BloodType { get; set; }
血液型
*public string Department { get; set; }
組
*public int National { get; set; }
国語
*public int Mathematics { get; set; }
算数
*{StudentNumber = studentNumber;Name = name;BloodType = bloodType;Department = department;National = national;Mathematics = mathematics;}
コンストラクタ
*.OrderBy(value =>; Array.IndexOf(new[] { "O", "A", "AB", "B" }, value.BloodType))
血液型のソート
*.ThenBy(value =>; Array.IndexOf(new[] { "B", "C", "A" }, value.Department))
組のソート

*var sendBuffer = new byte[] { 0xff, 0xca, 0x00, 0x00, 0x00 };
← IDmを取得するコマンド
受信データからIDmを抽出する
recvBuffer = IDm + SW1 + SW2 (SW = StatusWord)
SW1 = 0x90 (144) SW1 = 0x00 (0) で正常だが、ここでは見ていない
*string cardId = BitConverter.ToString(recvBuffer, 0, pcbRecvLength - 2);

*{}
Start is called before the first frame update
*{}
Update is called once per frame

*using System.Windows.Forms;
フォーム: Form, Button, TextBox, ...

*{}
Start is called before the first frame update
*{bool isUpdate = false;#if UNITY_EDITORif (Input.GetMouseButtonDown(0) || Input.GetMouseButton(1)){isUpdate = true;}#elseif (Input.touchCount == 1 &amp;&amp; Input.touches[0].phase == TouchPhase.Began){isUpdate = true;}else if (Input.touchCount == 2){isUpdate = true;}else if (Input.touchCount == 3){_aggregate.Clear();}#endifif (isUpdate){Random rand = new Random();_aggregate.Add((int)(rand.NextDouble() * 100));}}
Update is called once per frame

*Position = 0
先頭位置からの再生を意味するが、streamを新規にnewするときは不要なはず
再生
*player.Play();
*while (player.PlaybackState == PlaybackState.Playing)*{
待ち（ここ調査不足）
停止
*player.Stop();

*Width = RouletteEllipse.Width
2,                   ルーレットの円の半分
ルーレットを回すためのStoryBoardを検索
*var sb = FindResource("StartRoulettea") as Storyboard;
回転開始(スタート)
*sb.Begin();
回転停止(ストップ)
*sb.Pause();

このスクリプトをプロジェクト下に置くだけで実行されます。
エディター拡張機能なので Editor フォルダに置くと良いです。
*using UnityEngine;
シーンビュー上のイベントを取得するためのメソッドを追加
※この方法でないとメソッド内で全イベントが取得できない
*SceneView.onSceneGUIDelegate += onSceneGUIDelegate;
*if (scene.in2DMode)*return;
3Dモード時にマウススクロールにトレースする
カーソルの画面中央からの差を計算
*var center = new Vector2(scene.position.width, scene.position.height) * 0.5f;
カメラの中心を拡大率に比例してカーソル方向に動かす
*var pivot = scene.pivot;

*if (_instance == null)*{
Singleton
*if (currentCamera.cameraType != CameraType.SceneView)*#endif
Sceneビューには必ず映す
*if (line.RenderCamera != null &amp;&amp; currentCamera != line.RenderCamera)*{
It is not a camera for drawing this line.
*if ((currentCamera.cullingMask &amp; line.LayerMask) == 0)*{
The current camera does not draw this layer.
Preview Cameraの場合、選択中のカメラの中にRenderCameraと一致するカメラがあるかチェックする
Camera.current.cameraType == CameraType.Previewではチェックできない(PreviewCameraもCameraType.Gameになる)ので名前で判定
*if (currentCamera.name == PREVIEW_CAMERA_NAME)
位置、角度、マスクなどの情報から一致するカメラを推測
推測制度を高めたい場合は一致させるデータを増やす
*if (currentCamera.transform.position == camera.transform.position &amp;&amp;
*{}
Start is called before the first frame update
*{var sPos = _startObject.transform.position;var ePos = _endObject.transform.position;// 色指定無し、カメラ指定有りDebugLineDrawer.DrawLine(sPos, ePos, camera: Camera.main);// 色指定無しの場合のカラーを変更DebugLineDrawer.SetColor(Color.green);// 色指定無し、カメラ指定有りDebugLineDrawer.DrawLine(sPos + Vector3.up, ePos + Vector3.up, camera: Camera.main);// 色指定有り、カメラ指定無しDebugLineDrawer.DrawLine(sPos + Vector3.up * 2, ePos + Vector3.up * 2, Color.red);// 色指定無し、カメラ指定有りDebugLineDrawer.DrawLine(sPos + Vector3.up * 3, ePos + Vector3.up * 3, camera: Camera.main);// 色指定有り、カメラ指定無し、Mask指定有りDebugLineDrawer.DrawLine(sPos + Vector3.up * 4, ePos + Vector3.up * 4, Color.cyan, layerMask: LayerMask.GetMask("UI"));// 色指定無し、カメラ指定無しDebugLineDrawer.DrawRay(sPos, Vector3.up * 2);// 色指定有り、カメラ指定無しDebugLineDrawer.DrawRay(sPos + Vector3.up * 2, Vector3.up * 2, Color.yellow);}
Update is called once per frame
色指定無し、カメラ指定有り
*DebugLineDrawer.DrawLine(sPos, ePos, camera: Camera.main);
色指定無しの場合のカラーを変更
*DebugLineDrawer.SetColor(Color.green);
色指定無し、カメラ指定有り
*DebugLineDrawer.DrawLine(sPos + Vector3.up, ePos + Vector3.up, camera: Camera.main);
色指定有り、カメラ指定無し
*DebugLineDrawer.DrawLine(sPos + Vector3.up * 2, ePos + Vector3.up * 2, Color.red);
色指定無し、カメラ指定有り
*DebugLineDrawer.DrawLine(sPos + Vector3.up * 3, ePos + Vector3.up * 3, camera: Camera.main);
色指定有り、カメラ指定無し、Mask指定有り
*DebugLineDrawer.DrawLine(sPos + Vector3.up * 4, ePos + Vector3.up * 4, Color.cyan, layerMask: LayerMask.GetMask("UI"));
色指定無し、カメラ指定無し
*DebugLineDrawer.DrawRay(sPos, Vector3.up * 2);
色指定有り、カメラ指定無し
*DebugLineDrawer.DrawRay(sPos + Vector3.up * 2, Vector3.up * 2, Color.yellow);

*{void DoSomething(ConsoleAppOptions options);}
interface

*{
enumの定義

終端文字を追加する。
*var replyMsg = client.WriteLineAndGetReply(textBox_SendMsg.Text + '\0', TimeSpan.FromSeconds(3));

*const int TestTimes = 1001;
中央値を取りたいので奇数回にする。
明示的にGCを呼び出すことで、途中でGCが発生しにくくする。
*GC.Collect();
*{// 下行のコメントアウトを外してLoadTimeTest_ascii.exe として保存 ・・・ 表中の「ASCII」// File.ReadAllLines("tmp_ascii.txt",System.Text.Encoding.ASCII);// 下行のコメントアウトを外してコンパイルし LoadTimeTest_no_opt.exe として保存 ・・・ 表中の「no_opt (UTF-8)」// File.ReadAllLines("tmp_ascii.txt");// 下行のコメントアウトを外してLoadTimeTest_utf16le.exe として保存 ・・・ 表中の「UTF-16 LE」// File.ReadAllLines("tmp_utf16le.txt",System.Text.Encoding.Unicode);}
計測開始
下行のコメントアウトを外してLoadTimeTest_ascii.exe として保存 ・・・ 表中の「ASCII」
File.ReadAllLines("tmp_ascii.txt",System.Text.Encoding.ASCII);
下行のコメントアウトを外してコンパイルし LoadTimeTest_no_opt.exe として保存 ・・・ 表中の「no_opt (UTF-8)」
File.ReadAllLines("tmp_ascii.txt");
下行のコメントアウトを外してLoadTimeTest_utf16le.exe として保存 ・・・ 表中の「UTF-16 LE」
File.ReadAllLines("tmp_utf16le.txt",System.Text.Encoding.Unicode);
*}
計測結果を取得
*measuredTicks[i] = sw.ElapsedTicks;
中央値を取得
*Array.Sort(measuredTicks);

*objPool.SetActive(new Vector3(0f, 10f, 0f));
使用

ステージにギミックをランダムに発生させる
*funcGimmick[UnityEngine.Random.Range(0, funcGimmick.Length - 1)];
ステージが落ちる
*return 0;
ステージが跳ねる
*return 0;

角度の初期化
*NowRotation = new Vector3(-360, 0, 0);
現在の角度と画面にタッチしたVector3値の和を格納し、Update関数を終了
*StartFrick = Input.mousePosition + NowRotation;
マウスでクリックし続けてる間のみ、
現在のタッチしているVector3値とStartFrickの差分で角度を変更する
*NowRotation = StartFrick - Input.mousePosition;

*static RestSharp.RestClient client= new RestSharp.RestClient("http:
weather.livedoor.comforecastwebservicejsonv1");

*{return rootElement.FindFirst(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.AutomationIdProperty, automationId));}
指定したID属性に一致するAutomationElementを返します
*{return rootElement.FindAll(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.NameProperty, name)).Cast<;AutomationElement>;();}
指定したName属性に一致するAutomationElementをすべて返します
*{const string BUTTON_CLASS_NAME = "Button";return from x in FindElementsByName(rootElement, name)where x.Current.ClassName == BUTTON_CLASS_NAMEselect x;}
指定したName属性に一致するボタン要素をすべて返します
*{return rootElement.FindAll(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.ControlTypeProperty, controlType));}
指定したControlType属性に一致する要素をすべて返します

星の画像
*ImageView starImage;
星画像を表示する
*starImage.Visibility = Android.Views.ViewStates.Visible;
アニメーション開始
*var waitAnimation = AnimationUtils.LoadAnimation(this, Resource.Animation.wait_animation);
*starImage.Animation.AnimationEnd += (sender, e) =>; {// 星画像を非表示にするstarImage.Visibility = Android.Views.ViewStates.Gone;selectedDateLabel.Text = time.ToString("yyyy年MM月dd日")+ $"\r\nあなたは、{GetEto(time.Year)}年 {GetSeiza(time.Month, time.Day)}です。";};
アニメーション完了イベント
星画像を非表示にする
*starImage.Visibility = Android.Views.ViewStates.Gone;

*itemList[index] = ITEM.NONE;
アイテムを使用したので空にする;

*Debug.Log(code.ToString() + " のボタンが押されたよ！！");
コンソールに表示

十二支
*private const string ETO = "申酉戌亥子丑寅卯辰巳午未";
*private static Tuple<;string, int, int>;[] SEIZA = {Tuple.Create("牡羊座", 321, 419),Tuple.Create("牡牛座", 420, 520),Tuple.Create("双子座", 521, 621),Tuple.Create("蟹座", 622, 722),Tuple.Create("獅子座", 723, 822),Tuple.Create("乙女座", 823, 922),Tuple.Create("天秤座", 923, 1023),Tuple.Create("蠍座", 1024, 1122),Tuple.Create("射手座", 1123, 1221),Tuple.Create("山羊座", 1222, 1231),Tuple.Create("山羊座", 101, 120),Tuple.Create("水瓶座",121, 218),Tuple.Create("魚座", 219, 320)};
星座

*{// 非表示Visible = false,};
Excelアプリケーション生成
非表示
*Visible = false,
Bookを開く
*_workbook = _application .Workbooks.Open(@"e:\book1.xlsx");
全シートを選択する
*_workbook.Worksheets.Select();
ファイル名を指定してPDF形式で保存する
ExportAsFixedFormatメソッド: ブックを PDF または XPS 形式に発行する
Type    : タイプ   : XlFixedFormatType xlTypePDF=PDF, xlTypeXPS=XPS
Filename: 出力ファイル名
Quality : 種t力品質: XlFixedFormatQuality xlQualityStandard=標準品質, xlqualityminimum=最小限の品質
*_workbook.ExportAsFixedFormat(
TODO: Managed Objectの破棄
*}
*{excel.Open();if (excel.SaveAsPDF() == false)MessageBox.Show("ファイルが既に開かれています。\n閉じてから、再試行してください。","エラー",MessageBoxButtons.OK,MessageBoxIcon.Error);}
for Microsoft.Office.Interop.Excel

タグ
*public static readonly string TAG = "X:" + typeof(DatePickerFragment).Name.ToUpper();
*Action<;DateTime>; dateSelectedHandler = delegate { };
日付選択処理のデリゲート
SELECT DATEボタン
*Button dateSelectButton;
選択日付の表示ラベル
*TextView selectedDateLabel;

*var list = mat.SelectMany(r =<; r).ToList();
flatten

*Debug.Log(i);
→ 32768

*{StartInfo = new ProcessStartInfo(PYTHON_INTERPRITER){UseShellExecute = false,RedirectStandardOutput = true,Arguments = ARGUMENTS}}
プロセスの立ち上げ
プロセスの実行
*process.Start();
終了まで待ってから切断する
*process.WaitForExit();
M2Mqttの起動
*APPLICATION_ID = Guid.NewGuid().ToString();
*_mqttClient.MqttMsgPublishReceived += (sender, e) =>; {OnReceivedData(Encoding.UTF8.GetString(e.Message));};
購読設定
*{data = JsonConvert.DeserializeObject<;RasPiData>;(message);}
受信データのデシリアライズ
*{if (data.MessageType == MessageType.Record || data.MessageType == MessageType.PlayBack){PlayBackAndRecord(data.MessageType, data.Message);Log("Process succeeded.");}else{Log($"unexpected message arrived : {data.Message}");}}
メッセージが指定のJson形式だった場合
命令の種類を受け、Pythonアプリケーションの引数を指定
*var arguments = "";
*{StartInfo = new ProcessStartInfo(PYTHON_INTERPRITER){UseShellExecute = false,RedirectStandardOutput = true,Arguments = arguments},};
Pythonアプリケーションの起動・実行
M2Mqttの起動
*APPLICATION_ID = Guid.NewGuid().ToString();
コンソールで何の処理を行うかをユーザに尋ねる
*var program = new Program();

*{
enumの定義

*return Vector3.Cross(tmp1, tmp2);
Vector3.Crossは外積を求めるメソッド
*private float[] CalculateEquationOfPlane(Vector3 vec1, Vector3 vec2, Vector3 vec3, Vector3 normal) {float[] ans = new float[]{normal.x,normal.y,normal.z,-normal.x * vec1.x - normal.y * vec1.y - normal.z * vec1.z};return ans;}
このメソッドは、vec1,vec2,vec3の3点を通る平面の方程式ax+by+cz+d=0のa,b,c,dを配列で返す
*private Vector3 CalculateCoordinateOfIntersection(float[] plane, Vector3 angle, Vector3 position) {float parameter = -(plane[0] * position.x + plane[1] * position.y + plane[2] * position.z + plane[3]) / (plane[0] * angle.x + plane[1] * angle.y + plane[2] * angle.z);float x = angle.x * parameter + position.x;float y = angle.y * parameter + position.y;float z = angle.z * parameter + position.z;return new Vector3(x, y, z);}
このメソッドでは、カメラの視線とメッシュとの交点の座標が求められる
*private bool WhetherParameterIsPositive(float[] plane, Vector3 angle, Vector3 position) {float parameter = -(plane[0] * position.x + plane[1] * position.y + plane[2] * position.z + plane[3]) / (plane[0] * angle.x + plane[1] * angle.y + plane[2] * angle.z);return parameter >; 0;}
建てたい建築がカメラの正面にあるときにだけ建築できるようにする
*private bool WhetherDistanceIsProper(Vector3 vec0, Vector3 vec1, Vector3 vec2, Vector3 vec3) {Vector3 fromCameraToPlayer = player.transform.position - gameObject.transform.position;Vector3 fromCameraToBuilding = (vec0 + vec1 + vec2 + vec3) / 4 - gameObject.transform.position;return fromCameraToBuilding.magnitude >; fromCameraToPlayer.magnitude;}
カメラとプレイヤーとの間に建築されないようにする
*private bool WhetherIntersectionIsInsidePolygon(Vector3[] vertices, Vector3 intersection, Vector3 normal) {float angle_sum = 0f;for (int i = 0; i <; vertices.Length; i++) {Vector3 tmp1 = vertices[i] - intersection;Vector3 tmp2 = vertices[(i + 1) % vertices.Length] - intersection;float angle = Vector3.Angle(tmp1, tmp2);Vector3 cross = Vector3.Cross(tmp1, tmp2);if (Vector3.Dot(cross, normal) <; 0) angle *= -1;angle_sum += angle;}angle_sum /= 360f;return Mathf.Abs(angle_sum) >;= 0.1f;}
このメソッドは引用させていただきました
*private bool CanBuildWallAndStair(Vector3 vertex0, Vector3 vertex1, Vector3 vertex2, Vector3 vertex3) {Vector3[] vertices = new Vector3[] { vertex0, vertex1, vertex2, vertex3 };Vector3 normal = CalculateOuterProduct(vertices[0], vertices[1], vertices[2]);float[] abcd = CalculateEquationOfPlane(vertices[0], vertices[1], vertices[2], normal);Vector3 intersection = CalculateCoordinateOfIntersection(abcd, gameObject.transform.rotation * Vector3.forward, gameObject.transform.position);return WhetherIntersectionIsInsidePolygon(vertices, intersection, normal) &amp;&amp;WhetherDistanceIsProper(vertex0, vertex1, vertex2, vertex3) &amp;&amp;WhetherParameterIsPositive(abcd, gameObject.transform.rotation * Vector3.forward, gameObject.transform.position);}
壁と階段が建築できる条件
*private bool CanBuildFloor(Vector3 vec0, Vector3 vec1, Vector3 vec2, Vector3 vec3) {Vector3 target = (vec0 + vec1 + vec2 + vec3) / 4;Vector3 targetToCameraDirection = (target - gameObject.transform.position).normalized;if (Vector3.Dot(targetToCameraDirection, gameObject.transform.forward.normalized) >; 0.97) return true;else return false;}
床が建築できる条件
*if (Input.GetKeyDown("joystick button 5")) {*Calculate24Coordinates();
床の建築(RB)
*float x = gameObject.transform.localEulerAngles.x;*/*下の床*/
カメラが上の方を向いているか、下の方を向いているかを取得する
*else if (Input.GetKeyDown("joystick button 4")) {*Calculate24Coordinates();
壁の建築(LB)
*if (CanBuildWallAndStair(points[0], points[3], points[15], points[12])) Instantiate(wall, (points[0] + points[3] + points[15] + points[12]) / 4, Quaternion.Euler(0f, 0f, 90f));*else if (CanBuildWallAndStair(points[1], points[2], points[14], points[13])) Instantiate(wall, (points[1] + points[2] + points[14] + points[13]) / 4, Quaternion.Euler(0f, 0f, 90f));
pointsの数字によって壁を回転させなければならない
*else if (Input.GetKeyDown("joystick button 3")) {*Calculate24Coordinates();
階段の建築(Y)
*float cameraRotationY = gameObject.transform.localEulerAngles.y;*Vector3 pos = (points[0] + points[1] + points[2] + points[3] + points[12] + points[13] + points[14] + points[15]) / 8;
カメラが前後左右のどこを向いているか取得

アトリビュートの追加
*htmlAttributes.Add("class", "custom");

*using UnityEngine.UI;
これをつけ加え忘れるとエラーが出ます
*void Start () {webCamTexture = new WebCamTexture();rawImage.texture = webCamTexture;webCamTexture.Play();}
Start is called before the first frame update

どこに設定ファイルが保存されたかを出力
*Console.WriteLine("Configuration path:");

*using UnityEngine.UI;
UI.Textのために必要
eventData.pointerPressメンバから
どのTextObjectがクリックされたか受け取る
*ClickedTextObject =

定位置に戻る速度
*float m_moveSpeedAdjust = 10f;
腰との間隔
*float m_waistObjSpace = 0.2f;
視線判定の閾値
*float m_thresholdDot = -0.1f;
*{waistObjLocalPos = m_waistObj.transform.localPosition;m_waistSide = waistSide;if (m_waistSide == WAISTSIDE.LEFT){m_waistObj.transform.localPosition = new Vector3(-m_waistObjSpace, waistObjLocalPos.y, waistObjLocalPos.z);}else{m_waistObj.transform.localPosition = new Vector3(m_waistObjSpace, waistObjLocalPos.y, waistObjLocalPos.z);}}
腰のオブジェクトをどちら側で固定するか
*Quaternion waistRotation = this.gameObject.transform.parent.transform.rotation;*waistRotation.z = 0;
角度の制限
*Vector3 cameraPos = this.gameObject.transform.parent.position;*this.gameObject.transform.position = new Vector3(cameraPos.x, cameraPos.y-0.5f, cameraPos.z);
腰の位置の固定  0.5fは個人的にベストと感じた腰の位置
*float dot = Vector3.Dot(Vector3.down, this.gameObject.transform.parent.transform.forward);*waistObjLocalPos = m_waistObj.transform.localPosition;
顔面→腰のオブジェクト 、 顔面→顔面の正面  の内積　&gt; 閾値 ) ---＞ 前へ出てくる
*Quaternion waistRotation = this.gameObject.transform.parent.transform.rotation;*waistRotation.z = 0;
角度の制限
[SerializeField, Header("下を見ると腰のオブジェクトが前に飛び出る")]
*GameObject m_waistObj;
定位置に戻る速度
*float m_moveSpeedAdjust = 10f;
腰との間隔
*float m_waistObjSpace = 0.2f;
視線判定の閾値
*float m_thresholdDot = -0.1f;
腰とカメラの距離
*float m_waistHeight = 0.5f;
*{if (CheckChild() == false) return;waistObjLocalPos = m_waistObj.transform.localPosition;m_waistSide = waistSide;if (m_waistSide == WAISTSIDE.LEFT){m_waistObj.transform.localPosition = new Vector3(-m_waistObjSpace, waistObjLocalPos.y, waistObjLocalPos.z);}else{m_waistObj.transform.localPosition = new Vector3(m_waistObjSpace, waistObjLocalPos.y, waistObjLocalPos.z);}}
腰のオブジェクトをどちら側で固定するか
*{if (this.gameObject.transform.childCount >; 0){m_waistObj = this.gameObject.transform.GetChild(0).gameObject;return true;}else{m_waistObj = null;return false;}}
子が存在するか
*Quaternion waistRotation = this.gameObject.transform.parent.transform.rotation;*waistRotation.z = 0;
角度の制限
*Vector3 cameraPos = this.gameObject.transform.parent.position;*this.gameObject.transform.position = new Vector3(cameraPos.x, cameraPos.y - m_waistHeight, cameraPos.z);
腰の位置の固定
*if (CheckChild() == false) return;*//顔面→腰のオブジェクト 、 顔面→顔面の正面  の内積　>; 閾値 ) ---＞ 前へ出てくる
子が存在していたら腰のオブジェクトとして認識
*float dot = Vector3.Dot(Vector3.down, this.gameObject.transform.parent.transform.forward);*waistObjLocalPos = m_waistObj.transform.localPosition;
顔面→腰のオブジェクト 、 顔面→顔面の正面  の内積　&gt; 閾値 ) ---＞ 前へ出てくる
*{if (this.gameObject.transform.childCount >; 0){m_waistObj = this.gameObject.transform.GetChild(0).gameObject;return true;}else{m_waistObj = null;return false;}}
子が存在するか

*input.Type = 0;
MOUSE = 0

*else {
正規表現にはマッチしなかった。
次を検索させる。
*Console.WriteLine("Info: Regex mismatch. " + s);
RunApp()に処理を分離して属性指定している目的:
JITによるinline展開を禁止することで、
Mainメソッド内のGC.Collect()までに余計な(Wordの)COM参照オブジェクトが残らないことを期待する。
ただし、期待通りに動作しているかは確認していない。(そもそも要るのか不明。。)
*[MethodImpl(MethodImplOptions.NoInlining)]

デシリアライズ(jsonファイル→クラスオブジェクト)
*string jsonFilePath = @"TestData.json";
シリアライズ(クラスオブジェクト→jsonファイル)
*string jsonFilePathOut = @"TestDataOut.json";
終わり
*Console.WriteLine("json読み書き完了");

*public IExcelCrtOcx Xlsx { get; set; }
ExcelCreatorコントロール
テンプレートの情報
*private string _templateFile = string.Empty;
Xlsxインスタンス生成
*Xlsx = new Xlsx();
テンプレートの情報取得
*GetTemplateConfig();
ワークブックオープン(オープンするファイル名, オーバーレイ元ファイル名)
*Xlsx.OpenBook(filename, @"e:\book1.xlsx");
ワークシート設定
*Xlsx.SheetNo = Xlsx.SheetNo2["Sheet1"];
セル書込
*excelEC.Xlsx.Pos[sx:0, sy:1].Value = "test";
セル読取(R1C1形式)
*var cellValue1 = excelEC.Xlsx.Pos[sx: 0, sy: 1].Value;
セル読取("A1"形式)
*var cellValue2 = excelEC.Xlsx.Cell["A2"];
罫線を引く("A1:C3"に、実線、箱型、赤色で)
*excelEC.Xlsx.Cell["A1:C3"].Attr.Box(XlsxCrt.XLSX_BORDERSTYLE.xbsThin, XlsxCrt.XLSX_BOXTYPE.xbtBox, XlsxCrt.XLSX_COLOR.xclRed);
*if (excelEC.Close() == false)*{
クローズする

*return 3;
戻り値を返す命令

*{services.AddRazorPages();services.AddDbContext<;RazorPagesMovieContext>;(options =>;options.UseSqlite(Configuration.GetConnectionString("MovieContext")));}
This method gets called by the runtime. Use this method to add services to the container.

タイマー生成
*timer = CreateTimer();
タイマー生成(湯煎度はアイドル時に設定)
*var t = new DispatcherTimer(DispatcherPriority.SystemIdle);
タイマーイベントの発生間隔を300ミリ秒に設定
*t.Interval = TimeSpan.FromMilliseconds(300);
*{//タイマーイベントの発生時の処理をここに書く//　現在の時分秒をテキストに設定TextBlock.Text = DateTime.Now.ToString("HH:mm:ss");};
タイマーイベントの定義
タイマーイベントの発生時の処理をここに書く
現在の時分秒をテキストに設定
*TextBlock.Text = DateTime.Now.ToString("HH:mm:ss");
生成したタイマーを返す
*return t;
タイマー開始
*timer.Start();

*Employee empl_1 = new Employee("ichiro", 25, 123456, "system");
インスタンスを生成

*string url = String.Concat("http:
0.0.0.0:", port);
*// For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940*public void ConfigureServices(IServiceCollection services)
This method gets called by the runtime. Use this method to add services to the container.
*{}
For more information on how to configure your application, visit https:go.microsoft.com/fwlink/?LinkID=398940
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}app.UseRouting();app.UseEndpoints(endpoints =>;{endpoints.MapGet("/", async context =>;{var target = Environment.GetEnvironmentVariable("TARGET") ?? "World";await context.Response.WriteAsync($"Hello {target}!\n");});});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

Dispose処理は、下記のページを参考にしています。
[アンマネージドリソースをDisposeパターンで管理する]
(https:days-of-programming.blogspot.com/2018/04/dispose.html)
*#region "IDisposable Support"
TODO: Managed Objectの破棄
*}
*{// 非表示//Visible = trueVisible = false};
Excelアプリケーション生成
非表示
Visible = true
*Visible = false
Bookを開く
*_workbook = _application.Workbooks.Open(@"e:\book1.xlsx");
対象シートを設定する
*_worksheet = _workbook.Worksheets["Sheet1"];
ファイル名を指定して保存する
*_workbook.SaveCopyAs(@"e:\book2.xlsx");
セルを指定
*var cells = _worksheet.Cells;
値を設定
*range.Value = value;
cell解放
*Marshal.ReleaseComObject(range);
Excelファイルを開く
*var fileInfo = new FileInfo(@"e:\book1.xlsx");
シート名で参照
*_excelWorksheet = _excelPackage.Workbook.Worksheets["Sheet1"];
値を書込
*_excelWorksheet.Cells[row, col].Value = value;
値を書込
*_excelWorksheet.Cells[address].Value = value;
セル読取
*return _excelWorksheet.Cells[row, col].Value;
セル読取
*return _excelWorksheet.Cells[address].Value;
レンジ読取
*return (object[,])_excelWorksheet.Cells[rowFrom, colFrom, rowTo, colTo].Value;
レンジ読取
*return (object[,])_excelWorksheet.Cells[addresso].Value;
セル書込(R1C1形式)
*excelEx.WriteCell(row: 1, col: 1, value : "test");
セル書込("A1"形式)
*excelEx.WriteCell(address: "A1", value: 3.1415926538);
セル読取(R1C1形式)
*var cellValue1 = excelEx.ReadCell(row: 1, col: 1);
セル読取("A1"形式)
*var cellValue2 = excelEx.ReadCell("A1");
レンジ読取(R1C1R2C2形式)
*var rangeValue1 = excelEx.ReadRange(rowFrom: 1, colFrom: 1, rowTo: 2, colTo: 2);
レンジ読取("A1:B2"形式)
*var rangeValue2 = excelEx.ReadRange("A1:B2");
２次元配列(0始まり)から要素を参照
var a = rangeValue2[0, 0];     aには、3.1415926538が入る
名前を付けて保存する
*if (excelEx.SaveAs(@"e:\book2.xlsx") == false)

*this.Controls.Add(pdfOcx);
フォームにコントロールを追加
PDF ブラウザコントロールに指定したPDFファイルを表示する
*pdfOcx.LoadFile(@"E:\test.pdf");

DataFormats.FileDropを与えて、GetDataPresent()メソッドを呼び出す。
*var files = (string[])e.Data.GetData(DataFormats.FileDrop, false);
GetDataの戻り値はstring型の配列であり、
複数のファイルがドロップされた場合には
ドロップされた複数のファイル名が取得できる。
*for (int i = 0; i <; files.Length; i++) {
GetDataにより取得したString型の配列から要素を取り出す。
*var fileName = files[i];
マウスポインター形状変更

DragDropEffects
Copy  :データがドロップ先にコピーされようとしている状態
Move  :データがドロップ先に移動されようとしている状態
Scroll:データによってドロップ先でスクロールが開始されようとしている状態、あるいは現在スクロール中である状態
All   :上の3つを組み合わせたもの
Link  :データのリンクがドロップ先に作成されようとしている状態
None  :いかなるデータもドロップ先が受け付けようとしない状態
*if (e.Data.GetDataPresent(DataFormats.FileDrop))

*{/* OCRハンドラの作成と初期化 */ocrHandle = IntPtr.Zero;ocrHandle = TessBaseAPICreate();if(ocrHandle.Equals(IntPtr.Zero)) Debug.Log("Error:Cannot Create");string dataPath = Application.dataPath + "/tessdata";if(TessBaseAPIInit3(ocrHandle, dataPath, "eng") != 0) Debug.Log("Error:Cannot Init");/* テクスチャから文字を認識する */string recognition = RecognizeFromTexture();output.GetComponent<;Text>;().text = recognition;}
Start is called before the first frame update

どうやって書けばいい？
ここでansを計算して、awaitで待って、この後にansを表示させるなどしたい。
*var ans = await？？？ table.Select(async？？？(x) =>; ？？？);
非同期版の計算メソッド
*await Task.Delay(1000);
★★数値tableに100を足す計算をSelectで行い、それをTask.WhenAllで包む★★
*var ans = await Task.WhenAll(table.Select(async (x) =>; await Add100(x)));
*{Debug.WriteLine($"input is {a}. Start Calc...");await Task.Delay(1000);Debug.WriteLine($"input is {a}. End Calc.");return a + 100;}
100加算して返す(実験的に5秒待つ)

*itemBoxImages[index].sprite = null;
index番目に何も表示しない

*image.sprite = lightOFF;
imageの画像をlightOFFにする

*foreach (var order in Order)*{
設定されているソート項目分、ごにょごにょする
Orderのインデックス(Columnプロパティ)から、Columnオブジェクトを得る
*var column = Columns[order.Column].Data;
Orderのソート順(Dirプロパティ)から、Enumとして得る
*var direction = Enum.Parse<;OrderDirection>;(System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(order.Dir))

カメラ画像取得用のVideoCapture作成
*capture = new VideoCapture(0);
取得先のMat作成
*frame = new Mat(HEIGHT, WIDTH, MatType.CV_8UC3);
表示用のBitmap作成
*bmp = new Bitmap(frame.Cols, frame.Rows, (int)frame.Step(), System.Drawing.Imaging.PixelFormat.Format24bppRgb, frame.Data);
PictureBoxを出力サイズに合わせる
*pictureBox1.Width = frame.Cols;
描画用のGraphics作成
*graphic = pictureBox1.CreateGraphics();
画像取得スレッド開始
*backgroundWorker1.RunWorkerAsync();
描画
*graphic.DrawImage(bmp, 0, 0, frame.Cols, frame.Rows);
画像取得
*capture.Grab();
スレッドの終了を待機
*backgroundWorker1.CancelAsync();
保存されたキャプチャ画像の出力
*Cv2.ImShow("test1", frame);

処理内容
*isOnce = false;
処理内容
*Three++;

CodeGenerationSample プロジェクトの参照アセンブリの名前とパスを取得
*IDictionary<;string, string>; refs = GetReferences("CodeGenerationSample");

*agent.GetComponent<;AgentController<;().className = belongs;
所属しているクラスの情報をAgentControllerに渡す

Animator からボーン情報を持ってきたいので、Animator を取得
*var animator = HandBones[0].GetComponent<;Animator>;();
*HandBones = new Transform[(int) Bones.NumOfHI5Bones];*//左手と右手で取得すべきボーンが違うから判定
念の為初期化
*{case Hand.LEFT:HandBones[1] = animator.GetBoneTransform(HumanBodyBones.LeftHand);HandBones[2] = animator.GetBoneTransform(HumanBodyBones.LeftThumbProximal);HandBones[3] = animator.GetBoneTransform(HumanBodyBones.LeftThumbIntermediate);HandBones[4] = animator.GetBoneTransform(HumanBodyBones.LeftThumbDistal);HandBones[6] = animator.GetBoneTransform(HumanBodyBones.LeftIndexProximal);HandBones[7] = animator.GetBoneTransform(HumanBodyBones.LeftIndexIntermediate);HandBones[8] = animator.GetBoneTransform(HumanBodyBones.LeftIndexDistal);HandBones[10] = animator.GetBoneTransform(HumanBodyBones.LeftMiddleProximal);HandBones[11] = animator.GetBoneTransform(HumanBodyBones.LeftMiddleIntermediate);HandBones[12] = animator.GetBoneTransform(HumanBodyBones.LeftMiddleDistal);HandBones[14] = animator.GetBoneTransform(HumanBodyBones.LeftRingProximal);HandBones[15] = animator.GetBoneTransform(HumanBodyBones.LeftRingIntermediate);HandBones[16] = animator.GetBoneTransform(HumanBodyBones.LeftRingDistal);HandBones[18] = animator.GetBoneTransform(HumanBodyBones.LeftLittleProximal);HandBones[19] = animator.GetBoneTransform(HumanBodyBones.LeftLittleIntermediate);HandBones[20] = animator.GetBoneTransform(HumanBodyBones.LeftLittleDistal);break;case Hand.RIGHT:HandBones[1] = animator.GetBoneTransform(HumanBodyBones.RightHand);HandBones[2] = animator.GetBoneTransform(HumanBodyBones.RightThumbProximal);HandBones[3] = animator.GetBoneTransform(HumanBodyBones.RightThumbIntermediate);HandBones[4] = animator.GetBoneTransform(HumanBodyBones.RightThumbDistal);HandBones[6] = animator.GetBoneTransform(HumanBodyBones.RightIndexProximal);HandBones[7] = animator.GetBoneTransform(HumanBodyBones.RightIndexIntermediate);HandBones[8] = animator.GetBoneTransform(HumanBodyBones.RightIndexDistal);HandBones[10] = animator.GetBoneTransform(HumanBodyBones.RightMiddleProximal);HandBones[11] = animator.GetBoneTransform(HumanBodyBones.RightMiddleIntermediate);HandBones[12] = animator.GetBoneTransform(HumanBodyBones.RightMiddleDistal);HandBones[14] = animator.GetBoneTransform(HumanBodyBones.RightRingProximal);HandBones[15] = animator.GetBoneTransform(HumanBodyBones.RightRingIntermediate);HandBones[16] = animator.GetBoneTransform(HumanBodyBones.RightRingDistal);HandBones[18] = animator.GetBoneTransform(HumanBodyBones.RightLittleProximal);HandBones[19] = animator.GetBoneTransform(HumanBodyBones.RightLittleIntermediate);HandBones[20] = animator.GetBoneTransform(HumanBodyBones.RightLittleDistal);break;default:Debug.LogError("HandType が不正なものです。");break;}
左手と右手で取得すべきボーンが違うから判定

*ptr[y*bd.Stride + 4*x + 3] = 0;
alpha = 0 (透過)

*{transform.Rotate(new Vector3(15,30,45) * Time.deltaTime);}
Update is called once per frame

*destination = GameObject.Find("1-1");
目的地に設定した部屋名を指定
*agent.SetDestination(destination.transform.position);*}
目的地を指定(目的地のオブジェクトの位置情報を渡す）

*return Vector3.Cross(tmp1, tmp2);
Vector3.Crossは外積を求めるメソッド
*private bool WhetherIntersectionIsInsidePolygon(Vector3[] vertices, Vector3 intersection, Vector3 normal) {float angle_sum = 0f;for (int i = 0; i <; vertices.Length; i++) {Vector3 tmp1 = vertices[i] - intersection;Vector3 tmp2 = vertices[(i + 1) % vertices.Length] - intersection;float angle = Vector3.Angle(tmp1, tmp2);Vector3 cross = Vector3.Cross(tmp1, tmp2);if (Vector3.Dot(cross, normal) <; 0) angle *= -1;angle_sum += angle;}angle_sum /= 360f;return Mathf.Abs(angle_sum) >;= 0.1f;}
このメソッドは引用させていただきました

ここでScale In Lightmapの値を設定
*slider = EditorGUILayout.Slider("Scale In Lightmap", slider, 0, 20);
Scale In Lightmap一括変更ボタン
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
*if (GUILayout.Button("Change all Scale In Lightmap"))
ここでLightmapParametersを選択
*source = EditorGUILayout.ObjectField(source, typeof(LightmapParameters), true);
LightmapParameters一括変更ボタン
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
*if (GUILayout.Button("Change all LightmapParameters"))
ここでStitch Seamsを選択
*isOn =  EditorGUILayout.Toggle("Stitch Seams", isOn);
Stitch Seams一括変更ボタン
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
*if (GUILayout.Button("Change all Stitch Seams"))
一括変更ボタン
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
*if (GUILayout.Button("All Apply"))
全部いっぺんにするだけ
*ChangeScaleInLightmap(selectionObj);

*Debug.Log("キックされました。");
退室ボタンを押していないが退室した→つまりキックされた

*protected const int VK_SHIFT = 0x10;
SHIFTキー
この処理で発生したキーイベントは処理しない
*return base.HookProcedure(nCode, wParam, lParam);
ESCに変換
*num = 1;
*if (prevKeyDownCode == 91)*//if(GetKeyState(91) ; 0)
0x09                         F9 91(VK_LWIN)→9(VK_TAB)の順番
*{num = 1;inp = new INPUT[num];inp[0].type = INPUT_KEYBOARD;inp[0].ki.wVk = (short)VK_F9;inp[0].ki.wScan = (short)MapVirtualKey(inp[0].ki.wVk, 0);inp[0].ki.dwFlags = KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYDOWN;inp[0].ki.dwExtraInfo = dwExtraInfoNumber;inp[0].ki.time = 0;}
if(GetKeyState(91) &lt; 0)
*// スクリーンショットと被るので、ctrl/alt/shiftを押していないときだけF10に変換する*switch(prevKeyDownCode){
F10
*switch(prevKeyDownCode){case 0xA0:// SHift// VK_LSHIFTbreak;case 0xA1:// VK_RSHIFTbreak;case 0x11:// Controlbreak;case 0xA2:// VK_LCONTROLbreak;case 0xA3:// VK_RCONTROLbreak;case 0x12:// ALTbreak;case 0xA4:// VK_LMENUbreak;case 0xA5:// VK_RMENUbreak;default:num = 1;inp = new INPUT[num];inp[0].type = INPUT_KEYBOARD;inp[0].ki.wVk = (short)VK_F10;inp[0].ki.wScan = (short)MapVirtualKey(inp[0].ki.wVk, 0);inp[0].ki.dwFlags = KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYDOWN;inp[0].ki.dwExtraInfo = dwExtraInfoNumber;inp[0].ki.time = 0;break;}
スクリーンショットと被るので、ctrl/alt/shiftを押していないときだけF10に変換する
この処理で発生したキーイベントは処理しない
*return base.HookProcedure(nCode, wParam, lParam);
ESCに変換
*num = 1;
*if (dev.Connected == false)*{
Console.WriteLine(dev.DeviceName);

*}).ToArray();
無理矢理。。

*var csvData = ...;
Csv のデータ

*Console.WriteLine(sp.IntColumn);
データベースで生成された値がセット済み。

※using、Dispose文は省略
*var bitmap = new Bitmap(1280, 200);
透過
*bitmap.MakeTransparent();
BitmapからGraphicsを生成
*var graphics = Graphics.FromImage(bitmap);
どんなに長くて単語の区切りが良くても改行しない
*stringFormat.FormatFlags = StringFormatFlags.NoWrap;
どんなに長くてもトリミングしない
*stringFormat.Trimming = StringTrimming.None;
ハイクオリティレンダリング
*graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;
アンチエイリアスをかける
*graphics.SmoothingMode = SmoothingMode.HighQuality;
GraphicsPathを生成
*var gp = new GraphicsPath();
パスに文字を追加
*gp.AddString("山路を登りながら、智に働けば角が立つ。", new FontFamily("メイリオ"), 0, 46, new Point(8, 8), stringFormat);
縁取りをする。
*graphics.DrawPath(new Pen(Color.Black, 16), gp);
文字を塗りつぶす。
*graphics.FillPath(new SolidBrush(Color.White), gp);
テスト用にBitmapの内容をD:\result.pngに出力
*bitmap.Save("D:\\result.png", System.Drawing.Imaging.ImageFormat.Png);

*itemBoxImages[index].sprite = null;
index番目に何も表示しない

*{lightStandPanel.SetActive(false);drawerPanel.SetActive(false);pcPanel.SetActive(false);}
ボタンを押したらパネルを全て非表示

*bar();
任意の処理

*{LightBulbPanel.SetActive(false);alertText.SetActive(false);}
電球の画像をクリックすると電球画像を非表示にする
引き出しが押されたら
1.電球の画像をだす
2.Textをだす
*public void OnClickTrigger()
*{LightBulbSetActive(false);}
電球の画像をクリックすると電球画像を非表示にする

*pcPanel.SetActive(true);
PCパネルをアクティブにする

スプレッドシートで型名を文字列で管理し、ScriptableObject.CreateInstanceした際に型名からインスタンス化させようとしている
なお直接 Executor = new PhysicExecutor(); としてもポリモーフィズムが働かないのは変わらない
*Type executorType =Type.GetType(typeName);

*foreach(Transform child in this.gameObject.transform)*{
子のオブジェクトを全部リストに入れとく
*{StartCoroutine(AutoSelectStartCoroutine());}
Startボタン押したら呼ばれる
*{for(int i = 0; i <; m_levelGetFromSlider.GetLevel(); i++){yield return new WaitForSeconds(m_interval);//ここでどれが選ばれるかランダムに決めるm_randomValue = Random.Range(0, m_tmpListObj.Count);//選ばれたときのイベント呼び出しm_tmpListObj[(int)m_randomValue].GetComponent<;PanelSelectedEvent>;().BlinkPanel();m_tmpListObj[(int)m_randomValue].GetComponent<;PanelSelectedEvent>;().CorrectSoundPlay();//選んだオブジェクトをリスト化するg_listObj.Add(m_tmpListObj[(int)m_randomValue]);}}
レベルに応じて自動で選ばれる回数を変える
ここでどれが選ばれるかランダムに決める
*m_randomValue = Random.Range(0, m_tmpListObj.Count);
選ばれたときのイベント呼び出し
*m_tmpListObj[(int)m_randomValue].GetComponent<;PanelSelectedEvent>;().BlinkPanel();
選んだオブジェクトをリスト化する
*g_listObj.Add(m_tmpListObj[(int)m_randomValue]);
*{//ここでどれが選ばれるかランダムに決めるm_randomValue = Random.Range(0, m_tmpListObj.Count);//選ばれたときのイベント呼び出しm_tmpListObj[(int)m_randomValue].GetComponent<;PanelSelectedEvent>;().BlinkPanel();//選んだオブジェクトをリスト化するg_listObj.Add(m_tmpListObj[(int)m_randomValue]);}
レーザーで選んだら次が光ってリストを更新
ここでどれが選ばれるかランダムに決める
*m_randomValue = Random.Range(0, m_tmpListObj.Count);
選ばれたときのイベント呼び出し
*m_tmpListObj[(int)m_randomValue].GetComponent<;PanelSelectedEvent>;().BlinkPanel();
選んだオブジェクトをリスト化する
*g_listObj.Add(m_tmpListObj[(int)m_randomValue]);
このスクリプトはパネルにアタッチされたスクリプトです
何回選ぶか　エンドレスモードがあればここをめちゃくちゃでかい数字に変えればOK
*int m_playTime = 10;
先程のリストを取ってくる
*PanelSelected m_panelSelected;
*{if (m_selectedCount <; m_playTime){if (m_panelSelected.g_listObj[m_selectedCount] == this.gameObject){m_panelSelected.ToNextSelect();CorrectSoundPlay();m_selectedCount++;}else{WrongSoundPlay();}}else{if (m_panelSelected.g_listObj[m_selectedCount] == this.gameObject){CorrectSoundPlay();m_selectedCount++;if (m_selectedCount == m_playTime + m_levelGetFromSlider.GetLevel()){//ここにクリア時の処理m_clear.ClearTextAppear();}}else{WrongSoundPlay();}}}
選んだものが同じかどうか判定して選択カウント増加
ここにクリア時の処理
*m_clear.ClearTextAppear();

テキスト設定
*JabHelpers.AccessibleTreeItem txt = javaTree.children[0].children[1].children[0].children[0].children[1];
クリック実行
*JabHelpers.DoAccessibleActions(vmID, button.acPtr, "クリック");
リストの内容
*Console.WriteLine("リスト一覧-------------");
*// https://stackoverflow.com/questions/50582769/windowsaccessbridge-for-java-automation-using-c-sharp*public static void Init()
Windows_runはメッセージポンプが必要
*{JabApi.Windows_run();DoEvents();}
https:stackoverflow.com/questions/50582769/windowsaccessbridge-for-java-automation-using-c-sharp

*Console(a%b)
1

〜〜省略〜〜
*private BannerView bannerView;
*{if (bannerView != null){bannerView.Hide();bannerView.Destroy();//〜〜省略〜〜,,,
*var spriteAssets = await Addressables.LoadAssetsAsync<;Sprite<; ("Sprites", null).Task.ConfigureAwait (false);
ラベルを指定して一括ロード
*if (textPrefab &amp;&amp; imagePrefab &amp;&amp; spriteAssets != null &amp;&amp; spriteAssets.Count >; 0) {*// プレファブからオブジェクトを生成
エラーがないことを確認
*var image = Instantiate (imagePrefab, transform).GetComponent<;Image>; ();*var text = Instantiate (textPrefab, transform).GetComponent;Text>; ();
プレファブからオブジェクトを生成
*for (var i = 0; i <; spriteAssets.Count; i++) {*image.sprite = spriteAssets [i];
スプライトを順に切り替え
*private async Task loader () {// ～,,,private IEnumerator Start () {yield return StartCoroutine (loader ());// 次の処理},,,/// <;summary>;タスク拡張<;/summary>;public static class TaskEx {/// <;summary>;休止間隔<;/summary>;private const int Tick = 16;/// <;summary>;1フレーム待機<;/summary>;public static Task DelayOneFrame =>; Task.Delay (Tick);/// <;summary>;条件が成立する間待機<;/summary>;public static async Task DelayWhile (Func<;bool>; predicate) {while (predicate ()) {await Task.Delay (Tick);}}/// <;summary>;条件が成立するまで待機<;/summary>;public static async Task DelayUntil (Func<;bool>; predicate) {do {await Task.Delay (Tick);} while (!predicate ());}},,,*private IEnumerator Start () {yield return StartCoroutine (loader ());// 次の処理},,,/// <;summary>;タスク拡張<;/summary>;public static class TaskEx {/// <;summary>;休止間隔<;/summary>;private const int Tick = 16;/// <;summary>;1フレーム待機<;/summary>;public static Task DelayOneFrame =>; Task.Delay (Tick);/// <;summary>;条件が成立する間待機<;/summary>;public static async Task DelayWhile (Func<;bool>; predicate) {while (predicate ()) {await Task.Delay (Tick);}}/// <;summary>;条件が成立するまで待機<;/summary>;public static async Task DelayUntil (Func<;bool>; predicate) {do {await Task.Delay (Tick);} while (!predicate ());}},,,次の処理
*}

*Debug.Log("ボタンが押されたよ！！");
コンソールに表示

Weight降順でソート
*var sortedPairs = itemWeightPairs.OrderByDescending(x =>; x.Value).ToArray();
ドロップアイテムの抽選
*float total = sortedPairs.Select(x =>; x.Value).Sum();
*foreach (KeyValuePair<;T, float>; elem in sortedPairs)*{
randomPointの位置に該当するキーを返す
*{// Weight順でソートvar sortedPairs = itemWeightPairs.OrderByDescending(x =>; x.Weight).ToArray();// ドロップアイテムの抽選float total = sortedPairs.Select(x =>; x.Weight).Sum();float randomPoint = Random.Range(0, total);// randomPointの位置に該当するキーを返すforeach (T elem in sortedPairs){if (randomPoint <; elem.Weight){return elem;}randomPoint -= elem.Weight;}return sortedPairs[sortedPairs.Length - 1];}
interface利用
Weight順でソート
*var sortedPairs = itemWeightPairs.OrderByDescending(x =>; x.Weight).ToArray();
ドロップアイテムの抽選
*float total = sortedPairs.Select(x =>; x.Weight).Sum();
*foreach (T elem in sortedPairs)*{
randomPointの位置に該当するキーを返す
*{public string Name;private float _weight;public float Weight =>; _weight;public Item(string name, float weight){Name = name;_weight = weight;}}
IHaveWeightを継承する！！

*public DbSet<;Member>; Members { get; set; }
public myopContext (DbContextOptions options) : base(options) {}
*[HttpGet("{id}")]
GET: Members/5
*[HttpPut("{id}")]
PUT: Members/5
*[HttpDelete("{id}")]
DELETE: Members/5
*{services.AddDbContext<;myopContext>;(options =>; options.UseSqlite("Data Source=members.db"));services.AddControllers();}
This method gets called by the runtime. Use this method to add services to the container.

*return View();
ビューをそのまま返している
画面表示時に呼ばれる
*[HttpGet] public IActionResult Edit() =>; View();
*[HttpPost] public IActionResult Edit(EditViewModel vm) {if (ModelState.IsValid) {/** データベースへの登録処理とか */}return View();}
フォームの送信で呼ばれる

*public DbSet<;Member>; Members { get; set; }
public MvcBasicContext (DbContextOptions options) : base(options) {}

*if (i * i == n) return EnumResult.Success;
結果の整数が返せない

*RegistryKey regKey = rootKey.OpenSubKey(keyname, true);
書き込み権限で開く

樹形図の「枝」を作る。
*branches = new List<;Branch>;();
画像をPNG形式で保存する。
*bmp.Save(filePath, System.Drawing.Imaging.ImageFormat.Png);

*token.Register(() =<; utcs.TrySetCanceled());
CancellationToken対応
*{callback = onResult;Invoke("AfterWait", 3.0f);}
コールバック方式の非同期メソッドの例

*currentPieceIndex = keyPieces.Count;
範囲外を設定する
*try {lines = File.ReadAllLines(keyLayoutFileNameUTF8);}
雑だが例外処理でファイル有無も併せて判定していく
*foreach ( string s in lines ) {if ( s.Trim() == String.Empty ) {continue;}Match m = r.Match(s);if ( m.Success ) {int index = Convert.ToInt32(m.Groups[1].Value);string tmpScanCode   = m.Groups[2].Value;string tmpScanCodeFn = m.Groups[3].Value;string tagName       = m.Groups[4].Value;if ( index >;= keyPieces.Count ) {return false;}if ( keyPieces[index].TagName != tagName ) {return false;}if ( tmpScanCode.StartsWith("0x") ) {ushort scanCode = (ushort)Convert.ToInt32(tmpScanCode, 16);keyPieces[index].SetScanCode(scanCode, false);}else {keyPieces[index].ClearScanCode(false);}if ( tmpScanCodeFn.StartsWith("0x") ) {ushort scanCodeFn = (ushort)Convert.ToInt32(tmpScanCodeFn, 16);keyPieces[index].SetScanCode(scanCodeFn, true);}else {keyPieces[index].ClearScanCode(true);}}else{Console.WriteLine("unmatch \""+s+"\"");//return false;}}
長さのガードを入れるべきだが面倒なのでそのまま

たとえば、このように、特定のエディタが開いているかどうかで分岐をつくり、
*var fieldEditorWindow = FieldEditorWindow.GetCurrent();
通常はただのテキストフィールド
*stringProp.stringValue = EditorGUI.TextField(rect, label, stringProp.stringValue);
選択対象のオブジェクトをシーンから選択できる場合は、がんばってドロップダウンを出す
*var actorRepository = fieldEditorWindow.GetActorRepository();
シーン上のオブジェクトから選択するとかできます
Draw popup
*var selectedIndex = EditorGUI.Popup(popupRect, Array.IndexOf(ids, stringProp.stringValue), actorNames);
*if (!presented &amp;&amp; ActiveIndex >;= 0)*{
クリップのないフレーム
*{}
トラックの最初のフレームで呼ばれる
あるクリップが再生された最初のフレームで呼ばれる
エディタ上では、指しているクリップが代わった場合に都度呼ばれる
*protected virtual void OnClipEnable(Playable playable, int enabledIndex, float weight)
クリップのあるフレームから、クリップのないフレームへ移った場合に呼ばれる
エディタ上では、指しているクリップがなくなった場合に都度呼ばれる
*protected virtual void OnClipDisable(Playable playable, int disabledIndex)
*{}
あるクリップの最後のフレームで呼ばれる

*public DbSet<;Member>; Members { get; set; }
public MvcBasicContext (DbContextOptions options) : base(options) {}
*{services.AddDbContext<;MvcBasicContext>;(options =>; options.UseSqlite("Data Source=members.db"));services.AddControllersWithViews();}
This method gets called by the runtime. Use this method to add services to the container.

*param.Add("TargetData", Visibility.Visible);
パラメータをkeyとvalueの組み合わせで追加
第二引数にパラメータを渡すと、viewが切り替わった先でパラメータを受け取る
*RegionNavigationService.RequestNavigate(nameof(SelectScreen), param);
*public class SelectScreenViewModel : BindableBase, IConfirmNavigationRequest, IJournalAware, IRegionMemberLifetime*{
SelectScreenViewModel
Camera画面から受け取ったパラメータを照合してバインドさせる
*ViewboxSampleVisibility = (Visibility)navigationContext.Parameters["TargetData"];

*cosTheta = Mathf.Cos(theta);
回転角のcosを計算
*this.transform.position = new Vector3(A * sinTheta, height, -A * cosTheta);*//カメラの方向の代入
カメラの位置の代入
*this.transform.forward = new Vector3(-sinTheta, 0.0f, cosTheta);*}
カメラの方向の代入

Labelを作成し、そこに出力するサンプル
label.Content = "(x, y) = ("+ p.X +", "+ p.Y +")";  p.X, p.Yで取得できます。
*,,,

*string JsonStr = wc.DownloadString(@"https:
www.jma.go.jpbosaiforecastdataoverview_week130000.json");
*{public string publishingOffice { get; set; }public string reportDatetime { get; set; }public string targetArea { get; set; }public string headlineText { get; set; }public string text { get; set; }}
天気概況（明後日まで）用のクラス
*{public string publishingOffice { get; set; }public string reportDatetime { get; set; }public string headTitle { get; set; }public string text { get; set; }}
天気概況（週間）用のクラス

*string url = "http:
weather.livedoor.comforecastwebservicejsonv1?city=130010";
HttpClientインスタンス作成(using System.Net.Http;を忘れないこと)
*HttpClient client = new HttpClient();
Get通信して結果を文字列として取得
*string result = client.GetStringAsync(url).Result;
*//今回はルートが{で始まるオブジェクトなのでJObject.Parse,ルートが配列の場合はJArray.Parseを用いる//(using Newtonsoft.Json.Linq;を忘れないこと)JObject jobj = JObject.Parse(result);//表示してみる//Console.WriteLine(jobj);//jobjが持つforecastsは配列なので以下のようにその配列部分を取得する。JArray jarr = (JArray)jobj["forecasts"];//jarrに入っているのはオブジェクトなので以下のようなforeachで回すforeach(JObject f in jarr) {//fとして取り出したJObjectのdateLabelは文字列なのでstringでキャストしてあげるstring dateLabel = (string)f["dateLabel"];//確認してみる//Console.WriteLine(dateLabel);string telop = (string)f["telop"];string date = (string)f["date"];Console.WriteLine($"{dateLabel}({date})...{telop}");}}
表示
*//今回はルートが{で始まるオブジェクトなのでJObject.Parse,ルートが配列の場合はJArray.Parseを用いる//(using Newtonsoft.Json.Linq;を忘れないこと)JObject jobj = JObject.Parse(result);//表示してみる//Console.WriteLine(jobj);//jobjが持つforecastsは配列なので以下のようにその配列部分を取得する。JArray jarr = (JArray)jobj["forecasts"];//jarrに入っているのはオブジェクトなので以下のようなforeachで回すforeach(JObject f in jarr) {//fとして取り出したJObjectのdateLabelは文字列なのでstringでキャストしてあげるstring dateLabel = (string)f["dateLabel"];//確認してみる//Console.WriteLine(dateLabel);string telop = (string)f["telop"];string date = (string)f["date"];Console.WriteLine($"{dateLabel}({date})...{telop}");}}
Console.WriteLine(result);
今回はルートが{で始まるオブジェクトなのでJObject.Parse,ルートが配列の場合はJArray.Parseを用いる
(using Newtonsoft.Json.Linq;を忘れないこと)
*JObject jobj = JObject.Parse(result);
表示してみる
Console.WriteLine(jobj);
jobjが持つforecastsは配列なので以下のようにその配列部分を取得する。
*JArray jarr = (JArray)jobj["forecasts"];
*foreach(JObject f in jarr) {*//fとして取り出したJObjectのdateLabelは文字列なのでstringでキャストしてあげる
jarrに入っているのはオブジェクトなので以下のようなforeachで回す
fとして取り出したJObjectのdateLabelは文字列なのでstringでキャストしてあげる
*string dateLabel = (string)f["dateLabel"];
確認してみる
Console.WriteLine(dateLabel);
*string telop = (string)f["telop"];

OKも自動で押す場合はこれ
var ipOkButton = (InvokePattern)aeOkButton.GetCurrentPattern(InvokePattern.Pattern);
ipOkButton.Invoke();
*}
*if ( text != null ) {Console.WriteLine(text);// 下記は ID, PASSWORD に応じて適宜変更。機密管理に注意すること。//  やらかし例：ソースにパスワード埋め込んだままGitHubなどでうっかり公開したりとかInputToCredentialWindow(aeForm, "userid", "password");}
対象サイト(?)のメッセージに応じて適宜変更. 改行とか合わせるのが面倒なので正規表現で探すようにした
下記は ID, PASSWORD に応じて適宜変更。機密管理に注意すること。
やらかし例：ソースにパスワード埋め込んだままGitHubなどでうっかり公開したりとか
*InputToCredentialWindow(aeForm, "userid", "password");

*nums.Length
length

*options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver();
Camel形式

*return true;
すべてのウィンドウを列挙する

*ExtendBoth
3

*{rb = GetComponent<;Rigidbody>;();}
See also:https:docs.unity3d.com/ja/2019.1/Manual/ExecutionOrder.html

Ageを昇順にソート
*DataRow[] rows =
Ageを降順にソート
*rows =
複数項目（AgeとAddress）でのソート
*rows =
AND の場合
*DataRow[] rows =
OR の場合
*rows =

*if (file.Exists)*{
あるかないか

dummyは処置待ち用のダミー。locationの操作が目的
*var dummy = location

*Console.WriteLine("\n");
Friendly linespacing.

*}
namespace Qiita

集計日
*DateTime today = DateTime.Today;
月初め
*DateTime monthStart = new DateTime(today.Year, today.Month, 1);
月終わり
*DateTime monthEnd = new DateTime(today.Year, today.Month, 1).AddMonths(1).AddDays(-1);
日付挿入
*挿入する箇所.Text = today.ToShortDateString();
*{if (a <; b)// 引数を入替えて自分を呼び出すreturn Gcd(b, a);while (b != 0){var remainder = a % b;a = b;b = remainder;}return a;}
ユークリッドの互除法
引数を入替えて自分を呼び出す
*return Gcd(b, a);

追加コード
*const uint CFS_RECT = 0x0001;
*case WM_IME_STARTCOMPOSITION: {//入力コンテキストにアクセスするためのお約束IntPtr hImc = ImmGetContext(this.Handle);//コンポジションウィンドウの位置を設定COMPOSITIONFORM info = new COMPOSITIONFORM();info.dwStyle = CFS_POINT;info.ptCurrentPos.x = 10;info.ptCurrentPos.y = 10;ImmSetCompositionWindow(hImc, ref info);// 追加コード(IMEウィンドウ領域の設定)info.dwStyle = CFS_RECT;info.rcArea._Left = 10;info.rcArea._Top = 10;info.rcArea._Right = 100;info.rcArea._Bottom = 100;ImmSetCompositionWindow(hImc, ref info);//コンポジションウィンドウのフォントを設定//ImmSetCompositionFont(hImc, m_Focus->;GetFont()->;GetInfoLog());//入力コンテキストへのアクセスが終了したらロックを解除するImmReleaseContext(Handle, hImc);base.WndProc(ref m);break;,,,入力コンテキストにアクセスするためのお約束
*IntPtr hImc = ImmGetContext(this.Handle);
コンポジションウィンドウの位置を設定
*COMPOSITIONFORM info = new COMPOSITIONFORM();
追加コード(IMEウィンドウ領域の設定)
*info.dwStyle = CFS_RECT;
コンポジションウィンドウのフォントを設定
ImmSetCompositionFont(hImc, m_Focus-&gt;GetFont()-&gt;GetInfoLog());
入力コンテキストへのアクセスが終了したらロックを解除する
*ImmReleaseContext(Handle, hImc);

*migrationBuilder.Sql(sql);
NUMERICからINTへの暗黙的な変換。場合によってはここでコケるかもしれません！
古いテーブルを削除
*sql = "drop table Products; ";
新テーブルの名前を変更する
*sql = "alter table Products_temp rename to Products";
*migrationBuilder.Sql("PRAGMA foreign_keys=true;");*}
外部キーを有効にする

*var client = NotificationHubClient.CreateClientFromConnectionString(connectionString, hubName);*// iOSにタグ指定でJsonデータを送信
クライアントを作成
*var task = client.SendAppleNativeNotificationAsync(payload, tag);*// AndroidもSendFcmNativeNotificationAsyncを使うことで簡単にできそうだが未確認
iOSにタグ指定でJsonデータを送信
AndroidもSendFcmNativeNotificationAsyncを使うことで簡単にできそうだが未確認
～以下略～
*}

struct 配列の宣言
*INPUT[] input = new INPUT[2];
左ボタン Down
*input[0].mi.dwFlags = MOUSEEVENTF_LEFTDOWN;
左ボタン Up
*input[1].mi.dwFlags = MOUSEEVENTF_LEFTUP;
イベントの一括生成
*SendInput(2, input, Marshal.SizeOf(input[0]));

*anime.Rewind("アニメーション名");
0フレーム目に巻き戻す

*public string this[int index]{set{this.data[index] = value;}get{return data[index];}}
アクセス 戻り値 this[型 引数]

～～省略～～
*conn = DbConnect();
～～省略～～
*,,,
～～省略～～
*conn = DbConnect();

*Debug.Log("ルームマスター" + player.IsMasterClient);
ルームマスターならTrur。最初に部屋を作成した場合は、基本的にルームマスターなはず。
*public override void OnJoinRandomFailed(short returnCode, string message) {Debug.Log("入室失敗");//ルームを作成する。PhotonNetwork.CreateRoom(null, RoomOPS); //JoinOrCreateroomと同じ引数が使用可能。nullはルーム名を作成したくない場合roomNameを勝手に割り当てる。}
入室失敗したときに呼び出される動作。
ルームを作成する。
PhotonNetwork.CreateRoom(null, RoomOPS); JoinOrCreateroomと同じ引数が使用可能。nullはルーム名を作成したくない場合roomNameを勝手に割り当てる。
*}
*public override void OnCreateRoomFailed(short returnCode, string message) {Debug.Log("作成失敗");}
ルーム作成失敗したときの動作。

諸々省略
*}
*{}
結局再帰的にどこかにNullが出てきてしまう
*{public ITree Parent =>; throw new InvalidOperationException("Purged root doesn't have Parent element.");public IReadOnlyList<;ITree>; Children =>; throw new InvalidOperationException("Purged root doesn't have Children.");}
パージされたなど弁別したいときは増やせる

アセンブリに関する一般情報は以下の属性セットをとおして制御されます。
アセンブリに関連付けられている情報を変更するには、
これらの属性値を変更してください。
*[assembly: AssemblyTitle("Test Target")]
アセンブリに関する一般情報は以下の属性セットをとおして制御されます。
アセンブリに関連付けられている情報を変更するには、
これらの属性値を変更してください。
*[assembly: AssemblyTitle("Test Target")]

エスケープシーケンスがどう出力されるか見たかっただけ
*Debug.Log("aaa¥nbbb");
こっちの変数を使って調べる
*string originstr = "aaa¥nbbbbb";
文字列の長さを調べる
*Debug.Log(str.Length);
originstrの中身を、一文字ずつ配列に入れる
*char chars[] =originstr.ToCharArray();
*for (int i = 0; i <; 8; i++)*{
１文字追加するたびに現在の文字列を出力する

*// 簡単に言うとforeachの強化版*// データ集合に対しての検索や集約を簡潔に記述できる。
LINQ
簡単に言うとforeachの強化版
データ集合に対しての検索や集約を簡潔に記述できる。
javaのstreamと同様。
*class Practice10_2
Where (3以下の値を取り出す)
*iIte = intList.Where(s =>; s <;= 3);
Select (データを加工する)
*iIte = intList.Select(s =>; s * s);
Distinct (重複削除)
*iIte = intList.Distinct();
Order By (並び替え 昇順降順)
*iIte = intList.OrderBy(s =>; Math.Abs(s));
全てを複合できる。
実行順序は上からになる。
*iIte = intList
Sum 合計値
*int sum = intList.Sum();
Average 平均値
*double ave = intList.Average();
Count 要素数
*int count = intList.Count();
Max 最大値
*int max = intList.Max();
Min 最小値
*int min = intList.Min();

*eventParts += new EventPart(eventManager.Action2);
new演算子を使った書き方も可
追加した全てのメソッドを実行する。
*eventParts("");
削除もできる。
*eventParts -= eventManager.Action1;
*{action("");}
匿名メソッド

*{static void Main(string[] args){var s = new Sample<;int, float>;(15, 20.0f);s.Show();s = new Sample<;int, float>;();s.Show();}}
自前のジェネリッククラス
*{private T1 _item1 { get; set; }private T2 _item2 { get; set; }public Sample(){this._item1 = default(T1);this._item2 = default(T2);}public Sample(T1 t1, T2 t2){this._item1 = t1;this._item2 = t2;}public void Show (){Console.WriteLine(_item1.ToString());Console.WriteLine(_item2.ToString());}public (T1, T2) getT(){return (_item1, _item2);}}
ジェネリックなクラスを定義する。

*{static void Main(string[] args){// Enum ->; 数値long i = (long)Season.Autumn;// 数値 ->; Enum型Season s = (Season)Enum.Parse(typeof(Season), i.ToString());Console.WriteLine(i);Console.WriteLine(s);}}
enum
Enum -&gt; 数値
*long i = (long)Season.Autumn;
数値 -&gt; Enum型
*Season s = (Season)Enum.Parse(typeof(Season), i.ToString());

*{static void Main(string[] args){Parent p = new Child();p.Show();p.Run();// Is - newしたクラスと一致するかどうか。if (p is Child){}// As - ダウンキャストに失敗した場合，nullになる。// 通常のキャスト (ClassXX)ではキャスト失敗時に例外が発生する。var x = p as Sister;}}
new, virtual - override, abstruct , is, as
*if (p is Child)*{
Is - newしたクラスと一致するかどうか。
As - ダウンキャストに失敗した場合，nullになる。
通常のキャスト (ClassXX)ではキャスト失敗時に例外が発生する。
*var x = p as Sister;
*{Console.WriteLine("親が走る。");}
オーバーライドを許可
オーバーライドを強制
*public abstract void Jump();
*{// Overrideできない。(原則使用禁止。)public new void Show(){Console.WriteLine("child");}// Overrideが可能。(しなくてもよい)public override void Run(){Console.WriteLine("子が走る。");}// Overrideが必須。public override void Jump(){}}
sealedで継承不可にする。(javaでいうfinal)
*{Console.WriteLine("child");}
Overrideできない。(原則使用禁止。)
*{Console.WriteLine("子が走る。");}
Overrideが可能。(しなくてもよい)
*{}
Overrideが必須。

*{static void Main(string[] args){// プロパティを介してprivateな変数にアクセスできる。Sample s = new Sample();s.Param1 = 10;int n = s.Param1;FreeArray array = new FreeArray(10);array[3] = 10;}}
インデクサ
プロパティを介してprivateな変数にアクセスできる。
*Sample s = new Sample();
プロパティの配列版
配列にアクセスした際の挙動を決める。
*private int[] _list;
*{return ++index;}
引数で渡したインデックスの次のインデックスを返却する。

*{static void Main(string[] args){// プロパティを介してprivateな変数にアクセスできる。Sample s = new Sample();s.Param1 = 10;int n = s.Param1;}}
プロパティ
プロパティを介してprivateな変数にアクセスできる。
*Sample s = new Sample();
*{set{this._param1 = value;}get{return this._param1;}}
SetterとGetterを定義する。
*public int Param2 { get; set; }
自動プロパティ
*public int Param3 { get; private set; }
読み取り専用

*{// 参照渡しの場合はrefを書く。(C++の &amp;に相当)int n = 10;Increment(ref n);// 戻り値のデータを書き換えることで配列の値も変わる。var data = new int[] { 10, 20, 30 };int data_0 = Decrement(data);ref int data_1 = ref Decrement(data);data_1 = 40;// out引数による戻り値の設定。int n1 = 100;int n2 = 100;Devide(out n1, out n2);// tupleによる戻り値の設定。(int x, int y, int z) r = ReturnTupple();(var x1, var y1, var z1) = ReturnTupple();var (x2, y2, z2) = ReturnTupple();// tupleによる代入var axis = (100, 200, 300);int sum = axis.Item1 + axis.Item2 + axis.Item3;// 匿名型(名前付きtupleのようなものでreadonly)var tokumei = new { param1 = 1, param2 = "2" };// tokumei.param1 = 10; // エラーになる。}
ref, out , tuple, 匿名型
参照渡しの場合はrefを書く。(C++の &amp;に相当)
*int n = 10;
*var data = new int[] { 10, 20, 30 };
戻り値のデータを書き換えることで配列の値も変わる。
out引数による戻り値の設定。
*int n1 = 100;
tupleによる戻り値の設定。
*(int x, int y, int z) r = ReturnTupple();
tupleによる代入
*var axis = (100, 200, 300);
*var tokumei = new { param1 = 1, param2 = "2" };
匿名型(名前付きtupleのようなものでreadonly)
tokumei.param1 = 10;  エラーになる。
*}
*{n++;}
値の参照渡し
*{data[0]--;return ref data[0];}
戻り値の参照渡し
*{n1 = 10;n2 = 20;}
outによる複数の戻り値の設定。
*{return (10, 20, 30);}
tupleによる複数の戻り値の設定。

*int Sum(int a, int b) { return a + b; }
ローカル関数

*doc = await parser.ParseDocumentAsync(sorce);
ここが変わっています!!
ZIPファイルを解凍します
*ZipFile.ExtractToDirectory(<;保存するファイル名（絶対パスで）>;, <;解凍先フォルダー名>;);

以下と同じ
*var products = db.Query<;Product>;("Select * From Product")

バインドするローカルIPとポート番号
*string localIpString = "自分のIPアドレス";
UdpClientを作成し、ローカルエンドポイントにバインドする
*System.Net.IPEndPoint localEP =
データを受信する
*System.Net.IPEndPoint remoteEP = null;
データを文字列に変換する
*string rcvMsg = System.Text.Encoding.UTF8.GetString(rcvBytes);
受信したデータと送信者の情報を表示する
"exit"を受信したら終了
*if (RcvMsg[0] =="exit")
UdpClientを閉じる
*udp.Close();

↑↑↑↑_AnimatorのLayer番号
VR Motion Recorderでは3番がまばたき用のLayerとなっている
(0, 1, 2, 3, ...と数えるから、実際は4番目のLayer)
扱う_Animatorによって適切に設定すること
AnimatorのLayer機能については前の記事(冒頭に紹介した記事)を参照のこと
*void Start()
まばたきループ開始
*StartCoroutine("AutoBlinkCoroutine");
*{if (isBlink){// isBlink = trueならweightを1にもっていく// 0.05secかけてweightを1にするweight = Mathf.SmoothDamp(weight, 1, ref velocity, 0.05f);}else{// isBlink = falseならweightを0にもっていく// 0.05secかけてweightを0にするweight = Mathf.SmoothDamp(weight, 0, ref velocity, 0.05f);}// AnimatorのLayerのウェイトを更新_Animator.SetLayerWeight(Layer, weight);}
_Animatorのweightを毎フレーム更新する
isBlink = trueならweightを1にもっていく
0.05secかけてweightを1にする
*weight = Mathf.SmoothDamp(weight, 1, ref velocity, 0.05f);
isBlink = falseならweightを0にもっていく
0.05secかけてweightを0にする
*weight = Mathf.SmoothDamp(weight, 0, ref velocity, 0.05f);
AnimatorのLayerのウェイトを更新
*_Animator.SetLayerWeight(Layer, weight);
*{//無限ループwhile (true){//まばたき1回目。単発でまばたきをする。yield return new WaitForSeconds(OnceBlinkTime_1);isBlink = true;yield return new WaitForSeconds(CloseTime);isBlink = false;//まばたき2回目。単発でまばたきをする。yield return new WaitForSeconds(OnceBlinkTime_2);isBlink = true;yield return new WaitForSeconds(CloseTime);isBlink = false;//まばたき3回目。ここでは2回連続でまばたきをする。yield return new WaitForSeconds(TwiceBlinkTime_3);isBlink = true;yield return new WaitForSeconds(CloseTime);isBlink = false;yield return new WaitForSeconds(CloseTime);isBlink = true;yield return new WaitForSeconds(CloseTime);isBlink = false;}}
「コルーチン」で呼び出すメソッド
*while (true)*{
無限ループ
まばたき1回目。単発でまばたきをする。
*yield return new WaitForSeconds(OnceBlinkTime_1);
まばたき2回目。単発でまばたきをする。
*yield return new WaitForSeconds(OnceBlinkTime_2);
まばたき3回目。ここでは2回連続でまばたきをする。
*yield return new WaitForSeconds(TwiceBlinkTime_3);

*class Meteor:Enemy
Enemyクラスを継承してMeteorクラスを作る
*{Console.WriteLine("まっすぐに移動");}
EnemyクラスのMoveメソッドをオーバーライドする
インスタンスを生成する
*ufo = new UFO();
敵を移動する
*ufo.Move();

*{}
これが MyClass という class
ここでインスタンスになる(Objectになる)
*MyClass mc = new MyClass();
ここでインスタンスになる(Objectになる)
*MyClass mc = new MyClass();
*{public string ClassName{ get; set; }public int ClassId { get; set; }public MyClass(string name, int id){ClassName= name;ClassId = id;}}
classの中に　プロパティとコンストラクタを定義
ここでインスタンスになる(Objectになる)
MyClass mc = new MyClass("hoge",1); Classname = hoge, ClassId = 1 のMyClassインスタンス
*MyClass mc2 = mc;
MyClassは 読み書きできるので mc2を使って変数を変えてみます
*mc2.Classname = "hogehoge";
参照型なので、mc  mc2のプロパティは下記のようになる
Output
mc.Classname is "hogehoge"
mc.ClassId is 2
mc2.Classname is "hogehoge"
mc2.ClassId is 2
*}

*agent.SetDestination(target.transform.position);
☆追加

*public Transform ballTrans
ターゲットのオブジェクトのトランスフォーム
向きたい方向を計算
*Vector3 dir = (ballTrans.position - arrowTrans.position);
ここで向きたい方向に回転させてます
*arrowTrans .rotation = Quaternion.FromToRotation(Vector3.up, dir)

*string path = @"";
CSVファイルのパス

*{if (sprites.Length <; 1) return;var index = (int)Mathf.Repeat(Time.frameCount * speed / 100, sprites.Length);var renderer = GetComponent<;MeshRenderer>;();var material = renderer.material;var sprite = sprites[index];var texSize = new Vector2(sprite.texture.width, sprite.texture.height);var rect = sprite.textureRect;material.mainTexture = sprite.texture;material.mainTextureOffset = new Vector2(rect.x/ texSize.x, rect.y / texSize.y);material.mainTextureScale = new Vector2(rect.width / texSize.x, rect.height / texSize.y);material.SetTexture("_MainTex",sprite.texture);material.SetTextureOffset("_MainTex", new Vector2(rect.x, rect.y));material.SetTextureScale("_MainTex", new Vector2(1 / rect.width, 1 / rect.height));renderer.material = material;}
Update is called once per frame
ドット絵を保持するマテリアル
*public Material material;
マテリアルのメインテクスチャサイズ
*private Vector2Int texSize;
Spriteのテクスチャ領域
*private RectInt spriteRect;
マテリアルのメインテクスチャサイズ
*private Vector2Int texSize;
Spriteのテクスチャ領域
*private RectInt spriteRect;
Inspector 表示用の警告メッセージ
*public string heplMessage;
... 中略 ...
*}
シリアライズオブジェクトの更新
*serializedObject.Update();
*serializedObject.ApplyModifiedProperties();*string help = shed.heplMessage;
シリアライズオブジェクトのプロパティの変更を更新
*{return true;}
プレビューウィンドウを表示するかどうか
*{ZoomAroundPivot = GUILayout.Toggle(ZoomAroundPivot, "zoom pivot");}
プレビューウィンドウのヘッダーバーをカスタムする関数
*{if (ZoomAroundPivot) _drawAroundPivot(r);else _drawEntire(r);}
プレビューウィンドウで描画させたいものはここで書く
3D投影サイズ境界のx,zを赤と緑の外殻線で描く
*var maxPos = new Vector2(offsetPos.x + drawSize.x + border * 2, offsetPos.y + drawSize.y + border * 2);
中央にスプライト領域を描画
*var drawRect = new Rect(offsetPos.x + border, offsetPos.y + border, drawSize.x, drawSize.y);
3D投影サイズ境界のx,zを赤と緑の外殻線で描く
*Handles.DrawSolidRectangleWithOutline(new Rect(r.x, r.yMax, hfWidth, border - 1), Color.green, Color.green);
中央にスプライト領域を描画
*var drawRect = new Rect(r.x, r.y, r.width, r.height - border);

*int a = "string";
int型にStringを入れようとしている エラー

*where T : struct { }
nullを許容しない
*where T : struct { }
引数でnullを許容する
*where T : class { }
型引数も引数もnull不許容参照型
*where T : class { }
型引数はnull不許容参照型で、引数はnull許容参照型
型引数がnull許容参照型ならば、引数もnull許容参照型
型引数がnull不許容参照型ならば、引数もnull不許容参照型
*void Do2<;T>;(T item)
*//     where T : class? { }
これは書けない
*//     where T : class? { }
void Do3&lt;T&gt;(T? item)
*//    where T : notnull { }
これは書けない
*//    where T : notnull { }
void Do&lt;T&gt;(T? item)
*public abstract class Enum : ValueType {}
where T : notnull { }
*enum MyEnum { ... }
独自定義したとする

*Label getFollowerName = new Label();
Labelインスタンス生成
FlowLayoutPanelに画像を追加する処理
*flowLayoutPanel1.Controls.Add(profilePic);
プロフィール画像のレイアウトを調整
*profilePic.Width = 60;
フォロワーのプロフィール画像を表示する処理
*profilePic.ImageLocation = tweetieBird.ProfileImageUrl;

PdfDocument objectを作成します。
*PdfDocument pdf = new PdfDocument();
PDFファイルをロードします。
*pdf.LoadFromFile("サンプル.pdf");
Excelで保存します。
*pdf.SaveToFile("PDFToExcel.xlsx", FileFormat.XLSX);

*datetimes.Add("past", new Dictionary<;string, DateTime>;{{"yesterday", new DateTime("yesterday")}} );
An item with the same key has already been added
*datetimes.Add("past", new Dictionary<;string, DateTime>;{{"yesterday", new DateTime("yesterday")}} );
これはOK

データベースの接続
*con.Open();
コマンドのセット
*command.CommandText = query;
コマンドの実行
*command.ExecuteNonQuery();
コミット
*transaction.Commit();
ロールバック
*transaction.Rollback();
データベースの接続終了
*con.Close();

*public static  IList<;Piece>; PieceList = new List<;Piece>; {new Piece(new char[,] {{ ' ','X',' ' },{ 'X','X','X' },{ ' ','X',' ' },}),new Piece(new char[,] {{ ' ','F','F' },{ 'F','F',' ' },{ ' ','F',' ' },}),...,,,public class Piece {// 一つのピースの配列の空白以外の場所の位置を記憶public IList<;Point>; Points { get; private set; }// 回転、反転させた全てのパターンを列挙（コンストラクタで設定）public IList<;Piece>; AllSeries { get; private set; }//  ピースのサイズpublic int YSize { get; set; }public int XSize { get; set; }// ピースの形を示す文字public char Char { get; private set; }// 右に90度回転public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt =>; new Point {X = pt.Y, Y = this.XSize - pt.X - 1}).OrderBy(pt =>; pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}// 左右に反転public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt =>; new Point {X = pt.X, Y = this.YSize - pt.Y - 1}).OrderBy(pt =>; pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}// 回転、反転の８つのピースを得る （左右対称なら４つ）private IEnumerable<;Piece>; AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j <; 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j <; 3; j++) {mirror = mirror.R90();yield return mirror;}}}},,,public bool Solve(int xSize, int ySize) {_board = new Board(xSize, ySize);return Solve(Piece.PieceList);}// 解を求める （再帰メソッド）private bool Solve(IEnumerable<;Piece>; pieceList) {// 最初のピースを取り出すvar piece = pieceList.FirstOrDefault();if (piece == null)// すべてのペースを使い切った(つまり成功)return true;// ピースを回転、反転させたものを取り出し試していく。foreach (var curr in piece.AllSeries) {// すべての位置を順に取り出す、そこにcurrを置いていくforeach (var topleft in _board.AllPoints) {// 取り出した位置(左上)にピースを置いてみるif (Put(topleft, curr)) {if (CountEmpty().Any(n =>; n % 5 != 0)) {// 5で割り切れない空き領域があれば、そこにピースははめ込むことができない。// 枝刈り処理 これ以上試しても仕方が無いので、次を試す。Remove(topleft, curr);continue;}var newlist = pieceList.Where(o =>; o.Char != curr.Char).ToList();// 置けたら残りのピースで同じことを繰り返すif (Solve(newlist) == true)// 成功したら処理を終えるreturn true;// 状態を戻して、次を試すRemove(topleft, curr);}}}return false;},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {public struct Point {public int X { get; set; }public int Y { get; set; }// 上下左右の位置を列挙public IEnumerable<;Point>; GetAroundPoints() {yield return new Point { X = this.X, Y = this.Y + 1 };yield return new Point { X = this.X + 1, Y = this.Y };yield return new Point { X = this.X - 1, Y = this.Y };yield return new Point { X = this.X, Y = this.Y - 1 };}// BoardにPieceを置く際に利用する。public Point Add(Point pt) {return new Point {X = X + pt.X,Y = Y + pt.Y};}public override int GetHashCode() {return Value;}public int Value {get { return X + Y * 100; }}}},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {public class Piece {public IList<;Point>; Points { get; private set; }public IList<;Piece>; AllSeries { get; private set; }public int YSize { get; set; }public int XSize { get; set; }public char Char { get; private set; }private Piece() {}public Piece(char[,] piece) {YSize = piece.GetUpperBound(1) + 1;XSize = piece.GetUpperBound(0) + 1;Points = GetAllPoints().Where(pt =>; piece[pt.X, pt.Y] != ' ').OrderBy(pt =>; pt.Value).ToList();var first = Points[0];Char = piece[first.X, first.Y];AllSeries = this.AllCandidates().Distinct(_pieceComparer).ToList();}// 右に90度回転public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt =>; new Point { X = pt.Y, Y = this.XSize - pt.X - 1 }).OrderBy(pt =>; pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}// 左右に反転public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt =>; new Point { X = pt.X, Y = this.YSize - pt.Y - 1 }).OrderBy(pt =>; pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}// ピースの全ての位置を列挙するprivate IEnumerable<;Point>; GetAllPoints() {for (int xx = 0; xx <; this.XSize; xx++) {for (int yy = 0; yy <; this.YSize; yy++) {yield return new Point { X = xx, Y = yy };}}}// 回転、反転の８つのピースを得る （左右対称なら４つ）private IEnumerable<;Piece>; AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j <; 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j <; 3; j++) {mirror = mirror.R90();yield return mirror;}}}private static PieceComparer _pieceComparer = new PieceComparer();// 利用するピースデータpublic static  IList<;Piece>; PieceList = new List<;Piece>; {new Piece(new char[,] {{ ' ','X',' ' },{ 'X','X','X' },{ ' ','X',' ' },}),new Piece(new char[,] {{ ' ','F','F' },{ 'F','F',' ' },{ ' ','F',' ' },}),new Piece(new char[,] {{ 'I','I','I','I','I' },}),new Piece(new char[,] {{ 'L',' ' },{ 'L',' ' },{ 'L',' ' },{ 'L','L' },}),new Piece(new char[,] {{ 'N',' ' },{ 'N',' ' },{ 'N','N' },{ ' ','N' },}),new Piece(new char[,] {{ 'P','P' },{ 'P','P' },{ 'P',' ' },}),new Piece(new char[,] {{ 'T','T','T' },{ ' ','T',' ' },{ ' ','T',' ' },}),new Piece(new char[,] {{ 'U',' ','U' },{ 'U','U','U' },}),new Piece(new char[,] {{ 'V',' ',' ' },{ 'V',' ',' ' },{ 'V','V','V' },}),new Piece(new char[,] {{ 'W',' ',' ' },{ 'W','W',' ' },{ ' ','W','W' },}),new Piece(new char[,] {{ ' ','Y' },{ 'Y','Y' },{ ' ','Y' },{ ' ','Y' },}),new Piece(new char[,] {{ 'Z','Z',' ' },{ ' ','Z',' ' },{ ' ','Z','Z' },}),};}},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {public class Board {private char[,] _box;int _xSize;int _ySize;// コンストラクタprivate Board(Board board) {this._xSize = board._xSize;this._ySize = board._ySize;this._box = board._box.Clone() as char[,];}// コンストラクタpublic Board(int xmax, int ymax) {_box = new char[xmax + 2, ymax + 2];_xSize = xmax + 2;_ySize = ymax + 2;foreach (var pt in GetPointsIncludeFrame()) {if (IsValidPoint(pt))this[pt] = ' ';elsethis[pt] = '*';}}// 枠も含めてすべての位置を列挙するprivate IEnumerable<;Point>; GetPointsIncludeFrame() {for (int yy = 0; yy <; this._ySize; yy++) {for (int xx = 0; xx <; this._xSize; xx++) {yield return new Point { X = xx, Y = yy };}}}private List<;Point>; _AllValidPoint = null;// 枠を除いた位置を列挙するpublic IEnumerable<;Point>; AllPoints {get {if (_AllValidPoint == null) {var list = new List<;Point>;();for (int yy = 1; yy <; this._ySize - 1; yy++) {for (int xx = 1; xx <; this._xSize - 1; xx++) {list.Add(new Point { X = xx, Y = yy });}}_AllValidPoint = list.OrderBy(pt =>; pt.X + pt.Y).ToList();}return _AllValidPoint;}}// インデクサpublic char this[Point pt] {get { return _box[pt.X, pt.Y]; }set { _box[pt.X, pt.Y] = value; }}// Boardの内容をプリントするpublic void Print() {var ystr = new string(Enumerable.Repeat('-', _xSize-2).ToArray());Console.WriteLine($"+{ystr}+");for (int y = 1; y <; _ySize - 1; y++) {Console.Write("|");for (int x = 1; x <; _xSize - 1; x++) {Console.Write(_box[x, y]);}Console.WriteLine("|");}Console.WriteLine($"+{ystr}+");}// 複製をつくるpublic Board Clone() {return new Board(this);}// 有効な位置か （枠ならばfalse)internal bool IsValidPoint(Point point) {return ((1 <;= point.X &amp;&amp; point.X <; _xSize - 1) &amp;&amp;(1 <;= point.Y &amp;&amp; point.Y <; _ySize - 1));}// Boardの内容を変更してしまうので注意。元の状態に戻すのは呼び出す側の責務とする。// Pointのの位置に注目した時に、いくつの空白があるかをカウントする。pointも含める。// 再帰的に処理をしている。internal int CountEmpty(Point point) {if (this[point] != ' ')return 0;this[point] = '#';int count = 1;foreach (var pt in point.GetAroundPoints()) {if (this[pt] == ' ') {count += CountEmpty(pt);}}return count;}}},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {// 2つのピースを比較するクラスpublic class PieceComparer : IEqualityComparer<;Piece>; {public bool Equals(Piece a, Piece b) {return a.Points.SequenceEqual(b.Points);}public int GetHashCode(Piece obj) {return obj.Points.Aggregate(0, (hc, pt) =>; hc ^ pt.GetHashCode());}}},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {public class Pentomino {private Board _board;// 問題を解くpublic bool Solve(int xSize, int ySize) {_board = new Board(xSize, ySize);return Solve(Piece.PieceList);}// 解を求める （再帰メソッド）private bool Solve(IEnumerable<;Piece>; pieceList) {// 最初のピースを取り出すvar piece = pieceList.FirstOrDefault();if (piece == null)// すべてのペースを使い切った(つまり成功)return true;// ピースを回転、反転させたものを取り出し試していく。。foreach (var curr in piece.AllSeries) {// すべての位置を順に取り出す、そこにcurrを置いていくforeach (var topleft in _board.AllPoints) {// 取り出した位置(左上)にピースを置いてみるif (Put(topleft, curr)) {if (CountEmpty().Any(n =>; n % 5 != 0)) {// 5で割り切れない空き領域があれば、そこにピースははめ込むことができない。// 枝刈り処理 これ以上試しても仕方が無いので、次を試す。Remove(topleft, curr);continue;}var newlist = pieceList.Where(o =>; o.Char != curr.Char).ToList();// 置けたら残りのピースで同じことを繰り返すif (Solve(newlist) == true)// 成功したら処理を終えるreturn true;// 状態を戻して、次を試すRemove(topleft, curr);}}}return false;}// ピースをBoardから取り除くprivate void Remove(Point topleft, Piece piece) {foreach (var pt in piece.Points) {var point = topleft.Add(pt);_board[point] = ' ';}}// ピースを指定位置に置くpublic bool Put(Point basePlace, Piece piece) {List<;Point>; save = new List<;Point>;();foreach (var pt in piece.Points) {var point = basePlace.Add(pt);if (_board.IsValidPoint(point) &amp;&amp;  _board[point] == ' ') {_board[point] = piece.Char;save.Add(point);} else {// やっぱり置けなかったので、元に戻す。foreach (var p in save)_board[p] = ' ';return false;}}return true;}// プリントpublic void Print() {_board.Print();}// 空いている領域の面積を列挙する。private IEnumerable<;int>; CountEmpty() {var bclone = _board.Clone();var pts = bclone.AllPoints.Where(pt =>; bclone[pt] == ' ').ToArray();return pts.Select(pt =>; bclone.CountEmpty(pt)).Where(cnt =>; cnt >; 0);}}},,,using System;namespace PentominoApp {class Program {static void Main(string[] args) {Pentomino solver = new Pentomino();Console.WriteLine(DateTime.Now);solver.Solve(12, 5);Console.WriteLine(DateTime.Now);solver.Print();Console.ReadLine();}}},,,*public IList<;Point>; Points { get; private set; }// 回転、反転させた全てのパターンを列挙（コンストラクタで設定）public IList<;Piece>; AllSeries { get; private set; }//  ピースのサイズpublic int YSize { get; set; }public int XSize { get; set; }// ピースの形を示す文字public char Char { get; private set; }// 右に90度回転public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt =>; new Point {X = pt.Y, Y = this.XSize - pt.X - 1}).OrderBy(pt =>; pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}// 左右に反転public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt =>; new Point {X = pt.X, Y = this.YSize - pt.Y - 1}).OrderBy(pt =>; pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}// 回転、反転の８つのピースを得る （左右対称なら４つ）private IEnumerable<;Piece>; AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j <; 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j <; 3; j++) {mirror = mirror.R90();yield return mirror;}}}}
一つのピースの配列の空白以外の場所の位置を記憶
*public IList<;Piece>; AllSeries { get; private set; }
回転、反転させた全てのパターンを列挙（コンストラクタで設定）
*public int YSize { get; set; }
ピースのサイズ
*public char Char { get; private set; }
ピースの形を示す文字
*public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt =>; new Point {X = pt.Y, Y = this.XSize - pt.X - 1}).OrderBy(pt =>; pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}
右に90度回転
*public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt =>; new Point {X = pt.X, Y = this.YSize - pt.Y - 1}).OrderBy(pt =>; pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}
左右に反転
*private IEnumerable<;Piece>; AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j <; 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j <; 3; j++) {mirror = mirror.R90();yield return mirror;}}}
回転、反転の８つのピースを得る （左右対称なら４つ）
*private bool Solve(IEnumerable<;Piece>; pieceList) {// 最初のピースを取り出すvar piece = pieceList.FirstOrDefault();if (piece == null)// すべてのペースを使い切った(つまり成功)return true;// ピースを回転、反転させたものを取り出し試していく。foreach (var curr in piece.AllSeries) {// すべての位置を順に取り出す、そこにcurrを置いていくforeach (var topleft in _board.AllPoints) {// 取り出した位置(左上)にピースを置いてみるif (Put(topleft, curr)) {if (CountEmpty().Any(n =>; n % 5 != 0)) {// 5で割り切れない空き領域があれば、そこにピースははめ込むことができない。// 枝刈り処理 これ以上試しても仕方が無いので、次を試す。Remove(topleft, curr);continue;}var newlist = pieceList.Where(o =>; o.Char != curr.Char).ToList();// 置けたら残りのピースで同じことを繰り返すif (Solve(newlist) == true)// 成功したら処理を終えるreturn true;// 状態を戻して、次を試すRemove(topleft, curr);}}}return false;}
解を求める （再帰メソッド）
最初のピースを取り出す
*var piece = pieceList.FirstOrDefault();
すべてのペースを使い切った(つまり成功)
*return true;
*foreach (var curr in piece.AllSeries) {*// すべての位置を順に取り出す、そこにcurrを置いていく
ピースを回転、反転させたものを取り出し試していく。
*foreach (var topleft in _board.AllPoints) {*// 取り出した位置(左上)にピースを置いてみる
すべての位置を順に取り出す、そこにcurrを置いていく
*if (Put(topleft, curr)) {*if (CountEmpty().Any(n =>; n % 5 != 0)) {
取り出した位置(左上)にピースを置いてみる
5で割り切れない空き領域があれば、そこにピースははめ込むことができない。
枝刈り処理 これ以上試しても仕方が無いので、次を試す。
*Remove(topleft, curr);
*if (Solve(newlist) == true)*// 成功したら処理を終える
置けたら残りのピースで同じことを繰り返す
成功したら処理を終える
*return true;
状態を戻して、次を試す
*Remove(topleft, curr);
*public IEnumerable<;Point>; GetAroundPoints() {yield return new Point { X = this.X, Y = this.Y + 1 };yield return new Point { X = this.X + 1, Y = this.Y };yield return new Point { X = this.X - 1, Y = this.Y };yield return new Point { X = this.X, Y = this.Y - 1 };}
上下左右の位置を列挙
*public Point Add(Point pt) {return new Point {X = X + pt.X,Y = Y + pt.Y};}
BoardにPieceを置く際に利用する。
*public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt =>; new Point { X = pt.Y, Y = this.XSize - pt.X - 1 }).OrderBy(pt =>; pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}
右に90度回転
*public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt =>; new Point { X = pt.X, Y = this.YSize - pt.Y - 1 }).OrderBy(pt =>; pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}
左右に反転
*private IEnumerable<;Point>; GetAllPoints() {for (int xx = 0; xx <; this.XSize; xx++) {for (int yy = 0; yy <; this.YSize; yy++) {yield return new Point { X = xx, Y = yy };}}}
ピースの全ての位置を列挙する
*private IEnumerable<;Piece>; AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j <; 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j <; 3; j++) {mirror = mirror.R90();yield return mirror;}}}
回転、反転の８つのピースを得る （左右対称なら４つ）
*public static  IList<;Piece>; PieceList = new List<;Piece>; {new Piece(new char[,] {{ ' ','X',' ' },{ 'X','X','X' },{ ' ','X',' ' },}),new Piece(new char[,] {{ ' ','F','F' },{ 'F','F',' ' },{ ' ','F',' ' },}),new Piece(new char[,] {{ 'I','I','I','I','I' },}),new Piece(new char[,] {{ 'L',' ' },{ 'L',' ' },{ 'L',' ' },{ 'L','L' },}),new Piece(new char[,] {{ 'N',' ' },{ 'N',' ' },{ 'N','N' },{ ' ','N' },}),new Piece(new char[,] {{ 'P','P' },{ 'P','P' },{ 'P',' ' },}),new Piece(new char[,] {{ 'T','T','T' },{ ' ','T',' ' },{ ' ','T',' ' },}),new Piece(new char[,] {{ 'U',' ','U' },{ 'U','U','U' },}),new Piece(new char[,] {{ 'V',' ',' ' },{ 'V',' ',' ' },{ 'V','V','V' },}),new Piece(new char[,] {{ 'W',' ',' ' },{ 'W','W',' ' },{ ' ','W','W' },}),new Piece(new char[,] {{ ' ','Y' },{ 'Y','Y' },{ ' ','Y' },{ ' ','Y' },}),new Piece(new char[,] {{ 'Z','Z',' ' },{ ' ','Z',' ' },{ ' ','Z','Z' },}),};
利用するピースデータ
*private Board(Board board) {this._xSize = board._xSize;this._ySize = board._ySize;this._box = board._box.Clone() as char[,];}
コンストラクタ
*public Board(int xmax, int ymax) {_box = new char[xmax + 2, ymax + 2];_xSize = xmax + 2;_ySize = ymax + 2;foreach (var pt in GetPointsIncludeFrame()) {if (IsValidPoint(pt))this[pt] = ' ';elsethis[pt] = '*';}}
コンストラクタ
*private IEnumerable<;Point>; GetPointsIncludeFrame() {for (int yy = 0; yy <; this._ySize; yy++) {for (int xx = 0; xx <; this._xSize; xx++) {yield return new Point { X = xx, Y = yy };}}}
枠も含めてすべての位置を列挙する
*public IEnumerable<;Point>; AllPoints {get {if (_AllValidPoint == null) {var list = new List<;Point>;();for (int yy = 1; yy <; this._ySize - 1; yy++) {for (int xx = 1; xx <; this._xSize - 1; xx++) {list.Add(new Point { X = xx, Y = yy });}}_AllValidPoint = list.OrderBy(pt =>; pt.X + pt.Y).ToList();}return _AllValidPoint;}}
枠を除いた位置を列挙する
*public char this[Point pt] {get { return _box[pt.X, pt.Y]; }set { _box[pt.X, pt.Y] = value; }}
インデクサ
*public void Print() {var ystr = new string(Enumerable.Repeat('-', _xSize-2).ToArray());Console.WriteLine($"+{ystr}+");for (int y = 1; y <; _ySize - 1; y++) {Console.Write("|");for (int x = 1; x <; _xSize - 1; x++) {Console.Write(_box[x, y]);}Console.WriteLine("|");}Console.WriteLine($"+{ystr}+");}
Boardの内容をプリントする
*public Board Clone() {return new Board(this);}
複製をつくる
*internal bool IsValidPoint(Point point) {return ((1 <;= point.X &amp;&amp; point.X <; _xSize - 1) &amp;&amp;(1 <;= point.Y &amp;&amp; point.Y <; _ySize - 1));}
有効な位置か （枠ならばfalse)
Boardの内容を変更してしまうので注意。元の状態に戻すのは呼び出す側の責務とする。
Pointのの位置に注目した時に、いくつの空白があるかをカウントする。pointも含める。
再帰的に処理をしている。
*internal int CountEmpty(Point point) {
*public class PieceComparer : IEqualityComparer<;Piece>; {public bool Equals(Piece a, Piece b) {return a.Points.SequenceEqual(b.Points);}public int GetHashCode(Piece obj) {return obj.Points.Aggregate(0, (hc, pt) =>; hc ^ pt.GetHashCode());}}
2つのピースを比較するクラス
*public bool Solve(int xSize, int ySize) {_board = new Board(xSize, ySize);return Solve(Piece.PieceList);}
問題を解く
*private bool Solve(IEnumerable<;Piece>; pieceList) {// 最初のピースを取り出すvar piece = pieceList.FirstOrDefault();if (piece == null)// すべてのペースを使い切った(つまり成功)return true;// ピースを回転、反転させたものを取り出し試していく。。foreach (var curr in piece.AllSeries) {// すべての位置を順に取り出す、そこにcurrを置いていくforeach (var topleft in _board.AllPoints) {// 取り出した位置(左上)にピースを置いてみるif (Put(topleft, curr)) {if (CountEmpty().Any(n =>; n % 5 != 0)) {// 5で割り切れない空き領域があれば、そこにピースははめ込むことができない。// 枝刈り処理 これ以上試しても仕方が無いので、次を試す。Remove(topleft, curr);continue;}var newlist = pieceList.Where(o =>; o.Char != curr.Char).ToList();// 置けたら残りのピースで同じことを繰り返すif (Solve(newlist) == true)// 成功したら処理を終えるreturn true;// 状態を戻して、次を試すRemove(topleft, curr);}}}return false;}
解を求める （再帰メソッド）
最初のピースを取り出す
*var piece = pieceList.FirstOrDefault();
すべてのペースを使い切った(つまり成功)
*return true;
*foreach (var curr in piece.AllSeries) {*// すべての位置を順に取り出す、そこにcurrを置いていく
ピースを回転、反転させたものを取り出し試していく。。
*foreach (var topleft in _board.AllPoints) {*// 取り出した位置(左上)にピースを置いてみる
すべての位置を順に取り出す、そこにcurrを置いていく
*if (Put(topleft, curr)) {*if (CountEmpty().Any(n =>; n % 5 != 0)) {
取り出した位置(左上)にピースを置いてみる
5で割り切れない空き領域があれば、そこにピースははめ込むことができない。
枝刈り処理 これ以上試しても仕方が無いので、次を試す。
*Remove(topleft, curr);
*if (Solve(newlist) == true)*// 成功したら処理を終える
置けたら残りのピースで同じことを繰り返す
成功したら処理を終える
*return true;
状態を戻して、次を試す
*Remove(topleft, curr);
*private void Remove(Point topleft, Piece piece) {foreach (var pt in piece.Points) {var point = topleft.Add(pt);_board[point] = ' ';}}
ピースをBoardから取り除く
*public bool Put(Point basePlace, Piece piece) {List<;Point>; save = new List<;Point>;();foreach (var pt in piece.Points) {var point = basePlace.Add(pt);if (_board.IsValidPoint(point) &amp;&amp;  _board[point] == ' ') {_board[point] = piece.Char;save.Add(point);} else {// やっぱり置けなかったので、元に戻す。foreach (var p in save)_board[p] = ' ';return false;}}return true;}
ピースを指定位置に置く
*foreach (var p in save)*_board[p] = ' ';
やっぱり置けなかったので、元に戻す。
*public void Print() {_board.Print();}
プリント
*private IEnumerable<;int>; CountEmpty() {var bclone = _board.Clone();var pts = bclone.AllPoints.Where(pt =>; bclone[pt] == ' ').ToArray();return pts.Select(pt =>; bclone.CountEmpty(pt)).Where(cnt =>; cnt >; 0);}
空いている領域の面積を列挙する。

*private const float limitPos = 5f;
横幅の制限
*if (Input.touchCount <;= 0) return;*if (Input.GetTouch (0).phase == TouchPhase.Moved) {
もし入力がなかったらreturnする
*transform.position = new Vector3 (Mathf.Clamp (transform.position.x, -limitPos, limitPos), transform.position.y, transform.position.z);*}
Clamp関数で制限する

*return this.name;
現在のname取得
*public Monkey(){}
Program.cs

範囲は-128~127で、符号付き8ビット整数
*short a=0;
範囲は-32768~32767で、符号付き16ビット整数
*int a=0;
範囲は-2147483648~2147483647で、符号付き32ビット整数
*long a=0;
範囲は-9223372036854770000~9223372036854775807で、符号付き64ビット整数
*byte a=0;
範囲は0~255で、符号なしビット整数
*ushort a=0;
範囲は0~65535で、符号なし16ビット整数
*uint a=0;
範囲は0~4294967295で、符号なし32ビット整数
*ulong a=0;
範囲は0~18446744073709551615で、符号なし64ビット整数
*float a=1.5;
浮動小数点型
範囲は±1.5e-45~±3.4e38(おおよその範囲)で、有効桁数7桁
*double a=1.5;
浮動小数点型
範囲は±5.0e-324~±1.7e308(おおよその範囲)で、有効桁数15~16桁
*bool a = true;
true/false(ブール値)
真か偽の格納のみを目的とした変数の作成にはbool型が適している
*char a='X';
範囲はU+0000~U+ffffで、Unicode16ビット文字
*decimal a = 199.9m;
範囲は±1.0×10-28~±7.9×1028で、有効桁数28~29桁の型がある。
*string a = "b " + "c";
*int[,]a={{1,2,3},{4,5,6}
文字列型
多次元配列1
*a[1,2]=9;
多次元配列2
javaは[][]だが,で区切るだけ
*,,,

*}
MssGetStructureAndValidateValue

*_is_hide = true;
表示状況を反転

*{//カンストを考慮して加算_exp = Mathf.Clamp(_exp + exp, 0, expArray[expArray.Length - 1]);// 値の更新UpdateLevel(expArray);UpdateRemainExp(expArray);}
Expを加算してLvを初期化する
カンストを考慮して加算
*_exp = Mathf.Clamp(_exp + exp, 0, expArray[expArray.Length - 1]);
値の更新
*UpdateLevel(expArray);
*var maxIdx = expArray.Where(x =>; x <;= _exp).Select((val, idx) =>; new {V = val, I = idx})
現Exp以下の値の中で最大の値のインデックスを取得
*var minIdx = expArray.Where(x =>; x >; _exp).Select((val, idx) =>; new {V = val, I = idx})
現Expより大きい値の中で最小の値のインデックスを取得
*{ExpLevel.AddExp(exp, TOTAL_EXP_ARRAY);}
経験値獲得処理
*{//カンストを考慮して加算_exp = Mathf.Clamp(_exp + exp, 0, expArray[expArray.Length - 1]);// 値の更新UpdateLevel(expArray);UpdateRemainExp(expArray);return (Level, RemainExp);}
Expを加算してLvを初期化する
カンストを考慮して加算
*_exp = Mathf.Clamp(_exp + exp, 0, expArray[expArray.Length - 1]);
値の更新
*UpdateLevel(expArray);
*var maxIdx = expArray.Where(x =>; x <;= _exp).Select((val, idx) =>; new {V = val, I = idx})
現Exp以下の値の中で最大の値のインデックスを取得
*var minIdx = expArray.Where(x =>; x >; _exp).Select((val, idx) =>; new {V = val, I = idx})
現Expより大きい値の中で最小の値のインデックスを取得
*{return ExpLevel.AddExp(exp, TOTAL_EXP_ARRAY);}
経験値獲得処理

*var groupName = "";
検索したいグループ名
名前やメールアドレスを取得できる
*var members = groupPrincipal.Members.OfType<;UserPrincipal>;();

*string ShopDomain = "sample.myshopify.com";
自分のShopify ECサイトドメイン
*ShopifyBuy.Client().Query(*// Pass a lambda expression to 'buildQuery'
This example uses named parameters but these could be omitted.

横並びにしたいGUI達
*GUILayout.EndHorizontal();

*if (rgx.Match(line).Success)*{
System.Console.WriteLine(line);

*[System.Security.SecuritySafeCritical]
auto-generated

*{string[] args = System.Environment.GetCommandLineArgs();for (int i = 0; i <; args.Length; ++i){switch (args[i]){case "-text":if (i + 1 <; args.Length){text.text = args[i + 1];}break;}}}
Start is called before the first frame update

DB接続
*private OracleConnection conn;
SQL発行に必要
*private OracleCommand cmd;
SELECT時の結果読み取りに利用
*private OracleDataReader reader;
Transactionに利用
*private OracleTransaction transaction;
Bind変数に利用する型
*public static int DATE = 0;
バインド変数の名前解決
*cmd.BindByName = true;
*if (reader != null) {*reader.Close();
実行系だとnullになる為
*public static String GetString(OracleDataReader read, string target) {if (read.GetValue(read.GetOrdinal(target)).ToString() == "") {return "";} else {return read.GetString(read.GetOrdinal(target));}}

*public static int GetInt16(OracleDataReader read, string target) {return read.GetInt16(read.GetOrdinal(target));}

*public static int GetInt32(OracleDataReader read, string target) {return read.GetInt32(read.GetOrdinal(target));}

*public static float GetFloat(OracleDataReader read, string target) {return read.GetFloat(read.GetOrdinal(target));}

*public static String GetDateString(OracleDataReader read, string target, string format) {*if (read.GetValue(read.GetOrdinal(target)).ToString() == "") {

第一引数はBind変数、第二引数は値、第三引数はカラムの型に合わせたもの
*dbControlt.SetBindVariable("hobby", "山登り", DbControl.VARCHAR2);

*{}
Start is called before the first frame update
*{var body = GameObject.Find ("Sphere").GetComponent<;Rigidbody>; ();if (Input.GetKey(KeyCode.UpArrow )) {body.WakeUp();}else if (Input.GetKey(KeyCode.DownArrow)){body.WakeUp();}else if (Input.GetKey(KeyCode.RightArrow)){body.WakeUp();}else if(Input.GetKey(KeyCode.LeftArrow)){body.WakeUp();}}
Update is called once per frame

バインドするローカルIPとポート番号
*string localIpString = "自分のIPアドレス";
UdpClientを作成し、ローカルエンドポイントにバインドする
*System.Net.IPEndPoint localEP =
データを受信する
*System.Net.IPEndPoint remoteEP = null;
データを文字列に変換する
*string rcvMsg = System.Text.Encoding.UTF8.GetString(rcvBytes);
受信したデータと送信者の情報を表示する
"exit"を受信したら終了
*if (RcvMsg[0] =="exit")
UdpClientを閉じる
*udp.Close();

*{private readonly T[] _array;public ArrayCollector(T[] array)=>; _array = array;~ArrayCollector(){ArrayPool<;T>;.Shared.Return(_array);}}
~~~
*var ndarray1 = NdArray.Create(new double[24], new int[]{2, 3, 4});
一次元のT型配列＋シェイプを表すint型配列から作ります
多次元配列を直接渡しても作れます
*var ndarray2 = NdArray.Create(new double[2, 3, 4]);
これ作ったときにはスライス構文はまだプロポーザルの段階だったので独自実装で無理やり。C# 8.0にはそのうちちゃんと対応したい・・・
*var sliced = ndarray1[new Index(1), Range.Whole, new Range(0, 4, 2)];
ToImmutableはコピーによる生成。
*var ndarray3 = mndarray1.ToImmutable();
MoveToImmutableはムーブによる生成。効率がいい代わりにもとのMutableNdArray&lt;T&gt;を破壊します。
*var ndarray4 = mndarray2.MoveToImmutable();
LinqのZipメソッドの適用
*var result1 = A.Zip(B, (a, b) =>; a + b);
これも上の式と全く同じ演算
*var result2 = (A, B).Zip((a, b) =>; a + b);
System.Threading.Tasks.Parallel.Forによる並列化
*var result = (ndarray1, ndarray2).Zip((x, y) =>; x + y, ParallelIterationStrategy.Instance);

*B(3
2);      OK

*CreateNoWindow = CreateNoWindow
コンソール・ウィンドウを開かない

CreateAppHost.csより引用
*HostWriter.CreateAppHost(appHostSourceFilePath: AppHostSourcePath,
HostWriter.csより引用
Re-write the destination apphost with the proper contents.
*using (var memoryMappedFile = MemoryMappedFile.CreateFromFile(appHostDestinationFilePath))
BinaryUtils.csより引用 (★部分は追記部分)
*private const UInt16 WindowsGUISubsystem = 0x2;
*if (subsystem[0] != WindowsCUISubsystem)*{
The subsystem of the prebuilt apphost should be set to CUI
★WindowsGUISubsystem(2)の書き込み
Set the subsystem to GUI
*subsystem[0] = WindowsGUISubsystem;

*output = Unity.MatToTexture(processor.Image, output);
if output is valid texture it's buffer will be re-used, otherwise it will be re-created

*originalPixels[i++]=255;
α

*public string url = "http:
IPアドレス:8000";
*//var www = new WWW(url, form);*//yield return www;
これはおそらくPOSTになってしまう
URLに接続して結果が戻ってくるまで待機
*yield return webRequest.SendWebRequest();

SubjectPoolに追加
*timer = this.CreateSubject<;int>;(timerKey);

Azure情報の設定
*var config = SpeechConfig.FromSubscription(KEY, REGION);
*if (!string.IsNullOrEmpty(PROXY_HOST))*config.SetProxy(PROXY_HOST, PROXY_PORT);
Proxyの設定
文字起こし開始
*var result = await RecognizeStartAsync(config, wavefile);
*{using (var recognizer = new SpeechRecognizer(config, audioInput)){// recognizer.Recognizing += (s, e) =>;// {//     Console.WriteLine($"RECOGNIZING: Text={e.Result.Text}");// };recognizer.Recognized += (s, e) =>;{if (e.Result.Reason == ResultReason.RecognizedSpeech){var time = TimeSpan.FromSeconds(e.Result.OffsetInTicks / 10000000).ToString(@"hh\:mm\:ss");var text = $"{time} {e.Result.Text}\n";Console.Write(text);sb.Append(text);}else if (e.Result.Reason == ResultReason.NoMatch){Console.WriteLine($"NOMATCH: Speech could not be recognized.");}};recognizer.Canceled += (s, e) =>;{// Console.WriteLine($"CANCELED: Reason={e.Reason}");if (e.Reason == CancellationReason.Error){Console.WriteLine($"CANCELED: ErrorCode={e.ErrorCode}");Console.WriteLine($"CANCELED: ErrorDetails={e.ErrorDetails}");Console.WriteLine($"CANCELED: Did you update the subscription info?");// ret = null;}stopRecognition.TrySetResult(0);};// recognizer.SessionStarted += (s, e) =>;// {//     Console.WriteLine("\n    Session started event.");// };// recognizer.SessionStopped += (s, e) =>;// {//     Console.WriteLine("\n    Session stopped event.");//     Console.WriteLine("\nStop recognition.");//     if (string.IsNullOrEmpty(ret))//         ret = "";//     stopRecognition.TrySetResult(0);// };// Starts continuous recognition. Uses StopContinuousRecognitionAsync() to stop recognition.await recognizer.StartContinuousRecognitionAsync().ConfigureAwait(false);// Waits for completion.// Use Task.WaitAny to keep the task rooted.Task.WaitAny(new[] { stopRecognition.Task });// Stops recognition.await recognizer.StopContinuousRecognitionAsync().ConfigureAwait(false);}}
SpeechToTextの開始
*// {//     Console.WriteLine($"RECOGNIZING: Text={e.Result.Text}");// };
recognizer.Recognizing += (s, e) =&gt;
*//     Console.WriteLine($"RECOGNIZING: Text={e.Result.Text}");
{
*{if (e.Result.Reason == ResultReason.RecognizedSpeech){var time = TimeSpan.FromSeconds(e.Result.OffsetInTicks / 10000000).ToString(@"hh\:mm\:ss");var text = $"{time} {e.Result.Text}\n";Console.Write(text);sb.Append(text);}else if (e.Result.Reason == ResultReason.NoMatch){Console.WriteLine($"NOMATCH: Speech could not be recognized.");}};
};
*if (e.Reason == CancellationReason.Error)*{
Console.WriteLine($"CANCELED: Reason={e.Reason}");
*// {//     Console.WriteLine("\n    Session started event.");// };
recognizer.SessionStarted += (s, e) =&gt;
*// {//     Console.WriteLine("\n    Session stopped event.");//     Console.WriteLine("\nStop recognition.");//     if (string.IsNullOrEmpty(ret))//         ret = "";//     stopRecognition.TrySetResult(0);// };
};
*// {//     Console.WriteLine("\n    Session stopped event.");//     Console.WriteLine("\nStop recognition.");//     if (string.IsNullOrEmpty(ret))//         ret = "";//     stopRecognition.TrySetResult(0);// };
recognizer.SessionStopped += (s, e) =&gt;
*//     if (string.IsNullOrEmpty(ret))*//         ret = "";
Console.WriteLine("\nStop recognition.");
*Task.WaitAny(new[] { stopRecognition.Task });
Waits for completion.
*Task.WaitAny(new[] { stopRecognition.Task });
Use Task.WaitAny to keep the task rooted.
ファイル一覧の取得
*var files = new List<;string>;();
*foreach (var file in files)*{
テキスト変換の開始

*{var pos = bounds.center;var hoseiX = -(PaddingLeft / 2) + (PaddingRight / 2);var hoseiY = -(PaddingBottom / 2) + (PaddingTop / 2);var hoseiZ = 0.01f;this.Background.transform.localPosition = new Vector3(pos.x + hoseiX, pos.y + hoseiY, pos.z + hoseiZ);}
Debug.Log($"{bounds}");
*{var pos = bounds.center;var hoseiX = -(PaddingLeft / 2) + (PaddingRight / 2);var hoseiY = -(PaddingBottom / 2) + (PaddingTop / 2);var hoseiZ = 0.01f;this.Background.transform.localPosition = new Vector3(pos.x + hoseiX, pos.y + hoseiY, pos.z + hoseiZ);}
描画位置の計算
*{var scale = bounds.extents;var hoseiW = (PaddingLeft + PaddingRight) / 10;var hoseiH = (PaddingTop + PaddingBottom) / 10;this.Background.transform.localScale = new Vector3((scale.x / 10 * 2) + hoseiW, 1, (scale.y / 10 * 2) + hoseiH);}
描画サイズの計算

*{}
Start is called before the first frame update

インスタンス生成
*BinaryReader reader = new BinaryReader(File.OpenRead(<;ファイル名>;));
*{int ret;byte[] buf = new byte[4];// 4byte読み取りret = reader.Read(buf, 0, 4);// 1byte以上読み取ったか// ※インデックスがファイルの末尾だった場合、Read()は0を返すwhile (ret >; 0){// 読み取った内容を16進数としてコンソールに出力for (int i = 0; i <; ret; i++){Console.WriteLine(buf[i].ToString("x"));}ret = reader.Read(buf, 0, 4);}}
"BinaryFile1.bin"を開く
4byte読み取り
*ret = reader.Read(buf, 0, 4);
1byte以上読み取ったか
※インデックスがファイルの末尾だった場合、Read()は0を返す
*while (ret >; 0)
*for (int i = 0; i <; ret; i++)*{
読み取った内容を16進数としてコンソールに出力
インスタンス生成
*BinaryWriter writer = new BinaryWriter(File.OpenWrite(<;ファイル名>;)
*{byte[] buf = new byte[] { 0x01, 0x02, 0x03, 0x04 };// 書き込みwriter.Write(buf);}
"BinaryFile2.bin"を開く
書き込み
*writer.Write(buf);
*{int ret;byte[] buf = new byte[4];ret = reader.Read(buf, 0, 4);while (ret >; 0){for (int i = 0; i <; ret; i++){Console.WriteLine(buf[i].ToString("x"));}ret = reader.Read(buf, 0, 4);}}
書き込んだ内容を読み込んでコンソール出力

インスタンス生成
*StreamReader reader = new StreamReader(<;ファイルパス>;);
*StreamReader reader = new StreamReader(<;ファイルパス>;, Encoding.GetEncoding("Shift_JIS"));*,,,
エンコーディング指定(Shift_JISを指定する場合)
*{string line;// ファイル末尾まで繰り返すwhile(!reader.EndOfStream){// ファイルから1行readline = reader.ReadLine();Console.WriteLine(line);}}
"TextFile1.txt"を開く
*while(!reader.EndOfStream)*{
ファイル末尾まで繰り返す
ファイルから1行read
*line = reader.ReadLine();
インスタンス生成
*StreamWriter writer = new StreamWriter(<;ファイルパス>;);
*StreamWriter writer = new StreamWriter(<;ファイルパス>;, Encoding.GetEncoding("Shift_JIS"));*,,,
エンコーディング指定(Shift_JISを指定する場合)
*{// 文字列を書き込むwriter.WriteLine("TextFileWriteSample");}
"TextFile2.txt" を開く
文字列を書き込む
*writer.WriteLine("TextFileWriteSample");
*{string line;while (!reader.EndOfStream){line = reader.ReadLine();Console.WriteLine(line);}}
書き込んだファイルを開いて内容をコンソール出力する

*if (m.Msg == 15)
WM_PAINT = 15
下だけボーダー表示
*g.DrawLine(new Pen(Color.Black), 0, this.Height - 1, this.Width, this.Height - 1);

通知用のチャンネルを作成
チャンネル情報は通知に表示されない。
*var c = new AndroidNotificationChannel
*public void DoNotification()*{
通知の関数　関数名は自由につける
*var n = new AndroidNotification*{
通知を送信する
アイコンはなくても動く
SmallIcon = "icon_0",
LargeIcon = "icon_1",
FireTime = DateTime.Now.AddSeconds(10),  10 秒後に通知
FireTime = DateTime.Now.AddSeconds(30),  10 秒後に通知
*};

*dao.Insert(new DataEntity { Id = 1L, Name = "Data-1", Type = "A" });
Insert
MethodInfoを元にSQLを構築
*var tokenizer = new SqlTokenizer(sql.ToString());

*var response = s_webClient.UploadValues("https:
slack.comapichat.postMessage", "POST", data);
OnSessionChange関数をの実行を有効にするため、CanHandleSessionChangeEventをtrueに
*CanHandleSessionChangeEvent = true;
スラックに投稿
*Rootobject rootobject = SlackSendMessage.SendMessage("リモート接続監視");

*q.Dequeue();
Id:40, Name:Name40, Age:20

処理
*}
無限(有限)に引数が増やせる
*Foo(a, b, ...);
各配列の要素が欲しいときは下記のように
a[第1引数][0番目]
*var tmp = a[0][0];

普通にラムダ式で呼び出し、変数のキャプチャ有り
*return _samples.FirstOrDefault(_ =>; _.Id == id);
拡張メソッドを利用、変数のキャプチャ無し
*return _samples.FirstOrDefault((x, state) =>; x.Id == state, id);
ローカル関数経由で呼び出し、変数のキャプチャ有り
*bool Func(Sample s) =>; s.Id == id;
*foreach (var i in _indexes)*{
普通にラムダ式で呼び出し、変数のキャプチャ有り

カレントカルチャを英語にする(Twitter データの曜日が英語なので)
*CultureInfo.CurrentCulture = CultureInfo.GetCultureInfo("en-US");
なぜか残ってる
*Console.WriteLine("Hello World!");
Twitter アプリのコンシューマーキーとシークレット
*var session = OAuth.Authorize("hogehoge", "piyopiyo");
*Console.WriteLine("Access to {0}, and get PIN code.", session.AuthorizeUri.AbsoluteUri);
アプリ認証用URLを表示させる
認証させる
*var token = OAuth.GetTokens(session, pin);
*Console.WriteLine("ここまで消します:{0}", dateTime.ToString());
どこまで消すかのDateTime構造体を取得しておく
tweet.jsの冒頭にある文字を消してプレーンなjsonにするために、最初にくる[までなかったことにする。
*file = file.Substring(file.IndexOf("[") - 1);
パースしてあげる。
*var json = JArray.Parse(file);
すべてのツイートを必要な情報だけList&lt;Tweet&gt;にいれておく
*var list = new List<;Tweet>;();
削除対象のList&lt;Tweet&gt;。処理の簡単のために別のListに。
*var deleteList = new List<;Tweet>;();
ツイートの時刻からDateTime構造体を取得して、先ほど指定した時刻より小さかったら？古かったら削除対象リストに入れる。
*var thisDate = GetDate(item.Date);
わざわざ言ってくれるの親切。
*Console.WriteLine("実際に消していきます。");
*{// 削除APIを叩く。long型なので変換してやってねtoken.Statuses.Destroy(Convert.ToInt64(item.ID));// 削除できたっぽいので教えてあげる。Console.WriteLine("削除しました: {0} / {1} / {2}", item.ID, item.Date, item.Text);}
キタ！ついに例外処理を始めたぞ！！！
削除APIを叩く。long型なので変換してやってね
*token.Statuses.Destroy(Convert.ToInt64(item.ID));
*Console.WriteLine("削除しました: {0} / {1} / {2}", item.ID, item.Date, item.Text);
削除できたっぽいので教えてあげる。
*Console.WriteLine("見つかりませんでした: {0} / {1} / {2}", item.ID, item.Date, item.Text);
よくわかんないけど、ツイートがすでに存在しなかったらこの例外が投げられるのでcatch。
*Console.WriteLine("見つかりませんでした: {0} / {1} / {2}", item.ID, item.Date, item.Text);
ざんねん！見つからなかったと教えてあげよう。
1秒間に何度も叩かれるとTwitterさんが困っちゃうと思うので、1000ミリ秒お休みしてもらう
*Thread.Sleep(1000);
入力待ちでポーズ。
*Console.ReadLine();
*var format = "ddd MMM dd HH:mm:ss K yyyy";*// 普通のDateTime.Parseじゃあ多分例外吐く。
Twitter データのフォーマットがこれなので、これでDateTime構造体に変換してあげる。
*var dateTime = DateTime.ParseExact(date, format, null);*return dateTime;
普通のDateTime.Parseじゃあ多分例外吐く。
*{public string ID;public string Date;public string Text;}
IDと時間を保持しておくクラス。内容は表示用のおまけ。

*using System.Runtime.InteropServices;
DllImport

*foreach(var v in view){if(v == "DocumentType"){result = true;}}
result = view.Contains('DocumentType');

*bufferSize: 4096, useAsync: true))
useAsync=true もしくは options=FileOptions.Asynchronous

ファイルを読み込んで XDocument に置換 → XDocument をカスタムモデルにデシリアライズ
*XDocument xml = XDocument.Load(Path.Combine(Directory.GetCurrentDirectory(), @"XMLFile1.xml"));
カスタムモデルを XDocument にシリアライズ → XDocument を XML 形式でファイルに書き込み
*var doc = XmlConvert.SerializeXDocument(myModel);
カスタムモデルを文字列にシリアライズ
*var str = XmlConvert.SerializeObject(myModel);

ButtonBase.ClickイベントのRoutedEventHandlerを登録する
*routedEventHandler = new RoutedEventHandler(AssociatedObject_MouseDown);
UIElement.MouseUpEventイベントのRoutedEventHandlerを登録する
*routedEventHandler = new RoutedEventHandler(AssociatedObject_MouseDown);

問題のコードをここに書く
*}
*public static int MyFunction (int n) {// 便利な処理// ~~~~~~~~// ~~~~~~~~}
自作の関数
便利な処理
~~~~~~~~
~~~~~~~~
*}
*public static long MySuperAlgorithm (long m) {// ちょーすごいアルゴリズム// ~~~~~~~~// ~~~~~~~~}
自作のすごい関数
ちょーすごいアルゴリズム
~~~~~~~~
~~~~~~~~
*}

Webページを開く
driver.Navigate().GoToUrl("https:www.google.co.jp/");
検索ボックス
*textbox = driver.FindElement(By.Name("q"));
検索ボックスに検索ワードを入力
*textbox.SendKeys("Selenium");
検索ボタン
*findbuttom = driver.FindElement(By.Name("btnK"));
検索ボタンをクリック
*findbuttom.Click();

マウス押下中フラグ
*private bool _isMouseDown;
マウスの移動が開始されたときの座標
*private Point _startPoint;
マウスの現在位置座標
*private Point _currentPoint;
*{// フラグを"マウス押下中"にする_isMouseDown = true;// GetPositionメソッドで現在のマウス座標を取得し、マウス移動開始点を更新// （マウス座標は、OperationAreaからの相対的な位置とする）_startPoint = e.GetPosition(OperationArea);// イベントを処理済みとする（当イベントがこの先伝搬されるのを止めるため）e.Handled = true;}
マウス左ボタン押下イベントのイベントハンドラ
フラグを"マウス押下中"にする
*_isMouseDown = true;
GetPositionメソッドで現在のマウス座標を取得し、マウス移動開始点を更新
（マウス座標は、OperationAreaからの相対的な位置とする）
*_startPoint = e.GetPosition(OperationArea);
イベントを処理済みとする（当イベントがこの先伝搬されるのを止めるため）
*e.Handled = true;
*{// マウス押下中フラグを落とす_isMouseDown = false;e.Handled = true;}
マウス左ボタン解放イベントのハンドラ
マウス押下中フラグを落とす
*_isMouseDown = false;
*{// マウス押下中でなければドラッグ操作ではないのでメソッドを抜けるif (!_isMouseDown){return;}// マウスの現在位置座標を取得（OperationAreaからの相対位置）_currentPoint = e.GetPosition(OperationArea);//移動開始点と現在位置の差から、MouseMoveイベント1回分の移動量を算出double offsetX = _currentPoint.X - _startPoint.X;double offsetY = _currentPoint.Y - _startPoint.Y;// 動かす対象の図形からMatrixオブジェクトを取得// このMatrixオブジェクトを用いて図形を描画上移動させるMatrix matrix = ((MatrixTransform)Target.RenderTransform).Matrix;// TranslateメソッドにX方向とY方向の移動量を渡し、移動後の状態を計算matrix.Translate(offsetX, offsetY);// 移動後の状態を計算したMatrixオブジェクトを描画に反映するTarget.RenderTransform = new MatrixTransform(matrix);// 移動開始点を現在位置で更新する// （今回の現在位置が次回のMouseMoveイベントハンドラで使われる移動開始点となる）_startPoint = _currentPoint;e.Handled = true;}
マウス移動イベントのイベントハンドラ
*if (!_isMouseDown)*{
マウス押下中でなければドラッグ操作ではないのでメソッドを抜ける
マウスの現在位置座標を取得（OperationAreaからの相対位置）
*_currentPoint = e.GetPosition(OperationArea);
移動開始点と現在位置の差から、MouseMoveイベント1回分の移動量を算出
*double offsetX = _currentPoint.X - _startPoint.X;
動かす対象の図形からMatrixオブジェクトを取得
このMatrixオブジェクトを用いて図形を描画上移動させる
*Matrix matrix = ((MatrixTransform)Target.RenderTransform).Matrix;
TranslateメソッドにX方向とY方向の移動量を渡し、移動後の状態を計算
*matrix.Translate(offsetX, offsetY);
*Target.RenderTransform = new MatrixTransform(matrix);*// 移動開始点を現在位置で更新する
移動後の状態を計算したMatrixオブジェクトを描画に反映する
移動開始点を現在位置で更新する
（今回の現在位置が次回のMouseMoveイベントハンドラで使われる移動開始点となる）
*_startPoint = _currentPoint;
*{_isMouseDown = false;e.Handled = true;}
マウスが離れたときのイベントハンドラ

button1 省略
*this.button1.Click += new System.EventHandler(this.button1_Click);
button2 省略
*this.button2.Click += new System.EventHandler(this.button2_Click);

実行順序を変えるとtab幅がおかしくなるので注意
baseFont = new Font("ＭＳ ゴシック",     12);  rtxt.Font.Size);
*boldFont = new Font(baseFont.FontFamily, baseFont.Size, baseFont.Style | FontStyle.Bold);
*Load      += (sender,e)=>;{spl.SplitterDistance = nudG.Bottom;};
spl.IsSplitterFixed = true; はユーザがつかめないようにするだけで、固定してくれないっぽい。まぎらわしい。。
2019.12.27追記: AllocCoTaskMemに対する解放処理が漏れている
*return ret;

*if ( p.X == c.X &amp;&amp; p.Y == c.Y ) {
例外処理
*if ( MyAbsInt(p.Y-c.Y)*(long)W <;= MyAbsInt(p.X-c.X)*(long)H ) {*int dY = (int)((((long)W/2) * (p.Y-c.Y))/(p.X-c.X));
abs((p.Y-c.Y)/(p.X-c.X)) &lt;= H/W  なら  領域0か2
*if ( c.X <; p.X ) {*t.X = c.X + W/2;
p.X==c.X なら、p.Y==c.Yであり、先の例外処理でこのifには入らないのでゼロ除算は回避できる(W&gt;0が前提)

トランザクション
*Console.WriteLine("=================================================");
32bitで動かす必要がある
https:www.c-sharpcorner.com/uploadfile/mahesh/using-adox-with-ado-net/
Microsoft ADO Ext 6.0
*var ct = new ADOX.Catalog();
トランザクション
*Console.WriteLine("=================================================");
*//C:\Program Files (x86)\MySQL\MySQL Installer for Windows\MySql.Data.dll*using MySql.Data.MySqlClient;
以下を参照
トランザクション
*Console.WriteLine("=================================================");
*{cmd.Parameters.AddWithValue("@user", "丹下さくら");cmd.Parameters.AddWithValue("@age", 43);cmd.ExecuteNonQuery();}
Perform database operations
*{cmd.Parameters.AddWithValue("@user", "丹下さくら");cmd.Parameters.AddWithValue("@age", 43);cmd.ExecuteNonQuery();}
Perform database operations
*{cmd.Connection = conn;cmd.CommandText = "truncate table test_tbl";cmd.ExecuteNonQuery();}

*{cmd.Connection = conn;cmd.CommandText = "INSERT INTO test_tbl (user_name, age) VALUES (@user, @age)";cmd.Parameters.AddWithValue("user", "明日のジョー");cmd.Parameters.AddWithValue("age", 17);cmd.ExecuteNonQuery();}
Insert some data
トランザクション
*Console.WriteLine("=================================================");
トランザクション
*Console.WriteLine("=================================================");
ストアドの試験
*Console.WriteLine("=================================================");
トランザクション
*Console.WriteLine("=================================================");
*{cmd.Parameters.Add(new OracleParameter("userName", "丹下さくら"));cmd.Parameters.Add(new OracleParameter("age", 43));cmd.ExecuteNonQuery();}
Perform database operations
*{cmd.Parameters.Add(new OracleParameter("userName", "丹下さくら"));cmd.Parameters.Add(new OracleParameter("age", 43));cmd.ExecuteNonQuery();}
Perform database operations
トランザクション
*Console.WriteLine("=================================================");
*{cmd.Parameters.AddWithValue("@user", "丹下さくら");cmd.Parameters.AddWithValue("@age", 43);cmd.ExecuteNonQuery();}
Perform database operations
*{cmd.Parameters.AddWithValue("@user", "丹下さくら");cmd.Parameters.AddWithValue("@age", 43);cmd.ExecuteNonQuery();}
Perform database operations

*FastestMedian(InputGrayImage , MedianImage ,5);
入力，出力，n*nのブロックでフィルタ

*bmpOrg = new Bitmap(10,10,PixelFormat.Format32bppArgb);
dummy to avoid null
*if ( dlg.ShowDialog() == DialogResult.OK ) {Bitmap tmp = null;try {tmp = (Bitmap)Bitmap.FromFile(dlg.FileName);}catch (OutOfMemoryException e) {  MessageBox.Show(e.ToString()); }catch (FileNotFoundException e) { MessageBox.Show(e.ToString()); }catch (InvalidCastException e) {  MessageBox.Show(e.ToString()); }if ( tmp != null ) {bmpOrg = tmp;RedrawPct();}}
dlg.CheckFileExists = true;
*if ( dlg.ShowDialog() == DialogResult.OK ) {*Bitmap tmp = null;
dlg.CheckPathExists = true;
*if ( dlg.ShowDialog() == DialogResult.OK ) {bmpOrg.Save(dlg.FileName, System.Drawing.Imaging.ImageFormat.Png);}
dlg.OverwritePrompt = true;
*if ( dlg.ShowDialog() == DialogResult.OK ) {*bmpOrg.Save(dlg.FileName, System.Drawing.Imaging.ImageFormat.Png);
dlg.CheckPathExists = true;

*previewImageUrl = "https:
sqlvaidccykhi26mlc.blob.core.windows.netmisc-sho-junkboxcoast-preview.jpg"

ここはC#からILの段階で畳み込まれる。
*const double a = 60 * (Math.PI / 180);

*if (Input.GetKey(KeyCode.LeftArrow))*{
左右の矢印で増減するようにする(いろいろ良くない)
最大が500なので、割り算して比率で突っ込む
*_image.fillAmount = _myHp / 500.0f;
Image系はUIなので追加
*using UnityEngine.UI;
Image型の変数_imageを宣言しておく
*private Image _image;
thisいらないけど、自分のだよ、ということで説明のために
*_image = this.GetComponent<;Image>;();

*Console.WriteLine(instance1 == instance2);
&lt;-- True が出力される

*public void Guard() {
防御処理}

*solver.AddGoal(objVId, 0, true);
true: minimize
変数
*int vId;
範囲
*solver.SetBounds(vId, minValues[i], maxValues[i]);
初期値
*solver.SetValue(vId, initialValues[i]);
目的関数をセット
*Func<;INonlinearModel, int, ValuesByIndex, bool, double>; callbackFunc2 =
*{return solver.IterationCount >;= maxIter;};
中止関数
解く
*var solverParams = new NelderMeadSolverParams(abortFunc);
直角コーナー
*double theta = (i + 1) / (double)paramCnt * Math.PI / 4.0;

*ExecuteAnotherApp("FusaFusa.exe","hage husa husahusa", false, true);
"hage husa husa"引数は三つ．なしのときは""でいい

*private Light spotLight;
ONOFFするライト
*{spotLight = GetComponent<;Light>;();}
Use this for initialization
*{}
Update is called once per frame

正常ケース
存在するキーを指定し、値を取得
*try
異常ケース
存在しないキーを指定し、値を取得
*try
正常ケース
存在するキーを指定し、値を設定
*try
正常ケース？
存在しないキーを指定し、値を設定
*try
*Console.WriteLine($"success - value is {a}");
問題なく動く

*DirectorySize += GetDirectorySize(di);
サブフォルダのサイズを合算

省略
*}

*var text2 = string.Format("Value is {0}",v);
string.Format()
*var text0 = $"Value is {v}";
string interpolation

*var tleHtml = wc.DownloadString("https:
celestrak.comsatcattle.php?CATNR=27424");

*public string TestLockMessage { get; set; } = "ろぐいんちゅうでっせー";
ログイン中のメッセージを追加

*startEvent.Invoke();
ここにトリガーをオンにするイベントを登録

*terrainData.SetHeightsDelayLOD(hx, hy, heights);
ハイトマップに反映

Photonに接続する(引数でゲームのバージョンを指定できる)
*PhotonNetwork.ConnectUsingSettings(null);
*void OnJoinedLobby() {Debug.Log("ロビーに入りました。");// ルームに入室するPhotonNetwork.JoinRandomRoom();}
ロビーに入ると呼ばれる
ルームに入室する
*PhotonNetwork.JoinRandomRoom();
*void OnJoinedRoom() {Debug.Log("ルームへ入室しました。");}
ルームに入室すると呼ばれる
*void OnPhotonRandomJoinFailed() {Debug.Log("ルームの入室に失敗しました。");// ルームがないと入室に失敗するため、その時は自分で作る// 引数でルーム名を指定できるPhotonNetwork.CreateRoom("myRoomName");}
ルームの入室に失敗すると呼ばれる
ルームがないと入室に失敗するため、その時は自分で作る
引数でルーム名を指定できる
*PhotonNetwork.CreateRoom("myRoomName");

*if ( (m=rxp.Match(s)).Success ) {
透過色指定

入力の桁数（トリムしたあと）が1以上なら正常
*return ValidationResult.Success;
入力の桁数（トリムしたあと）が0以下なら異常
*return new ValidationResult(_errorMessage);
タグに「required="required"」と「required-err-msg="&lt;エラーメッセジ&gt;"」を設定する
*MergeAttribute(context.Attributes, "required", "required");
*{[RequiredH5(errorMessage: "メッセージ変更")]public string UserID { get; set; }[RequiredH5][DataType(DataType.Password)]public string Password { get; set; }[Display(Name = "Remember me?")]public bool RememberMe { get; set; }}
(class InputModelの部分を抜粋)

*//   foreach(string fmt in data.GetFormats(){Console.WriteLine(fmt);}*if (data.GetDataPresent("Embedded Object")) {
関連付けられているすべての形式を列挙する
*if (data.GetDataPresent("Embedded Object")) {*dynamic obj = data.GetData("Embedded Object");
foreach(string fmt in data.GetFormats(){Console.WriteLine(fmt);}

*public ActionResult<;IEnumerable<;string<;<; Get(){
略}
*[HttpPut("{id}")]
PUT api/values/5
*public void Post( [FromBody] string value ){}
POST api/values
*[HttpDelete("{id}")]
DELETE api/values/5

Webページを開く
driver.Navigate().GoToUrl("https:www.google.co.jp/");
検索ボックス
*textbox = driver.FindElement(By.Name("q"));
検索ボックスに検索ワードを入力
*textbox.SendKeys("Selenium");
検索ボタン
*findbuttom = driver.FindElement(By.Name("btnK"));
検索ボタンをクリック
*findbuttom.Click();

*if (novelListIndex <; messageList.Count)
全ての会話を表示していない場合

*Console.WriteLine(y3);
255

*string authValue = ((int)Authority.ReadWrite).ToString();
こんな感じ

ピクチャーボックス表示用
*System.Drawing.Bitmap myBitmap;
svgファイル読み込み
*var Magick = new ImageMagick.MagickImage("Sample.svg");
ピクチャーボックスへ表示する為、Bitmapへ変換
*myBitmap = Magick.ToBitmap();
リソース解放
*myMagick.Dispose();
pictureBox1に表示
*pictureBox1.Image = myBitmap;

*return Redirect ("https:
dongsu.dev");

*void Start () {gamaClearText.gameObject.SetActive (false);resetButton.gameObject.SetActive (false);rdnum = Random.Range (0, cube.Length);scoreText.text = "得 点 : ";gameflag = true;}
Use this for initialization
*void Update () {if(gameflag){for(int i=0;i<;cube.Length;i++){if (i != rdnum) {cube [i].gameObject.transform.Rotate (3, 0, 3);} else {cube [i].gameObject.transform.Rotate (-3, 0, -3);}}time += Time.deltaTime;timeText.text = time.ToString("f2");scoreText.text = "得 点 : " + score;if(score == 5){gameflag = false;gamaClearText.gameObject.SetActive (true);resetButton.gameObject.SetActive (true);}}}
Update is called once per frame

*var clipInfo = animator.GetCurrentAnimatorClipInfo(0)[0];
引数はLayer番号、配列の0番目

*var h = domainObject.Height
100.0F;  cm -&gt; m

必要コンポーネント
*[RequireComponent(typeof(MeshRenderer))]
*for(int i = 0; i <; 3; i++)*{
極座標ベース
頂点情報をもとに法線を計算
*mesh.RecalculateNormals();

MVCモジュールの導入
*services.AddMvc ();
*services.Configure<;RouteOptions>; (options =>; {options.ConstraintMap.Add ("name", typeof (NameRouteConstraint));});
定義したカスタムルート制約

*if (val == 1) {*Console.WriteLine("val = 1");
int型やstring型
*if (flg) {*Console.WriteLine("flg = true");
boolean型
*if (val >; 0) {Console.WriteLine("val != 0");} else {Console.WriteLine("val = 0");}
intやStringに値が入っているかは、
*if (val >; 0) {*Console.WriteLine("val != 0");
ちゃんと条件式を書く必要がある。

*effects.transform.position = hitResult.point;*var cameraPos = Camera.main.transform.position;
エフェクト表示

*string exeName = ExeFileName;
実行ファイル名

MVCモジュールの導入
*services.AddMvc ();
デフォルトルートの設定
*routes.MapRoute (
*namespace ds.Tutorial.web.Controllers {// 2. Controllerを継承public class HomeController : Controller {// 3. Action Methodの定義public IActionResult Index () {return Content ("Hello World!");}}}
1.MVC名前空間を追加
*public class HomeController : Controller {// 3. Action Methodの定義public IActionResult Index () {return Content ("Hello World!");}}
2. Controllerを継承
*public IActionResult Index () {return Content ("Hello World!");}
3. Action Methodの定義

*{}
Start is called before the first frame update
*{}
Update is called once per frame
クラスの中身
*}
メソッドの中身
*}
メソッドの中身
*}
*{speed = Random.Range(5f, 15f);}
Start is called before the first frame update
*{transform.position += new Vector3(Input.GetAxis("Horizontal") * Time.deltaTime, 0f, 0f);}
Update is called once per frame
*{speed = 5f;}
Start is called before the first frame update
Start()メソッドはここまでなので、ここで変数 speed は破棄される
*}
ここでは speed 変数は存在しない
*}

抽出結果を格納したい
*var result = new List<;string>;();
*var matches = Regex.Matches("0123abcdXyx", "[0-9a-fA-F]{2}");
16進数文字列を2文字ずつ取得
MatchCollectionクラスはIEnumerableでIEnumerable&lt;T&gt;じゃないので
そのままだとLinqが使えないのでIEnumerable&lt;Match&gt;にキャストしてから使う。
*result.AddRange(matches.Cast<;Match>;().Select(m =>; m.Value));

Nullの場合だけインスタンス生成
*_instance = new HogeManager();

*{}
Start is called before the first frame update
*{}
Update is called once per frame

*Screen s = Screen.AllScreens[1];
セカンダリ（今回撮るのはこっち）

例えば "test" という文字は選択された場合、選択できなくする
*textBoxValue = _textBoxValue;
例えば "test" という文字は選択された場合、選択できなくする
元のデータをバックアップ
*var _comboBoxList = ComboBoxList.ToList();
リストを更新することで強制的にComboBoxの更新を行う
*ComboBoxList.Clear();
元のデータを戻す
*textBoxValue = _textBoxValue;
*if (value != "test")*{
例えば "test" という文字が選択された場合、選択できなくする
ComboBox以外にも通知する
*RaisePropertyChanged(nameof(TextBoxValue));

*private const int FOF_NOCONFIRMATION = 0x0010;
Show no confirmation dialog box to the user

C#もこの書き方でOK
*Console.WriteLine(moji + suji);

*var outerUrl = $"https:
twitter.comintenttweet?text={UnityWebRequest.EscapeURL (outerMessage)}&amp;url={UnityWebRequest.EscapeURL (innerUrl)}";

変換情報の辞書情報（再帰関数内で使用されるため面倒なのでGlobalで宣言）
*Dictionary<;String, String>; replaceKeyValDic = new Dictionary<;string, string>;();
置換文字列情報を設定分追加
*replaceKeyValDic.Add("置き換え対象文字列","置き換え文字列");
PPTのインスタンス作成
*app = new Microsoft.Office.Interop.PowerPoint.Application();
PPTファイルオープン
*ppt = app.Presentations.Open(
*for (int i = 1; i <;= ppt.Slides.Count; i++)*{
スライドのインデックスは１から　順にループする
生成PPTファイルの保存を実行
*ppt.SaveAs(pptGenerateFilePath,
*if (ppt != null)*{
PPTファイルを閉じる
*if (app != null)*{
PPTインスタンスを閉じる
PPT内の文字列置き換えを実施
*shape.TextFrame.TextRange.Text = replaceStr(shape.TextFrame.TextRange.Text);
*if (shape.Type == Microsoft.Office.Core.MsoShapeType.msoGroup)*{
構造が入れ子になっている場合を考慮し、再帰検索を実施
項目設定文字列を置き換え（再帰呼び出し）
*getShapeText(childShape);
*if (shape.Type == Microsoft.Office.Core.MsoShapeType.msoTable)*{
テーブル情報取得
PPTテンプレートに「[置き換え対象文字列]」の書式で設定したものを変換
*targetStr = targetStr.Replace("[" + replaceKeyValKey + "]", replaceKeyValDic[replaceKeyValKey]);

*if(i==0){break;}
１個だけで終了させる
リソースの解放
*Marshal.ReleaseComObject(shellApp);

*{public User FindUser(int id){using (IDbConnection conn = GetConnection()){try{return conn.QueryFirst<;User>;(@"SELECT * from users where id = @id", new { id });}catch (Exception){// レコードが1件も無いthrow;}}}private IDbConnection GetConnection() =>; throw new NotImplementedException();}
中略
レコードが1件も無い
*throw;
*{public User FindUser(int id){using (IDbConnection conn = GetConnection()){return conn.QueryFirstOrDefault<;User>;(@"SELECT * from users where id = @id", new { id });}}private IDbConnection GetConnection() =>; throw new NotImplementedException();}
中略
*{public User FindUser(int id){using (IDbConnection conn = GetConnection()){try{return conn.QuerySingle<;User>;(@"SELECT * from users where id = @id", new { id });}catch (Exception){// レコード0件もしくはレコード複数件throw;}}}private IDbConnection GetConnection() =>; throw new NotImplementedException();}
中略
レコード0件もしくはレコード複数件
*throw;
*{public User FindUser(int id){using (IDbConnection conn = GetConnection()){try{return conn.QuerySingleOrDefault<;User>;(@"SELECT * from users where id = @id", new { id });}catch (Exception){// レコード複数件throw;}}}private IDbConnection GetConnection() =>; throw new NotImplementedException();}
中略
レコード複数件
*throw;

*builder.AddSignInManager();
こいつがないとサインインができない
AddRelatedParts(builder, framework);    &lt;&lt;= おそらくここですべてのページを作っているのでコメントアウト
builder.Services.ConfigureOptions(                &lt;&lt;= なにやらいろいろしているようですが、「IdentityDefaultUIConfigureOptions」がinnerなのでコメントアウト、将来使うかも
typeof(IdentityDefaultUIConfigureOptions&lt;&gt;)
.MakeGenericType(builder.UserType));
builder.Services.TryAddTransient&lt;IEmailSender, EmailSender&gt;();   この部分はメールを利用しないなら消してもよさそう、消す場合はclass「EmailSender」も不要
builder.Services.Configure&lt;DefaultUIOptions&gt;(o =&gt; o.UIFramework = UIFramework.Bootstrap3);   これは将来的にIdentity画面を変更してBootstrapを利用しないなら不要かと思う
*}

*{ws.Send(messageInput.text);}
サーバへ、メッセージを送信する
*{chatText.text += (text + "\n");}
サーバから受け取ったメッセージを、ChatTextに表示する
*{chatText.text = ("Close.");}
サーバの接続が切れたときのメッセージを、ChatTextに表示する
接続処理。接続先サーバと、ポート番号を指定する
ws = new WebSocket("ws:localhost:12345/");
*ws.Connect();
送信ボタンが押されたときに実行する処理「SendText」を登録する
*sendButton.onClick.AddListener(SendText);
サーバからメッセージを受信したときに実行する処理「RecvText」を登録する
*ws.OnMessage += (sender, e) =>; RecvText(e.Data);
サーバとの接続が切れたときに実行する処理「RecvClose」を登録する
*ws.OnClose += (sender, e) =>; RecvClose();
ポート番号を指定
*ws = new WebSocketServer(12345);
クライアントからの通信時の挙動を定義したクラス、「ExWebSocketBehavior」を登録
*ws.AddWebSocketService<;ExWebSocketBehavior>;("/");
サーバ起動
*ws.Start();
誰が現在接続しているのか管理するリスト。
*public static List<;ExWebSocketBehavior>; clientList = new List<;ExWebSocketBehavior>;();
接続者に番号を振るための変数。
*static int globalSeq = 0;
自身の番号
*int seq;
*{//ログインしてきた人には、番号をつけて、リストに登録。globalSeq++;this.seq = globalSeq;clientList.Add(this);Debug.Log("Seq" + this.seq + " Login. (" + this.ID + ")");//接続者全員にメッセージを送るforeach (var client in clientList){client.Send("Seq:" + seq + " Login.");}}
誰かがログインしてきたときに呼ばれるメソッド
ログインしてきた人には、番号をつけて、リストに登録。
*globalSeq++;
*foreach (var client in clientList)*{
接続者全員にメッセージを送る
*{Debug.Log("Seq:" + seq + "..." + e.Data);//接続者全員にメッセージを送るforeach (var client in clientList){client.Send("Seq:" + seq + "..." + e.Data);}}
誰かがメッセージを送信してきたときに呼ばれるメソッド
*foreach (var client in clientList)*{
接続者全員にメッセージを送る
*{Debug.Log("Seq" + this.seq + " Logout. (" + this.ID + ")");//ログアウトした人を、リストから削除。clientList.Remove(this);//接続者全員にメッセージを送るforeach (var client in clientList){client.Send("Seq:" + seq + " Logout.");}}
誰かがログアウトしてきたときに呼ばれるメソッド
ログアウトした人を、リストから削除。
*clientList.Remove(this);
*foreach (var client in clientList)*{
接続者全員にメッセージを送る
*// foreach (var client in clientList)*// {
接続者全員にメッセージを送る
*// {//    client.Send("Seq:" + seq + "..." + e.Data);// }
foreach (var client in clientList)

記事:
"c\qiita\qiita.txt"
*Console.WriteLine(@"記事:
記事:
"c\qiita\qiita.txt"
*,,,
*Console.WriteLine($"記事:{{{pass}}}");
3
*var item = JsonConvert.DeserializeObject<;JObject>;($@"{{ ""url"":  ""{url}"" }}");
記事: {c\qiita\qiita.txt}

円(2D)
*GizmosUtility.DrawWireCircle(Vector3.zero, 2f);
正三角形(2D)
*GizmosUtility.DrawWireRegularPolygon(3, new Vector3(4f, 0f, 0f), 2f);
正四角形(2D)
*GizmosUtility.DrawWireRegularPolygon(4, new Vector3(8f, 0f, 0f), 2f);
正五角形(2D)
*GizmosUtility.DrawWireRegularPolygon(5, new Vector3(12f, 0f, 0f), 2f);
円(3D)
*GizmosUtility.DrawWireCircle(new Vector3(16f, 0f, 0f), Quaternion.LookRotation(new Vector3(-1f, 1f, 0f)), 2f);
正三角形(3D)
*GizmosUtility.DrawWireRegularPolygon(3, new Vector3(20f, 0f, 0f), Quaternion.LookRotation(new Vector3(-1f, 1f, 0f)), 2f);
正四角形(3D)
*GizmosUtility.DrawWireRegularPolygon(4, new Vector3(24f, 0f, 0f), Quaternion.LookRotation(new Vector3(-1f, 1f, 0f)), 2f);
正五角形(3D)
*GizmosUtility.DrawWireRegularPolygon(5, new Vector3(28f, 0f, 0f), Quaternion.LookRotation(new Vector3(-1f, 1f, 0f)), 2f);

*{// このフィルターを追加することで、すべてのページが原則認証されているないと表示できなくなる。// ログインページなどは認証されていなくても表示できるようにするため、ページモデルに//  [AllowAnonymous]が必要となるが、デフォルトで設定されている。var policy = new AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build();config.Filters.Add(new AuthorizeFilter(policy));}).SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
認証機能を追加する
このフィルターを追加することで、すべてのページが原則認証されているないと表示できなくなる。
ログインページなどは認証されていなくても表示できるようにするため、ページモデルに
[AllowAnonymous]が必要となるが、デフォルトで設定されている。
*var policy = new AuthorizationPolicyBuilder()
初期化時のロール
public static readonly string SystemManagerRole = "SystemManager";       システム管理権限
public static readonly string GroupManagerRole = "GroupManager";         グループ管理権限
初期化時のシステム管理ユーザーID
public static readonly string StstemManageEmail = "system@test.com";     最初のシステム管理ユーザーのメールアドレス
public static readonly string StstemManagePassword = "!initialPassword01";     最初のシステム管理ユーザーの初期パスワード
*public static async Task Initialize(IServiceProvider serviceProvider)
ユーザー管理を取得(using Microsoft.Extensions.DependencyInjectionがないとエラーになる)
*var userManager = serviceProvider.GetService<;UserManager<;IdentityUser>;>;();
初期のユーザーマネージャーが存在しなければロールの作成と初期システムユーザーを作成する
*var systemManager = await userManager.FindByNameAsync(StstemManageEmail);
ロール管理を取得
*var roleManager = serviceProvider.GetService<;RoleManager<;IdentityRole>;>;();
ロールの追加
await roleManager.CreateAsync(new IdentityRole(SystemManagerRole));     システム管理ロール
await roleManager.CreateAsync(new IdentityRole(GroupManagerRole));     グループ管理ロール
初期システム管理者の作成
なぜか知らないが、デフォルトのログイン画面はユーザーIDではなくメールアドレスを要求し、バリデーションもメールで設定されている。
ところが、ログイン処理自体は「Email」ではなく「UserName」で行われるので両方に設定せざるを得ない。
なんでこんなことのなっているのか？　変更するにはログイン画面を変えればいい
*systemManager = new IdentityUser { UserName = StstemManageEmail, Email = StstemManageEmail };
システム管理ユーザーにシステム管理ロールを追加
*systemManager = await userManager.FindByNameAsync(StstemManageEmail);
CreateWebHostBuilder(args).Build().Run();　&lt;= もともとこの１行だけのはず
上の１行のコードを以下のように変更
*var host = CreateWebHostBuilder(args).Build();
サービスプロバイダーの取得
*var services = scope.ServiceProvider;
データベースの自動マイグレーション
*var context = services.GetRequiredService<;ApplicationDbContext>;();
初期のユーザーとロールの作成
*UserRollInitialize.Initialize(services).Wait();

*var spriteHandle = Addressables.LoadAssetsAsync<;Sprite<; ("Sprites", null);
ラベルを指定して一括ロード
完了の待機
*yield return new WaitUntil (() =>; textHandle.IsDone &amp;&amp; imageHandle.IsDone &amp;&amp; spriteHandle.IsDone);
*if (textHandle.Status == UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationStatus.Succeeded*&amp;&amp; imageHandle.Status == UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationStatus.Succeeded
エラーがないことを確認
*var image = Instantiate (imageHandle.Result, transform).GetComponent<;Image>; ();*var text = Instantiate (textHandle.Result, transform).GetComponent;Text>; ();
プレファブからオブジェクトを生成
*for (var i = 0; i <; spriteHandle.Result.Count; i = (i + 1) % spriteHandle.Result.Count) {*image.sprite = spriteHandle.Result [i];
スプライトを順に切り替え

設定ファイルの内容をバインドする
*services.Configure<;AppSettings>;(configuration.GetSection("AppSettings"));
サービスのDI設定を行う
*services.AddTransient<;IHelloService, HelloService>;();

*{GetComponent<;LocalClock>;().localTimeScale = 0.01f;}
Start is called before the first frame update
*{}
Update is called once per frame
*{}
Start is called before the first frame update
*{if (Input.GetKeyDown(KeyCode.T)){if (GetComponent<;GlobalClock>;().localTimeScale == 0)GetComponent<;GlobalClock>;().localTimeScale = 1;elseGetComponent<;GlobalClock>;().localTimeScale = 0;}}
Update is called once per frame

*MyImage.Source = bitmapImage;
「MyImage」は、xamlの&lt;Image Name="MyImage"&gt;より。砂嵐を張り付けるImageの名前。

*var hex = Convert.ToInt32("1a", 16);
16進数
上から3, 9, 26になる
*,,,
123456789に変換される
*str = "123e4";

リトライ最大回数(引数で指定してもいいかも)
*int retryMax = 3;
戻り値を初期化しておく
*T result = default( T );
*if(successResult.Equals( result ))*{
処理に成功していれば抜ける
リトライ間隔を適当にあけておく
*Thread.Sleep( 500 );

ファイルオープン
*Application xlApp = new Application();
シートを選択
*Worksheet sheet = xlBook.Sheets["メンバー一覧"];
セルの領域を選択
*Range TableRange = sheet.Range["A1", "B15"];
選択した領域の値をメモリー上に格納
*object[,] values = TableRange.Value;
*for (int i = 1; i <;= values.GetLength(0); i++)*{
配列アクセスができるので、それぞれをDictionaryに追加
使用したCOMオブジェクトを解放
*System.Runtime.InteropServices.Marshal.ReleaseComObject(TableRange);
Excelのクローズ
*xlBook.Close();
使用したCOMオブジェクトを解放その２
*System.Runtime.InteropServices.Marshal.FinalReleaseComObject(xlBook);
ファイルオープン
*object xlApp = Activator.CreateInstance(Type.GetTypeFromProgID("Excel.Application"));
ファイルオープン
*dynamic xlApp = Activator.CreateInstance(Type.GetTypeFromProgID("Excel.Application"));
インターフェースの名前空間
*using ExtractExcelDataInterface;
Excelを操作するために必要なクラスの名前空間を追加
*using Microsoft.Office.Interop.Excel;
returnするDicionaryインスタンス
*Dictionary<;string, string>; dic = new Dictionary<;string, string>;();
ファイルオープン
*Application xlApp = new Application();
シートを選択
*Worksheet sheet = xlBook.Sheets["メンバー一覧"];
セルの領域を選択
*Range TableRange = sheet.Range["A1", "B15"];
選択した領域の値をメモリー上に格納
（１セルずつ見ていくよりも早い）
*object[,] values = TableRange.Value;
配列アクセスができるので、それぞれをDictionaryに追加
[WARNING] 配列の開始インデックスは１から
*for (int i = 1; i <;= values.GetLength(0); i++)
使用したCOMオブジェクトを解放
*System.Runtime.InteropServices.Marshal.ReleaseComObject(TableRange);
Excelのクローズ
*xlBook.Close();
使用したCOMオブジェクトを解放その２
*System.Runtime.InteropServices.Marshal.FinalReleaseComObject(xlBook);
*object sheet = xlBook.GetType().InvokeMember("Sheets", System.Reflection.BindingFlags.GetProperty, null, xlBook, new object[] { "メンバー一覧" });
シートを選択
*object TableRange = sheet.GetType().InvokeMember("Range", System.Reflection.BindingFlags.GetProperty, null, sheet, new object[] { "A1", "B15" });
セルの領域を選択
選択した領域の値をメモリー上に格納
（１セルずつ見ていくよりも早い）
*object[,] values = TableRange.GetType().InvokeMember("Value", System.Reflection.BindingFlags.GetProperty, null, TableRange, null) as object[,];
配列アクセスができるので、それぞれをDictionaryに追加
[WARNING] 配列の開始インデックスは１から
*for (int i = 1; i <;= values.GetLength(0); i++)
使用したCOMオブジェクトを解放
*System.Runtime.InteropServices.Marshal.ReleaseComObject(TableRange);
Excelのクローズ
*xlBook.GetType().InvokeMember("Close", System.Reflection.BindingFlags.InvokeMethod, null, xlBook, null);
使用したCOMオブジェクトを解放その２
*System.Runtime.InteropServices.Marshal.FinalReleaseComObject(xlBook);
ファイルオープン
*dynamic xlApp = Activator.CreateInstance(Type.GetTypeFromProgID("Excel.Application"));
シートを選択
*dynamic sheet = xlBook.Sheets["メンバー一覧"];
セルの領域を選択
*dynamic TableRange = sheet.Range["A1", "B15"];
選択した領域の値をメモリー上に格納
（１セルずつ見ていくよりも早い）
*object[,] values = TableRange.Value;
配列アクセスができるので、それぞれをDictionaryに追加
[WARNING] 配列の開始インデックスは１から
*for (int i = 1; i <;= values.GetLength(0); i++)
使用したCOMオブジェクトを解放
*System.Runtime.InteropServices.Marshal.ReleaseComObject(TableRange);
Excelのクローズ
*xlBook.Close();
使用したCOMオブジェクトを解放その２
*System.Runtime.InteropServices.Marshal.FinalReleaseComObject(xlBook);

*//Debug.Log($"name {timelineClip.name} {timelineClip.GetType()}");
タイムラインのそれぞれのタイプを取得
*if (type.Name == "AnimationTrack")*{
アニメーショントラックか判定
TrackAssetをAnimationTrackで取得
*var animationTrack = timelineClip as AnimationTrack;
*//Debug.Log($"binding: {binding?.name}");
playableDirectorから各トラックを取得する
*if (GameObjectNameInclude(binding, _skinnedMeshRenderer, ref isParent))*{
トラックに設定されている、オブジェクトと比較する
*if (binding.name == _skinnedMeshRenderer.name)*{
トラックに設定されている、オブジェクトと比較する
アニーしょんタックに設定されているアニメーションクリップを取得
*var animationClip = animationTrack.infiniteClip;
アニメーションがすげにある場合
新たにアニメーションを上書きすると情報がおかしくなるので
少々違った方法で
*if (animationClip)
アニメーショントラックからアニメーションカーブを取得する
*var animationCurveList = AnimationUtility.GetAllCurves(animationClip).Where(_ =>; _.propertyName == _propertyName).ToList();
*if (isParent)*{
親がいるならパスに書いてあげないといけない
*if (animationCurve!=null)*{
セットするカーブ
アニメーションクリップを再セットする
*AnimationUtility.SetEditorCurve(animationClip, curveBinding, animationCurve!=null?  animationCurve.curve : curve);
再描画を依頼する
*Repaint();
アニメーションクリップをセットする
*animationClip.SetCurve(isParent == false ? "" : _skinnedMeshRenderer.name, typeof(SkinnedMeshRenderer), _propertyName, curve);
再描画を依頼する
*Repaint();

*var template = config.logFormat;
まぁ、こんな感じで↑の&lt;logFormat&gt;~&lt;logFormat&gt;が取れるとしよう。

*return RedirectToAction(nameof(Index2));
Getで定義されたActionがないのでエラー

HMDがトラッキングされるまで待つ
*await UniTask.WaitUntil(() =>;ovrTracker.isPositionTracked);

*else {
unknown type

*for(int i = 0; i <; Paneles.Count; i++)
確認用の表記

*var assembly = Assembly.LoadFrom(asmPath);
"C:\Windows\Microsoft.Net\assembly\GAC_MSIL\System\v4.0_4.0.0.0__b77a5c561934e089\System.dll");(assemblyName);

---------- 以下が追加した処理 ----------
*ServiceEventLog = new System.Diagnostics.EventLog();

*{{Excel.Application app = new Excel.Application();{Excel.Workbooks books = app.Workbooks;Excel.Workbook book = books.Open(@"test.xlsx");Excel.Sheets sheets = book.Sheets;Excel.Worksheet sheet = sheets["Sheet1"];Excel.Range cells = sheet.Cells;Excel.Range cell = cells[1, 1];Console.WriteLine(cell.Value);book.Close(Type.Missing, Type.Missing, Type.Missing);Marshal.ReleaseComObject(cell);Marshal.ReleaseComObject(cells);Marshal.ReleaseComObject(sheet);Marshal.ReleaseComObject(sheets);Marshal.ReleaseComObject(book);Marshal.ReleaseComObject(books);}GC.Collect();GC.WaitForPendingFinalizers();GC.Collect();app.Quit();Marshal.ReleaseComObject(app);}// Application オブジェクトのガベージ コレクトを強制します。GC.Collect();GC.WaitForPendingFinalizers();GC.Collect();}
略
Application オブジェクトのガベージ コレクトを強制します。
*GC.Collect();
Application オブジェクトのガベージ コレクトを強制します。
*GC.Collect();
*{// Start of the journey - get address of the first objetc on our reference chainvar currentObject = stack.Peek();// Have we checked this object before?if (!touchedObjects.Add(currentObject)){return false;}// Did we find our object? Then we have the path!if (currentObject == objectPointer){return true;}// Enumerate internal references of the objectvar found = false;var type = heap.GetObjectType(currentObject);if (type != null){type.EnumerateRefsOfObject(currentObject, (innerObject, fieldOffset) =>;{if (innerObject == 0 || touchedObjects.Contains(innerObject)){return;}// Push the object onto our stackstack.Push(innerObject);if (GetPathToObject(heap, objectPointer, stack, touchedObjects)){found = true;return;}// If not found, pop the object from our stack as this is not the tree we're looking forstack.Pop();});}return found;}
https:blog.maartenballiauw.be/post/2017/01/03/exploring-.net-managed-heap-with-clrmd.html
*if (!touchedObjects.Add(currentObject))*{
Have we checked this object before?
*if (currentObject == objectPointer)*{
Did we find our object? Then we have the path!
*{Excel.Application app = new Excel.Application();app.Quit();Console.WriteLine("ここでヒープのチェックを行う");Console.ReadLine();}
using Excel = Microsoft.Office.Interop.Excel;
*{Excel.Application app = new Excel.Application();app.Quit();Marshal.ReleaseComObject(app);Console.WriteLine("ここでヒープのチェックを行う");Console.ReadLine();}
using Excel = Microsoft.Office.Interop.Excel;
*{Excel.Application app = new Excel.Application();app.Quit();app = null;GC.Collect();GC.WaitForPendingFinalizers();GC.Collect();Console.WriteLine("ここでヒープのチェックを行う t1_3");Console.ReadLine();}
using Excel = Microsoft.Office.Interop.Excel;
*{Excel.Application app = new Excel.Application();// Workbooksの暗黙のオブジェクトの作成Excel.Workbook book = app.Workbooks.Open(@"test.xlsx");Console.WriteLine("ここでヒープのチェックを行う1");Console.ReadLine();book.Close();Marshal.ReleaseComObject(book);app.Quit();Marshal.ReleaseComObject(app);Console.WriteLine("ここでヒープのチェックを行う2");Console.ReadLine();}
using Excel = Microsoft.Office.Interop.Excel;
Workbooksの暗黙のオブジェクトの作成
*Excel.Workbook book = app.Workbooks.Open(@"test.xlsx");
*{Excel.Application app = new Excel.Application();Excel.Workbooks books = app.Workbooks;Excel.Workbook book = books.Open(@"test.xlsx");var book2 = book;Console.WriteLine(book.Name);Console.WriteLine(book2.Name);Console.WriteLine("ここでヒープのチェックを行う1 t_1");Console.ReadLine();book.Close();Marshal.ReleaseComObject(book);Marshal.ReleaseComObject(books);app.Quit();Marshal.ReleaseComObject(app);Console.WriteLine("ここでヒープのチェックを行う2");Console.ReadLine();}
using Excel = Microsoft.Office.Interop.Excel;

*return string.Compare(s1, s2, true);
第3引数の true は、大文字小文字の差異を無視する指定(ignore case)

*{var toolbar = new Toolbar();root.Add(toolbar);var btn1 = new ToolbarButton { text = "Button" };toolbar.Add(btn1);var spc = new ToolbarSpacer();toolbar.Add(spc);var tgl = new ToolbarToggle { text = "Toggle" };toolbar.Add(tgl);var spc2 = new ToolbarSpacer() { name = "flexSpacer1", flex = true };toolbar.Add(spc2);var menu = new ToolbarMenu { text = "Menu" };menu.menu.AppendAction("Default is never shown", a =>; { }, a =>; DropdownMenuAction.Status.None);menu.menu.AppendAction("Normal menu", a =>; { }, a =>; DropdownMenuAction.Status.Normal);menu.menu.AppendAction("Hidden is never shown", a =>; { }, a =>; DropdownMenuAction.Status.Hidden);menu.menu.AppendAction("Checked menu", a =>; { }, a =>; DropdownMenuAction.Status.Checked);menu.menu.AppendAction("Disabled menu", a =>; { }, a =>; DropdownMenuAction.Status.Disabled);menu.menu.AppendAction("Disabled and checked menu", a =>; { }, a =>; DropdownMenuAction.Status.Disabled | DropdownMenuAction.Status.Checked);toolbar.Add(menu);var spc3 = new ToolbarSpacer() { name = "flexSpacer2", flex = true };toolbar.Add(spc3);var popup = new ToolbarMenu { text = "Popup", variant = ToolbarMenu.Variant.Popup };popup.menu.AppendAction("Popup", a =>; { }, a =>; DropdownMenuAction.Status.Normal);toolbar.Add(popup);}
Create Toolbar
*{var visualTree = AssetDatabase.LoadAssetAtPath<;VisualTreeAsset>;("Assets/Editor/Sample2.uxml");// var styleSheet = AssetDatabase.LoadAssetAtPath<;StyleSheet>;("Assets/Editor/Sample2.uss");VisualElement labelFromUXML = visualTree.CloneTree();// labelFromUXML.styleSheets.Add(styleSheet);root.Add(labelFromUXML);}
Import UXML

StringCollectionの初期の編集画面では追加ができない。
これを実行することで編集画面が変わり、追加できるようになる。
*TypeDescriptor.AddAttributes(typeof(System.Collections.Specialized.StringCollection),
設定のコピーを作成する
*copiedSettings = new Settings();
StringCollection型のために必要
*copiedSettings[property.Name] = deepCopy(Settings.Default[property.Name]);
コピーしたオブジェクトを表示させる
*propertyGrid1.SelectedObject = copiedSettings;
StringCollection型のために必要
*Settings.Default[property.Name] = deepCopy(copiedSettings[property.Name]);
*{{ nameof(Settings.BoolSetting),             new CategoryAttribute("組み込みのデータ型") },{ nameof(Settings.StringSetting),           new CategoryAttribute("組み込みのデータ型") },{ nameof(Settings.StringCollectionSetting), new CategoryAttribute("複合データ型") },{ nameof(Settings.DateTimeSetting),         new CategoryAttribute("複合データ型") },{ nameof(Settings.IntSetting),              new CategoryAttribute("組み込みのデータ型") },};
PropertyGridのCategoryを設定する
*{{ nameof(Settings.BoolSetting),             new DescriptionAttribute("bool型の設定") },{ nameof(Settings.StringSetting),           new DescriptionAttribute("string型の設定") },{ nameof(Settings.StringCollectionSetting), new DescriptionAttribute("複数のstring型の設定") },{ nameof(Settings.DateTimeSetting),         new DescriptionAttribute("DateTime型の設定") },{ nameof(Settings.IntSetting),              new DescriptionAttribute("int型の設定") },};
PropertyGridのHelpテキストを設定する
属性を追加する。
本当はMemberDescriptor.Attributes.Addのようにしたいのだが、Attributes属性はgetだけ定義されている。
そのためリフレクションを使って属性を追加する
*var fi = p.Attributes.GetType().GetField("_attributes", BindingFlags.NonPublic | BindingFlags.Instance);
これを追加しないと、StringCollectionの追加ができない
*TypeDescriptor.AddAttributes(typeof(System.Collections.Specialized.StringCollection),
ファイルを選択
*string fullPath;
*{// user.configのパスを取得string userConfigPath = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.PerUserRoamingAndLocal).FilePath;// ファイルが無ければSave()して生成するif (!File.Exists(userConfigPath)){Settings.Default.Save();}// エクスポートはファイルをコピーするだけFile.Copy(userConfigPath, fullPath, true);MessageBox.Show("エクスポートしました");}
ファイルをコピー
user.configのパスを取得
*string userConfigPath = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.PerUserRoamingAndLocal).FilePath;
*if (!File.Exists(userConfigPath))*{
ファイルが無ければSave()して生成する
エクスポートはファイルをコピーするだけ
*File.Copy(userConfigPath, fullPath, true);
ExeConfigFilenameにインポートするファイルだけ指定しても、そのファイルにはセクション情報が書かれていないためGetSectionで正しく読めない。
さらに、ExeConfigFilenameにアプリケーション設定、RoamingUserConfigFilenameにインポートするファイルを指定しても、正しく動かない場合がある。
例えばインポートするファイルに吐かれていない新規設定がある場合、本来は現在値を保持してほしいが、デフォルト値で上書きしてしまう。
ということで、ExeConfigFilename/RoamingUserConfigFilenam/LocalUserConfigFilenameの3つを指定して読み込む。
*var tmpAppConfig  = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
Key:プロパティ名、Value:読み込んだファイルの該当プロパティのSettingElement、のDictionaryを作成する
*var dict = new Dictionary<;string, SettingElement>;();
*foreach (SettingsPropertyValue value in copiedSettings.PropertyValues)*{
現在の設定を更新する
SerializedValueを1度も参照していないと、参照したときの元の値に戻ってしまうという仕様になっている。
https:referencesource.microsoft.com/#System/sys/system/configuration/SettingsPropertyValue.cs,69
その対策として、リフレクションで無理やり内部のメンバをfalseに変更する。
リフレクションを使わなくても、var dummy = value.SerializedValueを実行して1度参照する方法でもよい。
*var _ChangedSinceLastSerialized = typeof(SettingsPropertyValue).GetField("_ChangedSinceLastSerialized", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Instance);
値の設定
*value.SerializedValue = element.Value.ValueXml.InnerXml;
value.Deserializedをfalseにすると、value.PropertyValueにアクセスしたときにDeserializeされる
*value.Deserialized = false;
ファイル選択
*string fullPath = "";
読み込み
*ClientSettingsSection section = null;
ExeConfigFilenameにインポートするファイルだけ指定しても、そのファイルにはセクション情報が書かれていないためGetSectionで正しく読めない。
さらに、ExeConfigFilenameにアプリケーション設定、RoamingUserConfigFilenameにインポートするファイルを指定しても、正しく動かない場合がある。
例えばインポートするファイルに吐かれていない新規設定がある場合、本来は現在値を保持してほしいが、デフォルト値で上書きしてしまう。
ということで、ExeConfigFilename/RoamingUserConfigFilenam/LocalUserConfigFilenameの3つを指定して読み込む。
*var tmpAppConfig  = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
*{// Key:プロパティ名、Value:読み込んだファイルの該当プロパティのSettingElement、のDictionaryを作成するvar dict = new Dictionary<;string, SettingElement>;();foreach (SettingElement v in section.Settings){dict.Add(v.Name, v);}// 現在の設定を更新するforeach (SettingsPropertyValue value in copiedSettings.PropertyValues){SettingElement element;if (dict.TryGetValue(value.Name, out element)){// SerializedValueを1度も参照していないと、参照したときの元の値に戻ってしまうという仕様になっている。// https://referencesource.microsoft.com/#System/sys/system/configuration/SettingsPropertyValue.cs,69// その対策として、リフレクションで無理やり内部のメンバをfalseに変更する。// リフレクションを使わなくても、var dummy = value.SerializedValueを実行して1度参照する方法でもよい。var _ChangedSinceLastSerialized = typeof(SettingsPropertyValue).GetField("_ChangedSinceLastSerialized", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Instance);_ChangedSinceLastSerialized.SetValue(value, false);// 値の設定value.SerializedValue = element.Value.ValueXml.InnerXml;// value.Deserializedをfalseにすると、value.PropertyValueにアクセスしたときにDeserializeされる.// https://referencesource.microsoft.com/#System/sys/system/configuration/SettingsPropertyValue.cs,40value.Deserialized = false;}}}
データの更新
Key:プロパティ名、Value:読み込んだファイルの該当プロパティのSettingElement、のDictionaryを作成する
*var dict = new Dictionary<;string, SettingElement>;();
*foreach (SettingsPropertyValue value in copiedSettings.PropertyValues)*{
現在の設定を更新する
SerializedValueを1度も参照していないと、参照したときの元の値に戻ってしまうという仕様になっている。
https:referencesource.microsoft.com/#System/sys/system/configuration/SettingsPropertyValue.cs,69
その対策として、リフレクションで無理やり内部のメンバをfalseに変更する。
リフレクションを使わなくても、var dummy = value.SerializedValueを実行して1度参照する方法でもよい。
*var _ChangedSinceLastSerialized = typeof(SettingsPropertyValue).GetField("_ChangedSinceLastSerialized", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Instance);
値の設定
*value.SerializedValue = element.Value.ValueXml.InnerXml;
value.Deserializedをfalseにすると、value.PropertyValueにアクセスしたときにDeserializeされる.
https:referencesource.microsoft.com/#System/sys/system/configuration/SettingsPropertyValue.cs,40
*value.Deserialized = false;
画面を更新
*propertyGrid1.SelectedObject = copiedSettings;
メッセージ
*MessageBox.Show("インポートした設定を反映するには保存を押してください");

*{// 引数には this + 拡張対象の型 + 変数名 を定義する。public static int ToInt32(this string value) =>; Convert.ToInt32(value);}
静的クラス・静的メソッドで定義することに注意。
引数には this + 拡張対象の型 + 変数名 を定義する。
*public static int ToInt32(this string value) =>; Convert.ToInt32(value);
ex) 文字列型"123"が入力されると、数値型123が返ってくる。
*public int ToInt(string value) =>; value.ToInt32();
ex) 列挙体の要素 Engine.MySQL が入力されると、対応する数値 1 が返ってくる。
*public int ToInt(Engine engine) =>; engine.ToIndex();
ex) 数値 1 が入力されると、列挙体の要素 Engine.MySQL が返ってくる。
*public static Engine ToEngine(this int index) =>; (Engine)Enum.ToObject(typeof(Engine), index);
ex) 文字列 "MySQL" が入力されると、列挙体の要素 Engine.MySQL が返ってくる。
*public static Engine ToEngine(this string value) =>; (Engine)Enum.Parse(typeof(Engine), value, true);

*{}
Start is called before the first frame update
*{AdjustShutter(1280, 720);}
Update is called once per frame

*if ( !(y <;= -20.0 &amp;&amp; y <;= 20.0) ) {
!でとることで0除算での不定値をはじく

*else
消えかけると激しく点滅

すべてのI2Cデバイスを取得するためのセレクタ文字列を取得
*string aqs = I2cDevice.GetDeviceSelector("I2C1");
*var dis = await DeviceInformation.FindAllAsync(aqs);*if (dis.Count == 0)
セレクタ文字列を使ってI2Cコントローラデバイスを取得
I2Cアドレスを指定して、デフォルトのI2C設定を作成する
private const byte ACCEL_I2C_ADDR = 0x68;
*var settings = new I2cConnectionSettings(ACCEL_I2C_ADDR);
バス速度を設定(FastMode：400 kHz)(指定しないと、標準設定(StandardMode：100kHz)になる)
*settings.BusSpeed = I2cBusSpeed.FastMode;
取得したI2Cデバイスと作成した設定で、I2cDeviceのインスタンスを作成
*I2CAccel = await I2cDevice.FromIdAsync(dis[0].Id, settings);
*{// 送信用バッファbyte[] WriteBuf;// 受信用バッファbyte[] ReadBuf;// アドレス取得(イニシャルに必須ではない。どこのサンプルにも書いてるので一応やっとく)WriteBuf = new byte[] { 0x75 };ReadBuf = new byte[1];I2CAccel.WriteRead(WriteBuf, ReadBuf);// センシング開始要求(レジスタ0x6Bに00を書き込み)WriteBuf = new byte[] { 0x6B, 0x00 };I2CAccel.Write(WriteBuf);// センシング開始要求(レジスタ0x37に02を書き込み)WriteBuf = new byte[] { 0x37, 0x02 };I2CAccel.Write(WriteBuf);}
ジャイロセンサ(MPU-9150)の設定を行うための通信
送信用バッファ
*byte[] WriteBuf;
受信用バッファ
*byte[] ReadBuf;
*WriteBuf = new byte[] { 0x75 };
アドレス取得(イニシャルに必須ではない。どこのサンプルにも書いてるので一応やっとく)
*WriteBuf = new byte[] { 0x6B, 0x00 };
センシング開始要求(レジスタ0x6Bに00を書き込み)
*WriteBuf = new byte[] { 0x37, 0x02 };
センシング開始要求(レジスタ0x37に02を書き込み)
初期化完了。100msごとにデータを採るためのコールバックを作成する
*periodicTimer = new Timer(this.TimerCallback, null, 0, 100);
送信用バッファ
*byte[] WriteBuf;
受信用バッファ
*byte[] ReadBuf;
*WriteBuf = new byte[] { 0x3B };
アドレス取得

手のローカル座標を用いた、ターゲットへの相対位置
*private Vector3 _relavivePosition;
virtualParentのローカル座標を用いた、virtualParent.rotation -&gt; virtualChild.rotationへの回転軸
*private Vector3 _parentLocalAxis;
*public Transform VirtualParent { get; private set; } = null;
virtualParent.rotation -&gt; virtualChild.rotationへの回転量
*_relavivePosition = VirtualParent.InverseTransformPoint(VirtualChild.position);*// 登録直後の状態のVirtualParentのrotationをVirtualChildのrotationに一致させるための回転行列を求める。
VirtualParentのローカル座標系で表した場合のターゲットオブジェクトの位置
登録直後の状態のVirtualParentのrotationをVirtualChildのrotationに一致させるための回転行列を求める。
求めたい回転行列をAとし, VirtualChild, VirtualParentのrotationをC,Pとすると、C = A * Pであり、
両辺からPの逆行列（Inverse(P)）をかけると A = C * Inverse(P)
*var rotationMatrix = VirtualChild.rotation * Quaternion.Inverse(VirtualParent.rotation);
rotationMatrixはグローバル座標を使って表現されているため、virtualParentが少しでも回転した後は使えないが、
Quaternionから回転量（angle）と回転軸（axis）を抽出すると、angleはそのまま使える
*rotationMatrix.ToAngleAxis(out _rotationAngle, out Vector3 grobalAxis);
axisはVirtualParentのローカル座標で表現しておき、
使うタイミングでVirtualParentのrotationをもとにグローバル座標へ変換し直す
*_parentLocalAxis = VirtualParent.InverseTransformVector(grobalAxis);
*var position = VirtualParent.TransformPoint(_relavivePosition);*var grobalAxis = VirtualParent.TransformVector(_parentLocalAxis);
ローカル座標 -&gt; グローバル座標へ変換
(回転行列) * 親のrotation
*var rotation = Quaternion.AngleAxis(_rotationAngle, grobalAxis) * VirtualParent.rotation;

*catch ( Microsoft.JScript.JScriptException e ) {
コンパイルにするには Microsoft.Vsa.dll を参照に追加する必要がある

*options.UseNpgsql(
&lt;= この部分を変更

*ie.Navigate("https:
www.google.com");
*if ( t["q"] == null ) {*Console.WriteLine("cannot find target element.");
Dump(t);

*string url = "https:
stocks.finance.yahoo.co.jpstockshistory?code=998407.O";

*embed.AddField("Googleリンク", "[こちら](https:
www.google.com) をクリック。");
作成したEmbedをbotに送信させる。
*await message.Channel.SendMessageAsync("テスト", embed: embed.Build());

*Quaternion deltaRotation = Quaternion.Inverse(_rotationPrevious) * transform.rotation;*// 角度と回転軸に変換
回転変化量を計算
角度と回転軸に変換
*deltaRotation.ToAngleAxis(out float angle, out Vector3 axis);
角速度 [rad/s] を算出
*float angularSpeed = (angle * Mathf.Deg2Rad) / Time.deltaTime;
*_rotationPrevious = transform.rotation;*}
今回値を覚えておく
*_estimatedAngularVelocity = transform.rotation.eulerAngles - _rotationPrevious.eulerAngles;*_estimatedAngularVelocity = (_estimatedAngularVelocity * Mathf.Deg2Rad) / Time.deltaTime;
回転変化量を計算
*_rotationPrevious = transform.rotation;*,,,
今回値を覚えておく

*bw.Write(bMessage);
文字列のbyte配列

パイプライン作成のための文字列.
*public string PipelineSource;
*private Element _pipeline { get; set; }
文字列から生成したパイプライン格納変数.
コントロールのハンドル.
*private IntPtr _handle;
*{if( _pipeline == null )return;_pipeline.Bus.SyncMessage -= Bus_SyncMessage;_pipeline.Bus.Message -= Bus_Message;_pipeline.SetState( State.Null );_pipeline.Dispose();_pipeline = null;};
開放処理を追加しておく.
*{if( string.IsNullOrEmpty( PipelineSource ) )return;if( InitGstreamerPipeline() )HandleRealized();}
実行.
*{if( _pipeline != null )_pipeline.SetState( State.Null );// パイプライン生成_pipeline = Parse.Launch( PipelineSource );if( _pipeline == null )return false;_pipeline.Bus.EnableSyncMessageEmission();_pipeline.Bus.AddSignalWatch();_pipeline.Bus.SyncMessage += Bus_SyncMessage;_pipeline.Bus.Message += Bus_Message;_pipeline.SetState( State.Playing );return true;}
パイプライン作成.
パイプライン生成
*_pipeline = Parse.Launch( PipelineSource );
エラー処理.
*break;
ストリーム終了.
*break;
再生開始.
*break;
*{_handle = this.Handle();Element overlay = ( ( Gst.Bin ) _pipeline ).GetByInterface( VideoOerlayAdapter.GType );var adapter = new VideoOverlayAdapter( overlay.Handle );adapter.WindowHandle = _handle;adapter.HandleEvent( true );}
コントロールに映像を埋め込むためハンドルを渡す.
*{if( _pipeline == null )return;_pipeline.Bus.SyncMessage -= Bus_SyncMessage;_pipeline.Bus.Message -= Bus_Message;_pipeline.SetState( State.Null );_pipeline.Dispose();_pipeline = null;}
停止.
Gstreamerのパイプライン生成文字列を入れる.
*videoPanel.PipelieSource = "/*再生したい内容*/";

*{var currentAnimatorState = _animator.GetCurrentAnimatorStateInfo(0);yield return new WaitWhile(() =>; currentAnimatorState.IsName("Idle"));Debug.Log("Do Something.");}
NG
*{yield return new WaitWhile(() =>; _animator.GetCurrentAnimatorStateInfo(0).IsName("Idle"));Debug.Log("Do Something.");}
OK

*if (Input.GetKeyDown(KeyCode.T) &amp;&amp; debug)*{
デバッグキー

*#if !UNITY_EDITOR*using Windows.Networking.Sockets;
&lt;JEM&gt;Ignore unity editor and run this code in the hololens instead&lt;/JEM&gt;
*public class ImageReceiver : MonoBehaviour {RawImage rend;bool socketClosed = false;bool writeStringToFile = false;bool loadTexture = false;bool logSize = false;public uint BUFFER_SIZE = 8192;public uint PORT = 8080;private readonly int DELAYMILLISEC = 10;public string textAll = "";string error_message;string error_source;string FILENAME = "received.png"#if !UNITY_EDITORStreamSocketListener listener;#endif// Use this for initializationvoid Start() {#if !UNITY_EDITORrend = this.GetComponent<;RawImage>;();listener = new StreamSocketListener();listener.ConnectionReceived += _receiver_socket_ConnectionReceived;listener.Control.KeepAlive = true;Listener_Start();#endif}#if !UNITY_EDITORprivate async void Listener_Start(){try{await listener.BindServiceNameAsync(PORT.ToString());Debug.Log("Listener started");Debug.Log(NetworkUtils.GetMyIPAddress() + " : " + PORT.ToString());} catch (Exception e){Debug.Log("Error: " + e.Message);}}private async void _receiver_socket_ConnectionReceived(StreamSocketListener sender, StreamSocketListenerConnectionReceivedEventArgs args){try{if (loadTexture != true) {string folderPath = System.IO.Directory.GetCurrentDirectory();// Create sample file; replace if exists.// Must be set as TemporaryFolder to read files from HoloLens.Windows.Storage.StorageFolder storageFolder = Windows.Storage.ApplicationData.Current.TemporaryFolder;using (var dr = new DataReader(args.Socket.InputStream)) {using (IInputStream input = args.Socket.InputStream) {using (var imageFile = new FileStream(storageFolder.Path + @"\" + FILENAME, FileMode.Create)) {using (FromBase64Transform myTransform = new FromBase64Transform(FromBase64TransformMode.IgnoreWhiteSpaces)) {byte[] data = new byte[BUFFER_SIZE];IBuffer buffer = data.AsBuffer();uint dataRead = BUFFER_SIZE;byte[] dataTransformed = new byte[BUFFER_SIZE];while (dataRead == BUFFER_SIZE) {await input.ReadAsync(buffer, BUFFER_SIZE, InputStreamOptions.Partial);int bytesWritten = myTransform.TransformBlock(data, 0,(int)BUFFER_SIZE, dataTransformed, 0);await Task.Delay(DELAYMILLISEC);imageFile.Write(dataTransformed, 0, bytesWritten);dataRead = buffer.Length;}dataTransformed = myTransform.TransformFinalBlock(data, 0, data.Length - (int)dataRead);imageFile.Write(dataTransformed, 0, dataTransformed.Length);myTransform.Clear();}imageFile.Flush();}}}loadTexture = true;}}catch (Exception e){error_source = e.Source;error_message = e.Message;socketClosed = true;}finally {if (loadTexture == true) {using (var dw = new DataWriter(args.Socket.OutputStream)) {dw.WriteString("OK");await dw.StoreAsync();dw.DetachStream();}} else {using (var dw = new DataWriter(args.Socket.OutputStream)) {dw.WriteString("NG");await dw.StoreAsync();dw.DetachStream();}}}}void Update() {if (logSize) {Debug.Log("SIZE IS : " + BUFFER_SIZE.ToString());logSize = false;}if (socketClosed) {Debug.Log(error_source);Debug.Log(error_message);Debug.Log("OOPS SOCKET CLOSED ");socketClosed = false;Debug.Log(textAll);}if (writeStringToFile) {Debug.Log("WRITTEN TO FILE");writeStringToFile = false;}if (loadTexture) {Debug.Log("LOADING IMAGE CURRENTLY");// Must be set as TemporaryFolder to read files from HoloLens.Windows.Storage.StorageFolder storageFolder = Windows.Storage.ApplicationData.Current.TemporaryFolder;string imgpath = storageFolder.Path + @"\" + FILENAME;Destroy(this.rend.texture);this.rend.texture = ReadPngAsTexture(imgpath);this.rend.SetNativeSize();Debug.Log("LOADED IMAGE");Debug.Log(textAll);loadTexture = false;}}#endifprivate static byte[] ReadPngFile(string path) {byte[] values;using (FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read)) {using (BinaryReader bin = new BinaryReader(fileStream)) {values = bin.ReadBytes((int)bin.BaseStream.Length);}}return values;}private static Texture2D ReadPngAsTexture(string path) {byte[] readBinary = ReadPngFile(path);Texture2D texture = new Texture2D(1, 1);texture.LoadImage(readBinary);return texture;}}
Able to act as a reciever
*void Start() {#if !UNITY_EDITORrend = this.GetComponent<;RawImage>;();listener = new StreamSocketListener();listener.ConnectionReceived += _receiver_socket_ConnectionReceived;listener.Control.KeepAlive = true;Listener_Start();#endif}
Use this for initialization
*using (var dr = new DataReader(args.Socket.InputStream)) {using (IInputStream input = args.Socket.InputStream) {using (var imageFile = new FileStream(storageFolder.Path + @"\" + FILENAME, FileMode.Create)) {using (FromBase64Transform myTransform = new FromBase64Transform(FromBase64TransformMode.IgnoreWhiteSpaces)) {byte[] data = new byte[BUFFER_SIZE];IBuffer buffer = data.AsBuffer();uint dataRead = BUFFER_SIZE;byte[] dataTransformed = new byte[BUFFER_SIZE];while (dataRead == BUFFER_SIZE) {await input.ReadAsync(buffer, BUFFER_SIZE, InputStreamOptions.Partial);int bytesWritten = myTransform.TransformBlock(data, 0,(int)BUFFER_SIZE, dataTransformed, 0);await Task.Delay(DELAYMILLISEC);imageFile.Write(dataTransformed, 0, bytesWritten);dataRead = buffer.Length;}dataTransformed = myTransform.TransformFinalBlock(data, 0, data.Length - (int)dataRead);imageFile.Write(dataTransformed, 0, dataTransformed.Length);myTransform.Clear();}imageFile.Flush();}}}
Must be set as TemporaryFolder to read files from HoloLens.

*return true;
すべてのウィンドウを列挙する

*[Range(0, 1)] public float HSV_Hue_min = 0.0f;
0 ~ 1
*{material =  GetComponent<;Renderer>;().material;HSV_Hue = HSV_Hue_min;StartCoroutine("Change_Color");}
Start is called before the first frame update

*yield return new WaitUntil (() =<; Purchaser.Valid || Purchaser.Unavailable);
初期化完了を待つ

*string url = @"http:
d01tsumath.hatenablog.comrss";
RSS読み込み
*XElement element = XElement.Load(url);
channelの取得
*XElement channelElement = element.Element("channel");
itemの取得
*IEnumerable<;XElement>; elementItems = channelElement.Elements("item");

*listener.Prefixes.Add(@"http:
+:8080");
リスナー開始
*listener.Start();
リクエスト取得
*HttpListenerContext context = listener.GetContext();
レスポンス取得
*HttpListenerResponse response = context.Response;
*if (request != null)*{
HTMLを表示する

*OpenWebCommand = new Command(() =<; Device.OpenUri(new Uri("https:
xamarin.complatform")));
*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer
*{// 自身にバインドされているViewModelを取得する。var viewModel = BindingContext as AboutViewModel;// AppNameを書き換える。viewModel.AppName = "ザマリンサンプルアプリケーション";}
☆ ボタンクリックイベントのハンドラ
自身にバインドされているViewModelを取得する。
*var viewModel = BindingContext as AboutViewModel;
AppNameを書き換える。
*viewModel.AppName = "ザマリンサンプルアプリケーション";

*gameObject.AddComponent<;ResetTest<;().Reset();
Reset()はpublicで定義

UWPアプリ
*var localDir = Windows.Storage.ApplicationData.Current.LocalFolder;
UWPアプリでない
*Debug.WriteLine(ex.Message);

*public SavedData SetData(int selected_id)
メソッド名　引数には主要キー、返り値にはクラス名
コネクションからコマンドへ-SqlConnectionに関連付けられているSqlCommandオブジェクトを作成
*cmd.Parameters.Add(new SqlParameter("@selected_id", selected_id));
クラスプロパティ'ID'のデータ型がintの場合は、このように変換
*setdata.ID = demoid.ToString();
メソッドが呼び出されたインスタンス自身を返す
*return setdata;

*public TEnum this [TObj o] { get { return (TEnum) Array.IndexOf (objects, o); } }
エラー
*public class EnumeratedArray<;TEnum, TObj>; where TEnum : Enum {private TObj [] objects;public TObj this [TEnum n] { get { return objects [Convert.ToInt32 (n)]; } }public TEnum this [TObj o] { get { return (TEnum) Enum.ToObject (typeof (TEnum), Array.IndexOf (objects, o)); } }}
この例は、やりたいことを端的に表現したもので、やりたいことそのものではありません。

*} else {
エラー時の処理

シナリオの再生処理
*yield return RunScenario();
テストしたいコルーチンに必ず付ける必要がある
*[UnityTest]
コルーチンに引数として値を渡すことができる（複数指定可）
この例だと、RunWithTestCase("file_0001")、RunWithTestCase("file_0002")として扱われる
【注意】 コルーチンに[TestCase]を使う場合、ExpectedResult = null を記述しないとエラーになる
*[TestCase("file_0001", ExpectedResult = null)]
*{get{foreach (var path in Directory.GetFiles("<;path>;")){//  【注意】 [TestCase]同様、Returns(null) を記述しないとエラーになるyield return new TestCaseData(path).Returns(null);}}}
[TestCaseSource]に渡すリスト
【注意】 [TestCase]同様、Returns(null) を記述しないとエラーになる
*yield return new TestCaseData(path).Returns(null);
[TestCase]をリストで管理できるようにしたもの（動的に定義したい場合などで有用）
各要素ごとを渡したテストとして扱われる
Directory.GetFilesから取得できる文字列がfile_0001、file_0002とすると、
RunWithTestCaseSource("file_0001")、RunWithTestCaseSource("file_0002")となる
*[TestCaseSource("FILES")]
テストのタイムアウト時間を指定する
デフォルトだと30秒
ms単位で指定（この例だと5分になる）
*[Timeout(300000)]
クラス内で最初のテストが実行される前に一度だけ呼ばれる
*[OneTimeSetUp]
各テストの最初に呼ばれる
*[SetUp]
各テストの最後に呼ばれる（テストが失敗しても呼ばれる）
*[TearDown]
クラス内で最後のテストが実行された後に一度だけ呼ばれる
*[OneTimeTearDown]
クラス内で最初のテストが実行される前に一度だけ呼ばれる
*[OneTimeSetUp]
テスト時間短縮のために高速化する
*Application.targetFrameRate = 60;
targetという名前のボタンを押す
*yield return Press("target");
Scenarioシーンをロードする
*yield return LoadScene("Scenario");
targetというオブジェクトが登場するまで待機する
*yield return WaitFor(new ObjectAppeared("target"));
クラス内で最初のテストが実行される前に一度だけ呼ばれる
*[OneTimeSetUp]
ログを残す
*Application.logMessageReceived += Log;
*if (type == LogType.Error || type == LogType.Exception)*{
エラーログを保持しておく
各テストの頭でクリアする
*_errorLogs.Clear();
各テストの最後に呼ばれる（テストが失敗しても呼ばれる）
*[TearDown]
*if (_errorLogs.Count >; 0)*{
エラーログがあるならテスト失敗
テスト情報を追加する
*var engineAssembly = Assembly.Load("UnityEngine.TestRunner");
テストの名前を使って実行する
実行するテスト名(メソッド名)は名前空間とクラス名も含めること
*var testNamesField = testFilterType.GetField("testNames");
Test Runnerを実行できるクラスを参照する
*var editorAssembly = Assembly.Load("UnityEditor.TestRunner");
*runMethod.Invoke(listGUI, new object[] { testFilter });
Test Runnerを実行する
クラス内で最初のテストが実行される前に一度だけ呼ばれる
*[OneTimeSetUp]
【注意】 この例では、Logメソッドを省略
*Application.logMessageReceived += Log;
Restartするため、テスト情報を保持しておく
*var assembly = Assembly.Load("UnityEngine.TestRunner");
【注意】 この例では、FILES変数の宣言は省略
*[TestCaseSource("FILES")]
*if (_errorLogs.Count >; 0 &amp;&amp; _testFilter != null)*{
前回のテストが失敗していたら、UnityのPlay状態を止める
【注意】 テスト情報の更新処理（今回は名前で更新しているが、カテゴリーなら別の処理が必要）
*var assembly = Assembly.Load("UnityEngine.TestRunner");
すでに実行しているテストは削除する
*testNames = testNames.Where(testName =>; !_runTestNames.Any(runTestName =>; testName.Contains(runTestName))).ToArray();
Unityを止めて、Test Runnerを再び実行する
*EditorApplication.isPlaying = false;
*{var assembly = Assembly.Load("UnityEditor.TestRunner");var runnerWindowType = assembly.GetType("UnityEditor.TestTools.TestRunner.TestRunnerWindow");var runnerWindow = runnerWindowType.GetField("s_Instance", BindingFlags.NonPublic | BindingFlags.Static).GetValue(null);var listGUIField = runnerWindowType.GetField("m_PlayModeTestListGUI", BindingFlags.Instance | BindingFlags.NonPublic);var listGUI = runnerWindow != null ? listGUIField.GetValue(runnerWindow) : Activator.CreateInstance(listGUIField.FieldType);var runMethod = listGUIField.FieldType.GetMethod("RunTests", BindingFlags.Instance | BindingFlags.NonPublic);runMethod.Invoke(listGUI, new object[] { testFilter });EditorApplication.update -= OnRestart;}
コード側からTest Runnerを実行する
クラス内で最後のテストが実行された後に一度だけ呼ばれる
*[OneTimeTearDown]
*if (Environment.CommandLine.Contains("-batchmode"))*{
batchmodeなら終了させる
エラー扱いにするため、1以上を返しても良い
*EditorApplication.Exit(0);

*{// privateメソッドprivate int AddValue(int additionValue){return _Value + additionValue;}// privateプロパティprivate bool IsZero =>; _Value == 0;// privateフィールドprivate int _Value = 0;// staticなprivateメソッドprivate static int GetTotalValue(int value1, int value2){return value1 + value2;}}
テスト対象のクラス
*{return _Value + additionValue;}
privateメソッド
privateプロパティ
*private bool IsZero =>; _Value == 0;
privateフィールド
*private int _Value = 0;
*{return value1 + value2;}
staticなprivateメソッド
MyClassのprivateなメンバーをテストするためのテストコード
*[TestClass]
privateメソッドのテスト
*[TestMethod]
PrivateObjectを作成して、AddValueメソッドを呼び出す
*var myClass = new MyClass();
privateプロパティとprivateフィールドのテスト
*[TestMethod]
PrivateObjectを作成して、_ValueフィールドとIsZeroプロパティを呼び出す
*var myClass = new MyClass();
privateフィールドを取得
*var value = (int) privateObject.GetField("_Value");
privateプロパティを取得
*var isZero = (bool) privateObject.GetProperty("IsZero");
staticなprivateメソッドのテスト
*[TestMethod]
PrivateTypeを作成して、GetTotalValueメソッドを呼び出す
*var privateType = new PrivateType(typeof(MyClass));
MyClassの以下のメソッド用の拡張メソッドを定義
private int AddValue(int additionValue)
*public static int AddValue(this MyClass myClass, int additionValue)
*{// privateメソッド用の拡張メソッドpublic static int AddValue(this MyClass myClass, int additionValue){return (int) new PrivateObject(myClass).Invoke("AddValue", additionValue);}// privateプロパティ用の拡張メソッドpublic static bool IsZero(this MyClass myClass){return (bool) new PrivateObject(myClass).GetProperty("IsZero");}// privateフィールド用の拡張メソッドpublic static int _Value(this MyClass myClass){return (int) new PrivateObject(myClass).GetField("_Value");}// staticなprivateメソッド用のstaticメソッドpublic static int GetTotalValue(int value1, int value2){return (int) new PrivateType(typeof(MyClass)).InvokeStatic("GetTotalValue", value1, value2);}}
拡張メソッドの定義(テストプロジェクト内で定義)
*{return (int) new PrivateObject(myClass).Invoke("AddValue", additionValue);}
privateメソッド用の拡張メソッド
*{return (bool) new PrivateObject(myClass).GetProperty("IsZero");}
privateプロパティ用の拡張メソッド
*{return (int) new PrivateObject(myClass).GetField("_Value");}
privateフィールド用の拡張メソッド
*{return (int) new PrivateType(typeof(MyClass)).InvokeStatic("GetTotalValue", value1, value2);}
staticなprivateメソッド用のstaticメソッド
テストコードは、PrivateObjectとPrivateTypeを用いずに、シンプルに記載
*[TestClass]
privateメソッドのテスト
*[TestMethod]
privateプロパティとprivateフィールドのテスト
*[TestMethod]
privateフィールドを取得
*var value = myClass._Value();
privateプロパティを取得
*var isZero = myClass.IsZero();
staticなprivateメソッドのテスト
*[TestMethod]

*InputTt.ChangeReceiver(this);
本来はレシーバーが直接ChangeReceiverするのではなく別途Managerなどの制御クラスで行うべき
移動処理とか
*}

略
追加
*@using Radzen.Blazor
*var dParam = new Dictionary<;string, object>;() { { "Message", "メッセージ" } };
ダイアログの表示
ダイアログが閉じたとの結果を取得
*resultText = result.ToString();
*Invoke(() =>; { StateHasChanged(); });
変更通知

*wwRegion
リージョン
↓おまじない
*string hoge = await credentials.GetIdentityIdAsync();
ここでオブジェクトがとれている（略）
*}

*if (devInfo == null) return;*if (devInfo.Pairing.IsPaired == false)
devInfoが、watcherで取得したデバイス情報。
すでにペアリング済み
*}
すでにペアリング解除済み
*}
*// If this is an App for 'Windows IoT Core' where there is no Windows Consent UX, you may want to provide your own confirmation.*args.Accept();
Windows itself will pop the confirmation dialog as part of "consent" if this is running on Desktop or Mobile
*{ShowPairingPanel("Please enter this PIN on the device you are pairing with: " + args.Pin,args.PairingKind);});
No need for a deferral since we don't need any decision from the user
*// this Windows device. Get a deferral so we can perform the async request to the user.*var collectPinDeferral = args.GetDeferral();
A PIN may be shown on the target device and the user needs to enter the matching PIN on

*string cachePath = "file:
" + Application.temporaryCachePath + "tmp.wav";

*{Vector3 accLeft = OVRInput.GetLocalControllerAcceleration(LeftCon) ;Vector3 accRight = OVRInput.GetLocalControllerAcceleration(RightCon);float walkSpeed = 10;float moveSpeed;moveSpeed = accLeft.y + accRight.y;if ( moveSpeed <;= -walkSpeed||  moveSpeed >;= walkSpeed ){var moveDirect = PlayerCamera.transform.rotation.eulerAngles.y;var moveQuate = Quaternion.Euler(0, moveDirect, 0);transform.position += (moveQuate * Vector3.forward).normalized * Time.deltaTime;}}
Update is called once per frame
*// Start is called before the first frame update*void Start()
Use this for initialization
*{LeftCon = OVRInput.Controller.LTouch;RightCon = OVRInput.Controller.RTouch;rd = GetComponent<;Rigidbody>;();}
Start is called before the first frame update
*{Vector3 accLeft = OVRInput.GetLocalControllerAcceleration(LeftCon) ;Vector3 accRight = OVRInput.GetLocalControllerAcceleration(RightCon);float walkSpeed = 10;float moveSpeed;moveSpeed = accLeft.y + accRight.y;if ( moveSpeed <;= -walkSpeed||  moveSpeed >;= walkSpeed ){var moveDirect = PlayerCamera.transform.rotation.eulerAngles.y;var moveQuate = Quaternion.Euler(0, moveDirect, 0);rd.AddForce((moveQuate * Vector3.forward).normalized);}}
Update is called once per frame

ここで TaskCreationOptions.RunContinuationsAsynchronously を指定するとデッドロックしない
*TaskCompletionSource<;string>; tcs = new();
*result.SetResult($"OK ({item})");
Waiting a bit to emulate some IO-bound operation
*Util.Print($"Logging: {message}");
"Saving" message to the file
ここで new BoundedChannelOptions(1) { AllowSynchronousContinuations = true } を渡すとデッドロックするようになる
*Channel<;string>; tcs = Channel.CreateBounded<;string>;(1);
*await result.WriteAsync($"OK {item}");
Waiting a bit to emulate some IO-bound operation
*Util.Print($"Logging: {message}");
"Saving" message to the file

*writer.WriteInt16(5);
設定値を作成(ここでは5秒)

ランダムな数字を作成するやつ
*var rnd = new Random();
Title.txtの読込みとその表示
*var path = "Title.txt";
桁数の入力
*Console.WriteLine("1~10のどの桁に挑戦しますか");
正解の作成
数字が重なることはない
*var useNum = new bool[10];
正解をあてるループ
*bool isWrong = true;
*Console.Write("{0,3} >; ", time);
予想の入力
予想のstringをint[]に変換する
*var isCheck = true;
hitとblowを数える
*var hit = 0;
*if (hit == dight)*{
正解
*Console.WriteLine("{0} hit", hit);
表示

privateなメンバなためアクセスできない,プロパティもゲッターのみなので値のセットはできない.
component.hoge.Id = EditorGUILayout.IntField("ID", component.hoge.Id);
*}
*{System.Type fieldType = component.hoge.GetType();FieldInfo fieldInfo = fieldType.GetField("id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);int tempId = (int)fieldInfo.GetValue(component.hoge);fieldInfo.SetValue(component.hoge, (int)EditorGUILayout.IntField("ID", tempId));}
Reflectionを利用してパラメータを操作.

ランダムな数字を作成するやつ
*var rnd = new Random();
Title.txtの読込みとその表示
*var path = "Title.txt";
桁数の入力
*Console.WriteLine("何桁に挑戦しますか");
正解の作成
*var correct = new int[dight];
正解を当てるループ
*bool isWrong = true;
*Console.Write("{0,3} >; ", time);
予想の入力
予想のstringをint[]に変換する
*var isCheck = true;
大小のチェック
*var a = Check(answer, correct, 0);
*{// 終点まで同じだったら0を返すif (num == correct.Length){return 0;}// 同じだったら次へif (answer[num] == correct[num]){return Check(answer, correct, num + 1);}// 大きいと1を返すelse if (answer[num] >; correct[num]){return 1;}// 小さいと-1を返すelse{return -1;}}
再帰による大小のチェック
*if (num == correct.Length)*{
終点まで同じだったら0を返す
*if (answer[num] == correct[num])*{
同じだったら次へ
*else if (answer[num] >; correct[num])*{
大きいと1を返す
*{return -1;}
小さいと-1を返す

*{string credPath = "token.json";return GoogleWebAuthorizationBroker.AuthorizeAsync(GoogleClientSecrets.Load(stream).Secrets,scopes,"user", CancellationToken.None, new FileDataStore(credPath, true));}
ファイル名は先ほど取得した認証情報のjson
1日前～現在までのデータを取得
*var results = step.QueryStep(DateTime.Now.AddDays(-1), DateTime.Now);

*rewardBasedVideo.Show ();
リワード動画を表示

*using Microsoft.Extensions.DependencyInjection;
CreateScope

*public int X { get; set; }
まさかの一行！！
「= 3」の部分が初期化子。
ここでは、初期値3を入れている
*,,,
コンストラクタか、初期化詞を遣えば、1度だけ設定できる。
以後値が変わることはない。
*,,,

*{Text = "よくある質問を以下に表示します。",Buttons = new List<;CardAction>;{// Note that some channels require different values to be used in order to get buttons to display text.// In this code the emulator is accounted for with the 'title' parameter, but in other channels you may// need to provide a value for other parameters like 'text' or 'displayText'.new CardAction(ActionTypes.ImBack, title: "1. Windows 10とは何ですか？", value: "Windows 10"),new CardAction(ActionTypes.ImBack, title: "2. Surface Proとは何ですか？", value: "Surface Pro"),new CardAction(ActionTypes.ImBack, title: "3. Cortanaとは何ですか？", value: "Cortana"),},};
Create a HeroCard with options for the user to interact with the bot.
*// In this code the emulator is accounted for with the 'title' parameter, but in other channels you may*// need to provide a value for other parameters like 'text' or 'displayText'.
Note that some channels require different values to be used in order to get buttons to display text.
*// need to provide a value for other parameters like 'text' or 'displayText'.*new CardAction(ActionTypes.ImBack, title: "1. Windows 10とは何ですか？", value: "Windows 10"),
In this code the emulator is accounted for with the 'title' parameter, but in other channels you may

エクセルファイルをロードします。
*Workbook workbook = new Workbook();
Excel Rangeで背景に色を設定します。
*sheet.Range["A1:E1"].Style.Color = Color.LightSeaGreen;
保存します。
*workbook.SaveToFile("SetBackgroundColor.xlsx", ExcelVersion.Version2010);
ファイルをロードします。
*Workbook workbook = new Workbook();
画像を追加します。
*Bitmap bm = new Bitmap(Image.FromFile("logo.png"));
保存します。
*workbook.SaveToFile("SetBackgroundimage.xlsx", ExcelVersion.Version2010);

*var res = req.GetResponse();
１．リクエスト送信
*{// デシリアイズする型を指定します。var serializer = new DataContractJsonSerializer(typeof(IList<;Person>;));// デシリアイズします。var persons = (IList<;Person>;)serializer.ReadObject(ms);Debug.WriteLine($"名前\t通称\t誕生日\t星座\t血液型\t身長\t体重");foreach(var p in persons){Debug.WriteLine($"{p.Name}\t{p.Nickname}\t{p.Birthday}\t{p.Constellatione}\t"+ $"{p.BloodType}\t{p.Height}\t{p.Weight}");}}
２．UTF8 に変換し MemoryStream に格納します。
デシリアイズする型を指定します。
*var serializer = new DataContractJsonSerializer(typeof(IList<;Person>;));
デシリアイズします。
*var persons = (IList<;Person>;)serializer.ReadObject(ms);

Cache.Clear(); 的なコード
*}
*new[] { typeof(Program).Assembly },
ユーザー用
*new[] { typeof(AdminService) },
管理者用

*Task.Run(async () =<; await Electron.WindowManager.CreateWindowAsync());
☆ 起動時にElectronを使用するように、この行を追加

*{public Inventor.ApplicationAddInSite inventor;private AppDomain appDomain;private Proxy proxy;public LoadDialog(){InitializeComponent();//UpdateControlState();}public void UpdateControlState(){if (appDomain == null){LoadButton.Enabled = File.Exists(DllPathTextBox.Text);UnloadButton.Enabled = false;}else{LoadButton.Enabled = false;UnloadButton.Enabled = true;}}private void ShowErrorDialog(string message, Exception exception = null){if (exception != null){message += Environment.NewLine + exception.ToString();}MessageBox.Show(message, "AddIn Hot Loader", MessageBoxButtons.OK, MessageBoxIcon.Error);}public void UnloadAppDomain(){if (appDomain != null){if (proxy != null &amp;&amp; proxy.Activated){try{proxy.Deactivate();}catch (Exception ex){ShowErrorDialog("Deactive()で例外が送出されました。", ex);}}try{AppDomain.Unload(appDomain);appDomain = null;proxy = null;}catch (Exception ex){ShowErrorDialog("AppDomainの解放に失敗しました。", ex);}}}private void LoadButton_Click(object sender, EventArgs e){bool isError = false;try{appDomain = AppDomain.CreateDomain("InventorAddInHotLoaderDomain");proxy = (Proxy)appDomain.CreateInstanceAndUnwrap(Assembly.GetExecutingAssembly().FullName, typeof(Proxy).FullName);}catch (Exception ex){ShowErrorDialog("Proxyの作成に失敗しました。", ex);isError = true;}if (!isError){try{proxy.Initialize(DllPathTextBox.Text, NameSpaceTextBox.Text, ClassNameTextBox.Text);}catch (Exception ex){ShowErrorDialog("Proxyの初期化に失敗しました。", ex);isError = true;}}if (!isError){try{proxy.Activate(inventor, true);}catch (Exception ex){ShowErrorDialog("Activate()で例外が送出されました。", ex);isError = true;}}if (isError){UnloadAppDomain();}UpdateControlState();}private void UnloadButton_Click(object sender, EventArgs e){UnloadAppDomain();UpdateControlState();}private void DllSelectButton_Click(object sender, EventArgs e){using (var fileDialog = new OpenFileDialog()){try{fileDialog.InitialDirectory = Path.GetDirectoryName(DllPathTextBox.Text);fileDialog.FileName = Path.GetFileName(DllPathTextBox.Text);}catch{var dirInfo = Directory.GetParent(System.Reflection.Assembly.GetExecutingAssembly().Location);try{dirInfo = dirInfo.Parent;}catch { }fileDialog.InitialDirectory = dirInfo.FullName;fileDialog.FileName = string.Empty;}fileDialog.Filter = "AddIn DLL Files (*.dll)|*.dll";fileDialog.Title = "AddInを選択";var result = fileDialog.ShowDialog();if (result == DialogResult.OK){DllPathTextBox.Text = fileDialog.FileName;}}}private void DllPathTextBox_TextChanged(object sender, EventArgs e){UpdateControlState();}}
以下のcodeは抜粋で、このままでは動作しません

ここでパラメーター設定行う
*material.SetFloat("_OutlineSize", m_OutlineSize);

DB処理
コミット
*trans.Commit();
DB処理
コミット
*trans.Commit();

workbook objectを作成します。
*Workbook wb = new Workbook();
既定のシートを削除します。
*wb.Worksheets.Clear();
新規シートを追加し、それに名をつけます。
*Worksheet sheet = wb.Worksheets.Add("職員名簿");
A1からG1までのセルを横方向に結合します。
*sheet.Range["A1:G1"].Merge();
A1セルにデータを書き込み、文字の書式などを設定します。
*sheet.Range["A1"].Value = "パンダ会社職員個人情報リスト";
初めの行の高さを設定します。
*sheet.Rows[0].RowHeight = 30F;
创建一个DataTable
*DataTable dt = new DataTable();
DataTableのデータをシートに追加します。
*sheet.InsertDataTable(dt, true, 2, 1, true);
このエリアの行の高さを設定します。
*sheet.Range["A2:G7"].RowHeight = 15F;
三つ目と五つ目の列の幅を設定しあｍす。
*sheet.Range["A2:G7"].Columns[2].ColumnWidth = 15F;
グリッドのスタイルを設定します。
*sheet.Range["A2:G7"].BorderAround(LineStyleType.Medium);
.xlsxで保存します。
*wb.SaveToFile("Excel.xlsx", FileFormat.Version2013);

カメラ自動生成
*GameObject camera_G = new GameObject("OnlyUIRenderingCamera");
キャンバス生成＆設定
*GameObject canvas_G = new GameObject("FaceCanvas");
テキスト生成＆設定
*GameObject text_G = new GameObject("FpsText");
*RectTransform textRect = text_G.GetComponent<;RectTransform>;();*textRect.sizeDelta = new Vector2(1000, 1000);
テキストのポジションを調整
Layerを変更
*canvas_G.layer = LayerMask.NameToLayer("UI");
キャンバス生成＆設定
*GameObject canvas_G = new GameObject("FaceCanvas");
レンダリングをfaceCameraに
*faceCanvas.renderMode = RenderMode.WorldSpace;
*this.gameObject.transform.parent = Camera.main.transform;*this.gameObject.transform.localPosition = Vector3.zero;
このゲームオブジェクトの親、ポジションを設定
*canvas_G.transform.parent = this.gameObject.transform;*canvas_G.transform.localPosition = new Vector3(0,0,0.3f);
キャンバスの親、ポジションを設定
テキスト生成＆設定
*GameObject text_G = new GameObject("FpsText");
*RectTransform textRect = text_G.GetComponent<;RectTransform>;();*textRect.sizeDelta = new Vector2(1000, 1000);
テキストのポジションを調整

テキストエディタとスナップショットマネージャの作成
*var editor = new TextEditor();
テキストの追記
*editor.AppendText("A");
スナップショットの保存
*snapShotManager.SaveSnapShot("FirstSnapShot");
さらにテキストを追加
*editor.AppendText("B");
表示
*editor.PrintText();
*if (snapShotManager.LoadSnapShot("FirstSnapShot"))*{
スナップショットから状態を復元
復元後の状態でテキストを表示
*editor.PrintText();

Texture2Dをモデルの入力に合った形に整形、正規化する。
*var input_floats = GetFloatFromTex2DWithFlip (input);
*var input_onnx_values = new List<;NamedOnnxValue>; {NamedOnnxValue.CreateFromTensor (input_nodes_name, input_tensor)};
OnnxRuntimeでの入力形式であるNamedOnnxValueを作成する
推論を実行
*var results = session.Run (input_onnx_values);
Texture2Dをモデルの入力に合った形に整形する
*Mat img = FixTexture2Input (input);
OpenCVSharpでの入力形式であるblobを作成、同時に正規化を行う。
*Scalar mean = new Scalar (0.485f, 0.456f, 0.406f);
推論を実行
*Mat scores = model.Forward ();
Texture2Dをモデルの入力に合った形に整形、正規化する。
*var float_values = GetFloatFromTex2DWithFlip(input);
TensorFlowSharpでの入力形式であるTFTensorを作成する
*var shape = new TFShape(1, input.width, input.height, 3);
データの入力・推論
input_2:0およびoutput_node0:0はpbファイル作成時につけた入力ノードと出力ノードの名前。
*var runner = session.GetRunner();
推論を実行
*var output = runner.Run();

背景色の相対輝度
*double background = RelativeLuminance(R, G, B);
黒文字と白文字の判定に使う相対輝度境界値
*const double border = 0.17912878474779D;
背景色の相対輝度が境界値以上なら黒文字、未満なら白文字
*return background >;= border ? Color.Black : Color.White;

*{services.AddControllersWithViews();services.AddDistributedMemoryCache();services.AddSession(options =>;{options.Cookie.Name = ".Session";});var mapperConfig = new MapperConfiguration(mc =>;{mc.AddProfile(new UserProfile());});IMapper mapper = mapperConfig.CreateMapper();     /*    AutoMapperに関する処理はここだけ         */services.AddSingleton(mapper);services.AddMvc();}
This method gets called by the runtime. Use this method to add services to the container.

*Console.WriteLine($"c = {c}");
計算した値を使用する。
数回繰り返す（省略）
*}

Audioファイル種類定義.
TODO:ファイル出力時に使用したい.
*enum AudioType
複数のファイルは受け付けない.
*string[] files = (string[])e.Data.GetData(DataFormats.FileDrop, false);
*if(audioFilePath.Contains(".mp3"))*{
指定の音楽ファイル以外は受け付けない.
音楽ファイル以外はDragEnterで弾かれる.
*dropBox.Text = audioFilePath;
trackBarにあわせて音量変更.
*audioVolume = audioRate * trackBar1.Value;
入力された数値をtrackbarへ反映.
*textBox1.Text = resultValue.ToString();
数値が範囲を超えている.
*textBox1.Text = trackBar1.Value.ToString();
数値以外が入力された.
*textBox1.Text = trackBar1.Value.ToString();
ダイアログ表示.
*MessageBox.Show("ファイルをドラッグアンドドロップしてください。\n");
再生位置を戻す.
*audioReader.Position = 0;
ダイアログ表示.
*MessageBox.Show("ファイル出力が完了しました。\n");
ダイアログ表示.
*MessageBox.Show("ファイルをドラッグアンドドロップしてください。\n");

[SerializeField]を書くことで、シリアライズ可能なフィールドを宣言できる。
*[SerializeField] private GameObject _object;
publicなフィールドでも可。
public GameObject _object;
*}
指定したタグを持つGameObjectを 1つ 取得する。
*GameObject obj = GameObject.FindWithTag("探したいオブジェクトに設定されたタグ");
指定したタグを持つGameObjectを 全て 取得する。
*GameObject[] objs = GameObject.FindGameObjectsWithTag("探したいオブジェクトに設定されたタグ");
*{[SerializeField] private Example _object;// または// public Example _object;}
欲しいコンポーネントを仮に Example とする
または
public Example _object;
*}
自身を持つGameObjectにアタッチされた、他のコンポーネントを取得する場合
*var cmp = this.gameObject.GetComponent<;/*欲しいコンポーネント*/>;();
CUBE という名前のGameObjectから取得したい場合
*var cmp = GameObject.Find("CUBE").GetComponent<;/*欲しいコンポーネント*/>;();
シーン内にある、指定したコンポーネントの1つを取得する
*var cmp = FindObjectOfType<;/*欲しいコンポーネント*/>;();
シーン内にある指定したコンポーネント全てを取得する
*var cmp = FindObjectsOfType<;/*欲しいコンポーネント*/>;();

*List<;ChannelOption>; options = new List<;ChannelOption>; {new ChannelOption("grpc.keepalive_time_ms", 2000),new ChannelOption("grpc.keepalive_timeout_ms", 3000),new ChannelOption("grpc.http2.min_time_between_pings_ms", 5000),};
各種 keepalive 関連のオプションを設定する
gRPC チャネル生成時の第3引数に IEnumerable でオプションを指定する
*channel = new Channel(m_MagicOnionHost, 12345, ChannelCredentials.Insecure, options);
*List<;ChannelOption>; options = new List<;ChannelOption>; {new ChannelOption("grpc.keepalive_time_ms", 2000),new ChannelOption("grpc.keepalive_timeout_ms", 3000),new ChannelOption("grpc.http2.min_time_between_pings_ms", 5000),};
各種 keepalive 関連のオプションを設定する
`UseMagicOnion` 関数の第3引数に IEnumerable でオプションを指定する
*await MagicOnionHost.CreateDefaultBuilder()

シリアル化させるオブジェクトには、MessagePackObject属性を付ける。
引数をtrueにするとプロパティの名前がそのまま使用される。
*[MessagePackObject(true)]
*public string FullName { get { return FirstName + LastName; } }
シリアル化させたくない場合には、[IgnoreMember]を付ける。
MessagePack形式のバイト配列に変換
*byte[] bytes = MessagePackSerializer.Serialize(myClass1);
復元
*MyClass myClass2 = MessagePackSerializer.Deserialize<;MyClass>;(bytes);
JSONにも変換できる
*var json = MessagePackSerializer.ConvertToJson(bytes);
シリアル化させるオブジェクトには、MessagePackObject属性を付ける。
引数をfalseにすると[Key()]を各プロパティに付ける必要がある。
*[MessagePackObject(false)]
*public string FullName { get { return FirstName + LastName; } }
シリアル化させたくない場合には、[IgnoreMember]を付ける。
シリアル化させるオブジェクトには、MessagePackObject属性を付ける。
引数をfalseにすると[Key()]を各プロパティに付ける必要がある。
*[MessagePackObject(false)]
*public string FullName { get { return FirstName + LastName; } }
シリアル化させたくない場合には、[IgnoreMember]を付ける。
*Console.WriteLine(MessagePackSerializer.SerializeToJson(new Sample4 { Foo = 10, Bar = 20, Hoge = 1 }));
{"Hoge":1,"Foo":10}

持っている
*}
持っている
*}

データ読み書き排他用
*ReaderWriterLockSlim rwlock = new ReaderWriterLockSlim();
しっかり破棄する
*rwlock.Dispose();
読み込みロック取得
*rwlock.EnterReadLock();
*if(rwlock.IsReadLockHeld)*rwlock.ExitReadLock();
読み込みロック解放
書き込みロック取得
*_rwlock.EnterWriteLock();
*listData = new List<;int>;{ 0, 1, 2 };
データを取得するような処理
*if(_rwlock.IsWriteLockHeld)*_rwlock.ExitWriteLock();
書き込みロック解放

*return "https:
drive.google.comuc?id=" + url;

*xmlns:x="http:
schemas.microsoft.comwinfx2006xaml"

過去を選択不可能にする
*calendar.BlackoutDates.AddDatesInPast();
2019年8月1日～8月31日を選択不可能にする
*calendar.BlackoutDates.Add(new DateTime(2019, 8, 1), new DateTime(2019, 8, 31));
2019年9月1日を選択不可能にする
*calendar.BlackoutDates.Add(new DateTime(2019, 9, 1));
選択不可範囲を指定しているとエラーになるので補正
(範囲終端を超えているので終端の日付に補正)
*calendar.SelectedDate = inputRange.End;
選択不可範囲を指定しているとエラーになるので補正
(範囲先端をより過去なので先端の日付に補正)
*calendar.SelectedDate = inputRange.Start;
2019年8月1日～8月31日を選択不可能にする
*calendar.BlackoutDates.Add(inputRange);

*filteredKeywords = Environment.GetEnvironmentVariable("TwKeywords");
Check whether local.settings.json is UTF8 or not
*while (true)*{
Start Twitter Stream reading loop
*log.LogInformation($"***** Filtered Keywords : {filteredKeywords}");*var keywords = filteredKeywords.Split(new char[] { ' ', '　' });
Add filters
*{var lang = args.Tweet.Language;//***** Specify Japanese &amp; Remove Botif (lang == Tweetinvi.Models.Language.Japanese &amp;&amp; args.Tweet.Source.Contains(">;Twitter ")){log.LogInformation("----------------------------------------------------------------------");log.LogInformation($"** CreatedAt : {args.Tweet.CreatedAt}");log.LogInformation($"** CreatedBy : {args.Tweet.CreatedBy}");log.LogInformation($"** Source    : {args.Tweet.Source}");log.LogInformation($"** Text      : {args.Tweet.Text}");tweets.CreatedAt.Add(args.Tweet.CreatedAt);tweets.CreatedBy.Add(args.Tweet.CreatedBy.ToString());var source = args.Tweet.Source;var position = source.IndexOf(">;");source = source.Substring(position + 1);position = source.IndexOf("<;");source = source.Substring(0, position);tweets.Source.Add(source);tweets.Text.Add(args.Tweet.Text);}lock (countLock){++counter;}if (counter >;= maxCount || (DateTime.UtcNow - startDt) >;= maxTimeSpan){stream.Stop();completed = true;}else if ((counter - prevCounter) >;= commitInterval){stream.Stop();}};
Read stream
*if (lang == Tweetinvi.Models.Language.Japanese &amp;&amp; args.Tweet.Source.Contains(">;Twitter "))*{
***** Specify Japanese &amp; Remove Bot
*log.LogInformation($"***** Tweet Data stored to Blob : {DateTime.UtcNow}");
Write tweet data to blob storage
*{groupWriter.WriteColumn(createdAtColumn);groupWriter.WriteColumn(createdByColumn);groupWriter.WriteColumn(sourceColumn);groupWriter.WriteColumn(textColumn);}
create a new row group in the file

*searcher.Start();
検索開始
*while(false == isFinished)*{
検索が終わるまでここで待つ
イベントハンドラ破棄
*searcher.Finished -= finish;

*using UnityEngine.UI;
これがないとTextUIが使えないので必ず入力する。
テキスト2つ分のSerializeFieldを用意
*[SerializeField] Text Cal;
*{ADD,SUB,MUL,DIV,}
列挙定数を生成。
*void Start () {//四則演算計算用の数字を設定。int a = 100;int b = 50;//Inspectorで選んだものがどれかで四則演算の種類が決定。if(Cul == Tas.ADD){Cal.text = (a + b).ToString();}else if (Cul == Tas.SUB){Cal.text = (a - b).ToString();}else if (Cul == Tas.MUL){Cal.text = (a * b).ToString();}else{Cal.text = (a / b).ToString();}//列挙定数をテキスト表示に。Str.text = Cul.ToString();}
Use this for initialization
四則演算計算用の数字を設定。
*int a = 100;
*if(Cul == Tas.ADD)*{
Inspectorで選んだものがどれかで四則演算の種類が決定。
列挙定数をテキスト表示に。
*Str.text = Cul.ToString();

最後の画像を超えたら　最初に戻る
*firstFrameNum++;
画像変更
*Sprite tex = Resources.Load<;Sprite>;(folderName + "/" + headText + _fixedFirstFrameNum);
*if(firstFrameNum == imageLength)*{
一周したら停止

*<;# }
End foreach #&gt;
*{{ "integer", "int" },{ "varchar", "string" },{ "date", "DateTime" },};
DBの型⇒C#の型変換表 DBMSごとに1つ用意すればよい
*{Name = "shain_master",Description = "社員マスタ",Columns = new[]{new ColumnInfo() { Name = "shain_id", Type = "integer", IsPrimary = true, NotNull = true },new ColumnInfo() { Name = "shain_name", Type = "varchar", NotNull = true },new ColumnInfo() { Name = "address", Type = "varchar", Description = "住所" },new ColumnInfo() { Name = "created_date", Type = "date" },}};
テーブル情報 実際はDBなどから取得するものとする
*// インターフェースなので、override指定しなくてもTextTemplate側のTransformTextが呼ばれる*ITemplate template = new TextTemplate(typeDef, "MyNameSpace", table);
具象型で受けるとCS1061エラーが発生するため、インターフェースで受ける
インターフェースなので、override指定しなくてもTextTemplate側のTransformTextが呼ばれる
*ITemplate template = new TextTemplate(typeDef, "MyNameSpace", table);
*Console.WriteLine(template.TransformText());*}
実際はファイル ストリームに書き出す

*if (stream.IsWriting)*{
オーナーの場合
*{this._text = (string)stream.ReceiveNext();}
オーナー以外の場合

Poolの生成イベントを書き換える
*PhotonNetwork.PrefabPool = this;
文字列で指定
*PhotonNetwork.Instantiate("BigAsteroid", Vector3.zero, Quaternion.identity, 0);
Prefabの名前で指定
*PhotonNetwork.Instantiate(prefab.name, Vector3.zero, Quaternion.identity, 0);

*SendMessage(imwd, WM_IME_CONTROL, (IntPtr)IMC_SETCONVERSIONMODE, (IntPtr)CMode_Hiragana);
ひらがなモードに設定

*{// グラフィックオブジェクトの作成Graphics g = this.CreateGraphics();// Penを作成Pen grayPen = new Pen(Color.Gray, 2);// lineの始点と終点を設定Point start_point = new Point(25, 250);Point end_point = new Point(480, 250);// lineを描画g.DrawLine(grayPen, start_point, end_point);// Penを解放するgrayPen.Dispose();// Graphicsを解放するg.Dispose();}
画面中央に引く横線を作成するメソッド
グラフィックオブジェクトの作成
*Graphics g = this.CreateGraphics();
Penを作成
*Pen grayPen = new Pen(Color.Gray, 2);
lineの始点と終点を設定
*Point start_point = new Point(25, 250);
lineを描画
*g.DrawLine(grayPen, start_point, end_point);
Penを解放する
*grayPen.Dispose();
Graphicsを解放する
*g.Dispose();
*{try{Property p = new Property();// ロット数p.Lot = int.Parse(lot_text.Text);// 通貨数p.Tsuka = int.Parse(tsuka_combo.Text);// 0%座標p.Zero = double.Parse(zero_text.Text);// 100%座標p.Hundred = double.Parse(hundred_text.Text);// エントリーポイントp.Entry = entry_combo.Text;// 結果を入れるリストList<;string>; sList = new List<;string>;();Calc c = new Calc();sList = c.CalcAskResult(p.Lot, p.Tsuka, p.Zero, p.Hundred, p.Entry);// 結果を表示lost_num.Text = sList[0];win_num.Text = sList[1];loss_amount.Text = "-" + sList[2] + " 円";profit_amount.Text = sList[3] + " 円";} catch{SetHook(this);MessageBox.Show("値を正しく入力してください","エラー",MessageBoxButtons.OK,MessageBoxIcon.Error);lost_num.Text = null;win_num.Text = null;loss_amount.Text = null;profit_amount.Text = null;}}
買ボタン押下時
ロット数
*p.Lot = int.Parse(lot_text.Text);
通貨数
*p.Tsuka = int.Parse(tsuka_combo.Text);
0%座標
*p.Zero = double.Parse(zero_text.Text);
100%座標
*p.Hundred = double.Parse(hundred_text.Text);
エントリーポイント
*p.Entry = entry_combo.Text;
結果を入れるリスト
*List<;string>; sList = new List<;string>;();
結果を表示
*lost_num.Text = sList[0];
*public int Lot { get; set; }
自動実装プロパティ
*{List<;string>; sList = new List<;string>;();ListMake lm = new ListMake();// 0%と100%の大小が逆の場合、空のリストを返すif (high <;= low){return sList;}double lose_line;double win_line;double loss;double profit;double entry_point;// 取引金額を計算int amount = lot * tsuka;if (entry == "100%"){// 損切ラインを計算lose_line = Math.Round((low + (high - low) * 0.764) * 1000) / 1000;// 利確ラインを計算win_line = Math.Round((low + (high - low) * 1.618) * 1000) / 1000;// 損失を計算loss = Math.Round(amount * (high - lose_line));// 利益を計算profit = Math.Round(amount * (win_line - high));// ListAddsList = lm.ListAdd(lose_line.ToString(), win_line.ToString(), loss.ToString(), profit.ToString());}else if (entry == "161.8%"){// エントリーポイントを計算entry_point = Math.Round((low + (high - low) * 1.618) * 1000) / 1000;// 損切ラインは100%ラインなので、high// 利確ラインを計算win_line = Math.Round((low + (high - low) * 2.618) * 1000) / 1000;// 損失を計算loss = Math.Round(amount * (entry_point - high));// 利益を計算profit = Math.Round(amount * (win_line - entry_point));// ListAddsList = lm.ListAdd(high.ToString(), win_line.ToString(), loss.ToString(), profit.ToString());}else if (entry == "261.8%"){// エントリーポイントを計算entry_point = Math.Round((low + (high - low) * 2.618) * 1000) / 1000;// 損切ラインを計算lose_line = Math.Round((low + (high - low) * 1.618) * 1000) / 1000;// 利確ラインを計算win_line = Math.Round((low + (high - low) * 4.236) * 1000) / 1000;// 損失を計算loss = Math.Round(amount * (entry_point - lose_line));// 利益を計算profit = Math.Round(amount * (win_line - entry_point));// ListAddsList = lm.ListAdd(lose_line.ToString(), win_line.ToString(), loss.ToString(), profit.ToString());}return sList;}
損切ライン・利確ライン・損失・利益を計算(買いポジションなので0%をlow、100%をhighとする)
*if (high <;= low)*{
0%と100%の大小が逆の場合、空のリストを返す
取引金額を計算
*int amount = lot * tsuka;
損切ラインを計算
*lose_line = Math.Round((low + (high - low) * 0.764) * 1000) / 1000;
利確ラインを計算
*win_line = Math.Round((low + (high - low) * 1.618) * 1000) / 1000;
損失を計算
*loss = Math.Round(amount * (high - lose_line));
利益を計算
*profit = Math.Round(amount * (win_line - high));
エントリーポイントを計算
*entry_point = Math.Round((low + (high - low) * 1.618) * 1000) / 1000;
損切ラインは100%ラインなので、high
利確ラインを計算
*win_line = Math.Round((low + (high - low) * 2.618) * 1000) / 1000;
損失を計算
*loss = Math.Round(amount * (entry_point - high));
利益を計算
*profit = Math.Round(amount * (win_line - entry_point));
エントリーポイントを計算
*entry_point = Math.Round((low + (high - low) * 2.618) * 1000) / 1000;
損切ラインを計算
*lose_line = Math.Round((low + (high - low) * 1.618) * 1000) / 1000;
利確ラインを計算
*win_line = Math.Round((low + (high - low) * 4.236) * 1000) / 1000;
損失を計算
*loss = Math.Round(amount * (entry_point - lose_line));
利益を計算
*profit = Math.Round(amount * (win_line - entry_point));

*public Task<;T<; FooAsync() =<; Task.Run(() =<; Foo);
必要？

*foreach (string card in deck)*{
test the cards in the deck:
*{PlayCards();}
Start is called before the first frame update
*{}
Update is called once per frame
*foreach (string card in deck)*{
test the cards in the deck:

Hoge は Sample.csproj で public なクラス
テスト対象の Assembly を取得する方法はいくつかあるがライブラリのテストであれば
プロジェクトの参照を持っているだろうし public なクラスもあるはずなので GetAssembly で取得するのが楽
*var asm = Assembly.GetAssembly(typeof(Hoge));
*// 型の最後に[[{型の名前1}],[{型の名前2}],...,[{型の名前n}]]のように指定する
Generics の場合はパラメータとして与えられた型の個数を「`」の後に指定する
*// 型の最後に[[{型の名前1}],[{型の名前2}],...,[{型の名前n}]]のように指定する
そして具体的に Generics のパラメータにどのような型を指定するかは
型の最後に[[{型の名前1}],[{型の名前2}],...,[{型の名前n}]]のように指定する
*var type = asm.GetType("Sample.Foo`2[[Sample.Tests.Bar, Sample.Tests],[Sample.Tests.Bar, Sample.Tests]]");
取得した type を使用して CreateInstance でインスタンスを作成する
*var instance = Activator.CreateInstance(type);
Nested Type の場合 Declaring Type の後に「+」を付けてそのあとに名前を指定します
Generics の具体的な型の指定は Declaring Type も Nested Type もまとめて配列で指定します
*var type = asm.GetType("Sample.Qux`1+Foo`2[[Sample.Tests.Quux, Sample.Tests],[Sample.Tests.Bar, Sample.Tests],[Sample.Tests.Baz, Sample.Tests]]");

*for(var i=0;i<;100;i++)
1から列挙しないといけないのに、0から列挙してしまってる。
Fizz Buzzの実装
*}
Fizz Buzzの実装
*}

これは戻り値という情報しか入っていない
*var retval = 0;
この変数はなにをカウントしているのかが変数名のみで判断できる
*var valueCount = 0;

画像が置かれているディレクトリ名をクラス名としている
ディレクトリ配下の画像に、分類しておいた学習データが格納されている
*string[] dirs = Directory.GetDirectories(TRAIN_PATH + "/img", "*", SearchOption.TopDirectoryOnly);
ディレクトリ配下の画像ファイルを学習用のリストに入れていく
*string[] files = Directory.GetFiles(dirPath, "*", SearchOption.TopDirectoryOnly);
*var classification = Path.GetFileName(dirPath);*this.labelList.Add(classDict[classification]);
一緒にクラス名をラベル番号としてclassLabelNoListに設定する
Bag of Visual-wordsで画像パターンでベクトル化
*this.bovw.Learn(trainImgList.ToArray());
各画像のベクトルをリストに設定する（学習時に使用する）
*this.vectorList = new List<;double[]>;();
BOVWのデータを学習済みデータとして保存
*Serializer.Save(this.bovw, BOVW_MODEL_PATH);
*{// 逐次最小問題最適化法というのを用いて2次計画問題に対応する（理解薄い。。）Learner = (param) =>; new SequentialMinimalOptimization<;ChiSquare>;(){UseComplexityHeuristic = true,UseKernelEstimation = true}};
一対一多の学習アルゴリズム
*{UseComplexityHeuristic = true,UseKernelEstimation = true}
逐次最小問題最適化法というのを用いて2次計画問題に対応する（理解薄い。。）
学習データ
*var inputs = this.vectorList.ToArray();
学習する
*this.msvm = smo.Learn(inputs, outputs);
*{// キャリブレーションで使用するアルゴリズムを設定Model = this.msvm, Learner = (param) =>; new ProbabilisticOutputCalibration<;ChiSquare>;(){Model = param.Model}};
キャリブレーション
*{Model = param.Model}
キャリブレーションで使用するアルゴリズムを設定

*#pragma warning restore CS0219
変数は割り当てられていますが、その値は使用されていません

*var media = VlcControl.SourceProvider.MediaPlayer;
操作したいコントロールね
ここでtime/durationを表示するなど
*}));

*//{SensorData.text = UpdateText(Input.acceleration, Input.compass, Input.gyro.attitude);nowTime = 0f;//}
if (nowTime &gt; updateSpan &amp;&amp; LoggerButton.UpdateFlag)
*{public GameObject model;public GameObject head;static List<;Vector3>; listGyro = new List<;Vector3>;();static List<;Vector3>; listAcceleration = new List<;Vector3>;();bool flg = false;float angle;static int currentPOV = 0;static List<;string>; strPOVkey = new List<;string>; { "TPS", "FPS", "nulmodel" };Dictionary<;string, Vector3>; dicPOV = new Dictionary<;string, Vector3>;(){{"TPS",new Vector3(0f,0f,0f)},{"FPS",new Vector3(0f,-2f,-64f)},{"nulmodel",new Vector3(0f,0f,-350f)}};// Start is called before the first frame updatevoid Start(){//model = GameObject.Find("Model");//head = GameObject.Find("Head");model.transform.localPosition = dicPOV[strPOVkey[currentPOV]];listAcceleration.Add(model.transform.position);listGyro.Add(model.transform.rotation.eulerAngles);}[System.Obsolete]void Update(){if (strPOVkey[currentPOV] != "FPS"){model.transform.localPosition =Vector3.Lerp(listAcceleration.Last(),SetPosition(getSensor.Acceleration) + dicPOV[strPOVkey[currentPOV]],0.5f);model.transform.Rotate(SetRotate(getSensor.Gyro));head.transform.localEulerAngles = new Vector3(0f, 0f, model.transform.localEulerAngles.z);}listAcceleration.Add(model.transform.position);listGyro.Add(model.transform.rotation.eulerAngles);}public void OnResetObjectClick(){model.transform.localPosition = dicPOV[strPOVkey[currentPOV]];do{model.transform.Rotate(listGyro[0] - model.transform.rotation.eulerAngles);}while (model.transform.eulerAngles != new Vector3(0f, 0f, 0f));}private Vector3 SetPosition(Vector3 vec){return new Vector3(vec.x, vec.y, vec.z) * 5f;}private Vector3 SetRotate(Vector3 vec){//ピッチ角は０度で固定//ヨー角は端末の動きに追従return new Vector3(0f,//Mathf.Clamp(-vec.x, -30f, 30f),Mathf.Clamp(-vec.y * listGyro[0].y, -30f, 30f),Mathf.Clamp(vec.z, -30f, 30f)) / 5;//0f,////Mathf.Clamp(-vec.x, -30f, 30f),//Mathf.Clamp(vec.z * listGyro[0].z, -30f, 30f),//Mathf.Clamp(-vec.y, -30f, 30f)) / 5;}//視線（頭）の向きprivate Vector3 HeadOrientation(Vector3 vec){//ピッチ,ロール軸の調整float limOri = 45f;float threshold = 20f;Debug.Log(vec.z);if (vec.z >; threshold){return new Vector3(0f,Mathf.Clamp(Mathf.Abs(vec.z), -limOri, limOri),0f);}if (vec.z <; -threshold){return new Vector3(0f,Mathf.Clamp(-Mathf.Abs(vec.z), -limOri, limOri),0f);}return new Vector3(0f, 0f, 0f);}//バイクのロール角に応じて体や膝の角度の調整private Vector3 LeanIn(Vector3 vec){return new Vector3(0f, 0f, 0f);}public void ChangePOV(){if (currentPOV <; strPOVkey.Count - 1)currentPOV++;elsecurrentPOV = 0;OnResetObjectClick();}}
using System.Numerics;
*{//model = GameObject.Find("Model");//head = GameObject.Find("Head");model.transform.localPosition = dicPOV[strPOVkey[currentPOV]];listAcceleration.Add(model.transform.position);listGyro.Add(model.transform.rotation.eulerAngles);}
Start is called before the first frame update
*model.transform.localPosition = dicPOV[strPOVkey[currentPOV]];*listAcceleration.Add(model.transform.position);
head = GameObject.Find("Head");
ピッチ角は０度で固定
ヨー角は端末の動きに追従
*return new Vector3(
*{//ピッチ,ロール軸の調整float limOri = 45f;float threshold = 20f;Debug.Log(vec.z);if (vec.z >; threshold){return new Vector3(0f,Mathf.Clamp(Mathf.Abs(vec.z), -limOri, limOri),0f);}if (vec.z <; -threshold){return new Vector3(0f,Mathf.Clamp(-Mathf.Abs(vec.z), -limOri, limOri),0f);}return new Vector3(0f, 0f, 0f);}
視線（頭）の向き
ピッチ,ロール軸の調整
*float limOri = 45f;
*{return new Vector3(0f, 0f, 0f);}
バイクのロール角に応じて体や膝の角度の調整

base呼び出し
*processor.Append(Instruction.Create(OpCodes.Ldarg_0));

*B = "XXX"
実際は何かのデータを取得 ...

*co++;
coは一度だけ選択を合わせるために使用している、これがないとUpdateなので、常に選択され続ける。

★ここで、「Dll1＿Win32.dll」「Dll1_x64.dll」とか分けずにDll1を使える！！
*[DllImport("Dll1.dll", CallingConvention = CallingConvention.Cdecl)]

*[WithConstructor]
placeholder syntax, up for debate

*midiOutShortMsg(this.hMidi, 0x19c0);
音色を定義 アコースティックギター（スチール弦）0x19(25)
*if (midiOutClose(this.hMidi) == MMSYSERR_NOERROR)*{
MidiデバイスのClose
*List<;byte>; Chord = new List<;byte>;() { 0x31,0x36,0x3A };
C#
*byte[] Header = JoinByteArray(MThd, dataLength, format, tracknum, trackLength);*byte[] MTrk = new byte[] { 0x4D, 0x54, 0x72, 0x6B };
ヘッダ作成
*foreach (byte note in playNotes)*{
playNotes -&gt; GUIで指定した音
*byte[] midifile = JoinByteArray(Header,*MTrk, new byte[] { 0x00, 0x00, 0x00, (byte)(ClockInfo.Length + TempoInfo.Length + TrackEnd.Length) }, ClockInfo, TempoInfo, TrackEnd,
バイナリファイルの内容作成
*{List<;byte>; ret = new List<;byte>;();foreach (byte[] array in arrays){foreach (byte arr_m in array){ret.Add(arr_m);}}return ret.ToArray();}
複数のbyte配列を結合して一つのbyte配列にまとめる
*if (!makeMidiFile(midiFile))*{
MIDIファイルの作成
pythonExe -&gt; Python.exeのフルパス
pythonScript -&gt; midiChordAnalysis.pyの相対パス
midiFile -&gt; 作成したmidiファイルの相対パス
*StartInfo = new ProcessStartInfo()

*textWords[i, n] = tempWords[n];
2次配列textWordsにカンマごとに分けたtempWordsを代入していく
*{Start();n = 0;//アイテムナンバー、0から始まるので+1をして1から表記uiText.text = (count + 1).ToString("00");//テキストの行数を超えないように制限、テキストをカウントに併せて変更。if(count <; rowLength){MaineText.text = (textWords[count, 0]);}}
プレハブ化された表示形式に以下の処理で文字と画像を順番に割り当てていく
アイテムナンバー、0から始まるので+1をして1から表記
*uiText.text = (count + 1).ToString("00");
*if(count <; rowLength)*{
テキストの行数を超えないように制限、テキストをカウントに併せて変更。

Durationの変更はParticleSystemのプレイ中には不可のようです
_mainModule.duration = _durationTimeValue;
Loopのオンオフ
*_mainModule.loop = false;
*_minMaxCurve = _startLifeTimeValue;*_mainModule.startLifetime = _minMaxCurve;
StartLifeTimeの値の変更(Constantの場合)
StartLifeTimeのモードの変更(Constant→Curve)
*ParticleSystemCurveMode particleSystemCurveMode = ParticleSystemCurveMode.Curve;
StartLifeTimeの値の変更(Curveの場合)
*_minMaxCurve.curve = _animationCurve;
2020/08/18 追記
StartColorの変更
*_mainModule.startColor = Color.red;
だんだんと消滅させる
*_MinMaxCurve.constant -= deleteSpeed;
*{_ParticleSystem.GetCollisionEvents(other, particleCollisionEventList);Vector3 collisionHitPos = particleCollisionEventList[0].intersection;Instantiate(obj,collisionHitPos,Quaternion.identity);}
パーティクルの当たった箇所でオブジェクト出現

*const double black = 0.0D;
黒の相対輝度
文字色と背景色のコントラスト比を計算
double whiteContrast = RelativeLuminanceRatio(white, background);    文字色：白との比
double blackContrast = RelativeLuminanceRatio(black, background);    文字色：黒との比
コントラスト比が大きい文字色を採用
*return whiteContrast <; blackContrast ? Color.Black : Color.White;
textColor = Color.White が選ばれる
*Color textColor = chooseTextColor(125, 40, 80);
textColor = Color.Black が選ばれる
*Color textColor = chooseTextColor(200, 160, 180);
*Func<;byte, double>; toRgb = (rgb) =>; {double srgb = (double)rgb / 255;return srgb <;= 0.03928 ? srgb / 12.92 : Math.Pow((srgb + 0.055) / 1.055, 2.4);};
RGB の各値を相対輝度算出用に変換
*{double srgb = (double)rgb / 255;return srgb <;= 0.03928 ? srgb / 12.92 : Math.Pow((srgb + 0.055) / 1.055, 2.4);}
RGB の各値を相対輝度算出用に変換
*{return 0.2126 * toRgb(R) + 0.7152 * toRgb(G) + 0.0722 * toRgb(B);}
RGB から相対輝度を算出（0.0 ～ 1.0）

*embed.AddField("Googleリンク", "[こちら](https:
www.google.com) をクリック。");
作成したEmbedをbotに送信させる。
*await message.Channel.SendMessageAsync("テスト", embed: embed.Build());

*var kantoh=new Dictionary<;string,string>;{{"茨城県","水戸市"},{"栃木県","宇都宮市"},{"群馬県","前橋市"},{"埼玉県","さいたま市"},{"神奈川県","横浜市"}};
初期化
代入
*kantoh["千葉県"]="千葉市";
要素の有無
*Console.WriteLine(kantoh.ContainsKey("千葉県"));
追加
*kantoh.Add("東京都","新宿区");
*try{kantoh.Add("東京都","新宿区");}
要素が登録済みの場合、ArgumentException
取得
*Console.WriteLine(kantoh["千葉県"]);
代入演算子も使用可
*kantoh["千葉県"]+="中央区";
要素数
*Console.WriteLine(kantoh.Count);
要素の削除
*kantoh.Remove("千葉県");
キーの配列
*Console.WriteLine(string.Join(",",kantoh.Keys));
値の配列
*Console.WriteLine(string.Join(",",kantoh.Keys));
*foreach(var v in kantoh){*Console.WriteLine($"key:{v.Key} value:{v.Value}");
ループ
要素のクリア
*kantoh.Clear();

*account.Validate();
追加

置換処理の通知を受けたSampleViewModelsクラスの処理
*var ram = new Random();
*((INotifyPropertyChanged)this._models).PropertyChanged += this.SampleViewModels_PropertyChanged;*,,,
SampleViewModelsのコンストラクタ内の処理

追従先
*public GameObject Player;
視点回転スピード
*public float RotateSpeed = 0.1f;
追従先との距離ベクトル
*private Vector3 OffsetVector;
*private Transform PlayerTransform;*void Start()
追従先のTransform
一番最初に一回だけ呼ばれる。
追従先との距離を覚える。
*OffsetVector = transform.position - Player.transform.position;
*PlayerTransform = Player.GetComponent<;Transform>;();*}
追従先のTransformを取る。(カメラが向いた方向に追従先も回転させるため)
*transform.position = Player.transform.position + OffsetVector;*// マウスの回転を感知して回転ベクトル化
追従先との距離を保つ
マウスの回転を感知して回転ベクトル化
*Vector3 angle = new Vector3(
*transform.eulerAngles += new Vector3(angle.y, angle.x);*// 追従先も加算して回転させる。
回転ベクトルをカメラのもとのベクトルに加算
*PlayerTransform.transform.eulerAngles += new Vector3(0, angle.x, 0);*}
追従先も加算して回転させる。
自分のオブジェクト
*public GameObject Player;
X軸への移動スピード
*public float MoveSpeedX = 20.0f;
Z軸への移動スピード
*public float MoveSpeedZ = 20.0f;
ジャンプの高さ
*private float MoveSpeedY = 10f;
プレイヤーオブジェクトの物理演算数を取得。
*rb = Player.GetComponent<;Rigidbody>;();
*void FixedUpdate() {// wを押したときif (Input.GetKey(KeyCode.W)){rb.AddForce(Mathf.Cos(transform.localEulerAngles.y * Mathf.Deg2Rad) * MoveSpeedX, 0, -Mathf.Sin(transform.localEulerAngles.y * Mathf.Deg2Rad) * MoveSpeedX);}// sを押したときif (Input.GetKey(KeyCode.S)){Plarb.AddForce(-Mathf.Cos(transform.localEulerAngles.y * Mathf.Deg2Rad) * MoveSpeedX, 0, Mathf.Sin(transform.localEulerAngles.y * Mathf.Deg2Rad) * MoveSpeedX);}// スペースを押したときif (Input.GetKeyDown(KeyCode.Space)){Vector3 go = new Vector3(0, MoveSpeedY, 0);rb.velocity = go;}}
毎フレームごとに実行される。
*if (Input.GetKey(KeyCode.W))*{
wを押したとき
*if (Input.GetKey(KeyCode.S))*{Pla
sを押したとき
*if (Input.GetKeyDown(KeyCode.Space))*{
スペースを押したとき

*decode_table[i] = (char)0xFF;
-1 encoding_tableにありえない値
*for ( int i = 0, count = bytes.Length; i <; count; i += DIGIT)*{
Base32 は1文字5bitなので 5byte ずつとりだして8文字ずつに変換する
40bitに統合
*ulong merge = 0;
*if( j+i >;= count )*{
範囲外参照チェック
4-j ビットシフトが必要
*merge |= ( (ulong)bytes[i+j] <;<; (BYTE_LENGTH * (DIGIT-j-1)) );
5bit 毎に分割
*byte b;
*if( j <; parseByteCount * BYTE_LENGTH / DIGIT +1 )*{
取り出して来た有効byteのところまで変換をかける
4文字ずつ分割して不足分は = で埋める
*int lastWordLen = builder.Length % PADDING_UNIT;
Base32じゃないよ！
*Debug.LogError( "not base32" );
*for ( int i = 0, count = base32.Length; i <; count; i += BYTE_LENGTH )*{
8文字( 8 x 5bit =40bit) ずつ取り出して5byteごとに変換をかけていく
*if( index <; 0 )*{
改行などの対象外の場合はもう一文字
1文字5bit なので5n bit シフトを行う
*merge |= (ulong)( index <;<; ( (BYTE_LENGTH-j-1) * DIGIT) );
*for (int j = 0; j <; DIGIT; j++)*{
40bit を8bitずつに分割

*{if (m_setactiveObjects.Length >; 0){foreach(var setactiveObject in m_setactiveObjects){setactiveObject.m_gameObject.SetActive(setactiveObject.m_enabled);}}else{Debug.LogError("m_setactiveObjects is empty!");}}
=========================
*for (int index = 0; index <; data.Length; index++)*{
暗号化.

*var messenger = new Messenger(weatherService);
呼び出す時に機能を注入

データベースの接続開始
*connection.Open();
SELECT文を設定します。
*command.CommandText = "SELECT * FROM [tableName] " ;
SQLの実行
*var adapter = new SqlDataAdapter(command);
データベースの接続終了
*connection.Close();

*・・・
普通にiTmpを使える。

*const float outRangeAlpha = 0.5f;
範囲外のアルファ値
アイコンを表示する座標
*var iconPos = new Vector3(iconTarget.position.x, defaultPosY, iconTarget.position.z);
*if (CheckInsideMap()) {*spriteRenderer.color = new Color(spriteRenderer.color.r, spriteRenderer.color.g, spriteRenderer.color.b, normalAlpha);
ミニマップ範囲内の場合はそのまま表示する
マップ範囲外の場合、ミニマップ端までのベクトルを求めて半透明で表示する
*spriteRenderer.color = new Color(spriteRenderer.color.r, spriteRenderer.color.g, spriteRenderer.color.b, outRangeAlpha);
直線距離で判定するため、yは0扱いにする
*cameraPos.y = targetPos.y = 0;

*{public abstract class Product{public abstract void Use();}}
Productクラス
*{public abstract class Factory{public Product Create(string owner){var product = CreateProduct(owner);RegisterProduct(product);return product;}public abstract Product CreateProduct(string owner);public abstract void RegisterProduct(Product product);}}
Factory クラス
IdCardクラス(Productクラスの実装)
*using DesignPatternLearn.FactoryMethodLearn.FrameWork;
IdCardFactoryクラス(Factoryクラスの実装)
*using DesignPatternLearn.FactoryMethodLearn.FrameWork;

*{groupWriter.WriteColumn(createdAtColumn);groupWriter.WriteColumn(createdByColumn);groupWriter.WriteColumn(sourceColumn);groupWriter.WriteColumn(textColumn);}
create a new row group in the file
*{var lang = args.Tweet.Language;// Specify Japanese &amp; Remove bot tweetsif (lang == Tweetinvi.Models.Language.Japanese &amp;&amp; args.Tweet.Source.Contains(">;Twitter ")){Console.WriteLine("----------------------------------------------------------------------");Console.WriteLine($"** CreatedAt : {args.Tweet.CreatedAt}");Console.WriteLine($"** CreatedBy : {args.Tweet.CreatedBy}");Console.WriteLine($"** Source    : {args.Tweet.Source}");Console.WriteLine($"** Text      : {args.Tweet.Text}");tweets.CreatedAt.Add(args.Tweet.CreatedAt);tweets.CreatedBy.Add(args.Tweet.CreatedBy.ToString());tweets.Source.Add(args.Tweet.Source);tweets.Text.Add(args.Tweet.Text);}++counter;if (counter >; maxCount){stream.Stop();}};
Read stream
*if (lang == Tweetinvi.Models.Language.Japanese &amp;&amp; args.Tweet.Source.Contains(">;Twitter "))*{
Specify Japanese &amp; Remove bot tweets
*{groupWriter.WriteColumn(createdAtColumn);groupWriter.WriteColumn(createdByColumn);groupWriter.WriteColumn(sourceColumn);groupWriter.WriteColumn(textColumn);}
create a new row group in the file

*SwipeMininalDuration, SwipeMaximalDuration))
Duration

*bitmapData.Width,
当然ながら画像サイズとストライドも必要
*if (bitmapData != null) hugeImage.UnlockBits(bitmapData);*}
ロックした画像を解放

*slime.setIntroduction(setName: "スライム", setExp: 200,setLife:100);
スライムの情報を取得する。

*var isOk = await postClass.PostMethod("グーグル", "中の人何人くらいで動かしてるんやろ", "https:
www.google.co.jp", "#ff0000");

*{
PDFに直接変換したい画像ファイルを複数選択できるようにしている。
*if (fileDialog.ShowDialog() == DialogResult.OK)*{
「開く」ボタンが選択された時の処理
変換したい画像のリストを取得
string[] fileNames = fileDialog.FileNames;  こんな感じで選択されたファイルのパスが取得できる
PDFは、今回は仮に、最初のファイルと同じフォルダに「test.pdf」として生成される。
*clsZIP cls = new clsZIP();
おしまいのメッセージ
*MessageBox.Show("END");
さようなら
*Application.Exit();

非同期な処理
*}

*using System.Transactions;
System.Transactions.dll
「newfolder」ディレクトリを作成
*fileMgr.CreateDirectory(@"test\a\newfolder");
「newfolder\aaa.txt」ファイルを作成
*fileMgr.WriteAllText(@"test\a\newfolder\aaa.txt", "あああああ");
「newfolder\aaa.txt」ファイルに追記
*fileMgr.AppendAllText(@"test\a\newfolder\aaa.txt", "いいいい");
test.txt→test_renamed.txt に変更
*fileMgr.Move(@"test\a\test.txt", @"test\a\test_renamed.txt");
WriteAllTextはBOMなしのUTF8になるので、エンコードを変えたかったりバイナリを操作したい場合はSnapshotを行う
*fileMgr.Snapshot(@"test\a\test_renamed.txt");

*io.AddInputCharacter(e);
ImGuiへ通知

*if (lang == Tweetinvi.Models.Language.Japanese &amp;&amp; args.Tweet.Source.Contains(">;Twitter "))*{
Specify Japanese &amp; Remove bot tweets
*var fileName = $"{defaultDir}tweets.parquet";
create file
*{groupWriter.WriteColumn(createdAtColumn);groupWriter.WriteColumn(createdByColumn);groupWriter.WriteColumn(sourceColumn);groupWriter.WriteColumn(textColumn);}
create a new row group in the file
*{var lang = args.Tweet.Language;// Specify Japanese &amp; Remove bot tweetsif (lang == Tweetinvi.Models.Language.Japanese &amp;&amp; args.Tweet.Source.Contains(">;Twitter ")){Console.WriteLine("----------------------------------------------------------------------");Console.WriteLine($"** CreatedAt : {args.Tweet.CreatedAt}");Console.WriteLine($"** CreatedBy : {args.Tweet.CreatedBy}");Console.WriteLine($"** Source    : {args.Tweet.Source}");Console.WriteLine($"** Text      : {args.Tweet.Text}");tweets.CreatedAt.Add(args.Tweet.CreatedAt);tweets.CreatedBy.Add(args.Tweet.CreatedBy.ToString());tweets.Source.Add(args.Tweet.Source);tweets.Text.Add(args.Tweet.Text);}++counter;if (counter >; maxCount){stream.Stop();}};
Read stream
*if (lang == Tweetinvi.Models.Language.Japanese &amp;&amp; args.Tweet.Source.Contains(">;Twitter "))*{
Specify Japanese &amp; Remove bot tweets
*var fileName = $"{defaultDir}tweets.parquet";
create file
*{groupWriter.WriteColumn(createdAtColumn);groupWriter.WriteColumn(createdByColumn);groupWriter.WriteColumn(sourceColumn);groupWriter.WriteColumn(textColumn);}
create a new row group in the file

*{
bmpに直接変換したい画像ファイルを選択できるようにしている。
*if (fileDialog.ShowDialog() == DialogResult.OK)*{
「開く」ボタンが選択された時の処理
変換したい画像のパスを取得
string fileName = fileDialog.FileName;  こんな感じで選択されたファイルのパスが取得できる
Windows Bitmapは、今回は仮に、最初のファイルと同じフォルダに「test.bmp」として生成される。
*clsBMP cls = new clsBMP();
おしまいのメッセージ
*MessageBox.Show("END");
さようなら
*Application.Exit();

リクエストデータ格納用
*private Hashtable _postData = new Hashtable();
リクエストイベント処理登録
*_webBrowser.RequestHandler = new RequestHandler(this);
*Invoke(new MethodInvoker(() =>; { SetFocus(_webBrowser.Handle); }));
_webBrowser.Focus()
読込完了処理を記述
*string jsScript = null;
*{string aaa = null;if (url.IndexOf("/exec/system/1161228728") >;= 0) {if (requestBody.IndexOf("=") != -1) {string[] ary = requestBody.Split("&amp;");for (int i = 0; i <;= ary.Length - 1; i++) {string[] param = ary[i].Split("=");_postData.Add(Web.HttpUtility.UrlDecode(param[0]), Web.HttpUtility.UrlDecode(param[1]));}return true;}}return false;}
リクエストのデータセット処理
*{private frmMain _frm;// コンストラクタpublic RequestHandler(frmMain frm){_frm = frm;}// リクエストが投げられる前に呼ばれる処理CefReturnValue IRequestHandler.OnBeforeResourceLoad(IWebBrowser browserControl, IBrowser browser, IFrame frame, IRequest request, IRequestCallback callback){if (request.Method == "POST"){using (var postData = request.PostData){var elements = postData.Elements;var charSet = request.GetCharSet();foreach (var element in elements){if (element.Type == PostDataElementType.Bytes){if (_frm.SetRequestData(browserControl.Address, element.GetBody(charSet)))break;}}}}return CefReturnValue.Continue;}bool IRequestHandler.OnOpenUrlFromTab(IWebBrowser browserControl, IBrowser browser, IFrame frame, string targetUrl, WindowOpenDisposition targetDisposition, bool userGesture){return false;}bool IRequestHandler.OnCertificateError(IWebBrowser browserControl, IBrowser browser, CefErrorCode errorCode, string requestUrl, ISslInfo sslInfo, IRequestCallback callback){return false;}void IRequestHandler.OnPluginCrashed(IWebBrowser browserControl, IBrowser browser, string pluginPath){}bool IRequestHandler.GetAuthCredentials(IWebBrowser browserControl, IBrowser browser, IFrame frame, bool isProxy, string host, int port, string realm, string scheme, IAuthCallback callback){callback.Dispose();return false;}void IRequestHandler.OnRenderProcessTerminated(IWebBrowser browserControl, IBrowser browser, CefTerminationStatus status){}void IRequestHandler.OnRenderViewReady(IWebBrowser browserControl, IBrowser browser){}bool IRequestHandler.OnQuotaRequest(IWebBrowser browserControl, IBrowser browser, string originUrl, long newSize, IRequestCallback callback){return false;}bool IRequestHandler.OnProtocolExecution(IWebBrowser browserControl, IBrowser browser, string url){return false;}bool IRequestHandler.OnResourceResponse(IWebBrowser browserControl, IBrowser browser, IFrame frame, IRequest request, IResponse response){return false;}void IRequestHandler.OnResourceLoadComplete(IWebBrowser browserControl, IBrowser browser, IFrame frame, IRequest request, IResponse response, UrlRequestStatus status, long receivedContentLength){}public void OnResourceRedirect(IWebBrowser browserControl, IBrowser browser, IFrame frame, IRequest request, IResponse response, ref string newUrl){}public IResponseFilter GetResourceResponseFilter(IWebBrowser browserControl, IBrowser browser, IFrame frame, IRequest request, IResponse response){return null;}public bool OnBeforeBrowse(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, bool userGesture, bool isRedirect){return false;}public bool OnSelectClientCertificate(IWebBrowser chromiumWebBrowser, IBrowser browser, bool isProxy, string host, int port, X509Certificate2Collection certificates, ISelectClientCertificateCallback callback){return true;}public bool CanGetCookies(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request){return true;}public bool CanSetCookie(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, CefSharp.Cookie cookie){return true;}}
リクエストハンドラークラス
*{_frm = frm;}
コンストラクタ
*CefReturnValue IRequestHandler.OnBeforeResourceLoad(IWebBrowser browserControl, IBrowser browser, IFrame frame, IRequest request, IRequestCallback callback)*{
リクエストが投げられる前に呼ばれる処理

*public event KeyCommandEventHandler KeyCommand = ValueTuple =<; { };
------②
イベントを発生
*KeyCommand(input);

WithJs()で、JavaScriptを有効 動作してるか不明
*var config = Configuration.Default.WithDefaultLoader().WithJs();

キーボード操作用
*private Vector3 rotate;
動作確認用のログ
*Debug.Log("started");
*if (Application.isEditor)*{
Unityエディタと実機で処理を分ける
キーボードで視点変更
*float speed = Time.deltaTime * 100.0f;
*if (Application.isEditor)*{
PCは矢印キーで視点変更
*{Quaternion gratitude = Input.gyro.attitude;gratitude.x *= -1;gratitude.y *= -1;transform.localRotation = Quaternion.Euler(90, 0, 0) * gratitude;}
スマホはジャイロで視点変更
*#if UNITY_EDITOR || UNITY_STANDALONE*private Vector3 rotate;
キーボード操作用
動作確認用ログ1
*Debug.Log("started");
動作確認用ログ2
*Debug.Log("non-smartphone");
*#if UNITY_EDITOR || UNITY_STANDALONE*float speed = Time.deltaTime * 100.0f;
PCの場合はキーボード、スマホはジャイロで視点変更

*private const double perEuro = 121.02;
ユーロ
*{return dollar * perDollar;}
ドル→円
*{return yen / perDollar;}
円→ドル
*public static double PoundToYen(int pound){return pound * perPound;}
ポンド→円
*public static double YenToPound(int yen){return yen / perPound;}
円→ポンド
*{return yuan * perPound;}
元→円
*{return yen / perPound;}
円→元
*{return euro * perPound;}
ユーロ→円
*{return yen / perPound;}
円→ユーロ

AesCryptoServiceProivder を使うときは  CryptoConfig を使うと良い。
CryptoConfig cryptoConfig = new CryptoConfig();
var aes = (AesCryptoServiceProvider)CryptoConfig.CreateFromName("AES");
*string original = "Here is some data encrypt!";
*Console.WriteLine($"Key Length: {generatedKey.Length}");
var aes = (AesCryptoServiceProvider)CryptoConfig.CreateFromName("AES");
*//{//    byte[] key = new byte[KeySize / BitsPerByte];//    RandomNumberGenerator.Fill(key);//    Key = key;//}
public sealed override void GenerateKey()
*Console.WriteLine($"KeySize: {myAes.KeySize}");
}
*{var buffer = new byte[32];using (var rng = new RNGCryptoServiceProvider()){rng.GetBytes(buffer);return BitConverter.ToString(buffer).Replace("-", string.Empty);}}
Make the key as 256-bit with the HEX string format
*if (hexOrBase64.Length == 64)*{
only support 32 bytes (256 bits) key length

*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame

なにがし
*}
docker-compose.yml で立てたseleniumサーバ
var uri = new Uri("http:selenium:4444/wd/hub/");
*using (var driver = new RemoteWebDriver(uri, options))
なにがし
*}

*public static int WS_CAPTION = WS_BORDER | WS_DLGFRAME;
window with a title bar

*dynamic json =  JsonConvert.DeserializeObject("{'a':1}");
二重引用符ではなく一重引用符を含むプロパティ
*json = JsonConvert.DeserializeObject("{a:1}");
引用符なしのプロパティ
*json = JsonConvert.DeserializeObject("{\"a\":NaN}");
NaN,Infinity, -Infinity
*json = JsonConvert.DeserializeObject("{\"a\": 123,}");
末尾のコンマ
空のコンマ
*json = JsonConvert.DeserializeObject("[1,,2]");
*json = JsonConvert.DeserializeObject("{\"a\": 010}");
8進数
*json = JsonConvert.DeserializeObject("{\"a\": 0x010}");
16進数

重い処理
*Thread.Sleep(1000);
重い処理
*Thread.Sleep(1000);
重い処理
*Thread.Sleep(1000);

*ToUV(size.x - size.z, harfX + harfZ + size.y+0.5f),
6:most far top

キャンセル
*this.cancelBtn.Enabled = false;
*{if((e.Error is null) == false){//エラーの表示等の処理Console.WriteLine("error");DialogResult = DialogResult.Cancel;}else if (e.Cancelled){//キャンセル時の処理Console.WriteLine("canceled");DialogResult = DialogResult.Cancel;}else{//完了時の処理Console.WriteLine("completed");DialogResult = DialogResult.OK;}//フォームを閉じるthis.Close();}
完了時の挙動
エラーの表示等の処理
*Console.WriteLine("error");
キャンセル時の処理
*Console.WriteLine("canceled");
完了時の処理
*Console.WriteLine("completed");
フォームを閉じる
*this.Close();
*{//プログレスバーの値を変更する//設定されてる値の範囲外の値を渡すとエラーが発生することに注意if (e.ProgressPercentage <; this.progressBar1.Minimum){this.progressBar1.Value = this.progressBar1.Minimum;}else if (this.progressBar1.Maximum <; e.ProgressPercentage){this.progressBar1.Value = this.progressBar1.Maximum;}else{this.progressBar1.Value = e.ProgressPercentage;}//UserStateの内容を表示するprogressLabel.Text = e.UserState.ToString();}
進捗の表示
プログレスバーの値を変更する
設定されてる値の範囲外の値を渡すとエラーが発生することに注意
*if (e.ProgressPercentage <; this.progressBar1.Minimum)
UserStateの内容を表示する
*progressLabel.Text = e.UserState.ToString();
画面表示を開始した際に動いてない場合はRunWorkerAsync()を呼ぶ
二重に叩かないように判定を入れる
*if (!backgroundWorker.IsBusy)
*if (backgroundWorker.IsBusy)*{
処理をキャンセルする
×ボタンで閉じられた際の対処
backgroundWorkerが動いており
*if (backgroundWorker.IsBusy &amp;&amp; !backgroundWorker.CancellationPending)
一度Closingをキャンセルしたうえで、改めてキャンセル処理をする。
*e.Cancel = true;
フォーム側でイベントハンドラーに加えた処理を外す
*backgroundWorker.ProgressChanged -= BackgroundWorker_ProgressChanged;
処理がキャンセルされた場合
※重要：競合を防ぐため、Cancel状態をDoWorkEventArgsにも伝える。
この処理を省くと、 RunWorkerCompletedEventArgs.Canceledがfalseのまま伝わる。
*e.Cancel = true;
キャンセルできる処理を呼び出す
*bw.WorkerSupportsCancellation = true;
進捗表示フォームを呼び出す。
*var res = prgForm.ShowDialog();
*else{//正常終了でない場合の処理}
正常終了時の処理
正常終了でない場合の処理
*}
キャンセルできない処理を呼び出す。
*bw.WorkerSupportsCancellation = false;
進捗表示フォームを呼び出す。
*var res = prgForm.ShowDialog();
正常終了時の処理
*}
正常終了でない場合の処理
*}
プログレスバーの値を変更する
設定されてる値の範囲外の値を渡すとエラーが発生することに注意
*if (e.ProgressPercentage <; this.progressBar1.Minimum)
UserStateの内容を表示する
*progressLabel.Text = e.UserState.ToString();
*if (backgroundWorker.IsBusy)*{
処理をキャンセルする
×ボタンで閉じられた際の対処
backgroundWorkerが動いており
*if (backgroundWorker.IsBusy &amp;&amp; !backgroundWorker.CancellationPending)
一度Closingをキャンセルしたうえで、改めてキャンセル処理をする。
*e.Cancel = true;
*{if((e.Error is null) == false){//エラーの表示等の処理Console.WriteLine("error");DialogResult = DialogResult.Cancel;}else if (e.Cancelled){//キャンセル時の処理Console.WriteLine("canceled");DialogResult = DialogResult.Cancel;}else{//完了時の処理Console.WriteLine("completed");DialogResult = DialogResult.OK;}//フォームを閉じるthis.Close();}
完了時の挙動
エラーの表示等の処理
*Console.WriteLine("error");
キャンセル時の処理
*Console.WriteLine("canceled");
完了時の処理
*Console.WriteLine("completed");
フォームを閉じる
*this.Close();
キャンセル
*this.cancelBtn.Enabled = false;
画面表示を開始した際に動いてない場合はRunWorkerAsync()を呼ぶ
二重に叩かないように判定を入れる
*if (!backgroundWorker.IsBusy)
フォーム側でイベントハンドラーに加えた処理を外す
*backgroundWorker.ProgressChanged -= BackgroundWorker_ProgressChanged;
フォーム側でイベントハンドラーに加えた処理を外す
*backgroundWorker.ProgressChanged -= BackgroundWorker_ProgressChanged;
×ボタンで閉じられた際の対処
backgroundWorkerが動いており
*if (backgroundWorker.IsBusy &amp;&amp; !backgroundWorker.CancellationPending)
一度Closingをキャンセルしたうえで、改めてキャンセル処理をする。
*e.Cancel = true;
処理がキャンセルされた場合
e.Cancel = true;※重要：競合を防ぐため、Cancel状態をDoWorkEventArgsにも伝える。
*return;
イベントハンドラーに処理を渡す。
*bw.DoWork += this.backgroundWorker_DoWork;
*if(res == DialogResult.OK){//正常終了時の処理}
進捗表示フォームを呼び出す。
*else{//正常終了でない場合の処理}
正常終了時の処理
正常終了でない場合の処理
*}
処理がキャンセルされた場合
e.Cancel = true;※重要：競合を防ぐため、Cancel状態をDoWorkEventArgsにも伝える。
*return;

"あいうえお"を暗号化
*AesEncrypter.WriteAesEncryptedBytesToFile("あいうえお", @"C:\work\test.bin");
暗号化したデータを読み出し復号化する
*var d = AesEncrypter.ReadAesEncryptedBytesFromFile(@"C:\work\test.bin");
キー 半角32文字のランダムな文字列
(1文字あたり8bit→8*32=256bit→キーサイズ)
*private static readonly string AesKey = @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
キーサイズ(bit)
*private static readonly int KeySize = 256;
ブロックサイズ
*private static readonly int BlockSize = 128;
*{// AESオブジェクトを取得var aes = GetAesCng();// 対象の文字列をバイトデータに変換var byteValue = Encoding.UTF8.GetBytes(value);// バイトデータの長さを取得var byteLength = byteValue.Length;// 暗号化オブジェクトを取得var encryptor = aes.CreateEncryptor();// 暗号化return encryptor.TransformFinalBlock(byteValue, 0, byteLength);}
暗号化
AESオブジェクトを取得
*var aes = GetAesCng();
対象の文字列をバイトデータに変換
*var byteValue = Encoding.UTF8.GetBytes(value);
バイトデータの長さを取得
*var byteLength = byteValue.Length;
暗号化オブジェクトを取得
*var encryptor = aes.CreateEncryptor();
*return encryptor.TransformFinalBlock(byteValue, 0, byteLength);*}
暗号化
*{// AESオブジェクトを取得var aes = GetAesCng();// 復号化オブジェクトを取得var decryptor = aes.CreateDecryptor();// 復号化var decryptValue = decryptor.TransformFinalBlock(encryptValue, 0, encryptValue.Length);// 復号化されたバイトデータを文字列に変換var stringValue = Encoding.UTF8.GetString(decryptValue);return stringValue;}
復号化
AESオブジェクトを取得
*var aes = GetAesCng();
復号化オブジェクトを取得
*var decryptor = aes.CreateDecryptor();
*var decryptValue = decryptor.TransformFinalBlock(encryptValue, 0, encryptValue.Length);*// 復号化されたバイトデータを文字列に変換
復号化
復号化されたバイトデータを文字列に変換
*var stringValue = Encoding.UTF8.GetString(decryptValue);
*{// AESオブジェクトを生成し、パラメータを設定します。var aes = new AesCng();aes.KeySize = KeySize;aes.BlockSize = BlockSize;aes.Mode = CipherMode.CBC;aes.IV = Encoding.UTF8.GetBytes(AesIV);aes.Key = Encoding.UTF8.GetBytes(AesKey);aes.Padding = PaddingMode.PKCS7;return aes;}
AESオブジェクトを取得
AESオブジェクトを生成し、パラメータを設定します。
*var aes = new AesCng();
文字列を暗号化してファイルに書き出す
targetString 暗号化したい文字列
keyFilePath 暗号化した文字列を書き込むファイル
*public static void WriteAesEncryptedBytesToFile(string targetString, string keyFilePath)
暗号化されたファイルからキーを読を復号して返す
keyFilePath キーファイルパス
return ： 復号化された文字列
*public static string ReadAesEncryptedBytesFromFile(string keyFilePath)

*enemyEye = enemy.transform.Find("Face
Eye"); Enemyの子のFaceの子のEye
*if(Physics.Raycast(this.transform.position, new Vector3(-1f, 0f, 0f), out hit, 100f)){*Debug.Log(hit.transform.gameObject.name + "を検知");
自身の位置からx負の方向(←)にRaycastを発射。最大長さは100f

*{if (path.EndsWith(".txt")) { paths.Add(path); }};
txt パスをリストに追加する
各パスに対してやりたいこと
*Debug.Log(path);
末尾に \ が付くのを回避（★）
*var p = path + "/";

*{
PDFに直接変換したい画像ファイルを複数選択できるようにしている。
*if (fileDialog.ShowDialog() == DialogResult.OK)*{
「開く」ボタンが選択された時の処理
変換したい画像のリストを取得
string[] fileName = fileDialog.FileNames;  こんな感じで選択されたファイルのパスが取得できる
PDFは、今回は仮に、最初のファイルと同じフォルダに「test.pdf」として生成される。
*CreateODS cls = new CreateODS();
入力する文字を横着して、ここにて指定。
*cls.title_string = "ここにタイトル";
*cls.main_string =　new string[] { "以下、本文です", "今日は晴れ","湿度は高め", "温度も高め", "いわゆる猛暑日", "とても暑い","困ったものです", "しかし、", "これも夏", "楽しまねば"};
本文のところ。
おしまいのメッセージ
*MessageBox.Show("END");
さようなら
*Application.Exit();

*{
PDFに直接変換したい画像ファイルを複数選択できるようにしている。
*if (fileDialog.ShowDialog() == DialogResult.OK)*{
「開く」ボタンが選択された時の処理
変換したい画像のリストを取得
string[] fileName = fileDialog.FileNames;  こんな感じで選択されたファイルのパスが取得できる
PDFは、今回は仮に、最初のファイルと同じフォルダに「test.pdf」として生成される。
*clsPDF cls = new clsPDF();
おしまいのメッセージ
*MessageBox.Show("END");
さようなら
*Application.Exit();

*var playlistUrl = $"https:
www.youtube.complaylist?list={playlistId}";

処理中のメッセージは雑に全部これに表示します。
*[SerializeField] Text textBox;
*var request = new LoginWithCustomIDRequest { CustomId = "MyCustomId", CreateAccount = true };
PlayFabにいつも通りログインします。
ログインできたので続けてマッチングの処理を呼びます。
*Matchmaking();
*{// Entityは下記のコードで決め打ちで大丈夫です。Entity = new PlayFab.MultiplayerModels.EntityKey{Id = PlayFabSettings.staticPlayer.EntityId,Type = PlayFabSettings.staticPlayer.EntityType}};
プレイヤーの情報を作ります。
*{Id = PlayFabSettings.staticPlayer.EntityId,Type = PlayFabSettings.staticPlayer.EntityType}
Entityは下記のコードで決め打ちで大丈夫です。
先程作っておいたプレイヤー情報です。
*Creator = matchmakingPlayer,
マッチングできるまで待機する秒数を指定します。最大600秒です。
*GiveUpAfterSeconds = 30,
GameManagerで作ったキューの名前を指定します。
*QueueName = "1vs1Battle"
*{TicketId = result.TicketId,QueueName = request.QueueName};
キューに積んだチケットの状態をマッチングするかタイムアウトするまでポーリングします。
ポーリングは1分間に10回まで許可されているので、6秒間隔で実行するのがおすすめです。
*var seconds = 6f;
*{// Entityは下記のコードで決め打ちで大丈夫です。Entity = new PlayFab.MultiplayerModels.EntityKey{Id = PlayFabSettings.staticPlayer.EntityId,Type = PlayFabSettings.staticPlayer.EntityType},// これ以下を追記Attributes = new MatchmakingPlayerAttributes{// このプレイヤーは Rate 900～1100 のプレイヤーとしかマッチングしないDataObject = new { Rate = 1000 }}};
マッチングさせるプレイヤーの情報を作ります。
*{Id = PlayFabSettings.staticPlayer.EntityId,Type = PlayFabSettings.staticPlayer.EntityType},
Entityは下記のコードで決め打ちで大丈夫です。
*{// このプレイヤーは Rate 900～1100 のプレイヤーとしかマッチングしないDataObject = new { Rate = 1000 }}
これ以下を追記
*DataObject = new { Rate = 1000 }
このプレイヤーは Rate 900～1100 のプレイヤーとしかマッチングしない

*var response = s_webClient.UploadValues("https:
slack.comapichat.postMessage", "POST", data);

*lineRenderer.SetPosition(1, hitPos);
LineRendererの終点に当てはめる

*{return Task.FromResult(new HelloReply { Message = "Hello " + request.Name });}
Server side handler of the SayHello RPC

*myDataGrid.ColumnHeaderHeight = 20;
列ヘッダがある場合は適当な値を入れます
行数が5の場合
var hoge = 2;  行数で割るだけだとちょっとはみ出るので微調整
*myDataGrid.RowHeight = (myDataGrid.ActualHeight - myDataGrid.ColumnHeaderHeight) / 5 - hoge;

プロパティクラスが手元の環境にないため以下
*string line;

parent には子要素を調べたい親要素のAutomationElementを指定する。
たとえばRootElementとか･･･。
*var children = parent.FindAll(

インスタンス化
*var game = PrefabUtility.InstantiatePrefab(obj) as GameObject;
〜　処理　〜
プレファブ作成
*var prefab = PrefabUtility.SaveAsPrefabAsset(game, "Assets/prefab.prefab");
リンクを解除
*PrefabUtility.UnpackPrefabInstance(game, PrefabUnpackMode.OutermostRoot, InteractionMode.AutomatedAction);
シーンから削除
*Object.DestroyImmediate(game);

*MaxResultsCount = 11
自分と+-5位をあわせて合計11件を取得します。
*foreach (var item in leaderboardResult.Leaderboard)*{
実際は良い感じのランキングを表示するコードにします。
*Debug.Log($"{item.Position + 1}位: {item.DisplayName} - {item.StatValue}回");
Positionは順位です。0から始まるので+1して表示しています。

*if (fromDateTime <;= DateTime.MinValue &amp;&amp; toDateTime <;= DateTime.MinValue)*{
Set Date, if not set
*if (string.IsNullOrEmpty(token))*{
Token must be set first
*if (response.IsSuccessStatusCode)*{
Make sure the call was a success
*for (int i = 1; result.has_more; i++)*{
see if there are more
*if (response.IsSuccessStatusCode)*{
Make sure the code was a success

*if (Regex.IsMatch(org, @"^[\da-zA-Z]{4}-[\da-zA-Z]{4}-[\da-zA-Z]{4}-[\da-zA-Z]{4}\z"))*{
①4桁の英数字を-でつなげたものかどうかを判定
*var match = Regex.Match(org, @"[\da-zA-Z]{4}");
②4桁英数字にマッチしたものを探す
*var matches = Regex.Matches(org, @"[\da-zA-Z]{4}");
③4桁英数字にマッチしたものを全部探す

ストップウォッチを作成
*Stopwatch sw = new Stopwatch();
ストップウォッチをスタート
*sw.Restart();
測りたい処理
*Thread.Sleep(5000);
ストップウォッチを止める
*sw.Stop();
経過時間をsw.Elapsed や sw.ElapsedMilliseconds で取得
*Debug.WriteLine(" 経過時間：" + sw.ElapsedMilliseconds + " ms");

*var address = new EndpointAddress("net.tcp:
localhost:8808service");
*Console.WriteLine("SayHello() = {0}", IHelloWorldService);
サービス呼び出し

*writer.AddFrame(bmp);
フレームを追加

とりあえずそのまま返す
*return continuation(context);
*{// 書き込む前にintercept_interceptor(message as byte[]);return _baseStream.WriteAsync(message);}
キモの部分
書き込む前にintercept
*_interceptor(message as byte[]);
以下、インターフェースを満たすための実装
*public Task CompleteAsync() =>; _baseStream.CompleteAsync();
*{get{// 読み取る前にintercept_interceptor(_baseStream.Current as byte[]);return _baseStream.Current;}}
キモの部分
読み取る前にintercept
*_interceptor(_baseStream.Current as byte[]);
以下、インターフェースを満たすための実装
*public Task<;bool>; MoveNext(CancellationToken cancellationToken) =>; _baseStream.MoveNext(cancellationToken);
*{// 雑にJSON化Debug.Log(MessagePackSerializer.ToJson(data));}
差し込む処理の定義
雑にJSON化
*Debug.Log(MessagePackSerializer.ToJson(data));
自作Streamに差し替えたcallを返す
*return new AsyncDuplexStreamingCall<;TRequest, TResponse>;(
*{foreach (var method in typeof(THub).GetMethods()){_methodNameDic[FNV1A32.GetHashCode(method.Name)] = method.Name;}foreach (var method in typeof(TReceiver).GetMethods()){_methodNameDic[FNV1A32.GetHashCode(method.Name)] = method.Name;}}
メソッドIDからメソッド名への変換テーブルを用意
*{// 要素数を取得var readSize = 0;var length = MessagePackBinary.ReadArrayHeader(bytes, 0, out readSize);var offset = readSize;// 要素数4はエラー出力なので無視(!)if (length == 4) return;// 要素数3ならはじめはメッセージIDなので捨てるif (length == 3) offset += MessagePackBinary.ReadNext(bytes, offset);// メソッドID取得var methodId = MessagePackBinary.ReadInt32(bytes, offset, out readSize);offset += readSize;// 残りのデータをコピー(ToJsonにoffset渡したい…)var newBytes = BufferPool.Default.Rent();Array.Copy(bytes, offset, newBytes, 0, bytes.Length - offset);// 出力Debug.Log($"[{type}]{_methodNameDic[methodId]}: {MessagePackSerializer.ToJson(newBytes)}");BufferPool.Default.Return(newBytes);}
ログ出力処理本体
要素数を取得
*var readSize = 0;
*if (length == 4) return;*// 要素数3ならはじめはメッセージIDなので捨てる
要素数4はエラー出力なので無視(!)
*if (length == 3) offset += MessagePackBinary.ReadNext(bytes, offset);*// メソッドID取得
要素数3ならはじめはメッセージIDなので捨てる
メソッドID取得
*var methodId = MessagePackBinary.ReadInt32(bytes, offset, out readSize);
残りのデータをコピー(ToJsonにoffset渡したい…)
*var newBytes = BufferPool.Default.Rent();
*Debug.Log($"[{type}]{_methodNameDic[methodId]}: {MessagePackSerializer.ToJson(newBytes)}");
出力

*{var dir = Path.GetDirectoryName(path);if (!Directory.Exists(dir)){Directory.CreateDirectory(dir);}using (var fs = new FileStream(path, FileMode.Create))using (var sw = new StreamWriter(fs)){sw.Write(data);}}
文字列をファイルに書き込み
*{var dir = Path.GetDirectoryName(path);if (!Directory.Exists(dir)){Directory.CreateDirectory(dir);}// 簡素なやり方。第二引数をtrueにすると、同じファイルに追記できる)using (var sw = new StreamWriter(path, true)){sw.Write(data);}}
文字列をファイルに書き込み2
*{sw.Write(data);}
簡素なやり方。第二引数をtrueにすると、同じファイルに追記できる)
*{string data = string.Empty;if (File.Exists(path)){using (var fs = new FileStream(path, FileMode.Open))using (var sr = new StreamReader(fs)){data = sr.ReadToEnd();}}return data;}
文字列をファイルから読み込み
*{var dir = Path.GetDirectoryName(path);if (!Directory.Exists(dir)){Directory.CreateDirectory(dir);}using (var fs = new FileStream(path, FileMode.Create))using (var sw = new BinaryWriter(fs)){sw.Write(data);}}
バイナリデータをファイルに書き込み(書き込み先のフォルダがない場合は作成する)
*{if (File.Exists(path)){using (var fs = new FileStream(path, FileMode.Open))using (var sr = new BinaryReader(fs)){int len = (int)fs.Length;byte[] data = new byte[len];sr.Read(data, 0, len);return data;}}return null;}
バイナリデータをファイルから読み込み

*const int automationPropID_dgvCellValue = 30045;
地道な調査で突き止めたID。環境によって違ったりしたらごめんね。
GetCachedPropertyValue()てのもあって、気にはなるけどそっちを使うとInvalidOperationExceptionを投げられちゃう
*string cellValue = string.Empty;

*public HogeHubReceiver Receiver { get; } = new HogeHubReceiver();
さっき作ったやつ
DontDestroy化
*var gameObject = new GameObject("ConnectionHolder");
接続
*var holder = gameObject.AddComponent<;ConnectionHolder>;();

*{return $"[{d}]";});
匿名メソッド
*{return $"[{d}]";});
ラムダ式

*{Win,Lose,Draw}
勝敗の種類
*{Guu,Tyoki,Paa}
手の種類
*{// 勝敗を判定するResultKind Judge(HandKind myHand, IEnumerable<;HandKind>; otherHands);}
ジャンケンのルールを表すインターフェイス
勝敗を判定する
*ResultKind Judge(HandKind myHand, IEnumerable<;HandKind>; otherHands);
Enum名の省略
*using static Domain.HandKind;
*{// 勝敗を判定するpublic ResultKind Judge(HandKind myHand, IEnumerable<;HandKind>; otherHands){uint winCount = 0;uint loseCount = 0;foreach (var otherHand in otherHands){var resultKind = Judge(myHand, otherHand);if (resultKind == Win) winCount++;else if (resultKind == Lose) loseCount++;}if (winCount * loseCount != 0 || winCount + loseCount == 0) return Draw;if (winCount != 0) return Win;return Lose;}// 1対1の時の勝敗判定private ResultKind Judge(HandKind myHand, HandKind otherHand){if (myHand == otherHand) return Draw;if ((myHand == Guu &amp;&amp; otherHand == Paa) ||(myHand == Tyoki &amp;&amp; otherHand == Guu) ||(myHand == Paa &amp;&amp; otherHand == Tyoki))return Lose;return Win;}}
もっとも一般的なジャンケンのルール
*{uint winCount = 0;uint loseCount = 0;foreach (var otherHand in otherHands){var resultKind = Judge(myHand, otherHand);if (resultKind == Win) winCount++;else if (resultKind == Lose) loseCount++;}if (winCount * loseCount != 0 || winCount + loseCount == 0) return Draw;if (winCount != 0) return Win;return Lose;}
勝敗を判定する
*{if (myHand == otherHand) return Draw;if ((myHand == Guu &amp;&amp; otherHand == Paa) ||(myHand == Tyoki &amp;&amp; otherHand == Guu) ||(myHand == Paa &amp;&amp; otherHand == Tyoki))return Lose;return Win;}
1対1の時の勝敗判定
*{private readonly Rule rule;public HandKind Hand { get; }// ルールと出す手をセットpublic Human(Rule rule, HandKind hand){this.rule = rule;this.Hand = hand;}// 勝敗を知るpublic ResultKind KnowResult(Human<;Rule>;[] otherHumen)=>; rule.Judge(Hand, otherHumen.Select(x =>; x.Hand));}
ジャンケンをする人間を表す
*{this.rule = rule;this.Hand = hand;}
ルールと出す手をセット
勝敗を知る
*public ResultKind KnowResult(Human<;Rule>;[] otherHumen)
*{event Action<;string>; OnInput;// 入力を促すvoid ShowRequest();// 再入力を促すvoid ShowTryRequest();// 勝敗を出力するvoid ShowResult(string result, string myHand, IEnumerable<;string>; aiHands);}
ユーザーとのやりとりをするインターフェイス
入力を促す
*void ShowRequest();
再入力を促す
*void ShowTryRequest();
勝敗を出力する
*void ShowResult(string result, string myHand, IEnumerable<;string>; aiHands);
*{public event Action<;string>; OnInput;// 入力を促すpublic void ShowRequest(){Console.WriteLine("ジャンケンの手を選んでください（1=グー,2=チョキ,3=パー）");var input = Console.ReadLine();OnInput(input);}// 再入力を促すpublic void ShowTryRequest(){Console.WriteLine("もう一度入力してください");ShowRequest();}// 勝敗を出力するpublic void ShowResult(string result, string myHand, IEnumerable<;string>; aiHands){Console.WriteLine("あなた:" + myHand);foreach (var aiHand in aiHands)Console.WriteLine("AI:" + aiHand);Console.WriteLine("あなたは" + result + "です");}}
コンソールの入出力をするクラス
*{Console.WriteLine("ジャンケンの手を選んでください（1=グー,2=チョキ,3=パー）");var input = Console.ReadLine();OnInput(input);}
入力を促す
*{Console.WriteLine("もう一度入力してください");ShowRequest();}
再入力を促す
*{Console.WriteLine("あなた:" + myHand);foreach (var aiHand in aiHands)Console.WriteLine("AI:" + aiHand);Console.WriteLine("あなたは" + result + "です");}
勝敗を出力する
*{// 文字列をHandKindへ変換("1"=グー,"2"=チョキ,"3"=パー)static public HandKind? StringToHandKind(string consoleString){int result;if (int.TryParse(consoleString, out result) == false) return null;if (result <; 1 || result >; 3) return null;var handKinds = new HandKind[] { HandKind.Guu, HandKind.Tyoki, HandKind.Paa };return handKinds[result - 1];}// ResultKindを文字列へ変換static public string ResultKindToString(ResultKind resultKind){switch (resultKind){case ResultKind.Draw:return "引き分け";case ResultKind.Win:return "勝利";default:return "敗北";}}// ResultKindを文字列へ変換static public string HandKindToString(HandKind handKind){switch (handKind){case HandKind.Guu:return "グー";case HandKind.Tyoki:return "チョキ";default:return "パー";}}}
文字列と相互変換する
*{int result;if (int.TryParse(consoleString, out result) == false) return null;if (result <; 1 || result >; 3) return null;var handKinds = new HandKind[] { HandKind.Guu, HandKind.Tyoki, HandKind.Paa };return handKinds[result - 1];}
文字列をHandKindへ変換("1"=グー,"2"=チョキ,"3"=パー)
*{switch (resultKind){case ResultKind.Draw:return "引き分け";case ResultKind.Win:return "勝利";default:return "敗北";}}
ResultKindを文字列へ変換
*{switch (handKind){case HandKind.Guu:return "グー";case HandKind.Tyoki:return "チョキ";default:return "パー";}}
ResultKindを文字列へ変換
*{private readonly Random rand;public AiHumanCreator(Random rand) =>; this.rand = rand;// Aiの人間を複数生成するpublic Human<;Rule>;[] CreateAiHumen<;Rule>;(Rule rule, uint size) where Rule : IRule{var handKinds = new HandKind[] { HandKind.Guu, HandKind.Tyoki, HandKind.Paa };var aiHumen = new Human<;Rule>;[size];for (int i = 0; i <; aiHumen.Length; i++){var aiHandKind = handKinds[rand.Next(3)];aiHumen[i] = new Human<;Rule>;(rule, aiHandKind);}return aiHumen;}}
Aiの人間を生成するクラス
*{var handKinds = new HandKind[] { HandKind.Guu, HandKind.Tyoki, HandKind.Paa };var aiHumen = new Human<;Rule>;[size];for (int i = 0; i <; aiHumen.Length; i++){var aiHandKind = handKinds[rand.Next(3)];aiHumen[i] = new Human<;Rule>;(rule, aiHandKind);}return aiHumen;}
Aiの人間を複数生成する
*{// ジャンケンゲームを開始するpublic Game(IView view, AiHumanCreator aiHumanCreator){view.OnInput += input =>;{var handKind = StringConverter.StringToHandKind(input);if (handKind == null){view.ShowTryRequest();return;}var player = new Human<;StandardRule>;(new StandardRule(), (HandKind)handKind);var aiHumen = aiHumanCreator.CreateAiHumen(new StandardRule(), 2);view.ShowResult(StringConverter.ResultKindToString(player.KnowResult(aiHumen)),StringConverter.HandKindToString(player.Hand),aiHumen.Select(x =>; StringConverter.HandKindToString(x.Hand)));};view.ShowRequest();}}
ゲームを表す
*{view.OnInput += input =>;{var handKind = StringConverter.StringToHandKind(input);if (handKind == null){view.ShowTryRequest();return;}var player = new Human<;StandardRule>;(new StandardRule(), (HandKind)handKind);var aiHumen = aiHumanCreator.CreateAiHumen(new StandardRule(), 2);view.ShowResult(StringConverter.ResultKindToString(player.KnowResult(aiHumen)),StringConverter.HandKindToString(player.Hand),aiHumen.Select(x =>; StringConverter.HandKindToString(x.Hand)));};view.ShowRequest();}
ジャンケンゲームを開始する

アプリで保持すべき唯一のインスタンスをクラスフィールドとして保存
*private static MySingleton instance = new MySingleton();
*{Console.WriteLine("シングルトンの生成");}
コンストラクターをprivate宣言することで1度だけしかインスタンスが生成されない
*{get { return instance; }}
唯一のインスタンスを取得するプロパティ
インスタンスは1つしか生成されないため、dataの内容は「シングルトン１」となる
*Console.WriteLine(obj2.str);

*g.DrawRectangle(pen[i], rectClip[i]);
確認用
clipを元に戻す
*g.SetClip(rectDraw);
文字列の縁を描画する
*g.DrawPath(Pens.Black, gp);

*chart1.AddSeries(series2);
標準系列なのでchart1.Series.Add(series2)でもよい
*series1 = new ScrollSeries() { ChartType = SeriesChartType.Line, Color = Color.Yellow, BorderWidth = 2, UseXValue = true, MaxPoints = MAX_POINTS, SlicePoints = 10 };
X値を使用する例
*{var yValue = Math.Sin(Math.PI * (counter-6) / 6d) * 30;series1.AddScrollPoint(new DataPoint(0, yValue));series2.Points.Insert(0,new DataPoint(0, yValue));if(series2.Points.Count >; MAX_POINTS){series2.Points.RemoveAt(MAX_POINTS);}counter = (++counter) % 12;bool empty = rand.Next(0,10) == 0 ? false : true;series3.AddScrollPoint(new DataPoint(0, 5){ IsEmpty = empty});//chart1.Invalidate();  // chart1.AddSeriesの代わりにchart1.Series.Addを使用する場合}
100msごとに動作
chart1.Invalidate();   chart1.AddSeriesの代わりにchart1.Series.Addを使用する場合
*}

*if (Input.GetMouseButtonDown(0))*{
Click確認
*if (Input.GetMouseButtonDown(0))*{
Click確認
*if (Physics.Raycast(ray, out hit))*{
Collider objectの存在確認（RayHit)
*if (!isSelected)*{
非選択モードか確認
PieceAbstract objectか判定
*selectedPiece = clickedGameObject.FindInParents<;PieceAbstract>;();
選択状態をTrueに
*isSelected = true;
*{//  Tile objecetの判定if (clickedGameObject.gameObject.tag == "Tile"){// 既に駒が配置されていた場合は、その駒とswapif (clickedGameObject.HasChild()){foreach(Transform child in clickedGameObject.transform){//念のためPieceか確認if (child.HasComponent<;PieceAbstract>;()){swapPiece(child, selectedPiece);//Childは一つのはずだが、念のためBreakbreak;}}}//  tileにpieceObjectを配置else{setPiece(selectedPiece, clickedGameObject.transform);}// effect解除}else if(clickedGameObject.FindInParents<;PieceAbstract>;()){//swap処理swapPiece(selectedPiece, clickedGameObject.FindInParents<;PieceAbstract>;().transform);}// 選択状態をFalseにisSelected = false;selectedPiece = null;}
選択モードの場合
*if (clickedGameObject.gameObject.tag == "Tile")*{
Tile objecetの判定
*if (clickedGameObject.HasChild())*{
既に駒が配置されていた場合は、その駒とswap
*if (child.HasComponent<;PieceAbstract>;())*{
念のためPieceか確認
Childは一つのはずだが、念のためBreak
*break;
*{setPiece(selectedPiece, clickedGameObject.transform);}
tileにpieceObjectを配置
*else if(clickedGameObject.FindInParents<;PieceAbstract>;()){//swap処理swapPiece(selectedPiece, clickedGameObject.FindInParents<;PieceAbstract>;().transform);}
effect解除
*swapPiece(selectedPiece, clickedGameObject.FindInParents<;PieceAbstract>;().transform);*}
swap処理
選択状態をFalseに
*isSelected = false;
*{isSelected = false;selectedPiece = null;}
RayCastがhitしなかった場合
*piece.parent = tile.transform;*//TileObjectを親としたローカルポジションを設定
Pieceの親オブジェクトにTileを設定
TileObjectを親としたローカルポジションを設定
*piece.localPosition = new Vector3(0, 0, 0);
*Transform tile1 = piece1.parent;*Transform tile2 = piece2.parent;
各Pieceの親となるTileオブジェクトを見つける
親となるTileをそれぞれ入れかえ
*piece1.parent = tile2;
駒を新しい親Tileの場所に移動（Swap）
*piece2.localPosition = new Vector3(0, 0, 0);

*{/// <;summary>;/// <;see cref="Function{TDbContext}">;のテストクラス/// <;/summary>;public class FunctionTest : IClassFixture<;MyDbContextFixture>;, IDisposable{private readonly ITestOutputHelper _output;private readonly MyDbContextFixture _fixture;private readonly MyDBContextName _context;public FunctionTest(MyDbContextFixture fixture, ITestOutputHelper output){_output = output;_fixture = fixture;_context = fixture.Context;}// ご自身で引数のテストデータ作成します// DBに登録したいテストデータをいれます// GetTestData()/// <;summary>;/// テストデータを削除/// <;/summary>;void IDisposable.Dispose(){var list = _context.PrPrint.ToList<;PrPrint>;();_context.PrPrint.RemoveRange(list);_context.SaveChanges();}/// <;summary>;/// ステータスコードが60から70に更新/// <;/summary>;[Theory(DisplayName = "ステータスコード更新")][MemberData(nameof(MyTestDataName))]public void UpdateTest(inputModel){var function = new TestFunction<;MyDBContextName>;(_context);// テストデータをInsertvar list = GetTestData();_context.TestTable.AddRange(GetTestData());_context.SaveChanges();// テストしたい内容var result = function.Update_Test(inputModel);_output.WriteLine(JsonConvert.SerializeObject(result));var entity = _context.TestTable.Where(x =>; x.Id == result.Id).SingleOrDefault();// DBのステータスコードが70Assert.Equal("70", entity.StatusCd);}}}
テストしたいプロジェクトを参照するのを忘れずに
ご自身で引数のテストデータ作成します
DBに登録したいテストデータをいれます
GetTestData()
*void IDisposable.Dispose()
テストデータをInsert
*var list = GetTestData();
テストしたい内容
*var result = function.Update_Test(inputModel);
DBのステータスコードが70
*Assert.Equal("70", entity.StatusCd);
テストデータをInsert
*var list = GetTestData();

*{public double Hp;public double Mp;public double Atk;public Character(){this.Hp = 100;this.Mp = 100;this.Atk = 100;}// ステータスを取得(ダミー)public virtual string GetStatus(){return string.Empty;}}
基底クラス
*{return string.Empty;}
ステータスを取得(ダミー)
*{// 剣士のステータスを取得public override string GetStatus(){this.Hp = this.Hp * 1.5;this.Mp = this.Mp * 0.5;this.Atk = this.Atk * 2;return $"剣士のステータスはHP:{this.Hp},MP:{this.Mp},ATK:{this.Atk}です";}}
派生クラス(剣士)
*{this.Hp = this.Hp * 1.5;this.Mp = this.Mp * 0.5;this.Atk = this.Atk * 2;return $"剣士のステータスはHP:{this.Hp},MP:{this.Mp},ATK:{this.Atk}です";}
剣士のステータスを取得
*{// 魔法使いのステータスを取得public override string GetStatus(){this.Hp = this.Hp * 1.3;this.Mp = this.Mp * 2;this.Atk = this.Atk * 0.5;return $"魔法使いのステータスはHP:{this.Hp},MP:{this.Mp},ATK:{this.Atk}です";}}
派生クラス(魔法使い)
*{this.Hp = this.Hp * 1.3;this.Mp = this.Mp * 2;this.Atk = this.Atk * 0.5;return $"魔法使いのステータスはHP:{this.Hp},MP:{this.Mp},ATK:{this.Atk}です";}
魔法使いのステータスを取得
*{Console.WriteLine(c.GetStatus());}
キャラのステータス表示メソッド
抽象メソッド
*public abstract string GetStatus();
*{string GetStatus();}
インターフェース

*var wordList=words.Replace("\r\n","\n").Split(new[]{'\n','\r'});
using System;
1000000ループの処理時間: 474ms(csc/.NET Framework)
*,,,
*var wordList=words.Split(new[]{"\r\n","\n","\r"},StringSplitOptions.None);
using System;
1000000ループの処理時間: 504ms(csc/.NET Framework)
*,,,

Animalを基底クラス、親クラス、スーパークラスと呼ぶ
Catを派生クラス、子クラス、サブクラスと呼ぶ
*}
*{public string Kind;public string Cry;public string Show(){return $"{this.Kind}";}}
親クラス
*{public string Name;// 子クラス独自のメソッドを定義可能public string GetCry(){// 親クラスの変数が利用可能return $"{this.Kind}は{this.Cry}と鳴く";}}
子クラス
*{// 親クラスの変数が利用可能return $"{this.Kind}は{this.Cry}と鳴く";}
子クラス独自のメソッドを定義可能
*return $"{this.Kind}は{this.Cry}と鳴く";
親クラスの変数が利用可能
親クラスで定義されたShowメソッドを
子クラスのメンバーであるかのように呼び出せる
*Console.WriteLine(cat.Show());
*{return $"{this.Kind}の{this.Name}";}
親クラスのShowメソッドを隠蔽
*{public string Name { get;}public string Kind { get;}public Animal(string name, string kind){Name = name;Kind = kind;}public virtual string Show()=>; $"{this.Kind}の{this.Name}";}
親クラス
*{public int Age { get; }public Cat(string name, string kind, int age) : base(name, kind){Age = age;}public override string Show(){if (Age <; 1){return $"{this.Kind}の赤ちゃんの{this.Name}";}else{return base.Show();}}}
子クラス
*{public Animal(){Console.WriteLine("動物");}}
親クラス
*{public Cat(){Console.WriteLine("猫");}}
子クラス
*{public Animal(string str){Console.WriteLine($"動物が{str}です");}}
親クラス
*{public Cat(string str) : base(str){Console.WriteLine($"猫が{str}です");}}
子クラス
*{}
親クラス
*{}
子クラス

*} else if (File.Exists (sourcePath)) {
Mac, Windows, iPhone

*void next(){if(getPageCount >; openingPage){openingPage++;}}
...
クラス内部で扱われる変数
*private int num = 10;
*public int Num{// 代入される時set{ this.num = value;}// 値を読まれる時get{ return num;}}
R/Wできるプロパティ
*set{ this.num = value;}
代入される時
*get{ return num;}
値を読まれる時
*public string Message{get{ return message; }}
Read onlyなプロパティ
numの読み書き
*var a = instance.Num;
messageの読み書き
*var msg = instance.Message;
pagesをいい感じになんかしたとして...
*var book = new Book("不思議の国のアリス", pages);
プロパティにする前
*var readingPage = book.getPage();
プロパティにしたあと
*var readingPage = book.page;

*.UseAutofacContainerBuilder(containerBuilder)
Must be the first line!
*.AddEvents(new[] {typeof(利用者を登録した),typeof(本を登録した),typeof(本を借りた),typeof(本を返した),typeof(本を破棄した),})
.RunBootstrapperOnHostStartup()
*//.Configure((JsonSerializerSettings s) =>; { })
.AddConverter&lt;SingleValueObjectConverter&gt;()

特殊ディレクトリのパスを取得
*string documentPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
サブディレクトリ含めてパスを全部見る。丸裸よ。
*string documents = Directory.EnumerateFiles(documentFilePath, "*", SearchOption.AllDirectories);

何らかの取得処理の呼び出し
*return "ExampleMemberInfo";
更新処理の呼び出し
*}
何らかの取得処理の呼び出し
*return "ExampleMemberInfo";
更新処理の呼び出し
*}
何らかの取得処理の呼び出し
*return "ExampleMemberInfo";
更新処理の呼び出し
*}

ifでどちらかのyield
*yield return hogehoge(data2);
ちゃんと帰りましょう
*continue;
null不要ならそのままcontinue;
*continue;
1行で表現したり
*yield return data2 == null ? null : hogehoge(data2);

*ProcessStartInfo processStartInfo = new ProcessStartInfo("C:\\Program Files (x86)\\Internet Explorer\\iexplore.exe", "http:
yahoo.co.jp");

*{using (var ofd = new OpenFileDialog() { FileName = "SelectFolder", Filter = "Folder|.", CheckFileExists = false }){if (ofd.ShowDialog() == DialogResult.OK){Console.WriteLine(Path.GetDirectoryName(ofd.FileName));}}}
using System.IO;

*private Action sFunc[];
スキルの関数を格納する配列

デフォルト引数を書いていないこのコードは
*var taxIncludedPrice = CommonLib.CalcTaxIncludedPrice(100);
コンパイル時にこのようなコードに解釈される
*var taxIncludedPrice = CommonLib.CalcTaxIncludedPrice(100, 1.08M);
*{return price * rate;}
オーバーロードして利率を渡せるバージョンのメソッドを作る
*{return CalcTaxIncludedPrice(price, 1.08M);}
元のメソッドはオーバーロードしたメソッドを呼び出すようにする

*if (pointList.Corners.Length <; 5) return null;
そもそも頂点が足りない

処理
*}

*{Component[] components = GetComponentsInChildren<;Component>;();foreach(Component component in components){if (component.GetType().Name == componentName){DestroyImmediate(component);}}}
コンポーネントを取得して該当コンポーネントを削除
押下時に実行したい処理
*rootClass.GetComAndDes();
*{Component[] components = GetComponentsInChildren<;Component>;();foreach(Component component in components){if (component.GetType().Name == componentName){DestroyImmediate(component);}}}
コンポーネントを取得して該当コンポーネントを削除

*{return $"{GetType()}: {Message}" + Environment.NewLine + $"MyProperty: {MyProperty}";}
EVIL code
*{return base.ToString() + Environment.NewLine + $"MyProperty: {MyProperty}";}
Not good
MyPropertyに1, Messageに"this is an example."を指定
*throw new MyException(1, "this is an example.");
*{get{return base.Message + Environment.NewLine + $"MyProperty: {MyProperty}";}}
Good
MyPropertyに1, Messageに"this is an example."を指定
*throw new MyException(1, "this is an example.");

*Transform SenderAnchor;*// 共有したい座標
送信側のアンカー
共有したい座標
*var worldPosition = ts.position;
*var relativePosition = SenderAnchor.transform.worldToLocalMatrix.MultiplyPoint3x4(worldPosition);*,,,
アンカーからの相対座標に変換します
*Transform ReceiverAnchor;*// 受け取り側のPositionに復元します
受信側のアンカー
*var local = ReceiverAnchor.transform.localToWorldMatrix.MultiplyPoint3x4(relativePosition);*,,,
受け取り側のPositionに復元します
共有したい姿勢
*var worldRotation = ts.rotation;
*var relativeRotation = Quaternion.Inverse(SenderAnchor.transform.rotation) * worldRotation;*,,,
アンカーからの相対角度に変換します
*var local = ReceiverAnchor.transform.rotation * relativeRotation;*,,,
受け取り側のRotationに復元します
送信側のアンカー
*[SerializeField] private GameObject SenderAnchor;
送信側の子
*[SerializeField] private GameObject SenderChild;
受信側のアンカー
*[SerializeField] private GameObject ReceiverAnchor;
受信側の子
*[SerializeField] private GameObject ReceiverChild;
てきとうにカラーリング
*o.GetComponent<;Renderer>;().material.color = UnityEngine.Random.ColorHSV();
*SenderAnchor.transform.SetPositionAndRotation(UnityEngine.Random.onUnitSphere, UnityEngine.Random.rotation);*ReceiverAnchor.transform.SetPositionAndRotation(UnityEngine.Random.onUnitSphere + new Vector3(7, 0, 0), UnityEngine.Random.rotation);
アンカーをランダムな位置に配置
*SenderChild.transform.position = UnityEngine.Random.onUnitSphere * 2;*SenderChild.transform.rotation = UnityEngine.Random.rotation;
送信側の子オブジェクトをランダムな位置に配置
*var ts = SenderChild.transform;*var (sendP, sendQ) = WorldToRelative(SenderAnchor.transform, ts.position, ts.rotation);
送信側のワールド座標からアンカーからの相対座標に変換
*var (receiveP, receiveQ) = RelativeToWorld(ReceiverAnchor.transform, sendP, sendQ);*ReceiverChild.transform.SetPositionAndRotation(receiveP, receiveQ);
アンカーからの相対座標を受信側のアンカーに依るワールド座標に変換
*SenderAnchor.transform.SetPositionAndRotation(Vector3.zero, Quaternion.identity);*ReceiverAnchor.transform.SetPositionAndRotation(Vector3.zero, Quaternion.identity);
アンカー同士の位置を揃えることで子オブジェクトの位置が揃っていることを確認する

クリーニング店
*Cleaners cleaners = new Cleaners();
行きつけのクリーニング店のある顧客
*Customer custmer = new Customer(cleaners);
回数券を買う
*custmer.BuyCouponTicket();
服を汚す
*custmer.StockDirtyLaundry();
クリーニング店に行く
*custmer.GoCleaners();
*{// 行きつけのクリーニング店のある顧客public Customer(Cleaners regularCleaners){RegularCleaners = regularCleaners;CleanLaundry.Add(new Clothes("T-Shirt"));CleanLaundry.Add(new Clothes("Jacket"));}// 汚れた洗濯物public List<;Clothes>; DirtyLaundry { get; } = new List<;Clothes>;();// 回数券private Queue<;Coupon>; CouponTicket { get; } = new Queue<;Coupon>;();// 行きつけのクリーニング店private Cleaners RegularCleaners = null;// きれいな洗濯物public List<;Clothes>; CleanLaundry { get; } = new List<;Clothes>;();// 汚れものを貯めるpublic void StockDirtyLaundry(){// きれいな洗濯物をひとつ取り出して、Clothes clothes = CleanLaundry[0];CleanLaundry.RemoveAt(0);// その洗濯物を、汚れた洗濯物にするclothes.Dirty = true;DirtyLaundry.Add(clothes);}// 回数券を買うpublic void BuyCouponTicket(){// お金は払ってないけれど、省略しているだけCouponTicket.Enqueue(new Coupon());}// クリーニング店に行くpublic void GoCleaners(){// 行きつけのクリーニング店.洗濯する(汚れた洗濯物,回数券);List<;Clothes>; clothes = RegularCleaners.Wash(DirtyLaundry, CouponTicket.Dequeue());// 仕上り品としてしまうCleanLaundry.AddRange(clothes);}}
顧客
*{RegularCleaners = regularCleaners;CleanLaundry.Add(new Clothes("T-Shirt"));CleanLaundry.Add(new Clothes("Jacket"));}
行きつけのクリーニング店のある顧客
*public List<;Clothes>; DirtyLaundry { get; } = new List<;Clothes>;();
汚れた洗濯物
*private Queue<;Coupon>; CouponTicket { get; } = new Queue<;Coupon>;();
回数券
行きつけのクリーニング店
*private Cleaners RegularCleaners = null;
*public List<;Clothes>; CleanLaundry { get; } = new List<;Clothes>;();
きれいな洗濯物
*{// きれいな洗濯物をひとつ取り出して、Clothes clothes = CleanLaundry[0];CleanLaundry.RemoveAt(0);// その洗濯物を、汚れた洗濯物にするclothes.Dirty = true;DirtyLaundry.Add(clothes);}
汚れものを貯める
きれいな洗濯物をひとつ取り出して、
*Clothes clothes = CleanLaundry[0];
その洗濯物を、汚れた洗濯物にする
*clothes.Dirty = true;
*{// お金は払ってないけれど、省略しているだけCouponTicket.Enqueue(new Coupon());}
回数券を買う
お金は払ってないけれど、省略しているだけ
*CouponTicket.Enqueue(new Coupon());
*{// 行きつけのクリーニング店.洗濯する(汚れた洗濯物,回数券);List<;Clothes>; clothes = RegularCleaners.Wash(DirtyLaundry, CouponTicket.Dequeue());// 仕上り品としてしまうCleanLaundry.AddRange(clothes);}
クリーニング店に行く
行きつけのクリーニング店.洗濯する(汚れた洗濯物,回数券);
*List<;Clothes>; clothes = RegularCleaners.Wash(DirtyLaundry, CouponTicket.Dequeue());
仕上り品としてしまう
*CleanLaundry.AddRange(clothes);
*{// 洗濯するpublic List<;Clothes>; Wash(List<;Clothes>; clothes,Coupon coupon){// 回数券クーポンを破棄し// (略)// 洗濯するforeach(Clothes oneClothes in clothes){oneClothes.Dirty = false;}// 返却するreturn clothes;}}
クリーニング店
*{// 回数券クーポンを破棄し// (略)// 洗濯するforeach(Clothes oneClothes in clothes){oneClothes.Dirty = false;}// 返却するreturn clothes;}
洗濯する
回数券クーポンを破棄し
(略)
洗濯する
*foreach(Clothes oneClothes in clothes)
返却する
*return clothes;

*if (policyResult.FinalException is SqlException)*{
実行に失敗した
FinalException に例外が格納されている
*}

_size フィールドを取得
*var size = type.GetField("_size", BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);
_size フィールドに capacity を書き込む
*size.SetValue(ls, capacity);
var normal = new List&lt;int&gt;(100);  普通に new すると...
normal[50] = 200;                 System.ArgumentOutOfRangeException で死ぬ
Console.WriteLine(normal[50]);
var ls = GenerateList&lt;int&gt;(100);     GenerateList&lt;T&gt; を使えば、
ls[50] = 200;                        アクセスできる！！
Console.WriteLine(ls[50]);           output: 200
*}
ここで各要素を初期化.
※ C/C++ のネイティブ関数をコールすれば高速化できそう...
*for (int i = 0; i <; capacity; i++)
_size フィールドを取得
*var size = type.GetField("_size", BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);
_items フィールドを取得
*var items = type.GetField("_items", BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);
_size フィールドに capacity を書き込む
*size.SetValue(ls, capacity);
_items フィールドに ary を書き込む
*items.SetValue(ls, ary);
*{var (start, end) = partition;for (int i = start; i <; end; i++)ary[i] = value;});
チャンク分けしてあげる
*{var (start, end) = partition;for (int i = start; i <; end; i++)ary[i] = generator(i);});
チャンク分けしてあげる
空配列で初期化させる.
capacity を指定すると, 余計な new が発生する.
*var ls = new List<;T>;();

ルームは全員固定
*const string roomName = "SampleRoom";
ルームに参加&amp;ルームを保持
*this.room = await this.Group.AddAsync(roomName);
自分の情報も保持
*me = player;
参加したことをルームに参加している全メンバーに通知
*this.Broadcast(room).OnJoin(me.Name);
ルーム内のメンバーから自分を削除
*await room.RemoveAsync(this.Context);
退室したことを全メンバーに通知
*this.Broadcast(room).OnLeave(me.Name);
発言した内容を全メンバーに通知
*this.Broadcast(room).OnSendMessage(me.Name, message);
サーバー上の情報を更新
*me.Position = position;
更新したプレイヤーの情報を全メンバーに通知
*this.Broadcast(room).OnMovePosition(me);
普通の API の呼び出しはコメントアウトしておきます
残しておいても問題はないです（リアルタイム通信と両方動きます）
this.SampleServiceTest(1, 2);
*this.SampleHubTest();
*{Name = "Minami",Position = new Vector3(0, 0, 0),Rotation = new Quaternion(0, 0, 0, 0)};
自分のプレイヤー情報を作ってみる
ゲームに接続する
*await this.sampleHub.JoinAsync(player);
チャットで発言してみる
*await this.sampleHub.SendMessageAsync("こんにちは！");
位置情報を更新してみる
*player.Position = new Vector3(1, 0, 0);
ゲームから切断してみる
*await this.sampleHub.LeaveAsync();
Pathの「Sample.Server」と「Sample.Server.csproj」は実際のものに書き換えてください
*};

衝突時にobjectを回転させない設定
*this.rigidBody.constraints = RigidbodyConstraints2D.FreezeRotation;
入力を取得
*input = new Vector2(
既存のポジションに対して、移動量(vector)を加算する
*rigidBody.position += input * SPEED;

*G = 0.98f
12.0f;  重力
*void Update () {PlayerAction();}
Update is called once per frame
*if (!x)*{
画面移動
*if ((transform.position.x >; mainCamera.transform.position.x - 4) &amp; (transform.position.x <;= mainCamera.transform.position.x - 8))*{
カメラ移動処理
*{A -= G;//PosY += Acc;//if (PosY <; 0.0f) // 0.0は地面if(A <; 0.0f){// 着地A = 0.0f;}return A;}
ジャンプ中
*//if (PosY <; 0.0f) // 0.0は地面*if(A ; 0.0f)
PosY += Acc;
*if(A <; 0.0f)*{
if (PosY &lt; 0.0f)  0.0は地面
着地
*A = 0.0f;
右・左
*bool x = false;
*if (transform.position.y <;= 0 || status == Status.jump)*{
bool y = false;
*if (timeScript.countTime <;= flgTime &amp;&amp; resultScript.playerLife >; 0 &amp;&amp; transform.position.y >;= -6.0f)*{
上・下
*if (status == Status.jump)*{
y = false;
*if (x)*{
アニメーション分岐
*if (x == true)*{
キャラクター反転
右向き
*scale.x = 4;
左向き(反転)
*scale.x = -4;
*transform.localScale = scale;*float a, b;
代入しなおす
速度をクリアした2回目のジャンプも1回目と同じ挙動にする。
*rigidbody2D.velocity = Vector2.zero;
移動する向きを決める
*Vector2 direction = new Vector2(a, b);
移動する向きとスピードを代入する
*GetComponent<;Rigidbody2D>;().velocity = 2.1f * direction * speed;

*enum E{}
OK シリアライズされる
*// Unsupported enum type 'BattlePlayer.Type' used for field 'type' in class 'BattlePlayer'*enum L : long {}
シリアライズされない
*enum L : long {}
Unsupported enum type 'BattlePlayer.Type' used for field 'type' in class 'BattlePlayer'

*{m_isPointing = !OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, m_controller);m_isGivingThumbsUp = !OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, m_controller);}
debouncing.

ラムダ式
*static public Func<;int, int>; func = x =>; x * 10;

*if (lang == Tweetinvi.Models.Language.Japanese &amp;&amp; args.Tweet.Source.Contains(">;Twitter "))*{
Specify Japanese &amp; Remove bot tweets
*{var lang = args.Tweet.Language;// Specify Japanese &amp; Remove bot tweetsif (lang == Tweetinvi.Models.Language.Japanese &amp;&amp; args.Tweet.Source.Contains(">;Twitter ")){Console.WriteLine("----------------------------------------------------------------------");Console.WriteLine($"** CreatedAt : {args.Tweet.CreatedAt}");Console.WriteLine($"** CreatedBy : {args.Tweet.CreatedBy}");Console.WriteLine($"** Source    : {args.Tweet.Source}");Console.WriteLine($"** Text      : {args.Tweet.Text}");}++counter;if (counter >;= maxCount){stream.Stop();}};
Read stream
*if (lang == Tweetinvi.Models.Language.Japanese &amp;&amp; args.Tweet.Source.Contains(">;Twitter "))*{
Specify Japanese &amp; Remove bot tweets

Formへの参照。
このクラス内でのFormへはdynamic型経由でアクセスしているため、
コントロール名やメソッド名が変わったらここでアクセスする名前も変更しなければいけないことに注意
*private dynamic targetForm;
テスト対象のパスを取得
*var path = System.IO.Path.GetFullPath("TestTarget.exe");
テスト対象のプロセスを開始し、WindowsAppFriendでプロセスへアタッチ
*var app = new WindowsAppFriend(Process.Start(path));
メインフォームへの参照を取得
*targetForm = app.Type(typeof(Application)).OpenForms[0];
*{return (bool)targetForm.execute_button.Enabled;}
Executeボタンの有効/無効状態の取得するヘルパー
*{return (string)targetForm.result_textBox.Text;}
Statusテキストボックスのテキストの取得するヘルパー
*{targetForm.Execute_button_Click(null, null);}
Executeボタンの押下を実行するヘルパー
*{targetForm.Close();}
フォームを閉じるヘルパー
起動直後は起動中状態であることを確認
*Assert.AreEqual(false, helper.IsExecute_button_Enable());
起動完了待ち
*Thread.Sleep(1500);
起動完了後のステータス確認
*Assert.AreEqual(true, helper.IsExecute_button_Enable());
実行ボタン押下
*helper.PushExecute();
実行直後のステータス確認
*Assert.AreEqual(false, helper.IsExecute_button_Enable());
実行完了待ち
*Thread.Sleep(1500);
実行完了後のステータス確認
*Assert.AreEqual(true, helper.IsExecute_button_Enable());

*var api = RestService.For<;IGitHubApi<;("https:
api.github.com", new RefitSettings

*.Do(i =>; Console.WriteLine("Do : {0}", i))
途中に処理を挟む
*.Subscribe(i =>; Console.WriteLine("OnNext : {0}", i));
購読(購読しないとOnNextをしても値が流れないね)
値の発行
*subject.OnNext(1);
正常終了する場合
実行結果：1, 2, 3, 4, 5, Completed
*Observable.Range(1, 5)
途中で例外が発生する場合
実行結果：1, 2, Error
*Observable.Range(1, 5)

*a[i] = i;
a[i]に対する任意の処理
方法1
*[Benchmark]
方法2
*[Benchmark]
方法3
*[Benchmark]
方法4
*[Benchmark]

参考：https:www.gesource.jp/weblog/?p=7742
*[TestClass]
publicなメソッドのテスト
*ret = cls1.AddPublic(1, 2);
private、internalなメソッドのテスト
*var pbObj = new PrivateObject(cls1);
private static、internal staticなメソッドのテスト
*PrivateType privateType = new PrivateType(typeof(Class1));
子クラスから見た親クラスのprivateメソッドをテスト
*var clssub = new Class1Sub();
子クラスから見た親クラスのprivate staticメソッドは、
親クラスのprivate staticテストと同じ。
*}

*namespace Sample {class C {static void Main(){Thread thread = new Thread(ThreadWork);thread.Start();Console.WriteLine("キー入力があるまでスレッドが動き続ける");Console.ReadKey();// スレッドを止める(スレッドが止まっている可能性がある場合は// IsAliveプロパティがtrueか確かめる)thread.Abort();}// スレッドを用いて動かすメソッドstatic void ThreadWork(){while(true) {Console.WriteLine("ThreadWork内の処理");Thread.Sleep(2000);}}}}
ThreadクラスはSystem.Threading名前空間に存在
スレッドを止める(スレッドが止まっている可能性がある場合は
IsAliveプロパティがtrueか確かめる)
*thread.Abort();
*{while(true) {Console.WriteLine("ThreadWork内の処理");Thread.Sleep(2000);}}
スレッドを用いて動かすメソッド
*namespace Sample {class C {static void Main(){Task task = new Task(ThreadWork);task.Start();Console.WriteLine("キー入力があるまでスレッドが動き続ける");Console.ReadKey();// Mainメソッドが終了すると自動でTaskが終了する}// スレッドを用いて動かすメソッドstatic void ThreadWork(){while(true) {Console.WriteLine("ThreadWork内の処理");Thread.Sleep(2000);}}}}
TaskクラスはSystem.Threading.Tasks名前空間に存在
Mainメソッドが終了すると自動でTaskが終了する
*}
*{while(true) {Console.WriteLine("ThreadWork内の処理");Thread.Sleep(2000);}}
スレッドを用いて動かすメソッド
*namespace Sample {class C {static void Main(){// Task.Run(Action)とTask.Run(Func<;Task>;)で競合が起こるので、明示的にActionにするTask.Run((Action)ThreadWork);Console.WriteLine("キー入力があるまでスレッドが動き続ける");Console.ReadKey();}// スレッドを用いて動かすメソッドstatic void ThreadWork(){while(true) {Console.WriteLine("ThreadWork内の処理");Thread.Sleep(2000);}}}}
TaskクラスはSystem.Threading.Tasks名前空間に存在
Task.Run(Action)とTask.Run(Func&lt;Task&gt;)で競合が起こるので、明示的にActionにする
*Task.Run((Action)ThreadWork);
*{while(true) {Console.WriteLine("ThreadWork内の処理");Thread.Sleep(2000);}}
スレッドを用いて動かすメソッド
*namespace Sample {class C {static void Main(){Parallel.For(0, 10, id =>; {Console.WriteLine($"並列で動作している部分\t id = {id}");});Console.WriteLine("並列処理終了!");}}}
ParallelクラスはSystem.Threading.Tasks名前空間に存在
*namespace Sample {class C {static void Main(){int[] arr = { 10, 20, 30, 40, 50, 60, 70, 80, 90 };Parallel.ForEach(arr, item =>; {Console.WriteLine($"並列で動作している部分\t item = {item}");});Console.WriteLine("並列処理終了!");}}}
ParallelクラスはSystem.Threading.Tasks名前空間に存在

対象のメソッド呼び出し
*}

*if (lang.ToLower() == "ja")
Display only Japanese tweets

*[ContentProperty("Key")]
Keyを規定のプロパティに指定
Keyプロパティに指定されたキーをもとにリソースから文字列を取得
*return AppResources.ResourceManager.GetString(Key, AppResources.Culture) ?? Key;
日本語を指定する場合
*AppResources.Culture =  new CultureInfo("ja-JP");
英語を指定する場合
*AppResources.Culture =  new CultureInfo("en-US");
*{public static void SetCulture(CultureInfo culture){AppResources.Culture = culture;}...}
共通プロジェクトのAppクラスでAppResoucesのカルチャを設定するメソッドを追加
*public class MainActivity : global::Xamarin.Forms.Platform.Android.FormsAppCompatActivity*{
AndroidプロジェクトのMainActivityクラスでプラットフォームの言語を元にカルチャを設定
Androidプラットフォームでの言語を取得
*var androidLocale = Java.Util.Locale.Default;
ja_JP を ja-JP に変換
*string netLanguage = androidLocale.ToString().Replace("_", "-");
プラットフォームが日本語ならばカルチャを日本語、それ以外ならカルチャを英語とする
*var culture = (netLanguage == "ja" || netLanguage == "ja-JP")
カルチャを設定する
*App.SetCulture(culture);

Console.WriteLine("マウスのXBUTTON2が押されています。");
*}
*if ((cp.X <; 0 || this.Width <; cp.X ) &amp;&amp; (cp.Y <; 0 || this.Height <; cp.Y) )*{
Console.WriteLine(cp.X.ToString() + " " + cp.Y.ToString());
フォームを表示する
*this.Visible = true;
*if (this.WindowState == FormWindowState.Minimized)*{
現在の状態が最小化の状態であれば通常の状態に戻す
フォームをアクティブにする
*new Thread(new ThreadStart(GetMouseButton)).Start();

*while(Working)*{
稼動中繰り返す
*{case 0://処理開始System.Console.WriteLine("処理開始");break;case 1://更新開始System.Console.WriteLine("更新開始");break;case 6:System.Console.WriteLine("ここにはこない");break;default://値が上限まで達したかif(Value >;= 5){//更新終了System.Console.WriteLine("更新終了");//処理終了とするWorking = false;}break;}
値を判断
処理開始
*System.Console.WriteLine("処理開始");
更新開始
*System.Console.WriteLine("更新開始");
*if(Value >;= 5)*{
値が上限まで達したか
更新終了
*System.Console.WriteLine("更新終了");
処理終了とする
*Working = false;
手書き--ここから
args[0]:dotファイル（トレース結果）出力先
*static void Main(string[] args)
*{Trace.TraceNode("node1", true);Trace.TraceNode("node2");var t = Task.Run(async () =>;{//稼動中繰り返すTrace.TraceNode("node3");while (Working){//値を判断Trace.TraceNode("node3");Trace.TraceNode("node4");switch (Value)//省略}public FlowTrace Trace = new FlowTrace();public void InitGraph(){Trace.AddFunc(0);Trace.AddNode(0, "node1", "ellipse", "DoJob\nstart");//省略Trace.AddEdge("node1", "node2", "");Trace.AddEdge("node4", "node5", "case 0:");//省略},,,using System.Linq;using Microsoft.CodeAnalysis.CSharp;using Microsoft.CodeAnalysis.CSharp.Syntax;using System.Text;using System.Text.RegularExpressions;using System.Collections.Generic;using Microsoft.CodeAnalysis;using System.IO;namespace Flow{public class FlowGraph{private static int WORD_WRAP_LENGTH = 40;private List<;GraphEdge>; EdgeList = new List<;GraphEdge>;();private Dictionary<;SyntaxNode, GraphNode>; NodeMap = new System.Collections.Generic.Dictionary<;SyntaxNode, GraphNode>;();private IEnumerable<;BaseMethodDeclarationSyntax>; memberDeclarations;private string _sourceCode;private int _seq = 0;//args[0]:対象c#ソースファイル//args[1]:dotファイル（静的フローチャート）出力先//args[2]:変換後ソース（トレース用コード）出力先static void Main(string[] args){string sourceCode = File.ReadAllText(args[0]);FlowGraph graph = new FlowGraph(sourceCode);//静的フロー出力graph.WriteDot(args[1]);//ソースコード変換graph.ConvSource(args[2]);}public FlowGraph(string sourceCode){_sourceCode = sourceCode;var tree = CSharpSyntaxTree.ParseText(_sourceCode);memberDeclarations = tree.GetRoot().DescendantNodes().OfType<;BaseMethodDeclarationSyntax>;();if(memberDeclarations.Count() == 0){return;}foreach (var funcRoot in memberDeclarations){SyntaxVisitor ast = new SyntaxVisitor(this);if (funcRoot is MethodDeclarationSyntax || funcRoot is ConstructorDeclarationSyntax)ast.VisitRootSyntax(funcRoot);}}//トレース用のソースコード出力public void ConvSource(string outFile){var result = _sourceCode;var keys = new List<;SyntaxNode>;(NodeMap.Keys).OrderByDescending(x =>; x.Span.Start);AddInitStatements(ref result, memberDeclarations.Last());foreach (var sNode in keys){AddTraceStatement(ref result, NodeMap[sNode], sNode);}using (System.IO.StreamWriter writer = new System.IO.StreamWriter(outFile, false)){writer.Write(result);}}//ノード、エッジ登録関数部作成private void AddInitStatements(ref string result, SyntaxNode lastMetod){var clustermap = new Dictionary<;SyntaxNode, int>;();int ipoint = lastMetod.FullSpan.End;string spaces = new string(' ', lastMetod.GetLocation().GetLineSpan().StartLinePosition.Character);var sb = new StringBuilder();sb.Append("\r\n" + spaces + "public FlowTrace Trace = new FlowTrace();\r\n");sb.Append(spaces + "public void InitGraph()\r\n");sb.Append(spaces + "{\r\n");//クラスタIDを追加するstring spaces2 = new string(' ', spaces.Length + 4);int cluster = 0;foreach (var funcRoot in memberDeclarations){sb.Append(spaces2 + "Trace.AddFunc(" + cluster + ");\r\n");foreach (SyntaxNode sNode in NodeMap.Keys){if (sNode == funcRoot || sNode.Ancestors(true).Contains(funcRoot)){var gNode = NodeMap[sNode];string isFunc = sNode == funcRoot ? "true" : "false";string label = gNode.LabelName.Replace("\r", "").Replace("\n", "\\n").Replace("\"", "\\\"");sb.Append(spaces2 + "Trace.AddNode(" + cluster + ", \"" + gNode.NodeId + "\", \"" + gNode.NodeShape + "\", \"" + label + "\"" + ");\r\n");}}cluster++;}foreach (GraphEdge gEdge in EdgeList){string label = gEdge.CenterLabel.Replace("\r", "").Replace("\n", "\\n").Replace("\"", "\\\"");sb.Append(spaces2 + "Trace.AddEdge(\"" + gEdge.TailNode.NodeId + "\", \"" + gEdge.HeadNode.NodeId + "\", \"" + label + "\");\r\n");}sb.Append(spaces + "}\r\n");result = result.Insert(ipoint, sb.ToString());}//トレースコード埋め込みprivate void AddTraceStatement(ref string result, GraphNode gNode, SyntaxNode sNode){string traceStr = $"Trace.TraceNode(\"{gNode.NodeId}\");";var parent = sNode.Parent;if (sNode is BlockSyntax){return;}else if (sNode is MethodDeclarationSyntax ||sNode is ConstructorDeclarationSyntax ||sNode is LocalFunctionStatementSyntax){var property = sNode.GetType().GetProperty("Body");var block = (BlockSyntax)property.GetValue(sNode);string spaces = new string(' ', block.GetLocation().GetLineSpan().StartLinePosition.Character + 4);result = result.Insert(block.Span.Start + 1, "\r\n" + spaces + $"Trace.TraceNode(\"{gNode.NodeId}\", true);");return;}else if (parent is ElseClauseSyntax || parent is IfStatementSyntax){var property = sNode.Parent.GetType().GetProperty("Statement");var statement = property.GetValue(sNode.Parent);string spaces = new string(' ', parent.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(sNode.Span.End, "\r\n" + spaces + "}");string spaces2 = new string(' ', sNode.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(((StatementSyntax)statement).Span.Start, "{" + "\r\n" + spaces2 + traceStr + "\r\n" + spaces2);return;}else if (sNode is ExpressionSyntax expr){if (expr.Parent is DoStatementSyntax doSntax2){try{var lastStatement = doSntax2.Statement.ChildNodes().Last();string spaces = new string(' ', lastStatement.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(lastStatement.Span.End, "\r\n" + spaces + traceStr);}catch { }}return;}else if (sNode is DoStatementSyntax ||sNode is WhileStatementSyntax ||sNode is ForEachStatementSyntax ||sNode is ForStatementSyntax){var property = sNode.GetType().GetProperty("Statement");StatementSyntax statement = (StatementSyntax)property.GetValue(sNode);try{var firstStatement = statement.ChildNodes().First();string spaces = new string(' ', firstStatement.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(firstStatement.Span.Start, traceStr + "\r\n" + spaces);}catch { }}string leftPadding = new string(' ', sNode.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(sNode.Span.Start, traceStr + "\r\n" + leftPadding);}public GraphNode CreateGraphNode(SyntaxNode astNode, string labelName, string nodeShape)//以下省略}},,,using System.Collections.Generic;using System.Linq;namespace Flow{public class FlowTrace{private Dictionary<;string, Node>; nodeMap = new Dictionary<;string, Node>;();private Dictionary<;(string tailId,string headId),Edge>; edgeMap = new Dictionary<;(string tailId, string headId), Edge>;();private Dictionary<;int, string>; funcMap = new Dictionary<;int, string>;();public void AddNode(int funcId, string id, string shape, string label){nodeMap[id] = new Node {FuncId = funcId, Id = id, Shape = shape, Label = label };}public void AddEdge(string tailId,string headId,string label){edgeMap[(tailId, headId)] = new Edge {TailId = tailId,HeadId = headId , Label = label };}public void AddFunc(int id){funcMap[id] = string.Empty;}public void TraceNode(string nodeId, bool reset = false){if (nodeMap.ContainsKey(nodeId)){var node = nodeMap[nodeId];if(funcMap[node.FuncId] != nodeId){nodeMap[nodeId].PassCount++;if (reset){funcMap[node.FuncId] = string.Empty;}if (funcMap[node.FuncId] != string.Empty){var edgeKey = (funcMap[node.FuncId], nodeId);if (!edgeMap.ContainsKey(edgeKey)){edgeMap[edgeKey] = new Edge { TailId = funcMap[node.FuncId], HeadId = nodeId, Label = "Unintended", LineStyle = "dashed" };}edgeMap[edgeKey].PassCount++;}funcMap[node.FuncId] = nodeId;}}}public void WriteDot(string dotFilename){using (System.IO.StreamWriter writer = new System.IO.StreamWriter(dotFilename, false)){writer.WriteLine("digraph G{");writer.WriteLine("rankdir=TB;");writer.WriteLine("node[fontname = \"MS GOTHIC\"]");writer.WriteLine("edge[fontname = \"MS GOTHIC\"]");var clusters = new List<;int>; { -1 };clusters.InsertRange(0, funcMap.Keys);foreach (var cluster in clusters){if(cluster != -1){writer.WriteLine("subgraph cluster_" + cluster + "{");}foreach (Node node in nodeMap.Values.OrderBy((x) =>; x.Id)){if (node.FuncId == cluster){string label = node.Label.Replace("\n", "\\n").Replace("\"", "\\\"");string countStr = string.Empty;string colorStr = string.Empty;if (node.PassCount >; 0){countStr = "(" + node.PassCount + ")";colorStr = ", color=\"red\"";}writer.WriteLine("\"" + node.Id + "\"" + " [shape = \"" + node.Shape + "\""+ colorStr + ", label = \"" + label + countStr + "\"]");}}if (cluster != -1){writer.WriteLine("}");}}foreach (Edge edge in edgeMap.Values.OrderBy((x) =>; x.TailId)){string countStr = string.Empty;string colorStr = string.Empty;if (edge.PassCount >; 0){countStr = "(" + edge.PassCount + ")";colorStr = ", color=\"red\"";}writer.WriteLine("\"" + edge.TailId + "\"  ->; \"" + edge.HeadId + "\""+ " [label =\"" + edge.Label + countStr + "\"" + colorStr + "]");}writer.WriteLine("}");}}private class Node{public int FuncId { get; set; }public string Id {get;set;}public string Shape { get; set; }public string Label { get; set; }public long PassCount { get; set; } = 0;}private class Edge{public string TailId { get; set; }public string HeadId { get; set; }public string Label { get; set; }public long PassCount { get; set; }public string LineStyle { get; set; } = string.Empty;}}},,,稼動中繰り返す
*Trace.TraceNode("node3");
値を判断
*Trace.TraceNode("node3");
省略
*}
省略
*Trace.AddEdge("node1", "node2", "");
省略
*}
args[0]:対象c#ソースファイル
args[1]:dotファイル（静的フローチャート）出力先
args[2]:変換後ソース（トレース用コード）出力先
*static void Main(string[] args)
静的フロー出力
*graph.WriteDot(args[1]);
ソースコード変換
*graph.ConvSource(args[2]);
*{var result = _sourceCode;var keys = new List<;SyntaxNode>;(NodeMap.Keys).OrderByDescending(x =>; x.Span.Start);AddInitStatements(ref result, memberDeclarations.Last());foreach (var sNode in keys){AddTraceStatement(ref result, NodeMap[sNode], sNode);}using (System.IO.StreamWriter writer = new System.IO.StreamWriter(outFile, false)){writer.Write(result);}}//ノード、エッジ登録関数部作成private void AddInitStatements(ref string result, SyntaxNode lastMetod){var clustermap = new Dictionary<;SyntaxNode, int>;();int ipoint = lastMetod.FullSpan.End;string spaces = new string(' ', lastMetod.GetLocation().GetLineSpan().StartLinePosition.Character);var sb = new StringBuilder();sb.Append("\r\n" + spaces + "public FlowTrace Trace = new FlowTrace();\r\n");sb.Append(spaces + "public void InitGraph()\r\n");sb.Append(spaces + "{\r\n");//クラスタIDを追加するstring spaces2 = new string(' ', spaces.Length + 4);int cluster = 0;foreach (var funcRoot in memberDeclarations){sb.Append(spaces2 + "Trace.AddFunc(" + cluster + ");\r\n");foreach (SyntaxNode sNode in NodeMap.Keys){if (sNode == funcRoot || sNode.Ancestors(true).Contains(funcRoot)){var gNode = NodeMap[sNode];string isFunc = sNode == funcRoot ? "true" : "false";string label = gNode.LabelName.Replace("\r", "").Replace("\n", "\\n").Replace("\"", "\\\"");sb.Append(spaces2 + "Trace.AddNode(" + cluster + ", \"" + gNode.NodeId + "\", \"" + gNode.NodeShape + "\", \"" + label + "\"" + ");\r\n");}}cluster++;}foreach (GraphEdge gEdge in EdgeList){string label = gEdge.CenterLabel.Replace("\r", "").Replace("\n", "\\n").Replace("\"", "\\\"");sb.Append(spaces2 + "Trace.AddEdge(\"" + gEdge.TailNode.NodeId + "\", \"" + gEdge.HeadNode.NodeId + "\", \"" + label + "\");\r\n");}sb.Append(spaces + "}\r\n");result = result.Insert(ipoint, sb.ToString());}//トレースコード埋め込みprivate void AddTraceStatement(ref string result, GraphNode gNode, SyntaxNode sNode){string traceStr = $"Trace.TraceNode(\"{gNode.NodeId}\");";var parent = sNode.Parent;if (sNode is BlockSyntax){return;}else if (sNode is MethodDeclarationSyntax ||sNode is ConstructorDeclarationSyntax ||sNode is LocalFunctionStatementSyntax){var property = sNode.GetType().GetProperty("Body");var block = (BlockSyntax)property.GetValue(sNode);string spaces = new string(' ', block.GetLocation().GetLineSpan().StartLinePosition.Character + 4);result = result.Insert(block.Span.Start + 1, "\r\n" + spaces + $"Trace.TraceNode(\"{gNode.NodeId}\", true);");return;}else if (parent is ElseClauseSyntax || parent is IfStatementSyntax){var property = sNode.Parent.GetType().GetProperty("Statement");var statement = property.GetValue(sNode.Parent);string spaces = new string(' ', parent.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(sNode.Span.End, "\r\n" + spaces + "}");string spaces2 = new string(' ', sNode.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(((StatementSyntax)statement).Span.Start, "{" + "\r\n" + spaces2 + traceStr + "\r\n" + spaces2);return;}else if (sNode is ExpressionSyntax expr){if (expr.Parent is DoStatementSyntax doSntax2){try{var lastStatement = doSntax2.Statement.ChildNodes().Last();string spaces = new string(' ', lastStatement.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(lastStatement.Span.End, "\r\n" + spaces + traceStr);}catch { }}return;}else if (sNode is DoStatementSyntax ||sNode is WhileStatementSyntax ||sNode is ForEachStatementSyntax ||sNode is ForStatementSyntax){var property = sNode.GetType().GetProperty("Statement");StatementSyntax statement = (StatementSyntax)property.GetValue(sNode);try{var firstStatement = statement.ChildNodes().First();string spaces = new string(' ', firstStatement.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(firstStatement.Span.Start, traceStr + "\r\n" + spaces);}catch { }}string leftPadding = new string(' ', sNode.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(sNode.Span.Start, traceStr + "\r\n" + leftPadding);}public GraphNode CreateGraphNode(SyntaxNode astNode, string labelName, string nodeShape)//以下省略}}
トレース用のソースコード出力
*{var clustermap = new Dictionary<;SyntaxNode, int>;();int ipoint = lastMetod.FullSpan.End;string spaces = new string(' ', lastMetod.GetLocation().GetLineSpan().StartLinePosition.Character);var sb = new StringBuilder();sb.Append("\r\n" + spaces + "public FlowTrace Trace = new FlowTrace();\r\n");sb.Append(spaces + "public void InitGraph()\r\n");sb.Append(spaces + "{\r\n");//クラスタIDを追加するstring spaces2 = new string(' ', spaces.Length + 4);int cluster = 0;foreach (var funcRoot in memberDeclarations){sb.Append(spaces2 + "Trace.AddFunc(" + cluster + ");\r\n");foreach (SyntaxNode sNode in NodeMap.Keys){if (sNode == funcRoot || sNode.Ancestors(true).Contains(funcRoot)){var gNode = NodeMap[sNode];string isFunc = sNode == funcRoot ? "true" : "false";string label = gNode.LabelName.Replace("\r", "").Replace("\n", "\\n").Replace("\"", "\\\"");sb.Append(spaces2 + "Trace.AddNode(" + cluster + ", \"" + gNode.NodeId + "\", \"" + gNode.NodeShape + "\", \"" + label + "\"" + ");\r\n");}}cluster++;}foreach (GraphEdge gEdge in EdgeList){string label = gEdge.CenterLabel.Replace("\r", "").Replace("\n", "\\n").Replace("\"", "\\\"");sb.Append(spaces2 + "Trace.AddEdge(\"" + gEdge.TailNode.NodeId + "\", \"" + gEdge.HeadNode.NodeId + "\", \"" + label + "\");\r\n");}sb.Append(spaces + "}\r\n");result = result.Insert(ipoint, sb.ToString());}
ノード、エッジ登録関数部作成
クラスタIDを追加する
*string spaces2 = new string(' ', spaces.Length + 4);
*{string traceStr = $"Trace.TraceNode(\"{gNode.NodeId}\");";var parent = sNode.Parent;if (sNode is BlockSyntax){return;}else if (sNode is MethodDeclarationSyntax ||sNode is ConstructorDeclarationSyntax ||sNode is LocalFunctionStatementSyntax){var property = sNode.GetType().GetProperty("Body");var block = (BlockSyntax)property.GetValue(sNode);string spaces = new string(' ', block.GetLocation().GetLineSpan().StartLinePosition.Character + 4);result = result.Insert(block.Span.Start + 1, "\r\n" + spaces + $"Trace.TraceNode(\"{gNode.NodeId}\", true);");return;}else if (parent is ElseClauseSyntax || parent is IfStatementSyntax){var property = sNode.Parent.GetType().GetProperty("Statement");var statement = property.GetValue(sNode.Parent);string spaces = new string(' ', parent.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(sNode.Span.End, "\r\n" + spaces + "}");string spaces2 = new string(' ', sNode.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(((StatementSyntax)statement).Span.Start, "{" + "\r\n" + spaces2 + traceStr + "\r\n" + spaces2);return;}else if (sNode is ExpressionSyntax expr){if (expr.Parent is DoStatementSyntax doSntax2){try{var lastStatement = doSntax2.Statement.ChildNodes().Last();string spaces = new string(' ', lastStatement.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(lastStatement.Span.End, "\r\n" + spaces + traceStr);}catch { }}return;}else if (sNode is DoStatementSyntax ||sNode is WhileStatementSyntax ||sNode is ForEachStatementSyntax ||sNode is ForStatementSyntax){var property = sNode.GetType().GetProperty("Statement");StatementSyntax statement = (StatementSyntax)property.GetValue(sNode);try{var firstStatement = statement.ChildNodes().First();string spaces = new string(' ', firstStatement.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(firstStatement.Span.Start, traceStr + "\r\n" + spaces);}catch { }}string leftPadding = new string(' ', sNode.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(sNode.Span.Start, traceStr + "\r\n" + leftPadding);}
トレースコード埋め込み
以下省略
*}

*context.Users.Add(new User { Name = "Elizabeth", Gender = GenderEnum.Female });
Femaleは'F'として登録される
*{foreach (var user in context.Users){Console.WriteLine($"Id:{user.Id}");Console.WriteLine($"Name:{user.Name}");Console.WriteLine($"Gender(Enum):{user.Gender}");Console.WriteLine($"Gender(String):{user.Gender.GetStringValue()}");Console.WriteLine("---------------------------");}}
取得

リストビューのデータを更新
*_listView0.ItemsSource =

*Add1(2).Should().Be(expValue);
ここで失敗する。

*jcr.externalIdFieldName = "Id";
外部 ID 項目　更新挿入操作で必須
HTTPリクエスト(具体的な実装は割愛)
*var res = HTTPAccess.GetResponse(method, url, body, contentType, header);
パースしてジョブIDを取得(具体的な実装は割愛)
*JobInfo jobInfo = ParseJson(res.body);
エンドポイント
*string url = DOMAIN + "/services/data/v46.0/jobs/ingest/" + this.jobId + "/batches";
メソッド
*string method = "PUT";
リクエストヘッダ
*string header = "Authorization: Bearer " + loginResult.sessionId;
リクエストボディ
csv形式で入力　 ジョブ作成時に指定した外部 ID 項目は必須
*string body = "Id,LastName,FirstName,AccountId" + "\r\n";
HTTPリクエスト(具体的な実装は割愛)
*var res = HTTPAccess.GetResponse(method, url, body, contentType, header);
成功時は201
*return (res.StatusCode == 201);
エンドポイント
*string url = DOMAIN + "/services/data/v46.0/jobs/ingest/" + this.jobId;
メソッド
*string method = "PATCH";
リクエストヘッダ
*string header = "Authorization: Bearer " + loginResult.sessionId;
*string body = "{\"state\":\"" + state + "\"}";
リクエストボディ
*string body = "{\"state\":\"" + state + "\"}";
state を更新する
HTTPリクエスト(具体的な実装は割愛)
*var res = HTTPAccess.GetResponse(method, url, body, contentType, header);
エンドポイント
*string url = DOMAIN + "/services/data/v46.0/jobs/ingest/" + this.jobId;
メソッド
*string method = "GET";
リクエストヘッダ
*string header = "Authorization: Bearer " + loginResult.sessionId;
HTTPリクエスト(具体的な実装は割愛)
*var res = HTTPAccess.GetResponse(method, url, null, null, header);
パースしてジョブIDを取得(具体的な実装は割愛)
*JobInfo jobInfo = ParseJson(res.body);
完了または失敗になるまで監視する
*break;
エンドポイント
成功結果取得
*string url = DOMAIN + "/services/data/v46.0/jobs/ingest/" + this.jobId + "/successfulResults";
失敗結果取得
string url = DOMAIN + "/services/data/v46.0/jobs/ingest/" + this.jobId + "/failedResults";
メソッド
*string method = "GET";
リクエストヘッダ
*string header = "Authorization: Bearer " + loginResult.sessionId;
HTTPリクエスト(具体的な実装は割愛)
*var res = HTTPAccess.GetResponse(method, url, null, null, header);
エンドポイント
*string url = DOMAIN + "/services/data";
メソッド
*string method = "GET";
HTTPリクエスト(具体的な実装は割愛)
*var res = HTTPAccess.GetResponse(method, url, null, null, null);
必要あればソート
apis.Sort((a, b) =&gt; string.Compare(a.version, b.version));
最新のバージョンを設定
*this.apiVersion = apis[apis.Count - 1].version;

SE,BGMの管理用コンテナクラス.
*[System.Serializable]
保持するデータ.
*[SerializeField] AudioClip soundData;
SampleContainerのインスペクタ拡張.
*[CustomEditor(typeof(SampleContainer))]
*{var data = target as SampleContainer;data.soundData = (AudioClip)EditorGUILayout.ObjectField("AudioClip", data.soundData, typeof(AudioClip));if (GUILayout.Button("PlayClip"))this.PlayClip(data.soundData);if (GUILayout.Button("StopClip"))this.StopClip(data.soundData);}
インスペクタ描画.
エディタ上でのサウンド再生.
*void PlayClip(
エディタ上でのサウンドを停止する.
*void StopClip(

*public InteractionEvents interactionEvents;
これはOnExecuteでセットしてね
点に座標を設定する
*GraphicsCoordinateSet gcs = ig.GraphicsDataSets.CreateCoordinateSet(0);
点の種類を選ぶ
*pg.PointRenderStyle = PointRenderStyleEnum.kEndPointStyle;
常に前面に表示
pg.BurnThrough = true;   無視される。Inventorのbug?
表示を更新。これをしないと、表示されない。
*ig.UpdateOverlayGraphics(View);

*cam.transform.parent = gameObject.transform;
Cameraの親オブジェクトはCarとする

*void Start () {}
Use this for initialization
*void Update () {pos = TrackPad.GetLastAxis(SteamVR_Input_Sources.RightHand);Debug.Log(pos.x +" " + pos.y);}
Update is called once per frame
*void Start () {}
Use this for initialization
*void Update () {pos = TrackPad.GetLastAxis(SteamVR_Input_Sources.RightHand);transform.localPosition = new Vector3( pos.x * 0.1f,0, pos.y * 0.1f);}
Update is called once per frame
*void Start () {}
Use this for initialization
*void Update () {pos = TrackPad.GetLastAxis(SteamVR_Input_Sources.RightHand);transform.localPosition = new Vector3( pos.x * 0.1f,0, pos.y * 0.1f);r = Mathf.Sqrt(pos.x* pos.x + pos.y* pos.y);sita = Mathf.Atan2(pos.y, pos.x) / Mathf.PI * 180;Debug.Log(r +" "+ sita );}
Update is called once per frame

*public GameObject innerBox;
文字たちを格納するための親オブジェクト（空オブジェクト）
プレハブ生成(この時点では、まだ、空のText)
*GameObject word = (GameObject)Resources.Load("Word");
生成された各オブジェクトに文字を1文字ずつ入れる
*newObj.GetComponent<;TextMesh>;().text = speakText.Substring(i-1,1);
生成された各オブジェクトの名前を変更
*newObj.name = "word" + "(" + speakText.Substring(i-1,1) + ")";
*newObj.transform.parent = innerBox.transform;*newObj.transform.localPosition = new Vector3(160.0f*(i-1), -151.0f, 0.0f);
各文字の位置を調整

*string sresult = client.DownloadString("https:
slack.comapirtm.connect");

*var z = JsonUtility.FromJson<;ItemDict<; (y);
デシリアライズ

1.変数を宣言
*LineRenderer lineRenderer;
2.GetComponentします
*lineRenderer = this.gameObject.GetComponent<;LineRenderer>;();
*gazeIcon = transform.Find("PointerIcon");*progressIndicator = transform.GetComponent;OVRProgressIndicator>;();
3.PointerIconはポインターアイコンのオブジェクト名が入る
*lineRenderer.SetPosition(0, startPointObj.transform.position);*lineRenderer.SetPosition(1, endPointObj.transform.position);
4.レーザーの位置を決定
5.消す
*lineRenderer.enabled = false;
6.出す
*lineRenderer.enabled = true;

ViewModelへの参照記憶
*vm = (ViewModels.MainWindowViewModel)DataContext;
View側処理をViewModelに設定
*vm.UpdateView = UpdataView;
Viewを更新
*UpdateView();

*BitConverter.GetBytes( (Int32)1000 ).CopyTo( tcp_keepalive, 8 );
interval.(ms)
keep-aliveのパラメータ設定
*clientSocket.IOControl( IOControlCode.KeepAliveValues, tcp_keepalive, null );

*Negative:
インデントを1段階上げる

MagicOnion を await で起動するため、非同期 Main で定義
await でサーバーを起動しないと、即 Main 関数が終了してしまうため
*static async Task Main(string[] args)
gRPC のログをコンソールに出力するよう設定
*GrpcEnvironment.SetLogger(new Grpc.Core.Logging.ConsoleLogger());
isReturnExceptionStackTraceInErrorDetail に true を設定して
エラー発生時のメッセージがコンソールに出力されるようにする
MagicOnion サーバーが localhost:12345 で Listen する
*await MagicOnionHost.CreateDefaultBuilder()
MessagePack.UnityShims を利用することで、
Unity の Vector3 や Quaternion を通信でやり取りすることが可能になる
*using UnityEngine;
サーバで gRPC が実行された際に、
実行結果をクライアントに返すためのコールバック関数を定義する
*public interface IGamingHubReceiver
*{Task<;Player[]>; JoinAsync(string roomName, string userName, Vector3 position, Quaternion rotation);Task LeaveAsync();Task MoveAsync(Vector3 position, Quaternion rotation);}
クライアントがサーバ側で gRPC 実行可能な関数を定義する
gRPC 通信で独自に定義したメッセージ Player を扱うための宣言
Player はプレイヤー名, 位置(Vector3), 回転(Quaternion) の変数を所持している
*[MessagePackObject]
*{// IGroup を使用することで同一のグループに所属している他ユーザ全員に対して// 一斉にブロードキャスト送信を行うことが出来る (オンラインゲームで言うルームの概念)IGroup room;// ルーム内での自分の情報 (IGamingHub.cs で定義した Player の情報)Player self;// ルームに入室しているユーザ全員（自分も含む）の情報を保持して扱うための変数IInMemoryStorage<;Player>; storage;// 指定したルームに入室するための関数// 入室するルーム名及び、ユーザ自身の情報(ユーザ名,位置(Vector3),回転(Quaternion)) を引数に取るpublic async Task<;Player[]>; JoinAsync(string roomName, string userName, Vector3 position, Quaternion rotation){self = new Player() { Name = userName, Position = position, Rotation = rotation };// ルームにユーザが入室する(room, storage) = await Group.AddAsync(roomName, self);// ルームに入室している他ユーザ全員に// 入室したユーザの情報をブロードキャスト送信するBroadcast(room).OnJoin(self);// ルームに入室している他ユーザ全員の情報を配列で取得するreturn storage.AllValues.ToArray();}// ユーザがルームから退出するpublic async Task LeaveAsync(){await room.RemoveAsync(this.Context);// ルームに入室している他ユーザ全員に// ルームから退出したことをユーザの情報と共にブロードキャスト送信するBroadcast(room).OnLeave(self);}// ユーザがルームの中で動くpublic async Task MoveAsync(Vector3 position, Quaternion rotation){// 動いたユーザの位置(xyz) と回転(quaternion) を設定するself.Position = position;self.Rotation = rotation;// 動いたユーザの最新の位置(Vector3)と回転(Quaternion) を// ルームに入室している他ユーザ全員にユーザの最新情報 (Player) をブロードキャスト送信するBroadcast(room).OnMove(self);}}
IGamingHub の実装が記述された GamingHub クラス
IGroup を使用することで同一のグループに所属している他ユーザ全員に対して
一斉にブロードキャスト送信を行うことが出来る (オンラインゲームで言うルームの概念)
*IGroup room;
ルーム内での自分の情報 (IGamingHub.cs で定義した Player の情報)
*Player self;
ルームに入室しているユーザ全員（自分も含む）の情報を保持して扱うための変数
*IInMemoryStorage<;Player>; storage;
指定したルームに入室するための関数
入室するルーム名及び、ユーザ自身の情報(ユーザ名,位置(Vector3),回転(Quaternion)) を引数に取る
*public async Task<;Player[]>; JoinAsync(string roomName, string userName, Vector3 position, Quaternion rotation)
ルームにユーザが入室する
*(room, storage) = await Group.AddAsync(roomName, self);
ルームに入室している他ユーザ全員に
入室したユーザの情報をブロードキャスト送信する
*Broadcast(room).OnJoin(self);
ルームに入室している他ユーザ全員の情報を配列で取得する
*return storage.AllValues.ToArray();
*{await room.RemoveAsync(this.Context);// ルームに入室している他ユーザ全員に// ルームから退出したことをユーザの情報と共にブロードキャスト送信するBroadcast(room).OnLeave(self);}
ユーザがルームから退出する
ルームに入室している他ユーザ全員に
ルームから退出したことをユーザの情報と共にブロードキャスト送信する
*Broadcast(room).OnLeave(self);
*{// 動いたユーザの位置(xyz) と回転(quaternion) を設定するself.Position = position;self.Rotation = rotation;// 動いたユーザの最新の位置(Vector3)と回転(Quaternion) を// ルームに入室している他ユーザ全員にユーザの最新情報 (Player) をブロードキャスト送信するBroadcast(room).OnMove(self);}
ユーザがルームの中で動く
動いたユーザの位置(xyz) と回転(quaternion) を設定する
*self.Position = position;
動いたユーザの最新の位置(Vector3)と回転(Quaternion) を
ルームに入室している他ユーザ全員にユーザの最新情報 (Player) をブロードキャスト送信する
*Broadcast(room).OnMove(self);
*{// 部屋に参加しているユーザ全員の GameObject (アバター)を保持するDictionary<;string, GameObject>; players = new Dictionary<;string, GameObject>;();// サーバ側の関数を実行するための変数IGamingHub client;// 指定したルームに入室するための関数// StreamingHubClient で使用する gRPC チャネル及び、参加したい部屋名、使用するユーザ名を引数に指定するpublic async Task<;GameObject>; ConnectAsync(Channel grpcChannel, string roomName, string playerName){// サーバ側の関数を実行するための StreamingHubClient を生成するclient = StreamingHubClient.Connect<;IGamingHub, IGamingHubReceiver>;(grpcChannel, this);// JoinAsync 関数を実行して部屋に入室すると同時に、// 既に入室済みのユーザ全員の情報を配列で取得するvar roomPlayers = await client.JoinAsync(roomName, playerName, Vector3.zero, Quaternion.identity);// 自ユーザ以外を OnJoin 関数に渡して、// this.players に部屋の他ユーザ全員の情報をセットする// 自ユーザの情報は await で JoinAsync を実行した段階で、// OnJoin がコールバックで呼ばれているためセット済みの状態となっているforeach (var player in roomPlayers){if (player.Name != playerName){(this as IGamingHubReceiver).OnJoin(player);}}// 自ユーザの情報を返却するreturn players[playerName];}// 部屋から退出し、部屋の他ユーザ全員に退出したことをブロードキャスト送信するpublic Task LeaveAsync(){return client.LeaveAsync();}// 自ユーザの位置(Vector3) と回転(Quaternion) を更新すると同時に// 部屋の他ユーザ全員にブロードキャスト送信するpublic Task MoveAsync(Vector3 position, Quaternion rotation){return client.MoveAsync(position, rotation);}// StreamingHubClient の解放処理// gRPC のチャネルを破棄する前に実行する必要があるpublic Task DisposeAsync(){return client.DisposeAsync();}// 部屋に新しいユーザが入室したときに呼び出される関数// または ConnectAsync 関数を実行したときに呼び出される関数void IGamingHubReceiver.OnJoin(Player player){// ユーザの GameObject (アバター)を Player 情報を元に生成して// this.players に player.Name をキーにして保持する// 部屋に入室しているユーザの数だけワールド上にキューブを出現するvar cube = GameObject.CreatePrimitive(PrimitiveType.Cube);cube.name = player.Name;cube.transform.SetPositionAndRotation(player.Position, player.Rotation);players[player.Name] = cube;}// 他ユーザが部屋から退出した際に呼び出される関数void IGamingHubReceiver.OnLeave(Player player){// this.players に保持していた GameObject (アバター)を破棄する// ワールド上から該当する GameObject (アバター)のキューブが消滅するif (players.TryGetValue(player.Name, out var cube)){GameObject.Destroy(cube);}}// 部屋の中でいずれかのユーザが動いたときに呼び出される関数void IGamingHubReceiver.OnMove(Player player){// 引数の player の Name を元に this.players 内から GameObject を取得する// ワールド上の該当する GameObject (アバター)の位置(Vector3)と回転(Quaternion) の値を最新のものに更新するif (players.TryGetValue(player.Name, out var cube)){cube.transform.SetPositionAndRotation(player.Position, player.Rotation);}}}
IGamingHubReceiver の実装が記述された GamingHubClient クラス
部屋に参加しているユーザ全員の GameObject (アバター)を保持する
*Dictionary<;string, GameObject>; players = new Dictionary<;string, GameObject>;();
サーバ側の関数を実行するための変数
*IGamingHub client;
指定したルームに入室するための関数
StreamingHubClient で使用する gRPC チャネル及び、参加したい部屋名、使用するユーザ名を引数に指定する
*public async Task<;GameObject>; ConnectAsync(Channel grpcChannel, string roomName, string playerName)
サーバ側の関数を実行するための StreamingHubClient を生成する
*client = StreamingHubClient.Connect<;IGamingHub, IGamingHubReceiver>;(grpcChannel, this);
JoinAsync 関数を実行して部屋に入室すると同時に、
既に入室済みのユーザ全員の情報を配列で取得する
*var roomPlayers = await client.JoinAsync(roomName, playerName, Vector3.zero, Quaternion.identity);
自ユーザ以外を OnJoin 関数に渡して、
this.players に部屋の他ユーザ全員の情報をセットする
自ユーザの情報は await で JoinAsync を実行した段階で、
OnJoin がコールバックで呼ばれているためセット済みの状態となっている
*foreach (var player in roomPlayers)
自ユーザの情報を返却する
*return players[playerName];
*{return client.LeaveAsync();}
部屋から退出し、部屋の他ユーザ全員に退出したことをブロードキャスト送信する
自ユーザの位置(Vector3) と回転(Quaternion) を更新すると同時に
部屋の他ユーザ全員にブロードキャスト送信する
*public Task MoveAsync(Vector3 position, Quaternion rotation)
StreamingHubClient の解放処理
gRPC のチャネルを破棄する前に実行する必要がある
*public Task DisposeAsync()
部屋に新しいユーザが入室したときに呼び出される関数
または ConnectAsync 関数を実行したときに呼び出される関数
*void IGamingHubReceiver.OnJoin(Player player)
ユーザの GameObject (アバター)を Player 情報を元に生成して
this.players に player.Name をキーにして保持する
部屋に入室しているユーザの数だけワールド上にキューブを出現する
*var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
*{// this.players に保持していた GameObject (アバター)を破棄する// ワールド上から該当する GameObject (アバター)のキューブが消滅するif (players.TryGetValue(player.Name, out var cube)){GameObject.Destroy(cube);}}
他ユーザが部屋から退出した際に呼び出される関数
this.players に保持していた GameObject (アバター)を破棄する
ワールド上から該当する GameObject (アバター)のキューブが消滅する
*if (players.TryGetValue(player.Name, out var cube))
*{// 引数の player の Name を元に this.players 内から GameObject を取得する// ワールド上の該当する GameObject (アバター)の位置(Vector3)と回転(Quaternion) の値を最新のものに更新するif (players.TryGetValue(player.Name, out var cube)){cube.transform.SetPositionAndRotation(player.Position, player.Rotation);}}
部屋の中でいずれかのユーザが動いたときに呼び出される関数
引数の player の Name を元に this.players 内から GameObject を取得する
ワールド上の該当する GameObject (アバター)の位置(Vector3)と回転(Quaternion) の値を最新のものに更新する
*if (players.TryGetValue(player.Name, out var cube))
プレイヤーの Transform (今回はメインカメラの Transform を指定)
*[SerializeField]
部屋に参加するときに使用するユーザ名 (何でも設定可)
*[SerializeField]
参加したい部屋のルーム名
(StreamingHub クライアント同士で交流したい場合は、
各クライアントで同一の名前を設定する必要がある)
*[SerializeField]
StreamingHub クライアントで使用する gRPC チャネルを生成
*private Channel channel = new Channel("localhost", 12345, ChannelCredentials.Insecure);
StreamingHub サーバと通信を行うためのクライアント生成
*private GamingHubClient client = new GamingHubClient();
ゲーム起動時に設定した部屋名のルームに設定したユーザ名で入室する。
*await this.client.ConnectAsync(this.channel, this.m_RoomName, this.m_UserName);
*{// 毎フレームプレイヤーの位置(Vector3) と回転(Quaternion) を更新し、// ルームに入室している他ユーザ全員にブロードキャスト送信するclient.MoveAsync(m_PlayerTransform.position, m_PlayerTransform.rotation);}
Update is called once per frame
毎フレームプレイヤーの位置(Vector3) と回転(Quaternion) を更新し、
ルームに入室している他ユーザ全員にブロードキャスト送信する
*client.MoveAsync(m_PlayerTransform.position, m_PlayerTransform.rotation);
GameClient が破棄される際の StreamingHub クライアント及び gRPC チャネルの解放処理
*await this.client.LeaveAsync();

*HogePool.Instance.Catch(this);
返却するクラスのインタンスを渡す

*86,
cols

*double dE = Y - a_sub_b;
value after differentiation of squared error because calculation is omitted
*{sw.Write(a.ToString() + "," + b.ToString() + "," + a_sub_b.ToString() + "," +w[0].ToString() + "," + w[1].ToString() + "," +Y.ToString() + "," + dE.ToString() +Environment.NewLine);}
record
*{sw.Write(",,," +w[0].ToString() + "," + w[1].ToString() + "," +"," +Environment.NewLine);}
final record

*{public override void Connect(){Console.WriteLine("SQLServerに繋ぎます～！");}}
ConcreteProduct
*{public override void Connect(){Console.WriteLine("PostgreSQLに繋ぎます～！");}}
ConcreteProduct
*{private readonly string _name;public DBCreator(string name) =>; _name = name;public override Product Create(){switch (_name){case "SQLServer":return new SQLServer();case "PostgreSQL":return new PostgreSQL();default:throw new Exception();}}}
ConcreteCreator

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"
ビープ音を鳴らします
*SystemSounds.Asterisk.Play();

*str = Regex.Replace(str, "^
[( |\t|)]*", "");

Tは抽象クラス
*var types = Assembly.GetAssembly(typeof(T))
Tはインターフェース
*var types = Assembly.GetAssembly(typeof(T))

*}, () =>;{
This is called once the client has emitted the RTM start command
*}, () =>;{
clientReady.Set();

*hoge = hoge.Split(" ".ToCharArray());
型 'string[]' を 'string' に暗黙的に変換できません
*public int itemType { get; set; }
私にとって１番しっくりきた書き方が見つかった！

*public string screenShotURL= "http:
www.my-server.comcgi-binscreenshot.pl";
*void Start () {StartCoroutine(UploadPNG());}
Use this for initialization
*WWWForm form = new WWWForm();*form.AddField("frameCount", Time.frameCount.ToString());
Create a Web Form
*using (var w = UnityWebRequest.Post(screenShotURL, form))*{
Upload to a cgi script

*string AmPmString = AMPM + "  " + dt.ToString("hh:mm") + Environment.NewLine + Mon+"." + dt.Day +" "+ dt.Year ;
12時間表示のstring型へ変換
テキストの透明度を変更する
*Qtext.color = new Color(1, 1, 1, a_color);

MySetting1はstring型
*string str = Properties.Settings.Default.MySetting1;
MySetting2はint型
*Properties.Settings.Default.MySetting1 = 123;
*{get { return Properties.Settings.Default.MySetting1; }set { Properties.Settings.Default.MySetting1 = value; }}
設定値を読み書きするためのプロパティを作成
*{InitializeComponent();txt1.Text = MyString;txt2.Text = MyInt.ToString();txt3.Text = MyBool.ToString();txt4.Text = MyDouble.ToString();}
起動時に設定の値を読み込み、画面表示
*{MyString = txt1.Text;Properties.Settings.Default.Save();}
画面に入力した値を保存する

女性の場合は割引金額
*return 1500;

*WriteCombineFile( item, dst_path );
それを書き込む

*_WaveHdr.lpData = Marshal.AllocHGlobal(dataSize);
メモリを確保
バッファを準備・追加
*var cdwh = Marshal.SizeOf<;NativeMethods.WaveHdr>;();
録音スタート
*NativeMethods.waveInStart(_Hwi);
オープン
*WaveOpen?.Invoke(this, EventArgs.Empty);
クローズ
*WaveClose?.Invoke(this, EventArgs.Empty);
WAVEデータ
*OnWaveData();
WAVEデータをコピーするバイト配列を作成
*var headerSize = 44;
WAVEヘッダを設定
*Array.Copy(Encoding.ASCII.GetBytes("RIFF"), 0, waveData, 0, 4);
バッファを開放
*NativeMethods.waveInUnprepareHeader(_Hwi, ref _WaveHdr, Marshal.SizeOf<;NativeMethods.WaveHdr>;());
メモリ開放
*Marshal.FreeHGlobal(_WaveHdr.lpData);

実際の処理

*transaction.End();
エラー処理

*}
必要なら、後処理

*interactionEvents = null;

ハッシュテーブルを宣言
*ExitGames.Client.Photon.Hashtable roomHash;
*{// ハッシュに要素を追加(同じ名前があるとエラーになる)roomHash.Add("hoge", 0);// ハッシュに要素を追加、既に同じ名前のキーがあれば上書きroomHash["hoge"] = 1;// ルームにハッシュを送信するPhotonNetwork.room.SetCustomProperties(roomHash);}
ローカルで使っているハッシュをルームにセット
ハッシュに要素を追加(同じ名前があるとエラーになる)
*roomHash.Add("hoge", 0);
ハッシュに要素を追加、既に同じ名前のキーがあれば上書き
*roomHash["hoge"] = 1;
ルームにハッシュを送信する
*PhotonNetwork.room.SetCustomProperties(roomHash);
*{// 変更されたハッシュを受け取るroomHash = changedRoomHash;}
ルームのハッシュが送信されたら、送信されたハッシュが入ってくる(Photonの機能で戻り値の型、関数名、引数を一致させると勝手に呼ばれる)
変更されたハッシュを受け取る
*roomHash = changedRoomHash;
ルームプロパティ用のハッシュ(Dictionary)
*private static ExitGames.Client.Photon.Hashtable roomHash;
ルームプロパティ用のこのプレイヤーのハッシュ(Dictionary)を生成
*roomHash = new ExitGames.Client.Photon.Hashtable();
ルームプロパティ ===========================================
RoomPropertyが更新された時に呼ばれる
*public void OnPhotonCustomRoomPropertiesChanged(ExitGames.Client.Photon.Hashtable changedRoomHash)
更新したプレイヤーが保持しているハッシュを入れる
*roomHash = changedRoomHash;
ルームプロパティのセット -----------------------------------
キーが既に存在していたら上書き
*public static void SetRoomProperty<;T>;(string key, T value)
自身のハッシュをネット上に送信
*PhotonNetwork.room.SetCustomProperties(roomHash);
*{// 要素数256を超える場合はここをshortなどに変更してくださいfor(byte i = 0; i <; value.Length; i++){roomHash[key + i] = value[i];}// 自身のハッシュをネット上に送信PhotonNetwork.room.SetCustomProperties(roomHash);}
一次元配列用
*for(byte i = 0; i <; value.Length; i++)*{
要素数256を超える場合はここをshortなどに変更してください
自身のハッシュをネット上に送信
*PhotonNetwork.room.SetCustomProperties(roomHash);
自身のハッシュをネット上に送信
*PhotonNetwork.room.SetCustomProperties(roomHash);
*{roomHash.Add(key, value);// 自身のハッシュをネット上に送信PhotonNetwork.room.SetCustomProperties(roomHash);}
キーが既に存在している場合エラーが出る
自身のハッシュをネット上に送信
*PhotonNetwork.room.SetCustomProperties(roomHash);
*{// outを受け取るための変数を用意object value;// 指定したキーがあれば返すif (roomHash.TryGetValue(key, out value)){// ボックス化解除return (T)value;}// 無かったらnullが返るreturn (T)value;}
ルームプロパティをゲット -----------------------------------
outを受け取るための変数を用意
*object value;
*if (roomHash.TryGetValue(key, out value))*{
指定したキーがあれば返す
ボックス化解除
*return (T)value;
無かったらnullが返る
*return (T)value;
*{// outを受け取るための変数を用意object value;// 指定したキーがあれば返すif(roomHash.TryGetValue(key + arrayNum, out value)){// ボックス化解除return (T)value;}return (T)value;}
一次元配列用
outを受け取るための変数を用意
*object value;
*if(roomHash.TryGetValue(key + arrayNum, out value))*{
指定したキーがあれば返す
ボックス化解除
*return (T)value;
値の設定方法
===============================================================
hogeというキーで0をセット
*PhotonProperty.SetRoomProperty("hoge", 0);
*int[] array = { 0, 1, 2, 3 };
一次元配列を作成
arrayというキーでarray配列をセット
*PhotonProperty.SetRoomPropertyArray("array", array);
値の取得方法
===============================================================
戻り値の型をint型に指定してキーを入力
*int hoge = PhotonProperty.GetRoomProperty<;int>;("hoge");
戻り値の型をint型に指定してキーと取得したい要素番号を入力
*int fuga = PhotonProperty.GetRoomPropertyArray<;int>;("array", 0);

バージョンチェック＆更新処理
*ApplicationDeployment deploy;
アップデートがあるかチェック
*bolCheckUpdate = deploy.CheckForUpdate();
アップデートがあるので、アップデート処理
*bool bolUpdate = deploy.Update();
更新処理が終わったのでアプリケーションをリスタートする
*Application.Restart();
更新がエラーしたので任意の処理
*}

条件により、読み込むDictionary.xamlを変える
*string dicPath = (true) ? "Dictionary1.xaml" : "Dictionary2.xaml";

ここを変更した↓
*static Product karinto = new Product(123, "かりんとう", 180);

アクティブウィンドウのデバイスコンテキストを取得
*hWnd = NativeAPIUtility.GetForegroundWindow();
ウィンドウサイズを取得
*NativeAPIUtility.RECT rect = new NativeAPIUtility.RECT();
TODO:クラシックモードを考慮していないことに注意（Aaro有効を前提）
*NativeAPIUtility.DwmGetWindowAttribute(hWnd, (int)NativeAPIUtility.DwmWindowAttribute.DWMWA_EXTENDED_FRAME_BOUNDS, out var bounds, Marshal.SizeOf(typeof(NativeAPIUtility.RECT)));
Bitmapの作成
*Bitmap bmp = new Bitmap(bounds.right - bounds.left, bounds.bottom - bounds.top);
Graphicsの作成
*graphics = Graphics.FromImage(bmp);
Graphicsのデバイスコンテキストを取得
*hDC = graphics.GetHdc();
Bitmapに画像をコピー
*NativeAPIUtility.BitBlt(hDC, 0, 0, bmp.Width, bmp.Height, windowDC, bounds.left - rect.left, bounds.top - rect.top, NativeAPIUtility.SRCCOPY);

*PubKey pub = ...
上で得たのと同じ公開鍵

*Task.Run(() =<; Task.WhenAll(
NEST
*}catch(AggregateException ex3){
例外ハンドリングを行ったが、"1-1"しかハンドリングできなかったと仮定
*if (ex2.Message == "1-1")*{
例外ハンドリングを行ったが、"1-1"しかハンドリングできなかった
*if (ex2.Message == "1-2")*{
"1-2"を別の例外でラップしてthrowした場合
ここ呼ばれない
*Console.WriteLine("--- Unhandle InnerExceptions ---");

LayerMaskFieldはデフォルトでは無いので自作.
*public static LayerMask LayerMaskField(
エディタ拡張部分.
*[CustomEditor(typeof(Sample))]

元からある行
*services
これを追記
*services.Configure<;AppSetting>;(Configuration);

textureSheetAnimation を使っているもの、組み込み texture を使っているものは除外
*var targets = particles.Select(p =>; new Data(p))
*foreach (var group in targets.GroupBy(p =>; p.Renderer.sharedMaterial.shader))*{
shader ごとにまとめる
*foreach (var t in group)*{
texture を readable, 2のべき乗 に変更
x,y を固定して使うための設定
*var sheet = p.Particle.textureSheetAnimation;
サイズ、位置を指定
*sheet.numTilesX = Mathf.RoundToInt(1 / packInfo.width);

*var image = new BitmapImage(new Uri($"pack:
application:,,,FirstRevitPlugin;componentResources{iconName}"));

*{Solid,Wire,}
描画モード.
エディタ拡張部分.
*[CustomEditor(typeof(Sample))]
プリミティブタイプが変更された場合,メッシュを差し替える.
*GUI.changed = false;
取得したメッシュを確認できるようにしているだけ.
*EditorGUILayout.ObjectField(component.mesh, typeof(Mesh));
プリミティブタイプが変更された場合,メッシュを差し替える.
*GUI.changed = false;

*public static void DefineItem(int type)
絶対なさそうな名前を選んだ
絶対なさそうなメソッド組んだ
*}

*double dE = Y - a_add_b;
value after differentiation of squared error because calculation is omitted
*{sw.Write(a.ToString() + "," + b.ToString() + "," + a_add_b.ToString() + "," +w[0].ToString() + "," + w[1].ToString() + "," +Y.ToString() + "," + dE.ToString() +Environment.NewLine);}
record
*{sw.Write(",,," +w[0].ToString() + "," + w[1].ToString() + "," +"," +Environment.NewLine);}
final record

127.0.0.1から10.0.2.2に接続先のアドレスを修正する。
Channel channel = new Channel("127.0.0.1:50051", ChannelCredentials.Insecure);
*Channel channel = new Channel("10.0.2.2:50051", ChannelCredentials.Insecure);

*if(i<;=(pot_k-16))
28時間以下って条件は必要ないかな。comboBoxが28時間までだから
0x100の256byteを埋める。jが1で16byte
*fill_FF_area(start_address_POT+(k*16*16)+0x20, start_address_POT+(k*16*16)+0xFF, micom, output_file_name);

*{// ActiveなSceneのRootにあるGameObject[]を取得するvar rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();// 空の IEnumerable<;T>;IEnumerable<;T>; resultComponents = (T[])Enumerable.Empty<;T>;();foreach (var item in rootGameObjects){// includeInactive = true を指定するとGameObjectが非活性なものからも取得するvar components = item.GetComponentsInChildren<;T>;(includeInactive);resultComponents = resultComponents.Concat(components);}return resultComponents.ToArray();}
通常trueしか指定しないのでデフォルト引数をtrueにしてます
ActiveなSceneのRootにあるGameObject[]を取得する
*var rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();
空の IEnumerable&lt;T&gt;
*IEnumerable<;T>; resultComponents = (T[])Enumerable.Empty<;T>;();
includeInactive = true を指定するとGameObjectが非活性なものからも取得する
*var components = item.GetComponentsInChildren<;T>;(includeInactive);
*{// ActiveなSceneのRootにあるGameObject[]を取得するvar rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();// 空の IEnumerable<;T>;IEnumerable<;T>; resultComponents = (T[])Enumerable.Empty<;T>;();foreach (var item in rootGameObjects){// includeInactive = true を指定するとGameObjectが非活性なものからも取得するvar components = item.GetComponentsInChildren<;T>;(includeInactive);resultComponents = resultComponents.Concat(components);}return resultComponents.First();}
1つだけ取得したい場合はこちら（GetComponentsInActiveSceneを元にして書いたので少し非効率です）
ActiveなSceneのRootにあるGameObject[]を取得する
*var rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();
空の IEnumerable&lt;T&gt;
*IEnumerable<;T>; resultComponents = (T[])Enumerable.Empty<;T>;();
includeInactive = true を指定するとGameObjectが非活性なものからも取得する
*var components = item.GetComponentsInChildren<;T>;(includeInactive);
*{MenuContentHandlers = MyGameObjectUtility.GetComponentsInActiveScene<;MenuContentHandler>;();}
Scriptをアタッチした際に自動で呼ばれる, Inspectorからも呼べる

メソッドの戻り値の配列は要素数6で、それぞれカメラ側から見て
[0]: 左の面, [1]: 右の面, [2]: 下の面, [3]: 上の面, [4]: 手前の面, [5]: 奥の面
*Plane[] planes = GeometryUtility.CalculateFrustumPlanes(Camera.main);

WWWクラス定義
WWW www = new WWW("http:urx3.nu/QwZk");
wwwダウンロード開始
*yield return www;
*{TestUniTask();}
using UniRx.Async;
WWWクラス定義
WWW www = new WWW("http:urx3.nu/QwZk");
wwwダウンロード開始
*await www;
*{//TestUniTask終了まで待つint a = await TestUniTask();Debug.Log("Complete");}
using UniRx.Async;
TestUniTask終了まで待つ
*int a = await TestUniTask();
5フレーム待つ
*await UniTask.DelayFrame(5);

カウントが閾値を超えたときの処理
*}

*dateTimeFormat.GetAbbreviatedEraName(eraIndex)
=&gt; 明

*{//省略services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);//省略}
This method gets called by the runtime. Use this method to add services to the container.
省略
*services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
省略
*}
*{//省略services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2).AddJsonOptions(opt =>;{opt.SerializerSettings.ContractResolver = new Newtonsoft.Json.Serialization.DefaultContractResolver();});//省略}
This method gets called by the runtime. Use this method to add services to the container.
省略
*services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2)
省略
*}

irome.Item = new Something(); コンパイルエラー
*var item = irome.Item;
irome.DoSomething(new Something()); コンパイルエラー
*item = irome.GetSomething();
irome.Dispose(); コンパイルエラー
*}

*driver.Navigate().GoToUrl("https:
www.google.com");

*var tfg = new TransformGroup();*tfg.Children.Add(new ScaleTransform(3, 3));
TransformGroupを作成(大きさを3倍にして、右に10pixcelずらす)
*bt.RenderTransform = tfg;*}
ボタンのRenderTransformにセット

*if (!this.IsLastSibling ()) return;
自身が最前でなければ何もしない

*Console.WriteLine(string.Format(CultureInfo.InvariantCulture, "{0:yyyy/MM/dd}", DateTime.Now));
↓
*Console.WriteLine(((IFormattable)$"{DateTime.Now:yyyy/MM/dd}").ToString(null, CultureInfo.InvariantCulture));
↓

*myUsecase.OnlineChanged += ReceiveOnlineChanged;
いつ -= する？
省略
*}
省略...
*this.app = new App();

*private GameObject guiTextSignUp;
新規登録テキスト
ログイン画面のときtrue, 新規登録画面のときfalse
*private bool isLogIn;
ボタンが押されると対応する変数がtrueになる
*private bool logInButton;
テキストボックスで入力される文字列を格納
*public string id;
ゲームオブジェクトを検索し取得する
*guiTextLogIn  = GameObject.Find ("GUITextLogIn");
*if( isLogIn ){*drawLogInMenu();
ログイン画面
*if( logInButton )*FindObjectOfType;UserAuth>;().logIn( id, pw );
ログインボタンが押されたら
*if( signUpMenuButton )*isLogIn = false;
新規登録画面に移動するボタンが押されたら
*else {drawSignUpMenu();// 新規登録ボタンが押されたらif( signUpButton )FindObjectOfType<;UserAuth>;().signUp( id, mail, pw );// 戻るボタンが押されたらif( backButton )isLogIn = true;}
新規登録画面
*if( signUpButton )*FindObjectOfType;UserAuth>;().signUp( id, mail, pw );
新規登録ボタンが押されたら
*if( backButton )*isLogIn = true;
戻るボタンが押されたら
*if( FindObjectOfType<;UserAuth>;().currentPlayer() != null )*Application.LoadLevel("Stage");
currentPlayerを毎フレーム監視し、ログインが完了したら
テキスト切り替え
*guiTextSignUp.SetActive (false);
テキストボックスの設置と入力値の取得
*GUI.skin.textField.fontSize = 20;
ボタンの設置
*int btnW = 180, btnH = 50;
テキスト切り替え
*guiTextLogIn.SetActive (false);
テキストボックスの設置と入力値の取得
*int txtW = 150, txtH = 35;
ボタンの設置
*int btnW = 180, btnH = 50;
シングルトン化する ------------------------
*private UserAuth instance = null;
Playerプレハブ
*public GameObject player;
タイトル
*private GameObject title;
ボタンが押されると対応する変数がtrueになる
*private bool leaderBoardButton;
Titleゲームオブジェクトを検索し取得する
*title = GameObject.Find ("Title");
*if( logOutButton )*FindObjectOfType;UserAuth>; ().logOut ();
ログアウトボタンが押されたら
*if ( Event.current.type == EventType.MouseDown)*GameStart ();
画面タップでゲームスタート
*if( FindObjectOfType<;UserAuth>;().currentPlayer() == null )*Application.LoadLevel("Login");
ログアウト完了してたらログインメニューに戻る
ゲームスタート時に、タイトルを非表示にしてプレイヤーを作成する
*title.SetActive (false);
ゲームオーバー時に、タイトルを表示する
*title.SetActive (true);
ゲーム中かどうかはタイトルの表示/非表示で判断する
*return title.activeSelf == false;
ボタンの設置
*int btnW = 140, btnH = 50;

*url: "hoge
{filename}.jpg", ハンドリング対象URL

*protected int HResult { get; set; }
略
略
*}
*public int HResult { get; protected set; }
略
略
*}
例外発生
*}
この Project のターゲットが .Net Framework 4.5　より前であっても
.Net Framework 4.5 以上のアセンブリが参照される可能性があるので Public を指定しておく
*| System.Reflection.BindingFlags.Public

*string[] JapanHolidayfromCAO = new string[1] { "https:
www8.cao.go.jpchoseishukujitsusyukujitsu.csv" };
URLのファイルが見つからない等のエラーが発生
*Console.WriteLine("エラーが発生しました\r\n\r\n" + e.ToString());

コンピュータ名 = "." はローカルコンピュータを表す。コンピュータ名は省略可能（省略時は"."）
Memory/Available MBytesのようにインスタンスを指定できない項目は、インスタンスを空文字にする
取りたい情報を並べる
*counterList.Add((".", "Processor", "% Processor Time", "_Total"));
*{if (!PerformanceCounterCategory.Exists(x.category, x.machine)){//カテゴリが存在するか確かめるConsole.WriteLine("登録されていないカテゴリです：" + x.category);}else if (!PerformanceCounterCategory.CounterExists(x.counter, x.category, x.machine)){//カウンタが存在するか確かめるConsole.WriteLine("登録されていないカウンタです：" + x.counter);}else{//PerformanceCounterオブジェクトの作成pcList.Add(new PerformanceCounter(x.category, x.counter, x.instance, x.machine));}});
エラーチェック後、PerformanceCounterオブジェクトの作成を作成
カテゴリが存在するか確かめる
*Console.WriteLine("登録されていないカテゴリです：" + x.category);
カウンタが存在するか確かめる
*Console.WriteLine("登録されていないカウンタです：" + x.counter);
*pcList.Add(new PerformanceCounter(x.category, x.counter, x.instance, x.machine));*}
PerformanceCounterオブジェクトの作成
*while (true)*{
1秒おきに値を取得する
計算された値を取得し、表示する
*Console.WriteLine(x.CategoryName + " / " + x.CounterName + "：" + x.NextValue());
1秒待機する
*System.Threading.Thread.Sleep(1000);

ディレクトリの指定
*const string Dir = @"C:\PDFTest";
ディレクトリ内のファイル名一覧を取得する。
*string[] files = System.IO.Directory.GetFiles(Dir, "*", System.IO.SearchOption.AllDirectories);
*if (!(Directory.Exists(Dir + "\\PDF"))) {*Directory.CreateDirectory(Dir + "\\PDF");
出力先フォルダがない場合は作成
エクセルのプロセスが残っているか確認して、残っていたら終了する。
*var excels = Process.GetProcessesByName("EXCEL");
Applicationクラスのインスタンス作成
*application = new Application();
Excelファイルを開く
*Console.WriteLine("----------Excelファイル展開開始----------");
*if (!(System.IO.File.Exists(saveAsPathName)))*{
Excelのシート全てをPDFとして出力
workbookをClose
*workbook.Close(true, Type.Missing, Type.Missing);
applicationをClose
*application.Quit();

*return await GetClient().CreateDocumentCollectionAsync(database.SelfLink, new DocumentCollection { Id = collectionId });
Default is S1 tier

*if (m_IsStop)*{
一時停止中なら
開始時間を調節する
*m_StartTime += Time.deltaTime;
*if (IsWork())*{
駆動中なら
経過時間を求める
*m_Time = Time.timeSinceLevelLoad - m_StartTime;
*if (m_Duration <;= m_Time)*{
経過時間が計りたい時間を超えたら
*if (m_IsLoop)*{
ループ設定されていたら
*if (m_LoopCount == 1)*{
ループ残り回数が１回なら
以下を実行してループを抜ける
*StartTimer(m_Duration);
再度セットする
*StartTimer(m_Duration, true, m_LoopCount);
駆動を終了する
*m_Duration = 0f;
計測終了イベントを実行する
*OnDoneMeasure(EventArgs.Empty);
全パラメータをリセットする
*Break();
*if(IsStop()) return false;*m_StartTime = Time.timeSinceLevelLoad;
停止中に再度再開はできない
駆動中でないなら０を返す
*return IsWork() ? m_Time : 0f;
駆動中なら秒、そうでないなら０を返す
*return IsWork() ? Mathf.FloorToInt(m_Time) : 0;
文字(秒数)を表示
*text.text = GetTimeSec().ToString();
ここに計測終了時に行いたい処理を書く
*timer.OnDoneMeasureHandler -= handler;
ここに計測終了時に行いたい処理を書く
*}

*tkm.start(9);
IDの呼び出し順が昇順でないパターン（レポートはID順に出る）・かつ、stopしたままで終了するパターン（レポートに警告が出る）

PdfDocument objectを作成します。
*PdfDocument document = new PdfDocument();
マージンを設定します。
*PdfUnitConvertor unitCvtr = new PdfUnitConvertor();
新規ページを追加します。
*PdfPageBase page = document.Pages.Add(PdfPageSize.A4, margins);
カスタムのPdfTrueTypeFont、PdfPenインスタンスを作成します。
*PdfTrueTypeFont font = new PdfTrueTypeFont(new Font("Ms mincho", 20f), true);
DrawStringメソッドでテキストを書きます。
*string text = "初めてのPDFです！";
保存します・
*document.SaveToFile("PDF作成.pdf");

*.WithSubscribe(_ =>; DialogHelper.ShowDialog($"N = {Operand.Value}"));
コンストラクタ内
*.WithSubscribe(_ =>; DialogHelper.ShowDialog($"N^2 = {Answer.Value}"));
コンストラクタ内

テスト用にテーブルを作成
*DataTable dt = new DataTable();
*for (int i = 0; i <; 3; i++)*{
テーブルに値をセット
リピーターコントロールにテーブルをBindする
*Repeater1.DataSource = dt;
A案
*((Literal)e.Item.FindControl("lits")).Text = "./newpage.aspx?KEY=" + view["KEY"] + "";
C案
*((HyperLink)e.Item.FindControl("hlk")).NavigateUrl = "./newpage.aspx?KEY=" + view["KEY"];

*Response.Redirect(openfilename);
PDFに遷移

*foreach (var sel in selectedAsset) {Debug.Log (sel.name + " : " + sel.GetType ());//選択したものがフォルダなら、フォルダ内にあるマテリアルとテクスチャを検索してリストに追加if ((sel.GetType ().ToString () == "UnityEditor.DefaultAsset")){var folder = (DefaultAsset)sel;var dirpath = AssetDatabase.GetAssetPath(folder);string[] diraug = {dirpath};//マテリアルに対する処理var mfiles = AssetDatabase.FindAssets("t:Material",diraug);foreach(var mf in mfiles){var mfpath = AssetDatabase.GUIDToAssetPath(mf);var mfasset = AssetDatabase.LoadAllAssetsAtPath(mfpath);foreach(var mfa in mfasset){mlist.Add((Material)mfa);}}//テクスチャに対する処理var tfiles = AssetDatabase.FindAssets("t:Texture2D",diraug);foreach(var tf in tfiles){var tfpath = AssetDatabase.GUIDToAssetPath(tf);var tfasset = AssetDatabase.LoadAllAssetsAtPath(tfpath);foreach(var tfa in tfasset){tlist.Add((Texture2D)tfa);Debug.Log(tfa);}}}}
選択したフォルダの取得
*if ((sel.GetType ().ToString () == "UnityEditor.DefaultAsset")){*var folder = (DefaultAsset)sel;
選択したものがフォルダなら、フォルダ内にあるマテリアルとテクスチャを検索してリストに追加
*foreach(var mf in mfiles){var mfpath = AssetDatabase.GUIDToAssetPath(mf);var mfasset = AssetDatabase.LoadAllAssetsAtPath(mfpath);foreach(var mfa in mfasset){mlist.Add((Material)mfa);}}
マテリアルに対する処理
*foreach(var tf in tfiles){var tfpath = AssetDatabase.GUIDToAssetPath(tf);var tfasset = AssetDatabase.LoadAllAssetsAtPath(tfpath);foreach(var tfa in tfasset){tlist.Add((Texture2D)tfa);Debug.Log(tfa);}}
テクスチャに対する処理
*foreach (var mat in mlist)*{
マテリアルリストをfor文で回して名前の種類によって処理を分ける

docの初期化など

*using (var transaction = new TinyTransaction(doc, "処理の名前"))
この場合は、Abort()される。
*return;
*} catch (Exception ex) {
いろいろとオブジェクトを操作する
*} catch (Exception ex) {

異常時はAbortする
*transaction.Abort();
変更した場合のみ、End()する。
例外のcatchで先にAbort()していた場合は、このEnd()は無視される。
*transaction.End();
managedリソースの破棄
*}
unmanagedリソースの破棄
*Abort();

バージョン番号をプロジェクトで一意にする
重複があるとエラーになる
2回目以降は、同じ番号のマイグレーションはスキップする
カスタム属性を使うとより管理しやすい
https:fluentmigrator.github.io/articles/migration/migration-attribute-custom.html
*[Migration(0, "creating schema")]
バージョン番号を下げるときに実行される
*Delete.Table("testtable").InSchema("aa");
バージョン番号を上げるときに実行される
*Create.Schema("aa");
SQLServer系列の場合だけ、デフォルトの文字列照合設定を変更する
*IfDatabase("SqlServer")
null許可する場合
*Create.Column("col1").OnTable("table1").AsString(128).Nullable();
null許可しない場合
*Create.Column("col2").OnTable("table1").AsString(128).NotNullable();
DIを設定していない場合にはこちらが呼ばれる
*_Param = null;
以下マイグレーションコード....
*}

（省略）
*var processInfo = new ProcessStartInfo();

*tokens.Statuses.Update(status =<; $"私の名前は「{name}」です。#NameChangeBot");
名前変更の報告ツイート
*public static IEnumerable<;TKey>; GetKeys<;TKey, TValue>;(this Dictionary<;TKey, TValue>; self) {foreach (var item in self.Keys) {yield return item;}}
DictionaryのKeyをまとめてIEnumerableにして返す
*public static T Random<;T>;(this IEnumerable<;T>; self) {if (!self.Any()) {return default;}Random random = new Random();var idx = random.Next(0, self.Count());return self.ElementAt(idx);}
ランダムな要素を返す
ふぁぼされてないツイートだけ抽出
*public static IEnumerable<;Status>; GetNotFavoTweets(this IEnumerable<;Status>; tweets,Tokens token) =>;

Controlキーを押しっぱなしにする
*NativeMethods.GetKeyboardState(keys);
ループか何かで、複数回BrowserNode.DoSelect()する

*}
Controlキーを復元する
*keys[VK_CONTROL] = savedControlKey;
BrowserNodeを開く
*parentNode.Expanded = true;

まずは、HTMLエンコードをする(既にエンコード済の文字が再エンコードされないように「&lt;」「&gt;」「"」だけエンコードする)
*motoData = motoData.Replace("<;","&amp;lt;").Replace(">;","&amp;gt;").Replace("\"","&amp;quot;");
&lt;b&gt;&lt;/b&gt;&lt;i&gt;&lt;/i&gt;&lt;br&gt;&lt;/font&gt;など属性のない許可タグ(と閉じタグ)を元に戻す
&amp;lt;(((/)?((b)|(i)))|(br)|(/font))&amp;gt;
→
&amp;lt;
(
(
(/)?((b)|(i))
)
|
(br)
|
(/font)
)
&amp;gt;
*Regex regex0 = new Regex("&amp;lt;(((/)?((b)|(i)))|(br)|(/font))&amp;gt;", RegexOptions.IgnoreCase | RegexOptions.Singleline);
fontタグのsizeとcolorだけ許可する
&amp;lt;font(( size=&amp;quot;[0-9]+&amp;quot;)|( color=&amp;quot;[a-z0-9#]+&amp;quot;))+&amp;gt;
→
&amp;lt;font
(
( size=&amp;quot;[0-9]+&amp;quot;)
|
( color=&amp;quot;[a-z0-9#]+&amp;quot;)
)+
&amp;gt;
*Regex regex1 = new Regex("&amp;lt;font(( size=&amp;quot;[0-9]+&amp;quot;)|( color=&amp;quot;[a-z0-9#]+&amp;quot;))+&amp;gt;", RegexOptions.IgnoreCase | RegexOptions.Singleline);

*c0.type = "Contact";
オブジェクト指定
XML作成
*System.Xml.XmlElement[] contactFields = new System.Xml.XmlElement[4];
氏
*contactFields[0] = doc.CreateElement("LastName");
名
*contactFields[1] = doc.CreateElement("FirstName");
勤務先
*contactFields[3] = doc.CreateElement("AccountId");
Email一致の場合UPDATE、それ以外の場合INSERT
*UpsertResult[] upsertResults = binding.upsert("Email", upserts);

トラッキングの処理効率を上げるために内部的には最大幅640pxのイメージとして処理する
この時、内部の_initRect, _boundingBox等は縮小したイメージで処理されるので、
publicメソッド内で復元して呼び出し元に返却する
*if (image.Width >; _MAX_IMAGE_WIDTH)
*if (area.HasValue)*{
指定エリアの外になったら抜ける

特に依存しているComponentはないです
*[SerializeField] private MicRecorder _micRecorder;
録音開始。これは別にCoroutineではない
*_micRecorder.StartRecord();
録音停止するときは処理をぜんぶ終える必要があるため、Coroutineの終了を待機してあげる
*yield return StartCoroutine(_micRecorder.StopRecord());
*Debug.Log($"Are you listening? {_micRecorder.IsRecording}");
録音中フラグだがMicRecorder.StopRecordを実行してから
*Debug.Log($"Are you listening? {_micRecorder.IsRecording}");
完全に終了するまでの間もfalseなのであんま信用してはいけない

*#nullable disable
ここ以下の行はnull許容参照型が無効になる(従来通り)

最初に完了したTaskが戻り値となる
*var completed = Task.WhenAny(heavyTask, Task.Delay(1000));
heavyTaskが完了したかどうか
heavyTask.IsCompletedを調べるのでもよい
*if (heavyTask == completed)

*using System.Runtime.InteropServices;
DllImport属性を使用するために必要
デバック時のみコンソールアプリを呼び出す
*[DllImport("kernel32.dll")]
コンソールアプリ表示（Nlogのコンソールへのログ出力が見えるようになります）
AllocConsole();以後は、
Console.ReadKey();　とかけば停止ができる。デバックで便利。キー押せば再開する。
*AllocConsole();

*int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);*// 目的のウィンドウを作成したスレッドのIDを取得
フォアグラウンドウィンドウを作成したスレッドのIDを取得
目的のウィンドウを作成したスレッドのIDを取得
*int targetID = GetWindowThreadProcessId(handle, out processId);
*AttachThreadInput(targetID, foregroundID, true);*// 現在の設定を timeout に保存
スレッドのインプット状態を結び付ける
現在の設定を timeout に保存
*SystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, timeout, 0);
ウィンドウの切り替え時間を 0ms にする
*SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, dummy, SPIF_SENDCHANGE);
ウィンドウをフォアグラウンドに持ってくる
*isSuccess = SetForegroundWindow(handle);
設定を元に戻す
*SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, timeout, SPIF_SENDCHANGE);
*AttachThreadInput(targetID, foregroundID, false);*return isSuccess;
スレッドのインプット状態を切り離す
*for (int i = 0; i <; 3; i++)*if (ForceActive(this.Handle)) break;
タスクバーが点滅しフォーカスはあるのに入力できない状態になるため
*for (int i = 0; i <; 3; i++)*if (ForceActive(helper.Handle)) break;
タスクバーが点滅しフォーカスはあるのに入力できない状態になるため

折り畳み部分を取得
*GameObject FoldinfImage;
折り畳み部分を表示するか非表示にするか
*bool OpenFold = false;
*RectTransform button;*VerticalLayoutGroup contentLayout;
ボタンの画像を回転
1フレーム停止
*yield return null;
再開後の処理
*contentLayout.enabled = false;

*BrowserNode node;
存在しているのに表示されていないBrowserNode
中略
node.DoSelect();        何も選択されない
_ = node.Expanded;      例外にならない
node.Expanded = false;  例外が送出される!!
*,,,

*string ToolTipText = "",
Ribbonのbuttonにポインタを合わせた時に表示されます。

*{}
Start is called before the first frame update
*{if (Delay >; 0){Delay -= Time.deltaTime;}else{if (isAnimation){CurrentTime += Time.deltaTime;float r = Mathf.Clamp01(CurrentTime / Duration);//EaseOutr = -r * (r - 2.0f);transform.localPosition = Vector3.Lerp(PrePosition, ToPosition, r);}else{transform.localPosition = ToPosition;}}}
Update is called once per frame

(中略)
*Form1 frm = new Form1();
*if (!inDesignMode)*{
Execute only outside of Visual Studio.

*{interactionEvents = m_inventorApplication.CommandManager.CreateInteractionEvents();interactionEvents.SelectEvents.OnPreSelect += SelectEvents_OnPreSelect;interactionEvents.SelectEvents.OnSelect += SelectEvents_OnSelect;//  selectEvents = interactionEvents.SelectEvents;interactionEvents.Start();}
private SelectEvents selectEvents;
(中略)
↓ これは通る(場合がある)
*someObject.ReferenceKeyManager.BindKeyToObject(ref byteArray1, 0, out dummy);
↓ ここで落ちる
*anotherObject.ReferenceKeyManager.BindKeyToObject(ref byteArray2, 0, out dummy);
(中略)
↓ OK
*dummy = null;
ここで、objは常にnullのはずだが、3Dスケッチから抜けたときだけは、nullではない。
フィーチャーもしくはスケッチが編集中かどうかを、
ActiveEditDocument.ActivatedObject == nullで判断すると、バグる。
代わりに、EditObjectがDocumentかどうかで判断することで、回避する。
*}

クライアントからLock scriptの文字列を受け取る
*string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
ScriptクラスへLock scriptを渡す
*Script redeemScript = new Script(requestBody);
P2SH形式のビットコインアドレスを生成する
*BitcoinAddress address = redeemScript.Hash.GetAddress(Network.Main);
生成されたビットコインアドレスを返す
*return address != null
トランザクションをブロードキャストするか否かのフラグ
*bool broadcast = (req.Query["b"] == "1");
クライアントからのパラメータを受け取る
*string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
chain.soでビットコインアドレスのUTXOを取得する
WebRequest request = WebRequest.Create("https:chain.so/api/v2/get_tx_unspent/" + network + "/" + btcAddress);
*WebResponse response = request.GetResponse();
半角スペース区切りでOPコードを取得する
*String[] unlockingScripts = unlockingScript.Split(" ", StringSplitOptions.RemoveEmptyEntries);
*Op[] ops = new Op[] {};
OPコードを格納する配列
*if (transaction.Inputs.AsIndexedInputs().First().VerifyScript(hallOfTheMakersAddress.ScriptPubKey) == false)*{
ここでパズルの答え合わせをしてる

コネクション作成
*MySqlConnection cn = new MySqlConnection("Server=＜値＞;Database=＜値＞;Uid=＜値＞;Pwd=＜値＞;Port=3306;");
cn.Openがないサンプル結構あるが、これを書かずにcmd.ExecuteReader行うと例外になりコネクション系の沼にはまる
世の中には、cn.Open()で済む話をcmd.ExecuteReaderが使えないバグと称して嘘を書いているものがあるので注意
*cn.Open();
*if (reader.HasRows)*{
readerでは件数は取得できないが、HasRowsでレコード有無だけわかる

*private Sprite sprite;
一時キャッシュ用
*{foreach (Image img in FindObjectsOfType<;Image>;()){//シーン上に存在し、spriteが割り当てられているかif (img.gameObject.activeInHierarchy &amp;&amp; img.sprite != null){sprite = img.sprite;img.sprite = null;img.sprite = sprite;}}}
Update、FixedUpdate、OnRenderObjectだと修正前の画像が一瞬見えてしまう(特にコルーチン)
*if (img.gameObject.activeInHierarchy &amp;&amp; img.sprite != null)*{
シーン上に存在し、spriteが割り当てられているか

*{// バージョン情報static public readonly Version version = new Version(1, 2, 2);// 製作者名static public readonly string maker = "HitsujiRere";// 接頭辞と初期値のディクショナリstatic public Dictionary<;char, bool>; prefixs = new Dictionary<;char, bool>;(){['&amp;'] = true,['@'] = false,};// 演算子と計算のディクショナリstatic public Dictionary<;string, Func<;double, string[], double>;>; operatorsOf1 =new Dictionary<;string, Func<;double, string[], double>;>;(){["=%"] = (a, _) =>; a * 0.01,["-%"] = (a, _) =>; a * 100.0,["++"] = (a, _) =>; a + 1.0,["--"] = (a, _) =>; a - 1.0,["*-"] = (a, _) =>; a * -1.0,["sq"] = (a, _) =>; a * a,["sqrt"] = (a, _) =>; Math.Sqrt(a),["bx"] = (a, _) =>; a * a * a,["bxrt"] = (a, _) =>; Math.Pow(a, 1.0 / 3.0),};static public Dictionary<;string, Func<;double, double, string[], double>;>; operatorsOf2 =new Dictionary<;string, Func<;double, double, string[], double>;>;(){["+"] = (a, b, _) =>; a + b,["-"] = (a, b, _) =>; a - b,["*"] = (a, b, _) =>; a * b,["/"] = (a, b, _) =>; a / b,["%"] = (a, b, _) =>; a % b,["mod"] = (a, b, _) =>; a % b,["div"] = (a, b, _) =>; (a - (a % b)) / b,["^"] = (a, b, _) =>; Math.Pow(a, b),};static public Dictionary<;string, Func<;double[], string[], double>;>; operatorsAll =new Dictionary<;string, Func<;double[], string[], double>;>;(){["cnt"] = (a, _) =>; a.Count(),["sum"] = (a, _) =>; a.Sum(),["ave"] = (a, _) =>; a.Average(),};// 命令と計算のディクショナリstatic public Dictionary<;string, Action<;Calculator, string[]>;>; instructions =new Dictionary<;string, Action<;Calculator, string[]>;>;(){["sort"] = (calc, _) =>;{calc.numStack = new Stack<;double>;(calc.numStack.OrderBy(x =>; x));},["rev"] = (calc, _) =>;{calc.numStack = new Stack<;double>;(calc.numStack);},["clr"] = (calc, _) =>; { calc.numStack.Clear(); },["help"] = (calc, _) =>;{Console.WriteLine("特殊な接頭辞");Prints(prefixs.Select(x =>; x.Key.ToString()));Console.WriteLine("1項演算子");Prints(operatorsOf1.Select(x =>; x.Key));Console.WriteLine("2項演算子");Prints(operatorsOf2.Select(x =>; x.Key));Console.WriteLine("全てへの演算子");Prints(operatorsAll.Select(x =>; x.Key));Console.WriteLine("命令");Prints(instructions.Select(x =>; x.Key));void Prints(IEnumerable<;string>; a){foreach (var item in a){Console.WriteLine("{0,6} = {1}", item,comments.ContainsKey(item) ? comments[item] : "not found");}Console.WriteLine();}},["xvar"] = (calc, names) =>;{foreach (var name in names){if (!calc.variables.ContainsKey(name)){calc.variables[name] = 0.0;}}},["xin"] = (calc, names) =>;{foreach (var name in names){if (calc.numStack.Count >;= 1){calc.variables[name] = calc.numStack.Pop();}}},["xout"] = (calc, names) =>;{foreach (var name in names){if (calc.variables.ContainsKey(name)){calc.numStack.Push(calc.variables[name]);}}},["xcout"] = (calc, _) =>;{foreach (var item in calc.variables){Console.WriteLine("{0,6} = {1}", item.Key, item.Value);}Console.WriteLine();},};// 接頭辞,演算子,命令についての説明static public Dictionary<;string, string>; comments =new Dictionary<;string, string>;(){["&amp;"] = "計算のために取得した数字を削除しない",["@"] = "全ての数に対して演算を行う（実装中）",["=%"] = "前の数値を、パーセント数値にする（*100する）",["-%"] = "前のパーセント数値を、数値にする（*0.01する）",["++"] = "前の数字を、+1する",["--"] = "前の数字を、-1する",["*-"] = "前の数字を、*(-1)する",["sq"] = "前の数字を、平方する",["sqrt"] = "前の数字を、平方根にする",["bx"] = "前の数字を、立方する",["bxrt"] = "前の数字を、立方根にする",["+"] = "前の数字2つを、足し算する",["-"] = "前の数字2つを、引き算する",["*"] = "前の数字2つを、掛け算する",["/"] = "前の数字2つを、割り算する",["%"] = "前の数字2つを、割り算し、その余りをとる",["mod"] = "前の数字2つを、割り算し、その余りをとる",["div"] = "前の数字2つを、割り算し、その商をとる",["^"] = "前の数字2つを、累乗する",["cnt"] = "前の数字全てを、計数する",["sum"] = "前の数字全てを、合計する",["ave"] = "前の数字全てを、平均する",["sort"] = "数値スタックを、昇順にソートする",["rev"] = "数値スタックを、順序逆転する",["clr"] = "数値スタックを、全て消去する",["help"] = "演算子,命令の一覧,説明を、出力する",["xvar"] = "変数を登録する",["xin"] = "前の数字を、変数に入れる",["xout"] = "変数を数値Stackに入れる",["xcout"] = "全ての変数とその値を出力する",};// 数値を入れておくスタックpublic Stack<;double>; numStack = new Stack<;double>;();// 変数のディクショナリpublic Dictionary<;string, double>; variables =new Dictionary<;string, double>;();// 計算もしくは数字を追加するpublic bool PassString(string[] txts){var main = txts[0];var options = txts.Skip(1).ToArray();// 演算子が有効かどうかvar havePrefixs = new Dictionary<;char, bool>;(prefixs);// 先頭に接頭辞が見つからなくなるまで繰り返すvar isContain = true;while (isContain){if (havePrefixs.ContainsKey(main[0])){havePrefixs[main[0]] ^= true;main = main.Substring(1);isContain = true;}else{isContain = false;}}if (numStack.Count >;= 1 &amp;&amp; operatorsOf1.ContainsKey(main)){var num = havePrefixs['&amp;'] ? numStack.Pop() : numStack.Peek();numStack.Push(operatorsOf1[main](num, options));return true;}else if (numStack.Count >;= 2 &amp;&amp; operatorsOf2.ContainsKey(main)){var num1 = havePrefixs['&amp;'] ? numStack.Pop() : numStack.Peek();var num2 = havePrefixs['&amp;'] ? numStack.Pop() : numStack.Peek();numStack.Push(operatorsOf2[main](num2, num1, options));return true;}else if (operatorsAll.ContainsKey(main)){var nums = numStack.ToArray();if (havePrefixs['&amp;'])numStack.Clear();numStack.Push(operatorsAll[main](nums, options));return true;}else if (instructions.ContainsKey(txts[0])){instructions[main](this, options);return true;}else if (double.TryParse(main, out var num)){numStack.Push(num);return true;}else if (variables.ContainsKey(main)){numStack.Push(variables[main]);return true;}return false;}public bool PassString(string word){var elements = word.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries);return PassString(elements);}// txtsを順に計算もしくは数字を追加するpublic double[] PassStrings(string[] words, bool debug = false){bool existNotFound = false;foreach (var word in words){if (PassString(word.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries))){if (debug){Console.Write("= ");if (numStack.Count >; 0){foreach (var num in numStack.Reverse()){Console.Write("{0}, ", num);}Console.Write('\n');}else{Console.WriteLine("nothing");}}}else{Console.WriteLine("{0} is not found", word);existNotFound = true;}}if (debug || existNotFound){Console.WriteLine();}return numStack.Reverse().ToArray();}// txtの命令を実行するpublic bool Instruction(string words){var word = words.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries);if (instructions.ContainsKey(word[0])){instructions[word[0]](this, word.Skip(1).ToArray());return true;}return false;}}
計算機
バージョン情報
*static public readonly Version version = new Version(1, 2, 2);
製作者名
*static public readonly string maker = "HitsujiRere";
*{['&amp;'] = true,['@'] = false,};
接頭辞と初期値のディクショナリ
演算子と計算のディクショナリ
*static public Dictionary<;string, Func<;double, string[], double>;>; operatorsOf1 =
命令と計算のディクショナリ
*static public Dictionary<;string, Action<;Calculator, string[]>;>; instructions =
接頭辞,演算子,命令についての説明
*static public Dictionary<;string, string>; comments =
数値を入れておくスタック
*public Stack<;double>; numStack = new Stack<;double>;();
変数のディクショナリ
*public Dictionary<;string, double>; variables =
*{var main = txts[0];var options = txts.Skip(1).ToArray();// 演算子が有効かどうかvar havePrefixs = new Dictionary<;char, bool>;(prefixs);// 先頭に接頭辞が見つからなくなるまで繰り返すvar isContain = true;while (isContain){if (havePrefixs.ContainsKey(main[0])){havePrefixs[main[0]] ^= true;main = main.Substring(1);isContain = true;}else{isContain = false;}}if (numStack.Count >;= 1 &amp;&amp; operatorsOf1.ContainsKey(main)){var num = havePrefixs['&amp;'] ? numStack.Pop() : numStack.Peek();numStack.Push(operatorsOf1[main](num, options));return true;}else if (numStack.Count >;= 2 &amp;&amp; operatorsOf2.ContainsKey(main)){var num1 = havePrefixs['&amp;'] ? numStack.Pop() : numStack.Peek();var num2 = havePrefixs['&amp;'] ? numStack.Pop() : numStack.Peek();numStack.Push(operatorsOf2[main](num2, num1, options));return true;}else if (operatorsAll.ContainsKey(main)){var nums = numStack.ToArray();if (havePrefixs['&amp;'])numStack.Clear();numStack.Push(operatorsAll[main](nums, options));return true;}else if (instructions.ContainsKey(txts[0])){instructions[main](this, options);return true;}else if (double.TryParse(main, out var num)){numStack.Push(num);return true;}else if (variables.ContainsKey(main)){numStack.Push(variables[main]);return true;}return false;}
計算もしくは数字を追加する
演算子が有効かどうか
*var havePrefixs = new Dictionary<;char, bool>;(prefixs);
先頭に接頭辞が見つからなくなるまで繰り返す
*var isContain = true;
*{bool existNotFound = false;foreach (var word in words){if (PassString(word.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries))){if (debug){Console.Write("= ");if (numStack.Count >; 0){foreach (var num in numStack.Reverse()){Console.Write("{0}, ", num);}Console.Write('\n');}else{Console.WriteLine("nothing");}}}else{Console.WriteLine("{0} is not found", word);existNotFound = true;}}if (debug || existNotFound){Console.WriteLine();}return numStack.Reverse().ToArray();}
txtsを順に計算もしくは数字を追加する
*{var word = words.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries);if (instructions.ContainsKey(word[0])){instructions[word[0]](this, word.Skip(1).ToArray());return true;}return false;}
txtの命令を実行する
計算機
*var calc = new Calculator();
下のwhileを繰り返すかどうか
*var isRepeat = true;
*var inputs = Console.ReadLine().Split(new[] { ' ', ',' }, StringSplitOptions.RemoveEmptyEntries);
コマンドから入力したものを' '（空白）もしくは','で分割する
分割した入力配列を渡す
*var nums = calc.PassStrings(inputs, debug: false);

*this.Loading.SetActive (false);
クルクルを非表示
*private void OnDestroy () {if (this.Texture2D) { Destroy (this.Texture2D); }if (this.Sprite) { Destroy (this.Sprite); }}
自分が消えるときには、作ったデータも消す

スタートからクリア判定を置く
isClear = true;
*}
*if(GamePlaying.isClear){*Debug.Log("isClear が true なのでクリアしてる状態です");
ゲーム結果画面でGamePlayingの変数を読み込み
*void Update () {if (Input.GetMouseButtonDown (0)) {SceneManager.LoadScene ("GameResult");}}
クリックしたら「GameResult」に遷移
オブジェクトを名前で探す
*GameObject resultObj = GameObject.Find ("ResultObject");
変数「test」を参照しDebug.Logに出力
*Debug.Log (resultObj.GetComponent<;GamePlaying>; ().test);
*resultObj.transform.position = new Vector3 (*resultObj.transform.position.x,
オブジェクトの位置情報を変更
「SCORE」というキーで、Int値の「20」を保存
*PlayerPrefs.SetInt("SCORE", 20);
「SCORE」というキーで保存されているInt値を読み込み
*int resultScore = PlayerPrefs.GetInt("SCORE");

出力結果
1.23399996757507
1.23399996757507
1.234
*,,,

*public DelegateCommand ButtonCommand { get; }
ボタン押下時処理
★〇の色を切り替えるためのフラグ
*private bool _colorChangeFlag = false;
*{this.ButtonCommand = new DelegateCommand(() =>;{// ★ボタンをおしたら、フラグが切り替わるColorChangeFlag = !ColorChangeFlag;});}
コンストラクタ
★ボタンをおしたら、フラグが切り替わる
*ColorChangeFlag = !ColorChangeFlag;
*public IRegionManager RegionManager { get; set; }
--------- Prismお決まり部分 -------------

*await Task.Delay(200);
指定時間のwait
タスクを実行、完了まで待機
*task.Wait();

*{/// <;summary>;content_mainページ表示用ボタン<;/summary>;private Button BtnShowContent { get; set; }/// <;summary>;activity_mainページ表示用ボタン<;/summary>;private Button BtnShowActivity { get; set; }/// <;summary>;アプリ起動時<;/summary>;/// <;param name="savedInstanceState">;<;/param>;protected override void OnCreate(Bundle savedInstanceState){base.OnCreate(savedInstanceState);Xamarin.Essentials.Platform.Init(this, savedInstanceState);// 初期ページを表示SetContentView(Resource.Layout.activity_main);// contentページ表示ボタンBtnShowContent = FindViewById<;Button>;(Resource.Id.btn_show_content_main_page);BtnShowContent.Click += BtnShowContent_Click;}/// <;summary>;contentページ表示イベント<;/summary>;/// <;param name="sender">;<;/param>;/// <;param name="e">;<;/param>;private void BtnShowContent_Click(object sender, EventArgs e){SetContentView(Resource.Layout.content_main);// activityページ表示ボタンBtnShowActivity = FindViewById<;Button>;(Resource.Id.btn_show_activity_main_page);BtnShowActivity.Click += BtnShowActivity_Click;}/// <;summary>;activityページ表示イベント<;/summary>;/// <;param name="sender">;<;/param>;/// <;param name="e">;<;/param>;private void BtnShowActivity_Click(object sender, EventArgs e){SetContentView(Resource.Layout.activity_main);// contentページ表示ボタンBtnShowContent = FindViewById<;Button>;(Resource.Id.btn_show_content_main_page);BtnShowContent.Click += BtnShowContent_Click;}//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,初期ページを表示
*SetContentView(Resource.Layout.activity_main);
contentページ表示ボタン
*BtnShowContent = FindViewById<;Button>;(Resource.Id.btn_show_content_main_page);
activityページ表示ボタン
*BtnShowActivity = FindViewById<;Button>;(Resource.Id.btn_show_activity_main_page);
contentページ表示ボタン
*BtnShowContent = FindViewById<;Button>;(Resource.Id.btn_show_content_main_page);

指定した座標のグラフ要素を保持するオブジェクト
*private HitTestResult hit = null;
*{return checkBox1.Checked &amp;&amp; seriesName == "Border";}
直線状態のBorderをクリックしたか
マウス座標上にヒットしたグラフ要素を取得し、それがDataPointかつ存在するものかチェックする
*HitTestResult test = chart1.HitTest(e.X, e.Y);
NOTE:マウスの座標の範囲チェックをしないと例外が出る
*double dx = ca.AxisX.PixelPositionToValue(e.X);
全ての線を移動させる
*var points = hit.Series.Points;
取得したグラフ要素を捨てる
*hit = null;
*foreach (var point in points)*{
Borderの最大Y軸に全データを合わせる
クリックしたX軸のデータをBorder以下のY軸にする
*var point = points.Where(v =>; v.XValue == curPoint.XValue).FirstOrDefault();
Borderの全Pointを最大値に合わせる（直線にする）
*var points = chart1.Series["Border"].Points;

*page.Orientation = PageOrientation.Landscape;
用紙の向き

*Response.Redirect(openfilename);
PDFに遷移

*public Int32 Add([MarshalAs(UnmanagedType.BStr)]string str)
★マーシャリングする！

*.Where(i =<; "" == i.description.Substring(0, 1)).ToList();
OK

https:localhost:&lt;ポート番号&gt;/&lt;コントローラ名&gt;/&lt;アクション名&gt; で発火
https:localhost:&lt;ポート番号&gt;/Hello で発火
*public IActionResult Index()
cshtml ファイル (View) に向けて値を受け渡す
ViewBag や ViewData を使ってデータをやり取りする
*ViewBag.Message = "Here is 'Hello/Index.cshtml'";
*{ViewBag.Message = "Hello World!";// Views/Hello/Index.cshtml に処理を反映させるreturn View("Index");}
https:localhost:&lt;ポート番号&gt;/Hello/sayHello で発火
Views/Hello/Index.cshtml に処理を反映させる
*return View("Index");

*{NONE = 0,WEEK = 1000,MIDDLE = 2000,STRONG = 4000}
振動の強さ三段階
*if (debug)*{
デバッグ用 (どんぐらいの強さかな～?)
振動メソッドたち
パターン①
*public void ControllerHaptic()
*{float seconds = (float)hapicPower / 1000000f;hapicAction.Execute(0, seconds, 1f / seconds, 1, handType);}
パターン②
*{float seconds = (float)microSecondsDuration / 1000000f;hapicAction.Execute(0, seconds, 1f / seconds, 1, handType);}
パターン③
パターン①
*ControllerHaptic();
パターン②
*ControllerHaptic(HapicPower.STRONG)
パターン③
*ControllerHaptic(3200);

*Company newCompanyA = companyA.DeepClone();
会社データ(新)A[会社データ(旧)Aを詳細コピー]
社長→山田太郎Jrに変更、社員から山田太郎Jrを削除
*newCompanyA.ceo = personD;
*foreach (Person employee in newCompanyA.employee)*{
従業員の名前をすべて取得しデータ作成用リストに追加する
*//{//    tempList.Add(null);//}
今回は空データはスキップするが、必要に応じてListに空データを追加する
*//{//    tempList.Add(null);//}
else
*Console.Write("会社名 {0}(新) 社長:{1} 社員: {2} \r\n", newCompanyA.name, newCompanyA.ceo.name, commonClass.NullCheck(string.Join(", ", nameList2)));
出力

この辺でもなんかやる
最後に1個だけ非同期メソッドを呼ぶ
*await DoSomethingAsync();
この辺でもなんかやる
直接Taskを返すとちょっと速い
*return DoSomethingAsync();
この辺でもなんかやる
*return thing.DoAsync();
この辺でもなんかやる
*return thing.DoAsync();
この辺でもなんかやる
*var ret = thing.DoAsync();
finallyの中身はreturnの前に実行される
*thing.Dispose();
ObjectDisposedExceptionで死ぬ
死ぬタイミングは thing.DoAsync() の中身次第
*return ret;
この辺でもなんかやる
これならDoAsync()が終わった後にDispose()される
*await thing.DoAsync();

FaceInfoクラスのリストを仕分け
*List<;FaceInfo>; faceInfoBaseList = faceInfoList.Where(x =>; x.faceDivision == DIVISION_BASE).ToList();
比較元画像の表示
*ShowImage(urlBase, faceInfoBaseList);
比較先画像の表示
*ShowImage(urlTarget, faceInfoTargetList);
*{foreach (FaceInfo faceInfo in faceInfoList){// 顔の検出箇所に赤枠を表示Rect rect = new Rect(faceInfo.recLeft, faceInfo.recTop, faceInfo.recWidth, faceInfo.recHeight);Cv2.Rectangle(image, rect, new Scalar(0, 0, 255), 2);// FaceIDを描画Cv2.PutText(image, faceInfo.faceId, new Point(faceInfo.recLeft, faceInfo.recTop), HersheyFonts.HersheyComplexSmall, 1, new Scalar(255, 0, 255), 1, LineTypes.AntiAlias);}Cv2.ImShow(url, image);Cv2.WaitKey(0);}
画像の読み込み
顔の検出箇所に赤枠を表示
*Rect rect = new Rect(faceInfo.recLeft, faceInfo.recTop, faceInfo.recWidth, faceInfo.recHeight);
FaceIDを描画
*Cv2.PutText(image, faceInfo.faceId, new Point(faceInfo.recLeft, faceInfo.recTop)
FindSimilarのパラメータとなるfaceId、その他を取得
*List<;FaceInfo>; faceInfoList = FaceDetect.Detect(imageUrls);
追加箇所 From----------------------------------------
*dispImageByOpenCV(URL_BASE, URL_TARGET, faceInfoList);
追加箇所 To------------------------------------------
*}
追加箇所 From----------------------------------------
*Cv2.DestroyAllWindows();
追加箇所 To------------------------------------------
*}
リクエストヘッダー
*client.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", ConfigurationManager.AppSettings["subscriptionKey"]);
*foreach (FaceInfo faceInfoTarget in faceInfoList.FindAll(x =>; x.faceDivision == DIVISION_TARGET))*{
FindSimilarの第二引数（faceIds）作成
リクエストボディをJSON形式にする
*MatchFaceSimilar matchFaceSimilar = new MatchFaceSimilar(faceInfoBase.faceId, targetFaceIdList.ToArray());
リクエストヘッダーの作成
*content.Headers.ContentType = new MediaTypeHeaderValue("application/json");
実行結果からJSONの取得
*var contentString = await response.Content.ReadAsStringAsync();
JSONを整形して出力
*List<;FaceConfidence>; faceConfidence = JsonConvert.DeserializeObject<;List<;FaceConfidence>;>;(contentString);

*var millisec = ts.Milliseconds;
ミリ秒
計測した時間の合計をミリ秒で取得
*var millisec2 = sw.ElapsedMilliseconds;
続きから計測する場合は再度Start()を呼ぶ
sw.Start();
0から再度計測する場合はReset()を呼んだあとにStart()を呼ぶ
sw.Reset();
sw.Start();
*}

*Hoge hoge = x =<; Debug.Log(x);
これがラムダ式
引数 =&gt; 処理の流れがあれば基本動く
Hogeは絶対に引数にstringとるからラムダ式での引数も勝手にstringになる
これだけ覚えとけばなんとかなる
*hoge("Hello World!!");

コンテキストの生成
*MLContext mlContext = new MLContext(seed: 1);
データのロード
*string dataPath = @".\Data\winequality-red.csv";
学習データとテストデータに分割
*var split = mlContext.Data.TrainTestSplit(data, testFraction: 0.2, seed: 0);
学習パイプラインの定義
学習データの定義
*var dataProcessPipeline = mlContext.Transforms.Concatenate(
学習アルゴリズムの定義
*var trainer = mlContext.Regression.Trainers.Sdca(labelColumnName: nameof(WineQualityData.Quality), featureColumnName: "Features");
学習アルゴリズムをパイプラインに設定
*var trainingPipeline = dataProcessPipeline.Append(trainer);
学習データを用いて学習モデルを生成
*var trainedModel = trainingPipeline.Fit(split.TrainSet);
テストデータによるモデルの評価
生成した学習モデルにテストデータを設定
*IDataView predictions = trainedModel.Transform(split.TestSet);
*Console.WriteLine($"*   損失関数(LossFn): {metrics.LossFunction}");
学習モデルの評価
学習モデルをファイルに保存
*mlContext.Model.Save(trainedModel, split.TrainSet.Schema, modelFilePath);
*ITransformer model = mlContext.Model.Load(modelFilePath, out DataViewSchema inputSchema);*//推論エンジンの生成
学習モデルのロード
推論エンジンの生成
*var predictionEngine = mlContext.Model.CreatePredictionEngine<;WineQualityData, WineQualityPrediction>;(model);
*{//TODO: 各属性の設定//FixedAcidity = ....};
各説明変数を定義したオブジェクトを生成
TODO: 各属性の設定
FixedAcidity = ....
*};
推論の実行
*WineQualityPrediction predictionResult = predictionEngine.Predict(wineQualityData);

*{int flg = -1;var dialog = new OpenFileDialog();dialog.ShowDialog();string filePath = dialog.FileName;//MessageBox.Show(filePath);if (optWhite.Checked == true) { flg = 0; }if (optYellow.Checked == true) { flg = 1; }if (optBlue.Checked == true) { flg = 2; }if (optRed.Checked == true) { flg = 3; }if (optGreen.Checked == true) { flg = 4; }if (optOrange.Checked == true) { flg = 5; }wholeCube.SetColors(flg, Python.ReadColors(flg.ToString()));RefreshView();}
フォーム上のクリックイベント
*if (optWhite.Checked == true) { flg = 0; }*if (optYellow.Checked == true) { flg = 1; }
MessageBox.Show(filePath);
*{public static string ReadColors(string filePath){return ReadDummyColors(filePath);}private static string ReadDummyColors(string filePath){string ret = "";if (filePath == "0") { ret = "000000000"; }else if (filePath == "1") { ret = "111111111"; }else if (filePath == "2") { ret = "222222222"; }else if (filePath == "3") { ret = "333333333"; }else if (filePath == "4") { ret = "444444444"; }else if (filePath == "5") { ret = "555555555"; }return ret;}}
共通関数側の呼び出し処理(スタブ)

*sp.Close();
シリアルポートのクローズ

*const string DIVISION_TARGET = "target";
区分：比較先
Face DetectからfaceIdその他を取得
*List<;FaceInfo>; faceInfoList = FaceDetect.Detect(imageUrls);

*Update(userId, newPassword);
コンパイルエラー
*if (!Check(userId, oldPassword))*{
チェック処理を組み込んだ
パスワードをチェックしたいときはCheckメソッドを使う
*PasswordUtil.Check("001", "password");
パスワードを変更したいときはUpdateメソッドを使う
*PasswordUtil.Update("001", "password", "new_password");

*foo = null;
この行はコンパイルエラー

*public DelegateCommand LoadedCommand { get; }
★ボタンのコマンドをやめて、Loaded時のコマンドにした

アプリ起動時処理
*Debug.Log("initialize AR camera manager frame received");
AR起動時処理
*this.arRaycastManager = GetComponent<;ARRaycastManager>;();
物体認識
*this.objectDetector = goObjectDetector.GetComponent<;TinyYolo3Detector>;();
関連語REST APIクライアント
*this.similarWordClient = goSimilarWordClient.GetComponent<;SimilarWordClient>;();
*if (Input.touchCount >; 0)*{
画面タッチでカメラに写っているものを物体認識する
*if (this.detectedSimilarWordsQueue.Count() >; 0)*{
関連語の表示
*{if (!arCameraManager.TryAcquireLatestCpuImage(out XRCpuImage image)){return;}var conversionParams = new XRCpuImage.ConversionParams{inputRect = new RectInt(0, 0, image.width, image.height),outputDimensions = new Vector2Int(image.width, image.height),outputFormat = TextureFormat.RGBA32,transformation = XRCpuImage.Transformation.None};int imageSize = image.GetConvertedDataSize(conversionParams);var buffer = new NativeArray<;byte>;(imageSize, Allocator.Temp);image.Convert(conversionParams, new IntPtr(buffer.GetUnsafePtr()), buffer.Length);image.Dispose();this.m_Texture = new Texture2D(conversionParams.outputDimensions.x,conversionParams.outputDimensions.y,conversionParams.outputFormat,false);this.m_Texture.LoadRawTextureData(buffer);this.m_Texture.Apply();buffer.Dispose();Detect();}
ARカメラの画像を取得
*{if (this.isDetecting){return;}if (this.detectionTargetQueue.Count() == 0){return;}var detectionTarget = this.detectionTargetQueue.Dequeue();this.isDetecting = true;StartCoroutine(ProcessImage(this.objectDetector.IMAGE_SIZE, detectionTarget.CurrentTexture2D, picture =>;{StartCoroutine(this.objectDetector.Detect(picture, itemsDetected =>;{if (itemsDetected.Count >; 0){var detected = new Detected{HitPose = detectionTarget.HitPose,ItemsDetected = itemsDetected,};this.detectedQueue.Enqueue(detected);}Resources.UnloadUnusedAssets();this.isDetecting = false;}));}));}
物体認識
*{if (this.detectedQueue.Count()==0){return;}var detected = this.detectedQueue.Dequeue();StartCoroutine(this.similarWordClient.SimilarWordAPI(detected.ItemsDetected[0].PredictedItem.Label, 20, results =>;{Debug.Log($"result {results}");var detectedSimilarWords = new DetectedSimilarWords{HitPose = detected.HitPose,SimilarWords=results,};this.detectedSimilarWordsQueue.Enqueue(detectedSimilarWords);}));}
関連語をリクエスト
*{EN,JP};
ラベルの言語。英語or日本語
Coroutineで物体認識を実行
*Debug.Log("Run detection");

*System.Array.Resize( ref planes, 4 );
near,far面を排除
*if ( GeometryUtility.TestPlanesAABB( planes, bounds ) ) {*// 入った！！
内外判定
入った！！
*}

*}
...

*{if (string.IsNullOrEmpty(instanceName))throw new ArgumentNullException(nameof(instanceName));try{using (var controller = new ServiceController($"MSSQL${instanceName}", ".")){if (controller.Status == ServiceControllerStatus.Stopped){controller.Start();controller.WaitForStatus(ServiceControllerStatus.Running);}return controller.Status;}}catch{throw;}}
using System.ServiceProcess;

*{AutomationElement mainForm = null;String message = "茜ちゃん、かわいい！やったー！";foreach (var p in Process.GetProcesses()){if (p.MainWindowTitle.Contains("VOICEROID2")){mainForm = AutomationElement.FromHandle(p.MainWindowHandle);}}if (mainForm == null){Debug.WriteLine("起動してない");return;}{var elems = mainForm.FindAll(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.ClassNameProperty, "TextBox"));ValuePattern txtboxName = elems[0].GetCurrentPattern(ValuePattern.Pattern) as ValuePattern;txtboxName.SetValue(message);}{var elems = mainForm.FindAll(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.ClassNameProperty, "Button"));InvokePattern btn = elems[0].GetCurrentPattern(InvokePattern.Pattern) as InvokePattern;btn.Invoke();}AutomationElementCollection stsMessage;do{Thread.Sleep(500);stsMessage = mainForm.FindAll(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.NameProperty, "テキストの読み上げは完了しました。"));} while (stsMessage.Count == 0);}
UIAutomationを使用します。

*runner.StateMachine = stateMachine;
set after create delegate.

コネクションのクローズ
*_connection.Close();
コネクションのオープン
*_connection = new NpgsqlConnection(_connInfo);
*if (String.IsNullOrEmpty(query))*{
EventLog.WriteEntry(EVENT_LOG_NAME, "BeginExecuteQuery", EventLogEntryType.Information, 1, 100, null);
*//EventLog.WriteEntry(EVENT_LOG_NAME, formatQuery, EventLogEntryType.Information, 1, 100, null);*// SQL実行&amp;結果取得
EventLog.WriteEntry(EVENT_LOG_NAME, "RunQuery", EventLogEntryType.Information, 1, 100, null);
*NpgsqlCommand command = new NpgsqlCommand(formatQuery, _connection);*String data = null;
SQL実行&amp;結果取得

*DateTime dt = new DateTime("2021
0423");  エラー

*ConditionExpression = "attribute_not_exists(Id)"
重複時は作成不可
*{Put = new Put{TableName = "Log",Item = new Dictionary<;string, AttributeValue>;(){{"Id", new AttributeValue {S = /* ID */ }},{"DateTimeStr", new AttributeValue {S = /* 操作日時 */ }},{"Operation", new AttributeValue {S = /* 操作内容 */ }}}}}
ログテーブルへの書き込み

*private ManualResetValueTaskSourceCore<;T<; _core;
mutable struct; do not make this readonly
*{if (_Worker.IsCompleted || _Worker.IsCanceled){throw new Exception("thread already stopped");}var vts = _Pool.Get();vts.SetPool(_Pool);vts.Reset();// System.Threading.ChannelsにIValueTaskSourceのインスタンスを渡すif (!_Channel.Writer.TryWrite(vts)){throw new Exception("failed to write to channel");}return new ValueTask<;int>;(vts, vts.Version);}
ValueTaskの生成
*if (!_Channel.Writer.TryWrite(vts))*{
System.Threading.ChannelsにIValueTaskSourceのインスタンスを渡す
*{try{while (!_Cts.IsCancellationRequested){if (!await _Channel.Reader.WaitToReadAsync().ConfigureAwait(false)){break;}while (!_Cts.IsCancellationRequested &amp;&amp; _Channel.Reader.TryRead(out var item)){item.SetResult(1);}}}catch (Exception e){Console.WriteLine(e);}}
ワーカースレッド

*{// ヒープからのアロケーションが発生しないvar s = new S();}
...
ヒープからのアロケーションが発生しない
*var s = new S();
*{_ = s.Value;}
structをそのまま引数に取る
*{_ = s.Value;}
interfaceで受け取る
アロケーションなし
*HogeS(s);
アロケーションあり!
*HogeI(s);
引数をジェネリックなTStoreに変更
TStoreにIStore&lt;T&gt;制約をかけるためにTも型引数とする必要がある
*public static void HogeG<;TStore, T>;(TStore s)
アロケーションなし
*HogeS(s);
アロケーションあり!
*HogeI(s);
アロケーションなし
*HogeG<;IStore<;int>;, int>;(s);
型引数が推論できずにエラー
メソッド 'A.HogeG&lt;TStore, T&gt;(TStore)' の型引数を使い方から推論することはできません。型引数を明示的に指定してください。
HogeG(s);
*}
Tを引数に取るとTのサイズ分のスタックの確保とコピーが発生してしまう
そもそもTの値をどうやって取得するのかという問題がある
*public static void HogeG<;TStore, T>;(TStore s, T __)
第二引数にTypeHint&lt;T&gt;をとるが推論にのみ用いる
*public static void HogeG<;TStore, T>;(TStore s, TypeHint<;T>; __ = default)
Store&lt;T&gt;からTypeHint&lt;T&gt;を取得するメソッド
*public static TypeHint<;T>; GetTypeHint<;T>;(Store<;T>; _) =>; default;
型引数を書かなくてよい!!
*HogeG(s, GetTypeHint(s));
TypeHintを渡さないと推論できずにエラー...
HogeG(s);
ついでにIStore&lt;T&gt;.Valueの型のデフォルト値の変数を作ることもできる
*var v = GetTypeHint(s).Default;
*{public TypeHint<;T1>; Arg1 =>; default;public TypeHint<;T2>; Arg2 =>; default;}
型情報を提供するstruct
二つの異なる型のIStoreを取る
*public static void HogeG<;TStore1, T1, TStore2, T2>;(TStore1 store1, TStore2 store2, TypeHint<;T1, T2>; __ = default)
1型引数のTypeHintから2型引数のTypeHintを作る
*public static TypeHint<;T1, T2>; CreateTypeHint<;T1, T2>;(TypeHint<;T1>; _, TypeHint<;T2>; __) =>; default;
型引数を書かなくてよい!!
*HogeG(s1, s2, CreateTypeHint(GetTypeHint(s1), GetTypeHint(s2)));
こんなこともできる
*var s3 = Create((s1, s2));

*Chart1.ChartAreas[0].AxisY.Maximum = 5;
最大値指定

*string lserver = $"LDAP:
{LDAPサーバーのIPアドレス}ou=testou,dc=gebogebo,dc=com";

*num = 50.0
3.0;   16.6666...が返る

*subject.OnNext(1);
エラーにならない

*public static float BackCoefficient = 1.0F;
Backの戻る値

受信Only
*SerialPort serialPort = new SerialPort("COM3", 250000, Parity.None, 8, StopBits.One);

*{//対象を26で割った余りint amari = index % 26;//対象を26で割った商int sho = index / 26;//割り切れた時（Zを出すため）if (amari == 0){amari = 26;sho--;}//余りの数のアルファベットを出力result = ((char)((int)'A' + amari - 1)).ToString() + result;//商を次の対象とするindex = sho;}
26より大きい場合は繰り返す
対象を26で割った余り
*int amari = index % 26;
対象を26で割った商
*int sho = index / 26;
*if (amari == 0)*{
割り切れた時（Zを出すため）
余りの数のアルファベットを出力
*result = ((char)((int)'A' + amari - 1)).ToString() + result;
商を次の対象とする
*index = sho;
残りのアルファベットを出力
*result = ((char)((int)'A' + index - 1)).ToString() + result;
*if (length == value.length - 1)*{
最後の1文字は処理しない

*{dist = Vector3.Distance(transform.position, targ.transform.position);}
Start is called before the first frame update
*{transform.position = Vector3.MoveTowards(transform.position, targ.transform.position, dist/30);}
Update is called once per frame

*a * a == b * b + c * c -2 * b * c * Mathf.Cos(θ);
余弦定理

*{string 苗字 { get; }string 名前 { get; }I利用者を登録するCommand Create(string _苗字, string _名前);}
↓コマンドの一例.
コマンド実行前に好きなことする.
*await CommandBus.ExecuteAsync(_command);
コマンド終了後に好きなことする.
*}

*void Cry();
鳴き声を出力する
*{public Cat() =>; Console.WriteLine(" 猫 コンストラクタ");public void Cry() =>; Console.WriteLine("ニャ～");}
ネコ(IAnimalインターフェースの実装)
*{public void Cry() =>; Console.WriteLine("バウ！");public Dog() =>; Console.WriteLine(" 犬 コンストラクタ");}
イヌ(IAnimalインターフェースの実装)
*{[Dependency]public IAnimal Pet { get; set; }// ペットを呼ぶpublic void CallPet() =>; Pet.Cry();}
依存性を注入されるクラス
ペットを呼ぶ
*public void CallPet() =>; Pet.Cry();

*private int Crynum = 0;
鳴く回数
*{// 名前を指定すると、RegisterInstanceで名前を指定したものを使用する//[Dependency("Dog12")]// 名前を指定しないと、RegisterInstanceで名前を指定しておらず、一番後に登録されたものを使用する(あと勝ちで使われるっぽい)[Dependency]public IAnimal Pet { get; set; }// ペットを呼ぶpublic void CallPet() =>; Pet.Cry();}
依存性を注入されるクラス
名前を指定すると、RegisterInstanceで名前を指定したものを使用する
[Dependency("Dog12")]
名前を指定しないと、RegisterInstanceで名前を指定しておらず、一番後に登録されたものを使用する(あと勝ちで使われるっぽい)
*[Dependency]
ペットを呼ぶ
*public void CallPet() =>; Pet.Cry();

*{Enabled = true,Interval = 100})
Create a WinForms timer that raises the Tick event every tenth second.
*{initialPage.Navigate(inProgressPage);};
When the user clicks "Yes", navigate to the second page.
*{UseShellExecute = true,Verb = "runas"};
Try to start an elevated cmd.exe.
*{Heading = "AfterNavigation.",Buttons ={TaskDialogButton.Close}};
Navigate to a new page.

*foreach(Transform child in gameObject.transform){SkinnedMeshRenderer skin = child.GetComponent<;SkinnedMeshRenderer>;();vtx_num += skin.sharedMesh.vertices.Length;}
頂点数を数える
*foreach(Transform child in gameObject.transform){SkinnedMeshRenderer skin = child.GetComponent<;SkinnedMeshRenderer>;();Mesh child_mesh = skin.sharedMesh;for(int i = 0; i <; child_mesh.vertices.Length; i++){float x = child_mesh.vertices[i].x;float y = child_mesh.vertices[i].y;float z = child_mesh.vertices[i].z;vtx_posi_array[count] = new Vector3(x, y, z);count++;}}
頂点座標を取得
*try{filename = filename + ".csv";bool append = false;using(var sw = new System.IO.StreamWriter(@filename, append)){for(int i = 0; i <; vtx_posi_array.Length; ++i){sw.WriteLine("{0},{1},{2}", vtx_posi_array[i].x, vtx_posi_array[i].y, vtx_posi_array[i].z);}}}
csvファイルに書き込む

*if (GameSceneManager.IsGameStart) return;*//リワード広告後は無視
ゲーム中は無視
*if (_isRewarding) return;*if (!pauseStatus) _isOpenOfflineEarning = true;
リワード広告後は無視
*if (_isOpenOfflineEarning)*{
起動時にはオフライン報酬を表示
*if (CalcOfflineEarning() <;= 0) return;*SceneManager.LoadSceneAsync(SceneName.OfflineEarningScene, LoadSceneMode.Additive);
もし稼ぎが0ならなし

オークリーダーのAnimator
*[SerializeField] private Animator _masterAnimator;
オークリーダーの初期位置
*private Vector3 _masterStartPosition;
初期位置からの差分, stateNameHash, normalizedTime
*public readonly Subject<;(Vector3, int, float)>; MasterInfo = new Subject<;(Vector3, int, float)>;();

*const string uriBase = "https:
westcentralus.api.cognitive.microsoft.comfacev1.0detect";
画像ファイルパスの入力
*string imageFilePath = Console.ReadLine();
*{HttpClient client = new HttpClient();// リクエストヘッダーclient.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", subscriptionKey);// リクエストパラメータstring requestParameters = "returnFaceId=true&amp;returnFaceLandmarks=false" +"&amp;returnFaceAttributes=age,gender,headPose,smile,facialHair,glasses," +"emotion,hair,makeup,occlusion,accessories,blur,exposure,noise";// Face API呼び出し時のURLを作成string uri = uriBase + "?" + requestParameters;HttpResponseMessage response;// ローカルの画像ファイルパスを文字列からバイト型配列へ変換byte[] byteData = GetImageAsByteArray(imageFilePath);using (ByteArrayContent content = new ByteArrayContent(byteData)){// リクエストヘッダーの作成content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");// Face APIの呼び出しresponse = await client.PostAsync(uri, content);// 実行結果からJSONの取得string contentString = await response.Content.ReadAsStringAsync();// JSONの出力Console.WriteLine("\nResponse:\n");Console.WriteLine(JsonPrettyPrint(contentString));Console.WriteLine("\nPress Enter to exit...");}}
Face APIを使用して画像分析を行う
リクエストヘッダー
*client.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", subscriptionKey);
リクエストパラメータ
*string requestParameters = "returnFaceId=true&amp;returnFaceLandmarks=false" +
Face API呼び出し時のURLを作成
*string uri = uriBase + "?" + requestParameters;
ローカルの画像ファイルパスを文字列からバイト型配列へ変換
*byte[] byteData = GetImageAsByteArray(imageFilePath);
リクエストヘッダーの作成
*content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");
Face APIの呼び出し
*response = await client.PostAsync(uri, content);
実行結果からJSONの取得
*string contentString = await response.Content.ReadAsStringAsync();
JSONの出力
*Console.WriteLine("\nResponse:\n");
*{using (FileStream fileStream =new FileStream(imageFilePath, FileMode.Open, FileAccess.Read)){BinaryReader binaryReader = new BinaryReader(fileStream);return binaryReader.ReadBytes((int)fileStream.Length);}}
ファイルパス上にある画像をバイト配列に変換
*{if (string.IsNullOrEmpty(json))return string.Empty;json = json.Replace(Environment.NewLine, "").Replace("\t", "");StringBuilder sb = new StringBuilder();bool quote = false;bool ignore = false;int offset = 0;int indentLength = 3;foreach (char ch in json){switch (ch){case '"':if (!ignore) quote = !quote;break;case '\'':if (quote) ignore = !ignore;break;}if (quote)sb.Append(ch);else{switch (ch){case '{':case '[':sb.Append(ch);sb.Append(Environment.NewLine);sb.Append(new string(' ', ++offset * indentLength));break;case '}':case ']':sb.Append(Environment.NewLine);sb.Append(new string(' ', --offset * indentLength));sb.Append(ch);break;case ',':sb.Append(ch);sb.Append(Environment.NewLine);sb.Append(new string(' ', offset * indentLength));break;case ':':sb.Append(ch);sb.Append(' ');break;default:if (ch != ' ') sb.Append(ch);break;}}}return sb.ToString().Trim();}
JSONの整形を行う

*}
追加

*Debug.Log(this.range);
-&gt; 10

*_music.PlayLooping();
ループ再生

*for (int YAxisIndex = YAxes.Count; YAxisIndex <; Signals.Count; YAxisIndex++)
軸インデックスがない場合は追加する
*for (int No = 0; No <; Signals.Count; No++)*{
各軸に描画
オートスケール
*WpfPlot1.Plot.AxisAuto();
X軸を表示制限
*var AxisLimits = WpfPlot1.Plot.GetAxisLimits();
*for(int No = 0; No <;YAxes.Count; No++)*{
各Y軸の設定（色指定、ラベル、表示制限）

*if (GameObject.Find("OnlyUIRenderingCamera"))*{
シーンをロードするたびに新しいカメラを生成
カメラ自動生成
*GameObject camera_G = new GameObject("OnlyUIRenderingCamera");
キャンバス生成＆設定
*GameObject canvas_G = new GameObject("FaceCanvas");
*Vector3 canvasPosition = canvas_G.transform.position;*canvasPosition.x = 0;
キャンバスのポジションを調整
レンダリングをfaceCameraに
*faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
パネル生成＆設定
*GameObject panel_G = new GameObject("FacePanel");
*panel_G.transform.parent = canvas_G.transform;*//パネルのポジションを正面、スケールをいい感じに調整
パネルをキャンバスの子に設定
*Vector3 panelPosition = panel_G.transform.localPosition;*Vector3 panelScale = panel_G.transform.localScale;
パネルのポジションを正面、スケールをいい感じに調整
*canvas_G.transform.parent = faceCamera.transform;*//Layerを変更
キャンバスをカメラの子に設定
Layerを変更
*canvas_G.layer = LayerMask.NameToLayer("UI");
Fixed Timestepを固定
*Time.fixedDeltaTime = FIXEDUPDATE_DELTATIME;
*if (Input.anyKey == false)*{
キー押してない間はreturn
*if (Input.GetKeyDown(KeyCode.O) &amp;&amp; panelColor[num].a == 0)*{
テスト用　フェードアウト
パラメータをひとまとめにしたクラス
*[Serializable]
*{//ラベル領域の幅を調整EditorGUIUtility.labelWidth = 100;position.height = EditorGUIUtility.singleLineHeight;//各プロパティーの Rect を求めるRect panelColorRect = new Rect(position){y = position.y + EditorGUIUtility.singleLineHeight + 1};Rect fadeTimeRect = new Rect(panelColorRect){y = panelColorRect.y + EditorGUIUtility.singleLineHeight + 2};Rect alpha_PanelRect = new Rect(fadeTimeRect){y = fadeTimeRect.y + EditorGUIUtility.singleLineHeight + 2};//各プロパティーの SerializedProperty を求めるSerializedProperty panelColorProperty = property.FindPropertyRelative("panelColor");SerializedProperty fadeTimeProperty = property.FindPropertyRelative("fadeTime");SerializedProperty alpha_PanelProperty = property.FindPropertyRelative("alpha_Panel");//各プロパティーの GUI を描画panelColorProperty.colorValue =EditorGUI.ColorField(panelColorRect,"フェードの色",panelColorProperty.colorValue);fadeTimeProperty.floatValue= EditorGUI.FloatField(fadeTimeRect, "フェードの時間", fadeTimeProperty.floatValue);alpha_PanelProperty.floatValue = EditorGUI.Slider(alpha_PanelRect, "透明度",alpha_PanelProperty.floatValue, 0, 1);}
元は 1 つのプロパティーであることを示すために PropertyScope で囲む
ラベル領域の幅を調整
*EditorGUIUtility.labelWidth = 100;
*{y = position.y + EditorGUIUtility.singleLineHeight + 1};
各プロパティーの Rect を求める
各プロパティーの SerializedProperty を求める
*SerializedProperty panelColorProperty = property.FindPropertyRelative("panelColor");
各プロパティーの GUI を描画
*panelColorProperty.colorValue =EditorGUI.ColorField(panelColorRect,"フェードの色",panelColorProperty.colorValue);
パラメータをひとまとめにしたクラス
*[Serializable]
*if (GameObject.Find("OnlyUIRenderingCamera"))*{
シーンをロードするたびに新しいカメラを生成
カメラ自動生成
*GameObject camera_G = new GameObject("OnlyUIRenderingCamera");
キャンバス生成＆設定
*GameObject canvas_G = new GameObject("FaceCanvas");
*Vector3 canvasPosition = canvas_G.transform.position;*canvasPosition.x = 0;
キャンバスのポジションを調整
レンダリングをfaceCameraに
*faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
パネル生成＆設定
*GameObject panel_G = new GameObject("FacePanel");
*panel_G.transform.SetParent(canvas_G.transform);*//パネルのポジションを正面、スケールをいい感じに調整
パネルをキャンバスの子に設定
*Vector3 panelPosition = panel_G.transform.localPosition;*Vector3 panelScale = panel_G.transform.localScale;
パネルのポジションを正面、スケールをいい感じに調整
*canvas_G.transform.SetParent(faceCamera.transform);*//Layerを変更
キャンバスをカメラの子に設定
Layerを変更
*canvas_G.layer = LayerMask.NameToLayer("UI");
Fixed Timestepを固定
*Time.fixedDeltaTime = FIXEDUPDATE_DELTATIME;
*if (Input.anyKey == false)*{
キー押してない間はreturn
*if (Input.GetKeyDown(KeyCode.O) &amp;&amp; fadeParameters[num].panelColor.a == 0)*{
テスト用　フェードアウト
*{//ラベル領域の幅を調整EditorGUIUtility.labelWidth = 100;position.height = EditorGUIUtility.singleLineHeight;//各プロパティーの Rect を求めるRect panelColorRect = new Rect(position){y = position.y + EditorGUIUtility.singleLineHeight + 1};Rect fadeTimeRect = new Rect(panelColorRect){y = panelColorRect.y + EditorGUIUtility.singleLineHeight + 2};Rect alpha_PanelRect = new Rect(fadeTimeRect){y = fadeTimeRect.y + EditorGUIUtility.singleLineHeight + 2};//各プロパティーの SerializedProperty を求めるSerializedProperty panelColorProperty = property.FindPropertyRelative("panelColor");SerializedProperty fadeTimeProperty = property.FindPropertyRelative("fadeTime");SerializedProperty alpha_PanelProperty = property.FindPropertyRelative("alpha_Panel");//各プロパティーの GUI を描画panelColorProperty.colorValue = EditorGUI.ColorField(panelColorRect, "フェードの色", panelColorProperty.colorValue);fadeTimeProperty.floatValue = EditorGUI.FloatField(fadeTimeRect, "フェードの時間", fadeTimeProperty.floatValue);alpha_PanelProperty.floatValue = EditorGUI.Slider(alpha_PanelRect, "透明度", alpha_PanelProperty.floatValue, 0, 1);}
元は 1 つのプロパティーであることを示すために PropertyScope で囲む
ラベル領域の幅を調整
*EditorGUIUtility.labelWidth = 100;
*{y = position.y + EditorGUIUtility.singleLineHeight + 1};
各プロパティーの Rect を求める
各プロパティーの SerializedProperty を求める
*SerializedProperty panelColorProperty = property.FindPropertyRelative("panelColor");
各プロパティーの GUI を描画
*panelColorProperty.colorValue = EditorGUI.ColorField(panelColorRect, "フェードの色", panelColorProperty.colorValue);

タップ検知したGameObjectを取得。
*GameObject tapObj = EventSystem.current.currentSelectedGameObject;
*if (!tapObj) { return false; }*//取得したオブジェクトからButtonを取得。
取得したGameObjectがnullならばfalseを返す。
取得したオブジェクトからButtonを取得。
*Button btn = tapObj.GetComponent<;Button>;();
ボタンがnullかどうかを返す。
*return btn;

以下、 線形グラデーション
*LinerDarkRed,
以下、放射状グラデーション
*RadialRedBrush,
透明色の場合はnullを返す
*return null;
*Colors = new SKColor[] { SKColors.White, SKColors.LightGray, SKColors.Black },
3色のグラデーションの場合はColorsとColorPosに3つを指定
*Colors = new SKColor[] { SKColors.White, Color.FromHex("#FFFF2020").ToSKColor() },
放射状グラデーション
*Colors = new SKColor[] { SKColors.White, Color.FromHex("#FF2020FF").ToSKColor() },
放射状グラデーション
*Colors = new SKColor[] { SKColors.White, SKColors.Yellow },
放射状グラデーション
コンストラクタとプロパティの定義は省略(詳細はGitHubのソースコード参照)
描画するハンドラ
*private void SkCanvasView_OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)
初期描画済みとする
*Initialized = true;
canvas上にすでに何かを描画済みであればいったんクリアする(透明色にする)
*canvas.Clear();
描画範囲をコントロール全体として指定
*SKRect rect = new SKRect(0, 0, info.Width, info.Height);
グラデーション設定を取得
*GradientModel gradientModel = GradientModelFactory.Instance.CreateGradientModel(BackGradientColor);
グラデーション設定もグラデーション無しの背景色も、どちらも未設定であれば透明とする
*return;
*{if (gradientModel != null){// 背景グラデーション用のShaderの設定paint.Shader = CreateShader(gradientModel, rect);}else{// グラデーション設定がない場合はBackgroundColorから取得paint.Color = BackgroundColor.ToSKColor();}// 背景を描画DrawFill(canvas, paint, rect);}
塗りつぶしのグラデーション用のSKPaintを作成
背景グラデーション用のShaderの設定
*paint.Shader = CreateShader(gradientModel, rect);
グラデーション設定がない場合はBackgroundColorから取得
*paint.Color = BackgroundColor.ToSKColor();
背景を描画
*DrawFill(canvas, paint, rect);
*if (StrokeWidth <; 0.01) return;*// 枠線用のSKPaintを作成
枠線の太さが0に近ければ枠線は描画しない
*{// 枠線を描画DrawStroke(canvas, paint, rect);}
枠線用のSKPaintを作成
枠線を描画
*DrawStroke(canvas, paint, rect);
円から絶対にはみ出ないように半径は1小さくする
*return (float)Math.Min(rect.Width, rect.Height) / 2 - 1;
矩形の場合
*return SKShader.CreateLinearGradient(
円の場合
矩形のサイズから円の半径を算出する
*float radius = GetRadius(rect);
グラデーションの始点位置を中心から左上にずらし、そのずれた分だけ半径を大きくする
*return SKShader.CreateRadialGradient(

*request.Headers.Referrer = new Uri("https:
app.splatoon2.nintendo.nethome");

*return val.ToString() + unit + behind;
★これが、TextBlockに表示される

*RestClient client = new RestClient("http:
ここにURL.co.jp");
client.Authenticator = new HttpBasicAuthenticator("username", "password"); 認証が必要な場合
*RestRequest request = new RestRequest("/ここにresourceのURL/",Method.POST);
*object x = new { query = new { range = new {occurred_at = new {gt = "2017-08-16 16:18:00+0900", lte = "now",format = "yyyy-MM-dd HH:mm:ssZ" } } } };request.AddJsonBody(x);request.RequestFormat = DataFormat.Json;var response = client.Execute(request);//ここにドキュメントを処理するコードvar jsonObj = DynamicJson.Parse(response.Content);var total=jsonObj.hits.total;foreach (var hit in jsonObj.hits.hits){var at=hit._source.occurred_at;},,,dynamic djson=DynamicJson.Parse(cjson)string name=djson["name"],,,ここにドキュメントを処理するコード
*var jsonObj = DynamicJson.Parse(response.Content);

PowePoint Objectを作成します。
*Presentation ppt = new Presentation();
ファイルをロードします。
*ppt.LoadFromFile(@"Sample.pptx");
HTMLで保存します。
*ppt.SaveToFile("ConvertPPTtoHtml.html", FileFormat.Html);

*string text = value.Text;
Tweet

*!type.IsPrimitiveRecursiveStruct())
allow System.Int32 to contain a field of its own type

Cookieを有効化
*var config = Configuration.Default.WithCookies().WithDefaultLoader();
URLを取得
await context.OpenAsync("https:qiita.com/login");
ログイン前のURL表示
*Console.WriteLine(context.Active.Location);
*{identity = "Qiitaのユーザー名またはメールアドレス",password = "Qiitaのパスワード"});
submit
ログイン後のURL表示
*Console.WriteLine(context.Active.Location);
*var notifications = document.QuerySelector(".st-Header_notifications");*Console.WriteLine(notifications.InnerHtml);
通知件数取得

*vm.ViewsideAction = this.ViewsideAction;
★スライダーの範囲表示更新処理をViewModelに登録

テスト対象メソッドを実行
*適当なクラス.適当なメソッド();
メインのログファイルは読み込めないため、確認用に一時的にコピー
*File.Copy("ログファイル", "一時的なログファイル", true);
*using (StreamReader file = new StreamReader("一時的なログファイル", Encoding.GetEncoding("shift_jis")))*{
ログファイルの読込み
ファイルの先頭行を読み込み
*string line = file.ReadLine();
ログ内に適切な文言が存在するかどうか
*Assert.IsTrue(line.Contains("出力されるべきメッセージ"));

*try{String str = "";XmlNodeList myXmlNodeList = myXmlDocument.ChildNodes;for(int i=0;i<;myXmlNodeList.Count;i++){str += EscapeHTML(myXmlNodeList[i]);}Console.WriteLine(str);}catch (Exception ee){Console.Error.WriteLine(ee.ToString());}
myXmlDocument.XmlResolver = null;
*switch (node.Name.ToLower()) {case "b":tagStart = "<;b>;";tagEnd = "<;/b>;";break;case "i":tagStart = "<;i>;";tagEnd = "<;/i>;";break;case "font":tagStart = "<;font";tagEnd = "<;/font>;";XmlAttributeCollection xmlAttributeCollection = node.Attributes;foreach(XmlAttribute attr in xmlAttributeCollection){switch (attr.Name.ToLower()) {case "color":case "size":tagStart += " " + attr.Name + "=\"" + System.Security.SecurityElement.Escape(attr.Value) + "\"";break;}}tagStart += ">;";break;}

"#"で始まらないノードのみ
*tagStart = "<;" + node.Name;

*myPlotModel.InvalidatePlot(false);
-- 変更点 ---

*IReadOnlyList<;Monster<; monsterList = LoadMonsterList();
良い例
悪い例
DBから読み場合最後まで読むという無駄な処理が必要
無限なシーケンスだと終わらない
bool isEmptyMonsters = monsterList.Count() == 0;
*,,,
MaxByは一番大きい要素(複数)を探すメソッド
*IReadOnlyCollection<;Monster>; maxLevelMonsters = monsterList.MaxBy(it =>; it.Level);
Bufferは先頭から指定数ごとにまとめるメソッド
*IEnumerable<;IReadOnlyList<;Monster>;>; bufferedMonsters = monsterList.Buffer(8);
Flattenは、リストのリストなどをIEnumerable&lt;T&gt;に平滑化するメソッド
「平滑化するよ」ということがメソッド名から伝わる
*IEnumerable<;Monster>; monsters = monsterListOfList.Flatten();
メソッド名が超わかりやすい!
無限シーケンスでも終わるし、余分な処理しない
*bool isEmptyMonster = monsters.IsEmpty();

*LineSeries.StrokeThickness = 2;
線の太さ
データを関連付け加
*LineSeries.ItemsSource = Datas;
点を追加
*Datas.Add(new DataPoint(1.0, 0.0));
グラフをモデルに追加
*Model.Series.Add(LineSeries);
セットした内容を反映させる
*Model.InvalidatePlot(true);

*return code;
漢字

*if (RGBCheckBox.Checked == true &amp;&amp; hexcolorCodesCheckBox.Checked == false)*{
「RGB → HexcolorCodes」にチェック時
RGB の値を取得
*int R = (int)redNumericUpDown.Value;
設定した色をパネルに表示
*DrawingPanel(R, G, B);
16進数カラーコードで表示
*CreateHexadecimal(R, G, B);
*else if (RGBCheckBox.Checked == false &amp;&amp; hexcolorCodesCheckBox.Checked == true)*{
「HexcolorCodes → RGB」にチェック時
16進数カラーコードを取得し、16進数を10進数に変換
*var R = Int32.Parse(redTextBox.Text, System.Globalization.NumberStyles.HexNumber);
設定した色をパネルに表示
*DrawingPanel(R, G, B);
RGB で表示
*CreateRGB(R, G, B);
チェックボックスの選択に不備があることをメッセージボックスで警告
*MessageBox.Show(@"Please check either ""RGB → HexcolorCodes"" or ""HexcolorCodes → RGB""");
カラーダイアログを表示
*DialogResult dialogResult = colorDialog.ShowDialog();
カラーダイアログからRGB の値を取得
*int R = colorDialog.Color.R;
設定した色をパネルに表示
*DrawingPanel(R, G, B);
16進数カラーコードで表示
*CreateHexadecimal(R, G, B);
RGB で表示
*CreateRGB(R, G, B);
パネルに設定された色を表示
*colorPanel.BackColor = Color.FromArgb(R, G, B);
*hexcolorCodesRichTextBox.Text = "#" + $"{R:x2}" + $"{G:x2}" + $"{B:x2}";
RGBを16進数に変換し、16進数カラーコードを「hexcolorCodesRichTextBox」に表示
「hexcolorCodesRichTextBox」に表示されたの文字を色分け
*hexcolorCodesRichTextBox.Select(1, 0);
設定されたRGBをRGBグループの各RGBに表示
*redNumericUpDown.Value = R;
*redTextBox.Text = $"{R:x2}";
設定されたRGBをHex color codesグループの各RGBに表示

プログラムの処理によってコンボボックス内のテキストが空に上書きされた場合、ここに入る。
この処理がないと、コンボボックス内のテキストを空に上書きするときにプルダウンが開いてしまう。
*this.Items.Filter += obj =>;
プルダウン部分へ適用されているフィルターを解除する。
*return true;
*{if (!(obj is ComboBoxItem)){return true;}var item = obj as ComboBoxItem;if (((string)item.Content).Contains(_textBox.Text)){//「選択肢の文字列の中に入力された文字列が含まれる場合」にフィルターを通過させる。// フィルターを通過すると、展開された選択肢の中に表示される。return true;}return false;};
入力がある都度、即時フィルターをかける。
「選択肢の文字列の中に入力された文字列が含まれる場合」にフィルターを通過させる。
フィルターを通過すると、展開された選択肢の中に表示される。
*return true;
コンボボックスの入力欄にフォーカスが当たったとき、プルダウンを展開する。
*_popUp.IsOpen = true;
*{new Prefecture(){ Name = "北海道", PrefecturalCapitalCityName = "札幌市"},new Prefecture(){ Name = "青森県", PrefecturalCapitalCityName = "青森市"},// 中略new Prefecture(){ Name = "鹿児島県", PrefecturalCapitalCityName = "鹿児島市"},new Prefecture(){ Name = "沖縄県", PrefecturalCapitalCityName = "那覇市"},};
コンストラクタ内でItemsSourceを積み込むとする。
*new Prefecture(){ Name = "鹿児島県", PrefecturalCapitalCityName = "鹿児島市"},
中略
*{if (!(obj is ComboBoxItem)){return true;}var item = obj as ComboBoxItem;if (((string)item.Content).Contains(_textBox.Text)){//「選択肢の文字列の中に入力された文字列が含まれる場合」にフィルターを通過させる。// フィルターを通過すると、展開された選択肢の中に表示される。return true;}return false;};
入力がある都度、即時フィルターをかける。
「選択肢の文字列の中に入力された文字列が含まれる場合」にフィルターを通過させる。
フィルターを通過すると、展開された選択肢の中に表示される。
*return true;
*{if (!(obj is Prefecture)){return true;}var item = obj as Prefecture;if (item.Name.Contains(_textBox.Text)){//「PrefectureのNameの中に入力された文字列が含まれる場合」にフィルターを通過させる。// フィルターを通過すると、展開された選択肢の中に表示される。return true;}return false;};
入力がある都度、即時フィルターをかける。
「PrefectureのNameの中に入力された文字列が含まれる場合」にフィルターを通過させる。
フィルターを通過すると、展開された選択肢の中に表示される。
*return true;
*{if (!(obj is Prefecture)){return true;}var item = obj as Prefecture;// ↓「item.Name」を「item.PrefecturalCapitalCityName」に変えただけif (item.PrefecturalCapitalCityName.Contains(_textBox.Text)){return true;}return false;};
入力がある都度、即時フィルターをかける。
*if (item.PrefecturalCapitalCityName.Contains(_textBox.Text))*{
↓「item.Name」を「item.PrefecturalCapitalCityName」に変えただけ

*{class SampleBatch1 : BatchBase{[Command("exec1")]public void Execute(string name1, int repeat1 = 3){for (int i = 0; i <; repeat1; i++){this.Context.Logger.LogInformation($"{this.GetType().Name}.Execute from {name1} ({i + 1}/{repeat})");}}}}
起動アセンブリのルート名前空間に定義したバッチクラス
*{class SampleBatch2 : BatchBase{[Command("exec2")]public void Execute(string name2, int repeat2 = 3) {}}}
起動アセンブリのルート名前空間の配下に定義したバッチクラス
*{class SampleBatch3 : BatchBase{[Command("exec3")]public void Execute(string name3, int repeat3 = 3) {}}}
起動アセンブリのルート名前空間外に定義したバッチクラス
*{public class SampleBatch4 : BatchBase{[Command("exec4")]public void Execute(string name4, int repeat4 = 3) {}}}
別アセンブリに定義したバッチクラス
起動アセンブリのルート名前空間の配下に定義したバッチクラス
*await BatchHost.CreateDefaultBuilder().RunBatchEngineAsync<;SampleBatch1>;(args);
起動アセンブリのルート名前空間の配下の名前空間に定義したバッチクラス
*await BatchHost.CreateDefaultBuilder().RunBatchEngineAsync<;Batches.SampleBatch2>;(args);
起動アセンブリのルート名前空間外に定義したバッチクラス
*await BatchHost.CreateDefaultBuilder().RunBatchEngineAsync<;global::Batches.SampleBatch3>;(args);
別アセンブリに定義したバッチクラス
*await BatchHost.CreateDefaultBuilder().RunBatchEngineAsync<;BatchLibrary1.SampleBatch4>;(args);
*public void ExecuteNotCommand(string name, int repeat = 3) {}
Command属性を付与しない

*{Name = name,Email = email};
Send email to the customers to confirm the email sent

*String.Format("{0:D6}", i)
iは数字

*LineSeries.StrokeThickness = 2;
線の太さ
データを関連付け加
*LineSeries.ItemsSource = Datas;
点を追加
*Datas.Add(new DataPoint(1.0, 10.0));
グラフをモデルに追加
*Model.Series.Add(LineSeries);
セットした内容を反映させる
*Model.InvalidatePlot(true);

左向き、下向きにトルクをかける
*iwasirigid.AddTorque(Vector3.down * rotationSpeed, ForceMode.Impulse);
右向き、下向きにトルクをかける
*iwasirigid.AddTorque(Vector3.up * rotationSpeed, ForceMode.Impulse);
左向き、上向きにトルクをかける
*iwasirigid.AddTorque(Vector3.down * rotationSpeed, ForceMode.Impulse);
右向き、上向きにトルクをかける
*iwasirigid.AddTorque(Vector3.up * rotationSpeed, ForceMode.Impulse);
右向きにトルクをかける
*iwasirigid.AddTorque(Vector3.up * rotationSpeed, ForceMode.Impulse);
左向きにトルクをかける
*iwasirigid.AddTorque(Vector3.down * rotationSpeed, ForceMode.Impulse);
*iwasirigid.velocity = this.gameObject.transform.forward * speed;*//外積で元に戻す　X軸方向
前に進む
*Vector3 left = this.gameObject.transform.TransformVector(Vector3.left);*Vector3 hori_left = new Vector3(left.x, 0, left.z).normalized;
外積で元に戻す　X軸方向
*Vector3 forward = this.gameObject.transform.TransformVector(Vector3.forward);*Vector3 hori_forward = new Vector3(forward.x, 0, forward.z).normalized;
外積で元に戻す　Z軸方向

*GetComponent<;Rigidbody<;().rotation = Quaternion.Euler (turn.x, turn.y, turn.z + GetComponent<;Rigidbody<;().velocity.x * tilt * f);
修正

*if (!isInitialized)*{
m_view.InitListView()は1度だけしか呼ばない
データ個数を変更して表示を更新する
*m_view.SetListItemCount(m_list.Length);
ScrollViewを非表示にしてる場合は表示するため
*m_view.gameObject.SetActive(true);
Cellの元となるLogデータはLogHandlerを継承したクラスで管理している
*LogHandler data = m_list[index];
UIの更新はLogCellViewを継承した各CellごとのComponentで行う
*LogCellView itemOriginal;

*var ns2 = XNamespace.Get("http:
example.combar");

*acc = accumulator(acc, item);
accumulatorも原因
C# 7では、静的ローカル関数に対応していないのでコンパイルエラー
*public static IEnumerable<;TSource>; Scan<;TSource>;(
*{var hasSeed = false;var acc = default(TSource);foreach (var item in source){if (!hasSeed){hasSeed = true;acc = item;continue;}acc = accumulator(acc, item);yield return acc;}}
引数として、sourceとaccumulatorを渡す
C# 7では、名前が衝突してコンパイルエラー
*public static IEnumerable<;TSource>; Scan<;TSource>;(
コンパイルエラー
sourceとaccumulator名前はもう使われているから
*IEnumerable<;TSource>; Impl(IEnumerable<;TSource>; source, Func<;TSource, TSource, TSource>; accumulator)
C# 7でもC# 8でもコンパイルが通る
*public static IEnumerable<;TSource>; Scan<;TSource>;(
コンパイルエラーを回避
sourceとaccumulator名前はもう使われているから、sourceImplとaccumulatorImplという名前を使う
*IEnumerable<;TSource>; Impl(IEnumerable<;TSource>; sourceImpl, Func<;TSource, TSource, TSource>; accumulatorImpl)
C# 7では、名前が衝突してコンパイルエラー
C# 8では、「変数のシャドーイング」が認められ、コンパイルが通る
*public static IEnumerable<;TSource>; Scan<;TSource>;(
*{var hasSeed = false;var acc = default(TSource);foreach (var item in source){if (!hasSeed){hasSeed = true;acc = item;continue;}acc = accumulator(acc, item);yield return acc;}}
C#8では、変数のシャドーイングが認められて、sourceとaccumulatorという名前でもOK

*{Vector3 thisPos = this.gameObject.transform.position;Ray ray = new Ray(new Vector3(thisPos.x,thisPos.y+1,thisPos.z), Vector3.down);RaycastHit hit = new RaycastHit();if (Physics.Raycast(ray.origin, ray.direction, out hit, Mathf.Infinity) ){if(hit.collider.gameObject.name == this.gameObject.name){hit.collider.gameObject.layer = LayerMask.NameToLayer("Top");}if(hit.collider.gameObject.name != this.gameObject.name &amp;&amp; movaChildBlock.isMove == false){this.gameObject.layer = LayerMask.NameToLayer("Default");}}}
自身の真上から自身に向けてレイを出す
*{BoxCollider thisCollider = this.gameObject.GetComponent<;BoxCollider>;();GameObject otherObj = other.gameObject;BoxCollider otherObjBoxCollider = otherObj.GetComponent<;BoxCollider>;();//コライダーの大きさを比較して衝突先の方が大きければ移動if (otherObjBoxCollider.size.x >; thisCollider.size.x){Vector3 otherObjPos = otherObj.transform.position;moveChildBlock.beforeMovePosition = new Vector3(otherObjPos.x, otherObjPos.y+ thisCollider.size.y*3, otherObjPos.z);moveChildBlock.isMove = false;}}
ブロック同士の衝突時にルール通りの移動かどうか判定する
*if (otherObjBoxCollider.size.x >; thisCollider.size.x)*{
コライダーの大きさを比較して衝突先の方が大きければ移動

*if (YAxis != 0) {*cnt++;
長押しで連続入力
*if (SentakuID >; 2) SentakuID = 0;*if (SentakuID ; 0) SentakuID = 2;
一番端にいったら反転

*h(x, y);
OK

*int year = date.Year;
西暦の年

ここ
*var connection = @"Server=(localdb)\mssqllocaldb;Database=EFGetStarted.AspNetCore.NewDb;Trusted_Connection=True;ConnectRetryCount=0";

A4 縦の用紙を準備
*var queue = server.DefaultPrintQueue;
印刷可能領域を取得
*var area = queue.GetPrintCapabilities().PageImageableArea;
用紙いっぱいにイメージを配置
*var page = new FixedPage();
デフォルトプリンタで印刷
*PrintQueue.CreateXpsDocumentWriter(queue).Write(page, ticket);

ソースドキュメントの準備
*List<;XpsDocument>; sourceXps = new List<;XpsDocument>;();
出力先
*var name = destinationPath;
ライター
*XpsDocumentWriter writer = XpsDocument.CreateXpsDocumentWriter(destXps);
*foreach (XpsDocument doc in sourceXps)*{
マージ
終了処理
*writer.Write(seq);

*else Bullet_List[Obj_No].SetActive(true);
Listにあればそのオブジェクトをアクティブに
使うオブジェクトを返す
*return Bullet_List[Obj_No];
Rigidbody取得
*rid2d = GetComponent<;Rigidbody2D>;();
*Vector2 ShotPos = transform.position;*//10フレームに1回発射
自身の座標取得
*if (WaitFrame >; 10) {shotmenu.n_way_Shot(20, 5, 30, ShotPos);WaitFrame = 0;}
10フレームに1回発射
*float diffusion_angle = PI * (Degree / 180);*//弾インスタンスに渡す角度の計算
n-way弾の端から端までの角度
*if (Angle_Split >; 1)*Theta = (diffusion_angle / (Angle_Split - 1)) * i - 0.5f * diffusion_angle;
弾インスタンスに渡す角度の計算
弾の座標を撃つ場所に
*GameObject Bullet_obj = objp.poolBullet(shotPos);
いろいろ弾に渡す部分
*Bullet_Sc bullet_cs = Bullet_obj.GetComponent<;Bullet_Sc>;();

*hoge(tmp);
参照型なのでコピーは発生しない

*var req = WebRequest.Create("http:
localhost:3000Post");

花火の種のParticleSystem
*[SerializeField]
*if (_particleSystem.particleCount >; 0)*{
パーティクルの粒子が存在しているか確認
音源再生の処理
*particleNum--;

*if (inputActionSingle != null &amp;&amp; inputActionSingle.GetAxis(handType) != 0f)*{
トリガーの値（0 ～1）
*{holdAnime.SetFloat("holdRate", squeezeVal);holdAnime.Play("Hold", 0, squeezeVal);float animeSpeed = holdAnime.speed;if (holdAnime.GetFloat("holdRate") <; 0.1){holdAnime.speed = 0;}else{holdAnime.speed = animeSpeed;}}
コントローラの入力(0~1)

*{this.name = name;this.score = score;}
↓追加する．
*{var ary = new ScoreData[scoreDatas.Length];for (int i = 0; i <; scoreDatas.Length; i++){ary[i] = scoreDatas[i];}for (int i = 1; i <; ary.Length; i++){for (int j = ary.Length - 1; j >;= i; j--){if (ary[j - 1].score >; ary[j].score){ScoreData temp = ary[j - 1];ary[j - 1] = ary[j];ary[j] = temp;}}}return ary;}
ソート関数

*{EditorApplication.playModeStateChanged += OnPlayMode;}
コンストラクタでPlayMode,EditModeの切り替え時の処理を登録
*if (playModeStateChange == PlayModeStateChange.ExitingEditMode)*{
途中でPlayModeに切り替えても元に戻す
ポジションをもとに戻す処理を書いたメソッド
*rootClass.ResetPosition();
*if (targetTrasform == null)*{
エラーで警告
*if (Input.GetKeyDown(KeyCode.Space) &amp;&amp; debug_SpaceKey)*{
プレイモード時テスト用
*{this.gameObject.transform.position = thisObjPos;}
Editor上でのみ使うメソッド。座標を開始位置まで戻す
*{if (runCoroutine == null){runCoroutine = StartCoroutine(MoveCoroutine());}}
利用時はこれを呼ぶ
*while (x_Abs >; 0 || y_Abs >; 0 || z_Abs >; 0)*{
Targetまで移動
*if (EditorApplication.isPlaying == false)*{
Editor上で動かした場合のみここを通る。元の座標に戻るまでの秒数
*if (runCoroutine != null)*{
PlayMode中はrunCoroutineにMoveCoroutineが入ってるので止めて空にしとく
*#if UNITY_EDITOR*[CustomEditor(typeof(MyDebug))]
ここからEditor拡張
*{EditorApplication.playModeStateChanged += OnPlayMode;}
コンストラクタでPlayMode,EditModeの切り替え時の処理を登録
*if (rootClass.isStart == false)*{
まだ一回もTargetのpositionを保存していなかった時の為
*if (playModeStateChange == PlayModeStateChange.ExitingEditMode)*{
途中でPlayModeに切り替えても元に戻す
*if (GUILayout.Button("Test") &amp;&amp; EditorApplication.isPlaying == false)*{
押下時に実行したい処理
*if (rootClass.targetTrasform == null)*{
エラーで警告
*rootClass.thisObjPos = rootClass.gameObject.transform.position;*rootClass.isStart = true;
開始位置の座標保存

傘の下の中間ディレクトリーたち。こいつらが消える。
*IEnumerable<;string>; intermediateDirectories =
再帰呼出し。
*PathFlat.VisitIntermadiateDirectory(intermediateDir);
傘の直下のファイルは既にフラットなのでやる必要なし。
ここまでで、フラットになっている。
ファイルの頭に、傘を付けていく。
*Trace.WriteLine($"GoRename: {directoryLikeUmbrella}.");
*var joinedName = $"{directoryLikeUmbrella}\\{Path.GetFileName(directoryLikeUmbrella)}$%{Path.GetFileName(fileName)}";
親ディレクトリーの下に、親ディレクトリーの名前と、主体のファイル名を $% でくっつけたものを置く。
*var joinedName = $"{directoryLikeUmbrella}\\{Path.GetFileName(directoryLikeUmbrella)}$%{Path.GetFileName(fileName)}";
Ｃ＃のメソッド名は、ノード名なのか、フルパスなのか、はっきりわかるように名付けてほしい。最後のノード名は、ファイル名を取るメソッドで代用した。
リネーム☆ 運用で衝突を避けるが、衝突すれば Move が例外を投げる。
*new TraceableFile(fileName).Move(new TraceableFile(joinedName));
もっと中間ディレクトリーたち。
*IEnumerable<;string>; moreIntermediateDirectories =
再帰呼出し。
*PathFlat.VisitIntermadiateDirectory(moreIntermediateDir);
この階層のファイル。これを残す。
*IEnumerable<;string>; files =
*var joinedName = $"{Directory.GetParent(file.FullName).Name}$%{Path.GetFileName(file.FullName)}";
親ディレクトリーの名前と、主体のファイル名を $% でくっつける。
親の親ディレクトリーのフル名。（なければ例外）
*var parentParentDirectory = Directory.GetParent(Directory.GetParent(file.FullName).FullName).FullName;
*Trace.WriteLine($"parentParentDirectory: '{parentParentDirectory}', joinedName: '{joinedName}'.");
親の親ディレクトリーの下に さっきくっつけた名前。衝突したら Move が例外を投げる。
古い名前から、新しい名前へ移動。
*file.Move(destination);

メソッドの指定はAssemblyFileName:NameSpace.ClassName.MethodNameで指定されるものとする。
*string assemblyFileName = url.Substring(0, url.IndexOf(':'));
クラスを呼び出す前にアセンブリをロードする
*Assembly asm = Assembly.Load(assemblyFileName);
名前空間も含んだフルパスでオブジェクト名を指定する
*Type type = asm.GetType(fullObjectName);
*object ret = type.InvokeMember(methodName, BindingFlags.InvokeMethod, null, null,new object[]{ arg1,arg2,... });
静的メソッドはInvokeMemberで呼び出す。引数は最後のオブジェクト配列で渡す
戻り値はobject型になるので適切な型にキャストして返すこと
*return ret;

*public RECT WorkingArea;
Exclude TaskBar
nullの確認（構造体のようにNULLにならない型では不要）
両方nullか（参照元が同じか）
(c1 == c2)とすると、無限ループ
*if (object.ReferenceEquals(c1, c2))
どちらかがnullか
(c1 == null)とすると、無限ループ
*if (((object)c1 == null) || ((object)c2 == null))
*if (c1.MonitorNum != c2.MonitorNum)*{
モニタの数が異なる
*for (int i = 0; i <; c1.MonitorNum; i++)*{
モニタの座標が異なる
ウィンドウの情報
*public String ClassName;
モニターとの関係
*public int BelongMonitor;
すべてのウィンドウを列挙する
*Common.EnumWindows(EnumWindowCallBack, (IntPtr)null);
*if ((Common.GetWindowLongStyle(hWnd) &amp; Common.WS_VISIBLE) == 0)*{
可視状態でないものを除く
*if ((Common.GetWindowLongExStyle(hWnd) &amp; Common.WS_EX_TOOLWINDOW) != 0)*{
タスクバーに表示されているものを除く
ウィンドウのタイトルの長さを取得する
*int textLen = Common.GetWindowTextLength(hWnd);
ウィンドウのタイトルを取得する
*StringBuilder tsb = new StringBuilder(textLen + 1);
ウィンドウのクラス名を取得する
*StringBuilder csb = new StringBuilder(256);
ウィンドウ位置を取得する
*var rc = new RECT();
ウィンドウ情報を取得する
*WINDOWPLACEMENT wp = new WINDOWPLACEMENT();
*if (Common.IsInclude(screen.Bounds, window.Rect))*{
完全に内包するモニタを見つけた
*if (Common.ExtraInclude(screen.Bounds, window.Rect) == Relation.OtherInclude)*{
一部内包するモニターだった (一部のみのモニターが複数存在するときはどっちの所属でもいい)
*if (tempBelong != WindowObj.OutOfRangeMonitor)*{
範囲外モニターならノータッチ
*if (!IsMonitorEqual())*{
モニタの構造が保存時と異なるときは警告を出す

*if (OnTouch())*{
タッチされたらイベント呼び出し
*{if (0 <; Input.touchCount){Touch touch= Input.GetTouch(0);if (touch.phase == TouchPhase.Began){//タッチした位置からRayを飛ばすRay ray = Camera.main.ScreenPointToRay(touch.position);RaycastHit hit = new RaycastHit();if (Physics.Raycast(ray, out hit)){if (hit.collider.gameObject == this.gameObject){return true;}}}}return false;}
タッチされたらtrueを返す
タッチした位置からRayを飛ばす
*Ray ray = Camera.main.ScreenPointToRay(touch.position);
*{Application.OpenURL(url);}
URLを開く
*{obj.SetActive(true);}
爆発

*null,
変更時イベントハンドラ
*{SKImageInfo info = e.Info;SKSurface surface = e.Surface;SKCanvas canvas = surface.Canvas;canvas.Clear();// 描画範囲をコントロール全体として指定SKRect rect = new SKRect(0, 0, info.Width, info.Height);// グラデーション設定を取得GradientModel gradientModel = GradientModelFactory.Instance.CreateGradientModel(BackGradientColor);if (gradientModel == null){return;}// 塗りつぶしのグラデーション用のSKPaintを作成SKPaint paint = new SKPaint{IsAntialias = true,Style = SKPaintStyle.Fill,Shader = SKShader.CreateLinearGradient(new SKPoint(rect.Left, rect.Top), new SKPoint(rect.Left, rect.Bottom),gradientModel.Colors, gradientModel.ColorPos, SKShaderTileMode.Clamp)};// 背景を描画canvas.DrawRoundRect(rect, CornerRadius, CornerRadius, paint);// 枠線用にSKPaintを変更paint.Style = SKPaintStyle.Stroke;paint.Shader = null;paint.Color = BorderColor.ToSKColor();paint.StrokeWidth = StrokeWidth;// 枠線の描画canvas.DrawRoundRect(rect, CornerRadius, CornerRadius, paint);// 初期描画済みInitialized = true;}
描画するハンドラ
描画範囲をコントロール全体として指定
*SKRect rect = new SKRect(0, 0, info.Width, info.Height);
グラデーション設定を取得
*GradientModel gradientModel = GradientModelFactory.Instance.CreateGradientModel(BackGradientColor);
*{IsAntialias = true,Style = SKPaintStyle.Fill,Shader = SKShader.CreateLinearGradient(new SKPoint(rect.Left, rect.Top), new SKPoint(rect.Left, rect.Bottom),gradientModel.Colors, gradientModel.ColorPos, SKShaderTileMode.Clamp)};
塗りつぶしのグラデーション用のSKPaintを作成
背景を描画
*canvas.DrawRoundRect(rect, CornerRadius, CornerRadius, paint);
枠線用にSKPaintを変更
*paint.Style = SKPaintStyle.Stroke;
枠線の描画
*canvas.DrawRoundRect(rect, CornerRadius, CornerRadius, paint);
初期描画済み
*Initialized = true;
*{if (bindable == null || newValue == null ||newValue.GetType() != BackGradientColorProperty.ReturnType){return;}GradientRect gradientRect = (GradientRect)bindable;// 初期描画前であれば何もしないif (gradientRect.Initialized == false){return;}// 再描画するgradientRect._SkCanvasView.InvalidateSurface();}
BackGradientColor変更後ハンドラ
*if (gradientRect.Initialized == false)*{
初期描画前であれば何もしない
再描画する
*gradientRect._SkCanvasView.InvalidateSurface();
*{ToDo,Doing,Done,}
ステータスを表すenum
*public class Item : INotifyPropertyChanged*{
Statusをプロパティに持つクラス
*{public object Convert(object value, Type targetType, object parameter, CultureInfo culture){var status = (Status)value;switch (status){case Status.ToDo:return GradientColor.DarkRed;case Status.Doing:return GradientColor.DarkYellow;case Status.Done:return GradientColor.LightBlue;default:throw new Exception("Invalid status");}}public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture){throw new NotImplementedException();}}
StatusをGradientColorに変換するコンバーター

*System.Math.Atan2( 0.0,  0.0);
0

*{// Observerを登録subj.DistinctUntilChanged().Where((f) =>; f == 0).Take(1).Subscribe(ProcInit);subj.DistinctUntilChanged().Where((f) =>; f >;= 0).Take(1).Subscribe(Proc0Frame);subj.DistinctUntilChanged().Where((f) =>; f >;= 5).Take(1).Subscribe(Proc5Frame);subj.DistinctUntilChanged().Where((f) =>; f >;= 7).Take(1).Subscribe(Proc7or11Frame);subj.DistinctUntilChanged().Where((f) =>; f >;= 11).Take(1).Subscribe(Proc7or11Frame);subj.DistinctUntilChanged().Where((f) =>; f >; 15).Take(1).Subscribe(ProcFinal, (ex) =>; { }, () =>; { this.subj.Dispose(); });}
コンストラクタ
Observerを登録
*subj.DistinctUntilChanged().Where((f) =>; f == 0).Take(1).Subscribe(ProcInit);
*Action<;int>; ProcInit = (f) =>; { Console.WriteLine("Initialize"); };
ジェネリックデリゲートに処理を用意（直接ラムダ式でSubscribeに入れてもOK）
フレーム更新
*MoveFrame();
*if ( subj.IsDisposed ) {*return (false);
終了したか？
イベント通知
*subj.OnNext((int)GetFrameNow());

*{"Scenes","Prefabs","Scripts","Animations","Materials","PhysicsMaterials","Fonts","Textures","Audios","Resources","Editor","Plugins",};
フォルダー名の一覧
作成先となるフォルダーのパスを取得
*var target = EditorUtility.OpenFolderPanel("Select Project Folder", Application.dataPath, "Project");
*foreach (var folder in folders)*{
プロジェクト以下にフォルダを作成
エディターの更新
*AssetDatabase.Refresh();

エラー処理
*}
1. GETでデータ取得
string uri = "http:localhost:50984/WebService/WebService.asmx/GetBinaryOfZip?userId=1";
*HttpResponseMessage res = await client.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead);
2. 保存するzipファイルのストリームをオープン
*string outputFilePath = "C:\temp\test.zip"
3. 受信データの中身を読み込む
*var resXml = await res.Content.ReadAsStringAsync();
4. Webサービスから取得したBase64文字列をバイト型配列に変換
*byte[] zipBinary =
5. ファイルに書き込む
*await fs.WriteAsync(zipBinary, 0, zipBinary.Length);
*{string entryName = userId + "_test.jpg";byte[] buffer = [jpgのバイナリデータ];// ファイル名を指定してエントリを作成System.IO.Compression.ZipArchiveEntry entry = zipArchive.CreateEntry(entryName);using (Stream es = entry.Open()){// エントリにバイナリを書き込むes.Write(buffer, 0, buffer.Length);}}
メモリストリーム上にZipArchiveを作成する
ファイル名を指定してエントリを作成
*System.IO.Compression.ZipArchiveEntry entry = zipArchive.CreateEntry(entryName);
エントリにバイナリを書き込む
*es.Write(buffer, 0, buffer.Length);

*pixels[4 * i + 3] = (byte)255;
alpha
バイト列をBitmapImageに変換する
*int stride = width * 4;
TaskはUIスレッドと別のスレッドのため、ビットマップにバインドしたプロパティの操作はUIスレッドでやってもらう
そのために、Dispatcherを使う
*MainViewDispatcher.BeginInvoke(new Action(() =>;

*public ListViewRecordColumn[] records {
追加
*private SforceService binding;*public Form1()
bindingオブジェクト
*binding = new SforceService();*binding.Timeout = 30000;
初期化
失敗
*MessageBox.Show(e.Code + ":" + e.Message);
パスワード失効
binding.setPassword(userId, newPassword) で更新が必要
*return false;
エンドポイント更新
string authEndPoint = binding.Url;       初期化時のログイン認証URL
binding.Url = loginResult.serverUrl;     認証後のサービス用URL
セッションヘッダ追加
*binding.SessionHeaderValue = new SessionHeader();
結果表示
*GetUserInfoResult userInfo = loginResult.userInfo;
SOQL発行
リレーション項目も取得可能(取引先担当者が所属する取引先名Account.Name)
*String soqlQuery = "SELECT Id, FirstName, LastName, Account.Name FROM Contact";
デフォルトだと500件までしか取れない
*QueryResult qr = binding.query(soqlQuery);
おわり
*break;
500件以上存在する場合、次の500件を取得
*qr = binding.queryMore(qr.queryLocator);
エラー
*MessageBox.Show(ex.Message);
更新対象配列作成(テストなので適当)
*sObject[] upserts = new Contact[1];
*c0.CustomDate__cSpecified = true;*c0.CustomDate__c = System.DateTime.Now;
カスタム項目を扱う場合、指定フラグを立てる必要がある
Email一致の場合UPDATE、それ以外の場合INSERT
*UpsertResult[] upsertResults = binding.upsert("Email", upserts);

Androidのファイル・ディレクトリ取得
*var folderPath = System.Environment.GetFolderPath(System.Environment.SpecialFolder.Personal);

*Console.WriteLine(i);
=&gt; 10
*public void value1( int x ) {x = 10;}
値型の値渡し
*public void value2( ref int x ) {x = 10;}
値型の参照渡し

*int fs = 1800;
サンプリング周波数
バタフライ演算のための置き換え
*output[i] = input[reverseBitArray[i]];
*for (int stage = 1; stage <;= bitSize; stage++)*{
バタフライ演算
*{var result = new int[arraySize];var halfSize = arraySize >;>; 1;result[0] = 0;for (int i = 1; i <; arraySize; i <;<;= 1){for (int j = 0; j <; i; j++) result[j + i] = result[j] + halfSize;halfSize >;>;= 1;}return result;}
ビットを左右反転した配列を返す

*ChildRects = GetComponentsInChildren<;RectTransform>;().Where(x=>;x != MyRect).Where(x=>;x.GetComponent<;LayoutElement>;() == null ? true : !x.GetComponent<;LayoutElement>;().ignoreLayout).ToArray();*_LayoutGroup = GetComponent;VerticalLayoutGroup>;();
自身のRectTransformと子のLayoutElementでignoreLayoutのものは除外する

*graphics.MeasureString(item.ToString() , this.Font).Width);
ドロップダウンリストの内容の幅を取得している

*if(args.Length != 1)*{
引数バリデート
*if (args.Length != 1)*{
引数バリデート
コピーするファイルパスを決定するぞい
*string to_file_path_;
元ファイルと同じフォルダーにコピーします
*to_file_path_ = Path.GetDirectoryName(from_file_path_) + @"\";
ファイル名は現在時刻を元に決定
2021年05月01日18時25分なら『20210501_1825』
*to_file_path_ += DateTime.Now.ToString("yyyyMMdd_HHmm");
拡張子は元ファイルから引き継ぎます
*to_file_path_ += Path.GetExtension(from_file_path_);
*if (File.Exists(to_file_path_))*{
ファイル上書きになる場合はコピーせずに中断
ファイルコピー実行！
*File.Copy(from_file_path_, to_file_path_);

*void Update() {_wait -= Time.deltaTime;if (_wait <;= 0f) {_wait = _bpm / 60f;_ring.Play();}}
Updateは60FPSで回っているとします

円運動の中心となるGameObject
*[SerializeField] GameObject center;
円運動の速度
*float speed = 20;
*void Update () {//RotateAround(円運動の中心,進行方向,速度)transform.RotateAround(center.transform.position,transform.forward, speed * Time.deltaTime);}
Update is called once per frame
*transform.RotateAround(center.transform.position,*transform.forward, speed * Time.deltaTime);
RotateAround(円運動の中心,進行方向,速度)
円運動させたい物体。Rigidbodyをコンポーネントさせておく
*[SerializeField] Rigidbody rbody;
速度を設定
*private float speed =1.0f;
半径を設定
*private float radius =2.0f;
float型を定義しておく
*float movex;
*void Update () {//movex(Sin波）・moveZ座標(Cos波）の指定をしておく。わからないときは三角関数を調べる。movex = radius * Mathf.Sin(Time.time * speed);movez = radius * Mathf.Cos(Time.time * speed);//Rigidbodyのオブジェクトを移動。rbody.MovePosition(new Vector3(movex, transform.position.y, movez));}
Update is called once per frame
movex(Sin波）・moveZ座標(Cos波）の指定をしておく。わからないときは三角関数を調べる。
*movex = radius * Mathf.Sin(Time.time * speed);
*rbody.MovePosition(new Vector3(movex, transform.position.y, movez));*}
Rigidbodyのオブジェクトを移動。

とりあえずの配列数144*16
*GameObject[] Bullet = new GameObject[2304];
*for (int i = 0; i <; 1296; i++) {*Bullet[i] = (GameObject)Instantiate(pool_Bullet);
配列に格納して子オブジェクトに
*if (WaitFrame >; 10) {*for (int i = 0; i ;= (Angle_Split - 1); i++) {
10フレームに1回円形弾幕
n-way弾流用。360度方向にだす
*float AngleRange = PI * (Degree / 180);
弾インスタンスに渡す角度の計算
*_theta = (AngleRange / (Angle_Split - 1)) * i + 0.5f * (PI - AngleRange);
弾インスタンスからスクリプト取得
*GameObject Bullet_obj = poolBullet();
アクティブになったフラッグ
*bullet_cs.Bulletmove_flag = true;
*bullet_cs.Lpos = transform.position;*bullet_cs.theta = _theta;
角度と初速に加えて、ランチャーの座標も渡す(消滅までの距離測るため)
プールから使うオブジェクトのナンバー。初期化はｰ1
*int Obj_No = -1;
*int Obj_Cnt = transform.childCount;*//for文で調べる非アクティブのオブジェクトがあれば抜ける
プールの中のオブジェクトの数
*for (int i = 0; i <; Obj_Cnt; i++) {*if (!Bullet[i].activeSelf) {
for文で調べる非アクティブのオブジェクトがあれば抜ける
*if (Obj_No == -1) {*Obj_No = Obj_Cnt;
プール中のオブジェクト全てアクティブなら、増やして新しく配列に入れる
使うオブジェクトを返す
*return Bullet[Obj_No];
Rigidbody取得
*rid2d = GetComponent<;Rigidbody2D>;();
*if (Bulletmove_flag) {*//角度を考慮して弾の速度計算
アクティブになった時の弾の動き
角度を考慮して弾の速度計算
*Vector2 bulletV = rid2d.velocity;
*Vector2 Bpos = transform.position;*float Distance_to_Luncher = Vector2.Distance(Bpos, Lpos);
弾の座標とランチャーから送られてきた座標で距離を計算
*if (Distance_to_Luncher >;= 50) Object_false();*}
今回はランチャーからの距離が消滅の条件
*void Object_false() {transform.position = Lpos;gameObject.SetActive(false);}
非アクティブになる前に座標をリセット

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

*{Debug.Log(DLL.add_function(1, 1));}
Start is called before the first frame update

LeapMotionのコントローラー
*controller = new Controller();
LeapMotionから手の情報を取得
*var handsStream = this.UpdateAsObservable()
両手グー開始判定ストリーム
*var beginDoubleRockGripStream = handsStream
両手グー終了判定ストリーム
*var endDoubleRockGripStream = handsStream
カメラ拡縮
*beginDoubleRockGripStream
カメラ回転
*beginDoubleRockGripStream
カメラ移動
*beginDoubleRockGripStream
両手なら
*hands.Count == 2 &amp;&amp;
１つ目の手の指の内、開いている数が0個なら
*hands[0].Fingers.ToArray().Count(x =>; x.IsExtended) == 0 &amp;&amp;
２つ目の手の指の内、開いている数が0個なら
*hands[1].Fingers.ToArray().Count(x =>; x.IsExtended) == 0;
カメラ拡縮
*beginDoubleRockGripStream
両手の距離を計算
*.Select(hands =>; hands[0].PalmPosition.DistanceTo(hands[1].PalmPosition))
距離が正の値なら（0割防止）
*.Where(distance =>; distance >; 0.0f)
バッファに前回と今回の２つの値を詰める
*.Buffer(2, 1)
今回と前回の商から距離の変化量を計算
*.Select(distances =>; distances[1] / distances[0])
両手グーが終了したらバッファをクリアにする
*.TakeUntil(endDoubleRockGripStream).RepeatUntilDestroy(this)
距離変化割合が正の値なら（0割防止）
*.Where(distanceRate =>; distanceRate >; 0.0f)
*.Subscribe(distanceRate =>; transform.localScale /= distanceRate);*,,,
カメラを拡縮
カメラ回転
*beginDoubleRockGripStream
両手の差ベクトルを計算
*.Select(hands =>; ToVector3(hands[1].PalmPosition - hands[0].PalmPosition))
*.Where(diff =>; diff.magnitude >; 0.0f)*// バッファに前回と今回の２つの値を詰める
距離が正の値なら（0割防止）
バッファに前回と今回の２つの値を詰める
*.Buffer(2, 1)
*.Select(diffs =>; Quaternion.AngleAxis(Vector3.Angle(diffs[0], diffs[1]), Vector3.Cross(diffs[1], diffs[0])))*// 両手グーが終了したらバッファをクリアにする
方向の変化量（クォータニオン）を内積と外積から計算
両手グーが終了したらバッファをクリアにする
*.TakeUntil(endDoubleRockGripStream).RepeatUntilDestroy(this)
*.Subscribe(quaternion =>; transform.rotation *= quaternion);*,,,
カメラを回転
カメラ移動
*beginDoubleRockGripStream
両手のひらの中点の位置を取得
*.Select(hands =>; ToVector3((hands[0].PalmPosition + hands[1].PalmPosition) * 0.5f))
バッファに前回と今回の２つの値を詰める
*.Buffer(2, 1)
今回と前回の差から中点の移動ベクトルを計算
*.Select(positions =>; positions[1] - positions[0])
両手グーが終了したらバッファをクリアにする
*.TakeUntil(endDoubleRockGripStream).RepeatUntilDestroy(this)
*.Subscribe(movement =>; transform.Translate(-speed * movement));*,,,
カメラを移動

*if (e.KeyData == (Keys.Control | Keys.Shift | Keys.T))
Ctrl+Shift+Tを捕まえたい

*new Claim(ClaimTypes.NameIdentifier, Input.Email),
ユニークID
一意の ID 情報
*var claimsIdentity = new ClaimsIdentity(
ログイン
*await HttpContext.SignInAsync(
Cookie をブラウザー セッション間で永続化するか？（ブラウザを閉じてもログアウトしないかどうか）
*IsPersistent = Input.RememberMe

*{Cube,Ball,}
列挙型：種類を列挙

*StartCoroutine(SpawnWaves());
敵の生成を開始

Updateの中
*var r_stickForce = m_joyconR.GetStick();
_camera = カメラPrefabのRootObject
*var currentPosition = _camera.position;
_right = バットのTransform
JoyconとUnityの角度の表し方がは違うらしいがこれで縦持ちでしっくり来る
*var q = m_joyconR.GetVector().eulerAngles;
_rightCollider = バットのCollider
*_rightCollider.OnCollisionEnterAsObservable().TakeUntilDestroy(this).Subscribe(
家具に当たったときの判定がめんどくさいのでキャラのパーツすべてにGameControllerのタグを付ける
*return;
キャラのAnimatorをdisable。本来ならcollision.gameObjectからどうにかして引っこ抜く。
*_animator.enabled = false;
そのComponentがないときにGetComponentするとnullが返ってくるのでその場合はAddComponentする。
トリッキーなコードなので使ったらだめ。
*var rigid = collision.gameObject.GetComponent<;Rigidbody>;() ?? collision.gameObject.AddComponent<;Rigidbody>;();

インターフェース参照用変数
*ICharQueue iq;
SimpleQueueオブジェクトを参照する
*iq = sq;
参照先のクラスを意識せずメソッドを呼びだせる
*iq.Enqueue((char)('A' + i));
参照先のクラスを意識せずメソッドを呼びだせる
*tempCh = iq.Dequeue();
ListQueueオブジェクトを参照する
*iq = lq;
参照先のクラスを意識せずメソッドを呼びだせる
*iq.Enqueue((char)('A' + i));
参照先のクラスを意識せずメソッドを呼びだせる
*tempCh = iq.Dequeue();

*void Awake() {Debug.Log("パターン1（Awakeで初期化）");var gameCharacter = new GameObject("GameCharacter");gameCharacter.AddComponent<;GameCharacter>;();Debug.Log("Game Start!");}
ゲーム開始時にキャラクターを生成する
*void Awake() {Debug.Log("Initializing GameCharacter");throw new System.Exception("GameCharacter: Initialization failed");}
だがそいつは初期化時にエラーを起こしてしまう死のキャラクターだった！
*void Awake() {Debug.Log("パターン2（Initメソッドで初期化）");var gameCharacter = new GameObject("GameCharacter");gameCharacter.AddComponent<;GameCharacter>;().Init();Debug.Log("Game Start!");}
ゲーム開始時にキャラクターを生成する
*public void Init() {Debug.Log("Initializing GameCharacter");throw new System.Exception("GameCharacter: Initialization failed");}
だがそいつは初期化時にエラーを起こしてしまう死のキャラクターだった！
*try {var gameCharacter = new GameObject("GameCharacter");gameCharacter.AddComponent<;GameCharacter>;();} catch {Debug.LogWarning("キャラクター生成できなかったけどいいよね？");}
パターン1 + try-catch
*try {var gameCharacter = new GameObject("GameCharacter");gameCharacter.AddComponent<;GameCharacter>;().Init();} catch {Debug.LogWarning("キャラクター生成できなかったけどいいよね？");}
パターン2 + try-catch

*string  _UploadFile
アップロードファイル名
カレントディレクトリ変更
*_sftp.ChangeDirectory(_UploadPath);
アップロード先パス
*var _RemotePath = _UploadPath + "/" + Path.GetFileName(_UploadFile);

*string url = "https:
www.google.co.jp";

*httpClient.BaseAddress = new Uri($"https:
{hostName}");
適当
*var databaseAccount = await documentClient.GetDatabaseAccountAsync();
*{public SampleContext(DbContextOptions<;SampleContext>; options): base(options){ }public DbSet<;Sample>; Samples { get; set; }}
適当
適当
*dbContext.Database.OpenConnection();

例） IsomeInterfaceのGetIntValue()メソッドの結果を1に差し替える
*substitute.GetIntValue().Returns(1);
あかーん例
*var substitute = Substitute.For<;ISomeInterface>;();

少しスペースを空ける
*EditorGUILayout.Space();
*if (GUILayout.Button("Inspectorに表示されるボタン名"))*{
押下時に実行したい処理
少しスペースを空ける
*EditorGUILayout.Space();
*if (GUILayout.Button("Inspectorに表示されるボタン名"))*{
押下時に実行したい処理
*if (GUILayout.Button("Test") &amp;&amp; EditorApplication.isPlaying == false)*{
押下時に実行したい処理
押下時の処理
*}

*return Task.FromResult(new TestResponse { Value = request.Value });
リクエストされた値をおうむ返ししているだけです
バイト配列へのシリアライズ
*obj =>; MessagePack.MessagePackSerializer.Serialize<;T>;(obj)
バイト配列からのデシリアライズ
*, bytes =>; MessagePack.MessagePackSerializer.Deserialize<;T>;(bytes)
RPCメソッドの種類
*MethodType.Unary
サービス名
*, "TestService"
メソッド名
*, "GetResponse"
リクエスト／レスポンスのマーシャラー
*, requestMarshaller
サービスメソッドへの参照を必要とするため、サービスクラスのインスタンスを生成
*TestService service = new TestService()
RPCメソッドを追加
TestRpcMethods はRPCメソッドの定義（Method&lt;TRequest, TResponse&gt;）をまとめたクラスです
*ServerServiceDefinition.Builder builder = ServerServiceDefinition.CreateBuilder();
ビルド
*ServerServiceDefinition definition = builder.Build();
インターセプターを設定するならここで設定する
*definition = definition
開始
*server.Start();
インターセプターを設定するならここで設定する
*invoker = invoker
TestRpcMethods はRPCメソッドの定義（Method&lt;TRequest, TResponse&gt;）をまとめたクラスです
*return Invoker.BlockingUnaryCall(TestRpcMethods.GetResponse, "", options, request);

*", SampleHz=" + wh.nSamplesPerSec.ToString();
サンプリング周波数(44.1kHzとか48kHzとか)

*rectTransform.DOLocalMoveX(-100, 0.40f).SetRelative();
0.4秒かけて現在地からみて-100に移動する
*transform.DOMove(new Vector3(, , ), 1).SetRelative();*,,,
ちなみに3Dオブジェクトなら　DOMoveを使用する
ダメなやり方
*gameObj.GetComponent<;ScrollBar>;.value = 1.0f;
正しいやり方
*gameObj.GetComponent<;ScrollRect>;.verticalNormalizedPosition = 1.0f;
DOTween使用
canvasGroup.DOFade(0, 1.0f); 1.0f秒かけながら、alpha0になっていく
*,,,
初期位置格納用
*private float gameObjInitX;
*{gameObjInitX = gameObj.GetComponent<;RectTransform>;().anchoredPosition.x;gameObjInitY = gameObj.GetComponent<;RectTransform>;().anchoredPosition.y;}
最初に初期位置の取得
*{gameObj.GetComponent<;RectTransform>;().anchoredPosition = new Vector2(gameObjInitX, gameObjInitY);}
初期位置に戻したいときに呼ぶ
*float width = rectTransform.sizeDelta.x;*float height = rectTransform.sizeDelta.y;
幅と高さを取得
*rectTransform.sizeDelta = new Vector2 (width + 加えたい幅, height);*,,,
今の幅+足したい幅
インスペクタからアタッチ
*public Image _image;
_iamgeの画像を_spriteに変更
*_image.sprite = _sprite;

*}
end of class C

ボタンを取得し、イベントを設定する（ボタンのidとして設定されているbutton1を指定）
*Button button1 = FindViewById<;Button>;(Resource.Id.button1);
通知出力
*Toast.MakeText(Application.Context, "click " + DateTime.Now.ToString(), ToastLength.Long).Show();

対象フォルダの取得
*var folder = GetCalenderFolder(mailOrName);
スケジュールの検索
*var items = GetScheduleItems(folder, start, end);
定期的なスケジュールを展開して、ScheduleItemに変換
*var schedules = ExpansionAndConvert(items, start, end);
ここの取得が成功したらスケジュールが存在するって判定になる
*var recur = pattern.GetOccurrence(cur);
指定の日付幅だけにする、ついでにソート
*ret = ret.Where(x =>; start <;= x.Start)
メールアドレス もしくは 名前 を指定
対象日時を指定（Start～Endでの指定もできます）
*var schedules = outlookManager.GetScheduleList("test@test.com", DateTime.Today);

*[SerializeField] Text TriggerText;
追加
*void Start () {}
Use this for initialization
*void Update () {// ここから2行追加transform.rotation = VvrController.Orientation();TriggerText.text = VvrController.Trigger().ToString();}
Update is called once per frame
*transform.rotation = VvrController.Orientation();*TriggerText.text = VvrController.Trigger().ToString();
ここから2行追加

if (this.Weights[i] &lt; this.Weights.Length)  上限を撤廃
*this.Weights[i]++;
*randomResult.Select((value, index) =>; (value, index)).ToLookup(t =>; t.value, t =>; t.index).SelectMany(ToDiff)*));
shuffleResult.Select((value, index) =&gt; (value, index)).ToLookup(t =&gt; t.value, t =&gt; t.index).SelectMany(ToDiff)

*Thread.Sleep(millisec);
Task.Run内Sleep

*Console.WriteLine(y);
5. yを画面に出力．

クラス自体の変数は下記の4行で定義
*private int id;
*public int Id { get; set; }
下記の4行でStudentクラスの変数に直接アクセスできない様にカプセル化
渡されるデータが幾つなのかはコンソールから渡す
*var N = int.Parse(Console.ReadLine());
今回は身長によって2つのクラスに分ける
*var listH = new List<;Student>;();
*for (int i = 1; i <;= N; i++)*{
渡されたN回数分をループで回す
Ver. 9.0からStudentクラスをインスタンス化(newだけで以下のクラス名は省略できる)
*Student src = new();
コンソールからまず身長が渡されるとする
*int studentTall = int.Parse(Console.ReadLine());
Student型の変数srcに新規内容として格納(iが出席番号)
*src.Id = i;
*if (hoge == "High")*{
基準の身長で入れるリストを分ける
体重がコンソールから入力される(半角スペース区切りで1行の入力)
*int[] weightArr = Array.ConvertAll(Console.ReadLine().Trim().Split(' '), int.Parse);
名前がコンソールから入力される(半角スペース区切りで1行の入力)
*string[] nameArr = Console.ReadLine().Trim().Split(' ');
身長によって入れているListが異なるので条件分岐にて振り分ける
その際に出席番号としてidをclassで持たせているので
そのidがListに入っているStudentクラスにあるかどうかを判定する
listのメソッドのFindメソッドを利用して、
その中でラムダ式にて該当idを探す ←これ大切です‼️‼️‼️‼️‼️
*if (listH.Find(x =>; x.Id == i) != null)
コンソールから取得した体重と名前をFIndメソッドで見つけたidのクラスに付与する
*listH.Find(x =>; x.Id == i).Weight = weightArr[i];
コンソールから取得した体重と名前をFIndメソッドで見つけたidのクラスに付与する
*listL.Find(x =>; x.Id == i).Weight = weightArr[i];
*for (int i = 1; i <;= N; i++)*{
各グループの一番体重の重い人を調べる
*if (listH.Find(x =>; x.Id == i) != null*&amp;&amp; listH.Find(x =>; x.Id == i).Weight >; dictHighList["heaviest"])
各グループに存在するID で一番体重が重たい

*var alwaysFalse = myList.Any();
常にfalse

*Excel.Range start_cell = cells[2, 1];
タイトルは含めない

カテゴリ：動物
*searchQuery.category = PolyCategory.ANIMALS;
犬を検索
*searchQuery.keywords = "dog";

*foreach (string name in GetFriendsNames())*{
1回目
2回目
*IEnumerable<;string>; names = GetFriendsNames();
*foreach (string name in names)*{
3回目
2回目
*IEnumerable<;string>; names = GetFriendsNames();
Listを生成
*var nameList = new List<;string>;();
Listを生成
*var nameList = new List<;string>;();
↑すでにメモリ上にあるnameListを使うので、再度リスト作成することはない
*Console.WriteLine(name);
まったく意味ないが
*var mick = nameList

*{if (e.Button == MouseButtons.Left){Win32Api.MouseLeftDownOnFormTitleBar(this);}}
using System.Runtime.InteropServices;

*private Action _Callback = delegate { };
こんな感じで初期化しておくと呼び出すときにnullチェック不用
こんな感じで初期化しておくとnullチェック不用
*private OnceAction _Callback = OnceAction.Default;

*Vector2 pos = transform.position;*pos.x += 0.1f * Input.GetAxisRaw("Horizontal");
ランチャーの移動================================
*if (Input.GetKeyDown(KeyCode.Space)) {for (int i = 0; i <;= (Angle_Split - 1); i++) {//n-way弾の端から端までの角度float AngleRange = PI * (Degree / 180);//弾インスタンスに渡す角度の計算if (Angle_Split >; 1) _theta = (AngleRange / (Angle_Split - 1)) * i + 0.5f * (PI - AngleRange);else _theta = 0.5f * PI;//弾インスタンスを取得し、初速と発射角度を与えるGameObject Bullet_obj = (GameObject)Instantiate(Bullet, transform.position, transform.rotation);BulletSc bullet_cs = Bullet_obj.GetComponent<;BulletSc>;();bullet_cs.theta = _theta;bullet_cs.Velocity_0 = _Velocity_0;}}
================================================
*if (Input.GetKeyDown(KeyCode.Space)) {*for (int i = 0; i ;= (Angle_Split - 1); i++) {
スペースキーで弾発射
n-way弾の端から端までの角度
*float AngleRange = PI * (Degree / 180);
*if (Angle_Split >; 1) _theta = (AngleRange / (Angle_Split - 1)) * i + 0.5f * (PI - AngleRange);*else _theta = 0.5f * PI;
弾インスタンスに渡す角度の計算
*GameObject Bullet_obj = (GameObject)Instantiate(Bullet, transform.position, transform.rotation);*BulletSc bullet_cs = Bullet_obj.GetComponent;BulletSc>;();
弾インスタンスを取得し、初速と発射角度を与える
Rigidbody取得
*rid2d = GetComponent<;Rigidbody2D>;();
角度を考慮して弾の速度計算
*Vector2 bulletV = rid2d.velocity;
*if (Angle_Split >; 1) _theta = (AngleRange / (Angle_Split - 1)) * i - 0.5f * AngleRange;*else _theta = 0;
弾インスタンスに渡す角度の計算

1.コンテキストメニューから処理を呼び出せるように属性を付加
*[MenuItem("CONTEXT/MonoBehaviour/Set ScriptName To GameObject")]
2.選択したスクリプト名を取得
*var name = command.context.GetType().ToString();
*while (name.Contains("."))*{
3.スクリプト名の名前空間を取り除く
4.選択したコンテキストの先頭文字は現在のオブジェクト名になる
*var target = command.context.ToString().Split(' ')[0];
シーン内にあるオブジェクトを取得してスクリプト名を設定
*GameObject.Find(target).name = name;

*if (AsinX <;= 1) AsinX = 1.0f;
Asinの中身が1を超えるとまずいので
θ算出
*float _theta = 0.5f * Mathf.Asin(AsinX);
*if (LuncherPos.x >; TargetPos.x) _theta = Mathf.PI - 0.5f * Mathf.Asin(AsinX);*//弾インスタンスを取得し、初速と発射角度を与える
ターゲットとの位置関係で発射方向反転
*GameObject Bullet_obj = (GameObject)Instantiate(Bullet, transform.position, transform.rotation);*BulletSc bullet_cs = Bullet_obj.GetComponent;BulletSc>;();
弾インスタンスを取得し、初速と発射角度を与える
Rigidbody取得
*rid2d = GetComponent<;Rigidbody2D>;();
角度を考慮して弾の速度計算
*Vector2 bulletV = rid2d.velocity;

*await Task.Delay(millisecond);
ミリ秒待つ
Deeplからダウンロード
*jsonString = await DeeplFileTranslator.Download(document_id, document_key, output_path);
翻訳完了を知らせるために, ダウンロードフォルダを開く
*Application.OpenURL("file:C:\\Users\\" + Environment.UserName + "\\Downloads");

*using MyExtension;
拡張メソッドのnamespaceを入れておく
サンプル1個目
*int number = 5;
サンプル2個目
*var slist = new List<;string>;();
サンプル3個目
*Console.WriteLine("オラ".MyMakeOraora(10, "ァァァァァ！"));

*{JwtID = Guid.NewGuid().ToString(),Audience = "testAudience",Expiration = DateTimeOffset.UtcNow.AddSeconds(120),NotBefore = DateTimeOffset.UtcNow.AddSeconds(-5),};
create a claim and a payload.
*int secondsBefore = 60;*TokenManager manager = CreateManager(secondsBefore);
create the token manager.
*if (!m_Validator.ValidateToken(*tokenString
refresh the token
*TokenInfo accessToken = new TokenInfo(provider.CreateToken(claim, payload), claim.Expiration, claim.NotBefore);*// create a refresh token.
create a access token.

コンストラクタ.
*public Hoge(
自身がエディタのアセンブリだという宣言.
*[assembly: AssemblyIsEditorAssembly]
何かの処理とか.
Hoge hogeData;  どこかでインスタンスを取得する.
*void OnGUI()
こちら側でのアクセスはErrorを吐き出す.
*hoge.Name = "I Love Unity";

*{CanExecuteChanged?.Invoke(this, EventArgs.Empty);}
他のメソッドなどは省略
*{add { CommandManager.RequerySuggested += value; }remove { CommandManager.RequerySuggested -= value; }}
他のメソッドなどは省略
手抜き 本来はCanExecuteの値が変わる時だけ呼び出すべき
*CanExecuteChanged?.Invoke(this, EventArgs.Empty);

*var fields = parser.ReadFields();
⇒ string[] { "abc", "d\"ef", "gh,i", "jk" }
*{public string Dummy { get; set; }}
カスタムクラスとそのインスタンスを用意
*var xslt = new XslCompiledTransform();*xslt.Load("test.xsl", new XsltSettings(true, true), null);
XSL ファイルを読み込む
*using (var writer = XmlWriter.Create(memory, new XmlWriterSettings() { Encoding = Encoding.UTF8, Indent = true }))
カスタムクラスの内容を XML としてメモリに書き込む
*{memory.Position = 0;xsl.Transform(memory, stream, Encoding.UTF8);}
メモリ内の XML を XSL 変換してファイルに出力

string endPoint = "http:localhost:8080";  こちらは例外でない
string endPoint = "http:&lt;host&gt;:8080";  こっちは例外が出る
*HttpListener server = new HttpListener();

例外ハンドラの登録
*GlobalConfiguration.Configuration.Filters.Add(new CustomExceptionFilter());

*string url = "https:
jsonplaceholder.typicode.composts";

Stride0のフィールド X を destにコピペする
*UnsafeUtility.MemCpyStride(dest, sizeof(Guid), src, sizeof(Stride0), sizeof(Guid), size);

*using Microsoft.EntityFrameworkCore;
追加
省略
追加
*[HttpPut]
*[HttpDelete("{id}")]
省略
*[HttpDelete("{id}")]
追加

プロパティ経由でDIコンテナから依存オブジェクトを取得して使用する。
*return this.Service.GetText();
*foreach (var mock in this.mocks)*{
モックが期待どおりに呼び出されたことを検証する。
RegisterMock はジェネリック引数（ここでは暗黙指定）から型を判定するので、登録処理自体をデリゲートに収める。
（List&lt;Mock&gt; では型を渡せない）
*this.registerMocks += builder =>; builder.RegisterMock(mock);
モック設定
*var serviceMock = CreateMock<;Service>;();
*{// テスト対象オブジェクトを生成var client = autoMock.Create<;Client>;();// テスト対象メソッドを実行string result = client.Act();// 戻り値の検証// ※モックの検証は基底クラスで自動的に行われる。Assert.AreEqual("UnitTest", result);}
モックのDI登録
テスト対象オブジェクトを生成
*var client = autoMock.Create<;Client>;();
テスト対象メソッドを実行
*string result = client.Act();
戻り値の検証
※モックの検証は基底クラスで自動的に行われる。
*Assert.AreEqual("UnitTest", result);

*var task3 = Task<;double<;.Run(() =<; { Thread.Sleep(2000); return 3.33; });
task3 開始
戻り値
Debug.WriteLine("戻り値1：" + task1.Result);  ここでブロックかかり、task1が終わるまでの5秒間UIフリーズ
*Debug.WriteLine("戻り値2：" + task2.Result);

*.UseUnityServiceProvider()
&lt;-- こっちが正解.
*//{//    container.RegisterType<;I~~Repository, ~~Repository>;();//    // 省略//})
.UseServiceProviderFactory&lt;IUnityContainer&gt;(new ServiceProviderFactory(new UnityContainer()))
*//{//    container.RegisterType<;I~~Repository, ~~Repository>;();//    // 省略//})
.ConfigureContainer&lt;IUnityContainer&gt;((hostContext, container) =&gt;
省略
})
*.RunConsoleAppFrameworkAsync<;MainApp>;(args);

*var payload = "message=" +
メッセージを入力;

*return new string[] { "value1", "value2" };
←ココにブレークポイントを設定

*foo.Hello();
ここでコピー発生。
元のfooではなく、fooのコピーをつくってから Hello() を呼びだす。
メソッド呼び出しで値が変わるか知る方法がないため。
*}

Unityエディタ上でもビルドターゲットをiOSにしているとUNITY_IOSがtrueとなるため
iOS実機ビルド時のみ __internal 読み込みとなるよう指定
*#if UNITY_IOS &amp;&amp; !UNITY_EDITOR_OSX

オブジェクトのNameプロパティで選択
*TextBox1= session.FindElementByAccessibilityId("TextBox1");
AccessibleNameプロパティで選択
*Button1= session.FindElementByName("ボタン1");
ボタンをクリック
*Button1.Click();
テキストボックスに文字入力
TextBox1.SendKeys("あいうえお"); キー入力
スリープ（文字入力後は少し待たないと、.Textプロパティの戻り値が途中経過みたいになってFailするぽい
*Thread.Sleep(TimeSpan.FromSeconds(1));
テキストボックスの内容が期待通りか確認
*Assert.AreEqual("あいうえお", TextBox1.Text);
チェックボックスの状態は.Selectedプロパティ
Assert.IsTrue(CheckBox1.Selected); チェックされてればパス
CheckBox1.Click(); クリックして状態を変更
Assert.IsTrue(CheckBox1.Selected); ここでフェイル
その他、inspect.exeで取得できるプロパティは.GetAttribute()メソッドを使う
*Assert.AreEqual("あいうえお", TextBox1.GetAttribute("Value.Value").ToString());

*uint dof = 1;
スカラー
*{var FEM = new SampleFEM(world);{//var solver = new IvyFEM.Linear.LapackEquationSolver();//solver.Method = IvyFEM.Linear.LapackEquationSolverMethod.Dense;//solver.IsOrderingToBandMatrix = true;//solver.Method = IvyFEM.Linear.LapackEquationSolverMethod.Band;//solver.Method = IvyFEM.Linear.LapackEquationSolverMethod.PositiveDefiniteBand;//FEM.Solver = solver;}{//var solver = new IvyFEM.Linear.LisEquationSolver();//solver.Method = IvyFEM.Linear.LisEquationSolverMethod.Default;//FEM.Solver = solver;}{var solver = new IvyFEM.Linear.IvyFEMEquationSolver();solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.NoPreconCG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.CG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.ICCG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.NoPreconBiCGSTAB;FEM.Solver = solver;}FEM.Solve();double[] U = FEM.U;world.UpdateFieldValueValuesFromNodeValues(valueId, FieldDerivativeType.Value, U);fieldDrawerArray.Update(world);mainWindow.glControl.Invalidate();mainWindow.glControl.Update();WPFUtils.DoEvents();}
WPFUtils.DoEvents();
*{//var solver = new IvyFEM.Linear.LisEquationSolver();//solver.Method = IvyFEM.Linear.LisEquationSolverMethod.Default;//FEM.Solver = solver;}
FEM.Solver = solver;
*{var solver = new IvyFEM.Linear.IvyFEMEquationSolver();solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.NoPreconCG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.CG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.ICCG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.NoPreconBiCGSTAB;FEM.Solver = solver;}
FEM.Solver = solver;

*SHISAKU.MOJI = "文字";
ここではstring型やint型の編集ルールをそのまま用いる。

*else if (sight_x <; 0)
sight_x が0度を下回ると360からsight_xを引く、残った分はsight_xに残る

*where T : IAdd<;T<;
T型に対して「IAdd&lt;T&gt;インターフェースを実装していないとダメ！」という制約を設けられる.
IAdd&lt;T&gt;を実装していることが前提のため, Add()メソッドを利用することが可能に！！
*return lhs.Add(rhs);
以下のコードはエラーに...
*var sum = Sum(num1, num2);

*{Test();Debug.Log(4);Test();}
Start is called before the first frame update
Taskを使用する準備
*using System.Threading;
おまじない
*private SynchronizationContext context;
*{//おまじないcontext = SynchronizationContext.Current;//実行時にawaitを使用await Test();Debug.Log(4);//実行時にawaitを使用しないTest();await Test();//1000ms待つawait Task.Delay(1000);Test();Debug.Log("StartFuncFinish!");}
voidをasync Taskに置き換え
おまじない
*context = SynchronizationContext.Current;
実行時にawaitを使用
*await Test();
実行時にawaitを使用しない
*Test();
1000ms待つ
*await Task.Delay(1000);
*{Debug.Log(1);//1000ms待つawait Task.Delay(1000);Debug.Log(2);//1000ms待つawait Task.Delay(1000);Debug.Log(3);//1000ms待つawait Task.Delay(1000);}
voidをasync Taskに置き換え
1000ms待つ
*await Task.Delay(1000);
1000ms待つ
*await Task.Delay(1000);
1000ms待つ
*await Task.Delay(1000);
タスクを使用する準備
*using System.Threading;
おまじない
*private SynchronizationContext context;
*{//おまじないcontext = SynchronizationContext.Current;//足し算の結果が返ってくるまで待つ．返ったらcに格納される．int c = await MyAddFuncAsync(5, 4);//cを出力Debug.Log(c);Debug.Log("StartFuncFinish!");}
Start is called before the first frame update
おまじない
*context = SynchronizationContext.Current;
足し算の結果が返ってくるまで待つ．返ったらcに格納される．
*int c = await MyAddFuncAsync(5, 4);
cを出力
*Debug.Log(c);
引数2つを足し算し結果を返すTask
返り値はintなのでTask&lt;int&gt;のTaskとなる．
*async Task<;int>; MyAddFuncAsync(int a,int b)
*{return a + b;}
待たない関数で普通に書いたらこうなる
タスクを使用する準備
*using System.Threading;
おまじない
*private SynchronizationContext context;
*{//awaitをつけずにTaskを実行StartAsync();Debug.Log("StartFuncFinish!");}
Start is called before the first frame update
awaitをつけずにTaskを実行
*StartAsync();
おまじない
*context = SynchronizationContext.Current;
UniTaskを使用する準備
*using UniRx.Async;
*{//awaitをつけずにTaskを実行StartAsync();Debug.Log("StartFuncFinish!");}
Start is called before the first frame update
awaitをつけずにTaskを実行
*StartAsync();

↓ ここに入れる
*Dapper.DefaultTypeMap.MatchNamesWithUnderscores = true;

*public LBool   m_bool;
bool型
*[System.Serializable] public class LGameObject : ReorderList<;GameObject>; { }
UnityEngine
*[System.Serializable] public class LText : ReorderList<;UnityEngine.UI.Text>; {}
追加 TextComponentをReorderableListで使えるようにする

*swing = Quaternion.identity;
no swing
*} else {
always twist 180 degree on singularity
*// http://www.euclideanspace.com/maths/geometry/rotations/for/decomposition/*Vector3 p = Vector3.Project(r, twistAxis);
formula &amp; proof:

*[SerializeField] private AudioClip m_LandSound;
the sound played when character touches back on ground.
*{m_CharacterController = GetComponent<;CharacterController>;();m_Camera = Camera.main;m_OriginalCameraPosition = m_Camera.transform.localPosition;m_FovKick.Setup(m_Camera);m_HeadBob.Setup(m_Camera, m_StepInterval);m_StepCycle = 0f;m_NextStep = m_StepCycle/2f;m_Jumping = false;m_AudioSource = GetComponent<;AudioSource>;();m_MouseLook.Init(transform , m_Camera.transform);}
Use this for initialization
*{if (AllowRotate){RotateView();}// the jump state needs to read here to make sure it is not missedif (!m_Jump){m_Jump = CrossPlatformInputManager.GetButtonDown("Jump");}if (!m_PreviouslyGrounded &amp;&amp; m_CharacterController.isGrounded){StartCoroutine(m_JumpBob.DoBobCycle());PlayLandingSound();m_MoveDir.y = 0f;m_Jumping = false;}if (!m_CharacterController.isGrounded &amp;&amp; !m_Jumping &amp;&amp; m_PreviouslyGrounded){m_MoveDir.y = 0f;}m_PreviouslyGrounded = m_CharacterController.isGrounded;}
Update is called once per frame
*if (!m_Jump)*{
the jump state needs to read here to make sure it is not missed
*Vector3 desiredMove = transform.forward*m_Input.y + transform.right*m_Input.x;*// get a normal for the surface that is being touched to move along it
always move along the camera forward as it is the direction that it being aimed at
*float horizontal = CrossPlatformInputManager.GetAxis("Horizontal");*float vertical = CrossPlatformInputManager.GetAxis("Vertical");
Read input
*m_IsWalking = !Input.GetKey(KeyCode.LeftShift);*#endif
keep track of whether or not the character is walking or running
*if (m_Input.sqrMagnitude >; 1)*{
normalize input if it exceeds 1 in combined length:
*// only if the player is going to a run, is running and the fovkick is to be used*if (m_IsWalking != waswalking &amp;&amp; m_UseFovKick &amp;&amp; m_CharacterController.velocity.sqrMagnitude >; 0)
handle speed change to give an fov kick
*if (m_IsWalking != waswalking &amp;&amp; m_UseFovKick &amp;&amp; m_CharacterController.velocity.sqrMagnitude >; 0)*{
only if the player is going to a run, is running and the fovkick is to be used
*if (m_CollisionFlags == CollisionFlags.Below)*{
dont move the rigidbody if the character is on top of it

*NLog.LogManager.Shutdown();
Flush and close down internal threads and timers

*services.AddDbContext<;BookContext<;(options =<; options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
追加

*var Person = module.GetType("CSharpDll.Person");
利用するクラス(or 構造体)を取得
CSharpDll.Personクラスをインスタンス化.
コンストラクタへ引数を渡すことも可能.
*dynamic p1 = Activator.CreateInstance(Person, "Aiueo", 29);
*Console.WriteLine($"name= {p1.Name}");
dynamicで受けているので, 面倒なプロパティ取得やメソッド取得を省略できる.

*uint pad_trg = inputController.Trigger();
パッドトリガ入力

*yield return this.CreateDescriptor(child);
子要素を列挙

*{private static bool baseStaticFieldInitialized = ConsoleOut("(1) 基底型静的フィールドの初期化");private bool baseInstanceFieldInitialized = ConsoleOut("(4) 基底型インスタンスフィールドの初期化");public Base(){ConsoleOut("(5) 基底型コンストラクタの実行");// ※派生型コンストラクタはまだ実行されていないが、この時点でもインスタンスは派生型Assert.AreEqual(typeof(Derived), this.GetType());// ※オーバーライドされた派生型メソッドが実行される。OverridableMethod();}// 仮想メソッドprotected virtual void OverridableMethod(){// ※インスタンス型でオーバーライドされている場合、コンストラクタからの呼び出しでも実行されない。Assert.Fail();}protected static bool ConsoleOut(string step){Console.WriteLine(step);return true;}}
基底クラス
※派生型コンストラクタはまだ実行されていないが、この時点でもインスタンスは派生型
*Assert.AreEqual(typeof(Derived), this.GetType());
※オーバーライドされた派生型メソッドが実行される。
*OverridableMethod();
*{// ※インスタンス型でオーバーライドされている場合、コンストラクタからの呼び出しでも実行されない。Assert.Fail();}
仮想メソッド
※インスタンス型でオーバーライドされている場合、コンストラクタからの呼び出しでも実行されない。
*Assert.Fail();
*{private static bool derivedStaticFieldInitialized = ConsoleOut("(2) 派生型静的フィールドの初期化");// ※基底型インスタンスフィールド、基底型コンストラクタより先に処理される。private bool derivedInstanceFieldInitialized = ConsoleOut("(3) 派生型インスタンスフィールドの初期化");private bool derivedConstructorCalled = false;public Derived(){ConsoleOut("(7) 派生型コンストラクタの実行");this.derivedConstructorCalled = true;}// オーバーライドメソッドprotected override void OverridableMethod(){ConsoleOut("(6) 派生型オーバーライドメソッドの実行");// ※基底型コンストラクタから呼び出された場合、// 　派生型フィールドは初期化済みだが、派生型コンストラクタが未処理のまま実行されてしまう。Assert.IsTrue(this.derivedInstanceFieldInitialized);Assert.IsFalse(this.derivedConstructorCalled);}}
派生クラス
※基底型インスタンスフィールド、基底型コンストラクタより先に処理される。
*private bool derivedInstanceFieldInitialized = ConsoleOut("(3) 派生型インスタンスフィールドの初期化");
*{ConsoleOut("(6) 派生型オーバーライドメソッドの実行");// ※基底型コンストラクタから呼び出された場合、// 　派生型フィールドは初期化済みだが、派生型コンストラクタが未処理のまま実行されてしまう。Assert.IsTrue(this.derivedInstanceFieldInitialized);Assert.IsFalse(this.derivedConstructorCalled);}
オーバーライドメソッド
※基底型コンストラクタから呼び出された場合、
派生型フィールドは初期化済みだが、派生型コンストラクタが未処理のまま実行されてしまう。
*Assert.IsTrue(this.derivedInstanceFieldInitialized);

MessagePipe を使用するためのサービスを生成する
*ServiceCollection services = CreateMessagePipeServices();
フォームのインスタンスをDIで生成する場合はアプリケーションのフォームを登録する
*services.AddTransient<;Form1>;();
サービスプロバイダーを生成する
*ServiceProvider provider = services.BuildServiceProvider();
Windowsフォームアプリケーションの既定の初期処理
*Application.SetHighDpiMode(HighDpiMode.SystemAware);
これではDIを利用できない
後述するどちらかの方法でフォームのインスタンスを生成してアプリケーションを開始する
Application.Run(new Form1());
サービスプロバイダーからフォームのインスタンスを生成する
コンストラクタの引数に定義された MessagePipe のインスタンスが注入される
*Application.Run(provider.GetRequiredService<;Form1>;());
サービスプロバイダーを内包したコンテキストを渡す
フォーム内で MessagePipe のインスタンスを生成する
*Application.Run(new Form1(new MyContext(provider)));
*{// 全てのメッセージに適用したいフィルタはグローバルフィルタとして定義するとよいoptions.AddGlobalMessageHandlerFilter(typeof(SampleFilter<;>;));}
MessagePipe の標準サービスを登録する
全てのメッセージに適用したいフィルタはグローバルフィルタとして定義するとよい
*options.AddGlobalMessageHandlerFilter(typeof(SampleFilter<;>;));
使用するメッセージを登録する
*services.AddSingleton(typeof(MessagePipe.IPublisher<;,>;), typeof(MessageBroker<;,>;));
キーが "form1" であるメッセージを購読する
*m_Releaser = m_Subscriber?.Subscribe(
メッセージを発行する
前述のサブスクライバには一つめのメッセージのみが送られる
*m_Publisher?.Publish("form1"

*bool f = (3 <;= 7);
fはfalse．

*class ProgramOverride : ProgramBase
中身を何も書かないとエラーを吐く。下に書くオーバーライドを用いて実装する必要があるようだ。

*GC.Collect();
必要なさそうだけど一応GC(ほんとに要らないかも)

*{Console.WriteLine("waiting for client connection...");// クライアント接続待ちserver.WaitForConnection();Console.WriteLine("connected!");// 受信char c;string message = string.Empty;while ((c = (char)server.ReadByte()) != '\f'){message += c;}// typeとdataが設定されたJSON文字列が送信されてくるConsole.WriteLine(message);var writer = new StreamWriter(server);// 返信var data = "pong";// node-ipcが解釈できる形のJSON文字列 + \fを返す。writer.Write("{ \"type\": \"app.message\", \"data\": \"" + data + "\" }" + "\f");writer.Flush();// クライアント側が送信メッセージを読み終わるまで待つserver.WaitForPipeDrain();}
サーバーの作成
クライアント接続待ち
*server.WaitForConnection();
受信
*char c;
typeとdataが設定されたJSON文字列が送信されてくる
*Console.WriteLine(message);
返信
*var data = "pong";
*writer.Write("{ \"type\": \"app.message\", \"data\": \"" + data + "\" }" + "\f");
node-ipcが解釈できる形のJSON文字列 + \fを返す。
クライアント側が送信メッセージを読み終わるまで待つ
*server.WaitForPipeDrain();

*public Text camSwitchButton;
GUIText -&gt; Textに変更

下記でも、うまく動く。(CharSetの代わりにMarshallAsでLPWSTRを指定する)
[DllImport("DllTest.dll", CallingConvention = CallingConvention.Cdecl)]
public extern static void Test_MyApi2([MarshalAs(UnmanagedType.LPWStr)]string lpText, [MarshalAs(UnmanagedType.LPWStr)]string lpCaption);
*[DllImport("DllTest.dll", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode)]

*}
notepad.exe killed

*const int NUM = 8;
定数も再定義はエラー

title = 【BGM素材】褪せし青の故郷【村】
description = ゲームミュージック風ループBGM素材です。ニコニ・コモンズよりダウンロード可能です。[nc168769] 自由にお使いください。使用した画像[nc4917][nc4915] 他動画 → [mylist/24914088 ] Twitter @hiki_neet_p
user nickname = tana＠ヒキニートP
*}

入力判定用にFとJを設定
*keyCodes.Add (KeyCode.F, "F");

*value = atk,
ダメージ量
*[Inject] ISubscriber<;PlayerAttackData>; OnAttacked { get; set; }
Zenjectによって自動的に攻撃イベントが注入される
プレイヤーの攻撃範囲内の場合、ダメージを受ける
*hp -= attack.value;
破棄されるタイミングでOnAttackイベントの購読をやめる
*disposable.Dispose();

query3とquery4は迷走時の黒歴史。文末の追記のほうが良いです。
*var query3 =

*public GameObject enemyTag;
Text3Dのprefabを割り当て
*void Start () {enemyGroup = new EnemyGroup(enemies.Length);Iterator it = enemyGroup.iterator();for(int i = 0; i <; enemies.Length; i++){enemyGroup.AddEnemy(enemies[i]);}while (it.HasNext()){var e = it.Next();GenerateEnemy((Enemy)e);}}
Use this for initialization
*void Update () {}
Update is called once per frame
*void Start () {}
Use this for initialization
*void FixedUpdate () {time += Time.deltaTime;if(time >;= 1){time = 0;foreach (GameObject obj in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))){if(obj.GetComponent<;Bomb>;() != null){obj.GetComponent<;Bomb>;().CountDown();}}}}
Update is called once per frame

*public SteamVR_TrackedObject targetObject;
割り当て固定対象のオブジェクト
*public void AssignTrackedObject(){SteamVR_TrackedObject.EIndex tmp;var buffer = new StringBuilder(256);var error = ETrackedPropertyError.TrackedProp_Success;for(int i = 0; i <; trackedObjects.Length; i++){SteamVR.instance.hmd.GetStringTrackedDeviceProperty((uint)trackedObjects[i].index, ETrackedDeviceProperty.Prop_SerialNumber_String, buffer, (uint)buffer.Capacity, ref error);if(error == ETrackedPropertyError.TrackedProp_Success){Debug.Log(buffer.ToString());if(buffer.ToString() == serialNumberTarget){tmp = trackedObjects[i].index;targetObject.SetDeviceIndex((int)tmp);}}}}
つまりserialNumberTargetとtargetObjectが対応づけされる

例外が出るよ
*var res = new DateTime( DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day + 1, hour, mini, sec );
こっちならOK
*var res = new DateTime( DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, hour, mini, sec).AddDays(1);

*if (GvrPointerInputModule.CurrentRaycastResult.isValid &amp;&amp; gvrControllerInput.GetButtonDown(GvrControllerButton.App))*{
Rayの衝突＆Appボタンを押したら
やりたい処理
*print("Cubeに衝突");

*// async IEnumerable<;int>; DoAsync(){,,,async IAsyncEnumerable<;int>; DoAsync(){await Task.Delay(1000);yield return 1;},,,await foreach(var item in asyncStream) {Console.WriteLine(item);},,,async IAsyncEnumerable<;int>; DoAsync() {foreach(var item in Enumerable.Range(1, 100).Select(x =>; x * 5)) {await Task.Delay(item);yield return item;}},,,async ValueTask DoSomething() {await foreach(var item in DoAsync()) {Console.WriteLine(item);}},,,public static class Ex{// 受けとったTaskの配列をIAsyncEnumerableとしてreturnする拡張メソッドpublic static IAsyncEnumerable<;T>; AsAsyncEnumerable<;T>;(this IEnumerable<;Task<;T>;>; tasks) =>; tasks switch {null =>; throw new ArgumentNullException(nameof(tasks)),IEnumerable<;Task<;T>;>; ts =>; ts.AsAsyncEnumerableImpl(),};static async IAsyncEnumerable<;T>; AsAsyncEnumerableImpl<;T>;(this IEnumerable<;Task<;T>;>; tasks) {foreach(var task in tasks) {yield return await task;}}},,,async ValueTask DoSomething() {var tasks = new List<;Task<;int>;>;();tasks.Add(Task.Delay(1000).ContinueWith(_ =>; 1));tasks.Add(Task.Delay(3000).ContinueWith(_ =>; 2));tasks.Add(Task.Delay(5000).ContinueWith(_ =>; 3));tasks.Add(Task.Delay(2000).ContinueWith(_ =>; 4));tasks.Add(Task.Delay(4000).ContinueWith(_ =>; 5));await foreach(int item inAsyncEnumerableEx.AsAsyncEnumerable(tasks)) {Console.WriteLine(item);}},,,*async IAsyncEnumerable<;int>; DoAsync(){await Task.Delay(1000);yield return 1;},,,await foreach(var item in asyncStream) {Console.WriteLine(item);},,,async IAsyncEnumerable<;int>; DoAsync() {foreach(var item in Enumerable.Range(1, 100).Select(x =>; x * 5)) {await Task.Delay(item);yield return item;}},,,async ValueTask DoSomething() {await foreach(var item in DoAsync()) {Console.WriteLine(item);}},,,public static class Ex{// 受けとったTaskの配列をIAsyncEnumerableとしてreturnする拡張メソッドpublic static IAsyncEnumerable<;T>; AsAsyncEnumerable<;T>;(this IEnumerable<;Task<;T>;>; tasks) =>; tasks switch {null =>; throw new ArgumentNullException(nameof(tasks)),IEnumerable<;Task<;T>;>; ts =>; ts.AsAsyncEnumerableImpl(),};static async IAsyncEnumerable<;T>; AsAsyncEnumerableImpl<;T>;(this IEnumerable<;Task<;T>;>; tasks) {foreach(var task in tasks) {yield return await task;}}},,,async ValueTask DoSomething() {var tasks = new List<;Task<;int>;>;();tasks.Add(Task.Delay(1000).ContinueWith(_ =>; 1));tasks.Add(Task.Delay(3000).ContinueWith(_ =>; 2));tasks.Add(Task.Delay(5000).ContinueWith(_ =>; 3));tasks.Add(Task.Delay(2000).ContinueWith(_ =>; 4));tasks.Add(Task.Delay(4000).ContinueWith(_ =>; 5));await foreach(int item inAsyncEnumerableEx.AsAsyncEnumerable(tasks)) {Console.WriteLine(item);}},,,受けとったTaskの配列をIAsyncEnumerableとしてreturnする拡張メソッド
*public static IAsyncEnumerable<;T>; AsAsyncEnumerable<;T>;(

*IPXPmxBuilder bdx = host.Builder.Pmx;
PMXビルダ
PMX関連
IPXPmx pmx = connect.Pmx.GetCurrentState();      PMX取得
IPXHeader header = pmx.Header;                   header   :ヘッダ
IPXModelInfo info = pmx.ModelInfo;               info     :モデル情報
IList&lt;IPXVertex&gt; vertex = pmx.Vertex;            vertex   :頂点   | リスト
IList&lt;IPXMaterial&gt; material = pmx.Material;      material :材質   | リスト
IList&lt;IPXBone&gt; bone = pmx.Bone;                  bone     :ボーン | リスト
IList&lt;IPXMorph&gt; morph = pmx.Morph;               morph    :モーフ | リスト
IList&lt;IPXNode&gt; node = pmx.Node;                  node     :表示枠 | リスト
IList&lt;IPXBody&gt; body = pmx.Body;                  body     :剛体   | リスト
IList&lt;IPXJoint&gt; joint = pmx.Joint;               joint    :Joint  | リスト
IList&lt;IPXSoftBody&gt; sbody = pmx.SoftBody;         sbody    :SoftBody  | リスト
*,,,

*Console.WriteLine(konan.Age);
-&gt;7のまま
本名を変えることはできません
konan.Realname = "江戸川コナン";  そのプロパティはRead-Only専用と怒られる
じゃあコナン君、本名は？
Console.WriteLine(konan.Realname);  -&gt;工藤新一。あっ……やっぱり。
*}
なんか処理
*return 処理した結果;
valueを使ってなんか処理
*this.フィールド = 処理した結果;
Console.WriteLine(konan.Secret); ←Write-Onlyと怒られる
*,,,

実行中のタスクをキャンセルするためのキャンセルトークン
*private CancellationTokenSource? m_CurrentCancellation;
実行中のタスクをキャンセルするためのキャンセルトークン
*private readonly ConcurrentDictionary<;Guid, CancellationTokenSource>; m_CurrentCancellations
実行中のタスクを表すID
*private Guid? m_CurrentTaskId;

コルーチンの実行
*StartCoroutine(Fuga());
コルーチンが終了する前にゲームオブジェクトを削除
*Destroy(gameObject);
ここで列挙が終了する。
3回目のMoveNextを呼べばDisposeされるがGameObjectが削除されているので呼ばれない。
enumerator.MoveNext()
もしくはenumeratorがDisposeされるならばDisposeが呼ばれる。
if (enumerator is IDisposable d) d.Dispose();
*,,,

*static int solve(int a, int b, int c) {
a &lt; b &lt; c

編集履歴を記録する対象に当ViewModelを指定します。
*this.UndoManager = new UndoManager();
UndoManagerに変更値を登録
*UndoManager.FromReference(this).AddPropertyChange(this, propertyName, storage, value);
UndoRedoの履歴を表示
*this.ShowHistory();
UndoManagerに変更値を登録
*UndoManager.FromReference(this).AddPropertyChange(this, propertyName, storage, value);
UndoRedoの履歴を表示
*this.ShowHistory();

リソース名の設定
*DefaultModelBinder.ResourceClassKey = nameof(Messages);
アダプターの設定
第1引数は独自Validationサブクラス、第2引数はRegularExpressionAttributeAdapter を指定
*DataAnnotationsModelValidatorProvider.RegisterAdapter(

*return Marshal.StringToHGlobalAuto("hoge fuga piyo");
string型をIntPtrに変換してreturn

*public string KeywordA { get; set; } = "";
初期表示の場合は""、検索条件なしで検索した場合はnull
*if (model.KeywordA == "" &amp;&amp; model.KeywordB == "")*{
初期表示の場合はエラーメッセージをクリア

検索後の入力値はModelState(入力パラメータ）が優先されるため、検索結果が入らない
ModelStateの値を削除することで検索結果が表示されるようにする
*ModelState.Remove(nameof(SearchViewModel.KeywordA));

保存対象のコントロールグループ
*private PersistenceGroup taregetGroup = new PersistenceGroup();
保存内容のMemoryStream
*private MemoryStream saveMemoryStrem;
保存対象のプロパティやコントロールの設定などを行う。
*SettingSaveTargetControls();
保存対象のコントロールに対し、保存するプロパティを設定する。
*this.SetSettingsControl(this.comboBox);
保存対象のコントロールを１つのグループとして登録。
*PersistenceManager.SetPersistenceGroup(this.comboBox, taregetGroup);
*if (target is ComboBox)*{
コントロールにより保存対象のプロパティを決定する。
保存対象のコントロールを１つのグループとして登録。
*PersistenceManager.SetPersistenceGroup(this.comboBox, taregetGroup);
保存処理
*saveMemoryStrem = PersistenceManager.Save(taregetGroup);
読込処理
*PersistenceManager.Load(taregetGroup, saveMemoryStrem);

Jsonをシリアライズ化してサンプルデータを設定
*this.xamDataGrid.DataSource = LoadJsonFile();
Jsonファイルを読み込み、デシリアライズ化し、SampleDataに設定します。
*string fileContent = System.IO.File.ReadAllText(JSON_FILE_PATH);
行を追加する
*List<;SampleData>; records = this.xamDataGrid.DataSource as List<;SampleData>;;
選択行を削除する。
*List<;SampleData>; records = this.xamDataGrid.DataSource as List<;SampleData>;;
編集内容を反映
*targetData.Age = editData.Age;
XamDataGridに反映
*this.xamDataGrid.DataSource = null;
データソース反映時に選択行が解除されるため、再設定
*this.xamDataGrid.SelectedDataItem = targetData;
選択行のオブジェクトをXamPropertyGridに表示
*xamPropGrid.SelectedObject = this.xamDataGrid.ActiveDataItem;

*return false;
生成忌避

他のシーンを呼び出す
Application.LoadLevel("Main");  非推奨
SceneManager.LoadScene("Main");  OK
遷移前のシーンを残して、他のシーンを呼び出す
Application.LoadLevelAdditive("Main");  非推奨
SceneManager.LoadScene("Main", LoadSceneMode.Additive);  OK
現在読み込んでいるシーンを再読込
Application.LoadLevel(Application.loadedLevel);  非推奨
SceneManager.LoadScene(SceneManager.GetActiveScene().name);  OK
*,,,

外部APIの呼び出し
*var apiResponse = (await XXXAsync(XXX, YYY));

*var responce = ...;
色々あった。
*public MessageController(IRequestHandler<;MessageRequest,MessageResponse>; handler) {this.handler = handler;}
型情報から先程のMessageHandlerのインスタンスを受け取ることが出来る。
詳細略
*}
略
*}

*d.Url = "http:
example.selenium.jpreserveApp";
予約入力画面
*ReserveFormPage.SetForm(d);
予約確認画面
*ReserveConfirmPage.ClickConfirmBtn(d);
予約完了画面
*Assert.AreEqual(ReserveCompletePage.GetMessage(d), "予約を完了しました。");
予約入力画面
*ReserveFormPage.SetForm(d);
エラー画面
*Assert.AreEqual(ErrorPage.GetPageTitle(d), "予約エラー");
予約画面操作
*ReserveFormPage.SetForm(d);
予約確認画面操作
*ReserveConfirmPage.ClickBackBtn(d);
予約画面操作
*ReserveFormPage.SetForm(d);
予約確認画面操作
*ReserveConfirmPage.ClickConfirmBtn(d);
予約完了画面操作
*Assert.AreEqual(ReserveCompletePage.GetMessage(d), "予約を完了しました。");

*//descriptor.Claims = new Dictionary<;string, object>; {//    { "userpayload", JsonConvert.SerializeObject(payload) }//    { "jti", claim.ID }//};
定義済でない項目をクレームに含めるには、Claims ではなく Subject に格納します。
*//    { "userpayload", JsonConvert.SerializeObject(payload) }
descriptor.Claims = new Dictionary&lt;string, object&gt; {
*//    { "jti", claim.ID }
{ "userpayload", JsonConvert.SerializeObject(payload) }
*descriptor.Subject = new ClaimsIdentity(new Claim[] {new Claim("userpayload", JsonConvert.SerializeObject(payload)),new Claim("jti", claim.ID)});
{ "jti", claim.ID }
*descriptor.Subject = new ClaimsIdentity(new Claim[] {new Claim("userpayload", JsonConvert.SerializeObject(payload)),new Claim("jti", claim.ID)});
};
*if (ValidIssuers != null &amp;&amp; ValidIssuers.Length >; 0)*{
発行者を検証するかどうか
*if (ValidAudiences != null &amp;&amp; ValidAudiences.Length >; 0)*{
利用者を検証するかどうか
*parameters.ValidateLifetime = true;*parameters.LifetimeValidator = m_LifetimeValidator;
有効期限を検証するかどうか
*{ID = GetClaim(claims, "jti),Audience = GetClaim(claims, "aud")};
クレーム情報
ペイロード
*string payloadJson = claims.FindFirst("userpayload")?.Value;
有効期限が不正
*claim = null;
NotBefore でも Expires でもない
*tokenState = TokenState.Invalid;
発行者が不正
*claim = null;
利用者が不正
*claim = null;

*while (true)*{
var container = …

*double rt = 1.5;
96dpi_rt=1, 144dpi_rt=1.5
*catch(Exception ex){MessageBox.Show("読み取りエラー\n\n"+ex);}
Clipboard.SetDataObject(Result,true,20,500);

*Console.log(-(1.5.Ceiling()));
&lt;- このように解釈される

*{if(Input.anyKey == false) isCheck_Input = false;if (isCheck_Input==false){if (Input.GetKey(key)){isCheck_Input = true;return true;}}return false;}
真の同時押し不可

*driver.FindElement(By.XPath("
input[@value='ログイン'] | button[text()='ログイン']")).Click();

*if (other.gameObject.tag != "Area")*{
衝突してほしいゲームオブジェクトでなければ抜ける
*if (other.gameObject.tag != "Area")*{
衝突してほしいゲームオブジェクトでなければ抜ける

*"https:
+:44300sample");

*using System.Drawing.Imaging;
追加
*if(args.Length == 1)*{
Application.Run(new Form1());
画像ファイルのみ取り込み
*var bmp = clip.GetData(typeof(Bitmap)) as Bitmap;

背景が透明なTexture2Dを作る
http:d.hatena.ne.jp/shinriyo/20140520/p2
*Color32[] texColors = Enumerable.Repeat<;Color32>;(bgColor, width * height).ToArray();
*Color[] wcolor = { color };
color of pixels
*while (x >; 0 &amp;&amp; x <; texture.width &amp;&amp; y >; 0 &amp;&amp; y <; texture.height)*{
draw line loop

*private string name2;
name for 2

Jsonをシリアライズ化してサンプルデータを設定
*this.xamDataGrid.DataSource = LoadJsonFile();
Jsonファイルを読み込み、デシリアライズ化し、SampleDataに設定します。
*string fileContent = System.IO.File.ReadAllText(JSON_FILE_PATH);
行を追加する
*List<;SampleData>; records = this.xamDataGrid.DataSource as List<;SampleData>;;
選択行を削除する。
*List<;SampleData>; records = this.xamDataGrid.DataSource as List<;SampleData>;;
編集内容を反映
*targetData.Age = editData.Age;
XamDataGridに反映
*this.xamDataGrid.DataSource = null;
データソース反映時に選択行が解除されるため、再設定
*this.xamDataGrid.SelectedDataItem = targetData;
選択行のオブジェクトをXamPropertyGridに表示
*xamPropGrid.SelectedObject = this.xamDataGrid.ActiveDataItem;

*driver.FindElement(By.XPath("
input[@value='登録'] | button[text()='登録']")).Click();

LeapMotionのコントローラー
*controller = new Controller();
LeapMotionから手の情報を取得
*var handsStream = this.UpdateAsObservable()
グー終了判定ストリーム
*var endRockGripStream = handsStream
カメラ制御
*handsStream
グーなら
*.Where(hands =>; IsRockGrip(hands))
手のひらの位置を取得
*.Select(hands =>; ToVector3(hands[0].PalmPosition))
バッファに前回と今回の２つの値を詰める
*.Buffer(2, 1)
今回と前回の差から手のひらの移動ベクトルを計算
*.Select(positions =>; positions[1] - positions[0])
値をログに出力
*.Do(movement =>; Debug.Log("移動: " + movement))
グーが終了したらバッファをクリアにする
*.TakeUntil(endRockGripStream).RepeatUntilDestroy(this)
*.Subscribe(movement =>; transform.Translate(-speed * movement));*}
カメラを移動
片手なら
*hands.Count == 1 &amp;&amp;
全ての指の内、開いている数が0個なら
*hands[0].Fingers.ToArray().Count(x =>; x.IsExtended) == 0;

*my.ToString();
nullの場合もここを通る
*if (point is Point(1, 2) p) {*}
単純な位置パターン
*if (point is Point(x: 1, y: 2) p) {*}
名前を書いても良い、この名前はDeconstruct関数の引数名に一致させる
*if (point is Point { AbsSquare: 10 } p) {*}
単純なプロパティパターン
*if (point is (1, 2)) {}
型名は、自明な場合に省略できる
*if (point is (1, 2)) {*}
変数は、使用しない場合省略できる
*if (point is (1, 3) { AbsSquare: 10 }) {*}
位置パターンとプロパティパターンは共存できる。
*if (point is (long x, 3) p) {*}
xの変数宣言も兼ねるのでlongは必要。
*if (point is (_, 3) p) {*}
破棄(_)では型名のlongは不要
*if (point is (long x, long y)) {*}
変数宣言も兼ねるので型名は必要。（この条件は常にtrueになる)
*if (point is (_, 3) { AbsSquare: long abs }) {*}
もちろん、プロパティパターンでも変数宣言可能
*if (line is ((1, 2), (3, 4))) {*}
全部定数にマッチさせる
*if (line is (Point(1, _) p1, Point(long x2, 4) p2)) {*}
一部だけマッチさせて、その場で宣言した変数に代入する
*if (line is ((1, _) { AbsSquare: 101 } p1, (long x2, 4) { AbsSquare: 80 } p2) { NormSquare: 85 } l) {*}
これもパターンマッチングの構文として正しい
*switch (x, str) {case (0, string s):break;case (int n, string s) when s.Length >; 0:break;default:break;}
switch文の対象に複数の値を書くことができるようになった。
*switch (x, str) {case (0, string s):break;case (int n, string s) when s.Length >; 0:break;default:break;}
実際には単なる一時的なタプルの構築が行われる。
*var result = (b1, b2) switch {(true, true) =>; 1,(true, false) =>; 2,(false, _) =>; 3,};
うまく使えば、エルビス演算子`A?B:C`の組み合わせよりわかりやすいかも

*class Student {[DataMember(Name = "id", Order = 1)]public int Id { set; get; }[DataMember(Name = "name", Order = 2)]public string Name { set; get; }[DataMember(Name = "v1")]public int V1 { set; get; }[DataMember(Name = "v2")]public int V2 { set; get; }}
CSV文字列化したいクラス
*static class StudentExtension {public static string ToCsvString(this Student student) {var list = student.GetType().GetProperties().OrderBy(_ =>; GetOrder(_)).ThenBy(_ =>; _.Name).Select(_ =>; _.GetValue(student));return string.Join(", ", list);}private static int GetOrder(PropertyInfo info) {if (Attribute.GetCustomAttribute(info, typeof(DataMemberAttribute))is DataMemberAttribute attr){return attr.Order;}return -1;}}
CSV文字列化を拡張メソッドで実装してみた
*class Program {static void Main(string[] args) {var student = new Student() { Id = 1, Name = "山田", V1 = 1, V2 = 2 };Console.WriteLine(student.ToCsvString());}}
StudentクラスのCSV文字列化

*{IPHostEntry host = Dns.GetHostEntry(hostname);Console.WriteLine($"GetHostEntry({hostname}) returns:");foreach (IPAddress address in host.AddressList){Console.WriteLine($"    {address}");}}
ホストネームからアドレスを取得する

*{if (<;>;1__state == -2 &amp;&amp; <;>;l__initialThreadId == nvironment.CurrentManagedThreadId){<;>;1__state = 0;return this;}return new <;YieldSample>;d__1(0);}
途中略

*string name;
パケットから取得したファイル名

*var ret = MasterContext.Where( g =<; g.email == "xxxxx@xxxxxxxx.xxx" ).Any();
No coercion operator is defined between types 'System.Int16' and 'System.Boolean'.
*var ret = ( MasterContext.Where( g =>; g.Email == "xxxxx@xxxxxxxx.xxx" ).Select( g =>; new { g.Email } ).FirstOrDefault()) != null;
Any()メソッドはbool以外が返ってきて例外がでるので、別回避する必要あり

ガンマ補正
*var color = tex.GetPixels();

*Color diffColor = Color.Red;
画像の差分に付ける色。
*for (int i = 0; i <; width; i++)*{
全ピクセルを総当りで比較し、違う部分があればfalseを返す。
*diffBmp.SetPixel(i, j, diffColor);*isSame = false;
画像のサイズが違う時は、ピクセルを取得できずにエラーとなるが、ここでは「差分」として扱う。

*private const float WINDOWSIZE_H = 200.0f;
ウィンドウサイズ縦幅
ウィンドウサイズ設定(minとmaxを=しているのはウィンドウサイズを固定するため)
*window.maxSize = window.minSize = new Vector2(WINDOWSIZE_W,WINDOWSIZE_H);

行毎の合計を撮る
var sums = array.Rows.Select(r =&gt; r.Sum()).ToArray();  =&gt; [ 6, 15, 24 ]
*,,,

*0x03,
[2] 00000011
*for(int j = 0; j <; 3; j++) {*int k = i + j;
copy or default.
*if(isUrlSafe) {*foreach(byte b in tgt) {
to character.

リダイレクト先を知りたいURL
string url = "https:goo.gl/xBVejN";
リダイレクト先の取得が終わるまで待つ
*Task<;string>; task = GetLastUrl(url);
リダイレクト先を表示
*Debug.WriteLine("リダイレクト先 : " + task.Result);
*{HttpClient client = new HttpClient();HttpResponseMessage response = await client.GetAsync(url);response.EnsureSuccessStatusCode();return response.RequestMessage.RequestUri.ToString();}
リダイレクト先の取得

ClientStreaming, ServerStreaming, DuplexStreaming も実装の流れは同じですので割愛します。
*#endregion
ClientStreaming, ServerStreaming, DuplexStreaming も実装の流れは同じですので割愛します。
*#endregion

*uint dof = 2;
Vector2
*{//var solver = new IvyFEM.Linear.LisEquationSolver();//solver.Method = IvyFEM.Linear.LisEquationSolverMethod.Default;//FEM.Solver = solver;}
FEM.Solver = solver;
*{var solver = new IvyFEM.Linear.IvyFEMEquationSolver();solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.NoPreconCG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.CG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.ICCG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.NoPreconBiCGSTAB;FEM.Solver = solver;}
FEM.Solver = solver;

*http:
opensource.orglicensesmit-license.php
ランダム文字列生成
*string randomLine = Guid.NewGuid().ToString("N").Substring(0, 10);

*window.location.href = "https:
s3.amazonaws.comstatic-files.lookingglassfactory.comWebCalibrationBridgeLKG_ThreeJsDriver_Mac.pkg"

*// input for prediction operations*// - First 4 properties are inputs/features used to predict the label
IrisData is used to provide training data, and as
*{[LoadColumn(0)]public float SepalLength;[LoadColumn(1)]public float SepalWidth;[LoadColumn(2)]public float PetalLength;[LoadColumn(3)]public float PetalWidth;[LoadColumn(4)]public string Label;}
- Label is what you are predicting, and is only set when training
*{[ColumnName("PredictedLabel")]public string PredictedLabels;}
IrisPrediction is the result returned from prediction operations
*var pipeline = mlContext.Transforms.Conversion.MapValueToKey("Label")*.Append(mlContext.Transforms.Concatenate("Features", "SepalLength", "SepalWidth", "PetalLength", "PetalWidth"))
Convert the Label back into original text (after converting to number in step 3)
*// You can change these numbers to test different predictions*var prediction = model.CreatePredictionEngine;IrisData, IrisPrediction>;(mlContext).Predict(
STEP 5: Use your model to make a prediction

*void Start () {targetRenderer = GetComponent<;MeshRenderer>;();}
Use this for initialization
*void Update () {}
Update is called once per frame

*private enum FOS
not fully defined

*NullValueHandling = NullValueHandling.Ignore
nullは出力しない

*options.AccessDeniedPath = "
IdentityAccessDenied"; AccessDenied は未実装

*db.Blogs.Add(new Blog { Url = "http:
blogs.msdn.comadonet" + i.ToString() });
念願のinformation_schema.TABLESテーブル取得＆表示
*Console.WriteLine("使用テーブル名やレコード数取得とか");
*//    name: "information_schema");*migrationBuilder.CreateTable(
migrationBuilder.EnsureSchema(
*//    schema: "information_schema",*//    columns: table =>; new
name: "TABLES",
*//    {//        TABLE_CATALOG = table.Column<;string>;(nullable: false),//        TABLE_SCHEMA = table.Column<;string>;(nullable: false),//        TABLE_NAME = table.Column<;string>;(nullable: false),//        TABLE_TYPE = table.Column<;string>;(nullable: false),//        ENGINE = table.Column<;string>;(nullable: true),//        VERSION = table.Column<;ulong>;(nullable: true),//        ROW_FORMAT = table.Column<;string>;(nullable: true),//        TABLE_ROWS = table.Column<;ulong>;(nullable: true),//        AVG_ROW_LENGTH = table.Column<;ulong>;(nullable: true),//        DATA_LENGTH = table.Column<;ulong>;(nullable: true),//        MAX_DATA_LENGTH = table.Column<;ulong>;(nullable: true),//        INDEX_LENGTH = table.Column<;ulong>;(nullable: true),//        DATA_FREE = table.Column<;ulong>;(nullable: true),//        AUTO_INCREMENT = table.Column<;ulong>;(nullable: true),//        CREATE_TIME = table.Column<;DateTime>;(nullable: true),//        UPDATE_TIME = table.Column<;DateTime>;(nullable: true),//        CHECK_TIME = table.Column<;DateTime>;(nullable: true),//        TABLE_COLLATION = table.Column<;string>;(nullable: true),//        CHECKSUM = table.Column<;ulong>;(nullable: true),//        CREATE_OPTIONS = table.Column<;string>;(nullable: true),//        TABLE_COMMENT = table.Column<;string>;(nullable: true)//    },
schema: "information_schema",
*//    {//        TABLE_CATALOG = table.Column<;string>;(nullable: false),//        TABLE_SCHEMA = table.Column<;string>;(nullable: false),//        TABLE_NAME = table.Column<;string>;(nullable: false),//        TABLE_TYPE = table.Column<;string>;(nullable: false),//        ENGINE = table.Column<;string>;(nullable: true),//        VERSION = table.Column<;ulong>;(nullable: true),//        ROW_FORMAT = table.Column<;string>;(nullable: true),//        TABLE_ROWS = table.Column<;ulong>;(nullable: true),//        AVG_ROW_LENGTH = table.Column<;ulong>;(nullable: true),//        DATA_LENGTH = table.Column<;ulong>;(nullable: true),//        MAX_DATA_LENGTH = table.Column<;ulong>;(nullable: true),//        INDEX_LENGTH = table.Column<;ulong>;(nullable: true),//        DATA_FREE = table.Column<;ulong>;(nullable: true),//        AUTO_INCREMENT = table.Column<;ulong>;(nullable: true),//        CREATE_TIME = table.Column<;DateTime>;(nullable: true),//        UPDATE_TIME = table.Column<;DateTime>;(nullable: true),//        CHECK_TIME = table.Column<;DateTime>;(nullable: true),//        TABLE_COLLATION = table.Column<;string>;(nullable: true),//        CHECKSUM = table.Column<;ulong>;(nullable: true),//        CREATE_OPTIONS = table.Column<;string>;(nullable: true),//        TABLE_COMMENT = table.Column<;string>;(nullable: true)//    },
columns: table =&gt; new
*//    {//        table.PrimaryKey("PK_TABLES", x =>; new { x.TABLE_CATALOG, x.TABLE_SCHEMA, x.TABLE_NAME, x.TABLE_TYPE });//    });
},
*//    {//        table.PrimaryKey("PK_TABLES", x =>; new { x.TABLE_CATALOG, x.TABLE_SCHEMA, x.TABLE_NAME, x.TABLE_TYPE });//    });
constraints: table =&gt;
*//        table.PrimaryKey("PK_TABLES", x =>; new { x.TABLE_CATALOG, x.TABLE_SCHEMA, x.TABLE_NAME, x.TABLE_TYPE });
{
*//    schema: "information_schema");*migrationBuilder.DropTable(
name: "TABLES",

*if (num <; 0)*{
イマイチ
こうとか
*num = num * -1;
こうとか
*num = -num;
↑なんか微妙
*}
Math.Absですっきり
*num = Math.Abs(num);

*"ST: service:WANIPConnection:1\r\n"
ST:例

ValueTupleとしでなく、分解して受ける
*var (minValue, maxValue) = FindMinAndMax(source);
中略
*}
中略
ここでsource中の最小値・最大値を探す。空なら例外を投げる
*return (min, max);
略
*}

マネージャーにPC購入の承認を判定してもらう
*manager.JudgeApproveItem(item1);
マネージャーにHigh Spec PC購入の承認を判定してもらう
*manager.JudgeApproveItem(item2);
マネージャーにSuper High Spec PC購入の承認を判定してもらう
*manager.JudgeApproveItem(item3);
マネージャーにUltra High Spec PC購入の承認を判定してもらう
*manager.JudgeApproveItem(item4);

ファイル読みこみ
*MemoryStream data = new MemoryStream(File.ReadAllBytes(tb_FileName2.Text));
*metadata.SetQuery("/app1/ifd/gps/subifd:{ushort=1}", GPSLatitudeRef);
metaデータを準備
*{var enc = new JpegBitmapEncoder();var frame = BitmapFrame.Create(image, null, metadata, null);enc.Frames.Add(frame);enc.Save(stream);}
ファイルに書き込み

ファイル/Metadata読み込み
*Uri uri = new Uri(tb_FileName.Text, UriKind.Absolute);
GetQueryしてエラーになる場合、
クエリの中の型(「ushort」の部分)が間違っているかもしれない。
その時は、「読み込み位置の指定(クエリ)の実験」で行ったMetadataの列挙のところで
出力される型を確認する。(画像ファイルによって、型が異なる？)
varの型が実際何かは、デバッグ実行して、この下でとめて、ウォッチの「種類」欄で帰ってきた値の型を見る。
var GPSLatitudeRef = metadata.GetQuery("/app1/ifd/gps/subifd:{ushort=1}");   北緯or南緯
var GPSLatitude = metadata.GetQuery("/app1/ifd/gps/subifd:{ushort=2}");      緯度
var GPSLongitudeRef = metadata.GetQuery("/app1/ifd/gps/{ushort=3}");         東経or西経
var GPSLongitude = metadata.GetQuery("/app1/ifd/gps/{ushort=4}");            経度
var Maker = metadata.GetQuery("/app1/ifd/{ushort=271}");                     メーカー名
var Model = metadata.GetQuery("/app1/ifd/{ushort=272}");                     モデル名
var MakerExif = metadata.GetQuery("/app1/ifd/exif/{ushort=34864}");          Exifバージョン
*,,,
ファイル/Metadata読み込み
*Uri uri = new Uri(tb_FileName.Text, UriKind.Absolute);
*BitmapMetadata metadata4 = (BitmapMetadata)metadata.GetQuery("/app1/{ushort=0}");
以下は、上の処理と同じ
*BitmapMetadata metadata6 = (BitmapMetadata)metadata.GetQuery("/app1/ifd/{ushort=34665}");*Debug.WriteLine("Metadataを列挙 /app1/ifd/{ushort=34665}");
以下は、上の処理と同じ
*BitmapMetadata metadataGPS = (BitmapMetadata)metadata.GetQuery("/app1/ifd/{ushort=34853}");*Debug.WriteLine("Metadataを列挙 /app1/ifd/{ushort=34853}");
以下は、上の処理と同じ

*public T[] GetFromStr(string str, string tagName)
tagName : データーとして扱うタグ名 (例:&lt;a&gt;data&lt;a&gt; -&gt; a)
keySet&lt;string(タグの名前),string(タグで囲まれた文字列)&gt;
*/* ここに文字列から<;tagName>;<;/tagNeme>;で囲まれた文字列をDictionaryに入れていく処理を書く */

*if (ThisProjectSingleton.Instance.isGameStart)*{
コルーチン開始(一回で抜ける)
*while (tmpNum == memoryNum)*{
もしランダムな数字( tmpNum)が前回(memoryNum)と一致したら通過。別の数字をtmpNumに代入して抜ける
ホールにボールが入るまで待つ
*yield return new WaitUntil(() =>; ThisProjectSingleton.Instance.isHoleEnter);
ホールが消える
*yield return new WaitForSeconds(0.5f);

*{double radian = GetRadianByDegree(degree);M2DVector destVector = new M2DVector();destVector.U = (srcVector.U) * Math.Cos(radian) - (srcVector.V) * Math.Sin(radian);destVector.V = (srcVector.U) * Math.Sin(radian) + (srcVector.V) * Math.Cos(radian);return destVector;}
位置ベクトルの回転
SetMotorSpeedメソッドのデリゲート変数
*SetMotorSpeed _func_SetMotorSpeed;
回転方向 1:正転 -1:逆転
*int _direction = 1;
回転速度
*int _speed = 0;

*return $"<;speak version='1.0' xmlns='https:
www.w3.org200110synthesis' xml:lang='{speechRecognitionLanguage}'&gt;&lt;voice name='{speechName}'&gt;{text}&lt;voice&gt;&lt;speak&gt;";

*for (int row = 0; row <; size; row++)*{
全ピクセルに色付け

*rate = Mathf.Pow(rate, m_ReactionDistance);
指数関数を加えることにより、収束する勢いを変更できるようにしてる

コード
*Show(Enumerable.Range(5, 3));
出力
*5 6 7

*{var list = new List<;Func<;int, int ,int>;>;();list.Add(GetAnsPlus);list.Add(GetAnsMinus);list.Add(GetAnsMultiple);list.Add(GetAnsDivide);//list.Add((int x, int y) =>; x + y);//list.Add((int x, int y) =>; x - y);//list.Add((int x, int y) =>; x * y);//list.Add((int x, int y) =>; x / y);list.Add((x, y) =>; x + y);list.Add((x, y) =>; x - y);list.Add((x, y) =>; x * y);list.Add((x, y) =>; x / y);return list;}
関数定義
*{foreach (var f in list){Console.WriteLine(f(x, y));}}
出力

*public class ListBox  { }
System.Windows.Forms.Form.ListBox  の代役 }
*{public bool isChanged = false;public List<;string>; list = new List<;string>;();public abstract void SetChangedData(string arg);public int GetHistCnt() { return list.Count; }}
履歴を保持して最新を返すという抽象クラス
*{public override void SetChangedData(string arg){isChanged = true;list.Add(arg);}public string GetValue(){string ret = "HistoryA:";if (isChanged){ret = list[list.Count - 1];}return ret;}}
「何かA」の変更履歴を管理するクラス (※このサンプルではA/B同型だけどホントは異なるつもりで。)
*{public override void SetChangedData(string arg){isChanged = true;list.Add(arg);}public string GetValue(){string ret = "HistoryB:";if (isChanged){ret = list[list.Count - 1];}return ret;}}
「何かB」の変更履歴を管理するクラス (※このサンプルではA/B同型だけどホントは異なるつもりで。)
*{public string GetValue(){string ret = "TextBoxEx:";//ret = TextBoxから値を取得return ret;}}
TextBoxから値を取得するクラス
ret = TextBoxから値を取得
*return ret;
*{public string GetValue(){string ret = "ComboBoxEx:";//ret = ComboBoxから値を取得return ret;}}
ComboBoxから値を取得するクラス
ret = ComboBoxから値を取得
*return ret;
*{public string GetValue(){string ret = "ListBoxEx:";//ret = ListBoxから値を取得return ret;}}
ListBoxから値を取得するクラス
ret = ListBoxから値を取得
*return ret;

*if (args.Length != 3) { return; }*int x, y, z;
x = 37, y = 95, z = 323  -&gt; 227
*if (y == 0) { break; }*//ループを実況。。。
無駄なループをなくすためにExit
ループを実況。。。
*Console.WriteLine("itr = [" + itr.ToString() + "], y = [" + y.ToString() + "]");

*temp = await resGetAsync();
サーバからのメッセージを受け取る

ServerCallContext にトレーラーを格納し、
*context.ResponseTrailers.Add("result", "1");
ServerCallContext からトレーラーを取得して例外に格納する。
*throw new RpcException(
Metadata にトレーラーを格納し、
*Metadata trailers = new Metadata();
Metadata を例外に格納する。
*throw new RpcException(
このメソッド呼び出しが終わらない。
*Response response = await rpcClient.GetData(new Request());
切断されたりするまで例外はキャッチされない。
*Debug.WriteLine(ex.ToString());

*.Select(count =<; (count &amp; 1) == 0);
trueから開始

監視するディレクトリ
*private const string TargetDirectory = "Assets/ServerDefinition";
*var files = new[] { importedAssets, deletedAssets, movedAssets, movedFromAssetPaths }.SelectMany(_ =>; _);
TargetDirectory のファイルが更新されたか確認
*{FileName = "/path/to/mpc",Arguments = "-i Assets -o Assets/GeneratedScripts/GeneratedResolver.cs",UseShellExecute = false,RedirectStandardOutput = true,RedirectStandardError = true,});
外部プロセス起動
標準出力
*UnityEngine.Debug.Log(process.StandardOutput.ReadToEnd());
標準エラー出力
*var error = process.StandardError.ReadToEnd();
監視するディレクトリ
*private const string TargetDirectory = "Assets/ServerDefinition";
自動ビルド設定のMenuPath
*private const string AutoBuildMenuPath = "Tools/MessagePack/Auto Build";
*if (!Menu.GetChecked(AutoBuildMenuPath)) return;*// TargetDirectory のファイルが更新されたか確認
自動ビルドがOFFなら終了
*var files = new[] { importedAssets, deletedAssets, movedAssets, movedFromAssetPaths }.SelectMany(_ =>; _);
TargetDirectory のファイルが更新されたか確認
dotnet コマンドのパスを通す
*Environment.SetEnvironmentVariable("PATH", "/usr/local/share/dotnet");

ここに各イベントごとの呼び出し処理を書く
*}

*[Inject]
👇 "?" はこのプロパティ値が null になり得ることを示します.
*if (this.JS != null)*{
👇 null チェックが必要
👇 "!" 記号で、null 状態確認を無視させる。
*await this.JS!.InvokeVoidAsync("foo");
*public IJSRuntime JS { get; set; }
👇 [AllowNull] 属性を追加
👇 null を設定してもコンパイラから何も言われない 😥
*this.JS = null;
👇 "warning disable" プラグマで当該プロパティを囲う
*#pragma warning disable CS8618
*public partial class MyComponent {...// コードビハインドの C# ファイル中辛はそれを使うだけ。await this.JS.InvokeVoidAsync("foo");,,,コードビハインドの C# ファイル中辛はそれを使うだけ。
*await this.JS.InvokeVoidAsync("foo");

*, EventLogEntryType.Information);
, 4);

実行結果
これは間違いなので確認してください(列番号 : 1)
*,,,
*System.Console.WriteLine($"{alert}{number})");
こんな方法もあります1(by @albireo さん)
こんな方法もあります2(by @shoe0227 さん)
*ちょっと変数を変えて
実行結果
これは間違いなので確認してください(列番号 : 1)
*,,,

*string[] berries = new string[]{"blackberry", "blueberry", "strawberry", "cranberry", "raspberry", "blueberry"};
リスト
*string[] berries = new string[]{"blackberry", "blueberry", "strawberry", "cranberry", "raspberry", "blueberry"};
リスト

*public class CustomTrimmingViewModel : INotifyPropertyChanged*{
バインド用のViewModel
*{if (values[0] is string == false) throw new ArgumentException("第1引数がstring型ではありません。");if (values[1] is double == false) throw new ArgumentException("第2引数がdouble型ではありません。");if (values[2] is TextBlock == false) throw new ArgumentException("第3引数がTextBlock型ではありません。");var str = values[0] as string;var actualWidth = (double)values[1];var textBlock = values[2] as TextBlock;double displayWidth = actualWidth - 10;double currentWidth = GetDrawingWidth(str, textBlock);// 省略時に末尾に設定する文字列string ellipsis = "(略";// Xaml側でConverterParameterに"(略"を設定している場合は以下でも処理できました// string ellipsis = (string)parameter;if (string.IsNullOrWhiteSpace(str) || displayWidth <;= 0){return str + ellipsis;}if (currentWidth <; displayWidth){return str;}else{string trimmedText = str;while (currentWidth >; displayWidth){trimmedText = trimmedText.Substring(0, trimmedText.Length - 1);currentWidth = this.GetDrawingWidth(trimmedText + ellipsis, textBlock);if (string.IsNullOrWhiteSpace(trimmedText)){break;}}return trimmedText + ellipsis;}}
ViewModel -&gt; Viewの通知が動作した時処理されるConverter
省略時に末尾に設定する文字列
*string ellipsis = "(略";
Xaml側でConverterParameterに"(略"を設定している場合は以下でも処理できました
string ellipsis = (string)parameter;
*if (string.IsNullOrWhiteSpace(str) || displayWidth <;= 0)
*{var formattedText = new FormattedText(str,CultureInfo.CurrentCulture,textBlock.FlowDirection,new Typeface(textBlock.FontFamily, textBlock.FontStyle, textBlock.FontWeight, textBlock.FontStretch),textBlock.FontSize,textBlock.Foreground);return formattedText.Width;}
実際の書式設定で文字列の描画幅を取得します
*{throw new NotImplementedException();}
View -&gt; ViewModelの通知が動作した時処理されるConverter

*{this.NavigateNextCommand = new RelayCommand<;object>;(this.NavigateNext);}
：
*{var navigationWindow = (NavigationWindow)Application.Current.MainWindow;navigationWindow.Navigate(new SecondPage(), parameter);}
：
*{get { return (Uri)GetValue(NavigatePageProperty); }set {  SetValue(NavigatePageProperty, value); }}
遷移先のページ
*{get { return GetValue(NavigateExtraDataProperty); }set { SetValue(NavigateExtraDataProperty, value); }}
遷移先に渡すパラメータ
*{if (this.NavigatePage == null){return;}var button = (ButtonBase)sender;var navigationService = GetNavigationService(button);if (navigationService == null){return;}// 現ページのパッケージURLを取得して相対パスを絶対パスに変換する。// ※new Uri(((IUriContext)navigationWindow).BaseUri, this.NavigatePage) だと// 　ナビゲーションウィンドウXAMLからの相対パスになるので、サブディレクトリとの間で遷移できない。var baseUri = BaseUriHelper.GetBaseUri(button);var uri = new Uri(baseUri, this.NavigatePage);// ナビゲートnavigationService.Navigate(uri, this.NavigateExtraData);}
クリックされたときの処理
現ページのパッケージURLを取得して相対パスを絶対パスに変換する。
※new Uri(((IUriContext)navigationWindow).BaseUri, this.NavigatePage) だと
ナビゲーションウィンドウXAMLからの相対パスになるので、サブディレクトリとの間で遷移できない。
*var baseUri = BaseUriHelper.GetBaseUri(button);
ナビゲート
*navigationService.Navigate(uri, this.NavigateExtraData);
NavigationWindow の場合
*return navigationWindow.NavigationService;
プレーンな（非 Navigation）Window で Frame を使用している場合
*return frame.NavigationService;

*this.Refresh();
これを忘れると抑制解除したあとで描画が行われません
*{using (var sus = new FormRedrawSuspension(this)){// このなかでフォームの描画が抑制されます}// 抜けるとき（FormRedrawSuspensionオブジェクトがDisposeされるとき）に、フォームがRefreshされます。}
※2019/3/12 追加：こちらのほうがより安全
このなかでフォームの描画が抑制されます
*}
抜けるとき（FormRedrawSuspensionオブジェクトがDisposeされるとき）に、フォームがRefreshされます。
*}
*private NativeMethods() { }
https:docs.microsoft.com/ja-jp/visualstudio/code-quality/ca1060-move-p-invokes-to-nativemethods-class
*private NativeMethods() { }
https:docs.microsoft.com/ja-jp/visualstudio/code-quality/ca1060-move-p-invokes-to-nativemethods-class

*Console.WriteLine(result);
=&gt; "edo"
生成するインスタンスの型
*Type ctorType = typeof(HogeClass);
引数で受け取る値のパラメータ
*ParameterExpression propParam = Expression.Parameter(typeof(int), "propParam");
インスタンス生成式
*NewExpression ctor = Expression.New(ctorType);
生成したインスタンスを参照するローカル変数
*ParameterExpression local = Expression.Parameter(ctorType, "instance");
インスタンスのプロパティアクセス
*MemberExpression prop = Expression.Property(local, "AnyProperty");
戻り値の型
*LabelTarget returnTarget = Expression.Label(ctorType);
戻り値の設定
*GotoExpression returnExpr = Expression.Return(returnTarget, local, ctorType);
ちょっとこれの理由は不明・・・
*LabelExpression returnLabel = Expression.Label(returnTarget, Expression.Default(ctorType));
*new[] { local },
上記処理を行うブロック文
ラムダ式の生成
*LambdaExpression lambda = Expression.Lambda<;Func<;int, HogeClass>;>;(body, propParam);
結果を受け取る
*var result = func(33);
メソッドの引数に対象クラスのTypeをもらう想定
ラムダ式の引数として与えられるパラメータ
*ParameterExpression arg1 = Expression.Parameter(typeof(AnyBase), "arg1");
ローカルで利用するためのローカル変数パラメータ
*ParameterExpression local1 = Expression.Parameter(type, "instance1");
引数をキャストする
*MethodCallExpression convertExpr1 = Expression.Call(typeof(Convert), "ChangeType", null, arg1, Expression.Constant(local1.Type));
キャストした引数をローカル変数にアサインする
*BinaryExpression castAssign1 = Expression.Assign(local1, valueCast1);

Theoryは引数ありテスト
MemberDataのメソッドから引数を取得する
*[Theory]
*{return new[] {new object[] { TypeKind.Null  , ""        },new object[] { TypeKind.Null  , "null"    },new object[] { TypeKind.Bool  , "true"    },new object[] { TypeKind.Bool  , "false"   },new object[] { TypeKind.Number, "0.0"     },new object[] { TypeKind.Number, "789"     },new object[] { TypeKind.Number, "-12.345" },new object[] { TypeKind.String, "a123"    },new object[] { TypeKind.String, "$#@?+"   }};}
上記テストメソッドに引数を渡す
*{int  Fuga(int x);void Piyo(int x);}
モックにしたいインターフェイス
Fugaメソッドの呼び出しをセットアップする
常に「引数 + 1」を返すように設定
*mock.Setup(hoge =>; hoge.Fuga(It.IsAny<;int>;()))
*mock.Verify(hoge =>; hoge.Piyo(  1), Times.Once);*mock.Verify(hoge =>; hoge.Piyo(  2), Times.AtLeastOnce);
Piyoメソッドの呼び出しを検証する
IHogeインターフェイスに注入する
Hogeクラスへの依存が存在しない
*[Dependency]
DIコンテナの設定
*var container = new UnityContainer();
Fugaインスタンスの生成
*var fuga = container.Resolve<;Fuga>;();

*{Console.WriteLine($"{Value} : {ToString(TypeKind)}");}
...

フリック時のスピード
*private float x_speed = 0;
カメラ拡大縮小時のスピード（実装環境によって要調整）
*private float cameraSpeed = 0.4f;
初期位置
*private Vector2 startPos;
最初のタップからの経過時間
*private float duration = 0;
オブジェクトの移動比率を操作する変数（実装環境によって要調整）
*private float moveRatio = 0.5f;
スワイプするオブジェクト（この場合スクロールビューのコンテンツ）の外部参照
*public GameObject obj;
拡大縮小用カメラの外部参照
*public Camera cam;
経過時間の計算
*duration += Time.deltaTime;
*if(Input.touchCount == 1){*//タップ情報の取得
一本指での操作（スワイプ、フリック）
タップ情報の取得
*Touch touch = Input.GetTouch(0);
*switch(touch.phase){//タップ開始case TouchPhase.Began://タッチ開始座標、時間取得this.startPos = Input.mousePosition;duration = 0;break;//タップ中、指が動いているcase TouchPhase.Moved://オブジェクト移動(スワイプ)Vector3 nowPosi = obj.transform.localPosition;nowPosi.x = nowPosi.x - touch.deltaPosition.x*moveRatio;nowPosi.y = nowPosi.y - touch.deltaPosition.y*moveRatio;obj.transform.localPosition = nowPosi;break;//タップ終了case TouchPhase.Ended://タップ終了位置取得Vector2 endPos = Input.mousePosition;//触れていた秒数でフリックとスワイプ分岐if(duration <;= 0.5){float x_flickLength = endPos.x - this.startPos.x;float y_flickLength = endPos.y - this.startPos.y;// フリックの長さを速度に変換するthis.x_speed = x_flickLength / 500.0f;this.y_speed = y_flickLength / 500.0f;}else{//フリック判定じゃない場合はcameraのTranslate速度を0にするthis.x_speed = 0;this.y_speed = 0;}break;}
タップ状態の分岐
タップ開始
*case TouchPhase.Began:
タッチ開始座標、時間取得
*this.startPos = Input.mousePosition;
タップ中、指が動いている
*case TouchPhase.Moved:
*Vector3 nowPosi = obj.transform.localPosition;*nowPosi.x = nowPosi.x - touch.deltaPosition.x*moveRatio;
オブジェクト移動(スワイプ)
タップ終了
*case TouchPhase.Ended:
タップ終了位置取得
*Vector2 endPos = Input.mousePosition;
*if(duration <;= 0.5){*float x_flickLength = endPos.x - this.startPos.x;
触れていた秒数でフリックとスワイプ分岐
フリックの長さを速度に変換する
*this.x_speed = x_flickLength / 500.0f;
フリック判定じゃない場合はcameraのTranslate速度を0にする
*this.x_speed = 0;
*obj.transform.Translate(this.x_speed, this.y_speed, 0);*//毎フレーム減速させる
オブジェクト移動(フリック)
毎フレーム減速させる
*this.x_speed *= 0.8f;
*if (Input.touchCount == 2){*// 両方のタップ情報を取得
２本指での操作（ピンチイン、アウト）
両方のタップ情報を取得
*Touch touchZero = Input.GetTouch(0);
前フレームでのタップ位置
*Vector2 touchZeroPrePos = touchZero.position - touchZero.deltaPosition;
各フレームのタッチ間の距離
*float preTouchDeltaMag = (touchZeroPrePos - touchOnePrePos).magnitude;
*float deltaMagnitudeDif = preTouchDeltaMag - touchDeltaMag;*//タッチ間の距離の変化からカメラの平行投影サイズを変更
各フレーム間の距離の差
*cam.orthographicSize += deltaMagnitudeDif * cameraSpeed;*// 平行投影サイズは0以上になるようにする(クランプの範囲は要調整)
タッチ間の距離の変化からカメラの平行投影サイズを変更
平行投影サイズは0以上になるようにする(クランプの範囲は要調整)
*cam.orthographicSize = Mathf.Clamp(cam.orthographicSize, 0f , 2.0f);

*{var result = 0.0;{var x = new Container<;int>;(1);var y = new Container<;int>;(1);for(var i = 0; i <; Iteration; ++i)x = Container<;int>;.AddByStaticStrategy(x, y);result += x.Value;}{var x = new Container<;double>;(1);var y = new Container<;double>;(1);for(var i = 0; i <; Iteration; ++i)x = Container<;double>;.AddByStaticStrategy(x, y);result += x.Value;}return result;}
こんな感じのメソッドをPrimitive/Struct/Class、および各特殊化手法ごとに定義していく

*File.WriteAllLines(fi.FullName, lines);
上の行を削除してFile.WriteAllText(fi.FullName, toCsv)でもOK
*// File.WriteAllLines(fi.FullName, content.Replace("\t", ",").Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries));
ワンライナー版
*string[] sepArr = new string[] { "\r\n" };
File.WriteAllLines(fi.FullName, content.Replace("\t", ",").Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries));

適宜
*throw;

*private const int WM_IME_ENDCOMPOSITION = 0x10E;
IME変換終了
Imeを関連付ける
*IntPtr himc = ImmCreateContext();
入力コンテキストにアクセスするためのお約束
*IntPtr hImc = ImmGetContext(this.Handle);
コンポジションウィンドウの位置を設定
*COMPOSITIONFORM info = new COMPOSITIONFORM();
コンポジションウィンドウのフォントを設定
ImmSetCompositionFont(hImc, m_Focus-&gt;GetFont()-&gt;GetInfoLog());
入力コンテキストへのアクセスが終了したらロックを解除する
*ImmReleaseContext(Handle, hImc);
IME以外のメッセージは元のプロシージャで処理
*base.WndProc(ref m);

*using (var request  = new HttpRequestMessage(HttpMethod.Get, new Uri("https:
127.0.0.1:8443test.dat")))

*public byte[] FileDataColumn { get; set; }
：

切り替えたいタイミングでこれを書く
*RenderSettings.skybox = sky;
*if (Input.anyKey == false)*{
キー押してない間はreturn
*if (Input.GetKeyDown(KeyCode.C))*{
テスト用 Change
切り替えたいタイミングでこれを書く
*RenderSettings.skybox = sky;
回転スピード
*[Range(0.01f,0.1f)]
*if (Input.anyKey == false)*{
キー押してない間はreturn
*if (Input.GetKeyDown(KeyCode.C))*{
テスト用 Change
切り替えたいタイミングでこれを書く
*RenderSettings.skybox = sky;

*return $"<;speak version='1.0' xmlns='https:
www.w3.org200110synthesis' xml:lang='ja-JP'&gt;&lt;voice name='ja-JP-NanamiNeural'&gt;{text}&lt;voice&gt;&lt;speak&gt;";

アクセス制限用ポリシーを追加
*options.AddPolicy("SellerPolicy", policy =>; policy.RequireRole("Seller"));
販売者の作品関連ページ
*options.Conventions.AuthorizeAreaFolder("Seller", "/Items", "SellerPolicy");
購入関連ページ
*options.Conventions.AuthorizeFolder("/Purchase");
カートページはログインしていなくても許可
*options.Conventions.AllowAnonymousToPage("/Purchase/Cart");
NOTE: まとめて以下のように書いても良い
options.Conventions
.AuthorizeFolder("/Purchase")
.AllowAnonymousToPage("/Purchase/Cart");
*});
購入作品一覧ページ
*options.Conventions.AuthorizePage("/User/Purchase");
アクセス制限用ポリシーを追加
*options.AddPolicy("SellerPolicy", policy =>; policy.RequireRole("Seller"));
販売者の作品関連ページ
*options.Conventions.AuthorizeAreaFolder("Seller", "/Items","SellerPolicy");
購入関連ページ
*options.Conventions.AuthorizeFolder("/Purchase");
カートページはログインしていなくても許可
*options.Conventions.AllowAnonymousToPage("/Purchase/Cart");
購入作品一覧ページ
*options.Conventions.AuthorizePage("/User/Purchase");

*time += Time.deltaTime;
timeを加算し続ける。
*if (enemy == null &amp;&amp; time >;= 1.2f)*{
enemyが無くかつtimeが1.2f以上の場合はenemyにクローンを生成する。
*if(enemy == true)*{
enemyがある場合timeを0にする。
時間経過を見るためコンソールに時間を表示させる。
*print(time);

*{EditorApplication.update += ProjectWindowUpdate;}
コンストラクタ
*{EditorApplication.update += ProjectWindowUpdate;}
コンストラクタ

*string input_str = base64_textbox_before.Text;*// 指定された文字コードでインスタンス化する
テキストボックス（base64_textbox_before）に入力された文字列を取得する
指定された文字コードでインスタンス化する
*Encoding enc = Encoding.GetEncoding(base64_radio_button);
指定された文字コードに従い,バイト型で取り扱う
*byte[] convert_str = enc.GetBytes(input_str);
Base64エンコードし,文字列として結果を保存する（注：引数はコードページ値もしくはWebNameプロパティ値であること）
*string after_str = Convert.ToBase64String(convert_str);
デコードする場合,以下の方法でデコードする
*byte[] convert_str = Convert.FromBase64String(input_str);
変換結果をもう一つのテキストボックス（base64_textbox_after）に表示する
*base64_textbox_after.Text = after_str;
*string input_str = url_textbox_before.Text;*// 指定された文字コードを取得
テキストボックスに入力された文字列を取得
指定された文字コードを取得
*System.Text.Encoding charcode = System.Text.Encoding.GetEncoding(url_radio_button);
文字列を指定された文字コードに従い,URLエンコードする
*string after_str = System.Web.HttpUtility.UrlEncode(input_str,charcode);
デコードの場合,以下のメソッドを利用する
*string after_str = System.Web.HttpUtility.UrlDecode(tmp_str,charcode);
変換結果をもう一つのテキストボックスに表示する
*url_textbox_after.Text = after_str;
文字実体参照にエンコードする
*string after_str = System.Web.HttpUtility.HtmlEncode(input_str);
数値文字参照および文字実体参照をデコードする
*string after_str = System.Web.HttpUtility.HtmlDecode(input_str);
以下を対応するForm.Designer.csに追記する
*this.[textbox_name].KeyDown += new System.Windows.Forms.KeyEventHandler(this.[textbox_name]_KeyDown);
*{if (e.Control &amp;&amp; e.KeyCode == Keys.A){[textbox_name].SelectAll();}}
以下を対応するForm.csに追記する
以下を対応するForm.Designer.csに追記する
今回はindex=0（文字列コレクションの一番上の文字列）を初期値とする
*this.comboBox1.SelectedIndex = 0;

*foreach (var assertion in ret.assertions) {dataList.Add(new WriteData(assertion.User_Id, assertion.User_Name, assertion.User_DisplayName));}
dataList
*foreach (var data in dataList) {var tmp = data.data1.ToList().Concat(data.data2).Concat(data.data3).ToList();readData.data = readData.data.ToList().Concat(tmp).ToArray();}
data
*{// AES-256key = Encoding.UTF8.GetBytes("ygmh8zudlw5u0a9w4vc29whc4b8wuech");iv = Encoding.UTF8.GetBytes( "o10wi1q3x2f98cobfkyisnwy9s9wxop7");// Rijndael// Mode = CBC// BlockSize = 256bit// PaddingMode = Zerovar cbcBlockCipher = new CbcBlockCipher(new RijndaelEngine(256));cipher = new PaddedBufferedBlockCipher(cbcBlockCipher, new ZeroBytePadding());parametersWithIV = new ParametersWithIV(new KeyParameter(key), iv);cipher.Init(false, parametersWithIV);var bytes = new byte[cipher.GetOutputSize(inData.Length)];var length = cipher.ProcessBytes(inData, bytes, 0);var ret = cipher.DoFinal(bytes, length);return bytes;}
inDataが暗号化されているデータです
ヘッダとフッダは飛ばす
*pems.RemoveAt(0);
つなげる
*var base64 = String.Join("", pems);
もどす
*return (Convert.FromBase64String(base64));
*{key = Encoding.UTF8.GetBytes("ygmh8zudlw5u0a9w4vc29whc4b8wuech");iv = Encoding.UTF8.GetBytes( "o10wi1q3x2f98cobfkyisnwy9s9wxop7");// Rijndael// Mode = CBC// BlockSize = 256bit// PaddingMode = Zerovar cbcBlockCipher = new CbcBlockCipher(new RijndaelEngine(256));cipher = new PaddedBufferedBlockCipher(cbcBlockCipher, new ZeroBytePadding());parametersWithIV = new ParametersWithIV(new KeyParameter(key), iv);cipher.Init(true, parametersWithIV);var bytes = new byte[cipher.GetOutputSize(inData.Length)];var length = cipher.ProcessBytes(inData, bytes, 0);cipher.DoFinal(bytes, length);return bytes;}
inDataがDER形式の秘密鍵です
*{var status = await gebo.CTAP2.WebAuthnModokiDesktop.Credentials.SetPin(gebo.CTAP2.DevParam.GetDefaultParams(), "1234");if( status.isSuccess == false) {// Errorreturn false;}return true;}
PINは1234
*var attr = new Dictionary<;DerObjectIdentifier, string>;()*{
証明書の属性
証明書の生成
*var name = new X509Name(ord, attr);
*using (var writer = new StreamWriter(mem, Encoding.ASCII)) {var pemWriter = new PemWriter(writer);pemWriter.WriteObject(cert);pemWriter.Writer.Flush();}
証明書の出力
newpin=新しいPIN、currentpin=現在のPIN
*var devParam = gebo.CTAP2.DevParam.GetDefaultParams();
*} else {
OK
1.Base64エンコード
2.64文字ごとに改行コードをいれる
3.ヘッダとフッタを入れる
*public static string ConvertPrivateKeyDERtoPEM(byte[] der)
PEMフォーマットの秘密鍵を読み込んで KeyPair オブジェクトを生成
*var privateKeyReader = new PemReader(new StringReader(pemPrivateKey));
*{z.CreateEntryFromFile(targetFile, targetFileName, CompressionLevel.Optimal);ZipArchiveEntry item = z.CreateEntry("sig.sig",CompressionLevel.Optimal);using (Stream stream = item.Open()){stream.Write(sig, 0, sig.Length);stream.Flush();}}
zipに固める
*{Org.BouncyCastle.X509.X509Certificate readedCert;// 証明書の読み込みusing (var reader = new StreamReader(certFile, Encoding.ASCII)) {var pemReader = new PemReader(reader);readedCert = (Org.BouncyCastle.X509.X509Certificate)pemReader.ReadObject();}var publicKey = readedCert.GetPublicKey();return (publicKey);}
certFileは証明書のパスファイル名です
*using (var reader = new StreamReader(certFile, Encoding.ASCII)) {var pemReader = new PemReader(reader);readedCert = (Org.BouncyCastle.X509.X509Certificate)pemReader.ReadObject();}
証明書の読み込み

*var dict = new Dictionary<;string, int>; {{ "a", 0 },{ "b", 0 },{ "c", 0 },{ null, 0 },};
例外が発生する

ShaderEffect.PixelShader プロパティにセット
*this.PixelShader = pixelShader;

*var requestMock = new HttpRequestMock(new NameValueCollection() { { "hoge", "12345" } });
Arrange

*// 'Operation is not supported on this platform.'*rsa.FromXmlString(privateKey);
ここで PlatformNotSupportedException がスローされます。
鍵を読み込むことができます。.NET Core 2.1 で確認。
シグネチャが同一である場合は拡張メソッドではなく本体に実装されているメソッドが優先されるため、メソッド名は変更しました。
*rsa.FromXmlStringEx(privateKey);

*{//開始時に現在時刻の記録DateTime localTime = DateTime.Now;File.AppendAllText(@"timelog.txt", localTime+" ", Encoding.UTF8);}
Form開始時の処理
開始時に現在時刻の記録
*DateTime localTime = DateTime.Now;
*{//終了時に現在時刻の記録DateTime localTime = DateTime.Now;File.AppendAllText(@"timelog.txt", localTime + Environment.NewLine, Encoding.UTF8);}
Form終了時の処理
終了時に現在時刻の記録
*DateTime localTime = DateTime.Now;

*8,
GraphicsMode.Default.Samples,
コンテキストの作成
*GLControl glControl = new GLControl(mode);
イベントの追加
*glControl.Load += glControl_Load;
ホストの子に設定
*glHost.Child = glControl;
背景色の設定
*GL.ClearColor(Color4.White);
ビューポートの設定
*GL.Viewport(0, 0, glControl.Width, glControl.Height);
視体積の設定
*GL.MatrixMode(MatrixMode.Projection);
視界の設定
*GL.MatrixMode(MatrixMode.Modelview);
デプスバッファの使用
*GL.Enable(EnableCap.DepthTest);
光源の使用
*GL.Enable(EnableCap.Lighting);
ビューポートの設定
*GL.Viewport(0, 0, glControl.Width, glControl.Height);

*{// トランザクション開始using (var transaction = context.Database.BeginTransaction()){// 1つめの SaveChanges()var product = await context.Products.SingleAsync(p =>; p.ProductID == 1).ConfigureAwait(false);product.ProductName = "New Product Name";await context.SaveChangesAsync().ConfigureAwait(false);// 2つめの SaveChanges()var employee = await context.Employees.SingleAsync(e =>; e.EmployeeID == 1).ConfigureAwait(false);employee.Title = "New Title";await context.SaveChangesAsync().ConfigureAwait(false);// まとめてコミットtransaction.Commit();}}
コンテキスト
*{// 1つめの SaveChanges()var product = await context.Products.SingleAsync(p =>; p.ProductID == 1).ConfigureAwait(false);product.ProductName = "New Product Name";await context.SaveChangesAsync().ConfigureAwait(false);// 2つめの SaveChanges()var employee = await context.Employees.SingleAsync(e =>; e.EmployeeID == 1).ConfigureAwait(false);employee.Title = "New Title";await context.SaveChangesAsync().ConfigureAwait(false);// まとめてコミットtransaction.Commit();}
トランザクション開始
1つめの SaveChanges()
*var product = await context.Products.SingleAsync(p =>; p.ProductID == 1).ConfigureAwait(false);
2つめの SaveChanges()
*var employee = await context.Employees.SingleAsync(e =>; e.EmployeeID == 1).ConfigureAwait(false);
まとめてコミット
*transaction.Commit();
接続準備
*var workspace = NorthwindEntities.GetMetadataWorkspace();
あらかじめ接続を開いておく。
*sqlConnection.Open();
*{// 1つ目のコンテキストを操作する。using (var context = new NorthwindEntities(entityConnection1, false)){context.Database.UseTransaction(transaction);var product = await context.Products.SingleAsync(p =>; p.ProductID == 1).ConfigureAwait(false);product.ProductName = "New Product Name";await context.SaveChangesAsync().ConfigureAwait(false);}// 別の EntityConnection を使って2つ目のコンテキストを操作する。// ※同じ EntityConnection を使用すると InvalidOperationException が発生する。using (var context = new NorthwindEntities(entityConnection2, false)){context.Database.UseTransaction(transaction);var employee = await context.Employees.SingleAsync(e =>; e.EmployeeID == 1).ConfigureAwait(false);employee.Title = "New Title";await context.SaveChangesAsync().ConfigureAwait(false);}// まとめてコミットtransaction.Commit();}
トランザクション開始
*{context.Database.UseTransaction(transaction);var product = await context.Products.SingleAsync(p =>; p.ProductID == 1).ConfigureAwait(false);product.ProductName = "New Product Name";await context.SaveChangesAsync().ConfigureAwait(false);}
1つ目のコンテキストを操作する。
別の EntityConnection を使って2つ目のコンテキストを操作する。
※同じ EntityConnection を使用すると InvalidOperationException が発生する。
*using (var context = new NorthwindEntities(entityConnection2, false))
まとめてコミット
*transaction.Commit();
*{/// <;summary>;/// コンストラクタ。/// <;/summary>;/// <;param name="existingConnection">;コンテキストで使用する接続。<;/param>;/// <;param name="contextOwnsConnection">;false を指定すると、コンテキストが Dispose されたときに接続を Dispose しない。<;/param>;public NorthwindEntities(DbConnection existingConnection, bool contextOwnsConnection): base(existingConnection, contextOwnsConnection){}/// <;summary>;/// メタデータワークスペースを取得する。/// <;/summary>;/// <;returns>;<;/returns>;public static MetadataWorkspace GetMetadataWorkspace(){using (var context = new NorthwindEntities()){var objectContext = ((IObjectContextAdapter)context).ObjectContext;return objectContext.MetadataWorkspace;}}}
コンテキストの部分クラス

シンボルAAAが定義されていないため、下のHello()の呼び出しはコンパイルされない
*Hello();

*UpdateCube(frame);
デバッグ用Cubeを表示する
*Vector3 pos_forward = TriangleNormal(now_pos[7], now_pos[4], now_pos[1]);*bone_t[0].position = now_pos[0] * scale_ratio + new Vector3(init_position.x, heal_position, init_position.z);
センターの移動と回転
*for (int i = 0; i <; bones.Length; i++) {*int b = bones[i];
各ボーンの回転
顔の向きを上げる調整。両肩を結ぶ線を軸として回転
*bone_t[8].rotation = Quaternion.AngleAxis(head_angle, bone_t[11].position - bone_t[14].position) * bone_t[8].rotation;

*private const string EndpointUrl = "https:
&lt;your-account&gt;.documents.azure.com:443";
*Console.WriteLine("Created Database: {0}\n", database.Id);
Create a new database
*Console.WriteLine("Created Container: {0}\n", container.Id);
Create a new container
*{Id = "Andersen.1",LastName = "Andersen",Parents = new Parent[]{new Parent { FirstName = "Thomas" },new Parent { FirstName = "Mary Kay" }},Children = new Child[]{new Child{FirstName = "Henriette Thaulow",Gender = "female",Grade = 5,Pets = new Pet[]{new Pet { GivenName = "Fluffy" }}}},Address = new Address { State = "WA", County = "King", City = "Seattle" },IsRegistered = false};
Create a family object for the Andersen family
*Console.WriteLine("Item in database with id: {0} already exists\n", andersenFamilyResponse.Resource.Id);
Read the item to see if it exists.
*Console.WriteLine("Created item in database with id: {0}\n", andersenFamilyResponse.Resource.Id);
Note that after creating the item, we can access the body of the item with the Resource property off the ItemResponse.
*{Id = "Wakefield.7",LastName = "Wakefield",Parents = new Parent[]{new Parent { FamilyName = "Wakefield", FirstName = "Robin" },new Parent { FamilyName = "Miller", FirstName = "Ben" }},Children = new Child[]{new Child{FamilyName = "Merriam",FirstName = "Jesse",Gender = "female",Grade = 8,Pets = new Pet[]{new Pet { GivenName = "Goofy" },new Pet { GivenName = "Shadow" }}},new Child{FamilyName = "Miller",FirstName = "Lisa",Gender = "female",Grade = 1}},Address = new Address { State = "NY", County = "Manhattan", City = "NY" },IsRegistered = true};
Create a family object for the Wakefield family
*Console.WriteLine("Created item in database with id: {0}\n", wakefieldFamilyResponse.Resource.Id);
Note that after creating the item, we can access the body of the item with the Resource property off the ItemResponse. We can also access the RequestCharge property to see the amount of RUs consumed on this request.
*Console.WriteLine("Running query: {0}\n", sqlQueryText);
var sqlQueryText = "SELECT * FROM c WHERE c.LastName = 'Andersen'";
*{while (feedIterator.HasMoreResults){FeedResponse<;Family>; response = await feedIterator.ReadNextAsync();foreach (Family family in response){//families.Add(family);Console.WriteLine("\tRead {0}\n", family);}}}
List&lt;Family&gt; families = new List&lt;Family&gt;();
*Console.WriteLine("\tRead {0}\n", family);
families.Add(family);
*Console.WriteLine("Updated Family [{0},{1}].\n \tBody is now: {2}\n", itemBody.LastName, itemBody.Id, wakefieldFamilyResponse.Resource);
replace the item with the updated content
*Console.WriteLine("Deleted Family [{0},{1}]\n", partitionKeyValue, familyId);
Delete an item. Note we must provide the partition key value and id of the item to delete

通常処理
*var response = await base.UnaryServerHandler(request, context, continuation);
*Services = { service.ServerServiceDefinition.Intercept(new HogeInterceptor()) },
ここで Interceptor を挟んだ ServerServiceDefinition を渡す
*// Services = { service },
挟まない場合はこう
*Ports = { new ServerPort("localhost", 12345, ServerCredentials.Insecure) }
Services = { service },
ここで Interceptor を挟んだ CallInvoker を生成
*var invoker = channel.Intercept(new HogeInterceptor());
挟まない場合はこう
var client = MagicOnionClient.Create&lt;IMyFirstService&gt;(channel);
*,,,

なにかしらの処理
*}

*"20"
第2引数
python側でprintした内容を取得
*var sr = process.StandardOutput;

「タブの高さ」×「タブストリップの行数」＋「タブページの高さ」でtab全体を表示するための高さを取得
*tab.Height = tab.ItemSize.height * tab.RowCount + tabPage.Height;

*{ForwardedHeaders = Microsoft.AspNetCore.HttpOverrides.ForwardedHeaders.XForwardedFor | Microsoft.AspNetCore.HttpOverrides.ForwardedHeaders.XForwardedProto});
リバースプロキシー設定用
*{options.TextEncoderSettings = new System.Text.Encodings.Web.TextEncoderSettings(System.Text.Unicode.UnicodeRanges.All);});
UTF8文字コード設定

*Console.WriteLine(isSatisfy);
True

*if(Input.GetMouseButtonDown(0)) {*// クリックした座標
スワイプの長さを求める
*} else if(Input.GetMouseButtonUp(0)) {
クリックした座標
離した座標
*Vector2 endPos = Input.mousePosition;
スワイプの長さを初速度に変換する
*this.speed = swipeLength / 500.0f;
*void Start(){}
Use this for initialization
*{// ポイント１_1// 1度目のスワイプのみ有効if (this.movedFlg == false){// スワイプの長さを求めるif (Input.GetMouseButtonDown(0)){// クリックした座標this.startPos = Input.mousePosition;}else if (Input.GetMouseButtonUp(0)){// 離した座標Vector2 endPos = Input.mousePosition;// ポイント２// タップの場合は動作させないfloat swipeLength = endPos.x - this.startPos.x;if (swipeLength >; 0 || swipeLength <; 0){// 初速度設定this.speed = swipeLength / 500.0f;// ポイント１_2this.movedFlg = true;}}}// 移動速度設定transform.Translate(this.speed, 0, 0);this.speed *= 0.98f;}
Update is called once per frame
ポイント１_1
1度目のスワイプのみ有効
*if (this.movedFlg == false)
*if (Input.GetMouseButtonDown(0))*{
スワイプの長さを求める
クリックした座標
*this.startPos = Input.mousePosition;
離した座標
*Vector2 endPos = Input.mousePosition;
ポイント２
タップの場合は動作させない
*float swipeLength = endPos.x - this.startPos.x;
初速度設定
*this.speed = swipeLength / 500.0f;
ポイント１_2
*this.movedFlg = true;
*transform.Translate(this.speed, 0, 0);*this.speed *= 0.98f;
移動速度設定
ポイント１_1
1度目のスワイプのみ有効
*if (this.movedFlg == false)
初速度設定
*this.speed = swipeLength / 500.0f;
ポイント１_2
*this.movedFlg = true;
ポイント２
タップの場合は動作させない
*float swipeLength = endPos.x - this.startPos.x;
*{this.car = GameObject.Find("car");this.flag = GameObject.Find("flag");this.distance = GameObject.Find("Distance");// ポイント1_1this.sceneName = SceneManager.GetActiveScene().name;// ポイント2_1this.defaultLength = this.flag.transform.position.x - this.car.transform.position.x - 1.53f;}
Use this for initialization
ポイント1_1
*this.sceneName = SceneManager.GetActiveScene().name;
*this.defaultLength = this.flag.transform.position.x - this.car.transform.position.x - 1.53f;*}
ポイント2_1
*{this.length = this.flag.transform.position.x - this.car.transform.position.x - 1.53f;if (this.finishFlg == false){// ポイント2_2// 車が停止中のテキスト表示if (this.length.Equals(this.defaultLength)){this.distance.GetComponent<;Text>;().text = "スワイプでゴールを目指せ！\nゴールを越えたらゲームオーバー";}// ポイント2_3// 逆走したらリトライelse if (this.length >; this.defaultLength){// ポイント1_3Invoke("Retry", 1);}// 車が動作中のテキスト表示else if (this.length >;= 0){this.distance.GetComponent<;Text>;().text = "ゴールまで" + this.length.ToString("F2") + "m";// ポイント3_2Invoke("GetScore", 10);}// ポイント2_4// ゴールを超えたらゲームオーバーelse{this.distance.GetComponent<;Text>;().text = "ゲームオーバー";// ポイント1_3Invoke("Retry", 1);}}}
Update is called once per frame
ポイント2_2
車が停止中のテキスト表示
*if (this.length.Equals(this.defaultLength))
ポイント2_3
逆走したらリトライ
*else if (this.length >; this.defaultLength)
ポイント1_3
*Invoke("Retry", 1);
*else if (this.length >;= 0)*{
車が動作中のテキスト表示
ポイント3_2
*Invoke("GetScore", 10);
ポイント2_4
ゴールを超えたらゲームオーバー
*else
ポイント1_3
*Invoke("Retry", 1);
*{this.finishFlg = true;if (this.length <; 0.5){this.distance.GetComponent<;Text>;().text = "perfect!!!";}else if (this.length <; 1){this.distance.GetComponent<;Text>;().text = "great!!";}else if (this.length <; 1.5){this.distance.GetComponent<;Text>;().text = "good!";}else{this.distance.GetComponent<;Text>;().text = "too bad...";}// ポイント1_3Invoke("Retry", 2);}
ポイント3_1
ポイント1_3
*Invoke("Retry", 2);
*{SceneManager.LoadScene(this.sceneName);}
ポイント1_2
ポイント1_1
*this.sceneName = SceneManager.GetActiveScene().name;
*public void Retry(){SceneManager.LoadScene(this.sceneName);}
ポイント1_2
ポイント1_3
*Invoke("Retry", 1);
*this.defaultLength = this.flag.transform.position.x - this.car.transform.position.x -1.53f;*,,,
ポイント2_1
ポイント2_2
車が停止中のテキスト表示
*if (this.length.Equals(this.defaultLength))
ポイント2_3
逆走したらリトライ
*else if (this.length >; this.defaultLength)
ポイント1_3
*Invoke("Retry", 1);
ポイント2_4
ゴールを超えたらゲームオーバー
*else
ポイント1_3
*Invoke("Retry", 1);
*{this.finishFlg = true;if (this.length <; 0.5){this.distance.GetComponent<;Text>;().text = "perfect!!!";}else if (this.length <; 1){this.distance.GetComponent<;Text>;().text = "great!!";}else if (this.length <; 1.5){this.distance.GetComponent<;Text>;().text = "good!";}else{this.distance.GetComponent<;Text>;().text = "too bad...";}// ポイント1_3Invoke("Retry", 2);}
ポイント3_1
ポイント1_3
*Invoke("Retry", 2);
*else if (this.length >;= 0)*{
車が動作中のテキスト表示
ポイント3_2
*Invoke("GetScore", 10);
ポイント3_2
*Invoke("GetScore", 10);

*{// SaveChanges() を実行するたびに接続が開閉され、分散トランザクションになるのを防ぐため、あらかじめ開いておく。((IObjectContextAdapter)context).ObjectContext.Connection.Open();// TransactionScope で囲む。var options = new TransactionOptions { IsolationLevel = IsolationLevel.ReadCommitted };using (var scope = new TransactionScope(TransactionScopeOption.Required, options)){// 1つめの SaveChanges()var product = context.Products.Single(p =>; p.ProductID == 1);product.ProductName = "New Product Name";context.SaveChanges();// 2つめの SaveChanges()var employee = context.Employees.Single(e =>; e.EmployeeID == 1);employee.Title = "New Title";context.SaveChanges();// まとめてコミットscope.Complete();}}
コンテキスト
SaveChanges() を実行するたびに接続が開閉され、分散トランザクションになるのを防ぐため、あらかじめ開いておく。
*((IObjectContextAdapter)context).ObjectContext.Connection.Open();
*var options = new TransactionOptions { IsolationLevel = IsolationLevel.ReadCommitted };
TransactionScope で囲む。
1つめの SaveChanges()
*var product = context.Products.Single(p =>; p.ProductID == 1);
2つめの SaveChanges()
*var employee = context.Employees.Single(e =>; e.EmployeeID == 1);
まとめてコミット
*scope.Complete();
*{// SaveChanges() を実行するたびに接続が開閉され、分散トランザクションになるのを防ぐため、あらかじめ開いておく。connection.Open();// TransactionScope で囲む。var options = new TransactionOptions { IsolationLevel = IsolationLevel.ReadCommitted };using (var scope = new TransactionScope(TransactionScopeOption.Required, options)){// 1つめのコンテキスト（接続を指定して生成）using (var context = new NorthwindEntities(connection, false)){var product = context.Products.Single(p =>; p.ProductID == 1);product.ProductName = "New Product Name";context.SaveChanges();}// 2つめのコンテキスト（接続を指定して生成）using (var context = new NorthwindEntities(connection, false)){var employee = context.Employees.Single(e =>; e.EmployeeID == 1);employee.Title = "New Title";context.SaveChanges();}// まとめてコミットscope.Complete();}}
共用する接続の作成
SaveChanges() を実行するたびに接続が開閉され、分散トランザクションになるのを防ぐため、あらかじめ開いておく。
*connection.Open();
*var options = new TransactionOptions { IsolationLevel = IsolationLevel.ReadCommitted };
TransactionScope で囲む。
*{var product = context.Products.Single(p =>; p.ProductID == 1);product.ProductName = "New Product Name";context.SaveChanges();}
1つめのコンテキスト（接続を指定して生成）
*{var employee = context.Employees.Single(e =>; e.EmployeeID == 1);employee.Title = "New Title";context.SaveChanges();}
2つめのコンテキスト（接続を指定して生成）
まとめてコミット
*scope.Complete();
*{/// <;summary>;/// コンストラクタ。/// <;/summary>;/// <;param name="existingConnection">;コンテキストで使用する接続。<;/param>;/// <;param name="contextOwnsConnection">;false を指定すると、コンテキストが Dispose されたときに接続を Dispose しない。<;/param>;public NorthwindEntities(DbConnection existingConnection, bool contextOwnsConnection): base(existingConnection, contextOwnsConnection){}}
コンテキストの部分クラス
*{try{var product = context.Products.Single(p =>; p.ProductID == 1);product.ProductName = "New Product Name";context.SaveChanges();var employee = context.Employees.Single(e =>; e.EmployeeID == 1);employee.Title = "New Title";context.SaveChanges();// コミットtransaction.Commit();}catch{// ロールバックtransaction.Rollback();throw;}}
トランザクション開始
コミット
*transaction.Commit();
ロールバック
*transaction.Rollback();

*foreach(x in collection){*if(/*条件*/){
LINQに書き換えたほうが良い構造
LINQに書き換える
*collection.Where(/*条件*/).ForEach(/*collectionの各要素に行う処理*/);

*static void CreateEditorFolder()
FolderCreate("フォルダ名");　で新しいフォルダ追加可能

トークンの有効期限を5分後に設定します。
*DateTimeOffset expiration = s_JwtHelper.DateTimeProvider.GetNow().AddMinutes(5);
*{Role = UserRole.User,Permissions = UserPermissions.Get | UserPermissions.Modify};
IDとパスワードが妥当であり、そのユーザーの情報を取得できたものとします。
秘密鍵。当然ですが、実際にはストレージなどから読み込みます。
*const string secretKey = "GQDstcKsx0NHjPOuXOYg5MbeJ1XT0uFiwDVvVBrk";
秘密鍵。当然ですが、実際にはストレージなどから読み込みます。
*const string secretKey = "GQDstcKsx0NHjPOuXOYg5MbeJ1XT0uFiwDVvVBrk";
リクエストヘッダーにトークンを格納するときのキー
*internal const string AuthorizationToken = "authorization";
レスポンスヘッダーにトークン認証結果を格納するときのキー
*internal const string AuthenticateResult = "www-authenticate";
*{if (!TryGetToken(context, out string token) || string.IsNullOrEmpty(token)){userInfo = null;exception = new RpcException(new Status(StatusCode.Unauthenticated, "Token is not set."));return false;}try{string[] values = token.Split(".");var json = s_JwtHelper.Decoder.Decode(token, secretKey, verify: true);var payload = s_JwtHelper.JsonSerializer.Deserialize<;Dictionary<;string, object>;>;(json);userInfo = s_JwtHelper.JsonSerializer.Deserialize<;UserInfo>;((string)payload["user"]);exception = null;return true;}catch (JWT.TokenExpiredException){userInfo = null;Metadata trailers = new Metadata();trailers.Add(AuthHeaderKeys.AuthenticateResult, "expired");exception = new RpcException(new Status(StatusCode.Unauthenticated, "Token has expired."), trailers);return false;}catch (JWT.SignatureVerificationException){userInfo = null;Metadata trailers = new Metadata();trailers.Add(AuthHeaderKeys.AuthenticateResult, "invalid");exception = new RpcException(new Status(StatusCode.Unauthenticated, "Token has invalid signature."), trailers);return false;}catch (Exception ex){userInfo = null;Metadata trailers = new Metadata();trailers.Add(AuthHeaderKeys.AuthenticateResult, "invalid");exception = new RpcException(new Status(StatusCode.Unauthenticated, "Could not get user information."), trailers);return false;}}
コンテキストに格納されている情報からトークンの検証を行います。
*if (!VaridateToken(context, out UserInfo userInfo, out RpcException ex))*{
トークンを認証します。
処理を行ってレスポンスを返します。
*return new Response();

*public int hp = xxx;
(数字を設定する)

接続文字列を生成
*_connectString = ConfigurationManager.ConnectionStrings[connectionString].ConnectionString;
クエリー送信先、トランザクションの指定
*sqlCom.Connection = this._con;

*public string A { get; set; }
-a と -aaa の二つ指定可能
*public bool B { get; set; }
string 以外でも受け取れる（この場合はオプションがあるかどうか）
*public IEnumerable<;string>; C { get; set; }
Sepalatorで指定下文字を区切り文字として、複数の値を渡せる
*public HogeInfo D { get; set; }
enumもいける（Hoge, Fuga などと指定する）
*public IEnumerable<;string>; Others { get; set; }
上記指定以外のオプションや文字列が入る
ジェネリクスでオプションクラスを指定し、パースする
*var parseResult = Parser.Default.ParseArguments<;Options>;(args);
*{// パース成功case ParserResultType.Parsed:// パースの成否でパース結果のオブジェクトの方が変わるvar parsed = parseResult as Parsed<;Options>;;// 成功時はキャストしたオブジェクトからパース結果が取得可能opt = parsed.Value;// 表示用に整形string strC = string.Concat("{ ", string.Join(", ", opt.C.Select(e =>; $"\"{e}\"")), " }");string strOthers = string.Concat("{ ", string.Join(", ", opt.Others.Select(e =>; $"\"{e}\"")), " }");Console.WriteLine($"opt.A = {opt.A}");Console.WriteLine($"opt.B = {opt.B}");Console.WriteLine($"opt.C = {strC}");Console.WriteLine($"opt.D = {opt.D}");Console.WriteLine($"opt.Others = {strOthers}");break;// パース失敗case ParserResultType.NotParsed:// パースの成否でパース結果のオブジェクトの方が変わるvar notParsed = parseResult as NotParsed<;Options>;;break;}
結果はTagに入っている
パース成功
*case ParserResultType.Parsed:
パースの成否でパース結果のオブジェクトの方が変わる
*var parsed = parseResult as Parsed<;Options>;;
成功時はキャストしたオブジェクトからパース結果が取得可能
*opt = parsed.Value;
*string strC = string.Concat("{ ", string.Join(", ", opt.C.Select(e =>; $"\"{e}\"")), " }");
表示用に整形
パース失敗
*case ParserResultType.NotParsed:
パースの成否でパース結果のオブジェクトの方が変わる
*var notParsed = parseResult as NotParsed<;Options>;;

*writer.Flush();
StreamWriter.Flush を呼ばないとバッファーからメモリに書き込まれないので注意
サンプルなので DI せず直にインスタンス化
*readonly TodoService service = new TodoService();

省略
*#else

*class Program : ConsoleAppBase
inherit ConsoleAppBase
*{for (int i = 0; i <; repeat; i++){Console.WriteLine($"Hello My ConsoleApp from {name}");}}
allows void/Task return type, parameter is automatically binded from string[] args.

*Debug.Log(ret);
インライン展開されて消えることがないようにちゃんと戻り値を使う

*new MathTest(100.0).run();
メモリキャッシュとか対策にちょっと回す

*return false;
強制で切断した場合に Socket が null になるため、例外を無視

*{if( step <;= 0 ){return;}Mult();Sin();Sqrt();Atan();Exp();Pow();Pow2();}
Update is called once per frame

*{//q = u + xi + yj + zkpublic float u;public float x;public float y;public float z;//コンストラクタpublic MyQuaternion(float u, float x, float y, float z)=>; (this.u, this.x, this.y, this.z) = (u, x, y, z);}
くぉーたにおん！
コンストラクタ
*public MyQuaternion(float u, float x, float y, float z)
*{var rx = x * Mathf.Deg2Rad;var ry = y * Mathf.Deg2Rad;var rz = z * Mathf.Deg2Rad;var cx = Mathf.Cos(rx / 2);var sx = Mathf.Sin(rx / 2);var cy = Mathf.Cos(ry / 2);var sy = Mathf.Sin(ry / 2);var cz = Mathf.Cos(rz / 2);var sz = Mathf.Sin(rz / 2);this.u = cx * cy * cz + sx * sy * sz;this.x = sx * cy * cz - cx * sy * sz;this.y = cx * sy * cz + sx * cy * sz;this.z = cx * cy * sz - sx * sy * cz;}
Quaternion.Euler(x,y,z)のやつ
光源(f,0,0,0)からスクリーンu=0への透視投影
*public Vector3 Project(float f)
平行投影はu座標を消すだけ
*public Vector3 ProjectParallel() =>; new Vector3(x, y, z);
回転（原点中心）
*public MyQuaternion Rotate(MyQuaternion QL, MyQuaternion QR) =>; QL * this * QR;
６つのオイラー角からデュアルクォータニオンを作って適用
*public MyQuaternion Rotate(float x1, float y1, float z1, float x2, float y2, float z2)
超立方体の面を構成する各三角形ABCについて、
超平面u=0との交線を求める。
すべての頂点が同じ側にある場合は交わらない。
*if (A.u <; 0 &amp;&amp; B.u <; 0 &amp;&amp; C.u <; 0 || A.u >; 0 &amp;&amp; B.u >; 0 &amp;&amp; C.u >; 0)
*else if (A.u * B.u >;= 0)*{
AとBが同じ側にある場合、AC間とBC間がu=0で切断される。
AC上、u=0の点Pを求める。
*var t = -C.u / (A.u - C.u);
BC上、u=0の点Qを求める。
*var s = -C.u / (B.u - C.u);
*return new[] { P, Q };
PQは求めたい交線である。
*else if (A.u * C.u >;= 0)*{
他の場合も同様

プロパティ経由でDIコンテナから依存オブジェクトを取得して使用する。
*return this.Service.GetText();
*foreach (var mock in this.mocks)*{
モックが期待どおりに呼び出されたことを検証する。
モック設定
*var serviceMock = CreateMock<;Service>;();
テスト対象オブジェクトを生成
*var client = new Client();
テスト対象メソッドを実行
*string result = client.Act();
戻り値の検証
※モックの検証は基底クラスで自動的に行われる。
*Assert.AreEqual("UnitTest", result);

*using System.IO;
冒頭に左記を追加する必要がある
実行クラスを取得し、実行
*GetExecutable(args).Exec();
引数が指定されない場合、投稿内容を表示
*return new ReadBoard();
引数が1個指定された場合、引数の内容を投稿する
*return new WriteBoard(args[0]);
投稿内容リスト
*var contentList = ReadFile();
*foreach (var contents in contentList.OrderByDescending(c =>; c.Date))*{
投稿内容を投稿日時の降順でソートして出力する
ファイルが未作成の場合：NOP
*yield break;
投稿リストを1行ずつ処理
*string line;
Contents インスタンスに変換して返す
*yield return Contents.Parse(line);
投稿内容インスタンスを作成し、ファイル末尾に出力
*writer.WriteLine(new Contents(message));

*IPEndPoint remoteEP = null;
任意の送信元からのデータを受信
*{txtCmd.Text = cmd;byte[] data = Encoding.ASCII.GetBytes(cmd);this.udpForCmd.Send(data, data.Length, "192.168.10.1", 8889);}
コマンド送信
*{Debug.WriteLine("SpeechRecognized...");if (e.Result.Semantics != null){if (e.Result.Semantics.ContainsKey("singleCommands")){Debug.WriteLine("..." + e.Result.Semantics["singleCommands"].Value);sendCmd((string)e.Result.Semantics["singleCommands"].Value);}else if (e.Result.Semantics.ContainsKey("moveCommands") &amp;&amp;e.Result.Semantics.ContainsKey("moveCm")){Debug.WriteLine("..." + e.Result.Semantics["moveCommands"].Value + " " + e.Result.Semantics["moveCm"].Value);sendCmd((string)e.Result.Semantics["moveCommands"].Value + " " + ((int)e.Result.Semantics["moveCm"].Value).ToString());}}}
Handle the SpeechRecognized event.

バインディングしたい場合は、そのクラスを作りオブジェクト化してバインディングする
*var appSettings = new AppSettings();

*this.expenseItems.DataContext = ExpenseDao.selectByUser(data as User);
追加

Subjectまとめとこうとするとなんかエラー出る.
SubjectってもしかしてListとかArrayとかに入れられないやつ？
CompositeDisposableみたいなのを自作する必要がある？
他のObservableTriggerBase継承クラスはSubjectひとつひとつにOnCompletedやDisposeしている…….
*private Subject<;object>;[] _subjectable;
OnConnectedToMaster時にOnCompletedされる想定
*Subject<;Unit>; ConnectMaster = new Subject<;Unit>;();

*​
ループを3回おこない、ループごとにiに1から3が代入される

ジェネリクスを使って比較メソッドを実装
比較可能な型を指定した時にのみ このメソッドを呼び出せる
*private T Compare<;T>;(T x, T y) where T : IComparable
SomeDelegate という名前のデリゲート型を定義
*private delegate void SomeDelegate();
SomeDelegate型の変数にメソッドを代入
型を明示的に宣言する必要がある
*SomeDelegate hoge = WriteDatetimeNow;
このように代入したメソッドを呼び出す
*hoge.Invoke();
SomeDelegate という名前のデリゲート型を定義
*public delegate void SomeDelegate();
何らかのイベントを定義
*public event SomeDelegate HogeEvent;
SomeDelegate型の変数にメソッドを代入
型を明示的に宣言する必要がある
*SomeDelegate someDelegate = WriteDatetimeNow;
イベントにメソッドを割り付ける
*HogeEvent += someDelegate;
何かしらの処理
*});
もしくはこっち
*Task.Run(() =>; WriteDateTimeNow());
*{Console.WriteLine(DateTime.Now);});
{}の中身が名前のないメソッド
*{//何かしらの処理});
この()は何なのか
何かしらの処理
*});
パターン1
引数は無し
戻り値はvoid
*Action Hoge = () =>; Console.WriteLine(DateTime.Now);
もしくはこう書く
*Task.Run(() =>; Console.WriteLine(DateTime.Now));
パターン2
引数はint型を1つ
戻り値はvoid
*Action<;int>; Fuga = x =>; Console.WriteLine(x);
*{var t = 1;Console.WriteLine(t);});
もしくはこう書く
パターン1
引数はint型を1つ
戻り値はstring型
*Func<;int, string>; Hoge = (int x) =>; x.ToString();
*{var x = 1;return x.ToString();});
もしくはこう書く
パターン2
引数はint型を2つ
戻り値はstring型
*Func<;int, int, string>; Fuga = (x, y) =>; (x + y).ToString();
*{var t = 1;var v = 2;return (t + v).ToString();});
もしくはこう書く
何かしらの処理
*});
*for (var i = 1; i <;= 10000; ++i)*{
至極単純にこうやればよいのでは？
*{for (var i = 1; i <;= 10000; ++i){textBox1.Text = i.ToString();}});
非同期処理にしてやれば全てうまくいくはず
*{textBox1.Text = i.ToString();}));
Invokeメソッド内ではUIスレッドに戻してくれる
巨大なファイルを読み込むつもりならここはあえてawaitキーワードを外すべき
UIスレッドで処理をさせると固まってしまうのでスレッドプールに処理を投げる
Task.Runメソッド内でawait を使用しているので、asyncキーワードを付ける
*Task.Run(async () =>;
*while (true)*{
無限ループ
*{result = new byte[file.Length];//バイナリデータを非同期的に読み込む//全部を読み込み終わるまで待っとくで～await file.ReadAsync(result, 0, (int)file.Length);}
ファイルオープン
バイナリデータを非同期的に読み込む
全部を読み込み終わるまで待っとくで～
*await file.ReadAsync(result, 0, (int)file.Length);
*{textBox1.Text = builder.ToString();}));
UIを更新できるのはUIスレッドだけなので Invoke でUIスレッドに一旦処理を戻してやる
タイマーイベントの代わり
1秒待つ
*await Task.Delay(1000);

*if (IsPlaying() == false &amp;&amp; audioSource.clip != BGM_Data.BGMList[keyname])
シーン再読み込みのために消さない
*{audioSource = audioObject.AddComponent<;AudioSource>;();audioSource.clip = SE_Data.SEList[keyname];audioSource.volume = SE_Data.SEVolumeList[keyname] * PlayerPrefs.GetFloat("SEVolume", 1);}*/
AudioSource audioSource=null;

Unity Editor上
*var filepath = Path.Combine(@"C:\", filename);
それ以外
*var filepath = Path.Combine(UnityEngine.Application.persistentDataPath, filename));

*ws.IndentChars = "  ";
&lt;- インデントの空白数ではなくて、1つ分のインデントとして使う文字列を直接指定します。

*).SetValidateNotifyError(x =<; String.IsNullOrEmpty(x) ? "何か入力してください。" : null)
バリデーション.

*1000
最大高

なんか
*}

using GalaSoft.MvvmLight;  コメントアウト
using CommonServiceLocator;  追加
*using GalaSoft.MvvmLight.Ioc;

ログ情報を生成します。
*NLog.LogEventInfo info = new NLog.LogEventInfo(NLog.LogLevel.Info, logger.Name, message);
ロガーの型に NLoggerExtensions を指定します。
*logger.Log(typeof(NLoggerExtensions), info);
ログ情報を生成します。
*NLog.LogEventInfo info = new NLog.LogEventInfo(NLog.LogLevel.Info, logger.Name, message);
ロガーの型に NLoggerExtensions を指定します。
*logger.Log(typeof(NLoggerExtensions), info);
呼び出し元情報を設定します。
*info.SetCallerInfo(callerClassName, callerMemberName, callerFilePath, callerLineNumber);
呼び出し元情報を設定します。
*info.SetCallerInfo(callerClassName, callerMemberName, callerFilePath, callerLineNumber);

*int[] current = { 9, 9, 11, 7, 3, 2, 1, 2 };
現在の数: 9人 -&gt; 2人 (8種類で合計44人)
繰り返し数を引数から取得(なければ0)
*int iteration = 0;
*int[] current = { 9, 9, 11, 7, 3, 2, 1, 2 };
現在の数: 9人 -&gt; 2人 (8種類で合計44人)
44人分の空配列
*int[] r = new int[current.Sum()];
9人 -&gt; 2人 で8回ループして44人の現在保持数を設定
*int startRemain = 9;
*for (int i = 0; i <; iteration; i++)*{
ガシャを引く。。。
対象内の誰かだったら☆数を++
*int tmp = rand.Next(103);
結果発表♪
*int remain = 0;
*if (tmp <; 10)*{
☆10に届いてない分だけ表示

*await Task.Delay(10);
10ms待機する

*array[h*wLength + w];
場合によっては[(h-1)*wLength + (w-1)]

なんかいろいろな処理
*}
なんかいろいろな処理
*}
*if (GameObject.Find("OnlyUIRenderingCamera"))*{
シーンをロードするたびに新しいカメラを生成
*{//カメラ自動生成camera_G = new GameObject("OnlyUIRenderingCamera");faceCamera = camera_G.AddComponent<;Camera>;();faceCamera.clearFlags = CameraClearFlags.Depth;faceCamera.cullingMask = (1 <;<; LayerMask.NameToLayer("UI"));//キャンバス生成＆設定GameObject canvas_G = new GameObject("FaceCanvas");faceCanvas = canvas_G.AddComponent<;Canvas>;();canvas_G.AddComponent<;CanvasRenderer>;();//キャンバスのポジションを調整Vector3 canvasPosition = canvas_G.transform.position;canvasPosition.x = 0;canvasPosition.y = 0;canvasPosition.z = 0.1f;canvas_G.transform.localPosition = canvasPosition;//レンダリングをfaceCameraにfaceCanvas.renderMode = RenderMode.ScreenSpaceCamera;faceCanvas.worldCamera = faceCamera;//パネル生成＆設定GameObject panel_G = new GameObject("FacePanel");facePanel = panel_G.AddComponent<;Image>;();Color tmpColor = facePanel.color;tmpColor.a = 0f;facePanel.color = tmpColor;//パネルをキャンバスの子に設定panel_G.transform.parent = canvas_G.transform;//パネルのポジションを正面に調整Vector3 panelPosition = panel_G.transform.localPosition;panelPosition.x = 0;panelPosition.y = 0;panelPosition.z = 0;panel_G.transform.localPosition = panelPosition;//キャンバスをカメラの子に設定canvas_G.transform.parent = faceCamera.transform;//Layerを変更canvas_G.layer = LayerMask.NameToLayer("UI");panel_G.layer = LayerMask.NameToLayer("UI");}
Start is called before the first frame update
カメラ自動生成
*camera_G = new GameObject("OnlyUIRenderingCamera");
キャンバス生成＆設定
*GameObject canvas_G = new GameObject("FaceCanvas");
*Vector3 canvasPosition = canvas_G.transform.position;*canvasPosition.x = 0;
キャンバスのポジションを調整
レンダリングをfaceCameraに
*faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
パネル生成＆設定
*GameObject panel_G = new GameObject("FacePanel");
*panel_G.transform.parent = canvas_G.transform;*//パネルのポジションを正面に調整
パネルをキャンバスの子に設定
*Vector3 panelPosition = panel_G.transform.localPosition;*panelPosition.x = 0;
パネルのポジションを正面に調整
*canvas_G.transform.parent = faceCamera.transform;*//Layerを変更
キャンバスをカメラの子に設定
Layerを変更
*canvas_G.layer = LayerMask.NameToLayer("UI");
Fixed Timestepを固定
*Time.fixedDeltaTime = FIXED_UPDATE_DELTATIME;
*if (Input.anyKey == false)*{
キー押してない間はreturn
*if (Input.GetKeyDown(KeyCode.O) &amp;&amp; panelColor.a == 0)*{
テスト用　フェードアウト
スタートの時間記録
*startTime = Time.time;
スタートの時間記録
*startTime = Time.time;
フェード中の時間、Alphaを確認
*print(Time.time - startTime);
フェード中の時間、Alphaを確認
*print(Time.time - startTime);
Fixed Timestepを固定
*Time.fixedDeltaTime = FIXED_UPDATE_DELTATIME;
*if (GameObject.Find("OnlyUIRenderingCamera"))*{
シーンをロードするたびに新しいカメラを生成

*updateScore("false");
発火

*await next(message, ct);
ハンドラ本体の処理を待機
後処理
*logger.LogDebug("メッセージを送信しました");
任意のMessageHandlerの実行前後に、AsyncL
*options.AddGlobalMessageHandlerFilter(typeof(AsyncLoggingFilter<;string>;), -10000 /*優先順位*/);

*if (GameObject.Find("OnlyUIRenderingCamera"))*{
シーンをロードするたびに新しいカメラを生成
*{//カメラ自動生成camera_G = new GameObject("OnlyUIRenderingCamera");faceCamera = camera_G.AddComponent<;Camera>;();faceCamera.clearFlags = CameraClearFlags.Depth;faceCamera.cullingMask = (1 <;<; LayerMask.NameToLayer("UI"));//キャンバス生成＆設定GameObject canvas_G = new GameObject("FaceCanvas");faceCanvas = canvas_G.AddComponent<;Canvas>;();canvas_G.AddComponent<;CanvasRenderer>;();//キャンバスのポジションを調整Vector3 canvasPosition = canvas_G.transform.position;canvasPosition.x = 0;canvasPosition.y = 0;canvasPosition.z = 0.1f;canvas_G.transform.localPosition = canvasPosition;//レンダリングをfaceCameraにfaceCanvas.renderMode = RenderMode.ScreenSpaceCamera;faceCanvas.worldCamera = faceCamera;//パネル生成＆設定GameObject panel_G = new GameObject("FacePanel");facePanel = panel_G.AddComponent<;Image>;();Color tmpColor = facePanel.color;tmpColor.a = 0f;facePanel.color = tmpColor;//パネルをキャンバスの子に設定panel_G.transform.parent = canvas_G.transform;//パネルのポジションを正面に調整Vector3 panelPosition = panel_G.transform.localPosition;panelPosition.x = 0;panelPosition.y = 0;panelPosition.z = 0;panel_G.transform.localPosition = panelPosition;//キャンバスをカメラの子に設定canvas_G.transform.parent = faceCamera.transform;//Layerを変更canvas_G.layer = LayerMask.NameToLayer("UI");panel_G.layer = LayerMask.NameToLayer("UI");}
Start is called before the first frame update
カメラ自動生成
*camera_G = new GameObject("OnlyUIRenderingCamera");
キャンバス生成＆設定
*GameObject canvas_G = new GameObject("FaceCanvas");
*Vector3 canvasPosition = canvas_G.transform.position;*canvasPosition.x = 0;
キャンバスのポジションを調整
レンダリングをfaceCameraに
*faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
パネル生成＆設定
*GameObject panel_G = new GameObject("FacePanel");
*panel_G.transform.parent = canvas_G.transform;*//パネルのポジションを正面に調整
パネルをキャンバスの子に設定
*Vector3 panelPosition = panel_G.transform.localPosition;*panelPosition.x = 0;
パネルのポジションを正面に調整
*canvas_G.transform.parent = faceCamera.transform;*//Layerを変更
キャンバスをカメラの子に設定
Layerを変更
*canvas_G.layer = LayerMask.NameToLayer("UI");
Fixed Timestepを固定
*Time.fixedDeltaTime = FIXED_UPDATE_DELTATIME;
*if (Input.anyKey == false)*{
キー押してない間はreturn
*if (Input.GetKeyDown(KeyCode.O) &amp;&amp; panelColor.a == 0)*{
テスト用　フェードアウト
スタートの時間記録
*startTime = Time.time;
スタートの時間記録
*startTime = Time.time;
フェード中の時間、Alphaを確認
*print(Time.time - startTime);
フェード中の時間、Alphaを確認
*print(Time.time - startTime);

*SetLocalGravity ();
重力をAddForceでかけるメソッドを呼ぶ。FixedUpdateが好ましい。

*IPEndPoint remoteEP = null;
任意の送信元からのデータを受信
後片付けの方法はあとで考える。（呼ばれない）
*_TermH264Decoder();
*{byte[] data = Encoding.ASCII.GetBytes(cmd);this.udpForCmd.Send(data, data.Length, "192.168.10.1", 8889);}
コマンド送信
*{SetupTello();this.txtRet.Text = "";this.btnCmd.Enabled = false;sendCmd("command");}
開始ボタン
*{this.txtRet.Text = "";this.btnCmd.Enabled = false;sendCmd(this.txtCmd.Text);}
コマンド送信ボタン押下

*time = 0;
timeを0にする。

↓この角括弧が何やってるか分けわかんなければ消してくれだぜ。
*[assembly: CLSCompliant(true)]
↓リソースファイルを使おうとしている。
リソースファイルの作り方は Qiita で別の人が書いてるだろ、勝手に調べろだぜ。
*using Grayscale.ResourcePracticeWithConsole.Properties;
使うリソースを 英語（米国）を使う。
*Resources.Culture = new CultureInfo("en-US");
↓C#デフォルトのエラーメッセージや、画面に効いてくる。
*Thread.CurrentThread.CurrentCulture = Resources.Culture;
↓英語（米国）テーブルの HelloWorld キーに対応した値が表示される。
*Trace.WriteLine(Resources.HelloWorld);
使うリソースを 日本 に変える。
*Resources.Culture = new CultureInfo("ja-JP");
↓日本テーブルの HelloWorld キーに対応した値が表示される。
*Trace.WriteLine(Resources.HelloWorld);
15秒待つ。
*Thread.Sleep(15000);
日付。
*var dateValue = new DateTime(2019, 2, 16, 13, 57, 0);
*{(new CultureInfo("ja-JP"), "Tokyo Standard Time"),(new CultureInfo("en-US"), "GMT Standard Time"),(new CultureInfo("fr-FR"), "Romance Standard Time"),(new CultureInfo("de-DE"), "Romance Standard Time"),};
System.ValueTuple

*while (true) {*numbers = Console.ReadLine().Split(' ');
game loop

30％の確率で起こるイベント
*}

*else Console.Error.Write(map[x, y]);
-1でなければプレイヤーID(0以上)を出力。
キャラクターの座標を登録・記憶しておくための入れ物。
Main 関数が受け取る標準入力の情報を格納するための構造体のようなもの。
Player インスタンスの各メソッドの引数は標準入力とのやり取りを意識せず、この構造体を期待できる。
*class Position
*{//return "{X0:" + X0 + ", Y0:" + Y0 + ", X1:" + X1 + ", Y1:" + Y1 + "}";return String.Format("{{X0:{0}, Y0:{1}, X1:{2}, Y1:{3}}}", X0, Y0, X1, Y1);}
デバッグなどで出力される際のフォーマットを制御する。
*return String.Format("{{X0:{0}, Y0:{1}, X1:{2}, Y1:{3}}}", X0, Y0, X1, Y1);
return "{X0:" + X0 + ", Y0:" + Y0 + ", X1:" + X1 + ", Y1:" + Y1 + "}";

*{var w = new Window01();w.Show();}
Window○○ は、自前のWindowクラス。
以下略
*,,,
Window○○ は、自前のWindowクラス。
*private void OpenWindow<;T>;() Where T : Window, new()

*success();
成功のメソッド

*string[] strings = new string[] { "a", "b" };
参照型 B を参照型 A に代入できるなら、配列 B[] も A[] に代入できる。
代入後の配列インスタンスは同一参照
*Assert.IsTrue(Object.ReferenceEquals(objects, strings));
ただし、要素に別の派生型の値を設定しようとすると実行時例外が発生する。
配列には値を返すだけでなく受け取る役目もあるのに、
丸ごと（本来適用すべきでない受け取り操作を含めて）共変を許してしまったことの弊害である。
*try
「配列と互換性のない型の要素にアクセスしようとしました」
*Console.WriteLine(ex.ToString());
*objects = new int[] { 0, 1 };
配列の共変性は、不変である値型には適用されない。
共変性のサポートがこの代入を可能にする。
*BaseGetter returnsDerived = this.GetDerived;
*{// :}
EventArgs 型の引数を受け取るイベントハンドラ
KeyDown が期待するイベント引数型は KeyEventArgs だが、
反変性のサポートによって EventArgs 型引数のイベントハンドラも登録できる。
*this.KeyDown += this.EventArgsHandler;
これは .NET 3.5 でもできた。
*IEnumerable<;Derived>; derivedEnumerable = new List<;Derived>;();
IEnumerable&lt;out T&gt; のように共変であることを表す out キーワードで修飾されるようになった。
列挙だけなら Derived 型オブジェクトを Base 型として扱っても問題ない。
*IEnumerable<;Base>; baseEnumerable = derivedEnumerable;
設定もできる場合、共変は許されない。
（List&lt;Base&gt; は Derived 以外の派生型オブジェクトを受け取ることもあるから）
*/* コンパイルエラー「変換できません」
Action&lt;in T&gt; のように、反変であることを表す in キーワードで修飾されるようになった。
基底型の引数に派生型のオブジェクトが渡されても問題ない。
*Action<;Derived>; derivedAction = baseAction;
引数を渡す側は、派生型を渡してそれが基底型として扱われても不都合はないはず。
*derivedAction.Invoke(new Derived());

バカみたいに失敗するテスト
*[Test]
バカみたいに成功するテスト
*[Test]

*FilePath = AppDomain.CurrentDomain.BaseDirectory.TrimEnd('\\');
EXEを実行したカレントディレクトリ (ショートカット等でカレントディレクトリが変わるのでこの方式で)

HWindowの名前を付ける
*HTuple hWin1;
画像を読み込む
*HObject img;
HWindowに画像を表示する
*Op.DispImage(img, hWin1);

*{#region lifecyclepublic void OnEnable(){PhotonNetwork.NetworkingClient.EventReceived += OnEvent;}public void OnDisable(){PhotonNetwork.NetworkingClient.EventReceived -= OnEvent;}#endregion// ①// eventCode. 0~199。0は特殊な扱いのため1から始めるpublic enum RaiseEventType : byte{SampleEvent = 1,}// ②public Action<;string>; OnSampleEvent;// ③public void OnEvent(EventData photonEvent){var type = (RaiseEventType) Enum.ToObject(typeof(RaiseEventType), photonEvent.Code);Debug.Log("RaiseEvent Received. Type = " + type);switch (type){case RaiseEventType.SampleEvent:OnSampleEvent?.Invoke(photonEvent.CustomData as string);break;default:return;}}}
RaiseEventReceiver
*{SampleEvent = 1,}
eventCode. 0~199。0は特殊な扱いのため1から始める
*{var type = (RaiseEventType) Enum.ToObject(typeof(RaiseEventType), photonEvent.Code);Debug.Log("RaiseEvent Received. Type = " + type);switch (type){case RaiseEventType.SampleEvent:OnSampleEvent?.Invoke(photonEvent.CustomData as string);break;default:return;}}
③
*{// ④public static void SendSampleEvent(string message){var raiseEventOptions = new RaiseEventOptions{Receivers = ReceiverGroup.All,CachingOption = EventCaching.AddToRoomCache,};PhotonNetwork.RaiseEvent((byte) RER.RaiseEventType.SampleEvent, message, raiseEventOptions, SendOptions.SendReliable);}}
RaiseEventSender
*{var raiseEventOptions = new RaiseEventOptions{Receivers = ReceiverGroup.All,CachingOption = EventCaching.AddToRoomCache,};PhotonNetwork.RaiseEvent((byte) RER.RaiseEventType.SampleEvent, message, raiseEventOptions, SendOptions.SendReliable);}
④
*{#region lifecyclepublic void OnEnable(){PhotonNetwork.NetworkingClient.EventReceived += OnEvent;}public void OnDisable(){PhotonNetwork.NetworkingClient.EventReceived -= OnEvent;}#endregion// ①// eventCode. 0~199。0は特殊な扱いのため1から始めるpublic enum RaiseEventType : byte{SampleEvent = 1,ChangeColor,}// ②public Action<;string>; OnSampleEvent;public Action<;PunSampleManager.CubeColor>; OnChangeColor;// ③public void OnEvent(EventData photonEvent){var type = (RaiseEventType) Enum.ToObject(typeof(RaiseEventType), photonEvent.Code);Debug.Log("RaiseEvent Received. Type = " + type);switch (type){case RaiseEventType.ChangeColor:var color = (PunSampleManager.CubeColor) Enum.ToObject(typeof(PunSampleManager.CubeColor), photonEvent.CustomData);OnChangeColor?.Invoke(color);break;case RaiseEventType.SampleEvent:default:return;}}}
RaiseEventReceiver
*{SampleEvent = 1,ChangeColor,}
eventCode. 0~199。0は特殊な扱いのため1から始める
*{var type = (RaiseEventType) Enum.ToObject(typeof(RaiseEventType), photonEvent.Code);Debug.Log("RaiseEvent Received. Type = " + type);switch (type){case RaiseEventType.ChangeColor:var color = (PunSampleManager.CubeColor) Enum.ToObject(typeof(PunSampleManager.CubeColor), photonEvent.CustomData);OnChangeColor?.Invoke(color);break;case RaiseEventType.SampleEvent:default:return;}}
③
*{// ④public static void SendSampleEvent(string message){var raiseEventOptions = new RaiseEventOptions{Receivers = ReceiverGroup.All,CachingOption = EventCaching.AddToRoomCache,};PhotonNetwork.RaiseEvent((byte) RER.RaiseEventType.SampleEvent, message, raiseEventOptions, SendOptions.SendReliable);}public static void ChangeColor(PunSampleManager.CubeColor cubeColor){var content = (int) cubeColor;var raiseEventOptions = new RaiseEventOptions{Receivers = ReceiverGroup.All,CachingOption = EventCaching.AddToRoomCache,};PhotonNetwork.RaiseEvent((byte) RER.RaiseEventType.ChangeColor, content, raiseEventOptions, SendOptions.SendReliable);}}
RaiseEventSender
*{var raiseEventOptions = new RaiseEventOptions{Receivers = ReceiverGroup.All,CachingOption = EventCaching.AddToRoomCache,};PhotonNetwork.RaiseEvent((byte) RER.RaiseEventType.SampleEvent, message, raiseEventOptions, SendOptions.SendReliable);}
④
*{RER.Instance.OnChangeColor += OnChangeColor;}
Start is called before the first frame update
*{RER.Instance.OnSpinCube += () =>; { StartCoroutine(SpinCube()); };}
Start is called before the first frame update

*this[index] = new T();
初期値
*{for (int y = 1; y <;= this.YSize; y++){for (int x = 1; x <;= this.XSize; x++){yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する
*{for (int index = ToIndex(x, y); IsOnBoard(index); index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む
(x,y)から右(水平)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Horizontal(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Virtical(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantR(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantL(int x, int y)

ThreadExceptionイベント・ハンドラの登録
*Application.ThreadException += new
ほかの処理
*}
*{// 第二引数にエラーメッセージShowErrorMessage(e.Exception, "ApplicationThreadException");}
未処理例外をキャッチするイベント・ハンドラ
第二引数にエラーメッセージ
*ShowErrorMessage(e.Exception, "ApplicationThreadException");
*{// ダイアログを自動的に閉じるようにしたいので以下の処理を追記var w = new Form() { Size = new Size(0, 0) };// ここでは約5秒後に閉じるように設定Task.Delay(TimeSpan.FromSeconds(5)).ContinueWith((t) =>; w.Close(), TaskScheduler.FromCurrentSynchronizationContext());// ダイアログに表示させるメッセージを記述MessageBox.Show(w, "エラーが発生しました。約5秒後にアプリケーションの再起動を行います。\n\nしばらくお待ちください。\n\n\n", "Error : " + extraMessage);// エラーダイアログが閉じた後に実行する処理（アプリの終了処理を書いたり）Application.Exit();}
ユーザー・フレンドリなダイアログを表示するメソッド
*var w = new Form() { Size = new Size(0, 0) };
ダイアログを自動的に閉じるようにしたいので以下の処理を追記
ここでは約5秒後に閉じるように設定
*Task.Delay(TimeSpan.FromSeconds(5))
ダイアログに表示させるメッセージを記述
*MessageBox.Show(w
エラーダイアログが閉じた後に実行する処理（アプリの終了処理を書いたり）
*Application.Exit();

～省略～
キャンバス生成＆設定
*GameObject canvas_G = new GameObject("FaceCanvas");
レンダリングをメインカメラに
*faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
パネル生成＆設定
*GameObject panel_G = new GameObject("FacePanel");
*panel_G.transform.parent = canvas_G.transform;*//パネルのポジションを正面に調整
パネルをキャンバスの子に設定
*Vector3 panelPosition = panel_G.transform.localPosition;*panelPosition.x = 0;
パネルのポジションを正面に調整
*{//キャンバス生成＆設定GameObject canvas_G = new GameObject("FaceCanvas");faceCanvas = canvas_G.AddComponent<;Canvas>;();canvas_G.AddComponent<;CanvasScaler>;();canvas_G.AddComponent<;GraphicRaycaster>;();//レンダリングをメインカメラにfaceCanvas.renderMode = RenderMode.ScreenSpaceCamera;faceCanvas.worldCamera = FindObjectOfType<;Camera>;();//パネル生成＆設定GameObject panel_G = new GameObject("FacePanel");facePanel = panel_G.AddComponent<;Image>;();Color tmpColor = facePanel.color;tmpColor.a = 0f;facePanel.color = tmpColor;//パネルをキャンバスの子に設定panel_G.transform.parent = canvas_G.transform;//パネルのポジションを正面に調整Vector3 panelPosition = panel_G.transform.localPosition;panelPosition.x = 0;panelPosition.y = 0;panel_G.transform.localPosition = panelPosition;}
Start is called before the first frame update
キャンバス生成＆設定
*GameObject canvas_G = new GameObject("FaceCanvas");
レンダリングをメインカメラに
*faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
パネル生成＆設定
*GameObject panel_G = new GameObject("FacePanel");
*panel_G.transform.parent = canvas_G.transform;*//パネルのポジションを正面に調整
パネルをキャンバスの子に設定
*Vector3 panelPosition = panel_G.transform.localPosition;*panelPosition.x = 0;
パネルのポジションを正面に調整
*if (Input.anyKey == false)*{
キー押してない間はreturn
*if (Input.GetKeyDown(KeyCode.O) &amp;&amp; panelColor.a == 0)*{
テスト用　フェードアウト
*if (Input.GetKeyDown(KeyCode.I) &amp;&amp; panelColor.a == 1)*{
テスト用　フェードイン

この初期化だと、配列の要素番号が一次元、二次元ともに0からスタートする。
*object[,] array2D = new object[100,100];
*int[] lower = { 1, 1 };
二次元配列の各次元の最小要素番号
*int[] length = { rowIdx, colIdx };
二次元配列の各次元の要素数

*x = radius *Mathf.Sin(Time.time * speed);
三角関数による動きの設定。
*transform.position = new Vector3(x+transform.position.x,transform.position.y,transform.position.z);*}
X座標のみ三角関数による動きの設定を反映
*{}
Start is called before the first frame update
*{transform.position = new Vector3(Mathf.PingPong(Time.time,3),transform.position.y,transform.position.z);}
Update is called once per frame

*{for (nIndexHeight = 0; nIndexHeight <; nHeightSize; nIndexHeight++){for (nIndexWidth = 0; nIndexWidth <; nWidthSize; nIndexWidth++){// バイト型のポインタで、画像のPixelデータのアドレスを取得しています。byte* pPixel = (byte*)bitmapData.Scan0 + nIndexHeight * bitmapData.Stride + nIndexWidth * 4;double dCalB = 0.0;double dCalG = 0.0;double dCalR = 0.0;double dCalA = 0.0;int nIndexWidthMask;int nIndexHightMask;int nFilter = 0;while (nFilter <; m_nFilterMax){for (nIndexHightMask = 0; nIndexHightMask <; nMasksize; nIndexHightMask++){for (nIndexWidthMask = 0; nIndexWidthMask <; nMasksize; nIndexWidthMask++){if (nIndexWidth + nIndexWidthMask >; 0 &amp;&amp;nIndexWidth + nIndexWidthMask <; nWidthSize &amp;&amp;nIndexHeight + nIndexHightMask >; 0 &amp;&amp;nIndexHeight + nIndexHightMask <; nHeightSize){// フィルタ処理のために、バイト型のポインタで、画像のPixelデータのアドレスを取得しています。byte* pPixel2 = (byte*)bitmapData.Scan0 + (nIndexHeight + nIndexHightMask) * bitmapData.Stride + (nIndexWidth + nIndexWidthMask) * 4;dCalB += pPixel2[0] * m_dMask[nIndexWidthMask, nIndexHightMask];dCalG += pPixel2[1] * m_dMask[nIndexWidthMask, nIndexHightMask];dCalR += pPixel2[2] * m_dMask[nIndexWidthMask, nIndexHightMask];dCalA += pPixel2[3] * m_dMask[nIndexWidthMask, nIndexHightMask];}}}nFilter++;}// ポインタなので、SetPixelのようなメソッドを呼ばなくて、そのままフィルタ処理後の値を設定できます。pPixel[0] = DoubleToByte(dCalB);pPixel[1] = DoubleToByte(dCalG);pPixel[2] = DoubleToByte(dCalR);pPixel[3] = DoubleToByte(dCalA);}}m_bitmapImageFilter.UnlockBits(bitmapData);}
unsafeで囲みます
バイト型のポインタで、画像のPixelデータのアドレスを取得しています。
*byte* pPixel = (byte*)bitmapData.Scan0 + nIndexHeight * bitmapData.Stride + nIndexWidth * 4;
フィルタ処理のために、バイト型のポインタで、画像のPixelデータのアドレスを取得しています。
*byte* pPixel2 = (byte*)bitmapData.Scan0 + (nIndexHeight + nIndexHightMask) * bitmapData.Stride + (nIndexWidth + nIndexWidthMask) * 4;
ポインタなので、SetPixelのようなメソッドを呼ばなくて、そのままフィルタ処理後の値を設定できます。
*pPixel[0] = DoubleToByte(dCalB);
Pixelデータの取得はフィルタ処理中でなく、事前に取得しています。
ここでGetPixelするとオーバーヘッドが凄すぎて断念しました...
*byte bytePixel2B = m_pixelData[nIndexWidth + nIndexWidthMask, nIndexHeight + nIndexHightMask, (int)Pixel.B];
フィルタ処理後に、SetPixelで画像のPixelデータを設定しています。
*m_bitmapImageFilter.SetPixel(nIndexWidth, nIndexHeight, Color.FromArgb(bytePixelA, bytePixelR, bytePixelG, bytePixelB));
ポインタなどの処理
*}

*{string Explain();}
各クラスが自分自身の説明をするための共通のインターフェース
*class WithSoupRamen : IExplainer {private string Name;private Noodles Noodles;private Soup Soup;private Topping Topping;public WithSoupRamen(string name, Noodles noodles, Soup soup, Topping topping) {Name = name;Noodles = noodles;Soup = soup;Topping = topping;}public string Explain() {return Name + "の\n" + Noodles.Explain() + "\n" + Soup.Explain() + "\n" + Topping.Explain();}}
汁あり
*class Noodles : IExplainer {private string WidthType;public Noodles(string widthType) {WidthType = widthType;}public string Explain() {return "麺の太さは" + WidthType + "です。";}}
麺
*class Soup : IExplainer {private Fond Fond;private Sauce Sauce;private Oil Oil;public Soup(Fond fond, Sauce sauce, Oil oil) {Fond = fond;Sauce = sauce;Oil = oil;}public string Explain() {return Fond.Explain() + "\n" + Sauce.Explain() + "\n" + Oil.Explain();}}
スープ
*class Fond : IExplainer {private List<;string>; Ingredients = new List<;string>;();public Fond(string ingredient) {AddFond(ingredient);}public void AddFond(string ingredient) {Ingredients.Add(ingredient);}public string Explain() {return "出汁は" + String.Join(", ", Ingredients) + "です。";}}
出汁
*class Sauce : IExplainer {private List<;string>; Seasonings = new List<;string>;();public Sauce(string seadoning) {AddSauce(seadoning);}public void AddSauce(string seadoning) {Seasonings.Add(seadoning);}public string Explain() {return "タレは" + String.Join(", ", Seasonings) + "です。";}}
タレ
*class Oil : IExplainer {private List<;string>; Oiltypes = new List<;string>;();public Oil(string oiltype) {AddOil(oiltype);}public void AddOil(string oiltype) {Oiltypes.Add(oiltype);}public string Explain() {return "香味油は" + String.Join(", ", Oiltypes) + "です。";}}
香味油
*class Topping : IExplainer {private List<;string>; Toppings = new List<;string>;();public Topping(string topping) {AddTopping(topping);}public void AddTopping(string topping) {Toppings.Add(topping);}public string Explain() {return "具は" + String.Join(", ", Toppings) + "です。";}}
具

*protected readonly long chunkStart;
chunk head + 8 (type + size)

*{services.Configure<;CookiePolicyOptions>;(options =>;{// This lambda determines whether user consent for non-essential cookies is needed for a given request.options.CheckConsentNeeded = context =>; true;options.MinimumSameSitePolicy = SameSiteMode.None;});services.AddLocalization(options =>; options.ResourcesPath = "Resources");services.AddMvc().AddViewLocalization(LanguageViewLocationExpanderFormat.Suffix).SetCompatibilityVersion(CompatibilityVersion.Latest);}
This method gets called by the runtime. Use this method to add services to the container.
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseExceptionHandler("/Home/Error");// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.app.UseHsts();}var supportedCultures = new[]{new CultureInfo("ja-JP"),new CultureInfo("en-US"),};app.UseRequestLocalization(new RequestLocalizationOptions{DefaultRequestCulture = new RequestCulture("ja-JP"),// Formatting numbers, dates, etc.SupportedCultures = supportedCultures,// UI strings that we have localized.SupportedUICultures = supportedCultures});app.UseHttpsRedirection();app.UseStaticFiles();app.UseCookiePolicy();app.UseMvc(routes =>;{routes.MapRoute(name: "default",template: "{controller=Home}/{action=Index}/{id?}");});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

間引き 例：(ret, digits) = ("1010", 3) =&gt; "010"
*return ret.Substring(ret.Length - digits.Value, digits.Value);
0埋め 例：(ret, digits) = ("101", 5) =&gt; "00101"
*return ret.PadLeft(digits.Value, '0');

有効桁数
*public const int SIGNIFICANT_DIGIT = 16;
小数点も取得する数値を表すPattern
*private const string DECIMAL = @"[\+\-]?\d+(?:\.\d+)?";
*{string result = "";// 対象文字列の半角スペースを削除result = Regex.Replace(calcStr, @"\s", "");// +-の符号重複を整理result = OperatorOrganize(result);// 余分な括弧を整理するresult = BracketsOrganize(result);// 関数の計算result = ProcFunction(result);// ()内を計算result = CalculationBrackets(result);// カッコが全て計算された後の通常計算result = NormalCalculation(result);// 先頭の + は削除するresult = Regex.Replace(result, @"^\+", "");return result;}
文字列を計算して結果を返す
対象文字列の半角スペースを削除
*result = Regex.Replace(calcStr, @"\s", "");
+-の符号重複を整理
*result = OperatorOrganize(result);
余分な括弧を整理する
*result = BracketsOrganize(result);
関数の計算
*result = ProcFunction(result);
()内を計算
*result = CalculationBrackets(result);
カッコが全て計算された後の通常計算
*result = NormalCalculation(result);
先頭の + は削除する
*result = Regex.Replace(result, @"^\+", "");
*{// + または - が２個連続している箇所を検出string pattern = @"[\+\-]{2}";return CalculationBase(calcStr, pattern, (baseMatch) =>;{string result;// ２つ続いている演算子を取得Match match = Regex.Match(baseMatch.Value, @"([\+\-])([\+\-])");result = (match.Result("$1") == match.Result("$2")) ? "+" : "-";return result;});}
+ または - 演算子の重複を解消する
*string pattern = @"[\+\-]{2}";
+ または - が２個連続している箇所を検出
２つ続いている演算子を取得
*Match match = Regex.Match(baseMatch.Value, @"([\+\-])([\+\-])");
*{string d = @"[\+\-\*\/]|" + DECIMAL;string pattern = @"\({2}((?:" + d + @"|\((?:" + d + @")+\))+)\){2}";return CalculationBase(calcStr, pattern, (baseMatch) =>;{string result = baseMatch.Result("($1)");return result;});}
余計な括弧をまとめる
*{// Sin() や Cos() など関数の形に一致string d = @"[\+\-\*\/]|" + DECIMAL;string d1 = d + @"\,?";string d2 = @"\((?:" + d + @")+\)\,?";string f = @"[a-zA-Z_]\w+";string pattern = "(" + f + @")\(((?:" + d1 + "|" + d2 + @")*)\)";return CalculationBase(calcStr, pattern, (baseMatch) =>;{// 後ろで正規表現を使用するので、$1が消える前に関数名を取得しておくstring func = baseMatch.Result("$1");// 引数をカンマ区切りで取得し、それぞれを計算するstring[] args = baseMatch.Result("$2").Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);for (int i = 0; i <; args.Length; i++){args[i] = CalculationBrackets(args[i]);args[i] = NormalCalculation(args[i]);}// 関数呼び出しstring result = StringCalculationFunctions.InvokeMethod(func, args);// 小数点第n位まで取得し、後ろの余分な0を切り捨てるresult = result.ToDouble().ToStringWithDigit(SIGNIFICANT_DIGIT);return result;});}
関数の計算
Sin() や Cos() など関数の形に一致
*string d = @"[\+\-\*\/]|" + DECIMAL;
後ろで正規表現を使用するので、$1が消える前に関数名を取得しておく
*string func = baseMatch.Result("$1");
*string[] args = baseMatch.Result("$2").Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
引数をカンマ区切りで取得し、それぞれを計算する
関数呼び出し
*string result = StringCalculationFunctions.InvokeMethod(func, args);
小数点第n位まで取得し、後ろの余分な0を切り捨てる
*result = result.ToDouble().ToStringWithDigit(SIGNIFICANT_DIGIT);
*{// 一番内側の括弧に一致string d = DECIMAL;string pattern = @"\(((?:[\-\+\*\/]|" + d + @")+)\)";return CalculationBase(calcStr, pattern, (baseMatch) =>;{string result = baseMatch.Result("$1");result = OperatorOrganize(result);result = NormalCalculation(result);return result;});}
カッコ付きの箇所の計算
一番内側の括弧に一致
*string d = DECIMAL;
*{// 掛け算と割り算string result = MultiDiv(calcStr);// 足し算と引き算result = AddSub(result);return result;}
カッコなしの通常の計算を行う
掛け算と割り算
*string result = MultiDiv(calcStr);
足し算と引き算
*result = AddSub(result);
*{// 掛け算、または割り算に一致string d = DECIMAL;string pattern = d + @"\*" + d + "|" + d + @"\/" + d;return CalculationBase(calcStr, pattern, (baseMatch) =>;{double nResult = 0;// 演算子で分割し、計算Match match = Regex.Match(baseMatch.Value, @"\*|\/");string l = match.Result("$`");string r = match.Result("$'");if (match.Value == "*"){nResult = (l.ToDouble() * r.ToDouble());}else if (match.Value == "/"){nResult = (l.ToDouble() / r.ToDouble());}else{nResult = match.Value.ToDouble();}// 小数点第n位まで取得し、後ろの余分な0を切り捨てるstring result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);// 計算結果が + の場合、前方の文字と結合する際に符号なしでくっついてしまう※ので、符号を追加// ※この関数の結果が10、前方の文字が123だとした場合、123 10 =>; 12310 になってしまう。// 　+ を記述しておけば、 123 +10 =>; 123+10 と正しい数式の形に戻せる。string prefix = nResult >;= 0 ? "+" : "";return prefix + result;});}
* または / の計算を行う
掛け算、または割り算に一致
*string d = DECIMAL;
演算子で分割し、計算
*Match match = Regex.Match(baseMatch.Value, @"\*|\/");
小数点第n位まで取得し、後ろの余分な0を切り捨てる
*string result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);
計算結果が + の場合、前方の文字と結合する際に符号なしでくっついてしまう※ので、符号を追加
※この関数の結果が10、前方の文字が123だとした場合、123 10 =&gt; 12310 になってしまう。
+ を記述しておけば、 123 +10 =&gt; 123+10 と正しい数式の形に戻せる。
*string prefix = nResult >;= 0 ? "+" : "";
*{// 足し算、または引き算に一致string d = DECIMAL;string pattern = d + @"\+" + d + "|" + d + @"\-" + d;return CalculationBase(calcStr, pattern, (baseMatch) =>;{double nResult = 0;// 演算子で分割し、計算Match match = Regex.Match(baseMatch.Value, @"(" + d + @")([\+\-])(" + d + @")");string l = match.Result("$1");string r = match.Result("$3");string op = match.Result("$2");if (op == "+"){nResult = (l.ToDouble() + r.ToDouble());}else if (op == "-"){nResult = (l.ToDouble() - r.ToDouble());}else{nResult = match.Value.ToDouble();}// 小数点第n位まで取得し、後ろの余分な0を切り捨てるstring result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);return result;});}
+ または - の計算を行う
足し算、または引き算に一致
*string d = DECIMAL;
演算子で分割し、計算
*Match match = Regex.Match(baseMatch.Value, @"(" + d + @")([\+\-])(" + d + @")");
小数点第n位まで取得し、後ろの余分な0を切り捨てる
*string result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);
*{// 指定したパターンに一致するMatch match = argMatch ?? Regex.Match(calcStr, pattern);if (match.Success){// あとで結合するので、計算する文字列の前後を取得しておくstring pre = match.Result("$`");string suf = match.Result("$'");// 計算はコールバックに任せるstring result = callback(match);// 計算結果を元の場所に結合result = string.Format("{0}{1}{2}", pre, result, suf);// まだ計算するべき数式があるかチェックMatch nMatch = Regex.Match(result, pattern);if (nMatch.Success){result = CalculationBase(result, pattern, callback, nMatch);}return result;}return calcStr;}
各種計算用メソッドのベース
指定したパターンに一致する
*Match match = argMatch ?? Regex.Match(calcStr, pattern);
あとで結合するので、計算する文字列の前後を取得しておく
*string pre = match.Result("$`");
計算はコールバックに任せる
*string result = callback(match);
*result = string.Format("{0}{1}{2}", pre, result, suf);
計算結果を元の場所に結合
まだ計算するべき数式があるかチェック
*Match nMatch = Regex.Match(result, pattern);
ネイピア数
*private const double E = 2.71828182845904523536;
有効桁数
*private const int SIGNIFICANT_DIGIT = StringCalculation.SIGNIFICANT_DIGIT;
*{{("Sin",   new Type[]{typeof(string)}.GetValueHash()), (args)=>;{ return Sin(args[0]); }},{("Cos",   new Type[]{typeof(string)}.GetValueHash()), (args)=>;{ return Cos(args[0]); }},{("Tan",   new Type[]{typeof(string)}.GetValueHash()), (args)=>;{ return Tan(args[0]); }},{("Log10", new Type[]{typeof(string)}.GetValueHash()), (args)=>;{ return Log10(args[0]); }},{("Log",   new Type[]{typeof(string)}.GetValueHash()), (args)=>;{ return Log(args[0]); }},{("Log",   new Type[]{typeof(string), typeof(string)}.GetValueHash()), (args)=>;{ return Log(args[0], args[1]); }},{("Ln",    new Type[]{typeof(string)}.GetValueHash()), (args)=>;{ return Ln(args[0]); }},};
メソッド呼び出し用辞書
*{int result = 0;int length = types.Length;for (int i = 0; i <; length; i++){var shift_l = (i % 32);var shift_r = 32 - shift_l;var hash = types[i].GetHashCode();result += hash <;<; shift_l | hash >;>; shift_r;}return result;}
Type[]で同じ並びの際に同じハッシュ値を返す
*{var argTypesHash = ((args == null) ? Type.EmptyTypes : args.Select(x =>; x.GetType()).ToArray()).GetValueHash();var cacheKey = (methodName, argTypesHash);var func = _methodCache[cacheKey];return func(args);}
登録されたメソッドを呼び出す
実体メソッド
====================================================================================================
Sin
*public static string Sin(string calcStr)
*{double result = Math.Cos(Deg2rad(calcStr.ToDouble()));return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
Cos
*{double result = Math.Tan(Deg2rad(calcStr.ToDouble()));return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
Tan
*{double result = Math.Log10(calcStr.ToDouble());return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
log - 10を底としたlogの計算を行う
*{double result = Math.Log(calcStr.ToDouble());return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
log - ネイピア数 e を底としたlogの計算を行う
*{double result = Math.Log(calcStr.ToDouble(), baseStr.ToDouble());return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
log - 自前でベース値を設定する
*{double result = Math.Log(calcStr.ToDouble(), E);return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
log - ネイピア数 e を底としたlogの計算を行う
*{return num / 180.0 * Math.PI;}
角度をラジアンに変換
*{// 小数点第digit位まで取得し、後ろの余分な0を切り捨てるstring result = string.Format("{0:f" + digit + "}", value);return Regex.Replace(result, @"(\.?0+)$", "");}
小数点第n位まで取得し、後ろの余分な0を切り捨てて文字列にする
*string result = string.Format("{0:f" + digit + "}", value);
小数点第digit位まで取得し、後ろの余分な0を切り捨てる
*{if (double.TryParse(str, out double ret)){return ret;}throw new ArgumentException("<;" + str + ">;をdouble型に変換できません");}
文字列をdouble型に変換します
指定したパターンに一致する
*Match match = argMatch ?? Regex.Match(calcStr, pattern);
あとで結合するので、計算する文字列の前後を取得しておく
*string pre = match.Result("$`");
計算はコールバックに任せる
*string result = callback(match);
*result = string.Format("{0}{1}{2}", pre, result, suf);
計算結果を元の場所に結合
まだ計算するべき数式があるかチェック
*Match nMatch = Regex.Match(result, pattern);
*string pattern = @"[\+\-]{2}";
+ または - が２個連続している箇所を検出
２つ続いている演算子を取得
*Match match = Regex.Match(baseMatch.Value, @"([\+\-])([\+\-])");
足し算、または引き算に一致
*string d = DECIMAL;
演算子で分割し、計算
*Match match = Regex.Match(baseMatch.Value, @"(" + d + @")([\+\-])(" + d + @")");
小数点第n位まで取得し、後ろの余分な0を切り捨てる
*string result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);
掛け算、または割り算に一致
*string d = DECIMAL;
演算子で分割し、計算
*Match match = Regex.Match(baseMatch.Value, @"\*|\/");
小数点第n位まで取得し、後ろの余分な0を切り捨てる
*string result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);
計算結果が + の場合、前方の文字と結合する際に符号なしでくっついてしまう※ので、符号を追加
※この関数の結果が10、前方の文字が123だとした場合、123 10 =&gt; 12310 になってしまう。
+ を記述しておけば、 123 +10 =&gt; 123+10 と正しい数式の形に戻せる。
*string prefix = nResult >;= 0 ? "+" : "";
掛け算と割り算
*string result = MultiDiv(calcStr);
足し算と引き算
*result = AddSub(result);
一番内側の括弧に一致
*string d = DECIMAL;
Sin() や Cos() など関数の形に一致
*string d = @"[\+\-\*\/]|" + DECIMAL;
後ろで正規表現を使用するので、$1が消える前に関数名を取得しておく
*string func = baseMatch.Result("$1");
*string[] args = baseMatch.Result("$2").Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
引数をカンマ区切りで取得し、それぞれを計算する
関数呼び出し
*string result = StringCalculationFunctions.InvokeMethod(func, args);
小数点第n位まで取得し、後ろの余分な0を切り捨てる
*result = result.ToDouble().ToStringWithDigit(SIGNIFICANT_DIGIT);
対象文字列の半角スペースを削除
*result = Regex.Replace(calcStr, @"\s", "");
+-の符号重複を整理
*result = OperatorOrganize(result);
余分な括弧を整理する
*result = BracketsOrganize(result);
関数の計算
*result = ProcFunction(result);
()内を計算
*result = CalculationBrackets(result);
カッコが全て計算された後の通常計算
*result = NormalCalculation(result);
先頭の + は削除する
*result = Regex.Replace(result, @"^\+", "");
*{// 通常計算_Recalculation("3.5 - 0.5 + 21 * 2 / 2.5",3.5 - 0.5 + 21 * 2 / 2.5);// 通常計算_Recalculation("-2 + 1 * +2 / -2 / 2.0 * -2 + 5 * 2",-2 + 1 * +2 / -2 / 2.0 * -2 + 5 * 2);// 括弧付き計算_Recalculation("(1 + 2.5 + (2 - 3.5) * (1 + 1)) * 5 + 3 * (20 - 8)",(1 + 2.5 + (2 - 3.5) * (1 + 1)) * 5 + 3 * (20 - 8));// 演算子重複_Recalculation("1 * (+2 + (-3)) - -+4 - -+ +- -5",1 * (+2 + (-3)) - -+4 - -+ +- -5);// 括弧の計算_Recalculation("2 - (1 * -11)",2 - (1 * -11));// 括弧の計算_Recalculation("1 * (+2 + (-3)) - (-(+4)) - (-(+(+(-(-5)))))",1 * (+2 + (-3)) - (-(+4)) - (-(+(+(-(-5))))));// 括弧の計算_Recalculation("((-20.25) + 4) / ((4 / 2) + 3 * (1 * 2))",((-20.25) + 4) / ((4 / 2) + 3 * (1 * 2)));// 関数の計算_Recalculation("Sin(45)",Math.Sin(Deg2rad(45)));// 関数の計算_Recalculation("Cos(45)",Math.Cos(Deg2rad(45)));// 関数の計算_Recalculation("Tan(45)",Math.Tan(Deg2rad(45)));// 関数の計算_Recalculation("Cos((12)) + Tan((179) + Sin(75))",Math.Cos(Deg2rad((12))) + Math.Tan(Deg2rad((179) + Math.Sin(Deg2rad(75)))));// 余分な括弧の計算_Recalculation("((((-(2 + 3) + 9))))",((((-(2 + 3) + 9)))));// 関数と過剰な括弧の計算_Recalculation("((Cos(Sin(( Cos(((((45+45)))) + 90) * - 90 )) * 180)) + 20 + Tan((180)))",((Math.Cos(Deg2rad(Math.Sin((Deg2rad(Math.Cos(Deg2rad(((((45 + 45)))) + 90)) * -90))) * 180))) + 20 + Math.Tan(Deg2rad((180)))));// 関数と過剰な括弧の計算_Recalculation("Cos((((((((-(2+3)+9))))))))",Math.Cos(Deg2rad((((((((-(2 + 3) + 9))))))))));// Log計算_Recalculation("Sin(Log10(10))",Math.Sin(Deg2rad(Math.Log10(10))));// Log計算_Recalculation("Sin(Log(10))",Math.Sin(Deg2rad(Math.Log(10))));// Log計算_Recalculation("Sin(Log(10+2*3, 4*2.4-5))",Math.Sin(Deg2rad(Math.Log(10 + 2 * 3, 4 * 2.4 - 5))));// Log計算_Recalculation("Log10(0.1)",Math.Log10(0.1));// Log計算_Recalculation("Ln(42.22*2)",Math.Log(42.22 * 2, Math.E));}
Use this for initialization
通常計算
*_Recalculation(
通常計算
*_Recalculation(
括弧付き計算
*_Recalculation(
演算子重複
*_Recalculation(
括弧の計算
*_Recalculation(
括弧の計算
*_Recalculation(
括弧の計算
*_Recalculation(
関数の計算
*_Recalculation(
関数の計算
*_Recalculation(
関数の計算
*_Recalculation(
関数の計算
*_Recalculation(
余分な括弧の計算
*_Recalculation(
関数と過剰な括弧の計算
*_Recalculation(
関数と過剰な括弧の計算
*_Recalculation(
Log計算
*_Recalculation(
Log計算
*_Recalculation(
Log計算
*_Recalculation(
Log計算
*_Recalculation(
Log計算
*_Recalculation(
*{string sResult = StringCalculation.Calculation(str);// 計算結果が文字列として一致、もしくは誤差の範囲内かどうかstring isSuccess = (sResult == nResult.ToString() || Math.Abs(sResult.ToDouble() - nResult) <;= 0.000000000001) ? "○" : "×";string resultStr = "検算結果 : " + "" + isSuccess + "\n" + str + "  =>;\n STR : [" + sResult + "]\n NUM : [" + nResult + "]\n\n";_dbgStr += resultStr;}
文字列の式と実際に計算した際の数値結果を入力し、検算を行う
計算結果が文字列として一致、もしくは誤差の範囲内かどうか
*string isSuccess = (sResult == nResult.ToString() || Math.Abs(sResult.ToDouble() - nResult) <;= 0.000000000001) ? "○" : "×";
Debug用変数
*private static string _logText = "";
対象文字列の半角スペースを削除
*result = Regex.Replace(calcStr, @"\s", "");
+-の符号重複を整理
*result = OperatorOrganize(result);
余分な括弧を整理する
*result = BracketsOrganize(result);
関数の計算
*result = ProcFunction(result);
()内を計算
*result = CalculationBrackets(result);
カッコが全て計算された後の通常計算
*result = NormalCalculation(result);
先頭の + は削除する
*result = Regex.Replace(result, @"^\+", "");
*string pattern = @"[\+\-]{2}";
+ または - が２個連続している箇所を検出
２つ続いている演算子を取得
*Match match = Regex.Match(baseMatch.Value, @"([\+\-])([\+\-])");
Sin() や Cos() など関数の形に一致
*string d = @"[\+\-\*\/]|" + DECIMAL;
後ろで正規表現を使用するので、$1が消える前に関数名を取得しておく
*string func = baseMatch.Result("$1");
*string[] args = baseMatch.Result("$2").Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
引数をカンマ区切りで取得し、それぞれを計算する
小数点第n位まで取得し、後ろの余分な0を切り捨てる
*result = result.ToDouble().ToStringWithDigit(SIGNIFICANT_DIGIT);
一番内側の括弧に一致
*string d = DECIMAL;
掛け算と割り算
*string result = MultiDiv(calcStr);
足し算と引き算
*result = AddSub(result);
掛け算、または割り算に一致
*string d = DECIMAL;
演算子で分割し、計算
*Match match = Regex.Match(baseMatch.Value, @"\*|\/");
小数点第n位まで取得し、後ろの余分な0を切り捨てる
*string result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);
計算結果が + の場合、前方の文字と結合する際に符号なしでくっついてしまう※ので、符号を追加
※この関数の結果が10、前方の文字が123だとした場合、123 10 =&gt; 12310 になってしまう。
+ を記述しておけば、 123 +10 =&gt; 123+10 と正しい数式の形に戻せる。
*string prefix = nResult >;= 0 ? "+" : "";
足し算、または引き算に一致
*string d = DECIMAL;
演算子で分割し、計算
*Match match = Regex.Match(baseMatch.Value, @"(" + d + @")([\+\-])(" + d + @")");
小数点第n位まで取得し、後ろの余分な0を切り捨てる
*string result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);
指定したパターンに一致する
*Match match = argMatch ?? Regex.Match(calcStr, pattern);
あとで結合するので、計算する文字列の前後を取得しておく
*string pre = match.Result("$`");
マッチ結果を表示
*CalculationLog("  match : " + pre + "  [" + mat + "]  " + suf + "\n");
計算はコールバックに任せる
*string result = callback(match);
*result = string.Format("{0}{1}{2}", pre, result, suf);
計算結果を元の場所に結合
まだ計算するべき数式があるかチェック
*Match nMatch = Regex.Match(result, pattern);
debug デバッグ出力用
====================================================================================================
*private static void CalculationLog(string log)

CameraにAdd
*PostProcessVolume processVolume;
*if (Input.anyKey == false)*{
キー押してない間はreturn
*if (Input.GetKeyDown(KeyCode.Space) &amp;&amp; processVolume.weight == 0)*{
テスト用　トンネル開始
*if (Input.GetKeyDown(KeyCode.Backspace) &amp;&amp; processVolume.weight == 1)*{
テスト用　トンネル解除
*{if(processVolume.weight == 0){coroutine = StartCoroutine(Tunnel_ON_Coroutine());}}
トンネル開始
*{if (processVolume.weight == 1){coroutine = StartCoroutine(Tunnel_OFF_Coroutine());}}
トンネル解除
*{if(processVolume.weight == 0){coroutine = StartCoroutine(Tunnel_ON_Coroutine());}}
トンネル開始
*{if (processVolume.weight == 1){coroutine = StartCoroutine(Tunnel_OFF_Coroutine());}}
トンネル解除

以下の行でレジストリを取り扱う
*Microsoft.Win32.RegistryKey regkey = Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"Software\TodoListDon\sub", false);
読み込む
*AccessToken = (string)regkey.GetValue("AccessToken");
リンク先に移動したことにする
*OAuthlink.LinkVisited = true;
ブラウザで開く
*System.Diagnostics.Process.Start(OAuthlink.Text);
操作するレジストリ・キーの名前
*string registryKeyName = @"Software\TodoListDon\Sub";
取得処理を行う対象となるレジストリの値の名前
*string registryValueName = "hostname";
*{// レジストリの値を設定registryKey.SetValue(registryValueName, host);}
キー（HKEY_CURRENT_USER\Software\Sample）を開く
レジストリの値を設定
*registryKey.SetValue(registryValueName, host);
取得処理を行う対象となるレジストリの値の名前
*registryValueName = "AccessToken";
*{// レジストリの値を設定registryKey.SetValue(registryValueName, tokens.AccessToken);}
キー（HKEY_CURRENT_USER\Software\Sample）を開く
レジストリの値を設定
*registryKey.SetValue(registryValueName, tokens.AccessToken);

ここで開始時間を保存しておく
*var startDateTime = DateTime.Now;
*Console.WriteLine($"End [{methodName}] took {collapsedTime.TotalMilliseconds:F2}ms");
ここで経過時間を求める
*{await Task.Delay(2000);}
ここで先ほどの計測関数を実装
・・・・
*,,,
ログ出力
*Console.WriteLine(CreateLogString(log, header));
例外情報出力
*Console.WriteLine(CreateLogString(ex.ToString(), header));

*void Ping(int i)
登録するメソッドにint型引数を持たす

*listener.Prefixes.Add("http:
+:80Temporary_Listen_Addresses");

次のコンパイル警告が検出されます。
この呼び出しを待たないため、現在のメソッドの実行は、呼び出しが完了するまで続行します。
呼び出しの結果に 'await' 演算子を適用することを検討してください。
*HeavyActionAsync();
*{Debug.WriteLine("BtnHeavyAction_Click enter");// await をつけます。// BtnHeavyAction_Click に async をつけないと次のコンパイルエラーが検出されます。// 'await' 演算子は、非同期メソッド内でのみ使用できます。// このメソッドに 'async' 修飾子を指定し、戻り値の型を 'Task' に変更することを検討してください。await HeavyActionAsync();Debug.WriteLine("BtnHeavyAction_Click exit");}
async をつけます。
await をつけます。
BtnHeavyAction_Click に async をつけないと次のコンパイルエラーが検出されます。
'await' 演算子は、非同期メソッド内でのみ使用できます。
このメソッドに 'async' 修飾子を指定し、戻り値の型を 'Task' に変更することを検討してください。
*await HeavyActionAsync();
戻り値を受けます。
このような場合、私は nowait のような変数名にすることが多いです。
人間に対しても「待つ必要がない」ということが伝わるからです。
*Task nowait = HeavyActionAsync();
ここでフリーズします。
*HeavyActionAsync().Wait();
*Debug.WriteLine($"result={result}");
ここでフリーズします。
*{Debug.WriteLine("BtnHeavyAction_Click enter");// await をつけます。await HeavyActionAsync();Debug.WriteLine("BtnHeavyAction_Click exit");}
async をつけます。
await をつけます。
*await HeavyActionAsync();
HeavyActionAsync の実行中 UI はブロックされますが、フリーズすることはなくなります。
*HeavyActionAsync().Wait();
ConfigureAwait(false) をつけます。
*await Task.Delay(3000).ConfigureAwait(false);
*Debug.WriteLine($"{ex.GetType().Name}:{ex.Message}");
ここではキャッチできない。
*while (task.IsCompleted) {}
タスクが完了するまでポーリングしたりすると例外が排出されます。
*while (task.IsCompleted) {*}
※ただ待ちたいだけなら await を使いましょう。
*Debug.WriteLine($"{ex.GetType().Name}:{ex.Message}");
ここで例外がキャッチされます。
Wait で完了を待つ。
*HeavyActionAsync().Wait();
*Debug.WriteLine($"{ex.GetType().Name}:{ex.Message}");
ここで例外がキャッチされます。
コントロールにアクセス
*btnHeavyAction.Enabled = false;
コントロールにアクセス
*btnHeavyAction.Enabled = true;
ここまでは呼び出し元スレッド
*await Task.Delay(3000).ConfigureAwait(false);
ここから後は別のスレッド
*,,,

*var enumVal = EnumA.Member2;
Member2 メンバの属性を取得してみる

*if (Input.GetKeyDown(KeyCode.T))
VRのカメラオン

*if (EventSystem.current.IsPointerOverGameObject(Input.GetTouch(0).fingerId)){*return;
UIの上なら、タップとみなさない

*@"C:\ProgramData\Application Data",
よくある隠しフォルダ
*if (_isExecute)*{
実行中にもう一度押されたらタスクのキャンセルを行う
*{//ファイル取得var filePaths = await GetAllFilesAsync(@"C:\");//一回でList型で取得するのではなく//1ファイル読み込み毎に何らかの処理をしたいからIEnumerable型で取得したいforeach (var filePath in filePaths){//タスクのキャンセルがされていたら例外を投げる_cancellationToken.ThrowIfCancellationRequested();//1ファイル読み込み毎に何らかの処理}}, _cancellationToken);
スレッドプールさん、処理をお願いします何でもしますから
ファイル取得
*var filePaths = await GetAllFilesAsync(@"C:\");
一回でList型で取得するのではなく
1ファイル読み込み毎に何らかの処理をしたいからIEnumerable型で取得したい
*foreach (var filePath in filePaths)
タスクのキャンセルがされていたら例外を投げる
*_cancellationToken.ThrowIfCancellationRequested();
1ファイル読み込み毎に何らかの処理
*}
同階層のファイル取得をして再帰的に同階層のフォルダを検索しに行く
*return Directory.EnumerateFiles(folderPath).Concat(directories);
パターン1
IEnumerable型で取得した後にList化して初めからListで返すパターンとの比較を行う
*var files = GetAllFiles(folderPath).ToList();
*//IEnumerableで取得したものをforeachで展開させる*foreach (var file in GetAllFiles(folderPath))
パターン2
*foreach (var file in GetAllFiles(folderPath))*{
IEnumerableで取得したものをforeachで展開させる
*{this.txtFileCount.Text = file.index + Environment.NewLine + file.value;});
Dispatcher.InvokeでUIスレッドに処理をさせる
*{foreach (var file in GetAllFiles(folderPath).Select((value, index) =>; new { value, index })){//UIスレッドに戻ってきてUIを更新させるthis.Dispatcher.Invoke(() =>;{this.txtFileCount.Text = file.index + Environment.NewLine + file.value;});}});
スレッドプールに処理を任せといた
*{this.txtFileCount.Text = file.index + Environment.NewLine + file.value;});
UIスレッドに戻ってきてUIを更新させる
*if (!directories.Any())*{
同階層にフォルダが存在しなければ同階層のファイルを取得するタスクを返す
再帰的にフォルダを探し続ける
*var filePaths = await Task.WhenAll(directories.Select(async x =>; await GetAllFilesAsync(x)))
タスクを作成する
*var tcs = new TaskCompletionSource<;IEnumerable<;string>;>;();
ディレクトリにアクセスできないならファイルはない
*yield break;
*if (!directories.Any())*{
同階層にフォルダが存在しなければ同階層のファイルを取得するタスクを返す
*foreach (var task in directories.Select(GetAllFilesAsync).SelectMany(t =>; t))*{
再帰的にフォルダを探し続ける
タスクを作成
*var tcs = new TaskCompletionSource<;IEnumerable<;string>;>;();
*if (_isExecute)*{
実行中にもう一度押されたらタスクをキャンセル
*{var enumerateFilesCollection = GetAllFilesAsync(@"C:\");await enumerateFilesCollection.ForEachAsync(async enumerateFiles =>;{foreach (var file in await enumerateFiles){//キャンセルされれば例外で止める_cancellationToken.ThrowIfCancellationRequested();this.Dispatcher.Invoke(() =>;{++count;this.txtFileCount.Text = count + Environment.NewLine + file;});}}, 200, _cancellationToken);}, _cancellationToken);
スレッドプールさん、処理をお願いします何でもしますから
キャンセルされれば例外で止める
*_cancellationToken.ThrowIfCancellationRequested();
パターン1に関しては省略
パターン2の計測の仕方
*await Task.Run(async () =>;
キャンセルされれば例外で止める
*_cancellationToken.ThrowIfCancellationRequested();
念の為スレッドセーフにインクリメントを行う
*Interlocked.Increment(ref count);
*{var enumerateFilesCollection = GetAllFilesAsync(@"C:\");await enumerateFilesCollection.ForEachAsync(async enumerateFiles =>;{foreach (var file in await enumerateFiles){//キャンセルされれば例外で止める_cancellationToken.ThrowIfCancellationRequested();//念の為スレッドセーフにインクリメントを行うInterlocked.Increment(ref count);if (count >;= 50000){_cancellationTokenSource.Cancel();}}}, 200, _cancellationToken);}, _cancellationToken, TaskCreationOptions.LongRunning, TaskScheduler.Default);
Task.RunではTaskCreationOptionsを設定できないのでTask.Factoryを使用する
キャンセルされれば例外で止める
*_cancellationToken.ThrowIfCancellationRequested();
念の為スレッドセーフにインクリメントを行う
*Interlocked.Increment(ref count);
}, _cancellationToken); こうじゃない
}, DispatcherPriority.Background, _cancellationToken); こっち
*,,,
キャンセルされれば例外で止める
*_cancellationToken.ThrowIfCancellationRequested();
念の為スレッドセーフにインクリメントを行う
*Interlocked.Increment(ref count);
*{this.txtFileCount.Text = count + Environment.NewLine + file;}, DispatcherPriority.Background, _cancellationToken);
意図的にawaitを付けない
*if (count >;= 50000)*{
50000件の計測用
.AsParallel() 悪夢の元凶
*.Where(x =>; _exceptFolder.All(y =>; !x.StartsWith(y, StringComparison.CurrentCultureIgnoreCase)));
*if (!directories.Any())*{
同階層にフォルダが存在しなければ同階層のファイルを取得するタスクを返す
再帰的にフォルダを探し続ける
*var filePaths = await Task.WhenAll(directories.Select(async x =>; await GetAllFilesAsync(x)))
タスクを作成する
*var tcs = new TaskCompletionSource<;IEnumerable<;string>;>;();
*{await Task.Run(async () =>;{var enumerateFilesCollection = GetAllFilesAsync(@"C:\");await enumerateFilesCollection.ForEachAsyncNoLock(async enumerateFiles =>;{foreach (var file in await enumerateFiles){//キャンセルされれば例外で止める_cancellationToken.ThrowIfCancellationRequested();//念の為スレッドセーフにインクリメントを行うInterlocked.Increment(ref count);//意図的にawaitを付けないthis.Dispatcher.InvokeAsync(() =>;{this.txtFileCount.Text = count + Environment.NewLine + file;}, DispatcherPriority.Background, _cancellationToken);}}, _cancellationToken);}, _cancellationToken);}
省略
キャンセルされれば例外で止める
*_cancellationToken.ThrowIfCancellationRequested();
念の為スレッドセーフにインクリメントを行う
*Interlocked.Increment(ref count);
*{this.txtFileCount.Text = count + Environment.NewLine + file;}, DispatcherPriority.Background, _cancellationToken);
意図的にawaitを付けない
省略
*}

*MessageEffectSubject.OnNext("failure");
イベントを通知

dll内の関数
*public static extern int Add(int a, int b);
dll内の関数
*public int tooltip_int;
dll内の関数
*public int header_int;

*xmlns:i="http:
schemas.microsoft.comexpression2010interactivity"
*private IRegionNavigationService RegionNavigationService { get; set; }
OnNavigatedToで取得したものを保持.
*public DelegateCommand GoToSubBCommand { get; }
この画面から別の画面に遷移するためのトリガー.
コンストラクタでGoToSubBCommandの設定.RegionNavigationServiceを使用すればRegionManagerやRegionNameを意識しなくて良い.
*public SubaViewModel() =>; GoToSubBCommand = new DelegateCommand(() =>; RegionNavigationService.RequestNavigate(nameof(SubbView)));
OnNavigatedToで手に入るIRegionNavigationServiceを保持.
*public void OnNavigatedTo(NavigationContext navigationContext) =>; RegionNavigationService = navigationContext.NavigationService;
*public class PopupNotification : INotification*{
InteractionRequest用に入れ物クラスを用意してその中にIRegionManager格納場所を用意.
*public ContentViewModel() =>; PopupWindowCommand = new DelegateCommand(() =>; PopupWindowRequest.Raise(new PopupNotification(), PopupWindowRequestCallback));*private void PopupWindowRequestCallback(PopupNotification n)
リクエストをRaiseしてウィンドウが閉じられたときの挙動を設定.
*// Notificationはコンストラクタの時点ではまだ注入されていなかった.*private void Loaded()
PopupWindowActionで指定したViewのLoaded時に入れ物クラスに詰めておく.
*{if (Notification is PopupNotification n)n.PopupRegionManager = PopupRegionManager.Value;}
Notificationはコンストラクタの時点ではまだ注入されていなかった.

対象ツイートの取得
*var status = tokens.Statuses.Show(id =>; ************/*対象のツイートのID*/));
対象ツイート以降に投稿されたツイート主へのリプライを取得
*var replies = tokens.Search.Tweets(q=>;"to:"+ status.User.ScreenName,
リプライの中でも、宛先が対象のツイートとなっているもののみを取得
*var targetReplies = replies.Where(w =>; w.InReplyToStatusId == status.Id);

対象年の1月1日(元旦)の曜日を取得する。
*DateTime gantan = new DateTime(targetYear, 1, 1);
対象年の1月において、引数で指定した曜日に該当する最初の日付を取得する
*DateTime date;
*while (date.Year == targetYear)*{
7日ずつ日付をずらして、対象年における指定した曜日の日付を全て取得する。
対象年の指定された曜日に該当する日付を全て取得する。
*var days = FindWantDayOfWeek(targetYear, wantDayOfWeek);
*var newDays = days.Select(day =>; new { Day = day, Month = day.Month }).GroupBy(day =>; day.Month)
日付を月単位でGroupByした後、Whereで「第N〇曜日が存在する月」に絞り込む。
*var newDays = days.Select(day =>; new { Day = day, Month = day.Month }).GroupBy(day =>; day.Month)
さらに、ElementAtで各月のN番目の〇曜日の日付を抽出する。
開始年～終了年の指定された曜日に該当する日付を全て取得する。
*int elapsedYear = end.Year - start.Year + 1;
得られた日付リストを、開始日～終了日の間に絞り込む。
*var newDays = days.Where(day =>; day >;= start &amp;&amp; day <;= end).ToList();
2018年4月1日～2019年3月31日の第2火曜日の日付を取得する。
*var days = DateUtils.FindWantDayOfWeek(2019, DayOfWeek.Tuesday, 2, new DateTime(2018, 4, 1), new DateTime(2019, 3, 31));

*material.SetFloat("_GlossyReflections", 0);
0:OFF, 1:ON

*new PropertyMetadata(XXX_PropertyChanged)
コールバックを登録
*private static void XXX_PropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {var textBox = d as TextBox;if (textBox == null) return;//イベントハンドラの登録if (e.NewValue != null) {textBox.PreviewTextInput += TextBox_PreviewTextInput;} else {textBox.PreviewTextInput -= TextBox_PreviewTextInput;}}
コールバック
*if (e.NewValue != null) {*textBox.PreviewTextInput += TextBox_PreviewTextInput;
イベントハンドラの登録
*private static void TextBox_PreviewTextInput(object sender, TextCompositionEventArgs e) {//振る舞い}
イベントハンドラ
振る舞い
*}
*private void AssociatedObject_Loaded(object sender, RoutedEventArgs e) {//振る舞い}
イベントハンドラ
振る舞い
*}

*{// Add a new ribbon panelRibbonPanel ribbonPanel = application.CreateRibbonPanel("NewRibbonPanel");// Create a push button to trigger a command add it to the ribbon panel.string thisAssemblyPath = Assembly.GetExecutingAssembly().Location;PushButtonData buttonData = new PushButtonData("cmdHelloWorld","Hello World", thisAssemblyPath, "HelloWorld.HelloWorld");PushButton pushButton = ribbonPanel.AddItem(buttonData) as PushButton;// Optionally, other properties may be assigned to the button// a) tool-tippushButton.ToolTip = "Say hello to the entire world.";// b) large bitmapUri uriImage = new Uri(@"C:\Users\会社\Documents\Visual Studio 2015\Projects\HelloWorld\地球アイコン9.jpeg");BitmapImage largeImage = new BitmapImage(uriImage);pushButton.LargeImage = largeImage;return Result.Succeeded;}
Both OnStartup and OnShutdown must be implemented as public method

*transform.position = new Vector3(x+defPosition.x,defPosition.y, z+defPosition.z);
自分のいる位置から座標を動かす。

*Debug.WriteLine($"{device.Name} Services: {gatt.Services.Count}, {gatt.Status}, {gatt.ProtocolError}");
SERVICES!!

（略）
*}

確認したフラグが違ってたら反転
*var toggleResult = EditorGUILayout.Toggle(flagName, isToggle);
*{EditorGUILayout.LabelField("CurrentFlag", _outputFlag.ToString());EditorGUILayout.LabelField("FlagHexValue", _outputFlag.ToString("X"));}
今のフラグの状態の表示

*private const string ENDPOINT = "https:
api-free.deepl.comv2translate?";
ドロップダウンメニュー作成
*var languages = Enum.GetNames(typeof(Language));
*.Subscribe(value =>; { fromLanguage = (Language) value; })
翻訳元言語
*.Subscribe(value =>; { toLanguage = (Language) value; })
翻訳後言語
翻訳ボタン押下
*translateButton.OnClickAsObservable()
結果が送られてくるまで待ってから表示
*var result = GetTranslation(fromLanguage, toLanguage, inputField.text, token);
*requestInfo += $"&amp;text={speechText}&amp;source_lang={from}&amp;target_lang={to}";
POSTメソッドのリクエストを作成
結果受け取り
*var second = TimeSpan.FromSeconds(3);

*static int[,] ReadData(string path) {int[,] nums = new int[9, 9];var lines = File.ReadAllLines(path);for (int y = 0; y <; 9; y++) {int x = 0;foreach (var n in lines[y].Split(',')) {nums[x++, y] = int.Parse(n);}}return nums;}
データを読み込む
*} else {
完成したら、answerに答えを入れる。
空いている位置をひとつ取り出す
*var pos = _board.AlloLocations()
*for (int n = 1; n <;= 9; n++) {*if (_board.CanPut(pos, n)) {
そこに、1-9 の数を置いてみる。
置けたので、再帰的に次の数を置いていく。
*var answer = SolveInner();
次の数を置くために、今置いた場所には 0 を入れなおす。
*_board.Put(pos, 0);
1..9どれも駄目。つまり失敗-&gt;  呼び出し元に戻る
*}
*public Board(int[,] mat) {this.sheet = mat;}
コンストラクタ
*private Board() {sheet = new int[9, 9];}
コンストラクタ
*public Board Clone() {var nboard = new Board();nboard.sheet = (int[,])this.sheet.Clone();return nboard;}
クローン
*public void Put(Location pos, int num) {sheet[pos.X, pos.Y] = num;}
チェックはしない CanPutを呼び出しているのが前提
*public bool CanPut(Location pos, int num) {if (sheet[pos.X, pos.Y] != 0)return false;// 仮に置いてみる。sheet[pos.X, pos.Y] = num;try {return IsValid(pos);} finally {// 元に戻すsheet[pos.X, pos.Y] = 0;}}
置けるか
*try {return IsValid(pos);} finally {// 元に戻すsheet[pos.X, pos.Y] = 0;}
仮に置いてみる。
元に戻す
*sheet[pos.X, pos.Y] = 0;
*public bool IsCompleted() {if (!Enumerable.Range(0, 9).All(nums =>; IsCompleted(VerticalNums(nums))))return false;if (!Enumerable.Range(0, 9).All(nums =>; IsCompleted(HorizontalNums(nums))))return false;return BoxLocations().All(pos =>; IsCompleted(BoxNums(pos)));}
完成か
*public bool IsCompleted(IEnumerable<;int>; nums) {return nums.Where(n =>; n >;= 1).Distinct().Count() == 9;}
完成したか
*public bool IsVacant(Location pos) {return sheet[pos.X, pos.Y] == 0;}
空いているか
*public bool IsValid(Location pos) {return IsValid(VerticalNums(pos.X)) &amp;&amp;IsValid(HorizontalNums(pos.Y)) &amp;&amp;IsValid(BoxNums(pos));}
posの位置に関する配置は違反していないか
*public bool IsValid(IEnumerable<;int>; nums) {return nums.Where(n =>; n >;= 1).Distinct().Count() == nums.Where(n =>; n >;= 1).Count();}
numsに重複はないか （つまり違反していないか）IsCompletedとは別。
*public IEnumerable<;Location>; BoxLocations() {return from x in Enumerable.Range(0, 2)from y in Enumerable.Range(0, 2)select new Location(x * 3, y * 3);}
９つある小さな四角形の左上のLocationを列挙
*public IEnumerable<;int>; BoxNums(Location pos) {return from x in Enumerable.Range(0, 3)from y in Enumerable.Range(0, 3)select sheet[pos.X / 3 * 3 + x, pos.Y / 3 * 3 + y];}
注目している位置が含まれる3*3の領域の数を列挙
*public IEnumerable<;int>; VerticalNums(int x) {for (int y = 0; y <; 9; y++) {yield return sheet[x, y];}}
注目している位置が含まれる縦一列の数を列挙
*public IEnumerable<;int>; HorizontalNums(int y) {for (int x = 0; x <; 9; x++) {yield return sheet[x, y];}}
注目している位置が含まれる横一列の数を列挙
*public IEnumerable<;Location>; AlloLocations() {return from x in Enumerable.Range(0, 9)from y in Enumerable.Range(0, 9)select new Location(x, y);}
すべての位置を列挙する

日本語用リソースだと”4逓倍”、英語用だと”Multiple 4”
*string str = Properties.Resources.Multi4

足し算
*Calc(4, 5, CalcType.Add).Is(9);
引き算
*Calc(4, 5, CalcType.Subtract).Is(-1);
掛け算
*Calc(4, 5, CalcType.Multiple).Is(20);
割り算
*Calc(4, 5, CalcType.Divide).Is((decimal) 0.8);

他のクラスメンバー略...
*}
だめだ。よくわかんねぇ
*,,,
*var dic = Employees.Select(x =>; { return new KeyValuePair<;int, string>;(x.Id, x.Name); }).Tolist();
これじゃList&lt;KeyValuePair&gt; なんだぜ。。。
*var dic2 = Employees.Select(x =>; { return new KeyValuePair<;int, string>;(x.Id, x.Name); }).ToDictionary(x =>; x.Key);
KeyにKeyは入ってるけど、ValueにKeyValuePairが入ってる気がした。

*{
モバイルの場合は下記のエラーになるので移動しない
ちょっと待たないとスクロールが間に合わない
*Thread.Sleep(100);
最後の画像は重複部分を切り取る
*Bitmap lastSc = screenshots.Last();
画像の縦横のサイズとJavascriptで取得した幅と高さから比率計算し、切り取るべきサイズを算出する
*decimal bitmapWidth = lastSc.Width;
算出したサイズで切り出す
*Rectangle rect = new Rectangle(0, duplHeight, cutWidth, cutHeight);

*void Start () {controller = new Controller();fingers = new Finger[5];isGripFingers = new bool[5];}
Use this for initialization
*void Update () {Frame frame = controller.Frame();if(frame.Hands.Count != 0){List<;Hand>; hand = frame.Hands;fingers = hand[0].Fingers.ToArray();isGripFingers = Array.ConvertAll(fingers, new Converter<;Finger, bool>;(i =>; i.IsExtended));Debug.Log(isGripFingers[0]+","+ isGripFingers[1] + "," + isGripFingers[2] + "," + isGripFingers[3] + "," + isGripFingers[4]);int extendedFingerCount = isGripFingers.Count(n =>; n == true);if(extendedFingerCount == 0){rsp = RSP.Rock;}else if(extendedFingerCount <; 4){rsp = RSP.Scissors;}else{rsp = RSP.Paper;}}}
Update is called once per frame

*private const string ENDPOINT = "https:
translation.googleapis.comlanguagetranslatev2?";
ドロップダウンメニュー作成
*var languages = Enum.GetNames(typeof(Language));
*.Subscribe(value =>; { fromLanguage = (Language) value; })
翻訳元言語
*.Subscribe(value =>; { toLanguage = (Language) value; })
翻訳後言語
翻訳ボタン押下
*translateButton.OnClickAsObservable()
結果が送られてくるまで待ってから表示
*var result = GetTranslation(fromLanguage, toLanguage, inputField.text, token);
*requestInfo += $"key={API_KEY}&amp;q={speechText}&amp;detectedSourceLanguage={from}&amp;target={to}";
POSTメソッドのリクエストを作成
結果受け取り
*var second = TimeSpan.FromSeconds(3);

*{
電話が来たらカッコ内の処理を流す．

ArgumentNullException がスローされる。これをレビューとテストで取り除くことができるか？
*sample.Name = null;
*Sample b = new Sample() { CreateDateTime = a.CreateDateTime };
a.CreateDateTime プロパティの値を b.CreateDateTime に代入（参照がコピーされる）
*Sample c = new Sample() { CreateDateTime = a.CreateDateTime.Clone() };
a.CreateDateTime プロパティの値のクローンを c.CreateDateTime に代入
a.CreateDateTime の値から1時間を引く
*a.CreateDateTime.Seconds -= 60 * 60;
*Debug.WriteLine($"a.CreateDateTime={a.CreateDateTime}");
当然ながら b.CreateDateTime の値も1時間が引かれます
*Debug.WriteLine($"a.CreateDateTime={a.CreateDateTime}");
参照型と値型の違いを理解していない場合、わかりにくいバグを埋め込むリスクがあります
*a.ParentID = new NullableInt32() { Value = 1 };
このように記述しなくてはいけません。partialファイルでコンストラクタや暗黙型変換を実装する必要あり？
null を代入することはできます。
*b.ParentID = null;
このようなコーディングは危険。
*b.ParentID = a.ParentID;
a2 は重複していると扱われて格納されません
*HashSet<;Player>; hash = new HashSet<;Player>;();
a2 は重複していると扱われて ArgumentException がスローされます
*Dictionary<;Player, bool>; dic = new Dictionary<;Player, bool>;();
*{get { return CreateDateTime.ToDateTime(); }set { CreateDateTime =Google.Protobuf.WellKnownTypes.Timestamp.FromDateTime(value.ToUniversalTime());}}
ProtoBuf モデルクラスとシグネチャが一致するメンバは明示的に実装する必要はありません。
アプリケーションロジックから使用するメソッド
*private SampleServiceClient m_Client;
RPCメソッドを呼び出す
*return SampleData.FromRpcModel(m_Client.GetSample(request.ToRpcModel(), options));
*{// 割愛public static SampleData FromRpcModel(Sample rpcModel) {}}
アプリケーションロジックから使用するモデルクラス
*public static SampleData FromRpcModel(Sample rpcModel) {}
割愛
*public Request ToRpcModel() {}
割愛

「@」をつけると逐語的文字列リテラルとなります。
文字列内ではエスケープシーケンスが不要になり、改行も可能になります。
また、C#6.0からは「$」による文字列埋め込みが使えます。
（SQLインジェクション対策としては、生の文字列埋め込みではなくDBパラメータの利用が推奨です。）
$@が正解ですが、@$とするとコンパイルエラーを起こすので注意。
*string sql = $@"

切り上げ
*value = Math.Ceilng(value);
切り下げ
Floor: -3、Truncate: -2
*value = Math.Floor(value2);
四捨五入
MidpointRounding.AwayFromZeroを指定しないと結果は2となる
*value = Math.Round(value, MidpointRounding.AwayFromZero);

*hogeInstance.Command.Execute(1);
これだと引数は1

*if(other.gameObject.tag == "Target")*{
ターゲットにしたオブジェクトにタグをつけとく
*//targetObjが動く場合はtargetObj.transform.positionで直接取得*tmpVec = Vector3.MoveTowards(tmpVec, targetObj.transform.position, speed);
~省略
*tmpVec = Vector3.MoveTowards(tmpVec, targetObj.transform.position, speed);*this.gameObject.transform.position = tmpVec;
targetObjが動く場合はtargetObj.transform.positionで直接取得
*if(other.gameObject.tag == "Target")*{
ターゲットにしたオブジェクトにタグをつけとく

*using System;
Needed for Math

*Note = Instantiate(Don, SpawnPoint.position, Quaternion.identity);
default don
setParameter関数を発火
*Note.GetComponent<;NoteController>;().setParameter(type, timing);
*void play() {PlayTime = Time.time * 1000;isPlaying = true;Debug.Log("Game Start!");}
ゲーム開始時に追加した変数に値をセット
追加した変数に値をセット
*Distance = Math.Abs(BeatPoint.position.x - SpawnPoint.position.x);
*void play() {PlayTime = Time.time * 1000;isPlaying = true;Debug.Log("Game Start!");}
ゲーム開始時に追加した変数に値をセット
ノーツを発射するタイミングかチェックし、go関数を発火
*this.UpdateAsObservable()

*{TState State {get;set;}}
様々な処理タスクのインターフェイス
*{}

*{Queued = 0,Downloading = 1,Encoding = 2,Uploading = 3,// 必要な処理を書いていく}
処理の状態を定義するEnum
必要な処理を書いていく
*}

*{var name = typeof(T).Name;// 重複チェック対策var viewTarget = _regionManager.Regions[regionName].Views.FirstOrDefault(x =>; x.GetType().Name == name);if (viewTarget == null){var view = _container.Resolve<;T>;();_regionManager.Regions[regionName].Add(view, name);}}
指定リージョンにモジュールを追加
重複チェック対策
*var viewTarget = _regionManager.Regions[regionName].Views
*{var viewToRemove = _regionManager.Regions[regionName].Views.FirstOrDefault(x =>; x.GetType().Name == typeof(T).Name);if (viewToRemove != null)_regionManager.Regions[regionName].Remove(viewToRemove);}
指定リージョンからモジュールを削除

和集合（重複データは除かれる）
*System.Console.WriteLine("和集合(Union)：" + string.Join(",", list1.Union(list2)));
和集合（重複データも含まれる）
*System.Console.WriteLine("和集合(Concat)：" + string.Join(",", list1.Concat(list2)));
積集合
*System.Console.WriteLine("積集合(Intersect)：" + string.Join(",", list1.Intersect(list2)));
差集合
*System.Console.WriteLine("差集合(Except)[list1-list2]：" + string.Join(",", list1.Except(list2)));
和集合（重複データは除かれる）を求めた後、文字列の昇順にソートする。
*System.Console.WriteLine("和集合＋昇順：" + string.Join(",", list1.Union(list2).OrderBy(cityName=>;cityName)));
和集合（重複データは除かれる）を求めた後、文字列の降順にソートする。
*System.Console.WriteLine("和集合＋降順：" + string.Join(",", list1.Union(list2).OrderByDescending(cityName =>; cityName)));

*public Text scoreText;
取得した手のトラッキングデータをUIに表示
右手と左手を取得する
*Hand rightHand = null;

*trackingPos = transform.rotation * trackingPos;*// 固定したい位置から hmd の位置を.
回転.
固定したい位置から hmd の位置を.
差し引いて実質 hmd の移動を無効化する.
*transform.position = Vector3.Lerp(transform.position,offset.position - trackingPos, 0.05f);

同期版はpr.TryRead(out var readResult)
*var readResult = await pr.ReadAsync();
読出し
*}
終了処理
*}
これをしないと次回のReadで例外
*pr.AdvanceTo(readResult.Buffer.End);
async内ではSpanが使用できないため別関数にする
将来的にはこの制限が緩和される可能性あり
*void WriteData(PipeWriter pw, ReadOnlySpan<;byte>; rsp)
実行時点でPipeReaderにデータが流れるようになる
*await pw.FlushAsync();

*IntPtr hWnd;
自ウィンドウのハンドルをここに取得したい
Player設定で入れた Product Name がタイトルになる
*hWnd = FindWindow(null, Application.productName);

*var userData = new UserData() { name = "HOGE", age = 20 };
保存データクラスをインスタンス化
クラスをJSON文字列に変換
*string json = JsonUtility.ToJson(userData);
byte配列に変換
*byte[] arr = System.Text.Encoding.UTF8.GetBytes(json);
AES暗号化サンプル処理
*AesEncryptSample(arr);
XOR暗号化サンプル処理
*XorEncrypt(arr);
AES設定値
===================================
*int aesKeySize = 128;
AES暗号化
*byte[] arrEncrypted = AesEncrypt(arr, aesKeySize, aesBlockSize, aesIv, aesKey);
ファイル書き込み
*string path = System.IO.Path.Combine(Application.temporaryCachePath, "UserDataAES");
ファイル読み込み
*byte[] arrRead = System.IO.File.ReadAllBytes(path);
復号化
*byte[] arrDecrypt = AesDecrypt(arrRead, aesKeySize, aesBlockSize, aesIv, aesKey);
byte配列を文字列に変換
*string decryptStr = System.Text.Encoding.UTF8.GetString(arrDecrypt);
暗号化文字列
*string keyString = "123456789";
ファイル書き込み
*string path = System.IO.Path.Combine(Application.temporaryCachePath, "UserDataXOR");
ファイル読み込み
*byte[] arrRead = System.IO.File.ReadAllBytes(path);
byte配列を文字列に変換
*string decryptStr = System.Text.Encoding.UTF8.GetString(arrDecrypt);
AESマネージャー取得
*var aes = GetAesManager(aesKeySize, aesBlockSize, aesIv, aesKey);
*byte[] encryptText = aes.CreateEncryptor().TransformFinalBlock(byteText, 0, byteText.Length);*return encryptText;
暗号化
AESマネージャー取得
*var aes = GetAesManager(aesKeySize, aesBlockSize, aesIv, aesKey);
*byte[] decryptText = aes.CreateDecryptor().TransformFinalBlock(byteText, 0, byteText.Length);*return decryptText;
復号化

*{Mat mat = Unity.TextureToMat(this.texture);Mat changedMat = new Mat();Cv2.CvtColor(mat, changedMat,ColorConversionCodes.BGR2RGB );Texture2D changedTex = Unity.MatToTexture(changedMat);GetComponent<;RawImage>;().texture = changedTex;}
Use this for initialization
*{}
Update is called once per frame
*{Mat mat = Unity.TextureToMat(this.texture);for(int yi = 0; yi <; mat.Height; yi++){for(int xi = 0; xi <; mat.Width; xi++){Vec3b v = mat.At<;Vec3b>;(yi,xi);float gr = 0.2126f * v[2] + 0.7152f * v[1] + 0.0722f * v[0];v[0] = (byte)gr;v[1] = (byte)gr;v[2] = (byte)gr;mat.Set<;Vec3b>;(yi, xi, v);}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<;RawImage>;().texture = changedTex;}
Use this for initialization
*{}
Update is called once per frame
*{Mat mat = Unity.TextureToMat(this.texture);for (int yi = 0; yi <; mat.Height; yi++){for (int xi = 0; xi <; mat.Width; xi++){Vec3b v = mat.At<;Vec3b>;(yi, xi);Debug.Log(v[0]);float gr = 0.2126f * v[2] + 0.7152f * v[1] + 0.0722f * v[0];if(gr <; 128){gr = 0;}else{gr = 255;}v[0] = (byte)gr;v[1] = (byte)gr;v[2] = (byte)gr;mat.Set<;Vec3b>;(yi, xi, v);}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<;RawImage>;().texture = changedTex;}
Use this for initialization
*{}
Update is called once per frame
*{Mat mat = Unity.TextureToMat(this.texture);float[] results = new float[256];float[,] grs = new float[mat.Height,mat.Width];for(int yi = 0; yi <; mat.Height; yi++){for(int xi = 0; xi <; mat.Width; xi++){Vec3b v = mat.At<;Vec3b>;(yi, xi);float gr = 0.2126f * v[2] + 0.7152f * v[1] + 0.0722f * v[0];grs[yi, xi] = gr;}}for(int thi = 1; thi <; 255; thi++){int w0 = 0;int w1 = 0;float M0 = 0;float M1 = 0;foreach(float gr in grs){if(gr <; thi){w0++;M0 += gr;}else{w1++;M1 += gr;}}Debug.Log(w0 + w1);float tmp0 = w0 == 0 ? 0 : M0 / w0;float tmp1 = w1 == 0 ? 0 : M1 / w1;results[thi] = ((float)w0 / (mat.Height * mat.Width)) * ((float)w1 / (mat.Height * mat.Width)) * Mathf.Pow(tmp0 - tmp1 , 2);}int z = 0;for(int i = 1; i <; 255; i++){if (results[i] >; results[z]) z = i;}for(int yi = 0; yi <; mat.Height; yi++){for(int xi = 0; xi <; mat.Width; xi++){if(grs[yi,xi] <; z){Vec3b v = new Vec3b();v[0] = (byte)0;v[1] = (byte)0;v[2] = (byte)0;mat.Set<;Vec3b>;(yi, xi, v);}else{Vec3b v = new Vec3b();v[0] = (byte)255; v[1] = (byte)255; v[2] = (byte)255;mat.Set<;Vec3b>;(yi, xi, v);}}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<;RawImage>;().texture = changedTex;}
Use this for initialization
*{}
Update is called once per frame
*{Mat mat = Unity.TextureToMat(this.texture);Mat changedMat = new Mat();Mat changedMat1 = new Mat();Cv2.CvtColor(mat, changedMat, ColorConversionCodes.BGR2HSV);for(int yi = 0; yi <; mat.Height; yi++){for(int xi = 0; xi <; mat.Width; xi++){Vec3b v = changedMat.At<;Vec3b>;(yi, xi);Debug.Log(v[0]);v[0] = (byte)((v[0] - 180) % 360);changedMat.Set<;Vec3b>;(yi, xi, v);}}Cv2.CvtColor(changedMat,changedMat1, ColorConversionCodes.HSV2BGR);Texture2D changedTex = Unity.MatToTexture(changedMat1);GetComponent<;RawImage>;().texture = changedTex;}
Use this for initialization
*{}
Update is called once per frame
*{Mat mat = Unity.TextureToMat(this.texture);for (int yi = 0; yi <; mat.Height; yi++){for (int xi = 0; xi <; mat.Width; xi++){Vec3b v = mat.At<;Vec3b>;(yi, xi);v[0] = (byte)(ReduceColor(v[0]));v[1] = (byte)(ReduceColor(v[1]));v[2] = (byte)(ReduceColor(v[2]));mat.Set<;Vec3b>;(yi, xi, v);}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<;RawImage>;().texture = changedTex;}
Use this for initialization
*{}
Update is called once per frame
*{Mat mat = Unity.TextureToMat(this.texture);for(int yi = 0; yi <; 16; yi++){for(int xi = 0; xi <; 16; xi++){Vector3 sum = new Vector3();for(int yj = 0; yj <; 8; yj++){for(int xj = 0; xj <; 8; xj++){Vec3b v = mat.At<;Vec3b>;(yi * 8 + yj,xi * 8 + xj);sum[0] += v[0];sum[1] += v[1];sum[2] += v[2];}}Vec3b ave = new Vec3b();ave[0] = (byte)(sum[0] / 64);ave[1] = (byte)(sum[1] / 64);ave[2] = (byte)(sum[2] / 64);for (int yj = 0; yj <; 8; yj++){for (int xj = 0; xj <; 8; xj++){mat.Set<;Vec3b>;(yi * 8 + yj, xi * 8 + xj, ave);}}}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<;RawImage>;().texture = changedTex;}
Use this for initialization
*{}
Update is called once per frame
*{Mat mat = Unity.TextureToMat(this.texture);for (int yi = 0; yi <; 16; yi++){for (int xi = 0; xi <; 16; xi++){Vec3b max = new Vec3b();for (int yj = 0; yj <; 8; yj++){for (int xj = 0; xj <; 8; xj++){Vec3b v = mat.At<;Vec3b>;(yi * 8 + yj, xi * 8 + xj);if (max[0] <; v[0]) max[0] = v[0];if (max[1] <; v[1]) max[1] = v[1];if (max[2] <; v[2]) max[2] = v[2];}}for (int yj = 0; yj <; 8; yj++){for (int xj = 0; xj <; 8; xj++){mat.Set<;Vec3b>;(yi * 8 + yj, xi * 8 + xj, max);}}}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<;RawImage>;().texture = changedTex;}
Use this for initialization
*{}
Update is called once per frame
*{Mat mat = Unity.TextureToMat(this.texture);Vector3[,] v = new Vector3[mat.Height, mat.Width];for (int yi = 0; yi <; mat.Height; yi++){for (int xi = 0; xi <; mat.Width; xi++){Vec3b vyx = mat.At<;Vec3b>;(yi, xi);v[yi, xi][0] = vyx[0];v[yi, xi][1] = vyx[1];v[yi, xi][2] = vyx[2];}}v = Gaussian(v, mat.Height, mat.Width);for(int yi = 0; yi <; mat.Height; yi++){for(int xi = 0; xi <; mat.Width; xi++){Vec3b vyx = new Vec3b();vyx[0] = (byte)v[yi, xi][0];vyx[1] = (byte)v[yi, xi][1];vyx[2] = (byte)v[yi, xi][2];mat.Set<;Vec3b>;(yi, xi, vyx);}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<;RawImage>;().texture = changedTex;}
Use this for initialization
*{}
Update is called once per frame
*{Mat mat = Unity.TextureToMat(this.texture);Mat changedMat = new Mat();Cv2.GaussianBlur(mat, changedMat, new Size(3,3),1.3,1.3);Texture2D changedTex = Unity.MatToTexture(changedMat);GetComponent<;RawImage>;().texture = changedTex;}
Use this for initialization
*{}
Update is called once per frame
*{Mat mat = Unity.TextureToMat(this.texture);Vector3[,] v = new Vector3[mat.Height, mat.Width];for (int yi = 0; yi <; mat.Height; yi++){for (int xi = 0; xi <; mat.Width; xi++){Vec3b vyx = mat.At<;Vec3b>;(yi, xi);v[yi, xi][0] = vyx[0];v[yi, xi][1] = vyx[1];v[yi, xi][2] = vyx[2];}}v = Median(v, mat.Height, mat.Width);for (int yi = 0; yi <; mat.Height; yi++){for (int xi = 0; xi <; mat.Width; xi++){Vec3b vyx = new Vec3b();vyx[0] = (byte)v[yi, xi][0];vyx[1] = (byte)v[yi, xi][1];vyx[2] = (byte)v[yi, xi][2];mat.Set<;Vec3b>;(yi, xi, vyx);}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<;RawImage>;().texture = changedTex;}
Use this for initialization
*{}
Update is called once per frame
*{Mat mat = Unity.TextureToMat(this.texture);Mat changedMat = new Mat();Cv2.MedianBlur(mat, changedMat, 3);Texture2D changedTex = Unity.MatToTexture(changedMat);GetComponent<;RawImage>;().texture = changedTex;}
Use this for initialization
*{}
Update is called once per frame

要素名でGroupByした後、グループ内の件数が2以上（※重複あり）に絞り込み、
最後にIGrouping.Keyからグループ化に使ったキーを抽出している。
*var duplicates = list.GroupBy(name =>; name).Where(name =>; name.Count() >; 1)
*List<;string>; cityNames = new List<;string>;() {"Tokyo", "Osaka", "Yokohama", "Nagoya", "Kobe","Tokyo", "Yokohama", "Sapporo", "Fukuoka", "Tokyo"};
"Tokyo"と"Yokohama"が重複しているリスト

対象年の1月1日(元旦)の曜日を取得する。
*DateTime gantan = new DateTime(targetYear, 1, 1);
対象年の1月において、引数で指定した曜日に該当する最初の日付を取得する
*DateTime date;
7日ずつ日付をずらして、対象年における指定した曜日の日付を全て取得する。
*List<;DateTime>; days = new List<;DateTime>;();
2019年の日曜日の日付を取得する。
*var days = DateUtils.FindWantDayOfWeek(2019, DayOfWeek.Sunday);

*var profile = new Dictionary<;string, string>;() {{"name", "お名前"},{"age", "３０歳"},{"address", "日本"},{"blood", "AB型"},};
サンプルデータ
*var profile = new Dictionary<;string, string>;() {{"name", "お名前"},{"age", "２０歳"},{"address", "日本"},{"blood", "AB型"},};
サンプルデータ
*var profile = new Dictionary<;string, string>;() {{"name", "お名前"},{"age", "２０歳"},{"address", "日本"},{"blood", "AB型"},};
サンプルデータ

rowsで結果を取得
*DataRow[] rows =
dataTableで結果を取得
*DataTable dataTable =

*il.Emit(Ret);
スタックにはJobHandleのみが残っているのでこれを返り値とする

喜
*var j = new KeyValuePair<;BlendShapePreset, float>;(BlendShapePreset.Joy,1);
怒
*var a = new KeyValuePair<;BlendShapePreset, float>;(BlendShapePreset.Angry,1);
哀
*var s = new KeyValuePair<;BlendShapePreset, float>;(BlendShapePreset.Sorrow,1);
楽
*var f = new KeyValuePair<;BlendShapePreset, float>;(BlendShapePreset.Fun,1);

コンストラクタで生成 =&gt; 読み辛い。「この男、素人か。」と思う。
*var ctr500milli = new TimeSpan(0, 0, 0, 0, 500);
FromMilliSecondで生成 =&gt; 定石
*var fromMilli500 = TimeSpan.FromMilliseconds(500);
拡張メソッドを定義して以下のように書く。
*var ext500Milli = 500.Milliseconds();
3.5秒待つ場合は以下のような感じ
*await Task.Delay(3.5.Seconds());

円周率=Math.PI
*double a = r * r * Math.PI;

*if (!Enum.IsDefined(value.GetType(), value))*{
Enumに存在しない値の場合、空文字を返す
Display属性が定義してある場合、リソースの値を返す
*var nameProperty = attribute.ResourceType.GetProperty(attribute.Name,
Display属性が定義していなかった場合、Enumの名称を返す
*return value.ToString();

Object 型のメソッド呼び出しでもオーバーライドされた Equals メソッドが使用されます。
*Assert.IsTrue(s2AsObj.Equals(s1));
リテラルから生成されていない値とは一致しません。
*Assert.IsFalse(Object.ReferenceEquals("s", s1));
文字列同士なら一致します。
*Assert.IsTrue(sb1AsStr.Equals(sb1.ToString()));
代入された同一インスタンスとは一致します。
*Assert.IsTrue(Object.Equals(sb1, sb1Assigned));

*Console.WriteLine(enumerator2.Current);
このCurrentは一番目の要素を指すべき

*if (Input.GetKeyDown(KeyCode.Return)) StartMove();*if (Input.GetKeyDown(KeyCode.Space)) StartReturn();
Test

*{{Filter.All, "all"},{Filter.Closed, "closed"},{Filter.Members, "members"},{Filter.Open, "open"},{Filter.Organization, "organization"},{Filter.Public, "public"},{Filter.Starred, "starred"},};
Enumを作るごとにこれをコピペして中身を書き換えるのは大変

*var list = titles.Select(title =>; new { Name = title, Index = ToInt(title) })
{Name,Index}という匿名クラスのリストを作り、Indexに従ってソートする。

要素数が10で、値が「あいうえお」の配列を生成する
*var array = Enumerable.Repeat("あいうえお",10).ToArray();
要素数が10で、値が「あいうえお」のリストを生成する
*var list = Enumerable.Repeat("あいうえお",10).ToList();
5から始まり、7個の連続した値（5,6,7,8,9,10,11）の配列を生成する。
*var array = Enumerable.Range(5, 7).ToArray();
5から始まり、7個の連続した値（5,6,7,8,9,10,11）のリストを生成する。
*var list = Enumerable.Range(5, 7).ToList();
「1番目,2番目,...10番目」という文字列を作成する。
*var txt = string.Join(",", Enumerable.Range(1, 10).Select(num =>; num.ToString() + "番目"));

*if (rec.ReturnBufferSize() - (int)rec.ReturnBufferSize() != 0)*{
BufferSizeがfloatだとめんどうなのでエラーメッセージで忠告する
*{print("保存開始");}
保存開始時
*{print("保存中:" + Math.Truncate(percent * 100.0) + "/" + "100％");}
保存中　idという引数はよくわからん
*{print("保存完了:" + "100" + "/" + "100％" + filepath);isSave = false;}
保存終了時　idという引数はよくわからん
*if (Input.GetKeyDown(KeyCode.R) &amp;&amp; isRec == false)*{
録画 -&gt;　録画中、セーブ中は押せない
*{isRec = true;float second = 1f;int count = 0;//録画カウントダウンprint("録画開始まで");yield return new WaitForSeconds(second);print("3");yield return new WaitForSeconds(second);print("2");yield return new WaitForSeconds(second);print("1");yield return new WaitForSeconds(second);print("開始");rec.Record();//残り秒数の表示for (int i = 0; i <; rec.ReturnBufferSize(); i++){yield return new WaitForSeconds(second);count++;print("録画時間" + ":" + count + "/" + rec.ReturnBufferSize()+"秒");}//録画終了print("録画終了");//保存開始rec.Save();yield return new WaitForSeconds(second);isRec = false;StopCoroutine(runCoroutine);}
録画開始～終了まで
録画カウントダウン
*print("録画開始まで");
*for (int i = 0; i <; rec.ReturnBufferSize(); i++)*{
残り秒数の表示
録画終了
*print("録画終了");
保存開始
*rec.Save();

*await SendRequest(httpClient, log, "https:
httpstat.us429");
*log.LogInformation("finish func");*}
await SendRequest(httpClient, log, "https:httpstat.us/200?sleep=11000");

*Console.Write($"{result, 2}");
resultを最低二桁で表示

「定義済のint型変数の値をインクリメントする」だけの処理をAction型変数に代入する
*var num = 0;
*Action action1 = delegate () { num++; };
1．delegateキーワードを使った古典的な書き方
*var action2 = new Action(delegate () { num++; });
2. var を使った書き方
3. ラムダ式で書く
*Action action3 = () =>; num++;
4. var を使った書き方
*var action4 = new Action(() =>; num++);
*Action<;int>; action5 = delegate (int num) { num++; };
例として「int型の引数の値をインクリメントする」だけの処理をAction&lt;int&gt;型変数に代入する
*Action<;int>; action5 = delegate (int num) { num++; };
1．delegateキーワードを使った古典的な書き方
*var action6 = new Action<;int>;(delegate (int num) { num++; });
2. var を使った書き方
3. ラムダ式で書く
*Action<;int>; action7 = num =>; num++;
4. var を使った書き方
*var action8 = new Action<;int>;(num =>; num++);

*ComplexObjectResponse response = new ComplexObjectResponse() { };
レスポンスのインスタンスは使いまわす
オブジェクトのキーとインデックスの組み合わせ
*Dictionary<;string, int>; indexes = new Dictionary<;string, int>;();
*foreach (ComplexHeader header in GetComplexHeaders(request))*{
header
*foreach (ComplexItem item in GetComplexItems(request))*{
items
*foreach (ComplexSubItem subitem in GetComplexSubItems(request))*{
subitems
*yield return new ComplexHeader() { Id = "1", Description = "オブジェクト1" };
実際にはデータベースなどからデータを取得して返すような実装になります。
*yield return new ComplexItem() { Id = "1", CreatedDate = createdDate, Value = 1001 };
実際にはデータベースなどからデータを取得して返すような実装になります。
*yield return new ComplexSubItem() { Id = "1", Value = "サブアイテム1-1" };
実際にはデータベースなどからデータを取得して返すような実装になります。
取得したオブジェクトを格納するリスト
*List<;ComplexObject>; objects = new List<;ComplexObject>;();

*if (list.Count == 0
つまり値の変化が無かった

*ilgen.Emit(OpCodes.Ret);
戻り値とせよ

暗号化されたGuest Issuer secretをストレージから読み込む。
*ProtectedString secret = LoadEncryptedGuestIssuerSecret();
GuestIssuerClientのインスタンスを作成する。
*var guestIssuer = TeamsAPI.CreateVersion1GuestIssuerClient(secret, "your_guest_issuer_id");
Guest Userを作成する。
*var guest = (await guestIssuer.CreateGuestUserAsync("my-guest-id", "ゲスト太郎")).GetData();
ゲストユーザ用のTeamsAPIClientインスタンスを作成する(リトライ機能付き)。
*var teams = TeamsAPI.CreateVersion1Client(guest, new TeamsRetryHandler(4));
*Console.WriteLine("メッセージが投稿されました: ID = {0}", message.Id);
ゲストユーザからメッセージを投稿する。

*public virtual DbSet<;BUSHO>; BUSHOs { get; set; }
Table
テーブル名を複数形化せずモデルクラス名をそのまま使う
*modelBuilder.Conventions.Remove<;System.Data.Entity.ModelConfiguration.Conventions.PluralizingTableNameConvention>;();

*{if (!string.IsNullOrEmpty(ArgSerialized) &amp;&amp; !string.IsNullOrEmpty(ArgType)){DeserializeFromString();}if (MethodArgument != null){TargetObject.SendMessage(CallbackName, MethodArgument);}else{TargetObject.SendMessage(CallbackName);}}
実行時MethodArgumentをデシリアライズ
*{if (string.IsNullOrEmpty(ArgSerialized) || string.IsNullOrEmpty(ArgType)){return;}//System.TypeとUnityEngine.Typeのデシリアライズvar type = System.Type.GetType(ArgType);if (type == null)type = System.Reflection.Assembly.Load("UnityEngine.dll").GetType(ArgType);if (type == typeof(string))MethodArgument = ArgSerialized;if (type == typeof(bool))MethodArgument = bool.Parse(ArgSerialized);else if (type == typeof(int))MethodArgument = int.Parse(ArgSerialized);else if (type == typeof(float))MethodArgument = float.Parse(ArgSerialized);else if (type == typeof(double))MethodArgument = double.Parse(ArgSerialized);else if (type == typeof(Vector2))MethodArgument = Vector2FromString(ArgSerialized);else if (type == typeof(Vector3))MethodArgument = Vector3FromString(ArgSerialized);else if (type == typeof(Vector4))MethodArgument = Vector4FromString(ArgSerialized);}
デシリアライズ処理
System.TypeとUnityEngine.Typeのデシリアライズ
*var type = System.Type.GetType(ArgType);
呼び出し　これは好きなタイミングで呼ぶ
*MethodList.ForEach(item =>; item.Execute());
*{Debug.Log("Test Log : " + t);}
テスト用メソッド群
ReorderableList作成
*var ListProp = serializedObject.FindProperty("MethodList");
メソッド名のインデックスを取得(見つからなかったらNoneである0にする)
*int NameIndex = methods.FindIndex(item =>; item == m.CallbackName);
*if (param.GetParameters()[0].ParameterType == typeof(string))*{
フィールド用の描画及びMethodArgumentの初期化をベタ書き
*{if (m == null || !m.TargetObject){return null;}List<;string>; result = new List<;string>;();result.Add("None");var methods = m.TargetObject.GetType().GetMethods(BindingFlags.Instance | BindingFlags.Public).Where(x =>; x.DeclaringType == m.TargetObject.GetType()).Where(x =>; x.GetParameters().Length <;= 1).Select(x =>; x.Name).ToArray();result.AddRange(methods);return result;}
メソッドの取得(SendMessageを使うので引数が1以下かつpublicに限定)

優先度１

整数値
*Matcher Number = '1'.To('9') + '0'.To('9')._0Max();
アルファベット
*Matcher Alphabet = ('A'.To('Z') | 'a'.To('z'));
*Matcher Identifier = (Alphabet | '_') + (Alphabet | '0'.To('9') | '_')._0Max();*// 「リテラル値式」のマッチャーを作る。(但し中身は空っぽ)
識別子
「リテラル値式」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher LiteralExp = new RecursionMatcher();
「括弧式」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher ParenExp = new RecursionMatcher();
「代入可能式」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher AssignableExp = new RecursionMatcher();
「関数呼び出し式」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher FunctionCallExp = new RecursionMatcher();
「メンバアクセス式」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher MemberAccessExp = new RecursionMatcher();
「インデックスアクセス式」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher IndexAccessExp = new RecursionMatcher();
「後置デクリメント」のマッチャーを作る。(但し中身は空っぽ)
*Matcher PostDecrementExp = AssignableExp + "--";
「後置インクリメント」のマッチャーを作る。(但し中身は空っぽ)
*Matcher PostIncrementExp = AssignableExp + "++";
*Matcher Priority1Exp = LiteralExp | Identifier | ParenExp | AssignableExp |*FunctionCallExp | IndexAccessExp | MemberAccessExp | PostDecrementExp | PostIncrementExp ;
優先順位１式
優先度２

「前置デクリメント」のマッチャーを作る。(但し中身は空っぽ)
*Matcher PreDecrementExp = "--" + AssignableExp;
「前置インクリメント」のマッチャーを作る。(但し中身は空っぽ)
*Matcher PreIncrementExp = "++" + AssignableExp;
「前置マイナス」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher PreMinusExp = new RecursionMatcher();
「前置プラス」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher PrePlusExp = new RecursionMatcher();
優先順位２式
*Matcher Priority2Exp = PreDecrementExp | PreIncrementExp | PreMinusExp | PrePlusExp ;
優先順位２以上式
*Matcher PriorityAbove2Exp = Priority1Exp | Priority2Exp ;
優先度３

「乗除算式」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher MulDivExp = new RecursionMatcher();
優先順位３式
*Matcher Priority3Exp = MulDivExp ;
優先順位３以上式
*Matcher PriorityAbove3Exp = PriorityAbove2Exp | Priority3Exp ;
優先度４

「加減算式」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher AddSubExp = new RecursionMatcher();
優先順位４式
*Matcher Priority4Exp = AddSubExp ;
優先順位４式
*Matcher PriorityAbove4Exp = PriorityAbove3Exp | Priority4Exp ;
(優先順位の低い演算子を増やしたい場合はここに挿入する。)

式の全て
*Matcher Exp = PriorityAbove4Exp;
優先度９９９

代入演算文
*Matcher AssignStatement = AssignableExp + '=' + Exp;
以下、中身が未設定なマッチャーの中身を設定

括弧式の中身
*ParenExp.Inner = '(' +
*LiteralExp | Identifier | ParenExp | FunctionCallExp |*IndexAccessExp | MemberAccessExp | PostDecrementExp | PostIncrementExp |
代入可能式を除く優先順位１式
優先順位２以下の全ての式
*Priority2Exp | Priority3Exp | Priority4Exp
*AssignableExp.Inner = Identifier | MemberAccessExp | IndexAccessExp | ( '(' + AssignableExp + ')' );*// 関数呼び出し式の中身
代入可能式の中身
関数呼び出し式の中身
*FunctionCallExp.Inner = (FunctionCallExp | IndexAccessExp | AssignableExp) + '(' + Exp._0Max(',') + ')';
インデックスアクセス式の中身
*IndexAccessExp.Inner = (FunctionCallExp | IndexAccessExp | AssignableExp) + '[' + Exp._1Max(',') + ']';
*MemberAccessExp.Inner = Priority1Exp + '.' + Identifier;*// 前置マイナス式の中身
メンバアクセス式の中身
前置マイナス式の中身
*PreMinusExp.Inner = '-' + (Priority1Exp | PreDecrementExp | PreIncrementExp | PrePlusExp);
前置プラス式の中身
*PrePlusExp.Inner = '+' + (Priority1Exp | PreDecrementExp | PreIncrementExp | PreMinusExp);
乗除算式の中身
*MulDivExp.Inner =  PriorityAbove3Exp + ('*'._() | '/') + PriorityAbove2Exp;
加減算式の中身
*AddSubExp.Inner =  PriorityAbove4Exp + ('+'._() | '-') + PriorityAbove3Exp;

*Bitmap grayBmp = new Bitmap(width, height);
グレースケールの画像。
*for (int i = 0; i <; width; i++)*{
全ピクセルを1つずつグレースケールに変換する。
NTSC規格などに準拠せず、RGB値の平均値をグレースケールに変える。
https:dobon.net/vb/dotnet/graphics/grayscale.html
*Color pixelColor = bmp.GetPixel(i, j);
RGBだけでなく、アルファ値もセットする。
*Color grayColor = Color.FromArgb(pixelColor.A, grayScale, grayScale, grayScale);

ウィンドウに既にコンテンツが表示されている場合は、アプリケーションの初期化を繰り返さずに、
ウィンドウがアクティブであることだけを確認してください
*if (rootFrame == null)
ナビゲーション コンテキストとして動作するフレームを作成し、最初のページに移動します
*rootFrame = new Frame();
これを追加
*Xamarin.Forms.Forms.Init(e);
追加
*LoadApplication(new TakeMeThereXamarinForms.App(new UwpInitializer()));
*{/// <;summary>;/// それ自体で使用できる空白ページまたはフレーム内に移動できる空白ページ。/// <;/summary>;public sealed partial class MainPage{public MainPage(){this.InitializeComponent();LoadApplication(new TakeMeThereXamarinForms.App(new UwpInitializer()));}}public class UwpInitializer : IPlatformInitializer{public void RegisterTypes(IContainerRegistry containerRegistry){// Register any platform specific implementations}}}
空白ページの項目テンプレートについては、https:go.microsoft.com/fwlink/?LinkId=402352&amp;clcid=0x411 を参照してください

*case string str:
when obj is string
*while(statement)*{
while template
*{piyopiyo} while(statement);
do while template
*for(initializer; condition; iterator)*{
template
*for(int i=6; i<;6; i++)*{
ex.

float ← double は暗黙の型変換不可
*Assert.IsFalse(float.NaN.Equals(double.NaN));
*{One = 1,Two}
列挙型定義
フィールド
*private ZeroUndefined zeroUndefinedUnassigned;
*{// 0 はメンバとして定義されていません。Assert.IsFalse(Enum.IsDefined(typeof(ZeroUndefined), 0));// ★既定値はメンバの定義がなくても 0 です。 default(T) もフィールドも同様です。Assert.AreEqual((ZeroUndefined)0, default(ZeroUndefined));Assert.AreEqual((ZeroUndefined)0, this.zeroUndefinedUnassigned);// ★リテラルや定数の 0 は特別に列挙型への暗黙変換が許可されているため、キャストなしで代入できます。ZeroUndefined undefinedZero = 0;/* int 型変数の代入はコンパイルエラーになります。int zero = 0;ZeroUndefined undefinedZero = zero;*/// 0 はどのメンバとも一致しません。foreach (ZeroUndefined each in Enum.GetValues(typeof(ZeroUndefined))){Assert.IsTrue(undefinedZero != each);}// int にキャストすると 0 になります。Assert.IsTrue((int)undefinedZero == 0);// 0 をキャストしたものと一致します。Assert.IsTrue(undefinedZero == (ZeroUndefined)0);// ★リテラルや定数の 0 は特別に列挙型への暗黙変換が許可されているため、キャストなしで等価比較できます。Assert.IsTrue(undefinedZero == 0);Assert.IsTrue(0 == undefinedZero);// ★int 型との Equals 比較は false になります。Assert.IsFalse(undefinedZero.Equals(0));Assert.IsFalse(0.Equals(undefinedZero));// 最大定義値を超える場合も数値は保持されます。ZeroUndefined maxValue = (ZeroUndefined)int.MaxValue;Assert.IsTrue(maxValue == (ZeroUndefined)int.MaxValue);Assert.IsTrue((int)maxValue == int.MaxValue);}
検証
0 はメンバとして定義されていません。
*Assert.IsFalse(Enum.IsDefined(typeof(ZeroUndefined), 0));
★既定値はメンバの定義がなくても 0 です。 default(T) もフィールドも同様です。
*Assert.AreEqual((ZeroUndefined)0, default(ZeroUndefined));
★リテラルや定数の 0 は特別に列挙型への暗黙変換が許可されているため、キャストなしで代入できます。
*ZeroUndefined undefinedZero = 0;
*foreach (ZeroUndefined each in Enum.GetValues(typeof(ZeroUndefined)))*{
0 はどのメンバとも一致しません。
int にキャストすると 0 になります。
*Assert.IsTrue((int)undefinedZero == 0);
0 をキャストしたものと一致します。
*Assert.IsTrue(undefinedZero == (ZeroUndefined)0);
★リテラルや定数の 0 は特別に列挙型への暗黙変換が許可されているため、キャストなしで等価比較できます。
*Assert.IsTrue(undefinedZero == 0);
★int 型との Equals 比較は false になります。
*Assert.IsFalse(undefinedZero.Equals(0));
最大定義値を超える場合も数値は保持されます。
*ZeroUndefined maxValue = (ZeroUndefined)int.MaxValue;

*[HttpGet("sample
{segments}")] *つけ忘れ
最後の一つで条件分岐
*string postfix = segmentsArray[segmentsArray.Length - 1];

*Thread.Sleep(100);
Task.Delay(100);Delayが使えればDelayが良いな･･･。

（省略）
*)
*{var hostingEnvironment = sp.GetRequiredService<;IHostingEnvironment>;();return new ConventionBasedStartup(StartupLoader.LoadMethods(sp, startupType, hostingEnvironment.EnvironmentName));});
(省略)
(省略)
*});
（省略）
*services.AddSingleton<;IHostingEnvironment>;(_hostingEnvironment);
（省略）
*var configuration = builder.Build();
（省略）
*,,,
*foreach (var value in urls.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries))*{
（省略）
*foreach (var component in _components.Reverse())*{
（省略）

int[] x = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();でもよい
*Console.WriteLine(Enumerable.Range(x[0], x[1] - x[0] + 1).Count(q =>; x[2] % q == 0));

*driver.FindElement(By.XPath("
input[@value='登録']")).Submit();

通常のアヒルを生成
*Duck duck = new Duck(new SmallQuack());
アメリカホシハジロを生成
*Duck redHead = new RedHeadDuck(new Quack());
ゴムのアヒルを生成
*Duck rubber = new RubberDuck(new Squeak());
偽物のアヒルを生成
*Duck decoy = new DecoyDuck(new MuteQuack());
アヒルの鳴き声
*duck.quack();
アメリカホシハジロの鳴き声
*redHead.quack();
ゴムのアヒルの鳴き声
*rubber.quack();
偽物のアヒルの鳴き声
*decoy.quack();
リストに格納して実行することもできます
*List<;Duck>; duckList = new List<;Duck>;();

*this[index] = new T();
初期値
*public virtual IEnumerable<;int>; GetAllIndexes() {for (int y = 1; y <;= this.YSize; y++) {for (int x = 1; x <;= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する
*public virtual IEnumerable<;int>; EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index); index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む
(x,y)から右(水平)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Horizontal(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Virtical(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantR(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantL(int x, int y)

*public class MyControl : UserControl {public static DependencyProperty XXXProperty= DependencyProperty.Register(nameof(XXX),typeof(bool),typeof(MyControl),new PropertyMetadata());public bool XXX {get { return (bool)GetValue(XXXProperty); }set { SetValue(XXXProperty, value); }}}
UserControlはDependencyObjectを継承している

*nameof(data)
"data"がゲットできる

普通のIEnumerable
*a = System.Linq.Enumerable.Range(0, 100_000_000);
配列
*c = a.ToArray();
無駄にWhereしてみる
*d = a.Where(x =>; x == x);
Listの作成
*var intList = Enumerable.Range(0, 100_000_000).ToList();
ここではまだ評価しない
*var odd = intList.Where(x=>;x % 2 != 0);
Countで中身を見なければならないので、ここで評価
*return odd.Count();
*if (source is Iterator<;TSource>;)*{
(1)
*if (source is TSource[])*{
(2)
*if (source is List<;TSource>;)*{
(3)
*while (e.MoveNext())*{
(2)
Listの作成
*var intList = Enumerable.Range(0, 100_000_000).ToList();
ここではまだ評価しない
*var odd = intList.Where(x=>;x % 2 != 0);
Countで中身を見なければならないので、ここで評価
*return odd.Count();
ICollection&lt;T&gt;ではないし、
*ICollection<;TSource>; collection = source as ICollection<;TSource>;;
ICollectionでもない
*ICollection collection2 = source as ICollection;
ここまで来る
*int num = 0;
元クラスのメンバ
*internal int state;
派生クラスのメンバ
*private List<;TSource>; source;
こいつが理想だが
*return a.Where(x =>; (x % 9_999_991 == 0) &amp;&amp; (x % 2 == 0)).Count();
これよりは
*return a.Where(x =>; x % 2 == 0).Where(x =>; x % 9_999_991 == 0).Count();
こっちのほうがマシ
*return a.Where(x =>; x % 9_999_991 == 0).Where(x =>; x % 2 == 0).Count();

Object.Equals が int の Equals を呼び出すので値で比較されます。
*Assert.IsTrue(o1.Equals(o2));
o1 != o2 かつ o1 != null なら上の o1.Equals(o2) と同じ結果となります。
*Assert.IsTrue(Object.Equals(o1, o2));
★ボックス化（値型 → object）すると参照比較になるので一致しません。
*Assert.IsFalse(o1 == o2);
★引数として渡されるときにボックス化されるので一致しません。
*Assert.IsFalse(Object.ReferenceEquals(1, 1));
比較演算子では、int が long に暗黙的に型変換され、long 同士として比較されます。
*Assert.IsTrue(i == l);
暗黙の型変換ができるなら Equals で比較できます。
*Assert.IsTrue(l.Equals(i));
★暗黙の型変換ができないと Equals は false を返します。
コンパイルは通り、例外も発生しないので見逃しがちです。
*Assert.IsFalse(i.Equals(l));
★異なる型へのボックス化解除は失敗します。
*object iBoxed = i;
int 型をボックス化しているので long 型に戻すことはできません。（InvalidCastException が発生）
*bool b = (l == (long)iBoxed);
実行されるのは Object.Equals です。
字面だけ見ると true を期待してしまいそう(?)です。
*Assert.IsFalse(Type.Equals(1, 2));

GameObjectの設定
*[SerializeField] GameObject newtext;
CubeRendererの設定
*[SerializeField] Renderer RendererCube;
Cubeが消えたところにTextを表示させる。
*Vector3 pos = new Vector3(-1.0f, 1.0f, 0);
*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame
*{//Rendererを偽（オフ）にする。RendererCube.enabled = false;//new Textクローンの生成Instantiate(newtext, transform.position +pos, Quaternion.identity);//4f後にCubeが消えるDestroy(gameObject, 4f);}
Sphereが当たった時の設定
Rendererを偽（オフ）にする。
*RendererCube.enabled = false;
*Instantiate(newtext, transform.position +pos, Quaternion.identity);*//4f後にCubeが消える
new Textクローンの生成
4f後にCubeが消える
*Destroy(gameObject, 4f);

*Math.Abs(x-y) <; EPSILON
true

ほげほげ
*}
ほげほげ
*}
ほげほげ
*}

*if (viewPos.x >;= 0 &amp;&amp; viewPos.x <;=1 &amp;&amp;*viewPos.y >;= 0 &amp;&amp; viewPos.y ;=1 &amp;&amp; viewPos.z >;=0) {
viewPosのx座標とy座標が0以上1以下かつzが0以上だったらみえる

*WriteVal(st, 2, 8);
wBitsPerSample

*int[][] data = new int[3][];
3つのary格納

参照サイト
https:qiita.com/okazuki/items/a4eb94f608bbc26c6a5f
https:usefuledge.com/csharp-webscraping-anglesharp.html
var urlstring = "https:www.yahoo.co.jp/";
*WebClient wc = new WebClient();
*// foreach (var item in document.QuerySelectorAll("h1.thumb"))*foreach (var item in document.QuerySelectorAll("section#tabpanelTopics1 li"))
Console.WriteLine(document.Title);
*foreach (var item in document.QuerySelectorAll("section#tabpanelTopics1 li"))*{
foreach (var item in document.QuerySelectorAll("h1.thumb"))

レスポンスのインスタンスは使いまわす
*BufferResponse response = new BufferResponse();
実際には条件に該当するファイルなどから列挙するように実装します。
*yield return new FileStream(@"image1.jpg", FileMode.Open, FileAccess.Read);
単純にダイアログフォームで表示します。
*using (Image image = Image.FromStream(stream))

ここに処理を追加
*};

*Velocity.y = JumpPower;
Velocity.yをJumpPowerにする

*public class BindingProxy : Freezable {protected override Freezable CreateInstanceCore()=>; new BindingProxy();//依存関係プロパティを定義するpublic static readonly DependencyProperty DataProperty= DependencyProperty.Register(nameof(Data),typeof(object),typeof(BindingProxy),new PropertyMetadata(null));public object Data {get { return (object)GetValue(DataProperty); }set { SetValue(DataProperty, value); }}}
Freezableを継承する
依存関係プロパティを定義する
*public static readonly DependencyProperty DataProperty

*{public class InputStructures {[DllImport("user32.dll", SetLastError = true)]public extern static intSendInput(int length, ref InputEvent events, int size);[DllImport("user32.dll", EntryPoint = "MapVirtualKeyA")]public extern static int MapVirtualKey(int wCode, int wMapType);public const int MOUSEEVENTF_MOVE       = 0x01;public const int MOUSEEVENTF_LEFTDOWN   = 0x02;public const int MOUSEEVENTF_LEFTUP     = 0x04;public const int MOUSEEVENTF_RIGHTDOWN  = 0x08;public const int MOUSEEVENTF_RIGHTUP    = 0x10;public const int MOUSEEVENTF_MIDDLEDOWN = 0x20;public const int MOUSEEVENTF_MIDDLEUP   = 0x40;public const int KEYEVENTF_KEYUP        = 0x02;public const int MAPVK_VK_TO_VSC        = 0;[StructLayout(LayoutKind.Sequential)]public struct InputEvent{public int Type;public InputUnion Data;}[StructLayout(LayoutKind.Explicit)]public struct InputUnion{[FieldOffset(0)] public MouseInput Mouse;[FieldOffset(0)] public KeyboardInput Keyboard;}[StructLayout(LayoutKind.Sequential)]public struct MouseInput{public int X;public int Y;public int MouseData;public int Flags;public int Time;public IntPtr ExtraInfo;}[StructLayout(LayoutKind.Sequential)]public struct KeyboardInput{public short VirtualKey;public short ScanCode;public int Flags;public int Time;public IntPtr ExtraInfo;}}[ComVisible(true)]public class Bridge : InputStructures {public class ControllerEvent{public string type  { get; set; }public string key   { get; set; }public int button   { get; set; }public float x      { get; set; }public float y      { get; set; }}public void dispatch(string s){var e = JsonSerializer.Deserialize<;ControllerEvent>;(s);switch(e.type){case "mousemove":   SendMouseMove(e);   break;case "mousedown":   SendMouse(e);       break;case "mouseup":     SendMouse(e);       break;case "keydown":     SendKeyboard(e);    break;case "keyup":       SendKeyboard(e);    break;}}static readonly Dictionary<;string,object>;flag = new Dictionary<;string,object>;(){{"keydown",     0},{"keyup",       KEYEVENTF_KEYUP},{"mousemove",   MOUSEEVENTF_MOVE},{"mousedown",   new []{MOUSEEVENTF_LEFTDOWN,MOUSEEVENTF_MIDDLEDOWN,MOUSEEVENTF_RIGHTDOWN,}},{"mouseup",     new []{MOUSEEVENTF_LEFTUP,MOUSEEVENTF_MIDDLEUP,MOUSEEVENTF_RIGHTUP,}}};static void SendMouseMove(ControllerEvent e){var v = new InputEvent(){Type = 0};v.Data.Mouse    = new MouseInput(){Flags       = (int)flag[e.type],X           = (int)Math.Round(e.x),Y           = (int)Math.Round(e.y),};SendInput(1, ref v, Marshal.SizeOf(v));}static void SendMouse(ControllerEvent e){var v = new InputEvent(){Type = 0};v.Data.Mouse    = new MouseInput(){Flags       = (int)(flag[e.type] as int[])[e.button]};SendInput(1, ref v, Marshal.SizeOf(v));}static void SendKeyboard(ControllerEvent e){if (Keys.TryParse(e.key, out Keys k)){var v = new InputEvent(){Type = 1};v.Data.Keyboard = new KeyboardInput(){VirtualKey  = (short)k,ScanCode    = (short)MapVirtualKey((int)k,MAPVK_VK_TO_VSC),Flags       = (int)flag[e.type],};SendInput(1, ref v, Marshal.SizeOf(v));}}}public class Browser : Form {public Browser(string html){ClientSize = new System.Drawing.Size(600,400);Text = "Gamepad";var v = new WebView2(){Source  = new Uri(GetPath()+"\\"+html),Size    = ClientSize,};v.NavigationCompleted += (s,e) =>;v.CoreWebView2.AddHostObjectToScript("bridge",new Bridge());SizeChanged += (s,e) =>; v.Size = ClientSize;Controls.Add(v);}private static string GetPath(){var p = System.Diagnostics.Process.GetCurrentProcess();return System.IO.Path.GetDirectoryName(p.MainModule.FileName);}}static class Program{[STAThread]static void Main(){Application.SetHighDpiMode(HighDpiMode.SystemAware);Application.EnableVisualStyles();Application.SetCompatibleTextRenderingDefault(false);Application.Run(new Browser("Gamepad.html"));}}}
https:www.it-swarm-ja.com/ja/c%23/user32dll%e3%81%aesendinput%e3%82%92%e4%bb%8b%e3%81%97%e3%81%a6%e3%82%ad%e3%83%bc%e3%82%92%e9%80%81%e4%bf%a1%e3%81%99%e3%82%8b/1068919389/

*var morake = "hello";
as string

べき乗計算はMathクラスのPowメソッドを使う。ex.double result = Math.Pow(2, 3); resultは8
*Console.WriteLine(x);
String.SplitメソッドとはStringクラスメソッドの一つで、文字列を指定した区切り文字で分割し配列に格納する場合に使う
*int a = int.Parse(str[0]);

*Type[] paramTypes = new Type[] { typeof(bool).MakeByRefType() };
引数を false から true に変える ChangeByRefToTrue メソッドを呼び出す。
列挙型か。
*bool isEnum = type.IsEnum;
値型か。
*bool isValueType = type.IsValueType;
Nullを許可する値型か。
*bool isNullableValueType = (Nullable.GetUnderlyingType(type) != null);
TProperty が object の場合、ボックス化によって UnaryExpression となる。
*var body = (UnaryExpression)lambda.Body;
使用例
*string propertyName = GetPropertyName((Sample s) =>; s.PublicProperty);

*#elif GG
else ifと同じ
ここには入らない。
#elseelseと同じ
ここには入らない。
#endifif文がここまでという宣言。
*}
こんな感じに閉じることが出来る。
*#region
必要
*using System.Diagnostics;
TESTが存在する際に実行される処理
*}
戻り値がvoidじゃない為、エラーになる
*[Conditional("TEST")]

*if (!pri.IsInRole(WindowsBuiltInRole.Administrator))*{
管理者権限以外での起動なら、別プロセスで本アプリを起動する
別プロセスで本アプリを起動する
*Process.Start(proc);
現在プロセス終了
*return;
*if (!pri.IsInRole(WindowsBuiltInRole.Administrator))*{
管理者権限以外での起動なら, 別プロセスで本アプリを起動する
別プロセスで本アプリを起動する
*Process.Start(proc);
現在プロセス終了
*return;

*while (e.MoveNext())*{
(2)
*while (e.MoveNext())*,,,
(2)

適当なデータです
*yield return 0;

VerticalOptions = LayoutOptions.FillAndExpand,縦方向に余白を最大限に利用する
*HeightRequest = 200,

*this[index] = new T();
初期値
*public virtual IEnumerable<;int>; GetAllIndexes() {for (int y = 1; y <;= this.YSize; y++) {for (int x = 1; x <;= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する
*public virtual IEnumerable<;int>; EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index); index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む
(x,y)から右(水平)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Horizontal(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Virtical(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantR(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantL(int x, int y)

RegionにViewを読み出す ★重要
*regionManager.RegisterViewWithRegion("ContentRegion", typeof(ViewA));
RegionにViewを読み出す ★重要
*var view = _container.Resolve<;ViewA>;();
概要:
Initializes a new instance of Prism.Commands.CompositeCommand.

パラメーター:
monitorCommandActivity:
Indicates when the command activity is going to be monitored.
*public CompositeCommand(bool monitorCommandActivity);
*bool IsActive { get; set; }
Gets or sets a value indicating whether the object is active.
ナビゲーションが移る前にコールされる。
trueを返すと、このインスタンスが使いまわされる。
falseを返すと、別のインスタンスが作成される。
サンプルの動作だとボタンクリックの度にタブが増えていく。
*bool IsNavigationTarget(NavigationContext navigationContext);
ナビゲーションが他に移る時にコールされる。
*void OnNavigatedFrom(NavigationContext navigationContext);
ナビゲーションが移ってきた時にコールされる。
これでカウンタをインクリメントしていた。
*void OnNavigatedTo(NavigationContext navigationContext);
*private void Regions_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)*{
こちらはアプリ起動直後に1回しか来ない (xaml "ContentRegion" の追加)
こちらはボタンクリック(ViewA/B)追加の度にAddが来る
ViewAインスタンスが消える際にはRemoveが来る
*private void Views_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
*bool KeepAlive { get; }
インスタンスを非アクティブ化時に保持するか？
*{if (x != null &amp;&amp; x.Count() >; 0)SelectedItemText = x.FirstOrDefault().ToString();});
This command will be executed when the selection of the ListBox in the view changes.

定義部
---------------------------
出力するクラスのnamespace
*%namespace GPPGCalculator2
出力するクラス名
*%scannertype CalculatorScanner
出力するクラスのアクセシビリティ
*%visibility internal
トークンに使用するenumの型名
*%tokentype Token
オプション
stack          : これを付けると、状態をスタックに保存できるようになる。
C言語のコメント(/*  */)の解釈のように、状態を管理したい場合に使用する。
電卓では不要だが付けておく。
minimize       : これを付けると、内部構造のDFSA(決定性有限オートマトン)を最小化してくれる
verbose        : これを付けると、ビルドの途中経過が出力される
persistbuffer  : これを付けると、入力を全てバッファに格納してから解析するようになる。
それにより、ScanBuff.GetString()で任意の位置から読めるようになる。
しかし、入力ファイルのサイズが大きいと、メモリ使用量も増えるので注意が必要となる。
noembedbuffers : これを付けると、バッファとしてGplexBuffersクラスを使うようになる。
これにより、アプリ側でバッファを利用したい場合に便利になる。
付けないと、バッファにアクセスできない。
*%option stack, minimize, parser, verbose, persistbuffer, noembedbuffers
ルール部
---------------------------
変数名
*{L}({L}|{D})*               { yylval.text = yytext; return (int)Token.VARIABLE; }
*0[xX]{H}+                   { yylval.real = (double)Convert.ToInt32(yytext, 16); return (int)Token.CONSTANT; }
16進数
*0{D}+                       { yylval.real = (double)Convert.ToInt32(yytext, 8);  return (int)Token.CONSTANT; }
8進数
*{D}+                        { yylval.real = double.Parse(yytext); return (int)Token.CONSTANT; }
10進数の整数
*{D}+{E}                     { yylval.real = double.Parse(yytext); return (int)Token.CONSTANT; }
指数表示の10進数の整数
*{D}*"."{D}+({E})?           { yylval.real = double.Parse(yytext); return (int)Token.CONSTANT; }
実数
*"="                         { return '='; }
演算子
該当しない文字は無視する
*.                           /* Skip */
コード部
---------------------------
*,,,
不要な関数を削除したぐらいで大きな変更なし
*using System;
宣言部
---------------------------
出力するクラスのnamespace
*%namespace GPPGCalculator2
生成するクラスがpartialクラスになる
そうすることで、実装部分を*.yではなく、*.csに書けるようになるので便利
*%partial
出力するクラス名
*%parsertype CalculatorParser
出力するクラスのアクセシビリティ
*%visibility internal
*%union {public double real;public string text;}
トークンに使用するenumの型名
*main            : assignment                    { m_result = $1.real; }
ルール部
*main            : assignment                    { m_result = $1.real; }
---------------------------
コード部
---------------------------
*,,,
Parseした結果が格納される。
格納する処理は、Calculator.Language.grammer.yの中に記述している。
*private double m_result;
変数を格納するためのディクショナリ
Keyが変数名、Valueが格納している値
*private Dictionary<;string, double>; m_variables = new Dictionary<;string, double>;();
作った電卓のParserを生成
字句解析器も、この中で生成されている
*var parser = new CalculatorParser();
式を入力。空文字なら終了。
*Console.Write(">; ");
式を解析して結果を出力
*double result;

iniから前回のフォーム位置、サイズ取得
*var filePath = System.IO.Path.Combine(Environment.CurrentDirectory, "Test.ini");
iniにフォーム位置、サイズ保存
*var filePath = System.IO.Path.Combine(Environment.CurrentDirectory, "Test.ini");

*RedirectUri = redirectUri,
オプションに追加することで応答URLを指定できる

*{this.GetComponent().preserveAspect = true;this.GetComponent().SetNativeSize();Vector2 CanvasSize = transform.root.GetComponent().sizeDelta;Vector2 ThisImageSize = this.GetComponent().sizeDelta;if(CanvasSize.x<;CanvasSize.y){scaleRate = CanvasSize.x / ThisImageSize.x;}else{scaleRate = CanvasSize.y / ThisImageSize.y;}this.GetComponent<;RectTransform>;().localScale = new Vector3(scaleRate, scaleRate, 1);}
Start is called before the first frame update

設定ファイルを読み込みます。
*RpcConfigurationConfig config = LoadConfig(@".\GrpcServer.config");
コンテキストを生成します。
第二引数は、コンテキストが dispose された時に生成した gRPC オブジェクトを破棄（チャネルをシャットダウン）するかどうかを表します。
*using (RpcConfigurationContext context = new RpcConfigurationContext(config, true))
設定上のサービス名を指定してサービスに対してインターセプターを適用します。
*server.Services.Add(context.Intercept(ExampleService.BindService(new ExampleServiceImpl()), "example1"));
設定上のチャネル名を指定してサーバーポートを生成します。
*server.Ports.Add(context.GetServerPort("channel1"));
*{typeof(ExampleInterceptorConfig)};
ExtraInterceptors などに指定した型をシリアライザに渡します。
*if (config.TryGetMethodArgs("name", out object name))*{
MethodArgs で指定した引数を取得できます。
設定ファイルを読み込みます。
*RpcConfigurationConfig config = LoadConfig(@".\GrpcClient.config");
コンテキストを生成します。
第二引数は、コンテキストが dispose された時に生成した gRPC オブジェクトを破棄（チャネルをシャットダウン）するかどうかを表します。
*using (RpcConfigurationContext context = new RpcConfigurationContext(config, true))
*{typeof(ExampleInterceptorConfig)};
ExtraInterceptors などに指定した型をシリアライザに渡します。
*if (config.TryGetMethodArgs("name", out object name))*{
MethodArgs で指定した引数を取得できます。
設定上の名称を指定して CallInvoker を生成します。
*CallInvoker invoker = m_RpcContext.GetCallInvoker("invoker1");

100ミリ秒でタイムアウト
1000ミリ秒のSleepがあるので確実にタイムアウトする
*[TestMethod, Timeout(100)]

ロード完了後でないとハンドラを登録できない
*var handle = ((HwndSource)HwndSource.FromVisual(element)).Handle;

*new ObservableClass(1).Goshujin = g;
これでListViewが更新！

*foreach (var prop in confirmationProperties) {*var value = prop.GetValue(confirmation, null);
ViewModelから渡された値をViewにセット
*foreach (var prop in dialogProperties) {*var ctxProp = confirmationProperties
Viewの値をViewModelに返す
*public string FileName { get; set; }
ファイルダイアログと同名のプロパティを定義する
以下省略
*}

*await Task.Delay(1000);
1秒待つ
静止
*Tello.controllerState.setAixs(0, 0, 0, 0);

*if ((uint)index >;= (uint)_size)*{
(1)
*if ((uint)index >;= (uint)_size)*{
(1)
ここと
*int version = _version;
*if (version != _version &amp;&amp; BinaryCompatibility.TargetsAtLeast_Desktop_V4_5)*{
ここと
*if (version != _version &amp;&amp; BinaryCompatibility.TargetsAtLeast_Desktop_V4_5)*{
ここ
特に何もしない。
*var a = new List<;int>;();
コンストラクタの引数であらかじめCapacityを設定できる。
*var b = new List<;int>;(num);

新規IDを生成
*NUlid.Ulid id = NUlid.Ulid.NewUlid();
*for (int i=0; i<; 10; ++i)*{
10個の値を生成

作った電卓のParserを生成する。
字句解析器は、この中で生成されている。
*var parser = new Calculator.CalculatorParser();
式を入力。空文字なら終了。
*Console.Write(">; ");
式を解析。この中で結果も出力される。
*parser.Parse(input);

JSONとして出力する（構造化）
*.AddLogging(configure =>; configure.AddJsonConsole())
*logger.LogError ("Hello {@aaa}", new Hoge { Id = 0, Name = "あいうえお"});
LogTemplateに@を付けると、プロパティーの構造をそのままログに出してくれる

準備 =================================================================================
key, iv
byte[] key = Encoding.UTF8.GetBytes("123456789012345678901234"); 半角24文字 196bit
byte[] iv = Encoding.UTF8.GetBytes("12345678"); 半角8文字 64bit
3DES
*TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
文字列
*string srcStr = "hogehoge";
出力
*Console.WriteLine("元の文字列: " + srcStr);
暗号化処理 ============================================================================
byte変換
*byte[] srcByte = Encoding.UTF8.GetBytes(srcStr);
普通に出力すると文字化け？するので、Base64でエンコード。
*string encStr = System.Convert.ToBase64String(encData);
複合処理 ============================================================================
*byte[] encByte = System.Convert.FromBase64String(encStr);

*sum += Mathf.Abs(data[i]);
データ（波形）の絶対値を足す
データ数で割ったものに倍率をかけて音量とする
*m_volumeRate = Mathf.Clamp01(sum * m_gain / (float)data.Length);

*_cachedRectTransform.IsAlive()
こんなメソッドはありません。あくまでも概念です
public RectTransform RectTransform =&gt; _cachedRectTransform != null ? _cachedRectTransform : (_cachedRectTransform = transform as RectTransform); これは辞めて
*private bool isCached;

*IEnumerable<;IList<;int>;>; buffered = new List<;int>; { 0, 1, 2, 3, 4, 5 }.Buffer(count: 2);
[[0, 1], [2, 3], [4, 5]] みたいな感じでまとめられます。
*IEnumerable<;IList<;int>;>; buffered = new List<;int>; { 0, 1, 2, 3, 4, 5, 6 }.Buffer(count: 2);
[[0, 1], [2, 3], [4, 5], [6]] みたいな感じでまとめられます。
*IEnumerable<;IList<;int>;>; buffered = new List<;int>; { 0, 1, 2, 3, 4 }.Buffer(count: 3, skip: 1);
[[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4], [4]] みたいな感じでまとめられます。
*IEnumerable<;IList<;int>;>; buffered = new List<;int>; { 0, 1, 2, 3, 4, 5, 6, 7 }.Buffer(count: 2, skip: 3);
[[0, 1], [3, 4], [6, 7]] みたいな感じでまとめられます。
渡した要素を何回でも繰り返すIEnumerable&lt;T&gt;をつくる
*public static IEnumerable<;TResult>; Repeat<;TResult>;(TResult value)
IEnumerable&lt;T&gt;の拡張関数で、何回でも要素を繰り返すIEnumerable&lt;T&gt;をつくる
*public static IEnumerable<;TSource>; Repeat<;TSource>;(this IEnumerable<;TSource>; source)
IEnumerable&lt;T&gt;の拡張関数で、指定した回数繰り返すIEnumerable&lt;T&gt;をつくる
*public static IEnumerable<;TSource>; Repeat<;TSource>;(this IEnumerable<;TSource>; source, int count)

*Tello.startConnecting();
接続開始
離陸
Telloと接続中、かつ、飛行していない
*if (inputStr == "takeoff" &amp;&amp; Tello.connected &amp;&amp; !Tello.state.flying)
着陸
Telloと接続中、かつ、飛行中
*if (inputStr == "land" &amp;&amp; Tello.connected &amp;&amp; Tello.state.flying)
とりあえず着陸命令だしておく
*Tello.land();
これだと、命令が送られる前にアプリケーションが終了してしまうので、
ちょっと待つ
*Thread.Sleep(1000);

*{public float X { get; set; }public float Y { get; set; }public Point(float x, float y){X = x;Y = y;}}
座標
*{public Point Start { get; set; }public Point End { get; set; }}
通知データ  線分を表すクラス
*{private int halfW;private int halfH;private int pa;private int pb;public LissajousCurve(int paramA, int paramB, int width, int height){pa = paramA;pb = paramB;halfW = width / 2;halfH = height / 2;}public void Start(){int startx = (int)(halfW * Math.Sin(0));int starty = (int)(halfH * Math.Sin(0));double rad = 0.0;int prevx = startx;int prevy = starty;do{rad += 0.02;int x = (int)(halfW * Math.Sin(pa * rad));int y = (int)(halfH * Math.Sin(pb * rad));Line line = new Line{Start = new Point(prevx, prevy),End = new Point(x, y)};Publish(line);prevx = x;prevy = y;} while (prevx != startx || prevy != starty);Complete();}// 終了を通知するprivate void Complete(){foreach (var observer in _observers){observer.OnCompleted();}}// 状況変化を知らせるために購読者に通知するprivate void Publish(Line state){foreach (var observer in _observers){observer.OnNext(state);}}private List<;IObserver<;Line>;>; _observers = new List<;IObserver<;Line>;>;();public IDisposable Subscribe(IObserver<;Line>; observer){_observers.Add(observer);return observer as IDisposable;}}
リサジュー曲線クラス
*{foreach (var observer in _observers){observer.OnCompleted();}}
終了を通知する
*{foreach (var observer in _observers){observer.OnNext(state);}}
状況変化を知らせるために購読者に通知する

追加エンティティのうち、CreatedDateTime プロパティを持つものを抽出
*var entities = this.ChangeTracker.Entries()
追加エンティティのうち、IEntity を実装したものを抽出
*var entities = this.ChangeTracker.Entries<;IEntity>;()
除外エンティティ
*continue;

オーナーウィンドウとメッセージボックスの領域を取得
*var rcOwner = Win32Native.GetWindowRect(hOwner);
メッセージボックスをオーナーウィンドウの中央位置に移動
*var x = rcOwner.Left + (rcOwner.Width - rcMsgBox.Width) / 2;
フックを解除
*Win32Native.UnhookWindowsHookEx(hHook);

コンストラクタでコンフィグを初期化
*Configuration = config;
オプションを使用するためのサービスを追加します。
*services.AddOptions();
バインドするオプションクラスに対し、設定情報を登録します。
*services.Configure<;MyOptions>;(Configuration);
※上記は services.AddMvc() より前で設定しなくても動きましたが、公式ドキュメント通り、前で設定しています。
*services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
以下略
*}
*public OptionsController(IOptionsMonitor<;MyOptions>; optionsMonitor) {// CurrentValueプロパティでオプションクラスのインスタンスが得られるoptions = optionsMonitor.CurrentValue;}
コンストラクタで OptionsMonitor&lt;TOptions&gt; が DI される
CurrentValueプロパティでオプションクラスのインスタンスが得られる
*options = optionsMonitor.CurrentValue;
オプションクラスのインスタンスをフィールドに保持
*private readonly MyOptions options;
*public IActionResult GetOptions() {// JSON で返してみるreturn Ok(options);}
api/options
JSON で返してみる
*return Ok(options);
*public class MySubOptions {public string SubOption1 { get; set; }public int SubOption2 { get; set; }public Guid SubOption3 { get; set; }}
バインドするクラスを用意
ここで自動的に appsettings.json が読み込まれる
*public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>;

*Console.WriteLine(str);
hoge

*Value = target.ID == "PDF" ? $"https:
dl.acm.org{match.Groups[1].Value}" : match.Groups[1].Value

*BurstFunc.TryParse(str_list[1], out elem.somethingData);
Burst 適用済み delegate
略
*}
略
*}
そのほか、byte, UInt16 との相互変換、
Equals(), 比較演算子(==, !=, &lt;=, &lt;, &gt;=, &gt;)などを一通り実装
*}
*{public static UnsafeRefToNativeList<;T>; GetUnsafeRef<;T>;(this NativeList<;T>; target)where T : unmanaged{return new UnsafeRefToNativeList<;T>;(target);}}
UnsafeRef を簡単に作成するための拡張メソッド
NativeList&lt;T&gt; 内部の UnsafeList へのポインタを取得
参照先が共通なので UnsafeRef への変更は元の NativeList にも反映される
*_list = passed_list.GetUnsafeList();
*{public void* GetUnsafePtr();}
interface
普通のInterfaceの使い方 -&gt; Boxing が起きる
Burst でコンパイルできない
*public unsafe void Func1(IPtrGetter source)
Generic Interface の書き方 -&gt; struct を渡す時には参照型を生成しない (高速)
Burst でコンパイルしてさらに速くできる
*public unsafe void Func2<;T>;(T source)
*public struct Data { };
BurstFunc が受け取れる型 Data
*{public implicit operator Data(DataType2 data) {return new Data(/* converion */)};};
Data への暗黙の型変換を実装した型
*{public Data data_member;};
関数のオーバーロードで該当するメンバを取り出して渡す例
Burst 関数ポインタへのエントリポイント
*[BurstCompile]
Burstへのエントリポイント以外では参照渡ししなくても、
Genericな関数を使っても、
void以外を返してもよい
*private static bool Proccess<;T>;(T data)
*{_funcDelegade(ref data);}
Data と DataType2 を渡せる　(暗黙にDataへの型変換が行われる)
*{_funcDelegade(ref data.data_member);}
DataType3 を渡せる (オーバーロード)

認証用公開鍵GETする
戻り値=DER形式の公開鍵
*byte[] authPubKey = JPKIReaderLib.JPKIReader.GetAuthenticationPublicKey();
ファイルの電子署名を作成する
第1引数=PIN
第2引数=電子署名する対象のファイル(パス＆ファイル）
戻り値=電子署名
*byte[] sig = JPKIReaderLib.JPKIReader.SignatureUsingAuthenticationPrivateKey("9999", file);
電子署名を検証する
第1引数=DER形式の公開鍵
第2引数=電子署名
第3引数=電子署名する対象のファイル(パス＆ファイル）
戻り値=true/false
*bool isVerifySuccess = JPKIReaderLib.Verify.VerifySignature(authPubKey , sig , file)

ここで取れるpubkey_pkcs1はPKCS#1形式の公開鍵
先頭に
30820122300d06092a864886f70d01010105000382010f00
を付加するとOpenSSLで取り扱い可能なPKCS#8になる
*pubkey_pkcs8.AddRange(Common.HexStringToBytes("30820122300d06092a864886f70d01010105000382010f00").ToArray());

BGMは一つづつ鳴るが、SEは複数同時に鳴ることがある
*private AudioSource bgmSource;
*IEnumerable<;AudioSource>; audioSources = GetComponents<;AudioSource>;().Select(a =>; { a.playOnAwake = false; a.volume = BGM_VOLUME; a.loop = true; return a; });
LinQを使い、BGMはループさせ、ボリュームをそれぞれ代入しました。
BGMは一つづつ鳴るが、SEは複数同時に鳴ることがある
*private AudioSource bgmSource;

*ConsoleWriteIEnumerable("OrderedSet:", os);
0, 1, 2, 3, 4

*List<;int>; numbers = new List<;int>; { 1, 2, 3, 4 };
Creating a list of numbers
*List<;int>; numbers = new List<;int>; { 1, 2, 3, 4 };
Creating a list of numbers

*{// プロパティがカラムになる。// 主キーには PrimaryKey 属性を付ける。[PrimaryKey]public int PrimaryKey { get; set; }public string Column1 { get; set; }public string Column2 { get; set; }// インデックスを作る項目には Indexed 属性を付ける。[Indexed]public string Column3 { get; set; }}
RealmObject を継承したクラスがテーブルになる。
プロパティがカラムになる。
主キーには PrimaryKey 属性を付ける。
*[PrimaryKey]
*public string Column3 { get; set; }
インデックスを作る項目には Indexed 属性を付ける。
*foreach (var row in realm.All<;Table1>;().Where(i =>; i.Column1 = "Value2-1"))*{
...
*{// ...[Preserve][WovenProperty]public string Column1{[CompilerGenerated]get{if (base.IsManaged){return base.GetStringValue("Column1");}return this.Column1;}[CompilerGenerated]set{if (!base.IsManaged){this.Column1 = value;base.RaisePropertyChanged("Column1");}else{base.SetStringValue("Column1", value);}}}// ...}
...
スレッド用に Realm オブジェクトを用意する。
*var threadRealm = Realm.GetInstance(config);
*{updateTarget.Column1 = "NewValue";Console.WriteLine("Updated: {0}", threadRealm.Find<;Table1>;(1));// トランザクションの完了を少し待機する。Thread.Sleep(2000);});
更新もトランザクション内で行う。
トランザクションの完了を少し待機する。
*Thread.Sleep(2000);
更新が済むまで少し待機する。
*Thread.Sleep(1000);
トランザクションが完了する前は変更内容が見えない。
Realm オブジェクトは毎回取得しなおす。取得し直さないと他スレッドでの変更は見れない。
*realm = Realm.GetInstance(config);
トランザクションが完了するまで少し待機する。
*Thread.Sleep(3000);
トランザクションが完了したので変更内容が見える。
*realm = Realm.GetInstance(config);
*public Table2 Object1 { get; set; }
一対一は単にプロパティを作る。
*public IList<;Table3>; ObjectN { get; }
一対多は IList のプロパティを作る。
*public IQueryable<;Table1>; Owners1 { get; }
Table1.Object1 の逆参照
*public IQueryable<;Table1>; OwnersN { get; }
Table1.ObjectN の逆参照
Realm.Find で取得しなおしたオブジェクト経由で変更しても変更通知は伝わる。
*var target = realm.Find<;Counter>;(COUNTER_KEY);
INotifyPropertyChanged による変更通知で画面の表示が自動で変わる。
*target.Count++;

*ilgen.Emit(OpCodes.Ret);
戻り値とせよ

returnステートメント不要
*}
*{HeavyWork(x)});
重い処理なのでUIスレッドから逃す
*await Task.Run(() =>; {Console.WriteLine("処理1");Thread.Sleep(3000);Console.WriteLine("処理2");Thread.Sleep(3000);});
ラムダ式を与えるコード
なんか処理
*await Task.Delay( 3000 );

以下同様の分岐が続く...
*}
CommandAの処理
・・・
*return stringResult;
CommandBの処理
・・・
*return doubleResult;
以下同様のメソッド多数...
・・・
*,,,
*class CommandResultDto{public string FieldResult1 {get;set;}public double FieldResult2 {get;set;}//必要なフィールドを定義する}
必要なフィールドを定義する
必要なフィールドを定義する
*}
コマンドAの処理
・・・
・・・
*return result;
コマンドBの処理
・・・
・・・
*return result;
コマンドとメソッドの組み合わせをディクショナリに格納する
*commandDic.Add("commandA",commandAExec);
必要な組み合わせを追加
*,,,
argsに引数を設定する
・・・
キーが存在するかどうかは先にチェックする
*if (commandDic.ContainsKey(commandString)){

*Dictionary<;int, string<; Table = new();
右辺を省略できる
今までは、こう書いていた。
Dictionary&lt;int, string&gt; Table = new Dictionary&lt;int, string&gt;();
もしくは、varが使える場面では、
var Table = new Dictionary&lt;int, string&gt;();
*,,,
C#8.0では'種類のパターン'が使えないので、次のように書く必要があった。
case SketchLine _:
*case SketchLine:

暗黙的な変換
*huga = hoge;
明示的な変換
*hoge = (int)huga;

*public const double payo = Math.Sqrt(10);
NG
*if(Moge == PI)*//処理
コンパイルで生成される中間言語では下の条件式はmyData == 3.14となる
処理
*}
なんか
*}
実際にはコンパイル時にHoge(100);となっている
*Hoge();
コンストラクタ内で書き換え可能
*this.Piyo = huga;
書き込み不可でエラー
*this.Piyo = mohu;

*class Sub : Expr {
式-式を表す

何か処理
*}
以下、再スタートさせるための再取得
*Set();
何か処理
*}
処理記述(1)
*yield return new WaitForSeconds ( 1f );
処理記述(2)
*yield return new WaitForSeconds ( 1f );
処理記述(3)
*yield return new WaitForSeconds ( 1f );
piyoのisComplete変数がtrueになるまで待機
*yield return new WaitForEndOfFrame();
childのアニメーションが終了したとき
(child.isCompleteがtrueになったとき)
ここより下にかかれた処理が実行される&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;
シンプルに実装できるので、アニメーションを組み合わせた演出などを作る時に便利。
*}
処理
*}

*DataContext = this;
Binding用

Linux等(Raspbian Stretchで動作確認)
*devicePort = "/dev/ttyUSB0";
シリアルポートOpen
*skStackClient.OpenAsync(devicePort, 115200, 8, Parity.None, StopBits.One).Wait();
*if(skStackClient.ScanAndJoinAsync(BRouteId, BRoutePw).Result)*{
スキャン＆Join

*var i = _count;
追加
iを引数で渡す
*numberBtList[_count].onClick.AddListener(() =>; OnClickNumber(i));
*void Update () {}
Update is called once per frame

*delegate int Delegate_A(string s);
Delegate_A という名前の「型」を定義
デリゲートはひとつの「型」なので、他のクラスを使用するときと同じ書き方でインスタンス化できる
Delegate_A dlg = new Delegate_A(work);     C#1.0
Delegate_A dlg = work;                 C#2.0 で new なしで書けるようになった
作成したインスタンスに引数を渡しつつ呼び出す
*int result = dlg("123");
*{return int.Parse(s);}
デリゲートから呼び出されるメソッド
*{// 定義済デリゲートのインスタンスを生成（newを省略した書き方）Func<;string,int>; dlg = work;// 作成したインスタンスに引数を渡しつつ呼び出すint result = dlg("123");}
独自デリゲート型の宣言が不要になった
定義済デリゲートのインスタンスを生成（newを省略した書き方）
*Func<;string,int>; dlg = work;
作成したインスタンスに引数を渡しつつ呼び出す
*int result = dlg("123");
*{return int.Parse(s);}
デリゲートから呼び出されるメソッド
*//Func<;string,int>; dlg = (string s) =>; { return int.Parse(s); };
メソッドの内容を (引数) =&gt; {処理(式)} で書ける
*// 処理部分がreturn のみの場合は{}も省略可能
Func&lt;string,int&gt; dlg = (string s) =&gt; { return int.Parse(s); };
*// 処理部分がreturn のみの場合は{}も省略可能
引数の型(string)は型推論により省略可能
処理部分がreturn のみの場合は{}も省略可能
*Func<;string,int>; dlg = s =>; int.Parse(s);
作成したインスタンスに引数を渡しつつ呼び出す
*int result = dlg("123");

*public static void Method_A()
静的メソッド --&gt; インスタンス化せずに呼び出せる
処理を実装
*}
*{// 処理を実装}
「静的クラスでインスタンスのメンバーを宣言することはできません」と怒られます。
処理を実装
*}

*{_webHost = webHost;base.PostCreateHost(webHost);}
Host が作成された際に PostCreateHost が呼び出されるので field に Host を保存しておく
*{_webHost?.Dispose();_webHost = null;}
LambdaEntryPoint が不要になったタイミングで解放するために Dispose を実装する
テストメソッドのスコープを外れたタイミングで Dispose して Host を解放する
*using var lambdaFunction = new LambdaEntryPoint();

*void Start () {//画像ファイルの読み込みstring file="Assets/cat.jpg";var labels = File.ReadAllLines("Assets/synset.txt");var tensor=CreateTensorFromImageFile(file);var graph=new TFGraph();string modelFile="Assets/plugins/beginner-const-graph.pb";var model=File.ReadAllBytes(modelFile);graph.Import(model,"");using (var session=new TFSession(graph)){var runner=session.GetRunner();runner.AddInput(graph["input"][0],tensor);runner.Fetch(graph["prob"][0]);var output=runner.Run();var result=output[0];var bestIdx = 0;float best = 0;// 尤も確率が高いものを調べて表示するvar probabilities = ((float[][])result.GetValue(true))[0];for (int i = 0; i <; probabilities.Length; i++){if (probabilities[i] >; best){bestIdx = i;best = probabilities[i];}}Debug.Log($"{file} best match: [{bestIdx}] {best * 100.0}% {labels[bestIdx]}");}}
Use this for initialization
画像ファイルの読み込み
*string file="Assets/cat.jpg";
尤も確率が高いものを調べて表示する
*var probabilities = ((float[][])result.GetValue(true))[0];
*void Update () {}
Update is called once per frame
*using (var session = new TFSession (graph)) {var normalized = session.Run (inputs: new [] { input },inputValues: new [] { tensor },outputs: new [] { output });return normalized [0];}
Execute that graph to normalize this one image
*// specific normalized format (a particular image size, shape of the input tensor,*// normalized pixel values etc.).
The inception model takes as input the image described by a Tensor in a very
*{// Some constants specific to the pre-trained model at:// https://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip//// - The model was trained after with images scaled to 224x224 pixels.// - The colors, represented as R, G, B in 1-byte each were converted to//   float using (value - Mean)/Scale.const int W = 224;const int H = 224;const float Mean = 117;const float Scale = 1;graph = new TFGraph ();input = graph.Placeholder (TFDataType.String);output = graph.Cast (graph.Div (x: graph.Sub (x: graph.ResizeBilinear (images: graph.ExpandDims (input: graph.Cast (graph.DecodeJpeg (contents: input, channels: 3), DstT: TFDataType.Float),dim: graph.Const (0, "make_batch")),size: graph.Const (new int [] { W, H }, "size")),y: graph.Const (Mean, "mean")),y: graph.Const (Scale, "scale")), destinationDataType);}
inception model.

ただ単に非同期で実行したいだけなら、Task.Run を使えばよいと思います。
*Debug.WriteLine(await Task.Run(() =>; HeavyFunc(15)).ConfigureAwait(false));

*Console.WriteLine(var1.Equals(var2));
falseになる
直接値を設定するような書き方ができる
*l.Experience = 0;
*public int Experience {set {if (value <; 0) {throw new ArgumentException("経験年数は正の数値を入力してください。");}this._experience = value;}get {return this._experience;}}
プロパティ

マスターデータテーブルの各項目の基底クラス
*[System.Serializable]
データテーブルそのものの基底クラス
ジェネリック化しているので、派生クラス作成時にMasterDataTableBaseを継承した項目クラスを設定するだけでおｋ
*public abstract class MasterDataTableBase<;T>; : ScriptableObject where T : MasterDataItemBase
*if(index == -2) return;*// 見つからない場合は新規追加
異常値の場合は何もしない
*if(index <; 0)*{
見つからない場合は新規追加
*{list[index] = item;}
既にある場合はその要素を更新
テーブル用のScriptableObjectとその元となる.csファイルの作成&amp;更新を行うスクリプト
GoogleSpreadSheetの情報をAPIで取得して、そこからファイルを作成する
*public class CreateMasterDataObject
各スプレッドシートIDとシート名
*private const string CONSTANT_SPREAD_SHEET = "シートIDを適宜入れる";
*{string resultText = string.Empty;m_NowUpdate = SendWebRequestToGet(string.Format(URL_FORMAT, API_URL, spreadSheetId, sheetName), (string result)=>;{ resultText = result; });while(m_NowUpdate.MoveNext()){}if(resultText.IsNullOrEmpty()){Debug.LogWarning("resultTextが空の為、終了しました");return;}// ScriptableObjectのファイル名はテーブルの型名と同じにしておくstring tableFileName = typeof(T).ToString();string masterAssetPath = string.Format("{0}{1}.asset", MASTER_DATA_OBJECT_PATH, tableFileName);T master = AssetDatabase.LoadAssetAtPath<;T>;(masterAssetPath);// データが無い場合は新規作成if(master == null){master = Editor.CreateInstance<;T>;();AssetDatabase.CreateAsset(master, masterAssetPath);AssetDatabase.Refresh();}// 取得したAPIResultをJsonに変換してテーブルに格納するvar json = MiniJSON.Json.Deserialize(resultText) as Dictionary<;string, object>;;var tableList = json.GetValueList<;Dictionary<;string, object>;>;("Table");// クリアしてから格納するmaster.Clear();foreach (var item in tableList){master.AddOrUpdate(item);}//ダーティとしてマークする(変更があった事を記録する)EditorUtility.SetDirty(master);//保存するAssetDatabase.SaveAssets();Debug.LogFormat("{0}作成完了", tableFileName);Debug.Log(masterAssetPath);}
テーブル作成or更新～保存処理までの共通処理
*string masterAssetPath = string.Format("{0}{1}.asset", MASTER_DATA_OBJECT_PATH, tableFileName);
ScriptableObjectのファイル名はテーブルの型名と同じにしておく
*if(master == null)*{
データが無い場合は新規作成
取得したAPIResultをJsonに変換してテーブルに格納する
*var json = MiniJSON.Json.Deserialize(resultText) as Dictionary<;string, object>;;
クリアしてから格納する
*master.Clear();
ダーティとしてマークする(変更があった事を記録する)
*EditorUtility.SetDirty(master);
*Debug.LogFormat("{0}作成完了", tableFileName);
保存する
*{Debug.Log("API通信開始");UnityWebRequest request = UnityWebRequest.Get(url);yield return request.SendWebRequest();while(!request.isDone){yield return 0;}// エラーチェックif(request.isNetworkError || request.responseCode != 200){Debug.LogError(request.responseCode);Debug.LogError(request.error);m_NowUpdate = null;if(callback != null){callback(string.Empty);}yield break;}Debug.Log(request.downloadHandler.text);Debug.Log(request.downloadHandler.data);if(callback != null){// ここで改行を置き換え無いと改行がDebug.LogやuGUI.textで反映されないstring text = request.downloadHandler.text.Replace("\\n", Environment.NewLine);callback(text);}m_NowUpdate = null;Debug.Log("API通信終了");}
Web通信用関数
*if(request.isNetworkError || request.responseCode != 200)*{
エラーチェック
ここで改行を置き換え無いと改行がDebug.LogやuGUI.textで反映されない
*string text = request.downloadHandler.text.Replace("\\n", Environment.NewLine);
*{public static bool IsNullOrEmpty(this string source){if(source == null || source.Length <;= 0 || source == "null" || source == "Null" || source == "NULL"){return true;}return false;}}
stringの拡張クラス

*if (string.IsNullOrEmpty(pattern))*{ throw new ArgumentNullException(); }
空文字も正規表現としては無意味なのでnull扱いにする。
*if (regexValuePairs.Any(rv =>; rv.RegexPattern.ToString() == pattern))*{ throw new ArgumentException(); }
同一パターンを登録済みならエラー
IListではないが、検索順序操作のためにIList風プロパティとメソッドも実装する
*#region IList like implements

*GetComponent<;Rigidbody<;().NullCast()?.AddForce(force, mode);
推論が効くはず

*case 3:
下
IEnumeratorを返す関数を引数に置くことでCoroutineが動く。
*}

*public static class AttachedCommandBindings {public static DependencyProperty NewCommandProperty= DependencyProperty.RegisterAttached("NewCommand",typeof(ICommand),typeof(AttachedCommandBindings),new PropertyMetadata(null, OnNewCommandChanged));public static void SetNewCommand(UIElement element, ICommand value)=>; element.SetValue(NewCommandProperty, value);public static ICommand GetNewCommand(UIElement element)=>; (ICommand)element.GetValue(NewCommandProperty);private static void OnNewCommandChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e) {UIElement element = sender as UIElement;if (element == null)return;ICommand command = e.NewValue as ICommand;if (command == null)return;RegisterCommandBinding(element, ApplicationCommands.New, command);}private static void RegisterCommandBinding(UIElement element, RoutedUICommand routedCommand, ICommand command) {var binding = new CommandBinding(routedCommand,(sender1, e1) =>; command.Execute(null),(sender1, e1) =>; e1.CanExecute = command.CanExecute(null));CommandManager.RegisterClassCommandBinding(element.GetType(), binding);element.CommandBindings.Add(binding);}}
コマンドごとに添付プロパティを実装する
*public static class AttachedCommandBindings {public static DependencyProperty NewCommandProperty= DependencyProperty.RegisterAttached("NewCommand",typeof(ICommand),typeof(AttachedCommandBindings),new PropertyMetadata(null, OnNewCommandChanged));public static void SetNewCommand(UIElement element, ICommand value)=>; element.SetValue(NewCommandProperty, value);public static ICommand GetNewCommand(UIElement element)=>; (ICommand)element.GetValue(NewCommandProperty);private static void OnNewCommandChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e) {UIElement element = sender as UIElement;if (element == null)return;ICommand command = e.NewValue as ICommand;if (command == null)return;RegisterCommandBinding(element, ApplicationCommands.New, command);}private static void RegisterCommandBinding(UIElement element, RoutedUICommand routedCommand, ICommand command) {var binding = new CommandBinding(routedCommand,(sender1, e1) =>; command.Execute(null),(sender1, e1) =>; e1.CanExecute = command.CanExecute(null));CommandManager.RegisterClassCommandBinding(element.GetType(), binding);element.CommandBindings.Add(binding);}}
以下はApplicationCommands.Newにバインドする例

ScrollViewerとグループ名の対応リスト
*private static Dictionary<;ScrollViewer, string>; _scrollViewers
水平方向のスクロール位置のリスト
*private static Dictionary<;string, double>; _horizontalScrollOffsets
垂直方向のスクロール位置のリスト
*private static Dictionary<;string, double>; _verticalScrollOffsets
グループ名の添付プロパティ
*public static readonly DependencyProperty ScrollGroupProperty
登録解除
*scrollViewer.ScrollChanged -= ScrollViewer_ScrollChanged;
既存のグループ名の場合は、現在のスクロール位置を反映する
*scrollViewer.ScrollToHorizontalOffset(_horizontalScrollOffsets[newGroup]);
新しいグループ名の場合は、スクロール位置を記録する
*_horizontalScrollOffsets[newGroup] = scrollViewer.HorizontalOffset;
ScrollViewerを登録
*_scrollViewers.Add(scrollViewer, newGroup);
*if (e.VerticalChange != 0) {*_verticalScrollOffsets[group] = changedScrollViewer.VerticalOffset;
垂直方向
同じグループのScrollViewerにスクロール位置を反映
*scrollViewers
*if (e.HorizontalChange != 0) {*_horizontalScrollOffsets[group] = changedScrollViewer.HorizontalOffset;
水平方向
同じグループのScrollViewerにスクロール位置を反映
*scrollViewers

なんかいろいろやる
*yield return new WaitForSeconds(5);
コールバックに入ってきた値をそのままobserverに渡します。
*observer.OnNext(s);
ここではcancellation tokenを返しますが
キャンセル機構を持っていないのでEmptyでいいでしょう
*return Disposable.Empty;
なんかいろいろやる
*yield return new WaitForSeconds(5);

*continuation();
続きを実行
*regist = cancellationToken.Register(()=>;{tween.Kill(true);});
tokenが発火したらTweenをKillする
*{return new TweenAwaiter(self, cancellationToken);}
TweenにToAwaiter拡張メソッドを追加
CancellationTokenSourceを準備
*source = new CancellationTokenSource();
CancellationTokenSourceを破棄する
*source.Cancel();
*await transform.DOMove(new Vector3(0, 5, 0), 3).ToAwaiter(token);*Debug.Log("Step1");
上に移動、ToAwaiter拡張メソッドにCancellationTokenを渡す
*await transform.DOMove(new Vector3(5, 5, 0), 3).ToAwaiter(token);*Debug.Log("Step2");
右斜め上に移動

*byteArray[i] = temp;
byte型を取得
取得したデータを出力
*Debug.Log("width" + message.width);
*{pcl = new Vector3[size];//この部分でbyte型をfloatに変換for (int n = 0; n <; size; n++){int x_posi = n * point_step + 0;int y_posi = n * point_step + 4;int z_posi = n * point_step + 8;float x = BitConverter.ToSingle(byteArray, x_posi);float y = BitConverter.ToSingle(byteArray, y_posi);float z = BitConverter.ToSingle(byteArray, z_posi);pcl[n] = new Vector3(y, z, x);//結果を出力Debug.Log("pclCoordinates:x=" + pcl[n].x + ",y=" + pcl[n].y + ",z=" + pcl[n].y);}}
点群の座標を変換
*for (int n = 0; n <; size; n++)*{
この部分でbyte型をfloatに変換
結果を出力
*Debug.Log("pclCoordinates:x=" + pcl[n].x + ",y=" + pcl[n].y + ",z=" + pcl[n].y);

適当なウェイトかける
*await Task.Delay(500);

スタックを用意
*var procStack = new List<;Action>;();
*procStack.Add(() =>; { Console.WriteLine("aaa"); });
ラムダ式で任意の処理をスタックする
任意の順番で呼び出す
*procStack[2]();
*for (int i = 0; i <; 10000; ++i)*actions.Add(() =>; { sum += i; });
処理を溜める
逐次実行
*actions.ForEach(action =>; action());
*for (int i = 0; i <; 10000; ++i)*actions.Add(() =>; { sum += i; });
処理を溜める
並列実行
*Parallel.ForEach(actions, action =>; action());

*NativeMethods.WH_KEYBOARD_LL, this.KeyboardProc,
←これ

文字列を指定してメソッドの情報を取得する
*MethodInfo Contains = typeof(string).GetMethod("Contains");
例)p.Nameの形式を作成
*var propertyAccess = Expression.MakeMemberAccess(parameter, property);
例)null != p.Nameの形式を作成
*var body0 = Expression.NotEqual(Expression.Constant(null), propertyAccess);
p.Name.Contains(keyword)の形式を作成
*var body1 = Expression.Call(propertyAccess,
例)null != p.Name &amp;&amp; p.Name.Contains(keyword)の形式を作成
*var newBody = Expression.AndAlso(body0, body1);
例)p =&gt; null != p.Name &amp;&amp; p.Name.Contains(keyword)の形式を作成
*return Expression.Lambda<;Func<;Student, bool>;>;(newBody, parameter);

*for (int i = 1; i <; nLabels; i++) {
0番目のラベルは背景のため飛ばす
画像上の重心位置をワールド座標に変換
*var ctrdOnImg = new Point(centroids.get(maxAreaLabel, 0)[0], centroids.get(maxAreaLabel, 1)[0]);
*_fire.transform.position = new Vector3((float)ctrdOnWorld.x, (float)ctrdOnWorld.y, FIRE_Z_POS);*}
炎を手の位置に移動

遅らせたい処理
*}

*public enum EnumSample {[Description("項目1")]A,[Description("項目2")]B,[Description("項目3")]C,[Description("項目4")]D}
表示させたい文字列をDescription属性に指定する

*if (window.DataContext is IClosing)*e.Cancel = (window.DataContext as IClosing).OnClosing();
ViewModelがインターフェイスを実装していたらメソッドを実行する

キーイベント処理登録
*_webBrowser.KeyboardHandler = new KeyboardHandler(this);
Enterキー押下時の処理を記述する。
*MessageBox.Show("KeyDown")
*{private frmMain _frm;public KeyboardHandler(frmMain frm){_frm = frm;}public bool OnKeyEvent(IWebBrowser browserControl, IBrowser browser, KeyType type, int windowsKeyCode, int nativeKeyCode, CefEventFlags modifiers, bool isSystemKey){return false;}public bool OnPreKeyEvent(IWebBrowser browserControl, IBrowser browser, KeyType type, int windowsKeyCode, int nativeKeyCode, CefEventFlags modifiers, bool isSystemKey, ref bool isKeyboardShortcut){_frm.OnMyPreviewKeyDown(windowsKeyCode, modifiers);return false;}}
KeyboardHandleクラス

*int iMinNum = iaArray.Min();
最小
追加
*liListName.Add("追加するデータ");
特定の要素削除
全て削除
*liListName.Clear();
昇順
*liListName.Sort();
降順（ラムダ式）
*liListName.Sort((a, b) =>; b - a);
*foreach(var a in liListName){*Console.WriteLine(a);
ループで出力
1文字のみ（charで取得される）
*sString (0)
あ
複数文字
*sString.Substring("n番目（index番号）から", "m文字取得");
例　１番目から２文字取得
*sString.Substring(1, 2);
いう
*,,,
パターン１
Console.WriteLine( string.Concat(sString .Reverse()) );　おえういあ
パターン２（LINQを使用しているため「using System.Linq」を読み込む）
Console.WriteLine( new string(sString.Reverse().ToArray()) );　おえういあ
*,,,
ループ内容
*}
*$"私の名前は\"{Name}\"です"
私の名前はhogeです
*▼「{}」のエスケープ処理
私の名前は"hoge"です

他のGameObjectにアタッチされているか調べる.
アタッチされている場合は破棄する.
*if (this != Instance)
以下は UnityEngine.TouchPhase の値に対応
*Began = 0,
*if (DragAction != null)*{
ドラッグ処理
*if (TapAction != null)*{
タップ処理
*if (startPosList[id].y - endPosList[id].y <; 0)*{
フリック処理
*if (DragAction != null)*{
ドラッグ処理

*var assetPath = AssetDatabase.GetAssetPath(obj);![SpriteAtlasInspector.PNG](https:
qiita-image-store.s3.amazonaws.com016088daacc87f-3ef1-fb1c-7495-804062243688.png)

整数値
*Matcher Number = '0'.To('9');
除算
*Matcher DivExp = Number + '/' + Number;
整数値
*Matcher Number = '0'.To('9');
「除算」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher DivExp = new RecursionMatcher();
「除算」の中身を設定する。
*DivExp.Inner = ((Number | DivExp) + '/' + Number);
整数値
*Matcher Number = '0'.To('9');
「除算」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher DivExp = new RecursionMatcher();
「除算」の中身を設定する。
*DivExp.Inner = ((Number | DivExp) + '/' + Number);
「減算」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher SubExp = new RecursionMatcher();
「減算」の中身を設定する。
*SubExp.Inner = ((Number | DivExp | SubExp) + '-' + (Number | DivExp));
整数値
*Matcher Number = '0'.To('9');
「除算」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher DivExp = new RecursionMatcher();
「除算」の中身を設定する。
*DivExp.Inner = ((Number | DivExp) + '/' + Number);
「減算」のマッチャーを作る。(但し中身は空っぽ)
*RecursionMatcher SubExp = new RecursionMatcher();
「減算」の中身を設定する。
*SubExp.Inner = ((Number | DivExp | SubExp) + '-' + (Number | DivExp));
*RecursionMatcher LShiftExp = new RecursionMatcher();*// 「左シフト演算」の中身を設定する。
「左シフト演算」のマッチャーを作る。(但し中身は空っぽ)
*LShiftExp.Inner = ((Number | DivExp | SubExp | LShiftExp) + "<;<;" + (Number | DivExp | SubExp));*,,,
「左シフト演算」の中身を設定する。

*Test("
\"''\"\"\"'''\"'''", "-");

*private const string EndPointHarvest = "http:
harvest.soracom.io";
HTTPクライアントインスタンスを破棄
*client.Dispose();
*{txtResponse.Text = string.Empty;var json = "{\"element1\":\"" + trackBar1.Value.ToString() + "\", \"element2\":\"" + trackBar2.Value.ToString() + "\"}";var content = new StringContent(json, Encoding.UTF8, @"application/json");var response = await client.PostAsync(EndPointHarvest, content);txtResponse.Text = response.ReasonPhrase;}
Harvestへ送信

*if (!File.Exists(fname))*{
ファイルの存在チェック
ファイルを展開
*/** 中略 **/
解凍したフォルダから画像ファイルを取り出す
*string mediaDir = unzipDir + "/" + type + "/media";
zipファイルと解凍したフォルダ削除
*Directory.Delete(unzipDir, true);

*var myClass2 = TinyhandSerializer.Deserialize<;MyClass<;(b, TinyhandSerializerOptions.Standard.WithCompression(TinyhandCompression.Lz4));
Same as TinyhandSerializerOptions.Lz4

*+ (fparam.external * deltaTime)
外力による移動量
長さをboneLengthに強制
*nextTail = tposition + normalize(nextTail - tposition) * fparam.m_length;
*for (int i = 0; i <; colliderList.Length; ++i)*{
Collisionで移動
ヒット。Colliderの半径方向に押し出す
*var normal = normalize(dir);
長さをboneLengthに強制
*nextTail = tposition + normalize(posFromCollider - tposition) * fparam.m_length;
*public JobHandle Process(Transform center)*{
Jobのための事前計算をし、Jobを発行する
*{VRMSpringBoneColliderGroup[] groups = bone.ColliderGroups;if (groups == null){return;}bone.enabled = false;foreach (var item in target.GetComponents<;VRMSpringBoneJobGroup>;()){if (item.groups.Count != groups.Length || item.m_center != bone.m_center){continue;}bool same = true;for (int j = 0; j <; groups.Length; ++j){if (groups[j] != item.groups[j]){same = false;break;}}if (!same){continue;}item.Setup(bone);return;}{var item = target.AddComponent<;VRMSpringBoneJobGroup>;();item.Setup(bone);}}
VRMSprintBoneを登録する

*vh.AddUIVertexTriangleStream(vertices);
変更を加えたメッシュを戻す

*{// この Hoge クラスのステートマシンprivate ImtStateMachine<;Hoge>; stateMachine;// この Hoge クラスのアイドリング状態クラスprivate class IdleState : ImtStateMachine<;Hoge>;.State{// 何もしない状態クラスなら何も書かなくても良い（むしろ無駄なoverrideは避ける）}// この Hoge クラスのなにかを処理している状態クラスprivate class ProcessState : ImtStateMachine<;Hoge>;.State{// 状態へ突入時の処理はこのEnterで行うprotected internal override void Enter(){}// 状態の更新はこのUpdateで行うprotected internal override void Update(){}// 状態から脱出する時の処理はこのExitで行うprotected internal override void Exit(){}// 状態で発生した未処理の例外がキャッチされた時の処理はこのErrorで行うprotected internal override bool Error(Exception exception){// 未処理の例外をハンドリングしたのなら true を返すことで、ステートマシンはエラーから復帰しますreturn true;}// ステートマシンが状態の遷移をする前にステートマシンのイベント入力を処理するならこのGuardEventで行うprotected internal override bool GuardEvent(int eventId){// 特定のタイミングで遷移を拒否（ガード）するなら true を返せばステートマシンは遷移を諦めますif (!Context.isActiveAndEnabled){return true;}// 遷移を許可するなら false を返せばステートマシンは状態の遷移をしますreturn false;}// ステートマシンが前回のプッシュした状態に復帰する時の処理をするならこのGuardPopで行うprotected internal override bool GuardPop(){// 復帰を拒否（ガード）するなら true を返せばステートマシンは復帰を諦めますif (!Context.isActiveAndEnabled){return true;}// 復帰を許可するなら false を返せばステートマシンは復帰しますreturn false;}}}
状態を定義しているだけの何もしないクラス
この Hoge クラスのステートマシン
*private ImtStateMachine<;Hoge>; stateMachine;
*{// 何もしない状態クラスなら何も書かなくても良い（むしろ無駄なoverrideは避ける）}
この Hoge クラスのアイドリング状態クラス
何もしない状態クラスなら何も書かなくても良い（むしろ無駄なoverrideは避ける）
*}
*{// 状態へ突入時の処理はこのEnterで行うprotected internal override void Enter(){}// 状態の更新はこのUpdateで行うprotected internal override void Update(){}// 状態から脱出する時の処理はこのExitで行うprotected internal override void Exit(){}// 状態で発生した未処理の例外がキャッチされた時の処理はこのErrorで行うprotected internal override bool Error(Exception exception){// 未処理の例外をハンドリングしたのなら true を返すことで、ステートマシンはエラーから復帰しますreturn true;}// ステートマシンが状態の遷移をする前にステートマシンのイベント入力を処理するならこのGuardEventで行うprotected internal override bool GuardEvent(int eventId){// 特定のタイミングで遷移を拒否（ガード）するなら true を返せばステートマシンは遷移を諦めますif (!Context.isActiveAndEnabled){return true;}// 遷移を許可するなら false を返せばステートマシンは状態の遷移をしますreturn false;}// ステートマシンが前回のプッシュした状態に復帰する時の処理をするならこのGuardPopで行うprotected internal override bool GuardPop(){// 復帰を拒否（ガード）するなら true を返せばステートマシンは復帰を諦めますif (!Context.isActiveAndEnabled){return true;}// 復帰を許可するなら false を返せばステートマシンは復帰しますreturn false;}}
この Hoge クラスのなにかを処理している状態クラス
*{}
状態へ突入時の処理はこのEnterで行う
*{}
状態の更新はこのUpdateで行う
*{}
状態から脱出する時の処理はこのExitで行う
*{// 未処理の例外をハンドリングしたのなら true を返すことで、ステートマシンはエラーから復帰しますreturn true;}
状態で発生した未処理の例外がキャッチされた時の処理はこのErrorで行う
未処理の例外をハンドリングしたのなら true を返すことで、ステートマシンはエラーから復帰します
*return true;
*{// 特定のタイミングで遷移を拒否（ガード）するなら true を返せばステートマシンは遷移を諦めますif (!Context.isActiveAndEnabled){return true;}// 遷移を許可するなら false を返せばステートマシンは状態の遷移をしますreturn false;}
ステートマシンが状態の遷移をする前にステートマシンのイベント入力を処理するならこのGuardEventで行う
*if (!Context.isActiveAndEnabled)*{
特定のタイミングで遷移を拒否（ガード）するなら true を返せばステートマシンは遷移を諦めます
遷移を許可するなら false を返せばステートマシンは状態の遷移をします
*return false;
*{// 復帰を拒否（ガード）するなら true を返せばステートマシンは復帰を諦めますif (!Context.isActiveAndEnabled){return true;}// 復帰を許可するなら false を返せばステートマシンは復帰しますreturn false;}
ステートマシンが前回のプッシュした状態に復帰する時の処理をするならこのGuardPopで行う
*if (!Context.isActiveAndEnabled)*{
復帰を拒否（ガード）するなら true を返せばステートマシンは復帰を諦めます
復帰を許可するなら false を返せばステートマシンは復帰します
*return false;
この Hoge クラスのステートマシン
*private ImtStateMachine<;Hoge>; stateMachine;
*{}
この Hoge クラスのアイドリング状態クラス
*{}
この Hoge クラスのなにかを処理している状態クラス
この関数を呼ぶと（遷移元状態クラスの状態で、入力値の入力をされた時に、遷移先状態クラスの状態へ遷移する）という定義になります。
*stateMachine.AddTransition<;遷移元の状態クラスの型, 遷移先の状態クラスの型>;(入力値);
*{Finish,Reset,}
ステートマシンの入力（イベント）を判り易くするために列挙型で定義
この Hoge クラスのステートマシン
*private ImtStateMachine<;Hoge>; stateMachine;
ステートマシンのインスタンスを生成して遷移テーブルを構築
stateMachine = new ImtStateMachine&lt;Hoge&gt;(this);  自身がコンテキストになるので自身のインスタンスを渡す
*stateMachine.AddTransition<;IdleState, ProcessState>;((int)StateEventId.Finish);
起動ステートを設定（起動ステートは IdleState）
*stateMachine.SetStartState<;IdleState>;();
*{Enable,Disable,}
ステートマシンのイベントID列挙型
中略...
ステートマシン変数の定義、もちろんコンテキストは Player クラス
*private ImtStateMachine<;Player>; stateMachine;
中略...
コンポーネントの初期化
*private void Awake()
中略...
ステートマシンの遷移テーブルを構築（コンテキストのインスタンスはもちろん自分自身）
*stateMachine = new ImtStateMachine<;Player>;(this);
起動状態はDisabled
*stateMachine.SetStartState<;EnabledState>;();
中略...
ステートマシンを起動
*stateMachine.Update();
*{// ステートマシンの更新stateMachine.Update();}
Playerクラスと言っておきながら移動コンポーネントなのでFixedUpdateでステートマシンを回す
ステートマシンの更新
*stateMachine.Update();
*{// ステートマシンに有効イベントを叩きつけるstateMachine.SendEvent((int)StateEventId.Enable);}
プレイヤーの操作を有効にします
ステートマシンに有効イベントを叩きつける
*stateMachine.SendEvent((int)StateEventId.Enable);
*{// ステートマシンに無効イベントを叩きつけるstateMachine.SendEvent((int)StateEventId.Disable);}
プレイヤーの操作を無効にします
ステートマシンに無効イベントを叩きつける
*stateMachine.SendEvent((int)StateEventId.Disable);
*{}
プレイヤーの移動も何も出来ない哀れな状態クラス
*{// 状態の更新を行いますprotected override void Update(){// 中略...}}
プレイヤーの移動が許された状態クラス
*{// 中略...}
状態の更新を行います
中略...
*}
*{Dead,Revive,}
状態イベントの定義
現在の状態が生存状態なら生存していることを返すプロパティ
*public bool IsAlive =>; stateMachine.IsCurrentState<;AliveState>;();
*if (collision.gameObject.name == "Ball")*{
衝突した相手がボールなら
死亡イベントを送る
*stateMachine.SendEvent((int)StateEventId.Dead);
ステートマシンに復活イベントを送る
*stateMachine.SendEvent((int)StateEventId.Revive);
中略...
*}
中略...
*}
*{Play,Miss,Retry,Exit,AllBlockBloken,Finish,}
ステートマシンのイベントID列挙型
中略...
ステートマシン変数の定義、もちろんコンテキストは MainGameScene クラス
*private ImtStateMachine<;MainGameScene>; stateMachine;
*{// ステートマシンの遷移テーブルを構築（コンテキストのインスタンスはもちろん自分自身）stateMachine = new ImtStateMachine<;MainGameScene>;(this);stateMachine.AddTransition<;ResetState, StandbyState>;((int)StateEventId.Finish);stateMachine.AddTransition<;StandbyState, PlayingState>;((int)StateEventId.Play);stateMachine.AddTransition<;PlayingState, MissState>;((int)StateEventId.Miss);stateMachine.AddTransition<;PlayingState, GameClearState>;((int)StateEventId.AllBlockBloken);stateMachine.AddTransition<;MissState, StandbyState>;((int)StateEventId.Retry);stateMachine.AddTransition<;MissState, GameOverState>;((int)StateEventId.Exit);stateMachine.AddTransition<;GameClearState, ResetState>;((int)StateEventId.Finish);stateMachine.AddTransition<;GameOverState, ResetState>;((int)StateEventId.Finish);// 起動状態はResetstateMachine.SetStartState<;ResetState>;();}
コンポーネントの初期化
ステートマシンの遷移テーブルを構築（コンテキストのインスタンスはもちろん自分自身）
*stateMachine = new ImtStateMachine<;MainGameScene>;(this);
起動状態はReset
*stateMachine.SetStartState<;ResetState>;();
ステートマシンを起動
*stateMachine.Update();
ステートマシンの更新
*stateMachine.Update();
ステートマシンにミスイベントを送る
*stateMachine.SendEvent((int)StateEventId.Miss);

ServiceProviderインスタンス生成
*Provider = new ServiceCollection().BuildServiceProvider();
自身のアセンブリにコマンドの処理を構築する為、自身をCommandServiceに追加
*Commands = new CommandService();
Botアカウントに機能を追加
*Client = new DiscordSocketClient();
BotアカウントLogin
*var token = "";
タスクを常駐
*await Task.Delay(-1);
*if (message?.Author.IsBot ?? true)*{
コメントがユーザーかBotかの判定
Botコマンドかどうか判定（判定条件は接頭辞"!"付き発言 or Botアカウントへのメンション）
*int argPos = 0;
実行
*var context = new CommandContext(Client, message);
*if (!result.IsSuccess)*{
実行できなかった場合
*if (face <; 1)*{
入力値検証
サイコロを振ってます・・・
*var resultText = new StringBuilder();
結果一覧の埋め込み要素を作成
*var embed = new EmbedBuilder();
*await ReplyAsync($"{face}面ダイスを{throwCount}回振ったよ！\r\n合計は{summary}、平均値は{((double)summary / throwCount).ToString("#,0.00")}でした。", embed: embed.Build());
結果返却

連続で切ってしまわないように少し遅らせる。適宜調整する
*Invoke("BoolOn", 0.2f);
meshの取得
*attachedMeshFilter = GetComponent<;MeshFilter>;();
*if (coliBool == false)*{
coliboolがfalseの時は何もしない
いろいろ、Vector3は精度のためにdoubleで扱えるようにしたDVector3を使用↓にclassあり
*DVector3 p1, p2, p3;
*for (int i = 0; i <; attachedMesh.triangles.Length; i += 3)*{
カットしたいオブジェクトのメッシュをトライアングルごとに処理
*p1 = new DVector3(transform.TransformPoint(attachedMesh.vertices[attachedMesh.triangles[i]]));*p2 = new DVector3(transform.TransformPoint(attachedMesh.vertices[attachedMesh.triangles[i + 1]]));
メッシュの3つの頂点を取得
頂点がカットする面のどちら側にあるか
*p1Bool = DVector3.Dot(new DVector3(cutPlane.normal), p1) + (double)cutPlane.distance >; 0 ? true : false;
*if (p1Bool &amp;&amp; p2Bool &amp;&amp; p3Bool)*{
3つの頂点が同じ側にある場合はそのまま代入、頂点がカットする場合はその処理を行う
*for (int k = 0; k <; 3; k++)*{
3つの頂点が同じ側にある、そのままそれぞれの1に代入
*for (int k = 0; k <; 3; k++)*{
3つの頂点が同じ側にある、そのままそれぞれの２に代入
3つの頂点が同じ側にない場合の処理１、以下仲間外れの頂点をp,それ以外をcとする
*DVector3 p, c1, c2;
カットした面に生じる新しい頂点を計算、カットする平面の法線方向に対するpとcの距離の比からc-pの長さを決める
*DVector3 cross1 = p + (c1 - p) * (((double)cutPlane.distance + DVector3.Dot(new DVector3(cutPlane.normal), p)) / DVector3.Dot(new DVector3(cutPlane.normal), p - c1));
新しい頂点のuvを計算、pとcの間で線形補間
*Vector2 cross1Uv = Vector2.Lerp(attachedMesh.uv[attachedMesh.triangles[i + n1]], attachedMesh.uv[attachedMesh.triangles[i + n2]], (float)System.Math.Sqrt((cross1 - p).sqrMagnitude / (p - c1).sqrMagnitude));
*cross1 = new DVector3(transform.InverseTransformPoint(cross1.ToVector3()));*cross2 = new DVector3(transform.InverseTransformPoint(cross2.ToVector3()));
本来はDVector3内でやりたいがよくわからないのでVector3のInverseTransfromPointを使用
断面をつくるために取っておく
*crossVertices.Add(cross1);
*if ((p1Bool &amp;&amp; !p2Bool &amp;&amp; !p3Bool) || (!p1Bool &amp;&amp; p2Bool &amp;&amp; !p3Bool) || (!p1Bool &amp;&amp; !p2Bool &amp;&amp; p3Bool))*{
pの２通りの処理、カットする面に対してどちらにあるかで異なる
p側のメッシュを追加
*vertices1.Add(cross1);
c側のメッシュを追加１
*vertices2.Add(cross2);
c側のメッシュを追加2
*vertices2.Add(cross2);
p側のメッシュを追加
*vertices2.Add(cross1);
c側のメッシュを追加１
*vertices1.Add(cross2);
c側のメッシュを追加2
*vertices1.Add(cross2);
meshを減らす処理を行う。(断面以外の処理)、↓に関数あり
*reduceMesh(ref vertices1, ref uvs1, ref normals1, cutPlane);
*if (returnBool)*{
reduceMesh中でCutの中断を判断した場合にreturnする
*if (crossVertices.Count != 0)*{
断面をつくる処理
*for (int i = 0; i <; crossVertices.Count; i += 2)*{
断面で頂点を減らす処理、直線上にある頂点を2つのみにする
*if (System.Math.Abs(DVector3.Dot((crossVertices[i] - crossVertices[i + 1]).normalized, (crossVertices[k] - crossVertices[k + 1]).normalized)) >; 1 - delta)*{
4つの頂点が一直線上にあるか、まず2つのベクトルが平行かどうか
*if ((crossVertices[i] - crossVertices[k]).sqrMagnitude <; delta || (crossVertices[i] - crossVertices[k + 1]).sqrMagnitude <; delta*|| (crossVertices[i + 1] - crossVertices[k]).sqrMagnitude ; delta || (crossVertices[i + 1] - crossVertices[k + 1]).sqrMagnitude ; delta)
同一の頂点を持つかどうか→一直線上にある
*if ((crossVertices[i] - crossVertices[k]).sqrMagnitude <; (crossVertices[i + 1] - crossVertices[k]).sqrMagnitude)*{
以下重なる点に応じた処理、両端を残して後を消去
断面の三角形を作る処理
等しい点を消去
*for (int i = 0; i <; crossVertices.Count; i++)
*for (int i = 2; i <; crossVertices.Count; i++)*{
外周の頂点を並び替え、crossVertices[0]と[1]を基準としてそれぞれの点を並び替える
*if (System.Math.Acos(DVector3.Dot((crossVertices[0] - crossVertices[1]).normalized, (crossVertices[0] - crossVertices[i]).normalized)) == System.Math.Acos(DVector3.Dot((crossVertices[0] - crossVertices[1]).normalized, (crossVertices[0] - crossVertices[j]).normalized)))*{
角度が等しい、一直線上にある場合。本来はないはずだが・・・
*if ((crossVertices[0] - crossVertices[i]).sqrMagnitude >; (crossVertices[0] - crossVertices[j]).sqrMagnitude)*{
基準を変える
並び替え
*crossVertices.Insert(i, crossVertices[j]);
*for (int j = 0; j <; 3; j++)*{
断面のnormalとuvの設定。uvを特別に設定する場合は変えてください
*if (Vector3.Dot(transform.TransformDirection(DVector3.Cross((crossVertices[i] - crossVertices[0]).normalized, (crossVertices[i + 1] - crossVertices[i]).normalized).ToVector3()), cutPlane.normal) <; delta)*{
断面の三角形を追加する　面の表の方向が正しくなるように判断して追加
ひとつのtriangleについてそれぞれ3つずつの頂点を作っているため最後に順番通りにいれる
*triangles1.Clear();
DVector3を通常のVector3に直す、もっと賢いやりかたがありそう
*var list1 = new List<;Vector3>;();
カット後のオブジェクト生成、いろいろといれる
*GameObject obj = new GameObject("cut obj", typeof(MeshFilter), typeof(MeshRenderer), typeof(MeshCollider), typeof(Rigidbody), typeof(MeshCut));
このオブジェクトをデストロイ
*Destroy(gameObject);
まずは同一平面上にある三角形を見つけ出すが、基準となるiをとりあえず追加
*verticeIndices.Clear();
*if (DVector3.Dot(DVector3.Cross((vertices[i + 1] - vertices[i]).normalized, (vertices[i + 2] - vertices[i + 1]).normalized).normalized,*DVector3.Cross((vertices[j + 1] - vertices[j]).normalized, (vertices[j + 2] - vertices[j + 1]).normalized).normalized) >; 1 - delta)
同一の平面上にある三角形かどうか。deltaで調整
*if (j == vertices.Count - 3)*{
全ての三角形について計算してループの最後に行う処理
*if (verticeIndices.Count >; 1)*{
三角形が1つの場合は何もする必要なし
平面上の三角形が2つ以上ある場合
pの入れ物に三角形を3つの直線にしていれる
*for (int k = 0; k <; verticeIndices.Count; k++)
等しい直線を消す（面の外周でない線を消す）
*int sameLineCount = 0;
同一平面上のn個の隣接する三角形にはn-1個の等しい直線があるはずが、ない場合(ここまでの処理がうまくいっていない場合)は処理をやめる
ここらへんは検討中　→　新しい処理追加
*if (sameLineCount != verticeIndices.Count - 1)
同一平面上にあるが三角形が隣接していない場合（本来同一平面上と判定されるはずの三角形が
同一平面上と判定されなかった(切断面の頂点を求める際にある2点がほぼ同じ値を取ってしまった場合)）
にcutPlaneをちょっとずらしてもう一度計算させる。
一度だけ処理させるように以下の分岐でゴニョゴニョ
*if (returnBool2)
ずらす量は暫定的
*Cut(new Plane(cutPlane.normal, -cutPlane.normal * cutPlane.distance + new Vector3(0.02f, 0.02f, 0.02f)));
*if (System.Math.Abs(DVector3.Dot((pVertices[l] - pVertices[l + 1]).normalized, (pVertices[k] - pVertices[k + 1]).normalized)) >; 1 - delta)*{
4つの頂点が一直線上にあるか、2つのベクトルが平行かどうか
*if ((pVertices[l] - pVertices[k]).sqrMagnitude <; delta || (pVertices[l] - pVertices[k + 1]).sqrMagnitude <; delta*|| (pVertices[l + 1] - pVertices[k]).sqrMagnitude ; delta || (pVertices[l + 1] - pVertices[k + 1]).sqrMagnitude ; delta)
同一の点を持つ→一直線上にある
*if ((pVertices[l] - pVertices[k]).sqrMagnitude <; (pVertices[l + 1] - pVertices[k]).sqrMagnitude)*{
以下重なる点に応じた処理、両端を残して後を消去
*for (int k = 0; k <; pVertices.Count; k++)*{
等しい点を消す
*for (int k = 2; k <; pVertices.Count; k++)*{
外周上の点を順番に並び替える.pVertices[0],[1]を基準として並び替え
*if (System.Math.Acos(DVector3.Dot((pVertices[0] - pVertices[1]).normalized, (pVertices[0] - pVertices[k]).normalized)) == System.Math.Acos(DVector3.Dot((pVertices[0] - pVertices[1]).normalized, (pVertices[0] - pVertices[l]).normalized)))*{
等しくなってしまう場合
並び替え
*pVertices.Insert(k, pVertices[l]);
*for (int k = 1; k <; pVertices.Count - 1; k++)*{
外周上の並び替えられた頂点を全て三角形で結ぶように追加
*for (int k = verticeIndices.Count - 1; k >;= 0; k--)*{
追加したので古いのを消去
処理した三角形を考慮してループの位置を調整
*i += 3 * (pVertices.Count - 3);
初期化しておく
*pVertices.Clear();
*{if (i % 3 == 0){return 0;}else if (i % 3 == 1){return 1;}else if (i % 3 == 2){return 2;}else{return 0;}}
ループで使いたかった関数
*{public double x;public double y;public double z;public DVector3(Vector3 a){x = a.x;y = a.y;z = a.z;}public DVector3(double a, double b, double c){x = a;y = b;z = c;}public double sqrMagnitude{get { return x * x + y * y + z * z; }}public Vector3 ToVector3(){return new Vector3((float)x, (float)y, (float)z);}public override string ToString(){return string.Format("({0:0.00000}, {1:0.00000}, {2:0.00000})", x, y, z);}public DVector3 normalized{get { return new DVector3(x / System.Math.Sqrt(this.sqrMagnitude), y / System.Math.Sqrt(this.sqrMagnitude), z / System.Math.Sqrt(this.sqrMagnitude)); }}public static double Dot(DVector3 a, DVector3 b){return a.x * b.x + a.y * b.y + a.z * b.z;}public static DVector3 Cross(DVector3 a, DVector3 b){return new DVector3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);}public static DVector3 operator -(DVector3 a, DVector3 b){return new DVector3(a.x - b.x, a.y - b.y, a.z - b.z);}public static DVector3 operator +(DVector3 a, DVector3 b){return new DVector3(a.x + b.x, a.y + b.y, a.z + b.z);}public static DVector3 operator *(DVector3 a, double b){return new DVector3(a.x * b, a.y * b, a.z * b);}public static DVector3 operator /(DVector3 a, double b){return new DVector3(a.x / b, a.y / b, a.z / b);}}
Vector3をdoubleで使うクラス、使う機能のみ
動く方向で切断する場合
private Vector3 prePos = Vector3.zero;
private Vector3 prePos2 = Vector3.zero;
void FixedUpdate ()
{
prePos = prePos2;
prePos2 = transform.position;
}
このコンポーネントを付けたオブジェクトのCollider.IsTriggerをONにする
*void OnTriggerEnter(Collider other)
*var cutPlane = new Plane (transform.right, transform.position);*//動きで切断する場合
一方向のみで切断する方法、方向については適宜変更
*//var cutPlane = new Plane (Vector3.Cross(transform.forward.normalized, prePos - transform.position).normalized, transform.position);*meshCut.Cut(cutPlane);
動きで切断する場合

初期化後の処理
*}

*services.AddProgressiveWebApp();
←これを追加

*{//Sqlservices.AddDbContext<;JetonModelContext>;(options =>;options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));services.AddDbContext<;ApplicationDbContext>;(options =>;options.UseSqlServer(Configuration.GetConnectionString("UserDabtaseConnection")));services.AddIdentity<;ApplicationUserDataModel, IdentityRole>;().AddEntityFrameworkStores<;ApplicationDbContext>;().AddUserManager<;UserManager<;ApplicationUserDataModel>;>;().AddDefaultTokenProviders();services.Configure<;IdentityOptions>;(options =>;{// Password settingsoptions.Password.RequireDigit = false;options.Password.RequiredLength = 6;options.Password.RequireNonAlphanumeric = false;options.Password.RequireUppercase = false;options.Password.RequireLowercase = false;options.Password.RequiredUniqueChars = 3;// Lockout settingsoptions.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(30);options.Lockout.MaxFailedAccessAttempts = 5;options.Lockout.AllowedForNewUsers = true;// User settingsoptions.User.RequireUniqueEmail = true;});services.AddSingleton<;IHttpContextAccessor, HttpContextAccessor>;();services.AddTransient<;IAccountHandler, AccountHandler>;();services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);// Register the Swagger generator, defining 1 or more Swagger documentsservices.AddSwaggerGen(c =>;{c.SwaggerDoc("v1", new Info{Title = "{title}",Version = "1",Description = "{description}",Contact = new Contact{Name = "{name}",Email = "{email}",Url = "{url}"}});c.OperationFilter<;AddAuthorizationHeaderParameterOperationFilter>;();// Set the comments path for the Swagger JSON and UI.string xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";string xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);c.IncludeXmlComments(xmlPath);});}
This method gets called by the runtime. Use this method to add services to the container.
*{c.SwaggerDoc("v1", new Info{Title = "{title}",Version = "1",Description = "{description}",Contact = new Contact{Name = "{name}",Email = "{email}",Url = "{url}"}});c.OperationFilter<;AddAuthorizationHeaderParameterOperationFilter>;();// Set the comments path for the Swagger JSON and UI.string xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";string xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);c.IncludeXmlComments(xmlPath);});
Register the Swagger generator, defining 1 or more Swagger documents
*string xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
Set the comments path for the Swagger JSON and UI.
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseHsts();}// Enable middleware to serve generated Swagger as a JSON endpoint.app.UseSwagger();// Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.),// specifying the Swagger JSON endpoint.app.UseSwaggerUI(c =>;{c.SwaggerEndpoint("/swagger/v1/swagger.json", "Jeton API V1");c.RoutePrefix = string.Empty;});app.UseAuthentication();app.UseHttpsRedirection();app.UseMvc();}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
*// specifying the Swagger JSON endpoint.*app.UseSwaggerUI(c =>;
Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.),
*{c.SwaggerEndpoint("/swagger/v1/swagger.json", "Jeton API V1");c.RoutePrefix = string.Empty;});
specifying the Swagger JSON endpoint.

*xmlns:x="http:
schemas.microsoft.comwinfx2009xaml"
値を取得したときのイベントハンドラをセット
*Compass.ReadingChanged += Compass_ReadingChanged;
コンパス値の取得開始
*Compass.Start(SensorSpeed.UI);
*{var data = e.Reading;//ラベルに表示LabelCompass.Text = data.HeadingMagneticNorth.ToString();}
値を取得したときに実行される
ラベルに表示
*LabelCompass.Text = data.HeadingMagneticNorth.ToString();

データベースと接続
*connection.Open();
コマンドの組み立て
*command.Connection = connection;
*{while (rdr.Read()){// ひたすら詰め替えるOrderHeader model = new OrderHeader();model.SalesOrderID = rdr["SalesOrderID"] == DBNull.Value ? default(int) : Convert.ToInt32(rdr["SalesOrderID"]);model.RevisionNumber = rdr["RevisionNumber"] == DBNull.Value ? default(byte) : Convert.ToByte(rdr["RevisionNumber"]);model.OrderDate = rdr["OrderDate"] == DBNull.Value ? default(DateTime) : Convert.ToDateTime(rdr["OrderDate"]);model.DueDate = rdr["DueDate"] == DBNull.Value ? default(DateTime) : Convert.ToDateTime(rdr["DueDate"]);model.ShipDate = rdr["ShipDate"] == DBNull.Value ? default(DateTime) : Convert.ToDateTime(rdr["ShipDate"]);model.Status = rdr["Status"] == DBNull.Value ? default(byte) : Convert.ToByte(rdr["Status"]);model.OnlineOrderFlag = rdr["OnlineOrderFlag"] == DBNull.Value ? default(bool) : Convert.ToBoolean(rdr["OnlineOrderFlag"]);model.SalesOrderNumber = rdr["SalesOrderNumber"] == DBNull.Value ? string.Empty : Convert.ToString(rdr["SalesOrderNumber"]);model.PurchaseOrderNumber = rdr["PurchaseOrderNumber"] == DBNull.Value ? string.Empty : Convert.ToString(rdr["PurchaseOrderNumber"]);model.AccountNumber = rdr["AccountNumber"] == DBNull.Value ? string.Empty : Convert.ToString(rdr["AccountNumber"]);model.CustomerID = rdr["CustomerID"] == DBNull.Value ? default(int) : Convert.ToInt32(rdr["CustomerID"]);model.SalesPersonID = rdr["SalesPersonID"] == DBNull.Value ? default(int) : Convert.ToInt32(rdr["SalesPersonID"]);model.TerritoryID = rdr["TerritoryID"] == DBNull.Value ? default(int) : Convert.ToInt32(rdr["TerritoryID"]);model.BillToAddressID = rdr["BillToAddressID"] == DBNull.Value ? default(int) : Convert.ToInt32(rdr["BillToAddressID"]);model.ShipToAddressID = rdr["ShipToAddressID"] == DBNull.Value ? default(int) : Convert.ToInt32(rdr["ShipToAddressID"]);model.ShipMethodID = rdr["ShipMethodID"] == DBNull.Value ? default(int) : Convert.ToInt32(rdr["ShipMethodID"]);model.CreditCardID = rdr["CreditCardID"] == DBNull.Value ? default(int) : Convert.ToInt32(rdr["CreditCardID"]);model.CreditCardApprovalCode = rdr["CreditCardApprovalCode"] == DBNull.Value ? string.Empty : Convert.ToString(rdr["CreditCardApprovalCode"]);model.CurrencyRateID = rdr["CurrencyRateID"] == DBNull.Value ? default(int) : Convert.ToInt32(rdr["CurrencyRateID"]);model.SubTotal = rdr["SubTotal"] == DBNull.Value ? default(decimal) : Convert.ToDecimal(rdr["SubTotal"]);model.TaxAmt = rdr["TaxAmt"] == DBNull.Value ? default(decimal) : Convert.ToDecimal(rdr["TaxAmt"]);model.Freight = rdr["Freight"] == DBNull.Value ? default(decimal) : Convert.ToDecimal(rdr["Freight"]);model.TotalDue = rdr["TotalDue"] == DBNull.Value ? default(decimal) : Convert.ToDecimal(rdr["TotalDue"]);model.Comment = rdr["Comment"] == DBNull.Value ? string.Empty : Convert.ToString(rdr["Comment"]);model.rowguid = rdr["rowguid"] == DBNull.Value ? default(Guid) : (Guid)rdr["rowguid"];model.ModifiedDate = rdr["ModifiedDate"] == DBNull.Value ? default(DateTime) : Convert.ToDateTime(rdr["ModifiedDate"]);modelList.Add(model);}}
SQLの実行
ひたすら詰め替える
*OrderHeader model = new OrderHeader();
データベースと接続
*connection.Open();
Dapperでマッピング
*return connection.Query<;OrderHeader>;(selectQuery).ToList();
DBSimpleでマッピング
*return DBSimple.SimpleMap<;OrderHeader>;(connectionString, selectQuery);

*{services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);services.AddSingleton<;IHttpContextAccessor, HttpContextAccessor>;();//Sqlservices.AddDbContext<;ApplicationDbContext>;(options =>;options.UseSqlServer(Configuration.GetConnectionString("UserDabtaseConnection")));// ADDEDservices.AddIdentity<;ApplicationUserDataModel, IdentityRole>;().AddEntityFrameworkStores<;ApplicationDbContext>;().AddDefaultTokenProviders();// Register the Swagger generator, defining 1 or more Swagger documentsservices.AddSwaggerGen(c =>;{c.SwaggerDoc("v1", new Info{Title = "{title}",Version = "1",Description = "{description}",Contact = new Contact{Name = "{name}",Email = "{email}",Url = "{url}"}});c.OperationFilter<;AddAuthorizationHeaderParameterOperationFilter>;();// Set the comments path for the Swagger JSON and UI.string xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";string xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);c.IncludeXmlComments(xmlPath);});}
This method gets called by the runtime. Use this method to add services to the container.
*{c.SwaggerDoc("v1", new Info{Title = "{title}",Version = "1",Description = "{description}",Contact = new Contact{Name = "{name}",Email = "{email}",Url = "{url}"}});c.OperationFilter<;AddAuthorizationHeaderParameterOperationFilter>;();// Set the comments path for the Swagger JSON and UI.string xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";string xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);c.IncludeXmlComments(xmlPath);});
Register the Swagger generator, defining 1 or more Swagger documents
*string xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
Set the comments path for the Swagger JSON and UI.
*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseHsts();}// Enable middleware to serve generated Swagger as a JSON endpoint.app.UseSwagger();// Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.),// specifying the Swagger JSON endpoint.app.UseSwaggerUI(c =>;{c.SwaggerEndpoint("/swagger/v1/swagger.json", "{name}");c.RoutePrefix = string.Empty;});// ADDEDapp.UseAuthentication();app.UseHttpsRedirection();app.UseMvc();}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
*// specifying the Swagger JSON endpoint.*app.UseSwaggerUI(c =>;
Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.),
*{c.SwaggerEndpoint("/swagger/v1/swagger.json", "{name}");c.RoutePrefix = string.Empty;});
specifying the Swagger JSON endpoint.

オーディオイベントの制御
Clovaでのオーディオ再生が終わった際に呼び出される
*if (reqObj["event"]["namespace"].Value<;string>;() == "AudioPlayer")
*if (cache?.StopRequest != null &amp;&amp; cache.StopRequest.IsStopped)*{
LINE Botのメニューから停止要求がされていれば呼び出さない
*cache.StopRequest.BeforId = beforeId;*cache.StopRequest.IsPaused = false;
DBに存在する停止レコードに、直近の再生済みオーディオのIDを更新する
*response.Response.Directives.Add(GetAudioResponseDirective(beforeId, "一時停止中", Consts.SilentAudioFileUrl));*response.ShouldEndSession = true;
一時停止状態の場合は無音を流す（無限ループ）
キャッシュ削除
*await PlayStatusService.DeleteAsync(cache);
*await AddAudioPlayAndPushPictureAsync(response, userId, null, beforeId, log);*}
次のオーディオ再生（画像送付があればそれも）を実施
再生中断された場合
*cache.StopRequest.IsStopped = true;
再生開始OK：DBに記録
再生開始時はStopped=falseで登録
*if (cache?.StopRequest == null)

サイズを最大に
*SetScale(MaxScale);
Spriteにスケールを設定
*nowScale = scale;
サイズが大きければ元のサイズまで徐々に戻す
*SetScale(Mathf.Max(NormalScale, nowScale - (ScaleSpeed * Time.deltaTime)));

*if (parent == null)
戻る遷移の場合は parent が null

*Debug.LogError (string.Format ("Fail Whale!\n{0}", www.error));
エラーを表示

*InOutStream CreateStream(Stream baseStream){// baseStreamストリームを包む// 例えば、何かを圧縮するストリームを生成するcompressStream = new CompressStream(baseStream);// 何かを圧縮するストリームを包んだInOutStream(System.IO.Stream)を返す// 入力側は圧縮するのでcompressStreamだけど、// 出力側は圧縮しないのでbaseStreamそのままを引数に与えるreturn new InOutStream(compressStream, baseStream);}}
例えば、何か圧縮するストリームだとする。
baseStreamストリームを包む
例えば、何かを圧縮するストリームを生成する
*compressStream = new CompressStream(baseStream);
何かを圧縮するストリームを包んだInOutStream(System.IO.Stream)を返す
入力側は圧縮するのでcompressStreamだけど、
出力側は圧縮しないのでbaseStreamそのままを引数に与える
*return new InOutStream(compressStream, baseStream);

取得できない.なんでなん？
var propertyBName = this.propertyB.FindPropertyRelative("name");
*EditorGUILayout.PropertyField(this.serializedPropertyB);
*if(null != this.serializedPropertyB.objectReferenceValue)*{
Bがある場合のみBのメンバ変数を表示する.
Bのメンバを更新する為ちゃんと実行しておきます.
*serializedObjectB.Update();
*serializedObjectB.ApplyModifiedProperties();*}
Bのメンバを更新する為ちゃんと実行しておきます.

シリアライズ
*XmlSerializeUtility.Serialize(CreateConfig(), path);
デシリアライズ
*SampleAppConfig config = XmlSerializeUtility.Deserialize<;SampleAppConfig>;(path);
*{return null;}
これらのメンバはアプリケーションから直接利用するものではないため、明示的に実装しています。
シリアライズされるときのタグを XmlType 属性で指定しています。
*[XmlType("Item")]
*{ConnectionString = "User ID=user1; Password=password1; Host=localhost; Database=sampleDb1;",ConnectionTimeout = 30,};
PostgreSqlConfig クラスのインスタンスを生成

*int medal = 0;
Medal枚数退避エリア（表示するのはこっち）
*void Start () {this.medalText = GameObject.Find("Medal");}
初期化
*void Update () {medalText.GetComponent<;Text>;().text = "MEDAL: " + medal.ToString("D1");}
常時動作
*{this.medalSwap -= 3;this.medal = this.medalSwap;}
bet枚数反映処理
抽選結果をもとにwin枚数を返すメソッド

【memo】
それぞれの小役に対応する番号とwin枚数は以下の通り。
0：ＢＲ　0
1：リプ　3
2：チェ　4
3：ベル　10
4：ｽｲｶ 　15
5：バー　150
6：赤７　350
7：青７　711
*public void GetMedal(int koyaku)
*{this.medal = this.medalSwap;}
medalSwapに入れたwin枚数含む現時点でのMedal枚数をmedalに反映する処理
抽選結果から小役振り分け（ここ次第で勝ち負けが大きく変わる）
【memo】
それぞれの小役に対応する番号と対応する抽選結果の範囲は以下の通り。
0：ＢＲ　0～769　（約1.3分の1）
1：リプ　770～894（8分の1）
2：チェ　945～984（20分の1）
3：ベル　945～984（25分の1）
4：ｽｲｶ   985～992（125分の1）
5：バー　993～996（250分の1）
6：赤７　997～998（500分の1）
7：青７　999     （1000分の1）
*private int GetKoyaku(int lottery)
*//            else if (lottery >;= 770 &amp;&amp; lottery <;= 894) return 1;*//            else if (lottery >;= 895 &amp;&amp; lottery ;= 944) return 2;
if (lottery &gt;= 0 &amp;&amp; lottery &lt;= 769) return 0;
*//            else if (lottery >;= 895 &amp;&amp; lottery <;= 944) return 2;*//            else if (lottery >;= 945 &amp;&amp; lottery ;= 984) return 3;
else if (lottery &gt;= 770 &amp;&amp; lottery &lt;= 894) return 1;
*//            else if (lottery >;= 945 &amp;&amp; lottery <;= 984) return 3;*//            else if (lottery >;= 985 &amp;&amp; lottery ;= 992) return 4;
else if (lottery &gt;= 895 &amp;&amp; lottery &lt;= 944) return 2;
*//            else if (lottery >;= 985 &amp;&amp; lottery <;= 992) return 4;*//            else if (lottery >;= 993 &amp;&amp; lottery ;= 996) return 5;
else if (lottery &gt;= 945 &amp;&amp; lottery &lt;= 984) return 3;
*//            else if (lottery >;= 993 &amp;&amp; lottery <;= 996) return 5;*//            else if (lottery >;= 997 &amp;&amp; lottery ;= 998) return 6;
else if (lottery &gt;= 985 &amp;&amp; lottery &lt;= 992) return 4;
*//            else if (lottery >;= 997 &amp;&amp; lottery <;= 998) return 6;*//            else if (lottery ;= 999) return 7;
else if (lottery &gt;= 993 &amp;&amp; lottery &lt;= 996) return 5;
*//            else if (lottery <;= 999) return 7;*if      (lottery >;=   0 &amp;&amp; lottery ;= 249) return 1;
else if (lottery &gt;= 997 &amp;&amp; lottery &lt;= 998) return 6;
*if      (lottery >;=   0 &amp;&amp; lottery <;= 249) return 1;*else if (lottery >;= 250 &amp;&amp; lottery ;= 499) return 5;
else if (lottery &lt;= 999) return 7;

*return isSuccess.ToString();
ログインの成否 (成功="True" or 失敗="False")

メソッドを対象に属性付与
Obsoleteの説明は後述
*[Obsolete("Old version. Don't use.")]
何らかの処理
*}
Conditionalの説明も後述
*[Conditional("DEBUG"), Obsolete("Old version. Don't use.")]
何らかの処理
*}
StringLengthの説明も後述
*[StringLength(15, ErrorMessage = "会社名は15文字以内で記述してください。")]
getメソッドに対応
*[method: CustomAttribute]
getの返却値に対応
*[return: Required]
setメソッドに対応
*[method: CustomAttribute]
*set { }
setが受け取るvalue引数に対応
*public int AutoProp { get; }
バッキングフィールドを対象とする
この場合はクラスと構造体に対し属性の設定が可能で、複数回付与でき、属性のターゲットが継承時には属性は引き継がれません。
*[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct,
作者名
*private string Name;
*public AuthorAttribute(string name) { Name = name; }
対象が動作するバージョン

*Console.ReadKey();
コンソールが閉じないように。

*{base.Start();sp = new Stopwatch();NativeArray = GameObject.Find(nameof(NativeArray)).GetComponent<;Text>;();Array = GameObject.Find(nameof(Array)).GetComponent<;Text>;();UnsafeArray = GameObject.Find(nameof(UnsafeArray)).GetComponent<;Text>;();Ptr = GameObject.Find(nameof(Ptr)).GetComponent<;Text>;();UnsafePtr = GameObject.Find(nameof(UnsafePtr)).GetComponent<;Text>;();}
Start is called before the first frame update

*Observable.
*オペレータ*.Subscribe(したい処理);
偶数のときだけ処理をする
*Observable.Range(0,10)
10倍にする（処理の中で変化させた値を使用できる）
*Observable.Range(0,10)
入力
登録
*var s = new Subject<;nt>;();
発火
*s.OnNext();
出力
*OnNext
5秒後に１秒間隔で値が発行される
*var t = Observable.Timer(TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(1));

*public int count;
生成数
*{[ReadOnly]public SharedComponentDataArray<;Cube>; Spawner;public ComponentDataArray<;Position>; Position;public EntityArray Entity;public readonly int Length;}
要求リスト一覧
*// so before we get to the next spawner we have to reinject them*UpdateInjectedComponentGroups();
Instantiate &amp; AddComponent &amp; RemoveComponent calls invalidate the injected groups,

*if (request.Request.Type == RequestType.IntentRequest)*{
IntentRequestのみここにくる想定
占い結果を返す。今回は適当占いなのでランダムにどちらか
(本来はここでスロットの星座を受け取ってそれに基づいた処理を行う)
*if (new System.Random().Next() % 2 == 0)
使い方
*response.AddText("あなたの星座を教えてください。占ってあげます。");
その他のインテントの場合
*response.AddText("よくわかりませんでしたが、まあまあだと思います。");
エラー
*response.AddText("よくわかりませんでしたが、たぶんラッキーな1日になると思いますよ。");
エラー
*response.AddText("よくわかりませんでしたが、きっと大丈夫ですよ。");

*public bool HasName() =<; string.IsNullOrEmpty(_Name);
戻り値があるメソッド
*{private string _Name;private int _Number;private int _Score;public string Name =>; _Name;public int Number =>; _Number;public int Score =>; _Score;public Student(string name, int number){_Name = name;_Number = number;}public void SetScore(int score) =>; _Score = score;public bool HasName() =>; string.IsNullOrEmpty(_Name);public int CompareNumber(Student student) =>; _Number.CompareTo(student?.Number ?? 0);}
48行 → 17行
*{private List<;Student>; _Students = new List<;Student>;();public List<;Student>; Students =>; _Students;public Teacher(IEnumerable<;Student>; students){_Students.AddRange(students);}public double AverageScore() =>; _Students.Select(student =>; student.Score).DefaultIfEmpty(0).Average();}
20行 → 10行
*{public void ResetScore(Student student) =>; student?.SetScore(0);public IEnumerable<;Student>; CreateSample(int count) =>; Enumerable.Range(1, count).Select(number =>; new Student($"生徒{number.ToString()}", number));public IEnumerable<;Student>; GetAllStudents(IEnumerable<;Teacher>; teachers) =>; teachers.SelectMany(teacher =>; teacher.Students);public IEnumerable<;String>; GetStudentNames(IEnumerable<;Person>; people) =>; people.OfType<;Student>;().Select(student =>; student.Name);}
41行 → 7行

*{private Vector3 changePosition;void Update(){//Move sphere straightchangePosition = new Vector3(0.1f,0.0f,0.0f);transform.position += changePosition;}}
Transform.position example

引数で取得したい情報を指定
*var videosList = youtubeService.Videos.List("LiveStreamingDetails");
動画情報の取得
*var videoListResponse = videosList.Execute();
*foreach (var videoID in videoListResponse.Items)*{
LiveChatIDを返す
動画情報取得できない場合はnullを返す
*return null;

*var t = SendCommandToESP8266Async("GPIOSW");
処理に時間がかかる場合があるのでawaitせずに実行
*Log($"{client.Client.RemoteEndPoint},404,{path}");
コマンド受信時はわざとエラーを返すことで、VRC_Panoramaが再度接続してくるようにする。

(中略)
*Matcher Rahmen = ("醤油"._() | "みそ"._() | "豚骨"._()) + "ラーメン"._();
(中略)
*Matcher Rahmen = ("醤油"._() | "みそ"._() | "豚骨"._()) + "ラーメン"._();
数字１文字
*Matcher Numeric = '0'.To('9');
大文字１文字
*Matcher UpperCaseAlphabet = 'A'.To('Z');
小文字１文字
*Matcher LowerCaseAlphabet = 'a'.To('z');
数字か大文字か小文字１文字
*Matcher WordChar = Numeric | UpperCaseAlphabet | LowerCaseAlphabet ;
(中略)
*Matcher Curry = Begin + "カレーライス" + End;
マイナス記号
*Matcher Minus = '-'._();
数字
*Matcher Numeric = '0'.To('9');
整数値
*Matcher IntegerValue = '0' | (Minus._01() + '1'.To('9') + Numeric._1Max());
ゼロで始まっても良い整数値
*Matcher Numerics = Numeric._1Max();
小数部
*Matcher RealPart = '.' + Numerics;
正負の符号
*Matcher Sign = Minus | '+';
指数部
*Matcher ExponentPart = ('e'._() | 'E') + Sign._01() + Numerics;
実数値
*Matcher RealNumber = IntegerValue + RealPart._01() + ExponentPart._01();
数字１文字
*Matcher Numeric = '0'.To('9');
アルファベット１文字
*Matcher Alphabet = 'A'.To('Z') | 'a'.To('z');
*Matcher Identifier = (Alphabet | '_') + (Alphabet | '_' | Numeric)._0Max();*,,,
識別子

*currentBaseState = anim.GetCurrentAnimatorStateInfo (0);
参照用のステート変数にBase Layer (0)の現在のステートを設定する
*if (!anim.IsInTransition (0)) {*anim.SetBool ("Punch", false);
ステートが遷移中でない場合、Punchフラグをリセットする（ループしないようにする）
*if (!anim.IsInTransition (0)) {*anim.SetBool ("Kick", false);
ステートが遷移中でない場合、Kickフラグをリセットする（ループしないようにする）

*namespace Main{public class Hello{public static void Main(){Console.WriteLine("hello world!");}}}
Mainという名前空間にHelloクラスが属している

*public struct DiscreteFourierTransform {*// 波サンプルデータの長さ
愚直に離散フーリエ変換を行うための構造体
波サンプルデータの長さ
*int Samples;
*public DiscreteFourierTransform(int Samples) {*// 引数の値が2の自然数乗でなければ例外を投げる
コンストラクタ
*for(int i = 2; i <;= Samples; i *= 2)*if(Samples % i != 0 || Samples ;= 0) throw new DomainException();
引数の値が2の自然数乗でなければ例外を投げる
波サンプルデータの長さを格納
*this.Samples = Samples;
*public double[] GetSpectrum(double[] WaveSamples, WindowFunction Window) {// 引数となる配列の長さが Samples に等しくなければ例外を投げるif(WaveSamples.Length != Samples) throw new SampleDataLengthException();// 返り値になる周波数成分データdouble[] Spectrum = new double[Samples];// 波サンプルに窓関数を掛けるfor(int i = 0; i <; Samples; i++) WaveSamples[i] *= Window((double)i / Samples);// 離散フーリエ変換for(int i = 0; i <; Samples; i++) {double re = 0, im = 0;for(int j = 0; j <; Samples; j++) {double arg = -2 * Math.PI / Samples * i * j;re += Math.Cos(arg) * WaveSamples[j];im += Math.Sin(arg) * WaveSamples[j];}Spectrum[i] = Math.Sqrt(re * re + im * im);}// Spectrum を返すreturn Spectrum;}
周波数成分を取得するメソッド
*public double[] GetSpectrum(double[] WaveSamples, WindowFunction Window) {// 引数となる配列の長さが Samples に等しくなければ例外を投げるif(WaveSamples.Length != Samples) throw new SampleDataLengthException();// 返り値になる周波数成分データdouble[] Spectrum = new double[Samples];// 波サンプルに窓関数を掛けるfor(int i = 0; i <; Samples; i++) WaveSamples[i] *= Window((double)i / Samples);// 離散フーリエ変換for(int i = 0; i <; Samples; i++) {double re = 0, im = 0;for(int j = 0; j <; Samples; j++) {double arg = -2 * Math.PI / Samples * i * j;re += Math.Cos(arg) * WaveSamples[j];im += Math.Sin(arg) * WaveSamples[j];}Spectrum[i] = Math.Sqrt(re * re + im * im);}// Spectrum を返すreturn Spectrum;}
引数 Function には自作した窓関数を指定することができる
*if(WaveSamples.Length != Samples) throw new SampleDataLengthException();*// 返り値になる周波数成分データ
引数となる配列の長さが Samples に等しくなければ例外を投げる
返り値になる周波数成分データ
*double[] Spectrum = new double[Samples];
*for(int i = 0; i <; Samples; i++) WaveSamples[i] *= Window((double)i / Samples);*// 離散フーリエ変換
波サンプルに窓関数を掛ける
*for(int i = 0; i <; Samples; i++) {*double re = 0, im = 0;
離散フーリエ変換
Spectrum を返す
*return Spectrum;
*public struct FastFourierTransform {*// 波サンプルデータの長さ
高速で離散フーリエ変換を行うための構造体
波サンプルデータの長さ
*int Samples;
回転因子
*double[,] Twiddle;
ビット逆順
*int[] Bitreverse;
*public FastFourierTransform(int Samples) {*// 引数の値が2の自然数乗でなければ例外を投げる
コンストラクタ
*for(int i = 2; i <;= Samples; i *= 2)*if(Samples % i != 0 || Samples ;= 0) throw new DomainException();
引数の値が2の自然数乗でなければ例外を投げる
波サンプルデータの長さを格納
*this.Samples = Samples;
*for(int i = 0; i <; Samples / 2; i++) {double arg = -2.0 * Math.PI / Samples * i;Twiddle[0, i] = Math.Cos(arg);Twiddle[1, i] = Math.Sin(arg);}
回転因子を格納する
*for(int i = 0; i <; Samples; i++) {int Order = i, Reverse = 0;for(int j = Samples / 2; j >;= 1; j /= 2) {Reverse += (Order % 2) * j;Order /= 2;}Bitreverse[i] = Reverse;}
ビット逆順を格納する
*public double[] GetSpectrum(double[] WaveSamples, WindowFunction Window) {// 引数となる配列の長さが Samples に等しくなければ例外を投げるif(WaveSamples.Length != Samples) throw new SampleDataLengthException();// 引数の波形データは予め虚数部に代入するdouble[] Wave_Re = new double[Samples], Wave_Im = WaveSamples;// ビット逆順をかけた波形データを実数部に入れ替える// 入れ替えたデータはその都度クリアしていく// ついでに窓関数をかけておくfor(int i = 0; i <; Samples; i++) {Wave_Re[i] = Wave_Im[Bitreverse[i]] * Window((double)Bitreverse[i] / Samples);Wave_Im[Bitreverse[i]] = 0.0;}// バタフライ演算をするfor(int i = 1; i <; Samples; i *= 2)for(int j = 0; j <; Samples; j += i * 2)for(int k = 0; k <; i; k++) {int a = j + k;int b = a + i;int w = Samples / (2 * i) * k;doublear = Wave_Re[a] + Wave_Re[b] * Twiddle[0, w] - Wave_Im[b] * Twiddle[1, w],ai = Wave_Im[a] + Wave_Re[b] * Twiddle[1, w] + Wave_Im[b] * Twiddle[0, w],br = Wave_Re[a] - Wave_Re[b] * Twiddle[0, w] + Wave_Im[b] * Twiddle[1, w],bi = Wave_Im[a] - Wave_Re[b] * Twiddle[1, w] - Wave_Im[b] * Twiddle[0, w];Wave_Re[a] = ar;Wave_Im[a] = ai;Wave_Re[b] = br;Wave_Im[b] = bi;}// 複素数形式の波形データの絶対値を返すfor(int i = 0; i <; Samples; i++) Wave_Re[i] = Math.Sqrt(Wave_Re[i] * Wave_Re[i] + Wave_Im[i] * Wave_Im[i]);return Wave_Re;}
周波数成分を取得するメソッド
*public double[] GetSpectrum(double[] WaveSamples, WindowFunction Window) {// 引数となる配列の長さが Samples に等しくなければ例外を投げるif(WaveSamples.Length != Samples) throw new SampleDataLengthException();// 引数の波形データは予め虚数部に代入するdouble[] Wave_Re = new double[Samples], Wave_Im = WaveSamples;// ビット逆順をかけた波形データを実数部に入れ替える// 入れ替えたデータはその都度クリアしていく// ついでに窓関数をかけておくfor(int i = 0; i <; Samples; i++) {Wave_Re[i] = Wave_Im[Bitreverse[i]] * Window((double)Bitreverse[i] / Samples);Wave_Im[Bitreverse[i]] = 0.0;}// バタフライ演算をするfor(int i = 1; i <; Samples; i *= 2)for(int j = 0; j <; Samples; j += i * 2)for(int k = 0; k <; i; k++) {int a = j + k;int b = a + i;int w = Samples / (2 * i) * k;doublear = Wave_Re[a] + Wave_Re[b] * Twiddle[0, w] - Wave_Im[b] * Twiddle[1, w],ai = Wave_Im[a] + Wave_Re[b] * Twiddle[1, w] + Wave_Im[b] * Twiddle[0, w],br = Wave_Re[a] - Wave_Re[b] * Twiddle[0, w] + Wave_Im[b] * Twiddle[1, w],bi = Wave_Im[a] - Wave_Re[b] * Twiddle[1, w] - Wave_Im[b] * Twiddle[0, w];Wave_Re[a] = ar;Wave_Im[a] = ai;Wave_Re[b] = br;Wave_Im[b] = bi;}// 複素数形式の波形データの絶対値を返すfor(int i = 0; i <; Samples; i++) Wave_Re[i] = Math.Sqrt(Wave_Re[i] * Wave_Re[i] + Wave_Im[i] * Wave_Im[i]);return Wave_Re;}
引数 Function には自作した窓関数を指定することができる
*if(WaveSamples.Length != Samples) throw new SampleDataLengthException();*// 引数の波形データは予め虚数部に代入する
引数となる配列の長さが Samples に等しくなければ例外を投げる
引数の波形データは予め虚数部に代入する
*double[] Wave_Re = new double[Samples], Wave_Im = WaveSamples;
ビット逆順をかけた波形データを実数部に入れ替える
入れ替えたデータはその都度クリアしていく
ついでに窓関数をかけておく
*for(int i = 0; i <; Samples; i++) {
*for(int i = 1; i <; Samples; i *= 2)*for(int j = 0; j ; Samples; j += i * 2)
バタフライ演算をする
*for(int i = 0; i <; Samples; i++) Wave_Re[i] = Math.Sqrt(Wave_Re[i] * Wave_Re[i] + Wave_Im[i] * Wave_Im[i]);*return Wave_Re;
複素数形式の波形データの絶対値を返す

*int C_num = B_C_request[B_num];
B_numからいらいを受けた人

*string url = "http:
localhost:5000bikes" + id + "";

*{}
UnityEventの引数指定用のダミークラス
データを受信したときに発火されるイベント
*public static ReceivedCallback OnReceivedEvent = new ReceivedCallback();
*if(receiveTask != null &amp;&amp; receiveTask.Status == TaskStatus.Running)*{
isRunningをfalseにするとTaskが止まるのでそれを待つ
登録したイベントを発火
*OnReceivedEvent.Invoke(text);
ボーレート (bit/sec)
*public int baudRate = 115200;
*if(isDebug &amp;&amp; currentPortName != null)*{
Debug用
*{if(isRunning) return;currentPortName = portName;serialPort = new SerialPort(portName, baudRate, Parity.None, 8, StopBits.One);serialPort.Open();isRunning = true;task = ReadAsync();}
ポート名を指定してSerialPortを開く
*if (task != null &amp;&amp; task.Status == TaskStatus.Running)*{
タスクの終了待ち
*if (serialPort != null &amp;&amp; serialPort.IsOpen)*{
タスクが終了してからSerialPortを閉じる

*Console.WriteLine($"{a[i1]}, {a[i2]}");
"3, 6"

*Action<;in DateTime<; action;
コンパイルエラーになる

ダメージを与える敵をアタッチする
*public GameObject _attakTarget;
_attakTarget にセットされたオブジェクトから、IDamagable を呼ぶ
*var damagetarget = _attakTarget.GetComponent<;IDamagable>;();
*if (damagetarget != null)*{
IDamagable は AddDamage の処理が必須

*public byte d;
1byte

*{this.webView.LoadUrl($"javascript:MyCalc.onResult({result});");});
メインスレッドから呼ばないとエラー
JavaScript から呼び出すハンドラを追加。
*webView.Configuration.UserContentController.AddScriptMessageHandler(this, "MyHeavyAdd");
*"MyCalc = {};" +
JavaScript 側で MyCalc.heavyAdd(n) が呼ばれた時に window.webkit.messageHandlers.xxx を呼ぶようにする。
時間のかかる処理
*await Task.Delay(1000);
*webView.EvaluateJavaScript($"MyCalc.onResult({result});", null);
結果を通知

*anim.SetFloat("speed", v);
Animator側で設定している"Speed"パラメタにvを渡す

*#if UNITY_EDITOR*if (Input.GetMouseButtonDown(0))
エディタ上
*if (raycastManager.Raycast(Input.GetTouch(0).position, hitResults, TrackableType.All))*{
レイと平面が交差時
端末上での動作
*#else
*if (raycastManager.Raycast(Input.GetTouch(0).position, hitResults, TrackableType.All))*{
レイと平面が交差時

ここでnullチェックをせずに person を使用しようとすると警告が表示される。
Console.WriteLine(person.age);
*if (person != null)
なんやかんや
*}
numの数値が1～7の範囲かどうか
*break;
*Console.WriteLine($"{num[fromBegin]}, {num[fromEnd]}");
出力結果は 1,7

ウィンドウ表示を完全に消したい場合
si.CreateNoWindow = true;
*si.RedirectStandardError = true;
*{Console.WriteLine($"stdout={ev.Data}");};
コールバックの設定
プロセスが終了すると呼ばれる
*ctoken.Cancel();
プロセスの開始
*proc.Start();
非同期出力読出し開始
*proc.BeginErrorReadLine();
終了まで待つ
*ctoken.Token.WaitHandle.WaitOne();
ウィンドウ表示を完全に消したい場合
si.CreateNoWindow = true;
*si.RedirectStandardError = true;
*{Console.WriteLine($"exited");// プロセスが終了すると呼ばれるctoken.Cancel();};
コールバックの設定
プロセスが終了すると呼ばれる
*ctoken.Cancel();
プロセスの開始
*proc.Start();

*note.eventTime = (int)(timeDifference * tempTempoList[j].tick) + tempoList[j].eventTime;
計算後のテンポ変更イベント時間+そこからの自分の時間

*0,
idThread

*{[Register("AppDelegate")]public class AppDelegate : UIApplicationDelegate{// 略[Export("application:openURL:options:")]public override bool OpenUrl(UIApplication app, NSUrl url, NSDictionary options){var uri = new Uri(url.AbsoluteString);var query = HttpUtility.ParseQueryString(uri.Query);var xSuccess = query.Get("x-success");if (!string.IsNullOrEmpty(xSuccess)){app.OpenUrl(new NSUrl(xSuccess + "?hoge=fuga"), new NSDictionary(), null);}return true;}}}
略
略
*[Export("application:openURL:options:")]

*for(var i = 0; i <; line; i++){*numArray[i] = Console.ReadLine();
int number = 0;
自分の得意な言語で
Let's チャレンジ！！
*int line = int.Parse(Console.ReadLine());
探したい文字のインデックス番号を取得
*int answerNum = Array.IndexOf(haveMoneyArray, searchNum) + 1;
調べる文字と調べられる文字列を各配列に格納
*int line1 = int.Parse(Console.ReadLine());
*for(var k = 0; k <; line1; k++){*string searchString = searchStringArray[k];
調べる文字　＞　調べられる文字でループ作成
自分の得意な言語で
Let's チャレンジ！！
*string[] NMK = Console.ReadLine().Split(' ');

*var obj = GetNullOrString();
半々の確率でnullか実体のあるstringを返してくれるメソッド
nullではない場合if内部を通る
*}
*//但しスコープはif文限りのため外からはstr変数を使えないことに注意*}
null時には型無し = string型では無いためif内部を通らない
但しスコープはif文限りのため外からはstr変数を使えないことに注意
*}

*var f = new int[H, W];
フィールド

*Label label;
UIのコントロールで、UIスレッドでしかアクセス不可
ポイントは、「LoadFromFileの直後に回される」のではなく、
「LoadFromFileの直後に『UIスレッドが暇なときに回される』という処理を回す」
ということで、コードの雰囲気とは若干タイミングがずれている
*));

*watcher.Query = new EventQuery($"SELECT * FROM RegistryKeyChangeEvent WHERE Hive='{Hive.Name}' AND KeyPath='{KeyPath}'");
キーを監視する場合
*watcher.Query = new EventQuery($"SELECT * FROM RegistryValueChangeEvent WHERE Hive='{Hive.Name}' AND KeyPath='{KeyPath}' AND ValueName='{ValueName}'");
値を監視する場合
*watcher.RegistryKeyChanged += (sender, eventArgs) =>; { Console.WriteLine("Changed"); };
Registry64を使用
Registry64をBaseKeyとして開いておく
*RegistryKey baseKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry64);

*.UseUrls("http:
*:5000")   &lt;- ここの行を追加

自分の得意な言語で
Let's チャレンジ！！
*string line = Console.ReadLine();
自分の得意な言語で
Let's チャレンジ！！
*var N = int.Parse(Console.ReadLine());
工事開始時刻
*startTimeArray = timeArray[0].Split(':');
工事時間（HH：時　MM：分）24時以上60分以上になる場合の処理
*addHH = int.Parse(timeArray[1]);
*if(HH.ToString().Length == 1){*stringHH = "0" + HH.ToString();
2桁出力になるような処理
工事終了時間
*Console.WriteLine(stringHH + ":" + stringMM);

*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame
*void Start () {}
Use this for initialization
*void FixedUpdate () {current = Mathf.SmoothDamp(current,10,ref speed,2f);transform.position = new Vector3(current, 0, 0);}
Update is called once per frame

コンソールにログを表示させる
*GrpcEnvironment.SetLogger(new Grpc.Core.Logging.ConsoleLogger());
*{Services = { service },Ports = { new ServerPort("localhost", 12345, ServerCredentials.Insecure) }};
localhost:12345でListen
MagicOnion起動
*server.Start();
コンソールアプリが落ちないようにReadLineで待つ
*Console.ReadLine();
ルームは全員固定
*const string roomName = "SampleRoom";
ルームに参加&amp;ルームを保持
*this.room = await this.Group.AddAsync(roomName);
自分の名前も保持
*me = userName;
参加したことをルームに参加している全メンバーに通知
*this.Broadcast(room).OnJoin(userName);
ルーム内のメンバーから自分を削除
*await room.RemoveAsync(this.Context);
退室したことを全メンバーに通知
*this.Broadcast(room).OnLeave(me);
発言した内容を全メンバーに通知
*this.Broadcast(room).OnSendMessage(me, message);
受信メッセージ
*public Text ChatText;
入室・退室UI
*public Button JoinOrLeaveButton;
テキスト送信UI
*public Button SendMessageButton;
*{this._isJoin = false;//Client側のHubの初期化this._channel = new Channel("localhost:12345", ChannelCredentials.Insecure);this._chutHub = StreamingHubClient.Connect<;IChatHub, IChatHubReceiver>;(this._channel, this);//メッセージ送信ボタンはデフォルト非表示this.SendMessageButton.gameObject.SetActive(false);}
Start is called before the first frame update
Client側のHubの初期化
*this._channel = new Channel("localhost:12345", ChannelCredentials.Insecure);
メッセージ送信ボタンはデフォルト非表示
*this.SendMessageButton.gameObject.SetActive(false);
*{}
Update is called once per frame
メッセージ送信ボタンを非表示に
*this.SendMessageButton.gameObject.SetActive(false);
メッセージ送信ボタンを表示
*this.SendMessageButton.gameObject.SetActive(true);
*if (!this._isJoin)*return;
入室してなかったら何もしない

CatもDogもWalkを実装済み。
*animal.Walk();

*"  categories are" + categories[ki]);
カテゴリを適当に表示する
モデルデータの破棄
*model_data.Dispose();
*{var q = new List<;Tuple<;float, int>;>;();for (var i = 0; first != last; first++, i++){q.Add(Tuple.Create(*first, i));}return q.OrderByDescending(_ =>; _.Item1).Take(k).Select(_ =>; _.Item2).ToArray();}
-------------------------------------------------

ロード処理を並列で実行する
*var cl = new CoroutineList();
通信処理をごにょごにょ
*}
プレハブ読み込みをごにょごにょ
*}
その他並列で読み込みたいものをごにょごにょ
*}

*void RequestTokenCallback(bool success) {if (!success) return;Application.OpenURL(Twity.Oauth.authorizeURL);}
Twityライブラリではリクエストトークンを取得した時点でOauth.authorizeURLに認可用URLが格納されます
success == trueの時点でOauth.accessToken、Oauth.accessTokenSecret、Oauth.screenNameにはそれぞれの情報が格納されています。
*}
access_tokenとaccess_token_secretが端末内に保存されている場合（＝認可済の場合）
*Twity.Oauth.accessToken = access_token;
*Dictionary<;string, string>; p = new Dictionary<;string, string>; {{"screen_name", Twity.Oauth.screenName}};
access_tokenが何らかの原因で正しくないものになっていないか確認するため、試しにユーザー情報を取得する
*} else {
何らかの原因でaccess_token等がおかしい可能性があるので、一旦削除して最初からやりなおす
認可は成功している
*}
*if (CheckRequestToken()) {*// 端末内にrequest_tokenがある場合、
まだ認可されていない場合、端末内にrequest_tokenがあるかどうかをチェックする
端末内にrequest_tokenがある場合、
*Twity.Oauth.requestToken = request_token;
*} else {
この状態はpin入力のシーンである場合があるので、入力用のUIを表示する
まだ何もない状態なので、request_tokenの取得を行う
*GenerateRequestToken()
*bool CheckAuthorizationInfo() {access_token = PlayerPrefs.GetString("access_token", "");access_token_secret = PlayerPrefs.GetString("access_token_secret", "");screen_name = PlayerPrefs.GetString("screen_name", "");if (string.IsNullOrEmpty(access_token) || string.IsNullOrEmpty(access_token_secret) || string.IsNullOrEmpty(screen_name)) {return false;} else {return true;}}
端末内にaccess_tokenとaccess_token_secretが保存されているか確認する
*bool CheckRequestToken() {request_token = PlayerPrefs.GetString("request_token", "");request_token_secret = PlayerPrefs.GetString("request_token_secret", "");if (string.IsNullOrEmpty(request_token) || string.IsNullOrEmpty(request_token_secret)) {return false;} else {return true;}}
端末内にrequest_tokenとrequest_token_secretが保存されているか確認する
この時点で認証完了。試しに特定のユーザー情報を出力する
*GetUserInfo("toofu__");

自分の得意な言語で
Let's チャレンジ！！
*var line = int.Parse(Console.ReadLine());
nameAgeに名前と年齢を格納
*string[] nameAge = Console.ReadLine().Split(' ');
年齢に1歳加える
*int age = int.Parse(nameAge[1]) + 1;

*Console.WriteLine(SharpDX.Diagnostics.ObjectTracker.ReportActiveObjects());
一覧表示

*Debug.WriteLine(date1.GetMonthDiff(date2));*Debug.WriteLine(date2.GetMonthDiff(date1));
拡張メソッド版
年度の開始月を引数で指定する
*Debug.WriteLine(DateTimeUtility.GetFiscalYear(date1, 4));
拡張メソッド版
*Debug.WriteLine(date1.GetFiscalYear(4));
年度の開始月を引数で指定する
*Debug.WriteLine(DateTimeUtility.GetFirstDateOfFiscalYear(date1, 4));
拡張メソッド版
*Debug.WriteLine(date1.GetFirstDateOfFiscalYear(4));
年度の開始月を引数で指定する
*Debug.WriteLine(DateTimeUtility.GetLastDateOfFiscalYear(date1, 4));
拡張メソッド版
*Debug.WriteLine(date1.GetLastDateOfFiscalYear(4));
対象日付と年度の開始月を引数で指定する
*Debug.WriteLine(DateTimeUtility.GetFirstDateOfQuarter(date1, 4));
年度, 四半期, 年度の開始月を引数で指定する
*Debug.WriteLine(DateTimeUtility.GetFirstDateOfQuarter(2018, QuarterPeriod.First, 4));
拡張メソッド版
*Debug.WriteLine(date1.GetFirstDateOfQuarter(4));
対象日付と年度の開始月を引数で指定する
*Debug.WriteLine(DateTimeUtility.GetLastDateOfQuarter(date1, 4));
年度, 四半期, 年度の開始月を引数で指定する
*Debug.WriteLine(DateTimeUtility.GetLastDateOfQuarter(2018, QuarterPeriod.First, 4));
拡張メソッド版
*Debug.WriteLine(date1.GetLastDateOfQuarter(4));
拡張メソッド版
*Debug.WriteLine(date1.GetFirstDateOfYear());
拡張メソッド版
*Debug.WriteLine(date1.GetLastDateOfYear());
拡張メソッド版
*Debug.WriteLine(date1.GetFirstDateOfMonth());
拡張メソッド版
*Debug.WriteLine(date1.GetLastDateOfMonth());
拡張メソッド版
*Debug.WriteLine(date1.GetFirstDateOfWeek());
拡張メソッド版
*Debug.WriteLine(date1.GetLastDateOfWeek());
拡張メソッド版
*Debug.WriteLine(date1.GetDateOfCurrentWeek(DayOfWeek.Friday));
拡張メソッド版
*Debug.WriteLine(date1.GetDateOfNextWeek(DayOfWeek.Friday));

*using System.Collections.Generic;
List

*x = x + 1;
ここはC# 5.0まででもOK

*using Microsoft.Bot.Connector.Authentication;
認証
現在の実行環境がProductionかチェック
*_isProduction = env.IsProduction();
AppSettingsと環境変数を取得
*var builder = new ConfigurationBuilder()
*{// .botのパスとシークレット取得var secretKey = Configuration.GetSection("botFileSecret")?.Value;var botFilePath = Configuration.GetSection("botFilePath")?.Value;// .botの読み込みvar botConfig = BotConfiguration.Load(botFilePath ?? @".\BotConfiguration.bot", secretKey);services.AddSingleton(sp =>; botConfig ?? throw new InvalidOperationException($"The .bot config file could not be loaded. ({botConfig})"));// 現在の実行環境におけるエンドポイントを取得var environment = _isProduction ? "production" : "development";var service = botConfig.Services.Where(s =>; s.Type == "endpoint" &amp;&amp; s.Name == environment).FirstOrDefault();if (!(service is EndpointService endpointService)){throw new InvalidOperationException($"The .bot file does not contain an endpoint with name '{environment}'.");}services.AddBot<;StrCountBot>;(options =>;{//APP認証情報options.CredentialProvider = new SimpleCredentialProvider(endpointService.AppId, endpointService.AppPassword);});}
This method gets called by the runtime. Use this method to add services to the container.
.botのパスとシークレット取得
*var secretKey = Configuration.GetSection("botFileSecret")?.Value;
*services.AddSingleton(sp =>; botConfig ?? throw new InvalidOperationException($"The .bot config file could not be loaded. ({botConfig})"));
.botの読み込み
現在の実行環境におけるエンドポイントを取得
*var environment = _isProduction ? "production" : "development";
APP認証情報
*options.CredentialProvider = new SimpleCredentialProvider(endpointService.AppId, endpointService.AppPassword);
*{app.UseBotFramework();}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

外部のウィンドウを作成する。
*bool closed = false;
外部のウィンドウを利用してAltseedを初期化する。
*asd.Engine.InitializeByExternalWindow(window.altseed.Child.Handle, System.IntPtr.Zero, (int)window.altseed.RenderSize.Width, (int)window.altseed.RenderSize.Height, new asd.EngineOption());
外部のウィンドウの処理を進める。
*MainWindow.DoEvents();
*if (closed)*{
外部のウィンドウが閉じられたらAltseed用のゲームループも抜ける。
フォントを生成する。
*var font = asd.Engine.Graphics.CreateDynamicFont("", 30, new asd.Color(255, 255, 255), 0, new asd.Color());
文字描画オブジェクトを生成する。
*asd.TextObject2D obj = new asd.TextObject2D();
描画に使うフォントを設定する。
*obj.Font = font;
描画位置を指定する。
*obj.Position = new asd.Vector2DF(100, 100);
描画する文字列を指定する。
*obj.Text = "C++完全に理解した";
文字描画オブジェクトのインスタンスをエンジンへ追加する。
*asd.Engine.AddObject2D(obj);

*label1.Text = "Answer = " + AmicableSum
2;同じ組を2回数えてしまうため2で割る

*int a = 1;
使用されていない変数

ループする回数取得
*int iDataNum = int.Parse(Console.ReadLine());
2 次元配列のように扱える List の定義
*var varList = new List<;List<;int>;>;();
*for (int i = 0; i <; iDataNum; i++){*var array_1D_ab = Console.ReadLine().Split(' ');
List に要素を代入する
i 行目の要素に List を作成する
*varList.Add(new List<;int>;());
*for (int j = 0; j <; 2; j++)*{
i 行目の要素を作成・追加する
要素の追加
*varList[i].Add(int.Parse(array_1D_ab[j]));
List をジャグ配列に変換する
*var varArray = varList.Select(line =>; line)
ジャグ配列をソートする
*Array.Sort(varArray, StructuralComparisons.StructuralComparer);
*for (int i = 0; i <; varArray.Length; i++)*{
出力
*if (j + 1 == varArray[i].Length)*{
j 列目が最後の要素なら
末尾改行あり出力
*Console.WriteLine(varArray[i][j]);
*{// 末尾改行なし出力Console.Write(varArray[i][j] + " ");}
j 列目が最後の要素では無いなら
末尾改行なし出力
*Console.Write(varArray[i][j] + " ");
ループする回数取得
*int iDataNum = int.Parse(Console.ReadLine());
2 次元配列のように扱える List の定義
*var varList = new List<;List<;int>;>;();
*for (int i = 0; i <; iDataNum; i++){*var array_1D_ab_original = Console.ReadLine().Split(' ');
List に要素を代入する
i 行目の要素に List を作成する
*varList.Add(new List<;int>;());
*for (int j = 0; j <; 2; j++)*{
i 行目の要素を作成・追加する
要素の追加
*varList[i].Add(array_1D_ab[j]);
List をジャグ配列に変換する
*var varArray = varList.Select(line =>; line)
ジャグ配列をソートする
*Array.Sort(varArray, StructuralComparisons.StructuralComparer);
*for (int i = 0; i <; varArray.Length; i++)*{
出力
*if (j + 1 == varArray[i].Length)*{
j 列目が最後の要素なら
末尾改行あり出力
*Console.WriteLine(varArray[i][j - 1]);
*{// 末尾改行なし出力Console.Write(varArray[i][j + 1] + " ");}
j 列目が最後の要素では無いなら
末尾改行なし出力
*Console.Write(varArray[i][j + 1] + " ");

*Xamarin.Essentials.Platform.Init(this, savedInstanceState);
追加！
*{Xamarin.Essentials.Platform.OnRequestPermissionsResult(requestCode, permissions, grantResults);base.OnRequestPermissionsResult(requestCode, permissions, grantResults);}
追加！
*{var mainDisplayInfo = DeviceDisplay.MainDisplayInfo;var width = mainDisplayInfo.Width;var height = mainDisplayInfo.Height;await DisplayAlert("Display Info", $"width: {width}px, height: {height}px", "Close");};
以下を追記

*EditorGUILayout.EndVertical();
20191008 追記　これで閉じないと警告が出まくる
少しスペースを空ける
*EditorGUILayout.Space();
*if (GUILayout.Button("Inspectorに表示されるボタン名"))*{
押下時に実行したい処理

*if (!this.App.Initialize())*{
アプリケーション初期化
アプリケーション終了
*Application.Idle += (e, sender) =>; this.ExitThread();
モーダル状態を捕捉
*Application.EnterThreadModal += this.Application_EnterThreadModal;
Idleイベント登録
*Application.Idle += this.Application_Idle;
App破棄
*this.App.Dispose();
Idleイベント一時解除
*Application.Idle -= this.Application_Idle;
Idleイベント再登録
*Application.Idle += this.Application_Idle;
*while (!SafeNativeMethods.PeekMessage(*out SafeNativeMethods.MSG _, IntPtr.Zero, 0, 0, 0))
ウィンドウメッセージを受信するまでループ処理
アプリケーションの処理を実行
*this.App.DoWork();
初期化処理を書く
エラーなどで終了したい場合は、return false;
*}
メイン処理を書く
アプリケーションを終了するときは、this.ExitApp();
*}
リソースの解放処理を書く
*base.Dispose(disposing);
*if (!this.App.Initialize())*{
アプリケーション初期化
アプリケーション終了
*Application.Idle += (e, sender) =>; this.ExitThread();
モーダル状態を捕捉
*Application.EnterThreadModal += this.Application_EnterThreadModal;
*while (!SafeNativeMethods.PeekMessage(*out SafeNativeMethods.MSG _, IntPtr.Zero, 0, 0, 0))
ウィンドウメッセージを受信するまでループ処理
アプリケーションの処理を実行
*this.App.DoWork();

*var result = source.Aggregate((sum, item) =<; sum + item);
⇒ 6

*browser = new ChromiumWebBrowser("https:
web.basemark.com")

*using NCMB;
追記
ログインしていない
*yield break;
一致する値で取得（例えばユーザーID）
*query.WhereEqualTo("キー", "値");
ソートkeyを設定,updateDateやcreateDateもOK
*query.OrderByDescending("updateDate");
12/1~12/31で抽出,DateTime型で渡せばOK
*query.WhereGreaterThanOrEqualTo("updateDate", new DateTime(2018,12,1));
*{if (e != null){//検索失敗時の処理Debug.Log("失敗");}else{Debug.Log("成功");//objListを使う処理OnResult(objList);}// ログイン処理終了isConnecting = false;});
検索結果を取得
検索失敗時の処理
*Debug.Log("失敗");
objListを使う処理
*OnResult(objList);
ログイン処理終了
*isConnecting = false;
*yield return new WaitWhile(() =>; { return isConnecting; });
ログイン処理が終了するまで以下の行で待機
ただし...
エラーになる
*Debug.log(objList[0]["createDate"]);
エラーになる
*Debug.log(objList[0]["updateDate"]);

*byte[] data = e.Value.ToNativeEvent();
MIDI生値に変換
ポートを開く
*var port = new MidiInPort("loopMIDI Port");
受信イベント登録
*port.Received += MidiReceived;
*while (!Console.KeyAvailable) {*Console.WriteLine("Keep-Alive");
なにかキーを押すと終了

*from name in Parse.CharExcept(new[] { '(', ')', ',' }).AtLeastOnce().Text()
関数名の部分 関数名にカッコやカンマは含まれないはずなので除外する
関数の最初のカッコ
*from lparen in Parse.Char('(')
関数の引数の部分 引数に関数を取る場合があり得るので`Ref`を使用して再帰的にパースされるように定義する
*from arguments in Parse.Ref(() =>; Arguments).DelimitedBy(Parse.Char(',').Token())
関数の閉じカッコ
*from rparen in Parse.Char(')')
関数を表す文字列と引数を表す文字列をExpressionにする関数を呼び出す
*select CallFunction(name, arguments.ToArray());
*Parse.CharExcept(new[] { '(', ')', ',' }).AtLeastOnce().Token().Text().Select(Expression.Constant);
引数のうち、関数でないもの（＝定数）
引数は関数か定数であるはず。なので、まず関数かどうかを評価してから関数でない場合は定数と判断する（なので`Or`を利用している）
*private static readonly Parser<;Expression>; Arguments = Function.Or(Constant);

*// foreachのコメントアウトを外してもコンパイルは通る。*//foreach (var val in q3)
Executeメソッドがnullのみを返すのでこのforeachで"ランタイム"エラーとなる。
*//foreach (var val in q3)*//{
foreachのコメントアウトを外してもコンパイルは通る。
*//{//   Console.WriteLine($"{val}");//}
foreach (var val in q3)
*//   Console.WriteLine($"{val}");
{

*var saveData = new byte[32];
保存するデータとして仮定
暗号化する処理
*var encryptData = Encrypt(saveData, buf);
ファイルに保存する処理
*SaveFile(encryptData);

tranform 移動させたいtranform
time     何秒かけて推移させるか
position 目標とするposition...nullを入れると値は変化しない
rotation 目標とするrotation...nullを入れると値は変化しない
*IEnumerator AnimateCoroutine(Transform transform, float time, Vector3? position, Quaternion? rotation)
*var currentPosition = transform.position;*var currentRotation = transform.rotation;
現在のposition, rotation
目標のposition, rotation
*var targetPosition = position ?? currentPosition;
Coroutine開始フレームから何秒経過したか
*sumTime += Time.deltaTime;
指定された時間に対して経過した時間の割合
*var ratio = sumTime / time;
目標の値に到達したらこのCoroutineを終了する
~.Lerpは割合を示す引数は0 ~ 1の間にClampされるので1より大きくても問題なし
*break;
*{_reset.onClick.AddListener(() =>;{if (_animationCoroutine != null){StopCoroutine(_animationCoroutine);}_cylinder.transform.SetPositionAndRotation(new Vector3(6f, 0f, 0f),Quaternion.Euler(0f, 0f, -60f));});_reset.onClick.Invoke();_go.onClick.AddListener(() =>;{if (_animationCoroutine != null){StopCoroutine(_animationCoroutine);}_animationCoroutine =StartCoroutine(AnimateCoroutine(_cylinder.transform,_slider.value,new Vector3(-6f, 0f, 0f),Quaternion.Euler(0f, 0f, 60f)));});_slider.onValueChanged.AddListener(arg =>; _field.text = arg.ToString());}
Use this for initialization
tranform 移動させたいtranform
time     何秒かけて推移させるか
position 目標とするposition...nullを入れると値は変化しない
rotation 目標とするrotation...nullを入れると値は変化しない
*IEnumerator AnimateCoroutine(Transform transform, float time, Vector3? position, Quaternion? rotation)
*var currentPosition = transform.position;*var currentRotation = transform.rotation;
現在のposition, rotation
目標のposition, rotation
*var targetPosition = position ?? currentPosition;
Coroutine開始フレームから何秒経過したか
*sumTime += Time.deltaTime;
指定された時間に対して経過した時間の割合
*var ratio = sumTime / time;
目標の値に到達したらこのCoroutineを終了する
~.Lerpは割合を示す引数は0 ~ 1の間にClampされるので1より大きくても問題なし
*break;

*var url = "http:
192.168.1.1:80osccommandsexecute";

*{if (action != null) {if (ct != null) {task.ContinueWith(action, (CancellationToken)ct).ConfigureAwait(false);} else {task.ContinueWith(action).ConfigureAwait(false);}} else {if (ct != null) {task.ContinueWith(_ =>; {}, (CancellationToken)ct).ConfigureAwait(false);} else {task.ContinueWith(_ =>; {}).ConfigureAwait(false);}}}
返り値なし
*{if (action != null) {if (ct != null) {task.ContinueWith(action, (CancellationToken)ct).ConfigureAwait(false);} else {task.ContinueWith(action).ConfigureAwait(false);}} else {if (ct != null) {task.ContinueWith(_ =>; {}, (CancellationToken)ct).ConfigureAwait(false);} else {task.ContinueWith(_ =>; {}).ConfigureAwait(false);}}}
返り値あり
*{task.ContinueWith(action ?? (_ =>; { }), ct).ConfigureAwait(false);}
返り値なし
*{task.ContinueWith(action ?? (_ =>; { }), ct).ConfigureAwait(false);}
返り値あり
返り値なし、後処理なし
*AsyncMethod().NoWait();
*AsyncMethodWithResult(ct).NoWait(task =>; { var result = task.Result; }, ct);
返り値あり、後処理あり、CancellationTokenあり

*return (2 * Math.PI) + n;
360度を足す
*{foreach (var observer in _observers){observer.OnNext(state);}}
状況変化を知らせるために購読者に通知する

*=<; Task.FromResult((string?)"");
これだと Task&lt;string?&gt; とみなしてくれない

*.Skip(1)
1行目はカラム名
*var data = ReadCSV("forcsts.csv");*var forecasts = Forecststify(data);
メインメソッド
*class RevealingReferences {readonly IList<;Forecast>; forecasts;// CSVデータでなくIEnumerable<;Forecast>;を受け取るpublic RevealingReferences(IEnumerable<;Forecast>; forecasts) {this.forecasts = forecasts.ToList();}public int[] TemperatureDeferences() =>;forecasts.Select(f =>;f.HighestTemperature - f.OptimumTemperature).ToArray();public double AverageHighTemperature() =>;forecasts.Average(f =>; f.HighestTemperature);}
明瞭な参照
*public RevealingReferences(IEnumerable<;Forecast>; forecasts) {*this.forecasts = forecasts.ToList();
CSVデータでなくIEnumerable&lt;Forecast&gt;を受け取る

処理とかいろいろ
*}
処理とかいろいろ
*}

モデル読み込み
*loadedModel = mlContext.Model.Load(modelLocation, out var modelInputSchema);
画像読み込み
*var predictor = mlContext.Model.CreatePredictionEngine<;ImageNetData, ImageNetPrediction>;(loadedModel);

*{string DisideOfSelsct;Console.WriteLine("フォルダの存在チェック");if (!Directory.Exists(Folderpath)){Console.WriteLine("フォルダが存在しません。フォルダを作成しますか？");Console.WriteLine("作成：yes　作成しない：no");DisideOfSelsct = Console.ReadLine();CreateDirectory(Folderpath, DisideOfSelsct);}else{Console.WriteLine(Folderpath + "は存在します");}return true;}
フォルダの存在確認を行う
*{if (!Directory.Exists(DirectoryFolder) &amp;&amp; Answer.Equals("yes")){Directory.CreateDirectory(DirectoryFolder);}else if(Directory.Exists(DirectoryFolder) &amp;&amp; Answer.Equals("no")){return;}}
フォルダの作成を行う

*serializer.Serialize(writer, value, emptyNamespaces);
3.

*object.Equals(myBase, mySub1)
内部でObject.Equals()が呼ばれる

*YourBrowser_Open();
ここで自由に調理してください

*public string CodeC { get; set; }
固有のコード体系
/* ... */                          固有のデータ構造
*}
*{public MixedStructure Get(string codeA) =>; { /* ... */ }}
SubStructureA を使うサービス
*{public MixedStructure Get(string codeB) =>; { /* ... */ }}
SubStructureB を使うサービス
*{public MixedStructure Get(string codeC) =>; { /* ... */ }}
SubStructureC を使うサービス

自動ダウンロードを有効にするには、第二引数に true を指定します
*ClickOnceController clickOnce = new ClickOnceController(null, true);
アセンブリ名とダウンロードグループ名の組み合わせを登録します
*clickOnce.RegistAssemblyDownloadGroup("ClassLibrary1", "Group1");

*count++;
ボールがDestroyされるたびにcountを1追加
*image = childrenTransform.GetComponent<;Image>;();*image.color = Color.yellow;
一例として子のイメージコンポーネントを取得して色を変える
*{//一度foreachを通ったらimageにはコンポーネントが入っているif (image != null){return;}foreach(Transform childrenTransform in this.gameObject.transform){image = childrenTransform.GetComponent<;Image>;();image.color = Color.yellow;}}
選んだイメージを光らせる
*if (image != null)*{
一度foreachを通ったらimageにはコンポーネントが入っている
例)Shaderの疑似bool値をオンに
*mr[i].SetFloat("_Enabled", 1);

*if(e.KeyValue == 18 )
18:Alt Key Num
System.Diagnosticsはusingで定義済み
*}

オプションセット済みの親コマンドのインスタンスが渡される
*_Parent = parent;
親コマンドの実行も可能
*_Parent.OnExecute();
*Console.WriteLine($"parent X = {_Parent.X}, Y = {Y}");
親クラスのオプションの取得も可能
*{[Option]public string X { get; set; }public void OnExecute(){Console.WriteLine($"in {nameof(MyCommand)}");}}
親コマンド
UseConstructorInjectionに空引数を指定すれば、デフォルトのServiceProviderが使用される
属性ベースのAPIを使用する場合はUseDefaultConventions()は必須
*app.Conventions.UseConstructorInjection(services.BuildServiceProvider()).UseDefaultConventions();

*if(arabicNo == 0)*{
0はローマ数字で表現できないので空文字を返す
*if(arabicNo >; 3999)*{
3９99より大きい数字もローマ数字で表現できないry
アラビア数字とローマ数字のペアを用意する
*Dictionary<;int, string>; romanArabicNum = new Dictionary<;int, string>;();
戻り値を宣言する
*string ret = string.Empty;
*foreach(KeyValuePair<;int,string>; pair in romanArabicNum)*{
アラビア数字とローマ数字のペアを大きい値から回す
arabicNoをペアの数字割って商を求める
商＝ローマ数字で出力する数となる
*int romanCount = arabicNo / pair.Key;
商の分の数をarabicNoから引く
*arabicNo -= romanCount * pair.Key;
*for (int i = 0; i <; romanCount; i++)*{
商の数だけ、ローマ数字を戻り値に追加する

*musics.Add(new msta("bgm_main",bgm_0));
音楽を格納する場所 増やす場合これを増やしていく
musics.Add(new msta("名前",bgm_1)); 名前はなんでも。soundman.bgm="名前"で呼び出せるようになります
musics.Add(new msta("se_buy",se_0)); seも同じく
*musics.Add(new msta("se_gold",se_1));

*{Console.WriteLine(ex.TargetSite);}
例外発生した部分表示
1つの処理で複数例外でる場合、throwで別のメソッドに再スローすればいい
逆に複数処理で1つの例外でる場合、whenでまとめればいい
*,,,

*this.Cond = cond;
引数を保存（テストコードで内容を検証できるように）
*{DeliveryScheduleDate = new DateTime(2018, 12, 7)};
都合のいいようにデータを作って返却する
初期化処理（フレームワークやデータベースの初期化など）
納期検索サービスのモックを作る
*var mock = new DeliveryScheduleSearchSvcForTest();
*{// 受注内容をセット};
商品受注サービスの入力データ
受注内容をセット
*};
商品受注サービスにモックを渡してインスタンス生成
*var targetSvc = new ReceiveOrderSvc(mock);
商品受注サービスを呼び出す
*var result = targetSvc.Exec(input);
結果を検証
*AssertEqual(ReceiveSatus.SUCCESS, result.Status);
以下、result の内容を検証する
*}
*{if (!object.Equals(expected, actual)) throw new Exception($"Assertion error! expected: {expected}, but actually: {actual}");}
検証用のメソッド（あくまで簡易な実装例。本当はもっと考慮すべきことがある）

*fs.Write(data, 0, data.Length);
We can also use ReadOnlySpan

*var diff = transform.position - TrackingCamera.transform.position;*// 鏡面の垂直ベクトル
カメラから鏡面へのベクトル
*var normal = transform.forward;*// 鏡面からの反射ベクトル
鏡面の垂直ベクトル
*var reflection = diff + 2 * (Vector3.Dot(-diff, normal)) * normal;*// 鏡面座標に反転させた反射ベクトルを加算する
鏡面からの反射ベクトル
*ReflectionCamera.transform.position = transform.position - reflection;*,,,
鏡面座標に反転させた反射ベクトルを加算する
*ReflectionCamera.transform.LookAt(Specular.position);*,,,
鏡面の方向に向ける
*var distance = Vector3.Distance(transform.position, ReflectionCamera.transform.position);*ReflectionCamera.nearClipPlane = distance* 0.9f;
カメラ設定の更新
焦点距離と表示したい鏡面サイズから画角(FOV)を計算する
*ReflectionCamera.fieldOfView = 2 * Mathf.Atan(Size / (2 * distance)) * Mathf.Rad2Deg;
*Specular.rotation = Quaternion.LookRotation(Specular.position - TrackingCamera.transform.position);*,,,
鏡面をカメラ方向に向ける
フレームのサイズを更新
*Frame.localScale = new Vector3(Size, Size, 1);
*var angle = Vector3.Angle(-transform.forward, ReflectionCamera.transform.forward);*var specularSize = Size + Mathf.Sin(angle * Mathf.Deg2Rad);
鏡面のサイズを調整
シーンビュー更新
*SceneView.RepaintAll();

*xlRange.Interior.ColorIndex = 15;
グレー

*new SigningCredentials(AuthConfig.ApiJwtSigningKey, SecurityAlgorithms.HmacSha256)
署名に使うCredential
トークンを作成（トークンは上記クレームをBase64エンコードしたものに署名をつけただけ）
*var encodedJwt = new JwtSecurityTokenHandler().WriteToken(jwt);

何か重い処理
*Thread.Sleep(1000);
重い処理をした続きの処理
*SomethingNextMethod(str);
何か続きの処理
*Debug.Log(str);
何か重い処理
*Thread.Sleep(1000);
そのままメソッドを続けて書いた場合
*SomethingNextMethod("Hoge");
メインスレッドに処理を戻したい場合
*_mainContext.Post(_ =>; SomethingNextMethod("Fuga"), null);
何か重い処理
*Thread.Sleep(1000);
重い処理を非同期で実行し、その結果を得る
*string result = await Task.Run(() =>; HeavyMethod("hoge"));
重い処理をした続きの処理
*SomethingNextMethod(result);
Taskはawaitせず直接受け取って
*var task = Task.Run(() =>; HeavyMethod("hoge"));
task.Resultで直接、値にアクセスする
var result = task.Result;  ここで結局スレッドが止まる
*SomethingNextMethod(result);
HogeHogeAsync()のタスク(Task&lt;string&gt;)をそのまま受け取り
*var task = HogeHogeAsync();
taskの完了を待つ
*task.Wait();
taskの処理は終了しているので、Resultを参照
*SomethingNextMethod(task.Result);
return await Task.Run(() =&gt; HeavyMethod("hoge")).ConfigureAwait(false);  これならデッドロックしない
*}
特に問題ないけど、あまり好きではない
*Task.Run(() =>; HeavyMethod("hoge"));
C# 6.0ならこう
*var _ = Task.Run(() =>; HeavyMethod("hoge"));
C# 7.0以降ならこう ... discards (値の破棄)
*_ = Task.Run(() =>; HeavyMethod("hoge"));
クライアントとの送信・受信処理
*}

*{//new した際にやりたい処理}
コンストラクタ(クラスと同じ名前にする)
new した際にやりたい処理
*}
*{//Dispose した際にやりたい処理}
デストラクタ(クラスと同じ名前にする)
Dispose した際にやりたい処理
*}
入れ物
*private int _hp = 10;
最大HP
*private int _maxHp = 10;
*{//変数を取得するときget{//取得するときに渡す値return _hp;}//変数を設定するときset{//入ってきた値（value）が０以下なら０に固定する。if (value <; 0){value = 0;}//入ってきた値（value）が最大値より大きければ最大値に固定する。if (value >; _maxHp){value = _maxHp;}_hp = value;}}
プロパティ（ここにアクセスして使う）
*{//取得するときに渡す値return _hp;}
変数を取得するとき
取得するときに渡す値
*return _hp;
*{//入ってきた値（value）が０以下なら０に固定する。if (value <; 0){value = 0;}//入ってきた値（value）が最大値より大きければ最大値に固定する。if (value >; _maxHp){value = _maxHp;}_hp = value;}
変数を設定するとき
*if (value <; 0)*{
入ってきた値（value）が０以下なら０に固定する。
*if (value >; _maxHp)*{
入ってきた値（value）が最大値より大きければ最大値に固定する。
変数＝条件式？true：false
*int i = flag ? 1 : -1 ;

*// public override BossEnemy Create () { return new BossEnemy(); }
↓こう書きたい。けれどコンパイルエラーになってしまう
*// public override BossEnemy Create () { return new BossEnemy(); }
BossEnemyFactoryを使う際はこう書けた方が便利なことがある
*public override Enemy Create() { return new BossEnemy(); }
実際は、BossEnemy型のインスタンスしか返さない
*public override Enemy Create() { return new BossEnemy(); }
↓こう書くしかない。

*this.View = new ContainerView();
差し替える
省略...
*}
*private IEnumerable<;NSLayoutConstraint>; CreateConstraint(NSView parent, NSView child) {// X座標を親の中心を軸に配置yield return NSLayoutConstraint.Create(child, NSLayoutAttribute.CenterX, NSLayoutRelation.Equal,parent, NSLayoutAttribute.CenterX, 1.0f, new nfloat(0));// Y座標を親の中心を軸に配置yield return NSLayoutConstraint.Create(child, NSLayoutAttribute.CenterY, NSLayoutRelation.Equal,parent, NSLayoutAttribute.CenterY, 1.0f, new nfloat(0));yield return NSLayoutConstraint.Create(child, NSLayoutAttribute.Width, NSLayoutRelation.Equal,null, NSLayoutAttribute.Width, 1.0f, new nfloat(80));yield return NSLayoutConstraint.Create(child, NSLayoutAttribute.Height, NSLayoutRelation.Equal,null, NSLayoutAttribute.Height, 1.0f, new nfloat(30));}
省略...
X座標を親の中心を軸に配置
*yield return NSLayoutConstraint.Create(
Y座標を親の中心を軸に配置
*yield return NSLayoutConstraint.Create(

*vlcControl1.Play(ms);
再生

*using System.Xml.Linq
重要
ディレクトリ指定してファイルを読み込み
*XDocument xml = XDocument.Load(@"C:\sample.xml");
テーブルを読み込む
*XElement table = xml.Element("リスト");
データの中身すべてを取得
*var rows = table.Elements("データ");
*foreach (XElement row in rows)*{
取り出し

*return (2 * Math.PI) + n;
360度を足す
*{return rad * 360 / (2 * Math.PI);}
ラジアンを度の変換
*{return deg * (2 * Math.PI) / 360;}
度をラジアンに変換
*{double w = (p2.X - p1.X);double h = (p2.Y - p1.Y);return Math.Sqrt(w * w + h * h);}
２点の線分の長さを求める
*{foreach (var observer in _observers){observer.OnCompleted();}}
終了を通知する
*{foreach (var observer in _observers){observer.OnNext(state);}}
状況変化を知らせるために購読者に通知する

ここが致命的。ViewがViewModelのことを知っていることになる。
*var dc = this.DataContext as MainWindowViewModel;
イベント1つぶんの記述。ここから
*System.Windows.Interactivity.EventTrigger trigger = new System.Windows.Interactivity.EventTrigger();
ここまで
*triggers.Add(trigger);
イベント1つぶんの記述。ここから
*System.Windows.Interactivity.EventTrigger trigger = new System.Windows.Interactivity.EventTrigger();
ここまで
*triggers.Add(trigger);

*[CustomPropertyDrawer(typeof(UnityEvent<;bool<;), true)]
この行を追加

クエリ
*string query = "SELECT * FROM <;テーブル名>; ";
コネクション開始
*con.Open();
*if (dr.Read())*{
値取得
エラーメッセージ
*Console.WriteLine(e.Message);
コネクション終了
*con.Close();
クエリ
*command.CommandText = @"INSERT INTO <;テーブル名>; VALUES('" + <;DATA_DATETIME>; + "'," + <;DATA_ID>; + ","+ <;DATA_VALUE>; + ")";
SQLの実行
*command.ExecuteNonQuery();
エラーメッセージ
*Console.WriteLine(e.Message);
コネクション終了
*con.Close();

*DownCommand.Subscribe(_ =<; Counter.Value--);
(() =&gt; Counter.Value--)ではコンパイルエラー

*case 37:
100
*if (p == 0)*{
かかった時間を表示
かかった時間を表示
*Debug.Log (Result + "：" + (TotalTime / n) + "ms");

*string json = Newtonsoft.Json.JsonConvert.SerializeObject(cardObject);
修正

シリアル化
*using var serializerStream = new MemoryStream();
デシリアル化
*var byteArray = Encoding.UTF8.GetBytes(jsonString);
すべての言語セットをエスケープせずにシリアル化させる
*Encoder = JavaScriptEncoder.Create(UnicodeRanges.All)
計測開始
*var summary = BenchmarkRunner.Run<;MeasurementJsonSerializer>;();

Singleton として登録しておくことで、プロセスが生きている間は状態が保持される
*services.AddSingleton<;OlkarStatusModel>;();
明示的にしておくことで、勝手にタイムアウトしていくのを防ぐ
*config.HandshakeTimeout = TimeSpan.FromSeconds(15);
SignalR のルート
*app.UseSignalR(routes =>; routes.MapHub<;OlkarHub>;("/olkar"));
Content で HTTP 200 を返しつつ応答メッセージを返せる
*return Content(message?.Challenge ?? "NULL");
基本情報
*var user = eventJson["user"];
*if (messageId != null)*{
前に発言したのと全く同じのがきていたら無視
フィールドに HttpClient http = new HttpClient(); がいます
var result = await this.http.PostAsync("https:slack.com/api/chat.postMessage", content);
*}

await部分
*}
await を展開した部分
*var task = Task.Delay(1000);
Awaiterを取り出す
*var awaiter = task.GetAwaiter();
*{// awiterの結果を受け取る// タスクの中で例外が発生していた場合などはGetResultを呼んだスレッドで改めて例外が投げられるawaiter.GetResult();// 本来の後続部分を実行HogeContinuation();};
後続部分
awiterの結果を受け取る
タスクの中で例外が発生していた場合などはGetResultを呼んだスレッドで改めて例外が投げられる
*awaiter.GetResult();
本来の後続部分を実行
*HogeContinuation();
*if (awaiter.IsCompleted)*{
タスクがすでに完了している場合はそのスレッド上で後続を実行
*{awaiter.OnCompleted(continuation);}
完了していない場合はAwaiterに後続部分の処理を任せる
後続処理がすべて終わったことを通知する
もしcompletionSource.Taskが誰かにawaitされている場合(=AwaiterのOnCompletedが呼ばれている場合)、
この関数の中でawaitの続きの処理が実行される
*completionSource.SetResult(true);
後続処理がすべて終わった後に完了するタスクを返す
*return completionSource.Task;
1フレーム待つ
*await UniTask.Yield(PlayerLoopTiming.Update, token);
UniTask.csより引用
*[DebuggerHidden]
UniTask.csより引用
*[DebuggerHidden]
UniTask.csより引用
*readonly IAwaiter awaiter;
*{return new UniTask(new YieldPromise(timing, cancellationToken));}
UniTask.Delay.csより引用
*{public YieldPromise(PlayerLoopTiming timing, CancellationToken cancellationToken): base(timing, cancellationToken, 2){}protected override void OnRunningStart(){}public override bool MoveNext(){Complete();if (cancellationToken.IsCancellationRequested){TrySetCanceled();}else{TrySetResult();}return false;}}
UniTask.Delay.csより引用
*{UnsafeOnCompleted(action);}
ReusablePromise.csより引用
*{get{if (Status == AwaiterStatus.Canceled || Status == AwaiterStatus.Faulted) return true;if (!isRunning){isRunning = true;ResetStatus(false);OnRunningStart();#if UNITY_EDITORTaskTracker.TrackActiveTask(this, capturedStackTraceForDebugging);#endifPlayerLoopHelper.AddAction(timing, this);}return false;}}
ReusablePromise.csより引用
*{Complete();if (cancellationToken.IsCancellationRequested){TrySetCanceled();}else{TrySetResult();}return false;}
UniTask.Delay.csより引用
*{if (status == AwaiterStatus.Pending){status = AwaiterStatus.Succeeded;TryInvokeContinuation();return true;}return false;}
ReusablePromise.csより引用

仮にAllowUnsafeBlockオプションを有効にしてみる
Buildalyzerの分析結果をanalyzerResultとする
分析結果から、RoslynWorkspaceを取得する
*var ws = analyzerResult.GetWorkspace();
roslynプロジェクトを取得
*var project = ws.CurrentSolution.Projects.First();
基本的にroslyn関連クラスのプロパティは直接書き換えできないので、With...で再セットする
*project = project.WithCompilationOptions(cscompopt.WithAllowUnsafe(true));
コンパイル結果取得
*var compilationUnit = project.GetCompilationAsync().Result;
諸々の処理
*,,,
"Clean"と"Build"がデフォルトで含まれている
*envopts.TargetsToBuild.Clear();
必ずコンパイルを走らせないと、アイテムリストを作ってくれないため
*envopts.TargetsToBuild.Add("Clean");
*foreach(var result in projectAnalyzer.Build(envopts))*{
分析の開始
ビルド結果の解析
*}
"Clean"と"Build"がデフォルトで含まれている
*envopts.TargetsToBuild.Clear();
Cleanタスクを省略
*envopts.TargetsToBuild.Add("ResolveAssemblyReferencesDesignTime");
*foreach(var result in projectAnalyzer.Build(envopts))*{
分析の開始
何も列挙されない場合がある
*}
必ず末尾をパス区切り文字(System.IO.Path.DirectorySeparatorChar)で終わらせること
ディレクトリは実行時に生成されるため、存在していなくても問題ない。
*var tmppath = [ランダムなディレクトリ];
ProjectAnalyzerとEnvironmentOptionsの準備...
*var analyzerManager = new AnalyzerManager();
中間出力ファイルディレクトリの指定
*envopts.GlobalProperties["IntermediateOutputPath"] = tmppath;
分析の開始...
*}

*sb.AppendLine("XXX");
&lt;--これ

*a(256);
この例では a(256) が呼ばれる。
*//{//    Console.Write("A({0}) が呼ばれました。\n", n);//}
static void A(int n)
*//    Console.Write("A({0}) が呼ばれました。\n", n);
{
Console.Write("A({0}) が呼ばれました。\n", n);
}
*}

*var results = _FizzBuzz(i + 1, n);
★

*private WaveIn sourceStream = null;
録音なのでWaveInを使用
デフォルトデバイスを選択
*DeviceNumber = 0,
Waveのフォーマット(サンプルレート等)を指定
*WaveFormat = new WaveFormat(44100, WaveIn.GetCapabilities(0).Channels)
指定したバッファにwaveデータを入力するやつ(WaveInProvider)に変換
*WaveInProvider waveIn = new WaveInProvider(sourceStream);
(たぶん)リアルタイムで入力音源を直で出力へ送る。
*waveOut = new DirectSoundOut();
録音の開始
*sourceStream.StartRecording();
音声ファイルの読み込み
*play.Init(new WaveInProvider(sourceStream));
音声ファイルの再生
*play.Play();
音声ファイルの停止
*play.Stop();

*.Select(i =<; i * i)
値を2乗する

*;
select a;
*{8,7,6}
結果
結果
*876
*{16, 14, 12}
結果
結果
*True
*{1, 2, 3}
結果
*{1, 4, 5}
結果
*{4, 5, 6}
結果
*{}
結果
*{4, 5}
結果
*{4, 5}
結果

*{public int age = 0;}
C#7.0以前
なんかデータ
*}
*if (obj is Animal)*{
obj は Animalクラスを継承しているか
ここ注目!!!!!!!!!!!!!!!!!!!!
*Animal animal = (Animal)obj;
なんかの処理
*Console.WriteLine(animal.age);
*{public void Piyo(Object obj){// ここ注目!!!!!!!!!!!!!!!!!!!!// obj が Animal クラスにキャストできた場合はキャスト結果を animal という変数に入れる// obj が null の場合はfalseとなって中の処理はもちろんキャストも通らないif (obj is Animal animal){// なんかの処理Console.WriteLine(animal.age);}else{Console.WriteLine(false);}}}
C#7.0以降
ここ注目!!!!!!!!!!!!!!!!!!!!
obj が Animal クラスにキャストできた場合はキャスト結果を animal という変数に入れる
obj が null の場合はfalseとなって中の処理はもちろんキャストも通らない
*if (obj is Animal animal)
なんかの処理
*Console.WriteLine(animal.age);
*{public void Mohu(Object obj){try{// ここ注目!!!!!!!!!!!!!!!!!!!!Animal animal = (Animal)obj;Console.WriteLine(animal.age);}// ここ注目!!!!!!!!!!!!!!!!!!!!// キャストできなかった場合の例外はInvalidCastExceptioncatch (InvalidCastException){Console.WriteLine(false);}}}
普通のキャストの場合
ここ注目!!!!!!!!!!!!!!!!!!!!
*Animal animal = (Animal)obj;
ここ注目!!!!!!!!!!!!!!!!!!!!
キャストできなかった場合の例外はInvalidCastException
*catch (InvalidCastException)
*{public void Humo(Object obj){// ここ注目!!!!!!!!!!!!!!!!!!!!Animal animal = obj as Animal;if(animal == null){Console.WriteLine("動物継承してないね");}else{Console.WriteLine(animal.age);}}}
as演算子を用いたキャストの場合
ここ注目!!!!!!!!!!!!!!!!!!!!
*Animal animal = obj as Animal;

*public float radius = 0.5f;
円の大きさ

dynamicで型が取れるのはC#は便利ですねー
*dynamic data = JsonConvert.DeserializeObject(requestBody);
BlobのURLを解析は少し厄介です...
*var url = new Uri(data0.data.url.ToString());
ダウンロードするファイル名を指定
*CloudBlockBlob blockBlob_download = blobcontainer.GetBlockBlobReference(blobname);
*var downloadFile = $"{tempFilePath}" ;
ダウンロード処理
*var downloadFile = $"{tempFilePath}" ;
ダウンロード後のパスとファイル名を指定。
*{client.Connect();// await a file uploadusing (var localStream = File.OpenRead(filePath)){client.ChangeDirectory("<;アップロードパス>;");await client.UploadAsync(localStream, $"{fileName}");// disconnect like you normally wouldclient.Disconnect();}}
clientを作成して
*{client.ChangeDirectory("<;アップロードパス>;");await client.UploadAsync(localStream, $"{fileName}");// disconnect like you normally wouldclient.Disconnect();}
await a file upload
ダウンロードするファイル名を指定
*CloudBlockBlob blockBlob_download = blobcontainer.GetBlockBlobReference(blobname);
*var downloadFile = $"{tempFilePath}" ;
ダウンロード処理
*var downloadFile = $"{tempFilePath}" ;
ダウンロード後のパスとファイル名を指定。
*{client.Connect();// await a file uploadusing (var localStream = File.OpenRead(filePath)){client.ChangeDirectory("/home/ubuntu/sftp");await client.UploadAsync(localStream, $"{fileName}");// disconnect like you normally wouldclient.Disconnect();}}
setup client
*{client.ChangeDirectory("/home/ubuntu/sftp");await client.UploadAsync(localStream, $"{fileName}");// disconnect like you normally wouldclient.Disconnect();}
await a file upload

*System.Console.WriteLine(obj + str);
▲

*else dc.OnKeyHit(cki.KeyChar);
Event発生
自動実装ｲﾍﾞﾝﾄ
*public event Action EventAction;
?.Invokeで全部呼出
*public void OnEvents() =>; this.EventAction?.Invoke();
ｲﾝｽﾀﾝｽ化
*var observer = new Observer();
Eventに登録する(ｲﾍﾞ名+=ﾃﾞﾘ名)
*observer.EventAction += sub1.SubjectAction;
ｲﾍﾞ呼出
*observer.OnEvents();
出力内容
&gt; "Action!"
&gt; "Action!"
*}
出力内容
&gt; "Action!"
&gt; "Action!"
*}

スレッドを作成
*var thread = new Thread(HeavyFunc);
非同期処理開始
*thread.Start();
ここで非同期処理が終わるまで待機
*thread.Join();
非同期処理が終わってから実行
*Console.WriteLine("スリー！");
*static void HeavyFunc(){for (int i = 0; i <; 100000; i++){for (int p = 0; p <; 10000; p++){}}Console.WriteLine("ツー！");}
暫定的な重い処理の見本
実行結果
ワン！
ツー！
スリー
*,,,
非同期処理開始
*Task task = Task.Run(() =>; HeavyFunc());
ここで非同期処理が終わるまで待機
*task.Wait();
非同期処理が終わってから実行
*Console.WriteLine("スリー！");
*static void HeavyFunc(){for (int i = 0; i <; 100000; i++){for (int p = 0; p <; 10000; p++){}}Console.WriteLine("ツー！");}
暫定的な重い処理の見本
非同期処理開始
*Task<;string>; task = StartAsync();
ここで非同期処理が終わるまで待機
*task.Wait();
StartAsyncから帰ってきた返り値を使える
*Console.WriteLine(task.Result);
*static async Task<;string>; StartAsync(){await Task.Run(() =>; HeavyFunc());Console.WriteLine("スリー");return "フォー";}
メソッドを定義
*static void HeavyFunc(){for (int i = 0; i <; 100000; i++){for (int p = 0; p <; 10000; p++){}}Console.WriteLine("ツー！");}
暫定的な重い処理の見本

*{// 処理}
継承先に引数がないパターン
処理
*}
処理
*}
*{// 処理}
継承先の引数が多いパターン
処理
*}
処理
*}

*this.Items = items?.AsReadOnly();
外部公開用には変更不可にラップ

空の Audio Sourceを取得
*audioSource = GetComponent<;AudioSource>;();
Audio Source の Audio Clip をマイク入力に設定
引数は、デバイス名（null ならデフォルト）、ループ、何秒取るか、サンプリング周波数
*audioSource.clip = Microphone.Start(null, true, 1, 44100);
*while (Microphone.GetPosition(null) <;= 0) { }*// 再生開始（録った先から再生、スピーカーから出力するとハウリングします）
マイクが Ready になるまで待機（一瞬）
再生開始（録った先から再生、スピーカーから出力するとハウリングします）
*audioSource.Play();
CubismParameterの更新はLateUpdate()内で行う必要がある点に注意
*MouthOpenParameter.Value = Mathf.Clamp01(currentVolume);
頭の角度
*SetParameter(HeadAngleX, currentRotateion.x);
眼球の向き
*SetParameter(EyeBallX, currentRotateion.x * EyeBallXRate * (ReversedGazing ? -1 : 1));

*str = "";
文字列とストップウォッチをリセット
かかった時間を表示
*Debug.Log ("+= s1：" + (TotalTime / 10) + "ms");
かかった時間を表示
*Debug.Log ("Append (s1)：" + (TotalTime / 10) + "ms");
かかった時間を表示
*Debug.Log ("+= s2 + s3：" + (TotalTime / 10) + "ms");
かかった時間を表示
*Debug.Log ("Append (s2).Append (s3)：" + (TotalTime / 10) + "ms");
かかった時間を表示
*Debug.Log ("Append (s2 + s3)：" + (TotalTime / 10) + "ms");

*try {requestBody = await req.GetBodyAsync<;NurieImageEntity>;();}
バリデーション
*try {fgBitmap = entity.image_fg_datauri.ReadAsBitmap();}
ビットマップへの変換
ペン入力ツールバーのクロップ有無
*var cropFgToolbar = false;
画像の合成
*var nurieBitmap = MergeTwoImages(fgBitmap, bgBitmap, cropFgToolbar);
*if (cropToolbar) {fgBitmap = fg.Clone(new Rectangle(0, 0, fg.Width, fg.Height - 60), fg.PixelFormat);}
ツールバーの60pxを切り抜き
*using (var g = Graphics.FromImage(bitmapBase)) {g.DrawImage(fgBitmap, g.VisibleClipBounds);}
ビットマップに前景画像を描画

見切れている文字数が0になるまで、テキストの先頭行から消してゆく
*t.text = t.text.Remove(0, line.Length + 1);

ココと
*var spotName = result.entities.Where(e =>; e.type == "spot").First();
ココが同じ
*var spotName = result.entities.Where(e =>; e.type == "spot").First();

*for(var i = 0; i <; 3; ++i){*Console.WriteLine(i);
Enumerable.Range(0,3).ToList().ForEach(i =&gt;
*public static void ForEach<;T>;(this IEnumerable<;T>; source, Action<;T>; action){source.All(x =>; {action(x); return true;});}
albireoさんの提案のコード追記

*public class Author {public int AuthorId { get; set; }public string Name { get; set; }public DateTime Birthday { get; set; }// 著者は複数の著書に紐づきますpublic IList<;Book>; Books { get; set; }}
著者エンティティ
*public IList<;Book>; Books { get; set; }
著者は複数の著書に紐づきます
*public class Book {public int BookId { get; set; }public string Title { get; set; }public int PublushYear { get; set; }// 書籍は一人の筆者に紐づきます（内容から外れるので共著はないものとする）public int AuthorId { get; set; }public Author Author { get; set; }}
書籍エンティティ
*public int AuthorId { get; set; }
書籍は一人の筆者に紐づきます（内容から外れるので共著はないものとする）
↓ JSONシリアル化で循環参照を無視する設定
*options.SerializerSettings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
DB は SQL Server local DB を使うことにします
*options.UseSqlServer(Configuration.GetConnectionString(nameof(RelationalEntitiesSeeding)));

*for (int i = 0; i <; TestArray.Length; i++)*{
forの処理
*foreach (int i in TestArray)*{
foreachの処理
forの処理
*int num = 0;
foreachの処理
*int[] array2 = TestArray;
*for (int i = 0; i <; TestList.Count; i++)*{
forの処理
*foreach (int i in TestList)*{
foreachの処理
forの処理
*int num = 0;
foreachの処理
*List<;int>;.Enumerator enumerator = list.GetEnumerator();

*using UnityEngine.UI;
UI関連コンポーネントを使うのに必要
privateな関数を渡す場合
*_button.onClick.AddListener(OnClickAction);
ラムダ式で渡す場合
*_button.onClick.AddListener(() =>; Debug.Log("ラムダ式"));

*{//ＬＩＮＱで最低点数の人のデータのみを取得tests.OrderBy(x =>; x.Points).First()};
List&lt;T&gt; リスト名 = new List&lt;T&gt; { LINQ文};
ＬＩＮＱで最低点数の人のデータのみを取得
*tests
表示
*dataGridView1.DataSource = hquerymin;

SoftwareKeyboardTestAppの終了
*Process process = Process.GetProcessById(_app.ProcessId);
txtInputTextをクリア
*_drv.txtInputText.EmulateChangeText("");
ひらがなを選択
*_drv.cmbMode.EmulateChangeSelectedIndex(0);
*while(_drv.grdHiragana.Visibility != System.Windows.Visibility.Visible)*{
ひらがなが表示されるのを待つ
ひらがなが表示、カタカナが非表示
*Assert.AreEqual<;System.Windows.Visibility>;(_drv.grdHiragana.Visibility, System.Windows.Visibility.Visible);
「あ」入力
*var btnA = _drv.GetButton("あ");
「い」入力
*var btnI = _drv.GetButton("い");

*private Vector3 prevTargetPos;
前フレームのターゲットの位置
*if (EnableAtten)*{
減衰
手ブレ
*bool move = Mathf.Abs(delta.x) >; 0.0f;
*if (EnableFieldOfViewAtten) nowfov = Mathf.Lerp(nowfov, move ? MoveFieldOfView : FieldOfView, Time.deltaTime);*else nowfov = FieldOfView;
FoV
*{cam = GetComponent<;Camera>;();nowfov = FieldOfView;nowPos = TargetObject.transform.position;}
Use this for initialization
*{RotAngle -= Input.GetAxis("Mouse X") * 5.0f;HeightAngle += Input.GetAxis("Mouse Y") * 5.0f;HeightAngle = Mathf.Clamp(HeightAngle, 0.0f, 80.0f);var delta = TargetObject.transform.position - deltaTarget;deltaTarget = TargetObject.transform.position;// 減衰if (EnableAtten){var deltaPos = TargetObject.transform.position - prevTargetPos;prevTargetPos = TargetObject.transform.position;deltaPos *= ForwardDistance;addForward += deltaPos * Time.deltaTime * 20.0f;addForward = Vector3.Lerp(addForward, Vector3.zero, Time.deltaTime * AttenRate);nowPos = Vector3.Lerp(nowPos, TargetObject.transform.position + Vector3.up * Height + addForward, Mathf.Clamp(Time.deltaTime * AttenRate, 0.0f, 1.0f));}else nowPos = TargetObject.transform.position + Vector3.up * Height;// 手ブレbool move = Mathf.Abs(delta.x) >; 0.0f;var noise = new Vector3();if (EnableNoise){var ns = (move ? MoveNoiseSpeed : NoiseSpeed);var nc = (move ? MoveNoiseCoeff : NoiseCoeff);var t = Time.time * ns;var nx = Mathf.PerlinNoise(t, t) * nc;var ny = Mathf.PerlinNoise(t + 10.0f, t + 10.0f) * nc;var nz = Mathf.PerlinNoise(t + 20.0f, t + 20.0f) * nc * 0.5f;noise = new Vector3(nx, ny, nz);}// FoVif (EnableFieldOfViewAtten) nowfov = Mathf.Lerp(nowfov, move ? MoveFieldOfView : FieldOfView, Time.deltaTime);else nowfov = FieldOfView;cam.fieldOfView = nowfov;// カメラ位置if (EnableAtten) nowRotAngle = Mathf.Lerp(nowRotAngle, RotAngle, Time.deltaTime * RotAngleAttenRate);else nowRotAngle = RotAngle;if (EnableAtten) nowHeightAngle = Mathf.Lerp(nowHeightAngle, HeightAngle, Time.deltaTime * RotAngleAttenRate);else nowHeightAngle = HeightAngle;var deg = Mathf.PI / 180.0f;var cx = Mathf.Sin(nowRotAngle * deg) * Mathf.Cos(nowHeightAngle * deg) * Distance;var cz = -Mathf.Cos(nowRotAngle * deg) * Mathf.Cos(nowHeightAngle * deg) * Distance;var cy = Mathf.Sin(nowHeightAngle * deg) * Distance;transform.position = nowPos + new Vector3(cx, cy, cz);// カメラ向きvar rot = Quaternion.LookRotation((nowPos - transform.position).normalized) * Quaternion.Euler(noise);if (EnableAtten) transform.rotation = Quaternion.Slerp(transform.rotation, rot, Time.deltaTime * AngleAttenRate);else transform.rotation = rot;}
Update is called once per frame
*if (EnableAtten)*{
減衰
手ブレ
*bool move = Mathf.Abs(delta.x) >; 0.0f;
*if (EnableFieldOfViewAtten) nowfov = Mathf.Lerp(nowfov, move ? MoveFieldOfView : FieldOfView, Time.deltaTime);*else nowfov = FieldOfView;
FoV
*if (EnableAtten) nowRotAngle = Mathf.Lerp(nowRotAngle, RotAngle, Time.deltaTime * RotAngleAttenRate);*else nowRotAngle = RotAngle;
カメラ位置
*var rot = Quaternion.LookRotation((nowPos - transform.position).normalized) * Quaternion.Euler(noise);*if (EnableAtten) transform.rotation = Quaternion.Slerp(transform.rotation, rot, Time.deltaTime * AngleAttenRate);
カメラ向き

*if (System.Environment.OSVersion.Platform.ToString() != "Win32NT")*{
こんな分岐でいいのだろうか(不安) そもそも ポートってどう選択すべき…？
Linux等(Raspbian Stretchで動作確認)
*devicePort = "/dev/ttyUSB0";
*{//シリアル通信を開くskdevice.Open(devicePort, 115200, 8, Parity.None, StopBits.One);//EVENTのイベントハンドラを登録skdevice.OnEVENTReceived += (sender, e) =>;{logger.LogDebug(e.ToString());};//ERXUDP(UDP受信)のイベントハンドラを登録skdevice.OnERXUDPReceived += (sender, e) =>;{logger.LogDebug(e.ToString());};//各種コマンドはSKDeviceクラスにメソッドとして実装var eInfo = await skDevice.SKInfoAsync();logger.LogInformation(eInfo.ToString());var eVer = await skDevice.SKVerAsync();logger.LogInformation(eVer.ToString());}
SKDeviceクラスをインスタンス化します
シリアル通信を開く
*skdevice.Open(devicePort, 115200, 8, Parity.None, StopBits.One);
*{logger.LogDebug(e.ToString());};
EVENTのイベントハンドラを登録
*{logger.LogDebug(e.ToString());};
ERXUDP(UDP受信)のイベントハンドラを登録
各種コマンドはSKDeviceクラスにメソッドとして実装
*var eInfo = await skDevice.SKInfoAsync();

*RtnType = null;
戻り値の型は不明とする
*Parameters = paraNames.Select((value, index) =>; new { Value = value, Index = index })
関数定義部がある場合
*{ParameterExpression pExpr = Array.Find(Parameters, para =>; para.Name == (string)x)?.DeclExpression;if (pExpr != null)return new Token(pExpr);elsereturn new Token(TryConvElement(x));});
パラメータ記述部分をParameterExpressionに変換
*{Regex reg = new Regex("^Func\\<;(?<;types>;.*?)\\>;\\((?<;paras>;.*)\\)$");Match m = reg.Match(defStr);typeNames = m.Groups["types"].Value.Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);paraNames = m.Groups["paras"].Value.Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);//型の数=パラメータの数+1if (typeNames.Length == paraNames.Length + 1){//型名とパラメータ名の合理性チェックif (typeNames.All(name =>; GetFieldType(name) != null)){Regex regVar = new Regex("^[a-zA-Z][a-zA-Z0-9_]*$");if (paraNames.All(value =>; regVar.IsMatch(value)))return;}}throw new FormatException();}
関数定義部からパラメータ名と型を抽出する
*if (typeNames.Length == paraNames.Length + 1)*{
型の数=パラメータの数+1
*if (typeNames.All(name =>; GetFieldType(name) != null))*{
型名とパラメータ名の合理性チェック
*{ParameterExpression[] paramExpressions = Parameters.Select(p =>; p.DeclExpression).ToArray();List<;Type>; declTypes = Parameters.Select(p =>; p.DeclType).ToList();declTypes.Add(RtnType);Type lambdaDef = LAMBDA_DEFS[paramExpressions.Length];Type genericType = lambdaDef.MakeGenericType(declTypes.ToArray());ParameterExpression valueExpression = Expression.Variable(genericType);return Expression.Lambda(Expression.Block(new[] { valueExpression },rootExp),paramExpressions).Compile();}
演算関数を作成する
ForamulaConverter（関数定義なし）
*dlg3 = FormulaConverter.GetDelegate("(int)para1/2 + 5 - 10 * 2.3333d + (int)0.5f");
ForamulaConverter（関数定義あり）
*Delegate dlg15 = FormulaConverter.GetDelegate("Func<;int,int,int>;(x,y)=(2+x*2)/(y-2.5)*(x+5)");
ラムダ式（ForamulaConverter「関数定義あり」の同等コード）
*Func<;int, int, int>; func15 = (x, y) =>; (int)((2 + x * 2) / (y - 2.5) * (x + 5));
FormulaConverter定義
*var dele = FormulaConverter.GetDelegate("Func<;int,int,double>;(x,y)=(int)x/2 + 5 - 10 * 2.3333d + (int)0.5f+Math.Pow(Math.Abs(y),2)");
ラムダ式定義
*Func<;int, int, double>; func = (x, y) =>; (double)((int)x / 2 + 5 - 10 * 2.3333d + (int)0.5f + Math.Pow(Math.Abs(y), 2));
*{return (double)((int)x / 2 + 5 - 10 * 2.3333d + (int)0.5f + Math.Pow(Math.Abs(y), 2));}
専用関数
FormulaConverter 100万回実行
*var rtn = (double)dele.DynamicInvoke(7, -5);
ラムダ式 100万回実行
*var rtn = func(7, -5);
専用関数 100万回実行
*var rtn = TestFunc(7, -5);

*foreach(var itm in workTasks.Take(5)*.Select(t =>; new ToastSelectionBoxItem(t.TaskId.Value.ToString(), $"[{t.ProcessName}] {t.Title}")))
表示できる項目数に上限があるよう
*ToastNotificationManagerCompat.OnActivated += toastArgs =>;*{
Listen to notification activation
*{if(args.TryGetValue(_ActionTypeCode, out string value)){switch(value){case _ActionTypeStartTask:userInput.TryGetValue(_SelectionTaskKey, out object key);StartSelectedWorkTask(key?.ToString());break;}}else{((MainWindow)Application.Current.MainWindow).ShowWindow();}});
Need to dispatch to UI thread if performing UI operations

*}
&lt;- ここで FooDbContext.Dispose() される

*{[MaxLength(4)][Required]public string UserID { get; set; }public string UserName { get; set; }[Range(0, 999)]public int Age { get; set; }public DateTime BirthDay { get; set; }public bool IsActive { get; set; }}
Using System.ModelComponentModel.DataAnotaions が必要。

*{if (n >; 0){Dlu(n - 1);GoLeft();Ldr(n - 1);GoDown();Ldr(n - 1);GoRight();Urd(n - 1);}}
┗
*{if (n >; 0){Rul(n - 1);GoUp();Urd(n - 1);GoRight();Urd(n - 1);GoDown();Ldr(n - 1);}}
┏┓
*{if (n >; 0){Urd(n - 1);GoRight();Rul(n - 1);GoUp();Rul(n - 1);GoLeft();Dlu(n - 1);}}
┛
*{if (n >; 0){Ldr(n - 1);GoDown();Dlu(n - 1);GoLeft();Dlu(n - 1);GoUp();Rul(n - 1);}}
┗┛
*{foreach (var observer in _observers){observer.OnNext(state);}}
状況変化を知らせるために購読者に通知する

*toGoPoint = goalPoint.transform.position;
目的地に設置したオブジェクトの座標

DLL 参照
*#r "Microsoft.Extensions.Configuration"
名前空間の参照
*using Microsoft.Extensions.Configuration;
環境変数からの取得
*var config = new ConfigurationBuilder()
----- 省略 -----
*}

*EventName();
ｲﾍﾞﾝﾄ発生
me.EventName += () =&gt; mc2.Show2; λでスリム
me.OnEventName();ｲﾍﾞﾝﾄ発生
*}
何かデリゲートの学習してるみたいだけど、元来のイベント処理手順がわかった。
*using System;
*{public event Handler KeyHit;public void OnKeyHit(char ch){if (KeyHit != null)KeyHit(ch);}}
2.field
*{int sum = 0;public void KeyShow(char ch){if (Char.IsDigit(ch)){int a = (int)char.GetNumericValue(ch);sum += a;Console.Write($"+{a}\n");Console.Write($"={sum}\n");}else if (ch == 'c'){sum = 0;Console.Write("合計がクリアされました\n");}else return;}}
3.handler
*{public static void Main(){ConsoleKeyInfo cki;EventClass ec = new EventClass();Show s = new Show();ec.KeyHit += new Handler(s.KeyShow);while (true){if (Console.KeyAvailable){cki = Console.ReadKey(true);if (cki.KeyChar == 'x')break;else ec.OnKeyHit(cki.KeyChar);}}}}
4.Main
何かデリゲートの学習してるみたいだけど、元来のイベント処理手順がわかった。
*,,,
*{return n % 2 != 0;};
ラムダ式でデリゲートを定義して使う従来の書き方
出力：odds=1,3,5,7,9
ローカル関数も、通常のメソッドと同様にデリゲートとして扱える
*bool IsEven(int n)
出力：evens=2,4,6,8,10
*}

*RaycastHit hit;
レイが衝突したオブジェクト
もしrayとhitが衝突した場合．．．の処理内容
*}
もしhitのタグが"Block"と一致していた場合．．．の処理内容
*}
もしhitのレイヤーが指定した"レイヤーの名前"と一致していた場合．．．の処理内容
*}

*{private IyyyService yyyService { get; }public int Value { get; }// staticファクトリーメソッド.必要なら値チェックしてから生成.public static xxxValueObject Create(IyyyService _yyyService, int _value)=>; new xxxValueObject(_yyyService, _value);private xxxValueObject(IyyyService _yyyService, int _value){yyyService = _yyyService;Value = _value;}public int ここでやらなければならないこと =>; yyyService.なんかやる(Value);// 以下、等価性担保...}
値オブジェクト.
staticファクトリーメソッド.必要なら値チェックしてから生成.
*public static xxxValueObject Create(IyyyService _yyyService, int _value)
以下、等価性担保
*...
*{private IyyyService yyyService { get; }// コンストラクタインジェクション.public zzzModel(IyyyService _yyyService){yyyService = _yyyService;}// 使用する場所.public void hogehoge(){var vo = xxxValueObject.Create(yyyService, 10);// vo.ここでやらなければならないこと を呼んでなんかやる.// vo.ここでやらなければならないこと を使わないときでも注入必要....}}
使用するクラス.
*{yyyService = _yyyService;}
コンストラクタインジェクション.
*{var vo = xxxValueObject.Create(yyyService, 10);// vo.ここでやらなければならないこと を呼んでなんかやる.// vo.ここでやらなければならないこと を使わないときでも注入必要....}
使用する場所.
vo.ここでやらなければならないこと を呼んでなんかやる.
vo.ここでやらなければならないこと を使わないときでも注入必要.
*...

エイリアスから列挙値へ変換
*Debug.WriteLine(EnumHelper.FromAlias<;SampleEnum>;("N"));
存在しないエイリアスから列挙値への変換
*Debug.WriteLine(EnumHelper.FromAlias<;SampleEnum>;("X"));
列挙値をエイリアスに変換
*Debug.WriteLine(EnumHelper.GetAlias(SampleEnum.None));
列挙値をエイリアスに変換（拡張メソッド版）
*Debug.WriteLine(SampleEnum.Left.GetAlias());
*{// 定義名を大文字に変換したものをエイリアスとするreturn new EnumAliasInfo(enumValue.ToString().ToUpper());}
任意の変換メソッドを登録した変換
定義名を大文字に変換したものをエイリアスとする
*return new EnumAliasInfo(enumValue.ToString().ToUpper());
表示名を取得
*Debug.WriteLine(EnumHelper.GetDisplayName(SampleEnum.None));
表示名を取得（拡張メソッド版）
*Debug.WriteLine(SampleEnum.Left.GetDisplayName());
表示順で列挙値を取得
*IList<;SampleEnum>; values = EnumHelper.GetOrderedValues<;SampleEnum>;(false);
表示順で列挙値を取得（非表示を除く）
*IList<;SampleEnum>; values = EnumHelper.GetOrderedValues<;SampleEnum>;(true);
*{// 定義名を大文字に変換したものを表示名とする// 数値に変換したものを表示順とするreturn new EnumDisplayInfo(enumValue.ToString().ToUpper(), (int)enumValue);}
任意の変換メソッドを登録した変換
定義名を大文字に変換したものを表示名とする
数値に変換したものを表示順とする
*return new EnumDisplayInfo(enumValue.ToString().ToUpper(), (int)enumValue);
数値文字列へ変換
*Debug.WriteLine(EnumHelper.ToNumericString(SampleEnum.Left));
数値文字列へ変換（拡張メソッド版）
*Debug.WriteLine(SampleEnum.Left.ToNumericString());
数値文字列から変換
*Debug.WriteLine(EnumHelper.FromNumericString<;SampleEnum>;("1"))

*var writer = new StringWriter();
出力先のWriterを定義
セーブするデータを作成
*SaveData save = new SaveData();
データをXML化
*string xml=XMLClass.SaveToString<;SaveData>;(save);
データをxmlから復元
*SaveData sdata =XMLClass.LoadFromString<;T>;(string s);
データの確認
*Console.WriteLine(sdata.data);

認証トークン発行
*[AllowAnonymous]
*[HttpGet("{id}")]
認証が必要
*[HttpGet("{id}")]
ID のユーザー情報を返す
*public class AppUser {public int ID { get; set; }public string UserName { get; set; }public string Password { get; set; }public string Token { get; set; }}
ユーザーモデル
*public class MyDbContext : DbContext {public MyDbContext(DbContextOptions<;MyDbContext>; options): base(options) { }public DbSet<;AppUser>; Users { get; set; }protected override void OnModelCreating(ModelBuilder modelBuilder) =>;modelBuilder.Entity<;AppUser>;().HasData(new AppUser { ID = 1, UserName = "user1", Password = "password1" },new AppUser { ID = 2, UserName = "user2", Password = "password2" });}
データベースコンテキスト
*if (env.IsDevelopment() &amp;&amp; !this.myDbContext.Users.Any()) {*this.myDbContext.Database.EnsureCreated();
インメモリDB を使うので初回のインスタンス生成時にシードデータを作っておく
*AppUser IAuthService.Authenticate(string userName, string password) {var foundUser = myDbContext.Users.SingleOrDefault(x =>; x.UserName == userName &amp;&amp; x.Password == password);if (foundUser is null) {return null;}foundUser.Token = GetSerializedToken(foundUser.ID, expiredDay: DateTime.UtcNow.AddDays(7));foundUser.Password = null;return foundUser;}
認証処理
*string GetSerializedToken(int id, DateTime expiredDay) {var tokenHandler = new JwtSecurityTokenHandler();// 秘密鍵var key = Encoding.ASCII.GetBytes(appSettings.Secret);var tokenDescriptor = new SecurityTokenDescriptor {Subject = new ClaimsIdentity(new Claim[] {new Claim(ClaimTypes.Name, id.ToString())}),// 有効期限Expires = expiredDay,// 署名SigningCredentials = new SigningCredentials(key: new SymmetricSecurityKey(key),algorithm: SecurityAlgorithms.HmacSha256Signature)};var token = tokenHandler.CreateToken(tokenDescriptor);var serializedToken = tokenHandler.WriteToken(token);return serializedToken;}
token 発行
*var tokenDescriptor = new SecurityTokenDescriptor {Subject = new ClaimsIdentity(new Claim[] {new Claim(ClaimTypes.Name, id.ToString())}),// 有効期限Expires = expiredDay,// 署名SigningCredentials = new SigningCredentials(key: new SymmetricSecurityKey(key),algorithm: SecurityAlgorithms.HmacSha256Signature)};
秘密鍵
有効期限
*Expires = expiredDay,
署名
*SigningCredentials = new SigningCredentials(
*services.AddDbContext<;MyDbContext>;(options =>; {options.UseInMemoryDatabase(databaseName: "MyDb");});
インメモリ DB を使う設定
appsettings.json の AppSettings に 秘密鍵があるので設定を読み取ります。
※本来は環境変数などから読み取ります。
*var appSettingsSection = Configuration.GetSection("AppSettings");
*app.UseCors(corsPolicyBuilder =>; {corsPolicyBuilder.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader().AllowCredentials();});
クロスオリジンを想定しているので

HACK: 本当はこのあたりはModelから取得されるはずのデータ
*_view.Title = "MvpWinFormsTest!";

*{// データ格納用の配列を確保するresult = new byte[fs.Length];// バイナリデータを非同期的に読み込むawait fs.ReadAsync(result, 0, (int)fs.Length);}
ファイルを読み取りモードで開く
データ格納用の配列を確保する
*result = new byte[fs.Length];
バイナリデータを非同期的に読み込む
*await fs.ReadAsync(result, 0, (int)fs.Length);

nは1以上かつsrcの長さよりも短い必要がある。
*int len = src.Count;

*{var targetDate = (DateTime)values[0];// ----------------省略----------------,,,
*[HtmlExporter]
←これ
(略)
*}

*skillResponse.Response.ShouldEndSession = true;
セッション終了を指定

このインスタンス化でテーブルが作られます。
userIdはセッション情報から取得します。
これがプライマリキー（id）として使われます。
*var attrManager=new AttributesManager(userId,_tableName);
ユーザーの星座情報をsignをキーにしてセット。
任意のキーで数値、文字列、一次元のリストや配列を格納することができます。
ここではまだ変数に追加しているだけ。
*attrManager.SetPersistentAttributes("sign", "ふたご座");
セットした情報をDynamoDBに保存。
ここでDynamoDBに追加！
*attrManager.SavePersistentAttributes();
値の取得
*var attr=attrManager.GetPersistentAttributes();

SQL処理で用いる変数を予め宣言
*NpgsqlCommand cmd = null;
接続文字列
*string conn_str1 = "Server=192.168.56.111;Port=5432;User ID=postgres;Database=tes_db1;Password=password;Enlist=true";
*{//接続その1(tes_db1へ接続)using (NpgsqlConnection conn1 = new NpgsqlConnection(conn_str1)){//PostgreSQLへ接続後、INSERT処理を実施し、SELECT結果を取得conn1.Open();//test対象のテーブルをリセット(全データDELETE)cmd_str = "DELETE FROM test1";cmd = new NpgsqlCommand(cmd_str, conn1);cmd.ExecuteNonQuery();//INSERT処理cmd_str = "INSERT INTO test1 VALUES(1, 'AAA'), (2, 'BBB')";cmd = new NpgsqlCommand(cmd_str, conn1);cmd.ExecuteNonQuery();//SELECT処理dt = new DataTable();cmd_str = "SELECT * FROM test1";cmd = new NpgsqlCommand(cmd_str, conn1);da = new NpgsqlDataAdapter(cmd);da.Fill(dt);//SELECT結果表示Console.WriteLine("tes_db1:");for (int i = 0; i <; dt.Rows.Count; i++){Console.WriteLine("(col1, col2) = (" + dt.Rows[i][0] + ", " + dt.Rows[i][1] + ")");}}//接続その2(tes_db2へ接続)using (NpgsqlConnection conn2 = new NpgsqlConnection(conn_str2)){//PostgreSQLへ接続後、INSERT処理を実施し、SELECT結果を取得conn2.Open();//test対象のテーブルをリセット(全データDELETE)cmd_str = "DELETE FROM test2";cmd = new NpgsqlCommand(cmd_str, conn2);cmd.ExecuteNonQuery();//INSERT処理cmd_str = "INSERT INTO test2 VALUES(3, 'ccc'), (4, 'ddd')";cmd = new NpgsqlCommand(cmd_str, conn2);cmd.ExecuteNonQuery();//SELECT処理dt = new DataTable();cmd_str = "SELECT * FROM test2";cmd = new NpgsqlCommand(cmd_str, conn2);da = new NpgsqlDataAdapter(cmd);da.Fill(dt);//SELECT結果表示Console.WriteLine("tes_db2:");for (int i = 0; i <; dt.Rows.Count; i++){Console.WriteLine("(col1, col2) = (" + dt.Rows[i][0] + ", " + dt.Rows[i][1] + ")");}}//トランザクション完了ts.Complete();}
TransactionScopeの利用(分散トランザクション)
*{//PostgreSQLへ接続後、INSERT処理を実施し、SELECT結果を取得conn1.Open();//test対象のテーブルをリセット(全データDELETE)cmd_str = "DELETE FROM test1";cmd = new NpgsqlCommand(cmd_str, conn1);cmd.ExecuteNonQuery();//INSERT処理cmd_str = "INSERT INTO test1 VALUES(1, 'AAA'), (2, 'BBB')";cmd = new NpgsqlCommand(cmd_str, conn1);cmd.ExecuteNonQuery();//SELECT処理dt = new DataTable();cmd_str = "SELECT * FROM test1";cmd = new NpgsqlCommand(cmd_str, conn1);da = new NpgsqlDataAdapter(cmd);da.Fill(dt);//SELECT結果表示Console.WriteLine("tes_db1:");for (int i = 0; i <; dt.Rows.Count; i++){Console.WriteLine("(col1, col2) = (" + dt.Rows[i][0] + ", " + dt.Rows[i][1] + ")");}}
接続その1(tes_db1へ接続)
PostgreSQLへ接続後、INSERT処理を実施し、SELECT結果を取得
*conn1.Open();
test対象のテーブルをリセット(全データDELETE)
*cmd_str = "DELETE FROM test1";
INSERT処理
*cmd_str = "INSERT INTO test1 VALUES(1, 'AAA'), (2, 'BBB')";
SELECT処理
*dt = new DataTable();
SELECT結果表示
*Console.WriteLine("tes_db1:");
*{//PostgreSQLへ接続後、INSERT処理を実施し、SELECT結果を取得conn2.Open();//test対象のテーブルをリセット(全データDELETE)cmd_str = "DELETE FROM test2";cmd = new NpgsqlCommand(cmd_str, conn2);cmd.ExecuteNonQuery();//INSERT処理cmd_str = "INSERT INTO test2 VALUES(3, 'ccc'), (4, 'ddd')";cmd = new NpgsqlCommand(cmd_str, conn2);cmd.ExecuteNonQuery();//SELECT処理dt = new DataTable();cmd_str = "SELECT * FROM test2";cmd = new NpgsqlCommand(cmd_str, conn2);da = new NpgsqlDataAdapter(cmd);da.Fill(dt);//SELECT結果表示Console.WriteLine("tes_db2:");for (int i = 0; i <; dt.Rows.Count; i++){Console.WriteLine("(col1, col2) = (" + dt.Rows[i][0] + ", " + dt.Rows[i][1] + ")");}}
接続その2(tes_db2へ接続)
PostgreSQLへ接続後、INSERT処理を実施し、SELECT結果を取得
*conn2.Open();
test対象のテーブルをリセット(全データDELETE)
*cmd_str = "DELETE FROM test2";
INSERT処理
*cmd_str = "INSERT INTO test2 VALUES(3, 'ccc'), (4, 'ddd')";
SELECT処理
*dt = new DataTable();
SELECT結果表示
*Console.WriteLine("tes_db2:");
トランザクション完了
*ts.Complete();
SQL処理で用いる変数を予め宣言
*NpgsqlCommand cmd = null;
接続文字列
*string conn_str = "Server=123.45.67.89;Port=5432;User ID=postgres;Database=postgres;Password=password;Enlist=true";
*{//接続その1using (NpgsqlConnection conn1 = new NpgsqlConnection(conn_str)){//PostgreSQLへ接続後、INSERT処理を実施conn1.Open();//test対象のテーブルをリセット(全データDELETE)cmd_str = "DELETE FROM test";cmd = new NpgsqlCommand(cmd_str, conn1);cmd.ExecuteNonQuery();//INSERT処理cmd_str = "INSERT INTO test VALUES(1, 'AAA'), (2, 'BBB'), (3, 'CCC')";cmd = new NpgsqlCommand(cmd_str, conn1);cmd.ExecuteNonQuery();}//接続その2using (NpgsqlConnection conn2 = new NpgsqlConnection(conn_str)){//PostgreSQLへ接続後、DELETE処理を実施し、SELECT結果を取得conn2.Open();//DELETE処理cmd_str = "DELETE FROM test WHERE col1 % 2 = 0";cmd = new NpgsqlCommand(cmd_str, conn2);cmd.ExecuteNonQuery();//SELECT処理dt = new DataTable();cmd_str = "SELECT * FROM test";cmd = new NpgsqlCommand(cmd_str, conn2);da = new NpgsqlDataAdapter(cmd);da.Fill(dt);//SELECT結果表示for (int i = 0; i <; dt.Rows.Count; i++){Console.WriteLine("(col1, col2) = (" + dt.Rows[i][0] + ", " + dt.Rows[i][1] + ")");}}//トランザクション完了ts.Complete();}
TransactionScopeの利用
*{//PostgreSQLへ接続後、INSERT処理を実施conn1.Open();//test対象のテーブルをリセット(全データDELETE)cmd_str = "DELETE FROM test";cmd = new NpgsqlCommand(cmd_str, conn1);cmd.ExecuteNonQuery();//INSERT処理cmd_str = "INSERT INTO test VALUES(1, 'AAA'), (2, 'BBB'), (3, 'CCC')";cmd = new NpgsqlCommand(cmd_str, conn1);cmd.ExecuteNonQuery();}
接続その1
PostgreSQLへ接続後、INSERT処理を実施
*conn1.Open();
test対象のテーブルをリセット(全データDELETE)
*cmd_str = "DELETE FROM test";
INSERT処理
*cmd_str = "INSERT INTO test VALUES(1, 'AAA'), (2, 'BBB'), (3, 'CCC')";
*{//PostgreSQLへ接続後、DELETE処理を実施し、SELECT結果を取得conn2.Open();//DELETE処理cmd_str = "DELETE FROM test WHERE col1 % 2 = 0";cmd = new NpgsqlCommand(cmd_str, conn2);cmd.ExecuteNonQuery();//SELECT処理dt = new DataTable();cmd_str = "SELECT * FROM test";cmd = new NpgsqlCommand(cmd_str, conn2);da = new NpgsqlDataAdapter(cmd);da.Fill(dt);//SELECT結果表示for (int i = 0; i <; dt.Rows.Count; i++){Console.WriteLine("(col1, col2) = (" + dt.Rows[i][0] + ", " + dt.Rows[i][1] + ")");}}
接続その2
PostgreSQLへ接続後、DELETE処理を実施し、SELECT結果を取得
*conn2.Open();
DELETE処理
*cmd_str = "DELETE FROM test WHERE col1 % 2 = 0";
SELECT処理
*dt = new DataTable();
*for (int i = 0; i <; dt.Rows.Count; i++)*{
SELECT結果表示
トランザクション完了
*ts.Complete();
接続文字列
*string conn_str = "Server=123.45.67.89;Port=5432;User ID=postgres;Database=postgres;Password=password;Enlist=true";
PostgreSQLへ接続
*conn.Open();
SQL処理で用いる変数を予め宣言
*NpgsqlCommand cmd = null;
接続文字列
*string conn_str = "Server=123.45.67.89;Port=5432;User ID=postgres;Database=postgres;Password=password;Enlist=true";
*{//接続その1using (NpgsqlConnection conn = new NpgsqlConnection(conn_str)){//PostgreSQLへ接続後、INSERT、DELETE処理を実施し、SELECT結果を取得conn.Open();//test対象のテーブルをリセット(全データDELETE)cmd_str = "DELETE FROM test";cmd = new NpgsqlCommand(cmd_str, conn);cmd.ExecuteNonQuery();//INSERT処理cmd_str = "INSERT INTO test VALUES(1, 'AAA'), (2, 'BBB'), (3, 'CCC')";cmd = new NpgsqlCommand(cmd_str, conn);cmd.ExecuteNonQuery();//DELETE処理cmd_str = "DELETE FROM test WHERE col1 % 2 = 0";cmd = new NpgsqlCommand(cmd_str, conn);cmd.ExecuteNonQuery();//SELECT処理dt = new DataTable();cmd_str = "SELECT * FROM test";cmd = new NpgsqlCommand(cmd_str, conn);da = new NpgsqlDataAdapter(cmd);da.Fill(dt);//SELECT結果表示for (int i = 0; i <; dt.Rows.Count; i++){Console.WriteLine("(col1, col2) = (" + dt.Rows[i][0] + ", " + dt.Rows[i][1] + ")");}}//トランザクション完了ts.Complete();}
TransactionScopeの利用
*{//PostgreSQLへ接続後、INSERT、DELETE処理を実施し、SELECT結果を取得conn.Open();//test対象のテーブルをリセット(全データDELETE)cmd_str = "DELETE FROM test";cmd = new NpgsqlCommand(cmd_str, conn);cmd.ExecuteNonQuery();//INSERT処理cmd_str = "INSERT INTO test VALUES(1, 'AAA'), (2, 'BBB'), (3, 'CCC')";cmd = new NpgsqlCommand(cmd_str, conn);cmd.ExecuteNonQuery();//DELETE処理cmd_str = "DELETE FROM test WHERE col1 % 2 = 0";cmd = new NpgsqlCommand(cmd_str, conn);cmd.ExecuteNonQuery();//SELECT処理dt = new DataTable();cmd_str = "SELECT * FROM test";cmd = new NpgsqlCommand(cmd_str, conn);da = new NpgsqlDataAdapter(cmd);da.Fill(dt);//SELECT結果表示for (int i = 0; i <; dt.Rows.Count; i++){Console.WriteLine("(col1, col2) = (" + dt.Rows[i][0] + ", " + dt.Rows[i][1] + ")");}}
接続その1
PostgreSQLへ接続後、INSERT、DELETE処理を実施し、SELECT結果を取得
*conn.Open();
test対象のテーブルをリセット(全データDELETE)
*cmd_str = "DELETE FROM test";
INSERT処理
*cmd_str = "INSERT INTO test VALUES(1, 'AAA'), (2, 'BBB'), (3, 'CCC')";
DELETE処理
*cmd_str = "DELETE FROM test WHERE col1 % 2 = 0";
SELECT処理
*dt = new DataTable();
*for (int i = 0; i <; dt.Rows.Count; i++)*{
SELECT結果表示
トランザクション完了
*ts.Complete();

ここに書く
*}
ここに書く
*}

*//Platforms.SetPlatform<;SystemDrawingPlatform>;();*}
.NET Coreのパッケージの場合は、このコードが必要？
*public EasyCanvas(int width, int height) {canvas = Platforms.Current.CreateImageCanvas(new Size(width, height), scale: 2);}
Platforms.SetPlatform&lt;SystemDrawingPlatform&gt;();
*private Dictionary<;string, bool>; MakeRule(int rule) {var list = new[] {"111", "110", "101", "100", "011", "010", "001", "000"};return list.Reverse().Select(k =>; {var b = (rule &amp; 0x01) == 0x01;rule = rule >;>; 1;return new { Key = k, Value = b };}).ToDictionary(p =>; p.Key, p =>; p.Value);}
ルール番号からルールを作成
*public IEnumerable<;bool[]>; AllGenerations() {yield return _cells;while (true) {List<;bool>; area = new List<;bool>;();foreach (var la in GetAdjoints()) {area.Add(_rule[LocalAreaToString(la)]);}_cells = area.ToArray();yield return _cells;}}
すべての世代を列挙する。永遠に列挙するので注意。
*string LocalAreaToString(bool[] area) {string s = "";foreach (var a in area) {s += a == true ? "1" : "0";}return s;}
３つのセルを文字列に変換
*IEnumerable<;bool[]>; GetAdjoints() {bool[] area = new bool[3];for (int i = 0; i <; _cells.Length; i++) {area[0] = (i == 0) ? false : _cells[i - 1];area[1] = _cells[i];area[2] = (i == _cells.Length - 1) ? false : _cells[i + 1];yield return area;}}
隣接した３つのセルを配列として順に取り出す。

*int Num = 2000000;
リストの最大値
*for (int i = j; i <; Num; i++)*{
先頭を探す
*foreach (int i in IntegerList)*{
ふるい落とし。落としたものには0を入れる

*private static List<;TodoItem>; items = new List<;TodoItem>;() {new TodoItem() { Id = 1, Name = @"犬の散歩", IsDone = false, },new TodoItem() { Id = 2, Name = @"買い物", IsDone = true, },new TodoItem() { Id = 3, Name = @"本棚の修理", IsDone = false },};
Todoアイテムの初期データ。本来はデータベースなどから取得する。
新しいTodoItemのIdは、最大値＋１にする
本当はSQLでやる
*item.Id = items.Max(i =>; i.Id) + 1;

*private static bool hasDoneSomething;
static member
フィールド
*int foo;
*public int Foo { get {...} set { ... } }
プロパティ
*{int value = number + 2;Debug.Log(value);}
メソッド

*rectTransform.anchorMin = targetMinAnchor;*rectTransform.anchorMax = targetMaxAnchor;
anchorの更新
*var diffLeft = parent.rect.width * diffMin.x;*var diffRight = parent.rect.width * diffMax.x;
上下左右の距離の差分を計算
*rectTransform.sizeDelta += new Vector2(diffLeft - diffRight, diffBottom - diffTop);*var pivot = rectTransform.pivot;
サイズと座標の修正
*var rectTransform = transform as RectTransform;*// Pivotを(0.0f,0.0f)にする
使い方
*rectTransform.SetPivotWithKeepingPosition(Vector2.zero);*// Pivotを(0.2f,0.7f)にする
Pivotを(0.0f,0.0f)にする
*rectTransform.SetPivotWithKeepingPosition(0.2f, 0.7f);*// Anchorを中心(0,5f,0.5f)にする
Pivotを(0.2f,0.7f)にする
*rectTransform.SetAnchorWithKeepingPosition(0.5f, 0.5f);*// AnchorMinを左下(0.0f,0.0f)、AnchorMacを右上(1.0f,1.0f)にする (ストレッチ)
Anchorを中心(0,5f,0.5f)にする
*rectTransform.SetAnchorWithKeepingPosition(Vector2.zero, Vector2.one);*,,,
AnchorMinを左下(0.0f,0.0f)、AnchorMacを右上(1.0f,1.0f)にする (ストレッチ)
座標を保ったままPivotを変更するメソッド
*void SetPivotWithKeepingPosition(Vector2 targetPivot)
座標を保ったままAnchorを変更する
*void SetAnchorWithKeepingPosition(Vector2 targetMinAnchor, Vector2 targetMaxAnchor)
*rectTransform.SetPivotWithKeepingPosition(Vector2.zero);*// Pivotを(0.2f,0.7f)にする
Pivotを(0.0f,0.0f)にする
*rectTransform.SetPivotWithKeepingPosition(0.2f, 0.7f);*// Anchorを中心(0,5f,0.5f)にする
Pivotを(0.2f,0.7f)にする
*rectTransform.SetAnchorWithKeepingPosition(0.5f, 0.5f);*// AnchorMinを左下(0.0f,0.0f)、AnchorMacを右上(1.0f,1.0f)にする (ストレッチ)
Anchorを中心(0,5f,0.5f)にする
*rectTransform.SetAnchorWithKeepingPosition(Vector2.zero, Vector2.one);*,,,
AnchorMinを左下(0.0f,0.0f)、AnchorMacを右上(1.0f,1.0f)にする (ストレッチ)

*{public class Index{// 任意の処理（これをラップしたい）public OutParam Execute(InParam param) {  /* ... */ }}public class InParam { /* ... */ }public class OutParam { /* ... */ }}
任意のライブラリ
*public OutParam Execute(InParam param) {  /* ... */ }
任意の処理（これをラップしたい）
*{public class IndexAdapter{public Index Index { get; }public Converter Converter { get; }public IndexAdapter(Index index, Converter converter){Index = index;Converter = converter;}// 任意の処理のラッパー処理public OutParam Execute(InParam param){// パラメーターもラップするvar inParam = Converter.ConvertToInnerInParam(param);// 対象の処理を実行するvar result = Index.Execute(inParam);// 戻り値もラップするreturn Converter.ConvertToOuterOutParam(result);}}public class Converter{// ラッパー用の InParam から ライブラリ用の InParam へ変換するpublic AnyLibrary.InParam ConvertToInnerInParam(InParam param) {  /* ... */ }// ライブラリ用の OutParam からラッパー用の OutParam へ変換するpublic OutParam ConvertToOuterOutParam(AnyLibrary.OutParam param) {  /* ... */ }}public class InParam { /* ... */ }public class OutParam { /* ... */ }}
ライブラリのアダプター（ラッパー）
*{// パラメーターもラップするvar inParam = Converter.ConvertToInnerInParam(param);// 対象の処理を実行するvar result = Index.Execute(inParam);// 戻り値もラップするreturn Converter.ConvertToOuterOutParam(result);}
任意の処理のラッパー処理
パラメーターもラップする
*var inParam = Converter.ConvertToInnerInParam(param);
対象の処理を実行する
*var result = Index.Execute(inParam);
戻り値もラップする
*return Converter.ConvertToOuterOutParam(result);
*public AnyLibrary.InParam ConvertToInnerInParam(InParam param) {  /* ... */ }
ラッパー用の InParam から ライブラリ用の InParam へ変換する
*public OutParam ConvertToOuterOutParam(AnyLibrary.OutParam param) {  /* ... */ }
ライブラリ用の OutParam からラッパー用の OutParam へ変換する
*{// 対象処理をラップする処理public U Execute<;T, U>;(Func<;TransactionInfo, T, U>; proc, T param){// トランザクション情報を取得するvar info = GetTransactionInfo();// トランザクションを開始するStartTransaction(info);try{// 対象処理を実行するvar result = proc(info, param);// トランザクションをコミットするCommitTransaction(info);// 対象処理の戻り値を返すreturn result;}catch (Exception){// 例外が発生した場合// トランザクションをロールバックするRollbackTransaction(info);// 発生した例外はそのままスローするthrow;}}// Overloadpublic T Execute<;T>;(Func<;TransactionInfo, T>; proc) { /* ... */ }public void Execute<;T>;(Action<;TransactionInfo, T>; proc, T param) { /* ... */ }public void Execute<;T>;(Action<;TransactionInfo>; proc) { /* ... */ }// Private Methodprivate TransactionInfo GetTransactionInfo() { /* ... */ }private void StartTransaction(TransactionInfo info) { /* ... */ }private void CommitTransaction(TransactionInfo info) { /* ... */ }private void RollbackTransaction(TransactionInfo info) { /* ... */ }}
コンテナー（ラッパー相当）
*{// トランザクション情報を取得するvar info = GetTransactionInfo();// トランザクションを開始するStartTransaction(info);try{// 対象処理を実行するvar result = proc(info, param);// トランザクションをコミットするCommitTransaction(info);// 対象処理の戻り値を返すreturn result;}catch (Exception){// 例外が発生した場合// トランザクションをロールバックするRollbackTransaction(info);// 発生した例外はそのままスローするthrow;}}
対象処理をラップする処理
トランザクション情報を取得する
*var info = GetTransactionInfo();
トランザクションを開始する
*StartTransaction(info);
対象処理を実行する
*var result = proc(info, param);
トランザクションをコミットする
*CommitTransaction(info);
対象処理の戻り値を返す
*return result;
例外が発生した場合
トランザクションをロールバックする
*RollbackTransaction(info);
発生した例外はそのままスローする
*throw;
*public T Execute<;T>;(Func<;TransactionInfo, T>; proc) { /* ... */ }
Overload
*private TransactionInfo GetTransactionInfo() { /* ... */ }
Private Method
*public class TransactionInfo { /* ... */ }
何かしらトランザクションに関係する情報
*{public Container Container { get; }public Client(Container container){Container = container;}// メイン処理public void MainProcess(){// 対象処理に必要なパラメーターを用意するvar param = new Param();// ラッパー経由で処理を実行するvar result = Container.Execute(TargetProcess, param);// 受け取った結果を使って何かする// ...}// 対象処理 → ※ これをラップしたいprivate Result TargetProcess(TransactionInfo info, Param param) { /* ... */ }// 対象処理の引数と戻り値private class Param { /* ... */ }private class Result { /* ... */ }}
ラッパーを使う人
*{// 対象処理に必要なパラメーターを用意するvar param = new Param();// ラッパー経由で処理を実行するvar result = Container.Execute(TargetProcess, param);// 受け取った結果を使って何かする// ...}
メイン処理
対象処理に必要なパラメーターを用意する
*var param = new Param();
ラッパー経由で処理を実行する
*var result = Container.Execute(TargetProcess, param);
受け取った結果を使って何かする
...
*}
*private Result TargetProcess(TransactionInfo info, Param param) { /* ... */ }
対象処理 → ※ これをラップしたい
*private class Param { /* ... */ }
対象処理の引数と戻り値

*{//省略ButtonFace.Clicked += ButtonFaceClicked;}
上のコード省略
省略
*ButtonFace.Clicked += ButtonFaceClicked;
*{var subscriptionKey = "<;自分のkey>;";//以下URLは自分のリージョンにあったやつを記載var faceEndpoint="https://westcentralus.api.cognitive.microsoft.com";FaceClient faceClient = new FaceClient(new ApiKeyServiceClientCredentials(subscriptionKey),new System.Net.Http.DelegatingHandler[] { });faceClient.Endpoint = faceEndpoint;IList<;DetectedFace>; faceList =await faceClient.Face.DetectWithUrlAsync(speaker.Avatar, true, false, faceAttributes);var age = faceList[0].FaceAttributes.Age;var gender = faceList[0].FaceAttributes.Gender;var happiness = faceList[0].FaceAttributes.Emotion.Happiness * 100;await DisplayAlert("faceAPI", $"Age: {age}\n Gender: {gender}\n Happiness: {happiness}%", "OK");}
省略
以下URLは自分のリージョンにあったやつを記載
var faceEndpoint="https:westcentralus.api.cognitive.microsoft.com";
*FaceClient faceClient = new FaceClient(

*Console.WriteLine(s);
2018年11月09日 17時54分54秒 + 09:00
KはUTCとの時差表示(JPは+9)
*}
ローカル表記。ローカル時刻は作るしかない？
*}

*if(!SceneManager.GetSceneByName(managerSceneName).IsValid()){*SceneManager.LoadScene(managerSceneName, LoadSceneMode.Additive);
ManagerSceneが有効でないときに追加ロード

従来のコンストラクタ
*public SslServerCredentials(
SslClientCertificateRequestType 列挙体を受け取るコンストラクタが追加されました。
*public SslServerCredentials(
資格情報を指定してポートを登録します。
*Server server = new Server();
*, SslClientCertificateRequestType.RequestAndRequireAndVerify*);
クライアント資格情報の要求動作を指定します
資格情報を指定してチャネルを生成します。
*Channel = new Channel("127.0.0.1:50001"), GetClientCredentials());

*AmazonDynamoDBClient client = new AmazonDynamoDBClient();
これを介してDynamoDBにアクセスする
目的のテーブルを取得
*var table = Table.LoadTable(client, tableName);
id(プライマリキー)がtestUserであるレコードを取得する
*var result3 = table.GetItemAsync("testUser").Result;
そのレコードのattributes列に格納されているデータをDocument型で取得。
*var attrData = result3["attributes"].AsDocument();
Document型のattrDataから「sign」をキーにして値を取得。
*var sign=attrData["sign"];
手抜き確認。
Versionにsignを入れて確認する。。。
*return new SkillResponse

*public Color after_color;
フェード後の色

*await Task.Delay(100);
If you add wait, then, the it switch the Thread.

*item["attributes"] = attr2;
attributes列。上で作成したattr2を入れる。

*TableName = tableName,
追加先のテーブル名
*{{"id",new AttributeValue{S= userId} },{"attributes",attrs}}
各カラムの値を指定
テーブルに追加
*var result = client.PutItemAsync(request).Result;

*KeyType = KeyType.HASH
Partition key
テーブル名
*TableName = tableName

*case Keys.Control | Keys.Z:
Ctrl + Z

*_reactivePropertyAA Completed !!
ReactivePropertyのDisposeでOnCompleted()が呼ばれる

*bioPosition.SetTargetTransform(target);
targetは対象のオブジェクトのTransform

*int Num = 1000000;
リストの最大値
*for (int i = j; i <; Num; i++)*{
先頭を探す
*foreach (int i in IntegerList)*{
ふるい落とし。落としたものには0を入れる

*ftpReq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.NoCacheNoStore);
キャッシュしない

*if(collision.collider.CompareTag("Uni"))*{
Uniタグがつけられたオブジェクトと接触したとき
シーン中のFlowchartのExecuteOnEventに設定されたMessageReceivedを取得する
*MessageReceived[] receivers = GameObject.FindObjectsOfType<;Fungus.MessageReceived>;();
*if (receivers != null)*{
取得できた場合
*foreach (var receiver in receivers)*{
すべてのMessageReceivedに"test"イベントを送信する

*void JumpToScene()
シーンの切り替え

メッセージ取得
*var receivedMessage = turnContext.Activity.Text;
本当は関数に切り出した方がいいんだろうけど、とりあえずここにdocomoAPIの処理
string baseUrl = "https:api.apigw.smt.docomo.ne.jp/naturalChatting/v1/dialogue";
key
*string registerKey = "docomoAPIから取得したKey";

*} else {


コンパイルエラー
*var c = new MyClass(10);
*var dict = new Dictionary<;string, int>; {["apple"] = 100,["orange"] = 150,["banana"] = 200};
`&lt;string, int&gt;`を省略できない
*static class Dictionary {public static Dictionary<;TKey, TValue>; New<;TKey, TValue>;(params (TKey key, TValue value)[] tuples) {var dict = new Dictionary<;TKey, TValue>;();foreach (var (key, value) in tuples) {dict.Add(key, value);}return dict;}}
Dictionary&lt;TKey, TValue&gt;のファクトリークラス
*static class Dictionary {public static Dictionary<;TKey, TValue>; New<;TKey, TValue>;(params (TKey key, TValue value)[] tuples) {var dict = new Dictionary<;TKey, TValue>;();foreach (var (key, value) in tuples) {dict.Add(key, value);}return dict;}}
クラス名を同じにするとそれっぽい（型引数あるなしでユーザー定義型として区別可能）

*SuppressChangeType = 131072,
0x00020000

*item.PropertyChanged += OnPropertyChanged;
イベント変更通知を登録

フォルダーを追加する
*root.AddEntry(dir1);
ファイルを追加する
*root.AddEntry(file1);
階層を1つ深くする
*item.Output(someDepth + 1);

*manager.AddComponent<;BoidPrefabType<;(prefab_entity);
Prefabであることを示す空のComponent
BoidPrefabType を BoidType に付け替え
*manager.RemoveComponent<;BoidPrefabType>;(entity);
*manager.SetComponentData(entity, new Translation { Value = this.random.NextFloat3(1f) });
適当に値を設定
パラメータをローカル変数として置いておき、ラムダ式にキャプチャさせる
*float dt = Time.DeltaTime;
ジョブの定義
*Dependency = Entities.
チャンク検索のため EntityQuery が必須 (IJobEntityBatch.Schedule()の引数)
*private EntityQuery query;
アクセサのハンドルを受け取るためのメンバ。 var で受け取れないのでひたすら面倒
*[ReadOnly] public ComponentTypeHandle<;Translation>; translationHandle;
チャンク内のイテレーションは自分で書く。
1段ネストが増える分手間だしバグ混入の危険も増える
*for(int i=0; i<;batchInChunk.Count; i++)
ComponentType のアクセサが NativeArray&lt;&gt; を返すので Dispose する必要がある
*pos_array.Dispose();
必要な ComponentType, BufferType の Handle をいちいち渡す必要がある
*translationHandle = GetComponentTypeHandle<;Translation>;(),
ここで渡す EntityQuery も自分で組み立てる必要がある
*Dependency = job.ScheduleParallel(query, 1, Dependency);

*private App() {}
App.Instance.Api でアクセスできるようにする
非同期専用のSubject
*private AsyncSubject<;List<;ItemInfo>;>; m_ItemInfos = new AsyncSubject<;List<;ItemInfo>;>;();
*{Debug.Log("clicked: " + val.name);};
アクションイベントの登録（委譲元）
アクションイベントを実行する（委譲先）
*public Action<;ItemInfo>; ActionOnClick;

*{// 返却用リストList<;string>; retLine = new List<;string>;();// データの改行有無フラグbool hasNewLine = false;foreach(string line in data){int iStart = 0;// 前の読み取り行に改行付きデータがあれば、ダブルクォートの終点探しif (hasNewLine){retLine[retLine.Count - 1] += Environment.NewLine;int iEnd = SearchCloseQuot(line, iStart);if (iEnd == -1){retLine[retLine.Count - 1] += line.Replace("\"\"", "\"");continue;}retLine[retLine.Count - 1] += line.Substring(iStart, iEnd).Replace("\"\"", "\"");hasNewLine = false;iStart = line.IndexOf(',', ++iEnd);if(iStart == -1){yield return retLine;retLine = new List<;string>;();continue;}iStart++;}// 行始まりか、前行からの改行データ終わりから読み取り開始for (; iStart <; line.Length; iStart++){//始点がダブルクォートなら、終点のダブルクォートの探索if(line[iStart] == '"'){int iEnd = SearchCloseQuot(line, iStart + 1);if (iEnd == -1){retLine.Add(line.Substring(iStart));hasNewLine = true;break;}retLine.Add(line.Substring(iStart + 1, iEnd - iStart - 1).Replace("\"\"", "\""));if(iEnd == line.Length - 1){break;}else{iStart = line.IndexOf(',', iEnd + 1);continue;}}// 始点がカンマなら、空文字データがあるとして処理else if (line[iStart] == ','){retLine.Add("");continue;}// 始点がそれ以外なら、次のカンマを探索else{int iEnd = line.IndexOf(',', iStart);if(iEnd == -1){retLine.Add(line.Substring(iStart).Trim());break;}else{retLine.Add(line.Substring(iStart, iEnd - iStart));iStart = iEnd;continue;}}}// 行内のデータに改行がなければ、リストを返却してリセットif (!hasNewLine){if (line.Length == 0 || line[line.Length - 1] == ','){retLine.Add("");}yield return retLine;retLine = new List<;string>;();}}// 読み取りが終わった時に改行があれば異常処理if (hasNewLine)throw new InvalidDataException();}
File.ReadLines(string path)辺りを引数で渡すつもりで作成
返却用リスト
*List<;string>; retLine = new List<;string>;();
データの改行有無フラグ
*bool hasNewLine = false;
*if (hasNewLine)*{
前の読み取り行に改行付きデータがあれば、ダブルクォートの終点探し
*for (; iStart <; line.Length; iStart++)*{
行始まりか、前行からの改行データ終わりから読み取り開始
*if(line[iStart] == '"')*{
始点がダブルクォートなら、終点のダブルクォートの探索
*else if (line[iStart] == ',')*{
始点がカンマなら、空文字データがあるとして処理
*{int iEnd = line.IndexOf(',', iStart);if(iEnd == -1){retLine.Add(line.Substring(iStart).Trim());break;}else{retLine.Add(line.Substring(iStart, iEnd - iStart));iStart = iEnd;continue;}}
始点がそれ以外なら、次のカンマを探索
*if (!hasNewLine)*{
行内のデータに改行がなければ、リストを返却してリセット
*if (hasNewLine)*throw new InvalidDataException();
読み取りが終わった時に改行があれば異常処理
*{for (int i = startIndex; i <; data.Length; i += 2){i = data.IndexOf('"', i);if (i == data.Length - 1 || data[i + 1] != '"' || i == -1){return i;}}return -1;}
データ終端のダブルクォートを探すサブ関数

*var i = 0;
最初に0が入ってるんだからこれでいいじゃないか

*private Button[] BtnArray;
セットする配列
*BtnArray = new Button[] { Button1, Button2, Button3 };
順番を考慮して配列にセットする必要がある
*foreach (Button Btn in BtnArray)*{
イベントをまとめたい場合、ForEachで回す以外方法がない
イベント内で配列の何番目かを取得するには、実際に配列の中身を探しに行かなくてはいけない
*int index = Array.IndexOf(BtnArray, ((Button)sender));

存在してたら実行
*}
アクティブなら実行
*}

*public bool Dial(string number)
interface(抽象メンバ)なのでそれぞれ定義した
*interface Vehicle {// all are the abstract methods.void changeGear(int a);void speedUp(int a);void applyBrakes(int a);}
interface declaration
*class Bicycle : Vehicle{int speed;int gear;// to change gearpublic void changeGear(int newGear){gear = newGear;}// to increase speedpublic void speedUp(int increment){speed = speed + increment;}// to decrease speedpublic void applyBrakes(int decrement){speed = speed - decrement;}public void printStates(){Console.WriteLine("speed: " + speed +" gear: " + gear);}}
class implements interface
*{gear = newGear;}
to change gear
*{speed = speed + increment;}
to increase speed
*{speed = speed - decrement;}
to decrease speed
*class Bike : Vehicle {int speed;int gear;// to change gearpublic void changeGear(int newGear){gear = newGear;}// to increase speedpublic void speedUp(int increment){speed = speed + increment;}// to decrease speedpublic void applyBrakes(int decrement){speed = speed - decrement;}public void printStates(){Console.WriteLine("speed: " + speed +" gear: " + gear);}}
class implements interface
*{gear = newGear;}
to change gear
*{speed = speed + increment;}
to increase speed
*public void applyBrakes(int decrement){speed = speed - decrement;}
to decrease speed
*{// creating an instance of Bicycle// doing some operationsBicycle bicycle = new Bicycle();bicycle.changeGear(2);bicycle.speedUp(3);bicycle.applyBrakes(1);Console.WriteLine("Bicycle present state :");bicycle.printStates();// creating instance of bike.Bike bike = new Bike();bike.changeGear(1);bike.speedUp(4);bike.applyBrakes(3);Console.WriteLine("Bike present state :");bike.printStates();}
Main Method

*private Transform pivot;
キャラクターの中心にある空のオブジェクトを選択してください
*if(character == null)*character = transform.parent;
エラーが起きないようにNullだった場合、それぞれ設定
カメラ上下移動の最大、最小角度です。Inspectorウィンドウから設定してください
*[Range(-0.999f, -0.5f)]
*{//マウスのX,Y軸がどれほど移動したかを取得しますfloat X_Rotation = Input.GetAxis("Mouse X");float Y_Rotation = Input.GetAxis("Mouse Y");//Y軸を更新します（キャラクターを回転）取得したX軸の変更をキャラクターのY軸に反映しますcharacter.transform.Rotate(0, X_Rotation, 0);//次はY軸の設定です。float nowAngle = pivot.transform.localRotation.x;//最大値、または最小値を超えた場合、カメラをそれ以上動かない用にしています。//キャラクターの中身が見えたり、カメラが一回転しないようにするのを防ぎます。if (-Y_Rotation != 0){if (0 <; Y_Rotation){if (minYAngle <;= nowAngle){pivot.transform.Rotate(-Y_Rotation, 0, 0);}}else{if (nowAngle <;= maxYAngle){pivot.transform.Rotate(-Y_Rotation, 0, 0);}}}}
Update is called once per frame
マウスのX,Y軸がどれほど移動したかを取得します
*float X_Rotation = Input.GetAxis("Mouse X");
*character.transform.Rotate(0, X_Rotation, 0);*//次はY軸の設定です。
Y軸を更新します（キャラクターを回転）取得したX軸の変更をキャラクターのY軸に反映します
*float nowAngle = pivot.transform.localRotation.x;*//最大値、または最小値を超えた場合、カメラをそれ以上動かない用にしています。
次はY軸の設定です。
最大値、または最小値を超えた場合、カメラをそれ以上動かない用にしています。
キャラクターの中身が見えたり、カメラが一回転しないようにするのを防ぎます。
*if (-Y_Rotation != 0)
マウスのX,Y軸がどれほど移動したかを取得します
*float X_Rotation = Input.GetAxis("Mouse X");
*pivot.transform.Rotate(0, X_Rotation, 0);*//次はY軸の設定です。
Y軸を更新します（キャラクターを回転）取得したX軸の変更をキャラクターのY軸に反映します
*float nowAngle = pivot.transform.localRotation.x;*//最大値、または最小値を超えた場合、カメラをそれ以上動かない用にしています。
次はY軸の設定です。
最大値、または最小値を超えた場合、カメラをそれ以上動かない用にしています。
カメラが一回転しないようにするのを防ぎます。
*if (-Y_Rotation != 0)
操作していると、Z軸がだんだん動いていくので、0に設定してください。
*pivot.eulerAngles = new Vector3(pivot.eulerAngles.x, pivot.eulerAngles.y, 0f);

*TableName = tableName,
追加先のテーブル名
*{{"ThisIsId",new AttributeValue{N= "2"} },{"ThisIsSomething",new AttributeValue{N="5"} }}
各カラムの値を指定
テーブルに追加
*var result = client.PutItemAsync(request).Result;

*private bool _isMac;
追加する
*if(SystemInfo.operatingSystem.Contains("Windows"))*{
以下を追加する
ここまで
*}
*if (_isWindows &amp;&amp; inputChar == 'y' &amp;&amp; currentChar == 'i' &amp;&amp;*(prevChar == '\0' || prevChar == 'a' || prevChar == 'i' || prevChar == 'u' || prevChar == 'e' ||
「い」の柔軟な入力（Windowsのみ）
*if (inputChar == 'w' &amp;&amp; currentChar == 'u' &amp;&amp; (prevChar == '\0' || prevChar == 'a' || prevChar == 'i' ||*prevChar == 'u' || prevChar == 'e' || prevChar == 'o'))
「う」の柔軟な入力（「whu」はWindowsのみ）
*if (_isWindows &amp;&amp; inputChar == 'c' &amp;&amp; prevChar != 'k' &amp;&amp;*currentChar == 'k' &amp;&amp; (nextChar == 'a' || nextChar == 'u' || nextChar == 'o'))
「か」「く」「こ」の柔軟な入力（Windowsのみ）
*if (_isWindows &amp;&amp; inputChar == 'q' &amp;&amp; prevChar != 'k' &amp;&amp; currentChar == 'k' &amp;&amp; nextChar == 'u')*{
「く」の柔軟な入力（Windowsのみ）
*if (inputChar == 'h' &amp;&amp; prevChar == 's' &amp;&amp; currentChar == 'i')*{
「し」の柔軟な入力
*if (inputChar == 'j' &amp;&amp; currentChar == 'z' &amp;&amp; nextChar == 'i')*{
「じ」の柔軟な入力
*if (inputChar == 'h' &amp;&amp; prevChar == 's' &amp;&amp; currentChar == 'y')*{
「しゃ」「しゅ」「しぇ」「しょ」の柔軟な入力
*if (inputChar == 'z' &amp;&amp; prevChar != 'j' &amp;&amp; currentChar == 'j' &amp;&amp;*(nextChar == 'a' || nextChar == 'u' || nextChar == 'e' || nextChar == 'o'))
「じゃ」「じゅ」「じぇ」「じょ」の柔軟な入力
*if (_isWindows &amp;&amp; inputChar == 'c' &amp;&amp; prevChar != 's' &amp;&amp; currentChar == 's' &amp;&amp;*(nextChar == 'i' || nextChar == 'e'))
「し」「せ」の柔軟な入力（Windowsのみ）
*if (inputChar == 'c' &amp;&amp; prevChar != 't' &amp;&amp; currentChar == 't' &amp;&amp; nextChar == 'i')*{
「ち」の柔軟な入力
*if (inputChar == 'c' &amp;&amp; prevChar != 't' &amp;&amp; currentChar == 't' &amp;&amp; nextChar == 'y')*{
「ちゃ」「ちゅ」「ちぇ」「ちょ」の柔軟な入力
*if (inputChar == 'h' &amp;&amp; prevChar == 'c' &amp;&amp; currentChar == 'y')*{
「cya」=&gt;「cha」
*if (inputChar == 's' &amp;&amp; prevChar == 't' &amp;&amp; currentChar == 'u')*{
「つ」の柔軟な入力
*if (inputChar == 'u' &amp;&amp; prevChar == 't' &amp;&amp; currentChar == 's' &amp;&amp;*(nextChar == 'a' || nextChar == 'i' || nextChar == 'e' || nextChar == 'o'))
「つぁ」「つぃ」「つぇ」「つぉ」の柔軟な入力
*if (inputChar == 'e' &amp;&amp; prevChar == 't' &amp;&amp; currentChar == 'h' &amp;&amp; nextChar == 'i')*{
「てぃ」の柔軟な入力
*if (inputChar == 'e' &amp;&amp; prevChar == 'd' &amp;&amp; currentChar == 'h' &amp;&amp; nextChar == 'i')*{
「でぃ」の柔軟な入力
*if (inputChar == 'e' &amp;&amp; prevChar == 'd' &amp;&amp; currentChar == 'h' &amp;&amp; nextChar == 'u')*{
「でゅ」の柔軟な入力
*if (inputChar == 'o' &amp;&amp; prevChar == 't' &amp;&amp; currentChar == 'w' &amp;&amp; nextChar == 'u')*{
「とぅ」の柔軟な入力
*if (inputChar == 'o' &amp;&amp; prevChar == 'd' &amp;&amp; currentChar == 'w' &amp;&amp; nextChar == 'u')*{
「どぅ」の柔軟な入力
*if (inputChar == 'f' &amp;&amp; currentChar == 'h' &amp;&amp; nextChar == 'u')*{
「ふ」の柔軟な入力
*if (inputChar == 'w' &amp;&amp; prevChar == 'f' &amp;&amp;*(currentChar == 'a' || currentChar == 'i' || currentChar == 'e' || currentChar == 'o'))
「ふぁ」「ふぃ」「ふぇ」「ふぉ」の柔軟な入力（一部Macのみ）
*if (inputChar == 'n' &amp;&amp; prevChar2 != 'n' &amp;&amp; prevChar == 'n' &amp;&amp; currentChar != 'a' &amp;&amp; currentChar != 'i' &amp;&amp;*currentChar != 'u' &amp;&amp; currentChar != 'e' &amp;&amp; currentChar != 'o' &amp;&amp; currentChar != 'y')
「ん」の柔軟な入力（「n'」には未対応）
*if (inputChar == 'i' &amp;&amp; currentChar == 'y' &amp;&amp;*(prevChar == 'k' || prevChar == 's' || prevChar == 't' || prevChar == 'n' || prevChar == 'h' ||
「きゃ」「にゃ」などを分解する
*if (inputChar == 'i' &amp;&amp;*(currentChar == 'a' || currentChar == 'u' || currentChar == 'e' || currentChar == 'o') &amp;&amp;
「しゃ」「ちゃ」などを分解する
*if (_isWindows &amp;&amp; inputChar == 'c' &amp;&amp; currentChar == 's' &amp;&amp; prevChar != 's' &amp;&amp; nextChar == 'y' &amp;&amp;*(nextChar2 == 'a' || nextChar2 == 'u' || nextChar2 == 'e' || nextChar2 == 'o'))
「しゃ」を「c」で分解する（Windows限定）
*if ((inputChar == 'x' || inputChar == 'l') &amp;&amp;*(currentChar == 'k' &amp;&amp; nextChar == 'k' || currentChar == 's' &amp;&amp; nextChar == 's' ||
「っ」の柔軟な入力
*if (_isWindows &amp;&amp; inputChar == 'c' &amp;&amp; currentChar == 'k' &amp;&amp; nextChar == 'k' &amp;&amp;*(nextChar2 == 'a' || nextChar2 == 'u' || nextChar2 == 'o'))
「っか」「っく」「っこ」の柔軟な入力（Windows限定）
*if (_isWindows &amp;&amp; inputChar == 'q' &amp;&amp; currentChar == 'k' &amp;&amp; nextChar == 'k' &amp;&amp; nextChar2 == 'u')*{
「っく」の柔軟な入力（Windows限定）
*if (_isWindows &amp;&amp; inputChar == 'c' &amp;&amp; currentChar == 's' &amp;&amp; nextChar == 's' &amp;&amp;*(nextChar2 == 'i' || nextChar2 == 'e'))
「っし」「っせ」の柔軟な入力（Windows限定）
*if (inputChar == 'c' &amp;&amp; currentChar == 't' &amp;&amp; nextChar == 't' &amp;&amp; nextChar2 == 'y')*{
「っちゃ」「っちゅ」「っちぇ」「っちょ」の柔軟な入力
*if (inputChar == 'c' &amp;&amp; currentChar == 't' &amp;&amp; nextChar == 't' &amp;&amp; nextChar2 == 'i')*{
「っち」の柔軟な入力
*if (inputChar == 'x' &amp;&amp; currentChar == 'l')*{
「l」と「x」の完全互換性

接続最大数は 100 件までですよ
*options.Limits.MaxConcurrentConnections = 100;
リクエスト数は100Mまでですよ
*options.Limits.MaxRequestBodySize = 100 * 1024 * 1024;

*KeyType = "RANGE"
Sort key
*{ReadCapacityUnits = 5,WriteCapacityUnits = 5},
勉強中
テーブル名
*TableName = tableName
テーブル作成リクエストを投げる！
ただし、非同期メソッドの返りを待たねければならない。
待たないと先にこのLambdaが終了して、DynamoDBのテーブル作成処理を完了せずに終わる。
でもメソッドにasyncつけたら、最終的にスキルのレスポンスの型もTask&lt;SkillResponse&gt;にしなきゃいけなくなってだめ。
.Wait()メソッドで非同期メソッドを同期メソッドにしちゃえば、返り値も変えなくていいし、テーブル作成完了まで待つことができる。
一回完結のサーバー側の処理で非同期でなきゃいけない理由ないしね。
client.CreateTableAsync(request).Wait();
Waitメソッドではただ非同期メソッドの完了を待つだけでしたが、非同期メソッドの返り値を取得したい場合は、Resultプロパティを使いましょう。
Resultプロパティにアクセスすることで、非同期メソッドの完了を待った上で結果を取得することができます。
結果を使って何か処理を行いたい場合はこちらが良いのではないでしょうか。
*var result=client.CreateTableAsync(request).Result;
テーブル一覧を取得
*var tableList=client.ListTablesAsync().Result;
TableNamesプロパティをチェック
*return tableList.TableNames.Exists(s =>; s.Equals(tableName));

*Console.ReadKey();
何かキーを押せばアプリ終了。

画面遷移を行う
今回の本題とは関係ないので説明略
*var regionManager = containerProvider.Resolve<;IRegionManager>;();
*{// ContainerRegistryが抽象化されたコンテナへの登録用Interface// GetContainerでUnityのコンテナに直接アクセスできる// NugetにてUnity、Prism.Unityを導入する必要ありvar container = containerRegistry.GetContainer();// 普通にUnityが利用可能container.RegisterType<;Models.ModelA>;(new InjectionFactory(x =>;{return new Models.ModelA("Hello, Prism 7.x !");}));// Viewの登録containerRegistry.RegisterForNavigation<;ViewA>;();}
ここでコンテナへの登録作業を行う
ContainerRegistryが抽象化されたコンテナへの登録用Interface
GetContainerでUnityのコンテナに直接アクセスできる
NugetにてUnity、Prism.Unityを導入する必要あり
*var container = containerRegistry.GetContainer();
*{return new Models.ModelA("Hello, Prism 7.x !");}));
普通にUnityが利用可能
Viewの登録
*containerRegistry.RegisterForNavigation<;ViewA>;();

*logic.Run();
IBusinessLogic には Run メソッドを作ると決める
処理
*}
処理
*}

*skillResponse.Response.ShouldEndSession = true;
セッション終了を指定
テスト
*}

*[SerializeField] private TextMeshProUGUI textRoman;
ここにローマ字表示のTextMeshProをアタッチする。

*log.LogInformation($"Started orchestration with ID = '{instanceId}'.");
Function input comes from the request content.

*public class TestMain : MonoBehaviour {void Start (){// yield return の実行テスト//StartCoroutine(TaskForYieldReturn()); // --- (1)// .MoveNext の実行テスト//StartCoroutine(TaskForMoveNext()); // --- (2)}// 直接yield return の実行テストprivate IEnumerator TaskForYieldReturn(){Debug.Log($"START : [ {Time.frameCount} ]");yield return StartCoroutine( SubTask() );Debug.Log($"END : [ {Time.frameCount} ]");}// .MoveNext の実行テストprivate IEnumerator TaskForMoveNext(){Debug.Log($"START : [ {Time.frameCount} ]");var e = SubTask();while(e.MoveNext()) { yield return e.Current; }Debug.Log($"END : [ {Time.frameCount} ]");}// 遅延処理がないコルーチンprivate IEnumerator SubTask(){Debug.Log($"SubTask : [ {Time.frameCount} ]  ");yield break;}}
コルーチン実行テスト
yield return の実行テスト
StartCoroutine(TaskForYieldReturn());  --- (1)
.MoveNext の実行テスト
StartCoroutine(TaskForMoveNext());  --- (2)
*}
*{Debug.Log($"START : [ {Time.frameCount} ]");yield return StartCoroutine( SubTask() );Debug.Log($"END : [ {Time.frameCount} ]");}
直接yield return の実行テスト
*{Debug.Log($"START : [ {Time.frameCount} ]");var e = SubTask();while(e.MoveNext()) { yield return e.Current; }Debug.Log($"END : [ {Time.frameCount} ]");}
.MoveNext の実行テスト
*{Debug.Log($"SubTask : [ {Time.frameCount} ]  ");yield break;}
遅延処理がないコルーチン

Bluetoothを使う場合は AVAudioSessionCategoryOptions.AllowBluetooth が必須
*AVAudioSession.SharedInstance().SetCategory(AVAudioSessionCategory.PlayAndRecord, AVAudioSessionCategoryOptions.AllowBluetooth);
*NSNotificationCenter.DefaultCenter.AddObserver(AVAudioSession.RouteChangeNotification, (notification) =>;*{
音声入出力のルート変更を検知する場合は、AVAudioSession.RouteChangeNotification を指定
*if (notification.UserInfo["AVAudioSessionRouteChangeReasonKey"] is NSNumber key)*{
ルート変更理由の取得と判定
新しくデバイス（Bluetoothやイヤホンジャック）が接続された場合
*case (int)AVAudioSessionRouteChangeReason.NewDeviceAvailable:
出力先を既定にする
*AVAudioSession.SharedInstance().OverrideOutputAudioPort(AVAudioSessionPortOverride.None, out error);
デバイスが使えなくなった場合（Bluetoothの切断やイヤホンジャックを抜いた場合）
*case (int)AVAudioSessionRouteChangeReason.OldDeviceUnavailable:
出力先を内蔵スピーカーに強制する
*AVAudioSession.SharedInstance().OverrideOutputAudioPort(AVAudioSessionPortOverride.Speaker, out error);

文字列化したいdouble型
*double val = 1.12345;
端末依存のCultureInfoで文字列出力した場合
文字列から数値に戻せるように書式指定子にR（ラウンドトリップ書式指定子）を指定
*Debug.WriteLine ("Before: " + val.ToString("R"));
CultureInfo.InvariantCultureでen-USの書式を取得
*CultureInfo culture = CultureInfo.InvariantCulture;
*NumberFormatInfo format = culture.NumberFormat;*// CultureInfo.InvariantCultureのNumberFormatInfoを指定して出力
数値文字列のフォーマットを取得
*Debug.WriteLine ("After: " + val.ToString ("R", format));*,,,
CultureInfo.InvariantCultureのNumberFormatInfoを指定して出力

*["apple"] = 180,
&lt;- 重複

時刻の形式が正しいか？
（数字2桁:数字2桁か簡易チェックしてOKならDateTime型に変換できるかチェックする）
*if (System.Text.RegularExpressions.Regex.IsMatch(
時刻として正しくない
*ErrMsg("時刻を正しく入力してください。例）12:34");
*if (string.IsNullOrWhiteSpace(msgText.Text))*{
メッセージが入力されているか？
メッセージ未入力（または空白しか入力されていない）
*ErrMsg("メッセージを入力してください。");
時刻もメッセージも入力されている
まだ追加されていない時刻かチェック
*if (timeAndMsgs.ContainsKey(timeText.Text))
一覧に追加
*listBox.Items.Add(timeText.Text + "\t" + msgText.Text);

XMLファイルの取得
var testfile = XDocument.Load("http:alfalfalfa.com/index.rdf");
ルート要素を選択
*var rss = testfile.Root.Elements();
*if (title != null){//"title"タグの値を表示Console.WriteLine(title.Value);}
"title"タグを選択
"title"タグの値を表示
*Console.WriteLine(title.Value);
*namespace ConsoleApp1{class Program{static void Main(string[] args){//XMLファイルの取得var testfile = XDocument.Load("http://alfalfalfa.com/index.rdf");//ルート要素を選択var rss = testfile.Root.Elements();foreach(var x in rss){//Namespaseの値を取得(修正箇所)var ns = x.Name.Namespace;//ns + "title"タグを選択(修正箇所)var title = x.Element(ns + "title");if (title != null){//ns + "title"タグの値を表示Console.WriteLine(title.Value);}}}}}
何も表示されない
XMLファイルの取得
var testfile = XDocument.Load("http:alfalfalfa.com/index.rdf");
ルート要素を選択
*var rss = testfile.Root.Elements();
Namespaseの値を取得(修正箇所)
*var ns = x.Name.Namespace;
*if (title != null){//ns + "title"タグの値を表示Console.WriteLine(title.Value);}
ns + "title"タグを選択(修正箇所)
ns + "title"タグの値を表示
*Console.WriteLine(title.Value);

keyFile：ダウンロードしたid_rsaの物理ファイルパス
sshPasswd：「パスワードを聞かれるのでお好きなパスワード入力」で入力したパスワード
*var pkfile = new PrivateKeyFile(keyFile, sshPasswd);
さくらのホスト名(xxxxx.sakura.ne.jp)
*string host = "xxxxx.sakura.ne.jp";
user：さくらのユーザ名(xxxxx)
*string user = "xxxxx";
ここで例外エラーが起こらなければSSH接続はOK
*sshClient.Connect();
さくらのサーバコントロールパネル-データベース一覧の「データベースサーバ」を設定
*string serverName = "yyyyy.db.sakura.ne.jp";

*[WebService(Namespace = "http:
tempuri.org")]
この Web サービスを、スクリプトから ASP.NET AJAX をしようして呼び出せるようにするには、次の行のコメントを解除します。
[System.Web.Script.Services.ScriptService]
*public class SampleWS : System.Web.Services.WebService

*{case LaunchRequest launchRequest:skillResponse = LaunchRequestHandler(skillRequest);break;case IntentRequest intentRequest:switch (intentRequest.Intent.Name){case "HelloWorldIntent":skillResponse = HelloWorldIntentHandler(skillRequest);break;case "AMAZON.HelpIntent":skillResponse = HelpIntentHandler(skillRequest);break;case "AMAZON.CancelIntent":skillResponse = CancelAndStopIntentHandler(skillRequest);break;case "AMAZON.StopIntent":skillResponse = CancelAndStopIntentHandler(skillRequest);break;default://skillResponse = ErrorHandler(skillRequest);break;}break;case SessionEndedRequest sessionEndedRequest:skillResponse = SessionEndedRequestHandler(skillRequest);break;default://skillResponse = ErrorHandler(skillRequest);break;}
型スイッチの利用

*hederList.Add("応答");
timings.receive
ヘッダー
*sw.WriteLine(string.Join(",", hederList));

*var prepare = awaiter.GetPrepare();
awaiterには何かしらのインターフェースを継承させておく
戻り値を準備させる
実際は戻り値をどのようにして準備させるかによってもっと複雑になる
*prepare();
何度呼び出されてもいいようにもう一度コピーしてそっちを使用する
*var _copy = CopyStateMachine(copy);

*static readonly string uri = "ws:
192.168.***.***:9090";

*System.Diagnostics.Debug.WriteLine(BaseClass.GetName<;BaseClass<;());
ArgumentException(´・ω・`)

参照する値
*public float ClockingAlpha = 0;
変動する値
*float time = 0.0f;
設定する値
*[SerializeField] private float angularFrequency = 3.5f;
エディタでアタッチしてもしてなくても動く
*[SerializeField] private CanvasGroup canvasGroup;

*Version = "1.0",
お約束
*if (skillRequest.Request.Type == "LaunchRequest")*{
テスト用
とりあえずreturnしておくことにした
*return skillResponse;

状態が変更されるまで待機する
*ChannelState state = channel.State;
状態が変更されたときの処理を実行する
*OnChannelStateChanged(state, channel.State);

*void Start () {ResetBlock();}
Use this for initialization
*void Update () {_iLevelValue = _dLevelValue.value;_fTimeLimit -= Time.deltaTime;if (_fTimeLimit <;= 0.0){_iBlockRedMain[_iCounter].gameObject.SetActive(true);_iBlockBlueMain[_iCounter].gameObject.SetActive(true);_iCounter++;_fTimeLimit = 0.5f;}if (_iCounter == 5){ResetBlock();_iCounter = 0;}}
Update is called once per frame
*void Start () {_fBaseNumber = Mathf.Round(Random.Range(0f, 10f));_iSaveCount = 0;if (main._iLevelValue == 0) { _fWorldTime = 15;}else if (main._iLevelValue == 1) { _fWorldTime = 7;}else if (main._iLevelValue == 2) { _fWorldTime = 1;}else { _fWorldTime = 100;}_fTimeLimit = _fWorldTime;for (int i = 1;i <; 6; i++){_iBlockRed[i].gameObject.SetActive(false);_iBlockBlue[i].gameObject.SetActive(false);}ResetAnswerField();MakeQuestion();}
Use this for initialization
*void Update () {_fMakeCountTimer += Time.deltaTime;if (_fWorldTime != 100) {_fTimeLimit -= Time.deltaTime;if (_fTimeLimit <;= 0.0) {_iBlockRed[_iCheckNumberBlockRed].gameObject.SetActive(true);_iCheckNumberBlockRed++;_fTimeLimit = _fWorldTime;}}if (_fModValue == _fResultNumber){MakeQuestion();}_tAnswerCounterText.text = "求める値:" + _fResultNumber;_tMakeCountTimerText.text = "生成時間:" + Mathf.Round(_fMakeCountTimer);if (_iCheckNumberBlockRed == 6){SceneManager.LoadScene("Lose Scene");}else if (_iCheckNumberBlockBlue == 6){SceneManager.LoadScene("Win Scene");}}
Update is called once per frame
*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame
*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame

*double d = md.Discri(1.0, 2.0, 3.0);
代入
*{partial class A{int num = 0;void MethodA() { }partial void MethodC();}}
File1.cs 内:
*{partial class A{void MethodB() { }partial void MethodC() { }}}
File2.cs 宣言内:
*partial class Earth : Planet, IRotate { }
--
*class Earth : Planet, IRotate, IRevolve { }
これらは、次の宣言と等価です。

*xmlns:x="http:
schemas.microsoft.comwinfx2009xaml"

*Response = new ResponseBody()
お約束
リクエストタイプが「LaunchRequest」かそれ以外の「IntentRequest」か判別する
今回はスキル起動時に送られる「LaunchRequest」のときとそれ以外のときで異なるレスポンスを返すようにした。
*if (input.Request.Type == nameof(Alexa.NET.Request.Type.LaunchRequest))
LaunchRequest以外はこちら
つまりIntentRequestもこちら
IntentRequestの場合
SampleIntentとGreetingIntentの2種類＋ビルトインインテント数種類がある
今回は自分で登録したSmapleIntentとGreetingIntentだけを扱う。
RequestをIntentRequestにキャスト
*var intentRequest = (IntentRequest) input.Request;
インテント名はこのIntentRequestオブジェクトが持っている
*var intentName = intentRequest.Intent.Name;
*if (intentName == "SampleIntent")*{
インテント名で場合分け
セッション終了させる。
*skillResponse.Response.ShouldEndSession = true;

受信完了を返す
*return new Empty();
*var request = new HelloRequest{Name = "Mete - on C#",Age = 34,Sentiment = Sentiment.Happy};
Create a request
チャンクデータの作成
*var fs = new FileStream("00013646_72B.jpg", FileMode.Open);
*{Stopwatch sw = new Stopwatch();sw.Start();for (int i = 0; i <; 100; i++){// 送信var stream = client.filesend();var chunk = Google.Protobuf.ByteString.CopyFrom(data, 0, data.Length);await stream.RequestStream.WriteAsync(new Chunk() { Chunk_ = chunk });await stream.RequestStream.CompleteAsync();var res = await stream.ResponseAsync;}sw.Stop();Console.WriteLine(sw.Elapsed);});
ファイルの送信処理
送信
*var stream = client.filesend();

*var beforeLength = _gameObjects.Length;*// nullと重複を除く
Inspectorに入力された長さを覚えておく
nullと重複を除く
*_gameObjects = _gameObjects
(入力された長さ) - (現在の長さ)
で足りない長さを調べる
*var length = beforeLength - _gameObjects.Length;
不足がある場合は,足りない長さの空の配列を作ってConcatで追加
*_gameObjects = _gameObjects
なんの変哲もないGameObjectの配列
*[SerializeField]

*if (isLeft != prev_isLeft) {
現在のプレイヤーの向きが1フレーム前と異なっていたら

*[TypeConverter(typeof(ListTypeConverter))]
*追加*

*...
send document to log storage

*Response = new ResponseBody()
お約束
リクエストタイプが「LaunchRequest」かそれ以外の「IntentRequest」か判別する
今回はスキル起動時に送られる「LaunchRequest」のときとそれ以外のときで異なるレスポンスを返すようにした。
*if (input.Request.Type == nameof(Alexa.NET.Request.Type.LaunchRequest))
セッション終了させる。
*skillResponse.Response.ShouldEndSession = true;

*OthelloCell[,] OthelloCells;
8x8のOthelloCell.csの配列参照 (Start()で生成している)
中略
押下された位置が反転可能かの判定
*internal bool CanPlaceHere(Vector2 location)
*if (OthelloCells[(int)location.x, (int)location.y].OwnerID != -1)*return false;
押下された位置は、そもそも空いているか
*for (int direction = 0; direction <; DirectionList.Count; direction++)*{
全方向に対して、挟めるか方角があるかを判定
*if (FindAllyChipOnOtherSide(directionVector, location, false) != null)*{
指定された方角に対して、挟む自分のコマが存在しているか？
一つの方向でも見つかればそれで終わり
*return true;
*{Vector2 to = fromV + directionVector;//ボードの外に出ていないか、空マスでないかif (IsInRangeOfBoard(to) &amp;&amp; OthelloCells[(int)to.x, (int)to.y].OwnerID != -1){//見つかったマスのオセロは自分のオセロかif (OthelloCells[(int)to.x, (int)to.y].OwnerID == OthelloBoard.Instance.CurrentTurn){//既に間に一回敵オセロを見つけているか(つまり挟んだか)if (EnemyFound)return OthelloCells[(int)to.x, (int)to.y];return null;}else//見つかったのは敵オセロなので、EnemyFoundを真にし、自分のオセロを見つけるまで再帰的に同メソッドを呼ぶreturn FindAllyChipOnOtherSide(directionVector, to, true);}//ここまでにreturnされない場合nullを返すreturn null;}
指定された方角に対して、挟む事ができるかを判定する再帰メソッド
*if (IsInRangeOfBoard(to) &amp;&amp; OthelloCells[(int)to.x, (int)to.y].OwnerID != -1)*{
ボードの外に出ていないか、空マスでないか
*if (OthelloCells[(int)to.x, (int)to.y].OwnerID == OthelloBoard.Instance.CurrentTurn)*{
見つかったマスのオセロは自分のオセロか
*if (EnemyFound)*return OthelloCells[(int)to.x, (int)to.y];
既に間に一回敵オセロを見つけているか(つまり挟んだか)
見つかったのは敵オセロなので、EnemyFoundを真にし、自分のオセロを見つけるまで再帰的に同メソッドを呼ぶ
*return FindAllyChipOnOtherSide(directionVector, to, true);
ここまでにreturnされない場合nullを返す
*return null;
*for (int direction = 0; direction <; DirectionList.Count; direction++)*{
全方位に対して挟む事が可能かを検地 (パフォーマンスを考慮する場合、CanPlaceHereの途中経過を渡すべきだが割愛)
2.2のメソッドを再利用
*OthelloCell onOtherSide = FindAllyChipOnOtherSide(directionVector, othelloCell.Location, false);
挟んだ敵のセルをひっくり返す
*ChangeOwnerBetween(othelloCell, onOtherSide, directionVector);
*{for (Vector2 location = from.Location + directionVector; location != to.Location; location += directionVector){OthelloCells[(int)location.x, (int)location.y].OwnerID = CurrentTurn;}}
fromからtoの間で、挟んだ敵のセルをひっくり返す
*public int EnemyID { get { return (CurrentTurn+1) % 2; } }
敵のIDは、今のプレイヤーが0なら1、1なら0を返す
今のターンのプレイヤーを入れ替える
*CurrentTurn = EnemyID;
*for (int y = 0; y <; BoardSize; y++)*{
入れ替えた上で、配置できる場所があるかをボード全体から探す
見つかったので無事次のプレイヤーの順番
*return;
*if (!isAlreadyEnded)*//もう一度同処理を再帰的に呼ぶ ただしisAlreadyEndedフラグを立てて呼ぶ
見つかっていない
*else {//両プレイヤー共に置く所がないGameOver();}
もう一度同処理を再帰的に呼ぶ ただしisAlreadyEndedフラグを立てて呼ぶ
両プレイヤー共に置く所がない
*GameOver();

*Parent childInParent = new Child();
コイツの動作が変わる
出力
parent.Hoge();                  Parent#Hoge()
parent.VirtualMethod();         Parent#VirtualMethod()
child.Hoge();                   Child#Hoge()
child.VirtualMethod();          Child#VirtualMethod()
childInParent.Hoge();           Parent#Hoge() ← Parentが出力（※1）
childInParent.VirtualMethod();  Child#VirtualMethod()
*Console.ReadLine();
*public virtual void VirtualMethod() {Console.WriteLine("Parent#VirtualMethod()");}
virtualとoverride修飾子はペア（※3）
*public new void Hoge() {Console.WriteLine("Child#Hoge()");}
new修飾子で隠ぺい（※2）
*public override void VirtualMethod() {Console.WriteLine("Child#VirtualMethod()");}
オーバーライド（※3）

最初の領域の定義
*var ar1 = new byte[128];
Memory&lt;T&gt;としてデータを保持する
*seg1.Memory = ar1.AsMemory();
データの開始点は0
*seg1.RunningIndex = 0;
次の領域の定義
*var ar2 = new byte[128];
全体の配列で見たときの、この領域の開始点を指定する
*seg2.RunningIndex = ar1.Length;
次の領域へのリンクを付ける
*seg1.Next = seg2;
開始点の場所と、終点の場所を指定する(2,4引数は、セグメント中のインデックス番号)
*var seq = new ReadOnlySequence<;byte>;(seg1, 0, seg2, seg2.Length);
GetEnumeratorを実装しているので、foreachでSystem.ReadOnlyMemory&lt;T&gt;が取得できる
開始点がSegmentの途中を指していた場合、開始点から切り取られた状態で取得ができる。
*}
末尾データを取得したい場合は、seq.GetPosition(0, seq.End)のように指定する
*SequencePosition pos = seq.GetPosition(N);
GetObjectは必ずobjectを返すため、キャストして使用すること
*var segment = (ReadOnlySequenceSegment<;T>;)pos.GetObject();

フィルターセット(例では解析モデル床でフィルタリング)
*ElementCategoryFilter filter = new ElementCategoryFilter(BuiltInCategory.OST_FloorAnalytical);
要素IDを取得する
*return elementIds;

*await TagLibMP4Extentions.SetMetaTagAsync(mp4Path, new string[] { "test1", "テスト２", "test３"} );
タグの設定
タグの取得
*var getTag = await TagLibMP4Extentions.GetMetaTagAsync(mp4Path);

*www.Dispose();
&lt;- ここで明示的に破棄を指定
Unity にリソースの解放を依頼。あくまで依頼なので、このタイミングで確実に解放されるわけではない
*yield return Resources.UnloadUnusedAssets();
DXT5Crunched の空のテクスチャを用意
*Texture2D texture = new Texture2D(2048, 2048, TextureFormat.DXT5Crunched, false);
ここでテクスチャを読み込み
*www.LoadImageIntoTexture(texture);
テクスチャ圧縮
*texture.Compress(false);
圧縮後のテクスチャを割り当て
*textureArray[key] = (T)(object)texture;
読み込みは終わったので Dispose()
*www.Dispose()

*string url = string.Format("https:
api.chatwork.comv2rooms{0}files", roomID);
ファイルを 1 行ずつ読み込む
*string stBuffer = cReader.ReadLine();
読み込んだものを追加で格納する
*stResult += stBuffer + System.Environment.NewLine;
データをPOST送信するためのStreamを取得
*var reqStream = req.GetRequestStream();
送信するデータを書き込む
*reqStream.Write(postDataBytes, 0, postDataBytes.Length);
サーバーからの応答を受信する
*var res = req.GetResponse();
応答データを受信するためのStreamを取得
*var resStream = res.GetResponseStream();
受信して表示
*var sr = new StreamReader(resStream, enc);
結果受信
*var responseMessage = sr.ReadToEnd();

*public Book(string title, string author) {
コンストラクタの引数に id を渡さない
book.HasKey(nameof(Book.Id)); 不要
*book.Property(e =>; e.Title);

*using JumpState = animJump.JumpState;
UniRxのJumpStateと命名が被ってしまっているので、UniRxが入っている場合に必要です。
プレイヤーの位置から下向きにRaycast
レイヤーマスクでGroundを設定しているので、
地面のGameObjectにGroundのレイヤーを設定しておけば、
Groundのレイヤーを持つGameObjectで一番近いものが一つだけヒットする
*var isGroundHit = Physics.Raycast(
ヒットしなかった場合はキャラの下方に地面が存在しないものとして扱う
*distance = float.MaxValue;

*delIntro(name);
ここで引数の関数が実行される。後ろにカッコをつけないと、関数は実行されない。
*{Console.WriteLine("Hi. I am " + name + ".");}
このメソッドを、メソッドごと変数に突っ込む予定。（※正確にはメソッドへの参照を渡す）
ここでは何も出力されない。メソッドをDelegateIntroduceに代入する（※メソッドへの参照を渡す）だけ。
*DelegateSubIntroduce delIntro = Someone.IntroduceMyself;
ここで初めてコンソール出力される。
*Lisa.Talk(delIntro, "Yuki");

*{// 例外をキャッチしてスローしなおすtry{return Task.WhenAll(Execute001Async(arg1), Execute002Async(arg2, arg3));}catch (Exception ex){throw new Exception("処理中に例外が発生しました。", ex);}}
ローカル関数を介して処理を実行する
*{return Task.WhenAll(Execute001Async(arg1), Execute002Async(arg2, arg3));}
例外をキャッチしてスローしなおす
*foreach (var result in values.Select(x =>; 10 / x))*{
ここでゼロ除算例外がスローされる

*vcap.Dispose();
Memory release

*{public void CommonProc() =>;Console.WriteLine("(*・з・*)");}
共通ロジック
*{}
継承の場合
*{private CommonModel Model { get; }public Director() =>; Model = new CommonModel();public void CommonProc() =>; Model.CommonProc();}
使用の場合

*{return m_Enumerator.Current[i];}
IDataReader の各メンバを実装します。ここでは割愛します。
NextRandomInt32メソッドは指定された範囲内でランダムな値を返すメソッド
*return expectedValues[NextRandomInt32(0, expectedValues.Count - 1)];
*{return (RandomInt32 ?? s_DefaultRandomInt32).NextValue(minValue, maxValue);}
NextAnyメソッドから呼び出しているメソッドです。
生成するデータ数
*int dataCount = 20;
データ項目
*var fields = Observable
連番
*.Range(1, dataCount)
今日から一か月間のランダムな日付
*.And(generator.Random(dataCount, DateTime.Today, DateTime.Today.AddMonths(1)).Select(d =>; d.Date))
1～100 のランダムな整数を前ゼロ編集した文字列
*.And(generator.Random(dataCount, 1, 100).Select(value =>; value.ToString("d3")))
a, b, c, d, e を順番に返す
*.And(generator.Each(dataCount, "a", "b", "c", "d", "e"))
A, B, C, D, E の何れかを返す
*.And(generator.Any(dataCount, "A", "B", "C", "D", "E"))
*, new string[] { "A", "B", "C", "D", "E" }, new double[] { 0.5, 0.3, 0.1, 0.05 }))
A, B, C, D, E の何れかを返す（A:50%, B:30%, C:10%, D:5%, E:5%）
[a, b, c] と [1, 2, 3] の何れかを組み合わせた文字列
*.And(generator.Any(dataCount, "a", "b", "c").Zip(generator.Any(dataCount, 1, 2, 3), (a, i) =>; a + i))
-10000～10000 のランダムな整数または25%の確率でnull
*.And(generator.RandomOrNull(dataCount, 0.25, -10000, 10000))
*new object[] { field1, field2, field3, field4, field5, field6, field7, field8 }
データ項目の配列にまとめて返す
Observable なデータソースを生成
*var source = Observable.When(plan);
*foreach (object[] values in source.ToEnumerable())*{
生成された値を列挙してみる

*Console.WriteLine(log);
C#

*for (int i = 0; i <; 10; i++)
getｱｸｾｻに使用

*{return text.Replace("\r\n", toEOL).Replace("\r", toEOL).Replace("\n", toEOL);}
改行コードを統一

マウスオーバー時のカーソルはIビームに変更
*AssociatedObject.Cursor = Cursors.IBeam;
*if (!string.IsNullOrEmpty(SelectedText)) {*Clipboard.SetText(SelectedText);
Ctrl+C が押された場合はクリップボードに選択内容をコピー
*} else {
ダブルクリック (全選択)
*if (AssociatedObject.CaptureMouse()) {*Point mouseDownPoint = e.GetPosition(AssociatedObject);
シングルクリック (選択開始)
選択中文字列の背景色変更
*Point mouseUpPoint = e.GetPosition(AssociatedObject);
選択終了
*Point mouseUpPoint = e.GetPosition(AssociatedObject);
TextBlockから選択範囲文字列取得
*TextRange ntr = new TextRange(start, end);

*path = path.Replace("https:
", "https:" + user + ":" + pass + "@");

*[Inject] IPlayerVoiceService service)
Functionの引数にインジェクトしたい場合、Inject属性が必要だよ！
*log.LogInformation($"serviceの実装型は「{service.GetType().Name}」です！");*var playerVoice = service.GetPlayerVoice();
=&gt; serviceの実装型は「PlayerVoiceService」です！
*log.LogInformation($"PlayerVoice={playerVoice}");*return new OkObjectResult(playerVoice);
=&gt; PlayerVoice=スプラトゥーン楽しいいいいいいいいい
インターフェイスと、それに対応する実装クラスを指定！
いろんな設定方法があるので、本家Autofacを参考にしてね！
https:github.com/autofac/Autofac#get-started
*builder.RegisterType<;InMemoryPlayerVoiceRepository>;().As<;IPlayeVoiceRepository>;();
PlayerVoiceServiceとInMemoryRepositoryの両方を登録しているので、
コンストラクタ引数へInMemoryRepositoryのインスタンスをインジェクトしてくれるよ！
Functionの引数じゃないのでInject属性は不要だよ！
*public PlayerVoiceService(IPlayeVoiceRepository repository)

*{options.TextEncoderSettings = new System.Text.Encodings.Web.TextEncoderSettings(System.Text.Unicode.UnicodeRanges.All);});
UTF8文字コードがHTMLエンティティされる問題を解決するおまじない

(略)
*}
(略)
同じ型に対して、複数の型情報を登録するため名前付きにする
*container.RegisterType<;IVehicle, Car>;(nameof(Car));
(略)
*}
*if (container.Resolve<;IVehicle>;(nameof(Car)) is Car)*{
(略)
(略)
*}
同じ型に対して、複数の型情報を登録するため名前付きにする
*container.RegisterType<;IVehicle, Car>;(nameof(Car));

*{[SerializeField] float messageScaleTime = 0.3f;[SerializeField] float displayTime = 2.5f;[SerializeField] TextMeshProUGUI MessageText;public IEnumerator TimeForDisplay(string message){MessageText.text = message;transform.DOScale(Vector3.one, messageScaleTime);yield return new WaitForSeconds(displayTime);transform.DOScale(Vector3.zero, messageScaleTime);}//アタッチされたScript上で右クリックを押して動作確認できます[ContextMenu("testMessage")]public void testMessage(){StartCoroutine(TimeForDisplay("これはテストです！"));}}
メッセージウィンドウにアタッチして使います
*public void testMessage(){StartCoroutine(TimeForDisplay("これはテストです！"));}
アタッチされたScript上で右クリックを押して動作確認できます

*static List<;uint<; notificationIds = new List<;uint<;();
通知リスト
*foreach (UserNotification n in userNotifications)*{
新しい通知を検出する
新しい通知だ！
*Console.WriteLine("------------- Add! : " + n.Id + "------------- ");
*notificationIdsNow.Add(n.Id);*}
現在の通知を記録していく
存在しなくなった通知を検出する
*List<;uint>; removeIdList = new List<;uint>;();
消えた通知だ！
*Console.WriteLine("------------- Remove! : " + id + "------------- ");
*foreach (uint id in removeIdList)*{
foreach中に削除できないので一旦別のに入れて削除している

元の画像はとりあえずリソースから取得
*var img = FindResource("neko") as BitmapImage;
*using (var fs = new FileStream(filePath, FileMode.Create)) {BitmapEncoder enc = new JpegBitmapEncoder();enc.Frames.Add(BitmapFrame.Create(img));enc.Save(fs);}
テンプラリフォルダに画像ファイル作成
*var dataObject = new DataObject(DataFormats.FileDrop, new[] { filePath });
ドラッグ開始

exeファイルパス設定
*proc.StartInfo.FileName = "exeへのフルパス";
引数設定
*proc.StartInfo.ArgumentList.Add("引数");
exe呼出
*proc.Start();
exeの終了を待つ
*proc.WaitForExit();

*Navigate("https:
qiita.com");

*char c[6];
(6byte)

*//{//  return type.IsPrimitive &amp;&amp; (type != typeof(bool)) &amp;&amp; (type != //typeof(char));//}
public static bool IsNumeric(this Type type)

*this[index] = new T();
初期値
*public virtual IEnumerable<;int>; GetAllIndexes() {for (int y = 1; y <;= this.YSize; y++) {for (int x = 1; x <;= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する
*public virtual IEnumerable<;int>; EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index) &amp;&amp; this[index] != null; index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む
(x,y)から右(水平)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Horizontal(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Virtical(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantR(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantL(int x, int y)
*foreach (var move in moves) {*var (x, y) = board.ToLocation(move.Place);
結果の棋譜を表示
棋譜を再現
*Replay(moves);
*private static void Replay(IEnumerable<;Move>; moves) {var board = new OthBoard();board.Print();Console.ReadLine();foreach (var move in moves) {Console.SetCursorPosition(0, 0);board.Put(move.Stone, move.Place);board.Print();Console.ReadLine();}}
棋譜を再現
*public IEnumerable<;Move>; Solve(OthBoard board) {// 最初はどこに打っても同じなので、ひとつに固定。int p = board.ToIndex(3, 4);board.Put(board.Turn, p);var queu = new Queue<;OthBoard>;();queu.Enqueue(new OthBoard(board));var current = board;while (queu.Count != 0) {//キューの先頭からノード currentNode を取り出すcurrent = queu.Dequeue();if ((current.StoneCount(Stone.Black) == 0) ||(current.StoneCount(Stone.White) == 0)) {// 解がひとつ見つかれば終了。その手順を返す。return current.GetMoves();}foreach (var pos in current.PutablePlaces(current.Turn)) {var next = new OthBoard(current);next.Put(next.Turn, pos);// 試した手の状態はキューに入れるqueu.Enqueue(next);}}// 見つからなかったreturn new Move[0];}
幅優先探索で調べる
最初はどこに打っても同じなので、ひとつに固定。
*int p = board.ToIndex(3, 4);
キューの先頭からノード currentNode を取り出す
*current = queu.Dequeue();
解がひとつ見つかれば終了。その手順を返す。
*return current.GetMoves();
試した手の状態はキューに入れる
*queu.Enqueue(next);
見つからなかった
*return new Move[0];
*namespace CooperatedOthello {public class Stone {public static readonly Stone Black = new Stone { Value = 'X' };public static readonly Stone White = new Stone { Value = 'O' };public static readonly Stone Empty = new Stone { Value = '.' };public char Value { get; set; }}public class Move {public int Place { get; set; }public Stone Stone { get; set; }public Move(Stone stone, int place) {Stone = stone;Place = place;}}public class OthBoard : BoardBase<;Stone>; {// 現在の手番の事。public Stone Turn { get; set; }// これまでの棋譜private List<;Move>; Moves = new List<;Move>;();// コンストラクタpublic OthBoard(): base(8, 8) {Turn = Stone.Black;Initialize();}// コンストラクタ （Cloneと同じ用途)public OthBoard(OthBoard board): base(board) {Turn = board.Turn;Moves = board.Moves.ToList();}// 初期化public void Initialize() {foreach (var p in GetAllIndexes())this[p] = Stone.Empty;this[ToIndex(4, 4)] = Stone.White;this[ToIndex(5, 5)] = Stone.White;this[ToIndex(4, 5)] = Stone.Black;this[ToIndex(5, 4)] = Stone.Black;}// 相手の石public Stone Opponent(Stone stone) {return stone == Stone.White ? Stone.Black : Stone.White;}// 石の数をカウントpublic int StoneCount(Stone stone) {return this.GetAllIndexes().Count(p =>; this[p] == stone);}// ８つの方向を列挙 （このBoardは、番兵用に一回り大きなサイズとなっている）public IEnumerable<;int>; Directions() {//return new int[] { -OuterWidth-1, -OuterWidth, -OuterWidth+1, 1, OuterWidth + 1, OuterWidth, OuterWidth-1, -1 };return new int[] {ToDirection(-1, -1),ToDirection( 0, -1),ToDirection(+1, -1),ToDirection(+1,  0),ToDirection(+1, +1),ToDirection( 0, +1),ToDirection(-1, +1),ToDirection(-1,  0),};}// 置ける場所を列挙するpublic IEnumerable<;int>; PutablePlaces(Stone stone) {return this.GetVacantIndexes().Where(index =>; CanPut(stone, index));}private IEnumerable<;int>; GetVacantIndexes() {return this.GetAllIndexes().Where(p =>; this[p] == Stone.Empty);}// 石を置けるかpublic bool CanPut(Stone stone, int place) {if (this[place] != Stone.Empty)return false;return Directions().Any(d =>; CanReverse(stone, place, d));}// direction方向の石をひっくり返せるかpublic bool CanReverse(Stone stone, int place, int direction) {Stone opponent = Opponent(stone);int np = place + direction;while (this[np] == opponent)np += direction;return (this[np] == stone &amp;&amp; np != place + direction);}// direction方向にstoneと同じ色の石があるかpublic bool FindStone(Stone stone, int place, int direction) {Stone opponent = Opponent(stone);int np = place + direction;while (this[np] == opponent)np += direction;return (this[np] == stone);}// direction方向の石をひっくり返えすpublic void Reverse(Stone stone, int place, int direction) {if (!FindStone(stone, place, direction))return;Stone opponent = Opponent(stone);int np = (int)(place + direction);while (this[np] == opponent) {this[np] = stone;np += direction;}}// stoneをplace位置に置く (必ず置けることを前提としている）public void Put(Stone stone, int place) {this[place] = stone;Stone opponent = Opponent(stone);foreach (int direction in Directions()) {Reverse(stone, place, direction);}Moves.Add(new Move(stone, place));// 通常は相手の番になるが、相手が置ける場所が無い場合は、連続して打てるif (PutablePlaces(Turn).Any())Turn = opponent;elseTurn = stone;}// 現時点での手順を返す。public IEnumerable<;Move>; GetMoves() {return Moves;}public void Print() {Console.Clear();for (int y = 1; y <;= YSize; y++) {for (int x = 1; x <;= XSize; x++) {Console.Write("{0} ", this[x, y].Value);}Console.WriteLine("");}Console.WriteLine();}}}
Boardから継承し、特有の機能を追加
*public Stone Turn { get; set; }
現在の手番の事。
これまでの棋譜
*private List<;Move>; Moves = new List<;Move>;();
*: base(8, 8) {Turn = Stone.Black;Initialize();}
コンストラクタ
*: base(board) {Turn = board.Turn;Moves = board.Moves.ToList();}
コンストラクタ （Cloneと同じ用途)
*public void Initialize() {foreach (var p in GetAllIndexes())this[p] = Stone.Empty;this[ToIndex(4, 4)] = Stone.White;this[ToIndex(5, 5)] = Stone.White;this[ToIndex(4, 5)] = Stone.Black;this[ToIndex(5, 4)] = Stone.Black;}
初期化
*public Stone Opponent(Stone stone) {return stone == Stone.White ? Stone.Black : Stone.White;}
相手の石
*public int StoneCount(Stone stone) {return this.GetAllIndexes().Count(p =>; this[p] == stone);}
石の数をカウント
*public IEnumerable<;int>; Directions() {//return new int[] { -OuterWidth-1, -OuterWidth, -OuterWidth+1, 1, OuterWidth + 1, OuterWidth, OuterWidth-1, -1 };return new int[] {ToDirection(-1, -1),ToDirection( 0, -1),ToDirection(+1, -1),ToDirection(+1,  0),ToDirection(+1, +1),ToDirection( 0, +1),ToDirection(-1, +1),ToDirection(-1,  0),};}
８つの方向を列挙 （このBoardは、番兵用に一回り大きなサイズとなっている）
*return new int[] {ToDirection(-1, -1),ToDirection( 0, -1),ToDirection(+1, -1),ToDirection(+1,  0),ToDirection(+1, +1),ToDirection( 0, +1),ToDirection(-1, +1),ToDirection(-1,  0),};
return new int[] { -OuterWidth-1, -OuterWidth, -OuterWidth+1, 1, OuterWidth + 1, OuterWidth, OuterWidth-1, -1 };
*public IEnumerable<;int>; PutablePlaces(Stone stone) {return this.GetVacantIndexes().Where(index =>; CanPut(stone, index));}
置ける場所を列挙する
*public bool CanPut(Stone stone, int place) {if (this[place] != Stone.Empty)return false;return Directions().Any(d =>; CanReverse(stone, place, d));}
石を置けるか
*public bool CanReverse(Stone stone, int place, int direction) {Stone opponent = Opponent(stone);int np = place + direction;while (this[np] == opponent)np += direction;return (this[np] == stone &amp;&amp; np != place + direction);}
direction方向の石をひっくり返せるか
*public bool FindStone(Stone stone, int place, int direction) {Stone opponent = Opponent(stone);int np = place + direction;while (this[np] == opponent)np += direction;return (this[np] == stone);}
direction方向にstoneと同じ色の石があるか
*public void Reverse(Stone stone, int place, int direction) {if (!FindStone(stone, place, direction))return;Stone opponent = Opponent(stone);int np = (int)(place + direction);while (this[np] == opponent) {this[np] = stone;np += direction;}}
direction方向の石をひっくり返えす
*public void Put(Stone stone, int place) {this[place] = stone;Stone opponent = Opponent(stone);foreach (int direction in Directions()) {Reverse(stone, place, direction);}Moves.Add(new Move(stone, place));// 通常は相手の番になるが、相手が置ける場所が無い場合は、連続して打てるif (PutablePlaces(Turn).Any())Turn = opponent;elseTurn = stone;}
stoneをplace位置に置く (必ず置けることを前提としている）
*if (PutablePlaces(Turn).Any())*Turn = opponent;
通常は相手の番になるが、相手が置ける場所が無い場合は、連続して打てる
*public IEnumerable<;Move>; GetMoves() {return Moves;}
現時点での手順を返す。

*{if (Input.GetKey (KeyCode.RightArrow))rigid.AddForce (Vector2.right * 3.0f);else if (Input.GetKey (KeyCode.LeftArrow))rigid.AddForce (Vector2.left * 3.0f);elserigid.velocity = new Vector2 (0.0f,rigid.velocity.y);}
テスト用に書いた移動処理なので参考にしないほうが良い
*{//最大の段階のジャンプを超えてたらジャンプしないif (jumpCount >;= maxJumpSteps)return;//ジャンプの力を加えるrigid.AddForce (Vector2.up * 5.0f, ForceMode2D.Impulse);//ジャンプの段階を１段階あげるjumpCount++;}
ジャンプ処理
*if (jumpCount >;= maxJumpSteps)*return;
最大の段階のジャンプを超えてたらジャンプしない
ジャンプの力を加える
*rigid.AddForce (Vector2.up * 5.0f, ForceMode2D.Impulse);
ジャンプの段階を１段階あげる
*jumpCount++;
*foreach (var contact in other.contacts)*{
自分があるオブジェクトと接触しているポイントを一つづつ調べる
*Vector2 dir = contact.point - (Vector2)transform.position;*//接触しているゲームオブジェクトの下向きのベクトル
自分から接触ポイントへのベクトル
*Vector2 contactObjectDown = -contact.collider.gameObject.transform.up;*//接触しているオブジェクトの下向きのベクトルと自身から接触しているポイントへのベクトルの
接触しているゲームオブジェクトの下向きのベクトル
接触しているオブジェクトの下向きのベクトルと自身から接触しているポイントへのベクトルの
角度が１０度未満であった場合にジャンプの段階数のリセットする
*if (Vector2.Angle (contactObjectDown, dir) <; 10.0f)
*if (jumpCount >;= maxJumpSteps)*return;
最大の段階のジャンプを超えてたらジャンプしない
ジャンプの力を加える
*rigid.AddForce (Vector2.up * 5.0f, ForceMode2D.Impulse);
ジャンプの段階を１段階あげる
*jumpCount++;
*foreach (var contact in other.contacts)*{
自分があるオブジェクトと接触しているポイントを一つづつ調べる
*Vector2 dir = contact.point - (Vector2)transform.position;*//接触しているゲームオブジェクトの下向きのベクトル
自分から接触ポイントへのベクトル
*Vector2 contactObjectDown = -contact.collider.gameObject.transform.up;*//接触しているオブジェクトの下向きのベクトルと自身から接触しているポイントへのベクトルの
接触しているゲームオブジェクトの下向きのベクトル
接触しているオブジェクトの下向きのベクトルと自身から接触しているポイントへのベクトルの
角度が１０度未満であった場合にジャンプの段階数のリセットする
*if (Vector2.Angle (contactObjectDown, dir) <; 10.0f)

API とサービスの認証情報でサービスアカウントを作成し、
ダウンロードしたアクセスキーファイルのパスを環境変数で指定
*Environment.SetEnvironmentVariable(
ここでfirestoreにデータ追加
*db.Collection("testxml").AddAsync(TestXml).Wait();
*public XElement TestXmlXElement { get; private set; }
XElementはマッピングでエラーになるので登録しない
登録したい名前をつけれる
なにもない場合はそのまま
*[FirestoreProperty("test_xml_string")]
*public Child Child =>; new Child() { XmlChild = TestXmlXElement.Element("Child") };
クラスもできる

*abstract class AFoodFactory { }
割愛

サーバーがダウンしていてもここでは例外は発生しません。
*}
ストリームライターをラップ
*IClientStreamWriter<;TRequest>; streamWriter = CreateClientStreamWriter(call.RequestStream, context);
Callオブジェクトのメソッドをラップ
*Task<;TResponse>; getResponse = InterceptGetResponse(call.ResponseAsync, context);
ラッパーを内包したCallオブジェクトを返す
*return new AsyncClientStreamingCall<;TRequest, TResponse>;(
例外が発生したときの処理
*}
例外が発生したときの処理
*}
例外が発生したときの処理
*}

*continue;
breakだと終了
*{static void Main(){for (int i = 1; i <;= 10; i++){if (i <; 9){continue;}Console.WriteLine(i);}// Keep the console open in debug mode.Console.WriteLine("Press any key to exit.");Console.ReadKey();}}
②i&lt;=10まで続けるがif(i&lt;9)までcontinueなので結果9と10のみ
*for (int i = 0; i <; 10; i++) {*if (i % 2 == 0) {
③余りが0(割り切れる)数値だけcontinueなので結果1 3 5 7 9(割り切れない)
*while (true)*{
while(true)if {(条件)continue/break} elseif... で∞ループ
処理
*}
具体例
*int count = 0;
*{int i = 0;do {i++;MessageBox.Show (i.ToString ());} while (i <;= 3);}
while do

初期設定（チェックマークをつけておきます）
フォームデザイナでプロパティ指定してもよいです。
*ToolStripMenuItemViewFontSizeMedium.CheckState = CheckState.Indeterminate;
選択されたメニュー項目
*var thisItem = clickedItem as System.Windows.Forms.ToolStripMenuItem;
その親項目
*var containerItem = thisItem.GetCurrentParent();
(Linqを使った例）
その子項目をToolStripMenuItem型のみ（つまりセパレータなどは除外して）列挙を行い
選択された項目であればIntermediate、それ以外はUncheckedを、CheckStateプロパティに設定します。
2018-10-20 All()使用でリソース消費を抑えています - albireoさんのコメントより
*containerItem.Items.OfType<;System.Windows.Forms.ToolStripMenuItem>;()
もとはこちら
containerItem.Items.OfType&lt;System.Windows.Forms.ToolStripMenuItem&gt;().ToList()
.ForEach(f =&gt; f.CheckState = (f == thisItem) ? CheckState.Indeterminate : CheckState.Unchecked);
*}

Linqを使うから忘れないように.
*using System.Linq;
個人名とその人の読書数の辞書があったとする.reading_booksとしておく.
これで値の小さい順のソートができる.xはラムダ式で,適当な変数である.
*var hoge = reading_books.OrderBy((x) =>; x.Value);
同様に,大きい順でのソート.
*var hogehoge = reading_books.OrderByDescending((x) =>; x.Value);
*foreach(var tekito in hoge)*{
実際の列挙(小さい順)
*foreach(var tekito in hogehoge)*{
実際の列挙(大きい順)

*wRange = string.Format("{0}!A{1}:B{1}", sheetName, rowNumber);
行を追加

gRPC で接続するときの接続文字列
var settings = EventStoreClientSettings.Create(@"esdb:127.0.0.1:2113?tls=true");
ルート証明書を明示的に設定する（自己証明書の場合のみ？）
これを設定しない場合、gRPC のエラー "failed to connect to all addresses." が発生した
*settings.ChannelCredentials = new SslCredentials(File.ReadAllText(@".\Certs\TestCA.crt"));
TODO: コマンドの型からイベントタイプとストリーム名を特定できるようにするのが望ましい
*return WriteCommandAsync("sampleEvent", "sampleStream", command);
*{foreach (var obj in commands){yield return new EventData(Uuid.NewUuid(), eventType, m_Serializer.Serialize(obj));}}
コマンドを格納したイベントデータを列挙するメソッド
頻繁に書き込みを行うアプリケーションの場合、クライアントの生成と破棄を繰り返さないほうがよいと思われる
*await using EventStoreClient client = CreateEventStoreClient();
次の読み込み位置を指定する
*return ReadCommandsAsync<;TCommand>;(streamName, GetNextStreamPosition(streamName));
頻繁に書き込みを行うアプリケーションの場合、クライアントの生成と破棄を繰り返さないほうがよいと思われる
*await using var client = CreateEventStoreClient();
最後に読み込んだ位置を格納する
*LastStreamPosition[streamName] = stream.Current.Event.EventNumber;
最後の読み込み位置を指定する
*return ReadAllCommandsAsync(GetLastTransactionPosition());
頻繁に書き込みを行うアプリケーションの場合、クライアントの生成と破棄を繰り返さないほうがよいと思われる
*await using EventStoreClient client = CreateEventStoreClient();
*if (lastPosition.CommitPosition >;= result.Event.Position.CommitPosition)*{
TODO: 最後に読み込んだときの位置と同じ場合はスキップする。位置が不変であるのか調査が必要。
*if (TryGetCommand(@event, out IEventCommand cmd))*{
イベントからコマンドを取得して列挙する
最後に読み込んだ位置を格納する
*LastTransactionPosition = result.Event.Position;
*if (@event.Event.EventType == "sampleEvent")*{
TODO: イベントタイプからコマンドの型を特定できるようにすることが望ましい
*if (@event.Event.EventType == "sampleEvent")*{
TODO: イベントタイプからコマンドの型を特定できるようにすることが望ましい
購読の状態を管理するオブジェクト
*private StreamSubscriptionState m_SubcribeSampleCommandState;
*{System.Diagnostics.Debug.WriteLine($"onReceiveCommandAsync: {command}");return Task.CompletedTask;}
コマンドを受け取ったときの処理
購読をキャンセルするためのトークン
*CancellationTokenSource cancellation = new CancellationTokenSource();
*{// イベントからコマンドを取得する// SubscribeToStreamAsync メソッドの引数にはイベントタイプがない// 購読対象でない型のコマンドである可能性があるif (TryGetCommand(@event, out TCommand cmd)){await onReceiveAsync(cmd).ConfigureAwait(false);}}
イベントを受け取ったときの処理
イベントからコマンドを取得する
SubscribeToStreamAsync メソッドの引数にはイベントタイプがない
購読対象でない型のコマンドである可能性がある
*if (TryGetCommand(@event, out TCommand cmd))
購読に関連するオブジェクトをまとめた状態オブジェクトを返す
*return new StreamSubscriptionState(client, subscription, cancellation);
購読の状態を管理するオブジェクト
*private StreamSubscriptionState m_SubcribeAllCommandState;
*{System.Diagnostics.Debug.WriteLine($"onReceiveAllCommandAsync: {command}");return Task.CompletedTask;}
コマンドを受け取ったときの処理
購読をキャンセルするためのトークン
*CancellationTokenSource cancellation = new CancellationTokenSource();
*{// TODO: 最後に読み込んだときの位置と同じ場合はスキップする。位置が不変であるのか調査が必要。if (lastPosition.CommitPosition >;= @event.Event.Position.CommitPosition){return;}// イベントからコマンドを取得するif (TryGetCommand(@event, out IEventCommand cmd)){await onReceiveAsync(cmd).ConfigureAwait(false);}}
イベントを受け取ったときの処理
*if (lastPosition.CommitPosition >;= @event.Event.Position.CommitPosition)*{
TODO: 最後に読み込んだときの位置と同じ場合はスキップする。位置が不変であるのか調査が必要。
*if (TryGetCommand(@event, out IEventCommand cmd))*{
イベントからコマンドを取得する
購読に関連するオブジェクトをまとめた状態オブジェクトを返す
*return new StreamSubscriptionState(client, subscription, cancellation);

*return NullSample.Instance;
何にも該当しない場合もNullを返すとややこしくなるのでNullObjectパターンを作っておくと優しい。

foreach:一時変数
*sw.Start();
*foreach (var item in list.Select((v, i) =>; new { v, i }))
foreach
foreach:一時変数
*sw.Start();
*foreach (var item in list2.Select((value, index) =>; new { value, index }))
foreach

HTTPリクエストを作成する
*HttpWebRequest req = PathUtil.getHttpWebRequest(uploadURL, true, new NetworkCredential("ユーザーID", "パスワード"));

*req.AllowWriteStreamBuffering = false;
デフォルト値はtrueだが、1GB近いサイズのファイルをアップロードした時の処理遅延対策としてfalseに変更する。

*public (string hashedPassword, byte[] salt) HashPassword(string rawPassword) {byte[] salt = GetSalt();string hashed = HashPassword(rawPassword, salt);return (hashed, salt);}
ハッシュ化...平文パスワードを渡すとハッシュ化パスワード、使用されたソルトが返る
*public bool VerifyPassword(string hashedPassword, string rawPassword, byte[] salt) =>;*hashedPassword == HashPassword(rawPassword, salt);
認証...ハッシュ化パスワード、平文パスワード・ソルトを渡すと正しいパスワードなら true が返る
平文パスワード
*var rawPassword = "nossa1234";
テスト対象のクラス
var sut = new PasswordService();   sut means System Under Test
パスワードをハッシュ化、使用したソルトを得る
*var (hashed, salt) = sut.HashPassword(rawPassword);
*Assert.True(sut.VerifyPassword(hashed, rawPassword, salt));*}
「ハッシュ」と「パスワード・ソルトから作成したハッシュ」が一致するかテスト
*public IActionResult RegisterUser([FromBody]RegisterUserRequest request) {bool success = userService.Register(request.UserName, request.RawPassword);return success ? Ok() : (IActionResult)Conflict();}
UsersController の登録処理の抜粋
*public IActionResult Authenticate([FromBody]AuthenticateRequest request) {bool ok = userService.Authenticate(request.UserName, request.RawPassword);return ok ? Ok() : (IActionResult)Unauthorized();}
LoginController の認証の抜粋
*public bool Register(string username, string rawPassword) {bool duplicated = dbContext.Users.Any(u =>; u.Name == username);if (duplicated) {return false;}(string hashed, byte[] salt) = passwordService.HashPassword(rawPassword);var user = new User {Name = username,HashedPassword = hashed,Salt = salt};dbContext.Users.Add(user);dbContext.SaveChanges();return true;}
ユーザー登録
*public bool Authenticate(string username, string rawPassword) {var user = dbContext.Users.SingleOrDefault(u =>; u.Name == username);if (user is null) {return false;}return passwordService.VerifyPassword(user.HashedPassword, rawPassword, user.Salt);}
認証

*Assert.AreEqual("FFC0", Extensions.ToHexString(new byte[] { 255, 192 });
大文字の 16 進文字列を返す？
*Assert.AreEqual("ffc0", Extensions.ToHexString(new byte[] { 255, 192 });
小文字の 16 進文字列を返す？
*Assert.AreEqual("FFC0", Extensions.ToHexString(new byte[] { 255, 192 }, toLower: false);
大文字の 16 進文字列を返す
*Assert.AreEqual("ffc0", Extensions.ToHexString(new byte[] { 255, 192 }, toLower: true);
小文字の 16 進文字列を返す
*var source = new byte[] { 255, 192 };
準備
実施
*var actual = Extensions.ToHexString(source, toLower);
検証
*Assert.AreEqual(expected, actual);
こういうのは読む量が増えるし、似ているコードは何が違うのかに
注意を払いながら読む必要があるのでかなり気を遣う。
（結局同じだったりする）
*public void バイト配列を大文字の１６進文字列に変換() {
*var message = $"No.{item.testNumber}";
実施
*if (actualException == null) {*Assert.AreEqual(item.expected, actual, message);
検証
*(int testNumber, byte[] source, bool toLower, string expected, Type expectedExceptionType)[] TestCases() =>; new[] {(1, new byte[] { 255, 192 }, false        , "FFC0", (Type)null),(2, new byte[] { 255, 192 }, true         , "ffc0", (Type)null),(3, null                   , default(bool), null  , (Type)typeof(ArgumentNullException)),};
テストケース一覧。

デザイナで初期設定してもOK
*this.MaximizeBox = false;
コントロールの表示状態を強制：初回は非表示にする
*base.SetVisibleCore(_initialized &amp;&amp; value);
フォームを閉じる操作をされた
base.OnClosing(e);
*this.Visible = false;
終了ボタン押下
*Application.Exit();
タスクトレイ（通知領域）のアイコンダブルクリック
*SetFormLocation();
*{var wa = Screen.PrimaryScreen.WorkingArea;if (0 <; wa.Left){//  タスクバーは左this.Location = new System.Drawing.Point(wa.Left, wa.Bottom - this.Height);}else if (0 <; wa.Top){//  タスクバーは上this.Location = new System.Drawing.Point(wa.Right - this.Width, wa.Top);}else{//  タスクバーは右か下this.Location = new System.Drawing.Point(wa.Right - this.Width, wa.Bottom - this.Height);}}
ここが今回のキモ！！
タスクバーは左
*this.Location = new System.Drawing.Point(wa.Left, wa.Bottom - this.Height);
タスクバーは上
*this.Location = new System.Drawing.Point(wa.Right - this.Width, wa.Top);
タスクバーは右か下
*this.Location = new System.Drawing.Point(wa.Right - this.Width, wa.Bottom - this.Height);

デフォルトイベント発生時に手動でデータソースを更新
(DataSourceUpdateMode.OnPropertyChanged だと、TextBox.TextChanged イベント後にデータソースが更新されるため)
*var defaultEvent = control.GetType().GetDefaultEvent();

*RaisePropertyChanged(nameof(ReadOnly));
読み取りのみプロパティ通知用
ReadOnly = "Changed from VM";コンパイルエラー
*ReadAndWrite_RP.Value = "Changed from VM";
ReadOnly_RP.Value = "Changed from VM";コンパイルエラー
*}

@Zuishinさんに教えていただいた方法
*string fileCount;

*using (var swTextC = new StreamWriter($@"{documentFolderPath}\c.txt"))
こちらは案1と同じで重ねただけ。

例外処理
*}

*if (soundPlayerObj == null)*{
Debug.Log("changeBGM : " + bgmName);
すでに再生中なら変えない
*return;

コマンドライン引数があるとき
*path = args[0];
コマンドライン引数がないとき
*path = Environment.GetFolderPath(Environment.SpecialFolder.MyMusic);
*.mp3に一致するファイルの取得
*string[] files = Directory.GetFiles(path, "*.mp3", SearchOption.AllDirectories);
*foreach (string file in files)*{
ファイルパスの出力

*Console.WriteLine(result);
False
&lt;&lt;=第2オペランドの値分左にシフトし、第1オペランドに格納
\&gt;&gt;= 第2オペランドの値分右にシフトし、第1オペランドに格納
int a = 5;         二進数の 0000000000000101 (5)
int b = a &lt;&lt; 3;    二進数の 0000000000101000（左に3，十進数の40)
int c = b &gt;&gt; 3;    二進数の 0000000000000101 (右に3，最初の値に戻った)
int b = a &lt;&lt; 14;   二進数の 0100000000000000 (左に14，1が捨てられた)
*,,,

*{public double A { get; set; }public double B { get; set; }public double Solve(double x) =>; this.A * x + this.B;}
y = Ax + B
*{public double A { get; set; }public double B { get; set; }public double Solve(double x) =>; Math.Exp(this.A * x) * this.B;public static ExponentialEquation Approximate(Coordinate[] data){var pt = data.Select(item =>; new Coordinate(item.X, Math.Log(item.Y)));var eq = LinearEquation.Approximate(pt.ToArray());return new ExponentialEquation() { A = eq.A, B = Math.Exp(eq.B) };}}
y = B･exp(Ax)

*bool result = signer.VerifySignature(plain, sign[0], sign[1]);
④
*Console.WriteLine(string.Join("", signature.Select(b =>; $"{b:x02}")));
署名
*bool result = Verify(clearText, signature, @"..\..\secp256k1.privatekey");*Console.WriteLine($"verify: {result}");
検証
鍵を読み込む
*AsymmetricCipherKeyPair pair = null;
署名インスタンスを生成＆署名
*var signer = new ECDsaSigner();
署名の値をbyte[]にしておく
*var sign1 = sign[0].ToByteArray().SkipWhile(b =>; b == 0x00).Reverse();
鍵を読み込む
*AsymmetricCipherKeyPair pair = null;
*if ((sign1[0] &amp; 0x80) == 0x80) sign1 = new byte[] { 0x00 }.Concat(sign1).ToArray();
署名の値をBigIntegerに変換する
検証する
*var signer = new ECDsaSigner();

VRMファイルのパスを指定します
*var path = "C:\\VRM\\AliciaSolid.vrm";
ファイルをByte配列に読み込みます
*var bytes = File.ReadAllBytes(path);
VRMImporterContextがVRMを読み込む機能を提供します
*var context = new VRMImporterContext();
GLB形式でJSONを取得しParseします
*context.ParseGlb(bytes);
VRMのメタデータを取得
var meta = context.ReadMeta(false); 引数をTrueに変えるとサムネイルも読み込みます
読み込めたかどうかログにモデル名を出力してみる
*Debug.LogFormat("meta: title:{0}", meta.Title);
同期処理で読み込みます
*context.Load();
読込が完了するとcontext.RootにモデルのGameObjectが入っています
*var root = context.Root;
*root.transform.SetParent(transform, false);*//メッシュを表示します
モデルをワールド上に配置します
メッシュを表示します
*context.ShowMeshes();
VRMファイルのパスを指定します
*var path = "C:\\VRM\\AliciaSolid.vrm";
ファイルをByte配列に読み込みます
*var bytes = File.ReadAllBytes(path);
VRMImporterContextがVRMを読み込む機能を提供します
*var context = new VRMImporterContext();
GLB形式でJSONを取得しParseします
*context.ParseGlb(bytes);
VRMのメタデータを取得
var meta = context.ReadMeta(false); 引数をTrueに変えるとサムネイルも読み込みます
読み込めたかどうかログにモデル名を出力してみる
*Debug.LogFormat("meta: title:{0}", meta.Title);
非同期処理で読み込みます
*context.LoadAsync(_ =>; OnLoaded(context));
読込が完了するとcontext.RootにモデルのGameObjectが入っています
*var root = context.Root;
*root.transform.SetParent(transform, false);*//メッシュを表示します
モデルをワールド上に配置します
メッシュを表示します
*context.ShowMeshes();
VRMファイルのパスを指定します
*var path = "C:\\VRM\\AliciaSolid.vrm";
ファイルをByte配列に読み込みます
*var bytes = File.ReadAllBytes(path);
VRMImporterContextがVRMを読み込む機能を提供します
*var context = new VRMImporterContext();
GLB形式でJSONを取得しParseします
*context.ParseGlb(bytes);
VRMのメタデータを取得
var meta = context.ReadMeta(false); 引数をTrueに変えるとサムネイルも読み込みます
読み込めたかどうかログにモデル名を出力してみる
*Debug.LogFormat("meta: title:{0}", meta.Title);
非同期処理(Task)で読み込みます
*await context.LoadAsyncTask();
読込が完了するとcontext.RootにモデルのGameObjectが入っています
*var root = context.Root;
*root.transform.SetParent(transform, false);*//メッシュを表示します
モデルをワールド上に配置します
メッシュを表示します
*context.ShowMeshes();
*{byte[] result;using (FileStream SourceStream = File.Open(path, FileMode.Open)){result = new byte[SourceStream.Length];await SourceStream.ReadAsync(result, 0, (int)SourceStream.Length);}return result;}
Byte列を得る
VRMのメタデータを取得
var meta = context.ReadMeta(false); 引数をTrueに変えるとサムネイルも読み込みます
読み込めたかどうかログにモデル名を出力してみる
*Debug.LogFormat("meta: title:{0}", meta.Title);
*root.transform.SetParent(transform, false);*//メッシュを表示します
モデルをワールド上に配置します
メッシュを表示します
*context.ShowMeshes();

*{One,Two,Three,Four,Five,Six,Seven,Eight,Nine,Ten}
Switch
*{{ Number.One,    1 },{ Number.Two,    2 },{ Number.Three,  3 },{ Number.Four,   4 },{ Number.Five,   5 },{ Number.Six,    6 },{ Number.Seven,  7 },{ Number.Eight,  8 },{ Number.Nine,   9 },{ Number.Ten,   10 }};
Dictionary
*{public bool Equals(Number x, Number y){return x == y;}public int GetHashCode(Number obj){return (int)obj;}}
Dictionary with EqualityComparer

*yield return new Syntax(@"
\*[\s\S]*?\*|.*", this.CommentColor);
テキスト変更フラグ (テキスト変更時に ON、ハイライト後に OFF)
*var textChanged = true;
キャレット位置を保持
*var start = this.richTextBox.SelectionStart;
ハイライト
*using (var highlighter = new SqlHighlighter())
キャレット位置を復元
*this.richTextBox.Select(start, length);

*return ope.GetString();
Operatorをstringに変換する拡張メソッド（詳細は省略）
*{//（略）}
文字列から演算子への変換
（略）
*}

*{p.TodoList.RemoveAt(id - 1);if (p.Conform() == true){Console.WriteLine("Please Write id to delete");int i = int.Parse(Console.ReadLine());this.Delete(id, p, this);}else{p.ModeSelect(0, p, this);}}
モードセレクトのクラスを作るしかない。それで、最後に確認をやって確認がTrueなら
"C:\test\1.txt"をShift-JISコードとして開く
*System.IO.StreamReader sr = new System.IO.StreamReader(
内容を一行ずつ読み込む
*var AccessToken = sr.ReadLine();
閉じる
*sr.Close();
ファイルを上書きし、utf-8で書き込む
*System.IO.StreamWriter sw = new System.IO.StreamWriter(
txtの内容を1行ずつ書き込む
*sw.WriteLine(tokens.AccessToken);
閉じる
*sw.Close();
キャンセル要求出す
*cancellationToken.Cancel();
タスクがキャンセルされるまで待機
*task.Wait();
タスクがキャンセルされるとここが実行される
*Console.WriteLine("Task is cancelled.");
ファイルを上書きし、Shift JISで書き込む
*System.IO.StreamWriter sw = new System.IO.StreamWriter(
*foreach (string line in p.TodoList)*{
TextBox1.Textの内容を1行ずつ書き込む
閉じる
*sw.Close();
"C:\test\1.txt"をShift-JISコードとして開く
*System.IO.StreamReader sr = new System.IO.StreamReader(
*while (sr.Peek() >; -1)*{
内容を一行ずつ読み込む
閉じる
*sr.Close();
"C:\test\1.txt"をShift-JISコードとして開く
*System.IO.StreamReader sr = new System.IO.StreamReader(
内容を一行ずつ読み込む
*var AccessToken = sr.ReadLine();
閉じる
*sr.Close();
ファイルを上書きし、Shift JISで書き込む
*System.IO.StreamWriter sw = new System.IO.StreamWriter(
TextBox1.Textの内容を1行ずつ書き込む
*sw.WriteLine(tokens.AccessToken);
閉じる
*sw.Close();
キャンセル要求出す
*cancellationToken.Cancel();
タスクがキャンセルされるまで待機
*task.Wait();
タスクがキャンセルされるとここが実行される
*Console.WriteLine("Task is cancelled.");
キャンセル要求出す
*cancellationToken.Cancel();
タスクがキャンセルされるまで待機
*task.Wait();
タスクがキャンセルされるとここが実行される
*Console.WriteLine("Task is cancelled.");

Exception にはエラーになった行を特定する情報は含まれていない。
*}
エラーになった行の DataRow とインデックスを取得する。
*var errorRow = copy.GetLastDataRow();

処理
*}
処理
*}
処理
*}
処理
*}
処理
*}
処理
*}
処理
*}

*{// SampleWindow : WPF のViewType winType = typeof(SampleWindow);// Windowのインスタンスを取得Window win = GetWindowInstance(winType);// Windowを表示させますwin.Show();win.Title = "サンプル";win.Activate();win.WindowState = WindowState.Normal;}
ボタンをクリックで呼び出すコード
SampleWindow : WPF のView
*Type winType = typeof(SampleWindow);
Windowのインスタンスを取得
*Window win = GetWindowInstance(winType);
Windowを表示させます
*win.Show();
*{// Windowsを取得Window win;win =System.Windows.Application.Current.Windows.OfType<;Window>;().SingleOrDefault(w =>; w.GetType() == winType);// まだ表示されていない場合はインスタンスを生成するif (win == null){win = (Window)Activator.CreateInstance(winType, _regionManager);}return win;}
Windowのインスタンス取得処理
Windowsを取得
*Window win;
*if (win == null)*{
まだ表示されていない場合はインスタンスを生成する

カーネルIdの取得
*kernelInitialize = computeShader.FindKernel("Initialize");
波の高さを格納するテクスチャの作成
*waveTexture = new RenderTexture(256, 256, 0, RenderTextureFormat.RG32);
レンダリング用のテクスチャの作成
*drawTexture = new RenderTexture(256, 256, 0, RenderTextureFormat.ARGB32);
スレッド数の取得
*uint threadSizeX, threadSizeY, threadSizeZ;
波の高さの初期化
*computeShader.SetTexture(kernelInitialize, "waveTexture", waveTexture);
波の追加
*this.computeShader.SetFloat("time", Time.time);
波の高さの更新
*this.computeShader.SetFloat("deltaSize", deltaSize);
波の高さをもとにレンダリング用のテクスチャを作成
*this.computeShader.SetTexture(kernelDraw, "waveTexture", waveTexture);

*Transform RightThumbProximal = chara.GetBoneTransform(HumanBodyBones.RightThumbProximal);*RightThumbProximal.localRotation = Quaternion.Euler(ThumbR/2, 0, 0);
右手親指------------------------------------------------------------------------------------
*Transform RightIndexProximal = chara.GetBoneTransform(HumanBodyBones.RightIndexProximal);*RightIndexProximal.localRotation = Quaternion.Euler(0,0,IndexR/2);
人差し指------------------------------------------------------------------------------------
以降は人差し指と同じ要領で小指まで
*}
右手
親指------------------------------------------------------------------------------------
*Transform RightThumbProximal = chara.GetBoneTransform(HumanBodyBones.RightThumbProximal);
*Transform RightIndexProximal = chara.GetBoneTransform(HumanBodyBones.RightIndexProximal);*RightIndexProximal.localRotation = Quaternion.Euler(IndexR / 800, -IndexR / 800, IndexR/2);
人差し指------------------------------------------------------------------------------------
*Transform RightMiddleProximal = chara.GetBoneTransform(HumanBodyBones.RightMiddleProximal);*RightMiddleProximal.localRotation = Quaternion.Euler(0, 0, MiddleR / 2);
中指------------------------------------------------------------------------------------
*Transform RightRingProximal = chara.GetBoneTransform(HumanBodyBones.RightRingProximal);*RightRingProximal.localRotation = Quaternion.Euler(-RingR / 800, RingR / 800, RingR / 2);
薬指------------------------------------------------------------------------------------
*Transform RightLittleProximal = chara.GetBoneTransform(HumanBodyBones.RightLittleProximal);*RightLittleProximal.localRotation = Quaternion.Euler(-LittleR / 400, LittleR / 400, LittleR / 2);
小指------------------------------------------------------------------------------------

何かしらの DB処理
*}
省略
*}

List&lt;Fruits&gt; fruitsの現在行を管理
*currencyManager1 = (CurrencyManager)this.BindingContext[_food.fruits];
dataSourceObjectにSystem.Windows.Forms.BindingSource（binds[]）を指定
*textBoxName1.DataBindings.Add("Text", binds[0], "Name");
dataSourceObjectにList（food.fruits[]）を指定
*textBoxName2.DataBindings.Add("Text", _food.fruits[1], "Name");
dataSourceObjectにインデクサ（food[]）を指定
*textBoxName3.DataBindings.Add("Text", _food[2], "Name");

*myAdminGetUserDetailByIds.HostName = "cybz.com";
インストールしたサーバーのホスト名
リクエストデータの生成
*AdminGetUserDetailByIdsRequestType adminGetUserDetailByIdsRequest = new AdminGetUserDetailByIdsRequestType();
自作AdminAPIクラスにリクエストデータを設定
*myAdminGetUserDetailByIds.AdminGetUserDetailByIdsRequest = adminGetUserDetailByIdsRequest;
AdminAPIの実行
*myAdminGetUserDetailByIds.soapSendReceive();
レスポンスデータの取得
*List<;UserDetail>; userDetailList = myAdminGetUserDetailByIds.AdminGetUserDetailByIdsResponse.userDetail.ToList();
*foreach (string userId in userIdsList)*{
ユーザーのログイン名のみを抽出

*RuleFor(x =>; x.Surname).NotNull().DependentRules(() =>; {RuleFor(x =>; x.Forename).NotNull();});
姓が入力されている場合に、名が入力されているか検証する。

*public OutArgument<;String<; result { get; set; }
戻り値はstring

*result.Set(context, text + " Hello world.");
追記

コンソールアプリケーションからAsyncを呼び出す大元はTaskを使用する
*Task task = MainAsync();
終了を待つ
*task.Wait();
*{await xxxxxxxxAsync();}
AsyncなMain。ここでは非同期処理をawaitを使って同期的処理のように扱うことができる
コンソールアプリケーションからAsyncを呼び出す大本はTaskを使用する;
*return MainAsync().Result;
*{await xxxxxxxxAsync();return 0;}
AsyncなMain

*dict[args.BluetoothAddress] = args.Advertisement.LocalName;
こうでないと重複例外が出る

*public static string ToErrorMessage<;TErrorCode<;(this Response<;TErrorCode<; response) {
← this が追加されました
*}else{
特別処理

*Console.WriteLine($"Osako = {y}");
Osako = 4

*new CardImage("http:
adaptivecards.iocontentcats2.png"),

*{Name = System.IO.Path.GetFileName(filePath),};
アップロード済みのファイルを更新するにはAPIを切り替える必要がある
更新
*var request = service.Files.Update(meta, file.Id, stream, GetMimeType(filePath));
*meta.Parents = new List<;string>; { _Configuration.DriveDirectoryId };
新規追加

DBからUSERを取得したとする
*var user = Service.FindUserByName(name);
*{UserId = user.USER_ID;UserName = user.USER_NAME;Tel = user.TEL;Mail = user.MAIL;}
USER -&gt; UserViewModel
DBからUSERを取得したとする
*var user = Service.FindUserByName(name);
*{UserId = user.USER_ID;UserName = user.USER_NAME;Tel = user.TEL;Mail = user.MAIL;}
USER -&gt; UserViewModel
DBからUSER一覧を取得したとする
*var users = Service.FindUsers();
*{UserId = user.USER_ID;UserName = user.USER_NAME;Tel = user.TEL;Mail = user.MAIL;};
USER -&gt; UserViewModel
DBからUSERを取得したとする
*var user = Service.FindUserByName(name);
*{UserId = user.USER_ID;UserName = user.USER_NAME;Tel = user.TEL;// 追加Fax = user.FAX;Mail = user.MAIL;}
USER -&gt; UserViewModel
追加
*Fax = user.FAX;
DBからUSER一覧を取得したとする
*var users = Service.FindUsers();
*{UserId = user.USER_ID;UserName = user.USER_NAME;Tel = user.TEL;// 追加Fax = user.FAX;Mail = user.MAIL;};
USER -&gt; UserViewModel
追加
*Fax = user.FAX;
DBからUSERを取得したとする
*var user = Service.FindUserByName(name);
DBからUSER一覧を取得したとする
*var users = Service.FindUsers();

*public IEnumerator NewEditModeTestWithEnumeratorPasses() {// Use the Assert class to test conditions.// yield to skip a frameyield return null;}
and allows you to yield null to skip a frame in EditMode

ファイルリストの取得
*string [] files = GetStreamingAssetFiles("sample", "*.png");
*for (int i = 0; i <; files.Length; i++)*{
リスト一覧

*private string convertBackString;
入力文字列
*{try{if (!(value is double)) return null;string format = (parameter as string) ?? string.Empty;if (!string.IsNullOrEmpty(convertBackString)){//フォーマットを「整数部」と「小数部」に分けるvar formatParts = format.Split('.');if (formatParts.Length >;= 2){//入力文字列が小数点で終わっていたら、「整数部」＋「小数点そのもの」をフォーマットにするif (convertBackString.EndsWith(culture.NumberFormat.NumberDecimalSeparator)){format = formatParts[0] + @"\" + culture.NumberFormat.NumberDecimalSeparator;}else{var pos = convertBackString.IndexOf(culture.NumberFormat.NumberDecimalSeparator);if (pos >;= 0){//入力文字列に小数部があれば、「整数部」＋「ピリオド」＋「入力文字列の小数の桁数分の０」をフォーマットにするvar digitLength = convertBackString.Length - pos - 1;format = formatParts[0] + @"."+ new string('0', digitLength)+ formatParts[1].Substring(Math.Min(digitLength, formatParts[1].Length));}}}}return ((double)value).ToString(format);}finally{convertBackString = null;}}
doubleから文字列への変換（表示時に使われる）
*var formatParts = format.Split('.');*if (formatParts.Length >;= 2)
フォーマットを「整数部」と「小数部」に分ける
*if (convertBackString.EndsWith(culture.NumberFormat.NumberDecimalSeparator))*{
入力文字列が小数点で終わっていたら、「整数部」＋「小数点そのもの」をフォーマットにする
入力文字列に小数部があれば、「整数部」＋「ピリオド」＋「入力文字列の小数の桁数分の０」をフォーマットにする
*var digitLength = convertBackString.Length - pos - 1;
*{//入力文字列を保存するconvertBackString = value as string;if (!string.IsNullOrEmpty(convertBackString)&amp;&amp; double.TryParse(convertBackString, out double newValue)){//入力文字列をパーズして戻すreturn newValue;}else{return null;}}
文字列からdoubleへの変換（入力時に使われる）
入力文字列を保存する
*convertBackString = value as string;
入力文字列をパーズして戻す
*return newValue;

*Max
MAX に相当
*public int Number { get; }
カードに書かれた数字
*public _Card(int number) { }
number: カードに書かれた数字
*{// プレイヤーがドローするカード列public IEnumerable<;_Card>; DeckCards { get; }// ソート済みの全カードpublic IEnumerable<;_Card>; SortedCards { get; }// allNumber  : 全カードの数字列// deckNumbers: プレイヤーがドローするカードの数字列public _Deck(IEnumerable<;int>; allNumbers, IEnumerable<;int>; deckNumbers) { }}
カードのデッキ
*public IEnumerable<;_Card>; DeckCards { get; }
プレイヤーがドローするカード列
*public IEnumerable<;_Card>; SortedCards { get; }
ソート済みの全カード
*public _Deck(IEnumerable<;int>; allNumbers, IEnumerable<;int>; deckNumbers) { }
allNumber  : 全カードの数字列
*public _Deck(IEnumerable<;int>; allNumbers, IEnumerable<;int>; deckNumbers) { }
deckNumbers: プレイヤーがドローするカードの数字列
*public string Name { get; }
プレイヤーの名前
*private _Inference _Inference { get; }
推論に関する情報
name: プレイヤーの名前
visibleCards: 他プレイヤーのカード
allCards    : 全カード
order       : 手番の順序
*public _Player(string name, IEnumerable<;_VisibleCard>; visibleCards, IEnumerable<;_Card>; allCards, _PlayerOrder order) { }
*public PlayerAnswer SayAnswer(int orderIndex) { }
答えを宣言する
*public PlayerAnswer SayAnswer(int orderIndex) { }
orderIndex: _PlayerOrder上における現在の順番
*{// カードを所持するプレイヤーの名前public string PlayerName { get; }// 見えているカードpublic _Card Card { get; }// playerName: カードを所持するプレイヤーの名前// card: 見えているカードpublic _VisibleCard(string playerName, _Card card) { }}
見えているカード
*public string PlayerName { get; }
カードを所持するプレイヤーの名前
*public _Card Card { get; }
見えているカード
*public _VisibleCard(string playerName, _Card card) { }
playerName: カードを所持するプレイヤーの名前
*public _VisibleCard(string playerName, _Card card) { }
card: 見えているカード
*{// 推論対象のプレイヤーの名前private string _PlayerName { get; }// プレイヤーに見えているカード列private IEnumerable<;_VisibleCard>; _VisibleCards { get; }// 全カード列private IEnumerable<;_Card>; _AllCards { get; }// 手番の順序private _PlayerOrder _Order { get; }// _Inferメソッドのメモprivate Dictionary<;_MemoKey, PlayerAnswer>; _Memo { get; }// playerName  : 推論対象のプレイヤーの名前// visibleCards: プレイヤーに見えているカード列// allCards    : 全カード列// order       : 手番の順序public _Inference(string playerName, IEnumerable<;_VisibleCard>; visibleCards, IEnumerable<;_Card>; allCards, _PlayerOrder order) { }// 現在の順番に基づき、答えを導出する// orderIndex: _PlayerOrder上における現在の順番// return    : 答えpublic PlayerAnswer Infer(int orderIndex) { }}
推論に関する情報
*private string _PlayerName { get; }
推論対象のプレイヤーの名前
*private IEnumerable<;_VisibleCard>; _VisibleCards { get; }
プレイヤーに見えているカード列
*private IEnumerable<;_Card>; _AllCards { get; }
全カード列
*private _PlayerOrder _Order { get; }
手番の順序
*private Dictionary<;_MemoKey, PlayerAnswer>; _Memo { get; }
_Inferメソッドのメモ
playerName  : 推論対象のプレイヤーの名前
visibleCards: プレイヤーに見えているカード列
allCards    : 全カード列
order       : 手番の順序
*public _Inference(string playerName, IEnumerable<;_VisibleCard>; visibleCards, IEnumerable<;_Card>; allCards, _PlayerOrder order) { }
現在の順番に基づき、答えを導出する
orderIndex: _PlayerOrder上における現在の順番
return    : 答え
*public PlayerAnswer Infer(int orderIndex) { }
*{// 全プレイヤーの名前列private IEnumerable<;string>; _PlayerNames { get; }// playerNames: 全プレイヤーの名前列public _PlayerOrder(IEnumerable<;string>; playerNames) { }// 手番の順序を生成する// return: 順序付けられたプレイヤーの名前列public IEnumerable<;string>; GetPlayerNames() { }}
手番の順序
*private IEnumerable<;string>; _PlayerNames { get; }
全プレイヤーの名前列
*public _PlayerOrder(IEnumerable<;string>; playerNames) { }
playerNames: 全プレイヤーの名前列
*public IEnumerable<;string>; GetPlayerNames() { }
手番の順序を生成する
*public IEnumerable<;string>; GetPlayerNames() { }
return: 順序付けられたプレイヤーの名前列
現在の順番に基づき、答えを導出する
orderIndex: _PlayerOrder上における現在の順番
return    : 答え
*public PlayerAnswer Infer(int orderIndex)
答えを導出する
targetPlayerName: 推論対象のプレイヤーの名前
visibleCards    : プレイヤーに見えているカード列
orderIndex      : _PlayerOrder上における現在の順番
return          : 答え
*public PlayerAnswer _Infer(string targetPlayerName, IEnumerable<;_VisibleCard>; visibleCards, int limit)
*if (_Memo.ContainsKey(memoKey))*{
メモより取得
自分のカードである可能性のあるカード列（あとで削除するためリストにする）
*var possibleCardList = _AllCards.Except(visibleCards.Select(x =>; x.Card))
*if (index >;= 1)*{
前の手番が存在するなら
*foreach (var p in possibleCardList.ToArray())*{
possibleCardListのクローンでループ
*var candidates = visibleCards.Concat(new[] { new _VisibleCard(targetPlayerName, p) })
前の手番を仮定する
仮定を元に答えを導出する
*var inferred = _Infer(prevPlayerName, candidates, prevIndex);
*if (inferred.Value != AnswerValue.Unknown)*{
答えの食い違い

VRMLipSync用フィールド変数
*public float[] VRMLipValue = new float[15];

*xmlns:x="http:
schemas.microsoft.comwinfx2006xaml"

ここはcreateInstanceで生成するインスタンスによって処理が変わる。
*instance.Method();
*{void Func();}
本当は名前が不適切なことはわかっているが、継承と比較するためにこうした

*public class MainActivity : global::Xamarin.Forms.Platform.Android.FormsAppCompatActivity
global::~が

事前処理でQueueには何か入ってる
*var hoge1 = new hoge();
まとめて突っ込みたいコレクションが出来てしまった。
*hoge[] array = hogehoge();
forでなくQueueに1行で突っ込む
重複を除きたいならUnion 今回のケースでは冗長だった・・・。
queue = new Queue&lt;hoge&gt;(queue.ToArray().Union(array));
重複を許容するならConcat↓
*queue = new Queue<;hoge>;(queue.ToArray().Concat(array));

カメラの設定
*private GameObject Object;
カメラ範囲の設定
*public float maxCamSize = 9.0f;
直前の指同士の距離
*private float lastDist = 0.0f;
指同士の中心座標
*private Vector2 centerPos;
一本指タッチしたワールド座標
*private Vector2 lastTouchWorld;
直前の触れている指の数
*private int lastCount = 0;
スピード調整
*public float zoomSpeed = 1.0f;
*float sizeDiff;*//カメラが画面外を映さないように処理
カメラサイズの差分
*{if (cam.transform.position.x >; maxCamX - cam.orthographicSize * 9 / 16){cam.transform.position = new Vector3(maxCamX - cam.orthographicSize * 9 / 16, cam.transform.position.y, cam.transform.position.z);}if (cam.transform.position.x <; minCamX + cam.orthographicSize * 9 / 16){cam.transform.position = new Vector3(minCamX + cam.orthographicSize * 9 / 16, cam.transform.position.y, cam.transform.position.z);}if (cam.transform.position.y >; maxCamY - cam.orthographicSize){cam.transform.position = new Vector3(cam.transform.position.x, maxCamY - cam.orthographicSize, cam.transform.position.z);}if (cam.transform.position.y <; minCamY + cam.orthographicSize){cam.transform.position = new Vector3(cam.transform.position.x, minCamY + cam.orthographicSize, cam.transform.position.z);}}
カメラが画面外を映さないように処理
カメラを設定
*Object = GameObject.Find("Main Camera");
*if (Input.touchCount == 0)*{
タッチが0
*else if (Input.touchCount == 1 &amp;&amp; lastCount <;= 1)*{
スワイプ操作（直前のtouchCountを1以下にすることでピンチ操作後に反応しないようにしています。）
タッチ位置取得
*Touch touch3 = Input.GetTouch(0);
*if (touch3.phase == TouchPhase.Began)*{
触れたとき
*else if (touch3.phase == TouchPhase.Moved)*{
動いたら
前回の座標を保存
*nowTouchWorld = lastTouchWorld;
今の座標を保存
*t = touch3.position;
*cam.transform.position = new Vector3(cam.transform.position.x + (lastTouchWorld.x - nowTouchWorld.x) * moveSpeed, cam.transform.position.y + (lastTouchWorld.y - nowTouchWorld.y) * moveSpeed, cam.transform.position.z);*CameraSlide();
カメラを移動
*else if (Input.touchCount >;= 2)*{
ピンチ操作
タッチ位置取得
*Touch touch1 = Input.GetTouch(0);
*if (touch2.phase == TouchPhase.Began)*{
二本目が触れたとき
指同士の距離と中心座標を取得
*lastDist = Vector2.Distance(touch1.position, touch2.position);
*else if (touch1.phase == TouchPhase.Moved || touch2.phase == TouchPhase.Moved)*{
どちらかの指が動いたら
指同士の距離を計算
*float newDist = Vector2.Distance(touch1.position, touch2.position);
*sizeDiff = cam.orthographicSize * cam.orthographicSize * (newDist - lastDist) / 10000.0f * zoomSpeed;*cam.orthographicSize -= sizeDiff;
ズーム処理
*if (cam.orthographicSize >; maxCamSize)*{
カメラが拡大（縮小）しすぎた場合の制限
*{cam.transform.position = new Vector3(centerPos.x + cam.orthographicSize / (cam.orthographicSize + sizeDiff) * (cam.transform.position.x - centerPos.x), centerPos.y + cam.orthographicSize / (cam.orthographicSize + sizeDiff) * (cam.transform.position.y - centerPos.y), cam.transform.position.z);}
指同士の中心位置がピンチ操作の中心となるようにカメラを平行移動

これはダメらしくnullになる
string Version = typeof(Application).Assembly.GetCustomAttribute&lt;AssemblyVersionAttribute&gt;()?.Version;
こうする
*string Version = typeof(Application).Assembly.GetName().Version.ToString();

*public static float score = 0;
スコア
*if(OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger)){*score += 100;
コントローラーのトリガーを押したらスコアが加算される
ログ出力
*Debug.Log("Score: "+ Game.getScore());

*response = await client.PostAsync("https:
api.cmtelecom.comv1.0otpverify", content);

ダイアログのタイトル
*[SerializeField] private Text _title;
ダイアログの説明文
*[SerializeField] private Text _description;
OKボタン
*[SerializeField] public Button _okButton;
NGボタン
*[SerializeField] public Button _ngButton;
ダイアログ終了時イベント
*public UnityAction onDestroyed;
ダイアログのまわりの灰色の背景.触られたときにダイアログを消す
*[SerializeField] private Image _background;
ダイアログのprefab名
*private static readonly string PREFAB_NAME = "DialogCanvasPrefab";
一応prefabをキャッシュしておく.
*private static GameObject prefab;
title:ダイアログのタイトル
description:ダイアログの説明文
ok:OKボタンの文言
ng:NGボタンの文言
デフォルト引数により,OKボタンとNGボタンの文言を入力しなければ両ボタンは表示されない.入力すれば表示される
*public static DialogHandler ShowDialog(
static変数に置くべきか,毎回読み込むべきか.
ベストプラクティスがよくわからない.
*prefab = Resources.Load(PREFAB_NAME) as GameObject;
prefabをInstantiateして,そのインスタンスからこのDialogHandlerを取得する.
*var instance = Instantiate(prefab);
タイトルと説明文を設定.
*handler._title.text = title;
okの文言がなかったらOKボタンを消す.
しっかり参照も消す.
*Destroy(handler._okButton.gameObject);
okの文言があったらボタンにセット.
クリックされたらダイアログを消す.
*handler._okButton.GetComponentInChildren<;Text>;().text = ok;
*if (string.IsNullOrEmpty(ng))*{
ngもokといっしょ.
imageをクリックされたときにアクションを行う.
スクリプトで付与.
この場合はダイアログ以外の場所を押されたらダイアログを消す.
*var eventTrigger = _background.gameObject.AddComponent<;EventTrigger>;();
ダイアログ終了イベント.
*onDestroyed?.Invoke();

*if (time <;= 1)
currentTime &gt;= lifeTimes[i].Value + deathTime

*static readonly AbstractSkill[] skills = {new LightningSkill(),new HealSkill()};
スキル一覧
*{return skills.SingleOrDefault(skill =>; skill.SkillKind == skillKind);}
SkillKindを引数に、それに応じたスキルを返す
*public abstract SkillFactory.SkillKind SkillKind { get; }
スキル種別の抽象プロパティ
スキル実行の抽象メソッド
*public abstract void Play();
*{get {return SkillFactory.SkillKind.Lightning;}}
スキル種別
*public override void Play() {Debug.Log("Lightning!");}
スキル「ライトニング」の実行
*{get {return SkillFactory.SkillKind.Heal;}}
スキル種別
選択中のスキル
*private SkillFactory.SkillKind selectedSkillKind;

*while (step <; 1) {
stepが1になるまで繰り返す。
*for (int x = 0; x <; _xSize; x++) {*for (int y = 0; y ; _ySize; y++) {
mapをプリント
*public void DebugPrint() {for (int x = 0; x <; _xSize; x++) {for (int y = 0; y <; _ySize; y++) {string s = (_map[x, y] <;= -2)? "***": (_map[x, y] == -1)? "   ": string.Format("{0,2} ", _map[x, y]);Console.Write(s);}Console.WriteLine();}Console.WriteLine();}
迷路をConsoleに表示する [Debug用]

*using NCMB;
追記
GameManagerのサンプル（https:qiita.com/azumagoro/items/d2b1a4e59ae8f48996c3）
Save,Loadメソッドを呼ぶのに必要
*[SerializeField]GameManager _GameManager;
最前面で画面全体を覆う RaycastBlock = true なImageコンポーネントを持つGameObject
*[SerializeField]GameObject ButtonDownStopper;
パスとファイル名
*string path;
Timestamp用, 別途TimeUtilクラスを設けてそっちに書いても可
*private static DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, 0);
*{return (long)(dateTime - UnixEpoch).TotalSeconds;}
DateTimeからUnixTimeへ変換
SaveDataクラス（http:magnaga.com/unity/2016/04/25/unity-save2/）で書き込むpathと同じにする
*path = Application.persistentDataPath + "/";
*{Debug.Log("UploadSaveData");//ログインチェック,ログインの処理は別途用意しておく//参考)オートログイン:https://qiita.com/azumagoro/items/2a82b55422354ac7cee8if (NCMBUser.CurrentUser == null){Debug.Log("ログインしてません");return;}//UI操作の制御ButtonDownStopper.SetActive(true);//JSONファイルを読んでstring,byteへstring str = "";if (File.Exists(path + fileName)){using (StreamReader sr= new StreamReader(path + fileName, Encoding.GetEncoding("utf-8"))){str = sr.ReadToEnd();}}byte[] data = System.Text.Encoding.UTF8.GetBytes(str);//ファイル名重複を避けるためユーザーID+Timestampでファイル名を固有にするstring NCMBFileName= "SaveData-"+ SaveData.GetString("NCMB_UserName")+ "-" + GetUnixTime(DateTime.Now);//セーブ用NCMBFileを作成NCMBFile file = new NCMBFile(NCMBFileName, data);//ファイルストアにセーブfile.SaveAsync((NCMBException error) =>;{if (error != null){Debug.Log("ファイルのアップロードに失敗しました");//UI操作制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("ファイルのアップロードに成功しました");//セーブ用クラスにレコードを追加AddRecord(NCMBFileName);}});}
セーブデータファイルをサーバーにアップロード
ログインチェック,ログインの処理は別途用意しておく
参考)オートログイン:https:qiita.com/azumagoro/items/2a82b55422354ac7cee8
*if (NCMBUser.CurrentUser == null)
UI操作の制御
*ButtonDownStopper.SetActive(true);
JSONファイルを読んでstring,byteへ
*string str = "";
ファイル名重複を避けるためユーザーID+Timestampでファイル名を固有にする
*string NCMBFileName
セーブ用NCMBFileを作成
*NCMBFile file = new NCMBFile(NCMBFileName, data);
*{if (error != null){Debug.Log("ファイルのアップロードに失敗しました");//UI操作制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("ファイルのアップロードに成功しました");//セーブ用クラスにレコードを追加AddRecord(NCMBFileName);}});
ファイルストアにセーブ
UI操作制御を解除
*ButtonDownStopper.SetActive(false);
セーブ用クラスにレコードを追加
*AddRecord(NCMBFileName);
*{NCMBObject obj = new NCMBObject("BackupSaveData");//フィールドに値を設定,NCMB_UserNameは会員登録時に予め設定して、セーブ済みobj.Add("userName", SaveData.GetString("NCMB_UserName"));obj.Add("fileName", filename);obj.Save((NCMBException e) =>;{if (e != null){Debug.Log("セーブ用クラスのレコード追加に失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("セーブ用クラスのレコード追加に成功しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}});}
userID-fileName の紐づけ情報を管理するNCMBクラスにレコードを追加する処理
フィールドに値を設定,NCMB_UserNameは会員登録時に予め設定して、セーブ済み
*obj.Add("userName", SaveData.GetString("NCMB_UserName"));
UI操作の制御を解除
*ButtonDownStopper.SetActive(false);
UI操作の制御を解除
*ButtonDownStopper.SetActive(false);
*{Debug.Log("LoadSaveData");//ログインチェック,ログインの処理は別途用意しておくif (NCMBUser.CurrentUser == null){Debug.Log("ログインしてません");return;}//UI操作の制御ButtonDownStopper.SetActive(true);//Queryを作成NCMBQuery<;NCMBObject>; query = new NCMBQuery<;NCMBObject>;("BackupSaveData");//設定追加：ユーザー名で抽出query.WhereEqualTo("userName", SaveData.GetString("NCMB_UserName", ""));//設定追加：作成日時・降順でソートquery.OrderByDescending("createDate");//検索結果を取得,検索結果はobjListに格納されるquery.FindAsync((List<;NCMBObject>; objList, NCMBException e) =>;{if (e != null){//検索失敗時の処理Debug.Log("データのダウンロードに失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("データのダウンロードに成功しました");//最新のファイルを読み込むLoadSaveFile(objList[0]["fileName"].ToString());//レコード数が2以下になるまで古いデータから順に削除for (int i = objList.Count - 1; i >; 1; i--){NCMBObject objDelete = new NCMBObject("BackupSaveData");//ObjectIdを指定して削除してるけど、objList[i].DeleteAsyncでOKかもobjDelete.ObjectId = objList[i].ObjectId;objDelete.DeleteAsync((NCMBException error) =>;{if (e != null){Debug.Log("古いレコードの削除に失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("古いレコードの削除に成功しました");}});}//ファイル数が2以下になるまで古いデータから順に削除for (int i = objList.Count - 1; i >; 1; i--){NCMBFile file = new NCMBFile(objList[i]["fileName"].ToString());file.DeleteAsync((NCMBException error) =>;{if (error != null){Debug.Log("古いファイルの削除に失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("古いファイルの削除に成功しました");}});}}});}
ファイル名を取得, ファイルを取得, 読み込む
*if (NCMBUser.CurrentUser == null)*{
ログインチェック,ログインの処理は別途用意しておく
UI操作の制御
*ButtonDownStopper.SetActive(true);
Queryを作成
*NCMBQuery<;NCMBObject>; query = new NCMBQuery<;NCMBObject>;("BackupSaveData");
設定追加：ユーザー名で抽出
*query.WhereEqualTo("userName", SaveData.GetString("NCMB_UserName", ""));
設定追加：作成日時・降順でソート
*query.OrderByDescending("createDate");
*{if (e != null){//検索失敗時の処理Debug.Log("データのダウンロードに失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("データのダウンロードに成功しました");//最新のファイルを読み込むLoadSaveFile(objList[0]["fileName"].ToString());//レコード数が2以下になるまで古いデータから順に削除for (int i = objList.Count - 1; i >; 1; i--){NCMBObject objDelete = new NCMBObject("BackupSaveData");//ObjectIdを指定して削除してるけど、objList[i].DeleteAsyncでOKかもobjDelete.ObjectId = objList[i].ObjectId;objDelete.DeleteAsync((NCMBException error) =>;{if (e != null){Debug.Log("古いレコードの削除に失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("古いレコードの削除に成功しました");}});}//ファイル数が2以下になるまで古いデータから順に削除for (int i = objList.Count - 1; i >; 1; i--){NCMBFile file = new NCMBFile(objList[i]["fileName"].ToString());file.DeleteAsync((NCMBException error) =>;{if (error != null){Debug.Log("古いファイルの削除に失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("古いファイルの削除に成功しました");}});}}});
検索結果を取得,検索結果はobjListに格納される
検索失敗時の処理
*Debug.Log("データのダウンロードに失敗しました");
UI操作の制御を解除
*ButtonDownStopper.SetActive(false);
最新のファイルを読み込む
*LoadSaveFile(objList[0]["fileName"].ToString());
*for (int i = objList.Count - 1; i >; 1; i--)*{
レコード数が2以下になるまで古いデータから順に削除
ObjectIdを指定して削除してるけど、objList[i].DeleteAsyncでOKかも
*objDelete.ObjectId = objList[i].ObjectId;
UI操作の制御を解除
*ButtonDownStopper.SetActive(false);
*for (int i = objList.Count - 1; i >; 1; i--)*{
ファイル数が2以下になるまで古いデータから順に削除
UI操作の制御を解除
*ButtonDownStopper.SetActive(false);
*{NCMBFile file = new NCMBFile(Name);file.FetchAsync((byte[] fileData, NCMBException error) =>;{if (error != null){Debug.Log("ファイルの取得に失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("ファイルの取得に成功しました");SaveBytesTo(fileData);//ロードと初期化LoadAndInit();//UI操作の制御を解除ButtonDownStopper.SetActive(false);//UIに成功メッセージを表示する}});}
SaveDataファイルを取得
UI操作の制御を解除
*ButtonDownStopper.SetActive(false);
ロードと初期化
*LoadAndInit();
UI操作の制御を解除
*ButtonDownStopper.SetActive(false);
UIに成功メッセージを表示する
*}
*{Debug.Log("SaveBytesTo");//UTF8 エンコードでbyteからstringへstring text = System.Text.Encoding.UTF8.GetString(b);Debug.Log("SaveBytesTo:" + text);//上書きStreamWriter writer = new StreamWriter(path + fileName, false, Encoding.GetEncoding("utf-8"));writer.WriteLine(text);writer.Close();}
Byteデータをsavedata.jsonに書き込む
UTF8 エンコードでbyteからstringへ
*string text = System.Text.Encoding.UTF8.GetString(b);
上書き
*StreamWriter writer = new StreamWriter(path + fileName, false, Encoding.GetEncoding("utf-8"));
*{Debug.Log("LoadAndInit");//ファイルの読み込みSaveData.UpdateSaveData();//ゲームデータのLoadgameManager.Load();//復元ペナルティがあればここに書いてSave()する}
ファイルからデータを読み込む
ファイルの読み込み
*SaveData.UpdateSaveData();
ゲームデータのLoad
*gameManager.Load();
復元ペナルティがあればここに書いてSave()する
*}

*var response = client.PostAsync("https:
gw.cmtelecom.comv1.0message", content).GetAwaiter().GetResult();

プレイヤーの情報
*public Player player = new Player();
手持ちキャラクターの情報
*public List<;Character>; ownCharacters = new List<;Character>;();
バトルの情報
*public Battle battle = new Battle();
フラグ情報
*public GameFlags gameFlags = new GameFlags();
マスタデータ
*[SerializeField] private MasterData _MasterData;
*void Awake(){//GameManager.instanceでの取得用の初期化instance = this;//SceneをまたいでもGameObjectを残すためDontDestroyOnLoad(gameObject);//開発用にEditorでは毎回初期化する,念を入れてDebug.isDebugBuildもif条件に。#if UNITY_EDITORif (Debug.isDebugBuild){SaveData.Clear();}#endif//ロード処理Load();}
こうしておくとGameManager.instanceでGetComponentせずに取得できる
GameManager.instanceでの取得用の初期化
*instance = this;
SceneをまたいでもGameObjectを残すため
*DontDestroyOnLoad(gameObject);
*#if UNITY_EDITOR*if (Debug.isDebugBuild)
開発用にEditorでは毎回初期化する,念を入れてDebug.isDebugBuildもif条件に。
ロード処理
*Load();
セーブデータの設定
*SaveData.SetClass("player", player);
セーブ
*SaveData.Save();
ロード
*player = SaveData.GetClass("player", new Player());
*for (int i = 0; i <; ownCharacters.Count; i++)*{
IDを元にMasterDataからScriptableObjectを取得し直す
キャラクターデータ
*var ch = ownCharacters[i];
覚えているスキル
*ch.skills.Clear();
キャラクター固有の情報 CharacterDataはScriptableObjectを継承
*public CharacterData data;
覚えているスキル SkillBaseはScriptableObjectを継承
*public List<;SkillBase>; skills = new List<;SkillBase>;();

*string category = "C#";
=&gt; 検索条件として渡されたと仮定

*private double? prevValue;
前回表示した値
*{try{if (!(value is double)) return null;double newValue = (double)value;try{if (!string.IsNullOrEmpty(convertBackString)&amp;&amp; prevValue.HasValue &amp;&amp; (prevValue == newValue)){//入力文字列があり、前回表示した値と同じ値を表示するなら、入力文字列をそのまま戻すreturn convertBackString;}else{//そうでなければ、値をdouble型で戻す//→StringFormatを使ってフォーマットされるreturn newValue;}}finally{prevValue = newValue;}}finally{convertBackString = null;}}
doubleから文字列への変換（表示時に使われる）
入力文字列があり、前回表示した値と同じ値を表示するなら、入力文字列をそのまま戻す
*return convertBackString;
そうでなければ、値をdouble型で戻す
→StringFormatを使ってフォーマットされる
*return newValue;
*{//入力文字列を保存するconvertBackString = value as string;if (!string.IsNullOrEmpty(convertBackString)&amp;&amp; double.TryParse(convertBackString, out double newValue)){//入力文字列をパーズして戻すreturn newValue;}else{return null;}}
文字列からdoubleへの変換（入力時に使われる）
入力文字列を保存する
*convertBackString = value as string;
入力文字列をパーズして戻す
*return newValue;

*else {
次の回答者がいなかったらおしまい。
*static string ToAlphabet(int number) {string alphabet = "";do {alphabet = Convert.ToChar(number % 26 + 0x41) + alphabet;} while((number=number/26-1) != -1);return alphabet;}
数字をアルファベットに変換！
*class Player {private Card _card;public Card card {get { return this._card; }}private string _name;public string name {get { return this._name; }}public Player(string name) {this._name = name;}//カードを一枚引いて額にかざすpublic void Draw(List<;Card>; cards) {Random random = new Random(Environment.TickCount);int index = random.Next(cards.Count);this._card = cards[index];cards.RemoveAt(index);}//MAX, MID, MIN, ?public string Answer(List<;Player>; players) {//ここがこの問題の肝となるアルゴリズムです！//是非チャレンジしてみてくださいね！return "?";}}
現実世界のカードは自分から動かないのでメソッドを持たない！
*public void Draw(List<;Card>; cards) {Random random = new Random(Environment.TickCount);int index = random.Next(cards.Count);this._card = cards[index];cards.RemoveAt(index);}
カードを一枚引いて額にかざす
*public string Answer(List<;Player>; players) {//ここがこの問題の肝となるアルゴリズムです！//是非チャレンジしてみてくださいね！return "?";}
MAX, MID, MIN, ?
ここがこの問題の肝となるアルゴリズムです！
是非チャレンジしてみてくださいね！
*return "?";

*_animator.SetBool("Idle", false);
&lt;- 追加

*{if (_dict.ContainsKey((sender.GetType(), e.PropertyName)))foreach (BindInfo b in _dict[(sender.GetType(), e.PropertyName)])b.SetValue();}
トリガープロパティに値がセットされたとき動作するハンドラー
*{Delegate deleg = expression.Compile();BindInfo bindInfo = new BindInfo(control, memberName, deleg);//コントロールのプロパティに初期値がセットされるbindInfo.SetValue();//PropertyInfoを収集するvar visitor = new ExVisitor();visitor.Visit(expression);//プロパティ変更イベント発生時参照するディクショナリを作るforeach (PropertyInfo info in visitor.Properties.Distinct())_dict.GetWithNew((info.DeclaringType, info.Name)).Add(bindInfo);}
バインド定義を処理
コントロールのプロパティに初期値がセットされる
*bindInfo.SetValue();
PropertyInfoを収集する
*var visitor = new ExVisitor();
*foreach (PropertyInfo info in visitor.Properties.Distinct())*_dict.GetWithNew((info.DeclaringType, info.Name)).Add(bindInfo);
プロパティ変更イベント発生時参照するディクショナリを作る
*{private object _target;private string _memberName;private Delegate _deleg;public BindInfo(object control, string memberName, Delegate deleg){_target = control;_memberName = memberName;_deleg = deleg;}public void SetValue(){PropertyInfo p = _target.GetType().GetProperty(_memberName);p.SetValue(_target, _deleg.DynamicInvoke());}}
バインド情報を持つクラス
Input=Hoge  とコンソール出力される。
*,,,
バインド定義
*_bm = new BindManager();
*{target = value;if (PropertyChanged == null)return;PropertyChangedEventArgs arg = new PropertyChangedEventArgs(caller);PropertyChanged.Invoke(sender, arg);}
プロパティ変更通知

*Console.WriteLine("true!");
以下else if..
GetType(型調べる)
Console.WriteLine(100.GetType());int
Console.WriteLine(5.1.GetType());double
Console.WriteLine(1.7.GetType());double
Console.WriteLine(3.4.GetType());double
MaxValue(範囲調べる)
*Console.WriteLine($"int:{int.MinValue}~{int.MaxValue}");

*private bool disposedValue = false;
重複する呼び出しを検出するには
*if (disposedValue)*{
すでに処理されている場合は何もしない
ここでマネージリソースを解放
*disposedValue = true;

*void Start () {camera = Camera.main;}
Use this for initialization
*void Update () {if (Input.GetMouseButtonDown(0)) {RayCheck();}if (beRay) {MovePoisition();}if (Input.GetMouseButtonUp(0)) {beRay = false;}}
Update is called once per frame

*{Message1,Message2,Message3};
列挙用配列。しかし、この配列の公開はNG
*NGSample.Messages = new [] { "Compile Error!" };
コンパイルエラーになる
実際に値が入れかえられる
*NGSample.Messages[1] = "This message is spoiled.";
*{Message1,Message2,Message3};
列挙用配列
*{get{foreach (var e in _Messages)yield return e;}}
これは外部から変更不可能
*{get{return _Messages.AsEnumerable();}}
注意！外部から変更可能！
コンパイルエラーになる
*OKSample.Messages[1] = "Compile Error!"
NotSupportedExceptionをスローする
*(OKSample.Messages as IList<;string>;)[1] = "Throw an exception";
実行結果は以下の通り。Clear()したのに！
1
2
*,,,
*public static IReadOnlyList<;string>; Messages { get; }
問題なし。IReadOnlyCollection&lt;string&gt;型として公開するのはおすすめしない
*public static string[] MessagesProperty { get; } =
問題のある値の公開。外部から値を変更できてしまう！
*{get{return _Messages.ToArray();}}
バイナリ互換性を保ったまま、値を変更できないように修正。

呼び出し
*Choices awake = new Choices(AwakeWord);
指示
*Choices actions = new Choices();
音声認識が認識処理を終えたときのイベントハンドラを設定する。
*engine.SpeechRecognized += recogEngine_SpeechRecognized;
音声認識が推定処理を終えたときのイベントハンドラを設定する。
*engine.SpeechHypothesized += recogEngine_SpeechHypothesized;
SystemSpeech を利用したディクテーションを行う場合には、
*engine.LoadGrammar(new Grammar(gb));
実行環境の標準の入力を音声認識エンジンの入力とする。
*engine.SetInputToDefaultAudioDevice();
非同期の認識を継続して実行するようにして音声認識を開始する。
*engine.RecognizeAsync(RecognizeMode.Multiple);
処理を分ける
*bool isSilent = SilentWords.Any(x =>; e.Result.Text.Contains(x));

*lArea.Reverse();
出現箇所を後ろから処理

*a = null;
値を設定しないとエラーなる。
a = null;    nullは「非Null許容型であるため、NullをStrictSに変換できません」となる。
*}

*proc.Verb = "RunAs";
管理者として実行する為のおまじない

*long span = 1000 * 10;
= 1ms

*{private string _text = string.Empty;private int[] _suffixArray;//コンストラクタpublic SearchEx(string text){if (string.IsNullOrEmpty(text)) throw new ArgumentNullException(nameof(text));this._text = text;this.CreateSuffixArray();}//(中略)//接尾辞配列作成メソッドprivate void CreateSuffixArray(){//連番配列を作成var suffixArray = Enumerable.Range(0, this._text.Length).ToList();//ソート部分suffixArray.Sort((x, y) =>;{return string.Compare(this._text, x, this._text y, this._text.Length);});this._suffixArray = suffixArray.ToArray();}}
文字列探索クラス
*{if (string.IsNullOrEmpty(text)) throw new ArgumentNullException(nameof(text));this._text = text;this.CreateSuffixArray();}
コンストラクタ
(中略)
接尾辞配列作成メソッド
*private void CreateSuffixArray()
連番配列を作成
*var suffixArray = Enumerable.Range(0, this._text.Length).ToList();
ソート部分
*suffixArray.Sort(
*{//実体化にかなり時間がかかる//var suffixArray = Enumerable.Range(0, this._text.Length.ToList();//配列を作成後、数値を代入するvar suffixArray = new int[text.Length];for (var index = 0; index <; text.Length; index++){suffixArray[index] = index;}(中略)}
接尾語配列生成メソッド
実体化にかなり時間がかかる
var suffixArray = Enumerable.Range(0, this._text.Length.ToList();
配列を作成後、数値を代入する
*var suffixArray = new int[text.Length];
*for (var i= 0;i<;1000;i++)*{
Enumrable.Range.ToList
*for (var i = 0; i <; 1000; i++)*{
Enumrable.Range.ToArray
*for (var i = 0; i <; 1000; i++)*{
配列生成+forループ
Array.Sortに変更。
*Array.Sort(
*{return CultureInfo.CurrentCulture.CompareInfo.Compare(this._text,indexA,(maxLength - indexA),this._text,indexB,(maxLength - indexB),CompareOptions.None);}
文字列比較用メソッド

*date = SystemDate.GetSystemDate()
DateTime.Now()を返すだけのメソッド

本当にやりたかった処理
*}

*// is needed for a given request.*options.CheckConsentNeeded = context =>; true;
This lambda determines whether user consent for non-essential cookies

*{var dialogResult = MessageBox.Show(@"Hello", @"Title", MessageBoxButtons.OKCancel);if(dialogResult == DialogResult.OK){System.Diagnostics.Trace.WriteLine("Ok");}}
using System.Windows.Forms;

*#endregion
) ===== BUNDLE_SIZE_API =====

Channel.Intercept 拡張メソッドは内部で DefaultCallInvoker を生成して返しています。
*CallInvoker callInvoker = new Channel("localhost:50000", ChannelCredentials.Insecure)
ClientStreaming クライアントサイド用
*public virtual AsyncClientStreamingCall<;TRequest, TResponse>; AsyncClientStreamingCall<;TRequest, TResponse>;(
ClientStreaming サーバーサイド用
*public virtual Task<;TResponse>; ClientStreamingServerHandler<;TRequest, TResponse>;(

*{FileName = "schtasks",Arguments = "/create /tn AutoTask /tr \"" + Assembly.GetExecutingAssembly().Location+ "\" /sc onevent /ec Microsoft-Windows-NetworkProfile/Operational /mo "+ "\"*[System[Provider[@Name=\'Microsoft-Windows-NetworkProfile\'] and EventID=10000]]\" /F",CreateNoWindow = true,UseShellExecute = false};
登録されていない場合は登録する

結果を格納するための配列を生成する
*var splitedStr = new string[COL_NUM];
区切り文字を見つけた件数
*var count = 0;
区切り文字の位置を格納する配列
*var posi = new int[COUNT_OF_DELIMITER];
文字列をchar配列でループして、一文字ずつ区切り文字であるか判定
区切り文字であるなら、区切り文字の位置を保存
*for (var i = 0; i <; str.Length; i = i + 1)
Substringで文字列をスプリットしていく
1つ目の引数は、開始位置(0始まり)
2つ目の引数は、文字数
-----------------------------------------------------
※区切り文字を「カンマ」として説明を記載
・1列目のデータは、以下で抽出
開始位置：0
文字数：最初のカンマの位置（最初のカンマの位置＝最初の文字数になる）
*splitedStr[0] = str.Substring(0, posi[0]);
・2列目のデータは、以下で抽出（3列目以降も同じ感じ）
開始位置：最初のカンマの位置 + 1
文字数：次のカンマの位置 - 最初のカンマの位置 - 1
*splitedStr[1] = str.Substring(posi[0] + 1, posi[1] - posi[0] - 1);
・最後のデータは、以下で抽出
開始位置：最後のカンマの位置
文字数：指定なし（最後まで）
*splitedStr[4] = str.Substring(posi[3] + 1);
結果を格納するための配列を生成する
*var splitedStr = new string[COL_NUM];
区切り文字を見つけた件数
*var count = 0;
切り出し開始位置
*var start = 0;
文字列をchar配列でループして、一文字ずつ区切り文字であるか判定
区切り文字であるなら、区切り文字の位置を保存
*for (var i = 0; i <; str.Length; i++)
Substringで文字列をスプリットしていく
*splitedStr[count] = str.Substring(start, i - start);
最後のデータは、以下で抽出
*splitedStr[count + 1] = str.Substring(i + 1);
*var splitTargets = new string[]{"12345,D,555555,115151,EEEEEE"};
スプリットの対象文字
正しくスプリットできているかチェックする
*Console.WriteLine("---------------------------Check---------------------------");
*Console.WriteLine("Loop Count:{0}", LOOP_COUNT);
スプリットの速度計測
*{foreach(var text in splitTargets){var splitedValues = splitFunc(text);foreach(var val in splitedValues){Console.WriteLine("{0}:{1}", name, val);}}}
スプリットの検証用メソッド
速度図るためのカウント
*private const int LOOP_COUNT = 200000;
*{var sw = new System.Diagnostics.Stopwatch();sw.Start();for (int i = 0; i <; LOOP_COUNT; i++){foreach(var text in splitTargets){splitFunc(text);}}sw.Stop();Console.WriteLine("{0}:{1}", name, sw.Elapsed.ToString());}
スプリットの速度計測用メソッド
区切り文字
*private const char DELIMITER = ',';
何個に区切るか
*private const int COL_NUM = 5;
区切り文字の数
*private const int COUNT_OF_DELIMITER = COL_NUM - 1;
*{return str.Split(DELIMITER);}
通常のスプリット
*{//結果を格納するための配列を生成するvar splitedStr = new string[COL_NUM];//区切り文字を見つけた件数var count = 0;//区切り文字の位置を格納する配列var posi = new int[COUNT_OF_DELIMITER];//文字列をchar配列でループして、一文字ずつ区切り文字であるか判定//区切り文字であるなら、区切り文字の位置を保存for (var i = 0; i <; str.Length; i = i + 1){if (str[i] == DELIMITER){posi[count] = i;if (count == COUNT_OF_DELIMITER - 1)break;count = count + 1;}}//-----------------------------------------------------//Substringで文字列をスプリットしていく//1つ目の引数は、開始位置(0始まり)//2つ目の引数は、文字数//-----------------------------------------------------//※区切り文字を「カンマ」として説明を記載//・1列目のデータは、以下で抽出//　開始位置：0//    文字数：最初のカンマの位置（最初のカンマの位置＝最初の文字数になる）splitedStr[0] = str.Substring(0, posi[0]);//・2列目のデータは、以下で抽出（3列目以降も同じ感じ）//　開始位置：最初のカンマの位置 + 1//    文字数：次のカンマの位置 - 最初のカンマの位置 - 1splitedStr[1] = str.Substring(posi[0] + 1, posi[1] - posi[0] - 1);splitedStr[2] = str.Substring(posi[1] + 1, posi[2] - posi[1] - 1);splitedStr[3] = str.Substring(posi[2] + 1, posi[3] - posi[2] - 1);//・最後のデータは、以下で抽出//　開始位置：最後のカンマの位置//    文字数：指定なし（最後まで）splitedStr[4] = str.Substring(posi[3] + 1);return splitedStr;}
お手製スプリット
結果を格納するための配列を生成する
*var splitedStr = new string[COL_NUM];
区切り文字を見つけた件数
*var count = 0;
区切り文字の位置を格納する配列
*var posi = new int[COUNT_OF_DELIMITER];
文字列をchar配列でループして、一文字ずつ区切り文字であるか判定
区切り文字であるなら、区切り文字の位置を保存
*for (var i = 0; i <; str.Length; i = i + 1)
Substringで文字列をスプリットしていく
1つ目の引数は、開始位置(0始まり)
2つ目の引数は、文字数
-----------------------------------------------------
※区切り文字を「カンマ」として説明を記載
・1列目のデータは、以下で抽出
開始位置：0
文字数：最初のカンマの位置（最初のカンマの位置＝最初の文字数になる）
*splitedStr[0] = str.Substring(0, posi[0]);
・2列目のデータは、以下で抽出（3列目以降も同じ感じ）
開始位置：最初のカンマの位置 + 1
文字数：次のカンマの位置 - 最初のカンマの位置 - 1
*splitedStr[1] = str.Substring(posi[0] + 1, posi[1] - posi[0] - 1);
・最後のデータは、以下で抽出
開始位置：最後のカンマの位置
文字数：指定なし（最後まで）
*splitedStr[4] = str.Substring(posi[3] + 1);
結果を格納するための配列を生成する
*var splitedStr = new string[COL_NUM];
区切り文字を見つけた件数
*var count = 0;
切り出し開始位置
*var start = 0;
文字列をchar配列でループして、一文字ずつ区切り文字であるか判定
区切り文字であるなら、区切り文字の位置を保存
*for (var i = 0; i <; str.Length; i++)
Substringで文字列をスプリットしていく
*splitedStr[count] = str.Substring(start, i - start);
最後のデータは、以下で抽出
*splitedStr[count + 1] = str.Substring(i + 1);
*var splitTargets = new string[] { "12345,D,555555,115151,EEEEEE" };
スプリットの対象文字
*Console.WriteLine("Version: {0}", Environment.Version.ToString());
環境
正しくスプリットできているかチェックする
*Console.WriteLine("---------------------------Check---------------------------");
温める
*Console.WriteLine("---------------------------WarmUp--------------------------");
合計のリセット
*ResultDic = new Dictionary<;string, List<;TimeSpan>;>;();
*Console.WriteLine("Loop Count:{0}", LOOP_COUNT);
スプリットの速度計測
*{foreach (var text in splitTargets){var splitedValues = splitFunc(text);foreach (var val in splitedValues){Console.WriteLine("{0}:{1}", name, val);}}}
スプリットの検証用メソッド
速度図るためのカウント
*private const int LOOP_COUNT = 2000000;
*{System.Threading.Thread.Sleep(10);var sw = new System.Diagnostics.Stopwatch();sw.Start();for (int i = 0; i <; LOOP_COUNT; i++){foreach (var text in splitTargets){splitFunc(text);}}sw.Stop();var elapsed = sw.Elapsed;//結果表示Console.WriteLine("{0}:{1}", name, elapsed.ToString());//結果の保存List<;TimeSpan>; results;if (ResultDic.TryGetValue(name, out results) == false){results = new List<;TimeSpan>;();ResultDic.Add(name, results);}results.Add(elapsed);}
スプリットの速度計測用メソッド
*Console.WriteLine("{0}:{1}", name, elapsed.ToString());
結果表示
結果の保存
*List<;TimeSpan>; results;
区切り文字
*private const char DELIMITER = ',';
何個に区切るか
*private const int COL_NUM = 5;
区切り文字の数
*private const int COUNT_OF_DELIMITER = COL_NUM - 1;
*{return str.Split(DELIMITER);}
通常のスプリット
*{//結果を格納するための配列を生成するvar splitedStr = new string[COL_NUM];//区切り文字を見つけた件数var count = 0;//区切り文字の位置を格納する配列var posi = new int[COUNT_OF_DELIMITER];//文字列をchar配列でループして、一文字ずつ区切り文字であるか判定//区切り文字であるなら、区切り文字の位置を保存for (var i = 0; i <; str.Length; i = i + 1){if (str[i] == DELIMITER){posi[count] = i;if (count == COUNT_OF_DELIMITER - 1)break;count = count + 1;}}//-----------------------------------------------------//Substringで文字列をスプリットしていく//1つ目の引数は、開始位置(0始まり)//2つ目の引数は、文字数//-----------------------------------------------------//※区切り文字を「カンマ」として説明を記載//・1列目のデータは、以下で抽出//　開始位置：0//    文字数：最初のカンマの位置（最初のカンマの位置＝最初の文字数になる）splitedStr[0] = str.Substring(0, posi[0]);//・2列目のデータは、以下で抽出（3列目以降も同じ感じ）//　開始位置：最初のカンマの位置 + 1//    文字数：次のカンマの位置 - 最初のカンマの位置 - 1splitedStr[1] = str.Substring(posi[0] + 1, posi[1] - posi[0] - 1);splitedStr[2] = str.Substring(posi[1] + 1, posi[2] - posi[1] - 1);splitedStr[3] = str.Substring(posi[2] + 1, posi[3] - posi[2] - 1);//・最後のデータは、以下で抽出//　開始位置：最後のカンマの位置//    文字数：指定なし（最後まで）splitedStr[4] = str.Substring(posi[3] + 1);return splitedStr;}
お手製スプリット
結果を格納するための配列を生成する
*var splitedStr = new string[COL_NUM];
区切り文字を見つけた件数
*var count = 0;
区切り文字の位置を格納する配列
*var posi = new int[COUNT_OF_DELIMITER];
文字列をchar配列でループして、一文字ずつ区切り文字であるか判定
区切り文字であるなら、区切り文字の位置を保存
*for (var i = 0; i <; str.Length; i = i + 1)
Substringで文字列をスプリットしていく
1つ目の引数は、開始位置(0始まり)
2つ目の引数は、文字数
-----------------------------------------------------
※区切り文字を「カンマ」として説明を記載
・1列目のデータは、以下で抽出
開始位置：0
文字数：最初のカンマの位置（最初のカンマの位置＝最初の文字数になる）
*splitedStr[0] = str.Substring(0, posi[0]);
・2列目のデータは、以下で抽出（3列目以降も同じ感じ）
開始位置：最初のカンマの位置 + 1
文字数：次のカンマの位置 - 最初のカンマの位置 - 1
*splitedStr[1] = str.Substring(posi[0] + 1, posi[1] - posi[0] - 1);
・最後のデータは、以下で抽出
開始位置：最後のカンマの位置
文字数：指定なし（最後まで）
*splitedStr[4] = str.Substring(posi[3] + 1);
結果を格納するための配列を生成する
*var splitedStr = new string[COL_NUM];
区切り文字を見つけた件数
*var count = 0;
切り出し開始位置
*var start = 0;
文字列をchar配列でループして、一文字ずつ区切り文字であるか判定
区切り文字であるなら、区切り文字の位置を保存
*for (var i = 0; i <; str.Length; i++)
Substringで文字列をスプリットしていく
*splitedStr[count] = str.Substring(start, i - start);
最後のデータは、以下で抽出
*splitedStr[count + 1] = str.Substring(i + 1);

*if (retryFrequency <; 0)*{
パラメータチェック
最大リトライ回数
*throw new ArgumentOutOfRangeException("retryFrequency");
リトライ間隔
*throw new ArgumentOutOfRangeException("retryInterval");
処理
*throw new ArgumentNullException("action");
メソッド
*return action();
リトライが必要な処理で例外が発生した場合
指定回数リトライ
*if (retryCount++ <; retryFrequency)
最大リトライ回数に達していない場合
*System.Threading.Thread.Sleep(retryInterval);
最大リトライ回数に達した場合
*throw e;
*if (retryFrequency <; 0)*{
パラメータチェック
最大リトライ回数
*throw new ArgumentOutOfRangeException("retryFrequency");
リトライ間隔
*throw new ArgumentOutOfRangeException("retryInterval");
処理
*throw new ArgumentNullException("action");
リトライが必要な処理で例外が発生した場合
指定回数リトライ
*if (retryCount++ <; retryFrequency)
最大リトライ回数に達していない場合
*System.Threading.Thread.Sleep(retryInterval);
最大リトライ回数に達した場合
*throw e;
*RetryExecutorNameSpace.RetryExecutor.Execute(4,1000, () =>; { System.Console.WriteLine("Hello World!"); });
System.Console.WriteLine("Hello World!")をリトライ対象のメソッドに置き換えて、ご使用ください。

IronPython ボイラープレート
*var engine = Python.CreateEngine();
戻り値 k の println
*var variables = scope.GetVariable<;dynamic>;("path");

クリックのアクション
*}
ダブルクリックのアクション
*}

*{UpdateSight();}
Update is called once per frame

*list = list.OrderByDescending(n =<; n).ToList();
16 13 10 4 3 2 1

*gameObject.name = "Test";
UnityException

*// 例えばswitchによって分けるなど*}
処理
例えばswitchによって分けるなど
*}
*{cloudy,sunny,rainy}
天気の列挙
晴れ→曇り→雨→晴れの順にループすることにする
クラスの宣言
*public static class Weather_Class
*// 天気状態型のweather_caseを宣言し、それによってswitchでわける*public static Weather_State Weather_Loop(this Weather_State weather_case)
メソッドの宣言
*{switch (weather_case){case Weather_State.sunny: return Weather_State.cloudy;case Weather_State.cloudy: return Weather_State.rainy;case Weather_State.rainy: return Weather_State.sunny;default: throw new NotImplementedException();}}
天気状態型のweather_caseを宣言し、それによってswitchでわける

*if (x <;= 0 || y <;= 0) return 0;
最大公約数を求めるのに0やマイナスを渡すことはないだろうけど、念のため

*public class Maze {private char[,] _map;public int XSize { get; private set; }public int YSize { get; private set; }private Position _start;// コンストラクタpublic Maze(string mapfile) {ReadMap(mapfile);_start = FindPosition('S');}// Mapデータを読み込むpublic void ReadMap(string mapfile) {string[] map = File.ReadAllLines(mapfile);this._map = new char[map[0].Length, map.Length];for (int y = 0; y <; map.Length; y++) {var line = map[y];for (int x = 0; x <; line.Length; x++) {this._map[x, y] = line[x];}}XSize = map[0].Length;YSize = map.Length;}// インデクサ （これは、表示のみに利用する)public char this[int x, int y] {get { return _map[x, y]; }}// relativeの場所が何かを返すpublic Place Look(Position relative) {var pos = GetAbsolutePosition(relative);// pos = GetPosition(pos, direction);if (pos.X <; 0 || pos.X >;= this.XSize)return Place.Wall;if (pos.Y <; 0 || pos.Y >;= this.YSize)return Place.Wall;switch (_map[pos.X, pos.Y]) {case 'G':return Place.Goal;case 'S':return Place.Start;case ' ':return Place.Path;default:return Place.Wall;}}// 相対位置から絶対位置に変換 （相対位置は、startの位置を基準とする)public Position GetAbsolutePosition(Position relative) {return new Position {X = _start.X + relative.X,Y = _start.Y + relative.Y};}// target で指定した文字がある場所を求める。public Position FindPosition(char target) {for (int x = 0; x <; XSize; x++) {for (int y = 0; y <; YSize; y++) {if (_map[x, y] == target)return new Position { X = x, Y = y };}}throw new ApplicationException();}// Positionは値型なので、呼び出し元には影響を与えないpublic static Position GetPosition(Position current, Direction direction) {switch (direction) {case Direction.South:current.Y++;break;case Direction.East:current.X++;break;case Direction.North:current.Y--;break;case Direction.West:current.X--;break;}return current;}// 反対方向を求めるpublic static Direction BackDirection(Direction direction) {switch (direction) {case Direction.South:return Direction.North;case Direction.East:return Direction.West;case Direction.North:return Direction.South;case Direction.West:return Direction.East;}return Direction.None;}}
迷路クラス
*public Maze(string mapfile) {ReadMap(mapfile);_start = FindPosition('S');}
コンストラクタ
*public void ReadMap(string mapfile) {string[] map = File.ReadAllLines(mapfile);this._map = new char[map[0].Length, map.Length];for (int y = 0; y <; map.Length; y++) {var line = map[y];for (int x = 0; x <; line.Length; x++) {this._map[x, y] = line[x];}}XSize = map[0].Length;YSize = map.Length;}
Mapデータを読み込む
*public char this[int x, int y] {get { return _map[x, y]; }}
インデクサ （これは、表示のみに利用する)
*public Place Look(Position relative) {var pos = GetAbsolutePosition(relative);// pos = GetPosition(pos, direction);if (pos.X <; 0 || pos.X >;= this.XSize)return Place.Wall;if (pos.Y <; 0 || pos.Y >;= this.YSize)return Place.Wall;switch (_map[pos.X, pos.Y]) {case 'G':return Place.Goal;case 'S':return Place.Start;case ' ':return Place.Path;default:return Place.Wall;}}
relativeの場所が何かを返す
*if (pos.X <; 0 || pos.X >;= this.XSize)*return Place.Wall;
pos = GetPosition(pos, direction);
*public Position GetAbsolutePosition(Position relative) {return new Position {X = _start.X + relative.X,Y = _start.Y + relative.Y};}
相対位置から絶対位置に変換 （相対位置は、startの位置を基準とする)
*public Position FindPosition(char target) {for (int x = 0; x <; XSize; x++) {for (int y = 0; y <; YSize; y++) {if (_map[x, y] == target)return new Position { X = x, Y = y };}}throw new ApplicationException();}
target で指定した文字がある場所を求める。
*public static Position GetPosition(Position current, Direction direction) {switch (direction) {case Direction.South:current.Y++;break;case Direction.East:current.X++;break;case Direction.North:current.Y--;break;case Direction.West:current.X--;break;}return current;}
Positionは値型なので、呼び出し元には影響を与えない
*public static Direction BackDirection(Direction direction) {switch (direction) {case Direction.South:return Direction.North;case Direction.East:return Direction.West;case Direction.North:return Direction.South;case Direction.West:return Direction.East;}return Direction.None;}
反対方向を求める
*public struct Position {public int X { get; set; }public int Y { get; set; }public override string ToString() {return $"({X},{Y})";}}
位置情報構造体
*public enum Direction {None,East,West,South,North}
Position
深さ優先探索
自分がいる絶対的な位置を知ることはできないものとする。
スタート位置を(0,0とし、どのように進んだかを自分自身で把握することで
相対的な位置だけはわかる。
迷路についてわかるのは自分の周りが道なのか壁なのかゴールなのかだけとする。
*public class MazeSolver : IObservable<;Direction>; {
*public IEnumerable<;Direction>; Solve(Maze maze) {_maze = maze;_footprint.Add(_current);_Solve();return _path.Reverse();}
解く。必ず解が存在することが前提。
*public IEnumerable<;Direction>; Directions() {if (_lastDirection != Direction.None)yield return _lastDirection;if (_lastDirection != Direction.South)yield return Direction.South;if (_lastDirection != Direction.East)yield return Direction.East;if (_lastDirection != Direction.North)yield return Direction.North;if (_lastDirection != Direction.West)yield return Direction.West;}
４つの方向を列挙する （直前の方向を最初にする)
*private bool _Solve(int level = 0) {foreach (var direction in Directions().ToList()) {var temp = Maze.GetPosition(_current, direction);switch (_maze.Look(temp)) {case Place.Goal:return true;case Place.Start:return false;case Place.Path:if (!AlreadyPassed(temp)) {Walk(direction);if (_Solve(level + 1))return true;Back(direction);}break;}}return false;}
Solveの下請け 再帰的に呼び出される
*private void Walk(Direction direction) {_current = Maze.GetPosition(_current, direction);_footprint.Add(_current);_path.Push(direction);_lastDirection = direction;Publish(direction);}
指定した方向へ歩く。
*public void Back(Direction direction) {var dir = Maze.BackDirection(direction);_current = Maze.GetPosition(_current, dir);Publish(dir);_path.Pop();}
逆の方向に戻る。
*private void TurnBack(Direction direction) {while (true) {var dir = Maze.BackDirection(_path.Pop());Back(dir);foreach (var nd in Directions()) {var temp = Maze.GetPosition(_current, nd);if (_maze.Look(temp) == Place.Path &amp;&amp; !AlreadyPassed(temp))// その方向が指す場所は、まだ試していない （_footprintにない) なら、もう戻らなくて良いreturn;}// 行くべき道がないから、さらに戻る}}
逆戻りする
その方向が指す場所は、まだ試していない （_footprintにない) なら、もう戻らなくて良い
*return;
行くべき道がないから、さらに戻る
*}
*private bool AlreadyPassed(Position pos) {return _footprint.Exists(p =>; p.X == pos.X &amp;&amp; p.Y == pos.Y);}
指定した方向は既に通った場所か
このプログラムでは購読者は、Viewerオブジェクトの一つだけ。
*private List<;IObserver<;Direction>;>; _observers = new List<;IObserver<;Direction>;>;();
*private void Complete() {foreach (var observer in _observers) {observer.OnCompleted();}}
終了を通知する
*private void Publish(Direction state) {foreach (var observer in _observers) {observer.OnNext(state);}}
状況変化を知らせるために購読者に通知する
*public IDisposable Subscribe(IObserver<;Direction>; observer) {_observers.Add(observer);return observer as IDisposable;}
observer(購読者) が通知を受け取れるようにする
*public void OnNext(Direction d) {// d方向に一つ動いた位置を新しい位置にする_current = Maze.GetPosition(_current, d);// 絶対位置を求めvar pos = _maze.GetAbsolutePosition(_current);// 足跡を残すConsole.SetCursorPosition(pos.X, pos.Y);Console.Write('.');Console.SetCursorPosition(pos.X, pos.Y);System.Threading.Thread.Sleep(100);}
状態が変化した （引数 d には、動いた方向が渡ってくる)
d方向に一つ動いた位置を新しい位置にする
*_current = Maze.GetPosition(_current, d);
絶対位置を求め
*var pos = _maze.GetAbsolutePosition(_current);
足跡を残す
*Console.SetCursorPosition(pos.X, pos.Y);
*public void Print() {for (int y = 0; y <; _maze.YSize; y++) {for (int x = 0; x <; _maze.XSize; x++) {Console.Write(_maze[x, y]);}Console.WriteLine();}}
迷路をConsoleに表示する

*PrefabUtility.ReplacePrefab(prefab, prefabAsset);
反映.
*{if (gameObj == null) return;if (onExecute == null) return;onExecute(gameObj);if (gameObj.transform.childCount >; 0){for (int i = 0; i <; gameObj.transform.childCount; ++i){var child = gameObj.transform.GetChild(i);ScanTree(child.gameObject, onExecute);}}}
子どものGameObjectを走査して処理を適用するためのヘルパ.
ディレクトリパスを指定.
*targets.Add("Assets/Prefabs/PrefabA.prefab");
新しい子ノードを追加してあげたりとか、
*GameObject child = new GameObject();
*PrefabChanger.ScanTree(prefab, gameObj =>; {GameObject.DestroyImmediate(gameObj.GetComponent<;Hoge>;());});
要らなくなったコンポーネントを削除するとか、

https:docs.microsoft.com/ja-jp/windows/uwp/devices-sensors/ble-beacon よりPickUp
*BluetoothLEAdvertisementWatcher watcher = new BluetoothLEAdvertisementWatcher();

*{var behaviour = new TextPlayableBehaviour();behaviour.charaObject = charaObj.Resolve(graph.GetResolver());// behaviour.text = text;return ScriptPlayable<;TextPlayableBehaviour>;.Create(graph, behaviour);}
Factory method that generates a playable based on this asset
*{public GameObject charaObject;private string text;// Called when the owning graph starts playingpublic override void OnGraphStart(Playable playable) {this.text = this.charaObject.GetComponent<;TextMeshPro>;().text;this.charaObject.GetComponent<;TextMeshPro>;().text = "";}// Called when the owning graph stops playingpublic override void OnGraphStop(Playable playable) {this.charaObject.GetComponent<;TextMeshPro>;().text = this.text;}// Called when the state of the playable is set to Playpublic override void OnBehaviourPlay(Playable playable, FrameData info) {}// Called when the state of the playable is set to Pausedpublic override void OnBehaviourPause(Playable playable, FrameData info) {}// Called each frame while the state is set to Playpublic override void ProcessFrame(Playable playable, FrameData info, object playerData){// PlayableTrackのClip上でシークバーが移動するたびに呼ばれ続ける（PrepareFrameの後）if (charaObject == null) { return; }var percent = (float)playable.GetTime() / (float)playable.GetDuration();this.charaObject.GetComponent<;TextMeshPro>;().text =this.text.Substring(0, (int)Mathf.Round(this.text.Length * percent));}}
A behaviour that is attached to a playable
*public override void OnGraphStart(Playable playable) {this.text = this.charaObject.GetComponent<;TextMeshPro>;().text;this.charaObject.GetComponent<;TextMeshPro>;().text = "";}
Called when the owning graph starts playing
*public override void OnGraphStop(Playable playable) {this.charaObject.GetComponent<;TextMeshPro>;().text = this.text;}
Called when the owning graph stops playing
*public override void OnBehaviourPlay(Playable playable, FrameData info) {}
Called when the state of the playable is set to Play
*public override void OnBehaviourPause(Playable playable, FrameData info) {}
Called when the state of the playable is set to Paused
*{// PlayableTrackのClip上でシークバーが移動するたびに呼ばれ続ける（PrepareFrameの後）if (charaObject == null) { return; }var percent = (float)playable.GetTime() / (float)playable.GetDuration();this.charaObject.GetComponent<;TextMeshPro>;().text =this.text.Substring(0, (int)Mathf.Round(this.text.Length * percent));}
Called each frame while the state is set to Play
*if (charaObject == null) { return; }*var percent = (float)playable.GetTime() / (float)playable.GetDuration();
PlayableTrackのClip上でシークバーが移動するたびに呼ばれ続ける（PrepareFrameの後）

*public Rigidbody parentRigidBody;
本体
*void Start () {rigidBody = GetComponent<;Rigidbody>;();}
Use this for initialization
*void Update () {if (Input.GetKey(KeyCode.Mouse1)){float deltaY = glindStartedY - parentRigidBody.position.y;if (deltaY >;= 0){parentRigidBody.velocity = parentRigidBody.transform.forward.normalized * Mathf.Sqrt(2 * Physics.gravity.magnitude * deltaY);}}else{parentRigidBody.useGravity = true;glindStartedY = parentRigidBody.position.y;}}
Update is called once per frame

初期処理
*NVelocity.App.Velocity.Init();
コンテキストを生成する
*NVelocity.VelocityContext context = new NVelocity.VelocityContext();
変数と値の組み合わせを格納する
*context.Put("name", "あいうえお");
テンプレートファイルを指定してテキストを生成する
*StringBuilder sb = new StringBuilder();

例外発生
*Console.WriteLine(dt.ToString("yyyy/MM/dd"));
例外発生時はチェックNG
*}

Note の セクション一覧を取得
*var notebooks = await graphClient.Me.Onenote.Sections
指定の セクションのページ一覧を取得
*var pageList = await graphClient.Me.Onenote.Sections[secId].Pages.Request()
*Debug.WriteLine(page.Title + " " + page.LastModifiedDateTime);*Debug.WriteLine(page.Links.OneNoteWebUrl.Href);
指定のページの最終更新年月日を比較 新しい物を取得対象とする。
*foreach (var doc in getDocList)*{
指定の ページを取得する。
ページ取得のループ
*var contentSt = await graphClient.Me.Onenote.Pages[doc.Id].Content.Request().GetAsync();

*GetCalendar(credential, "(カレンダーID)");
アクセスしたいカレンダーのID

*if(obj is string str)*{
変数objがstring型であるならばキャストして変数strとして定義
①ifのスコープ内なので変数strが利用可能
*Console.WriteLine(str);
変数objがstring型であるならばキャストして変数strとして定義し、
変数objがstring型でないならreturnする
*if(!(obj is string str)) return;
①if文のスコープ外であるはずだが、変数strが利用できる
*Console.WriteLine(str);
*if(!(obj is string)) return;*// if文の判定後にキャスト
変数objがstring型でないならreturnする
if文の判定後にキャスト
*string str = (string)obj;

新規のExcelファイルを作成
*SimpleExcelCreator simpleExcelCreator = new SimpleExcelCreator("test.xlsx");
テンプレートとなるExcelを基にファイル作成
*SimpleExcelCreator simpleExcelCreator = new SimpleExcelCreator("template.xlsx", "use_template.xlsx");
保存
*simpleExcelCreator.Save();
シート追加
*simpleExcelCreator.AddSheet("SampleSheet1");
シート選択
*simpleExcelCreator.SelectSheet("SampleSheet2");
選択中のシート名変更
*simpleExcelCreator.SetSheetName("ChangeName");
シートの削除
*simpleExcelCreator.RemoveSheet("SampleSheet3");
アルファベットとy座標でデータ書込
*simpleExcelCreator.WriteCell("A", 1, 1000);
x,y座標指定でデータ書込(0は範囲外になります)
*simpleExcelCreator.WriteCell(1, 1, "temp");
セル指定でデータ書込
*simpleExcelCreator.WriteCell("A2", "temp");
行のコピー&amp;ペースト
*simpleExcelCreator.RowCopyPaste(2, 5, false);
コピーした行を挿入
*simpleExcelCreator.RowCopyPaste(2, 5, true);

*byte[] buf = img.GetPropertyItem(0x5100).Value;
PropertyTagFrameDelay

*app.UseLocalTimeZone();
← ココ

*ctxt.Acceptable = true;
&lt;- 委譲元のAcceptableの値を変更

追記
*using System.Web.Mvc;
*{// 以下の４行を追加AreaRegistration.RegisterAllAreas();FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);RouteConfig.RegisterRoutes(RouteTable.Routes);BundleConfig.RegisterBundles(BundleTable.Bundles);}
中略
以下の４行を追加
*AreaRegistration.RegisterAllAreas();
*{// 適宜追加// Web FormsからもBundleしたファイルを呼び出せます}
バンドルの詳細については、http:go.microsoft.com/fwlink/?LinkId=301862  を参照してください
適宜追加
Web FormsからもBundleしたファイルを呼び出せます
*}
適宜追加
*}
属性でルーティング
*routes.MapMvcAttributeRoutes();

*.AsEnumerable()
&lt;- IEnumerable&lt;T&gt; に切り替わる
*foreach (var title in query) {*Console.WriteLine(title);
クエリが実行される

*ImmAssociateContext(handle, imeRet);
IMEを復元

*public bool IsDeleted { get; set; }
Column for Azure Search soft delete
*public bool IsDeleted { get; set; }
Column for Azure Search soft delete

*static readonly ILoggerFactory loggerFactory = new LoggerFactory(new[] {new ConsoleLoggerProvider((category, level) =>;category == DbLoggerCategory.Database.Command.Name&amp;&amp; level == LogLevel.Information, true) });
ロガーファクトリに ConsoleLoggerProvider を登録する。
*static readonly ILoggerFactory loggerFactory = new LoggerFactory(new[] {new ConsoleLoggerProvider((category, level) =>;category == DbLoggerCategory.Database.Command.Name&amp;&amp; level == LogLevel.Information, true) });
出力先を変えたい時は登録するロガー変えたり、追加する
UseLoggerFactory で上記のロガーファクトリを登録する。
Insert 文の値をロギングするために EnableSensitiveDataLogging を許可する。
*protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) =>;
データベースに初期値をシーディングする。
※データベースに値がない場合のみ Insert 文が走るので２重に登録される心配はない
*protected override void OnModelCreating(ModelBuilder modelBuilder) =>;
まだDBがない場合にデータベースを作成。
存在する場合何もしないのでモデルとの整合性は保証されないが、
今回は使い捨てでマイグレーションを行わないのでこれでOK
*dbContext.Database.EnsureCreated();

*if (Input.GetButton("Jump")) return true;
ジャンプキー押しっぱなしで連続ジャンプ
*// または、 if (Input.GetKeyUp(KeyCode.Space)) return true; とかでも可*return false;
if (Input.GetButtonDown("Jump")) return true;     ジャンプキーが押された時だけジャンプにする時はこっち
または、 if (Input.GetKeyUp(KeyCode.Space)) return true; とかでも可
*return false;
プレイヤーの位置から下向きにRaycast
レイヤーマスクでGroundを設定しているので、
地面のGameObjectにGroundのレイヤーを設定しておけば、
Groundのレイヤーを持つGameObjectで一番近いものが一つだけヒットする
*var isGroundHit = Physics.Raycast(
ヒットしなかった場合はキャラの下方に地面が存在しないものとして扱う
*_groundDistance = float.MaxValue;
地面とキャラの距離は環境によって様々で
完全にゼロにはならない時もあるため、
ジャンプしていない時の値に多少のマージンをのせた
一定値以下を接地と判定する
通常あり得ないと思われるが、オーバーフローされると再度アクションが実行されてしまうので、越えたところで止める
*if (_groundDistance <; _groundDistanceLimit) {
*if (_isGroundStateChange == _isGround &amp;&amp; _notGround == 0) {if (landingAction != null) landingAction();} else
接地後またはジャンプ後、特定フレーム分状態の変化が無ければ、
*if (_isGroundStateChange == _isGround &amp;&amp; _notGround == 0) {*if (landingAction != null) landingAction();
状態が安定したものとして接地処理またはジャンプ処理を行う
*.Select(_ =>; {//if (jumpInput || JumpInput()) jumpInput = true;if (jumpInput || Input.GetButton("Jump")) jumpInput = true;return jumpInput;});
入力ストリーム
*if (jumpInput || Input.GetButton("Jump")) jumpInput = true;*return jumpInput;
if (jumpInput || JumpInput()) jumpInput = true;
入力ストリームを通すと処理が遅れるようでリアルタイムなやり取りが難しかったので
今回はパス
**/
FixedUpdateを主軸にし、そこにinputStreamを合成する
*this.FixedUpdateAsObservable()
*{if (jumpInput &amp;&amp; !isJumping)  {isJumping = true;Debug.Log("jumping : " + (Vector3.up * jumpPower).ToString());rigidBody.AddForce(Vector3.up * jumpPower, ForceMode.Impulse);}});
.WithLatestFrom(inputStream, (_, jump_input) =&gt; jump_input)
*_is_ground.Where(value =>; value == _isGroundStateChange).Subscribe(x =>; {jumpInput = false;isJumping = false;});
接地後またはジャンプ後、特定フレーム分状態の変化が無ければ、
*_is_ground.Where(value =>; value == _isGroundStateChange).Subscribe(x =>; {jumpInput = false;isJumping = false;});
状態が安定したものとして接地処理またはジャンプ処理を行う
プレイヤーの位置から下向きにRaycast
レイヤーマスクでGroundを設定しているので、
地面のGameObjectにGroundのレイヤーを設定しておけば、
Groundのレイヤーを持つGameObjectで一番近いものが一つだけヒットする
*var isGroundHit = Physics.Raycast(
ヒットしなかった場合はキャラの下方に地面が存在しないものとして扱う
*_groundDistance = float.MaxValue;
地面とキャラの距離は環境によって様々で
完全にゼロにはならない時もあるため、
ジャンプしていない時の値に多少のマージンをのせた
一定値以下を接地と判定する
通常あり得ないと思われるが、オーバーフローされると再度アクションが実行されてしまうので、越えたところで止める
*if (_groundDistance <; _groundDistanceLimit) {

*var index1st = Array.IndexOf(list, max1st);
最大確率のインデックスを取得
結果表示
*this.Text_Result_1st.Text = ans + ":" + max1st.ToString();

ファイル名
*string fileName = "ShortCut.url";
作成するURLショートカットのパス
*string shortcutPath = System.IO.Path.Combine(Directory.GetCurrentDirectory(), fileName);
ショートカットのリンク先
string url = "https:www.google.co.jp/";
テキストファイルに書き込む
*System.Text.Encoding enc = System.Text.Encoding.GetEncoding("utf-8");
ファイルダウンロード
*var filePath = shortcutPath;

*System.Console.Out.WriteLine(FormatPhoneNumber("08001112222"));
0800:OK
*{"01564", "01558", "01586", "01587", "01634", "01632","01547", "05769", "04992", "04994", "01456", "01457","01466", "01635", "09496", "08477", "08512", "08396","08388", "08387", "08514", "07468", "01655", "01648","01656", "01658", "05979", "04996", "01654", "01372","01374", "09969", "09802", "09912", "09913", "01398","01377", "01267", "04998", "01397", "01392",};
市外局番5桁、局番1桁の番号
*{"0768", "0770", "0772", "0774", "0773", "0767", "0771", "0765","0748", "0747", "0746", "0826", "0749", "0776", "0763", "0761","0766", "0778", "0824", "0797", "0796", "0555", "0823", "0798","0554", "0820", "0795", "0556", "0791", "0790", "0779", "0558","0745", "0794", "0557", "0799", "0738", "0567", "0568", "0585","0586", "0566", "0564", "0565", "0587", "0584", "0581", "0572","0574", "0573", "0575", "0576", "0578", "0577", "0569", "0594","0827", "0736", "0735", "0725", "0737", "0739", "0743", "0742","0740", "0721", "0599", "0561", "0562", "0563", "0595", "0596","0598", "0597", "0744", "0852", "0956", "0955", "0954", "0952","0957", "0959", "0966", "0965", "0964", "0950", "0949", "0942","0940", "0930", "0943", "0944", "0948", "0947", "0946", "0967","0968", "0987", "0986", "0985", "0984", "0993", "0994", "0997","0996", "0995", "0983", "0982", "0973", "0972", "0969", "0974","0977", "0980", "0979", "0978", "0920", "0898", "0855", "0854","0853", "0553", "0856", "0857", "0863", "0859", "0858", "0848","0847", "0835", "0834", "0833", "0836", "0837", "0846", "0845","0838", "0865", "0866", "0892", "0889", "0887", "0893", "0894","0897", "0896", "0895", "0885", "0884", "0869", "0868", "0867","0875", "0877", "0883", "0880", "0879", "0829", "0550", "0228","0226", "0225", "0224", "0229", "0233", "0237", "0235", "0234","0223", "0220", "0192", "0191", "0187", "0193", "0194", "0198","0197", "0195", "0238", "0240", "0260", "0259", "0258", "0257","0261", "0263", "0266", "0265", "0264", "0256", "0255", "0243","0242", "0241", "0244", "0246", "0254", "0248", "0247", "0186","0185", "0144", "0143", "0142", "0139", "0145", "0146", "0154","0153", "0152", "0138", "0137", "0125", "0124", "0123", "0126","0133", "0136", "0135", "0134", "0155", "0156", "0176", "0175","0174", "0178", "0179", "0184", "0183", "0182", "0173", "0172","0162", "0158", "0157", "0163", "0164", "0167", "0166", "0165","0267", "0250", "0533", "0422", "0532", "0531", "0436", "0428","0536", "0299", "0294", "0293", "0475", "0295", "0297", "0296","0495", "0438", "0466", "0465", "0467", "0478", "0476", "0470","0463", "0479", "0493", "0494", "0439", "0268", "0480", "0460","0538", "0537", "0539", "0279", "0548", "0280", "0282", "0278","0277", "0269", "0270", "0274", "0276", "0283", "0551", "0289","0287", "0547", "0288", "0544", "0545", "0284", "0291", "0285",};
市外局番4桁、局番2桁の番号
*{"0120", "0570", "0800", "0990"};
市外局番4桁、局番3桁の番号
*{"058", "052", "011", "096", "049", "015", "048", "072","084", "028", "024", "076", "023", "047", "029", "075","025", "055", "026", "079", "082", "027", "078", "077","083", "022", "086", "089", "045", "044", "092", "046","017", "093", "059", "073", "019", "087", "042", "018","043", "088",};
市外局番3桁、局番3桁の番号
*{"050",};
市外局番3桁、局番4桁の番号
*{"03", "04", "06",};
市外局番2桁、局番4桁の番号
*{"020", "070", "080", "090",};
市外局番3桁、一般ルールなら局番4桁、総務省ルールなら局番3桁
*if (strict)*{ numList3_3.AddRange(numList3_3or4); }
一般ルールか総務省ルールかで登録するグループを変える
番号変換クラスに変換ルールを登録
*var replacer = new Replacer();
入力文字列から数値以外の文字を除去
*var number = Regex.Replace(input, @"\D", "");
*var formatted = replacer.TryReplace(number);*if (formatted != "")
変換を実行
局番なしの場合の変換
*var matches = Regex.Match(number, @"\A(00(?:[013-8]|2\d|91[02-9])\d)(\d+)\z");

*app.UsePathBase("
pathtoproject_directory");  ※ app.UseStaticFiles();に影響します

*base.Walk();
←SuperClassメソッドの呼び出し
処理1
*}
処理2
*}
処理3
*}

*string to = "";
コピー先

型を書けないので変数をnullで初期化できない
絶対にnullが返ってくる引数でGetMethodを呼び出して型推論させる
*var assemblyLoadMethodInfo = assemblyType.GetMethod("XXXX");
*// var assemblyLoadMethodInfo = assemblyType.GetMethod("Load", new[] { typeof(string) });
stringを引数に使うほうならGetMethodでも大丈夫だけどAssemblyNameのほうを使用したかったので使わない
*foreach (var method in assemblyType.GetMethods())*{
var assemblyLoadMethodInfo = assemblyType.GetMethod("Load", new[] { typeof(string) });
Instance | NonPublicのフラグ作成
*var bindingFlagsType = assemblyType.Assembly.GetType("System.Reflection.BindingFlags");
*var toObjectMethodInfo = enumType.GetMethod("ToObject", new[] { enumType.GetType().BaseType, typeof(int) });
既存のEnum(MemberType)からenumの型情報取得
*var filedGetValueMethodInfo = invocationFlagsField.GetType().GetMethod("GetValue", new[] { typeof(object) });
invocationFlagsFieldがobjectなのでGet/Setもリフレクション経由
*var originalInvocationFlags = filedGetValueMethodInfo.Invoke(invocationFlagsField, new object[] { assemblyLoadMethodInfo });
INITIALIZEDのフラグ設定
*var assemblyLoadMethodInfo = assemblyType.GetMethod("Load", new[] { typeof(string) });
アセンブリのロードは文字列直接のほうを使う
*var consoleAssembly = assemblyLoadMethodInfo.Invoke(null, new[] { "System.Console" });
アセンブリのロードとタイプの取得

*<;html xmlns="http:
www.w3.org1999xhtml"&gt;
AutoPostBack="True"にしてOnSelectedIndexChangedイベントを追加すること
*<;asp:DropDownList ID="ddlPublish" runat="server" Width="150px" AutoPostBack="True" OnSelectedIndexChanged="DDLPublish_SelectedIndexChanged">;
出版社情報定義
*dicPublish.Add(1, "日経BP社");
書籍情報定義
*books.Add(new Book("978-4-8222-9644-5", "アプリを作ろう! Android入門", 2000, 1, DateTime.ParseExact("2015/08/21", "yyyy/MM/dd", null), false));
senderオブジェクトよりコントロールを取得
*var ddlPublish = (DropDownList)sender;
ddlPublishの親コントロールを取得する
*var ddlBook = ddlPublish.Parent.FindControl("ddlBook") as DropDownList;

p2 は重複していると扱われて格納されません
*HashSet<;Player>; hash = new HashSet<;Player>;();
p2 は重複していると扱われて ArgumentException がスローされます
*Dictionary<;Player, bool>; dic = new Dictionary<;Player, bool>;();

*var ddt = TimeZoneInfo.ConvertTime(now, jddtTimeZone);
-&gt; 20180831 13:44:05 +11:00
(4-2) 特定日時の場合
*var dt1 = new DateTimeOffset(2018, 9, 1, 12, 34, 56,
*if (jddtTimeZone.IsDaylightSavingTime(dt2))*{
var dt2 = new DateTime(2018, 10, 1, 12, 34, 56);
*{var dt3 = new DateTimeOffset(dt2, jddtTimeZone.BaseUtcOffset);// ->; 2018/10/01 12:34:56 +09:00}
-&gt; 2018/09/01 12:34:56 +11:00
現在時刻の１時間後(夏時間考慮込み)
*var now1 = DateTimeOffset.Now.AddHours(1);
結局出力は(自作した)TimeZoneInfoで変換するので、DateTimeOffsetなら問題ない
*jddstTimeZone.ConvertTime(now1);

*Console.WriteLine(a);
5が出力される。

*Vector3 cLTxLB = Vector3.Cross(ToLeftTop, ToLeftBottom);
左端

*{X, Y, Z}
using CommandLine;
*public string A { get; set; }
基本的な形式
*public bool B { get; set; }
プリミティブ型であれば、string以外でも受け取ることが可能
*public IEnumerable<;string>; C { get; set; }
複数の値を受け取ることが可能。区切り文字はSeparatorで指定
*public Hoge D { get; set; }
enumを受け取ることも可能(指定にはenumの名前を指定する)
*public IEnumerable<;string>; Remaining { get; set; }
オプション以外の引数を受け取るための属性
第一引数がショート形式、第二引数がロング形式
第一、第二引数は省略可
*[Option('a', "aaa", Description = "option A", Required = false)]
*public string X { get; set; }
MetaNameはヘルプ時に表示される
*.WithParsed(opt =>; {/*パースに成功した場合*/})
using CommandLine.Text;
非同期でint値を返す
*await Parser.Default.ParseArguments<;Options>;(args)
*{// 何かの非同期処理await Task.Yield();return 0;}
成功した場合
何かの非同期処理
*await Task.Yield();
*{// 何かの非同期処理await Task.Yield();return -1;}
失敗した場合
何かの非同期処理
*await Task.Yield();
パース成功時
*var parsed = (Parsed<;Options>;)result;
処理
*}
パース失敗時
*var notParsed = (NotParsed<;Options>;)result;
処理
*}
*.WithParsed<;MySubCommand>;(opt1 =>; { /**/ })
MySubCommandとMySubCommand2があるとする
*{var parsed = parser.ParseArguments<;Options>;(args);parsed.WithNotParsed(er =>;{// パース結果からデフォルトの文を生成したい場合は、HelpText.AutoBuildを使用するvar helpText = HelpText.AutoBuild(parsed);// 生成後にhelpText = helpText.Add...で追加記述も可能Console.WriteLine($"parse failed: {helpText}");});// 処理...}
using CommandLine.Text;
パース結果からデフォルトの文を生成したい場合は、HelpText.AutoBuildを使用する
*var helpText = HelpText.AutoBuild(parsed);
*Console.WriteLine($"parse failed: {helpText}");
生成後にhelpText = helpText.Add...で追加記述も可能
処理...
*}

略...
*}

*var filterSize = 5;
ここで1,3,5,7と変更しました。
偶数はガウシアンフィルタの原理上指定できないようです。
偶数を指定するとExceptionが発生します。
*imageMat = imageMat.GaussianBlur(new OpenCvSharp.Size(filterSize, filterSize), 0);
ビットマップに戻します
*var filterResult = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(imageMat);

*<; m.Background = new SolidColorBrush(Colors.Purple);
ウインドウの背景色が紫色に変わる

*{Console.WriteLine($"値:{s}");}));
before
*second.Subscribe(s =>; Console.WriteLine($"値:{s}"));
after
*{root.Subscribe(new Observer<;string>;(s =>;{Console.WriteLine($"'{s}' が流れてきました。2倍にします。");o.OnNext(s + s);}));});
before
*{Console.WriteLine($"'{s}' が流れてきました。2倍にします。");return s + s;});
after
*{second.Subscribe(new Observer<;string>;(s =>;{if (s == "ふがふが"){Console.WriteLine("'ふがふが'は先に流しません");}else{o.OnNext(s);}}));});
before
*{if (s == "ふがふが"){Console.WriteLine("'ふがふが'は先に流しません");return false;}return true;});
after

*.Where(x =<; x.Column_a == user_input);
このxは直前のJoinのテーブルが対象となる
クエリでデータが取得できた場合の処理
*}
データが取得できなかった場合
*}

*x1 = ref x2;
参照先=呼び出し元には影響しないので書ける
呼び出し元には、x1=1, x2=3 が出力(out)される
*}
*void DoSomethingIn(in int x1 = default) {}
in引数はオプション引数にできる
*//if (x1 >; x2 &amp;&amp; x1 >; x3) {*//    return ref x1; // 読み取り専用の参照(in)を読み取り可能な参照(ref)では返せない
return ref b;  これは返せない
*if (x2 >; x3) {return ref x2;}
return ref x1;  読み取り専用の参照(in)を読み取り可能な参照(ref)では返せない
*if (x2 >; x3) {*return ref x2;
}
*if (x1 >; x2 &amp;&amp; x1 >; x3) {*return ref x1;
return ref b;  これは返せない
x = 100;  これはNG
*ref int y = ref a;

*public static bool PlayBgm (SoundFile soundFile) {return Instance.DoPlayBgm (soundFile);}
BGMの再生.
*public static void PauseBgm (bool flag) {Instance.DoPauseBgm (flag);}
BGMの一時停止.
*public static void StopBgm () {Instance.DoStopBgm ();}
BGMの停止.
*public bool DoPlayBgm (SoundFile soundFile) {if ((int)soundFile != _bgmFileIdx) {_bgmChannel.Stop();_bgmFileIdx = (int)soundFile;var clip = soundFile.ToAudioClip();if (clip == null) return false;_bgmChannel.clip = clip;_bgmChannel.loop = true;_bgmChannel.volume = 1;_bgmChannel.Play ();}return true;}
BGMの再生.
*public void DoPauseBgm (bool flag) {if (flag) {_bgmChannel.Pause ();} else {_bgmChannel.Play ();}}
BGMの一時停止.
*public void DoStopBgm () {_bgmChannel.Stop ();_bgmFileIdx = -1;}
BGMの停止.
*public static AudioSource PlaySe (SoundFile soundFile) {return Instance.DoPlaySe (soundFile);}
SE再生.

*return false;
見つからなかった

パスを定数で定義する
*const string FILE_PATH = @"C:\Hoge.txt";
作成日時を現在のローカル時刻で更新する
*System.IO.File.SetCreationTime(FILE_PATH, DateTime.Now);
更新日時を現在のローカル時刻で更新する
*System.IO.File.SetLastWriteTime(FILE_PATH, DateTime.Now);
アクセス日時を現在のローカル時刻で更新する
*System.IO.File.SetLastAccessTime(FILE_PATH, DateTime.Now);

*string name = user.Name;
=&gt; user が null なら System.NullReferenceException
if 文
*string name;
三項演算子
*var name = (user == null) ? null : user.Name;

IntPtr module = Marshal.GetHINSTANCE(typeof(MouseHook).Assembly.GetModules()[0]);  ここを消すかコメントアウト
*this.hook = SetWindowsHookEx(MouseLowLevelHook, handler, module, 0);
IntPtr module = Marshal.GetHINSTANCE(typeof(KeyboardHook).Assembly.GetModules()[0]);  ここを消すかコメントアウト
*this.hook = SetWindowsHookEx(KeyboardHookType, callback, module, 0);

省略
*}
省略
*}
省略
*}

*[System.Web.Services.Protocols.SoapRpcMethodAttribute("BaseGetUsersByLoginName", RequestNamespace="http:
wsdl.cybozu.co.jpbase2008", ResponseNamespace="http:wsdl.cybozu.co.jpbase2008", Use=System.Web.Services.Description.SoapBindingUse.Literal)]
base区分のAPIクライアント
*BaseBinding baseAPI = new BaseBinding();
ヘッダ情報追加
--------------------------------------------------------
Garoon共通のSOAPヘッダー
*ActionElement actionElement = new ActionElement();
呼び出すAPI名
*actionElement.actionValue = "BaseGetUsersByLoginName";
アクセス者
userNameTokenElement.Username = "xxxxx";  GaroonのログインID
userNameTokenElement.Password = "xxxxx";  ログインパスワード
*securityElement.usernameToken = userNameTokenElement;
タイムスタンプ
*timeStampElement.Created = DateTime.UtcNow;
ヘッダー設定
*baseAPI.action = actionElement;
リクエスト(Body)作成
--------------------------------------------------------
このAPIだとログインID配列のみ
*string[] param = { "yyyyy" };
SOAPリクエスト
--------------------------------------------------------
*UserType[] userTypes = baseAPI.BaseGetUsersByLoginName(param);
ユーザーIDに一致するユーザーがいない場合もここに来る
*Console.WriteLine(ex.Message);

ダイアログ内容VMのOpenプロパティを変更することで、ダイアログのOpen・Closeを制御する
*DialogVM.IsOpen.Value = true;
ダイアログのOpenプロパティが変更されるのを待つ
*await DialogVM.IsOpen;
ダイアログ結果を文字列に加工して表示
*DialogResultText.Value = DialogVM.IsOK.Value == true ? "おーけー" : "きゃんせる";
ダイアログが開いたときにダイアログ結果をNullに設定
*IsOpen

加算の場合はアルファ値を0.0 ~ 0.5, 乗算の場合は0.5 ~ 1.0になるように変換をかける
*return new Color(base.color.r, base.color.g, base.color.b, (base.color.a + (int)_blendType) / 2.0f);

*void Start () {ResetMapData();CreateSpaceData();CreateDangeon();}
道の集合点を増やしたいならこれを増やす
*void Update () {}
Update is called once per frame

静的なインスタンスとして持つ
*private static TestSingleton _instance;
*private TestSingleton(){}
コンストラクタはprivate
*{lock(_lockObject){if ( _instance == null){//インスタンス生成_instance = new TestSingleton();}return  _instance;}}
インスタンス取得のためのstaticメソッド
インスタンス生成
*_instance = new TestSingleton();

使用する値をランダムに並び替える
*var rnd = new Random();

*public class Maze {private char[,] _map;public int XSize { get; private set; }public int YSize { get; private set; }private Position _start;// コンストラクタpublic Maze(string mapfile) {ReadMap(mapfile);_start = FindPosition('S');}// Mapデータを読み込むpublic void ReadMap(string mapfile) {string[] map = File.ReadAllLines(mapfile);this._map = new char[map[0].Length, map.Length];for (int y = 0; y <; map.Length; y++) {var line = map[y];for (int x = 0; x <; line.Length; x++) {this._map[x, y] = line[x];}}XSize = map[0].Length;YSize = map.Length;}// インデクサ （これは、表示のみに利用する)public char this[int x, int y] {get { return _map[x, y]; }}// relativeの場所が何かを返すpublic Place Look(Position relative) {var pos = GetAbsolutePosition(relative);// pos = GetPosition(pos, direction);if (pos.X <; 0 || pos.X >;= this.XSize)return Place.Wall;if (pos.Y <; 0 || pos.Y >;= this.YSize)return Place.Wall;switch (_map[pos.X, pos.Y]) {case 'G':return Place.Goal;case 'S':return Place.Start;case ' ':return Place.Path;default:return Place.Wall;}}// 相対位置から絶対位置に変換 （相対位置は、startの位置を基準とする)public Position GetAbsolutePosition(Position relative) {return new Position {X = _start.X + relative.X,Y = _start.Y + relative.Y};}// target で指定した文字がある場所を求める。public Position FindPosition(char target) {for (int x = 0; x <; XSize; x++) {for (int y = 0; y <; YSize; y++) {if (_map[x, y] == target)return new Position { X = x, Y = y };}}throw new ApplicationException();}// Positionは値型なので、呼び出し元には影響を与えないpublic static Position GetPosition(Position current, Direction direction) {switch (direction) {case Direction.South:current.Y++;break;case Direction.East:current.X++;break;case Direction.North:current.Y--;break;case Direction.West:current.X--;break;}return current;}// 反対方向を求めるpublic static Direction BackDirection(Direction direction) {switch (direction) {case Direction.South:return Direction.North;case Direction.East:return Direction.West;case Direction.North:return Direction.South;case Direction.West:return Direction.East;}return Direction.None;}}
迷路クラス
*public Maze(string mapfile) {ReadMap(mapfile);_start = FindPosition('S');}
コンストラクタ
*public void ReadMap(string mapfile) {string[] map = File.ReadAllLines(mapfile);this._map = new char[map[0].Length, map.Length];for (int y = 0; y <; map.Length; y++) {var line = map[y];for (int x = 0; x <; line.Length; x++) {this._map[x, y] = line[x];}}XSize = map[0].Length;YSize = map.Length;}
Mapデータを読み込む
*public char this[int x, int y] {get { return _map[x, y]; }}
インデクサ （これは、表示のみに利用する)
*public Place Look(Position relative) {var pos = GetAbsolutePosition(relative);// pos = GetPosition(pos, direction);if (pos.X <; 0 || pos.X >;= this.XSize)return Place.Wall;if (pos.Y <; 0 || pos.Y >;= this.YSize)return Place.Wall;switch (_map[pos.X, pos.Y]) {case 'G':return Place.Goal;case 'S':return Place.Start;case ' ':return Place.Path;default:return Place.Wall;}}
relativeの場所が何かを返す
*if (pos.X <; 0 || pos.X >;= this.XSize)*return Place.Wall;
pos = GetPosition(pos, direction);
*public Position GetAbsolutePosition(Position relative) {return new Position {X = _start.X + relative.X,Y = _start.Y + relative.Y};}
相対位置から絶対位置に変換 （相対位置は、startの位置を基準とする)
*public Position FindPosition(char target) {for (int x = 0; x <; XSize; x++) {for (int y = 0; y <; YSize; y++) {if (_map[x, y] == target)return new Position { X = x, Y = y };}}throw new ApplicationException();}
target で指定した文字がある場所を求める。
*public static Position GetPosition(Position current, Direction direction) {switch (direction) {case Direction.South:current.Y++;break;case Direction.East:current.X++;break;case Direction.North:current.Y--;break;case Direction.West:current.X--;break;}return current;}
Positionは値型なので、呼び出し元には影響を与えない
*public static Direction BackDirection(Direction direction) {switch (direction) {case Direction.South:return Direction.North;case Direction.East:return Direction.West;case Direction.North:return Direction.South;case Direction.West:return Direction.East;}return Direction.None;}
反対方向を求める
*public struct Position {public int X { get; set; }public int Y { get; set; }public override string ToString() {return $"({X},{Y})";}}
位置情報構造体
*public enum Direction {None,East,West,South,North}
Direction
*public class Tracks {private List<;Direction>; _directionPath = new List<;Direction>;();private List<;Position>; _positionPath = new List<;Position>;();// コンストラクタpublic Tracks() {_directionPath.Add(Direction.None);_positionPath.Add(new Position { X = 0, Y = 0 });}// 進行方向の履歴public IEnumerable<;Direction>; GetDirectionPath() {return _directionPath;}// 位置の履歴public IEnumerable<;Position>; GetPositionPathh() {return _positionPath;}// 経路を追加public void Add(Position pos, Direction dir) {_positionPath.Add(pos);_directionPath.Add(dir);}// 最後の位置と方向を取得public (Position, Direction) Last() {return (_positionPath.Last(), _directionPath.Last());}// 現在の位置と方向を取得public (Position, Direction) Current {get {return (_positionPath.Last(), _directionPath.Last());}}public Tracks Clone() {var obj = new Tracks() {_directionPath = this._directionPath.ToList(),_positionPath = this._positionPath.ToList()};return obj;}}
経路を表すクラス 位置と進行方向からなる
*public Tracks() {_directionPath.Add(Direction.None);_positionPath.Add(new Position { X = 0, Y = 0 });}
コンストラクタ
*public IEnumerable<;Direction>; GetDirectionPath() {return _directionPath;}
進行方向の履歴
*public IEnumerable<;Position>; GetPositionPathh() {return _positionPath;}
位置の履歴
*public void Add(Position pos, Direction dir) {_positionPath.Add(pos);_directionPath.Add(dir);}
経路を追加
*public (Position, Direction) Last() {return (_positionPath.Last(), _directionPath.Last());}
最後の位置と方向を取得
*public (Position, Direction) Current {get {return (_positionPath.Last(), _directionPath.Last());}}
現在の位置と方向を取得
*public class MazeSolver : IObservable<;Position>; {private Maze _maze;// 解く。必ず解が存在することが前提。public IEnumerable<;Direction>; Solve(Maze maze) {_maze = maze;var tracks = _Solve();return tracks.GetDirectionPath();}public Tracks _Solve() {Queue<;Tracks>; queu = new Queue<;Tracks>;();queu.Enqueue(new Tracks());while (queu.Count != 0) {//キューの先頭から経路情報取り出すvar tracks = queu.Dequeue();var (currentPosition, currentDirection) = tracks.Current;foreach (var direction in Directions(currentDirection).ToList()) {// 次に進む位置を求めるvar nextpos = Maze.GetPosition(currentPosition, direction);// その場所の種類を調べるswitch (_maze.Look(nextpos)) {case Place.Goal:return tracks;case Place.Path:if (!AlreadyPassed(tracks, nextpos)) {// 通路でまだ通っていない場所ならば、キューに入れて覚えてくvar clone = tracks.Clone();clone.Add(nextpos, direction);queu.Enqueue(clone);Publish(nextpos);}break;}// 壁とStart位置ならば何もせずに、次の方向を調べる}}return null;}// ４つの方向を列挙する （できるだけ直進するように直前の方向を最初にする)public IEnumerable<;Direction>; Directions(Direction lastDirection) {if (lastDirection != Direction.None)yield return lastDirection;if (lastDirection != Direction.South)yield return Direction.South;if (lastDirection != Direction.East)yield return Direction.East;if (lastDirection != Direction.North)yield return Direction.North;if (lastDirection != Direction.West)yield return Direction.West;}// 指定した方向は既に通った場所かprivate bool AlreadyPassed(Tracks tracks, Position pos) {return tracks.GetPositionPathh().Any(p =>; p.X == pos.X &amp;&amp; p.Y == pos.Y);}// このプログラムでは購読者は、Viewerオブジェクトの一つだけ。private List<;IObserver<;Position>;>; _observers = new List<;IObserver<;Position>;>;();// 終了を通知するprivate void Complete() {foreach (var observer in _observers) {observer.OnCompleted();}}// 状況変化を購読者に通知するprivate void Publish(Position state) {foreach (var observer in _observers) {observer.OnNext(state);}}// observer(購読者) が通知を受け取れるようにするpublic IDisposable Subscribe(IObserver<;Position>; observer) {_observers.Add(observer);return observer as IDisposable;}}
幅優先探索で解く
*public IEnumerable<;Direction>; Solve(Maze maze) {_maze = maze;var tracks = _Solve();return tracks.GetDirectionPath();}
解く。必ず解が存在することが前提。
キューの先頭から経路情報取り出す
*var tracks = queu.Dequeue();
次に進む位置を求める
*var nextpos = Maze.GetPosition(currentPosition, direction);
*switch (_maze.Look(nextpos)) {case Place.Goal:return tracks;case Place.Path:if (!AlreadyPassed(tracks, nextpos)) {// 通路でまだ通っていない場所ならば、キューに入れて覚えてくvar clone = tracks.Clone();clone.Add(nextpos, direction);queu.Enqueue(clone);Publish(nextpos);}break;}
その場所の種類を調べる
通路でまだ通っていない場所ならば、キューに入れて覚えてく
*var clone = tracks.Clone();
壁とStart位置ならば何もせずに、次の方向を調べる
*}
*public IEnumerable<;Direction>; Directions(Direction lastDirection) {if (lastDirection != Direction.None)yield return lastDirection;if (lastDirection != Direction.South)yield return Direction.South;if (lastDirection != Direction.East)yield return Direction.East;if (lastDirection != Direction.North)yield return Direction.North;if (lastDirection != Direction.West)yield return Direction.West;}
４つの方向を列挙する （できるだけ直進するように直前の方向を最初にする)
*private bool AlreadyPassed(Tracks tracks, Position pos) {return tracks.GetPositionPathh().Any(p =>; p.X == pos.X &amp;&amp; p.Y == pos.Y);}
指定した方向は既に通った場所か
このプログラムでは購読者は、Viewerオブジェクトの一つだけ。
*private List<;IObserver<;Position>;>; _observers = new List<;IObserver<;Position>;>;();
*private void Complete() {foreach (var observer in _observers) {observer.OnCompleted();}}
終了を通知する
*private void Publish(Position state) {foreach (var observer in _observers) {observer.OnNext(state);}}
状況変化を購読者に通知する
*public IDisposable Subscribe(IObserver<;Position>; observer) {_observers.Add(observer);return observer as IDisposable;}
observer(購読者) が通知を受け取れるようにする
*public void OnNext(Position relative) {// 絶対位置を求めvar pos = _maze.GetAbsolutePosition(relative);// 足跡を残すConsole.SetCursorPosition(pos.X, pos.Y);Console.Write('.');Console.SetCursorPosition(pos.X, pos.Y);System.Threading.Thread.Sleep(100);}
状態が変化した （引数 relative は、相対位置)
絶対位置を求め
*var pos = _maze.GetAbsolutePosition(relative);
足跡を残す
*Console.SetCursorPosition(pos.X, pos.Y);
*public void Replay(IEnumerable<;Direction>; path) {var current = new Position { X = 0, Y = 0 };foreach (var d in path) {current = Maze.GetPosition(current, d);var pos = _maze.GetAbsolutePosition(current);Console.SetCursorPosition(pos.X, pos.Y);Console.Write('.');Console.SetCursorPosition(pos.X, pos.Y);System.Threading.Thread.Sleep(80);}Console.SetCursorPosition(0, _maze.YSize + 1);}
リプレイする
*public void Print() {for (int y = 0; y <; _maze.YSize; y++) {for (int x = 0; x <; _maze.XSize; x++) {Console.Write(_maze[x, y]);}Console.WriteLine();}}
迷路をConsoleに表示する

*public int ID { get; set; }
ID は自動で主キー
*// For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940*public void ConfigureServices(IServiceCollection services)
This method gets called by the runtime. Use this method to add services to the container.
*{services.AddMvc();services.AddDbContext<;ShopDbContext>;();}
For more information on how to configure your application, visit https:go.microsoft.com/fwlink/?LinkID=398940
*{if (env.IsDevelopment())app.UseDeveloperExceptionPage();app.UseMvc();app.Run(async (context) =>; await context.Response.WriteAsync("Hello World!"));}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*using (var context = new BooksDbContext(options))
インメモリ DB を使うオプション設定を渡す
サービスクラスをインスタンス化しデータベースコンテキストを DI
*var service = new BooksService(context);
*{Assert.Equal(1, context.Books.Count());var book = context.Books.Single(e =>; e.ISBN == "978-4150117481");Assert.Equal("月は無慈悲な夜の女王", book.Title);}
再びインメモリ DB から値を取り出してテスト

割愛
*}
呼び出し
*AsyncClientStreamingCall<;string, string>; call1;
IAsyncRequestStreamingCall&lt;TRequest&gt; の拡張メソッドとして定義すれば次のように呼び出せます
*await call1.AsRequestStreamingCall().SendRequestsAndCompleteAsync(requests).ConfigureAwait(false);

*string[] fileDirArray = { @"C:\hoge.jpg", @"C:\fuga.jpg" };
添付したいファイルのパス
添付ファイル実体配列
*MessageCreateThreadTypeFile[] files = new MessageCreateThreadTypeFile[0];
添付ファイル情報配列
*contentFile[] cFiles = new contentFile[0];
*for (int cnt = 0; cnt <; fileDirArray.Length; cnt++)*{
ファイル数分ループ
ファイル実体
------------------
1.添付するファイルをバイト配列にする
*FileStream fs = new FileStream(fileDir, FileMode.Open, FileAccess.Read);
2.ファイル設定
*MessageCreateThreadTypeFile file = new MessageCreateThreadTypeFile();
3.添付ファイル配列に追加
*Array.Resize(ref files, cnt + 1);
ファイル情報
------------------
1.ファイル情報設定
*contentFile cFile = new contentFile();
2.添付ファイル配列に追加
*Array.Resize(ref cFiles, cnt + 1);
添付ファイル実体配列、添付ファイル情報配列をそれぞれセット
*messageThreadType.file = files;

イメージの読み込み
*var loadImage = Cv2.ImRead(filename, ImreadModes.Color);
HSVカラーに変換
*var hsvImage = loadImage.CvtColor(ColorConversionCodes.BGR2HSV, 3);
処理対象だけを抜き出す為のマスク
HSVcolor [0] 色相
HSVcolor [1] 彩度
HSVcolor [2] 輝度
手動で画像加工した時に真っ白BGR(255,255,255)、真っ黒(0,0,0) がいると閾値がずれてしまったので除去する。
*var mask = hsvImage.InRange(new Scalar(5, 5, 5), new Scalar(250, 250, 250));
マスクを通した結果画像を取得
*var res = new Mat();
グレースケール変換
*var gray = res.CvtColor(ColorConversionCodes.BGR2GRAY);
2値化
*var binImg = gray.Threshold(0, 255, ThresholdTypes.Otsu);
*var contours = new Mat[] { };
画像内の輪郭を抽出
*{//BoundingRectだと傾いたQRコードが検出できない？//var rect = a.BoundingRect();//var area = Math.Abs(Cv2.ContourArea(a));//var area_ratio = area / (rect.Width * rect.Height);//var rect_ratio = ((rect.Size.Width <; rect.Size.Height) ?//            (double)rect.Size.Width / (double)rect.Size.Height ://            (double)rect.Size.Height / (double)rect.Size.Width);//return area >; 10 &amp;&amp; area_ratio >; 0.7 &amp;&amp; rect_ratio >; 0.9; // 正方形っぽいものを探してvar rect = a.MinAreaRect();var area = Math.Abs(Cv2.ContourArea(a));var rect_ratio = ((rect.Size.Width <; rect.Size.Height) ?rect.Size.Width / rect.Size.Height :rect.Size.Height / rect.Size.Width);//この辺の数字は適宜調整してくださいreturn area >; 10 &amp;&amp; !double.IsNaN(rect_ratio) &amp;&amp; !double.IsInfinity(rect_ratio) &amp;&amp; rect_ratio >; 0.7;});
正方形っぽいものを抽出する
BoundingRectだと傾いたQRコードが検出できない？
var rect = a.BoundingRect();
var area = Math.Abs(Cv2.ContourArea(a));
var area_ratio = area / (rect.Width * rect.Height);
var rect_ratio = ((rect.Size.Width &lt; rect.Size.Height) ?
(double)rect.Size.Width / (double)rect.Size.Height :
(double)rect.Size.Height / (double)rect.Size.Width);
return area &gt; 10 &amp;&amp; area_ratio &gt; 0.7 &amp;&amp; rect_ratio &gt; 0.9;  正方形っぽいものを探して
*var rect = a.MinAreaRect();
この辺の数字は適宜調整してください
*return area >; 10 &amp;&amp; !double.IsNaN(rect_ratio) &amp;&amp; !double.IsInfinity(rect_ratio) &amp;&amp; rect_ratio >; 0.7;
正方形らしき輪郭は見つからなかったので
*return null;
自らを含め3つの矩形を内包した矩形を探す = ファインダパターンの検出
黒、白、黒の3つの輪郭の最外郭が検出できる
*var finderPattarn = squares.Where(a =>; squares.Count(b =>; a.BoundingRect().Contains(b.BoundingRect())) == 3).ToArray();
ファインダパターンは3つのコーナーに存在するはず
3つ無い時はQRコードが画像中に無いと考える。
*return null;
ファインダパターンの頂点を含む矩形 = QRコードの輪郭
*var qrCodeContour = Cv2.MinAreaRect(finderPattarn.Select(a =>; a.MinAreaRect().Points()).SelectMany(b =>; b));
検出した輪郭を描画する為のイメージ(確認用のため不要です)
*var imgDetect = Cv2.ImRead(filename, ImreadModes.Color);
検出した輪郭を描画する。
*Cv2.DrawContours(imgDetect, contours, -1, Scalar.Gold);
正方形らしきものの輪郭を描画する。
*Cv2.DrawContours(imgDetect, squares, -1, Scalar.Blue);
ファインダパターンの輪郭を描画する。
*Cv2.DrawContours(imgDetect, finderPattarn, -1, Scalar.Red);
*for (int i = 0; i <; 4; i++)*Cv2.Line(imgDetect, qrCodeContour.Points()[i], qrCodeContour.Points()[(i + 1) % 4], Scalar.LimeGreen);
QRコードの輪郭を描画する
結果の表示
*Cv2.ImShow("contuours", imgDetect[qrCodeContour.BoundingRect()]);
トリミングしたビットマップを取得
*return OpenCvSharp.Extensions.BitmapConverter.ToBitmap(loadImage[qrCodeContour.BoundingRect()]);

*System.Console.Out.WriteLine(FormatPhoneNumber("08001112222"));
0800:OK

*.ToList();
ToList でクエリが実行されるため ToList は必要
*public ActionResult<;PostItem>; Post([FromBody] PostItem postItem) {postItem.PostDateTime = DateTime.Now;BbsContext.PostItems.Add(postItem);BbsContext.SaveChanges();return postItem;}
POST api/bbs

*if (messages[0] == "onBeginningOfSpeech")*{
ユーザーが話すのを開始した際のコールバック
*if (messages[0] == "onRmsChanged")*{
認識した音量変化のコールバック
*if (messages[0] == "onEndOfSpeech")*{
ユーザーが話すのを終了した際のコールバック
*if (messages[0] == "onResults")*{
認識結果の準備が完了したコールバック

*var ray = new Ray(animator.GetIKPosition(AvatarIKGoal.RightFoot), -transform.up);*RaycastHit hit;
右足
weightはとりあえず1で固定しておく（0f:元のアニメーション,1f:IKを完全に反映）
*animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, 1);
*ray = new Ray(animator.GetIKPosition(AvatarIKGoal.LeftFoot), -transform.up);*if (Physics.Raycast(ray, out hit, rayRange, LayerMask.GetMask(fieldLayerName)))
左足

*Console.WriteLine(AppState.Active.getViewStr());
&lt;- メソッド呼び出し

*string newTodo;
private フィールドを追加する
テキストボックスが空なら追加しない
*return;
*todos.Add(new TodoItem { Title = newTodo });
Todo リストに新しい Todo を追加する
テキストボックスを空に戻す。
*newTodo = "";

*private double _weight    { get; set; }
体重

*this.socket = IO.Socket("http:
localhost:3000");

*newAngle = MainCamera.transform.localEulerAngles;*lastMousePosition = Input.mousePosition;
マウスクリック開始(マウスダウン)時にカメラの角度を保持(Z軸には回転させないため).
マウスの移動量分カメラを回転させる.
*newAngle.y += (Input.mousePosition.x - lastMousePosition.x) * 0.1f;

*app.UseCookiePolicy();
2.1 コードベース追加

*{prePos = prePos2;prePos2 = transform.position;}
Update is called once per frame
*{var meshCut = other.gameObject.GetComponent<;MeshCut>;();if (meshCut == null) { return; }var cutPlane = new Plane (Vector3.Cross(transform.forward.normalized, prePos - transform.position).normalized, transform.position);meshCut.Cut(cutPlane);}
このコンポーネントを付けたオブジェクトのCollider.IsTriggerをONにすること！

*{// 変換後のenumenum Status{Success = 0,Error = 99,}static void Main(string[] args){{var convertedText = ConvertToTextType<;int>;("99");Console.WriteLine(convertedText.GetType().Name + ", " + convertedText);// Int32, 99}{var convertedText = ConvertToTextType<;Status>;("99");Console.WriteLine(convertedText.GetType().Name + ", " + convertedText);// Status, Error}}// text を 型 T に変換するメソッドprivate static object ConvertToTextType<;T>;(string text){// ここに何か実装したい}}
結果確認用プログラム
*{Success = 0,Error = 99,}
変換後のenum
*{var convertedText = ConvertToTextType<;Status>;("99");Console.WriteLine(convertedText.GetType().Name + ", " + convertedText);// Status, Error}
Int32, 99
*{// ここに何か実装したい}
text を 型 T に変換するメソッド
ここに何か実装したい
*}
*{if (typeof(T) == typeof(int)){var canConvert = int.TryParse(text, out int result);if (!canConvert){throw new Exception("エラー");}return result;}else if (typeof(T).IsEnum){var canConvert = Enum.TryParse(text, out T result);if (!canConvert){throw new Exception("エラー");}return result;}return default(T);}
text を 型 T に変換するメソッド
*{if (typeof(T) == typeof(int)){var converter = new Int32Converter();return converter.ConvertFrom(text);}else if (typeof(T).IsEnum){var converter = new EnumConverter(typeof(T));return converter.ConvertFrom(text);}return default(T);}
text を 型 T に変換するメソッド
*{var converter = TypeDescriptor.GetConverter(typeof(T));return converter.ConvertFrom(text);}
text を 型 T に変換するメソッド
string型からMyClass型への変換
*var converter = TypeDescriptor.GetConverter(typeof(MyClass));
*{public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value){if (value is string){return new MyClass { X = (string)value };}return base.ConvertFrom(context, culture, value);}}
自作Converter

*{return new DateTime(year, month, day);}
例
*{return new DateTime(year, month, day);}
例
*{return new DateTime(year, month, day);}
例
*{return new DateTime(year, month, day);}
例
*{return new DateTime(year, month, day);}
例

*{terrainData = GetComponent<;Terrain>;().terrainData;StartCoroutine(UpdateTerrainCoroutine());}
Use this for initialization
*{terrainData = GetComponent<;Terrain>;().terrainData;StartCoroutine(UpdateTerrainCoroutine());//Debug.Log(terrainData.heightmapHeight);renderArea = 50;t += 1;}
Update is called once per frame

*Edition[] Editions = new [] {new Edition { Code = 1, Text = "Home" },new Edition { Code = 2, Text = "Pro" },new Edition { Code = 3, Text = "Enterprise" },};
"Edition" class has "int Code" and "string Text" properties.

*StreamWriter sw2 = new StreamWriter("hugahuga.csv", false, Encoding.GetEncoding("shift_jis"));*// ->; 例外 ArgumentException: 'shift_jis' is not a supported encoding name.
-&gt; OK
-&gt; 例外 ArgumentException: 'shift_jis' is not a supported encoding name.
*,,,

*{// client.Receive は ServerStreaming メソッドusing (var call = client.Receive(request, callOptions)){try{while (await call.ResponseStream.MoveNext().ConfigureAwait(false)){// レスポンスを受け取ったときの処理OnResponse(call.ResponseStream.Current);}catch (Exception ex){// 発生した例外に対する処理。キャンセルした場合も例外が発生します。}}}}
レスポンスストリームの読み込みが完了するまでブロックされるため、待機しないように実装する必要があります。
*{try{while (await call.ResponseStream.MoveNext().ConfigureAwait(false)){// レスポンスを受け取ったときの処理OnResponse(call.ResponseStream.Current);}catch (Exception ex){// 発生した例外に対する処理。キャンセルした場合も例外が発生します。}}}
client.Receive は ServerStreaming メソッド
レスポンスを受け取ったときの処理
*OnResponse(call.ResponseStream.Current);
発生した例外に対する処理。キャンセルした場合も例外が発生します。
*}
*{lock (m_Observers){m_Observers.Remove(observer);}};
dispose されたら監視オブジェクトを削除する
*{try{// 1. RPCメソッドを実行し、配信オブジェクトを生成します。using (observable = client.Receive(request, callOptions).ToObservable()){// 2. 監視オブジェクトを生成します。observer = GrpcObservable.CreateObserver<;Response>;(// レスポンスを受け取ったときの処理response =>; OnResponse(response)// 例外が発生したときの処理, ex =>; OnError(ex)// 完了したときの処理, () =>; OnComplete());// 3. 監視オブジェクトを渡して購読オブジェクトを受け取ります。subscriver = observable.Subscribe(observer);// 4. 監視を開始します。await observable.ObserveAsync().ConfigureAwait(false);}}catch (Exception ex){// 配信クラスでは発生した例外を再スローしています。}finally{// 配信クラスでは dispose 時に購読オブジェクトを解放しています。// if (subscriber!= null) {subscriber.Dispose();}}}
レスポンスストリームの読み込みが完了するまでブロックされるため、待機しないように実装する必要があります。
*{// 2. 監視オブジェクトを生成します。observer = GrpcObservable.CreateObserver<;Response>;(// レスポンスを受け取ったときの処理response =>; OnResponse(response)// 例外が発生したときの処理, ex =>; OnError(ex)// 完了したときの処理, () =>; OnComplete());// 3. 監視オブジェクトを渡して購読オブジェクトを受け取ります。subscriver = observable.Subscribe(observer);// 4. 監視を開始します。await observable.ObserveAsync().ConfigureAwait(false);}
1. RPCメソッドを実行し、配信オブジェクトを生成します。
2. 監視オブジェクトを生成します。
*observer = GrpcObservable.CreateObserver<;Response>;(
レスポンスを受け取ったときの処理
*response =>; OnResponse(response)
例外が発生したときの処理
*, ex =>; OnError(ex)
完了したときの処理
*, () =>; OnComplete()
3. 監視オブジェクトを渡して購読オブジェクトを受け取ります。
*subscriver = observable.Subscribe(observer);
4. 監視を開始します。
*await observable.ObserveAsync().ConfigureAwait(false);
配信クラスでは発生した例外を再スローしています。
*}
*// if (subscriber!= null) {subscriber.Dispose();}*}
配信クラスでは dispose 時に購読オブジェクトを解放しています。
5. 購読を終了するには購読オブジェクトを解放します。
*subscriber.Dispose();
2'. 新しい監視オブジェクトを生成します。
*var observer2 = GrpcObservable.CreateObserver<;Response>;(
レスポンスを受け取ったときの処理
*response =>; OnResponse2(response)
例外が発生したときの処理
*, ex =>; OnError2(ex)
完了したときの処理
*, () =>; OnComplete2()
3'. 新しい監視オブジェクトを渡して購読オブジェクトを受け取ります。
*var subscriver2 = observable.Subscribe(observer2);
*{try{// 1. RPCメソッドを実行し、配信オブジェクトを生成します。using (observable = client.Receive(callOptions).ToObservable()){// 2. 監視オブジェクトを生成します。observer = GrpcObservable.CreateObserver<;Response>;(// レスポンスを受け取ったときの処理response =>; OnResponse(response)// 例外が発生したときの処理, ex =>; OnError(ex)// 完了したときの処理, () =>; OnComplete());// 3. 監視オブジェクトを渡して購読オブジェクトを受け取ります。subscriver = observable.Subscribe(observer);// 4. 監視を開始します。await observable.ObserveAsync().ConfigureAwait(false);}}catch (Exception ex){// 配信クラスでは発生した例外を再スローしています。}finally{// 配信クラスでは dispose 時に購読オブジェクトを解放しています。// if (subscriber!= null) {subscriber.Dispose();}}}
レスポンスストリームの読み込みが完了するまでブロックされるため、待機しないように実装する必要があります。
*{// 2. 監視オブジェクトを生成します。observer = GrpcObservable.CreateObserver<;Response>;(// レスポンスを受け取ったときの処理response =>; OnResponse(response)// 例外が発生したときの処理, ex =>; OnError(ex)// 完了したときの処理, () =>; OnComplete());// 3. 監視オブジェクトを渡して購読オブジェクトを受け取ります。subscriver = observable.Subscribe(observer);// 4. 監視を開始します。await observable.ObserveAsync().ConfigureAwait(false);}
1. RPCメソッドを実行し、配信オブジェクトを生成します。
2. 監視オブジェクトを生成します。
*observer = GrpcObservable.CreateObserver<;Response>;(
レスポンスを受け取ったときの処理
*response =>; OnResponse(response)
例外が発生したときの処理
*, ex =>; OnError(ex)
完了したときの処理
*, () =>; OnComplete()
3. 監視オブジェクトを渡して購読オブジェクトを受け取ります。
*subscriver = observable.Subscribe(observer);
4. 監視を開始します。
*await observable.ObserveAsync().ConfigureAwait(false);
配信クラスでは発生した例外を再スローしています。
*}
*// if (subscriber!= null) {subscriber.Dispose();}*}
配信クラスでは dispose 時に購読オブジェクトを解放しています。
5. リクエストを書き込む。
*await observable.WriteRequestAsync(request).ConfigureAwait(false);
6. リクエストの完了を通知する。
*await observable.CompleteRequestAsync().ConfigureAwait(false);
7. 購読を終了するには購読オブジェクトを解放します。
*subscriber.Dispose();
2'. 新しい監視オブジェクトを生成します。
*var observer2 = GrpcObservable.CreateObserver<;Response>;(
レスポンスを受け取ったときの処理
*response =>; OnResponse2(response)
例外が発生したときの処理
*, ex =>; OnError2(ex)
完了したときの処理
*, () =>; OnComplete2()
3'. 新しい監視オブジェクトを渡して購読オブジェクトを受け取ります。
*var subscriver2 = observable.Subscribe(observer2);

ScreenPointToRayに因るベクトルの取得
*Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);

*{
コンストラクタで各種情報を設定
ジョブをスケジュール
*job_handles[ i ] = job_router.Schedule();
ジョブを開始
*JobHandle.ScheduleBatchedJobs();
順番に経路探索ジョブを待って、結果を作成
*Route[] results = new Route[ goals.Length ];
ジョブ待ち
*job_handles[ i ].Complete();
結果をルートに変換
*var route = new Route();

開始時の現在時刻を取得しておく
*DateTime dt = DateTime.Now;
郵便番号データのコンテキストを生成
*IEnumerable<;string[]>; context = Context(
*foreach (string[] result in context.AsParallel())*{
結果をコンソールに出す
開始時の現在時刻を表示
*Console.WriteLine(dt);
終了時の現在時刻を表示
*Console.WriteLine(DateTime.Now);
指定されたCSVファイルへのコンテキストを生成する
*public static IEnumerable<;string[]>; Context(
開始時の現在時刻を取得しておく
*DateTime dt = DateTime.Now;
*for (int i = 0; i <; lines; i++)*{
結果をコンソールに出す
*{using (TextFieldParser parser = new TextFieldParser(stream, Encoding.GetEncoding(932))){parser.TextFieldType = FieldType.Delimited;parser.Delimiters = new[] { "," };parser.HasFieldsEnclosedInQuotes = true;parser.TrimWhiteSpace = false;string[] fields = parser.ReadFields();// 結果をコンソールに出す(列数70固定と仮定する)for (int j = 0; j <; 70; j++){Console.Write(fields[j] + " ");}Console.WriteLine("");}}
１行のstringをstream化してTextFieldParserで処理する
*for (int j = 0; j <; 70; j++)*{
結果をコンソールに出す(列数70固定と仮定する)
開始時の現在時刻を表示
*Console.WriteLine(dt);
終了時の現在時刻を表示
*Console.WriteLine(DateTime.Now);
開始時の現在時刻を取得しておく
*DateTime dt = DateTime.Now;
*{using (TextFieldParser parser = new TextFieldParser(stream, Encoding.GetEncoding(932))){parser.TextFieldType = FieldType.Delimited;parser.Delimiters = new[] { "," };parser.HasFieldsEnclosedInQuotes = true;parser.TrimWhiteSpace = false;string[] fields = parser.ReadFields();// 結果をコンソールに出す(列数70固定と仮定する)for (int j = 0; j <; 70; j++){Console.Write(fields[j] + " ");}Console.WriteLine("");}}
１行のstringをstream化してTextFieldParserで処理する
*for (int j = 0; j <; 70; j++)*{
結果をコンソールに出す(列数70固定と仮定する)
開始時の現在時刻を表示
*Console.WriteLine(dt);
終了時の現在時刻を表示
*Console.WriteLine(DateTime.Now);
開始時の現在時刻を取得しておく
*DateTime dt = DateTime.Now;
郵便番号データのコンテキストを生成
*IEnumerable<;string[]>; context = Context(
*foreach (string[] result in context.AsParallel())*{
結果をコンソールに出す
*for (int j = 0; j <; 70; j++)*{
結果をコンソールに出す(列数70固定と仮定する)
開始時の現在時刻を表示
*Console.WriteLine(dt);
終了時の現在時刻を表示
*Console.WriteLine(DateTime.Now);
指定されたCSVファイルへのコンテキストを生成する
*public static IEnumerable<;string[]>; Context(

*for (int i = angle * 6, j = 0; i <; triangles.Length; i += 6, j += 2)
上下面

*float size = 2000;
NOTE!
*void Update () {transform.Translate (0, 0, speed);if (this.transform.position.z + size <; 0) {Debug.Log("out of display");this.transform.Translate(0, 0, size * 2);}}
Update is called once per frame
*{transform.Translate(0, 0, speed);if (this.transform.position.z >;500){Debug.Log("out of display");this.transform.Translate(0, 0, -1000 );}}
Update is called once per frame

*Dealer.Take(faceUp: false);
2枚目は裏向き
*WriteLine($"<;<; {Player.Name} turn! >;>;");
ユーザーのターン
*WriteLine($"<;<; {Dealer.Name} turn! >;>;");
ディーラーのターン
判定
*WriteLine("<;<; Result >;>;");
*bool ConfrimHitOrStand(string message, char hit, char stand) {while (true) {Write($"{message} [{hit}/{stand}]");var key = ReadKey().KeyChar;WriteLine();if (key == hit)return true;if (key == stand)return false;WriteLine($"Invalid key. Please input {hit} or {stand}.");}}
ヒット・スタンド確認
*void Won() {WriteLine($"{Player.Name} won. Congrats!");End();}
勝ち
*void Lost() {WriteLine($"{Player.Name} lost.");End();}
負け
*void Drawn() {WriteLine("This game was drawn...");End();}
引き分け
*void End() {WriteLine("To close, press any key.");ReadKey(intercept: true);Environment.Exit(0);}
終了

全ての候補の転置インデックスを作成する
*var indexs = choices.Select(choice =>; new InversedIndex(choice));
初期のPathを作成する
*var paths = new List<;Path>;();
*for (int i = 0; i <; search.Count; i++)*{
Searchの全文字列を各Pathに渡してPathを更新する
一番スコアの高いPathを採択
*var selectedChoice = paths.OrderByDescending(Path =>; Path.Score()).First().Source();

*MainLabel.Content = "Hello World!";
ここ

*float ObjectHeight;
オブジェクトの高さ
*{m_MainCamera = GameObject.Find("Main Camera").GetComponent<;Camera>;();//カメラ領域の左下の座標を取得BottomLeft = m_MainCamera.ScreenToWorldPoint(Vector3.zero);// カメラ領域の右上の座標を取得TopRight = m_MainCamera.ScreenToWorldPoint(new Vector3(Screen.width, Screen.height, 0.0f));//オブジェクトの幅・高さを取得ObjectWidth = this.GetComponent<;MeshRenderer>;().bounds.size.x;ObjectHeight = this.GetComponent<;MeshRenderer>;().bounds.size.y;//カメラの領域の幅・高さをワールド座標系数値で取得Width = (TopRight.x - BottomLeft.x) ;Height = (TopRight.y - BottomLeft.y) ;//上記二値からスケール（ローカル座標系）を調整transform.localScale = new Vector3(Width/ ObjectWidth, Height/ ObjectHeight, 0);}
Start is called before the first frame update
カメラ領域の左下の座標を取得
*BottomLeft = m_MainCamera.ScreenToWorldPoint(Vector3.zero);
カメラ領域の右上の座標を取得
*TopRight = m_MainCamera.ScreenToWorldPoint(new Vector3(Screen.width, Screen.height, 0.0f));
オブジェクトの幅・高さを取得
*ObjectWidth = this.GetComponent<;MeshRenderer>;().bounds.size.x;
カメラの領域の幅・高さをワールド座標系数値で取得
*Width = (TopRight.x - BottomLeft.x) ;
*transform.localScale = new Vector3(Width/ ObjectWidth, Height/ ObjectHeight, 0);*}
上記二値からスケール（ローカル座標系）を調整

Following取得
*var following = (await token.Friends.IdsAsync()).ToArray();
ListId(ぶち抜いたListIdを代入)
var listid = 5554560721;値変えてね
100人ずつ追加
*var n = 100;
2秒間隔で実行。フォローが多い場合はこの値を調整して手加減する
*await Task.Delay(2000);

*while (sty.Count != 0)*{
int ct = 0;debug用
*if (y + i <; 8 &amp;&amp; x + i <; 8 &amp;&amp; map[y + i, x + i] == 'Q') return false;*if (y - i >;= 0 &amp;&amp; x + i ; 8 &amp;&amp; map[y - i, x + i] == 'Q') return false;
if (map[y, i] == 'Q') return false;

*frame[14] = sw ? (byte)0x30 : (byte)0x31;
0x30がスイッチオン 0x31がスイッチオフ

エラー
*var number = testList[0];
正常に動作する
*var number = testList[0];
キャスト変換により値が変更可能
*((List<;int>;)testList)[0] = 100;
キャスト変換により値が変更可能
*((List<;int>;)testList)[0] = 200;
ReadOnlyCollection&lt;T&gt;オブジェクトにする
*Test(readOnlyLists.AsReadOnly());
エラー
実行時,System.InvalidCastExceptionが発生する
*((List<;int>;)testList)[0] = 200;

*listBucketResponse.Dump();
バケット一覧を表示
ListObjects のパラメータには ListObjectsRequest クラスを使うこともできるが、
上記のようにクラスを作成せずに使える場合もある。
*}
*{var content = await sr.ReadToEndAsync();Console.WriteLine(content);}
StreamReader を使って ResponseStream から文字列を読む
次のようにファイルに保存することもできる。
getObjectResponse.WriteResponseStreamToFile(@"C:\Temp\test");

※StreamReader と WriteResponseStreamToFile を同時に使うことはできない。
*}

*public Component(){....}
コンストラクタ
*public void update(){....}
更新
1.こういう書き方はせず
*private string Name;
*string Name { get; set; }
2.こういう書き方をする
*if (!Util.IsRegisteredLicense(Name))*return false;
Utilのライセンスの判定処理がうまくいかない場合があるので, 一旦マスク

*sphereOnGui.Rotate ();
黄色い球
*this.transform.RotateAround (*center,
Rotate around the center of (0,0,0)

*[Tooltip("The service URL (optional). This defaults to \"https:
api.us-south.speech-to-text.watson.cloud.ibm.com\"")]

*//  See the License for the specific language governing permissions and*//  limitations under the License.
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*{using DurableTask.Core;using Microsoft.WindowsAzure.Storage.Table;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Xml.Linq;/// <;summary>;/// OrchestrationInstanceStatusQueryBuilder is a builder to create a StorageTable Query/// <;/summary>;internal class OrchestrationInstanceStatusQueryCondition{public IEnumerable<;OrchestrationStatus>; RuntimeStatus { get; set; }public DateTime CreatedTimeFrom { get; set; }public DateTime CreatedTimeTo { get; set; }public TableQuery<;T>; ToTableQuery<;T>;()where T : TableEntity, new(){var query = new TableQuery<;T>;();if (!((RuntimeStatus == null || (!RuntimeStatus.Any())) &amp;&amp; CreatedTimeFrom == default(DateTime) &amp;&amp; CreatedTimeTo == default(DateTime))){query.Where(GetConditions());}return query;}private string GetConditions(){var conditions = new List<;string>;();if (default(DateTime) != this.CreatedTimeFrom){conditions.Add(TableQuery.GenerateFilterConditionForDate("CreatedTime", QueryComparisons.GreaterThanOrEqual, new DateTimeOffset(this.CreatedTimeFrom)));}if (default(DateTime) != this.CreatedTimeTo){conditions.Add(TableQuery.GenerateFilterConditionForDate("CreatedTime", QueryComparisons.LessThanOrEqual, new DateTimeOffset(this.CreatedTimeTo)));}if (this.RuntimeStatus != null &amp;&amp; this.RuntimeStatus.Any()){var runtimeCondition = this.RuntimeStatus.Select(x =>; TableQuery.GenerateFilterCondition("RuntimeStatus", QueryComparisons.Equal, x.ToString())).Aggregate((a, b) =>; TableQuery.CombineFilters(a, TableOperators.Or, b));if (runtimeCondition.Count() != 0){conditions.Add(runtimeCondition);}}if (conditions.Count == 1){return conditions[0];}else{return conditions.Aggregate((a, b) =>; TableQuery.CombineFilters(a, TableOperators.And, b));}}/// <;summary>;/// Parse is a factory method of the OrchestrationInstanceStatusConditionQuery/// <;/summary>;/// <;param name="createdTimeFrom">;CreatedTimeFrom<;/param>;/// <;param name="createdTimeTo">;CreatedTimeTo<;/param>;/// <;param name="runtimeStatus">;RuntimeStatus<;/param>;/// <;returns>;<;/returns>;public static OrchestrationInstanceStatusQueryCondition Parse(DateTime createdTimeFrom, DateTime? createdTimeTo, IEnumerable<;OrchestrationStatus>; runtimeStatus){var condition = new OrchestrationInstanceStatusQueryCondition();condition.CreatedTimeFrom = createdTimeFrom;condition.CreatedTimeTo = (createdTimeTo != null) ? (DateTime)createdTimeTo : default(DateTime);condition.RuntimeStatus = runtimeStatus;return condition;}}}
----------------------------------------------------------------------------------
*//  See the License for the specific language governing permissions and*//  limitations under the License.
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*{using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using DurableTask.AzureStorage.Tracking;using DurableTask.Core;using DurableTask.ServiceBus.Tracking;using Microsoft.VisualStudio.TestTools.UnitTesting;[TestClass]public class OrchestrationInstanceStatusQueryConditionTest{[TestMethod]public void OrchestrationInstanceQuery_RuntimeStatus(){var runtimeStatus = new OrchestrationStatus[] { OrchestrationStatus.Running };var condition = new OrchestrationInstanceStatusQueryCondition{RuntimeStatus = runtimeStatus};var query = condition.ToTableQuery<;OrchestrationInstanceStatus>;();Assert.AreEqual("RuntimeStatus eq 'Running'", query.FilterString);}[TestMethod]public void OrchestrationInstanceQuery_CreatedTime(){var condition = new OrchestrationInstanceStatusQueryCondition{CreatedTimeFrom = new DateTime(2018, 1, 10, 10, 10, 10),CreatedTimeTo = new DateTime(2018, 1, 10, 10, 10, 50)};var result = condition.ToTableQuery<;OrchestrationInstanceStatus>;().FilterString;Assert.AreEqual("(CreatedTime ge datetime'2018-01-10T01:10:10.0000000Z') and (CreatedTime le datetime'2018-01-10T01:10:50.0000000Z')", condition.ToTableQuery<;OrchestrationInstanceStatus>;().FilterString);}[TestMethod]public void OrchestrationInstanceQuery_CreatedTimeOnly(){var condition = new OrchestrationInstanceStatusQueryCondition{CreatedTimeFrom = new DateTime(2018, 1, 10, 10, 10, 10),CreatedTimeTo = default(DateTime),RuntimeStatus = new List<;OrchestrationStatus>;(),};var result = condition.ToTableQuery<;OrchestrationInstanceStatus>;().FilterString;Assert.AreEqual("CreatedTime ge datetime'2018-01-10T01:10:10.0000000Z'", condition.ToTableQuery<;OrchestrationInstanceStatus>;().FilterString);}[TestMethod]public void OrchestrationInstanceQuery_CreatedTimeVariations(){var condition = new OrchestrationInstanceStatusQueryCondition{CreatedTimeFrom = new DateTime(2018, 1, 10, 10, 10, 10)};Assert.AreEqual("CreatedTime ge datetime'2018-01-10T01:10:10.0000000Z'", condition.ToTableQuery<;OrchestrationInstanceStatus>;().FilterString);condition = new OrchestrationInstanceStatusQueryCondition{CreatedTimeTo = new DateTime(2018, 1, 10, 10, 10, 50)};Assert.AreEqual("CreatedTime le datetime'2018-01-10T01:10:50.0000000Z'", condition.ToTableQuery<;OrchestrationInstanceStatus>;().FilterString);}[TestMethod]public void OrchestrationInstanceQuery_Combination(){var runtimeStatus = new OrchestrationStatus[] { OrchestrationStatus.Running };var condition = new OrchestrationInstanceStatusQueryCondition{RuntimeStatus = runtimeStatus,CreatedTimeFrom = new DateTime(2018, 1, 10, 10, 10, 10),CreatedTimeTo = new DateTime(2018, 1, 10, 10, 10, 50)};Assert.AreEqual("((CreatedTime ge datetime'2018-01-10T01:10:10.0000000Z') and (CreatedTime le datetime'2018-01-10T01:10:50.0000000Z')) and (RuntimeStatus eq 'Running')", condition.ToTableQuery<;OrchestrationInstanceStatus>;().FilterString);}[TestMethod]public void OrchestrationInstanceQuery_NoParameter(){var condition = new OrchestrationInstanceStatusQueryCondition();var query = condition.ToTableQuery<;OrchestrationInstanceStatus>;();Assert.IsNull(query.Expression);}[TestMethod]public void OrchestrationInstanceQuery_MultipleRuntimeStatus(){var runtimeStatus = new OrchestrationStatus[] { OrchestrationStatus.Running , OrchestrationStatus.Completed };var condition = new OrchestrationInstanceStatusQueryCondition{RuntimeStatus = runtimeStatus,CreatedTimeFrom = new DateTime(2018, 1, 10, 10, 10, 10),CreatedTimeTo = new DateTime(2018, 1, 10, 10, 10, 50)};Assert.AreEqual("((CreatedTime ge datetime'2018-01-10T01:10:10.0000000Z') and (CreatedTime le datetime'2018-01-10T01:10:50.0000000Z')) and ((RuntimeStatus eq 'Running') or (RuntimeStatus eq 'Completed'))", condition.ToTableQuery<;OrchestrationInstanceStatus>;().FilterString);}[TestMethod]public void OrchestrationInstanceQuery_Parse(){var runtimeStatus = new List<;OrchestrationStatus>;();runtimeStatus.Add(OrchestrationStatus.Running);var condition = OrchestrationInstanceStatusQueryCondition.Parse(new DateTime(2018, 1, 10, 10, 10, 10), new DateTime(2018, 1, 10, 10, 10, 50), runtimeStatus);Assert.AreEqual("((CreatedTime ge datetime'2018-01-10T01:10:10.0000000Z') and (CreatedTime le datetime'2018-01-10T01:10:50.0000000Z')) and (RuntimeStatus eq 'Running')", condition.ToTableQuery<;OrchestrationInstanceStatus>;().FilterString);}[TestMethod]public void OrchestrationInstanceQuery_ParseOptional(){var runtimeStatus = new List<;OrchestrationStatus>;();runtimeStatus.Add(OrchestrationStatus.Running);var condition = OrchestrationInstanceStatusQueryCondition.Parse(default(DateTime), null, runtimeStatus);var query = condition.ToTableQuery<;OrchestrationInstanceStatus>;();Assert.AreEqual("RuntimeStatus eq 'Running'", query.FilterString);}}}
----------------------------------------------------------------------------------

*this[index] = new T();
初期値
*public virtual IEnumerable<;int>; GetAllIndexes() {for (int y = 1; y <;= this.YSize; y++) {for (int x = 1; x <;= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する
*public virtual IEnumerable<;int>; EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index) &amp;&amp; this[index] != null; index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む
(x,y)から右(水平)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Horizontal(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Virtical(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantR(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantL(int x, int y)
*_combinations = Combination.Enumerate(new int[] { 1, 2, 3, 4, 5, 6 }, 2, false)
重複無しの組み合わせを求める
まずは、1行目から黒を置いてゆく
*InnerSolve(1, Stone.Black);
*public void InnerSolve(int y, Stone stone) {if (y == 7) {if (stone == Stone.Black)// 今度は、１行目から白を置いてゆくInnerSolve(1, Stone.White);else if (stone == Stone.White) {// 黒白両方置き終わった（解が見つかったので通知する)Publish(board);}return;}// y行にstoneを２つずつ置くforeach (var combi in _combinations) {int a = combi[0];int b = combi[1];if (board[a, y] != Stone.Empty || board[b, y] != Stone.Empty)continue;board[a, y] = stone;board[b, y] = stone;try {if (board.IsCorrect(a, y, stone) &amp;&amp; board.IsCorrect(b, y, stone)) {// 条件を満たしているので、次の行を処理する。InnerSolve(y + 1, stone);}} finally {// バックトラックするため、状態を戻す。board[a, y] = Stone.Empty;board[b, y] = Stone.Empty;}}return;}
ｙで指定した行にstone(White or Black)を置く
*else if (stone == Stone.White) {// 黒白両方置き終わった（解が見つかったので通知する)Publish(board);}
今度は、１行目から白を置いてゆく
黒白両方置き終わった（解が見つかったので通知する)
*Publish(board);
*foreach (var combi in _combinations) {*int a = combi[0];
y行にstoneを２つずつ置く
条件を満たしているので、次の行を処理する。
*InnerSolve(y + 1, stone);
バックトラックするため、状態を戻す。
*board[a, y] = Stone.Empty;
*private void Publish(Board board) {foreach (var observer in observers)observer.OnNext(board);}
状況変化を知らせるために購読者に通知する
*private void Complete() {foreach (var observer in observers) {observer.OnCompleted();}}
終了を通知する
計算回数を少なくするために、事前に求めておく。
*Up = this.ToDirection(0, -1);
*internal bool IsCorrect(int x, int y, Stone piece) {return EightLines(x, y).All(line =>; line.Count(p =>; this[p] == piece) <;= 2);}
x,y 座標にpieceを置いたが、条件を満たしているか
*public IEnumerable<;int[]>; EightLines(int x, int y) {// 縦方向 （この配列要素順は問わない、以下も同様）yield return this.EnumerateIndexes(x, y, Up).Skip(1).Concat(EnumerateIndexes(x, y, Down)).ToArray();// 横方向yield return this.EnumerateIndexes(x, y, Left).Skip(1).Concat(EnumerateIndexes(x, y, Right)).ToArray();// 右斜め４５％  （＼）yield return this.EnumerateIndexes(x, y, UpperLeft).Skip(1).Concat(EnumerateIndexes(x, y, BottomRight)).ToArray();// 左斜め４５％ （／）yield return this.EnumerateIndexes(x, y, UpperRight).Skip(1).Concat(EnumerateIndexes(x, y, BottomLeft)).ToArray();// 下右右  （傾斜が緩い 右斜め）yield return this.EnumerateIndexes(x, y, UpperLeftLeft).Skip(1).Concat(EnumerateIndexes(x, y, BottomRightRight)).ToArray();// 下左左  （傾斜が緩い 左斜め）yield return this.EnumerateIndexes(x, y, UpperRightRight).Skip(1).Concat(EnumerateIndexes(x, y, BottomLeftLeft)).ToArray();// 下下右  （傾斜がきつい 右斜め）yield return this.EnumerateIndexes(x, y, UpperUpperLeft).Skip(1).Concat(EnumerateIndexes(x, y, BottomBottomRight)).ToArray();// 下下左 （傾斜がきつい 左斜め）yield return this.EnumerateIndexes(x, y, UpperUpperRight).Skip(1).Concat(EnumerateIndexes(x, y, BottomBottomLeft)).ToArray();}
indexで指定した位置を通る８本の線を列挙する
縦方向 （この配列要素順は問わない、以下も同様）
*yield return this.EnumerateIndexes(x, y, Up).Skip(1)
横方向
*yield return this.EnumerateIndexes(x, y, Left).Skip(1)
右斜め４５％  （＼）
*yield return this.EnumerateIndexes(x, y, UpperLeft).Skip(1)
左斜め４５％ （／）
*yield return this.EnumerateIndexes(x, y, UpperRight).Skip(1)
下右右  （傾斜が緩い 右斜め）
*yield return this.EnumerateIndexes(x, y, UpperLeftLeft).Skip(1)
下左左  （傾斜が緩い 左斜め）
*yield return this.EnumerateIndexes(x, y, UpperRightRight).Skip(1)
下下右  （傾斜がきつい 右斜め）
*yield return this.EnumerateIndexes(x, y, UpperUpperLeft).Skip(1)
下下左 （傾斜がきつい 左斜め）
*yield return this.EnumerateIndexes(x, y, UpperUpperRight).Skip(1)
item よりも前のものを除く （順列と組み合わせの違い)
重複を許さないので、unusedから item そのものも取り除く
*var unused = withRepetition ? items : items.SkipWhile(e =>; !e.Equals(item)).Skip(1).ToList();

*Debug.Log(target?.name);
`UnassignedReferenceException`が投げられる

*class Person {public string Name { get; set; }public static bool operator ==(Person lhs, Person rhs) {Console.WriteLine("called ==");return object.ReferenceEquals(lhs, rhs);}public static bool operator !=(Person lhs, Person rhs) {Console.WriteLine("called !=");return !object.ReferenceEquals(lhs, rhs);}}
本当はEqualsとかも実装するべき

*public DateTime End {  get { return Last + TimeSpan.FromTicks(1); } }
!&lt; 期間の最後の次
*if (ReferenceEquals(l, r))*{
参照が同じならtrue
どちらかがnullならfalse
objectでキャストしないと無限ループになるので注意
*if (((object)l == null) || ((object)r == null))

*Debug.Log(ReferenceEquals(target, null));
Falseと表示される

*public interface ISample {int Hoge();int Fuga(int n);int hogeProp { get; set; }}
モック作成元のインターフェース
*public void Returns() {// モックの作成var mockSample = Substitute.For<;ISample>;();// 戻り値設定mockSample.Hoge().ReturnsForAnyArgs(99);Assert.AreEqual(99, mockSample.Hoge());// 戻り値設定 (特定引数)mockSample.Fuga(0).Returns(99);Assert.AreEqual(99, mockSample.Fuga(0));// 処理呼び出しmockSample.Fuga(2).Returns(n =>; { Debug.Log("called."); return 0; });mockSample.Fuga(2);// 1回目は10, 2回目は20を返すmockSample.Fuga(1).Returns(10, 20);Assert.AreEqual(10, mockSample.Fuga(1));Assert.AreEqual(20, mockSample.Fuga(1));}
挙動を設定
モックの作成
*var mockSample = Substitute.For<;ISample>;();
戻り値設定
*mockSample.Hoge().ReturnsForAnyArgs(99);
戻り値設定 (特定引数)
*mockSample.Fuga(0).Returns(99);
*mockSample.Fuga(2).Returns(n =>; { Debug.Log("called."); return 0; });
処理呼び出し
1回目は10, 2回目は20を返す
*mockSample.Fuga(1).Returns(10, 20);
*public void Received() {// モックの作成var mockSample = Substitute.For<;ISample>;();// 呼び出されたことを確認mockSample.Hoge();mockSample.ReceivedWithAnyArgs().Hoge();// 呼び出されたことを確認  (特定引数)mockSample.Fuga(1);mockSample.Received().Fuga(1);mockSample.DidNotReceive().Fuga(2);// 呼び出された回数確認mockSample.ReceivedWithAnyArgs(1).Fuga(1);mockSample.Fuga(9);mockSample.Fuga(9);mockSample.ReceivedWithAnyArgs(3).Fuga(1);// プロパティが呼び出されたことを確認var dummy = mockSample.DidNotReceive().hogeProp;dummy = mockSample.hogeProp;dummy = mockSample.Received().hogeProp;mockSample.DidNotReceive().hogeProp = 1;mockSample.hogeProp = 1;mockSample.Received().hogeProp = 1;// 呼び出し状態クリアmockSample.ClearReceivedCalls();mockSample.Received(0).Hoge();}
呼び出し結果確認
モックの作成
*var mockSample = Substitute.For<;ISample>;();
呼び出されたことを確認
*mockSample.Hoge();
呼び出されたことを確認  (特定引数)
*mockSample.Fuga(1);
呼び出された回数確認
*mockSample.ReceivedWithAnyArgs(1).Fuga(1);
プロパティが呼び出されたことを確認
*var dummy = mockSample.DidNotReceive().hogeProp;
呼び出し状態クリア
*mockSample.ClearReceivedCalls();

*Console.WriteLine(outValue);
これはエラーにならない
後述のエラー2
*}

*while (progress)*{
クソオブクソ処理

ドメインを生成
*AppDomain ad = AppDomain.CreateDomain("TEST");
インスタンス生成
*Object instance = ad.CreateInstanceAndUnwrap("ClassLibrary1", "ClassLibrary1.Class1");
DLLのメソッド実行
*instance.test();
ドメインを開放
*AppDomain.Unload(ad);
*public string ExecuteName { get; set; }
取込処理名
*public string Arguments { get; set; }
取込処理の引数
*{InitializeComponent();}
コンストラクタ
*{// アセンブリ名を使ってクラス ライブラリーを動的に読み込みstring baseName = Path.GetFileNameWithoutExtension(ExecuteName);Assembly assembly = Assembly.Load(baseName);_myType = assembly.GetType(baseName + ".Program");_instance = Activator.CreateInstance(_myType);// アセンブリ内のクラスの Update イベントの EventInfo を取得EventInfo eventInfo = _myType.GetEvent("Update");var methodInfo = this.GetType().GetMethod("OnUpdate");Delegate handler = Delegate.CreateDelegate(eventInfo.EventHandlerType, this, methodInfo);// EventInfo に対してイベント ハンドラーを追加eventInfo.AddEventHandler(_instance, handler);// 閉じるボタンを無効にするbtnClose.Enabled = false;// ProgressChangedイベントが発生するようにするbgWorker.WorkerReportsProgress = true;// 処理を開始するbgWorker.RunWorkerAsync();}
画面初回表示時
アセンブリ名を使ってクラス ライブラリーを動的に読み込み
*string baseName = Path.GetFileNameWithoutExtension(ExecuteName);
アセンブリ内のクラスの Update イベントの EventInfo を取得
*EventInfo eventInfo = _myType.GetEvent("Update");
EventInfo に対してイベント ハンドラーを追加
*eventInfo.AddEventHandler(_instance, handler);
閉じるボタンを無効にする
*btnClose.Enabled = false;
ProgressChangedイベントが発生するようにする
*bgWorker.WorkerReportsProgress = true;
処理を開始する
*bgWorker.RunWorkerAsync();
*{Close();}
画面を閉じる
*{BackgroundWorker bgWorker = (BackgroundWorker)sender;// 処理を開始するint result = (int)_myType.InvokeMember("Main", BindingFlags.InvokeMethod, null, _instance, new object[] { Arguments.Split(',') });// 結果を設定するe.Result = result;}
取込処理
*int result = (int)_myType.InvokeMember("Main", BindingFlags.InvokeMethod, null, _instance, new object[] { Arguments.Split(',') });
処理を開始する
結果を設定する
*e.Result = result;
*{// ProgressBarの値を変更するInvoke((Action)delegate (){prbDowork.Value = e.ProgressPercentage;// タイトルのテキストを変更するlblTitle.Text = (e.ProgressPercentage).ToString() + " %";});}
途中経過イベント処理
*{prbDowork.Value = e.ProgressPercentage;// タイトルのテキストを変更するlblTitle.Text = (e.ProgressPercentage).ToString() + " %";});
ProgressBarの値を変更する
タイトルのテキストを変更する
*lblTitle.Text = (e.ProgressPercentage).ToString() + " %";
*{Invoke((Action)delegate (){if (e.Error != null){// エラーが発生したときlblTitle.Text = "エラー:" + e.Error.Message;}else{// ProgressBarの結果を取得するint result = (int)e.Result;if (result == -1){// エラーで中断したときlblTitle.Text = "処理を中断しました。";}else{// 正常に終了したときprbDowork.Value = prbDowork.Maximum;lblTitle.Text = "完了しました。";}}// 閉じるボタンを有効に戻すbtnClose.Enabled = true;});}
取込処理が終わったときに呼び出される
エラーが発生したとき
*lblTitle.Text = "エラー:" + e.Error.Message;
ProgressBarの結果を取得する
*int result = (int)e.Result;
エラーで中断したとき
*lblTitle.Text = "処理を中断しました。";
正常に終了したとき
*prbDowork.Value = prbDowork.Maximum;
閉じるボタンを有効に戻す
*btnClose.Enabled = true;
*{// ProgressChangedイベントハンドラを呼び出しbgWorker.ReportProgress(e.ProgressPercentage);}
進捗値の更新
ProgressChangedイベントハンドラを呼び出し
*bgWorker.ReportProgress(e.ProgressPercentage);
*{this.ExecuteName = executeName;this.Arguments = args;this.ShowDialog();}
実行処理
メッセージボックスを表示する
*DialogResult result = MessageBox.Show("実行します。よろしいですか ? ",
処理実行
*AppDomain appDomain = AppDomain.CreateDomain("Domain");
実行ファイル名 サンプルなので固定
進捗画面表示
*proxy.Execute("SUB00001.dll", "");
*{string path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);Assembly asm = Assembly.LoadFile(Path.Combine(path, "DoWork.dll"));Type type = asm.GetType("DoWork.frmDoWork");instance = Activator.CreateInstance(type);}
進捗画面アセンブリのロード
*{instance.Execute(executeName, args);}
進捗画面表示
更新されると起きるイベント
*public event ProgressChangedEventHandler Update;
完了
*SetProgress(100);
*{System.Threading.Thread.Sleep(200);SetProgress(10);return true;}
処理10%
*{System.Threading.Thread.Sleep(200);SetProgress(30);return true;}
処理30%
*{System.Threading.Thread.Sleep(200);SetProgress(50);return true;}
処理50%
*{System.Threading.Thread.Sleep(200);SetProgress(70);return true;}
処理70%
*{System.Threading.Thread.Sleep(200);SetProgress(90);return true;}
処理90%
*{// 更新イベントを起こすProgressChangedEventArgs e = new ProgressChangedEventArgs(value, null);Update?.Invoke(this, e);}
進捗状況を標準出力に出力する
更新イベントを起こす
*ProgressChangedEventArgs e = new ProgressChangedEventArgs(value, null);

郵便番号データのコンテキストを生成
*IEnumerable<;string[]>; context = TextField.Context(
*foreach (string[] result in context.AsParallel())*{
結果をコンソールに出す
指定されたCSVファイルへのコンテキストを生成する
*public static IEnumerable<;string[]>; Context(

*http:
neue.cc20110917_343.html

*{if (Input.GetKey(KeyCode.LeftArrow)){// 左キー(orボタン）が押されている}}
Input時代の書き方
左キー(orボタン）が押されている
*}
*if (move.Left.ReadValue<;float>;() >; 0f)*{
moveはInputControl
左キー(orボタン）が押されている
*}
*if (move.Left.IsPressed())*{
moveはInputControl
左キー(orボタン）が押されている
*}

省略
*}
↓privateからpublicに変更する
private System.Windows.Forms.ProgressBar progressBar1;
*public System.Windows.Forms.ProgressBar progressBar1;
*{class BackGroundClass1{private Form1 f1;private Form2 f2;public BackGroundClass1(Form1 f1){this.f1 = f1;this.f2 = new Form2();}public void start(){Thread t = new Thread(new ThreadStart(LongTask));t.IsBackground = true;t.Start();f2.ShowDialog(f1);f2.Dispose();}private void LongTask(){//ここにすっげー時間かかる処理を書く想定for (int i = 0; i <;= 100; i++){Thread.Sleep(100);f2.BeginInvoke(new UpdateProgressBarDelegate(UpdateProgressBar), new object[] { i });}}private delegate void UpdateProgressBarDelegate(int val);private void UpdateProgressBar(int val){f2.progressBar1.Value = val;if (val >;= 100){f2.Close();}}}}
using System.Windows.Forms;
*for (int i = 0; i <;= 100; i++)*{
ここにすっげー時間かかる処理を書く想定

コマンドライン引数を配列で取得する
*string[] cmds = System.Environment.GetCommandLineArgs();
*if(cmds.Length >;= 2)*{
コマンドライン引数を列挙する

*string loadText = await model.LoadedText;
ReactivePropertyの変更を待つ

*using System.Collections.Generic;
for List&lt;&gt;

*Console.WriteLine(sum);
1060
*if (n == 1) return false;*if (n == 2) return true;
素数かどうか判定する &lt;- みたいなコメントがいる。(IsPrime なら自明)
素数だけをカウント
*var count = numbers.Count(n =>; IsPrime(n));
すべて素数か？
*bool isAllPrime = numbers.All(n =>; IsPrime(n));
素数が混じっているか？
*bool containsPrime = numbers.Any(n =>; IsPrime(n));
最大の素数
*int max = numbers.Where(n =>; IsPrime(n)).Max();
数列中に最初に現れる素数
*int first = numbers.First(n =>; IsPrime(n))
*IEnumerable<;int>; PrimeGen() {int n = 1;while (true) {if (IsPrime(n)) yield return n;n++;}}
無限に素数を返すイテレータ
素数を5個取り出す
var primes = PrimeGen().Take(5);  =&gt; 2, 3, 5, 7, 11 のシーケンス
*,,,

*data.Rows.Add(add);
add.RowState:DataRowState.Added
修正
var mod = data.Rows[0];      mod.RowState:DataRowState.Unchanged
mod["ID"] = 9;               mod.RowState:DataRowState.Modified
削除
・削除された行として存在する。
var del = data.Rows[1];     del.RowState:DataRowState.Unchanged
del.Delete();               del.RowState:DataRowState.Deleted
除外
・DataTableから除外される。
・data.RejectChanges();しても、dataから除外されたままになる。
var rmv = data.Rows[2];     rmv.RowState:DataRowState.Unchanged
data.Rows.Remove(rmv);      rmv.RowState:DataRowState.Detached
*Console.WriteLine("--------------------");
*Console.WriteLine($"ID:{row["ID", DataRowVersion.Original]},RowState={row.RowState}");
削除された行の値をアクセスしようとする例外が発生する。
*Console.WriteLine($"ID:{row["ID", DataRowVersion.Original]},RowState={row.RowState}");
→DataRowVersion.Original を付けて、削除前の状態の値を取得する。

*Thread.Sleep((3 + count) * 1000);
It will change the end time for the concurrently started thread.
*Console.WriteLine($"{semaphore.CurrentCount} tasks can enter the semaphore.");
increase avairable Semaphore

*private const string ENDPOINT = "https:
api.cognitive.microsofttranslator.com";
ドロップダウンメニュー作成
*var languages = Enum.GetNames(typeof(Language));
*.Subscribe(value =>; { fromLanguage = (Language) value; })
翻訳元言語
*.Subscribe(value =>; { toLanguage = (Language) value; })
翻訳後言語
翻訳ボタン押下
*translateButton.OnClickAsObservable()
結果が送られてくるまで待ってから表示
*var result = GetTranslation(fromLanguage, toLanguage, inputField.text, token);
*requestInfo += $"&amp;from={from}&amp;to={to}";
POSTメソッドのリクエストを作成
*var speechData = new SpeechData {Text = speechText};
リクエストに使用するJSON作成
ヘッダーに必要な情報を追加
*request.SetRequestHeader("Ocp-Apim-Subscription-Region", LOCATION);
結果受け取り
*var second = TimeSpan.FromSeconds(3);
ドロップダウンメニュー作成
*var languages = Enum.GetNames(typeof(Language));
*.Subscribe(value =>; { fromLanguage = (Language) value; })
翻訳元言語
*.Subscribe(value =>; { toLanguage = (Language) value; })
翻訳後言語

呼び出し
*Hello.CallMe(namePtr, respPtr);

*{return GvrControllerInput.GetDevice(GvrControllerHand.Dominant).TouchPos;}
このメソッドと入れ替える
*ReplaceMethod(typeof(OVRInput), typeof(OVRInputEmulator), "Get", new System.Type[] { typeof(OVRInput.Axis2D), typeof(OVRInput.Controller) });
タッチパッド上の座標

*options.UseNpgsql(
&lt;= この部分は使うＤＢに合わせてください
初期化時のロール
public static readonly string SystemManagerRole = "SystemManager";       システム管理権限
public static readonly string GroupManagerRole = "GroupManager";         グループ管理権限
初期化時のシステム管理ユーザーID
public static readonly string SystemUserName = "system";     最初のシステム管理ユーザーのメールアドレス
public static readonly string SystemManageEmail = "system@test.com";     最初のシステム管理ユーザーのメールアドレス
public static readonly string SystemManagePassword = "!initialPassword01";     最初のシステム管理ユーザーの初期パスワード
初期化時のグループ管理ユーザーID
public static readonly string GroupUserName = "groupuser";     最初のグループ管理ユーザーのメールアドレス
public static readonly string GroupUserEmail = "groupuser@test.com";     最初のグループ管理ユーザーのメールアドレス
public static readonly string GroupUserPassword = "!initialPassword02";     最初のグループ管理ユーザーの初期パスワード
*public static async Task Initialize(IServiceProvider serviceProvider)
ユーザー管理を取得(using Microsoft.Extensions.DependencyInjectionがないとエラーになる)
*var userManager = serviceProvider.GetService<;UserManager<;IdentityUser>;>;();
初期のユーザーマネージャーが存在しなければロールの作成と初期システムユーザーを作成する
*var systemManager = await userManager.FindByNameAsync(SystemUserName);
ロール管理を取得
*var roleManager = serviceProvider.GetService<;RoleManager<;IdentityRole>;>;();
ロールの追加
await roleManager.CreateAsync(new IdentityRole(SystemManagerRole));     システム管理ロール
await roleManager.CreateAsync(new IdentityRole(GroupManagerRole));     グループ管理ロール
初期システム管理者の作成
*systemManager = new IdentityUser { UserName = SystemUserName, Email = SystemManageEmail };
システム管理ユーザーにシステム管理ロールを追加
*systemManager = await userManager.FindByNameAsync(SystemUserName);
*var groupUser = new IdentityUser { UserName = GroupUserName, Email = GroupUserEmail };
グループユーザーの作成
グループユーザーにグループユーザーロールを追加
*groupUser = await userManager.FindByNameAsync(GroupUserName);
CreateHostBuilder(args).Build().Run(); &lt;= もともとこの1行のみ
*var host = CreateHostBuilder(args).Build();
サービスプロバイダーの取得
*var services = scope.ServiceProvider;
データベースの自動マイグレーション
*var context = services.GetRequiredService<;ApplicationDbContext>;();
初期のユーザーとロールの作成
*UserRollInitialize.Initialize(services).Wait();
設定管理オブジェクト
*IConfiguration _config;
サインインマネージャー（DefaultIdenityを利用している）
*SignInManager<;IdentityUser>; _signInManager =null;
コンストラクタ
サインインマネージャーとコンフィグ管理のオブジェクトをＤＩ
*public AuthController(SignInManager<;IdentityUser>; signInManager, IConfiguration config, UserManager<;IdentityUser>; userManage)
ログイン処理
*[HttpPost]
ASP.Net core のdDefaultIdentityを利用してIDとパスワードの確認
*var result = await _signInManager.PasswordSignInAsync(request.userId, request.password, false, false);
*return Ok(new { token = await BuildToken(request) });
ログイン成功でおJWTトークンを返す
ログアウト処理
*[HttpPost]
*{var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config["Jwt:Key"]));var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);var user = await _userManage.FindByNameAsync(request.userId);var principal = await _signInManager.CreateUserPrincipalAsync(user);var roles = await _userManage.GetRolesAsync(user);var claims = new List<;Claim>;(principal.Claims);claims.Add(new Claim(JwtRegisteredClaimNames.Sub, user.UserName));claims.Add(new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()));foreach(var role in roles){claims.Add(new Claim(ClaimTypes.Role, role));}var token = new JwtSecurityToken(issuer: _config["Jwt:Issuer"],audience: _config["Jwt:Issuer"],expires: DateTime.Now.AddMinutes(30),signingCredentials: creds,claims: claims);var tmp = new JwtSecurityTokenHandler().WriteToken(token);return tmp;}
JWTトークンの作成
テスト用
*[HttpPost]
JWT Bearer をデフォルトにする
*options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;

*this[index] = new T();
初期値
*public virtual IEnumerable<;int>; GetAllIndexes() {for (int y = 1; y <;= this.YSize; y++) {for (int x = 1; x <;= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する
*public virtual IEnumerable<;int>; EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index) &amp;&amp; this[index] != null; index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む
(x,y)から右(水平)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Horizontal(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Virtical(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantR(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantL(int x, int y)
*public Board(Board board) : base(board) {}
コピーコンストラクタ
*public void Put(int place) {this[place] = Piece.Queen;}
駒を置く
*public void Clear(int place) {this[place] = Piece.Empty;}
指定した位置から駒を取り去る
*public bool CanPut(int place) {if (this[place] != Piece.Empty)return false;if (Courses(place).Any(p =>; this[p] == Piece.Queen))return false;return true;}
引数で与えた位置に駒を置けるか
与えられた位置の右、下、ななめ右下、ななめ左下の位置を
それぞれぐるっと一回転するまで列挙する。
ただし、与えられた位置は除く。
*public IEnumerable<;int>; Courses(int index) {
*public IEnumerable<;int>; Oblique(int x, int y) {for (int i = 0; i <; _width; i++) {x += 1;y -= 1;if (x >; _width)x = 1;if (y == 0)y = _width;yield return ToIndex(x, y);}}
左下がりの斜線の各位置を列挙する
*public IEnumerable<;int>; BackOblique(int x, int y) {for (int i = 0; i <; _width; i++) {x += 1;y += 1;if (x >; _width)x = 1;if (y >; _width)y = 1;yield return ToIndex(x, y);}}
右下がりの斜線の各位置を列挙する
*private IEnumerable<;Board>; SolveInner(Board board, int y) {if (y >; board.YSize) {yield return new Board(board);yield break;}foreach (int pos in board.Horizontal(1, y)) {if (board.CanPut(pos)) {board.Put(pos);foreach (var b in SolveInner(board, y + 1))yield return b;board.Clear(pos);}}}
y行よりも下に置く駒を求める － 鏡像、回転を除くことは考慮していない

*Console.WriteLine($"整形={d.ToString("yyyy年MM月dd日")}");
&lt;------ MM だけ大文字だ

*var sut = new ColorConverter();
sut means `System under test`

*if (!IsInsideOfCircle(diff, radius))*{
円の内外判定
*if (GetCross2d(startVec, endVec) >; 0)*{
扇型の角度が180度未満の場合
*if (GetCross2d(startVec, diff) >;= 0 &amp;&amp; GetCross2d(endVec, diff) <;= 0)*{
diff が startVec より左側 *かつ* diff が endVec より右側の時
*{// diff が startVec より左側 *または* diff が endVec より右側の時if (GetCross2d(startVec, diff) >;= 0 || GetCross2d(endVec, diff) <;= 0){return true;}return false;}
扇型の角度が180度以上の場合
*if (GetCross2d(startVec, diff) >;= 0 || GetCross2d(endVec, diff) <;= 0)*{
diff が startVec より左側 *または* diff が endVec より右側の時
AssertはNUnitのではなくUnityのものを使う
*using Assert = UnityEngine.Assertions.Assert;
*if (GetCross2d(startVec, endVec) >; 0)*{
扇型の角度が180度未満の場合
*if (GetCross2d(startVec, diff) >;= 0 &amp;&amp; GetCross2d(endVec, diff) <;= 0)*{
diff が startVec より左側 *かつ* diff が endVec より右側の時
*{// diff が startVec より左側 *または* diff が endVec より右側の時if (GetCross2d(startVec, diff) >;= 0 || GetCross2d(endVec, diff) <;= 0){return true;}return false;}
扇型の角度が180度以上の場合
*if (GetCross2d(startVec, diff) >;= 0 || GetCross2d(endVec, diff) <;= 0)*{
diff が startVec より左側 *または* diff が endVec より右側の時

フォルダ「HogeFolder」下のファイル一覧を取得する
リクエストパラメータの定義
service(DriveService)はユーザ認証部分なので割愛
*var listRequest = service.Files.List();
取得するフォルダの条件をクエリ構文で指定
*listRequest.Q = "(name = 'HogeFolder') and (mimeType = 'application/vnd.google-apps.folder') and (trashed = false)";
フォルダIDの取得
*var folderId = listRequest.Execute().Files.First().Id;
*// '{folderId}' in parentsにより、フォルダ「HogeFolder」下にあるファイルとフォルダのみが対象となる
フォルダ「HogeFolder」下のファイルの条件をクエリ構文で指定
*listRequest.Q = $"('{folderId}' in parents) and (mimeType != 'application/vnd.google-apps.folder') and (trashed = false)";
'{folderId}' in parentsにより、フォルダ「HogeFolder」下にあるファイルとフォルダのみが対象となる
ファイル一覧の取得
*var files = listRequest.Execute().Files;
一番最初にとれたファイルのIDを取得する
*var id = files.First().Id;
保存するファイル先を指定する
*string saveTo = "HogeFolder";
ファイルをダウンロードする
*var request = service.Files.Get(id);

Storageに保存されている設定を読み込む
*await sharedDictionary.LoadFromStorageAsync();
もちろん基本データ型の保存はできて
*sharedDictionary.SetProperty("text", "sssss");
Utf8JsonまたはSpanJsonによって、ユーザー定義型の保存もできる
*sharedDictionary.SetProperty("data", new Data());
Storageに書き込む
*await sharedDictionary.SaveToStorageAsync();
設定を読み込む
*string text = sharedDictionary.GetProperty<;string>;("text");

*public string ExecuteName { get;  set; }
取込処理名
*public string Arguments { get; set; }
取込処理の引数
動的DLL処理用
*private Type _myType = null;
*{InitializeComponent();}
コンストラクタ
*{// アセンブリ名を使ってクラス ライブラリーを動的に読み込みstring baseName = Path.GetFileNameWithoutExtension(ExecuteName);Assembly assembly = Assembly.Load(baseName);_myType = assembly.GetType(baseName + ".Program");_instance = Activator.CreateInstance(_myType);// アセンブリ内のクラスの Update イベントの EventInfo を取得EventInfo eventInfo = _myType.GetEvent("Update");var methodInfo = this.GetType().GetMethod("OnUpdate");Delegate handler = Delegate.CreateDelegate(eventInfo.EventHandlerType, this, methodInfo);// EventInfo に対してイベント ハンドラーを追加eventInfo.AddEventHandler(_instance, handler);}
画面ロード時
アセンブリ名を使ってクラス ライブラリーを動的に読み込み
*string baseName = Path.GetFileNameWithoutExtension(ExecuteName);
アセンブリ内のクラスの Update イベントの EventInfo を取得
*EventInfo eventInfo = _myType.GetEvent("Update");
EventInfo に対してイベント ハンドラーを追加
*eventInfo.AddEventHandler(_instance, handler);
*{// 閉じるボタンを無効にするbtnClose.Enabled = false;// ProgressChangedイベントが発生するようにするbgWorker.WorkerReportsProgress = true;// 処理を開始するbgWorker.RunWorkerAsync();}
画面初回表示時
閉じるボタンを無効にする
*btnClose.Enabled = false;
ProgressChangedイベントが発生するようにする
*bgWorker.WorkerReportsProgress = true;
処理を開始する
*bgWorker.RunWorkerAsync();
*{Close();}
画面を閉じる
*{BackgroundWorker bgWorker = (BackgroundWorker)sender;// 処理を開始するint result = (int)_myType.InvokeMember("Main", BindingFlags.InvokeMethod, null, _instance, new object[] { Arguments });// 結果を設定するe.Result = result;}
取込処理
*int result = (int)_myType.InvokeMember("Main", BindingFlags.InvokeMethod, null, _instance, new object[] { Arguments });
処理を開始する
結果を設定する
*e.Result = result;
*{// ProgressBarの値を変更するprbDowork.Value = e.ProgressPercentage;// タイトルのテキストを変更するlblTitle.Text = (e.ProgressPercentage).ToString() + " %";}
途中経過イベント処理
ProgressBarの値を変更する
*prbDowork.Value = e.ProgressPercentage;
タイトルのテキストを変更する
*lblTitle.Text = (e.ProgressPercentage).ToString() + " %";
*{if (e.Error != null){// エラーが発生したときlblTitle.Text = "エラー:" + e.Error.Message;}else{// ProgressBarの結果を取得するint result = (int)e.Result;if(result == -1){// エラーで中断したときlblTitle.Text = "処理を中断しました。";}else{// 正常に終了したときprbDowork.Value = prbDowork.Maximum;lblTitle.Text = "完了しました。";}}// 閉じるボタンを有効に戻すbtnClose.Enabled = true;}
取込処理が終わったときに呼び出される
エラーが発生したとき
*lblTitle.Text = "エラー:" + e.Error.Message;
ProgressBarの結果を取得する
*int result = (int)e.Result;
エラーで中断したとき
*lblTitle.Text = "処理を中断しました。";
正常に終了したとき
*prbDowork.Value = prbDowork.Maximum;
閉じるボタンを有効に戻す
*btnClose.Enabled = true;
*{PropertyInfo prop_value = e.GetType().GetProperty("value");int percentage = Convert.ToInt32(prop_value.GetValue(e, null));// ProgressChangedイベントハンドラを呼び出しbgWorker.ReportProgress(percentage);}
進捗値の更新
ProgressChangedイベントハンドラを呼び出し
*bgWorker.ReportProgress(percentage);
メッセージボックスを表示する
*DialogResult result = MessageBox.Show("実行します。よろしいですか ? ",
処理実行
*frmDoWork frm = new frmDoWork();
実行ファイル名 サンプルなので固定
*frm.ExecuteName = "SUB00001.dll";
進捗画面表示
*frm.ShowDialog();
更新されると起きるイベント
*public event EventHandler Update;
完了
*SetProgress(100);
*{System.Threading.Thread.Sleep(200);SetProgress(10);return true;}
処理10%
*{System.Threading.Thread.Sleep(200);SetProgress(30);return true;}
処理30%
*{System.Threading.Thread.Sleep(200);SetProgress(50);return true;}
処理50%
*{System.Threading.Thread.Sleep(200);SetProgress(70);return true;}
処理70%
*{System.Threading.Thread.Sleep(200);SetProgress(90);return true;}
処理90%
*{// 更新イベントを起こすUpdateEventArgs e = new UpdateEventArgs();e.value = value;Update?.Invoke(this, e);}
進捗状況を標準出力に出力する
更新イベントを起こす
*UpdateEventArgs e = new UpdateEventArgs();

自身のウィンドウを囲む長方形を定義，thisはGUIアプリのクラス
*System.Drawing.Rectangle rect = new System.Drawing.Rectangle((int)this.Left, (int)this.Top, (int)this.Width, (int)this.Height);
長方形のある（ウィンドウのある）ディスプレイのスクリーン情報を取得
*System.Windows.Forms.Screen screenData = System.Windows.Forms.Screen.FromRectangle(rect);
縦と横の解像度を取得
*int screenHeight = screenData.WorkingArea.Height;
*scaleX = source.CompositionTarget.TransformToDevice.M11;*scaleY = source.CompositionTarget.TransformToDevice.M22;
ここでDPIの係数を取得
サイズを画面の縦サイズと同じにする
*this.Height = (double)screenHeight / scaleY;

マウスカーソルの座標を取得
*GetMousePoint( &amp;MouseX, &amp;MouseY ) ;
マウスボタンの入力状態を更新
*PrevInput = NowInput ;
*if( Catch == 0 )*{
既にモデルを掴んでいるかどうかで処理を分岐
掴んでいない場合
左クリックされたらモデルをクリックしたかを調べる
*if( EdgeInput &amp; MOUSE_INPUT_1 )
モデルとの当たり判定用の線分の２座標を作成
*ScreenPos1.x = ( float )MouseX ;
モデルの当たり判定情報を更新
*MV1RefreshCollInfo( ModelHandle, -1 ) ;
モデルと線分の当たり判定
*MV1_COLL_RESULT_POLY Result = MV1CollCheck_Line( ModelHandle, -1, WorldPos1, WorldPos2 ) ;
*if( Result.HitFlag )*{
当たっていたら掴み状態にする
掴んでいるかどうかのフラグを立てる
*Catch = 1 ;
掴んだときのスクリーン座標を保存
*CatchMouseX = MouseX ;
掴んだときのモデルのワールド座標を保存
*Catch3DModelPosition = MV1GetPosition( ModelHandle ) ;
掴んだときのモデルと線分が当たった座標を保存( 座標をスクリーン座標に変換したものも保存しておく )
*Catch3DHitPosition = Result.HitPosition ;

*Debug.Log("Out" + Uncode.posData);
JSONをJSONWriteクラスに変換した結果を出力

*Console.WriteLine("items[1][0]:" + items1[1][0]);
items[1][0]:-
RemoveAllメソッドを使った場合
*hoges.RemoveAll(b =>; b <; 5);

今日の日付、現在の時刻を取得する
*DateTime dt = DateTime.Now;

～略～
NLogを使う設定を宣言し
*env.ConfigureNLog("nlog.config");
*{IndentSize = 4,Name = "MyNLogTraceListener",});
さらにNLogに流し込むListenerを追加することをでTrace.Xxxxでの出力がNLog設定で書き出される
*Trace.TraceInformation("Appcation Start!");*}
本来もっと前に記録したいところだけど記述準的にここで初めてTraceをNLogに流し込めるようになるのでここでAppStartログ
*{public static string ExtractException(this Exception ex, int indent = 2){var indentStr = new String(' ',indent);StringBuilder traceLog = new StringBuilder();StackTrace trace = new StackTrace(ex, true);foreach (var frame in trace.GetFrames()){traceLog.AppendLine($"{indentStr}File Name : {frame.GetFileName()}");traceLog.AppendLine($"{indentStr}Class Name : {frame.GetMethod().ReflectedType.Name}");traceLog.AppendLine($"{indentStr}Method Name : {frame.GetMethod()}");traceLog.AppendLine($"{indentStr}Line Number : {frame.GetFileLineNumber()}");traceLog.AppendLine($"=======================================================");}return traceLog.ToString();}}
https:teratail.com/questions/24669

*{return new OtherClient();});
Registration with Function
*Console.WriteLine($"SomeClient1(Singleton): Type: {someClient1.GetType()} Id: {someClient1.Id}");
Singleton
*Console.WriteLine($"OtherClient1(Transient): Type: {otherClient1.GetType()} Id: {otherClient1.Id}");
Transient
*{Value1 = "Hello",Value2 = "World"});
Register Option value object
*{var options = serviceProvider.GetRequiredService<;IOptions<;SomeOption>;>;();var client =  new SomeClient();client.SomeOptions = options.Value;return client;});
Options

*private bool isPassing = false;
trueの場合すでに探索済みfalseなら未探索

出力:
1
2
3
*}
*public void Test2 ([Values]bool b) {Debug.Log (b);// 出力:// True// False}
boolの場合、Valuesの引数は省略できる
出力:
True
False
*}
*public void Test3 ([Values (1, 2)]int i, [Values(-2, -4)]int j) {Debug.Log (i + "," + j);// 出力:// 1, -2// 1, -4// 2, -2// 2, -4}
複数の引数にValuesをつけた場合、組み合わせてテストケースを作成する
出力:
1, -2
1, -4
2, -2
2, -4
*}
*// static int[] testValues {//   get {//     return new [] { 1, 2, 3 };//   }// }
こっちでも通る
*//   get {//     return new [] { 1, 2, 3 };//   }
static int[] testValues {
*//     return new [] { 1, 2, 3 };
get {
*// static int[] testValues () {//   return new [] { 1, 2, 3 };// }
}
*// static int[] testValues () {//   return new [] { 1, 2, 3 };// }
こっちでも通る
*//   return new [] { 1, 2, 3 };
static int[] testValues () {
*public void Test ([ValueSource ("testValues")]int i) {Debug.Log (i);}
}
出力:
1,3,3
2,2,1
3,3,3
*}
*// static int[][] testCases {//   get {//     return new[] {//       new [] { 1, 3, 3 },//       new [] { 2, 2, 1 },//       new [] { 3, 3, 3 }//     };//   }// }
こっちでも通る
*//   get {//     return new[] {//       new [] { 1, 3, 3 },//       new [] { 2, 2, 1 },//       new [] { 3, 3, 3 }//     };//   }
static int[][] testCases {
*//     return new[] {//       new [] { 1, 3, 3 },//       new [] { 2, 2, 1 },//       new [] { 3, 3, 3 }//     };
get {
*//       new [] { 1, 3, 3 },
return new[] {
*//       new [] { 2, 2, 1 },
new [] { 1, 3, 3 },
*//       new [] { 3, 3, 3 }
new [] { 2, 2, 1 },
*// static int[][] testCases () {//   return new[] {//     new [] { 1, 3, 3 },//     new [] { 2, 2, 1 },//     new [] { 3, 3, 3 }//   };// }
}
*// static int[][] testCases () {//   return new[] {//     new [] { 1, 3, 3 },//     new [] { 2, 2, 1 },//     new [] { 3, 3, 3 }//   };// }
こっちでも通る
*//   return new[] {//     new [] { 1, 3, 3 },//     new [] { 2, 2, 1 },//     new [] { 3, 3, 3 }//   };
static int[][] testCases () {
*//     new [] { 1, 3, 3 },
return new[] {
*//     new [] { 2, 2, 1 },
new [] { 1, 3, 3 },
*//     new [] { 3, 3, 3 }
new [] { 2, 2, 1 },
*public void Test (int i, int j, int k) {Debug.Log (i + ", " + j + ", " + k);// 出力:// 1,3,3// 2,2,1// 3,3,3}
}
出力:
1,3,3
2,2,1
3,3,3
*}
*public void Test1 ([NUnit.Framework.Range (3, 7)]int i) {Debug.Log (i);// 出力:// 3// 4// 5// 6// 7}
3 ~ 7 の値で順にテストする
出力:
3
4
5
6
7
*}
*public void Test2 ([NUnit.Framework.Range (3, 7, 3)]int i) {Debug.Log (i);// 出力:// 3// 6}
3 ~ 7 の値で3飛ばしにテストする
出力:
3
6
*}
*public void Test1 ([Random (3)]int i) {Debug.Log (i);}
ランダムな値で3回テストする
*public void Test2 ([Random (-10, 10, 3)]int i) {Debug.Log (i);}
-10 ~ 10 のランダムな値で3回テストする
*public void Test1 ([Values (1, 2, 3)]int i, [Values(-2, -4)]int j, [Values ("A", "B", "C")]string s) {Debug.Log (i + "," + j + "," + s);// 出力:// 1,-2,A// 1,-2,B// 1,-2,C// 1,-4,A// 中略// 3,-4,C}
全18パターンの組み合わせでテストする
出力:
1,-2,A
1,-2,B
1,-2,C
1,-4,A
中略
3,-4,C
*}
*public void Test2 ([Values (1, 2, 3)]int i, [Values(-2, -4)]int j, [Values ("A", "B", "C")]string s) {Debug.Log (i + "," + j + "," + s);// 出力:// 1,-2,A// 2,-4,B// 3,0,C}
全3パターンの組み合わせでテストする
出力:
1,-2,A
2,-4,B
3,0,C
*}
*public void Test3 ([Values (1, 2, 3)]int i, [Values(-2, -4)]int j, [Values ("A", "B", "C")]string s) {Debug.Log (i + "," + j + "," + s);// 出力:// 1,-2,A// 1,-4,C// 1,-4,B// 2,-2,B// 中略// 3,-4,A}
全9パターンの組み合わせでテストする
出力:
1,-2,A
1,-4,C
1,-4,B
2,-2,B
中略
3,-4,A
*}
*public void Test1 () {yield return new WaitForSeconds (1.5f);Debug.Log ("テストは失敗し、何も出力されない");}
指定する時間はミリ秒
*public IEnumerator Test2 () {yield return new WaitForSeconds (1.5f);Debug.Log ("テストは失敗するが、このログは出力される");}
指定する時間はミリ秒
一桁目が2より大きくないと許さない
*Assert.Greater (i % 10, 2);
*[Platform ("Windows10, MacOsX")]*public class Hoge {
Windows10またはMacOSXでのみテストを実行する

*{}
GET api/Values/email@address.com

*outputArray.AddRange(new float[21125]);
125×13×13

*ERROR2 = 2,
エラー 2

*.Memoize()
キャッシュ

*public string ExecuteName { get;  set; }
取込処理名
*public string Arguments { get; set; }
取込処理の引数
プロセス処理用
*private Process _proc = null;
*{InitializeComponent();}
コンストラクタ
*{// 取込処理の準備_proc = new Process();// プロセスの実行名をセット_proc.StartInfo.FileName = ExecuteName;// プロセスの引数をセット_proc.StartInfo.Arguments = Arguments;// ウィンドウを表示しないようにする_proc.StartInfo.CreateNoWindow = true;//入力できるようにする_proc.StartInfo.UseShellExecute = false;_proc.StartInfo.RedirectStandardInput = true;//非同期で出力を読み取れるようにする_proc.StartInfo.RedirectStandardOutput = true;_proc.OutputDataReceived += proc_OutputDataReceived;}
画面ロード時
取込処理の準備
*_proc = new Process();
プロセスの実行名をセット
*_proc.StartInfo.FileName = ExecuteName;
プロセスの引数をセット
*_proc.StartInfo.Arguments = Arguments;
ウィンドウを表示しないようにする
*_proc.StartInfo.CreateNoWindow = true;
入力できるようにする
*_proc.StartInfo.UseShellExecute = false;
非同期で出力を読み取れるようにする
*_proc.StartInfo.RedirectStandardOutput = true;
*{// 閉じるボタンを無効にするbtnClose.Enabled = false;// ProgressChangedイベントが発生するようにするbgWorker.WorkerReportsProgress = true;// 処理を開始するbgWorker.RunWorkerAsync();}
画面初回表示時
閉じるボタンを無効にする
*btnClose.Enabled = false;
ProgressChangedイベントが発生するようにする
*bgWorker.WorkerReportsProgress = true;
処理を開始する
*bgWorker.RunWorkerAsync();
*{Close();}
画面を閉じる
*{if (e.Data == null) return;Regex regex = new Regex(@"進捗 (\d.)%");Match match = regex.Match(e.Data);if(match.Groups.Count >; 1){int percentage = int.Parse(match.Groups[1].Value);// ProgressChangedイベントハンドラを呼び出しbgWorker.ReportProgress(percentage);}}
行が出力されるたびに呼び出される
ProgressChangedイベントハンドラを呼び出し
*bgWorker.ReportProgress(percentage);
*{BackgroundWorker bgWorker = (BackgroundWorker)sender;// 処理を開始する_proc.Start();// 非同期で出力の読み取りを開始する_proc.BeginOutputReadLine();_proc.WaitForExit();// 結果を設定するe.Result = _proc.ExitCode;}
取込処理
処理を開始する
*_proc.Start();
非同期で出力の読み取りを開始する
*_proc.BeginOutputReadLine();
結果を設定する
*e.Result = _proc.ExitCode;
*{// ProgressBarの値を変更するprbDowork.Value = e.ProgressPercentage;// タイトルのテキストを変更するlblTitle.Text = (e.ProgressPercentage).ToString() + " %";}
途中経過イベント処理
ProgressBarの値を変更する
*prbDowork.Value = e.ProgressPercentage;
タイトルのテキストを変更する
*lblTitle.Text = (e.ProgressPercentage).ToString() + " %";
*{if (e.Error != null){// エラーが発生したときlblTitle.Text = "エラー:" + e.Error.Message;}else{// ProgressBarの結果を取得するint result = (int)e.Result;if(result == -1){// エラーで中断したときlblTitle.Text = "処理を中断しました。";}else{// 正常に終了したときprbDowork.Value = prbDowork.Maximum;lblTitle.Text = "完了しました。";}}// 閉じるボタンを有効に戻すbtnClose.Enabled = true;}
取込処理が終わったときに呼び出される
エラーが発生したとき
*lblTitle.Text = "エラー:" + e.Error.Message;
ProgressBarの結果を取得する
*int result = (int)e.Result;
エラーで中断したとき
*lblTitle.Text = "処理を中断しました。";
正常に終了したとき
*prbDowork.Value = prbDowork.Maximum;
閉じるボタンを有効に戻す
*btnClose.Enabled = true;
メッセージボックスを表示する
*DialogResult result = MessageBox.Show("実行します。よろしいですか ? ",
処理実行
*frmDoWork frm = new frmDoWork();
実行ファイル名 サンプルなので固定
*frm.ExecuteName = "SUB00001.exe";
進捗画面表示
*frm.ShowDialog();
完了
*SetProgress(100);
*{System.Threading.Thread.Sleep(200);SetProgress(10);return true;}
処理10%
*{System.Threading.Thread.Sleep(200);SetProgress(30);return true;}
処理30%
*{System.Threading.Thread.Sleep(200);SetProgress(50);return true;}
処理50%
*{System.Threading.Thread.Sleep(200);SetProgress(70);return true;}
処理70%
*{System.Threading.Thread.Sleep(200);SetProgress(90);return true;}
処理90%
*{Console.WriteLine(string.Format("進捗 {0}%", value));}
進捗状況を標準出力に出力する

*if (deviceIds.Length == 0) { return; }
接続されているデバイスIDを取得する
RICOH THETA V デバイスを取得する
*string targetDeviceId = String.Empty;
デバイスよさようなら
*command.Close();
*{MtpOperationCode.OpenSession,          DataPhase.NoDataPhase},
データフェーズのないオペレーション
*{MtpOperationCode.GetDeviceInfo,            DataPhase.DataReadPhase},
R-&gt;Iのデータフェーズがあるオペレーション
*{MtpOperationCode.SetDevicePropValue,       DataPhase.DataWritePhase},
I-&gt;Rのデータフェーズがあるオペレーション
*if (deviceIds.Length == 0) { return; }
接続されているデバイスIDを取得する
RICOH THETA V デバイスを取得する
*string targetDeviceId = String.Empty;
イベントを受け取れるようにする
*command.MtpEvent += MtpEventListener;
デバイスよさようなら
*command.Close();

*@"http:
schemas.microsoft.commapiproptag0x39FE001E";
*if (sender.AddressEntryUserType ==*Outlook.OlAddressEntryUserType.
Now we have an AddressEntry representing the Sender

*mres.Set();
ServiceAsync関数側に通知します。
*for (int i = 0; i <; 10; i++)*{
ループ処理

イテレータ (反復子)
*yield return mes1;
個々に表示する
*Console.WriteLine(CEN_FLG_YN.ARI);
*foreach (string s in CEN_FLG_YN.Enumerate())*{
連続表示する
New()を使用するタイプ
*CMessage mes = new CMessage();

UTC+XをTimeSpan型にする（今回はUTC-4）
TimeSpan userOffset = new TimeSpan(-4, 0, 0);  時、分、秒
今のローカル時間（日本時間）を取得
ここでDateTimeOffsetを使うのは、
DateTimeだと時差情報がオブジェクトに含まれていないため
*DateTimeOffset localTime = DateTimeOffset.Now;
一度UTC（標準時間）に変換する
UtcDateTimeプロパティではDateTimeが取得されるため、またDateTimeOffsetにする
*DateTimeOffset utcTime = new DateTimeOffset(localTime.UtcDateTime, TimeSpan.Zero);
取得したUTCから時差の分ずらす
*DateTime targetTime = utcTime.ToOffset(userOffset);
表示
*Console.Write(targetTime.ToString("yyyy/MM/dd HH:mm:ss"));

*str = instance.Name;
なにかさせる

*var fm = this[dest] as Footmark;
fm が null なら PGミス
*public int MovableCount(int place) {return Destinations(place).Count(ix =>; this[ix] == Piece.Empty);}
騎士が移動可能な場所の数
４つのブロックの座標(インデックス）を設定。
ここだけが番兵の存在に依存している。かなり力業だが...
4隅(4マス)の座標は、各配列の最後に格納する。
*private static int[] _blockA = new int[] { 28, 29, 40, 41, 50, 51, 52, 53, 62, 63, 64, 65, 26, 27, 38, 39, };
*private void _Solve(Chessboard board, int level, int nowpos, int[] block) {if (board.IsOver(block))return;if (board.IsCorrect(block)) {// 現在のブロックが正しいので、次のブロックを求めるint[] nextblock = board.NextBlock(block);if (nextblock != null) {// 次のブロックの解を求める_Solve(board, level, nowpos, nextblock);} else {// すべてのブロックを処理し終わったので、解が見つかったか調べるif (board.IsFinish()) {// Levelの値と置いた騎士の数は一致する。置いた騎士の数が少ないほうがより良い解。if (_mincount >; level) {// より良い解が見つかったので、解を覚える。_answer = new Chessboard(board);// _answer.Print();  // デバッグ用 暫定解を表示_mincount = level;}}}return;}if (level + 1 >;= _mincount)//  現在の最良解よりも悪いものなので、この探索は途中で打ち切るreturn;// 現在のブロックのそれぞれに対し、騎士が置けるかを調べるvar list = block.Where(ix =>; board[ix] == Piece.Empty).ToList();foreach (int pos in list) {if (Array.IndexOf(block, pos) >; Array.IndexOf(block, nowpos)) {// 直前に置いた騎士の位置よりもインデックスが小さいなら既に試してあるので、// インデックスが大きい場合に、新たに騎士をおいて、次の探索に行く。board.Put(pos);_Solve(board, level + 1, pos, block);// pos位置での試しは終わったので、次の探索ができるようにするためクリアする。board.Clear(pos);}}}
４つに区切って探索する。
*private void _Solve(Chessboard board, int level, int nowpos, int[] block) {if (board.IsOver(block))return;if (board.IsCorrect(block)) {// 現在のブロックが正しいので、次のブロックを求めるint[] nextblock = board.NextBlock(block);if (nextblock != null) {// 次のブロックの解を求める_Solve(board, level, nowpos, nextblock);} else {// すべてのブロックを処理し終わったので、解が見つかったか調べるif (board.IsFinish()) {// Levelの値と置いた騎士の数は一致する。置いた騎士の数が少ないほうがより良い解。if (_mincount >; level) {// より良い解が見つかったので、解を覚える。_answer = new Chessboard(board);// _answer.Print();  // デバッグ用 暫定解を表示_mincount = level;}}}return;}if (level + 1 >;= _mincount)//  現在の最良解よりも悪いものなので、この探索は途中で打ち切るreturn;// 現在のブロックのそれぞれに対し、騎士が置けるかを調べるvar list = block.Where(ix =>; board[ix] == Piece.Empty).ToList();foreach (int pos in list) {if (Array.IndexOf(block, pos) >; Array.IndexOf(block, nowpos)) {// 直前に置いた騎士の位置よりもインデックスが小さいなら既に試してあるので、// インデックスが大きい場合に、新たに騎士をおいて、次の探索に行く。board.Put(pos);_Solve(board, level + 1, pos, block);// pos位置での試しは終わったので、次の探索ができるようにするためクリアする。board.Clear(pos);}}}
ひとつのブロックには、最大でも４つのKnightを配置すれば条件を満たせるはず。
*if (nextblock != null) {// 次のブロックの解を求める_Solve(board, level, nowpos, nextblock);} else {// すべてのブロックを処理し終わったので、解が見つかったか調べるif (board.IsFinish()) {// Levelの値と置いた騎士の数は一致する。置いた騎士の数が少ないほうがより良い解。if (_mincount >; level) {// より良い解が見つかったので、解を覚える。_answer = new Chessboard(board);// _answer.Print();  // デバッグ用 暫定解を表示_mincount = level;}}}
現在のブロックが正しいので、次のブロックを求める
*} else {
次のブロックの解を求める
*if (board.IsFinish()) {*// Levelの値と置いた騎士の数は一致する。置いた騎士の数が少ないほうがより良い解。
すべてのブロックを処理し終わったので、解が見つかったか調べる
*if (_mincount >; level) {*// より良い解が見つかったので、解を覚える。
Levelの値と置いた騎士の数は一致する。置いた騎士の数が少ないほうがより良い解。
より良い解が見つかったので、解を覚える。
*_answer = new Chessboard(board);
_answer.Print();   デバッグ用 暫定解を表示
*_mincount = level;
現在の最良解よりも悪いものなので、この探索は途中で打ち切る
*return;
*foreach (int pos in list) {if (Array.IndexOf(block, pos) >; Array.IndexOf(block, nowpos)) {// 直前に置いた騎士の位置よりもインデックスが小さいなら既に試してあるので、// インデックスが大きい場合に、新たに騎士をおいて、次の探索に行く。board.Put(pos);_Solve(board, level + 1, pos, block);// pos位置での試しは終わったので、次の探索ができるようにするためクリアする。board.Clear(pos);}}
現在のブロックのそれぞれに対し、騎士が置けるかを調べる
直前に置いた騎士の位置よりもインデックスが小さいなら既に試してあるので、
インデックスが大きい場合に、新たに騎士をおいて、次の探索に行く。
*board.Put(pos);
pos位置での試しは終わったので、次の探索ができるようにするためクリアする。
*board.Clear(pos);

*GameObject.Find("Master").GetComponent<;GameMaster<;().GameOver("ゲーム失敗．また挑戦しよう");
&lt;=====文字列を引数へ
*void Start () {resultMessageText.text = DataSender.resultMessage;}
Use this for initialization
*void Update () {}
Update is called once per frame
*void Start () {}
Use this for initialization
*void Update () {if (Input.GetKey(KeyCode.Space)) {SceneManager.LoadScene("Main");}}
Update is called once per frame

*Debug.Log(i.ToString().PadRight(5, '*'));
123**

*public enum State { Alive, Dead }
生死
*internal State Current { get; private set; }
現在の生死
*State Next { get; set; }
次の世代の生死
*IList<;Cell>; Neighbours { get; }
周囲のセル
*Rule Rule { get; }
次の世代の生死を判定するルール
*public Cell(State state, Rule rule) {Current = state;Rule = rule;Neighbours = new List<;Cell>;();}
初期状態を受け取る。ルールはDIします。
次の世代の生死を設定します。
*internal void SetNextState() =>;
世代を進めます。
*internal void ToNextGen() =>; Current = Next;
周囲のセルを設定します。
*internal void AddNeighbour(Cell neighbour) =>; Neighbours.Add(neighbour);
コンソール出力時の描画
*public override string ToString() =>; Current == State.Alive ? "o " : ". ";
*internal Cell.State GetNextState(Cell.State self, IList<;Cell>; neighbours) {int alives = neighbours.Count(cell =>; cell.Current == Cell.State.Alive);bool willBorn = alives == 3;bool isSurvive = alives == 2 &amp;&amp; self == Cell.State.Alive;return (willBorn || isSurvive) ? Cell.State.Alive : Cell.State.Dead;}
周囲の生きているセルの数から次代の生死を判定する
*public void ToNextGen() {var flattened = Cells.SelectMany(row =>; row);foreach (var cell in flattened)cell.SetNextState();foreach (var cell in flattened)cell.ToNextGen();}
セル達を次の世代へ進めます。
各セルに設定するルールをコンストラクタで受け取ります。
*public CellBuilder(Rule rule) =>; Rule = rule;
*public Cell[][] BuildCells(int rowLength, int colLength, int percentOfLivingCells) {var random = new Random();var cells = Enumerable.Range(1, rowLength).Select(_ =>; Enumerable.Range(1, colLength).Select(__ =>; {var state = (random.Next(1, 100) <; percentOfLivingCells)? Cell.State.Alive: Cell.State.Dead;return new Cell(state, Rule);}).ToArray()).ToArray();return ConnectNeighbours(cells);}
縦横の長さと生きたセルの割合を受け取りグリッド（配列の配列）を返します。
*Cell[][] ConnectNeighbours(Cell[][] cells) {foreach (var (row, rowIndex) in cells.Select((row, i) =>;(row, i))) {foreach (var (cell, colIndex) in row.Select((cell, i) =>;(cell, i))) {foreach (Cell neighbour in GetNeighbours(rowIndex, colIndex, cells.Length, row.Length))cell.AddNeighbour(neighbour);}}return cells;// 周囲のセルを取得します。ローカル関数です。IEnumerable<;Cell>; GetNeighbours(int rowIndex, int colIndex, int rowLength, int colLength) {for (int i = -1; i <; 2; i++) {for (int j = -1; j <; 2; j++) {if (i == 0 &amp;&amp; j == 0) continue;int offsetRow = circlate(rowIndex + i, rowLength);int offsetCol = circlate(colIndex + j, colLength);yield return cells[offsetRow][offsetCol];}}}}
各セルに周囲のセルを接続します。
*IEnumerable<;Cell>; GetNeighbours(int rowIndex, int colIndex, int rowLength, int colLength) {for (int i = -1; i <; 2; i++) {for (int j = -1; j <; 2; j++) {if (i == 0 &amp;&amp; j == 0) continue;int offsetRow = circlate(rowIndex + i, rowLength);int offsetCol = circlate(colIndex + j, colLength);yield return cells[offsetRow][offsetCol];}}}
周囲のセルを取得します。ローカル関数です。
*int circlate(int index, int length) {if (index <; 0) return index + length;if (index >;= length) return index - length;else return index;}
はみ出るインデクスを循環させます。(C#ではマイナスのインデクスで配列の後ろからn番目でアクセスができない)
*int circlate(int index, int length) {if (index <; 0) return index + length;if (index >;= length) return index - length;else return index;}
周囲のセルを取得する際にグリッド端のセルはハミ出るのでこれで逆の端と繋げます。
TextWriterは外部からDIします。
*public ConsoleDrawer(TextWriter writer) =>; StdOut = writer;
*public void DrawCells(Cell[][] cells) {Console.CursorTop = 0;Console.CursorLeft = 0;foreach (var row in cells) {foreach (var cell in row) {StdOut.Write(cell);}StdOut.WriteLine();}StdOut.Flush();}
グリッドをTextWriter.Flushで一気に出力します。

*var url = $"http:
www.kmoni.bosai.go.jpnewwebservicehypoeew{time}.json";

*{X = to.X - from.X,Y = to.Y - from.Y};
-----1. 補間する距離を調べる
-----2. 補間方向を調べる
*bool isRight   = distance.X >;= 0;
方向判定に使い終わったので使いやすいように絶対値にしておく
*distance.X = Math.Abs(distance.X);
これが補間されたドットのデータ一覧になる
*var dotPositions = new List<;Vector2Int>;();
*while(distance.X != 0 || distance.Y != 0)*{
-----3. 補間距離が０になるまで間のドットを潰していく
*var shift = new Vector2Int*{
ずらし距離
*dotPositions.Add(from + shift);*//大きい方の数値を減らす
データ追加
*if(distance.X >; distance.Y) distance.X--;*else distance.Y--;
大きい方の数値を減らす

*{if (Controller)device = SteamVR_Controller.Input((int)Controller.index);}
Use this for initialization
*{if (device != null)ControllerFunction(device);else if (Controller)device = SteamVR_Controller.Input((int)Controller.index);}
Update is called once per frame
Debug.Log("トリガーを浅く引いた");
*}
Debug.Log("トリガーを深く引いた");
*}
Debug.Log("トリガーを離した");
*}
Debug.Log("タッチパッドをクリックした");
*}
Debug.Log("タッチパッドをクリックしている");
*}
Debug.Log("タッチパッドをクリックして離した");
*}
Debug.Log("タッチパッドに触った");
*}
Debug.Log("タッチパッドを離した");
*}
Debug.Log("メニューボタンをクリックした");
*}
Debug.Log("グリップボタンをクリックした");
*}
Debug.Log("トリガーを浅く引いている");
*}
Debug.Log("トリガーを深く引いている");
*}
Debug.Log("タッチパッドに触っている");
*}

処理
*}
処理
*}

すべての null 値プロパティを除外
*IgnoreNullValues = true,
文字コードの設定
*Encoder = JavaScriptEncoder.Create(UnicodeRanges.All),
整形出力を行う
*WriteIndented = true
*{var optionsUTF8 = new JsonSerializerOptions{// すべての null 値プロパティを除外IgnoreNullValues = true,// 文字コードの設定Encoder = JavaScriptEncoder.Create(UnicodeRanges.All),// 整形出力を行うWriteIndented = true};return JsonSerializer.Serialize(model, optionsUTF8);}
拡張メソッドにしておくとちょっと便利
すべての null 値プロパティを除外
*IgnoreNullValues = true,
文字コードの設定
*Encoder = JavaScriptEncoder.Create(UnicodeRanges.All),
整形出力を行う
*WriteIndented = true

*if (novelListIndex <; messageList.Count)
全ての会話を表示したか

*Debug.Log(element.id + "," + element.name);
出力例 : 100,HogeItem

*slideContents.Add(slide.NotesPage.Shapes.Placeholders[2].TextFrame.TextRange.Text);
placefolders[1] is slide itself.
*if(success)*{
merge contents after closing ppt.
*foreach (PowerPoint.Shape subShape in shape.GroupItems)*{
because other ways like shape.GroupItem.Count &amp; shape.Ungroup thow an exception when shape is not a group.

*.SelectMany(x =<; x.Buffer(20))
20:明細最大行数
.SelectMany(x =&gt; x.Buffer(20) は
.Select(x =&gt; x.Buffer(20)).SelectMany(x =&gt; x) とも書ける
*}

共通変数
*/**************************/
トークンの作成
*/**************************/
tokens.Statuses.Update(new { status = text });  ツイート
*/**************************/
検索・リツイートの繰り返し
*/**************************/
検索
*/**************************/
*if (keyWordFlag)*{
検索ワード決定
検索実行
*var result = tokens.Search.Tweets(count =>; 100, q =>; keyWord);
リツイート実行
*/**************************/
つぶやき格納
*string tweetComent = tweet.Text;
コンソールに表示
*Console.WriteLine("===Tweet【" + tweetCntNo + "】【ID:"+ tweet.Id + "】===============================================");
カウンタ
*tweetCntNo += 1;
*if (checkTweet(tweet, keyWordFlag))*{
対象チェック
リツイート
*tokens.Statuses.Retweet(id =>; tweet.Id);
いいね
*tokens.Favorites.Create(id =>; tweet.Id);
*// Console.WriteLine("{0}: {1}",
コンソールに表示
再帰的呼出
*xrpTweetAsync();
*String APIKEY = "{API key}";
APIキーの設定
トークン作成
*/**************************/
いいねの数
---------------------------
if (tweet.FavoriteCount &lt; 1)
{
return false;
}
---------------------------
日本語
---------------------------
*if (!tweet.Language.Equals("ja"))
タグの数
---------------------------
タグのカウント
*HashtagEntity[] hashTags = tweet.Entities.HashTags;
除外タグ検索
---------------------------
*foreach(var tag in hashTags)
除外ワード検索
---------------------------
*if (tweet.Text.Contains("プレゼント") ||
除外ワード検索
---------------------------
*if (tweet.Text.Contains("プレゼント"))
XRP検索時、本文にXRPが入っていない場合は除外
---------------------------
*if (keyWordFlag &amp;&amp; !tweet.Text.Contains("XRP"))
XRPが含まれているだけのリツイートは除外
---------------------------
*string tweetCmnt = "";
合格
*return true;

*ClickUp = 1 <;<; 5,
ボタンを離したとき
OnPointerDown は Button.interactable とは関係無い
これを忘れると、interactable = false でもクリックできてしまう
*if (!interactable)
*// 全て if-elseif にしているのは、イベントを投げるときに 1フレームに1イベントだけ投げるようにするため*if ((_eventBitCode &amp; ButtonEventType.ClickDown) == ButtonEventType.ClickDown)
ここで ButtonEventType の各フラグを見て、どのイベントを投げるのか決定している。
*if ((_eventBitCode &amp; ButtonEventType.ClickDown) == ButtonEventType.ClickDown)*{
全て if-elseif にしているのは、イベントを投げるときに 1フレームに1イベントだけ投げるようにするため
ClickDown 時に interactable を false にして、入力が2つ(スマホだと指2本で1つのボタンをタップするとか)あっても 2個目以上は弾くようにしている
*interactable = false;
ClickUp したら、ボタンが再度 Click できるようにする。
*interactable = true;

*(int)(_arr_control_storage[_pos].Height * _form_ratio_height));
use for sizing

*GameObject go = Instantiate(arrowPrefab) as GameObject;
instantiateメソッドに引数arrowPrefabを渡すと、戻り値としてPrefabのインスタンスを返す。強制型変換であるキャストを使い、戻り値をGameObject型に変換

四角形の大きさ
*int width = 30;
グリッド描画めり込み最低値
*const int SINK_PERMISSION_NUM = 18;
頂点数
*int vertex = width * 8;
*var center = new { X = width * 0.5f, Y = height * 0.5f };
中心点
先にDegree -&gt; Radian用の数値を作っておく
*float toAngle = (float)Math.PI / vertex;
円を生成していく
*double angle = toAngle * i;
円頂点のドットへのめり込み量を調べる
*int sink = (int)((py % 1.0f) * 100);
*for (int j = 0;j <; py;++j)*{
ここでBoxを描画していく
上側のポジションY 偶数時の補正をするならここに-1
*int dotUpY = (int)(center.Y - j);
下側のポジションY
*int dotDownY = (int)(center.Y + j);
~~~~~~~描画~~~~~~~
DrawDot(dotX,dotUpY,dotDownY);
~~~~~~~~~~~~~~~~~~
*}

*context.SaveChanges();
これでエラー発生しない！

*Console.WriteLine(book.Title);
1984年
コンストラクタでプライベートフィールドを初期化する
*public Logger(TextWriter writer) =>; this.writer = writer;

*return false;
ここをコメントアウトするとデータが尽きるまでズンドコ言い続ける

第1引数：ファイルパス
第2引数：追記するテキスト
*File.WriteAllText(@"C:\Myfolder\test.txt", "Good morning!");
第1引数：ファイルパス
第2引数：追記するテキスト
*File.AppendAllText(@"C:\Myfolder\test.txt", "Good morning!");
第1引数：ファイルパス
第2引数：追記するテキスト
*File.AppendAllText(@"C:\Myfolder\test.txt", "Good morning!"+Environment.NewLine);
第1引数：ファイルパス
*string readText = File.ReadAllText(@"C:\Myfolder\test.txt");
ここにファイルIO処理を記述する
*}

*static void Main(string[] args) {// 問題の集合と部分和を入力するConsole.Write("集合=>; ");var strs = Console.ReadLine().Split(',');int[] nums = strs.Select(s =>; int.Parse(s.Trim())).ToArray();// 一つの集合に対して、複数のターゲットを調べることができるwhile (true) {Console.Write("ターゲット=>; ");var line = Console.ReadLine();if (line == "")break;int target = int.Parse(line);// 問題を解くvar ssp = new SubsetSumProblem(nums);var ans = ssp.Solve(target);if (ans.Length >; 0) {// 解が見つかったので、解を表示する。var ansStrings = ans.Select(n =>; n.ToString()).ToArray();var text = string.Join(" + ", ansStrings) + " = " + target;Console.WriteLine(text);} else {Console.WriteLine("解は存在しません");}}Console.ReadLine();}
ここは問題の本質じゃないbので手抜き
問題の集合と部分和を入力する
*Console.Write("集合=>; ");
*while (true) {*Console.Write("ターゲット=>; ");
一つの集合に対して、複数のターゲットを調べることができる
問題を解く
*var ssp = new SubsetSumProblem(nums);
解が見つかったので、解を表示する。
*var ansStrings = ans.Select(n =>; n.ToString()).ToArray();
*public class SubsetSumProblem {private int[] _nums;// numsの要素は、正整数とするpublic SubsetSumProblem(int[] nums) {this._nums = nums.ToArray();}private int[] _work;public int[] Solve(int target) {// 0. 配列pを用意する。サイズは、部分和(target)+1 とする。_work = new int[target + 1];// 1. 配列_workを初期化する _work[0] = 0, それ以外は -1 をセット。_work[0] = 0;for (int i = 1; i <;= target; i++)_work[i] = -1;// 2. 集合からひとつ要素を取り出し、m とする。foreach (var m in _nums) {for (int i = target; i >;= 0; i--) {// 3. 配列pを最後から見ていき、-1 以外の時に、4の処理を行うif (_work[i] == -1)continue;// 4. i + m <;= target で、_work[i+m] == -1 ならば、_work[i+m] に m を代入する。if (i + m <;= target &amp;&amp; _work[i + m] == -1)_work[i + m] = m;}// 5. _work[target] != -1 ならば、解が見つかったので、処理を終了する。//    _work[target] == -1 ならば 1.に戻って処理を繰り返す。if (_work[target] != -1)break;}return ToResult(_work, target);}// 作業用の配列から、部分集合を求めるprivate int[] ToResult(int[] work, int target) {var result = new List<;int>;();if (work[target] != -1) {while (target >; 0) {result.Add(work[target]);target = target - work[target];}}return (result as IEnumerable<;int>;).Reverse().ToArray();}}
部分和問題を動的計画法で解く
*public SubsetSumProblem(int[] nums) {this._nums = nums.ToArray();}
numsの要素は、正整数とする
0. 配列pを用意する。サイズは、部分和(target)+1 とする。
*_work = new int[target + 1];
1. 配列_workを初期化する _work[0] = 0, それ以外は -1 をセット。
*_work[0] = 0;
*foreach (var m in _nums) {*for (int i = target; i >;= 0; i--) {
2. 集合からひとつ要素を取り出し、m とする。
*if (_work[i] == -1)*continue;
3. 配列pを最後から見ていき、-1 以外の時に、4の処理を行う
*if (i + m <;= target &amp;&amp; _work[i + m] == -1)*_work[i + m] = m;
4. i + m &lt;= target で、_work[i+m] == -1 ならば、_work[i+m] に m を代入する。
5. _work[target] != -1 ならば、解が見つかったので、処理を終了する。
_work[target] == -1 ならば 1.に戻って処理を繰り返す。
*if (_work[target] != -1)
*private int[] ToResult(int[] work, int target) {var result = new List<;int>;();if (work[target] != -1) {while (target >; 0) {result.Add(work[target]);target = target - work[target];}}return (result as IEnumerable<;int>;).Reverse().ToArray();}
作業用の配列から、部分集合を求める

自分自身のAssemblyを取得し、名前を返す
*System.Reflection.Assembly asm = System.Reflection.Assembly.GetExecutingAssembly();
自分自身のAssemblyを取得し、バージョンを返す
*System.Reflection.Assembly asm = System.Reflection.Assembly.GetExecutingAssembly();

*parameters.Exponent = Base64.Decode(key[@"e"]);
公開指数

*var list = new List<;int>;(){1,2,3,4,5};
=&gt; 1 4 9 16 25
*var array = new[] {new{Name = "A", Age = 1},new{Name = "C", Age = 2},new{Name = "B", Age = 1},new{Name = "E", Age = 5},new{Name = "D", Age = 3},};
=&gt;2 4
*var list = new List<;int>;() { 1, 2, 3, 4, 5 };
=&gt; {A,1} {B,1} {C,2} {D,3} {E,5}
*var list = new List<;int>;(){1,2,2,3,3,3,4,5,5};
=&gt; 5
*var listA = new List<;int>;(){1,2,3,4,5};
=&gt; 1 2 3 4 5
*var listA = new List<;int>;(){1,2,3,4,5};
=&gt; 1 2 3 4 5 6 7 8
*var list = new List<;int>;(){1,2,3,4,5};
=&gt; 4 5
*var list = new List<;int>;(){1,2,3,4,5};
=&gt;True
*var list = new List<;int>;(){1,2,3,4,5};
=&gt;True

*if (string.IsNullOrEmpty(loadJsonStr))
セーブデータがない場合無駄な処理を行わないためのif文

*Debug.Print(output.ToString());
結果の出力
最後の5個を取り出す
*var lastFive = resQueue.Skip(resQueue.Count - 5);
*if (lastFive.SequenceEqual(answerArr))*{
答えと並びが一緒であること
ここが重要
inputStrを分解し、重複を削除してから結合
*var seedArr = string.Concat(inputStr.Select(x =>; x).Distinct());
inputStrをseedArrのindexに置き換え
*var answerArr = inputStr.Select(x =>; seedArr.IndexOf(x));
0～lastIdx未満の整数を追加
*resStack.Push(rnd.Next(0, lastIdx));
比較用に反転
*var revStack = resStack.Reverse();
*if (!revStack.SequenceEqual(answerArr.Take(resStack.Count)))*{
答えと並びが一緒であること

*if(chatClient!= null &amp;&amp; (int)Time.time % 5 == 0)*{
5秒に1回生存確認
*if(!chatClient.SendPrivateMessage("MyName", "keepalive"))*{
自分に発言してfalseが返ってきたらコネクトし直す
*if (this.chatClient != null) this.chatClient.Disconnect();*// 接続
切断
接続
*chatClient.Connect(this.appId, "1.0", new ExitGames.Client.Photon.Chat.AuthenticationValues("MyName"));

*connectableInterval.Connect();
Observable.Interval自体をHot化（ObservableソースがHot化する）
Observale.IntervalをHot化したものに接続する
*IDisposable connection = connectableObservable.Connect();
3秒経ったら切断して再接続する
*await Task.Delay(3000);

バイトオーダーをBigEndienからLittle Endienに変換してからBigIntegerを生成
*BigInteger value = new BigInteger(valueByteData.Reverse().ToArray());
OIDをピリオドで区切って数値配列に分けて格納する。
*int[] values = Oid.Split('.').Select(int.Parse).ToArray();
1個目、2個目
*result.AddRange(ConvByte(ParseXY(values[0], values[1])));
非同期受信開始
*udp.BeginReceive(ReceiveCallback, udp);
別スレッドから呼び出された場合
*Invoke(new ShowReceiveValueDelegate(ShowReceiveValue), value);

await前にTaskが終わるケース（UIスレッドの場合）
*Task task = Task.Run(() =>; Sleep(startTick, "3", "4", 250, 0));
await後にTaskが終わるケース（UIスレッドの場合）
*await Task.Run(() =>; B(startTick));
await後にTaskが終わるケース（ワーカースレッドの場合）
*await Task.Run(() =>; Sleep(startTick, "8?", "9", 500, 500));
await前にTaskが終わるケース（ワーカースレッドの場合）
*Task task = Task.Run(() =>; Sleep(startTick, "11", "12", 250, 1000));

*str = ary[0];
string型の変数にobject型は代入できない

*Console.WriteLine("abcde".Slice(3,4));
"d"

*Console.WriteLine(data[0]);
アドレスが更新されたため。

今回は上部分をずらすのでTopのみ修正
top = ;任意サイズ
gameWindow.offsetMin = new Vector2(left, bottom);下部分をずらしたいときに使用
*gameWindow.offsetMax = new Vector2(right, top);

*IEnumerable<;int<; evenList = idxList.Where(x =<; x % 2 == 1);
偶数桁目はindex=1,3,...
奇数／偶数のリストごとに、Selectで値を加工
（ここでは文字列.Substringにindexを渡して取り出し、数値リストに加工）
下記のサブメソッドEncodeToIntに分けてもよいかも
*IEnumerable<;int>; oddDigit = EncodeToInt(oddList, barcode);
それぞれSumで合計、奇数桁目は3倍の重み付け（ウェイト）
int sumOdd = oddDigit.Sum(x =&gt; x * 3);   一旦Selectで(x =&gt; x * 3)、あるいは次で3倍してもOK
int sumEven = evenDigit.Sum();           こちらはそのまま
合計をstringに変換
*int sumAll = sumOdd + sumEven;
10から「合計の下１桁」を引く
*int lastDigit = Integer.Parse(sumStr.Last());
チェックディジットは数値であることが前提なので、例外は起こします
必要に応じて例外処理を加えて下さい。
return list.Select(idx =&gt; barcode.Substring(idx, 1))         文字列を切り出して
.Select(chr =&gt; Integer.Parse(chr));               改めて数値リストに変換
*}

*void Start () {StartCoroutine(UpdateBankruptShader());}
coroutine を呼び出し
*while (this.GetComponent<;Renderer>;().material.GetFloat("progress") <; 2f)*{
Material 内部の progress プロパティ値が 2f になるまで繰り返し
Material 内部の progress プロパティの値を 0.01f 加算
*this.GetComponent<;Renderer>;().material.SetFloat("progress", this.GetComponent<;Renderer>;().material.GetFloat("progress") + 0.01f);
0.01sec 待つ
*yield return new WaitForSeconds(0.01f);

日付
*DateTime a = DateTime.Now;

とループ外で宣言してから
*yield return num;

VOICEROIDのパスの割り当て
*PATH_VOICEROID = @"...\VOICEROID.exe";
VOICEROIDの起動
*Process.Start(vr);
起動の待ち時間: 5000ms = 5s
*Thread.Sleep(5000);
*tb = main.IdentifyFromZIndex(2, 0, 0, 1, 0, 1, 1);*//再生ボタン
テキストボックス
*playbtn = new FormsButton(main.IdentifyFromZIndex(2, 0, 0, 1, 0, 1, 0, 3));*//保存ボタン
再生ボタン
*savebtn = new FormsButton(main.IdentifyFromZIndex(2, 0, 0, 1, 0, 1, 0, 1));*,,,
保存ボタン
テキストボックスにテキストを渡す
*tb["Text"](text);
再生
*playbtn.EmulateClick();
*while (!savebtn.Enabled)*{
音声読み終わりまで待つ
テキストを入手
*var text = talklist[0];
再生
*playbtn.EmulateClick();
*while (!savebtn.Enabled)*{
音声読み終わりまで待つ
TimelineとしてDataGridViewを作成
columnの作成
*var columnImage = new DataGridViewImageColumn();
columnの追加
*Timeline.Columns.Add(columnImage);
セルの内容に合わせて、行の高さが自動的に調節されるようにする
*Timeline.AutoSizeRowsMode = DataGridViewAutoSizeRowsMode.AllCells;
ツイート列のセルのテキストを折り返して表示する
*Timeline.Columns["ツイート"].DefaultCellStyle.WrapMode = DataGridViewTriState.True;
左側の項目を消す
*Timeline.RowHeadersVisible = false;
img = アイコンのURL
user = ScreenName
text = ツイートの内容
*WebClient wc = new WebClient();

*this._発言者.Add(pricure);
リストはセリフ自体の特性なので、外から与えないこととした。
List自体を、外から差し替えられないようにprivateにしている
*private List<;セリフ>; 開始の合図 = new List<;セリフ>;();
Listは「変身シーンのセリフ」の特性であると考えられるため、
引数のリストをそのまま代入せずに、中身だけを代入する
*if( 開始の合図 != null)

非同期受信開始
*udp.BeginReceive(ReceiveCallback, udp);
別スレッドから呼び出された場合
*Invoke(new ShowReceiveMessageDelegate(ShowReceiveMessage), message);

*fTempo[0] = modelview[0] * objx + modelview[4] * objy + modelview[8] * objz + modelview[12];
w is always 1

*static string[] Scopes = { SheetsService.Scope.Spreadsheets };
もしスコープを変えた時は事前にあるcredential（~/.credentials/sheets.googleapis.com-dotnet-quickstart.json）を消すこと
credentialを取得
*using (var stream =
*{HttpClientInitializer = credential,ApplicationName = ApplicationName,});
Google Sheets API サービスを作る
スプレッドシートID
*String spreadsheetId = "コピーしたスプレッドシートID";
*{new List<;object>;{"=ROW()","Bです","日付：", DateTime.Now.ToString()}};
データを新しい行に書き込む
終わり
*Console.WriteLine("書き込み完了");

*1.0
sec

*new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J2, NextTime =  6,            SlipTime = 1 },
波動拳                    状態は押している         キーは左   次の入力は 6フレーム以内 次の入力同時押し不可NextFrame判定
*new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J3, NextTime =  6,            SlipTime = 1 },
波動拳                    状態は押している         キーは左下 次の入力は 6フレーム以内 次の入力同時押し不可NextFrame判定
*new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J6, NextTime =  7,            SlipTime = 0 },
波動拳                    状態は押している         キーは右   次の入力は 7フレーム以内 次の入力同時押し可能ThisFrame判定
*new MoveCommand { DoFinger = Finger.Pressed, InputKey = Key.HP, NextTime =  0,            SlipTime = 0 },
波動拳                    状態は押した             キーはP    最後なので 0に必ずする   最後なので 0に必ずする
*new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J2, NextTime =  6,            SlipTime = 1 },
波動拳                    状態は押している         キーは左   次の入力は 6フレーム以内 次の入力同時押し不可NextFrame判定
*new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J3, NextTime =  6,            SlipTime = 1 },
波動拳                    状態は押している         キーは左下 次の入力は 6フレーム以内 次の入力同時押し不可NextFrame判定
*new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J6, NextTime =  7,            SlipTime = 0 },
波動拳                    状態は押している         キーは右   次の入力は 7フレーム以内 次の入力同時押し可能ThisFrame判定
*new MoveCommand { DoFinger = Finger.Pressed, InputKey = Key.HP, NextTime =  0,            SlipTime = 0 },
波動拳                    状態は押した             キーはP    最後なので 0に必ずする   最後なので 0に必ずする
十字キーの状態を取得
*float x = Input.GetAxisRaw("Horizontal");
十字キーおよびパンチキックの"押している"状態を変数に設定
*Hold = Key.Zero;
パンチキックの"押した"状態を変数に設定
*Pressed = Key.Zero;
技のコマンドリストの順序を反転
波動拳は下⇒右下⇒右⇒Pだが、
処理順はP⇒右⇒右下⇒下の順序で判定を行なうため反転。
*foreach (List<;MoveCommand>; MoveCommandData in MoveCommandList) MoveCommandData.Reverse();
*for (int i = 0; i <; InputGetKeyDataHistoryMax; ++i)*{
InputGetKeyDataの履歴保持用のインスタンス作成
フレームレートの設定
*Application.targetFrameRate = 60;
GC Alloc 等確認用プロファイラースタート
*Profiler.BeginSample("check_GC_Alloc");
処理時間計測用のストップウォッチスタート
*DebugStopwatch1.Restart();
InputGetKeyData追加処理更新
*InputGetKeyData.Update();
InputGetKeyDataの履歴保持用に今回のフレームのキー情報を取得
*int i = Time.frameCount % InputGetKeyDataHistoryMax;
*while (InputGetKeyTinyHistoryList.Count >;= InputGetKeyDataHistoryMax) InputGetKeyTinyHistoryList.RemoveAt(0);*// InputGetKeyDataの履歴保持用Listの末尾に今回のフレームのキー情報を追加
InputGetKeyDataの履歴保持用Listが最大数以上の場合には先頭から順次削除
InputGetKeyDataの履歴保持用Listの末尾に今回のフレームのキー情報を追加
*InputGetKeyTinyHistoryList.Add(InputGetKeyTinyHistoryData[i]);
技のコマンドリストを順次判定処理
本コードは波動拳だけなので1回転のみ
*foreach (List<;MoveCommand>; MoveCommandData in MoveCommandList)
処理時間計測用のストップウォッチスタート
*DebugStopwatch2.Restart();
技のコマンドのひとつひとつを順次判定処理
波動拳は下⇒右下⇒右⇒Pなので4回転
foreach1回目はP 　の判定
foreach2回目は右　の判定
foreach3回目は右下の判定
foreach4回目は下　の判定
*foreach (MoveCommand record in MoveCommandData)
GC Alloc 対策
*StaticInputKey = record.InputKey;
処理時間計測用のストップウォッチスタート
*DebugStopwatch3.Restart();
技のコマンドのひとつひとつを順次判定処理
波動拳は下⇒右下⇒右⇒Pなので4回判定
foreach1回目はP 　の判定
foreach2回目は右　の判定
foreach3回目は右下の判定
foreach4回目は下　の判定
*InputGetKeyTinyHistoryDataRow = record.DoFinger switch
*if (InputGetKeyTinyHistoryDataRow != null)*{
抽出データが存在する場合
次の判定用に判定用のStaticFrameCountを更新。allowを1にする。
*StaticFrameCount = InputGetKeyTinyHistoryDataRow.FrameCount;
*{allow = false;break;}
抽出データが存在しない場合は波動拳コマンド入力受付否認。
*if (DebugStopwatch3.IsRunning) DebugStopwatch3.Stop();*}
処理時間計測用のストップウォッチストップ
*if (DebugStopwatch2.IsRunning) DebugStopwatch2.Stop();*// コマンド入力受付承認?
処理時間計測用のストップウォッチストップ
*if (allow)*{
コマンド入力受付承認?
*Debug.Log($"{Time.frameCount}fr [判定所要時間]{DebugStopwatch2.ElapsedTicks,6:D}ticks, [受付承認技名]波動拳");
Consoleデバック表示
*Debug.Log($"{Time.frameCount}fr [判定所要時間]{DebugStopwatch2.ElapsedTicks,6:D}ticks, [受付否認技名]波動拳");
Consoleデバック表示
*if (DebugStopwatch1.IsRunning) DebugStopwatch1.Stop();*// GC Alloc 等確認用プロファイラーストップ
処理時間計測用のストップウォッチストップ
GC Alloc 等確認用プロファイラーストップ
*Profiler.EndSample();

*private Int32 version = 0;
SNMP V1

共通の前処理の実施
（イベント発生】呼び出し元個別の処理
呼び出し元でイベント発生時の処理を記述
*ExecuteMainProcessHandler(new GenericEventArgs<;string>;("Hello World!"));
共通の後処理を実施
*}
呼び出し元でイベント発生時の処理を記述
*ExecuteExceptionHandler(new GenericEventArgs<;Exception>;(e));
イベントが呼び出し元で定義されている場合のみイベント処理を実施
*EventHandler<;GenericEventArgs<;string>;>; handler = this.MainProcessHandler;
イベントが呼び出し元で定義されている場合のみイベント処理を実施
*EventHandler<;GenericEventArgs<;Exception>;>; handler = this.ExceptionHandler;
ある処理のインスタンスを生成し、イベントの処理を定義
*SomeProcessExecutor executor = new SomeProcessExecutor();
ある処理を実行する処理を実行
*executor.Execute();
呼び出し元個別の処理を定義
*MessageBox.Show(args.EventData);
呼び出し元個別の処理を定義（例外発生時）
*MessageBox.Show(args.EventData.ToString());

*using Assert = UnityEngine.Assertions.Assert;
AssertはNUnitのではなくUnityのものを使う
*{[Test]public void ResolveTest(){var container = new DiContainer();container.BindInstance("hoge");Assert.AreEqual("hoge", container.Resolve<;string>;());}[Test]public void ResolveAllTest(){var container = new DiContainer();container.BindInstance("hoge");container.BindInstance("fuga");var all = container.ResolveAll<;string>;();Assert.AreEqual(2, all.Count);Assert.AreEqual("hoge", all[0]);Assert.AreEqual("fuga", all[1]);}}
Zenjectの挙動確認を行う（あらかじめZenjectの導入が必要）
*{public int count { get; private set; }void Start(){this.count = 1;}}
適当なコンポーネントを定義
*{[UnityTest]public IEnumerator CountTest(){var go = new GameObject("Hoge");var hoge = go.AddComponent<;HogeComponent>;();// Start()前Assert.AreEqual(0, hoge.count);yield return null;// Start()後Assert.AreEqual(1, hoge.count);}}
テスト用クラス
Start()前
*Assert.AreEqual(0, hoge.count);
Start()後
*Assert.AreEqual(1, hoge.count);

*[SerializeField] Item iteminfo;
さっきのアイテム情報をアタッチ
プレイヤーの所持アイテムはここで管理
*using UnityEngine;
*{return itemLists;}
アイテムリストを返す
所持アイテムをアイテム画面に映す。改良の余地あり
*using System.Collections.Generic;
*{PlayersItem.itemLists.ObserveAdd().Subscribe(_ =>; ReloadItemSlots());PlayersItem.itemLists.ObserveRemove().Subscribe(_ =>; ReloadItemSlots());}
Use this for initialization

OIDをピリオドで区切って数値配列に分けて格納する。
*int[] values = Oid.Split('.').Select(int.Parse).ToArray();
1個目、2個目
*result.AddRange(ConvByte(ParseXY(values[0], values[1])));

*var lazy = new LazySlim1<;Foo<;(() =<; new Foo());
LazySlim2, Lazyに差し替えた版も用意

*digitalWrite(LED, LOW);
オフ

*var urls = doc.Root.Descendants("{http:
search.yahoo.commrss}thumbnail")

なんか色々文字置換とかの処理をここでしましょう
↓このままだと、設定されたメッセージがそのまま出力されるので、いい感じに変えてください
*writer.Write(loggingEvent.RenderedMessage);

*Console.WriteLine(list.Sum().Value);
6
*if (a is { X: { Y: { Z: 4 } } }) { ... }
例：#line (1, 1) - (2, 2) 3 "test.cs"

サインアップ
*var hashStr = SignUp(password);
サインイン
*Console.WriteLine(SignIn(password, hashStr));

何の数字かはお察しください...
*var tuple = ("鍵山雛", 50, 45, 49);
*var Fujinroku = new Character[] {new Character(162, 84, 52, 83) {Name = "秋静葉",Category = "東方風神録"},new Character(163, 94, 62, 81) {Name = "秋穣子",Category = "東方風神録"},new Character(172, 94, 57, 89) {Name = "鍵山雛",Category = "東方風神録"},new Character(161, 88, 52, 91) {Name = "河城にとり",Category = "東方風神録"},new Character(165, 86, 64, 83) {Name = "犬走椛",Category = "東方風神録"},new Character(169, 92, 55, 88) {Name = "射命丸文",Category = "東方花映塚"}new Character(168, 94, 65, 94) {Name = "東風谷早苗",Category = "東方風神録"},new Character(176, 88, 60, 88) {Name = "八坂神奈子",Category = "東方風神録"}new Character(152, 79, 52, 80) {Name = "洩矢諏訪子",Category = "東方風神録"}};
数値については異論を認める
*public int GetTall() {return Tall;}
一つずつGetterを作るのは面倒だよね
*public (int, int, int) GetThreeSize() {return (Bust, Waist, Hip);}
プロパティを根こそぎ浚える
ぱんつはいてません
*UdonChang.SetColor(("#DA81F5", "#FE2E2E", null));
ローカル変数と同じ扱いなので、雛ちゃんのスリーサイズは同一スコープ内で利用できる
*(int Bust, int Waist, int Hip) = HinaChangNoThreeSize;
直接メソッドから取ることもできる
*(Bust, Waist, Hip) = Fujinroku[2].GetThreeSize();
*tupleList.Add((1, new Character(171, 89, 52, 88) {Name = "博麗霊夢",Category = "自機"}));
世界一位
*tupleList.Add((2, new Character(167, 84, 57, 90) {Name = "霧雨魔理沙",Category = "自機"}));
悔しいので来年は抜いてやるぜ
*tupleList.Add((9, new Character(174, 92, 63, 91) {Name = "アリス・マーガトロイド",Category = "東方妖々夢"}));
⑨位でいいの。謙虚だもの私

dbの処理
*var userList = (from n in db.user_info select n).ToList();

*static class ArrayRotation {// 中央横軸を中心に回転するpublic static int[,] HorRotate(this int[,] array) {var work = array.Clone() as int[,];int xLeng = work.GetLength(0);for (int x = 0; x <; xLeng / 2; x++) {for (int y = 0; y <; work.GetLength(1); y++) {int temp = work[x, y];work[x, y] = work[xLeng - x - 1, y];work[xLeng - x - 1, y] = temp;}}return work;}}
２次元配列の回転を行うクラス（要素数には依存しない)
*public static int[,] HorRotate(this int[,] array) {var work = array.Clone() as int[,];int xLeng = work.GetLength(0);for (int x = 0; x <; xLeng / 2; x++) {for (int y = 0; y <; work.GetLength(1); y++) {int temp = work[x, y];work[x, y] = work[xLeng - x - 1, y];work[xLeng - x - 1, y] = temp;}}return work;}
中央横軸を中心に回転する
*static class ArrayRotation {......// 左上から右下への斜め対角線軸を中心に反転するpublic static int[,] RightDownDiagRotate(this int[,] array) {var work = array.Clone() as int[,];for (int y = 1; y <; work.GetLength(1); y++) {for (int x = 0; x <; y; x++) {int temp = work[x, y];work[x, y] = work[y, x];work[y, x] = temp;}}return work;}}
２次元配列の回転を行うクラス（要素数には依存しない)
*public static int[,] RightDownDiagRotate(this int[,] array) {var work = array.Clone() as int[,];for (int y = 1; y <; work.GetLength(1); y++) {for (int x = 0; x <; y; x++) {int temp = work[x, y];work[x, y] = work[y, x];work[y, x] = temp;}}return work;}
左上から右下への斜め対角線軸を中心に反転する
*static class ArrayRotation {// これが基準public static int[,] TurnLeft90(this int[,] array) {return array.RightDownDiagRotate().HorRotate();}public static int[,] TurnLeft180(this int[,] array) {return array.TurnLeft90().TurnLeft90();}public static int[,] TurnLeft270(this int[,] array) {return array.TurnLeft180().TurnLeft90();}public static int[,] TurnLeft360(this int[,] array) {return array.Clone() as int[,];}public static int[,] TurnRight90(this int[,] array) {return array.TurnLeft270();}public static int[,] TurnRight180(this int[,] array) {return array.TurnLeft180();}public static int[,] TurnRight270(this int[,] array) {return array.TurnLeft90();}public static int[,] TurnRight360(this int[,] array) {return array.Clone() as int[,];}public static int[,] VertRotate(this int[,] array) {return array.RightDownDiagRotate().TurnRight90();}// 中央横軸を中心に回転するpublic static int[,] HorRotate(this int[,] array) {var work = array.Clone() as int[,];int xLeng = work.GetLength(0);for (int x = 0; x <; xLeng / 2; x++) {for (int y = 0; y <; work.GetLength(1); y++) {int temp = work[x, y];work[x, y] = work[xLeng - x - 1, y];work[xLeng - x - 1, y] = temp;}}return work;}public static int[,] RightUpDiagRotate(this int[,] array) {return array.TurnLeft180().RightDownDiagRotate();}// 左上から右下への斜め軸を中心に回転するpublic static int[,] RightDownDiagRotate(this int[,] array) {var work = array.Clone() as int[,];for (int y = 1; y <; work.GetLength(1); y++) {for (int x = 0; x <; y; x++) {int temp = work[x, y];work[x, y] = work[y, x];work[y, x] = temp;}}return work;}}
２次元配列の回転を行うクラス（要素数には依存しない)
*public static int[,] TurnLeft90(this int[,] array) {return array.RightDownDiagRotate().HorRotate();}
これが基準
*public static int[,] HorRotate(this int[,] array) {var work = array.Clone() as int[,];int xLeng = work.GetLength(0);for (int x = 0; x <; xLeng / 2; x++) {for (int y = 0; y <; work.GetLength(1); y++) {int temp = work[x, y];work[x, y] = work[xLeng - x - 1, y];work[xLeng - x - 1, y] = temp;}}return work;}
中央横軸を中心に回転する
*public static int[,] RightDownDiagRotate(this int[,] array) {var work = array.Clone() as int[,];for (int y = 1; y <; work.GetLength(1); y++) {for (int x = 0; x <; y; x++) {int temp = work[x, y];work[x, y] = work[y, x];work[y, x] = temp;}}return work;}
左上から右下への斜め軸を中心に回転する
*{ 11, 12, 13, 14, 15, 16, 17, 18, 19 },
array[x,y]でアクセス。x軸が縦、y軸が横
*{ 11, 12, 13, 14, 15, 16, 17, 18, 19 },
array[0,2]-&gt;13  array[4,0]-&gt; 51

albireoさま コメントよりコピー
*var result = Enumerable.Repeat("", 9).ToArray();

*Padding = new Thickness(100, top, 100, 0);
これに変更！！

*if (Physics.Raycast (ray, out hit, maxRayDistance, collisionLayer)) {//we're going to get the position from the contact pointm_HitTransform.position = hit.point;Debug.Log (string.Format ("x:{0:0.######} y:{1:0.######} z:{2:0.######}", m_HitTransform.position.x, m_HitTransform.position.y, m_HitTransform.position.z));//and the rotation from the transform of the plane colliderm_HitTransform.rotation = hit.transform.rotation;}
we'll try to hit one of the plane collider gameobjects that were generated by the plugin
*if (Physics.Raycast (ray, out hit, maxRayDistance, collisionLayer)) {*//we're going to get the position from the contact point
effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
*m_HitTransform.position = hit.point;*Debug.Log (string.Format ("x:{0:0.######} y:{1:0.######} z:{2:0.######}", m_HitTransform.position.x, m_HitTransform.position.y, m_HitTransform.position.z));
we're going to get the position from the contact point
*m_HitTransform.rotation = hit.transform.rotation;*}
and the rotation from the transform of the plane collider
*if (Physics.Raycast (ray, out hit, maxRayDistance, collisionLayer)) {//we're going to get the position from the contact pointm_HitTransform.position = hit.point;Debug.Log (string.Format ("x:{0:0.######} y:{1:0.######} z:{2:0.######}", m_HitTransform.position.x, m_HitTransform.position.y, m_HitTransform.position.z));//and the rotation from the transform of the plane colliderm_HitTransform.rotation = hit.transform.rotation;}
we'll try to hit one of the plane collider gameobjects that were generated by the plugin
*if (Physics.Raycast (ray, out hit, maxRayDistance, collisionLayer)) {*//we're going to get the position from the contact point
effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
*m_HitTransform.position = hit.point;*Debug.Log (string.Format ("x:{0:0.######} y:{1:0.######} z:{2:0.######}", m_HitTransform.position.x, m_HitTransform.position.y, m_HitTransform.position.z));
we're going to get the position from the contact point
*m_HitTransform.rotation = hit.transform.rotation;*}
and the rotation from the transform of the plane collider

Calculateデリゲートの宣言
*delegate int Calculate (int a, int b);
*class Test {public static void Main() {// デリゲートの生成Printer print = new Printer(Console.WriteLine);// デリゲートの実行print("Hello World");}}
デリゲートの宣言
デリゲートの生成
*Printer print = new Printer(Console.WriteLine);
デリゲートの実行
*print("Hello World");
*class Test {public static void Main() {// デリゲートの生成Printer print = delegate (string s) {Console.WriteLine(s);}// デリゲートの実行print("Hello World");// 匿名メソッドはデリゲート変数に代入することも可能print = delegate (string s) {Console.WriteLine($"You inputed \"{s}\"");};print("I'm fine");}}
デリゲートの宣言
*Printer print = delegate (string s) {Console.WriteLine(s);}
デリゲートの生成
デリゲートの実行
*print("Hello World");
*print = delegate (string s) {Console.WriteLine($"You inputed \"{s}\"");};
匿名メソッドはデリゲート変数に代入することも可能
式
*}
式
*}
*class Test {public static void Main() {Printer print = (string s) =>; {Console.WriteLine($"You inputed \"{s}\"");};print("I'm fine");}}
デリゲートの宣言

*private void ChangeisOpen()
状態が変わったことを１秒遅れにするためにInvokeメソッド

*private Text mGameOverText;
TextGameOverを指定
ステージの生成
*case STATE.LOAD_STAGE:
Enter入力でゲームを開始
*case STATE.WAIT_ENTER_KEY:
プレイ中
*case STATE.PLAY:
タイムテキスト
---------------------------------------------------------------------------------
*[SerializeField]
制限時間を設定
*追加        mRestTime = 100;
プレイヤーとチェイサーの行動開始
*mConstructor.OnActivePlayer();
コルーチンを開始
*StartCoroutine("PopupFollower");
制限時間
---------------------------------------------------------------------------------
*private int mRestTime;
制限時間終了でプレイヤーをダウン状態へ遷移 → それによってEndGameが呼ばれる
*mRestTime--;
*if (mRestTime == 10) GameController.Instance.UiManager.ChangeTimeTextColorIntoRed();*GameController.Instance.UiManager.RenewTime(mRestTime);
残り時間10秒になったときにテキストの色を赤に変更する

平行投影
*GL.Ortho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);

*log4net.GlobalContext.Properties["user"] = "user";
クライアントのユーザーIDを設定する

*return new DowntimeReport[] {GetFailureDowntimeReport("Team01", "Team01POI", date),GetFailureDowntimeReport("Team01", "Team01POI", (date + TimeSpan.FromSeconds(1))),GetFailureDowntimeReport("Team01", "Team01POI", (date + TimeSpan.FromSeconds(2)))};
Normal case failure

*// { 2, 4, 6, 8, 10 }
{引数} =&gt; {処理内容&amp;return}

パーサを生成
*var parser = new MimeParser(stream, MimeFormat.Mbox);
メッセージをパースする
*var message = parser.ParseMessage();
メッセージを使って何かする
*Console.WriteLine("[From]");

*string path2;
out file name

*lookup[2000]
=&gt; 発行年が2000年の book オブジェクト一覧が返る
第二引数にラムダ式を与えることで、値を指定できる
*var lookup = books.ToLookup(b =>; b.PublishedYear, b =>; b.Title);
ToLookup と ToDictionary で2度ループが回る
*var dic = books
GroupBy と ToDictionary なら ループが回るのは ToDictionary の一度だけ
*var dic = books

*Func<;NamedPipeServerStream>; createpipe = delegate() {var ps = new PipeSecurity();ps.AddAccessRule(new PipeAccessRule("Everyone", PipeAccessRights.FullControl, System.Security.AccessControl.AccessControlType.Allow));return new NamedPipeServerStream(this._PipeName, PipeDirection.InOut, 1, PipeTransmissionMode.Message, PipeOptions.Asynchronous, 1024, 1024, ps);};
パイプサーバ作成

*string[] str = Console.ReadLine().Split(' ');
ここで半角スペース区切りで取る

*public string GetString(string resourceKeyName) {return Translator<;Properties.Resources>;.Translate(resourceKeyName);}
...

*private State mCurrentState;
現在のステート
すでにprevStateとnextStateの組み合わせでコールバックが仕込まれていたら
prevStateとnextStateの組み合わせのコールバックは１つのみ
*if (mSwitchTable.ContainsKey(prevState) &amp;&amp; mSwitchTable[prevState].ContainsKey(nextState))
次のラムダ式を式木で構築
(S s) =&gt; (T)s
*var p = Expression.Parameter(typeof(S), "target");

*{// ...}
上を下に
*new ViewDataDictionary { Model = model },
create a view context and assign the model

*string returnStr = inst.ReadString();
応答を文字列で取得する

*foreach(var txtbox in GetAllControls<;TextBox>;(form, c =>; c.Name.EndsWith("ID")))*{
名前が"ID"で終わるテキストボックスをdisableに
*foreach(var txtbox in GetAllControls<;TextBox>;(form, c =>; c.Parent?.Name.StartWith("panel") ?? false))*{
名前が"panel"で始まるコンテナ直下のテキストボックスを非表示に

*App.Main();
Run WPF startup code.
*if (dllName.EndsWith("resources.dll") &amp;&amp; !CultureInfo.InvariantCulture.Equals(assembly.CultureInfo))*{
Load satelite assembly
*var resourceName = thisAssembly.GetManifestResourceNames().Where(*s =>; s.EndsWith(dllName, true, null)).FirstOrDefault();
in the same folder as the app.

*this[index] = new T();
初期値
*public virtual IEnumerable<;int>; GetAllIndexes() {for (int y = 1; y <;= this.YSize; y++) {for (int x = 1; x <;= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する
*public virtual IEnumerable<;int>; EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index); index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む
(x,y)から右(水平)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Horizontal(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Virtical(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantR(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantL(int x, int y)
*if (board.IsFin()) {*if (board.CanBackHome())
全ての位置に移動し、現在の位置からStart地点にジャンプできれば、解が求まった。
*foreach (int pos in list) {board.Jump(pos);// 枝刈り用の処理：この判断が無いととてつもなく遅くなってしまう。if (board[pos] is Footmark fm) {// 開始位置からJumpする場所が無いなら、これ以上探しても意味が無いので次の可能性へ。if ((fm.Number != board.YSize * board.XSize) &amp;&amp;(board.CanPutPlaces(_startPlace).Count() == 0)) {board.Clear(pos);continue;}}// 枝刈り：ここまでvar ans = SolveInner(board, pos);if (ans != null)return ans;board.Clear(pos);}
OrderBy を入れるか入れないかで、圧倒的な速度差が出る
*if (board[pos] is Footmark fm) {*// 開始位置からJumpする場所が無いなら、これ以上探しても意味が無いので次の可能性へ。
枝刈り用の処理：この判断が無いととてつもなく遅くなってしまう。
*if ((fm.Number != board.YSize * board.XSize) &amp;&amp;*(board.CanPutPlaces(_startPlace).Count() == 0)) {
開始位置からJumpする場所が無いなら、これ以上探しても意味が無いので次の可能性へ。
枝刈り：ここまで
*var ans = SolveInner(board, pos);
ジャンプできる場所はすべて試した。解は見つからない。
*return null;

*static T CreateObjBase<;T>;(int id1, int id2, int id3) where T : ObjBase {var maker = NewObjectHelper<;T>;.CreateMethod<;Func<;int, int, int, T>;>;();return maker(id1, id2, id3);}
引数ありコンストラクターを呼ばせるジェネリックで関数
*static class NewObjectHelper<;TInstance>; {//使うFunc型から引数の型だけ抜き出すstatic Type[] CreateParameterType<;TFunc>;() where TFunc : Delegate {//Type.GetGenericArguments()で//ジェネリック型に指定された型を全て取り出せるvar method_use_types = new List<;Type>;(typeof(TFunc).GetGenericArguments());//使うFunc型の戻り値の型だけ除外var deleteIndex = method_use_types.FindIndex((i) =>; i == typeof(TInstance));method_use_types.RemoveAt(deleteIndex);return method_use_types.ToArray();}//Type配列から式木用の配列を作成static List<;ParameterExpression>; CreateParamsListFromTypes(Type[] types) {var paramList = new List<;ParameterExpression>;(types.Length);foreach (var i in types) paramList.Add(Expression.Parameter(i));return paramList;}//式木を使ってコンストラクタを呼ぶ関数を作成public static TFunc CreateMethod<;TFunc>;() where TFunc : Delegate {var argsType = CreateParameterType<;TFunc>;();var paramList = CreateParamsListFromTypes(argsType);var flag = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;var constructor = typeof(TInstance).GetConstructor(flag,Type.DefaultBinder,argsType,null);return Expression.Lambda<;TFunc>;(Expression.New(constructor, paramList),paramList).Compile();}//式木を使ってコンストラクタを呼ぶ関数を作成////引数のtypeValueで戻り値の型推論をさせるpublic static TFunc CreateMethod<;TFunc>;(TFunc typeValue) where TFunc : Delegate {var argsType = CreateParameterType<;TFunc>;();var paramList = CreateParamsListFromTypes(argsType);var flag = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;var constructor = typeof(TInstance).GetConstructor(flag,Type.DefaultBinder,argsType,null);return Expression.Lambda<;TFunc>;(Expression.New(constructor, paramList),paramList).Compile();}}
TInstanceに戻り値の型を指定
*static Type[] CreateParameterType<;TFunc>;() where TFunc : Delegate {//Type.GetGenericArguments()で//ジェネリック型に指定された型を全て取り出せるvar method_use_types = new List<;Type>;(typeof(TFunc).GetGenericArguments());//使うFunc型の戻り値の型だけ除外var deleteIndex = method_use_types.FindIndex((i) =>; i == typeof(TInstance));method_use_types.RemoveAt(deleteIndex);return method_use_types.ToArray();}
使うFunc型から引数の型だけ抜き出す
Type.GetGenericArguments()で
ジェネリック型に指定された型を全て取り出せる
*var method_use_types = new List<;Type>;(typeof(TFunc).GetGenericArguments());
使うFunc型の戻り値の型だけ除外
*var deleteIndex = method_use_types.FindIndex((i) =>; i == typeof(TInstance));
*static List<;ParameterExpression>; CreateParamsListFromTypes(Type[] types) {var paramList = new List<;ParameterExpression>;(types.Length);foreach (var i in types) paramList.Add(Expression.Parameter(i));return paramList;}
Type配列から式木用の配列を作成
*public static TFunc CreateMethod<;TFunc>;() where TFunc : Delegate {var argsType = CreateParameterType<;TFunc>;();var paramList = CreateParamsListFromTypes(argsType);var flag = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;var constructor = typeof(TInstance).GetConstructor(flag,Type.DefaultBinder,argsType,null);return Expression.Lambda<;TFunc>;(Expression.New(constructor, paramList),paramList).Compile();}
式木を使ってコンストラクタを呼ぶ関数を作成
式木を使ってコンストラクタを呼ぶ関数を作成

引数のtypeValueで戻り値の型推論をさせる
*public static TFunc CreateMethod<;TFunc>;(TFunc typeValue) where TFunc : Delegate {
*abstract class ObjBase {public int Id1;public int Id2;public int Id3;public override string ToString() {return  "[" + Id1 + " : " + Id2 + " : " + Id3 + "]";}}
テスト用クラス

*System.Threading.Thread.Sleep(len);
一定時間音を鳴らし続ける

重複した単語を探す
*var pattern = @"\b(\w+?)\s\1\b";

１．各要素の値ごとに、素因数分解
*var primeFactorizes = nums.Select(n =>; PrimeFactorize(n));
２．素数リストの各値について、素因数分解した結果から指数を並べる
*var dic = LineUpPowerIndex(primeFactorizes);
３．最小公倍数・最大公約数の計算
*var result = Calc(dic);
*if (tmp == 1) { break; }*//指数の初期化
除算の結果が1になったら終了
指数の初期化
*var i = 0;
割ったら余りが0の時、指数を+1し、除算
*i++;
*if (i >; 0) { primeDic.Add(n, i); }*}
指数決定
素因数のリスト作成
*var plist = new List<;int>;();
素因数のリストと、それに対応する指数の配列作成(初期値0)
*primes.ToList().ForEach(p =>; dic.Add(p, Enumerable.Repeat<;int>;(0, primeFactorizes.Count()).ToArray()));
素因数分解の結果を反映
*var idx = 0;
素因数の指数乗を計算
*var ar = kv.Value.Select(v =>; (int)Math.Pow(kv.Key, v)).ToArray();
最大値の積→最小公倍数
*leastCommonMultiple = leastCommonMultiple * (ar.Max());
最小値の積→最大公約数
*greatestCommonDivisor = greatestCommonDivisor * (ar.Min());
結果をタプルで返す
*return new Tuple<;int, int>;(leastCommonMultiple, greatestCommonDivisor);

*ServicePointManager.DnsRefreshTimeout = 10 * 1000;
10秒に設定

*if (drawPosition <;= result.GetLength(0))
マネージリソース(Line bar[])の解放は自動でガベージコレクションが行う
描画する方法 (Brush)を設定
bar[j].Stroke = brush;   System.Windows.Media.Brushes.LightBlue;
(親要素内に作成されるときに適用される)水平方向の配置特性を、(親要素のレイアウトのスロットの)左側に設定
*bar[j].HorizontalAlignment = HorizontalAlignment.Left;
(親要素内に作成されるときに適用される)垂直方向の配置特性を、(親要素のレイアウトのスロットの)中央に設定
*bar[j].VerticalAlignment = VerticalAlignment.Center;
始点のx座標を設定
*bar[j].X1 = j * 7 + 32;
終点のx座標を設定
*bar[j].X2 = j * 7 + 32;
始点のy座標を設定
*bar[j].Y1 = 0;
終点のy座標を設定 (result[,]は、0 ~ 1の値)
*bar[j].Y2 = 7700 * result[drawPosition, j];
*if (bar[j].Y2 >;= 400)*bar[j].Y2 = 400;
長さが400より大きい場合は長さを400にする
幅を設定
*bar[j].StrokeThickness = 5;
画面にLine(バー)を追加
*grid.Children.Add(bar[j]);
描画済みにする
*barDrawn = true;

意図通りのコード
*var mode = Mode.READ;
想定外の値も入ってしまう!
*mode = 4;
ビルドエラー!!
*mode = 4;

*private RectTransform myRectTransform;
オブジェクト自身の位置
*void Start () {this.myRectTransform = GetComponent<;RectTransform>;( );}
Use this for initialization
*void Update () {// マウスカーソルに追尾するかどうかを切り替えるif (Input.GetKeyDown("space")) {this.canMove = !this.canMove;}// 追尾可能ならマウスに追従させるif (this.canMove) {MoveOnMouse(ref this.myRectTransform, Camera.main);}}
Update is called once per frame
*if (Input.GetKeyDown("space")) {*this.canMove = !this.canMove;
マウスカーソルに追尾するかどうかを切り替える
*if (this.canMove) {*MoveOnMouse(ref this.myRectTransform, Camera.main);
追尾可能ならマウスに追従させる

*var c = null == CONST;
false

*public const string NICONICO_LOGIN_URL = "https:
secure.nicovideo.jpsecurelogin?site=niconico";
これがめっちゃ重要
*www.redirectLimit = 0;
post情報が間違っててSet-Cookieすら含まれない状態
*Debug.Log(keyNotFoundException.Message);
*foreach(string cookie in setCookieHeader.Split(new string[] {"user_session="}, StringSplitOptions.None)) {
Set-Cookieヘッダに含まれるuser_sessionは3つあって、そのうち必要なものはuser_sessionから始まる
*foreach(string cookie in setCookieHeader.Split(new string[] {"user_session="}, StringSplitOptions.None)) {*if(cookie.StartsWith("user_session")) {
他は"deleted"とsecureなんたらとかいうの。いらない。（知らんけど)

*if (text.Contains(target))
&lt;-拡張メソッドのほうの Contains

*case 2:
フェードイン

sut はSystem under testを指す
*var sut = new FizzBuzzService();
Startup.cs の設定によりコンストラクタの引数に FizzBuzzService が渡される
*public FizzBuzzController(IFizzBuzz fizzbuzz) =>;

[1] バインドデータ作成
----------------------------------------
*DataTable personTable = new DataTable("PersonTable");
*{new DataColumn("ID", typeof(string)),new DataColumn("Name", typeof(string)),new DataColumn("Gender", typeof(string)),new DataColumn("Remarks", typeof(string))});
カラム設定
*personTable.Rows.Add(new string[] { "001", "Taro Tanaka", "Male", "Normal Employee" });
データを追加
[2] GridViewにバインド
----------------------------------------
*this.PersonView.DataSource = new DataView(personTable);
*if (e.Row.RowType == DataControlRowType.DataRow)*{
DataBind行のみを対象
IDセルの行幅を設定
*e.Row.Cells[0].RowSpan = 2;

*1000
最大高

下2行を追加
*ViewData["CurrentFilterDateFrom"] = dateFrom?.ToString("yyyy-MM-dd") ?? "";
*{//return View(await _context.Salary.ToListAsync());var refUrl = Request.Headers["Referer"].ToString();var refUri = new System.Uri(refUrl);if (refUri.Segments.Length >; 2 &amp;&amp; (refUri.Segments[2] == "Details/" || refUri.Segments[2] == "Edit/")){dateFrom = TempData["CurrentFilterDateFrom"] as DateTime?;dateTo = TempData["CurrentFilterDateTo"] as DateTime?;}TempData["CurrentFilterDateFrom"] = dateFrom?.ToString("yyyy-MM-dd") ?? (TempData["CurrentFilterDateFrom"] as DateTime?)?.ToString("yyyy-MM-dd");TempData["CurrentFilterDateTo"] = dateTo?.ToString("yyyy-MM-dd") ?? (TempData["CurrentFilterDateTo"] as DateTime?)?.ToString("yyyy-MM-dd");TempData.Keep();var salaries = from s in _context.Salary select s;salaries = salaries.Where(x =>; x.RegisterUser == (User.Identity.Name ?? "DUMMY"));if (!(dateFrom == null) &amp;&amp; !(dateTo == null)){salaries = salaries.Where(x =>; x.PaymentDate >;= dateFrom &amp;&amp; x.PaymentDate <;= dateTo);} else if (!(dateFrom == null)){salaries = salaries.Where(x =>; x.PaymentDate >;= dateFrom);} else if (!(dateTo == null)){salaries = salaries.Where(x =>; x.PaymentDate <;= dateTo);}return View(await salaries.ToListAsync());}
GET: Salaries

*.Select( (v,idx) =<; v.Equals(refer[idx]) ? "" : v)
差分なしは何を返せばいいのか? nullは嫌だ

キー入力を受け取る-&gt;keyInputに格納
*Method(map);
キー入力を受け付ける
*string keyInput = Console.ReadLine();
*if (keyInput == "A" || keyInput == "a")*{
もし「A」が押されたら、
*else if (map[positionP - 1] == "b")*{
bのループ
*else if (map[positionP - 1] == "j")*{
jのループ
*else if (map[positionP - 1] == "o")*{
jのループ
*else if (map[positionP - 1] == "k")*{
jのループ
*else if (map[positionP - 1] == "g")*{
bのループ
*else if (map[positionP - 1] == "G")*{
ゴール時
*else if (map[positionP + 1] == "e")*{
eのわーぷ
*else if (map[positionP + 1] == "i")*{
iのわーぷ
*else if (map[positionP + 1] == "m")*{
iのわーぷ
*if (keyInput == "W" || keyInput == "w")*{
もし「W」が押されたら、
*else if (map[positionP - 15] == "c")*{
cのループ
*if (keyInput == "S" || keyInput == "s")*{
もし「S」が押されたら、
*else if (map[positionP + 15] == "a")*{
もし↓が押されたら
*else if (map[positionP + 15] == "f")*{
もし↓が押されたら
*else if (map[positionP + 15] == "d")*{
dのループ

*public int  Dmy3;
予約(0)
()内の数値はその区間が使用するビット数
二つ目以降はビット数とそのセクションが始まる直前のセクションを書く
*public static BitVector32.Section Mode1     = BitVector32.CreateSection(5);
*public void SetConfig(ref _Sel sel){BitVector32 bv = new BitVector32();bv[Mode1]     = sel.Mode1;bv[SelectCh]  = sel.SelectCh;bv[Function1] = sel.Function1;WriteDevice(bv.Data);}
ビットフィールドに構造体をセットする場合
*{int data = 0;ReadDevice(ref data);//インスタンスを作るときに数値を入れるとそのビットフィールドが持つ数値を設定できる．//bv.Dataのアクセサはgetだけなのでインスタンス生成時に引数として入れる必要があるBitVector32 bv = new BitVector32(data);sel.Mode1     = bv[Mode1];sel.SelectCh  = bv[SelectCh];sel.Function1 = bv[Function1];}
ビットフィールドから構造体へセットする場合
インスタンスを作るときに数値を入れるとそのビットフィールドが持つ数値を設定できる．
bv.Dataのアクセサはgetだけなのでインスタンス生成時に引数として入れる必要がある
*BitVector32 bv = new BitVector32(data);

*this[index] = new T();
初期値
*public virtual IEnumerable<;int>; GetAllIndexes() {for (int y = 1; y <;= this.YSize; y++) {for (int x = 1; x <;= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する
*public virtual IEnumerable<;int>; EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index) &amp;&amp; this[index] != null; index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む
(x,y)から右(水平)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Horizontal(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Virtical(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantR(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantL(int x, int y)

*Console.WriteLine(hhmmss);
14:50:21

対象のコレクション
*var list = Enumerable.Range(1, 10);
*var chunks = list.Select((v, i) =>; new { v, i })
N 個ずつの N
*foreach (var chunk in chunks)*{
動作確認
*foreach (var chunk in chunks)*{
動作確認
*foreach (var chunk in chunks)*{
動作確認

ボタンとパネルの組み合わせを登録
*_dic.Add(this.button1, this.panel1);
ボタンのクリックイベント登録
*AddEvent();
画面初期表示時はボタン1を選択
*SelectPanel(this.button1);
選択時
*button.BackColor = Color.DarkBlue;
選択されていない時
*button.BackColor = Color.Gray;
行の順番を変えるとデザイナ上のパネルの表示順が変わる
*this.Controls.Add(this.panel3);
例：button1をクリックしたらpanel1を表示
*_dic.Add(this.button1, this.panel1);
*{// パネル1を表示button1.BackColor = Color.DarkBlue;button1.ForeColor = Color.White;panel1.Visible = true;// パネル2を非表示button2.BackColor = Color.Gray;button2.ForeColor = Color.Black;panel2.Visible = false;// パネル3を非表示button3.BackColor = Color.Gray;button3.ForeColor = Color.Black;panel3.Visible = false;}
ボタン1をクリック
パネル1を表示
*button1.BackColor = Color.DarkBlue;
パネル2を非表示
*button2.BackColor = Color.Gray;
パネル3を非表示
*button3.BackColor = Color.Gray;

*Array.Clear(_items, 0, size);
Clear the elements so that the gc can reclaim the references.

中断の割り込みがあったときのイベントを受け取る
*Console.CancelKeyPress += Console_CancelKeyPress;
*while (running)*{
続く限り続く
動いてるアピール
*Console.WriteLine(DateTime.Now);
何か時間のかかる処理のつもり
*Thread.Sleep(5000);
中断を受け付けましたアピール
*Console.WriteLine("Ctrl+C");
もう頑張らなくていいことをメイン処理に伝える
*running = false;
今は終わらんよと伝える
*e.Cancel = true;

int型に
*var num = 1;
*var strList = new List<;string>;() { };
List&lt;string&gt;型に
処理
*}
何か重い処理
*return "async!";
含んでいるか
*arr.Any(s =>; s == "a");
*// IEnumerable<;string>; { "bb", "ccc" }
絞り込み
*// IEnumerable<;string>; { "aa", "bbbb", "cccccc" }
射影

*cameraPivot.transform.GetComponent<;Rigidbody>;().AddTorque(new Vector3(5f, 5f, 5f));*}
5,5,5!な斜め方向に。
*cameraPivot.transform.GetComponent<;Rigidbody>;().AddTorque(new Vector3(-5f, -5f, -5f));*}
-5,-5,-5!な斜め方向に。⇒右クリックで回転を止める
*//if (OVRInput.IsControllerConnected(OVRInput.Controller.RTrackedRemote))*// GetMouseButtonDownで、UnityEditor上で動作確認できます。
接続確認したいとか
*if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger) || Input.GetMouseButtonDown(0))*{
GetMouseButtonDownで、UnityEditor上で動作確認できます。
*cameraPivot.transform.GetComponent<;Rigidbody>;().AddTorque(new Vector3(5f, 5f, 5f));*}
5,5,5!な斜め方向に。
*cameraPivot.transform.GetComponent<;Rigidbody>;().AddTorque(new Vector3(-10f, -10f, -10f));*}
-10,-10,-10!な斜め方向に。⇒右クリックで回転を止める
クエリちゃん設定
*public QueryAnimationController queryAnim = null;
回転対象
*public GameObject cameraPivot = null;
【Unite Tokyo 2018】Oculusで作るスタンドアローン・モバイルVRコンテンツ
https:www.slideshare.net/UnityTechnologiesJapan002/unite-tokyo-2018oculusvr-96453609/UnityTechnologiesJapan002/unite-tokyo-2018oculusvr-96453609
上記スライドを参考にした設定
アイバッファ解像度 scale 1.0 == 1024x1024
*UnityEngine.XR.XRSettings.eyeTextureResolutionScale = 1.25f;
外枠側のレンダリング設定。&gt;&gt;HIGH　外側の解像度が減っていく
*OVRManager.tiledMultiResLevel = OVRManager.TiledMultiResLevel.LMSLow;
72Hzモード（フレームレートは上がるが綺麗）
*OVRManager.display.displayFrequency = 72.0f;
浮いてるアニメーション再生
*queryAnim.ChangeAnimation(QueryAnimationController.QueryChanAnimationType.FLY_IDLE);
*cameraPivot.transform.GetComponent<;Rigidbody>;().AddTorque(new Vector3(5f, 5f, 5f));*}
5,5,5!な斜め方向に。
*//if (OVRInput.IsControllerConnected(OVRInput.Controller.RTrackedRemote))*// GetMouseButtonDownで、UnityEditor上で動作確認できます。
接続確認したいとか
*if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger) || Input.GetMouseButtonDown(0))*{
GetMouseButtonDownで、UnityEditor上で動作確認できます。

状態
---------------------------------------------------------------------------------
*private enum STATE
更新
---------------------------------------------------------------------------------
*void Update()
ステージの生成
*case STATE.LOAD_STAGE:
プレイ中
*case STATE.PLAY:
*public bool IsGameOver { get; set; }
フラグ
*public bool IsGameOver { get; set; }
---------------------------------------------------------------------------------
プレイヤーとチェイサーの行動開始
*mConstructor.OnActivePlayer();
コルーチンを開始
*StartCoroutine("PopupFollower");
ステージの生成
*case STATE.LOAD_STAGE:
Enter入力でゲームを開始
*追加            case STATE.WAIT_ENTER_KEY:
プレイ中
*case STATE.PLAY:
入力
---------------------------------------------------------------------------------
*private bool WaitEnter()
チェイサーを除去
*mConstructor.OffActiveChaser();
コルーチン終了
*StopAllCoroutines();
フラグを立てる
*GameController.Instance.IsGameOver = true;
シーン管理
---------------------------------------------------------------------------------
*public void OnRestartButton()
ステージの生成
*case STATE.LOAD_STAGE:
Enter入力でゲームを開始
*case STATE.WAIT_ENTER_KEY:
プレイ中
*case STATE.PLAY:

*<;dd:DragDrop.DragAdornerTemplate<;
Adornerを変更するところ

*追加    private FollowCamera mFollowCameraMinimap;
MinimapCameraを指定

*private Rigidbody sphere;
バウンドさせたいオブジェクトを宣言
*private void OnCollisionEnter(Collision collision){//Y軸方向に常に同じ力を与えるsphere.AddForce(Vector3.up*10f,ForceMode.Impulse);}
sphereに触れた時のメソッド
Y軸方向に常に同じ力を与える
*sphere.AddForce(Vector3.up*10f,ForceMode.Impulse);

フィールド
*private string property1;
*{set{this.property1 = value;}get{return this.property1;}}
プロパティ
*public string Attribute1 { set; get; }
プロパティ
フィールド
*public string attribute1;
フィールド
*private string attribute1;
*{set{this.attribute1 = value;}get{return this.attribute1;}}
プロパティ

*await Task.Delay(1000).ConfigureAwait(false);
←重要

日付パースできなければNG
*DateTime inputTime;
*if (now.Subtract(inputTime).Minutes >; permitMinutes) { return false; }
現在日付 &gt; 渡された日付の場合
*if (inputTimeMax.Subtract(now).Minutes >; permitMinutes) { return false; }
現在日付 &lt; 渡された日付の場合

住人の話す内容
*public string[] scenarios;
プレイヤーが一定範囲内に入ったら会話できるサインを表すオブジェクト
*public GameObject heart;
プレイヤーが範囲内にいるかどうかの判定
*bool Aflagflag = false;
*if (other.gameObject.tag == "player") {*Aflagflag = true;
もしplayerタグをつけたゲームオブジェクトが住人のCollider判定範囲に入ったら
IventScriptのStartIventメソッドに会話が可能な状態であることを示すフラグと、住人の話す内容を送る。
*iventScript.StartIvent (Aflagflag, scenarios);
*heart.transform.position = gameObject.transform.position + new Vector3 (-0.5f, 1f, 0);*heart.SetActive (true);
住人の頭上にオブジェクトを表示(座標は自由に変えてください)
プレイヤーが範囲外に出たら会話しない。
*Aflagflag = false;
CharacterScriptから送られてきたAflagflagの格納用
*bool flag2=false;
*public void StartIvent (bool flag,string[] scenarios) {flag2 = flag;scenarios2 = scenarios;}
CharacterScriptから送られてきたscenariosの格納用
シナリオを格納
*private string[] scenarios2;
uiTextへの参照を保つ
*private Text uiText;
現在の行番号
*int currentLine;
セリフを表示するテクスト(文字の大きさや色はここにアタッチしたTextをいじって決定する)
*public Text message;
テキストウィンドウ
*public GameObject panel;
*public void StartText (string[] scenarios) {flag=1;scenarios2=scenarios;currentLine = 0;uiText = message;//パネルを表示panel.SetActive (true);//テクストを表示uiText.gameObject.SetActive (true);TextUpdate ();}
Use this for initialization
パネルを表示
*panel.SetActive (true);
テクストを表示
*uiText.gameObject.SetActive (true);
*if (currentLine <; scenarios2.Length) {*TextUpdate ();
現在の行番号がラストまで行ってない状態でボタンを押すとテキストを更新する
最後まで行ったら、テキストとテキストウィンドウを消す
*uiText.gameObject.SetActive (false);
現在の行番号をuiTextに流し込み、現在の行番号を一つ追加する
*uiText.text = scenarios2 [currentLine];

*public static string scientificName;
インスタンス化してもPersonは皆ホモサピエンスで変わらない。
*{public struct MyStruct{public static int x = 100;}}
例

*float[] weights = { 61.2f, 62.5f, 64.9f, 63.2f, 65.1f, 63.6f, 67.9f };
foreachを使って、配列の値をすべて表示する
*float[] weights = { 61.2f, 62.5f, 64.9f, 63.2f, 65.1f, 63.6f, 67.9f };
1. 配列を初期化
*//foreach (型名 変数名 in 配列名)*foreach (float w in weights)
2. foreachを回す
*foreach (float w in weights)*{
foreach (型名 変数名 in 配列名)

以下の名前空間を追加
*using System.Collections.Generic;
Dictionaryを使い日付と体重データを保持する例
1. Dictionary型の変数を作る
*Dictionary<;string, float>; weights = new Dictionary<;string, float>;();
2. Dictionaryに要素を追加
*weights.Add("2017/12/10", 62.6f);
3. 2017/12/13の体重を表示
*Console.WriteLine(weights["2017/12/13"]);

*float[] weights = { 61.2f, 62.5f, 64.9f, 63.2f, 65.1f, 63.2f, 65.1f, 63.2f, 62.7f };
1週間分の体重データから最大値を求める例
*float[] weights = { 61.2f, 62.5f, 64.9f, 63.2f, 65.1f, 63.2f, 65.1f, 63.2f, 62.7f };
1. 配列を初期化
2. 最も重い体重を記憶する変数"max"を用意
*float max = 0.0f;
*for (int i = 0; i <; weights.Length; i++)*{
3. 1週間の体重を順に参照
*if (weights[i] >; max)*{
4. maxの値が現在記録している体重よりも重ければ更新
5. 出力
*Console.WriteLine("最大値は" + max + "です");

Listを使う際には以下を宣言する
*using System.Linq;
1週間分の体重で3日目の体重データを削除してから表示する例
1. List型の変数を作る
*List<;float>; weights = new List<;float>;();
2. Listに要素を追加する
*weights.Add(61.2f);
例：weights[1] = 61.2f
3. Listの先頭から3番目を削除する
*weights.RemoveAt(2);
*for (int i = 0; i <; weights.Count; i++)*{
List&lt;T&gt;.Count -&gt; List&lt;T&gt; に格納されている要素の数を取得
weights.Add(71.2f);が消えている！
*}

Listを使う際には以下を宣言する
*using System.Linq;
Listは簡単に並び替えができる
リスト名.Sort();で並び替えができる
1週間分の体重データで軽い順にベスト3を表示する例
1. List型の変数を作る
ここでは、リスト名：weights
*List<;float>; weights = new List<;float>;();
2. Listに要素を追加する
*weights.Add(61.2f);
例：weights[1] = 61.2f
3. 小さい順に並び替える
*weights.Sort();
*for (int i = 0; i <; 3; i++)*{
4. for文で回す

*if (countOfPlayerRank == 53) { break; }
52位まで決まったらメインループを抜け出す
*foreach (var rank in playerRanking)*{
-回答を出力する

*mRigid.isKinematic = false;
物理挙動を一時的に有効にする
当たり判定
---------------------------------------------------------------------------------
*private readonly string TAG_CHASER = "Chaser";
*if (other.tag == TAG_CHASER)*{
追従中に敵と接触した場合はプレイヤーに通知
速度を再設定
*SetSpeed();

*if (countOfPlayerRank <; 52) { break; }
52位まで決まったらメインループを抜け出す
*foreach (var rank in playerRanking)*{
-回答を出力する

*this[index] = new T();
初期値
*public virtual IEnumerable<;int>; GetAllIndexes() {for (int y = 1; y <;= this.YSize; y++) {for (int x = 1; x <;= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する
*public virtual IEnumerable<;int>; EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index) &amp;&amp; this[index] != null; index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む
(x,y)から右(水平)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Horizontal(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Virtical(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantR(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantL(int x, int y)

*public class EventManager : SingletonMonoBehaviour<;EventManager>; {//初期値を２０に設定public static float ene = 20;//energyの書き込みpublic void setScore (float n){ene = n;}//energyの取得public float getScore(){return ene;}}
EventManagerをシングルトンにする
初期値を２０に設定
*public static float ene = 20;
*public void setScore (float n){ene = n;}
energyの書き込み
*public float getScore(){return ene;}
energyの取得
barのマックスの値を３００に設定
*private static float maxbarHp = 300f;
energyをこのスクリプトではHpと呼ぶことにする
*private float Hp;
EventManagerからスコアを取得
*float Hp = EventManager.Instance.getScore ();
barの中の位置を取得
*HpSlider = this.GetComponent<;Slider>;();
barの最大の長さを１としているので、長さはHp/300ということになる
*HpSlider.value = (float)Hp/ (float)maxbarHp;
EventManagerに値を返す(不要かも)
*EventManager.Instance.setScore (Hp);
*void Update () {//EventManagerからスコアを取得float Hp = EventManager.Instance.getScore ();//エネルギー自動減少(私のゲームでの設定)Hp -= Time.deltaTime;EventManager.Instance.setScore (Hp);//下の関数を実行(あとで使うのでとりあえず書いておく)UpdateHpValue ();//energyがゼロになったらゲームオーバーシーンになる(私のゲームでの設定)if (Hp <;= 0) {SceneManager.LoadScene (GameOver);}}
Update is called once per frame
EventManagerからスコアを取得
*float Hp = EventManager.Instance.getScore ();
エネルギー自動減少(私のゲームでの設定)
*Hp -= Time.deltaTime;
下の関数を実行(あとで使うのでとりあえず書いておく)
*UpdateHpValue ();
*if (Hp <;= 0) {*SceneManager.LoadScene (GameOver);
energyがゼロになったらゲームオーバーシーンになる(私のゲームでの設定)
*public void UpdateHpValue(){var Hp = EventManager.Instance.getScore ();HpSlider.value = (float)Hp / (float)maxbarHp;,,,public GameObject edgepoint;//５ｐ泡を取った時public void EneUp5(){//EventManagerからスコアを取得、５点追加var Hp = EventManager.Instance.getScore ();Hp += 5f;//大事！！！//パッと表示させたいImageを、edgepointの子としてInstantiateImage bubbleP5 = Instantiate(plus5, Vector3.zero, Quaternion.identity) as Image;bubbleP5.transform.SetParent (edgepoint.transform, false);//１．５秒後にDestroy。同時にtextも消去Text txt5 =bubbleP5.GetComponentInChildren<;Text>;();Destroy (bubbleP5, 1.5f);Destroy (txt5, 1.5f);bubbleP5 = null;txt5 = null;//energyをEventManagerに返すEventManager.Instance.setScore (Hp);}//Hp表示用アップデートpublic void UpdateHpValue(){var Hp = EventManager.Instance.getScore ();HpSlider.value = (float)Hp / (float)maxbarHp;Text energycount = this.GetComponentInChildren<;Text>; ();energycount.text= Hp.ToString("f0");,,,using UnityEngine;using System.Collections;using UnityEngine.UI;public class BubbleScript : MonoBehaviour {private GameObject energybar;private HpController hpController;// Use this for initializationvoid Start () {//barを見つけるGameObject energybar = GameObject.Find ("EnergyBar");//barに付けるスクリプトHpControllerを見つけるhpController = energybar.GetComponentInChildren<;HpController>;();}//Playerにぶつかったときの反応void OnTriggerEnter (Collider col){if (col.tag == "Player") {//HpControllerに"Eneup"を実行するように指示hpController.SendMessage ("EneUp5");//HpControllerに"UpdateHpValue"を実行するように指示hpController.SendMessage("UpdateHpValue");//ぶつかった泡(このスクリプトがついているgameobject)をDestroyするDestroy(this.gameObject);}}},,,*public void EneUp5(){//EventManagerからスコアを取得、５点追加var Hp = EventManager.Instance.getScore ();Hp += 5f;//大事！！！//パッと表示させたいImageを、edgepointの子としてInstantiateImage bubbleP5 = Instantiate(plus5, Vector3.zero, Quaternion.identity) as Image;bubbleP5.transform.SetParent (edgepoint.transform, false);//１．５秒後にDestroy。同時にtextも消去Text txt5 =bubbleP5.GetComponentInChildren<;Text>;();Destroy (bubbleP5, 1.5f);Destroy (txt5, 1.5f);bubbleP5 = null;txt5 = null;//energyをEventManagerに返すEventManager.Instance.setScore (Hp);}//Hp表示用アップデートpublic void UpdateHpValue(){var Hp = EventManager.Instance.getScore ();HpSlider.value = (float)Hp / (float)maxbarHp;Text energycount = this.GetComponentInChildren<;Text>; ();energycount.text= Hp.ToString("f0");,,,using UnityEngine;using System.Collections;using UnityEngine.UI;public class BubbleScript : MonoBehaviour {private GameObject energybar;private HpController hpController;// Use this for initializationvoid Start () {//barを見つけるGameObject energybar = GameObject.Find ("EnergyBar");//barに付けるスクリプトHpControllerを見つけるhpController = energybar.GetComponentInChildren<;HpController>;();}//Playerにぶつかったときの反応void OnTriggerEnter (Collider col){if (col.tag == "Player") {//HpControllerに"Eneup"を実行するように指示hpController.SendMessage ("EneUp5");//HpControllerに"UpdateHpValue"を実行するように指示hpController.SendMessage("UpdateHpValue");//ぶつかった泡(このスクリプトがついているgameobject)をDestroyするDestroy(this.gameObject);}}},,,EventManagerからスコアを取得、５点追加
*var Hp = EventManager.Instance.getScore ();
大事！！！
パッと表示させたいImageを、edgepointの子としてInstantiate
*Image bubbleP5 = Instantiate(plus5, Vector3.zero, Quaternion.identity) as Image;
１．５秒後にDestroy。同時にtextも消去
*Text txt5 =bubbleP5.GetComponentInChildren<;Text>;();
energyをEventManagerに返す
*EventManager.Instance.setScore (Hp);
*public void UpdateHpValue(){var Hp = EventManager.Instance.getScore ();HpSlider.value = (float)Hp / (float)maxbarHp;Text energycount = this.GetComponentInChildren<;Text>; ();energycount.text= Hp.ToString("f0");,,,using UnityEngine;using System.Collections;using UnityEngine.UI;public class BubbleScript : MonoBehaviour {private GameObject energybar;private HpController hpController;// Use this for initializationvoid Start () {//barを見つけるGameObject energybar = GameObject.Find ("EnergyBar");//barに付けるスクリプトHpControllerを見つけるhpController = energybar.GetComponentInChildren<;HpController>;();}//Playerにぶつかったときの反応void OnTriggerEnter (Collider col){if (col.tag == "Player") {//HpControllerに"Eneup"を実行するように指示hpController.SendMessage ("EneUp5");//HpControllerに"UpdateHpValue"を実行するように指示hpController.SendMessage("UpdateHpValue");//ぶつかった泡(このスクリプトがついているgameobject)をDestroyするDestroy(this.gameObject);}}},,,*void Start () {//barを見つけるGameObject energybar = GameObject.Find ("EnergyBar");//barに付けるスクリプトHpControllerを見つけるhpController = energybar.GetComponentInChildren<;HpController>;();}//Playerにぶつかったときの反応void OnTriggerEnter (Collider col){if (col.tag == "Player") {//HpControllerに"Eneup"を実行するように指示hpController.SendMessage ("EneUp5");//HpControllerに"UpdateHpValue"を実行するように指示hpController.SendMessage("UpdateHpValue");//ぶつかった泡(このスクリプトがついているgameobject)をDestroyするDestroy(this.gameObject);}}},,,barを見つける
*GameObject energybar = GameObject.Find ("EnergyBar");
barに付けるスクリプトHpControllerを見つける
*hpController = energybar.GetComponentInChildren<;HpController>;();
*void OnTriggerEnter (Collider col){if (col.tag == "Player") {//HpControllerに"Eneup"を実行するように指示hpController.SendMessage ("EneUp5");//HpControllerに"UpdateHpValue"を実行するように指示hpController.SendMessage("UpdateHpValue");//ぶつかった泡(このスクリプトがついているgameobject)をDestroyするDestroy(this.gameObject);}}},,,HpControllerに"Eneup"を実行するように指示
*hpController.SendMessage ("EneUp5");
HpControllerに"UpdateHpValue"を実行するように指示
*hpController.SendMessage("UpdateHpValue");
ぶつかった泡(このスクリプトがついているgameobject)をDestroyする
*Destroy(this.gameObject);

*var option = new ExpandPropertyOptions(){MaxReferenceLevel=2};
2階層目までOK

*public class move : MonoBehaviour {GameObject player;//  動かしたいプレイヤーbool right = false;//  右ボタンを押しているかの真偽値bool left = false;//  左ボタンを押しているかの真偽値// Use this for initializationvoid Start () {}// Update is called once per framevoid Update () {if (right) {goright ();//          右に動かすためのメソッドを呼び出す}else if (left) {goleft ();//          左に動かすためのメソッドを呼び出す} else {//          ボタンを押していない時transform.rotation = Quaternion.Euler (0, 0, 0);//          プレイヤーを元の角度に戻す}}public void rPushDown(){//      右ボタンを押している間right = true;}public void rPushUp(){//      右ボタンを押すのをやめた時right = false;}public void lPushDown(){//      左ボタンを押している間left = true;}public void lPushUp(){//      左ボタンを押すのをやめた時left = false;}public void goright(){if (transform.position.x <;= 5.0f) {//          プレイヤーの位置が5.0f以下の時//          ↑画面からはみ出さないための条件transform.position += new Vector3 (5.0f * Time.deltaTime, 0, 0);//          プレイヤーをx軸方向に秒速5.0fで動かすtransform.rotation = Quaternion.Euler (0, -20, -10);//          プレイヤーの角度をy軸周りに-20度、z軸周りに-10度回転させる//          ↑プレイヤーがグッと肩を入れて移動してる感を出す、この一文は無くても問題なし}}public void goleft(){if (transform.position.x >;= -5.0f) {//          プレイヤーの位置が-5.0f以上の時//          ↑画面からはみ出さないための条件transform.position += new Vector3 (-5.0f * Time.deltaTime, 0, 0);//          プレイヤーをx軸方向に秒速-5.0fで動かすtransform.rotation = Quaternion.Euler (0, 20, 10);//          プレイヤーの角度をy軸周りに20度、z軸周りに10度回転させる//          ↑プレイヤーがグッと肩を入れて移動してる感を出す、この一文は無くても問題なし}}}
UIを使うときのおまじない、忘れずに書く
動かしたいプレイヤー
*bool right = false;
右ボタンを押しているかの真偽値
*bool left = false;
*// Use this for initialization*void Start () {
左ボタンを押しているかの真偽値
*void Start () {}
Use this for initialization
*void Update () {if (right) {goright ();//          右に動かすためのメソッドを呼び出す}else if (left) {goleft ();//          左に動かすためのメソッドを呼び出す} else {//          ボタンを押していない時transform.rotation = Quaternion.Euler (0, 0, 0);//          プレイヤーを元の角度に戻す}}
Update is called once per frame
*}else if (left) {*goleft ();
右に動かすためのメソッドを呼び出す
*} else {
左に動かすためのメソッドを呼び出す
*transform.rotation = Quaternion.Euler (0, 0, 0);*//          プレイヤーを元の角度に戻す
ボタンを押していない時
プレイヤーを元の角度に戻す
*}
右ボタンを押している間
*right = true;
右ボタンを押すのをやめた時
*right = false;
左ボタンを押している間
*left = true;
左ボタンを押すのをやめた時
*left = false;
プレイヤーの位置が5.0f以下の時
↑画面からはみ出さないための条件
*transform.position += new Vector3 (5.0f * Time.deltaTime, 0, 0);
*transform.rotation = Quaternion.Euler (0, -20, -10);*//          プレイヤーの角度をy軸周りに-20度、z軸周りに-10度回転させる
プレイヤーをx軸方向に秒速5.0fで動かす
プレイヤーの角度をy軸周りに-20度、z軸周りに-10度回転させる
↑プレイヤーがグッと肩を入れて移動してる感を出す、この一文は無くても問題なし
*}
プレイヤーの位置が-5.0f以上の時
↑画面からはみ出さないための条件
*transform.position += new Vector3 (-5.0f * Time.deltaTime, 0, 0);
*transform.rotation = Quaternion.Euler (0, 20, 10);*//          プレイヤーの角度をy軸周りに20度、z軸周りに10度回転させる
プレイヤーをx軸方向に秒速-5.0fで動かす
プレイヤーの角度をy軸周りに20度、z軸周りに10度回転させる
↑プレイヤーがグッと肩を入れて移動してる感を出す、この一文は無くても問題なし
*}

データファイルのロード
*pipeline.Add(new TextLoader<;WineQualityData>;(trainDataPath, useHeader: true, separator: ";"));
予測列の定義
予測したい列を "Label" という名前で作成
タプルとして定義している点に注意
*pipeline.Add(new ColumnCopier((nameof(WineQualityData.Quality), "Label")));
学習に用いるデータの定義
"Features" という名前で、各列を一つにまとめる
*pipeline.Add(new ColumnConcatenator("Features",
アルゴリズムの定義
*pipeline.Add(new FastTreeRegressor());
学習を実施しモデルを作成
*var model = pipeline.Train<;WineQualityData, WineQualityPrediction>;();
評価用データのロード
*var testData = new TextLoader<;WineQualityData>;(testDataPath, useHeader: true, separator: ";");
評価用のクラスの生成
*var evaluator = new RegressionEvaluator();
評価の実行
*var metrics = evaluator.Evaluate(model, testData);
*Console.WriteLine($"Rms={metrics.Rms}");
評価指標の出力
データの分割
*var data = SplitData(@".\Data\winequality-red.csv", 7);
学習
*var model = Train(data.trainDataPath);
評価
*Evalute(model, data.testDataPath);

*private float mSpeed;
現在の速度
*if (mIsExcited)*{
活性・非活性の切り替え
*if (!SearchAround(1.5f)) mIsExcited = false;*}
プレイヤーが索敵できなくなった場合は非活性状態へ遷移
*if (SearchAround(1.0f))*{
範囲内にプレイヤーが存在し、視認できる状態ならば活性状態へ遷移
目的地を設定
---------------
*GameObject player = GameController.Instance.StageManager.GetPlayer();
*mAgent.SetDestination(player.transform.position);*}
活性状態の場合はプレイヤーを追従
非活性状態の場合はプレイヤー進行方向へ先回り
*Vector3? temp = player.GetComponent<;PlayerRaycastPoint>;().GetDestinationPoint();
リストをシャッフルすれば巡回するポイントの順番をランダムに決定可能
*mPatrolPosList = GameController.Instance.StageManager.GetPatrolPosList();
*if (mIsExcited)*{
活性・非活性の切り替え
*if (!SearchAround(2.0f)) mIsExcited = false;*}
プレイヤーが索敵できなくなった場合は非活性状態へ遷移
*if (SearchAround(1.0f))*{
範囲内にプレイヤーが存在し、視認できる状態ならば活性状態へ遷移
目的地を設定
---------------
*GameObject player = GameController.Instance.StageManager.GetPlayer();
*mAgent.SetDestination(player.transform.position);*}
活性状態の場合はプレイヤーを追従
*if (mPatrolIndex <; 0)*{
非活性状態の場合はポップアップポイントを巡回
初回は目標地点がないためプレイヤー座標を仮に設定する
*mPatrolIndex = 0;
新しい目標が決定した直後は3.0f離れるまで到達判定を行わない
これをしないと前回の目標地点が到達判定で使用されて次の目標地点が飛ばされる場合がある
*if (mAgent.remainingDistance >;= 3.0f) newTarget = false;
*if (mAgent.remainingDistance <;= 0.1f)*{
目標としているポイントに接近した場合は次のポイントを新しい目標地点に設定する

*using NCMB;
忘れないように
パスとファイル名
*string path;
セーブデータ
*List<;NCMBObject>; saveDataList;
テスト用に値書き換え,バックアップされる
*player.PlayerName = "アズマ1";
セーブ
*SavePlayer();
テスト用に値書き換え,バックアップされてない
*player.PlayerName = "アズマ2";
バックアップのロード、savedata.jsonに上書き
*loadSaveData();
savedata.jsonからロード
*player = SaveData.GetClass<;Player>;("Player", new Player());
値変更確認,バックアップされた「アズマ1」が出力されれば成功
*Debug.Log("player.PlayerName = " + player.PlayerName);
*void SavePlayer(){SaveData.SetClass<;Player>;("Player", player);SaveData.Save();}
JsonUtilityでセーブ
*if (File.Exists(path + fileName))*{
JSONファイルを読んでstringへ
ファイル名重複を避けるためファイル名を日付＋乱数で生成
*string NCMBFileName = Application.companyName + "." + Application.productName + ".savedata" + "-" + DateTime.Now.Year+DateTime.Now.Month+DateTime.Now.Day+DateTime.Now.Hour+DateTime.Now.Minute+DateTime.Now.Second;
失敗
Debug.Log("UploadPlayer : 失敗"); 追記
*}
成功
Debug.Log("UploadPlayer : 成功"); 追記
*}
バックアップレコードを追加
*AddRecord(NCMBFileName);
*{NCMBObject obj = new NCMBObject("SaveData");obj.Add("username", PlayerPrefs.GetString(userNameKey, ""));obj.Add("savedatafile", filename);obj.Add("date", DateTime.Now.Date);obj.Save((NCMBException e) =>; {if (e != null){Debug.Log("save data error");showError(e);}else{//成功時の処理Debug.Log("UpdateSaveData : 成功");}});}
バックアップの更新
成功時の処理
*Debug.Log("UpdateSaveData : 成功");
*{saveDataList = new List<;NCMBObject>;();//QueryTestを検索するクラスを作成NCMBQuery<;NCMBObject>; query = new NCMBQuery<;NCMBObject>;("SaveData");//ユーザー名で抽出query.WhereEqualTo("username", PlayerPrefs.GetString(userNameKey, ""));//ソートkeyを設定query.OrderByDescending("createDate");//検索結果を取得query.FindAsync((List<;NCMBObject>; objList, NCMBException e) =>; {if (e != null){//検索失敗時の処理Debug.Log("loadSaveData : 失敗");}else{Debug.Log("loadSaveData : 成功");//最新のファイルを読み込むDebug.Log(objList[0]["username"] + " " + objList[0]["savedatafile"]);LoadSaveFile(objList[0]["savedatafile"].ToString());}});}
ファイル名を取得, ファイルを取得, 読み込む
QueryTestを検索するクラスを作成
*NCMBQuery<;NCMBObject>; query = new NCMBQuery<;NCMBObject>;("SaveData");
ユーザー名で抽出
*query.WhereEqualTo("username", PlayerPrefs.GetString(userNameKey, ""));
ソートkeyを設定
*query.OrderByDescending("createDate");
*query.FindAsync((List<;NCMBObject>; objList, NCMBException e) =>; {if (e != null){//検索失敗時の処理Debug.Log("loadSaveData : 失敗");}else{Debug.Log("loadSaveData : 成功");//最新のファイルを読み込むDebug.Log(objList[0]["username"] + " " + objList[0]["savedatafile"]);LoadSaveFile(objList[0]["savedatafile"].ToString());}});
検索結果を取得
検索失敗時の処理
*Debug.Log("loadSaveData : 失敗");
最新のファイルを読み込む
*Debug.Log(objList[0]["username"] + " " + objList[0]["savedatafile"]);
*{NCMBFile file = new NCMBFile(Name);file.FetchAsync((byte[] fileData, NCMBException error) =>; {if (error != null){// 失敗Debug.Log("LoadSaveFile : 失敗");}else{//成功Debug.Log("LoadSaveFile : 成功");SaveBytesTo(fileData);}});}
SaveDataファイルを取得
失敗
*Debug.Log("LoadSaveFile : 失敗");
成功
*Debug.Log("LoadSaveFile : 成功");
*{Debug.Log("SaveBytesTo");//UTF8 エンコードでbyteからstringへstring text = System.Text.Encoding.UTF8.GetString(b);//上書きStreamWriter writer = new StreamWriter(path + fileName, false, Encoding.GetEncoding("utf-8"));writer.WriteLine(text);writer.Close();}
Byteデータをsavedata.jsonに書き込む
UTF8 エンコードでbyteからstringへ
*string text = System.Text.Encoding.UTF8.GetString(b);
上書き
*StreamWriter writer = new StreamWriter(path + fileName, false, Encoding.GetEncoding("utf-8"));
テスト用ClassをまとめたScript
class構成が大きな影響を与えることはないと思われるので、任意に書き換えてOK
*using System.Collections.Generic;
*{Name = name;Id = id;}
コンストラクタ
※Skillクラスは各skillに継承される
*[System.Serializable]
*{Name = name;Id = id;}
コンストラクタ
*{Name = name;Id = id;}
継承クラスのコンストラクタはこう書く
*{Name = name;Id = id;}
継承クラスのコンストラクタはこう書く
*{Name = name;Id = id;}
継承クラスのコンストラクタはこう書く

*foreach (int element in trialPatternArray)*{
コンソールに出力

*private void AsyncSample(string argText)
引数は最低一つ必要なだけなので値はなんでもよい
実際にはここに時間のかかる処理が入る。今回はwaitで代用
*Thread.Sleep(3000);
*{sw.Write("処理が完了しました");sw.Close();}
ローカルファイルに書き込む
*{TempData["message"] = sr.ReadLine();sr.Close();}
ローカルファイルを見に行く
↓は今回使ってないけどこいうやり方もあるので勉強して別途記事を書きたい ----
*[HttpGet]

使い方
宣言
TcpServer.ClassTcpServer classTcpServer = new TcpServer.ClassTcpServer();
初期化、スタート
classTcpServer.ipaddress = "0.0.0.0";
classTcpServer.port = 49152;
classTcpServer.timerinterval = 100;
classTcpServer.DataReceived += new TcpServer.ClassTcpServer.DataReceivedEventHandler(TcpServer_DataReceived);
classTcpServer.Start();
停止
classTcpServer.Stop();
イベントハンドラ
private void TcpServer_DataReceived(object sender, TcpServer.DataReceivedEventArgs e)
{
イベントが発生したとき
textBox1.AppendText(e.Message + Environment.NewLine);
}
*public class DataReceivedEventArgs : EventArgs
TcpListenerオブジェクトを作成する
*listener = new System.Net.Sockets.TcpListener(System.Net.IPAddress.Parse(ipaddress), port);
Listenを開始する
*listener.Start();
タイマスタート
*timer.Interval = timerinterval;
タイマストップ
*timer.Stop();
リスナを閉じる
*listener.Stop();
*if (!listener.Pending())*{
接続要求が無かったら return
接続要求があったら受け入れる
*System.Net.Sockets.TcpClient client = listener.AcceptTcpClient();
NetworkStreamを取得
*System.Net.Sockets.NetworkStream ns = client.GetStream();
読み取り、書き込みのタイムアウト
デフォルトはInfiniteで、タイムアウトしない
(.NET Framework 2.0以上が必要)
*ns.ReadTimeout = 10000;
クライアントから送られたデータを受信する
*System.Text.Encoding enc = System.Text.Encoding.UTF8;
データの一部を受信する
*resSize = ns.Read(resBytes, 0, resBytes.Length);
*if (resSize == 0)*{
Readが0を返した時はクライアントが切断したと判断
受信したデータを蓄積する
*ms.Write(resBytes, 0, resSize);
まだ読み取れるデータがあるか、データの最後が\nでない時は、
受信を続ける
*} while (ns.DataAvailable || resBytes[resSize - 1] != '\n');
受信したデータを文字列に変換
*string resMsg = enc.GetString(ms.GetBuffer(), 0, (int)ms.Length);
末尾の\nを削除
*resMsg = resMsg.TrimEnd('\n');
イベント発生して呼び出し元にデータを返す
*DataReceivedEventArgs ee = new DataReceivedEventArgs();
クライアントにデータを送信する
クライアントに送信する文字列を作成
*string sendMsg = resMsg.Length.ToString();
文字列をByte型配列に変換
*byte[] sendBytes = enc.GetBytes(sendMsg + '\n');
データを送信する
*ns.Write(sendBytes, 0, sendBytes.Length);
閉じる
*ns.Close();

*private readonly float THICKNES_HALF = 0.05f;
四方を囲む壁の厚さの半分

アプリ起動時に呼ばれるメソッド (オートログイン)
---------------------------------------------------------------------------------------------
*IEnumerator Start()
Unity(端末)に保存された `ユーザ名` と `パスワード` を取得 (保存されていない場合は空文字で初期化)
*string userName = PlayerPrefs.GetString(userNameKey, "");
*if (userName == "")*{
Unityにユーザ情報が保存されているか
保存なし -&gt; ユーザ登録処理
*Debug.Log("No User Info on Unity");
*if (NCMBUser.CurrentUser == null)*{
保存あり -&gt; 現在ログインしているか
ログインしていない -&gt; ログイン処理
*yield return StartCoroutine(loginCoroutine(userName, password));
任意文字数のランダム文字列を生成するメソッド
---------------------------------------------------------------------------------------------
*const string letters = "abcdefghijklmnopqrstuvwxyz1234567890";
会員登録を行うメソッド
---------------------------------------------------------------------------------------------
*private IEnumerator userRegistrationCoroutine()
NCMBUserクラスのインスタンス生成
*NCMBUser user = new NCMBUser();
パスワード
*string password = genRandomString(16);
UserIDが重複したらやり直し
*bool isSuccess = false;
*user.SignUpAsync((NCMBException e) =>; {if (e != null){// ユーザ登録失敗if (e.ErrorCode != NCMBException.DUPPLICATION_ERROR){// ユーザ名重複以外のエラーが発生Debug.Log("Failed to registerate: " + e.ErrorMessage);}}else{// ユーザ登録成功isSuccess = true;Debug.Log("Succeeded to registrate");// Unity(端末)に情報を設定PlayerPrefs.SetString(userNameKey, user.UserName);PlayerPrefs.SetString(passwordKey, password);}// ユーザ登録処理（１ループ）終了isConnecting = false;});
ランダム文字列でユーザ名を設定してユーザ登録実行（非同期処理）
*if (e.ErrorCode != NCMBException.DUPPLICATION_ERROR)*{
ユーザ登録失敗
ユーザ名重複以外のエラーが発生
*Debug.Log("Failed to registerate: " + e.ErrorMessage);
ユーザ登録成功
*isSuccess = true;
Unity(端末)に情報を設定
*PlayerPrefs.SetString(userNameKey, user.UserName);
ユーザ登録処理（１ループ）終了
*isConnecting = false;
*yield return new WaitWhile(() =>; { return isConnecting; });
ユーザ登録処理（１ループ）が終了するまで以下の行でストップ（強制的に同期処理にする）
ログインを行うメソッド
---------------------------------------------------------------------------------------------
*private IEnumerator loginCoroutine(string userName, string password)
ログイン失敗
*Debug.Log("Failed to login: " + e.ErrorMessage);
ログイン成功
*Debug.Log("Succeeded to login");
ログイン処理終了
*isConnecting = false;
*yield return new WaitWhile(() =>; { return isConnecting; });
ログイン処理が終了するまで以下の行でストップ

*private const string baseUrl = "http:
weather.livedoor.comforecastwebservicejsonv1";
*{public Pinpointlocation[] pinpointLocations { get; set; }public string link { get; set; }public Forecast[] forecasts { get; set; }public Location location { get; set; }public DateTime publicTime { get; set; }public Copyright copyright { get; set; }public string title { get; set; }public Description description { get; set; }}
ここから下は受け取るJsonのデータ型を定義しているよ -----------------------

-文字列を受け取る
*string S = Console.ReadLine();
-文字列の中から連続したb,wの数をカウントして、List&lt;int&gt; resultに格納する
*int currentSIndex = 0;
-List&lt;int&gt; result内の要素を半角スペース区切りで出力する
*int count = 0;

*static int GetSumOfRowNumber(List<;List<;int<;<; OriginMagicSquare ,int row)
引数2に指定した行riの合計値(ri_c0+ri_c1+ri_c2...ri_cN)を返すメソッド

*if (Message.activeSelf) {*speed = 0;
move
スティックの倒れた向きを向く---------------------------------
float v2 = leftController.GetTouchPosition.y; y軸方向の値をとる
float h2 = leftController.GetTouchPosition.x; x軸方向の値をとる
*Debug.Log (v2 + ", "+h2);
ジョイスティックが傾いている方向を向く
*Vector3 direction = new Vector3(h2,0,v2);
*if (speed == 0f) {*Debug.Log (speed);
WalkingFlag

*mAgent.velocity = Vector3.zero;
減速ではなくピタっと止める
当たり判定
---------------------------------------------------------------------------------
*private readonly string TAG_POPUP_POINT = "PopupPoint";
*if (other.tag == TAG_POPUP_POINT) TakeFollower(other.GetComponent<;PopupPoint>;());*}
ポップアップポイントに接触した
フォロワーの追従
---------------------------------------------------------------------------------
*private List<;FollowerModel>; mFollowerList = new List<;FollowerModel>;();
*Transform target = mTrans;*int followerCount = mFollowerList.Count;
フォロワーに追従させる対象を決定する（すでにフォロワーが追従している場合は一番後ろのフォロワーを対象にする）
フォロワーの追従開始
*FollowerModel follower = popup.DeleverFollower();
フォロワーをリストに追加し、プレイヤーとフォロワーの移動速度を再設定
*mFollowerList.Add(follower);

*DoHeavyTask();
← 10秒かかる重い処理
*Console.WriteLine("after DoSomethingAsync: {0:N0}ms", stopwatch.ElapsedMilliseconds);
ここではバックグラウンド？で DoSomethingAsync を開始だけしたつもり（非同期のつもり）
*Console.WriteLine("after await: {0:N0}ms", stopwatch.ElapsedMilliseconds);
ここで await することで完了を待っているつもり

*URL = string.Format("https:
docs.google.comformsde1FAIpQLSdjLLjO0OEYT44hJlxUBFRm2wz2GTqpatku7sJb-aBv8eOcxgviewform?usp=pp_url&amp;entry.1543890908={0}&amp;entry.966225331={1}&amp;entry.451690904={2}&amp;entry.465137427={3}",

*private int mFollowerCount;
アクティブ状態のフォロワー数

*book.Worksheet( sheetName ).Delete();
削除
シート「新規追加したいシート名」を新規追加
*book.AddWorksheet( sheetName, 1 );
保存
*book.Save();

*case XLDataType.Text:
文字列

*private Vector3 mDistance;
ターゲットとの距離
カメラの追従設定
---------------------------------------------------------------------------------
*[SerializeField]

*mAnimator.SetLayerWeight(1, 1);
レイヤーウェイト = そのレイヤーのアニメーションをどの程度反映させるかどうか0.0f~1.0f
*//override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {////}
OnStateEnter is called when a transition starts and the state machine starts to evaluate this state
*//override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {////}
}
*//override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {////}
OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks
*{PlayerAnimation pa = animator.gameObject.GetComponent<;PlayerAnimation>;();if (pa.AnimId == PlayerAnimation.ANIM_ID.IDLE) pa.OnCallChangeFace(PlayerAnimation.DEFAULT_FACE);}
OnStateExit is called when a transition ends and the state machine finishes evaluating this state
*//override public void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {////}
OnStateMove is called right after Animator.OnAnimatorMove(). Code that processes and affects root motion should be implemented here
*//override public void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {////}
}
*//override public void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {////}
OnStateIK is called right after Animator.OnAnimatorIK(). Code that sets up animation IK (inverse kinematics) should be implemented here.

*Debug.Log("foo は null ");
NG

*byte[] vals = { 0x0d};
, 0x0a

*string path2;
out file name

*if (JapaneseKana.IsMatch(text))*{
ほんとはここでひらがなカタカナだけじゃなくて、日本語にしか使われてない漢字も含めたほうが精度あがる
たまに繁体字・簡体字両方含んでるやつがあるので、そのときは多い方にする
*var scount = 0;
ここに来た時点ではまだ日本語・繁体字・簡体字どれも可能性あるんだけど、
どれにも含まれる漢字しか使われてないので、日本語フォントでも問題なく表示される。
*if (Kanji.IsMatch(text))
*static Regex SimplifiedChinese = new Regex(@"\u343D|\u3447|\u3448...{省略}...\u2B6F6|\u2B6F8|\u2C88D");*static Regex TraditionalChinese = new Regex(@"\u346F|\u3473|\u3493...{省略}...\u2A535|\u2A600|\u2A62F");
↓Pythonスクリプトで生成したやつをコピペ

*this[index] = new T();
初期値
*public virtual IEnumerable<;int>; GetAllIndexes() {for (int y = 1; y <;= this.YSize; y++) {for (int x = 1; x <;= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する
*public virtual IEnumerable<;int>; EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index) &amp;&amp; this[index] != null; index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む
(x,y)から右(水平)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Horizontal(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; Virtical(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantR(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む
*public virtual IEnumerable<;int>; SlantL(int x, int y)

*if (buf.CompareTo("FXSHRXW") >;= 1)*throw new ArgumentOutOfRangeException("Argument range max \"FXSHRXW\"");
変換後がint.MaxValueに収まるか?

*{new Person { Name = "明石家さんま", Age = 63, Gender = Gender.Male, BirthPlace = "東京都"},new Person { Name = "阿部寛", Age = 54, Gender = Gender.Male, BirthPlace = "神奈川県"},new Person { Name = "マツコ・デラックス", Age = 46, Gender = Gender.Male, BirthPlace = "千葉県"},new Person { Name = "内村光良", Age = 54, Gender = Gender.Male, BirthPlace = "熊本県"},new Person { Name = "新垣結衣", Age = 30, Gender = Gender.Female, BirthPlace = "神奈川県"},new Person { Name = "浅田真央", Age = 28, Gender = Gender.Female, BirthPlace = "東京都"},new Person { Name = "綾瀬はるか", Age = 33, Gender = Gender.Female, BirthPlace = "熊本県"}};
芸能人好感度ランキングから名前を借りました。出身地や年齢は加工しています。
明石家さんま 63才 男 東京都出身
*,,,
明石家さんま 63才 男 東京都出身
阿部寛 54才 男 神奈川県出身
マツコ・デラックス 46才 男 千葉県出身
内村光良 54才 男 熊本県出身
*,,,
新垣結衣 30才 女 神奈川県出身
*,,,
浅田真央 28才 女 東京都出身
新垣結衣 30才 女 神奈川県出身
綾瀬はるか 33才 女 熊本県出身
マツコ・デラックス 46才 男 千葉県出身
阿部寛 54才 男 神奈川県出身
内村光良 54才 男 熊本県出身
明石家さんま 63才 男 東京都出身
*,,,
明石家さんま 63才 男 東京都出身
阿部寛 54才 男 神奈川県出身
内村光良 54才 男 熊本県出身
マツコ・デラックス 46才 男 千葉県出身
綾瀬はるか 33才 女 熊本県出身
新垣結衣 30才 女 神奈川県出身
浅田真央 28才 女 東京都出身
*,,,
熊本県
内村光良 54才 男 熊本県出身
綾瀬はるか 33才 女 熊本県出身
神奈川県
阿部寛 54才 男 神奈川県出身
新垣結衣 30才 女 神奈川県出身
千葉県
マツコ・デラックス 46才 男 千葉県出身
東京都
明石家さんま 63才 男 東京都出身
浅田真央 28才 女 東京都出身
*,,,
東京都
神奈川県
千葉県
熊本県
*,,,
最小値:28
*var max = people.Max(p =>; p.Age);
最大値:63
*var average = people.Average(p =>; p.Age);
平均値:44
*var sum = people.Sum(p =>; p.Age);

ImmutableなListは、項目が追加された別のインスタンスを生成する
*var addedList = list.Add(11);
MutableなListは、自身の中身を書き換える
*list.Add(11);
大量の変更が必要な場合、Builderに。
*var builder = originalList.ToBuilder();
変更後、ToImmutable()で、Immutableに。
*var newList = builder.ToImmutable();
大量の変更が必要な場合、Builderに。
*var builder = new StringBuilder(originalString);
Immutableに。
*var newStr = builder.ToString();

接続文字列を生成
*string connectString =
SqlConnection の新しいインスタンスを生成 (接続文字列を指定)
*this.sqlConnection = new SqlConnection(connectString);
データベース接続を開く
*this.sqlConnection.Open();
クエリー送信先、トランザクションの指定
*sqlCom.Connection = this.sqlConnection;
SQLを実行
*SqlDataReader reader = sqlCom.ExecuteReader();
クエリー送信先、トランザクションの指定
*sqlCom.Connection = this.sqlConnection;
SQLを実行
*sqlCom.ExecuteNonQuery();
データベース接続情報
*private const string DATABASE_SERVER = "hogehoge";
データベース接続情報
*private const string DATABASE_SERVER = "hogehoge";

*Console.WriteLine(message.Value);
"Hello"と出力
*{public string Name { get; set; }public int Age { get; set; }}
ViewModelで使いたいModelクラス
*{private Person _person;public int Age{get =>; _person.Age;set =>; SetProperty(_person.Age, value, (model, newval) =>; model.Age = newval);}public string Name{get =>; _person.Name;set =>; SetProperty(_person.Name, value, (model, newval) =>; model.Name = newval);//SetProperty(古値, 新値, 更新(古値!=新値)時に実行するcallback);}}
ViewModelでラップしてPropertyChangedに反応させる
SetProperty(古値, 新値, 更新(古値!=新値)時に実行するcallback);
*}

*true
読み込むStreamを破棄しないかどうか
リクエストBodyを読み込む
*var body = reader.ReadToEnd();
読み込み開始位置を先頭にする(どっちの方法でやっても大丈夫)
*reader.BaseStream.Position = 0;
リクエストBodyを複数回読み込めるようにする
*context.Request.EnableRewind();
*{// リクエストBody読み込みvar body = await reader.ReadToEndAsync();// リクエストBodyの読み込み位置を先頭にするreader.BaseStream.Position = 0;}
リクエストBodyのStreamを破棄しないようにする
リクエストBody読み込み
*var body = await reader.ReadToEndAsync();
リクエストBodyの読み込み位置を先頭にする
*reader.BaseStream.Position = 0;
リクエストBody再読み込み
*var body = await reader.ReadToEndAsync();

各ColumnHeaderのSortDirectionをクリアする
*this.EmployeesDataGrid.Columns.ToList().ForEach(c =>; c.SortDirection = null);
DataGridのDataContextを再設定する
*this.EmployeesDataGrid.DataContext = null;

*public string ProjectName { get; set; }
ここに"projects"の最初の要素の"name"を割り当てたい
JsonPropertyでDeserializeしたいメンバーを持つJsonObject名を指定
JsonConverterの宣言でObjectMemberPickerの型と指定したいPathをパラメーターで渡す
(このパラメーターがObjectMemberPickerのコンストラクタへ引数として渡される)
*[JsonProperty("company")]
一つのJsonPropertyは一つのPropertyにしか割り当てられないようなので、
今のところDepartmentNameにDeserializeするならComopanyNameは諦めるしかない
Deserialize自体は下記のPath指定でできた。
[JsonProperty("company")]
[JsonConverter(typeof(ObjectMemberPicker), "department.name")]
public string DepartmentName { get; set; }
*[JsonProperty("projects")]

*Console.WriteLine(data);
上の説明文から、Main内のdataがインクリメントされたままで値が出力されるため、2となっている。

*format.ToString(new CultureInfo("en-US"));
$1,234.56

*public event PropertyChangedEventHandler PropertyChanged;
これ
このコードはテンプレートから生成されました。

このファイルを手動で変更すると、アプリケーションで予期しない動作が発生する可能性があります。
このファイルに対する手動の変更は、コードが再生成されると上書きされます。
&lt;/auto-generated&gt;
------------------------------------------------------------------------------
*namespace models

追加
*using UnityEngine.Events;
処理を実行するメソッドにコールバックを受け取りたいメソッドを渡す
*ActionMethod (ActionCallbackMethod);
*ActionMethod (() =&amp;gt; {Debug.Log("ラムダ式UnityAction実行完了 : "+testVal);});
ラムダ式UnityAction
*private void ActionMethod (UnityAction callback) {// コールバック実行callback ();}
実行メソッド
コールバック実行
*callback ();
*public void ActionCallbackMethod () {Debug.Log ("UnityAction実行完了");}
UnityActionのコールバックで呼び出されるメソッド
*void Start () {// 処理を実行するメソッドにコールバックを受け取りたいメソッドを渡すDelegateMethod (DelegateCallbackMethod);// ラムダ式delegateDelegateMethod ((string text) =&amp;gt; {Debug.Log ("ラムダ式delegate実行完了 : " + text);});}
delegate型の宣言
処理を実行するメソッドにコールバックを受け取りたいメソッドを渡す
*DelegateMethod (DelegateCallbackMethod);
*DelegateMethod ((string text) =&amp;gt; {Debug.Log ("ラムダ式delegate実行完了 : " + text);});
ラムダ式delegate
*private void DelegateMethod (OnComplete callback) {// コールバック実行callback ("文字列だよ");}
実行メソッド
コールバック実行
*callback ("文字列だよ");
*public void DelegateCallbackMethod (string text) {Debug.Log ("delegate実行完了 : "+text);}
delegateのコールバックで呼び出されるメソッド
追加
*using UnityEngine.Events;
*if (unityEvent == null)*unityEvent = new UnityEvent ();
インスタンスを生成
Invoke()で実行させるメソッドを登録する
*unityEvent.AddListener (UnityEventCallbackMethod_1);
登録されたメソッドを一斉に実行する
*unityEvent.Invoke();
*private void UnityEventCallbackMethod_1 () {Debug.Log ("UnityEvent実行完了 その1");}
Invoke時に実行されるメソッド1
*private void UnityEventCallbackMethod_2 () {Debug.Log ("UnityEvent実行完了 その2");}
Invoke時に実行されるメソッド2

*UnsubscribeEvents();
イベント削除
*{//平面が認識されている時if(unityAnchor.GetCurrentPlaneAnchors().Count != 0) {//1個目の平面オブジェクトのポジション取得Vector3 vFloor = unityAnchor.GetCurrentPlaneAnchors()[0].gameObject.transform.position;//VR空間の高さを変更するobjFloor.transform.position = new Vector3 (0f, vFloor.y, 0f);}}
ボタンなどに設定
*if(unityAnchor.GetCurrentPlaneAnchors().Count != 0) {*//1個目の平面オブジェクトのポジション取得
平面が認識されている時
*Vector3 vFloor = unityAnchor.GetCurrentPlaneAnchors()[0].gameObject.transform.position;*//VR空間の高さを変更する
1個目の平面オブジェクトのポジション取得
*objFloor.transform.position = new Vector3 (0f, vFloor.y, 0f);*}
VR空間の高さを変更する

*dbSet.FromSqlRaw<;T>;($"SELECT * FROM [{テーブル名}] WITH (UPDLOCK)")
dbSet は DbContext と紐づけられた DbSet&lt;T&gt; のインスタンスです
context は DbContext のインスタンスです
*using var transaction = context.Database.BeginTransaction();
この時点ではロックは取得しない
データ編集等
*if (context.SaveChanges() >; 0)
SaveChangesメソッドで更新系クエリが発行され、更新ロックが取得され、
Commitを行うまでの間ロックが保持される
*transaction.Commit();

*.Select(t =>; new ToDo { id = t.Id, title = t.Title, content = t.Content})
さすがにハイジャックはされたくなのでむき出しの配列では返さない。

*public CoroutineEx(IEnumerator routine) {this.routine = routine;}
コンストラクタ
*public void Update() {IsDone = !routine.MoveNext();}
更新処理
*public CoroutineEx(IEnumerator routine) {stack.Push(routine);}
コンストラクタ
*public CoroutineEx(IEnumerator routine) {stack.Push(routine);}
コンストラクタ
*public void Update() {if (stack.Count == 0) {Done();return;}var peek = stack.Peek();if (peek == null) {stack.Pop();Current = null;}else if (peek is IEnumerator) {var e = (IEnumerator)peek;try {if (e.MoveNext()) {stack.Push(e.Current);Update();} else {stack.Pop();Update();}}catch (Exception error) {stack.Clear();Error = error;Done();}}else if (peek is AsyncOperation) {if (!((AsyncOperation)peek).isDone) {Current = null;} else {stack.Pop();Update();}}else {stack.Pop();Current = peek;}}
更新処理

表示周期(編集可能)
*[SerializeField] int DisplaySpan = 10;
表示ボタン
*[SerializeField] GameObject AdsButton;
リワード処理
*public UnityEvent _UnityEvent;
*if (AdsButton.activeSelf)*{
Activeな時は処理を行わない
*if (span.TotalMinutes >; DisplaySpan)*{
Debug.Log("span.TotalMinutes " + span.TotalMinutes);

*byte[] buf;
文字列

*// input for prediction operations*// - First 4 properties are inputs/features used to predict the label
IrisData is used to provide training data, and as
*{[Column("0")]public float SepalLength;[Column("1")]public float SepalWidth;[Column("2")]public float PetalLength;[Column("3")]public float PetalWidth;[Column("4")][ColumnName("Label")]public string Label;}
- Label is what you are predicting, and is only set when training
*{[ColumnName("PredictedLabel")]public string PredictedLabels;}
IrisPrediction is the result returned from prediction operations
*// This is a classification scenario (What type of iris is this?)*pipeline.Add(new StochasticDualCoordinateAscentClassifier());
Add a learning algorithm to the pipeline.
*pipeline.Add(new StochasticDualCoordinateAscentClassifier());*// Convert the Label back into original text (after converting to number in step 3)
This is a classification scenario (What type of iris is this?)
*pipeline.Add(new PredictedLabelColumnOriginalValueConverter() { PredictedLabelColumn = "PredictedLabel" });
Convert the Label back into original text (after converting to number in step 3)
*// You can change these numbers to test different predictions*var prediction = model.Predict(new IrisData()
STEP 6: Use your model to make a prediction
*{SepalLength = 3.3f,SepalWidth = 1.6f,PetalLength = 0.2f,PetalWidth = 5.1f,});
You can change these numbers to test different predictions

*uint? data = conn.QueryFirst<;uint?>;(sql, new { UserId = userId });
ExecuteScalar が使えることを教えてもらいました

メールをエクスポートしたフォルダ
*var path = @"XXXXXXX\受信トレイ_20180522-2132\メッセージ";
*foreach (var file in Directory.EnumerateFiles(path).Where(f =>; f.Contains("Apple") &amp;&amp; f.Contains("領収書")))*{
Appleからの領収書だけ抜き出す
タイトル名の後に'¥'が来ないのはおかしい(予想外の形式)ので止める
*throw new Exception();
おかしい
*throw new Exception();
intになってるはずなので例外チェックしない
*var yen = int.Parse(yenStr);
デバッグ用
*var isFirst = true;
タイトル名の後に'¥'が来ないのはおかしい(予想外の形式)ので止める
*throw new Exception();
おかしい
*throw new Exception();
intになってるはずなので例外チェックしない
*var yen = int.Parse(yenStr);

*new AmazonS3Client();
おそらく production は EC2 のインスタンスメタデータ等から接続するはず

サンプルDLL
*var targetFilePath = @"C:\Windows\System32\shell32.dll";
メッセージテーブルリソースをもつファイルを読み込みます。
*var hModule = NativeMethods.LoadLibraryEx(filePath, IntPtr.Zero, NativeMethods.LoadLibraryExFlags.DONT_RESOLVE_DLL_REFERENCES | NativeMethods.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE);
*{// 文字列リソースIDは、得られたリソース名（INTRESOURCE）-1の16倍var resId = (nam.ToInt32() - 1) * 16;var hRes = NativeMethods.FindResource(hMod, nam, typ);if (!IntPtr.Zero.Equals(hRes)){var hGlobal = NativeMethods.LoadResource(hMod, hRes);if (!IntPtr.Zero.Equals(hGlobal)){var bytesLen = NativeMethods.SizeofResource(hMod, hRes);var ptr = NativeMethods.LockResource(hGlobal);if (!IntPtr.Zero.Equals(ptr)){Int32 offset = 0;while(offset <; bytesLen){var strLen = (UInt16)Marshal.ReadInt16(ptr + (int)offset);offset += 2;if (strLen >; 0){var str = Marshal.PtrToStringUni(ptr + (int)offset, strLen);offset += strLen * 2;retVal.Add(new System.Tuple<;Int32, string>;(resId, str));}resId += 1;}}}}return true;}, IntPtr.Zero);
STRINGテーブルのエントリを列挙させます。
文字列リソースIDは、得られたリソース名（INTRESOURCE）-1の16倍
*var resId = (nam.ToInt32() - 1) * 16;
読み込んだファイルを閉じます。
*NativeMethods.FreeLibrary(hModule);

*var r8 = r1 with { Length = 11 };
OK

*RowHeight = 60
Cellの高さを設定
*listView.ItemsSource = new String[] {"ダミーテキスト","ダミーテキスト","ダミーテキスト","ダミーテキスト","ダミーテキスト",};
ListViewに表示するデータを設定
QiitaAPIのURl
public string API_URL = "https:qiita.comapi/v2/items";
データを取得するメソッド
*public async Task<;List<;QiitaArticleEntity>;>; AsyncGetWebAPIData()
Listの作成
*articleList = new List<;QiitaArticleEntity>;();
HttpClientの作成
*HttpClient httpClient = new HttpClient();
非同期でAPIからデータを取得
*Task<;string>; stringAsync = httpClient.GetStringAsync(API_URL);
JSON形式のデータをデシリアライズ
*articleList = JsonConvert.DeserializeObject<;List<;QiitaArticleEntity>;>;(result);
List でデータを返す
*return articleList;
*{public string title { get; set; }public string url { get; set; }}
QiitaApiから取得するデータのEntity
*{try{// 取得したデータをListに設定articleList = await api.AsyncGetWebAPIData();var items = new List<;String>;();foreach (QiitaArticleEntity value in articleList){items.Add(value.title);}listView.ItemsSource = items;}// エラー表示処理catch (System.Exception ex){await DisplayAlert("Error", ex.Message.ToString(), "OK");}}
非同期でデータ取得のメソッドを実行するメソッド
取得したデータをListに設定
*articleList = await api.AsyncGetWebAPIData();
*{await DisplayAlert("Error", ex.Message.ToString(), "OK");}
エラー表示処理

*(h, p) =>; {var count = NativeMethods.GetWindowTextLength(h);var sb = new StringBuilder(count + 1);var ret = NativeMethods.GetWindowText(h, sb, sb.Capacity);Console.WriteLine("0x{0:X8} - {1}", h.ToInt32(), sb.ToString());// 子ウインドウを列挙NativeMethods.EnumChildWindows(h, EnumChildWindowsProc, new IntPtr(1));return true;},
トップレベルウインドウを列挙
子ウインドウを列挙
*NativeMethods.EnumChildWindows(h, EnumChildWindowsProc, new IntPtr(1));
さらに自身の子ウインドウを列挙
*NativeMethods.EnumChildWindows(hWnd, EnumChildWindowsProc, new IntPtr(lParam.ToInt32() + 1));

サンプルDLL
*var targetFilePath = @"C:\Windows\System32\kernel32.dll";
メッセージテーブルリソースをもつファイルを読み込みます。
*var hModule = NativeMethods.LoadLibraryEx(filePath, IntPtr.Zero, NativeMethods.LoadLibraryExFlags.DONT_RESOLVE_DLL_REFERENCES | NativeMethods.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE);
ブロック数はDWORD
*var numOfBlocks = Marshal.ReadInt32(topOfResourceData);
先頭IDはDWORD
*var lowID = (UInt32)Marshal.ReadInt32(ptrInBlocks);
終端IDはDWORD
*var highID = (UInt32)Marshal.ReadInt32(ptrInBlocks);
オフセットはDWORD
*var offsetFromTop = Marshal.ReadInt32(ptrInBlocks);
この構造のバイトサイズはWORD
*var lengthInBytes = Marshal.ReadInt16(ptrOfMessage);
フラグ（文字種）はWORD
*var flag = Marshal.ReadInt16(ptrOfMessage);
読み込んだファイルを閉じます。
*NativeMethods.FreeLibrary(hModule);

なんらかの処理
*}

*if(GvrControllerInput.HomeButtonDown){*Debug.Log("HomeButtonDown");
Daydreamボタンを押した瞬間True
*if(GvrControllerInput.Recentered){*Debug.Log("Recentered");
ポジションリセンターした瞬間True（Daydreamボタンの長押し）
*if(GvrControllerInput.AppButtonDown){*Debug.Log("AppButtonDown");
アプリボタンを押した瞬間True
*if(GvrControllerInput.AppButtonUp){*Debug.Log("AppButtonUp");
アプリボタンを押した指を離した瞬間True
*if(GvrControllerInput.TouchDown){*Debug.Log("TouchDown");
タッチパッドにタッチした瞬間True
*if(GvrControllerInput.TouchUp){*Debug.Log("TouchUp");
タッチパッドから指が離れた瞬間True
タッチパッドにタッチしている間ずっとTrue
*Debug.Log("IsTouching : " + GvrControllerInput.IsTouching);
タッチパッドのタッチしている位置 0~1
*Debug.Log("TouchPos : " + GvrControllerInput.TouchPos);
タッチパッドのタッチしている位置 -1~1
*Debug.Log("TouchPosCentered : " + GvrControllerInput.TouchPosCentered);
コントローラの傾き
*Debug.Log("Orientation : " + GvrControllerInput.Orientation);
*Vector3 rayDir = GvrControllerInput.Orientation * Vector3.forward;*Debug.Log("rayDir : " + rayDir);
コントローラの正面方向のベクトル
角速度 | 回転の動きを取得
操作しないとVector3.zeroに戻る
ex.一定速度以上でコントローラを振ったらボールを投げる
*Debug.Log("Gyro : " + GvrControllerInput.Gyro);
加速度 | 重力、振動、衝撃を計測
ex.コントローラが傾いているとか、ぶら下がっているとかを判定する
*Debug.Log("Accel : " + GvrControllerInput.Accel);

*public interface IDisposable {// 《自分自身を》破棄するvoid Dispose();}
『破棄できる』インタフェース
《自分自身を》破棄する
*void Dispose();
*public interface IComparable<;in T>; {// 《自分自身を》T型の他のオブジェクトと『比較する』int CompareTo(T other);}
『比較できる』インタフェース
《自分自身を》T型の他のオブジェクトと『比較する』
*int CompareTo(T other);
*public interface IEnumerable<;out T>; {// 『《自分自身を》「列挙する人」を取得する』IEnumerator<;T>; GetEnumerator();}
『列挙できる』インタフェース
『《自分自身を》「列挙する人」を取得する』
*IEnumerator<;T>; GetEnumerator();
ややこしいので非ジェネリクスのIEnumerableの継承は省略
*,,,
*public interface ICustomFormatter {// 受け取った引数を元に『フォーマットする』String Format (String format, Object arg, IFormatProvider formatProvider);}
『フォーマットする人』インタフェース
*String Format (String format, Object arg, IFormatProvider formatProvider);*}
受け取った引数を元に『フォーマットする』
*public interface IEnumerator<;out T>; : IDisposable {// 《列挙する対象を》次の要素へ移動するbool MoveNext();// 《列挙する対象を》現在の要素を取得するT Current { get; }// 《列挙する対象を》初期状態に戻すvoid Reset();}
『列挙する人』インタフェース
《列挙する対象を》次の要素へ移動する
*bool MoveNext();
*T Current { get; }
《列挙する対象を》現在の要素を取得する
《列挙する対象を》初期状態に戻す
*void Reset();
ややこしいので非ジェネリクスのIEnumeratorの継承は省略
*,,,
*public interface ICollection<;T>; : IEnumerable<;T>; {// 《自分自身の》持つ要素数int Count { get; }// 《自分自身が》読み取り専用か否かbool IsReadOnly { get; }// 《自分自身に》T型の新しい要素を追加するvoid Add(T item);// 《自分自身の》要素を空にするvoid Clear();// 《自分自身に》対象の要素が含まれているか判断するbool Contains(T item);// 《自分自身の》arrayIndex番目の要素以降をarrayにコピーするvoid CopyTo(T[] array, int arrayIndex);// 《自分自身から》対象の要素を削除するbool Remove(T item);}
『コレクション』を表すインタフェース
*int Count { get; }
《自分自身の》持つ要素数
*bool IsReadOnly { get; }
《自分自身が》読み取り専用か否か
《自分自身に》T型の新しい要素を追加する
*void Add(T item);
《自分自身の》要素を空にする
*void Clear();
《自分自身に》対象の要素が含まれているか判断する
*bool Contains(T item);
《自分自身の》arrayIndex番目の要素以降をarrayにコピーする
*void CopyTo(T[] array, int arrayIndex);
《自分自身から》対象の要素を削除する
*bool Remove(T item);
*public interface IList<;T>; : ICollection<;T>; {// 《自分自身の》index番目の要素を取得、設定するT this[int index] { get; set; }// 《自分自身の》何番目に対象の要素があるか判断するint IndexOf(T item);// 《自分自身の》index番目に対象の要素を挿入するvoid Insert(int index, T item);// 《自分自身の》index番目の要素を削除するvoid RemoveAt(int index);}
『リスト』を表すインタフェース
*public interface IList<;T>; : ICollection<;T>; {// 《自分自身の》index番目の要素を取得、設定するT this[int index] { get; set; }// 《自分自身の》何番目に対象の要素があるか判断するint IndexOf(T item);// 《自分自身の》index番目に対象の要素を挿入するvoid Insert(int index, T item);// 《自分自身の》index番目の要素を削除するvoid RemoveAt(int index);}
『リスト』は『コレクション』に加えて以下のことが可能
*T this[int index] { get; set; }
《自分自身の》index番目の要素を取得、設定する
《自分自身の》何番目に対象の要素があるか判断する
*int IndexOf(T item);
《自分自身の》index番目に対象の要素を挿入する
*void Insert(int index, T item);
《自分自身の》index番目の要素を削除する
*void RemoveAt(int index);
*interface IPrintable {// 《自分自身を》印刷するvoid Print();}
『印刷できる』
《自分自身を》印刷する
*void Print();
*class Document : IPrintable { /*...*/ }
例えば、印刷できるドキュメント型
*interface ICutter {// 《他のものを》切るPaper[] Cut(Paper paper);}
『カッター(切るもの)』
《他のものを》切る
*Paper[] Cut(Paper paper);
*class Scissor : ICutter { /*...*/ }
例えば、他の物を切ることができるハサミ型
*interface IRemoteControllable {// 《自分自身を》操作するためのリモコンを取得するIRemoteController GetController();}
『リモコンで操作できる』
《自分自身を》操作するためのリモコンを取得する
*IRemoteController GetController();
*interface IRemoteController {// 『《遠隔操作する対象の》電源を入切する』void Power(bool turningOn);// 『《遠隔操作する対象の》チャネルを変更する』void ChangeChannel(int channel);}
『リモコン(遠隔操作するもの)』
『《遠隔操作する対象の》電源を入切する』
*void Power(bool turningOn);
『《遠隔操作する対象の》チャネルを変更する』
*void ChangeChannel(int channel);
*class Television : IRemoteControllable {bool _powerOn;int _channel;// 自分自身を対象とするリモコンを返却public IRemoteController GetController() {return new RemoteController(this);}// リモコン型class RemoteController : IRemoteController {Television _television;// コンストラクタで対象のテレビを受け取るpublic RemoteController(Television television) {_television = television;}public void ChangeChannel(int channel) {_television._channel = channel;}public void Power(bool turningOn) {_television._powerOn = turningOn;}}}
リモコン操作可能なテレビ型
*public IRemoteController GetController() {return new RemoteController(this);}
自分自身を対象とするリモコンを返却
*class RemoteController : IRemoteController {Television _television;// コンストラクタで対象のテレビを受け取るpublic RemoteController(Television television) {_television = television;}public void ChangeChannel(int channel) {_television._channel = channel;}public void Power(bool turningOn) {_television._powerOn = turningOn;}}
リモコン型
*public RemoteController(Television television) {_television = television;}
コンストラクタで対象のテレビを受け取る
*interface ICar {// 『《自分自身の》エンジンを開始する』void StartEngine();// 『《自分自身を》加速する』void Accel();// 『《自分自身を》減速する』void Break();}
『車』
『《自分自身の》エンジンを開始する』
*void StartEngine();
『《自分自身を》加速する』
*void Accel();
『《自分自身を》減速する』
*void Break();
*class Car : ICar { /* ・・・*/ }
様々な車

コピー先はjpg形式とする。
*string destFileName = Path.Combine(_destFolder ,Path.GetFileName(picturePath) + ".jpg");
ファイルのロードに失敗する場合は次へ行く。
*}

*pdf.PageScaling = PdfPrintPageScaling.ActualSize;
実際の大きさ
何もしない
*}

*#if _IOS_
iOSがターゲットのOSの際には、実行されるもの

*routeTemplate: "api
{controller}{action}{id}", ここは編集する。

最小サイズを設定
*var minimumSize = this.minimumSize;
すでに同じ名前のAdvancedDropdownItemがあった場合は次へ
*parent = foundChildItem;
KeyをAdvacnedDropdownItemnのidにしてパスを取得できるようにする
*pathDictionary[lastItem.id] = path;
ボタンの表示方法を設定
*button.style.width = BUTTON_WIDTH;
イベント購読
*sampleDropdown.onItemSelected += OnItemSelected;

*// Note that default(T) is not equal to null for value types except when T is Nullable<;U>;.*return ((value is T) || (value == null &amp;&amp; default(T) == null));
Non-null values are fine.  Only accept nulls if T is a class or Nullable&lt;U&gt;.
*// before adding the new element.*//
increased by one. If required, the capacity of the list is doubled

*var data = 1;
上のCountUpのdataと、このdataは別物！

*TokenAudience = new Uri("https:
api.loganalytics.io"),

*var hogeTypes = (HogeType[])Enum.GetValues(typeof(HogeType));
System.Arrayが返されるので、キャストする。

*float speed = 0.01f;
後で速度変更しやすいように敢えて変数にしている
*{rectTransform = this.GetComponent<;RectTransform>;();}
Start is called before the first frame update
*{if (Increase){i += speed;}else{i -= speed;}if (i >;= 1){Increase = false;}if (i <;= 0){Increase = true;}rectTransform.localScale = new Vector3(i, i, 0);}
Update is called once per frame

*using (Process process = this.CreateFCProcess(sourceFileName, destinationFileName)) {await this.StartCommandAsync(process);}
Processを非同期に実行
プロセスからの情報を受け取る変数の初期化
*this.m_FCResult = "";
プロセスの開始
*started = process.Start();

*T Current { get; }
現在の要素を取得する。
次の要素に移動する。次の要素があればtrue,無ければfalseを返す。
*bool MoveNext();
その他の定義は省略
*}
イテレータを取得
*IEnumerator<;T>; GetEnumerator();
その他の定義は省略
*}
実際には例外処理や後処理などがあるが、ここでは省略
*,,,
*static IEnumerable<;int>; Generate5Primes() {yield return 2;yield return 3;yield return 5;yield return 7;yield return 11;}
イテレータ構文と呼ばれているが、実際にはジェネレータ
*static IEnumerable<;double>; RandomDoubles() {var random = new Random();while (true) {yield return random.NextDouble();}}
無限ループも使い方次第

*foreach (var user in users)*{
ユーザをリストしていく。
*user.NotifyMessage(message);*}
各ユーザにメッセージを通知する。
*Log.ErrorFormat("通知に失敗 : ErrorCode = {0}", ne.ErrorCode, ne);
通知に失敗したのでログに出力
*foreach (var user in users)*{
ユーザをリストしていく。
*user.NotifyMessage(message);*}
各ユーザにメッセージを通知する。
*Log.ErrorFormat("通知に失敗 : ErrorCode = {0}, UserGUID = {1}", ne.ErrorCode, user.Guid, ne);
通知に失敗したのでログに出力

*void Start () {}
Use this for initialization
*void Update () {this.GetComponent<;Text>;().text = "ここに文字が表示されます。";}
Update is called once per frame
*void Start () {}
Use this for initialization
*void Update () {int sum = x + y;this.GetComponent<;Text>;().text = "x + y =" + sum.ToString();}
Update is called once per frame

*string finishedUrl = @"https:
api.twitter.comoauthauthorize";
&lt;code&gt;があった=認証に成功した場合
*pin = html.Substring(codeIndex + 6, 7);
&lt;code&gt;がなかった=認証に失敗した場合
*MessageBox.Show("認証に失敗しました．");

*.UseStartup<;Startup<;()
Startupクラスを使用する
リクエストを受け付けたら「Hello World!」と出力する
*app.Run(async context =>; await context.Response.WriteAsync("Hello World!"));
UseStartupの代わりに以下を記述する
*.Configure(app =>; app.Run(async context =>; await context.Response.WriteAsync("Hello World!")))
Dependency InjectionでASP.NET Core MVC周りの機能を解決できるようにする
*services.AddMvcCore();
*{// とりあえず[コントローラ名]/[アクション名]でURLをルーティングroute.MapRoute("default", "{controller}/{action}");});
ASP.NET Core MVCのルーティングを有効化する
*route.MapRoute("default", "{controller}/{action}");
とりあえず[コントローラ名]/[アクション名]でURLをルーティング
*{public string Index(){return "value";}}
ControllerではなくControllerBaseを継承させる
Dependency InjectionでASP.NET Core MVCのView周りの機能を解決できるようにする
*services.AddMvc();
アクション名に一致するViewを返す
*return View();
各ファイルの基点となるディレクトリを設定
*.UseContentRoot(Directory.GetCurrentDirectory())

*void Start () {}
Use this for initialization
*void Update () {transform.position += (new Vector3(x,y,z));}
Update is called once per frame
*void Start () {}
Use this for initialization
*void Update () {if (Input.GetKey (KeyCode.LeftArrow)) {print ("左押したよ");transform.position -= (new Vector3 (x, 0, 0));}if (Input.GetKey (KeyCode.RightArrow)) {print ("右押したよ");transform.position += (new Vector3 (x, 0, 0));}if (Input.GetKey (KeyCode.UpArrow)) {print ("上押したよ");transform.position += (new Vector3 (0, 0, z));}if (Input.GetKey (KeyCode.DownArrow)) {print ("下押したよ");transform.position -= (new Vector3 (0, 0, z));}}
Update is called once per frame
移動スピードをpublicで初期化
*public float mvsp = 3;
*void Start () {}
Use this for initialization
*void Update () {// 左キー押されたらTime.deltaTimeとmvspでddt値を作成if (Input.GetKey (KeyCode.LeftArrow)) {float ddt = Time.deltaTime * mvsp;transform.position += (new Vector3 (-ddt, 0, 0));}// 右キー押されたらTime.deltaTimeとmvspでddt値を作成if (Input.GetKey (KeyCode.RightArrow)) {float ddt = Time.deltaTime * mvsp;transform.position += (new Vector3 (ddt, 0, 0));}if (Input.GetKey (KeyCode.UpArrow)) {float ddt = Time.deltaTime * mvsp;transform.position += (new Vector3 (0, 0, ddt));}if (Input.GetKey (KeyCode.DownArrow)) {float ddt = Time.deltaTime * mvsp;transform.position += (new Vector3 (0, 0, -ddt));}}
Update is called once per frame
*if (Input.GetKey (KeyCode.LeftArrow)) {*float ddt = Time.deltaTime * mvsp;
左キー押されたらTime.deltaTimeとmvspでddt値を作成
*if (Input.GetKey (KeyCode.RightArrow)) {*float ddt = Time.deltaTime * mvsp;
右キー押されたらTime.deltaTimeとmvspでddt値を作成
speedを制御する
*public float speed = 10;
*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame

*void Start () {//単純にコンソールで文字を表示させるだけprint("ハローワールド");}
Use this for initialization
単純にコンソールで文字を表示させるだけ
*print("ハローワールド");
*void Update () {}
Update is called once per frame
*void Start () {//単純に今度はコンソールでDebug Logで出力するDebug.Log("ハローワールドDebug Log");}
Use this for initialization
単純に今度はコンソールでDebug Logで出力する
*Debug.Log("ハローワールドDebug Log");
*void Update () {}
Update is called once per frame
*void Start () {int kotae = x + y;print ("答えは" + kotae);}
Use this for initialization
*void Update () {}
Update is called once per frame
*void Start () {if (x == testx) {print ("合ってる");} else {print ("間違っている");}}
Use this for initialization
*void Update () {}
Update is called once per frame
*void Start () {if (fuga == 3) {print ("3で合ってるよ");} else if (fuga == 4) {print ("おしい。それ４だから");} else {print ("３じゃないよ");}}
Use this for initialization
*void Update () {}
Update is called once per frame
*void Start () {}
Use this for initialization
*void Update () {while (cont <;= tasukazu) {sum += cont;cont++;}print (sum);}
Update is called once per frame
*void Start () {for (int cont = 1; cont <;= 100; cont++) {sum += cont;}print(sum);}
Use this for initialization
*void Update () {}
Update is called once per frame

*if (string.Compare(child.name, field.Name, true) != 0)*{
フィールドとオブジェクトの名前を大文字小文字無視して比較する
一致しなかったらスキップ
*continue;
対象のコンポーネントが存在しないのでスキップ
*continue;
NonPublicなフィールドのうち、SerializeField属性が設定されてるものを取得する
*var nonPublicFields = contextType.GetFields(BindingFlags.Instance | BindingFlags.NonPublic);

*new HighKobold(new Mage()).Show();
Hp:20 Mp:10 Skill:コボルトサンダー

*private void Move(Stack<;int>; s1, Stack<;int>; s2, Stack<;int>; s3, int n) {if (n >; 0) {Move(s1, s3, s2, n - 1);int x = s1.Pop();s3.Push(x);OnChanged();Move(s2, s1, s3, n - 1);}}
当プログラムの核となるメソッド
*private void OnChanged() {foreach (var observer in _observers) {observer.OnNext(_state);}}
状況変化を知らせるために購読者に通知する
*public IDisposable Subscribe(IObserver<;HanoiState>; observer) {_observers.Add(observer);return observer as IDisposable;}
購読する場合に呼び出すメソッド
初期状態時にもOnNextが呼ばれるので0ではなく、-1にしておく。
*private int count = -1;
*public void OnCompleted() {Console.WriteLine($"\n{count}手で移動完了");}
IObserver&lt;T&gt; インターフェース
*public void OnError(Exception error) {Console.WriteLine("{0]", error.Message);}// IObserver<;T>; インターフェースpublic void OnNext(HanoiState value) {count++;DisplayState(value);}private void DisplayState(HanoiState value) {var t1 = TowerToString(value.Number, value.StickA);var t2 = TowerToString(value.Number, value.StickB);var t3 = TowerToString(value.Number, value.StickC);for (int i = 0; i <; t1.Length; i++) {Console.WriteLine($"{t1[i]} {t2[i]} {t3[i]}");}Console.WriteLine();}private string[] TowerToString(int n, IEnumerable<;int>; tower) {// 塔の下から組み立てる// 幅2の円盤だけがあるときは、tower は、{ 2 } となり、Count() == 1 になので注意する。var rewot = tower.Reverse().ToArray();var list = new List<;char[]>;();for (var i = 0; i <; n; i++) {var w = i <; rewot.Length ? rewot[i] : 0;var s = new string(' ', n - w) + new string('=', w * 2 + 1) + new string(' ', n - w);list.Add(s.ToArray());}list.Add(new string(' ', n * 2 + 1).ToArray());foreach (var floor in list) {floor[n] = '|';}// 最後に逆転させる。1階が配列の一番最後に来るようにする。return list.Select(f =>; new string(f)).Reverse().ToArray();}}
IObserver&lt;T&gt; インターフェース
*public void OnNext(HanoiState value) {count++;DisplayState(value);}
IObserver&lt;T&gt; インターフェース
*// 幅2の円盤だけがあるときは、tower は、{ 2 } となり、Count() == 1 になので注意する。
塔の下から組み立てる
幅2の円盤だけがあるときは、tower は、{ 2 } となり、Count() == 1 になので注意する。
*var rewot = tower.Reverse().ToArray();
最後に逆転させる。1階が配列の一番最後に来るようにする。
*return list.Select(f =>; new string(f)).Reverse().ToArray();

*public Queries(string intent, double score)
ここのintentとかはluisの要素と一緒にしないとダメかも

【重要】xmlファイル名を指定する場合は「プロジェクト名.File1.xml」という形式にする必要がある
*var xmlfile = "WinServiceAppSample1.XMLSettingFile.xml";

Typeからフィールドを探す。フィールド名とBindingFlagsを引数にする。
*FieldInfo field = type.GetField("_field", BindingFlags.InvokeMethod | BindingFlags.NonPublic | BindingFlags.Instance);
Typeからメソッドを探す。メソッド名とBindingFlagsを引数にする。
*MethodInfo method = type.GetMethod("PrivateMethod", BindingFlags.InvokeMethod | BindingFlags.NonPublic | BindingFlags.Instance);
インスタンスを作成する
*object instance = Activator.CreateInstance(type);
*int methodResult = (int)(method.Invoke(instance, new object[2] { 3, 4 }));
探したメソッドを実行する。　呼ぶメソッドはint,intを引数にし、戻り値もintのため、intにcastしている

*p.Show(title:Console.ReadLine());
名前付き引数

*using(Stream filestream = File.Open(filename, FileMode.Open)) {//Actvar deserialize = XMLDataContract.Load<;CompanyInfo>;(filestream);//AssertAssert.AreEqual(deserialize.Company, "ほんにゃら産業");}
Arrange
*using(Stream filestream = File.Open(filename, FileMode.Open)) {//Actvar deserialize = XMLDataContract.Load<;CompanyInfo>;(filestream);//AssertAssert.AreEqual(deserialize.Departments[1].DeparmentName, "総務部");}
Arrange
*using(Stream filestream = File.Open(filename, FileMode.Open)) {//Actvar deserialize = XMLDataContract.Load<;CompanyInfo>;(filestream);//AssertAssert.AreEqual(deserialize.Departments[0].Employees[1].EmployeeName, "木村課長");Assert.AreEqual(deserialize.Departments[0].Employees[1].Gender, "男");}
Arrange

ApplicationDeployment.IsNetworkDeployedがtrueの時に取得可能
*ApplicationDeployment.CurrentDeployment.DataDirectory

*if (!Properties.Settings.Default.IsUpgraded)*{
以下のコードを追加
ClickOnceで配布されたアプリケーションを実行した場合は、
*string dataDirectory;
データディレクトリに保存します (最後に'\'は含まないので注意)
*dataDirectory = ApplicationDeployment.CurrentDeployment.DataDirectory;
*{// exeと同じパスに保存します (最後に'\'を含む)dataDirectory = AppDomain.CurrentDomain.BaseDirectory;}
直接exeを実行した場合は、
exeと同じパスに保存します (最後に'\'を含む)
*dataDirectory = AppDomain.CurrentDomain.BaseDirectory;
ディレクトリの最後の'\'の有無が異なるため、Path.Combineでつなげる
*string dataPath = Path.Combine(dataDirectory, "data.ini");
*{writer.WriteLine("data");}
出力

*Console.WriteLine("{0}ミリ秒", sw.ElapsedMilliseconds);
結果 → 3003ミリ秒

*for (var i = 0; i <; _arPrefabs.Length; i++)*{
辞書を作る 画像の名前とARオブジェクトのPrefabを紐づける
認識した画像マーカーの名前を使って辞書から任意のオブジェクトを引っ張り出す
*var arObject = _markerNameAndPrefabDictionary[trackedImage.referenceImage.name];
*var markerFrontRotation = imageMarkerTransform.rotation * Quaternion.Euler(90f, 0f, 0f);*arObject.transform.SetPositionAndRotation(imageMarkerTransform.transform.position, markerFrontRotation);
位置合わせ
トラッキングの状態に応じてARオブジェクトの表示を切り替え
*arObject.SetActive(trackedImage.trackingState == TrackingState.Tracking);

*this.LabelEdit = false;
テキストボックスを表示するので、編集不可にしておく

*public PennyFlipping(int n) {_number = n;_disks = new bool[n];}
falseが表
*public IEnumerable<;(int, bool[])>; Solve() {int count = 0;foreach (var n in Repeat(Enumerable.Range(1, _number))) {Turn(n);yield return (n, _disks.ToArray());count++;if (IsFin())break;}}
問題を解く
*private IEnumerable<;int>; Repeat(IEnumerable<;int>; nums) {while (true) {foreach (var n in nums)yield return n;}}
1,2,3,...n,1,2,3,...n,1,2,3,...nを永遠に繰り返す
*public void Turn(int n) {var r = _disks.Take(n).Reverse().ToArray();for (int i = 0; i <; n; i++) {_disks[i] = !r[i];}}
先頭N枚のコインをひっくり返す。
*public bool IsFin() {return _disks.All(d =>; d == false);}
終了したかどうか
*public int Solve(Action<;int, bool[]>; progress) {int count = 0;foreach (var n in Repeat(Enumerable.Range(1, _number))) {Turn(n);progress(n, _disks.ToArray());count++;if (IsFin())break;}return count;}
問題を解く

*var index = keys.IndexOf(key);
for を駆使する場合もある。
エラー判定は省略
*return values[index];
エラー処理は省略
*}

必要に応じて.addToやClassTerminateなどでオブジェクトの解放を定義しておきます。
*LoadCommand =
例えばこんな感じのコマンドを作ってウィンドウを閉じることが出来ます。
このコードはメンバ定義もバインディングもしてないのでこのままでは動きません。
*hogehogeCommand=

aとbそれぞれに、値を入れて、いろいろ試してみます。
*int a = 100;
*Console.WriteLine("a >; b : {0}",     (a >; b));
Javaなら、System.out.printf("a &gt; b : %s%n", (a &gt; b));とか。
*var array = new int[] { 3, 1, -2147483647, -5 };
整数値の配列
リストに格納
*var list = new List<;int>;(array);
ラムダ式で評価してソート
*list.Sort(

*if (1 is var x &amp;&amp; (x = x * 2) != 1) { }
Intなので恐らく2倍して1になる数値はない

*tokenSource.Cancel();
Taskキャンセル

trueに変更
*AutomaticMigrationsEnabled = true;
以下のコードを追加
*SetSqlGenerator("System.Data.SQLite", new SQLiteMigrationSqlGenerator());
providerNameをコードを使って取得する。
コードを使わずに、直接"System.Data.SQLite"を使ってもいい
https:stackoverflow.com/questions/36060478/dbmigrator-does-not-detect-pending-migrations-after-switching-database
*var internalContext = context.GetType().GetProperty("InternalContext", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(context);
Migratorが使うConfigurationを生成する。
TargetDatabaseはDbMigratorの方ではなく、Configurationの方に設定しないと効果が無い。
*var configuration = new Configuration()
DbMigratorを生成する
*var migrator = new DbMigrator(configuration);
EF6.13では問題ないが、EF6.2の場合にUpdateのタイミングで以下の例外が吐かれないようにする対策
System.ObjectDisposedException: '破棄されたオブジェクトにアクセスできません。
オブジェクト名 'SQLiteConnection' です。'
https:stackoverflow.com/questions/47329496/updating-to-ef-6-2-0-from-ef-6-1-3-causes-cannot-access-a-disposed-object-error/47518197
*var _historyRepository = migrator.GetType().GetField("_historyRepository", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(migrator);
Migrationを実行する。
*migrator.Update();
*if (context.Samples.Count() == 0)*{
データベースにアクセスして保存する例
*public DbSet<;TestPoco>; Tests { get; set; }
追加
*if (context.Tests.Count() == 0)*{
以下のようにTestテーブルにアクセスできる

*private const string ApiBaseUrl = "https:
www.finds.jpwsrgeocode.php?json&amp;lon={0}&amp;lat={1}";
URLに経緯度パラメータを埋め込み
*string url = string.Format(ApiBaseUrl, longitude, latitude);
*{// API非同期実行用yield returnyield return www;// 結果JSONのデシリアライズvar desirializedData = (Dictionary<;string, object>;)Json.Deserialize(www.text);// 成功した場合のみ処理if ((long)desirializedData["status"] == 200){// 都道府県+市区町村を文字列として保持var result = (Dictionary<;string, object>;)desirializedData["result"];var prefecture = (Dictionary<;string, object>;)result["prefecture"];var municipality = (Dictionary<;string, object>;)result["municipality"];Address = (string)prefecture["pname"] + " " + (string)municipality["mname"];}}
APIを実行して経緯度を保持
API非同期実行用yield return
*yield return www;
結果JSONのデシリアライズ
*var desirializedData = (Dictionary<;string, object>;)Json.Deserialize(www.text);
*if ((long)desirializedData["status"] == 200)*{
成功した場合のみ処理
都道府県+市区町村を文字列として保持
*var result = (Dictionary<;string, object>;)desirializedData["result"];
テキストラベルオブジェクトを保持
*lonLatInfo = GameObject.Find("LonLatInfo").GetComponent<;Text>;();
経緯度取得オブジェクトオブジェクトを保持
*lonLatGetter = GetComponent<;LonLatGetter>;();
逆ジオコーディングオブジェクトを取得
*lonLatToAddr = GetComponent<;LonLatToAddr>;();
*if (lonLatGetter.CanGetLonLat())*{
経緯度の値を取得できるか判定

*var configuration = new Configuration();
Enable-Migrationsで自動生成されたクラス

適当に色んな型のオブジェクトをぶっこむ
*var list = new ArrayList();
答えとなる型をランダムで選ぶ
*Type answerType = list[new Random().Next(0, list.Count - 1 )].GetType();
ランダムで選んだ型のメンバから公開メソッドの名前のみを抽出、オーバーロードの重複はまとめる。
*var methods = answerType.GetMethods().Where(x =>; x.IsPublic).Select(x =>; x.Name).Distinct().ToList();
*Console.WriteLine($"問題 : このオブジェクトは「{hintMethodName}」メソッドを持っています。型名は何でしょう？");
その中からランダムでヒントとなるメソッド名を一つ取得
ヒントを参考に答えを入力
*string answer = Console.ReadLine();

スネークケースは推奨されていない。
*public const int HOGE_HOGE = 1;
*public int iHoge { get; set; }
ハンガリアン記法も過去のもの。
args[i] に何か処理。
*}
item に何か処理。
*}
*Hoge(new string[] { });
どれもエラーにならない！
あれこれ list.Add() する処理
*return list.ToArray();
あれこれ list.Add() する処理
*return list;
*foreach (var item in fuga) { }*var tmp = fuga[0];
読み出しはできる
書き込みはできない
コンパイルエラー
*fuga.Add("");

ディスプレイサイズ取得
*var w = UIScreen.MainScreen.Bounds.Size.Width;

*if ((uint)index >;= (uint)_size)*{
Following trick can reduce the range check by one

このコードはテンプレートから生成されました。

このファイルを手動で変更すると、アプリケーションで予期しない動作が発生する可能性があります。
このファイルに対する手動の変更は、コードが再生成されると上書きされます。
&lt;/auto-generated&gt;
------------------------------------------------------------------------------
*namespace CSVpractice.Models
*{private StreamReader reader;private bool skip;Stream fileStream;object ret;// コンストラクタpublic CsvReaderOneLine(Stream fileStream, bool skip=true, string filePath = ""){if(filePath != ""){if(!filePath.EndsWith(".csv", StringComparison.InvariantCultureIgnoreCase)){throw new FormatException("拡張子が.csvではないファイルが指定されました");}}this.fileStream = fileStream;this.skip = skip;reader = new StreamReader(fileStream);if (skip) reader.ReadLine();}public bool MoveNext(){string line = reader.ReadLine();if(line != null){string[] lineSplited = line.Split(',');var lineObj = new T();lineObj.SetDataFrom(lineSplited);var modelObj = new U();// ここの実装が力技すぎてダサい ----------------------PropertyInfo[] getItems = lineObj.GetType().GetProperties();foreach (PropertyInfo getItem in getItems){PropertyInfo[] tmpItems = modelObj.GetType().GetProperties();foreach (PropertyInfo tmpItem in tmpItems){if (getItem.Name == tmpItem.Name){tmpItem.SetValue(modelObj, getItem.GetValue(lineObj, null));}}}//---------------------------------------ret = modelObj;return true;}else{ret = null;return false;}}public object current{get{if(ret != null){return ret;}else{throw new NullReferenceException();}}}public void Reset(){reader.BaseStream.Seek(0, SeekOrigin.Begin);}public void Dispose(){this.reader.Dispose();}}
TはLineDataの継承(AddressMasterLineData)、UはModelのクラス(ADDRESS_MASTER)
*{if(filePath != ""){if(!filePath.EndsWith(".csv", StringComparison.InvariantCultureIgnoreCase)){throw new FormatException("拡張子が.csvではないファイルが指定されました");}}this.fileStream = fileStream;this.skip = skip;reader = new StreamReader(fileStream);if (skip) reader.ReadLine();}
コンストラクタ
ここの実装が力技すぎてダサい ----------------------
*PropertyInfo[] getItems = lineObj.GetType().GetProperties();
*{return View();}
GET: FileUpload

sourceディレクトリの全てのファイル・フォルダを取得(サブフォルダの内部までは見ない)
sourceフォルダに入れたものは全てAssetBundle化対象
*string[] srcFilesPath = Directory.GetFileSystemEntries(sourceDirectory);
ファイルの名前を取得し、AssetBundleの名前に設定する
*string fileName = Path.GetFileNameWithoutExtension(srcFilePath);
無いフォルダは作る
*string assetBundleDirectory = "Assets/AssetBundles/";
各OS向けにビルド
*BuildPipeline.BuildAssetBundles(assetBundleDirectory + iOSPath, BuildAssetBundleOptions.None, BuildTarget.iOS);
Windowsの方はBuildTarget.StandaloneWindowsにでも変更してください
*BuildPipeline.BuildAssetBundles(assetBundleDirectory + editerPath, BuildAssetBundleOptions.None, BuildTarget.StandaloneOSX);
*foreach (string srcPath in srcFilesPath)*{
sourceディレクトリのAssetBundle対象化を解除

*var m2 = new Messeage(2);
静的コンストラクターは実行されない

*chrome.Navigate().GoToUrl(@"http:
www.opoona.com");
ChromeOptionsオブジェクトを生成します。
*var options = new ChromeOptions();
--headlessを追加します。
*options.AddArgument("--headless");
ChromeOptions付きでChromeDriverオブジェクトを生成します。
*var chrome = new ChromeDriver(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location), options);
URLに移動します。
chrome.Url = @"http:www.opoona.com/";
タイトルを表示します。
*Console.WriteLine(chrome.Title);
すぐ終了しないよう、キーが押されるまで待機します。
*Console.ReadKey();
ブラウザを閉じます。
*chrome.Quit();

*{if (_proxy == null){_proxy = GetComponent<;VRMBlendShapeProxy>;();}else{foreach (BlendShapePreset t in Enum.GetValues(typeof(BlendShapePreset))){_proxy.SetValue(t, GetPropertyValue(t));}}}
Update is called once per frame

*Rotation rotation = Rotation.Rotate0) {var bmpImage = new BitmapImage(new Uri(path));bmpImage.Rotation = rotation;return bmpImage;}
単純なImageコントロールへの画像のセット
*Rotation rotation = Rotation.Rotate0) {var bmpImage = new BitmapImage();FileStream stream = File.OpenRead(path);bmpImage.BeginInit();bmpImage.CacheOption = BitmapCacheOption.OnLoad;bmpImage.StreamSource = stream;bmpImage.Rotation = rotation;bmpImage.EndInit();stream.Close();return bmpImage;}
画像ファイルロックをしないコントロールへの画像のセット
*//Exif情報を読み取って自動で回転や左右上下反転を行う*BitmapSource GetImageSourceAutoExifOrientate(string path) {
画像ファイルロックをしないコントロールへの画像のセット
*BitmapSource GetImageSourceAutoExifOrientate(string path) {*var bmpImage = new BitmapImage();
Exif情報を読み取って自動で回転や左右上下反転を行う

DataRowを宣言
*DataRow dr;
行を作成
*dr = dt.NewRow();
行を表に追加
*dt.Rows.Add(dr);
※以下のような書き方も可能。ただし、列と値、その位置は揃える事。
⇒『td.Rows.Add(001, "test", "田中太郎");』
*dt.Rows.Add(dr);

*dtGetLog = (DateTime)pso.Properties["TimeCreated"].Value;
ログの日付取得
なんかやりたい本処理
～～～～～～～～～～～～～～～～～～
*}

*return (T) _componentCache[type];
Dictionaryから返却
普通の使い方
*samplerNormal.Begin();
GetComponentおじさん
*samplerDefaultGetComponent.Begin();
貼るだけで速くなるコード(?)
*samplerOverrideGetComponent.Begin();
メンバ変数でキャッシュ
*samplerCache.Begin();
*if (_componentCache.ContainsKey(type) == false)*{
↓この必ず通ってしまうif文がボトルネックなのでは！！！？
*//    {//        var type = typeof(T);//        if (_componentCache.ContainsKey(type) == false)//        {//            var component = base.GetComponent<;T>;();//            if (component == null) component = gameObject.AddComponent<;T>;();////            _componentCache.Add(type, component);//        }////        return (T) _componentCache[type];//    }
public new T GetComponent&lt;T&gt;() where T : Component
*//        if (_componentCache.ContainsKey(type) == false)*//        {
var type = typeof(T);
*//        {//            var component = base.GetComponent<;T>;();//            if (component == null) component = gameObject.AddComponent<;T>;();////            _componentCache.Add(type, component);//        }
if (_componentCache.ContainsKey(type) == false)
*//            if (component == null) component = gameObject.AddComponent<;T>;();*//
var component = base.GetComponent&lt;T&gt;();
*{return (T) _componentCache[typeof(T)];}
}

上限値
*public const int UPPER_LIMIT = 999999999;
下限値
*public const int LOWER_LIMIT = 0;
*if (_willAdd + baseVariable >; UPPER_LIMIT) {*checkedNum = UPPER_LIMIT;
加算する二値の和が上限値より大きい場合、上限値で上書きする。
*} else if (_willAdd + baseVariable <; LOWER_LIMIT) {*checkedNum = LOWER_LIMIT;
二値の和が下限値未満になる場合、下限値で上書きする。
*} else {
問題がなければ、二値の和をそのまま返す。

*{this.dictionary[binder.Name] = value;return true;}
プロパティに値を設定しようとしたときに呼ばれる
*{result = this.dictionary[binder.Name];return true;}
プロパティから値を取得しようとしたときに呼ばれる
ここでdynamicを使用することが大事
*dynamic args = new ArgsObject();

*if (m.Msg == 0x31D &amp;&amp; Clipboard.ContainsImage()) OnClipboardImageUpdate();
WM_CLIPBOARDUPDATE
*protected virtual void OnClipboardImageUpdate() {if (!_notifyIcon.ContextMenu.MenuItems[0].Checked) return;uint seq = GetClipboardSequenceNumber();if (seq == _lastSeq) return;_lastSeq = seq;var t = new Thread(() =>; {Image img;if (Clipboard.ContainsData("PNG")) {IDataObject data  = Clipboard.GetDataObject();img = Image.FromStream((Stream)data.GetData("PNG"));} else {img = Clipboard.GetImage();}if (img != null &amp;&amp; img.Height >;= _minImageSize &amp;&amp; img.Width >;= _minImageSize) {string filename = Path.Combine(_imageDir, @"ScreenShot-" + DateTime.Now.ToString("yyyyMMddHHmmss") + ".png");img.Save(filename, System.Drawing.Imaging.ImageFormat.Png);if (_notifyIcon.ContextMenu.MenuItems[1].Checked) {_notifyIcon.ShowBalloonTip(1000,"","Screenshot saved!", ToolTipIcon.Info);} else {Console.Beep(500,200);}}});t.SetApartmentState(ApartmentState.STA);t.Start();}
t.Join();  uncomment to avoid "System.Runtime.InteropServices.ExternalException (0x800401D0)" error

*private int _version;
Do not rename (binary serialization)

*_ansPos0[_star[0]] = 1;
位置0に置いた番号を記憶する 対称性排除のため
*if (_tipIndexes.Contains(nextix) &amp;&amp; _ansPos0.ContainsKey(n))*continue;
回転して得られる対称解を省く
*public bool IsAnswer() {return GetLines(_star).All(line =>; line.Sum() == 26);}
解か？
*public bool IsCorrect() {foreach (var line in GetLines(_star)) {// 26より大きければダメif (line.Sum() >; 26)return false;// 直線に数字が全て埋まっていて、26より小さければダメif (line.All(x =>; x >; 0) &amp;&amp; line.Sum() <; 26)return false;// 鏡像を省くif ((_star[2] != 0 &amp;&amp; _star[3] != 0) &amp;&amp; (_star[2] >; _star[3]))return false;}return true;}
正しいか （途中の状態を調べる）
*if (line.Sum() >; 26)*return false;
26より大きければダメ
*if (line.All(x =>; x >; 0) &amp;&amp; line.Sum() <; 26)*return false;
直線に数字が全て埋まっていて、26より小さければダメ
*if ((_star[2] != 0 &amp;&amp; _star[3] != 0) &amp;&amp; (_star[2] >; _star[3]))*return false;
鏡像を省く
*public IEnumerable<;int[]>; GetLines(int[] stars) {yield return new int[] { stars[0], stars[2], stars[5], stars[7] };yield return new int[] { stars[0], stars[3], stars[6], stars[10] };yield return new int[] { stars[1], stars[2], stars[3], stars[4] };yield return new int[] { stars[1], stars[5], stars[8], stars[11] };yield return new int[] { stars[7], stars[8], stars[9], stars[10] };yield return new int[] { stars[4], stars[6], stars[9], stars[11] };}
6本の直線を列挙する
*// こんな拡張メソッド書けば、インデックス付きのforeachができる。*static class EnumerableExtensions {
これはちょっとしたお遊び。
*static class EnumerableExtensions {public static IEnumerable<;(T, int)>; Enumerate<;T>;(this IEnumerable<;T>; seq, int startIndex) {var i = startIndex;foreach (var e in seq) {yield return (e, i);i++;}}}
こんな拡張メソッド書けば、インデックス付きのforeachができる。

*{if (price <; 0){throw new ArgumentOutOfRangeException("商品価格は0以上の数値を入力してください。");}else if (canRemoveTax){// 消費税なしで割引適用if (canDiscount){return price * 0.9m;}else{return price;}}else{// 消費税ありで割引適用if (canDiscount){return price * 1.08m * 0.9m;}else{return price * 1.08m;}}}
客が支払う金額を計算する
*if (canDiscount)*{
消費税なしで割引適用
*if (canDiscount)*{
消費税ありで割引適用
*if (price <; 0)*{
エラー回避
消費税率確定
*decimal taxRate;
割引率確定
*decimal discountRate;
支払価格を計算する
*return price * (1m + taxRate) * discountRate;

*return year % 4 == 0 &amp;&amp; year % 100 != 0;
400で割り切れないので、4で割り切れるかつ100で割り切れない
数行の処理
*country = GetCountry(countryId);
数行の処理
*Country country = GetCountry(countryId);

*Content = new StackLayout
C＃勉強会、５日目のコンストラクターの生成構文参照

*if (sdr.Read())
コマンドによってwhileだったりifだったりする
ここに処理を書く
*return true;

*using System.Net.NetworkInformation;*namespace test
Pingを使用するにはこの名前空間が必要。
Sendメソッドでリクエストを送り、結果を格納したPingReplyクラスを返す。
*var reply = ping.Send("google.com");
*Console.WriteLine($"ping succeeded is {isSucceeded}");
Pingの返答が正しく返ってきたときはStatusプロパティでIPStatus列挙のSuccessを返す。Success以外はFalseである
*Console.WriteLine($"ping average time is {averageTime}");
時間がどれだけかかったかを知りたい場合はRoundtripTimeプロパティで取得可能

*var h = new Hoge ("constructor"){value = "initializer"};
それぞれの（）{}で、コメントアウトすると、結果が変わるよ☆

*{//１．ここでawaitすると同期処理にvar alpha = GetsSum(5);var bravo = GetsSum(7);//２．ここでawaitすると非同期処理にint a = await alpha;int b = await bravo;Console.WriteLine($"{a}+{b}={a + b}");});
Main内でasyncする場合はTaskを用意して走らせる必要がある。
１．ここでawaitすると同期処理に
*var alpha = GetsSum(5);
２．ここでawaitすると非同期処理に
*int a = await alpha;
*{Console.WriteLine($"task start interval {interval}");var intTask = Task<;int>;.Run(() =>;{var sum = 0;for (int i = 0; i <; 1000/interval; i++){sum += i;Console.WriteLine($"interval {interval}'s sum : {sum}");Thread.Sleep(interval);}return sum;});return await intTask;}
一定時間ごとに値を加算、コンソールに出力する。

*void Fetch(int number) {// 重い処理。Thread.Sleep(100);}
00:00:02.0102643
重い処理。
*Thread.Sleep(100);
*source.AsParallel().ForAll(i =>; {Fetch(i);});
00:00:02.0139477
*Parallel.ForEach(source, i =>; {Fetch(i);});
00:00:00.5032450

*await Task.Delay(1000);
1秒差でColdなObservableソースを2回購読

*{
文法ファイルが存在する場合
音声認識の設定に失敗
*MessageBox.Show("音声認識の設定に失敗しました。", "音声認識", MessageBoxButtons.OK,
チェックボックス(音声入力)を非活性
*this.checkBoxVoiceInput.Enabled = false;
音声認識エンジンのオブジェクトを解放
*this.Engine.Dispose();
音声認識エンジンを初期化
*this.Engine = null;
コメント以外の行を取得
*var lines = File.ReadAllLines(path, Encoding.Default)
ファイルを作成するフォルダが存在するかチェック
存在しない場合は、フォルダを作成
*string dirPath = Path.GetDirectoryName(path);
*if (appendFlg)*{
指定ファイルに内容を書き込む
ファイルの末尾に書き加える
*File.AppendAllText(path, data, Encoding.Default);
ファイルを上書きする
*File.WriteAllText(path, data, Encoding.Default);

*for(int flags = 0; flags <; 1048576; flags++)*{
単純に整数値をforで回して、各ビットが立っているか調べるだけ
*if( (flags &amp; (0x01 <;<; bit)) != 0)*{
各ビットが立っていれば、チェックされているとみなす

*{// 従業員IDpublic int Id { get; set;}// 部署IDpublic int DepartmentId { get; set;}// 従業員名public string Name { get; set;}}
従業員
*public int Id { get; set;}
従業員ID
*public int DepartmentId { get; set;}
部署ID
*public string Name { get; set;}
従業員名
*{// 部署IDpublic int Id { get; set;}// 部署名public string Name { get; set;}}
部署
*public int Id { get; set;}
部署ID
*public string Name { get; set;}
部署名
*{new Employee { Id = 100, Name = "佐藤", DepartmentId = 1 },new Employee { Id = 101, Name = "鈴木", DepartmentId = 2 },new Employee { Id = 102, Name = "高橋", DepartmentId = 3 },new Employee { Id = 103, Name = "田中", DepartmentId = 2 },new Employee { Id = 104, Name = "伊藤", DepartmentId = 1 },new Employee { Id = 105, Name = "渡辺", DepartmentId = 3 },new Employee { Id = 106, Name = "山本", DepartmentId = 1 },};
従業員データ
*{new Department { Id = 1, Name = "開発部" },new Department { Id = 2, Name = "研究部" },new Department { Id = 3, Name = "総務部" }};
部署データ
*{// 従業員IDpublic int Id { get; set;}// 部署ID(null許容型)public int? DepartmentId { get; set;}// 従業員名public string Name { get; set;}}
従業員
*public int Id { get; set;}
従業員ID
*public int? DepartmentId { get; set;}
部署ID(null許容型)
*public string Name { get; set;}
従業員名
*{// 部署IDpublic int Id { get; set;}// 部署名public string Name { get; set;}}
部署
*public int Id { get; set;}
部署ID
*public string Name { get; set;}
部署名
*{new Employee { Id = 100, Name = "佐藤", DepartmentId = 1 },new Employee { Id = 101, Name = "鈴木", DepartmentId = 2 },new Employee { Id = 102, Name = "高橋", DepartmentId = null },new Employee { Id = 103, Name = "田中", DepartmentId = null },new Employee { Id = 104, Name = "伊藤", DepartmentId = 1 },new Employee { Id = 105, Name = "渡辺", DepartmentId = 3 },new Employee { Id = 106, Name = "山本", DepartmentId = 1 },};
従業員データ
*{new Department { Id = 1, Name = "開発部" },new Department { Id = 2, Name = "研究部" },new Department { Id = 3, Name = "総務部" }};
部署データ

*void Start () {//オブジェクトの色を赤に変更するGetComponent<;Renderer>;().material.color = Color.red;}
Use this for initialization
オブジェクトの色を赤に変更する
*GetComponent<;Renderer>;().material.color = Color.red;
*void Update () {}
Update is called once per frame
*void Start () {//オブジェクトの色をRGBA値を用いて変更するGetComponent<;Renderer>;().material.color = new Color32(248, 168, 133, 1);}
Use this for initialization
オブジェクトの色をRGBA値を用いて変更する
*GetComponent<;Renderer>;().material.color = new Color32(248, 168, 133, 1);
*void Update () {}
Update is called once per frame
*void Start () {//オブジェクトの色を用意したMaterialの色に変更するGetComponent<;Renderer>;().material.color = colorA.color;}
Use this for initialization
オブジェクトの色を用意したMaterialの色に変更する
*GetComponent<;Renderer>;().material.color = colorA.color;
*void Update () {}
Update is called once per frame

*if (a % b == 0)*{
int c =0;
BEEPでカエルの歌の途中まで作成
*Console.Beep(540, 250);

ここでHook登録
*}
ここでHook削除
*}
*if (!Main.player[args.Msg.whoAmI].ghost)*{
ゴーストの時だけ処理
処理するので処理しましたフラグを建てる
*args.Handled = true;
今回はゴーストが移動したときにテレポートさせたいだけなので、一度テラリアサーバーが行う処理と同じことをする。
*BinaryReader reader = new BinaryReader(new MemoryStream(args.Msg.readBuffer, args.Index, args.Length));
ゴーストを短距離テレポート
*ShortTeleportGhost(player);
ゴーストにタイル情報送信
*RemoteClient.CheckSection(playerIndex, player.position);
今は何もしない
*}
配列に入力切り替わり時間と前回の入力を保存しておく(上左下右)
*private int[,] lastControlChangedTicks = new int[Main.player.Length, 4];
テレポート相対位置
*Vector2 teleportOffset = Vector2.Zero;
*if (lastControlChangedTicks[playerIndex, 0] + SHORT_TELEPORT_DOUBLE_TAP_TICK >; currentGameTick)*{
プレイヤーコントロール入力変化(上入力なし→あり)
プレイヤーコントロール入力変化(上入力あり→なし)
*lastControlChangedTicks[playerIndex, 0] = currentGameTick;
*if (lastControlChangedTicks[playerIndex, 1] + SHORT_TELEPORT_DOUBLE_TAP_TICK >; currentGameTick)*{
プレイヤーコントロール入力変化(左入力なし→あり)
プレイヤーコントロール入力変化(上入力あり→なし)
*lastControlChangedTicks[playerIndex, 1] = currentGameTick;
*if (lastControlChangedTicks[playerIndex, 2] + SHORT_TELEPORT_DOUBLE_TAP_TICK >; currentGameTick)*{
プレイヤーコントロール入力変化(下入力なし→あり)
プレイヤーコントロール入力変化(左入力あり→なし)
*lastControlChangedTicks[playerIndex, 2] = currentGameTick;
*if (lastControlChangedTicks[playerIndex, 3] + SHORT_TELEPORT_DOUBLE_TAP_TICK >; currentGameTick)*{
プレイヤーコントロール入力変化(右入力なし→あり)
プレイヤーコントロール入力変化(右入力あり→なし)
*lastControlChangedTicks[playerIndex, 3] = currentGameTick;
プレイヤー入力を記録(パケットが来るまで入力は変化しないため、リセット等は必要ない)
*lastPlayerControl[playerIndex, 0] = player.controlUp || player.controlJump;
TODO: 実際にテレポートさせる
*}
(省略)
移動距離が0以外の場合
*if (teleportOffset != Vector2.Zero)
*if (!isSSC)*{
サーバーサイドキャラクターではない場合、サーバーサイドキャラクターに一時的にする
*if (player.position.X >; Main.rightWorld - 992)*{
プレイヤーがワールド端に行き過ぎないように補正
クライアントにプレイヤー情報送信(事実上のテレポート)
*NetMessage.SendData((int)PacketTypes.PlayerUpdate, playerIndex, -1, null, playerIndex);
*if (!isSSC)*{
サーバーサイドキャラクターではなかった場合、元に戻す
配列に入力切り替わり時間と前回の入力を保存しておく(上左下右)
*private int[,] lastControlChangedTicks = new int[Main.player.Length, 4];
*if (!Main.player[args.Msg.whoAmI].ghost)*{
ゴーストの時だけ処理
処理するので処理しましたフラグを建てる
*args.Handled = true;
今回はゴーストが移動したときにテレポートさせたいだけなので、一度テラリアサーバーが行う処理と同じことをする。
*BinaryReader reader = new BinaryReader(new MemoryStream(args.Msg.readBuffer, args.Index, args.Length));
ゴーストを短距離テレポート
*ShortTeleportGhost(player);
ゴーストにタイル情報送信
*RemoteClient.CheckSection(playerIndex, player.position);
テレポート相対位置
*Vector2 teleportOffset = Vector2.Zero;
*if (lastControlChangedTicks[playerIndex, 0] + SHORT_TELEPORT_DOUBLE_TAP_TICK >; currentGameTick)*{
プレイヤーコントロール入力変化(上入力なし→あり)
プレイヤーコントロール入力変化(上入力あり→なし)
*lastControlChangedTicks[playerIndex, 0] = currentGameTick;
*if (lastControlChangedTicks[playerIndex, 1] + SHORT_TELEPORT_DOUBLE_TAP_TICK >; currentGameTick)*{
プレイヤーコントロール入力変化(左入力なし→あり)
プレイヤーコントロール入力変化(上入力あり→なし)
*lastControlChangedTicks[playerIndex, 1] = currentGameTick;
*if (lastControlChangedTicks[playerIndex, 2] + SHORT_TELEPORT_DOUBLE_TAP_TICK >; currentGameTick)*{
プレイヤーコントロール入力変化(下入力なし→あり)
プレイヤーコントロール入力変化(左入力あり→なし)
*lastControlChangedTicks[playerIndex, 2] = currentGameTick;
*if (lastControlChangedTicks[playerIndex, 3] + SHORT_TELEPORT_DOUBLE_TAP_TICK >; currentGameTick)*{
プレイヤーコントロール入力変化(右入力なし→あり)
プレイヤーコントロール入力変化(右入力あり→なし)
*lastControlChangedTicks[playerIndex, 3] = currentGameTick;
プレイヤー入力を記録(パケットが来るまで入力は変化しないため、リセット等は必要ない)
*lastPlayerControl[playerIndex, 0] = player.controlUp || player.controlJump;
*if (teleportOffset != Vector2.Zero)*{
移動距離が0以外の場合
*if (!isSSC)*{
サーバーサイドキャラクターではない場合、サーバーサイドキャラクターに一時的にする
*if (player.position.X >; Main.rightWorld - 992)*{
プレイヤーがワールド端に行き過ぎないように補正
クライアントにプレイヤー情報送信(事実上のテレポート)
*NetMessage.SendData((int)PacketTypes.PlayerUpdate, playerIndex, -1, null, playerIndex);
*if (!isSSC)*{
サーバーサイドキャラクターではなかった場合、元に戻す

WHERE句生成
*StringBuilder conditions = new StringBuilder("WHERE key IN (");
WHERE句生成
*StringBuilder conditions = new StringBuilder("WHERE key IN (");
*for(int i=keys.length; i >;= 0; i--)*{
降順でパラメータを追加

*{ "v|value=", "specify a value.", v =>; value = v },*// string型以外の引数を取るオプション
string型の引数を取るオプション
*{ "n|number=", "specify a number.", (int v) =>; number = v },*// 引数を取らないオプション
string型以外の引数を取るオプション
*{ "h|help", "show help.", v =>; help = v != null },
引数を取らないオプション

*return Gcd(b, a);
引数を入替えて自分を呼び出す
*private static void PrintNumber(int n) {Console.WriteLine(n.ToString());}
8桁の数が求められるたびに呼び出される。

*return 1000.0 * (double)sw.ElapsedTicks
(double)Stopwatch.Frequency;  処理時間

*GUILayout.EndHorizontal();
【サービスの行表示】 終了
Credential情報を貼り付けるテキストエリア
*m_PastedCredentials = EditorGUILayout.TextArea(m_PastedCredentials);
Credential情報を反映するApplyボタン
*GUI.SetNextControlName("Apply");
過去にCredential情報があれば削除する処理
*cfg.Credentials.Add(newInfo);
成功もしくは失敗のダイアログを表示
*SaveConfig();
実際の処理は省略
*}

*{return LastName == other.LastName;}
LastNameのみで等値性を評価
*{return LastName.GetHashCode();}
LastNameのみでハッシュ値を生成
*{}
具象クラスを定義する
LastNameでグループ化する（ここで「既定の等値比較子」を使用している）
*var groups = people.GroupBy(v =>; v);
*foreach (var g in groups)*{
グループ群を走査
*foreach (var v in g)*{
各インスタンスを走査
LastNameでグループ化する（ここで「既定の等値比較子」を使用している）
*var groups = people.GroupBy(v =>; (AVocaloid)v);
*{return obj is AVocaloid ? Equals((AVocaloid)obj) : base.Equals(obj);}
これを追加
*{return obj1.Equals(obj2);}
ついでに演算子も追加しておく

*}
df.Dispose() が呼ばれる

*var p = new Person ("太朗","山田");
引数をこれで指定
*public Person(string firstName,string lastName){this.FirstName = firstName;this.LastName = astName;}
コンストラクター（フィールドの初期値を明示）
*public Person () :this("權兵衞","名無し"){}
コンストラクター(引数を省略)

ディレクトリ名が入ったテキストファイルからディレクトリ情報を取得し、IEnumerable&lt;DirectoryInfo&gt;を生成
*var lines = File.ReadLines("FileName");
上で作成したディレクトリ情報集をもとに、ネストされたファイル情報集を生成する
このときnestedFilesの型はIEnumerable&lt;IEnumerable&lt;FileInfo&gt;&gt;である
*var nestedFiles = directories.Select(directory=>;directory.EnumerateFiles());
ディレクトリ名が入ったテキストファイルからディレクトリ情報を取得し、IEnumerable&lt;DirectoryInfo&gt;を生成
*var lines = File.ReadLines("FileName");
上で作成したディレクトリ情報集をもとに、ネストされたファイル情報集を生成する
このときnestedFilesの型はIEnumerable&lt;IEnumerable&lt;FileInfo&gt;&gt;である
*var nestedFiles = directories
ネストされたファイル情報集を平坦化する。
*var flatternFiles = nestedFiles.SelectMany(file=>;file);

抽出
*var row = rows.Where(x =>; x.name == "yamada");
1件抽出
*var row = rows.FirstOrDefault(x =>; x.id == 2);
全件に処理
*var row = rows.Select(x =>; x * x);
存在確認
*var row = rows.Any(x =>; x.id == 2);

空を飛ばないので、このメソッドでは何もしない
*}
歩かずに常に空を飛んで移動するので、このメソッドでは何もしない
*}

*Debug.Log(b[i]);
配列外アクセス

*string[] marks = new string[] { "ハート", "スペード", "クラブ", "ダイヤ" };
マーク
*string[] nos = new string[] { "A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K" };
数字
山札作成
*List<;string>; decks = new List<;string>;();
*decks.Add($"{mark}の{no}");
「ハートの5」、「スペードのJ」などの文字列が順番にdecksに代入される
カードを引く
*Random random = new Random();
*{// ......ここで条件分岐。1と11と12と13の場合、AとJとQとKを返却する}
①トランプの「数値」を使用して判定する
......ここで条件分岐。1と11と12と13の場合、AとJとQとKを返却する
*}
*{// ......ここで条件分岐。11と12と13の場合、ともに10を返却する}
①トランプの「数値」を使用して判定する
......ここで条件分岐。11と12と13の場合、ともに10を返却する
*}

*textField.EditingDidEnd += (sender, args) =<; { textField.Text = ""; };
これを追加
*//{//    plugin.Load();//}
public void Include(MvvmCross.Plugin.Json.Plugin plugin)

対象ページを読み込み
const string _targetUrl = "https:www.seiyu.co.jp/service/5off/";
*var config = Configuration.Default.WithDefaultLoader();
*{return new SaleDay{Month = int.TryParse(_.QuerySelector("span.off_calendar_month").InnerHtml.Replace("/", ""), out var month) ? month : 0,Day = int.TryParse(_.QuerySelector("span.off_calendar_day").InnerHtml, out var day) ? day : 0,};});
セールの月日を取得
年をまたぐかどうか
*var isExtendingYears = saleDays.Select(_ =>; _.Month).Distinct().All(_ =>; _ == 1 || _ == 12);
セールの年を設定して返す
（対象ページには年は表示されていないのでこちらで設定する）
*var currentYear = DateTime.Now.Year;
*public string UniqueId { get { return StartDateTime.ToString("yyyyMMdd"); } }
以下iCalendar用の項目
*{body.AppendLine("BEGIN:VCALENDAR");body.AppendLine($"PRODID:{ProdId}");body.AppendLine("VERSION:2.0");body.AppendLine("METHOD:PUBLISH");{body.AppendLine("BEGIN:VTIMEZONE");body.AppendLine("TZID:Asia/Tokyo");{body.AppendLine("BEGIN:STANDARD");body.AppendLine("DTSTART:19390101T000000");body.AppendLine("TZOFFSETFROM:+0900");body.AppendLine("TZOFFSETTO:+0900");body.AppendLine("TZNAME:JST");body.AppendLine("END:STANDARD");}body.AppendLine("END:VTIMEZONE");}// セール日をそれぞれイベントとして生成するforeach (var _ in saleDays){body.AppendLine("BEGIN:VEVENT");{body.AppendLine("CLASS:PUBLIC");body.AppendLine($"UID:{_.UniqueId}");body.AppendLine($"DTSTAMP:{timestamp}");body.AppendLine($"SUMMARY:{_.Summary}");body.AppendLine($"DESCRIPTION:{_.Description}");body.AppendLine($"DTSTART;VALUE=DATE:{_.StartDateTime:yyyyMMdd}");body.AppendLine($"DTEND;VALUE=DATE:{_.EndDateTime:yyyyMMdd}");}body.AppendLine("END:VEVENT");}body.AppendLine("END:VCALENDAR");}
http:www.asahi-net.or.jp/~ci5m-nmr/iCal/ref.html
*foreach (var _ in saleDays)*{
セール日をそれぞれイベントとして生成する
*{// セール日を取得var webScraper = new WebScraper();var saleDays = webScraper.GetSaleDaysAsync();saleDays.Wait();// iCal形式に変換var converter = new CalendarConverter();var calendar = converter.Convert(saleDays.Result);// API Gateway用のレスポンス形式に変換// ★ハマったポイント: Json文字列ではなく、オブジェクトを返すこと！var response = ToApiGatewayResponseAsync(calendar);response.Wait();return response.Result;}
★ハマったポイント: 戻り値はstringではなくクラス
セール日を取得
*var webScraper = new WebScraper();
iCal形式に変換
*var converter = new CalendarConverter();
API Gateway用のレスポンス形式に変換
★ハマったポイント: Json文字列ではなく、オブジェクトを返すこと！
*var response = ToApiGatewayResponseAsync(calendar);

*col.SendMessage ("Damage");
ダメージを与えて
自分は消える
*Destroy (this.gameObject);
*void Start () {myRect = GetComponent<;RectTransform>; ();}
Use this for initialization
*void Update () {myRect.LookAt (Camera.main.transform);}
Update is called once per frame

*var storageObject = storage.GetObject(bucketName, $"{path}/{fileName}");
Google Storage
キャッシュを無効にするように追加
*storageObject.CacheControl = "no-cache";

*tokenSource.Cancel();
Taskキャンセル

*var pinchMultiply = 0.001f;
適当に調整するなりしてください
*transform.localScale += (pinchDistanceDelta * pinchMultiply) * Vector3.one;*})
ピンチで拡大・縮小

*InitOnlyProperty = "baz",
OK

*values.Select(v =<; v * v);
結果：1, 4, 9, 16, 25

その1
*HttpPostedFileBase file = model.UploadFile;
その2
*string path = System.Web.Hosting.HostingEnvironment.MapPath(""C:/test/test/" + fileName);
その3
ファイルを読み込む
*}
取得したデータをDBに登録する処理
*}
*while (!reader.EndOfStream)*{
データを行単位で取得
*foreach (var row in table.DataRange.Rows()){*var cellList = row.Cells().ToList();
データを行単位で取得

ログイン処理例
*PlayGamesClientConfiguration config = new PlayGamesClientConfiguration.Builder()
*public void PressCloudSyncButton() {OpenSavedGame();}
バックアップボタンから呼ぶメソッド
*public void OpenSavedGame() {if (!hasInternetConnection) {Debug.Log("No Internet Connection");return;}if (!isAuthed) {Debug.Log("Not Authed");return;}isSaving = false;Debug.Log("Opening savedGame in the cloud");((PlayGamesPlatform)Social.Active).SavedGame.OpenWithAutomaticConflictResolution(saveFileName,DataSource.ReadCacheOrNetwork,ConflictResolutionStrategy.UseLongestPlaytime,OnSavedGameOpened);}
まずクラウド上のファイルをOPEN
*((PlayGamesPlatform)Social.Active).SavedGame.OpenWithAutomaticConflictResolution(*saveFileName,
first, open the file
*void OnSavedGameOpened(SavedGameRequestStatus status, ISavedGameMetadata gameMetadata) {if (status == SavedGameRequestStatus.Success) {openedSavedGame_commitDate = gameMetadata.LastModifiedTimestamp;currentOpenedSavedGameMetadata = gameMetadata;if (isSaving) {BuildBackupDate();byte[] data = ToBytes(saveString);var builder = new SavedGameMetadataUpdate.Builder();var updateMetadata = builder.WithUpdatedPlayedTime(GameController.statTotalBattleTime).WithUpdatedDescription("SAVED AT:" + DateTime.UtcNow.ToLocalTime().ToShortDateString()).Build();((PlayGamesPlatform)Social.Active).SavedGame.CommitUpdate(gameMetadata, updateMetadata, data, OnSavedGameWritten);} else {SAVEDGAME_STATUS stat = SAVEDGAME_STATUS.Default;if (gameMetadata.Description == null || gameMetadata.Description == "") {stat = SAVEDGAME_STATUS.NoData;}if (gameMetadata.TotalTimePlayed >; GameController.statTotalBattleTime) {stat = SAVEDGAME_STATUS.LongerPlaytime;} else {if (gameMetadata.TotalTimePlayed == GameController.statTotalBattleTime) {stat = SAVEDGAME_STATUS.Default;} else {stat = SAVEDGAME_STATUS.ShorterPlaytime;}}switch (stat) {case SAVEDGAME_STATUS.Default:Debug.Log("バックアップデータの更新は不要です");break;case SAVEDGAME_STATUS.NoData:case SAVEDGAME_STATUS.LongerPlaytime:case SAVEDGAME_STATUS.ShorterPlaytime:OpenDialog(stat);break;}}}}
OPENできたらwrite/readする
*void OpenDialog(SAVEDGAME_STATUS stts) {Debug.Log("OPEN DIALOG:" + stts);switch (stts) {default:break;case SAVEDGAME_STATUS.NoData:Debug.Log("バックアップデータがありません、バックアップしますか？");break;case SAVEDGAME_STATUS.ShorterPlaytime:Debug.Log("バックアップしますか？");break;case SAVEDGAME_STATUS.LongerPlaytime:Debug.Log("バックアップしたデータをロードしますか？");break;}}
ダイアログ表示,YES NOを選択すると対応するメソッドを呼ぶ。具体的な内容にはこの記事では触れない
バックアップしたいデータをここで代入する
*saveString = "(バックアップしたいデータ)";
*void DistributeLoadedData(byte[] dataFromCloud) {if (dataFromCloud == null) {Debug.Log("No data saved on the cloud yet");return;}Debug.Log("Decoding cloud data from bytes.");string stringFromCloud = FromBytes(dataFromCloud);if (stringFromCloud == "") {Debug.Log("No data saved on the cloud yet");return;}//データを反映するHogeHoge(SaveString);//念の為アプリを落とすQuitApp();}
ロードしたデータをゲームに反映する処理
データを反映する
*HogeHoge(SaveString);
念の為アプリを落とす
*QuitApp();

*OpenWithArguments(option);
メソッド呼び出し
*{Process cmd = new Process();cmd.StartInfo.FileName = "PowerShell.exe";//PowerShellのWindowを立ち上げずに実行。cmd.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;// 引数optionsをShellのコマンドとして渡す。cmd.StartInfo.Arguments = options;cmd.Start();}
PowerShellの実行メソッド（引数:PowerShellコマンド)
PowerShellのWindowを立ち上げずに実行。
*cmd.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
引数optionsをShellのコマンドとして渡す。
*cmd.StartInfo.Arguments = options;

*i
= 1024; GB

*foreach (var prime in primes)
&lt;- ここで例外が発生する

*{// ドロップされたファイルを順に確認するforeach (string file in (string[])e.Data.GetData(DataFormats.FileDrop)){// ファイルの拡張子を取得string extension = Path.GetExtension(file);// ファイルへのショートカットは拡張子".lnk"if (".lnk" == extension){IWshRuntimeLibrary.WshShell shell = new IWshRuntimeLibrary.WshShell();// ショートカットオブジェクトの取得IWshRuntimeLibrary.IWshShortcut shortcut = (IWshRuntimeLibrary.IWshShortcut)shell.CreateShortcut(file);// ショートカットのリンク先の取得string targetPath = shortcut.TargetPath.ToString();}}}
ドロップ時のイベント
*foreach (string file in (string[])e.Data.GetData(DataFormats.FileDrop))*{
ドロップされたファイルを順に確認する
ファイルの拡張子を取得
*string extension = Path.GetExtension(file);
*if (".lnk" == extension)*{
ファイルへのショートカットは拡張子".lnk"
ショートカットオブジェクトの取得
*IWshRuntimeLibrary.IWshShortcut shortcut = (IWshRuntimeLibrary.IWshShortcut)shell.CreateShortcut(file);
ショートカットのリンク先の取得
*string targetPath = shortcut.TargetPath.ToString();

*where T : Enum
コンパイルエラー

*Assert.Equal($"おはよう！{name}さん！", greeting);
Assert

*Console.WriteLine(src);
Point2D { X = 10, Y = 20 }

*void Start () {ClockText = GetComponentInChildren<;Text>;();}
Use this for initialization
*void Update () {ClockText.text = DateTime.Now.ToLongTimeString();}
Update is called once per frame
時、分を取得する（hh:mm (AM/PM)）
*ClockText.text = DateTime.Now.ToShortTimeString();
時、分、秒を取得する（hh:mm:ss (AM/PM)）
*ClockText.text = DateTime.Now.ToLongTimeString();
日付を取得する（MM/dd/yyyy）
*ClockText.text = DateTime.Now.ToShortTimeString();
日付を取得する（曜日,日付,yyyy）
*ClockText.text = DateTime.Now.ToLongTimeString();

パレットから色を取得
---------------------------------------------------
*public Color Get(string name)
ScriptableObject 作成
---------------------------------------------------
*[MenuItem("Tool/Create ColorPallet")]
カラーパレットからデータを取得
*var element = property.GetArrayElementAtIndex(ii);
ScriptableObject にデータを格納
*asset.list.Add(data);

*int fcount = 0;
0の数
*private bool NeedCount(bool[] line) {if (IsRound(line))// 左右対称ならば、他に鏡像となるパターンはないので、これは調べる必要がある。return true;// 左右対称でないならば、鏡像のパターンが他にもうひとつあるので、// 片方だけを調べるようにする。return ToInt(line.Reverse().ToArray()) >; ToInt(line);}
鏡像をカウントしないようにするための判定メソッド
左右対称ならば、他に鏡像となるパターンはないので、これは調べる必要がある。
*return true;
左右対称でないならば、鏡像のパターンが他にもうひとつあるので、
片方だけを調べるようにする。
*return ToInt(line.Reverse().ToArray()) >; ToInt(line);
*private bool IsRound(bool[] line) {int j = line.Length - 1;int i = 0;while (i <; j) {if (line[i++] != line[j--]) {return false;}}return true;}
ビットパターンが左右対称かどうかを調べる
*private int ToInt(bool[] line) {return line.Aggregate(0, (r, b) =>; r * 2 + (b ? 1 : 0));}
bool[]をビットパターンとみなし、intに変換する
*public bool[] ToArray(int n, int width) {var array = new bool[width];int mask = 1;width.Times(i =>; {array[i] = (n &amp; mask) != 0;mask <;<;= 1;});return array;}
整数nを width個からなるbool配列に変換する
*private bool[] NextLine(bool[] line) {var next = new bool[line.Length - 1];int i = 0;// ここで、Aggregateを使うのは邪道かな？line.Aggregate((a, b) =>; {next[i++] = a ^ b;return b;});return next;}
1段下のラインを排他的論理和を使い求める
*line.Aggregate((a, b) =>; {next[i++] = a ^ b;return b;});
ここで、Aggregateを使うのは邪道かな？
*public static void ForEach<;T>;(this IEnumerable<;T>; source, Action<;T>; action) {foreach (var x in source) {action(x);}}
要素の数だけ、actionを呼び出す
*public static void Times(this int count, Action<;int>; action) {for (int i = 0; i <; count; i++)action(i);}
n回、actionを呼び出す

(1)コールバック関数なしでボタンを登録する
*builder.SetPositiveButton("OK", (EventHandler<;DialogClickEventArgs>;)null);
*public void OnShow(IDialogInterface dialog){// ダイアログが表示された後でないとButtonを取得できないvar okButton = dialog_.GetButton((int)Android.Content.DialogButtonType.Positive);okButton.Click += OkEventHandler;}
(2)ダイアログが表示された時にボタンにコールバックを割当てる
ダイアログが表示された後でないとButtonを取得できない
*var okButton = dialog_.GetButton((int)Android.Content.DialogButtonType.Positive);
*private void OkEventHandler(object sender, EventArgs args){// (3)条件を満たした場合はDismiss()でダイアログを閉じるif(is_satisfy_close_condition())dialog_.Dismiss();}
OKボタンが押されたとき
*if(is_satisfy_close_condition())*dialog_.Dismiss();
(3)条件を満たした場合はDismiss()でダイアログを閉じる

*: dotCount
2;                           一辺の要素数が偶数の時
行列の左半分にランダムにドットを打つ
*matrix[row, col] = random.Next( 0, 2 ) == 1 ? true : false;
行列の右半分にコピー
*matrix[row, ( dotCount - 1 ) - col] = matrix[row, col];
*foreach ( var info in typeof( Color ).GetProperties( BindingFlags.Public | BindingFlags.Static ) )*{
Color構造体から定義済みの色をぶっこ抜く
ドットパターンをランダムに生成
*var dotPattern = CreateSymmetricalDotPatternRandomly( COUNT_DOT, random );
*var foreColor = GetColorRandomly( random );*var backGroundColor = CreateInvertedColor( foreColor );
前景色・背景色を生成
アイデンティコンを描画
*var image = new Bitmap( pictureBox.ClientSize.Width, pictureBox.ClientSize.Height );

*CollectionAssert.AreEquivalent(new string[] { "A", "B", }, new string[] { "B", "A", });
AreEquivalentは順不同
*CollectionAssert.IsSubsetOf(new string[] { "C", "B", }, new string[] { "A", "B", "C", });
IsSubsetOfは順不同

*return this.data;
thisで、フィールドのdataにアクセスし、値を返す。

Gridへのデータソースを設定
*xamDataGrid.DataSource = datas;
*{ItemsSource = datas,ConnectionSettings = new FlatDataConnectionSettings(){ ItemsSource = datas}};
Pivotに対するデータソースを設定
サンプルデータを設定
*SettingDatas<;SampleData>;(datas);

*string reqUrl = $"https:
chart.googleapis.comchart?cht=qr&amp;chl={urlEnc}&amp;chs=300x300&amp;chld=H|1";

*<; d.ToString("ggyy年MM月dd日", cul)
ToStringの方が記述量は少ない

デフォルトのテンプレートでは下の関数が書かれているが
public string FunctionHandler(string input, ILambdaContext context)
オーバロードしたこちらの関数を使ったほうが、色々幸せになる
*public string FunctionHandler(ILambdaContext context)
*var name = $"山本一成{weather}Ponanza";
OpenWeatherMapAPIから天気を取得して対応するEmojiを返す
*return $"{DateTime.Now}:{name}";
TwitterAPIを経由してnameに変更する
お昼かどうかの可能判定
*}
日の出日の入り時刻は最大でも一日で一分程度しかズレないのでほぼ問題ない。
*}

*{using (var uploadResponse = await client.GetAsync(pdfUrl)){// URL先からストリームを取得var temp = await uploadResponse.Content.ReadAsStreamAsync();if (temp.AsRandomAccessStream().Size == 0){var err = new TextBlock();err.Text = "PDFファイルを読み込めませんでした。";this.listView.Items.Add(err);return;}// 一時ファイルストリームをPDFドキュメントとしてパースpdfDoc = await PdfDocument.LoadFromStreamAsync(temp.AsRandomAccessStream());// PDFを1ページずつ画像に変換し、リストビューに挿入for (uint i = 0; i <; pdfDoc.PageCount; i++){PdfPage page = pdfDoc.GetPage(i);var stream = new InMemoryRandomAccessStream();await page.RenderToStreamAsync(stream);var image = new BitmapImage();await image.SetSourceAsync(stream);var img = new Image();img.Source = image;this.listView.Items.Add(img);}}}
HTTPクライアントを生成
URL先からストリームを取得
*var temp = await uploadResponse.Content.ReadAsStreamAsync();
一時ファイルストリームをPDFドキュメントとしてパース
*pdfDoc = await PdfDocument.LoadFromStreamAsync(temp.AsRandomAccessStream());
*for (uint i = 0; i <; pdfDoc.PageCount; i++)*{
PDFを1ページずつ画像に変換し、リストビューに挿入
*{using (var uploadResponse = await client.GetAsync(pdfUrl)){// URL先からストリームを取得var temp = await uploadResponse.Content.ReadAsStreamAsync();・・・}}
HTTPクライアントを生成
URL先からストリームを取得
*var temp = await uploadResponse.Content.ReadAsStreamAsync();
一時ファイルストリームをPDFドキュメントとしてパース
*pdfDoc = await PdfDocument.LoadFromStreamAsync(temp.AsRandomAccessStream());
*for (uint i = 0; i <; pdfDoc.PageCount; i++)*{
PDFを1ページずつ画像に変換し、リストビューに挿入

*{//メッセージボックスを出力するMessageBox.Show("お使いのパソコンは正常ではありません","DANGER!!",MessageBoxButton.OK, MessageBoxImage.Error);//メッセージボックスを閉じた後指定のアドレスにジャンプするSystem.Diagnostics.Process.Start("http://www.google.com");Close();}
ボタンクリックでイベント発生
メッセージボックスを出力する
*MessageBox.Show("お使いのパソコンは正常ではありません",
メッセージボックスを閉じた後指定のアドレスにジャンプする
System.Diagnostics.Process.Start("http:www.google.com");
*Close();

リクエストパラメータの定義
service(DriveService)はユーザ認証部分なので割愛
*FilesResource.ListRequest listRequest = DriveService.service.Files.List();
Google Slidesのみ取得する
*listRequest.Q = "mimeType = 'application/vnd.google-apps.presentation'";
ファイル一覧の取得
*IList<;Google.Apis.Drive.v3.Data.File>; files = listRequest.Execute().Files;
例えば一番最初にとれたファイルをダウンロードする
*var id = files.First().Id;
保存するファイル先を指定する
*string saveTo = /*ファイル先*/;
例えばGoogle SlidesをPDF形式でダウンロードする
*var request = DriveService.service.Files.Export(id, "application/pdf");

*var prefix = "folder1
folder2samp";    ファイル名の中間一致
var prefix = "folder1/fol";           フォルダ名の中間一致でもOK
*GetList(containerName, prefix);

*void Start () {//Playerタグのつけ忘れに注意！player = GameObject.FindGameObjectWithTag("Player").transform;//見つからない場合は自身を設定if(player == null){player = transform;}}
Use this for initialization
*player = GameObject.FindGameObjectWithTag("Player").transform;*//見つからない場合は自身を設定
Playerタグのつけ忘れに注意！
*if(player == null){*player = transform;
見つからない場合は自身を設定
*void Update () {float vertical = Input.GetAxis("Vertical");float horizontal = Input.GetAxis("Horizontal");//アナログスティックのグラつきを想定して±0.01以下をはじくif(Mathf.Abs(horizontal) + Mathf.Abs(vertical) >; 0.1F){//カメラからみたプレイヤーの方向ベクトルVector3 camToPlayer = player.position - Camera.main.transform.position;// π/2 - atan2(x,y) == atan2(y,x)float inputAngle = Mathf.Atan2(horizontal,vertical) * Mathf.Rad2Deg;float cameraAngle = Mathf.Atan2(camToPlayer.x,camToPlayer.z) * Mathf.Rad2Deg;Quaternion targetRotation = Quaternion.Euler(0, inputAngle + cameraAngle, 0);//deltaTimeを用いることで常に一定の速度になるplayer.rotation = Quaternion.Slerp(player.rotation, targetRotation, Time.deltaTime * rotateSpeed);}}
Update is called once per frame
*if(Mathf.Abs(horizontal) + Mathf.Abs(vertical) >; 0.1F){*//カメラからみたプレイヤーの方向ベクトル
アナログスティックのグラつきを想定して±0.01以下をはじく
*Vector3 camToPlayer = player.position - Camera.main.transform.position;*// π/2 - atan2(x,y) == atan2(y,x)
カメラからみたプレイヤーの方向ベクトル
deltaTimeを用いることで常に一定の速度になる
*player.rotation = Quaternion.Slerp(player.rotation, targetRotation, Time.deltaTime * rotateSpeed);
*void Start () {//Playerタグのつけ忘れに注意！player = GameObject.FindGameObjectWithTag("Player").transform;//見つからない場合は自身を設定if(player == null){player = transform;}}
Use this for initialization
*player = GameObject.FindGameObjectWithTag("Player").transform;*//見つからない場合は自身を設定
Playerタグのつけ忘れに注意！
*if(player == null){*player = transform;
見つからない場合は自身を設定
*void Update () {float vertical = Input.GetAxis("Vertical");float horizontal = Input.GetAxis("Horizontal");//アナログスティックのグラつきを想定して±0.01以下をはじくif(Mathf.Abs(horizontal) + Mathf.Abs(vertical) >; 0.1F){//カメラからみたプレイヤーの方向ベクトルVector3 camToPlayer = player.position - Camera.main.transform.position;// π/2 - atan2(x,y) == atan2(y,x)float inputAngle = Mathf.Atan2(horizontal,vertical) * Mathf.Rad2Deg;float cameraAngle = Mathf.Atan2(camToPlayer.x,camToPlayer.z) * Mathf.Rad2Deg;Quaternion targetRotation = Quaternion.Euler(0, inputAngle + cameraAngle, 0);//deltaTimeを用いることで常に一定の速度になるplayer.rotation = Quaternion.Slerp(player.rotation, targetRotation, Time.deltaTime * rotateSpeed);}}
Update is called once per frame
*if(Mathf.Abs(horizontal) + Mathf.Abs(vertical) >; 0.1F){*//カメラからみたプレイヤーの方向ベクトル
アナログスティックのグラつきを想定して±0.01以下をはじく
*Vector3 camToPlayer = player.position - Camera.main.transform.position;*// π/2 - atan2(x,y) == atan2(y,x)
カメラからみたプレイヤーの方向ベクトル
deltaTimeを用いることで常に一定の速度になる
*player.rotation = Quaternion.Slerp(player.rotation, targetRotation, Time.deltaTime * rotateSpeed);

*Console.WriteLine(x =<; x * x);
-&gt; 16

*sw.WriteLine("<;gpx creator=\"GenericScript\" version=\"1.1\" xmlns=\"http:
www.topografix.comGPX11\" xmlns:xsi=\"http:www.w3.org2001XMLSchema-instance\" xsi:schemaLocation=\"http:www.topografix.comGPX11 http:www.topografix.comGPX11gpx.xsd\"&gt;");
*for (int i = 0; i <; gpxInfoList.Count; i++)*{
Loop Process

xはインスペクタ上のUV RectのXです、y,w,hも以下同文
*}

キャッシュに無かったら、リフレクションを用いて取得、キャッシュへの追加をして返す
*return EnumAttributeCache<;TAttribute>;.GetOrAdd(enumKey, _ =>; enumKey.GetAttributeCore<;TAttribute>;());
リフレクションを用いて列挙体の型から情報を取得
*var fieldInfo = enumKey.GetType().GetField(enumKey.ToString());
指定した属性のリスト
*var attributes
*if ((attributes?.Count() ?? 0) <;= 0)*return null;
属性がなかった場合、nullを返す
同じ属性が複数含まれていても、最初のみ返す
*return attributes.First();

Unityスクリプトリファレンス/CharacterController.Moveより
https:docs.unity3d.com/ja/current/ScriptReference/CharacterController.Move.html
*using UnityEngine;
*public class MyCharacterController : MonoBehaviour {public float speed = 6.0F;public float jumpSpeed = 8.0F;public float gravity = 20.0F;private Vector3 moveDirection = Vector3.zero;void Update() {CharacterController controller = GetComponent<;CharacterController>;();if (controller.isGrounded) {moveDirection = new Vector3(Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical"));moveDirection = transform.TransformDirection(moveDirection);moveDirection *= speed;if (Input.GetButton("Jump"))moveDirection.y = jumpSpeed;}moveDirection.y -= gravity * Time.deltaTime;controller.Move(moveDirection * Time.deltaTime);}}
クラス名はファイル名に一致させる

*temp = char.ToUpper(name[0]) + name.Substring(1).ToLower();
"Erasermotorphantom"
先頭から5文字抜き出す　abcde
*temp = hoge.Substring(0, 5);
5文字スキップし、6文字目から2文字取得　fg
*temp = hoge.Substring(5, 2);
22文字スキップし、それ以降の文字列を取得する　wxyz
*temp = hoge.Substring(22);
文字列中の"hoge"を"piyo"に置換 piyopiyoになる
*temp = hoge.Replace("hoge", "piyo");
文字列中から"piyo"を削除 hogeになる
*temp = hoge.Replace("piyo", "");
Joinで一発。for文で最後の要素以外にコンマを追加とかしなくていい
*string line = string.Join(",", elements);
一行をコンマで区切って配列に入れる。
*string[] splitStr = line.Split(',');

*Console.WriteLine(p.Show());
ParsonクラスのなかのShowメソッドが呼び出される。

*{using (FileStream fs = File.OpenRead(filePath)) { }return true;}
File.Exists()で存在するとなっても、実際は存在しないことがあるので再チェック

現在時刻取得
*DateTime dt = DateTime.Now;
入力したリセットまでの時間
*int resetTime = int.Parse(txtReset.Text);
呼びだされたchboxとリセットの時刻を保持
*ChTimeList.Add(((CheckBox)(sender)), dt.AddSeconds(resetTime));
1秒周期でメソッド実行
*timer.Tick += new EventHandler(chReset);
*{List<;CheckBox>; removeList = new List<;CheckBox>;();//Dictionaryの要素がなければ何もしないif (ChTimeList.Count == 0){return;}foreach (KeyValuePair<;CheckBox, DateTime>; a in ChTimeList){//要素が今の時間より過去ならリセットif (DateTime.Compare(a.Value, DateTime.Now) <; 0){a.Key.Checked = false;removeList.Add(a.Key);}}//削除リストforeach (CheckBox ch in removeList){CHandTIME.Remove(ch);}timer.Stop();}
chリセット処理
*if (ChTimeList.Count == 0)*{
Dictionaryの要素がなければ何もしない
*if (DateTime.Compare(a.Value, DateTime.Now) <; 0)*{
要素が今の時間より過去ならリセット
*foreach (CheckBox ch in removeList)*{
削除リスト

*chrRewriter.Add(nameof(dmyAge), nameof(Character.YearsOld));
chrRewriter.Add("dmyAge", "YearsOld");
クエリのすり替え
*var usrWhere = usrRewriter.Rewrite(p =>; dmyLevel <; 10 &amp;&amp; dmyAge >; 16);
*{ctx.Database.Log = Console.WriteLine;var usrItems = ctx.Users.Where(usrWhere).ToList();var chrItems = ctx.Characters.Where(chrWhere).ToList();}
実際にＤＢアクセス
ダミー変数の定義
*var dmyLevel = 0;
*{ctx.Database.Log = Console.WriteLine;var usrItems = GetEntities<;User>;(ctx, 10, 16, nameof(User.Level), nameof(User.Age)).ToList();var chrItems = GetEntities<;Character>;(ctx, 10, 16, nameof(Character.Power), nameof(Character.YearsOld)).ToList();}
実際にＤＢアクセス
ダミー変数の定義
*var dmyLevel = 0;
*{ctx.Database.Log = Console.WriteLine;var usrItems = GetEntities<;User>;(ctx, 10, 16, nameof(User.Level), nameof(User.Age)).ToList();var chrItems = GetEntities<;Character>;(ctx, 10, 16, nameof(Character.Power), nameof(Character.YearsOld)).ToList();}
実際にＤＢアクセス
*{IQueryable<;TEntity>; query = Context.Set<;TEntity>;();foreach (var f in filters){query = query.Where(this.Rewriter.Rewrite(f));}return query;}
コメントを参考にさせていただきました。さらにRewriter適用バージョンです。
*{return this.GetEntities(p =>; DmyLevel >;= 20 &amp;&amp; DmyAge >;= 20);}
つよーい人を取得(レベル20以上、二十歳以上)
*{return this.GetEntities(p =>; DmyLevel >;= level &amp;&amp; DmyAge >;= age);}
level以上、かつage以上の一覧を取得します。
つぉーい人取得
*var usrItems = usr.GetPowerful().ToList();
引数付き、レベル、年齢共に10以上取得
*var grt = chr.GetGreaterOrEqual(10, 10).ToList();
インターフェースに拘るとダミー変数をどこに置くかが新たな課題。ローカル変数である必要は無さそう。
*int DmyLevel = 0, DmyAge = 0;
Userをパワーアップ
*PowerUp(usr, new UserAccessor());
Characterをパワーアップ
*PowerUp(chr, new CharacterAccessor());
パワーアップの処理を反映・・・　しないでおく。
ctx.SaveChanges();
*}

*Console.WriteLine(TodaysNikkei(DateTime.Today, 23456.7));
参照したメソッドを呼び出す
*Action hello = () =>; { Console.WriteLine("Hello, World!!"); };
例１
*Func<;int, int>; add = (n) =>; { return n + 1; };
例２
*Func<;DateTime, double, string>; TodaysNikkei = (dt, price) =>; { return dt.ToShortDateString() + " の日経平均株価終値は" + price.ToString() + "円です。"; };
例３
受験者全員の数学の平均点を求めたい
*double mathAve = CalcMathAverage(results, tr =>; tr.Math);
受験者全員の数学の平均点を求めたい
*double mathAve = CalcAverage(results, tr =>; tr.Math);
受験者全員の数学の平均点を求めたい
*double mathAve = ListUtil.CalcAverage(results, tr =>; tr.Math);
受験者全員の数学の平均点を求めたい
*double mathAve = results.CalcAverage(tr =>; tr.Math);
受験者全員の数学の平均点を求めたい
*double mathAve = results.CalcAverage(tr =>; tr.Math);

*public string GetArgumentNullException() {throw new ArgumentNullException("ArgumentNullException");}
GET api/values/ArgumentNullException
*public string GetAPIException() {throw new APIException(HttpStatusCode.BadRequest, "Your exception message");}
GET api/values/APIException

*Console.WriteLine($"exist value = {sourceDict.GetOrAdd("A", 10000)}");
これのみDictionaryが変化しない
Dictionaryを別のDictionaryに変換（値コピー）
*var copiedDict = sourceDict.ToDictionary();
元のDictionaryを変更しても、コピー先には反映されない
*copiedDict["A"] = 100;
LINQで加工したものもDictionaryにできる
*var filterdDict = sourceDict.Where(x =>; x.Key == "A").ToDictionary();
実行時エラー　複数のKeyに同じValueがあった場合、入れ替えるとKeyが重複してしまう
sourceDict["B"] = 10;
flipedDict = sourceDict.FlipKeyValue();
*,,,
2つのDictionaryを合流、Keyが重複していたら、先のDictionaryのValueが使用される
*var mergedDict = sourceDict.Merge(secondDict).ToDictionary();

NOTE: 起動にはそこそこ時間がかかる
*_driver = new ChromeDriver(path);
起動後は好きなようにChromeを操作できる
_driver.Navigate().GoToUrl("http:yahoo.co.jp");
*}

Coroutineを中断するために変数として宣言しておく
*Coroutine _Coroutine;
スクロールスピード
*[SerializeField]float ScrollSpeed = 0.2f;
*{if (_Coroutine != null) {StopCoroutine (_Coroutine);}_Coroutine = StartCoroutine (TimeForScrollLeft ());}
LeftButtonに登録
*{if (_Coroutine != null) {StopCoroutine (_Coroutine);}_Coroutine = StartCoroutine (TimeForScrollLeft (300f));}
LeftestButtonに登録
*{while (_Scrollbar.value >; 0) {_Scrollbar.value -= Time.deltaTime * ScrollSpeed * SpeedRate;yield return null;}}
左スクロールコルーチン
*{if (_Coroutine != null) {StopCoroutine (_Coroutine);}_Coroutine = StartCoroutine (TimeForScrollRight ());}
Rightボタンに登録
*{if (_Coroutine != null) {StopCoroutine (_Coroutine);}_Coroutine = StartCoroutine (TimeForScrollRight (300f));}
RightestButtonに登録
*{while (_Scrollbar.value <; 1) {_Scrollbar.value += Time.deltaTime * ScrollSpeed * SpeedRate;yield return null;}}
右スクロールコルーチン
*{if (_Coroutine != null) {StopCoroutine (_Coroutine);}}
EventTriggerのPointerUpイベントに登録する処理

soap1.1を使いたい場合は、第二引数にBasicHttpBindingをnewすればOK
*var transportBinding = new HttpTransportBindingElement();
*{app.UseWhen(ctx =>; ctx.Request.Headers.ContainsKey("SOAPAction"), app2 =>;{app2.UseSoapEndpoint<;TestService>;("/Service.svc", new BasicHttpBinding(), SoapSerializer.DataContractSerializer);});app.UseWhen(ctx =>; !ctx.Request.Headers.ContainsKey("SOAPAction"), app2 =>;{var transportBinding = new HttpTransportBindingElement();var textEncodingBinding = new TextMessageEncodingBindingElement(MessageVersion.Soap12WSAddressing10, System.Text.Encoding.UTF8);app2.UseSoapEndpoint<;TestService>;("/Service.svc", new CustomBinding(transportBinding, textEncodingBinding), SoapSerializer.DataContractSerializer);});}
using System.ServiceModel.Channels;

今回は実際のレスポンスではなくJSONデータのロードで検証
*var json = Resources.Load<;TextAsset>;("sample").ToString();
各Valueをログに吐き出す
*Debug.Log(data.detectedLanguage.language);
配列をラップ
*[Serializable]
TranslateDataが新たにルートになる
*[Serializable]
レスポンスのルートをここに入れる
*public Root[] root;
*var json = "{" + $"\"root\":{rawJson}" + "}";
今回は実際のレスポンスではなくJSONデータのロードで検証
各Valueをログに吐き出す
*Debug.Log(data.root[0].translations[0].text);
今回は実際のレスポンスではなくJSONデータのロードで検証
*var rawJson = Resources.Load<;TextAsset>;("sample").ToString();
各Valueをログに吐き出す
*Debug.Log(data.translations[0].text);

子Elementを再帰的に探索してIExpressionを生成する
*var expressions =

*draw = true;
衝突したらその先の放物線は表示しない
*if (hitTime != float.MaxValue)*{
マーカーの表示
*for (int i = 0; i <; lineRenderers.Length; i++)*{
放物線とマーカーを表示しない
親オブジェクトを作り、LineRendererを持つ子オブジェクトを作る
*GameObject arcObjectsParent = new GameObject("ArcObject");
光源関連を使用しない
*lineRenderers[i].receiveShadows = false;
線の幅とマテリアル
*lineRenderers[i].material = arcMaterial;
Linecastする線分の始終点の座標
*Vector3 startPosition = GetArcPositionAtTime(startTime);
衝突判定
*RaycastHit hitInfo;
衝突したColliderまでの距離から実際の衝突時間を算出
*float distance = Vector3.Distance(startPosition, endPosition);
*shootVelocity = barrelObject.transform.up * speed;*// 弾の生成座標を更新
弾の初速度を更新
*instantiatePosition = barrelObject.transform.position;*// 発射
弾の生成座標を更新
*if (Input.GetKeyDown(KeyCode.Space))*{
発射
弾を生成して飛ばす
*GameObject obj = Instantiate(bulletPrefab, instantiatePosition, Quaternion.identity);
5秒後に消える
*Destroy(obj, 5.0F);

ここと
*public static SimpleMessage Msg = new SimpleMessage();
ここのようなthis.～からthis.を外します
public void AddMessage内の処理ですが、
これをpublic static bool jusin内へ移動します
*MessageList.Add(msg);
AddMessageメソッドを引数なしのRePaintメソッドに変更して、
jusinメソッドの呼び出しも修正します
*myIns.RePaint();
*{// 手動での更新通知this.StateHasChanged();}
また、RePaintメソッドは以下のようにシンプルにします
手動での更新通知
*this.StateHasChanged();
usingの追加（一回だけなので書かなくてもおｋです）
*@using Microsoft.AspNetCore.Blazor.Browser.Services;
*url = $"{url}{(url.EndsWith("/") ? "index" : string.Empty)}";
OnInit内に記述

*if (this.owningThreadId != -1 &amp;&amp; this.owningThreadId != Thread.CurrentThread.ManagedThreadId)*{
way to detect cross-thread access is to do it in the Durable Task Framework directly.

*if (IsPopssible()) {
この判定は、速度アップのため （不要な探索は行わないようにする）
引き算をして得られた数が、baseLineにある数と同じならばダメ。
*var q = from n in _baseLine

*Console.WriteLine(dt1 == dt2);
→ True
→ 2018/01/02 午後 12:23:45
*Console.WriteLine(dt.ToString("yyyy/MM/dd HH:mm:ss"));

*Console.WriteLine($"{num2:00000}");
"00123"

*using UnityEngine.UI;
UI弄るときに必須
*{}
Start is called before the first frame update
*{countTime += Time.deltaTime * speed;if (countTime >; commandlist.Length){countTime = 0f;}if (lastTime != (int)countTime){foreach (var command in commandlist){command.color = new Color(1, 1, 1);}lastTime = (int)countTime;commandlist[(int)countTime].color = new Color(1, 0, 0);}if (Input.GetKeyDown(KeyCode.Space)){speed = 0;}}
Update is called once per frame
*{}
Start is called before the first frame update
*{countTime += Time.deltaTime * speed;if (countTime >; commandlist.Length){countTime = 0f;}if (lastTime != (int)countTime){foreach (var command in commandlist){command.color = new Color(1, 1, 1);}lastTime = (int)countTime;commandlist[(int)countTime].color = new Color(1, 0, 0);}if (Input.GetKeyDown(KeyCode.Space)){speed = 0;//ここで(int)countTimeを他スクリプトに送信}}
Update is called once per frame
ここで(int)countTimeを他スクリプトに送信
*}
*{}
Start is called before the first frame update
*{//タイマーAcountTime += Time.deltaTime * speed;if (countTime >; commandlist.Length){countTime = 0f;}//タイマーBfireTime += Time.deltaTime;if (lastTime != (int)countTime){fireTime = 0f;foreach (var command in commandlist){command.color = new Color(1, 1, 1);}lastTime = (int)countTime;commandlist[(int)countTime].color = new Color(1, 0, 0);}if (Input.GetKeyDown(KeyCode.Space)){isStop = true;lottery = Random.Range(990, 997) * 0.001f;}if (isStop){speed *= lottery;}if (fireTime >;= 2.5 &amp;&amp; justOnce){fireTime = 0;justOnce = false;//(int)countTimeを他スクリプトに送信}}
Update is called once per frame
タイマーA
*countTime += Time.deltaTime * speed;
タイマーB
*fireTime += Time.deltaTime;
(int)countTimeを他スクリプトに送信
*}

*log.Info($"JSON to response: {responseJSON}");
Create JSON to return

*public float forceStrength;
打ち出す力の強さ
*if(Input.GetKeyDown(KeyCode.Space)){*GameObject g = Instantiate(ammunition, port.transform.position, port.transform.rotation);
砲弾を複製して打ち出す処理
*if(Input.GetKey(KeyCode.RightArrow)){*transform.Rotate(0,0,-1);
左右回転処理

現在編集中のシーンを保存する
*EditorSceneManager.SaveOpenScenes();
処理後にシーン状態を戻すために現在のシーン一覧を記録しておく
*string[] openingScenePaths = Enumerable.Range(0, openingSceneCount)
保存されていないシーンは取り除く
*.Where(s =>; !string.IsNullOrEmpty(s.path))
既に開かれているシーンを再度開こうとすると処理が止まるので、新規シーンのみにする
*EditorSceneManager.NewScene(NewSceneSetup.EmptyScene, NewSceneMode.Single);
編集前のシーン状態に戻す
*EditorSceneManager.NewScene(NewSceneSetup.EmptyScene, NewSceneMode.Single);
*if (original != null)*PrefabUtility.DisconnectPrefabInstance(obj);
スクリプトによる変更を有効にするためにPrefabとのリンクを切る
*if (original != null)*PrefabUtility.ConnectGameObjectToPrefab(root, original);
Prefabとのリンクを再接続
UnityにSceneの変更を通知する（通知しないと保存されない）
*EditorSceneManager.MarkAllScenesDirty();
UnityにComponentの変更を通知する（通知しないと保存されない）
*EditorUtility.SetDirty(component);

*private bool disposedValue = false;
重複する呼び出しを検出するには
TODO: マネージ状態を破棄します (マネージ オブジェクト)。
*}
TODO: アンマネージ リソース (アンマネージ オブジェクト) を解放し、下のファイナライザーをオーバーライドします。
TODO: 大きなフィールドを null に設定します。
*disposedValue = true;
*// ~MyDisposableClass() {//   // このコードを変更しないでください。クリーンアップ コードを上の Dispose(bool disposing) に記述します。//   Dispose(false);// }
TODO: 上の Dispose(bool disposing) にアンマネージ リソースを解放するコードが含まれる場合にのみ、ファイナライザーをオーバーライドします。
このコードを変更しないでください。クリーンアップ コードを上の Dispose(bool disposing) に記述します。
Dispose(false);
}
このコードは、破棄可能なパターンを正しく実装できるように追加されました。
*public void Dispose()
このコードを変更しないでください。クリーンアップ コードを上の Dispose(bool disposing) に記述します。
*Dispose(true);
TODO: 上のファイナライザーがオーバーライドされる場合は、次の行のコメントを解除してください。
GC.SuppressFinalize(this);
*}

*for(var i = 0; i <; 2000000000; i++)*{
20億回ボクシングが発生
*for (var i = 0; i <; 2000000000; i++)*{
こちらはそのままint型へ値型を代入

描画用の Visual を用意
*var visual = new DrawingVisual();

*const string webHookUrl = "https:
hooks.slack.comservicesXXX...";

*Console.WriteLine($"{p1.LastName}{p1.FirstName}");
$は{}内の指示語展開のスイッチ（C#6で搭載）

1. 読み込み中の表示を始める
*ShowLoader(
*{// 3. masterデータを元に3Dモデルを読むLoad3DModel(res, () =>;{// 4. userデータとマップデータを同時に読むLoadUserDataAndMapData(() =>;{// 5. 読み込み中の表示を終了するHideLoader(onEnd);});});});
2. masterデータを読む
*{// 4. userデータとマップデータを同時に読むLoadUserDataAndMapData(() =>;{// 5. 読み込み中の表示を終了するHideLoader(onEnd);});});
3. masterデータを元に3Dモデルを読む
*{// 5. 読み込み中の表示を終了するHideLoader(onEnd);});
4. userデータとマップデータを同時に読む
5. 読み込み中の表示を終了する
*HideLoader(onEnd);
... ユーザーデータとマップデータを同時に読む処理。両方終わったらcallback実行
*}
1. 読み込み中の表示を始める
*await ShowLoaderAsync();
2. masterデータを読む
*int res = await LoadMasterDataAsync();
3. masterデータを元に3Dモデルを読む
*await Load3DModelAsync(res);
*await Task.WhenAll(new Task[]{LoadUserDataAsync(), LoadMapDataAsync()});
4. userデータとマップデータを同時に読む
5. 読み込み中の表示を終了する
*await HideLoaderAsync();
1フレーム経過している
*UnityEngine.Debug.Log("Coroutine after: " + Time.frameCount);
*{yield return null;};
NG. deleagte内ではyield return出来ない
*{var tcs = new TaskCompletionSource<;bool>;();TweenCallback callback = null;callback = () =>;{tweener.onComplete -= callback;tcs.SetResult(true);};tweener.onComplete += callback;return tcs.Task.GetAwaiter();}
TweenerをAwaitableにする
*{var tcs = new TaskCompletionSource<;bool>;();TweenCallback callback = null;callback = () =>;{seq.onComplete -= callback;tcs.SetResult(true);};seq.onComplete += callback;return tcs.Task.GetAwaiter();}
SequenceをAwaitableにする
*{Image img = null;img.gameObject.SetActive(true);}
log出ない例
*{Image img = null;img.gameObject.SetActive(true);}
log出る

Textboxにアクセスするので、UIスレッド上で購読
*.ObserveOn(this.Dispatcher)
OnNextは流れてきた文字をそのままTextboxに書き足す
*x =>; this.textBox.Text += x,
CompleteしたらリソースからAAを取得してTextboxに書き足す
*() =>; textBox.Text += Properties.Resources.Take);
10msecごとに
*.Interval(TimeSpan.FromMilliseconds(10))
ランダムに「ポ」「プ」「テ」「ピピック」のどれか
*.Select(_ =>; pops[random.Next(maxCount)]);
※テスト用　最初がいきなり「ポプテピピック」になる
.Select(i =&gt; pops[i % maxCount]);
バッファを空白で埋めておく (["","","","",""])
*return Observable.Repeat("", maxCount)
最後の「ピピック」をOnNextに流すために1つ余分にBufferをもつ
*.Buffer(maxCount + 1, 1)
Bufferの前が「ポプテピピック」に一致する状態(["ポ","プ","テ","ピピック",*])になるまで続行
*.TakeWhile(x =>; !x.Take(maxCount).SequenceEqual(pops))
Bufferの最後をOnNextに流す  ([*,*,*,*,○]　の　○)
*.Select(x =>; x.Last());

*await new HttpClient().GetStringAsync(@"https:
docs.microsoft.comja-jp");

*base(factory, serviceProvider, "AddIn", "ThisAddIn") {Globals.Factory = factory;}
(中略)
*internal static global::Microsoft.Office.Tools.Outlook.Factory Factory {get {return _factory;}set {if ((_factory == null)) {_factory = value;}else {throw new System.NotSupportedException();}}}
(中略)
(中略)
*,,,
*if (mail != null)*{
MailItemの場合
*else if (Item is Outlook.ReportItem)*{
(中略)
ReportItemのままだと送信先が取れないため、
いったんIPM.Noteとして別名保存⇒ロードしてからRecipientsを取得する
*Outlook.ReportItem copiedReport = item.Copy();
IPM.Noteとして保存してからロードするとMailItemとして扱えるようになる
*var newReportItem = Globals.ThisAddIn.Application.Session.GetItemFromID(copiedReport.EntryID);
受信者の情報をリストに入れる
*List<;Outlook.Recipient>; recipientsList = new List<;Outlook.Recipient>;();
*if (recipients[i].Type == (int)Outlook.OlMailRecipientType.olBCC)*{
recipients[i]がBccまたはリソース
*if (recipients[i].Sendable)*{
Bccや、選択されたリソースの場合
*{continue;}
選択されていないリソースの場合
*{recipientsList.Add(recipients[i]);}
送信者、To、Ccの場合
(中略)
アセンブリを読み込み、モジュールを取得
*Assembly asm = Assembly.LoadFrom(@".\ORCAUnitTest\bin\Debug\OutlookRecipientConfirmationAddin.dll");
テスト対象のクラス（Utility）のタイプを取得
*Type type = mod.GetType("OutlookRecipientConfirmationAddin.Utility");
インスタンスを生成し、メソッドにアクセスできるようにする
*object obj = Activator.CreateInstance(type);
(中略)
*}
(中略)
ThisAddInクラスのインスタンスを生成
*TestFactory testFactory = new TestFactory();
ThisAddInのApplicaitionフィールドを取得し、モックの値（testApp）をセット
*Type typeThisAddIn = testAddIn.GetType();
モックのApplication（testApp）のSessionに値(tesNs)をセットする
*testNs = Substitute.For<;NameSpace>;();
GlobalsのThisAddinプロパティに、モックなどを使って作った値(testAddIn)をセットする
*Type typeGlobal = mod.GetType("OutlookRecipientConfirmationAddin.Globals");
モックのApplication（testApp）のSessionに値(tesNS)をセットする
*testNs = Substitute.For<;NameSpace>;();
(中略)
*}
(中略)
*dynamic Copy();
(中略)
*}
(中略)
*public abstract void Close(OlInspectorClose SaveMode);
(中略)
*,,,
*string[] testRecNames = { "testemailaddress1@example.com", "testemailaddress2@example.com" };
モックでつかうデータを用意
期待結果を入れるリスト
*List<;Recipient>; expectedRecList = new List<;Recipient>;();
モックのReturn値と、期待結果のリストの値を設定
*MyTestNs myTestNs = Substitute.For<;MyTestNs>;();
*var objArray = new object[] { testReport, Utility.OutlookItemType.Mail, false };
テストするメソッドにアクセスし、実際の結果を取得
テスト対象メソッドの返り値をList&lt;Recipient&gt;型にする
*List<;Recipient>; actualRecList = new List<;Recipient>;();
actualとexpectedのリストを比較
*Assert.AreEqual(actualRecList.Count, expectedRecList.Count);
ref引数のtypeが正しいことを確認
*Assert.That(objArray[1], Is.EqualTo(Utility.OutlookItemType.Report));

*{protected override void OnCreate(Bundle savedInstanceState){base.OnCreate(savedInstanceState);SetContentView(Resource.Layout.Main);var button = FindViewById<;Button>;(Resource.Id.myButton);var sounds = new int[]{Resource.Raw.trumpet1,Resource.Raw.trumpet2};button.Click += async (sender, e) =>;{foreach (var id in sounds){await PlayAsync(id);}};}// 再生が終了したら true を、エラーだったら false を返すprivate Task<;bool>; PlayAsync(int rscId){var compSource = new TaskCompletionSource<;bool>;();var mp = MediaPlayer.Create(this, rscId);mp.Completion += (_, __) =>;{compSource.SetResult(true);};mp.Error += (_, __) =>;{compSource.SetResult(false);};mp.Start();return compSource.Task;}}
using System.Threading.Tasks;
*{var compSource = new TaskCompletionSource<;bool>;();var mp = MediaPlayer.Create(this, rscId);mp.Completion += (_, __) =>;{compSource.SetResult(true);};mp.Error += (_, __) =>;{compSource.SetResult(false);};mp.Start();return compSource.Task;}
再生が終了したら true を、エラーだったら false を返す

*public string Name { get; set; }
名前
*public int Age { get; set; }
年齢
年齢昇順
*people.Sort((a, b) =>; a.Age - b.Age);
年齢降順
*people.Sort((a, b) =>; b.Age - a.Age);
名前昇順
*people.Sort((a, b) =>; string.Compare(a.Name, b.Name));

YYYYY Entity の Statesが
Unchanged状態→Added状態へ。
*context.YYYYYs.Add(

*await context.OpenAsync("https:
www.google.co.jp");

それを求めるすべてのクラスに対してFooの新しいインスタンスを作成する
*Container.Bind<;Foo>;().AsTransient();
IFooを要求するクラスごとにFooの新しいインスタンスを作成する
*Container.Bind<;IFoo>;().To<;Foo>;().AsTransient();
非ジェネリックバージョン
*Container.Bind(typeof(IFoo)).To(typeof(Foo)).AsTransient();
Fooの1つの最終的なインスタンスを作成し、それを求めるすべてのクラスに対して再利用します
*Container.Bind<;Foo>;().AsSingle();
Fooの1つの最終的なインスタンスを作成し、IFooを要求するすべてのクラスに対してそのインスタンスを再利用します
*Container.Bind<;IFoo>;().To<;Foo>;().AsSingle();
この例では、Fooの同じインスタンスが3つのすべてのケースで使用されます
*Container.Bind<;Foo>;().AsSingle();
非ジェネリックバージョン
*Container.Bind(typeof(Foo)).AsSingle();
または、1つのバインドステートメント
*Container.Bind(typeof(Foo), typeof(IFoo)).To(typeof(Foo)).AsSingle();
Fooが実装するすべてのインターフェイスを、Foo型の新しいシングルトンにバインドする
*Container.BindInterfacesTo<;Foo>;().AsSingle();
たとえば、FooがITickableとIInitializableを実装している場合、上記の行は次のようになります。
*Container.Bind<;ITickable>;().To<;Foo>;().AsSingle();
Fooが使用されているあらゆる場所で、指定されたインスタンスを使用する
*Container.Bind<;Foo>;().FromInstance(new Foo());
これは単に上記バインディングのショートカットです
これは、タイプ引数がパラメータから導き出されることができるので、少し好きかもしれません
*Container.BindInstance(new Foo());
複数のバインディングを許可し、複数のバインディングで同じインスタンスをAsSingleで再利用することはできないため、
FromInstanceはAsSingleとは異なることに注意してください。
たとえば、次のようにしてList &lt;Fooのコンストラクタパラメータ &gt;（単一のFooを要求するパラメータの例外をスローする）
*Container.Bind<;Foo>;().FromInstance(new Foo());
intが要求されるたびに10を使用するあなたはこれをやりたいとは思っていません。
プリミティブ値にはほとんどの場合、When条件を使うべきです（下記の条件節を参照）
*Container.Bind<;int>;().FromInstance(10);
これらは上記と同じです
これは型引数がパラメータから導き出されるためです
また、条件を使用して値の使用範囲を制限するように注意してください
上記のようにSettingsオブジェクトを使用することを検討してください
*Container.BindInstance(10);
要求されたときに、指定されたメソッドを使用してFooのインスタンスを作成するもっと複雑な構築シナリオでは、
代わりにファクトリを使用することを検討してください
*Container.Bind<;Foo>;().FromMethod(GetFoo);
IFooのいくつかの異なる実装のうちの1つをランダムに返します
Foo1がそのメンバを注入するように、ここではインスタンス化をnewの代わりに使用します
*Container.Bind<;IFoo>;().FromMethod(GetFoo);
ラムダ構文の使用
*Container.Bind<;Foo>;().FromMethod((ctx) =>; new Foo());
これはAsTransientと同等です
*Container.Bind<;Foo>;().FromMethod((ctx) =>; ctx.Container.Instantiate<;Foo>;());
別の依存関係のプロパティにバインドする
これは、クラス間の結合を減らすのに役立ちます
*Container.Bind<;Foo>;().AsSingle();
値を使用する別の例
*Container.Bind<;string>;().FromResolveGetter<;Foo>;(foo =>; foo.GetTitle());
シーンのルートに新しいゲームオブジェクトを作成し、そこにFoo MonoBehaviourを追加し、それに "Foo"という名前を付けます。
*Container.Bind<;Foo>;().FromNewComponentOnNewGameObject().AsSingle();
WithGameObjectNameを使用して使用するゲームオブジェクト名を指定することもできます
*Container.Bind<;Foo>;().FromNewComponentOnNewGameObject().WithGameObjectName("Foo1").AsSingle();
インターフェイスにバインドする
*Container.Bind<;IFoo>;().To<;Foo>;().FromNewComponentOnNewGameObject().AsSingle();
与えられたプレハブを使ってシーンのルートに新しいゲームオブジェクトを作成する
ここではFooはMonoBehaviourであり、Fooは以前にプレハブに追加されているものと仮定しています
zenjectが与えられたプレハブから新しいGameObjectを作成すると、
プレファブで 'Foo'型のコンポーネントを検索し、それを返します
*GameObject fooPrefab;
代わりにインターフェイスにバインドする
*Container.Bind<;IFoo>;().To<;Foo>;().FromComponentInNewPrefab(fooPrefab).AsSingle();
この例では、AsSingleを使用していますが、異なるコンポーネントを使用しています。
ここでは、特定のプレハブのインスタンスが1つだけ作成されることに注意してください。
AsSingleはプレハブ自体に適用され、プレハブから返されるタイプには適用されません。
これが機能するには、Foo MonoBehaviourとBar MonoBehaviourの両方がプレハブのどこかに存在する必要があります
*GameObject prefab;
Fooのインスタンスが毎回 'fooPrefab'の新しいコピーをインスタンス化する
コンストラクタパラメータ、注入されたフィールドなどによって要求されます。
*GameObject fooPrefab = null;
ここでも、AsTransientがデフォルトであるため、これは同等です
*Container.Bind<;Foo>;().FromComponentInNewPrefab(fooPrefab).AsTransient();
代わりにインターフェイスにバインドする
*Container.Bind<;IFoo>;().To<;Foo>;().FromComponentInNewPrefab(fooPrefab);
グローバルにアクセス可能な文字列を 'PlayerName'という名前でバインドすることをお勧めします。
しかし、より良い選択肢は、Settingsオブジェクトを作成してバインドすることです
*Container.Bind<;string>;().WithId("PlayerName").FromInstance("name of the player");
これは上記の行に相当し、もう少し読みやすくなります
*Container.BindInstance("name of the player").WithId("PlayerName");
IDを使用して、同じタイプの複数のインスタンスをバインドすることもできます。
*Container.Bind<;string>;().WithId("FooA").FromInstance("foo");
*{[Inject(Id = "FooA")]string _foo;}
次に、これらの依存関係を注入するときには、同じIDを使用する必要があります。
この例では、Fooの3つのインスタンスをバインドします.1つはIDなし
*Container.Bind<;Foo>;().AsCached();
[Inject]フィールドでIDが指定されていない場合は、最初のインスタンスが使用されます.
IDなしのBindingsはデフォルトとして使用でき、同じタイプの特定のバージョンのIDを指定できます
*public class Norf
Qux._fooはNorf._fooと同じインスタンスになります。
これは、AsTransではなくAsCachedを使用しているためです。
AsSingleを使用しないことに注意してください。
この場合、Qux._foo2も同じインスタンスを使用するためです
*public class Qux
これにより、BarはFooに依存することができます
Fooを他のクラスのコンストラクタに追加すると、それを見つけることができません
*Container.Bind<;Foo>;().AsSingle().WhenInjectedInto<;Bar>;();
IFooのさまざまな実装を使用する
クラスが注入されている
*Container.Bind<;IFoo>;().To<;Foo1>;().AsSingle().WhenInjectedInto<;Bar>;();
「Foo1」をデフォルトの実装として使用する場合は、
クラスQux、その場合はFoo2を使用する
*Container.Bind<;IFoo>;().To<;Foo1>;().AsSingle();
Fooに依存するいくつかの選択されたクラスでのみ許可
*Container.Bind<;Foo>;().AsSingle().WhenInjectedInto(typeof(Bar), typeof(Qux), typeof(Baz));
識別子 "Title"を持つGuiクラスに注入された文字列の "my game"を提供する
*Container.BindInstance("my game").WithId("Title").WhenInjectedInto<;Gui>;();
Guiクラスに注入されたすべてのintの5を供給する
*Container.BindInstance(5).WhenInjectedInto<;Gui>;();
Guiの中のパラメータやフィールドに注入されたすべてのintを 'width'という名前で入力します。
フィールドの名前は簡単に変更でき、バインディングを破ることができますが、ここでは例として示しています。
*Container.BindInstance(5.0f).When(ctx =>;
'Bar'クラスの構築の一部として作成されたすべてのクラスに対して新しい 'Foo'を作成する
したがって、BarがQux型のコンストラクタパラメータを持ち、QuxがIFoo型のコンストラクタパラメータを持っている場合、
そのケースに対して新しいFooが作成されます
*Container.Bind<;IFoo>;().To<;Foo>;().AsTransient().When(
*Container.BindInstance(foo1).When(c =>; c.ParentContexts.Where(x =>; x.MemberType == typeof(Bar) &amp;&amp; x.Identifier == "Bar1").Any());*Container.BindInstance(foo2).When(c =>; c.ParentContexts.Where(x =>; x.MemberType == typeof(Bar) &amp;&amp; x.Identifier == "Bar2").Any());
ここでは、注入コンテキストの 'ParentContexts'プロパティを使用して、複数の対応する識別子を同期させます
これにより、
Container.Resolve&lt;Bar&gt;("Bar1").Foo == foo1
Container.Resolve&lt;Bar&gt;("Bar2").Foo == foo2
これにより、IBar、IFoo、およびFooがすべてFooの同じインスタンスにバインドされます。
これは、指定されたプレハブのどこかに存在すると仮定されています
*GameObject fooPrefab;
これにより、上記と同じ動作になります
*GameObject fooPrefab = null;
Rebindは、以前のバインディングを上書きするために使用できます
これは、IFooがBarのみにバインドされることになります
Fooへのバインディングは削除されます
通常、バインディングが発生する順序はまったく重要ではありませんが、
Rebindは順序依存性を作成して慎重に使用します
*Container.Bind<;IFoo>;().To<;Foo>;().AsSingle();
すぐにFooInstallerでInstallBindings（）を呼び出します。
*FooInstaller.Install(Container);
FooInstallerを呼び出す前に、そのプロパティを設定してください
*Container.BindInstance("foo").WhenInjectedInto<;FooInstaller>;();
*FooInstaller.Install(Container, new object[] { "foo" });
引数を直接渡すこともできます
*FooInstaller.Install(Container, new object[] { "foo" });
この行は上記の2行に相当します
FooInstallerを呼び出した後、そのバインディングの1つをオーバーライドします
FooInstallerがIFooを何かにBindすると仮定します
*FooInstaller.Install(Container);
これは、[Inject]とマークされた任意のパラメータを記入し、任意の[Inject]メソッド
*var foo = new Foo();
以前に追加されたバインディングを使用して、IFooのインスタンスを返します。
内部的には、IFoo型のコンストラクタパラメータを入力するとトリガされるものです
注：一致が見つからない場合は例外がスローされます
*Container.Resolve<;IFoo>;();
上記と同じですが、指定された型が見つからない場合はnullを返します。
*Container.TryResolve<;IFoo>;();
Foo型の2つのインスタンスのリストを返す
*Container.BindInstance(new Foo());
Fooの新しいインスタンスを作成し、そのメンバーのいずれかに注入する
Fooが持つ可能性のある任意のコンストラクタパラメータを入力します
*Container.Instantiate<;Foo>;();
新しいプレハブをインスタンス化し、プレハブに注入可能なものを埋め込む
*GameObject go = Container.InstantiatePrefab(prefab);
新しいプレハブをインスタンス化し、特定のモノオブジェクトを返す
*Foo foo2 = Container.InstantiatePrefabForComponent<;Foo>;(prefab);
既存のゲームオブジェクトに新しいコンポーネントを追加する
*Foo foo3 = Container.InstantiateComponent<;Foo>;(gameObject);

このコードはツールによって生成されました。
ランタイム バージョン:4.0.30319.42000

このファイルへの変更は、以下の状況下で不正な動作の原因になったり、
コードが再生成されるときに損失したりします。
&lt;/auto-generated&gt;
------------------------------------------------------------------------------
*namespace INotifyPropertyChanged_2172d2073f184d9db6d12b49f79a37c0 {

*var denominator = 1;
分母 もっと大きな数から始められるはずだが...
*var frac = $"{k}{numerator}{denominator}";
分子  K + N / D = 100 となる N を求めている --&gt; N = D * (100 - K)
*if (IsKomachi(frac)) {yield return new Answer {WholeNumber = k,Numerator = numerator,Denominator = denominator};}
これ以上やっても解はない。小町にはならない
*private bool IsKomachi(string s) {return s.OrderBy(c =>; c).SequenceEqual("123456789");}
小町数か、（引数は数値を文字列に変換したもの）

*var dateNode = doc.DocumentNode.SelectNodes("
div[@class='top-matter']p[2]time");

*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame
オブジェクトをアクティブにする
*winnerLabelObject.SetActive(true);
*if (hit.gameObject.CompareTag("Player")) {*// 現在のシーン番号を取得
接触したオブジェクトのタグが"Player"の場合
現在のシーン番号を取得
*int sceneIndex = SceneManager.GetActiveScene().buildIndex;
現在のシーンを再読込する
*SceneManager.LoadScene(sceneIndex);

プレビュー１の場合
*return Clients.All.SendAsync("AddMessage", msg);
α2の場合
return Clients.All.InvokeAsync("AddMessage", msg);
*}
この１行を追加します
*services.AddSignalR();
*{// 使用するClassを登録しているようですroutes.MapHub<;ChatHub>;("/chathub");});
UseMvcの後でもいいかどうか不明ですが
使用するClassを登録しているようです
*routes.MapHub<;ChatHub>;("/chathub");
*{RegisteredFunction.Invoke<;bool>;("迷信", Msg);}
ここはC#内で完結するため日本語メソッド名が利用できました
JavaScriptでログ出力
*RegisteredFunction.Invoke<;bool>;("log", "「AddMessage」よばれたー");
C#でのログ出力を行うと
WASM: 「AddMessage」よばれたー
と出力されます
*Console.Out.WriteLine("「AddMessage」よばれたー");
手動での更新通知
*this.StateHasChanged();

*private readonly int MAX_TIME = 3599;
限界は59分59秒
ゲーム全体の初期化
*mGame = GameController.Instance;
初期レベルはイージー
*mGame.GameLevel = GameController.LEVEL_EASY;
タイマーの生成
*追加        mTimer = new GameTimer();
ゲームの開始と終了
---------------------------------------------------------------------------------
*private void StartGame()
時間管理
---------------------------------------------------------------------------------
*private GameTimer mTimer;

*追加
フラグの解除
ゲームレベルによってサイズと爆弾の数を決定
*int xLength;
ブロックを並べる
*InstantiateBlocks(xLength, yLength);
ブロックに爆弾を設置
*SetBombs(bombCount);
カメラを中心に設定
*float cameraX = xLength * BLOCK_SIZE / 2.0f;

状態と更新
---------------------------------------------------------------------------------
*private enum STATE
タグ
*public static string TAG_BLOCK = "Block";
対象が爆弾ブロックか判定
*BlockModel target = go.GetComponent<;BlockModel>;();
*if (target.IsCheck) return;*// チェックしていないなら開いてゲームオーバー
チェック済ならば何もしない
チェックしていないなら開いてゲームオーバー
GameOver(target);
*}else
爆弾でないならば一連の開く処理
*OpenBlock(target);
ゲームクリアの判定
JudgeGameClear();
*}
*{BlockModel model = GetBlock(posX, posY);if (model != null) result.Add(model);};
定義済みデリゲート
各座標をチェックしてリストに追加していく
*action(x - 1, y - 1);
*if (target.IsOpen || target.IsCheck) return;*// 対象ブロックの隣接1マスにあるブロックを取得
対象がすでに開かれている or チェック済の場合は何もしない
対象ブロックの隣接1マスにあるブロックを取得
*List<;BlockModel>; aroundBlocks = GetAroundBlocks(target.X, target.Y);
周囲の爆弾の数を取得
*int bombCount = aroundBlocks.Count(block =>; block.HasBomb);
対象ブロックを開く
*target.Open(bombCount);
*if(bombCount == 0)*{
周囲に爆弾が0だった場合に限り、隣接するブロックを連鎖的に開いていく

*追加
カメラを中心に設定

フラグ
---------------------------------------------------------------------------------
開かれたブロックの場合はtrue
*public bool IsOpen { get; private set; }
アクション
---------------------------------------------------------------------------------
*public void Open()
UVマップの定義
---------------------------------------------------------------------------------
*private static Vector2[] UV_CHECK =
初期化
---------------------------------------------------------------------------------
*private void Awake()
チェックマークを表示
*ChangeUvToCheck();
UVマップの切り替え
---------------------------------------------------------------------------------
*public void ChangeUvToCheck()
初期化
---------------------------------------------------------------------------------
*private void Awake()
最初は何も表示しないテクスチャを設定
*ChangeUvToBlank();
UVマップの切り替え
---------------------------------------------------------------------------------
*private static Vector2[] UV_ONE =
*public int X { get; private set; }
ポジション
*public int X { get; private set; }
---------------------------------------------------------------------------------
フラグ
---------------------------------------------------------------------------------
爆弾ブロックの場合はtrue
*public bool HasBomb { get; set; }
*public bool IsOpen { get; private set; }
開かれたブロックの場合はtrue
*public bool IsCheck { get; private set; }
チェック済ブロックの場合はtrue
アクション
---------------------------------------------------------------------------------
*public void Open(int aroundBombs)

初期化タイミングでインスタンスを生成
*private static readonly GameController mInstance = new GameController();
*private GameController() { }
コンストラクタをprivateにすることによって他クラスからnewできないようにする
*{get{return mInstance;}}
他クラスからこのインスタンスを参照する
フレームレートの設定
*Application.targetFrameRate = 30;
状態と更新
---------------------------------------------------------------------------------
*private enum STATE

*Debug.Log($"Interval time:{start_time - previous_time}");
10msではなく、1frame待つことになる。
10msではなく、1frame待つことになる。
*yield return new WaitForSeconds(0.01f);
1frame + α待つことになる。
*await Task.Delay(10);
1Tickあたりの時間を代入する。
*_nextTickTime = (float)_tempo.SecondsPerTick();
始めの1小節は不安定なので発行しない。
*.Skip(_tempo.TickPerTuplet * 8)
4小節毎に発行する。
*_rhythmObserver.FourBars.OnNext(new TimingForFourBars(_Timing));
1小節毎に発行する。
*_rhythmObserver.Bar.OnNext(new TimingForBar(_Timing));
1beat毎に発行する。
*_rhythmObserver.Beat.OnNext(new TimingForBeat(_Timing));
連符毎に発行する。
*_rhythmObserver.Tuplet.OnNext(new TimingForTuplet(_Timing));
Tick毎に発行する。
*_rhythmObserver.Tick.OnNext(new TimingForTick(_Timing));
1Tickあたりの時間を追加する。
*_nextTickTime += (float)_tempo.SecondsPerTick();
1小節毎に購読する。
*_rhythmReceiver.Bar

*for (var denominator = 2; denominator <;= 9; denominator++) {*var ans = UnitFractionKomachi.Solve(denominator);
n が2～9までのすべての場合の、解を求め、プリントする
*private static void PrintResult(int denominator, IEnumerable<;int>; numerators) {StringBuilder sb = new StringBuilder();int i = 1;foreach (var n in numerators) {int den2 = n * denominator;sb.AppendFormat("{0,2} : {1} / {2} = 1 / {3}\n", i++, n, den2, denominator);}Console.WriteLine(sb.ToString());}
n == denominatorの時の解をプリントする
denominator 分母 2-9 まで
1/denominatorとなる小町数を求める
単位分数の分母が 2-9までの場合は、小町数になる分数の分子と分母は、４桁/5桁になる
*public static IEnumerable<;int>; Solve(int denominator) {
*for (int m = 1000; m <;= 9876; m++) {*string s = (denominator * m).ToString() + m.ToString();
小町数で単位分数

テストが同時に走らないためにロックを使う
*Monitor.Enter(lockObject);
テストが同時に走らないためのロック解放
*Monitor.Exit(lockObject);

クエリあることを設定する
*Name = "Query";
heroというクエリを定義　　　　　　　　　　　　　　　　　　↓LINQが書ける
*Field<;CharacterInterface>;("hero", resolve: context =>; data.GetDroidByIdAsync("3"));

*UIApplication.SharedApplication.SetStatusBarStyle(UIStatusBarStyle.LightContent, false);
← これ

依存関係プロパティ
*get =>; (string)GetValue(NameProperty);
添付プロパティ
*public static string GetName(DependencyObject obj) =>; (string)obj.GetValue(NameProperty);

*float acos =Acos(cos);
ここも必要に応じて変更する
度に変換すること
*return angle;

*sieve[1] = 0;
0 : 素数ではない
*private IEnumerable<;int[]>; Solve(IEnumerable<;int>; primesA, IEnumerable<;int>; primesB) {// 素因数分解した結果を文字列にし、小町数かどうかを調べるvar s = ToString(primesA);if (IsKomachi(s)) {yield return primesA.ToArray();} else {// 小町の可能性があるならば、PrimesBから一つ取り出し、// その因数を解PrimesAに加え、再帰処理してゆく。if (IsValid(s)) {foreach (var n in primesB) {var ans = Solve(primesA.Concat(new int[] { n }), primesB.SkipWhile(a =>; a <;= n));foreach (var primes in ans)yield return primes;}}}}
primesA 素因数分解した途中結果 (必ず小さい因数から順に並ぶ）
*private IEnumerable<;int[]>; Solve(IEnumerable<;int>; primesA, IEnumerable<;int>; primesB) {// 素因数分解した結果を文字列にし、小町数かどうかを調べるvar s = ToString(primesA);if (IsKomachi(s)) {yield return primesA.ToArray();} else {// 小町の可能性があるならば、PrimesBから一つ取り出し、// その因数を解PrimesAに加え、再帰処理してゆく。if (IsValid(s)) {foreach (var n in primesB) {var ans = Solve(primesA.Concat(new int[] { n }), primesB.SkipWhile(a =>; a <;= n));foreach (var primes in ans)yield return primes;}}}}
primesB 候補となる素数 （どんどん絞られてゆく）
*if (IsKomachi(s)) {yield return primesA.ToArray();} else {// 小町の可能性があるならば、PrimesBから一つ取り出し、// その因数を解PrimesAに加え、再帰処理してゆく。if (IsValid(s)) {foreach (var n in primesB) {var ans = Solve(primesA.Concat(new int[] { n }), primesB.SkipWhile(a =>; a <;= n));foreach (var primes in ans)yield return primes;}}}
素因数分解した結果を文字列にし、小町数かどうかを調べる
*if (IsValid(s)) {foreach (var n in primesB) {var ans = Solve(primesA.Concat(new int[] { n }), primesB.SkipWhile(a =>; a <;= n));foreach (var primes in ans)yield return primes;}}
小町の可能性があるならば、PrimesBから一つ取り出し、
*if (IsValid(s)) {*foreach (var n in primesB) {
その因数を解PrimesAに加え、再帰処理してゆく。
*private bool IsValid(string s) {var length = s.Length;// 重複していれば、Distinctした個数とは一致しないreturn s.Distinct().Count() == length;}
適合しているか （同じ数字があるとダメ）
重複していれば、Distinctした個数とは一致しない
*return s.Distinct().Count() == length;
*private string ToString(IEnumerable<;int>; nums) {var s = "";foreach (var n in nums) {s += n.ToString();}return s;}
int配列を文字列に変換
*private bool IsKomachi(string s) {if (s.Length != 9)return false;return s.OrderBy(c =>; c).SequenceEqual("123456789");}
小町数か、（引数は数値を文字列に変換したもの）
*var ans = Solve(primesA.Concat(new int[] { n }), primesB.Where(a =>; a != n));
解答primesAにnを追加。候補となる素数リストprimeBからnを除外

*Console.WriteLine(string.Format("{0} is {1}? {2}", nonGenericInterfaceClass, nonGenericInterfaceType, nonGenericInterfaceClass is INonGenericInterface));
Interface を実装したクラスは当然 is で判定可能
*foreach (Type interfaceType in nonGenericInterfaceClassType.GetInterfaces())*{
Interface を実装したクラスの Type からインターフェースを取り出してみる
例えそのクラス自体がインターフェースを定義していなくても
インターフェースを実装したクラスのサブクラスであればインターフェースを取得できる事が分かる
*foreach (Type interfaceType in subClassOfNonGenericInterfaceClassType.GetInterfaces())
そもそもこういう書き方できるんだね、っていうw
しかし、genericInterfaceClass is IGenericInterface&lt;&gt; とは書けない
*Type genericInterfaceType = typeof(IGenericInterface<;>;);
*foreach (Type interfaceType in genericInterfaceClassType.GetInterfaces())*{
Interface を実装したクラスの Type からインターフェースを取り出してみる
↑これやー！
*}

*var query = list.GroupBy(item =<; item.Category);
集約keyはint型とします。

*new Human("Yamada", new List<;int>;(){ 150, 40, 180, 110, 20 }),
適当なインスタンスを作成
Humansリスト内の全ての要素のList&lt;int&gt; NumbersをひとつのList&lt;int&gt;にまとめたい
冗長なコードの例1
*List<;int>; BadSample1 = new List<;int>;();
冗長なコードの例2
*List<;int>; BadSample2 = new List<;int>;();
LINQを使った例
HumansのNumbersのリストの列挙を作成
*List<;List<;int>;>; AllNumbers = Humans.Select(h =>; h.Numbers).ToList();
List&lt;List&lt;T&gt;&gt;をList&lt;T&gt;にする（Listを平坦化する）
*List<;int>; AllNum = AllNumbers.SelectMany(a =>; a).ToList();
List&lt;Human&gt;から一発でList&lt;int&gt;に変換する
*List<;int>; allNum = Humans.SelectMany(x =>; x.Numbers).ToList();

返り値の型が間違っていてもエラーしない
return (bool)value ? TextWrapping.Wrap : TextWrapping.NoWrap;
*}
返り値の型が間違っているのでエラーする
return (bool)value ? TextWrapping.Wrap : TextWrapping.NoWrap;
*}

文字コードは、UTF8
*static Encoding ScriptCharCode =>; Encoding.UTF8;
*static void Main() {LoadEmbedScripts();JSCallTest();}
Main関数が最初に実行される
*static void LoadEmbedScripts() {//リソースが埋め込まれたアセンブリを取得するvar asm = System.Reflection.Assembly.GetExecutingAssembly();//アセンブリ内のリソースを全て読み出すforeach (var i in asm.GetManifestResourceNames()) {//リソースをbyte配列で取得var datas = asm.GetManifestResourceData(i);//byte配列をString型に変換var js = ScriptCharCode.GetString(datas);//↓を実行することで埋め込んだスクリプトを使えるようになるDocument.Head.AppendChild(new HTMLScriptElement { TextContent = js });}}
リソースを読み出し、
*static void LoadEmbedScripts() {//リソースが埋め込まれたアセンブリを取得するvar asm = System.Reflection.Assembly.GetExecutingAssembly();//アセンブリ内のリソースを全て読み出すforeach (var i in asm.GetManifestResourceNames()) {//リソースをbyte配列で取得var datas = asm.GetManifestResourceData(i);//byte配列をString型に変換var js = ScriptCharCode.GetString(datas);//↓を実行することで埋め込んだスクリプトを使えるようになるDocument.Head.AppendChild(new HTMLScriptElement { TextContent = js });}}
Scriptタグを動的に定義する処理
リソースが埋め込まれたアセンブリを取得する
*var asm = System.Reflection.Assembly.GetExecutingAssembly();
*foreach (var i in asm.GetManifestResourceNames()) {*//リソースをbyte配列で取得
アセンブリ内のリソースを全て読み出す
*var datas = asm.GetManifestResourceData(i);*//byte配列をString型に変換
リソースをbyte配列で取得
byte配列をString型に変換
*var js = ScriptCharCode.GetString(datas);
*Document.Head.AppendChild(new HTMLScriptElement { TextContent = js });
↓を実行することで埋め込んだスクリプトを使えるようになる
*static void JSCallTest() {Console.WriteLine(JSTest.ScriptTestA.GetStr());}
読み込んだスクリプトを使う
jsファイルの関数をインポートするクラスがある名前空間は、
他の名前空間と被らないように注意！
被ってしまうと、どういうわけかエラーが出てしまう
*namespace JSTest {
使用するJsファイルを使えるようにするためのクラス

jsファイルに定義した、
JSTest.ScriptTestA.GetStr()のインポート
*[External]
インポート対象の関数には、
Bridge.External属性を指定し、
extern修飾子とstaticをつける

関数内部処理は書かない
*[External]

あんどん表示を第2モニタに表示し、このフォームは閉じる
*var andon = new Form2();
あんどん表示を第2モニタに表示し、このフォームは閉じる
*var andon = new Window2();

*using Prism.Commands;
prism6
*}else if(str == "Up"){*// ToDo: Upの処理
ToDo: Downの処理
ToDo: Upの処理
*}
WPF MVVM Buttonのupとdownイベント発生時に各コマンドをICommandに送る
*private void btn_PreviewMouseDown(object sender, MouseButtonEventArgs e)
Prismの場合。
*public DelegateCommand<;object>; LatXPCommand
nullは、Click
trueは PreviewMouseDown
falseは PreviewMouseUp
*if(! para.HasValue)

*element.SendKeys(OpenQA.Selenium.Keys.Return);
もしくはKeys.Enter
URLリストを定義する
*List<;string>; url_list = new List<;string>;();
*foreach (IWebElement ele in elements)*{
記事のタイトルをコンソールに表示
Console.WriteLine(lsc_yoku_listdata_rec.Yoku_itemurl);          アドレス
urlを配列に代入する
*url_list.Add(lsc_yoku_listdata_rec.Yoku_itemurl);
リストを配列に載せ替える
*url_arr = url_list.ToArray();
配列のカウント
*url_count = url_arr.Count();
カウント
*int i = 0;
*foreach (string url in url_arr)*{
URLを取出して個別ページの処理を行う
*if (MainBackgroundWorker.CancellationPending)*{
ループ処理の途中にキャンセルされたかを確認する
キャンセルされてた場合の処理
*e.Cancel = true;
htmlファイルを読み込む
var html = File.ReadAllText(driver.PageSource, System.Text.Encoding.UTF8);
HTMLParserのインスタンス生成
*var parser = new HtmlParser();
htmlをパースする
*var doc = parser.ParseDocument(driver.PageSource);
idを指定してElement取得
*var detail_element = doc.GetElementById("pageTop");
マルチスレット対応してテキストボックスを操作
*Invoke(new Action<;string>;(status_mess), i +" / "+ url_count+ "件取得済み");
*List<;IWebElement>; details = driver.FindElements(By.ClassName("p-goods-information-action")).ToList();*int flg = 0;
詳細
見つかったときはフラグ:1
*flg = 1;
セルに値を入れる
*worksheet.Cell(i, 6).Value = cell_name;

*using UnityEngine.EventSystems;
追加を忘れないように！
*{//EventTriggerをアタッチしておくpublic EventTrigger _EventTrigger;//StopCoroutineのためにCoroutineで宣言しておくCoroutine PressCorutine;bool isPressDown = false;float PressTime = 2f;void Awake (){//PointerDownイベントの登録EventTrigger.Entry pressdown = new EventTrigger.Entry ();pressdown.eventID = EventTriggerType.PointerDown;pressdown.callback.AddListener ((data) =>; PointerDown ());_EventTrigger.triggers.Add (pressdown);//PointerUpイベントの登録EventTrigger.Entry pressup = new EventTrigger.Entry ();pressup.eventID = EventTriggerType.PointerUp;pressup.callback.AddListener ((data) =>; PointerUp ());_EventTrigger.triggers.Add (pressup);}//EventTriggerのPointerDownイベントに登録する処理void PointerDown (){Debug.Log ("Press Start");//連続でタップした時に長押しにならないよう前のCoroutineを止めるif (PressCorutine != null) {StopCoroutine (PressCorutine);}//StopCoroutineで止められるように予め宣言したCoroutineに代入PressCorutine = StartCoroutine (TimeForPointerDown ());}//長押しコルーチンIEnumerator TimeForPointerDown (){//プレス開始isPressDown = true;//待機時間yield return new WaitForSeconds (PressTime);//押されたままなら長押しの挙動if (isPressDown) {Debug.Log ("Long Press Done");//お好みの長押し時の挙動をここに書く}//プレス処理終了isPressDown = false;}//EventTriggerのPointerUpイベントに登録する処理void PointerUp (){if (isPressDown) {Debug.Log ("Short Press Done");isPressDown = false;//お好みの短押し時の挙動をここに書く(無い場合は書かなくても良い)}Debug.Log ("Press End");}}
長押しを発生させるuGUI(ImageやText)にアタッチして使う
EventTriggerをアタッチしておく
*public EventTrigger _EventTrigger;
StopCoroutineのためにCoroutineで宣言しておく
*Coroutine PressCorutine;
PointerDownイベントの登録
*EventTrigger.Entry pressdown = new EventTrigger.Entry ();
PointerUpイベントの登録
*EventTrigger.Entry pressup = new EventTrigger.Entry ();
*{Debug.Log ("Press Start");//連続でタップした時に長押しにならないよう前のCoroutineを止めるif (PressCorutine != null) {StopCoroutine (PressCorutine);}//StopCoroutineで止められるように予め宣言したCoroutineに代入PressCorutine = StartCoroutine (TimeForPointerDown ());}
EventTriggerのPointerDownイベントに登録する処理
*if (PressCorutine != null) {*StopCoroutine (PressCorutine);
連続でタップした時に長押しにならないよう前のCoroutineを止める
StopCoroutineで止められるように予め宣言したCoroutineに代入
*PressCorutine = StartCoroutine (TimeForPointerDown ());
*{//プレス開始isPressDown = true;//待機時間yield return new WaitForSeconds (PressTime);//押されたままなら長押しの挙動if (isPressDown) {Debug.Log ("Long Press Done");//お好みの長押し時の挙動をここに書く}//プレス処理終了isPressDown = false;}
長押しコルーチン
プレス開始
*isPressDown = true;
待機時間
*yield return new WaitForSeconds (PressTime);
*if (isPressDown) {*Debug.Log ("Long Press Done");
押されたままなら長押しの挙動
お好みの長押し時の挙動をここに書く
*}
プレス処理終了
*isPressDown = false;
*{if (isPressDown) {Debug.Log ("Short Press Done");isPressDown = false;//お好みの短押し時の挙動をここに書く(無い場合は書かなくても良い)}Debug.Log ("Press End");}
EventTriggerのPointerUpイベントに登録する処理
お好みの短押し時の挙動をここに書く(無い場合は書かなくても良い)
*}

*var postkey = c.GetStringAsync("http:
ow.live.nicovideo.jpapigetpostkey?thread=" + thread).Result.Replace("postkey=", "");

省略
*}

*Array.Sort(a); Array.Reverse(a);
Array.Sortは昇順ソートを行います
*var words = new string[] { "maerd", "remaerd", "esare", "resare" };
問題文にある文字列を逆にしたもの
初期状態をt[0], x[0], y[0]とすることで便利になります
*var t = new int[N + 1];

*public bool ShouldAddProjectItem(string filePath) =<; true;
無条件でProjectItemを生成する
選択中のプロジェクトはActiveSolutionProjectsの配列の先頭にある
*var dte = (EnvDTE._DTE)automationObject;
*foreach(Property prop in project.Properties)*{
プロジェクトのプロパティをテンプレートで使えるように、置換リストに追加する

*if (current is IEnumerator)*{
IEnumeratorはcurrent isで判断する
currentがIEnumeratorの場合再帰的に実行
*var ie = MoveNext((IEnumerator)current);
IEnumerator以外はcurrent.GetType()で判断する
下記は説明用の分岐。
*else if (type == typeof(Coroutine))

*if (credential.IsCreateScopedRequired)*{
Inject the Cloud Vision scopes

*public const int Value = 10;
constだけでstatic扱いなのでstaticは不要

*else if(mIsActive &amp;&amp; !mIsPlayer)
アクティブかつ敵の場合はAI行動を決定＆実行
移動目標を決定
*mAi.DecideMovement();
移動完了の判定
*mAi.CheckMovement();
砲台向きを計算
*mAi.CalTurretRotation();
発射
*mAi.Fire();
HP描画はアクティブに影響を受けないで更新
*mHealthScript.RenewHealthBar();

*case STATE.PLAY:
ゲームプレイ中
*if (Input.GetKeyDown(KeyCode.Backspace)) mGame.OnRestartButton();*}
リスタート
シーンの再読み込み
*SceneManager.LoadScene(SceneManager.GetActiveScene().name);

*case STATE.PLAY:
ゲームプレイ中

初期化処理
*break;
プレイ中
*break;
ゲームオーバー
*break;
初期化タイミングでインスタンスを生成
*private static readonly GameController mInstance = new GameController();
*private GameController() { }
コンストラクタをprivateにすることによって他クラスからnewできないようにする
*{get{return mInstance;}}
他クラスからこのマネージャーを参照する
FixedUpdateの間隔
*private readonly float FIXED_TIME_STEP = 0.03f;
更新間隔の設定
*Time.fixedDeltaTime = FIXED_TIME_STEP;
FixedUpdateの間隔
*private readonly float FIXED_TIME_STEP = 0.03f;
更新間隔の設定
*Time.fixedDeltaTime = FIXED_TIME_STEP;
当たり判定の設定
*追加        SetLayerCollision();
*for (int i = 0; i <;= 11; i++)*{
初期化：車輪とボディについて、全ての接触を有効にする
車輪同士の接触は無効
*Physics.IgnoreLayerCollision(LAYER_WHEEL, LAYER_WHEEL, true);
車輪と本体の接触は無効
*Physics.IgnoreLayerCollision(9, 11, true);
*for (int i = 0; i <;= 11; i++)*{
サスペンションと全ての物体の接触は無効
タグ
*public static string TAG_TANK = "Tank";
*bool IsDead = collider.transform.GetComponent<;TankHealth>;().AddDamage(mAttackValue);*if (!IsDead)
被弾した戦車にダメージを与える
おおまかな接触点を取得（OnCollisionEnterとは異なり、triggerでは正確な座標を取得できない：でも着弾点としては十分？）
*Vector3 hitPos = collider.ClosestPointOnBounds(mTrans.position);
接触した場所に爆発エフェクトを生成
*Instantiate(mExplosionSmallPrefab, hitPos, Quaternion.identity);
*Vector3 hitPos = collider.transform.position;*Instantiate(mExplosionLargePrefab, hitPos, Quaternion.identity);
HPが無くなった場合は戦車中央のポイントに大きな爆発エフェクトを生成
*collider.transform.GetComponent<;TankModel>;().IsDead = true;*}
対象を死亡状態へ
この弾を休眠状態へ
*Sleep();

*private float mPreFillAmount;
増減アクションの終了条件となるHPバーのfillAmount
移動入力の受付
*mMovementScript.CheckInput();
砲台角度を計算
*mTurretScript.CalRotation();
弾発射の入力を受付
*mFireScript.CheckInput();
HPバーの更新
*追加        mHealthScript.RenewHealthBar();

*private Transform mTransFirePoint;
発射時の弾とエフェクトについて、位置と方向を決定する
*{if (Input.GetMouseButtonDown(0)) Fire();}
----------------------------------------------------------------------------------------
発射
----------------------------------------------------------------------------------------
発射地点のTransformから正面方向に1.0f進んだ座標に弾を生成する
*private readonly float BULLET_OFFSET = 1.0f;
生成された弾オブジェクトをプーリング
*private List<;BulletModel>; mBulletList = new List<;BulletModel>;();
所持している弾数
*private int mBulletCount = 3;
弾の攻撃力
*private int mBulletAttack = 10;
弾の速さ
*private float mBulletSpeed = 40.0f;
*if (mBulletCount >; 0)*{
弾数が残っているならば発射処理
所持弾数をデクリメント
*mBulletCount--;
発射エフェクト生成
*CreateMuzzleFire();
弾生成
*CreateBullet();
*foreach (BulletModel model in mBulletList)*{
休眠状態の弾オブジェクトがある場合はそれを再利用する
*GameObject bulletGo = Instantiate(mBulletPrefab, mTransFirePoint.position + mTransFirePoint.forward * BULLET_OFFSET, mTransFirePoint.rotation) as GameObject;*bulletGo.transform.parent = mTransBulletGroup;
再利用できるオブジェクトが無かった場合は新しく生成してリストに格納する
デリゲート受け取り
----------------------------------------------------------------------------------------
*public void OnSleepBullet()

*serialPort1.Open();
ポートを開く

*{// カメラからマウスポインタの方向へ伸びるRayを作成Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);// Rayが接触したコライダーの情報を格納する入れ物RaycastHit hit;// Rayの衝突判定if(Physics.Raycast(ray, out hit)){// 衝突したコライダーのTransformから座標を取得するTransform hitTrans = hit.transform;Vector3 position = hitTrans.position;}}
Ray（光線）を使ってマウスポインタの3D空間上の座標を取得する
カメラからマウスポインタの方向へ伸びるRayを作成
*Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
Rayが接触したコライダーの情報を格納する入れ物
*RaycastHit hit;
*if(Physics.Raycast(ray, out hit))*{
Rayの衝突判定
*Transform hitTrans = hit.transform;*Vector3 position = hitTrans.position;
衝突したコライダーのTransformから座標を取得する
地面の代わりとして使う仮の平面
*private Plane mTempPlane;
Rayを飛ばした際にmTempPlaneと接触するまでの距離
*private float mDistance;
mTempPlaneを予め生成し、Groundと同じ位置に配置しておく
*mTempPlane = new Plane();
カメラからマウスポインタの方向へRayを飛ばす
*Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
RayとmTempPlaneとの接点を取得
*Vector3 mousePosition3d = ray.GetPoint(mDistance);
次のFixedUpdateで砲台に適用するRotation値
*private Vector3 mTurretRotation = Vector3.zero;
*{// カメラからマウスポインタの方向へRayを飛ばすRay ray = Camera.main.ScreenPointToRay(Input.mousePosition);if (mTempPlane.Raycast(ray, out mDistance)){// RayとmTempPlaneとの接点を取得Vector3 mousePosition3d = ray.GetPoint(mDistance);// 対象座標 - 観測座標 = 観測座標から対象座標へ向かうベクトルVector3 direction = mousePosition3d - mTurretTrans.position;// 砲台の正面が対象を向いたときの角度を計算Quaternion quaternion = Quaternion.FromToRotation(transform.forward, direction);// 砲台の回転軸をYのみに制限するmTurretRotation = quaternion.eulerAngles;mTurretRotation.x = 0.0f;mTurretRotation.z = 0.0f;/*// Y軸の値について、インスペクタ上のRotationでは-180~180の表記だが、コード上では0~360で計算されているif (mTurretRotation.y <; 30.0f){mTurretRotation.y = 30.0f;}else if (mTurretRotation.y >; 270.0f){mTurretRotation.y = 30.0f;}else if (mTurretRotation.y >; 150.0f){mTurretRotation.y = 150.0f;}*/}}
GetMousePosition3d()から名称を変更
カメラからマウスポインタの方向へRayを飛ばす
*Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
RayとmTempPlaneとの接点を取得
*Vector3 mousePosition3d = ray.GetPoint(mDistance);
対象座標 - 観測座標 = 観測座標から対象座標へ向かうベクトル
*Vector3 direction = mousePosition3d - mTurretTrans.position;
*Quaternion quaternion = Quaternion.FromToRotation(transform.forward, direction);*// 砲台の回転軸をYのみに制限する
砲台の正面が対象を向いたときの角度を計算
砲台の回転軸をYのみに制限する
*mTurretRotation = quaternion.eulerAngles;
*if (mTurretRotation.y <; 30.0f)*{
Y軸の値について、インスペクタ上のRotationでは-180~180の表記だが、コード上では0~360で計算されている
*{mTurretTrans.rotation = Quaternion.Euler(mTurretRotation);}
計算された角度を砲台のRotationに適用する
移動入力の受付
*mMovementScript.CheckInput();
砲台角度を計算
*追加            mTurretScript.CalRotation();
移動力の更新
*mMovementScript.ApplyVelocity();
砲台角度の更新
*追加        mTurretScript.ApplyRotation();

*this.gameObject.layer = 11;
Layer11 &gt;&gt; for MainBody.
*for (int i = 0; i <;= 11; i++)*{
初期化：車輪とボディについて、全ての接触を有効にする
車輪同士の接触は無効
*Physics.IgnoreLayerCollision(LAYER_WHEEL, LAYER_WHEEL, true);
車輪と本体の接触は無効
*Physics.IgnoreLayerCollision(9, 11, true);
*for (int i = 0; i <;= 11; i++)*{
サスペンションと全ての物体の接触は無効

*il.DeclareLocal(method.ReturnParameter.ParameterType);
result
ラベルの宣言
*var label1 = il.DefineLabel();
dictionaryField の値をスタックに積む
*il.Emit(OpCodes.Ldarg_0);
null をスタックに積む
*il.Emit(OpCodes.Ldnull);
スタックに積まれた dictionaryFiled の値と null が等しければ true を等しくなければ false を boolVariable1 に代入
*il.Emit(OpCodes.Ceq);
boolVariable1 が false なら label1 にジャンプ
*il.Emit(OpCodes.Ldloc_2);
dictionaryField に Dictionary&lt;Param, T&gt; を代入
*il.Emit(OpCodes.Ldarg_0);
object[] を用意
*il.Emit(OpCodes.Ldc_I4, parameterTypes.Length);
*for (int i = 0; i <; parameterTypes.Length; i++)*{
object[] に引数をセット
Param を作成してローカル変数 0 に保存
*il.Emit(OpCodes.Newobj, paramConstructor);
TryGetValue の結果が false なら label2 へ
*il.Emit(OpCodes.Ldloc_3);
リターン位置へジャンプ
*il.Emit(OpCodes.Br_S, label3);
*for (int i = 0; i <; parameterTypes.Length + 1; i++)*{
継承したメソッドの実行
メモ
*il.Emit(OpCodes.Ldarg_0);

まず、LevelだけのFilteredElementCollectorを取得する
*FilteredElementCollector collectorLevel = new FilteredElementCollector(doc).OfClass(typeof(Level));
CollectorからElementIDのリストを取得する。これを除外リストとして使う
*ICollection<;ElementId>; exIds = collectorLevel.ToElementIds();
*foreach (Element el in collectorLevel)*{
Collectorの中身を一つずつ確認
*if (el.Category == null) continue;*// 建物の階にチェックが入っているものは除外リストから外す
念のため
*if (el.LookupParameter(@"建物の階").AsInteger() >; 0)*{
建物の階にチェックが入っているものは除外リストから外す
*if (exIds.Count() >; 0)*{
もし除外リストの中身があれば
除外実行
*collectorLevel.Excluding(exIds);
高さでソート（昇順）
*IOrderedEnumerable<;Level>; lstLevels = from Level lv in collectorLevel orderby lv.LookupParameter(@"高さ").AsDouble() ascending select lv;

*const string host_in = "https:
httpbin.org";

*const string host_in = "https:
httpbin.org";

*{if (commands.Count >; 0){IEnumerator enumerator = commands.GetEnumerator();while (enumerator.MoveNext()){ICommand obj =(ICommand)enumerator.Current;obj.Execute();}}}
実行
*{if (addCommand != this) commands.Push(addCommand);}
追加
*{if (commands.Count >; 0) commands.Pop();}
削除
全件削除
*public void Clear() =>; commands.Clear();
描画対象
*protected IDrawable drawable;
描画位置
*private Point point;
*{this.drawable = drawable;this.point = point;}
コンストラクタ
*{drawable.Draw(point.X, point.Y);}
実行
描画色
*private Color color = Color.Black;
半径
*private int radius = 6;
履歴
*private MacroCommand history = null;
履歴セット（本来はコンストラクタ、今回はメソッドを用意）
*public void SetHistory(MacroCommand history) =>; this.history = history;
*{using (Graphics g = CreateGraphics())using (Brush brush = new SolidBrush(color)){Rectangle rectangle = new Rectangle(x, y, radius, radius);g.FillEllipse(brush, rectangle);}}
描画
*{if (history != null){history.Execute();}}
再描画
描画履歴
*private MacroCommand history = new MacroCommand();
*{if (drag){ICommand command = new DrawCommand(drawCanvas1, e.Location);history.Apppend(command);command.Execute();}}
マウスが動いている時
*{history.Clear();drawCanvas1.Invalidate();}
Clearボタン押下
*{history.Undo();drawCanvas1.Invalidate();}
Undoボタン押下

*SetTextIfEmpty(ref LastName, "Doe");
コンパイルエラー
*{if (String.IsNullOrEmpty(value)){value = "John";}}
参照渡しで受け取った文字列が空白だった、別の文字列を代入する
*{if (String.IsNullOrEmpty(value)){assingAction();}}
文字列が空白だったら、受け取ったデリゲートを実行する
*{Utilitiy.SetIf(propertySelector,predicate: x =>; String.IsNullOrEmpty(x),inputValue: textEmpty);}
文字列を取得して空白だったら、生成した代入デリゲートを実行する
式木からデリゲート生成、生成したデリゲートを実行して現在の値を取得する
*var value = propertySelector.Compile().Invoke();
*if (predicate(value))*{
条件があてはまるなら、代入処理の実行
プロパティを取得する式木を材料にプロパティへの代入をする式木を組み立てて、デリゲート生成
*var assignAction = Utilitiy.CreateAssignActionExpr(propertySelector).Compile();
生成した代入デリゲートに値を指定して実行
*assignAction.Invoke(inputValue);
生成される式：x
*var inputExpr = Expression.Parameter(typeof(TValue), "x");
生成される式：this.Name = x
*var assignExpr = Expression.Assign(
生成される式：x =&gt; this.Name = x
*return Expression.Lambda<;Action<;TValue>;>;(assignExpr, inputExpr);

色別にグルーピング
*var grouped = balls.Grouping(b =>; b.Color);
*foreach (Ball ball in redBalls) {...}
赤色のボールについて何かする
緑色のボールを削除
*grouped.Remove(RGB.Green);
色別にグルーピング
*var grouped = balls.GroupBy(b =>; b.Color);
grouped の型は IEnumerable&lt;IGrouping&lt;RGB, Ball&gt;&gt;
赤色のボールについて何かする
*var redBalls = grouped.Single(g =>; g.Key == RGB.Red);
*foreach (Ball ball in redBalls) {*...
redBalls の型は IGrouping&lt;RGB, Ball&gt; で IEnumerable&lt;Ball&gt; の子クラス
緑色のボールを削除
*grouped = grouped.Where(g =>; g.Key != RGB.Green);
色別にグルーピング
*ILookUp<;RGB, Ball>; grouped = balls.ToLookUp(b =>; b.Color);
grouped の型は ILookUp&lt;RGB, Ball&gt;
赤色のボールについて何かする
*IEnumerable<;Ball>; redBalls = grouped[RGB.Red];
緑色のボールを削除
grouped.Remove(RGB.Green);  No such method.
*,,,
*foreach (Ball ball in balls) {List<;Ball>; list;if (!grouped.TryGetValue(ball.Color)) {list = new List<;Ball>;();grouped.Add(ball.Color, list);}list.Add(ball);}
色別にグルーピング
*foreach (Ball ball in redBalls) {...}
赤色のボールについて何かする
緑色のボールを削除
*grouped.Remove(RGB.Green);
色別にグルーピング
*Dictionary<;RGB, IGrouping<;RGB, Ball>;>; grouped = balls.GroupBy(b =>; b.Color).ToDictionary(g =>; g.Key);
grouped の型は Dictionary&lt;RGB, IGrouping&lt;RGB, Ball&gt;&gt;
赤色のボールについて何かする
*var redBalls = grouped[RGB.Red];
*foreach (Ball ball in redBalls) {*// IGrouping;RGB, Ball>; は IEnumerable;Ball>; の子クラス
redBalls  の型は IGrouping&lt;RGB, Ball&gt;
IGrouping&lt;RGB, Ball&gt; は IEnumerable&lt;Ball&gt; の子クラス
*...
緑色のボールを削除
*grouped.Remove(RGB.Green);
*if (grouped.TryGetValue(RGB.Black, out blackBalls)) {foreach (Ball ball in blackBalls) {...}}
黒色のボールがあれば何かする
色別にグルーピング
*var grouped = balls.GroupBy(b =>; b.Color).ToDictionary(g =>; g.Key, g =>; g as IEnumerable<;Ball>;);
grouped の型は Dictionary&lt;RGB, IEnumerable&lt;Ball&gt;&gt;
赤色のボールについて何かする
*var redBalls = grouped[RGB.Red];
*foreach (Ball ball in redBalls) {*...
redBalls  の型は IEnumerable&lt;Ball&gt;
緑色のボールを削除
*grouped.Remove(RGB.Green);
*if (grouped.TryGetValue(RGB.Black, out blackBalls)) {foreach (Ball ball in blackBalls) {...}}
黒色のボールがあれば何かする

ここに張り付ける
*}
*{public Result[] result { get; set; }}
ここに張り付ける

*VmMyCommand1.RaiseCanExecuteChanged();
★CanExecuteが変化したことを使えないと、フラグ切り替えても有効無効変わらない！
*{Debug.WriteLine("押された");await Task.Delay(2000);Debug.WriteLine("処理完了");}
実験用 押したときに2秒かかる処理実施
*{return MyCamExecuteFlag;}
フラグのON/OFFでボタンの有効無効を切り替える
処理中フラグ
*private bool isExecuting = false;
本クラスを使う側が設定するCanExecuteに加え、処理中フラグのON/OFFを有効無効条件に加える
*public bool CanExecute(object parameter) =>; (canExecute != null) ? (canExecute() &amp;&amp; !isExecuting) : (!isExecuting);
*{IsExecuting = true;await execute();IsExecuting = false;}
処理実行の前後に、無効化→有効化、の処理を追加する

元データと比べたいためコピーを作る
*string result = string.Copy(_defaultText);
検索パターン。今回は先頭末尾以外の大文字を検索する
*var regex = new Regex(@"\B[A-Z]");
パターンに一致した文字列を配列で確保
*var matches = regex.Matches(result);
先頭文字には挿入させないため1にしておく
*int searchIndex = 1;
次の文字列の検索するための増加分
*const int ADD_SEARCH_NUM = 2;
挿入したい文字を入れる。今回はアンダーバー
*const string INSERT_TEXT = "_";
*foreach (var match in matches)*{
パターンにマッチした分だけ回す
文字列の場所を検索。成功すると0以上の数字が返ってくる
*int findIndex = result.IndexOf(match.ToString(), searchIndex);
元データと比べたいためコピーを作る
*string result = string.Copy(_defaultText);

*var d = new Dictionary<;string, MyClass<;();
&lt;キーの型, 値の型&gt;

*handle = FindWindow(null, WINDOW_NAME);
起動したウィンドウを指定
SetWindowLongによる変更を適用
*SetWindowPos(handle, HWND_TOPMOST, 0, 0, displayWidth, displayHeight, SWP_SHOWWINDOW);

*db.Configuration.ProxyCreationEnabled = false;
動的プロキシ禁止
戻り値生成
*ModelResponse<;T1>; ret = new ModelResponse<;T1>;();
トークンの設定
*ret.token = this.GenerateToken();
検索用パラメータの取得
*ModelRequest<;T2>; req = (ModelRequest<;T2>;)DeserializeJson<;T2>;(request);
*if(req != null){*object Checker = null;
検証
検証失敗時
*ret.resultCode = resultCode.Select_WithInfo;
*{object Records = null;int ResultCodeOrSelectCount = 0;// トランザクションを使用する場合if (IsUseTransaction){using (var tran = db.Database.BeginTransaction()){try{ResultCodeOrSelectCount = Execute(req.data, out Records);// 更新実行if (this.SaveChanges()){//更新正常終了tran.Commit();ResultCodeOrSelectCount = DBParameters.ResultCode.UpdateSuccess;}else{//更新失敗(検証失敗、検証以外は例外をスロー)tran.Rollback();ResultCodeOrSelectCount = DBParameters.ResultCode.UpdateValidateError;}}catch (Exception ex){// 検証以外の例外時は例外を再スローtran.Rollback();throw ex;}}}else{ResultCodeOrSelectCount = Execute(req.data, out Records);}// 取得レコードが存在する場合、レスポンスデータに設定if (Records != null){logger.Info("");ret = (ModelResponse<;T1>;)Records;}// 戻り値の設定{// 返却メッセージ初期化ret.message = CommonStrings.DataBase.EmptyMessage;// 戻り値によって返却値、メッセージを設定switch (ResultCodeOrSelectCount){case DBParameters.Parameter.SelectMin:ret.resultCode = resultCode.Select_NotFoundResult;ret.message = CommonStrings.DataBase.Warning.Select_RecordNotExist;break;case DBParameters.Parameter.SelectMax:ret.resultCode = resultCode.Select_WithInfo;ret.message = CommonStrings.DataBase.Question.Select_OverRecords;break;case DBParameters.ResultCode.UpdateSuccess:ret.resultCode = resultCode.Update_Success;break;case DBParameters.ResultCode.UpdateValidateError:ret.resultCode = resultCode.Update_WithWarinig;break;default:ret.resultCode = resultCode.Select_Success;break;}}}
処理実行
*if (IsUseTransaction)*{
トランザクションを使用する場合
*if (this.SaveChanges())*{
更新実行
更新正常終了
*tran.Commit();
更新失敗(検証失敗、検証以外は例外をスロー)
*tran.Rollback();
検証以外の例外時は例外を再スロー
*tran.Rollback();
*if (Records != null)*{
取得レコードが存在する場合、レスポンスデータに設定
*{// 返却メッセージ初期化ret.message = CommonStrings.DataBase.EmptyMessage;// 戻り値によって返却値、メッセージを設定switch (ResultCodeOrSelectCount){case DBParameters.Parameter.SelectMin:ret.resultCode = resultCode.Select_NotFoundResult;ret.message = CommonStrings.DataBase.Warning.Select_RecordNotExist;break;case DBParameters.Parameter.SelectMax:ret.resultCode = resultCode.Select_WithInfo;ret.message = CommonStrings.DataBase.Question.Select_OverRecords;break;case DBParameters.ResultCode.UpdateSuccess:ret.resultCode = resultCode.Update_Success;break;case DBParameters.ResultCode.UpdateValidateError:ret.resultCode = resultCode.Update_WithWarinig;break;default:ret.resultCode = resultCode.Select_Success;break;}}
戻り値の設定
返却メッセージ初期化
*ret.message = CommonStrings.DataBase.EmptyMessage;
*{case DBParameters.Parameter.SelectMin:ret.resultCode = resultCode.Select_NotFoundResult;ret.message = CommonStrings.DataBase.Warning.Select_RecordNotExist;break;case DBParameters.Parameter.SelectMax:ret.resultCode = resultCode.Select_WithInfo;ret.message = CommonStrings.DataBase.Question.Select_OverRecords;break;case DBParameters.ResultCode.UpdateSuccess:ret.resultCode = resultCode.Update_Success;break;case DBParameters.ResultCode.UpdateValidateError:ret.resultCode = resultCode.Update_WithWarinig;break;default:ret.resultCode = resultCode.Select_Success;break;}
戻り値によって返却値、メッセージを設定
オプティミスティック同時実行制御違反
*logger.Fatal(ex.Message);
データベースへの更新送信エラー
*logger.Fatal(ex.Message);
*foreach (var errors in ex.EntityValidationErrors)*{
エンティティ検証エラー
ログ出力
*logger.Fatal(error.ErrorMessage);
非サポートコマンド実施
*logger.Fatal(ex.Message);
コンテキスト破棄エラー
*logger.Fatal(ex.Message);
コマンド送信時コンテキスト内部処理エラー
*logger.Fatal(ex.Message);
作成したファイルをストリーム送信用に変換
*HttpResponseMessage result = Request.CreateResponse(HttpStatusCode.OK);

*int loop = 1000000;
100万回

*if (y * d != c)
yは切り捨てされるので、ここで、再度チェック

ViewModelを登録する
*var model = new MainModel();
メニュー(ButtonMenuItem)のCommandプロパティに「"{Binding ClickMeCommand}"」と
設定しても動かなかったので、コードビハインドに見せかけてDataContextを直接叩く荒業
*(DataContext as MainModel).ClickMeCommand.Execute(sender);
*public ICommand ClickMeCommand { get; private set; }
プロパティ
*private void ClickMe(object sender, EventArgs e) {MessageBox.Show("I was clicked!");}
実行するメソッド
*public MainModel() {ClickMeCommand = new Command(ClickMe);LabelText = "Some Content";}
コンストラクタ
*foreach(var fileUri in e.Data.Uris) {*Console.WriteLine(fileUri.LocalPath);
ファイル名一覧をforeachで回しながら、絶対パス名を表示していく
メニューバーを書き変える
*this.Menu.ApplicationMenu.Text = "ファイル(&amp;F)";
ViewModelを登録する
*var model = new MainModel();
画像データを用意する
*var image1 = new Eto.Drawing.Bitmap(w1, h2, PixelFormat.Format24bppRgb);
*using(var g = new Eto.Drawing.Graphics(image1)){// image2から切り出す範囲を指定(下記例だと左上座標は(x,y)、幅w3・高さh3の範囲)var cropRect = new Eto.Drawing.Rectangle(x, y, w3, h3);// tempImageはimage2から切り出された範囲var tempImage = image2.Clone(cropRect);// image1の指定した位置(x2,y2)にtempImageを貼り付ける// ちなみにGraphics.DrawImage(Image, float x, float y)メソッドは// 見ての通り第2・第3引数がなぜか実数だが、整数を入れてもキャストされるので// 問題なく使用できるg.DrawImage(tempImage, x2, y2);}
Eto.Drawing.Graphics型はIDisposeを継承しているのでusingが使える
image2から切り出す範囲を指定(下記例だと左上座標は(x,y)、幅w3・高さh3の範囲)
*var cropRect = new Eto.Drawing.Rectangle(x, y, w3, h3);
tempImageはimage2から切り出された範囲
*var tempImage = image2.Clone(cropRect);
image1の指定した位置(x2,y2)にtempImageを貼り付ける
ちなみにGraphics.DrawImage(Image, float x, float y)メソッドは
見ての通り第2・第3引数がなぜか実数だが、整数を入れてもキャストされるので
問題なく使用できる
*g.DrawImage(tempImage, x2, y2);

カードのGameObjectにアタッチしたScriptに記述
右回転用
*public IEnumerator CardOpen ()
カードを予め-180度回転させ裏面用の画像を表示する
裏面表示はコルーチン外で行っても良い
CanvasGroupでなくspriteのalpha値を操作しても良い
*transform.eulerAngles = new Vector3 (0, 180, 0);
*while (angle <; -90f) {*angle += Speed * Time.deltaTime;
-90度を超えるまで回転
裏面用の画像を非表示(表面が表示される)
*ReversedFace_CanvasGroup.alpha = 0f;
*while (angle <; 0f) {*angle += Speed * Time.deltaTime;
0度まで回転
*transform.eulerAngles = new Vector3 (0, 0, 0);*}
綺麗に0度にならないことがあるため、補正

*transform.localRotation = Quaternion.Euler(0, 0, 0);*duration = 2f;
reset property

プロセスを起動させるbatファイルが格納されたディレクトリのパス
*string scriptPath = Application.dataPath + "/StreamingAssets/ProcessScripts/";
*if (process != null) return;*// 新規プロセスを作成し、batファイルのパスを登録
他のプロセスが実行しているなら行わない
新規プロセスを作成し、batファイルのパスを登録
*process = new Process();
外部プロセスの終了を検知するための設定
*process.EnableRaisingEvents = true;
外部プロセスを実行
*process.Start();
*{process.Dispose();process = null;}
外部プロセスの終了を検知してプロセスを終了

Ver4.5では、Worksheetsは 0 から始まるように変更
*ExcelWorksheet sheet = pck.Workbook.Worksheets[1];

継承クラスで実装する型Tから型UへのConvert関数
*public abstract U Convert(T value, Type targetType, object parameter, string language);
*{switch (value){case T t_val:return Convert(t_val, targetType, parameter, language);case IEnumerable<;T>; t_arr:return t_arr.Select(t =>; Convert(t, targetType, parameter,language));default:return null;}}
IValueConverterの実装
継承クラスで実装する型Uから型TへのConvertBack関数
*public abstract T ConvertBack(U value, Type targetType, object parameter, string language);
*{switch (value){case U u_val:return ConvertBack(u_val, targetType, parameter, language);case IEnumerable<;U>; u_arr:return u_arr.Select(u =>; ConvertBack(u, targetType, parameter, language));default:return null;}}
IValueConverterの実装
*{public object Convert(object value, Type targetType, object parameter, string language){switch (value){case T t_val:return Convert(t_val, targetType, parameter, language);case IEnumerable<;T>; t_arr:return t_arr.Select(t =>; Convert(t, targetType, parameter, language));default:return null;}}public object ConvertBack(object value, Type targetType, object parameter, string language){switch (value){case U u_val:return ConvertBack(u_val, targetType, parameter, language);case IEnumerable<;U>; u_arr:return u_arr.Select(u =>; ConvertBack(u, targetType, parameter, language));default:return null;}}public abstract U Convert(T value, Type targetType, object parameter, string language);public abstract T ConvertBack(U value, Type targetType, object parameter, string language);}
TからUへの変換

*{HashSet<;Pokemon>; hashSet = new HashSet<;Pokemon>; ();foreach (var item in Party) {hashSet.Add (item);}//重複がある場合は要素数が減るif (Party.Count >; hashSet.Count) {return false;}return true;}
重複時はfalseを返す
*if (Party.Count >; hashSet.Count) {*return false;
重複がある場合は要素数が減る

*while((result = new JVReadResult(m_jvlink1.JVRead(out buffer, out bufferSize, out fileName))).state != JVReadResult.State.finished)*{
JVReadのreturnCodeでJVReadResultを初期化。状態が終了でない限り読み込みを続ける。

*.Publish();
Publish以前のIObservableを保持したIConnectableObservableにする
Publishの内部が持つSubjectを購読
*observable.Subscribe(Console.WriteLine);
Publish以前のIObservableをSubscribeして、Subjectに伝える
*observable.Connect();

*handle = FindWindow(null, WINDOW_NAME);
指定したウィンドウを取得
タイトルバーを非表示
uint style = GetWindowLong(handle, GWL_STYLE);  ウィンドウの情報を取得
SetWindowLong(handle, GWL_STYLE, style ^ WS_CAPTION);  ウィンドウの属性を変更
SetWindowLongによる変更を適用
*SetWindowPos(handle, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_FRAMECHANGED | SWP_SHOWWINDOW);

*StartCoroutine(CoTalk());
会話シナリオを呼び出します
「宴」のシナリオ「Start」タグの会話シーンを呼び出す
会話をどのように構成するか、条件分岐、フラグ設定などは
なんと１つのエクセルでできてしまいます・・・
なお「Start」はデフォルトで入っているタグなので
設定しなくとも下記コードは動きます
*Debug.Log("call co talk");
*while (!Engine.IsEndScenario)*{
「宴」のシナリオ終了待ち

*if (atr.isNothingable)*{
add nothing
*if(index == -1)*index = 0;
type string missing

*SetLayeredWindowAttributes(handle, TRANSPARENT_COLOR, 0, LWA_COLORKEY);
ウィンドウの特定の色を透過

*private async Task HandleCard(CardEventArgs args) {try {//(前のカードが残ってたら消しておく)card?.Dispose();//カードのインスタンス作ってcard = args.SmartCard.CreateMiFareCard();var localCard = card;//カード情報引いたりvar cardIdentification = await localCard.GetCardInfo();DisplayText("Connected to card\r\nPC/SC device class: " + cardIdentification.PcscDeviceClass.ToString() + "\r\nCard name: " + cardIdentification.PcscCardName.ToString());// MiFareカードならif (cardIdentification.PcscDeviceClass == MiFare.PcSc.DeviceClass.StorageClass&amp;&amp; (cardIdentification.PcscCardName == CardName.MifareStandard1K || cardIdentification.PcscCardName == CardName.MifareStandard4K)) {// 2セクタ0ブロックを読み込みvar data = await localCard.GetData(2, 0, 48);// ダンプしたり何なりする// 2セクタ1ブロックを0フィルawait localCard.SetData(2,1, Enumerable.Range(0,16).Select<;byte>;(i=>;0x00).ToArray());//更新を適用await localCard.Flush();}} catch (Exception e) {PopupMessage("HandleCard Exception: " + e.Message);}}
カードが接続されたら
(前のカードが残ってたら消しておく)
*card?.Dispose();
カードのインスタンス作って
*card = args.SmartCard.CreateMiFareCard();
*var cardIdentification = await localCard.GetCardInfo();*DisplayText("Connected to card\r\nPC/SC device class: " + cardIdentification.PcscDeviceClass.ToString() + "\r\nCard name: " + cardIdentification.PcscCardName.ToString());
カード情報引いたり
*if (cardIdentification.PcscDeviceClass == MiFare.PcSc.DeviceClass.StorageClass*&amp;&amp; (cardIdentification.PcscCardName == CardName.MifareStandard1K || cardIdentification.PcscCardName == CardName.MifareStandard4K)) {
MiFareカードなら
2セクタ0ブロックを読み込み
*var data = await localCard.GetData(2, 0, 48);
ダンプしたり何なりする
2セクタ1ブロックを0フィル
*await localCard.SetData(2,1, Enumerable.Range(0,16).Select<;byte>;(i=>;0x00).ToArray());
更新を適用
*await localCard.Flush();
(前のカードが残ってたら消しておく)
*card?.Dispose();
*var keySet = new List<;SectorKeySet>;(){new SectorKeySet(){Sector=1,KeyType=KeyType.KeyA,"FFFFFFFFFFFF"),new SectorKeySet(){Sector=1,KeyType=KeyType.KeyB,"A0A1A2A3A4A5"),new SectorKeySet(){Sector=2,KeyType=KeyType.KeyA,"000000000000"),new SectorKeySet(){Sector=2,KeyType=KeyType.KeyB,"BBBBBBAAAAAA"),// : 以下略}//こうじゃcard = args.SmartCard.CreateMiFareCard(keySet);,,,//セクターを読んでvar sector = card.GetSector(2);//(必要なら)データブロックごとの権限を設定してforeach (var area in sector.Access.DataAreas) {area.Read = DataAreaAccessCondition.ConditionEnum.KeyAOrB;area.Write = DataAreaAccessCondition.ConditionEnum.KeyB;area.Increment = DataAreaAccessCondition.ConditionEnum.KeyB;area.Decrement = DataAreaAccessCondition.ConditionEnum.KeyB;}//こうじゃawait sector.FlushTrailer("FFFFFFFFFFFF", "FF00FF00FF00");,,,: 以下略
*}
こうじゃ
*card = args.SmartCard.CreateMiFareCard(keySet);
セクターを読んで
*var sector = card.GetSector(2);
*foreach (var area in sector.Access.DataAreas) {*area.Read = DataAreaAccessCondition.ConditionEnum.KeyAOrB;
(必要なら)データブロックごとの権限を設定して
こうじゃ
*await sector.FlushTrailer("FFFFFFFFFFFF", "FF00FF00FF00");

公開変数
public int maxDuration;                  最大の録音時間（20秒とか）
public AudioClip audioClip;              音声データ
非公開変数
private const int sampleRate = 16000;    録音のサンプリングレート
private string mic;                      マイクのデバイス名
*public void StartRecord()
*if (Microphone.devices.Length == 0)*{
マイク存在確認
マイク名
*mic = Microphone.devices[0];
録音開始。audioClipに音声データを格納。
*audioClip = Microphone.Start(mic, false, maxDuration, sampleRate);
マイクの録音位置を取得
*int position = Microphone.GetPosition(mic);
マイクの録音を強制的に終了
*Microphone.End(mic);
再生時間を確認すると、停止した時間に関わらず、maxDurationの値になっている。これは無音を含んでいる？
*Debug.Log("修正前の録音時間: " + audioClip.length);
音声データ一時退避用の領域を確保し、audioClipからのデータを格納
*float[] soundData = new float[audioClip.samples * audioClip.channels];
新しい音声データ領域を確保し、positonの分だけ格納できるサイズにする。
*float[] newData = new float[position * audioClip.channels];
*for (int i = 0; i <; newData.Length; i++)*{
positionの分だけデータをコピー
新しいAudioClipのインスタンスを生成し、音声データをセット
*AudioClip newClip = AudioClip.Create(audioClip.name, position, audioClip.channels, audioClip.frequency, false);
audioClipを新しいものに差し替え
*AudioClip.Destroy(audioClip);
再生時間
*Debug.Log("修正後の録音時間: " + newClip.length);

*public class EDITOR_FileOpenInApp: EditorWindow {[MenuItem("Assets/Open in System Default Application")]private static void GetSelectFile(){if(Selection.assetGUIDs != null &amp;&amp; Selection.assetGUIDs.Length >; 0){List<;string>; fileList = new List<;string>;();foreach(var files in Selection.assetGUIDs){var path = AssetDatabase.GUIDToAssetPath(files);fileList.Add(path);}foreach (string directory in fileList) {Command("open " + Application.dataPath + directory.Substring(6, directory.Length - 6));}}}static string Command(string cmd){var p = new Process();p.StartInfo.FileName = "/bin/bash";p.StartInfo.Arguments = "-c \" " + cmd + " \"";p.StartInfo.UseShellExecute = false;p.StartInfo.RedirectStandardOutput = true;p.Start();var output = p.StandardOutput.ReadToEnd();p.WaitForExit();p.Close();return output;}}
システムのデフォルトアプリケーションでファイルを開く機能を
*public class EDITOR_FileOpenInApp: EditorWindow {[MenuItem("Assets/Open in System Default Application")]private static void GetSelectFile(){if(Selection.assetGUIDs != null &amp;&amp; Selection.assetGUIDs.Length >; 0){List<;string>; fileList = new List<;string>;();foreach(var files in Selection.assetGUIDs){var path = AssetDatabase.GUIDToAssetPath(files);fileList.Add(path);}foreach (string directory in fileList) {Command("open " + Application.dataPath + directory.Substring(6, directory.Length - 6));}}}static string Command(string cmd){var p = new Process();p.StartInfo.FileName = "/bin/bash";p.StartInfo.Arguments = "-c \" " + cmd + " \"";p.StartInfo.UseShellExecute = false;p.StartInfo.RedirectStandardOutput = true;p.Start();var output = p.StandardOutput.ReadToEnd();p.WaitForExit();p.Close();return output;}}
Projectウィンドウのファイル選択→右クリック、または左上のAssetsボタンから呼ぶことができる

*int result = DateTime.Compare(date1, date2);
比較
現在時刻が対象先の日付時刻よりも早い場合の処理
*}
現在時刻が対象先の日付時刻よりも遅い場合の処理
Close();アプリケーション終了
*}

コルーチンを開始
*StartCoroutine(TurnEndProcessing());
*{//1.勝敗判定if (CheckAlive()) {yield break;}//2.同速チェックと並び替えbool isSame = Sort ();//3.天候解除if (WeatherProcessing ()) {yield return new WaitForSeconds (1f);}/* 中略 *///4.素早さが同じ場合は順番をシャッフルするShuffle (isSame);//5.毒ダメージforeach (var item in SortedUnits) {if (PoizonProcessing (item)) {yield return new WaitForSeconds (0.5f);}}/* 中略 *///6.勝敗判定if (CheckAlive()) {yield break;}//7.交代の有無を確認if(CheckChange()){//交代の処理CharacterChange();} else {//ターン開始に移る処理TurnStart();}}
コルーチン処理
*if (CheckAlive()) {*yield break;
1.勝敗判定
2.同速チェックと並び替え
*bool isSame = Sort ();
*if (WeatherProcessing ()) {*yield return new WaitForSeconds (1f);
3.天候解除
4.素早さが同じ場合は順番をシャッフルする
*Shuffle (isSame);
*foreach (var item in SortedUnits) {*if (PoizonProcessing (item)) {
5.毒ダメージ
*if (CheckAlive()) {*yield break;
6.勝敗判定
*if(CheckChange()){*//交代の処理
7.交代の有無を確認
*} else {
交代の処理
ターン開始に移る処理
*TurnStart();
myPokemonとenemyPokemonの素早さを比較
素早さが高い順にSortedPokemonsにAddする
素早さが同じ場合はtrue,それ以外はfalseを返す
*}
素早さが同じ場合は順番のシャッフルを行う
素早さが同じでない場合は何もしない
*}
天候解除の有無を判定する
天候解除ありの場合はエフェクトやUI表示を更新してtrueを返す
それ以外はfalseを返す
*}
pokemonが瀕死状態ならfalseを返して終了する
pokemonが毒状態ならエフェクトと毒ダメージの処理を行う
それ以外はfalseを返す
*}
対戦の勝敗判定を行う
勝ちまたは負けの判定が出た場合はtrueを返す
それ以外はfalseを返す
*}
交代の有無を判定して交代が必要な場合はtrueを返す
*}
ポケモンの交代の必要があれば交代画面に映る
*}
ターン開始時に移る
*}

nums は、_Solveの作業用領域
*var nums = new List<;int>;();
*private IEnumerable<;int[]>; _Solve(List<;int>; nums) {if (IsRight(nums)) {if (nums.Count() == 9) {// 解が求まったyield return nums.ToArray();} else {for (int i = 1; i <;= 9; i++) {if (nums.Contains(i))continue;// i をリストに入れて試すnums.Add(i);// _Solveを再帰的に呼び出す。foreach (var ans in _Solve(nums))yield return ans.ToArray();// 次のiを試すために、iをリストから削除する。nums.Remove(i);}}}// 現在のnumsでの試行が終了した。}
バックトラックにより、解を求める。
*} else {
解が求まった
i をリストに入れて試す
*nums.Add(i);
*foreach (var ans in _Solve(nums))*yield return ans.ToArray();
_Solveを再帰的に呼び出す。
次のiを試すために、iをリストから削除する。
*nums.Remove(i);
現在のnumsでの試行が終了した。
*}
９つ揃っていなくても、途中までを判断する。
完全な誤りならば、falseを返す。そうでないならば、trueを返す
例えば、[4, 9, 1]というリストは、まだ間違いとは言えないので、trueが返る。
これを元に枝刈りをする。
*private bool IsRight(List<;int>; nums) {
まだ、海のものとも山のものともわからない。次を調べる必要があるから、trueを返す。
*return true;
小町リングになっていない
*return false;
現時点で、小町リングになっている
*return true;
*private IEnumerable<;int>; GetSums(List<;int>; nums) {int length = nums.Count;if (length <; 2)yield break;yield return nums[0] + nums[1];for (int i = 3; i <; length; i += 2) {yield return nums[i - 2] + nums[i - 1] + nums[i];}if (length == 9)yield return nums[7] + nums[8];}
numsの値をもとに、各リング内の合計を求める。
*private IEnumerable<;int>; GetSums(List<;int>; nums) {int length = nums.Count;if (length <; 2)yield break;yield return nums[0] + nums[1];for (int i = 3; i <; length; i += 2) {yield return nums[i - 2] + nums[i - 1] + nums[i];}if (length == 9)yield return nums[7] + nums[8];}
nums.Length ==9 ならば、5つの値(合計)が列挙される。

*var client = new MongoClient("mongodb:
localhost:27017");
*new WriterOptions(SharpCompress.Common.CompressionType.None) { LeaveStreamOpen = true }))
Create Tar
*new WriterOptions(SharpCompress.Common.CompressionType.None) { LeaveStreamOpen = true }))
Create Tar

*b = new sample();
インスタンスを作成

*{if (Input.GetKeyDown(KeyCode.Space)){_behaviour.Move(this);}}
Update is called once per frame

*data += vb.ToString() + ",";
12

*Console.WriteLine(x <; y ? x : y);
2

*client.BaseAddress = new Uri("https:
spla2.yuu26.com");

*foreach (var r in randomEpoch)*{
メモリあふれるので行単位で
参考：http:www.npgsql.org/doc/types/datetime.html
*case "tstz":
SELECT *　FROM テーブル(各3回)
*result.AppendLine("--- SELECT *　FROM テーブル ---");
SELECT * FROM テーブル ORDER BY tstz(各5回)
*result.AppendLine("--- SELECT *　FROM テーブル ORDER BY tstz---");
結果の保存
*System.IO.File.WriteAllText("indexbench.txt", result.ToString());

*if (flag)*{
一回の押下で複数回動作しないようにするフラグ

選択時にSelectAllにする場合はこちら
AssociatedObject.Select(0, AssociatedObject.Text.Length);
*}
ToDisplayString:表示できる形式で書式設定された文字列
*AssociatedObject.Text = Provider.ToDisplayString();
*if (Provider.Replace(e.Text, position))*position++;
上書きモード
*if (Provider.InsertAt(e.Text, position))*position++;
挿入モード
*if (Provider.ToDisplayString().Equals(AssociatedObject.Text))*return;
同じときは更新なし

パラメータやアップロードファイルなどあればセットする
リクエストBodyの形式を指定
*request.RequestFormat = DataFormat.Json;
Body部分にJson文字列をセット
名前部分にapplication/jsonを指定し、パラメータタイプにRequestBodyを指定
*request.AddParameter("application/json", jsonString, ParameterType.RequestBody);

*BeginInvoke(d, new object[] { text });
&lt;--ここを変える

*var format = img.Format;
画像フォーマット
*if (format == PixelFormat.Format48bppRgb)*{
画像フォーマット毎に処理

*if (view.distance <;= 0.0f)*return;
can't draw

*a += new SomeDelegate(dt2.FuncC);
FuncCを追加
引数を渡す場合は同じ型でなければならない
*a(10);

文字の名前
*private char charname;
大きな文字を表現する文字列
*private String fontdata;
*{Console.Write(fontdata);}
大きい文字を表示
既に作ったBigCharのインスタンスを管理
*private Hashtable pool = new Hashtable();
Singletonパターン
*private static BigCharFactory bigCharFactory = new BigCharFactory();
*{BigChar bigChar = (BigChar)pool["" + charname];if (bigChar == null){bigChar = new BigChar(charname);pool.Add("" + charname, bigChar);}return bigChar;}
BigCharのインスタンス作成
「大きな文字」の配列
*private BigChar[] bigchars;
*{for(int i=0; i <; bigchars.Length; i++){bigchars[i].print();}}
表示

*if (message.Author.IsBot) { return; }*int argPos = 0;
コメントがユーザーかBotかの判定
*if (!(message.HasCharPrefix('.', ref argPos) || message.HasMentionPrefix(client.CurrentUser, ref argPos))) { return; }*var context = new CommandContext(client, message);
コマンドかどうか判定（今回は、「.」で判定）
実行
*var result = await commands.ExecuteAsync(context, argPos, services);
*if (!result.IsSuccess) { await context.Channel.SendMessageAsync(result.ErrorReason); }*}
実行できなかった場合

*if (!Item1Value.HasValue) return null;
null値の場合はGet~すると死ぬのでここで返す
*{JsonValueKind.String =>; Item1Value.Value.GetString(),JsonValueKind.Number=>; Item1Value.Value.GetInt32().ToString(),// object,arrayのコード例// JsonValueKind.Object =>; new[] {  JsonSerializer.Deserialize<;HogeHoge>;(ItemValue.Value.GetRawText()) },// JsonValueKind.Array =>; JsonSerializer.Deserialize<;HogeHoge[]>;(ItemValue.Value.GetRawText()),_ =>; throw new NotSupportedException()}
任意の変換処理
*// JsonValueKind.Object =>; new[] {  JsonSerializer.Deserialize<;HogeHoge>;(ItemValue.Value.GetRawText()) },
object,arrayのコード例

私の好きなものは寿司です。
*this.label1.Text = Common.Class1.CreateIntroduction("寿司");
私の好きなものは野球です。
*this.label1.Text = Common.Class1.CreateIntroduction("野球");
*if (isShout)*{
シャウトするかどうか
*if (random.Next(0, 10) % 2 == 0)*{
ランダムな数字を作成し、偶数ならシャウトする
私の好きなものは寿司です。/ オレの好きなものは寿司だぜ！！
*this.label1.Text = Common.Class1.CreateIntroduction("寿司", isShout);
シャウト版
*return CreateIntroductionShout(strFavorite);
シャウトしない版
*return CreateIntroduction(strFavorite);

*while (true) {*Console.Write("input dice >; ");
繰り返しテストできるように無限ループ
*if (match.Groups[0].Length == 0)*{
処理が間違ってたら後続処理を中断
ダイス判定処理
*int NumberOfDice=0;
*if(match.Groups[1].Length >; 0)*{
ダイスの数量指定がない時は1を指定する

*if (result == null)*{
キャッシュにないの場合
*{var ret = base.SaveChanges();HttpRuntime.Cache.Remove(cacheKey);return ret;}
作成更新削除があったらこのメソッドでキャッシュをクリアします。
Index 等の実装・・・
*}

*this.speed *= 0.98f;
徐々に減速
効果音再生
*GetComponent<;AudioSource>;().Play();

ローカル変数が優先され、999のダメージを与えることになる。
*}

Commonプロジェクトの関数を使えるようになった
*this.label1.Text = Common.Class1.CreateIntroduction("野球");
Usingディレクティブを使った場合
*using Common;
「Common.」は書かなくてもCommonの中のClass1なんだと分かってくれる
*this.label1.Text = Class1.CreateIntroduction("野球");

*void Start () {SayHello();}
Use this for initialization
*void Start () {CallName("Tom");}
Use this for initialization
*void Start () {int answer;answer = Add(2, 3);Debug.Log(answer);}
Use this for initialization

5スレッド使う
*List<;Task>; tasks = new List<;Task>;(5);

回転の中心を（1,2,3)とする
*Vector3 RotCenter = new Vector3(1, 2, 3);

*int v = PlayerPrefs.GetInt("Test");
testというキーで読み出し

*using UnityEngine.UI;
ここ注意
変数設定
*float m_X;
知りたい座標のGaeObjectの設定
*public GameObject target;
*void Start () {}
Use this for initialization
*void Update () {//それぞれに座標を挿入m_X = target.transform.position.x;m_Y = target.transform.position.y;m_Z = target.transform.position.z;//テキストに表示this.GetComponent<;Text>; ().text = "X座標は" + m_X.ToString() + "\nY座標は" + m_Y.ToString() + "\nZ座標は" + m_Z.ToString();}
Update is called once per frame
*m_X = target.transform.position.x;*m_Y = target.transform.position.y;
それぞれに座標を挿入
テキストに表示
*this.GetComponent<;Text>; ().text = "X座標は" + m_X.ToString() + "\nY座標は" + m_Y.ToString() + "\nZ座標は" + m_Z.ToString();

*g3.GetComponent<;RectTransform<;().sizeDelta = new Vector2(t.preferredWidth, t.preferredHeight);
2回必要

検索コマンドの実行可否 更新
*SearchCommand?.ChangeCanExecute();
*{IsBusy = false;TargetPath = @"C:\ProgramData";PathList = new ObservableCollection<;string>;();});
ウィンドウ起動
検索
*SearchCommand = CommandFactory.Create(
パスが空のときは無効
*return !string.IsNullOrWhiteSpace(TargetPath);
すぐ終わらないよう少し待つ
*await Task.Delay(100);
1つ返す
*yield return dir;
処理成功したらtrue
*return true;

*var encode = new UTF8Encoding(false);
BOMなしUTF8
*{var binary = LZ4MessagePackSerializer.Serialize<;string>;(str);fs.Write(binary, 0, binary.Length);}
MessagePackのLZ4
MessagePackでPack（匿名型もいける）
*var msgpackBinary = MessagePackSerializer.Serialize<;dynamic>;(data);
*using (var fs = new FileStream("frameformat.msg.lz4", FileMode.Create, FileAccess.Write))*using (var lz4Stream = LZ4Stream.CreateCompressor(fs, LZ4StreamMode.Write))
IonKiwi.lz4.netでFrame Fomat圧縮
IonKiwi.lz4.netでFrame Fomat解凍
*byte[] decompBinary;
MessagePackのUnpack
*var obj = MessagePackSerializer.Deserialize<;dynamic>;(decompBinary);
id:1 str:じゅげむ
id:2 str:じゅげむ
id:3 str:ごこうのすりきれ
id:4 str:かいじゃりすいぎょの
id:5 str:すいぎょうまつ
id:6 str:うんらいまつ
id:7 str:ふうらいまつ
id:8 str:くうねるところにすむところ
id:9 str:やぶらこうじのぶらこうじ
id:10 str:ぱいぽ
id:11 str:ぱいぽ
id:12 str:ぱいぽのしゅーりんがん
id:13 str:しゅーりんがんのぐーりんだい
id:14 str:ぐーりんだいのぽんぽこぴーの
id:15 str:ぽんぽこなーの
id:16 str:ちょうきゅうめいのちょうすけ
*,,,

*Debug.Log(objectName);
オブジェクト名をコンソールに表示

*).Subscribe(x =<; Debug.Log('OK'))
NG

*{var alphabets = "ABC";foreach (var (alphabet, index) in alphabets.WithIndex()){Console.WriteLine("{0} =>; {1}", index, alphabet);}}
利用例

*self.level = 1;
これはコンストラクタをサボってる
*public static List<;QuestResult>; All { get; set; }
ロードは後で書く

*if (Controller.isGrounded &amp;&amp; FallSpeed <;= 0)*FallSpeed = Physics.gravity.y * (GravityModifier * 0.002f);
calculate gravity influence

RootDialogとなっている部分を上で作成したクラス名に変更
*await Conversation.SendAsync(activity, () =>; new Dialogs.RootDialog());
*{var bestAnswer = result.Answers.First();await context.PostAsync($"{bestAnswer.Answer}");if (result.Answers.Count >; 1){var sb = new StringBuilder();sb.Append("以下の情報も関連しているかもしれません");int count = 0;foreach (var answer in result.Answers.Skip(1)){count += 1;sb.Append($"\n\n{count}.{answer.Answer}\n\n");}await context.PostAsync(sb.ToString());}}
複数の解答を返したい場合
*{if (!IsConfidentAnswer(result)){var sb = new StringBuilder();sb.Append("以下の情報が関連しているかもしれません");int count = 0;foreach (var answer in result.Answers){count += 1;sb.Append($"\n\n{count}.{answer.Answer}\n\n");}await context.PostAsync(sb.ToString());}}
スコアが低い解答しか得られない場合

*new Idol("安部菜々", 17),
ウーサミン！
*// [0] {[17, 安部菜々]}
あくまでLINQによる解決策
*// [0] {[17, 安部菜々]}
dicの中身はKeyValuePair&lt;int, string&gt;型で
*// [1] {[12, 櫻井桃華]}
[0] {[17, 安部菜々]}
*// [2] {[22, 相原雪乃]}
[1] {[12, 櫻井桃華]}
[2] {[22, 相原雪乃]}
*var dic = list.GroupBy(idol =>; idol.Value)

*mPlayer.time = 15f;
こんな感じで再生途中再生したい時間を

*Console.WriteLine(string.Join(", ", z1));
0, 1, 2
[-1, 1, 2], [10, 11, 12] ← 2次元の場合はディープコピーにならない
*,,,
*{new {Id = 1, Name = "スライム", MaxHp = 10},new {Id = 2, Name = "ドラキー", MaxHp = 15},new {Id = 3, Name = "スライムベス", MaxHp = 20}};
匿名型でマスターデータを定義
*{//Battleのオブジェクト作成はこれだけvar battle = idlist.Select(x =>; masterEnemy.Where(y =>; y.Id == x).FirstOrDefault()).OrderBy(x =>; x.Id).Select(x =>; new { Id = x.Id, Name = x.Name, NowHp = x.MaxHp, MaxHp = x.MaxHp }).ToArray();//Consoleに表示foreach (var x in battle) Console.WriteLine($"{x.Name} があらわれた！ HP:{x.NowHp}/{x.MaxHp}");return battle;};
匿名型を返せないのでdynamicで
Battleのオブジェクト作成はこれだけ
*var battle = idlist.Select(x =>; masterEnemy.Where(y =>; y.Id == x).FirstOrDefault())
*foreach (var x in battle) Console.WriteLine($"{x.Name} があらわれた！ HP:{x.NowHp}/{x.MaxHp}");*return battle;
Consoleに表示
スライム があらわれた！ HP:10/10
ドラキー があらわれた！ HP:15/15
ドラキー があらわれた！ HP:15/15
スライムベス があらわれた！ HP:20/20
*,,,

*link_names = "1"
メンションを有効にする

全メールのUIDL取得
*List<;string>; uidList = client.GetMessageUids();
*for (int i = 1; i <;= client.GetMessageCount(); i++)*{
全メール古い順で繰り返し処理
メール情報取得
*Message message = client.GetMessage(i);
差出人メールアドレス取得
*fromAddress = message.Headers.From.MailAddress.Address;
件名取得
*subject = message.Headers.Subject;
UID取得
*uid = client.GetMessageUid(i);
本文取得
*var plainText = message.FindFirstPlainTextVersion();
*Console.WriteLine("UID={0} ,FROM={1} ,SUBJECT={2}", uid, fromAddress, subject);
取得情報出力
*catch (Exception e) {Console.WriteLine(e.Message);}
Console.WriteLine("BODY={0}", body);

サーバーを起動する処理、ここから
*const int Port = 50051;
サーバーを起動する処理、ここまで
*Channel channel = new Channel("127.0.0.1:50051", ChannelCredentials.Insecure);
起動したサーバーをシャットダウンする処理、ここから
*server.ShutdownAsync().Wait();
起動したサーバーをシャットダウンする処理、ここまで
*return reply;
*{// Server side handler of the SayHello RPCpublic override Task<;HelloReply>; SayHello(HelloRequest request, ServerCallContext context){return Task.FromResult(new HelloReply { Message = "Hello " + request.Name });}}
サーバーサイドの処理、ここから
*{return Task.FromResult(new HelloReply { Message = "Hello " + request.Name });}
Server side handler of the SayHello RPC
サーバーサイドの処理、ここまで
*}
*return Task.FromResult(new HelloReply { Message = "Hello Server " + request.Name });
"Hello "から"Hello Server "に文字列を修正

*var url = "http:
〇〇.comuploadfile.php";

*if (!FindDevice (ref device)) {*Debug.LogError(";"+deviceNameKeyword+">;を含むWebカメラが検出できませんでした。");
参照渡しでdeviceを書き換え

画像をデコード
*BitmapDecoder decoder = BitmapDecoder.Create(
拡大/縮小したイメージを生成する
*double scaleX = (double)scaledWidth / decoder.Frames[0].PixelWidth;
*bmp = new TransformedBitmap(decoder.Frames[0], new ScaleTransform(scale, scale));*}
TransformedBitmapをそのまま保持する
原寸でイメージを生成する
*bmp = new WriteableBitmap(decoder.Frames[0]);
*bmp = new WriteableBitmap(new TransformedBitmap(decoder.Frames[0], new ScaleTransform(scale, scale)));*,,,
生成したTransformedBitmapから再度WritableBitmapを生成する

*var seq = new List<;Foo>; {new Foo { Id = 2 }, new Foo { Id = 0 }, new Foo { Id = 1 },};
Fooのリストを生成
Fooのリストに対しクエリを発行
*var query = from x in seq
*foreach (var q in query) {Console.WriteLine ("{0}", q);}
ループ開始

マウス座標取得
*var element = (System.Windows.IInputElement)param;

*Console.WriteLine(Config.Mossari.Get());
"fusafusa"と出力

*SFML.Window.Styles.Close
ウィンドウ右上に×ボタンを設置
window.Closedイベントで、
×ボタンが押されたときの処理を追加できる

window.Close関数を呼ぶとウィンドウを閉じる
*window.Closed += (sender, e) =>; window.Close();
*while (window.IsOpen) {*//ウィンドウのイベント処理を実行
メインループを開始
ウィンドウのイベント処理を実行
（必ずこれを実行すること！）
*window.DispatchEvents();
画像を読み込み
*var image = new Image("0.png");
画像をテクスチャに変換
*var texture = new Texture(image);
*while (window.IsOpen) {window.DispatchEvents();//ウィンドウを黒で塗りつぶすwindow.Clear();sprite.Position = new SFML.System.Vector2f(20, 20);//画像の描画window.Draw(sprite);//描画したものを表示window.Display();}
描画用オブジェクトを作成
ウィンドウを黒で塗りつぶす
*window.Clear();
画像の描画
*window.Draw(sprite);
描画したものを表示
*window.Display();
フォント読み込み
*var font = new Font(fontName);
*while (window.IsOpen) {window.DispatchEvents();//ウィンドウを黒で塗りつぶすwindow.Clear();text.Position = new SFML.System.Vector2f(20, 20);//テキストを描画window.Draw(text);//描画したものを表示window.Display();}
テキスト描画用オブジェクトを作成
ウィンドウを黒で塗りつぶす
*window.Clear();
テキストを描画
*window.Draw(text);
描画したものを表示
*window.Display();
*foreach (var i in textStr) {//フォントテクスチャに、//指定した文字を書き込むfont.GetGlyph(i, textSize, false);}
フォント読み込み
フォントテクスチャに、
指定した文字を書き込む
*font.GetGlyph(i, textSize, false);
フォントからテクスチャを作成
*var texture = font.GetTexture(textSize);
*for (var i = 0; i <; textStr.Length; i++) {//表示したい文字を描画するためのデータを取得var glyph = font.GetGlyph(textStr[i], textSize, false);sprite.Position = new SFML.System.Vector2f(20 + textSize * i, 20);sprite.TextureRect = glyph.TextureRect;//文字列を表示window.Draw(sprite);}
ウィンドウを黒で塗りつぶす
表示したい文字を描画するためのデータを取得
*var glyph = font.GetGlyph(textStr[i], textSize, false);
文字列を表示
*window.Draw(sprite);
描画したものを表示
*window.Display();
音再生用オブジェクトの作成

WAVファイルとOGGファイルの再生が
できることを確認

MIDとMP3の再生は残念ながらできない
（読み込み時にエラーが出る）
*var music = new Music("0.wav");
Loopプロパティでループ再生できるかどうかを指定できる
（ただし、Play関数を呼ぶ前に指定しないと反映されない）
初期値はfalse

falseならループしない
trueならループする
*music.Loop = true;
*while (window.IsOpen) {window.DispatchEvents();}
音再生の開始
フレームレートの指定
引数はuint型

（この例では60 Fpsを指定）
*window.SetFramerateLimit(fps);
この関数を使うと、
window.SetFramerateLimit関数で指定したFpsになる

（この例では60 Fpsになる）
*window.Display();
既定のスプライトを表示
*window.Draw(sprite);
自作スプライトを表示
*window.Draw(spriteTester);
スプライトを使わずに画像を表示
*TextureDrawer.Draw(window, texture, 20, 100);
*static class TextureDrawer {public　static Vertex[] Vertexs { get; } = new Vertex[4];public static void Draw(RenderTarget target,Texture texture, float x, float y){//描画データの指定var transform = Transform.Identity;//描画範囲を指定var left = x;var right = x + texture.Size.X;var top = y;var bottom = y + texture.Size.Y;//左上Vertexs[0].Position = new Vector2f(left, top);Vertexs[0].TexCoords = new Vector2f(0, 0);//左下Vertexs[1].Position = new Vector2f(left, bottom);Vertexs[1].TexCoords = new Vector2f(0, texture.Size.Y);//右上Vertexs[2].Position = new Vector2f(right, top);Vertexs[2].TexCoords = new Vector2f(texture.Size.X, 0);//右下Vertexs[3].Position = new Vector2f(right, bottom);Vertexs[3].TexCoords = new Vector2f(texture.Size.X, texture.Size.Y);for (var i = 0; i <; Vertexs.Length; i++) {//new Color(255, 255, 255, 255)//で画像の色変更なしVertexs[i].Color = new Color(255, 255, 255, 255);}var states = default(RenderStates);//これも指定しないと表示されないstates.BlendMode = BlendMode.Alpha;//描画データをstatesに指定するstates.Transform = transform;//テクスチャをstatesに指定する////states.Textureがnullの場合は矩形が表示されるstates.Texture = texture;//描画開始target.Draw(Vertexs, 0, (uint)Vertexs.Length, PrimitiveType.TrianglesStrip, states);}}
スプライトを使わずに画像を表示するためのクラス
*var transform = Transform.Identity;*//描画範囲を指定
描画データの指定
描画範囲を指定
*var left = x;
左上
*Vertexs[0].Position = new Vector2f(left, top);
左下
*Vertexs[1].Position = new Vector2f(left, bottom);
右上
*Vertexs[2].Position = new Vector2f(right, top);
右下
*Vertexs[3].Position = new Vector2f(right, bottom);
で画像の色変更なし
*Vertexs[i].Color = new Color(255, 255, 255, 255);
これも指定しないと表示されない
*states.BlendMode = BlendMode.Alpha;
*states.Transform = transform;*//テクスチャをstatesに指定する
描画データをstatesに指定する
テクスチャをstatesに指定する

states.Textureがnullの場合は矩形が表示される
*states.Texture = texture;
描画開始
*target.Draw(Vertexs, 0, (uint)Vertexs.Length, PrimitiveType.TrianglesStrip, states);
*sealed class SpriteTester : Drawable {public Vertex[] Vertexs { get; } = new Vertex[4];public Texture Texture { get; }public Transform Transform { get; set; }public float X { get; set; }public float Y { get; set; }public float Width { get; set; }public float Height { get; set; }public float Left =>; X;public float Right =>; X + Width;public float Top =>; Y;public float Bottom =>; Y + Height;public SpriteTester(Texture texture) {//テクスチャの指定Texture = texture;//描画データの指定Transform = Transform.Identity;Width = Texture.Size.X;Height = Texture.Size.Y;}public void Draw(RenderTarget target, RenderStates states) {//左上Vertexs[0].Position = new Vector2f(Left, Top);Vertexs[0].TexCoords = new Vector2f(0, 0);//左下Vertexs[1].Position = new Vector2f(Left, Bottom);Vertexs[1].TexCoords = new Vector2f(0, Height);//右上Vertexs[2].Position = new Vector2f(Right, Top);Vertexs[2].TexCoords = new Vector2f(Width, 0);//右下Vertexs[3].Position = new Vector2f(Right, Bottom);Vertexs[3].TexCoords = new Vector2f(Width, Height);for (var i = 0; i <; Vertexs.Length; i++) {//new Color(255, 255, 255, 255)//で画像の色変更なしVertexs[i].Color = new Color(255, 255, 255, 255);}//描画データをstatesに指定するstates.Transform = Transform;//テクスチャをstatesに指定する////states.Textureがnullの場合は矩形が表示されるstates.Texture = Texture;//描画開始target.Draw(Vertexs, 0, (uint)Vertexs.Length, PrimitiveType.TrianglesStrip, states);}}
自作スプライト
テクスチャの指定
*Texture = texture;
*Transform = Transform.Identity;*Width = Texture.Size.X;
描画データの指定
左上
*Vertexs[0].Position = new Vector2f(Left, Top);
左下
*Vertexs[1].Position = new Vector2f(Left, Bottom);
右上
*Vertexs[2].Position = new Vector2f(Right, Top);
右下
*Vertexs[3].Position = new Vector2f(Right, Bottom);
で画像の色変更なし
*Vertexs[i].Color = new Color(255, 255, 255, 255);
*states.Transform = Transform;*//テクスチャをstatesに指定する
描画データをstatesに指定する
テクスチャをstatesに指定する

states.Textureがnullの場合は矩形が表示される
*states.Texture = Texture;
描画開始
*target.Draw(Vertexs, 0, (uint)Vertexs.Length, PrimitiveType.TrianglesStrip, states);

*ScriptManager.ScriptResourceMapping.AddDefinition("vue", null, scriptRefVue);
ここで指定した名前がマッピングされる

*Console.WriteLine(result);
200

*UnityWebRequest liverequest = UnityWebRequest.Get(urisample);
testURI + apikey);
MiniJSON　つかうー！！！！
*var mjson = (IDictionary)MiniJSON.Json.Deserialize(jsontext);
videoIdを取得
*videoId = (string)sid["videoId"];
ChatIdを取得しにいくよ！！
*var searchChannel = youtubeAPIbase + channnelSearch + videoId + "&amp;key=" + apikey;
chatIdを取得
*chatId = (string)clad["activeLiveChatId"];
チャットを取りに行く！！！
*var chatURI = youtubeAPIbase + chatURIUp + chatId + pagetoken + nextPageTokenstr + chatURIbottom2 + apikey;
*if(nextPageTokenstr == (string)commentlogjson["nextPageToken"])*{
このif文は全くの無意味
*for(var i = 0; i <; (int)commentcount; i++)*{
コメント分だけ描画
Youtubeへ接続しに行ってます
*}
videoIdを基に、chatIdを探しに行っています。
*}
chatIdを基に、コメントを取得します。
*}
StartCoroutine(GetComment()); で、コメントを再取得しにいっています。
*}
中略
*nextPageTokenstr = (string)commentlogjson["nextPageToken"];
チャットを取りに行く！！！
*var chatURI = youtubeAPIbase + chatURIUp + chatId + pagetoken + nextPageTokenstr + chatURIbottom2 + apikey;
中略
使うときに生成
*GameObject cvn = Instantiate(canvas);
パーッ寿司ながら中身取り出しにいく。
*var citems = (IList)commentlogjson["items"];
*cvn.transform.Find("Description").gameObject.GetComponent<;Text>;().text = message;*var author = (IDictionary)cslsd["authorDetails"];
本文を取得
*cvn.transform.Find("Name").gameObject.GetComponent<;Text>;().text = dispName;*,,,
名前をつける

*textWords[i, n] = tempWords[n];
2次配列textWordsにカンマごとに分けたtempWordsを代入していく

MiniJSON　つかうー！！！！
*var mjson = (IDictionary)MiniJSON.Json.Deserialize(jsontext);
videoIdを取得
*videoId = (string)sid["videoId"];

エンティティを追加
*builder.EntitySet<;Customer>;("Customers");
オプションを有効化 ↓この行を追加（必要なものだけでOK）
*config.Count().Filter().OrderBy().Expand().Select().MaxTop(null);

newするとサーバが起動する.CancellationTokenが必要.
任意でポート番号も指定できる.デフォルトは1234.
*_easyHttpRPC = new EasyHttpRPC(this.GetCancellationTokenOnDestroy());
外から呼び出すメソッドを登録する.
*_easyHttpRPC.RegisterRPC(nameof(Instantiate), Instantiate);
引数のNameValueCollectionにはGetのパラメータがそのまま入っている.
Taskなので終了まで待ってからレスポンスを返せる.
*private async Task<;string>; Instantiate(NameValueCollection arg)

*{
出力
二乗誤差
double dE = Y - a_mul_b;計算省略のため二乗誤差微分後の値
記録
*string rec = p.ToString() + "," + a.ToString() + "," + b.ToString() + "," + a_mul_b.ToString() + ",";
逆伝播
∂E/∂In
double[] dE_dI = new double[cell];
for (int cl = 0; cl &lt; cell; cl++)
{
dE_dI[cl] = 2 * h_in[cl] * w[1][cl, 0] * dE;
}
w-Δw
for (int cl = 0; cl &lt; cell; cl++)
{
w[0][0, cl] = w[0][0, cl] - η * (a * dE_dI[cl]);
w[0][1, cl] = w[0][1, cl] - η * (b * dE_dI[cl]);
}
*for (int cl = 0; cl <; cell; cl++)
最終記録
*string last_rec = new string(',', In + Out + 1);
読取専用
*File.SetAttributes(path, FileAttributes.ReadOnly);

*TcpClient tcp = new TcpClient("127.0.0.1", 8081);
InputHostに接続
*{int x = (int)(p.X / image.ActualWidth * displayWidth);int y = (int)(p.Y / image.ActualHeight * displayHeight);return new Point(x, y);}
マウスの位置を端末のタッチ座標に変換

*ms.Position = 0;
Positionが最後に行っているので最初に戻す
メモリに圧縮
*var compressor = new SevenZipCompressor();
メモリに解凍
*var extractor = new SevenZipExtractor(archiveMemoryStream);

*Console.WriteLine($"(a==1 &amp;&amp; a!=2 &amp;&amp; a==3) : {a == 1 &amp;&amp; a != 2 &amp;&amp; a == 3}");
true

*ServiceStack.Text.JsonSerializer.DeserializeFromStream<;Data<;(sr.BaseStream);
ServiceStackの場合
Jil.JSON.Deserialize&lt;Data&gt;(sr);Jilの場合
Utf8Json.JsonSerializer.Deserialize&lt;Data&gt;(sr.BaseStream);Utf8Jsonの場合
*}
Utf8Json.JsonSerializer.Deserialize&lt;Data&gt;(sr.BaseStream);                                                                                                                               Utf8Json.JsonSerializer.Deserialize&lt;Data&gt;(sr.BaseStream);Utf8Jsonの場合
*}

Chartには、最初からSeriesが設定されているので削除しておく。
*chart1.Series.Clear();

*foreach (var platformInfo in Platform.GetPlatformInfos())*{
シンプルなデバイス情報取得
*var platform = new Platform(0);*var device = platform.CreateDevice(0);
面倒だけど必要なこいつらを手軽に用意
*var data = new float[] { 3F, 4.5F, 0F, -4.4F };
いわゆるcl_memを用いたプログラム
*data = new float[] { 3F, 4.5F, 0F, -4.4F };
CL_MEM_COPY_HOST_PTRを利用した場合
CL_MEM_ALLOC_HOST_PTRを使用した場合(unsafeが必要)
*dataSize = sizeof(float) * 4;
*data = new float[] { 3F, 4.5F, 0F, -4.4F };
CL_MEM_USE_HOST_PTRを使用した場合
SVM(unsafeが必要)
*dataSize = sizeof(float) * 4;
*var platform = new Platform(0);*var device = platform.CreateDevice(0);
面倒だけど必要なこいつらを手軽に用意

指定したキーのデータがなかった時は例外になるので注意
validOrInvalidItems[false].Select(x =&gt; x.Name);
== ["A", "C"]
validOrInvalidItems[true].Select(x =&gt; x.Name);
== ["B", "D"]
*,,,

Gripのボタンの取得
*Input.GetKey("joystick button 5")
*if(Input.GetKey("joystick button 5")){*Debug.Log("GripKey");
押し続けてる間イベントを取得
*if(Input.GetKeyDown("joystick button 5")){*Debug.Log("GripKey");
押したイベントを取得
*if(Input.GetKeyUp("joystick button 5")){*Debug.Log("GripKey");
離したイベントを取得

*{
出力
二乗誤差
double dE = Y - a_mul_b;計算省略のため二乗誤差微分後の値
記録
*string rec = p.ToString() + "," + a.ToString() + "," + b.ToString() + "," + a_mul_b.ToString() + ",";
逆伝播
∂E/∂In
*double[] dE_dI = new double[cell];
*for (int cl = 0; cl <; cell; cl++)*{
w-Δw
最終記録
*string last_rec = new string(',', In + Out + 1);
読取専用
*File.SetAttributes(path, FileAttributes.ReadOnly);

*if(!anim.isPlaying){
&lt;- falseのとき動くかんじにしたかった
実行したい処理
*}

制限時間をセット
*float timer = 10f;
Update()の中などに何度も呼ばれるメソッドの中に記述し、Time.deltaTimeを引きつづける
*timer -= Time.deltaTime;
(参考)
初期化
*float timer = 0f;
カウントアップ
*timer += Time.deltaTime;
制限時間との差を取得しつづける
*limitTime -= Time.deltaTime;
文字列に変換して表示
*timerText.text = limitTime.ToString();
*if(limitTime==0){*// Finishと表示
もし制限時間が0になったら
Finishと表示
*timerText.text = "Finish";
*IEnmerator コルーチン関数名(){// 処理1yield return new WaitforSeconds(止めたい秒数);// 処理2}
処理1と処理2の間で任意の秒数待つ
*yield return new WaitforSeconds(止めたい秒数);*// 処理2
処理1
処理2
*}
制限時間
*public int TIME_LIMIT = 10;
コルーチンを呼ぶ
*StartCoroutine("Timer");
変数へ初期値を代入
*int count = TIME_LIMIT;
*while (count >; 0)*{
カウントが0より大きい時ループ
テキストの更新
*timerText.text = count.ToString();
1秒待機
*yield return new WaitForSeconds(1.0f);
カウントを1減らす
*count--;
テキストの表示
*timerText.text = "Finish";
これはOK
DateTime.Now.AddSeconds(3)で現在時刻より3秒後 , DateTime.Nowで現在時刻を得られます
*TimeSpan timeSpan = DateTime.Now.AddSeconds(3) - DateTime.Now;
現在時刻から3秒後をセット
*limitTime = DateTime.Now.AddSeconds(3);
現在時刻との差を取得しつづける
*timeSpan = LimitTime - DateTime.Now;
文字列に変換して表示
*timerText.text = timeSpan.ToString();
*if(limitTime<;=DateTime.Now){*// Finishと表示
もし現在時刻がStart時点でセットした3秒後の時刻を過ぎたら
Finishと表示
*timerText.text = "Finish";
デフォルト（例:00.00.04のような表示）
*timerText.text = timeSpan.ToString();
s秒（例:4のような表示）
*timerText.text = timeSpan.ToString("s");
ss秒mmミリ秒（例:04.37のような表示）
*timerText.text = timeSpan.ToString("ss':'ff");
ss秒mmmミリ秒（例:04.375のような表示）
*timerText.text = timeSpan.ToString("ss':'fff");
DateTimeだと「:」など文字でないものをシングルクォーテーションで囲まなくてよい
ss秒mmミリ秒（例:04.37のような表示）
*timerText.text = dateTime.ToString("ss:ff");
これはダメ
*DateTime time = DateTime.Now.AddSeconds(3) - DateTime.Now;

ウィンドウメッセージを処理するために
IMessageFilter インターフェイスを実装します。
*public class ImeStatus : IMessageFilter
コンストラクター内で
メッセージフィルターとして自身を登録します。
*Application.AddMessageFilter(this);
アプリケーションがウィンドウメッセージを処理する前に
呼び出されます。
*public bool PreFilterMessage(ref Message m)
日本語入力の開始
*Compositing = true;
日本語入力の終了
*Compositing = false;

*{
列見出し
0.0 以上 1.0 以下の乱数を取得
*Random cRandom = new Random();
*for (int p = 0; p <; 100; p++)*{
学習
値設定
*double a = cRandom.NextDouble();
順伝播
*double Y = a * w[0] + b * w[1];
最小二乗誤差
double dE = Y - a_sub_b;計算省略のため二乗誤差微分後の値
記録
*using (StreamWriter sw = new StreamWriter(path, true, Encoding.Unicode))
逆伝播
*w[0] = w[0] - (a * dE);
*{sw.Write(",,," +w[0].ToString() + "," + w[1].ToString() + "," +"," +Environment.NewLine);}
最終記録
読取専用
*File.SetAttributes(path, FileAttributes.ReadOnly);

*gamer.Bet();
ゲームを進める
*if (gamer.Money >; memento.Money)*{
保存／リストアの判断

クライアント＆リクエストの作成
*var client = new RestClient();
URLの設定
*client.BaseUrl = new Uri("リクエスト先のURLをここに指定する");
メソッド、パラメータの指定
*request.Method = Method.POST;
ParameterTypeはいろいろあるが、GETとPOSTで特に指定なく
stringパラメータを設定する場合は、GetOrPost
ファイルをアップロードする場合
*request.AddFile("ファイルパラメータ名", "ファイルパス", "ContentType");
ContentTypeは拡張子などから適切なものを選ぶ
リクエスト送信
*var response = client.Execute(request);
レスポンスがファイルなどで、復元したい場合
*File.WriteAllBytes("出力先のパス", response.RawBytes);
レスポンスのステータスコードが欲しいなどの場合
*bool isOK = response.StatusCode == HttpStatusCode.OK;

必要なコンポーネントを定義
*[RequireComponent(typeof(TestClassB))]
必要なコンポーネントを定義
*[RequireComponent(typeof(TestClassB))]

*{
列見出し
0.0 以上 1.0 以下の乱数を取得
*Random cRandom = new Random();
*for (int p = 0; p <; 100; p++)*{
学習
値設定
*double a = cRandom.NextDouble();
順伝播
*double Y = a * w[0] + b * w[1];
最小二乗誤差
double dE = Y - a_add_b;計算省略のため二乗誤差微分後の値
記録
*using (StreamWriter sw = new StreamWriter(path, true, Encoding.Unicode))
逆伝播
*w[0] = w[0] - (a * dE);
*{sw.Write(",,," +w[0].ToString() + "," + w[1].ToString() + "," +"," +Environment.NewLine);}
最終記録
読取専用
*File.SetAttributes(path, FileAttributes.ReadOnly);

*var request = new HttpRequestMessage(HttpMethod.Get, "https:
qiita.comtoryuneko");

*if (Value == 1 &amp;&amp; Value == 2 &amp;&amp; Value == 3)*{
ここ

*new UriTemplateAction("住所を送る","line:
nvlocation")
注文だがメニューがわからない場合はメニューをボタンで提示
*replyMessage = new TemplateMessage("menu", new ButtonsTemplate(

*"http:
localhost:8080");

IntPtr型を使用するのに必要
*using System;
Dllの読み込みに必要
*using System.Runtime.InteropServices;
Dll内の関数を宣言
*[DllImport("DllForDebug")]
*{Debug.Log(add_b())}
Use this for initialization
*{}
Update is called once per frame

IntPtr型を使用するのに必要
*using System;
Dllの読み込みに必要
*using System.Runtime.InteropServices;
Dll内の関数を宣言
*[DllImport("DllForDebug")]
*{Loop();}
Use this for initialization
*{Debug.Log(ReturnA());}
Update is called once per frame
IntPtr型を使用するのに必要
*using System;
Dllの読み込みに必要
*using System.Runtime.InteropServices;
Dll内の関数を宣言
*[DllImport("DllForDebug")]
*{}
Use this for initialization
*{LoopNotToUseWhile();Debug.Log(ReturnA());}
Update is called once per frame
IntPtr型を使用するのに必要
*using System;
Dllの読み込みに必要
*using System.Runtime.InteropServices;
Dll内の関数を宣言
*[DllImport("DllForDebug")]
*{ResetConstants();}
Use this for initialization
*{LoopNotToUseWhile();Debug.Log(ReturnA());}
Update is called once per frame

IntPtr型を使用するのに必要
*using System;
Dllの読み込みに必要
*using System.Runtime.InteropServices;
Dll内の関数を宣言
*[DllImport("DllForDebug")]
*{int i = 0;// 格納したい配列先int[] arrInt = new int[5];float[] arrFloat = new float[5];char[] arrChar = new char[5];// 配列の先頭ポインタをIntPtr型の変数にそれぞれ格納するIntPtr ptrInt = ReturnIntArray();IntPtr ptrFloat = ReturnFloatArray();IntPtr ptrChar = ReturnCharArray();// コピーMarshal.Copy(ptrInt, arrInt, 0, 5);Marshal.Copy(ptrFloat, arrFloat, 0, 5);Marshal.Copy(ptrChar, arrChar, 0, 5);// Logfor (i = 0;i <;=4; i++){Debug.Log(arrInt[i]);Debug.Log(arrFloat[i]);Debug.Log(arrChar[i]);}}
Use this for initialization
格納したい配列先
*int[] arrInt = new int[5];
配列の先頭ポインタをIntPtr型の変数にそれぞれ格納する
*IntPtr ptrInt = ReturnIntArray();
コピー
*Marshal.Copy(ptrInt, arrInt, 0, 5);
*for (i = 0;i <;=4; i++)*{
Log
*{}
Update is called once per frame

*cmd.InsertAllWithPrepared(array);
ここがInsertAllからInsertAllWithPreparedに変更
SQLite3.7.11以降可能な書き方＋プリペアドステートメント
プリペアドステートメント
*var sb = new StringBuilder();
パラメーター追加
*command.Parameters.Clear();

*extendStyle &amp;= ~WS_EX_TRANSPARENT;
フラグを消す
WindowHandle(Win32) を取得
*var handle = new WindowInteropHelper( this ).Handle;
Alt + F4 を無効化
*var hwndSource = HwndSource.FromHwnd( handle );
*if ( msg == WM_SYSKEYDOWN &amp;&amp; wParam.ToInt32() == VK_F4 ) {*//処理済みにセットする
Alt + F4 が入力されたら
処理済みにセットする
(Windowは閉じられなくなる)
*handled = true;

*double[] deltaE = new double[] { Y0_out - alpha, Y1_out - beta };
計算省略のため二乗誤差微分後の値
*{sw.Write(a.ToString() + "," + b.ToString() + "," + c.ToString() + "," + d.ToString() + "," +alpha.ToString() + "," + beta.ToString() + "," +w[0][0, 0].ToString() + "," + w[0][0, 1].ToString() + "," + w[0][0, 2].ToString() + "," + w[0][0, 3].ToString() + "," +w[0][1, 0].ToString() + "," + w[0][1, 1].ToString() + "," + w[0][1, 2].ToString() + "," + w[0][1, 3].ToString() + "," +w[0][2, 0].ToString() + "," + w[0][2, 1].ToString() + "," + w[0][2, 2].ToString() + "," + w[0][2, 3].ToString() + "," +w[0][3, 0].ToString() + "," + w[0][3, 1].ToString() + "," + w[0][3, 2].ToString() + "," + w[0][3, 3].ToString() + "," +h_net[0][0].ToString() + "," + h_out[0][0].ToString() + "," +h_net[0][1].ToString() + "," + h_out[0][1].ToString() + "," +h_net[0][2].ToString() + "," + h_out[0][2].ToString() + "," +h_net[0][3].ToString() + "," + h_out[0][3].ToString() + "," +w[1][0, 0].ToString() + "," + w[1][0, 1].ToString() + "," + w[1][0, 2].ToString() + "," + w[1][0, 3].ToString() + "," +w[1][1, 0].ToString() + "," + w[1][1, 1].ToString() + "," + w[1][1, 2].ToString() + "," + w[1][1, 3].ToString() + "," +w[1][2, 0].ToString() + "," + w[1][2, 1].ToString() + "," + w[1][2, 2].ToString() + "," + w[1][2, 3].ToString() + "," +w[1][3, 0].ToString() + "," + w[1][3, 1].ToString() + "," + w[1][3, 2].ToString() + "," + w[1][3, 3].ToString() + "," +w[1][4, 0].ToString() + "," + w[1][4, 1].ToString() + "," + w[1][4, 2].ToString() + "," + w[1][4, 3].ToString() + "," +h_net[1][0].ToString() + "," + h_out[1][0].ToString() + "," +h_net[1][1].ToString() + "," + h_out[1][1].ToString() + "," +h_net[1][2].ToString() + "," + h_out[1][2].ToString() + "," +h_net[1][3].ToString() + "," + h_out[1][3].ToString() + "," +w[2][0, 0].ToString() + "," + w[2][0, 1].ToString() + "," + w[2][0, 2].ToString() + "," + w[2][0, 3].ToString() + "," +w[2][1, 0].ToString() + "," + w[2][1, 1].ToString() + "," + w[2][1, 2].ToString() + "," + w[2][1, 3].ToString() + "," +w[2][2, 0].ToString() + "," + w[2][2, 1].ToString() + "," + w[2][2, 2].ToString() + "," + w[2][2, 3].ToString() + "," +w[2][3, 0].ToString() + "," + w[2][3, 1].ToString() + "," + w[2][3, 2].ToString() + "," + w[2][3, 3].ToString() + "," +w[2][4, 0].ToString() + "," + w[2][4, 1].ToString() + "," + w[2][4, 2].ToString() + "," + w[2][4, 3].ToString() + "," +h_net[2][0].ToString() + "," + h_out[2][0].ToString() + "," +h_net[2][1].ToString() + "," + h_out[2][1].ToString() + "," +h_net[2][2].ToString() + "," + h_out[2][2].ToString() + "," +h_net[2][3].ToString() + "," + h_out[2][3].ToString() + "," +w[3][0, 0].ToString() + "," + w[3][0, 1].ToString() + "," + w[3][0, 2].ToString() + "," + w[3][0, 3].ToString() + "," +w[3][1, 0].ToString() + "," + w[3][1, 1].ToString() + "," + w[3][1, 2].ToString() + "," + w[3][1, 3].ToString() + "," +w[3][2, 0].ToString() + "," + w[3][2, 1].ToString() + "," + w[3][2, 2].ToString() + "," + w[3][2, 3].ToString() + "," +w[3][3, 0].ToString() + "," + w[3][3, 1].ToString() + "," + w[3][3, 2].ToString() + "," + w[3][3, 3].ToString() + "," +w[3][4, 0].ToString() + "," + w[3][4, 1].ToString() + "," + w[3][4, 2].ToString() + "," + w[3][4, 3].ToString() + "," +h_net[3][0].ToString() + "," + h_out[3][0].ToString() + "," +h_net[3][1].ToString() + "," + h_out[3][1].ToString() + "," +h_net[3][2].ToString() + "," + h_out[3][2].ToString() + "," +h_net[3][3].ToString() + "," + h_out[3][3].ToString() + "," +w[4][0, 0].ToString() + "," + w[4][0, 1].ToString() + "," + w[4][0, 2].ToString() + "," + w[4][0, 3].ToString() + "," +w[4][1, 0].ToString() + "," + w[4][1, 1].ToString() + "," + w[4][1, 2].ToString() + "," + w[4][1, 3].ToString() + "," +w[4][2, 0].ToString() + "," + w[4][2, 1].ToString() + "," + w[4][2, 2].ToString() + "," + w[4][2, 3].ToString() + "," +w[4][3, 0].ToString() + "," + w[4][3, 1].ToString() + "," + w[4][3, 2].ToString() + "," + w[4][3, 3].ToString() + "," +w[4][4, 0].ToString() + "," + w[4][4, 1].ToString() + "," + w[4][4, 2].ToString() + "," + w[4][4, 3].ToString() + "," +h_net[4][0].ToString() + "," + h_out[4][0].ToString() + "," +h_net[4][1].ToString() + "," + h_out[4][1].ToString() + "," +h_net[4][2].ToString() + "," + h_out[4][2].ToString() + "," +h_net[4][3].ToString() + "," + h_out[4][3].ToString() + "," +w[5][0, 0].ToString() + "," + w[5][0, 1].ToString() + "," +w[5][1, 0].ToString() + "," + w[5][1, 1].ToString() + "," +w[5][2, 0].ToString() + "," + w[5][2, 1].ToString() + "," +w[5][3, 0].ToString() + "," + w[5][3, 1].ToString() + "," +w[5][4, 0].ToString() + "," + w[5][4, 1].ToString() + "," +Y0_net.ToString() + "," + Y0_out.ToString() + "," + deltaE[0].ToString() + "," +Y1_net.ToString() + "," + Y1_out.ToString() + "," + deltaE[1].ToString() +Environment.NewLine);}
記録
*for (int n = 0; n <; cell; n++)*{
w-((δE/δNET)(δNET/δw))
*{sw.Write(",,,," +",," +w[0][0, 0].ToString() + "," + w[0][0, 1].ToString() + "," + w[0][0, 2].ToString() + "," + w[0][0, 3].ToString() + "," +w[0][1, 0].ToString() + "," + w[0][1, 1].ToString() + "," + w[0][1, 2].ToString() + "," + w[0][1, 3].ToString() + "," +w[0][2, 0].ToString() + "," + w[0][2, 1].ToString() + "," + w[0][2, 2].ToString() + "," + w[0][2, 3].ToString() + "," +w[0][3, 0].ToString() + "," + w[0][3, 1].ToString() + "," + w[0][3, 2].ToString() + "," + w[0][3, 3].ToString() + "," +",," +",," +",," +",," +w[1][0, 0].ToString() + "," + w[1][0, 1].ToString() + "," + w[1][0, 2].ToString() + "," + w[1][0, 3].ToString() + "," +w[1][1, 0].ToString() + "," + w[1][1, 1].ToString() + "," + w[1][1, 2].ToString() + "," + w[1][1, 3].ToString() + "," +w[1][2, 0].ToString() + "," + w[1][2, 1].ToString() + "," + w[1][2, 2].ToString() + "," + w[1][2, 3].ToString() + "," +w[1][3, 0].ToString() + "," + w[1][3, 1].ToString() + "," + w[1][3, 2].ToString() + "," + w[1][3, 3].ToString() + "," +w[1][4, 0].ToString() + "," + w[1][4, 1].ToString() + "," + w[1][4, 2].ToString() + "," + w[1][4, 3].ToString() + "," +",," +",," +",," +",," +w[2][0, 0].ToString() + "," + w[2][0, 1].ToString() + "," + w[2][0, 2].ToString() + "," + w[2][0, 3].ToString() + "," +w[2][1, 0].ToString() + "," + w[2][1, 1].ToString() + "," + w[2][1, 2].ToString() + "," + w[2][1, 3].ToString() + "," +w[2][2, 0].ToString() + "," + w[2][2, 1].ToString() + "," + w[2][2, 2].ToString() + "," + w[2][2, 3].ToString() + "," +w[2][3, 0].ToString() + "," + w[2][3, 1].ToString() + "," + w[2][3, 2].ToString() + "," + w[2][3, 3].ToString() + "," +w[2][4, 0].ToString() + "," + w[2][4, 1].ToString() + "," + w[2][4, 2].ToString() + "," + w[2][4, 3].ToString() + "," +",," +",," +",," +",," +w[3][0, 0].ToString() + "," + w[3][0, 1].ToString() + "," + w[3][0, 2].ToString() + "," + w[3][0, 3].ToString() + "," +w[3][1, 0].ToString() + "," + w[3][1, 1].ToString() + "," + w[3][1, 2].ToString() + "," + w[3][1, 3].ToString() + "," +w[3][2, 0].ToString() + "," + w[3][2, 1].ToString() + "," + w[3][2, 2].ToString() + "," + w[3][2, 3].ToString() + "," +w[3][3, 0].ToString() + "," + w[3][3, 1].ToString() + "," + w[3][3, 2].ToString() + "," + w[3][3, 3].ToString() + "," +w[3][4, 0].ToString() + "," + w[3][4, 1].ToString() + "," + w[3][4, 2].ToString() + "," + w[3][4, 3].ToString() + "," +",," +",," +",," +",," +w[4][0, 0].ToString() + "," + w[4][0, 1].ToString() + "," + w[4][0, 2].ToString() + "," + w[4][0, 3].ToString() + "," +w[4][1, 0].ToString() + "," + w[4][1, 1].ToString() + "," + w[4][1, 2].ToString() + "," + w[4][1, 3].ToString() + "," +w[4][2, 0].ToString() + "," + w[4][2, 1].ToString() + "," + w[4][2, 2].ToString() + "," + w[4][2, 3].ToString() + "," +w[4][3, 0].ToString() + "," + w[4][3, 1].ToString() + "," + w[4][3, 2].ToString() + "," + w[4][3, 3].ToString() + "," +w[4][4, 0].ToString() + "," + w[4][4, 1].ToString() + "," + w[4][4, 2].ToString() + "," + w[4][4, 3].ToString() + "," +",," +",," +",," +",," +w[5][0, 0].ToString() + "," + w[5][0, 1].ToString() + "," +w[5][1, 0].ToString() + "," + w[5][1, 1].ToString() + "," +w[5][2, 0].ToString() + "," + w[5][2, 1].ToString() + "," +w[5][3, 0].ToString() + "," + w[5][3, 1].ToString() + "," +w[5][4, 0].ToString() + "," + w[5][4, 1].ToString() + "," +",,," +",," +Environment.NewLine);}
記録
読取専用
*File.SetAttributes(path, FileAttributes.ReadOnly);
*if (e.ColumnIndex <; 0 &amp;&amp; e.RowIndex >;= 0)*{
列ヘッダーかどうか調べる
セルを描画する
*e.Paint(e.ClipBounds, DataGridViewPaintParts.All);
行番号を描画する範囲を決定する
e.AdvancedBorderStyleやe.CellStyle.Paddingは無視しています
*Rectangle indexRect = e.CellBounds;
行番号を描画する
*TextRenderer.DrawText(e.Graphics,
描画が完了したことを知らせる
*e.Handled = true;

*Console.WriteLine($"検証結果: {res}");
false

干渉しないようにisTriggerをつける
*collider.isTrigger = true;
マウス左クリックでボールを射出する
*ThrowingBall();
*GameObject ball = Instantiate(ThrowingObject, this.transform.position, Quaternion.identity);*// 標的の座標
Ballオブジェクトの生成
*Vector3 targetPosition = TargetObject.transform.position;*// 射出角度
標的の座標
射出角度
*float angle = ThrowingAngle;
*Vector3 velocity = CalculateVelocity(this.transform.position, targetPosition, angle);*// 射出
射出速度を算出
射出
*Rigidbody rid = ball.GetComponent<;Rigidbody>;();
射出角をラジアンに変換
*float rad = angle * Mathf.PI / 180;
水平方向の距離x
*float x = Vector2.Distance(new Vector2(pointA.x, pointA.z), new Vector2(pointB.x, pointB.z));
垂直方向の距離y
*float y = pointA.y - pointB.y;
斜方投射の公式を初速度について解く
*float speed = Mathf.Sqrt(-Physics.gravity.y * Mathf.Pow(x, 2) / (2 * Mathf.Pow(Mathf.Cos(rad), 2) * (x * Mathf.Tan(rad) + y)));
条件を満たす初速を算出できなければVector3.zeroを返す
*return Vector3.zero;

Chromeの場合
*driver = new ChromeDriver();
Safariの場合
*driver = new SafariDriver();
FireFoxの場合
*driver = new FirefoxDriver();

*Thread.Sleep(500);
成功するまでTry
前回記録時間の更新
*previousTime = DateTime.Now;
*{return delegate (object s, SuperSocket.ClientEngine.ErrorEventArgs e){var errorStr = string.Format("({0}){1}", ticker, e.Exception.ToString());ErrorLog(errorStr);};}
エラー時
エラーログメソッド
*static object _errorLogLock = new Object();
*{using (var sw = new StreamWriter(Environment.CurrentDirectory + "\\error.log", true, Encoding.UTF8))using (var writerSync = TextWriter.Synchronized(sw)){sw.WriteLine(str);}}
TextWriter.Synchronizedだけだとエラー発生するっぽいので自前ロック
*{var i = 0;foreach (var ws in _sockets){if (ws.State == WebSocketState.Closed){//再接続var str = string.Format("({0})Try to reconnect", _tickers[i]);ErrorLog(str);ws.Open();}i++;}}
再接続（テスト版）
*var str = string.Format("({0})Try to reconnect", _tickers[i]);
再接続
*{foreach (var ws in _sockets) ws.Open();//自動再接続をオン_autoReconnectTimer = new Timer(AutoReconnectCallBack);_autoReconnectTimer.Change(_autoRecconectInterval, _autoRecconectInterval);}
一括接続
自動再接続をオン
*_autoReconnectTimer = new Timer(AutoReconnectCallBack);
*{foreach (var ws in _sockets) ws.Close();//自動再接続をオフif (_autoReconnectTimer != null) _autoReconnectTimer.Change(Timeout.Infinite, Timeout.Infinite);}
一括切断
*if (_autoReconnectTimer != null) _autoReconnectTimer.Change(Timeout.Infinite, Timeout.Infinite);*}
自動再接続をオフ

*m_stateVector.EnableRefreshTrace = true;
一致条件実行ログのデバッグ出力を有効化

*var hostName = "";
空文字にする

全体カウントダウンのスタート時間をセット
*var properties = new ExitGames.Client.Photon.Hashtable();

*Console.WriteLine(CreatePassword());
=&gt; 91760

配列系の確認 ＜　[]のアレイ　＞ とりあえず宣言と初期値設定まとめ
＜　宣言時のもろもろな書き方　＞
------------------------------------------------------
①　多分基本形はこれだけど、要素数と要素を合わせるのが面倒でメリットが薄そう
*public int[] Num3 = new int[5] { 0, 1, 2, 3, 4 };
②　とりあえず変数宣言のみのスタイル
Start() などの実行時か、UnityEditorのインスペクタで値を入れないと中身を作れない
結局これでいい気がするけど・・・
これ以外は、Unityの場合は初期値を変数宣言時に行うと、メタファイルに情報が残るからか？
あとから宣言時の値をスクリプトで管理しにくいのが不便に感じる...
*public int[] Num;
③　要素数だけ決めて中身は後からのスタイル
インスタンスを入れたり、座標の合成代入先など...
*public int[] Num1 = new int[3];
*public int[] Num2a =new int[] { 0, 1, 2, 3 };
④　いきなり要素を作るスタイル
*public int[] Num2a =new int[] { 0, 1, 2, 3 };
要素を書いたら要素数が決まる！　要素数は省略できる！
*public int[] Num2b = { 0, 1, 2, 3 };
new int[] も省略可能...だが変数宣言時のみ下記のスタイルが許容されている
*//　　　public int[] Num2c =new int { 0, 1, 2, 3 };
中途半端な省略はエラーになる
※　その他のエラーパターン
・ 因みに 下のように最後に（）をつけてはいけない！
上のどのパターンでも()は付けたらダメ！　Listと勘違いしないように！っと
public int[] i_NumXX4 = new int[5] { 0, 1, 2, 3, 4 }();
・ 当然、配列の枠と要素数とが合っていない場合はエラー。
public int[] i_Num4 = new int[5] { 0,1, 2, 3, 4,5,6 };
------------------------------------------------------
＜　関数内での書き方　＞
------------------------------------------------------
*int[] NumX;
*//  　NumX2 = {9,8,7};
new int[] 省略形　はアウト！
*//  　NumX2 = {9,8,7};
下記はやっぱりコンパイルエラーになる。
*NumX = new int[]{9,8,7};
NumX2 = {9,8,7};
*NumX = new int[]{9,8,7};
▼　これならOK
new int[] 省略形は、 このように変数の要素をさきに作っても...
*int[] num2b=new int[4];
*// num1b = { 0, 1, 2, 3 };
下記の行はコンパイルエラーがでて許容されない。
*int[] numX = {9,8,7};
変数宣言時ならローカル変数でも問題ない...わかりにくい！ ("=";)
*int[] numX = {9,8,7};
多分つまり...この書き方は変数宣言時にしか使えない。
＜　Start()内での確認　＞
------------------------------------------------------
変数を宣言し、Start()　内部で要素数を決める。
この書式は汎用性があり使いやすい。
結果的に行が増えるが、Unityでは変数宣言時に要素数を決めないほうが使いやすいのでは？？
要素もプールとして使うなら、 for などのループ処理で生成するほうが使いやすいのでは？
*public int[] NumInStart;

*using MyGameAsset;
←ココ
シーンに配置されたGameObjectの名前から取得する
*pointTarget = GameObject.Find("GameObjectName");

*float floatValue = float.Parse("6.2");
文字列からFloat値を取得

*public class Soldier : CharacterBase {public override string Attack() {return "戦士は斬りかかった！";}}
var character = new CharacterBase(); ←これは無理
*public override bool IsValid() {if (String.IsNullOrWhiteSpace(this._model.Name)) {return false;}if (this._model.Name.Length >; 20) {return false;}return true;}
入力されているかつ20文字以下なら可
*public override bool IsValid() {var age = DateTime.Now.Year - this._model.Birth.Year;if (DateTime.Now <; this._model.Birth.AddYears(age)) {age--;}if (!(20 <;= age &amp;&amp; age <;= 40)) {return false;}return true;}
20歳以上40歳以下なら可
*public override bool IsValid() {return !this._model.Married;}
結婚していない人のみ可
*var model = new Model() {Name = "名無しの権兵衛",Birth = new DateTime(1992, 7, 17),Married = false};
※実際にはユーザーの入力値がバインドされることを想定しています。
順に検証して処理する
*}

*string url = "https:
office.yahoo.co.jp";
サーバーからの応答を受信するためのWebResponseを取得
*res = (HttpWebResponse)req.GetResponse();

*input[1].mi.dwFlags = MOUSEEVENTF_LEFTUP;
左ボタン Up
マウス位置を元に戻す
*SetCursorPos(pt.X, pt.Y);
マウスカーソルの移動 例
*input[0].mi.dwFlags = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
自身がアクティブなら何もしない
*string processName = WindowsHandles.GetActiveProcessName();
これを実行しないとフォーカスが奪えない
*this.Activate();
最前面にした後に解除することで前面化させる
*this.Topmost = true;
PCによってはフォーカスが奪えないため、マウスクリックでアクティブ化する。
*WindowsHandles.ForceActive((int)this.Left + 10, (int)this.Top + 10);
*{const uint SPI_GETFOREGROUNDLOCKTIMEOUT = 0x2000;const uint SPI_SETFOREGROUNDLOCKTIMEOUT = 0x2001;const int SPIF_SENDCHANGE = 0x2;const int SW_RESTORE = 9;IntPtr dummy = IntPtr.Zero;IntPtr timeout = IntPtr.Zero;// 最小化状態なら元に戻すif (IsIconic(handle))ShowWindowAsync(handle, SW_RESTORE);int processId;// フォアグラウンドウィンドウを作成したスレッドのIDを取得int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);// 目的のウィンドウを作成したスレッドのIDを取得int targetID = GetWindowThreadProcessId(handle, out processId);// スレッドのインプット状態を結び付けるAttachThreadInput(targetID, foregroundID, true);// 現在の設定を timeout に保存SystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, timeout, 0);// ウィンドウの切り替え時間を 0ms にするSystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, dummy, SPIF_SENDCHANGE);// ウィンドウをフォアグラウンドに持ってくるSetForegroundWindow(handle);// 設定を元に戻すSystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, timeout, SPIF_SENDCHANGE);// スレッドのインプット状態を切り離すAttachThreadInput(targetID, foregroundID, false);}
ウィンドウを強制的にアクティブにする
*if (IsIconic(handle))*ShowWindowAsync(handle, SW_RESTORE);
最小化状態なら元に戻す
*int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);*// 目的のウィンドウを作成したスレッドのIDを取得
フォアグラウンドウィンドウを作成したスレッドのIDを取得
目的のウィンドウを作成したスレッドのIDを取得
*int targetID = GetWindowThreadProcessId(handle, out processId);
*AttachThreadInput(targetID, foregroundID, true);*// 現在の設定を timeout に保存
スレッドのインプット状態を結び付ける
現在の設定を timeout に保存
*SystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, timeout, 0);
ウィンドウの切り替え時間を 0ms にする
*SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, dummy, SPIF_SENDCHANGE);
ウィンドウをフォアグラウンドに持ってくる
*SetForegroundWindow(handle);
設定を元に戻す
*SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, timeout, SPIF_SENDCHANGE);
*AttachThreadInput(targetID, foregroundID, false);*}
スレッドのインプット状態を切り離す
*{const int SW_RESTORE = 9;// 最小化状態なら元に戻すif (IsIconic(handle))ShowWindowAsync(handle, SW_RESTORE);int processId;// フォアグラウンドウィンドウを作成したスレッドのIDを取得int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);// 目的のウィンドウを作成したスレッドのIDを取得int targetID = GetWindowThreadProcessId(handle, out processId);// スレッドのインプット状態を結び付けるAttachThreadInput(targetID, foregroundID, true);// ウィンドウをフォアグラウンドに持ってくるSetForegroundWindow(handle);// スレッドのインプット状態を切り離すAttachThreadInput(targetID, foregroundID, false);}
ウィンドウを強制的にアクティブにする
*if (IsIconic(handle))*ShowWindowAsync(handle, SW_RESTORE);
最小化状態なら元に戻す
*int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);*// 目的のウィンドウを作成したスレッドのIDを取得
フォアグラウンドウィンドウを作成したスレッドのIDを取得
目的のウィンドウを作成したスレッドのIDを取得
*int targetID = GetWindowThreadProcessId(handle, out processId);
*AttachThreadInput(targetID, foregroundID, true);*// ウィンドウをフォアグラウンドに持ってくる
スレッドのインプット状態を結び付ける
ウィンドウをフォアグラウンドに持ってくる
*SetForegroundWindow(handle);
*AttachThreadInput(targetID, foregroundID, false);*}
スレッドのインプット状態を切り離す
自身をアクティブにする
*this.Activate();
表示の最初は最前面とする
*this.Topmost = true;
最前面にした後に解除することで前面化させる
*this.Topmost = false;
強制的にフォーカスを奪う
*var helper = new System.Windows.Interop.WindowInteropHelper(this);
再度、再設定する
表示の最初は最前面とする
*this.Topmost = true;
最前面にした後に解除することで前面化させる
*this.Topmost = false;
アクティブイベントを呼ぶ
*Window_Activated(null, EventArgs.Empty);
*{const int SWP_NOSIZE = 0x0001;const int SWP_NOMOVE = 0x0002;const int SWP_SHOWWINDOW = 0x0040;const int HWND_TOPMOST = -1;const int HWND_NOTOPMOST = -2;if (isTopMost){// 最前面SetWindowPos(handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);}else{// 最前面解除SetWindowPos(handle, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);}}
ウィンドウの最前面/解除
最前面
*SetWindowPos(handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
最前面解除
*SetWindowPos(handle, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);
自身をアクティブにする
*this.Activate();
表示の最初は最前面とする
*WindowsHandles.SetTopMostWindow(helper.Handle, true);
最前面にした後に解除することで前面化させる
*WindowsHandles.SetTopMostWindow(helper.Handle, false);
強制的にフォーカスを奪う
*WindowsHandles.ForceActive(helper.Handle);
*for(int i = 0; i <; 2; i++)*{
背面に隠れることがあるため、再度繰り返す
表示の最初は最前面とする
*WindowsHandles.SetTopMostWindow(helper.Handle, true);
最前面にした後に解除することで前面化させる
*WindowsHandles.SetTopMostWindow(helper.Handle, false);
アクティブイベントを呼ぶ
*Window_Activated(null, EventArgs.Empty);

*.AddTo(this);
MonoBehaviourなら死活管理もこれでOK
IMessageBrokerではなく、IMessagePublisher/IMessageReceiverと明確にできることの権限を分ける
*Container.Bind<;IMessagePublisher>;().To<;ShopMessageBroker>;().AsSingle();
何らかの処理
*})

*Console.WriteLine( test2 == null);
ここはNullじゃないのでFalseになる

*void Start () {}
Use this for initialization
*void Update () {switch(MyLoopMode){case LoopMode.Foreach:// int count=0;//　▲　Switch文はif文と違ってスコープが別れていないので、同名のローカル変数を作りにくい？//　▼ ・・・と思ったけどスコープの外に書いているからダメだったのがアドバイスで解りました。{int count=0;foreach(int num in IntArray){print("foreach__"+num.ToString());count++;if(count==IntArray.Length){MyLoopMode=LoopMode.Stop;}}break;}case LoopMode.For:int maxF=IntArray.Length-1;for(int i=0;i<;=maxF;i++){print("for__"+IntArray[i].ToString());if(i==maxF){MyLoopMode=LoopMode.Stop;}}break;case LoopMode.While:int countW=0,maxW=5;//while(int id <; IntArray.Length)//　　　　　↑　と　型を書いて定義することはできないっぽい。//ちょっとしたミスで、無限ループになる可能性がそこそこある…Unityが固まる。while( countW <;= maxW){print("while__"+IntArray[countW].ToString());if(countW==maxW){MyLoopMode=LoopMode.Stop;}countW++;}break;case LoopMode.Stop:break;}}
Update is called once per frame
*//　▲　Switch文はif文と違ってスコープが別れていないので、同名のローカル変数を作りにくい？*//　▼ ・・・と思ったけどスコープの外に書いているからダメだったのがアドバイスで解りました。
int count=0;
*{int count=0;foreach(int num in IntArray){print("foreach__"+num.ToString());count++;if(count==IntArray.Length){MyLoopMode=LoopMode.Stop;}}break;}
▲　Switch文はif文と違ってスコープが別れていないので、同名のローカル変数を作りにくい？
*{int count=0;foreach(int num in IntArray){print("foreach__"+num.ToString());count++;if(count==IntArray.Length){MyLoopMode=LoopMode.Stop;}}break;}
▼ ・・・と思ったけどスコープの外に書いているからダメだったのがアドバイスで解りました。
↑　と　型を書いて定義することはできないっぽい。
ちょっとしたミスで、無限ループになる可能性がそこそこある…Unityが固まる。
*while( countW <;= maxW)

*public string url = "ws:
192.168.1.1:6437";環境ごとに変更

*{void Save();}
ISavable
*{}
ReactiveSavableList
*{public void Save(){}}
ISavable
*{}
ReactiveSavableList

*public IEnumerable<;int>; Solve() {// 計算時間を考慮して、1-9999999までの自然数に限定しました。foreach (var num in Enumerable.Range(1, 10000000 / multiplier)) {if (IsCyclicNumber(num)) {yield return num;}}}
multiplier倍すると巡回する数を求める。
*foreach (var num in Enumerable.Range(1, 10000000 / multiplier)) {*if (IsCyclicNumber(num)) {
計算時間を考慮して、1-9999999までの自然数に限定しました。
*private bool IsCyclicNumber(int num) {string numstr = num.ToString();string result = (num * multiplier).ToString();// 速度を速めるための泥臭い判断  ここから ↓if (result.Length != numstr.Length)return false;foreach (var c in result)if (!numstr.Contains(c))return false;// ↑ ここまで （無くても正しく動作する）return (GetCyclics(num).Any(x =>; result == x));}
numが巡回数かどうかを調べる
*if (result.Length != numstr.Length)*return false;
速度を速めるための泥臭い判断  ここから ↓
↑ ここまで （無くても正しく動作する）
*return (GetCyclics(num).Any(x =>; result == x));
*private IEnumerable<;string>; GetCyclics(int num) {string s = num.ToString();for (int i = 0; i <; s.Length - 1; i++) {s = s.Substring(1) + s[0];yield return s;}}
numを巡回させた数を文字列に変換し列挙する。

*void Start () {//例：Testsqという名前のGameObjectをobj1に格納obj1 = GameObject.Find("Testsq");//フラグを初期化showflag = true;}
Use this for initialization
例：Testsqという名前のGameObjectをobj1に格納
*obj1 = GameObject.Find("Testsq");
フラグを初期化
*showflag = true;
スクリプトで制御するGameObjectを用意
*private GameObject obj1;
オブジェクトが見えているかの判定をするフラグ
*private bool showflag;
*void Start () {//例：Testsqという名前のGameObjectをobj1に格納obj1 = GameObject.Find("Testsq");//フラグを初期化showflag = true;}
Use this for initialization
例：Testsqという名前のGameObjectをobj1に格納
*obj1 = GameObject.Find("Testsq");
フラグを初期化
*showflag = true;
*void Update () {if (Input.GetMouseButtonDown(0)){//showflagがtureなら、表示オブジェクトを消すif (showflag) {Debug.Log("click");//ここでオブジェクトを消すobj1.SetActive(false);//フラグを管理showflag = false;}else if (showflag == false){//オブジェクトを表示obj1.SetActive(true);//フラグを管理showflag = true;}}}
Update is called once per frame
*if (showflag) {*Debug.Log("click");
showflagがtureなら、表示オブジェクトを消す
ここでオブジェクトを消す
*obj1.SetActive(false);
フラグを管理
*showflag = false;
オブジェクトを表示
*obj1.SetActive(true);
フラグを管理
*showflag = true;

*postAsyncTask.Wait();
asyncawaitは.NET4.0だから使えない...

計測するメソッド本体
*method();
*Console.WriteLine($@"メソッド名：{methodName}
計測メソッド名の取得
ここで計測したいメソッド名を引数にして呼ぶ。
*main.MeasurementClock(main.StringBuilder);
計測するメソッド本体
*method();
*Console.WriteLine($@"メソッド名：{methodName}
計測メソッド名の取得

*task.Start(queuedTaskScheduler);
タスクを開始するときにタスクスケジューラを指定します
*{Name = threadName};
スレッドを生成し、名前を付けます。スレッドは下記のExecuteを実行します。
スレッドを開始
*mainThread.Start();
*// タスクがないときは、foreachは停止しています。*foreach (var task in tasksCollection.GetConsumingEnumerable())
tasksCollectionにタスクがある間だけ、このforeachが回ります。
*foreach (var task in tasksCollection.GetConsumingEnumerable())*{
タスクがないときは、foreachは停止しています。
*{return tasksCollection.ToArray();}
オーバーライドしなければなりません。
*{// タスクをキューイングします。if (task != null){tasksCollection.Add(task);}}
オーバーライドしなければなりません。
*if (task != null)*{
タスクをキューイングします。
*{// falseを返すと、taskがキューに並びます。return false;// ここでtrueを返すと、キューに入れずにそのまま実行させてしまいます。}
オーバーライドしなければなりません。
falseを返すと、taskがキューに並びます。
*return false;
ここでtrueを返すと、キューに入れずにそのまま実行させてしまいます。
*}

メール本文の内容を記載する(例："C#でOutlookを操作する")。
*mail.Body = "C#でOutlookを操作する";

静的でないフィールド、メソッド、またはプロパティで、オブジェクト参照が必要です
piyo = 2;
*piyo2 = 3;
*public static void Method4() { }
静的メンバーを override、virtual、または abstract とすることはできません。
*public static void Method4() { }
public abstract static void Method3();
*public new static void Method4() { }
newキーワードによる隠蔽は可能
静的メソッドはクラス修飾で呼び出せます。
*Hoge.Fuga2(i);
インスタンスメソッドは、インスタンス修飾で呼び出せます。
*var hoge = new Hoge();
静的メソッドをインスタンス修飾で呼び出すことはできません。
hoge.Fuga2(i);
*}

2つの派生Exceptionをネストされた例外の
動きをみるためのデモ用に定義する
*class SecondLevelException : Exception
前Exceptionを受け取らないコンストラクタ
*public ThirdLevelException( string message )
この`Rethrow`関数は0ディビジョンを行う
別関数を呼び出します。
*Rethrow( );
このコードではネストされた例外をInnerExceptionプロパティを
用いて紐解きます
*current = ex;
`Rethrow`関数は`DivideBy0( )`関数からの例外をキャッチし
別の例外を生成します。
*static void Rethrow()
`DivideBy0`関数は0ディビジョンを実行し
2番目の例外を生成します。
*static void DivideBy0( )

*var nameList = new List<;string>; {"Tokyo", "Osaka", "Aichi", "America", "London", "Australia",};
テストケース
リスト内から6文字以上の文字列を探す場合
-----------------------------------------
パターン１
*var nameBuf1 = nameList.Where(s =>; 6 <;= s.Length);
パターン２
*Func<;string, bool>; func2 = (s) =>; 6 <;= s.Length;
*Func<;string, bool>; func3 = (s) =>; { return 6 <;= s.Length; };
パターン３
パターン４
*Func<;string, bool>; func4 = Judge;

*public IEnumerable<;int>; GetSequence(ICollection<;ICollection<;int>;>; list) {foreach (var bin in list)foreach (var n in bin)yield return n;}
ビンに詰められている全ての要素を順に取り出す
*while (true) {// 空きの小さい順に並べ替え、// 空きが最も小さいビンを最終解答領域(result)へ入れる（確定）var bin = binsList.OrderByDescending(b =>; b.Sum()).First();result.Add(bin);// listから確定したビンを取り除くbinsList.Remove(bin);// 残ったビンは無いので、処理終了if (binsList.Count == 0)break;// 残ったビンに入っている項目で、再度解を求めるbinsList = _solver.Solve(GetSequence(binsList).ToArray());}
一旦答えを求める
空きの小さい順に並べ替え、
空きが最も小さいビンを最終解答領域(result)へ入れる（確定）
*var bin = binsList.OrderByDescending(b =>; b.Sum())
listから確定したビンを取り除く
*binsList.Remove(bin);
*if (binsList.Count == 0)*break;
残ったビンは無いので、処理終了
残ったビンに入っている項目で、再度解を求める
*binsList = _solver.Solve(GetSequence(binsList).ToArray());

Inspectorで録音デバイスを指定する場合の名前(未指定は既定)
*[SerializeField]
口パク対象(SkinnedMeshRenderer)のIndex
*[SerializeField]
入力音量に口パク具合を合わせる係数
*[SerializeField]
このスクリプトは口パク対象(SkinnedMeshRenderer)に付ける前提
*SkinnedMeshRenderer Skinned;
入力音声データ
*WaveIn Wave;
入力音声データを音量としてBlendShapeに設定する値
*float Weight = 0;
録音デバイス未指定なら既定
*DeviceName = WaveIn.GetCapabilities(0).ProductName;
*for (int i = 0; i <; WaveIn.DeviceCount; i++)*{
録音デバイスが指定されていたら探す
NAudioの録音初期化
*Wave = new WaveIn();
*{Weight = 0;var buffer = new WaveBuffer(e.Buffer);for (int index = 0; index <; e.BytesRecorded / 2; index++){Weight += Mathf.Abs(buffer.ShortBuffer[index]);}Weight /= e.BytesRecorded / 2;}
音量取得
*{Skinned.SetBlendShapeWeight(Index, Weight * Gain);}
取得した音量に係数をかけて調整してBlendShapeに設定

*float waitTimeRate = 0.002f;
生成スパンを徐々に短く
生成スパンが最短になったらシーンをロード
*Invoke ("GoNextScene", 5f);
コルーチンを止める場合
StopCoroutine ("Fire");
fade
*SteamVR_LoadLevel.Begin("NextScene");

とりあえず特定のファイル名を指定
*string videoclipfile = "Movie/動画ファイル名";
*public void VideoStart(){// ボタンクリック処理StartCoroutine (VideoPlayStart ());}
再生画面用のRaw Imageは「MovieRawImage」という名称でプレハブ化されている前提
ボタンクリック処理
*StartCoroutine (VideoPlayStart ());
あらかじめVideo PlayerがSceneに登録されている前提
*var obj = GameObject.Find ("Video Player");
あらかじめVideo PlayerにAudio Sourceが登録されている前提
*var audioSource = videoPlayer.GetComponent<;AudioSource>;();
ファイルをロードし、再生する動画のサイズに合わせてRender Textureを準備する
*VideoClip vclip = (VideoClip)Resources.Load (videoclipfile);
Video Playerの設定を行う
*videoPlayer.playOnAwake = false;
Audio SourceにあらかじめVideo Playerに追加したAudio Sourceを設定する
*videoPlayer.SetTargetAudioSource(0, audioSource);
Video Playerの準備（完了まで待つ）
*videoPlayer.Prepare();
Video Playerの準備が完了した後
プレハブから動画再生用のRawImageをロードする
*var _prefab = Resources.Load(rawImage);
Canvasが親になるようにtransformを代入する
*GameObject cvs = GameObject.Find("Canvas");
RawImageに動画再生用のRenderTextureを設定する
*RawImage screen = _rawImg.GetComponent<;RawImage>;();
動画の再生開始（再生完了まで待つ）
*videoPlayer.Play();
動画の再生完了
*videoPlayer.clip = null;

*}
end of method MyClass::Display

スレッドの中にシングルスレッドにしたいメソッドを入れる
*Thread t = new Thread(ClipBoardSetter);

新しく作ったクラスを使う
*var opponentInput = new StubOpponentInput(0);
実際にテストしたいクラス
*var jankenChecker = new JankenChecker(output);
結果を確認。第１引数が想定の、第２引数が実際の値
*Assert.Equal("あいこでした！", output.Output);

*public ReactiveProperty<;int>; SelectedMode { get; private set; }
プロパティ
*public ReactiveProperty<;int>; SelectedMode { get; private set; }
宣言と同時に初期化 or コンストラクタで初期化する場合は「private set;」の記述不要
メソッド内での記述
デフォルト値で初期化
*SelectedMode = new ReactiveProperty<;int>;();
指定した数値(この場合は3)で初期化
*SelectedMode = new ReactiveProperty<;int>;(3);
値を引き出す・書き換える際はValueプロパティを参照すること
*int selectedMode = SelectedMode.Value;
コンストラクタ内で
*SelectedMode.Subscribe(x =>; DoFunc(x));
*private CompositeDisposable Disposable { get; } = new CompositeDisposable();
Disposeが必要なReactivePropertyやReactiveCommandを集約させるための仕掛け
*public ReactiveProperty<;int>; Hoge{ get; }
ReactivePropertyやReactiveCommandを用意する
AddToメソッドでDisposeしたいオブジェクトをDisposableプロパティ(の実体)に登録する
*this.Hoge = new ReactiveProperty<;int>;().AddTo(this.Disposable);
まとめてDisposeする
*Disposable.Dispose();
*//値が変更された時の動作(色々行うので{}が必要)
値が変更された時の動作
*SelectedMode.Subscribe(_ =>; {DoFunc1(SelectedMode.Value);DoFunc2(SelectedMode.Value);DoFunc3(SelectedMode.Value);});
値が変更された時の動作(色々行うので{}が必要)
*public ReactiveProperty<;int>; Input1 { get; } = ReactiveProperty<;int>;();
変数を宣言
定義する際に、どう加工するかをメソッドチェーンで示す
(Output1は、Input1を2倍にした数値となる)
*Output1 = Input1.Select(x =>; x * 2).ToReactiveProperty();
この「Select」は、普通のLINQと同様、型変換にも使える
(Output2は、Input1が偶数ならtrue、機数ならfalseとなる)
*Output2 = Input1.Select(x =>; (x % 2 == 0)).ToReactiveProperty();
2つ以上のReactivePropertyを合成することも可能
(Output3は、Input1 == Input2なら"同じ", それ以外なら"違う"となる)
*Output3 = Input1.CombineLatest(Input2, (x, y) =>; (x == y ? "同じ" : "違う")).ToReactiveProperty();
値が変更された時の動作
*SelectedMode.Subscribe(_ =>; DoFunc(SelectedMode.Value));
実はこういった風に書ける
*SelectedMode.Subscribe(x =>; DoFunc(x));
更に、DoFuncメソッドが引数1のみでオーバーロードが無ければここまで略せる(意味は上と等価)
*SelectedMode.Subscribe(DoFunc);
*public ReactiveCommand ButtonCommand {get; private set; }
何らかのコマンド
*public ReactiveProperty<;bool>; ButtonFlg1 { get; } = new ReactiveProperty<;bool>;();
何らかのフラグ
フラグが有効な時にのみコマンドを有効にする(例えばボタンのコマンドが無効になっている際は、ボタン自体も無効色になる)
*ButtonCommand = ButtonFlg1.ToReactiveCommand();
フラグが2つとも有効な場合にのみコマンドを有効にする
*ButtonCommand = ButtonFlg1.CombineLatest(ButtonFlg2, (x,y) =>; x &amp; y).ToReactiveCommand();
*ButtonCommand = new[] { ButtonFlg1, ButtonFlg2, ButtonFlg3 }
フラグが3つとも有効な場合にのみコマンドを有効にする
フラグが1つでも有効な場合にのみコマンドを有効にする
*ButtonCommand = ButtonFlg1.CombineLatest(ButtonFlg2, (x,y) =>; x | y).ToReactiveCommand();
*ButtonCommand = new[] { ButtonFlg1, ButtonFlg2, ButtonFlg3 }
フラグが1つでも有効な場合にのみコマンドを有効にする
*ButtonCommand = new[] { ButtonFlg1, ButtonFlg2, ButtonFlg3 }
フラグが全て有効な場合にのみコマンドを有効にする
*ButtonCommand = new[] { ButtonFlg1, ButtonFlg2, ButtonFlg3 }
フラグが全て無効な場合にのみコマンドを有効にする
バリデーション用のクラス
(以下のサンプルは、int型にパースできた時のみ「入力値が正常」だと判断する)
*using System.ComponentModel.DataAnnotations;
*public ReactiveProperty<;string>; X {get;} = new ReactiveProperty<;string>;();
バリデーションを設定する
バリデーションが通る(入力値が正常)な時のみコマンドを有効にする
*ButtonCommand = X.ObserveHasErrors.Select(x =>; !x).ToReactiveCommand();
バリデーションが通らない(入力値が異常)な時のみコマンドを有効にする
*ButtonCommand = X.ObserveHasErrors.ToReactiveCommand();
*ButtonCommand = new[]{ButtonFlg1.ObserveHasErrors,ButtonFlg2.ObserveHasErrors}.CombineLatest(x =>; x.All(y =>; !y)).ToReactiveCommand();
2つのバリデーションが通る時のみコマンドを有効にする
Model側(各種プロパティを実装した側)
ここでBindableBaseは、Prism.Mvvm.BindableBaseのような、
INotifyPropertyChanged実装済みのヘルパークラスだとする
*public class Model : BindableBase{
*public class ViewModel : INotifyPropertyChanged{*private Model model = new Model();
ViewModel側(ReactivePropertyで中継する側)
BindingのModeがTwoWayなプロパティ(つまり双方向)
*Property1 = model.ToReactivePropertyAsSynchronized(m =>; m.X);
BindingのModeがOneWayなプロパティ(つまりView→ViewModelのみ)
*Property2 = model.ObserveProperty(m =>; m.X).ToReactiveProperty();
BindingのModeがOneWayToSourceなプロパティ(つまりViewModel→Viewのみ)
*Property3 = ReactiveProperty.FromObject(model, m =>; m.X);

『バブリング創世記』（筒井康隆著）の冒頭部分を抜粋（改行せずに1文字列にしている）
*var text = @"ドンドンはドンドコの父なり。ドンドンの子ドンドコ、ドンドコドンを生み、

*{[TestFixture]public class NUnitTest{private MyDbContextFixture _fixture;private MyDBContextName _context;[OneTimeSetUp]public void OneTimeSetup(){_fixture = new MyDbContextFixture();}[SetUp]public void SetUp(){_context = _fixture.Context;}// ご自身で引数のテストデータ作成します// DBに登録したいテストデータをいれます// GetTestData()/// <;summary>;/// テストデータを削除/// <;/summary>;[TearDown]public void TearDown(){var list = _context.PrPrint.ToList<;PrPrint>;();_context.PrPrint.RemoveRange(list);_context.SaveChanges();}/// <;summary>;/// ステータスコードが60から70に更新/// <;/summary>;[TestCaseSource(nameof(MyTestDataName))]public void UpdateTest(inputModel){var function = new TestFunction<;MyDBContextName>;(_context);// テストデータをInsertvar list = GetTestData();_context.TestTable.AddRange(GetTestData());_context.SaveChanges();// テストしたい内容var result = function.Update_Test(inputModel);var entity = _context.TestTable.Where(x =>; x.Id == result.Id).SingleOrDefault();// DBのステータスコードが70Assert.That("70", Is.EqualTo(entity.StatusCd));}}}
テストしたいプロジェクトを参照するのを忘れずに
ご自身で引数のテストデータ作成します
DBに登録したいテストデータをいれます
GetTestData()
*[TearDown]
テストデータをInsert
*var list = GetTestData();
テストしたい内容
*var result = function.Update_Test(inputModel);
DBのステータスコードが70
*Assert.That("70", Is.EqualTo(entity.StatusCd));
テストデータをInsert
*var list = GetTestData();

mはメジアンで配列を中央で二分割するための指数
T[i...j]は一時的な配列
*p <;- i;
Pは配列の最初の値でこれを軸とする
入力される値は配列A[0...n -1]の部分配列でlは左、rは右を意味する
出力する値は配列を２つに分けるための分割点の値を返す
*p <;- A[l]
*if l / r {s <;- Partition(A[l...r])Quicksort(A[l...s - 1])Quicksort(A[s + 1...r])}
部分配列をクイックソートする
*if l / r {*s ;- Partition(A[l...r])
s は分割点

*...
await code
*if ((IShape)shape is Rectangle rect1) {*...
キャストが必要。外すとコンパイルエラー。
*switch ((IShape)shape) {case Rectangle rect2:...break;}
キャストが必要。外すとコンパイルエラー。

所有権の移譲
*i_projectile.GetComponent<;PhotonView>; ().TransferOwnership (PhotonNetwork.player.ID);

最初に一つのビンを用意する
*var binList = new List<;ICollection<;int>;>;();
*foreach (var n in items.OrderByDescending(x =>; x)) {*// nが入るビンを見つける （空きが最小のビン）
各項目をビンに入れてゆく
*var target = binList.Select(b =>; new { Bin = b, Space = BinSize - b.Sum(t =>; t) })
nが入るビンを見つける （空きが最小のビン）
*} else {
nが入るビンが見つかったので、そこに入れる
*List<;int>; bin2 = new List<;int>;() { n };
見つからなかったので、新しいビンを用意する

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"
*this.MouseLeftButtonDown += (sender, e) =>; { this.DragMove(); };
ウィンドウをマウスのドラッグで移動できるようにする
既存の画像データ集を用いて学習を開始する
*StartLearning();
*{var catsCreator = new ItemsFactory("cats", directoryPath, itemList, 0);var birdsCreator = new ItemsFactory("birds", directoryPath, itemList, 1);var dogsCreator = new ItemsFactory("dogs", directoryPath, itemList, 2);bagofVW = new TrainFactory(codeWordCount, bagofVW, itemList).bagofVW;var inputs = new InputFactory(itemList).input;var outputs = new OutputFactory(itemList).output;msvm = new MulticlassSupportVectorMachine<;ChiSquare>;(0, new ChiSquare(), classes);// 学習アルゴリズムを作成するvar teacher = new MulticlassSupportVectorLearning<;ChiSquare>;(){Learner = (param) =>; new SequentialMinimalOptimization<;ChiSquare>;(){UseComplexityHeuristic = true,UseKernelEstimation = true}};msvm = teacher.Learn(inputs, outputs);var calibration = new MulticlassSupportVectorLearning<;ChiSquare>;(){Model = msvm,Learner = (param) =>; new ProbabilisticOutputCalibration<;ChiSquare>;(){Model = param.Model}};calibration.ParallelOptions.MaxDegreeOfParallelism = 1;calibration.Learn(inputs, outputs);inkCanvas.Strokes.Clear();textBox1.Clear();}
学習を開始する
*{Learner = (param) =>; new SequentialMinimalOptimization<;ChiSquare>;(){UseComplexityHeuristic = true,UseKernelEstimation = true}};
学習アルゴリズムを作成する
*{private string directoryPath;private List<;ImageItem>; itemList;public ItemsFactory(string animalName, string directoryPath, List<;ImageItem>; itemList, int classNum){this.directoryPath = directoryPath;this.itemList = itemList;List<;String>; list = new List<;String>;();System.IO.DirectoryInfo di = new System.IO.DirectoryInfo(Path.Combine(directoryPath, animalName));IEnumerable<;System.IO.FileInfo>; files =di.EnumerateFiles("*", System.IO.SearchOption.AllDirectories);//ファイルを列挙するforeach (System.IO.FileInfo f in files){list.Add(f.FullName);}foreach (String fileName in list){ImageItem ii;ii = new ImageItem();ii.FileName = fileName;FileStream fs;fs = new FileStream(fileName, FileMode.Open, FileAccess.Read);Bitmap source= (Bitmap)System.Drawing.Bitmap.FromStream(fs);fs.Close();ii.bmp = new Bitmap(source);ii.Classification = classNum;itemList.Add(ii);}}}
各動物の画像を学習用データに加える
*foreach (System.IO.FileInfo f in files)*{
ファイルを列挙する
*{public BagOfVisualWords bagofVW;public TrainFactory(int codeWordCount, BagOfVisualWords bagofVW, List<;ImageItem>; itemList){BinarySplit binarySplit = new BinarySplit(codeWordCount);bagofVW = new BagOfVisualWords(binarySplit);List<;Bitmap>; bitmapList = new List<;Bitmap>;();foreach (ImageItem item in itemList){bitmapList.Add(item.bmp);}Bitmap[] trainImages = bitmapList.ToArray();bagofVW.Learn(trainImages);foreach (ImageItem item in itemList){item.codeWord = bagofVW.Transform(item.bmp);}this.bagofVW = bagofVW;}}
訓練用インプットデータを作成する
*{public double[][] input;public InputFactory(List<;ImageItem>; list){var inputList = new List<;double[]>;();foreach (ImageItem item in list){inputList.Add(item.codeWord);}input = inputList.ToArray();}}
学習用インプットデータを作成する
*{public int[] output;public OutputFactory(List<;ImageItem>; list){var outputList = new List<;int>;();foreach (ImageItem item in list){outputList.Add(item.Classification);}output = outputList.ToArray();}}
学習用アウトプットデータを作成する
*{this.Close();}
アプリを終了する
*{Bitmap bitmap = new BitmapFactory(inkCanvas).bitmap;double[] codeword = bagofVW.Transform(bitmap);int classResult = msvm.Decide(codeword);textBox1.Text = "Result:" + Convert.ToString(classResult) + "\r\n";String cryStr;if (classResult == 0){cryStr = @"・・・ねこのなきごえ.mp3";}else if (classResult == 1){cryStr = @"・・・とりのなきごえ.mp3";}else{cryStr = @"・・・いぬのなきごえ.mp3";}Uri cryFile = new Uri(cryStr);mediaPlayer.Open(cryFile);mediaPlayer.Play();,,,//フィードバック// Configure the message box to be displayedstring messageBoxText = "猫ならYes、犬ならNo、鳥ならCancelを押してください。";string caption = "フィードバック";MessageBoxButton button = MessageBoxButton.YesNoCancel;MessageBoxImage icon = MessageBoxImage.Question;// Display message boxMessageBoxResult result = MessageBox.Show(messageBoxText, caption, button, icon);string animalStr = "";// Process message box resultsswitch (result){//猫case MessageBoxResult.Yes:animalStr = "cats";break;//犬case MessageBoxResult.No:animalStr = "dogs";break;//鳥case MessageBoxResult.Cancel:animalStr = "birds";break;}string saveDi = Path.Combine(directoryPath, animalStr);string imagePath = DateTime.Now.ToString("yyyyMMddhhmmss") + ".jpg";string savePath = Path.Combine(saveDi, imagePath);SaveImage(savePath);//再学習StartLearning();}
判定するイラストの読み込みと鳴き声
フィードバック
Configure the message box to be displayed
*string messageBoxText = "猫ならYes、犬ならNo、鳥ならCancelを押してください。";
*{//猫case MessageBoxResult.Yes:animalStr = "cats";break;//犬case MessageBoxResult.No:animalStr = "dogs";break;//鳥case MessageBoxResult.Cancel:animalStr = "birds";break;}
Process message box results
猫
*case MessageBoxResult.Yes:
犬
*case MessageBoxResult.No:
鳥
*case MessageBoxResult.Cancel:
再学習
*StartLearning();
*{Rect rectBounds = inkCanvas.Strokes.GetBounds();DrawingVisual dv = new DrawingVisual();DrawingContext dc = dv.RenderOpen();dc.PushTransform(new TranslateTransform(-rectBounds.X, -rectBounds.Y));dc.DrawRectangle(inkCanvas.Background, null, rectBounds);inkCanvas.Strokes.Draw(dc);dc.Close();RenderTargetBitmap rtb = new RenderTargetBitmap((int)rectBounds.Width, (int)rectBounds.Height,96, 96,PixelFormats.Default);rtb.Render(dv);BitmapEncoder enc = new JpegBitmapEncoder();if (enc != null){enc.Frames.Add(BitmapFrame.Create(rtb));System.IO.Stream stream = System.IO.File.Create(file);enc.Save(stream);stream.Close();}}
InkCanvasを画像として保存する
*{inkCanvas.Strokes.Clear();}
お描き画像を消す
*{public Bitmap bitmap;private InkCanvas inkCanvas;public BitmapFactory(InkCanvas inkCanvas){this.inkCanvas = inkCanvas;double width = inkCanvas.ActualWidth;double height = inkCanvas.ActualHeight;RenderTargetBitmap bmpCopied = new RenderTargetBitmap((int)Math.Round(width), (int)Math.Round(height), 96, 96, PixelFormats.Default);DrawingVisual dv = new DrawingVisual();using (DrawingContext dc = dv.RenderOpen()){VisualBrush vb = new VisualBrush(inkCanvas);dc.DrawRectangle(vb, null, new Rect(new System.Windows.Point(), new System.Windows.Size(width, height)));}bmpCopied.Render(dv);System.Drawing.Bitmap bitmap;using (MemoryStream outStream = new MemoryStream()){BitmapEncoder enc = new BmpBitmapEncoder();enc.Frames.Add(BitmapFrame.Create(bmpCopied));enc.Save(outStream);bitmap = new System.Drawing.Bitmap(outStream);}this.bitmap = bitmap;}}
InkCanvasをBitMapで返す

*Thread.Sleep(100);
ちょっと待つ
*Task.Run(() =>; {// スレッド終了を何も考えていない while (true)// 実際は、キーが入力されたらスレッドを終了する、などが必要while (true){var data = sharedQueue.Poll();Console.WriteLine($"Poll: {data}");}});
Consumerスレッド生成＆開始
スレッド終了を何も考えていない while (true)
実際は、キーが入力されたらスレッドを終了する、などが必要
*while (true)

*Console.WriteLine(mock.DoSomething);
=&gt; True

*input.mi.dwFlags = 0x0001;
MOVE (RELATIVE)

外周1マスは端をつなげるための領域である
return:field[size_x,size_y]
*private StatusLife[,] calc_cell_1step(StatusLife[,] field, int size_x, int size_y)
*private StatusLife[,] FieldToFieldCalc(StatusLife[,] field, int size_x, int size_y)*{
fieldから計算フィールドへうつす。端はつながってる形である
*for (int y = 0; y <; size_y; y++)*{
真ん中
4隅
f_calc[0, 0] = field[size_x - 1, size_y - 1];           左上
f_calc[size_x + 1, 0] = field[0, size_y - 1];           右上
f_calc[size_x + 1, size_y + 1] = field[0, 0];            右下
f_calc[0, size_y + 1] = field[size_x - 1, 0];            左下
外枠直線
上下
*for (int x = 0; x <; size_x; x++)
*for (int y = 0; y <; size_y; y++)*{
左右

*if (start <; 0) throw new ArgumentOutOfRangeException(nameof(start));*if (end ;= start) throw new ArgumentException("start must be less than end.");
引数の評価処理も反復子に含まれている為、実際に反復処理が行われるまで評価が遅延されてしまう。
*if (start <; 0) throw new ArgumentOutOfRangeException(nameof(start));*if (end ;= start) throw new ArgumentException("start must be less than end.");
反復子がローカル関数に隔離されているので、引数の評価は即時に行われる。
*public Person(string name) {_name = name;}
コンストラクター
*~Person() {Console.Error.WriteLine("Finalized");}
ファイナライザー
*public string Name {get { return _name; }set { _name = value; }}
プロパティ
コンストラクター
*public Person(string name) =>; _name = name;
ファイナライザー
*~Person() =>; Console.Error.WriteLine("Finalized");
*public string Name {get =>; _name;set =>; _name = value;}
プロパティ
*public Person(string name) {Name = name ?? throw new ArgumentNullException(nameof(name));}
null 合体演算子
*public string GetFirstName() {var parts = Name.Split(' ');return (parts.Length >; 0) ? parts[0] : throw new InvalidOperationException("No name!");}
条件演算子
式形式のラムダ
*public string GetLastName() =>; throw new NotImplementedException();

*var unspec = new DateTime(2017, 12, 25, 20, 0, 0);
未指定なので、DateTimeKind.Unspecified
Kindがローカルのものを変換
var localToLocal = local.ToLocalTime();     2017-12-25 20:00:00 &lt;- JSTのまま
var localToUtc = local.ToUniversalTime();   2017-12-25 11:00:00 &lt;- UTCに
KindがUTCのものを変換
var utcToLocal = utc.ToLocalTime();         2017-12-26 05:00:00 &lt;- JSTに
var utcToUtc = utc.ToUniversalTime();       2017-12-25 20:00:00 &lt;- UTCのまま
Kindを明示しなかったものを変換
var unsToUtc = unspec.ToUniversalTime();    2017-12-25 11:00:00 &lt;- Unspecified = Localだと判断されてUTCに
var unsToLocal = unspec.ToLocalTime();      2017-12-26 05:00:00 &lt;- Unspecified = Utcだと判断されてJSTに
インスタンス間の差を計算。9時間の時差はあるが、差は0という結果。
TimeSpan sub = local.Subtract(utc);     local - utc も可。 sub.TotalSeconds == 0
*,,,
DateTime型
Kindプロパティ：Local
*Jst = new DateTime(2017, 12, 25, 13, 0, 0, DateTimeKind.Local),
Kindプロパティ：明示しないので、Unspecifiedになる
*Unspec = new DateTime(2017, 12, 25, 13, 0, 0),
Kindプロパティ：Utc
*Utc = new DateTime(2017, 12, 25, 13, 0, 0, DateTimeKind.Utc),
UTCからのタイムゾーンのズレ：9時間(日本時間)
*JstOffset = new DateTimeOffset(2017, 12, 25, 13, 0, 0, TimeSpan.FromHours(9)),
*{Jst = new DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Local),Unspec = new DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Unspecified),Utc = new DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Utc),JstOffset = new DateTimeOffset(2017, 12, 23, 13, 0, 0, TimeSpan.FromHours(9)),UtcOffset = new DateTimeOffset(2017, 12, 23, 13, 0, 0, TimeSpan.FromHours(0))};
元のドキュメント
*{Jst = DateTime(2017, 12, 23, 4, 0, 0, DateTimeKind.Utc),Unspec = DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Utc),Utc = DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Utc),JstOffset = DateTimeOffset(2017, 12, 23, 4, 0, 0, TimeSpan.FromHours(0)),UtcOffset = DateTimeOffset(2017, 12, 23, 13, 0, 0, TimeSpan.FromHours(0)),};
取得したドキュメント
*{Jst = new DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Local),Unspec = new DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Unspecified),Utc = new DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Utc),JstOffset = new DateTimeOffset(2017, 12, 23, 13, 0, 0, TimeSpan.FromHours(9)),UtcOffset = new DateTimeOffset(2017, 12, 23, 13, 0, 0, TimeSpan.FromHours(0))};
元のドキュメント
*{Jst = DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Local),Unspec = DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Unspecified),Utc = DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Utc),JstOffset = DateTimeOffset(2017, 12, 23, 13, 0, 0, TimeSpan.FromHours(9)),UtcOffset = DateTimeOffset(2017, 12, 23, 22, 0, 0, TimeSpan.FromHours(9))};
取得したドキュメント

1から100までの偶数の和を表示する
*IEnumerable<;int>; numbers = Enumerable.Range(1, 100);
1から100までの偶数の和を表示する
*IEnumerable<;int>; numbers = Enumerable.Range(1, 100);
1から100までの整数に101が含まれていないか？
*IEnumerable<;int>; numbers = Enumerable.Range(1, 100);
1から100までの整数に101が含まれていないか？
*IEnumerable<;int>; numbers = Enumerable.Range(1, 100);
*Debug.Log(string.Format("{0}: {1}", nameof(_hoge), _hoge));
※ nameof演算子もC# 6.0相当の機能

*public OrderedDictionary<;string, OrderedDictionary<;string, string>;>; SectionDic { get; set; }
Iniファイル情報格納(OrderedDictionary型)
*public DataSet SectionDataSet { get; set; }
Iniファイル情報格納(DataSet型)
*public Encoding Encording { get; set; }
エンコーディング
*public string SectionSeparator { get; set; }
セクション番号区切り文字
*public string KeySeparator { get; set; }
キー番号区切り文字
*public string InsertSpace { get; set; }
セクションと値の間の空白
*public string RootName { get; set; }
XML用ルート名
セクショングループ用属性値
*public const string SECTION_GROUP_ATTR = "Grp";
パラメーターグループ用属性値
*public const string PARAMETER_INDEX_ATTR = "Idx";
XML用ルート名
*public const string DEFAULT_ROOT_NAMER = "Root";
セクション用正規表現パターン
*const string SECTION_PATTERN = @"^\s*\[(?<;section>;[^\]]+)\].*$";
パラメーター用正規表現パターン
*const string PARAMETER_PATTERN = @"^\s*(?<;name>;[^=]+)=(?<;value>;.*?)(\s+;(?<;comment>;.*))?$";
*{Encording = Encoding.UTF8;SectionSeparator = "";KeySeparator = "";InsertSpace = " ";RootName = DEFAULT_ROOT_NAMER;}
コンストラクタ
Ini情報のセット
*SectionDic = GetSections(filePath);
*if (isDataSet) return ToDataSet();*return true;
DataSet型に変換
XMLデータに変換する
*string xml = ConvertDicToXML();
*{SectionDataSet.ReadXml(reader);}
DataSet型に変換する
セクション名が明示されていない先頭部分のセクション名を""として扱う
*sections[string.Empty] = new OrderedDictionary<;string, string>;();
*if (IsBlank(line))*continue;
空行は読み飛ばす
*if (line.StartsWith(";", StringComparison.Ordinal))*continue;
コメント行は読み飛ばす
name=valueの行
*sections[currentSection][matchNameValue.Groups["name"].Value.Trim()] = matchNameValue.Groups["value"].Value.Trim();
[section]の行
*currentSection = matchSection.Groups["section"].Value;
Iniファイル情報を取得する
*var dic = GetSections(filePath);
並び替えた情報を格納
*var sortSections = new OrderedDictionary<;string, OrderedDictionary<;string, string>;>;(StringComparer.Ordinal);
*foreach (var sec in sections)*{
存在しなかったら追記
*if (sortSections.ContainsKey(sec.Key) &amp;&amp; sortSections[sec.Key].ContainsKey(pair.Key))*continue;
既に登録済みなら何もしない
*if (!sortSections.ContainsKey(sec.Key))*sortSections[sec.Key] = new OrderedDictionary;string, string>;();
未登録なら追加する
セクションの最終キーを格納
*Dictionary<;string, string>; lastdic = new Dictionary<;string, string>;();
*//if (!result) return false;*result = Write(filePath, sortSections, lastdic);
result = WriteIni(section.Key, pair.Key, pair.Value, filePath);
セクション名が明示されていない先頭部分のセクション名を""として扱う
*sections[string.Empty] = new OrderedDictionary<;string, string>;();
空行は読み飛ばす
*bool isContinue = IsBlank(line);
*if (line.StartsWith(";", StringComparison.Ordinal))*isContinue = true;
コメント行は読み飛ばす
*if (sortSections.Count == 0)*isContinue = true;
全て終わった
存在しなかったら追記
*var matchNameValue = regexNameValue.Match(line);
name=valueの行
*string keyName = matchNameValue.Groups["name"].Value.Trim();
*if(curvalue.Contains(" "))*{
現在値があるなら置換する
現在値に空白が含まれていた場合、単純な置換(キーやコメントなども置換される可能性がある)
*newline = line.Replace(curvalue, value);
*newline = Regex.Replace(line, @"(=\s+|=)([^;|\s]+)(\s+;.*|)", "${1}" + value + "${3}");
現在値に空白が含まれていない場合、値のみ置換
現在値と違う値なら保存する
*isSave = true;
*newline = Regex.Replace(line, @"(=)(\s[^;].*)", "${1}" + InsertSpace + value + "${2}");
= の位置に半角スペースを1つ空けて値をセット
*if (newline != line) isSave = true;*}
現在値と違う値なら保存する
書き換え行のセット
*sb.AppendLine(newline);
*if (lastdic[currentSection] == keyName)*{
新規パラメーターがあれば最終キー後に追記する
*if (sortSections[currentSection].Count == 0)*{
セクション内のパラメーターが存在しない
セクションを削除する
*sortSections.Remove(currentSection);
対象のセクション行が存在
*isExistsSection = true;
行のセット
*sb.AppendLine(line);
*foreach (var sec in sortSections)*{
新規セクションとパラメーターを追記する
*if (sb.Length != 0) sb.AppendLine("");*sb.AppendLine(string.Format("[{0}]", sec.Key));
未登録のセクションを追加する(一行空行)
*sb.AppendLine(string.Format("{0}" + InsertSpace + "=" + InsertSpace + "{1}", pair.Key, pair.Value));
パラメーターを追加する
*if (isWrite &amp;&amp; isSave)*{
保存処理
同一名カウントチェック
*OrderedDictionary<;string, int>; secCount = GetSectionGroupCount();
*foreach (var section in SectionDic)*{
XMLデータ生成
*if (grpno == -1 &amp;&amp; key != "" &amp;&amp; secCount[key] >; 1) grpno = 0;*// パラメーターが連番のみかチェック
複数存在するならグループ扱い
パラメーターが連番のみかチェック
*bool isDataGrp = true;
*sb.AppendLine(string.Format("<;{0}>;{1}<;/{0}>;", pkey, pair.Value));
セクションが無い場合
空行(全角スペース、タブ、半角スペースのみを対象にする)
*Regex re = new Regex(@"\s");

*using (var res = await client.GetAsync("http:
localhost:10001").ConfigureAwait(false))
*{// Do 1000 concurrent tasks, loop 10 timesvar tasks = Enumerable.Range(0, 1000).Select(async idx =>;{for (int i = 0; i <; 10; i++){try{// HttpWebRequestはそのリクエストごとに毎回インスタンスを作成するvar client = HttpWebRequest.CreateHttp("http://localhost:10001");using(var res = client.GetResponse() as HttpWebResponse){if((int)res.StatusCode <; 200 || (int)res.StatusCode >;= 300 ){throw new Exception($"http response failed:{res.StatusCode}");}}break;}catch (Exception e){Console.WriteLine($"error({idx},{i}): {e}");}}Console.WriteLine($"done{idx}");}).ToArray();await Task.WhenAll(tasks).ConfigureAwait(false);Console.WriteLine($"all done");}
予めhttp:localhost:10001で適当なhttpサーバーを動かしておく
*{for (int i = 0; i <; 10; i++){try{// HttpWebRequestはそのリクエストごとに毎回インスタンスを作成するvar client = HttpWebRequest.CreateHttp("http://localhost:10001");using(var res = client.GetResponse() as HttpWebResponse){if((int)res.StatusCode <; 200 || (int)res.StatusCode >;= 300 ){throw new Exception($"http response failed:{res.StatusCode}");}}break;}catch (Exception e){Console.WriteLine($"error({idx},{i}): {e}");}}Console.WriteLine($"done{idx}");}).ToArray();
Do 1000 concurrent tasks, loop 10 times
HttpWebRequestはそのリクエストごとに毎回インスタンスを作成する
var client = HttpWebRequest.CreateHttp("http:localhost:10001");
*using(var res = client.GetResponse() as HttpWebResponse)

*var decrypted = crypter.TryDecrypt(encrypted);
bytes[] { 0, 1, 2}

*"https:
www.twilio.comdocsdocuments25justthefaxmaam.pdf");

*[SerializeField] GameObject m_ProjectilePrefab;
ボールのプレファブ
到達した後の処理はこの下に
*}

*// labelShift*//

*this.labelShift.AutoSize = true;*this.labelShift.Font = new System.Drawing.Font("MS UI Gothic", 48F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(128)));

A-Zキーが押されているときは非0が入る
*int AtoZ = 0;

初期設定
*SetPlayerName ("Player-Id: " + PhotonNetwork.player.ID);
*void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info) {if (stream.isWriting) {// 自分の情報を送るstring myName = this.gameObject.name;int myHealthPoint = m_healthPoint;stream.SendNext (myName);stream.SendNext (myHealthPoint);} else {// 他人の情報を受け取るstring otherName = (string)stream.ReceiveNext();int otherHealthPoint = (int)stream.ReceiveNext();SetPlayerName (otherName);SetHealthPoint (otherHealthPoint);}}
ストリーム同期
自分の情報を送る
*string myName = this.gameObject.name;
他人の情報を受け取る
*string otherName = (string)stream.ReceiveNext();
*void Shoot(Vector3 i_pos, Vector3 i_angle) {Quaternion rot = Quaternion.Euler (i_angle);GameObject bullet = GameObject.Instantiate (m_BulletPrefab ,i_pos ,rot);bullet.GetComponent<;Rigidbody>; ().AddForce (transform.forward * 20, ForceMode.VelocityChange);Destroy(bullet, 3);}
イベント同期
ダメージを受ける
*SetHealthPoint (m_healthPoint - 10);
*Vector3 pos = transform.position + transform.forward * 2f;*Vector3 angle = transform.eulerAngles;
自分自身の弾丸でトリガーを引かないようにやや手前から発射
処理が重いのでPhotonViewを付けずに位置と角度を渡す
*m_photonView.RPC ("Shoot", PhotonTargets.AllViaServer, pos, angle);
キーボード入力による移動処理
*var v = Input.GetAxis ("Vertical");
キーボード入力による回転処理
*var h = Input.GetAxis ("Horizontal");
*public void SetPlayerDeathState( bool isDeath ) {var properties  = new ExitGames.Client.Photon.Hashtable();properties.Add ("player-id", PhotonNetwork.player.ID);properties.Add ("isDeath", isDeath);PhotonNetwork.player.SetCustomProperties( properties );}
ここから重要
*public void SetPlayerDeathState( bool isDeath ) {var properties  = new ExitGames.Client.Photon.Hashtable();properties.Add ("player-id", PhotonNetwork.player.ID);properties.Add ("isDeath", isDeath);PhotonNetwork.player.SetCustomProperties( properties );}
===============================
全員分回す
*var aliveList = new ArrayList();

自分のアバターを他のクライアントにも生成
*GameObject avatar = PhotonNetwork.Instantiate ("Avatar", new Vector3(0f,1f,0f), Quaternion.identity, 0);
初期設定
*SetPlayerName ("Player-Id: " + PhotonNetwork.player.ID);
*void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info) {if (stream.isWriting) {// 自分の情報を送るstring myName = this.gameObject.name;int myHealthPoint = m_healthPoint;stream.SendNext (myName);stream.SendNext (myHealthPoint);} else {// 他人の情報を受け取るstring otherName = (string)stream.ReceiveNext();int otherHealthPoint = (int)stream.ReceiveNext();SetPlayerName (otherName);SetHealthPoint (otherHealthPoint);}}
ストリーム同期
自分の情報を送る
*string myName = this.gameObject.name;
他人の情報を受け取る
*string otherName = (string)stream.ReceiveNext();
*void Shoot(Vector3 i_pos, Vector3 i_angle) {// 全クライアントの中の自分が一斉に弾丸を発射するQuaternion rot = Quaternion.Euler (i_angle);GameObject bullet = GameObject.Instantiate (m_BulletPrefab ,i_pos ,rot);bullet.GetComponent<;Rigidbody>; ().AddForce (transform.forward * 20, ForceMode.VelocityChange);Destroy(bullet, 3);}
イベント同期
全クライアントの中の自分が一斉に弾丸を発射する
*Quaternion rot = Quaternion.Euler (i_angle);
ダメージを受ける
*SetHealthPoint (m_healthPoint - 10);
*Vector3 pos = transform.position + transform.forward * 2f;*Vector3 angle = transform.eulerAngles;
自分自身の弾丸でトリガーを引かないようにやや手前から発射
処理が重いのでPhotonViewを付けずに位置と角度を渡す
*m_photonView.RPC ("Shoot", PhotonTargets.AllViaServer, pos, angle);
自分のアバターだけを動かす
*var v = Input.GetAxis ("Vertical");

*int BUFFER_SIZE = 32;
バッファーサイズ(あえて小さく設定)
*{// 検索ブロック位置の繰り返しfor (int i = 0; ; i++){// ブロック開始位置に移動offset = Math.Min((int)fs.Length, (i + 1) * BUFFER_SIZE);loc = 0;if (fs.Length <;= i * BUFFER_SIZE){// ファイルの先頭まで達した場合if (foundCount >; 0 || fs.Length >; 0) break;// 行が未存在throw new ArgumentOutOfRangeException("NOT FOUND DATA");}fs.Seek(-offset, SeekOrigin.End);// ブロックの読み込みint readLength = offset - BUFFER_SIZE * i;for (int j = 0; j <; readLength; j += fs.Read(buffer, j, readLength - j)) ;// ブロック内の改行コードの検索for (int k = readLength - 1; k >;= 0; k--){if (buffer[k] == 0x0A){if (isFirst &amp;&amp; k == readLength - 1) continue;if (++foundCount == lines){// 所定の行数が見つかった場合loc = k + 1;isFound = true;break;}}}isFirst = false;if (isFound) break;}// 見つかった場合fs.Seek(-offset + loc, SeekOrigin.End);using (var sr = new StreamReader(fs, Encoding.GetEncoding(encoding))){return sr.ReadToEnd();}}
ファイル共有モードで開く
*for (int i = 0; ; i++)*{
検索ブロック位置の繰り返し
ブロック開始位置に移動
*offset = Math.Min((int)fs.Length, (i + 1) * BUFFER_SIZE);
*if (foundCount >; 0 || fs.Length >; 0) break;*// 行が未存在
ファイルの先頭まで達した場合
行が未存在
*throw new ArgumentOutOfRangeException("NOT FOUND DATA");
ブロックの読み込み
*int readLength = offset - BUFFER_SIZE * i;
*for (int k = readLength - 1; k >;= 0; k--)*{
ブロック内の改行コードの検索
所定の行数が見つかった場合
*loc = k + 1;
見つかった場合
*fs.Seek(-offset + loc, SeekOrigin.End);

*void Start () {}
Use this for initialization
*void Update () {transform.position =GameObject.Find("Main Camera").transform.position+ InputTracking.GetLocalPosition(XRNode.RightHand)- InputTracking.GetLocalPosition(XRNode.Head);transform.eulerAngles =InputTracking.GetLocalRotation(XRNode.RightHand).eulerAngles;}
Update is called once per frame
*public Transform muzzle;*// 弾丸の速度
弾丸発射点
弾丸の速度
*public float speed = 1000;
*void Start () {}
Use this for initialization
*void Update () {time += Time.deltaTime;if(Input.GetAxis("10th axis") == 1F &amp;&amp; time >; 1){Debug.Log("Fire");// 弾丸の複製GameObject bullets = GameObject.Instantiate(bullet) as GameObject;// 弾丸の位置を調整bullets.transform.position = muzzle.position;bullets.GetComponent<;Rigidbody>;().AddForce(gameObject.transform.forward * speed);cannon2 = GetComponent<;AudioSource>;();cannon2.PlayOneShot(cannon2.clip);time = 0;}transform.position =GameObject.Find("Main Camera").transform.position +InputTracking.GetLocalPosition(XRNode.RightHand)-InputTracking.GetLocalPosition(XRNode.Head);transform.eulerAngles = InputTracking.GetLocalRotation(XRNode.RightHand).eulerAngles;}
Update is called once per frame
弾丸の複製
*GameObject bullets = GameObject.Instantiate(bullet) as GameObject;
*bullets.transform.position = muzzle.position;*bullets.GetComponent;Rigidbody>;().AddForce(gameObject.transform.forward * speed);
弾丸の位置を調整

*var googleHomeWebhookUrl = "https:
xxxxxxxx.ngrok.iogoogle-home-notifier";

ここでStyleCopを呼ぶ
*}
全ファイルを表示するとログ出力がTruncateされるので違反が出たファイルと箇所だけ表示するように整形
*var tmpLogs = new List<;string>;();
結果をまとめる
*bool existsViolation = violationCount >; 0;
*if (EditorApplication.isPlayingOrWillChangePlaymode)*{
DidReloadSciptsは再生直後にも発火するのでガードしておく

最低限必要なビンを用意し、listに入れる
*int total = items.Sum();
*foreach (var n in items.OrderByDescending(a =>; a)) {*// nが入るビンを見つける （空きが最大のビン）
各項目をビンに入れてゆく
*var target = binList.Select(b =>; new { Bin = b, Space = BinSize - b.Sum(t =>; t) })
nが入るビンを見つける （空きが最大のビン）
*} else {
nが入るビンが見つかったので、そこに入れる
*List<;int>; bin2 = new List<;int>;() { n };
見つからなかったので、新しいビンを用意する
*private static void PrintResult(IEnumerable<;IEnumerable<;int>;>; result) {var sb = new StringBuilder();foreach (var bin in result) {var list = string.Join(",", bin.Select(n =>; n.ToString()).ToArray());var sum = bin.Sum();sb.AppendLine($"{sum,5}: [{list}]");}Console.WriteLine(sb.ToString());}
結果を表示

unit を初期化
*unit.Code = c;

*var indexPath = "http:
127.0.0.1:80sample.html";

デシリアライザをデフォルトの設定で生成
*var builder = new DeserializerBuilder();
ファイルの内容をSomeObjectにデシリアライズ
*SomeObject deserializedObj = null;
*Console.WriteLine(string.Format("Number : {0}", deserializedObj.Number));
結果をコンソール出力

*{throw new NotImplementedException();}
返り値intできちんとつくられた！

*var settings = new ConnectionConfiguration(new Uri("http:
" + host + ":" + port))
*{public static IEnumerable<;IEnumerable<;T>;>; Chunks<;T>;(this IEnumerable<;T>; list, int size){while (list.Any()){yield return list.Take(size);list = list.Skip(size);}}}
from https:webbibouroku.com/Blog/Article/chunk-linq

*Select(element).SelectByText("text");
表示テキスト

*animation?.TryStart(DestinationImage, new UIElement[] { DescriptionRoot });
省略

*Debug.Log("マイナス側：" + _numberLoopList[-_index]);
0 3 2 1 0 3 2 1...

シリアル化されたGraphDefをファイルからロードします。
*string modelFile = @"E:\****\beginner-const-graph.pb.pb";
学習モデルのグラフを指定する。
入出力テンソルの名前をsessionに登録する
*runner.AddInput(graph["input"][0], tensor);

*Console.WriteLine(outputStr);
StorageのShaaredAccessSignatureのテスト
書込SasUriを利用してアクセス
*await new CloudBlobContainer(new Uri(setting.WriteContainerSas))

*Console.WriteLine(query);
2, 4, 6

SharedApplication に触れるのは Init の後
*NSApplication.SharedApplication.Delegate = new AppDelegate();

*string NonErrorHandling(string name){return $"Hello! {name}";}
メソッド定義
呼び出し
*var userName = "Sho";
*{if (string.IsNullOrEmpty(name)) return null;return $"Hello! {name}";}
メソッド定義
呼び出し
*var userName = "Sho";
*{if (string.IsNullOrEmpty(name)) return "E001";// some validation with return error code "Exxx";return $"Hello! {name}";}
メソッド定義
*return $"Hello! {name}";
some validation with return error code "Exxx";
呼び出し
*var userName = "Sho";
*{if (string.IsNullOrEmpty(name)){greeting = null;return false;}greeting = $"Hello! {name}";return true;}
メソッド定義
呼び出し
*var userName = "Sho";
*greeting = $"Hello! {name}";
some validation with return error code "Exxx";
呼び出し
*var userName = "Sho";
*{NoError,NameIsEmpty,// SomeError}
エラーの種類
*{if (string.IsNullOrEmpty(name)){greeting = null;return ErrorType.NameIsEmpty;}// some validation with return error code "Exxx";greeting = $"Hello! {name}";return ErrorType.NoError;}
メソッド定義
*greeting = $"Hello! {name}";
some validation with return error code "Exxx";
呼び出し
*var userName = "Sho";
*{NoError,NameIsEmpty,// SomeError}
エラーの種類
*{if (string.IsNullOrEmpty(name)){return (null, ErrorType.NameIsEmpty);}// some validation with return error code "Exxx";return ($"Hello! {name}", ErrorType.NoError);}
メソッド定義
*return ($"Hello! {name}", ErrorType.NoError);
some validation with return error code "Exxx";
呼び出し
*var userName = "Sho";
*{public string ErrorCode {get; set;}}
独自定義の例外
*{if (string.IsNullOrEmpty(name)){return (null, new ArgumentNullException(nameof(name)));}string person = FindByName(name);if (person == null){return (null, new MyException { ErrorCode = "E001" });}return ($"Hello! {name}", null);}
メソッド定義
*if (name.StartsWith("0"))*{
名前から人を探しに行く
見つからなかった
*return null;
呼び出し
*var userName = "Sho";
*{if (string.IsNullOrEmpty(name)) throw new ArgumentNullException(nameof(name));return $"Hello! {name}";}
メソッド定義
呼び出し
*var userName = "Sho";

*mock.Object.DoSomething("abc");
-&gt; "ABC"

ワークブックコレクションオブジェクトを生成する。
*object excelBooks = excelApp.GetType().InvokeMember(
Excelファイルのオープン
*object excelBook = excelBooks.GetType().InvokeMember(
*{return o.GetType().InvokeMember(name, BindingFlags.InvokeMethod, null, o, args);}
paramsは可変長引数
Openの引数は4つあるが必要な数だけ渡すので大丈夫らしい
*var presentation = OLEHelper.call(presentations, "Open", path);
presentationsを解放しても開いたpresentationに影響はない
*OLEHelper.freeObject(presentations);
オブジェクトを全部解放しないとウインドウが閉じられない
*OLEHelper.freeObject(slideshowview);

*SampleInterpreter.Execute("1*(1-1)");
=&gt; "0"

*if (mouseDownFlag) pictureBox2.Width = e.X;
ドラッグ中にオレンジの波形の幅を変更
ドラッグが終了した場所から曲の再生位置を計算して設定
*audioFile.Position = (int)(((double)e.X / pictureBox1.Width) * audioFile.Length);

セルの生成
*Cells = Enumerable.Range(0, CountRowColumn)
*.Select(p =>; new Cell { Position = p }))
位置をセルに変換
1次元に平坦化
*.SelectMany(x =>; x)
全セルに自身の隣人を登録させる
*Cells.ForEach(cell =>; cell.SetNeiberCells(Cells));
Timerの更新回数を現在の世代として公開
*Generation = timer.ToReadOnlyReactiveProperty();
*{//並列で全セルに次の世代での生死を決定Cells.AsParallel().ForEach(c =>; c.DetermineNextGeneration());//生死の更新Cells.ForEach(c =>; c.UpdateGeneration());});
Timer実行内容の登録
並列で全セルに次の世代での生死を決定
*Cells.AsParallel().ForEach(c =>; c.DetermineNextGeneration());
生死の更新
*Cells.ForEach(c =>; c.UpdateGeneration());
登録パターンをファイルから呼び出す
*ReadSavedStatesFromFile();
生存しているセルの位置情報を集める
*var aliveCellPositions = GetAlivePositions();
左上端の位置を計算
*var minPosition = new Position();
*{Name = saveName,AliveCellPositions = aliveCellPositions//位置パターンを左上つめ（最小化）する.Select(x =>; x - minPosition).ToList()};
保存パターンの生成
位置パターンを左上つめ（最小化）する
*.Select(x =>; x - minPosition)
パターンコレクションに追加
*this.SavedStates.Add(currentState);
パターンコレクションをファイル保存
*WriteSavedStatesToFile();
生存セルが中央に配置されるように調整
*var maxPosition = new Position();
生存セルリストと位置が一致していたら生、していなかったら死に変更
*Cells.ForEach(c =>;
*if (currentAlive)*{
現在生きていて、
*if (countneiberAlive <;= 1)*{
過疎なら死
*if (countneiberAlive >;= 4)*{
過密なら死
*{//誕生なら生if (countneiberAlive == 3){return true;}}
死んでいて、
*if (countneiberAlive == 3)*{
誕生なら生
それ以外はそのまま
*return currentAlive;

*int n = Encoding.GetEncoding("Shift_JIS").GetByteCount("字");*,,,
半角なら 1, 全角なら 2
*var kindTexts = new List<;string>;(new string[] { "_", "N", "A", "H", "W", "F", "Na", });
読み込み
undefined も含めたマッピング構築
*var map = new List<;int>;();
昇順になっていない場合は異常と判断
*throw new InvalidDataException();
サロゲートペアの場合
*int cp = char.ConvertToUtf32(elm[0], elm[1]);
結合文字は、１文字目だけで判定
*this.column += this.GetWidth(elm[0]);

結果
*1 : 1
結果 [123  ]
*Console.WriteLine("[" + target.PadRight(197-192) + "]");
結果 [123   ]
*Console.WriteLine("[" + target.PadRight(197-192 + 1) + "]");

画面初期表示時に表示したい文字をセットしておく
*InputedText = "Init Value";
viewはDataContext経由でViewModelを取得するので、設定する
*this.DataContext = new MainWindowViewModel();
テストなのでメッセージを出すだけにしとく
*MessageBox.Show(_vm.InputedText);

*int index = String.Empty.Length;
0をセット

*await waitQueueTask;
実際に待ち合わせを行う
*while (_queue.TryDequeue(out var t)) await t(ct);*}
キューイングされているものを待つ
先にTaskを起動しておかないとMock等で即コールバックが呼ばれた時に取りこぼす
*var waitLoginTask = _onLoggedIn.FirstAsync(x =>; x.userId == userId).ToTask();

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

（1行の場合）
*,,,
*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame
*void Start () {}
オブジェクト起動時に実行
*void Update () {}
フレーム毎に連続実行
*{//hogeObjectをアクティブにするhogeObject.SetActive(true);}
このメソッドが呼び出されたときに実行
hogeObjectをアクティブにする
*hogeObject.SetActive(true);
アクティブにしたいゲームオブジェクト（キャラクター、ボタンなど）
*public GameObject hogeObject;
*{//hogeObjectをアクティブにするhogeObject.SetActive(true);}
このメソッドが呼び出されたときに実行
hogeObjectをアクティブにする
*hogeObject.SetActive(true);
*{//hogeObjectをアクティブにするhogeObject.SetActive(true);}
このメソッドが呼び出されたときに実行
hogeObjectをアクティブにする
*hogeObject.SetActive(true);

*List<;string>; func1(List<;Student>; data){List<;string>; output;foreach(var student in data){if(student.Height >;= 170){output.Add(student.Name);}}return output;}
学生の一覧から、身長が170cm以上の者達の名前の一覧を作成する
*List<;string>; func2(List<;Student>; data){return data.Where(s =>; s.Height >;= 170).Select(s =>; s.Name).ToList();}
同上(LINQ版)
処理1
*func1();
処理2(時間がかかる処理)
*func2();
処理3
*func3();
処理1
*func1();
処理2(時間がかかる処理)
非同期処理する関数では、関数名の末尾にAsyncを付けるのが慣例
*await func2Async();
処理3
*func3();

*Console.WriteLine(roObs.Count);
1

もともとあったコード。m_meshに頂点情報(座標と順番)や色情報を渡している |
*m_Mesh.Clear();
*//Add following 2 lines. This cord attaches triangular mesh information to collider.*GetComponent;MeshCollider>;().sharedMesh = null;
下記の2行を新たに追加。上記で作成した三角形の集合をコライダーに反映
または
*Session.CreateAnchor(Pose);

*#if !___server___*Task;
サーバ側のコンパイラスイッチには___server___の定数を指定
戻り値ありはValueTask&lt;T&gt;
*ValueTask<;int>; TallyAsync(int a, int b
戻り値なしはTask
*Task MethodAsync(int a, int b
SharedProjectに参照させる。
RPCで呼び出すインターフェースを識別するためにContractのインターフェースを指定
*public interface Interface : INetStitchContract
普通にインスタンス生成　オーバーロードにHttpClientの引数もあるため、認証周りはそちらで指定
*var client = new NetStitchClient(url);
SharedProjectに定義したインターフェースをGenericの型に指定する
*await client.Create<;Interface>;.TallyAsync(100, 4);
*{public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory){//クラスからDLLを参照し、DLLに含まれるINetStitchContractを継承した//メソッドを呼び出せるようにする。app.UseNetStitch(typeof(Startup));}}
ASP.Net Core で使ういつものやつ
クラスからDLLを参照し、DLLに含まれるINetStitchContractを継承した
メソッドを呼び出せるようにする。
*app.UseNetStitch(typeof(Startup));
*{public async ValueTask<;int>; TallyAsync(int a, int b){return a + b;}}
SharedProjectに定義したインターフェースを実装するだけ

日付更新ファイルから日付を取得
*/* ------------------------------*/
排他ロックをかける
*System.IO.FileStream fs = new System.IO.FileStream(
*TextFieldParser parser = new TextFieldParser(fs, Encoding.GetEncoding("Shift_JIS"));*parser.TextFieldType = FieldType.Delimited;
ファイル読込
キーに紐づく日付の加算
*/* ------------------------------*/
一つの文字列に格納
*/* ------------------------------*/
更新処理
*/* ------------------------------*/
*{// 成功}
失敗
成功
*}

*Write(array.ToArray());
こうして書き換えられるのを防止する

*private GraphicsCaptureBridge.Capture capture = null;
この行を追加
コンストラクタの段階ではウィンドウハンドルが生成されていないのでダメ
*capture = new GraphicsCaptureBridge.Capture(pictureBox1.Handle.ToInt64());

*Status s = tokens.Statuses.Update(status: "upload image", media_ids: ids);
画像をツイート

*class BinPackingSolver1 : IBinPacking {public int BinSize { get; set; }public BinPackingSolver1(int size) {this.BinSize = size;}public ICollection<;ICollection<;int>;>; Solve(int[] items) {// 最初に一つのビンを用意するvar binList = new List<;ICollection<;int>;>;();binList.Add(new List<;int>;());// 各項目をビンに入れてゆくforeach (var n in items) {// nが入るビンを見つける （空きが最大のビン）var target = binList.Select(b =>; new { Bin = b, Space = BinSize - b.Sum(t =>; t) }).Where(x =>; x.Space >;= n).OrderByDescending(x =>; x.Space).Select(x =>; x.Bin);var bin = target.FirstOrDefault();if (bin != null) {// nが入るビンが見つかったので、そこに入れるbin.Add(n);} else {// 見つからなかったので、新しいビンを用意するList<;int>; bin2 = new List<;int>;() { n };binList.Add(bin2);}}return binList;}}
解法A：最も空きが多いビンに入れていく解法
最初に一つのビンを用意する
*var binList = new List<;ICollection<;int>;>;();
*foreach (var n in items) {*// nが入るビンを見つける （空きが最大のビン）
各項目をビンに入れてゆく
*var target = binList.Select(b =>; new { Bin = b, Space = BinSize - b.Sum(t =>; t) })
nが入るビンを見つける （空きが最大のビン）
*} else {
nが入るビンが見つかったので、そこに入れる
*List<;int>; bin2 = new List<;int>;() { n };
見つからなかったので、新しいビンを用意する
*private static (int[] ,int) InputDate() {Console.Write("荷物の重さ(カンマ区切り)=>; ");var itemsText = Console.ReadLine();var items = itemsText.Split(',').Select(x =>; int.Parse(x.Trim())).ToArray();Console.Write("1台のコンテナの容量=>; ");var sizeText = Console.ReadLine();int binsize = int.Parse(sizeText);return (items, binsize);}
データの入力
*private static void PrintResult(IEnumerable<;IEnumerable<;int>;>; result) {var sb = new StringBuilder();foreach (var bin in result) {var list = string.Join(",", bin.Select(n =>; n.ToString()).ToArray());var sum = bin.Sum();sb.AppendLine($"{sum,5}: [{list}]");}Console.WriteLine(sb.ToString());}
結果を表示
*class BinPackingSolver2 : IBinPacking {public int BinSize { get; set; }public BinPackingSolver2(int size) {BinSize = size;}public ICollection<;ICollection<;int>;>; Solve(int[] items) {// 最初に一つのビンを用意するvar binList = new List<;ICollection<;int>;>;();binList.Add(new List<;int>;());// 各項目をビンに入れてゆくforeach (var n in items) {// nが入るビンを見つける （空きが最小のビン）var target = binList.Select(b =>; new { Bin = b, Space = BinSize - b.Sum(t =>; t) }).Where(x =>; x.Space >;= n).OrderBy(x =>; x.Space).Select(x =>; x.Bin);var bin = target.FirstOrDefault();if (bin != null) {// nが入るビンが見つかったので、そこに入れるbin.Add(n);} else {// 見つからなかったので、新しいビンを用意するList<;int>; bin2 = new List<;int>;() { n };binList.Add(bin2);}}return binList;}}
解法０２：最も空きが少ないビンに入れていく解法
最初に一つのビンを用意する
*var binList = new List<;ICollection<;int>;>;();
*foreach (var n in items) {*// nが入るビンを見つける （空きが最小のビン）
各項目をビンに入れてゆく
*var target = binList.Select(b =>; new { Bin = b, Space = BinSize - b.Sum(t =>; t) })
nが入るビンを見つける （空きが最小のビン）
*} else {
nが入るビンが見つかったので、そこに入れる
*List<;int>; bin2 = new List<;int>;() { n };
見つからなかったので、新しいビンを用意する

Stripe の初期設定
*StripeConfiguration.SetApiKey(ConfigurationManager.AppSettings["StripeSecretKey"]);
カード処理を実装するアプリケーションサービス
*private readonly HomeControlerService service;
商品を発注、カード決裁入力
*[Authorize]
カード情報入力画面（checkout.js）に必要な引数をセット（Stripeの公開鍵とメールアドレス）
*ViewBag.PublishableKey = ConfigurationManager.AppSettings["StripePublishableKey"];
カード決済と、決裁結果を表示
*[HttpPost]
クロスドメインでも実行できるように
*Response.Headers["Expires"] = "-1";
課金処理
*service.Charge(stripeEmail, stripeToken);
課金エラー処理
本当なら service からスローされたエラーを処理します
こんなアバウトなキャッチはだめですよ！(^^;;
*ViewBag.Message = "エラー発生：" + ex.Message;
*{var customersService = new StripeCustomerService();var chargesService = new StripeChargeService();StripeCustomer customer;Customer dbCustomer;// DBにメアドが存在しなければ、顧客登録を行うvar dbCustomers = AppDb.Customers.Where(c =>; c.Email == stripeEmail);if (dbCustomers.Count() == 0){// Stripe に顧客を追加customer = customersService.Create(new StripeCustomerCreateOptions{Email = stripeEmail,SourceToken = stripeToken});// DB に顧客を追加dbCustomer = new Customer(){Email = stripeEmail,StripeId = customer.Id};AppDb.Customers.Add(dbCustomer);AppDb.SaveChanges();}else{// Stripe の顧客を取得dbCustomer = dbCustomers.First();customer = customersService.Get(dbCustomer.StripeId);}// 課金を追加var charge = chargesService.Create(new StripeChargeCreateOptions{Amount = 1000,Currency = "jpy",Description = "Example charge",CustomerId = customer.Id});// ここで課金結果をDBに登録（今回は実装しない）// DBに charge.id を保管すれば、Stripe 側の課金情報と紐づけできる}
カード決裁処理
DBにメアドが存在しなければ、顧客登録を行う
*var dbCustomers = AppDb.Customers.Where(c =>; c.Email == stripeEmail);
*{Email = stripeEmail,SourceToken = stripeToken});
Stripe に顧客を追加
*{Email = stripeEmail,StripeId = customer.Id};
DB に顧客を追加
Stripe の顧客を取得
*dbCustomer = dbCustomers.First();
*{Amount = 1000,Currency = "jpy",Description = "Example charge",CustomerId = customer.Id});
課金を追加
ここで課金結果をDBに登録（今回は実装しない）
DBに charge.id を保管すれば、Stripe 側の課金情報と紐づけできる
*}

*return string.Join(", ", s.Select(e =<; e.ToString()));
おそらくここにナミナミが...
*if(!(s is System.Array)) {*throw new System.ArgumentException("s には配列型を指定する必要があります");
例

以下caseに応じた分岐処理
*}
*if (EditorGUI.EndChangeCheck())*{
変更があったときだけ
*if (_settings.MaterialList == null || _settings.MaterialNameList.Count == 0)*{
リストが空の時、エラーを吐くのでここで拾う
*if (_settings.MaterialNameList.Count <;= _selectedMaterialIndex) _settings.SelectedMaterialIndex = 0;*_selectedMaterialIndex = EditorGUILayout.Popup("使用するマテリアル", _settings.SelectedMaterialIndex, _settings.MaterialNameList.ToArray());
リストの設定漏れは一番若い数字に
変更した値を設定側で保持
*_settings.SelectedMaterialName = _settings.MaterialNameList[_selectedMaterialIndex];
マテリアル設定用ScriptableObject読み込み
*var materialSettings = Resources.Load<;MaterialSettings>;("MaterialSettings");
選択したマテリアル名取得
*var materialName = materialSettings.SelectedMaterialName;
マテリアル名から使用するマテリアル取得
*var useMaterial = materialSettings
*transform.GetComponent<;MeshRenderer>;().material = useMaterial;*}
マテリアル適用

変更したい項目をここに書く
*si.SvgPixelsPerUnit = 50;

*= new Person3();
C#3版
= new Person5();  C#5版
= new Person6();  C#6版
= new Person7();  C#7版
= new Person3X();  C#3式木版
= new PersonVM(); 独自ViewModel継承版
= new PersonNB(); 独自ViewModel継承バッキングフィールド無し版
= new PersonEX(); 拡張メソッド使用版
= new PersonMV(); MVVMライブラリ使用版
= new PersonRP(); ReactiveProperty版
= new PersonFD(); Fody使用版
*}
ラムダ式のBodyを取得する。MemberExpressionじゃなかったら駄目
*var memberEx = propertyName.Body as MemberExpression;
*if (EqualityComparer<;TResult>;.Default.Equals(source, value))*return false;
値が同じだったら何もしない
イベント発行
*RaisePropertyChanged(propertyName);
プロパティ名をKeyとしたバッキングフィールド代わりのDictionary
*private Dictionary<;string, object>; currentPropertyValues = new Dictionary<;string, object>;();
プロパティの型の既定値を初期値とする
*=>; GetPropertyValue(default(TResult), propertyName);
*if (!currentPropertyValues.ContainsKey(propertyName))*currentPropertyValues[propertyName] = initialValue;
キーに値が無かったら初期値を現在値に入力
Dictionaryから現在値を取得してプロパティの型に変換する
*return (TResult)currentPropertyValues[propertyName];
*if (EqualityComparer<;TResult>;.Default.Equals(GetPropertyValue<;TResult>;(propertyName), value))*return false;
値が同じだったら何もしない
プロパティの現在値に入力
*currentPropertyValues[propertyName] = value;
イベント発行
*RaisePropertyChanged(propertyName);
*if (_this == null) return;*// ラムダ式のBodyを取得する。MemberExpressionじゃなかったら駄目
ハンドラに何も登録されていない場合は何もしない
*if (!(propertyName.Body is MemberExpression memberEx))*throw new ArgumentException();
ラムダ式のBodyを取得する。MemberExpressionじゃなかったら駄目
() =&gt; NameのNameの部分の左側に暗黙的に存在しているオブジェクトを取得する式をゲット
ConstraintExpressionじゃないと駄目
*if (!(memberEx.Expression is ConstantExpression senderExpression))
○：定数なのでValueプロパティからsender用のインスタンスを得る
*var sender = senderExpression.Value;
下準備が出来たので、イベント発行！！
*_this(sender, new PropertyChangedEventArgs(memberEx.Member.Name));
*if (EqualityComparer<;TResult>;.Default.Equals(source, value))*return false;
値が同じだったら何もしない
イベント発行
*Raise(_this, propertyName);
*public class PersonX : INotifyPropertyChanged*{
！！このコードは2017年時点ではコンパイルできません！！

*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame
式入力テキスト
*public Text Formula;
結果表示テキスト
*public Text Answer;
各数字ボタン
*public Button[] bNumber;
割るボタン
*public Button bDivide;
計算ボタン
*public Button bEqual;
クリアボタン
*public Button bClear;
*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame
*public void InputNumber(Text number){}
各数字ボタン押下
*public void InputDivide(Text divideButton){}
割るボタン押下
*public void InputEqual(Text equal){}
計算ボタン押下
*public void InputClear(Text equal){}
クリアボタン押下
式入力テキスト
*public Text Formula;
結果表示テキスト
*public Text Answer;
各数字ボタン
*public Button[] bNumber;
割るボタン
*public Button bDivide;
計算ボタン
*public Button bEqual;
クリアボタン
*public Button bClear;
*void Start () {//初期化Formula.text = "";Answer.text = "";}
Use this for initialization
初期化
*Formula.text = "";
*void Update () {}
Update is called once per frame
*public void InputNumber(Text number){// 押下したボタンの数字を式欄に追記するFormula.text += number.text;}
数字ボタン押下
押下したボタンの数字を式欄に追記する
*Formula.text += number.text;
*public void InputDivide(Text divideButton){// 数字が未入力か、すでに÷があればスルーif(Formula.text == "" || Formula.text.Contains("÷")){return;}// ÷を式欄に追記するFormula.text += divideButton.text;}
割るボタン押下
*if(Formula.text == "" || Formula.text.Contains("÷")){*return;
数字が未入力か、すでに÷があればスルー
÷を式欄に追記する
*Formula.text += divideButton.text;
*public void InputEqual(Text equal){// ÷がないか、文字列の最後が÷ならスルー★if(!Formula.text.Contains("÷")){return;}// 入力した式を割る数と割られる数に分けるstring[] inputString = Formula.text.Split('÷');int leftNumber = int.Parse(inputString[0]);int rightNumber = int.Parse(inputString[1]);// 割られる数がゼロならスルーif(rightNumber == 0){return;}// 商int quotient = leftNumber / rightNumber;// 余りint remainder = leftNumber % rightNumber;// 計算結果を表示Answer.text = quotient.ToString() + "…" + remainder.ToString();}
計算ボタン押下
*if(!Formula.text.Contains("÷")){*return;
÷がないか、文字列の最後が÷ならスルー★
入力した式を割る数と割られる数に分ける
*string[] inputString = Formula.text.Split('÷');
*if(rightNumber == 0){*return;
割られる数がゼロならスルー
商
*int quotient = leftNumber / rightNumber;
余り
*int remainder = leftNumber % rightNumber;
計算結果を表示
*Answer.text = quotient.ToString() + "…" + remainder.ToString();
*public void InputClear(Text equal){//初期化Formula.text = "";Answer.text = "";}
クリアボタン押下
初期化
*Formula.text = "";

*ret[i] = Sin(1000.0 * sr * i);
1000ヘルツ

*型名 変数 = (型名)e.Current;
(3)
Dispose処理(4)
*}
先頭のセルを格納するフィールド。
*private Cell Head;
*public Array() { Head = new Cell(null); }
まず、コレクションのインスタンスを生成したと同時に
*public Array() { Head = new Cell(null); }
空のセル(フィールドがnullなセル。要素の格納はできない)を作成する
ここはあくまで現在のセルの場所を示すためのものなので、
例えば、新たにセルを加えたりなどセルの場所を扱う必要のない操作に関しては
一切不要（セルを加える操作では、このコレクションの場合常に先頭に追加されるため不要）
*class ArrayEnumerator : IEnumerator
*{public Object Item { set; get; }public Cell Next { set; get; }//新たにセルが作られたとき、各フィールドに値を代入する。//コンストラクタの引数は、セルの要素。public Cell(Object item){Item = item;}}
セル。要素と次のセルを格納するフィールドを持つ。
新たにセルが作られたとき、各フィールドに値を代入する。
コンストラクタの引数は、セルの要素。
*public Cell(Object item)
*{//現在の先頭のセル(ヘッド)を一時的に保存Cell temphead = Head;//ヘッドに、新たに作成したセルを格納。Head = new Cell(item);//ヘッドのもつ、次のセルを格納するフィールドに追加するセルを代入。Head.Next = temphead;}
これがなくては何もできない。
現在の先頭のセル(ヘッド)を一時的に保存
*Cell temphead = Head;
ヘッドに、新たに作成したセルを格納。
*Head = new Cell(item);
ヘッドのもつ、次のセルを格納するフィールドに追加するセルを代入。
*Head.Next = temphead;
*public Object Current { get { return CurrentCell.Item; } }
矢印が指し示すセルの要素を返す
返り値は、ちゃんと動かせたかどうか。
true(矢印を動かせた)、false(もうこれ以上矢印を動かせない)
*public bool MoveNext()
*if (CurrentCell == null)*//矢印の位置を初期位置(Head)に戻す。
現在指し示しているセルの次のセル(Next)があるかどうかを調べる。、
矢印の位置を初期位置(Head)に戻す。
*CurrentCell = Array.Head;
矢印を動かす。
*CurrentCell = CurrentCell.Next;
*if (CurrentCell == null)*return false;
条件文が同じなので統合したくなるが、それはできない。
*public void Reset() { CurrentCell = null; }
先頭位置を元に戻す
先頭のセルを格納するフィールド。
*private Cell Head;
*public Array() { Head = new Cell(null); }
空のセル(フィールドがnullなセル。要素の格納はできない)を作成する
*{Cell CurrentCell;Array Array;public ArrayEnumerator(Array array){this.Array = array;//初めにどのセルを指し示すのかを決める。CurrentCell = null;}//現在指し示されているセルの要素を返すpublic Object Current { get { return CurrentCell.Item; } }//返り値のbool値は、ちゃんと動かせたかどうかという情報。//true(矢印を動かせた)、false(もうこれ以上矢印を動かせない)public bool MoveNext(){//現在指し示しているセルの次のセル(Next)があるかどうかを調べる。、if (CurrentCell == null)//矢印の位置を初期位置(Head)に戻す。CurrentCell = Array.Head;else//矢印を動かす。CurrentCell = CurrentCell.Next;//条件文が同じなので統合したくなるが、それはできない。if (CurrentCell == null)return false;return true;}//先頭位置を元に戻すpublic void Reset() { CurrentCell = null; }}
反復子のクラス
初めにどのセルを指し示すのかを決める。
*CurrentCell = null;
*public Object Current { get { return CurrentCell.Item; } }
現在指し示されているセルの要素を返す
返り値のbool値は、ちゃんと動かせたかどうかという情報。
true(矢印を動かせた)、false(もうこれ以上矢印を動かせない)
*public bool MoveNext()
*if (CurrentCell == null)*//矢印の位置を初期位置(Head)に戻す。
現在指し示しているセルの次のセル(Next)があるかどうかを調べる。、
矢印の位置を初期位置(Head)に戻す。
*CurrentCell = Array.Head;
矢印を動かす。
*CurrentCell = CurrentCell.Next;
*if (CurrentCell == null)*return false;
条件文が同じなので統合したくなるが、それはできない。
*public void Reset() { CurrentCell = null; }
先頭位置を元に戻す
*{public Object Item { set; get; }public Cell Next { set; get; }//新たにセルが作られたとき、各フィールドに値を代入する。public Cell(Object item){Item = item;}}
セル。要素と次のセルを格納するフィールドを持つ。
*{Item = item;}
新たにセルが作られたとき、各フィールドに値を代入する。
現在のヘッドを一時的に保存
*var temphead = Head;
先頭のセルを、追加したセルに切り替える。
*Head = new Cell(item);
先頭のセルのもつ、次のセルを格納するフィールドに追加するセルを代入。
*Head.Next = temphead;

ここではオリジナルのファイル名の拡張子を取り出し
格納するときは GUID をベースの名前に変えている。
*var orgFileName = ContentDispositionHeaderValue
stream からデータを取り、
それを適当なストレージに格納し、
その URL を返す 処理を実装。
return "https:xxx.xxx.xxx/xxx/" + fileName;
*}

*if(mode == EditMode.Insert)*{
モードによって比較する計算式が異なり、値が有効か判定する
*if(mode == EditMode.Insert)*{
モードによって比較する計算式が異なり、値が有効か判定する
*if(mode == EditMode.Insert)*{
モードによって比較する計算式が異なり、値が有効か判定する

【Cameraクラス側】
*public delegate void DisplayProgress(Mat img, int threshold);
*{// (中略)// フォーム側処理を呼ぶcallback?.Invoke(img2, value);// (中略)}
デコード処理
(中略)
フォーム側処理を呼ぶ
*callback?.Invoke(img2, value);
(中略)
*}
【フォーム側処理】
しきい値を中央に解析する
*string value = await Task.Run(() =>; _camera.Decode(min, max, 1, img, threshold, AnalyzeDisplay));
【Cameraクラス側】
*VideoCapture _cap = null;
*_cap = new VideoCapture(0) { AutoFocus = false };
カメラ有無 0:バックカメラ 1:フロントカメラ
【フォーム側処理】
*bool _isRunning = false;
*{BackgroundWorker worker = (BackgroundWorker)sender;if (!_camera.Enabled) return;while (_isRunning){// bgWorker_ProgressChangedイベントで画像取得Mat dst = _camera.Read();worker.ReportProgress(0, dst);}}
バッググラウンド処理
bgWorker_ProgressChangedイベントで画像取得
*Mat dst = _camera.Read();
*{// カメラ画像表示picMain.ImageIpl = (Mat)e.UserState;}
バッググラウンド進行変更イベント処理
カメラ画像表示
*picMain.ImageIpl = (Mat)e.UserState;
*{_isRunning = true;bgWorker.RunWorkerAsync();tmrCapture.Enabled = true;}
キャプチャー開始処理
*{_isRunning = false;bgWorker.CancelAsync();tmrCapture.Enabled = false;}
キャプチャー停止処理
ターゲットアイコン用(メイン用)
*picMain.Controls.Add(picTargetMain);
キャプチャー画面
*const string CAPTURE_PATH = "caputure.png";
*{if (picMain.Image == null) return;// 画面キャプチャー保存picMain.ImageIpl.SaveImage(CAPTURE_PATH);// 画像読込(中央あたりをトリミング)Mat src = new Mat(CAPTURE_PATH);Rect rc = new Rect((src.Width - picMain.Width) / 2,(src.Height - picMain.Height) / 2 - Camera.IMAGE_MERGIN_SIZE,picMain.Width,picMain.Height + Camera.IMAGE_MERGIN_SIZE);picCapture.ImageIpl = new Mat(new Mat(CAPTURE_PATH), rc);// そのまま解析Result result = _camera.Analyze(picCapture.ImageIpl);if (result == null) return;string decode = result.ToString().Trim();if (decode != "" &amp;&amp; decode != "error"){// 解析出来たなら入力値へ送信Send(decode);}// 解析可能性があるif (decode == "error"){// 自動解析処理AnalyzeAuto(picCapture.ImageIpl, trbThreshold.Value);}}
タイマー処理
画面キャプチャー保存
*picMain.ImageIpl.SaveImage(CAPTURE_PATH);
画像読込(中央あたりをトリミング)
*Mat src = new Mat(CAPTURE_PATH);
そのまま解析
*Result result = _camera.Analyze(picCapture.ImageIpl);
解析出来たなら入力値へ送信
*Send(decode);
*if (decode == "error")*{
解析可能性がある
自動解析処理
*AnalyzeAuto(picCapture.ImageIpl, trbThreshold.Value);
*{Mat result = null;if (_cap.IsOpened()){Mat frame = new Mat();result = new Mat();// カメラ画像の読込み_cap.Read(frame);// グレースケール化Cv2.CvtColor(frame, result, ColorConversionCodes.BGRA2GRAY);}return result;}
カメラ画像の読込み
カメラ画像の読込み
*_cap.Read(frame);
グレースケール化
*Cv2.CvtColor(frame, result, ColorConversionCodes.BGRA2GRAY);
*{BarcodeReader reader = new BarcodeReader{AutoRotate = true,TryInverted = true,// Code-39とQRコードに限定Options = new ZXing.Common.DecodingOptions{TryHarder = true,PossibleFormats = new[] { BarcodeFormat.QR_CODE }.ToList()}};return reader.Decode(img.ToBitmap());}
解析処理
*{TryHarder = true,PossibleFormats = new[] { BarcodeFormat.QR_CODE }.ToList()}
Code-39とQRコードに限定
ファインダパタンの中央点から端までの差
*public const int IMAGE_MERGIN_SIZE = 22;
ポイント情報からQRコード部分を切り取る
*int stX = 0;
左下→左上→右上
*stX = (int)GetMinValue(result.ResultPoints[0].X, result.ResultPoints[1].X) - IMAGE_MERGIN_SIZE;
右下→左下→右上
*stX = (int)GetMinValue(result.ResultPoints[1].X, result.ResultPoints[2].X) - IMAGE_MERGIN_SIZE;
*{return (min1 <;= min2 ? min1 : min2);}
引数の小さい値を取得する
*{return (min1 >;= min2 ? max1 : max2);}
引数の大きい値を取得する

世代管理開始
*/**************************************************************/
*if (i == Generation)*{
指定された最大世代ループ時
*if (File.Exists(target))*{
存在する場合は削除(最大サイズだから)
*if (1 <; i &amp;&amp; i <; Generation)*{
最大未満～当世代未満の場合
*if (File.Exists(target))*{
存在する場合はコピーして削除
*if(i == 2)*{
2世代目の場合
*if (File.Exists(LogPath + LogFileName + Extention))*{
1世代上のファイルがあればコピーして削除
*if (File.Exists(LogPath + LogFileName + (i - 1).ToString().PadLeft(2, '0') + Extention))*{
1世代上のファイルがあればコピーして削除
*if (i == 1)*{
当世代の場合
*if (File.Exists(target))*{
存在する場合はコピーして削除して当世代新規作成

*public IEnumerator CreatePDF (string path) {Document doc = new Document(PageSize.A4.Rotate());var writer = PdfWriter.GetInstance(doc, new FileStream(path, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None));doc.Open();doc.NewPage();yield return StartCoroutine(TakeScreenshot(mainCam, Screen.width, Screen.height));AddImageToPDF(writer, capturedTex, 0, 0);doc.Close();}
create pdf to specific path
*public IEnumerator TakeScreenshot (Camera cam, int width, int height) {RenderTexture rt = new RenderTexture(width, height, 24, RenderTextureFormat.ARGB32);rt.antiAliasing = 8;cam.targetTexture = rt;cam.Render();yield return new WaitForEndOfFrame();RenderTexture.active = rt;capturedTex = new Texture2D(width, height, TextureFormat.RGB24, false);capturedTex.ReadPixels(new Rect(0, 0, width, height), 0, 0);capturedTex.Apply();cam.targetTexture = null;}
coroutine to take screenshot
*public void AddImageToPDF(PdfWriter pdfWriter, Texture2D img, float posX, float posY){byte[] imageBytes = img.EncodeToPNG();iTextSharp.text.Image finalImage = iTextSharp.text.Image.GetInstance(imageBytes);finalImage.ScaleAbsolute(PageSize.A4.Rotate());finalImage.SetAbsolutePosition(posX, posY);var pdfContentByte = pdfWriter.DirectContent;pdfContentByte.AddImage(finalImage);}
add image to pdf

Buildalyzerの起点
*AnalyzerManager manager = new AnalyzerManager();
C#プロジェクトのオープン
*ProjectAnalyzer analyzer = manager.GetProject(@"C:\MyCode\MyProject.csproj");
プロジェクト情報からRoslynで使うWorkspace(プロジェクトやソリューションをまとめたもの)を生成する。
Buildalyzer.Workspacesが必要
*Microsoft.CodeAnalysis.AdhocWorkspace workspace = analyzer.GetWorkspace();
*foreach(var project in workspace.CurrentSolution.Projects)*{
以後Microsoft.CodeAnalysis.AdhocWorkspaceを使用する
個々のプロジェクト処理
プロジェクトのコンパイル(シンボル情報構築)
型がAssemblyではなく、Microsoft.CodeAnalysis.Compilationなので注意
*var compilation = await project.GetCompilationAsync();
コンパイルエラー等がある場合、
完了後にGetDiagnostics()を使用してエラー情報を取得する
*}
compilation.GetSymbolsWithNameでクラス定義等が取得可能
キャストしないとISymbolで取得されるため、情報が非常に限定される
*foreach(var clsSymbol in compilation.GetSymbolsWithName(_ =>; true, SymbolFilter.Type).OfType<;ITypeSymbol>;())
メンバーの取得
(メソッドやインナークラス等も入るため、ISymbol.Kindで場合分けを行う事)
*foreach(var memberSymbol in clsSymbol.GetMembers())

*var url = "http:
localhost:xxxxxapivalues"

iOSでデータをiCloudにバックアップさせない設定
*UnityEngine.iOS.Device.SetNoBackupFlag(path);

コンパイル時にintとしてコンパイルされる
*var num = 1;
stringとしてコンパイルされる
*var str = "Hello,World";
numはintとしてコンパイルされるのでコンパイルエラー
*num = "1";
使用する側
*var collect = new UserCollection(users);
Countプロパティにアクセス
*var count = collect.Count;
Indexerにインデックスを指定することによってアクセス
*var user = collect[1];
※CountプロパティにはSetアクセサーが実装されていないため、コンパイルエラーになる
*collect.count = 10;
ここで例外がスローされても、conは確実にDisposeが呼ばれる
*}

*XXXXX xx = new XXXXX();
呼び出したいdllの呼び出し情報

*return 0;
最初のステップにもどる

結果
*key=FONT, no=12

*var resources = new List<;ResourceDictionary>; { Application.Current.Resources };
現在のアプリケーションのResourceDictionaryと入れ子になっているResourceDictionaryを平坦化
ResourceからValueを取り出しDataTemplate型だけ抽出して平坦化
*.SelectMany(x =>; x.Values.OfType<;DataTemplate>;())
DataTemplateを匿名型に変換
*.Select(x =>;
Contentを生成してView型情報に変換
*viewType = x.LoadContent().GetType(),
DataTypeをViewModel型情報に変換
*viewModelType = x.DataType as Type
一致するView型を探し、対応するViewModel型を選択
*var selectViewModelType = dataTemplateExs
該当するViewModel型を作成
*var vm = Activator.CreateInstance(selectViewModelType);

*AdditiveTransparent,
加算半透明
materialEditor.EnableInstancingField();    GPU Instancing未対応
*}
MaterialのShader切り替え時にBlend指定が変更されてしまうので再設定
*this.SetupBlendMode(material, (BlendMode)material.GetFloat("_BlendMode"));

*app.UseSwaggerUi();
追加
*[HttpGet("{id}")]
GET api/values/5

notepadのプロセスを取得
*System.Diagnostics.Process[] ps =
プロセスを強制的に終了させる
*p.Kill();

*{private static readonly string BasePath = Application.persistentDataPath + "/DAO/";private const string Extention = ".json";// 存在確認public static bool Exists( string fileName ){return ExistsFile( fileName );}// カスタムクラスを読み込みpublic static T Read<;T>;( string fileName ){string text = ReadFile( fileName );if( string.IsNullOrEmpty( text ) )return default(T);return JsonUtility.FromJson<;T>;( text );}// カスタムクラスを保存public static void Save( object data, string fileName ){string text = JsonUtility.ToJson( data );OverWriteFile( fileName, text );}// 削除public static void Delete( string fileName ){DeleteFile( fileName );}// パスの取得private static string MakeFilePath( string fileName ){return BasePath + "/" + fileName + Extention;}// ファイルの存在確認private static bool ExistsFile( string fileName ){string path = MakeFilePath( fileName );return File.Exists( path );}// ファイルの読み込みprivate static string ReadFile( string fileName ){string path = MakeFilePath( fileName );if( !ExistsFile( fileName ) )return null;return File.ReadAllText( path );}// ファイルの上書きprivate static void OverWriteFile( string fileName, string text ){if( !Directory.Exists( BasePath ) )Directory.CreateDirectory( BasePath );string path = MakeFilePath( fileName );DeleteFile( fileName );File.WriteAllText( path, text );}// ファイルの削除private static void DeleteFile( string fileName ){string path = MakeFilePath( fileName );if( Exists( fileName ) )File.Delete( path );}}
クライアントのデータ保存・読み込み・削除・存在確認
*{return ExistsFile( fileName );}
存在確認
*{string text = ReadFile( fileName );if( string.IsNullOrEmpty( text ) )return default(T);return JsonUtility.FromJson<;T>;( text );}
カスタムクラスを読み込み
*{string text = JsonUtility.ToJson( data );OverWriteFile( fileName, text );}
カスタムクラスを保存
*{DeleteFile( fileName );}
削除
*{return BasePath + "/" + fileName + Extention;}
パスの取得
*{string path = MakeFilePath( fileName );return File.Exists( path );}
ファイルの存在確認
*{string path = MakeFilePath( fileName );if( !ExistsFile( fileName ) )return null;return File.ReadAllText( path );}
ファイルの読み込み
*{if( !Directory.Exists( BasePath ) )Directory.CreateDirectory( BasePath );string path = MakeFilePath( fileName );DeleteFile( fileName );File.WriteAllText( path, text );}
ファイルの上書き
*{string path = MakeFilePath( fileName );if( Exists( fileName ) )File.Delete( path );}
ファイルの削除
*{// データ保存用クラス[Serializable]private class TestData{public string testString;public int    testInt;public override string ToString(){return   "Test Data :: "+ "Test String : " + testString + ", "+ "Test Int : " + testInt;}}private void Start(){var testData = new TestData();{testData.testString = "string";testData.testInt = 15;}// 保存DataAccessObject.Save( testData, "fileName" );// 読み込みDebug.Log( DataAccessObject.Read<;TestData>;( "fileName" ).ToString() );// 存在確認Debug.Log( DataAccessObject.Exists( "fileName" ) );// 削除DataAccessObject.Delete( "fileName" );Debug.Log( DataAccessObject.Exists( "fileName" ) );}}
使用例
データ保存用クラス
*[Serializable]
保存
*DataAccessObject.Save( testData, "fileName" );
読み込み
*Debug.Log( DataAccessObject.Read<;TestData>;( "fileName" ).ToString() );
存在確認
*Debug.Log( DataAccessObject.Exists( "fileName" ) );
削除
*DataAccessObject.Delete( "fileName" );
*{private static readonly string BasePath = Application.persistentDataPath + "/DAO/";private const string Extention = ".json";public static T Read<;T>;( string fileName ){string text = ReadFile( fileName );if( string.IsNullOrEmpty( text ) )return default(T);return JsonUtility.FromJson<;T>;( text );}private static string MakeFilePath( string fileName ){return BasePath + "/" + fileName + Extention;}private static bool ExistsFile( string fileName ){string path = MakeFilePath( fileName );return File.Exists( path );}private static string ReadFile( string fileName ){string path = MakeFilePath( fileName );if( !ExistsFile( fileName ) )return null;return File.ReadAllText( path );}}
クライアントのデータ読み込み
*{T Read();}
インターフェイス：読み込み
*{private readonly string basePath;private readonly string fileName;private DaoFactory( string fileName ){this.basePath = Application.persistentDataPath + "/DAO/";this.fileName = fileName;}public static IRead<;T>; CreateReader<;T>;( string fileName ){return new DaoFactory( fileName ).CreateReader<;T>;();}private IRead<;T>; CreateReader<;T>;( string fileName ){var textReader = new TextReader( basePath, fileName );return new DeserializeReader<;T>;( textReader );}}
IReadの作成
*{private readonly string basePath;private readonly string fileName;public TextReader( string basePath, string fileName ){this.basePath = basePath;this.fileName = fileName;}public string Read(){string path = basePath + fileName;if( !Directory.Exists( basePath ) || !File.Exists( path ) )return null;return File.ReadAllText( path );}}
テキストの読み込み
*{private readonly IRead<;string>; stringReader;public DeserializeReader( IRead<;string>; stringReader ){this.stringReader = stringReader;}public T Read(){string text = stringReader.Read();if( string.IsNullOrEmpty( text ) )return default(T);return JsonUtility.FromJson<;T>;( text );}}
Jsonを指定されたクラスとして読み込み
*{// データ保存用クラス[Serializable]private class TestData{public string testString;public int    testInt;public override string ToString(){return   "Test Data :: "+ "Test String : " + testString + ", "+ "Test Int : " + testInt;}}private void Start(){// Data Access Objectの取得var testDataDAO = DaoFactory.Create<;TestData>;( "fileName" );var testData = new TestData();{testData.testString = "test";testData.testInt = 99;}// 保存testDataDAO.Save( testData );// 読み込みDebug.Log( testDataDAO.Read().ToString() );// 存在確認Debug.Log( testDataDAO.Exists() );// 削除testDataDAO.Delete();Debug.Log( testDataDAO.Exists() );}}
使用例
データ保存用クラス
*[Serializable]
Data Access Objectの取得
*var testDataDAO = DaoFactory.Create<;TestData>;( "fileName" );
保存
*testDataDAO.Save( testData );
読み込み
*Debug.Log( testDataDAO.Read().ToString() );
存在確認
*Debug.Log( testDataDAO.Exists() );
削除
*testDataDAO.Delete();
簡単なモック
*using UniDAO;
*{public class DataAccessObject{public static T Read<;T>;( string fileName ){// 読み込まれたテキストは暗号化されている想定string encryptedText = ReadFile( fileName );// 何らかの方法で復号化string text = Decrypt( encryptedText );// ログを出力Debug.Log( text );if( string.IsNullOrEmpty( text ) )return default(T);return JsonUtility.FromJson<;T>;( text );}}}
そのまま関数を拡張したパターン
読み込まれたテキストは暗号化されている想定
*string encryptedText = ReadFile( fileName );
何らかの方法で復号化
*string text = Decrypt( encryptedText );
ログを出力
*Debug.Log( text );
*{// 復号化public class DecryptReader : IRead<;string>;{private readonly IRead<;string>; stringReader;public DecryptReader( IRead<;string>; stringReader ){this.stringReader = stringReader;}public string Read(){return Decrypt( stringReader.Read() );}}// ログ出力public class LogReader : IRead<;string>;{private readonly IRead<;string>; stringReader;public LogReader( IRead<;string>; stringReader ){this.stringReader = stringReader;}public string Read(){string str = stringReader.Read();Debug.Log( str );return str;}}public class DaoFactory{private IRead<;T>; CreateReader<;T>;( string fileName ){var textReader  = new TextReader( basePath, fileName );// 復号化機能をデコレーションvar decryptReader = new DecryptReader( textReader );// ログ出力機能をデコレーションvar logReader  = new LogReader( decryptReader );return new DeserializeReader<;T>;( logReader );}}}
デコレーターで拡張したパターン
*{private readonly IRead<;string>; stringReader;public DecryptReader( IRead<;string>; stringReader ){this.stringReader = stringReader;}public string Read(){return Decrypt( stringReader.Read() );}}
復号化
*{private readonly IRead<;string>; stringReader;public LogReader( IRead<;string>; stringReader ){this.stringReader = stringReader;}public string Read(){string str = stringReader.Read();Debug.Log( str );return str;}}
ログ出力
復号化機能をデコレーション
*var decryptReader = new DecryptReader( textReader );
ログ出力機能をデコレーション
*var logReader  = new LogReader( decryptReader );
*{private readonly IRead<;string>; stringReader;public DeserializeReader( IRead<;string>; stringReader ){this.stringReader = stringReader;}public T Read(){string text = stringReader.Read();if( string.IsNullOrEmpty( text ) )return default(T);return JsonUtility.FromJson<;T>;( text );}}
Jsonを指定されたクラスとして読み込み
*{private IRead<;T>; CreateReader<;T>;( string fileName ){// 自力で依存関係を解決var textReader        = new TextReader( basePath, fileName );var decryptReader     = new DecryptReader( textReader );var logReader         = new LogReader( decryptReader );var deserializeReader = new DeserializeReader<;T>;( logReader );return deserializeReader;}}
IReadの作成
自力で依存関係を解決
*var textReader        = new TextReader( basePath, fileName );
*{private readonly IRead<;string>; stringReader;private readonly IDeserialize<;string>; deserializer;public DeserializeReader( IRead<;string>; stringReader, IDeserialize<;string>; deserializer ){this.stringReader = stringReader;this.deserializer = deserializer;}public T Read(){string text = stringReader.Read();if( string.IsNullOrEmpty( text ) )return default(T);// IDeserializeにデシリアライズ処理を委譲return deserializer.Deserialize<;T>;( text );}}
JsonUtilityへの依存をなくしたDeserializeReader
IDeserializeにデシリアライズ処理を委譲
*return deserializer.Deserialize<;T>;( text );
*{T Read();}
インターフェイス：読み込み
*{bool Exists();T Read();void Save( T data );void Delete();}
インターフェイス：存在確認・読み込み・保存・削除
*{private readonly string basePath;private readonly string fileName;private string Path{get{return basePath + fileName;}}public TextDao( string basePath, string fileName ){this.basePath = basePath;this.fileName = fileName;}public bool Exists(){return File.Exists( Path );}public string Read(){if( !Exists() )return null;return File.ReadAllText( Path );}public void Save( string text ){if( !Directory.Exists( basePath ) )Directory.CreateDirectory( basePath );Delete();File.WriteAllText( Path, text );}public void Delete(){if( Exists() )File.Delete( Path );}}
テキストの存在確認・読み込み・保存・削除
シリアライズしたテキストを保存
テキストをデシリアライズして読み込み
テキストの存在確認・削除 ← 委譲しているだけ！
*public class SerializeDao<;T>; : IDataAccessObject<;T>;
委譲しているだけ
*return stringDao.Exists();
委譲しているだけ
*stringDao.Delete();

作業用変数の宣言
var wordbreakIndex = 0;           現在の単語の始まりのインデックス
var currentWordLength = 0;        現在の単語の文字数
var current = '\0';               ループの中で現在参照している文字
var isLowerBefore = false;        一つ前の文字が小文字だったかどうか
var isUpperCurrent = false;       現在の文字が大文字かどうか
*for(var i = 0; i <; source.Length; i++)
小文字から大文字に切り替わった時に単語を切り出す。
*yield return source.Substring(wordbreakIndex, currentWordLength);
最後の単語の返却漏れがないように
*yield return source.Substring(wordbreakIndex, source.Length - wordbreakIndex);

*int size = 1;
デバイス数 ÷ 16

*return default(T);
コンパイルが通ってしまう

*if (e.ColumnIndex <; 0 &amp;&amp; e.RowIndex >;= 0)*{
列ヘッダーかどうか調べる
セルを描画する
*e.Paint(e.ClipBounds, DataGridViewPaintParts.All);
行番号を描画する範囲を決定する
e.AdvancedBorderStyleやe.CellStyle.Paddingは無視しています
*Rectangle indexRect = e.CellBounds;
行番号を描画する
*TextRenderer.DrawText(e.Graphics,
描画が完了したことを知らせる
*e.Handled = true;

*#if UNITY_EDITOR*Input.gyro.enabled = false;
ジャイロを有効にする
*#if UNITY_EDITOR*#elif UNITY_ANDROID
androidとiosで座標系が違うのでデバイスごとに設定
*rightCam.transform.localPosition = new Vector3(-parallax, 0, 0)/2;*leftCam.transform.localPosition = new Vector3(parallax, 0, 0)/2;
視差の変更があったら反映する

*var e = new Vector(1, 0);
単位ベクトル

文字列型の変数「str」宣言
*string str = "Hello, C#";
ローカルスコープ内で定義した定数はconstを指定
*const string str = "Hello, C#";
辞書データを実装するためにはDictionaryクラスが必要
*using System.Collections.Generic;
引数名を指定しての設定と指定なしの両方が可能
*func.Func(num: 1);

*{x = 114514;}
仮想関数
純粋仮想関数
*protected abstract void Hoge();

TextBoxの追加
*TextBox newTextBox = new TextBox();
TextBoxの表示位置
*InkCanvas.SetTop(newTextBox, 5);
フォーカスの設定
*FocusManager.SetFocusedElement(FocusManager.GetFocusScope(newTextBox), newTextBox);
IMEの変更
*InputMethod.Current.ImeState = InputMethodState.On;

*//q1{1,1,1}{1,1,2}{1,1,3}{1,2,1}…{3,3,3}
結合条件なしで重複ありの全組み合わせを展開
*//q1{1,1,1}{1,1,2}{1,1,3}{1,2,1}…{3,3,3}
展開結果は配列にする
*// q1={1,3,1}の場合、要素の個数は3、値の種類数は2(1と3しかないから)→×：除外
各要素の重複なしのレコードのみ抽出して返す
*// q1={1,3,1}の場合、要素の個数は3、値の種類数は2(1と3しかないから)→×：除外
要素の個数と、各要素の値の種類数が一致していれば重複無しと判断
*// q1={1,3,2}の場合、要素の個数は3、値の種類数は3→○：抽出
q1={1,3,1}の場合、要素の個数は3、値の種類数は2(1と3しかないから)→×：除外
*// q1={1,1,1}の場合、要素の個数は3、値の種類数は1(1しかないから)→×：除外
q1={1,3,2}の場合、要素の個数は3、値の種類数は3→○：抽出
q1={1,1,1}の場合、要素の個数は3、値の種類数は1(1しかないから)→×：除外
*var q2 = q1.Where(ar =>; ar.Length == ar.Distinct().Count());
*//q1{1,1,1}{1,1,2}{1,1,3}{1,2,1}…{3,3,3}
結合条件なしで重複ありの全組み合わせを展開
*// q1={1,3,1}の場合、要素の個数は3、値の種類数は2(1と3しかないから)→×：除外
各要素の重複なしのレコードのみ抽出して返す
*// q1={1,3,1}の場合、要素の個数は3、値の種類数は2(1と3しかないから)→×：除外
要素の個数と、各要素の値の種類数が一致していれば重複無しと判断
*// q1={1,3,2}の場合、要素の個数は3、値の種類数は3→○：抽出
q1={1,3,1}の場合、要素の個数は3、値の種類数は2(1と3しかないから)→×：除外
*// q1={1,1,1}の場合、要素の個数は3、値の種類数は1(1)→×：除外
q1={1,3,2}の場合、要素の個数は3、値の種類数は3→○：抽出
*{var ar = new int[] { v.N1, v.N2, v.N3 };return ar.Length == ar.Distinct().Count();}
q1={1,1,1}の場合、要素の個数は3、値の種類数は1(1)→×：除外

*.UseUrls("http:
192.168.xx.xx:8080")

*public UnityTerrain terrain = null;
GameObjectにアタッチされたTerrainコンポーネントを保持
独自の名前空間にTerrainを使っていて名称の混乱が起きているので、using UnityTerrain = UnityEngine.Terrainしています。
*UnityTerrain left_terrain = null;
今のところテクスチャ一枚をすべてのTerrainの全面に貼る機能しかありません。
*SplatPrototype[] splatprototype = new SplatPrototype[1];
ワールド座標をチャンクサイズで割って小数部だけ取り出せば、Terrain内の欲しい位置が割り出せる算段
*TerrainData tData = terrain.terrainData;
TerrainService初期化
ConfigData.instantiate_texture2Dは後述
*public static void reset(GameObject game_object, TerrainConfig terrain_config, WorldConfig world_config)
プレイヤー移動時のTerrainアップデートを行います。
生成済みのTerrainは有効/無効の切り替えのみ。
未生成のTerrainは新しく生成します。
*public static IEnumerator update(int player_x, int player_z)
Terrain初期化時のみ使用します。
TerrainConfigで指定した範囲のTerrainを順次生成します。
*public static void createUnityTerrains()
Terrain初期化時のみ使用します。
createUnityTerrainsで作ったTerrain達に対して追加の調整を実施していきます。
*public static void setupTerrainCollection()
*{int xs = x * chunk_size;int zs = z * chunk_size;float[,] heights = createHeightMap(xs, zs, terrain_seed, perlin_noise_scale);terrain_collection[x, z] = TerrainEntityFactory.create(x, z, heights, terrain_config, terrain_parent);terrain_collection[x, z].disable();}
Terrain生成
*{terrain_collection[x, z].setNeighbors(terrain_collection[x - 1, z],terrain_collection[x, z + 1],terrain_collection[x + 1, z],terrain_collection[x, z - 1]);terrain_collection[x, z].setTexture(texture, chunk_size);TerrainEntityRepository.set(terrain_collection[x, z]);terrain_collection[x, z].enable();}
createTerrainで生成したTerrainに対して、追加で調整を行います。
Terrain1つ分のハイトマップ生成
ここが壊れていると針の山が出来たり地形に切れ目が出来ます
Mathf.PerlinNoiseに渡す引数を作っているRand.calucurate_perlin_valueについては後述
*private static float[,] createHeightMap(int xs, int zs, float terrain_seed, float perlin_noise_scale)
ワールド座標を受け取って、その位置の地形高さを返します。
Terrain生成後にプレイヤーキャラクターを初期化しているので、地形に埋まらないようにこれで高さを取得しています。
*public static float getHeight(float x, float z)

*{algo.BlockSize = 128;algo.KeySize = 128;algo.GenerateKey();using (ICryptoTransform encryptor = algo.CreateEncryptor() , decryptor = algo.CreateDecryptor()){byte[] plainEnc = encryptor.TransformFinalBlock(plainByte, 0, plainByte.Length);byte[] plainDec = decryptor.TransformFinalBlock(plainEnc, 0, plainEnc.Length);Console.WriteLine(System.Text.Encoding.ASCII.GetString(plainDec));Console.WriteLine();}}
Speck ECB mode
*{algo.BlockSize = 128;algo.KeySize = 128;algo.GenerateIV();algo.GenerateKey();using (ICryptoTransform encryptor = algo.CreateEncryptor() , decryptor = algo.CreateDecryptor()){byte[] plainEnc = encryptor.TransformFinalBlock(plainByte, 0, plainByte.Length);byte[] plainDec = decryptor.TransformFinalBlock(plainEnc, 0, plainEnc.Length);Console.WriteLine(System.Text.Encoding.ASCII.GetString(plainDec));Console.WriteLine();}}
Speck CTR mode

*{using (var s3Client = new AmazonS3Client()){var response = await s3Client.GetObjectAsync("bucket-name", key, cancellationToken);using (var reader = new StreamReader(response.ResponseStream)){concurrentBag.Add(reader.ReadToEnd());}}},
ITargetBlock&lt;T&gt; を継承する ActionBlock で key を受け取ってファイルの中身を読み取る
*{CancellationToken = cancellationToken,MaxDegreeOfParallelism = Environment.ProcessorCount});
Select で Task にくるんで WaitAll と異なりこの辺の制御ができる。
actionBlock に key を渡して投げる
*await actionBlock.SendAsync(key, cancellationToken);
actionBlock にもう依頼は無い事を通知する。
*actionBlock.Complete();
actionBlock を await して全部終わるのを待つ。
*await actionBlock.Completion;

プロセス名(string)
p.ProcessName
*if (p.MainWindowTitle != "")
タイトル名(string)
*lists += p.MainWindowTitle + "\n";

*{AnimalTypeTable.TryGetValue(code, out AnimalTypeProperties prop);return prop;}
拡張メソッド

*if (choices.Count() != choices.Distinct().Count()) { throw new Exception("has duplicate value"); }*//選択結果は空からスタート
重複あり
*var choosed = new T[] { };
選択結果は空からスタート
展開開始
*var query = Expand(choices, choosed);
*if (!choices.Any()) { yield return choosed.ToArray(); }*foreach (var choice in choices)
選択肢がなくなったら終了
*var newChoosed = choosed.Concat(new T[] { choice });
選択肢から1つ選んで、選択済要素に入れる
選択肢から削除
*var newChoices = choices.Where(v =>; !choice.Equals(v));
新たな選択肢と選択済要素で再帰
*var query = Expand(newChoices, newChoosed);
配列を順次返す
*yield return qq.ToArray();

*transform.Find("Panel
Text").GetComponent&lt;Text&gt;().text = notificationText(streamEvent);  GameObjectの親子関係は適宜直してください
フキダシ(先述)
...
ユニティちゃん
*unitychan.GetComponent<;NotificationUnitychan>;().Response(CheckUnitychanResponse(streamEvent));
*{List<;string>; eventNameForUnitychanJump = new List<;string>;() { "favorite", "follow" };List<;string>; eventNameForUnitychanSad = new List<;string>;() { "unfavorite" };if (eventNameForUnitychanJump.IndexOf(streamEvent.event_name) != -1){return "Jump";}else if (eventNameForUnitychanSad.IndexOf(streamEvent.event_name) != -1){return "Sad";}else{return null;}}
streamEventに応じて"Jump"か"Sad"のどちらかを返す

*if( ガード条件 == 真 ){
ガード条件が真ならば、
略
*,,,
*{_サンプル状態 = state.name;状態1のentryアクション}
状態1状態のentry/do/exit
*{_サンプル状態 = state.name;状態2のentryアクション}
状態2状態のentry/do/exit
*{_状態マシン1 = state.name;notifyStarted();}
状態a状態のentry/do/exit

5秒間スリープするだけ。
*System.Threading.Thread.Sleep( 5000 );
1．Task.Delayはasyncで定義されている。なので、await識別子を指定する事が可能。
awaitすることで、一旦UIスレッドに処理を返す事が出来る。
= &gt; 重たい処理が実行中でも、UI操作が可能。フリーズしない。
処理が終了すると、処理スレッドに戻る。
*await Task.Delay( 5000 );
2．Thread.Sleep処理はasyncで定義されていないので、await識別子を指定することが出来ない。
= &gt; 「HeavyProcAsync」メソッドにasyncの定義があるが、UI操作が不可能。
System.Threading.Thread.Sleep( 5000 );
3. 2の処理に対して、非同期処理を行いたい場合は、
Task処理として動作させれば良い。
await Task.Factory.StartNew( () =&gt;
{
System.Threading.Thread.Sleep( 5000 );
}
);
*}

*var url = "https:
qiita.comapiv2items";

*if ( readSize1 != readSize2 ) { return DiffType.Unknown; }
unexpected.
*if ( readSize1 == 0 ) { return DiffType.Same; }*}
ファイルをすべて読み込んだときは終了する

値の変更時に古い値を Dispose する
*var d = this.RxProp.Zip(this.RxProp.Skip(1), (old, _) =>; old)
これは別件
*d.AddTo(this.Disposer);

*int ret2 = num?.Let((int nonNullNum) =<; nonNullNum * 2) ?? -1;
-&gt; -1

*GlobalConfiguration.Configure({{クラス名}}.Controllers.WebApiConfig.Register);
以下を追加

数式を逆ポーランド記法へ変換
*ReversePolishNotation rpn = ConvertToRpn(exp);
逆ポーランド記法の式を計算する
*return RpnCalculator.Calculate(rpn);
*private static ReversePolishNotation ConvertToRpn(string exp) {var context = new Context(exp);var node = new ExpressionNode();node.Parse(context);if (!context.IsTerminate)throw new ArithmeticException("正しい式ではありません");return context.Notation;}
数式を逆ポーランド記法へ変換
数式を逆ポーランド記法へ変換
*ReversePolishNotation rpn = ConvertToRpn(exp);
逆ポーランド記法の式を計算する
*return RpnCalculator.Calculate(rpn);
*private static ReversePolishNotation ConvertToRpn(string exp) {var context = new Context(exp);var node = new ExpressionNode();node.Parse(context);if (!context.IsTerminate)throw new ArithmeticException("正しい式ではありません");return context.Notation;}
数式を逆ポーランド記法へ変換
*public class RpnCalculator {static Dictionary<;string, Func<;decimal, decimal, decimal>;>; binaryOperators =new Dictionary<;string, Func<;decimal, decimal, decimal>;>;() {["+"] = (a, b) =>; a + b,["-"] = (a, b) =>; a - b,["*"] = (a, b) =>; a * b,["/"] = (a, b) =>; a / b,};// 後置記法を計算するpublic static decimal Calculate(ReversePolishNotation rpn) {Stack<;object>; stack = new Stack<;object>;();foreach (var token in rpn.Tokens) {if (binaryOperators.ContainsKey(token)) {var b = (decimal)stack.Pop();var a = (decimal)stack.Pop();var c = binaryOperators[token](a, b);stack.Push(c);} else {stack.Push(decimal.Parse(token));}}return (decimal)stack.Pop();}}
shiracamusさんのコードを採用
*public class RpnCalculator {static Dictionary<;string, Func<;decimal, decimal, decimal>;>; binaryOperators =new Dictionary<;string, Func<;decimal, decimal, decimal>;>;() {["+"] = (a, b) =>; a + b,["-"] = (a, b) =>; a - b,["*"] = (a, b) =>; a * b,["/"] = (a, b) =>; a / b,};// 後置記法を計算するpublic static decimal Calculate(ReversePolishNotation rpn) {Stack<;object>; stack = new Stack<;object>;();foreach (var token in rpn.Tokens) {if (binaryOperators.ContainsKey(token)) {var b = (decimal)stack.Pop();var a = (decimal)stack.Pop();var c = binaryOperators[token](a, b);stack.Push(c);} else {stack.Push(decimal.Parse(token));}}return (decimal)stack.Pop();}}
https:qiita.com/gushwell/items/a40f4119a35a1e6d7622 のコメント
*public static decimal Calculate(ReversePolishNotation rpn) {Stack<;object>; stack = new Stack<;object>;();foreach (var token in rpn.Tokens) {if (binaryOperators.ContainsKey(token)) {var b = (decimal)stack.Pop();var a = (decimal)stack.Pop();var c = binaryOperators[token](a, b);stack.Push(c);} else {stack.Push(decimal.Parse(token));}}return (decimal)stack.Pop();}
後置記法を計算する
*public class Tokenizer {private string _expression;IEnumerator<;string>; _ite;public Tokenizer(string exp) {_expression = exp;_ite = GetTokens().GetEnumerator();}public bool MoveNext() {return _ite.MoveNext();}public string Current {get { return _ite.Current; }}private IEnumerable<;string>; GetTokens() {char c = NextChar();var token = "";while (c != (char)0) {if (char.IsDigit(c)) {token += c;} else if (c == '.' &amp;&amp; token.All(x =>; x != '.')) {token += c;} else {if (token != "")yield return token;token = "";if (IsSymbol(c))yield return c.ToString();else if (c != ' ')throw new ArithmeticException("正しい式ではありません");}c = NextChar();}if (token != "")yield return token;}private static bool IsSymbol(char c) {if (c == '+' || c == '-' || c == '*' || c == '/' ||c == '(' || c == ')')return true;return false;}private int _currentIndex = 0;private char NextChar() {if (_currentIndex <; _expression.Length)return _expression[_currentIndex++];return (char)0;}}
Tokenに分解する

*string animalName = animalType.GetTypeName();
イヌ

*{var vm = this.DataContext as ViewModel;if (null == vm) { return; }// ツリー表示となるデータを追加するvm.Add(new Person(vm._dumpData, vm.Data) { Name = "天財女王", Age = 57, VisibleGroup = Visibility.Visible });}
行追加ボタン押下処理
*vm.Add(new Person(vm._dumpData, vm.Data) { Name = "天財女王", Age = 57, VisibleGroup = Visibility.Visible });
ツリー表示となるデータを追加する
*{private ObservableCollection<;Person>; _Child;private ObservableCollection<;Person>; _Parent;// 名前public string Name { get; set; }// 年齢private int _Age;public int Age{get =>; _Age;set{if (value <; 0){MessageBox.Show("範囲外の値が設定されました。");OnPropertyChanged("Age");}else{SetProperty(ref _Age, value);}}}// 階層を展開するためのボタンの表示状態public Visibility VisibleGroup { get; set; } = Visibility.Collapsed;// 子階層を表示しているか否かprivate bool _IsOpen = false;public bool IsOpen{get =>; _IsOpen;set{_IsOpen = value;if (null != _Child){// 子階層があれば、表示／非表示に応じて、データを挿入／削除するif (_IsOpen){int index = _Parent.IndexOf(this) + 1;foreach (Person item in _Child){_Parent.Insert(index, item);}}else{int index = _Parent.IndexOf(this) + 1;foreach (Person item in _Child){_Parent.RemoveAt(index);}}}}}public Person() { }// 子階層と親階層を設定するpublic Person(ObservableCollection<;Person>; child, ObservableCollection<;Person>; parent){_Child = child;_Parent = parent;}}
DataGridに表示するデータ
*public string Name { get; set; }
名前
年齢
*private int _Age;
*public Visibility VisibleGroup { get; set; } = Visibility.Collapsed;
階層を展開するためのボタンの表示状態
子階層を表示しているか否か
*private bool _IsOpen = false;
*if (_IsOpen)*{
子階層があれば、表示／非表示に応じて、データを挿入／削除する
*{_Child = child;_Parent = parent;}
子階層と親階層を設定する
*{new Person{Name="　天財息子", Age=29},new Person{Name="　天財娘", Age=27}};
子階層用のデータ
*{new Person{Name="天財太郎", Age=19},new Person{Name="天財次郎", Age=17}};
初期データ

*user.UserName = "urashimataro";
Change UserName column

*var startTime = new DateTime(2021, 2, 1);
ドキュメントによると現在の時刻より60日以上前にすることはできないようです。

*m.UploadStringFunc = () =<; throw new Exception("なんかエラー");
接続エラーをシミュレート
モックオブジェクトを HogeServiceClient のコンストラクタに渡す
*HogeServiceClient3 h = new HogeServiceClient3(m);

*[AllFilter("Controller2", Order = 0)]
Orderの順序検証用
ExceptionFilter確認用
*throw new Exception();
～ Filter実装部省略 ～
*}

*public void print3(){
ただの上書き定義

*var settings = new ConnectionSettings(new Uri("http:
&lt;host&gt;:&lt;port&gt;"))
単一ホストのクラスタの場合
*var health = client.CatHealth().Records.SingleOrDefault();
複数ホストのクラスタの場合
*var health = client.CatHealth().Records;

*var url = $"https:
process.filestackapi.com{filestackApiKey}output=format:jpghttps:chart.apis.google.comchart?cht=tx&amp;chl={texText}";
*client.DefaultRequestHeaders.Add("Authorization", $"Bearer {{{lineChannelAccessToken}}}");
認証情報
LINE側へメッセージ送信依頼
var res = await client.PostAsJsonAsync("https:api.line.me/v2/bot/message/reply",
送信データを作成
*new ReplyMessageObject()

*Console.WriteLine(Object.ReferenceEquals("hogefuga","hogefuga"));
(A-5) True

*modelBuilder.Entity<;Item>;().HasKey(c =>; new { c.Id, c.PointNo });
複合キーの場合、以下のように指定してやる。
*modelBuilder.Entity<;Item>;().HasKey(c =>; new { c.Id, c.PointNo });
ない場合「Entity type 'Item' has composite primary key defined with data annotations. To set composite primary key, use fluent API.」と表示される
*{ Id = int.Parse(this.idText.Text),ItemName = this.itemNameText.Text,PointNo = int.Parse(this.pointIdText.Text),SortNum = int.Parse(this.sortNumText.Text)};
本当はMVVMにのっとってやるべきだけど、今回は動確ということでサボり
コミット
*db.SaveChanges();

*list.Sort(comparer);
comparer を使い回す

*{case "a":direction = -1;break;case "d":direction = 1;break;case "w":direction = stageWidth * (-1);break;case "s":direction = stageWidth;break;default:Console.Write("ゲームを終了します");Environment.Exit(0);return 0;}
入力したキーに応じてプレイヤーの移動先を決定します。

*if (e.ColumnIndex <; 0 &amp;&amp; e.RowIndex >;= 0)*{
列ヘッダーかどうか調べる
セルを描画する
*e.Paint(e.ClipBounds, DataGridViewPaintParts.All);
行番号を描画する範囲を決定する
e.AdvancedBorderStyleやe.CellStyle.Paddingは無視しています
*Rectangle indexRect = e.CellBounds;
行番号を描画する
*TextRenderer.DrawText(e.Graphics,
描画が完了したことを知らせる
*e.Handled = true;

*power = this.Statuses[0].ModifyPower(power);
状態異常の0番目が攻撃力アップだとして

設定記述子
*this.options = options;
データベースとの接続処理等を記述する。
*}

*Application.Quit();
ゲーム終了
やばい
*cache_obj = instantiated_obj ?? GameObject.Instantiate(orig_obj);
*if (instantiated_obj != null) {*cache_obj = instantiated_obj;
冗長だがOK
YUVテクスチャのため注意
*decode_buf = new byte[size];
GCHandleでbyte配列のポインタを取得
*decode_hn = GCHandle.Alloc(decode_buf, GCHandleType.Pinned);

取得したレコードをListで保持します。
取得したデータはすべてstring型とする。
*List<;Dictionary<;string, string>;>; stationRecords = new List<;Dictionary<;string, string>;>;();
*{sqliteConn.Open();using ( SQLiteCommand command = sqliteConn.CreateCommand() ){// クエリ実行command.CommandText = "SELECT * from station";using ( SQLiteDataReader reader = command.ExecuteReader() ){// 一行一行読み込んでいくwhile ( reader.Read() ){// Listに追加Dictionary<;string, string>; record = new Dictionary<;string, string>;() {{ "stationName", reader["station_name"].ToString() },{ "longitude", reader["lon"].ToString() },{ "latitude",  reader["lat"].ToString()}};stationRecords.Add( record );}}}sqliteConn.Close();}
DBに接続して、クエリを実行する。
クエリ実行
*command.CommandText = "SELECT * from station";
*while ( reader.Read() )*{
一行一行読み込んでいく
*Dictionary<;string, string>; record = new Dictionary<;string, string>;() {{ "stationName", reader["station_name"].ToString() },{ "longitude", reader["lon"].ToString() },{ "latitude",  reader["lat"].ToString()}};
Listに追加
ルート部分のエレメントオブジェクト作成
*XElement rootElement = new XElement( "records" );
*foreach ( var record in stationRecords )*{
ルートに対して子のエレメントを追加していく
ルート部分のエレメントオブジェクト作成
*XElement rootElement = new XElement( "records" );
*foreach ( var record in stationRecords )*{
ルートに対して子のエレメントを追加していく
XMLストリームを取得
*string xmlStream = SQLiteIF.GetStations( ".dbファイルのフルパスを指定" );
XMLストリームからXElementオブジェクトを作成する場合は、
LoadではなくParseを使うこと。
*XElement stationsElement = XElement.Parse( xmlStream );
&lt;record&gt;要素のコレクションを取得
*IEnumerable<;XElement>; stations = stationsElement.Elements( "record" );
*foreach ( var stationElement in stations )*{
&lt;record&gt;に属している要素から、必要な情報を取得する

前景らしい領域を表す定数
*const int GC_PR_FGD = 3;
対象画像オブジェクト
*Mat image = new Mat("iphone8IMGL7576_TP_V4.jpg", ImreadModes.Color);
前景を含む領域
*Rect rectangle = new Rect(300, 20, 650, 500);
前景を抽出
*var result = new Mat(image.Size(), MatType.CV_8U);
GrabCutするイテレーションに5回を指定
*Cv2.GrabCut(image, result, rectangle, bgdModel, fgdModel, 5, GrabCutModes.InitWithRect);
*Mat foreground = new Mat(image.Size(), MatType.CV_8UC3, new Scalar(255, 255, 255));*image.CopyTo(foreground, result);
抽出した前景を貼り付ける画像、ソースと同サイズの真っ白な画像を指定
*Cv2.ImShow("タイトル", foreground);*Cv2.WaitKey();
表示

*{//対象アセットをロードvar obj = AssetDatabase.LoadAssetAtPath<;UnityEngine.Object>;(path);//存在すればPingif (obj)EditorGUIUtility.PingObject(obj);}
指定したパスのファイルにPingを飛ばす。パスは "Assets/..." で拡張子まで。
対象アセットをロード
*var obj = AssetDatabase.LoadAssetAtPath<;UnityEngine.Object>;(path);
*if (obj)*EditorGUIUtility.PingObject(obj);
存在すればPing
メソッド検索オプションを設定
*var flag = BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static;
UnityEditor.dllを取得
*var asm = Assembly.Load("UnityEditor");
ProjectBrowserクラスを取得
*var projectwindowtype = asm.GetType("UnityEditor.ProjectBrowser");
列挙体 ProjectBrowser.ViewMode を取得
*var viewmodetype = asm.GetType("UnityEditor.ProjectBrowser+ViewMode");
フォルダIDを取得するメソッドを取得
*var GetFolderInstanceIDs = projectwindowtype.GetMethod("GetFolderInstanceIDs", flag);
任意IDのフォルダを選択するメソッドを取得
*var SetFolderSelection = projectwindowtype.GetMethod("SetFolderSelection", flag);
ビューモードを設定するメソッドを取得
*var InitViewMode = projectwindowtype.GetMethod("InitViewMode", flag);
プロジェクトウィンドウを取得
*var projectwindow = EditorWindow.GetWindow(projectwindowtype, false, "Project", false);
プロジェクトウィンドウにフォーカス
*projectwindow.Focus();
*InitViewMode.Invoke(projectwindow, new[] { Enum.GetValues(viewmodetype).GetValue(1) });
プロジェクトウィンドウを２カラム表示に変更
*int[] folderids = (int[])GetFolderInstanceIDs.Invoke(null, new[] { paths });
渡されたパスのフォルダIDを取得
*SetFolderSelection.Invoke(projectwindow, new object[] { folderids, false });
取得したIDのフォルダを選択（第二引数はとりあえずfalse）

*{var data = DynamicJson.Parse(e.Message);if (!data.IsDefined("type")) return;string type = data["type"];if (!string.IsNullOrEmpty(type)){if (type == "goodbye"){Console.WriteLine("Slack goodbye.");isExit = true;}// メッセージ以外は弾くif (type != "message") return;if (data.IsDefined("subtype")) return;// 編集されたテキストは弾くif (data.IsDefined("edited")) return;var channel = data["channel"].ToString();var c = client.FindChannel(channel);if (c == null) return;// troomに投稿されたメッセージか確認if (c.name != "troom" &amp;&amp; channel != "troom") return;// 文字列に犬の鳴き声があるstring text = data["text"];var mc = Regex.Matches(text, @"(わん|ワン|wan|ﾜﾝ)", RegexOptions.Multiline);if (mc.Count <;= 0) return;// shibe.online から画像URLを取得var mes = WWW.GET("http://shibe.online/api/shibes?count=1&amp;urls=true&amp;httpsUrls=false");var res = DynamicJson.Parse(mes);// 同じ画像でも展開されるように、現在時刻をUnixTimeで入れるvar imageUrl = string.Format("{0}?{1}", res[0].ToString(), TimeUtil.GetUnixTime(DateTime.Now));// チャンネルに投稿await client.PostMessageAsync(channel, imageUrl, "shibainu", icon_emoji: ":shibainu:");}};
文字列受信
*if (type != "message") return;*if (data.IsDefined("subtype")) return;
メッセージ以外は弾く
*if (data.IsDefined("edited")) return;*var channel = data["channel"].ToString();
編集されたテキストは弾く
*if (c.name != "troom" &amp;&amp; channel != "troom") return;*// 文字列に犬の鳴き声がある
troomに投稿されたメッセージか確認
文字列に犬の鳴き声がある
*string text = data["text"];
shibe.online から画像URLを取得
var mes = WWW.GET("http:shibe.online/api/shibes?count=1&amp;urls=true&amp;httpsUrls=false");
*var res = DynamicJson.Parse(mes);
*var imageUrl = string.Format("{0}?{1}", res[0].ToString(), TimeUtil.GetUnixTime(DateTime.Now));
同じ画像でも展開されるように、現在時刻をUnixTimeで入れる
チャンネルに投稿
*await client.PostMessageAsync(channel, imageUrl, "shibainu", icon_emoji: ":shibainu:");
*{// 閉じられたConsole.WriteLine("Websocket close!");isExit = true;};
サーバーから切断された
閉じられた
*Console.WriteLine("Websocket close!");
サーバ接続開始
*ws.Open();
*while (true)*{
送受信ループ
サーバ接続開始
*ws.Open();
*while (true)*{
送受信ループ

外す場合
*options.Cookie.SameSite = Microsoft.AspNetCore.Http.SameSiteMode.None;

*var dealer_cards = new Cards(Console.ReadLine());
ディーラーのカード
*if (field.nextPercentage(dealer_cards.margin) <; 20 ){*Console.WriteLine("STAND") ;
ディーラーのバースト率が80%超えたら高みの見物

*private const int Bufsize = 4096;
?

設定記述子
*this.options = options;
データベースとの接続処理等を記述する。
*}

*#endif*}
GL.InvalidateState();

登録処理とか
*return Redirect("Welcome");

*"asdfghjkl1234567890qwertyuiop0987654321");
スプレッドシートのURLに記載のID
*static readonly byte[] ini = { 0x01, 0x01 };
初期化に必要なレポートデータ
*static readonly byte[] ini = { 0x01, 0x01 };
参考：https:www.codeproject.com/Tips/1007522/Temper-USB-Thermometer-in-Csharp
上記で準備完了なのだが、この時点で温度を取得すると75℃といった異常な値が取れる。
2回ほど読み捨ててごみを除去する。
*for (int i = 0; i <; 2; i++)
*{var report = WriteAndReadReport(bulk, 0x00, temp);int rawReading = (report.Data[3] &amp; 0xFF) + (report.Data[2] <;<; 8);const double calibrationOffset = -1.70;const double calibrationScale = 1;double temperatureCelsius = (calibrationScale * (rawReading * (125.0 / 32000.0))) + calibrationOffset;return temperatureCelsius;}
摂氏で今の温度を取得する

カメラ映像の縦横を取得しておく
*int screen_width = _liveCamera.OutputTexture.width;
キャリブレーション画像の領域をRGBAで初期化しておく。
*mat_calibration = new Mat(screen_height, screen_width, CvType.CV_8UC4);
openCV系のライブラリをUpdate()の中で使う場合にはusingを多用してリソースをちゃんとリリースさせたほうがよい。すぐ落ちるから。
カメラ画像もRGBAを想定して４チャンネル分を確保しておく。
*using (Mat mat_livecamera = new Mat(screen_height, screen_width, CvType.CV_8UC4))
カメラ画像はTextureで取れるので、それをMAT型に変換しOpenCVで画像処理しやすいようにする。
*Utils.textureToMat(_liveCamera.OutputTexture, mat_livecamera);
画像データ（数値データ）を反転させる(0-&gt;255へ。255-&gt;0へ)
*Core.flip(mat_bg_rgba, mat_bg_rgba, 0);
*if (Input.GetKeyUp(KeyCode.Space) || Input.touchCount >; 0)*{
スペースキーが押下されたら、いまカメラに写っている画像をキャリブレーション画像として置き換える。
BackgroundSubtractorMOG2メソッドを使って背景差分を導出する
*mog2.apply(mat_calibration, fgMaskMat);
場合によっては2値化させる前に画像をぼやかして、ちいさい差分を消す。（なかったことにする）
Imgproc.medianBlur(fgMaskMat, fgMaskMat, 10);
透過させる場所をはっきりさせるため、2値下する。
*Imgproc.threshold(fgMaskMat, fgMaskMat, 100, 255, Imgproc.THRESH_BINARY);
マスク画像をつかって画像を反転させる。
*Core.bitwise_not(fgMaskMat, bgMaskMat);
完成した画像をMAT型から元のTexture型に変換する。
*Utils.matToTexture(mat_livecamera, texture);

メソッドやプロパティの列挙も可能.
*}

*System.Windows.Forms.PowerLineStatus pls = SystemInformation.PowerStatus.PowerLineStatus;*switch (pls)
AC電源の状態
バッテリーの充電状態を取得する
*BatteryChargeStatus bcs =
*float blp = SystemInformation.PowerStatus.BatteryLifePercent;*System.Windows.MessageBox.Show("バッテリー残量は、"+ blp * 100+"%です。");
バッテリー残量（割合）
*int blr = SystemInformation.PowerStatus.BatteryLifeRemaining;*if (-1 ; blr)
バッテリー残量（時間）
AC電源がオンラインの時など
*System.Windows.MessageBox.Show("バッテリー残り時間は、不明です");
*int bfl = SystemInformation.PowerStatus.BatteryFullLifetime;*if (-1 ; bfl)
バッテリーがフル充電された時の持ち時間（バッテリー駆動時間）

*if ((privKeyBuf[index] &amp; 0x80) != 0 )*{
次のByteの最上位Bitが立っていれば、その下位7bitでコンテンツの長さの長さ(タイポじゃないよ)を表す。
*byte[] emptyBytes = {0, 0, 0, 0};
コンテンツの長さを取得する。
Intにしてるので4byte以上の場合はパースできない。
*throw new ArgumentException("PEM file is too large.");
*if (BitConverter.IsLittleEndian)*{
エンディアンによって処理が違う
Intにキャスト失敗した場合はパースできない。
*throw new ArgumentException("PEM file is too large.");
最上位Bitが立っていなければ、そのbyte自体がコンテンツの長さを表す。
*contentLength = privKeyBuf[index++];

*context.Notation.Add(token);
これを追加

*int result = await task;
-&gt; 1998

*Console.WriteLine("x = {0:d}, y = {1:d}\n", x, y);
x と y の値を交換
*{var u = x;x = y;y = u;}
x と y の値を交換するメソッド

Pinの発行
*session = OAuth.Authorize("APIKEY", "APISECRET");
トークンの発行
*string pincode = textBox.Text;
ツイート
*var text = "認証成功";

実際に使用できる
*List<;int>; list =  Enumerable.Range(0, 10).Where(i =>; i % 2 == 0).Select(i =>; i * 2).ToList();

Increment コマンドは、 Counter が 10 未満の間、使用可能
*Increment = Counter.Select(x =>; x <; 10).ToReactiveCommand();
Increment コマンドが実行されたら Counter を +1 してく
*Increment.Subscribe(x =>; Counter.Value = Counter.Value + 1);

*{int[] array = new int[]{0,1,2,3,4,5,6};for (int i = 0; i <; array.Length; i++){Console.WriteLine(array[i]);}}
ConsoleAppArrayFor.Program
*{int[] array = new int[]{0,1,2,3,4,5,6};int[] array2 = array;for (int i = 0; i <; array2.Length; i++){int num = array2[i];Console.WriteLine(num);}}
ConsoleAppArrayFor.Program
*{int[] numbers = new int[]{0,1,2,3,4,5,6};foreach (int i in numbers){Console.WriteLine(i);}}
Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250

音量を変更
*MMDevice device;

*if (this.stack.Any(x =>; x != ""))*{
Pop対象に[]を付ける
*if (this.queue.Any(x =>; x != ""))*{
EnQueue対象に[]を付ける

1回目ループ
*var max = doubleList.Max();
2回目ループ
*var min = doubleList.Min();
3回目ループ
*var average = doubleList.Average();
*foreach (double d in doubleList)*{
ここで1回すだけ
NaNチェックを避けるため1つ目の値をいれておく
*var max = doubleList.First();
*foreach (double d in doubleList)*{
ここで1回すだけ

*public class Association<;TKey1, TKey2, TValue<; where TValue : class
where T : class が Tは参照型のみの意味

*return *((short *) pbyte);
この行はリトルエンディアンでしか使用できない。

*public partial class MainWindow : NavigationWindow
この行を変更
下記2行を追加
*var secondPage = new SecondPage();

*g.AddEdge(new Edge("d8", "ee", "f", 0));
E -&gt; finish

*void Start () {//本来はUpdateに書いた方が良さそうな内容だが、プリントがやたら出るのでStartにてテスト//------------------------------//スイッチ文のサンプル//条件には、string型,float型などは使えない。//intとenumが使える。//int を直接数値で使う場合は状態のイメージがわかないので、//書いてみると、レベルやhpなど数値で分かるものを利用すべきだと思った。switch (State){case 1:print (State);//breakは無いと VSCode上でエラーが出る。役目はスイッチ文からの脱出//原語や環境によっては、break必須ではなさそう。break;//breakの下に命令を書いても意味がないし、これもVSCode上でエラーが出る。case 2:print (State);break;case 3:print (State);break;//default は書かなくても動く　elseと同じ役割default:print (State);break;}//------------------------------//上のスイッチ文と同じ結果になるif文if(State==0){print (State);}else if(State==1){print (State);}else if(State==3){print (State);}else{print (State);}//必ずしもif文が長くなる訳では無いことが・・・・分かるなぁ・・・//特に複雑な条件で分岐させるには　if文が強そう。//------------------------------//なるほど enum と相性が良さそう！//状態を分けるのはif文を利用して、その後の処理はSwitch文を利用するのが良さそう。switch (e_MyState){case MyState.Wait:print (e_MyState);break;case MyState.Run:print (e_MyState);break;case MyState.Sleep:print (e_MyState);break;default:print (e_MyState);break;}}
Use this for initialization
本来はUpdateに書いた方が良さそうな内容だが、プリントがやたら出るのでStartにてテスト
------------------------------
スイッチ文のサンプル
条件には、string型,float型などは使えない。
intとenumが使える。
int を直接数値で使う場合は状態のイメージがわかないので、
書いてみると、レベルやhpなど数値で分かるものを利用すべきだと思った。
*switch (State)
breakは無いと VSCode上でエラーが出る。役目はスイッチ文からの脱出
原語や環境によっては、break必須ではなさそう。
*break;
breakの下に命令を書いても意味がないし、これもVSCode上でエラーが出る。
*case 2:
default は書かなくても動く　elseと同じ役割
*default:
*//上のスイッチ文と同じ結果になるif文*if(State==0){print (State);}
------------------------------
*if(State==0){print (State);}*else if(State==1){print (State);}
上のスイッチ文と同じ結果になるif文
*//特に複雑な条件で分岐させるには　if文が強そう。*//------------------------------
必ずしもif文が長くなる訳では無いことが・・・・分かるなぁ・・・
特に複雑な条件で分岐させるには　if文が強そう。
------------------------------
なるほど enum と相性が良さそう！
状態を分けるのはif文を利用して、その後の処理はSwitch文を利用するのが良さそう。
*switch (e_MyState)

*Console.WriteLine(a);
5

処理
*}
処理
*}
処理
*}
処理
*}
処理
*}
処理
*}
処理
*}

*alpha = 0;
alpha値の初期化(色が透明な状態)

処理
*counter++;
*for (e = collection.GetEnumerator() ;*new Func;bool>;(() =>; { isContinue = e.MoveNext(); if (isContinue) s = e.Current; return isContinue; })() ;)
別の書き方

GameManagerを取得
*gamemanagerOBJ = GameObject.FindGameObjectWithTag("GameManager");
取得したGameManagerの"GetScore"を呼び出す
*gamemanagerOBJ.SendMessage("GetScore",enemystatus.sc);

時系列データを表す型をusing宣言
*using TimeSeriesData = Dictionary<;DateTime, int>;;
更にそれを種類ごとに記録するためのDictionary
例：
supplyData["燃料"][DateTime.Parse("2017/11/22 10:20:30")] = 12345
supplyData["資金"][DateTime.Parse("2017/11/23 11:21:31")] = 23456
*Dictionary<;string, TimeSeriesData>; supplyData;
*public PlotModel GraphModel {get =>; graphModel;set {graphModel = value;NotifyPropertyChanged();}}
Model側
*newGraphModel.Axes.Add(new LinearAxis { Position = AxisPosition.Bottom, Title = "X軸" });
PlotModelを作成して上書きする
グラフの要素を画面に反映する
*newGraphModel.InvalidatePlot(true);
軸の最小・最大値
*DateTime graphMin, graphMax;
*var dateTimeAxis = new DateTimeAxis{// 最小値を設定Minimum = DateTimeAxis.ToDouble(graphMin),// 最大値を設定Maximum = DateTimeAxis.ToDouble(graphMin),// 表記を書式文字列で設定// 下記例では「2017/11/21」といった風になるStringFormat = "yyyy/MM/dd"};
時刻表示向けの軸としてDateTimeAxisがあるのでそれを初期化する
最小値を設定
*Minimum = DateTimeAxis.ToDouble(graphMin),
最大値を設定
*Maximum = DateTimeAxis.ToDouble(graphMin),
表記を書式文字列で設定
下記例では「2017/11/21」といった風になる
*StringFormat = "yyyy/MM/dd"
DateTimeAxis.ToDoubleは、ChartコントロールにおけるDateTime#ToOADateのようなもの
*DateTime plotX;
大きな間隔を指定
*MajorStep = 5,
小さな間隔を指定
*MinorStep = 1,
大きな間隔で置かれる罫線のスタイル(この場合は実線・黒色)
*MajorGridlineStyle = LineStyle.Solid,
小さな間隔で置かれる罫線のスタイル(この場合は実線・灰色)
*MinorGridlineStyle = LineStyle.Dot,
*var y1Axis = new LinearAxis{ Position = AxisPosition.Left,  Key = "Primary" };
Keyに設定する文字列は一意なら何でもいい。それこそ"左軸"・"右軸"とかでもいい
Series作成時に、どちら側の軸に属するかを設定する
*var lineSeries1 = new LineSeries();
*plotModel.Axes.Add(new LinearAxis {Position = AxisPosition.Left});
横軸・縦軸を追加する。今回は縦軸をLinearAxisとした(LabelListはList&lt;string&gt;など、ラベルを表す値)
*for (int type = 0; type <; Type.Max; ++k) {// インスタンスを初期化var columnSeries = new ColumnSeries();// 積み上げられるようにするcolumnSeries.IsStacked = true;// ここに代入しておくと、積み上げ棒の成分の名前(判例)がマウスオーバーで表示できるようになるcolumnSeries.Title = $"{columnLabel[k]}";// 成分値を追加していくfor (int n = 0; n <; Data[type].Max; ++n) {columnSeries.Items.Add(new ColumnItem(Data[type][n]));}plotModel.Series.Add(columnSeries);}
グラフ要素を追加する
*for (int type = 0; type <; Type.Max; ++k) {*// インスタンスを初期化
ループが「積み上げ棒の各成分」→「各積み上げ棒における成分値」となっていることに注意
インスタンスを初期化
*var columnSeries = new ColumnSeries();
積み上げられるようにする
*columnSeries.IsStacked = true;
*columnSeries.Title = $"{columnLabel[k]}";
ここに代入しておくと、積み上げ棒の成分の名前(判例)がマウスオーバーで表示できるようになる
*for (int n = 0; n <; Data[type].Max; ++n) {*columnSeries.Items.Add(new ColumnItem(Data[type][n]));
成分値を追加していく

*print(b);
これは結局、b=1がb++2回処理されるので　３がプリントされる

*bc.SetBrightness(40);
輝度 40

*...
Dispose e

*StandingTypeInvoke ();
演出の種類を切り替える関数の呼び出し

インデックス1の引数(target)をスタックに積む
*ilGenerator.Emit(OpCodes.Ldarg_1);
pi.DeclaringType(Data型)のキャスト
*ilGenerator.Emit(OpCodes.Castclass, pi.DeclaringType);
スタック上にあるオブジェクトのプロパティ(StringValue)のGetメソッドを呼び出す
*ilGenerator.Emit(OpCodes.Callvirt, pi.GetGetMethod());
戻り値を返す
*ilGenerator.Emit(OpCodes.Ret);
インデックス1の引数(target)をスタックに積んでpi.DeclaringType(Data型)にキャスト
*ilGenerator.Emit(OpCodes.Ldarg_1);
インデックス2の引数(value)をスタックに積んでpi.PropertyType(string型)にキャスト
*ilGenerator.Emit(OpCodes.Ldarg_2);
スタック上にあるオブジェクトのプロパティ(StringValue)のSetメソッドを呼び出す
*ilGenerator.Emit(OpCodes.Callvirt, pi.GetSetMethod());
戻る
*ilGenerator.Emit(OpCodes.Ret);
*if (pi.PropertyType.IsValueType)*{
ValueTypeへの追加分
Box化する
*ilGenerator.Emit(OpCodes.Box, pi.PropertyType);
ここにValueType用のコードを追加
*}
以下はstringの時のコードに同じ
*ilGenerator.Emit(OpCodes.Ldarg_1);
ValueType用のコード
*var hasValue = ilGenerator.DefineLabel();
nullの時
...
*ilGenerator.Emit(OpCodes.Ret);
null以外の時
*ilGenerator.MarkLabel(hasValue);
分岐で飛んでくるラベルの定義
*ilGenerator.MarkLabel(hasValue);
インデックス1の引数(target)をスタックに積んでpi.DeclaringType(Data型)にキャスト
*ilGenerator.Emit(OpCodes.Ldarg_1);
インデックス2の引数(value)をスタックに積んでUnbox
*ilGenerator.Emit(OpCodes.Ldarg_2);
スタック上にあるオブジェクトのプロパティ(IntValue)のSetメソッドを呼び出す
*ilGenerator.Emit(OpCodes.Callvirt, pi.GetSetMethod());
戻る
*ilGenerator.Emit(OpCodes.Ret);
インデックス1の引数(target)をスタックに積んでpi.DeclaringType(Data型)にキャスト
*ilGenerator.Emit(OpCodes.Ldarg_1);
*if (LdcDictionary.TryGetValue(pi.PropertyType, out var action))*{
プリミティブ型なら対応する初期値をスタック
プリミティブ以外の処理(次章以降で解説)
*}
スタック上にあるオブジェクトのプロパティのSetメソッドを呼び出す
*ilGenerator.Emit(OpCodes.Callvirt, pi.GetSetMethod());
戻る
*ilGenerator.Emit(OpCodes.Ret);
ローカル変数の宣言
*var local = ilGenerator.DeclareLocal(pi.PropertyType);
ローカル変数のアドレスをスタック
*ilGenerator.Emit(OpCodes.Ldloca_S, local);
型の初期化
*ilGenerator.Emit(OpCodes.Initobj, pi.PropertyType);
ローカル変数をスタック
*ilGenerator.Emit(OpCodes.Ldloc_0);
Enumならその基となる型で、初期値用の処理をテーブルから取得
*var type = pi.PropertyType.IsEnum ? pi.PropertyType.GetEnumUnderlyingType() : pi.PropertyType;
structの処理
*var local = ilGenerator.DeclareLocal(pi.PropertyType);
*if (!pi.CanWrite)*{
書き込みに対応していない場合
NotSupportedExceptionを作って
*ilGenerator.Emit(OpCodes.Newobj, typeof(NotSupportedException).GetConstructor(Type.EmptyTypes));
throwする
*ilGenerator.Emit(OpCodes.Throw);
...既存のIL生成コードの記述
*,,,

*{public int Group { set; get; }public string Name { set; get; }}
Define other methods and classes here

BitmapImage型の画像
*System.Windows.Media.Imaging.BitmapImage bitmapImage;
BitmapImage型の画像
*System.Windows.Media.Imaging.BitmapImage bitmapImage;
BitmapImage→BitmapSource(型変換を明示する必要はない)
*System.Windows.Media.Imaging.BitmapSource bitmapSource = bitmapImage;
BitmapSource→BitmapImage(型変換を明示する必要がある)
*System.Windows.Media.Imaging.BitmapImage bitmapImage2 = (System.Windows.Media.Imaging.BitmapImage)bitmapSource;
変換元の画像
*System.Drawing.Bitmap bitmap;
*using (var ms = new System.IO.MemoryStream()) {// MemoryStreamに書き出すbitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Bmp);// MemoryStreamをシークms.Seek(0, System.IO.SeekOrigin.Begin);// MemoryStreamからBitmapFrameを作成// (BitmapFrameはBitmapSourceを継承しているのでそのまま渡せばOK)System.Windows.Media.Imaging.BitmapSource bitmapSource =System.Windows.Media.Imaging.BitmapFrame.Create(ms,System.Windows.Media.Imaging.BitmapCreateOptions.None,System.Windows.Media.Imaging.BitmapCacheOption.OnLoad);}
MemoryStreamを利用した変換処理
MemoryStreamに書き出す
*bitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Bmp);
MemoryStreamをシーク
*ms.Seek(0, System.IO.SeekOrigin.Begin);
MemoryStreamからBitmapFrameを作成
(BitmapFrameはBitmapSourceを継承しているのでそのまま渡せばOK)
*System.Windows.Media.Imaging.BitmapSource bitmapSource =
変換元の画像
*System.Drawing.Bitmap bitmap;
*using (var ms = new System.IO.MemoryStream()) {bitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Bmp);// MemoryStreamのポジションを設定？ms.Position = 0;// BitmapImageを初期化var bitmapImage = new System.Windows.Media.Imaging.BitmapImage();// MemoryStreamを書き込むために準備するbitmapImage.BeginInit();bitmapImage.CacheOption = System.Windows.Media.Imaging.BitmapCacheOption.OnLoad;bitmapImage.CreateOptions = System.Windows.Media.Imaging.BitmapCreateOptions.None;// MemoryStreamを書き込むbitmapImage.StreamSource = ms;//bitmapImage.EndInit();// ここでFreezeしておくといいらしい(参考資料参照)bitmapImage.Freeze();// BitmapImageはBitmapSourceを継承しているのでそのまま渡せばOKSystem.Windows.Media.Imaging.BitmapSource bitmapSource = bitmapImage;}
MemoryStreamを利用した変換処理
MemoryStreamのポジションを設定？
*ms.Position = 0;
BitmapImageを初期化
*var bitmapImage = new System.Windows.Media.Imaging.BitmapImage();
MemoryStreamを書き込むために準備する
*bitmapImage.BeginInit();
MemoryStreamを書き込む
*bitmapImage.StreamSource = ms;
ここでFreezeしておくといいらしい(参考資料参照)
*bitmapImage.Freeze();
BitmapImageはBitmapSourceを継承しているのでそのまま渡せばOK
*System.Windows.Media.Imaging.BitmapSource bitmapSource = bitmapImage;
変換元の画像
*System.Drawing.Bitmap bitmap;
HBitmapに変換
*var hBitmap = bitmap.GetHbitmap();
*try {var bitmapSource = System.Windows.Interop.Imaging.CreateBitmapSourceFromHBitmap(hBitmap,System.IntPtr.Zero,System.Windows.Int32Rect.Empty,System.Windows.Media.Imaging.BitmapSizeOptions.FromEmptyOptions());}
HBitmapからBitmapSourceを作成
LockBitsとUnlockBitsを使う方法
フォーマット決め打ちなので、他フォーマットだと別途変換が必要。
詳しくは参考資料における「ルーチェ's Homepage」または「nuits.jp blog」のコードを参照すること
元画像
*System.Windows.Media.Imaging.BitmapSource bitmapSource;
処理
*var bitmap = new System.Drawing.Bitmap(
Encoderを使う方法
かなり楽だがその分遅い。
SampleEncoderがSystem.Windows.Media.Imaging.BmpBitmapEncoderなら不透明部分を扱えず、
System.Windows.Media.Imaging.PngBitmapEncoderなら高性能な分余計に遅くなる
元画像
*System.Windows.Media.Imaging.BitmapSource bitmapSource;
処理
*var encoder = new SampleEncoder();
このおまじないの意味は参考資料を参照
*bitmap = new System.Drawing.Bitmap(temp);

*q = null;
ガベコレの対象になるはず

受注データを列挙して返す
*IEnumerable<;Order>; Read();
ファイルを削除する
*void Delete();
*public void Delete() {// ファイル削除処理}
固定長テキストの処理
ファイル削除処理
*}
*public void Delete() {// ファイル削除処理}
CSVファイルの処理
ファイル削除処理
*}
*public void Delete() {// ファイル削除処理}
XMLファイルの処理
ファイル削除処理
*}
*if (<;判別>;) {*return new OrderFileFromA(filePath);
ファイルパスで判別して具象クラスを返す。
orderをDB登録する処理
*}

*this.transform.localScale = Vector3.zero;
みえない大きさにする
ぶつかった位置にexplodeというprefabを配置する
*}

(ここでプロパティ、コンストラクタ、メソッドを定義)
*var typeInfo = typeBuilder.CreateTypeInfo();
インデックス0の引数(this)をスタックに積む
*ilGenerator.Emit(OpCodes.Ldarg_0);
スタック上にあるオブジェクト内のフィールド(source)を取得
*ilGenerator.Emit(OpCodes.Ldfld, sourceField);
戻り値を返す
*ilGenerator.Emit(OpCodes.Ret);
objectのコンストラクタを呼ぶ
*ilGenerator.Emit(OpCodes.Ldarg_0);
引数のsourceの値をフィールドのsourceに格納する
*ilGenerator.Emit(OpCodes.Ldarg_0);
戻る
*ilGenerator.Emit(OpCodes.Ret);
インスタンス生成
*ilGenerator.Emit(OpCodes.Newobj, ci);
返す
*ilGenerator.Emit(OpCodes.Ret);
*for (var i = 0; i <; ci.GetParameters().Length; i++)*{
argumentsの処理
argumentsの
*ilGenerator.Emit(OpCodes.Ldarg_1);
i番目を
*ilGenerator.EmitLdcI4(i);
スタックして
*ilGenerator.Emit(OpCodes.Ldelem_Ref);
型変換
*ilGenerator.EmitTypeConversion(ci.GetParameters()[i].ParameterType);
インスタンス生成
*ilGenerator.Emit(OpCodes.Newobj, ci);
返す
*ilGenerator.Emit(OpCodes.Ret);

設定記述子
*this.options = options;
データベース接続処理等を記述する。
*}

*public ReversePolishNotation Notation { get; } = new ReversePolishNotation();
逆ポーランド記法を表すオブジェクト
*public bool IsTerminate { get; private set; } = false;
トークンの取得が終わったかどうかを示す。
*public bool IsTerminate { get; private set; } = false;
MoveNextを呼び出した後でも、このプロパティを見れば、次があるかどうかがわかる。
*public Context(string exp) {_tokenizer = new Tokenizer(exp);_tokenizer.MoveNext();}
コンストラクタ　加減乗除を行う数式を引数で受け取る
*public bool MoveNext() {if (_tokenizer.MoveNext())return true;IsTerminate = true;return false;}
次のトークンを取り出すためにカレントを移動する
*public bool MoveNext() {if (_tokenizer.MoveNext())return true;IsTerminate = true;return false;}
最初のトークンを取り出すには、まず、MoveNextを呼び出す必要がある。
*public string CurrentToken {get { return _tokenizer.Current; }}
現在のトークン

*詳細については、http:
go.microsoft.comfwlink?LinkID=314055 をご覧ください。 ---&gt; System.Web.UI.ViewStateException: 無効な viewstate です。

*EnumExt.TryParse("5", out ss);
true, ss = SolarSystem.Jupiter

INotifyPropertyChanged実装
*public event PropertyChangedEventHandler PropertyChanged;
添付プロパティでItemSourceは不要になる
*private List<;object>; _ItemSource;
*{PropertyChangedCallback = OnSelectedEnumItemChanged,BindsTwoWayByDefault = true});
デフォルトBindingモードをTwoWayにするために、FrameworkPropertyMetadataを使用
添付プロパティの変更値が有効でなかったら無効
*Type newType = e.NewValue?.GetType();
添付されたコントロールがSelector以外では無効
*var selector = d as Selector;
*if (selector?.SelectedItem?.GetType() == newType)*{
変更値の型が変更前と同じなら何もしない
添付されたSelectorのItemSourceに列挙型の全値を入力
*selector.ItemsSource = Enum.GetValues(newType);
SelectedItemに直接値を入力
*selector.SelectedItem = e.NewValue;
*{Path = new PropertyPath(AutoEnumSource.SelectedEnumItemProperty),RelativeSource = RelativeSource.Self,Mode = BindingMode.TwoWay};
SelectorのSelctedItemにこの添付プロパティを双方向Bindingする

設定記述子
*this.options = options;
データベース接続処理等を記述する。
*}

*yield return new WaitForSeconds(0.5f);
0.5秒待って

*public int ID { get; } = 1;
getのみも可能
*} catch (ArgumentException e) when (e.Message == "unknown") {
Messageがtestの時はエラー無視
*} catch (ArgumentException e) {
Messageがunknownの時はメッセージを出力
その他
*throw;

*public void function(){// 複合フラグメントbreak の前に描かれた処理if( Guard == true ){// 複合フラグメントbreak 内に描かれた処理return;}// 複合フラグメントbreak の後に描かれた処理return;}
シーケンス図が、1つのメソッドの場合の例
*if( Guard == true ){*// 複合フラグメントbreak 内に描かれた処理
複合フラグメントbreak の前に描かれた処理
複合フラグメントbreak 内に描かれた処理
*return;
複合フラグメントbreak の後に描かれた処理
*return;
*if( Guard == true ){*// 複合フラグメントbreak 内に描かれた処理
複合フラグメントbreak の前に描かれた処理
複合フラグメントbreak 内に描かれた処理
*break;
複合フラグメントbreak の後に描かれた処理
*break;
*if( Guard == true ){*// 複合フラグメントbreak 内に描かれた処理
複合フラグメントbreak の前に描かれた処理
複合フラグメントbreak 内に描かれた処理
*break;
複合フラグメントbreak の後に描かれた処理
*}

*UInt64 bleAddress = 0xff00ff00ff00ff00;
ダミーアドレス
ラムダ式を渡す場合はAwait&lt;返り値の型&gt;と明示する必要あり
IAsyncOperationなどを返すメソッドはAsTask()で明示的にTaskに変換する
*var bleDevice = AsyncWrapper.Await<;BluetoothLEDevice>;(() =>;

*public EventAggregator HelloRequest { get; }
Viewへのリクエスト
*public ReactiveCommand HelloCommand { get; }
ボタンの動作
ボタン押下時、Viewへリクエストを発行する。
*HelloCommand.Subscribe(_ =>; HelloRequest.GetEvent<;PubSubEvent>;().Publish());
ViewModelの初期設定
*var viewModel = new _MainWindowViewModel();
リクエストが発行されたら、MessageBoxを表示する
*var hello = "Hello, Prism!";
リクエストが発行されたら、MessageBoxを表示する
var hello = "Hello, Prism!";   ローカル変数にする
ここのラムダ式がGCに回収される！
*viewModel.HelloRequest.GetEvent<;PubSubEvent>;().Subscribe(() =>; MessageBox.Show(hello));
リクエストが発行されたら、MessageBoxを表示する
*var hello = "Hello, Prism!";
第2引数にtrueを指定する
*viewModel.HelloRequest.GetEvent<;PubSubEvent>;().Subscribe(() =>; MessageBox.Show(hello), true);

引数なし、返り値がintのラムダ式を表す
*Expression.Lambda<;Func<;int>;>;(
動的コード生成
*Func<;int>; func=expr.Compile();
実行してみる
*Console.WriteLine(func());
引数なし、返り値がintのラムダ式を表す
*Expression.Lambda<;Func<;int,int,int>;>;(
動的コード生成
*Func<;int,int,int>; func=expr.Compile();
実行してみる
*Console.WriteLine(func(4,6));

設定記述子
*this.options = options;
データベースとの接続処理等を記述する。
*}

EnumWindowsから呼び出されるコールバック関数WNDENUMPROCのデリゲート
*private delegate bool WNDENUMPROC(IntPtr hWnd, IntPtr lParam);
*{public string ClassName;public string Title;public IntPtr hWnd;}
Windowsクラス
*public static List<;List<;Window>;>; WindowsList { get; set; }
Windowsクラスの格納リスト
*{// キャッシュクリアしない場合、同じプロセス名なら画面情報を再利用するif (_oldProcessName == null || _oldProcessName.ToUpper() != processName.ToUpper()){// 初期化_hWndList.Clear();// 画面情報の取得_targetProcessName = processName;EnumWindows(new EnumWindowsDelegate(EnumWindowCallBack), IntPtr.Zero);WindowsList = new List<;List<;Window>;>;();foreach (IntPtr hWnd in _hWndList){WindowsList.Add(GetAllChildWindows(GetWindow(hWnd), new List<;Window>;(), isAll));}_oldProcessName = processName;}}
初期化
*if (_oldProcessName == null || _oldProcessName.ToUpper() != processName.ToUpper())*{
キャッシュクリアしない場合、同じプロセス名なら画面情報を再利用する
初期化
*_hWndList.Clear();
画面情報の取得
*_targetProcessName = processName;
*{bool result = false;foreach (List<;Window>; win in WindowsList){result = win.Any(x =>; x.Title == title);if (result) break;}return result;}
タイトル存在チェック
*{_oldProcessName = null;_hWndList = new List<;IntPtr>;();}
キャッシュをクリアする
*{// 現在アクティブなプロセスIDとプロセス名を取得int processId;GetWindowThreadProcessId(GetForegroundWindow(), out processId);return Process.GetProcessById(processId).ProcessName;}
アクティブなプロセス名を取得する
現在アクティブなプロセスIDとプロセス名を取得
*int processId;
*{const int SWP_NOSIZE = 0x0001;const int SWP_NOMOVE = 0x0002;const int SWP_SHOWWINDOW = 0x0040;const int HWND_TOPMOST = -1;const int HWND_NOTOPMOST = -2;SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);SetWindowPos(hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);}
ウィンドウをアクティブにする
*{// タブコントロールなどで選択タブ以外は取得しないif (!isAll &amp;&amp; !IsWindowVisible(parent.hWnd)) return dest;dest.Add(parent);EnumChildWindows(parent.hWnd).ToList().ForEach(x =>; GetAllChildWindows(x, dest, isAll));return dest;}
指定したウィンドウの全ての子孫ウィンドウを取得し、リストに追加する
*if (!isAll &amp;&amp; !IsWindowVisible(parent.hWnd)) return dest;*dest.Add(parent);
タブコントロールなどで選択タブ以外は取得しない
*{IntPtr hWnd = IntPtr.Zero;while ((hWnd = FindWindowEx(hParentWindow, hWnd, null, null)) != IntPtr.Zero) { yield return GetWindow(hWnd); }}
与えた親ウィンドウの直下にある子ウィンドウを列挙する(孫ウィンドウは見つけてくれない)
*{int textLen = GetWindowTextLength(hWnd);string windowText = null;if (0 <; textLen){// ウィンドウのタイトルを取得するStringBuilder windowTextBuffer = new StringBuilder(textLen + 1);GetWindowText(hWnd, windowTextBuffer, windowTextBuffer.Capacity);windowText = windowTextBuffer.ToString();}// ウィンドウのクラス名を取得するStringBuilder classNameBuffer = new StringBuilder(256);GetClassName(hWnd, classNameBuffer, classNameBuffer.Capacity);return new Window() { hWnd = hWnd, Title = windowText, ClassName = classNameBuffer.ToString() };}
ウィンドウハンドルを渡すと、ウィンドウテキスト(ラベルなど)、クラス、スタイルを取得してWindowsクラスに格納して返す
ウィンドウのタイトルを取得する
*StringBuilder windowTextBuffer = new StringBuilder(textLen + 1);
ウィンドウのクラス名を取得する
*StringBuilder classNameBuffer = new StringBuilder(256);
*{// ウィンドウが可視かどうか調べるif (!IsWindowVisible(hWnd)) return true;// ウィンドウハンドルからプロセスIDを取得int processId;GetWindowThreadProcessId(hWnd, out processId);// プロセスIDからProcessクラスのインスタンスを取得if (_targetProcessName == "" ||Process.GetProcessById(processId).ProcessName.ToUpper() == _targetProcessName.ToUpper()){// ウィンドウのタイトルの長さを取得するint textLen = GetWindowTextLength(hWnd);if (0 <; textLen){_hWndList.Add(hWnd);}}return true;}
コールバック関数
*if (!IsWindowVisible(hWnd)) return true;*// ウィンドウハンドルからプロセスIDを取得
ウィンドウが可視かどうか調べる
ウィンドウハンドルからプロセスIDを取得
*int processId;
*if (_targetProcessName == "" ||*Process.GetProcessById(processId).ProcessName.ToUpper() == _targetProcessName.ToUpper())
プロセスIDからProcessクラスのインスタンスを取得
ウィンドウのタイトルの長さを取得する
*int textLen = GetWindowTextLength(hWnd);
*{public string ClassName;public string Title;public IntPtr hWnd;}
Windowsクラス
*public static List<;List<;Window>;>; WindowsList { get; set; }
Windowsクラスの格納リスト
プロセス名がnotepad(メモ帳)の画面情報を取得します。
*WindowsHandles.Initialize("notepad");
画面情報に「キャンセル」ボタンがあるかチェックします。
*bool exists = WindowsHandles.ExistsTitle("キャンセル");
結果を表示
*MessageBox.Show(exists.ToString());
WindowsHandles.WindowsListプロパティはPublicなのでご自由に。
List&lt;List&lt;WindowsHandles.Window&gt;&gt; list = WindowsHandles.WindowsList;
*,,,

*CodeList.add("\r\n\t
Operations");
*CodeList.add("\t{" + getOperationDefinition(opes[i]) + "\r\n\t}");
class

*if(other.gameObject.tag == "Player")
プレイヤーが武器を取ったら消す

*if (Input.GetMouseButtonDown(0)) controller.OnClick();
左クリックで呼び出す

チェックボックス拡大サイズ
*private const int CHECKBOX_INFLATE_SIZE = 8;
塗りつぶしと枠線描画
*bool cellSelected = (elementState &amp; DataGridViewElementStates.Selected) != 0;
チェックボックス描画
*Rectangle checkboxRect = this.GetCheckboxBounds(graphics, cellStyle, rowIndex);

*<;p<;Learn about <;a href="https:
docs.microsoft.comaspnetcore"&gt;building Web apps with ASP.NET Core&lt;a&gt;.&lt;p&gt;

*string example = " 　";
空白

*private const string TestPageUrl = @"http:
localhost:3000login.aspx";
*var model = new CopyTestsModels { Name = "Test Name" };
Reference type

TraceクラスのWriteLineメソッドを利用
*Trace.WriteLine("OK");

"べた"に書く場合:
*var tuples1 = strs.SelectMany((str) =>; nums.Select((num) =>; new Tuple<;string, int>;(str, num)));
メソッド定義した場合:
*var tuples2 = product(strs, nums, (str, num) =>; new Tuple<;string, int>;(str, num));
*var xs = new List<;int>;() { 1, 2, 3 };
引数が3つの場合:
===&gt; "べた"に書く場合 &lt;===
(a, 1)
(a, 2)
(a, 3)
(b, 1)
(b, 2)
(b, 3)
(c, 1)
(c, 2)
(c, 3)
===&gt; メソッド定義した場合 &lt;===
(a, 1)
(a, 2)
(a, 3)
(b, 1)
(b, 2)
(b, 3)
(c, 1)
(c, 2)
(c, 3)
===&gt; 引数が3つの場合 &lt;===
(1, 1, 1)
(1, 1, 2)
(1, 1, 3)
(1, 2, 1)
(1, 2, 2)
(1, 2, 3)
(1, 3, 1)
(1, 3, 2)
(1, 3, 3)
(2, 1, 1)
(2, 1, 2)
(2, 1, 3)
(2, 2, 1)
(2, 2, 2)
(2, 2, 3)
(2, 3, 1)
(2, 3, 2)
(2, 3, 3)
(3, 1, 1)
(3, 1, 2)
(3, 1, 3)
(3, 2, 1)
(3, 2, 2)
(3, 2, 3)
(3, 3, 1)
(3, 3, 2)
(3, 3, 3)
*}

*string[] sp = lines[0].Split(',');
ヘッダ
指定カラム名値判定
*string[] sp2 = lines[0].Split(',');
指定カラム名列判定
*int scoreClm = 0;
*while(!parser.EndOfData) {*string[] data = parser.ReadFields();
指定カラム名値判定

数式を逆ポーランド記法へ変換
*ReversePolishNotation rpn = ConvertToRpn(exp);
逆ポーランド記法の式を計算する
*return RpnCalculator.Calculate(rpn);
*public class Tokenizer {private string _expression;IEnumerator<;string>; _ite;public Tokenizer(string exp) {_expression = exp;_ite = GetTokens().GetEnumerator();}public bool MoveNext() {return _ite.MoveNext();}public string Current {get { return _ite.Current; }}private IEnumerable<;string>; GetTokens() {char c = NextChar();var token = "";while (c != (char)0) {if (char.IsDigit(c)) {token += c;} else if (c == '.' &amp;&amp; token.All(x =>; x != '.')) {token += c;} else {if (token != "")yield return token;token = "";if (IsSymbol(c))yield return c.ToString();else if (c != ' ')throw new ArithmeticException("正しい式ではありません");}c = NextChar();}if (token != "")yield return token;}private static bool IsSymbol(char c) {return "+-*/()".Any(x =>; x == c);}private int _currentIndex = 0;private char NextChar() {if (_currentIndex <; _expression.Length)return _expression[_currentIndex++];return (char)0;}}
Tokenに分解する

行数を取得(ヘッダー分含まず)
*string[] lines = File.ReadAllLines(@"D:\vcCsvPrc\test.csv",
分割数の決定
long syou = cntRow / 9;    商(切捨) 9は可変にする
long amari = cntRow % 9;   余り     9は可変にする
ファイル読込
*using (var sr = new System.IO.StreamReader(@"D:\vcCsvPrc\test.csv",
ヘッダー読込
*string headRow = sr.ReadLine();
*for (int i = 1; i <;= 9; ++i)*{
9ファイル作成(新規作成)
ヘッダー挿入
*sw.WriteLine(headRow);
*if (amari >; 0)*{
余りがある場合
*for (int j = 0; j <; syou + 1; ++j)*{
商 + 1回数分ループ
商分書き込む
*sw.WriteLine(sr.ReadLine());
余り - 1
*amari = amari - 1;
*for (int j = 0; j <; syou; ++j)*{
商の回数分ループ
商分書き込む
*sw.WriteLine(sr.ReadLine());

*intIterator = (IEnumerable<;int<;) d;
4

*}
end while
まず描画します
*Map.DrawMap();
配列の内容をListに入ます。
*List<;MapObject>; mapObjects = new List<;MapObject>;();
*if(goalcount <;= 0){Console.WriteLine("ゲームクリア！¥nゲームを終了します");//コンソールの終了Environment.Exit(0);}
ゴールの数が0以下ならばゲームクリアです。
コンソールの終了
*Environment.Exit(0);
*if (c != Convert.ToChar(Environment.NewLine))*{
改行コードを無視して配列の要素数を超えないようにする
c の内容によって生成するオブジェクトのTYPEを決定する
*mapobject = getObject(c);
*{for (int i = 0; i <; map.Length; i++){switch (map[i].objType){case MapObject.OBJ_TYPE.PLAYER: Console.Write('P'); break;case MapObject.OBJ_TYPE.NIMOTU: Console.Write('N'); break;case MapObject.OBJ_TYPE.WALL: Console.Write('■'); break;case MapObject.OBJ_TYPE.GOAL: Console.Write('G'); break;case MapObject.OBJ_TYPE.FLOOR: Console.Write('□'); break;case MapObject.OBJ_TYPE.GOAL_ON_NIMOTU: Console.Write('D'); break;}//幅の数だけ表示したら改行させますif ((i + 1) % mapWidth == 0){Console.Write(Environment.NewLine);}}}
オブジェクトのOBJ_TYPEを見てコンソールに出力する
*if ((i + 1) % mapWidth == 0)*{
幅の数だけ表示したら改行させます

*public MainWindow win = null;
GUI にイベントを表示するための独自実装（無くてもよい）
GUI にイベントを表示するための独自実装（無くてもよい） ===&gt;&gt;&gt;
*Application.Current.Dispatcher.BeginInvoke(
GUI にイベントを表示するための独自実装（無くてもよい） ===&lt;&lt;&lt;&lt;
*}
GUI にイベントを表示するための独自実装（無くてもよい） ===&gt;&gt;&gt;
*Application.Current.Dispatcher.BeginInvoke(
GUI にイベントを表示するための独自実装（無くてもよい） ===&lt;&lt;&lt;&lt;
*}
イベントシンクとの切断
*m_connectionPoint.Unadvise(m_sinkCookie);
COMオブジェクトの開放
*Marshal.ReleaseComObject(m_connectionPoint);

*Player_pos = transform.position;
プレイヤーの位置を更新

*0xC3
ret

*if (Input.touchCount >; 0) {*Touch touch = Input.GetTouch (0);
タップ処理
*if (Input.touchCount >; 0) {*Touch touch = Input.GetTouch (0);
タップ処理
*if (Input.touchCount >; 0) {*Touch touch = Input.GetTouch (0);
タップ処理
*if (Input.touchCount >; 0) {*Touch touch = Input.GetTouch (0);
タップ処理

アクセス修飾子をinternalからpublicへ変更する
*public class Calculator

設定値の取得
*var testValue = config["AppSettings:TestConstValue"];
以下の書き方でも取得できます。
*testValue = config.GetSection("AppSettings")["TestConstValue"];
ConnectionString は専用のメソッドが用意されています。
*var connectionString = config.GetConnectionString("Default");
下記の書き方でも取得できますが、専用のメソッドを利用するほうが簡単です。
*connectionString = config["ConnectionStrings:Default"];
設定ファイルのベースパスをカレントディレクトリ( 実行ファイルと同じディレクトリ )にします。
*configBuilder.SetBasePath(Directory.GetCurrentDirectory());
Json ファイルへのパスを設定します。SetBasePath() で設定したパスからの相対パスになります。
*configBuilder.AddJsonFile(@"AppConfig.json");

入れの子のGenericには対応していない
*var type = list.GetType().GetGenericArguments().First();
クリップボードに出力
*Clipboard.SetText(list.ToTsv());

*if (e.ColumnIndex <; 0 &amp;&amp; e.RowIndex >;= 0)*{
列ヘッダーかどうか調べる
セルを描画する
*e.Paint(e.ClipBounds, DataGridViewPaintParts.All);
行番号を描画する範囲を決定する
e.AdvancedBorderStyleやe.CellStyle.Paddingは無視しています
*Rectangle indexRect = e.CellBounds;
行番号を描画する
*TextRenderer.DrawText(e.Graphics,
描画が完了したことを知らせる
*e.Handled = true;

*{private double mReal;private double mImaginary;public Complex() { mReal = 1.0; mImaginary = 0.1; }public double Real{get { return mReal; }set { mReal = value; }}public double Imaginary{get { return mImaginary; }set { mImaginary = value; }}}
テスト用のクラス
*{for (int j=0; j <; kCount0o/sFactor; ++j){for (int i=0; i <; kCount0i; ++i){var temp = new Complex();sVolatileInt = (int)temp.Real;}}}
コンストラクト
*{return (iLhs >; iRhs)?iLhs:iRhs;}
テスト用の通常メソッド
*{return (iLhs.CompareTo(iRhs) >; 0)?iLhs:iRhs;}
テスト用のジェネリック・メソッド
*{for (int j=0; j <; kCount0o/sFactor; ++j){for (int i=0; i <; kCount0i; ++i){sVolatileInt = maxInt(i, j);}}}
通常関数
*{for (int j=0; j <; kCount0o/sFactor; ++j){for (int i=0; i <; kCount0i; ++i){sVolatileInt = max<;int>;(i, j);}}}
int型
*{for (int j=0; j <; kCount0o/sFactor; ++j){for (int i=0; i <; kCount0i; ++i){sVolatileInt = (int)max<;double>;(i, j);}}}
double型
*{for (int j=0; j <; kCount0o/sFactor; ++j){for (int i=0; i <; kCount0i; ++i){sVolatileInt =int.Parse(max<;String>;(i.ToString(), j.ToString()));}}}
string型

設定記述子
*this.options = options;
データベース接続処理等を記述する。
*}
*public string nameSei { get; set; }
【ポイント】HTMLのFormタグのID名とEntityのプロパティ名を揃えること。

*ToastNotificationManager.CreateToastNotifier(appId).Show(notification);*,,,
トースト通知を飛ばす

*// ===>; new List<;string>;() { "a", "a" }が複製されていないことが確認できます。
想定していた値: [b,a][a,a]
*// ===>; new List<;string>;() { "a", "a" }が複製されていないことが確認できます。
実際の値: [b,a][b,a]
===&gt; new List&lt;string&gt;() { "a", "a" }が複製されていないことが確認できます。
*}
想定していた値 =&gt; [b,a][a,a]
実際の値       =&gt; [b,a][a,a]
*}

コンポジション
*private List<;Piyo>; m_piyos = new List<;Piyo>;();
部分が他の全体に属しているかをチェックするリスト
*private static List<;Piyo>; m_piyosCheckList = new List<;Piyo>;();
*if (m_piyosCheckList.Contains(piyo) == true)*{
この要素がすでに全体に属しているかチェック
すでに他の全体に属しています
*return false;
部分として保持
*m_piyos.Add(piyo);
この要素が全体に属したことを記憶する
*m_piyosCheckList.Add(piyo);
部分としてのリストから削除
*bool ans = m_piyos.Remove(piyo);
この要素が全体に属したことを記憶から消す
*m_piyosCheckList.Remove(piyo);

Dataクラスはid, name, pointプロパティを持つとする。
*var DataList = new List<;Data>;();
②と同様の結果が得られる(LINQではなくListのメソッド)
*var record　= DataList.Find(data =>; data.id =="1");

*var result = list.Select((string s) =<; { return s + ".txt"; });
← 直接リテラルを書く

*public void Post([FromForm] TorokuFormEntity formData)
成功：[FromForm] TorokuFormEntity formData
DB登録等の処理を記述する。
*}

*response.Play(url: "https:
api.twilio.comcowbell.mp3", loop: 1);
録音終了
var url = request.RecordingUrl;  録音データURL
*var response = new VoiceResponse();
録音データ保存完了
*}

*m_piyos[u].Execute();
要素有無のチェックは省略

*{string hoge = "hoge";//重たい処理return "hoge";}
async句をつけたメソッドはAsyncのsuffixを付けることが推奨されています。
重たい処理
*return "hoge";
処理A
*string hoge = await HeavyProcessingAsync();
処理B
*}
あるいはTask.Result();
*}
重たい処理
*token.ThrowIfCancellationRequested();
*// if (token.IsCancellationRequested)*// {
↑以下のコードのシンタックスシュガーになります
*// {//     throw new OperationCanceledException(token)// }
if (token.IsCancellationRequested)
重たい処理
*return hoge;

*aes.Padding = PaddingMode.PKCS7;
デフォルト
*using (ICryptoTransform decryptor = aes.CreateDecryptor())*{
対称復号化オブジェクト
*{byte[] buffer = new byte[1024];int len;while ((len = cs.Read(buffer, 0, buffer.Length)) >; 0){outfs.Write(buffer, 0, len);}}
暗号化されたデータを読み込むための復号ストリーム

*using System;
Actionに必要
*public class InputManager : MonoBehaviour {public event Action Idle;public event Action Attack01;public event Action Attack02;void Update () {if (Input.GetKeyDown (KeyCode.Space) &amp;&amp; Idle != null) {Idle ();}if (Input.GetKeyDown (KeyCode.F1) &amp;&amp; Attack01 != null) {Attack01 ();}if (Input.GetKeyDown (KeyCode.F2) &amp;&amp; Attack02 != null) {Attack02 ();}}}
委譲先 アクションメソッドを実行する
*public class InputManager : MonoBehaviour {public event Action Idle;public event Action Attack01;public event Action Attack02;void Update () {if (Input.GetKeyDown (KeyCode.Space) &amp;&amp; Idle != null) {Idle ();}if (Input.GetKeyDown (KeyCode.F1) &amp;&amp; Attack01 != null) {Attack01 ();}if (Input.GetKeyDown (KeyCode.F2) &amp;&amp; Attack02 != null) {Attack02 ();}}}
-------------------------------------------
*public class ActionTest1 : MonoBehaviour {private InputManager inputManager;void Awake() {// scriptの参照GameObject inputManagerObj = GameObject.Find("InputManager");if (inputManagerObj != null) {inputManager = inputManagerObj.GetComponent<;InputManager>; ();}if (inputManager == null) {Debug.Log ("Cannot find 'InputManager' script");}}void OnEnable() {// アクションメソッドの登録inputManager.Idle += Idle;inputManager.Attack01 += Run;inputManager.Attack01 += Punch;inputManager.Attack02 += Jump;inputManager.Attack02 += Kick;}void OnDisable() {// アクションメソッドの削除inputManager.Idle -= Idle;inputManager.Attack01 -= Run;inputManager.Attack01 -= Punch;inputManager.Attack02 -= Jump;inputManager.Attack02 -= Kick;}void Idle() {Debug.Log ("[ActionTest1] Idle...");}void Run() {Debug.Log ("[ActionTest1] Run...");}void Jump() {Debug.Log ("[ActionTest1] Jump...");}void Kick() {Debug.Log ("[ActionTest1] Kick...");}void Punch() {Debug.Log ("[ActionTest1] Punch...");}}
委譲元 アクションメソッドの登録・削除（実行はしない）
*public class ActionTest1 : MonoBehaviour {private InputManager inputManager;void Awake() {// scriptの参照GameObject inputManagerObj = GameObject.Find("InputManager");if (inputManagerObj != null) {inputManager = inputManagerObj.GetComponent<;InputManager>; ();}if (inputManager == null) {Debug.Log ("Cannot find 'InputManager' script");}}void OnEnable() {// アクションメソッドの登録inputManager.Idle += Idle;inputManager.Attack01 += Run;inputManager.Attack01 += Punch;inputManager.Attack02 += Jump;inputManager.Attack02 += Kick;}void OnDisable() {// アクションメソッドの削除inputManager.Idle -= Idle;inputManager.Attack01 -= Run;inputManager.Attack01 -= Punch;inputManager.Attack02 -= Jump;inputManager.Attack02 -= Kick;}void Idle() {Debug.Log ("[ActionTest1] Idle...");}void Run() {Debug.Log ("[ActionTest1] Run...");}void Jump() {Debug.Log ("[ActionTest1] Jump...");}void Kick() {Debug.Log ("[ActionTest1] Kick...");}void Punch() {Debug.Log ("[ActionTest1] Punch...");}}
-------------------------------------------
*if (inputManagerObj != null) {inputManager = inputManagerObj.GetComponent<;InputManager>; ();}
scriptの参照
アクションメソッドの登録
*inputManager.Idle += Idle;
アクションメソッドの削除
*inputManager.Idle -= Idle;
*public class ActionTest2 : MonoBehaviour {private InputManager inputManager;void Awake() {// scriptの参照GameObject inputManagerObj = GameObject.Find("InputManager");if (inputManagerObj != null) {inputManager = inputManagerObj.GetComponent<;InputManager>; ();}if (inputManager == null) {Debug.Log ("Cannot find 'InputManager' script");}}void OnEnable() {// アクションメソッドの登録inputManager.Idle += Talk;inputManager.Attack01 += PunchSound;inputManager.Attack02 += KickSound;}void OnDisable() {// アクションメソッドの削除inputManager.Idle -= Talk;inputManager.Attack01 -= PunchSound;inputManager.Attack02 -= KickSound;}void Talk() {Debug.Log ("[ActionTest2] Talk...");}void KickSound() {Debug.Log ("[ActionTest2] KickSound...");}void PunchSound() {Debug.Log ("[ActionTest2] PunchSound...");}}
委譲元 アクションメソッドの登録・削除（実行はしない）
*public class ActionTest2 : MonoBehaviour {private InputManager inputManager;void Awake() {// scriptの参照GameObject inputManagerObj = GameObject.Find("InputManager");if (inputManagerObj != null) {inputManager = inputManagerObj.GetComponent<;InputManager>; ();}if (inputManager == null) {Debug.Log ("Cannot find 'InputManager' script");}}void OnEnable() {// アクションメソッドの登録inputManager.Idle += Talk;inputManager.Attack01 += PunchSound;inputManager.Attack02 += KickSound;}void OnDisable() {// アクションメソッドの削除inputManager.Idle -= Talk;inputManager.Attack01 -= PunchSound;inputManager.Attack02 -= KickSound;}void Talk() {Debug.Log ("[ActionTest2] Talk...");}void KickSound() {Debug.Log ("[ActionTest2] KickSound...");}void PunchSound() {Debug.Log ("[ActionTest2] PunchSound...");}}
-------------------------------------------
*if (inputManagerObj != null) {inputManager = inputManagerObj.GetComponent<;InputManager>; ();}
scriptの参照
アクションメソッドの登録
*inputManager.Idle += Talk;
アクションメソッドの削除
*inputManager.Idle -= Talk;

*public static decimal Calculate(ReversePolishNotation rpn) {Stack<;object>; stack = new Stack<;object>;();foreach (var token in rpn.Tokens) {if (IsOperator(token)) {var b = (decimal)stack.Pop();var a = (decimal)stack.Pop();var c = Operate(a, b, token);stack.Push(c);} else {stack.Push(decimal.Parse(token));}}return (decimal)stack.Pop();}
後置記法を計算する

*public int Index { get; private set; }
左側もしくは右側の頂点配列のインデックス
*public Vector3 Position { get; private set; }
位置
*public bool IsLeft { get; private set; }
左側か右側のフラグ
*if (triangles.Count() <; 2)*return null;
三角形の数が2つ未満の場合は計算できないので空のパスを返す
*if (!CreateVertices3D(triangles))*return null;
与えられた三角形リストから３次元における左右の頂点配列を作成する
3次元における頂点配列を２次元における頂点配列にコピーする
*CopyVertices3DToVertices2D();
コピーした頂点配列を2次元に変換する
*ConvertTo2D();
XY平面上に変換する
*ConvertToXYPlane();
Funnelの先端を始点にセットする (右側も左側も同じなのでどっちを採用してももいい。ここでは左側を採用)
*apex = new Apex(0, leftVertices2d[0], true);
Funnelの左側の頂点リストに最初の頂点を追加する(先端から1つ進んだとこから開始する)
*leftIndices.Add(1);
Funnelの右側の頂点リストに最初の頂点を追加する(先端から1つ進んだとこから開始する)
*rightIndices.Add(1);
*while (UpdateFunnel()) { }*// 終点にたどり着いたら現在のFunnelの先端を追加する
終点にたどり着くまでFunnelに頂点を追加していく
終点にたどり着いたら現在のFunnelの先端を追加する
*apexes.Add(apex);
終点を追加する(ここも左、右側のどちらを採用してもOK)
*apexes.Add(new Apex(leftVertices2d.Length - 1, leftVertices2d.Last(), true));
共有辺との交点()を求め、最終的なパスを計算する
*var path = MakePath();
三角形リストから共有辺のリストを作成する
*var commonEdges = new List<;Edge>;();
前後の三角形から共有辺を探す
*var commonEdge = pair.Left.FindCommonEdge(pair.Right);
共有辺が見つからない場合は連結してないので失敗
*return false;
３次元における頂点配列を初期化する。 長さは 始点 + 終点 + 共有辺の数 になる
*leftVertices3d = new Vector3[commonEdges.Count + 2];
始点を求める。始点は最初の三角形の頂点の内、最初の共有辺に向かいあう頂点
*var startPoint = triangles.First().FindOppositeVertex(commonEdges.First()).Value;
始点を両サイドの頂点配列に追加
*leftVertices3d[0] = rightVertices3d[0] = startPoint;
共有辺の頂点を左、右に分けていく
*var i = 1;
*if (commonEdge.A.Equals(leftVertices3d[i - 1]) || commonEdge.B.Equals(rightVertices3d[i - 1]))*{
頂点配列の最後と一致するかを調べて一致する場合はそのサイドに配列に追加する。一致しないほうは逆サイドに追加する。　必ずどちらかに一致する
終点を求める。終点は最後の三角形の頂点の内、最後の共有辺に向かいある頂点
*var endPoint = triangles.Last().FindOppositeVertex(commonEdges.Last()).Value;
終点を両サイドの頂点配列に追加
*leftVertices3d[leftVertices3d.Length - 1] = rightVertices3d[leftVertices3d.Length - 1] = endPoint;
3次元における頂点配列をそのままコピーする
コピーしたものをあとで2次元に変換する
*leftVertices2d = leftVertices3d.Select(v =>; new Vector3(v.x, v.y, v.z)).ToArray();
回転対象の頂点をもとめる
*var isLeftEqual = leftVertices2d[i].Equals(leftVertices2d[i - 1]);
origin - edge 平面の法線
*var originNormal = Vector3.Cross(leftVertices2d[i - 1] - rightVertices2d[i - 1], origin - leftVertices2d[i - 1]).normalized;
target - edge 平面の法線
*var targetNormal = Vector3.Cross(rightVertices2d[i - 1] - leftVertices2d[i - 1], target - rightVertices2d[i - 1]).normalized;
2つの法線間の角度を求める
*var angle = MathUtility.SignedVectorAngle(originNormal, targetNormal, leftVertices2d[i - 1] - rightVertices2d[i - 1]);
edge を軸としてangleだけ回転するQuaternionを求める
*var rotation = Quaternion.AngleAxis(angle, rightVertices2d[i - 1] - leftVertices2d[i - 1]);
回転軸に回転を適用して平行移動量を求める
*var translation = leftVertices2d[i - 1] - (rotation * leftVertices2d[i - 1]);
求めた変換パラメータを現在の頂点以降の頂点全てに適用する
適用する順番は回転-&gt;平行移動の順にすること
*leftVertices2d[j] = rotation * leftVertices2d[j];
次の回転の起点を求める
*var nextOrigin = isLeftEqual ? rightVertices2d[i - 1] : leftVertices2d[i - 1];
始点を原点に移動するパラメータを求める
*var origin = leftVertices2d[0];
*for (int i = 0; i <; leftVertices2d.Length; i++)*{
全ての頂点に対してパラメータを適用する
*foreach (var pair in apexes.MakePairs())*{
先端リストの前後でペアを作成してループで回す
現在の先端の頂点インデックスを開始インデックスとする
*var startIndex = pair.Left.Index;
次の先端の頂点インデックスを終了インデックスとする
*var endIndex = pair.Right.Index;
現在の先端のポジション(3次元)をパスに追加
*var startPoint = (pair.Left.IsLeft ? leftVertices3d : rightVertices3d)[pair.Left.Index];
*if (startIndex == 0)*{
現在の先端の法線を求める
始点の場合
*normals.Add(Vector3.Cross(rightVertices3d[1] - leftVertices3d[1], rightVertices3d[1] - leftVertices3d[0]).normalized);
*foreach (var i in Enumerable.Range(startIndex + 1, endIndex - startIndex))*{
開始インデックスから終了インデックスまでの共有辺との交点を求める
*if (MathUtility.SegmentSegmentIntersection(out intersection, pair.Left.Position, pair.Right.Position, leftVertices2d[i], rightVertices2d[i]))*{
現在の先端 - 次の先端 の線分と 共有辺との交点を求める
後から3次元に変換できるように共有辺の左側の頂点から交点までの長さを割合として計算する
*var lerp = Vector3.Distance(intersection, leftVertices2d[i]) / Vector3.Distance(rightVertices2d[i], leftVertices2d[i]);
各サイドの3次元における頂点を取得
*var left3dpos = leftVertices3d[i];
先ほど求めた割合から3次元における交点を算出する
*var position = Vector3.MoveTowards(left3dpos, right3dpos, Vector3.Distance(left3dpos, right3dpos) * lerp);
現在の面の法線を求める
*var currentOpposite = rightVertices3d[i].Equals(rightVertices3d[i - 1]) ? leftVertices3d[i - 1] : rightVertices3d[i - 1];
次の面の法線を求める
*var nextOpposite = rightVertices3d[i + 1].Equals(rightVertices3d[i]) ? leftVertices3d[i] : rightVertices3d[i];
パスに追加
*positions.Add(position);
3次元における終点をパスに追加
*var endPoint = leftVertices3d[leftVertices3d.Length - 1];
終点の法線を求める
*var endNormal = Vector3.Cross(leftVertices3d[leftVertices3d.Length - 2] - rightVertices3d[rightVertices3d.Length - 2], leftVertices3d[leftVertices3d.Length - 2] - leftVertices3d.Last()).normalized;
同じポジションでグループ化する
*var positionGroups = positions.SplitByEquality();
法線を合成する
*var resultNormals = new List<;Vector3>;();
ポジションリストに対応する法線リストを取得して合成する
*var resultNormal = MathUtility.Synthesize(normals.Skip(skipCount).Take(g.Count()));
*if (leftVertices2d.Length - 1 <;= leftIndices.Last())*return false;
Funnelの左側の頂点リストが終点にたどり着いたら終了 (右側も終点になるはずなので左側のチェックでよい)
*if (Push(leftVertices2d, rightVertices2d, ref leftIndices, ref rightIndices, true))*{
Funnelの左側に頂点を追加する
左側に追加できた場合は右側に追加する
*Push(rightVertices2d, leftVertices2d, ref rightIndices, ref leftIndices, false);
進めた際にFunnnelの反対側の頂点リストを追い越さないかを調べる
*var crossedIndex = IsCrossedOppositeVertices(targets, opposites, targetIndices, oppositeIndices);
追い越した場合は現在のFunnelの先端を記録する
*apexes.Add(apex);
Funnelの先端を追い越されたほうの頂点にセットする
*apex = new Apex(crossedIndex, opposites[crossedIndex], !isLeft);
Funnelの両サイドのインデックスをセットする
*var nextIndex = apex.Index + 1;
*if (!apex.Position.Equals(opposites[nextIndex]))*break;
Funnelの先端と同じ座標にいる場合は座標が変わるまでインデックスを進める
進めることができなかったのでFalseを返す
*return false;
進めることができる
*var next = targetIndices.Last() + 1;
*if (IsTightened(targets, opposites, targetIndices, oppositeIndices))*{
進めた場合Funnelが絞られるかを調べる
Funnelが絞られるので一度頂点リストをクリアする
*targetIndices.Clear();
新しい頂点として追加
*targetIndices.Add(next);
進めることができたのでTrueを返す
*return true;
先端から、進める側の最後の頂点に向かうベクトル
*var lastVec = (targets[targetIndices.Last() + 1] - apex.Position).normalized;
先端から、進める側の最初の頂点に向かうベクトル
*var firstVec = (targets[targetIndices.First()] - apex.Position).normalized;
先端から、反対側の最初の頂点に向かうベクトル
*var oppositeVec = (opposites[oppositeIndices.First()] - apex.Position).normalized;
先端から、進める側の最後の頂点に向かうベクトル
*var lastVec = targets[targetIndices.Last()] - apex.Position;
先端から、進める側の追加する頂点に向かうベクトル
*var nextVec = targets[targetIndices.Last() + 1] - apex.Position;
先端から、反対側のi番目の頂点に向かうベクトル
*var oppositeVec = opposites[i] - apex.Position;
*if (target == Vector3.zero || current == Vector3.zero || next == Vector3.zero)*return false;
不正なベクトルの場合はダメ
更新前のベクトルと基準となるベクトルの外積をとる
*var currentCross = Vector3.Cross(target, current).normalized;
更新後のベクトルと基準となるベクトルの外積をとる
*var nextCross = Vector3.Cross(target, next).normalized;
外積が反対方向なら追い越したことになる
*return dot <;= 0;

直接メソッドを書く方法。
*this.btn3.Click += (sender, e) =>; MessageBox.Show("Button3だよ");
*{case "btn1":MessageBox.Show("Button1だよ");break;case "btn2":MessageBox.Show("Button2だよ");break;}
ボタンの種類によって処理を変更

別スレッドによるUI操作
*this.Invoke((MethodInvoker)(() =>; TextBox.Text = "hoge"));
UIスレッドからのUI操作
*TextBox.Text = "hoge";

*var res = await httpClient.GetAsync("http:
gochiusa.com");

*|| (length <;= 2 &amp;&amp; path[1] == VolumeSeparatorChar) )
':'
*if ( path[0] == DirectorySeparatorChar*|| path[0] == AltDirectorySeparatorChar ) return true;
先頭の文字が '\' 若しくは '/' の場合、絶対パスと判定。
*if ( length >;= 2 &amp;&amp; path[1] == VolumeSeparatorChar ) return true;*}
二文字目が ':' の場合、絶対パスと判定。
上記２パターン以外は全て相対パスと判定。
*return false;
先頭の文字が '\' 若しくは '/' の場合、絶対パスと判定。
*char c1 = path.at(0);
二文字目が ':' の場合、絶対パスと判定。
*char c2 = path.at(1);
上記２パターン以外は全て相対パスと判定。
*return false;

*using UnityEditor;
エディタ拡張関連はUnityEditor名前空間に定義されているのでusingしておく。
*{// メニューのWindowにEditorExという項目を追加。[MenuItem("Window/EditorEx")]static void Open(){// メニューのWindow/EditorExを選択するとOpen()が呼ばれる。// 表示させたいウィンドウは基本的にGetWindow()で表示＆取得する。EditorWindow.GetWindow<;EditorExWindow>;( "EditorEx" ); // タイトル名を"EditorEx"に指定（後からでも変えられるけど）}// Windowのクライアント領域のGUI処理を記述void OnGUI(){// 試しにラベルを表示EditorGUILayout.LabelField( "ようこそ！　Unityエディタ拡張の沼へ！" );}}
エディタに独自のウィンドウを作成する
メニューのWindowにEditorExという項目を追加。
*[MenuItem("Window/EditorEx")]
メニューのWindow/EditorExを選択するとOpen()が呼ばれる。
表示させたいウィンドウは基本的にGetWindow()で表示＆取得する。
EditorWindow.GetWindow&lt;EditorExWindow&gt;( "EditorEx" );  タイトル名を"EditorEx"に指定（後からでも変えられるけど）
*}
*{// 試しにラベルを表示EditorGUILayout.LabelField( "ようこそ！　Unityエディタ拡張の沼へ！" );}
Windowのクライアント領域のGUI処理を記述
試しにラベルを表示
*EditorGUILayout.LabelField( "ようこそ！　Unityエディタ拡張の沼へ！" );

*if (range.EntireColumn.OutlineLevel <; 8) {
最大8段階

*.Where(x =<; x.NewItem.SkipWhile(n =<; !n).Skip(1).Any(n =<; n))
コントロールの個数を考えるとCount()を素直に使ってよさそうですね

RedisのDBを選択
*IDatabase db = RedisRepository.SelectCache(0);
キーを生成
*var key = "hoge";
スコア算出の為、Unixtimeを取得
*var unixSeconds = DateTimeOffset.Now.ToUnixTimeSeconds();
経過秒数をスコアとして保存
*var score = (double)unixSeconds;
閲覧履歴の情報をソート済みセット型で登録
*db.SortedSetAdd(key, "りんご", score);
保持期間を設定する場合は下記（例：30日）
*db.KeyExpire(key, new TimeSpan(30, 0, 0, 0));
最大件数を設定する場合は下記
*var current = db.SortedSetRangeByScore(key);
最下位のデータを削除
*db.SortedSetRemoveRangeByRank(key,0,0);
最新の閲覧順（スコアが高い順）に取得
*var list = db.SortedSetRangeByScore(key, order: Order.Descending);

結合セル
*int cellwidth = 4;
*if (line.Index == 0 || line.Value.Contains("/"))*{
見出し行

*int m = 0;
重解 multiple root
Int32に変換する
*a = BitConverter.ToInt32(bs, 0);
*} while (a == 0);*rng.GetBytes(bs);
a = -1;
Int32に変換する
*b = BitConverter.ToInt32(bs, 0);
Int32に変換する
*c = BitConverter.ToInt32(bs, 0);
Int32に変換する
*d = BitConverter.ToInt32(bs, 0);

*} else {
2分割
*} else {
セル位置取得
セル位置取得
*this.RangeToLocation(range.Row, range.Column, out x, out y);

*if (Input.GetKeyDown(KeyCode.Escape)) {*// アプリ終了
Backキー押下
アプリ終了
*Application.Quit();
*if (Input.GetKeyDown(KeyCode.Escape)) {*// アプリ終了
Backキー押下
アプリ終了
*Application.runInBackground = false;

エラー 'Random' は、'UnityEngine.Random' と 'System.Random' 間のあいまいな参照です
*int a = Random.Range(0,10);
UnityEngine名前空間のクラスであることを明示（0以上10未満の乱数が返る）
*int RUNDOM_NUMBER_1 = UnityEngine.Random.Range(0,10);
System名前空間のクラスであることを明示（0以上10未満の乱数が返る）
*System.Random r = new System.Random();
シード値（1000）を使用して初期化
シード値が変わらなければ毎回同じ乱数を返す
*System.Random r = new System.Random(1000);
0以上10未満の乱数を整数で返す
*int RANDOM_NUMBER_1 = r.Next(10);
-10以上10未満の乱数を整数で返す
*int RANDOM_NUMBER_2 = r.Next(-10,10);
0以上Int32.MaxValue（32bit符号付き整数の最大有効値:2147483647）未満の乱数を整数で返す
*int RANDOM_NUMBER_3 = r.Next();
0以上10未満の乱数を浮動小数点数で返す
*int RANDOM_NUMBER = UnityEngine.Random.Range(0,10);

*[Route("api
TorokuForm")] [Route("api[controller]")]
設定記述子
*this.options = options;
処理を書く。
*}

*var value    = buffer.ElementAt(3);
(2)

*{ new Group { No = 1, Name = "Cat", Members = new List<;Member>; {new Member { No = 1, Name = "Tama", Age = 12, IsIndoor = true },new Member { No = 2, Name = "Mike", Age = 9, IsIndoor = true },new Member { No = 3, Name = "Chibi", Age = 1, IsIndoor = true },new Member { No = 4, Name = "Mosa", Age = 3, IsIndoor = false },new Member { No = 5, Name = "Grow", Age = 5, IsIndoor = false },}},
初期化：GroupクラスはMemberクラスのリストを要素に持つ
*.SelectMany(r =>; r.Members, (g, m) =>; new { g, m })
IsIndoor == true の Group Name と Member Name を取得
*foreach (var v in q) {*Console.WriteLine(string.Format("[{0}] {1}", v.GroupName, v.MemberName));
表示

*.AddErrorDescriber<;Resources.IdentityErrorDescriberJP<;()
←これ

*int m = 0;
重解 multiple root
Int32に変換する
*a = BitConverter.ToInt32(bs, 0);
*} while (a == 0);*rng.GetBytes(bs);
a = -1;
Int32に変換する
*b = BitConverter.ToInt32(bs, 0);
Int32に変換する
*c = BitConverter.ToInt32(bs, 0);

各Animate() には StartCoroutine を呼び出すロジックが書いてある
*hoge.Animate();
*foreach(var _ in Anim1()) { yield return _; }*// Anim2
Anim1
*foreach(var _ in Anim2()) { yield return _; }*// ...
Anim2

0と1ではOK返してるけど、2以降ではfalseを返す
*return S_FALSE;
*if ((fileAttributes &amp; FileAttributes.Directory) == 0) {*return S_FALSE;
ディレクトリオンリー

*case Reset:
Sourceの配列がClearされたので, targetの配列もClearする
customerWatchers は customers と同期する
*customers.Add(new Customer());

*var ssid = wifiManager.ConnectionInfo.SSID;*var bssid = wifiManager.ConnectionInfo.BSSID;
SSIDとBSSIDの取得
SSIDを取得
*string GetSSID();

*dynamic mat = input;
Matのメソッドに触れるためdynamicに突っ込む
特に操作せずに返却→デフォルトのDumpによる表示が行われる
*return input;
なんか処理とかするする
*}
横に並べて表示してくれるやつ。
文字列がキャプションになって、それ以降の引数のobjectに対してDumpメソッドを呼んでくれる。
*Util.HorizontalRun("origin,half,gray,binary", origin, half, gray, binary).Dump();

*foreach (var p in t.GetProperties(BindingFlags.Public | BindingFlags.NonPublic |BindingFlags.Static)) {if (p.PropertyType == typeof(Bitmap)) {//いろいろする}}
リフレクションを使ってBitmap型のリソースを取得
いろいろする
*}
いろいろする
*}

INotifyPropertyChangedは必ずこのイベントをもっていなければならない
*public event PropertyChangedEventHandler PropertyChanged;
自作したプロパティのセッター
必ずプロパティ変更通知を飛ばす
*public void SetProperty<;T>;(ref T target, T value, [CallerMemberName] string caller ="")
UIに値を書き込む
WPFならxaml(View)にプロパティを書き込むことになる
*}
HPに値が入ったら, 自動的にgauge側で登録した処理が行われる
*player.HP = 200;

*}
end of method GCAllocTest::Update

モデルのインスタンスを生成
*_Model = new MyModel();

Disposeしてみる
*_compositeDisposable1.Dispose();
Clearしてみる
*_compositeDisposable2.Clear();
*void Start () {//テスト用IDisposable_test1 = Observable.Interval(TimeSpan.FromSeconds(1)).Subscribe(_ =>; Debug.Log("Dispose1")).AddTo(_compositeDisposable1);_test2 = Observable.Interval(TimeSpan.FromSeconds(1)).Subscribe(_ =>; Debug.Log("Dispose2")).AddTo(_compositeDisposable1);_test3 = Observable.Interval(TimeSpan.FromSeconds(1)).Subscribe(_ =>; Debug.Log("Clear1")).AddTo(_compositeDisposable2);_test4 = Observable.Interval(TimeSpan.FromSeconds(1)).Subscribe(_ =>; Debug.Log("Clear2")).AddTo(_compositeDisposable2);//実験用Observable.Interval(TimeSpan.FromSeconds(1.5f)).Subscribe(_ =>; {TestDispose();TestClear();});}
Use this for initialization
テスト用IDisposable
*_test1 = Observable.Interval(TimeSpan.FromSeconds(1))
*.Subscribe(_ =>; {TestDispose();TestClear();});
実験用

*var l1 = new List<;int>;(){1,2};
Your code here!

*var duration = GetMovieDuration(inputMoviePath);
see [Gist](https:gist.github.comkokeiro001a8a6194296ea7973a55c6fe3c2865cf2#file-imageextractor-cs-L176-L197)
*.Select(x =>; new { SeekSec = x * interval.TotalSeconds, No = x });
処理対象時間を列挙する

*SceneManager.LoadScene("next", LoadSceneMode.Additive);
nextシーンを追加
*GameObject bullet = Instantiate (BulletPrefab, transform.position, transform.rotation);*Rigidbody rb = bullet.GetComponent;Rigidbody>;();
大砲（親要素）の位置と回転をもった弾丸を生成し、
*rb.AddForce(transform.up * 30, ForceMode.VelocityChange);*}
推力をvec3で設定し、力のタイプ（加速、衝撃、速度変化）を決める
衝突したgameObjectのメソッドをコール
*collision.gameObject.SendMessage("hit");
破壊
*Destroy(gameObject);

*users = (List<;User<;)JsonSerializer.SerializerList<;User<;().ReadObject(fs3);
ここで例外

毎回シード値を変更して、
1以上100000未満の整数（乱数のようなもの）を生成する
*Random r = new Random(seed++);
生成した乱数のようなものを出力して、
区切り文字としてスペースも出力する
*Console.Write(num + " ");
string型の配列に1つ1つ格納
*string[] str = Console.ReadLine().Split(' ');
計測開始
*start = DateTime.Now;
配列strの中身をint型に変換してから
10で割った余りを出力する
*Console.Write(int.Parse(str[i]) % 10 + " ");
計測終了
*end = DateTime.Now;
処理にかかった時間を秒単位で出力
*Console.WriteLine((end - start).TotalSeconds);
string型の配列に1つ1つ格納
*string[] str = Console.ReadLine().Split(' ');
計測開始
*start = DateTime.Now;
配列strのi番目の要素の、
配列strのi番目の要素の文字列の長さ - 1 番目の文字を出力する
*Console.Write(str[i][str[i].Length - 1] + " ");
計測終了
*end = DateTime.Now;
処理にかかった時間を秒単位で出力
*Console.WriteLine((end - start).TotalSeconds);

エラー修正前

AutoBlink.cs
オート目パチスクリプト
2014/06/23 N.Kobayashi

*using UnityEngine;
エラー修正後

AutoBlink.cs
オート目パチスクリプト
2014/06/23 N.Kobayashi

*using UnityEngine;

*private static IEnumerable<;T>; Merge<;T>;(IEnumerable<;T>; a1, IEnumerable<;T>; a2, Comparison<;T>; compare) {if (!a1.Any()) {return a2;} else if (!a2.Any()) {return a1;}var x1 = a1.First();var x2 = a2.First();if (compare(x1, x2) <; 0) {return (new T[] { x1 }).Concat(Merge(a1.Skip(1), a2, compare));} else {return (new T[] { x2 }).Concat(Merge(a1, a2.Skip(1), compare));}}
再帰版　Mergeメソッド
*private static IEnumerable<;T>; Merge<;T>;(IEnumerable<;T>; a1, IEnumerable<;T>; a2, Comparison<;T>; compare) {var ite1 = a1.GetEnumerator();var ite2 = a2.GetEnumerator();var exists1 = ite1.MoveNext();var exists2 = ite2.MoveNext();while (exists1 == true &amp;&amp; exists2 == true) {T x1 = ite1.Current;T x2 = ite2.Current;if (compare(x1, x2) <; 0) {yield return x1;exists1 = ite1.MoveNext();} else {yield return x2;exists2 = ite2.MoveNext();}}while (exists1) {yield return ite1.Current;exists1 = ite1.MoveNext();}while (exists2) {yield return ite2.Current;exists2 = ite2.MoveNext();}}
非再帰版　Mergeメソッド
*class Program {static void Main(string[] args) {Random rnd = new Random();var nums = new int[10000];for (int count = 0; count <; 10; count++) {for (int i = 0; i <; nums.Length; i++) {nums[i] = rnd.Next(1, 10000);}var result = MargeSort.Sort(nums, (a, b) =>; a - b);// LINQのOrderByメソッドの結果と比較することで、MergeSortが正しく整列されているかを確認しているbool isEqual = Enumerable.SequenceEqual(result, nums.OrderBy(n =>; n));Console.WriteLine(isEqual);}Console.ReadLine();}}
MergeSortの検証用コード
LINQのOrderByメソッドの結果と比較することで、MergeSortが正しく整列されているかを確認している
*bool isEqual = Enumerable.SequenceEqual(result, nums.OrderBy(n =>; n));

Cubeの頂点座標
Vector3[] cubeLocalSharedVert = new Vector3[24]; ローカル座標系での頂点座標(ダブりあり)
List&lt;Vector3&gt; cubeLocalVert = new List&lt;Vector3&gt;(); ローカル座標系での頂点座標(ダブりなし)
Vector3[] cubeWorldVert = new Vector3[8]; ワールド座標系での頂点座標
Quadオブジェクトを2つ生成して子オブジェクトとして登録する関数
*public GameObject Cube2Quad(GameObject _parent)
ダブってる頂点を削除する
*cubeLocalVert.Add(cubeLocalSharedVert[0]);
面のインデックスを取得
*int[,] surfaces = new int[6, 4];
*for (int i = 0; i <; cubeLocalVert.Count; ++i)*{
面の取得
*Matrix4x4 matrix = meshFilter.transform.localToWorldMatrix;*for (int i = 0; i ; cubeLocalVert.Count; ++i)
変換行列Get
最も面積の大きい面を探す
*List<;float>; areas = new List<;float>;();
最も面積の大きい二つの面を探す
*int[] indicesOfMaxAreaSurfaces = new int[2];
*for (int i = 0; i <; indicesOfMaxAreaSurfaces.Length; ++i)*{
ローカル座標系でQuadを新しく作成し、ワールド座標変換を行う
どの軸で貼られた面なのかを調べる
*float verticalX = 0f, verticalY = 0f, verticalZ = 0f;
*if (Mathf.Approximately(sign, 1f))*{
x = 0.5 の面の場合
*{newQuadPos[0] = new Vector3(-0.5f, -0.5f, 0.5f);newQuadPos[1] = new Vector3(-0.5f, 0.5f, -0.5f);newQuadPos[2] = new Vector3(-0.5f, -0.5f, -0.5f);newQuadPos[3] = new Vector3(-0.5f, 0.5f, 0.5f);}
x = -0.5 の面の場合
*if (Mathf.Approximately(sign, 1f))*{
y = 0.5 の面の場合
*{newQuadPos[0] = new Vector3(-0.5f, -0.5f, 0.5f);newQuadPos[1] = new Vector3(0.5f, -0.5f, -0.5f);newQuadPos[2] = new Vector3(0.5f, -0.5f, 0.5f);newQuadPos[3] = new Vector3(-0.5f, -0.5f, -0.5f);}
y = -0.5 の面の場合
*if (Mathf.Approximately(sign, 1f))*{
z = 0.5 の面の場合
*{newQuadPos[0] = new Vector3(-0.5f, -0.5f, -0.5f);newQuadPos[1] = new Vector3(0.5f, 0.5f, -0.5f);newQuadPos[2] = new Vector3(0.5f, -0.5f, -0.5f);newQuadPos[3] = new Vector3(-0.5f, 0.5f, -0.5f);}
z = -0.5 の面の場合
ゲームオブジェクトを新規作成
*GameObject quad = GameObject.CreatePrimitive(PrimitiveType.Quad);
Cubeの面をQuadとして定義しなおす
*Mesh mesh = quad.GetComponent<;MeshFilter>;().mesh;
*Transform quadTrans = quad.GetComponent<;Transform>;();*quadTrans.position = matrix.MultiplyPoint(quadTrans.position);
座標変換
マテリアルの引継ぎ
*quad.GetComponent<;Renderer>;().material = gameObject.GetComponent<;Renderer>;().material;

WriteIf: 第一引数が true の場合、メッセージを出力
*int size = 1234;
Assert: 第一引数が false の場合、プログラムを中断してメッセージを出力
*int index = -1;
このメソッドは DEBUG 定数が定義されている時だけ実行される
*[Conditional("DEBUG")]
Debug.WriteLine メソッドの定義
*[ConditionalAttribute("DEBUG")]
Trace.WriteLine メソッドの定義
*[ConditionalAttribute("TRACE")]

なんか
*}
略
*}
*{this.ResizeBegin += (object sender, EventArgs e) =>; { this.isBeingMoved = true; };this.ResizeEnd += (object sender, EventArgs e) =>; { this.isBeingMoved = false; };this.Move += (object sender, EventArgs e) =>;{if(true == this.willBeAdjusted &amp;&amp; this.IsLocationGood()){this.willBeAdjusted = false;this.OnDelayedDpiChanged(new DelayedDpiChangedEventArgs(this.dpiOld, this.wParam_, this.lParam_));}};}
ばっさり省略

*boo = new sampleDelegate(fuga.hello);
これは出来ない

解く問題を初期化(IDisposable対応)
・線形計画法/整数計画法なので"IntegerProgramming"
・ソルバーとしてCoin-or branch and cut(CBC)を使うので"CBC_MIXED_INTEGER_PROGRAMMING"
※ソルバーにGlop(”GLOP_LINEAR_PROGRAMMING”)を指定すると、整数制約が守られないので注意
*using (var solver = Solver.CreateSolver("IntegerProgramming", "CBC_MIXED_INTEGER_PROGRAMMING")) {
*if (solver == null) {*Console.WriteLine("ソルバーを初期化できませんでした。");
初期化できてない場合はnullが返る
最適化の方向を設定する
最大化→SetMaximization、最小化→SetMinimization
*var objective = solver.Objective();
制約式の数・範囲
*var e1 = solver.MakeConstraint(double.NegativeInfinity, 13.5);
変数の数・名前・範囲
実数→MakeNumVar、整数→MakeIntVar、0-1変数→MakeBoolVar
(0-1変数以外だと、下限および上限を指定できる)
なお、MakeVarだと引数で整数制約があるか否かをbool指定できる
*var x = solver.MakeIntVar(0.0, double.PositiveInfinity, "X");
目的関数の係数
*objective.SetCoefficient(x, 5);
制約式の係数
*e1.SetCoefficient(x, 1.5);
最適化
*int resultStatus = solver.Solve();
*if (resultStatus != Solver.OPTIMAL) {Console.WriteLine("ソルバーで解けませんでした。");return;}
結果表示
*if (resultStatus != Solver.OPTIMAL) {*Console.WriteLine("ソルバーで解けませんでした。");
結果の返り値はdoubleなので注意

*Console.WriteLine(date1.AddMonths(1));
4302017 12:00:00 AM
DateTime date2 = new DateTime(2017, 4, 31);   これはエラー
[System.ArgumentOutOfRangeException: Year, Month, and Day parameters describe an un-representable DateTime.]
*,,,

解く問題を初期化(IDisposableではない)
*var solver = new SimplexSolver();
使用する変数のID・制約式のID・目的関数のIDを宣言する
*int x, y, z = 0, e1, e2, e3;
最適化の方向を設定する
AddGoal(目的関数の数値が代入される変数のID, (不明), 最大化するならfalse・最小化するならtrue)
*solver.AddRow("目的関数値", out z);
制約式の数・名前・範囲
*solver.AddRow("条件1", out e1);
変数の数・名前・範囲
SetIntegralityメソッドで整数条件を付与できることがポイント
*solver.AddVariable("X", out x);
目的関数の係数
*solver.SetCoefficient(z, x, 5);
制約式の係数
*solver.SetCoefficient(e1, x, 1.5);
最適化
*solver.Solve(new SimplexSolverParams());
結果表示
GetValueメソッドの返り値はRational型……要するに分数なので、
ToDouble()メソッドでdouble型にすると分かりやすい
*Console.WriteLine($"Z = {solver.GetValue(z).ToDouble()}");

*#endif
UNITY_IOS

*if ( textLength <; 0 ) { return 0; }
overflow

*public int Age { get; set; }
オートプロパティ

*NewSettingParam.CopyTo(PreSettingParam);
最新設定パラメータを前回設定パラメータにコピーする

配列として0チェック(foreach版)
*sum = TimeSpan.Zero;
配列として0チェック(for版)
*sum = TimeSpan.Zero;
IEnumerableとして0チェック
*sum = TimeSpan.Zero;
Enumerable.Anyとして0チェック
*sum = TimeSpan.Zero;
Enumerable.Allとして0チェック
*sum = TimeSpan.Zero;
unchecked下で forで0チェックを行う
*sum = TimeSpan.Zero;
uncheckを使用した上でforで0方向による0チェックを行う
*sum = TimeSpan.Zero;
unsafeを用いて ポインタによる0チェックを行う
*sum = TimeSpan.Zero;
unsafeを用いて long間隔で0チェックを行う
*sum = TimeSpan.Zero;

*ResourceService.Current.ChangeCulture("zh-CN");
上記サンプルでは「中国語」を表す

*{// 処理B}
処理A
処理B
*}
*{// 処理D}
処理C
処理D
*}
計測を終了したい時は、Stop()を実行する
実行しないと、処理時間が大幅に変わってしまうので注意
*mp.Stop()
*{// tに対して何らかの処理if(t.HasChildren){foreach(var child in t.Children){// 再帰的に処理するProcessTiming(child);}}}
計測終了
*if(t.HasChildren)*{
tに対して何らかの処理
再帰的に処理する
*ProcessTiming(child);

*int[] a12345 = { 1, 2, 3, 4, 5 };
単純な循環リスト
*Func<;int>;[] r = { () =>; rnd.Next() };
ランダムな値を返す関数のリストにすればランダムな無限リストが得られる

*+ "YOUR_ACCESSKEY";
アクセスキー
路線情報の取得
*var ekiResult = await client.GetStringAsync(ekiRequest);
停車駅情報を編集
*var stationList = "";

*string str = "Hello\"World";
Hello"World

*web.Navigate($"https:
translate.google.co.jp#{sourceLang}{resultLang}");

SeriesにSlicesをセット
*PieSeries.Slices = Slices;
PlotModelにSeriesを追加
*PlotModel.Series.Add(PieSeries);
リストのソート
*var sortedList = _DonutModel.ItemList
内側のグラフの更新
*_InsidePie.UpdateSlices(sortedList.Select(x =>; new PieSlice(x.Label, x.Value)));
外側のグラフの更新
*_OutsidePie.UpdateSlices(_Categories.Select(x =>; new PieSlice(

保存パス生成
*string executeTime = (DateTime.Now.ToString("yyyy_MMdd_HHmmss_ffff"));
保存するBitmap(handWrite)
*var bitmap = new System.Drawing.Bitmap(
*if (savename == "")*{
fullpathを指定した場合。

*if (list[i].Equals(default(T)) == true)
0の場合は空文字列をセット

*Info("Information");*// Show warning
Show information

*Link google = AbstractFactory.CreateLink("Google", "http:
www.google.com");
実行が一瞬で終わって確認ため、キーの入力を待ちます
*Console.ReadLine();

*{textbox.Text += msg + Environment.NewLine;}
呼び出すメソッドの定義(匿名メソッドを使う場合は不要)
*if (InvokeRequired)*{
マルチスレッドから呼び出す
戻り値がvoidで、引数がstring1個の場合
*Invoke( new Action<;string>;(writeToConsole), "解析終了" );
*{...}
呼び出すメソッドの定義
マルチスレッドから呼び出す
*Invoke( new Action(funcp0) );
*{...}
呼び出すメソッドの定義
マルチスレッドから呼び出す
*Invoke( new Action<;string, int>;(funcp2), "解析終了", 100 );
*{...return 100.0;}
呼び出すメソッドの定義
マルチスレッドから呼び出す
*Invoke( new Action<;string, int, double>;(funcdp2), "50.0", 75 );

*list.RemoveAt(2);
Listの2番目の要素を削除する

*using(GeometrySink geom = result.Open())
usingを追加

*{for (int i = 1; i <; 50000000; i++){sw.WriteLine(i.ToString() + ",いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす");}}
テスト用ファイルを作る
書き込み用のStreamWriterを開く
*Dictionary<;int, StreamWriter>; writer = new Dictionary<;int, StreamWriter>;();
*{while (sr.Peek() >;= 0){string s = sr.ReadLine();writer[Convert.ToInt32(s.Split(',')[0]) % div].WriteLine(s);}}
ここで内容判断、書き込み先の分岐処理を行う
*for (int i = 0; i <; div; i++)*{
忘れずにStreamWriterを閉じる

https:github.com/Microsoft/WindowsTemplateStudio/blob/master/templates/_composition/MVVMBasic/Project/Helpers/Observable.cs から引用
名前空間を修正
*namespace App8.Helpers
*{/// <;summary>;/// それ自体で使用できる空白ページまたはフレーム内に移動できる空白ページ。/// <;/summary>;public sealed partial class MainPage : Page{public ViewModels.MainPageViewModel ViewModel { get; private set; } = new ViewModels.MainPageViewModel();public MainPage(){this.InitializeComponent();ViewModel.Initialize(this);this.DataContext = ViewModel;}}}
空白ページの項目テンプレートについては、https:go.microsoft.com/fwlink/?LinkId=402352&amp;clcid=0x411 を参照してください
https:github.com/Microsoft/WindowsTemplateStudio/blob/master/templates/Projects/Default/Helpers/ResourceExtensions.cs から引用
名前空間を修正
*namespace App8.Helpers

↓が必要!
*Livet.DispatcherHelper.UIDispatcher = Dispatcher;

*{string s;while ((s = source.ReadLine()) != null){yield return s;}}
TextReaderから一行ずつを要素にして返すよ
*{static void Main(string[] args){Console.In.AsLineEnumerable().All(line =>; { Console.WriteLine($"[{line}]"); return true; });}}
実行サンプル(C#6.0以降)

*Array.Resize(ref 顧客, i + 1);
配列のリサイズ。既存値はそのまま。リサイズ直後の値はNull(のようだ)。

*public IReadOnlyReactiveProperty<;string>; SensorMsg { get { return _sensorMsg; } }
説明用のため、細かいところは省略してあります。

*if (string.IsNullOrEmpty(selectcmd))*{
空文字か調べる
*{//データソースを読み込むstring line;try {using (var reader = new StreamReader(_filePath, Encoding.UTF8)){while ((line = reader.ReadLine()) != null){string key;string value;int sepPos = line.IndexOf("-");if (sepPos <; 0){key = line;value = "";}else{key = line.Substring(0, sepPos);value = line.Substring(sepPos + 1);}_TaskDict[key] = value;}}}catch (Exception e){Console.WriteLine("ファイルの読み込みに失敗しました" + e.Message);}}
コンストラクタ
*try {using (var reader = new StreamReader(_filePath, Encoding.UTF8)){while ((line = reader.ReadLine()) != null){string key;string value;int sepPos = line.IndexOf("-");if (sepPos <; 0){key = line;value = "";}else{key = line.Substring(0, sepPos);value = line.Substring(sepPos + 1);}_TaskDict[key] = value;}}}
データソースを読み込む
*{//要素を追加するthis._TaskDict[date] = value;//要素を追加したのでテキストファイルに書き込む//テキストファイルを空にするメソッドを呼び出すRefreshFile(_filePath);//テキストファイルに書き込むメソッドを呼び出すWriteFile(_filePath);}
タスクを追加する
要素を追加する
*this._TaskDict[date] = value;
要素を追加したのでテキストファイルに書き込む
テキストファイルを空にするメソッドを呼び出す
*RefreshFile(_filePath);
テキストファイルに書き込むメソッドを呼び出す
*WriteFile(_filePath);
*{Console.WriteLine("\n-----タスク一覧-----\n");foreach (var task in _TaskDict){Console.WriteLine("{0}：{1}",task.Key,task.Value);}Console.WriteLine("\n--------------------\n");}
タスクを見る
*{if(!_TaskDict.Keys.Contains(value))Console.WriteLine("指定された日付のタスクはありません。");else{_TaskDict.Remove(value);Console.WriteLine(value + "のタスクを削除しました");//テキストファイルを空にするメソッドを呼び出すRefreshFile(_filePath);//テキストファイルに書き込むメソッドを呼び出すWriteFile(_filePath);}}
タスクを削除する
テキストファイルを空にするメソッドを呼び出す
*RefreshFile(_filePath);
テキストファイルに書き込むメソッドを呼び出す
*WriteFile(_filePath);
*{try{File.WriteAllText(filePath, "");}catch (Exception e){Console.WriteLine("ファイルが見つかりませんでした" + e.Message);}}
テキストファイルを空にするメソッド
*{try{using (var writer = new StreamWriter(_filePath, append: true)){foreach (var task in _TaskDict)writer.WriteLine(task.Key + "-" + task.Value);}}catch (Exception e){Console.WriteLine("書き込みに失敗しました" + e.Message);}}
テキストファイルに書き込むメソッド

*if (_uniWebView != null)*{
既に存在している場合は開くだけ
キャッシュのクリア
*webViewObject.OnDestroyAsObservable().Subscribe(_ =>; _uniWebView.CleanCache()).AddTo(webViewObject);
スキームを追加
*_uniWebView.AddUrlScheme("web-view-demo");
*{switch (message.Path){//閉じるボタン押下case "close"://WebViewを非表示にするif (_uniWebView != null) _uniWebView.Hide(true);break;//↑ボタン押下case "up":player.Translate(Vector3.forward);break;//↓ボタン押下case "down":player.Translate(Vector3.down);break;//→ボタン押下case "right":player.Translate(Vector3.right);break;//←ボタン押下case "left":player.Translate(Vector3.left);break;}};
メッセージ受け取りイベント
閉じるボタン押下
*case "close":
*if (_uniWebView != null) _uniWebView.Hide(true);*break;
WebViewを非表示にする
↑ボタン押下
*case "up":
↓ボタン押下
*case "down":
→ボタン押下
*case "right":
←ボタン押下
*case "left":
*{_uniWebView.Frame = new Rect(0, 0, Screen.width, Screen.height);};
画面の向きが変わるたびに解像度を変更
画面サイズを設定
*_uniWebView.Frame = new Rect(0, 0, Screen.width, Screen.height);
背景色
*var color = Color.white;
ツールバー非表示
*_uniWebView.SetShowToolbar(false);
横スクロールバー非表示
*_uniWebView.SetHorizontalScrollBarEnabled(false);
インジケータ
*_uniWebView.SetShowSpinnerWhileLoading(true);
内部保持してるサイトを読み込み
*var exchangeUrl = UniWebViewHelper.StreamingAssetURLForPath(url);
画面表示
*_uniWebView.Show();

*"Using": [ "Serilog.Sinks.File" ],
ファイルに出力
最小ログレベル
*"Default": "Verbose"
拡張
"WithThreadId", スレッドID
"WithThreadName", スレッド名
"WithMachineName", マシン名
"WithEnvironmentUserName", ユーザー名
"WithProcessId", プロセスID
"WithProcessName", プロセス名
"WithAssemblyName", アセンブリ名
"WithAssemblyVersion", アセンブリバージョン
"WithMemoryUsage", メモリ使用量
"WithExceptionDetails" 例外の詳細情報
*],
*"Args": {"configureLogger": {"WriteTo": [{"Name": "File","Args": {//ログファイルパス"path": "Logs/All/Default/all.log",//ログファイルのフォーマット"outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss} | [{Level:u3}] | {ThreadId:00}:{ThreadName} | {ProcessId:00}:{ProcessName} | {Message:lj} | {AssemblyName} | {AssemblyVersion} | {MachineName} | {EnvironmentUserName} | {MemoryUsage} B | {NewLine}{Exception}",//1日毎にロールする"rollingInterval": "Day",//直近の7ファイルを保持する（デフォルトでは直近の31ファイル）"retainedFileCountLimit": 7,//ファイルサイズの制限を削除（デフォルトでは1GB）"fileSizeLimitBytes": null,//書き込みをバッファリングする"buffered": true}}]}}
通常のテキスト形式で、全レベルのログを出力するためのLogger
ログファイルパス
*"path": "Logs/All/Default/all.log",
*"outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss} | [{Level:u3}] | {ThreadId:00}:{ThreadName} | {ProcessId:00}:{ProcessName} | {Message:lj} | {AssemblyName} | {AssemblyVersion} | {MachineName} | {EnvironmentUserName} | {MemoryUsage} B | {NewLine}{Exception}",
ログファイルのフォーマット
1日毎にロールする
*"rollingInterval": "Day",
直近の7ファイルを保持する（デフォルトでは直近の31ファイル）
*"retainedFileCountLimit": 7,
ファイルサイズの制限を削除（デフォルトでは1GB）
*"fileSizeLimitBytes": null,
書き込みをバッファリングする
*"buffered": true
*"Args": {"configureLogger": {"WriteTo": [{"Name": "File","Args": {"path": "Logs/All/Compact/all_compact.json",//JsonFormatter"formatter": "Serilog.Formatting.Compact.CompactJsonFormatter, Serilog.Formatting.Compact","rollingInterval": "Day","retainedFileCountLimit": 7,"fileSizeLimitBytes": null,"buffered": true}}]}}
JSON形式で、全レベルの構造化ログを出力するためのLogger
*"formatter": "Serilog.Formatting.Compact.CompactJsonFormatter, Serilog.Formatting.Compact",*"rollingInterval": "Day",
JsonFormatter
*"Args": {"configureLogger": {"Filter": [{"Name": "ByIncludingOnly","Args": {"expression": "(@Level = 'Error' or @Level = 'Fatal' or @Level = 'Warning')"}}],"WriteTo": [{"Name": "File","Args": {"path": "Logs/Error/Default/error.log","outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss} | [{Level:u3}] | {ThreadId:00}:{ThreadName} | {ProcessId:00}:{ProcessName} | {Message:lj} | {AssemblyName} | {AssemblyVersion} | {MachineName} | {EnvironmentUserName} | {MemoryUsage} B | {NewLine}{Exception}","rollingInterval": "Day","retainedFileCountLimit": 7,"fileSizeLimitBytes": null,"buffered": true}}]}}
通常のテキスト形式で、Warning以上のログを出力するためのLogger
*"Args": {"configureLogger": {"Filter": [{"Name": "ByIncludingOnly","Args": {"expression": "(@Level = 'Error' or @Level = 'Fatal' or @Level = 'Warning')"}}],"WriteTo": [{"Name": "File","Args": {"path": "Logs/Error/Compact/error_compact.json","formatter": "Serilog.Formatting.Compact.CompactJsonFormatter, Serilog.Formatting.Compact","rollingInterval": "Day","retainedFileCountLimit": 7,"fileSizeLimitBytes": null,"buffered": true}}]}}
JSON形式で、Warning以上の構造化ログを出力するためのLogger

*reader.Close();
&lt;------一旦クローズ!!!
2回目----------------------------------------------------------------------
*command.CommandText = "select 氏名, 所属 from ユーザマスタ where 社員番号 = '456456'";

*Contract.Result<;int<;() <;= 0
事後条件

*{ClientId = ConfigurationManager.AppSettings["CLIENT_ID"],Password = user.Password,Username = user.Name,};
リクエストオブジェクト生成
リザルトオブジェクト取得
*var signUpResult = await _client.SignUpAsync(signUpRequest);
*{AccessToken = authResp.AuthenticationResult.AccessToken};
AccessTokenを元にUser名を取得

ウィンドウの特定 - バリエーション4つ
1. 最前面にあるウィンドウ
*var main = WindowControl.FromZTop(_app);
*main = WindowControl.IdentifyFromTypeFullName(_app, "WpfApplication.MainWindow");*main = WindowControl.IdentifyFromWindowText(_app, "Friendly Handson");
2, 3. ウィンドウ情報を基に特定する - MainWindow.xamlに記載されている
4. 現在操作中のアプリケーションのメインウィンドウ
*var mainWindowCore = _app.Type<;Application>;().Current.MainWindow;
タブの特定
logicalツリー：xamlファイルの木構造を取得する
*var logicalMain = main.LogicalTree();
AppVar =&gt; コントロールオブジェクトそのもの
オブジェクトのポインタのようなものが入っているイメージ
*AppVar tabCore = logicalMain.ByType<;TabControl>;().Single();
タブの操作
*tab.EmulateChangeSelectedIndex(1);
以下、テキストボックスの特定、コンボボックスの特定 と続いたが、ここでは省略
*.

*if(list.Skip(n - 1).Any() &amp;&amp; !list.Skip(n).Any())*{
n=1の時は　list.Any() &amp;&amp; !list.Skip(n).Any()でもOK

*{ViewData["msg"] = "こんにちは！ MVC頑張ろう！";return View();}
GET: Hello

とりあえずTextパラメータは必須
*param["Text"] = "hogehoge message";

*AssetDatabase.Refresh ();
アセットDBの更新

初期化ベクトル            ----- (4)
*const string AesIV = @"<;半角16文字（1byte=8bit, 8bit*16=128bit>;";
暗号化鍵
*const string AesKey = @"<;半角32文字（8bit*32文字=256bit）>;";
暗号化方式はAES           ----- (1)
*AesManaged aes = new AesManaged();
鍵の長さ                  ----- (2)
*aes.KeySize = 256;
ブロックサイズ（何文字単位で処理するか）
*aes.BlockSize = 128;
暗号利用モード             ----- (3)
*aes.Mode = CipherMode.CBC;
パディング                 ----- (5)
*aes.Padding = PaddingMode.PKCS7;
暗号化するためにはバイトの配列に変換する必要がある
*byte[] byteText = Encoding.UTF8.GetBytes(text);
*byte[] encryptText = aes.CreateEncryptor().TransformFinalBlock(byteText, 0, byteText.Length);*// Base64形式（64種類の英数字で表現）で返す
暗号化
Base64形式（64種類の英数字で表現）で返す
*return Convert.ToBase64String(encryptText);
*Console.WriteLine("暗号化後の文字列:{0}", encryptStr);
暗号化

*var str = await new HttpClient().GetStringAsync("http:
hogehoge.com");

値
*string val = prop.GetValue(obj).ToString();
DisplayName属性取得
*DisplayNameAttribute dispNameAttr = Attribute.GetCustomAttribute(prop, typeof(DisplayNameAttribute)) as DisplayNameAttribute;
StringLength属性取得
*StringLengthAttribute lenAttr = Attribute.GetCustomAttribute(prop, typeof(StringLengthAttribute)) as StringLengthAttribute;
Required属性取得
*RequiredAttribute reqAttr = Attribute.GetCustomAttribute(prop, typeof(RequiredAttribute)) as RequiredAttribute;
*if (lenAttr != null &amp;&amp; val.Length >; lenAttr.MaximumLength)*{
↓チェック処理
ID(123456)は最大桁数5桁を超えています。
なまえは必須項目です。
*,,,

*private void SendFunc(int[] SendedData){
相手が送ってきたときに自動的に発動
相手から来たデータを自分の受け皿に上書き保存
*}

①-1デザインファイル名を指定します。
*cellReport1.FileName = @"C:\Book1.xlsx";
①-2帳票ドキュメントの作成を開始します。
*cellReport1.Report.Start();
①-3帳票の作成を開始します。
*cellReport1.Report.File();
②-1デザインシートを指定します。
*cellReport1.Page.Start("Sheet1", "1");
②-2セルに値を設定します。
*cellReport1.Cell("A1").Value = "VB-Reportのサンプル";
②-3ページ処理を終了します。
*cellReport1.Page.End();
③-1帳票ドキュメント作成を終了します。
*cellReport1.Report.End();
③-2作成した帳票ドキュメントをビューアに設定します。
*viewerControl1.Document = cellReport1.Document;
請求リストを読み込みます。
*doc.Load(@"見積書リスト.xml");
日付
*cellReport1.Cell("**Date").Value = DateTime.Now;
見積有効日
*cellReport1.Cell("**EndDate").Value = (double)DateTime.Now.ToOADate() + 7;
見積書番号
*cellReport1.Cell("**Mitsumori").Value = node.SelectSingleNode("./見積書番号").InnerText;
会社名
*string officename = node.SelectSingleNode("./会社名").InnerText;
部署名
*string sectionname = node.SelectSingleNode("./部署名").InnerText;
お客様名
*cellReport1.Cell("**UserName").Value = node.SelectSingleNode("./お客様名").InnerText + " 様";
郵便番号
*cellReport1.Cell("**Post").Value = "〒" + node.SelectSingleNode("./郵便番号").InnerText;
住所県
*cellReport1.Cell("**Address1").Value = node.SelectSingleNode("./住所県").InnerText;
住所その他
*cellReport1.Cell("**Address2").Value = node.SelectSingleNode("./住所その他").InnerText;
商品一覧
*int y = 0;
一括割引対象品と除外品を判断するためのフラグ("1"→"0"に変更した時点で割引額の表示)
*string discount = "";
一括割引対象品でなくなった時点で、割引額を求める
全て割引除外品の場合、計算を行わない
*if ((discount == "0") &amp;&amp; (discountPrev == "1"))
*if (totalSeikyu >;= 1000000)*{
合計額(税抜き)が、100万未満の場合、一括割引を行わない。
商品名
*cellReport1.Cell("**Shouhin", 0, y).Value = node2.SelectSingleNode("./商品名").InnerText;
数量
*int unitNumber = Convert.ToInt32(node2.SelectSingleNode("./数量").InnerText);
単価
*int unitPrice = Convert.ToInt32(node2.SelectSingleNode("./単価").InnerText);
金額
*int totalPrice = unitNumber * unitPrice;
備考
*cellReport1.Cell("**Biko", 0, y).Value = node2.SelectSingleNode("./備考").InnerText;
税抜
*cellReport1.Cell("**Zeinuki").Value = totalSeikyu;
消費税
*int tax = (int)(totalSeikyu * 0.05);
税込
*cellReport1.Cell("**Zeikomi").Value = totalSeikyu + tax;

*Debug.WriteLine($"Start Action: Token = {token}");
アクションが実行される前の処理
*Debug.WriteLine("End Action: Token = {token}");
アクションが実行された後の処理

*}
このブロックを抜けたらcommand 、conn はDisposeされます。
メソッドの定義 ここまで---------------------------------↑
*}

Lottie用に追加
*using Lottie.Forms.iOS.Renderers;
Lottie用に追加
*AnimationViewRenderer.Init();

*if(!IsOpen(gpio))*{
gpioがオープン済みでない場合のみ
2番ピンが開いていない場合はOpenします。
*GpioOperationHelper.Open(2);
信号を出力方向に設定します。。
*GpioOperationHelper.SetDirection(2, GpioDirection.Out);
*{//とりあえず10回ON/OFFforeach(var i in Enumerable.Range(1,10)){//トグルさせてみる。if (GpioOperationHelper.GetValue(2) == 1){Console.WriteLine("Off");GpioOperationHelper.SetValue(2, 0);}else{Console.WriteLine("On");GpioOperationHelper.SetValue(2, 1);}//0.5秒ごとにチカチカ！await Task.Delay(500);}});
Lチカタスクを作成します。
*foreach(var i in Enumerable.Range(1,10))*{
とりあえず10回ON/OFF
*if (GpioOperationHelper.GetValue(2) == 1)*{
トグルさせてみる。
0.5秒ごとにチカチカ！
*await Task.Delay(500);
タスクを実行し、完了を待機します。
*task.Wait();

*xmlns:materialDesign="http:
materialdesigninxaml.netwinfxxamlthemes"
ComboBoxのClearButtonを取得します
*Button genderComboBoxclearButton = GenderComboBox.Template.FindName("PART_ClearButton", GenderComboBox) as Button;
*ScaleTransform st = new ScaleTransform(0.75,0.75);*genderComboBoxclearButton.RenderTransform = st;
ComboBoxのClearButtonの大きさを少し小さめにします
ComboBoxのClearButtonの表示位置を調整します
*genderComboBoxclearButton.Padding = new System.Windows.Thickness(2, 4, -5, -4);

ログファイルにプロセス番号も出力できるようにする
*int pid = System.Diagnostics.Process.GetCurrentProcess().Id;
出力するログファイル名を動的に変更するため設定されているFileAppenderを取得する
*const string APPENDER_NAME = "test1";
ファイル名を「MyLog_{YYYYMMDD}_{pid}.log」の形式に置き換え、変更前のファイルを削除する
*string file = fileAppender.File;

Console.WriteLine($"SpecialFoo : {((SpecialFoo)specialFoo).GetSome()}");   コンパイル不可
*:

*} else {
タッチされていない場合→スティックを元の位置に戻す
*//m_MouseLook.LookRotation (transform, m_Camera.transform);*}
↓↓↓FPSCameraControllerの回転と衝突するのでコメントアウト

*var agg = new AggregateCatalog(assm, extensions);
2つのカタログをマージしたカタログを作成する
ex.Value.Execute();  拡張機能クラスのインスタンスは作成しない
*}

*private int _writeIndex = -1;
書き終わった位置

*.ObservesProperty(() =<; Flag);
ObservesPropertyでFlagを監視するよう指定する

モックの生成
*var fooMock = Substitute.For<;Foo>;();
戻り値を設定
*fooMock.GetBaz().Returns("baz");
メソッドが呼ばれたかどうかをテスト
*fooMock.Received().GetBaz();

何かしらの初期化処理を実行
*_isInited = true;

*public ushort UshortVal { get; set; } = 0xabcd;
組み込み型

ListenするIPアドレスを決める
*string host = "localhost";
Listenするポート番号
*int port = xxxx;
TcpListenerオブジェクトの生成
*System.Net.Sockets.TcpListener listener
*Console.WriteLine("Listenを開始しました({0}:{1})。",
Listenを開始する
*Console.WriteLine("クライアント({0}:{1})と接続しました。",
接続要求があったら受け入れる
NetworkStream取得
*System.Net.Sockets.NetworkStream ns = client.GetStream();
クライアントから送られたデータを受信する
*System.Text.Encoding enc = System.Text.Encoding.UTF8;
データの一部を受信する
*int resSize = ns.Read(resBytes, 0, resBytes.Length);
*if (resSize == 0)*{
Readが0を返した時はクライアントが接続したと判断
受信したデータを蓄積する
*ms.Write(resBytes, 0, resSize);
受信したデータを文字列に変換
*resMsg = enc.GetString(ms.ToArray());
クライアントにデータを送信する
クライアントに送信する文字列を作成
*string sendMsg = resMsg.ToString();
文字列をByte型配列に置換
*byte[] sendBytes = enc.GetBytes(sendMsg);
データを送信する
*ns.Write(sendBytes, 0, sendBytes.Length);
閉じる
*ns.Close();
リスナを閉じる
*listener.Stop();

*PerformSegue("MyNamedSegue", this);*,,,
Display the Scene defined by the given Segue ID
*switch (segue.Identifier) {*case "MyNamedSegue":
Take action based on Segue ID

*//    values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },
"/Account/ConfirmEmail",
*//    values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },
pageHandler: null,
*//    $"Please confirm your account by <;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>;clicking here<;/a>;.");
protocol: Request.Scheme);
*//    $"Please confirm your account by <;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>;clicking here<;/a>;.");
await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",
*if (_userManager.Options.SignIn.RequireConfirmedAccount)*{
$"Please confirm your account by &lt;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'&gt;clicking here&lt;/a&gt;.");
支給額
*[Display(Name = "支給額")]
*[DisplayFormat(DataFormatString = "{0:#,##0.#}", ApplyFormatInEditMode = true)]
↓これをつけると3桁カンマあり小数0埋めなしになる

*var result = await client.GetStringAsync("http:
weather.livedoor.comforecastwebservicejsonv1?city=" + cityId);
API 取得したデータをデコードして WeatherModel に取得
*result = Uri.UnescapeDataString(result);
タイトル作成
*var titleColumnSet = new ColumnSet();
本文作成
天気情報をセット
*var mainColumnSet = new ColumnSet();
*if (selectedDay == "Today" &amp;&amp; forcast.dateLabel != "今日")*{
Todayが取得出来ている場合は、dateLabel = "今日" の場合のみセット (=else の操作を行う)
*string day = forcast.dateLabel;*string date = DateTime.Parse(forcast.date).Date.ToString("M/d");
天気データの取得と加工
temperature が null の場合は "--" に変換
*string maxTemp, minTemp;
*AddTextBlock(mainColumn, $"{day}({date})", TextSize.Large, HorizontalAlignment.Center);AddTextBlock(mainColumn, $"{maxTemp} / {minTemp} °C", TextSize.Medium, HorizontalAlignment.Center);AddImage(mainColumn, forcast.image.url, ImageSize.Medium, HorizontalAlignment.Center);}}}
データのセット

集約
*private List<;Piyo>; m_piyos = new List<;Piyo>;();
チェックが必要ならば、この辺でする。
車とタイヤの例ならば、「車」クラスが「走行中」状態のときにAddされないようにガードするとか。
*m_piyos.Add(piyo);
Addと同じく、チェックが必要ならば、この辺でする。
*return m_piyos.Remove(piyo);
特になし
*}
コンポジション
*private List<;Piyo>; m_piyos = new List<;Piyo>;();
Disposeなど、削除に必要なものを実装
*}

*int[][] array = { new int[]{ 1, 2, }, new int[] { 3, 4 } };
{1, 2, 3, 4}

*sw.WriteLine($"
{dicItemName[x.Item2]}");
土のブロック
*case TileID.Dirt:
石のブロック
*case TileID.Stone:

*public DbSet<;HogeModel>; HogeHogeModel { get; set; }
こいつを元にTableが作られる
DBの中身を空にするらしい
*Database.EnsureDeleted();
DbSetを元にTableを作るらしい
*Database.EnsureCreated();
DBのパスを入れよう
*optionsBuilder.UseSqlite(@"Data Source='hoge\hoge.db'");
こんなん初見でわかるわけないやろ
*SQLitePCL.Batteries_V2.Init();

*new EndpointAddress("net.pipe:
localhostHogeSearchService")).CreateChannel()

*[Commands("hello")]
コマンドとして使用する文字列をアトリビュートで設定

*{input = gameObject.GetComponent<;LocalHandInput>;();_initializePos = gameObject.transform.localPosition;material = new Material(Shader.Find("Diffuse"));gameObject.GetComponent<;Renderer>;().material = material;}
Use this for initialization
*{//if Hand is lost,this gameobject's color is become Red.material.color = InputSources.Instance.hands.GetHandState(input.Handedness, input.MinConfidence) == null ? Color.red : new Color(.4f,.4f,1f);gameObject.transform.position = _initializePos + input.LocalPosition;}
Update is called once per frame

RenderTextureからTexture2Dに変換します
*var leftTex = leftCam.targetTexture;
*for (int y = 0; y <; mainTexture.height; y++) {*if (y % 2 == 0) {
偶数回目にmainTextureのy行目に左目の画像を入れ，y+1行目に右目の画像を入れます
ここでfor文との行ずれを調整するために別に用意した変数の値を1ずつ加算します
*count = count + 1;

*private void CutTask() {Task.Run(() =>; {if (semaphore1.CurrentCount == 0) {System.Threading.Interlocked.Increment(ref count_x);semaphore2.Release();semaphore1.Release();}semaphore1.Wait();semaphore2.Wait();if (count_x >; 0) {System.Threading.Interlocked.Decrement(ref count_x);return;}HeavyProcess();semaphore2.Release();semaphore1.Release();});}
--------------------

*.SelectMany(d =<; Directory.EnumerateFiles(d))
戻り値 IEnumerable&lt;string&gt;　（ファイルのリスト）

*Console.WriteLine("Doing!");
Doing! の位置で評価タイミングがわかる！違いに注意

*//foreach版-----------------------------------------------*//結果を格納する変数を作成する。
&lt;Scoreの合計を抽出します&gt;
foreach版-----------------------------------------------
結果を格納する変数を作成する。
*int ret1 = 0;
値を足していく。
*ret1 += m.Score;
Linq版--------------------------------------------------
メンバー表の中からスコアだけを射影し、合計する。
*var ret2 = members.Select(x =>; x.Score).Sum();
*Console.WriteLine($"foreach:{ret1}, Linq:{ret2}");*}
表示する------------------------------------------------
Linq版--------------------------------------------------
メンバー表の中からスコアの合計を求めます。
*var ret2 = members.Sum(x =>; x.Score);
*//foreach版-----------------------------------------------*//結果を格納する変数を作成する。
&lt;男の数をカウントします&gt;
foreach版-----------------------------------------------
結果を格納する変数を作成する。
*int ret1 = 0;
男性の場合はカウントアップ
*ret1++;
Linq版--------------------------------------------------
membersの中で性別が男性の個数を返します。
*var ret2 = members.Count(x =>; x.Sex == "男");
*Console.WriteLine($"foreach:{ret1}, Linq:{ret2}");*}
表示する------------------------------------------------
*//foreach版-----------------------------------------------*//計算用の合計値
&lt;Ageの平均値を集計します。&gt;
foreach版-----------------------------------------------
計算用の合計値
*double sum = 0;
計算用の件数
*int count = 0;
合計値と件数をカウントアップ
*sum += m.Age;
平均値を算出する
*double ret1 = sum / count;
Linq版--------------------------------------------------
membersの年齢の平均値を算出する
*var ret2 = members.Average(x =>; x.Age);
*Console.WriteLine($"foreach:{ret1}, Linq:{ret2}");*}
表示する------------------------------------------------
*//foreach版-----------------------------------------------*//最大値を格納する変数
&lt;Scoreの最大値を集計します。&gt;
foreach版-----------------------------------------------
最大値を格納する変数
*int ret1 = 0;
ret1の値を超える値が出てきた場合は値を更新
*ret1 = mem.Score;
Linq版--------------------------------------------------
membersの中でScoreが最大のものを抽出
*var ret2 = members.Max(x =>; x.Score);
*Console.WriteLine($"foreach:{ret1}, Linq:{ret2}");*}
表示する------------------------------------------------
*//foreach版-----------------------------------------------*//最小値を格納する変数に、int型の上限値を入れて初期化
&lt;Scoreの最小値を集計します。&gt;
foreach版-----------------------------------------------
最小値を格納する変数に、int型の上限値を入れて初期化
*int ret1 = int.MaxValue;
*if (mem.Score <; ret1)*ret1 = mem.Score;
ret1の値よりも小さい値が出てきた場合は値を更新
Linq版--------------------------------------------------
membersの中でスコアが最小のものを抽出
*var ret2 = members.Min(x =>; x.Score);
*Console.WriteLine($"foreach:{ret1}, Linq:{ret2}");*}
表示する------------------------------------------------
*//foreach版-----------------------------------------------*//積算合計を保持する変数
&lt;Scoreの積算を取得する&gt;
foreach版-----------------------------------------------
積算合計を保持する変数
*int ret1 = 1;
値を積算していく。
*ret1 = ret1 * mem.Score;
Linq版--------------------------------------------------
memberのScoreを順次積算していく。
*var ret2 = members.Aggregate(1,(n, next) =>; n * next.Score);
*Console.WriteLine($"foreach:{ret1}, Linq:{ret2}");*}
表示する------------------------------------------------
*//for版-----------------------------------------------*//最高スコア
&lt;最高スコアの人を名前付きで出力する&gt;
for版-----------------------------------------------
最高スコア
*int maxScore = 0;
リスト検索用インデックス
*int index = 0;
*if (members[i].Score >; maxScore)*{
MAXを求める。
最大値が見つかったら更新し、インデックスを保持。
*maxScore = members[i].Score;
Linq版--------------------------------------------------
membersの中からスコアが最大のものを取得し、名前と一緒に表示する
*var ret2 = members.Aggregate(members.First(),
スコア最大を求める
*(max, next) =>; max.Score <; next.Score ? next : max,
*x =>; $"最高点 : {x.Score}点 / {x.Name }");
表示結果を作成する
*Console.WriteLine($"foreach:{ret1}\nLinq:{ret2}");*}
表示する

*string url = "https:
" + customerId + ".ods.opinsights.azure.comapilogs?api-version=2016-04-01";

*var MonsterList = new List<;Monster<;();
モンスターを格納するリスト
リストに生成したモンスターのインスタンスを追加
*MonsterList.Add(new Monster());
Randomクラスからランダム値を生成
HP値が最大100になるように範囲を設定
*int randomValue = rd.Next(97);
ランダム値の分だけ「|」を生成してAddHPに追加
*AddHP = AddHP + "|";
出力
*WriteLine("Moster" + Convert.ToString(RoopCount) + "HP:" +

読み込み
*}
保存
*}
読み込み
*}
保存
*}

各列のリストを初期化
*var sample = new List<;List<;string>;>;();
*for (int i = 0; i <; str.Count; i++)*{
1行をカンマで分割し、それぞれのリストに追加していく
*for (int i = 0; i <; length; i++)*{
表示
*x =>; x.Split(',').Where(word =>; !string.IsNullOrWhiteSpace(word)).Select((word, i) =>; new { word, i }));
1行をカンマで分割して、0からインデックスを追加
全ての行を平坦化して、先ほど追加したインデックスでグループ化する.
*var oneColumnData = strWithIndex.SelectMany(word =>; word).ToLookup(x =>; x.i);

*<;add key="AuthenticationUri" value="https:
westus.api.cognitive.microsoft.comstsv1.0issueToken" &gt;
Custom Speech ServiceのEndpointページに書かれたSubscription Key
*this.SubscriptionKey,
Custom Speech ServiceのサブのKey Azureポータルをみるとわかる。ただ上のSubscription Keyと同じでも動く
*this.SubscriptionKey,
Custom Speech ServiceのEndpointページに書かれたWebSocket for LongDictation mode
"https:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.api.cris.ai/ws/cris/speech/recognize/continuous"
*);

TODO ここに実装方法を記述
例：app.configから取得　定数クラスから取得等
*return token;
TODO ここにイベント内容を記載
以下サンプル
*await this.ReplyTextMessageSampleEvent( channelAccessToken , replyToken , "追加されました" );

*raise(Unit);
Sends an event to itself

*Console.WriteLine(result);
p@5k#2Az

*var weatherResult = await client.GetStringAsync("http:
weather.livedoor.comforecastwebservicejsonv1?city=140010");
API 取得したデータをデコードして WeatherModel に取得
*weatherResult = Uri.UnescapeDataString(weatherResult);
返答メッセージを作成
*var message = context.MakeMessage();
天気を取得
*WeatherModel weather = await GetWeatherAsync();
message.Text = $"今日の天気は {weather.forecasts[0].telop.ToString()} です";
取得した天気情報をカードにセット
*var weatherCard = GetCard(weather);
返答メッセージをPost
*await context.PostAsync(message);
タイトル作成
*var titleColumnSet = new ColumnSet();
本文作成
天気情報をセット
*var mainColumnSet = new ColumnSet();
天気アイコンをセット
*var mainImage = new AdaptiveCards.Image();
タイトル作成
*var titleColumnSet = new ColumnSet();
本文作成
天気情報をセット
*var mainColumnSet = new ColumnSet();
天気データの取得と加工
*string day = item.dateLabel;
temperature が null の場合は "--" に変換
*string maxTemp, minTemp;
*AddTextBlock(mainColumn, $"{day}({ date})", TextSize.Large, HorizontalAlignment.Center);
データのセット

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

*private const string WindowsManagementUri = "https:
management.core.windows.net";

*{XmlSerializer xs = new XmlSerializer(typeof(Product));StringWriter sw = new StringWriter();xs.Serialize(sw, item);serializedData = sw.ToString();}
Serialize
*{XmlSerializer xs = new XmlSerializer(typeof(Product));Product deserilizedObject = xs.Deserialize(new StringReader(serializedData)) as Product;}
Deserialize
*{BinaryFormatter bf = new BinaryFormatter();MemoryStream mem = new MemoryStream();bf.Serialize(mem, item);serializedData = mem.ToArray();}
Serialize
*{BinaryFormatter bf = new BinaryFormatter();MemoryStream mem = new MemoryStream(serializedData);Product deserilizedObject = bf.Deserialize(mem) as Product;}
Deserialize
*{JavaScriptSerializer js = new JavaScriptSerializer();serializedData = js.Serialize(item);}
Serialize
*{JavaScriptSerializer js = new JavaScriptSerializer();Product deserilizedObject = js.Deserialize<;Product>;(serializedData);}
Deserialize
*{DataContractSerializer ds = new DataContractSerializer(typeof(Product));MemoryStream mem = new MemoryStream();ds.WriteObject(mem, item);serializedData = mem.ToArray();}
Serialize
*{DataContractSerializer bf = new DataContractSerializer(typeof(Product));MemoryStream mem = new MemoryStream(serializedData);Product deserilizedObject = bf.ReadObject(mem) as Product;}
Deserialize
*{DataContractJsonSerializer ds = new DataContractJsonSerializer(typeof(Product));MemoryStream mem = new MemoryStream();ds.WriteObject(mem, item);serializedData = mem.ToArray();}
Serialize
*{DataContractJsonSerializer bf = new DataContractJsonSerializer(typeof(Product));MemoryStream mem = new MemoryStream(serializedData);Product deserilizedObject = bf.ReadObject(mem) as Product;}
Deserialize

----------------- 問題1--------------------
*Question1();
*var datas = new[] { "水本", "椎名", "中野" };
input datas
*// ----------------- foreach版--------------------*// ----------------- Linq版--------------------
ここに処理を追加してみて
----------------- foreach版--------------------
----------------- Linq版--------------------
*return;
----------------- 問題1--------------------
*Question1();
*var datas = new[] { "水本", "椎名", "中野" };
input datas
*//do something(foreach)*// 結果を受け取るリストを用意
----------------- foreach版--------------------
*var forResultDatas = new List<;string>;();*// ちゃん付けしてリストに入れる
結果を受け取るリストを用意
*foreach (var data in datas)*forResultDatas.Add(data + "ちゃん");
ちゃん付けしてリストに入れる
*foreach (var forResultData in forResultDatas)*Console.WriteLine(forResultData);
ちゃん付けで表示
----------------- Linq版--------------------
do something(LINQ)
ちゃん付けした列挙を取得
*var linqResultDatas = datas.Select(x =>; x + "ちゃん");
ちゃん付けで表示
output datas
*foreach (var linqResultData in linqResultDatas)
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
*Question2();
*var datas = new[] { "うづき", "りん", "みお", "みく", "なお" };
input datas
*// ----------------- foreach版--------------------*// ----------------- Linq版--------------------
ここに処理を追加してみて
----------------- foreach版--------------------
----------------- Linq版--------------------
*return;
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
*Question2();
*var datas = new[] { "うづき", "りん", "みお", "みく", "なお" };
input datas
*//do something(foreach)*// 結果を受け取るリストを用意
----------------- foreach版--------------------
*var forResultDatas = new List<;string>;();*foreach (var data in datas)
結果を受け取るリストを用意
*if (data.EndsWith("お"))*forResultDatas.Add(data);
末尾が"お"のdataをListに入れる
*foreach (var forResultData in forResultDatas)*Console.WriteLine(forResultData);
文字列の末尾が"お"のデータを表示
----------------- Linq版--------------------
do something(LINQ)
文字列の末尾が"お"の列挙を取得
*var linqResultDatas = datas.Where(x =>; x.EndsWith("お"));
*foreach (var linqResultData in linqResultDatas)*Console.WriteLine(linqResultData);
文字列の末尾が"お"のデータを表示
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
Question2();
----------------- 問題3--------------------
引数は４パターン試してね！
完全一致パターン
*var ret3a = Question3("りん");
*foreach (var a in ret3a)*Console.Write(a);
表示
前方一致パターン
*var ret3b = Question3("み%");
*foreach (var b in ret3b)*Console.Write(b);
表示
後方一致パターン
*var ret3c = Question3("%お");
*foreach (var c in ret3c)*Console.Write(c);
表示
部分一致パターン
*var ret3d = Question3("%づき%");
*foreach (var d in ret3d)*Console.Write(d);
表示
*var datas = new[] { "うづき", "りん", "みお", "みく", "なお" };
data sources
ここに処理を追加してみて
*return null;
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
Question2();
----------------- 問題3--------------------
引数は４パターン試してね！
完全一致パターン
*var ret3a = Question3("りん");
*foreach (var a in ret3a)*Console.Write(a);
表示
前方一致パターン
*var ret3b = Question3("み%");
*foreach (var b in ret3b)*Console.Write(b);
表示
後方一致パターン
*var ret3c = Question3("%お");
*foreach (var c in ret3c)*Console.Write(c);
表示
部分一致パターン
*var ret3d = Question3("%づき%");
*foreach (var d in ret3d)*Console.Write(d);
表示
*var datas = new[] { "うづき", "りん", "みお", "みく", "なお" };
data sources
部分一致
一文字目が%かつ末尾が%の場合
*if (value.StartsWith("%") &amp;&amp; value.EndsWith("%"))
valueから%を除いたものとdatasの中に存在してるのが一致してる列挙を取得
*var partMatchedCase = datas.Where(a =>; a.Contains(value.Trim('%')));
前方一致
末尾が%の場合
*else if (value.EndsWith("%"))
*var forwardMatchedCase = datas.Where(b =>; b.StartsWith(value.Trim('%')));*foreach (var matchedB in forwardMatchedCase)
valueから%を除いたものとdatasの中に存在してる一文字目が一致してる列挙を取得
後方一致
一文字目が%の場合
*else if (value.StartsWith("%"))
valueから%を除いたものとdatasの中に存在してる末尾が一致してる列挙を取得
*var backMatchedCase = datas.Where(c =>; c.EndsWith(value.Trim('%')));
完全一致
それ以外
*else
valueとdatasの中に存在してる文字列が一致してる列挙を取得
*var matchedCase = datas.Where(d =>; d.Equals(value));
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
Question2();
----------------- 問題3--------------------
引数は４パターン試してね！
完全一致パターン
var ret3a = Question3("りん");
表示
foreach (var a in ret3a)
Console.Write(a);
前方一致パターン
var ret3b = Question3("み%");
表示
foreach (var b in ret3b)
Console.Write(b);
後方一致パターン
var ret3c = Question3("%お");
表示
foreach (var c in ret3c)
Console.Write(c);
部分一致パターン
var ret3d = Question3("%づき%");
表示
foreach (var d in ret3d)
Console.Write(d);
----------------- 問題4--------------------
列挙を作るよ
*IEnumerable<;string>; cute = new[] { "まゆ", "ちえり", "ゆかり", "きょうこ", "さえ" };
分割した列挙を入れるよ
*var ret4a = Divide(cute, 2);
*foreach (var r in ret4a)*Console.WriteLine(string.Join(",", r));
表示
ここに処理を追加してみて
*return null;
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
Question2();
----------------- 問題3--------------------
引数は４パターン試してね！
完全一致パターン
var ret3a = Question3("りん");
表示
foreach (var a in ret3a)
Console.Write(a);
前方一致パターン
var ret3b = Question3("み%");
表示
foreach (var b in ret3b)
Console.Write(b);
後方一致パターン
var ret3c = Question3("%お");
表示
foreach (var c in ret3c)
Console.Write(c);
部分一致パターン
var ret3d = Question3("%づき%");
表示
foreach (var d in ret3d)
Console.Write(d);
Console.WriteLine();
----------------- 問題4--------------------
列挙を作るよ
*IEnumerable<;string>; cute = new[] { "まゆ", "ちえり", "ゆかり", "きょうこ", "さえ" };
分割した列挙を入れるよ
*var ret4a = Divide(cute, 2);
*foreach (var r in ret4a)*Console.WriteLine(string.Join(",", r));
表示
*while (datas.Any())*{
datesがある間ループ
valueの分だけデータを貰って
*yield return datas.Take(value);
valueの分だけスキップ
*datas = datas.Skip(value);
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
Question2();
----------------- 問題3--------------------
引数は４パターン試してね！
完全一致パターン
var ret3a = Question3("りん");
表示
foreach (var a in ret3a)
Console.Write(a);
前方一致パターン
var ret3b = Question3("み%");
表示
foreach (var b in ret3b)
Console.Write(b);
後方一致パターン
var ret3c = Question3("%お");
表示
foreach (var c in ret3c)
Console.Write(c);
部分一致パターン
var ret3d = Question3("%づき%");
表示
foreach (var d in ret3d)
Console.Write(d);
Console.WriteLine();
----------------- 問題4--------------------
列挙を作るよ
IEnumerable&lt;string&gt; cute = new[] { "まゆ", "ちえり", "ゆかり", "きょうこ", "さえ" };
分割した列挙を入れるよ
var ret4a = Divide(cute, 2);
表示
foreach (var r in ret4a)
Console.WriteLine(string.Join(",", r));
----------------- 問題5--------------------
LiPPS ?　をてきとーな数に分けてくれー！
*var LiPPS = new[] { "しき", "しゅうこ", "かなで", "高田純次", "みか" };
*foreach (var r in LiPPS)*Console.WriteLine(string.Join(",", r));
表示
作ったDivideを
①Extensionsクラスに切り出して、IEnumerableの拡張メソッドにする
②ジェネリック（&lt;T&gt;）型に対応させ、string以外の型でも処理できるようにする
返却する最後の列挙数が指定したvalue数に満たない場合、
切り捨てを行う処理を追加する。
（例えば、前回の例でいうと{"さえ"}の個数は指定したvalue（２個）に満たないので、
切り捨てることとする）
*public static IEnumerable<;IEnumerable<;T>;>; Divide<;T>;(this IEnumerable<;T>; datas, int value)
ここに処理を書いて
*return null;
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
Question2();
----------------- 問題3--------------------
引数は４パターン試してね！
完全一致パターン
var ret3a = Question3("りん");
表示
foreach (var a in ret3a)
Console.Write(a);
前方一致パターン
var ret3b = Question3("み%");
表示
foreach (var b in ret3b)
Console.Write(b);
後方一致パターン
var ret3c = Question3("%お");
表示
foreach (var c in ret3c)
Console.Write(c);
部分一致パターン
var ret3d = Question3("%づき%");
表示
foreach (var d in ret3d)
Console.Write(d);
Console.WriteLine();
----------------- 問題4--------------------
列挙を作るよ
IEnumerable&lt;string&gt; cute = new[] { "まゆ", "ちえり", "ゆかり", "きょうこ", "さえ" };
分割した列挙を入れるよ
var ret4a = Divide(cute, 2);
表示
foreach (var r in ret4a)
Console.WriteLine(string.Join(",", r));
----------------- 問題5--------------------
LiPPS ?　わぁお！ここで拡張メソッド呼べちゃう！
.Divide(3)っていうのもわかりやすい！
*var LiPPS = new[] { "しき", "しゅうこ", "かなで", "高田純次", "みか" }.Divide(3);
*foreach (var r in LiPPS)*Console.WriteLine(string.Join(",", r));
表示
作ったDivideを
Extensionsクラスに切り出して、IEnumerableの拡張メソッドにする
ジェネリック（&lt;T&gt;）型に対応させ、string以外の型でも処理できるようにする
返却する最後の列挙数が指定したvalue数に満たない場合、
切り捨てを行う処理を追加する。
（例えば、今回の例でいうと{"さえ"}の個数は指定したvalue（２個）に満たないので、
切り捨てることとする)
*public static IEnumerable<;IEnumerable<;T>;>; Divide<;T>;(this IEnumerable<;T>; datas, int value)
そもそも分割するdatasが無いのはおかしくね？
Exceptionを出して、使った人に告知してあげようかな
*throw new ArgumentNullException();
*if (!datas.Any())*yield break;
要素が無いとbreak
value分だけをyield return
*yield return datas.Take(value);
*foreach (var s in datas.Skip(value).Divide(value))*// きちんと分割できるか判定
上の処理でTakeした分だけSkipしたものから再帰して自分REST@RT
*if (value == s.Count())*// 分割したものを各自yield return
きちんと分割できるか判定
分割したものを各自yield return
*yield return s;

Mutex名を決める ■■■ 必ずアプリケーション固有の文字列に変更すること！ ■■■
*string mutexName = "MyApp";
Mutexオブジェクトを作成する
*bool createdNew;
*if (createdNew == false)*{
ミューテックスの初期所有権が付与されたか調べる
されなかった場合は、すでに起動していると判断して終了
*MessageBox.Show("多重起動はできません。");
はじめからMainメソッドにあったコードを実行
*Application.EnableVisualStyles();
ミューテックスを解放する
*mutex.ReleaseMutex();

異体字一覧（辞書）を取得する
*var vari = Dictionaly.GetDictionaly();
*foreach (char c in word)*{
文字列を1文字ずつに分割して処理する
文字が異体字リストにあれば、異体字を取得する。
ex. 浜 →  [浜|濵|濱]
*var f = vari.FirstOrDefault(x =>; x.Key == c.ToString());
*if (f.Key != null)*{
[]で囲む
結果を返す
*return result;
regStringsが検索ワード（[浜|濵|濱][崎|隑|陭|徛|﨑|㟢|碕|埼|嵜]）等
*var query = from c in db.Entity

*mesh.triangles = verticesIndex;
四角ポリゴンなのでtriangleを使うべきなのかは謎。

*Task<;string<; dl3 = hc.GetStringAsync("https:
www.microsoft.comen-us");
すべてのダウンロード完了を待つ
*await Task.WhenAll(dl1, dl2, dl3);

非UIスレッドでAddListenerしたものをUIスレッドでRemoveListener → 削除されない
*CollectionChangedEventManager.RemoveListener(collection, listener1);
UIスレッドでAddListenerしたものを非UIスレッドでRemoveListener → 削除されない
*Task.Run(() =>; CollectionChangedEventManager.RemoveListener(collection, listener2)).Wait();
非UIスレッドでAddListenerしたものを非UIスレッドでRemoveListener → 削除されるかもしれないしされないかもしれない
*Task.Run(() =>; CollectionChangedEventManager.RemoveListener(collection, listener3)).Wait();

*Console.WriteLine($"Eternal Loop: {DateTime.Now}");
if (ct.IsCancellationRequested) { return; }
*Console.WriteLine($"Eternal Loop: {DateTime.Now}");
if (ct.IsCancellationRequested) { return; }

非同期で行いたい処理を記述
*});
非同期で行いたい処理を記述
*});
同期させた後に書きたい処理を書く
*}

戻り値
*var entities = new List<;TEntity>;();
Getアクセッサ デリゲートキャッシュ
*var getterDelegateItems = new Dictionary<;int, Func<;TModel, object>;>;();
Setアクセッサ デリゲートキャッシュ
*var setterDelegateItems = new Dictionary<;int, Action<;TEntity, object>;>;();
Getアクセッサ デリゲート
*Func<;TModel, object>; getter = null;
Setアクセッサ デリゲート
*Action<;TEntity, object>; setter = null;
設定対象プロパティリスト
*var entityTargetProps = new List<;PropertyInfo>;();
TEntityプロパティリスト ディクショナリ(パフォーマンス対策)
*var entityProps = typeof(TEntity).GetProperties().Where(a =>; a.CanWrite).ToDictionary(a =>; a.Name);
TModel プロパティリスト
*var modelProps = typeof(TModel).GetProperties().Where(a =>; a.CanRead);
設定対象プロパティを抽出
*PropertyInfo entityProp = null;
*if (entityProps.TryGetValue(modelProp.Name, out entityProp) &amp;&amp; entityProp.PropertyType == modelProp.PropertyType)*{
TEntityプロパティリストに TModelプロパティと同一の名前で存在する、且つ、型が完全一致する場合
設定対象プロパティに追加
*entityTargetProps.Add(entityProp);
*foreach (var item in items)*{
プロパティ設定
設定先TEntity
*var entity = new TEntity();
*foreach (var setProp in entityTargetProps)*{
設定対象プロパティ
*if (!getterDelegateItems.TryGetValue(setProp.MetadataToken, out getter))*{
キャッシュされていないかどうかを判定し、未キャッシュの場合は生成
Getアクセッサ デリゲートを生成
*getter = CreateGetDelegate<;TModel>;(setProp.Name);
生成したGetデリゲートをキャッシュ
*getterDelegateItems.Add(setProp.MetadataToken, getter);
Setアクセッサ デリゲートを生成
*setter = CreateSetDelegate<;TEntity>;(setProp.Name);
生成したSetデリゲートをキャッシュ
*setterDelegateItems.Add(setProp.MetadataToken, setter);
プロパティ値を取得
*var val = getter(item);
プロパティ値を設定
*setter(entity, val);

*// query allWeatherForecasts {//   allWeatherForecasts {//     nodes {//       id//       dt//       temperatureC//       summary//     }//   }// }
クエリー
*//   allWeatherForecasts {//     nodes {//       id//       dt//       temperatureC//       summary//     }//   }
query allWeatherForecasts {
*//     nodes {//       id//       dt//       temperatureC//       summary//     }
allWeatherForecasts {
*{public int Id { get; set; }public DateTime Dt { get; set; }private double _tempC;public double TemperatureC{get{return _tempC;}set{_tempC = value;}}public double TemperatureF{get{return 32 + (_tempC / 0.5556);}set{_tempC = (value - 32) * 0.5556;}}public string Summary { get; set; }public WeatherForecast(){Dt = DateTime.Now.Date;}}
}
*// {//   "data": {//     "allWeatherForecasts": {//       "nodes": [//         {//           "id": 1,//           "dt": "2000-01-01",//           "temperatureC": 7,//           "summary": "Hot"//         },//         {//           "id": 2,//           "dt": "2000-01-02",//           "temperatureC": -16,//           "summary": "Cool"//         },////         （中略）////       ]//     }//   }// }
レスポンス例
*//   "data": {//     "allWeatherForecasts": {//       "nodes": [//         {//           "id": 1,//           "dt": "2000-01-01",//           "temperatureC": 7,//           "summary": "Hot"//         },//         {//           "id": 2,//           "dt": "2000-01-02",//           "temperatureC": -16,//           "summary": "Cool"//         },////         （中略）////       ]//     }//   }
{
*//     "allWeatherForecasts": {//       "nodes": [//         {//           "id": 1,//           "dt": "2000-01-01",//           "temperatureC": 7,//           "summary": "Hot"//         },//         {//           "id": 2,//           "dt": "2000-01-02",//           "temperatureC": -16,//           "summary": "Cool"//         },////         （中略）////       ]//     }
"data": {
*//         {//           "id": 1,//           "dt": "2000-01-01",//           "temperatureC": 7,//           "summary": "Hot"//         },
"allWeatherForecasts": {
*//         {//           "id": 1,//           "dt": "2000-01-01",//           "temperatureC": 7,//           "summary": "Hot"//         },
"nodes": [
*//         {//           "id": 2,//           "dt": "2000-01-02",//           "temperatureC": -16,//           "summary": "Cool"//         },
"summary": "Hot"
*//         {//           "id": 2,//           "dt": "2000-01-02",//           "temperatureC": -16,//           "summary": "Cool"//         },
},
（中略）

]
}
}
}
*public class AllWeatherForecastsResponse
行儀が良くないですが、今回はここにGraphQLエンドポイントのURLを書いてしまいます
private const string graphql_http = "http:192.168.1.7/15000/graphql";
*public async Task<;List<;WeatherForecast>;>; GetForecastListAsync()
*//{//    未実装//}
public async Task UpdateForecastAsync(WeatherForecast forecastToUpdate)
未実装
}
public async Task DeleteForecastAsync(WeatherForecast forecastToRemove)
{
未実装
}
public async Task InsertForecastAsync(WeatherForecast forecastToInsert)
{
未実装
}
*}

*sign = sign * -1;
signをトグルさせる

*var foo = helper.GetSecret<;Foo<;();
型情報から、データを取得して、値を詰めて返す。

*sb.Length = 0;
これで前回編集していた文字列がクリアされて、新しい編集が開始できる。
なんか文字列編集する処理
*string text = sb.ToString();

*var baseUrl = "https:
abc.vault.azure.net";

*if (!fileText.Any())*{
データがなければ終了

*var helper =  new KeyVaultHelper(keyVaultClientMock.Object, "https:
abc.vault.azure.net");

*var secretIdentifier = "https:
spikekey.vault.azure.netsecretsSomeSecret";

*private void Imprison(Kusogaki k, TimeOfCrime e)
書き換え

*ServicePointManager.Expect100Continue = false;
HTTPエラー(417)対応

*.Where( s =<; !s.StartsWith("
") )
もうちょっとカッコイイ実装（JavaのCDIみたいな）にしたかったけど、paiza用なんでこれで良いよね。
*PaizaUtility.IO = new TestData();
【サンプル実装】ヘッダパーサを独自に指定するパターン。
ヘッダで２種類のデータ数が指定され、
それらが連続したデータ行として与えられる、みたいなケースを想定。
（実際にそんな問題があるのかどうかは知らん）
*int a = 0;
二種類のデータ数をそれぞれ控える。
*a = token[0];
二種類のデータの合計数を返す（読み込み行数）
*return a + b;
ヘッダのパーサを指定して ReadArgs を呼び出す。
*var args = PaizaUtility.ReadArgs( parser ).ToList();

*productMock.Verify(product =<; product.GetContent("http:
www.microsoft.com"));

*GlobalConfiguration.Configure(WebApiConfig.Register);
ルーティングの処理などを書く

*using ObjCRuntime;
現在のテンプレートには含まれません
*public override NSObject RepresentedObject {get {return base.RepresentedObject;}set {base.RepresentedObject = value;// Update the view, if already loaded.}}
Do any additional setup after loading the view.
*ClickedLabel.StringValue = string.Format("The button has been clicked {0} time{1}.",++numberOfTimesClicked, (numberOfTimesClicked <; 2) ? "" : "s");
Update counter and label

*if (Input.GetKeyDown("tab"))*{
スペースキーを押したら話しかける
話しかけられる状態かつプレイヤーが生きていたら話しかける
*Talk(GetTalkableObject());

ファイルのパス
*string filePath = "【CSVファイルが置いているフォルダ】/Oita.csv";
*{try{//ファイルを読み込みで開くSystem.IO.StreamReader sr = new System.IO.StreamReader(filePath);//一時ファイルを作成するstring tmpPath = System.IO.Path.GetTempFileName();//一時ファイルを書き込みで開くSystem.IO.StreamWriter sw = new System.IO.StreamWriter(tmpPath);//書き込む用の変数string writeLine = "";//内容を一行ずつ読み込むwhile (sr.Peek() >; -1){//一行読み込むstring line = sr.ReadLine();int len = line.Length;//true → 読み飛ばす(continue) / false →CSV書換え処理if(isCheckWords(line)){continue;}int output;bool flag = Int32.TryParse(line, out output);if (flag){if("1" == line){writeLine += line;}else{System.Text.StringBuilder sb = new System.Text.StringBuilder(writeLine);string pr = sb.ToString();sw.WriteLine(pr);writeLine = "";writeLine += line;}}else{writeLine += "," + line;}}//閉じるsr.Close();sw.Close();//一時ファイルと入れ替えるSystem.IO.File.Copy(tmpPath, filePath, true);System.IO.File.Delete(tmpPath);}catch (System.Exception e){// ファイルを開くのに失敗したときSystem.Console.WriteLine(e.Message);}}
CSV書換え
ファイルを読み込みで開く
*System.IO.StreamReader sr = new System.IO.StreamReader(filePath);
一時ファイルを作成する
*string tmpPath = System.IO.Path.GetTempFileName();
一時ファイルを書き込みで開く
*System.IO.StreamWriter sw = new System.IO.StreamWriter(tmpPath);
書き込む用の変数
*string writeLine = "";
*while (sr.Peek() >; -1)*{
内容を一行ずつ読み込む
一行読み込む
*string line = sr.ReadLine();
*if(isCheckWords(line))*{
true → 読み飛ばす(continue) / false →CSV書換え処理
閉じる
*sr.Close();
一時ファイルと入れ替える
*System.IO.File.Copy(tmpPath, filePath, true);
ファイルを開くのに失敗したとき
*System.Console.WriteLine(e.Message);
*private bool isCheckWords(String line){if (line.Contains("市町村名") ||line.Contains("避難施設一覧") ||line.Contains("市町村名") ||line.Contains("/") ||line.Contains("町丁目名") ||line.Contains("名称") ||line.Contains("整理") ||line.Contains("別添") ||line.Contains("機密")){//必要ないワードのため読み飛ばす処理（continue）に進むreturn true;}else{//必要なワードのためCSVに書き込む処理に進むreturn false;}}
C避難所が書いていない行以外は無視する
*}else{
必要ないワードのため読み飛ばす処理（continue）に進む
必要なワードのためCSVに書き込む処理に進む
*return false;

*using (var command = scope.Resolve<;Command<;())
ここでエラーになる

*public Command(IBackend backend)
Command に IBackend を Injection する書き方

*var url = "http:
www.data.jma.go.jpobdstatsdatamdrrtem_rctalltablemxtemsadext00_rct.csv";

*Debug.Log(transform.position);
ここだとOK

csv データが行毎に Foo クラスに格納され、IEnumerable&lt;Foo&gt; として
records に割り当てられます。
*var records = csv.GetRecords<;Foo>;();
*foreach(var i in records)*{
records は IEnumerable なので、こんな使い方ができます。
読み取ったヘッダが小文字に変換されるように ToLower() を仕込みます。
*PrepareHeaderForMatch = args =>; args.Header.ToLower(),
csv データが行毎に Foo クラスに格納され、IEnumerable&lt;Foo&gt; として
records に割り当てられます。
*var records = csv.GetRecords<;Foo>;();
*foreach(var i in records)*{
records は IEnumerable なので、こんな使い方ができます。
クラスマップを使って読み込み順序を指定します
*csv.Context.RegisterClassMap<;FooMap>;();
csv データが行毎に Foo クラスに格納され、IEnumerable&lt;Foo&gt; として
records に割り当てられます。
*var records = csv.GetRecords<;Foo>;();
*foreach(var i in records)*{
records は IEnumerable なので、こんな使い方ができます。
読み込み開始準備を行います
*csv.Read();
ヘッダを読み込みます
*csv.ReadHeader();
*while (csv.Read())*{
行毎に読み込みと処理を行います
この１行で保存ができる
*csv.WriteRecords(records);
ヘッダを出力しないように指定
*HasHeaderRecord = false,

GCの実行
*GC.Collect();
ファイナライズ(後述)の完了を待つ
*GC.WaitForPendingFinalizers();
ファイナライズで参照されなくなったオブジェクトを開放
*GC.Collect();
確保したリソースを開放する処理
*Console.WriteLine("Dispose");
確保したアンマネージリソースを開放する処理
*Console.WriteLine("Finalize");
*{public SuppressFinalize(){GC.SuppressFinalize(this);}~SuppressFinalize(){Console.WriteLine("このメッセージは出力されない");}}
超ナンセンスなクラス
マネージリソースの開放
*}
アンマネージリソースの開放
*disposed = true;
IOExceptionが発生するかも
*sw = new StreamWriter(file);
Exception が発生してもしなくても Dispoose() は呼びたい
*sw?.Dispose();

*[HttpGet("{id}")]
GET api/values/5
*[HttpPut("{id}")]
PUT api/values/5
*[HttpDelete("{id}")]
DELETE api/values/5

フィールド
*private string name;
バッキングフィールド
*private int id;
*{// getアクセサget { return id; }// setアクセサ// valueはプロパティに代入された値set { id = value; }}
プロパティ
*get { return id; }
getアクセサ
*set { id = value; }
setアクセサ
*set { id = value; }
valueはプロパティに代入された値
*// {//     ....// }
プロパティは内部的には以下のようになる。
*// {//     ....// }
public 戻り値 プロパティ名
バッキングフィールド
*private int id;
*{// getアクセサ// public とは書いていないけど public である。get { return id; }// setアクセサ// valueはプロパティに代入された値private set { id = value; }}
プロパティ
*get { return id; }
getアクセサ
*get { return id; }
public とは書いていないけど public である。
*private set { id = value; }
setアクセサ
*private set { id = value; }
valueはプロパティに代入された値
*public int ID { get; private set; }
プロパティ
*// public int ID { get; private set; } = 100;
内部ではデータを変更したい場合、以下のように書く。
*{public virtual int MyProperty{get{return MyProperty + 100;}}}
基底クラス
*{public override int MyProperty{get{return MyProperty + 200;}}}
サブクラス

*var test = nodes.Item(0).InnerText;
この様な形でテーブル名を取得可能

*var cmdline = $"-parentHWND {GetWallpaperHWND()}";
子ウィンドウとして起動

dbを使った処理
db.Database.Connection.Close();   Closeを明記している
*}

*public static IEnumerable<;T[]>; Enumerate<;T>;(IEnumerable<;T>; items) {var original = items.ToArray();foreach (var element in Permutation.Enumerate(items, items.Count(), false)) {bool isComplete = element.Zip(original, (a, b) =>; a.Equals(b)).All(x =>; x == false);if (isComplete)yield return element;}}
攪乱順列（完全順列ともいう）を列挙する

*Assert.AreEqual("期待するログメッセージ", logMessage);
受け取ったログメッセージで期待値検証する

*url: new Uri("https:
www.noraneko.co.jpvoice.xml"));

遷移先から戻ってきたときの処理
*}

ミューテックスクラスのインスタンス生成
*_Mutex = new System.Threading.Mutex(false,"SubProcess");
*if (_Mutex.WaitOne(0, false) == false)*return true;
Mutexの所有権を要求
プロセスを取得
*string AppName = Process.GetCurrentProcess().MainModule.FileName;
*if (ProcessFlg)*return true;
起動済ならreturn

*//Console.WriteLine("id: {0} name: {1} category: {2} price: {3}", info.Id, info.Name, info.Category, info.Price);
var serializer = new DataContractJsonSerializer(typeof(Product));
*//Console.WriteLine("id: {0} name: {1} category: {2} price: {3}", info.Id, info.Name, info.Category, info.Price);
var info = (Product)serializer.ReadObject(resStream);

*string html = wc.DownloadString("http:
www.microsoft.com");
www.microsoft.com の応答が遅くてもウィンドウが固まらない。
Task(async/await) を使うとダウンロード処理をUIスレッドではない別のスレッドで実行してくれる。
*private async void button1_Click(object sender, EventArgs e)
WebClient.DownloadStringTaskAsync() の戻り値の型は Task&lt;string&gt;
await キーワードを付けると Task の完了を待つと同時に string 型に変換してくれる。
Task の完了を待っている間、UIスレッドはブロックされない（ウィンドウは固まらない）。
string html = await wc.DownloadStringTaskAsync("http:www.microsoft.com/");
*textBox1.Text = html;
テキストボックスに入力された数値が素数かどうかを表示する。
入力された数値が非常に大きい場合、
計算に時間がかかりUIスレッドがブロックされてしまうので
Task.Run()を使って別スレッドに処理させる。
*bool isPrime = await Task.Run(() =>;
ダウンロードしたWebコンテンツからリンクURLを抜き出して表示する。
ダウンロードとスクレイピングには時間がかかる可能性がある。
ダウンロードが終わったらスクレイピング処理を実行させたい。
Task&lt;string&gt; downloadTask = new WebClient().DownloadStringTaskAsync("https:msdn.microsoft.com/ja-jp/library/dd460693(v=vs.110).aspx");
*Task<;string>; scrapingTask = downloadTask.ContinueWith(dlTask =>;
*{int num = 1000000;List<;int>; oddNumbers = new List<;int>;();Parallel.For(0, num, i =>;{if (i % 2 == 1) oddNumbers.Add(i);});Console.WriteLine($"List: {num}以下の奇数は{oddNumbers.Count}個です。");}
マルチコアCPUなPCで実行すると毎回結果が変わる不思議なプログラム
*{int num = 1000000;ConcurrentBag<;int>; oddNumbers = new ConcurrentBag<;int>;();Parallel.For(0, num, i =>;{if (i % 2 == 1) oddNumbers.Add(i);});Console.WriteLine($"ConcurrentBag: {num}以下の奇数は{oddNumbers.Count}個です。");}
毎回正確な結果が得られる安全なプログラム。

*public bool PartialMactch { get; set; }
部分一致
*{ManagementObjectSearcher mos = new ManagementObjectSearcher();mos.Query.QueryString = QueryString;var moc = mos.Get();return moc.Count >; 0;}
接続されてるか確認
*{ManagementObjectSearcher mos = new ManagementObjectSearcher();var check = new System.Text.RegularExpressions.Regex("(COM[1-9][0-9]?[0-9]?)");mos.Query.QueryString = QueryString;var moc = mos.Get();foreach(var m in moc){string value = m.GetPropertyValue("Name") as string;if(value == null){continue;}if (check.IsMatch(value)){var match = check.Match(value);return match.Captures[0].Value;}}return null;}
ポート番号取得

*{Print($"Before await. Thread Id: {Thread.CurrentThread.ManagedThreadId}");var task = MethodAsync();// 結果待ちをするためにスレッドをロックして他のスレッドから触れなくしてしまう。task.Wait();Print($"After wait. Thread Id: {Thread.CurrentThread.ManagedThreadId}");}
awaitを使っていないのでasync不要。
*Print($"After wait. Thread Id: {Thread.CurrentThread.ManagedThreadId}");
結果待ちをするためにスレッドをロックして他のスレッドから触れなくしてしまう。
*await Task.Run(() =>; Print($"In task run. Thread Id: {Thread.CurrentThread.ManagedThreadId}"));
処理終了後に元のスレッドに戻そうとするが、元のスレッドがTask.Wait()によりロックされており戻せない。
*{Print($"Before await. Thread Id: {Thread.CurrentThread.ManagedThreadId}");var task = MethodAsync();// 結果待ちをするためにスレッドをロックして他のスレッドから触れなくしてしまう。task.Wait();Print($"After wait. Thread Id: {Thread.CurrentThread.ManagedThreadId}");}
awaitを使っていないのでasync不要。
*Print($"After wait. Thread Id: {Thread.CurrentThread.ManagedThreadId}");
結果待ちをするためにスレッドをロックして他のスレッドから触れなくしてしまう。
*Print($"After configure await. Thread Id: {Thread.CurrentThread.ManagedThreadId}");
ConfigureAwait(false)の後なのでメインスレッドに戻らず実行される。
*await Task.Run(() =>; Print($"In task run. Thread Id: {Thread.CurrentThread.ManagedThreadId}"));
SynchronizationContext.Currentをnullに設定する。ここではメインスレッドに対して設定している。

*}
Disposeは勝手にやってくれるらしいです。

.aseのバイナリを取得
*byte[] bin = ToBinary(ase);
RGBの個数の取得
*int colorCount = bin[11];
RGB値を取り出していく
*int pos = 40;

*this.Items.Add(new BaseNode());
ダミーノードの追加
*{Console.WriteLine(e.Source + "：" + e.Message);}
アクセス拒否、ディレクトリ・ファイルが見つからないエラーをスキップ
選択中Itemの始点設定
*var selectedItemStartingPoint = (Point)(selectedItem.PointToScreen(new Point(0.0d, 0.0d)) - treeView.PointToScreen(new Point(0.0d, 0.0d)));
選択中Itemの終点設定
*var selectedItemEndPoint = new Point(selectedItemStartingPoint.X + selectedItem.ActualWidth, selectedItemStartingPoint.Y + selectedItem.ActualHeight);
*if (inRange(mousePosition, selectedItemStartingPoint, selectedItemEndPoint))*{
選択中のItem内でダブルクリックが発生したならCommand実行
コンストラクタ内
*C_Load.Subscribe(x =>; Load(x as TreeView));
処理
*}

*[FunctionName("EchoExec")]
Point 4

使うAPIによってURLが変わる
var url = "https:westus.api.cognitive.microsoft.com/emotion/v1.0/recognize";
*byte[] bytes = texture.EncodeToPNG ();
*var headers = new Dictionary<;string, string>; () {{"Ocp-Apim-Subscription-Key", [取得したAPI_KEYを入力してください]},{"Content-Type", "application/octet-stream"}};
ヘッダはだいたい固定
JSON形式でくるので適当にデータクラスに突っ込む
*var request = new EntityEmoteModel ();
*if(callback != null)*callback (request);
データを返す

*private const string LOG_FORMAT = "{0:000} {1:00000}";
ミリ秒３桁 linenumber５桁想定

*User = "moge@example.com"
G Suiteの管理者アカウントを設定する。このアカウントが実行したことになる
*{HttpClientInitializer = credential,ApplicationName = "Calendar API Sample",});
Create the service.
ドメイン内のカレンダーを取得
*var cal = service.Calendars.Get("piyo@example.com").Execute();
*{Summary = "APIからのテストスケジュール",Start = new EventDateTime(){DateTime = new DateTime(2017, 7, 10, 12, 0, 0)},End = new EventDateTime(){DateTime = new DateTime(2017, 7, 10, 13, 0, 0)},Description = "詳細"};
ドメイン内のカレンダーに予定を作成

初期値指定
*PenSize = 10;
ペンのスタイル指定
*PenStyleChanged();
*{//太さWidth = PenSize,//高さHeight = PenSize,//形状StylusTip = PenStyle == true ? StylusTip.Ellipse : StylusTip.Rectangle,//色Color = Colors.Green,//滑らかな線（ギザギザするのでTrue推奨）FitToCurve = true,//蛍光ペン（背景画像の上に色を置くのでTrue推奨）IsHighlighter = true};
DrawingAttributesの指定
太さ
*Width = PenSize,
高さ
*Height = PenSize,
形状
*StylusTip = PenStyle == true ? StylusTip.Ellipse : StylusTip.Rectangle,
色
*Color = Colors.Green,
滑らかな線（ギザギザするのでTrue推奨）
*FitToCurve = true,
蛍光ペン（背景画像の上に色を置くのでTrue推奨）
*IsHighlighter = true
拡張子を取得する
*string extension = System.IO.Path.GetExtension(dlgSave.FileName).ToUpper();
ストロークが描画されている境界を取得
*Rect rectBounds = inkCanvas.Strokes.GetBounds();
描画先を作成
*DrawingVisual drawingVisual = new DrawingVisual();
描画エリアを作成
*context.DrawRectangle(inkCanvas.Background, null, rect);
ビットマップに変換
*RenderTargetBitmap rtb = new RenderTargetBitmap((int)rect.Width, (int)rect.Height, 96, 96, PixelFormats.Default);
ビットマップエンコーダー変数の宣言
*BitmapEncoder enc = new PngBitmapEncoder();
ビットマップフレームを作成してエンコーダーにフレームを追加する
*enc.Frames.Add(BitmapFrame.Create(rtb));
ファイルに書き込む
*System.IO.Stream stream = System.IO.File.Create(dlgSave.FileName);
現在のストロークをクリア
*inkCanvas.Strokes.Clear();

メンバ変数
*private string appPath;
*{//パスの取得this.appPath = System.Windows.Forms.Application.ExecutablePath;//ディレクトリthis.appDir = System.IO.Path.GetDirectoryName(this.appPath);//ファイル名this.appName = System.IO.Path.GetFileName(this.appPath);//ファイル名(拡張子含まず)this.appNameWoExt = System.IO.Path.ChangeExtension(this.appName, null);//設定ファイル名this.confFileName = System.IO.Path.ChangeExtension(this.appPath, ".conf");//バージョンSystem.Diagnostics.FileVersionInfo ver_info = System.Diagnostics.FileVersionInfo.GetVersionInfo(System.Reflection.Assembly.GetExecutingAssembly().Location);if (ver_info == null){this.appVer = "0.0";this.appVerFull = "0.0.0.0";}else{this.appVer =ver_info.FileMajorPart+ "." + ver_info.FileMinorPart+ "." + ver_info.FileBuildPart+ "." + ver_info.FilePrivatePart;this.appVerFull = ver_info.FileVersion;}//タイトルバーthis.Text = this.appNameWoExt + " ver." + this.appVer;//------------------------------//設定//設定をロードthis.mySettings = new AppSettings();this.mySettings = (AppSettings)this.mySettings.loadSettings(this.confFileName);if (this.mySettings == null){this.mySettings = new AppSettings();}//最小サイズthis.MinimumSize = this.Size;//設定を反映this.mySettings.SetWinStat(this);//------------------------------this.updateCtrl = true;//----------//----------this.updateCtrl = false;//------------------------------this.ctrlEnable();}
フォーム Load イベントハンドラ
パスの取得
*this.appPath = System.Windows.Forms.Application.ExecutablePath;
ディレクトリ
*this.appDir = System.IO.Path.GetDirectoryName(this.appPath);
ファイル名
*this.appName = System.IO.Path.GetFileName(this.appPath);
ファイル名(拡張子含まず)
*this.appNameWoExt = System.IO.Path.ChangeExtension(this.appName, null);
設定ファイル名
*this.confFileName = System.IO.Path.ChangeExtension(this.appPath, ".conf");
バージョン
*System.Diagnostics.FileVersionInfo ver_info = System.Diagnostics.FileVersionInfo.GetVersionInfo(System.Reflection.Assembly.GetExecutingAssembly().Location);
タイトルバー
*this.Text = this.appNameWoExt + " ver." + this.appVer;
設定
設定をロード
*this.mySettings = new AppSettings();
最小サイズ
*this.MinimumSize = this.Size;
設定を反映
*this.mySettings.SetWinStat(this);
*{//ウインドウ状態の取得this.mySettings.GetWinStat(this);//保存this.mySettings.saveSettings(this.confFileName);}
フォーム FromClosing イベントハンドラ
ウインドウ状態の取得
*this.mySettings.GetWinStat(this);
保存
*this.mySettings.saveSettings(this.confFileName);
*{}
メソッド

IPアドレス
*string addr_ip;
ホスト名を取得
*string hostname = System.Net.Dns.GetHostName();
ホスト名からIPアドレスを取得
*System.Net.IPAddress[] addr_arr = System.Net.Dns.GetHostAddresses(hostname);
探す
*addr_ip = "";
*if ( addr_str.IndexOf( "." ) >; 0 &amp;&amp; !addr_str.StartsWith( "127." ) )*{
IPv4 &amp;&amp; localhostでない

参考
C#.NET Tips
http:codepanic.itigo.jp/cs/listbox_select_right.html
注意
コンテキストメニューを割り当てていると、右クリック時 MouseUp イベントが発生しない。
この場合、MouseUp イベントハンドラ内で、自前でコンテキストメニューを表示させる。

というようなことが参考記事には書かれていたが、
VS2015community では、コンテキストメニューを割り当てても、MouseUp イベント発生した。
コントロール名
リストボックス ... listBox1
コンテキストメニュー ... contextMenuStrip1
============================================================
リストボックスの MouseUp イベントハンドラ
*void listBox1_MouseUp(object sender, MouseEventArgs e)
*if(e.Button == System.Windows.Forms.MouseButtons.Right)*{
右クリックされた？
マウス座標から選択すべきアイテムのインデックスを取得
*int index = listBox1.IndexFromPoint(e.Location);
*if(index >;= 0)*{
インデックスが取得できたら
すべての選択状態を解除してから
*listBox1.ClearSelected();
アイテムを選択
*listBox1.SelectedIndex = index;
コンテキストメニューを表示
Point pos = listBox1.PointToScreen(e.Location);
contextMenuStrip1.Show(pos);
*}

参考
フォームのサイズを制限する .NET Tips C#, VB.NET
http:dobon.net/vb/dotnet/form/minimumsize.html
============================================================
フォームの Load イベントハンドラ
*this.MinimumSize = this.Size;
フォームの幅や高さ固定
*[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
フォームの範囲を取得
*RECT rect = (RECT)System.Runtime.InteropServices.Marshal.PtrToStructure(m.LParam, typeof(RECT));
*if (rect.Right - rect.Left >; this.MinimumSize.Width)*{
幅を固定
*//if (rect.Bottom - rect.Top >; this.MinimumSize.Height)*//{
高さを固定
*//{//  rect.Bottom = rect.Top + this.MinimumSize.Height;//}
if (rect.Bottom - rect.Top &gt; this.MinimumSize.Height)
フォームの範囲を設定
*System.Runtime.InteropServices.Marshal.StructureToPtr(rect, m.LParam, true);

*{//Xxxのドラッグ＆ドロップを許可this.Xxx.AllowDrop = true;}
フォームのLoadイベントハンドラ
Xxxのドラッグ＆ドロップを許可
*this.Xxx.AllowDrop = true;
*{if (e.Data.GetDataPresent(DataFormats.FileDrop)){e.Effect = DragDropEffects.Copy;}else{e.Effect = DragDropEffects.None;}}
DragEnterイベントハンドラ
*{if (e.Data.GetDataPresent(DataFormats.FileDrop)){string[] file_arr = (string[])(e.Data.GetData(DataFormats.FileDrop));//■file_arrを使った処理■}}
DragDropイベントハンドラ
■file_arrを使った処理■
*}

参考
C#で文字列式を演算する
http:www.infortec.co.jp/blog/archives/Item_710
============================================================
using
*using System.Data;
*{using (DataTable dt = new DataTable()){s = string.Format(s, args);object result = dt.Compute(s, "");var converter = TypeDescriptor.GetConverter(typeof(T));return (T)converter.ConvertFromString(result.ToString());}}
通常のメソッドで使用
呼び出し
*string exp1 = "(2.5 + 1.5) * 3";
*{public static T Calc<;T>;(this string s, params object[] args){using (DataTable dt = new DataTable()){s = string.Format(s, args);object result = dt.Compute(s, "");var converter = TypeDescriptor.GetConverter(typeof(T));return (T)converter.ConvertFromString(result.ToString());}}}
string型の拡張メソッドで使用
呼び出し
*string exp1 = "(2.5 + 1.5) * 3";

コントロール名
テキストボックス ... textBox1
注意
行数が増えると遅くなるので注意
------------------------------
C#
*private void textBoxWriteLine(string str)

Draw, Lose, Winのままなら
var result = Rps.Battle(own, opponent).ToString();
*var result = Rps.Battle(own, opponent) switch

コントロール名
ListView ... listView1
上ボタン ... buttonUp
下ボタン ... buttonDown
コントロールの有効無効
*private void ctrlEnable()
ListViewの選択綱目のIDを取得
*int sel_id = this.getListViewSelectedIndex();
*if (sel_id <; 0)*{
未選択？
ボタン無効
*this.buttonUp.Enabled = false;
0番以外は、UPボタン有効
*this.buttonUp.Enabled = (sel_id >; 0);
末尾以外は、DOWNボタン有効
*this.buttonDown.Enabled = (sel_id <; this.listView1.Items.Count - 1);
*{if (this.listView1.SelectedIndices == null || this.listView1.SelectedIndices.Count == 0){return -1;}else{return this.listView1.SelectedIndices[0];}}
ListViewの選択綱目のIDを取得
*{//コントロールの有効無効this.ctrlEnable();}
ListViewの SelectedIndexChanged イベントハンドラ
コントロールの有効無効
*this.ctrlEnable();
*{//マイナス方向に項目移動this.listViewItemUpDown(-1);}
UPボタンの Click イベントハンドラ
マイナス方向に項目移動
*this.listViewItemUpDown(-1);
*{//マイナス方向に項目移動this.listViewItemUpDown(1);}
DOWNボタンの Click イベントハンドラ
マイナス方向に項目移動
*this.listViewItemUpDown(1);
ListViewの項目移動
引数
direction ... 移動方向(マイナス方向=-1、プラス方向=1)
*private void listViewItemUpDown(int direction)
ListViewの選択綱目のIDを取得
*int sel_id = this.getListViewSelectedIndex();
*if (sel_id <; 0) return;*//マイナス方向移動？
未選択？
*if (direction <; 0)*{
マイナス方向移動？
*if (sel_id <;= 0) return;*//
0番は移動できない
*{//末尾は移動できないif (sel_id >;= this.listView1.Items.Count - 1) return;//direction = 1;}
プラス方向
*if (sel_id >;= this.listView1.Items.Count - 1) return;*//
末尾は移動できない
ListView更新開始
*this.listView1.BeginUpdate();
移動する項目
*ListViewItem item = this.listView1.Items[sel_id];
移動する項目を削除
*this.listView1.Items.RemoveAt(sel_id);
移動する項目をずらして挿入
*this.listView1.Items.Insert(sel_id + direction, item);
ListView更新終了
*this.listView1.EndUpdate();

参考
ListViewの列の幅を自動調節する .NET Tips C#, VB.NET
http:dobon.net/vb/dotnet/control/lvautocolumnwidth.html
------------------------------
項目のテキスト幅で、自動調節
*this.listView1.AutoResizeColumns(ColumnHeaderAutoResizeStyle.ColumnContent);
*foreach (ColumnHeader ch in this.listView1.Columns)*{
あるいは
ヘッダと項目のテキスト幅で、自動調節
*this.listView1.AutoResizeColumns(ColumnHeaderAutoResizeStyle.HeaderSize);
*foreach (ColumnHeader ch in this.listView1.Columns)*{
あるいは

*string[] lv_item_str = { "aaa", "bbb", "ccc" };
方法1
*string[] lv_item_str = { "aaa", "bbb", "ccc" };
文字列配列 → リストビュー項目生成 → リストビューへ追加
方法2
リストビューへ文字列を項目追加 → 追加した項目にサブ項目追加
*int id = this.listView1.Items.Count;

*{if ( this.listView1.SelectedIndices == null || this.listView1.SelectedIndices.Count == 0 ){return -1;}else{return this.listView1.SelectedIndices[0];}}
C#

参考
【C++CLI】StatusStrip（ステータスバー）上のコントロールを右揃えに配置する　画像処理ソリューション
http:imagingsolution.blog107.fc2.com/blog-entry-77.html
============================================================
1個のステータスラベルを右寄せ
------------------------------
C#
*this.toolStripStatusLabel1.Spring = true;
2個のステータスラベルで、
toolStripStatusLabel1 が 左寄せ、toolStripStatusLabel2 が右寄せ
------------------------------
C#
*this.toolStripStatusLabel1.Spring = true;

*//  コンボボックスの幅を自動的にアイテムの内容にあわせる - Paradigm Shift Design*//  http://ishitoya.hatenablog.com/entry/20090209/1234179378
参考
コンボボックスの幅を自動的にアイテムの内容にあわせる - Paradigm Shift Design
http:ishitoya.hatenablog.com/entry/20090209/1234179378
*Graphics g = this.comboBox1.CreateGraphics();

*var res = await client.GetAsync("https:
対象サイトFQDN");

*var userAccount = new ChannelAccount(id: "29:2WLwfakXxSbEze4gfeGxeS31nXfELePLX3deELoxHw");
送信先ユーザー ※IDは適当だけどこんな感じの文字列だった

ロジックを書く
*}

参考
テキストボックスで CTRL+A を有効にする - BiBoLoG
http:d.hatena.ne.jp/Guernsey/20081016/1224135096
テキストボックスのCtrl-A (改)
*protected override bool ProcessDialogKey(Keys keyData)
このほかにもショートカットキーなどをここに記述できる
*}
参考
現在アクティブな（選択されている、フォーカスのある）コントロールを取得する、指定したコントロールをアクティブにする .NET Tips C#, VB.NET
http:dobon.net/vb/dotnet/control/selectcontrol.html
*public static Control GetRealActiveControl(ContainerControl parentControl)
ActiveControlプロパティを取得
*Control ac = parentControl.ActiveControl;
*if (ac == null)*{
ActiveControlがNULLの時は、コンテナコントロールを返す
*if (ac is ContainerControl)*{
ActiveControlがコンテナコントロールの場合は、さらにActiveControlを取得

+演算子
*sw.Restart();

Shell の登録
*builder.RegisterType<;Shell>;();
Shell を MainWindow に設定して表示する。
*Application.Current.MainWindow = (Shell)Shell;
Bootstrapperを起動
*new Bootstrapper().Run();
MainRegion に SamplePage を表示
*RegionManager.RegisterViewWithRegion("MainRegion", typeof(SamplePage));
SampleMessageProvider を ISampleMessageProvider として登録
*builder.RegisterType<;SampleMessageProvider>;().As<;ISampleMessageProvider>;();
SamplePage を登録
*builder.RegisterType<;SamplePage>;();
Shell の登録
*builder.RegisterType<;Shell>;();
Autofac Module の登録
*builder.RegisterModule<;Modules.SampleModule.SampleModuleRegistry>;();
Prism Module の登録
*var mc = (ModuleCatalog)ModuleCatalog;
Shell を MainWindow に設定して表示
*Application.Current.MainWindow = (Shell)Shell;

*public textPrefab;
(事前に用意）

データを持たないイベントデリゲートの宣言
ここでは"Time"というイベントデリゲートを宣言する
*public event EventHandler Time;
"Time"イベントの発生
*Time(this, EventArgs.Empty);
イベントハンドラの追加
*clsSleep.Time += new EventHandler(this.SleepClass_Time);
イベントが発生したとき
*MessageBox.Show("OK!");
データを持たないイベントデリゲートの宣言
*public event EventHandler Time;
Timeイベントで返されるデータ
ここではstring型のひとつのデータのみ返すものとする
*public class TimeEventArgs : EventArgs
デリゲートの宣言
TimeEventArgs型のオブジェクトを返すようにする
*public delegate void TimeEventHandler(object sender, TimeEventArgs e);
イベントデリゲートの宣言
*public event TimeEventHandler Time;
返すデータの設定
*TimeEventArgs e = new TimeEventArgs();
イベントの発生
*OnTime(e);
返されたデータを取得し表示
*MessageBox.Show(e.Message);

データを設定
*memos = new List<;MemoData>;();
リストビューのソースに設定
*lstMemo.ItemsSource = memos;
*btnListAdd.Clicked += (sender, e) =>; {memos.Add(new MemoData() { Title = "NewData" });};
ボタンイベント

*if (!loopSwap)
Swapが一度も実行されなかった場合はソート終了

ネットワークが無効な場合.
*Available = false;
メッセージをしばらく受信していない場合.
*var ok = false;
確認メッセージに対する返信の Consumer を定義.
*Action<;byte[]>; replyConsumer =
正式な返信なら OK.
*ok = true;
*Send(new byte[] { 0 });
確認メッセージを送信.
返信を待機.
*yield return new WaitForSeconds(CheckTimeoutSeconds);
引き続きメッセージを受信していない場合、結果を反映.
*Available = ok;
Socket.Poll で到着を待機.
*yield return new Poll(Client.Client);
以下、受信処理.
*byte[] message = Client.Receive(ref endpoint);
*{int port = DefaultPort;string[] args = Environment.GetCommandLineArgs();for (var i = 0; i <; args.Length; i++){if (args[i] == "-executeMethodArgs" &amp;&amp;i + 1 <; args.Length &amp;&amp;int.TryParse(args[++i], out port) &amp;&amp;port <; 0){// 独自に定義した引数のポート番号が不正だった場合.Debug.LogError("Invalid port number");port = DefaultPort;break;}}Start(IPAddress.Any, port);}
サイレントモードでのみ呼び出される想定の起動処理.
独自に定義した引数のポート番号が不正だった場合.
*Debug.LogError("Invalid port number");
*{Debug.LogFormat("[Server] Service is available at {0}:{1}", addr, port);var udp = new UdpClient(new IPEndPoint(addr, port));IPEndPoint from = null;var freeMessageSerializer = new FreeMessageSerializer();while (true){byte[] message = udp.Receive(ref from);if (message.Length >; 0){var theme = (Theme)message[0];if (theme == Theme.Check){// 確認メッセージの返信.Debug.Log("[Server] Received: ping");udp.Send(new byte[] { (byte)Theme.Check }, 1, from);}else if (theme == Theme.Free){// 自由メッセージの返信.var stream = new MemoryStream(message);FreeMessage deserialized = freeMessageSerializer.Deserialize(stream);Debug.Log("[Server] Received: " + deserialized.Text);Debug.Log("[Server] Length: " + message.Length);deserialized.Text = "Thanks!";stream = new MemoryStream();freeMessageSerializer.Serialize(stream, deserialized);byte[] buffer = stream.ToArray();udp.Send(buffer, buffer.Length, from);}}else{Debug.LogError("[Server] Received message size is zero.");}}}
エディタでの再生時のみ呼び出される想定の起動処理.
*udp.Send(new byte[] { (byte)Theme.Check }, 1, from);
確認メッセージの返信.
自由メッセージの返信.
*var stream = new MemoryStream(message);
アクティブ時にスレッドを開始.
*Service = new Thread(new ThreadStart(StartServer));
非アクティブ時にスレッドを終了.
*Service.Abort();

*{ new User { ID = 0, Name = "ID0" },
今回はDB用意するのは面倒なので適当にユーザーデータを作成する
*foreach (var item in UserList.Where(x =>; IDList.Contains(x.ID)))*{
IDListにあるIDを持つUser一覧を取得する

XamlになれるとC#コードでも普通に画面書けることに気が付いた。
Intellisenseとコード補完最大限に効くので結構書きやすい。
物凄く読みにくいけどね🍣
*public partial class App : Application
*{Title = "Browse"};
browse page
*{Title = "About"};
aboutPage
*{Title = browsePage.Title};
InnerNavigationPage

*// support library). There is no need to create a notification*// channel on older versions of Android.
Notification channels are new in API 26 (and not a part of the
*Log.Debug(TAG, "Notification Message Body: " + message.GetNotification().Body);*SendNotification(message.GetNotification().Body);
These is how most messages will be received
*SendNotification(message.Data.Values.First());*}
Only used for debugging payloads sent from the Azure portal
*hub = new NotificationHub(Constants.NotificationHubName,*Constants.ListenConnectionString, this);
Register with Notification Hubs

デフォルトのメッセージをセット
*context.PostAsync($"こんにちは！ドリンクおすすめ Botです。");
変数定義
bool food = false;   "food" タグの有無
string tag ="";      食べ物カテゴリータグ
string msg = "";     返答メッセージ
Custom Vision API を使う準備
*var cvEp = new PredictionEndpoint { ApiKey = "YOUR_PREDICTION_KEY" };
画像が送られてきたら Custom Vision を呼び出してタグを取得
メッセージをセット
※次以降の項目で作成します
*await context.PostAsync(msg);
*if (activity.Attachments?.Count != 0)*{
画像が送られてきたら Custom Vision を呼び出してタグを取得
送られてきた画像を Stream として取得
*var photoUrl = activity.Attachments[0].ContentUrl;
画像を判定
*var cvResult = await cvEp.PredictImageAsync(cvGuid, photoStream);
*foreach (var item in cvResult.Predictions)*{
food タグ および カテゴリーを取得
メッセージをセット
※次以降の項目で作成します
*await context.PostAsync(msg);
*if (tag != "")*{
メッセージをセット
タグに応じてメッセージをセット
*msg = "この写真は " + tag + " だね♪";
*if (tag != "")*{
メッセージをセット
タグに応じてメッセージをセット
msg = "この写真は " + tag + " だね♪";
*switch (tag)

シーケンスから例外が Throw された場合、
predicate でリトライするかどうかを判定する。

*return
predicate から例外が Throw された場合、
後続のシーケンスに例外を流す（＝リトライせずオブザーバーに例外を捕捉させる）。

*return Observable.Throw<;T>;(e);
predicate から例外が Throw されなかった場合、
再度、起点となったシーケンスに繋げる（＝リトライ）。

*return RetryWhenRecursive(source, predicate);

動画読み込み
*videoClip = Resources.Load(__path) as VideoClip;
下の2つは念のための程度の設定です
AudioのOutputModeを選択
*vp.audioOutputMode = VideoAudioOutputMode.AudioSource;
audioTrack[0]を有効に
*videoPlayer.EnableAudioTrack(0,true);
audioSourceにaudioTrack[0]を設定？？
*videoPlayer.SetTargetAudioSource(0,audioSource);
コレが最後に来るのが大事(直感)
*videoPlayer.clip = videoClip;
再生
*videoPlayer.Play();

*~SomeClass() {// ログ出力の自作クラス、内部で自作のロガーに警告ログを転送しているFinalizeLog.Warning(nameof(SomeClass));Dispose(false);}
GC発生時にこちらで回収された
ログ出力の自作クラス、内部で自作のロガーに警告ログを転送している
*FinalizeLog.Warning(nameof(SomeClass));
*void Dispose(bool disposing) {...}
ロジックのバグで呼ばれなかった

動画のレンダリングの仕方。デフォルトだとカメラが見れる一番遠く(Far)でレンダリングするっぽい
カメラの設定を使う場合はスクリプトをカメラにアタッチしたほうが良いかも
*videoPlayer.renderMode = VideoRenderMode.CameraNearPlane;
開始フレームの設定(最初にスキップするフレームの数)
*videoPlayer.frame = 100;
ループONに
*videoPlayer.isLooping = true;
動画が最後まで来たときのループ処理
*videoPlayer.loopPointReached += Loop;
*{print("LoooooP");}
引数ないと怒られます

*using System.IO;
←add this on the top of your code!
*void Start () {date = DateTime.Now;}
Use this for initialization
*void Update () {string str;string format = "yyyy-MM-dd-HH-mm-ss";string filename = "/data/" + date.ToString (format) + ".csv";fi = new FileInfo(Application.dataPath + filename);str = this.gameObject + "," + (transform.position.x) + "," +(transform.position.y) + "," + (transform.position.z)+","+ transform.rotation.x +","+ transform.rotation.y +","+ transform.rotation.z +","+ transform.rotation.w  ;sw = fi.AppendText();sw.WriteLine(str);sw.Flush();sw.Close();}
Update is called once per frame

*var urlstring = $"http:
stocks.finance.yahoo.co.jpstocksdetail?code={code}";
指定したサイトのHTMLをストリームで取得する
*var doc = default(IHtmlDocument);
AngleSharp.Html.Parser.HtmlParserオブジェクトにHTMLをパースさせる
*var parser = new HtmlParser();
クエリーセレクタを指定し株価部分を取得する
*var priceElement = doc.QuerySelector("#main td[class=stoksPrice]");
*Debug.WriteLine("コクヨ(7984.T)の株価: {0}円", price);
取得した株価がstring型なのでint型にパースする
休講情報を取得したいサイトのURL
var urlstring = "https:www.ead.tut.ac.jp/board/main.aspx";
指定したサイトのHTMLをストリームで取得する
*var doc = default(IHtmlDocument);
AngleSharp.Html.Parser.HtmlParserオブジェクトにHTMLをパースさせる
*var parser = new HtmlParser();
クエリーセレクタを指定して休講情報テーブル部分を取得する
*var items = doc.QuerySelectorAll("#grvCancel >; tr")
td単位で複数のデータを取得する
*var data = item.GetElementsByTagName("td");
休講日
*var date = data[1].TextContent;
時限
*var period = data[2].TextContent;
*return new { Date = date, Period = period, Subject = subject };
授業の名前
*{Debug.WriteLine("${item.Date}({item.Period}) {item.Subject}");});
取得した休講情報を出力する
新刊情報を取得したいサイトのURL
var urlstring = "http:www.shuwasystem.co.jp/newbook.html";
指定したサイトのHTMLをストリームで取得する
*var doc = default(IHtmlDocument);
AngleSharp.Html.Parser.HtmlParserオブジェクトにHTMLをパースさせる
*var parser = new HtmlParser();
最初のsinkanがコンピュータの関連書籍
*var priceElement = doc.GetElementById("sinkan");
必要な情報を読み取る
*var listItems = priceElement.GetElementsByTagName("dl")
書籍のタイトルを取得する
*var title = n.QuerySelector("dt")
書籍のISBNを取得する
*var isbn = n.QuerySelector("dd >; p >; strong")
*{Debug.WriteLine($"{item.Title} ({item.Isbn})");});
結果を出力する

*FileInfo file = new FileInfo(path)
フルパス・拡張子必要
Close() メソッドはWindows Store系アプリの場合使えないのでDispose()で代用
sr.Dispose(); ↑結構大事
*}

*foreach(var value in dic.Values) {// valueが欲しいとき}
keyが欲しいとき
valueが欲しいとき
*}

サービス情報を初期化する
Init 内で "認可された 権限コード(AuthorityCode) のリスト" を初期化する
*ServiceManager.Init();
*{new User("foo", AuthorityCode.A), new User("bar", AuthorityCode.B)};
User(Name, AuthorityCode) のリストを作成する(userManager に渡すため)
サービスにて認可された 権限コード(AuthorityCode) を所有したユーザーだけを表示する
プロジェクト実装上 User:"foo" だけが表示される
*var userManager = new UserManager(users);
ここからリフレクション
ServiceManager &gt; authorizedCode(private static) に値割り当てる
結果的に ServiceManager &gt; GetServiceAuthorizedCode() の返却値がスタブされている
*var authzCode = new List<;AuthorityCode>;() { AuthorityCode.S, AuthorityCode.A };
ここまでリフレクション
*var user1 = Substitute.For<;IUser>;();

*int freeTrialExpire = 60 * 60 * 24 * 7 * 2;
期間は2週間

SetAnimationでアニメーションの変更
引数：Track(後述)、アニメーション名、ループ再生か否か
*charaState.SetAnimation (0, "Idle", true);
アニメーション終了後処理
*charaState.Complete += (処理);
スキン変更後は必ず呼ぶ。
SkeletonDataのSlotDataリストの値を使用して、スロットをsetup poseに設定する。
*charaSkel.SetSlotsToSetupPose ();

*int v = (player_col - 1) *32;
最初4 色に応じてユーザーの色の画像を指定y

*if (bContainAlpha) {*// 信頼度がある程度以上ならば区切りと判断
アルファベット混じりだと発声が遅れるので処置する
*if (0.8 <; note.Results[0].Stability) {*var subtext = "";
信頼度がある程度以上ならば区切りと判断
*if (0.8 <; note.Results[0].Stability) {*,,,
信頼度がある程度以上ならば区切りと判断
*void _ms_wi_DataAvailable(object sender, WaveInEventArgs e) {try {if (_ms_wloop != null) {byte[] output = Convert16(e.Buffer, e.BytesRecorded, _ms_wloop.WaveFormat);_ms_wloop_ss.WriteLoop(output, 0, output.Length);,,,_micClient = SpeechRecognitionServiceFactory.CreateDataClient(SpeechRecognitionMode.LongDictation, _recog_lang_set, _keyBingSAPI1);_micClient.OnPartialResponseReceived += this.OnPartialResponseReceivedHandler;_micClient.OnResponseReceived += this.OnMicDictationResponseReceivedHandler;_micClient.OnConversationError += this.OnConversationErrorHandler;_micClient.SendAudioFormat(SpeechAudioFormat.create16BitPCMFormat(16000));var recorder = new RecordModel();recorder.RecordDataAvailabled += (sender2, e2) =>; {if (0 <; e2.Length) {try {lock (recorder) {_micClient.SendAudio(e2.Buffer, e2.Length);}} catch (InvalidOperationException w_e4) {}}};recorder.Start();// Bing Speech API1回14秒までなので、14秒まできたら打ち切るtimer = new System.Timers.Timer(13800);timer.Start();timer.Elapsed += (sender2, e2) =>; {try {recorder.Stop();} catch (TaskCanceledException w_e4) {}};do {if (this.Worker.CancellationPending || cToken.IsCancellationRequested) {e.Cancel = true;break;}Thread.Sleep(Convert.ToInt32(Math.Round(_threadwaitsec/4)));} while (!recorder.isStoped);timer.Stop();timer.Dispose();,,,var speechtxt = outtext;if (0 <; lastspeaktext.Length) {// 前回の発言内容とスペースを除去try {speechtxt = speechtxt.Substring(lastspeaktext.Length, speechtxt.Length - lastspeaktext.Length);} catch (Exception w_e4) {speechtxt = speechtxt.Replace(lastspeaktext, "");FuncWriteLogFile(w_e4.ToString());}speechtxt = Regex.Replace(speechtxt, @"\s", "");},,,var speechtxt = outtext;if (0.8 <; note.Results[0].Stability) {if (0 <; lastspeaktext.Length) {}var subtext = "";if (1 <; note.Results.Count) {subtext = note.Results[1].Alternatives[0].Transcript;if (0 <; subtext.Length) {speechtxt += subtext;}}// 前回の発言内容を除去try {if (10 <; lstLastspeaktext.Count) lstLastspeaktext.Clear();foreach (var tmpStr in lstLastspeaktext) {speechtxt = speechtxt.Replace(tmpStr, "");}} catch (Exception w_e4) {FuncWriteLogFile(w_e4.ToString());}},,,// ループバックの場合MMDevice outdevice = null;// 既定の出力をキャプチャ、出力サウンドデバイスは別の場所で別途設定outdevice = new MMDeviceEnumerator().GetDefaultAudioEndpoint(DataFlow.Render, Role.Multimedia); // 既定の出力_ms_wloop = new WasapiLoopbackCapture(outdevice);//_ms_wloop = new WasapiLoopbackCapture(new MMDeviceEnumerator().GetDevice(MainWindow.MMDoutputDevice));//WaveFormat format = new WaveFormat(8000, 16, 1);//_ms_writer = new WaveFileWriter(Environment.CurrentDirectory + "\\kikisen-vc.wav", format);_ms_wloop.DataAvailable += _ms_wi_DataAvailable;_ms_wloop.ShareMode = AudioClientShareMode.Shared;_ms_wloop_ss = new SpeechStreamer(100000);,,,Bing Speech API1回14秒までなので、14秒まできたら打ち切る
*timer = new System.Timers.Timer(13800);
*try {speechtxt = speechtxt.Substring(lastspeaktext.Length, speechtxt.Length - lastspeaktext.Length);} catch (Exception w_e4) {speechtxt = speechtxt.Replace(lastspeaktext, "");FuncWriteLogFile(w_e4.ToString());}speechtxt = Regex.Replace(speechtxt, @"\s", "");},,,var speechtxt = outtext;if (0.8 <; note.Results[0].Stability) {if (0 <; lastspeaktext.Length) {}var subtext = "";if (1 <; note.Results.Count) {subtext = note.Results[1].Alternatives[0].Transcript;if (0 <; subtext.Length) {speechtxt += subtext;}}// 前回の発言内容を除去try {if (10 <; lstLastspeaktext.Count) lstLastspeaktext.Clear();foreach (var tmpStr in lstLastspeaktext) {speechtxt = speechtxt.Replace(tmpStr, "");}} catch (Exception w_e4) {FuncWriteLogFile(w_e4.ToString());}},,,// ループバックの場合MMDevice outdevice = null;// 既定の出力をキャプチャ、出力サウンドデバイスは別の場所で別途設定outdevice = new MMDeviceEnumerator().GetDefaultAudioEndpoint(DataFlow.Render, Role.Multimedia); // 既定の出力_ms_wloop = new WasapiLoopbackCapture(outdevice);//_ms_wloop = new WasapiLoopbackCapture(new MMDeviceEnumerator().GetDevice(MainWindow.MMDoutputDevice));//WaveFormat format = new WaveFormat(8000, 16, 1);//_ms_writer = new WaveFileWriter(Environment.CurrentDirectory + "\\kikisen-vc.wav", format);_ms_wloop.DataAvailable += _ms_wi_DataAvailable;_ms_wloop.ShareMode = AudioClientShareMode.Shared;_ms_wloop_ss = new SpeechStreamer(100000);,,,*try {if (10 <; lstLastspeaktext.Count) lstLastspeaktext.Clear();foreach (var tmpStr in lstLastspeaktext) {speechtxt = speechtxt.Replace(tmpStr, "");}} catch (Exception w_e4) {FuncWriteLogFile(w_e4.ToString());}},,,// ループバックの場合MMDevice outdevice = null;// 既定の出力をキャプチャ、出力サウンドデバイスは別の場所で別途設定outdevice = new MMDeviceEnumerator().GetDefaultAudioEndpoint(DataFlow.Render, Role.Multimedia); // 既定の出力_ms_wloop = new WasapiLoopbackCapture(outdevice);//_ms_wloop = new WasapiLoopbackCapture(new MMDeviceEnumerator().GetDevice(MainWindow.MMDoutputDevice));//WaveFormat format = new WaveFormat(8000, 16, 1);//_ms_writer = new WaveFileWriter(Environment.CurrentDirectory + "\\kikisen-vc.wav", format);_ms_wloop.DataAvailable += _ms_wi_DataAvailable;_ms_wloop.ShareMode = AudioClientShareMode.Shared;_ms_wloop_ss = new SpeechStreamer(100000);,,,ループバックの場合
*MMDevice outdevice = null;
既定の出力をキャプチャ、出力サウンドデバイスは別の場所で別途設定
outdevice = new MMDeviceEnumerator().GetDefaultAudioEndpoint(DataFlow.Render, Role.Multimedia);  既定の出力
*_ms_wloop = new WasapiLoopbackCapture(outdevice);
*//WaveFormat format = new WaveFormat(8000, 16, 1);*//_ms_writer = new WaveFileWriter(Environment.CurrentDirectory + "\\kikisen-vc.wav", format);
_ms_wloop = new WasapiLoopbackCapture(new MMDeviceEnumerator().GetDevice(MainWindow.MMDoutputDevice));
*//_ms_writer = new WaveFileWriter(Environment.CurrentDirectory + "\\kikisen-vc.wav", format);*_ms_wloop.DataAvailable += _ms_wi_DataAvailable;
WaveFormat format = new WaveFormat(8000, 16, 1);

*Console.WriteLine(node["A"]["B"]["C"].Exists);
false

画面を白で塗りつぶします
*gc.ClearScreen();
0番の画像を描画します
*gc.DrawImage(0, 0, 0);

*} while (i != -1);
使用できる文字がない場合は「-1」が返る

まずコンテナインスタンスの作成
*var container = new Container();
シングルトンインスタンスの登録
インターフェイス - 実体の型を登録
*container.For<;IService1>;().As<;Service1>;(Lifecycle.Singleton);
インスタンスを登録
*container.For<;IService2>;().As(service2);
*container.For<;IService3>;().As(() =>; new Service3(), Lifecycle.Singleton);*container.For;IService4>;().As((IService3 service3) =>; new Service4(service5), Lifecycle.Singleton);
ラムダ式で登録
都度生成の場合
インターフェイス - 実体の型を登録
*container.For<;IService6>;().As<;Service6>;(Lifecycle.Transient);
*container.For<;IService7>;().As(() =>; new Service7(), Lifecycle.Transient);*container.For;IService8>;().As((IService7 service7) =>; new Service8(service7), Lifecycle.Transient);
ラムダ式で登録
スレッド単位生成の場合
インターフェイス - 実体の型を登録
*container.For<;IService9>;().As<;Service6>;(Lifecycle.ThreadLocal);
*container.For<;IService10>;().As(() =>; new Service10(), Lifecycle.ThreadLocal);*container.For;IService11>;().As((IService10 service10) =>; new Service11(service10), Lifecycle.ThreadLocal);
ラムダ式で登録
通常通り生成
*container.GetInstance<;IService1>;();
生成するデリゲートを出力
*container.GetInstance<;Func<;IService6>;>;();
遅延生成
*container.GetInstance<;Lazy<;IService7>;>;();

*https:
stackoverflow.comquestions25619169deploying-32-bit-access-system-to-64-bit-office-machine

*//if (!string.IsNullOrWhiteSpace(data.ToString())) properties[i].SetValue(person, data);*}
これでもOK

*+ Camera.main.transform.forward * 100 * n;
カメラから距離を取ってカメラと被らないようにさせているだけ

変数の宣言
*int money;
*{//タップした時の処理if (gc.GetPointerFrameCount(0)==1 &amp;&amp; ! isComplete) {money -= 100;if (gc.Random(0,3)==0){new_card = gc.Random(0,4);}else{new_card = gc.Random(5,9);}card_count[new_card]++;for (int i = 0; i <; 5; i++) {if (card_count[i] >; 4){isComplete = true;}}}//長押しした時の処理if(gc.GetPointerFrameCount(0) >;= 120){resetValue();}}
１フレームごとに呼ばれる・動きの処理を入れる
*if (gc.GetPointerFrameCount(0)==1 &amp;&amp; ! isComplete) {*money -= 100;
タップした時の処理
*if(gc.GetPointerFrameCount(0) >;= 120){*resetValue();
長押しした時の処理
*{gc.ClearScreen();gc.SetColor(255,0,0);gc.SetFontSize(36);gc.DrawString("money:"+money,60, 40);if(new_card >;= 0){gc.DrawString("new:"+card_name[new_card],60, 80);}for(int i=0 ; i<; CARD_TYPE ; i++){gc.DrawString(card_name[i] + ":" + card_count[i],60, 120+i*80);}if(isComplete ){gc.DrawString("complete!!",60, 920);}}
１フレームごとに呼ばれる・描画の処理

*Console.WriteLine("PlainText : {0}\n", plainText);
平文の文字列
*Console.WriteLine("Cipher : {0}\n" ,cipher);
暗号化された文字列
平文の文字列
*string plainText = "Hello, world!";
暗号化、復号された文字列
*string encrypted, decrypted;
公開鍵と秘密鍵
*string publicKey, privateKey;
公開鍵、秘密鍵をXML形式で取得する
*publicKey = rsa.ToXmlString(false);

*var url = "https:
www.google.commaps?q=" + latitude.ToString() + "," + longitude.ToString();

*return;
error
*{public bool Checked { get; set; }public string Name { get; set; }public string Race { get; set; }private string codename;public string Codename {get { return codename; }set { codename = value.ToUpper(); }}}
Name, Race, Codename

参考
http:nn-hokuson.hatenablog.com/entry/2016/12/08/200133
*using System.Collections;
*void Start () {Texture2D mainTexture = (Texture2D)GetComponent<;Renderer>;().material.mainTexture;Color[] pixels = mainTexture.GetPixels();buffer = new Color[pixels.Length];pixels.CopyTo(buffer, 0);drawTexture = new Texture2D(mainTexture.width, mainTexture.height, TextureFormat.RGBA32, false);drawTexture.filterMode = FilterMode.Point;}
Use this for initialization
*{//buffer.SetValue(Color.black, (int)p.x + 256 * (int)p.y);//太字for (int x = 0; x <; 256; x++){for (int y = 0; y <; 256; y++){if ((p - new Vector2(x, y)).magnitude <; 5){buffer.SetValue(Color.black, x + 256 * y);}}}}
ブラシの太さを変える
*for (int x = 0; x <; 256; x++)*{
太字
*void Update () {if (Input.GetMouseButton(0)){Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);RaycastHit hit;if (Physics.Raycast(ray, out hit, 100.0f)){Draw(hit.textureCoord * 256);}drawTexture.SetPixels(buffer);drawTexture.Apply();GetComponent<;Renderer>;().material.mainTexture = drawTexture;}}
毎フレーム、テクスチャ上のすべてのピクセルをチェックして、マウスが乗っている座標からの距離が8以下なら黒く塗りつぶします。
*{byte[] data = drawTexture.EncodeToJPG();File.WriteAllBytes(Application.dataPath + "/saveImage.jpg", data);}
テクスチャをjpgとして保存
*{var contents = File.ReadAllBytes(file);// DecodeJpeg uses a scalar String-valued tensor as input.var tensor = TFTensor.CreateString(contents);TFGraph graph;TFOutput input, output;// Construct a graph to normalize the imageConstructGraphToNormalizeImage(out graph, out input, out output);// Execute that graph to normalize this one imageusing (var session = new TFSession(graph)){var normalized = session.Run(inputs: new[] { input },inputValues: new[] { tensor },outputs: new[] { output });return normalized[0];}}
Convert the image in filename to a Tensor suitable as input to the Inception model.
*{var normalized = session.Run(inputs: new[] { input },inputValues: new[] { tensor },outputs: new[] { output });return normalized[0];}
Execute that graph to normalize this one image
開始モデルは、非常に特定の正規化されたフォーマット（特定の画像サイズ、入力テンソルの形状、正規化されたピクセル値など）
でテンソルによって記述された画像を入力として取ります。
このファンクションは、入力としてJPEGでエンコードされた文字列を取り込み、
入力モデルとしての入力として適したテンソルを戻すTensorFlow操作のグラフを作成します。
*static void ConstructGraphToNormalizeImage(out TFGraph graph, out TFOutput input, out TFOutput output)
- モデルは28x28ピクセルにスケーリングされた画像で訓練されました。
- モノクロなので表される色は1色のみ。（値 - 平均）/ スケールを使用してfloatに変換して使用する。
画素値を0-255 から 0-1 の範囲にするので、変換値 = (Mean　- 画素値) / Scale の式から,
Mean = 255, Scale = 255 となる。
*const int W = 28;
*{var graph = new TFGraph();//var model = File.ReadAllBytes("tensorflow_inception_graph.pb");// シリアル化されたGraphDefをファイルからロードします。var model = File.ReadAllBytes(Application.dataPath + "/models/Auto_model.pb");graph.Import(model, "");using (var session = new TFSession(graph)){var labels = File.ReadAllLines(Application.dataPath + "/models/labels.txt");var file = Application.dataPath + "/saveImage.jpg";//画像ファイルに対して推論を実行する//複数のイメージの場合、session.Run（）はループで（同時に）呼び出すことができます。//あるいは、モデルが画像データのバッチを入力として受け入れるので、画像をバッチ処理することができる。var tensor = CreateTensorFromImageFile(file);var runner = session.GetRunner();// 学習モデルのグラフを指定する。// 入出力テンソルの名前をsessionに登録する// 手動で変換したモデルの読込のときは、.AddInput(graph["dropout"][0], 0.5f)はいらない。runner.AddInput(graph["input"][0], tensor).AddInput(graph["dropout"][0], 0.5f).Fetch(graph["output"][0]);var output = runner.Run();// output[0].Value（）は、「バッチ」内の各画像のラベルの確率を含むベクトルです。 バッチサイズは1であった。//最も可能性の高いラベルインデックスを見つけます。var result = output[0];var rshape = result.Shape;if (result.NumDims != 2 || rshape[0] != 1){var shape = "";foreach (var d in rshape){shape += $"{d} ";}shape = shape.Trim();Debug.Log($"Error: expected to produce a [1 N] shaped tensor where N is the number of labels, instead it produced one with shape [{shape}]");Environment.Exit(1);}var bestIdx = 0;float best = 0;// 尤も確率が高いものを調べて表示するvar probabilities = ((float[][])result.GetValue(true))[0];for (int i = 0; i <; probabilities.Length; i++){if (probabilities[i] >; best){bestIdx = i;best = probabilities[i];}}Debug.Log($"{file} best match: [{bestIdx}] {best * 100.0}% {labels[bestIdx]}");}}
pythonで作成したモデルの読込を行う
シリアル化されたGraphDefをファイルからロードします。
*var model = File.ReadAllBytes(Application.dataPath + "/models/Auto_model.pb");
画像ファイルに対して推論を実行する
複数のイメージの場合、session.Run（）はループで（同時に）呼び出すことができます。
あるいは、モデルが画像データのバッチを入力として受け入れるので、画像をバッチ処理することができる。
*var tensor = CreateTensorFromImageFile(file);
学習モデルのグラフを指定する。
入出力テンソルの名前をsessionに登録する
手動で変換したモデルの読込のときは、.AddInput(graph["dropout"][0], 0.5f)はいらない。
*runner.AddInput(graph["input"][0], tensor).AddInput(graph["dropout"][0], 0.5f).Fetch(graph["output"][0]);
output[0].Value（）は、「バッチ」内の各画像のラベルの確率を含むベクトルです。 バッチサイズは1であった。
最も可能性の高いラベルインデックスを見つけます。
*var result = output[0];
尤も確率が高いものを調べて表示する
*var probabilities = ((float[][])result.GetValue(true))[0];

エラー発生時の処理
*}

変数の宣言
*int sec = 0;
キャンバスの大きさを設定します
*gc.SetResolution(720, 1280);
起動からの経過時間を取得します
*sec = (int)gc.TimeSinceStartup;
画面を白で塗りつぶします
*gc.ClearScreen();
0番の画像を描画します
*gc.DrawImage(0, 0, 0);
黒の文字を描画します
*gc.SetColor(0, 0, 0);

*{try{// ファイルから読み込んだ情報をDtoに変換する。// (コードは省略)return new Dto();}catch (Exception e){// ファイルフォーマットエラーしか発生しないので、// エラーログを呼び出し元で出力する。return null;}}
パターン1,2
ファイルから読み込んだ情報をDtoに変換する。
(コードは省略)
*return new Dto();
ファイルフォーマットエラーしか発生しないので、
エラーログを呼び出し元で出力する。
*return null;
*{try{// テーブルのレコード更新// (コードは省略)}catch (Exception e){// ロールバック。// (コードは省略)throw e;}}
パターン3
テーブルのレコード更新
(コードは省略)
*}
ロールバック。
(コードは省略)
*throw e;
*{// ファイルから読み込んだ情報をDtoに変換する。// (コードは省略)// 想定外例外は外側の共通例外処理でキャッチされる。return new Dto();}
パターン1
ファイルから読み込んだ情報をDtoに変換する。
(コードは省略)
想定外例外は外側の共通例外処理でキャッチされる。
*return new Dto();
*{// ファイルのフォーマットチェックif (HasFormatError()){return new ReadResult(){HasFormatError = true,Dto = null};}else{// ファイルから読み込んだ情報をDtoに変換する。// (コードは省略)// 想定外例外は外側の共通例外処理でキャッチされる。return new ReadResult(){HasFormatError = false,Dto = new Dto()};}}
パターン2
*if (HasFormatError())*{
ファイルのフォーマットチェック
ファイルから読み込んだ情報をDtoに変換する。
(コードは省略)
想定外例外は外側の共通例外処理でキャッチされる。
*return new ReadResult()
*{try{// テーブルのレコード更新// (コードは省略)}catch (Exception e){// ロールバック。// (コードは省略)// 再スローする場合、eを書いてはいけない。throw;}}
パターン3
テーブルのレコード更新
(コードは省略)
*}
ロールバック。
(コードは省略)
再スローする場合、eを書いてはいけない。
*throw;
ファイルフォーマットチェック
コードは省略
*return true;
*{public bool HasFormatError;public Dto Dto { get; set; }}
ファイル読み込み結果

*var digits = int[] { 2, 3, 4, 8, 9, 0, 3, 2 };
result =&gt; [2, 3, 4, 8, 9, 0, 3, 2]

*var perm = source.Perm(2);
k = 2
*var source = new int[] { 1, 2, 3 };
C(n=3, r=2)の例

*builder.RegisterModule(module);
設定ファイルによるコンポーネントの構築

*foreach (AnimatorStateTransition transition in state.transitions)
トランジション

(1) 基となる差を求める。
*int result = palyer_hand - pc_hand;
(2) 除数であまりを求め、±除数の範囲に収める。
*result %= 3;
(3) 除数を1回加えることでプラス化。
*result += 3;
(4) 再度除数であまりを求め、+除数の範囲に収める。
*result %= 3;
*foreach(string player_hand in new string[]{"グー", "チョキ", "パー"}) {
Your code here!

*exitTransitionC2.AddCondition(UnityEditor.Animations.AnimatorConditionMode.If, 0, "TransitionNow");
条件にトリガーを追加する。

*{var contents = File.ReadAllBytes(file);// DecodeJpeg uses a scalar String-valued tensor as input.var tensor = TFTensor.CreateString(contents);TFGraph graph;TFOutput input, output;// Construct a graph to normalize the imageConstructGraphToNormalizeImage(out graph, out input, out output);// Execute that graph to normalize this one imageusing (var session = new TFSession(graph)){var normalized = session.Run(inputs: new[] { input },inputValues: new[] { tensor },outputs: new[] { output });return normalized[0];}}
Convert the image in filename to a Tensor suitable as input to the Inception model.
*{var normalized = session.Run(inputs: new[] { input },inputValues: new[] { tensor },outputs: new[] { output });return normalized[0];}
Execute that graph to normalize this one image
開始モデルは、非常に特定の正規化されたフォーマット（特定の画像サイズ、入力テンソルの形状、正規化されたピクセル値など）
でテンソルによって記述された画像を入力として取ります。
このファンクションは、入力としてJPEGでエンコードされた文字列を取り込み、
入力モデルとしての入力として適したテンソルを戻すTensorFlow操作のグラフを作成します。
*static void ConstructGraphToNormalizeImage(out TFGraph graph, out TFOutput input, out TFOutput output)
- モデルは28x28ピクセルにスケーリングされた画像で訓練されました。
- モノクロなので表される色は1色のみ。（値 - 平均）/ スケールを使用してfloatに変換して使用する。
画素値を0-255 から 0-1 の範囲にするので、変換値 = (Mean　- 画素値) / Scale の式から,
Mean = 255, Scale = 255 となる。
*const int W = 28;
*{var graph = new TFGraph();//var model = File.ReadAllBytes("tensorflow_inception_graph.pb");// シリアル化されたGraphDefをファイルからロードします。var model = File.ReadAllBytes("Manual_model.pb");graph.Import(model, "");using (var session = new TFSession(graph)){var labels = File.ReadAllLines("labels.txt");var file = "temp.jpg";//画像ファイルに対して推論を実行する//複数のイメージの場合、session.Run（）はループで（同時に）呼び出すことができます。//あるいは、モデルが画像データのバッチを入力として受け入れるので、画像をバッチ処理することができる。var tensor = CreateTensorFromImageFile(file);var runner = session.GetRunner();// 学習モデルのグラフを指定する。// 入出力テンソルの名前をsessionに登録する// 手動で変換したモデルの読込のときは、.AddInput(graph["dropout"][0], 0.5f)はいらない。runner.AddInput(graph["input"][0], tensor).Fetch(graph["output"][0]);var output = runner.Run();// output[0].Value（）は、「バッチ」内の各画像のラベルの確率を含むベクトルです。 バッチサイズは1であった。//最も可能性の高いラベルインデックスを見つけます。var result = output[0];var rshape = result.Shape;if (result.NumDims != 2 || rshape[0] != 1){var shape = "";foreach (var d in rshape){shape += $"{d} ";}shape = shape.Trim();Console.WriteLine($"Error: expected to produce a [1 N] shaped tensor where N is the number of labels, instead it produced one with shape [{shape}]");Environment.Exit(1);}var bestIdx = 0;float best = 0;// 尤も確率が高いものを調べて表示するvar probabilities = ((float[][])result.GetValue(true))[0];for (int i = 0; i <; probabilities.Length; i++){Console.WriteLine(probabilities[i]);if (probabilities[i] >; best){bestIdx = i;best = probabilities[i];}}Console.WriteLine($"{file} best match: [{bestIdx}] {best * 100.0}% {labels[bestIdx]}");}}
pythonで作成したモデルの読込を行う
シリアル化されたGraphDefをファイルからロードします。
*var model = File.ReadAllBytes("Manual_model.pb");
画像ファイルに対して推論を実行する
複数のイメージの場合、session.Run（）はループで（同時に）呼び出すことができます。
あるいは、モデルが画像データのバッチを入力として受け入れるので、画像をバッチ処理することができる。
*var tensor = CreateTensorFromImageFile(file);
学習モデルのグラフを指定する。
入出力テンソルの名前をsessionに登録する
手動で変換したモデルの読込のときは、.AddInput(graph["dropout"][0], 0.5f)はいらない。
*runner.AddInput(graph["input"][0], tensor).Fetch(graph["output"][0]);
output[0].Value（）は、「バッチ」内の各画像のラベルの確率を含むベクトルです。 バッチサイズは1であった。
最も可能性の高いラベルインデックスを見つけます。
*var result = output[0];
尤も確率が高いものを調べて表示する
*var probabilities = ((float[][])result.GetValue(true))[0];

*if (hoge != null) { hoge.Piyo(); }*// nullチェック込みで簡潔に書ける
nullチェックを行ってから実行していた構文が
nullチェック込みで簡潔に書ける
*hoge?.Piyo();
*if (hoge != null)*{
nullじゃない場合にPropertyに代入したい
これはコンパイルエラー
hoge?.Fuga = "ほげほげ";
nullじゃない場合に、何かのメソッドの引数として実行したい。
*var list = new List<;string>;();
構文的にあてはまるものがない...
list.Add(str?);
*,,,
例えば上の方で書いた例だと
nullじゃない場合に代入（ちょっと冗長。。）
*hoge?.Invoke(h =>; h.Fuga = "ほげほげ");
nullじゃない場合にメソッド呼び出し
*str?.Invoke(list.Add);
nullable型も、Valueの取り出しが自然に行えます。
*int? ni = GetNullableInteger();

*myPlotModel.InvalidatePlot(true);
-- (3) , ここで軸設定が反映され、PlotViewが更新される

*if ( textLength <; 0 ) { return 0; }
overflow

KeyBindingが指定された時に呼ばれるコールバック
*KeyBindPropertyChanged));
KeyBindingに結び付けられたコマンドをこのMenuItemのCommandに反映
*menuItemKB.Command = kb.Command;
KeyBindingのローカライズされた文字列("Ctrl"など)をこのMenuItemのInputGestureTextに反映
*menuItemKB.InputGestureText = (kb.Gesture as KeyGesture).GetDisplayStringForCulture(CultureInfo.CurrentCulture);

item よりも前のものを除く （順列と組み合わせの違い)
重複を許さないので、unusedから item そのものも取り除く
*var unused = withRepetition ? items : items.SkipWhile(e =>; !e.Equals(item)).Skip(1).ToList();

*if (finishedPattern.Except(inputPattern).Any())*{
パターンが一致可能か確認
初期化
*this.StartStopButtonText.Value = "Stop";
*{foreach (var item in StreamCreater.Create(inputPattern, finishedPattern)){if (cancellationTokenSource.IsCancellationRequested) return false;this.ResultText.Value += item + ',';this.StreamCount.Value++;await Task.Delay(1);}this.ResultText.Value += output;this.IsStarted.Value = false;return true;}, this.cancellationTokenSource.Token);
Streamを非同期で生成
*if (res)*{
キャンセルされなければダイアログ表示

*DebugUtil.ListDump("ほげ","ふが");
OK

*string postUrl = "https:
****.****.com****upload";

ボックス化
*int i = 1;
ボックス化解除
*int j = (int)o;

*var t = dict["test"];
↑で作ったばかりなので入ってるはずもなく、KeyNotFoundException
var t = dict["test"];↑で作ったばかりなので入ってるはずもなく、KeyNotFoundException
var t = dict.GetOrDefault("test");  default値を指定しない場合はdefault(KV),KV=stringなので、stringのデフォ値のnullがtに入る
var t2 = dict.GetOrDefault("test2","入ってなかったよ");  default値を明示的に指定した場合は、keyが存在しない場合にそれが使用される。
*,,,

*if (t <;= 0) {
Java版はt==0で脱出、C#版はt==-1で脱出
空白・改行のときここに来る。空白・改行とも 0 &lt; t &lt; '0' の範囲内にある
*++I;

*// Use Activity.MembersAdded and Activity.MembersRemoved and Activity.Action for info*// Not available in all channels
Handle conversation state changes, like members being added and removed
*await context.PostAsync($"You sent {activity.Text} which was {length} characters");
return our reply to the user
*//await context.PostAsync($"You sent {activity.Text} which was {length} characters");
return our reply to the user
*string message = $"You sent {activity.Text} which was {length} characters";
await context.PostAsync($"You sent {activity.Text} which was {length} characters");

*public TestContext TestContext { get; set; }
必須

*void Start () {InputManager.Instance.PushFallbackInputHandler(gameObject);}
Use this for initialization
*void Update () {if (isDrag){Vector3 pos;currentInputSource.TryGetPosition(id, out pos);Debug.Log(pos);obj.transform.position = pos;}}
Update is called once per frame
*void Start () {InputManager.Instance.PushFallbackInputHandler(gameObject);}
Use this for initialization
*void Update () {if (isDrag){Vector3 pos;currentInputSource.TryGetPosition(id, out pos);Debug.Log(pos);obj.transform.position = pos;}}
Update is called once per frame

*int cnt = 0;
変数である必要は無い（Qiitaでのコメントを頂いた事で発覚）
*foreach (string s in e.Text.Split(new string[] { "\r\n" }, StringSplitOptions.None))*{
グラフ作成

*public Vector3 targetPoint;
注視点
*void Update () {float mouseX = Input.GetAxis("Mouse X");float mouseY = Input.GetAxis("Mouse Y");float mouseWheelScroll = Input.GetAxis("Mouse ScrollWheel");// 平行移動if (Input.GetMouseButton(2)){targetPoint += transform.right * mouseX * translateSpeed;targetPoint += transform.up * mouseY * translateSpeed;this.transform.Translate(mouseX * translateSpeed, mouseY * translateSpeed, 0);}// 回転if (Input.GetMouseButton(1)){float dist = Vector3.Distance(this.transform.position, targetPoint);this.transform.rotation = Quaternion.AngleAxis(rotateSpeed * -mouseY, transform.right) * transform.rotation;this.transform.rotation = Quaternion.AngleAxis(rotateSpeed * mouseX, Vector3.up) * transform.rotation;targetPoint = this.transform.position + this.transform.forward * dist;}// ズームif(mouseWheelScroll != 0){this.transform.Translate(Vector3.forward * mouseWheelScroll * zoomSpeed);float dist = Vector3.Distance(this.transform.position, targetPoint);if(dist <;= 1f){targetPoint = this.transform.position + this.transform.forward * 1f;}}// 注視点の周りを回るif (Input.GetMouseButton(0) &amp;&amp; (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))){this.transform.RotateAround(targetPoint, transform.right, -mouseY * rotateSpeed);this.transform.RotateAround(targetPoint, Vector3.up, mouseX * rotateSpeed);}}
Update is called once per frame
*if (Input.GetMouseButton(2))*{
平行移動
*if (Input.GetMouseButton(1))*{
回転
*if(mouseWheelScroll != 0)*{
ズーム
*if (Input.GetMouseButton(0) &amp;&amp; (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)))*{
注視点の周りを回る

*var rank = playerRankingQuery.Count;
自分のスコアのランク（-1）取得
TOP5同様、降順＋Limit5 に加え、自分のRank-2をSkipすることで、自分のスコアの2つ上のユーザーから取得
*dispRank = Mathf.Max(0, rank - 2);

処理なし
*}

*{
処理なし }
起動時にに呼び出すActorのメソッドをコール
*await proxy.HogeHoge();

*case XPaths.Post_CommentCOunt: return @"
*[@id=""main""]articlediv[1]div[2]divdiv[2]divulli[2]div[1]text()";

*client = new EmotionServiceClient("{your subscription key}");
クライアント
ファイル呼び出し
*var datafile = await KnownFolders.PicturesLibrary.GetFileAsync("emotion.jpg");
APIの呼び出し
*var emotions = await client.RecognizeAsync(fileStream.AsStream());
*{canvas.Children.Clear();if (emotions != null){foreach (var emotion in emotions){var ranked = emotion.Scores.ToRankedList();resultTbox.Text = "";Color color = Colors.Transparent;foreach(var rank in ranked){switch (rank.Key){case "Anger":resultTbox.Text = resultTbox.Text + "怒り : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Red;}break;case "Contempt":resultTbox.Text = resultTbox.Text + "軽蔑 : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.White;}break;case "Disgust":resultTbox.Text = resultTbox.Text + "嫌悪 : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Purple;}break;case "Fear":resultTbox.Text = resultTbox.Text + "恐怖 : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Black;}break;case "Happiness":resultTbox.Text = resultTbox.Text + "喜び : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Pink;}break;case "Neutral":resultTbox.Text = resultTbox.Text + "中立 : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Green;}break;case "Sadness":resultTbox.Text = resultTbox.Text + "悲しみ : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Blue;}break;case "Surprise":resultTbox.Text = resultTbox.Text + "驚き : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Yellow;}break;}}var faceRect = emotion.FaceRectangle;Windows.UI.Xaml.Shapes.Rectangle rect = new Windows.UI.Xaml.Shapes.Rectangle{Height = faceRect.Height,Width = faceRect.Width,Stroke = new SolidColorBrush(color),StrokeThickness = 2};canvas.Children.Add(rect);Canvas.SetLeft(rect, faceRect.Left);Canvas.SetTop(rect, faceRect.Top);}}});
結果を表示

*lastGetTime = (long)query.Result.First()["createTime"];
createTimeの新しい順に並んでいるので、先頭(First)のcreateTimeを保持しておく。

*static ~TestClass()
← staticなデストラクタはコンパイルエラーになる
外部ライブラリの初期化
*OuterLib.Initialize();
メインの処理
外部ライブラリの終了処理
*OuterLib.Finalize();
ここに終了処理を記述！！！
*OuterLib.Finalize();

COMを使った処理
*}
COMを使った処理
*}

*yield return so.SaveAsync();
こちらは新規登録処理

*client = new VisionServiceClient("{your subscription key}", "https:
southeastasia.api.cognitive.microsoft.comvisionv1.0");
ファイル呼び出し
*var datafile = await KnownFolders.PicturesLibrary.GetFileAsync("cvpict.jpg");
*var visuals = new VisualFeature[] {//VisualFeature.Adult,//VisualFeature.Categories,//VisualFeature.Color,VisualFeature.Description,VisualFeature.Faces,//VisualFeature.ImageType,//VisualFeature.Tags};
取得する項目の設定
APIの呼び出し
*var response = await client.AnalyzeImageAsync(fileStream.AsStream(), visuals);
*{canvas.Children.Clear();resultTbox.Text = "説明:\n" + captions[0].Text + "\n\n";var i = 0;Windows.UI.Color color;foreach (var face in faces){resultTbox.Text = resultTbox.Text + "Face No." + (i + 1).ToString() + "\n";resultTbox.Text = resultTbox.Text + "年齢:\n" + face.Age.ToString() + "\n";resultTbox.Text = resultTbox.Text + "性別:\n" + face.Gender.ToString() + "\n";if (face.Gender == "Male"){color = Windows.UI.Colors.Blue;}else{color = Windows.UI.Colors.Red;}Windows.UI.Xaml.Shapes.Rectangle rect = new Windows.UI.Xaml.Shapes.Rectangle{Height = face.FaceRectangle.Height,Width = face.FaceRectangle.Width,Stroke = new Windows.UI.Xaml.Media.SolidColorBrush(color),StrokeThickness = 2};canvas.Children.Add(rect);Canvas.SetLeft(rect, face.FaceRectangle.Left);Canvas.SetTop(rect, face.FaceRectangle.Top);i++;}});
結果を表示

TODO: このコード行はデータを 'kintoneDataSet.顧客リスト' テーブルに読み込みます。必要に応じて移動、または削除をしてください。
*this.顧客リストTableAdapter.Fill(this.kintoneDataSet.顧客リスト);
*this.contactTableAdapter.Fill(this.salesforceDataSet.Contact);*,,,
TODO: このコード行はデータを 'salesforceDataSet.Contact' テーブルに読み込みます。必要に応じて移動、または削除をしてください。

TODO: このコード行はデータを 'sendGridDataSet.Recipients' テーブルに読み込みます。必要に応じて移動、または削除をしてください。
*this.recipientsTableAdapter.Fill(this.sendGridDataSet.Recipients);
*this.contactTableAdapter.Fill(this.salesforceDataSet.Contact);*,,,
TODO: このコード行はデータを 'salesforceDataSet.Contact' テーブルに読み込みます。必要に応じて移動、または削除をしてください。
*{this.btImport.Enabled = true;this.Text = "完了";}));
エラー処理は省略

*{foreach (var s in sampleData){var bytes = BitConverter.GetBytes(s);yield return bytes[0];yield return bytes[1];}}
http:opensource.org/licenses/mit-license.php
ここでUnity側に値を表示するロジックを実装する。
*}

*{}
Use this for initialization
*{if (Input.GetMouseButtonDown(0)){Vector3 position = Input.mousePosition;iTween.MoveTo(player.gameObject, iTween.Hash("x", playerTapPoint.x, "y", playerTapPoint.y, "time", 10.0f));}}
Update is called once per frame

*generateType = Constant.Dungeon.BlockType.RoomFloor;
部屋の床としておくことで、普通の床と区別します.
壁オブジェクトを生成.
*break;
床オブジェクトを生成.
*break;

どこかから対象オブジェクトを取得
*var hoge = GetHoge();
変更前の値を保持
*var oldValue = hoge.Fuga;
これから変更する値。
*var newValue = "new";
Redo/Undo用のオブジェクトを生成
*var command = new UndoCommand(() =>; hoge.Fuga = oldValue, () =>; hoge.Fuga = new Vlaue);
適用
*command.Redo();
元に戻す
*command.Undo();
再適用
*command.Redo();

*var a = new { x = 1, y = "a" };
匿名型
ValueTupleでは名前がつかない
*var vt2 = (x, y);
名前を付けるためは、ちゃんと名前を書かないとダメ
*var vt2_ = (x:x, y:y);
*var a2 = new { x, y };
匿名型では名前がつく
明示的に名前付きのValueTupleとしても宣言可能
*(int x, string y) vt3 = (1, "ccc");
Tupleは引数・戻値に利用できます。
*public Tuple<;int, string>; GetTuple(Tuple<;int, string>; t) =>; t;
ValueTupleも、引数にも、戻り値にも利用可能です。
*public (int, string) GetValueTuple((int, string) vt) =>; vt;
もちろん名前を付けることも
*public (int x, string y) GetValueTuple2((int i, string s) vt) =>; vt;
structなので、null初期化できない
Null 非許容の値型であるため、Null を '(int, string)' に変換できません
*(int, string) vt = null;
classなのでnull初期化可能
*Tuple<;int, string>; t = null;
プロパティまたはインデクサーを out か ref のパラメーターとして渡すことはできません。
*Add(ref t.Item1);
割り当て可能
*var vt = (1, "a");
プロパティまたはインデクサー 'Tuple&lt;int, string&gt;.Item1' は読み取り専用であるため、割り当てることはできません
*var t = Tuple.Create(1, "a");
*var a = new { Item1 = 1, Item2 = "a" };
プロパティまたはインデクサー '&lt;anonymous type: int Item1, string Item2&gt;.Item1' は読み取り専用であるため、割り当てることはできません
'tuple' のメンバーは 'foreach 繰り返し変数' であるため変更できません
*tuple.i = 2;

*{x = p.X;y = p.Y;}
例えば、Pointに対する拡張メソッドを定義しておくと
*Console.WriteLine($"{x}:{y}");
分割代入ができるようになります。

*var a = f(10);
匿名型を返す

*Debug.Log("TimeOut");
タイムアウト
タイムアウト処理


*break;

*{activate = true;}
開始時に呼ぶ
*{if (activate){Timer += Time.deltaTime;for(int i = 0;i <; list.Count; i++){if (list[i].Time <; Timer){GameObject obj = (GameObject)Instantiate(list[i].Prefab, list[i].Pos, Quaternion.Euler(list[i].Rot));obj.transform.parent = transform;list.Remove(list[i]);}}}}
出現させたい間呼ぶ
*public class EmitPrefabAttribute : PropertyAttribute { }
ReorderableListの作成

*string actionName;
動的に変更したいログインページのアクション

Dictionary&lt;string, ocbect&gt;[]へのデシリアライズ
*var rawObject = Unpacking.UnpackObject(objectProvider.GetData());

*}
Disposeメソッドは書かれていないが、最後にfile.Disaposeが呼ばれる

何かrequest.Urlを見たりして処理する
*return false;

*static SingletonClass() {}
suppress beforefieldinit

*var jarRoot = @"..\..\stanford-corenlp-3.7.0-models";*// Annotation pipeline configuration
Path to the folder with models extracted from `stanford-corenlp-3.7.0-models.jar`
Indexは1からスタート
*var Index = new CoreAnnotations.IndexAnnotation().getClass();
*var text = "Kosgi Santosh sent an email to Stanford University. He didn't get a reply.";*var result = NLP.Run(text);
Text for processing

*{if (!_isStart) return;lock (this){foreach (var f in buffer){samplingData.Add(FloatToInt16(f));}}}
http:opensource.org/licenses/mit-license.php
*{CheckForErrorOnCall(MicStream.MicInitializeCustomRate((int)StreamType, AudioSettings.outputSampleRate));}
http:opensource.org/licenses/mit-license.php
*{if (!_isStart) return;lock (this){CheckForErrorOnCall(MicStream.MicGetFrame(buffer, buffer.Length, numChannels));foreach (var f in buffer){samplingData.Add(FloatToInt16(f));}}}
http:opensource.org/licenses/mit-license.php

*{public string ID { get; set; }public string YorozuyaMemberName { get; set; }}
このクラスはDBから取得したエンティティクラスのつもり。
出力結果
1    坂田銀時
2    定春
*TeacherList.ForEach(t =>; Console.WriteLine(t.TeacherName));
*{new YorozuyaMember{ID = "1", YorozuyaMemberName = "坂田銀時" },new YorozuyaMember{ID = "2", YorozuyaMemberName = "定春" }};
データ登録処理
*{public string ID { get; set; }public string YorozuyaMemberName { get; set; }}
このクラスはDBから取得したエンティティクラスのつもり。
*{public string ID { get; set; }public string JouihaMemberName { get; set; }}
このクラスもDBから取得したエンティティクラスのつもり。
出力結果
1    坂田銀時
2    定春
1    桂小太郎
2    エリザベス
*YorozuyaMemberList.ForEach(y =>; Console.WriteLine(y.ID + "    " + y.YorozuyaMemberName));
*{new YorozuyaMember{ID = "1", YorozuyaMemberName = "坂田銀時" },new YorozuyaMember {ID = "2", YorozuyaMemberName = "定春" }};
万事屋データ登録処理
*{new JouihaMember{ID = "1", JouihaMemberName = "桂小太郎" },new JouihaMember{ID = "2", JouihaMemberName = "エリザベス" }};
攘夷派データ登録処理
*string ID { get; }
Programクラスから変更されないように、getのみ。
*{public string ID { get; set; }public string YorozuyaMemberName { get; set; }//インターフェイス Person の Name プロパティを実装する必要がある。public string Name =>; YorozuyaMemberName;}
このクラスはDBから取得したエンティティクラスのつもり。
インターフェイス Person の Name プロパティを実装する必要がある。
*public string Name =>; YorozuyaMemberName;
*{public string ID { get; set; }public string JouihaMemberName { get; set; }//インターフェイス Person の Name プロパティを実装する必要がある。public string Name =>; JouihaMemberName;}
このクラスもDBから取得したエンティティクラスのつもり。
インターフェイス Person の Name プロパティを実装する必要がある。
*public string Name =>; JouihaMemberName;
Personリストを作り、万事屋と攘夷派のミックスリストを作る。
*List<;Person>; PersonList = new List<;Person>;();
*{//出力結果//2    エリザベス//1    桂小太郎//1    坂田銀時//2    定春Console.WriteLine(p1.ID + "    " + p1.Name);});
名前順にソートして表示
出力結果
2    エリザベス
1    桂小太郎
1    坂田銀時
2    定春
*Console.WriteLine(p1.ID + "    " + p1.Name);
*{new YorozuyaMember{ID = "1", YorozuyaMemberName = "坂田銀時" },new YorozuyaMember {ID = "2", YorozuyaMemberName = "定春" }};
万事屋データ登録処理
*{new JouihaMember{ID = "1", JouihaMemberName = "桂小太郎" },new JouihaMember{ID = "2", JouihaMemberName = "エリザベス" }};
攘夷派データ登録処理

*if(this.BackFunction == null)return;*this.UseCount--;
BackFunctionが存在しない時は終了
*if(this.UseCount != 0)return;*this.BackFunction.Backward();
他の関数に対しても出力している場合にはまだ勾配を計算しない
*if (this.Size >; 1)throw new InvalidSizeException($"expect size : 1, but actual : {this.Size}");*this.Grad[0] = 1.0;
一つの変数しか持たないことを確認する
*public virtual Tensor[] Predict(params Tensor[] inputs){return this.FunctionForward(inputs);}
...
*if (this.OutShape.Aggregate((now, next) =>; now * next) != tensor.Size)*throw new InvalidShapeException($"Expected Output Shape : ({string.Join(",", this.OutShape)})  ,Input Shape :({string.Join(",", tensor.Shape)})");
サイズ確認

*foreach (var item in root*.DescendantNodes()
usingの一覧を収集
自動生成対象とするインターフェースの一覧及びそのメンバの一覧を収集
*classes.AddRange(root
インターフェースが自動生成の対象かを判定、Syntaxのみでの判定なのでちょっと手抜き
*var name = syntax.Name.ToString().Split('.').Last();
*{Namespace = nds.Name.ToString(),Interface = ids.Identifier.Text,Methods = ids.Members.OfType<;MethodDeclarationSyntax>;().Select(CreateMethodInfo).ToArray()};
自動生成するクラスの元になる情報
*{Name = mds.Identifier.Text,ReturnType = mds.ReturnType.ToString(),ParameterTypes = String.Join(", ", mds.ParameterList.Parameters.Select(ps =>; String.Format("typeof({0})", ps.Type.ToString()))),ArgumentsWithTypes = String.Join( ",", mds.ParameterList.Parameters.Select(ps =>; String.Format("{0} {1}", ps.Type.ToString(), ps.Identifier.Text))),Arguments = String.Join(", ", mds.ParameterList.Parameters.Select(ps =>; ps.Identifier.Text))};
自動生成するクラスのメソッドの元になる情報

*private const string SpeechTranslateUrl = @"wss:
dev.microsofttranslator.comspeechtranslate?";
*{var reader = new RawSourceWaveStream(waveStream, new WaveFormat(16000, 16, 1));var buffer = new byte[reader.Length];var bytesRead = reader.Read(buffer, 0, buffer.Length);var samplesL = new float[bytesRead / reader.BlockAlign];switch (reader.WaveFormat.BitsPerSample){case 8:                    for (var i = 0; i <; samplesL.Length; i++)samplesL[i] = (buffer[i * reader.BlockAlign] - 128) / 128f;break;case 16:for (var i = 0; i <; samplesL.Length; i++)samplesL[i] = BitConverter.ToInt16(buffer, i * reader.BlockAlign) / 32768f;break;case 32:for (var i = 0; i <; samplesL.Length; i++)samplesL[i] = BitConverter.ToSingle(buffer, i * reader.BlockAlign);break;}var w = new byte[16000];for (var i = 0; i <; w.Length; i++)w[i] = 0;var data = 1000;//この部分は再生するwaveに応じて変更してください。//サンプルでは3～4秒程度のデータを送っていました。service.AddSamplingData(buffer, 0, 32000);await Task.Delay(data);service.AddSamplingData(buffer, 32000, 32000);await Task.Delay(data);service.AddSamplingData(buffer, 64000, 32000);await Task.Delay(data);service.AddSamplingData(buffer, 96000, buffer.Length - 96000);await Task.Delay(data);//無音データを意図的に送っています。service.AddSamplingData(w, 0, w.Length);}
http:opensource.org/licenses/mit-license.php
この部分は再生するwaveに応じて変更してください。
サンプルでは3～4秒程度のデータを送っていました。
*service.AddSamplingData(buffer, 0, 32000);
無音データを意図的に送っています。
*service.AddSamplingData(w, 0, w.Length);
*{using (var reader = messageEventArgs.GetDataStream())using (var stream = reader.AsStreamForRead())using (var mStream = new MemoryStream()){var bufferSize = 32000;var bytes = new List<;byte>;();var buf = new byte[bufferSize];var length = stream.Read(buf, 0, buf.Length);while (length - bufferSize == 0){bytes.AddRange(buf);length = stream.Read(buf, 0, buf.Length);}if (length >; 0)bytes.AddRange(buf.Take(length).ToArray());var fullData = bytes.ToArray();mStream.Write(fullData, 0, fullData.Length);mStream.Position = 0;var bitsPerSampleBytes = fullData.Skip(34).Take(2).ToArray();var channelBytes = fullData.Skip(22).Take(2).ToArray();var samplingBytes = fullData.Skip(24).Take(4).ToArray();var bitsPerSample = BitConverter.ToInt16(bitsPerSampleBytes, 0);var channel = BitConverter.ToInt16(channelBytes, 0);var samplingRate = BitConverter.ToInt32(samplingBytes, 0);using (var player = new WasapiOutRT(AudioClientShareMode.Shared, 250)){player.Init(() =>;{var waveChannel32 =new WaveChannel32(new RawSourceWaveStream(mStream,new WaveFormat(samplingRate, bitsPerSample, channel)));var mixer = new MixingSampleProvider(new[] {waveChannel32.ToSampleProvider()});return mixer.ToWaveProvider16();});player.Play();while (player.PlaybackState == PlaybackState.Playing){}}}}
http:opensource.org/licenses/mit-license.php

AirTapを検出したとき、OnInputClickedが呼ばれる。
*InputManager.Instance. PushFallbackInputHandler(gameObject);
*void OnInputClicked(InputClickedEventData eventData){//AirTap検出時の処理を記述}
AirTapを検出したとき呼ばれるメソッド
AirTap検出時の処理を記述
*}

*Thread.Sleep( 4000 );
スクリプト実行まで時間が掛かるので適当にwait

*var NotepadSession = new WindowsDriver<;WindowsElement<;(new Uri("http:
127.0.0.1:4723"), appCapabilities);

*if (GetDisplay() == "○")*{
NG 画面表示に対して実装している。表示が○でなくなると修正が必要。
画面に設定されたフラグ値を取得する。ビルドのため、固定値になっている。
*return IsOk.Yes;
画面に設定されたフラグに対する表示値を取得する。ビルドのため、固定値になっている。
*return "○";
文字を太字にする。コードは省略。
*}
*if (GetValue() == IsOk.Yes)*{
OK 表示にかかわらずYesの場合は動作する。画面表示の影響は受けない。
画面に設定されたフラグ値を取得する。ビルドのため、固定値になっている。
*return IsOk.Yes;
画面に設定されたフラグに対する表示値を取得する。ビルドのため、固定値になっている。
*return "○";
文字を太字にする。コードは省略。
*}

stringが変更された時の処理
*});
*{appState.Subscribe(value =>;{Debug.Log("APP_STATE:" + value);});}
Start is called before the first frame update

用途に合わせて、どちらか一方を使うとよいかと思います。
*checkBox.CheckedChanged += CheckBoxCheckedChanged;
CheckedChangedイベントは、
ユーザー操作だけでなく、
プログラムからCheckBoxのCheckedプロパティを操作した場合もコールされる。
*void CheckBoxCheckedChanged(object sender, EventArgs e)
*if ( checkBox.Checked ) {*Text = "Checked";
window title
Clickイベントは、
ユーザー操作からは呼ばれる。
（「クリック(Click)」という名称だが、スペースキーでCheck状態を操作しても呼んでくれる。）
プログラムからCheckBoxのCheckedプロパティを操作した場合はコールされない。
*void CheckBoxClick(object sender, EventArgs e)
用途に合わせて、どちらか一方を使うとよいかと思います。
checkBox.Click += CheckBoxClick;
*checkBox.CheckedChanged += CheckBoxCheckedChanged;
*{// window titleif ( checkBox.Checked ) {Text = "Checked";}else {Text = "Not checked";}}
void CheckBoxClick(object sender, EventArgs e)
*if ( checkBox.Checked ) {*Text = "Checked";
window title

*ViewData["Message"] = System.Runtime.InteropServices.RuntimeInformation.OSDescription;*return View();
ViewData["Message"] = "Your application description page.";

*void Start () {StartCoroutine (Calcurate ());}
Use this for initialization
*void Update () {}
Update is called once per frame

*button = GameObject.Find("Canvas").transform.Find("ChildButtonController").GetComponent<;ChildButtonController>;();*}
改善の余地あり

*else if (num % 2 == 0) return false;
偶数はあらかじめ除く
素数ではない
*return false;
素数である
*return true;

*System.Diagnostics.Debug.Assert(max <;= 2);
maxは2以上の数
■ステップ 1
探索リストに2からxまでの整数を昇順で入れる。
*var searchList = Enumerable.Range(2, max - 1).ToList();
■ステップ 2
探索リストの先頭の数を素数リストに移動し、その倍数を探索リストから篩い落とす。
*prime = searchList.First();
素数リストに追加
*primeList.Add(prime);
倍数をふるい落とす
*searchList.RemoveAll(n =>; n % prime == 0);
■ステップ 3
上記の篩い落とし操作を探索リストの先頭値がxの平方根に達するまで行う。
*} while (prime <; sqrtMax);
■ステップ 4
探索リストに残った数を素数リストに移動して処理終了。
*primeList.AddRange(searchList);

*using (var cryptoStream = new CryptoStream(inputStream, decryptor, CryptoStreamMode.Read))
暗号化データ → 圧縮データ
圧縮データ → MemoryStream
*int byteCount;

*{return x + y;}
テスト対象メソッド
テストメソッド
*[Fact]
テストメソッド
*[Fact(DisplayName = "1+1=2のはず", Skip = "諸々の事情により実行したくない")]
*public static object[][] AddTestData =>; Enumerable.Range(1, 10).Select(i =>; new object[] { i, i, i + i }).ToArray();
テストデータ１: プロパティ
*{return Enumerable.Range(from, count).Select(i =>; new object[] { i, i, i + i });}
テストデータ２: メソッド
テストメソッド
*[Theory]
*{return date.ToString("dddd", new System.Globalization.CultureInfo("ja-JP"));}
テスト対象メソッド
*{List<;object[]>; _testData = new List<;object[]>;();public TestDataClass(){_testData.Add(new object[] { new DateTime(2017, 4, 27), "木曜日" });_testData.Add(new object[] { new DateTime(2017, 4, 28), "金曜日" });}public IEnumerator<;object[]>; GetEnumerator() =>; _testData.GetEnumerator();IEnumerator IEnumerable.GetEnumerator() =>; GetEnumerator();}
テストデータ作成クラス
テストメソッド
*[Theory]
*{if(message == null){throw new ArgumentNullException(nameof(message), "ぬるぬる");}Console.WriteLine(message);}
テスト対象メソッド
テストメソッド
*[Fact]
*{Write(null);});
ArgumentNullExceptionが発生するはず
*{Write(null);});
ArgumentExceptionかそのサブクラスの例外が発生するはず
*{if (file == null){throw new ArgumentNullException(nameof(file));}using(var sr = new StreamReader(file)){return await sr.ReadToEndAsync();}}
テスト対象メソッド
テストメソッド
*[Fact]
テストメソッド(Exception)
*[Fact]
*{return ReadAllTextAsync(null);});
ArgumentNullExceptionが発生するはず

一部省略
*}
一部省略
*}
一部省略
*}
一部省略
*}

*string url = "https:
api.a3rt.recruit-tech.co.jptalkv1smalltalk";
*WWWForm form = new WWWForm();*form.AddField("apikey", apikey);
ChatAPIに送る情報を入力
*using (UnityWebRequest request = UnityWebRequest.Post(url, form))*{
通信
取得したものをJsonで整形
*string itemJson = request.downloadHandler.text;
*if (text.text != null) {*text.text = jsnode["results"][0]["reply"].Get;string>;();
Jsonから会話部分だけ抽出してTextに代入
エラーが出たらこれがログに吐き出される
*Debug.Log("JsonNode:" + e.Message);

*public static List<;T<; GetMasterData<;T<;(List<;long<; id) where T : IMasterData, new()
new T() のため.
---拡張しました---
同じキー(dataPath)が呼び出されたら.
*if (cachedMasterDictionary.ContainsKey(dataPath))
キャッシュしていたデータを渡します.
*return Filter(cachedData, id);
UTF8形式でデータを読み込みます.
*StreamReader sr = new StreamReader(dataPath, Encoding.UTF8);
インターフェースを通してデータを初期化します.
*var table = Json.Deserialize(source) as IList;
---拡張しました---
初期化済みマスタデータをdataPathをキーとしてキャッシュしておきます.
*cachedMasterDictionary.Add(dataPath, result);
IDが一致したデータのみ渡します.
*return Filter(result, id);

素数の一覧を取得
*var primes = CountPrime(0, number);
*while (tmp % prime == 0)*{
剰余が発生するまで割り続けて、終わったら次の素数に
*var primes = new List<;long>;() { 2 };
最小の素数をリストに
*while (tmp != 1)*{
割れなくなったらやめる
*while (tmp % prime == 0)*{
剰余が発生するまで割り続けて、終わったら次の素数に
割れなくなったらやめる
*yield break;
最大の素数が残っている数の平方より大きいなら残っている数は素数
*primes.Add(tmp);
次の素数を求める
*primes.Add(Enumerable.Range(maxPrime, tmp - maxPrime)

このSampleのメソッドをGetActionのUnityEventに指定する
&lt;/Summary&gt;
*public void TestA()
CreateDelegateでUnityActionを作っている
*Action action = (Action)System.Delegate.CreateDelegate(typeof(Action), SetUnityEvent.GetPersistentTarget(i), SetUnityEvent.GetPersistentMethodName(i));

*x = x.Val- 0.1 * x.Dif;
xの更新
yの極小値とその時のx
*Console.WriteLine(y.Val + "\t" + x.Val);

*using (DirectoryEntry DE = new DirectoryEntry(string.Format("LDAP:
{0}", new ADSystemInfo().UserName))) {

*.ToList();
Whereの結果をList&lt;int&gt;に変換する

*return fields[8];
c-ip

元（デザイン状態）の列設定
*private List<;DataGridColumnInfo>; _defaultSettings;
デフォルトの並び順・幅を確保する
*_defaultSettings = this.TargetGrid.Columns
ユーザ設定から保存値を取得し、DataGridに反映する
*var saveValue = Properties.Settings.Default[SettingsKey].ToString();
列情報コレクションに現在のDisplayIndexとWidthを確保
*var newSettings = this.TargetGrid.Columns
ユーザ設定へ保存
*Properties.Settings.Default[SettingsKey] = xmlSerialize<;List<;DataGridColumnInfo>;>;(newSettings);
最初にとっておいた_defaultSettingsで設定する
*setColumns(_defaultSettings);
ユーザ設定へはnullを保存する
*Properties.Settings.Default[SettingsKey] = null;

*foreach (var prop in properties)*{
テーブルレイアウトの作成
*foreach (var item in items)*{
値の投げ込み
その1 単純に変換
*var table1 = default(DataTable)
その2 匿名型
もちろんJoinとかの結果でも大丈夫
*var table2 = default(DataTable)

*browser.Address = "https:
google.co.jp";

TODO: スタブ
*return null;
何もせず if を抜けます
*}

非同期１つ目。待たなくてもいいパターン
*ExecuteAsync();
非同期２つ目。後続がこの処理の結果を必要とするので待つ必要がある。
*var result = await ExecuteAsync2();
非同期3つ目。2つ目の結果を受け取って処理する。
*await ExecuteAsync3(result);

以下ゲーム開始の処理
*}

移動スピード
*[SerializeField] private float speed;
SpaceshipのRigidbody
*[SerializeField] private Rigidbody2D _rigidbody;
*{_rigidbody.velocity = direction * speed;}
機体の移動
右・左
*float x = Input.GetAxisRaw ("Horizontal");
上・下
*float y = Input.GetAxisRaw ("Vertical");
移動する向きを求める
*Vector2 direction = new Vector2 (x, y).normalized;
移動
*movable.Move (direction);

*var displayName = account.DisplayName;
設定しいるユーザー名が取れる

UIPickerViewを生成する
*var pickerDataModel = new pickerDataModel();
プロパティの変更を検知するプロパティ
*public event EventHandler<;EventArgs>; ValueChanged;
Pickerに表示するデータを格納するフィールド
*List<;Item>; items = new List<;Item>;();
*{get{var returnType = new Tuple<;int, string>;(items[selectedIndex].ItemId, items[selectedIndex].ItemName);return returnType;}}
選択された値を取得するメソッド
*{items = new List<;Item>;();}
コンストラクター
*{return 1;}
カラム数
*{return items.Count;}
行数
*{return items[(int)row].ItemName;}
文字列取得
*{selectedIndex = (int)row;if (ValueChanged != null){ValueChanged(this, new EventArgs());}}
選択されたときの挙動

*cell.TextLabel.Text = item.name;
任意のプロパティ

*var d1 = DateTime.Parse($"{yy:D2}/01/01");
DateTime.Parse()
*var d2 = DateTime.ParseExact($"{yy:D2}/01/01", "yy/MM/dd", null);
DateTime.ParseExact()
*DateTime d3; DateTime.TryParseExact($"{yy:D2}/01/01", "yy/MM/dd", null, System.Globalization.DateTimeStyles.None, out d3);
DateTime.TryParseExact()
*Console.WriteLine($"{yy:D2}/01/01 → {d1:yyyy/MM/dd}, {d2:yyyy/MM/dd}, {d3:yyyy/MM/dd}");
出力
カルチャの生成 (年2桁の解釈(TwoDigitYearMax)を2099(2000～2099)にする)
*var culture = new System.Globalization.CultureInfo("ja-JP");
*var d1 = DateTime.Parse($"{yy:D2}/01/01", culture);
DateTime.Parse() + カルチャ明示
*var d2 = DateTime.ParseExact($"{yy:D2}/01/01", "yy/MM/dd", culture);
DateTime.ParseExact() + カルチャ明示
*DateTime d3; DateTime.TryParseExact($"{yy:D2}/01/01", "yy/MM/dd", culture, System.Globalization.DateTimeStyles.None, out d3);
DateTime.TryParseExact() + カルチャ明示
*Console.WriteLine($"{yy:D2}/01/01 → {d1:yyyy/MM/dd}, {d2:yyyy/MM/dd}, {d3:yyyy/MM/dd}");
出力

ルーティングのルールによって、エリアを持つルートはエリアを持たないルート具体的なので、前に配置する必要がある
*endpoints.MapControllerRoute(
エリア属性によって、該当コントローラーを指定のエリアと関連付ける
*[Area("Personnel")]
既存のエリアビューの検出ルールをクリア
*options.AreaViewLocationFormats.Clear();
*options.AreaViewLocationFormats.Add("/MyAreas/{2}/Views/{1}/{0}.cshtml");
新しいエリアビューの検出ルールを登録する
親コントローラーにArea属性を設定
Controllerが抽象クラスなので、PersonnelBaseControllerは抽象にしてもしなくても良いです
*[Area("Personnel")]
*{public IActionResult Index(){return View();}}
親コントローラーにエリア属性を設定しているので、該当子コントローラーには設定しなくてもPersonnelエリアと関連付けている

*listener.Prefixes.Add("http:
localhost:9999");

*{ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto});
クライアントのIPアドレスを取得するため、NginxのProxyヘッダを使う設定

*string uri = "http:
api.microsofttranslator.comv2Http.svcTranslate?text=" +

*Task<;string<; task = hc.GetStringAsync("https:
www.microsoft.com");
*if (!task.IsCompleted)*{
タスクが終わっている（成功、失敗、キャンセル）かチェック
www.microsoft.com の応答が超速なら、このメッセージは表示されない！
*Console.WriteLine("ちょっとまってね");

わりと頻繁に発生
*System.IO.IOException: The process cannot access the file 'hoge.txt' because it is being used by another process.
まだ何も書いてない
*}
希に発生
*System.IO.IOException: The process cannot access the file 'hoge.txt' because it is being used by another process.

*{Console.WriteLine("");};
引数void、戻り値void
*{Console.WriteLine(value);};
引数string、戻り値void
*{return (x + y).ToString();};
引数int,int、戻り値string
呼び出し
*act1();

*else
Remove Select All chkBox
*public bool Selected { get; set; }
public string items { get; set; }
*if (item.Selected)*{
item.Selectedがtrueの場合

*var s = string.Format("{0:0.000}", 1.2345);
= "1.235"

*{loggerFactory.AddConsole(Configuration.GetSection("Logging"));loggerFactory.AddDebug();if (env.IsDevelopment()){app.UseDeveloperExceptionPage();app.UseBrowserLink();}else{app.UseExceptionHandler("/Home/Error");}app.UseStaticFiles();app.UseCookieAuthentication();app.UseOpenIdConnectAuthentication(new OpenIdConnectOptions{ClientId = Configuration["Authentication:AzureAd:ClientId"],Authority = Configuration["Authentication:AzureAd:AADInstance"] + Configuration["Authentication:AzureAd:TenantId"],CallbackPath = Configuration["Authentication:AzureAd:CallbackPath"]});app.UseMvc(routes =>;{routes.MapRoute(name: "default",template: "{controller=Home}/{action=Index}/{id?}");});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*{if (e.Index != lastCheckedIndex){if(lastCheckedIndex != -1)checkedListBox1.SetItemCheckState(lastCheckedIndex, CheckState.Unchecked);lastCheckedIndex = e.Index;}}
ItemCheck event handler for your checkedListBox1

*{public int ID { get; set; }public string Fruit1 { get; set; }public int Price1 { get; set; }public string Fruit2 { get; set; }public int Price2 { get; set; }public string Fruit3 { get; set; }public int Price3 { get; set; }}
分割前のデータ1行が入る
*{public int Sequence { get; set; }public string Fruit { get; set; }public int Price { get; set; }}
分割後のデータ1行が入る
*{new InputRecord{ID = 1,Fruit1 = "りんご",Price1 = 150,Fruit2 = "みかん",Price2 = 50,Fruit3 = "はっさく",Price3 = 100,},new InputRecord{ID = 2,Fruit1 = "ぶんたん",Price1 = 200,Fruit2 = "ぶどう",Price2 = 300,Fruit3 = "いちご",Price3 = 400,},new InputRecord{ID = 3,Fruit1 = "めろん",Price1 = 2000,Fruit2 = "なし",Price2 = 130,Fruit3 = "ざくろ",Price3 = 500,},};
テストデータ(分割前表と同じ内容)
メソッド呼び出し
*List<;OutputRecord>; output = ConvertToOutput(input).ToList();

ここから下は Linq to object
*.ToDictionary(x =>; x, x =>; User32.GetWindowText(x));

*string html = await wc.DownloadDataTaskAsync("http:
www.google.co.jp");

*script.Attack ();
UnityChanScriptにある関数Attackを実行する

CELLレコードのサイズ
*long count = GetUInt32(4, false) + 24;
*if (pos + count <; len &amp;&amp; GetTypeID(count).Equals("GRUP"))*{
読込みサイズがファイルサイズと一致する場合、GRUPなし
CELLレコード後のGROUPのサイズを加算
*count += GetUInt32(count + 4, false);

*{if (Sd1_on.activeSelf){time += Time.deltaTime;if (Input.GetKeyDown(KeyCode.F)){audioSource.PlayOneShot(Operandum1SE);if (time >; DRL){audioSource.PlayOneShot(PointSE);CountText.text = "Point : " + Point.ToString();Point += 1;time = 0;}else{time = 0;}}}if (Sd1_off.activeSelf){time = 0;}}
New
*if (Sd1_on.activeSelf)*{
New_1
*if (time >; DRL)*{
New_2
*{if (Sd1_on.activeSelf){time += Time.deltaTime;if (Input.GetKeyDown(KeyCode.F)){audioSource.PlayOneShot(Operandum1SE);if (time <; DRH){audioSource.PlayOneShot(PointSE);CountText.text = "Point : " + Point.ToString();Point += 1;time = 0;}else{time = 0;}}}if (Sd1_off.activeSelf){time = 0;}}
New
*if (Sd1_on.activeSelf)*{
New_1
*if (time <; DRH)*{
New_2
*{if (Sd1_on.activeSelf){time += Time.deltaTime;if (Input.GetKeyDown(KeyCode.F)){audioSource.PlayOneShot(Operandum1SE);if (time <; DRHTime){if (Counter == DRHTimes){audioSource.PlayOneShot(PointSE);CountText.text = "Point : " + Point.ToString();Point += 1;time = 0;Counter = 0;}}else{time = 0;Counter = 0;}}}if (Sd1_off.activeSelf){time = 0;Counter = 0;}}
New
*if (Sd1_on.activeSelf)*{
New_1
*if (time <; DRHTime)*{
New_2

MastodonClient.CreateApp で得たものを保存しとく必要があるけど面倒だから UnitTest(MastodonClientTests)のを使わせてもらった
var appRegistration = await MastodonClient.CreateApp(instanceUrl, "MastoConsoleStandard", Scope.Read);
*var appRegistration = new AppRegistration
*{Console.WriteLine("--");Console.WriteLine($"{e.Status.CreatedAt.ToLocalTime().ToString()} - {e.Status.Account.AccountName}:");Console.WriteLine(e.Status.Content);};
Register events

言語ファイルの格納先
*string langPath = @"C:\tessdata";
言語（日本語なら"jpn"）
*string lngStr = "eng";
画像ファイル
*var img = new Bitmap(@"C:\Temp\test.jpg");
OCRの実行
*Tesseract.Page page = tesseract.Process(img);
表示
*Console.WriteLine(page.GetText());

既存の平面をリセット
*_session.Reset();
平面認識の機能をオフ
*_arPlaneManager.requestedDetectionMode = PlaneDetectionMode.None;
平面認識の機能をオン
*_arPlaneManager.requestedDetectionMode = PlaneDetectionMode.Horizontal;
RayとARPlaneが衝突したところのPose
*var hitPose = _hits[0].pose;
*_arObject.transform.position = hitPose.position;*var cameraPos = Camera.main.transform.position;
オブジェクトの配置

*[System.Web.Services.Protocols.SoapRpcMethodAttribute("MessageSaveCreateThreads", RequestNamespace="http:
wsdl.cybozu.co.jpmessage2008", ResponseNamespace="http:wsdl.cybozu.co.jpmessage2008", Use=System.Web.Services.Description.SoapBindingUse.Literal)]
送信者
userNameTokenElement.Username = this.Account.Text.ToString(); 送信者のﾕｰｻﾞｰｱｶｳﾝﾄ;
userNameTokenElement.Password = this.Password.Text.ToString(); 送信者のﾕｰｻﾞｰﾊﾟｽﾜｰﾄ;
*securityElement.usernameToken = userNameTokenElement;
Soapヘッダー
*messageAPI.action = actionElement;
ダミー情報
*threadType.id = "dummy";
フォルダー
*threadTypeFolder.id = "dummy";
コメント
*threadTypeFollow.id = "dummy";
標題
threadType.subject = this.Subject.Text.ToString();標題
本文
content1.body = this.Content.Text.ToString();本文
*threadType.content = content1;
確認フラグ
*threadType.confirm = false;
宛先
*int i = 0;
メッセージの送信
*messageThreadType.thread = threadType;

ギズモのアイコンは自分で設定してね！
*Gizmos.DrawIcon(pivotCenter, "MyGizmoCircleOrange");

構成ファイル、環境変数等から、構成情報をロード
*var builder = new ConfigurationBuilder()
構成情報をプロパティに設定
*Configuration = builder.Build();
各構成情報の取得
ブール値のロード
*bool isDemoMode = this.Configuration.GetValue<;bool>;("UserSettings:IsDemoMode");
文字列値のロードは、インデクサで指定可能
*string defaultUserName = this.Configuration["UserSettings:DefaultUser:Name"];
int 値のロード
*int defaultUserAge = this.Configuration.GetValue<;int>;("UserSettings:DefaultUser:Age");
*{// Add framework services.services.AddMvc();//構成情報から、UserSettings クラスへバインドservices.Configure<;UserSettings>;(this.Configuration.GetSection("UserSettings"));}
This method gets called by the runtime. Use this method to add services to the container.
構成情報から、UserSettings クラスへバインド
*services.Configure<;UserSettings>;(this.Configuration.GetSection("UserSettings"));
ユーザー設定情報インスタンスをフィールドに保持
*this._userSettings = userSettings.Value;

*xmlns:x="http:
schemas.microsoft.comwinfx2006xaml"
メイン画面を作成して表示する
*var mv = new MainView();
計測開始
*sw.Start();
この間に処理を行う
計測終了
*sw.Stop();
結果を返す(ミリ秒単位)
*long time = sw.ElapsedMilliseconds;
乱数を初期化
*var r = new System.Random();
0以上6未満の整数一様乱数を発生させる
*int dice = r.Next(6);
-10以上11未満の整数一様乱数を発生させる
つまり下記は[-10,10]であり[-10,11]ではない
*int x = r.Next(-10, 11);
0以上Int32.MaxValue未満の整数一様乱数を発生させる
*int y = r.Next();
0.0以上1.0未満の実数一様乱数を発生させる
つまり[0.0,1.0)であり[0.0,1.0]ではない
*double z = r.NextDouble();

*nums6.Aggregate((x, y) =<; x * y);
3628800
*// ->; { 2, 3, 5, 7, 11, 13, 1, 9 }
-&gt; { 1, 3, 5, 7, 9, 11, 13 }
*// ->; { 3, 5, 7, 11, 13 }
-&gt; { 2, 3, 5, 7, 11, 13, 1, 9 }
*// ->; { 1, 9 }
-&gt; { 3, 5, 7, 11, 13 }
*var nums7 = new[] { 1, 2, 3, 4, 5, 6 };
-&gt; { 1, 9 }
*// ->; { "First", "Second", "Third" }
-&gt; { "First", "Second", null, "Third" }

IHostingEnvironment をフィールドに保持
*this._hostingEnvironment = hostingEnvironment;
シリアライザーのインスタンスを生成
*DataContractJsonSerializer jsonSerializer = new DataContractJsonSerializer(typeof(Person));
入力ファイル ストリームの生成
using (FileStream stream = new FileStream(filePath, FileMode.Open))
*using (Stream stream = System.IO.File.Open(filePath, FileMode.Open))
逆シリアライズ
*deSerializedPerson = jsonSerializer.ReadObject(stream) as Person;

*{int result = Nullable.Compare(date1, date2);return result >; 0;}
date1がdate2より遅い日付の場合True

*var devices = await DeviceInformation.FindAllAsync(DeviceClass.VideoCapture);*var device = devices[0];
http:opensource.org/licenses/mit-license.php
使用するカメラの最大画素数を取得するためのプロパティ
*var properties = capture.VideoDeviceController.GetMediaStreamProperties(MediaStreamType.VideoPreview) as VideoEncodingProperties;
Jpeg形式でガメラの最大解像度で取得する。
*var property = ImageEncodingProperties.CreateJpeg();
*{//カメラから画像をキャプチャする。//注：この処理はawaitが使えない。今のところ原因は不明ですが、スレッド関連の問題だと思われる。capture.CapturePhotoToStreamAsync(property, stream).GetAwaiter().GetResult();//検索位置を戻すstream.Seek(0);//Face APIの呼び出しFace[] face = await _faceClient.DetectAsync(stream.AsStreamForRead());}
http:opensource.org/licenses/mit-license.php
カメラから画像をキャプチャする。
注：この処理はawaitが使えない。今のところ原因は不明ですが、スレッド関連の問題だと思われる。
*capture.CapturePhotoToStreamAsync(property, stream).GetAwaiter().GetResult();
検索位置を戻す
*stream.Seek(0);
Face APIの呼び出し
*Face[] face = await _faceClient.DetectAsync(stream.AsStreamForRead());
カメラから画像をキャプチャする。
注：この処理はawaitが使えない。今のところ原因は不明ですが、スレッド関連の問題だと思われる。
*capture.CapturePhotoToStreamAsync(property, stream).GetAwaiter().GetResult();
検索位置を戻す
*stream.Seek(0);
Emotion APIの呼び出し
*Emotion[] emotion = await _emotionClient.RecognizeAsync(stream.AsStreamForRead());
カメラから画像をキャプチャする。
注：この処理はawaitが使えない。今のところ原因は不明ですが、スレッド関連の問題だと思われる。    capture.CapturePhotoToStreamAsync(property, stream).GetAwaiter().GetResult();
検索位置を戻す
*stream.Seek(0);
Computer Vision APIの呼び出し
*AnalysisResult vision = await _visionClient.GetTagsAsync(stream.AsStreamForRead());

*void CirclarMotionByDiameter(){//cosθ = a(底辺)/c(斜辺)//a = c*cosθ//a = radius*cosθ//sinθ = b(高さ)/c(斜辺)//b = c * sinθ;//b = radius * sinθ//円の中心Vector3 a = left.position;Vector3 b = right.position;Vector3 center = new Vector3 ((a.x + b.x) / 2, (a.y + b.y) / 2, (a.z + b.z) / 2);//円の半径float radius = Vector3.Distance (a, center);float c = Time.time * speed;float x = radius * Mathf.Cos (c);float y = radius * Mathf.Sin (c);obj.position = new Vector3 (x, y, obj.position.z) + center;}
2点間を直径とする正円運動
cosθ = a(底辺)/c(斜辺)
a = c*cosθ
a = radius*cosθ
sinθ = b(高さ)/c(斜辺)
b = c * sinθ;
b = radius * sinθ
円の中心
*Vector3 a = left.position;
円の半径
*float radius = Vector3.Distance (a, center);
*void ElliptiicalMotionBy2Points(){Vector3 a = left2.position;Vector3 b = right.position;Vector3 center = new Vector3 (a.x , b.y, (a.z + b.z) / 2);//円の半径float radiusX = Vector3.Distance (b, center);float radiusY = Vector3.Distance (a, center);float c = Time.time * speed;float x = radiusX * Mathf.Cos (c);float y = radiusY * Mathf.Sin (c);obj.position = new Vector3 (x, y, obj.position.z) + center;}
2点を通る楕円運動
円の半径
*float radiusX = Vector3.Distance (b, center);
*void CirclarMotionBy2Points(){//中心(a,b)の円の半径を求める式は//(x-a)^2 + (y - b)^2 = r^2//これを一般形にすると、(aとbになんでもいいから入れるとわかる）//x^2 + y^2 +lx + my + n = 0//となるので、まず3点を定義する//とやろうと思ったけどプログラムで連立方程式なんてできるの。。。？//なので、//中心をO(x,y)とすると、OA=OB=OCであるので、Vector3 a = left2.position;Vector3 b = right.position;Vector3 c = left.position;}
3点を通る正円運動
中心(a,b)の円の半径を求める式は
(x-a)^2 + (y - b)^2 = r^2
これを一般形にすると、(aとbになんでもいいから入れるとわかる）
x^2 + y^2 +lx + my + n = 0
となるので、まず3点を定義する
とやろうと思ったけどプログラムで連立方程式なんてできるの。。。？
なので、
中心をO(x,y)とすると、OA=OB=OCであるので、
*Vector3 a = left2.position;

UNC を指定したときに発生
存在しない UNC を指定したときに発生
*break;

*public System.Collections.ObjectModel.ObservableCollection<;ZipRecord>; ZipRecords { get; set; }
郵便番号データのコレクション
郵便番号データのコレクションを初期化
*this.ZipRecords = new System.Collections.ObjectModel.ObservableCollection<;ZipRecord>;();
関連付け
*listView.DataContext = this.ZipRecords;

System.Text.Encoding.CodePages を NuGet で追加
コンソールの文字コードの設定
*System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);
シリアライザーのインスタンスを生成
*DataContractJsonSerializer jsonSerializer = new DataContractJsonSerializer(typeof(Person));
*{//シリアライズjsonSerializer.WriteObject(stream, person);}
出力ファイル ストリームの生成
シリアライズ
*jsonSerializer.WriteObject(stream, person);
入力ファイル ストリームの生成
using (FileStream stream = new FileStream(filePath, FileMode.Open))
*using (Stream stream = File.Open(filePath, FileMode.Open))
逆シリアライズ
*deSerializedPerson = jsonSerializer.ReadObject(stream) as Person;

*{if (Sd1_on.activeSelf){time += Time.deltaTime;if (Input.GetKeyDown(KeyCode.F)){audioSource.PlayOneShot(Operandum1SE);}if (time >;= FTTime){audioSource.PlayOneShot(PointSE);CountText.text = "Point : " + Point.ToString();Point += 1;time = 0;}}if (Sd1_off.activeSelf){time = 0;}}
New
*if (Sd1_on.activeSelf)*{
New_1
*if (time >;= FTTime)*{
New_2
*for (i = 0; i <; values.Length; i++)*{
New_2
*if (Sd1_on.activeSelf)*{
New_3
*if (first)*{
New_4
*for (i = 0; i <; values.Length; i++)*{
New_2
*if (Sd1_on.activeSelf)*{
New_3
*if (first)*{
New_4

追加 : O(1)
*list.Add("item");
取得 : O(1)
*var item = list[0];
検索 : O(n)
*int index = list.IndexOf("item");
ソート : O(n log n)
*list.Sort();
*foreach (var element in list)*{
列挙 : O(1) ※GetEnumerator()のみ。foreachを含めたらO(n)
削除 : O(n)
*bool removed = list.Remove("itemmmm");
追加 : O(1)
*LinkedListNode<;string>; addedNode = llist.AddLast("value");
検索 : O(n)
*bool contains = llist.Contains("value");
検索と取得 : O(n)
*LinkedListNode<;string>; findNode = llist.Find("value");
*foreach (var element in llist)*{
列挙 : O(1)
削除(要素指定) : O(n)
*bool removed = llist.Remove("value");
削除(ノード指定) : O(1)
*llist.Remove(addedNode2);
エンキュー : O(1)
*queue.Enqueue("item");
検索 : O(n)
*bool contains = queue.Contains("item");
ピーク : O(1)
*var item = queue.Peek();
デキュー : O(1)
*var item2 = queue.Dequeue();
プッシュ : O(1)
*stack.Push("item");
検索 : O(n)
*bool contains = stack.Contains("item");
ピーク : O(1)
*var item = stack.Peek();
ポップ : O(1)
*var item2 = stack.Pop();
追加 : O(1)
*dict.Add("key", "value");
検索 : O(1)
*bool containsKey = dict.ContainsKey("key");
取得 : O(1)
*var value = dict["key"];
削除 : O(1)
*bool removed = dict.Remove("key");
追加：O(log n)
*sdict.Add("key2", "value2");
検索：O(log n)
*bool contains = sdict.ContainsKey("key");
取得：O(log n)
*var value = sdict["key"];
*foreach (var element in sdict)*{
列挙：O(log n)
削除：O(log n)
*bool removed = sdict.Remove("key");
追加：O(n)
*slist.Add("key", "value");
検索：O(log n)
*bool containsKey = slist.ContainsKey("key");
取得：O(log n)
*var value = slist["key"];
取得(インデックス使用)：O(1)
*var keybyindex = slist.Keys[0];
*foreach (var element in slist)*{
列挙：O(1)
削除：O(n)
*bool removed = slist.Remove("key");
追加：O(1)
*bool added = set.Add("item");
検索：O(1)
*bool contains = set.Contains("item");
*set.UnionWith(new[] { "otheritem" });
集合演算：O(n) ~ O(n+m)
*foreach (var element in set)*{
列挙：O(1)
削除：O(1)
*bool removed = set.Remove("item");
削除(条件指定)：O(n)
*int removedCount = set.RemoveWhere(_ =>; _.StartsWith("it"));
追加：O(log n)
*bool added = sset.Add("item");
検索：O(log n)
*bool contains = sset.Contains("item");
*sset.UnionWith(new[] { "otheritem" });
集合演算：O(n) ~ O(n+m)
*foreach (var element in sset)*{
列挙：O(log n)
削除：O(log n)
*bool removed = sset.Remove("item");
削除（条件指定）：O(n)
*int removedCount = sset.RemoveWhere(_ =>; _.StartsWith("it"));

*if (quoteCount % 2 == 0)
is not value(quoted)
*//        "{",//        "}",
"C",
*//        "{",//        "}",
"Escape:",

*{get{return InternalEditorUtility.tags.ToList();}}
tagのList
*{var list = AllTags;var selectedIndex = list.FindIndex(item =>; item.Equals(property.stringValue));if (selectedIndex == -1){selectedIndex = list.FindIndex(item =>; item.Equals(list[0]));}selectedIndex = EditorGUI.Popup(position, label.text, selectedIndex, list.ToArray());property.stringValue = list[selectedIndex];}
ドロップダウンメニューの作成

*{if (Sd1_on.activeSelf){if (Input.GetKeyDown(KeyCode.F)){Counter += 1;audioSource.PlayOneShot(Operandum1SE);if (Counter == FRTimes){audioSource.PlayOneShot(PointSE);CountText.text = "Point : " + Point.ToString();Point += 1;Counter = 0;}}}if (Sd1_off.activeSelf){Counter = 0;}}
New
*if (Sd1_on.activeSelf)*{
New_1
*if (Counter == FRTimes)*{
New_2
*for (i = 0; i <; values.Length; i++)*{
New_2
*if (Sd1_on.activeSelf)*{
New_3
*if (first)*{
New_4
*for (i = 0; i <; values.Length; i++)*{
New_2
*if (Sd1_on.activeSelf)*{
New_3
*if (first)*{
New_4

*Debugger.Array(data);
123

スクリプトのパス設定
*var ssr = ScriptSourceResolver.Default
Roslynでスクリプト実行
*var gameRuleClass = CSharpScript.EvaluateAsync<;Type>;(script,so).Result;

*{get{List<;string>; sceneNames = new List<;string>;();//BuildSettingsからSceneのPathを読み込むList<;string>; AllPaths = (from scene in EditorBuildSettings.scenes where scene.enabled select scene.path).ToList();//PathからScene名を切り出すforeach (string x in AllPaths){int slash = x.LastIndexOf("/");int dot = x.LastIndexOf(".");sceneNames.Add(x.Substring(slash + 1, dot - slash - 1));}return sceneNames;}}
Scene名のList
BuildSettingsからSceneのPathを読み込む
*List<;string>; AllPaths = (from scene in EditorBuildSettings.scenes where scene.enabled select scene.path).ToList();
*foreach (string x in AllPaths)*{
PathからScene名を切り出す
*{var list = AllSceneName;var selectedIndex = list.FindIndex(item =>; item.Equals(property.stringValue));if (selectedIndex == -1){selectedIndex = list.FindIndex(item =>; item.Equals(list[0]));}selectedIndex = EditorGUI.Popup(position, label.text, selectedIndex, list.ToArray());property.stringValue = list[selectedIndex];}
ドロップダウンメニューの作成
どんな名前でもいいのでstring型のフィールドに付ける
*[SerializeField, SceneChangerAttribute]

*if (!testCountDictionary.ContainsKey(skill))*{
csharp&gt; dict[0]++; =&gt; System.Collections.Generic.KeyNotFoundException
Tuple の実装があればこっちの方がイケてる気がする
return Tuple.Create(Code, Level).GetHashCode();
*return Code.GetHashCode() ^ Level.GetHashCode();

終端がNULLの場合、除外する
*int count = this.Count;

*Console.WriteLine("文字数が5文字を超えるのは：" + index6 + "番目の要素でした。");
出力:文字数が5文字を超えるのは：2番目の要素でした。

TimeStampを見て、新しい方が今流れてきたと判断
*var isUpdatedSubject1 = subject1.Timestamp >; subject2.Timestamp;

*hoge.StartInstantiate();
registInstantiateで登録したアクションを一気に動かす

NG1 戻り値がなく、引数を更新しているのにGetメソッド
*var dtoes = new List<;Dto>;();
NG2 戻り値があるのにSetメソッド
*dtoes = SetData();
NG3 正しいSetterが混在していて読みにくい
*var dto2 = SetDto2();
DBから取得する想定。
*dtoes.Add(new Dto());
DBから取得する想定。
*var dtoes = new List<;Dto>;();
OK 引数更新
*var dtoes = new List<;Dto>;();
OK 戻り値が取得データになっている。
*dtoes = GetData();
OK GetterとSetterが統一されて読みやすくなった。
*var dto2 = GetDto2();
DBから取得する想定。
*dtoes.Add(new Dto());
DBから取得する想定。
*var dtoes = new List<;Dto>;();

*public class Enemy{public string name;public int hp;public int attack;public Enemy(){}public Enemy(string name, int hp, int attack){this.name = name;this.hp = hp;this.attack = attack;}// ステータスをコンソールに表示public void DebugStatus(){// string.Formatを使うと， + でつなげるよりも見た目わかりやすく文字を連結できる．Debug.Log (string.Format ("名前; {0}, HP: {1}, 攻撃; {2}", name, hp, attack));}}
敵
*public void DebugStatus(){// string.Formatを使うと， + でつなげるよりも見た目わかりやすく文字を連結できる．Debug.Log (string.Format ("名前; {0}, HP: {1}, 攻撃; {2}", name, hp, attack));}
ステータスをコンソールに表示
*Debug.Log (string.Format ("名前; {0}, HP: {1}, 攻撃; {2}", name, hp, attack));
string.Formatを使うと， + でつなげるよりも見た目わかりやすく文字を連結できる．

*process.StartInfo.CreateNoWindow = true;
not show cmd window

*Thread.Sleep(100);
時間のかかる処理を想定

*return book;
Bookオブジェクトを返す

*f.ShowDialog(this);
親はthis、つまり「form親」だよの設定。
Form親の変数を取得
*label1.Text = Form親.Form親Instance.TargetStr;
Form親の変数を書き換えちゃう
*Form親.Form親Instance.TargetStr = "ABCDE";
Form親の変数を取得
*label1.Text = Form親.Form親Instance.TargetStr;

*.ToList()
ConvertAll メソッドを使用するため一旦 List に変換する
FindAll メソッドを Where メソッドに、ConvertAll メソッドを Select メソッドに書き換え（処理は同じ）
*var resultList2 = list
クエリ構文で書き換え（処理は同じ）
（実は最初に紹介した「LINQ の典型的な例」と同じ）
*var resultList3 =
LINQ を使って実装
========================================
*var resultList1 = list
*// LINQ は使わず、foreach と for を使って実装*// ========================================
========================================
LINQ は使わず、foreach と for を使って実装
========================================
*var resultList2 = new List<;int>;();

*.Subscribe(...)
thisが死んだら OnCompleted() からの Dispose()

*parameters ["id"] = tweet.id_str;
リツイートするツイートのID

*public string FirstName { get; set; }
Attributeは省略できる
*var entitys = new List<;Entity>;() {new Entity() { LastName = "Ono", FirstName = "Shinji", Age = 37 },new Entity() { LastName = "Honda", FirstName = "Keisuke",  Age = 30 },new Entity() { LastName = "Nakayama", FirstName = "Masashi", Age = 49 },};
出力する内容
SortAttribute属性が設定されているプロパティのみ対象
*.Where(e =>; Attribute.IsDefined(e, typeof(SortAttribute)))
SortAttribute属性のSortIndexプロパティでソート
*.OrderBy(e =>; ((SortAttribute)Attribute.GetCustomAttribute(e, typeof(SortAttribute))).SortIndex)
プロパティ名を取得
*.Select(e =>; e.Name);
*foreach (var entity in this.Entitys) {//要素出力var element = propertyNames.Select(n =>; typeof(T).GetProperty(n).GetValue(entity));result.AppendLine(string.Join(",", element));}
ヘッダー出力
要素出力
*var element = propertyNames.Select(n =>; typeof(T).GetProperty(n).GetValue(entity));
*var entitys = new List<;Entity>;() {new Entity() { LastName = "Ono", FirstName = "Shinji", Age = 37 },new Entity() { LastName = "Honda", FirstName = "Keisuke",  Age = 30 },new Entity() { LastName = "Nakayama", FirstName = "Masashi", Age = 49 },};
出力する内容

*if (isManager)*{
管理者には詳細ログを表示する。
管理者向けには詳細ログを表示する。
*string summary = null;
関数呼び出しの部分を条件分岐から分離した。
*SetSummary(summary);

クロスフェードに使用するImageオブジェクト
*[SerializeField]
テクスチャ1枚目
*[SerializeField]
テクスチャ2枚目
*[SerializeField]
変化の速度 (秒)
*[SerializeField]
Imageのマテリアルを取得
*Material material = ImageUI.GetComponent<;Image>;().material;
ブレンド率を0.0に設定
*material.SetFloat("_Blend", 0.0f);
テクスチャを設定する
*material.SetTexture("_Texture1", Texture1);
ブレンド率を操作する (DoTweenを使用しています)
*material.DOFloat(1.0f, "_Blend", Speed).SetLoops(-1, LoopType.Yoyo);

メソッドをデリゲートに代入
*sumDelegate sumDele = Sum;
引数を入れて、Sumメソッドを使う
*sumDele(1, 2);
フォームクローズイベントに、Form1_FormClosedメソッドの処理を追加する
*FormClosed += new FormClosedEventHandler(Form1_FormClosed);
1行目：1つ目の引数確認
2行目：2つ目の引数確認
3行目：ついでにイベント発生原因を格納したプロパティ確認
*MessageBox.Show(sender.ToString() + "\n" + e.ToString() + "\n" + e.CloseReason.ToString());
フォームクローズイベントに、Form1_FormClosedメソッドの処理を追加する
*FormClosed += new FormClosedEventHandler(Form1_FormClosed);
FormClosedEventArgsクラス作成
引数に、フォームが閉じられた理由を渡す
(今回は「ウィンドウズがシャットダウンされるから」という理由にしてます)
*FormClosedEventArgs sample = new FormClosedEventArgs(CloseReason.WindowsShutDown);
フォームコントロールとFormClosedEventArgsオブジェクトを渡して呼び出し
*Form1_FormClosed(this, sample);

*var a = 0;
ダメなコメントのパターンです。
コメントは別の行に記述します。
*var a = 0;
処理
*}
*public int MyProperty { get; set; } = 0;
prop -&gt; tab -&gt; tabで補完できます。
*public int MyConstructor { }
ctor -&gt; tab -&gt; tabで補完できます。
推奨する記法(C#2.0)
Event名 += -&gt; tab -&gt; tabで補完できます。
*this.Click += this.SampleForm_OnClick;
古い記法(C#1.0)
*this.Click += new EventHandler(this.SampleForm_OnClick);
*{// TODO: 処理};
匿名メソッド(C#2.0)
TODO: 処理
*};
*{// TODO: 処理};
ラムダ式(C#3.0)
TODO: 処理
*};
TODO: クリックされたときの処理を実装します。
*}
*if (!isNotFound)*if (!IsNotNull())
二重否定
*if (Exists())*if (Contains())
肯定形
文脈から意味が読み取れる場合
*var mean = (a + b) / 2;
*if ((a >;= 90 &amp;&amp; a <;= 180) ||*(a >;= 270 &amp;&amp; a ;= 360))
比較演算子の左を主とした場合
*if ((90 <;= a &amp;&amp; a <;= 180) ||*(270 ;= a &amp;&amp; a ;= 360))
比較演算子の向きを揃えた場合
通常のループ
*var evenMax = 0;
LINQ(メソッド構文 + ラムダ式)
*var oddMin = decimals
LINQ(クエリ構文)
*var averageAgeOfMan = (
*if (obj?.Value is int i)*{
推奨する記法(C#7.0)
*if (obj?.Value is int)*{
Null条件演算子(C#6.0)
*if (obj != null &amp;&amp;*obj.Value is int)
古い記法(C#1.0)
as演算子
*var instance = obj as IDisposable;
*// while ((len--) >; 0)と等価*var len = 100;
特異な記述
while ((len--) &gt; 0)と等価
*var len = 100;
99 .. 0 のループ
*}
*for (var i = 99; i >;= 0; i--)*{
一般的な記述
99 .. 0 のループ
*}
処理
*}
原因を呼び出し元に伝える場合
*db.Rollback();
原因の詳細がそれ以上必要ない場合
*Debug.WriteLine(ex.ToString());
*byte[] bytes1 = new byte[2] { 0x00, 0xFF };
Array
古い書き方
スレッドごと停止します。
*Thread.Sleep(ms);
.NET4以降
*Task.Delay(ms).Wait();
asyncメソッド内であればawaitを使います。
*await Task.Delay(ms);
*var coord = $"({x}, {y})";
var coord = String.Format("({0}, {1})", x, y);
*var percent = $"f={f:P2}";
f=10.00%
*var currency = $"yen={yen,10:C}";
yen=    \1,000
*var hex = $"b=0x{b,-5:X4}";
b=0x00FF
*//var date = String.Format("{0:yyyy/MM/dd HH:mm:ss.fff}", DateTime.Now);
var date = DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss.fff");
*var date = $"{DateTime.Now:yyyy/MM/dd HH:mm:ss.fff}";
var date = String.Format("{0:yyyy/MM/dd HH:mm:ss.fff}", DateTime.Now);
*var date = $@"{TimeSpan.MaxValue:yyyy\/MM\/dd HH\:mm\:ss\.fff}";
var date = TimeSpan.MaxValue.ToString(@"yyyy\/MM\/dd HH\:mm\:ss\.fff")

*using (var g = new TFGraph ()) {// セッションの作成。var s = new TFSession (g);// ここでは "int"を使用するので、演算時のキャストはintにする。// placeholderというデータが格納される箱(値は実行時に入れる).引数として予めグラフに与える。var feed = g.Placeholder (TFDataType.Int32);// 中身が2のconstantの作成。var x = g.Const (2);// xの2乗を求める。var x2 = g.Square (x);// 和を求める。var add = g.Add (x2, feed);// runnerの作成。var runner = s.GetRunner ();// Placeholderに値を入れる。runner.AddInput (feed, new TFTensor ((int)3));// 実行及び結果表示Console.WriteLine ("2^2 + 3 ={0}", runner.Run (add).GetValue ());}
グラフを作成。
セッションの作成。
*var s = new TFSession (g);
ここでは "int"を使用するので、演算時のキャストはintにする。
placeholderというデータが格納される箱(値は実行時に入れる).引数として予めグラフに与える。
*var feed = g.Placeholder (TFDataType.Int32);
中身が2のconstantの作成。
*var x = g.Const (2);
xの2乗を求める。
*var x2 = g.Square (x);
和を求める。
*var add = g.Add (x2, feed);
runnerの作成。
*var runner = s.GetRunner ();
Placeholderに値を入れる。
*runner.AddInput (feed, new TFTensor ((int)3));
*Console.WriteLine ("2^2 + 3 ={0}", runner.Run (add).GetValue ());
実行及び結果表示

*List<;Hoge>; hogeList = Enumerable.Range(0, 10).Select(i =>; new Hoge { i = i * 10 }).ToList();
List&lt;T&gt;

なんらかの処理
進捗表示
*if (progressCounter != null)
*var progressCounter = new Modify.ProgressCounter();*var something = new Qiita.CounterOK.Something(progressCounter);
改良後
nullの代わりにNullObjectを渡してくる前提のため、nullチェックはしない。
*_progressCounter.MaxCount = maxCount;
なんらかの処理
進捗表示
*_progressCounter.Update(i + 1);

半角空白, 連続半角空白, 全角空白, 連続全角空白
*var text = "hoge foo  bar　Hoge　　Foo";

*reportProgress(progressCount, num);
進捗%更新
このメソッドからの戻り値
*return Task.WhenAll(taskList.ToArray());

*case 11:
throw の改善
ここの代入値を変更してみる。
*object o = "3";
ラムダ式で定義したローカル関数
*FuncHypo Hypo = (double x, double y) =>; Math.Sqrt(x * x + y * y);
*{return Math.Sqrt(x * x + y * y);}
ローカル関数(新機能)
3 の参照が返される。
*ref int p = ref findIt(3, arry);
参照なので p を変更すれば配列の要素が変更される。
*p = -1;
*{get =>; name == null ? "NULL" : name;set =>; name = value;}
=&gt; を使ってメソッド本体を書けるようになった。
Read Only の場合はこういう書き方ができる。
*public int Length =>; 0;
ラムダ式のように throw を書ける。
*public int getValue() =>; throw new NotImplementedException();

画面の初期表示処理
*InitializeView(id);
画面の初期表示処理
*_table1Rows = GetTable1Rows(id);
画面へ設定する。
*SetView();

*{public delegate void SetFaceObject(List<;FaceInformation>; list);public int FrameSizeWidth;public int FrameSizeHeight;public SetFaceObject OnDetected;public abstract void DetectFace();}
http:opensource.org/licenses/mit-license.php
*{if (Time.frameCount % FRAME_INTERVAL == 0){if (Service == null){#if UNITY_EDITOR// For Debug.when this application execute by unity,call this.Service = new FaceDetectStub();#else// execute For HoloLens.Service = UWPBridgeServiceManager.Instance.GetService<;FaceDetectBase>;();TextData.text = "Service Initialized.";#endifService.OnDetected = SetFaceObject;}Service.DetectFace();}}
http:opensource.org/licenses/mit-license.php
*{AppCallbacks.Instance.InvokeOnUIThread(async () =>;{var properties =_capture.VideoDeviceController.GetMediaStreamProperties(MediaStreamType.VideoPreview) asVideoEncodingProperties;if (properties == null)return;//coution! face detect is only supported 'BitmapPixelFormat.Gray8'.var videoFrame = new VideoFrame(BitmapPixelFormat.Gray8, (int) properties.Width, (int) properties.Height);this.FrameSizeWidth = (int) properties.Width;this.FrameSizeHeight = (int) properties.Height;var previewFrame = await _capture.GetPreviewFrameAsync(videoFrame);var detector = await FaceDetector.CreateAsync();var detectFaces = await detector.DetectFacesAsync(previewFrame.SoftwareBitmap);var faceInformations = detectFaces.Select(x =>; new FaceInformation{X = x.FaceBox.X,Y = x.FaceBox.Y,Width = x.FaceBox.Width,Height = x.FaceBox.Height}).ToList();AppCallbacks.Instance.InvokeOnAppThread(() =>; { OnDetected(faceInformations); }, false);}, true);}
http:opensource.org/licenses/mit-license.php

*{protected TParam param;protected TOut value;protected Func<;TParam, TOut>; provider;public Lazy(TParam param, Func<;TParam, TOut>; provider){this.param = param;this.provider = provider;}public TOut Value{get { return value != null ? value : (value = provider(param)); }}}
Basic
*{public LazyObject(Func<;T>; provider) : base(null, o =>; provider()){}}
Without initialization params
*{public LazyResource(string path) : base(path, Resources.Load<;T>;){}}
Resource

*Vector3 diff = transform.position - latestPos;*latestPos = transform.position;
ワールドでの移動量
*localDiff = transform.InverseTransformDirection(diff.normalized);*tiltVector = new Vector3(
ローカル用に変換する

*using (WebApp.Start<;StartUp<;("http:
*:8080"))

*{if (Service == null){#if UNITY_EDITOR// For Debug.when this application execute by unity,call this.Service = new SampleStub();#else// execute For HoloLens.Service = UWPBridgeServiceManager.Instance.GetService<;ISampleService>;();#endifService.OnDetected = SetFaceObject;}Service.DetectFace();}
http:opensource.org/licenses/mit-license.php

*1.0f
アニメーション時間
(1,1,1)に移動
*seq.Append(
(0,0,0)にスケーリング
*seq.Append(
(1,1,1)に移動
*seq.Append(
(0,0,0)にスケーリング
*seq.Join(
*hoge.OnUpdate(() =>; {// 対象の値が変更される度によばれる});
アニメーション開始時によばれる
*hoge.OnComplete(() =>; {// アニメーションが終了時によばれる});
対象の値が変更される度によばれる
アニメーションが終了時によばれる
*});

*rb.angularVelocity = Vector3.zero;
回転運動の停止

*connection.ConnectionString = String.Format("Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST={0})(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=gounn.WH))); User Id=test;Password=fuga", "192.168.64.190");
or 192.168.64.173
*{// 選択肢の値をセットします。public string Value { get; set; }// 選択肢として表示するテキストを取得するためのプロパティ。public string DisplayText{get{return $"{this.Value}";}}}
ドロップダウンリストの選択肢を表す ViewModel です。
*public string Value { get; set; }
選択肢の値をセットします。
*{get{return $"{this.Value}";}}
選択肢として表示するテキストを取得するためのプロパティ。
ページに必要な情報を全て持つ ViewModel です。
View はこの ViewModel から値を取得するようにしています。
*public class DropDownListViewModel
*public string Factory { get; set; }
ドロップダウンリストで選択している値を取得または設定するためのプロパティです。
*public IEnumerable<;FactoryViewModel>; FactoryOptions { get; set; }
ドロップダウンリストの選択肢をセットします。
*public IEnumerable<;FactoryViewModel>; FactoryOptions { get; set; }
※ ViewBag で代用も可能。
ここでビューモデルに選択肢をセットしています。
*vm.FactoryOptions = this.GetFactoryOptions();
もう一度ビューモデルに選択肢をセットしています。
Post されてこの箇所に来た時点で、
FactoryOptions プロパティは null になっているので、
再度セットする必要があります。
*vm.FactoryOptions = this.GetFactoryOptions();
*{string[] sourceDatas = new string[] { "Context190", "Context173" };return sourceDatas.Select(t =>; new FactoryViewModel() { Value = t });}
工場一覧の選択肢を取得するためのメソッドです。

*var conn = new HubConnection("http:
~~~~~~~~~~~.azurewebsites.netsignalr");

*else { dishes[dishes.Count-1].Add(a); }
要素数-1 で最後の要素
結果
*int i = 0;

Execute : Command :  バックグラウンドで実行する
: nohup ./tamesi33a2_cs.exe &gt; ./tamesi33a2_cs.out.log 2&gt; ./tamesi33a2_cs.err.log &lt; /dev/null &amp;
Check   :         :  tamesi33a1_cs.exe を使う
--------------------------------------------------------------------------------
tamesi33a2_cs.cs
Ubuntu の RabbitMQ はソースのバージョンが古いのか、API が異なった。
#define UBUNTU
*using RabbitMQ.Client;
回転式バッファー
*public static RotationBuffer rollingBuffer = new RotationBuffer();
Ubuntuでは何故か Spring.Messaging.Amqp.Rabbit の引数 7 つのやつになっている。
*m_channels_[index].QueueDeclare(QUEUE_NAMES[index], false, false, false, false, false, null);
Ubuntuでは何故か v1.4.0 の引数が 0 個のやつになっている。調べたが引数が1個～6個のものは無かった。
*m_consumers_[index] = new EventingBasicConsumer();
末尾に daze を付ける。
*message += "daze";
回転式バッファーに入れる
*rollingBuffer.PutMessage(message);
常時監視をスタート
*StartDequeue();
*while (IsConnected())*{
無限ループ
エンキューする
*Enqueue(message);
このプログラムは、自分では接続を切らない。
*}
対応するオープンは無いが、ちゃんと閉じないと、レシーブしてくれない。
*CloseChannel(ENQUEUE_INDEX);
受信できたときに割り込んでくる処理
*consumer.Received += GetReceiveHandler();
Ubuntuでは何故か引数が 5 個のやつになっている。
*channel.BasicConsume( QUEUE_NAMES[DEQUEUE_INDEX], true, "", null, consumer);
割込み処理の削除
consumer.Received -= GetReceiveHandler();
対応するオープンは無いが、ちゃんと閉じないと、レシーブしてくれない。
CloseChannel(DEQUEUE_INDEX);
*}

*{Debug.Log("上書きされた");}
Start is called before the first frame update

*publisherList.Items.Add(publisherName);
出版社のListBoxに値をセット

privateなフィールド、メソッドにアクセスするためにリフレクションを使用する
*var vInfo = typeof(Hoge).GetField("v", BindingFlags.NonPublic | BindingFlags.Instance);
コンストラクタを呼ばずにインスタンスを作成
*var hoge = FormatterServices.GetUninitializedObject(typeof(Hoge)) as Hoge;
HeavyFuncを実行する
*var result = heavyFuncInfo.Invoke(hoge, null);
フィールドに値をセット
*vInfo.SetValue(hoge, result);
正しくインスタンスが作成されている
*Debug.Log(hoge.Value);
*Debug.Log($"Application.isPlaying:{Application.isPlaying}");
Application.isPlayingはメインスレッドで呼ばなければ例外が発生する
コンストラクタで重い処理をしている
*v = HeavyFunc();
重い初期化処理
*Thread.Sleep(5000);
計算結果
*return 42;

*if ('A' <;= c1 &amp;&amp; c1 <;= 'Z')*{
last

UE4exeを起動する
*ProcessStartInfo psUE4Exe = new ProcessStartInfo();
5秒後間スリープ
*System.Threading.Thread.Sleep(5000);
プロセスを殺す
*ps.Kill();
UE4exeを起動する
*ProcessStartInfo psUE4Exe = new ProcessStartInfo();
10秒後間スリープ
*System.Threading.Thread.Sleep(1000 * 10);
UE4Gameに一致するプロセスを殺す
*System.Diagnostics.Process[] ps = System.Diagnostics.Process.GetProcessesByName(killProcessName);
UE4exeを起動する
*ProcessStartInfo psUE4Exe = new ProcessStartInfo();
10秒後間スリープ
*System.Threading.Thread.Sleep(1000 * 10);
UE4Gameに一致するプロセスを殺す
*System.Diagnostics.Process[] ps = System.Diagnostics.Process.GetProcessesByName(killProcessName);
*{if (!results.MoveNext()) throw new ApplicationException("Couldn't Get ParrentProcessId.");var queryResult = results.Current;//親プロセスのPIDを取得return (uint)queryResult["ParentProcessId"];}
クエリから結果を取得
親プロセスのPIDを取得
*return (uint)queryResult["ParentProcessId"];

絶対URIを起動
*System.Diagnostics.Process.Start(e.Uri.AbsoluteUri);
イベントを処理済みとしてマークする
*e.Handled = true;

*break;
条件不成立 (index &gt;= list.Count) なら終了。

ボタン無効化
*startButtonL.IsEnabled = false;
キャンセルフラグ初期化
*isCanceled = false;
ステータス表示更新
*statusLabelL.Text = "処理中...";
リストボックスクリア
*fileListL.Items.Clear();
時間のかかる処理呼び出し
*bool complete = await TimeConsumingProcessLAsync();
ステータス表示更新
*statusLabelL.Text = complete ? "処理完了しました。" : "処理を中断しました。";
ボタン有効化
*startButtonL.IsEnabled = true;
キャンセルされたら終了
*return false;
リストボックスにファイルパス追加
*fileListL.Items.Add(item);
（動作確認のため）1500ミリ秒待つ
*await Task.Delay(1500);
キャンセルフラグ設定
*isCanceled = true;
ボタン無効化
*startButtonR.IsEnabled = false;
ステータス表示更新
*statusLabelR1.Text = "処理中...";
リストボックスクリア
*fileListR.Items.Clear();
キャンセル用トークンソース生成
*cts = new System.Threading.CancellationTokenSource();
時間のかかる処理呼び出し
*bool complete = await TimeConsumingProcessRAsync(cts.Token);
ステータス表示更新
*statusLabelR1.Text = complete ? "処理完了しました。" : "処理を中断しました。";
ボタン有効化
*startButtonR.IsEnabled = true;
リストボックスにファイルパス追加
*fileListR.Items.Add(item);
（動作確認のため）1500ミリ秒待つ
*await Task.Delay(1500, token);
キャンセルされた
キャンセル用トークンソース解放
*cts?.Dispose();
*statusLabelR2.Text = $"例外、OperationCanceledException:{ex.Message}";
ステータス表示更新
終了
*return false;
例外発生
*MessageBox.Show(ex.Message);
*if (cts?.IsCancellationRequested == false)*{
まだキャンセル要求されていない？
キャンセル要求
*cts.Cancel();

*if(hp <; 5)
5より小さい

実際にはバインドしている値なのでこの辺はイメージ
*var TItems = new ObservableCollection<;TItem>;();
欲しい値
*var count = TItems.Sum(v =>; v.TreeCount());

*foreach (var ch in String.Join("", args)) {*win.FindElementByUid(keyIds[ch].ToString()).Click();
入力に対応したボタンをクリック
計算結果を表示する
win.FindElementByUid("121").Click();                       =
var result = win.FindElementByUid("150").Properties.Name; 結果のテキスト
*Console.Write(result);
*private static readonly IDictionary<;char, int>; keyIds = new Dictionary<;char, int>;() .{{'.', 84}, {'/', 91}, {'*', 92}, {'+', 93}, {'-', 94}, {'=', 121},{'0', 130}, {'1', 131}, {'2', 132}, {'3', 133}, {'4', 134},{'5', 135}, {'6', 136}, {'7', 137}, {'8', 138}, {'9', 139},};
電卓のキーとidの対応表
ログをコマンド用に設定する
Infoは出力しない
Warn以上を標準エラー出力に出す
*static void initializeLoggingRule() {
出力先を標準エラー出力へ
*target.Error = true;
Warning以上だけ表示
*var rule = new NLog.Config.LoggingRule("*", NLog.LogLevel.Warn, target);
*static void checkAlreadyRunning() {var procname = System.IO.Path.GetFileNameWithoutExtension(calcPath);if (System.Diagnostics.Process.GetProcessesByName(procname).Any()) {Console.Error.WriteLine("error!, already running calc process");Environment.Exit(1);}}
対象のアプリが起動してないか？

*{// 共通鍵を用意var keyString = "hogehogehogehoge";// トークン操作用のクラスを用意var handler = new System.IdentityModel.Tokens.Jwt.JwtSecurityTokenHandler();// 共通鍵なのでSymmetricSecurityKeyクラスを使う// 引数は鍵のバイト配列var key = new Microsoft.IdentityModel.Tokens.SymmetricSecurityKey(Encoding.UTF8.GetBytes(keyString));// 署名情報クラスを生成// 共通鍵を使うのでアルゴリズムはHS256使っとけばいいはずvar credentials = new Microsoft.IdentityModel.Tokens.SigningCredentials(key, "HS256");// トークンの詳細情報クラス？を生成var descriptor = new Microsoft.IdentityModel.Tokens.SecurityTokenDescriptor{Issuer = "GHKEN",SigningCredentials = credentials,};// トークンの生成//SecurityTokenDescriptor使わずにhandler.CreateJwtSecurityToken("GHKEN", null, null, null, null, null, credentials)でもOKvar token = handler.CreateJwtSecurityToken(descriptor);// トークンの文字列表現を取得var tokenString = handler.WriteToken(token);// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE0ODc4MjQ3MTQsImV4cCI6MTQ4NzgyODMxNCwiaWF0IjoxNDg3ODI0NzE0LCJpc3MiOiJHSEtFTiJ9.PJ-5KzFq7n2hBiJnoZMli0XajaJPNup0BztIO9QlDFYConsole.WriteLine(tokenString);Console.Read();}
issuerがGHKENのJWTを生成する
共通鍵を用意
*var keyString = "hogehogehogehoge";
トークン操作用のクラスを用意
*var handler = new System.IdentityModel.Tokens.Jwt.JwtSecurityTokenHandler();
共通鍵なのでSymmetricSecurityKeyクラスを使う
引数は鍵のバイト配列
*var key = new Microsoft.IdentityModel.Tokens.SymmetricSecurityKey(Encoding.UTF8.GetBytes(keyString));
署名情報クラスを生成
共通鍵を使うのでアルゴリズムはHS256使っとけばいいはず
*var credentials = new Microsoft.IdentityModel.Tokens.SigningCredentials(key, "HS256");
*{Issuer = "GHKEN",SigningCredentials = credentials,};
トークンの詳細情報クラス？を生成
トークンの生成
SecurityTokenDescriptor使わずにhandler.CreateJwtSecurityToken("GHKEN", null, null, null, null, null, credentials)でもOK
*var token = handler.CreateJwtSecurityToken(descriptor);
トークンの文字列表現を取得
*var tokenString = handler.WriteToken(token);
共通鍵で署名されたトークンを検証する
トークンの内容は
aud: 空
iss: "GHKEN"
exp: 期限切れ
*static void Main(string[] args)
鍵
*var keyString = "hogehogehogehoge"; ;
トークン操作用のクラス
*var handler = new System.IdentityModel.Tokens.Jwt.JwtSecurityTokenHandler();
トークンの文字列表現
*var tokenString = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE0ODc4MjUxMjMsImV4cCI6MTQ4NzgyODcyMywiaWF0IjoxNDg3ODI1MTIzLCJpc3MiOiJHSEtFTiJ9.AJFdztPP3GOBBjtiJeHc6wvy5Z3idQW2yGw9yCd6_wc";
*// Audience, Issuer, Lifetimeに関してはデフォルトで検証が有効になっている*// audが空でexpが期限切れなのでValidateAudienceとValidateLifetimeはfalseにしておく
トークン検証用のパラメータを用意
*// audが空でexpが期限切れなのでValidateAudienceとValidateLifetimeはfalseにしておく*var validationParams = new Microsoft.IdentityModel.Tokens.TokenValidationParameters
Audience, Issuer, Lifetimeに関してはデフォルトで検証が有効になっている
*{ValidateAudience = false,ValidIssuer = "GHKEN",ValidateLifetime = false,IssuerSigningKey = key,};
audが空でexpが期限切れなのでValidateAudienceとValidateLifetimeはfalseにしておく
第三引数にSecurityToken型の変数を参照で渡しておくと、検証済みのトークンが出力される
*handler.ValidateToken(tokenString, validationParams, out token);
ValidateTokenで検証に失敗した場合はここにやってくる
*Console.WriteLine("トークンが無効です: " + e.Message);
秘密鍵を用意
*var keyString = "<;RSAKeyValue>;<;Modulus>;yT12/iqZLNcrnTTFGy3NMuCjo6wJNLuG5j5L2yM6iX7CT5sWVq2BuXtdbq6PFuOIkzwJ+5Sng+qthAX5qHnuxRMI+QITe1qP+k0pOtK/EVtuedz6zdu2+Sp24CvGIMt1y8yMeOBXrRZTZzxpH9VsSq9kA/ylHKuWRfWLHysIqsdO0Tgf9eLwNAhRr6vpkvsAwvJnreIdWr/7aTrt9vq3EIJI3NYHV7/zqbZ7mKS1GbvJkAMbrQkYJ45hhEBUdYE45V8Dhkb9NTlExIcrar3vqsXSOVjQvuiGN4HsYmqPGUw26P9F7DrPyM4eQksb+PRMdkPW4dTjIRj9X3OIBHXrBw==<;/Modulus>;<;Exponent>;AQAB<;/Exponent>;<;P>;8Qw9p6A+11Tu6Dsl6+ndb7qiQP3u4cE5JMDRuq71A11XiEKU9K+1j5O26TtcJaJUCeH01RCKvMa/hNp2G7NqPnjxpRQU06Vj+bvJono7YTHcScC4Apa8cSsFQ62Iu2jpoHIkEz/5j7EdkToyFpC4opxbcHANPc9lXwfjIJTyieE=<;/P>;<;Q>;1bkXNBVazXVSGaP2DXVSSme9uXF5DmiEdKbpqRY6hlW+wIUBOG3RStkPC5ah62+3ObAooehVveR+kJOmSl2qLYvSaqV/DPkTyRyFOpTlpOSpLBsRvzPMoA7BFweXiy3YIbDsSr7S1qC1JgoMK4Htz742tDXLBUM32SWZr9OFoec=<;/Q>;<;DP>;aE8rvwYRK42NdOFjn5ssP9U7sXQxk2/SEp1+JJLhY/tYjZaCbwA6SU9ar8MINSDxzPUCxdDKuLYo2ozO313cc/xSVWVDPfMsOD2TG8RZPc4dzayf9D7WfQJo3MiTisXzk4LRKaNdk1jJura8RheKTpPq3dUfZcgBzgXTu5249wE=<;/DP>;<;DQ>;E8JP9d2/jl05YOt6tRXSrNRYgwuNoJpjHJHN6ncGpCLLRutFCJ2Giv/0VyLvB2BFtUynBQkA3FSCqwUri5aLRDi4FGoGjAF/JcnAO4FGle8aANzj0CSO14FlsqZeCV0MrVi5D9QClBs5hDHLnD4f6WPxlMmgYnUrdaT3R30rzqM=<;/DQ>;<;InverseQ>;dSfitpkpXxGrKbPA4HxVtSZU71tWOMbvIjYKy8cYTw+/EsQ7LW84Q1I8WDrbB7m/Zj67EufC2n1VNaP+x9dOCXpud+R/48piD2bp5JDCv5wUSs7xsjPsx8o1ScrHaXOeySQ486HTLji4RaqiiD1I46fF6NV1ZKRmOSUmMInxDDM=<;/InverseQ>;<;D>;DqjBkEY+HjwWWz9K1G4Dsp8WjIetq/+1FfSXxgDM9NMdCHt9pxbAimhoJ/XjSoGMo10ORRtREJT5ytI8m382W3jFgI4cKTIxpsQUKsrLTFJiu9HTG0fUDlZ/jljh9+WaURw3Z17AREWKEc0ew0jiuJYKLRgsVuhQ7Au09LJH0VjOTj9h62Trb2srbz/s+XjnTi8cch6oSBeqV/2YbYQla9bAMswR84fRRNUonDPrYvwC5rnhw5Xp0vJueHZpmTsruXjQJasue/Tgp/p6CsZlZX1CvTX8muSROyJ8vCjbG1dGplx+3Jbca+RoXj1FajdlmfrZxvDiH+v4M2mLenuDgQ==<;/D>;<;/RSAKeyValue>;";
RSAを使うのでRsaSecurityKeyを使う
*var rsa = new System.Security.Cryptography.RSACryptoServiceProvider();
トークン操作用のクラスを用意
*var handler = new System.IdentityModel.Tokens.Jwt.JwtSecurityTokenHandler();
署名情報クラスを生成
非対称鍵を使うのでアルゴリズムはRS256使っとけばいいはず
*var credentials = new Microsoft.IdentityModel.Tokens.SigningCredentials(key, "RS256");
*{Issuer = "GHKEN",SigningCredentials = credentials,};
トークンの詳細情報クラス？を生成
トークンの生成
SecurityTokenDescriptor使わずにhandler.CreateJwtSecurityToken("GHKEN", null, null, null, null, null, credentials)でもOK
*var token = handler.CreateJwtSecurityToken(descriptor);
トークンの文字列表現を取得
*var tokenString = handler.WriteToken(token);
公開鍵を用意
*var keyString = "<;RSAKeyValue>;<;Modulus>;yT12/iqZLNcrnTTFGy3NMuCjo6wJNLuG5j5L2yM6iX7CT5sWVq2BuXtdbq6PFuOIkzwJ+5Sng+qthAX5qHnuxRMI+QITe1qP+k0pOtK/EVtuedz6zdu2+Sp24CvGIMt1y8yMeOBXrRZTZzxpH9VsSq9kA/ylHKuWRfWLHysIqsdO0Tgf9eLwNAhRr6vpkvsAwvJnreIdWr/7aTrt9vq3EIJI3NYHV7/zqbZ7mKS1GbvJkAMbrQkYJ45hhEBUdYE45V8Dhkb9NTlExIcrar3vqsXSOVjQvuiGN4HsYmqPGUw26P9F7DrPyM4eQksb+PRMdkPW4dTjIRj9X3OIBHXrBw==<;/Modulus>;<;Exponent>;AQAB<;/Exponent>;<;/RSAKeyValue>;"; ;
RSAを使うのでRsaSecurityKeyを使う
*var rsa = new System.Security.Cryptography.RSACryptoServiceProvider();
トークン操作用のクラス
*var handler = new System.IdentityModel.Tokens.Jwt.JwtSecurityTokenHandler();
トークンの文字列表現
*var tokenString = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE0ODgyNjgyNDgsImV4cCI6MTQ4ODI3MTg0OCwiaWF0IjoxNDg4MjY4MjQ4LCJpc3MiOiJHSEtFTiJ9.qgyYG-q8-aDdjabt-Wp3dn3wNVIu8WGP2n8Mnv_AxrFY98Abmb96M_SP3dnZI3mDKk5NC3QYKf42cbvu20DbAAdiawAVclLMXYBgKZJqHc-5Wkq7PsGA9ECoVE2KLzKGisqHFrZUm-kv51gdCegPsANm0ukdp5CWAy26Em1og02WG9--q0peGOWgYjtE5V2sM8b861QtAsWUtUSKs6kf_r9c5bcvN2xFS4_iw5luVY0u4dSjdeaaeIOjMqLCpZaelleTAubyEdoJ89J9vz6gj6ghzYe9dvND_mlUYpfiperSceSR8eKLPtwsno0zn7DaYYqcMI5uERqUtj2YKWcIgg";
*// Audience, Issuer, Lifetimeに関してはデフォルトで検証が有効になっている*// 今回発行したトークンの内容
トークン検証用のパラメータを用意
Audience, Issuer, Lifetimeに関してはデフォルトで検証が有効になっている
今回発行したトークンの内容
Audience: 空なので検証スキップ
Issuer: "GHKEN"
Lifetime: 期限切れなので検証スキップ
*var validationParams = new Microsoft.IdentityModel.Tokens.TokenValidationParameters
第三引数にSecurityToken型の変数を参照で渡しておくと、検証済みのトークンが出力される
*handler.ValidateToken(tokenString, validationParams, out token);
ValidateTokenで検証に失敗した場合はここにやってくる
*Console.WriteLine("トークンが無効です: " + e.Message);

コードからbyteを取得(4byte)
*byte[] byteArray = BitConverter.GetBytes(sJisCharCode);
ShiftJISは2byteのため、4→2byteに変換する
*byte[] rtn = new byte[2];
*if (BitConverter.IsLittleEndian)*{
環境によってバイトの格納順を変更
1バイト文字の場合は2→1バイトに変換する
*rtn = Convert2To1ByteIfNeeded(rtn);
*if (checkArray[0] == 0)*{
1バイト文字のとき
*{return checkArray;}
2バイト文字

*public enum MonitorDefaultTo { Null, Primary, Nearest }
MonitorFromWindowが返したディスプレイの種類
*enum MonitorDpiType { Effective, Angular, Raw, Default = Effective }
GetDpiForMonitorが返したDPIの種類
*class NativeMethods {// ウィンドウハンドルから、そのウィンドウが乗っているディスプレイハンドルを取得[DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]public static extern IntPtr MonitorFromWindow(IntPtr hwnd, MonitorDefaultTo dwFlags);// ディスプレイハンドルからDPIを取得[DllImport("SHCore.dll", CharSet = CharSet.Unicode, PreserveSig = false)]public static extern void GetDpiForMonitor(IntPtr hmonitor, MonitorDpiType dpiType, ref uint dpiX, ref uint dpiY);}
NativeMethods
ウィンドウハンドルから、そのウィンドウが乗っているディスプレイハンドルを取得
*[DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
ディスプレイハンドルからDPIを取得
*[DllImport("SHCore.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
*Dpi GetDpi() {// 当該ウィンドウののハンドルを取得するvar helper = new WindowInteropHelper(this);var hwndSource = HwndSource.FromHwnd(helper.Handle);// ウィンドウが乗っているディスプレイのハンドルを取得するvar hmonitor = NativeMethods.MonitorFromWindow(hwndSource.Handle, MonitorDefaultTo.Nearest);// ディスプレイのDPIを取得するuint dpiX = Dpi.Default.X;uint dpiY = Dpi.Default.Y;NativeMethods.GetDpiForMonitor(hmonitor, MonitorDpiType.Default, ref dpiX, ref dpiY);return new Dpi(dpiX, dpiY);}
現在のディスプレイにおけるDPIを取得する
当該ウィンドウののハンドルを取得する
*var helper = new WindowInteropHelper(this);
ウィンドウが乗っているディスプレイのハンドルを取得する
*var hmonitor = NativeMethods.MonitorFromWindow(hwndSource.Handle, MonitorDefaultTo.Nearest);
ディスプレイのDPIを取得する
*uint dpiX = Dpi.Default.X;
*protected override void OnSourceInitialized(EventArgs e) {base.OnSourceInitialized(e);// 最初にDPIを取得するResizeWindowByDpi(GetDpi());}
初期化直後の処理
最初にDPIを取得する
*ResizeWindowByDpi(GetDpi());
*enum WindowMessage { DpiChanged = 0x02E0 }
DPI変更時に飛んでくるウィンドウメッセージ
*protected override void OnSourceInitialized(EventArgs e) {base.OnSourceInitialized(e);// ウィンドウメッセージを取得するvar helper = new WindowInteropHelper(this);var source = HwndSource.FromHwnd(helper.Handle);source.AddHook(new HwndSourceHook(WndProc));}
フックするルーチン
ウィンドウメッセージを取得する
*var helper = new WindowInteropHelper(this);
*IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled) {if(msg == (int)WindowMessage.DpiChanged) {// wParamの下位16bit・上位16bitがそれぞれX・Y方向のDPIを表しているvar dpiX = (uint)wParam &amp; 0xFFFF;   //下位16bitvar dpiY = (uint)wParam >;>; 16;      //上位16bitResizeWindowByDpi(new Dpi(dpiX, dpiY));handled = true;}return IntPtr.Zero;}
ウィンドウプロシージャ
wParamの下位16bit・上位16bitがそれぞれX・Y方向のDPIを表している
var dpiX = (uint)wParam &amp; 0xFFFF;   下位16bit
var dpiY = (uint)wParam &gt;&gt; 16;      上位16bit
*ResizeWindowByDpi(new Dpi(dpiX, dpiY));

コンピューター名を取得する
*string computerName = Environment.MachineName;
SID取得
*byte[] sid;
*if (!LookupAccountName(null, computerName, null, ref sidLen, domainName, ref domainNameLen, out snu)) {*int lastError = Marshal.GetLastWin32Error();
SIDに必要なメモリ領域を確認して確保する
ここもコンストラクターは空でいい気もするけど気分的にこのまま
*throw new Win32Exception(lastError);
SIDを取得する
*sid = new byte[sidLen];
*if (!ConvertSidToStringSid(sid, out pSidString)) {throw new Win32Exception();}
SIDを文字列に変換する
stringに変換
*string sidString = Marshal.PtrToStringUni(pSidString);
*if (LocalFree(pSidString) != IntPtr.Zero) {*throw new Win32Exception();
メモリの解放

効率悪い例：
*detail += "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
改善例：
*StringBuilder retSb = new StringBuilder();

*{InitializeComponent();/* 初期化処理など */this.Disposed += (sender, args) =>;{//// ここに後処理を記述//};}
コンストラクタ
ここに後処理を記述

*};

*private bool disposedValue = false;
To detect redundant calls
*// ~CSVWriter() {//   // Do not change this code. Put cleanup code in Dispose(bool disposing) above.//   Dispose(false);// }
TODO: override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources.
*{// Do not change this code. Put cleanup code in Dispose(bool disposing) above.Dispose(true);// TODO: uncomment the following line if the finalizer is overridden above.// GC.SuppressFinalize(this);}
This code added to correctly implement the disposable pattern.

*DateTimeOffset.Now.ToOffset(TimeSpan.FromHours(2.5))
UTC+2.5のタイムゾーンは存在しないはず・・・
日本時間(JST)に変換する
DateTimeOffset.Now.ToOffset(TimeSpan.FromHours(9))  JST以外に設定されている場合にエラー
*,,,
端末のタイムゾーンが切り替わる
*...

*{var maxDivisorCount = 0;for (int i = 2; i <; limit; i++){var divisorCount = CountDivisor(i);if (maxDivisorCount <; divisorCount){yield return i;maxDivisorCount = divisorCount;}}}
result:2,4,12,24,36,60,120,180,240,360,720,840,1260,1680,2520,5040,7560

*private bool disposedValue = false;
To detect redundant calls
*// ~CSVReader() {//   // Do not change this code. Put cleanup code in Dispose(bool disposing) above.//   Dispose(false);// }
TODO: override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources.
*{// Do not change this code. Put cleanup code in Dispose(bool disposing) above.Dispose(true);// TODO: uncomment the following line if the finalizer is overridden above.// GC.SuppressFinalize(this);}
This code added to correctly implement the disposable pattern.

敢えて型推論varで宣言はしません
*string hoge = "静的言語です";

*if (index >;= 0) {type_name = type_name.Remove (index) + "`1";}
ジェネリック対応処理
*foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies ()) {*foreach (var type in assembly.GetTypes ()) {
タイプ検索

*{[SubValue( "ABCDEFG" )]StringValue = 0,[SubValue( 12345 )]IntValue,[SubValue( new[] { "A", "B", "C" } )]ArrayValue,}
こんな形でEnumに属性を付けます。
こんな感じで取れます
*string   stringValue     = Example.StringValue.ToSubValue<;string>;();
*Console.WriteLine( "StringValue \t= {0}", stringValue );
出力
結果：
StringValue     = ABCDEFG
IntValue        = 12345
ArrayValue      = A,B,C
*}
カスタム属性
*[AttributeUsage( AttributeTargets.Field )]
*{public static string ToStringFromSubValue( this Enum enm ){return enm.GetType().GetRuntimeField( enm.ToString() ).GetCustomAttributes( typeof( StringAttribute ), false ).Cast<;StringAttribute>;().Single().String;}}
拡張メソッド
こんな感じで取れます
string   stringValue   = Example.StringValue.ToSubValue&lt;string&gt;();
*string   stringValue     = Example.StringValue.ToStringFromSubValue();
*Console.WriteLine( "StringValue \t= {0}", stringValue );
出力
結果：
StringValue     = ABCDEFG
*}

*open.StartInfo.RedirectStandardOutput = true;
標準出力をリダイレクトで取得したい

*Stream pngStream = snapshot.AsPNG().AsStream();
.AsJPEG() もあるよ

①stringで受け取る版
stringで入れた文字列の長さ(文字数)が、C++側に渡されるwchar_tのバッファの長さになるっぽい
string str = "";にすると、なにも帰ってこない
*string str = "AAAAAAAAAAAAAAAAAAAAAAA";
②IntPtrで受ける版
*IntPtr buf = Marshal.AllocHGlobal((int)16);
③byteで受け取る版
*var buf = new byte[16];
①stringで受け取る版
*[DllImport("DllTest.dll", CharSet = CharSet.Unicode)]
②IntPtrで受ける版
*[DllImport("DllTest.dll", EntryPoint = "CopyStringToBuffer")]
③byteで受け取る版
*[DllImport("DllTest.dll", EntryPoint = "CopyStringToBuffer")]

（こんな調子で様々な初期設定を行う）
...
*return view;

DBから現時点の情報を取得する。
*var param = new UpdateParameter(_dao)
画面の情報を反映する。
*SetValueFromView(param);
DBを更新する。
*_dao.Update(param);
画面の値を取得したパラメータのHeader1,2,3に反映する。
コードは省略
*}
*return new Header() { Id = id };
ヘッダーの取得
*return new Header2() { Code = code };
ヘッダー２の取得
*return new Header3() { Id = id };
ヘッダー３の取得
DB更新処理を実行する。コードは省略
*}
DBから現時点の情報を取得する。
*var param = new UpdateParameter();
メイン処理でDBからデータを取得する。
*param.Header = _dao.GetHeader(1);
画面の情報を反映する。
*SetValueFromView(param);
DBを更新する。
*_dao.Update(param);
画面の値を取得したパラメータのHeader1,2,3に反映する。
コードは省略
*}
Daoの参照を削除
*}
*return new Header() { Id = id };
ヘッダーの取得
*return new Header2() { Code = code };
ヘッダー２の取得
*return new Header3() { Id = id };
ヘッダー３の取得
DB更新処理を実行する。コードは省略
*}

*xmlns:l="http:
schemas.livet-mvvm.net2011wpf"
*public WPFButtonBase[] Buttons { get; }
ここ追加

*loggerMock.VerifyLogging(null, LogLevel.Warning);*loggerMock.VerifyLogging(null, LogLevel.Debug, Times.Exactly(3));
ログの内容にかかわらず、呼び出されることのみ確認
*loggerMock.VerifyLogging(null, LogLevel.Error, Times.Never());*loggerMock.VerifyLogging("testaaa", LogLevel.Warning, Times.Never());
呼び出されないことの確認
loggerMock.VerifyLogging("test", LogLevel.Debug, Times.Never()); これはログレベルが違うので失敗する
*}

*public void SqlBackup(){try{//SQLへの接続情報MySqlServerDatum.Info info = new MySqlServerDatum.Info();SqlConnection sc = new SqlConnection(info.connectionString);Server s = new Server(new ServerConnection(sc));//ここの型への名前空間はあえてフルパスにしています。Backupでも動作しますが、念のため。Microsoft.SqlServer.Management.Smo.Backup b = new Microsoft.SqlServer.Management.Smo.Backup();b.Action = BackupActionType.Database;b.Database = info.databaseName;b.Incremental = false;b.Initialize = true;b.LogTruncation = BackupTruncateLogType.Truncate;//バックアップする場所を設定BackupDeviceItem backupItemDevice = new BackupDeviceItem("C:\\"+@"\"+info.databaseName+".bak", DeviceType.File);b.Devices.Add(backupItemDevice);b.SqlBackup(s);} catch(Exception ex){}}
SQLの接続情報が入っているdll
SQLへの接続情報
*MySqlServerDatum.Info info = new MySqlServerDatum.Info();
ここの型への名前空間はあえてフルパスにしています。Backupでも動作しますが、念のため。
*Microsoft.SqlServer.Management.Smo.Backup b = new Microsoft.SqlServer.Management.Smo.Backup();
バックアップする場所を設定
*BackupDeviceItem backupItemDevice = new BackupDeviceItem("C:\\"+@"\"+info.databaseName+".bak", DeviceType.File);

*{Renderer[] renderers = gameObject.GetComponentsInChildren<;Renderer>;();foreach(Renderer renderer in renderers){renderer.material.color = color;}}
モデルのマテリアルの色を変更する

false や null を返すかもしれない
*return true;

毎回 Func&lt;object, Task&lt;object&gt;&gt; と書くのが億劫なのでエイリアスを...
*using JsAPI = System.Func<;object, System.Threading.Tasks.Task<;object>;>;;
*public static void Main() {}
emitEntryPoint を true にしているのでとりあえず入れなくてはならない

参照型だと後で変更したときにほかの部分も変わるから値型のみ受け付ける。
*public IEnumerable<;IEnumerable<;T>;>; Do<;T>;(IEnumerable<;IEnumerable<;T>;>; values, T blankValue)
*{return Enumerable.Range(0, values.Max(c =>; c.Count())).Select(i =>; values.Select(c =>; i <; c.Count() ? c.ElementAt(i) : blankValue()));}
毎回newとかさせれば上記の問題が解消できるからFuncデリゲート入れてラムダ式とかでいけるようにする。
使い方例
*var tValues = Do(values, () =>; new T());

ここにコマンド処理
*});
ここにコマンドの処理
*});

*{this.DialogResult = true;}
OK時
*{this.DialogResult = false;}
キャンセル時

一行読み込み
*var strLine = sr.ReadLine();
*if (strLine == "Fatal")*{
内容によって処理を行なうかの判定を行なう
一行ごとに行われる何らかの処理
*var printer = new InfoPrinter(strLine);
読み込み部分
*var strList = new List<;string>;();
フィルタ部分
*var strList2 = new List<;string>;();
*foreach (var strLine in strList2)*{
終端部分
一行ごとに行われる何らかの処理
*var printer = new InfoPrinter(strLine);
読み込み部分
*IEnumerable<;string>; strList = CreateSequence();
フィルタ部分
*IEnumerable<;string>; strList2 = StrFilter(strList);
終端部分
*PrintForAll(strList2);
一行ごとに行われる何らかの処理
*var printer = new InfoPrinter(strLine);
読み込み部分
*IEnumerable<;string>; strList = CreateSequence();
フィルタ部分
*IEnumerable<;string>; strList2 = StrFilter(strList).Tolist;
終端部分
*PrintForAll(strList2);

その1
*label1.BackColor = SystemColors.ActiveCaption;
その2
*label2.BackColor = Color.Transparent;
その3
*var PictureBox = Image.FromFile("../../sample.png");
その4
*flowLayoutPanel4.BorderStyle = BorderStyle.FixedSingle;

*{deltaTime = ( Time.unscaledTime - prevTime ) * timeScale;time += deltaTime;prevTime = Time.unscaledTime;}
LateUpdateなどで呼んでやる
どこかにインスタンスを保持していると仮定
var myTimer = new Timer();
*private IEnumerator インコにヘッドホンのもふもふかじられて辛い()
行き場のない気持ちに悶え３秒停止する
*yield return new WaitForSecond(3.0f * myTimer.timeScale);
どこかにインスタンスを保持していると仮定
var myTimer = new Timer();
*private void Update ()
timeScaleが減少していくにつれて抽選の当選確率が下がる
timeScale=1のとき必ず当選する
timeScale=0のとき必ず落選する
*List<;bool>; lotTable = new List<;bool>;();
くじ引きして当選していたらランダム値を獲得する
*float result = 0f;

*if (string.IsNullOrWhiteSpace(inputValue.ToString()))*{
NG こんな実装方法は思いつかなかったので、少しだけすごいと思ってしまった。
*if (!inputValue.HasValue)*{
OK プロパティを使う
*if (inputValue == null)*{
OK !Nullable.HasValueと等価なため、これでもよい。
NG 何でも文字列にすれば良いという考えは止めよう
*value = int.Parse(inputValue.ToString());
NG 無駄なキャスト1
*value = Convert.ToInt32((object)inputValue);
OK プロパティを使用
*value = inputValue.Value;
OK 無駄なキャストに見えるが、inputValue.Valueが呼ばれる。
*value = (int)inputValue;
NG 文字列にしてキャストするのは無駄が多い
*castValue = int.Parse(objectValue.ToString());
OK .Net Frameworkで用意された変換処理を使う
*castValue = Convert.ToInt32(objectValue);
OK 通常のキャスト
*castValue = (int)objectValue;

*class FileDropBehaviorC
behaivorの継承要らない
この場合、イベントの購読解除はどこでやるんだ？
*element.PreviewDragOver += Element_PreviewDragOver;

*r = g = b = 0;
black
*public static void ARGBfromAHSV(ref byte aOut, ref byte r, ref byte g, ref byte b, double aIn, double h, double s, double v){aOut = (byte)(255*aIn);r = (byte)(255*v);g = (byte)(255*v);b = (byte)(255*v);if (s <;= 0.0) return;h *= 6.0;int i = (int)h;double f = h-i;switch(i){case 0:g = (byte)(g*(1-s*(1-f)));b = (byte)(b*(1-s));break;case 1:r = (byte)(r*(1-s*f));b = (byte)(b*(1-s));break;case 2:r = (byte)(r*(1-s));b = (byte)(b*(1-s*(1-f)));break;case 3:r = (byte)(r*(1-s));g = (byte)(g*(1-s*f));break;case 4:r = (byte)(r*(1-s*(1-f)));g = (byte)(g*(1-s));break;case 5:g = (byte)(g*(1-s));b = (byte)(b*(1-s*f));break;}}
ARGBからAHSVへ変換

最大の桁数
*public int columns;
プログレスバーの長さ
*public int width;
進捗度
*public int par=0;
目標進捗度
*public int parMax;
最後に出力したカーソルの行
*protected int rowLate=CursorTop;
*public Progress(int width,int parMax){this.columns=WindowWidth;this.width=width;this.parMax=parMax;}
モノクロ版プログレスバー
*public virtual void update(string message){int row0=CursorTop;float parcent=(float)par/parMax;int widthNow=(int)Math.Floor(width*parcent);string gauge=new string('>;',widthNow)+new string(' ',width-widthNow);string status=$"({(parcent*100).ToString("f1")}%<;-{par}/{parMax})";Error.WriteLine($"#[{gauge}]#{status}");clearScreenDown();Error.WriteLine(message);rowLate=CursorTop;SetCursorPosition(0,row0);par++;}
プログレスバーの更新
*public virtual void done(string doneAlert){int sideLen=(int)Math.Floor((float)(width-doneAlert.Length)/2);string gauge=new string('=',sideLen)+doneAlert;gauge+=new string('=',width-gauge.Length);string status=$"(100%<;-{parMax}/{parMax})";clearScreenDown();Error.WriteLine($"#[{gauge}]#{status}");}
プログレスバーの完了
*protected void clearScreenDown(){int clearRange=rowLate-(CursorTop-1);Error.Write(new string(' ',columns*clearRange));SetCursorPosition(CursorLeft,CursorTop-clearRange);}
コンソール表示の掃除
*class ProgressColor:Progress{public ProgressColor(int width,int parMax):base(width,parMax){}//プログレスバーの更新public override void update(string message){int row0=CursorTop;float parcent=(float)par/parMax;int widthNow=(int)Math.Floor(width*parcent);string status=$"({(parcent*100).ToString("f1")}%<;-{par}/{parMax})";BackgroundColor=ConsoleColor.Yellow;ForegroundColor=ConsoleColor.DarkYellow;Error.Write("{");BackgroundColor=ConsoleColor.Cyan;Error.Write(new string(' ',widthNow));BackgroundColor=ConsoleColor.DarkCyan;Error.Write(new string(' ',width-widthNow));BackgroundColor=ConsoleColor.Yellow;Error.Write("}");ResetColor();Error.WriteLine(status);clearScreenDown();Error.WriteLine(message);rowLate=CursorTop;SetCursorPosition(0,row0);par++;}//プログレスバーの完了public override void done(string doneAlert){int sideLen=(int)Math.Floor((float)(width-doneAlert.Length)/2);string gauge=new string(' ',sideLen)+doneAlert;gauge+=new string(' ',width-gauge.Length);string status=$"(100%<;-{parMax}/{parMax})";clearScreenDown();BackgroundColor=ConsoleColor.Yellow;ForegroundColor=ConsoleColor.DarkYellow;Error.Write("{");BackgroundColor=ConsoleColor.Green;ForegroundColor=ConsoleColor.Red;Error.Write(gauge);BackgroundColor=ConsoleColor.Yellow;ForegroundColor=ConsoleColor.DarkYellow;Error.Write("}");ResetColor();Error.WriteLine(status);}}
カラー版プログレスバー
*public override void update(string message){int row0=CursorTop;float parcent=(float)par/parMax;int widthNow=(int)Math.Floor(width*parcent);string status=$"({(parcent*100).ToString("f1")}%<;-{par}/{parMax})";BackgroundColor=ConsoleColor.Yellow;ForegroundColor=ConsoleColor.DarkYellow;Error.Write("{");BackgroundColor=ConsoleColor.Cyan;Error.Write(new string(' ',widthNow));BackgroundColor=ConsoleColor.DarkCyan;Error.Write(new string(' ',width-widthNow));BackgroundColor=ConsoleColor.Yellow;Error.Write("}");ResetColor();Error.WriteLine(status);clearScreenDown();Error.WriteLine(message);rowLate=CursorTop;SetCursorPosition(0,row0);par++;}
プログレスバーの更新
*public override void done(string doneAlert){int sideLen=(int)Math.Floor((float)(width-doneAlert.Length)/2);string gauge=new string(' ',sideLen)+doneAlert;gauge+=new string(' ',width-gauge.Length);string status=$"(100%<;-{parMax}/{parMax})";clearScreenDown();BackgroundColor=ConsoleColor.Yellow;ForegroundColor=ConsoleColor.DarkYellow;Error.Write("{");BackgroundColor=ConsoleColor.Green;ForegroundColor=ConsoleColor.Red;Error.Write(gauge);BackgroundColor=ConsoleColor.Yellow;ForegroundColor=ConsoleColor.DarkYellow;Error.Write("}");ResetColor();Error.WriteLine(status);}
プログレスバーの完了
モノクロ版
var prg=new Progress(width,works);
カラー版
*var prg=new ProgressColor(width,works);

*abstract class Animal
加abstract关键字，表明是抽象类
在方法的返回值前加abstract表明此方法是抽象方法，抽象方法没有方法体，直接在括号后加“；”
*}
声明一个Ichangething接口，此接口有一个方法Changthing，参数是一个字符串变量，返回一字符串。
*}

メソッド定義
*public static Schedule Create(string タイトル,
省略
*}
メソッド使用時、名前付き引数で可読性をあげる
*var schedule=Schedule.Create(
*{string GetValue();}
読み取りInterface
*{void SetValue(string value);}
書き込みInterface
*{public void ReadValue(){var data = ConfigManager.Get();//何らかの処理（省略）}}
設定ファイル：読込のみ
何らかの処理（省略）
*}
*{private string _data;public void ReadValue(){_data = ConfigManager.Get();//何らかの処理（省略）}public void WriteValue(){ConfigManager.Set(_data);}}
設定ファイル：読込と書込
何らかの処理（省略）
*}
例１ infoメッセージ
*var length = "かくかくしかじか".Info("文字数取得").Length;
例２　Is
*var str = "ポチ".Is()+"犬です。"
例１
*var schedule=Schedule.Create(
例２
*var schedule=Schedule.Create()
例２（再掲）
*var schedule=Schedule.Create()
スケジュール作成時の処理（省略）
*return new Schedule();
タイトル追加の処理（省略）
*return this;
日付追加の処理（省略）
*return this;
開始時間追加の処理（省略）
*return this;
期間追加の処理（省略）
*return this;
場所追加の処理（省略）
*return this;
同行者追加の処理（省略）
*return this;
例：処理は順番に1回だけ行いたい場合
タイトル追加Interface
*public interface IScheduleAdd
*{IScheduleFrom 日付(DateTime date);}
日付追加Interface
*{IScheduleDuration 開始時間(string startTime);}
開始時刻追加Interface
*{IScheduleAt 期間(TimeSpan duration);}
期間追加Interface
*{IScheduleAdd 場所(string area);}
場所追加Interface
*{public static IScheduleAdd Create(){return new Schedule();}public IScheduleDay Addタイトル(string title){return this;}public IScheduleFrom 日付(DateTime date){return this;}public IScheduleDuration 開始時間(string startTime){return this;}public IScheduleAt 期間(TimeSpan duration){return this;}public IScheduleAdd 場所(string area){return this;}}
スケジュールクラス
*{//買い物開始public static Shopping Start(){return new Shopping();}//商品選択public Shopping SelectItem(string items){return this;}//商品試着public Shopping 試着(Action<;Fitting>; action){using (var 試着室 = FittingRoom.Prepare()){if(試着室.CanUse())action(new Fitting());}return this;}//商品購入public void 購入(){}}
Shoppingクラス
*public static Shopping Start(){return new Shopping();}
買い物開始
*{return this;}
商品選択
*{using (var 試着室 = FittingRoom.Prepare()){if(試着室.CanUse())action(new Fitting());}return this;}
商品試着
*{}
商品購入
*{//スタッフの補助ありpublic void WithHelp(string item){}//スタッフの補助なしpublic void Self(string item){}}
試着クラス
*{}
スタッフの補助あり
*{}
スタッフの補助なし
*{public static FittingRoom Prepare(){return new FittingRoom();}//試着室が使えるかチェックpublic bool CanUse(){return true;}//試着室解放public void Dispose(){}}
試着室クラス
*{return true;}
試着室が使えるかチェック
*{}
試着室解放
大筋からは試着室の事は隠ぺいし、モデルの俯瞰図的な使用をおこなっている
*var shopping = Shopping.Start()

*public class PlayerMovementSystem : SystemBase {// 移動の入力情報InputAction m_MoveInput;protected override void OnUpdate () {// 移動の入力を取得するVector2 input = m_MoveInput.ReadValue<;Vector2>;();float3 movement = new float3(input.x,0f,input.y);// 移動させるfloat deltaTime = UnityEngine.Time.deltaTime;Entities.WithAll<;Player>;().ForEach((Mover mover,ref Translation translation) =>; {translation.Value += movement * mover.Speed * deltaTime;}).WithBurst().ScheduleParallel();}}
プレイヤーを移動させるためのシステム
*protected override void OnUpdate () {// 移動の入力を取得するVector2 input = m_MoveInput.ReadValue<;Vector2>;();float3 movement = new float3(input.x,0f,input.y);// 移動させるfloat deltaTime = UnityEngine.Time.deltaTime;Entities.WithAll<;Player>;().ForEach((Mover mover,ref Translation translation) =>; {translation.Value += movement * mover.Speed * deltaTime;}).WithBurst().ScheduleParallel();}
移動の入力情報
移動の入力を取得する
*Vector2 input = m_MoveInput.ReadValue<;Vector2>;();
移動させる
*float deltaTime = UnityEngine.Time.deltaTime;
PlayerInputActionsをインスタンス化し、有効にする
*m_Input = new PlayerInputActions();
PlayerInputActionsに定義されているMoveをm_MoveInputに割り当てる
*m_MoveInput = m_Input.Player.Move;
移動の入力を取得する
*Vector2 input = m_MoveInput.ReadValue<;Vector2>;();
移動させる
*float deltaTime = UnityEngine.Time.deltaTime;

*for (int i = 0; i <; tensor.Size; i += this.Step){for (int j = 0; j <; this.RepeatNum; j++){Array.Copy(tensor.Data, i, data, i * this.RepeatNum + j * this.Step, this.Step);}}
対象となるDim以下の要素数を取得
*public Tensor[] Parameters {get;}
...
*public Tensor[] Params = new Tensor[]{};
...
*public Tensor[] Parameters{get{return this.Params;}}
...
何もしない
*}

*new PyList<;int<;() { 1 } * 4;
[1,1,1,1]
*{var temp = new PyList<;T>;(list);if (temp.Count != 0){for (int i = 0; i <; rate-1; i++)foreach (var item in list)temp.Add(item);}else{for (int i = 0; i <; rate; i++){temp.Add(default(T));}}return temp;}
*したときに複製をするようにした

*{
あったよー！

*$"{d:n1}";
123.5

*"https:
dinosaur-facts.firebaseio.com",

*using System.Windows.Forms;
OpenFileDialog用に使う
ダイアログを開く
*open_file_dialog.ShowDialog();
取得したファイル名をstringに代入する
*string file_name = open_file_dialog.FileName;

*{var destType = dest.GetType();var sourceType = source.GetType();//構造体の場合はValueTypeにいったん置き換えないと値が更新されない。//ValueType vt = dest;//構造体の場合は以下のdestをvtに置き換えが必要//お互いのフィールドとプロパティを列挙して名前が一致したものコピーするforeach (var destProperty in destType.GetProperties()){foreach (var sourceProprty in sourceType.GetProperties().Where(v =>; v.Name==destProperty.Name)){destProperty.SetValue(dest, sourceProprty.GetValue(source));}foreach (var sourceField in sourceType.GetFields().Where(v =>; v.Name==destProperty.Name)){destProperty.SetValue(dest, sourceField.GetValue(source));}}foreach (var destField in destType.GetFields()){foreach (var sourceProperty in sourceType.GetProperties().Where(v =>; v.Name==destField.Name)){destField.SetValue(dest, sourceProperty.GetValue(source));}foreach (var sourceField in sourceType.GetFields().Where(v =>; v.Name==destField.Name)){destField.SetValue(dest, sourceField.GetValue(source));}}//以下のはまた構造体のときに必要//構造体に戻す//dest = (T2)vt;}
where T2 : structこれがないとValueType vt = dest;ができない。
構造体の場合はValueTypeにいったん置き換えないと値が更新されない。
ValueType vt = dest;
構造体の場合は以下のdestをvtに置き換えが必要
お互いのフィールドとプロパティを列挙して名前が一致したものコピーする
*foreach (var destProperty in destType.GetProperties())
以下のはまた構造体のときに必要
構造体に戻す
dest = (T2)vt;
*}

*if (loginUserId == AuthorId &amp;&amp; firstApproverId == null &amp;&amp; secondApproverId == null)*{
各ボタンを非活性で初期化済み。
編集ボタン、削除ボタン、詳細表示ボタン、活性
*}
承認ボタン、差し戻しボタン、詳細表示ボタン活性
*}
詳細表示ボタン活性
*}
承認ボタン、差し戻しボタン、詳細表示ボタン活性
*}
詳細表示ボタン活性
*}
各ボタンを非活性で初期化済み。
この書き方を知らない人が私の周りでは多かった。
*bool firstApproved = firstApproverId != null;
編集ボタン、削除ボタン、活性
*}
詳細表示ボタン　活性
*}
承認ボタン、差し戻しボタン、活性
*}
承認詳細ボタン活性
*}
承認ボタン、差し戻しボタン
*}
詳細表示ボタン活性
*}
第一承認済み
*bool firstApproved = firstApproverId != null;
第二承認済み
*bool secondApproved = firstApproved &amp;&amp; secondApproverId != null;
文字列比較はEqualsでも良いが、==でも文字列比較が可能。
*bool isAuthor = AuthorId == loginUserId;
ボタン活性制御
編集ボタン
*bool editButtonEnabled = isAuthor &amp;&amp; !firstApproved;
削除ボタン
*bool deleteButtonEnabled = isAuthor &amp;&amp; !firstApproved;
承認ボタン
*bool approvalButtonEnabled = (isFirstManager &amp;&amp; !firstApproved) || (isSecoundManager &amp;&amp; !secondApproved);
詳細ボタン
*bool detailButtonEnabled = isAuthor || isFirstManager || isSecoundManager;

*int angle = 0,
degree

かなり大きめの処理なので省略…
*}

1. データ点からランダムに k 個のクラスタ平均を初期値として取る。
*var rand = new Random();
2. 収束判定のためにループ外に assignments 変数を持っておく。
*var assignments = new int[data.Length];
*while (true)*{
2. 収束するまで繰り返す。
2. 収束判定のために 1 つ前の状態をコピー。
*var prevAssignments = assignments.Select(v =>; v).ToArray();
2.1. 各データ点について、自身に最も近いクラスタに割り当てる。
*assignments = data.Select(v =>; means.IndexOf(means.MinBy(m =>; Math.Pow(v - m, 2)))).ToArray();
*if (Enumerable.Range(0, data.Length).All(i =>; assignments[i] == prevAssignments[i])) break;*// 2.2. 各クラスタについて、所属するデータ点の平均を計算して新しいクラスタ平均とする。
2. 収束していたら計算終了。
2.2. 各クラスタについて、所属するデータ点の平均を計算して新しいクラスタ平均とする。
*means = means.Select((m, i) =>; data.Where((v, j) =>; i == assignments[j]).DefaultIfEmpty(m).Average()).ToList();
1. データ点からランダムに k 個のクラスタ平均を初期値として取る。
*var rand = new Random();
2. 収束判定のためにループ外に assignments 変数を持っておく。
*var assignments = new int[data.Length];
*while (true)*,,,
2. 収束するまで繰り返す。
2. 収束判定のために 1 つ前の状態をコピー。
*var prevAssignments = assignments.Select(v =>; v).ToArray();
2.1. 各データ点について、自身に最も近いクラスタに割り当てる。
*assignments = data.Select(v =>; means.IndexOf(means.MinBy(m =>; Math.Pow(v - m, 2)))).ToArray();
*if (Enumerable.Range(0, data.Length).All(i =>; assignments[i] == prevAssignments[i])) break;*,,,
2. 収束していたら計算終了。
2.2. 各クラスタについて、所属するデータ点の平均を計算して新しいクラスタ平均とする。
*means = means.Select((m, i) =>; data.Where((v, j) =>; i == assignments[j]).DefaultIfEmpty(m).Average()).ToList();
*{var rand = new Random();var means = data.OrderBy(v =>; rand.Next()).Take(k).ToList();var assignments = new int[data.Length];while (true){var prevAssignments = assignments.Select(v =>; v).ToArray();assignments = data.Select(v =>; means.IndexOf(means.MinBy(m =>; (v - m).LengthSquared()))).ToArray();if (Enumerable.Range(0, assignments.Length).All(i =>; assignments[i] == prevAssignments[i])) break;means = means.Select((m, i) =>; data.Where((v, j) =>; i == assignments[j]).DefaultIfEmpty(m).Average()).ToList();}return Tuple.Create(means.ToArray(), assignments);}
Vector2 には System.Numerics.Vectors が必要（ライセンスに同意する必要あり）。

*if (period == null)*{
one-shot

テキストボックス等の入力項目の設定
*<;input type="submit" name="Search" value="検索">;
検索ボタンが押された場合の処理
*}
クリアボタンが押された場合の処理
*}
テキストボックス等の入力項目の設定
*<;input type="submit" name="cmd" value="検索">;
検索ボタンが押された場合の処理
*}
クリアボタンが押された場合の処理
*}
*public string ButtonName { get; set; }
アクションメソッド付加時に設定したボタン名を保存
設定したボタン名と同名のデータが存在するかチェック（Requestで返ってきているか）
*return controllerContext.Controller.ValueProvider.GetValue(ButtonName) != null;
テキストボックス等の入力項目の設定
*<;input type="submit" name="Search" value="検索">;
検索ボタンが押された場合の処理
*}

*Count = 0;
0にする
---------略------------
*}

*public void ButtonPushedByManual(){StartCoroutine(Compare(result_before, result_after));}
ボタンをクリックしたとき

*if (m.Msg == 15)
WM_PAINT == 15
描画を一旦消してしまう
*g.FillRectangle(new System.Drawing.SolidBrush(this.BackColor), this.ClientRectangle);
プレースホルダのテキスト色を、前景色と背景色の中間として文字列を描画する
*var placeholderTextColor = System.Drawing.Color.FromArgb((this.ForeColor.A >;>; 1 + this.BackColor.A >;>; 1), (this.ForeColor.R >;>; 1 + this.BackColor.R >;>; 1), ((this.ForeColor.G >;>; 1 + this.BackColor.G) >;>; 1), (this.ForeColor.B >;>; 1 + this.BackColor.B >;>; 1));

*if (connection == null)*{
don't subscribe twice

*.AddReferences("System.Core")
これが必要
何か
*}

次でアクセスできる
*Properties.Settings.Default.Properties[設定名]?.DefaultValue
次でアクセスできる
*Properties.Settings.Default.PropertyValues[設定名]?.PropertyValue

xの合計値
*float x = 0;
x^2の合計値
*float x2 = 0;
x * yの合計値
*float xy = 0;
x * zの合計値
*float xz = 0;
yの合計値
*float y = 0;
y^2の合計値
*float y2 = 0;
y * zの合計値
*float yz = 0;
zの合計値
*float z = 0;
*for (int i = 0; i <; data.Length; i++)*{
計測したデータから、各種必要なsumを得る
最小二乗平面との誤差は高さの差を計算するので、（今回の式の都合上）Yの値をZに入れて計算する
*float vx = v.x;
matA[0, 0]要素は要素数と同じ（\sum{1}のため）
*float l = 1 * data.Length;
*{{l,  x,  y},{x, x2, xy},{y, xy, y2},};
求めた和を行列の要素として2次元配列を生成
求めた値を使ってLU分解→結果を求める
*return LUDecomposition(matA, b);
行列数（Vector3データの解析なので3x3行列）
*int N = aMatrix.GetLength(0);
L行列(零行列に初期化)
*float[,] lMatrix = new float[N, N];
U行列(対角要素を1に初期化)
*float[,] uMatrix = new float[N, N];
計算用のバッファ
*float[,] buffer = new float[N, N];
*for (int i = 0; i <; N; i++)*{
LU分解開始
l1成分をコピー
*float[] l1 = new float[n];
u1^T成分をコピー
*float[] u1 = new float[n];
*for (int j = 0; j <; n; j++)*{
luを求める
A1を求める
*float[,] A1 = new float[n, n];
A1を新しいaMatrixとして利用する
*aMatrix = A1;
求めたLU行列を使って連立方程式を解く
*float[] y = new float[N];
最小二乗平面を用いた推測値を元に速度を求める
*float[] result = CalcLeastSquaresPlane(samplingData);
サンプリングした最後のデータを用いて、理想平面の値を求める
*Vector3 v = samplingData.Last();
実際に利用したいデータ
*Vector3 vec = new Vector3(v.x, y, v.z);

生成したObjectを持っておくためのList
*List<;GameObject>; list_toggle_ = new List<;GameObject>;();
インスタンスを作成
*GameObject toggle_instance = Instantiate(toggle_prefab_) as GameObject;
生成したインスタンスをリストで持っておく
*list_toggle_.Add(toggle_instance);
*for (int i = 0; i <; list_toggle_.Count; i++)*{
リストで保持しているインスタンスを削除
リスト自体をキレイにする
*list_toggle_.Clear();
生成したObjectを持っておくためのList
*List<;GameObject>; list_toggle_ = new List<;GameObject>;();
インスタンスを作成
*GameObject toggle_instance = Instantiate(toggle_prefab_) as GameObject;
生成したインスタンスをリストで持っておく
*list_toggle_.Add(toggle_instance);
リスト自体をキレイにする
*list_toggle_.Clear();
生成したObjectを持っておくためのList（ただしToggleクラスのリストを保持する)
*List<;Toggle>; list_toggle_ = new List<;GameObject>;();
インスタンスを作成(ただしGameObject)
*GameObject toggle_instance = Instantiate(toggle_prefab_) as GameObject;
生成したインスタンスをリストで持っておく(GameObject内部のToggleを取り出してリストに入れる)
*list_toggle_.Add(toggle_instance.GetComponent<;Toggle>;());
*for (int i = 0; i <; list_toggle_.Count; i++)*{
リストで保持しているインスタンスを削除（）
リスト自体をキレイにする
*list_toggle_.Clear();

作成する別名ディレクトリのリスト
*List<;string>; destDir = new List<;string>;();
1つ目の文字列だけ置換するためRegexインスタンス作成
*Regex reg = new Regex("orig");
*foreach (string dir in sourceDir)*{
取得したパスから重複を抜いてリストに登録
*if (destDir.Contains(reg.Replace(dir.Remove(dir.LastIndexOf('\\')), "TestDir", 1)))*continue;
リスト内に既に文字列がある場合はAdd処理を飛ばす
最初に出現した文字列をTestDirに置き換える
*destDir.Add(reg.Replace(dir.Remove(dir.LastIndexOf('\\')), "TestDir", 1));
*foreach (string dir in destDir)*{
ディレクトリの作成
取得したパスはエスケープがされている状態なので、そのままディレクトリ作成
*Directory.CreateDirectory(dir);
メンバ変数
*string directoryPath = @"C:\Users\watame\Desktop\orig";
対象のフォルダ以下の .txt ファイル一覧を取得
*string[] filePaths = Directory.GetFiles(directoryPath, searchFileName, SearchOption.AllDirectories);
ディレクトリの作成
*CreateDestDir(filePaths);

*private AnimatorStateInfo currentState;
現在のステート状態を保存する参照
*{// 各参照の初期化anim = GetComponent<;Animator>; ();currentState = anim.GetCurrentAnimatorStateInfo (0);startPosZ = transform.position.z;transform.position = new Vector3(transform.position.x, transform.position.y, startPosZ);}
Use this for initialization
各参照の初期化
*anim = GetComponent<;Animator>; ();
*{//向く方向の決定transform.LookAt(new Vector3(lookAtObj.position.x, 0, lookAtObj.position.z), new Vector3(0,1,0));//左クリック時の処理if (Input.GetButtonDown("Fire1")){anim.SetBool("Jump", true);transform.position = new Vector3(transform.position.x, transform.position.y, startPosZ);}//カーソルが移動した時の処理//targetとの距離がしきい値dxより大きくなったら歩くfloat dx = transform.position.x - lookAtObj.position.x;if (lookAtObj != null){if (Mathf.Abs(dx) >; 0.3f){currentState = anim.GetCurrentAnimatorStateInfo(0);anim.SetBool("Walk", true);}else{anim.SetBool("Walk", false);currentState = anim.GetCurrentAnimatorStateInfo(0);}}if (currentState.fullPathHash == walkingState){transform.position = new Vector3(transform.position.x - Mathf.Sign(dx)*0.01f, transform.position.y, startPosZ);}if (currentState.fullPathHash == standingState){transform.position = new Vector3(transform.position.x, transform.position.y, startPosZ);}}
Update is called once per frame
*transform.LookAt(new Vector3(lookAtObj.position.x, 0, lookAtObj.position.z), new Vector3(0,1,0));*//左クリック時の処理
向く方向の決定
*if (Input.GetButtonDown("Fire1"))*{
左クリック時の処理
カーソルが移動した時の処理
targetとの距離がしきい値dxより大きくなったら歩く
*float dx = transform.position.x - lookAtObj.position.x;

*class Ref{public class Box{public int value;public Box(int value){this.value = value;}}//関数定義時と呼び出し時にrefをつけると参照渡しになるpublic static void Foo(ref Box box){box.value = 42;}public static void Bar(ref Box box){box = new Box(42);}public static void Main(string[] args){Box box1 = new Box(334);Console.WriteLine("foo: ");Console.WriteLine(box1.value);Foo(ref box1);Console.WriteLine(box1.value);Box box2 = new Box(334);Console.WriteLine("bar: ");Console.WriteLine(box2.value);Bar(ref box2);Console.WriteLine(box2.value);}}
C#
*public static void Foo(ref Box box){box.value = 42;}
関数定義時と呼び出し時にrefをつけると参照渡しになる
*class Ptr{public class Box{public int value;public Box(int value){this.value = value;}}//refをつけないとクラスは参照の値渡しになるpublic static void Foo(Box box){box.value = 42;}public static void Bar(Box box){box = new Box(42);}public static void Main(string[] args){Box box1 = new Box(334);Console.WriteLine("foo: ");Console.WriteLine(box1.value);Foo(box1);Console.WriteLine(box1.value);Box box2 = new Box(334);Console.WriteLine("bar: ");Console.WriteLine(box2.value);Bar(box2);Console.WriteLine(box2.value);}}
C#
*public static void Foo(Box box){box.value = 42;}
refをつけないとクラスは参照の値渡しになる

*for (int i = 0; i <; this.Out.Size; i+=step){*for (int j = 0; j ; repNum; j++){
総和処理

*Console.WriteLine(exp.MyFunction(exp.MyValue, exp.AnotherValue));
30
*{Console.WriteLine($"{nameof(TryConvert)} : {binder.Type}");if (binder.Type != typeof(int)){return base.TryConvert(binder, out result);}result = _x;return true;}
キャスト
*{Console.WriteLine($"{nameof(TryUnaryOperation)} : {binder.Operation}");switch (binder.Operation){case ExpressionType.UnaryPlus:result = _x;return true;default:return base.TryUnaryOperation(binder, out result);}}
単項演算
*{Console.WriteLine($"{nameof(TryBinaryOperation)} : {binder.Operation}");switch (binder.Operation){case ExpressionType.Add:result = _x + (arg as MyDynamic)?._x ?? 0;return true;default:return base.TryBinaryOperation(binder, arg, out result);}}
二項演算
*{Console.WriteLine($"{nameof(TryGetMember)} : {binder.Name}");switch (binder.Name){case "X":result = _x;return true;default:return base.TryGetMember(binder, out result);}}
プロパティの get
*{Console.WriteLine($"{nameof(TrySetMember)} : {binder.Name} = {value}");switch (binder.Name){case "X":_x = value is int ? (int)value : 0;return true;default:return base.TrySetMember(binder, value);}}
プロパティの set
*{Console.WriteLine($"{nameof(TryGetIndex)} : [{indexes.Select(x =>; x.ToString()).Aggregate((x, y) =>; $"{x}, {y}")}]");if (!indexes.All(x =>; x is int)){return base.TryGetIndex(binder, indexes, out result);}result = indexes.Cast<;int>;().Aggregate((x, y) =>; x + y);return true;}
インデクサの get
*{Console.WriteLine($"{nameof(TrySetIndex)} : [{indexes.Select(x =>; x.ToString()).Aggregate((x, y) =>; $"{x}, {y}")}] = {value}");if (!indexes.All(x =>; x is int) &amp;&amp; value is int){return base.TrySetIndex(binder, indexes, value);}_x = indexes.Cast<;int>;().Aggregate((x, y) =>; x + y) + (int)value;return true;}
インデクサの set
*{Console.WriteLine($"{nameof(TryInvokeMember)} : {binder.Name}({(args.Length == 0 ? "" : args.Select(x =>; x.ToString()).Aggregate((x, y) =>; $"{x}, {y}"))})");if (!args.All(x =>; x is string)){return base.TryInvokeMember(binder, args, out result);}result = args.Cast<;string>;().Aggregate((x, y) =>; x + y);return true;}
メンバ呼び出し
*{Console.WriteLine($"{nameof(TryInvoke)} : ({(args.Length == 0 ? "" : args.Select(x =>; x.ToString()).Aggregate((x, y) =>; $"{x}, {y}"))})");result = null;return true;}
自身に () をつけて呼び出し

塗りつぶす
*grph.Clear( Color.Black );
四角い枠を描く
*grph.DrawRectangle( Pens.Aqua, 90, 50, 160, 50 );
*using ( Font font = new Font( "Arial", 20 ) ) {grph.DrawString( "ABCDEFG", font, Brushes.White, 100, 60 );}
枠の中に文字を書く
後略
*}
四角い枠を描く
*float scale = grph.DpiX / 96f;
四角い枠を描く
*float scale = grph.DpiX / 96f;
塗りつぶす
*grph.Clear( Color.Black );
DPIに合わせてワールド変換を設定
*float scale = grph.DpiX / 96f;
*using ( Pen pen = new Pen( Color.Aqua, 1 / scale ) ) {grph.DrawRectangle( pen, 90, 50, 160, 50 );}
四角い枠を描く
*using ( Font font = new Font( "Arial", 20 / scale ) ) {grph.DrawString( "ABCDEFG", font, Brushes.White, 100, 60 );}
枠の中に文字を書く
*grph.Transform = morg;*}
ワールド変換を元に戻しておく

*Process.Start("https:
twitter.com"); ここはスキなのでいいです。Unityのとこも

*{textBox.Dispatcher.Invoke((Action)(() =>;{int i = 0;textBox.Text += $"CallBack   inferID[{inferID}] : [inputImage] = {inputImage}" + System.Environment.NewLine;foreach (float result in results){textBox.Text += $"CallBack   inferID[{inferID}] : [{i}] = {Math.Round(result, 4, MidpointRounding.AwayFromZero)}" + System.Environment.NewLine;i += 1;}textBox.Text += $"---------------------" + System.Environment.NewLine;}));}
dll側から呼ばれる
*textBox.Text +=  $"[{i}] :  {Math.Round(output, 4, MidpointRounding.AwayFromZero)}" + System.Environment.NewLine;
textBox.Text += string.Format("{0} : {1:f4}", i, outputVec[i]) + System.Environment.NewLine;
*{instance.Initialize(networkInfo);instance.SetInferCallBack(obj);foreach (string inputImage in inputImageFiles){instance.InferASync(inputImage);}});
instance.GetAvailableDevices();

コンパイルが成功するための実装。
*return v.X <;= v.Y

*{new City { Id = 0, Name = "tokyo", Path = "./path/tokyo" },new City { Id = 1, Name = "osaka", Path = "./path/osaka" }};
1. List作成
2. Findで取得
*string filepath = cityList.Find(x =>; x.Id == 0).Path;
表示確認
*Console.WriteLine(filepath);

*private static string baseAddress = "http:
localhost:9000";
戻り値
*object result = null;
取得対象のデータがrouteDataに含まれていたら、返す。
含まれていなければ、&lt;T&gt;のdefaultを返す
*if (routeData.Values.TryGetValue(name, out result))

*var uwq = UnityWebRequest.Get("http:
google.com");

*ApplyVacation?.Invoke(this, e);
C#6.0以上でのみ可能

データをdataGridView品目リストにセットする--------------------------------------
*SqlConnection connection = new SqlConnection();
DataSet ds = new DataSet();        データセットに格納する場合
*DataTable dt = new DataTable();
接続文字列を設定します。
Formメイン f = new Formメイン();     他のフォームからPublic変数を呼び出し。
*connection.ConnectionString = f.DB接続文字列;
SQLを実行し結果をdsの中に格納します。
【お勉強】Fill()でOpen/Closeを自動で行ってくれるので、記述不要。
但し、Openしたら、Close要。
adapter.Fill(ds);             データセット格納する場合
*adapter.Fill(dt);
dataGridView品目リストの設定----------------------------------------------------
ユーザの操作規制　←これはFormのLoadへ持って行っても良い
dataGridView品目リスト.ReadOnly = true;                      読取専用
dataGridView品目リスト.AllowUserToDeleteRows = false;        行削除禁止
dataGridView品目リスト.AllowUserToAddRows = false;           行挿入禁止
dataGridView品目リスト.AllowUserToResizeRows = false;        行の高さ変更禁止
dataGridView品目リスト.RowHeadersVisible = false;            行ヘッダーを非表示にする
dataGridView品目リスト.MultiSelect = false;                  ル、行、列が複数選択禁止
dataGridView品目リスト.SelectionMode = DataGridViewSelectionMode.FullRowSelect;      　セルを選択すると行全体が選択されるようにする
ヘッダー名変更
*dataGridView品目リスト.Columns[0].HeaderText = "品目コード";
カラム幅設定
*dataGridView品目リスト.Columns[0].Width = 60;

*hp -= damage;
hp から damageを引き算する

*...
bitmapに対する処理
フォーマット指定
*bitmap.Save("save.png", System.Drawing.Imaging.ImageFormat.Png);
画像塗りつぶし
*g.FillRectangle(Brushes.White,g.VisibleClipBounds);
*using( Pen p = new Pen(Color.Black,1)){// またはPens.Black;// 線を引くg.DrawLine(p,x,y,x2,y2);// 長方形g.DrawRectangle(p,x,y,w,h);}
幅1pxのペン
または
*Pens.Black;
線を引く
*g.DrawLine(p,x,y,x2,y2);
長方形
*g.DrawRectangle(p,x,y,w,h);

*struct MyStruct
Error ( Field ' MyStruct.myString ' must be fully assigned before it leaves the constructor ).

*{// Add framework services.services.AddApplicationInsightsTelemetry(Configuration);services.AddDbContext<;ApplicationDbContext>;(options =>;options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));services.AddIdentity<;ApplicationUser, IdentityRole>;().AddEntityFrameworkStores<;ApplicationDbContext>;().AddDefaultTokenProviders();//DBContextを読み込むservices.AddDbContext<;ScaffoldDBContext>;(); // この行を追加services.AddMvc();// Add application services.services.AddTransient<;IEmailSender, AuthMessageSender>;();services.AddTransient<;ISmsSender, AuthMessageSender>;();}
This method gets called by the runtime. Use this method to add services to the container.
DBContextを読み込む
services.AddDbContext&lt;ScaffoldDBContext&gt;();  この行を追加
*services.AddMvc();

*if (Input.GetKeyDown(playerLeftButton))*{
左右のキー入力でキャラクターを90度旋回する

*list.ForEach(Console.WriteLine);
1 3 5

*Debug.Log("test");
testと表示される

*using APP_NAME.Models;
環境依存
ユーザーの追加
*var user = new ApplicationUser();
ハッシュ化する
*user.PasswordHash = new PasswordHasher().HashPassword("test@test.com");
SecurityStampを設定する（これがNullだと認証でエラーとなる）
*user.SecurityStamp = Guid.NewGuid().ToString();
追加処理
*ApplicationDbContext adb = new ApplicationDbContext();
そのままサインイン処理
*var signInManager = this.HttpContext.GetOwinContext().Get<;ApplicationSignInManager>;();
*var user = new ApplicationUser { UserName = model.Email, Email = model.Email };
抜粋
UserManager生成（ユーザーを検索するため：生成にも使える）
*var userManager = this.HttpContext.GetOwinContext().GetUserManager<;ApplicationUserManager>;();
SignInManager生成（認証するため）
*var signInManager = this.HttpContext.GetOwinContext().Get<;ApplicationSignInManager>;();
サインアウト
*AuthenticationManager.SignOut(DefaultAuthenticationTypes.ApplicationCookie);
*{get{return HttpContext.GetOwinContext().Authentication;}}
ヘルパー
*{}
for role
RoleManagerの取得
*var roleManager = this.HttpContext.GetOwinContext().Get<;ApplicationRoleManager>;();
*roleManager.Create(new ApplicationRole { Name = "admin"});
Roleの生成
UserManagerの取得
*var userManager = this.HttpContext.GetOwinContext().GetUserManager<;ApplicationUserManager>;();
adminにするユーザーの検索
*var user = userManager.Find("test@test.com", "test@test.com");
紐づけ
*userManager.AddToRole(user.Id, "admin");
adminのみにアクセスを許可
*[Authorize(Roles ="admin")]

以下、コンストラクタを実行する処理
*RealProxy rp = RemotingServices.GetRealProxy(this._target);
以下、コンストラクタ以外のメソッドを実行する処理
*string execFlag = ConfigurationManager.AppSettings["ASYNC_EXEC_FLAG"];
メソッド実行
*res = RemotingServices.ExecuteMessage(this._target, call);
メソッド前処理
*Console.WriteLine("非同期キューにSEND：start");
メソッド実行
*res = new ReturnMessage(0, null, 0, null, call);

XorShift乱数ジェネレータの初期化
論文デフォルトシード
*var r_def=new XorShift.defaultSeed();
*var r_const=new XorShift(100);*// 時間シード
固定値シード
*var r=new XorShift();*//デフォルトシード値の取得
時間シード
デフォルトシード値の取得
*Console.WriteLine(">;>; defaults");
適用したシード値の取得
*Console.WriteLine(">;>; seeds in r");
*for(int i=0;i<;5;i++){Console.WriteLine(r_def.rand());}
乱数の生データを取得
*for(int i=0;i<;5;i++){Console.WriteLine(r_const.randInt(0,100));}
0-100の乱数(100含む)を整数で取得
*for(int i=0;i<;5;i++){Console.WriteLine(r.randFloat());}
0-1の乱数を浮遊小数点で取得
静的配列のシャッフル
値渡しとなるので元の配列は破壊されない
*Console.WriteLine(">;>; shuffle Array");
List&lt;T&gt;のシャッフル
*Console.WriteLine(">;>; shuffle List<;T>;");
今の乱数を回した回数
*Console.WriteLine(">;>; randCount in r");

*Debug.Log( "func2:" + func2.NullSafe(1) + ";" );
"func2:;"

*[SerializeField] private float azimuthalAngle = 45.0f;
angle with x-axis

*(x) =<; -1
f'
*public static Tensor Minus(Tensor In){return new Lambda("Minus",(x) =>; -x,(x) =>; -1).Forward(In);}
-X
*public static Tensor ReLU(Tensor In){return new Lambda("ReLU",(x) =>; x >; 0 ? x : 0,(x) =>; x >; 0 ? 1 : 0).Forward(In);}
ReLU
*public static Tensor Exp(Tensor In){return new Lambda("Exp",(x) =>; System.Math.Exp(x),(x) =>; System.Math.Exp(x)).Forward(In);}
Exponential
*public static Tensor Log(Tensor In){return new Lambda("Log_e",(x) =>; System.Math.Log(x),(x) =>; 1 / x).Forward(In);}
Log

*var inc = (int x) =<; x + 1;
エラー

*{if (disposable == null) throw new ArgumentNullException(nameof(disposable));if(_disposable!=null) throw new InvalidOperationException();_disposable = disposable;}
This method is not protected from multi thread.

*someFunction(notBeConverted);
大丈夫

*this.label_x.Text = TempStr;
ラベルに値を書き込み値を保管。
PictureBoxに書き込む
*描画();
doubleに変換可能
↓
描画先とするImageオブジェクトを作成する
*Bitmap canvas = new Bitmap(pictureBox1.Width, pictureBox1.Height);
ImageオブジェクトのGraphicsオブジェクトを作成する
*Graphics g = Graphics.FromImage(canvas);
座標軸
*g.DrawLine(Pens.Black, 0, 100, 200, 100);
基本円
*g.DrawEllipse(Pens.Black, 0, 0, 200, 200);
x,yの座標を確定→floatに変換
R = Math.PI * (d * 90) / 180;  ラジアンを確保！
*x = (float)(100 * Math.Cos(R));
リソースを解放する
*g.Dispose();
PictureBox1に表示する
*pictureBox1.Image = canvas;

*pin.SetDriveMode(GpioPinDriveMode.Output);
GPIO5を出力モードにする
終了処理
*pin.Dispose();

ベジェ線の入ったPrefabをセット
*public BezierCurve Curve;
移動にかける時間（秒）
*public float MoveTime = 2f;
現在の地点を保持
*private int _currentPoint;
経過時間
*private float _currentTime;
移動完了フラグ
*private bool _isComplete;
こういうのが嫌ならCorutine使ってwhile(true)で回して、
_isCompleteの条件があったらbreakでいいと思う。
*if(_isComplete) return;
カーブに沿って移動
ポイント１とポイント２の間に作られるカーブの、xx%時点での位置を取得する
*transform.position =
*if (_currentTime >; MoveTime)*{
現在時間が移動時間を超えたら100%過ぎてるので次のカーブへ行く

*baseDir = args[1];
アセンブリパス

*yield return null;
1フレーム待機

*.Subscribe(_ =<; this.TestMessage.Text += $"LongPressed!:{DateTime.Now}\n");
実行したいメソッド
100になるまでGenerateしてもらいます。この100がトリガーです。
*var progress = down
ProgressというボタンとProgressBarというプログレスバーがあったとします
*this.Progress
Resumableという名前のボタンがあるとします。
*this.Resumable

*context.GetLink(IDocument);
IDocument型を渡す方が多いと思います

*{public byte a;public byte r;public byte g;public byte b;public Pixel(byte b, byte g, byte r, byte a){this.a = a;this.r = r;this.g = g;this.b = b;}}
RGBA のバイト情報をピクセル単位で扱えるようにするためのクラス
*{// ビットマップをピクセルデータに変換するpublic static IList<;Pixel>; ConvertBitmapToPixels(Bitmap bitmap){byte[] byteArray = null;using (bitmap){byteArray = ConvertBitmapToByteArray(bitmap);}var ret = new List<;Pixel>;();for (var i = 0; i <; byteArray.Length; i += 4){ret.Add(new Pixel(byteArray[i + 0],byteArray[i + 1],byteArray[i + 2],byteArray[i + 3]));}return ret;}// ビットマップをバイト配列に変換するprivate static byte[] ConvertBitmapToByteArray(Bitmap bitmap){var ret = new byte[bitmap.Width * bitmap.Height * 4];BitmapData bitmapData = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),ImageLockMode.ReadOnly,PixelFormat.Format32bppArgb);Marshal.Copy(bitmapData.Scan0, ret, 0, ret.Length);bitmap.UnlockBits(bitmapData);return ret;}// ピクセルデータをビットマップに戻すpublic static Bitmap ConvertPixelsToBitmap(IList<;Pixel>; pixels, int width, int height){var byteArray = new byte[width * height * 4];var index = 0;foreach (var pixel in pixels){byteArray[index++] = pixel.b;byteArray[index++] = pixel.g;byteArray[index++] = pixel.r;byteArray[index++] = pixel.a;}return ConvertByteArrayToBitmap(byteArray, width, height);}// バイト配列をビットマップに戻すprivate static Bitmap ConvertByteArrayToBitmap(byte[] byteArray, int width, int height){Bitmap ret = new Bitmap(width, height);BitmapData bitmapData = ret.LockBits(new Rectangle(0, 0, ret.Width, ret.Height),ImageLockMode.ReadWrite,PixelFormat.Format32bppArgb);Marshal.Copy(byteArray, 0, bitmapData.Scan0, byteArray.Length);ret.UnlockBits(bitmapData);return ret;}}
ビットマップとピクセルデータ間の変換処理を行うクラス
*{byte[] byteArray = null;using (bitmap){byteArray = ConvertBitmapToByteArray(bitmap);}var ret = new List<;Pixel>;();for (var i = 0; i <; byteArray.Length; i += 4){ret.Add(new Pixel(byteArray[i + 0],byteArray[i + 1],byteArray[i + 2],byteArray[i + 3]));}return ret;}
ビットマップをピクセルデータに変換する
*{var ret = new byte[bitmap.Width * bitmap.Height * 4];BitmapData bitmapData = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),ImageLockMode.ReadOnly,PixelFormat.Format32bppArgb);Marshal.Copy(bitmapData.Scan0, ret, 0, ret.Length);bitmap.UnlockBits(bitmapData);return ret;}
ビットマップをバイト配列に変換する
*{var byteArray = new byte[width * height * 4];var index = 0;foreach (var pixel in pixels){byteArray[index++] = pixel.b;byteArray[index++] = pixel.g;byteArray[index++] = pixel.r;byteArray[index++] = pixel.a;}return ConvertByteArrayToBitmap(byteArray, width, height);}
ピクセルデータをビットマップに戻す
*{Bitmap ret = new Bitmap(width, height);BitmapData bitmapData = ret.LockBits(new Rectangle(0, 0, ret.Width, ret.Height),ImageLockMode.ReadWrite,PixelFormat.Format32bppArgb);Marshal.Copy(byteArray, 0, bitmapData.Scan0, byteArray.Length);ret.UnlockBits(bitmapData);return ret;}
バイト配列をビットマップに戻す
*{// 画像ファイルの拡張子から決定するpublic static ImageFormat ResolveFromExtension(string extension){switch (extension.ToLower()){case ".bmp": return ImageFormat.Bmp;case ".gif": return ImageFormat.Gif;case ".jpg":case ".jpeg": return ImageFormat.Jpeg;case ".png":default: return ImageFormat.Png;}}}
画像ファイルの保存形式 ImageFormat を決定するクラス
*{switch (extension.ToLower()){case ".bmp": return ImageFormat.Bmp;case ".gif": return ImageFormat.Gif;case ".jpg":case ".jpeg": return ImageFormat.Jpeg;case ".png":default: return ImageFormat.Png;}}
画像ファイルの拡張子から決定する

*if (Input.GetKeyDown(KeyCode.Escape))
初期位置へスポーン
*var rotate = (-mouseY * transform.right + mouseX * transform.up + -h * transform.forward).normalized;*// 与える力の計算（線形補間）
トルクベクトルの計算
*if (v >;= 0) power = Mathf.Lerp(power, maxPower, v * accel * Time.deltaTime);*else power = Mathf.Lerp(power, 0, -v * accel * Time.deltaTime);
与える力の計算（線形補間）
*body.AddForce(transform.forward * power);*body.AddTorque(rotate * toruque);
力を与える

*{}
Use this for initialization
*{this.transform.position += this.transform.forward;if (Input.GetKey(KeyCode.S)){transform.Rotate(-0.5f, 0, 0);}if (Input.GetKey(KeyCode.W)){transform.Rotate(0.5f, 0, 0);}if (Input.GetKey(KeyCode.A)){transform.Rotate(0, 0, 0.5f);}if (Input.GetKey(KeyCode.D)){transform.Rotate(0, 0, -0.5f);}}
Update is called once per frame

*{
スピンボタンから編集
５回Upする
*up.EmulateClick();
２回Downする
*dw.EmulateClick();
確定
*var commitButton = new WPFButtonBase(subLogicalTree.ByBinding("CommitCommand").Single());
ちゃんと年齢が書き換わっている（元の値から+5、-2されている）ことを確認
*Assert.AreEqual((int.Parse(age) + 5 - 2).ToString() , dataGrid.GetCellText(0, 1));
IntegerUpDownのVisualTreeから検索
*return new Tuple<;ButtonBase, ButtonBase>;(IntegerUpDown.Descendants<;ButtonBase>;().First(c =>; c.Name == "PART_IncreaseButton"),

*{private void ThisAddIn_Startup(object sender, System.EventArgs e){Application.ItemSend += Application_ItemSend;Application.OptionsPagesAdd += Application_OptionsPagesAdd;}void Application_OptionsPagesAdd(Outlook.PropertyPages Pages){Pages.Add(new MyPropPage(), "General");// 複数ページあれば、さらに Add します。}// .... ほかのコードがあれば続行}
Outlook:ThisAddin.cs
複数ページあれば、さらに Add します。
*}
.... ほかのコードがあれば続行
*}
MyPropPage.cs : 「ユーザーコントロール」をテンプレートにプロパティページを作成します。COM 参照可能なよう ComVisible(true) 属性をつけ、Microsoft.Office.Interop.Outlook.PropertyPage インターフェイスを組み込みます。
*[System.Runtime.InteropServices.ComVisible(true)]
「設定 (Settings)」に UserName（String 型）を記憶させ、プロパティシート上の textBoxUserName（テキストボックス）で変更を扱う場合
*textBoxUserName.Text = Properties.Settings.Default.UserName;
*if (_propertyPageSite != null)*_propertyPageSite.OnStatusChange();
テキストボックスが編集されたら、OnStatusChange メソッドで通知します。
プロパティ変更の通知先を得ます
=&gt; リフレクションを利用して .NET ライブラリ中の System.Windows.Forms.UnsafeNativeMethods.IOleObject クラスにある GetClientSite メソッドを呼び出します。
*Type type = typeof(System.Object);
OK や 適用ボタンをクリックされたときの処理を記述します。
*Properties.Settings.Default.UserName = textBoxUserName.Text;
適用ボタンを有効にしたい状態の場合は true を返すようにします。ここでは、「設定」の記憶値とテキストボックスの値が異なっている場合に true を返すようにしています。
*return (textBoxUserName.Text != Properties.Settings.Default.UserName);
ヘルプファイル (.chm) を指定できるようです。不要なら何も書かないでよいです。
*}
.... ほかのコードがあれば
*}

*static readonly string fileName = $@"{Application.StartupPath}\r.xml";
独自データのファイルは、実行時のフォルダに固定名称で r.xml としておく
独自データ読込
*XmlSerializer s = new XmlSerializer(typeof(RFile));
独自データ保存
*XmlSerializer s = new XmlSerializer(typeof(RFile));

*int form_num = this.OwnedForms.Length;*MessageBox.Show("children form : " + form_num.ToString());
どれだけの画面からOwnerに指定されているか
*// children form : 3*Form[] form_info = this.OwnedForms;
メッセージボックスに表示される結果
*Form[] form_info = this.OwnedForms;*for (int i = 0; i ; form_info.Length; i++)
children form : 3
メッセージボックスに表示される結果
this is c1
this is c2
this is c3
*}

*index = 0;
インデックスをリセット

*{
ブロックの形と色のパターンをswtich文で実装。

*Console.WriteLine("終了");
ここに到達できません

*dynamic dx = 1;
dx の型は dynamic 型

*StreamReader reader = new StreamReader(templatePath, Encoding.GetEncoding("Shift_JIS"));*string template = reader.ReadToEnd();
テンプレートを読み込んでtempに格納
テンプレート中の文字列"#SCRIPTNAME#"をスクリプト名に置換
*string scriptText = template.Replace("#SCRIPTNAME#", scriptName);
csファイルとしてScriptsフォルダに保存
*File.WriteAllText("Assets/Scripts/" + scriptName + ".cs", scriptText, Encoding.UTF8);
一時ファイルを生成し、必要な情報(ここではスクリプト名のみ)を書き込んで保存
*File.WriteAllText(tempFilePath, scriptName, Encoding.UTF8);
*if (File.Exists(tempFilePath)) {*StreamReader reader = new StreamReader(tempFilePath, Encoding.GetEncoding("Shift_JIS"));
一時ファイルがあれば処理
スクリプト名を読み込み
*scriptName = reader.ReadLine();
空のGameObjectを生成してスクリプトをアタッチし、プレハブ化(後述)
*CreateAttachedPrefab();
一時ファイルの削除
*File.Delete(tempFilePath);
空のGameObjectの生成
*GameObject go = new GameObject(scriptName);
生成したスクリプトをアタッチ
*go.AddComponent(Type.GetType(scriptName));
プレハブの生成
*string prefabPath = "Assets/" + scriptName + ".prefab";
コンパイル中は操作できないように
*EditorGUI.BeginDisabledGroup(EditorApplication.isCompiling);
スクリプト名を入力
*scriptName = EditorGUILayout.TextField("ScriptName", scriptName);
*if (GUILayout.Button("Create")) {*CreateNewScript();
Createボタンを押してスクリプトと一時ファイルを生成し、ウィンドウを閉じる
*StreamReader reader = new StreamReader(templatePath, Encoding.GetEncoding("Shift_JIS"));*string template = reader.ReadToEnd();
テンプレートを読み込んでtempに格納
テンプレート中の文字列"#SCRIPTNAME#"をスクリプト名に置換
*string scriptText = template.Replace("#SCRIPTNAME#", scriptName);
csファイルとしてScriptsフォルダに保存
*File.WriteAllText("Assets/Scripts/" + scriptName + ".cs", scriptText, Encoding.UTF8);
一時ファイルを生成し、必要な情報(ここではスクリプト名のみ)を書き込んで保存
*File.WriteAllText(tempFilePath, scriptName, Encoding.UTF8);
*if (File.Exists(tempFilePath)) {*StreamReader reader = new StreamReader(tempFilePath, Encoding.GetEncoding("Shift_JIS"));
一時ファイルがあれば処理
スクリプト名を読み込み
*scriptName = reader.ReadLine();
空のGameObjectを生成してスクリプトをアタッチし、プレハブ化
*CreateAttachedPrefab();
一時ファイルの削除
*File.Delete(tempFilePath);
空のGameObjectの生成
*GameObject go = new GameObject(scriptName);
生成したスクリプトをアタッチ
*go.AddComponent(Type.GetType(scriptName));
プレハブの生成
*string prefabPath = "Assets/" + scriptName + ".prefab";

*Application.OpenURL("https:
twitter.comintenttweet?text=hello&amp;hashtags=way");

*float[] data = new float[44100];
音声データを格納する配列
*while (isRec) {*rec.clip = Microphone.Start ("マイク名", false, 1, 44100);
録音を繰り返す

TODO:その内プロパティ化
*encoding = System.Text.Encoding.GetEncoding(932);
TODO: 必要そうならその内、開き方を指定できるようにする
*fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
*if (length <; len)*OnRenewted(new EventArgs());
ファイルサイズが小さくなったら、ログが変わったと判断する
*if (length >; len)*{
長さが大きくなっていたら、ログが追記されたと判断する
TODO: 最初に大容量のファイルを開かれた場合、問題になるかもしれないので、その内検証する
*byte[] bs = new byte[length - len];

現在アクティブなVisioファイルの取得方法
*Visio.Document activeDocument = this.Application.ActiveDocument;

/|*|こんにちは。|*|/
/|*+------------+*|/
/+----------------+/
実行が一瞬で終わって確認できないので、キーの入力を待ちます
*Console.ReadLine();
*{public abstract int Columns { get; }public abstract int Rows { get; }public abstract string GetRowText(int row);public void Show(){for(int i = 0; i <; Rows; i++){Console.WriteLine(GetRowText(i));}}}
・機能を追加するときの核
*{private string str;public StringDisplay(string str){this.str = str;}public override int Columns{get{Encoding sjisEnc = Encoding.GetEncoding("shift_jis");return sjisEnc.GetByteCount(str);}}public override int Rows{get { return 1; }}public override string GetRowText(int row){if (row == 0){return str;}else{return null;}}}
・Componentを実装
・Componentと同じインターフェース（API）を持つ
・飾る対象となるComponentを持つ
*public abstract class Border : Display
*{private char borderChar;public SideBorder(Display display, char ch) : base(display){this.borderChar = ch;}public override int Columns{get{return 1 + display.Columns + 1;}}public override int Rows{get{return display.Rows;}}public override string GetRowText(int row){return borderChar + display.GetRowText(row) + borderChar;}}
・Decoratorを実装
*{public FullBorder(Display display) : base(display) { }public override int Columns{get{return 1 + display.Columns + 1;}}public override int Rows{get{return 1 + display.Rows + 1;}}public override string GetRowText(int row){if (row == 0){return "+" + MakeLine('-', display.Columns) + "+";}else if (row == display.Rows + 1){return "+" + MakeLine('-', display.Columns) + "+";}else{return "|" + display.GetRowText(row - 1) + "|";}}private string MakeLine(char ch, int count){StringBuilder sb = new StringBuilder();for (int i = 0; i <; count; i++){sb.Append(ch);}return sb.ToString();}}
・Decoratorを実装

*internal PtrHandle<;UnLoadJobInfo<; _info;
UnLoadJob の管理情報

*{// UserManager<;ApplicationUser>; ->; UserManager<;ApplicationUser, int>;public async Task<;ClaimsIdentity>; GenerateUserIdentityAsync(UserManager<;ApplicationUser, int>; manager){var userIdentity = await manager.CreateIdentityAsync(this, DefaultAuthenticationTypes.ApplicationCookie);return userIdentity;}}
IdentityUser -&gt; IdentityUser&lt;int, CustomUserLogin, CustomUserRole, CustomUserClaim&gt;
*{var userIdentity = await manager.CreateIdentityAsync(this, DefaultAuthenticationTypes.ApplicationCookie);return userIdentity;}
UserManager&lt;ApplicationUser&gt; -&gt; UserManager&lt;ApplicationUser, int&gt;
*{// base("DefaultConnection", throwIfV1Schema: false) ->; base("DefaultConnection")public ApplicationDbContext(): base("DefaultConnection"){}public static ApplicationDbContext Create(){return new ApplicationDbContext();}}
IdentityDbContext&lt;ApplicationUser&gt; -&gt; IdentityDbContext&lt;ApplicationUser, CustomRole, int, CustomUserLogin, CustomUserRole, CustomUserClaim&gt;
*{// IUserStore<;ApplicationUser>; ->; IUserStore<;ApplicationUser, int>;public ApplicationUserManager(IUserStore<;ApplicationUser, int>; store): base(store){}public static ApplicationUserManager Create(IdentityFactoryOptions<;ApplicationUserManager>; options, IOwinContext context){// UserStore<;ApplicationUser>;() ->; UserStore<;ApplicationUser, CustomRole, int, CustomUserLogin, CustomUserRole, CustomUserClaim>;()var manager = new ApplicationUserManager(new UserStore<;ApplicationUser, CustomRole, int, CustomUserLogin, CustomUserRole, CustomUserClaim>;(context.Get<;ApplicationDbContext>;()));...,,,public void ConfigureAuth(IAppBuilder app){...app.UseCookieAuthentication(new CookieAuthenticationOptions{AuthenticationType = DefaultAuthenticationTypes.ApplicationCookie,LoginPath = new PathString("/Account/Login"),Provider = new CookieAuthenticationProvider{// OnValidateIdentity<;ApplicationUserManager, ApplicationUser>; ->; OnValidateIdentity<;ApplicationUserManager, ApplicationUser, int>;OnValidateIdentity = SecurityStampValidator.OnValidateIdentity<;ApplicationUserManager, ApplicationUser, int>;(validateInterval: TimeSpan.FromMinutes(30),// regenerateIdentity ->; regenerateIdentityCallbackregenerateIdentityCallback: (manager, user) =>; user.GenerateUserIdentityAsync(manager),// 【getUserIdCallbackを追加】getUserIdCallback: (id) =>; id.GetUserId<;int>;())}});,,,// XxxxClass<;ApplicationUser>;XxxxClass<;ApplicationUser, int>;// User.Identity.GetUserId();User.Identity.GetUserId<;int>;();// function(string userId)// if (userId == null)function(int userId)if (userId == default(int)),,,public class ApplicationUser : IdentityUser{},,,public class IdentityUser : IdentityUser<;string>;{public IdentityUser();public IdentityUser(string userName);},,,public class IdentityUser<;TKey>; : IdentityUser<;TKey, IdentityUserClaim<;TKey>;, IdentityUserRole<;TKey>;, IdentityUserLogin<;TKey>;>; where TKey : IEquatable<;TKey>;{public IdentityUser();},,,// IdentityUser ->; IdentityUser<;int>;public class ApplicationUser : IdentityUser<;int>;{},,,// IdentityDbContext<;ApplicationUser>; ->; IdentityDbContext<;ApplicationUser, IdentityRole<;int>;, int>;public class ApplicationDbContext : IdentityDbContext<;ApplicationUser, IdentityRole<;int>;, int>;{public ApplicationDbContext(DbContextOptions<;ApplicationDbContext>; options): base(options){}...},,,public class Startup{...public void ConfigureServices(IServiceCollection services){services.AddDbContext<;ApplicationDbContext>;(options =>;options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));// AddIdentity<;ApplicationUser, IdentityRole>; ->; AddIdentity<;ApplicationUser, IdentityRole<;int>;>;// AddEntityFrameworkStores<;ApplicationDbContext>; ->; AddEntityFrameworkStores<;ApplicationDbContext, int>;services.AddIdentity<;ApplicationUser, IdentityRole<;int>;>;().AddEntityFrameworkStores<;ApplicationDbContext, int>;().AddDefaultTokenProviders();...,,,【getUserIdCallbackを追加】
*getUserIdCallback: (id) =>; id.GetUserId<;int>;())
*// if (userId == null)*function(int userId)
function(string userId)
*{},,,// IdentityDbContext<;ApplicationUser>; ->; IdentityDbContext<;ApplicationUser, IdentityRole<;int>;, int>;public class ApplicationDbContext : IdentityDbContext<;ApplicationUser, IdentityRole<;int>;, int>;{public ApplicationDbContext(DbContextOptions<;ApplicationDbContext>; options): base(options){}...},,,public class Startup{...public void ConfigureServices(IServiceCollection services){services.AddDbContext<;ApplicationDbContext>;(options =>;options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));// AddIdentity<;ApplicationUser, IdentityRole>; ->; AddIdentity<;ApplicationUser, IdentityRole<;int>;>;// AddEntityFrameworkStores<;ApplicationDbContext>; ->; AddEntityFrameworkStores<;ApplicationDbContext, int>;services.AddIdentity<;ApplicationUser, IdentityRole<;int>;>;().AddEntityFrameworkStores<;ApplicationDbContext, int>;().AddDefaultTokenProviders();...,,,*{public ApplicationDbContext(DbContextOptions<;ApplicationDbContext>; options): base(options){}...},,,public class Startup{...public void ConfigureServices(IServiceCollection services){services.AddDbContext<;ApplicationDbContext>;(options =>;options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));// AddIdentity<;ApplicationUser, IdentityRole>; ->; AddIdentity<;ApplicationUser, IdentityRole<;int>;>;// AddEntityFrameworkStores<;ApplicationDbContext>; ->; AddEntityFrameworkStores<;ApplicationDbContext, int>;services.AddIdentity<;ApplicationUser, IdentityRole<;int>;>;().AddEntityFrameworkStores<;ApplicationDbContext, int>;().AddDefaultTokenProviders();...,,,
*System.GC.Collect();
ファイナライズされたばかりのオブジェクトに関連するメモリを開放

*using System.Threading;
EventWaitHandle

*webBrowser1.Navigate($"http:
www.upload.nicovideo.jpedit?f={e.Node.Tag}");

参照が必要な処理
*}
参照が必要な処理
*}

その他のメソッドは省略しています
*}

対応するViewModelを割り出し、プロパティ公開しているICommandを取り出す
*var viewModel = this.BindingContext as GamePageViewModel;
CocosSharp側の基底LayerにStatic公開しているICommandプロパティに渡してやる
*BaseLayer.GameEndCommand = cmd;
*{if (this.IsBusy) return;this.IsBusy = true;await this.NavigationService.NavigateAsync(Consts.NavigationUrl.HOME_PAGE);this.IsBusy = false;}, () =>; !this.IsBusy);
プロパティ公開しているコマンドでしかるべき処理（今回はPrism画面遷移）
NOTE:リソースの解放やらなにやら
終了処理として受け渡されているコマンドを実行
中身はViewModelで定義の通りゲームページからホームページへの遷移
UIスレッドで動かす必要があるためDevice.BeginInvokeOnMainThreadをかませる
*Device.BeginInvokeOnMainThread(() =>;

*webBrowser1.Navigate($"http:
www.upload.nicovideo.jpedit?f={e.Node.Tag}");

改行検索
*Regex regex = new Regex("\n");

ファイルテンプレートをロードします。
*doc.LoadFromFile("リスト.docx");
リストのデータに更新します。
*doc.Replace("a.price", "5.5", true, true);
フィールドを更新します。
*doc.IsUpdateFields = true;
保存します。
*doc.SaveToFile("output.docx", FileFormat.Docx2013);

*richTextBox2.Update();
step4

*String fileName = "";
任意のファイルパス
ファイルを読込専用、他プロセスからの読書き可能として開き、読込んで読込み位置を取得する
*FileStream fs = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
指定のファイルのみ更新された際に、非同期にイベントを呼出す
*FileSystemWatcher fsw = new FileSystemWatcher();
オープンファイルダイアログを表示
*OpenFileDialog dlg = new OpenFileDialog();
TODO:ファイルが選ばれなかった場合などの処理が必要
ファイルを読込専用、他プロセスからの読書き可能として開き、読込んで読込み位置を取得する
*fs = new FileStream(dlg.FileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
指定のファイルのみ、更新された際に非同期にイベントを呼出す
*fsw = new FileSystemWatcher();
ファイルを一時的に読み込むバイト型配列を作成する
*byte[] bs = new byte[0x1000];
*for (;;)*{
ファイルをすべて読み込む
ファイルの一部を読み込む
*int readSize = fs.Read(bs, 0, bs.Length);
*if (readSize == 0)*break;
ファイルをすべて読み込んだときは終了する
部分的に読み込んだデータを使用したコードをここに記述する
*tb.Text += System.Text.Encoding.GetEncoding(932).GetString(bs);
カーソルを行末に移動して、スクロールさせる
*tb.SelectionStart = tb.Text.Length;
ファイルの先頭から指定した位置までストリーム内の読込み位置を変更し、追加分のデータを読込んで、読込み位置を最後の位置にする
*fs.Seek(pos, SeekOrigin.Begin);

配列数
*int num = 1000000;
繰り返し回数
*int loop = 10;
*using(IEnumerator<;T>; en = collection.GetEnumerator()) {while(en.MoveNext()) {Add(en.Current);}}
This enumerable could be empty.  Let Add allocate a new array, if needed.
*using(IEnumerator<;T>; en = collection.GetEnumerator()) {while(en.MoveNext()) {Add(en.Current);}}
Note it will also go to _defaultCapacity first, not 1, then 2, etc.

重い処理
*System.Threading.Thread.Sleep(1000);
*{lock(this.progressBar1) {this.progressBar1.Value += 1;}}));
コントロールの制御
重い処理
*System.Threading.Thread.Sleep(1000);
*{lock(this.progressBar1) {this.progressBar1.Value += 1;}}));
コントロールの制御

word objectを作成します。
*Document document = new Document();
sectionとparagraphを追加します。
*Section section = document.AddSection();
paragraphにテキストを追加します。
*paragraph.AppendText("今日の日付: ");
日付フィールドを設定します。
*Field field = paragraph.AppendField("Date", FieldType.FieldData) as Field;
保存します。
*document.SaveToFile("Sample.docx", FileFormat.Docx2013);
*string[] fieldName = { "Count" };
CreateFieldメソッドを使用して値を指定します。
Ifフィールドに値をマージします。
*document.MailMerge.Execute(fieldName, fieldValue);
フィールドを更新します。
*document.IsUpdateFields = true;
保存します
*document.SaveToFile("sample.docx", FileFormat.Docx);
*IfField ifField = new IfField(document);*ifField.Type = FieldType.FieldIf;
Ifフィールドを追加して条件を設定します。
TOCを追加します
*paragraph.AppendTOC(1, 3);
段落にテキストを追加します。
*Paragraph para1 = section.AddParagraph();
TOCを更新します
*document.UpdateTableOfContents();
保存します
*document.SaveToFile("TOC.docx", FileFormat.Docx);

*var doubledEnumerable = oddEnumerable.Select(x =<; x * 2);
=&gt; 4,8,12,16

ウォッチフェイスのスタイルを設定します。
*SetWatchFaceStyle(
ユーザーからのタップイベントを有効にするかどうか設定します。
true  : 有効
false : 無効（デフォルト）
.SetAcceptsTapEvents( true )
通知が来た時の通知カードの高さを設定します。
*.SetCardPeekMode( WatchFaceStyle.PeekModeShort )
通知カード（small cardの表示時）の背景の表示方法を設定します。
WatchFaceStyle.BackgroundVisibilityInterruptive : 一部の重要な通知に限り、表示します。（デフォルト）
WatchFaceStyle.BackgroundVisibilityPersistent   : 通知カードの種類にかかわらず、表示します。
*.SetBackgroundVisibility( WatchFaceStyle.BackgroundVisibilityInterruptive )
システムUIのデジタル時計を表示するするかどうかを設定します。（使用している例として、デフォルトで用意されている「シンプル」があります。）
true  : 表示
false : 非表示（デフォルト）
*.SetShowSystemUiTime( false )
設定したスタイル情報をビルドします。このメソッドは最後に呼び出します。
*.Build()
背景用のグラフィックスオブジェクトを生成します。
*backgroundPaint = new Paint();
リソースから背景色を読み込みます。
*backgroundPaint.Color = resources.GetColor( Resource.Color.background );
時針用のPaintグラフィックスオブジェクトを生成します。
*hourHandPaint = new Paint();
時針の幅を設定します。
*hourHandPaint.StrokeWidth = resources.GetDimension( Resource.Dimension.hour_hand_stroke );
アンチエイリアスを有効にします。
*hourHandPaint.AntiAlias = true;
線端の形は丸形を指定します。
*hourHandPaint.StrokeCap = Paint.Cap.Round;
分針用のPaintグラフィックスオブジェクトを生成します。
*minuteHandPaint = new Paint();
秒針用のPaintグラフィックスオブジェクトを生成します。
*secondHandPaint = new Paint();
時刻を格納するオブジェクトを生成します。
*nowTime = Java.Util.Calendar.GetInstance( Java.Util.TimeZone.Default );
非推奨となった方法
*backgroundPaint.Color = owner.Resources.GetColor( Resource.Color.background );
代わりに推奨された方法
*int argb = ContextCompat.GetColor( owner, Resource.Color.background );
注 : ContextCompat.GetColorメソッドの戻り値を、Paint.Colorプロパティに直接代入できません。
*backgroundPaint.Color = ContextCompat.GetColor( owner, Resource.Color.background );
UpdateTimeHandlerにセットされているメッセージを削除します。
*updateTimeHandler.RemoveMessages( MessageUpdateTime );
Android Wearのウィンドウが丸形かどうかを判別します。
bool isRound = insets.IsRound;
*}
アンビエントモード時、Low-Bit制限を必要とするかどうかの値を取得します。
*isRequiredLowBitAmbient = properties.GetBoolean( PropertyLowBitAmbient, false );
アンビエントモード時、焼き付き防止を必要とするかどうかの値を取得します。
*isReqiredBurnInProtection = properties.GetBoolean( PropertyBurnInProtection, false );
ウォッチフェイスを再描画します。
*Invalidate();
*if( isAmbient != inAmbientMode ) {*// 現在のアンビエントモードをセットします。
アンビエントモードが変更されたかどうかを判別します。
現在のアンビエントモードをセットします。
*isAmbient = inAmbientMode;
*if( isRequiredLowBitAmbient ) {*bool antiAlias = !inAmbientMode;
デバイスがLow-Bit制限を必要とするかどうかを判別します。
アンビエントモードの時は、針のPaintオブジェクトのアンチエイリアスを無効にし、
そうでなければ有効にします。
*hourHandPaint.AntiAlias = antiAlias;
ウォッチフェイスを再描画します。
*Invalidate();
タイマーを更新します。
*UpdateTimer();
UpdateTimeHandlerからMessageUpdateTimeメッセージを取り除きます。
*updateTimeHandler.RemoveMessages( MessageUpdateTime );
*if( ShouldTimerBeRunning ) {*// UpdateTimeHandlerにMessageUpdateTimeメッセージをセットします。
UpdateTimeHandlerを動作させるかどうかを判別します。
UpdateTimeHandlerにMessageUpdateTimeメッセージをセットします。
*updateTimeHandler.SendEmptyMessage( MessageUpdateTime );
InterruptionフィルターがInterruptionFilterNoneであるかどうか判別します。
*bool inMuteMode = ( interruptionFilter == InterruptionFilterNone );
*if( isMute != inMuteMode ) {*isMute = inMuteMode;
ミュートモードが変更されたかどうか判別します。
ウォッチフェイスを再描画します。
*Invalidate();
*switch( tapType ) {case TapTypeTouch:// TODO : ユーザーが画面をタッチした時の処理を入れます。break;case TapTypeTouchCancel:// TODO : ユーザーが画面をタッチしたまま、指を動かした時の処理を入れます。break;case TapTypeTap:// TODO : ユーザーがタップした時の処理を入れます。break;}
タップの種類を判別します。
TODO : ユーザーが画面をタッチした時の処理を入れます。
*break;
TODO : ユーザーが画面をタッチしたまま、指を動かした時の処理を入れます。
*break;
TODO : ユーザーがタップした時の処理を入れます。
*break;
中略
*}
*if( IsInAmbientMode ) {*// アンビエントモードの時は、黒色で塗りつぶします。
アンビエントモードであるかどうか判別します。
アンビエントモードの時は、黒色で塗りつぶします。
*canvas.DrawColor( Color.Black );
そうでない時は、背景画像を描画します。
*canvas.DrawRect( 0, 0, canvas.Width, canvas.Height, backgroundPaint );
中心のXY座標を求めます。
*float centerX = bounds.Width() / 2.0f;
針の長さを求めます。
*float hourHandLength = centerX - 80;
時針の先端のXY座標を求めます。
*float hourHandRotation = ( ( nowTime.Get( Java.Util.CalendarField.Hour ) + ( nowTime.Get( Java.Util.CalendarField.Minute ) / 60f ) ) / 6f ) * ( float )Math.PI;
時針を描画します。
*canvas.DrawLine( centerX, centerY, centerX + hourHandX, centerY + hourHandY, hourHandPaint );
分針の先端のXY座標を求めます。
*float minuteHandRotation = nowTime.Get( Java.Util.CalendarField.Minute ) / 30f * ( float )Math.PI;
分針を描画します。
*canvas.DrawLine( centerX, centerY, centerX + minuteHandX, centerY + minuteHandY, minuteHandPaint );
*if( !isAmbient ) {*// 秒針の先端のXY座標を求めます。
アンビエントモードでないかどうかを判別します。
秒針の先端のXY座標を求めます。
*float secondHandRotation = nowTime.Get( Java.Util.CalendarField.Second ) / 30f * ( float )Math.PI;
分針を描画します。
*canvas.DrawLine( centerX, centerY, centerX + secondHandX, centerY + secondHandY, secondHandPaint );
*if( visible ) {*// TimeZoneReceiverが未初期化の時、ここで初期化します。
ウォッチフェイスの表示・非表示を判別します。
*if( timeZoneReceiver == null ) {*timeZoneReceiver = new TimeZoneReceiver(
TimeZoneReceiverが未初期化の時、ここで初期化します。
タイムゾーン用のレシーバーを登録します。
*var intentFilter = new IntentFilter( Intent.ActionTimezoneChanged );
ウォッチフェイスが描画されていない時にタイムゾーンが変化した場合の備え、現在タイムゾーンの時の現在時刻を取得します。
*nowTime = Java.Util.Calendar.GetInstance( Java.Util.TimeZone.Default );
タイムゾーン用のレシーバーを登録解除します。
*Application.Context.UnregisterReceiver( timeZoneReceiver );
タイマーの動作を更新します。
*UpdateTimer();
*public override void OnPropertiesChanged( Bundle properties ) {base.OnPropertiesChanged( properties );isRequiredLowBitAmbient = properties.GetBoolean( PropertyLowBitAmbient, false );isReqiredBurnInProtection = properties.GetBoolean( PropertyBurnInProtection, false );}
bool isRound = insets.IsRound;

中略
*}
四角形
*[MetaData( "com.google.android.wearable.watchface.preview", Resource = "@drawable/preview" )]
丸形
*[MetaData( "com.google.android.wearable.watchface.preview_circular", Resource = "@drawable/preview_circular" )]
中略
*}
*public class AnalogWatchFaceService : CanvasWatchFaceService {// インタラクティブモードにおける更新間隔（ミリ秒単位）を表します。// Java.Util.Concurrent.TimeUnit.Seconds.ToMillisメソッドは、指定した秒の値をミリ秒に変換します。（※）private static readonly long InteractiveUpdateRateMilliseconds = Java.Util.Concurrent.TimeUnit.Seconds.ToMillis( 1 );// インタラクティブモードにて、定期的に時刻を更新するための、ハンドラー用のメッセージのIDを表します。// 値は何でもOKです。private const int MessageUpdateTime = 0;// 中略}
中略
インタラクティブモードにおける更新間隔（ミリ秒単位）を表します。
Java.Util.Concurrent.TimeUnit.Seconds.ToMillisメソッドは、指定した秒の値をミリ秒に変換します。（※）
*private static readonly long InteractiveUpdateRateMilliseconds = Java.Util.Concurrent.TimeUnit.Seconds.ToMillis( 1 );
インタラクティブモードにて、定期的に時刻を更新するための、ハンドラー用のメッセージのIDを表します。
値は何でもOKです。
*private const int MessageUpdateTime = 0;
中略
*}
*public class AnalogWatchFaceService : CanvasWatchFaceService {// 中略private class AnalogWatchFaceEngine : CanvasWatchFaceService.Engine {}}
中略
*private class AnalogWatchFaceEngine : CanvasWatchFaceService.Engine {}
中略
*public class AnalogWatchFaceService : CanvasWatchFaceService {// 中略public override WallpaperService.Engine OnCreateEngine() {return new AnalogWatchFaceEngine( this );}private class AnalogWatchFaceEngine : CanvasWatchFaceService.Engine {}}
中略
*public override WallpaperService.Engine OnCreateEngine() {return new AnalogWatchFaceEngine( this );}
中略
CanvasWatchFaceServiceオブジェクトの参照を格納します。
*private CanvasWatchFaceService owner;
時刻を更新する時の処理を行うハンドラーを表します。
*private readonly Handler updateTimeHandler;
現在時刻を表します。
*private Java.Util.Calendar nowTime;
背景用のペイントオブジェクトを表します。
*private Paint backgroundPaint;
時針、分針、秒針用のオブジェクトを表します。
*private Paint hourHandPaint;
アンビエントモードであるかどうかを表します。
*private bool isAmbient;
アンビエントモード時、デバイスがLow-Bitの制限を必要としているかどうかを表します。
*private bool isRequiredLowBitAmbient;
アンビエントモード時、デバイスが焼き付け防止を必要としているかどうかを表します。
*private bool isReqiredBurnInProtection;
ミュート状態であるかどうかを表します。
*private bool isMute;
タイムゾーンを変更した時に通知を受け取るレシーバーを表します。（※）
*private TimeZoneReceiver timeZoneReceiver;
中略
*}
*public class TimeZoneReceiver : BroadcastReceiver {// タイムゾーンを変更した通知を受け取った時に実行するデリゲートを表します。private Action<;Intent>; receiver;// OnReceiveメソッドで実行する処理をpublic TimeZoneReceiver( Action<;Intent>; _receiver ) {receiver = _receiver;}// タイムゾーンを変更した通知を受け取った時に実行します。public override void OnReceive( Context context, Intent intent ) {receiver?.Invoke( intent );}}
タイムゾーンを変更した時に通知を受け取るレシーバーを提供します。
タイムゾーンを変更した通知を受け取った時に実行するデリゲートを表します。
*private Action<;Intent>; receiver;
*public TimeZoneReceiver( Action<;Intent>; _receiver ) {receiver = _receiver;}
OnReceiveメソッドで実行する処理を
*public override void OnReceive( Context context, Intent intent ) {receiver?.Invoke( intent );}
タイムゾーンを変更した通知を受け取った時に実行します。
CanvasWatchFaceServiceクラスを継承したオブジェクトの参照をセットします。
*this.owner = owner;
*message =>; {// Whatプロパティでメッセージを判別します。switch( message.What ) {case MessageUpdateTime:// TODO : 時刻の更新のメッセージの時の処理を入れます。// ウォッチフェイスを再描画します。Invalidate();// UpdateTimeHandlerを動作させるかどうかを判別します。if( ShouldTimerBeRunning ) {long timeMillseconds = DateTime.UtcNow.Ticks / TimeSpan.TicksPerMillisecond;// delayMs = 更新間隔 - ( 現在時刻（ミリ秒） % 更新間隔) ->; 更新間隔との差long delayMilliseconds = InteractiveUpdateRateMilliseconds - ( timeMillseconds % InteractiveUpdateRateMilliseconds );// UpdateTimeHandlerにメッセージをセットします。// SendEmptyMessageDelayedメソッドは指定した時間後にメッセージを発行します。updateTimeHandler.SendEmptyMessageDelayed( MessageUpdateTime, delayMilliseconds );}break;}}
時刻を更新する時の処理を構成します。
*switch( message.What ) {case MessageUpdateTime:// TODO : 時刻の更新のメッセージの時の処理を入れます。// ウォッチフェイスを再描画します。Invalidate();// UpdateTimeHandlerを動作させるかどうかを判別します。if( ShouldTimerBeRunning ) {long timeMillseconds = DateTime.UtcNow.Ticks / TimeSpan.TicksPerMillisecond;// delayMs = 更新間隔 - ( 現在時刻（ミリ秒） % 更新間隔) ->; 更新間隔との差long delayMilliseconds = InteractiveUpdateRateMilliseconds - ( timeMillseconds % InteractiveUpdateRateMilliseconds );// UpdateTimeHandlerにメッセージをセットします。// SendEmptyMessageDelayedメソッドは指定した時間後にメッセージを発行します。updateTimeHandler.SendEmptyMessageDelayed( MessageUpdateTime, delayMilliseconds );}break;}
Whatプロパティでメッセージを判別します。
TODO : 時刻の更新のメッセージの時の処理を入れます。
ウォッチフェイスを再描画します。
*Invalidate();
*if( ShouldTimerBeRunning ) {*long timeMillseconds = DateTime.UtcNow.Ticks / TimeSpan.TicksPerMillisecond;
UpdateTimeHandlerを動作させるかどうかを判別します。
delayMs = 更新間隔 - ( 現在時刻（ミリ秒） % 更新間隔) -&gt; 更新間隔との差
*long delayMilliseconds = InteractiveUpdateRateMilliseconds - ( timeMillseconds % InteractiveUpdateRateMilliseconds );
UpdateTimeHandlerにメッセージをセットします。
SendEmptyMessageDelayedメソッドは指定した時間後にメッセージを発行します。
*updateTimeHandler.SendEmptyMessageDelayed( MessageUpdateTime, delayMilliseconds );
TimeZoneReceiverのインスタンスを生成します。
*timeZoneReceiver = new TimeZoneReceiver(
*intent =>; {// 新しいタイムゾーンを設定します。nowTime.TimeZone = Java.Util.TimeZone.Default;}
BroadcastReceiver.OnReceiveメソッドの実行時に実行します。
新しいタイムゾーンを設定します。
*nowTime.TimeZone = Java.Util.TimeZone.Default;
UpdateTimeHandlerを動作させるかどうかを表す値を取得します。
*private bool ShouldTimerBeRunning =>;
GetStringExtraメソッドで、Android Wearとペアリングしているスマートフォンで設定したタイムゾーンのIDを取得します。
*nowTime.Clear( intent.GetStringExtra( "time-zone" ) );
TimeZone.Defaultプロパティは、Android Wearとペアリングしているスマートフォンで設定しているタイムゾーンのIDを取得します。
もちろん、AndroidのTimeクラスのように、GetStringExtraメソッドで取得したタイムゾーンのIDを設定してもOK
*nowTime.TimeZone = Java.Util.TimeZone.Default;
DateTime.Nowプロパティで取得する時刻は、Android Wearとペアリングしているスマートフォンで
設定しているタイムゾーンが適用されています。
*nowTime = DateTime.Now;

*videoCallBackFlg = false;
コールバック済みフラグをリセット
〜〜省略
*,,,
〜〜省略
*GameSceneSingleton.Instance.setVideoSdkCallbackListener(this);

処理
*sw.Stop();

*{if (Sd1_on.activeSelf){time += Time.deltaTime;if (Input.GetKeyDown(KeyCode.F)){audioSource.PlayOneShot(Operandum1SE);if (time >;= FITime){audioSource.PlayOneShot(PointSE);CountText.text = "Point : " + Point.ToString();Point += 1;time = 0;}}}if (Sd1_off.activeSelf){time = 0;}}
New
*if (Sd1_on.activeSelf)*{
New_1
*if (time >;= FITime)*{
New_2
*for (i = 0; i <; values.Length; i++)*{
New_2
*if (Sd1_on.activeSelf)*{
New_3
*if (first)*{
New_4
*for (i = 0; i <; values.Length; i++)*{
New_2
*if (Sd1_on.activeSelf)*{
New_3
*if (first)*{
New_4

*var index = 1;
1 からの連番
今回なにもする必要なし
*}
今回なにもする必要なし
*}
今回なにもする必要なし
*}

*dictionary.TryGetValue(key, out result);
keyが見つからない場合は result に default(TValue) が代入される

*this.salesforce予定表TableAdapter.Fill(this.sharePointDataSet.Salesforce予定表);*// TODO: このコード行はデータを 'salesforceDataSet.Event' テーブルに読み込みます。必要に応じて移動、または削除をしてください。
TODO: このコード行はデータを 'sharePointDataSet.Salesforce予定表' テーブルに読み込みます。必要に応じて移動、または削除をしてください。
*this.eventTableAdapter.Fill(this.salesforceDataSet.Event);*,,,
TODO: このコード行はデータを 'salesforceDataSet.Event' テーブルに読み込みます。必要に応じて移動、または削除をしてください。

*x =<; x.Type == "http:
schemas.xmlsoap.orgws200505identityclaimsnameidentifier")?.Value;

*c.myEvent += func1;
イベントの登録
呼出側が、発生側のクラスに登録するメソッド
*private void func1(string txt) =>; Debug.WriteLine(txt);
*{// デリゲートを登録public delegate void TestDelegate(string txt);public TestDelegate myDelegate;// イベントを登録public event TestDelegate myEvent;// Actionもデリゲートなので、eventにできるpublic event Action<;string>; myAction;// 登録したイベント/デリゲートを読んでみるメソッドpublic void doFunc(TestDelegate func){myDelegate?.Invoke("デリゲートです");myAction?.Invoke("アクションです");myEvent?.Invoke("イベントです");}}
「発生側」のクラス
デリゲートを登録
*public delegate void TestDelegate(string txt);
イベントを登録
*public event TestDelegate myEvent;
Actionもデリゲートなので、eventにできる
*public event Action<;string>; myAction;
*{myDelegate?.Invoke("デリゲートです");myAction?.Invoke("アクションです");myEvent?.Invoke("イベントです");}
登録したイベント/デリゲートを読んでみるメソッド
*{textbox1.Text = temperature.ToString();}
View/ViewModelが用意するメソッド
温度更新時に読んでほしいメソッドをModelに登録
*sensorModel.OnSensorDataReceived += OnSensorDataReceived;

*string targetName = name;
ここがポイント

*VoiceClient.Send(buffer, 0, blockSize);
Send the buffer to Discord

*X509ChainStatusFlags.UntrustedRoot;
ルート証明書が信頼されていない
*if (sslPolicyErrors == SslPolicyErrors.None)*{
エラーがなければ OK
*if (TrustedThumbprints.Contains(((X509Certificate2)certificate).Thumbprint))*{
信頼するハッシュリストと比較し、一致するなら OK
*if ((sslPolicyErrors &amp; ~SslPolicyErrors.RemoteCertificateChainErrors) != 0)*{
SslPolicyError.RemoteCertificateChainErrors 以外のエラーがあるなら NG
*for (int i = 0; i <; chain.ChainStatus.Length; ++i)*{
IgnoreChainStatus 以外のチェーンエラーがあるなら NG
*for (int i = 0; i <; chain.ChainElements.Count; ++i)*{
証明書チェーン内に信頼する証明書と一致するものがあれば OK とする
*//By default, we trust all certificates.*return true;
This is where you implement logic to determine if you trust the certificate.

*switch (Start.Key)
エンターキーが押されたときの動作

移動速度を数パターン設定（後進は-で定義)
*public float moveSpeed  = 10.0f;
Gyroセンサーを感知
*currentGyro = Input.gyro.attitude;
*float angle = diveCamera.transform.eulerAngles.x;*// 2.ある角度以内であれば前進させる
1.カメラの傾きを取得
*if (moveAngleX <; angle &amp;&amp; angle <; moveAngleXX) {*moveForward ();
2.ある角度以内であれば前進させる
*public void moveForward() {Vector3 direction = new Vector3 (diveCamera.transform.forward.x, 0, diveCamera.transform.forward.z).normalized * moveSpeed * Time.deltaTime;Quaternion rotation = Quaternion.Euler (new Vector3 (0, -diveCamera.transform.rotation.eulerAngles.y, 0));diveCamera.transform.Translate (rotation * direction);diveCamera.transform.position = new Vector3 (diveCamera.transform.position.x, yOffset, diveCamera.transform.position.z);}
2.速度に合わせて移動(moveForward,runForward,moveBackward)を定義

*});
Parallel.For

*WritingCreator.ReleaseDate = DateTime.Now;
投稿時の日付を自動記載

*| ActivityFlags.ExcludeFromRecents
最近使ったアプリの一覧に表示しない
ゲームの起点画面に遷移
*var scene = Layers.GameStartLayer.GetScene(mainWindow);
Helpersはアプリ内でGlobalに使いまわす自作ヘルパ
*gv.DesignResolution = new CCSizeI(Helpers.Settings.AppWidth, Helpers.Settings.AppHeight);
戻るボタン無効化するならfalse
*return base.OnBackButtonPressed();
GameImageLoader.GetSpriteはAssemblyからpng読み出してCCSpriteインスタンスを作り返すメソッド
*CommonImagesCache.Add(key.ToKey(), GameImageLoader.GetSprite(key.ToName()));

*reticle.transform.position = hit.point + (hit.normal * hitRayPosition);
hitRayPosition は画像が当たった対象にめり込まない程度に設定する
略
*}
*else {reticle.transform.localPosition = new Vector3(0, 0, defaultPos.z);reticle.transform.localRotation = defaultRotation;}
デフォルトのRayの位置

*new Claim("http:
schemas.xmlsoap.orgws200505identityclaimsnameidentifier", userid)
Principalを生成し、HttpContextのUserにセットする。
*var principal = new GenericPrincipal(identity, null);
テスト対象のコントローラを生成し、ControllerContextをセットする。
*ctrl = new TestCardsController();
未使用DLLはテストプロジェクトの実行領域にコピーされないためインスタンスを生成する。
*var instance = System.Data.Entity.SqlServer.SqlProviderServices.Instance;

*ExtensionConfiguration = new ExtensionConfiguration()
Diagnosticsの拡張機能とロールを紐づける
デプロイ実行 ComputeManagementClientを以下の様に利用する
*var response = managementClient.Deployments.Create(CloudServiceName, deploymentSlot, parameters);

*Bitmap bitmap;
保存したいBitmapが格納済み
保存する画像の名前を決める
*String imgname = "img_";
保存先のパスとか
*ContextWrapper cw = new ContextWrapper(this.ApplicationContext);
*{bitmap.Compress(Android.Graphics.Bitmap.CompressFormat.Png, 100, os);}
保存

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

*.DisableDirectStreaming()
これはデバッグ用

第一引数が初期値で、第二引数は繰り返し回数になる。1ずつインクリメントされる。
*Enumerable.Range(0, 100)

メインテクスチャのコピー
*Graphics.Blit(mainTexture, paintMainTexture);
マテリアルのテクスチャをRenderTextureに変更
*material.SetTexture(mainTexturePropertyID, paintMainTexture);

*int LengthValue = 0;
一行の配列の長さ
CRLF分減らす
*LengthValue = EndPoint - StartPoint + 1 - 2;
行データ取得
*byte[] LineVal = GetByteFromByte(_GetBinData, StartPoint, LengthValue);
取込データ出力
*int count = 0;
*if (_GetBinData[i] == 0xD &amp; _GetBinData[i + 1] == 0xA)*{
&amp;HD:13　キャリッジリターン　&amp;HA:10  ラインフィード

*private string ApiUrl = "http:
api.ekispert.jp";
年
*ArrayList YearArray = new ArrayList();
月
*index = 0;
日
*index = 0;
時
*ArrayList HourArray = new ArrayList();
分
*ArrayList MinuteArray = new ArrayList();

*cs.Dispatch(emitKernel, emitNum
THREAD_NUM_X, 1, 1);    emitNumの数だけ発生
*void Update () {// マウスボタンがクリックされたらカーソルの位置からパーティクルを生成するif (Input.GetMouseButton(0)){Vector3 mpos = Input.mousePosition;mpos.z = 10;Vector3 pos = camera.ScreenToWorldPoint(mpos);EmitParticle(pos);}UpdateParticle();}
Update is called once per frame
*if (Input.GetMouseButton(0))*{
マウスボタンがクリックされたらカーソルの位置からパーティクルを生成する

*NiceAsyncMethod().Wait();
Waitしてもデッドロックしない！

*var xslt = new XslCompiledTransform();*xslt.Load(stylesheetUri);
XSLTファイル の読み込み
出力先を 文字列 として準備
*var output = new StringBuilder();
出力フォーマット の指定
*var settings = new XmlWriterSettings();
*using(var writer = XmlWriter.Create(output, settings)) {xslt.Transform(inputUri, writer);}
XSLT を利用した 変換処理
LaTeXの文字列はoutput.ToString()で得られる
*Console.WriteLine(output.ToString());

*var evens = Positives.Where(i =<; i%2 != 0);
変数名もつけられる
略
*}

TickCountで取得した、コンピュータを起動してからの経過時間をミリ秒単位で取得し、ランダムデータ生成のSeed値とする
*int Seed = Environment.TickCount;
ランダムデータ生成件数
*int MaxRoop = 100;
*if (RoopCount >;= MaxRoop)*{
ループカウントが生成件数の設定値に到達したらループ終了
普通のランダムクラスのインスタンスを生成
*Random SeedRoopCountRondom1 = new Random();
上限値を適当に設定し、数値をひとつ取り出す
*int SeedRoopCount1 = SeedRoopCountRondom1.Next(200);
*for (int i = 0; i <; 200; i++)*{
上限値の分だけループ
ランダムクラス「rnd」にSeed値をインクリメントしたものを与えてインスタンス生成
ここでループを繰り返してSeed値を与えることで、よりランダム性のある数値を作ることができる
*rnd = new Random(Seed++);
*if (i == SeedRoopCount1)*{
普通のランダムクラスから取得した値とループカウントが同じになればループ終了
ランダムデータとして取り出したい範囲の値を設定
*int value = rnd.Next(1, 100000);
51ミリ秒待つのがポイント(根拠は正直あまりない…)
ここで待機時間を入れないとマシンの性能によってはSeed値に規則性が生まれてしまい、ランダムデータが規則的な間隔で出力されるため
*System.Threading.Thread.Sleep(51);
csvにデータを書き込みする
*sw.WriteLine(value);

*10.0f
どれくらいの時間
省略
*,,,

*{public string[] Genders { get; set; }}
設定クラス
設定ファイルのセクションの内容をProfileSettingsとして登録
*services.Configure<;ProfileSettings>;(Configuration.GetSection("ProfileSettings"));
使用例
*[MetricsFilter]
ここでカスタムIServiceProviderを返せばそれが使用される
*return services.BuildServiceProvider();

*void Start () {seedPs = GetComponent<;ParticleSystem>;();StartCoroutine(ProgressCo());}
Use this for initialization
*void Update () {}
Update is called once per frame
*while (seedPs.particleCount == 0)*{
ひゅるるる待ち
*while (seedPs.particleCount >; 0)*{
ひゅるるるの間は音の位置を移動
*while (getSubEmitterParticleNum() == 0)*{
爆発待ち
爆発音
*explodeAudioObj.GetComponent<;AudioSource>;().pitch *= Random.Range(0.8f, 1.2f);
*while (getSubEmitterParticleNum() >; 0)*{
消滅待ち
消滅
*Destroy(gameObject);

*using (IEnumerator<;TSource>; e = source.GetEnumerator()) {checked {while (e.MoveNext()) count++;}}
～～ (省略) ～～
*Console.WriteLine("件数：{0}", intArray.Count());
ICollectionを実装して無い為、全要素をループして件数をカウンティングする。
*Console.WriteLine("件数：{0}", intList.Count());
宣言はIEnumerable&lt;T&gt;でも実体はICollectionを実装している為、プロパティの値を返してくれる。

*if (hit.collider.tag == "Monster") {*//Rayが当たっている時間をincrease
もしRayが衝突したオブジェクトのタグが"Monsterだったら"
Rayが当たっている時間をincrease
*gazedTime += Time.deltaTime;
*if (gazedTime >;= 1.4f) {*Destroy(hit.collider.gameObject);
発射してリセット

*// private BindingList<;string>; stringList = new BindingList<;string>; { "abc", "123" };
2016-12-19 追記
*// private BindingList<;string>; stringList = new BindingList<;string>; { "abc", "123" };
List&lt;T&gt; の代わりに System.ComponentModel.BindingList&lt;T&gt; を使えばリストを更新するだけでコントロールも更新されるようです。機能は少々ゴテっとしていますが。
*{InitializeComponent();comboBox1.DataSource = stringList;}
private BindingList&lt;string&gt; stringList = new BindingList&lt;string&gt; { "abc", "123" };
*stringList.AddRange(new List<;string>; { "x", "y" });
全体入れ替え - アイテムに x, y が追加される
*stringList.AddRange(new List<;string>; { "x", "y" });
DataSource (List&lt;string&gt;) と ComboBox を直結
ComboBox を更新、null 代入が必要
*comboBox1.DataSource = null;
*var newList = new List<;string>; { "x", "y" };
全体入れ替え - アイテム x, y が追加される
*var newList = new List<;string>; { "x", "y" };
DataSource (List&lt;string&gt;) と ComboBox を直結
ComboBox を更新
*comboBox1.DataSource = newList;
List&lt;&gt; と ComboBox の間に BindingSource をかます
*var bindingSource1 = new BindingSource(stringList, "");
データソースに def を追加して
*stringList.Add("def");
ComboBox を更新
*bindingSource1.ResetBindings(false);
項目更新
List&lt;&gt; と ComboBox の間に BindingSource をかます
*var bindingSource1 = new BindingSource(stringList, "");
12-06-2016 追加
string ではなくユーザデータを DataSource に。
*private List<;UserData>; userDataList = new List<;UserData>;

Altseedを初期化する。
*asd.Engine.Initialize("Empty", 640, 480, new asd.EngineOption());
*while (asd.Engine.DoEvents())*{
Altseedのウインドウが閉じられていないか確認する。
Altseedを更新する。
*asd.Engine.Update();
Altseedの終了処理をする。
*asd.Engine.Terminate();

*var traceProfiler = new TraceProfler();
IAdoNetProfilerを実装したクラスのオブジェクト
DBアクセス処理
*}
アプリケーションの起動時または初期化時に呼び出す
*AdoNetProfilerFactory.Initialize(typeof(TraceProfiler));
これまで通りDbProviderFactoryを取得
*var factory = DbproviderFactories.GetFactory("System.Data.SqlClient");
*{connection.ConnectionString = "[接続文字列]";// DBアクセス処理}
AdoNetProfilerConnectionが生成される
DBアクセス処理
*}

*public static readonly int HANDVALUE_PAA = 2;
パーを表す値
*{Hand NextHand();void Study(bool win);}
・戦略を定めるためのインターフェース（API）を定める
*{private Random random;private bool won = false;private Hand prevHand;public WinningStrategy(int seed){random = new Random(seed);}public Hand NextHand(){if (!won){prevHand = Hand.GetHand(random.Next(3));}return prevHand;}public void Study(bool win){won = win;}}
・Strategyのインターフェース（API）を実装する
*{private Random random;private int prevHandValue = 0;private int currentHandValue = 0;private int[][] history ={new int[] { 1, 1, 1, },new int[] { 1, 1, 1, },new int[] { 1, 1, 1, },};public ProbStrategy(int seed){random = new Random(seed);}public Hand NextHand(){int bet = random.Next(GetSum(currentHandValue));int handvalue = 0;if (bet <; history[currentHandValue][0]){handvalue = 0;}else if (bet <; history[currentHandValue][0] + history[currentHandValue][1]){handvalue = 1;}else{handvalue = 2;}prevHandValue = currentHandValue;currentHandValue = handvalue;return Hand.GetHand(handvalue);}private int GetSum(int hv){int sum = 0;for (int i = 0; i <; 3; i++){sum += history[hv][i];}return sum;}public void Study(bool win){if (win){history[prevHandValue][currentHandValue]++;}else{history[prevHandValue][(currentHandValue + 1) % 3]++;history[prevHandValue][(currentHandValue + 2) % 3]++;}}}
ConcreteStrategy
・Strategyを利用する
・ConcreteStrategyのインスタンスを持っていて、必要に応じて利用する
・呼び出すのはStrategyのインターフェース
*public class Player

percisionとscaleの値を変更してやればお望みの桁数にできる
*decimaltest = c.Decimal(nullable: false, precision: 18, scale: 2)

*foreach(var obj in Objects.ToArray())
ToArray() でコピー
*{Add = 0,Remove = 1,}
コレクションの操作の種類：追加、削除
*{public EventToManageObject(Layer layer, Object content, RegistrationCommand command){ObjectManager = objectManager;Content = content;Command = command;}// 描画オブジェクトを追加または削除する対象のレイヤーprivate Layer Layer { get; }// 追加または削除する描画オブジェクトpublic Object Content { get; }// 行う処理が追加なのか削除なのかpublic RegistrationCommand Command { get; }// 実際に追加・削除をするpublic void Commit(){// 追加操作であれば実際に追加if(Command == RegistrationCommand.Add){// ImmediatelyAddObjectはバッファリングを介さず直接追加するLayer.ImmediatelyAddObject(Content);}// 削除操作であれば実際に削除else if(Command == RegistrationCommand.Remove){// ImmediatelyRemoveObjectはバッファリングを介さず直接削除するLayer.ImmediatelyRemoveObject(Content);}}}
描画オブジェクトのコレクションに対する操作イベント
*private Layer Layer { get; }
描画オブジェクトを追加または削除する対象のレイヤー
*public Object Content { get; }
追加または削除する描画オブジェクト
*public RegistrationCommand Command { get; }
行う処理が追加なのか削除なのか
*{// 追加操作であれば実際に追加if(Command == RegistrationCommand.Add){// ImmediatelyAddObjectはバッファリングを介さず直接追加するLayer.ImmediatelyAddObject(Content);}// 削除操作であれば実際に削除else if(Command == RegistrationCommand.Remove){// ImmediatelyRemoveObjectはバッファリングを介さず直接削除するLayer.ImmediatelyRemoveObject(Content);}}
実際に追加・削除をする
*if(Command == RegistrationCommand.Add)*{
追加操作であれば実際に追加
ImmediatelyAddObjectはバッファリングを介さず直接追加する
*Layer.ImmediatelyAddObject(Content);
*else if(Command == RegistrationCommand.Remove)*{
削除操作であれば実際に削除
ImmediatelyRemoveObjectはバッファリングを介さず直接削除する
*Layer.ImmediatelyRemoveObject(Content);

*Console.WriteLine(record.No+ "," + record.ReceptDate.ToString());
ちゃんと読み込めているか確認してみる

CSVを分解（囲み文字の二重引用符も除去）
*var record = reader.ReadLine().Split(',').Select(a =>; a.Trim('"')).ToArray();
*var output = new string[]{ record[0], record[2], record[1], record[3] };
入れ替え
CSV形式で出力
*writer.WriteLine(string.Join(",", output.Select(a =>; "\"" + a + "\"")));

*var req = new HttpRequestMessage(HttpMethod.Post, new Uri("https:
hoge.hogehoge"));

*var d2 = Math.Ceiling(-0.5);
0

IOptions&lt;T&gt;でのインジェクション有効化
*services.AddOptions();

RegAsm のパスを取得
*string path = System.IO.Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), "RegAsm.exe");
パスをコンソールに出力
*Console.WriteLine("[" + path + "]");
渡されたコマンドライン引数をそのまま渡す
*StringBuilder buff = new StringBuilder(128);
出力を取得できるようにする
*p.StartInfo.UseShellExecute = false;
ウィンドウを表示しない
*p.StartInfo.CreateNoWindow = true;
起動
*p.Start();
出力を取得
*string results = p.StandardOutput.ReadToEnd();
プロセス終了まで待機する
*p.WaitForExit();
出力された結果を表示
*Console.WriteLine(results);

*foreach (var n in perm.Enumerate(new[] { 1, 2, 3, 4 })) {
確認用コード

*process.Kill();
例外が発生する可能性のあるメソッド

*protected override C Apply(B b)
エラー: 共変戻り値不可

*{static void Main(string[] args){SampleClass cls = new SampleClass();cls.SampleMethod("テスト実行");Console.ReadLine();}}
EntryPoint
実行対象クラス
*[MyAspect]
以下、コンストラクタを実行する処理
*RealProxy rp = RemotingServices.GetRealProxy(this._target);
*Console.WriteLine("[{0}]{1} : 実行開始",
以下、コンストラクタ以外のメソッドを実行する処理
*Console.WriteLine("[{0}]{1} : 実行開始",
メソッド前処理
メソッド実行
*res = RemotingServices.ExecuteMessage(this._target, call);
*Console.WriteLine("[{0}]{1} : 実行終了",
メソッド後処理
メソッド実行前処理メソッド
*void PreProcessing(IMethodCallMessage call);
メソッド実行後処理メソッド
*void PostProcessing(IMethodCallMessage call, IMethodReturnMessage res);
*Console.WriteLine("[{0}]{1} : 実行開始",
メソッド前処理
*Console.WriteLine("[{0}]{1} : 実行終了",
メソッド後処理
以下、コンストラクタを実行する処理
*RealProxy rp = RemotingServices.GetRealProxy(this._target);
*//Console.WriteLine("[{0}]{1} : 実行開始",
以下、コンストラクタ以外のメソッドを実行する処理
*//Console.WriteLine("[{0}]{1} : 実行開始",
メソッド前処理
Console.WriteLine("[{0}]{1} : 実行開始",
DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"), call.MethodName);
*this._container.PreProcessing(call);
メソッド実行
*res = RemotingServices.ExecuteMessage(this._target, call);
*//Console.WriteLine("[{0}]{1} : 実行終了",
メソッド後処理
Console.WriteLine("[{0}]{1} : 実行終了",
DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"), call.MethodName);
*this._container.PostProcessing(call, res);

storageAccountの作成（接続情報の定義）
アカウントネームやキー情報はAzureポータルから確認できる。
*var accountName = "teststorage";
こういう書き方もできるし、Configから読み込むこともできる。
CloudStorageAccount storageAccount = CloudStorageAccount.Parse("DefaultEndpointsProtocol=https;AccountName=アカウントネーム;AccountKey=アクセスキー");
blob
*CloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();
もし無かったら作る
container.CreateIfNotExists();
upload
アップロード後のファイル名を指定（無くてよい）
*CloudBlockBlob blockBlob_upload = container.GetBlockBlobReference("aaa.jpg");
アップロード処理
アップロードしたいローカルのファイルを指定
*using (var fileStream = System.IO.File.OpenRead(@"C:\Users\hoge\Desktop\bbb.jpg"))
ダウンロードするファイル名を指定
*CloudBlockBlob blockBlob_download = container.GetBlockBlobReference("ccc.jpg");
ダウンロード処理
ダウンロード後のパスとファイル名を指定。
*blockBlob_download.DownloadToFile(@"C:\Users\hoge\Desktop\ddd.jpg", System.IO.FileMode.CreateNew);
削除
blockBlob_download.Delete();
*Console.WriteLine("処理を完了しました。");
アカウントネームやキー情報はAzureポータルから確認できる。
*var accountName = "teststorage";
ここまではstorage共通
blob
*CloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();
無かったら作る
*container.CreateIfNotExistsAsync();
ここまではblob共通
appendblob
BlockBlobではなくAppenDBlobのリファレンスを取得する
*CloudAppendBlob appendBlob = container.GetAppendBlobReference("server01.log");
*if(!appendBlob.Exists()) appendBlob.CreateOrReplace();*//書き込み
無かったら作る
書き込み
*appendBlob.AppendText(DateTime.Now+" Log message.\n");
内容表示
*Console.WriteLine(appendBlob.DownloadText());
待つ
*Console.ReadLine();

*System.Environment.Exit(returnCd);
リターンコードを返却しながら終了する。

*{return new Add().Forward(tensor1, tensor2);}
演算子のオーバーロード

CS1648が発生｡
*_immutable.Value = value;
*Console.WriteLine($"_mutable.Count:{_mutable.Count}");
1
*Console.WriteLine($"_mutable.Counter:{_mutable.Counter.Count}");
1
*Console.WriteLine($"_immutable.Count:{_immutable.Count}");
0のまま!
*Console.WriteLine($"_immutable.Counter:{_mutable.Counter.Count}");
1
*Console.WriteLine($"_immutable.Count:{_immutable.Count}");
0
*Console.WriteLine($"_immutable.Counter:{_immutable.Counter.Count}");
1

*.UseUrls("http:
*:80")     ここを追加

*while(reader.Read() == true)*{
loop &amp; write
*{//commandusing(var command = connection.CreateCommand()){try{connection.Open();command.CommandText = @"select * from members";//readerusing(var reader = command.ExecuteReader()){//loopwhile(reader.Read() == true){Console.WriteLine(reader["id"]+" "+reader["name"]+" "+reader["email"]);}}}catch(Exception e){Console.WriteLine(e.Message);throw;}finally{connection.Close();}}}
connection
*{try{connection.Open();command.CommandText = @"select * from members";//readerusing(var reader = command.ExecuteReader()){//loopwhile(reader.Read() == true){Console.WriteLine(reader["id"]+" "+reader["name"]+" "+reader["email"]);}}}catch(Exception e){Console.WriteLine(e.Message);throw;}finally{connection.Close();}}
command
*{//loopwhile(reader.Read() == true){Console.WriteLine(reader["id"]+" "+reader["name"]+" "+reader["email"]);}}
reader
*while(reader.Read() == true)*{
loop
*{public int id {get;set;}public string name {get;set;}public string email {get;set;}}
data
*{public DbSet<;Member>; Members{get;set;}protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)=>; optionsBuilder.UseSqlServer(@"server=192.168.77.129;database=sample;uid=sa;pwd=P@ssw0rd!;");}
context
*{public static void Main(string[] args){using(var context = new MyContext()){//selectvar ret = context.Members.ToList();foreach(var x in ret){Console.WriteLine($"{x.name} {x.email}");}}}}
main
*{public int id {get;set;}public string name {get;set;}public string email {get;set;}}
model
*{using(var connection = new SqlConnection(@"Data Source=192.168.77.129;Initial Catalog=sample;User Id=sa;Password=P@ssw0rd!;")){connection.Open();var members = connection.Query<;Member>;("select * from members");foreach(var member in members){Console.WriteLine(member.name + " " + member.email);}}}
main

*.ToArray();
→ Aオブジェクト1つだけの配列となる
以下のように`OfType`を用いても同じ結果になるので、こう書く方がベター
*var arrayOfA2 = objects.OfType<;A>;();

実行が一瞬で終わって確認できないので、キーの入力を待ちます
*Console.ReadLine();
・機能のクラス階層の最上位クラス
・Implementorを使用して基本的なメソッドを実装する
・機能クラスの階層と実装クラスの階層を橋渡しするImplementerを保持
*public class Display
*{public CountDisplay(DisplayImpl impl) : base(impl) { }public void MultiDisplay(int times){Open();for (int i = 0; i <; times; i++){Print();}Close();}}
・Abstractionに対して機能を追加
・実装のクラス階層の最上位クラス
・Abstranctionのインターフェース（API）を規定する
*public abstract class DisplayImpl
*{private string str;private int width;public StringDisplayImpl(string str){this.str = str;Encoding sjisEnc = Encoding.GetEncoding("shift_jis");this.width = sjisEnc.GetByteCount(str);}public override void RawOpen(){PrintLine();}public override void RawPrint(){Console.WriteLine($"|{str}|");}public override void RawClose(){PrintLine();}public void PrintLine(){Console.Write("+");for (int i = 0; i <;width; i++){Console.Write("-");}Console.WriteLine("+");}}
・Implementatorを具体的に実装する

*if(Input.GetKey(KeyCode.W)){isMove = true;moveVec = new Vector3(viewVec.x, 0, viewVec.z).normalized * speed * Time.deltaTime;Rigidbody.velocity = new Vector3(moveVec.x, Rigidbody.velocity.y, moveVec.z);}
Move
*if(Input.GetKey(KeyCode.Space) &amp;&amp; isGround){*isGround = false;
Jump
*void LookAtSet(){camPos = this.transform.position + viewVec;this.transform.LookAt(new Vector3(camPos.x, this.transform.position.y, camPos.z));camera.transform.position = new Vector3(camPos.x, this.transform.position.y + 0.5f, camPos.z);camera.transform.LookAt(camera.transform.position + viewVec);}
Viewpoint
*if(Input.GetKey(KeyCode.W)){isMove = true;moveVec = new Vector3(viewVec.x, 0, viewVec.z).normalized * speed * Time.deltaTime;Rigidbody.velocity = new Vector3(moveVec.x, Rigidbody.velocity.y, moveVec.z);}
Move
*if(Input.GetKey(KeyCode.Space) &amp;&amp; isGround){*isGround = false;
Jump

employeeテーブル情報取得
*command.CommandText = "PRAGMA TABLE_INFO(employee);";
*var tableInfo = new TableInfo {ColumnName = reader["name"].ToString(),DataType = reader["type"].ToString()};
name: カラム名, type: データ型
*switch (dataType) {case "TEXT":return typeof(string);case "INTEGER":return typeof(int);case "REAL":return typeof(double);default:throw new ArgumentException($"型が不明です: { dataType }");}
今回はBLOB型を無視します｡
名前空間を設定
*var name = new CodeNamespace(nameSpace);
*foreach (var t in tableInfo) {//propertyを定義var field = new CodeMemberField {Attributes = MemberAttributes.Public | MemberAttributes.Final,Name = $"{ t.ColumnName } {{ get; set; }}",Type = new CodeTypeReference(this.GetPropertyDataType(t.DataType)),};classType.Members.Add(field);}
クラス定義 引数にはクラス名を設定
*var field = new CodeMemberField {Attributes = MemberAttributes.Public | MemberAttributes.Final,Name = $"{ t.ColumnName } {{ get; set; }}",Type = new CodeTypeReference(this.GetPropertyDataType(t.DataType)),};
propertyを定義
*var fileName = $"{ classType.Name }.{ provider.FileExtension }";
CSharpCodeProvider().FileExtensionで｢cs｣拡張子を取得できます
*using (var writer = File.CreateText(fileName)) {provider.GenerateCodeFromCompileUnit(compileUnit,writer,new CodeGeneratorOptions());}
Entityクラスを出力
このコードはツールによって生成されました。
ランタイム バージョン:4.0.30319.42000

このファイルへの変更は、以下の状況下で不正な動作の原因になったり、
コードが再生成されるときに損失したりします。
&lt;/auto-generated&gt;
------------------------------------------------------------------------------
*namespace Namespace1 {
ファイルを読込み､波括弧末尾のセミコロンを削除
*string fileDetail = File.ReadAllText(fileName).Replace("};", "}");
*using (var writer = new StreamWriter(fileName)) {writer.Write(fileDetail);}
再度ファイルに書き出す
名前空間を設定
*var name = new CodeNamespace(nameSpace);
*foreach (var t in tableInfo) {//propertyを定義var field = new CodeMemberField {Attributes = MemberAttributes.Public | MemberAttributes.Final,Name = $"{ t.ColumnName } {{ get; set; }}",Type = new CodeTypeReference(this.GetPropertyDataType(t.DataType)),};classType.Members.Add(field);}
クラス定義 引数にはクラス名を設定
*var field = new CodeMemberField {Attributes = MemberAttributes.Public | MemberAttributes.Final,Name = $"{ t.ColumnName } {{ get; set; }}",Type = new CodeTypeReference(this.GetPropertyDataType(t.DataType)),};
propertyを定義
*var fileName = $"{ classType.Name }.{ provider.FileExtension }";
CSharpCodeProvider().FileExtensionで｢cs｣拡張子を取得できます
*using (var writer = File.CreateText(fileName)) {provider.GenerateCodeFromCompileUnit(compileUnit, writer, new CodeGeneratorOptions());}
Entityクラスを出力
各プロパティ末尾のセミコロン削除
*this.DeletePropertysEndSemicolon(fileName);
このコードはツールによって生成されました。
ランタイム バージョン:4.0.30319.42000

このファイルへの変更は、以下の状況下で不正な動作の原因になったり、
コードが再生成されるときに損失したりします。
&lt;/auto-generated&gt;
------------------------------------------------------------------------------
*namespace Namespace1 {
名前空間を設定
*var name = new CodeNamespace("Namespace1");
Systemをインポート
*name.Imports.Add(new CodeNamespaceImport("System"));
クラス定義 引数にはクラス名を設定
*var classType = new CodeTypeDeclaration("HelloWorld");
public static void Main() を作成
*var method = new CodeEntryPointMethod();
Console.WriteLine("Hello World!"); を定義
*var writeLine = new CodeMethodInvokeExpression(
Console.ReadKey(); を定義
*var readKey = new CodeMethodInvokeExpression(
上記で定義した処理をMain()に追加する
*method.Statements.Add(new CodeExpressionStatement(writeLine));
確認のため生成コードをコンソールへ出力
*provider.GenerateCodeFromCompileUnit(compileUnit, Console.Out, new CodeGeneratorOptions());
*var param = new CompilerParameters { GenerateExecutable = true, OutputAssembly = "HelloWorld.exe" };
実行ファイル(HelloWorld.exe)を作成

*var referenceNodes = doc.DocumentNode.SelectNodes("
itemgroupreference");

*var human = new Human();
OK
*{void chirp();}
追加
鳴く処理
*}
飛ぶ処理
*}
ここで継承先でそれぞれの通信を実装
*var jsonString = GetJson();
*return new { json = jsonString };
jsonStringをオブジェクトにして返す(今回は省略)
通信して結果のオブジェクトを作成
APIからJSONを取得して返す
*return "TwitterAPIの結果のJSON";
通信して結果のオブジェクトを作成
APIからJSONを取得して返す
*return "InstagramAPIの結果のJSON";
通信して結果のオブジェクトを作成
APIからJSONを取得して返す
*return "YoutubeAPIの結果のJSON";
*IObject[] objects = new IObject[] { twitterApi, instagramApi, youtubeApi };
上記のインスタンス

*public class hogehoge : Program
継承させてProgramクラスの動作を再利用

*Link google = factory.CreateLink("Google", "http:
www.google.com");
実行が一瞬で終わって確認できないので、キーの入力を待ちます
*Console.ReadLine();
*{protected string caption;public Item(string caption){this.caption = caption;}public abstract string MakeHTML();}
・AbstractFactoryによって作り出される抽象的な部品や製品のインターフェース（API）を定める
*{protected string url;public Link(string caption, string url) : base(caption){this.url = url;}}
AbstractProduct
*{protected List<;Item>; tray = new List<;Item>;();public Tray(string caption) : base(caption) { }public void Add(Item item){tray.Add(item);}}
AbstractProduct
*{protected string title;protected string author;protected List<;Item>; content = new List<;Item>;();public Page(string title, string author){this.title = title;this.author = author;}public void Add(Item item){this.content.Add(item);}public void Output(){try{string filename = title + ".html";using (StreamWriter writer = new StreamWriter(filename, false, Encoding.UTF8)){writer.Write(this.MakeHTML());}Console.WriteLine($"{filename}を作成しました。");}catch(IOException e){Console.Error.WriteLine(e);}}public abstract string MakeHTML();}
AbstractProduct
*{public static Factory GetFactory(string classname){Factory factory = null;try{Assembly assembly = Assembly.GetExecutingAssembly();factory = (Factory)assembly.CreateInstance(classname,false,BindingFlags.CreateInstance,null,null,null,null);}catch(TypeLoadException){Console.Error.WriteLine($"クラス{classname}が見つかりません。");}catch(Exception e){Console.Error.WriteLine(e.StackTrace);}return factory;}public abstract Link CreateLink(string caption, string url);public abstract Tray CreateTray(string caption);public abstract Page CreatePage(string title, string author);}
・AbstractProductのインスタンスを作り出すためのインターフェース（API）を定める
*{public override Link CreateLink(string caption, string url){return new ListLink(caption, url);}public override Tray CreateTray(string caption){return new ListTray(caption);}public override Page CreatePage(string title, string author){return new ListPage(title, author);}}
ConcreteFactory
*{public ListLink(string caption, string url) : base(caption, url) { }public override string MakeHTML(){return $"  <;li>;<;a href=\"{url}\">;{caption}<;/a>;<;/li>;\n";}}
ConcreteProduct
*{public ListTray(string caption) : base(caption) { }public override string MakeHTML(){StringBuilder sb = new StringBuilder();sb.Append("<;li>;\n");sb.Append($"{caption}\n");sb.Append("<;ul>;\n");IEnumerator<;Item>; e = tray.GetEnumerator();while (e.MoveNext()){sb.Append(e.Current.MakeHTML());}sb.Append("<;/ul>;\n");sb.Append("<;/li>;\n");return sb.ToString();}}
ConcreteProduct
*{public ListPage(string title, string author) : base(title, author) { }public override string MakeHTML(){StringBuilder sb = new StringBuilder();sb.Append($"<;html>;<;head>;<;title>;{title}<;/title>;<;/head>;\n");sb.Append("<;body>;\n");sb.Append($"<;h1>;{title}<;/h1>;");sb.Append("<;ul>;\n");IEnumerator<;Item>; e = content.GetEnumerator();while (e.MoveNext()){sb.Append(e.Current.MakeHTML());}sb.Append("<;/ul>;\n");sb.Append($"<;hr>;<;address>;{author}<;/address>;");sb.Append("<;/body>;<;/html>;\n");return sb.ToString();}}
ConcreteProduct
*{public override Link CreateLink(string caption, string url){return new TableLink(caption, url);}public override Tray CreateTray(string caption){return new TableTray(caption);}public override Page CreatePage(string title, string author){return new TablePage(title, author);}}
Concrete Factory
*{public TableLink(string caption, string url) : base(caption, url) { }public override string MakeHTML(){return $"<;td>;<;a href=\"{url}\">;{caption}<;/a>;<;/td>;\n";}}
ConcreteProduct
*{public TableTray(string caption) : base(caption) { }public override string MakeHTML(){StringBuilder sb = new StringBuilder();sb.Append("<;td>;");sb.Append("<;table width=\"100%\" border=\"1\">;<;tr>;");sb.Append($"<;td bgcolor=\"#cccccc\" align=\"center\" colspan=\"{tray.Count}\"<;b>;{caption}<;/b>;<;/td>;");sb.Append("<;/tr>;\n");sb.Append("<;tr>;\n");IEnumerator<;Item>; e = tray.GetEnumerator();while (e.MoveNext()){sb.Append(e.Current.MakeHTML());}sb.Append("<;tr>;<;/table>;");sb.Append("<;/tr>;");return sb.ToString();}}
ConcreteProduct
*{public TablePage(string title, string author) : base(title, author) { }public override string MakeHTML(){StringBuilder sb = new StringBuilder();sb.Append($"<;html>;<;head>;<;title>;{title}<;/title>;<;/head>;\n");sb.Append("<;body>;\n");sb.Append($"<;h1>;{title}<;/h1>;\n");sb.Append("<;table width=\"80%\" border=\"3\">;\n");IEnumerator<;Item>; e = content.GetEnumerator();while (e.MoveNext()){sb.Append($"<;tr>;{e.Current.MakeHTML()}<;/tr>;");}sb.Append("<;/table>;\n");sb.Append($"<;hr>;<;address>;{author}<;/address>;");sb.Append("<;/body>;<;/html>;\n");return sb.ToString();}}
ConcreteProduct

*{var c2 = new ClassLibrary1.Class2();ClassLibrary1.Fakes.ShimClass1.AllInstances.CalInt32Int32 = (ClassLibrary1.Class1 obj, int x, int y) =>;{// c1.Cal(1, 2); が実行されていることを確認するAssert.AreEqual(c2.c1, obj);Assert.AreEqual(1, x);Assert.AreEqual(2, y);return 999999;};var act = c2.CallCal();// Shimで偽装した値が返ってくることを確認する。Assert.AreEqual(999999, act);}
ShimsContextのブロック内のみ偽装する。
c1.Cal(1, 2); が実行されていることを確認する
*Assert.AreEqual(c2.c1, obj);
Shimで偽装した値が返ってくることを確認する。
*Assert.AreEqual(999999, act);
*{return new Test6Ret();}
パラメータまたは戻り値が公開された型でないので偽装ができない。
*{var c2 = new ClassLibrary1.Class2();ClassLibrary1.Fakes.ShimClass3.AllInstances.test1 = (ClassLibrary1.Class3 obj) =>;{return 11;};ClassLibrary1.Fakes.ShimClass3.test2 = () =>;{return 22;};ClassLibrary1.Fakes.ShimClass3.AllInstances.test3 = (ClassLibrary1.Class3 obj) =>;{return 33;};ClassLibrary1.Fakes.ShimClass3.AllInstances.test4 = (ClassLibrary1.Class3 obj) =>;{return 44;};ClassLibrary1.Fakes.ShimClass3.AllInstances.test5 = (ClassLibrary1.Class3 obj) =>;{return null;};//これは作られない。//ClassLibrary1.Fakes.ShimClass3.AllInstances.test6 = (ClassLibrary1.Class3 obj) =>;//{//    return null;//};}
ShimsContextのブロック内のみ偽装する。
*//{//    return null;//};
これは作られない。
*//{//    return null;//};
ClassLibrary1.Fakes.ShimClass3.AllInstances.test6 = (ClassLibrary1.Class3 obj) =&gt;
*{DateTime exp = new DateTime(2000, 10, 5);System.Fakes.ShimDateTime.NowGet = () =>;{return exp;};var act = System.DateTime.Now;Assert.AreEqual(exp, act);}
ShimsContextのブロック内のみ偽装する。
*{System.Fakes.ShimEnvironment.UserNameGet = () =>;{return "user";};System.Fakes.ShimEnvironment.MachineNameGet = () =>;{return "machine";};Assert.AreEqual("user", Environment.UserName);Assert.AreEqual("machine", Environment.MachineName);}
ShimsContextのブロック内のみ偽装する。
*{ClassLibrary1.Fakes.ShimClass5.ShimClass5Inner.AllInstances.Test5Inner = (ClassLibrary1.Class5.Class5Inner obj) =>;{return 99;};var o = new ClassLibrary1.Class5.Class5Inner();Assert.AreEqual(99, o.Test5Inner());}
ShimsContextのブロック内のみ偽装する。
*{ClassLibrary1.Fakes.ShimClass6Base.AllInstances.Test6Base = (ClassLibrary1.Class6Base obj) =>;{return 99;};var o = new ClassLibrary1.Class6();Assert.AreEqual(100, o.Test6BasePlus1());}
ShimsContextのブロック内のみ偽装する。
*{bool callSwap = false;ClassLibrary1.Fakes.ShimClass7.SwapOf1M0RefM0Ref<;int>;((ref int x, ref int y) =>;{//callSwap = true;Assert.AreEqual(1, x);Assert.AreEqual(9, y);return;});ClassLibrary1.Class7.Test7();Assert.AreEqual(true, callSwap);}
ShimsContextのブロック内のみ偽装する。
*{bool callLog = false;ClassLibrary1.Fakes.ShimClass8<;int,string>;.AllInstances.Log = (ClassLibrary1.Class8<;int,string>; obj) =>;{//callLog = true;};var o = new ClassLibrary1.Class8<;int, string>;();o.Log();Assert.AreEqual(true, callLog);}
ShimsContextのブロック内のみ偽装する。
*{ClassLibrary1.Fakes.ShimClass1.AllInstances.CalInt32Int32 = (ClassLibrary1.Class1 obj, int x, int y) =>;{// c1.Cal(1, 2); が実行されていることを確認するAssert.AreEqual(1, x);Assert.AreEqual(2, y);// 実行時のClass1.xxxxが123であることを確認するAssert.AreEqual(123, obj.xxxx);return 999999;};}
ShimsContextのブロック内のみ偽装する。
c1.Cal(1, 2); が実行されていることを確認する
*Assert.AreEqual(1, x);
実行時のClass1.xxxxが123であることを確認する
*Assert.AreEqual(123, obj.xxxx);
*{int callCalCnt = 0;ClassLibrary1.Fakes.ShimClass1.AllInstances.CalInt32Int32 = (ClassLibrary1.Class1 obj, int x, int y) =>;{// 実行した回数を数える++callCalCnt;return 999999;};var c2 = new ClassLibrary1.Class2();var act = c2.CallCal();Assert.AreEqual(1, callCalCnt, "c1.Calが1回実行されていることを確認");}
ShimsContextのブロック内のみ偽装する。
実行した回数を数える
*++callCalCnt;
実行した回数を数える
*int ix = callIncCnt;

広告が閉じたときのイベント登録
ちなみに古いAdmobのSDKだと.AdClosedとか微妙に違う
*interStitialView.OnAdFailedToLoad += HandleInterstitialFailedToLoad;

C#6までの書き方
*int n1 = 0;
*if (s.Parse() is int n2)*{
C#7ではパターンマッチングと拡張メソッドでこのように書ける

プロパティ情報の取得
*var property = typeof(Student).GetProperty("Name");
*var beforeName = property.GetValue(student);*// インスタンスに値を設定
インスタンスの値を取得
*Console.WriteLine($"{student.ID}, {beforeName}, {student.Name}");
インスタンスに値を設定

コンソールアプリケーションで実行を確認しました
*using System;
*{if (args.Length != 1){Program.Usage();Environment.Exit(0);}if (args[0].Equals("plain")){TextBuilder textbuilder = new TextBuilder();Director director = new Director(textbuilder);director.Construct();string result = textbuilder.Result;Console.WriteLine(result);}else if (args[0].Equals("html")){HTMLBuilder htmlbuilder = new HTMLBuilder();Director director = new Director(htmlbuilder);director.Construct();string filename = htmlbuilder.Filename;Console.WriteLine(filename + "が作成されました。");}else{Program.Usage();Environment.Exit(0);}// 実行が一瞬で終わって確認できないので、キーの入力を待ちますConsole.ReadLine();}
・Builderを利用する
実行が一瞬で終わって確認できないので、キーの入力を待ちます
*Console.ReadLine();
・インスタンスを作成するためのインターフェース（API）を定める
・インスタンスの各部分を作るためのメソッドを用意する
*public abstract class Builder
・Builderのインターフェース（API）を使ってインスタンスを生成する
・Builderのメソッドのみを使用する
*public class Director
・Builderのインターフェース（API）を実装する
・実際のインスタンス作成で呼び出されるメソッドを定義する
*public class TextBuilder : Builder
・Builderのインターフェース（API）を実装する
・実際のインスタンス作成で呼び出されるメソッドを定義する
*public class HTMLBuilder : Builder

頻繁に開け閉めしなくてもよいので起動時に作成
*mmf = MemoryMappedFile.CreateOrOpen("TestMap", (uint)Marshal.SizeOf(typeof(Test1)));
UIからデータを取り込む(右辺は全部WPFのテキストボックスです)
*testclass.A = int.Parse(this.A.Text);
構造体の体裁を整えたデータクラスをファイルマッピングのストリームに流すためにバイト列に変換する
*int size = Marshal.SizeOf(typeof(Test1));
ファイルマッピングに書く
*mmvs.Write(bytes, 0, size);
構造体の体裁を整えたデータクラスをファイルマッピングのストリームに流すためにバイト列に変換する
*int size = Marshal.SizeOf(typeof(Test1));
ファイルマッピングに書く
*mmvs.Write(bytes, 0, size);

*{
プレイヤーをゲーム画面から出さないための範囲指定

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

*foreach(Nabeatsu Nabe in NabeList.ToArray())
これで自信がない処を削除

*{T Execute();}
戻り値を返すコマンド
*{T Execute();}
戻り値を返すコマンド
*{void Execute();}
戻り値を返さないコマンド

*Int32 x3 = f(x1, x2);
例外が発生！
*var n2 = new int[] { 1, 2, 3, 4, 5 };
1回目にILコードが生成されキャッシュされる。ILコードの生成の分、遅いはず。
*var n3 = new Int64[] { 1, 2, 3, 4 };
キャッシュされたFuncが使用される。直接ハードコーディングした場合とほぼ同じ速度が出るはず。
Int64なのでInt64用のILコードが生成されキャッシュされる。
*var result3 = Sum<;int>;(n3);

*switch (item.GetType().Name)
switchの条件分岐の値は定数しか使えない
HTMLの構築処理とか
*}
HTMLの構築処理とか
*}
HTMLの構築処理とか
*}

*public static List<;User>; GetUserList(){return new List<;User>; GetUserLists(){new User(){ id=1, userName="佐藤",age=20 },new User(){ id=2, userName="山田",age=30 },new User(){ id=3, userName="田中",age=28 },}}
ユーザーリストを返すメソッド

RequestScopeStorageでのオブジェクト管理機能をStandardResolverに追加
*resolver.Configure(container =>; container.Register(storage));
Request Scopeで管理されるオブジェクトの破棄
*storage.Clear();
UseMvcの前に記述
*app.UseSmartResolverRequestScope(resolver);
*{routes.MapRoute(name: "default",template: "{controller=Home}/{action=Index}/{id?}");});
Enable request scope

*byte[] buffer = new byte[65536];
64KB chunks
*while (ms.Length <; 65536 * 10)*Thread.Sleep(1000);
Pre-buffering some data to allow NAudio to start playing

*{new List<;string>;() {"1a", "2a", "3a"},new List<;string>;() {"1b", "2b", "3b"},new List<;string>;() {"1c", "2c", "3c"}}
変換後
*{new List<;string>;() {"1a", "1b", "1c"},new List<;string>;() {"2a", "2b", "2c", "2d"},new List<;string>;() {"3a", "3b", "3c"}}
変換前
*{new List<;string>;() {"1a", "2a", "3a"},new List<;string>;() {"1b", "2b", "3b"},new List<;string>;() {"1c", "2c", "3c"},new List<;string>;() {"2d"}}
変換後

*var enumNames = new Dictionary<;string, string[]<;();
enumの中身を入れとく

標準のASP.NET設定はここ
*services.AddSingleton<;IControllerActivator>;(new SmartResolverControllerActivator(resolver));

Personクラスのpublicメンバーを構造体形式でコンソール出力する
*var human = new Person();
publicのプロパティとフィールドを検索
*var memberInfos = classes.GetMembers(BindingFlags.Public | BindingFlags.Instance);
*if (prop.FieldType.IsArray)*{
配列なら要素数の位置を移動(要検討)
*if (!"System".Equals(prop.FieldType.Namespace) &amp;&amp; prop.FieldType.IsPrimitive == false)*{
プリミティブとSystemネームスペース以外
*if (prop.FieldType.IsEnum)*{
enumは一階層のため列挙
*else if (prop.FieldType.IsClass)*{
独自クラスがある場合はさらに掘り進める
*if (prop.PropertyType.IsEnum)*{
enumは一階層のため列挙
*foreach (var item in nestMembers)*{
メンバーに独自クラスがある場合は掘り進める ※1
*foreach (var item in enumNames)*{
enum
*Console.WriteLine("typedef struct\r\n{");foreach (var item in memberNames){string replaceValue;if (!convertDeclaration.TryGetValue(item.Key, out replaceValue)){replaceValue = item.Key;}if (string.Compare(item.Key, "string", true) == 0){Console.WriteLine("    {0} {1}[256];", replaceValue, item.Value);}else{Console.WriteLine("    {0} {1};", replaceValue, item.Value);}}Console.Write("} ");
コンソール出力をファイル出力(.h)で出すとしぁゎせ。ファイル出力する場合はstreamを引数にするとか工夫しよう。
*Console.WriteLine("typedef struct\r\n{");foreach (var item in memberNames){string replaceValue;if (!convertDeclaration.TryGetValue(item.Key, out replaceValue)){replaceValue = item.Key;}if (string.Compare(item.Key, "string", true) == 0){Console.WriteLine("    {0} {1}[256];", replaceValue, item.Value);}else{Console.WriteLine("    {0} {1};", replaceValue, item.Value);}}Console.Write("} ");
※1より後に出力があるのは、掘り進めた深い階層の構造体を先に定義したいがため

五十順
*string pattern = string.Empty;

*.Concat(Task.Delay(TimeSpan.FromMilliseconds(1000)).ToObservable()
なんとなく待つ

*var length = name.Length;
Warning でない

*int[] numbers = { 0b0000_0001, 0b0000_0010, 0b0000_0011, 0b0000_0100 };
int[] numbers = { 1, 2, 3, 4 };と同じ

*print (json.Get<;double>; (new object[]{"fuga"}));
拡張版の書き方
従来のJsonNodeの書き方でもOK
*print (json["hoge"]["bool"].Get<;bool>; ());

コンソールアプリケーションで実行を確認しました
*using System;
実行が一瞬で終わって確認できないので、キーの入力を待ちます
*Console.ReadLine();
*{private char decochar;public MessageBox(char decochar){this.decochar = decochar;}public void Use(string s){Encoding sjisEnc = Encoding.GetEncoding("Shift_JIS");int length  = sjisEnc.GetByteCount(s);for (int i = 0; i <; length + 4; i++){Console.Write(decochar);}Console.WriteLine("");Console.WriteLine($"{decochar} {s} {decochar}");for (int i = 0; i <; length + 4; i++){Console.Write(decochar);}Console.WriteLine("");}public object Clone(){return this.MemberwiseClone();}public Product CreateClone(){return (Product)this.Clone();}}
ConcretePrototype
*{private char ulchar;public UnderlinePen(char ulchar){this.ulchar = ulchar;}public void Use(string s){Encoding sjisEnc = Encoding.GetEncoding("Shift_JIS");int length = sjisEnc.GetByteCount(s);Console.WriteLine($"\"{s}\"");Console.Write(" ");for (int i = 0; i <; length; i++){Console.Write(ulchar);}Console.WriteLine("");}public object Clone(){return this.MemberwiseClone();}public Product CreateClone(){return (Product)this.Clone();}}
ConcretePrototype
*{void Use(string s);Product CreateClone();}
Prototype
*{private Dictionary<;string, Product>; showcase = new Dictionary<;string, Product>;();public void Register(string name, Product proto){showcase.Add(name, proto);}public Product Create(string protoname){Product p = showcase[protoname];return p.CreateClone();}}
Client

解像度を1.3mに設定
*DesiredAccuracy = 30

globalな変数（う～ん）
*static List<;Slider>; SliderList = new List<;Slider>;();
Sliderを洗い出す
************************
*SliderList = new List<;Slider>;();
総当たりを仕掛ける
************************
*Location Goal = new Location(strX.Length, strY.Length);

インスペクタ上では;区切り
*currentSymbols = PlayerSettings.GetScriptingDefineSymbolsForGroup(BuildTargetGroup.Standalone).Split(';');

event本体：[eventName]には、event名が入ります
*public event EventHandler [eventName];
event本体：[eventName]には、event名が入ります
*public event System.Windows.Forms.UICuesEventHandler ChangeUICues;
event本体：[eventName]には、event名が入ります
*public event System.Windows.Forms.ControlEventHandler [eventName];
event本体：[eventName]には、event名が入ります
*public event System.Windows.Forms.DragEventHandler [eventName];
event本体
*public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;
event本体
*public event System.Windows.Forms.HelpEventHandler HelpRequested;
event本体
*[System.ComponentModel.Browsable(false)]
event本体：[eventName]には、event名が入ります
*public event System.Windows.Forms.KeyEventHandler [eventName];
event本体
*public event System.Windows.Forms.KeyPressEventHandler KeyPress;
event本体
*public event System.Windows.Forms.LayoutEventHandler Layout;
event本体：[eventName]には、event名が入ります
*public event System.Windows.Forms.MouseEventHandler [eventName];
event本体
*public event System.Windows.Forms.PaintEventHandler Paint;
event本体
*public event System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown;
event本体
*public event System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp;
event本体
*public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;
event本体
*public event System.ComponentModel.CancelEventHandler Validating;

*if (pDataObj == IntPtr.Zero)*{
選択されているファイル/ディレクトリを取得
*if (pDataObj == IntPtr.Zero)*{
選択されているファイル/ディレクトリを取得

*hd.TryGetValue("buz", out buz)
false
Relation&lt;string, string&gt;はないのでコンパイルエラー
string hoge;
hd.TryGetValue("hoge", out hoge);
*,,,

=&gt; インスタンスを生成しました。
*Singleton obj2 = Singleton.GetInstance();
=&gt; obj1とobj2は同じインスタンスです。
*}
実行が一瞬で終わって確認できないので、キーの入力を待ちます
*Console.ReadLine();

=&gt; nyanchuのカードを作ります。
*Product card2 = factory.Create("toshi0607");
=&gt; toshi0607のカードを作ります。
*card1.Use();
=&gt; nyanchuのカードを使います。
*card2.Use();
=&gt; toshi0607のカードを使います。
実行が一瞬で終わって確認できないので、キーの入力を待ちます
*Console.ReadLine();
*{public abstract void Use();}
Product
*{public Product Create(string owner){Product p = CreateProduct(owner);RegisterProduct(p);return p;}protected abstract Product CreateProduct(string owner);protected abstract void RegisterProduct(Product product);}
Creator
*{public string Owner { get; private set; }internal IDCard(string owner){Console.WriteLine($"{owner}のカードを作ります。");this.Owner = owner;}public override void Use(){Console.WriteLine($"{Owner}のカードを使います。");}}
ConcreteProduct
*{private List<;string>; Owners { get; set; } = new List<;string>;();protected override Product CreateProduct(string owner){return new IDCard(owner);}protected override void RegisterProduct(Product product){Owners.Add(((IDCard)product).Owner);}}
ConcreteCreator

ダメな奴
同一参照のオブジェクトを返す。1つ変えると全部変わる
*var multiItems = Enumerable.Repeat(new Dummy(0,null),100 );
最初は同じだけど別々のオブジェクト
*var multiItems = Enumerable.Repeat(0,100).Select(v=>;new Dummy(v,null));
Indexをつけたりして最初から別々にしたい場合はRangeにして↑同様に
*var multiItems = Enumerable.Range(0, 100).Select(v =>;new Dummy(v, null));
*{public Dummy(int number,string name){this.Number = number;this.Name = name;}public int Number { get; set; }public string Name { get; set; }public override string ToString(){return $"{this.Number}:{this.Name}";}}
↑で使ったクラス

1.適当に画像を作成
*var image= new WriteableBitmap(width, height, 96, 96, PixelFormats.Gray8, BitmapPalettes.Gray256);
2.この辺で画像をいじる
*byte* dp = (byte*)image.BackBuffer;
3.ここで入れたサイズの領域が更新される。ここがないと真っ黒。
*image.AddDirtyRect(new System.Windows.Int32Rect(0, 0, image.PixelWidth, image.PixelHeight));

*using UniRx.Triggers;
これが必須
フラグが有効な間、上向きに力を加える
*this.FixedUpdateAsObservable()
WarpZoneに侵入したらフラグを有効にする
*this.OnTriggerEnterAsObservable()
WarpZoneから出たらフラグを無効にする
*this.OnTriggerExitAsObservable()
60秒カウントするストリームをコルーチンから作る
*Observable.FromCoroutine<;int>;(observer =>; GameTimerCoroutine(observer, 60))
uGUIのデフォルトのUnityイベントの名前をしたObservableが用意されている
*var button = GetComponent<;Button>;();
なお、このような記述もある
*inputField.onValueChanged.AsObservable().Subscribe();
この2つの記法の違いは、Subscribe時に現在の値を初期値を発行するかどうかである
Subscribe時に初期値が必要である場合は前者を使うとよい
inputField.OnValueChangedAsObservable(); 初期値あり
inputField.onValueChanged.AsObservable();初期値なし
*,,,
https:google.comをHTTP GETする
ObservableWWW.Get("https:google.com")
*.Subscribe(x =>; Debug.Log(x));
CharacterControllerのIsGroundedを監視
false → trueになったらログに出す
*charcterController
↑のコードは↓とほぼ同義
*Observable.EveryUpdate()
ObserveEveryValueChangedは
EveryUpdate + Select + DistinctUntilChanged
の省略記法と思ってよい
*,,,

*string format3 = "%x";
符号なし16進数として出力する
*Console.WriteLine(Format(format, 3.1415926535));*Console.WriteLine(Format(format2, 3.1415926535));
変換指定子を使って数値を変換したい！
結果表示
*Console.ReadLine();

*Console.ReadKey();
キー入力までウィンドウが閉じないようにする

コンソールアプリケーションで実行を確認しました
*using System;
|こんにちは！|
|こんにちは！|
|こんにちは！|
|こんにちは！|
|こんにちは！|
+------------+
実行が一瞬で終わって確認できないので、キーの入力を待ちます
*Console.ReadLine();
*{this.Open();for(int i = 0; i <; 5; i++){this.Print();}this.Close();}
テンプレートメソッド
*{private char Ch { get; set; }public CharDisplay(char ch){this.Ch = ch;}public override void Open(){Console.Write("<;<;");}public override void Print(){Console.Write(Ch);}public override void Close(){Console.WriteLine(">;>;");}}
テンプレートメソッドの挙動はサブクラスでの実装に依る

*Favorites = 8,
Unique
デフォルトタブの存在チェック、ない場合には追加
*…
trueでFavAdd,falseでFavRemove
*,,,
*if (post.IsFav)*favTab.AddPostQueue(post);
Fav済み発言だったらFavoritesタブに追加

114556が出力される。
*Console.WriteLine((x + y)?.ToString() ?? "NULL");
NULLが出力される。
*Console.WriteLine((x + z)?.ToString() ?? "NULL");

*private Plane[] planes = new Plane[6];
Plane配列を使いまわして余計なヒープ確保をさせない
MEMO: 自前でやってもいいのだがInternalはネイティブコードを呼び出すのでこっちの方が早い･･･と思うのだけれど
*var meth = typeof(GeometryUtility).GetMethod("Internal_ExtractPlanes",
カメラの視錘台を取得
*this.CalculateFrustumPlanes(this.planes, Camera.main.projectionMatrix * Camera.main.worldToCameraMatrix);
*Bounds bound = new Bounds(this.transform.position, Vector3.one);*// 視錘台判定はそのまま使う
Boundsサイズは任意
*if (!GeometryUtility.TestPlanesAABB(this.planes, bound))*Debug.LogWarning("Out of Camera");
視錘台判定はそのまま使う

*inputMotor.GetSpeed = () =<; 0;
GetSpeedの動作を入れ替える

*Transform t = this.gameObject.GetComponent<;Transform<;();
=&gt; 約 0.73 秒
*// Transform t = GetComponent<;Transform>;();              // =>; 約 0.53 秒*// Transform t = transform;                              // =>; 約 0.24 秒
Transform t = gameObject.GetComponent&lt;Transform&gt;();    =&gt; 約 0.73 秒
*// Transform t = transform;                              // =>; 約 0.24 秒*}
Transform t = GetComponent&lt;Transform&gt;();               =&gt; 約 0.53 秒
Transform t = transform;                               =&gt; 約 0.24 秒
*}

*public IEnumerable<;string>; Solve() {int[] nums = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };foreach (var s in GetRisingNumbers("", nums)) {if (IsEmirp(s))yield return s;}}
問題を解く 答えは文字列として列挙する
*private IEnumerable<;string>; GetRisingNumbers(string rn, IEnumerable<;int>; nums) {if (nums.Count() == 0)yield break;int i = 0;foreach (var n in nums) {i++;string s = rn + n.ToString();yield return s;foreach (var r in GetRisingNumbers(s, nums.Skip(i)))yield return r;}}
上昇数 を求める 再帰メソッドの中で、yield return を使っている。
*private bool IsEmirp(string s) {if (s.Length >;= 2 &amp;&amp;PrimeNumber.IsPrime(long.Parse(s)) &amp;&amp;PrimeNumber.IsPrime(long.Parse(ReverseString(s))))return true;return false;}
エマープか？
*private string ReverseString(string s) {return new string(s.Reverse().ToArray());}
文字列を反転する

*chart1.Dock = DockStyle.Fill;
特に設定していないなら不要。

*Console.WriteLine(formattedString);
This is a test.

*Console.WriteLine(result.IsCompleted);
false

*var socket = IO.Socket("http:
192.168.1.3:3000");
*{// UIとは別スレッドなので Dispatcher を利用するawait Dispatcher.RunAsync(CoreDispatcherPriority.Normal, () =>;{ReceivedText.Text = "接続しました";});});
接続時のイベント
*{ReceivedText.Text = "接続しました";});
UIとは別スレッドなので Dispatcher を利用する
*{// UIとは別スレッドなので Dispatcher を利用するawait Dispatcher.RunAsync(CoreDispatcherPriority.Normal, () =>;{ReceivedText.Text = Convert.ToString(data);});});
"msg" 受信時
*{ReceivedText.Text = Convert.ToString(data);});
UIとは別スレッドなので Dispatcher を利用する

*if (pDataObj == IntPtr.Zero)*{
選択されているファイル/ディレクトリを取得
*if (((uint)CMF.CMF_DEFAULTONLY &amp; uFlags) != 0)*{
メニュー項目を追加
追加したメニュー項目の数を返す
*return WinError.MAKE_HRESULT(WinError.SEVERITY_SUCCESS, 0, 1);
ici.lpVerb の上位ワードが NULL でなければ
このメソッドは別のアプリケーションによって呼出されたものなので
そのまま返す
*if (WinApi.HighWord(ici.lpVerb.ToInt32()) != 0)
そうでなければ
シェルが呼出したもので
ici.lpVerb の下位ワードが、ユーザが選択したメニュー項目
*if (WinApi.LowWord(ici.lpVerb.ToInt32()) == IDM_SHOW_FILENAME)

*particleSystem.Stop();
ストップ

親ボーンのインデックス なしの場合は-1
*public short ParentIndex;
子ボーンのインデックス なしの場合は0
*public short TailIndex;
ボーンの根本の位置
*public Vector3 HeadPosition;
ボーンの根本の位置
*public Vector3 Position;
親ボーンのインデックス なしの場合は-1
*public int ParentIndex;
子ボーンのインデックス なしの場合は-1
*public int TailIndex;
ボーンの変形階層
*public int Rank;
ボーンの変形フラグ
*public BoneFlagEnum BoneFlag;
*public SkinBone Parent { get; set; }
親ボーン
*public List<;SkinBone>; Children { get; set; }
子ボーンのリスト
*public int Rank { get; private set; }
階層
*public bool IsBeforePhysic { get; private set; }*//初期姿勢行列
物理演算前に変形させるか
*public Matrix Init { get; private set; }
初期姿勢行列
*public Matrix Offset { get; private set; }
オフセット行列
*public Quaternion Rotate { get; set; }
回転量
*public Vector3 Translate { get; set; }
移動量
*public Quaternion MotionRotate { get; set; }
モーション用の回転・移動量
*private void UpdateBone() {foreach(var b in Bones) {b.Bone = CalcTranspose(b.Rotate, b.Translate) * b.Init;if(b.Parent != null) b.Bone *= b.Parent.Bone;}}
ボーン行列の更新
*public Matrix CalcTranspose(Quaternion Rotation, Vector3 Translation) {return Matrix.RotationQuaternion(Rotation) * Matrix.Translation(Translation);}
回転と移動から変換行列の作成
*public Matrix[] Results {get {return Bones.Select(x =>; x.Offset * x.Bone).ToArray();}}
変換行列配列
*if(nowList.Count == 0) continue;*int startFrm = motionList[i].StartFrame;
このボーンのモーションがない場合
*if(endFrm <;= nowFrame) {*var nowAt = nowList.Last();
最後のモーションが終わっている場合
*} else if(nowFrame <; startFrm) {*int nowIdx = 0;
最初のモーションが始まっていない場合
現在のフレームのボーンの動きを取得し、セットする
*boneMng.SetPose(motMng.GetMotion());
変換行列を計算する。
*boneMng.Update();
シェーダにセットする
*effect.SetBoneMatrix(boneMng.Results);
描画
*effect.DrawAll(camera);

*.WithReferences(Assembly.GetEntryAssembly()),
CreviceApp.exe
既にフックが実行されているとして
*Unhook();

*int carry = 0;
繰り上がりの数
例えば N=6,firstDigit=4の場合、最初のループでは、
int a = b * n + carry;        a &lt;- 24 (= 6 * 4 + 0)
int m = a % 10;               m &lt;- 4 (= 24 % 10)
carry = a / 10;               carry &lt;- 2 (= 24 / 10)
b = m;                        現時点での最上位の桁の数は 4 である。
*if (carry == 0 &amp;&amp; b == firstDigit &amp;&amp; r[0] != '0')

ブック作成
*var book = CreateNewBook( filePath );
シート無しのexcelファイルは保存は出来るが、開くとエラーが発生する
*book.CreateSheet( "newSheet" );
*using( var fs = new FileStream( filePath, FileMode.Create ) ) {book.Write( fs );}
ブックを保存
*{IWorkbook book;var extension = Path.GetExtension( filePath );// HSSF =>; Microsoft Excel(xls形式)(excel 97-2003)// XSSF =>; Office Open XML Workbook形式(xlsx形式)(excel 2007以降)if( extension == ".xls" ) {book = new HSSFWorkbook();}else if( extension == ".xlsx" ) {book = new XSSFWorkbook();}else {throw new ApplicationException( "CreateNewBook: invalid extension" );}return book;}
ブック作成
*if( extension == ".xls" ) {book = new HSSFWorkbook();}
HSSF =&gt; Microsoft Excel(xls形式)(excel 97-2003)
*if( extension == ".xls" ) {*book = new HSSFWorkbook();
XSSF =&gt; Office Open XML Workbook形式(xlsx形式)(excel 2007以降)
ブック読み込み
*var book = WorkbookFactory.Create( "sample.xlsx" );
シート名からシート取得
*var sheet = book.GetSheet( "newSheet" );
セルに設定
*WriteCell( sheet, 0, 0, "0-0" );
日付表示するために書式変更
*var style = book.CreateCellStyle();
*using( var fs = new FileStream( "sample2.xlsx", FileMode.Create ) ) {book.Write( fs );}
ブックを保存
*{var row = sheet.GetRow( rowIndex ) ?? sheet.CreateRow( rowIndex );var cell = row.GetCell( columnIndex ) ?? row.CreateCell( columnIndex );cell.SetCellValue( value );}
セル設定(文字列用)
*{var row = sheet.GetRow( rowIndex ) ?? sheet.CreateRow( rowIndex );var cell = row.GetCell( columnIndex ) ?? row.CreateCell( columnIndex );cell.SetCellValue( value );}
セル設定(数値用)
*{var row = sheet.GetRow( rowIndex ) ?? sheet.CreateRow( rowIndex );var cell = row.GetCell( columnIndex ) ?? row.CreateCell( columnIndex );cell.SetCellValue( value );}
セル設定(日付用)
*{var row = sheet.GetRow( rowIndex ) ?? sheet.CreateRow( rowIndex );var cell = row.GetCell( columnIndex ) ?? row.CreateCell( columnIndex );cell.CellStyle = style;}
書式変更

複雑な生成方法のつもり
*WebRule webRule1 = Rule.WebInfo(webConfig).And.Config(myConfig).Build();
複雑な生成方法のつもり
*WebRule webRule1 = WebRule.Rule.WebInfo(webConfig).Config(myConfig);

*Console.WriteLine( $"OS : {( Environment.Is64BitOperatingSystem ? "64bit" : "32bit" )}" );
OSが何ビットで動作しているか確認
*Console.WriteLine( $"プロセス : {( Environment.Is64BitProcess ? "64bit" : "32bit" )}" );
プロセスが何ビットで動作しているか確認
32bit版のC/C++関数の宣言
*[DllImport( "Library32.dll", EntryPoint = "Test" )]
64bit版のC/C++関数の宣言
*[DllImport( "Library64.dll", EntryPoint = "Test" )]
*{if ( Environment.Is64BitProcess )Test_64();elseTest_32();}
現在のプロセスにより32bit/64bit版の関数を呼び分けるラッパーメソッド
*{Test();}
クライアント

コンソールアプリケーションで実行を確認しました
*using System;
*{static void Main(string[] args){Print p = new PrintBanner("Hello");p.PrintWeak();// =>; (Hello)p.PrintStrong();// =>; *Hello*// 実行が一瞬で終わって確認できないので、キーの入力を待ちますConsole.ReadLine();}}
Client
実行が一瞬で終わって確認できないので、キーの入力を待ちます
*Console.ReadLine();
このクラスは既に提供されているものとします
Adaptee
*public class Banner
*{void PrintWeak();void PrintStrong();}
Target
*{public PrintBanner(string str) : base(str) { }public void PrintWeak(){this.ShowWithPattern();}public void PrintStrong(){this.ShowWithAster();}}
Adapter
コンソールアプリケーションで実行を確認しました
*using System;
*{Print p = new PrintBanner("Hello");p.PrintWeak();// =>; (Hello)p.PrintStrong();// =>; *Hello*// 実行が一瞬で終わって確認できないので、キーの入力を待ちますConsole.ReadLine();}
Client
実行が一瞬で終わって確認できないので、キーの入力を待ちます
*Console.ReadLine();
このクラスは既に提供されているものとします
Adaptee
*public class Banner
*{public abstract void PrintWeak();public abstract void PrintStrong();}
Target
*{private Banner banner;public PrintBanner(string str){this.banner = new Banner(str);}public override void PrintWeak(){this.banner.ShowWithPattern();}public override void PrintStrong(){this.banner.ShowWithAster();}}
Adapter

*right_side.subIndices.Count - 1
カット面。最後のサブメッシュとしてトライアングルを追加

*public int ID { get; set; }
データベース上のキー
*public string Name { get; set; }
投稿者名
*public string Comment { get; set; }
投稿内容
*public DateTime ReleaseDate { get; set; }
投稿日時

外部から変更不可
*readonly string s;
外部から変更可能
*readonly List<;string>; str;
Tが参照型の時、コレクション自体は変更できないが、
要素のインスタンス（Tクラス）内部を変更可能
*readonly List<;T>; str = new List<;T>;();

*int sum =i[0]+i[1]+i[2];
3要素の合計

*Motor.CreateMotor = MotorStub.CreateMotorBody;
インスタンス生成メソッドを入れ替える
Act (実行)
*instance.SampleMethod();
Assert (検証)
何か処理が行われたことを確認する
今回は省略
*}

*((MotorStub)inputMotor).SpeedValue = 1;
Speedプロパティが返す値を設定
Act (実行)
*instance.SampleMethod(inputMotor);
Assert (検証)
何か処理が行われたことを確認する
今回は省略
*}

*originalMethod = LcdConsoleWrapper.WriteLine;
もともとのメソッドを退避させる
スタブメソッドに入れ替える
PrivateType privateType = new PrivateType(typeof(LcdConsoleWrapper));    privateなメンバにアクセスするためのオブジェクト
*privateType.SetStaticField(
Act (実行)
*instance.SampleMethod();
Assert (検証)
何か処理が行われたことを確認する
今回は省略
*}

*{FileCopyRetry(sorcePass: "sorce/abc.txt", destPass: "dest/abc.txt", retryCounts: 5, waitMilliSeconds: 500);}
メソッド利用部分
*{Exception exStack = new Exception();foreach (var i in Enumerable.Range(1, retryCounts + 1)){try{File.Copy(sorcePass, destPass);return;}catch (Exception ex){exStack = ex;}if (i <;= retryCounts) Thread.Sleep(waitMilliSeconds);}throw exStack;}
ファイルコピーを行なうメソッド
*{SomeClass.someStaticMethod(() =>; button1_Click(sender, e));}
メソッド呼び出し部
何らかの処理
*}
何らかの処理
*someNonStaticMethod();

*// 中身が{ 0, 0, 0 } のList<;int>;
中身が{ 0, 0, 0 } のint[3]
中身が{ 0, 0, 0 } のList&lt;int&gt;
*var numList = Enumerable.Repeat( 0, 3 ).ToList();
少子化対策
*var persons = Enumerable.Repeat(
*var jobList = new[] { "整備士", "会計士", "弁護士", "運転士", "建築士" };
仕事を与える
自己紹介をお願いします
*persons.ForEach( p =>; Console.WriteLine( p ) );
*{// 以下省略,,,var persons = Enumerable.Range( 0, 5 ).Select( _ =>; new Person( "クローン人間", 20, "無職" ) ).ToArray();,,,using System;using System.Collections.Generic;using System.Linq;namespace Post._20161009{public static class MyEnumerable{/// <;summary>;/// activatorを工夫して、参照型の/// 複数の異なる実体への参照をゲットしよう/// <;/summary>;/// <;typeparam name="T">;<;/typeparam>;/// <;param name="activator">;<;/param>;/// <;param name="count">;<;/param>;/// <;returns>;<;/returns>;public static IEnumerable<;T>; Repeat<;T>;( Func<;int, T>; activator, int count ){for ( int i = 0; i <; count; i++ )yield return activator( i );}}class Program{private static void Main(){// 少子化対策// MyEnumerable.Repeat()の使用箇所var persons = MyEnumerable.Repeat( i =>; new Person( "クローン人間", 20, "無職" ), 5 ).ToList();// 仕事を与えるvar jobList = new[] { "整備士", "会計士", "弁護士", "運転士", "建築士" };persons = persons.Select( ( p, index ) =>;{ p.Job = jobList[index]; return p; } ).ToList();// 自己紹介をお願いしますpersons.ForEach( p =>; Console.WriteLine( p ) );}}},,,以下省略
*,,,
少子化対策
MyEnumerable.Repeat()の使用箇所
*var persons = MyEnumerable.Repeat( i =>; new Person( "クローン人間", 20, "無職" ), 5 ).ToList();
*var jobList = new[] { "整備士", "会計士", "弁護士", "運転士", "建築士" };persons = persons.Select( ( p, index ) =>;{ p.Job = jobList[index]; return p; } ).ToList();// 自己紹介をお願いしますpersons.ForEach( p =>; Console.WriteLine( p ) );}
仕事を与える
自己紹介をお願いします
*persons.ForEach( p =>; Console.WriteLine( p ) );

*user.Password = new PasswordHasher<;SMSUser<;().HashPassword(user, Input.Password);
追加部分
*//    values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },
"/Account/ConfirmEmail",
*//    values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },
pageHandler: null,
*//    $"Please confirm your account by <;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>;clicking here<;/a>;.");
protocol: Request.Scheme);
*//    $"Please confirm your account by <;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>;clicking here<;/a>;.");
await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",
*//if (_userManager.Options.SignIn.RequireConfirmedAccount)*//{
$"Please confirm your account by &lt;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'&gt;clicking here&lt;/a&gt;.");
*//{//    return RedirectToPage("RegisterConfirmation", new { email = Input.Email, returnUrl = returnUrl });//}
if (_userManager.Options.SignIn.RequireConfirmedAccount)
*//    return RedirectToPage("RegisterConfirmation", new { email = Input.Email, returnUrl = returnUrl });
{
*//{await _signInManager.SignInAsync(user, isPersistent: false);return LocalRedirect(returnUrl);//}
}
*//{await _signInManager.SignInAsync(user, isPersistent: false);return LocalRedirect(returnUrl);//}
else
*//public string Email { get; set; }
[Required]
*//public string Email { get; set; }
[EmailAddress]
ここから追加
*services.AddDefaultIdentity<;IdentityUser>;()
ここまで追加
*services.AddControllersWithViews();
*//public string Email { get; set; }
[EmailAddress]
*//public string Email { get; set; }
[Display(Name = "Email")]
*[StringLength(100, ErrorMessage = "{0} は {2} ～ {1} 文字で入力してください。", MinimumLength = 6)]
public string Email { get; set; }
*//    values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },
"/Account/ConfirmEmail",
*//    values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },
pageHandler: null,
*//    $"Please confirm your account by <;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>;clicking here<;/a>;.");
protocol: Request.Scheme);
*//    $"Please confirm your account by <;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>;clicking here<;/a>;.");
await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",
*if (_userManager.Options.SignIn.RequireConfirmedAccount)*{
$"Please confirm your account by &lt;a href='{HtmlEncoder.Default.Encode(callbackUrl)}'&gt;clicking here&lt;/a&gt;.");
*//public string Email { get; set; }
[Required]
*//public string Email { get; set; }
[EmailAddress]

Stateの初期化
*StateClient stateClient = activity.GetStateClient();
UserDataの値取り出し
*BotData userData = await stateClient.BotState.GetUserDataAsync(activity.ChannelId, activity.From.Id);
UserDataの値セット
*userData.SetProperty<;boot>;("Greeting", true);
*if (activity.Text == "Hello" || activity.Text == "こんにちは")*{
activity.Textがユーザから送られてきた文章
既定文にヒットしなかったらLUISを呼ぶ
*await LUIS(activity);

*double sigma_C = 0;
i=0 のときは計算されない。つまりZ[0]=B[0]
あらかじめ用意しておく
*List<;double>; A_press = (num * 2 - 1).Loop(i =>; gain.Select_ToList(a =>; Math.Pow(a, i)).Sum());
A行列の場合、i+jがそのまま次数となるためそれを利用
*List<;List<;double>;>; A = num.Loop(i =>; num.Loop(j =>; A_press[i + j]));
上記で、行列AをL行列、U行列に分解
下記で、Ax=B⇒LUx=B⇒Ly=Bからyを求める
c行列の計算
List&lt;double&gt; Z = ListUtil.CreateNewList&lt;double&gt;(num); 指定数の配列を作成する独自の拡張メソッド
*for (int i = 0; i <; num; i++)
最後にy(既知)=Uxを計算しxをはじき出す
出力行列の計算
*List<;double>; res = ListUtil.CreateNewList<;double>;(num);

*public static IEnumerable<;int>; Take(int n) {yield return 0;int ans = 0;for (int i = 1; i <; n; i++) {ans += i;yield return ans;}}
三角数を列挙する
*public static bool IsCorrect(long x) {long a = 8 * x + 1;long b = (long)(Math.Sqrt(a));if (b * b != a)return false;return (b - 1) % 2 == 0;}
三角数かを調べる
*public static long GetAt(int nth) {return (long)nth * (nth + 1) / 2;}
ｎ番目の三角数を求める

*string _apiUrlBase = "https:
api.projectoxford.aivisionv1.0generateThumbnail";
*var uri = $"{_apiUrlBase}?width={width}&amp;height={height}&amp;smartCropping={smartCropping.ToString()}&amp;Subscription-Key={_subscriptionKey.ToString()}";
get response

*{return new Point(nth * MapChipSize, 0);}
指定したマップチップのMapImage上での開始位置を返します。
*{var mcpoint = GetMapChipPoint(nth);Rectangle rect = new Rectangle(mcpoint.X, mcpoint.Y, MapChipSize, MapChipSize);Bitmap bmpNew = MapImage.Clone(rect, MapImage.PixelFormat);return bmpNew;}
指定したマップチップの画像を返します
*{var mapdata = this.Maps[nth];var xLen = mapdata.MapChips.GetLength(1);var yLen = mapdata.MapChips.GetLength(0);var bmp = new Bitmap(xLen * this.MapChipSize, yLen * this.MapChipSize);Graphics g = Graphics.FromImage(bmp);for(int y = 0; y <; yLen; y++){for (int x = 0; x <; xLen; x++){var mapchip = this.GetMapChip(mapdata.MapChips[y, x]);g.DrawImage(mapchip, new PointF(x * this.MapChipSize, y * this.MapChipSize));mapchip.Dispose();}}g.Dispose();return bmp;}
指定したマップの画像を返します。
*var integerMapChips = new int[,] {{ 0,0,0,0,0,0,0,0,0 },{ 0,0,0,0,0,0,0,0,0 },{ 0,0,2,0,0,0,0,0,0 },{ 0,0,0,0,1,0,0,0,0 },{ 0,1,0,0,0,0,0,0,0 },{ 0,0,0,0,0,0,0,0,0 },{ 0,0,0,0,0,0,0,0,0 }};
今回表示するマップのマップチップ配列。0:草原,1:山,2:家

*var points = new[] { 20, 30, 40, 40, 50 };
コレクションを用意
*// ----------------- foreach版--------------------*// 結果を受け取る配列を用意
全て２倍した集合がほしい！
----------------- foreach版--------------------
結果を受け取る配列を用意
*var result1 = new int[points.Length];
ポインタを作成
*var i = 0;
*foreach (var p in points)*{
全て２倍して表示したい
配列に2倍した値を入力
*result1[i] = p * 2;
ポインタを更新
*i++;
画面に表示
*Console.WriteLine(string.Join(",", result1));
----------------- Linq版--------------------
2倍した集合を取得
*var result2 = points.Select(x =>; x * 2).ToArray();
画面に表示
*Console.WriteLine(string.Join(",", result2));
*var points = new[] { 20, 30, 40, 40, 50 };
コレクションを用意
*// ----------------- foreach版--------------------*// 結果を受け取るリストを用意
４０以上の値だけ抜き出したい！
----------------- foreach版--------------------
結果を受け取るリストを用意
*var result1 = new List<;int>;();
*foreach (var p in points)*{
40以上の値だけ抜き出したい！
リストに値を追加
*result1.Add(p);
画面に表示
*Console.WriteLine(string.Join(",", result1));
----------------- Linq版--------------------
40以上の値だけ抜き出したい！
*var result2 = points.Where(x =>; x >;= 40).ToList();
画面に表示
*Console.WriteLine(string.Join(",", result2));
*var points = new[] { 20, 30, 40, 40, 50 };
コレクションを用意
*// ----------------- foreach版--------------------*// 結果を受け取るリストを用意
重複を排除したい！
----------------- foreach版--------------------
結果を受け取るリストを用意
*var result1 = new List<;int>;();
*foreach (var p in points)*{
重複を排除したい！
*if(!result1.Contains(p))*{
すでに追加されていない場合
リストに値を追加
*result1.Add(p);
画面に表示
*Console.WriteLine(string.Join(",", result1));
----------------- Linq版--------------------
重複を排除したい！
*var result2 = points
画面に表示
*Console.WriteLine(string.Join(",", result2));
*var points1 = new[] { 20, 30, 40, 40, 50 };
コレクションを用意
*var points2 = new[] { 60, 70, 70, 80 };
コレクションを用意
*// ----------------- foreach版--------------------*// 結果を受け取るリストを用意
くっつける！
----------------- foreach版--------------------
結果を受け取るリストを用意
*var result1 = new List<;int>;();
*foreach (var p in points1)*{
くっつける！
points1の値を入れる
*result1.Add(p);
*foreach (var p in points2)*{
くっつける！
points2の値を入れる
*result1.Add(p);
画面に表示
*Console.WriteLine(string.Join(",", result1));
----------------- Linq版--------------------
くっつける！
*var result2 = points1.Concat(points2).ToList();
画面に表示
*Console.WriteLine(string.Join(",", result2));
*var points = new[] { 20, 30, 40, 40, 50 };
コレクションを用意
*// ----------------- foreach版--------------------*// 結果を受け取るリストを用意
3つ飛ばして4つ目から見たい！
----------------- foreach版--------------------
結果を受け取るリストを用意
*var result1 = new List<;int>;();
*for (int i = 3; i <; points.Length; i++)*{
3つ飛ばして4つ目から見たい！
pointsの値を入れる
*result1.Add(points[i]);
画面に表示
*Console.WriteLine(string.Join(",", result1));
----------------- Linq版--------------------
3つ飛ばして4つ目から見たい！
*var result2 = points.Skip(3).ToList();
画面に表示
*Console.WriteLine(string.Join(",", result2));
*var points = new[] { 20, 30, 40, 40, 50 };
コレクションを用意
*// ----------------- foreach版--------------------*// 結果を受け取るリストを用意
2つ目から4つ目まで見たい!
----------------- foreach版--------------------
結果を受け取るリストを用意
*var result1 = new List<;int>;();
*for (int i = 1; i <; 4; i++)*{
2つ目から4つ目まで見たい!
pointsの値を入れる
*result1.Add(points[i]);
画面に表示
*Console.WriteLine(string.Join(",", result1));
----------------- Linq版--------------------
2つ目から4つ目まで見たい!
*var result2 = points.Skip(1).Take(3).ToList();
画面に表示
*Console.WriteLine(string.Join(",", result2));
----------------- 表示--------------------
*Console.ReadLine();
*var productList = new Dictionary<;string, int>; {{ "りんご", 200 },{ "バナナ", 150 },{ "すいか", 150 },{ "ぶどう", 400 },};
コレクションを用意
*// ----------------- foreach版--------------------*// 結果を受け取るDictionaryを作成
全てのValueを+50したDictionaryがほしい！
----------------- foreach版--------------------
結果を受け取るDictionaryを作成
*var result1 = new Dictionary<;string, int>;();
*foreach (var i in productList)*{
全てのValueを+50したDictionaryを取得
----------------- Linq版--------------------
全ての要素を+50したDictionaryを取得
*var result2 = productList
*Console.WriteLine(string.Join("\n", elements.Select(x =>; {return x.Key + "\t" + x.Value;})));
Key、Valueのペアを表示

鍵のジェネレータ
*var randGen = new CryptoApiRandomGenerator();
鍵生成
*var keyGen = new RsaKeyPairGenerator();
*var attr = new Dictionary<;DerObjectIdentifier, string>;()*{
証明書の属性
証明書の生成
*var name = new X509Name(ord, attr);
*{var pemWriter = new PemWriter(writer);pemWriter.WriteObject(keyPair.Private);pemWriter.Writer.Flush();}
秘密鍵の出力
*{var pemWriter = new PemWriter(writer);pemWriter.WriteObject(keyPair.Public);pemWriter.Writer.Flush();}
公開鍵の出力
*using (var writer = new StreamWriter(@"D:\Downloads\certificate.crt", false, Encoding.ASCII))*{
証明書の出力
*{var pemReader = new PemReader(reader);privateKey = (AsymmetricCipherKeyPair)pemReader.ReadObject();}
秘密鍵の読み込み
*{var pemReader = new PemReader(reader);publicKey = (RsaKeyParameters)pemReader.ReadObject();}
公開鍵の読み込み
*using (var reader = new StreamReader(@"D:\Downloads\certificate.crt", Encoding.ASCII))*{
証明書の読み込み
*var certEntry = new X509CertificateEntry(cert);*var keyEntry = new AsymmetricKeyEntry(privateKey.Private);
PKCS12の生成
*{p12.Save(stream, "password".ToCharArray(), rand);stream.Flush();}
PKCS12の出力
*{readedP12 = new Pkcs12Store(stream, "password".ToCharArray());}
PKCS12の読み込み
*{var pemWriter = new PemWriter(writer);pemWriter.WriteObject(readedP12.GetKey("tana").Key);pemWriter.Writer.Flush();}
秘密鍵の取得と書き込み

*{BookShelf bookShelf = new BookShelf();bookShelf.appendBook(new Book("Around the world in 80 days"));bookShelf.appendBook(new Book("Bible"));bookShelf.appendBook(new Book("Cinderella"));bookShelf.appendBook(new Book("Daddy-Long-Legs"));IIterator it = bookShelf.Iterator();while(it.HasNext()){Book book = (Book)it.Next();Console.WriteLine(book.Name);}// 実行結果// Around the world in 80 days// Bible// Cinderella// Daddy-Long-Legs// 実行が一瞬で終わって確認できないので、キーの入力を待ちますConsole.ReadLine();}
コンソールアプリケーションで実行を確認しました
実行結果
Around the world in 80 days
Bible
Cinderella
Daddy-Long-Legs
実行が一瞬で終わって確認できないので、キーの入力を待ちます
*Console.ReadLine();
*{IIterator Iterator();}
集合体を表すインターフェース
*{bool HasNext();object Next();}
数え上げ、スキャンを表すインターフェース
*{public string Name { get; set; }public Book(string name){this.Name = name;}}
本を表すクラス
*{List<;Book>; books = new List<;Book>;();int Last { get; set; } = 0;public Book GetBookAt(int index){return books[index];}public void appendBook(Book book){this.books.Add(book);Last++;}public int GetLength(){return this.Last;}public IIterator Iterator(){return new BookShelfIterator(this);}}
本棚を表すクラス
*{BookShelf BookShelf { get; set; }int Index { get; set; }public BookShelfIterator(BookShelf bookShelf){this.BookShelf = bookShelf;this.Index = 0;}public bool HasNext(){if(Index <; BookShelf.GetLength()){return true;} else {return false;}}public object Next(){Book book = BookShelf.GetBookAt(Index);this.Index++;return book;}}
本棚をスキャンするクラス

*void Start () {}
Use this for initialization
*void Update () {float x = Input.GetAxisRaw ("Horizontal");float y = Input.GetAxisRaw ("Vertical");//移動する向きを求めるVector2 direction = new Vector2 (x, y);moveObject.Move (direction);if (Input.GetKey (KeyCode.Z)) {//プレイヤーと同じ位置/角度で発射StartCoroutine(spaceShip.Shot(transform));}}
Update is called once per frame
移動する向きを求める
*Vector2 direction = new Vector2 (x, y);
*StartCoroutine(spaceShip.Shot(transform));*}
プレイヤーと同じ位置/角度で発射
*{// レイヤー名を取得string layerName = LayerMask.LayerToName(c.gameObject.layer);// レイヤー名がBullet (Enemy)の時は弾を削除if( layerName == "Bullet(Enemy)"){// 弾の削除Destroy(c.gameObject);}// レイヤー名がBullet (Enemy)またはEnemyの場合は爆発if( layerName == "Bullet(Enemy)" || layerName == "Enemy"){// 爆発するspaceShip.Explosion();// プレイヤーを削除Destroy (gameObject);}}
ぶつかった瞬間に呼び出される
レイヤー名を取得
*string layerName = LayerMask.LayerToName(c.gameObject.layer);
*if( layerName == "Bullet(Enemy)")*{
レイヤー名がBullet (Enemy)の時は弾を削除
弾の削除
*Destroy(c.gameObject);
*if( layerName == "Bullet(Enemy)" || layerName == "Enemy")*{
レイヤー名がBullet (Enemy)またはEnemyの場合は爆発
爆発する
*spaceShip.Explosion();
プレイヤーを削除
*Destroy (gameObject);
*void Start () {}
Use this for initialization
*void Update () {Vector2 direction = new Vector2 (1, 1);moveObject.Move (direction);StartCoroutine(spaceShip.Shot(transform));}
Update is called once per frame
レイヤー名を取得
*string layerName = LayerMask.LayerToName(c.gameObject.layer);
*if( layerName != "Bullet(Player)") return;*// 弾の削除
レイヤー名がBullet (Player)以外の時は何も行わない
弾の削除
*Destroy(c.gameObject);
爆発
*spaceShip.Explosion();
エネミーの削除
*Destroy(gameObject);

*void Start () {idx = 0;Profiler.BeginSample("ClampPattern1");clamp1();Profiler.EndSample();idx = 0;Profiler.BeginSample("ClampPattern2");clamp2();Profiler.EndSample();idx = 0;Profiler.BeginSample("ClampPattern3");clamp3();Profiler.EndSample();UnityEditor.EditorApplication.isPlaying = false;}
Use this for initialization

*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame
弾の発射間隔
*public float shotDelay;
弾を打てるか
*public bool canShot;
次の弾の
*private bool isRunning = false;
*if (!canShot)*yield break;
弾を打てるか
*if (isRunning)*yield break;
弾の発射準備中か
*void Start () {}
Use this for initialization
*void Update () {float x = Input.GetAxisRaw ("Horizontal");float y = Input.GetAxisRaw ("Vertical");//移動する向きを求めるVector2 direction = new Vector2 (x, y);moveObject.Move (direction);if (Input.GetKey (KeyCode.Z)) {//プレイヤーと同じ位置/角度で発射StartCoroutine(spaceShip.Shot(transform));}}
Update is called once per frame
移動する向きを求める
*Vector2 direction = new Vector2 (x, y);
*StartCoroutine(spaceShip.Shot(transform));*}
プレイヤーと同じ位置/角度で発射
*void Start () {}
Use this for initialization
*void Update () {Vector2 direction = new Vector2 (1, 1);moveObject.Move (direction);StartCoroutine(spaceShip.Shot(transform));}
Update is called once per frame
*void Start () {Vector2 direction = new Vector2 (1, 1);moveObject.Move (direction);}
Use this for initialization
*void Update () {}
Update is called once per frame

処理
*}

*protected virtual void MouseInput(object sender, Rwin.MouseInputEventArgs e) { }
using SlimDX.Multimedia;
*protected virtual void MouseInput(object sender, Rwin.MouseInputEventArgs e) { }
using Rwin = SlimDX.RawInput;
処理
*break;
*protected override void MouseInput(object sender, Rwin.MouseInputEventArgs e) {switch(e.ButtonFlags) {case Rwin.MouseButtonFlags.MiddleDown:isMiddleMoving = true;break;case Rwin.MouseButtonFlags.MiddleUp:isMiddleMoving = false;break;}if(isMiddleMoving) {movingNow.posX += e.X;movingNow.posY += e.Y;}if(e.WheelDelta >; 0) {movingNow.posZ++;} else if(e.WheelDelta <; 0) {movingNow.posZ--;}}
省略
省略
*public int rotX;
*public void ResetRotXY() { rotX = rotY = 0; }
省略
省略
*case Rwin.MouseButtonFlags.RightDown:
*if(isRightMoving) {*movingNow.rotX += e.X;
省略
省略
*}

*{// https://www.google.co.jp に遷移させるwebDriver.Url = @"https://www.google.co.jp";// #lst-ibの要素を取得するIWebElement element = webDriver.FindElement(By.CssSelector("#lst-ib"));// 上記取得した要素に対してテキストを入力してサブミットelement.SendKeys("Selenium2");element.Submit();// 一瞬で完了するため3秒スリープThread.Sleep(TimeSpan.FromSeconds(3));// ブラウザを閉じるwebDriver.Quit();}
AppSettings.BrowserName.Firefoxを変更することによって対象のブラウザを変更できます
https:www.google.co.jp に遷移させる
webDriver.Url = @"https:www.google.co.jp";
#lst-ibの要素を取得する
*IWebElement element = webDriver.FindElement(By.CssSelector("#lst-ib"));
上記取得した要素に対してテキストを入力してサブミット
*element.SendKeys("Selenium2");
一瞬で完了するため3秒スリープ
*Thread.Sleep(TimeSpan.FromSeconds(3));
ブラウザを閉じる
*webDriver.Quit();

*OnDamage += (damage) =>; { Player.SetDamage(damage); };
ダメージ通知の関数を登録.
実際にダメージを与える
*OnDamage.Invoke(100);
~~~ (略) ~~~
登録した関数を全破棄.
*OnDamage.Clear();

約数を算出したい値
*long N = 100;
算出した約数を格納するリスト
*List<;long>; ans = new List<;long>;();
約数列挙
--------
iが割り切れたらiの2乗も割り切れるので、Forループの条件はi*iで加算していくように設定する
大きな値にも対応できるようlong型でループする
*for (long i = 1; i * i <;= N; i++)
iの値が割り切れるなら約数なのでリストに追加
*ans.Add(i);
iと(N/i)が同じ値でない時は(N/i)の値もリストに追加する(約数である)
ex:N=100のとき、i=2,N/i=50
ex:N=100のとき、i=10,N/i=10
↑昇順と降順で走査してるのでいずれ値がぶつかる。
ぶつかった値を入れてしまうと同じ値が二重にリストに追加されてしまうのでそれを避ける。
*if (i != N / i)
リストを昇順にならべかえ
*ans.Sort();
*foreach (var item in ans)*{
順番に出力

描画処理
*}

*br.ReadSingle();
バージョン(読み飛ばし)

*Vector3 pos = Camera.main.WorldToScreenPoint(transform.position);*// draw health bar background
Draw a health bar.

"0"をセット
*dataGridView1[0, 0].Value = 0.ToString();
"0"をセット
*dataGridView1.Rows[0].Cells[0].Value = 0.ToString();
空白行を追加
*dataGridView1.Rows.Add();
*dataGridView1.Rows.Add(new string[] { "1", "Good Product" });
セル内容を指定して行を追加

*{//Rijindaelのブロックサイズの設定//初期値128ビットを256ビットに変更rijndael.BlockSize = 256;}
Rijindaelのオブジェクトを作成
Rijindaelのブロックサイズの設定
初期値128ビットを256ビットに変更
*rijndael.BlockSize = 256;

10000.Loopは1万回ループしていると思ってください
*,,,

移動スピード
*public float speed;
弾を撃つ間隔
*public float shotDelay;
弾のPrefab
*public GameObject bullet;
弾を撃つかどうか
*public bool canShot;
*public void Shot (Transform origin)*{
弾の作成
*{GetComponent<;Rigidbody2D>;().velocity = direction * speed;}
機体の移動
弾の発射間隔
*public float shotDelay;
弾を打てるか
*public bool canShot;
次の弾を打つインターバルが終わっているか
*private bool isRunning = false;
*protected IEnumerator Shot(Transform origin){*if (!canShot)
弾の作成
*void Start () {}
Use this for initialization
*void Update () {float x = Input.GetAxisRaw ("Horizontal");float y = Input.GetAxisRaw ("Vertical");//移動する向きを求めるVector2 direction = new Vector2 (x_speed * x, y_speed * y);base.Move (direction);if (Input.GetKey (KeyCode.Z)) {//プレイヤーと同じ位置/角度で発射StartCoroutine(Shot(transform));}}
Update is called once per frame
移動する向きを求める
*Vector2 direction = new Vector2 (x_speed * x, y_speed * y);
*StartCoroutine(Shot(transform));*}
プレイヤーと同じ位置/角度で発射
*void Start () {}
Use this for initialization
*void Update () {Vector2 direction = new Vector2 (x_speed, -y_speed);base.Move (direction);StartCoroutine(Shot(transform));}
Update is called once per frame
*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame

移動スピード
*public float speed = 5;
PlayerBulletプレハブ
*public GameObject bullet;
*{while (true) {// 弾をプレイヤーと同じ位置/角度で作成Instantiate (bullet, transform.position, transform.rotation);// 0.05秒待つyield return new WaitForSeconds (0.05f);}}
Startメソッドをコルーチンとして呼び出す
*Instantiate (bullet, transform.position, transform.rotation);*// 0.05秒待つ
弾をプレイヤーと同じ位置/角度で作成
0.05秒待つ
*yield return new WaitForSeconds (0.05f);
右・左
*float x = Input.GetAxisRaw ("Horizontal");
上・下
*float y = Input.GetAxisRaw ("Vertical");
移動する向きを求める
*Vector2 direction = new Vector2 (x, y).normalized;
移動する向きとスピードを代入する
*GetComponent<;Rigidbody2D>;().velocity = direction * speed;
*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame
PlayerBulletプレハブ
*public GameObject bullet;
*{while (true) {// 弾をプレイヤーと同じ位置/角度で作成Instantiate (bullet, transform.position, transform.rotation);// 0.05秒待つyield return new WaitForSeconds (0.05f);}}
Startメソッドをコルーチンとして呼び出す
*Instantiate (bullet, transform.position, transform.rotation);*// 0.05秒待つ
弾をプレイヤーと同じ位置/角度で作成
0.05秒待つ
*yield return new WaitForSeconds (0.05f);
右・左
*float x = Input.GetAxisRaw ("Horizontal");
上・下
*float y = Input.GetAxisRaw ("Vertical");
移動する向きを求める
*Vector2 direction = new Vector2 (x, y).normalized;
移動する向きとスピードを代入する
*base.Move(direction);

本当は await AsyncV();としたかった
*AsyncV();

*.ToDictionary(o =<; o["AccountNumber"].ToString(), o =<; o);
AccountNumberをキー、DataRowViewを値とするDictionaryに変換

*{parse.Configuration.HasHeaderRecord = false;parse.Configuration.RegisterClassMap<;M>;();List<;T>; data = parse.GetRecords<;T>;().ToList();return data;}
絶対ファイルパス
*{class SVM{MulticlassSupportVectorMachine msvm;double[][] inputs { get; set; }int[] outputs { get; set; }public SVM(double[][] inputs, int[] outputs){this.inputs = inputs;this.outputs = outputs;}public SVM() { }public void learn(){var kernel = new Accord.Statistics.Kernels.Linear();var classes = outputs.GroupBy(x =>; x).Count();msvm = new MulticlassSupportVectorMachine(0, kernel, classes);var teacher = new MulticlassSupportVectorLearning(msvm, inputs, outputs);teacher.Algorithm = (machine, inputs, outputs, class1, class2) =>;{var smo = new SequentialMinimalOptimization(machine, inputs, outputs);smo.UseComplexityHeuristic = true;return smo;};teacher.Run();}public int predict(double[] data){var result = msvm.Compute(data);return result;}}}
http:accord-framework.net/docs/html/N_Accord_MachineLearning_VectorMachines.htm
*var preIndex = truelabel.Select((x, i) =>; new { Content = x, Index = i })
ラベルがitemのもののindexを正解ラベルからとってくる

*Debug.WriteLine(a);
買い物 掃除 洗濯

*dog4.Naku2();
わん わん

*private int _interval = 1 * 1000;
呼び出し間隔（ミリ秒）

コントロールを生成したスレッドではないスレッドから操作することはできない
progressBar1.Value = i;
Invokeメソッドを使う
*progressBar1.Invoke(new DelBar(SetBarValue), new object[] { i });
5秒後に実行
*Debug.WriteLine("done.");
.NET4.0～使用可
*Task t1 = Task.Factory.StartNew(Worker);
.NET4.0～使用可
*Task t2 = new Task(Worker);
.NET4.5～使用可
*Task t3 = Task.Run(() =>; Worker());
全てのタスクが終了するまで待機
*Task.WaitAll(t1, t2, t3);

処理
*}
処理
*}

*num[i] = string.Format("num_{0}", i);
84byte
*num[i] = $"num_{i.ToString()}";
64byte
*for (int i = 0; i <; 1000; i++)*{
8.3Kbyte
*for (int i = 0; i <; 1000; i++)*{
4.0Kbyte
*for (int i = 0; i <; 100; i++)*{
10.9Kbyte
*for (int i = 0; i <; 100; i++)*{
112byte
*{byte a;long b;byte c;long d;byte e;long f;byte g;long h;}
80byte
*{long b;long d;long f;long h;byte a;byte c;byte e;byte g;}
56byte
*foreach (var touch in Input.touches)*{
80byte
*for (int i = 0; i <; Input.touchCount; i++)*{
0byte
animators.parameters[i].nameとほぼ同じ
*Debug.Log(animator.GetParameter(i).name);

検査結果エレメント
*IEnumerable<;XElement>; q = from n in xdoc.Descendants(ex + "observation")
検査内容(コード、検査項目名)
*IEnumerable<;XElement>; s = from n in ee.Descendants(ex + "code")
検査結果()
*IEnumerable<;XElement>; t = from n in ee.Descendants(ex + "value")

Azure Storageにデータを入れる
*var storageAccount = new CloudStorageAccount(new StorageCredentials(_storageAccountName,_storageAccessKey),false);

*var sum = evens.Sum();
二つ目のループ・・・のようには別れません

*{[DllImport("user32.dll")]extern static int RegisterHotKey(IntPtr HWnd, int ID, int MOD_KEY, Keys KEY);[DllImport("user32.dll")]extern static int UnregisterHotKey(IntPtr HWnd, int ID);const int WM_HOTKEY = 0x0312;public readonly int modKey;public readonly Keys key;public readonly int id;public readonly ThreadStart proc;//ホットキー登録public HotKeyForm(int modKey, Keys key, ThreadStart proc){for (int i = 0x0000; i <;= 0xbfff; i++){if (RegisterHotKey(this.Handle, i, modKey, key) != 0){this.modKey = modKey;this.key = key;this.id = i;this.proc = proc;break;}}}//ウィンドウメッセージ監視protected override void WndProc(ref Message m){base.WndProc(ref m);//ホットキーが押された時の処理if (m.Msg == WM_HOTKEY){if ((int)m.WParam == this.id){this.proc();}}}//ホットキー解除protected override void Dispose(bool disposing){UnregisterHotKey(this.Handle, this.id);base.Dispose(disposing);}}
クラス（ホットキー登録・解除用フォーム）
*{for (int i = 0x0000; i <;= 0xbfff; i++){if (RegisterHotKey(this.Handle, i, modKey, key) != 0){this.modKey = modKey;this.key = key;this.id = i;this.proc = proc;break;}}}
ホットキー登録
*{base.WndProc(ref m);//ホットキーが押された時の処理if (m.Msg == WM_HOTKEY){if ((int)m.WParam == this.id){this.proc();}}}
ウィンドウメッセージ監視
*if (m.Msg == WM_HOTKEY)*{
ホットキーが押された時の処理
*{UnregisterHotKey(this.Handle, this.id);base.Dispose(disposing);}
ホットキー解除
*{public List<;HotKeyForm>; HotKeyFormList;//ホットキー登録・解除用フォームを表示すると、ウィンドウメッセージの監視が開始されるprivate void HotKeyController_Load(object sender,EventArgs e){foreach (HotKeyForm hotKeyForm in this.HotKeyFormList){hotKeyForm.WindowState = System.Windows.Forms.FormWindowState.Minimized;hotKeyForm.Show();hotKeyForm.Hide();}}private void HotKeyController_FormClosing(object sender,EventArgs e){foreach (HotKeyForm hotKeyForm in this.HotKeyFormList){if (!hotKeyForm.IsDisposed){hotKeyForm.Close();}}}public HotKeyController(){this.HotKeyFormList = new List<;HotKeyForm>;();this.WindowState = System.Windows.Forms.FormWindowState.Minimized;this.ShowInTaskbar = false;this.Load += HotKeyController_Load;this.FormClosing += HotKeyController_FormClosing;}}
クラス（ホットキー制御用フォーム）
*{foreach (HotKeyForm hotKeyForm in this.HotKeyFormList){hotKeyForm.WindowState = System.Windows.Forms.FormWindowState.Minimized;hotKeyForm.Show();hotKeyForm.Hide();}}
ホットキー登録・解除用フォームを表示すると、ウィンドウメッセージの監視が開始される

*app.Run(context =>; {StringBuilder sb = new StringBuilder();switch(context.Request.Path.Value) {case "/":context.Response.Redirect("/select");break;case "/select":sb.AppendLine(@"<;!DOCTYPE HTML>;");sb.AppendLine(@"<;html lang=""ja"">;");sb.AppendLine(@"<;head>;");sb.AppendLine(@"<;meta charset=""UTF-8"">;");sb.AppendLine(@"<;meta name=""viewport"" content=""width = 300"">;");sb.AppendLine(@"<;title>;画像転送<;/title>;");sb.AppendLine(@"<;/head>;");sb.AppendLine(@"<;body>;");sb.AppendLine(@"<;h1>;画像転送<;/h1>;<;br/>;");sb.AppendLine(@"<;form action=""upload"" method=""post"" enctype=""multipart/form-data"">;");sb.AppendLine(@"<;input type=""file"" name=""upfile"" multiple=""multiple""/>;<;br/>;<;br/>;");sb.AppendLine(@"<;input type=""submit"" value=""転送""/>;");sb.AppendLine(@"<;/form>;");sb.AppendLine(@"<;/body>;");sb.AppendLine(@"<;/html>;");context.Response.Write(sb.ToString());break;case "/upload":for(int i=0; i<;context.Request.Files.Count; i++) {string fileName = Path.GetFileName(context.Request.Files[i].FileName),;fileName = Regex.Replace(fileName, @"(?=\.\w+$)|(?<;!\.\w+)$", DateTime.Now.ToString("yyyyMMddHHmmssfff"));context.Request.Files[i].SaveAs(Path.Combine(imgPath, fileName));Thread.Sleep(1);}sb.AppendLine(@"<;!DOCTYPE HTML>;");sb.AppendLine(@"<;html lang=""ja"">;");sb.AppendLine(@"<;head>;");sb.AppendLine(@"<;meta charset=""UTF-8"">;");sb.AppendLine(@"<;meta name=""viewport"" content=""width = 300"">;");sb.AppendLine(@"<;title>;画像転送<;/title>;");sb.AppendLine(@"<;/head>;");sb.AppendLine(@"<;body>;");sb.AppendLine(@"<;a href=""select"">;<;button>;戻る<;/button>;<;/a>;");sb.AppendLine(@"<;/body>;");sb.AppendLine(@"<;/html>;");context.Response.Write(sb.ToString());break;default:context.Response.StatusCode = 404;break;}return context.Response.WriteAsync(string.Empty);});
アプリケーションの設定方法の詳細については、http:go.microsoft.com/fwlink/?LinkID=316888 を参照してください

AtlasTextureの生成.
*AtlasTex = new Texture2D(2048, 2048);
Unity起動直後は正確に計測できないのでしばらく待つ.
*yield return new WaitForSeconds(3f);
~~~~~計測開始~~~~~
*Stopwatch sw = new Stopwatch();
*Rects = AtlasTex.PackTextures(new [] {BodyTex, HairTex, EyeTex}, 2);
TextureのAtlas化を行う.
*Rects = AtlasTex.PackTextures(new [] {BodyTex, HairTex, EyeTex}, 2);
Rects に各Textureの領域情報が返ってくる、順番は引数のTexture配列と同じ.
Atlas用のMaterialにAtlasTextureを割り当てる
*AtlasMaterial.mainTexture = AtlasTex;
PackTextureに渡した順番でUVを更新
*ApplyUVAndMaterial(BodyMeshs, Rects[0], AtlasMaterial);
~~~~~計測終了~~~~~
*sw.Stop();
*{foreach (var mesh in meshs){var uvs = new List<;Vector2>;();// 元のMesh情報を上書きしないように、Instanctiateしてメッシュをコピーmesh.sharedMesh = Instantiate(mesh.sharedMesh);// 元々のUV情報を取得mesh.sharedMesh.GetUVs(0, uvs);// Atlasマテリアルを割り当てmesh.material = atlasMaterial;for (int i = 0; i <; uvs.Count; ++i){// Atlas化してずれたUVを更新する.uvs[i] = new Vector2(uvs[i].x * rect.width + rect.x, uvs[i].y * rect.height + rect.y);// 新しいUVを割り当てmesh.sharedMesh.SetUVs(0, uvs);}}}
UVを更新して、AtlasMaterialを割り当てる
元のMesh情報を上書きしないように、Instanctiateしてメッシュをコピー
*mesh.sharedMesh = Instantiate(mesh.sharedMesh);
元々のUV情報を取得
*mesh.sharedMesh.GetUVs(0, uvs);
Atlasマテリアルを割り当て
*mesh.material = atlasMaterial;
Atlas化してずれたUVを更新する.
*uvs[i] = new Vector2(uvs[i].x * rect.width + rect.x, uvs[i].y * rect.height + rect.y);
新しいUVを割り当て
*mesh.sharedMesh.SetUVs(0, uvs);

*Print(  chara);
Normal
*static void Print(  Status s){Console.WriteLine(  "{0}  {1}", Convert.ToString(   (int)s, 2).PadLeft(4,'0'), s);}
状態を確認するメソッド

*driver.Navigate().GoToUrl("http:
webya.in");

*return Gcd(b, a);
引数を入替えて自分を呼び出す
*private static bool IsPrime(long number) {long boundary = (long)Math.Floor(Math.Sqrt(number));if (number == 1)return false;if (number == 2)return true;for (long i = 2; i <;= boundary; ++i) {if (number % i == 0)return false;}return true;}
効率は良くないが、これでも十分な速度がでたので、良しとする。

*Assert.That(() =<; { someMethod2(1, 2); }, Throws.ArgumentNullException.With.Message.EqualTo("値を Null にすることはできません。"));
Messageは専用のプロパティが用意されている
積結合
*Assert.That(5, Is.GreaterThan(-10).And.LessThan(10));
和結合
*Assert.That(5, Is.EqualTo(3).Or.EqualTo(5));
否定
*Assert.That(5, Is.Not.EqualTo(0));

*Console.WriteLine("pass: {0}", pass);
userName: username

*.FirstOrDefault()
最初の一回だけでそのあとは捨てる（というか破棄される）

ドラッグしたファイルの拡張子が ".txt" ならコピー可能、そうでなければコピー不可のアイコンにする
*dragEventArgs.Effect =
ドロップしたときの処理
*CountLines();
メッセージボックスで表示する
*MessageBox.Show(builder.ToString());

常に表示する
*return true;
メニューを生成して項目を追加する
*var menu = new ContextMenuStrip();
メニューを返す
*return menu;
メッセージボックスで表示する
*MessageBox.Show(builder.ToString());

*if (dict.TryGetValue("none", out var value))
YES! var

テストの同時実行で利用するスレッド数の最大値
*[assembly: CollectionBehavior(MaxParallelThreads = n)]
このアセンブリ内のテストを並列で処理する
デフォルト : false
*[assembly: CollectionBehavior(DisableTestParallelization = true)]

テスト前の処理
*}
テスト後の処理
*}
Context の初期化処理
*}
Context の終了処理
*}
テスト用 Context のシングルトンがここの引数で渡される。
*this.fixture = fixture;
テストをいつも通り書く
*}

30m+2, 30m+3, 30m+4, 30m+5, 30m+6、30m+8、30m+9、30m+12... は割る必要はない。
*var primeCandidte = p + i;
30m+2, 30m+3, 30m+4, 30m+5, 30m+6、30m+8、30m+9、30m+12... は割る必要はない。
*var primeCandidte = p + i;

スリープ直前
*break;
復帰直後
*break;
バッテリーや電源に関する通知があった
*break;

AppDbContextはDbContextを継承して作ったクラスで、
Code Firstの形式で定義したクラス
*services.AddDbContext<;AppDbContext>;(option =>; options.
AppDbContextはDbContextを継承して作ったクラスで、
Code Firstの形式で定義したクラス
*services.AddDbContext<;AppDbContext>;(option =>; options.

*using System.Drawing;
for PointF

*Encoding.GetEncoding("Shift-JIS"));
文字コードを設定してCSVファイルの読み込み

*new PointF(600, 6),
X,Y

日本時間のタイムゾーン情報
*var jstTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById("Tokyo Standard Time");
米国東海岸時間のタイムゾーン情報
*var etTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time");
DateTimeOffsetでの変換 - 1（日本時間から夏時間な東海岸時間に）
2016年8月29日 15時30分11秒 (UTC+9) = いわゆる日本時間の2016年8月29日 15時30分11秒
*var jstDateTimeOffsetSample1 = new DateTimeOffset(2016, 8, 29, 15, 30, 11, jstTimeZoneInfo.BaseUtcOffset);
東海岸時間に変換
jstDateTimeOffset1に入っている日時は、東海岸時間では夏時間にあたり13時間差なので
2016年8月29日 2時30分11秒 (UTC-4)が返る

夏時間だろうが冬時間だろうが、TimeZoneInfo.ConvertTime()がよきに計らってくれる
*var etDateTimeOffsetSample1 = TimeZoneInfo.ConvertTime(jstDateTimeOffsetSample1, etTimeZoneInfo);
*Console.WriteLine($"jstDateTimeOffsetSample1.Equals(etDateTimeOffsetSample1) = {jstDateTimeOffsetSample1.Equals(etDateTimeOffsetSample1)}");
=&gt; 日本時間の8/29/2016 3:30:11 PM +09:00を東海岸時間に変換すると8/29/2016 2:30:11 AM -04:00です
*Console.WriteLine($"jstDateTimeOffsetSample1.Equals(etDateTimeOffsetSample1) = {jstDateTimeOffsetSample1.Equals(etDateTimeOffsetSample1)}");
DateTimeOffsetはある一意の地点を指しているので、変換したとしてもイコールである
DateTimeOffsetでの変換 - 2（日本時間から冬時間な東海岸時間に）
2016年1月29日 15時30分11秒 (UTC+9) = いわゆる日本時間の2016年1月29日 15時30分11秒
*var jstDateTimeOffsetSample2 = new DateTimeOffset(2016, 1, 29, 15, 30, 11, jstTimeZoneInfo.BaseUtcOffset);
東海岸時間に変換
jstDateTimeOffset2に入っている日時は、東海岸時間では冬時間で14時間差なので
2016年1月29日 1時30分11秒 (UTC-5)が返る

夏時間だろうが冬時間だろうが、TimeZoneInfo.ConvertTime()がよきに計らってくれる
*var etDateTimeOffset2 = TimeZoneInfo.ConvertTime(jstDateTimeOffsetSample2, etTimeZoneInfo);
=&gt; 日本時間の1/29/2016 3:30:11 PM +09:00を東海岸時間に変換すると1/29/2016 1:30:11 AM -05:00です
*Console.WriteLine("");
DateTimeのよくある残念なパターン1 - 指定できない時刻

『2016年3月13日 15時59分59秒』と『2015年11月1日 16時00分00秒』を日本時間として扱い、それぞれ東海岸時間にしようとする。
すると、それぞれ『2016年3月13日 1時59分59秒』と『2016年3月13日 3時00分00秒』に変換される。
なぜなら、東海岸時間で冬時間から夏時間に変わるときには1時59分59秒の次は3時00分00秒がくるので、
前者は『冬時間の1時59分59秒』、後者は『夏時間の3時00分00秒』という変換のされ方になる。

*var jstDateTime1 = new DateTime(2016, 3, 13, 15, 59, 59, DateTimeKind.Unspecified);
*Console.WriteLine($"日本時間の{jstDateTime1Plus1Sec}は東海岸時間の{TimeZoneInfo.ConvertTime(jstDateTime1Plus1Sec, jstTimeZoneInfo, etTimeZoneInfo)}です");
=&gt; 日本時間の3/13/2016 3:59:59 PMは東海岸時間の3/13/2016 1:59:59 AMです
=&gt; 日本時間の3/13/2016 4:00:00 PMは東海岸時間の3/13/2016 3:00:00 AMです
*Console.WriteLine("↑↑↑おかしい↑↑↑");
DateTimeOffsetなら、時刻を正しく扱える
*var jstDateTimeOffset1 = new DateTimeOffset(2016, 3, 13, 15, 59, 59, jstTimeZoneInfo.BaseUtcOffset);
*Console.WriteLine($"日本時間の{jstDateTimeOffset1Plus1Sec}は東海岸時間の{TimeZoneInfo.ConvertTime(jstDateTimeOffset1Plus1Sec, etTimeZoneInfo)}です");
=&gt; 日本時間の3/13/2016 3:59:59 PM +09:00は東海岸時間の3/13/2016 1:59:59 AM -05:00です
=&gt; 日本時間の3/13/2016 4:00:00 PM +09:00は東海岸時間の3/13/2016 3:00:00 AM -04:00です
*Console.WriteLine("↑↑↑DateTimeOffsetなら、オフセット部分が-5時間から-4時間に変化しているので問題無い↑↑↑");
DateTimeのよくある残念なパターン2 - ダブる時刻

『2015年11月1日 14時59分59秒』と『2015年11月1日 15時00分00秒』を日本時間として扱い、それぞれ東海岸時間にしようとする。
すると、それぞれ『2015年11月1日 1時59分59秒』と『2015年11月1日 1時00分00秒』に変換される。
なぜなら、東海岸時間で夏時間から冬時間に変わるときには1時59分59秒の次にもう1回1時00分00秒がくるので、
前者は『夏時間の1時59分59秒』、後者は『冬時間の1時00分00秒』という変換のされ方になる。

*var jstDateTime2 = new DateTime(2015, 11, 1, 14, 59, 59, DateTimeKind.Unspecified);
*Console.WriteLine($"日本時間の{jstDateTime2Plus1Sec}は東海岸時間の{TimeZoneInfo.ConvertTime(jstDateTime2Plus1Sec, jstTimeZoneInfo, etTimeZoneInfo)}です");
=&gt; 日本時間の11/1/2015 2:59:59 PMは東海岸時間の11/1/2015 1:59:59 AMです
=&gt; 日本時間の11/1/2015 3:00:00 PMは東海岸時間の11/1/2015 1:00:00 AMです
*Console.WriteLine("↑↑↑おかしい↑↑↑");
DateTimeOffsetなら、時刻を正しく扱える
*var jstDateTimeOffset2 = new DateTimeOffset(2015, 11, 1, 14, 59, 59, jstTimeZoneInfo.BaseUtcOffset);
*Console.WriteLine($"日本時間の{jstDateTimeOffset2Plus1Sec}は東海岸時間の{TimeZoneInfo.ConvertTime(jstDateTimeOffset2Plus1Sec, etTimeZoneInfo)}です");
=&gt; 日本時間の11/1/2015 2:59:59 PM +09:00は東海岸時間の11/1/2015 1:59:59 AM -04:00です
=&gt; 日本時間の11/1/2015 3:00:00 PM +09:00は東海岸時間の11/1/2015 1:00:00 AM -05:00です
*Console.WriteLine("↑↑↑DateTimeOffsetなら、オフセット部分が-4時間から-5時間に変化しているので問題無い↑↑↑");
DateTimeのよくある残念なパターン3 - 変換しようとして例外が発生する時刻（パターン1の裏返し）

『2016年3月13日 2時30分11秒』を東海岸時間として扱い、それを日本時間にしようとすると、ArgumentExceptionが発生する。
なぜなら、2016年3月13日は冬時間から夏時間に戻る日で、1時59分59秒の次は3時00分00秒なので、
東海岸時間には『2016年3月13日 2時30分11秒』は存在しないから。

*try
DateTimeのよくある残念なパターン4 - 指定できない時刻（パターン2の裏返し）

『2015年11月1日 0時59分59秒』と『2015年11月1日 1時00分00秒』を東海岸時間として扱い、それぞれ日本時間にしようとする。
すると、それぞれ『2015年11月1日 13時59分59秒』と『2015年11月1日 15時00分00秒』に変換される。
なぜなら、夏時間から冬時間に変わるときは1時59分59秒の次にもう1回1時0分0秒がくるので
UTCからのオフセット値がないと東海岸時間午前1時台は曖昧にしか表現できないため。

*Console.WriteLine($"{TimeZoneInfo.ConvertTime(new DateTime(2015, 11, 1, 0, 59, 59), etTimeZoneInfo, jstTimeZoneInfo)}");

Dataは変数データ、Gradは勾配データを格納する
*public R[] Data, Grad;
Shapeはデータの形を保存している
*public List<;int>; Shape;
UseCountは計算グラフで使用された回数を保存することで、勾配の計算漏れを防ぐ
*public int UseCount = 0;
Backward時に呼び出す。IFunctionはRein.Functionsのinterface
*public IFunction BackFunction;
*{System.Random random = new System.Random();this.Shape = shape.ToList();this.Size = shape.Aggregate((now, next) =>; now * next);// 乱数で初期化this.Data = Enumerable.Range(0, this.Size).Select(_ =>; (R)random.NextDouble()).ToArray();this.Grad = new R[this.Size];}
データの形で初期化
乱数で初期化
*this.Data = Enumerable.Range(0, this.Size).Select(_ =>; (R)random.NextDouble()).ToArray();
*{this.Shape = new List<;int>;(1){ data.Length };this.Size = data.Length;this.Data = data;this.Grad = new R[this.Size];}
データを直接入力して初期化
*{this.Shape = shape.ToList();this.Size = shape.Aggregate((now, next) =>; now * next);// データ自体のサイズとshapeから得られるサイズが異なる時にエラーを投げる。if(data.Length != this.Size) throw new InvalidSizeException();this.Data = data;this.Grad = new R[this.Size];}
データとshapeで初期化
*if(data.Length != this.Size) throw new InvalidSizeException();*this.Data = data;
データ自体のサイズとshapeから得られるサイズが異なる時にエラーを投げる。
*public Tensor(R[] data, List<;int>; shape){this.Shape = shape;this.Size = shape.Aggregate((now, next) =>; now * next);if(data.Length != this.Size) throw new InvalidSizeException();this.Data = data;this.Grad = new R[this.Size];}
Shapeがリスト型で与えられた時
*{// BackFunctionが存在しない時は終了if(this.BackFunction == null)return;this.UseCount--;// 他の関数に対しても出力している場合にはまだ勾配を計算しないif(this.UseCount != 0)return;this.BackFunction.Backward();}
...
*if(this.BackFunction == null)return;*this.UseCount--;
BackFunctionが存在しない時は終了
*if(this.UseCount != 0)return;*this.BackFunction.Backward();
他の関数に対しても出力している場合にはまだ勾配を計算しない

*string url = "https:
api.projectoxford.aiemotionv1.0recognize";
リクエストヘッダー
*Dictionary<;string, string>; header = new Dictionary<;string, string>;();
リクエストする
*WWW www = new WWW(url, bytes, header);
非同期なのでレスポンスを待つ
*yield return www;
*if (www.error == null)*{
↑ Emotion  API使用部分
JSON の中身をパース
*var emotionJsonArray = JArray.Parse(www.text);
今回は顔が一人分だけ写っていると仮定し0番目を取り出す
*JObject scores = (JObject) emotionJsonArray[0]["scores"];
取れたスコアに基づき最も強かった感情をstringで返す
*string emotion = getEmotion(scores);
キャラクターにその感情にあった表情をさせる
*Girl g = girl.GetComponent<;Girl>;();

*checkBox.FontSiZe = 50;
これが反映されない
*{public string Name {get; set;}}
***データクラス***
***UserControl内XAML***
*<;DataGrid Name="MainDataGrid">;
***UserControl内コードビハインド***
外部からDataGridにバインドするデータを受け取る用
*public static readonly DependencyProperty ListDataProperty = DependencyProperty.Register(
ロードイベントなりなんなり好きなところで
*mainDataGrid.ItemsSource = this.ListData;

インスタンス作ったり
*Character character = (Character)Activator.CreateInstance(type);
メソッド呼んだり
*MethodInfo method = type.GetMethod("Move");
*// Object[] args = { "A", "B", "C" };
引数渡したい場合

*namespace System.Diagnostics {public static class Debug {[ConditionalAttribute("DEBUG")]public static void Assert(bool condition);}}
Error !!

*base.Start();
スーパークラス参照

requestInfo.Bodyにバイナリデータが入っている
*}

Functionsで行う処理などを書く
適宜telemetryClient.TrackTrace()やtelemetryClient.TrackMetric()などを呼び出してもよい。
*}

*writer.IndentChar = ' ';
indent character
日本語化けないようにする
*Console.OutputEncoding = new UTF8Encoding();
サンプルXML構築 (整形を確認するために意図的に崩してある)
*XmlDocument xmlDocument = new XmlDocument();
インデント付き整形表示
*Console.WriteLine("----------------------------------------");

*using System.Text.RegularExpressions;
for Regex

*var ber = BerConverter.Encode("{tststs}",
https:tools.ietf.org/html/rfc3062
パスワードを変更するユーザーでバインドする
*ldapConnection.Bind();
*ldapConnection.SendRequest(modifyPasswdRequest);*// 応答が「成功」か確認
パスワード変更要求を送信
*if (modifyPasswdResponse.ResultCode != ResultCode.Success)*throw new Exception("Could not change password. (" + modifyPasswdResponse.ResultCode + ")");
応答が「成功」か確認

次の２行を追加する
*WndProcHooker.HookWndProc(listView1, new WndProcHooker.WndProcCallback(WM_Hook_Handler), WM_HSCROLL);

*string diffs = diffs.Patch;
追加行、削除行などの差分情報
オプション変数
*LibGit2Sharp.CloneOptions options = new LibGit2Sharp.CloneOptions();
オプション：チェックアウトするブランチ名。簡略名(FriendlyName)でもOK
*options.BranchName = branch;
オプション：進行状況のコールバック指定
*options.OnCheckoutProgress = (p,n,t)=>;checkout_progress_handler(p,n,t);
オプション：開始時のコールバックを指定
*options.RepositoryOperationStarting = (c)=>;operation_start_handler(c);
入出力のパスとオプションを指定してクローンを実行します。
string remote_path：クローンするリモートリポジトリのパス
string local_path：クローンを作成するパス
CloneOptions options
*LibGit2Sharp.Repository.Clone( remote_path, local_path, options );

*private void listView1_ItemCheck(object sender, ItemCheckEventArgs e) {Point pnt = listView1.PointToClient(Cursor.Position);ListViewItem item = listView1.Items[e.Index];ListViewItem.ListViewSubItem stem = item.GetSubItemAt(pnt.X, pnt.Y);if(stem != null &amp;&amp; stem.Bounds.Contains(pnt))if(item.SubItems.IndexOf(stem) == 1)e.NewValue = e.CurrentValue;}
カラム2の直接編集ちっくモードに入るときに、ItemのCheckが入らないようにする

*Console.WriteLine(element);
Debug.Log() for Unity

*while (Fade(-0.2f*0.1f))*{
フェードアウト

まずはスクレイピング対象のページを取得してくる。
var pageResult = browser.NavigateToPage(new Uri("http:example.com/page.html"));
ページに対してCSSセレクタを適用し、該当するDOMノードの最初のものを取り出す。
→ 「hoge 1」が返る
*pageResult.Html.CssSelect("ul li").First().InnerText;
ページに対してCSSセレクタを適用してDOMノード群を取り出し、ノード群の中からinnerTextに「fuga」が入っている最初のノードをLINQで絞り込む
→ 「fuga 2」が返る
*pageResult.Html.CssSelect("ul li").First(elem =>; elem.InnerText.Contains("fuga")).InnerText;
&lt;td&gt;タグ内に「location」という文字が入っているノードの隣のノードをXPathで絞り込む
→ 「Tokyo」が返る
pageResult.Html.SelectNodes("td[contains(text(),'location')]/following-sibling::td").First().InnerText;
*}

*ball_rb.AddForce(sliderDirection * changePower);
ボールに力を加える

カメラ視覚の範囲
*float viewMin = 20.0f;
直前の2点間の距離.
*private float backDist = 0.0f;
初期値
*float view = 60.0f;
*void Update () {// マルチタッチかどうか確認if (Input.touchCount >;= 2){// タッチしている２点を取得Touch t1 = Input.GetTouch (0);Touch t2 = Input.GetTouch (1);//2点タッチ開始時の距離を記憶if (t2.phase == TouchPhase.Began){backDist = Vector2.Distance (t1.position, t2.position);}else if (t1.phase == TouchPhase.Moved &amp;&amp; t2.phase == TouchPhase.Moved){// タッチ位置の移動後、長さを再測し、前回の距離からの相対値を取る。float newDist = Vector2.Distance (t1.position, t2.position);view = view + (backDist - newDist) / 100.0f;v = v + (newDist - backDist) / 1000.0f;// 限界値をオーバーした際の処理if(v >; vMax){v = vMax;}else if(v <; vMin){v = vMin;}// 相対値が変更した場合、カメラに相対値を反映させるif(v != 0){map.transform.localScale = new Vector3(v, v, 1.0f);}}}}
Update is called once per frame
*if (Input.touchCount >;= 2)*{
マルチタッチかどうか確認
タッチしている２点を取得
*Touch t1 = Input.GetTouch (0);
*if (t2.phase == TouchPhase.Began)*{
2点タッチ開始時の距離を記憶
タッチ位置の移動後、長さを再測し、前回の距離からの相対値を取る。
*float newDist = Vector2.Distance (t1.position, t2.position);
*if(v >; vMax)*{
限界値をオーバーした際の処理
*if(v != 0)*{
相対値が変更した場合、カメラに相対値を反映させる

*Console.WriteLine($"Name={p.Name}, Age={p.Age}");
Name=Mike, Age=43

出力結果
aaabbbccc
*}
出力結果
aaa
*}
出力結果
aaabbb
*}
出力結果
aaabbbccc
*}

*private IEnumerator Sample(){int i = 0;Debug.Log("yield:"+ i + ":" + 1);yield return null;i++;Debug.Log("yield:"+ i + ":" + 2);yield return null;i++;Debug.Log("yield:"+ i + ":" + 3);yield return null;i++;Debug.Log("yield:"+ i + ":" + 4);yield return null;i++;Debug.Log("yield:"+ i + ":" + 5);yield return null;i++;}
アップデートの中で呼ぶと危険

.Message("こんにちは! 野菜の○ブウェイです。ご注文をどうぞ!")
.Build();
*.Message("こんにちは! 野菜の○ブウェイです。ご注文を承ります！")

*Digit(12345);
=&gt; 5

前略．．．
wwwrootに対して静的コンテンツサービスを登録
*app.UseStaticFiles();
*{//登録するフォルダーを指定、絶対パスを設定する必要があるFileProvider = new PhysicalFileProvider("C:\\StaticContent"),});
wwwroot以外に静的コンテンツサービスを登録
登録するフォルダーを指定、絶対パスを設定する必要がある
*FileProvider = new PhysicalFileProvider("C:\\StaticContent"),
後略．．．
*}
前略．．．
パラメータなしの場合は「wwwroot」フォルダー及びサブフォルダの全ファイルを静的コンテンツとして提供する
デフォルトでは認証と認可ミドルウェアの前に登録されているので、「wwwroot」の静的コンテンツをアクセスする際は認証と認可は不要
*app.UseStaticFiles();
後略．．．
*app.UseAuthentication();
後略．．．
*}
前略．．．
パラメータなしの場合は「wwwroot」フォルダー及びサブフォルダの全ファイルを静的コンテンツとして提供する
*app.UseStaticFiles();
「wwwroot」以外に「StaticContent」フォルダーも静的ファイルを提供する
app.UseStaticFiles();の呼び出しがないと「wwwroot」へのアクセスができなくなる
*app.UseStaticFiles(new StaticFileOptions
後略．．．
*app.UseAuthentication();
後略．．．
*}
前略．．．
*app.UseDefaultFiles();
「wwwroot」以外に「StaticContent」フォルダーも静的ファイルを提供する
app.UseStaticFiles();の呼び出しがないと「wwwroot」へのアクセスができなくなる
*app.UseStaticFiles(new StaticFileOptions
後略．．．
*app.UseAuthentication();
後略．．．
*}
前略．．．
既定ドキュメントの設定
*DefaultFilesOptions defaultFilesOptions = new DefaultFilesOptions();
デフォルトのファイル名設定をクリア
*defaultFilesOptions.DefaultFileNames.Clear();
既定ドキュメント名を指定
*defaultFilesOptions.DefaultFileNames.Add("myIndex.html");
「wwwroot」以外に「StaticContent」フォルダーも静的ファイルを提供する
app.UseStaticFiles();の呼び出しがないと「wwwroot」へのアクセスができなくなる
*app.UseStaticFiles(new StaticFileOptions
後略．．．
*app.UseAuthentication();
後略．．．
*}
前略．．．
EnableDirectoryBrowsing = trueの時、下記を呼び出す必要がある
*services.AddDirectoryBrowser();
後略．．．
*}
前略．．．
*app.UseStaticFiles();
「wwwroot」以外に「StaticContent」フォルダーも静的ファイルを提供する
app.UseStaticFiles();の呼び出しがないと「wwwroot」へのアクセスができなくなる
*app.UseStaticFiles(new StaticFileOptions
*{//ディレクトリ参照の対象フォルダーFileProvider = new PhysicalFileProvider("C:\\StaticContent"),//ディレクトリ参照するためのURL相対パス//https://<;hostname>;/DirectoryBrowserRequestPath = "/DirectoryBrowser"});
ディレクトリ参照を起用する
ディレクトリ参照の対象フォルダー
*FileProvider = new PhysicalFileProvider("C:\\StaticContent"),
ディレクトリ参照するためのURL相対パス
https:&lt;hostname&gt;/DirectoryBrowser
*RequestPath = "/DirectoryBrowser"
略．．．
*app.UseAuthentication();
後略．．．
*}
前略．．．
EnableDirectoryBrowsing = trueの時、下記を呼び出す必要がある
*services.AddDirectoryBrowser();
後略．．．
*}
前略．．．
*app.UseStaticFiles();
*{//静的ファイルを提供する対象フォルダーFileProvider = new PhysicalFileProvider("C:\\StaticContent"),//デフォルトがtrue:デフォルトファイルを起用EnableDefaultFiles = true,//デフォルトがfalse:ディレクトリブラウザ禁止EnableDirectoryBrowsing = true//静的コンテンツをアクセスするための相対パスRequestPath = "/StaticFiles",});
「wwwroot」以外に「StaticContent」フォルダーも静的ファイルを提供する
静的ファイルを提供する対象フォルダー
*FileProvider = new PhysicalFileProvider("C:\\StaticContent"),
デフォルトがtrue:デフォルトファイルを起用
*EnableDefaultFiles = true,
デフォルトがfalse:ディレクトリブラウザ禁止
*EnableDirectoryBrowsing = true
静的コンテンツをアクセスするための相対パス
*RequestPath = "/StaticFiles",
略．．．
*app.UseAuthentication();
後略．．．
*}
ここで既定の「wwwroot」を指定したフォルダーに変更できる
*webBuilder.UseStartup<;Startup>;().UseWebRoot("C:\\NewWebRoot");

*page = GetPage("http:
www.jikokuhyo.co.jpsearchdetailline_iskanto_takasaki");
*{private bool state;private string comment;public parser1(){state = true;}public bool status{get{return this.state;}set{this.state = value;}}public string m_comment{set{this.comment = value;}get{return this.comment;}}//find tagpublic override void find_tag(string tag){}//find atrributepublic override void find_attribute(string tag, Dictionary<;string, string>; attr_list){}//find datapublic override void find_data(string tag, Dictionary<;string, string>; attr_list, string data){if (tag == "div"){foreach (KeyValuePair<;string, string>; sPair in attr_list){if (sPair.Key == "class" &amp;&amp; sPair.Value == "corner_block_row_detail_d"){if ( (data != "\r\n現在、平常通り運転しています。") &amp;&amp; (data !="\r\n情報提供時間は4：00～翌2：00となっています。") ){//なにかするm_comment = data;status = false;}else{}}}}}}
～～～～～～～～～～
*{}
find tag
*{}
find atrribute
*{if (tag == "div"){foreach (KeyValuePair<;string, string>; sPair in attr_list){if (sPair.Key == "class" &amp;&amp; sPair.Value == "corner_block_row_detail_d"){if ( (data != "\r\n現在、平常通り運転しています。") &amp;&amp; (data !="\r\n情報提供時間は4：00～翌2：00となっています。") ){//なにかするm_comment = data;status = false;}else{}}}}}
find data
なにかする
*m_comment = data;

*for (int i =0; i <; 1000000; i++ ){test_string.text = "集計" + i;}
スタート時間
終了時間
*float _endTime = Time.realtimeSinceStartup;
*for (int i =0; i <; 1000000; i++ ){test_string.GetComponent<;Text>;().text = "集計" + i;}
スタート時間
終了時間
*float _endTime = Time.realtimeSinceStartup;
*for (int i =0; i <; 1000000; i++ ){GameObject test_string = Parent.transform.FindChild("Text").gameObject;test_string.GetComponent<;Text>;().text = "集計" + i;}
スタート時間
終了時間
*float _endTime = Time.realtimeSinceStartup;

*HttpWebRequest req = (HttpWebRequest)WebRequest.Create("http:
example.comapihoge");

*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

InvalidCastExceptionが発生する
*var fuga = hoge.Cast<;double>;();
結果は空（すなわちキャスト出来ていない）
*var piyo = hoge.OfType<;double>;();
要素に対する等価式（当然例外になる）
*var element = (double)((object)1);

*AudioBuffer.Instance.Enqueue(_audioRecord);
最初に空読みさせないと、リスナーのイベントが発生しないらしい
または
*public virtual void SetRecordPositionUpdateListener(IOnRecordPositionUpdateListener listener, Handler handler);
１つめ
*public event EventHandler<;MarkerReachedEventArgs>; MarkerReached;
*public event EventHandler<;PeriodicNotificationEventArgs>; PeriodicNotification;*,,,
２つめ

*viewModel.Model2.Model1 = model1_2;
10, 20, 30...
↑SelectMany(m1 =&gt; m1.ToReactivePropertyAsSynchronized(x =&gt; x.Number))と同じ結果
*,,,

ビルド対象シーンのパスの配列
*string[] scenes = EditorBuildSettings
先のビルド対象シーンのパスの配列を引数にとるBuildPipeline.BuildPlayerメソッド
*string errorMessage = BuildPipeline.BuildPlayer(
ビルド対象シーンの配列
*EditorBuildSettingsScene[] scenes = EditorBuildSettings
先のビルド対象シーンの配列を引数にとるBuildPipeline.BuildPlayerメソッド
*string errorMessage = BuildPipeline.BuildPlayer(

*public string Affiliation;
作者所属
中身は省略
*}
クラスの Author
*GetAuthors(t);
メソッドの Author
*GetAuthors(info);

*{RoastBeef, BLT, SubwayClub, RoastChicken,TeriyakiChicken, TurkeyBreast, Ham, Tuna, VeggieDelite}
質問項目と回答

*WriteReadCommand[22] = (byte)sum;
CheckSum（これまでの数値の和の下位１バイト）
WriteReadCommand 送信
*int offset_Write = 0;
WriteReadCommand 受信
*byte[] inBuffer = new byte[23];

*var obj = new DerivedClass();
子クラスをインスタンス化

*dbContext.SaveChanges();
エラーは出ないがDBに反映されない・・・

*await auth.GetUserCredential( "http:
localhost:8080GoogleFitsteps" );
ここが認証後のリダイレクト先ルート
*}

[Key] これだけだとエラーが出る
*[Key, DatabaseGenerated(DatabaseGeneratedOption.None)]

*result.Add("None");
常に「指定しない」の意味で `None` を追加
該当コンポーネントの名前を取得（階層構造のいわゆるディレクトリ的な扱いで使う）
*string componentName = component.GetType().Name;
該当コンポーネントから「public」でかつ「引数 0」のメソッドを抜き出す
*string[] methodNames = component.GetType().GetMethods(BindingFlags.Instance | BindingFlags.Public)
string[] に変換して返す
*return (string[])result.ToArray(typeof(string));
*{var rect = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);// 折りたたまれているかの状態を得るm_Unfoled = EditorGUI.Foldout(rect, m_Unfoled, label);// 折りたたまれている場合はGUIの更新をせずに終了if (!m_Unfoled) {return;}var backupIndent = EditorGUI.indentLevel;EditorGUI.indentLevel = 0;label = EditorGUI.BeginProperty(position, label, property);// 表示に使うメソッドリストへの参照string[] methods;// レイアウトのスタート位置float y = position.y;{// `Target` プロパティを取得SerializedProperty targetProperty = property.FindPropertyRelative("Target");// 指定したプロパティから、実際に設定されている値を取り出しGameObject target = targetProperty.objectReferenceValue as GameObject;// 設定されているターゲットを対象に、コンポーネントの条件に合うメソッドリストを収集methods = CollectMethods(target);// Yの位置を更新y += EditorGUIUtility.singleLineHeight + 5f; ;// インデントレベルを修正EditorGUI.indentLevel++;// ターゲットのラベルをレンダリングvar targetRect = new Rect(position.x, y, position.width, EditorGUIUtility.singleLineHeight);EditorGUI.PropertyField(targetRect, targetProperty, new GUIContent("Target"));}{if (methods.Length >; 0) {// `HandleMethod` プロパティから値を取得SerializedProperty handleMethodProperty = property.FindPropertyRelative("HandleMethod");y += EditorGUIUtility.singleLineHeight + 5f; ;// メソッドのラベルをレンダリングvar methodRect = new Rect(position.x, y, position.width, EditorGUIUtility.singleLineHeight);EditorGUI.LabelField(methodRect, new GUIContent("Method"));if (!methods.Contains(handleMethodProperty.stringValue)) {handleMethodProperty.stringValue = "";}string selected = handleMethodProperty.stringValue == "" ? "None" : handleMethodProperty.stringValue;int index = methods.Select((Name, Index) =>; new { Name, Index }).First(x =>; x.Name == selected).Index;var padding = 105f;methodRect.x += padding;methodRect.width -= padding;index = EditorGUI.Popup(methodRect, index, methods);handleMethodProperty.stringValue = methods[index];}}EditorGUI.EndProperty();EditorGUI.indentLevel = backupIndent;}
GUIのレンダリング
折りたたまれているかの状態を得る
*m_Unfoled = EditorGUI.Foldout(rect, m_Unfoled, label);
*if (!m_Unfoled) {*return;
折りたたまれている場合はGUIの更新をせずに終了
表示に使うメソッドリストへの参照
*string[] methods;
*{// `Target` プロパティを取得SerializedProperty targetProperty = property.FindPropertyRelative("Target");// 指定したプロパティから、実際に設定されている値を取り出しGameObject target = targetProperty.objectReferenceValue as GameObject;// 設定されているターゲットを対象に、コンポーネントの条件に合うメソッドリストを収集methods = CollectMethods(target);// Yの位置を更新y += EditorGUIUtility.singleLineHeight + 5f; ;// インデントレベルを修正EditorGUI.indentLevel++;// ターゲットのラベルをレンダリングvar targetRect = new Rect(position.x, y, position.width, EditorGUIUtility.singleLineHeight);EditorGUI.PropertyField(targetRect, targetProperty, new GUIContent("Target"));}
レイアウトのスタート位置
`Target` プロパティを取得
*SerializedProperty targetProperty = property.FindPropertyRelative("Target");
指定したプロパティから、実際に設定されている値を取り出し
*GameObject target = targetProperty.objectReferenceValue as GameObject;
設定されているターゲットを対象に、コンポーネントの条件に合うメソッドリストを収集
*methods = CollectMethods(target);
Yの位置を更新
*y += EditorGUIUtility.singleLineHeight + 5f; ;
インデントレベルを修正
*EditorGUI.indentLevel++;
ターゲットのラベルをレンダリング
*var targetRect = new Rect(position.x, y, position.width, EditorGUIUtility.singleLineHeight);
`HandleMethod` プロパティから値を取得
*SerializedProperty handleMethodProperty = property.FindPropertyRelative("HandleMethod");
メソッドのラベルをレンダリング
*var methodRect = new Rect(position.x, y, position.width, EditorGUIUtility.singleLineHeight);
*{// 折りたたまれている場合は1行分だけの高さif (!m_Unfoled) {return EditorGUIUtility.singleLineHeight;}// それ以外の場合は3行（プロパティの数）＋マージンvar height = EditorGUIUtility.singleLineHeight * 3 + 5f + 5f;return height;}
プロパティのインスペクタ上で占める範囲の高さ
*if (!m_Unfoled) {*return EditorGUIUtility.singleLineHeight;
折りたたまれている場合は1行分だけの高さ
それ以外の場合は3行（プロパティの数）＋マージン
*var height = EditorGUIUtility.singleLineHeight * 3 + 5f + 5f;
折りたたみ状態かどうかを保持するプロパティ
*bool m_Unfoled = false;
中略
該当プロパティが閉じている状態かを取得
*m_Unfoled = EditorGUI.Foldout(rect, m_Unfoled, label);
以下、閉じていた場合と開いている場合で処理を分岐
GetPropertyHeightメソッド内で、展開の状態に応じて高さの値を変えることで、
双方の状態を適切な高さで表現することができる
*public override float GetPropertyHeight(SerializedProperty property, GUIContent label)

*param ["bllimit"] = "16";
取得するリンク数の上限
WikipediaからJSONを取得
WWW www = this.GET("http:ja.wikipedia.org/w/api.php?", param);
*yield return www;
JSONデータ -&gt; Wikipediaオブジェクト
*var wikipedia = JsonUtility.FromJson (www.text, typeof(Wikipedia.RootObject)) as Wikipedia.RootObject;
*if (www.error == null) {*Debug.Log ("WWW OK");
check for errors

XDocumentでXPath用の拡張メソッドを使うのに必要
*using System.Xml.XPath;
XML文字列からXDocumentオブジェクトを生成
*var doc = XDocument.Load(new StringReader(xmlString));
名前空間のための処理
string nameSpace = "http:example.com";
*var nsmgr = new XmlNamespaceManager(new NameTable());
名前空間を指定して検索
*var nodeD = doc.XPathSelectElement("ns:nodeA/ns:nodeB/ns:nodeC/ns:nodeD", nsmgr);
XML文字列からXDocumentオブジェクトを生成
*var doc = XDocument.Load(new StringReader(xmlString));
*foreach(var e in doc.Descendants())　e.Name = e.Name.LocalName;*//上記処理により、検索時に名前空間の指定が不要
各ノードのNameを名前空間なしの要素名にする
上記処理により、検索時に名前空間の指定が不要
*var nodeD = doc.XPathSelectElement("nodeA/nodeB/nodeC/nodeD");

*ClockSkew = TimeSpan.Zero
←これがポイント

A1:B10の矩形範囲にはすべて値が詰まっている｡
*var range = sheet.Cells["A1:B10"];
こいつはTrueになる｡
*Console.WriteLine(ReferenceEquals(foo, bar));
*Console.WriteLine($"foo:{foo.Current.Address}");
だもんで､foo及びbarをMoveNextした結果が､それぞれにに反映される｡
*Console.WriteLine($"foo:{foo.Current.Address}");
foo:B2
*Console.WriteLine($"bar:{bar.Current.Address}");
bar:B2
A1:B10の矩形範囲にはすべて値が詰まっている｡
*var rangeA = sheet.Cells["A1:B10"];
Falseになる｡
*Console.WriteLine(ReferenceEquals(rangeA, rangeB));
当然こいつはFalseになる｡
*Console.WriteLine(ReferenceEquals(foo, bar));
*Console.WriteLine($"foo:{foo.Current.Address}");
共々独立しているのでめでたしめでたし
*Console.WriteLine($"foo:{foo.Current.Address}");
foo:B1
*Console.WriteLine($"bar:{bar.Current.Address}");
bar:A1

セーブ後､ロードすると0になる｡
*Console.WriteLine(range.Count());
予想としてA1から､B10の矩形範囲なので20が返ると思いがちだけど
0が返ってくる｡
*Console.WriteLine(range.Count());
この段階では､2が戻ってくる｡
*Console.WriteLine(range.Count());
20が戻ってくる｡
*Console.WriteLine(range.Count());

*.SetSubtitle(new Subtitle { Text = "Source: <;a href=\"http:
WorldClimate.com\"&gt;WorldClimate.com&lt;a&gt;", UseHTML = true })

*//    {//    if (activity.Type == ActivityTypes.Message)://    }
public async Task&lt;HttpResponseMessage&gt; Post([FromBody]Activity activity)
*//    if (activity.Type == ActivityTypes.Message)*:
{

*public static int Lcm(int a, int b) {return a * b / Gcd(a, b);}
最小公倍数
*public static int Gcd(int a, int b) {if (a <; b)// 引数を入替えて自分を呼び出すreturn Gcd(b, a);while (b != 0) {var remainder = a % b;a = b;b = remainder;}return a;}
ユークリッドの互除法
*while (b != 0) {var remainder = a % b;a = b;b = remainder;}
引数を入替えて自分を呼び出す

*Item m_nextState;
次実行のセット
*{var i = new Item();i.state = func;i.p1 = p1;i.p2 = p2;m_queue.Enqueue(i);}
実行登録
*{m_elapsed += Time.deltaTime;if (m_curState == null){if (m_queue.Count != 0){m_nextState = m_queue.Dequeue();}}if (m_nextState != null){m_curState  = m_nextState;m_nextState = null;m_elapsed = 0;}if(m_curState != null){m_curState.state(m_elapsed, m_curState.p1, m_curState.p2);}}
更新処理　上位関数から更新時呼び出しを想定
*{m_curState = null;}
ステートの終了告知用
処理の登録
*m_ss.Command(S_START);
*{if (t == 0){Debug.Log("S_START Initailize");}else if (t >; 1){m_ss.Done();}}
以下、ステート関数

*wRange = String.Format("{0}!A{1}:B{1}", sheetName, rowNumber);
行を追加

*// int index = anyList.Select((Name, Index) =>; new { Name, Index });
さらに短くするとこう書ける
*// int index = anyList.Select((Name, Index) =>; new { Name, Index });
ローカルで宣言した変数を使うとその名前と値がそのまま利用される
*var person = new { Name = "edo", Age = 20 };
int index = anyList.Select((Name, Index) =&gt; new { Name, Index });

このイベントをメインフォームでListenする。
*public event DataEventHandler DataPassEvent;
ここでデータを加工したりする処理をして・・・
空白でない時だけ、イベントを起こしたりも出来る。
*if(!string.IsNullOrWhiteSpace(StringDate))
データベースからデータを取得する処理。
*}
ここでデータベースにレコードをInsertしたりUpdateしたりして・・・
その後、イベント起動。
*DatabaseUpdateCompleted?.Invoke(null, new EventArgs());
データ管理用クラスの、データ変更イベントをListenする。
*DataClass.DataPassEvent += DataClass_DataPassEvent;
サブフォーム内に実装した、データを変更するメソッドを呼び出す。
下記メソッドはどのクラスから呼び出してもいいが、今回は2つしかクラスがないので、このクラスで呼び出す。
*new SubForm().Method();
データ変更前後の値を表示する。
メッセージBOXは4回表示され、表示結果は以下
------------------------------------------
①変更前は で 変更後は あいうえお
②変更前は あいうえお で 変更後は かきくけこ
③変更前は かきくけこ で 変更後は さしすせそ
④変更前は さしすせそ で 変更後は たちつてと
------------------------------------------
*MessageBox.Show($"変更前は { e.OldStringData } で 変更後は { e.NewStringData } ");
*{DataClass.StringValue = "あいうえお";DataClass.StringValue = "かきくけこ";DataClass.StringValue = "さしすせそ";DataClass.StringValue = "たちつてと";}
データ管理用クラスのデータを変更する。
*{public delegate void DataEventHandler(DataChangeEventArgs e);//このイベントをメインフォームとサブフォームでListenする。public static event DataEventHandler DataPassEvent;private static string oldValue;private static string newValue;public static string StringValue{get { return newValue; }set{//データ変更前後の値が違っていれば・・・if (oldValue != value){//元々あった値をoldValueに退避oldValue = newValue;//newValueにセットし・・・newValue = value;//データ変更イベントを起動する。DataPassEvent?.Invoke(new DataChangeEventArgs(oldValue, newValue));};}}}
データ管理用クラス
このイベントをメインフォームとサブフォームでListenする。
*public static event DataEventHandler DataPassEvent;
*if (oldValue != value)*{
データ変更前後の値が違っていれば・・・
元々あった値をoldValueに退避
*oldValue = newValue;
newValueにセットし・・・
*newValue = value;
データ変更イベントを起動する。
*DataPassEvent?.Invoke(new DataChangeEventArgs(oldValue, newValue));
*{public string OldStringData { get; set; }public string NewStringData { get; set; }public DataChangeEventArgs(string oldData, string newData){OldStringData = oldData;NewStringData = newData;}}
変更前後の値を渡す為のEventArgs

AnyClassNameコンポーネントを取得
*anyClassName = target as anyClassName;
*var options = new []{ GUILayout.Width(64), GUILayout.Height(64) };
レイアウト情報付き
`selectedIndex`には選択された新しいindexが格納される
*int selectedIndex = EditorGUILayout.Popup(index, list);
各種Propertyを取得する
*_anyNameProperty = serializedObject.FindProperty("_anyName");
シリアライズされたPropertyを更新しておく
*serializedObject.Update();
*serializedObject.ApplyModifiedProperties();*}
更新された値を適用する

*void Start () {routine = coroutine();StartCoroutine(routine);}
Use this for initialization
*{if (Input.GetKeyDown(KeyCode.X)){StopCoroutine(routine);StartCoroutine(routine);}}
Update is called once per frame

*app.MapSignalR();
← この行を追加

*private Dictionary<;SceneID, string>; m_sceneNameDictionary = new Dictionary<;SceneID, string>; {{SceneID.Game, "Game"},{SceneID.Title, "Title"}};
enumからシーン名を取得するために必要
*public void LoadSceneEX(SceneID sceneID) {SceneManager.LoadScene(m_sceneNameDictionary[sceneID]);)}
これを呼んでシーン遷移を行う
文字列を渡すとそもそも型が違うのでエラー
SceneIDで定義している値しか受け付けない
*SceneManager.LoadScene(SceneID.Title);
BuildSettingsに登録した全てのシーン名文字列が格納された配列が取得できる
*var sceneNames = UnityEditor.EditorBuildSettings.scenes

*iProgress.Report(i * 20);
進捗(%)を報告
*{label1.Text = $"{per}%";}
進捗通知を受けたらラベルに表示

try 文
*}
catch 文 その1
*}
catch 文 その2
*}
finally 文
*}

が表示される｡
*}
ImmutableList&lt;T&gt;はCtorを持ってないので､ファクトリ使って構築する｡
*var immutableList = ImmutableList.Create(0, 1, 2, 3, 4);
*foreach (var i in immutableList)*{
ふつーにforeachで回せる｡
ImmutableList&lt;T&gt;はCtorを持ってないので､ファクトリ使って構築する｡
*var immutableList = ImmutableList.Create(0, 1, 2, 3, 4);
*foreach (var i in immutableList)*{
ふつーにforeachで回せる｡
Addできる
*immutableList.Add(42);
RemoveAtも出来る
*immutableList.RemoveAt(0);
*foreach (var i in immutableList)*{
けれど不変(ナンデ?)
ImmutableList&lt;T&gt;はCtorを持ってないので､ファクトリ使って構築する｡
*var immutableList = ImmutableList.Create(0, 1, 2, 3, 4);
Addできる
*var addAfterList = immutableList.Add(42);
RemoveAtも出来る
*var removeAfterList = immutableList.RemoveAt(0);
元は不変
*Console.WriteLine("immutableList");
Addはされている
*Console.WriteLine("addAfterList");
RemoveAtもされている
*Console.WriteLine("removeAfterList");
ImmutableList&lt;T&gt;はCtorを持ってないので､ファクトリ使って構築する｡
*var immutableList = ImmutableList.Create(0, 1, 2, 3, 4);
当然不変
*Console.WriteLine("immutableList");
変更されている
*Console.WriteLine("after");
こさえる
*var immutalbe = Enumerable.Range(0, 10).ToImmutableList();
Builderをこさえる｡
*var build = immutalbe.ToBuilder();
Builderに対してはMutableな操作が効く｡
*build[0] = 42;
当然操作の結果は変化する｡
*Console.WriteLine("build");
ToImmutableでImmutable化できる｡
*var after = build.ToImmutable();
操作結果は反映される
*Console.WriteLine("after");

ユーザーデータ削除時のアクション、メッセージを記載
*}
メンバー追加、削除といった会話ステータスの変更を把握
Activity.MembersAdded, Activity.MembersRemoved,
Activity.Action で詳細を確認
*}
コンタクトリストの追加、削除
詳細は Activity.From + Activity.Action で確認
*}
会話の入力時のアクション、メッセージを記載
*}
Ping時のアクション、メッセージを記載
*}
文字数をカウント
*int length = (activity.Text ?? string.Empty).Length;
*$"You sent {activity.Text} which was {length} characters"
返答の文章を作成

メニューアイテム:予約一覧
*ctmd = DefCtxmData[CtxmCode.ReserveView];
メニューアイテム:使用予定チューナー
*ctmd = DefCtxmData[CtxmCode.TunerReserveView];

*.OrderBy(info =<; info.tunerID).ToList();
多分大丈夫だけど一応ソートしておく

*public static int Gcd(int a, int b) {if (a <; b)// 引数を入替えて自分を呼び出すreturn Gcd(b, a);while (b != 0) {var remainder = a % b;a = b;b = remainder;}return a;}
ユークリッドの互除法
*while (b != 0) {var remainder = a % b;a = b;b = remainder;}
引数を入替えて自分を呼び出す

*global::X.XClass.Greeting();
X.XClass: Greeting()

*string result = String.Join("", uniq_str);
文字列に再変換

Effect を追加する
*Effects.Add(Effect.Resolve("mycompany.CustomMasterDetailEffect"));

フォルダがなければ作る。
*string pluginsPath = Directory.GetCurrentDirectory() + @"\plugins";
プラグイン読み込み
*using (var catalog = new DirectoryCatalog(pluginsPath, "SummationPlugin.dll"))

*label1.Text = ret.ToString();
UIスレッド

*public partial class PropertyGridPlus : PropertyGrid
ControlからPropertyGridに変更する
*if (currentDepth >;= limitDepth)*{
指定した深さ以上になっていればツリーの展開を中断し、現在の深さをそのまま返す。
サブツリーの展開
*int retDepth = currentDepth;
*if (retDepth <; childDepth)*retDepth = childDepth;
サブツリーの中で最も深い深さを取得する。
インデントのため、タブを現在の深さ分挿入する。
*ret.Append(new string('\t', currentDepth));
子アイテムがあるときの記号。自由に設定してください。
*string expandSign = "";
*ret.Append($"{expandSign}{item.Label.TrimStart('\t')}");
プロパティ名の追加
*ret.Append($"{new string('\t', maxDepth - currentDepth + 1)}");
プロパティ名と値の間のスペースを追加
*ret.AppendLine($"{item.Value}");
値の出力
*if (currentDepth <; limitDepth)*{
サブツリーの展開
*{string text = CreateText(SelectedGridItem, true);Clipboard.SetText(text);}
コンテキストメニューのClickイベントハンドラ

*direction_light_offset = this.transform.rotation;*}
太陽光の傾きオフセットをシーンの設定から保持
端末の傾きを保持
*gyro_to_light = Input.gyro.attitude;
yz軸の値を入れ替え
*float yz_change;
*this.transform.rotation = gyro_to_light * direction_light_offset;*}
ライトの向きを端末の傾き＋元の設定のオフセットで変更

*public virtual ActionResult GetFiles(string dir, bool onlyFolders, bool onlyFiles, string[] rootFolders)
←rootFoldersの引数をstring型からstring配列型に変更
*foreach (string root in rootFolders)*{
index.cshtml中で指定されたルートフォルダをList&lt;string&gt;型インスタンスに保持させます。
Web画面の初回表示時に、dirに、2つ設定したルートフォルダの情報が渡されるので、その情報をList&lt;string&gt;インスタンスに変換して保持する。
（なお、フォルダ・ファイルのクリック時には、そのクリックしたノードの情報のみ渡される。
2つのノード情報がカンマ区切りで送られてくるのは初回表示時のみ）
*dir = Server.UrlDecode(dir);
*if (rootList.Contains(realDir))*{
ルートノードと同じフォルダに対する操作に対しては、そのフォルダ配下の情報は返さないようにする。

*var rnds = new int[5].Select(_ =<; rnd.Next());
new int[5]は0を5個の配列になる
空のシーケンスを返すだけ(いわゆるφ空集合)
あんまり用途ないけど戻り値nullだと駄目なパターンとか
型引数は推論できないため明示してあげる必要あり
出力なし
*var empty = Enumerable.Empty<;int>;();

*[Import(typeof(IPlugin))]
プラグインを"1つだけ"読み込む
フォルダがなければ作る。
*string pluginsPath = Directory.GetCurrentDirectory() + @"\plugins";
プラグイン読み込み
*using (var catalog = new DirectoryCatalog(pluginsPath))

リフレクションを用いて列挙体の型から情報を取得
*var fieldInfo = value.GetType().GetField(value.ToString());
指定した属性のリスト
*var attributes
*if ((attributes?.Count() ?? 0) <;= 0)*return null;
属性がなかった場合、空を返す
同じ属性が複数含まれていても、最初のみ返す
*return attributes.First();

*for (int i = 0; i <;= 50; i++) {*Console.WriteLine(Fibo(i));
f(0)..f(50)までを列挙する
*.Select((Value, Index) =>; new { Index, Value })
f(0)..f(50)までを列挙する
*long[] array = new long[] { 0, 1 };
無限に求める オーバーフローは無視

*string json = @"{'Name': 'Bad Boys','ReleaseDate': '1995-4-7T00:00:00','Genres': ['Action','Comedy']}";
}

DiagnosticAnalyzerクラスを継承する
*[DiagnosticAnalyzer(LanguageNames.CSharp)]
分析で問題があると判断された箇所に表示するメッセージを定義する。
*public const string DiagnosticId = "任意のIDを割振る。";
上で定義した諸々をベースに DiagnosticDescriptor を作成する。
ソースコードに問題が見つかった場合に表示するメッセージ形式を定義している。
*private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(
SymbolKindの部分がポイント。ここで分析対象を指定している。NamedTypeは、クラス名やメソッド名などの名前。
第一引数に分析の処理を指定する。
*context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);
Tips: 分析対象はSyntaxKindでも指定可能。
その場合、RegisterSyntaxNodeActionメソッドを呼び出す。
context.RegisterSyntaxNodeAction(AnalyzeBlock, SyntaxKind.XXX);
*}
*{// contextからソースコードの情報を取り出して、任意の分析処理を実行する。var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;if (namedTypeSymbol.Name.ToCharArray().Any(char.IsLower)){/* 「3. 必要に応じて分析処理の結果を表示する。」 に該当する部分 */var diagnostic = Diagnostic.Create(Rule, namedTypeSymbol.Locations[0], namedTypeSymbol.Name);context.ReportDiagnostic(diagnostic);}}
context.RegisterSymbolAction　の第一引数で指定されているメソッド
contextからソースコードの情報を取り出して、任意の分析処理を実行する。
*var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;

*Console.Write($"Hello, {value}")
"Hello, .NET Core"

*{// Add framework services.services.AddMvc();// リポジトリを登録services.AddSingleton<;IPersonRepository, PersonRepository>;();// SwaggerGen を追加services.AddSwaggerGen();}
This method gets called by the runtime. Use this method to add services to the container.
リポジトリを登録
*services.AddSingleton<;IPersonRepository, PersonRepository>;();
SwaggerGen を追加
*services.AddSwaggerGen();
*{loggerFactory.AddConsole(Configuration.GetSection("Logging"));loggerFactory.AddDebug();app.UseMvc();// .tag ファイルを扱えるようにするvar provider = new FileExtensionContentTypeProvider();provider.Mappings[".tag"] = "riot/tag";// wwwroot/index.html を起動時に表示するようにするapp.UseDefaultFiles();// 静的ファイルを扱えるようにするapp.UseStaticFiles(new StaticFileOptions{ContentTypeProvider = provider});// UseSwagger と UseSwaggerUi を追加app.UseSwagger();app.UseSwaggerUi();}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
.tag ファイルを扱えるようにする
*var provider = new FileExtensionContentTypeProvider();
wwwroot/index.html を起動時に表示するようにする
*app.UseDefaultFiles();
*{ContentTypeProvider = provider});
静的ファイルを扱えるようにする
UseSwagger と UseSwaggerUi を追加
*app.UseSwagger();
リポジトリを登録
*services.AddSingleton<;IPersonRepository, pository>;();
XML Document のパスを取得する
*var location = System.Reflection.Assembly.GetEntryAssembly().Location;
*services.AddSwaggerGen(options =>; {// XML Document Comment を読込むoptions.IncludeXmlComments(xmlPath);});
SwaggerGen を追加
XML Document Comment を読込む
*options.IncludeXmlComments(xmlPath);

TryParseが先に呼ばれてxは初期化されるはずだが・・・
「エラー  CS0165  未割り当てのローカル変数 'x' が使用されました。」
*Console.WriteLine(x);
*{int min = 1, max = 1000, defaultVal = 100;x = !parseResult ? defaultVal: x <; min ? min: max <; x ? max: x;}
Parse成功なら範囲チェック、失敗ならデフォルト値をセット
*{validate(ref x, parseResult);}
逆順だと通る

*{// Hoge()を実行Hoge();}
Use this for initialization
Hoge()を実行
*Hoge();
*if (Time.time >; 1.5f)*{
Time.time &gt; 1.5f の場合に1回だけHoge()を実行
Time.time &gt; 1.5f の場合に１回だけHoge()を実行
*this.UpdateAsObservable()

json    Google によって提供される文字列にエンコードされた JSON
signature    Google によって提供される JSON パラメーターの署名
*var json = payload.String("json");

*Activity reply = activity.CreateReply($"You sent {activity.Text} which was {length} characters");
return our reply to the user
*Activity reply = activity.CreateReply($"「{activity.Text}！」");
「オウム返しだ」「オウム返しだ！」
アイサツは実際大事。古事記にもそう書かれている。
*return message.CreateReply($"「こんにちは！」");
*Activity reply = activity.CreateReply($"「{activity.Text}！」");
「オウム返しだ」「オウム返しだ！」
*if (reply != null)*{
システムメッセージに対する応答
アイサツは実際大事。古事記にもそう書かれている。
*return message.CreateReply($"「こんにちは！」");
省略
*return null;

*var array = new int[5][][];
3次元ジャグ配列
*{if (j == 0) array[i] = new int[5][];array[i][j] = new int[5];});
arrayの配列要素を生成
*{// i + j + k が奇数なら-1, 偶数なら1をセットarray[i][j][k] = ((i + j + k) % 2) == 0 ? 1 : -1;});
arrayの要素を初期化
i + j + k が奇数なら-1, 偶数なら1をセット
*array[i][j][k] = ((i + j + k) % 2) == 0 ? 1 : -1;
何かしらの処理
*return i * j <; 50;

リポジトリを登録
*services.AddSingleton<;IPersonRepository, PersonRepository>;();
*[HttpGet("{id}", Name="GetPerson")]
GET api/v1/person/{id}
*[HttpPut("{id}")]
PUT api/v1/person/{id}
*[HttpDelete("{id}")]
DELETE api/v1/person/{id}
*[HttpDelete("{id}")]
DELETE api/v1/person/{id}
*[HttpGet("{id}", Name="GetPerson")]
GET api/v1/person/{id}

1 - 100 までのメビウス関数を求める
*int upper = 100;
*var primes = new List<;int>;() { 2, 3 };
2,3は既知の素数とする
*while (true) {int prime1st = primes[ix];int prime2nd = primes[++ix];// ふるい用の配列の下限、上限を求め、配列を確保する。var lower = prime1st * prime1st;var upper = prime2nd * prime2nd - 1;// ふるいは、[4:8], [9:24], [25:48], [49:120]... と変化する。// []内の数値は、配列の下限と上限var sieve = new BoundedBoolArray(lower, upper);// 求まっている素数を使い、ふるいに掛けるforeach (var prime in primes.Take(ix)) {var start = (int)Math.Ceiling((double)lower / prime) * prime;for (int index = start; index <;= upper; index += prime)sieve[index] = true;}// ふるいに掛けられて残った値が素数。これを列挙する。// 併せて、求まった素数は、primesリストに記憶していく。// この素数が次にふるいに掛ける際に利用される。for (int i = lower; i <;= upper; i++) {if (sieve[i] == false) {primes.Add(i);yield return i;}}}
4以上の整数から素数を列挙する。int.MaxValueを超えたときには対処していない
ふるい用の配列の下限、上限を求め、配列を確保する。
*var lower = prime1st * prime1st;
ふるいは、[4:8], [9:24], [25:48], [49:120]... と変化する。
[]内の数値は、配列の下限と上限
*var sieve = new BoundedBoolArray(lower, upper);
*foreach (var prime in primes.Take(ix)) {*var start = (int)Math.Ceiling((double)lower / prime) * prime;
求まっている素数を使い、ふるいに掛ける
ふるいに掛けられて残った値が素数。これを列挙する。
併せて、求まった素数は、primesリストに記憶していく。
この素数が次にふるいに掛ける際に利用される。
*for (int i = lower; i <;= upper; i++) {
*class BoundedBoolArray {private BitArray _array;private int _lower;public BoundedBoolArray(int lower, int upper) {_array = new BitArray(upper - lower + 1);_lower = lower;}public bool this[int index] {get {return _array[index - _lower];}set {_array[index - _lower] = value;}}}
下限、上限が指定できるbool型配列

先に効果音を読み込んでおく
*var soundPool = new SoundPool(1, Stream.Music, 0);
SoundPool は再生完了のコールバックがないので、事前に長さを得ておく
*var duration = GetSoundDuration(Resource.Raw.cat);
ダッキングを許可する AudioFocus を要求
*var result = audioManager.RequestAudioFocus(this, Stream.Music, AudioFocus.GainTransientMayDuck);
効果音を再生する
*soundPool.Play(soundId, 1.0f, 1.0f, 0, 0, 1.0f);
再生完了まで待つ
*await Task.Delay((int)duration);
AudioFocus を開放
*audioManager.AbandonAudioFocus(this);
*{using (var player = MediaPlayer.Create(ApplicationContext, rawId)){return player.Duration;}}
音声の再生長さを得る
*{// 今回は使用しない}
IOnAudioFocusChangeListener の実装（RequestAudioFocus のために必要）
今回は使用しない
*}

*socket.OnOpen += (sender, e) =>; {[このときに実行したい処理を記述する]};
WebSocketの接続が確立されたときのイベントハンドラ
*socket.OnMessage += {[このときに実行したい処理を記述する]};
WebSocketからメッセージが送信されたときのイベントハンドラ
*socket.OnError += (sender, e) =>; {[このときに実行したい処理を記述する]};
WebSocketとの接続にエラーが発生したときのイベントハンドラ
*socket.OnClose += (sender, e) =>; {[このときに実行したい処理を記述する]};
WebSocketとの接続が終了したときのイベントハンドラ

View → Modelへの反映
==========================
再生ボタン押下
*_musicPlayerView.PlayButton.OnClickAsObservable()
*.Subscribe(_ =>; { _musicPlayerModel.StopMusic(); }).AddTo(_disposables);
停止ボタン押下
*.Subscribe(_ =>; { _musicPlayerModel.StopMusic(); }).AddTo(_disposables);
シークバーのドラッグ開始
*.Subscribe(_ =>; { _musicPlayerModel.PlayMusic(_musicPlayerView.SeekBar.value); }).AddTo(_disposables);
シークバーのドラッグ終了
Model → Viewへの反映
==========================
再生時間を反映
*_musicPlayerModel.MusicPlayTimeRP
シークバーに反映
*_musicPlayerView.SeekBar.value = time;
テキストに反映
*_musicPlayerView.SetPlayTime(_musicPlayerModel.GetMusicTime());
再生モード変更に応じてボタンの表示を切り替え
*_musicPlayerModel.MusicPlayModeRP

その他 .AddMvc() など...
*}

docの記述
*var imageQuery = bingContainer.Image(word, null, null, null, null, null);
こうすればパスる（null1個追加)
*var imageQuery = bingContainer.Image(word, null, null, null, null, null, null);
↓をやってます。
*using Systemt;
以下で定義されたメンバ変数を使って検索、結果を格納します。
入力
引数word が検索単語です。
以下のコードで使っている定義です。呼び出す前に設定済です。
private const string BING_SEARCH_API_URL = "https:api.datamarket.azure.com/Bing/Search/";
private string m_BingKey = "プライマリ アカウント キー";
private int m_count;  何回目の検索であるかが設定されています。
出力
以下に成功失敗が入ります。
private bool m_success;
失敗の際には以下にエラー（例外メッセージ）が入ります。
private string m_exceptionMeggase;
成功の際には、以下の個数が入ります。
private int m_numberOfItem;
以下にタイトルと画像のURLをそれぞれ入れます。
private string[] m_title = new string[50];
private string[] m_mediaUri = new string[50];
*m_numberOfItem = 0;

*{// Add framework services.services.AddMvc();}
This method gets called by the runtime. Use this method to add services to the container.
*{loggerFactory.AddConsole(Configuration.GetSection("Logging"));loggerFactory.AddDebug();app.UseMvc();// wwwroot/index.html を起動時に表示するようにするapp.UseDefaultFiles();// 静的ファイルを扱えるようにするapp.UseStaticFiles();}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
wwwroot/index.html を起動時に表示するようにする
*app.UseDefaultFiles();
静的ファイルを扱えるようにする
*app.UseStaticFiles();
*{// Add framework services.services.AddMvc();}
This method gets called by the runtime. Use this method to add services to the container.
*{loggerFactory.AddConsole(Configuration.GetSection("Logging"));loggerFactory.AddDebug();app.UseMvc();// .tag ファイルを扱えるようにするvar provider = new FileExtensionContentTypeProvider();provider.Mappings[".tag"] = "riot/tag";// wwwroot/index.html を起動時に表示するようにするapp.UseDefaultFiles();// 静的ファイルを扱えるようにするapp.UseStaticFiles(new StaticFileOptions{ContentTypeProvider = provider});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
.tag ファイルを扱えるようにする
*var provider = new FileExtensionContentTypeProvider();
wwwroot/index.html を起動時に表示するようにする
*app.UseDefaultFiles();
*{ContentTypeProvider = provider});
静的ファイルを扱えるようにする

暗号化
*var publicParameters = CreatePublicKeyParameters(PublicKey);
復号化
*var privateParameters = CreatePrivateKeyParameters(PrivateKey);
暗号化
*var publicParameters = CreatePublicKeyParameters(PublicKey);
復号化
*var privateParameters = CreatePrivateKeyParameters(PrivateKey);
*{Exponent = Adjustment(parameters?.Exponent?.ToByteArray()),Modulus = Adjustment(parameters?.Modulus?.ToByteArray())};
$"OID:{info.AlgorithmID.Algorithm.Id}".Dump();

*SceneView.RepaintAll();
シーンビュー更新

*static readonly string BASE_URL = "http:
vccw.dev";

*int count2 = query2.Count();
7件中の2件抽出

*if (!goal &amp;&amp; next[x] <;= 0) {
分かれ道を進む

*class BoundedBoolArray {private BitArray _array;private int _lower;public BoundedBoolArray(int lower, int upper) {_array = new BitArray(upper - lower + 1);_lower = lower;}public bool this[int index] {get {return _array[index - _lower];}set {_array[index - _lower] = value;}}}
下限、上限が指定できるbool型配列
*var primes = new List<;int>;() { 2, 3 };
2,3は既知の素数とする
*while (true) {int prime1st = primes[ix];int prime2nd = primes[++ix];// ふるい用の配列の下限、上限を求め、配列を確保する。var lower = prime1st * prime1st;var upper = prime2nd * prime2nd - 1;// ふるいは、[4:8], [9:24], [25:48], [49:120]... と変化する。// []内の数値は、配列の下限と上限var sieve = new BoundedBoolArray(lower, upper);// 求まっている素数を使い、ふるいに掛けるforeach (var prime in primes.Take(ix)) {var start = (int)Math.Ceiling((double)lower / prime) * prime;for (int index = start; index <;= upper; index += prime)sieve[index] = true;}// ふるいに掛けられて残った値が素数。これを列挙する。// 併せて、求まった素数は、primesリストに記憶していく。// この素数が次のステップ以降で、ふるいに掛ける際に利用される。for (int i = lower; i <;= upper; i++) {if (sieve[i] == false) {primes.Add(i);yield return i;}}}
4以上の整数から素数を列挙する。int.MaxValueを超えたときには対処していない
ふるい用の配列の下限、上限を求め、配列を確保する。
*var lower = prime1st * prime1st;
ふるいは、[4:8], [9:24], [25:48], [49:120]... と変化する。
[]内の数値は、配列の下限と上限
*var sieve = new BoundedBoolArray(lower, upper);
*foreach (var prime in primes.Take(ix)) {*var start = (int)Math.Ceiling((double)lower / prime) * prime;
求まっている素数を使い、ふるいに掛ける
ふるいに掛けられて残った値が素数。これを列挙する。
併せて、求まった素数は、primesリストに記憶していく。
この素数が次のステップ以降で、ふるいに掛ける際に利用される。
*for (int i = lower; i <;= upper; i++) {
1000個の素数を取得
*var primes = Primes().Take(1000);
500以下の素数を取得
*var primes = Primes().TakeWhile(p =>; p <;= 500);
500より大きい最初の素数を取得
*var prime = Primes().First(p =>; p >; 500);

*hogeMethod_ ();
ネイティブコード上のメソッドを呼び出す

追加分
*app.UseDefaultFiles();

*{// デシリアライズするvar serializer = new XmlSerializer(typeof(Members));var model = (Members)serializer.Deserialize(stream);// person 要素を返すreturn model.Person;}
ファイルを開く
デシリアライズする
*var serializer = new XmlSerializer(typeof(Members));
person 要素を返す
*return model.Person;

*BasePath = "https:
xamarin-chat-sample.firebaseio.com"

*client_secret = appSecret,
FacebookアプリのSecret
取得したアプリアクセストークンを使うようにFacebookClientに設定
*fb.AccessToken = result.access_token;
*dynamic testUsers = fb.Get($"/{appId}/accounts/test-users");
次にアプリに属すテストユーザーのデータを読み出す
最後に、テストユーザーのID(例えば"123455555")を元に、ユーザーアクセストークンを取り出す
*var userToken = ((IEnumerable<;dynamic>;)testUsers.data).FirstOrDefault(_ =>; _.id == "123455555").access_token;
*fb.Post("/me/feed", new { message = "hello from unit test" });
後は、ユーザーアクセストークンを元に投稿するなどする

年月のみでカレンダーを表示させる場合に使用します
*_calendarButton = datePicker.Template.FindName("PART_Button", datePicker) as Button;
表示用と編集用で表示フォーマットを変更します
*this.IscustomizeFormat = !string.IsNullOrEmpty(this.CustomDateFormat);
*if (this.CustomDateFormat.StartsWith("g", StringComparison.CurrentCulture))*{
フォーカスがあたっていない、もしくは読み取り専用の時はカスタム書式で表示
フォーカスが合っていて、編集可能なときは、編集用の書式にする。
*_textBox.Text = this.ToEditingDateFormat(datePicker.SelectedDate.Value, datePicker);
変換前に値を一時保持
*TempText = AssociatedObject.SelectedDate.Value.ToString();
*if (this.CustomDateFormat.StartsWith("g"))*{
フォーカス喪失時の書式設定に変換
*if (AssociatedObject.SelectedDate == null)*{
一時保持した日付を表示します
PART_TextBoxの値がない場合は、カレンダーの初期値を本日にします
*datePicker.DisplayDate = DateTime.Now;
テンプレート内のテキストボックスを検索します。
*var dateTextBox = datePicker.Template.FindName("PART_TextBox", datePicker) as DatePickerTextBox;
変換前に値を一時保持
*TempText = datePicker.SelectedDate.Value.ToString();
*if (datePicker.IsFocused || dateTextBox.IsFocused)*{
編集中の書式

*string path = "output.png";
このようにファイル名で指定します。
以下の関数処理を実装する事で、アプリケーションが実現出来ます。
実際は CuiHelperApplication.cs を見てもらってもよろしいでしょうか・・
*int PrepareDragAndDrop(string[] files, string text);
*m_ComboBoxData = new[] {new CuiHelperComboBoxData { Name = "Goto Home", Commnad = COMMAND_GO_HOME },new CuiHelperComboBoxData { Name = "Calc", Commnad = COMMAND_CALC },new CuiHelperComboBoxData { Name = "View jpg/png file", Commnad = COMMAND_IMAGE },};
CuiHelperComboBoxData[]の生成

*string[] data = {"A","B","C"};
ループ内でカンマ追記判定
*string[] data = {"A","B","C"};
ループ後にカンマ削除
csv = csv.TrimEnd(','); C#ならTrimEndでもいい
*Console.Write(csv);
*string[] data = {"A","B","C"};
ループ中にカンマ文字列定義
*string[] data = {"A","B","C"};
先に先頭の値をセット
*string[] data = {"A","B","C"};
String.Joinメソッド

要素取得時ではなく関数呼び出し時に上記の引数チェックが行われるように、
yield を用いた処理は別関数にする。
*return RepeatRandomChoiceInternal(source);
要素取得時ではなく関数呼び出し時に上記の引数チェックが行われるように、
yield を用いた処理は別関数にする。
*return TakeUntilMatchingPatternInternal(source, pattern);

*Utils.webCamTextureToMat(webCamTexture, mat, colors);
ArgumentException: The output Mat object has to be of the same size
以下Mat処理
*}
宣言
*texture = new Texture2D(webCamTexture.width, webCamTexture.height);
以下Mat処理
*}

OK のとき
*Console.WriteLine("ok");
それ以外
*Console.WriteLine("cancel");
メッセージ ボックスを表示する関数を設定
*ShowMessageBox = () =>; MessageBox.Show(messageBoxText, caption, button, icon);
メッセージボックスを表示して結果を受取る
*var result = ShowMessageBox();
*if (!_acts.ContainsKey(result) || _acts[result] == null)*return;
存在しないかあっても null の場合は何もしない
実行
*_acts[result]();
確認
*var confirm = ChainableMessageBox
確認
*var confirm = ChainableMessageBox.Create(MessageBoxButton.OKCancel, MessageBoxImage.Question);
エラー
*var error = ChainableMessageBox.Create(MessageBoxButton.OK, MessageBoxImage.Error);
なにか重たい処理...
*await Task.Delay(TimeSpan.FromSeconds(2));

Property IDを引数に渡します。(string型)
*InMobiAndroid.init ("Property ID", dict);
Placement ID(long型), bannerの名前, bannerの位置, 横のサイズ, 縦のサイズ, インターバルの時間 を引数に渡します。
*InMobiAndroid.createBanner (Placement ID, name, InMobiAdPosition.BottomCenter, 320, 50, 30, "test1,test2,test3", dict);
作成したbannerの名前を引数に渡します。
*InMobiAndroid.loadBanner(name);

テストケース内で次のようにアクセス出来る。
_appsettingsFixture.Configuration
*}

config読みだし
*FileName = config.AppSettings.Settings["FileName"].Value;
config書き込み
*config.AppSettings.Settings["FileName"].Value = FileName;

*{var index = Array.IndexOf(persister.PropertyNames, propertyName);if (index == -1)return;state[index] = value;}
ref: http:stackoverflow.com/a/24908880

*{// Add framework services.services.AddMvc();}
This method gets called by the runtime. Use this method to add services to the container.
*{loggerFactory.AddConsole(Configuration.GetSection("Logging"));loggerFactory.AddDebug();app.UseMvc();// プロジェクトで扱う各種静的ファイルの場所を指定する// js/css ファイルの読込み先var location = "wwwroot/app";// 実行時に表示する html ファイルを指定するvar options = new DefaultFilesOptions();options.DefaultFileNames.Clear();options.DefaultFileNames.Add("app/index.html");app.UseDefaultFiles(options);app.UseStaticFiles();// javascriptapp.UseStaticFiles(new StaticFileOptions{FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), $"{location}/scripts")),RequestPath = new PathString("/scripts"),});// cssapp.UseStaticFiles(new StaticFileOptions{FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), $"{location}/styles")),RequestPath = new PathString("/styles")});// html テンプレートapp.UseStaticFiles(new StaticFileOptions{FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), $"{location}/views")),RequestPath = new PathString("/views")});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
プロジェクトで扱う各種静的ファイルの場所を指定する
js/css ファイルの読込み先
*var location = "wwwroot/app";
実行時に表示する html ファイルを指定する
*var options = new DefaultFilesOptions();
*{FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), $"{location}/scripts")),RequestPath = new PathString("/scripts"),});
javascript
*{FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), $"{location}/styles")),RequestPath = new PathString("/styles")});
css
*{FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), $"{location}/views")),RequestPath = new PathString("/views")});
html テンプレート

*yield return i;
ここで列挙してしまう

*bool b3 = obj is Oneisan;
False

*private bool disposedValue = false;
重複するDispose()呼び出しを検出する
IDisposableを実装しておくと、xUnitがテスト終了時に呼び出してくれる
https:xunit.github.io/docs/shared-context.html#class-fixture
*public void Dispose()
テストケースが続く．．．．．．．
*}

*hiddenNeurons: new int[] { 1 });
出力層の次元
ネットワークの重みをガウス分布で初期化する
*new GaussianWeights(network).Randomize();
DBNの学習アルゴリズムの生成（誤差関数を決める部分）
*var teacher = new PerceptronLearning(network);
*for (int i = 0; i <; 1000; i++)*teacher.RunEpoch(inputs, outputs);
学習実行。同じデータを1000回学習させる。
重みの更新
*network.UpdateVisibleWeights();

*else
スペースキーから指を離したとき
現在描画中の線があったらnullにして次の線を描けるようにする。
*CurrentLineObject = null;
*if (Input.GetKeyDown(KeyCode.Delete)) Destroy(gameObject);*}
削除

*public double GetBmi() {
2. メソッド

ページイメージをファイルに保存する
*var now = DateTime.Now;

*{var dict = new RouteValueDictionary(anonymousObj);foreach (var kv in dict){Console.WriteLine($"{kv.Key} =>; {kv.Value}");}}
匿名型のオブジェクトを受け取り、辞書に変換する

*{
ここに行く

このクラスの中身がここに入る
*};
*void Start () {}
Use this for initialization
*void Update () {}
Update is called once per frame
*void Start () {}
Use this for initialization
*void Update () {int count = transform.childCount;if(prayerTransform.childCount==count){//プレイヤーの子の数と自分の子の数が同じ場合の処理}}
Update is called once per frame
プレイヤーの子の数と自分の子の数が同じ場合の処理
*

*public ActionResult ExecProcessCompleted(AsyncTestModel key)
AsyncManager.Parametersに指定したkey名で引数を受とる。

*{[ObjectId]public string SSN { get; set; }public string Name { get; set; }public int Age { get; set; }public Person Owner { get; set; }}
Define your models like regular C# classes
*{var id = this.Count();var mydog = realm.CreateObject<;Dog>;();mydog.SSN = (id).ToString ();mydog.Name = newDog.Name;mydog.Age = newDog.Age;});
トランザクションを用いてオブジェクトを保存・更新します.
*{// これはだめ.//              foreach (var dog in realm.All<;Dog>;())//              {//                  this.realm.Remove(dog);//              }this.realm.RemoveAll<;Dog>;();trans.Commit();}
トランザクションを開始してオブジェクトを削除します.
*//              foreach (var dog in realm.All<;Dog>;())*//              {
これはだめ.
*//              {//                  this.realm.Remove(dog);//              }
foreach (var dog in realm.All&lt;Dog&gt;())
*using (var trans = this.realm.BeginWrite ()) {this.realm.Remove(obj);trans.Commit();}
Delete an object with a transaction
*foreach (var dog in dogs)*{
ダンプする.

*HttpResponseMessage aResponse = await httpClient.PostAsync("http:
flashairupload.cgi", fileContent);
呼び出し例
*var str = await uploadStringToFile("任意の文字列");

*Debug.WriteLine(cnt);
=&gt; 2になるはず
Threadは使えません！
new Thread(() =&gt;
*new Task(() =>;

*if (n <;= 0) return 0;*// (n &amp; (n - 1)) == 0 の時は、nが2の冪乗であるため、そのままnを返す。
nが0以下の時は0とする。
*if ((n &amp; (n - 1)) == 0) return (uint)n;*// bitシフトを用いて、2の冪乗を求める。
(n &amp; (n - 1)) == 0 の時は、nが2の冪乗であるため、そのままnを返す。
*while (n >; 0) { ret <;<;= 1; n >;>;= 1; }
bitシフトを用いて、2の冪乗を求める。
*if (n <;= 0) return 0;*// (n &amp; (n - 1)) == 0 の時は、nが2の冪乗であるため、そのままnを返す。
nが0以下の時は0とする。
*if ((n &amp; (n - 1)) == 0) return (uint)n;*// bitシフトを用いて、2の冪乗を求める。
(n &amp; (n - 1)) == 0 の時は、nが2の冪乗であるため、そのままnを返す。
*while (n >; 0) { ret <;<;= 1; n >;>;= 1; }
bitシフトを用いて、2の冪乗を求める。

開始日プロパティ取得
*var startDateProperty = validationContext.ObjectInstance.GetType().GetProperty(StartDatePropertyName);
開始日プロパティの値取得
*var startDateValue = startDateProperty.GetValue(validationContext.ObjectInstance, null );
*if (value == null)*{
終了日

コンストラクタの呼び出し
*Programs programs = new Programs();
programsインスタンスを破棄
*programs = null;
*{Console.WriteLine("コンストラクタが自動で呼ばれました");}
コンストラクタの定義
コンストラクタの呼び出し
*Programs programs1 = new Programs();
*{Console.WriteLine("引数が無いコンストラクタです");}
コンストラクタの定義

Web API の設定およびサービス
*config.Filters.Add(new PrettyPrintFilterAttribute());
Web API ルート
*config.MapHttpAttributeRoutes();

シーケンスを配列に変換します。
*var source2 = source.ToArray();
*for( int i = 0; i <; source2.Length; i++ ) {// シーケンスのi番目の要素を、ブロックの( i mod numInBlock )番目に代入します。block[i % numInBlock] = source2[i];// iをnumInBlockで割った余りが、ブロックの末尾のインデックスと等しい or// iがシーケンスの末尾のインデックスと等しいかどうか判別します。if( i % numInBlock == numInBlock - 1 || i == source2.Length - 1 ) {// ブロックを返します。yield return block;// 新しいブロックを作成します。（注：配列は参照型です）block = new T[numInBlock];}}
ブロックとなる配列です。
シーケンスのi番目の要素を、ブロックの( i mod numInBlock )番目に代入します。
*block[i % numInBlock] = source2[i];
*if( i % numInBlock == numInBlock - 1 || i == source2.Length - 1 ) {// ブロックを返します。yield return block;// 新しいブロックを作成します。（注：配列は参照型です）block = new T[numInBlock];}
iをnumInBlockで割った余りが、ブロックの末尾のインデックスと等しい or
*if( i % numInBlock == numInBlock - 1 || i == source2.Length - 1 ) {*// ブロックを返します。
iがシーケンスの末尾のインデックスと等しいかどうか判別します。
ブロックを返します。
*yield return block;
新しいブロックを作成します。（注：配列は参照型です）
*block = new T[numInBlock];
各要素にインデックスを付加し、numInBlockで割った値と要素の値とのペアを作成します。
*return source.Select( ( v, i ) =>; new KeyValuePair<;int, T>;( i / numInBlock, v ) )
numInBlockで割った値でグループ化し、そのグループに属する要素の値を抽出します。
*.GroupBy( v1 =>; v1.Key, v2 =>; v2.Value )
グループに属する要素の値を配列に変換します。
*.Select( block =>; block.ToArray() );
ブロックとなる配列です。
*var block = new T[numInBlock];
*foreach( var s in source.Select( ( v, i ) =>; new KeyValuePair<;int, T>;( i % numInBlock, v ) ) ) {*// 要素のキーをブロックのインデックスとして指定し、要素の値を代入します。
各要素にインデックスを付加して、numInBlockで割った余り（ = ブロック内のインデックス ）と要素の値とのペアを作成し、それらを列挙します。
要素のキーをブロックのインデックスとして指定し、要素の値を代入します。
*block[s.Key] = s.Value;
*if( s.Key == numInBlock - 1 ) {*// ブロックを返します。
現在の要素のキーとブロックの配列の末尾のインデックスが等しいかどうかを判別します。
ブロックを返します。
*yield return block;
新しいブロックを作成します。
*block = new T[numInBlock];
ブロック内のインデックスです。
*int indexInBlock = numInBlock - 1;
ブロックとなる配列です。
*var block = new T[numInBlock];
*foreach( var s in source.Select( ( v, i ) =>; new KeyValuePair<;int, T>;( i % numInBlock, v ) ) ) {*indexInBlock = s.Key;
各要素にインデックスを付加して、numInBlockで割った余り（ = ブロック内のインデックス ）と要素の値とのペアを作成し、それらを列挙します。
ブロック内の要素にシーケンスの要素を代入します。
*block[s.Key] = s.Value;
*if( s.Key == numInBlock - 1 ) {*// ブロックを返します。
現在のブロック内のインデックスが末尾であるかどうかを判別します。
ブロックを返します。
*yield return block;
新しいブロックを作成します。
*block = new T[numInBlock];
*// シーケンスの末尾側の要素がforeach文内でまだ返していないので、*// ここで返します。
indexInBlockの値が、ブロック内の末尾のインデックスより前にいる時、
*if( indexInBlock <; numInBlock - 1 ) {yield return block;}
シーケンスの末尾側の要素がforeach文内でまだ返していないので、
*if( indexInBlock <; numInBlock - 1 ) {*yield return block;
ここで返します。
ブロック内のインデックスです。
*int indexInBlock = numInBlock - 1;
ブロックとなる配列です。
*var block = new T[numInBlock];
*foreach( var s in source.Select( ( v, i ) =>; new KeyValuePair<;int, T>;( i % numInBlock, v ) ) ) {*indexInBlock = s.Key;
各要素にインデックスを付加して、numInBlockで割った余り（ = ブロック内のインデックス ）と要素の値とのペアを作成し、それらを列挙します。
ブロック内の要素にシーケンスの要素を代入します。
*block[s.Key] = s.Value;
*if( s.Key == numInBlock - 1 ) {*// ブロックを返します。
現在のブロック内のインデックスが末尾であるかどうかを判別します。
ブロックを返します。
*yield return block;
新しいブロックを作成します。
*block = new T[numInBlock];
*// シーケンスの末尾にある端数の要素がforeach文内でまだ返していないので、*// ここで返します。
indexInBlockの値が、ブロック内の末尾のインデックスより前にいる時、
*if( includeLastFractionBlock &amp;&amp; indexInBlock <; numInBlock - 1 ) {yield return block;}
シーケンスの末尾にある端数の要素がforeach文内でまだ返していないので、
*if( includeLastFractionBlock &amp;&amp; indexInBlock <; numInBlock - 1 ) {*yield return block;
ここで返します。
塩基配列（RNA）
*string rnaSeq = "AUGAUGGAGCUUCGGAGCUAG";
コドンに変換します。
*var codon = rnaSeq.ToBlockSequence( 3 ).Select( c =>; new string( c ) );
*Console.WriteLine( $"Codon      : {string.Join( "-", codon )}" );
コドンを出力します。
*Console.WriteLine( $"Amino acid : {string.Join( "-", codon.Select( c =>; RNACodonTable[c] ) )}" );
コドン表に従ってアミノ酸に変換し、出力します。

View を返す
*Get["/"] = _ =>; View["index"];
*{new Person { Id = 1, Name = "Francis" },new Person { Id = 2, Name = "Nancy" },};
TODO: スタブ
JSON に変換して返す
*Get["/"] = _ =>; Response.AsJson(_values);
*Get["/{id}"] = p =>; Response.AsJson(
指定された ID の Person を JSON に変換して返す
View のロケーションを追加
*nancyConventions.ViewLocationConventions
静的コンテンツの場所をクリア
*nancyConventions.StaticContentsConventions.Clear();
静的コンテンツの場所を追加
Bower
*nancyConventions.StaticContentsConventions
JSファイル
*nancyConventions.StaticContentsConventions
CSSファイル
*nancyConventions.StaticContentsConventions

*var v =  new Vector2(-vec.y,vec.x).normalized * width;
90度回転させてから正規化*widthで左右への幅ベクトルを得る
指定した横幅に広げる
*vertices.Add(currentPos-v);
*if (Physics2D.CircleCast(pos, 0.2f, Vector2.zero))*{
既にあるオブジェクトに当たりそうならそこで生成を辞める
*for (int index = 0; index <; mesh.vertices.Length; index+=2)*{
偶数を小さい順に
*for (int index = mesh.vertices.Length-1; index >; 0; index-=2)*{
奇数を大きい順に

Applicationを強制終了
*Application.Quit();
Editorを強制終了
*UnityEditor.EditorApplication.isPlaying = false;
Applicationを強制終了
*Application.Quit();
Editorを強制終了
*UnityEditor.EditorApplication.isPlaying = false;
Applicationを強制終了
*Application.Quit();
Editorを強制終了
*UnityEditor.EditorApplication.isPlaying = false;

*{new Person { Id = 1, Name = "Francis" },new Person { Id = 2, Name = "Nancy" },};
TODO: スタブ
View を返す
*Get["/"] = _ =>; View["index"];
JSON に変換して返す
*Get["/api/person"] = _ =>; Response.AsJson(_values);
*Get["/api/person/{id}"] = p =>; Response.AsJson(
指定された ID の Person を JSON に変換して返す
*// For more information on how to configure your application, visit http://go.microsoft.com/fwlink/?LinkID=398940*public void ConfigureServices(IServiceCollection services)
This method gets called by the runtime. Use this method to add services to the container.
*{}
For more information on how to configure your application, visit http:go.microsoft.com/fwlink/?LinkID=398940
*{app.UseOwin(pipeline =>; pipeline.UseNancy(options =>; options.Bootstrapper = new BootStrapper()));}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*Get["
"] = _ =&gt; View["index"];"Hello World!";
JSON に変換して返す
*Get["/api/person"] = _ =>; Response.AsJson(_values);
*Get["/api/person/{id}"] = p =>; Response.AsJson(
指定された ID の Person を JSON に変換して返す

HttpCode:200を返して何事もなかったようにする
*actionExecutedContext.Response = actionExecutedContext.Request.CreateResponse();

*{Arg0?.GetType() ?? typeof(object),Arg1?.GetType() ?? typeof(object),Arg2?.GetType() ?? typeof(object),Arg3?.GetType() ?? typeof(object),};
各引数の型から動的に ScriptArguments&lt;&gt; オブジェクトを作り出す。
スクリプトをコンパイルしてデリゲートを作成する。
*_runner = CSharpScript
デリゲートを実行
*await _runner?.Invoke(_args);
*public T0 Arg0 { get; set; }
4個も引数があれば足りるでしょ。

*Debug.Log(x);
コンソールに1を出力
コンソールに"Check is true"を出力
*,,,

*Buffer.Memcpy((byte*)dmem, (byte*)smem, charCount * 2);
2 used everywhere instead of sizeof(char)
中略
copyToのコピー実態
*if (count >; 0)

*{return View(db.Books.ToList());}
GET: Books
*{if (id == null){return new HttpStatusCodeResult(HttpStatusCode.BadRequest);}Book book = db.Books.Find(id);if (book == null){return HttpNotFound();}return View(book);}
GET: Books/Details/5
*{return View();}
GET: Books/Create
過多ポスティング攻撃を防止するには、バインド先とする特定のプロパティを有効にしてください。
詳細については、http:go.microsoft.com/fwlink/?LinkId=317598 を参照してください。
*[HttpPost]
*{if (id == null){return new HttpStatusCodeResult(HttpStatusCode.BadRequest);}Book book = db.Books.Find(id);if (book == null){return HttpNotFound();}return View(book);}
GET: Books/Edit/5
過多ポスティング攻撃を防止するには、バインド先とする特定のプロパティを有効にしてください。
詳細については、http:go.microsoft.com/fwlink/?LinkId=317598 を参照してください。
*[HttpPost]
*{if (id == null){return new HttpStatusCodeResult(HttpStatusCode.BadRequest);}Book book = db.Books.Find(id);if (book == null){return HttpNotFound();}return View(book);}
GET: Books/Delete/5

*ap.showImage(file.Path);
画像表示

YAMLのストリームを解析して読み込むとき
*var input = new StreamReader(@"cshp.yaml", Encoding.UTF8);
*Console.WriteLine("thema\t{0}", thema.Value);
2015-5-28-01
title   .NETプログラミングにピンポイントで役立つテクニックとヒント集
url     http:www.atmarkit.co.jp/ait/subtop/features/dotnet/dotnettips_index.html
title   初めてのＣ＃
url     http:homepage3.nifty.com/midori_no_bike/CS/
*}
C#のクラスにデシリアライズして読み込むとき
*DeserializedObject obj = YamlImporter.Deserialize("cshp.yaml");

*Spawners[waveNumber]();
result: Wave1

*button1.Clicked += delegate
button1はButtonインスタンス
*{Title = "helloxamarin",Content = new StackLayout{VerticalOptions = LayoutOptions.Center,Children = {new Label {HorizontalTextAlignment = TextAlignment.Center,Text = "Welcome to Xamarin Forms!"},label1,button1,}},};
The root page of your application
*{label1.TextColor = Color.Aqua;content.DisplayAlert("これはタイトルです", "これは表示するメッセージです", "はい");};
これ以降でイベントの定義

*w.WriteLine (string.Format ("
CFBundleDisplayName = \"{0}\";", "ほげほげ"));
設定保存
*File.WriteAllText (projPath, pbxproj.WriteToString ());

*csv.Configuration.HasHeaderRecord = false;
Headerはなし

Note: Navigation操作に関わるバグへの対処
読み込み中にナビゲーション等によって ListView の LayoutUpdate が阻害されると
IncrementalLoading 処理が呼び出し続けられてしまいます（※未検証）
これを防止するため、Page.NavigationTo/From で IsPuaseLoading をスイッチして対応してください
なおPage.NavigationFromでIncrementalLoadingCollectionをItemsSourceから外すとより確実に読み込みを一時停止できます
*public bool IsPuaseLoading { get; set; }
多重読み込み防止のため
リスト表示に反映されるまで
タスクの終了を遅延させる必要があります
*await Task.Delay(500);
Note: PullToRefresh等で要素を削除した時のための対応
IIncrementalSourceの実装で head == 1 の時に
強制的にアイテムソースのリストを更新させるよう対応してください
*_Position = 1;

*var targetUri = new Uri("https:
www.gotokyo.orgeventlistjalist");

*"B13EC36903F8BF4701D498261A0802EF63642BC3"
DigiCert High Assurance EV Root CA

