var results = _repository.GetStudentInfo(model).ToList());
_repositoryはDB操作をするための自作クラスの変数。GetStudentInfoでDBから情報を取得してくる
m_texture.SetPixel( x, y, Color.black );
点を描画
services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
.AddCookieでは認証用のCookieに関する設定です
option.LoginPath = "/LoginController/LoginAction";
HttpContext.ChallengeAsync(認証チャレンジ)で認証失敗した場合のリダイレクト先
option.AccessDeniedPath = "/LoginController/ForbidAction";
HttpContext.ForbidAsync（認証されているが、必要な権限がない時の禁止）でのリダイレクト先
option.Cookie.Name = "token";
該当スキームのCookie名
option.ExpireTimeSpan = TimeSpan.FromMinutes(5);
Cookieの中に保存されている認証データの有効期限、ここでは5分以内にサーバーへアクセスがないと認証タイムアウトが発生する
var claims = new List<Claim>(){new Claim(ClaimTypes.Sid,loginId)};
ログインID,パスワードチェック処理省略、ログイン出来ると仮定する
await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, identityPrincipal,
認証サービス登録する際に設定したスキームと同じものを設定
AllowRefresh = true,
サーバーアクセスによる認証時間を更新する
ExpiresUtc = DateTimeOffset.UtcNow.AddMinutes(5),
認証の有効期間,認証cookieタイムアウト
IsPersistent = false,
cookieの有効期間を優先かsessionを優先か
IssuedUtc = DateTime.UtcNow
cookieの認証時間
option.IdleTimeout = TimeSpan.FromMinutes(5);
5分以上操作がないとセッションタイムアウト
data_1.number = data_2.number = ResultData.no.Tostring();
data_1にそのまま代入
if (data_3 != null)
data_3がnullでない場合
builder.WithOrigins(this.Configuration.GetSection("CorsUrl").Value)
appsettings.jsonから"CorsUrl"の値を取得して設定。
List<int> ls2 = new List<int>();
ls2に全ての要素を入れ直す
csv.ReadHeader();
ヘッダー　を次に行う
csv.Configuration.RegisterClassMap<CsvMapperKenAll>();
データを読み出し
tempDatas = new ObservableCollection<KenAllCSV>();
DataGridに出力
{return (IEnumerable)obj.GetValue(SelectableDatesProperty);}
ゲッター
{obj.SetValue(SelectableDatesProperty, value);}
セッター
datePicker.DisplayDateStart = minDate;
区間の最初を設定
_sliderX.OnValueChangedAsObservable()
X軸操作用Sliderの値の変更を監視
_sliderY.OnValueChangedAsObservable()
Y軸操作用Sliderの値の変更を監視
_sliderZ.OnValueChangedAsObservable()
Z軸操作用Sliderの値の変更を監視
valueText.text = arrangeValue.ToString();
テキストに値を反映
_sliderView.SliderValueRP_X
Sliderの値の更新を監視
Environment.SetEnvironmentVariable("Path",
環境パス設定
var conversationId = "<ConversationID>";
API経由で取得したConversationID
readonly ObservableCollection<Person> tmpPeople = new ObservableCollection<Person>();
DataGridにバインドするModel
var keyFunc = GetDynamicPropertyExpression(e.Column.Header.ToString()).Compile();
p => p."columnName"というラムダ式を生成
sortedPeople = new List<Person>(tmpPeople.OrderBy(keyFunc));
ColumnNameの中身でOrderBy
sortedPeople = new List<Person>(tmpPeople.OrderByDescending(keyFunc));
ColumnNameの中身でorderByDescending
pipeServer.WaitForConnection();
クライアントの接続待ち
cam.transform.position = position.transform.position;cam.transform.rotation = position.transform.rotation;
カメラを移動
csvDatas.Add(cell.Split(','));
','を目安にリストに格納していく
for (int i = 0;values.Length > i;i++) {values[i] = Random.value;}
選択に使用する[0.0f~1.0f]の値を用意する
for (int k = 0;iteration > k;k++) {weightedSelector.SelectItem(values[k]);
WeightedSelectorからアイテムを選択する
SceneManager.LoadScene(sceneName);
シーンチェンジ
PhotonNetwork.JoinLobby();
ロビーへ移動する
roomButton.name = r.Name;
ボタンの名前を作成するルームの名前にする
{if (gameObject.transform.Find(r.Name)){GameObject.Destroy(gameObject.transform.Find(r.Name).gameObject);}}
ルームボタンの削除
if (gameObject.transform.Find(r.Name)){
ボタンが存在すれば削除
PhotonNetwork.JoinLobby();
ロビーへ移動する
yield return new WaitUntil(() => Input.anyKeyDown);
キー入力を待機
if(createRoomName == "")
ルーム名が入力されてないなら自動生成
RoomOptions roomOptions = new RoomOptions();
ルームのオプションの設定
PhotonNetwork.CreateRoom(createRoomName, roomOptions , null);
指定したルーム名と同じルーム名が存在している場合、PhotonNetworkの方で作成できないようになっている
if (IsSelected)
選択状態の場合のみ
if (Bounds.Width < 0){
幅がマイナスの場合
if (Bounds.Height < 0){
高さがマイナスの場合
public struct Data{[DataMenber]public int hoge;}
Dataの構造体の定義
private Data data;
Dataのインスタンス
dataContractJsonSerializer.WriteObject(memoryStream, data);
memoryStreamにDataのインスタンスをシリアライズしたJsonデータを書き込む
memoryStream.Position = 0;
カーソル位置を最初に戻す
using(var streamReader = new StreamReader(memoryStream, Encoding.UTF8)){var filePath = "任意のファイルのパス";File.WriteAllText(filePath, streamReader.ReadToEnd(), Encoding.UTF8);}
memoryStreamの内容を読み込んで、全ての文字列をファイルに書き出す
if(sch == null)
スキーマがあるかどうかを判定
sb.SetSchemaName("適当なスキーマ名");
スキーマ名をセット
sb.AddSimpleField("適当なフィールド名", typeof(string));
フィールド名設定
sch = sb.Finish();
スキーマを取得
Entity ent = doc.ProjectInformation.GetEntity(sch);
Entityを取得
ent.Set<FieldType>("適当なフィールド名", xmldata.ToString());
XMLを設定
doc.ProjectInformation.SetEntity(ent);*,,,
Docに設定
if (!elem.GetEntity(sch).IsValid())
有効な値が無い時
if (e.ErrorCode != 49)
エラー コード 49 は「認証失敗」
encode = encode ?? Encoding.GetEncoding("Shift-JIS");*var cutChars = text
エンコード未指定時はShift-JISを仮置き
var templateMat = new Mat(fileName);
マッチング
if (match < 0){
マッチなし
Cv2.MinMaxLoc(resultMat, out _, out var maxVal, out _, out matchPoint);
一番マッチした箇所のマッチ具合と、その位置を取得する
GameObject _wb = GameObject.FindGameObjectWithTag("Whiteboard");
GameObjectを取得。
texture = (Texture2D)_wb.GetComponent<Renderer>().material.mainTexture;
TextureをGameObjectから取得
StartCoroutine(SendData(picData));
SendDataを呼び出す
var request = new UnityWebRequest(url, "POST");
サーバ上のphpに送信する
if (GamepadIndex != null){
認識済みの場合
GamepadIndex = null;
認識済みのゲームパッドが無効になったとみなす
var date = new DateTime(2021, 1, 1, 0, 0, 0, 0);
2021/01のパッチだけ取得
level.Value++;
.Valueで中身にアクセスする
string responceStr = Encoding.UTF8.GetDtring(responceByte);
リクエストを送信し、レスポンスを取得
return (responce.permalink);
取得したメッセージのURLを返す
[DataType(DataType.Date)]
DataTypeの指定
{DateTime time = DateTime.Now;for (int i = 0; i < count; i++){action();}return DateTime.Now - time;}
関数の処理にかかる時間を計測する
catch (Exception ex)
例外をcatchする。
*{HttpClientInitializer = credential,ApplicationName = ApplicationName,});
ReportsAPIサービスを作成します
{this.name = name;this.age = age;}
情報は直接変数にアクセスできない様にメソッド化する
Info[] src = new Info[] { };
Infoクラスをインスタンス化
var list = new List<Info>();
Listを生成
list.AddRange(src);
listに要素を追加
var c = new Comparison<Info>(Compare);
listをソート
var x = a.age - b.age;
xにはa.ageとb.ageの差が入る
HttpWebResponse response = (HttpWebResponse)request.GetResponse();
リクエスト出す
project.Add(dir);
プロジェクトインスタンスに追加
session.Log("in customaction");
MSIのログに出力
session["A_PROPERTY"] = "ABCDE";
MSIプロパティを設定する
*string propb = session["B_PROPERTY"];
MSIプロパティを取得する
string caData = session.CustomActionData;
CustomActionDataを取得する
ActionAssembly = "%this%",
カスタムアクションメソッドが入っているアセンブリを指定する
using UnityEngine;
共通クラスライブラリ
protected override void Initialize()
UnityのDebugLog出力ソースコード
{Ground.In.Value = level;}
ログ出力レベルの変更
PdfDocument doc = new PdfDocument();
PdfDocument obejctを作成します。
doc.LoadFromFile(@"C:\Users\Administrator.SD-20151030NEMY\Desktop\java输出\吾輩.pdf");
PDFをロードします
PdfPageBase page = doc.Pages[4];
スタンプを作成するページを取得します。
PdfTemplate template = new PdfTemplate(180, 50);
テンプレートオブジェクトを作成します
PdfCjkStandardFont font1 = new PdfCjkStandardFont(PdfCjkFontFamily.SinoTypeSongLight, 16f, PdfFontStyle.Bold | PdfFontStyle.Italic);
フォントを設定します。
PdfSolidBrush brush = new PdfSolidBrush(Color.Purple);
ソリッドブラシとグラデーションブラシを作成します。
template.Graphics.DrawPath(gradientBrush, path);
テンプレートで角丸長方形のパスを描き、グラデーションで塗りつぶします。
template.Graphics.DrawPath(PdfPens.Purple, path);
テンプレートで角丸長方形のパスを描き、紫色でパスを塗りつぶします。
PdfRubberStampAnnotation stamp = new PdfRubberStampAnnotation(new RectangleF(new PointF(page.ActualSize.Width - 250, 200), template.Size));
PdfRubberStampAnnotationオブジェクトを作成し、そのサイズを設定します。
PdfAppearance apprearance = new PdfAppearance(stamp);
PdfApperanceオブジェクトを作成し、テンプレートをnormalにします。
stamp.Appearance = apprearance;
スタンプでPdfApperanceオブジェクトを適用します。
page.AnnotationsWidget.Add(stamp);
スタンプをPdfAnnotationに追加します。
System.IO.Directory.SetCreationTime(BasePath + "新しいフォルダー", DateTime.Now);
作成日時の設定
System.IO.Directory.SetLastWriteTime(BasePath + "新しいフォルダー", DateTime.Now);
更新日時の設定
System.IO.Directory.SetLastAccessTime(BasePath + "新しいフォルダー", DateTime.Now);
アクセス日時の設定
var TrendsJson = tokens.Trends.Place(15015370);
JSONデータを取得
string UrlDec = System.Web.HttpUtility.UrlDecode(JsonData);
URLデコードする
Root TrendData = JsonConvert.DeserializeObject<Root>(UrlDec);
JSON文字列をデシリアライズ
Thread.Sleep(1000);
1秒待つ
Random Rnd = new Random();
ランダム数値生成
string TrendText = TrendData.json_data[0].trends[TrendRdm].query;
トレンド文字列取得
TrendText = TrendText.Replace("#","");
#を置換
Thread.Sleep(1000);
1秒待つ
var color = GetCurrentColor();
colorを設定ファイルから呼び出します
ResizeHandles.Draw(g);
リサイズハンドルを描画
typeof(T).TypeHandle;
Handleにアクセス
typeof(T).TypeHandle.Value;
IntPtrにアクセス
int data = (int)(object)100;
100をdataの中に入れる
nested_ptr_arr [i] = *((byte*)data_ptr + 16 + i);
先頭の16byte分ずらしたところから8byte分だけ切り取る
private Random Random { get; } = new();
表示位置をランダムにするための Random クラス
Items.Add(new(Random.Next(500), Random.Next(500), DateTime.Now.ToString()));
ランダムな位置に、とりあえず現在時間の文字列を出すようなデータを作る
if (navigationContext.Parameters.TryGetValue<int>("x", out var x))*{
パラメーターから表示位置や表示する内容を取得してプロパティに保持
var targets = sources.Select(sourceToTarget).ToObservableCollection();
sourcesの要素を変換したコレクションを生成
SyncCollectionTwoWay(sources, targets, sourceToTarget, targetToSource);
2つのコレクションを同期させる
string senderName = "anonymous";
送信者の名前用変数
if (!string.IsNullOrEmpty(mi.Sender.NickName)){
送信者の名前があれば
showText.text = senderName + ": " + newLine;
受信したチャットをログに追加
jar.WaitForExit();
終了待ち
jar.ExitCode();
結果取得
db.Database.EnsureCreated();
スキーマとかテーブルが無かったら作るよ。
int recordsAffected = db.SaveChanges();
データベースへ保存
Console.ReadKey();
キー入力待ち
Presentation ppt = new Presentation();
PPTファイルをロードします。
ISlide slide = ppt.Slides[0];
スライドを取得します。
slide.Shapes.AppendVideoMedia(@"ビデオ.mp4", new RectangleF(300, 150, 300, 150));
スライドに動画を挿入します。
foreach (ISlide slide in ppt.Slides){
スライドをループします。
foreach (IShape shape in slide.Shapes){
スライド内のシェイプをループします。
if (shape is IVideo){
シェイプが動画なのか判断します。
(shape as IVideo).EmbeddedVideoData.SaveToFile(string.Format(@"動画{0}.mp4", i));
動画を保存します。
Array.Resize(ref numbers, numbers.Length + 1);
配列サイズを１つ増やす
for (int i = 0; i < 5; i++) {*numbers[i] = int.Parse (Console.ReadLine ());
今回はからの配列内にコンソールの入力値を格納
var myTable = new Dictionary<string, int>();
まずは空のdictionary型を生成して変数に代入
myTable.Add("Hokkaido", 1);
dictionary型の変数にkeyとvalueを追加
*List<string> keyList = new List<string>(myTable.Keys);
Dictionary型をListに変換する
uniTask.ToAsyncLazy();
AsyncLazyに変換
var GetCommentsresponse = GetCommentsClient.Execute(CommentsRequest);
コメント情報を取得
var JsonCommentsData = JsonSerializer.Deserialize<Root>(GetCommentsresponse.Content);
レスポンスをデシリアライズ
foreach (var comment in JsonCommentsData.comments)*{
メッセージを取得
Console.WriteLine(comment.message);
コンソールに出力
string appPath = App.GetAppPath();
パス取得
string cfgFilePath = System.IO.Path.Combine(appPath, ConfigFileName);
設定ファイルのフルパス組み立て
if (System.IO.File.Exists(cfgFilePath))*{
設定ファイル存在チェック
this.Exit += (_, _) => containerRegistry.GetContainer().Dispose();
Exit時に Service と Reader も Dispose される。
Console.WriteLine("bootstrap servers を入力してください（省略時 127.0.0.1）：");
コンソールからパラメーターを受け取る
using var cancelTokenSource = new CancellationTokenSource();
キャンセルトークンを生成する
{return new SampleMessageKey(Guid.NewGuid().ToString());}
キーを生成するメソッド
var factory = new SampleMessagePublisherFactory(publisherSetting, new SampleLogger());
パブリッシャーを生成する
var factory = new SampleMessageSubscriberFactory(subscriberSetting, new SampleLogger());
observable パターンでメッセージを監視する
OpenCvSharpHelper.ImShow("test", rtb);
testウィンドウにRenderTargetBitmapを表示する
var ev3 = new EV3("10.0.1.1", 6789);
EV3に接続 (EV3上で'lejos-server'が動作している前提)
{if (e.KeyData == Keys.Enter){}
キーボード押下イベント
pictureBox1.Invalidate();
画像貼り付け
{return System.Windows.Forms.Cursor.Position.Y; ;}
マウスのY座標取得
*int mouseY = GetMousePoint();
マウスの座標取得
IServiceProvider serviceProvider = services.BuildServiceProvider();
サービスプロバイダーを構築
ILogger<Program> logger = serviceProvider.GetRequiredService<ILogger<Program>>();
Loggerを取得
var telemetryClient = serviceProvider.GetRequiredService<TelemetryClient>();
テレメトリクライアントを取得
string example = "文字列";
string型では、文字列を格納できる。
int example = 64;
int型変数には、大体-21憶から21億までの整数が格納される。
float example = 3.2f;
小数を格納することができる。
int arrays [] = new int [] {1,2,3};
配列の宣言
Debug.Log(arrays.length);
配列の長さ(大きさ)をコンソールに表示する。
Debug.Log(arrays[0]);
配列の番号を指定してコンソールに表示する。
arrays[0] = 900;
配列の番号を指定して、内容を書き換える。
Debug.Log(arrays[0]);
配列の内容の表示
List <int> lists = new List <int> {1,2,3};
List型の宣言
lists.Count
listsの中の個数のカウントする
lists.add(800);
List型listsに「800」のデータを追加する
Debug.Log(lists[3]);
Listの内容の表示
enum GAMEMODE{Easy,Normal,Difficult}
enum型は、値の種類を先に宣言しておくことができる
const int example = 10;
constを付けると、その値は変更できなくなる。
var position = new Vector3(0, 1, 2);
varは型推論といって、勝手に型を補ってくれる。
transform.position = position;
座標をpositionに移動させる。
Debug.Log(new Vector3(0, 1, 2) + new Vector3(2, 3, 4));
Vector3同士の演算も可能
if (p.X >= shape.Bounds.Left && p.X <= shape.Bounds.Right && p.Y >= shape.Bounds.Top - 2 && p.Y <= shape.Bounds.Top + 2)
上辺との当たり判定
if (p.X >= shape.Bounds.Left && p.X <= shape.Bounds.Right&& p.Y >= shape.Bounds.Bottom - 2 && p.Y <= shape.Bounds.Bottom + 2)
下辺との当たり判定
if (p.Y >= shape.Bounds.Top && p.Y <= shape.Bounds.Bottom && p.X >= shape.Bounds.Left - 2 && p.X <= shape.Bounds.Left + 2)
左辺との当たり判定
if (p.Y >= shape.Bounds.Top && p.Y <= shape.Bounds.Bottom*&& p.X >= shape.Bounds.Right - 2 && p.X <= shape.Bounds.Right + 2)
右辺との当たり判定
if (shape.Bounds.Left <= p.X && p.X <= shape.Bounds.Right && shape.Bounds.Top <= p.Y && p.Y <= shape.Bounds.Bottom)
図形内部の当たり判定
var p = e.GetPosition(skElement);
マウスポインタの座標を取得
string yyyyMMdd = DateTime.Now.ToString("yyyyMMdd");
今日の日付文字列を取得
Media jsonMedia = new Media();
JSONオブジェクトを生成
var jsonStr = JsonConvert.SerializeObject(jsonRoot);
JSONを文字列変換
byte[] jsonData = System.Text.Encoding.UTF8.GetBytes(jsonStr);
バイト配列に変換
Dispose(false);
アンマネージリソースを明示的に解放
Dispose(true);
マネージリソースを明示的に解放
GC.SuppressFinalize(this);
ファイナライザを抑止
ISomeInterface<SubClass> sub = new SomeClass<BaseClass>();
SubClass型の型引数をもつのインターフェイスに、BaseClass型の型引数を持つ実体クラスを代入
string iconName = selectedItem.Tag?.ToString();
Tag取得
sender.Header = iconName;
ヘッダー設定
ContentFrame.Navigate(_pages[icon]);
対応するページ表示
ContentFrame.Navigate(_pages[NaviIcon.None]);
空ページ表示
if (Input.GetMouseButtonDown(0)){
マウス押した瞬間
if (Input.GetMouseButton(0)){
マウス押し続けている間
if (Input.GetMouseButtonUp(0)){
マウス離した瞬間
TrailRenderer paintObjectTrailRenderer = _tmpPaintObj.GetComponent<TrailRenderer>();
TrailRendererの頂点情報からメッシュを生成する
GameObject colliderContainer = new GameObject("Collider Container");
空のゲームオブジェクトを作成する
dynamic viewCount = py.ViewCount();
クラスを取得
Debug.Log(viewCount.count());
関数が返す文字列をコンソールに表示
FileVersionInfo ver = FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location);
バージョン情報取得＆表示
var tween = Undo.AddComponent<Tween>(targetTransform.gameObject);*tween.hideFlags = HideFlags.HideInInspector;
var rate = currentTime / _duration;
経過時間割合算出
offset = transform.position - target.transform.position;}
offsetに相対的な距離を代入
headers.Add("Authorization", authorization);
リクエストヘッダに署名を追加
HttpHelpers.InvokeHttpRequest(uri, "GET", headers, null);
リクエスト実行
{var request = youtubeService.CommentThreads.List("snippet");request.VideoId = videoId;request.Order = CommentThreadsResource.ListRequest.OrderEnum.Relevance;request.TextFormat = CommentThreadsResource.ListRequest.TextFormatEnum.PlainText;request.MaxResults = 100;request.PageToken = nextPageToken;var response = await request.ExecuteAsync();foreach (var item in response.Items){try{CommentInfo info = new CommentInfo();info.ParentNo = no;info.ChildNo = 0;info.Text = item.Snippet.TopLevelComment.Snippet.TextDisplay;info.LikeCount = (long)item.Snippet.TopLevelComment.Snippet.LikeCount;info.AuthorName = item.Snippet.TopLevelComment.Snippet.AuthorDisplayName;info.PublishedAt = JsonDateToDate(item.Snippet.TopLevelComment.Snippet.PublishedAt);info.ReplyCount = (long)item.Snippet.TotalReplyCount;string parentId = item.Snippet.TopLevelComment.Id;commentList.Add(info);if (item.Snippet.TotalReplyCount > 0)await GetReplyComment(commentList, youtubeService, parentId, no, 1, null);no++;}catch { }}if (response.NextPageToken != null)await GetComment(commentList, videoId, youtubeService, no, response.NextPageToken);}
コメント取得
{var request = youtubeService.Comments.List("snippet");request.TextFormat = CommentsResource.ListRequest.TextFormatEnum.PlainText;request.MaxResults = 50;request.ParentId = parentId;request.PageToken = nextPageToken;var response = await request.ExecuteAsync();foreach (var item in response.Items){try{CommentInfo info = new CommentInfo();info.ParentNo = no;info.ChildNo = cno;info.Text = item.Snippet.TextDisplay;info.LikeCount = (long)item.Snippet.LikeCount;info.AuthorName = item.Snippet.AuthorDisplayName;info.PublishedAt = JsonDateToDate(item.Snippet.PublishedAt);commentList.Add(info);cno++;}catch { }}if (response.NextPageToken != null)await GetReplyComment(commentList, youtubeService, parentId, no, cno, response.NextPageToken);}
返信コメント取得
{DateTime result;DateTime.TryParse(dt, out result);return result;}
JSON日付変換
if(tmpValue != n)
前回と値が変わっていたら
.Where(n => n > 100)
100より大きいものに絞り込む
if (new Uri(NavigationManager.Uri).AbsolutePath.Contains("_")){
URLの中に_があった場合
NavigationManager.NavigateTo(WebUtility.HtmlDecode(NavigationManager.Uri.Replace("_", "")));
_を外してHTMLデコードして投げる
Thread.Sleep(3000);
3秒待つ
if (v == Keys.J){
Jキーの入力の場合
await downloadInfo.Content.CopyToAsync(es);
Blobストレージから取得したファイルをコピー
if (!typeof(T).IsEnum)
TがEnumかどうかチェック
if (!Enum.IsDefined(typeof(T), value)) return null;
TryParseする前に、定義されている値かチェックする
animator.SetTrigger("Death");
Deathというアニメーションに移行
public override void Write()
overrideを使って定義し直す
SceneManager.LoadSceneAsync("ScreenBreak");
シーンを遷移する
public PrintService(ILabelPrinter printer)
ILabelPrinterを実装したクラスを受け取れるようにコンストラクタを追加
File.WriteAllText(@"write.json", j);
file書き込み
string j = sr.ReadToEnd();
ファイルの内容をすべて読み込みます。
TargetJson s = Newtonsoft.Json.JsonConvert.DeserializeObject<TargetJson>(j);
string型の文字列をもとにTargetJson型のオブジェクトにデシリアライズ
Console.WriteLine(s.ObS.Name);
オブジェクトのプロパティにアクセス
if (_auth.CurrentUser.UserId == null)
すでにユーザーが作られているのか確認
_auth.CurrentUser.LinkWithCredentialAsync(credential).ContinueWith(task => {if (task.IsCanceled){Debug.LogError("LinkWithCredentialAsync was canceled.");callback(false);return;}if (task.IsFaulted){Debug.LogError("LinkWithCredentialAsync encountered an error: " + task.Exception);callback(false);return;}_user = task.Result;Debug.Log($"Credentials successfully linked to Firebase user: {_user.DisplayName} ({_user.UserId})");callback(true);});
認証方法追加
this.styleSheets.Add(Resources.Load<StyleSheet>("GraphViewBackGround"));
ussファイルを読み込んでスタイルに追加
this.Insert(0, new GridBackground());
背景を一番後ろに追加
var worldMousePosition = _window.rootVisualElement.ChangeCoordinatesTo(_window.rootVisualElement.parent, context.screenMousePosition - _window.position.position);
ノードの生成位置をマウスの座標にする
JObject jObject = ReadJsonFile(Path.Combine(startupPath, "test.json"));
json読み込み
string tableName = jObject["category"].ToString();
category要素をテーブル名とする
executer.DynamicInsert(jObject, tableName);
Insertするデータと、テーブル名を指定する
XmlDocument doc = new XmlDocument();
XMLを読込んで、Jsonに変換
public record Person(string FirstName, string LastName);
Person定義
var module = await JSRuntime.InvokeAsync<IJSObjectReference>(
コンパニオン モジュールへデータを渡す
using (var writer = new SimpleCsvWriter<ProfileData>(directory, "test", list.ToArray())) {writer.Write();}
データ書き込み
Write();
書き込み
foreach (var profile in profiles) {Debug.Log(profile.Name + " = " + profile.Time);}
データ読み込み
var serializedObject = new SerializedObject(targetObject);
targetObjectをSirializedObjectに変換する
{_text = GUILayout.TextField(_text);if (scope.changed){Debug.Log(_text);}}
TextFieldが変更されたログが吐かれる
{var rect = GUILayoutUtility.GetLastRect();}
VerticalScopeのRectを取得する
EditorGUIUtility.FindTexture("PlayButton");
PlayButton用のテクスチャを取得する
GUI.backgroundColor = Color.red;
背景を赤色にする
GUI.SetNextControlName("Focus String");
コントロールする名前を設定する
GUI.FocusControl("Focus String");
指定した名前にフォーカスする
var focusString = GUI.GetNameOfFocusedControl()
フォーカスされている名前を取得する
System.Console.Writeline(hoge.A);
コンソールにAの値が出力される
System.Console.Writeline(hoge.B);
コンソールにBの値が出力される
await app.CreateDatabaseAsync();
DBへ接続する、存在しなければDBを作成する
await app.CreateContainerAsync();
コンテナへ接続する、存在しなければコンテナを作成する
this.container = await this.database.CreateContainerIfNotExistsAsync(containerName, "/partitionKey");
コンテナ名とパーティションキーを指定する。存在しなければ指定したコンテナ名とパーティションキーでコンテナが作成される
var sqlQueryText = "SELECT * FROM c ";
クエリ全件検索
QueryDefinition queryDefinition = new QueryDefinition(sqlQueryText);
クエリを実行する
item.Date = example(item);
データを整形する
var root = action.Tree.GetRoot(action.CancellationToken);
コード全体を取得する
string[] strArray = str.Split(',');
文字列型配列の宣言と初期化
int[] num_foreach = new int[strArray.Length];
整数型配列の宣言
int i = 0;
インデックス変数の宣言と初期化
foreach(string s in strArray) {*num_foreach[i] = int.Parse(s);
整数型配列の代入
foreach(int n in num_foreach) {*Console.WriteLine(n);
整数型配列の各要素の出力
int[] num_lambda = str.Split(',').Select(s => int.Parse(s)).ToArray();
文字列の分割からの整数型配列の宣言と初期化
foreach(int j in num_lambda) {*Console.WriteLine(j);
整数型配列の各要素の出力
string command = e.Command.Trim();
変数commandの前後の空白を取る
string[] com_arg =  Regex.Split(e.Command.Trim(),@"\s+");
コマンドと引数に分割
{IsSuccessful = true,IDToken = result.AccessToken};
トークンを取得
this.dgvList.Rows[0].Cells[0].Value
dgvListはDataGridViewコントロール
this.dgvList[0, 0].Value
セルの値を取得したり変更したりする
this.dgvList[0, 0].Style.ForeColor
セルの文字色を取得したり変更したりする
this.dgvList[0, 0].Style.BackColor
セルの背景色を取得したり変更したりする
this.dgvList[0, 0].ErrorText
セルのエラーアイコンとメッセージを取得したり変更したりする
this.dgvList[0, 0].Style.Font
セルのフォントを取得したり変更したりする
this.dgvList.Rows[0].DataBoundItem
行と紐付いているバインドオブジェクトを取得します。
this.sbList.Clear();
DataGridViewの行をすべてクリアする
this.dgvList.AutoGenerateColumns = false;
親リストにデータソースを追加したとき勝手に列が追加されないようにする
this.dgvListChild.AutoGenerateColumns = false;
子リストにデータソースを追加したとき勝手に列が追加されないようにする
this.dgvList.DataSource = this.sbList;
親リストのデータソースを設定する
this.dgvListChild.DataSource = rowBound.ChildList;
子リストのデータソースをセットする。
string path = AssetDatabase.GetAssetPath(DirectoryAsset);
DefaultAssetのパスを取得する
bool isDirectory = File.GetAttributes(path).HasFlag(FileAttributes.Directory);
取得したパスがディレクトリのパスの時だけ、パスを返す
{await DisplayAlert("Error", result.Exception.Message, "Close");});
エラーが起きてたら何か処理
Color color_before = mask.GetComponent<RawImage>().color;*color_before.a = 0.0f;
透明度を最大にする
mask.GetComponent<RawImage>().enabled = false;
非活性にし画面を操作できるようにする
{for (int i = 0; i < 100; i++){Color color = mask.GetComponent<RawImage>().color;color.a += 0.01f;mask.GetComponent<RawImage>().color = color;if (i == 99){yield break;}else{yield return null;}}}
フェードアウト処理
renderingShader_Material.SetPass(0);
レンダリングを開始
var points = ObservationPoint.LoadFromMpk("ShindoObsPoints.mpk.lz4", true);
出力ディレクトリにコピーした観測点情報を読み込む
var targetTime = DateTime.Now.AddMinutes(-1);
現時刻から1分前の時刻を取得する
var result = await webApi.ParseIntensityFromParameterAsync(points, targetTime);
もとにする観測点情報と取得したい時間を添えて震度を取得する
Console.WriteLine(point.ObservationPoint.Region + " " + point.ObservationPoint.Name + " " + point.AnalysisResult);
地域名 観測点名 震度 の形で出力する
WebApiUrlGenerator.Generate(WebApiUrlType.RealtimeImg, targetTime, RealtimeDataType.Pga, true);
地中PGA画像データへのURLを作成
WebApiUrlGenerator.Generate(WebApiUrlType.RealtimeImg, targetTime, RealtimeDataType.Response_1Hz);
地上1.0Hz応答速度画像データへのURLを作成
WebApiUrlGenerator.Generate(WebApiUrlType.PSWave, targetTime);
P/S波画像データへのURLを作成
WebApiUrlGenerator.Generate(WebApiUrlType.EewJson, targetTime);
緊急地震速報情報のURLを作成
MainWindow.mw.AddLog("OnActivated()実行しました");
ログ表示
App.Current.Windows[0].WindowState = WindowState.Normal;
最小化してたら通常の大きさに戻す
IntPtr hDC = g.GetHdc();
Graphicsのデバイスコンテキストを取得
NativeMethods.BitBlt(hDC, 0, 0, bmp.Width, bmp.Height, winDC, 0, 0, SRCCOPY);
Bitmapに画像をコピーする
tmr.Stop();
停止させる
g.CopyFromScreen(new Point(curScreen.Bounds.Left, curScreen.Bounds.Top), new Point(0, 0), bmp.Size);
画面全体をコピーする
{_backButton.transform.gameObject.SetActive(true);_multiPlayButton.transform.gameObject.SetActive(false);//接続を試みる_cancellationTokenSource = new CancellationTokenSource();CancellationToken token = _cancellationTokenSource.Token;TryConnectAsync(token).Forget();});
サーバーの検索＆接続開始
_cancellationTokenSource = new CancellationTokenSource();
接続を試みる
StopDiscovery();
サーバーから抜ける
_cancellationTokenSource.Cancel();
非同期処理止める
SendHostReadyData sendData = new SendHostReadyData() {IsHostReady = true};
各クライアントにフラグデータを送る
_isHostReady = receivedData.IsHostReady;
ローカルのフラグに反映
StartDiscovery();
サーバーの検索開始
while (!_networkManager.isNetworkActive)
サーバーに接続するまでループ
if (_discoveredServer.uri != null)
サーバー発見した場合
_networkManager.StartClient(_discoveredServer.uri);
クライアントとして接続開始
_connectionStateText.text =CONNECTION_STATUS_CLIENT_WAITING;
接続ステータスの文言変更
await UniTask.WaitUntil(() => _isHostReady, cancellationToken: token);
ホストの開始フラグを待つ
_connectionStateText.text = CONNECTION_STATUS_SUCCESS;
接続ステータスの文言変更
if (tryCount > CONNECT_TRY_COUNT)
任意の回数以上接続に試みて失敗した場合は自身がホストになる
_networkManager.StartHost();
サーバーのホストになる
_playButton.gameObject.SetActive(true);
プレイボタン表示
_networkManager.ServerChangeScene(_gameSceneName);
シーン遷移
SendHostReadyData sendData = new SendHostReadyData() {IsHostReady = true};
各クライアントにフラグデータを送る
NetworkClient.RegisterHandler<SendHostReadyData>(ReceivedReadyInfo);
データ受信の準備
if (_titleScene.Contains(SceneManager.GetActiveScene().name))
タイトルシーンの場合
SendPlayerCountData sendData = new SendPlayerCountData() {PlayerCount = NetworkServer.connections.Count};
接続中の人数表記を変える
if (_mainScene.Contains(SceneManager.GetActiveScene().name))
メインシーンの場合
GameObject player = Instantiate(playerPrefab);
プレイヤー生成
NetworkServer.AddPlayerForConnection(conn, player);
今立ち上げているサーバーにプレイヤーを追加登録
FacialData newFacialData = FacialData.GetFacialData(facialExpressionName);
表情名から対応したFacialDataを取得する
Vector2 force = new Vector2(0.5f, 10f);*rb.AddForce(force, ForceMode2D.Impulse);
加える力の大きさ
isBounce = false;
接触していない時は跳ねないように
GL.Enable(EnableCap.DepthTest);
Depthバッファの有効化
Rotate++;
回転角度を更新する。
GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
画面をクリアする。
Shader.IdentityMatrix();
図形を描画する。
var resizedImageFile = await imageFile.RequestImageFileAsync(format, 100, 100);*var buffer = new byte[resizedImageFile.Size];
100*100の画像にリサイズ
$"data:{format};base64,{Convert.ToBase64String(buffer)}";
ブラウザ上に表示するためにDataUrlに変換
private DummyPersonService _service = new DummyPersonService();
REST APIなどからデータを取得するクラス
this.transform.position += this.transform.forward * inputMove.Vertical *moveSpeed* Time.deltaTime;
左スティックでの縦移動
this.transform.position += this.transform.right * inputMove.Horizontal * moveSpeed*Time.deltaTime;
左スティックでの横移動
transform.Rotate(new Vector3(0,rotateSpeed*inputRotate.Horizontal,0));
右スティックでの回転
if (cell.HasFormula){
計算式があるかどうか判定します。
Object value = cell.FormulaValue;
結果の値を取得します。
cell.Clear(ExcelClearOptions.ClearContent);
セルのコンテンツを削除します。
cell.Value2 = value;
値をセルに追加します。
Workbook workbook = new Workbook();
Workbookを作成します。
int currentRow = 1;
currentRow、currentFormulaを初期化します。
sheet.SetColumnWidth(1, 32);
1、2列の幅をセットします。
sheet.Range[currentRow, 1].Value = "テストデータ：";
データを追加します。
currentRow += 2;
テキストを追加します。
currentFormula = "=1/2+3*4";
演算を行います。
workbook.SaveToFile("Excel数式.xlsx", FileFormat.Version2013);
workbookの保存
Workbook workbook = new Workbook();
Workbook作成します。
workbook.LoadFromFile("Excel数式.xlsx");
Excelをロードします。
Worksheet sheet = workbook.Worksheets[0];
シートを取得します。
foreach (var cell in sheet.Range["B1:B13"])*{
[B1：B13]のセルをループします。
if (cell.HasFormula){
数式があるかどうか判定します。
string certainCell = String.Format("Cell[{0},{1}]", cell.Row, cell.Column);
数式のあるセルを出力します。
DisplayWizard<ViewCreateWizard>("View Create Wizard");
作成ウィザードを表示する。
File.WriteAllText(path, builder.ToString());
文字列を指定のパスに書き出す。
PrefabUtility.SaveAsPrefabAsset(gameObject, prefabPath);
指定したゲームオブジェクトをプレハブ化する。
GameObject.DestroyImmediate(gameObject);
プレハブ化したゲームオブジェクトをHierarchyから破棄する。
var assembly = Assembly.Load("Assembly-CSharp");
Assembly-CSharpアセンブリからクラスを取得する。
string className = $"{creatingViewName}ViewController";
作成情報をEditorPrefsから読み込む。
EditorPrefs.DeleteKey("CreatingViewName");
作成が済んだので、EditorPrefsから削除する。
string className = $"{viewName}ViewController";
作成情報をEditorPrefsへ保存しておく。
public void Attack()
アクセス修飾子 戻り値の型 関数名(引数の型 引数名)
int intNum = 2;
int(整数)型の変数宣言
float floatNum = 1.234f;
float(単精度浮動小数点)型の変数宣言
double doubleNum = 1.234;
double(倍精度浮動小数点)型の変数宣言
bool boolVal = true;
bool(論理)型の変数宣言
char c = 'a';
char(文字)型の変数宣言
DateTime date;
DateTime(日付)型の変数宣言
String str = "hoge";
String(文字列)型の変数宣言
int[] array;
配列型の変数宣言
int num4 = 1 / 2;
小数点以下切り捨て
int num6 = 10 % 3;
余りの数の求め方
num6 += 1;
複合代入演算子
string[] array;
string型配列arrayの宣言
int array = new int[3];
配列の長さが3のint型配列arrayの宣言
array[0] = 5;
配列の0番目に値を代入
int array2 = new int[] { 0, 5, 10 };
int型配列arrayの宣言し初期化
{new[] {1, 2, 3},new[] {4, 5, 6, 7}};
ジャグ配列での初期化
{{1, 1, 1},{2, 2, 2},{3, 3, 3}};
四角配列での初期化
continue;
continueを書くとここでループ処理が中断され、変数の更新後ループ処理の頭から再度開始します
int[] array = { 0, 5, 10 };
arrayの中身は 0, 15, 20となる
foreach (int num in array){
foreach(変数宣言 in ループ処理したい配列)
*AssetDatabase.Refresh();
Asset作成後、反映させるために必要なメソッド
{{ "name"   ,"John"},{ "age"   ,"12"},{ "city"  ,"Tokyo"},};
個人データを表すpersonのDictionaryを作成
group.Add(1, person1);
groupに個人データpersonを追加する
var jsonstr = JsonSerializer.Serialize(group);
Dictionaryをシリアライズ
Console.WriteLine("{0}", jsonstr);
コンソールに出力
var currentSceneGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();
現在のHierarchyのRootにあるGameObjectの一覧
Document doc = new Document();
Document objectを作成します。
Section sec = doc.AddSection();
Section対象を追加します。
Paragraph p = sec.AddParagraph();
sectionに段落を追加します。
doc.SaveToFile("記号を追加.docx");
保存します。
doc.LoadFromFile("特殊記号.docx");
ファイルをロードします。
TextRange tr = doc.FindString("\u002A", true, true).GetAsOneRange();
FindStringメソッドでメールの記号を探します。
doc.SaveToFile("test.docx", FileFormat.Docx2013);
保存します。
key.SetValue(null, tbValue.Text);
書き込み実施
Console.WriteLine($"{responseContent}");
Responseの表示
JObject jsonObject = JObject.Parse(jsonString);
全体をJObject型で受け取る。
JObject emojis = (JObject)jsonObject["emoji"];
"emoji"のValueをJObject型で受け取る。
System.Diagnostics.Process.Start(e.Uri.AbsoluteUri);
URLを開く
if (IsAnyNullOrEmpties(input, regPattern)){
未入力がないかチェック
MatchCollection matches = reg.Matches(input);
マッチング実行
OutTxt.Text = sb.ToString();
結果を設定
if (ROptIgnoreCase.IsChecked == true){
大文字小文字の区別をしない
await
非同期処理
Bitmap bitmap = new Bitmap(Screen.PrimaryScreen.Bounds.Width,
Bitmapの作成
Graphics g = Graphics.FromImage(bitmap);
Graphicsの作成
g.CopyFromScreen(new Point(0, 0), new Point(0, 0), bmp.Size);
画面全体をコピーする
g.Dispose();
解放
var folder = Directory.GetCurrentDirectory();
取得したキャプチャ画像をファイルとして保存
{BitmapDecoder decoder = await BitmapDecoder.CreateAsync(stream);softwareBitmap = await decoder.GetSoftwareBitmapAsync();}
保存した画像をSoftwareBitmap形式で読み込み
File.Delete(folder + "\\" + imageName);
保存した画像ファイルの削除
return softwareBitmap;
SoftwareBitmap形式の画像を返す
Document document = new Document();
Document objectを作成します。
document.LoadFromFile("Input.docx");
Wordファイルをロードします。
document.Sections[0].Paragraphs.RemoveAt(0);
一つ目の段落を削除します。
Presentation ppt = new Presentation();
PPTを作成します。
ppt.DocumentProperty.Title = "パンダについて";
プロパティを設定します。
ppt.SaveToFile("プロパティ.pptx", FileFormat.Pptx2013);
保存します。
if(TimeoutIOUtils.DirectoryExists(dir)){
ディレクトリの有無確認
if(TimeoutIOUtils.FileExists(file)){
ファイルの有無確認
Player.player.playerHp--;
クラス名.変数名.変数で、Playerクラスの変数を取得できる
if (targetDirectory[targetDirectory.Length - 1] != Path.DirectorySeparatorChar)*targetDirectory = targetDirectory + Path.DirectorySeparatorChar;
保存先のディレクトリ名の末尾に"\"をつける
Presentation ppt = new Presentation();
PowerPointを作成します。
ppt.SlideSize.Type = SlideSizeType.Screen16x9;
スライドのサイズと方向を配置します。
string ImageFile ="picture.jpg";
スライドの背景画像を挿入します。
IAutoShape textboxShape = ppt.Slides[0].Shapes.AppendShape(ShapeType.Rectangle, new RectangleF(50, 70, 600, 100));
図形を初めのスライドに追加します。
textboxShape.TextFrame.Paragraphs.Clear();
図形での段落を削除します。
sheet.PageSetup.Order = OrderType.DownThenOver;
印刷の順を設定します。
PrintDialog dialog = new PrintDialog();
PrintDialogを設定します。
dialog.PrinterSettings.Duplex = Duplex.Simplex;
片面印刷します。
dialog.PrinterSettings.FromPage = 0;
印刷範囲を設定します。
dialog.PrinterSettings.Copies = 5;
部数を設定します。
dialog.PrinterSettings.PrinterName = "HP LasterJet P1007";
プリンターの名前を設定します。
workbook.PrintDialog = dialog;
印刷します。
var relativePosition = Display.RelativeMouseAt(position);
画面ごとのスクリーン座標に変換
var displayIndex = (int)relativePosition.z;
z座標にディスプレイ番号がセットされる
var camera = cameras[displayIndex];
該当する画面のカメラでワールド座標に変換
Cef.Initialize(settings, false, new BrowserProcessHandler());
CefSharpを初期化する
this.webViewContainer.Controls.Add(WebBrowser);
CefSharpのWebViewを作成する。
WebBrowser = new ChromiumWebBrowser("https:www.google.co.jp");
コントロールを追加する。
WebBrowser.BrowserSettings.Javascript = CefState.Enabled;
WebViewの各種オプションを設定する
WebBrowser.KeyboardHandler = new Handlers.KeyboardHandler();
CefSharpの各種ハンドラを設定する
WebBrowser.JavascriptObjectRepository.Register("Test", new SimpleBrowser.Util.Test(), true, null);
独自オブジェクトを公開する
SimpleBrowserFrame parent = SimpleBrowserFrame.getMainFrame(browser);
親のbrowserからフォームを取得する
SimpleBrowserFrame newWindows = new SimpleBrowserFrame(false);
WebView無しの空のコンテナフォームを作成する。
Rectangle rect = newWindows.ClientRectangle;
WebViewのコンテナの情報を設定する。
newWindows.Show();
フォームを表示する
SimpleBrowserFrame parent = SimpleBrowserFrame.getMainFrame(browser);
新しく作成されたbrowserからコンテナのフォームを取得する
WebBrowser.LifeSpanHandler = new Handlers.LifeSpanHandler();
LifeSpanHandlerをWebViewに設定する
IntPtr hWnd = Browser.GetHost().GetWindowHandle();
WebViewのウィンドウハンドルを取得する
SetWindowPos(hWnd, HWND_TOP, 0, 0, webViewContainer.Width, webViewContainer.Height, SetWindowPosFlags.SWP_NOMOVE | SetWindowPosFlags.SWP_NOZORDER);
WebViewのサイズを変更する。
if(notesTime =< 0)
判定位置に来たら
var slideList = new List<(string, string)>();
ノートと画像保存場所のリスト
var ppt = app.Presentations.Open(SLIDE_PATH, MsoTriState.msoTrue, MsoTriState.msoFalse,
スライドを開く
if (ppt.Slides[i].SlideShowTransition.Hidden == MsoTriState.msoTrue) continue;
非表示スライドは無視
var file = FILE_PATH + $"/slide{i:0000}.jpg";
JPEGとして保存
WebView.Size = this.Size;
WebView2のサイズをフォームのサイズに合わせる
WebView.NavigationCompleted += WebView_NavigationCompleted;
WebView2のロード完了時のイベント
WebView.CoreWebView2.AddHostObjectToScript("class", CsClass);
JavaScriptからC#のメソッドが実行できる様に仕込む
string strBearerTokenCredentials = apiKey + ":" + apiSecretKey;
API keyとAPI secret keyをコロンでつなぐ
Transform objTransform= hogeObject.transform;
オブジェクトのtransform情報を取得
Vector3 pos = objTransform.position;
その中からposition情報を取得
pos.y += 0.001f;
上方向成分を加算
objTransform.position = pos;
座標を変更
{StreamReader sr = new StreamReader(filePath, Encoding.GetEncoding(encodingName));string allLine = sr.ReadToEnd();sr.Close();return allLine;}
ファイル読み込み
paragraph.ChildObjects.Insert(i + 1, footnote);
脚注を挿入します。
TextRange text = footnote.TextBody.AddParagraph().AppendText("夏時間。カナダ、オーストラリアでも用いる）とは1年のうち夏を中心とする時期に太陽が出ている時間帯を有効に利用する目的で、標準時を1時間進める制度またはその進められた時刻のこと。ただし、オーストラリアのロード・ハウ島では夏時間と通常の時間の差が30分であるなど一律ではない。");
脚注の内容を追加し、文字のフォントなどを設定します。
Paragraph paragraph2 = document.Sections[0].Paragraphs[2];
三つ目の段落を取得します。
Footnote endnote = paragraph2.AppendFootnote(FootnoteType.Endnote);
文末脚注を挿入し、スタイルを設定します。
document.SaveToFile("脚注.docx", FileFormat.Docx2010);
保存します。
List<GameObject> gameObjects = GameObject.FindGameObjectsWithTag("Player").ToList();
PlayerタグをつけたGameObjectを配列で取得しリストへ変換
gameObjects.ForEach(gameObj => print(gameObj.transform.name));*}
取得したGameObjectの名前をコンソールに出力
private readonly Subject<Unit> someSubject = new Subject<Unit>();
Subjectを生成。
var bitcoinPrivateKey = new BitcoinSecret("cPoEcLELGdXjHK5HB4tFxWf11UabeBJX4muBZSTZoavL8ZbDpBGa");
自アドレスの秘密鍵(WIF形式)からBitcoinSecretを取得する
var client = new QBitNinjaClient(network);
送金するためのトランザクションの左側(TxIn)をつくる
var destinationAddress = BitcoinAddress.Create("mhk39wXeb1ZsDegtPb6xnrUquctp6Rusko", network);
送金するためのトランザクションの右側(TxOut)をつくる
var message = "From Qiita, Japan, @ysskjck.";
メッセージ編集
transaction.Inputs[0].ScriptSig = bitcoinPrivateKey.ScriptPubKey;
これから送金するためのトランザクションに署名する
var broadcastResponse = client.Broadcast(transaction).Result;
送金確定
string tmpFile = @"..\勤務表(XXXX)_yyyyMMdd.xlsm";
Excelへの書き込み
File.Copy(tmpFile, outFile);
テンプレートから新規Excelを作成
IWebDriver driver = new ChromeDriver(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location));
Webドライバーのインスタンス化
driver.Navigate().GoToUrl(loginPage);
ログインページへアクセス
driver.FindElement(By.Name("{ログインボタンの要素id}")).Click();
ログインボタンのクリック
driver.Navigate().GoToUrl(targetPage);
勤務時間取得用のページへ遷移し、HTML取得
var appType = Type.GetTypeFromProgID("Excel.Application");
ProgIDからOfficeアプリのCOMのTypeを取得する。
app = Activator.CreateInstance(appType);
COMオブジェクトを作成し、対象アプリのプロセス名を検索する。
app.Quit();
アプリ停止＆解放
GC.Collect();
GCを強制
var appType = Type.GetTypeFromProgID("Excel.Application");
ProgIDからOfficeアプリのCOMのTypeを取得する。
using (var reader = new StreamReader("user.csv"))
StreamReaderにCSVのパスを渡す
privateObject.SetFieldOrProperty("_privateMember", 100);
メンバ変数値変更
var ret = privateObject.Invoke("PrivateMethod", 100, 200);
"PrivateMethod"呼び出し
戻り値の型でくるんでawait
*privateType.SetStaticFieldOrProperty("_privateStaticMember", "ヨシッ！");
static変数"_privateStaticMember"の値を変更
*var ret = privateType.InvokeStatic("GetPrivateStaticMember");
staticメソッド"GetPrivateStaticMember"を呼び出す
*string[][] arr = { new string[3] { "あ", "い", "う" },
ジャグ配列の初期化
Array.Resize(ref arr, 10);
要素数を10に変更する
var sb = FindResource("MyRoundingAnimation") as Storyboard;
StoryBoardを検索
Screen ownerScreen = Screen.FromControl(this);
所属している画面を取得
if ( preferedSize.Width <= rect.Width && preferedSize.Width <= rect.Height ) {ClientSize = preferedSize;}
画面に収まるときだけリサイズする
capture = new VideoCapture(0);
カメラ画像取得用のVideoCapture作成
Mat matframe = new Mat(HEIGHT, WIDTH, MatType.CV_8UC3);
Mat作成
bmp = new Bitmap(matframe.Cols, matframe.Rows, (int)matframe.Step(), System.Drawing.Imaging.PixelFormat.Format24bppRgb, matframe.Data);
Bitmap作成
ImageEncodingParam encodingParam = new ImageEncodingParam(ImwriteFlags.PngBilevel, 0);
エンコード
mat = Cv2.ImDecode(buffer, ImreadModes.Color);
デコードして保存する
Cv2.ImWrite(path, mat);
画像の保存
if (vrmModel == null)
VRMモデルが読み込まれていなかったら
vrmModel = ImportVRM(VrmPath);
VRMモデル読み込み
var model = GameObject.Instantiate(vrmModel);
VRMモデルを複製
model.transform.SetParent(__instance.transform, false);alreadyVrmSetList.Add(__instance);
親を既存モデルにセット
foreach (var smr in __instance.GetComponentsInChildren<SkinnedMeshRenderer>())*{
既存モデルのVRMモデル以外のSkinnedMeshRendererを非表示
e.Cancel = true;
終了処理をキャンセル
PdfDocument document = new PdfDocument()
PDFオブジェクト作成
PdfDocument inputDocument = PdfReader.Open(file, PdfDocumentOpenMode.Import)
PdfDocumentOpenMode.Import：PDFを読み取りモードで開く。結合するPDFオブジェクトを作成
inputDocument.Close();
結合するPDFを閉じる
document.Save(selectedPath);
PDF保存
document.Close();
PDFを閉じる
Array.Copy(b.Data, 0, Data, Size, b.Size);
bの有効データを、thisの有効データの末尾(位置=Size)以降にコピーする
{sam.x = 100;}
値型の参照渡し
return input?.ToUpper();
引数で受け取った文字列を大文字にして返す
context.Logger.LogLine($"Arg : [{input}]");
受け取った引数をログに出力
for (int i = 0; i < 3; i++){
for (初期化式; ループ条件式; 更新式)
foreach (int even in arr)
foreach (一時変数宣言 in コレクション)
Invalidate();
コントロールの再描画要求
(array[j], array[j - 1]) = (array[j - 1], array[j]);
System.ValueTapleの機能による要素の交換
str += new string( Enumerable.Repeat( "■", n ).SelectMany( x => x ).ToArray() )
現在のソートの状態を数値の並び→横棒グラフ状の文字列に変換する。
Animator.DisplaySingleFrame( str );
アニメの一コマ分として画面に表示する
Dictionary TagValues = new Dictionary();
Dictionary オブジェクトを作成
Presentation presentation = new Presentation();
PowerPointファイルをロードします。
ReplaceTags(presentation.Slides[0], TagValues);
ReplaceTagsメソッドで文字を置換します。
headers.Add("Authorization", authorization);
リクエストヘッダに署名を追加
HttpHelpers.InvokeHttpRequest(uri, "GET", headers, null);
リクエスト実行
return x + y;
xとyの和を返す
ToEnemyVec = ToEnemyVec.normalized;
ベクトルの正規化
Loaded_Command.Subscribe(()=> System.Diagnostics.Debug.WriteLine("Loaded !!"));
ボタンが押された時の動作を定義する
spl2.SplitterDistance = 200;
分割線の位置を指定[pixel]
await UniTask.WaitForEndOfFrame(ct);
任意のフレームの描画処理が終わるまで待つ
var rt = new RenderTexture(_camera.pixelWidth, _camera.pixelHeight, 24);
Cameraの描画領域をRenderTextureとして取り出す
NativeGallery.SaveImageToGallery(screenShot, "GalleryTest", $"{date}.png" );
CameraのRenderTextureを元に画像を作成して保存
while ( !www.isDone ) yield return new WaitForSeconds(0.25f);*audio.clip = www.GetAudioClip(false, false);
インポートが完了するまで待つ
System.IO.File.Delete(path);
ファイルを削除
Console.WriteLine(++a);
a = a + 1してからaを表示
var credentials = SdkContext.AzureCredentialsFactory
credential の作成
var azure = Microsoft.Azure.Management.Fluent.Azure
Azure オブジェクトの作成
var siteConfig = (await azure.WebApps.Inner.GetConfigurationWithHttpMessagesAsync(resourceGroupName, functionAppName)).Body;
WebApps の config を取得
var corsList = siteConfig.Cors.AllowedOrigins;
config から CORS の一覧を取得
var additionalDomain = "{登録するドメイン}";
COSR の一覧に登録するドメインを追加
var newSiteConfig = new SiteConfigResourceInner() { Cors = new CorsSettings() };
CORS の一覧を設定
await azure.WebApps.Inner.CreateOrUpdateConfigurationWithHttpMessagesAsync(resourceGroupName, functionAppName, newSiteConfig);
WebApps の config を更新
headers.Add("Authorization", authorization);
リクエストヘッダに署名を追加
HttpHelpers.InvokeHttpRequest(uri, "GET", headers, null);
リクエスト実行
string filePath  = @".\JUFx_KMJ\JUF1_KMJ.csv";
ファイルの読み込み
string[] cols = reader.ReadLine().Split(',');
読み込んだ文字列をカンマ区切りで配列に格納
*string[] cols = reader2.ReadLine().Split(',');
読み込んだ文字列をカンマ区切りで配列に格納
var codePoint = Convert.ToInt32(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")],16);
サロゲートペア計算（ライブラリが見つからなかった）
public int numAProperty
公開プロパティにする
[DllImport("hoge.dll")]
C++関数定義
if (time >= 0.5f)
timeが0.5秒経ったら
[DllImport("./foo.dll", EntryPoint = "foo")]
ネイティブ関数の宣言
var str = Enumerable.Repeat("w", count).Aggregate((a, b) => $"{a}{b}");
count 個 'w' を含む文字列の生成
var f = (delegate* unmanaged[Cdecl]<int, nint>)(delegate*<int, nint>)&Generate;
関数ポインタの作成
var str = Enumerable.Repeat("w", count).Aggregate((a, b) => $"{a}{b}");
count 個 'w' を含む文字列の生成
var f = (delegate*<int, string>)&Generate;
関数ポインタの作成
return this.Configuration.GetSection("Admins").Get<string[]>().Contains(oid?.Value);
appSettings.json の Admins にオブジェクト ID が含まれているか評価
{position_manager pm = new position_manager();pm.set_koma_select_position(this.gameObject.transform.parent.gameObject.transform.parent.gameObject , 4, 8);this.gameObject.transform.parent.gameObject.SetActive(false);Debug.LogError("You Click Area");}
親オブジェクトの駒を移動する
GameObject[] tags = GameObject.FindGameObjectsWithTag(tag);
タグのついたオブジェクトをすべて格納
{Image image = this.GetComponent<Image>();image.color = new Color(1.0f, 0.1401087f, 0.0f, 0.3f);}
imageの色を濃くする
Image image = this.GetComponent<Image>();
Imageの取得
{Image image = this.GetComponent<Image>();image.color = new Color(1.0f, 0.1401087f, 0.0f, 0.8f);}
imageの色を薄くする
{position_manager pm = new position_manager();pm.set_koma_select_position(this.gameObject.transform.parent.gameObject.transform.parent.gameObject , 4, 8);this.gameObject.transform.parent.gameObject.SetActive(false);Debug.LogError("You Click Area");}
親オブジェクトの駒を移動する
var id = Shader.PropertyToID("_OutlineTex");
テクスチャ作成
commandBuffer.ClearRenderTarget(false, true, Color.clear);
メッシュの描画
commandBuffer.Blit(id, BuiltinRenderTextureType.CameraTarget, outlineMaterial);
アウトラインを抽出して合成
line.Draw(settings);
線の描画
private void InitMaterial() {if (!lineMaterial) {lineMaterial = new Material(Shader.Find("Hidden/Internal-Colored"));lineMaterial.hideFlags = HideFlags.HideAndDontSave;lineMaterial.SetInt(SrcBlend, (int) BlendMode.SrcAlpha);lineMaterial.SetInt(DstBlend, (int) BlendMode.OneMinusSrcAlpha);lineMaterial.SetInt(Cull, (int) CullMode.Off);lineMaterial.SetInt(ZWrite, 0);}}
描画するために使うマテリアルの初期化
if (!enabled || settings.paths.Length <= 0 || settings.paths.Any(t => t == null)) return;
座標が入っていなかったら描画しない
if (_settings.Equals(settings) && _paths.SequenceEqual(vecPaths)) {*DotVertexes(currentPaths.ToArray());
設定が変更されていなかったら計算しない
for (int index = 0; index < _paths.Count - 1; index++) {v0 = _paths[index];v1 = _paths[index + 1];
解像度に対する幅を求める
o = (new Vector3(v1.y, v0.x, 0.0f) - new Vector3(v0.y, v1.x, 0.0f)).normalized;
２点の単位ベクトルを求める
void DrawLine2D(Vector3 v0, Vector3 v1, Vector3 o) {Vector3 n = o * relativeWidth;Vector3[] vertex = new[] {new Vector3(v0.x - n.x, v0.y - n.y, 0.0f),new Vector3(v0.x + n.x, v0.y + n.y, 0.0f),new Vector3(v1.x + n.x, v1.y + n.y, 0.0f),new Vector3(v1.x - n.x, v1.y - n.y, 0.0f),};DotVertexes(vertex);foreach (Vector3 v in vertex) {currentPaths.Add(v);}}
２点に線を引く関数
void DrawMark2D(Vector3 v0, Vector3 v1, Vector3 o) {Vector3 markLength, _v0, _v1, _o;Vector3 _unitVec = (v1 - v0) / settings.intervalCount;List<Vector3> _pos = new List<Vector3>();for (int i = 0; i < settings.intervalCount + 1; i++) {_pos.Add(v0 + _unitVec * i);}for (int i = 0; i < _pos.Count; i++) {Vector3 vec = _pos[i];float length = (i == 0 || i == _pos.Count - 1 ? settings.edgeMarkLength : settings.insideMarkLength);markLength = o * length;_v0 = new Vector3(vec.x - markLength.x, vec.y - markLength.y, 0.0f);_v1 = new Vector3(vec.x + markLength.x, vec.y + markLength.y, 0.0f);_o = (new Vector3(_v1.y, _v0.x, 0.0f) - new Vector3(_v0.y, _v1.x, 0.0f)).normalized;DrawLine2D(_v0, _v1, _o);}}
2点にメモリをつける関数
void DotVertexes(Vector3[] pos) {foreach (Vector3 v in pos) {GL.Vertex3(v.x, v.y, v.z);}}
与えられた座標配列に頂点を打つ関数
void DrawLine2D(Vector3 v0, Vector3 v1, Vector3 o) {Vector3 n = o * relativeWidth;Vector3[] vertex = new[] {new Vector3(v0.x - n.x, v0.y - n.y, 0.0f),new Vector3(v0.x + n.x, v0.y + n.y, 0.0f),new Vector3(v1.x + n.x, v1.y + n.y, 0.0f),new Vector3(v1.x - n.x, v1.y - n.y, 0.0f),};DotVertexes(vertex);}
垂直なベクトルを求め、正規化する
Vector3 n = o * relativeWidth;
単位ベクトルに設定された幅をかける
Vector3[] vertex = new[] {new Vector3(v0.x - n.x, v0.y - n.y, 0.0f),new Vector3(v0.x + n.x, v0.y + n.y, 0.0f),new Vector3(v1.x + n.x, v1.y + n.y, 0.0f),new Vector3(v1.x - n.x, v1.y - n.y, 0.0f),};
オフセットを足して、頂点座標を求める
other.GetComponent<Move>().StartCor(targetPos);
StartCor()を使ってMoveクラスのMoveToを開始
HttpPostedFile file = HttpContext.Current.Request.Files["userfile"];
アップロードされたファイルを取得
container.CreateIfNotExists();
もしコンテナが存在しなかった場合は作成
CloudBlockBlob blob = container.GetBlockBlobReference($"{file.FileName}");
一意となるファイル名でblobに対しての参照を取得する
blob.UploadFromStream(fileStream);
ファイルをアップロードする
string filename = HttpContext.Current.Request["filename"];
ファイルをダウンロードする
{for (int i = 0; i < data.elems.Count; i++){Node[] nodes = new Node[2];nodes[0].No = data.elems[i].NodeNo1;nodes[0].Point = data.nodes[nodes[0].No - 1].Point;nodes[1].No = data.elems[i].NodeNo2;nodes[1].Point = data.nodes[nodes[1].No - 1].Point;int materialNo = data.elems[i].MaterialNo - 1;double area = data.materials[materialNo].Area;double young = data.materials[materialNo].Young;elems.Add(new BeamElement(nodes, area, young));}}
要素の形式を変換して格納する
{if (Rest == null){return null;}if (NodeNum <= 0 || BeamElems == null || Rest.Count != NodeNum){return null;}DenseMatrix kMatrix = DenseMatrix.Create(NodeNum, NodeNum, 0.0); for (int i = 0; i < BeamElems.Count; i++){Console.WriteLine("要素" + (i + 1).ToString());DenseMatrix keMatrix = BeamElems[i].makeKeMatrix();for (int r = 0; r < 2; r++){int rt = BeamElems[i].Nodes[r].No - 1;for (int c = 0; c < 2; c++){int ct = BeamElems[i].Nodes[c].No - 1;kMatrix[rt, ct] += keMatrix[r, c];}}}Console.WriteLine("Kマトリックス");Console.WriteLine(kMatrix); ForceVector = ForceVector - kMatrix * DispVector;for (int i = 0; i < Rest.Count; i++){if (Rest[i] == true){for (int j = 0; j < kMatrix.ColumnCount; j++){kMatrix[i, j] = 0.0;}for (int k = 0; k < kMatrix.RowCount; k++){kMatrix[k, i] = 0.0;}kMatrix[i, i] = 1.0;ForceVector[i] = DispVector[i];}}Console.WriteLine("Kマトリックス(境界条件考慮)");Console.WriteLine(kMatrix);Console.WriteLine("荷重ベクトル(境界条件考慮)");Console.WriteLine(ForceVector);return kMatrix;}
Kマトリックスを作成する
ForceVector = ForceVector - kMatrix * DispVector;
境界条件を考慮して修正する
DispVector = (DenseVector)(kMatrix.Inverse().Multiply(ForceVector));
変位を計算する
DenseVector dispElemVector = DenseVector.Create(2, 0.0);
各要素の応力を計算する
{if (Area <= 0){return null;}double length = Nodes[1].Point - Nodes[0].Point;double[,] bmatrixArray = new double[1, 2];bmatrixArray[0, 0] = -1.0 / length;bmatrixArray[0, 1] = 1.0 / length;return DenseMatrix.OfArray(bmatrixArray);}
Bマトリックスを計算する
{DenseMatrix BMatrix = makeBMatirx();Console.WriteLine("Bマトリックス");Console.WriteLine(BMatrix);if (BMatrix == null || Young <= 0){return null;}double Volume = Area * (Nodes[1].Point - Nodes[0].Point);var keMatrix = Young * Volume * BMatrix.Transpose() * BMatrix;DenseMatrix KeMatrix = DenseMatrix.OfColumnArrays(keMatrix.ToColumnArrays());Console.WriteLine("Keマトリックス");Console.WriteLine(KeMatrix);return KeMatrix;}
Keマトリックスを計算する
DenseMatrix BMatrix = makeBMatirx();
Bマトリックスを計算する
{DenseMatrix bMatrix = makeBMatirx();StrainVector = (DenseVector)bMatrix.Multiply(dispvector);Console.WriteLine("ひずみベクトル");Console.WriteLine(StrainVector);}
ひずみベクトルを計算する
{if (StrainVector == null || Young <= 0){return;}StressVector = Young * StrainVector;Console.WriteLine("応力ベクトル");Console.WriteLine(StressVector);}
応力ベクトルを計算する
player = ConvertExtension.ChangeType<Player>(data[nameof(player)])
nullableなMapデータをPlayerに変換する
public ChildArray[] array;
配列を作成
var tasks = new List<Task>();
Taskリストの初期化
await Task.WhenAll(tasks);
リスト中の全てのタスクの完了を待つ
app.UseAuthentication();
認証ミドルウェアの追加
Mat Lsrc = new Mat(sLeftPictureFile, ImreadModes.Color);
画像をグレースケールとして読み込む
Mat Rsrc = new Mat(sRightPictureFile, ImreadModes.Color);
画像をグレースケールとして読み込む
akaze.DetectAndCompute(Lsrc, null, out keyPointsLeft, descriptorLeft);
特徴量の検出と特徴量ベクトルの計算
Cv2.Absdiff(LmatPlanes[0], RmatPlanes[0], diff0);*Cv2.Absdiff(LmatPlanes[1], RmatPlanes[1], diff1);
分割したチャンネルごとに差分を出す
Cv2.MedianBlur(diff0, diff0, 5);*Cv2.MedianBlur(diff1, diff1, 5);
ブラーでノイズ除去
MessageBox.Show("入力したものは…" + sb.ToString() + " です。");
メッセージを表示する
{new weapon_status{Name = "どうの剣",Attribute = "なし",Status = 10},new weapon_status{Name = "はがねの剣",Attribute = "なし",Status = 50},new weapon_status{Name = "炎の剣",Attribute = "火",Status = 100},new weapon_status{Name = "ドラゴンの剣",Attribute = "竜",Status = 150},};
武器のリストを作成
var Strong_Weapons = weapons.Where(x => x.Status >= 100);
攻撃力が100以上のものを、強武器としてStrong_Weaponsに格納
static void makeDB(){using(var db=new SqliteConnection("Data Source=../sqlitest.db")){db.Open();var sql=db.CreateCommand();sql.CommandText=@"CREATE TABLE IF NOT EXISTS DMCARDS (ID INTEGER PRIMARY KEY AUTOINCREMENT,NAME TEXT,COLOR TEXT,COST INTEGER,POWER INTEGER)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('ラ・ウラ・ギガ','光',1,2000)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('アクア・ガード','水',1,2000)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('ボーン・スライム','闇',1,1000)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('ブレイズ・クロー','火',1,1000)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('スナイプ・モスキート','自然',1,2000)";sql.ExecuteNonQuery();}}
データベース(テーブル)を初期化
static void updateDB(){using(var db=new SqliteConnection("Data Source=../sqlitest.db")){db.Open();var sql=db.CreateCommand();sql.CommandText="UPDATE DMCARDS SET COLOR='白' WHERE COLOR='光'";sql.ExecuteNonQuery();sql.CommandText="UPDATE DMCARDS SET COLOR='青' WHERE COLOR='水'";sql.ExecuteNonQuery();sql.CommandText="UPDATE DMCARDS SET COLOR='黒' WHERE COLOR='闇'";sql.ExecuteNonQuery();sql.CommandText="UPDATE DMCARDS SET COLOR='赤' WHERE COLOR='赤'";sql.ExecuteNonQuery();sql.CommandText="UPDATE DMCARDS SET COLOR='緑' WHERE COLOR='自然'";sql.ExecuteNonQuery();}}
データベースを変更
static void dropDB(){using(var db=new SqliteConnection("Data Source=../sqlitest.db")){db.Open();var sql=db.CreateCommand();sql.CommandText="DROP TABLE IF EXISTS DMCARDS";sql.ExecuteNonQuery();}}
データベースを削除
static void viewDB(){using(var db=new SqliteConnection("Data Source=../sqlitest.db")){db.Open();var sql=db.CreateCommand();sql.CommandText="SELECT * FROM DMCARDS";using(var row=sql.ExecuteReader()){Console.WriteLine("ID,NAME,COLOR,COST,POWER");while(row.Read()){Console.WriteLine($"{row["ID"]},{row["NAME"]},{row["COLOR"]},{row["COST"]},{row["POWER"]}");}}}}
データベースを表示
{private int value1private int value2public void method1(int a, int b){this.value1 = a;this.value2 = b;}}
クラスの定義
public delegate void MyDelegate(string s);
デリゲート(関数を参照する変数の型)
クラスのインスタンス作成
MyDelegate dgref1 = new MyDelegate(Console.WriteLine);
デリゲートのインスタンス(関数そのものを参照するインスタンス)の作成
delegate double Culc2(int a, int b);
2値を計算するメソッドデリゲート型の定義
Culc2 culc2Test = new Culc2(plus);
2値計算メソッドデリゲート変数「culc2Test」を定義する。
double testnum = culc2Test(24, 33);
デリゲート変数に格納されたメソッドを呼び出す
{return (double)a + (double)b;}
足し算
{return (double)a - (double)b;}
引き算
{return (double)a * (double)b;}
掛け算
{if (b == 0){return -9999999999999999999.9;}else{return (double)a / (double)b;}}
割り算
{int result = 1;for (int i = 0; i < b; i++){result *= a;}return (double)result;}
aのb乗
delegate double Culc2(int a, int b);
2値を計算するメソッドデリゲート型の定義
*Culc2[] culc2tests = new Culc2[5];
2値計算メソッドデリゲート配列「culc2tests」を定義する。
{return (double)a + (double)b;}
足し算
{return (double)a - (double)b;}
引き算
{return (double)a * (double)b;}
掛け算
{if (b == 0){return -9999999999999999999.9;}else{return (double)a / (double)b;}}
割り算
{int result = 1;for (int i = 0; i < b; i++){result *= a;}return (double)result;}
aのb乗
delegate double Culc2(int a, int b);
2値を計算するメソッドデリゲート型の定義
Culc2[] culc2tests = new Culc2[6];
2値計算メソッドデリゲート配列「culc2tests」を定義する。
{int result = 1;for (int i = 0; i < b; i++){result *= a;}return (double)result;}
aのb乗
string data = selectResult.GetString(1);
カラムインデックスでのアクセス
System.Net.ServicePointManager.SecurityProtocol = System.Net.SecurityProtocolType.Tls11 | System.Net.SecurityProtocolType.Tls12;
SSL通信の許可設定
StorageSharedKeyCredential credential = new StorageSharedKeyCredential(accountName, accessKey);
Azureへ接続準備：接続情報の設定
ShareClient share = new ShareClient(serverurl ,  credential);
Azureへ接続
directory.CreateIfNotExists();
Upload先(azure側)にフォルダがなければ作成。
ShareFileClient file = directory.GetFileClient(azureFileName);
Upload先(azure側)にファイルインスタンスを作成。
file.DeleteIfExists();
同名のファイルがあったら削除
FileStream stream = File.OpenRead( Path.Combine(localDirectoryPath , localFileName ) );
Upload対象のLocalファイルを開く。
file.Create(stream.Length);
Upload先(azure側)にファイルインスタンスにバイナリ情報を注入
stream.Dispose();
ローカルファイルの開放
public static int BinarySearchInOdds(double[] odds, double r) {if (r < 0) return -1;if (odds.Length == 0) return -1;double[] sum_from_left = new double[odds.Length];double[] sum_from_right = new double[odds.Length];double odd_total = odds.Sum();sum_from_left[0] = 0;sum_from_right[0] = odd_total;for (int i = 1; i < odds.Length; i++) {sum_from_left[i] = sum_from_left[i-1] + odds[i-1];sum_from_right[i] = sum_from_right[i-1] - odds[i-1];}int left = 0;int right = odds.Length - 1;int mid = left + (right - left) / 2;double L_mid = sum_from_left[mid];while (right >= left) {double R_mid = L_mid + odds[mid];if ((L_mid <= r && r < R_mid) || (r == R_mid && mid == odds.Length - 1)) {// キーがmid番目の要素の範囲内にある場合return mid;} else if (r < L_mid) {// キーがmid番目の要素の範囲より小さい範囲にある場合right = mid - 1;mid = left + (right - left) / 2;R_mid = L_mid - (odd_total - sum_from_left[mid + 1] - sum_from_right[right + 1]);L_mid = R_mid - odds[mid];} else {// キーがmid番目の要素の範囲より大きい範囲にある場合left = mid + 1;mid = left + (right - left) / 2;if (mid >= odds.Length) break;L_mid = R_mid + (odd_total - sum_from_left[left] - sum_from_right[mid]);R_mid = L_mid + odds[mid];}}return -1;}
確率分布の中で、 rに対応する要素のインデックスを返す
double[] sum_from_left = new double[odds.Length];
確率分布の部分和をあらかじめ求めておく
public static int Draw(double[] odds) {Random rnd = new Random();double r = rnd.NextDouble() * odds.Sum();return BinarySearchInOdds(odds, r);}
確率分布にしたがって、ランダムに決定した要素のインデックスを返す
string path = @"C:\Users\hogehoge\Desktop\";
ファイルの置き場所を記載
string sourceWord = sourceCode[i].Trim();
前後の空白と2つ以上続く空白を全て削除し、1つの空白しか残らないようにする
if (CheckData(sourceWord, "TabIndex ="))
TabIndexの取得
if (CheckData(sourceWord, "Index ="))
Indexの取得
if (CheckData(sourceWord, "Tag ="))
Tagの取得
if (CheckData(sourceWord, "Top ="))
Topの取得
if (list1 == null || list2 == null)
list1とlist2がNULLの場合
var channelAccessToken = System.Environment.GetEnvironmentVariable("CHANNEL_ACCESS_TOKEN");
チャンネルアクセストークンを変数へ格納
{messages = new List<Message>(){new Message(){type="text",text=mm + "月"+ dd　+"日の"+ HH + "時になりました。本日のタスクは完了していますか？"}}};
リプライメッセージ作成
string json = JsonConvert.SerializeObject(rm, Formatting.Indented);
リプライメッセージをシリアライズ
var req = new HttpRequestMessage(HttpMethod.Post, apiUrl);
Line Messaging APIへのリクエストを作成する
req.Headers.Add(@"Authorization", @"Bearer {" + channelAccessToken + "}");
ヘッダーにチャンネルアクセストークンを追加する
req.Content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");
リクエストをJSON形式にシリアライズする
{var response = await client.SendAsync(req);log.LogInformation($"{response}");}
リクエストを送信する
if (num % 2 == 0) return false;
偶数はあらかじめ除く
{return num % 2 == 0;}
偶数ならTrueを返すメソッド
Console.WriteLine(N);
標準出力へ書き出し
DumbAssertConfig.Encoding = Encoding.GetEncoding("UTF-8");
エンコーディングを指定
DumbAssertConfig.DateTimePattern = "yyyy-MM-dd HH:mm:ss.fff";
DateTimeの文字列表現パターンを指定
DumbAssertConfig.NewLine = Environment.NewLine;
改行コード
{var res = await _http.GetStringAsync("/api/GetToken");_getTokenResponse = JsonSerializer.Deserialize<GetTokenResponse>(res);_chatClient = new ChatClient(new Uri(_communicationServiceSettings.Endpoint),new CommunicationUserCredential(_getTokenResponse.Token));_chatThreadClient =  _chatClient.GetChatThreadClient(_getTokenResponse.ThreadId);}
チャットに参加
{await _chatThreadClient.SendMessageAsync(message, senderDisplayName: name);}
チャットにメッセージを送信
public IAsyncEnumerable<ChatMessage> GetMessagesAsync() => _chatThreadClient.GetMessagesAsync();
チャットのメッセージを取得
lock (client.SyncRoot)
スレッド処理のためロックする
if (Directory.Exists(save_path + folder.Name) == false)
フォルダ存在確認
Directory.CreateDirectory(save_path + folder.Name);
フォルダを作る
m.WriteTo(save_path + folder.Name + "\\" + uid.ToString() + "：" + m.Subject + ".eml");
ファイルへ書き出し
folder.Open(FolderAccess.ReadOnly);
IMAPフォルダを開く
DateTime next = Enumerable.Range(1, 100).Select(x => date.AddDays(x)).First(
100日後までの間で最も近い営業日を取得
SetDrawScreen(DX.DX_SCREEN_BACK);
描画先を裏画面に設定
DX.ClearDrawScreen();
画面をクリア
Vector3 center = (sunrise.position + sunset.position) * 0.5f;
弧の中心
Vector3 riseRelCenter = sunrise.position - center;
中心を基準として円弧を補間する
Client.Send(RequestData, RequestData.Length, new IPEndPoint(IPAddress.Broadcast, 8888));
ポート8888にブロードキャスト送信
var ServerResponse = Encoding.ASCII.GetString(ServerResponseData);
送信データを受信した相手は、自分（クライアント）のエンドポイント情報を知ったはずなので、そこに対してパケットを送信してくれるのを待つ
_saveButton.OnPointerClickAsObservable()
セーブボタン
_loadButton.OnPointerClickAsObservable()
ロードボタン
Directory.CreateDirectory(directoryPath);
まだ存在してなかったら作成
GetFiles(directoryName, "*", SearchOption.AllDirectories)
Imageディレクトリ内の全ファイルを取得
.OrderBy(filePath => File.GetLastWriteTime(filePath).Date)
日付順に降順でソート
.ThenBy(filePath => File.GetLastWriteTime(filePath).TimeOfDay)
同じ日付内で時刻順に降順でソート
List<string> imageFilePaths = GetAllFileFromDirectory(directoryPath);
指定したディレクトリー配下のファイルが全て入ったリストを取得
File.Delete(imageFilePaths[0]);
最も古いファイルを削除
byte[] bytes = _paintImage.sprite.texture.EncodeToPNG();
Png画像に変換
List<string> imageFilePaths = GetAllFileFromDirectory(directoryPath);
指定したディレクトリー配下のファイルが全て入ったリストを取得
インデックス用カウンター
byte[] bytes = File.ReadAllBytes(imageFilePath);
読み込み
Texture2D loadTexture = new Texture2D(2, 2);
画像をテクスチャに変換
count++;
カウンターを進める
float lineLength = Vector2.Distance(_prevPosition, endPosition);
2点間の距離
Vector3 lerpPosition = Vector2.Lerp(_prevPosition, Input.mousePosition, lerpWeight);
前回の入力座標、現在の入力座標、割合を渡して補間する座標を算出
_prevPosition = Input.mousePosition;
前回の入力座標を記録
_prevPosition = Vector2.zero;
前回の入力座標をリセット
if (_prevPosition == Vector2.zero)
前回値がまだないなら現在の値を前回値として扱う
_prevPosition = Vector2.zero;
前回の入力座標をリセット
DataRow row = tbl.Rows[i];
データ行
listBox1.Items.Add(row[1]);
右のリストボックスにアイテムを追加
Array.Clear(bmparr,0, bmparr.Length);
画像の解放
StateMachine<MyClass> stateMachine = new StateMachine<MyClass>(myClass);
ステートマシンの宣言
stateMachine.ChangeState(myState);
現在の状態を変更
stateMachine.Update();
現在のステートを実行
Directory.CreateDirectory(directoryPath);
まだ存在してなかったら作成
ImageData imageData =new ImageData(pngPath,_inputText.text);
構造体にパス、名前を入れる　これでひとつの塊
JsonDataUtility.Save(imageData,jsonPath);
構造体をJsonに変換
byte[] bytes = File.ReadAllBytes(imageData.ImageSavePath);
読み込み
Texture2D loadTexture = new Texture2D(2, 2);
画像をテクスチャに変換
_loadImage.sprite = Sprite.Create(loadTexture, new Rect(0, 0, loadTexture.width, loadTexture.height), Vector2.zero);
テクスチャをスプライトに変換
_loadText.text = imageData.ImageName;
画像の名前を表示
Directory.CreateDirectory(directoryPath);
まだ存在してなかったら作成
string connStr = "server=127.0.0.1;user id=test;password=test1;database=manutest";
接続情報を文字列で与える
conn.Open();
接続を開く
conn.Close();
接続を閉じる
{List<ExampleClass> selItems = new List<ExampleClass>();foreach (var oneItemLine in listBox.SelectedItems){ExampleClass item = oneItemLine as ExampleClass;selItems.Add(item);}return selItems;}
SelectedItemsの中身を取り出すメソッド
{string controlName = "ExampleList1";object controlObj = FindName(controlName);ListBox listBox = (ListBox)controlObj;if (listBox.SelectedItems.Count == 0)return;List<ExampleClass> selItems = GetSelectedItems(listBox);string message = "";foreach (var line in selItems){message = message + string.Format("\r\nId：「{0}」　Nmae：「{1}」　Age：「{2}」", line.Id, line.Name, line.Age);}message = string.Format($"{controlName} で選択中の項目は\r\n{message}\r\n\r\nです");MessageBox.Show(message);}
リストボックス1の選択中アイテムを表示する
object controlObj = FindName(controlName);
リストボックスを探す
if (listBox.SelectedItems.Count == 0)return;
選択項目が0ならメソッドを出る
List<ExampleClass> selItems = GetSelectedItems(listBox);
選択中のアイテムを取得する
{string controlName = "ExampleList2";ItemShow(controlName);}
! リストボックス2の選択中アイテムを表示する
mvcBuilder.AddRazorRuntimeCompilation();
実行時コンパイルの有効化
if (ExampleList.SelectedItems.Count == 0)return;
選択項目が0ならメソッドを出る
int[] _id = new int[0];
空の配列を宣言
ExampleClass item = oneItemLine as ExampleClass;
ExampleClassとして取り出す
_list.RemoveRange(0, result);
リストのインデックス 0～result を削除
bool isDemoMode = this._configuration.GetValue<bool>("UserSettings:IsDemoMode");
ブール値のロード
string defaultUserName = this._configuration["UserSettings:DefaultUser:Name"];
文字列値のロードは、インデクサで指定可能
int defaultUserAge = this._configuration.GetValue<int>("UserSettings:DefaultUser:Age");
int 値のロード
services.Configure<UserSettings>(this.Configuration.GetSection("UserSettings"));
構成情報の注入
this._userSettings = userSettings.Value;
構成情報の取得
return View(this._userSettings);
構成情報の参照
distance = Vector3.Distance(startMarker.position, endMarker.position);
二点間の距離
float distCovered = (Time.time - startTime) * speed;
移動距離 =　経過時間　*　速度
fractionOfJourney = distCovered / distance;
移動距離の割合 = 移動距離 /　二点間の距離
transform.position = Vector3.Lerp(startMarker.position, endMarker.position, fractionOfJourney);*}
線形補間による移動
mat = this.GetComponent<Renderer>().material;
LerpExampleから補間値を取得
mat.color = Color.Lerp(Color.blue, Color.red, lerpExample.fractionOfJourney);
青色→赤色へLerpExampleと同じ補間値で推移
Window firstWindow = new MainWindow();
Windowsインスタンスを生成した際に自動でそのインスタンスがApplication.MainWindowにセットされる。
[RequireComponent(typeof(Rigidbody2D))]
Rigidbody2Dコンポーネントを必須にする
_rigidbody.velocity = direction * _speed;
機体の移動
if (this.paramA.SetValue(value, this))this.Model.ParamA = int.Parse(this.ParamA);
入力エラーがなければModelに設定
if (this.paramB.SetValue(value, this))this.Model.ParamB = int.Parse(this.ParamB);
入力エラーがなければModelに設定
Console.WriteLine(string.Join(",",ary));
aryを連結して出力
{sensor.AddObservation(gameObject.transform.localPosition.z);sensor.AddObservation(cartRB.velocity.z);sensor.AddObservation(pole.transform.localRotation.eulerAngles.x);sensor.AddObservation(poleRB.angularVelocity.x);}
センサーにデータを送る
var actionZ = 200f * Mathf.Clamp(verctorAction[0], -1f, 1f);
カートに力を加える
poleRB.angularVelocity = new Vector3(Random.Range(-0.1f, 0.1f), 0f, 0f);
ランダムな傾きを与える
var actionZ = 200f * Mathf.Clamp(verctorAction[0], -1f, 1f);
カートに力を加える
SelectionColor = ResultColor;
実行結果の表示色を設定
if (ee.Result != null && ee.Result.Length != 0 && ee.Result[0] == COUTIONCHER) {*ee.Result = ee.Result.Remove(0, 1);
表示文字列の先頭が「！」なら、その一文字を削除し、表示色をCoutionColorに変更
AppendText(LFCR + ee.Result + LFCR);
実行結果の表示
Console.WriteLine(string.Join(",", array));
コンマ区切りで出力
*Console.WriteLine(string.Join(" ", array));
スペース区切りで出力
*Console.WriteLine(string.Join("\r\n", array));
改行区切りで出力
downloadedPost.LGTM();
記事をLGTMする
QiitaServer.Upload(post);
記事をアップロードする
IAuthorQiitaPost post = new QiitaPost("タイトル", "本文");
記事を書く
{for (var i = 0; i < NameList.Count; i++){yield return this[i];}}
GetEnumerator実装
{return this.GetEnumerator();}
IEnumerable(非ジェネリック型)のGetEnumeratorも実装
foreach (var (name, index) in properties.Select((prop, index) => (prop.Name, index)))
propertiesから、各Name取り出し
public GameObject viewcamera;
"viewcamera"という変数を定義
viewcamera.transform.Rotate(-mouse_y, 0.0f, 0.0f);*}
このscriptに登録されているオブジェクトをX方向に-mouse_yの値分、回転する
this.RegionManager.RequestNavigate("RedRegion", nameof(UserControl2), new NavigationParameters($"id=1"));
Shell.xaml.csで作成したリージョンの名前と、画面のUserControlクラス名を指定して、画面遷移させる。
ray = Camera.main.ScreenPointToRay(Input.mousePosition);
クリック点にRayを飛ばす
Collider[] collider = Physics.OverlapSphere(hit.point, radius);
クリックした所から半径20mの範囲のColliderを取得
DX.SetDrawScreen(DX.DX_SCREEN_BACK);
裏画面処理を設定する
DX.ScreenFlip();
2つの画面を入れ替える
target.localPosition = new Vector3 (Random.value * 8 - 4, 0.5f, Random.value * 8 - 4);
ターゲットを新しい無作為な位置へ移動
if (distanceToTarget < reachMargin) 
ターゲットへの到達したら
*{UIHostNoLaunch uiHostNoLaunch = null;try{uiHostNoLaunch = new UIHostNoLaunch();var tipInvocation = (ITipInvocation)uiHostNoLaunch;tipInvocation.Toggle(GetDesktopWindow());}finally{if (uiHostNoLaunch != null){Marshal.ReleaseComObject(uiHostNoLaunch);}}}
UIHostNoLaunch.Toggle で表示切り替え
RpcSetBaseTime(DateTime.UtcNow);
クライアントにホストの現在時刻を送信する
var t = Time.realtimeSinceStartup - baseTime;
ホスト開始からの経過時間
var delay = (float)(DateTime.UtcNow - hostTime).TotalSeconds;
通信で起きたラグを算出
baseTime = Time.realtimeSinceStartup - delay;
ラグを考慮した開始時間を設定、このbaseTimeがホストの基準時刻と一致する
Authenticator = new DigestAuthenticator("username", "password");
Digest認証の設定
client.UseUtf8Json();
JSONシリアライザーの設定
var request = new RestRequest("foobaz", DataFormat.Json);
リクエストの生成（Resourceとレスポンスのデータフォーマットを設定）
var response = client.Get(request);
同期呼び出し
var result = new Utf8JsonSerializer().Deserialize<Foo>(response);
JSONデータをデシリアライズ
var result = await client.GetAsync<Foo>(request);
非同期呼び出し（resultがFoo型として返ってくる）
p.StartInfo.StandardOutputEncoding = Encoding.GetEncoding("shift_jis");
Pythonの出力結果をshift-jisに変換
p.OutputDataReceived += new DataReceivedEventHandler((sender, e) =>
イベントハンドラの設定。pythonから出力があるたびに呼び出される
if (Physics.Raycast(transform.position, Vector3.down, out hit, 10))
レイが当たったか判定
if (String.Compare(Path.GetFileName(tmp), "EXPLORER.EXE", true)==0) {
大文字小文字無視で比較
var item = new ListViewItem(new string[]{Path.GetFileName(path),path});
Windows形式のパス表現に変換する
ILogger logger = new ConsoleLogger();
Loggerを初期化する
var context = System.Threading.SynchronizationContext.Current;
UIスレッドを触る可能性があるので、コールバックを渡すためのコンテキストを退避しておく
string targetFilePath = targetDir + targetFileName;
ファイル準備
var regex = new Regex(regexPattern, RegexOptions.Compiled);
ファイル名の一部を変更する置換パターンを作成
fileElem.Replace(new[] { rpRegex });
リネームプレビュー実行
fileElem.Rename();
リネーム保存実行
string[] port_list = SerialPort.GetPortNames();
ポート一覧の更新
if (SerialPortComboBox.Items.Count <= 1)SerialPortComboBox.SelectedIndex = 0;
ポート数が1以下であれば0番目を選択
NativeMethods.CopyMemory((void*)0, src, realsrc.Length);
0番地にデータをコピーする
RSA rsa = RSA.Create();
秘密鍵と公開鍵を生成
var publicKey = rsa.ToXmlString(false);
鍵情報を保存
Console.WriteLine($"Encrypt: {encByteToString}");
暗号化したバイトデータを16進数文字列に変換
var encStrToBytes = encByteToString.Split('-').Select(r => Convert.ToByte(r, 16)).ToArray();
上記の方法で生成された16進数文字列を外部から受信したと仮定して、秘密鍵を使って復元する
{decRsa.FromXmlString(privateKey);decryptedByte = decRsa.Decrypt(encStrToBytes, RSAEncryptionPadding.Pkcs1);}
秘密鍵情報の文字列からオブジェクトを復元し、復号
Random rnd = new Random();
乱数インスタンス化
Bitmap canvas = new Bitmap("画像のパス");
描画先とするImageオブジェクトを作成する
g.DrawImage(canvas, rnd.Next(0, 1920), rnd.Next(0, 1000));
ImageオブジェクトのGraphicsオブジェクトを作成する
var path = EditorUtility.OpenFilePanel("Open csv", "", "CSV");
パスの取得
var reader = new StreamReader(path);
読み込み
{int ret = 0;for (int i = 0; i < inputCount; i++){if (inputs[i] >= target){ret++;}}return ret;}
targer以上の要素の個数を返す
var endpoint = context.GetEndpoint();
UseRoutingの後に配置したミドルウェアではhttpコンテキストからエンドポイントの情報を取得できる
{endpoints.MapRazorPages();});
エンドポイントとデリゲートを関連付ける
double X_x = x * 1;
X軸周りで回転計算
double X_y = X_x * Math.Cos(f_roty * rad) + Z_x * Math.Sin(f_roty * rad);
Y軸周りで回転計算
double X_z = X_y * Math.Cos(f_rotz * rad) - Y_y * Math.Sin(f_rotz * rad);
Z軸周りで回転計算
public ReactiveCommand CloseWindow { get; } = new ReactiveCommand();
プロパティ宣言
CloseWindow.Subscribe(x => ((System.Windows.Window)x).Close());
コンストラクタ
OK.Subscribe(x => {result = MessageBox.Show("ウィンドウを閉じてもよろしいですか？", "確認メッセージ", MessageBoxButtons.OKCancel);if (result == DialogResult.Cancel)return;elseCloseWindow.Execute(x);});
コンストラクタ
return actressSearch.ToActressList();
データベース用クラス変換
glControl = new GLControl();
GLControlの初期化
if (e.Button == MouseButtons.Right)
右ボタンが押された場合
if (isCameraRotating)
カメラが回転状態の場合
if (zoom > 4.0f)zoom = 4.0f;
拡大、縮小の制限
GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
バッファのクリア
glControl.SwapBuffers();
バッファの入れ替え
GL.Begin(PrimitiveType.Triangles);
描画
{int width = glControl.Width;int height = glControl.Height;float[] floatArr = new float[width * height * 3];OpenCvSharp.Mat ret = new OpenCvSharp.Mat(height, width, OpenCvSharp.MatType.CV_32FC3);// dataBufferへの画像の読み込みIntPtr dataBuffer = Marshal.AllocHGlobal(width * height * 12);GL.ReadBuffer(ReadBufferMode.Front);GL.ReadPixels(0, 0, width, height, PixelFormat.Bgr, PixelType.Float, dataBuffer);// imgへの読み込みMarshal.Copy(dataBuffer, floatArr, 0, floatArr.Length);// opencvsharp.Matへの変換Marshal.Copy(floatArr, 0, ret.Data, floatArr.Length);// 破棄Marshal.FreeHGlobal(dataBuffer);return ret;}
画像の保存
IntPtr dataBuffer = Marshal.AllocHGlobal(width * height * 12);
dataBufferへの画像の読み込み
Marshal.Copy(dataBuffer, floatArr, 0, floatArr.Length);
imgへの読み込み
Marshal.Copy(floatArr, 0, ret.Data, floatArr.Length);
opencvsharp.Matへの変換
Marshal.FreeHGlobal(dataBuffer);
破棄
var polygon = SurfaceAnalyzer.LoadData.LoadSTL(@"local\cube3_とんがり2.STL", true);
形状の読み込み
viewer.Render(polygon);
形状のレンダリング
{Cv2.ImShow("mat", mat);Cv2.ImWrite(@"local\mat.jpg", mat * 256);}
viewerの画像の取得
Cv2.ImShow("mat", mat);
画像の表示
Cv2.ImWrite(@"local\mat.jpg", mat * 256);
画像の保存
if (args.Length > 0)
引数が指定されていればyournameに代入
string csvText = loadCSV.csvFile.text;
csvファイルをstring形式に変換
string[] afterParse = csvText.Split('\n');
改行ごとにパース
string fileName = parseByComma[column] + ".asset";
ファイルを作成
PokeDex pokedex = CreateInstance<PokeDex>();
PokeDexのインスタンスをメモリ上に作成
var asset = (PokeDex)AssetDatabase.LoadAssetAtPath(path, typeof(PokeDex));
インスタンス化したものをアセットとして保存
AssetDatabase.CreateAsset(pokedex, path);
指定のパスにファイルが存在しない場合は新規作成
EditorUtility.CopySerialized(pokedex, asset);
指定のパスに既に同名のファイルが存在する場合は更新
string csvText = loadCSV.csvFile.text;
csvファイルをstring形式に変換
string[] afterParse = csvText.Split('\n');
改行ごとにパース
string fileName = parseByComma[column] + ".asset";
ファイルを作成
IndexName = "Date-Time-index"
利用する GSI を指定
this.room = await this.Group.AddAsync(roomName);
ルームに参加&ルームを保持
this.Broadcast(room).OnJoin(me.Name);
参加したことをルームに参加している全メンバーに通知
await room.RemoveAsync(this.Context);
ルーム内のメンバーから自分を削除
this.Broadcast(room).OnLeave(me.Name);
退室したことを全メンバーに通知
this.Broadcast(room).OnSendMessage(me.Name, message);
発言した内容を全メンバーに通知
this.Broadcast(room).OnMovePosition(me);
更新したプレイヤーの情報を全メンバーに通知
await this.sampleHub.JoinAsync(player);
ゲームに接続する
await this.sampleHub.SendMessageAsync("こんにちは！");
チャットで発言してみる
ゲームから切断してみる
var newSessionID = Guid.NewGuid().ToString();
セッションIDを持っていなければクッキーに埋め込む
await CookieService.WriteCookieAsync(SessinID, newSessionID).ConfigureAwait(false);
セッションIDを持っていなければクッキーに埋め込む
var loginData = await LocalStorage.GetItemAsync<LoginData>(sessionID.Value).ConfigureAwait(false);
セッションIDを持っておりローカルストレージにもログイン情報がある場合
public static Setting Values { get; private set;}
外部に公開する為の static プロパティ
public int FormLocationX { get; set;}
シリアライズするプロパティは public にして getter と setter が必要。
Setting.Load();
読み出し
Workbook workbook = new Workbook();
workbookオブジェクトを作成します。
workbook.LoadFromFile("Sample.xlsx");
Excelをロードします。
Worksheet sheet = workbook.Worksheets[0];
シートを取得します。
sheet.SaveToImage("ExceltoImage.png", ImageFormat.Png);
イメージで保存します。
.WithAutomaticReconnect(new RandomRetryPolicy())
自動接続
var urlPattern = new Regex(@"(https?|ftp)(:\/\/[-_.!~*\'()a-zA-Z0-9;\/?:\@&=+\$,%#]+)");
message = HttpUtility.HtmlEncode(message);
入力文字列をサニタイズする
if (urlPatternMatch.Success)
入力文字列の中にURLが存在する場合
await _hubConnection.StartAsync();
画面の更新を行う
return TimeSpan.FromSeconds(_random.Next(2, 5));
2～5秒の間でランダムに再接続を試みる
var urlPattern = new Regex(@"(https?|ftp)(:\/\/[-_.!~*\'()a-zA-Z0-9;\/?:\@&=+\$,%#]+)");
入力文字列の中にURLが存在するかどうかを判定だけする
Label label = new Label();
ラベルのインスタンス生成
String inputFile = @"C:\Users\Administrator\Desktop\sample.pdf";
パスを指定します。
String outputFolder = @"C:\Users\Administrator\Desktop\Output\";
パスを指定します。
PdfStandardsConverter converter = new PdfStandardsConverter(inputFile);
PdfStandardsConverterオブジェクトを作成します。
.Range(1, 3)
1～3の数値を取得する
string gitPath = GetGitPath();
gitのパスを取得する。
string gitCommand = "config core.autocrlf";
gitのコマンドを設定する。
string autocrlf = GetStandardOutputFromProcess(gitPath, gitCommand).Trim();
コマンドを実行して標準出力を取得する。
return exePaths.FirstOrDefault(exePath => File.Exists(exePath));
存在するパスで最初に見つかったもの
{FileName = exePath,Arguments = arguments,WindowStyle = ProcessWindowStyle.Hidden,UseShellExecute = false,RedirectStandardOutput = true,};
プロセスの起動条件を設定する。
{string output = process.StandardOutput.ReadToEnd();process.WaitForExit(TimeoutPeriod);return output;}
プロセスを起動する。
string output = process.StandardOutput.ReadToEnd();
標準出力を取得する。
process.WaitForExit(TimeoutPeriod);
プロセスが終了するかタイムアウトするまで待つ。
Properties.Settings.Default.Setting1 = "a"
値の設定
Properties.Settings.Default.Save();
全部まとめて保存
LogFilePath = Path.Combine(LogDirPath, "Application.log");
出力ファイル名
Root myDeserializedClass = JsonConvert.DeserializeObject<Root>(myJsonResponse);
デシリアライズコード
.ToReactiveCommand();
実行可能なコマンド
.Select(x => new SomeDisposableClass(x))
文字列から Dispose が必要なオブジェクトに変換
BBB.IsSelected = true;
BBBタブを選択状態にする
CCC.IsSelected = true;
CCCタブを選択状態にする
cashDrawer.OpenDrawer();
キャッシュドロアを開く
if (e.Reason == SessionSwitchReason.SessionUnlock)isSoftwareRenderingMode = MakeIsSoftwareRenderingMode():
セッションのロックが解除されたとき、リモート接続されたとき
listener.Bind(localEndPoint);
通信の受け入れ準備
int bytesRec = handler.Receive(bytes);
データの受取をReceiveで行う。
data1 = data1.ToUpper();
大文字に変更
byte[] msg = Encoding.UTF8.GetBytes(data1);
クライアントにSendで返す。
handler.Shutdown(SocketShutdown.Both);
ソケットの終了
IPHostEntry ipHostInfo = Dns.GetHostEntry(Dns.GetHostName());
IPアドレスやポートを設定している。
Socket socket = new Socket(ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
ソケットを作成
byte[] msg = Encoding.UTF8.GetBytes(st + "<EOF>");
Sendで送信している。
byte[] bytes = new byte[1024];
Receiveで受信している。
socket.Shutdown(SocketShutdown.Both);
ソケットを終了している。
services.Configure<SendMailParams>(Configuration.GetSection("SendMailParams"));
メール送信用のパラメータを「appsettings.json」から抜きしてDIで利用できるようにしている
services.AddScoped<IEmailSender, MailSender.MailSender>();
メール送信用のクラスを認証時に利用するメール送信サービスとして登録。
services.AddDefaultIdentity<IdentityUser>(options => options.SignIn.RequireConfirmedAccount = true)
メールによる確認を有効にした認証を有効にする
systemManager = await userManager.FindByNameAsync(StstemManageEmail);
システム管理ユーザーにシステム管理ロールを追加
var normalUser = new IdentityUser { UserName = NormalUserEmail, Email = NormalUserEmail, EmailConfirmed = true };
ユーザー作成
var services = scope.ServiceProvider;
サービスプロバイダーの取得
IdentityUserInitializer.Initialize(services).Wait();
初期のユーザーとロールの作成
var context = services.GetRequiredService<ApplicationDbContext>();
データベースの自動マイグレーション
IdentityUserInitializer.Initialize(services).Wait();
初期のユーザーとロールの作成
services.AddIdentity<IdentityUser, IdentityRole>()
認証を有効にする
{RootDirectory = @".\Documents\",TypeDocumentTemplate = File.ReadAllText(typeTemplate, Encoding.UTF8),NamespaceDocumentTemplate = File.ReadAllText(namespaceTemplate, Encoding.UTF8),};
ライターを設定（.NET Framework バージョンの場合）
string typeDocTemplate = File.ReadAllText(typeTemplate, Encoding.UTF8);
ライターを設定（.NET Core バージョンの場合）
{ConstructorFilter = ConstructorInfoExtensions.IsRecommendOutputToDocument,TypeFilter = TypeExtenstions.IsRecommendOutputToDocument,PropertyFilter = PropertyInfoExtensions.IsRecommendOutputToDocument,FieldFilter = FieldInfoExtensions.IsRecommendOutputToDocument,MethodFilter = MethodInfoExtensions.IsRecommendOutputToDocument,EventFilter = EventInfoExtensions.IsRecommendOutputToDocument,};
コンテキストとフォーマッターを設定
top.enabled = viewportRect.max.y >= contentBound.max.y;
上までスクロールされているか？
Grounded = true;
Groundedをtrueにする
Quaternion rot = Quaternion.AngleAxis(rotate_direction * rotate_speed, transform.up);
オブジェクトからみて垂直方向を軸として回転させるQuaternionを作成
Quaternion q = this.transform.rotation;*
現在の自信の回転の情報を取得する。
this.transform.rotation = rot * q;
合成して、自身に設定
RaycastHit hit;
Rayが当たったオブジェクトの情報を入れる箱
if (Physics.Raycast(ray, out hit, Mathf.Infinity))
もしRayにオブジェクトが衝突したら
if (hit.collider.tag == "Planet")
Rayが当たったオブジェクトのtagがPlanetだったら
.Where(pair => (pair.up.Timestamp - pair.down.Timestamp) <= TimeSpan.FromMilliseconds(shortTapThreshold))
押した時と離れたときの間隔が shortTapThreshold 以下のときだけ通す
_randomNumber = Random.Range(0, _blockParent.transform.childCount);_randomInterval = Random.Range(_MIN_INTERVAL_VALUE, _MAX_INTERVAL_VALUE);
ランダムな値
await UniTask.Delay(TimeSpan.FromSeconds(_randomInterval));
ランダムな間隔でDelay
_usePositionList.Add(randomPosition);
新しい使用中のポジションをリストに追加
cam.GetComponent<RippleEffect>().SetNewRipplePosition(target);
新しい波紋を生成
double  val8  = 1.23;
1.23dと明示的に表記してもOK
var hoge = JsonSerializer.Deserialize<Hoge>(File.ReadAllText(@"C:\hoge.json"), options);
デシリアライズ
var json = JsonSerializer.Serialize<Hoge>(hoge, options);
シリアライズ
var posts = context.GetCollection<Post>("posts");
DBへ接続
posts.EnsureIndex(x => x.Title, true);
Titleをユニークインデックスにする
posts.Update(post);
更新
Console.WriteLine("Hello world");
文字を出力
var tokyoWeathers = string.Join(", ", nodes.Select(x => x.TextContent.Trim()));
整形して出力
var ave1 = timeSpans.Item1.Average();
それぞれの平均処理速度と速度改善率を計算
if(rect.X + rect.Width >= ClientSize.Width)addX = false;*else if(rect.X <= 0)addX = true;
フォームの外枠超えようとすると、移動方向反転
Invalidate();
再描画
public int Value { get; private set; }
イベントを定義
var counter = new Counter();
カウンターを作る
context.Dispose();
解放
pRt.enableRandomWrite = true;
レンダーテクスチャを書き込み可能にする
_skin.BakeMesh(mesh);
SkinnedMeshRenderから現在のフレームのmeshを作る
posBuffer = new ComputeBuffer(vertexCount, System.Runtime.InteropServices.Marshal.SizeOf(typeof(Vector3)));
コンピュートシェーダーに値を渡す入れ物をつくる
posBuffer.SetData(mesh.vertices);
meshの頂点位置情報をセットする
infoTexGen.Dispatch(kernel, vertexCount, 1, 1);
コンピュートシェーダを実行する
var kernel = NormalizedRGBValueTo64pxRGBBrightness.FindKernel("CSMain");
呼びたいカーネル（処理）を決める
ReadOnlyCollection<IWebElement> itemList_sb = chrome.FindElementsByClassName("SearchResultList-box");
クラス名SearchResultList-boxの要素を取得
ReadOnlyCollection<IWebElement> itemList_li = itemList_sb[0].FindElements(By.ClassName("List_item"));
クラス名SearchResultList-boxの下にあるクラス名List_itemの要素を取得
ReadOnlyCollection<IWebElement> itemList_sb = chrome.FindElementsByClassName("SearchResultList-box");
クラス名SearchResultList-boxの要素を取得
ReadOnlyCollection<IWebElement> itemList_wc = itemList_sb[0].FindElements(By.CssSelector("*"));
クラス名SearchResultList-boxの下にあるすべての要素を取得
ReadOnlyCollection<IWebElement> itemList = chrome.FindElementsByClassName("List_item");
クラス名List_itemの要素を取得
string text = itemList[0].Text;
List_item1個めのテキスト"Text1"を取得
ReadOnlyCollection<IWebElement> itemList = chrome.FindElementsByTagName("li");
Tag名"li"の要素を取得
string text = itemList[0].GetAttribute("class");
Tag名liの1個めのクラス名"List_item"を取得
ReadOnlyCollection<IWebElement> itemList = chrome.FindElementsByTagName("ul");
Tag名"ul"の要素を取得
string text = itemList[0].GetAttribute("innerHTML");
HTMLを取得
string text = itemList[0].TagName;
class名SearchResultList-boxの要素を取得
*ReadOnlyCollection<IWebElement> itemList = chrome.FindElementsByClassName("URL-box");
class名SearchResultList-boxの要素を取得
if (IsIconic(handle))ShowWindowAsync(handle, SW_RESTORE);
最小化状態なら元に戻す
int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);
フォアグラウンドウィンドウを作成したスレッドのIDを取得
int targetID = GetWindowThreadProcessId(handle, out processId);
目的のウィンドウを作成したスレッドのIDを取得
AttachThreadInput(targetID, foregroundID, true);
スレッドのインプット状態を結び付ける
SetForegroundWindow(handle);
ウィンドウをフォアグラウンドに持ってくる
AttachThreadInput(targetID, foregroundID, false);
スレッドのインプット状態を切り離す
if (p.MainWindowTitle.Length != 0)
メインウィンドウのタイトルがある時だけ
ForceActive(pFireFox.MainWindowHandle);
FireFoxをアクティブに
var responceObject = JsonConvert.DeserializeObject<GetSlackMessagesResponce>(responseBodyString);
読みだしたJsonを、オブジェクトにデシリアライズする
Text = messageResponce.text;
本文を設定
using var reader = new StreamReader(stream);
ストリームから文字列を読みだすため、StreamReaderを生成する
user.Name = user.Name.ToUpper();
大文字に変換
public Texture wood_dark_AlbedoTransparency;
クラス変数として Texture型のクラス変数 wood_dark_AlbedoTransparencyを定義する
GCHandle handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
GCによって移動しないように固定する。
IntPtr bufferPtr = handle.AddrOfPinnedObject();
確保したバッファのアドレス
handle.Free();
解放
var services = new ServiceCollection();
型の登録
DialogResult result = pd.ShowDialog();
ダイアログを表示する
if (bw.CancellationPending){
キャンセルされたか調べる
e.Cancel = true;
キャンセルされたとき
e.Result = counter;
結果を設定する
System.Threading.Thread.Sleep(16);
指定された時間待機する
this.bmp = new Bitmap(500, 400);
キャンバスサイズは横500px、縦400px。
g.DrawEllipse(new Pen(GetFaceBorderColor(), 5), GetFacePosition());
顔の輪郭を描く。
g.FillEllipse(new SolidBrush(GetFaceColor()), GetFacePosition());
色を塗る。
*}
bmp.Save(filePath, System.Drawing.Imaging.ImageFormat.Png);
画像をPNG形式で保存する。
Score = Sd.GetScore();
ScoreDataの中のGetScore関数を呼び出す
gameObject.GetComponent<Renderer>().material.color = Color.red;
マテリアルの色を赤色に変更する
c.RegisterType<ISettingsProvider, SettingsProvider>();
アプリの起動時あたりで、以下のようにアプリで使うインターフェースと実装クラスを登録していく
webImage.Mutate(w => w.Resize(180, 180));
画像をリサイズ
ctx.DrawImage(webImage, new Point(240, 154), 1);
座標を指定して書き込む
ctx.DrawText("MKTaro", font, Color.FromRgb(255, 255, 255), new PointF(240, 90));
テキストを書き込む処理
Parallel.For(0, 10, i => {Console.WriteLine(i.ToString());});
インデックス0から9までの並列処理。
Task.Run(() => {Console.WriteLine("a");});
並列処理を立ち上げる。
var t = Task.Run(() => {Console.WriteLine("a");});
並列処理を立ち上げる。
t.Wait();
処理の終了を待つ
.Select(x => x * x);
2 乗する
{player.CustomProperties.TryAndGetPlayerNum(out int playerNum);return playerNum;}
プレイヤー番号を取得する
{_hashtable[PLAYER_ASSIGN_NUMBER] = assignNum;player.SetCustomProperties(_hashtable);_hashtable.Clear();}
プレイヤーの割り当て番号のカスタムプロパティを更新する
if (photonView.IsMine)
自分のクライアントの同期オブジェクトの時
Player[] otherPlayers = PhotonNetwork.PlayerListOthers;
他の全プレイヤー取得
if (otherPlayers.Length <= 0)
他のプレイヤーがいなければ
SetMyCustomProperties();
プレーヤーのカスタムプロパティ更新
using System.Windows.Media.Media3D;
3D行列使用
HttpClient httpClient = new HttpClient{Timeout = TimeSpan.FromSeconds(15)};
Timeoutの時間も設定できます。
{if (httpResponse.StatusCode == System.Net.HttpStatusCode.OK){imageData = await httpResponse.Content.ReadAsByteArrayAsync();}}
downloadUrlは画像や動画のUrl
imageData = await httpResponse.Content.ReadAsByteArrayAsync();
正常に取得できたというレスポンス（System.Net.HttpStatusCode.OK）ならデータを取得
IFolder DCIMFolder = await FileSystem.Current.GetFolderFromPathAsync(DCIMPath);
DCIMフォルダの取得
ExistenceCheckResult exist = await DCIMFolder.CheckExistsAsync(saveFolderName);
フォルダがすでにあれば取得、なければ新規作成
IFile file = await saveFolder.CreateFileAsync(saveFileName, CreationCollisionOption.ReplaceExisting);
ファイルを新規作成
{stream.Write(imageData, 0, imageData.Length);}
ファイルに画像や動画のByte情報書き込み
string path = Path.Combine(Android.OS.Environment.ExternalStorageDirectory.AbsolutePath, "DCIM");
Xamarin.AndroidでのDCIMパスの取得
MessageBox.Show(("ここに表示したい文字列を入力します。"));
ポップアップwindowを表示する
var service = EdgeDriverService.CreateChromiumService();
ドライバー起動時に表示されるコンソール画面を非表示にする
driver.FindElement(By.Name("pid")).SendKeys("userId");
サイトを開く
RedirectToAction();
遷移したいページに遷移
m_worker.Dispose();
終了時に破棄する
string[] files = Directory.GetFiles(Path.GetFullPath(folderPath), "*.xlsx");
フォルダの中の拡張子が.xlsxのファイルの取得
excel = new Excel.Application();
Excelを起動する
books = excel.Workbooks;
ブック一覧の定義
book = books.Open(file);
ブックを開く
sheets = book.Worksheets;
シート一覧の定義
sheet = sheets[1];
最初のシートの選択
cells = sheet.Cells;
セル一覧の定義
range = cells[2, 1];
セル[2,1]の選択
book.Close(true);
ブックを保存して閉じる
excel.Quit();
Excelを終了する
Marshal.FinalReleaseComObject(range);
定義されたオブジェクトの解放
range3.Merge();
セルの結合
range = sheet.Range["B2:D2"];
セル[B2]から[D2]までの範囲の選択
range.Merge();
セルの結合
range = cells[2, 1];
セル[2,1]の選択
font = range.Font;
フォントの選択
font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.Red);
文字色を赤にする
range = cells[2, 2];
セル[2,2]の選択
border = range.Borders;
罫線選択
border.LineStyle = Excel.XlLineStyle.xlContinuous;
罫線を実線に設定する
border.Weight = 2d;
罫線の太さの設定
services.AddLocalization(options => options.ResourcesPath = "Resources");
ローカリゼーション周りのクラスをDIコンテナに登録する。
string[] supportedCultures = new string[] {"ja", "en"};
サポートするカルチャの設定
Random cRandom = new System.Random();
乱数
Debug.WriteLine($"User Message: {message}");
引数messageの内容を出力
var val = (offsetToMidBaseline.x - minX) / (maxX - minX);
中心位置を計算
point = rotation * point + new Vector3(pos0.x, offsetToMidBaseline.y, pos0.z);
移動と回転を適用
{var angle = (float) (1.5 * Math.PI + (val - 0.5f) * spread * Mathf.Deg2Rad);var x = radius * Mathf.Cos(angle);var z = (flip ? -1 : 1) * radius * (1 + Mathf.Sin(angle));return new Vector3(x, 0, z);}
0~1のvalueに対し，円周上の位置を返す
var deg = i;
境界部での丸め込み
_searchItemQuary.Execute(1);
商品IDが1の商品情報を取得
return item.Execute(_id)
idに紐づいた商品情報を取得
var client = new GitHubClient(new ProductHeaderValue("lr")) {Credentials = tokenAuth};
接続情報の設定
var client = new GitHubClient(new ProductHeaderValue(settings.Owner)) {Credentials = tokenAuth};
接続情報の設定
var createIssue = new NewIssue(issueTitle);
Issueを作成し、本文を設定
var newIssue = await client.Issue.Create(settings.Owner, settings.Repository, createIssue);
Issueを追加
PhotonNetwork.ConnectUsingSettings();
PhotonServerSettingsに設定した内容を使ってマスターサーバーへ接続する
if (stream.IsWriting)
自身のクライアントから相手クライアントの同期オブジェクトに送る情報
{var page = new ContentPage{Content = view};await Application.Current.MainPage.Navigation.PushModalAsync(page);}
フルスクリーンを実現するためのメソッド
return await accountService.CreateAccount();
サーバーにアカウント作成を要求、レスポンスは作成されたユーザIDとパスワード
GrpcEnvironment.SetLogger(new Grpc.Core.Logging.ConsoleLogger());
コンソールにログ出力するように設定
await MagicOnionHost.CreateDefaultBuilder()
MagicOnionを使ってホスト作成、起動
{Logger.Info("CreateAccount Request");var userId = GenerateHash(20);var password = GenerateHash(12);try{if (!Directory.Exists("accounts")) Directory.CreateDirectory("accounts");File.WriteAllText("accounts/" + userId, password);}catch (Exception e){Logger.Error(e, "CreateAccount Error");return (null, null);}Logger.Info($"CreateAccount UserId:{userId}, Password:{password}");return (userId, password);}
アカウント作成
{if (!Directory.Exists("accounts")) Directory.CreateDirectory("accounts");File.WriteAllText("accounts/" + userId, password);}
アカウント情報を仮でファイルに保存(本来はDBに入れる事！)
{Logger.Info("Login Request");try{if (!File.Exists("accounts/" + userId)) return null;if (File.ReadAllText("accounts/" + userId) != password){Logger.Warning("Login failed: " + (userId, password));return null;};}catch (Exception e){Logger.Error(e, "Login Error");return null;}var session = GenerateHash(20);lock (lockObject){sessions[session] = (userId, DateTime.UtcNow.AddDays(1));}Logger.Info("【" + userId + "】Login succeeded!");return session;}
ログイン
if (!File.Exists("accounts/" + userId)) return null;
アカウントがない
if (File.ReadAllText("accounts/" + userId) != password)
パスワードが一致しない
sessions[session] = (userId, DateTime.UtcNow.AddDays(1));
一先ず1日有効なセッションを保存
{return Sha256(Guid.NewGuid().ToString("N")).Substring(0, length).ToLower();}
指定の長さのランダムハッシュ値を取得
AllocConsole();
Console表示
Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = true });
コンソールとstdoutの紐づけを行う。
var connectionString = Parameter.getConnectionString();
DB接続文字列の取得
{connection.Open();try{Database.checkMasterData(models, log, connection);Database.saveData(models, jstTime, log, connection);}catch (Exception exception){log.LogInformation(exception.Message);throw;}finally{connection.Close();}}
データ保存
connection.Open();
データベースの接続開始
Database.checkMasterData(models, log, connection);
マスタテーブルの更新チェック
Database.saveData(models, jstTime, log, connection);
データを保存
connection.Close();
データベースの接続終了
httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", Parameter.getQiitaAccessToken());
OAuth 2.0 Authorization Headerの設定
public static void checkMasterData(List<QiitaInformationModel> models, ILogger log, SqlConnection connection)*{
新たに記事が投稿された場合はマスタテーブルを更新
selectCommand.CommandText = @"SELECT id FROM qiita_items";
SQLの準備
insertCommand.CommandText = @"INSERT INTO qiita_items VALUES (@ID, @TITLE, @CREATED_AT)";
SQLの準備
log.LogInformation($"succeeded to insert master data: {model.Title}");
SQLの実行
transaction.Commit();
コミット
transaction.Rollback();
ロールバック
command.CommandText = @"INSERT INTO page_views_count VALUES (@ID, @COUNTED_AT, @PAGE_VIEWS_COUNT)";
SQLの準備
log.LogInformation($"succeeded to insert data: {model.Title}");
SQLの実行
transaction.Commit();
コミット
transaction.Rollback();
ロールバック
title = type.Name.Replace("Node", "");
クラス名から "Node" を削除したもの
CvOptFlow.UpdateMotionHistory(black_diff, motion_history, timestamp, duration);Cv2.Normalize(motion_history, hist_gray, 0, 255, NormTypes.MinMax, MatType.CV_8UC1);
履歴画像の更新
angle_deg = CvOptFlow.CalcGlobalOrientation(orientation, mask, motion_history, timestamp, duration);
全体的なモーション方向を計算
Cv2.Circle(hist_color,
全体のモーション方向を黄色い線で描画
Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
EncodeをShift-Jisに対応
SerialPort sp = new SerialPort("COM3");
シリアルポート取得
var sw = new System.IO.StreamWriter(PATH, false, System.Text.Encoding.GetEncoding("shift_jis"));*//Arduino側のサンプリング周波数
csv出力
string data = sp.ReadLine();
1行分取得
var remark = ControlAttachedProperty.GetRemark(this.textBlock);
コントロールを指定して添付プロパティを取得、設定する
{get => (string) this.GetValue(TextProperty);set => this.SetValue(TextProperty, value);}
CLR ラッパープロパティ
return String.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, OtherPropertyDisplayName ?? OtherProperty);
エラーメッセージを返す
var mediaType = reader.GetCurrentMediaType(SourceReaderIndex.FirstVideoStream);
元のメディアタイプから動画情報を取得する
var mulPositionOfPercent = Math.Min(Math.Max(positionOfPercent, 0), 100.0) / 100.0;
取得する動画の位置を設定
this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(HogeText)));
データを更新したことを通知する
var hogeData = Application.Current.Resources["HogeDataInstance"] as HogeData;
ナビゲーターの項目を押したタイミングで、HogeDataの内容を更新する
IWebElement el = wait.Until(SeleniumExtras.WaitHelpers.ExpectedConditions.ElementExists(By.Name("q")));
Webページを開く
PdfDocument doc = new PdfDocument();
Pdf ファイルをロードします。
PdfUsedFont[] fonts = doc.UsedFonts;
UsedFontsでフォントを取得します。
Font newfont = new PdfFont(PdfFontFamily.TimesRoman, 18f, PdfFontStyle.Italic | PdfFontStyle.Bold);
新規フォントを作成します。
doc.SaveToFile(Result file);
保存します。
Random rnd = new Random(3);
Randomオブジェクトを作成
public static LogFactory factory = new LogFactory();
staticなLoggerを定義
logger.Info(message);
Logの出力
sa.Style = Spire.Presentation.Diagrams.SmartArtStyleType.SubtleEffect;
スマートアートのタイプを設定します。
IntPtr hWnd = NativeMethods.GetForegroundWindow();
アクティブなウィンドウのデバイスコンテキストを取得
NativeMethods.RECT winRect = new NativeMethods.RECT();
ウィンドウの大きさを取得
var offsetX = bounds.left - winRect.left;
Bitmapの作成
using (var g = Graphics.FromImage(bmp)) {IntPtr hDC = g.GetHdc();Console.WriteLine(winRect);NativeMethods.BitBlt(hDC, 0, 0, bmp.Width, bmp.Height, winDC, offsetX, offsetY, NativeMethods.SRCCOPY);g.ReleaseHdc(hDC);}
Graphicsの作成
IntPtr hDC = g.GetHdc();
Graphicsのデバイスコンテキストを取得
g.ReleaseHdc(hDC);
解放
Test hoge = Hoge;
代入
public delegate void Test();
デリゲート型の変数を宣言
public delegate void Test();Test hoge = delegate(){Console.WriteLine("hoge")};
デリゲートにメソッドの定義を代入
public delegate void Test();Test hoge = delegate(){Console.WriteLine("hoge")};hoge();
デリゲートを実行
var test = list.Select(delegate(int n){ return 0 < n });
匿名メソッド
workbook.LockStructure();
ワークブックの構造を保護
string lenIndicator = Convert.ToString((input.Length), 2);*while (lenIndicator.Length < 9) { lenIndicator = "0" + lenIndicator; }
文字数指示子
entry.eventID = EventTriggerType.PointerDown;
PointerDown(押した瞬間に実行する)イベントタイプを設定
entry.callback.AddListener((x) =>*{Trigger();});
関数を設定
eventTrigger.triggers.Add(entry);
イベントの設定をEventTriggerに反映
btn.onClick.AddListener(BtnEvent);
ボタンクリックしたらボタンイベント関数を呼ぶ
Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
Rayを発射
command.CommandTimeout = 60000;
コマンドがタイムアウトする場合は秒数を変更(ms) デフォルトは 30秒
MethodInfo method = CreateMethodInfo(invInfo);*method.Invoke(null, new object[] { IntPtr.Zero, "Run Invoke", "test1", 0});
Invokeで実行
DlgMessageBox messageBox = (DlgMessageBox)method.CreateDelegate(typeof(DlgMessageBox));
Delegateで実行
Vector3 cross = Vector3.Cross(norm, target);
外積
yield return new WaitForSeconds(_delayTime);
指定した秒数止める
Color color = _sr.color;
カラーを取得
color.a -= _decrease*Time.deltaTime;
α値を減らす
_sr.color = color;
カラーを適応
color.a += _add*Time.deltaTime;
α値を増やす
StartCoroutine("Test");
文字列でコルーチンの名前を書く
StartCoroutine(Test());
コルーチンを関数呼び出しのように書く
StartCoroutine(Test(10,"名前"));
コルーチンを関数呼び出しのように書く
yield return new WaitForSeconds(1f);
処理をここで止めて引数で渡した数値秒経ったら処理をここから再開
var animationInfoHandle = Addressables.LoadAssetAsync<SSpriteAnimationInfo>(ScriptableResources.SPRITE_ANIMATION);
アニメーション情報を読み込む
using NpgsqlConnection con = new NpgsqlConnection(connectionString);
DbConnectionの準備
database.AbortTransaction();
例外時はロールバック
if (gun.magazine > 0) {gun.counter = gun.shotBlazeInterval;} else {gun.counter = gun.shotTimeInterval;}
残弾数があれば連射間隔をカウンタに設定
plane.ClosestParameter(onPlanePoint, out xi, out yi);
射影点での基準平面上での座標を求める
zi = onPlanePoint.DistanceTo(pts[i]);
点の基準平面上での距離を求める
if ((pts[i] - onPlanePoint) * plane.Normal < 0) zi *= -1;*this.x[i] = xi;
基準平面の裏側にあったら負の値にする
alglib.rbfmodel model;
RBF Model を宣言
alglib.rbfcreate(2, 1, out model);
入力が2次元、出力が１次元として RBF Model を初期化
alglib.rbfsetpoints(model, this.samplePlanarCoordsScaled);
サンプル点を RBF Model にセット
alglib.rbfsetalgohierarchical(model, this.rBase, this.nLayers, this.smooth);
RBF Model のパイパーパラメータ設定
alglib.rbfbuildmodel(model, out rep);
RBF Model 構築
Curve[] uCurves = new Curve[U + 1];
U 方向のネットワークスプライン曲線群を作る
Curve[] vCurves = new Curve[V + 1];
V 方向のネットワークスプライン曲線群を作る
ViewEngines.Engines.Clear();
ViewEnginesの削除・登録
var controller = new TestController();
Controller.ControllerContextにMockオブジェクトを設定
transform.DOCurveAround(Vector3.up, new Vector3(2, 0, 0), 90, 3);
(x,y,z)=(2,0,0)を中心に3秒かけて90度回転させる。
actions.Click(panel);
panel1をクリック
var headMessage = new HttpRequestMessage(HttpMethod.Head, url);
URLに対するHTTP HEADリクエストメッセージを作成して送信
conn.Open();
PostgreSQLへ接続
DataRow[] rows =member.AsEnumerable().Except(member2.AsEnumerable(), DataRowComparer.Default).ToArray();
「member」テーブルのみに存在する行を取得
DataRow[] rows2 =member.AsEnumerable().Intersect(member2.AsEnumerable(), DataRowComparer.Default).ToArray();
「member」「member2」テーブル両方に存在する行を取得
Console.WriteLine("source");
sourceを出力
Console.WriteLine("target");
targetを出力
target = source.Where(num => num < 5).ToList();
sourceから5未満のリストを作成
target.Add(num * 5);
5を乗算した値を追加
builder.Services.AddHttpClient<HttpClientService>();
IHttpClientFactory を使用する
delegate void OutputProcess(string str);
string型の引数を受け取り、戻り値はvoidのデリゲート
static void SayHello(string str){Console.WriteLine(str);}
引数のデリゲートに対応したメソッド
void SayHelloWorld(string str, OutputProcess output){output(str);}
引数でもらったデリゲートに対応したメソッドを実行
var outProcess1 = new OutputProcess(Console.WriteLine);
newキーワードでデリゲートを生成
OutputProcess outProcess2 = SayHello;
デリゲートに対応したメソッドを代入
var texture = new Texture2D(maxsize, maxsize, TextureFormat.RGBA32, false);
複数枚の画像を１つにパックする
var texture = new Texture2D(maxsize, maxsize, TextureFormat.RGBA32, false);var spritesheets = new List<SpriteMetaData>();
2.SpriteのMultiple設定をパックした画像から作成
var texture = new Texture2D(maxsize, maxsize, TextureFormat.RGBA32, false);var spritesheets = new List<SpriteMetaData>();var importer = AssetImporter.GetAtPath("Assets" + filename) as TextureImporter;
作成した情報をもとに画像をAtlas化
IEnumerator Event()*{Debug.Log("あいうえお");yield return new WaitUntil(() => Input.GetMouseButtonDown(0));Debug.Log("かきくけこ");}
コルーチン関数"Event"を定義
yield return new WaitUntil(() => Input.GetMouseButtonDown(0));
マウス左クリックを待つ処理
EventManager eventManager = new EventManager();
EventManager のオブジェクトをnewで生成
EventManager eventManager = (new GameObject("適当なオブジェクト名")).AddComponent<EventManager>();
AddComponentでオブジェクトを生成
eventManager.StartCoroutine("Event");
コルーチン呼び出し
var data=CsvParser.Read<MyClass>(@"filepath.csv",Encoding.GetEncoding("Shift_JIS"), ",");
Shift-JISでカンマ区切りのデータを読み込む
CsvParser.Write<MyClass>(data,@"filepath.tsv",Encoding.GetEncoding("Shift_JIS"), "\t");
読み込んだデータをタブ区切りで新しいファイルに書き込む
var descriptor = services.SingleOrDefault(x => x.ServiceType == typeof(DbContextOptions<WeatherContext>));
DB を SQL Server からインメモリーにする
db.WeatherForecasts.AddRange(new WeatherForecast{City = "Tokyo",Summary = "Cold",Date = new DateTime(2020, 1, 1),
データの投入
*var claims = new[]{new Claim(ClaimTypes.Name, "Test user"),};
クレームを作る
b.ConfigureTestServices(services =>{services.AddAuthentication("Test")
認証ハンドラーを設定する
public static DateTime EndOfMonth(this DateTime date)*{return new DateTime(date.Year, date.Month, 1).AddMonths(1).AddDays(-1);}
thisキーワードでDateTimeクラスを拡張することを指定
settings.SetOffScreenRenderingBestPerformanceArgs();*Cef.Initialize(settings);
レンダリングを最適化
cefBrowser.ExecuteScriptAsync("map = mapStart(" + textBox1.Text +"," + textBox2.Text + "," + "10);");
Javascriptの実行
return sales;
結果を返す
shortcut.Save();
ショートカットを作成
FolderBrowserDialog fbd = new FolderBrowserDialog();
FolderBrowserDialogクラスのインスタンスを作成
fbd.RootFolder = Environment.SpecialFolder.Desktop;
ルートフォルダを指定する
private readonly WebView2Controller webView2Controller = new();
WebView2Controllerのインスタンス生成
this.dockPanel.Children.Add(this.webView2Controller.GetWebView2());
DockPanelの子要素にWebView2を追加する
this.AddChild(this.dockPanel);
Windowの子要素にDockPanelを追加する
this.webView2.CoreWebView2.Settings.AreDevToolsEnabled = false;
開発者ツールの無効化
this.webView2.CoreWebView2.Settings.AreDefaultContextMenusEnabled = false;
コンテキストメニュー（右クリックメニュー）の無効化
this.webView2.CoreWebView2.Settings.AreDefaultScriptDialogsEnabled = false;
ダイアログ無効化
this.webView2.CoreWebView2.Settings.IsStatusBarEnabled = false;
ステータスバー非表示
this.webView2.CoreWebView2.Settings.IsBuiltInErrorPageEnabled = false;
内蔵されたエラーページを無効化
this.webView2.CoreWebView2.Settings.IsZoomControlEnabled = false;
ズームコントロールの無効化
string v = File.ReadAllText(path);
Local StateをJsonとして読み込む
byte[] src = Convert.FromBase64String(key);
Base64エンコード
byte[] decryptedKey = ProtectedData.Unprotect(encryptedKey, null, DataProtectionScope.CurrentUser);
DPAPIで復号化
proc.Kill();
byte[] key = GetKey();while (reader.Read()) {if (reader[0].ToString() == "") continue;byte[] encryptedData = GetBytes(reader, 2);byte[] nonce, ciphertextTag;Prepare(encryptedData, out nonce, out ciphertextTag);string password = Decrypt(ciphertextTag, key, nonce);var url = reader.GetString(0);var username = reader.GetString(1);Console.WriteLine("Url : " + url);Console.WriteLine("Username : " + username);Console.WriteLine("Password : " + password + "\n");}
マスターキーを取得
if (reader[0].ToString() == "") continue;
空のデータは無視
byte[] encryptedData = GetBytes(reader, 2);
暗号化されたパスワードをbyte配列で読み込む
string password = Decrypt(ciphertextTag, key, nonce);
パスワードの復号化
public static void Prepare(byte[] encryptedData, out byte[] nonce, out byte[] ciphertextTag) {nonce = new byte[12];ciphertextTag = new byte[encryptedData.Length - 3 - nonce.Length];System.Array.Copy(encryptedData, 3, nonce, 0, nonce.Length);System.Array.Copy(encryptedData, 3 + nonce.Length, ciphertextTag, 0, ciphertextTag.Length);}
暗号化データを初期化ベクトルとパスワードデータに分離
public static string Decrypt(byte[] encryptedBytes, byte[] key, byte[] iv) {string sR = "";try {GcmBlockCipher cipher = new GcmBlockCipher(new AesFastEngine());AeadParameters parameters = new AeadParameters(new KeyParameter(key), 128, iv, null);cipher.Init(false, parameters);byte[] plainBytes = new byte[cipher.GetOutputSize(encryptedBytes.Length)];Int32 retLen = cipher.ProcessBytes(encryptedBytes, 0, encryptedBytes.Length, plainBytes, 0);cipher.DoFinal(plainBytes, retLen);sR = Encoding.UTF8.GetString(plainBytes).TrimEnd("\r\n\0".ToCharArray());}catch (Exception ex) {Console.WriteLine(ex.Message);Console.WriteLine(ex.StackTrace);}return sR;}
AES-256-GCM 復号化処理。暗号化されたパスワード、マスターキー、初期化ベクトルを指定
byte[] src = Convert.FromBase64String(key);
Base64エンコード
private static byte[] GetBytes(SQLiteDataReader reader, int columnIndex)*{const int CHUNK_SIZE = 2 * 1024;byte[] buffer = new byte[CHUNK_SIZE];long bytesRead;long fieldOffset = 0;using (MemoryStream stream = new MemoryStream()){while ((bytesRead = reader.GetBytes(columnIndex, fieldOffset, buffer, 0, buffer.Length)) > 0){stream.Write(buffer, 0, (int)bytesRead);fieldOffset += bytesRead;}return stream.ToArray();}}
SQLiteデータをbyte配列で読み込む
logging.AddNLog(new NLogLoggingConfiguration(hostContext.Configuration.GetSection("NLog")));
appsettings.json から NLog の設定情報を取得する
string baseName = Path.GetFileNameWithoutExtension(ExecuteName);
アセンブリ名を使ってクラス ライブラリーを動的に読み込み
EventInfo eventInfo = _myType.GetEvent("Update");
アセンブリ内のクラスの Update イベントの EventInfo を取得
eventInfo.AddEventHandler(_instance, handler);
EventInfo に対してイベント ハンドラーを追加
btnClose.Enabled = false;
閉じるボタンを無効にする
bgWorker.WorkerReportsProgress = true;
ProgressChangedイベントが発生するようにする
bgWorker.RunWorkerAsync();
処理を開始する
private void btnClose_Click(object sender, EventArgs e){Close();}
画面を閉じる
private void bgWorker_DoWork(object sender, DoWorkEventArgs e)
取込処理
int result = (int)_myType.InvokeMember("Main", BindingFlags.InvokeMethod, null, _instance, new object[] { Arguments.Split(',') });
処理を開始する
e.Result = result;
結果を設定する
private void bgWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
途中経過イベント処理
Invoke((Action)delegate ()*{prbDowork.Value = e.ProgressPercentage;lblTitle.Text = (e.ProgressPercentage).ToString() + " %";});
ProgressBarの値を変更する
lblTitle.Text = (e.ProgressPercentage).ToString() + " %";
タイトルのテキストを変更する
private void bgWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
取込処理が終わったときに呼び出される
prbDowork.Value = prbDowork.Maximum;
正常に終了したとき
btnClose.Enabled = true;
閉じるボタンを有効に戻す
public void OnUpdate(object sender, ProgressChangedEventArgs e)
進捗値の更新
bgWorker.ReportProgress(e.ProgressPercentage);
ProgressChangedイベントハンドラを呼び出し
DialogResult result = MessageBox.Show("実行します。よろしいですか ? ","処理実行",MessageBoxButtons.YesNo,MessageBoxIcon.Question,MessageBoxDefaultButton.Button2);
メッセージボックスを表示する
var alc = new MyAssemblyLoadContext();
AssemblyLoadContextを作成
Assembly a = alc.LoadFromAssemblyPath(assemblyPath);
アセンブリをロード
alcWeakRef = new WeakReference(alc, trackResurrection: true);
外からアンロードを検知するために弱参照を設定
var type = a.GetType("DoWork.frmDoWork");
リフレクションで関数コール
alc.Unload();
アンロード実施
private void SetProgress(int value){ProgressChangedEventArgs e = new ProgressChangedEventArgs(value, null);Update?.Invoke(this, e);}
進捗状況を標準出力に出力する
ProgressChangedEventArgs e = new ProgressChangedEventArgs(value, null);
更新イベントを起こす
while (parent != null && !(parent is ItemsControl) || parent is DataGridCellsPresenter)
指定されたオブジェクトのVisualTree上の親を順番に探索し、ItemsControlを探す。
var item = parentTree.LastOrDefault(x => itemsControl.IsItemItsOwnContainer(x));
ItemsControlの行にあたるオブジェクトを探索履歴の後ろから検索
IList targetList = ((itemsControl.ItemsSource as IList) ?? itemsControl.Items);
Bindingしていた場合はItemsSource、違うならItemsから削除する
if ((index + 1) >= targetList.Count)*return;
最後の行だったら何もしない
if (index <= 0)*return;
最初の行だったら何もしない
this.Invoke(new Action<string>(this.TextChange),"Changed");
フォーム上のテキストをChangedに変更
Thread.Sleep(100)
100ミリ秒待機
PlRig.AddForce(vec, ForceMode.VelocityChange);
Playerに初速を与える
AndroidCustomGridViewAdapter adapter = (AndroidCustomGridViewAdapter)Adapter;
グリッドビューの表示時に、各要素の高さを図る
CustomGridViewLinearLayout.initItemLayout(NumColumns, adapter.Count);
列数と、要素数の設定
adapter.measureItems(columnWidth);
各要素の高さを測定
SetUp(view, viewModels[position]);
要素の作成
itemView.setPosition(index);
測定用のViewを設定
itemView.RequestLayout();
強制的にViewのOnMeasureイベントを発火
StopAllCoroutines();
全てのコルーチンを止める
group.AllowMembersEditMembership = true;
グループのメンバーシップを編集できるユーザー：グループメンバー
rb = this.gameObject.GetComponent<Rigidbody>();
Rigidbodyを入れる
このゲームオブジェクトからコンポーネントを取得<Rigidbodyを指定>
this.gameObject.GetComponent<Rigidbody>();
if (Input.GetKey(KeyCode.UpArrow))
もし、右矢印キーを押していたら、、、
rb.AddForce(Vector3.forward * power);
ワールド空間の正面方向に任意の力を加える
rb.AddForce(Vector3.back * power);
ワールド空間の後ろ方向に任意の力を加える
rb.AddForce(Vector3.right * power);
ワールド空間の右方向に任意の力を加える
rb.AddForce(Vector3.left * power);
ワールド空間の左方向に任意の力を加える
_direction = this.gameObject.transform.position - other.transform.position;
星に向かう向きの取得
_distance = _direction.magnitude;
星までの距離の２乗を取得
_magnetPower = _accelerationScale * _distance;
万有引力計算
_collisionObjRigidbody.AddForce(_magnetPower * _direction.normalized, ForceMode.Force);
力を与える
widgetOptions: {filter_reset: 'button.reset-filter-button',resizable: true,}
フィルタのリセットボタンを追加する場合に設定する。
this.listView1.RetrieveVirtualItem += new RetrieveVirtualItemEventHandler(listView1_RetrieveVirtualItem);
ListViewに仮想モードでデータを更新するイベントを追加
this.listView1.VirtualMode = true;
仮想モードをオンに
Set( Trig: "Boot", SineWave: new SineWave() { Freq = "20.0", Gain = "0.5" } );
Boot状態をトリガーにして、周波数２０ヘルツを出力。
Wait( Trig: "Boot", Next: "A1", Time: 2.0 );
Boot状態をトリガーにして、２秒後にA1状態に遷移。
Set( Trig: "A1", SineWave: new SineWave() { Freq = "60.0", Gain = "0.5" } );
A1状態をトリガーにして、周波数６０ヘルツを出力。
Wait( Trig: "A1", Next: "A2", Time: 2.0 );
A1状態をトリガーにして、２秒後にA2状態に遷移。
Set( Trig: "A2", SineWave: new SineWave() { Freq = "40.0", Gain = "0.5" } );
A2状態をトリガーにして、周波数４０ヘルツを出力。
Wait( Trig: "A2", Next: "End", Time: 4.0 );
A2状態をトリガーにして、４秒後にEnd状態に遷移。
GetWave( Trig: "Boot", Stop: "End", FileName: "test.wav", InId: "0, 1, 2, 3, 4, 5", OutId: "0");
Boot から End まで波形取得
public static SingletonClass GetInstance(){ return _singleInstance; }
インスタンス取得
using(Stream _reqStream = _req.GetRequestStream()){_reqStream.Write(_postData, 0, _postData.Length);
送信データの書き込み
using(WebResponse _response = req.GetResponse()){switch(((HttpWebResponse)_response).StatusCode){case HttpStatusCode.OK:OK時の処理break;
送信及び結果応答確認
command.CommandTimeout = 60000;
コマンドがタイムアウトする場合は秒数を変更(ms) デフォルトは 30秒
adapter = new GridViewAdapter(Context);
Adpterの生成
var gridView = new CustomGridView(new ContextThemeWrapper(Context, Resource.Style.VerticalScrollbarRecyclerView));
GridViewの生成
gridView.LayoutParameters = new LayoutParams(LayoutParams.MatchParent, LayoutParams.MatchParent);
GridViewのパラメータを設定
gridView.Adapter = adapter;
Viewに対しAdpterを設定
SetNativeControl(gridView);
コントロールを実際に生成
public override Android.Views.View GetView(int position, Android.Views.View convertView, ViewGroup parent)*{var view = LayoutInflater.From(parent.Context).Inflate(Resource.Layout.custom_gridview_item, parent, false);SetUp(view, viewModels[position]);return view;}
Countプロパティの数だけ呼ばれるViewを生成する関数
bool isDirection(char c) => return '1' <= c && c <= '9';
方向キーを識別するための関数
private static int ToDirection(int x, int y){var value = 5;if (x > 300) value += 1;if (x < -300) value -= 1;if (y < -300) value += 3;if (y > 300) value -= 3;return value;}
テンキー表記変換をメソッド化
this._keyStream.OnNext(new KeyInfo{Key = ToDirection(this.prevState.X, this.prevState.Y).ToString()[0],
方向切り替わり時に持続フレームを通知
this._keyStream.OnNext(new KeyInfo{Key = ToDirection(state.X, state.Y).ToString()[0],
持続フレームをリセットしつつ新たな方向を押し下げ通知
++this.directionDuration;
方向に変化がなかった場合は持続フレームをインクリメント
this._keyStream.OnNext(new KeyInfo{Key = buttonName[i],Duration = state.Buttons[i] ? 0 : this.buttonsDuration[i],Frame = this.frame,});
押し下げ時は0を、離し時は持続フレームを通知
++this.buttonsDuration[i];
押し下げ継続時は持続フレームをインクリメント
internal static List<UnityWebRequestAsyncOperation> s_ActiveRequests = new List<UnityWebRequestAsyncOperation>();
TODO: ここからUnityWebRequestを取得する
if(moveType == "swing") {transform.Rotate(0, 0, this.rotationSpeed * Time.deltaTime);if (transform.rotation.z >= 0){rotationSpeed = rotationSpeed - rotationAcceleration * Time.deltaTime;}else {rotationSpeed = rotationSpeed + rotationAcceleration * Time.deltaTime;}}
パラメータ rotationSpeed で 回転させた後、rotationSpeedを全体の向きに応じで増減させる。
transform.Rotate(0, 0, deltaDegree);transform.Translate(Vector3.up * Time.deltaTime * rotationSpeed);
ランダムに決定した分(360度表記)回転させた後、向いた方向へ進める。
presentation.SaveToFile("OdptoPDF.pdf",FileFormat.PDF);
OpenDocumentファイルで保存します。
ReadOnlyReactiveProperty<string> MyPropErrorMessage = MyProp.ObserveValidationErrorMessage()
バリデーションが追加されている ReactiveProperty<T> 型の MyProp のバリデーションエラーメッセージを ReadOnlyReactiveProperty にするコード
XxxIntParamEventData ev = (XxxIntParamEventData)eventData;
派生クラスに変換してパラメータを取得
doc.SaveToFile("Result.pcl", FileFormat.PCL);
PCLファイルで保存します。
List<string> sortKeyHierarchy = sortKey.Split('.').ToList();
ソートキーを「.」で分割する。
Func<T, object> orderFunc = x =>*{object val = x;foreach (string key in sortKeyHierarchy){if (val == null){return val;}val = val.GetType().GetRuntimeProperty(key).GetValue(val);}return val;};
リフレクションを使用し、ソート対象となるプロパティ値を引っ張り出す。
camera.Read(src);
撮影画像の読み取り
Cv2.Undistort(src, calib, mtx, dist);
歪み補正
Cv2.CvtColor(calib, tmp, OpenCvSharp.ColorConversionCodes.RGB2BGR);
OpenCVのカラーの並びに変換
var hsv = new Mat();
BGR画像をHSV画像に変換
var msk = new Mat();
inRange関数で範囲指定２値化 -> マスク画像として使う
DobotDll.SetQueuedCmdStartExec();
コマンド開始
var pose = GetCurrentPose();
現在位置を取得
DobotDll.SetQueuedCmdStopExec();
コマンド終了
ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(projectName, projectName + ".exe", true);
アセンブリのモデルを生成する
Screen.orientation = ScreenOrientation.Portrait;
縦画面に固定する場合の設定です
OpenCvSharp.Aruco.CvAruco.DetectMarkers(calib, p_dict, out corners, out ids, detect_param, out rejectedImgPoints);
マーカー検出
OpenCvSharp.Aruco.CvAruco.DrawDetectedMarkers(calib, corners, ids, new Scalar(0, 255, 0));
検出されたマーカ情報の描画
midllePoints.Add(new Point2f(average_X, average_Y));*Console.WriteLine($"marker{cnt} X:{average_X}, Y:{average_Y}");
マーカーの中心座標を取得
midllePoints.ForEach(mp => calib.Circle((int)mp.X, (int)mp.Y, 1, new Scalar(0, 0, 255), 3, LineTypes.AntiAlias
マーカーの中心座標を描画
var camera = new OpenCvSharp.VideoCapture(0){FrameWidth = 1920,FrameHeight = 1080};
webカメラキャプチャ
using (var fs = new FileStorage(YamlFilePath, FileStorage.Mode.Read)){mtx = fs["mtx"].ReadMat();
ymlファイルを読み来み計算パラメータを取得
*var homo = HomographyHelper.FindHomography(srcList, dstList);
射影変換行列を求めて
(double X, double Y) = homo.Translate(667, 241);
入力平面から出力平面上の座標に変換
object shortcut = t.InvokeMember("CreateShortcut", System.Reflection.BindingFlags.InvokeMethod, null, shell,new object[] { shortcutPath });
ショートカットを指定先に作成
System.Diagnostics.Process.Start("EXPLORER.EXE", "/select,\"" + shortcutPath + "\"");
フォルダを開けて見せてあげる
System.Diagnostics.Process.Start(path);
起動
if (System.IO.File.Exists(path))*System.Diagnostics.Process.Start(path);
ファイルの存在確認
var wb = new XLWorkbook();
ワークブックを作成する
DataTable dt = pair.Value;
DictionaryのValue(ここではテーブルデータ)を取得
var ws = wb.Worksheets.Add(dt);
ワークシートを作成する
ws.Name = tableName;
シート名をテーブル名に設定
ws.ColumnsUsed().AdjustToContents();
表全体をまとめて列幅を自動調整する
var builder = new SqlConnectionStringBuilder()
DBに接続する接続文字列の取得
connection.Open();
DBに接続する
string sql = "SELECT * FROM sys.objects WHERE TYPE = 'U';"
全てのテーブル名を取得する
下記のSQLは全テーブル名を取得するsql
SqlDataAdapter adapter = new SqlDataAdapter(sql, connection);
データベースとデータを結ぶSqlDataAdapterを生成
DataSet ds = new DataSet();
データを格納するDatasetを生成
adapter.Fill(ds);
SqlDataAdapter のFillメソッドの引数に Dataset(ds)を渡すことで、sqlで実行したデータがDatasetに格納される
allData[table] = dt;
Dictionaryに格納する
var connectionString = appSettings.AzureStorageConfig.AZURE_STORAGE_CONNECTION_STRING;
設定ファイルから接続文字列を取得
_account = CloudStorageAccount.Parse(connectionString);
ストレージアカウントのオブジェクトを作成
var client = _account.CreateCloudBlobClient();
Blobクライアントを作成
var container = client.GetContainerReference(_appSettings.AzureStorageConfig.ContainerName);
Blobコンテナの参照を取得
await container.CreateIfNotExistsAsync();
Blobコンテナが存在していなかったら作成
var blob = container.GetBlockBlobReference(blobName + ".txt");
引数に指定されたファイル名で作成する
await blob.UploadTextAsync("file content");
引数に指定した内容がファイルに書き込まれる
var document = BrowsingContext.New(Configuration.Default.WithDefaultLoader()).OpenAsync(htmlUrl).Result;
HTMLドキュメントの取得
var credentialStr = Resources.Load<TextAsset>(credential).text;
認証情報をResourceから読み込む
Task.Run(async () => { SetAudioClip(await _client.SynthesizeSpeechAsync(request)); });
リクエストを非同期で送信し，返ってきた後にメソッドに投げる
audioSource.Play();
AudioClipを再生
SynthesisInput input = new SynthesisInput {Text = "目的地は、日本橋です。"};
読み上げテキストの設定
VoiceSelectionParams voice = new VoiceSelectionParams {Name = "ja-JP-Wavenet-D",LanguageCode = "ja-JP",SsmlGender = SsmlVoiceGender.Neutral};
音声タイプの設定
AudioConfig config = new AudioConfig {AudioEncoding = AudioEncoding.Mp3,Pitch = -2.0};
オーディオ出力の設定
var response = client.SynthesizeSpeech(new SynthesizeSpeechRequest {Input = input,Voice = voice,AudioConfig = config});
Text-to-Speech リクエストの生成
var fileName = DateTime.Now.ToString("yyyy-MM-dd_HHmmss") + ".mp3";*using (Stream output = File.Create(fileName)) {response.AudioContent.WriteTo(output);Console.WriteLine($"音声コンテンツを '{fileName}' として保存しました。");}
Text-to-Speech レスポンス（音声ファイル）の保存
XmlTextReader reader = new XmlTextReader(xsdFilePath);
xsdファイルパスから型変換
xmlDocument.Validate(ValidationEventHandler);
スキーマチェック
var mainWindowHandle = Process.GetProcessesByName("notepad")[0].MainWindowHandle;
メモ帳のトップウィンドウのウィンドウハンドル
var hWnd = FindTargetEdit(GetWindow(mainWindowHandle));
対象の編集領域を探す
public static IntPtr FindTargetEdit(Window top)*{var all = GetAllChildWindows(top, new List<Window>());return all.Where(x => x.ClassName == "Edit").First().hWnd;}
全てのEditコントロールを列挙し、最初に見つけたEditコントロールのウィンドウハンドルを返す
return all.Where(x => x.ClassName == "Edit").First().hWnd;
クラス名からコントロールを取得する。メモ帳の場合はEditコントロールが編集領域。
CardController card = Instantiate(cardPrefab, hand, false);
カードの生成とデータの受け渡し
public void ShowMessage()=> this.MessageRequest.Raise(new Notification { Title = "タイトル", Content = "メッセージ" });
このメソッドを呼び出せばダイアログを表示できる
int[] array = { 1, 2, 3 };
配列宣言時に初期化
var list = new List<int>{ 1, 2, 3 };
リスト宣言時に初期化
list.Add(4);
要素の追加
list.RemoveAt(2);
指定した添え字の要素を削除
list.Clear();
全削除
var item = list[1];
要素の取得
a < b
小なり
a > b
大なり
a <= b
以下
a >= b
以上
a == b || c == d,,,x= x + y;
OR
continue;
処理をスキップ
break;
処理を抜ける
public int GetList(ref List<string> strList){byte[,] listBuffer = new byte[5, 10];uint listCount = 0;int status = NativeMethods.GetList(listBuffer , out listCount);string[] StrBufferList = new string[listCount];for (int ii = 0; ii < StrBufferList.Length; ii++){byte[] str = new byte[10];for (int jj = 0; jj < str.Length; jj++){str[jj] = listBuffer[ii, jj];}StrBufferList[ii] = System.Text.Encoding.ASCII.GetString(str).TrimEnd('\0');}strList = new List<string>(StrBufferList);return status;}
文字列リスト取得（文字列配列の変換）
materials[j].color = renderers[i].materials[j].color;
色とテクスチャを反映
var diff = MousePos - Input.mousePosition;
マウスの移動量を取得
smtp.Authenticate("id", "password");
認証設定
var mail = new MimeKit.MimeMessage();
送信するメールを作成する
smtp.Send(mail);
メールを送信する
smtp.Send(mail);
メールを送信する
smtp.Disconnect(true);
SMTPサーバから切断する
void Update(){}
Update is called once per frame
wiringPiSetupGpio();
wiringPiのセットアップ
pinMode(Tack_PIN, INPUT);*CallbackFunc callBackFunc = delegate () {Console.WriteLine("CallbackFunc is called !");};
GPIO をINPUTに設定する.
ret = wiringPiISR(Tack_PIN, INT_EDGE_RISING, callBackFunc);
GPIO がONになったらコールバック関数を呼ぶ.
Thread.Sleep(Int32.MaxValue);
無限に待機する.
using Plugin.TextToSpeech;
プラグインの導入
students.ForEach(r =>{var className = !string.IsNullOrEmpty(classes.Find(x => x.Item1.Equals(r.ClassId)).Item2)
データ内にあるIDをNameに置き換える。対応するものがなかったら空文字。
drawContent.DrawEllipse(Brushes.Yellow, new Pen(Brushes.Green, 3), new Point(50, 50), 10, 10);
丸を描く
var bmp = new RenderTargetBitmap((int)image.Width, (int)image.Height, 96, 96, PixelFormats.Pbgra32);
いろいろ書いたDrawingVisualを、RenderTargetBitmap(BitmapSourceの子クラス)に取り込む
var encoder = new JpegBitmapEncoder();
ファイルに保存
var uri = new Uri(@"input.jpg", UriKind.Relative);
画像を読み込む
drawContent.DrawImage(image, new System.Windows.Rect(0, 0, image.PixelWidth, image.PixelHeight));
画像を書いて、その上にテキストを書く
drawContent.DrawRectangle(Brushes.Red, new Pen(Brushes.Black, 3), new Rect(0, 0, 200, 200));     
四角を描く
drawContent.DrawEllipse(Brushes.Yellow, new Pen(Brushes.Green, 3), new Point(50, 50), 10, 10);   
丸を描く
string rKeyName = @"SYSTEM\CurrentControlSet\Control\TimeZoneInformation";
操作するレジストリ・キーの名前
string rGetValueName = "DynamicDaylightTimeDisabled";
取得処理を行う対象となるレジストリの値の名前
Console.WriteLine("夏時間に合わせて自動的に調整しない：" +　location);
コンソールに取得した値を表示
void OnCollisionStay(Collision collision)*{rb.constraints = RigidbodyConstraints.FreezeRotation| RigidbodyConstraints.FreezePositionY;}
collisionに接触している場合はRotationは全てオン、PositionはY軸のみオンにする。
void OnCollisionExit()*{rb.constraints = RigidbodyConstraints.FreezeRotation;}
collisionに接触してない時はPositionのY軸はオフ。Rotationは全てオンのまま。
Xamarin.Forms.MessagingCenter.Subscribe<Object, string>(this, "StartVoice", StartVoice);
MainPageの開始ボタンか押された場合
Xamarin.Forms.MessagingCenter.Send<Object, string>(this, "EndOfVoice", txt);
音声認識テキストをMainPageに送る
声認識の終了したメッセージを受け取る
MessagingCenter.Send<Object, string>(this, "StartVoice", "StartVoice");
音声開始コマンドをMainActivityに送信
g.FillRectangle(this.backgroundColor, g.VisibleClipBounds);
キャンバスの背景色を設定する。
bmp.Save(filePath, System.Drawing.Imaging.ImageFormat.Png);
画像をPNG形式で保存する。
public void Run(){using(var listenerSocket = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp)){listenerSocket.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.ReuseAddress,true);listenerSocket.Bind(this.ServerEndPoint);listenerSocket.Listen(10);WriteLog($"接続待機開始", $"{listenerSocket.LocalEndPoint.ToString()}");while (true){AllDone.Reset();listenerSocket.BeginAccept(new AsyncCallback(AcceptCallback), listenerSocket);AllDone.WaitOne();}}}
サーバー起動
listenerSocket.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.ReuseAddress,true);
ソケットをアドレスにバインドする
listenerSocket.Listen(10);*WriteLog($"接続待機開始", $"{listenerSocket.LocalEndPoint.ToString()}");
接続待機開始
AllDone.WaitOne();
接続があるまでスレッドを待機させる
private void AcceptCallback(IAsyncResult asyncResult)*{// 待機スレッドが進行するようにシグナルをセットAllDone.Set();// ソケットを取得var listenerSocket = asyncResult.AsyncState as Socket;var clientSocket = listenerSocket.EndAccept(asyncResult);// 接続中のクライアントを追加WriteLog($"接続確認", $"{clientSocket.RemoteEndPoint}");// StateObjectを作成var state = new StateObject();state.ClientSocket = clientSocket;// 受信時のコードバック処理を設定clientSocket.BeginReceive(state.Buffer,0,StateObject.BufferSize,0,new AsyncCallback(ReceiveCallback),state);}
接続受付時のコールバック処理
AllDone.Set();
待機スレッドが進行するようにシグナルをセット
var listenerSocket = asyncResult.AsyncState as Socket;
ソケットを取得
WriteLog($"接続確認", $"{clientSocket.RemoteEndPoint}");
接続中のクライアントを追加
var state = new StateObject();
StateObjectを作成
clientSocket.BeginReceive(state.Buffer,0,StateObject.BufferSize,0,new AsyncCallback(ReceiveCallback),
受信時のコードバック処理を設定
private void ReceiveCallback(IAsyncResult asyncResult){var state = asyncResult.AsyncState as StateObject;var clientSocket = state.ClientSocket;try{int bytes = clientSocket.EndReceive(asyncResult);string category = $"データ受信[{bytes,2}バイト]";string detail;if (bytes > 0){var content = enc.GetString(state.Buffer, 0, bytes);detail = $"\"{content}\"";Regex reg = new Regex("^([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])$");if (reg.IsMatch(content)){detail += $" MACアドレスデータを受信しました。";WriteLog(category, detail);byte[] sendBytes = new byte[HEADLEN + MACLEN * MACCOUNT];int i;for (i = 0; i < HEADLEN; i++){sendBytes[i] = 0xFF;}foreach (Match m in reg.Matches(content)){for (i = 0; i < MACLEN; i++){byte convert = Convert.ToByte(m.Groups[i + 1].Value, 16);for (int j = 0; j < MACCOUNT; j++){sendBytes[HEADLEN + MACLEN * j + i] = convert;}}}UdpClient udp = new UdpClient();udp.Send(sendBytes, sendBytes.Length, this.BroadCastEndPoint);udp.Close();WriteLog($"データ送信", $"マジックパケットを送信しました。");}else{detail += $" 不明なデータを破棄しました。";WriteLog(category, detail);}clientSocket.BeginReceive(state.Buffer,0,StateObject.BufferSize,0,new AsyncCallback(ReceiveCallback),state);}else{clientSocket.Close();WriteLog(category, $"通信を切断しました。");}}catch (SocketException e){if (e.NativeErrorCode.Equals(10054)){clientSocket.Close();WriteLog($"強制切断", $"クライアントが強制切断しました。");}else{WriteLog($"強制切断", $"Error Code {e.NativeErrorCode} : {e.Message}");}}catch (Exception ex){WriteLog($"例外発生", $"{ex.Message}");}}
受信時のコードバック処理
var state = asyncResult.AsyncState as StateObject;
StateObjectとクライアントソケットを取得
int bytes = clientSocket.EndReceive(asyncResult);*string category = $"データ受信[{bytes,2}バイト]";
クライアントソケットから受信データを取得終了
var content = enc.GetString(state.Buffer, 0, bytes);*detail = $"\"{content}\"";
受信した文字列を表示
udp.Send(sendBytes, sendBytes.Length, this.BroadCastEndPoint);
マジックパケットを送信する
udp.Close();
ソケットクローズ
clientSocket.BeginReceive(state.Buffer,0,StateObject.BufferSize,0,new AsyncCallback(ReceiveCallback),
受信時のコードバック処理を再設定
clientSocket.Close();
保持しているクライアントの情報をクリアする
devPlc = new devPlc(axActUtlType1, 1);
PLCとの通信を確立する
binding.ReceiveTimeout = new TimeSpan(240, 0, 0);
10日間クライアントからのリクエストがなくてもタイムアウトしない
svc = new ServiceHost(typeof(Host));
エンドポイントを作成
svc.Open();
サービスホストをスタート
var bitmap = new Bitmap(16, 16);
Bitmapを生成
var graphics = Graphics.FromImage(bitmap);
Graphicsを生成
var graphicsSize = graphics.MeasureString("成就した恋ほど語るに値しないものはない。", Font);
文字列のサイズを計測。
var trueGraphicsSize = graphics.MeasureString("成就した恋ほど語るに値しないものはない。", Font, (int)graphicsSize.Width, StringFormat.GenericTypographic);
文字列のサイズを計測。
panel.Controls.Remove(c);
フォームに登録されたコントロールのオブジェクトを消す
private void AdditionalControlItems1_Click(object sender, EventArgs e)*{Console.WriteLine("items1_Click");Console.WriteLine();}
追加したコンソールのメニューアイテム１番を選択した時のイベントハンドラ
private void AdditionalControlItems2_Click(object sender, EventArgs e)*{Console.WriteLine("items2_Click");Console.WriteLine();}
追加したコンソールのメニューアイテム２番を選択した時のイベントハンドラ
Point mp = MousePosition;
マウスカーソルの位置を画面座標で取得
contextMenuStripOnPanel.Items.Clear();
コンテキストメニューの表示
var copyDoc = new FlowDocument();
新しくFlowDocumentを作成
copyRange.Load(stream, DataFormats.XamlPackage);
MemoryStreamからDesirializeして書き込む
private Vector3 StagePos;
StagePos変数を設定
GameObject resourceButtonObj = Resources.Load("Button") as GameObject;
Resorcesフォルダからプレハブを取得
Resources.UnloadUnusedAssets();
コールバック処理
GameObject obj = this.gameObject;
自身のオブジェクト取得
GameObject canvas = GameObject.Find("Canvas");
オブジェクトを検索して取得
GameObject rootObj = this.transform.root.gameObject;
ルートオブジェクト取得
DontDestroyOnLoad(rootObj);
シーンが移動しても消えないオブジェクトを登録
GameObject[] cubes = GameObject.FindGameObjectsWithTag("cube");
"cube"タグのついたオブジェクトをすべて格納
objChild = this.gameObject.transform.Find("Viewport/Content").gameObject;*// 子オブジェクトの数取得
孫オブジェクトを検索して取得
int a = objChild.transform.childCount;
子オブジェクトの数取得
Button button = child.GetComponent<Button>();
Buttonコンポーネントの取得
button.onClick.AddListener(() => OnClickButton(child));
Buttonコンポーネントにクリックイベント追加
Application.Quit();
アプリケーション終了
GameObject instance = Instantiate(resourceButtonObj, new Vector3(0.0f, 0.0f, 0.0f), Quaternion.identity);
プレハブを元にオブジェクトを生成する
instance.GetComponent<Image>().color = new Color32(255, 0, 0, 128);
Buttonの色を変える
instance.transform.SetParent(objChild.transform);*}
生成したオブジェクトを子として登録
SendMessage("OnClickCreateButton");
メソッドを呼び出す
Destroy(button);
オブジェクトを破棄
int index = buttonObj.transform.GetSiblingIndex();
同階層におけるオブジェクトの順序取得
GameObject parentObj = buttonObj.transform.parent.gameObject;
親オブジェクトを取得
int childMax = parentObj.transform.childCount;
子オブジェクトの数取得
buttonObj.transform.SetSiblingIndex(childMax - 1);
Buttonオブジェクトの順序を一番下に移動
StartCoroutine(ScrollDelay(index));
スクロールバーをコルーチンを使って移動
GameObject obj = this.gameObject.transform.Find("Scrollbar Vertical").gameObject;
子オブジェクトを検索して取得
Scrollbar bar = obj.GetComponent<Scrollbar>();
Scrollbarコンポーネント取得
yield return new WaitForSeconds(0.01f);
0.01秒処理を待つ
yield break;
コルーチン終了
Application.OpenURL(url);
ブラウザでwebページを開く
private IEnumerator DownloadImage(string url)*{WWW www = new WWW(url);yield return www;RawImage img = GameObject.Find("WebRawImage").GetComponent<RawImage>();img.texture = www.texture;}
イメージファイルをダウンロードしてRawImageに表示
PlayerPrefs.SetInt("Player", save.PlayerHP);
PlayerHPデータを保存
string json = JsonUtility.ToJson(save);
セーブデータをJSON形式に変換
PlayerPrefs.SetString("SaveData", json);
セーブデータを保存
string json = PlayerPrefs.GetString("SaveData");
セーブデータを読み込み
JsonUtility.FromJsonOverwrite(json, save);
読み込んだセーブデータをsaveに上書き
PlayerPrefs.DeleteKey("SaveData");
セーブデータを削除
Canvas.SetTop(textBlock, 10);
textBlock に添付プロパティを設定
new Label*{Text = "Hello world",}.Row(1).Column(2).ColumnSpan(2);
Label は Xamarin.Forms で文字列を表示するためのコントロール
public class MainPageViewModel : INotifyPropertyChanged
インターフェースを実装
public event PropertyChangedEventHandler PropertyChanged;
プロパティに変更があったときに発行されるイベント
PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Message)));
プロパティの値が変わったことを PropertyChanged イベントで外部に通知
transform.position = new Vector3(Pos.x + CameraX, Pos.y + CameraY, Pos.z + CameraZ);*}
カメラとプレイヤーの位置を同じにする
class Mbutton : Xamarin.Forms.Button*{public object Tag{get { return (object)GetValue(TagProperty); }set { SetValue(TagProperty, value); }}public static readonly BindableProperty TagProperty =BindableProperty.Create(nameof(Tag), typeof(object), typeof(Mbutton), null);}
Button に　Tag プロパティを追加
List<string> flist = new List<string>()*{"ManyButtons.Images.applications.ico" ,"ManyButtons.Images.audio_file.ico" ,"ManyButtons.Images.back.ico" ,"ManyButtons.Images.button_cancel.ico" ,"ManyButtons.Images.button_ok.ico" ,"ManyButtons.Images.cd.ico" ,"ManyButtons.Images.cdimage.ico" ,"ManyButtons.Images.cdr.ico" ,"ManyButtons.Images.clock.ico" ,"ManyButtons.Images.computer.ico" ,"ManyButtons.Images.configuration_settings.ico" ,"ManyButtons.Images.control_panel.ico" ,"ManyButtons.Images.desktop.ico" ,"ManyButtons.Images.down.ico" ,"ManyButtons.Images.exec.ico" ,"ManyButtons.Images.favorits.ico" ,};
Imagesのファイル定義
void Setup(){var g = new Grid() {HeightRequest=400 };var k = 0;for(var i = 0; i < 4; i++){for (var j = 0; j < 4; j++){if (k < flist.Count){var b = new Mbutton(){Text = $"{k}",Tag = k,ImageSource = ImageSource.FromResource(flist[k]),};b.Clicked += B_Clicked;g.Children.Add(b, j, i);k++;}}}var l=new Label();g.Children.Add(l, 0, 8);Content = g;}
16個のボタンを作成してグリットに配置
SceneManager.LoadScene("GameClear");
クリアシーンを表示
TrailRenderer tr = child.GetComponent<TrailRenderer>();
TrailRendererの情報を取得
paintData.PaintObjectPosition = child.position;
構造体にTrailRendererの座標を格納
paintData.PaintVertices = posArray;
構造体にTrailRendererの頂点座標の配列を格納
_materialPropertyBlock.SetColor(_propertyID,tr.material.color);
構造体に色情報を格納
paintDataWrapper.DataList.Add(paintData);
構造体をリストに追加
JsonDataManager.Save(paintDataWrapper);
シリアライズ
PaintDataWrapper paintDataWrapper =  JsonDataManager.Load();
デシリアライズ
paintObjTrailRenderer.AddPositions(paintData.PaintVertices);
全ての頂点を復元
_materialPropertyBlock.SetColor(_propertyID, paintData.PaintColor);
色情報を復元
void BtnClick(object s,EventArgs e){label.FontSize = 64;label.Text = DateTime.Now.ToString("HH:mm:ss");}
イベントハンドラの定義追加
label.Text = DateTime.Now.ToString("HH:mm:ss");
ラベルのTextに時刻を表示します。
label.FontSize = 64;
font size指定
void BtnClick(object s, EventArgs e){Button b = s as Button;label.FontSize = 64;b.IsEnabled = false;Device.StartTimer(TimeSpan.FromSeconds(1),()=> {label.Text = DateTime.Now.ToString("HH:mm:ss");return true;});}
イベントハンドラの定義追加
Device.StartTimer(TimeSpan.FromSeconds(1),*()=> {label.Text = DateTime.Now.ToString("HH:mm:ss");return true;});
タイマーインタラプトルーチン
var mock = new Mock<IFooSample>();
Mockを作成(インターフェースを指定)
mock.Setup(foo => foo.DoSomething("ping")).Returns(true);
関数名と戻り値を指定
var fooObject = new FooSample(mock.Object);
評価対象クラスにMockを渡す
Assert.IsTrue(fooObject.DoSomething("ping"));
評価対象クラスで関数コール
Instantiate(PrefabObject, pos, Quaternion.identity);
オブジェクト、位置(省略可)、無回転（省略可）
watcher.Stop();
スキャン終了
CLIENT_ID = HttpContext.Request.Query["client_id"].ToString();
要求URLパラメータ取得
var client = await _context.Clients.FindAsync(CLIENT_ID);*if (client == null) {return Redirect("#error=unauthorized_client&error_description=client authentication failed.");}
要求URLパラメータclient_idチェック
string random = Guid.NewGuid().ToString("N").ToUpper();
access_token発番(token)
string refresh = Guid.NewGuid().ToString("N").ToUpper();
refresh_token発番(code)
string param = "&state="+STATE;
応答URLパラメータにstateを引き継ぐ
var code = new Code {CodeId = random, UserId = User.Identity.Name, ClientId = CLIENT_ID, Nonce = NONCE, Iat=DateTime.Now};
認可コード(code)を発行
access_token = new Token {UserId = User.Identity.Name, AccessToken = random, ClientId = CLIENT_ID, Scope = SCOPE, Iat=DateTime.Now};
有効期限60秒固定のaccess_tokenを発行
param = "#access_token=" + random + "&token_type=bearer" + param;
応答URLパラメータを生成
var claims = new[] {new Claim(JwtRegisteredClaimNames.Sub, User.Identity.Name),new Claim(JwtRegisteredClaimNames.Nonce, NONCE)};
共通関数にてIDトークン(id_token)を生成
param = "#id_token=" + id_token + param;
応答URLパラメータを生成
return Redirect(REDIRECT_URI + param);
応答をリダイレクト
var force = new Vector3(a, 0f, b);
(x, y, z)平面方向がx,z上空方向がy
var request = new GraphQLRequest{Query = query,OperationName = "MyQuery",Variables = variables,};
リクエスト作成
var response = await this.GraphQLHttpClient.SendQueryAsync<JObject>(request);
Query実行
rangeValuePattern.SetValue(50000);
スクロール位置の変更
string secretId = "hubspot-client-secret";
hubspotアプリのclientsecretを指定
CreateLogfile(new FileInfo(logFilePath));
ログファイルを生成する
CompressLogFile();
ログファイルを圧縮する
DeleteOldLogFile();
古いログファイルを削除する
texture.ToRenderTexture().GaussianFilter5X5().ExtractEdge();
デノイズ処理を行い，その結果からエッジを抽出
dbAccess.AddMessage("ごちそうさま");
新しいメッセージを追加
dbAccess.UpdateMessage(testId, "おはようございます");
メッセージを変更
dbAccess.DeleteMessage("おはようございます");
メッセージを削除
get { return _num; }
外部に値を返す
string body = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync();
POSTパラメータ取得
var client = await _context.Clients.FindAsync(CLIENT_ID);*if (client == null) {return new AccessToken {error = "unauthorized_client", error_description="client authentication failed."};}
POSTパラメータclient_idチェック
var rsa = (RSACryptoServiceProvider)cert.PrivateKey;
秘密鍵の取り出し
var signature = rsa.SignData(byteData, HashAlgorithm.Create("SHA256"));
署名実行
var rsa = (RSACryptoServiceProvider)cert.PublicKey.Key;
公開鍵の取り出し
var result = rsa.VerifyData(byteData, HashAlgorithm.Create("SHA256"), signature);
検証実行
StreamWriter sw = new StreamWriter(Server.MapPath("~/init.log"), true, Encoding.GetEncoding("Shift_JIS"));
ログ・ファイルへの出力ストリームを生成
GameObject field = Instantiate(fields) as GameObject;
Prefabを作成
LineRenderer line = gameObject.GetComponent<LineRenderer>();
線オブジェクト設定
line.startWidth = 0.1f;
線の幅を指定
line.positionCount = 2;
頂点の数を指定
line.SetPosition(0, Vector3.zero);
開始位置と終了位置を指定
int[] arr = new int[100];
100個のint型要素が入る配列を生成。
if (e.KeyChar == 's' && paddlePos.Right < this.Width)
Sキー押下時
var arc = CalcArc.Calc(subContour);
円弧を計算
.ToArray();
配列にする
int lenNow = Encoding.GetEncoding("Shift_JIS").GetByteCount(txt.Text);
桁数取得
MessageBox.Show(ex.Message);
メッセージを表示
using (var pngbmp = new Bitmap("touka.png"))
bitmap画像を開く
g.DrawImage(pngbmp, 5, 5, pngbmp.Width, pngbmp.Height);
画像を(5,5)の位置に描画する
bmp.Save(@"output.bmp");
保存する
CloudAppendBlob appendBlob_download = container.GetAppendBlobReference(filename);
ダウンロードするファイル名を指定
string path = Directory.GetCurrentDirectory() + "\\log\\" + DateTime.Now.ToString("yyyyMMdd") + ".log";
ダウンロード後のパスとファイル名を指定。
int b = a;
値を代入
string b = a;
stringの代入
List<int> b = new List<int>(a);
値型のListをコンストラクタでnew
List<List<int>> b = new List<List<int>>(a);
多重Listをコンストラクタでnew
var s = Template(i, j);
文字列を作る
var keys = GetKeys(template);
テンプレートからキーの部分のみを取り出す
PivotMeasure<MockData>.Average("Avg.Cash",(t)=>t.cash),
cashの平均値
child[i] = parent.transform.GetChild(i).gameObject;
子オブジェクト取得
var printerName = ConfigurationManager.AppSettings["PrinterName"];
印刷するプリンタ名を取得
var text = Windows.Storage.ApplicationData.Current.LocalSettings.Values["Key"].ToString();
UWPから渡ってきた値を取得する
float randomValueA = Random.Range(-1.0f, 1.0f);
ランダムな値
float randomMagnification = Random.Range(0.0f, 5.0f);
ランダムな値
Vector3 randomPos = new Vector3(randomValueA, randomValueB, randomValueC);
ランダムな位置にキューブ生成
MeshRenderer mr = tmp.GetComponent<MeshRenderer>();
MaterialPropertyBlockで色を変更　元のマテリアルの色はそのまま
Vector3 worldClickPos = Camera.main.ScreenToWorldPoint(Input.mousePosition +  Camera.main.transform.forward);
スクリーン座標をワールド座標に変換
int vertCount =  tr.GetPositions(posArray);
全ての頂点を取ってくる
this.Controls.Add(cefBrowser);
コントロールを追加する。
int month = random.Next(1, 13);
無作為に選ぶ
db.Posts.RemoveRange(db.Posts.ToArray());
テーブルを空にする
this.Controls.Add(panel4);
フォーム上にパネルpanel4を追加
Vector2 spos = RectTransformUtility.WorldToScreenPoint(Camera.main, trfTarget.position);
World座標をUI座標へ変換
var imgsize = new Vector2(trfTarget.rect.width * trfTarget.localScale.x,trfTarget.rect.height * trfTarget.localScale.y);
左下を計算上のpivotにする
g.RotateTransform(-90f);
-90度回転
rb = GetComponent<Rigidbody>();
自分のRigidbodyを格納して参照する
hitCount++;
インクリメント hitCountという整数の値に１を足すこと
UnityEditor.Events.UnityEventTools.AddPersistentListener(hogehogeEvent, TestCallback);
ボタンにイベントを登録する.
hogehogeEvent.Invoke();
イベントの呼び出し
Func<int, int, int> func1 = Add;
関数をデリゲートに登録
Func<int, int, int> func2 = (x, y) => x + y;
ラムダ式で作った関数を登録
private float Reciprocal(int x)*{return 1.0f / x;}
逆数を返す関数
var matchArticle = wpList.FirstOrDefault(w => w["content"]["rendered"].ToString().Contains(url));
Qiitaの記事URLが含まれる物を取得
await Task.WhenAll(tasks);
10個のタスクが終わるまで待つ
Vector3 dir = player.transform.position - transform.position;
方向ベクトルを取得
float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg;
var calApi = new CalendarAPITest(@"C:\job\TestProject\GoogleAPITest\testproject-269217-813bf9be17a5.json");
Googleカレンダーテストクラスインスタンス化
calApi.ReadEvents(calendarId);
イベント読み取り
var evt = calApi.InsertEvent(calendarId);
イベント追加
calApi.UpdateEvent(calendarId, evt);
イベント更新
calApi.DeleteEvent(calendarId, evt.Id);
イベント削除
theString.Should().Be(string.Empty);
Fluent Assertions で文字列が空文字であることを確認する例
theInt.Should().BeInRange(0, 10);
Fluent Assertions で対象の値が0以上10以下であることを確認する例
theInt.Is(value => value >= 0 && value <= 10);
Chaining Assertion で対象の値が0以上10以下であることを確認する例
catch(Exception e)
例外が起きた場合の処理
throw new Exception();
意図的に例外を投げる
var request  = context.Request;
リクエストとレスポンス処理用のインスタンス取得。
conn.Open();
接続文字列を利用してSQLDatabaseに接続
private void MyTxt_TextChanged(object sender, TextChangedEventArgs e){}
テキストが変化したときのイベント
alfa = Mathf.MoveTowards(alfa, 0f, fadeSpeed * Time.deltaTime);
不透明度を徐々に下げる
SetColor();
変更した透明度を画像に反映させる関数を呼ぶ
alfa = Mathf.MoveTowards(alfa, 1f, fadeSpeed * Time.deltaTime);
不透明度を徐々に上げる
void SetColor(){fadeImage.color = new Color(red, green, blue, alfa);}
画像に色を代入する関数
public void SetRGBA(int r, int g, int b, int a){red = r;green = g;blue = b;alfa = a;}
色の値を設定するための関数
var original = RenderTexture.active;
RenderTextureからTexture2Dに変換
int p1Index = Triangles[id.x * 3];
3角ポリゴンをつくる3頂点のインデックスを取得
float2 uv1 = UVs[p1Index];
3頂点に対応したuv座標を取得
void drawline(uint2 p1, uint2 p2, float4 color) {int2 diffp12 = int2(p2.x-p1.x, p2.y-p1.y);float distp12 = distance(p1, p2);for (int i = 0; i < distp12; i++){UVMap[p1 + diffp12 / distp12 * i] = color;}}
2点間に線を引く
rb.AddForce(1.0f, 2.0f, -1.0f);
加える力のベクトルをVectorで入れる
.OrderByDescending(s => s.id)
TodayNow = DateTime.Now;
時間を取得
var histogram = new int[256];
画像色用256配列を用意
AudioCurveRendering.AudioMinMaxCurveAndColorEvaluator dlg = delegate (float x, out Color col, out float minValue, out float maxValue){if (numSamples <= 0)
描画内容定義
float p = Mathf.Clamp(x * (numSamples - 2), 0.0f, numSamples - 2);
minMaxDataの現在のx座標に対応する値を取得
Console.WriteLine(pe.StandardOutput);
標準出力の結果を出力
this.textBox1.Clear();
標準出力エリアのクリア
alfa -= fadeSpeed * Time.deltaTime;
不透明度を徐々に下げる
SetColor();
変更した透明度を画像に反映させる関数を呼ぶ
alfa += fadeSpeed * Time.deltaTime;
不透明度を徐々に上げる
void SetColor(){fadeImage.color = new Color(red, green, blue, alfa);}
画像に色を代入する関数
public void SetRGBA(int r, int g, int b, int a){red = r;green = g;blue = b;alfa = a;}
色の値を設定するための関数
fadeManager = ManageObject.GetComponent<SceneFadeManager>();
オブジェクトの中のSceneFadeManagerを取得
fadeManager.fadeOutStart(0, 0, 0, 0, "Scene2");
SceneFadeManagerの中のフェードアウト開始関数を呼び出し
trimFood = food.TrimStart();
先頭のみトリミング
trimFood = food.TrimEnd();
末尾のみトリミング
fav = fav.Replace("Movie", "Running");
文字列の置き換えを行う
gameObject.Destroy();
自身を破壊
gameObject.SetPositionX(float x);
X座標を設定します
gameObject.SetPositionY(float y);
Y座標を設定します
gameObject.SetPositionZ(float z);
Z座標を設定します
gameObject.AddPositionX(int x);
X座標を加算します
gameObject.AddPositionY(int y);
Y座標を加算します
gameObject.AddPositionZ(int z);
Z座標を加算します
gameObject.ResetPosition();
座標を0にリセットします
Texture2D tex2D=rt.CreateTexture2D(Camera camera);
レンダラーテクスチャからテクスチャ2Dを生成する
Sprite sprite=tex2D.CreateSprite();
Texture2DからSpriteを作成
GameObject[] game=GameObjectUtils.FindContainsName(string name);
指定した文字列が含まれているオブジェクトを取得
T t=RandomUtils .RandomArray<T>(T[] array);;
配列の中の要素をランダムで返す
T t=RandomUtils .RandomList<T>(List<T> list);
listの中の要素をランダムで返す
bool flag=RandomUtils .BoolValue();
ランダムでtrueかfalseを返す
DebugUtils.Log(string message);
ログを出力
DebugUtils.Log(string message, Color color);
色を変更してログを出力
DebugUtils.Log(string message, float size,Color color);
サイズと色を変えてログを出力
DebugUtils.LogError(string message);
エラーログを出力します
DebugUtils.LogWarning(string message);
警告ログを出力します
DebugUtils.ArrayLog(T[] array);
配列のログを出します
builder.AddConsole();
コンソールログを追加
builder.AddDebug();
デバッグログを追加
builder.AddEventLog();
イベントログを追加
builder.AddEventSourceLogger();
イベントソースを追加
builder.AddProvider(new SampleLoggerProvider());
独自のログプロバイダを追加
builder.AddFilter("System", LogLevel.Warning);
カテゴリに対してフィルタを設定
listener.EventSourceCreated += listener_EventSourceCreated;
イベントハンドラを使ってイベントソースが生成されたときの処理とログが書き込まれたときの処理を行うことも可能です。
Program2 obj = new Program2();
Program2のインスタンスを生成
this.sampleEntities.Database.EnsureDeleted();
接続文字列記載のデータベースを削除
this.sampleEntities.Database.EnsureCreated();
接続文字列記載のデータベースを作成
var chunk_binary_str = ToBinary(chunk_array);
バイナリに変換
string text1 = textBox1.Text;
各テキストボックスの値を取得
DateTime Today = dateTimePicker1.Value;
日付を取得
fbDialog.Description = "週報保存先フォルダを選択";
ダイアログの説明文を指定する
textBox1.ResetText();
全てのテキストボックスの値をクリアする
this.textBox5.Clear();
標準入力エリアのクリア
this.textBox1.Clear();
標準出力エリアのクリア
services.Configure<SampleOption>(context.Configuration);
コンフィグを登録
services.AddSingleton<IService, SampleService>();
サービスを登録
ClassA classA = new ClassA();
クラスをインスタンス化しクラスの変数に格納
sqlCom.ExecuteNonQuery();
SQLを実行
MouseDonwStartPoint = e.GetPosition(MyScrollViewer);
クリックした位置を保存
double offsetX = MouseCurrentPoint.X - MouseDonwStartPoint.X;
移動開始点と現在位置の差から移動量を算出
Matrix matrix = ((MatrixTransform)MyTarget.RenderTransform).Matrix;
動かす対象の図形からMatrixオブジェクトを取得
matrix.Translate(offsetX, offsetY);
TranslateメソッドにX方向とY方向の移動量を渡し移動後の状態を計算
MyTarget.RenderTransform = new MatrixTransform(matrix);
移動後の状態を計算したMatrixオブジェクトを描画に反映する
MouseDonwStartPoint = MouseCurrentPoint;
移動開始点を現在位置で更新する
matrix.ScaleAt(scaleDelta, scaleDelta, orgX, orgY);
中心を指定して対象を拡大
Image img = Image.FromFile("outQR.png");
画像を読み込む
e.Graphics.DrawImage(img, e.MarginBounds);
画像を描画する
logger.Info("test message for info");
ログの書き込み
LogManager.Shutdown();
ロガーの終了
var rect = new Rectangle(0, 0, bmp.Width, bmp.Height);
画像のピクセルを byte[] にコピーする
Task<string> task_get = GetRequest(RequestURL);
URLでHTMLを取得する。
float canvasScale = transform.root.localScale.z;
ルートのスケール値を取得する
string[] args = Environment.GetCommandLineArgs();
コマンドライン引数を取得
static int Add(int a,int b){return a + b;}
2つの整数の加算結果を返すメソッド
Player_Nav = GetComponent<NavMeshAgent>();
プレイヤーのNavMeshAgentを取得
Destination = GameObject.Find("Destination");
オブジェクトを取得
var middles = JoinAndCalcProductPrice(inputs, products);
中間エンティティを用いて1レコードごとの価格を計算する。
var castA = new CastA();
CastA型でインスタンス化する
var deserializer = new Deserializer();
デシリアライザインスタンス作成
var deserializeObject = deserializer.Deserialize<YamlData>(input);
yamlデータのオブジェクトを作成
Parallel.ForEach();
並列処理実行
transaction.Sign(bitcoinPrivateKey, false);
署名する
var result = await client.GetStringAsync(url);
JSONを受け取って独自クラスにコンバートする
speak.cancelPlay();
音声再生をキャンセルする
switchGPIO(4, 1);.
LEDを点灯する
Thread.Sleep(1000);
1秒待機
switchGPIO(4, 0);
LEDを消灯する
Thread.Sleep(1000);
1秒待機
wiringPiSetupGpio();
wiringPiのセットアップ
pinMode(14, OUTPUT);
GPIO 14をOUTPUT(1)に設定する
pinMode(15, OUTPUT);
GPIO 15をOUTPUT(1)に設定する
pinMode(18, PWM_OUTPUT);
GPIO 18をPWM_OUTPUT(2)に設定する
digitalWrite(14, 0);
初期状態としてモーターを停止する.
Thread.Sleep(3000);
3秒待機する
pwmWrite(18, 512);
3秒待機する.
await onClickAsync?.Invoke();
クリックされた時の処理を実行
ResponseJson response = new ResponseJson();
レスポンス生成
var dlg = mainWindow.WaitForNextModal();
モーダルダイアログが表示されるのを確実に待ち合わせる
async.WaitForCompletion();
非同期で実行したモーダルボタン押下の処理が完全に終了するのを待つ
int Inc(int x) => x+1;
+1して返すだけの関数
v.AddRange(app);
v配列に appデータを増やす
Marshal.FreeCoTaskMem(pStructure);
確保したアンマネージドメモリの解放
udp.BeginReceive(UdpServer, udp);
非同期的な受信を開始する
private void UdpServer(IAsyncResult ar)*{UdpClient udp = (UdpClient)ar.AsyncState;for (;;){//一度非同期受信を終了するIPEndPoint remoteEP = null;byte[] rcvBytes = udp.Receive(ref remoteEP);//受信したデータを文字列に変換string rcvMsg = System.Text.Encoding.UTF8.GetString(rcvBytes);//"exit"を受信したら終了if (rcvMsg == "exit"){break;}D = rcvMsg.Split(' ');for(i=0;D[i]== null; i++){d[i] = int.Parse(D[i]);}//受信したデータをTextBoxに表示するstring displayMsg = string.Format("{0}", rcvMsg);richTextBox1.BeginInvoke(new Action<string>(ShowReceivedString1), displayMsg);X_Data.BeginInvoke(new Action<string>(ShowReceivedString_x), D[0]);Y_Data.BeginInvoke(new Action<string>(ShowReceivedString_y), D[1]);Z_Data.BeginInvoke(new Action<string>(ShowReceivedString_z), D[2]);}rcvMsg = "終了しました";//UdpClientを閉じるudp.Close();richTextBox1.BeginInvoke(new Action<string>(ShowReceivedString1), rcvMsg);}
データを受信した時の処理
IPEndPoint remoteEP = null;
一度非同期受信を終了する
string rcvMsg = System.Text.Encoding.UTF8.GetString(rcvBytes);
受信したデータを文字列に変換
string displayMsg = string.Format("{0}", rcvMsg);
受信したデータをTextBoxに表示する
udp.Close();
UdpClientを閉じる
*g.DrawImage(img, 10, 10, 48, 48);
変数名, 設置する座標X, 設置する座標Y, 画像の幅Width, 画像の高さHeight);
_httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("bearer", savedToken);
HTTPの認証用のトークンを設定
return new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity(new[] { new Claim(ClaimTypes.Name, userID) }, "apiauth")));
認証情報を返す
await _localStorage.SetItemAsync("userID", userID);
ローカルストレージに認証情報を保持して変更通知を行う
var roles = await _localStorage.GetItemAsync<List<string>>("roles");
保存したロールを取得
Type tEditorApplication = typeof(EditorApplication);
ApplicationTitleDescriptorのTypeを取得
Type delegateType = typeof(Action<>).MakeGenericType(tApplicationTitleDescriptor);
Action<object>をAction<ApplicationTitleDescriptor>に変換
Regex reg_preprocessorSymbols = new Regex("<DefineConstants>(.*)</DefineConstants>", RegexOptions.Compiled);
プロジェクトからシンボル一覧を取得しIEnumerable<string>に変換します
c.IncludeXmlComments(GetXmlCommentsPath());
XMLファイルを読込む
PhotonNetwork.ConnectUsingSettings();
PhotonServerSettingsに設定した内容を使ってマスターサーバーへ接続する
fl.Commit(true);
最後にCommitすると変更が反映される
MethodInfo methodInfo = typeof(Test).GetMethod(nameof(TargetMethod));
呼び出すメソッド情報を取得
ParameterExpression valueArg = Expression.Parameter(typeof(int).MakeByRefType());
out引数を定義(MakeByRefTypeを使う)
cell.CellStyle = cellStyle;
セルのスタイルを保存
OneofDescriptor oneofField = message.Descriptor.FindDescriptor<OneofDescriptor>("oneof_field");
名前を指定してDescriptorを取得する
FileStream file = File.Create(SaveFilePath);
指定したパスにファイルを作成
bf.Serialize(file, player);
指定したオブジェクトを上で作成したストリームにシリアル化する
if (file != null*file.Close();
ファイル操作を明示的に破棄
FileStream file = File.Open(SaveFilePath, FileMode.Open);
指定したパスのファイルストリームを開く
SavePlayerData player = (SavePlayerData)bf.Deserialize(file);
指定したファイルストリームをオブジェクトにデシリアライズ。
Vector3 vTgt = target.position - player.position;
ターゲットへのベクトル
ILogger logger = LogManager.GetCurrentClassLogger();
NLogに出力
Type cType = Type.GetType("UI_Module.TestFunc");
クラスの型取得
MethodInfo m = cType.GetMethod("Func1");
クラスのメソッド取得
object obj = Activator.CreateInstance(cType);
インスタンス化
m.Invoke(obj, null);
メソッド実行
bool isOk = dialog.WaitClose();
ボタンが押されて閉じられるまで待つ
var publicKeyReader = new PemReader(new StringReader(publickey));
PEMフォーマットの公開鍵を読み込んで KeyParam を生成
rsa.Init(true, publicKeyParam);
RSA暗号オブジェクトを初期化
byte[] encrypted = rsa.ProcessBlock(bytes, 0, bytes.Length);
対象のバイト列を渡し暗号化した結果のバイト列を受け取る
IHtmlDocument doc = parser.ParseDocument(HTMLtext);
HTMLの文字列を分解します
string s = Console.ReadLine();
文字列の入力
long n = long.Parse(Console.ReadLine());
整数の入力
string[] inputStrArray = Console.ReadLine().Split(' ');
文字列配列の入力
long[] inputLongArray = Console.ReadLine().Split(' ').Select(i => long.Parse(i)).ToArray();
整数配列の入力
text.text = "文字";
テキストの文字を変更
File.WriteAllText(FilePath, s);
文字列をファイルに保存
SaveFile(resultstr);
ファイルの保存
var serializer = new DataContractJsonSerializer(typeof(ServerResponse));
得られたjsonを解析する
Array.Resize<byte>(ref encryptKey, AesBlockByteSize);
AES暗号化キーの長さを強制的に16バイトで切る
aes.BlockSize = AesBlockBitSize;
AES暗号化の設定
Image tiffImage = Image.FromFile("test.tiff");*Image[] imgs = SplitImages(tiffImage);
tiffをロードします。
page.Canvas.DrawImage(pdfImg, x, 0, pageSize.Width,pageSize.Height);
PDFで画像を描きます。
pdfDoc.SaveToFile("result.pdf");
Pdfで保存します。
img.Density = new Density(densityX, DensityUnit.PixelsPerInch);
解像度を設定
img.FilterType = ImageMagick.FilterType.Lanczos;
フィルター指定
img.Resize((int)Math.Ceiling(newWid), toHeight);
リサイズ実行
GetWindow<EditorWindowScript>("SceneEditWindow");
エディタウインドウ生成
pdf.SaveToFile("ToHtml.html", FileFormat.HTML);
htmlで保存します。
StartCoroutine("OnSend", URL);
コルーチンを呼び出す
string base1_str = Convert.ToString(base1, 2).PadLeft(8, '0');
8桁の二進数にする。
base1_str = base1_str.Substring(4, 4); 
下位4ビットのみ取得。
viewer.ClipboardHandler += this.OnClipBoardChanged;
イベントハンドラを登録
fontDialog1.Color = richTextBox1.ForeColor;
フォントの色を設定
fontDialog1.FontMustExist = true;
存在しないフォントやスタイルをユーザーが選択するとエラーメッセージを表示する
fontDialog1.AllowVerticalFonts = false;
横書きフォントだけを表示する
fontDialog1.ShowColor = true;
色を選択できるようにする
fontDialog1.ShowEffects = true;
取り消し線、下線、テキストの色などのオプションを指定可能にする
fontDialog1.FixedPitchOnly = false;
固定ピッチフォント以外も表示する
fontDialog1.AllowVectorFonts = true;
ベクタ フォントを選択できるようにする
richTextBox1.SelectionFont = fontDialog1.Font;
フォントを設定する
Destroy(gameObject);
オブジェクトを消す
enemyNameGenerator.ResetUsageHistory();
履歴を削除
g.SmoothingMode = SmoothingMode.AntiAlias;
アンチエイリアスを掛ける
WriteableBitmap bitmap = new WriteableBitmap(width, height);
サーマル画像を作成
this.MLX90640_DumpEE();
EEPROM読み出し
if (aCube.TargetPosition.x > 3.0f) aCube.TargetPosition.x = 0.0f;
ある程度右へ行ったら最初の位置へ
analogWrite(LED_PIN, 250);
点灯
backgroundWorker1.CancelAsync();
スレッドの終了を待機
LineSeries.Points.Add(new DataPoint(1.0, 10.0 + 10.0 * i));
点を追加
Model.Series.Add(LineSeries);
線グラフをモデルに追加
_Callee.Sup();
メソッドの呼び出し.
player.Play();
再生
player.Stop();
停止
SceneView.onSceneGUIDelegate += onSceneGUIDelegate;
シーンビュー上のイベントを取得するためのメソッドを追加
var center = new Vector2(scene.position.width, scene.position.height) * 0.5f;
カーソルの画面中央からの差を計算
var pivot = scene.pivot;
カメラの中心を拡大率に比例してカーソル方向に動かす
var replyMsg = client.WriteLineAndGetReply(textBox_SendMsg.Text + '\0', TimeSpan.FromSeconds(3));
終端文字を追加する
GC.Collect();
明示的にGCを呼び出す
Array.Sort(measuredTicks);
中央値を取得
private static AutomationElement FindElementById(AutomationElement rootElement, string automationId)*{return rootElement.FindFirst(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.AutomationIdProperty, automationId));}
指定したID属性に一致するAutomationElementを返します
private static IEnumerable<AutomationElement> FindElementsByName(AutomationElement rootElement, string name)*{return rootElement.FindAll(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.NameProperty, name)).Cast<AutomationElement>();}
指定したName属性に一致するAutomationElementをすべて返します
private static IEnumerable<AutomationElement> FindButtonsByName(AutomationElement rootElement, string name)*{const string BUTTON_CLASS_NAME = "Button";return from x in FindElementsByName(rootElement, name)where x.Current.ClassName == BUTTON_CLASS_NAMEselect x;}
指定したName属性に一致するボタン要素をすべて返します
private static AutomationElementCollection FindElementsByControlType(AutomationElement rootElement, ControlType controlType)*{return rootElement.FindAll(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.ControlTypeProperty, controlType));}
指定したControlType属性に一致する要素をすべて返します
var waitAnimation = AnimationUtils.LoadAnimation(this, Resource.Animation.wait_animation);
アニメーション開始
starImage.Animation.AnimationEnd += (sender, e) => {// 星画像を非表示にするstarImage.Visibility = Android.Views.ViewStates.Gone;selectedDateLabel.Text = time.ToString("yyyy年MM月dd日")+ $"\r\nあなたは、{GetEto(time.Year)}年 {GetSeiza(time.Month, time.Day)}です。";};
アニメーション完了イベント
_workbook.Worksheets.Select();
全シートを選択する
process.Start();
プロセスの実行
process.WaitForExit();
終了まで待ってから切断する
Vector3.Cross(tmp1, tmp2);
外積を求めるメソッド
private float[] CalculateEquationOfPlane(Vector3 vec1, Vector3 vec2, Vector3 vec3, Vector3 normal) {float[] ans = new float[]{normal.x,normal.y,normal.z,-normal.x * vec1.x - normal.y * vec1.y - normal.z * vec1.z};return ans;}
vec1,vec2,vec3の3点を通る平面の方程式
private Vector3 CalculateCoordinateOfIntersection(float[] plane, Vector3 angle, Vector3 position) {float parameter = -(plane[0] * position.x + plane[1] * position.y + plane[2] * position.z + plane[3]) / (plane[0] * angle.x + plane[1] * angle.y + plane[2] * angle.z);float x = angle.x * parameter + position.x;float y = angle.y * parameter + position.y;float z = angle.z * parameter + position.z;return new Vector3(x, y, z);}
カメラの視線とメッシュとの交点の座標が求める
float x = gameObject.transform.localEulerAngles.x;
カメラが向いている方向
float cameraRotationY = gameObject.transform.localEulerAngles.y;*Vector3 pos = (points[0] + points[1] + points[2] + points[3] + points[12] + points[13] + points[14] + points[15]) / 8;
カメラが前後左右のどこを向いているか取得
htmlAttributes.Add("class", "custom");
アトリビュートの追加
Xlsx = new Xlsx();
Xlsxインスタンス生成
GetTemplateConfig();
テンプレートの情報取得
Xlsx.OpenBook(filename, @"e:\book1.xlsx");
ワークブックオープン
Xlsx.SheetNo = Xlsx.SheetNo2["Sheet1"];
ワークシート設定
excelEC.Xlsx.Pos[sx:0, sy:1].Value = "test";
セル書込
var cellValue1 = excelEC.Xlsx.Pos[sx: 0, sy: 1].Value;
セル読取
var cellValue2 = excelEC.Xlsx.Cell["A2"];
セル読取("A1"形式)
excelEC.Xlsx.Cell["A1:C3"].Attr.Box(XlsxCrt.XLSX_BORDERSTYLE.xbsThin, XlsxCrt.XLSX_BOXTYPE.xbtBox, XlsxCrt.XLSX_COLOR.xclRed);
罫線を引く("A1:C3"に、実線、箱型、赤色で)
timer = CreateTimer();
タイマー生成
var t = new DispatcherTimer(DispatcherPriority.SystemIdle);
タイマー生成
t.Interval = TimeSpan.FromMilliseconds(300);
タイマーイベントの発生間隔を300ミリ秒に設定
timer.Start();
タイマー開始
Employee empl_1 = new Employee("ichiro", 25, 123456, "system");
インスタンスを生成
_workbook.SaveCopyAs(@"e:\book2.xlsx");
ファイル名を指定して保存する
var cells = _worksheet.Cells;
セルを指定
range.Value = value;
値を設定
Marshal.ReleaseComObject(range);
cell解放
var fileInfo = new FileInfo(@"e:\book1.xlsx");
Excelファイルを開く
_excelWorksheet = _excelPackage.Workbook.Worksheets["Sheet1"];
シート名で参照
_excelWorksheet.Cells[row, col].Value = value;
値を書込
_excelWorksheet.Cells[address].Value = value;
値を書込
return _excelWorksheet.Cells[row, col].Value;
セル読取
return _excelWorksheet.Cells[address].Value;
セル読取
return (object[,])_excelWorksheet.Cells[rowFrom, colFrom, rowTo, colTo].Value;
レンジ読取
return (object[,])_excelWorksheet.Cells[addresso].Value;
レンジ読取
this.Controls.Add(pdfOcx);
フォームにコントロールを追加
pdfOcx.LoadFile(@"E:\test.pdf");
PDF ブラウザコントロールに指定したPDFファイルを表示する
var files = (string[])e.Data.GetData(DataFormats.FileDrop, false);
DataFormats.FileDropを与えて、GetDataPresent()メソッドを呼び出す。
if (e.Data.GetDataPresent(DataFormats.FileDrop))
マウスポインター形状変更
frame = new Mat(HEIGHT, WIDTH, MatType.CV_8UC3);
取得先のMat作成
bmp = new Bitmap(frame.Cols, frame.Rows, (int)frame.Step(), System.Drawing.Imaging.PixelFormat.Format24bppRgb, frame.Data);
表示用のBitmap作成
slider = EditorGUILayout.Slider("Scale In Lightmap", slider, 0, 20);
Scale In Lightmapの値を設定
graphics.SmoothingMode = SmoothingMode.HighQuality;
アンチエイリアスをかける
var gp = new GraphicsPath();
GraphicsPathを生成
pcPanel.SetActive(true);
PCパネルをアクティブにする
g_listObj.Add(m_tmpListObj[(int)m_randomValue]);
選んだオブジェクトをリスト化する
m_randomValue = Random.Range(0, m_tmpListObj.Count);
ここでどれが選ばれるかランダムに決める
m_tmpListObj[(int)m_randomValue].GetComponent<PanelSelectedEvent>().BlinkPanel();
選ばれたときのイベント呼び出し
var image = Instantiate (imagePrefab, transform).GetComponent<Image> ();*var text = Instantiate (textPrefab, transform).GetComponent<Text> ();
プレファブからオブジェクトを生成
RegistryKey regKey = rootKey.OpenSubKey(keyname, true);
書き込み権限で開く
bmp.Save(filePath, System.Drawing.Imaging.ImageFormat.Png);
画像をPNG形式で保存する。
param.Add("TargetData", Visibility.Visible);
パラメータをkeyとvalueの組み合わせで追加
DataRow[] rows =member.AsEnumerable().OrderBy(x => x["Age"])
Ageを昇順にソート
rows =member.AsEnumerable().OrderByDescending(x => x["Age"])
Ageを降順にソート
rows =member.AsEnumerable().OrderBy(x => x["Age"])
複数項目（AgeとAddress）でのソート
COMPOSITIONFORM info = new COMPOSITIONFORM();
コンポジションウィンドウの位置を設定
info.dwStyle = CFS_RECT;
IMEウィンドウ領域の設定
ImmReleaseContext(Handle, hImc);
コンポジションウィンドウのフォントを設定
char chars[] =originstr.ToCharArray();
originstrの中身を、一文字ずつ配列に入れる
int sum = intList.Sum();
合計値
double ave = intList.Average();
平均値
int count = intList.Count();
要素数
int max = intList.Max();
最大値
int min = intList.Min();
最小値
public int Param1{set{this._param1 = value;}get{return this._param1;}}
SetterとGetterを定義する。
var axis = (100, 200, 300);
tupleによる代入
string rcvMsg = System.Text.Encoding.UTF8.GetString(rcvBytes);
データを文字列に変換する
udp.Close();
UdpClientを閉じる
ufo = new UFO();
インスタンスを生成する
Vector3 dir = (ballTrans.position - arrowTrans.position);
向きたい方向を計算
var drawRect = new Rect(r.x, r.y, r.width, r.height - border);
中央にスプライト領域を描画
Label getFollowerName = new Label();
Labelインスタンス生成
command.CommandText = query;
コマンドのセット
command.ExecuteNonQuery();
コマンドの実行
transaction.Commit();
コミット
transaction.Rollback();
ロールバック
con.Close();
データベースの接続終了
public static  IList<Piece> PieceList = new List<Piece> {new Piece(new char[,] {{ ' ','X',' ' },{ 'X','X','X' },{ ' ','X',' ' },}),new Piece(new char[,] {{ ' ','F','F' },{ 'F','F',' ' },{ ' ','F',' ' },}),...,,,public class Piece {// 一つのピースの配列の空白以外の場所の位置を記憶public IList<Point> Points { get; private set; }// 回転、反転させた全てのパターンを列挙（コンストラクタで設定）public IList<Piece> AllSeries { get; private set; }//  ピースのサイズpublic int YSize { get; set; }public int XSize { get; set; }// ピースの形を示す文字public char Char { get; private set; }// 右に90度回転public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point {X = pt.Y, Y = this.XSize - pt.X - 1}).OrderBy(pt => pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}// 左右に反転public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point {X = pt.X, Y = this.YSize - pt.Y - 1}).OrderBy(pt => pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}// 回転、反転の８つのピースを得る （左右対称なら４つ）private IEnumerable<Piece> AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j < 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j < 3; j++) {mirror = mirror.R90();yield return mirror;}}}},,,public bool Solve(int xSize, int ySize) {_board = new Board(xSize, ySize);return Solve(Piece.PieceList);}// 解を求める （再帰メソッド）private bool Solve(IEnumerable<Piece> pieceList) {// 最初のピースを取り出すvar piece = pieceList.FirstOrDefault();if (piece == null)// すべてのペースを使い切った(つまり成功)return true;// ピースを回転、反転させたものを取り出し試していく。foreach (var curr in piece.AllSeries) {// すべての位置を順に取り出す、そこにcurrを置いていくforeach (var topleft in _board.AllPoints) {// 取り出した位置(左上)にピースを置いてみるif (Put(topleft, curr)) {if (CountEmpty().Any(n => n % 5 != 0)) {// 5で割り切れない空き領域があれば、そこにピースははめ込むことができない。// 枝刈り処理 これ以上試しても仕方が無いので、次を試す。Remove(topleft, curr);continue;}var newlist = pieceList.Where(o => o.Char != curr.Char).ToList();// 置けたら残りのピースで同じことを繰り返すif (Solve(newlist) == true)// 成功したら処理を終えるreturn true;// 状態を戻して、次を試すRemove(topleft, curr);}}}return false;},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {public struct Point {public int X { get; set; }public int Y { get; set; }// 上下左右の位置を列挙public IEnumerable<Point> GetAroundPoints() {yield return new Point { X = this.X, Y = this.Y + 1 };yield return new Point { X = this.X + 1, Y = this.Y };yield return new Point { X = this.X - 1, Y = this.Y };yield return new Point { X = this.X, Y = this.Y - 1 };}// BoardにPieceを置く際に利用する。public Point Add(Point pt) {return new Point {X = X + pt.X,Y = Y + pt.Y};}public override int GetHashCode() {return Value;}public int Value {get { return X + Y * 100; }}}},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {public class Piece {public IList<Point> Points { get; private set; }public IList<Piece> AllSeries { get; private set; }public int YSize { get; set; }public int XSize { get; set; }public char Char { get; private set; }private Piece() {}public Piece(char[,] piece) {YSize = piece.GetUpperBound(1) + 1;XSize = piece.GetUpperBound(0) + 1;Points = GetAllPoints().Where(pt => piece[pt.X, pt.Y] != ' ').OrderBy(pt => pt.Value).ToList();var first = Points[0];Char = piece[first.X, first.Y];AllSeries = this.AllCandidates().Distinct(_pieceComparer).ToList();}// 右に90度回転public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point { X = pt.Y, Y = this.XSize - pt.X - 1 }).OrderBy(pt => pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}// 左右に反転public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point { X = pt.X, Y = this.YSize - pt.Y - 1 }).OrderBy(pt => pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}// ピースの全ての位置を列挙するprivate IEnumerable<Point> GetAllPoints() {for (int xx = 0; xx < this.XSize; xx++) {for (int yy = 0; yy < this.YSize; yy++) {yield return new Point { X = xx, Y = yy };}}}// 回転、反転の８つのピースを得る （左右対称なら４つ）private IEnumerable<Piece> AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j < 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j < 3; j++) {mirror = mirror.R90();yield return mirror;}}}private static PieceComparer _pieceComparer = new PieceComparer();// 利用するピースデータpublic static  IList<Piece> PieceList = new List<Piece> {new Piece(new char[,] {{ ' ','X',' ' },{ 'X','X','X' },{ ' ','X',' ' },}),new Piece(new char[,] {{ ' ','F','F' },{ 'F','F',' ' },{ ' ','F',' ' },}),new Piece(new char[,] {{ 'I','I','I','I','I' },}),new Piece(new char[,] {{ 'L',' ' },{ 'L',' ' },{ 'L',' ' },{ 'L','L' },}),new Piece(new char[,] {{ 'N',' ' },{ 'N',' ' },{ 'N','N' },{ ' ','N' },}),new Piece(new char[,] {{ 'P','P' },{ 'P','P' },{ 'P',' ' },}),new Piece(new char[,] {{ 'T','T','T' },{ ' ','T',' ' },{ ' ','T',' ' },}),new Piece(new char[,] {{ 'U',' ','U' },{ 'U','U','U' },}),new Piece(new char[,] {{ 'V',' ',' ' },{ 'V',' ',' ' },{ 'V','V','V' },}),new Piece(new char[,] {{ 'W',' ',' ' },{ 'W','W',' ' },{ ' ','W','W' },}),new Piece(new char[,] {{ ' ','Y' },{ 'Y','Y' },{ ' ','Y' },{ ' ','Y' },}),new Piece(new char[,] {{ 'Z','Z',' ' },{ ' ','Z',' ' },{ ' ','Z','Z' },}),};}},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {public class Board {private char[,] _box;int _xSize;int _ySize;// コンストラクタprivate Board(Board board) {this._xSize = board._xSize;this._ySize = board._ySize;this._box = board._box.Clone() as char[,];}// コンストラクタpublic Board(int xmax, int ymax) {_box = new char[xmax + 2, ymax + 2];_xSize = xmax + 2;_ySize = ymax + 2;foreach (var pt in GetPointsIncludeFrame()) {if (IsValidPoint(pt))this[pt] = ' ';elsethis[pt] = '*';}}// 枠も含めてすべての位置を列挙するprivate IEnumerable<Point> GetPointsIncludeFrame() {for (int yy = 0; yy < this._ySize; yy++) {for (int xx = 0; xx < this._xSize; xx++) {yield return new Point { X = xx, Y = yy };}}}private List<Point> _AllValidPoint = null;// 枠を除いた位置を列挙するpublic IEnumerable<Point> AllPoints {get {if (_AllValidPoint == null) {var list = new List<Point>();for (int yy = 1; yy < this._ySize - 1; yy++) {for (int xx = 1; xx < this._xSize - 1; xx++) {list.Add(new Point { X = xx, Y = yy });}}_AllValidPoint = list.OrderBy(pt => pt.X + pt.Y).ToList();}return _AllValidPoint;}}// インデクサpublic char this[Point pt] {get { return _box[pt.X, pt.Y]; }set { _box[pt.X, pt.Y] = value; }}// Boardの内容をプリントするpublic void Print() {var ystr = new string(Enumerable.Repeat('-', _xSize-2).ToArray());Console.WriteLine($"+{ystr}+");for (int y = 1; y < _ySize - 1; y++) {Console.Write("|");for (int x = 1; x < _xSize - 1; x++) {Console.Write(_box[x, y]);}Console.WriteLine("|");}Console.WriteLine($"+{ystr}+");}// 複製をつくるpublic Board Clone() {return new Board(this);}// 有効な位置か （枠ならばfalse)internal bool IsValidPoint(Point point) {return ((1 <= point.X && point.X < _xSize - 1) &&(1 <= point.Y && point.Y < _ySize - 1));}// Boardの内容を変更してしまうので注意。元の状態に戻すのは呼び出す側の責務とする。// Pointのの位置に注目した時に、いくつの空白があるかをカウントする。pointも含める。// 再帰的に処理をしている。internal int CountEmpty(Point point) {if (this[point] != ' ')return 0;this[point] = '#';int count = 1;foreach (var pt in point.GetAroundPoints()) {if (this[pt] == ' ') {count += CountEmpty(pt);}}return count;}}},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {// 2つのピースを比較するクラスpublic class PieceComparer : IEqualityComparer<Piece> {public bool Equals(Piece a, Piece b) {return a.Points.SequenceEqual(b.Points);}public int GetHashCode(Piece obj) {return obj.Points.Aggregate(0, (hc, pt) => hc ^ pt.GetHashCode());}}},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {public class Pentomino {private Board _board;// 問題を解くpublic bool Solve(int xSize, int ySize) {_board = new Board(xSize, ySize);return Solve(Piece.PieceList);}// 解を求める （再帰メソッド）private bool Solve(IEnumerable<Piece> pieceList) {// 最初のピースを取り出すvar piece = pieceList.FirstOrDefault();if (piece == null)// すべてのペースを使い切った(つまり成功)return true;// ピースを回転、反転させたものを取り出し試していく。。foreach (var curr in piece.AllSeries) {// すべての位置を順に取り出す、そこにcurrを置いていくforeach (var topleft in _board.AllPoints) {// 取り出した位置(左上)にピースを置いてみるif (Put(topleft, curr)) {if (CountEmpty().Any(n => n % 5 != 0)) {// 5で割り切れない空き領域があれば、そこにピースははめ込むことができない。// 枝刈り処理 これ以上試しても仕方が無いので、次を試す。Remove(topleft, curr);continue;}var newlist = pieceList.Where(o => o.Char != curr.Char).ToList();// 置けたら残りのピースで同じことを繰り返すif (Solve(newlist) == true)// 成功したら処理を終えるreturn true;// 状態を戻して、次を試すRemove(topleft, curr);}}}return false;}// ピースをBoardから取り除くprivate void Remove(Point topleft, Piece piece) {foreach (var pt in piece.Points) {var point = topleft.Add(pt);_board[point] = ' ';}}// ピースを指定位置に置くpublic bool Put(Point basePlace, Piece piece) {List<Point> save = new List<Point>();foreach (var pt in piece.Points) {var point = basePlace.Add(pt);if (_board.IsValidPoint(point) &&  _board[point] == ' ') {_board[point] = piece.Char;save.Add(point);} else {// やっぱり置けなかったので、元に戻す。foreach (var p in save)_board[p] = ' ';return false;}}return true;}// プリントpublic void Print() {_board.Print();}// 空いている領域の面積を列挙する。private IEnumerable<int> CountEmpty() {var bclone = _board.Clone();var pts = bclone.AllPoints.Where(pt => bclone[pt] == ' ').ToArray();return pts.Select(pt => bclone.CountEmpty(pt)).Where(cnt => cnt > 0);}}},,,using System;namespace PentominoApp {class Program {static void Main(string[] args) {Pentomino solver = new Pentomino();Console.WriteLine(DateTime.Now);solver.Solve(12, 5);Console.WriteLine(DateTime.Now);solver.Print();Console.ReadLine();}}},,,*public IList<Point> Points { get; private set; }// 回転、反転させた全てのパターンを列挙（コンストラクタで設定）public IList<Piece> AllSeries { get; private set; }//  ピースのサイズpublic int YSize { get; set; }public int XSize { get; set; }// ピースの形を示す文字public char Char { get; private set; }// 右に90度回転public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point {X = pt.Y, Y = this.XSize - pt.X - 1}).OrderBy(pt => pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}// 左右に反転public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point {X = pt.X, Y = this.YSize - pt.Y - 1}).OrderBy(pt => pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}// 回転、反転の８つのピースを得る （左右対称なら４つ）private IEnumerable<Piece> AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j < 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j < 3; j++) {mirror = mirror.R90();yield return mirror;}}}}
一つのピースの配列の空白以外の場所の位置を記憶
public IList<Piece> AllSeries { get; private set; }
回転、反転させた全てのパターンを列挙（コンストラクタで設定）
public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point {X = pt.Y, Y = this.XSize - pt.X - 1}).OrderBy(pt => pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}
右に90度回転
public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point {X = pt.X, Y = this.YSize - pt.Y - 1}).OrderBy(pt => pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}
左右に反転
private IEnumerable<Piece> AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j < 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j < 3; j++) {mirror = mirror.R90();yield return mirror;}}}
回転、反転の８つのピースを得る （左右対称なら４つ）
public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point { X = pt.Y, Y = this.XSize - pt.X - 1 }).OrderBy(pt => pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}
右に90度回転
private IEnumerable<Point> GetAllPoints() {for (int xx = 0; xx < this.XSize; xx++) {for (int yy = 0; yy < this.YSize; yy++) {yield return new Point { X = xx, Y = yy };}}}
ピースの全ての位置を列挙する
private IEnumerable<Piece> AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j < 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j < 3; j++) {mirror = mirror.R90();yield return mirror;}}}
回転、反転の８つのピースを得る （左右対称なら４つ）
private IEnumerable<Point> GetPointsIncludeFrame() {for (int yy = 0; yy < this._ySize; yy++) {for (int xx = 0; xx < this._xSize; xx++) {yield return new Point { X = xx, Y = yy };}}}
枠も含めてすべての位置を列挙する
public IEnumerable<Point> AllPoints {get {if (_AllValidPoint == null) {var list = new List<Point>();for (int yy = 1; yy < this._ySize - 1; yy++) {for (int xx = 1; xx < this._xSize - 1; xx++) {list.Add(new Point { X = xx, Y = yy });}}_AllValidPoint = list.OrderBy(pt => pt.X + pt.Y).ToList();}return _AllValidPoint;}}
枠を除いた位置を列挙する
public void Print() {var ystr = new string(Enumerable.Repeat('-', _xSize-2).ToArray());Console.WriteLine($"+{ystr}+");for (int y = 1; y < _ySize - 1; y++) {Console.Write("|");for (int x = 1; x < _xSize - 1; x++) {Console.Write(_box[x, y]);}Console.WriteLine("|");}Console.WriteLine($"+{ystr}+");}
Boardの内容をプリントする
public class PieceComparer : IEqualityComparer<Piece> {public bool Equals(Piece a, Piece b) {return a.Points.SequenceEqual(b.Points);}public int GetHashCode(Piece obj) {return obj.Points.Aggregate(0, (hc, pt) => hc ^ pt.GetHashCode());}}
2つのピースを比較するクラス
UpdateLevel(expArray);
値の更新
var members = groupPrincipal.Members.OfType<UserPrincipal>();
名前やメールアドレスを取得できる
string ShopDomain = "sample.myshopify.com";
自分のShopify ECサイトドメイン
System.Net.IPEndPoint localEP =new System.Net.IPEndPoint(localAddress, localPort);
UdpClientを作成し、ローカルエンドポイントにバインドする
string rcvMsg = System.Text.Encoding.UTF8.GetString(rcvBytes);
データを文字列に変換する
udp.Close();
UdpClientを閉じる
var ndarray1 = NdArray.Create(new double[24], new int[]{2, 3, 4});
一次元のT型配列＋シェイプを表すint型配列から作ります
var ndarray2 = NdArray.Create(new double[2, 3, 4]);
多次元配列を直接渡しても作れます
var ndarray3 = mndarray1.ToImmutable();
ToImmutableはコピーによる生成。
var ndarray4 = mndarray2.MoveToImmutable();
MoveToImmutableはムーブによる生成。効率がいい代わりにもとのMutableNdArray<T>を破壊します。
var result1 = A.Zip(B, (a, b) => a + b);
LinqのZipメソッドの適用
subsystem[0] = WindowsGUISubsystem;
WindowsGUISubsystem(2)の書き込み
yield return webRequest.SendWebRequest();
URLに接続して結果が戻ってくるまで待機
timer = this.CreateSubject<int>(timerKey);
SubjectPoolに追加
var config = SpeechConfig.FromSubscription(KEY, REGION);
Azure情報の設定
if (!string.IsNullOrEmpty(PROXY_HOST))config.SetProxy(PROXY_HOST, PROXY_PORT);
Proxyの設定
using (var audioInput = AudioConfig.FromWavFileInput(wavefile)){using (var recognizer = new SpeechRecognizer(config, audioInput)){recognizer.Recognizing += (s, e) =>
SpeechToTextの開始
{var scale = bounds.extents;var hoseiW = (PaddingLeft + PaddingRight) / 10;var hoseiH = (PaddingTop + PaddingBottom) / 10;this.Background.transform.localScale = new Vector3((scale.x / 10 * 2) + hoseiW, 1, (scale.y / 10 * 2) + hoseiH);}
描画サイズの計算
BinaryReader reader = new BinaryReader(File.OpenRead(<ファイル名>));
インスタンス生成
ret = reader.Read(buf, 0, 4);
4byte読み取り
writer.Write(buf);
書き込み
StreamReader reader = new StreamReader(<ファイルパス>, Encoding.GetEncoding("Shift_JIS"));*,,,
エンコーディング指定(Shift_JISを指定する場合)
line = reader.ReadLine();
ファイルから1行read
writer.WriteLine("TextFileWriteSample");
文字列を書き込む
Rootobject rootobject = SlackSendMessage.SendMessage("リモート接続監視");
スラックに投稿
return _samples.FirstOrDefault(_ => _.Id == id);
普通にラムダ式で呼び出し、変数のキャプチャ有り
return _samples.FirstOrDefault((x, state) => x.Id == state, id);
拡張メソッドを利用、変数のキャプチャ無し
bool Func(Sample s) => s.Id == id;
ローカル関数経由で呼び出し、変数のキャプチャ有り
CultureInfo.CurrentCulture = CultureInfo.GetCultureInfo("en-US");
カレントカルチャを英語にする(Twitter データの曜日が英語なので)
var session = OAuth.Authorize("hogehoge", "piyopiyo");
Twitter アプリのコンシューマーキーとシークレット
Console.WriteLine("Access to {0}, and get PIN code.", session.AuthorizeUri.AbsoluteUri);
アプリ認証用URLを表示させる
var token = OAuth.GetTokens(session, pin);
認証させる
var dateTime = GetDate(date);*Console.WriteLine("ここまで消します:{0}", dateTime.ToString());
DateTime構造体を取得しておく
var json = JArray.Parse(file);
パースしてあげる。
token.Statuses.Destroy(Convert.ToInt64(item.ID));
削除APIを叩く
Console.ReadLine();
入力待ち
XDocument xml = XDocument.Load(Path.Combine(Directory.GetCurrentDirectory(), @"XMLFile1.xml"));
ファイルを読み込んで XDocument に置換しXDocument をカスタムモデルにデシリアライズ
var doc = XmlConvert.SerializeXDocument(myModel);
カスタムモデルを XDocument にシリアライズしXDocument を XML 形式でファイルに書き込み
var str = XmlConvert.SerializeObject(myModel);
カスタムモデルを文字列にシリアライズ
routedEventHandler = new RoutedEventHandler(AssociatedObject_MouseDown);
ButtonBase.ClickイベントのRoutedEventHandlerを登録する
routedEventHandler = new RoutedEventHandler(AssociatedObject_MouseDown);
UIElement.MouseUpEventイベントのRoutedEventHandlerを登録する
textbox = driver.FindElement(By.Name("q"));
Webページを開く
driver.Navigate().GoToUrl("https:www.google.co.jp/");
検索ボックス
textbox.SendKeys("Selenium");
検索ボックスに検索ワードを入力
findbuttom = driver.FindElement(By.Name("btnK"));
検索ボタン
findbuttom.Click();
検索ボタンをクリック
_startPoint = e.GetPosition(OperationArea);
GetPositionメソッドで現在のマウス座標を取得し、マウス移動開始点を更新
_currentPoint = e.GetPosition(OperationArea);
マウスの現在位置座標を取得
double offsetX = _currentPoint.X - _startPoint.X;
移動開始点と現在位置の差から、MouseMoveイベント1回分の移動量を算出
Matrix matrix = ((MatrixTransform)Target.RenderTransform).Matrix;
動かす対象の図形からMatrixオブジェクトを取得
matrix.Translate(offsetX, offsetY);
TranslateメソッドにX方向とY方向の移動量を渡し、移動後の状態を計算
Target.RenderTransform = new MatrixTransform(matrix);*// 移動開始点を現在位置で更新する
移動後の状態を計算したMatrixオブジェクトを描画に反映する
_startPoint = _currentPoint;
移動開始点を現在位置で更新する
boldFont = new Font(baseFont.FontFamily, baseFont.Size, baseFont.Style | FontStyle.Bold);
実行順序を変えるとtab幅がおかしくなるので注意
FastestMedian(InputGrayImage , MedianImage ,5);
入力，出力，n*nのブロックでフィルタ
DirectorySize += GetDirectorySize(di);
サブフォルダのサイズを合算
startEvent.Invoke();
ここにトリガーをオンにするイベントを登録
terrainData.SetHeightsDelayLOD(hx, hy, heights);
ハイトマップに反映
PhotonNetwork.ConnectUsingSettings(null);
Photonに接続する(引数でゲームのバージョンを指定できる)
PhotonNetwork.JoinRandomRoom();
ルームに入室する
void OnPhotonRandomJoinFailed() {Debug.Log("ルームの入室に失敗しました。");PhotonNetwork.CreateRoom("myRoomName");}
ルームの入室に失敗すると呼ばれる
PhotonNetwork.CreateRoom("myRoomName");
ルームがないと入室に失敗するため、その時は自分で作る
textbox = driver.FindElement(By.Name("q"));
Webページを開く
textbox.SendKeys("Selenium");
検索ボックスに検索ワードを入力
findbuttom = driver.FindElement(By.Name("btnK"));
検索ボタン
findbuttom.Click();
検索ボタンをクリック
if (novelListIndex < messageList.Count)
全ての会話を表示していない場合
var Magick = new ImageMagick.MagickImage("Sample.svg");
svgファイル読み込み
myBitmap = Magick.ToBitmap();
ピクチャーボックスへ表示する為、Bitmapへ変換
myMagick.Dispose();
リソース解放
pictureBox1.Image = myBitmap;
pictureBox1に表示
services.AddMvc ();
MVCモジュールの導入
routes.MapRoute (name: "Default",template: "{controller}/{action}",defaults : new { controller = "Home", action = "Index" });
デフォルトルートの設定
var matches = Regex.Matches("0123abcdXyx", "[0-9a-fA-F]{2}");
16進数文字列を2文字ずつ取得
result.AddRange(matches.Cast<Match>().Select(m => m.Value));
MatchCollectionクラスはIEnumerableでIEnumerable<T>じゃないのでそのままだとLinqが使えないのでIEnumerable<Match>にキャストしてから使う
RaisePropertyChanged(nameof(TextBoxValue));
ComboBox以外にも通知する
app = new Microsoft.Office.Interop.PowerPoint.Application();
PPTのインスタンス作成
ppt = app.Presentations.Open(pptFilePath,Microsoft.Office.Core.MsoTriState.msoTrue,Microsoft.Office.Core.MsoTriState.msoTrue,Microsoft.Office.Core.MsoTriState.msoFalse);
PPTファイルオープン
ppt.SaveAs(pptGenerateFilePath,PpSaveAsFileType.ppSaveAsDefault,Microsoft.Office.Core.MsoTriState.msoFalse);
生成PPTファイルの保存を実行
shape.TextFrame.TextRange.Text = replaceStr(shape.TextFrame.TextRange.Text);
PPT内の文字列置き換えを実施
getShapeText(childShape);
項目設定文字列を置き換え（再帰呼び出し）
targetStr = targetStr.Replace("[" + replaceKeyValKey + "]", replaceKeyValDic[replaceKeyValKey]);
PPTテンプレートに「[置き換え対象文字列]」の書式で設定したものを変換
Marshal.ReleaseComObject(shellApp);
リソースの解放
public void SendText(){ws.Send(messageInput.text);}
サーバへ、メッセージを送信する
public void RecvText(string text){chatText.text += (text + "\n");}
サーバから受け取ったメッセージを、ChatTextに表示する
public void RecvClose()*{chatText.text = ("Close.");}
サーバの接続が切れたときのメッセージを、ChatTextに表示する
ws.Connect();
接続処理。接続先サーバと、ポート番号を指定する
sendButton.onClick.AddListener(SendText);
送信ボタンが押されたときに実行する処理「SendText」を登録する
ws.OnMessage += (sender, e) => RecvText(e.Data);
サーバからメッセージを受信したときに実行する処理「RecvText」を登録する
ws.OnClose += (sender, e) => RecvClose();
サーバとの接続が切れたときに実行する処理「RecvClose」を登録する
ws = new WebSocketServer(12345);
ポート番号を指定
ws.AddWebSocketService<ExWebSocketBehavior>("/");
クライアントからの通信時の挙動を定義したクラス、「ExWebSocketBehavior」を登録
ws.Start();
サーバ起動
public static List<ExWebSocketBehavior> clientList = new List<ExWebSocketBehavior>();
誰が現在接続しているのか管理するリスト。
protected override void OnMessage(MessageEventArgs e)*{Debug.Log("Seq:" + seq + "..." + e.Data);//接続者全員にメッセージを送るforeach (var client in clientList){client.Send("Seq:" + seq + "..." + e.Data);}}
誰かがメッセージを送信してきたときに呼ばれるメソッド
protected override void OnClose(CloseEventArgs e)*{Debug.Log("Seq" + this.seq + " Logout. (" + this.ID + ")");//ログアウトした人を、リストから削除。clientList.Remove(this);//接続者全員にメッセージを送るforeach (var client in clientList){client.Send("Seq:" + seq + " Logout.");}}
誰かがログアウトしてきたときに呼ばれるメソッド
clientList.Remove(this);
ログアウトした人を、リストから削除。
var userManager = serviceProvider.GetService<UserManager<IdentityUser>>();
ユーザー管理を取得
var systemManager = await userManager.FindByNameAsync(StstemManageEmail);
初期のユーザーマネージャーが存在しなければロールの作成と初期システムユーザーを作成する
var roleManager = serviceProvider.GetService<RoleManager<IdentityRole>>();
ロール管理を取得
systemManager = await userManager.FindByNameAsync(StstemManageEmail);
システム管理ユーザーにシステム管理ロールを追加
var services = scope.ServiceProvider;
サービスプロバイダーの取得
var context = services.GetRequiredService<ApplicationDbContext>();
データベースの自動マイグレーション
UserRollInitialize.Initialize(services).Wait();
初期のユーザーとロールの作成
var spriteHandle = Addressables.LoadAssetsAsync<Sprite> ("Sprites", null);
ラベルを指定して一括ロード
var image = Instantiate (imageHandle.Result, transform).GetComponent<Image> ();*var text = Instantiate (textHandle.Result, transform).GetComponent<Text> ();
プレファブからオブジェクトを生成
services.Configure<AppSettings>(configuration.GetSection("AppSettings"));
設定ファイルの内容をバインドする
services.AddTransient<IHelloService, HelloService>();
サービスのDI設定を行う
Application xlApp = new Application();
ファイルオープン
Worksheet sheet = xlBook.Sheets["メンバー一覧"];
シートを選択
Range TableRange = sheet.Range["A1", "B15"];
セルの領域を選択
object[,] values = TableRange.Value;
選択した領域の値をメモリー上に格納
System.Runtime.InteropServices.Marshal.ReleaseComObject(TableRange);
使用したCOMオブジェクトを解放
xlBook.Close();
Excelのクローズ
System.Runtime.InteropServices.Marshal.FinalReleaseComObject(xlBook);
使用したCOMオブジェクトを解放
object xlApp = Activator.CreateInstance(Type.GetTypeFromProgID("Excel.Application"));
ファイルオープン
dynamic xlApp = Activator.CreateInstance(Type.GetTypeFromProgID("Excel.Application"));
ファイルオープン
using ExtractExcelDataInterface;
インターフェースの名前空間
using Microsoft.Office.Interop.Excel;
Excelを操作するために必要なクラスの名前空間を追加
Dictionary<string, string> dic = new Dictionary<string, string>();
returnするDicionaryインスタンス
Application xlApp = new Application();
ファイルオープン
Worksheet sheet = xlBook.Sheets["メンバー一覧"];
シートを選択
Range TableRange = sheet.Range["A1", "B15"];
セルの領域を選択
var animationTrack = timelineClip as AnimationTrack;
TrackAssetをAnimationTrackで取得
var binding = playableDirector.GetGenericBinding(animationTrack);*//Debug.Log($"binding: {binding?.name}");
playableDirectorから各トラックを取得する
if (animationClip)
アニメーションがすでにある場合
var animationCurveList = AnimationUtility.GetAllCurves(animationClip).Where(_ => _.propertyName == _propertyName).ToList();
アニメーショントラックからアニメーションカーブを取得する
AnimationUtility.SetEditorCurve(animationClip, curveBinding, animationCurve!=null?  animationCurve.curve : curve);
アニメーションクリップをセットする
Repaint();
再描画する
GC.Collect();
Application オブジェクトのガベージ コレクトを強制します
Excel.Workbook book = app.Workbooks.Open(@"test.xlsx");
Workbooksの暗黙のオブジェクトの作成
var descriptionTable = new Dictionary<string, Attribute>()*{{ nameof(Settings.BoolSetting),             new DescriptionAttribute("bool型の設定") },{ nameof(Settings.StringSetting),           new DescriptionAttribute("string型の設定") },{ nameof(Settings.StringCollectionSetting), new DescriptionAttribute("複数のstring型の設定") },{ nameof(Settings.DateTimeSetting),         new DescriptionAttribute("DateTime型の設定") },{ nameof(Settings.IntSetting),              new DescriptionAttribute("int型の設定") },};
PropertyGridのHelpテキストを設定する
string userConfigPath = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.PerUserRoamingAndLocal).FilePath;
user.configのパスを取得
string aqs = I2cDevice.GetDeviceSelector("I2C1");
すべてのI2Cデバイスを取得するためのセレクタ文字列を取得
ar dis = await DeviceInformation.FindAllAsync(aqs);*if (dis.Count == 0)
セレクタ文字列を使ってI2Cコントローラデバイスを取得
var settings = new I2cConnectionSettings(ACCEL_I2C_ADDR);
I2Cアドレスを指定して、デフォルトのI2C設定を作成する
settings.BusSpeed = I2cBusSpeed.FastMode;
バス速度を設定
I2CAccel = await I2cDevice.FromIdAsync(dis[0].Id, settings);
取得したI2Cデバイスと作成した設定で、I2cDeviceのインスタンスを作成
await message.Channel.SendMessageAsync("テスト", embed: embed.Build());
作成したEmbedをbotに送信させる。
Quaternion deltaRotation = Quaternion.Inverse(_rotationPrevious) * transform.rotation;*// 角度と回転軸に変換
回転変化量を計算
deltaRotation.ToAngleAxis(out float angle, out Vector3 axis);
角度と回転軸に変換
float angularSpeed = (angle * Mathf.Deg2Rad) / Time.deltaTime;
角速度 [rad/s] を算出
_estimatedAngularVelocity = transform.rotation.eulerAngles - _rotationPrevious.eulerAngles;*_estimatedAngularVelocity = (_estimatedAngularVelocity * Mathf.Deg2Rad) / Time.deltaTime;
回転変化量を計算
private bool InitGstreamerPipeline(){if( _pipeline != null )_pipeline.SetState( State.Null );// パイプライン生成_pipeline = Parse.Launch( PipelineSource );if( _pipeline == null )return false;_pipeline.Bus.EnableSyncMessageEmission();_pipeline.Bus.AddSignalWatch();_pipeline.Bus.SyncMessage += Bus_SyncMessage;_pipeline.Bus.Message += Bus_Message;_pipeline.SetState( State.Playing );return true;}
パイプライン作成
_pipeline = Parse.Launch( PipelineSource );
パイプライン生成
XElement element = XElement.Load(url);
RSS読み込み
XElement channelElement = element.Element("channel");
channelの取得
IEnumerable<XElement> elementItems = channelElement.Elements("item");
itemの取得
listener.Start();
リスナー開始
HttpListenerContext context = listener.GetContext();
リクエスト取得
HttpListenerResponse response = context.Response;
レスポンス取得
var viewModel = BindingContext as AboutViewModel;
自身にバインドされているViewModelを取得する。
viewModel.AppName = "ザマリンサンプルアプリケーション";
AppNameを書き換える。
[OneTimeSetUp]
クラス内で最初のテストが実行される前に一度だけ呼ばれる
[SetUp]
各テストの最初に呼ばれる
[OneTimeTearDown]
クラス内で最後のテストが実行された後に一度だけ呼ばれる
[OneTimeSetUp]
クラス内で最初のテストが実行される前に一度だけ呼ばれる
Application.logMessageReceived += Log;
ログを残す
_errorLogs.Clear();
クリアする
[TearDown]
各テストの最後に呼ばれる
var engineAssembly = Assembly.Load("UnityEngine.TestRunner");
テスト情報を追加する
var testNamesField = testFilterType.GetField("testNames");
テストの名前を使って実行する
var editorAssembly = Assembly.Load("UnityEditor.TestRunner");
Test Runnerを実行できるクラスを参照する
var runMethod = listGUIField.FieldType.GetMethod("RunTests", BindingFlags.Instance | BindingFlags.NonPublic);*runMethod.Invoke(listGUI, new object[] { testFilter });
Test Runnerを実行する
[OneTimeSetUp]
クラス内で最初のテストが実行される前に一度だけ呼ばれる
EditorApplication.isPlaying = false;
Unityを止める
[OneTimeTearDown]
クラス内で最後のテストが実行された後に一度だけ呼ばれる
EditorApplication.Exit(0);
エラー扱いにするため、1以上を返しても良い
var value = (int) privateObject.GetField("_Value");
privateフィールドを取得
var isZero = (bool) privateObject.GetProperty("IsZero");
privateプロパティを取得
[TestMethod]
staticなprivateメソッドのテスト
var privateType = new PrivateType(typeof(MyClass));
PrivateTypeを作成して、GetTotalValueメソッドを呼び出す
Invoke(() => { StateHasChanged(); });
変更通知
writer.WriteInt16(5);
設定値を作成(ここでは5秒)
var rnd = new Random();
ランダムな数字を作成する
var path = "Title.txt";
Title.txtの読込みとその表示
Console.WriteLine("1~10のどの桁に挑戦しますか");
入力
Workbook workbook = new Workbook();
エクセルファイルをロードします。
sheet.Range["A1:E1"].Style.Color = Color.LightSeaGreen;
Excel Rangeで背景に色を設定します。
workbook.SaveToFile("SetBackgroundColor.xlsx", ExcelVersion.Version2010);
保存します
workbook.SaveToFile("SetBackgroundimage.xlsx", ExcelVersion.Version2010);
保存します。
var res = req.GetResponse();
リクエスト送信
using (var ms = new MemoryStream(Encoding.UTF8.GetBytes(reader.ReadToEnd()))){デシリアイズする型を指定します。var serializer = new DataContractJsonSerializer(typeof(IList<Person>));
UTF8 に変換し MemoryStream に格納します
var serializer = new DataContractJsonSerializer(typeof(IList<Person>));
デシリアイズする型を指定します
Workbook wb = new Workbook();
workbookオブジェクトを作成します
wb.Worksheets.Clear();
既定のシートを削除します
Worksheet sheet = wb.Worksheets.Add("職員名簿");
新規シートを追加し、それに名をつけます
sheet.Range["A1:G1"].Merge();
A1からG1までのセルを横方向に結合します
sheet.Rows[0].RowHeight = 30F;
行の高さを設定します。
canvas_G.layer = LayerMask.NameToLayer("UI");
"UI"Layerに変更
snapShotManager.SaveSnapShot("FirstSnapShot");
スナップショットの保存
var input_floats = GetFloatFromTex2DWithFlip (input);
Texture2Dをモデルの入力に合った形に整形、正規化する。
double background = RelativeLuminance(R, G, B);
背景色の相対輝度
return background >= border ? Color.Black : Color.White;
背景色の相対輝度が境界値以上なら黒文字、未満なら白文字
audioVolume = audioRate * trackBar1.Value;
trackBarにあわせて音量変更.
MessageBox.Show("ファイルをドラッグアンドドロップしてください。\n");
ダイアログ表示.
audioReader.Position = 0;
再生位置を戻す.
[SerializeField] private GameObject _object;
シリアライズ可能なフィールドを宣言
GameObject obj = GameObject.FindWithTag("探したいオブジェクトに設定されたタグ");
指定したタグを持つGameObjectを 1つ 取得する。
GameObject[] objs = GameObject.FindGameObjectsWithTag("探したいオブジェクトに設定されたタグ");
指定したタグを持つGameObjectを 全て 取得する。
var cmp = FindObjectOfType</*欲しいコンポーネント*/>();
シーン内にある、指定したコンポーネントの1つを取得する
var cmp = FindObjectsOfType</*欲しいコンポーネント*/>();
シーン内にある指定したコンポーネント全てを取得する
byte[] bytes = MessagePackSerializer.Serialize(myClass1);
MessagePack形式のバイト配列に変換
Graphics g = this.CreateGraphics();
グラフィックオブジェクトの作成
Pen grayPen = new Pen(Color.Gray, 2);
Penを作成
Point start_point = new Point(25, 250);
lineの始点と終点を設定
g.DrawLine(grayPen, start_point, end_point);
lineを描画
grayPen.Dispose();
Penを解放する
g.Dispose();
Graphicsを解放する
uiText.text = (count + 1).ToString("00");
アイテムナンバー、0から始まるので+1をして1から表記
ParticleSystemCurveMode particleSystemCurveMode = ParticleSystemCurveMode.Curve;
StartLifeTimeのモードの変更
_minMaxCurve.curve = _animationCurve;
StartLifeTimeの値の変更
return whiteContrast < blackContrast ? Color.Black : Color.White;
文字色と背景色のコントラスト比を計算
Vector3 angle = new Vector3(Input.GetAxis("Mouse X") * 1.0f,
マウスの回転を感知して回転ベクトル化
command.CommandText = "SELECT * FROM [tableName] " ;
SELECT文を設定します
fileMgr.CreateDirectory(@"test\a\newfolder");
「newfolder」ディレクトリを作成
fileMgr.WriteAllText(@"test\a\newfolder\aaa.txt", "あああああ");
「newfolder\aaa.txt」ファイルを作成
fileMgr.AppendAllText(@"test\a\newfolder\aaa.txt", "いいいい");
「newfolder\aaa.txt」ファイルに追記
fileMgr.Move(@"test\a\test.txt", @"test\a\test_renamed.txt");
test.txtをtest_renamed.txt に変更
var byteValue = Encoding.UTF8.GetBytes(value);
文字列をバイトデータに変換
var byteLength = byteValue.Length;
バイトデータの長さを取得
var prefab = PrefabUtility.SaveAsPrefabAsset(game, "Assets/prefab.prefab");
プレファブ作成
Object.DestroyImmediate(game);
ゲームオブジェクトを削除
var match = Regex.Match(org, @"[\da-zA-Z]{4}");
4桁英数字にマッチしたものを探す
var matches = Regex.Matches(org, @"[\da-zA-Z]{4}");
4桁英数字にマッチしたものを全部探す
Stopwatch sw = new Stopwatch();
ストップウォッチを作成
public static void WriteStringToFile(string path, string data)*{var dir = Path.GetDirectoryName(path);if (!Directory.Exists(dir)){Directory.CreateDirectory(dir);}using (var fs = new FileStream(path, FileMode.Create))using (var sw = new StreamWriter(fs)){sw.Write(data);}}
文字列をファイルに書き込み
var size = type.GetField("_size", BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);
_size フィールドを取得
var items = type.GetField("_items", BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);
_items フィールドを取得
size.SetValue(ls, capacity);
_size フィールドに capacity を書き込む
items.SetValue(ls, ary);
_items フィールドに ary を書き込む
rigidBody.position += input * SPEED;
既存のポジションに対して、移動量(vector)を加算する
GetComponent<Rigidbody2D>().velocity = 2.1f * direction * speed;
移動する向きとスピードを代入する
this.Visible = true;
フォームを表示する
new Thread(new ThreadStart(GetMouseButton)).Start();
フォームをアクティブにする
var res = HTTPAccess.GetResponse(method, url, body, contentType, header);
HTTPリクエスト
LineRenderer lineRenderer;
変数を宣言
private Channel channel = new Channel("localhost", 12345, ChannelCredentials.Insecure);
StreamingHub クライアントで使用する gRPC チャネルを生成
private GamingHubClient client = new GamingHubClient();
StreamingHub サーバと通信を行うためのクライアント生成
await this.client.ConnectAsync(this.channel, this.m_RoomName, this.m_UserName);
ゲーム起動時に設定した部屋名のルームに設定したユーザ名で入室する。
Qtext.color = new Color(1, 1, 1, a_color);
透明度を変更する
WriteCombineFile( item, dst_path );
書き込む
_WaveHdr.lpData = Marshal.AllocHGlobal(dataSize);
メモリを確保
var cdwh = Marshal.SizeOf<NativeMethods.WaveHdr>();
バッファを準備・追加
NativeMethods.waveInStart(_Hwi);
録音スタート
Array.Copy(Encoding.ASCII.GetBytes("RIFF"), 0, waveData, 0, 4);
WAVEヘッダを設定
NativeMethods.waveInUnprepareHeader(_Hwi, ref _WaveHdr, Marshal.SizeOf<NativeMethods.WaveHdr>());
バッファを開放
Marshal.FreeHGlobal(_WaveHdr.lpData);
メモリ開放
int[] array = { 0, 1, 2, 3 };
一次元配列を作成
PhotonProperty.SetRoomPropertyArray("array", array);
arrayというキーでarray配列をセット
hWnd = NativeAPIUtility.GetForegroundWindow();
アクティブウィンドウのデバイスコンテキストを取得
NativeAPIUtility.RECT rect = new NativeAPIUtility.RECT();
ウィンドウサイズを取得
hDC = graphics.GetHdc();
Graphicsのデバイスコンテキストを取得
guiTextLogIn  = GameObject.Find ("GUITextLogIn");
ゲームオブジェクトを検索し取得する
title = GameObject.Find ("Title");
Titleゲームオブジェクトを検索し取得する
title.SetActive (false);
タイトルを非表示
title.SetActive (true);
タイトルを表示する
application = new Application();
Applicationクラスのインスタンス作成
DataTable dt = new DataTable();
テーブルを作成
Repeater1.DataSource = dt;
リピーターコントロールにテーブルをBindする
Response.Redirect(openfilename);
PDFに遷移
Object[] selectedAsset = Selection.GetFiltered (typeof(Object), SelectionMode.Assets);*foreach (var sel in selectedAsset) {Debug.Log (sel.name + " : " + sel.GetType ());//選択したものがフォルダなら、フォルダ内にあるマテリアルとテクスチャを検索してリストに追加if ((sel.GetType ().ToString () == "UnityEditor.DefaultAsset")){var folder = (DefaultAsset)sel;var dirpath = AssetDatabase.GetAssetPath(folder);string[] diraug = {dirpath};//マテリアルに対する処理var mfiles = AssetDatabase.FindAssets("t:Material",diraug);foreach(var mf in mfiles){var mfpath = AssetDatabase.GUIDToAssetPath(mf);var mfasset = AssetDatabase.LoadAllAssetsAtPath(mfpath);foreach(var mfa in mfasset){mlist.Add((Material)mfa);}}//テクスチャに対する処理var tfiles = AssetDatabase.FindAssets("t:Texture2D",diraug);foreach(var tf in tfiles){var tfpath = AssetDatabase.GUIDToAssetPath(tf);var tfasset = AssetDatabase.LoadAllAssetsAtPath(tfpath);foreach(var tfa in tfasset){tlist.Add((Texture2D)tfa);}}}}
選択したフォルダの取得
int targetID = GetWindowThreadProcessId(handle, out processId);
スレッドのIDを取得
SystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, timeout, 0);
現在の設定を timeout に保存
SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, dummy, SPIF_SENDCHANGE);
ウィンドウの切り替え時間を 0ms にする
isSuccess = SetForegroundWindow(handle);
ウィンドウをフォアグラウンドに持ってくる
string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
クライアントからLock scriptの文字列を受け取る
Script redeemScript = new Script(requestBody);
ScriptクラスへLock scriptを渡す
BitcoinAddress address = redeemScript.Hash.GetAddress(Network.Main);
P2SH形式のビットコインアドレスを生成する
return address != null? (ActionResult)new OkObjectResult(address.ToString()): new BadRequestObjectResult("Please pass a name on the query string or in the request body");
生成されたビットコインアドレスを返す
string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
クライアントからのパラメータを受け取る
GameObject resultObj = GameObject.Find ("ResultObject");
オブジェクトを名前で探す
Debug.Log (resultObj.GetComponent<GamePlaying> ().test);
変数「test」を参照しDebug.Logに出力
resultObj.transform.position = new Vector3 (*resultObj.transform.position.x,
オブジェクトの位置情報を変更
BtnShowContent = FindViewById<Button>(Resource.Id.btn_show_content_main_page);
contentページ表示ボタン
BtnShowActivity = FindViewById<Button>(Resource.Id.btn_show_activity_main_page);
activityページ表示ボタン
BtnShowContent = FindViewById<Button>(Resource.Id.btn_show_content_main_page);
contentページ表示ボタン
Response.Redirect(openfilename);
PDFに遷移
Rect rect = new Rect(faceInfo.recLeft, faceInfo.recTop, faceInfo.recWidth, faceInfo.recHeight);
顔の検出箇所に赤枠を表示
Cv2.PutText(image, faceInfo.faceId, new Point(faceInfo.recLeft, faceInfo.recTop)
FaceIDを描画
List<FaceInfo> faceInfoList = FaceDetect.Detect(imageUrls);
FindSimilarのパラメータを取得
content.Headers.ContentType = new MediaTypeHeaderValue("application/json");
リクエストヘッダーの作成
var contentString = await response.Content.ReadAsStringAsync();
実行結果からJSONの取得
static async void MakeAnalysisRequest(string imageFilePath)*{HttpClient client = new HttpClient();// リクエストヘッダーclient.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", subscriptionKey);// リクエストパラメータstring requestParameters = "returnFaceId=true&returnFaceLandmarks=false" +"&returnFaceAttributes=age,gender,headPose,smile,facialHair,glasses," +"emotion,hair,makeup,occlusion,accessories,blur,exposure,noise";// Face API呼び出し時のURLを作成string uri = uriBase + "?" + requestParameters;HttpResponseMessage response;// ローカルの画像ファイルパスを文字列からバイト型配列へ変換byte[] byteData = GetImageAsByteArray(imageFilePath);using (ByteArrayContent content = new ByteArrayContent(byteData)){// リクエストヘッダーの作成content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");// Face APIの呼び出しresponse = await client.PostAsync(uri, content);// 実行結果からJSONの取得string contentString = await response.Content.ReadAsStringAsync();// JSONの出力Console.WriteLine("\nResponse:\n");Console.WriteLine(JsonPrettyPrint(contentString));Console.WriteLine("\nPress Enter to exit...");}}
Face APIを使用して画像分析を行う
byte[] byteData = GetImageAsByteArray(imageFilePath);
文字列からバイト型配列へ変換
content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");
リクエストヘッダーの作成
response = await client.PostAsync(uri, content);
Face APIの呼び出し
string contentString = await response.Content.ReadAsStringAsync();
実行結果からJSONの取得
static byte[] GetImageAsByteArray(string imageFilePath)*{using (FileStream fileStream =new FileStream(imageFilePath, FileMode.Open, FileAccess.Read)){BinaryReader binaryReader = new BinaryReader(fileStream);return binaryReader.ReadBytes((int)fileStream.Length);}}
画像をバイト配列に変換
canvas_G.layer = LayerMask.NameToLayer("UI");
Layerを変更
Time.fixedDeltaTime = FIXEDUPDATE_DELTATIME;
Fixed Timestepを固定
SerializedProperty panelColorProperty = property.FindPropertyRelative("panelColor");
各プロパティーの SerializedProperty を求める
panelColorProperty.colorValue = EditorGUI.ColorField(panelColorRect, "フェードの色", panelColorProperty.colorValue);
各プロパティーの GUI を描画
GameObject tapObj = EventSystem.current.currentSelectedGameObject;
タップ検知したGameObjectを取得
Button btn = tapObj.GetComponent<Button>();
取得したオブジェクトからButtonを取得。
ShaderType = ShaderType.Liner,Colors = new SKColor[] { SKColors.White, SKColors.LightGray, SKColors.Black },ColorPos = new float[] { 0, 0.5f, 1 }};
3色のグラデーションの場合はColorsとColorPosに3つを指定
ShaderType = ShaderType.Radial,Colors = new SKColor[] { SKColors.White, Color.FromHex("#FFFF2020").ToSKColor() },ColorPos = new float[] { 0, 1 }};
放射状グラデーション
canvas.Clear();
canvas上にすでに何かを描画済みであればいったんクリアする
SKRect rect = new SKRect(0, 0, info.Width, info.Height);
描画範囲をコントロール全体として指定
GradientModel gradientModel = GradientModelFactory.Instance.CreateGradientModel(BackGradientColor);
グラデーション設定を取得
paint.Shader = CreateShader(gradientModel, rect);
背景グラデーション用のShaderの設定
DrawFill(canvas, paint, rect);
背景を描画
DrawStroke(canvas, paint, rect);
枠線を描画
Presentation ppt = new Presentation();
PowePoint Objectを作成します
ppt.LoadFromFile(@"Sample.pptx");
ファイルをロードします
ppt.SaveToFile("ConvertPPTtoHtml.html", FileFormat.Html);
HTMLで保存します
var config = Configuration.Default.WithCookies().WithDefaultLoader();
Cookieを有効化
Console.WriteLine(context.Active.Location);
URLを取得
await context.OpenAsync("https:qiita.com/login");
ログイン前のURL表示
Model.Series.Add(LineSeries);
グラフをモデルに追加
Model.InvalidatePlot(true);
セットした内容を反映させる
DrawingPanel(R, G, B);
設定した色をパネルに表示
CreateHexadecimal(R, G, B);
16進数カラーコードで表示
DialogResult dialogResult = colorDialog.ShowDialog();
カラーダイアログを表示
Datas.Add(new DataPoint(1.0, 10.0));
点を追加
Model.Series.Add(LineSeries);
グラフをモデルに追加
Model.InvalidatePlot(true);
セットした内容を反映させる
m_view.SetListItemCount(m_list.Length);
データ個数を変更して表示を更新する
m_view.gameObject.SetActive(true);
ScrollViewを非表示にしてる場合は表示するため
var area = queue.GetPrintCapabilities().PageImageableArea;
印刷可能領域を取得
PrintQueue.CreateXpsDocumentWriter(queue).Write(page, ticket);
デフォルトプリンタで印刷
List<XpsDocument> sourceXps = new List<XpsDocument>();
ソースドキュメントの準備
Vector2 ShotPos = transform.position;
自身の座標取得
GameObject Bullet_obj = objp.poolBullet(shotPos);
弾の座標を撃つ場所に
static ScoreData[] BubbleSort(ScoreData[] scoreDatas)*{var ary = new ScoreData[scoreDatas.Length];for (int i = 0; i < scoreDatas.Length; i++){ary[i] = scoreDatas[i];}for (int i = 1; i < ary.Length; i++){for (int j = ary.Length - 1; j >= i; j--){if (ary[j - 1].score > ary[j].score){ScoreData temp = ary[j - 1];ary[j - 1] = ary[j];ary[j] = temp;}}}return ary;}
ソート関数
Common.EnumWindows(EnumWindowCallBack, (IntPtr)null);
すべてのウィンドウを列挙する
int textLen = Common.GetWindowTextLength(hWnd);
ウィンドウのタイトルの長さを取得する
StringBuilder tsb = new StringBuilder(textLen + 1);
ウィンドウのタイトルを取得する
StringBuilder csb = new StringBuilder(256);
ウィンドウのクラス名を取得する
Ray ray = Camera.main.ScreenPointToRay(touch.position);
タッチした位置からRayを飛ばす
public void OpenURL(string url){Application.OpenURL(url);}
GradientModel gradientModel = GradientModelFactory.Instance.CreateGradientModel(BackGradientColor);
グラデーション設定を取得
SKPaint paint = new SKPaint{IsAntialias = true,Style = SKPaintStyle.Fill,Shader = SKShader.CreateLinearGradient(new SKPoint(rect.Left, rect.Top), new SKPoint(rect.Left, rect.Bottom),gradientModel.Colors, gradientModel.ColorPos, SKShaderTileMode.Clamp)};
SKPaintを作成
canvas.DrawRoundRect(rect, CornerRadius, CornerRadius, paint);
背景を描画
paint.Style = SKPaintStyle.Stroke;
枠線用にSKPaintを変更
var resXml = await res.Content.ReadAsStringAsync();
受信データの中身を読み込む
byte[] zipBinary =System.Convert.FromBase64String(xmlDoc.GetElementsByTagName("base64Binary")[0].InnerText);
Webサービスから取得したBase64文字列をバイト型配列に変換
await fs.WriteAsync(zipBinary, 0, zipBinary.Length);
ファイルに書き込む
to_file_path_ += DateTime.Now.ToString("yyyyMMdd_HHmm");
ファイル名を現在時刻を元に決定
rbody.MovePosition(new Vector3(movex, transform.position.y, movez));*}
Rigidbodyのオブジェクトを移動
await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme,new ClaimsPrincipal(claimsIdentity),
ログイン
var currentPosition = _camera.position;
カメラPrefabのRootObject
EditorGUILayout.Space();
スペースを空ける
void Awake(){gameObjInitX = gameObj.GetComponent<RectTransform>().anchoredPosition.x;gameObjInitY = gameObj.GetComponent<RectTransform>().anchoredPosition.y;}
最初に初期位置の取得
float width = rectTransform.sizeDelta.x;
幅を取得
float height = rectTransform.sizeDelta.y;
高さを取得
if (LuncherPos.x > TargetPos.x) _theta = Mathf.PI - 0.5f * Mathf.Asin(AsinX);
using (var writer = XmlWriter.Create(memory, new XmlWriterSettings() { Encoding = Encoding.UTF8, Indent = true })){var serializer = new XmlSerializer(obj.GetType());
カスタムクラスの内容を XML としてメモリに書き込む
var bmp = clip.GetData(typeof(Bitmap)) as Bitmap;
画像ファイルのみ取り込み
Color32[] texColors = Enumerable.Repeat<Color32>(bgColor, width * height).ToArray();
背景が透明なTexture2Dを作る
xamPropGrid.SelectedObject = this.xamDataGrid.ActiveDataItem;
選択行のオブジェクトをXamPropertyGridに表示
string randomLine = Guid.NewGuid().ToString("N").Substring(0, 10);
ランダム文字列生成
MemoryStream data = new MemoryStream(File.ReadAllBytes(tb_FileName2.Text));
ファイル読みこみ
using (FileStream stream = new FileStream(tb_FileName2.Text, FileMode.Open)){var enc = new JpegBitmapEncoder();
ファイルに書き込み
var process = Process.Start(new ProcessStartInfo{FileName = "/path/to/mpc",Arguments = "-i Assets -o Assets/GeneratedScripts/GeneratedResolver.cs",UseShellExecute = false,RedirectStandardOutput = true,RedirectStandardError = true,});
外部プロセス起動
if (!Menu.GetChecked(AutoBuildMenuPath)) return;
自動ビルドがOFFなら終了
Touch touch = Input.GetTouch(0);
タップ情報の取得
this.startPos = Input.mousePosition;
タッチ座標
Vector2 endPos = Input.mousePosition;
タップ位置取得
this.x_speed = x_flickLength / 500.0f;
フリックの長さを速度に変換する
System.Text.Encoding charcode = System.Text.Encoding.GetEncoding(url_radio_button);
指定された文字コードを取得
string after_str = System.Web.HttpUtility.UrlEncode(input_str,charcode);
文字列を指定された文字コードに従い,URLエンコードする
string after_str = System.Web.HttpUtility.HtmlEncode(input_str);
文字実体参照にエンコードする
using (var z = ZipFile.Open(zipFile, ZipArchiveMode.Update)){z.CreateEntryFromFile(targetFile, targetFileName, CompressionLevel.Optimal);
zip圧縮する
DateTime localTime = DateTime.Now;
現在時刻の記録
this.startPos = Input.mousePosition;
クリックした座標
await file.ReadAsync(result, 0, (int)file.Length);
バイナリデータを非同期的に読み込む
NLog.LogEventInfo info = new NLog.LogEventInfo(NLog.LogLevel.Info, logger.Name, message);
ログ情報を生成します
logger.Log(typeof(NLoggerExtensions), info);
ロガーの型に NLoggerExtensions を指定します。
info.SetCallerInfo(callerClassName, callerMemberName, callerFilePath, callerLineNumber);
呼び出し元情報を設定します
faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
レンダリングをメインカメラに
result = Regex.Replace(calcStr, @"\s", "");
対象文字列の半角スペースを削除
public static string Log10(string calcStr){double result = Math.Log10(calcStr.ToDouble());return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
log - 10を底としたlogの計算を行う
public static string Log(string calcStr){double result = Math.Log(calcStr.ToDouble());return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
log - ネイピア数 e を底としたlogの計算を行う
private static double Deg2rad(double num){return num / 180.0 * Math.PI;}
角度をラジアンに変換
string result = string.Format("{0:f" + digit + "}", value);
小数点第digit位まで取得し後ろの余分な0を切り捨てる
public static double ToDouble(this string str){if (double.TryParse(str, out double ret)){return ret;}throw new ArgumentException("<" + str + ">をdouble型に変換できません");}
文字列をdouble型に変換します
registryKey.SetValue(registryValueName, host);
レジストリの値を設定
var filePaths = await GetAllFilesAsync(@"C:\");
ファイル取得
var tcs = new TaskCompletionSource<IEnumerable<string>>();
タスクを作成
Interlocked.Increment(ref count);
スレッドセーフにインクリメントを行う
DateTime gantan = new DateTime(targetYear, 1, 1);
対象年の1月1日(元旦)の曜日を取得する。
var days = FindWantDayOfWeek(targetYear, wantDayOfWeek);
対象年の指定された曜日に該当する日付を全て取得する。
var requestInfo = ENDPOINT + API_KEY;*requestInfo += $"&text={speechText}&source_lang={from}&target_lang={to}";
POSTメソッドのリクエストを作成
value = Math.Ceilng(value);
小数点切り上げ
value = Math.Floor(value2);
小数点切り下げ
Note.GetComponent<NoteController>().setParameter(type, timing);
setParameter関数を実行
Distance = Math.Abs(BeatPoint.position.x - SpawnPoint.position.x);
追加した変数に値をセット
string json = JsonUtility.ToJson(userData);
クラスをJSON文字列に変換
byte[] arr = System.Text.Encoding.UTF8.GetBytes(json);
byte配列に変換
AesEncryptSample(arr);
AES暗号化サンプル処理
string path = System.IO.Path.Combine(Application.temporaryCachePath, "UserDataAES");
ファイル書き込み
byte[] arrRead = System.IO.File.ReadAllBytes(path);
ファイル読み込み
byte[] arrDecrypt = AesDecrypt(arrRead, aesKeySize, aesBlockSize, aesIv, aesKey);
復号化
string decryptStr = System.Text.Encoding.UTF8.GetString(arrDecrypt);
byte配列を文字列に変換
var aes = GetAesManager(aesKeySize, aesBlockSize, aesIv, aesKey);
AESマネージャー取得
var array = Enumerable.Repeat("あいうえお",10).ToArray();
要素数が10で、値が「あいうえお」の配列を生成する
var guestIssuer = TeamsAPI.CreateVersion1GuestIssuerClient(secret, "your_guest_issuer_id");
GuestIssuerClientのインスタンスを作成する。
var guest = (await guestIssuer.CreateGuestUserAsync("my-guest-id", "ゲスト太郎")).GetData();
Guest Userを作成する。
var teams = TeamsAPI.CreateVersion1Client(guest, new TeamsRetryHandler(4));
ゲストユーザ用のTeamsAPIClientインスタンスを作成する(リトライ機能付き)。
var message = (await teams.CreateMessageAsync("space_id_to_post", "こんにちは、私はゲストユーザです！！")).GetData();*Console.WriteLine("メッセージが投稿されました: ID = {0}", message.Id);
ゲストユーザからメッセージを投稿する。
public virtual IEnumerable<int> EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index); index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む
public virtual IEnumerable<int> Horizontal(int x, int y)
(x,y)から右(水平)の位置を列挙する　(x,y)含む
public virtual IEnumerable<int> Virtical(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む
public virtual IEnumerable<int> SlantR(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む
RendererCube.enabled = false;
Rendererをオフにする
Destroy(gameObject, 4f);
4f後にCubeが消える
Velocity.y = JumpPower;
Velocity.yをJumpPowerにする
regionManager.RegisterViewWithRegion("ContentRegion", typeof(ViewA));
RegionにViewを読み出す
using (RpcConfigurationContext context = new RpcConfigurationContext(config, true))
コンテキストを生成します
CallInvoker invoker = m_RpcContext.GetCallInvoker("invoker1");
設定上の名称を指定して CallInvoker を生成します
sum += Mathf.Abs(data[i]);
データの絶対値を足す
var rcOwner = Win32Native.GetWindowRect(hOwner);
オーナーウィンドウとメッセージボックスの領域を取得
var x = rcOwner.Left + (rcOwner.Width - rcMsgBox.Width) / 2;
メッセージボックスをオーナーウィンドウの中央位置に移動
services.Configure<MyOptions>(Configuration);
バインドするオプションクラスに対し、設定情報を登録します。
await Task.Run(() => {Console.WriteLine("処理1");Thread.Sleep(3000);Console.WriteLine("処理2");Thread.Sleep(3000);});
ラムダ式を与えるコード
hoge = (int)huga;
明示的な変換
Debug.Log("width" + message.width);
取得したデータを出力
Directory.Delete(unzipDir, true);
フォルダ削除
Provider = new ServiceCollection().BuildServiceProvider();
ServiceProviderインスタンス生成
Destroy(gameObject);
このオブジェクトをデストロイ
pVertices.Clear();
初期化しておく
Compass.Start(SensorSpeed.UI);
コンパス値の取得開始
LabelCompass.Text = data.HeadingMagneticNorth.ToString();
ラベルに表示
connection.Open();
データベースと接続
await AddAudioPlayAndPushPictureAsync(response, userId, null, beforeId, log);*}
次のオーディオ再生（画像送付があればそれも）を実施
cache.StopRequest.IsStopped = true;
再生中断された場合
SetScale(MaxScale);
サイズを最大に
SetScale(Mathf.Max(NormalScale, nowScale - (ScaleSpeed * Time.deltaTime)));
サイズが大きければ元のサイズまで徐々に戻す
XmlSerializeUtility.Serialize(CreateConfig(), path);
シリアライズ
SampleAppConfig config = XmlSerializeUtility.Deserialize<SampleAppConfig>(path);
デシリアライズ
for(int i = 2; i <= Samples; i *= 2)if(Samples % i != 0 || Samples <= 0) throw new DomainException();
引数の値が2の自然数乗でなければ例外を投げる
if(WaveSamples.Length != Samples) throw new SampleDataLengthException();
引数となる配列の長さが Samples に等しくなければ例外を投げる
for(int i = 0; i < Samples; i++) WaveSamples[i] *= Window((double)i / Samples);
波サンプルに窓関数を掛ける
public void Open(string portName){if(isRunning) return;currentPortName = portName;serialPort = new SerialPort(portName, baudRate, Parity.None, 8, StopBits.One);serialPort.Open();isRunning = true;task = ReadAsync();}
ポート名を指定してSerialPortを開く
webView.Configuration.UserContentController.AddScriptMessageHandler(this, "MyHeavyAdd");
JavaScript から呼び出すハンドラを追加。
anim.SetFloat("speed", v);
Animator側で設定している"Speed"パラメタにvを渡す
proc.Start();
プロセスの開始
proc.BeginErrorReadLine();
非同期出力読出し開始
ctoken.Token.WaitHandle.WaitOne();
終了まで待つ
si.RedirectStandardError = true;
ウィンドウ表示を完全に消したい場合
ctoken.Cancel();
プロセスが終了すると呼ばれる
int answerNum = Array.IndexOf(haveMoneyArray, searchNum) + 1;
探したい文字のインデックス番号を取得
int line1 = int.Parse(Console.ReadLine());
調べる文字と調べられる文字列を各配列に格納
Console.ReadLine();
コンソールアプリが落ちないようにReadLineで待つ
this.room = await this.Group.AddAsync(roomName);
ルームに参加&ルームを保持
this.Broadcast(room).OnJoin(userName);
参加したことをルームに参加している全メンバーに通知
await room.RemoveAsync(this.Context);
ルーム内のメンバーから自分を削除
this.Broadcast(room).OnLeave(me);
退室したことを全メンバーに通知
this.Broadcast(room).OnSendMessage(me, message);
発言した内容を全メンバーに通知
this.SendMessageButton.gameObject.SetActive(false);
メッセージ送信ボタンを非表示に
this.SendMessageButton.gameObject.SetActive(true);
メッセージ送信ボタンを表示
model_data.Dispose();
モデルデータの破棄
_isProduction = env.IsProduction();
現在の実行環境がProductionかチェック
var builder = new ConfigurationBuilder().SetBasePath(env.ContentRootPath).AddJsonFile("appsettings.json", optional: true, reloadOnChange: true).AddEnvironmentVariables();
AppSettingsと環境変数を取得
var secretKey = Configuration.GetSection("botFileSecret")?.Value;
.botのパスとシークレット取得
var botConfig = BotConfiguration.Load(botFilePath ?? @".\BotConfiguration.bot", secretKey);*services.AddSingleton(sp => botConfig ?? throw new InvalidOperationException($"The .bot config file could not be loaded. ({botConfig})"));
.botの読み込み
asd.Engine.InitializeByExternalWindow(window.altseed.Child.Handle, System.IntPtr.Zero, (int)window.altseed.RenderSize.Width, (int)window.altseed.RenderSize.Height, new asd.EngineOption());
外部のウィンドウを利用してAltseedを初期化する。
var font = asd.Engine.Graphics.CreateDynamicFont("", 30, new asd.Color(255, 255, 255), 0, new asd.Color());
フォントを生成する。
asd.TextObject2D obj = new asd.TextObject2D();
文字描画オブジェクトを生成する。
obj.Font = font;
描画に使うフォントを設定する。
obj.Position = new asd.Vector2DF(100, 100);
描画位置を指定する。
obj.Text = "C++完全に理解した";
描画する文字列を指定する。
asd.Engine.AddObject2D(obj);
文字描画オブジェクトのインスタンスをエンジンへ追加する。
int iDataNum = int.Parse(Console.ReadLine());
ループする回数取得
var varList = new List<List<int>>();
2 次元配列のように扱える List の定義
varList[i].Add(int.Parse(array_1D_ab[j]));
要素の追加
var varArray = varList.Select(line => line)
List をジャグ配列に変換する
Array.Sort(varArray, StructuralComparisons.StructuralComparer);
ジャグ配列をソートする
Console.WriteLine(varArray[i][j]);
末尾改行あり出力
Console.Write(varArray[i][j] + " ");
末尾改行なし出力
Application.Idle += (e, sender) => this.ExitThread();
アプリケーション終了
Application.Idle += this.Application_Idle;
Idleイベント登録
this.App.Dispose();
App破棄
Application.Idle -= this.Application_Idle;
Idleイベント一時解除
Application.Idle += this.Application_Idle;
Idleイベント再登録
this.App.DoWork();
アプリケーションの処理を実行
base.Dispose(disposing);
リソースの解放処理
Application.EnterThreadModal += this.Application_EnterThreadModal;
モーダル状態を捕捉
query.WhereEqualTo("キー", "値");
一致する値で取得
query.OrderByDescending("updateDate");
ソートkeyを設定
query.FindAsync((List<NCMBObject> objList, NCMBException e) =>*{if (e != null){Debug.Log("失敗");}else{Debug.Log("成功");OnResult(objList);}isConnecting = false;});
検索結果を取得
OnResult(objList);
objListを使う処理
isConnecting = false;
ログイン処理終了
yield return new WaitWhile(() => { return isConnecting; });
ログイン処理が終了するまで以下の行で待機
var port = new MidiInPort("loopMIDI Port");
ポートを開く
port.Received += MidiReceived;
受信イベント登録
var encryptData = Encrypt(saveData, buf);
暗号化する処理
SaveFile(encryptData);
ファイルに保存する処理
sumTime += Time.deltaTime;
開始フレームから何秒経過したか
var ratio = sumTime / time;
指定された時間に対して経過した時間の割合
loadedModel = mlContext.Model.Load(modelLocation, out var modelInputSchema);
モデル読み込み
var predictor = mlContext.Model.CreatePredictionEngine<ImageNetData, ImageNetPrediction>(loadedModel);
画像読み込み
public bool DirectoryExists(string Folderpath){string DisideOfSelsct;Console.WriteLine("フォルダの存在チェック");if (!Directory.Exists(Folderpath)){Console.WriteLine("フォルダが存在しません。フォルダを作成しますか？");Console.WriteLine("作成：yes　作成しない：no");DisideOfSelsct = Console.ReadLine();CreateDirectory(Folderpath, DisideOfSelsct);}else{Console.WriteLine(Folderpath + "は存在します");}return true;}
フォルダの存在確認を行う
private void CreateDirectory(string DirectoryFolder, string Answer){if (!Directory.Exists(DirectoryFolder) && Answer.Equals("yes")){Directory.CreateDirectory(DirectoryFolder);}else if(Directory.Exists(DirectoryFolder) && Answer.Equals("no")){return;}}
フォルダの作成を行う
clickOnce.RegistAssemblyDownloadGroup("ClassLibrary1", "Group1");
アセンブリ名とダウンロードグループ名の組み合わせを登録します
image = childrenTransform.GetComponent<Image>();image.color = Color.yellow;
イメージコンポーネントを取得して色を変える
AssertEqual(ReceiveSatus.SUCCESS, result.Status);
結果を検証
var normal = transform.forward;
鏡面の垂直ベクトル
var reflection = diff + 2 * (Vector3.Dot(-diff, normal)) * normal;
鏡面からの反射ベクトル
ReflectionCamera.transform.position = transform.position - reflection;
鏡面座標に反転させた反射ベクトルを加算する
task.Wait();
taskの完了を待つ
SomethingNextMethod(task.Result);
taskの処理は終了しているので、Resultを参照
yield return NSLayoutConstraint.Create(child, NSLayoutAttribute.CenterX, NSLayoutRelation.Equal,parent, NSLayoutAttribute.CenterX, 1.0f, new nfloat(0)
X座標を親の中心を軸に配置
yield return NSLayoutConstraint.Create(child, NSLayoutAttribute.CenterY, NSLayoutRelation.Equal,parent, NSLayoutAttribute.CenterY, 1.0f, new nfloat(0)
Y座標を親の中心を軸に配置
vlcControl1.Play(ms);
再生
XDocument xml = XDocument.Load(@"C:\sample.xml");
ディレクトリ指定してファイルを読み込み
XElement table = xml.Element("リスト");
テーブルを読み込む
var rows = table.Elements("データ");
データの中身すべてを取得
private double ToDegree(double rad){return rad * 360 / (2 * Math.PI);}
ラジアンを度に変換
private double ToRadian(double deg){return deg * (2 * Math.PI) / 360;}
度をラジアンに変換
private double LineLength(Point p1, Point p2){double w = (p2.X - p1.X);double h = (p2.Y - p1.Y);return Math.Sqrt(w * w + h * h);}
２点の線分の長さを求める
command.ExecuteNonQuery();
SQLの実行
var ws = analyzerResult.GetWorkspace();
AllowUnsafeBlockオプションを有効にする
sourceStream.StartRecording();
録音の開始
play.Init(new WaveInProvider(sourceStream));
音声ファイルの読み込み
play.Play();
音声ファイルの再生
play.Stop();
音声ファイルの停止
CloudBlockBlob blockBlob_download = blobcontainer.GetBlockBlobReference(blobname);
ダウンロードするファイル名を指定
observer.EventAction += sub1.SubjectAction;
Eventに登録する
var thread = new Thread(HeavyFunc);
スレッドを作成
task.Wait();
ここで非同期処理が終わるまで待機
audioSource = GetComponent<AudioSource>();
AudioSourceを取得
audioSource.Play();
再生開始
var nurieBitmap = MergeTwoImages(fgBitmap, bgBitmap, cropFgToolbar);
画像の合成
using (var g = Graphics.FromImage(bitmapBase)) {g.DrawImage(fgBitmap, g.VisibleClipBounds);
ビットマップに前景画像を描画
skdevice.Open(devicePort, 115200, 8, Parity.None, StopBits.One);
シリアル通信を開く
skdevice.OnEVENTReceived += (sender, e) =>*{logger.LogDebug(e.ToString());};
EVENTのイベントハンドラを登録
skdevice.OnERXUDPReceived += (sender, e) =>*{logger.LogDebug(e.ToString());};
ERXUDP(UDP受信)のイベントハンドラを登録
var eInfo = await skDevice.SKInfoAsync();
各種コマンドはSKDeviceクラスにメソッドとして実装
FormulaParts = parts.ConvertAll(x =>{ParameterExpression pExpr = Array.Find(Parameters, para => para.Name == (string)x)?.DeclExpression;
パラメータ記述部分をParameterExpressionに変換
private void ParseFuncDef(string defStr, out string[] paraNames, out string[] typeNames)*{Regex reg = new Regex("^Func\\<(?<types>.*?)\\>\\((?<paras>.*)\\)$");Match m = reg.Match(defStr);typeNames = m.Groups["types"].Value.Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);paraNames = m.Groups["paras"].Value.Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);//型の数=パラメータの数+1if (typeNames.Length == paraNames.Length + 1){//型名とパラメータ名の合理性チェックif (typeNames.All(name => GetFieldType(name) != null)){Regex regVar = new Regex("^[a-zA-Z][a-zA-Z0-9_]*$");if (paraNames.All(value => regVar.IsMatch(value)))return;}}throw new FormatException();}
関数定義部からパラメータ名と型を抽出する
toGoPoint = goalPoint.transform.position;
目的地に設置したオブジェクトの座標
Debug.WriteLine(EnumHelper.FromAlias<SampleEnum>("N"));
エイリアスから列挙値へ変換
Debug.WriteLine(EnumHelper.FromAlias<SampleEnum>("X"));
存在しないエイリアスから列挙値への変換
Debug.WriteLine(EnumHelper.GetAlias(SampleEnum.None));
列挙値をエイリアスに変換
IList<SampleEnum> values = EnumHelper.GetOrderedValues<SampleEnum>(false);
表示順で列挙値を取得
IList<SampleEnum> values = EnumHelper.GetOrderedValues<SampleEnum>(true);
表示順で列挙値を取得（非表示を除く）
return new EnumDisplayInfo(enumValue.ToString().ToUpper(), (int)enumValue);
定義名を大文字に変換したものを表示名とする
string xml=XMLClass.SaveToString<SaveData>(save);
データをXML化
SaveData sdata =XMLClass.LoadFromString<T>(string s);
データをxmlから復元
services.AddDbContext<MyDbContext>(options => {options.UseInMemoryDatabase(databaseName: "MyDb");
インメモリ DB を使う設定
using (var fs = new System.IO.FileStream(fileFullPath, System.IO.FileMode.Open, System.IO.FileAccess.Read)){result = new byte[fs.Length];
ファイルを読み取りモードで開く
result = new byte[fs.Length];
データ格納用の配列を確保する
await fs.ReadAsync(result, 0, (int)fs.Length);
バイナリデータを非同期的に読み込む
var table = Table.LoadTable(client, tableName);
テーブルを取得
var result = client.PutItemAsync(request).Result;
テーブルに追加
var receivedMessage = turnContext.Activity.Text;
メッセージ取得
item.PropertyChanged += OnPropertyChanged;
イベント変更通知を登録
root.AddEntry(dir1);
フォルダーを追加する
item.ActionOnClick += val =>{Debug.Log("clicked: " + val.name);};
アクションイベントの登録
float X_Rotation = Input.GetAxis("Mouse X");
マウスのX軸がどれほど移動したかを取得します
var tableList=client.ListTablesAsync().Result;
テーブル一覧を取得
return tableList.TableNames.Exists(s => s.Equals(tableName));
TableNamesプロパティをチェック
containerRegistry.RegisterForNavigation<ViewA>();
Viewの登録
skillResponse.Response.ShouldEndSession = true;
セッション終了を指定
var ns = x.Name.Namespace;
Namespaseの値を取得
ChannelState state = channel.State;
状態が変更されるまで待機する
OnChannelStateChanged(state, channel.State);
状態が変更されたときの処理を実行する
skillResponse.Response.ShouldEndSession = true;
セッション終了させる。
var getTag = await TagLibMP4Extentions.GetMetaTagAsync(mp4Path);
タグの取得
Texture2D texture = new Texture2D(2048, 2048, TextureFormat.DXT5Crunched, false);
DXT5Crunched の空のテクスチャを用意
www.LoadImageIntoTexture(texture);
テクスチャを読み込み
texture.Compress(false);
テクスチャ圧縮
textureArray[key] = (T)(object)texture;
テクスチャを割り当て
string stBuffer = cReader.ReadLine();
1行ずつ読み込む
var reqStream = req.GetRequestStream();
データをPOST送信するためのStreamを取得
reqStream.Write(postDataBytes, 0, postDataBytes.Length);
送信するデータを書き込む
var res = req.GetResponse();
サーバーからの応答を受信する
var resStream = res.GetResponseStream();
応答データを受信するためのStreamを取得
Point mouseUpPoint = e.GetPosition(AssociatedObject);
選択中文字列の背景色変更
Point mouseUpPoint = e.GetPosition(AssociatedObject);
選択終了
TextRange ntr = new TextRange(start, end);
TextBlockから選択範囲文字列取得
proc.StartInfo.FileName = "exeへのフルパス";
ファイルパス設定
rigid.AddForce (Vector2.up * 5.0f, ForceMode2D.Impulse);
ジャンプの力を加える
this.Visible = false;
フォームを閉じる操作をされた
context.ShowMeshes();
メッシュを表示します
System.IO.StreamWriter sw = new System.IO.StreamWriter(@"AccessToken.txt",false,System.Text.Encoding.GetEncoding("utf-8"));
ファイルを上書きし、utf-8で書き込む
sw.WriteLine(tokens.AccessToken);
txtの内容を1行ずつ書き込む
cancellationToken.Cancel();
キャンセル要求出す
System.IO.StreamWriter sw = new System.IO.StreamWriter(@"TodoList.txt",false,System.Text.Encoding.GetEncoding("utf-8"));
ファイルを上書きし、Shift JISで書き込む