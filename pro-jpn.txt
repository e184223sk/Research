public class StudentInfoMap : CsvHelper.Configuration.ClassMap&lt;StudentInfo&gt;{    public StudentInfoMap()    {        Map(result =&gt; result.ID).Index(0);        Map(result =&gt; result.Japanese).Index(1);        Map(result =&gt; result.Mathematics).Index(2);        Map(result =&gt; result.Science).Index(3);        Map(result =&gt; result.SocialStudies).Index(4);        Map(result =&gt; result.English).Index(5);    }}
「CSVヘルパーを使ったマッピング用のクラス」IDをCSVの1つ目の要素に指定する。JapaneseをCSVの2つ目の要素に指定する。MathematicsをCSVの3つ目の要素に指定する。ScienceをCSVの4つ目の要素に指定する。SocialStudiesをCSVの5つ目の要素に指定するEnglishをCSVの6つ目の要素に指定する
public class StudentInfo{    public long ID { get; set; }    public int Japanese { get; set; }    public int Mathematics { get; set; }    public int Science { get; set; }    public int SocialStudies { get; set; }    public int English { get; set; }}
「生徒の成績をまとめたクラス」IDは生徒の出席番号。Japaneseは国語の点数。Mathematicsは数学の点数。Scienceは理科の点数。SocialStudiesは社会の点数。Englishは英語の点数。
public class StudentSearchModel{    public long ID { get; set; }    public string Name { get; set; }    public int Age { get; set; }    public int Grade { get; set; }    public string Class { get; set; }}
「生徒検索用のクラス」IDは生徒の番号(long型)。Nameは生徒の名前(string型)。Ageは生徒の年齢(int型)。Gradeは生徒の学年(int型)。Classは生徒の所属するクラス(string型)。
public IActionResult ExportCsv([FromForm] StudentSearchModel model){    var results = _repository.GetStudentInfo(model).ToList());    var bytes_separate = Encoding.GetEncoding("Shift-JIS").GetBytes("-----成績一覧-----\r\n");    var bytes_results = GetCsvData&lt;StudentInfo, StudentInfoMap&gt;(results);    return File(        bytes_separate        .Concat(bytes_results)        .ToArray(),        "text/csv",        "sample.csv");}private static byte[] GetCsvData&lt;T, TMap&gt;(List&lt;StudentInfo&gt; list) where TMap : ClassMap{    var ms = new MemoryStream();    var sw = new StreamWriter(ms, Encoding.GetEncoding("Shift-JIS"));    var cw = new CsvWriter(sw, CultureInfo.CurrentCulture);    //ここの仕様が変わった？ 以前は "cw.Configuration.RegisterClassMap" のようにしていたと思う    cw.Context.RegisterClassMap&lt;TMap&gt;();    cw.WriteRecords(list);    sw.Flush();    return ms.ToArray();}
「CSVを出力するためのAction(ExportCsv)を用意」この時のCSVは普通のものとは少し違い、区切り線も出力する必要があった。_repositoryはDB操作をするための自作クラスの変数。GetStudentInfoでDBから情報を取得してくる。File関数でbyte配列をつなぐ。
var s = "&lt;EMBEDDED QUERY GOES HERE&gt;";var base64 = HttpUtility.UrlDecode(s);var buffer = new byte[1024];string queryString = string.Empty;var e = Convert.FromBase64String(base64);using (var gz = new GZipStream(new MemoryStream(e), CompressionMode.Decompress)){    while (true)    {        var len = gz.Read(buffer, 0, buffer.Length);        queryString += Encoding.UTF8.GetString(buffer, 0, len);        if (len &lt; buffer.Length)        {            break;        }    }}queryString.Dump();
「クエリ文字列をデコードするコード」URLのクエリ文字列中に埋め込まれた Kusto クエリは、元の Kusto クエリを ZIP 圧縮したビット列を BASE64 にエンコードしたものです。この部分を取り出して、元の Kusto クエリを取り出すコード。
private void OnEnable(){    _lastTime = CurrentTime();    this.UpdateAsObservable()        .FirstOrDefault(_ =&gt; Time.unscaledTime - _lastTime &gt; lifespan)        .Subscribe(_ =&gt;        {            // UIを消す処理        });}
「UniRXで一定時間UIに触れないとUIが消えるようにする」
List&lt;string&gt; SharpList = new List&lt;string&gt;();SharpList.Add("So Smart!");
「string型のリストSharpListを宣言」SharpListに"So Smart!"という文字列を追加。
Dictionary&lt;string,List&lt;string&gt;&gt; SharpDict = new Dictionary&lt;string,List&lt;string&gt;&gt;();SharpDict.Add("So Smart", new List&lt;string&gt;{"be", "so", "smart", "!"});
「string型をキーにstring型のリストを値とするDictionary、SharpDictを作る」SharpDictに"So smart!"というキーと{"be","so","smart","!"}という値を持ったstring型のリストを追加。
List&lt;List&lt;int&gt;&gt; DevilList = new List&lt;List&lt;int&gt;&gt;();
「int型のリストを格納するリストDevilListを宣言」
AngelNestList.Add(new List&lt;int&gt; { 1, 2, 3 });
「AngelNestListに{1,2,3}という値を持ったint型のリストを追加」
List&lt;List&lt;int&gt;&gt; AngelNestList = new List&lt;List&lt;int&gt;&gt;{    new List&lt;int&gt;{1,2,3},    new List&lt;int&gt;{4,5,6},    new List&lt;int&gt;{7,8,9},};
「int型のリストを格納するリストの宣言」int型のリストを格納するリストAngelNestListを宣言し、{1,2,3}というリストと{4,5,6}というリストと{7,8,9}というリストを追加。
List&lt;Dictionary&lt;string, string&gt;&gt; MyFamily = new List&lt;Dictionary&lt;string, string&gt;&gt;(){    new Dictionary&lt;string, string&gt;{{Name = "Mickey"},{Kind = "Mouse"}},    new Dictionary&lt;string, string&gt;{{Name = "Pluto"},{Kind = "Dog"}},};
「Dictionaryの宣言」stringをキーにstringの値を取り出すDictionaryを格納するリストMyFamiliyを宣言し、"Mickey"をキーに"Mouse"を取り出すDictionaryと、"pluto"をキーに"Dog"を取り出すDictionaryを追加。
services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)    .AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, option =&gt;     {         option.LoginPath = "/LoginController/LoginAction";         option.AccessDeniedPath = "/LoginController/ForbidAction";         option.Cookie.Name = "token";         option.ExpireTimeSpan = TimeSpan.FromMinutes(5);     });
「ASP.NET Core MVCでCookieによる認証の利用及びタイムアウトの設定」option.LoginPathはHttpContext.ChallengeAsync(認証チャレンジ)で認証失敗した場合のリダイレクト先。option.AccessDeniedPathはHttpContext.ForbidAsync（認証されているが、必要な権限がない時の禁止）でのリダイレクト先。option.Cookie.Nameは該当スキームのCookie名、デフォルトは.AspNetCore.Cookies。option.ExpireTimeSpanはCookieの中に保存されている認証データの有効期限、ここでは5分以内にサーバーへアクセスがないと認証タイムアウトが発生する。
app.UseAuthentication();app.UseAuthorization();
認証ミドルウェアを登録する。認可ミドルウェアを登録する。
[HttpPost][AllowAnonymous]public async Task&lt;ActionResult&gt; Login(string loginId,string loginPW,string ReturnUrl){    var claims = new List&lt;Claim&gt;(){                        new Claim(ClaimTypes.Sid,loginId)                    };    var identity = new ClaimsIdentity(claims, authSchema);    var identityPrincipal = new ClaimsPrincipal(identity);    //認証サービス登録する際に設定したスキームと同じものを設定    await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, identityPrincipal,         new AuthenticationProperties            {                //サーバーアクセスによる認証時間を更新する                AllowRefresh = true,                //認証の有効期間,認証cookieタイムアウト                ExpiresUtc = DateTimeOffset.UtcNow.AddMinutes(5),                //cookieの有効期間を優先かsessionを優先か                //true:cookieが有効であれば、ブラウザを閉じても再ログインが必要ない                //false:ブラウザ閉じたら再ログインが必要                IsPersistent = false,                //cookieの認証時間                IssuedUtc = DateTime.UtcNow            });    return Redirect(ReturnUrl);}
「ログイン認証処理」ログイン関数は引数にstring型のloginIdとstring型のloginPWとstring型のReturnUrlを受け取りログイン処理をする。
ExpiresUtc = DateTimeOffset.UtcNow.AddMinutes(5)
「認証の有効期間,認証cookieタイムアウトを5分に設定」
services.AddSession(option=&gt;    {        option.IdleTimeout = TimeSpan.FromMinutes(5);    });
「ASP.NET Core MVCでSessionの利用及びタイムアウトの設定」
app.UseSession();
「セッションミドルウェアの登録」
public override void SetFrom(TweenerCore&lt;Angle, Angle, AngleOptions&gt; t, bool isRelative){    //開始値と終了値を反転させる    Angle prevEndAngle = t.endValue;    t.endValue = t.getter();    t.startValue = isRelative ? t.endValue + prevEndAngle : prevEndAngle;    t.setter(t.startValue);}
「2つの値の入れ替え」endValueとstartValueの値を入れ替える。
public override void SetFrom(TweenerCore&lt;Angle, Angle, AngleOptions&gt; t, Angle fromValue, bool setImmediately, bool isRelative){    t.startValue = fromValue;    if (setImmediately) t.setter(fromValue);}
「引数を代入する」引数のfromValueをstartValueに代入する。
public override void SetChangeValue(TweenerCore&lt;Angle, Angle, AngleOptions&gt; t){    //TweenerCoreのchangeValueに開始値と終了値の差分を計算して代入する    t.changeValue = t.endValue - t.startValue;}
「差分を返す関数」endValueとstartValueの差分を返す関数。
public enum AngularVelocityUnit{    Unspecified,    DegreePerSecond,    RadianPerSecond}
「enumの宣言」enum型のAngularVelocityUnit。要素にUnspecifiedとDegreePerSecondとRadianSecondを持つ。
using System;class Prog{    static void Main() {        int[] list ={1, 2, 3, 4, 5};        int[] list2 = new int[list.Length];        for(int i=0;    i&lt;list.Length;  i++) {            list2[i] = list[i] * 10;        }        foreach(int i in list2){            Console.WriteLine(  i);             }    }}
「要素を操作」int型リストのlistを宣言し、{1,2,3,4,5}の値を代入for文でlist2にlistの値を10倍したものを代入し、Console.WriteLineで出力。
using System;using System.Linq;using System.Collections.Generic;class Prog{    static void Main() {        int[] list ={1, 2, 3, 4, 5};                IEnumerable&lt;int&gt; list2 = list.Select(    i =&gt; i*10);        foreach(int i in list2){            Console.WriteLine(  i);             }    }}
「要素を操作」int型リストのlistを宣言し、{1,2,3,4,5}の値を代入。int型リストのlist2にLinqのSelect関数を使いlistの値を10倍したものを代入し、Console.WriteLineで出力。
using System;using System.Collections.Generic;class Prog{    static void Main() {        List&lt;int[]&gt; ls = new List&lt;int[]&gt;(); //配列のリスト        for(int i=0;    i&lt;3;    i++){              ls.Add(     new int[2]);        }        List&lt;int&gt; ls2 = new List&lt;int&gt;();            foreach(int[] array in ls){             foreach(int i in array){                    ls2.Add(i);            }        }        foreach(var val in ls2) {                       Console.WriteLine(val);        }    }}
「平坦化」{0,0}というint型の配列を3つ持ったlsをforeachを使いls2に追加していき1個のリストにまとめる。まとめた結果をConsole.WriteLineで出力する。
using System;using System.Linq;using System.Collections.Generic;class Prog{    static void Main() {        int[] ls = { 2,2,2};        IEnumerable&lt;int&gt; ls2    = ls.SelectMany(   x =&gt; new int[x] );        foreach(int i in ls2) {            Console.WriteLine(i);        }    }}
「平坦化」{0,0}というint型の配列を3つ持ったlsをSelectMan関数を使いls2にまとめる。SelectManyは、コレクションの要素を操作してバラバラにして返す。ラムダ式で作られる配列を１つずつintにして、intのコレクションにして返す。
using System;using System.Collections.Generic;class Prog{    static void Main() {        int[] ls = {1,2,3,4,5};        List&lt;int&gt; ls2 = new List&lt;int&gt;();        foreach(int i in ls) {            if( i&gt; 3)   ls2.Add(i);        }        foreach(var val in ls2) {            Console.WriteLine(val);        }    }}
「条件で抽出」int型の配列lsを宣言し{1,2,3,4,5}の値を代入する。if文で3より大きい値のみint型IEnumerableのls2に追加する。ls2の値をConsole.WriteLineで出力。
using System;using System.Linq;using System.Collections.Generic;class Prog{    static void Main() {        int[] ls = {1,2,3,4,5};        IEnumerable&lt;int&gt; ls2 = ls.Where(    x =&gt; x &gt; 3);        foreach(int i in ls2) {            Console.WriteLine(i);        }    }}
「条件で抽出」int型配列lsに{1,2,3,4,5}という値を代入。LinqのWhere関数を使い3より大きい値をls2に追加。ls2の値をConsole.WriteLineで出力。
using System;using System.Linq;using System.Collections.Generic;class Prog{    static void Main() {        int[] ls = {1,2,3,4,5};        IEnumerable&lt;int&gt; ls2 = ls.Where(x =&gt; x &gt; 3).Select(x =&gt; x *10);        foreach(int i in ls2) {            Console.WriteLine(i);        }    }}
「WhereとSelectの組み合わせ」int型IEnumerableのlsに{1,2,3,4,5}を代入。4以上の数値だけに10をかけてint型配列ls2に格納。ls2の値をConsole.WriteLineで出力。
using System;using System.Linq;class Prog {    public static void Main() {        int[] ary = { 6, 12, 7, 1, 4 };        IOrderedEnumerable&lt;int&gt; order = ary.OrderBy(x =&gt; x);        foreach(int i in order) {            Console.WriteLine(i);        }    }}
「並び替え」int型配列aryに{ 6, 12, 7, 1, 4 }を代入。LinqのOrderBy関数を使い昇順に並び替えた結果をint型を格納するIOrderedEnumerableのls2に代入。ls2の値をConsole.WriteLineで出力。
using System;using System.Linq;class Prog{    public static void Main(string[] args) {        string[] names = {            "ナポレオン",            "ピカソ",            "エジソン",        };        foreach(var ins in names.Select((name) =&gt; new { Name = name, Count = name.Length })) {            string output = string.Format("{0}は、{1}文字", ins.Name, ins.Count);            Console.WriteLine(output);        }    }}
「匿名クラス」string型配列namesに "ナポレオン", "ピカソ","エジソン",}を代入。foreachの対象となる配列にNameとCountを持つ匿名クラスを設定する。Console.WriteLineでFormat関数で書式設定した文字列を出力。
using System;namespace CSharpLibrary{    public class CSharpClass    {        public static void printType&lt;T&gt;(T t)        {            Console.WriteLine(t.GetType().FullName + "|");        }    }}
「引数の型を出力」CSharpLibraryという名前空間の中に、CSharpClassというクラスを作成。PrintType関数はConsole.WriteLineで引数tの型を出力。
using UnityEngine;namespace Ono.MVP.Model{    public class CubeRotationModel : MonoBehaviour    {        public static CubeRotationModel Instance;        private void Awake()        {            Instance = this;        }        public void SetRotationX(float x)        {            var rot = Quaternion.AngleAxis(x, Vector3.right);            transform.rotation =  rot;        }        public void SetRotationY(float y)        {            var rot = Quaternion.AngleAxis(y, Vector3.up);            transform.rotation =  rot;        }        public void SetRotationZ(float z)        {            var rot = Quaternion.AngleAxis(z, Vector3.forward);            transform.rotation =  rot;        }    }}
「XYZの回転を設定」publicなクラスCubeRotationModelにMonoBehaviourを継承する。Awake関数でCubeRotationModel型の変数Instanceに自分自身を設定する。SetRotationXは引数のx(float型)をもとにQuaternion.AngleAxis関数で回転を設定する。SetRotationYは引数のy(float型)をもとにQuaternion.AngleAxis関数で回転を設定する。SetRotationZは引数のZ(float型)をもとにQuaternion.AngleAxis関数で回転を設定する。
Environment.SetEnvironmentVariable("SofTalk", $"C:\\softalk\\", EnvironmentVariableTarget.Machine);
「環境変数Pathへの追加」Environment.SetEnvironmentVariableの引数に設定したい変数名とPathを入力するとシステム環境変数に追加できる。
string base_paths = System.Environment.GetEnvironmentVariable("Path", System.EnvironmentVariableTarget.Machine);Environment.SetEnvironmentVariable("Path", base_paths + ";" + "C:\\softalk\\", EnvironmentVariableTarget.Machine);
System.Environment.GetEnvironmentVariable関数で変更前の環境変数Pathの値を全て取得する。Environment.SetEnvironmentVariable関数で環境パスを設定する。
class Program{    static void Main(string[] args)    {        Sample sample = new Sample();        sample.Paint();         IExistsImplement iSample = new Sample();        iSample.Paint();     }}public class Sample : IExistsImplement{}interface IExistsImplement{    void Paint() =&gt; Console.WriteLine("Default Paint method");}
「インタフェースの継承」IExistsImplementはConsole,WriteLineで"Default Paint method"と出力するPaint関数を持ったインタフェース。SampleクラスはIExistsImplementを継承したクラス。ProgramクラスはMain関数でSample型のsampleとIExistsImplement型のiSampleを定義し、Paint関数を呼んでいる。
class Program{    static void Main(string[] args)    {        Sample sample = new Sample();        sample.Paint();         IExistsImplement iSample = new Sample();        iSample.Paint();    }}public class Sample : IExistsImplement{}interface IExistsImplement{void Paint() =&gt; Console.WriteLine("Default Paint method");}class Program{    static void Main(string[] args)    {        Sample sample = new Sample();        sample.Paint(); 　        IExistsImplement iSample = new Sample();        iSample.Paint(); 　    }}public class Sample : IExistsImplement{    public void Paint() =&gt; Console.WriteLine("Change Paint method");}interface IExistsImplement{    void Paint() =&gt; Console.WriteLine("Default Paint method");}
「インタフェースの継承」IExistsImplementはConsole,WriteLineで"Default Paint method"と出力するPaint関数を持ったインタフェース。SampleクラスはIExistsImplementを継承したクラスでPaint関数を新たに定義している。ProgramクラスはMain関数でSample型のsampleとIExistsImplement型のiSampleを定義し、Paint関数を呼んでいる。
