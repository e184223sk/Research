var results = _repository.GetStudentInfo(model).ToList());
_repositoryはDB操作をするための自作クラスの変数。GetStudentInfoでDBから情報を取得してくる
m_texture.SetPixel( x, y, Color.black );
点を描画
services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
.AddCookieでは認証用のCookieに関する設定です
option.LoginPath = "/LoginController/LoginAction";
HttpContext.ChallengeAsync(認証チャレンジ)で認証失敗した場合のリダイレクト先
option.AccessDeniedPath = "/LoginController/ForbidAction";
HttpContext.ForbidAsync（認証されているが、必要な権限がない時の禁止）でのリダイレクト先
option.Cookie.Name = "token";
該当スキームのCookie名
option.ExpireTimeSpan = TimeSpan.FromMinutes(5);
Cookieの中に保存されている認証データの有効期限、ここでは5分以内にサーバーへアクセスがないと認証タイムアウトが発生する
var claims = new List<Claim>(){new Claim(ClaimTypes.Sid,loginId)};
ログインID,パスワードチェック処理省略、ログイン出来ると仮定する
await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, identityPrincipal,
認証サービス登録する際に設定したスキームと同じものを設定
AllowRefresh = true,
サーバーアクセスによる認証時間を更新する
ExpiresUtc = DateTimeOffset.UtcNow.AddMinutes(5),
認証の有効期間,認証cookieタイムアウト
IsPersistent = false,
cookieの有効期間を優先かsessionを優先か
IssuedUtc = DateTime.UtcNow
cookieの認証時間
option.IdleTimeout = TimeSpan.FromMinutes(5);
5分以上操作がないとセッションタイムアウト
data_1.number = data_2.number = ResultData.no.Tostring();
data_1にそのまま代入
if (data_3 != null)
data_3がnullでない場合
builder.WithOrigins(this.Configuration.GetSection("CorsUrl").Value)
appsettings.jsonから"CorsUrl"の値を取得して設定。
List<int> ls2 = new List<int>();
ls2に全ての要素を入れ直す
csv.ReadHeader();
ヘッダー　を次に行う
csv.Configuration.RegisterClassMap<CsvMapperKenAll>();
データを読み出し
tempDatas = new ObservableCollection<KenAllCSV>();
DataGridに出力
{return (IEnumerable)obj.GetValue(SelectableDatesProperty);}
ゲッター
{obj.SetValue(SelectableDatesProperty, value);}
セッター
datePicker.DisplayDateStart = minDate;
区間の最初を設定
_sliderX.OnValueChangedAsObservable()
X軸操作用Sliderの値の変更を監視
_sliderY.OnValueChangedAsObservable()
Y軸操作用Sliderの値の変更を監視
_sliderZ.OnValueChangedAsObservable()
Z軸操作用Sliderの値の変更を監視
valueText.text = arrangeValue.ToString();
テキストに値を反映
_sliderView.SliderValueRP_X
Sliderの値の更新を監視
Environment.SetEnvironmentVariable("Path",
環境パス設定
var conversationId = "<ConversationID>";
API経由で取得したConversationID
readonly ObservableCollection<Person> tmpPeople = new ObservableCollection<Person>();
DataGridにバインドするModel
var keyFunc = GetDynamicPropertyExpression(e.Column.Header.ToString()).Compile();
p => p."columnName"というラムダ式を生成
sortedPeople = new List<Person>(tmpPeople.OrderBy(keyFunc));
ColumnNameの中身でOrderBy
sortedPeople = new List<Person>(tmpPeople.OrderByDescending(keyFunc));
ColumnNameの中身でorderByDescending
pipeServer.WaitForConnection();
クライアントの接続待ち
cam.transform.position = position.transform.position;cam.transform.rotation = position.transform.rotation;
カメラを移動
csvDatas.Add(cell.Split(','));
','を目安にリストに格納していく
for (int i = 0;values.Length > i;i++) {values[i] = Random.value;}
選択に使用する[0.0f~1.0f]の値を用意する
for (int k = 0;iteration > k;k++) {weightedSelector.SelectItem(values[k]);
WeightedSelectorからアイテムを選択する
SceneManager.LoadScene(sceneName);
シーンチェンジ
PhotonNetwork.JoinLobby();
ロビーへ移動する
roomButton.name = r.Name;
ボタンの名前を作成するルームの名前にする
{if (gameObject.transform.Find(r.Name)){GameObject.Destroy(gameObject.transform.Find(r.Name).gameObject);}}
ルームボタンの削除
if (gameObject.transform.Find(r.Name)){
ボタンが存在すれば削除
PhotonNetwork.JoinLobby();
ロビーへ移動する
yield return new WaitUntil(() => Input.anyKeyDown);
キー入力を待機
if(createRoomName == "")
ルーム名が入力されてないなら自動生成
RoomOptions roomOptions = new RoomOptions();
ルームのオプションの設定
PhotonNetwork.CreateRoom(createRoomName, roomOptions , null);
指定したルーム名と同じルーム名が存在している場合、PhotonNetworkの方で作成できないようになっている
if (IsSelected)
選択状態の場合のみ
if (Bounds.Width < 0){
幅がマイナスの場合
if (Bounds.Height < 0){
高さがマイナスの場合
public struct Data{[DataMenber]public int hoge;}
Dataの構造体の定義
private Data data;
Dataのインスタンス
dataContractJsonSerializer.WriteObject(memoryStream, data);
memoryStreamにDataのインスタンスをシリアライズしたJsonデータを書き込む
memoryStream.Position = 0;
カーソル位置を最初に戻す
using(var streamReader = new StreamReader(memoryStream, Encoding.UTF8)){var filePath = "任意のファイルのパス";File.WriteAllText(filePath, streamReader.ReadToEnd(), Encoding.UTF8);}
memoryStreamの内容を読み込んで、全ての文字列をファイルに書き出す
if(sch == null)
スキーマがあるかどうかを判定
sb.SetSchemaName("適当なスキーマ名");
スキーマ名をセット
sb.AddSimpleField("適当なフィールド名", typeof(string));
フィールド名設定
sch = sb.Finish();
スキーマを取得
Entity ent = doc.ProjectInformation.GetEntity(sch);
Entityを取得
ent.Set<FieldType>("適当なフィールド名", xmldata.ToString());
XMLを設定
doc.ProjectInformation.SetEntity(ent);*,,,
Docに設定
if (!elem.GetEntity(sch).IsValid())
有効な値が無い時
if (e.ErrorCode != 49)
エラー コード 49 は「認証失敗」
encode = encode ?? Encoding.GetEncoding("Shift-JIS");*var cutChars = text
エンコード未指定時はShift-JISを仮置き
var templateMat = new Mat(fileName);
マッチング
if (match < 0){
マッチなし
Cv2.MinMaxLoc(resultMat, out _, out var maxVal, out _, out matchPoint);
一番マッチした箇所のマッチ具合と、その位置を取得する
GameObject _wb = GameObject.FindGameObjectWithTag("Whiteboard");
GameObjectを取得。
texture = (Texture2D)_wb.GetComponent<Renderer>().material.mainTexture;
TextureをGameObjectから取得
StartCoroutine(SendData(picData));
SendDataを呼び出す
var request = new UnityWebRequest(url, "POST");
サーバ上のphpに送信する
if (GamepadIndex != null){
認識済みの場合
GamepadIndex = null;
認識済みのゲームパッドが無効になったとみなす
var date = new DateTime(2021, 1, 1, 0, 0, 0, 0);
2021/01のパッチだけ取得
level.Value++;
.Valueで中身にアクセスする
string responceStr = Encoding.UTF8.GetDtring(responceByte);
リクエストを送信し、レスポンスを取得
return (responce.permalink);
取得したメッセージのURLを返す
[DataType(DataType.Date)]
DataTypeの指定
{DateTime time = DateTime.Now;for (int i = 0; i < count; i++){action();}return DateTime.Now - time;}
関数の処理にかかる時間を計測する
catch (Exception ex)
例外をcatchする。
*{HttpClientInitializer = credential,ApplicationName = ApplicationName,});
ReportsAPIサービスを作成します
{this.name = name;this.age = age;}
情報は直接変数にアクセスできない様にメソッド化する
Info[] src = new Info[] { };
Infoクラスをインスタンス化
var list = new List<Info>();
Listを生成
list.AddRange(src);
listに要素を追加
var c = new Comparison<Info>(Compare);
listをソート
var x = a.age - b.age;
xにはa.ageとb.ageの差が入る
HttpWebResponse response = (HttpWebResponse)request.GetResponse();
リクエスト出す
project.Add(dir);
プロジェクトインスタンスに追加
session.Log("in customaction");
MSIのログに出力
session["A_PROPERTY"] = "ABCDE";
MSIプロパティを設定する
*string propb = session["B_PROPERTY"];
MSIプロパティを取得する
string caData = session.CustomActionData;
CustomActionDataを取得する
ActionAssembly = "%this%",
カスタムアクションメソッドが入っているアセンブリを指定する
using UnityEngine;
共通クラスライブラリ
protected override void Initialize()
UnityのDebugLog出力ソースコード
{Ground.In.Value = level;}
ログ出力レベルの変更
PdfDocument doc = new PdfDocument();
PdfDocument obejctを作成します。
doc.LoadFromFile(@"C:\Users\Administrator.SD-20151030NEMY\Desktop\java输出\吾輩.pdf");
PDFをロードします
PdfPageBase page = doc.Pages[4];
スタンプを作成するページを取得します。
PdfTemplate template = new PdfTemplate(180, 50);
テンプレートオブジェクトを作成します
PdfCjkStandardFont font1 = new PdfCjkStandardFont(PdfCjkFontFamily.SinoTypeSongLight, 16f, PdfFontStyle.Bold | PdfFontStyle.Italic);
フォントを設定します。
PdfSolidBrush brush = new PdfSolidBrush(Color.Purple);
ソリッドブラシとグラデーションブラシを作成します。
template.Graphics.DrawPath(gradientBrush, path);
テンプレートで角丸長方形のパスを描き、グラデーションで塗りつぶします。
template.Graphics.DrawPath(PdfPens.Purple, path);
テンプレートで角丸長方形のパスを描き、紫色でパスを塗りつぶします。
PdfRubberStampAnnotation stamp = new PdfRubberStampAnnotation(new RectangleF(new PointF(page.ActualSize.Width - 250, 200), template.Size));
PdfRubberStampAnnotationオブジェクトを作成し、そのサイズを設定します。
PdfAppearance apprearance = new PdfAppearance(stamp);
PdfApperanceオブジェクトを作成し、テンプレートをnormalにします。
stamp.Appearance = apprearance;
スタンプでPdfApperanceオブジェクトを適用します。
page.AnnotationsWidget.Add(stamp);
スタンプをPdfAnnotationに追加します。
System.IO.Directory.SetCreationTime(BasePath + "新しいフォルダー", DateTime.Now);
作成日時の設定
System.IO.Directory.SetLastWriteTime(BasePath + "新しいフォルダー", DateTime.Now);
更新日時の設定
System.IO.Directory.SetLastAccessTime(BasePath + "新しいフォルダー", DateTime.Now);
アクセス日時の設定
var TrendsJson = tokens.Trends.Place(15015370);
JSONデータを取得
string UrlDec = System.Web.HttpUtility.UrlDecode(JsonData);
URLデコードする
Root TrendData = JsonConvert.DeserializeObject<Root>(UrlDec);
JSON文字列をデシリアライズ
Thread.Sleep(1000);
1秒待つ
Random Rnd = new Random();
ランダム数値生成
string TrendText = TrendData.json_data[0].trends[TrendRdm].query;
トレンド文字列取得
TrendText = TrendText.Replace("#","");
#を置換
Thread.Sleep(1000);
1秒待つ
var color = GetCurrentColor();
colorを設定ファイルから呼び出します
ResizeHandles.Draw(g);
リサイズハンドルを描画
typeof(T).TypeHandle;
Handleにアクセス
typeof(T).TypeHandle.Value;
IntPtrにアクセス
int data = (int)(object)100;
100をdataの中に入れる
nested_ptr_arr [i] = *((byte*)data_ptr + 16 + i);
先頭の16byte分ずらしたところから8byte分だけ切り取る
private Random Random { get; } = new();
表示位置をランダムにするための Random クラス
Items.Add(new(Random.Next(500), Random.Next(500), DateTime.Now.ToString()));
ランダムな位置に、とりあえず現在時間の文字列を出すようなデータを作る
if (navigationContext.Parameters.TryGetValue<int>("x", out var x))*{
パラメーターから表示位置や表示する内容を取得してプロパティに保持
var targets = sources.Select(sourceToTarget).ToObservableCollection();
sourcesの要素を変換したコレクションを生成
SyncCollectionTwoWay(sources, targets, sourceToTarget, targetToSource);
2つのコレクションを同期させる
string senderName = "anonymous";
送信者の名前用変数
if (!string.IsNullOrEmpty(mi.Sender.NickName)){
送信者の名前があれば
showText.text = senderName + ": " + newLine;
受信したチャットをログに追加
jar.WaitForExit();
終了待ち
jar.ExitCode();
結果取得
db.Database.EnsureCreated();
スキーマとかテーブルが無かったら作るよ。
int recordsAffected = db.SaveChanges();
データベースへ保存
Console.ReadKey();
キー入力待ち
Presentation ppt = new Presentation();
PPTファイルをロードします。
ISlide slide = ppt.Slides[0];
スライドを取得します。
slide.Shapes.AppendVideoMedia(@"ビデオ.mp4", new RectangleF(300, 150, 300, 150));
スライドに動画を挿入します。
foreach (ISlide slide in ppt.Slides){
スライドをループします。
foreach (IShape shape in slide.Shapes){
スライド内のシェイプをループします。
if (shape is IVideo){
シェイプが動画なのか判断します。
(shape as IVideo).EmbeddedVideoData.SaveToFile(string.Format(@"動画{0}.mp4", i));
動画を保存します。
Array.Resize(ref numbers, numbers.Length + 1);
配列サイズを１つ増やす
for (int i = 0; i < 5; i++) {*numbers[i] = int.Parse (Console.ReadLine ());
今回はからの配列内にコンソールの入力値を格納
var myTable = new Dictionary<string, int>();
まずは空のdictionary型を生成して変数に代入
myTable.Add("Hokkaido", 1);
dictionary型の変数にkeyとvalueを追加
*List<string> keyList = new List<string>(myTable.Keys);
Dictionary型をListに変換する
uniTask.ToAsyncLazy();
AsyncLazyに変換
var GetCommentsresponse = GetCommentsClient.Execute(CommentsRequest);
コメント情報を取得
var JsonCommentsData = JsonSerializer.Deserialize<Root>(GetCommentsresponse.Content);
レスポンスをデシリアライズ
foreach (var comment in JsonCommentsData.comments)*{
メッセージを取得
Console.WriteLine(comment.message);
コンソールに出力
string appPath = App.GetAppPath();
パス取得
string cfgFilePath = System.IO.Path.Combine(appPath, ConfigFileName);
設定ファイルのフルパス組み立て
if (System.IO.File.Exists(cfgFilePath))*{
設定ファイル存在チェック
this.Exit += (_, _) => containerRegistry.GetContainer().Dispose();
Exit時に Service と Reader も Dispose される。
Console.WriteLine("bootstrap servers を入力してください（省略時 127.0.0.1）：");
コンソールからパラメーターを受け取る
using var cancelTokenSource = new CancellationTokenSource();
キャンセルトークンを生成する
{return new SampleMessageKey(Guid.NewGuid().ToString());}
キーを生成するメソッド
var factory = new SampleMessagePublisherFactory(publisherSetting, new SampleLogger());
パブリッシャーを生成する
var factory = new SampleMessageSubscriberFactory(subscriberSetting, new SampleLogger());
observable パターンでメッセージを監視する
OpenCvSharpHelper.ImShow("test", rtb);
testウィンドウにRenderTargetBitmapを表示する
var ev3 = new EV3("10.0.1.1", 6789);
EV3に接続 (EV3上で'lejos-server'が動作している前提)
{if (e.KeyData == Keys.Enter){}
キーボード押下イベント
pictureBox1.Invalidate();
画像貼り付け
{return System.Windows.Forms.Cursor.Position.Y; ;}
マウスのY座標取得
*int mouseY = GetMousePoint();
マウスの座標取得
IServiceProvider serviceProvider = services.BuildServiceProvider();
サービスプロバイダーを構築
ILogger<Program> logger = serviceProvider.GetRequiredService<ILogger<Program>>();
Loggerを取得
var telemetryClient = serviceProvider.GetRequiredService<TelemetryClient>();
テレメトリクライアントを取得
string example = "文字列";
string型では、文字列を格納できる。
int example = 64;
int型変数には、大体-21憶から21億までの整数が格納される。
float example = 3.2f;
小数を格納することができる。
int arrays [] = new int [] {1,2,3};
配列の宣言
Debug.Log(arrays.length);
配列の長さ(大きさ)をコンソールに表示する。
Debug.Log(arrays[0]);
配列の番号を指定してコンソールに表示する。
arrays[0] = 900;
配列の番号を指定して、内容を書き換える。
Debug.Log(arrays[0]);
配列の内容の表示
List <int> lists = new List <int> {1,2,3};
List型の宣言
lists.Count
listsの中の個数のカウントする
lists.add(800);
List型listsに「800」のデータを追加する
Debug.Log(lists[3]);
Listの内容の表示
enum GAMEMODE{Easy,Normal,Difficult}
enum型は、値の種類を先に宣言しておくことができる
const int example = 10;
constを付けると、その値は変更できなくなる。
var position = new Vector3(0, 1, 2);
varは型推論といって、勝手に型を補ってくれる。
transform.position = position;
座標をpositionに移動させる。
Debug.Log(new Vector3(0, 1, 2) + new Vector3(2, 3, 4));
Vector3同士の演算も可能
if (p.X >= shape.Bounds.Left && p.X <= shape.Bounds.Right && p.Y >= shape.Bounds.Top - 2 && p.Y <= shape.Bounds.Top + 2)
上辺との当たり判定
if (p.X >= shape.Bounds.Left && p.X <= shape.Bounds.Right&& p.Y >= shape.Bounds.Bottom - 2 && p.Y <= shape.Bounds.Bottom + 2)
下辺との当たり判定
if (p.Y >= shape.Bounds.Top && p.Y <= shape.Bounds.Bottom && p.X >= shape.Bounds.Left - 2 && p.X <= shape.Bounds.Left + 2)
左辺との当たり判定
if (p.Y >= shape.Bounds.Top && p.Y <= shape.Bounds.Bottom*&& p.X >= shape.Bounds.Right - 2 && p.X <= shape.Bounds.Right + 2)
右辺との当たり判定
if (shape.Bounds.Left <= p.X && p.X <= shape.Bounds.Right && shape.Bounds.Top <= p.Y && p.Y <= shape.Bounds.Bottom)
図形内部の当たり判定
var p = e.GetPosition(skElement);
マウスポインタの座標を取得
string yyyyMMdd = DateTime.Now.ToString("yyyyMMdd");
今日の日付文字列を取得
Media jsonMedia = new Media();
JSONオブジェクトを生成
var jsonStr = JsonConvert.SerializeObject(jsonRoot);
JSONを文字列変換
byte[] jsonData = System.Text.Encoding.UTF8.GetBytes(jsonStr);
バイト配列に変換
Dispose(false);
アンマネージリソースを明示的に解放
Dispose(true);
マネージリソースを明示的に解放
GC.SuppressFinalize(this);
ファイナライザを抑止
ISomeInterface<SubClass> sub = new SomeClass<BaseClass>();
SubClass型の型引数をもつのインターフェイスに、BaseClass型の型引数を持つ実体クラスを代入
string iconName = selectedItem.Tag?.ToString();
Tag取得
sender.Header = iconName;
ヘッダー設定
ContentFrame.Navigate(_pages[icon]);
対応するページ表示
ContentFrame.Navigate(_pages[NaviIcon.None]);
空ページ表示
if (Input.GetMouseButtonDown(0)){
マウス押した瞬間
if (Input.GetMouseButton(0)){
マウス押し続けている間
if (Input.GetMouseButtonUp(0)){
マウス離した瞬間
TrailRenderer paintObjectTrailRenderer = _tmpPaintObj.GetComponent<TrailRenderer>();
TrailRendererの頂点情報からメッシュを生成する
GameObject colliderContainer = new GameObject("Collider Container");
空のゲームオブジェクトを作成する
dynamic viewCount = py.ViewCount();
クラスを取得
Debug.Log(viewCount.count());
関数が返す文字列をコンソールに表示
FileVersionInfo ver = FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location);
バージョン情報取得＆表示
var tween = Undo.AddComponent<Tween>(targetTransform.gameObject);*tween.hideFlags = HideFlags.HideInInspector;
var rate = currentTime / _duration;
経過時間割合算出
offset = transform.position - target.transform.position;}
offsetに相対的な距離を代入
headers.Add("Authorization", authorization);
リクエストヘッダに署名を追加
HttpHelpers.InvokeHttpRequest(uri, "GET", headers, null);
リクエスト実行
{var request = youtubeService.CommentThreads.List("snippet");request.VideoId = videoId;request.Order = CommentThreadsResource.ListRequest.OrderEnum.Relevance;request.TextFormat = CommentThreadsResource.ListRequest.TextFormatEnum.PlainText;request.MaxResults = 100;request.PageToken = nextPageToken;var response = await request.ExecuteAsync();foreach (var item in response.Items){try{CommentInfo info = new CommentInfo();info.ParentNo = no;info.ChildNo = 0;info.Text = item.Snippet.TopLevelComment.Snippet.TextDisplay;info.LikeCount = (long)item.Snippet.TopLevelComment.Snippet.LikeCount;info.AuthorName = item.Snippet.TopLevelComment.Snippet.AuthorDisplayName;info.PublishedAt = JsonDateToDate(item.Snippet.TopLevelComment.Snippet.PublishedAt);info.ReplyCount = (long)item.Snippet.TotalReplyCount;string parentId = item.Snippet.TopLevelComment.Id;commentList.Add(info);if (item.Snippet.TotalReplyCount > 0)await GetReplyComment(commentList, youtubeService, parentId, no, 1, null);no++;}catch { }}if (response.NextPageToken != null)await GetComment(commentList, videoId, youtubeService, no, response.NextPageToken);}
コメント取得
{var request = youtubeService.Comments.List("snippet");request.TextFormat = CommentsResource.ListRequest.TextFormatEnum.PlainText;request.MaxResults = 50;request.ParentId = parentId;request.PageToken = nextPageToken;var response = await request.ExecuteAsync();foreach (var item in response.Items){try{CommentInfo info = new CommentInfo();info.ParentNo = no;info.ChildNo = cno;info.Text = item.Snippet.TextDisplay;info.LikeCount = (long)item.Snippet.LikeCount;info.AuthorName = item.Snippet.AuthorDisplayName;info.PublishedAt = JsonDateToDate(item.Snippet.PublishedAt);commentList.Add(info);cno++;}catch { }}if (response.NextPageToken != null)await GetReplyComment(commentList, youtubeService, parentId, no, cno, response.NextPageToken);}
返信コメント取得
{DateTime result;DateTime.TryParse(dt, out result);return result;}
JSON日付変換
if(tmpValue != n)
前回と値が変わっていたら
.Where(n => n > 100)
100より大きいものに絞り込む
if (new Uri(NavigationManager.Uri).AbsolutePath.Contains("_")){
URLの中に_があった場合
NavigationManager.NavigateTo(WebUtility.HtmlDecode(NavigationManager.Uri.Replace("_", "")));
_を外してHTMLデコードして投げる
Thread.Sleep(3000);
3秒待つ
if (v == Keys.J){
Jキーの入力の場合
await downloadInfo.Content.CopyToAsync(es);
Blobストレージから取得したファイルをコピー
if (!typeof(T).IsEnum)
TがEnumかどうかチェック
if (!Enum.IsDefined(typeof(T), value)) return null;
TryParseする前に、定義されている値かチェックする
animator.SetTrigger("Death");
Deathというアニメーションに移行
public override void Write()
overrideを使って定義し直す
SceneManager.LoadSceneAsync("ScreenBreak");
シーンを遷移する
public PrintService(ILabelPrinter printer)
ILabelPrinterを実装したクラスを受け取れるようにコンストラクタを追加
File.WriteAllText(@"write.json", j);
file書き込み
string j = sr.ReadToEnd();
ファイルの内容をすべて読み込みます。
TargetJson s = Newtonsoft.Json.JsonConvert.DeserializeObject<TargetJson>(j);
string型の文字列をもとにTargetJson型のオブジェクトにデシリアライズ
Console.WriteLine(s.ObS.Name);
オブジェクトのプロパティにアクセス
if (_auth.CurrentUser.UserId == null)
すでにユーザーが作られているのか確認
_auth.CurrentUser.LinkWithCredentialAsync(credential).ContinueWith(task => {if (task.IsCanceled){Debug.LogError("LinkWithCredentialAsync was canceled.");callback(false);return;}if (task.IsFaulted){Debug.LogError("LinkWithCredentialAsync encountered an error: " + task.Exception);callback(false);return;}_user = task.Result;Debug.Log($"Credentials successfully linked to Firebase user: {_user.DisplayName} ({_user.UserId})");callback(true);});
認証方法追加
this.styleSheets.Add(Resources.Load<StyleSheet>("GraphViewBackGround"));
ussファイルを読み込んでスタイルに追加
this.Insert(0, new GridBackground());
背景を一番後ろに追加
var worldMousePosition = _window.rootVisualElement.ChangeCoordinatesTo(_window.rootVisualElement.parent, context.screenMousePosition - _window.position.position);
ノードの生成位置をマウスの座標にする
JObject jObject = ReadJsonFile(Path.Combine(startupPath, "test.json"));
json読み込み
string tableName = jObject["category"].ToString();
category要素をテーブル名とする
executer.DynamicInsert(jObject, tableName);
Insertするデータと、テーブル名を指定する
XmlDocument doc = new XmlDocument();
XMLを読込んで、Jsonに変換
public record Person(string FirstName, string LastName);
Person定義
var module = await JSRuntime.InvokeAsync<IJSObjectReference>(
コンパニオン モジュールへデータを渡す
using (var writer = new SimpleCsvWriter<ProfileData>(directory, "test", list.ToArray())) {writer.Write();}
データ書き込み
Write();
書き込み
foreach (var profile in profiles) {Debug.Log(profile.Name + " = " + profile.Time);}
データ読み込み
var serializedObject = new SerializedObject(targetObject);
targetObjectをSirializedObjectに変換する
{_text = GUILayout.TextField(_text);if (scope.changed){Debug.Log(_text);}}
TextFieldが変更されたログが吐かれる
{var rect = GUILayoutUtility.GetLastRect();}
VerticalScopeのRectを取得する
EditorGUIUtility.FindTexture("PlayButton");
PlayButton用のテクスチャを取得する
GUI.backgroundColor = Color.red;
背景を赤色にする
GUI.SetNextControlName("Focus String");
コントロールする名前を設定する
GUI.FocusControl("Focus String");
指定した名前にフォーカスする
var focusString = GUI.GetNameOfFocusedControl()
フォーカスされている名前を取得する
System.Console.Writeline(hoge.A);
コンソールにAの値が出力される
System.Console.Writeline(hoge.B);
コンソールにBの値が出力される
await app.CreateDatabaseAsync();
DBへ接続する、存在しなければDBを作成する
await app.CreateContainerAsync();
コンテナへ接続する、存在しなければコンテナを作成する
this.container = await this.database.CreateContainerIfNotExistsAsync(containerName, "/partitionKey");
コンテナ名とパーティションキーを指定する。存在しなければ指定したコンテナ名とパーティションキーでコンテナが作成される
var sqlQueryText = "SELECT * FROM c ";
クエリ全件検索
QueryDefinition queryDefinition = new QueryDefinition(sqlQueryText);
クエリを実行する
item.Date = example(item);
データを整形する
var root = action.Tree.GetRoot(action.CancellationToken);
コード全体を取得する
string[] strArray = str.Split(',');
文字列型配列の宣言と初期化
int[] num_foreach = new int[strArray.Length];
整数型配列の宣言
int i = 0;
インデックス変数の宣言と初期化
foreach(string s in strArray) {*num_foreach[i] = int.Parse(s);
整数型配列の代入
foreach(int n in num_foreach) {*Console.WriteLine(n);
整数型配列の各要素の出力
int[] num_lambda = str.Split(',').Select(s => int.Parse(s)).ToArray();
文字列の分割からの整数型配列の宣言と初期化
foreach(int j in num_lambda) {*Console.WriteLine(j);
整数型配列の各要素の出力
string command = e.Command.Trim();
変数commandの前後の空白を取る
string[] com_arg =  Regex.Split(e.Command.Trim(),@"\s+");
コマンドと引数に分割
{IsSuccessful = true,IDToken = result.AccessToken};
トークンを取得
this.dgvList.Rows[0].Cells[0].Value
dgvListはDataGridViewコントロール
this.dgvList[0, 0].Value
セルの値を取得したり変更したりする
this.dgvList[0, 0].Style.ForeColor
セルの文字色を取得したり変更したりする
this.dgvList[0, 0].Style.BackColor
セルの背景色を取得したり変更したりする
this.dgvList[0, 0].ErrorText
セルのエラーアイコンとメッセージを取得したり変更したりする
this.dgvList[0, 0].Style.Font
セルのフォントを取得したり変更したりする
this.dgvList.Rows[0].DataBoundItem
行と紐付いているバインドオブジェクトを取得します。
this.sbList.Clear();
DataGridViewの行をすべてクリアする
this.dgvList.AutoGenerateColumns = false;
親リストにデータソースを追加したとき勝手に列が追加されないようにする
this.dgvListChild.AutoGenerateColumns = false;
子リストにデータソースを追加したとき勝手に列が追加されないようにする
this.dgvList.DataSource = this.sbList;
親リストのデータソースを設定する
this.dgvListChild.DataSource = rowBound.ChildList;
子リストのデータソースをセットする。
string path = AssetDatabase.GetAssetPath(DirectoryAsset);
DefaultAssetのパスを取得する
bool isDirectory = File.GetAttributes(path).HasFlag(FileAttributes.Directory);
取得したパスがディレクトリのパスの時だけ、パスを返す
{await DisplayAlert("Error", result.Exception.Message, "Close");});
エラーが起きてたら何か処理
Color color_before = mask.GetComponent<RawImage>().color;*color_before.a = 0.0f;
透明度を最大にする
mask.GetComponent<RawImage>().enabled = false;
非活性にし画面を操作できるようにする
{for (int i = 0; i < 100; i++){Color color = mask.GetComponent<RawImage>().color;color.a += 0.01f;mask.GetComponent<RawImage>().color = color;if (i == 99){yield break;}else{yield return null;}}}
フェードアウト処理
renderingShader_Material.SetPass(0);
レンダリングを開始
var points = ObservationPoint.LoadFromMpk("ShindoObsPoints.mpk.lz4", true);
出力ディレクトリにコピーした観測点情報を読み込む
var targetTime = DateTime.Now.AddMinutes(-1);
現時刻から1分前の時刻を取得する
var result = await webApi.ParseIntensityFromParameterAsync(points, targetTime);
もとにする観測点情報と取得したい時間を添えて震度を取得する
Console.WriteLine(point.ObservationPoint.Region + " " + point.ObservationPoint.Name + " " + point.AnalysisResult);
地域名 観測点名 震度 の形で出力する
WebApiUrlGenerator.Generate(WebApiUrlType.RealtimeImg, targetTime, RealtimeDataType.Pga, true);
地中PGA画像データへのURLを作成
WebApiUrlGenerator.Generate(WebApiUrlType.RealtimeImg, targetTime, RealtimeDataType.Response_1Hz);
地上1.0Hz応答速度画像データへのURLを作成
WebApiUrlGenerator.Generate(WebApiUrlType.PSWave, targetTime);
P/S波画像データへのURLを作成
WebApiUrlGenerator.Generate(WebApiUrlType.EewJson, targetTime);
緊急地震速報情報のURLを作成
MainWindow.mw.AddLog("OnActivated()実行しました");
ログ表示
App.Current.Windows[0].WindowState = WindowState.Normal;
最小化してたら通常の大きさに戻す
IntPtr hDC = g.GetHdc();
Graphicsのデバイスコンテキストを取得
NativeMethods.BitBlt(hDC, 0, 0, bmp.Width, bmp.Height, winDC, 0, 0, SRCCOPY);
Bitmapに画像をコピーする
tmr.Stop();
停止させる
g.CopyFromScreen(new Point(curScreen.Bounds.Left, curScreen.Bounds.Top), new Point(0, 0), bmp.Size);
画面全体をコピーする
{_backButton.transform.gameObject.SetActive(true);_multiPlayButton.transform.gameObject.SetActive(false);//接続を試みる_cancellationTokenSource = new CancellationTokenSource();CancellationToken token = _cancellationTokenSource.Token;TryConnectAsync(token).Forget();});
サーバーの検索＆接続開始
_cancellationTokenSource = new CancellationTokenSource();
接続を試みる
StopDiscovery();
サーバーから抜ける
_cancellationTokenSource.Cancel();
非同期処理止める
SendHostReadyData sendData = new SendHostReadyData() {IsHostReady = true};
各クライアントにフラグデータを送る
_isHostReady = receivedData.IsHostReady;
ローカルのフラグに反映
StartDiscovery();
サーバーの検索開始
while (!_networkManager.isNetworkActive)
サーバーに接続するまでループ
if (_discoveredServer.uri != null)
サーバー発見した場合
_networkManager.StartClient(_discoveredServer.uri);
クライアントとして接続開始
_connectionStateText.text =CONNECTION_STATUS_CLIENT_WAITING;
接続ステータスの文言変更
await UniTask.WaitUntil(() => _isHostReady, cancellationToken: token);
ホストの開始フラグを待つ
_connectionStateText.text = CONNECTION_STATUS_SUCCESS;
接続ステータスの文言変更
if (tryCount > CONNECT_TRY_COUNT)
任意の回数以上接続に試みて失敗した場合は自身がホストになる
_networkManager.StartHost();
サーバーのホストになる
_playButton.gameObject.SetActive(true);
プレイボタン表示
_networkManager.ServerChangeScene(_gameSceneName);
シーン遷移
SendHostReadyData sendData = new SendHostReadyData() {IsHostReady = true};
各クライアントにフラグデータを送る
NetworkClient.RegisterHandler<SendHostReadyData>(ReceivedReadyInfo);
データ受信の準備
if (_titleScene.Contains(SceneManager.GetActiveScene().name))
タイトルシーンの場合
SendPlayerCountData sendData = new SendPlayerCountData() {PlayerCount = NetworkServer.connections.Count};
接続中の人数表記を変える
if (_mainScene.Contains(SceneManager.GetActiveScene().name))
メインシーンの場合
GameObject player = Instantiate(playerPrefab);
プレイヤー生成
NetworkServer.AddPlayerForConnection(conn, player);
今立ち上げているサーバーにプレイヤーを追加登録
FacialData newFacialData = FacialData.GetFacialData(facialExpressionName);
表情名から対応したFacialDataを取得する
Vector2 force = new Vector2(0.5f, 10f);*rb.AddForce(force, ForceMode2D.Impulse);
加える力の大きさ
isBounce = false;
接触していない時は跳ねないように
GL.Enable(EnableCap.DepthTest);
Depthバッファの有効化
Rotate++;
回転角度を更新する。
GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
画面をクリアする。
Shader.IdentityMatrix();
図形を描画する。
var resizedImageFile = await imageFile.RequestImageFileAsync(format, 100, 100);*var buffer = new byte[resizedImageFile.Size];
100*100の画像にリサイズ
$"data:{format};base64,{Convert.ToBase64String(buffer)}";
ブラウザ上に表示するためにDataUrlに変換
private DummyPersonService _service = new DummyPersonService();
REST APIなどからデータを取得するクラス
this.transform.position += this.transform.forward * inputMove.Vertical *moveSpeed* Time.deltaTime;
左スティックでの縦移動
this.transform.position += this.transform.right * inputMove.Horizontal * moveSpeed*Time.deltaTime;
左スティックでの横移動
transform.Rotate(new Vector3(0,rotateSpeed*inputRotate.Horizontal,0));
右スティックでの回転
if (cell.HasFormula){
計算式があるかどうか判定します。
Object value = cell.FormulaValue;
結果の値を取得します。
cell.Clear(ExcelClearOptions.ClearContent);
セルのコンテンツを削除します。
cell.Value2 = value;
値をセルに追加します。
Workbook workbook = new Workbook();
Workbookを作成します。
int currentRow = 1;
currentRow、currentFormulaを初期化します。
sheet.SetColumnWidth(1, 32);
1、2列の幅をセットします。
sheet.Range[currentRow, 1].Value = "テストデータ：";
データを追加します。
currentRow += 2;
テキストを追加します。
currentFormula = "=1/2+3*4";
演算を行います。
workbook.SaveToFile("Excel数式.xlsx", FileFormat.Version2013);
workbookの保存
Workbook workbook = new Workbook();
Workbook作成します。
workbook.LoadFromFile("Excel数式.xlsx");
Excelをロードします。
Worksheet sheet = workbook.Worksheets[0];
シートを取得します。
foreach (var cell in sheet.Range["B1:B13"])*{
[B1：B13]のセルをループします。
if (cell.HasFormula){
数式があるかどうか判定します。
string certainCell = String.Format("Cell[{0},{1}]", cell.Row, cell.Column);
数式のあるセルを出力します。
DisplayWizard<ViewCreateWizard>("View Create Wizard");
作成ウィザードを表示する。
File.WriteAllText(path, builder.ToString());
文字列を指定のパスに書き出す。
PrefabUtility.SaveAsPrefabAsset(gameObject, prefabPath);
指定したゲームオブジェクトをプレハブ化する。
GameObject.DestroyImmediate(gameObject);
プレハブ化したゲームオブジェクトをHierarchyから破棄する。
var assembly = Assembly.Load("Assembly-CSharp");
Assembly-CSharpアセンブリからクラスを取得する。
string className = $"{creatingViewName}ViewController";
作成情報をEditorPrefsから読み込む。
EditorPrefs.DeleteKey("CreatingViewName");
作成が済んだので、EditorPrefsから削除する。
string className = $"{viewName}ViewController";
作成情報をEditorPrefsへ保存しておく。
public void Attack()
アクセス修飾子 戻り値の型 関数名(引数の型 引数名)
int intNum = 2;
int(整数)型の変数宣言
float floatNum = 1.234f;
float(単精度浮動小数点)型の変数宣言
double doubleNum = 1.234;
double(倍精度浮動小数点)型の変数宣言
bool boolVal = true;
bool(論理)型の変数宣言
char c = 'a';
char(文字)型の変数宣言
DateTime date;
DateTime(日付)型の変数宣言
String str = "hoge";
String(文字列)型の変数宣言
int[] array;
配列型の変数宣言
int num4 = 1 / 2;
小数点以下切り捨て
int num6 = 10 % 3;
余りの数の求め方
num6 += 1;
複合代入演算子
string[] array;
string型配列arrayの宣言
int array = new int[3];
配列の長さが3のint型配列arrayの宣言
array[0] = 5;
配列の0番目に値を代入
int array2 = new int[] { 0, 5, 10 };
int型配列arrayの宣言し初期化
{new[] {1, 2, 3},new[] {4, 5, 6, 7}};
ジャグ配列での初期化
{{1, 1, 1},{2, 2, 2},{3, 3, 3}};
四角配列での初期化
continue;
continueを書くとここでループ処理が中断され、変数の更新後ループ処理の頭から再度開始します
int[] array = { 0, 5, 10 };
arrayの中身は 0, 15, 20となる
foreach (int num in array){
foreach(変数宣言 in ループ処理したい配列)
*AssetDatabase.Refresh();
Asset作成後、反映させるために必要なメソッド
{{ "name"   ,"John"},{ "age"   ,"12"},{ "city"  ,"Tokyo"},};
個人データを表すpersonのDictionaryを作成
group.Add(1, person1);
groupに個人データpersonを追加する
var jsonstr = JsonSerializer.Serialize(group);
Dictionaryをシリアライズ
Console.WriteLine("{0}", jsonstr);
コンソールに出力
var currentSceneGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();
現在のHierarchyのRootにあるGameObjectの一覧
Document doc = new Document();
Document objectを作成します。
Section sec = doc.AddSection();
Section対象を追加します。
Paragraph p = sec.AddParagraph();
sectionに段落を追加します。
doc.SaveToFile("記号を追加.docx");
保存します。
doc.LoadFromFile("特殊記号.docx");
ファイルをロードします。
TextRange tr = doc.FindString("\u002A", true, true).GetAsOneRange();
FindStringメソッドでメールの記号を探します。
doc.SaveToFile("test.docx", FileFormat.Docx2013);
保存します。
key.SetValue(null, tbValue.Text);
書き込み実施
Console.WriteLine($"{responseContent}");
Responseの表示
JObject jsonObject = JObject.Parse(jsonString);
全体をJObject型で受け取る。
JObject emojis = (JObject)jsonObject["emoji"];
"emoji"のValueをJObject型で受け取る。
System.Diagnostics.Process.Start(e.Uri.AbsoluteUri);
URLを開く
if (IsAnyNullOrEmpties(input, regPattern)){
未入力がないかチェック
MatchCollection matches = reg.Matches(input);
マッチング実行
OutTxt.Text = sb.ToString();
結果を設定
if (ROptIgnoreCase.IsChecked == true){
大文字小文字の区別をしない
await
非同期処理
Bitmap bitmap = new Bitmap(Screen.PrimaryScreen.Bounds.Width,
Bitmapの作成
Graphics g = Graphics.FromImage(bitmap);
Graphicsの作成
g.CopyFromScreen(new Point(0, 0), new Point(0, 0), bmp.Size);
画面全体をコピーする
g.Dispose();
解放
var folder = Directory.GetCurrentDirectory();
取得したキャプチャ画像をファイルとして保存
{BitmapDecoder decoder = await BitmapDecoder.CreateAsync(stream);softwareBitmap = await decoder.GetSoftwareBitmapAsync();}
保存した画像をSoftwareBitmap形式で読み込み
File.Delete(folder + "\\" + imageName);
保存した画像ファイルの削除
return softwareBitmap;
SoftwareBitmap形式の画像を返す
Document document = new Document();
Document objectを作成します。
document.LoadFromFile("Input.docx");
Wordファイルをロードします。
document.Sections[0].Paragraphs.RemoveAt(0);
一つ目の段落を削除します。
Presentation ppt = new Presentation();
PPTを作成します。
ppt.DocumentProperty.Title = "パンダについて";
プロパティを設定します。
ppt.SaveToFile("プロパティ.pptx", FileFormat.Pptx2013);
保存します。
if(TimeoutIOUtils.DirectoryExists(dir)){
ディレクトリの有無確認
if(TimeoutIOUtils.FileExists(file)){
ファイルの有無確認
Player.player.playerHp--;
クラス名.変数名.変数で、Playerクラスの変数を取得できる
if (targetDirectory[targetDirectory.Length - 1] != Path.DirectorySeparatorChar)*targetDirectory = targetDirectory + Path.DirectorySeparatorChar;
保存先のディレクトリ名の末尾に"\"をつける
Presentation ppt = new Presentation();
PowerPointを作成します。
ppt.SlideSize.Type = SlideSizeType.Screen16x9;
スライドのサイズと方向を配置します。
string ImageFile ="picture.jpg";
スライドの背景画像を挿入します。
IAutoShape textboxShape = ppt.Slides[0].Shapes.AppendShape(ShapeType.Rectangle, new RectangleF(50, 70, 600, 100));
図形を初めのスライドに追加します。
textboxShape.TextFrame.Paragraphs.Clear();
図形での段落を削除します。
sheet.PageSetup.Order = OrderType.DownThenOver;
印刷の順を設定します。
PrintDialog dialog = new PrintDialog();
PrintDialogを設定します。
dialog.PrinterSettings.Duplex = Duplex.Simplex;
片面印刷します。
dialog.PrinterSettings.FromPage = 0;
印刷範囲を設定します。
dialog.PrinterSettings.Copies = 5;
部数を設定します。
dialog.PrinterSettings.PrinterName = "HP LasterJet P1007";
プリンターの名前を設定します。
workbook.PrintDialog = dialog;
印刷します。
var relativePosition = Display.RelativeMouseAt(position);
画面ごとのスクリーン座標に変換
var displayIndex = (int)relativePosition.z;
z座標にディスプレイ番号がセットされる
var camera = cameras[displayIndex];
該当する画面のカメラでワールド座標に変換
Cef.Initialize(settings, false, new BrowserProcessHandler());
CefSharpを初期化する
this.webViewContainer.Controls.Add(WebBrowser);
CefSharpのWebViewを作成する。
WebBrowser = new ChromiumWebBrowser("https:www.google.co.jp");
コントロールを追加する。
WebBrowser.BrowserSettings.Javascript = CefState.Enabled;
WebViewの各種オプションを設定する
WebBrowser.KeyboardHandler = new Handlers.KeyboardHandler();
CefSharpの各種ハンドラを設定する
WebBrowser.JavascriptObjectRepository.Register("Test", new SimpleBrowser.Util.Test(), true, null);
独自オブジェクトを公開する
SimpleBrowserFrame parent = SimpleBrowserFrame.getMainFrame(browser);
親のbrowserからフォームを取得する
SimpleBrowserFrame newWindows = new SimpleBrowserFrame(false);
WebView無しの空のコンテナフォームを作成する。
Rectangle rect = newWindows.ClientRectangle;
WebViewのコンテナの情報を設定する。
newWindows.Show();
フォームを表示する
SimpleBrowserFrame parent = SimpleBrowserFrame.getMainFrame(browser);
新しく作成されたbrowserからコンテナのフォームを取得する
WebBrowser.LifeSpanHandler = new Handlers.LifeSpanHandler();
LifeSpanHandlerをWebViewに設定する
IntPtr hWnd = Browser.GetHost().GetWindowHandle();
WebViewのウィンドウハンドルを取得する
SetWindowPos(hWnd, HWND_TOP, 0, 0, webViewContainer.Width, webViewContainer.Height, SetWindowPosFlags.SWP_NOMOVE | SetWindowPosFlags.SWP_NOZORDER);
WebViewのサイズを変更する。
if(notesTime =< 0)
判定位置に来たら
var slideList = new List<(string, string)>();
ノートと画像保存場所のリスト
var ppt = app.Presentations.Open(SLIDE_PATH, MsoTriState.msoTrue, MsoTriState.msoFalse,
スライドを開く
if (ppt.Slides[i].SlideShowTransition.Hidden == MsoTriState.msoTrue) continue;
非表示スライドは無視
var file = FILE_PATH + $"/slide{i:0000}.jpg";
JPEGとして保存
WebView.Size = this.Size;
WebView2のサイズをフォームのサイズに合わせる
WebView.NavigationCompleted += WebView_NavigationCompleted;
WebView2のロード完了時のイベント
WebView.CoreWebView2.AddHostObjectToScript("class", CsClass);
JavaScriptからC#のメソッドが実行できる様に仕込む
string strBearerTokenCredentials = apiKey + ":" + apiSecretKey;
API keyとAPI secret keyをコロンでつなぐ
Transform objTransform= hogeObject.transform;
オブジェクトのtransform情報を取得
Vector3 pos = objTransform.position;
その中からposition情報を取得
pos.y += 0.001f;
上方向成分を加算
objTransform.position = pos;
座標を変更
{StreamReader sr = new StreamReader(filePath, Encoding.GetEncoding(encodingName));string allLine = sr.ReadToEnd();sr.Close();return allLine;}
ファイル読み込み
paragraph.ChildObjects.Insert(i + 1, footnote);
脚注を挿入します。
TextRange text = footnote.TextBody.AddParagraph().AppendText("夏時間。カナダ、オーストラリアでも用いる）とは1年のうち夏を中心とする時期に太陽が出ている時間帯を有効に利用する目的で、標準時を1時間進める制度またはその進められた時刻のこと。ただし、オーストラリアのロード・ハウ島では夏時間と通常の時間の差が30分であるなど一律ではない。");
脚注の内容を追加し、文字のフォントなどを設定します。
Paragraph paragraph2 = document.Sections[0].Paragraphs[2];
三つ目の段落を取得します。
Footnote endnote = paragraph2.AppendFootnote(FootnoteType.Endnote);
文末脚注を挿入し、スタイルを設定します。
document.SaveToFile("脚注.docx", FileFormat.Docx2010);
保存します。
List<GameObject> gameObjects = GameObject.FindGameObjectsWithTag("Player").ToList();
PlayerタグをつけたGameObjectを配列で取得しリストへ変換
gameObjects.ForEach(gameObj => print(gameObj.transform.name));*}
取得したGameObjectの名前をコンソールに出力
private readonly Subject<Unit> someSubject = new Subject<Unit>();
Subjectを生成。
var bitcoinPrivateKey = new BitcoinSecret("cPoEcLELGdXjHK5HB4tFxWf11UabeBJX4muBZSTZoavL8ZbDpBGa");
自アドレスの秘密鍵(WIF形式)からBitcoinSecretを取得する
var client = new QBitNinjaClient(network);
送金するためのトランザクションの左側(TxIn)をつくる
var destinationAddress = BitcoinAddress.Create("mhk39wXeb1ZsDegtPb6xnrUquctp6Rusko", network);
送金するためのトランザクションの右側(TxOut)をつくる
var message = "From Qiita, Japan, @ysskjck.";
メッセージ編集
transaction.Inputs[0].ScriptSig = bitcoinPrivateKey.ScriptPubKey;
これから送金するためのトランザクションに署名する
var broadcastResponse = client.Broadcast(transaction).Result;
送金確定
string tmpFile = @"..\勤務表(XXXX)_yyyyMMdd.xlsm";
Excelへの書き込み
File.Copy(tmpFile, outFile);
テンプレートから新規Excelを作成
IWebDriver driver = new ChromeDriver(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location));
Webドライバーのインスタンス化
driver.Navigate().GoToUrl(loginPage);
ログインページへアクセス
driver.FindElement(By.Name("{ログインボタンの要素id}")).Click();
ログインボタンのクリック
driver.Navigate().GoToUrl(targetPage);
勤務時間取得用のページへ遷移し、HTML取得
var appType = Type.GetTypeFromProgID("Excel.Application");
ProgIDからOfficeアプリのCOMのTypeを取得する。
app = Activator.CreateInstance(appType);
COMオブジェクトを作成し、対象アプリのプロセス名を検索する。
app.Quit();
アプリ停止＆解放
GC.Collect();
GCを強制
var appType = Type.GetTypeFromProgID("Excel.Application");
ProgIDからOfficeアプリのCOMのTypeを取得する。
using (var reader = new StreamReader("user.csv"))
StreamReaderにCSVのパスを渡す
privateObject.SetFieldOrProperty("_privateMember", 100);
メンバ変数値変更
var ret = privateObject.Invoke("PrivateMethod", 100, 200);
"PrivateMethod"呼び出し
戻り値の型でくるんでawait
*privateType.SetStaticFieldOrProperty("_privateStaticMember", "ヨシッ！");
static変数"_privateStaticMember"の値を変更
*var ret = privateType.InvokeStatic("GetPrivateStaticMember");
staticメソッド"GetPrivateStaticMember"を呼び出す
*string[][] arr = { new string[3] { "あ", "い", "う" },
ジャグ配列の初期化
Array.Resize(ref arr, 10);
要素数を10に変更する
var sb = FindResource("MyRoundingAnimation") as Storyboard;
StoryBoardを検索
Screen ownerScreen = Screen.FromControl(this);
所属している画面を取得
if ( preferedSize.Width <= rect.Width && preferedSize.Width <= rect.Height ) {ClientSize = preferedSize;}
画面に収まるときだけリサイズする
capture = new VideoCapture(0);
カメラ画像取得用のVideoCapture作成
Mat matframe = new Mat(HEIGHT, WIDTH, MatType.CV_8UC3);
Mat作成
bmp = new Bitmap(matframe.Cols, matframe.Rows, (int)matframe.Step(), System.Drawing.Imaging.PixelFormat.Format24bppRgb, matframe.Data);
Bitmap作成
ImageEncodingParam encodingParam = new ImageEncodingParam(ImwriteFlags.PngBilevel, 0);
エンコード
mat = Cv2.ImDecode(buffer, ImreadModes.Color);
デコードして保存する
Cv2.ImWrite(path, mat);
画像の保存
if (vrmModel == null)
VRMモデルが読み込まれていなかったら
vrmModel = ImportVRM(VrmPath);
VRMモデル読み込み
var model = GameObject.Instantiate(vrmModel);
VRMモデルを複製
model.transform.SetParent(__instance.transform, false);alreadyVrmSetList.Add(__instance);
親を既存モデルにセット
foreach (var smr in __instance.GetComponentsInChildren<SkinnedMeshRenderer>())*{
既存モデルのVRMモデル以外のSkinnedMeshRendererを非表示
e.Cancel = true;
終了処理をキャンセル
PdfDocument document = new PdfDocument()
PDFオブジェクト作成
PdfDocument inputDocument = PdfReader.Open(file, PdfDocumentOpenMode.Import)
PdfDocumentOpenMode.Import：PDFを読み取りモードで開く。結合するPDFオブジェクトを作成
inputDocument.Close();
結合するPDFを閉じる
document.Save(selectedPath);
PDF保存
document.Close();
PDFを閉じる
Array.Copy(b.Data, 0, Data, Size, b.Size);
bの有効データを、thisの有効データの末尾(位置=Size)以降にコピーする
{sam.x = 100;}
値型の参照渡し
return input?.ToUpper();
引数で受け取った文字列を大文字にして返す
context.Logger.LogLine($"Arg : [{input}]");
受け取った引数をログに出力
for (int i = 0; i < 3; i++){
for (初期化式; ループ条件式; 更新式)
foreach (int even in arr)
foreach (一時変数宣言 in コレクション)
Invalidate();
コントロールの再描画要求
(array[j], array[j - 1]) = (array[j - 1], array[j]);
System.ValueTapleの機能による要素の交換
str += new string( Enumerable.Repeat( "■", n ).SelectMany( x => x ).ToArray() )
現在のソートの状態を数値の並び→横棒グラフ状の文字列に変換する。
Animator.DisplaySingleFrame( str );
アニメの一コマ分として画面に表示する
Dictionary TagValues = new Dictionary();
Dictionary オブジェクトを作成
Presentation presentation = new Presentation();
PowerPointファイルをロードします。
ReplaceTags(presentation.Slides[0], TagValues);
ReplaceTagsメソッドで文字を置換します。
headers.Add("Authorization", authorization);
リクエストヘッダに署名を追加
HttpHelpers.InvokeHttpRequest(uri, "GET", headers, null);
リクエスト実行
return x + y;
xとyの和を返す
ToEnemyVec = ToEnemyVec.normalized;
ベクトルの正規化
Loaded_Command.Subscribe(()=> System.Diagnostics.Debug.WriteLine("Loaded !!"));
ボタンが押された時の動作を定義する
spl2.SplitterDistance = 200;
分割線の位置を指定[pixel]
await UniTask.WaitForEndOfFrame(ct);
任意のフレームの描画処理が終わるまで待つ
var rt = new RenderTexture(_camera.pixelWidth, _camera.pixelHeight, 24);
Cameraの描画領域をRenderTextureとして取り出す
NativeGallery.SaveImageToGallery(screenShot, "GalleryTest", $"{date}.png" );
CameraのRenderTextureを元に画像を作成して保存
while ( !www.isDone ) yield return new WaitForSeconds(0.25f);*audio.clip = www.GetAudioClip(false, false);
インポートが完了するまで待つ
System.IO.File.Delete(path);
ファイルを削除
Console.WriteLine(++a);
a = a + 1してからaを表示
var credentials = SdkContext.AzureCredentialsFactory
credential の作成
var azure = Microsoft.Azure.Management.Fluent.Azure
Azure オブジェクトの作成
var siteConfig = (await azure.WebApps.Inner.GetConfigurationWithHttpMessagesAsync(resourceGroupName, functionAppName)).Body;
WebApps の config を取得
var corsList = siteConfig.Cors.AllowedOrigins;
config から CORS の一覧を取得
var additionalDomain = "{登録するドメイン}";
COSR の一覧に登録するドメインを追加
var newSiteConfig = new SiteConfigResourceInner() { Cors = new CorsSettings() };
CORS の一覧を設定
await azure.WebApps.Inner.CreateOrUpdateConfigurationWithHttpMessagesAsync(resourceGroupName, functionAppName, newSiteConfig);
WebApps の config を更新
headers.Add("Authorization", authorization);
リクエストヘッダに署名を追加
HttpHelpers.InvokeHttpRequest(uri, "GET", headers, null);
リクエスト実行
string filePath  = @".\JUFx_KMJ\JUF1_KMJ.csv";
ファイルの読み込み
string[] cols = reader.ReadLine().Split(',');
読み込んだ文字列をカンマ区切りで配列に格納
*string[] cols = reader2.ReadLine().Split(',');
読み込んだ文字列をカンマ区切りで配列に格納
var codePoint = Convert.ToInt32(myTable2[buf[i].ToString("X2") + buf[i+1].ToString("X2")],16);
サロゲートペア計算（ライブラリが見つからなかった）
public int numAProperty
公開プロパティにする
[DllImport("hoge.dll")]
C++関数定義
if (time >= 0.5f)
timeが0.5秒経ったら
[DllImport("./foo.dll", EntryPoint = "foo")]
ネイティブ関数の宣言
var str = Enumerable.Repeat("w", count).Aggregate((a, b) => $"{a}{b}");
count 個 'w' を含む文字列の生成
var f = (delegate* unmanaged[Cdecl]<int, nint>)(delegate*<int, nint>)&Generate;
関数ポインタの作成
var str = Enumerable.Repeat("w", count).Aggregate((a, b) => $"{a}{b}");
count 個 'w' を含む文字列の生成
var f = (delegate*<int, string>)&Generate;
関数ポインタの作成
return this.Configuration.GetSection("Admins").Get<string[]>().Contains(oid?.Value);
appSettings.json の Admins にオブジェクト ID が含まれているか評価
{position_manager pm = new position_manager();pm.set_koma_select_position(this.gameObject.transform.parent.gameObject.transform.parent.gameObject , 4, 8);this.gameObject.transform.parent.gameObject.SetActive(false);Debug.LogError("You Click Area");}
親オブジェクトの駒を移動する
GameObject[] tags = GameObject.FindGameObjectsWithTag(tag);
タグのついたオブジェクトをすべて格納
{Image image = this.GetComponent<Image>();image.color = new Color(1.0f, 0.1401087f, 0.0f, 0.3f);}
imageの色を濃くする
Image image = this.GetComponent<Image>();
Imageの取得
{Image image = this.GetComponent<Image>();image.color = new Color(1.0f, 0.1401087f, 0.0f, 0.8f);}
imageの色を薄くする
{position_manager pm = new position_manager();pm.set_koma_select_position(this.gameObject.transform.parent.gameObject.transform.parent.gameObject , 4, 8);this.gameObject.transform.parent.gameObject.SetActive(false);Debug.LogError("You Click Area");}
親オブジェクトの駒を移動する
var id = Shader.PropertyToID("_OutlineTex");
テクスチャ作成
commandBuffer.ClearRenderTarget(false, true, Color.clear);
メッシュの描画
commandBuffer.Blit(id, BuiltinRenderTextureType.CameraTarget, outlineMaterial);
アウトラインを抽出して合成
line.Draw(settings);
線の描画
private void InitMaterial() {if (!lineMaterial) {lineMaterial = new Material(Shader.Find("Hidden/Internal-Colored"));lineMaterial.hideFlags = HideFlags.HideAndDontSave;lineMaterial.SetInt(SrcBlend, (int) BlendMode.SrcAlpha);lineMaterial.SetInt(DstBlend, (int) BlendMode.OneMinusSrcAlpha);lineMaterial.SetInt(Cull, (int) CullMode.Off);lineMaterial.SetInt(ZWrite, 0);}}
描画するために使うマテリアルの初期化
if (!enabled || settings.paths.Length <= 0 || settings.paths.Any(t => t == null)) return;
座標が入っていなかったら描画しない
if (_settings.Equals(settings) && _paths.SequenceEqual(vecPaths)) {*DotVertexes(currentPaths.ToArray());
設定が変更されていなかったら計算しない
for (int index = 0; index < _paths.Count - 1; index++) {v0 = _paths[index];v1 = _paths[index + 1];
解像度に対する幅を求める
o = (new Vector3(v1.y, v0.x, 0.0f) - new Vector3(v0.y, v1.x, 0.0f)).normalized;
２点の単位ベクトルを求める
void DrawLine2D(Vector3 v0, Vector3 v1, Vector3 o) {Vector3 n = o * relativeWidth;Vector3[] vertex = new[] {new Vector3(v0.x - n.x, v0.y - n.y, 0.0f),new Vector3(v0.x + n.x, v0.y + n.y, 0.0f),new Vector3(v1.x + n.x, v1.y + n.y, 0.0f),new Vector3(v1.x - n.x, v1.y - n.y, 0.0f),};DotVertexes(vertex);foreach (Vector3 v in vertex) {currentPaths.Add(v);}}
２点に線を引く関数
void DrawMark2D(Vector3 v0, Vector3 v1, Vector3 o) {Vector3 markLength, _v0, _v1, _o;Vector3 _unitVec = (v1 - v0) / settings.intervalCount;List<Vector3> _pos = new List<Vector3>();for (int i = 0; i < settings.intervalCount + 1; i++) {_pos.Add(v0 + _unitVec * i);}for (int i = 0; i < _pos.Count; i++) {Vector3 vec = _pos[i];float length = (i == 0 || i == _pos.Count - 1 ? settings.edgeMarkLength : settings.insideMarkLength);markLength = o * length;_v0 = new Vector3(vec.x - markLength.x, vec.y - markLength.y, 0.0f);_v1 = new Vector3(vec.x + markLength.x, vec.y + markLength.y, 0.0f);_o = (new Vector3(_v1.y, _v0.x, 0.0f) - new Vector3(_v0.y, _v1.x, 0.0f)).normalized;DrawLine2D(_v0, _v1, _o);}}
2点にメモリをつける関数
void DotVertexes(Vector3[] pos) {foreach (Vector3 v in pos) {GL.Vertex3(v.x, v.y, v.z);}}
与えられた座標配列に頂点を打つ関数
void DrawLine2D(Vector3 v0, Vector3 v1, Vector3 o) {Vector3 n = o * relativeWidth;Vector3[] vertex = new[] {new Vector3(v0.x - n.x, v0.y - n.y, 0.0f),new Vector3(v0.x + n.x, v0.y + n.y, 0.0f),new Vector3(v1.x + n.x, v1.y + n.y, 0.0f),new Vector3(v1.x - n.x, v1.y - n.y, 0.0f),};DotVertexes(vertex);}
垂直なベクトルを求め、正規化する
Vector3 n = o * relativeWidth;
単位ベクトルに設定された幅をかける
Vector3[] vertex = new[] {new Vector3(v0.x - n.x, v0.y - n.y, 0.0f),new Vector3(v0.x + n.x, v0.y + n.y, 0.0f),new Vector3(v1.x + n.x, v1.y + n.y, 0.0f),new Vector3(v1.x - n.x, v1.y - n.y, 0.0f),};
オフセットを足して、頂点座標を求める
other.GetComponent<Move>().StartCor(targetPos);
StartCor()を使ってMoveクラスのMoveToを開始
HttpPostedFile file = HttpContext.Current.Request.Files["userfile"];
アップロードされたファイルを取得
container.CreateIfNotExists();
もしコンテナが存在しなかった場合は作成
CloudBlockBlob blob = container.GetBlockBlobReference($"{file.FileName}");
一意となるファイル名でblobに対しての参照を取得する
blob.UploadFromStream(fileStream);
ファイルをアップロードする
string filename = HttpContext.Current.Request["filename"];
ファイルをダウンロードする
{for (int i = 0; i < data.elems.Count; i++){Node[] nodes = new Node[2];nodes[0].No = data.elems[i].NodeNo1;nodes[0].Point = data.nodes[nodes[0].No - 1].Point;nodes[1].No = data.elems[i].NodeNo2;nodes[1].Point = data.nodes[nodes[1].No - 1].Point;int materialNo = data.elems[i].MaterialNo - 1;double area = data.materials[materialNo].Area;double young = data.materials[materialNo].Young;elems.Add(new BeamElement(nodes, area, young));}}
要素の形式を変換して格納する
{if (Rest == null){return null;}if (NodeNum <= 0 || BeamElems == null || Rest.Count != NodeNum){return null;}DenseMatrix kMatrix = DenseMatrix.Create(NodeNum, NodeNum, 0.0); for (int i = 0; i < BeamElems.Count; i++){Console.WriteLine("要素" + (i + 1).ToString());DenseMatrix keMatrix = BeamElems[i].makeKeMatrix();for (int r = 0; r < 2; r++){int rt = BeamElems[i].Nodes[r].No - 1;for (int c = 0; c < 2; c++){int ct = BeamElems[i].Nodes[c].No - 1;kMatrix[rt, ct] += keMatrix[r, c];}}}Console.WriteLine("Kマトリックス");Console.WriteLine(kMatrix); ForceVector = ForceVector - kMatrix * DispVector;for (int i = 0; i < Rest.Count; i++){if (Rest[i] == true){for (int j = 0; j < kMatrix.ColumnCount; j++){kMatrix[i, j] = 0.0;}for (int k = 0; k < kMatrix.RowCount; k++){kMatrix[k, i] = 0.0;}kMatrix[i, i] = 1.0;ForceVector[i] = DispVector[i];}}Console.WriteLine("Kマトリックス(境界条件考慮)");Console.WriteLine(kMatrix);Console.WriteLine("荷重ベクトル(境界条件考慮)");Console.WriteLine(ForceVector);return kMatrix;}
Kマトリックスを作成する
ForceVector = ForceVector - kMatrix * DispVector;
境界条件を考慮して修正する
DispVector = (DenseVector)(kMatrix.Inverse().Multiply(ForceVector));
変位を計算する
DenseVector dispElemVector = DenseVector.Create(2, 0.0);
各要素の応力を計算する
{if (Area <= 0){return null;}double length = Nodes[1].Point - Nodes[0].Point;double[,] bmatrixArray = new double[1, 2];bmatrixArray[0, 0] = -1.0 / length;bmatrixArray[0, 1] = 1.0 / length;return DenseMatrix.OfArray(bmatrixArray);}
Bマトリックスを計算する
{DenseMatrix BMatrix = makeBMatirx();Console.WriteLine("Bマトリックス");Console.WriteLine(BMatrix);if (BMatrix == null || Young <= 0){return null;}double Volume = Area * (Nodes[1].Point - Nodes[0].Point);var keMatrix = Young * Volume * BMatrix.Transpose() * BMatrix;DenseMatrix KeMatrix = DenseMatrix.OfColumnArrays(keMatrix.ToColumnArrays());Console.WriteLine("Keマトリックス");Console.WriteLine(KeMatrix);return KeMatrix;}
Keマトリックスを計算する
DenseMatrix BMatrix = makeBMatirx();
Bマトリックスを計算する
{DenseMatrix bMatrix = makeBMatirx();StrainVector = (DenseVector)bMatrix.Multiply(dispvector);Console.WriteLine("ひずみベクトル");Console.WriteLine(StrainVector);}
ひずみベクトルを計算する
{if (StrainVector == null || Young <= 0){return;}StressVector = Young * StrainVector;Console.WriteLine("応力ベクトル");Console.WriteLine(StressVector);}
応力ベクトルを計算する
player = ConvertExtension.ChangeType<Player>(data[nameof(player)])
nullableなMapデータをPlayerに変換する
public ChildArray[] array;
配列を作成
var tasks = new List<Task>();
Taskリストの初期化
await Task.WhenAll(tasks);
リスト中の全てのタスクの完了を待つ
app.UseAuthentication();
認証ミドルウェアの追加
Mat Lsrc = new Mat(sLeftPictureFile, ImreadModes.Color);
画像をグレースケールとして読み込む
Mat Rsrc = new Mat(sRightPictureFile, ImreadModes.Color);
画像をグレースケールとして読み込む
akaze.DetectAndCompute(Lsrc, null, out keyPointsLeft, descriptorLeft);
特徴量の検出と特徴量ベクトルの計算
Cv2.Absdiff(LmatPlanes[0], RmatPlanes[0], diff0);*Cv2.Absdiff(LmatPlanes[1], RmatPlanes[1], diff1);
分割したチャンネルごとに差分を出す
Cv2.MedianBlur(diff0, diff0, 5);*Cv2.MedianBlur(diff1, diff1, 5);
ブラーでノイズ除去
MessageBox.Show("入力したものは…" + sb.ToString() + " です。");
メッセージを表示する
{new weapon_status{Name = "どうの剣",Attribute = "なし",Status = 10},new weapon_status{Name = "はがねの剣",Attribute = "なし",Status = 50},new weapon_status{Name = "炎の剣",Attribute = "火",Status = 100},new weapon_status{Name = "ドラゴンの剣",Attribute = "竜",Status = 150},};
武器のリストを作成
var Strong_Weapons = weapons.Where(x => x.Status >= 100);
攻撃力が100以上のものを、強武器としてStrong_Weaponsに格納
static void makeDB(){using(var db=new SqliteConnection("Data Source=../sqlitest.db")){db.Open();var sql=db.CreateCommand();sql.CommandText=@"CREATE TABLE IF NOT EXISTS DMCARDS (ID INTEGER PRIMARY KEY AUTOINCREMENT,NAME TEXT,COLOR TEXT,COST INTEGER,POWER INTEGER)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('ラ・ウラ・ギガ','光',1,2000)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('アクア・ガード','水',1,2000)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('ボーン・スライム','闇',1,1000)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('ブレイズ・クロー','火',1,1000)";sql.ExecuteNonQuery();sql.CommandText="INSERT INTO DMCARDS (NAME,COLOR,COST,POWER) VALUES ('スナイプ・モスキート','自然',1,2000)";sql.ExecuteNonQuery();}}
データベース(テーブル)を初期化
static void updateDB(){using(var db=new SqliteConnection("Data Source=../sqlitest.db")){db.Open();var sql=db.CreateCommand();sql.CommandText="UPDATE DMCARDS SET COLOR='白' WHERE COLOR='光'";sql.ExecuteNonQuery();sql.CommandText="UPDATE DMCARDS SET COLOR='青' WHERE COLOR='水'";sql.ExecuteNonQuery();sql.CommandText="UPDATE DMCARDS SET COLOR='黒' WHERE COLOR='闇'";sql.ExecuteNonQuery();sql.CommandText="UPDATE DMCARDS SET COLOR='赤' WHERE COLOR='赤'";sql.ExecuteNonQuery();sql.CommandText="UPDATE DMCARDS SET COLOR='緑' WHERE COLOR='自然'";sql.ExecuteNonQuery();}}
データベースを変更
static void dropDB(){using(var db=new SqliteConnection("Data Source=../sqlitest.db")){db.Open();var sql=db.CreateCommand();sql.CommandText="DROP TABLE IF EXISTS DMCARDS";sql.ExecuteNonQuery();}}
データベースを削除
static void viewDB(){using(var db=new SqliteConnection("Data Source=../sqlitest.db")){db.Open();var sql=db.CreateCommand();sql.CommandText="SELECT * FROM DMCARDS";using(var row=sql.ExecuteReader()){Console.WriteLine("ID,NAME,COLOR,COST,POWER");while(row.Read()){Console.WriteLine($"{row["ID"]},{row["NAME"]},{row["COLOR"]},{row["COST"]},{row["POWER"]}");}}}}
データベースを表示
{private int value1private int value2public void method1(int a, int b){this.value1 = a;this.value2 = b;}}
クラスの定義
public delegate void MyDelegate(string s);
デリゲート(関数を参照する変数の型)
クラスのインスタンス作成
MyDelegate dgref1 = new MyDelegate(Console.WriteLine);
デリゲートのインスタンス(関数そのものを参照するインスタンス)の作成
delegate double Culc2(int a, int b);
2値を計算するメソッドデリゲート型の定義
Culc2 culc2Test = new Culc2(plus);
2値計算メソッドデリゲート変数「culc2Test」を定義する。
double testnum = culc2Test(24, 33);
デリゲート変数に格納されたメソッドを呼び出す
{return (double)a + (double)b;}
足し算
{return (double)a - (double)b;}
引き算
{return (double)a * (double)b;}
掛け算
{if (b == 0){return -9999999999999999999.9;}else{return (double)a / (double)b;}}
割り算
{int result = 1;for (int i = 0; i < b; i++){result *= a;}return (double)result;}
aのb乗
delegate double Culc2(int a, int b);
2値を計算するメソッドデリゲート型の定義
*Culc2[] culc2tests = new Culc2[5];
2値計算メソッドデリゲート配列「culc2tests」を定義する。
{return (double)a + (double)b;}
足し算
{return (double)a - (double)b;}
引き算
{return (double)a * (double)b;}
掛け算
{if (b == 0){return -9999999999999999999.9;}else{return (double)a / (double)b;}}
割り算
{int result = 1;for (int i = 0; i < b; i++){result *= a;}return (double)result;}
aのb乗
delegate double Culc2(int a, int b);
2値を計算するメソッドデリゲート型の定義
Culc2[] culc2tests = new Culc2[6];
2値計算メソッドデリゲート配列「culc2tests」を定義する。
{int result = 1;for (int i = 0; i < b; i++){result *= a;}return (double)result;}
aのb乗
string data = selectResult.GetString(1);
カラムインデックスでのアクセス
System.Net.ServicePointManager.SecurityProtocol = System.Net.SecurityProtocolType.Tls11 | System.Net.SecurityProtocolType.Tls12;
SSL通信の許可設定
StorageSharedKeyCredential credential = new StorageSharedKeyCredential(accountName, accessKey);
Azureへ接続準備：接続情報の設定
ShareClient share = new ShareClient(serverurl ,  credential);
Azureへ接続
directory.CreateIfNotExists();
Upload先(azure側)にフォルダがなければ作成。
ShareFileClient file = directory.GetFileClient(azureFileName);
Upload先(azure側)にファイルインスタンスを作成。
file.DeleteIfExists();
同名のファイルがあったら削除
FileStream stream = File.OpenRead( Path.Combine(localDirectoryPath , localFileName ) );
Upload対象のLocalファイルを開く。
file.Create(stream.Length);
Upload先(azure側)にファイルインスタンスにバイナリ情報を注入
stream.Dispose();
ローカルファイルの開放
public static int BinarySearchInOdds(double[] odds, double r) {if (r < 0) return -1;if (odds.Length == 0) return -1;double[] sum_from_left = new double[odds.Length];double[] sum_from_right = new double[odds.Length];double odd_total = odds.Sum();sum_from_left[0] = 0;sum_from_right[0] = odd_total;for (int i = 1; i < odds.Length; i++) {sum_from_left[i] = sum_from_left[i-1] + odds[i-1];sum_from_right[i] = sum_from_right[i-1] - odds[i-1];}int left = 0;int right = odds.Length - 1;int mid = left + (right - left) / 2;double L_mid = sum_from_left[mid];while (right >= left) {double R_mid = L_mid + odds[mid];if ((L_mid <= r && r < R_mid) || (r == R_mid && mid == odds.Length - 1)) {// キーがmid番目の要素の範囲内にある場合return mid;} else if (r < L_mid) {// キーがmid番目の要素の範囲より小さい範囲にある場合right = mid - 1;mid = left + (right - left) / 2;R_mid = L_mid - (odd_total - sum_from_left[mid + 1] - sum_from_right[right + 1]);L_mid = R_mid - odds[mid];} else {// キーがmid番目の要素の範囲より大きい範囲にある場合left = mid + 1;mid = left + (right - left) / 2;if (mid >= odds.Length) break;L_mid = R_mid + (odd_total - sum_from_left[left] - sum_from_right[mid]);R_mid = L_mid + odds[mid];}}return -1;}
確率分布の中で、 rに対応する要素のインデックスを返す
double[] sum_from_left = new double[odds.Length];
確率分布の部分和をあらかじめ求めておく
public static int Draw(double[] odds) {Random rnd = new Random();double r = rnd.NextDouble() * odds.Sum();return BinarySearchInOdds(odds, r);}
確率分布にしたがって、ランダムに決定した要素のインデックスを返す
string path = @"C:\Users\hogehoge\Desktop\";
ファイルの置き場所を記載
string sourceWord = sourceCode[i].Trim();
前後の空白と2つ以上続く空白を全て削除し、1つの空白しか残らないようにする
if (CheckData(sourceWord, "TabIndex ="))
TabIndexの取得
if (CheckData(sourceWord, "Index ="))
Indexの取得
if (CheckData(sourceWord, "Tag ="))
Tagの取得
if (CheckData(sourceWord, "Top ="))
Topの取得
if (list1 == null || list2 == null)
list1とlist2がNULLの場合
var channelAccessToken = System.Environment.GetEnvironmentVariable("CHANNEL_ACCESS_TOKEN");
チャンネルアクセストークンを変数へ格納
{messages = new List<Message>(){new Message(){type="text",text=mm + "月"+ dd　+"日の"+ HH + "時になりました。本日のタスクは完了していますか？"}}};
リプライメッセージ作成
string json = JsonConvert.SerializeObject(rm, Formatting.Indented);
リプライメッセージをシリアライズ
var req = new HttpRequestMessage(HttpMethod.Post, apiUrl);
Line Messaging APIへのリクエストを作成する
req.Headers.Add(@"Authorization", @"Bearer {" + channelAccessToken + "}");
ヘッダーにチャンネルアクセストークンを追加する
req.Content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");
リクエストをJSON形式にシリアライズする
{var response = await client.SendAsync(req);log.LogInformation($"{response}");}
リクエストを送信する
if (num % 2 == 0) return false;
偶数はあらかじめ除く
{return num % 2 == 0;}
偶数ならTrueを返すメソッド
Console.WriteLine(N);
標準出力へ書き出し
DumbAssertConfig.Encoding = Encoding.GetEncoding("UTF-8");
エンコーディングを指定
DumbAssertConfig.DateTimePattern = "yyyy-MM-dd HH:mm:ss.fff";
DateTimeの文字列表現パターンを指定
DumbAssertConfig.NewLine = Environment.NewLine;
改行コード
{var res = await _http.GetStringAsync("/api/GetToken");_getTokenResponse = JsonSerializer.Deserialize<GetTokenResponse>(res);_chatClient = new ChatClient(new Uri(_communicationServiceSettings.Endpoint),new CommunicationUserCredential(_getTokenResponse.Token));_chatThreadClient =  _chatClient.GetChatThreadClient(_getTokenResponse.ThreadId);}
チャットに参加
{await _chatThreadClient.SendMessageAsync(message, senderDisplayName: name);}
チャットにメッセージを送信
public IAsyncEnumerable<ChatMessage> GetMessagesAsync() => _chatThreadClient.GetMessagesAsync();
チャットのメッセージを取得
lock (client.SyncRoot)
スレッド処理のためロックする
if (Directory.Exists(save_path + folder.Name) == false)
フォルダ存在確認
Directory.CreateDirectory(save_path + folder.Name);
フォルダを作る
m.WriteTo(save_path + folder.Name + "\\" + uid.ToString() + "：" + m.Subject + ".eml");
ファイルへ書き出し
folder.Open(FolderAccess.ReadOnly);
IMAPフォルダを開く
DateTime next = Enumerable.Range(1, 100).Select(x => date.AddDays(x)).First(
100日後までの間で最も近い営業日を取得
SetDrawScreen(DX.DX_SCREEN_BACK);
描画先を裏画面に設定
DX.ClearDrawScreen();
画面をクリア
Vector3 center = (sunrise.position + sunset.position) * 0.5f;
弧の中心
Vector3 riseRelCenter = sunrise.position - center;
中心を基準として円弧を補間する
Client.Send(RequestData, RequestData.Length, new IPEndPoint(IPAddress.Broadcast, 8888));
ポート8888にブロードキャスト送信
var ServerResponse = Encoding.ASCII.GetString(ServerResponseData);
送信データを受信した相手は、自分（クライアント）のエンドポイント情報を知ったはずなので、そこに対してパケットを送信してくれるのを待つ
_saveButton.OnPointerClickAsObservable()
セーブボタン
_loadButton.OnPointerClickAsObservable()
ロードボタン
Directory.CreateDirectory(directoryPath);
まだ存在してなかったら作成
GetFiles(directoryName, "*", SearchOption.AllDirectories)
Imageディレクトリ内の全ファイルを取得
.OrderBy(filePath => File.GetLastWriteTime(filePath).Date)
日付順に降順でソート
.ThenBy(filePath => File.GetLastWriteTime(filePath).TimeOfDay)
同じ日付内で時刻順に降順でソート
List<string> imageFilePaths = GetAllFileFromDirectory(directoryPath);
指定したディレクトリー配下のファイルが全て入ったリストを取得
File.Delete(imageFilePaths[0]);
最も古いファイルを削除
byte[] bytes = _paintImage.sprite.texture.EncodeToPNG();
Png画像に変換
List<string> imageFilePaths = GetAllFileFromDirectory(directoryPath);
指定したディレクトリー配下のファイルが全て入ったリストを取得
インデックス用カウンター
byte[] bytes = File.ReadAllBytes(imageFilePath);
読み込み
Texture2D loadTexture = new Texture2D(2, 2);
画像をテクスチャに変換
count++;
カウンターを進める
float lineLength = Vector2.Distance(_prevPosition, endPosition);
2点間の距離
Vector3 lerpPosition = Vector2.Lerp(_prevPosition, Input.mousePosition, lerpWeight);
前回の入力座標、現在の入力座標、割合を渡して補間する座標を算出
_prevPosition = Input.mousePosition;
前回の入力座標を記録
_prevPosition = Vector2.zero;
前回の入力座標をリセット
if (_prevPosition == Vector2.zero)
前回値がまだないなら現在の値を前回値として扱う
_prevPosition = Vector2.zero;
前回の入力座標をリセット
DataRow row = tbl.Rows[i];
データ行
listBox1.Items.Add(row[1]);
右のリストボックスにアイテムを追加
Array.Clear(bmparr,0, bmparr.Length);
画像の解放
StateMachine<MyClass> stateMachine = new StateMachine<MyClass>(myClass);
ステートマシンの宣言
stateMachine.ChangeState(myState);
現在の状態を変更
stateMachine.Update();
現在のステートを実行
Directory.CreateDirectory(directoryPath);
まだ存在してなかったら作成
ImageData imageData =new ImageData(pngPath,_inputText.text);
構造体にパス、名前を入れる　これでひとつの塊
JsonDataUtility.Save(imageData,jsonPath);
構造体をJsonに変換
byte[] bytes = File.ReadAllBytes(imageData.ImageSavePath);
読み込み
Texture2D loadTexture = new Texture2D(2, 2);
画像をテクスチャに変換
_loadImage.sprite = Sprite.Create(loadTexture, new Rect(0, 0, loadTexture.width, loadTexture.height), Vector2.zero);
テクスチャをスプライトに変換
_loadText.text = imageData.ImageName;
画像の名前を表示
Directory.CreateDirectory(directoryPath);
まだ存在してなかったら作成
string connStr = "server=127.0.0.1;user id=test;password=test1;database=manutest";
接続情報を文字列で与える
conn.Open();
接続を開く
conn.Close();
接続を閉じる
{List<ExampleClass> selItems = new List<ExampleClass>();foreach (var oneItemLine in listBox.SelectedItems){ExampleClass item = oneItemLine as ExampleClass;selItems.Add(item);}return selItems;}
SelectedItemsの中身を取り出すメソッド
{string controlName = "ExampleList1";object controlObj = FindName(controlName);ListBox listBox = (ListBox)controlObj;if (listBox.SelectedItems.Count == 0)return;List<ExampleClass> selItems = GetSelectedItems(listBox);string message = "";foreach (var line in selItems){message = message + string.Format("\r\nId：「{0}」　Nmae：「{1}」　Age：「{2}」", line.Id, line.Name, line.Age);}message = string.Format($"{controlName} で選択中の項目は\r\n{message}\r\n\r\nです");MessageBox.Show(message);}
リストボックス1の選択中アイテムを表示する
object controlObj = FindName(controlName);
リストボックスを探す
if (listBox.SelectedItems.Count == 0)return;
選択項目が0ならメソッドを出る
List<ExampleClass> selItems = GetSelectedItems(listBox);
選択中のアイテムを取得する
{string controlName = "ExampleList2";ItemShow(controlName);}
! リストボックス2の選択中アイテムを表示する
mvcBuilder.AddRazorRuntimeCompilation();
実行時コンパイルの有効化
if (ExampleList.SelectedItems.Count == 0)return;
選択項目が0ならメソッドを出る
int[] _id = new int[0];
空の配列を宣言
ExampleClass item = oneItemLine as ExampleClass;
ExampleClassとして取り出す
_list.RemoveRange(0, result);
リストのインデックス 0～result を削除
bool isDemoMode = this._configuration.GetValue<bool>("UserSettings:IsDemoMode");
ブール値のロード
string defaultUserName = this._configuration["UserSettings:DefaultUser:Name"];
文字列値のロードは、インデクサで指定可能
int defaultUserAge = this._configuration.GetValue<int>("UserSettings:DefaultUser:Age");
int 値のロード
services.Configure<UserSettings>(this.Configuration.GetSection("UserSettings"));
構成情報の注入
this._userSettings = userSettings.Value;
構成情報の取得
return View(this._userSettings);
構成情報の参照
distance = Vector3.Distance(startMarker.position, endMarker.position);
二点間の距離
float distCovered = (Time.time - startTime) * speed;
移動距離 =　経過時間　*　速度
fractionOfJourney = distCovered / distance;
移動距離の割合 = 移動距離 /　二点間の距離
transform.position = Vector3.Lerp(startMarker.position, endMarker.position, fractionOfJourney);*}
線形補間による移動
mat = this.GetComponent<Renderer>().material;
LerpExampleから補間値を取得
mat.color = Color.Lerp(Color.blue, Color.red, lerpExample.fractionOfJourney);
青色→赤色へLerpExampleと同じ補間値で推移
Window firstWindow = new MainWindow();
Windowsインスタンスを生成した際に自動でそのインスタンスがApplication.MainWindowにセットされる。
[RequireComponent(typeof(Rigidbody2D))]
Rigidbody2Dコンポーネントを必須にする
_rigidbody.velocity = direction * _speed;
機体の移動
if (this.paramA.SetValue(value, this))this.Model.ParamA = int.Parse(this.ParamA);
入力エラーがなければModelに設定
if (this.paramB.SetValue(value, this))this.Model.ParamB = int.Parse(this.ParamB);
入力エラーがなければModelに設定
Console.WriteLine(string.Join(",",ary));
aryを連結して出力
{sensor.AddObservation(gameObject.transform.localPosition.z);sensor.AddObservation(cartRB.velocity.z);sensor.AddObservation(pole.transform.localRotation.eulerAngles.x);sensor.AddObservation(poleRB.angularVelocity.x);}
センサーにデータを送る
var actionZ = 200f * Mathf.Clamp(verctorAction[0], -1f, 1f);
カートに力を加える
poleRB.angularVelocity = new Vector3(Random.Range(-0.1f, 0.1f), 0f, 0f);
ランダムな傾きを与える
var actionZ = 200f * Mathf.Clamp(verctorAction[0], -1f, 1f);
カートに力を加える
SelectionColor = ResultColor;
実行結果の表示色を設定
if (ee.Result != null && ee.Result.Length != 0 && ee.Result[0] == COUTIONCHER) {*ee.Result = ee.Result.Remove(0, 1);
表示文字列の先頭が「！」なら、その一文字を削除し、表示色をCoutionColorに変更
AppendText(LFCR + ee.Result + LFCR);
実行結果の表示
Console.WriteLine(string.Join(",", array));
コンマ区切りで出力
*Console.WriteLine(string.Join(" ", array));
スペース区切りで出力
*Console.WriteLine(string.Join("\r\n", array));
改行区切りで出力
downloadedPost.LGTM();
記事をLGTMする
QiitaServer.Upload(post);
記事をアップロードする
IAuthorQiitaPost post = new QiitaPost("タイトル", "本文");
記事を書く
{for (var i = 0; i < NameList.Count; i++){yield return this[i];}}
GetEnumerator実装
{return this.GetEnumerator();}
IEnumerable(非ジェネリック型)のGetEnumeratorも実装
foreach (var (name, index) in properties.Select((prop, index) => (prop.Name, index)))
propertiesから、各Name取り出し
public GameObject viewcamera;
"viewcamera"という変数を定義
viewcamera.transform.Rotate(-mouse_y, 0.0f, 0.0f);*}
このscriptに登録されているオブジェクトをX方向に-mouse_yの値分、回転する
this.RegionManager.RequestNavigate("RedRegion", nameof(UserControl2), new NavigationParameters($"id=1"));
Shell.xaml.csで作成したリージョンの名前と、画面のUserControlクラス名を指定して、画面遷移させる。
ray = Camera.main.ScreenPointToRay(Input.mousePosition);
クリック点にRayを飛ばす
Collider[] collider = Physics.OverlapSphere(hit.point, radius);
クリックした所から半径20mの範囲のColliderを取得
DX.SetDrawScreen(DX.DX_SCREEN_BACK);
裏画面処理を設定する
DX.ScreenFlip();
2つの画面を入れ替える
target.localPosition = new Vector3 (Random.value * 8 - 4, 0.5f, Random.value * 8 - 4);
ターゲットを新しい無作為な位置へ移動
if (distanceToTarget < reachMargin) 
ターゲットへの到達したら
*{UIHostNoLaunch uiHostNoLaunch = null;try{uiHostNoLaunch = new UIHostNoLaunch();var tipInvocation = (ITipInvocation)uiHostNoLaunch;tipInvocation.Toggle(GetDesktopWindow());}finally{if (uiHostNoLaunch != null){Marshal.ReleaseComObject(uiHostNoLaunch);}}}
UIHostNoLaunch.Toggle で表示切り替え
RpcSetBaseTime(DateTime.UtcNow);
クライアントにホストの現在時刻を送信する
var t = Time.realtimeSinceStartup - baseTime;
ホスト開始からの経過時間
var delay = (float)(DateTime.UtcNow - hostTime).TotalSeconds;
通信で起きたラグを算出
baseTime = Time.realtimeSinceStartup - delay;
ラグを考慮した開始時間を設定、このbaseTimeがホストの基準時刻と一致する
Authenticator = new DigestAuthenticator("username", "password");
Digest認証の設定
client.UseUtf8Json();
JSONシリアライザーの設定
var request = new RestRequest("foobaz", DataFormat.Json);
リクエストの生成（Resourceとレスポンスのデータフォーマットを設定）
var response = client.Get(request);
同期呼び出し
var result = new Utf8JsonSerializer().Deserialize<Foo>(response);
JSONデータをデシリアライズ
var result = await client.GetAsync<Foo>(request);
非同期呼び出し（resultがFoo型として返ってくる）
p.StartInfo.StandardOutputEncoding = Encoding.GetEncoding("shift_jis");
Pythonの出力結果をshift-jisに変換
p.OutputDataReceived += new DataReceivedEventHandler((sender, e) =>
イベントハンドラの設定。pythonから出力があるたびに呼び出される
if (Physics.Raycast(transform.position, Vector3.down, out hit, 10))
レイが当たったか判定
if (String.Compare(Path.GetFileName(tmp), "EXPLORER.EXE", true)==0) {
大文字小文字無視で比較
var item = new ListViewItem(new string[]{Path.GetFileName(path),path});
Windows形式のパス表現に変換する
ILogger logger = new ConsoleLogger();
Loggerを初期化する
var context = System.Threading.SynchronizationContext.Current;
UIスレッドを触る可能性があるので、コールバックを渡すためのコンテキストを退避しておく
string targetFilePath = targetDir + targetFileName;
ファイル準備
var regex = new Regex(regexPattern, RegexOptions.Compiled);
ファイル名の一部を変更する置換パターンを作成
fileElem.Replace(new[] { rpRegex });
リネームプレビュー実行
fileElem.Rename();
リネーム保存実行
string[] port_list = SerialPort.GetPortNames();
ポート一覧の更新
if (SerialPortComboBox.Items.Count <= 1)SerialPortComboBox.SelectedIndex = 0;
ポート数が1以下であれば0番目を選択
NativeMethods.CopyMemory((void*)0, src, realsrc.Length);
0番地にデータをコピーする
RSA rsa = RSA.Create();
秘密鍵と公開鍵を生成
var publicKey = rsa.ToXmlString(false);
鍵情報を保存
Console.WriteLine($"Encrypt: {encByteToString}");
暗号化したバイトデータを16進数文字列に変換
var encStrToBytes = encByteToString.Split('-').Select(r => Convert.ToByte(r, 16)).ToArray();
上記の方法で生成された16進数文字列を外部から受信したと仮定して、秘密鍵を使って復元する
{decRsa.FromXmlString(privateKey);decryptedByte = decRsa.Decrypt(encStrToBytes, RSAEncryptionPadding.Pkcs1);}
秘密鍵情報の文字列からオブジェクトを復元し、復号
Random rnd = new Random();
乱数インスタンス化
Bitmap canvas = new Bitmap("画像のパス");
描画先とするImageオブジェクトを作成する
g.DrawImage(canvas, rnd.Next(0, 1920), rnd.Next(0, 1000));
ImageオブジェクトのGraphicsオブジェクトを作成する
var path = EditorUtility.OpenFilePanel("Open csv", "", "CSV");
パスの取得
var reader = new StreamReader(path);
読み込み
{int ret = 0;for (int i = 0; i < inputCount; i++){if (inputs[i] >= target){ret++;}}return ret;}
targer以上の要素の個数を返す
var endpoint = context.GetEndpoint();
UseRoutingの後に配置したミドルウェアではhttpコンテキストからエンドポイントの情報を取得できる
{endpoints.MapRazorPages();});
エンドポイントとデリゲートを関連付ける
double X_x = x * 1;
X軸周りで回転計算
double X_y = X_x * Math.Cos(f_roty * rad) + Z_x * Math.Sin(f_roty * rad);
Y軸周りで回転計算
double X_z = X_y * Math.Cos(f_rotz * rad) - Y_y * Math.Sin(f_rotz * rad);
Z軸周りで回転計算
public ReactiveCommand CloseWindow { get; } = new ReactiveCommand();
プロパティ宣言
CloseWindow.Subscribe(x => ((System.Windows.Window)x).Close());
コンストラクタ
OK.Subscribe(x => {result = MessageBox.Show("ウィンドウを閉じてもよろしいですか？", "確認メッセージ", MessageBoxButtons.OKCancel);if (result == DialogResult.Cancel)return;elseCloseWindow.Execute(x);});
コンストラクタ
return actressSearch.ToActressList();
データベース用クラス変換
glControl = new GLControl();
GLControlの初期化
if (e.Button == MouseButtons.Right)
右ボタンが押された場合
if (isCameraRotating)
カメラが回転状態の場合
if (zoom > 4.0f)zoom = 4.0f;
拡大、縮小の制限
GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
バッファのクリア
glControl.SwapBuffers();
バッファの入れ替え
GL.Begin(PrimitiveType.Triangles);
描画
{int width = glControl.Width;int height = glControl.Height;float[] floatArr = new float[width * height * 3];OpenCvSharp.Mat ret = new OpenCvSharp.Mat(height, width, OpenCvSharp.MatType.CV_32FC3);// dataBufferへの画像の読み込みIntPtr dataBuffer = Marshal.AllocHGlobal(width * height * 12);GL.ReadBuffer(ReadBufferMode.Front);GL.ReadPixels(0, 0, width, height, PixelFormat.Bgr, PixelType.Float, dataBuffer);// imgへの読み込みMarshal.Copy(dataBuffer, floatArr, 0, floatArr.Length);// opencvsharp.Matへの変換Marshal.Copy(floatArr, 0, ret.Data, floatArr.Length);// 破棄Marshal.FreeHGlobal(dataBuffer);return ret;}
画像の保存
IntPtr dataBuffer = Marshal.AllocHGlobal(width * height * 12);
dataBufferへの画像の読み込み
Marshal.Copy(dataBuffer, floatArr, 0, floatArr.Length);
imgへの読み込み
Marshal.Copy(floatArr, 0, ret.Data, floatArr.Length);
opencvsharp.Matへの変換
Marshal.FreeHGlobal(dataBuffer);
破棄
var polygon = SurfaceAnalyzer.LoadData.LoadSTL(@"local\cube3_とんがり2.STL", true);
形状の読み込み
viewer.Render(polygon);
形状のレンダリング
{Cv2.ImShow("mat", mat);Cv2.ImWrite(@"local\mat.jpg", mat * 256);}
viewerの画像の取得
Cv2.ImShow("mat", mat);
画像の表示
Cv2.ImWrite(@"local\mat.jpg", mat * 256);
画像の保存
if (args.Length > 0)
引数が指定されていればyournameに代入
string csvText = loadCSV.csvFile.text;
csvファイルをstring形式に変換
string[] afterParse = csvText.Split('\n');
改行ごとにパース
string fileName = parseByComma[column] + ".asset";
ファイルを作成
PokeDex pokedex = CreateInstance<PokeDex>();
PokeDexのインスタンスをメモリ上に作成
var asset = (PokeDex)AssetDatabase.LoadAssetAtPath(path, typeof(PokeDex));
インスタンス化したものをアセットとして保存
AssetDatabase.CreateAsset(pokedex, path);
指定のパスにファイルが存在しない場合は新規作成
EditorUtility.CopySerialized(pokedex, asset);
指定のパスに既に同名のファイルが存在する場合は更新
string csvText = loadCSV.csvFile.text;
csvファイルをstring形式に変換
string[] afterParse = csvText.Split('\n');
改行ごとにパース
string fileName = parseByComma[column] + ".asset";
ファイルを作成
IndexName = "Date-Time-index"
利用する GSI を指定
this.room = await this.Group.AddAsync(roomName);
ルームに参加&ルームを保持
this.Broadcast(room).OnJoin(me.Name);
参加したことをルームに参加している全メンバーに通知
await room.RemoveAsync(this.Context);
ルーム内のメンバーから自分を削除
this.Broadcast(room).OnLeave(me.Name);
退室したことを全メンバーに通知
this.Broadcast(room).OnSendMessage(me.Name, message);
発言した内容を全メンバーに通知
this.Broadcast(room).OnMovePosition(me);
更新したプレイヤーの情報を全メンバーに通知
await this.sampleHub.JoinAsync(player);
ゲームに接続する
await this.sampleHub.SendMessageAsync("こんにちは！");
チャットで発言してみる
ゲームから切断してみる
var newSessionID = Guid.NewGuid().ToString();
セッションIDを持っていなければクッキーに埋め込む
await CookieService.WriteCookieAsync(SessinID, newSessionID).ConfigureAwait(false);
セッションIDを持っていなければクッキーに埋め込む
var loginData = await LocalStorage.GetItemAsync<LoginData>(sessionID.Value).ConfigureAwait(false);
セッションIDを持っておりローカルストレージにもログイン情報がある場合
public static Setting Values { get; private set;}
外部に公開する為の static プロパティ
public int FormLocationX { get; set;}
シリアライズするプロパティは public にして getter と setter が必要。
Setting.Load();
読み出し
Workbook workbook = new Workbook();
workbookオブジェクトを作成します。
workbook.LoadFromFile("Sample.xlsx");
Excelをロードします。
Worksheet sheet = workbook.Worksheets[0];
シートを取得します。
sheet.SaveToImage("ExceltoImage.png", ImageFormat.Png);
イメージで保存します。
.WithAutomaticReconnect(new RandomRetryPolicy())
自動接続
var urlPattern = new Regex(@"(https?|ftp)(:\/\/[-_.!~*\'()a-zA-Z0-9;\/?:\@&=+\$,%#]+)");
message = HttpUtility.HtmlEncode(message);
入力文字列をサニタイズする
if (urlPatternMatch.Success)
入力文字列の中にURLが存在する場合
await _hubConnection.StartAsync();
画面の更新を行う
return TimeSpan.FromSeconds(_random.Next(2, 5));
2～5秒の間でランダムに再接続を試みる
var urlPattern = new Regex(@"(https?|ftp)(:\/\/[-_.!~*\'()a-zA-Z0-9;\/?:\@&=+\$,%#]+)");
入力文字列の中にURLが存在するかどうかを判定だけする
Label label = new Label();
ラベルのインスタンス生成
String inputFile = @"C:\Users\Administrator\Desktop\sample.pdf";
パスを指定します。
String outputFolder = @"C:\Users\Administrator\Desktop\Output\";
パスを指定します。
PdfStandardsConverter converter = new PdfStandardsConverter(inputFile);
PdfStandardsConverterオブジェクトを作成します。
.Range(1, 3)
1～3の数値を取得する
string gitPath = GetGitPath();
gitのパスを取得する。
string gitCommand = "config core.autocrlf";
gitのコマンドを設定する。
string autocrlf = GetStandardOutputFromProcess(gitPath, gitCommand).Trim();
コマンドを実行して標準出力を取得する。
return exePaths.FirstOrDefault(exePath => File.Exists(exePath));
存在するパスで最初に見つかったもの
{FileName = exePath,Arguments = arguments,WindowStyle = ProcessWindowStyle.Hidden,UseShellExecute = false,RedirectStandardOutput = true,};
プロセスの起動条件を設定する。
{string output = process.StandardOutput.ReadToEnd();process.WaitForExit(TimeoutPeriod);return output;}
プロセスを起動する。
string output = process.StandardOutput.ReadToEnd();
標準出力を取得する。
process.WaitForExit(TimeoutPeriod);
プロセスが終了するかタイムアウトするまで待つ。
Properties.Settings.Default.Setting1 = "a"
値の設定
Properties.Settings.Default.Save();
全部まとめて保存
LogFilePath = Path.Combine(LogDirPath, "Application.log");
出力ファイル名
Root myDeserializedClass = JsonConvert.DeserializeObject<Root>(myJsonResponse);
デシリアライズコード
.ToReactiveCommand();
実行可能なコマンド
.Select(x => new SomeDisposableClass(x))
文字列から Dispose が必要なオブジェクトに変換
BBB.IsSelected = true;
BBBタブを選択状態にする
CCC.IsSelected = true;
CCCタブを選択状態にする
cashDrawer.OpenDrawer();
キャッシュドロアを開く
if (e.Reason == SessionSwitchReason.SessionUnlock)isSoftwareRenderingMode = MakeIsSoftwareRenderingMode():
セッションのロックが解除されたとき、リモート接続されたとき
listener.Bind(localEndPoint);
通信の受け入れ準備
int bytesRec = handler.Receive(bytes);
データの受取をReceiveで行う。
data1 = data1.ToUpper();
大文字に変更
byte[] msg = Encoding.UTF8.GetBytes(data1);
クライアントにSendで返す。
handler.Shutdown(SocketShutdown.Both);
ソケットの終了
IPHostEntry ipHostInfo = Dns.GetHostEntry(Dns.GetHostName());
IPアドレスやポートを設定している。
Socket socket = new Socket(ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
ソケットを作成
byte[] msg = Encoding.UTF8.GetBytes(st + "<EOF>");
Sendで送信している。
byte[] bytes = new byte[1024];
Receiveで受信している。
socket.Shutdown(SocketShutdown.Both);
ソケットを終了している。
services.Configure<SendMailParams>(Configuration.GetSection("SendMailParams"));
メール送信用のパラメータを「appsettings.json」から抜きしてDIで利用できるようにしている
services.AddScoped<IEmailSender, MailSender.MailSender>();
メール送信用のクラスを認証時に利用するメール送信サービスとして登録。
services.AddDefaultIdentity<IdentityUser>(options => options.SignIn.RequireConfirmedAccount = true)
メールによる確認を有効にした認証を有効にする
systemManager = await userManager.FindByNameAsync(StstemManageEmail);
システム管理ユーザーにシステム管理ロールを追加
var normalUser = new IdentityUser { UserName = NormalUserEmail, Email = NormalUserEmail, EmailConfirmed = true };
ユーザー作成
var services = scope.ServiceProvider;
サービスプロバイダーの取得
IdentityUserInitializer.Initialize(services).Wait();
初期のユーザーとロールの作成
var context = services.GetRequiredService<ApplicationDbContext>();
データベースの自動マイグレーション
IdentityUserInitializer.Initialize(services).Wait();
初期のユーザーとロールの作成
services.AddIdentity<IdentityUser, IdentityRole>()
認証を有効にする
{RootDirectory = @".\Documents\",TypeDocumentTemplate = File.ReadAllText(typeTemplate, Encoding.UTF8),NamespaceDocumentTemplate = File.ReadAllText(namespaceTemplate, Encoding.UTF8),};
ライターを設定（.NET Framework バージョンの場合）
string typeDocTemplate = File.ReadAllText(typeTemplate, Encoding.UTF8);
ライターを設定（.NET Core バージョンの場合）
{ConstructorFilter = ConstructorInfoExtensions.IsRecommendOutputToDocument,TypeFilter = TypeExtenstions.IsRecommendOutputToDocument,PropertyFilter = PropertyInfoExtensions.IsRecommendOutputToDocument,FieldFilter = FieldInfoExtensions.IsRecommendOutputToDocument,MethodFilter = MethodInfoExtensions.IsRecommendOutputToDocument,EventFilter = EventInfoExtensions.IsRecommendOutputToDocument,};
コンテキストとフォーマッターを設定
top.enabled = viewportRect.max.y >= contentBound.max.y;
上までスクロールされているか？
Grounded = true;
Groundedをtrueにする
Quaternion rot = Quaternion.AngleAxis(rotate_direction * rotate_speed, transform.up);
オブジェクトからみて垂直方向を軸として回転させるQuaternionを作成
Quaternion q = this.transform.rotation;*
現在の自信の回転の情報を取得する。
this.transform.rotation = rot * q;
合成して、自身に設定
RaycastHit hit;
Rayが当たったオブジェクトの情報を入れる箱
if (Physics.Raycast(ray, out hit, Mathf.Infinity))
もしRayにオブジェクトが衝突したら
if (hit.collider.tag == "Planet")
Rayが当たったオブジェクトのtagがPlanetだったら
.Where(pair => (pair.up.Timestamp - pair.down.Timestamp) <= TimeSpan.FromMilliseconds(shortTapThreshold))
押した時と離れたときの間隔が shortTapThreshold 以下のときだけ通す
_randomNumber = Random.Range(0, _blockParent.transform.childCount);_randomInterval = Random.Range(_MIN_INTERVAL_VALUE, _MAX_INTERVAL_VALUE);
ランダムな値
await UniTask.Delay(TimeSpan.FromSeconds(_randomInterval));
ランダムな間隔でDelay
_usePositionList.Add(randomPosition);
新しい使用中のポジションをリストに追加
cam.GetComponent<RippleEffect>().SetNewRipplePosition(target);
新しい波紋を生成
double  val8  = 1.23;
1.23dと明示的に表記してもOK
var hoge = JsonSerializer.Deserialize<Hoge>(File.ReadAllText(@"C:\hoge.json"), options);
デシリアライズ
var json = JsonSerializer.Serialize<Hoge>(hoge, options);
シリアライズ
var posts = context.GetCollection<Post>("posts");
DBへ接続
posts.EnsureIndex(x => x.Title, true);
Titleをユニークインデックスにする
posts.Update(post);
更新
Console.WriteLine("Hello world");
文字を出力
var tokyoWeathers = string.Join(", ", nodes.Select(x => x.TextContent.Trim()));
整形して出力
var ave1 = timeSpans.Item1.Average();
それぞれの平均処理速度と速度改善率を計算
if(rect.X + rect.Width >= ClientSize.Width)addX = false;*else if(rect.X <= 0)addX = true;
フォームの外枠超えようとすると、移動方向反転
Invalidate();
再描画
public int Value { get; private set; }
イベントを定義
var counter = new Counter();
カウンターを作る
context.Dispose();
解放
pRt.enableRandomWrite = true;
レンダーテクスチャを書き込み可能にする
_skin.BakeMesh(mesh);
SkinnedMeshRenderから現在のフレームのmeshを作る
posBuffer = new ComputeBuffer(vertexCount, System.Runtime.InteropServices.Marshal.SizeOf(typeof(Vector3)));
コンピュートシェーダーに値を渡す入れ物をつくる
posBuffer.SetData(mesh.vertices);
meshの頂点位置情報をセットする
infoTexGen.Dispatch(kernel, vertexCount, 1, 1);
コンピュートシェーダを実行する
var kernel = NormalizedRGBValueTo64pxRGBBrightness.FindKernel("CSMain");
呼びたいカーネル（処理）を決める
ReadOnlyCollection<IWebElement> itemList_sb = chrome.FindElementsByClassName("SearchResultList-box");
クラス名SearchResultList-boxの要素を取得
ReadOnlyCollection<IWebElement> itemList_li = itemList_sb[0].FindElements(By.ClassName("List_item"));
クラス名SearchResultList-boxの下にあるクラス名List_itemの要素を取得
ReadOnlyCollection<IWebElement> itemList_sb = chrome.FindElementsByClassName("SearchResultList-box");
クラス名SearchResultList-boxの要素を取得
ReadOnlyCollection<IWebElement> itemList_wc = itemList_sb[0].FindElements(By.CssSelector("*"));
クラス名SearchResultList-boxの下にあるすべての要素を取得
ReadOnlyCollection<IWebElement> itemList = chrome.FindElementsByClassName("List_item");
クラス名List_itemの要素を取得
string text = itemList[0].Text;
List_item1個めのテキスト"Text1"を取得
ReadOnlyCollection<IWebElement> itemList = chrome.FindElementsByTagName("li");
Tag名"li"の要素を取得
string text = itemList[0].GetAttribute("class");
Tag名liの1個めのクラス名"List_item"を取得
ReadOnlyCollection<IWebElement> itemList = chrome.FindElementsByTagName("ul");
Tag名"ul"の要素を取得
string text = itemList[0].GetAttribute("innerHTML");
HTMLを取得
string text = itemList[0].TagName;
class名SearchResultList-boxの要素を取得
*ReadOnlyCollection<IWebElement> itemList = chrome.FindElementsByClassName("URL-box");
class名SearchResultList-boxの要素を取得
if (IsIconic(handle))ShowWindowAsync(handle, SW_RESTORE);
最小化状態なら元に戻す
int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);
フォアグラウンドウィンドウを作成したスレッドのIDを取得
int targetID = GetWindowThreadProcessId(handle, out processId);
目的のウィンドウを作成したスレッドのIDを取得
AttachThreadInput(targetID, foregroundID, true);
スレッドのインプット状態を結び付ける
SetForegroundWindow(handle);
ウィンドウをフォアグラウンドに持ってくる
AttachThreadInput(targetID, foregroundID, false);
スレッドのインプット状態を切り離す
if (p.MainWindowTitle.Length != 0)
メインウィンドウのタイトルがある時だけ
ForceActive(pFireFox.MainWindowHandle);
FireFoxをアクティブに
var responceObject = JsonConvert.DeserializeObject<GetSlackMessagesResponce>(responseBodyString);
読みだしたJsonを、オブジェクトにデシリアライズする
Text = messageResponce.text;
本文を設定
using var reader = new StreamReader(stream);
ストリームから文字列を読みだすため、StreamReaderを生成する
user.Name = user.Name.ToUpper();
大文字に変換
public Texture wood_dark_AlbedoTransparency;
クラス変数として Texture型のクラス変数 wood_dark_AlbedoTransparencyを定義する
GCHandle handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
GCによって移動しないように固定する。
IntPtr bufferPtr = handle.AddrOfPinnedObject();
確保したバッファのアドレス
handle.Free();
解放
var services = new ServiceCollection();
型の登録
DialogResult result = pd.ShowDialog();
ダイアログを表示する
if (bw.CancellationPending){
キャンセルされたか調べる
e.Cancel = true;
キャンセルされたとき
e.Result = counter;
結果を設定する
System.Threading.Thread.Sleep(16);
指定された時間待機する
this.bmp = new Bitmap(500, 400);
キャンバスサイズは横500px、縦400px。
g.DrawEllipse(new Pen(GetFaceBorderColor(), 5), GetFacePosition());
顔の輪郭を描く。
g.FillEllipse(new SolidBrush(GetFaceColor()), GetFacePosition());
色を塗る。
*}
bmp.Save(filePath, System.Drawing.Imaging.ImageFormat.Png);
画像をPNG形式で保存する。
Score = Sd.GetScore();
ScoreDataの中のGetScore関数を呼び出す
gameObject.GetComponent<Renderer>().material.color = Color.red;
マテリアルの色を赤色に変更する
c.RegisterType<ISettingsProvider, SettingsProvider>();
アプリの起動時あたりで、以下のようにアプリで使うインターフェースと実装クラスを登録していく
webImage.Mutate(w => w.Resize(180, 180));
画像をリサイズ
ctx.DrawImage(webImage, new Point(240, 154), 1);
座標を指定して書き込む
ctx.DrawText("MKTaro", font, Color.FromRgb(255, 255, 255), new PointF(240, 90));
テキストを書き込む処理
Parallel.For(0, 10, i => {Console.WriteLine(i.ToString());});
インデックス0から9までの並列処理。
Task.Run(() => {Console.WriteLine("a");});
並列処理を立ち上げる。
var t = Task.Run(() => {Console.WriteLine("a");});
並列処理を立ち上げる。
t.Wait();
処理の終了を待つ
.Select(x => x * x);
2 乗する
{player.CustomProperties.TryAndGetPlayerNum(out int playerNum);return playerNum;}
プレイヤー番号を取得する
{_hashtable[PLAYER_ASSIGN_NUMBER] = assignNum;player.SetCustomProperties(_hashtable);_hashtable.Clear();}
プレイヤーの割り当て番号のカスタムプロパティを更新する
if (photonView.IsMine)
自分のクライアントの同期オブジェクトの時
Player[] otherPlayers = PhotonNetwork.PlayerListOthers;
他の全プレイヤー取得
if (otherPlayers.Length <= 0)
他のプレイヤーがいなければ
SetMyCustomProperties();
プレーヤーのカスタムプロパティ更新
using System.Windows.Media.Media3D;
3D行列使用
HttpClient httpClient = new HttpClient{Timeout = TimeSpan.FromSeconds(15)};
Timeoutの時間も設定できます。
{if (httpResponse.StatusCode == System.Net.HttpStatusCode.OK){imageData = await httpResponse.Content.ReadAsByteArrayAsync();}}
downloadUrlは画像や動画のUrl
imageData = await httpResponse.Content.ReadAsByteArrayAsync();
正常に取得できたというレスポンス（System.Net.HttpStatusCode.OK）ならデータを取得
IFolder DCIMFolder = await FileSystem.Current.GetFolderFromPathAsync(DCIMPath);
DCIMフォルダの取得
ExistenceCheckResult exist = await DCIMFolder.CheckExistsAsync(saveFolderName);
フォルダがすでにあれば取得、なければ新規作成
IFile file = await saveFolder.CreateFileAsync(saveFileName, CreationCollisionOption.ReplaceExisting);
ファイルを新規作成
{stream.Write(imageData, 0, imageData.Length);}
ファイルに画像や動画のByte情報書き込み
string path = Path.Combine(Android.OS.Environment.ExternalStorageDirectory.AbsolutePath, "DCIM");
Xamarin.AndroidでのDCIMパスの取得
MessageBox.Show(("ここに表示したい文字列を入力します。"));
ポップアップwindowを表示する
var service = EdgeDriverService.CreateChromiumService();
ドライバー起動時に表示されるコンソール画面を非表示にする
driver.FindElement(By.Name("pid")).SendKeys("userId");
サイトを開く
RedirectToAction();
遷移したいページに遷移
m_worker.Dispose();
終了時に破棄する
string[] files = Directory.GetFiles(Path.GetFullPath(folderPath), "*.xlsx");
フォルダの中の拡張子が.xlsxのファイルの取得
excel = new Excel.Application();
Excelを起動する
books = excel.Workbooks;
ブック一覧の定義
book = books.Open(file);
ブックを開く
sheets = book.Worksheets;
シート一覧の定義
sheet = sheets[1];
最初のシートの選択
cells = sheet.Cells;
セル一覧の定義
range = cells[2, 1];
セル[2,1]の選択
book.Close(true);
ブックを保存して閉じる
excel.Quit();
Excelを終了する
Marshal.FinalReleaseComObject(range);
定義されたオブジェクトの解放
range3.Merge();
セルの結合
range = sheet.Range["B2:D2"];
セル[B2]から[D2]までの範囲の選択
range.Merge();
セルの結合
range = cells[2, 1];
セル[2,1]の選択
font = range.Font;
フォントの選択
font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.Red);
文字色を赤にする
range = cells[2, 2];
セル[2,2]の選択
border = range.Borders;
罫線選択
border.LineStyle = Excel.XlLineStyle.xlContinuous;
罫線を実線に設定する
border.Weight = 2d;
罫線の太さの設定
services.AddLocalization(options => options.ResourcesPath = "Resources");
ローカリゼーション周りのクラスをDIコンテナに登録する。
string[] supportedCultures = new string[] {"ja", "en"};
サポートするカルチャの設定
Random cRandom = new System.Random();
乱数
Debug.WriteLine($"User Message: {message}");
引数messageの内容を出力
var val = (offsetToMidBaseline.x - minX) / (maxX - minX);
中心位置を計算
point = rotation * point + new Vector3(pos0.x, offsetToMidBaseline.y, pos0.z);
移動と回転を適用
{var angle = (float) (1.5 * Math.PI + (val - 0.5f) * spread * Mathf.Deg2Rad);var x = radius * Mathf.Cos(angle);var z = (flip ? -1 : 1) * radius * (1 + Mathf.Sin(angle));return new Vector3(x, 0, z);}
0~1のvalueに対し，円周上の位置を返す
var deg = i;
境界部での丸め込み
_searchItemQuary.Execute(1);
商品IDが1の商品情報を取得
return item.Execute(_id)
idに紐づいた商品情報を取得
var client = new GitHubClient(new ProductHeaderValue("lr")) {Credentials = tokenAuth};
接続情報の設定
var client = new GitHubClient(new ProductHeaderValue(settings.Owner)) {Credentials = tokenAuth};
接続情報の設定
var createIssue = new NewIssue(issueTitle);
Issueを作成し、本文を設定
var newIssue = await client.Issue.Create(settings.Owner, settings.Repository, createIssue);
Issueを追加
PhotonNetwork.ConnectUsingSettings();
PhotonServerSettingsに設定した内容を使ってマスターサーバーへ接続する
if (stream.IsWriting)
自身のクライアントから相手クライアントの同期オブジェクトに送る情報
{var page = new ContentPage{Content = view};await Application.Current.MainPage.Navigation.PushModalAsync(page);}
フルスクリーンを実現するためのメソッド
return await accountService.CreateAccount();
サーバーにアカウント作成を要求、レスポンスは作成されたユーザIDとパスワード
GrpcEnvironment.SetLogger(new Grpc.Core.Logging.ConsoleLogger());
コンソールにログ出力するように設定
await MagicOnionHost.CreateDefaultBuilder()
MagicOnionを使ってホスト作成、起動
{Logger.Info("CreateAccount Request");var userId = GenerateHash(20);var password = GenerateHash(12);try{if (!Directory.Exists("accounts")) Directory.CreateDirectory("accounts");File.WriteAllText("accounts/" + userId, password);}catch (Exception e){Logger.Error(e, "CreateAccount Error");return (null, null);}Logger.Info($"CreateAccount UserId:{userId}, Password:{password}");return (userId, password);}
アカウント作成
{if (!Directory.Exists("accounts")) Directory.CreateDirectory("accounts");File.WriteAllText("accounts/" + userId, password);}
アカウント情報を仮でファイルに保存(本来はDBに入れる事！)
{Logger.Info("Login Request");try{if (!File.Exists("accounts/" + userId)) return null;if (File.ReadAllText("accounts/" + userId) != password){Logger.Warning("Login failed: " + (userId, password));return null;};}catch (Exception e){Logger.Error(e, "Login Error");return null;}var session = GenerateHash(20);lock (lockObject){sessions[session] = (userId, DateTime.UtcNow.AddDays(1));}Logger.Info("【" + userId + "】Login succeeded!");return session;}
ログイン
if (!File.Exists("accounts/" + userId)) return null;
アカウントがない
if (File.ReadAllText("accounts/" + userId) != password)
パスワードが一致しない
sessions[session] = (userId, DateTime.UtcNow.AddDays(1));
一先ず1日有効なセッションを保存
{return Sha256(Guid.NewGuid().ToString("N")).Substring(0, length).ToLower();}
指定の長さのランダムハッシュ値を取得
AllocConsole();
Console表示
Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = true });
コンソールとstdoutの紐づけを行う。
var connectionString = Parameter.getConnectionString();
DB接続文字列の取得
{connection.Open();try{Database.checkMasterData(models, log, connection);Database.saveData(models, jstTime, log, connection);}catch (Exception exception){log.LogInformation(exception.Message);throw;}finally{connection.Close();}}
データ保存
connection.Open();
データベースの接続開始
Database.checkMasterData(models, log, connection);
マスタテーブルの更新チェック
Database.saveData(models, jstTime, log, connection);
データを保存
connection.Close();
データベースの接続終了
httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", Parameter.getQiitaAccessToken());
OAuth 2.0 Authorization Headerの設定
public static void checkMasterData(List<QiitaInformationModel> models, ILogger log, SqlConnection connection)*{
新たに記事が投稿された場合はマスタテーブルを更新
selectCommand.CommandText = @"SELECT id FROM qiita_items";
SQLの準備
insertCommand.CommandText = @"INSERT INTO qiita_items VALUES (@ID, @TITLE, @CREATED_AT)";
SQLの準備
log.LogInformation($"succeeded to insert master data: {model.Title}");
SQLの実行
transaction.Commit();
コミット
transaction.Rollback();
ロールバック
command.CommandText = @"INSERT INTO page_views_count VALUES (@ID, @COUNTED_AT, @PAGE_VIEWS_COUNT)";
SQLの準備
log.LogInformation($"succeeded to insert data: {model.Title}");
SQLの実行
transaction.Commit();
コミット
transaction.Rollback();
ロールバック
title = type.Name.Replace("Node", "");
クラス名から "Node" を削除したもの
CvOptFlow.UpdateMotionHistory(black_diff, motion_history, timestamp, duration);Cv2.Normalize(motion_history, hist_gray, 0, 255, NormTypes.MinMax, MatType.CV_8UC1);
履歴画像の更新
angle_deg = CvOptFlow.CalcGlobalOrientation(orientation, mask, motion_history, timestamp, duration);
全体的なモーション方向を計算
Cv2.Circle(hist_color,
全体のモーション方向を黄色い線で描画
Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
EncodeをShift-Jisに対応
SerialPort sp = new SerialPort("COM3");
シリアルポート取得
var sw = new System.IO.StreamWriter(PATH, false, System.Text.Encoding.GetEncoding("shift_jis"));*//Arduino側のサンプリング周波数
csv出力
string data = sp.ReadLine();
1行分取得
var remark = ControlAttachedProperty.GetRemark(this.textBlock);
コントロールを指定して添付プロパティを取得、設定する
{get => (string) this.GetValue(TextProperty);set => this.SetValue(TextProperty, value);}
CLR ラッパープロパティ
return String.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, OtherPropertyDisplayName ?? OtherProperty);
エラーメッセージを返す
var mediaType = reader.GetCurrentMediaType(SourceReaderIndex.FirstVideoStream);
元のメディアタイプから動画情報を取得する
var mulPositionOfPercent = Math.Min(Math.Max(positionOfPercent, 0), 100.0) / 100.0;
取得する動画の位置を設定
this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(HogeText)));
データを更新したことを通知する
var hogeData = Application.Current.Resources["HogeDataInstance"] as HogeData;
ナビゲーターの項目を押したタイミングで、HogeDataの内容を更新する
IWebElement el = wait.Until(SeleniumExtras.WaitHelpers.ExpectedConditions.ElementExists(By.Name("q")));
Webページを開く
PdfDocument doc = new PdfDocument();
Pdf ファイルをロードします。
PdfUsedFont[] fonts = doc.UsedFonts;
UsedFontsでフォントを取得します。
Font newfont = new PdfFont(PdfFontFamily.TimesRoman, 18f, PdfFontStyle.Italic | PdfFontStyle.Bold);
新規フォントを作成します。
doc.SaveToFile(Result file);
保存します。
Random rnd = new Random(3);
Randomオブジェクトを作成
public static LogFactory factory = new LogFactory();
staticなLoggerを定義
logger.Info(message);
Logの出力
sa.Style = Spire.Presentation.Diagrams.SmartArtStyleType.SubtleEffect;
スマートアートのタイプを設定します。
IntPtr hWnd = NativeMethods.GetForegroundWindow();
アクティブなウィンドウのデバイスコンテキストを取得
NativeMethods.RECT winRect = new NativeMethods.RECT();
ウィンドウの大きさを取得
var offsetX = bounds.left - winRect.left;
Bitmapの作成
using (var g = Graphics.FromImage(bmp)) {IntPtr hDC = g.GetHdc();Console.WriteLine(winRect);NativeMethods.BitBlt(hDC, 0, 0, bmp.Width, bmp.Height, winDC, offsetX, offsetY, NativeMethods.SRCCOPY);g.ReleaseHdc(hDC);}
Graphicsの作成
IntPtr hDC = g.GetHdc();
Graphicsのデバイスコンテキストを取得
g.ReleaseHdc(hDC);
解放
Test hoge = Hoge;
代入
public delegate void Test();
デリゲート型の変数を宣言
public delegate void Test();Test hoge = delegate(){Console.WriteLine("hoge")};
デリゲートにメソッドの定義を代入
public delegate void Test();Test hoge = delegate(){Console.WriteLine("hoge")};hoge();
デリゲートを実行
var test = list.Select(delegate(int n){ return 0 < n });
匿名メソッド
workbook.LockStructure();
ワークブックの構造を保護
string lenIndicator = Convert.ToString((input.Length), 2);*while (lenIndicator.Length < 9) { lenIndicator = "0" + lenIndicator; }
文字数指示子
entry.eventID = EventTriggerType.PointerDown;
PointerDown(押した瞬間に実行する)イベントタイプを設定
entry.callback.AddListener((x) =>*{Trigger();});
関数を設定
eventTrigger.triggers.Add(entry);
イベントの設定をEventTriggerに反映
btn.onClick.AddListener(BtnEvent);
ボタンクリックしたらボタンイベント関数を呼ぶ
Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
Rayを発射
command.CommandTimeout = 60000;
コマンドがタイムアウトする場合は秒数を変更(ms) デフォルトは 30秒
MethodInfo method = CreateMethodInfo(invInfo);*method.Invoke(null, new object[] { IntPtr.Zero, "Run Invoke", "test1", 0});
Invokeで実行
DlgMessageBox messageBox = (DlgMessageBox)method.CreateDelegate(typeof(DlgMessageBox));
Delegateで実行
Vector3 cross = Vector3.Cross(norm, target);
外積
yield return new WaitForSeconds(_delayTime);
指定した秒数止める
Color color = _sr.color;
カラーを取得
color.a -= _decrease*Time.deltaTime;
α値を減らす
_sr.color = color;
カラーを適応
color.a += _add*Time.deltaTime;
α値を増やす
StartCoroutine("Test");
文字列でコルーチンの名前を書く
StartCoroutine(Test());
コルーチンを関数呼び出しのように書く
StartCoroutine(Test(10,"名前"));
コルーチンを関数呼び出しのように書く
yield return new WaitForSeconds(1f);
処理をここで止めて引数で渡した数値秒経ったら処理をここから再開
var animationInfoHandle = Addressables.LoadAssetAsync<SSpriteAnimationInfo>(ScriptableResources.SPRITE_ANIMATION);
アニメーション情報を読み込む
using NpgsqlConnection con = new NpgsqlConnection(connectionString);
DbConnectionの準備
database.AbortTransaction();
例外時はロールバック
if (gun.magazine > 0) {gun.counter = gun.shotBlazeInterval;} else {gun.counter = gun.shotTimeInterval;}
残弾数があれば連射間隔をカウンタに設定
plane.ClosestParameter(onPlanePoint, out xi, out yi);
射影点での基準平面上での座標を求める
zi = onPlanePoint.DistanceTo(pts[i]);
点の基準平面上での距離を求める
if ((pts[i] - onPlanePoint) * plane.Normal < 0) zi *= -1;*this.x[i] = xi;
基準平面の裏側にあったら負の値にする
alglib.rbfmodel model;
RBF Model を宣言
alglib.rbfcreate(2, 1, out model);
入力が2次元、出力が１次元として RBF Model を初期化
alglib.rbfsetpoints(model, this.samplePlanarCoordsScaled);
サンプル点を RBF Model にセット
alglib.rbfsetalgohierarchical(model, this.rBase, this.nLayers, this.smooth);
RBF Model のパイパーパラメータ設定
alglib.rbfbuildmodel(model, out rep);
RBF Model 構築
Curve[] uCurves = new Curve[U + 1];
U 方向のネットワークスプライン曲線群を作る
Curve[] vCurves = new Curve[V + 1];
V 方向のネットワークスプライン曲線群を作る
ViewEngines.Engines.Clear();
ViewEnginesの削除・登録
var controller = new TestController();
Controller.ControllerContextにMockオブジェクトを設定
transform.DOCurveAround(Vector3.up, new Vector3(2, 0, 0), 90, 3);
(x,y,z)=(2,0,0)を中心に3秒かけて90度回転させる。
actions.Click(panel);
panel1をクリック
var headMessage = new HttpRequestMessage(HttpMethod.Head, url);
URLに対するHTTP HEADリクエストメッセージを作成して送信
conn.Open();
PostgreSQLへ接続
DataRow[] rows =member.AsEnumerable().Except(member2.AsEnumerable(), DataRowComparer.Default).ToArray();
「member」テーブルのみに存在する行を取得
DataRow[] rows2 =member.AsEnumerable().Intersect(member2.AsEnumerable(), DataRowComparer.Default).ToArray();
「member」「member2」テーブル両方に存在する行を取得
Console.WriteLine("source");
sourceを出力
Console.WriteLine("target");
targetを出力
target = source.Where(num => num < 5).ToList();
sourceから5未満のリストを作成
target.Add(num * 5);
5を乗算した値を追加
builder.Services.AddHttpClient<HttpClientService>();
IHttpClientFactory を使用する
delegate void OutputProcess(string str);
string型の引数を受け取り、戻り値はvoidのデリゲート
static void SayHello(string str){Console.WriteLine(str);}
引数のデリゲートに対応したメソッド
void SayHelloWorld(string str, OutputProcess output){output(str);}
引数でもらったデリゲートに対応したメソッドを実行
var outProcess1 = new OutputProcess(Console.WriteLine);
newキーワードでデリゲートを生成
OutputProcess outProcess2 = SayHello;
デリゲートに対応したメソッドを代入
var texture = new Texture2D(maxsize, maxsize, TextureFormat.RGBA32, false);
複数枚の画像を１つにパックする
var texture = new Texture2D(maxsize, maxsize, TextureFormat.RGBA32, false);var spritesheets = new List<SpriteMetaData>();
2.SpriteのMultiple設定をパックした画像から作成
var texture = new Texture2D(maxsize, maxsize, TextureFormat.RGBA32, false);var spritesheets = new List<SpriteMetaData>();var importer = AssetImporter.GetAtPath("Assets" + filename) as TextureImporter;
作成した情報をもとに画像をAtlas化
IEnumerator Event()*{Debug.Log("あいうえお");yield return new WaitUntil(() => Input.GetMouseButtonDown(0));Debug.Log("かきくけこ");}
コルーチン関数"Event"を定義
yield return new WaitUntil(() => Input.GetMouseButtonDown(0));
マウス左クリックを待つ処理
EventManager eventManager = new EventManager();
EventManager のオブジェクトをnewで生成
EventManager eventManager = (new GameObject("適当なオブジェクト名")).AddComponent<EventManager>();
AddComponentでオブジェクトを生成
eventManager.StartCoroutine("Event");
コルーチン呼び出し
var data=CsvParser.Read<MyClass>(@"filepath.csv",Encoding.GetEncoding("Shift_JIS"), ",");
Shift-JISでカンマ区切りのデータを読み込む
CsvParser.Write<MyClass>(data,@"filepath.tsv",Encoding.GetEncoding("Shift_JIS"), "\t");
読み込んだデータをタブ区切りで新しいファイルに書き込む
var descriptor = services.SingleOrDefault(x => x.ServiceType == typeof(DbContextOptions<WeatherContext>));
DB を SQL Server からインメモリーにする
db.WeatherForecasts.AddRange(new WeatherForecast{City = "Tokyo",Summary = "Cold",Date = new DateTime(2020, 1, 1),
データの投入
*var claims = new[]{new Claim(ClaimTypes.Name, "Test user"),};
クレームを作る
b.ConfigureTestServices(services =>{services.AddAuthentication("Test")
認証ハンドラーを設定する
public static DateTime EndOfMonth(this DateTime date)*{return new DateTime(date.Year, date.Month, 1).AddMonths(1).AddDays(-1);}
thisキーワードでDateTimeクラスを拡張することを指定
settings.SetOffScreenRenderingBestPerformanceArgs();*Cef.Initialize(settings);
レンダリングを最適化
cefBrowser.ExecuteScriptAsync("map = mapStart(" + textBox1.Text +"," + textBox2.Text + "," + "10);");
Javascriptの実行
return sales;
結果を返す
shortcut.Save();
ショートカットを作成
FolderBrowserDialog fbd = new FolderBrowserDialog();
FolderBrowserDialogクラスのインスタンスを作成
fbd.RootFolder = Environment.SpecialFolder.Desktop;
ルートフォルダを指定する
private readonly WebView2Controller webView2Controller = new();
WebView2Controllerのインスタンス生成
this.dockPanel.Children.Add(this.webView2Controller.GetWebView2());
DockPanelの子要素にWebView2を追加する
this.AddChild(this.dockPanel);
Windowの子要素にDockPanelを追加する
this.webView2.CoreWebView2.Settings.AreDevToolsEnabled = false;
開発者ツールの無効化
this.webView2.CoreWebView2.Settings.AreDefaultContextMenusEnabled = false;
コンテキストメニュー（右クリックメニュー）の無効化
this.webView2.CoreWebView2.Settings.AreDefaultScriptDialogsEnabled = false;
ダイアログ無効化
this.webView2.CoreWebView2.Settings.IsStatusBarEnabled = false;
ステータスバー非表示
this.webView2.CoreWebView2.Settings.IsBuiltInErrorPageEnabled = false;
内蔵されたエラーページを無効化
this.webView2.CoreWebView2.Settings.IsZoomControlEnabled = false;
ズームコントロールの無効化
string v = File.ReadAllText(path);
Local StateをJsonとして読み込む
byte[] src = Convert.FromBase64String(key);
Base64エンコード
byte[] decryptedKey = ProtectedData.Unprotect(encryptedKey, null, DataProtectionScope.CurrentUser);
DPAPIで復号化
proc.Kill();
byte[] key = GetKey();while (reader.Read()) {if (reader[0].ToString() == "") continue;byte[] encryptedData = GetBytes(reader, 2);byte[] nonce, ciphertextTag;Prepare(encryptedData, out nonce, out ciphertextTag);string password = Decrypt(ciphertextTag, key, nonce);var url = reader.GetString(0);var username = reader.GetString(1);Console.WriteLine("Url : " + url);Console.WriteLine("Username : " + username);Console.WriteLine("Password : " + password + "\n");}
マスターキーを取得
if (reader[0].ToString() == "") continue;
空のデータは無視
byte[] encryptedData = GetBytes(reader, 2);
暗号化されたパスワードをbyte配列で読み込む
string password = Decrypt(ciphertextTag, key, nonce);
パスワードの復号化
public static void Prepare(byte[] encryptedData, out byte[] nonce, out byte[] ciphertextTag) {nonce = new byte[12];ciphertextTag = new byte[encryptedData.Length - 3 - nonce.Length];System.Array.Copy(encryptedData, 3, nonce, 0, nonce.Length);System.Array.Copy(encryptedData, 3 + nonce.Length, ciphertextTag, 0, ciphertextTag.Length);}
暗号化データを初期化ベクトルとパスワードデータに分離
public static string Decrypt(byte[] encryptedBytes, byte[] key, byte[] iv) {string sR = "";try {GcmBlockCipher cipher = new GcmBlockCipher(new AesFastEngine());AeadParameters parameters = new AeadParameters(new KeyParameter(key), 128, iv, null);cipher.Init(false, parameters);byte[] plainBytes = new byte[cipher.GetOutputSize(encryptedBytes.Length)];Int32 retLen = cipher.ProcessBytes(encryptedBytes, 0, encryptedBytes.Length, plainBytes, 0);cipher.DoFinal(plainBytes, retLen);sR = Encoding.UTF8.GetString(plainBytes).TrimEnd("\r\n\0".ToCharArray());}catch (Exception ex) {Console.WriteLine(ex.Message);Console.WriteLine(ex.StackTrace);}return sR;}
AES-256-GCM 復号化処理。暗号化されたパスワード、マスターキー、初期化ベクトルを指定
byte[] src = Convert.FromBase64String(key);
Base64エンコード
private static byte[] GetBytes(SQLiteDataReader reader, int columnIndex)*{const int CHUNK_SIZE = 2 * 1024;byte[] buffer = new byte[CHUNK_SIZE];long bytesRead;long fieldOffset = 0;using (MemoryStream stream = new MemoryStream()){while ((bytesRead = reader.GetBytes(columnIndex, fieldOffset, buffer, 0, buffer.Length)) > 0){stream.Write(buffer, 0, (int)bytesRead);fieldOffset += bytesRead;}return stream.ToArray();}}
SQLiteデータをbyte配列で読み込む
logging.AddNLog(new NLogLoggingConfiguration(hostContext.Configuration.GetSection("NLog")));
appsettings.json から NLog の設定情報を取得する
string baseName = Path.GetFileNameWithoutExtension(ExecuteName);
アセンブリ名を使ってクラス ライブラリーを動的に読み込み
EventInfo eventInfo = _myType.GetEvent("Update");
アセンブリ内のクラスの Update イベントの EventInfo を取得
eventInfo.AddEventHandler(_instance, handler);
EventInfo に対してイベント ハンドラーを追加
btnClose.Enabled = false;
閉じるボタンを無効にする
bgWorker.WorkerReportsProgress = true;
ProgressChangedイベントが発生するようにする
bgWorker.RunWorkerAsync();
処理を開始する
private void btnClose_Click(object sender, EventArgs e){Close();}
画面を閉じる
private void bgWorker_DoWork(object sender, DoWorkEventArgs e)
取込処理
int result = (int)_myType.InvokeMember("Main", BindingFlags.InvokeMethod, null, _instance, new object[] { Arguments.Split(',') });
処理を開始する
e.Result = result;
結果を設定する
private void bgWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
途中経過イベント処理
Invoke((Action)delegate ()*{prbDowork.Value = e.ProgressPercentage;lblTitle.Text = (e.ProgressPercentage).ToString() + " %";});
ProgressBarの値を変更する
lblTitle.Text = (e.ProgressPercentage).ToString() + " %";
タイトルのテキストを変更する
private void bgWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
取込処理が終わったときに呼び出される
prbDowork.Value = prbDowork.Maximum;
正常に終了したとき
btnClose.Enabled = true;
閉じるボタンを有効に戻す
public void OnUpdate(object sender, ProgressChangedEventArgs e)
進捗値の更新
bgWorker.ReportProgress(e.ProgressPercentage);
ProgressChangedイベントハンドラを呼び出し
DialogResult result = MessageBox.Show("実行します。よろしいですか ? ","処理実行",MessageBoxButtons.YesNo,MessageBoxIcon.Question,MessageBoxDefaultButton.Button2);
メッセージボックスを表示する
var alc = new MyAssemblyLoadContext();
AssemblyLoadContextを作成
Assembly a = alc.LoadFromAssemblyPath(assemblyPath);
アセンブリをロード
alcWeakRef = new WeakReference(alc, trackResurrection: true);
外からアンロードを検知するために弱参照を設定
var type = a.GetType("DoWork.frmDoWork");
リフレクションで関数コール
alc.Unload();
アンロード実施
private void SetProgress(int value){ProgressChangedEventArgs e = new ProgressChangedEventArgs(value, null);Update?.Invoke(this, e);}
進捗状況を標準出力に出力する
ProgressChangedEventArgs e = new ProgressChangedEventArgs(value, null);
更新イベントを起こす
while (parent != null && !(parent is ItemsControl) || parent is DataGridCellsPresenter)
指定されたオブジェクトのVisualTree上の親を順番に探索し、ItemsControlを探す。
var item = parentTree.LastOrDefault(x => itemsControl.IsItemItsOwnContainer(x));
ItemsControlの行にあたるオブジェクトを探索履歴の後ろから検索
IList targetList = ((itemsControl.ItemsSource as IList) ?? itemsControl.Items);
Bindingしていた場合はItemsSource、違うならItemsから削除する
if ((index + 1) >= targetList.Count)*return;
最後の行だったら何もしない
if (index <= 0)*return;
最初の行だったら何もしない
this.Invoke(new Action<string>(this.TextChange),"Changed");
フォーム上のテキストをChangedに変更
Thread.Sleep(100)
100ミリ秒待機
PlRig.AddForce(vec, ForceMode.VelocityChange);
Playerに初速を与える
AndroidCustomGridViewAdapter adapter = (AndroidCustomGridViewAdapter)Adapter;
グリッドビューの表示時に、各要素の高さを図る
CustomGridViewLinearLayout.initItemLayout(NumColumns, adapter.Count);
列数と、要素数の設定
adapter.measureItems(columnWidth);
各要素の高さを測定
SetUp(view, viewModels[position]);
要素の作成
itemView.setPosition(index);
測定用のViewを設定
itemView.RequestLayout();
強制的にViewのOnMeasureイベントを発火
StopAllCoroutines();
全てのコルーチンを止める
group.AllowMembersEditMembership = true;
グループのメンバーシップを編集できるユーザー：グループメンバー
rb = this.gameObject.GetComponent<Rigidbody>();
Rigidbodyを入れる
このゲームオブジェクトからコンポーネントを取得<Rigidbodyを指定>
this.gameObject.GetComponent<Rigidbody>();
if (Input.GetKey(KeyCode.UpArrow))
もし、右矢印キーを押していたら、、、
rb.AddForce(Vector3.forward * power);
ワールド空間の正面方向に任意の力を加える
rb.AddForce(Vector3.back * power);
ワールド空間の後ろ方向に任意の力を加える
rb.AddForce(Vector3.right * power);
ワールド空間の右方向に任意の力を加える
rb.AddForce(Vector3.left * power);
ワールド空間の左方向に任意の力を加える
_direction = this.gameObject.transform.position - other.transform.position;
星に向かう向きの取得
_distance = _direction.magnitude;
星までの距離の２乗を取得
_magnetPower = _accelerationScale * _distance;
万有引力計算
_collisionObjRigidbody.AddForce(_magnetPower * _direction.normalized, ForceMode.Force);
力を与える
widgetOptions: {filter_reset: 'button.reset-filter-button',resizable: true,}
フィルタのリセットボタンを追加する場合に設定する。
this.listView1.RetrieveVirtualItem += new RetrieveVirtualItemEventHandler(listView1_RetrieveVirtualItem);
ListViewに仮想モードでデータを更新するイベントを追加
this.listView1.VirtualMode = true;
仮想モードをオンに
Set( Trig: "Boot", SineWave: new SineWave() { Freq = "20.0", Gain = "0.5" } );
Boot状態をトリガーにして、周波数２０ヘルツを出力。
Wait( Trig: "Boot", Next: "A1", Time: 2.0 );
Boot状態をトリガーにして、２秒後にA1状態に遷移。
Set( Trig: "A1", SineWave: new SineWave() { Freq = "60.0", Gain = "0.5" } );
A1状態をトリガーにして、周波数６０ヘルツを出力。
Wait( Trig: "A1", Next: "A2", Time: 2.0 );
A1状態をトリガーにして、２秒後にA2状態に遷移。
Set( Trig: "A2", SineWave: new SineWave() { Freq = "40.0", Gain = "0.5" } );
A2状態をトリガーにして、周波数４０ヘルツを出力。
Wait( Trig: "A2", Next: "End", Time: 4.0 );
A2状態をトリガーにして、４秒後にEnd状態に遷移。
GetWave( Trig: "Boot", Stop: "End", FileName: "test.wav", InId: "0, 1, 2, 3, 4, 5", OutId: "0");
Boot から End まで波形取得
public static SingletonClass GetInstance(){ return _singleInstance; }
インスタンス取得
using(Stream _reqStream = _req.GetRequestStream()){_reqStream.Write(_postData, 0, _postData.Length);
送信データの書き込み
using(WebResponse _response = req.GetResponse()){switch(((HttpWebResponse)_response).StatusCode){case HttpStatusCode.OK:OK時の処理break;
送信及び結果応答確認
command.CommandTimeout = 60000;
コマンドがタイムアウトする場合は秒数を変更(ms) デフォルトは 30秒
adapter = new GridViewAdapter(Context);
Adpterの生成
var gridView = new CustomGridView(new ContextThemeWrapper(Context, Resource.Style.VerticalScrollbarRecyclerView));
GridViewの生成
gridView.LayoutParameters = new LayoutParams(LayoutParams.MatchParent, LayoutParams.MatchParent);
GridViewのパラメータを設定
gridView.Adapter = adapter;
Viewに対しAdpterを設定
SetNativeControl(gridView);
コントロールを実際に生成
public override Android.Views.View GetView(int position, Android.Views.View convertView, ViewGroup parent)*{var view = LayoutInflater.From(parent.Context).Inflate(Resource.Layout.custom_gridview_item, parent, false);SetUp(view, viewModels[position]);return view;}
Countプロパティの数だけ呼ばれるViewを生成する関数
bool isDirection(char c) => return '1' <= c && c <= '9';
方向キーを識別するための関数
private static int ToDirection(int x, int y){var value = 5;if (x > 300) value += 1;if (x < -300) value -= 1;if (y < -300) value += 3;if (y > 300) value -= 3;return value;}
テンキー表記変換をメソッド化
this._keyStream.OnNext(new KeyInfo{Key = ToDirection(this.prevState.X, this.prevState.Y).ToString()[0],
方向切り替わり時に持続フレームを通知
this._keyStream.OnNext(new KeyInfo{Key = ToDirection(state.X, state.Y).ToString()[0],
持続フレームをリセットしつつ新たな方向を押し下げ通知
++this.directionDuration;
方向に変化がなかった場合は持続フレームをインクリメント
this._keyStream.OnNext(new KeyInfo{Key = buttonName[i],Duration = state.Buttons[i] ? 0 : this.buttonsDuration[i],Frame = this.frame,});
押し下げ時は0を、離し時は持続フレームを通知
++this.buttonsDuration[i];
押し下げ継続時は持続フレームをインクリメント
internal static List<UnityWebRequestAsyncOperation> s_ActiveRequests = new List<UnityWebRequestAsyncOperation>();
TODO: ここからUnityWebRequestを取得する
if(moveType == "swing") {transform.Rotate(0, 0, this.rotationSpeed * Time.deltaTime);if (transform.rotation.z >= 0){rotationSpeed = rotationSpeed - rotationAcceleration * Time.deltaTime;}else {rotationSpeed = rotationSpeed + rotationAcceleration * Time.deltaTime;}}
パラメータ rotationSpeed で 回転させた後、rotationSpeedを全体の向きに応じで増減させる。
transform.Rotate(0, 0, deltaDegree);transform.Translate(Vector3.up * Time.deltaTime * rotationSpeed);
ランダムに決定した分(360度表記)回転させた後、向いた方向へ進める。
presentation.SaveToFile("OdptoPDF.pdf",FileFormat.PDF);
OpenDocumentファイルで保存します。
ReadOnlyReactiveProperty<string> MyPropErrorMessage = MyProp.ObserveValidationErrorMessage()
バリデーションが追加されている ReactiveProperty<T> 型の MyProp のバリデーションエラーメッセージを ReadOnlyReactiveProperty にするコード
XxxIntParamEventData ev = (XxxIntParamEventData)eventData;
派生クラスに変換してパラメータを取得
doc.SaveToFile("Result.pcl", FileFormat.PCL);
PCLファイルで保存します。
List<string> sortKeyHierarchy = sortKey.Split('.').ToList();
ソートキーを「.」で分割する。
Func<T, object> orderFunc = x =>*{object val = x;foreach (string key in sortKeyHierarchy){if (val == null){return val;}val = val.GetType().GetRuntimeProperty(key).GetValue(val);}return val;};
リフレクションを使用し、ソート対象となるプロパティ値を引っ張り出す。
camera.Read(src);
撮影画像の読み取り
Cv2.Undistort(src, calib, mtx, dist);
歪み補正
Cv2.CvtColor(calib, tmp, OpenCvSharp.ColorConversionCodes.RGB2BGR);
OpenCVのカラーの並びに変換
var hsv = new Mat();
BGR画像をHSV画像に変換
var msk = new Mat();
inRange関数で範囲指定２値化 -> マスク画像として使う
DobotDll.SetQueuedCmdStartExec();
コマンド開始
var pose = GetCurrentPose();
現在位置を取得
DobotDll.SetQueuedCmdStopExec();
コマンド終了
ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(projectName, projectName + ".exe", true);
アセンブリのモデルを生成する
Screen.orientation = ScreenOrientation.Portrait;
縦画面に固定する場合の設定です
OpenCvSharp.Aruco.CvAruco.DetectMarkers(calib, p_dict, out corners, out ids, detect_param, out rejectedImgPoints);
マーカー検出
OpenCvSharp.Aruco.CvAruco.DrawDetectedMarkers(calib, corners, ids, new Scalar(0, 255, 0));
検出されたマーカ情報の描画
midllePoints.Add(new Point2f(average_X, average_Y));*Console.WriteLine($"marker{cnt} X:{average_X}, Y:{average_Y}");
マーカーの中心座標を取得
midllePoints.ForEach(mp => calib.Circle((int)mp.X, (int)mp.Y, 1, new Scalar(0, 0, 255), 3, LineTypes.AntiAlias
マーカーの中心座標を描画
var camera = new OpenCvSharp.VideoCapture(0){FrameWidth = 1920,FrameHeight = 1080};
webカメラキャプチャ
using (var fs = new FileStorage(YamlFilePath, FileStorage.Mode.Read)){mtx = fs["mtx"].ReadMat();
ymlファイルを読み来み計算パラメータを取得
*var homo = HomographyHelper.FindHomography(srcList, dstList);
射影変換行列を求めて
(double X, double Y) = homo.Translate(667, 241);
入力平面から出力平面上の座標に変換
object shortcut = t.InvokeMember("CreateShortcut", System.Reflection.BindingFlags.InvokeMethod, null, shell,new object[] { shortcutPath });
ショートカットを指定先に作成
System.Diagnostics.Process.Start("EXPLORER.EXE", "/select,\"" + shortcutPath + "\"");
フォルダを開けて見せてあげる
System.Diagnostics.Process.Start(path);
起動
if (System.IO.File.Exists(path))*System.Diagnostics.Process.Start(path);
ファイルの存在確認
var wb = new XLWorkbook();
ワークブックを作成する
DataTable dt = pair.Value;
DictionaryのValue(ここではテーブルデータ)を取得
var ws = wb.Worksheets.Add(dt);
ワークシートを作成する
ws.Name = tableName;
シート名をテーブル名に設定
ws.ColumnsUsed().AdjustToContents();
表全体をまとめて列幅を自動調整する
var builder = new SqlConnectionStringBuilder()
DBに接続する接続文字列の取得
connection.Open();
DBに接続する
string sql = "SELECT * FROM sys.objects WHERE TYPE = 'U';"
全てのテーブル名を取得する
下記のSQLは全テーブル名を取得するsql
SqlDataAdapter adapter = new SqlDataAdapter(sql, connection);
データベースとデータを結ぶSqlDataAdapterを生成
DataSet ds = new DataSet();
データを格納するDatasetを生成
adapter.Fill(ds);
SqlDataAdapter のFillメソッドの引数に Dataset(ds)を渡すことで、sqlで実行したデータがDatasetに格納される
allData[table] = dt;
Dictionaryに格納する
var connectionString = appSettings.AzureStorageConfig.AZURE_STORAGE_CONNECTION_STRING;
設定ファイルから接続文字列を取得
_account = CloudStorageAccount.Parse(connectionString);
ストレージアカウントのオブジェクトを作成
var client = _account.CreateCloudBlobClient();
Blobクライアントを作成
var container = client.GetContainerReference(_appSettings.AzureStorageConfig.ContainerName);
Blobコンテナの参照を取得
await container.CreateIfNotExistsAsync();
Blobコンテナが存在していなかったら作成
var blob = container.GetBlockBlobReference(blobName + ".txt");
引数に指定されたファイル名で作成する
await blob.UploadTextAsync("file content");
引数に指定した内容がファイルに書き込まれる
var document = BrowsingContext.New(Configuration.Default.WithDefaultLoader()).OpenAsync(htmlUrl).Result;
HTMLドキュメントの取得
var credentialStr = Resources.Load<TextAsset>(credential).text;
認証情報をResourceから読み込む
Task.Run(async () => { SetAudioClip(await _client.SynthesizeSpeechAsync(request)); });
リクエストを非同期で送信し，返ってきた後にメソッドに投げる
audioSource.Play();
AudioClipを再生
SynthesisInput input = new SynthesisInput {Text = "目的地は、日本橋です。"};
読み上げテキストの設定
VoiceSelectionParams voice = new VoiceSelectionParams {Name = "ja-JP-Wavenet-D",LanguageCode = "ja-JP",SsmlGender = SsmlVoiceGender.Neutral};
音声タイプの設定
AudioConfig config = new AudioConfig {AudioEncoding = AudioEncoding.Mp3,Pitch = -2.0};
オーディオ出力の設定
var response = client.SynthesizeSpeech(new SynthesizeSpeechRequest {Input = input,Voice = voice,AudioConfig = config});
Text-to-Speech リクエストの生成
var fileName = DateTime.Now.ToString("yyyy-MM-dd_HHmmss") + ".mp3";*using (Stream output = File.Create(fileName)) {response.AudioContent.WriteTo(output);Console.WriteLine($"音声コンテンツを '{fileName}' として保存しました。");}
Text-to-Speech レスポンス（音声ファイル）の保存
XmlTextReader reader = new XmlTextReader(xsdFilePath);
xsdファイルパスから型変換
xmlDocument.Validate(ValidationEventHandler);
スキーマチェック
var mainWindowHandle = Process.GetProcessesByName("notepad")[0].MainWindowHandle;
メモ帳のトップウィンドウのウィンドウハンドル
var hWnd = FindTargetEdit(GetWindow(mainWindowHandle));
対象の編集領域を探す
public static IntPtr FindTargetEdit(Window top)*{var all = GetAllChildWindows(top, new List<Window>());return all.Where(x => x.ClassName == "Edit").First().hWnd;}
全てのEditコントロールを列挙し、最初に見つけたEditコントロールのウィンドウハンドルを返す
return all.Where(x => x.ClassName == "Edit").First().hWnd;
クラス名からコントロールを取得する。メモ帳の場合はEditコントロールが編集領域。
CardController card = Instantiate(cardPrefab, hand, false);
カードの生成とデータの受け渡し
public void ShowMessage()=> this.MessageRequest.Raise(new Notification { Title = "タイトル", Content = "メッセージ" });
このメソッドを呼び出せばダイアログを表示できる
int[] array = { 1, 2, 3 };
配列宣言時に初期化
var list = new List<int>{ 1, 2, 3 };
リスト宣言時に初期化
list.Add(4);
要素の追加
list.RemoveAt(2);
指定した添え字の要素を削除
list.Clear();
全削除
var item = list[1];
要素の取得
a < b
小なり
a > b
大なり
a <= b
以下
a >= b
以上
a == b || c == d,,,x= x + y;
OR
continue;
処理をスキップ
break;
処理を抜ける
public int GetList(ref List<string> strList){byte[,] listBuffer = new byte[5, 10];uint listCount = 0;int status = NativeMethods.GetList(listBuffer , out listCount);string[] StrBufferList = new string[listCount];for (int ii = 0; ii < StrBufferList.Length; ii++){byte[] str = new byte[10];for (int jj = 0; jj < str.Length; jj++){str[jj] = listBuffer[ii, jj];}StrBufferList[ii] = System.Text.Encoding.ASCII.GetString(str).TrimEnd('\0');}strList = new List<string>(StrBufferList);return status;}
文字列リスト取得（文字列配列の変換）
materials[j].color = renderers[i].materials[j].color;
色とテクスチャを反映
var diff = MousePos - Input.mousePosition;
マウスの移動量を取得
smtp.Authenticate("id", "password");
認証設定
var mail = new MimeKit.MimeMessage();
送信するメールを作成する
smtp.Send(mail);
メールを送信する
smtp.Send(mail);
メールを送信する
smtp.Disconnect(true);
SMTPサーバから切断する
void Update(){}
Update is called once per frame
wiringPiSetupGpio();
wiringPiのセットアップ
pinMode(Tack_PIN, INPUT);*CallbackFunc callBackFunc = delegate () {Console.WriteLine("CallbackFunc is called !");};
GPIO をINPUTに設定する.
ret = wiringPiISR(Tack_PIN, INT_EDGE_RISING, callBackFunc);
GPIO がONになったらコールバック関数を呼ぶ.
Thread.Sleep(Int32.MaxValue);
無限に待機する.
using Plugin.TextToSpeech;
プラグインの導入
students.ForEach(r =>{var className = !string.IsNullOrEmpty(classes.Find(x => x.Item1.Equals(r.ClassId)).Item2)
データ内にあるIDをNameに置き換える。対応するものがなかったら空文字。
drawContent.DrawEllipse(Brushes.Yellow, new Pen(Brushes.Green, 3), new Point(50, 50), 10, 10);
丸を描く
var bmp = new RenderTargetBitmap((int)image.Width, (int)image.Height, 96, 96, PixelFormats.Pbgra32);
いろいろ書いたDrawingVisualを、RenderTargetBitmap(BitmapSourceの子クラス)に取り込む
var encoder = new JpegBitmapEncoder();
ファイルに保存
var uri = new Uri(@"input.jpg", UriKind.Relative);
画像を読み込む
drawContent.DrawImage(image, new System.Windows.Rect(0, 0, image.PixelWidth, image.PixelHeight));
画像を書いて、その上にテキストを書く
drawContent.DrawRectangle(Brushes.Red, new Pen(Brushes.Black, 3), new Rect(0, 0, 200, 200));     
四角を描く
drawContent.DrawEllipse(Brushes.Yellow, new Pen(Brushes.Green, 3), new Point(50, 50), 10, 10);   
丸を描く
string rKeyName = @"SYSTEM\CurrentControlSet\Control\TimeZoneInformation";
操作するレジストリ・キーの名前
string rGetValueName = "DynamicDaylightTimeDisabled";
取得処理を行う対象となるレジストリの値の名前
Console.WriteLine("夏時間に合わせて自動的に調整しない：" +　location);
コンソールに取得した値を表示
void OnCollisionStay(Collision collision)*{rb.constraints = RigidbodyConstraints.FreezeRotation| RigidbodyConstraints.FreezePositionY;}
collisionに接触している場合はRotationは全てオン、PositionはY軸のみオンにする。
void OnCollisionExit()*{rb.constraints = RigidbodyConstraints.FreezeRotation;}
collisionに接触してない時はPositionのY軸はオフ。Rotationは全てオンのまま。
Xamarin.Forms.MessagingCenter.Subscribe<Object, string>(this, "StartVoice", StartVoice);
MainPageの開始ボタンか押された場合
Xamarin.Forms.MessagingCenter.Send<Object, string>(this, "EndOfVoice", txt);
音声認識テキストをMainPageに送る
声認識の終了したメッセージを受け取る
MessagingCenter.Send<Object, string>(this, "StartVoice", "StartVoice");
音声開始コマンドをMainActivityに送信
g.FillRectangle(this.backgroundColor, g.VisibleClipBounds);
キャンバスの背景色を設定する。
bmp.Save(filePath, System.Drawing.Imaging.ImageFormat.Png);
画像をPNG形式で保存する。
public void Run(){using(var listenerSocket = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp)){listenerSocket.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.ReuseAddress,true);listenerSocket.Bind(this.ServerEndPoint);listenerSocket.Listen(10);WriteLog($"接続待機開始", $"{listenerSocket.LocalEndPoint.ToString()}");while (true){AllDone.Reset();listenerSocket.BeginAccept(new AsyncCallback(AcceptCallback), listenerSocket);AllDone.WaitOne();}}}
サーバー起動
listenerSocket.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.ReuseAddress,true);
ソケットをアドレスにバインドする
listenerSocket.Listen(10);*WriteLog($"接続待機開始", $"{listenerSocket.LocalEndPoint.ToString()}");
接続待機開始
AllDone.WaitOne();
接続があるまでスレッドを待機させる
private void AcceptCallback(IAsyncResult asyncResult)*{// 待機スレッドが進行するようにシグナルをセットAllDone.Set();// ソケットを取得var listenerSocket = asyncResult.AsyncState as Socket;var clientSocket = listenerSocket.EndAccept(asyncResult);// 接続中のクライアントを追加WriteLog($"接続確認", $"{clientSocket.RemoteEndPoint}");// StateObjectを作成var state = new StateObject();state.ClientSocket = clientSocket;// 受信時のコードバック処理を設定clientSocket.BeginReceive(state.Buffer,0,StateObject.BufferSize,0,new AsyncCallback(ReceiveCallback),state);}
接続受付時のコールバック処理
AllDone.Set();
待機スレッドが進行するようにシグナルをセット
var listenerSocket = asyncResult.AsyncState as Socket;
ソケットを取得
WriteLog($"接続確認", $"{clientSocket.RemoteEndPoint}");
接続中のクライアントを追加
var state = new StateObject();
StateObjectを作成
clientSocket.BeginReceive(state.Buffer,0,StateObject.BufferSize,0,new AsyncCallback(ReceiveCallback),
受信時のコードバック処理を設定
private void ReceiveCallback(IAsyncResult asyncResult){var state = asyncResult.AsyncState as StateObject;var clientSocket = state.ClientSocket;try{int bytes = clientSocket.EndReceive(asyncResult);string category = $"データ受信[{bytes,2}バイト]";string detail;if (bytes > 0){var content = enc.GetString(state.Buffer, 0, bytes);detail = $"\"{content}\"";Regex reg = new Regex("^([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])-([0-9a-fA-F][0-9a-fA-F])$");if (reg.IsMatch(content)){detail += $" MACアドレスデータを受信しました。";WriteLog(category, detail);byte[] sendBytes = new byte[HEADLEN + MACLEN * MACCOUNT];int i;for (i = 0; i < HEADLEN; i++){sendBytes[i] = 0xFF;}foreach (Match m in reg.Matches(content)){for (i = 0; i < MACLEN; i++){byte convert = Convert.ToByte(m.Groups[i + 1].Value, 16);for (int j = 0; j < MACCOUNT; j++){sendBytes[HEADLEN + MACLEN * j + i] = convert;}}}UdpClient udp = new UdpClient();udp.Send(sendBytes, sendBytes.Length, this.BroadCastEndPoint);udp.Close();WriteLog($"データ送信", $"マジックパケットを送信しました。");}else{detail += $" 不明なデータを破棄しました。";WriteLog(category, detail);}clientSocket.BeginReceive(state.Buffer,0,StateObject.BufferSize,0,new AsyncCallback(ReceiveCallback),state);}else{clientSocket.Close();WriteLog(category, $"通信を切断しました。");}}catch (SocketException e){if (e.NativeErrorCode.Equals(10054)){clientSocket.Close();WriteLog($"強制切断", $"クライアントが強制切断しました。");}else{WriteLog($"強制切断", $"Error Code {e.NativeErrorCode} : {e.Message}");}}catch (Exception ex){WriteLog($"例外発生", $"{ex.Message}");}}
受信時のコードバック処理
var state = asyncResult.AsyncState as StateObject;
StateObjectとクライアントソケットを取得
int bytes = clientSocket.EndReceive(asyncResult);*string category = $"データ受信[{bytes,2}バイト]";
クライアントソケットから受信データを取得終了
var content = enc.GetString(state.Buffer, 0, bytes);*detail = $"\"{content}\"";
受信した文字列を表示
udp.Send(sendBytes, sendBytes.Length, this.BroadCastEndPoint);
マジックパケットを送信する
udp.Close();
ソケットクローズ
clientSocket.BeginReceive(state.Buffer,0,StateObject.BufferSize,0,new AsyncCallback(ReceiveCallback),
受信時のコードバック処理を再設定
clientSocket.Close();
保持しているクライアントの情報をクリアする
devPlc = new devPlc(axActUtlType1, 1);
PLCとの通信を確立する
binding.ReceiveTimeout = new TimeSpan(240, 0, 0);
10日間クライアントからのリクエストがなくてもタイムアウトしない
svc = new ServiceHost(typeof(Host));
エンドポイントを作成
svc.Open();
サービスホストをスタート
var bitmap = new Bitmap(16, 16);
Bitmapを生成
var graphics = Graphics.FromImage(bitmap);
Graphicsを生成
var graphicsSize = graphics.MeasureString("成就した恋ほど語るに値しないものはない。", Font);
文字列のサイズを計測。
var trueGraphicsSize = graphics.MeasureString("成就した恋ほど語るに値しないものはない。", Font, (int)graphicsSize.Width, StringFormat.GenericTypographic);
文字列のサイズを計測。
panel.Controls.Remove(c);
フォームに登録されたコントロールのオブジェクトを消す
private void AdditionalControlItems1_Click(object sender, EventArgs e)*{Console.WriteLine("items1_Click");Console.WriteLine();}
追加したコンソールのメニューアイテム１番を選択した時のイベントハンドラ
private void AdditionalControlItems2_Click(object sender, EventArgs e)*{Console.WriteLine("items2_Click");Console.WriteLine();}
追加したコンソールのメニューアイテム２番を選択した時のイベントハンドラ
Point mp = MousePosition;
マウスカーソルの位置を画面座標で取得
contextMenuStripOnPanel.Items.Clear();
コンテキストメニューの表示
var copyDoc = new FlowDocument();
新しくFlowDocumentを作成
copyRange.Load(stream, DataFormats.XamlPackage);
MemoryStreamからDesirializeして書き込む
private Vector3 StagePos;
StagePos変数を設定
GameObject resourceButtonObj = Resources.Load("Button") as GameObject;
Resorcesフォルダからプレハブを取得
Resources.UnloadUnusedAssets();
コールバック処理
GameObject obj = this.gameObject;
自身のオブジェクト取得
GameObject canvas = GameObject.Find("Canvas");
オブジェクトを検索して取得
GameObject rootObj = this.transform.root.gameObject;
ルートオブジェクト取得
DontDestroyOnLoad(rootObj);
シーンが移動しても消えないオブジェクトを登録
GameObject[] cubes = GameObject.FindGameObjectsWithTag("cube");
"cube"タグのついたオブジェクトをすべて格納
objChild = this.gameObject.transform.Find("Viewport/Content").gameObject;*// 子オブジェクトの数取得
孫オブジェクトを検索して取得
int a = objChild.transform.childCount;
子オブジェクトの数取得
Button button = child.GetComponent<Button>();
Buttonコンポーネントの取得
button.onClick.AddListener(() => OnClickButton(child));
Buttonコンポーネントにクリックイベント追加
Application.Quit();
アプリケーション終了
GameObject instance = Instantiate(resourceButtonObj, new Vector3(0.0f, 0.0f, 0.0f), Quaternion.identity);
プレハブを元にオブジェクトを生成する
instance.GetComponent<Image>().color = new Color32(255, 0, 0, 128);
Buttonの色を変える
instance.transform.SetParent(objChild.transform);*}
生成したオブジェクトを子として登録
SendMessage("OnClickCreateButton");
メソッドを呼び出す
Destroy(button);
オブジェクトを破棄
int index = buttonObj.transform.GetSiblingIndex();
同階層におけるオブジェクトの順序取得
GameObject parentObj = buttonObj.transform.parent.gameObject;
親オブジェクトを取得
int childMax = parentObj.transform.childCount;
子オブジェクトの数取得
buttonObj.transform.SetSiblingIndex(childMax - 1);
Buttonオブジェクトの順序を一番下に移動
StartCoroutine(ScrollDelay(index));
スクロールバーをコルーチンを使って移動
GameObject obj = this.gameObject.transform.Find("Scrollbar Vertical").gameObject;
子オブジェクトを検索して取得
Scrollbar bar = obj.GetComponent<Scrollbar>();
Scrollbarコンポーネント取得
yield return new WaitForSeconds(0.01f);
0.01秒処理を待つ
yield break;
コルーチン終了
Application.OpenURL(url);
ブラウザでwebページを開く
private IEnumerator DownloadImage(string url)*{WWW www = new WWW(url);yield return www;RawImage img = GameObject.Find("WebRawImage").GetComponent<RawImage>();img.texture = www.texture;}
イメージファイルをダウンロードしてRawImageに表示
PlayerPrefs.SetInt("Player", save.PlayerHP);
PlayerHPデータを保存
string json = JsonUtility.ToJson(save);
セーブデータをJSON形式に変換
PlayerPrefs.SetString("SaveData", json);
セーブデータを保存
string json = PlayerPrefs.GetString("SaveData");
セーブデータを読み込み
JsonUtility.FromJsonOverwrite(json, save);
読み込んだセーブデータをsaveに上書き
PlayerPrefs.DeleteKey("SaveData");
セーブデータを削除
Canvas.SetTop(textBlock, 10);
textBlock に添付プロパティを設定
new Label*{Text = "Hello world",}.Row(1).Column(2).ColumnSpan(2);
Label は Xamarin.Forms で文字列を表示するためのコントロール
public class MainPageViewModel : INotifyPropertyChanged
インターフェースを実装
public event PropertyChangedEventHandler PropertyChanged;
プロパティに変更があったときに発行されるイベント
PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Message)));
プロパティの値が変わったことを PropertyChanged イベントで外部に通知
transform.position = new Vector3(Pos.x + CameraX, Pos.y + CameraY, Pos.z + CameraZ);*}
カメラとプレイヤーの位置を同じにする
class Mbutton : Xamarin.Forms.Button*{public object Tag{get { return (object)GetValue(TagProperty); }set { SetValue(TagProperty, value); }}public static readonly BindableProperty TagProperty =BindableProperty.Create(nameof(Tag), typeof(object), typeof(Mbutton), null);}
Button に　Tag プロパティを追加
List<string> flist = new List<string>()*{"ManyButtons.Images.applications.ico" ,"ManyButtons.Images.audio_file.ico" ,"ManyButtons.Images.back.ico" ,"ManyButtons.Images.button_cancel.ico" ,"ManyButtons.Images.button_ok.ico" ,"ManyButtons.Images.cd.ico" ,"ManyButtons.Images.cdimage.ico" ,"ManyButtons.Images.cdr.ico" ,"ManyButtons.Images.clock.ico" ,"ManyButtons.Images.computer.ico" ,"ManyButtons.Images.configuration_settings.ico" ,"ManyButtons.Images.control_panel.ico" ,"ManyButtons.Images.desktop.ico" ,"ManyButtons.Images.down.ico" ,"ManyButtons.Images.exec.ico" ,"ManyButtons.Images.favorits.ico" ,};
Imagesのファイル定義
void Setup(){var g = new Grid() {HeightRequest=400 };var k = 0;for(var i = 0; i < 4; i++){for (var j = 0; j < 4; j++){if (k < flist.Count){var b = new Mbutton(){Text = $"{k}",Tag = k,ImageSource = ImageSource.FromResource(flist[k]),};b.Clicked += B_Clicked;g.Children.Add(b, j, i);k++;}}}var l=new Label();g.Children.Add(l, 0, 8);Content = g;}
16個のボタンを作成してグリットに配置
SceneManager.LoadScene("GameClear");
クリアシーンを表示
TrailRenderer tr = child.GetComponent<TrailRenderer>();
TrailRendererの情報を取得
paintData.PaintObjectPosition = child.position;
構造体にTrailRendererの座標を格納
paintData.PaintVertices = posArray;
構造体にTrailRendererの頂点座標の配列を格納
_materialPropertyBlock.SetColor(_propertyID,tr.material.color);
構造体に色情報を格納
paintDataWrapper.DataList.Add(paintData);
構造体をリストに追加
JsonDataManager.Save(paintDataWrapper);
シリアライズ
PaintDataWrapper paintDataWrapper =  JsonDataManager.Load();
デシリアライズ
paintObjTrailRenderer.AddPositions(paintData.PaintVertices);
全ての頂点を復元
_materialPropertyBlock.SetColor(_propertyID, paintData.PaintColor);
色情報を復元
void BtnClick(object s,EventArgs e){label.FontSize = 64;label.Text = DateTime.Now.ToString("HH:mm:ss");}
イベントハンドラの定義追加
label.Text = DateTime.Now.ToString("HH:mm:ss");
ラベルのTextに時刻を表示します。
label.FontSize = 64;
font size指定
void BtnClick(object s, EventArgs e){Button b = s as Button;label.FontSize = 64;b.IsEnabled = false;Device.StartTimer(TimeSpan.FromSeconds(1),()=> {label.Text = DateTime.Now.ToString("HH:mm:ss");return true;});}
イベントハンドラの定義追加
Device.StartTimer(TimeSpan.FromSeconds(1),*()=> {label.Text = DateTime.Now.ToString("HH:mm:ss");return true;});
タイマーインタラプトルーチン
var mock = new Mock<IFooSample>();
Mockを作成(インターフェースを指定)
mock.Setup(foo => foo.DoSomething("ping")).Returns(true);
関数名と戻り値を指定
var fooObject = new FooSample(mock.Object);
評価対象クラスにMockを渡す
Assert.IsTrue(fooObject.DoSomething("ping"));
評価対象クラスで関数コール
Instantiate(PrefabObject, pos, Quaternion.identity);
オブジェクト、位置(省略可)、無回転（省略可）
watcher.Stop();
スキャン終了
CLIENT_ID = HttpContext.Request.Query["client_id"].ToString();
要求URLパラメータ取得
var client = await _context.Clients.FindAsync(CLIENT_ID);*if (client == null) {return Redirect("#error=unauthorized_client&error_description=client authentication failed.");}
要求URLパラメータclient_idチェック
string random = Guid.NewGuid().ToString("N").ToUpper();
access_token発番(token)
string refresh = Guid.NewGuid().ToString("N").ToUpper();
refresh_token発番(code)
string param = "&state="+STATE;
応答URLパラメータにstateを引き継ぐ
var code = new Code {CodeId = random, UserId = User.Identity.Name, ClientId = CLIENT_ID, Nonce = NONCE, Iat=DateTime.Now};
認可コード(code)を発行
access_token = new Token {UserId = User.Identity.Name, AccessToken = random, ClientId = CLIENT_ID, Scope = SCOPE, Iat=DateTime.Now};
有効期限60秒固定のaccess_tokenを発行
param = "#access_token=" + random + "&token_type=bearer" + param;
応答URLパラメータを生成
var claims = new[] {new Claim(JwtRegisteredClaimNames.Sub, User.Identity.Name),new Claim(JwtRegisteredClaimNames.Nonce, NONCE)};
共通関数にてIDトークン(id_token)を生成
param = "#id_token=" + id_token + param;
応答URLパラメータを生成
return Redirect(REDIRECT_URI + param);
応答をリダイレクト
var force = new Vector3(a, 0f, b);
(x, y, z)平面方向がx,z上空方向がy
var request = new GraphQLRequest{Query = query,OperationName = "MyQuery",Variables = variables,};
リクエスト作成
var response = await this.GraphQLHttpClient.SendQueryAsync<JObject>(request);
Query実行
rangeValuePattern.SetValue(50000);
スクロール位置の変更
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

*services.AddScoped<IHubSpotService, HubSpotService>();
(略)

*string secretId = "hubspot-client-secret";
hubspotアプリのclientsecretを指定。(e.g. 00000000-1111-2222-3333-444444444444)

*byte[] bytes = Encoding.UTF8.GetBytes(secretId + method + url + requestBody);
ワークフローで指定したウェブフックURLを指定
string url = "https:hogehoge.com/webhook";


*,,,
拡張メソッドは、以下と同等の為、引数無しデリゲート型として渡せないと思われる。
Func(TestExt.IsTrue(true));

*Func(() => true.IsTrue());
以下は可能

*,,,
おそらく以下のように取り扱われているから？
Func(TestExt.IsTrue(true));


*DapperExtensions.DapperExtensions.SqlDialect = new DapperExtensions.Sql.SqliteDialect();
Sql文を　[testTable].[test_id]から　[test_id]に変更する

*testTable testTable1 = new testTable();
DapperExtensionを使った処理

*result.name += "qqqq111";
DapperExtensionを使った処理


*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer


*private void form1_Closing(object sender, FormClosingEventArgs e)
×ボタン押下時


*public Vector3 MinScale = Vector3.one;
最小サイズ

*public Vector3 ScaleRate = Vector3.one * 0.001f;
縮んでいく比率


*CreateLogfile(new FileInfo(logFilePath));
ログファイルを生成する

*CompressLogFile();
ログファイルを圧縮する

*DeleteOldLogFile();
古いログファイルを削除する


*String url = "http:
api.openweathermap.orgdata2.5weather?q=Tokyo,jp&units=metric&APPID={Your API Key}";


*Console.WriteLine(i);
1,2,3,4,5

*,,,
3じゃないよ

*int plusWithNum(int num1, int num2)*{return num1 + num2;}
戻り値の型 関数名(型 引数名)

*plusWithNum(1,5)
普通に引数の型と同じものを入れたらよい

*PlusWithNum(num1: 1, num2: 5);
追記
名前付き引数での呼び出し

*PlusWithNum(num2: 5, num1: 1);
名前付き引数の場合, 順番を前後させても問題ない


*texture.ToRenderTexture().GaussianFilter5X5().ExtractEdge();
デノイズ処理を行い，その結果からエッジを抽出


*var ユーザー = new ユーザー(new ユーザーId(100),
以下省略...


*private void mode_Select(object sender, EventArgs e)
モードセレクト

*x = -3;
未選択時はNormal


*case "SQLServer":*{var option = new DbContextOptionsBuilder<SampleDbContext>();Options = option.UseSqlServer(DbSetting.SQLServerConnectionString).Options;break;}
本番環境

*case "SqliteInMemory":*{if (_dbConnection == null){_dbConnection = new SqliteConnection(DbSetting.SqliteInMemoryConnectionString);_dbConnection.Open();var option = new DbContextOptionsBuilder<SampleDbContext>();// InMemoryではトランザクション(スコープ)を使うとエラーになってしまうので回避コードoption.ConfigureWarnings(x => x.Ignore(Microsoft.EntityFrameworkCore.Diagnostics.RelationalEventId.AmbientTransactionWarning));Options = option.UseSqlite(_dbConnection).Options;using (var context = new SampleDbContext(Options)){context.Database.EnsureDeleted();context.Database.EnsureCreated();}}break;}
テスト環境

*option.ConfigureWarnings(x => x.Ignore(Microsoft.EntityFrameworkCore.Diagnostics.RelationalEventId.AmbientTransactionWarning));
InMemoryではトランザクション(スコープ)を使うとエラーになってしまうので回避コード

*DbSetting.DataBaseName = "SqliteInMemory";
SqliteInMemoryに設定

*DbSetting.SqliteInMemoryConnectionString = $"DataSource=UnitTest1.db;mode=memory;";
DB名はテストごとに変更すると競合しなくてすみます

*dbContextOptionsFactory = new DbContextOptionsFactory();
DIは使用せずに直接実装から呼び出しています

*Seed();
初期データ作成

*Assert.IsTrue(count == 5);
最初に登録されてたメッセージは5種類

*testId = sampleDbContext.SampleModels.Where(x => x.Message == "おはよう").Select(x => x.SampleModelId).FirstOrDefault();
後で使用するため、"おはよう"の主キーを取得しておきます

*Assert.IsTrue(count == 5);
最初に登録されているメッセージは5種類

*dbAccess.AddMessage("おはよう");
追加
既存のメッセージがあるので数は変更ないはず

*dbAccess.AddMessage("ごちそうさま");
新しいメッセージを追加

*dbAccess.DeleteMessage("おはようございます");
削除
存在しないメッセージは削除できず数の変更なしのはず

*dbAccess.UpdateMessage(testId, "おはようございます");
変更
おはよう => おはようございます

*dbAccess.DeleteMessage("おはようございます");
削除
こんどは"おはようございます"は存在するので削除できる


*SecValue = v ^ Seed;
あとはお好きに


*CurrentThemeName = themeName;
Themeが変わった


*get { return _num; }
外部に値を返す


*PhotonVoiceSettings.Instance.MicrophoneType = IsMacOs()? PhotonVoiceSettings.MicAudioSourceType.Unity: PhotonVoiceSettings.MicAudioSourceType.Photon;
念の為PhotonVoiceSettingも変更しておく

*private bool IsMacOs() {#if UNITY_STANDALONE_OSX || UNITY_EDITOR_OSXreturn true;#endifreturn false;}
Macで実行されていたらtrue


*mock.Setup(_ => _.DoSomething(It.IsAny<string>(), ref It.Ref<string>.IsAny))
モックの振る舞いを登録します
ref参照の変数で値を変更します


*string body = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync();
POSTパラメータ取得

*var client = await _context.Clients.FindAsync(CLIENT_ID);*if (client == null) {return new AccessToken {error = "unauthorized_client", error_description="client authentication failed."};}
POSTパラメータclient_idチェック

*string idtoken = null;
id_token生成(authorization_code)

*string random = Guid.NewGuid().ToString("N").ToUpper();
access_token発番(authorization_code/client_credentials/password/refresh_token)

*string refresh = Guid.NewGuid().ToString("N").ToUpper();
refresh_token発番(authorization_code/password/refresh_token)

*var refresh_token = _context.Tokens.FirstOrDefault(r => r.RefreshToken == REFRESH_TOKEN);*if (refresh_token == null) {return new AccessToken {error = "unsupported_response_type", error_description="the response_type value is not supported."};} else {// 要求のclient_idをチェックif (CLIENT_ID != refresh_token.ClientId) return new AccessToken {error = "invalid_request", error_description = "client_id is not valid."};// 要求のrefresh_tokenの有効期限3600秒固定をチェックint unixTimestamp = (int)(DateTime.Now.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;int iat = (int)(refresh_token.Iat.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;if (unixTimestamp - iat > 3600) {return new AccessToken {error = "access_denied", error_description="the refresh_token is not valid."};}// 要求のclient_idからusername/scopeを取得USERNAME = refresh_token.UserId;SCOPE = refresh_token.Scope;}
要求のrefresh_tokenをチェック

*int unixTimestamp = (int)(DateTime.Now.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;
要求のrefresh_tokenの有効期限3600秒固定をチェック

*USERNAME = refresh_token.UserId;
要求のclient_idからusername/scopeを取得

*USERNAME = "admin";
usernameはadmin固定

*refresh = null;
refresh_tokenは発行しない

*var user = _context.Users.FirstOrDefault(u => u.UserName == USERNAME);*if (user == null ) {return new AccessToken {error = "access_denied", error_description="user authentication failed."};}
要求のusernameをチェック

*var code = await _context.Codes.FindAsync(CODE);*if (code == null) {return new AccessToken {error = "invalid_request", error_description="the code is not valid."};}
要求のcodeをチェック

*USERNAME=code.UserId;
要求のcodeからusername/nonceを取得

*_context.Codes.Remove(code);
要求のcodeを削除

*var claims = new[] {new Claim(JwtRegisteredClaimNames.Sub, USERNAME),new Claim(JwtRegisteredClaimNames.Nonce, NONCE)};
共通関数にてIDトークン(id_token)を生成

*string t="openid";*if (SCOPE != null) {string[] s =  SCOPE.Split(' ');for (int j=0; j<s.Length; j++){if (s[j]!="openid" && client.AllowedScope.Contains(s[j])) t=t+" "+s[j];}}
scopeはopenidを最小限とする

*SCOPE=t;
要求scopeと許可scopeのANDをとる

*} else {
不明の場合

*var token = await _context.Tokens.FindAsync(USERNAME);*if (token != null) {_context.Tokens.Remove(token);await _context.SaveChangesAsync();}
削除タイミングがないためaccess_tokenは１ユーザーにつき１つの制限

*token = new Token {UserId = USERNAME, AccessToken = random, ClientId = CLIENT_ID, RefreshToken=refresh, Scope = SCOPE, Iat=DateTime.Now};
有効期限60秒固定のaccess_tokenを発行

*} else {
要求がathorization_code/password/refresh_tokenの場合、access_token/refresh_tokenを返す


*var cert = new X509Certificate2(file, pfxFilePassward);*//秘密鍵の取り出し
pfxファイルを読み込み

*var rsa = (RSACryptoServiceProvider)cert.PrivateKey;
秘密鍵の取り出し

*var signature = rsa.SignData(byteData, HashAlgorithm.Create("SHA256"));
署名実行
!!! 例外発生 !!!!

*var cert = new X509Certificate2(file);*//公開鍵の取り出し
crtファイルを読み込み

*var rsa = (RSACryptoServiceProvider)cert.PublicKey.Key;
公開鍵の取り出し

*var result = rsa.VerifyData(byteData, HashAlgorithm.Create("SHA256"), signature);*,,,
検証実行

*var cert = new X509Certificate2(file, pfxFilePassward);*//秘密鍵の取り出し
pfxファイルを読み込み

*var rsa = (RSACryptoServiceProvider)cert.PrivateKey;
秘密鍵の取り出し

*var enhCsp = new RSACryptoServiceProvider().CspKeyContainerInfo;
以下の処理を行わないとSHA256アルゴリズムが使用できない

*var signature = privKey.SignData(byteData, HashAlgorithm.Create("SHA256"));
署名実行


*s2.Num = 2;
コピーしたオブジェクトのメンバーの値を変更する。

*public Sample ShallowCopy() => (Sample)MemberwiseClone();
MemberwiseCloneメソッドはobject型で返却するのでSample型へキャストする必要があります。


*public interface ISummerVacation*{public void SummerVacationWeekday();public void SummerVacationHoliday();}
夏休み用の過ごし方を表すインターフェースを用意します。

*public class SummerVacationLifeStyle : ISummerVacation
夏休み用ライフスタイルクラスで元々あったクラスを利用 + 独自にカスタマイズします。
今回は平日の過ごし方を夏休み用にカスタマイズしました。


*Status = 0;
0だったらCllisionのif文が実行される


*public int X
自動実装プロパティにすべきだが説明用


*builder.Services.AddSingleton(p => p.GetRequiredService<IConfiguration>().Get<AppSettings>());
IConfiguration から AppSettings クラスにして DI できるようにしておく

*public class AppSettings*{public string Message { get; set; }public string EnvMessage { get; set; }}
appsettings.json の値を入れるよう


*return method.Invoke(_instance, arg);
メソッドを実行する

*throw e.InnerException;
エラーが発生したら「ここ」のエラー情報じゃなくて発生元のエラーを投げる


*var v = configuration_.GetValue<int>("test:abc");
値を読み込む

*var v = testConfiguration_.Value.abc;
値を読み込む


*myPolygon.StrokeThickness = 1
1.25;    ここは解像度に変更


*string jsonRpText = MessagePack.MessagePackSerializer.SerializeToJson(rpText);*Console.WriteLine($"JSON:{jsonRpText}");
JSON形式にシリアライズ

*byte[] mPackRpText = MessagePack.MessagePackSerializer.Serialize(rpText);*Console.WriteLine($"MessagePack:{String.Join(" ", mPackRpText.Select(x => x.ToString("X2")))}");
MessagePack形式にシリアライズ

*public ReactivePropertySlim<string> NameRps { get; set; } = new ReactivePropertySlim<string>("Skywalker");
ReactivePropertyでもReactivePropertySlimでもできる。

*[IgnoreMember]*public ReadOnlyReactivePropertySlim<string> NameRorps { get; set; }
ReadOnlyはSerializeできない。

*NameRorps = Observable.CombineLatest(NameRp, NameRps, (x, y) => $"{x}={y}")
姓と名の変更を購読して、フルネームにする

*public event PropertyChangedEventHandler PropertyChanged;*public RpNames Names { get; } = new RpNames();
メモリリークを防ぐためのダミー実装

*var resolver = MessagePack.Resolvers.CompositeResolver.Create(ReactivePropertyResolver.Instance,MessagePack.Resolvers.ContractlessStandardResolver.Instance,MessagePack.Resolvers.StandardResolver.Instance);
ReactiveProperty用を含んだResolverのセットをデフォルトに設定しておく

*var mPack = MessagePack.MessagePackSerializer.ConvertFromJson(JsonSerializedNames.Value);
JSON側からデシリアライズ


*StreamWriter sw = new StreamWriter(Server.MapPath("~/init.log"), true, Encoding.GetEncoding("Shift_JIS"));
ログ・ファイルへの出力ストリームを生成

*StringBuilder sb = new StringBuilder();
日付、リクエストのユーザーエージェントを出力


*helloText.enabled = true;
表示する


*var orderedNumber = number.OrderBy(x => x)
.OrderByDescending(x => x)

*int item = list[1];
配列のように添え字でアクセスできます


*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

*using (var frames = pipeline.WaitForFrames()){var colorFrame = frames.ColorFrame.DisposeWith(frames);
at the end of scope.


*var num = LunLunNumber.Dequeue();
次のルンルン数をキューに追加する


*public class stagecreate : MonoBehaviour*{//スクリプトにPrehubをアタッチするpublic GameObject fields;void Start(){//Prehubを作成GameObject field = Instantiate(fields) as GameObject;//ここで位置情報を入力したり、名前を変えたり、後はお好みで。}}
最初にステージを生成する

*public GameObject fields;
スクリプトにPrehubをアタッチする

*GameObject field = Instantiate(fields) as GameObject;
Prehubを作成

*}
ここで位置情報を入力したり、名前を変えたり、後はお好みで。

*void OnTriggerStay(Collider other)*{//当たったものが"weapon"だったらこのオブジェクトを破壊if (other.gameObject.name == "weapon"){Destroy(this.gameObject);}}
何かに当たったら反応


*var hoge = Hoge();
taskが完了したかなど関係なく普通に進んでいく


*void Start()*{// 線オブジェクト設定LineRenderer line = gameObject.GetComponent<LineRenderer>();// 線の幅を指定line.startWidth = 0.1f;line.endWidth = 0.1f;// 頂点の数を指定line.positionCount = 2;// 開始位置と終了位置を指定line.SetPosition(0, Vector3.zero);line.SetPosition(1, new Vector3(1f, 1f, 0f));}
Start is called before the first frame update

*LineRenderer line = gameObject.GetComponent<LineRenderer>();
線オブジェクト設定

*line.startWidth = 0.1f;
線の幅を指定

*line.positionCount = 2;
頂点の数を指定

*line.SetPosition(0, Vector3.zero);
開始位置と終了位置を指定

*void Update()*{}
Update is called once per frame

*void Start()*{// 線オブジェクト設定LineRenderer line = gameObject.GetComponent<LineRenderer>();// 線の幅を指定line.startWidth = 0.1f;line.endWidth = 0.1f;// 頂点の数を指定line.SetVertexCount(2);// 開始位置と終了位置を指定line.SetPosition(0, Vector3.zero);line.SetPosition(1, new Vector3(1f, 1f, 0f));}
Start is called before the first frame update

*LineRenderer line = gameObject.GetComponent<LineRenderer>();
線オブジェクト設定

*line.startWidth = 0.1f;
線の幅を指定

*line.SetVertexCount(2);
頂点の数を指定

*line.SetPosition(0, Vector3.zero);
開始位置と終了位置を指定

*void Update()*{}
Update is called once per frame


*"https:
blazorsignin.onmicrosoft.comxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxxAPI.Manage");

*@using Microsoft.AspNetCore.Components.Authorization
これを追加


*int[] arr = new int[100];
100個のint型要素が入る配列を生成。


*[DependencyPropertyGen(typeof(string), "MyText")]
DependencyPropertyを自動実装するために属性を付ける

*}
略

*[DependencyPropertyGen(typeof(string), "MyText")]
DependencyPropertyを自動実装するために属性を付ける

*}
略


*AssetDatabase.Refresh ();
アセットを更新


*// 今回はプロジェクトプロパティのResource画像から*public ImageSource img { get; }
返す値はお好みで

*public ImageSource img { get; }
今回はプロジェクトプロパティのResource画像から


*}
レンダリングするので重い処理はしない

*}
レンダリングしてないので重い処理を実行


*else if (e.KeyChar == 's' && paddlePos.Right < this.Width)
S押下時


*string a = onestring();
aに一つの文字列を入力

*string[] b = arraystring();
bに複数の文字列を入力

*int c = oneint();
cに一つの数字を入力

*int[] d = arrayint();
dに複数の数字を入力

*static string onestring()*{return Console.ReadLine();}
一つの文字列を受け渡す

*static string[] arraystring()
複数の文字列を配列で受け渡す
文字列と文字列の間は" "で区切る

*static int oneint()*{return int.Parse(Console.ReadLine());}
一つの数字を受け渡す

*static int[] arrayint()
複数の数字を配列で受け渡す
数字と数字の間は" "で区切る


*&& Math.Abs(xy01 - xy02) > 0.025
傾きの差が小さすぎる点は直線であろう。<--------要調整

*Func<OpenCvSharp.Point[], OpenCvSharp.Point[]> getMaskContuour = (inputPoints) =>*{List<OpenCvSharp.Point> maskedContour = new List<OpenCvSharp.Point>();if (maskArea == null){//画像中の無視領域は指定されていないのでそのまま返す。maskedContour.AddRange(inputPoints);}else{foreach (var con in inputPoints){if (maskArea.Where(a => a.Left < con.X && a.Right > con.X&& a.Top < con.Y && a.Bottom > con.Y).Any()){continue;}maskedContour.Add(con);}}return maskedContour.ToArray();};
画像中の無視する範囲の輪郭を除去します。

*maskedContour.AddRange(inputPoints);
画像中の無視領域は指定されていないのでそのまま返す。

*var blur = gray.GaussianBlur(new OpenCvSharp.Size(9, 9), 0);
binaryにすると円以外の輪郭が強く出てしまい、これを除去する必要がある。今回は不採用
var bin_img = gray.Threshold(12, 255, ThresholdTypes.Binary);.Otsu);
ガウシアンフィルタのカーネルサイズは画像(画素数)によって要調整。画素数が多いほど大きくした方が良さそうである。

*var canny_img = blur.Canny(100, 250);
画像次第でここの数値は要調整 なるべく数値を上げて輪郭数を少なくした方が速いが、輪郭が短くブツ切れになると円の検出が厳しい。

*var rtnList = new List<Arc>();
検出した円弧を詰めるList

*int numOfPoints = 10;
輪郭中の計算点数

*var maskedContour = getMaskContuour(contour);
画像中の処理対象外にある輪郭を除去する

*var notStraightContour = searchNotStraightContour(maskedContour);
完全な直線と疑われるものは除く

*if (!notStraightContour.Any()*|| notStraightContour.Count() < numOfPoints)
対象が無ければ処理しない

*var subContour = notStraightContour間引きする.Where((a, index) => index % (notStraightContour.Count() / numOfPoints) == 0)
間引きしてdouble型のPointコレクションを取得

*.Where((a, index) => index % (notStraightContour.Count() / numOfPoints) == 0)
間引きする

*.Select(a => new Point2d(a.X + outLine.X, a.Y + outLine.Y));
外形トリミング分の座標補正

*var arc = CalcArc.Calc(subContour);
円弧を計算


*listView.Items[i] = fld;
こんな感じで配列をそのまま突っ込む


*string[] imagePaths = System.IO.Directory.EnumerateFiles(ImagePath, "*", System.IO.SearchOption.AllDirectories).ToArray();
(1)キャリブレーション画像(補正前)の読み込み

*using (var fs = new FileStorage(YamlFilePath, FileStorage.Mode.Read)){var mtx = fs["mtx"].ReadMat();
ymlファイルを読み来み計算パラメータを取得


*Taro.SetNickName = "tataroro";
setの部分が呼び出される

*}
ニックネームを表示する
Console.Write(Taro.SetNickName);     getの部分が呼び出される

*public string SetNickName { get; set; }
上のプロパティは以下のように短縮できる


*.ToArray();
配列にする


*IntPtr GetFunctionPointer<T>(T function) where T : Delegate*{return function.Method.MethodHandle.GetFunctionPointer();}
Func等をキャストなしで引数に渡せるのでジェネリックにしています。

*public readonly struct FuncPointer<TResult, T0> : IEquatable<FuncPointer<TResult, T0>>*{public static bool operator ==(FuncPointer<TResult, T0> left, FuncPointer<TResult, T0> right) => left.Equals(right);public static bool operator !=(FuncPointer<TResult, T0> left, FuncPointer<TResult, T0> right) => !(left == right);public static int Arity => 1;public RuntimeMethodHandle Handle { get; }readonly IntPtr ptr;[MethodImpl(MethodImplOptions.AggressiveInlining)]public TResult Invoke(T0 arg0) => FunctionPointerUtility.Call<TResult, T0>(this.ptr, arg0);public override bool Equals(object obj) => obj is FuncPointer<TResult, T0> pointer && this.Equals(pointer);public bool Equals(FuncPointer<TResult, T0> other) => this.Handle.Equals(other.Handle);public override int GetHashCode() => HashCode.Combine(this.Handle);public FuncPointer(Func<TResult, T0> func){FunctionPointersHelper.ValidateFunction(func, Arity);this.Handle = func.Method.MethodHandle;this.ptr = this.Handle.GetFunctionPointer();}}
項数1の戻り値有り・無しで一つずつ例示します。

*internal static class FunctionPointersHelper*{public static void ValidateFunction(Delegate func, int arity){if (func is null) throw new ArgumentNullException(ResourceStrings.ExceptionMessage_FunctionIsNull);if (!func.Method.IsStatic) throw new ArgumentException(ResourceStrings.ExceptionMessage_FunctionIsNotStatic);//拡張メソッドだと項数が一致しない。if (func.Method.GetParameters().Length != arity) throw new ArgumentException(ResourceStrings.ExceptionMessage_FunctionArityMismatch);}}
ResourceStringsは特に重要でないので出しません。

*if (func.Method.GetParameters().Length != arity) throw new ArgumentException(ResourceStrings.ExceptionMessage_FunctionArityMismatch);*}
拡張メソッドだと項数が一致しない。


*int lenNow = Encoding.GetEncoding("Shift_JIS").GetByteCount(txt.Text);*// 未入力の場合
桁数取得（全角を2桁として扱う）

*MessageBox.Show(ex.Message);
エラーメッセージを表示


*}
何か終了処理があればここに

*MessageBox.Show(ex.Message);
エラーメッセージを表示

*this.Close();
画面を終了する


*using (var pngbmp = new Bitmap("touka.png"))
貼り付けたい画像を開く(この場合はpngで、透明部分を透過できる)

*g.DrawImage(pngbmp, 5, 5, pngbmp.Width, pngbmp.Height);
貼り付ける画像を(5,5)の位置に描画する

*bmp.Save(@"output.bmp");
保存する


*//ある日あるときの配列*int[][] bingo = { new int[] { 0, 1, 2 }, new int[] { 3, 4, 5 }, new int[] { 6, 7, 8 }, new int[] { 0, 3, 6 }, new int[] { 1, 4, 7 }, new int[] { 2, 5, 8 }, new int[] { 0, 4, 8 }, new int[] { 2, 4, 6 } };
C#

*int[][] bingo = { new int[] { 0, 1, 2 }, new int[] { 3, 4, 5 }, new int[] { 6, 7, 8 }, new int[] { 0, 3, 6 }, new int[] { 1, 4, 7 }, new int[] { 2, 5, 8 }, new int[] { 0, 4, 8 }, new int[] { 2, 4, 6 } };
ある日あるときの配列

*int[,] day = new int[2,3];
他のある日の配列

*//要素数が一定でないときの配列の使い方*//要素数が3個の配列(中身{0,1,2})と2個の配列(中身{3,4})を、同じ配列に入れている
C#

*//要素数が3個の配列(中身{0,1,2})と2個の配列(中身{3,4})を、同じ配列に入れている
要素数が一定でないときの配列の使い方

*int[][] arr1 = { new int[] { 0, 1, 2 }, new int[] { 3, 4 }};
要素数が3個の配列(中身{0,1,2})と2個の配列(中身{3,4})を、同じ配列に入れている

*//前者と同じように中身を定義することもできる(定義していないと全部中身は0になる)*int[,] arr2 = new int[2,3]{ { 0, 1, 2 } { 3, 4, 5} };
要素数が一定な時の配列の使い方

*int[,] arr2 = new int[2,3]{ { 0, 1, 2 } { 3, 4, 5} };
前者と同じように中身を定義することもできる(定義していないと全部中身は0になる)


*var expected = 8;
予想している結果

*var actual = Calculation.add(x,y);
実際の結果


*var roleArn = $"AwsRoleArnAws{(byte)accountNo}";
accountNo: 1~N


*actual.AssertIs(new { Foo = "Foo1", Bar = new[] { 1, 2 } });
成功！


*await GeotagHelper.SetGeotagAsync(stbmp, gps);
→こっちは、拡張子はjpgだが実はbmpでjpgではないので、geotag付与時に例外発生


*private string templete = @"C:\tmp\templete.docx";
テンプレートのファイルパス

*doc.SaveAs(@"C:\tmp\output.docx");
保存パス


*panel2.Controls.Remove(deletingArrow);
panel2に登録されたArrow型のオブジェクトを消す


*CloudAppendBlob appendBlob_download = container.GetAppendBlobReference(filename);
ダウンロードするファイル名を指定

*string path = Directory.GetCurrentDirectory() + "\\log\\" + DateTime.Now.ToString("yyyyMMdd") + ".log";
ダウンロード後のパスとファイル名を指定。

*CloudStorageAccount storageAccount = CloudStorageAccount.Parse(CloudConfigurationManager.GetSetting("StorageConnectionString"));
Retrieve storage account from connection string.


*PdfReader.Open(path, PdfDocumentOpenMode.ReadOnly).Dispose();
パスワードのチェックのみなので、ReadOnlyモードで開きます。


*return (T)binaryFormatter.Deserialize(memoryStream);
デシリアライズ

*int b = a;
値型を代入

*string b = a;
stringの代入（stringは参照型だが、例外的にディープコピーとなる）

*List<int> b = new List<int>(a);
値型のListをコンストラクタでnew

*int[] b = a;
配列、リスト等の参照型を代入

*List<List<int>> b = new List<List<int>>(a);
多重Listをコンストラクタでnew

*foreach(var member in a)*//gourpbyの中身（下の例でgroupaを変更すると、aも変更される）
foreachの中身（下の例でmemberを変更すると、aも変更される）

*var groupa = a.Groupby(c => c.key)
gourpbyの中身（下の例でgroupaを変更すると、aも変更される）


*app.UseAuthentication();
この1行を追加


*var doubleList = src.Select(a => Convert.ToDouble(a)).ToArray();
Doubleにキャストして処理を進める

*double mean = doubleList.Average();
平均値算出

*double sum2 = doubleList.Select(a => a * a).Sum();
自乗和算出

*double variance = sum2 / doubleList.Count - mean * mean;
分散 = 自乗和 / 要素数 - 平均値^2

*return Math.Sqrt(variance);
標準偏差 = 分散の平方根

*Console.WriteLine(iList.Stdev().ToString());
標準偏差(int)

*Console.WriteLine(dList.Stdev().ToString());
標準偏差(double)

*var doubleList = new List<double>();
Doubleにキャストして処理を進める

*double mean = doubleList.Average();
平均値算出

*double sum2 = doubleList.Select(a => a * a).Sum();
自乗和算出

*double variance = sum2 / doubleList.Count - mean * mean;
分散 = 自乗和 / 要素数 - 平均値^2

*return Math.Sqrt(variance);
標準偏差 = 分散の平方根

*var sw = new System.Diagnostics.Stopwatch();
テストその1（ジェネリックからキャスト）

*sw = new System.Diagnostics.Stopwatch();
テストその2（ジェネリックからキャスト（旧））

*sw = new System.Diagnostics.Stopwatch();
テストその3（ジェネリックなしでキャスト）

*double mean = doubleList.Average();
平均値算出

*double sum2 = doubleList.Select(c => c * c).Sum();
自乗和算出

*double variance = sum2 / doubleList.Length - mean * mean;
分散 = 自乗和 / 要素数 - 平均値^2

*double stdev = Math.Sqrt(variance);
標準偏差 = 分散の平方根


*public static T Median<T>(this IEnumerable<T> src)*{//ジェネリックの四則演算用クラスvar ao = new ArithmeticOperation<T>();//昇順ソートvar sorted = src.OrderBy(a => a).ToArray();if (!sorted.Any()){throw new InvalidOperationException("Cannot compute median for an empty set.");}int medianIndex = sorted.Length / 2;//要素数が偶数のとき、真ん中の2要素の平均を出力if (sorted.Length % 2 == 0){//四則演算可能な時のみ算出if (ao.ArithmeticOperatable(typeof(T))){return ao.Divide(ao.Add(sorted[medianIndex], sorted[medianIndex - 1]), (T)(object)2.0);}else throw new InvalidOperationException("Cannot compute arithmetic operation");}//奇数のときは、真ん中の値を出力else{return sorted[medianIndex];}}
メディアン算出メソッド（Generics）

*var ao = new ArithmeticOperation<T>();
ジェネリックの四則演算用クラス

*var sorted = src.OrderBy(a => a).ToArray();
昇順ソート

*else*{return sorted[medianIndex];}
奇数のときは、真ん中の値を出力

*public static DateTime Median(this IEnumerable<DateTime> src)*{//昇順ソートvar sorted = src.OrderBy(a => a).ToArray();if (!sorted.Any()){throw new InvalidOperationException("Cannot compute median for an empty set.");}int medianIndex = sorted.Length / 2;//要素数が偶数のとき、真ん中の2要素の平均を出力if (sorted.Length % 2 == 0){return sorted[medianIndex] + new TimeSpan((sorted[medianIndex - 1] - sorted[medianIndex]).Ticks / 2);}//奇数のときは、真ん中の値を出力else{return sorted[medianIndex];}}
メディアン算出（DateTime型のみ別メソッド）

*var sorted = src.OrderBy(a => a).ToArray();
昇順ソート

*else*{return sorted[medianIndex];}
奇数のときは、真ん中の値を出力

*public class ArithmeticOperation<T>*{/// <summary>/// 四則演算適用可能かを判定/// </summary>/// <param name="src">判定したいタイプ</param>/// <returns></returns>public bool ArithmeticOperatable(Type srcType){//四則演算可能な型の一覧var availableT = new Type[]{typeof(int), typeof(uint), typeof(short), typeof(ushort), typeof(long), typeof(ulong), typeof(byte),typeof(decimal), typeof(double)};if (availableT.Contains(srcType)) return true;else return false;}/// <summary>/// 四則演算可能なクラスに対しての処理/// </summary>public ArithmeticOperation(){var availableT = new Type[]{typeof(int), typeof(uint), typeof(short), typeof(ushort), typeof(long), typeof(ulong), typeof(byte),typeof(decimal), typeof(double)};if (!availableT.Contains(typeof(T))){throw new NotSupportedException();}var p1 = Expression.Parameter(typeof(T));var p2 = Expression.Parameter(typeof(T));Add = Expression.Lambda<Func<T, T, T>>(Expression.Add(p1, p2), p1, p2).Compile();Subtract = Expression.Lambda<Func<T, T, T>>(Expression.Subtract(p1, p2), p1, p2).Compile();Multiply = Expression.Lambda<Func<T, T, T>>(Expression.Multiply(p1, p2), p1, p2).Compile();Divide = Expression.Lambda<Func<T, T, T>>(Expression.Divide(p1, p2), p1, p2).Compile();Modulo = Expression.Lambda<Func<T, T, T>>(Expression.Modulo(p1, p2), p1, p2).Compile();Equal = Expression.Lambda<Func<T, T, bool>>(Expression.Equal(p1, p2), p1, p2).Compile();GreaterThan = Expression.Lambda<Func<T, T, bool>>(Expression.GreaterThan(p1, p2), p1, p2).Compile();GreaterThanOrEqual = Expression.Lambda<Func<T, T, bool>>(Expression.GreaterThanOrEqual(p1, p2), p1, p2).Compile();LessThan = Expression.Lambda<Func<T, T, bool>>(Expression.LessThan(p1, p2), p1, p2).Compile();LessThanOrEqual = Expression.Lambda<Func<T, T, bool>>(Expression.LessThanOrEqual(p1, p2), p1, p2).Compile();}public Func<T, T, T> Add { get; private set; }public Func<T, T, T> Subtract { get; private set; }public Func<T, T, T> Multiply { get; private set; }public Func<T, T, T> Divide { get; private set; }public Func<T, T, T> Modulo { get; private set; }public Func<T, T, bool> Equal { get; private set; }public Func<T, T, bool> GreaterThan { get; private set; }public Func<T, T, bool> GreaterThanOrEqual { get; private set; }public Func<T, T, bool> LessThan { get; private set; }public Func<T, T, bool> LessThanOrEqual { get; private set; }}
ジェネリック四則演算用クラス

*var availableT = new Type[]{typeof(int), typeof(uint), typeof(short), typeof(ushort), typeof(long), typeof(ulong), typeof(byte),typeof(decimal), typeof(double)};
四則演算可能な型の一覧

*Console.WriteLine(iList.Median().ToString());
メディアン(int)

*Console.WriteLine(dList.Median().ToString());
メディアン(double)

*Console.WriteLine(dtList.Median().ToString());
メディアン(DateTime)


*const int WEEK_MAX = 7;
マジックナンバーは禁止


*string currDirPath = Directory.GetCurrentDirectory();
プロジェクト名の抽出

*string old = "</AllowUnsafeBlocks>";*string addition = $"<CodeAnalysisRuleSet>{projectName}.ruleset</CodeAnalysisRuleSet>";
.csprojの内容を置換


*public delegate void DELEGATE_PARAM_FUNC(int count);
引数で渡すメソッドの型をdelegateで宣言

*[DllImport("PInvokeTest_delegate.dll", CallingConvention = CallingConvention.Cdecl)]public extern static void StartCountDownAndRegisterFunction(DELEGATE_PARAM_FUNC func);
関数本体の宣言


*.OrderBy(x => x)
.OrderByDescending(x => x)


*Close();
ソフトを終了

*private void Cancel(object sender, RoutedEventArgs e)*{Close();}
キャンセルボタン押すと実行

*public void ErrorOpen(string text)*{// xamlに書いたTextBlockにエラーメッセージを設定errorText.Text = text;// 警告音を鳴らすSystem.Media.SystemSounds.Exclamation.Play();// ドロワーを出すerrorDrawer.IsBottomDrawerOpen = true;}
エラードロワーを開く

*errorText.Text = text;
xamlに書いたTextBlockにエラーメッセージを設定

*System.Media.SystemSounds.Exclamation.Play();
警告音を鳴らす

*errorDrawer.IsBottomDrawerOpen = true;
ドロワーを出す


*else MessageBox.Show("選択したのはPictureBoxではありません！");
(追加変更）


*FormattableString s = $"";
左辺をFormattableStringにできる

*FormattableString s = "";
文字列補間を使用しない場合は代入できない
型 'string' を 'System.FormattableString' に暗黙的に変換できません

*var s = $"";
varを使用した場合はstringになる

*// hello {0}!
出力

*string DoubleInsert(FormattableString fs)*{var f = fs.Format;for (var i = 0; i < fs.ArgumentCount; i++){var target = "{" + i + "}";f = f.Replace(target, target + target);}return string.Format(f, fs.GetArguments());}
挿入される文字列を2倍にするメソッド

*,,,
出力
hello world!
hello worldworld!

*var s = Template(i, j);
文字列を作る

*,,,
出力
key:i value:100
key:j value:200

*var keys = GetKeys(template);
テンプレートからキーの部分のみを取り出す

*var builder = DictionaryBuilder.Create<(int i, int j)>(p => $@"
DictionaryBuilder.Createでテンプレートを作成
ネストも可能

*text.SetText("i: {0} j: {1}", 1, 2);
SetTextを行うとTextMeshProが内部に持っているバッファに文字情報が設定される
内部に持っているバッファはcharの配列なので文字列をアロケーションする必要がない
逆に言うと文字列にできないのでフォーマットのパースやchar配列への変換などは全部自力でやらなければならない

*var sb = new CharBufferedStringBuilder();
文字情報を内部のchar配列にためるBuilder

*var fsb = new FormatStringBuilder<(int i, int j)>(p => $"i: {p.P(t => t.i)}, j: {p.P(t => t.j)}");
文字列補間からテンプレートの作成

*fsb.Apply(sb, (100, 200));
テンプレートを適用
バッファサイズが足りなくならない限りはゼロアロケーション
適用時に毎回パースしなくて済むので多少効率的(かもしれない)


*var account = new Account(){ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<string>()
シリアライズ

*var obj = JsonConvert.DeserializeObject<Account>(json);*Console.WriteLine(string.Join("\n", typeof(Account).GetProperties().Select(info => $"{info.Name}: {info.GetValue(obj)}")));
デシリアライズ

*var account = new Account(){ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<string>()
シリアライズ

*public AccountRole Role { get; set; }
[JsonConverter]付けない

*var json = $@"{{""ID"": 999,""Name"": ""foo"",""IsActive"": true,""CreatedDate"": ""2020-01-02T03:04:05+09:00"",""Role"": ""Role2""}}";
デシリアライズ

*var json = $@"{""ID"": 999,""Name": ""foo"",""IsActive"": true,""CreatedDate"": ""2020-01-02T03:04:05+09:00""}}";
デシリアライズ

*var json = $@"{""ID"": 999,""Name"": ""foo"",""IsActive"": true,""CreatedDate"": ""2020-01-02T03:04:05+09:00"",""Role"": null}}";
デシリアライズ

*var account = new Account(){ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<string>()
シリアライズ

*var account = new Account(){ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<string>()
シリアライズ

*var account = new Account(){ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<string>()
シリアライズ

*var json = $@"{{""ID"": 999,""Name"": ""foo"",""IsActive"": true,""CreatedDate"": ""2020/01/02 03:04:05"",""Role"": ""Role2""}}";
デシリアライズ

*var json = $@"{{""ID"": 999,""Name"": ""foo"",""IsActive"": true,""CreatedDate"": ""2020.01.02 03.04.05"",""Role"": ""Role2""}}";
デシリアライズ

*var account = new Account(){ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<string>()
シリアライズ

*var account = new Account(){ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<string>()
シリアライズ

*var account = new Account(){ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<string>()
シリアライズ

*var account = new Account(){ID = 1,Name = @"hoge@example.com",IsActive = true,CreatedDate = DateTimeOffset.Now,Role = Account.AccountRole.Role1,Telephones = new List<string>()
シリアライズ

*var json = $@"{{""user_id"": 999,""name"": ""foo"",""active"": true,""created_date"": ""2020/01/02 03:04:05"",""role"": ""Role2"",""note"": ""メモ"",""hoge"": ""fuga""}}";
デシリアライズ

*var json = $@"{{""user_id"": 999,""name"": ""foo"",""active"": true,""created_date"": ""2020/01/02 03:04:05"",""role"": ""Role2"",""telephone"": [""010-1111-2222"", ""020-2222-3333""],""address"": {{""address1"":""住所１"", ""address2"":""住所２""}}}}";
デシリアライズ

*using (StreamWriter writer = File.CreateText(@"account.json")){var serializer = new JsonSerializer();
シリアライズ

*using (StreamReader reader = File.OpenText(@"account.json")){var serializer = new JsonSerializer();
デシリアライズ


*new PivotColumn<MockData>("initial",(t)=>t.car.Substring(0,1),(t)=>t.car.Substring(0,1)){Order=PivotOrder.Descending,},
carの頭文字を逆順で集計

*new PivotColumn<MockData>("category",(t)=>t.Job.Split(' ').First(),(t)=>t.Job.Split(' ').First()),
スペース区切りのJobの最初の単語をカテゴリとして集計

*new PivotColumn<MockData>("Job",(t)=>string.Join(" ",t.Job.Split(' ').Skip(1))),
スペース区切りのJobの2番め以降をJobとして集計

*PivotMeasure<MockData>.Average("Avg.Cash",(t)=>t.cash),
集計するのはcashの平均値


*child[i] = parent.transform.GetChild(i).gameObject;
子オブジェクト取得


*var printerName = ConfigurationManager.AppSettings["PrinterName"];
印刷するプリンタ名を取得

*var text = Windows.Storage.ApplicationData.Current.LocalSettings.Values["Key"].ToString();
UWPから渡ってきた値を取得する

*printingText = text;
印刷

*e.Graphics.DrawString(printingText, printFont, Brushes.Black, 0, 0);
都合いい感じに印刷処理を書く


*Regex re = new Regex(@"https:
qiita-image-store.s3.amazonaws.com.*\.png");


*// 1. Data source.*int[] numbers = new int[7] { 0, 1, 2, 3, 4, 5, 6 };
The Three Parts of a LINQ Query:

*int[] numbers = new int[7] { 0, 1, 2, 3, 4, 5, 6 };
1. Data source.

*var numQuery =from num in numberswhere (num % 2) == 0select num;
(クエリ式)

*foreach (int num in numQuery)
(メソッド式)
var numQuery = numbers.where(num => num % 2 == 0);
3. Query execution.


*propertyID = Shader.PropertyToID("_Color");
プロパティーのIDを取得しておく　SetColorをstringで指定しても結局intに変換してるらしく、無駄らしい

*float randomValueA = Random.Range(-1.0f, 1.0f);
ランダムな値

*float randomMagnification = Random.Range(0.0f, 5.0f);*//ランダムな位置にキューブ生成
ランダムな値

*Vector3 randomPos = new Vector3(randomValueA, randomValueB, randomValueC);
ランダムな位置にキューブ生成

*MeshRenderer mr = tmp.GetComponent<MeshRenderer>();
MaterialPropertyBlockで色を変更　元のマテリアルの色はそのまま


*public static IEnumerable<int> TestFunc1()*{//kは非nullが確定しているが警告が出る//CS8629    Null 許容値型は Null になる場合があります。return Enumerable.Range(0, 10).Select((i) => ToIntOrNull(i)).Where((j) => j != null).Select((k) => (int)k);}


*return Enumerable.Range(0, 10)
kは非nullが確定しているが警告が出る
CS8629    Null 許容値型は Null になる場合があります。

*return Enumerable.Range(0, 10)
!演算子をつければ警告は出ない


*.HasForeignKey(x => new { x.Gaibuki });
子テーブル側の、外部キーの設定

*modelBuilder.Entity<Table13>()
ダメ
modelBuilder.Entity<Table12>()
.HasOptional(x => x.Table11)
.WithMany(x => x.Table12s)
.HasForeignKey(x => new { x.Gaibuki });
OK

*,,,
これもOK
modelBuilder.Entity<Table13>()
.HasRequired(x => x.Table11)
.WithMany(x => x.Table13s)
.HasForeignKey(x => new { x.Gaibuki });


*}
何かしらの処理

*}
何かしらの処理


*while (!isAllBingo)
全てのカードがビンゴするまで繰り返す


*}
メンバー変数が変更されるかどうかわからない

*}
メンバー変数が変更されることはない

*}
引数のListが変更されるかどうかがわからない

*}
引数のListが変更されないことが明示的

*// 中身の変更が可能なので変更されてもいい場合以外はだめ*public List<int> IntList { get { return m_IntList} }
そのまま返す場合

*public List<int> IntList { get { return m_IntList} }
中身の変更が可能なので変更されてもいい場合以外はだめ

*// 基本的にはこれで問題ないと思う*public int[] IntList { get { return m_IntList.ToArray(); } }
Arrayに変換する場合

*public int[] IntList { get { return m_IntList.ToArray(); } }
基本的にはこれで問題ないと思う

*public IReadOnlyList<int> IntList { get { return m_IntList; } }
IReadOnlyListとして公開する
変更されたくないのが明示的。クラスの外からは基本的に変更されないはず
キャストすれば変更可能だけど...そこまでして変更する必要のある場合ともとれる？

*public int AnyValue { set; get; }
クラスの外から変更可能

*public int AnyValue { private set; get; }
クラスの外から変更不可

*Name= name;
変更の必要がない場合get-onlyプロパティ

*string Hoge1 { get; }
プロパティはインターフェースでももてる

*readonly string Hoge2;
これはだめ。フィールドはもてない


*string ISS = "http:
localhost:5000op";


*,,,
.csxだと直値を出力とかはできない. 以下はエラーとなるので注意.
"Hello, World!!"

*#r "nuget: Utf8Json"
以下を追記して、VSCodeで開きなおす


*public GameObject explosionPrefab;
爆発エフェクトのPrefab

*GameObject.Find("Canvas").GetComponent<UIController>().AddScore();
衝突したときにスコアを更新する

*GameObject effect = Instantiate(explosionPrefab, transform.position, Quaternion.identity) as GameObject;*Destroy(effect, 1.0f);
爆発エフェクトを生成

*,,,
Instantiate(第１関数,第２関数,第３関数);

*,,,
InvokeRepeating(第１関数, n, m);

*GameObject effect = Instantiate(explosionPrefab, transform.position, Quaternion.identity) as GameObject;*Destroy(effect, 1.0f);
爆発エフェクトを生成


*string body = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync();
POSTパラメータ取得

*var client = await _context.Clients.FindAsync(CLIENT_ID);*if (client == null) {return new AccessToken {error = "unauthorized_client", error_description="client authentication failed."};}
POSTパラメータclient_idチェック

*string random = Guid.NewGuid().ToString("N").ToUpper();
access_token発番(authorization_code/client_credentials/password/refresh_token)

*string refresh = Guid.NewGuid().ToString("N").ToUpper();
refresh_token発番(authorization_code/password/refresh_token)

*USERNAME = "admin";
usernameはadmin固定

*refresh = null;
refresh_tokenは発行しない

*var user = _context.Users.FirstOrDefault(u => u.UserName == USERNAME);*if (user == null ) {return new AccessToken {error = "access_denied", error_description="user authentication failed."};}
要求のusernameをチェック

*string t="openid";*if (SCOPE != null) {string[] s =  SCOPE.Split(' ');for (int j=0; j<s.Length; j++){if (s[j]!="openid" && client.AllowedScope.Contains(s[j])) t=t+" "+s[j];}}
scopeはopenidを最小限とする

*SCOPE=t;
要求scopeと許可scopeのANDをとる

*} else {
不明の場合

*var token = await _context.Tokens.FindAsync(USERNAME);*if (token != null) {_context.Tokens.Remove(token);await _context.SaveChangesAsync();}
削除タイミングがないためaccess_tokenは１ユーザーにつき１つの制限

*token = new Token {UserId = USERNAME, AccessToken = random, ClientId = CLIENT_ID, RefreshToken=refresh, Scope = SCOPE, Iat=DateTime.Now};
有効期限60秒固定のaccess_tokenを発行

*return new AccessToken {access_token = random, expires_in=60, token_type="bearer", scope = SCOPE};
access_tokenを返す


*int directionInt = 0;
0:上


*public class Sample : MonoBehaviour
2次元配列
* Table/表

*int[] arrayInt = new int[3];
宣言方法
１次元配列

*int[,] tabelInt = new int[3, 2];
2次元配列

*tabelInt[0, 0] = 1;
代入方法

*Debug.Log(tabelInt.GetLength(0));
取得方法
int x = tabelInt[0, 0];
長さ
Debug.Log(arrayInt.Length);


*issuer: "http:
localhost:5000op",

*//  {public DbSet<Client> Clients { get; set; }public DbSet<Token> Tokens { get; set; }public DbSet<Code> Codes { get; set; }//        protected override void OnConfiguring(DbContextOptionsBuilder options)//            => options.UseSqlite("Data Source=app.db");}
public class myopContext : DbContext

*public DbSet<Client> Clients { get; set; }
{


*var str = Str.Get(context);*return (ctx) => {// Schedule child activitiesif (Body != null)ctx.ScheduleAction<IObjectContainer>(Body, _objectContainer, OnCompleted, OnFaulted);// Outputs};
Inputs

*if (Body != null)*ctx.ScheduleAction<IObjectContainer>(Body, _objectContainer, OnCompleted, OnFaulted);
Schedule child activities

*if (Body != null)*ctx.ScheduleAction<IObjectContainer>(Body, _objectContainer, OnCompleted, OnFaulted);
Schedule child activities

*return (ctx) => {OutString.Set(ctx, str);};
Outputs


*Vector3 worldClickPos = Camera.main.ScreenToWorldPoint(Input.mousePosition +  Camera.main.transform.forward);*//マウス押した瞬間
スクリーン座標をワールド座標に変換

*int vertCount =  tr.GetPositions(posArray);
全ての頂点を取ってくる


*int[] lastBusinessDays = new int[7];
日、月、火、水、木、金、土


*public abstract double Hanbetsu(double a, double b, double c);
Hanbetsuメソッドは抽象メソッド

*public override double Hanbetsu(double a, double b, double c)*{return Math.Pow(b, 2.0) - 4.0 * a * c;}
基本クラスの抽象メソッドは必ずオーバーライドする


*while(date.CompareTo(endDate) == -1)
-1で以前、0で同じ、1で以後


*}
MakeCredentialAsync()、GetAssertionAsync()で
PIN認証が通ってFIDOキーのタッチ待ちになるとこのイベントが発生します

*return;*} else if (res.DeviceStatus == g.FIDO2.CTAP.DeviceStatus.Timeout) {
FIDOキーが接続されていない場合

*return;*} else if (res.DeviceStatus == g.FIDO2.CTAP.DeviceStatus.Ok) {
FIDOキーのタッチ待ちでTimeoutした場合

*var v = new AttestationVerifier();*var verify = v.Verify(rpid,challenge, res.CTAPResponse.Attestation);
verify

*creid = verify.CredentialID.ToArray();*pubkey = verify.PublicKeyPem;
store

*}
MakeCredentialAsync()、GetAssertionAsync()で
PIN認証が通ってFIDOキーのタッチ待ちになるとこのイベントが発生します

*return;*} else if (res.DeviceStatus == g.FIDO2.CTAP.DeviceStatus.Timeout) {
FIDOキーが接続されていない場合

*return;*} else if (res.DeviceStatus == g.FIDO2.CTAP.DeviceStatus.Ok) {
FIDOキーのタッチ待ちでTimeoutした場合

*var v = new AssertionVerifier();*var verify = v.Verify(rpid,pubkey,challenge, res.CTAPResponse.Assertion);
verify


*private string URL = "https:
expired.badssl.com";

*CefSettings set = new CefSettings();
CefCharp初期設定

*cefBrowser = new ChromiumWebBrowser(URL);
CefSharpのWebViewを作成する。
ページを表示。

*this.Controls.Add(cefBrowser);
コントロールを追加する。

*cefBrowser.RequestHandler = new ExampleRequestHandler();
先ほど実装したRequestHandlerをインスタンス化


*int month = random.Next(1, 13);
無作為に選ぶ

*DateTime date = new DateTime(year, month, 13);
year年month月13日が金曜日ですか？


*var sql = "SELECT Id, Author, Title, PostedAt, Text From Posts";*sql += $" Where Author like '%{author}%'";
危険なコード！

*,,,
省略...

*[Theory]
fuzz.txt の１行を１テストケースとして定義
※後述の Parameters プロパティを参照

*using (var db = new BlogDbContext()){テーブルを空にしておくdb.Posts.RemoveRange(db.Posts.ToArray());
* Arrange

*db.Posts.RemoveRange(db.Posts.ToArray());
テーブルを空にしておく

*db.Posts.Add(new BlogPost() { Author = param, Title = "test" });
SQL が正しく実行されれば、この Entity が帰ってくるはず

*db.Posts.Add(new BlogPost() { Author = "Dummy", Title = "Dummy" });
こっちは帰ってこないはず

*Assert.True(sw.ElapsedMilliseconds < 5000, "Blind SQL Injection");
実行に5秒以上かかったら Blind な SQL Injection が成功してるのでNG

*Assert.Equal(param, result.Single().Author);
正しいSQL文が発行されていれば１件の結果が返ってくるはず

*public static IEnumerable<object[]> Parameters*{get{var f = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "fuzz.txt");var r = File.ReadAllLines(f).Where(l => !string.IsNullOrWhiteSpace(l)).Select(l => new object[] { l }).ToArray();return r;}}
SqlInjectionTest で使う入力データ列


*cal[line][column] = string.Format("{0,2}", day);
プラスで右寄せ、マイナスで左寄せ


*_redoButtonObj.InteractableStateChanged.AddListener(modeChangeToRedo);
Redoボタンが押されたらFunctionステートを変更

*_undoButtonObj.InteractableStateChanged.AddListener(modeChangeToUndo);
Undoボタンが押されたらFunctionステートを変更

*_paintButtonObj.InteractableStateChanged.AddListener(modeChangeToPaint);
Paintボタンが押されたらFunctionステートを変更


*using System;
コンパイルは、コマンドラインから以下
c:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /target:winexe scr_cap.cs


*this.Controls.Add(panel4);
フォーム(this)上にパネルpanel4を追加

*}
イベントハンドラを登録
this.LocationChanged += new EventHandler(Form1_LocationChanged);     フォームが移動したことを検出

*private void Form1_LocationChanged(object sender, EventArgs e)*{//panel1label11.Text = "panel1の左上の座標";p11 = panel1.Location;label12.Text = "(1) panel1.Locationで示される座標(" + p11.X + "," + p11.Y + ")";p12 = this.PointToScreen(p11);label13.Text = "(2) this.PointToScreen( (1)の座標系 ) で求められたスクリーン(モニタ)の左上を基準にした座標(" + p12.X + "," + p12.Y + ") <--- フォームをドラッグして動かすと、座標の表示が変わります。";p13 = this.PointToClient(p12);label14.Text = "(3) this.PointToClient( (2)のスクリーン座標系 ) で求められたフォーム(this)の左上を基準にした座標(" + p13.X + "," + p13.Y + ")     フォームを動かしても、(1)と同じ値。";p14 = panel1.PointToClient(p12);label15.Text = "(3) panel1.PointToClient( (2)のスクリーン座標系 ) で求められたpanel1の左上を基準にした座標(" + p14.X + "," + p14.Y + ")";//panel2label21.Text = "panel2の左上の座標";p21 = panel2.Location;label22.Text = "(1) Locationメソッドで示される座標(" + p21.X + "," + p21.Y + ")";p22 = panel1.PointToScreen(p21);label23.Text = "(2) panel1.PointToScreen( (1)の座標系 ) で求められたスクリーン(モニタ)の左上を基準にした座標(" + p22.X + "," + p22.Y + ") <--- フォームをドラッグして動かすと、座標の表示が変わります。";p23 = this.PointToClient(p22);label24.Text = "(3) this.PointToClient( (2)のスクリーン座標系 ) で求められたフォーム(this)の左上を基準にした座標(" + p23.X + "," + p23.Y + ") ";p24 = panel1.PointToClient(p22);label25.Text = "(4) panel1.PointToClient( (2)のスクリーン座標系 ) で求められたpanel1の左上を基準にした座標(" + p24.X + "," + p24.Y + ")     フォームを動かしても、(1)と同じ値。";p25 = panel2.PointToClient(p22);label26.Text = "(5) panel2.PointToClient( (2)のスクリーン座標系 ) で求められたpanel2の左上を基準にした座標(" + p25.X + "," + p25.Y + ")";//panel3label31.Text = "panel3の左上の座標";p31 = panel3.Location;label32.Text = "(1) Locationメソッドで示される座標(" + p31.X + "," + p31.Y + ")";p32 = panel2.PointToScreen(p31);label33.Text = "(2) panel2.PointToScreen( (1)の座標系 ) で求められたスクリーン(モニタ)の左上を基準にした座標(" + p32.X + "," + p32.Y + ") <--- フォームをドラッグして動かすと、座標の表示が変わります。";p33 = this.PointToClient(p32);label34.Text = "(3) this.PointToClient( (2)のスクリーン座標系 ) で求められたフォーム(this)の左上を基準にした座標(" + p33.X + "," + p33.Y + ") ";p34 = panel1.PointToClient(p32);label35.Text = "(4) panel1.PointToClient( (2)のスクリーン座標系 ) で求められたpanel1の左上を基準にした座標(" + p34.X + "," + p34.Y + ")";p35 = panel2.PointToClient(p32);label36.Text = "(5) panel2.PointToClient( (2)のスクリーン座標系 ) で求められたpanel2の左上を基準にした座標(" + p35.X + "," + p35.Y + ")     フォームを動かしても、(1)と同じ値。";p36 = panel3.PointToClient(p32);label37.Text = "(6) panel3.PointToClient( (2)のスクリーン座標系 ) で求められたpanel3の左上を基準にした座標(" + p36.X + "," + p36.Y + ")";//panel4label41.Text = "panel4の左上の座標";p41 = panel4.Location;label42.Text = "(1) Locationメソッドで示される座標(" + p41.X + "," + p41.Y + ")";p42 = this.PointToScreen(p41);label43.Text = "(2) this.PointToScreen( (1)の座標系 ) で求められたスクリーン(モニタ)の左上を基準にした座標(" + p42.X + "," + p42.Y + ") <--- フォームをドラッグして動かすと、座標の表示が変わります。";p43 = this.PointToClient(p42);label44.Text = "(3) this.PointToClient( (2)のスクリーン座標系 ) で求められたフォーム(this)の左上を基準にした座標(" + p43.X + "," + p43.Y + ")      フォームを動かしても、(1)と同じ値。";p44 = panel1.PointToClient(p42);label45.Text = "(4) panel1.PointToClient( (2)のスクリーン座標系 ) で求められたpanel1の左上を基準にした座標(" + p44.X + "," + p44.Y + ")";p45 = panel2.PointToClient(p42);label46.Text = "(5) panel2.PointToClient( (2)のスクリーン座標系 ) で求められたpanel2の左上を基準にした座標(" + p45.X + "," + p45.Y + ")";p46 = panel3.PointToClient(p42);label47.Text = "(6) panel3.PointToClient( (2)のスクリーン座標系 ) で求められたpanel3の左上を基準にした座標(" + p46.X + "," + p46.Y + ")";}
フォームを移動した時に実行


*__hogeName = db.GetHogeName(HogeCode) ;
DBから名前取ったりとか

*string HogeName => dictionary.Get<string>(()=> db.GetHogeName(HogeCode) );
名前を取り出す。名前は別テーブルに入ってるのでHogeCodeを元に取得


*SqlDataAdapter adapter = new SqlDataAdapter(commandText, connectionString);
DataTableを取得
string connectionString = "環境に合わせた接続文字列";  接続文字列
string commandText = "SELECT UserId, UserName FROM Users";  Usersテーブル取得SQL

*UsersDataGrid.DataContext = ConvertDataTable(table);
DataGridへセット


*IntPtr Hbitmap = bitmap.GetHbitmap();
bitmap => bitmapHandler => ImageSource(参考）


*var sb = new StringBuilder();
指定ブラケットに一致するかどうか

*Action<int> startBracketAction = delegate (int index)*{// 文字長を超えるならブラケット処理なしif (value.Length - 1 < index + startBracket.Length - 1){return;}// ブラケットに合致しなければ処理なしif (!IsMatchBracket(index, startBracket)){return;}openCount++;if (!started){startIndex = index;}started = true;};
開始ブラケット処理

*Action<int> endBracketAction = delegate (int index)*{// 文字長を超えるならブラケット処理なしif (value.Length - 1 < index + endBracket.Length - 1){return;}// ブラケットに合致しなければ処理なしif (!IsMatchBracket(index, endBracket)){return;}openCount--;};
終了ブラケット処理


*int separater = 10;
分割ライン高さ


*var servers = (await c.GetStringAsync("http:
lst10s-sp.wni.co.jpserver_list.txt").ConfigureAwait(false)).Split('\n');

*client.OnReceiveData += Console.WriteLine;
受信したら OnReceiveData が発火し、電文が渡される


*return (ctx) => {C.Set(ctx, null);};
Outputs


*var isEqual = actual == expect
False


*Vector2 spos = RectTransformUtility.WorldToScreenPoint(Camera.main, trfTarget.position);*Vector2 pos;
World座標をUI座標へ変換

*var imgsize = new Vector2(trfTarget.rect.width * trfTarget.localScale.x,trfTarget.rect.height * trfTarget.localScale.y);
左下を計算上のpivotにする

*var resetpos = new Vector2(imgpos.x + (ressize.x * piv.x),imgpos.y + (ressize.y * piv.y));
CanvasのRectTransformから解像度とピボットを取り、左下0にする

*rct = new Vector4(resetpos.x / ressize.x, resetpos.y / ressize.y, imgsize.x / ressize.x, imgsize.y / ressize.y);
リニア化　(minx,miny,解像度xに対する横の割合,解像度yに対する高さの割合)


*public static double[][] operator +(Mat p1, Mat p2)*{double[][] d = new double[p1.R][];if (p1.C == p2.C && p1.R == p2.R){for (int i = 0; i < p1.R; i++){d[i] = new double[p1.C];for (int j = 0; j < p1.C; j++){d[i][j] = p1.Matrix_data[i][j] + p2.Matrix_data[i][j];}}}else{for (int k = 0; k < p1.R; k++){d[k] = new double[2] { 0, 0 };}}return d;}
以下　演算子オーバーロード


*List<int> parameterIds = new List<int>();
パラメータIDのリスト

*List<String> parameterNames = new List<String>();
パラメータ名のリスト

*Dictionary<int, Dictionary<int, Double>> parameterId2ValueMap = new Dictionary<int, Dictionary<int, Double>>();
パラメータID毎にデータが格納されたディクショナリ

*int parameterIdX = parameterIds[j];
データ

*else*{series.ChartType = SeriesChartType.Column;series.Color = Color.Blue;int parameterId = parameterIds[i];Dictionary<int, double> valueMap = parameterId2ValueMap[parameterId];Histogram hist = new Histogram(valueMap.Values, nBuckets, -50, 50);for (int k = 0; k < nBuckets; k++){double mid = Math.Round((hist[k].UpperBound + hist[k].LowerBound) / 2, 1);series.Points.Add(new DataPoint(mid, hist[k].Count));}}
ヒストグラムを作成

*g.TranslateTransform(0, this.height);*// -90度回転
原点を移動

*g.RotateTransform(-90f);*// 文字列を描画
-90度回転

*g.ResetTransform();*}
元に戻す


*int[] list = new int[N];
1 -> 休業日、0 -> 営業日


*input = Console.ReadLine().Split(' ');
1なら休業日、0なら営業日


*B::hoge();
HOGEHOGE namespace内にあるBクラス。読み込み可


*prepos = pos;
今のフレームの位置を次のフレームにおける前のフレームの位置として保存


*public class Destruction : MonoBehaviour*{// 玉がぶつかった回数を記憶する int hitCountint hitCount = 0;// Start後にオブジェクト自身のRigidbodyを参照して情報を格納するためのrbpublic Rigidbody rb;// GameObject型のDamageLevels、GameObjectのもの(ボログルマ3形態)のみ配列に入れるpublic GameObject[] DamageLevels;// 煙エフェクト Unity側でSmokeをドロップするpublic GameObject SmokePt;void Start(){// 自分のRigidbodyを格納して参照するrb = GetComponent<Rigidbody>();// 3段階で壊れるボログルマを配列で用意DamageLevels = new GameObject[3];// ダメージレベルが上がったら各ダメージレベルのオブジェクトを呼ぶくりかえしfor(var n = 0; n < 3; n++){// 1段階壊れたオブジェクトから後+1ずつ呼び出す、3段階目まで// 非アクティブ(ディアクティベート)状態の子オブジェクトも取得できるtransform.Find/*(子オブジェクトの参照先がみつからない、原因分からず)NullReferenceException: Object reference not set to aninstance of an objectDestruction.Start () (at Assets/Destruction.cs:35)*/DamageLevels[n] = transform.Find("damage_level1" + (n + 1)).gameObject;}}// BulletBehaviour.csから送られてきたら反応するAdd_Damageメソッドvoid Add_Damage(){// 玉がぶつかるたびに煙のsmをinstantiate(インスタンス化する、シーン中に表示させる)GameObject sm = Instantiate(SmokePt, transform.position, transform.rotation);// smoke出現後はボログルマを親とするsm.transform.parent = transform;// hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わりif (hitCount > 2)return;// ボログルマのダメージが0の状態はSmokeを非表示DamageLevels[hitCount].SetActive(false);// インクリメント hitCountという整数の値に１を足すことhitCount++;// ボログルマのダメージ1以上の状態はSmokeを表示DamageLevels[hitCount].SetActive(true);}}
P.228 玉がボログルマに着弾するとボログルマがだんだん壊れていくスクリプト

*int hitCount = 0;
玉がぶつかった回数を記憶する int hitCount

*public Rigidbody rb;
Start後にオブジェクト自身のRigidbodyを参照して情報を格納するためのrb

*public GameObject[] DamageLevels;
GameObject型のDamageLevels、GameObjectのもの(ボログルマ3形態)のみ配列に入れる

*public GameObject SmokePt;
煙エフェクト Unity側でSmokeをドロップする

*rb = GetComponent<Rigidbody>();
自分のRigidbodyを格納して参照する

*DamageLevels = new GameObject[3];
3段階で壊れるボログルマを配列で用意

*// 非アクティブ(ディアクティベート)状態の子オブジェクトも取得できるtransform.Find*/*(子オブジェクトの参照先がみつからない、原因分からず)NullReferenceException: Object reference not set to an
1段階壊れたオブジェクトから後+1ずつ呼び出す、3段階目まで

*/*(子オブジェクトの参照先がみつからない、原因分からず)NullReferenceException: Object reference not set to an
非アクティブ(ディアクティベート)状態の子オブジェクトも取得できるtransform.Find

*void Add_Damage()*{// 玉がぶつかるたびに煙のsmをinstantiate(インスタンス化する、シーン中に表示させる)GameObject sm = Instantiate(SmokePt, transform.position, transform.rotation);// smoke出現後はボログルマを親とするsm.transform.parent = transform;// hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わりif (hitCount > 2)return;// ボログルマのダメージが0の状態はSmokeを非表示DamageLevels[hitCount].SetActive(false);// インクリメント hitCountという整数の値に１を足すことhitCount++;// ボログルマのダメージ1以上の状態はSmokeを表示DamageLevels[hitCount].SetActive(true);}
BulletBehaviour.csから送られてきたら反応するAdd_Damageメソッド

*GameObject sm = Instantiate(SmokePt, transform.position, transform.rotation);*// smoke出現後はボログルマを親とする
玉がぶつかるたびに煙のsmをinstantiate(インスタンス化する、シーン中に表示させる)

*sm.transform.parent = transform;*// hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わり
smoke出現後はボログルマを親とする

*if (hitCount > 2)*return;
hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わり

*DamageLevels[hitCount].SetActive(false);
ボログルマのダメージが0の状態はSmokeを非表示

*hitCount++;
インクリメント hitCountという整数の値に１を足すこと

*DamageLevels[hitCount].SetActive(true);
ボログルマのダメージ1以上の状態はSmokeを表示

*public class Destruction : MonoBehaviour*{// 玉がぶつかった回数を記憶する int hitCountint hitCount = 0;// Start後にオブジェクト自身のRigidbodyを参照して情報を格納するためのrbpublic Rigidbody rb;// GameObject型のDamageLevels、GameObjectのもののみ配列に入れるpublic GameObject[] DamageLevels;// 煙エフェクト Unity側でSmokeをドロップするpublic GameObject SmokePt;// ビルトイン配列を定義 配列数を指定して子オブジェクトをtransform.Findで探す、damage_levelのGameObjectvoid Start(){rb = GetComponent<Rigidbody>();DamageLevels = new GameObject[3];DamageLevels[0] = transform.Find("damage_level1").gameObject;DamageLevels[1] = transform.Find("damage_level2").gameObject;DamageLevels[2] = transform.Find("damage_level3").gameObject;}/*// For文を使うともう少しすっきりする// (子オブジェクトの参照先がみつからない、原因分からず)NullReferenceException: Object reference not set to an instance of an objectDestruction.Start () (at Assets/Destruction.cs:47)void Start(){// 自分のRigidbodyを格納して参照するrb = GetComponent<Rigidbody>();// 3段階で壊れるボログルマを配列で用意DamageLevels = new GameObject[3];// ダメージレベルが上がったら各ダメージレベルのオブジェクトを呼ぶくりかえしfor(var n = 0; n < 3; n++){// 1段階壊れたオブジェクトから後+1ずつ呼び出す、3段階目まで// 非アクティブ(ディアクティベート)状態の子オブジェクトも取得できるtransform.FindDamageLevels[n] = transform.Find("damage_level1" + (n + 1)).gameObject;}}*/// BulletBehaviour.csから送られてきたら反応するAdd_Damageメソッドvoid Add_Damage(){// 玉がぶつかるたびに煙のsmをinstantiate(インスタンス化する、シーン中に表示させる)GameObject sm = Instantiate(SmokePt, transform.position, transform.rotation);// smoke出現後はボログルマを親とするsm.transform.parent = transform;// hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わりif (hitCount > 2)return;// ボログルマのダメージが0の状態はSmokeを非表示DamageLevels[hitCount].SetActive(false);// インクリメント hitCountという整数の値に１を足すことhitCount++;// ボログルマのダメージ1以上の状態はSmokeを表示DamageLevels[hitCount].SetActive(true);}}
P.228 玉がボログルマに着弾するとボログルマがだんだん壊れていくスクリプト

*int hitCount = 0;
玉がぶつかった回数を記憶する int hitCount

*public Rigidbody rb;
Start後にオブジェクト自身のRigidbodyを参照して情報を格納するためのrb

*public GameObject[] DamageLevels;
GameObject型のDamageLevels、GameObjectのもののみ配列に入れる

*public GameObject SmokePt;
煙エフェクト Unity側でSmokeをドロップする

*void Start()*{rb = GetComponent<Rigidbody>();DamageLevels = new GameObject[3];DamageLevels[0] = transform.Find("damage_level1").gameObject;DamageLevels[1] = transform.Find("damage_level2").gameObject;DamageLevels[2] = transform.Find("damage_level3").gameObject;}
ビルトイン配列を定義 配列数を指定して子オブジェクトをtransform.Findで探す、damage_levelのGameObject

*Destruction.Start () (at Assets/Destruction.cs:47)
For文を使うともう少しすっきりする
(子オブジェクトの参照先がみつからない、原因分からず)NullReferenceException: Object reference not set to an instance of an object

*rb = GetComponent<Rigidbody>();
自分のRigidbodyを格納して参照する

*DamageLevels = new GameObject[3];
3段階で壊れるボログルマを配列で用意

*// 非アクティブ(ディアクティベート)状態の子オブジェクトも取得できるtransform.Find*DamageLevels[n] = transform.Find("damage_level1" + (n + 1)).gameObject;
1段階壊れたオブジェクトから後+1ずつ呼び出す、3段階目まで

*DamageLevels[n] = transform.Find("damage_level1" + (n + 1)).gameObject;*}
非アクティブ(ディアクティベート)状態の子オブジェクトも取得できるtransform.Find

*void Add_Damage()*{// 玉がぶつかるたびに煙のsmをinstantiate(インスタンス化する、シーン中に表示させる)GameObject sm = Instantiate(SmokePt, transform.position, transform.rotation);// smoke出現後はボログルマを親とするsm.transform.parent = transform;// hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わりif (hitCount > 2)return;// ボログルマのダメージが0の状態はSmokeを非表示DamageLevels[hitCount].SetActive(false);// インクリメント hitCountという整数の値に１を足すことhitCount++;// ボログルマのダメージ1以上の状態はSmokeを表示DamageLevels[hitCount].SetActive(true);}
BulletBehaviour.csから送られてきたら反応するAdd_Damageメソッド

*GameObject sm = Instantiate(SmokePt, transform.position, transform.rotation);*// smoke出現後はボログルマを親とする
玉がぶつかるたびに煙のsmをinstantiate(インスタンス化する、シーン中に表示させる)

*sm.transform.parent = transform;*// hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わり
smoke出現後はボログルマを親とする

*if (hitCount > 2)*return;
hitcount2以上はreturn、玉からAdd_Damageが呼ばれるとメソッドの処理は終わり

*DamageLevels[hitCount].SetActive(false);
ボログルマのダメージが0の状態はSmokeを非表示

*hitCount++;
インクリメント hitCountという整数の値に１を足すこと

*DamageLevels[hitCount].SetActive(true);
ボログルマのダメージ1以上の状態はSmokeを表示

*rb = GetComponent<Rigidbody>();
自分のRigidbodyを格納して参照する

*DamageLevels = new GameObject[3];
3段階で壊れるボログルマを配列で用意

*DamageLevels[n] = GameObject.Find("damaged_transporter_01").transform.Find("damage_level1").gameObject;*}
アクティブなオブジェクト"damaged_transporter_01"をまず見つけ出し、その子オブジェクトを探索して"damage_level1"を見つける


*UnityEditor.Events.UnityEventTools.RemovePersistentListener(hogehogeEvent, TestCallback);
既にボタンにイベントを登録していたら削除する.

*UnityEditor.Events.UnityEventTools.AddPersistentListener(hogehogeEvent, TestCallback);
ボタンにイベントを登録する.

*hogehogeEvent.Invoke();
イベントの呼び出し


*DoubleAccounting = 34
二重下線(会計)


*:
以下処理


*outputCsv.WriteRecord(record);
（中略）

*outputCsv.WriteRecord(record);
（中略）


*var DSE = new DropShadowEffect();
Drop Shadow効果設定

*Line hhLine = new Line();
時針描画


*items.Select(a => a + 10).ToArray();
=> [11, 12, 13]


*float posSpeed = _positionLerpSpeed;
正面に移動

*float rotSpeed = _rotationLerpSpeed;
正面方向に回転


*.Select(s => Console.WriteLine(s))
Console.WriteLineがvoidなのでこういうことができない

*T Transform<T>(Action a) => a.DynamicInvoke() == null ? default(T) : default;*// 戻り値voidがintに変換可能!!
DynamicInvokeを使用するとnullを戻り値として取得することができる

*Transform<int>(() => Console.WriteLine());*,,,
戻り値voidがintに変換可能!!

*}
oがHogeの場合はhに代入されている

*Console.WriteLine(1 is var i ? 2 is var j ? i + j : default : default);
式中でi,jを宣言して足し算する
1 + 2 = 3;

*var res = (Func<int, int>)null is var fib ?
再帰関数も作れる
null is var は常にtrueになるので変数宣言に使用できる


*Console.WriteLine(getCount());
536870911


*var v = random.NextDouble();
0.0 - 1.0

*Func<int, int, double> func = CreateRandomNumber;
int型2つを引数にとり、double型を返す関数を登録できる

*var result = func(0, 100);
CreateRandomNumber(0, 100)が実行される

*Func<int, int, int> func1 = Add;
関数をデリゲートに登録

*Func<int, int, int> func2 = (x, y) => x + y;
ラムダ式で作った関数を登録

*Console.WriteLine(func1(10, 20));
呼び出し

*_ = WaitForAsync(5, () => Console.WriteLine("5!"));
5秒経ったらログを出す

*_ = WaitForAsync(10, () => Console.WriteLine("10!"));
10秒経ったら別のログを出す

*_ = WaitForAsync(30, () =>*{Console.WriteLine("Bye!");Dispose();});
30秒経ったらログを出して削除

*var reciprocalSum = array.Select(x => 1.0f / x)
整数配列のそれぞれの逆数の総和を計算する

*.Select(Reciprocal)
Func<int, float> に Reciprocal()を登録

*private float Reciprocal(int x)*{return 1.0f / x;}
逆数を返す関数


*lock (LockObject)*{RandomIndexList.Clear();// 条件に一致する要素のindexを取得しますfor (int i = 0; i < ie.Count(); i++){if (predicate(ie.ElementAt(i))){RandomIndexList.Add(i);}}if (RandomIndexList.Count < 1){throw new Exception("一致する要素がありません！");}// 抽出したindexから抽選して返しますint randomIndex = RandomIndexList[Random.Range(0, RandomIndexList.Count)];return ie.ElementAt(randomIndex);}
非同期実行時に同時アクセスしないようlockします

*int randomIndex = RandomIndexList[Random.Range(0, RandomIndexList.Count)];
抽出したindexから抽選して返します

*int randomIndex = TempIndices[Random.Range(0, TempIndices.Length)];
抽出したindexから抽選して返します


*Console.WriteLine(increment());
=> 102


*public void ConfigureServices(IServiceCollection services)*{services.AddApiVersioning();services.AddControllers();}
This method gets called by the runtime. Use this method to add services to the container.


*Debug.Log("<color=#ff0000ff>numの値は<
color>" + num + "<size=20>です<size>");  とコンソール画面に表示されます


*_ = 1;
ブレークポイントを置くためのタミープログラム


*if (x is { }) Console.WriteLine("Never pass");
recursive pattern is not match null


*var multi = new int[5][];
ok


*ID = value;
プロパティの値を変更してもトラッキングされない

*item.ValueList = new List<int>();
ArgumentException がスローされる

*item.Children = new List<ISampleItem>();
TargetInvocationException がスローされる
Children プロパティの型が IList<SampleItem> であればOK

*[DoNoTrack]
何れもトラッキング対象外です
DoNoTrack 属性が付与されている or setter がない or public でない

*[DoNoTrack]
何れもトラッキング対象外です
DoNoTrack 属性が付与されている or setter がない or public でない

*public virtual SampleItem Parent { get; set; }
親への参照をトラッキング対象プロパティとして持つようにしてみます

*SampleItem proxy = original.AsTrackable();
proxy の型は SampleItem クラスから継承された Castle.Proxies.SampleItemProxy クラスです

*IChangeTrackable<SampleItem> tracker = proxy.CastToIChangeTrackable();
proxy から本体／子／子リストのトラッキングオブジェクトを取得する

*childTracker = proxy.Children[proxy.Children.Count - 1].CastToIChangeTrackable();
InvalidCastException がスローされます

*originalChildren = original.Children.ToArray();
プロキシを生成するとオリジナルのリストの要素もプロキシに差し換わってしまうため、
プロキシ生成前にリストをコピー

*public interface IChangeTracking*{}
トラッキング対象であることを表すインターフェース

*public static class ChangeTrackingExtensions*{public static T AsTrackable<T>(this T target) where T : class, IChangeTracking{// ライブラリ標準の拡張メソッドを呼び出すreturn ChangeTracking.Core.AsTrackable(target);}// 残りは割愛}
IChangeTracking インターフェースに対する拡張メソッド

*return ChangeTracking.Core.AsTrackable(target);
ライブラリ標準の拡張メソッドを呼び出す

*}
残りは割愛


*public class Weekday : IState*{public void Morning() => Console.WriteLine("朝：早起きをします。");public void Afternoon() => Console.WriteLine("昼：仕事を一生懸命します。");}
平日の具体的な状態を作成します。

*public class Holiday : IState*{public void Morning() => Console.WriteLine("朝：寝ます。");public void Afternoon() => Console.WriteLine("昼：寝ます。");}
休日の具体的な状態を作成します。

*public class Context*{private IState _state;public void SetState(string dayOfWeek){switch (dayOfWeek){case "Saturday" or "Sunday":_state = new Holiday();break;default:_state = new Weekday();break;}}public void GetMorning() => _state.Morning();public void GetAfternoon() => _state.Afternoon();}
状態を管理するクラスです。


*void Start()*{}
Start is called before the first frame update

*void Update()*{// ↑キー押下時if (Input.GetKeyDown(KeyCode.UpArrow)) {transform.Rotate(new Vector3(0f, 0f, 90f));}// ↓キー押下時if (Input.GetKeyDown(KeyCode.DownArrow)) {transform.Rotate(new Vector3(0f, 0f, -90f));}// →キー押下時if (Input.GetKeyDown(KeyCode.RightArrow)) {transform.Rotate(new Vector3(90f, 0f, 0f));}// ←キー押下時if (Input.GetKeyDown(KeyCode.LeftArrow)) {transform.Rotate(new Vector3(-90f, 0f, 0f));}}
Update is called once per frame

*void Start()*{}
Start is called before the first frame update

*void Update()*{// ↑キー押下時if (Input.GetKeyDown(KeyCode.UpArrow)) {Animation(new Vector3(0f, 0f, 2f));}// ↓キー押下時if (Input.GetKeyDown(KeyCode.DownArrow)) {Animation(new Vector3(0f, 0f, -2f));}// →キー押下時if (Input.GetKeyDown(KeyCode.RightArrow)) {Animation(new Vector3(2f, 0f, 0f));}// ←キー押下時if (Input.GetKeyDown(KeyCode.LeftArrow)) {Animation(new Vector3(-2f, 0f, 0f));}}
Update is called once per frame

*private void Animation(Vector3 angle) {for(int i=0; i<45; i++){transform.Rotate(angle);}}
2度ずつ回転を45回行う

*bool isAnimate;
アニメーション中かどうか

*Vector3 angle;
回転の角度

*int count;
回転回数

*void Start()*{}
Start is called before the first frame update

*void Update()*{// アニメーションを行うかの判定if (isAnimate) {Animation();}// ↑キー押下時if (Input.GetKeyDown(KeyCode.UpArrow)) {isAnimate = true;angle = new Vector3(0f, 0f, 2f);count = 0;}// ↓キー押下時if (Input.GetKeyDown(KeyCode.DownArrow)) {isAnimate = true;angle = new Vector3(0f, 0f, -2f);count = 0;}// →キー押下時if (Input.GetKeyDown(KeyCode.RightArrow)) {isAnimate = true;angle = new Vector3(2f, 0f, 0f);count = 0;}// ←キー押下時if (Input.GetKeyDown(KeyCode.LeftArrow)) {isAnimate = true;angle = new Vector3(-2f, 0f, 0f);count = 0;}}
Update is called once per frame

*private void Animation() {transform.Rotate(angle);count++;// 45回回ったら終了if(count == 45) {isAnimate = false;}}
2度ずつ回転を45回行う

*bool isAnimate;
アニメーション中かどうか

*Vector3 angle;
回転の角度

*int count;
回転回数

*void Start()*{}
Start is called before the first frame update

*void Update()*{// アニメーションを行うかの判定if (isAnimate) {Animation();}// ↑キー押下時if (Input.GetKeyDown(KeyCode.UpArrow)) {isAnimate = true;angle = new Vector3(0f, 0f, 2f);count = 0;}// ↓キー押下時if (Input.GetKeyDown(KeyCode.DownArrow)) {isAnimate = true;angle = new Vector3(0f, 0f, -2f);count = 0;}// →キー押下時if (Input.GetKeyDown(KeyCode.RightArrow)) {isAnimate = true;angle = new Vector3(2f, 0f, 0f);count = 0;}// ←キー押下時if (Input.GetKeyDown(KeyCode.LeftArrow)) {isAnimate = true;angle = new Vector3(-2f, 0f, 0f);count = 0;}}
Update is called once per frame

*private void Animation() {transform.Rotate(angle,Space.World);count++;// 45回回ったら終了if(count == 45) {isAnimate = false;}}
2度ずつ回転を45回行う


*if (!(filterContext.ActionParameters["culture"] is string culture))
culture が null だったら、という書き方

*Uri requestUri = filterContext.HttpContext.Request.Url;
リクエストされた URI。

*string initialDefaultCulture = "ja";
URI を変更。
デフォルトは ja だけれど、クッキーに値が入っていればそれをデフォルトとする。

*filterContext.Result = new RedirectResult(uriBuilder.ToString());
リダイレクト。

*// NOTE: CurrentCulture is used to switch formats.*Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(culture);
RouteConfig で culture を ja か en に絞っているので culure の値チェックは不要。

*var cookie = new HttpCookie("culture"){Value = culture};
/ja や /en でアクセスされたらその値をクッキーに保存。


*int[] date = nextBusinessDate(M, D, d);
date[0]: 月、 date[1]: 日


*this.Opacity = 1;
main windowを表示


*float magnification_x = 0;*float magnification_y = 0;
縦横比率を変更してでも全画面に合わせる。


*using hoge;*class hoge{public void hoge(height, width){this.height = height;this.width = width;}}
C#


*int[] nextWorkingDay = new int[2];
翌営業日の日付

*switch (d)
月～木、日なら翌日が営業日
金なら3日後が営業日
土なら2日後が営業日

*static int[] NextWorkingDay(int month,int day,int a)*{for(int i = 0; i < a; i++){//翌日の日付を求めるday++;//月末を超えていた場合if(day > lastDay(month)){day = 1;month++;}if(month > 12){month = 1;}}return  new int[] { month, day };}
日付から何日後の日付を求める

*day++;
翌日の日付を求める

*static int lastDay(int month)*{switch (month){case 2:return 28;case 4:case 6:case 9:case 11:return 30;default:return 31;}}
各月の最終日を返す


*businessHours: true,
display business hours


*public event PropertyChangedEventHandler PropertyChanged = delegate { };
INotifyPropertyChanged実装

*private void RaisePropertyChanged([CallerMemberName]string propertyName = ""){if (propertyName != null)PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
INotifyPropertyChanged.PropertyChangedイベントを発生させる


*await q2wp.Qiita2WPArticle();
Qiita2WPプロジェクトの方の処理を使いまわす


*}
ここでPlayerのAttack関数を実行したい


*xmlns:Item="clr-namespace:Item"
New!

*<ContentControl prism:RegionManager.RegionName="{x:Static Item:RegionName.Ringo}">
prismのRegionNameに文字列を登録している
文字列はx:static
xmlns:ItemというnamespaceのRegionNameクラスにあるRingoプロパティ


*private const string TOP_URL = "http:
kurosu.s1009.xrea.com";

*var responce = await HpClient.GetAsync($"{TOP_URL}{url}?page={page}&per_page=100");
1ページ単位、100件取得

*var toalPage = responce.Headers.GetValues("X-WP-TotalPages").First();
100件区切りした場合のトータルのページ
例えば201件ある場合、3ページとなる

*tagArray.Merge(await this.GetList(url, ++page));
再起処理 すべてのページの要素を収集

*var json = new{作成日時date = DateTime.Parse(qiita["created_at"].ToString()).ToString("s"),公開範囲status = "publish",タイトルtitle = title,本文content = $"\n<p>{title}<a href=\"{url}\">{url}</a></p>\n",
リクエストBody作成

*date = DateTime.Parse(qiita["created_at"].ToString()).ToString("s"),公開範囲status = "publish",タイトルtitle = title,本文content = $"\n<p>{title}<a href=\"{url}\">{url}</a></p>\n",
作成日時

*status = "publish",タイトルtitle = title,本文content = $"\n<p>{title}<a href=\"{url}\">{url}</a></p>\n",
公開範囲

*title = title,本文content = $"\n<p>{title}<a href=\"{url}\">{url}</a></p>\n",
タイトル

*content = $"\n<p>{title}<a href=\"{url}\">{url}</a></p>\n",
本文

*tags = await Task.WhenAll(qiita["tags"].Select(async q => await this.GetAndAddTagListAsync(wpService, q, tagList)))
タグ(インサート処理は非同期で実行し、すべての処理が終わるのを待つ)

*var id = await wpService.InsertTag(new { name = tag["name"].ToString() });
Tag追加リクエスト

*wpTagList.Add(JToken.FromObject(new { id = id ?? -1, name = tag["name"].ToString() }));
リストに追加

*var result = await HpClient.SendAsync(request);
リクエスト

*var resultJson = JObject.Parse(await result.Content.ReadAsStringAsync());
レスポンスbody

*return resultJson["id"].Value<int>();
追加したタグのIDを返却

*Console.WriteLine(resultJson["message"].ToString());
エラーメッセージ


*[DiagnosticName("EventName1")]
引数を指定しない場合は[DiagnosticName("[メソッド名]")]と等価


*public class Model*{[Required]public string a { get; set; }}
Request Body に使用するモデルクラス

*[HttpPost]
Request されてきた値を JSON 形式で返します。

*public string Post([FromBody]Model value)*{return JsonConvert.SerializeObject(value);}
こちらも同じように Request されてきた値を JSON 形式で返します。

*public void ConfigureServices(IServiceCollection services)*{services.AddControllers().ConfigureApiBehaviorOptions(options =>{options.SuppressModelStateInvalidFilter = true;});}
Startup.cs

*public class ModelStateInvalidFilter : ActionFilterAttribute
FromBody のリクエストパラメーターが null または ModelState.IsValid == false の場合にステータスコード 400 を返すフィルタークラス
Note: もっと効率のよい実装や、わかりやすい実装があったら教えてください。

*public static class WebApiConfig*{public static void Register(HttpConfiguration config){// Web API configuration and servicesconfig.Filters.Add(new ModelStateInvalidFilter());// 以下、略 ...}}
WebApiConfig.cs

*}
以下、略 ...


*public void ConfigureServices(IServiceCollection services)*{services.AddDbContext<HeroContext>(opt => opt.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));services.AddControllers();}
This method gets called by the runtime. Use this method to add services to the container.

*// To protect from overposting attacks, please enable the specific properties you want to bind to, for*// more details see https://aka.ms/RazorPagesCRUD.
PUT: api/Heroes/5

*// more details see https://aka.ms/RazorPagesCRUD.*[HttpPut("{id}")]
To protect from overposting attacks, please enable the specific properties you want to bind to, for

*[HttpPut("{id}")]
more details see https:aka.ms/RazorPagesCRUD.


*return sum
count;  合計個数


*private const string TOP_URL = "http:
kurosu.s1009.xrea.com";

*var result = await HpClient.SendAsync(request);
リクエスト

*var resultJson = JObject.Parse(await result.Content.ReadAsStringAsync());
エラーメッセージ

*var result = await HpClient.SendAsync(request);
リクエスト

*var resultJson = JObject.Parse(await result.Content.ReadAsStringAsync());
エラーメッセージ

*var credentials = Convert.ToBase64String(Encoding.UTF8.GetBytes(this.apllicationKey));*request.Headers.Add("Authorization", $"Basic {credentials}");
Basi認証ヘッダー

*var qiitaService = new QiitaService();
Qiita記事取得

*var wpService = new WPService("ユーザID:アプリケーションパスワード");
WP記事取得

*var matchArticle = wpList.FirstOrDefault(w => w["content"]["rendered"].ToString().Contains(url));
Qiitaの記事URLが含まれる物を取得

*var json = new{公開範囲status= "publish",タイトルtitle = title,本文content = $"\n<p>{title}<a href=\"{url}\">{url}</a></p>\n"
リクエストBody作成

*status= "publish",タイトルtitle = title,本文content = $"\n<p>{title}<a href=\"{url}\">{url}</a></p>\n"
公開範囲

*title = title,本文content = $"\n<p>{title}<a href=\"{url}\">{url}</a></p>\n"
タイトル

*content = $"\n<p>{title}<a href=\"{url}\">{url}</a></p>\n"
本文

*await wpService.UpdateWPArticle(matchArticle["id"].ToString(), json);
更新

*await wpService.InsertWPArticle(json);
新規追加

*await q2wp.Qiita2WPArticle();
Qiitaの記事をWordPressに反映


*void Start()*{}
Start is called before the first frame update

*void Update()*{}
Update is called once per frame

*void Update () {this.GetComponent<Text>().text = score.toString();}
Update is called once per frame


*Debug.Log(nameList[0]);
これでもOK

*nameList[0] = "スタジオしまづアカデミア";
0番目の値を"スタジオしまづアカデミア"に変更したい

*Debug.Log(nameList[0]);
コンソールに0番目を表示したい

*Debug.Log(nameList[0]);
for文を使って以下と同じログを表示したい

*}
nameListに"スタジオしまづアカデミア"を追加したい：Addってのを使う
追加したあと、全ての値をログに表示して追加されたのを確認したい

*nameList.Add("スタジオしまづアカデミア");
nameListに"スタジオしまづアカデミア"を追加したい：Addってのを使う

*/*
以下でもOK

*}
nameListの"アンチスタジオしまづ"を消したい

*nameList.Remove("アンチスタジオしまづ");
nameListの"アンチスタジオしまづ"を消したい

*for (int i = 0; i < nameList.Count; i++)
番号指定での削除もできるよ
nameList.RemoveAt(1);

*/*
以下でもOK


*private const string URL_FIRST = "http:
kurosu.s1009.xrea.com";

*var credentials = Convert.ToBase64String(Encoding.UTF8.GetBytes("XXXX:BBBBBBB"));
TODO「Application Passwords」プラグインというプラグインを有効化にしていないせいかまだ動作しない

*var qiitaService = new QiitaService();
Qiita記事取得

*var wpService = new WPService();
WP記事取得

*var matchArticle = wpList.FirstOrDefault(w => w["content"]["rendered"].ToString().Contains(url));
Qiitaの記事URLが含まれる物を取得

*matchArticle["title"] = title;
タイトル

*matchArticle["content"]["rendered"] = $"\n<p>{title}<a href=\"{url}\">{url}</a></p>\n";
リンク部分

*var result = await wpService.UpdateWPArticle(matchArticle["id"].ToString(), matchArticle.ToString());
更新

*else*{// TODO}
記事新規追加

*await q2wp.Qiita2WPArticle();
Qiitaの記事をWordPressに反映


*tasks[index] = context.CallActivityAsync<int>("TaskActivity", index);
アクティビティ関数を並列で10回呼び出す

*await Task.WhenAll(tasks);
10個のタスクが終わるまで待つ

*Console.WriteLine("Error has occured.");
エラーが発生したことをキャッチする

*int total = tasks.Where(t => t.Status == TaskStatus.RanToCompletion).Sum(t => t.Result);
成功の結果だけ集めてくる

*var errors = tasks.Where(t => t.Status == TaskStatus.Faulted).ToList();
エラー結果だけを取得する

*string instanceId = await starter.StartNewAsync("Function2", null);*log.LogInformation($"Started orchestration with ID = '{instanceId}'.");
Function input comes from the request content.

*throw new Exception("number:" + number.ToString() + " is a mulriple of 4.");
0以外の4の倍数の時に例外をスロー


*[CreateAssetMenu(menuName = "Tools/Test")]public class Test_ScriptableObject : ScriptableObject{public int value;
右クリック Tools/Test で任意の場所に Test_ScriptableObject.asset ファイルを作成できる

*throw new System.IO.FileNotFoundException("Test_ScriptableObject does not found");
場合により Exception や

*Debug.LogWarning("Oh...");
Log 出して return null

*public T Load<T>() where T : UnityEngine.Object*{var guid = AssetDatabase.FindAssets("t:" + typeof(T).Name).FirstOrDefault();var filePath = AssetDatabase.GUIDToAssetPath(guid);if (string.IsNullOrEmpty(filePath)){}return AssetDatabase.LoadAssetAtPath<T>(filePath);}
読み込みますよ


*builder.Services.AddScoped<AppState>();
<-追加


*Console.WriteLine(Txt + "\n値を2つ入力");
(略)可変長配列を使った演算(Ls)


*long count = countDay(year, month, day);*string[] dayOfWeek = new string[] { "水", "木", "金", "土", "日", "月", "火" };
１８００年１月１日からの日数を計算する

*static long lastDay(long year,long month)*{switch (month){case 2:if(year % 400 == 0 || (year % 100 != 0 && year % 4 == 0)){return 29;}else{return 28;}case 4:case 6:case 9:case 11:return 30;default:return 31;}}
ある年月の最終日を返す

*static long[] nextDay(long year, long month, long day)*{day++;if(day > lastDay(year,month)){day = 1;month++;}if(month > 12){month = 1;year++;}return new long[] { year, month, day };}
次の日を計算するメソッド

*static long countDay(long year,long month,long day)*{long y = 1800, m = 1, d = 1;long count = 0;//400年分の日数を計算long DaysOf400Years = 365 * 400 + (400 / 400) - (400 / 100) + (400 / 4);//400の倍数年未来に飛ぶcount += ((year - 1800) / 400) * DaysOf400Years;y = year - (year - 1800) % 400;while(!(y == year && m == month && d == day)){//一日ずつ進めるcount++;long[] tomoorow = nextDay(y, m, d);y = tomoorow[0];m = tomoorow[1];d = tomoorow[2];}return count;}
１８００年１月１日からの日数を計算するメソッド

*long DaysOf400Years = 365 * 400 + (400 / 400) - (400 / 100) + (400 / 4);
400年分の日数を計算

*count += ((year - 1800) / 400) * DaysOf400Years;
400の倍数年未来に飛ぶ

*count++;
一日ずつ進める


*Vector3 dir = player.transform.position - transform.position;*//角度を取得
プレイヤーまでの方向ベクトルを取得

*float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg;
角度を取得

*IEnumerator Attack14(int c) {for(int i = 1; i < c; i++) {float angle = -(c + 1) * 10 / 2 + i * 10;NwayShot(angle);yield return new WaitForSeconds(0.02f);}AttackFlag = 0;}
らせん状に弾が飛んでいく

*IEnumerator Attack15(int NwayCount) {//最初の弾(p1として保持)float r1 = Random.Range(1, NwayCount + 1);float angle1 = -(NwayCount + 1) * 5 / 2 + r1 * 5;GameObject p = Instantiate(BossProjectilePrefab_slow2, transform.position, Quaternion.Euler(new Vector3(0.0f, 0.0f, angle1)));AudioSource.PlayClipAtPoint(BossShotSE, transform.position);yield return new WaitForSeconds(0.2f);//最初の弾からの1段階の分裂(分裂した弾をp2として保持)float r2 = Random.Range(1, NwayCount + 1);float angle2 = -(NwayCount + 1) * 5 / 2 + r2 * 5;GameObject p2=Instantiate(BossProjectilePrefab_slow2, p.transform.position, Quaternion.Euler(new Vector3(0.0f, 0.0f, angle2)));AudioSource.PlayClipAtPoint(BossShotSE, transform.position);yield return new WaitForSeconds(0.5f);//1段階で分裂したそれぞれの弾が分裂(p1とp2からそれぞれ分裂)float r3 = Random.Range(1, NwayCount + 1);float angle3 = -(NwayCount + 1) * 5 / 2 + r3 * 5;Instantiate(BossProjectilePrefab_slow2, p.transform.position, Quaternion.Euler(new Vector3(0.0f, 0.0f, angle3)));AudioSource.PlayClipAtPoint(BossShotSE, transform.position);float r4 = Random.Range(1, NwayCount + 1);float angle4 = -(NwayCount + 1) * 5 / 2 + r4 * 5;Instantiate(BossProjectilePrefab_slow2, p2.transform.position, Quaternion.Euler(new Vector3(0.0f, 0.0f, angle4)));AudioSource.PlayClipAtPoint(BossShotSE, transform.position);}
弾を発射したら数秒後に2段階分裂する

*float r1 = Random.Range(1, NwayCount + 1);
最初の弾(p1として保持)

*float r2 = Random.Range(1, NwayCount + 1);
最初の弾からの1段階の分裂(分裂した弾をp2として保持)

*float r3 = Random.Range(1, NwayCount + 1);
1段階で分裂したそれぞれの弾が分裂(p1とp2からそれぞれ分裂)


*Console.WriteLine(counter.Invoke());
3

*public string GetFullName()
指定したユーザのフルネームを取得する
今回の例題ではこのメソッドが使われている

*public string GetFirstName()*{return Find()["first_name"].ToString();}
指定したユーザの名前を取得する

*public string GetLastName()*{return Find()["last_name"].ToString();}
指定したユーザの名字を取得する

*private Dictionary<string, object> Find()*{var connection = new DBConnection();connection.Open();// SQLを作成し、DBにアクセスする// ここで時間がかかる!!Dictionary<string, object> record = connection.FindBySql("SELECT * FROM users WHERE id = ?", _userId);connection.Close();return record;}
usersテーブルから指定されたユーザIDに紐づくレコードを取得する

*Dictionary<string, object> record = connection.FindBySql(
SQLを作成し、DBにアクセスする
ここで時間がかかる!!

*private Dictionary<string, object> _cache = null;
キャッシュ用のグローバル変数を用意する

*public string GetFullName()
指定したユーザのフルネームを取得する
今回の例題ではこのメソッドが使われている

*public string GetFirstName()*{return Find()["first_name"].ToString();}
指定したユーザの名前を取得する

*public string GetLastName()*{return Find()["last_name"].ToString();}
指定したユーザの名字を取得する

*private Dictionary<string, object> Find()*{if(_cache != null){// キャッシュにすでにユーザ情報があればDBアクセスせずにキャッシュを返すreturn _cache;}var connection = new DBConnection();connection.Open();// SQLを作成し、DBにアクセスする// ここで時間がかかる!!Dictionary<string, object> record = connection.FindBySql("SELECT * FROM users WHERE id = ?", _userId);connection.Close();// キャッシュしておく_cache = record;return record;}
usersテーブルから指定されたユーザIDに紐づくレコードを取得する

*return _cache;
キャッシュにすでにユーザ情報があればDBアクセスせずにキャッシュを返す

*Dictionary<string, object> record = connection.FindBySql(
SQLを作成し、DBにアクセスする
ここで時間がかかる!!

*_cache = record;
キャッシュしておく

*public string GetFullName()
指定したユーザのフルネームを取得する
今回の例題ではこのメソッドが使われている

*public string GetFirstName()*{return Find()["first_name"].ToString();}
指定したユーザの名前を取得する

*public string GetLastName()*{return Find()["last_name"].ToString();}
指定したユーザの名字を取得する

*private Dictionary<string, object> Find()*{return FindUsingCache().Invoke();}
キャッシュするためにFindUsingCacheメソッドで作られるクロージャに処理を移動した

*private Func<Dictionary<string, object>> FindUsingCache()
usersテーブルから指定されたユーザIDに紐づくレコードを取得する
キャッシュ対応版

*Dictionary<string, object> _cache = null;
キャッシュ用の変数を用意する

*Func<Dictionary<string, object>> f = () => {if(_cache != null){// キャッシュにすでにユーザ情報があればキャッシュを返すreturn _cache;}var connection = new DBConnection();connection.Open();// SQLを作成し、DBにアクセスする// ここで時間がかかる!!Dictionary<string, object> record = connection.FindBySql("SELECT * FROM users WHERE id = ?", _userId);connection.Close();// キャッシュに入れておく_cache = record;return record;};
クロージャを作る

*return _cache;
キャッシュにすでにユーザ情報があればキャッシュを返す

*Dictionary<string, object> record = connection.FindBySql(
SQLを作成し、DBにアクセスする
ここで時間がかかる!!

*_cache = record;
キャッシュに入れておく

*return f;
クロージャを返す


*date = nextDate(date[0], date[1], date[2]);
一日進める

*static bool isLeap(int year)*{return year % 400 == 0 || year % 100 != 0 && year % 4 == 0;}
うるう年か判断するメソッド

*static int lastDay(int year, int month)*{switch(month){case 2:if (isLeap(year)){return 29;}else{return 28;}case 4:case 6:case 9:case 11:return 30;default:return 31;}}
ある年月の最終日を計算

*static int[] nextDate(int year,int month, int day)*{day++;if(day > lastDay(year, month)){day = 1;month++;}if(month > 12){month = 1;year++;}return new int[] { year, month, day };}
翌日の年月日を返す


*Reader ExecuteQuery(string query);
SQL発行関数（SELECT）

*void ExecuteNonQuery(string query);
SQL発行関数（INSERT, UPDATE, DELETE）

*void Initialize();
初期化

*void BuildSqlConnectionString();
コネクションストリングの構築（DB毎に異なるので）

*void BeginTransaction();
トランザクション管理

*private SQLiteConnection _SQLiteConnection;
Nuget で SQLite 関連は読み込み済み

*private readonly string _path;
SQLiteDB ファイルのパス

*private readonly string _fileName;
SQLiteDB ファイルの名称

*public SqliteDatabaseConnector(string path, string fileName)*{_path = path;_fileName = fileName;Initialize();}
コンストラクタ

*public void Initialize()*{BuildSqlConnectionString();_SQLiteConnection = new SQLiteConnection(_dbConnectionString);_SQLiteConnection.Open();}
初期化：DB接続を確立させる

*public void BuildSqlConnectionString()*{// DB ファイルネームが指定されなかった場合は、"default" を定義値にします。string fName = (_fileName.Length == 0) ? "default" : _fileName;if(_path.Length == 0)_dbConnectionString = $"Data Source ={fName}.db";else_dbConnectionString = $"Data Source ={_path}/{fName}.db";}
コネクションストリングを作成

*string fName = (_fileName.Length == 0) ? "default" : _fileName;
DB ファイルネームが指定されなかった場合は、"default" を定義値にします。

*public void ExecuteNonQuery(string query)*{this.ExecuteNonQuery(query, new Dictionary<string, object>());}
SQL発行


*}
･･･ 以下省略 ･･･

*var people_pagelist = await PaginatedList<Person>.CreateAsync(
･･･ 途中省略 ･･･
この部分にIQuerable<Person>selectedに、引数crt_nameとcrt_ageで指定された検索条件でデータを検索し、
sortfiledに指定されたソート条件で並べ替えを行った結果をセットする処理が記載されている。
･･･


*return new Uri("http:
localhost:8080");


*int NumberOfDays = 0;
1800年1月1日からy年m月d日の経過日数を計算

*string dayOfWeek = null;
経過に日数の7の剰余が


*//Recurrence = new string[] { "RRULE:FREQ=DAILY;COUNT=2" },
以下があるとエラーになるので・・・

*Attendees = new EventAttendee[] {new EventAttendee() { Email = "lpage@example.com" },new EventAttendee() { Email = "sbrin@example.com" },},Reminders = new Event.RemindersData(){UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
Recurrence = new string[] { "RRULE:FREQ=DAILY;COUNT=2" },

*new EventAttendee() { Email = "lpage@example.com" },new EventAttendee() { Email = "sbrin@example.com" },},Reminders = new Event.RemindersData(){UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
Attendees = new EventAttendee[] {

*new EventAttendee() { Email = "sbrin@example.com" },},Reminders = new Event.RemindersData(){UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
new EventAttendee() { Email = "lpage@example.com" },

*Reminders = new Event.RemindersData(){UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
},

*//{//    UseDefault = false,//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }//}
Reminders = new Event.RemindersData()

*UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
{

*Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
UseDefault = false,

*new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
Overrides = new EventReminder[] {

*new EventReminder() { Method = "sms", Minutes = 10 },}}};
new EventReminder() { Method = "email", Minutes = 24 * 60 },

*var calendarId = "カレンダーID";
カレンダーID

*var calApi = new CalendarAPITest(@"C:\job\TestProject\GoogleAPITest\testproject-269217-813bf9be17a5.json");
Googleカレンダーテストクラスインスタンス化

*calApi.ReadEvents(calendarId);
イベント読み取り

*var evt = calApi.InsertEvent(calendarId);
イベント追加

*calApi.UpdateEvent(calendarId, evt);
イベント更新

*var calendarId = "カレンダーID";
カレンダーID

*var calApi = new CalendarAPITest(@"C:\job\TestProject\GoogleAPITest\testproject-269217-813bf9be17a5.json");
Googleカレンダーテストクラスインスタンス化

*calApi.ReadEvents(calendarId);
イベント読み取り

*var evt = calApi.InsertEvent(calendarId);
イベント追加

*evt = calApi.UpdateEvent(calendarId, evt);
イベント更新

*calApi.DeleteEvent(calendarId, evt.Id);
イベント削除


*theString.Should().Be(string.Empty);
Fluent Assertions で文字列が空文字であることを確認する例

*theString.Is(string.Empty);
Chaining Assertion で文字列が空文字であることを確認する例

*theInt.Should().BeInRange(0, 10);
Fluent Assertions で対象の値が0以上10以下であることを確認する例

*theInt.Is(value => value >= 0 && value <= 10);
Chaining Assertion で対象の値が0以上10以下であることを確認する例

*collection.Should().HaveCountGreaterThan(3);
Fluent Assertions でコレクションの要素に3より大きい値があることを確認する例
(何十個もあるコレクションのメソッドの中から適したメソッドを使う)

*collection.Any(c => c > 3).Is(true);
Chaining Assertion でコレクションの要素に3より大きい値があることを確認する例
(慣れ親しんだ Linq to Objects を使う)

*public class MyClass*{private string PrivateMethod(int number){return number;}}
privateメンバーを持つクラス

*int number = myClass.AsDynamic().PrivateMethod(3);
AsDynamic()の戻り値は dynamic型
AsDynamic()に続けて呼び出したいメンバーを書くことでリフレクションで実行される

*public class MyClass*{public string Name{get;set;}public MyClass Child{get;set;}public MyClass Clone(){// 複製する処理}}
テスト対象クラス

*}
複製する処理

*var myClass = new MyClass(){Name = "Test",Child = new MyClass(),};
テスト対象クラスを作成する

*var clone = myClass.Clone();
複製する

*clone.IsStructuralEqual(myClass);
参照しているChildのフィールド値も含めて一致することを確認


*SelectAll(listview1, true);
全選択

*SelectAll(listview1, false);
選択解除

*}
iを使用した処理


*}
初期化処理（ただし、この時点ではまだ矩形情報が取れない！）
CreateWindowとかして、帰ってきたHWNDを返す

*}
Win32の後半のメッセージループの部分
DirectXのUpdate（Render）処理はここで

*}
終了処理

*IntPtr hwnd = CreateWindowEx(0, "STATIC", "",WindowStyle.WS_CHILD | WindowStyle.WS_VISIBLE,0, 0,(int)ActualWidth, (int)ActualHeight,
Win32のWindowの初期化

*app = Init(hwnd, (int)ActualWidth, (int)ActualHeight);
DirectX12の初期化
BuildWindowCoreでInitしたかったが、は矩形が0のままなのでDepthBufferが作れない。
本当はリサイズも考慮してデバイスのInitとRenderTarger/DepthBufferの生成を分けるべき。

*Render(app);
DirectX12の描画（のリクエスト）処理

*DestroyWindow(hwnd.Handle);
Win32のWindowとDirectX12の終了処理


*//Recurrence = new string[] { "RRULE:FREQ=DAILY;COUNT=2" },
以下があるとエラーになっていたのでコメントアウト・・・

*Attendees = new EventAttendee[] {new EventAttendee() { Email = "lpage@example.com" },new EventAttendee() { Email = "sbrin@example.com" },},Reminders = new Event.RemindersData(){UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
Recurrence = new string[] { "RRULE:FREQ=DAILY;COUNT=2" },

*new EventAttendee() { Email = "lpage@example.com" },new EventAttendee() { Email = "sbrin@example.com" },},Reminders = new Event.RemindersData(){UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
Attendees = new EventAttendee[] {

*new EventAttendee() { Email = "sbrin@example.com" },},Reminders = new Event.RemindersData(){UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
new EventAttendee() { Email = "lpage@example.com" },

*Reminders = new Event.RemindersData(){UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
},

*//{//    UseDefault = false,//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }//}
Reminders = new Event.RemindersData()

*UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
{

*Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
UseDefault = false,

*new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
Overrides = new EventReminder[] {

*new EventReminder() { Method = "sms", Minutes = 10 },}}};
new EventReminder() { Method = "email", Minutes = 24 * 60 },

*var request = new EventsResource.ListRequest(this.Serive, calendarId);
ここで第2引数にサービスアカウントに公開したカレンダーIDを指定する

*Attendees = new EventAttendee[] {new EventAttendee() { Email = "lpage@example.com" },new EventAttendee() { Email = "sbrin@example.com" },},Reminders = new Event.RemindersData(){UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
Recurrence = new string[] { "RRULE:FREQ=DAILY;COUNT=2" },

*new EventAttendee() { Email = "lpage@example.com" },new EventAttendee() { Email = "sbrin@example.com" },},Reminders = new Event.RemindersData(){UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
Attendees = new EventAttendee[] {

*new EventAttendee() { Email = "sbrin@example.com" },},Reminders = new Event.RemindersData(){UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
new EventAttendee() { Email = "lpage@example.com" },

*Reminders = new Event.RemindersData(){UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
},

*//{//    UseDefault = false,//    Overrides = new EventReminder[] {//        new EventReminder() { Method = "email", Minutes = 24 * 60 },//        new EventReminder() { Method = "sms", Minutes = 10 },//    }//}
Reminders = new Event.RemindersData()

*UseDefault = false,Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
{

*Overrides = new EventReminder[] {new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
UseDefault = false,

*new EventReminder() { Method = "email", Minutes = 24 * 60 },new EventReminder() { Method = "sms", Minutes = 10 },}}};
Overrides = new EventReminder[] {

*new EventReminder() { Method = "sms", Minutes = 10 },}}};
new EventReminder() { Method = "email", Minutes = 24 * 60 },

*var calendarId = "カレンダーID";
カレンダーID

*var calApi = new CalendarAPITest(@"C:\job\TestProject\GoogleAPITest\testproject-269217-813bf9be17a5.json");
Googleカレンダーテストクラスインスタンス化

*calApi.ReadEvents(calendarId);
イベント読み取り

*calApi.InsertEvent(calendarId);
イベント追加


*return;
DB has been seeded

*);
こんな感じで投入データを書き加えていく。


*advWatcher.Stop();
デバイスを見つけたので止める

*BluetoothLEDevice device = await BluetoothLEDevice.FromBluetoothAddressAsync(args.BluetoothAddress);
接続

*addLog("get service");
サービス・キャラクタリスティックを列挙

*var gattService = device.GetGattService(switchUUID);
サービスUUIDを使って目的のサービスを取得
asyncバージョンは使えない

*var characteristics = gattService.GetCharacteristics(commandUUID);
キャラクタリスティックUUIDを使って目的のキャラクタリスティックを取得
asyncバージョンは使えない


*WriteIndented = true,UNICODEエスケープシーケンスにしない対象を指定。やらないと、ASCII文字以外すべてが　あ → \u3042　みたいな感じでエスケープされる。Encoder = System.Text.Encodings.Web.JavaScriptEncoder.Create(System.Text.Unicode.UnicodeRanges.All),};
trueだと出力を整形する

*Encoder = System.Text.Encodings.Web.JavaScriptEncoder.Create(System.Text.Unicode.UnicodeRanges.All),};
UNICODEエスケープシーケンスにしない対象を指定。やらないと、ASCII文字以外すべてが　あ → \u3042　みたいな感じでエスケープされる。


*var targetMac = "*******";
アプリで調べたMAC

*BluetoothLEDevice device = await BluetoothLEDevice.FromBluetoothAddressAsync(args.BluetoothAddress);
接続

*var gattService = await device.GetGattServicesForUuidAsync(switchUUID);*if (gattService.Status == GattCommunicationStatus.Success)
サービスUUIDを使って目的のサービスを取得

*var characteristics = await gattService.Services.FirstOrDefault().GetCharacteristicsForUuidAsync(commandUUID);
コマンド送信用UUIDを使ってキャラクタリスティックを取得


*using System;
簡単な例外処理をしてみよう

*try*{Console.WriteLine("Hello World");int number = 0;// 0で割り算できないためエラーが起きる// ここで処理が中断され、catchブロックに飛ぶint answer = 100 / number;Console.WriteLine(answer);}
例外が投げられる可能性のあるコード

*int answer = 100 / number;
0で割り算できないためエラーが起きる
ここで処理が中断され、catchブロックに飛ぶ

*catch(Exception e)
例外が起きた場合の処理
Exception e の中に例外の詳細情報が格納されている

*finally*{Console.WriteLine("Hello C#");}
例外発生の有無にかかわらず実行したいコード

*using System;
throwで意図的に例外を投げよう

*throw new Exception();
意図的に例外を投げる

*catch (Exception e)*{Console.WriteLine("例外が発生しました。");Console.Error.WriteLine(e);}
throw で呼ばれる


*Direction direction = Direction.DOWN;
ここはDirection.DOWNでなくてもOK


*// at ~/.credentials/calendar-dotnet-quickstart.json*private static string[] Scopes = { CalendarService.Scope.CalendarReadonly };
If modifying these scopes, delete your previously saved credentials

*private static string[] Scopes = { CalendarService.Scope.CalendarReadonly };
at ~/.credentials/calendar-dotnet-quickstart.json

*var service = new CalendarService(new BaseClientService.Initializer(){HttpClientInitializer = credential,ApplicationName = ApplicationName,});
Create Google Calendar API service.

*var request = new EventsResource.ListRequest(service, "公開したカレンダーのカレンダーID");
おそらく不必要
Define parameters of request.
var request = service.Events.List("primary");
request.TimeMin = DateTime.Now;
request.ShowDeleted = false;
request.SingleEvents = true;
request.MaxResults = 10;
request.OrderBy = EventsResource.ListRequest.OrderByEnum.StartTime;
ここで第2引数にサービスアカウントに公開したカレンダーIDを指定する


*var canvas = new RenderTargetBitmap((int)RouletteWhole.ActualWidth, (int)RouletteWhole.ActualHeight, 96, 96, PixelFormats.Pbgra32);
BitmapSourceの派生クラス「RenderTargetBitmap」で、画像を取ってくる
「RouletteWhole」は、Gridの名前。

*using (var stream = new MemoryStream()){BitmapEncoder encoder = new BmpBitmapEncoder();
BmpBitmapEncoderに画像を入れる

*var bitmap = new System.Drawing.Bitmap(stream);
BmpBitmapEncoderからSystem.Drawing.Bitmapをつくる


*Console.WriteLine(addDelegate());
(4-2)


*PluginManager?.DoSomething?.Invoke();
連携先の呼び出し、なければ何もしない


*using (var listener = new HttpListener()){ローカルの8080番ポート(ngrok起動時のオプションで指定した番号)で待ち受け開始。ngrokが同じローカルマシンで動いているので、"127.0.0.1"だけで待ち受ければよい。(外部の環境からリクエストを受ける必要がない)また、"/webhook"のパスも入れておく。Prefix指定時は、"/"で終わるようにしておく必要がある。listener.Prefixes.Add("http:127.0.0.1:8080/webhook/");
System.Net.HttpListenerを利用してサーバを実装します。

*listener.Start();
ローカルの8080番ポート(ngrok起動時のオプションで指定した番号)で待ち受け開始。
ngrokが同じローカルマシンで動いているので、"127.0.0.1"だけで待ち受ければよい。
(外部の環境からリクエストを受ける必要がない)
また、"/webhook"のパスも入れておく。Prefix指定時は、"/"で終わるようにしておく必要がある。
listener.Prefixes.Add("http:127.0.0.1:8080/webhook/");
HttpListenerの待ち受けを開始します。

*Task.Run(
スレッドプール上で待ち受けるようにする。
今回は1スレッドだが、例えばループで64回Task作成すれば、64スレッドで待ち受けるようになる。

*var context = await listener.GetContextAsync();
このサンプルの実装では、whileブロック内で例外が発生すると後続の待ち受けも中断されます。
実際には、適切に例外を処理する必要があります。
どの例外をcatchすべきかは、whileブロック内での処理内容にもよります。
catchしすぎると、意図せずループが続く場合もあるので注意が必要です。
基本的には、例外が発生しても待ち受けを継続したいような場合の例外は、whileブロックの中、
待ち受けを継続しても意味がないような例外は、whileブロックの外側で受けるように実装します。
先ほど登録したアドレス、ポート、パスに合致するリクエストが来ると、処理用のContextが取得できる。

*var request  = context.Request;
リクエストとレスポンス処理用のインスタンス取得。

*response.StatusCode = 204;
Webhook通知元の仕様にもよるが、HTTPのPOSTかGETかで通知が来る前提にして、
それ以外は、"204 No Content"を返す。

*response.ContentType = "application/json";
以下、レスポンスで何を返すべきかは通知元のサービス側の仕様にもよる。
"204 No Content"を返せばいい場合は、以下にコメントアウトした1行だけでBody出力不要。
response.StatusCode = 204;
レスポンスヘッダで、Content-Type: application/jsonにする。

*using (var writer = new StreamWriter(response.OutputStream)){writer.Write("{\"status\" : \"OK\"}");
レスポンスのBodyは決め打ちで書き込む。

*response.Close();
ResponseはClose()を呼ぶ必要があります。

*Console.WriteLine("終了するには何かキーを押してください。");
何かキーを押したら終了させる。


*string uri = "http:
localhost";


*MySqlCommand selectCommand = new MySqlCommand("SELECT * FROM MyTable", conn);
SQL発行

*public static void Main{MySqlConnection mySqlConnection = new MySqlConnection("ConnectionString");mySqlConnection.Open();var tableA = getTable("tableA");var tableB = getTable("tableB");}
メイン

*public async Task<DataReader> getTable(string tableName){using (var command = mySqlConnection.CreateCommand()) {command.CommandText = $"SELECT * FROM {tableName}";using (var reader = command.ExecuteReaderAsync()) {return reader;}}}
取得

*public Dictionary<string, Dictionary<string, string>> getTable(string tableName){using (var command = mySqlConnection.CreateCommand()) {command.CommandText = $"SELECT * FROM {tableName}";using (var reader = command.ExecuteReader()) {if (reader.HasRows) {while (reader.Read()) {JObject line = new JObject();for (int i = 0; i < reader.FieldCount; i++) {line.Add(reader.GetName(i), reader.GetString(i));}ret.Add(reader.GetString("id"), line);}}}}return ret;}
取得

*public Dictionary<string, Dictionary<string, string>> getTable(string tableName){using (MySqlConnection mySqlConnection = new MySqlConnection("ConnectionString")) {mySqlConnection.Open();using (var command = mySqlConnection.CreateCommand()) {command.CommandText = $"SELECT * FROM {tableName}";using (var reader = command.ExecuteReader()) {if (reader.HasRows) {while (reader.Read()) {var line = new Dictionary<string, string>();for (int i = 0; i < reader.FieldCount; i++) {line.Add(reader.GetName(i), reader.GetString(i));}ret.Add(reader.GetString("id"), line);}}}}}return ret;}
取得


*conn.Open();
接続文字列を利用してSQLDatabaseに接続

*var rows = cmd.ExecuteScalar();*log.LogInformation($"{rows} rows were updated");
SQLの実行はココ selectなのでExecuteScalarクラスを利用

*var rowsrows = cmdcmd.ExecuteNonQuery();
SQLの実行はココ insertなのでExecuteNonQueryクラスを利用


*var q = driver.FindElementByName("q");
任意のブラウザ操作処理 ↓↓↓
driver.Url = "https:www.google.com";

*}
任意のブラウザ操作処理 ↑↑↑


*using UniRx.Triggers;
これ必要


*col = smoothstep(0.5, 0.51, col);
境界をなめらかに

*_Color.a *= step(1-col.a, 0.01);
一定以下のalphaはゼロにする


*Vector3 distancePosition;
追加 半径設定用のベクトル

*void Awake()*{speed = 50.0f;//半径設定 高さをカメラと同一にすることで距離をそのまま半径として利用できるdistancePosition = new Vector3(parent.transform.position.x, transform.position.y, parent.transform.position.z);distance = Vector3.Distance(distancePosition, transform.position);}
Start is called before the first frame update

*distancePosition = new Vector3(parent.transform.position.x, transform.position.y, parent.transform.position.z);*distance = Vector3.Distance(distancePosition, transform.position);
半径設定 高さをカメラと同一にすることで距離をそのまま半径として利用できる

*void Update()*{float x = Input.GetAxis("RightHorizontal");float y = Input.GetAxis("RightVirtical");//等速円運動をする物体の角速度(rad/s)の公式は 角速度(ベクトル) = 速度 / 半径 もしくは 角速度(ベクトル) = 角度 / 時間 (2π * 半径 / 時間)//今回は角速度(ベクトル) = 2π * 半径 / 時間 を利用する//今回の場合、秒間72°移動する処理であるfloat radSpeedValue = 2 * Mathf.PI * distance / 5.0f; //変更//RotateAroundと同等の動きをするVector3 radSpeed = x * transform.right * radSpeedValue;transform.position += radSpeed * Time.deltaTime;//振動を防ぐためにMathf.Clampは利用していない//振動を防ぐ方法として一定以上もしくは以下になったらそれ以上動きを足さない処理を利用するfloat eulerAnglesX = transform.eulerAngles.x;if (!((eulerAnglesX < 180 && eulerAnglesX > 89.0f && y > 0) || (eulerAnglesX > 180 && eulerAnglesX < 271.0f && y < 0)))transform.RotateAround(parent.transform.position, transform.right, y * speed * Time.deltaTime);transform.LookAt(parent.transform);//半径設定 高さをカメラと同一にすることで距離をそのまま半径として利用できるdistancePosition = new Vector3(parent.transform.position.x, transform.position.y, parent.transform.position.z);//y軸となす角度によって距離が変動するため、毎フレーム更新distance = Vector3.Distance(distancePosition, transform.position);}
Update is called once per frame

*今回は角速度(ベクトル) = 2π * 半径 / 時間 を利用する今回の場合、秒間72°移動する処理であるfloat radSpeedValue = 2 * Mathf.PI * distance / 5.0f; 変更
等速円運動をする物体の角速度(rad/s)の公式は 角速度(ベクトル) = 速度 / 半径 もしくは 角速度(ベクトル) = 角度 / 時間 (2π * 半径 / 時間)

*Vector3 radSpeed = x * transform.right * radSpeedValue;
今回は角速度(ベクトル) = 2π * 半径 / 時間 を利用する
今回の場合、秒間72°移動する処理である
float radSpeedValue = 2 * Mathf.PI * distance / 5.0f; 変更
RotateAroundと同等の動きをする

*float eulerAnglesX = transform.eulerAngles.x;
振動を防ぐためにMathf.Clampは利用していない
振動を防ぐ方法として一定以上もしくは以下になったらそれ以上動きを足さない処理を利用する

*distancePosition = new Vector3(parent.transform.position.x, transform.position.y, parent.transform.position.z);*//y軸となす角度によって距離が変動するため、毎フレーム更新
半径設定 高さをカメラと同一にすることで距離をそのまま半径として利用できる

*distance = Vector3.Distance(distancePosition, transform.position);*}
y軸となす角度によって距離が変動するため、毎フレーム更新


*outputQueueItem.Add(name);
パラメーターを使用してキュー メッセージを作成するコードを追加


*public void Pc1()*{which_cake += 1;Debug.Log("which_cake: " + which_cake);}
食材側で呼び出される、判定値を変更

*public int plus = 1;
足す値をインスペクター上で指定

*int p = plus;
ループ用の変数を定義


*var secretValue = _configuration[secretName];
★配列みたいなもので一致しているものだけとっている？


*const string ServiceBusConnectionString = "Endpoint=sb:
***********.servicebus.windows.net;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=***********";


*string shopifyMpKey = "YOUR SECRET KEY HERE";*var sp = new ShopifyMultipassTokenGenerator.ShopifyMultipass(shopifyMpKey, "gyrocanopy-delivery-motor.myshopify.com");
To generate a valid multipass login token, you need the secret given to you in your Shopify admin.


*return DateTime.Today.Year - this.birth.Year + 1;
数え年


*else if (i == columns.Length - 1) sql.Append($", {column} = :{column.ToPascal()} ");
最後


*private static async IAsyncEnumerable<SampleData> GetSampleData()*{await Task.Yield();for (int i = 0; i < 10; ++i){yield return new SampleData(i);}}
10個のオブジェクトを返す


*return true;
それ以外はOKとする(setされた値になる)

*public SimpleUserControl()*{InitializeComponent();}
コンストラクタ

*private void MyTxt_TextChanged(object sender, TextChangedEventArgs e)*{Console.WriteLine(MethodBase.GetCurrentMethod().Name);// (仮にここでMyTextPropを書き換えたとしても画面側(DispText)には伝わらない！！！！)}
テキストが変化したときのイベント

*}
(仮にここでMyTextPropを書き換えたとしても画面側(DispText)には伝わらない！！！！)


*var dump = ObjectDumper.Dump(user);
データ表示したい型をuserに代入するとstringに変換される

*void Start()*{test = this.gameObject.GetComponent<Text>();//API送るなにか作った想定APIManager.Api(hoge, GetRanking_Success, GetRanking_Failure);}
Start is called before the first frame update

*APIManager.Api(hoge, GetRanking_Success, GetRanking_Failure);
API送るなにか作った想定

*GetRankingResponseForm getData = data as GetRankingResponseForm;
受け取りたい型として変換

*string dump = ObjectDumper.Dump(getData);
受け取った型をstringに変換

*test.text = "成功\n"+dump;
表示


*.Build();
誕生日をセットしていないのでコンパイルエラーにしたい


*float fadeSpeed = 0.75f;
透明度が変わるスピード

*public Image fadeImage;
画面をフェードさせるための画像をパブリックで取得

*float red, green, blue, alfa;
画像のRGBA値設定用

*string afterScene;
シーン遷移のための型

*IEnumerator fadeInCoroutine;
フェードイン用のコルーチン

*IEnumerator fadeOutCoroutine;
フェードアウト用のコルーチン

*void Start()*{fadeInCoroutine = FadeIn();fadeOutCoroutine = FadeOut();DontDestroyOnLoad(this);SetRGBA(0, 0, 0, 1);StartCoroutine(fadeInCoroutine);//シーン遷移が完了した際にフェードインを開始するように設定SceneManager.sceneLoaded += fadeInStart;}
Start is called before the first frame update

*SceneManager.sceneLoaded += fadeInStart;
シーン遷移が完了した際にフェードインを開始するように設定

*void fadeInStart(Scene scene,LoadSceneMode mode)*{fadeInCoroutine = FadeIn();StartCoroutine(fadeInCoroutine);}
シーン遷移が完了した際にフェードインを開始するように設定

*alfa = Mathf.MoveTowards(alfa, 0f, fadeSpeed * Time.deltaTime);
不透明度を徐々に下げる

*SetColor();
変更した透明度を画像に反映させる関数を呼ぶ

*alfa = Mathf.MoveTowards(alfa, 1f, fadeSpeed * Time.deltaTime);
不透明度を徐々に上げる

*SetColor();
変更した透明度を画像に反映させる関数を呼ぶ

*void SetColor()*{fadeImage.color = new Color(red, green, blue, alfa);}
画像に色を代入する関数

*public void SetRGBA(int r, int g, int b, int a)*{red = r;green = g;blue = b;alfa = a;}
色の値を設定するための関数


*...
必要ならここになにかを記述


*return;
ボタン位置から得られたGameObjectとボタンのGameObjectが異なる＝別のもので遮られている ので処理しない


*var findEl = root.SelectSingleNode($"
testBtestTag[text()='{value1}']");

*doc.Save(Path.Combine(Environment.CurrentDirectory, "test.xml"));
xml保存


*var original = RenderTexture.active;
RenderTextureからTexture2Dに変換

*int p1Index = Triangles[id.x * 3];
3角ポリゴンをつくる3頂点のインデックスを取得

*float2 uv1 = UVs[p1Index];
3頂点に対応したuv座標を取得

*uint2 p1Pos = uint2(uv1.x * Width, uv1.y * Height);
テクスチャの座標に変換

*void drawline(uint2 p1, uint2 p2, float4 color) {int2 diffp12 = int2(p2.x-p1.x, p2.y-p1.y);float distp12 = distance(p1, p2);for (int i = 0; i < distp12; i++){UVMap[p1 + diffp12 / distp12 * i] = color;}}
2点間に線を引く


*private const string BackButtonKey = "__BackButton";
←自作したタグヘルパーのname属性と同じであること。

*public override void OnActionExecuting(ActionExecutingContext context)*{var form = context.HttpContext.Request.Form;var factory = context.HttpContext.RequestServices.GetService(typeof(ITempDataDictionaryFactory)) as ITempDataDictionaryFactory;// ※Post先アクションメソッド(EditとかCreate)の第一引数と、確認画面で定義する「@model」は同じ型であること。※var parameter = context.ActionArguments.FirstOrDefault();// 登録ボタンが押された場合if (form.Any(f => f.Key == SubmitButtonKey)){// そのままアクションメソッドのpost処理を実行する。return;}// 確認ボタンが押された場合var viewName = (string)context.RouteData.Values["Action"];if (form.Any(f => f.Key == ConfirmButtonKey)){// モデルの検証でエラーが発生しているか調べるif (!context.ModelState.IsValid){// Viewに戻りエラーを表示するreturn;}// 確認画面を表示するためにビュー名を変更viewName += ViewSuffix;}var controller = context.Controller as Controller;// ビューを表示する（戻るボタンを押した場合は入力内容そのままで戻る）context.Result = new ViewResult{ViewName = viewName,// Viewにモデルの内容を渡すために必要。ViewのModelに値が入る。ViewData = new ViewDataDictionary(controller.ViewData) { Model = parameter.Value }};}
アクションメソッド実行前処理

*var parameter = context.ActionArguments.FirstOrDefault();
※Post先アクションメソッド(EditとかCreate)の第一引数と、確認画面で定義する「@model」は同じ型であること。※

*return;
そのままアクションメソッドのpost処理を実行する。

*var viewName = (string)context.RouteData.Values["Action"];
確認ボタンが押された場合

*return;
Viewに戻りエラーを表示する

*viewName += ViewSuffix;
確認画面を表示するためにビュー名を変更

*context.Result = new ViewResult{ViewName = viewName,Viewにモデルの内容を渡すために必要。ViewのModelに値が入る。ViewData = new ViewDataDictionary(controller.ViewData) { Model = parameter.Value }};
ビューを表示する（戻るボタンを押した場合は入力内容そのままで戻る）

*ViewData = new ViewDataDictionary(controller.ViewData) { Model = parameter.Value }};
Viewにモデルの内容を渡すために必要。ViewのModelに値が入る。

*public override void OnActionExecuted(ActionExecutedContext context)*{}
アクションメソッド実行後処理


*void Start()*{}
Start is called before the first frame update

*void Update()*{if (Input.GetKey(KeyCode.UpArrow)){transform.position += new Vector3(0,0,0.1f);}if (Input.GetKey(KeyCode.DownArrow)){transform.position += new Vector3(0,0,-0.1f);}if (Input.GetKey(KeyCode.RightArrow)){transform.position += new Vector3(0.1f,0,0);}if (Input.GetKey(KeyCode.LeftArrow)){transform.position += new Vector3(-0.1f,0,0);}}
Update is called once per frame


*var sortedTimes = times.Select(time => new DepatureTime(time))
発時刻クラス型に変換した後、経過時間（分）の昇順でソートして、
最後に時刻文字列に戻してList化している。


*rb.AddForce(1.0f, 2.0f, -1.0f);
加える力のベクトルをVectorで入れる


*DataSourceConfig config = new FileConfig(){Name = "file1",FilePath = @"d:\test.csv"};
基底型で宣言

*FileConfig config = new FileConfig(){Name = "file1",FilePath = @"d:\test.csv"};
派生型で宣言

*DataSourceConfig config = new FileConfig(){Name = "file1",FilePath = @"d:\test.csv"};
基底型で宣言

*return JsonSerializer.Serialize(config, config.GetType(), GetOptions());
引数でインスタンスの型を渡す

*DataSourceConfig config = new FileConfig(){Name = "file1",FilePath = @"d:\test.csv"};
基底型で宣言

*return JsonSerializer.Serialize<object>(config, GetOptions());
ジェネリックパラメーターで object を指定する

*public class ApplicationConfig*{[JsonIgnore]public DataSourceConfig DataSource { get; set; }[JsonPropertyName("DataSource")][Browsable(false)][EditorBrowsable( EditorBrowsableState.Never)]public object DataSourceObject{get { return DataSource; }set { DataSource = (DataSourceConfig)value; }}}
using System.Text.Json.Serialization;


*anim.SetBool("left_long", true);
押した時

*anim.SetBool("left_long", true);
長押しの時

*anim.SetBool("left_long",false);
指を離した時

*anim.SetBool("right_long", true);
押した時

*anim.SetBool("right_long", true);
長押しの時

*anim.SetBool("right_long",false);
指を離した時


*var worldDirectedLocalScale
localScaleを表すベクトルをワールドの向きに変換

*var scaleUnaffectedByParents
ワールド上で上記ベクトルを示す場合のローカル上での表現方法を算出
これがlocalScale設定値の大きさをワールド上で実現するために必要なlocalScaleとなる


*var newReader = jobject.CreateReader();
As JsonReader cannot be used twice, create new one and pass it.


*public static int Gcd(int a, int b)*{var x = 0;while (true){// 割り切れたらif (a % b == 0){return b;}else{x = a % b;a = b;b = x;}}}
最大公約数

*public static int Lcm(int a, int b)*{var x = Gcd(a, b);return a * b / x;}
最小公倍数


*public class WeatherForecastWithPOCOs*{public DateTimeOffset Date { get; set; }public int TemperatureCelsius { get; set; }public string Summary { get; set; }public string SummaryField;public IList<DateTimeOffset> DatesAvailable { get; set; }public Dictionary<string, HighLowTemps> TemperatureRanges { get; set; }public string[] SummaryWords { get; set; }}
展開する先のクラス構造

*string jsonString = "{\"Date\":\"2019-08-01T00:00:00-07:00\",\"TemperatureCelsius\":25,\"Summary\":\"Hot\",\"DatesAvailable\":[\"2019-08-01T00:00:00-07:00\",\"2019-08-02T00:00:00-07:00\"],\"TemperatureRanges\":{\"Cold\":{\"High\":20,\"Low\":-10},\"Hot\":{\"High\":60,\"Low\":20}},\"SummaryWords\":[\"Cool\",\"Windy\",\"Humid\"]}";
JSON文字列の例

*var weatherForecast = JsonConvert.DeserializeObject<WeatherForecastWithPOCOs>(jsonString);
デシリアライズ

*var weatherForecast = JsonConvert.DeserializeObject(jsonString);
Newtonsoft.Jsonを使う

*JObject weatherForecast = JObject.Parse(jsonString);
デシリアライズ

*Console.WriteLine("Date: " + weatherForecast["Date"].ToString());
直下の値を取得

*Console.WriteLine("TemperatureRanges_Cold_High: " + weatherForecast["TemperatureRanges"]["Cold"]["High"].ToString());
入れ子の値を取得

*Console.WriteLine("TemperatureRange Key: " + ((JProperty)TemperatureRange).Name);
キー

*Console.WriteLine("TemperatureRange Value: " + TemperatureRange.First["High"]);
値

*HighLowTemps highLowTemps = TemperatureRange.First.ToObject<HighLowTemps>();
一部だけ定型クラスに取り出したい

*weatherForecast["hoge"] = "fuga";
トップレベルに追加

*weatherForecast.Property("Summary").Remove();
削除

*((JArray)weatherForecast["DatesAvailable"]).Add("2020-02-02T02:02:02-02:00");*// {}に追加
[]に追加

*((JObject)weatherForecast["TemperatureRanges"]).Last.AddAfterSelf(*new JProperty("Lukewarm", JObject.Parse(@"{""High"": 10,""Low"": 10}"))
{}に追加

*weatherForecast["TemperatureRanges"]["Absolute"] = JObject.Parse(@"{""High"": -273,""Low"": -273}");
これでもいい

*var jsonStringAfter = JsonConvert.SerializeObject(weatherForecast);
JSON文字列に戻す


*public void Execute(string utageSceneName, string label)*{// 実行するラベル名を保存ExecuteScenario.Label = label;StartCoroutine(ExecuteScenarioCoroutine(utageSceneName));}
他シーンのUtage呼び出し

*ExecuteScenario.Label = label;
実行するラベル名を保存

*private bool IsSceneLoaded;
シーン読み込みが完了したか

*private void OnSceneLoaded(Scene scene, LoadSceneMode mode)*{IsSceneLoaded = true;}
シーン読み込み完了イベント

*private IEnumerator ExecuteScenarioCoroutine(string utageSceneName)*{IsSceneLoaded = false;SceneManager.LoadScene(utageSceneName);yield return new WaitUntil(() => IsSceneLoaded);}
シナリオの呼び出しCorotine

*private IEnumerator Execute()*{// Utage Engine の起動を待つyield return new WaitUntil(() => !Engine.IsLoading);// 機能呼び出しyield return StartCoroutine(ExecuteLabel());}
シナリオを呼び出す

*yield return new WaitUntil(() => !Engine.IsLoading);
Utage Engine の起動を待つ

*yield return StartCoroutine(ExecuteLabel());
機能呼び出し

*private IEnumerator ExecuteLabel()*{// 起動ラベルのラベル名を取得string label = ExecuteScenario.Label;// 機能呼び出しTitle.Close();MainGame.OpenStartLabel(label);yield return null;}
機能呼び出し

*string label = ExecuteScenario.Label;
起動ラベルのラベル名を取得

*Title.Close();
機能呼び出し

*public static string Label;
呼び出すラベル


*++index;
"\r"は追加せずにスキップ

*return true;
後続に文字がないか、半角スペースの場合は折り返し可能

*return true;
改行コード

*return false;
１バイト文字が連続している場合

*return true;
1バイト文字と2バイト文字の境界

*return true;
最後に追加した文字がマルチバイト文字

*count += (enc.GetByteCount(enumerator.GetTextElement()) > 1 ? 2 : 1);
UTF-8で１バイトならASCII範囲の文字

*count += (enc.GetByteCount(enumerator.GetTextElement()) > 1 ? 2 : 1);
UTF-8で１バイトならASCII範囲の文字


*private Transform InstantiateParent = null;
Instantiateで複製したオブジェクトの親

*var guids_prefab = AssetDatabase.FindAssets("t:prefab", new string[] { "Assets/Prefabs" });
指定フォルダのprefabを全取得

*prefab = AssetDatabase.LoadAssetAtPath<GameObject>("Assets/Prefabs/Info.prefab");
アタッチさせたいオブジェクト名を拡張子付きで書く

*Object[] allGameObject = Resources.FindObjectsOfTypeAll(typeof(GameObject));
ヒエラルキー上のすべてのオブジェクトを取得


*public ObservableCollection<MyData> DataList { get; set; } = new ObservableCollection<MyData>();
ガンダム情報を格納

*CollectionViewSource _UICollectionViewSource;*public CollectionViewSource UICollectionViewSource { get { return _UICollectionViewSource; } set { _UICollectionViewSource = value; } }
ソート/グルーピングに使うCollectionViewSource

*UICollectionViewSource = new CollectionViewSource();
CollectionViewSourceのソースにDataListを設定

*private void Button_Click(object sender, RoutedEventArgs e)*{DataList.Add(new MyData() { MachineName = "ガンダム", PilotName = "アムロ" });DataList.Add(new MyData() { MachineName = "シャアザク", PilotName = "シャア" });DataList.Add(new MyData() { MachineName = "グフ", PilotName = "誰やったっけ？" });DataList.Add(new MyData() { MachineName = "Zガンダム", PilotName = "カミーユ" });DataList.Add(new MyData() { MachineName = "ガンダムmk-Ⅱ", PilotName = "アムロ" });DataList.Add(new MyData() { MachineName = "ジ・オ", PilotName = "シロッコ" });DataList.Add(new MyData() { MachineName = "百式", PilotName = "シャア" });DataList.Add(new MyData() { MachineName = "ZZガンダム", PilotName = "ジュドー" });DataList.Add(new MyData() { MachineName = "νガンダム", PilotName = "アムロ" });//ソートの指定SortDescription sortDescription;UICollectionViewSource.SortDescriptions.Clear();sortDescription = new SortDescription{PropertyName = "MachineName",Direction = ListSortDirection.Ascending};UICollectionViewSource.SortDescriptions.Add(sortDescription);sortDescription = new SortDescription{PropertyName = "PilotName",Direction = ListSortDirection.Ascending};UICollectionViewSource.SortDescriptions.Add(sortDescription);//グループの指定PropertyGroupDescription groupDescription;UICollectionViewSource.GroupDescriptions.Clear();groupDescription = new MyDataGroupDescription{// なにでグループを作るか決めるPropertyName = "PilotName"};UICollectionViewSource.GroupDescriptions.Add(groupDescription);UICollectionViewSource.View.Refresh();}
ボタンをおしたらデータの中身を追加

*SortDescription sortDescription;
ソートの指定

*PropertyGroupDescription groupDescription;
グループの指定

*PropertyName = "PilotName"};
なにでグループを作るか決める

*public class MyData*{public string MachineName { get; set; }public string PilotName { get; set; }}
ガンダム情報クラス

*public override object GroupNameFromItem(object item, int level, System.Globalization.CultureInfo culture)*{var uiobject = (MyData)item;return uiobject.PilotName;}
データの中身からグループのヘッダに出すものを決める


*class Hoge : MonoBehaviour*{[SerializeField]private TextMeshProUGUI text = default;void Start(){_ = HogeAsync();}async UniTask HogeAsync(){for (var i = 0; ; i++){await UniTask.Delay(1000);text.text = $"count:{i}";}}}
1秒間隔で表示を更新する

*var cancellationToken = this.GetCancellationTokenOnDestroy();
破棄されるときにキャンセル状態になるCancellationToken
thisとtextの寿命が違う場合はこれではまずいがとりあえず一緒とする

*await YTask.Inject(token);
CancellationTokenを挿入する
この後の処理でawaitを使用するとawait抜ける際にキャンセル状態がチェックされるようになる

*await Task.Delay(1000);
CancellationTokenを渡してなくても勝手にキャンセルされる

*_ = Task.Run(async () =>*{await Task.Delay(5000);cts.Cancel();});
5秒後にキャンセルする

*await YTask.InjectToStatic(token);
最上位の非同期メソッドでstatic領域にInjectする

*await PiyoAsync(name);
await後にstatic領域のCancellationTokenがFugaAsyncの最初にInjectされたものに戻る
よって複数の非同期メソッドを別々のCancellationTokenで同時に動かしてもシングルスレッドの場合は正常に動作する

*await YTask.InjectFromStatic();
下位の非同期メソッドではstatic領域から拾ってきてInjectする

*await FugaAsync();
FugaAsyncの中でも先頭でInjectしているはずなのでCancellationTokenを渡さない

*}
適当な後続処理...


*Commands = new[]{ProcessCommandFactory.FromCommandLine("command1", "コマンド1", filePath + " 5"), ProcessCommandFactory.FromCommandLine("command2", "コマンド2", filePath + " 4")},終了コードの制御は既定何れかのコマンドの終了コードが 0 でない場合、最初に見つかった終了コードを返すExitCodeHandler = null,成功時の次処理NextOnSucceed = new SequencialWorkflowItem("root-succeed", "成功時の後処理"){実行するコマンド（直列実行）Commands = new[]{ProcessCommandFactory.FromFile("command3", "コマンド3", filePath, "3"), ProcessCommandFactory.FromFile("command4", "コマンド4", filePath, "-2")},終了コードの制御ExitCodeHandler = ExitCodeHandlerFactory.Create(既定の終了コード-1, new[]{command3 の終了コード = 0 && command4 の終了コード = 0 => 0
実行するコマンド（並列実行）

*ExitCodeHandler = null
終了コードの制御は既定
何れかのコマンドの終了コードが 0 でない場合、最初に見つかった終了コードを返す

*NextOnSucceed = new SequencialWorkflowItem("root-succeed", "成功時の後処理"){実行するコマンド（直列実行）Commands = new[]{ProcessCommandFactory.FromFile("command3", "コマンド3", filePath, "3"), ProcessCommandFactory.FromFile("command4", "コマンド4", filePath, "-2")},終了コードの制御ExitCodeHandler = ExitCodeHandlerFactory.Create(既定の終了コード-1, new[]{command3 の終了コード = 0 && command4 の終了コード = 0 => 0
成功時の次処理

*Commands = new[]{ProcessCommandFactory.FromFile("command3", "コマンド3", filePath, "3"), ProcessCommandFactory.FromFile("command4", "コマンド4", filePath, "-2")},終了コードの制御ExitCodeHandler = ExitCodeHandlerFactory.Create(既定の終了コード-1, new[]{command3 の終了コード = 0 && command4 の終了コード = 0 => 0
実行するコマンド（直列実行）

*ExitCodeHandler = ExitCodeHandlerFactory.Create(既定の終了コード-1, new[]{command3 の終了コード = 0 && command4 の終了コード = 0 => 0(new[] { ("command3", 0), ("command4", 0) }, 0)
終了コードの制御

*-1
既定の終了コード

*(new[] { ("command3", 0), ("command4", 0) }, 0)
command3 の終了コード = 0 && command4 の終了コード = 0 => 0

*, (new[] { ("command3", 1), ("command4", 1) }, 11)
command3 の終了コード = 1 && command4 の終了コード = 1 => 11

*, (new[] { ("command4", 1) }, 10)
command4 の終了コード = 1 => 10

*NextOnSucceed = new WorkflowItem("root-succeed-succeed", "成功時の後処理"){Command = ProcessCommandFactory.FromFile("command5", "コマンド5", filePath, "1")},失敗時の次処理NextOnFailed = new WorkflowItem("root-succeed-failed", "失敗時の後処理"){実行するコマンドCommand = ProcessCommandFactory.FromFile("command6", "コマンド6", filePath, "2")}},失敗時の次処理NextOnFailed = new WorkflowItem("root-failed", "失敗時の後処理"){実行するコマンドCommand = ProcessCommandFactory.FromFile("command7", "コマンド7", filePath, "1")}};
成功時の次処理

*NextOnFailed = new WorkflowItem("root-succeed-failed", "失敗時の後処理"){実行するコマンドCommand = ProcessCommandFactory.FromFile("command6", "コマンド6", filePath, "2")}},失敗時の次処理NextOnFailed = new WorkflowItem("root-failed", "失敗時の後処理"){実行するコマンドCommand = ProcessCommandFactory.FromFile("command7", "コマンド7", filePath, "1")}};
失敗時の次処理

*Command = ProcessCommandFactory.FromFile("command6", "コマンド6", filePath, "2")}},失敗時の次処理NextOnFailed = new WorkflowItem("root-failed", "失敗時の後処理"){実行するコマンドCommand = ProcessCommandFactory.FromFile("command7", "コマンド7", filePath, "1")}};
実行するコマンド

*NextOnFailed = new WorkflowItem("root-failed", "失敗時の後処理"){実行するコマンドCommand = ProcessCommandFactory.FromFile("command7", "コマンド7", filePath, "1")}};
失敗時の次処理

*Command = ProcessCommandFactory.FromFile("command7", "コマンド7", filePath, "1")}};
実行するコマンド

*IWorkflowItem current = item;
ワークフローを実行する

*var variables = System.Environment.GetEnvironmentVariables();
環境変数から前処理の終了コードを取得して出力

*int repeatCount = Convert.ToInt32(args[0]);*if (repeatCount < 0) { return 1; }
先頭の引数は繰り返し回数を表すものとする


*XmlDocument log4netConfig = new XmlDocument();
log4net使う準備ここから

*logger.Info("Hello World!");
log4net使う準備ここまで

*LogLog.Debug(declaringType, "Creating repository for assembly [" + repositoryAssembly + "]");*// Must specify defaults
Not found, therefore create

*#if NETSTANDARD1_3*object[] configAttributes = assembly.GetCustomAttributes(typeof(log4net.Config.ConfiguratorAttribute)).ToArray();
Look for the Configurator attributes (e.g. XmlConfiguratorAttribute) on the assembly

*// Do this even if the repository has been configured (or claims to be), this allows overriding*// of the default config files etc, if that is required.
Try to configure the default repository using an AppSettings specified config file

*// of the default config files etc, if that is required.*string repositoryConfigFile = SystemInfo.GetAppSetting("log4net.Config");
Do this even if the repository has been configured (or claims to be), this allows overriding

*try*{fullPath2ConfigFile = SystemInfo.ConfigurationFileLocation;}
Use the default .config file for the AppDomain


*click = true;
クリックされた判定にする


*.OrderByDescending(s => s.id)
IDの降順


*using CustomInput;
自分で定義したやつ


*public ObservableCollection<MyData> DataList { get; set; } = new ObservableCollection<MyData>();
ガンダム情報を格納

*private void Button_Click(object sender, RoutedEventArgs e)*{DataList.Add(new MyData() { MachineName = "ガンダム", PilotName = "アムロ" });DataList.Add(new MyData() { MachineName = "シャアザク", PilotName = "シャア" });DataList.Add(new MyData() { MachineName = "グフ", PilotName = "誰やったっけ？" });DataList.Add(new MyData() { MachineName = "Zガンダム", PilotName = "カミーユ" });DataList.Add(new MyData() { MachineName = "ガンダムmk-Ⅱ", PilotName = "アムロ" });DataList.Add(new MyData() { MachineName = "ジ・オ", PilotName = "シロッコ" });DataList.Add(new MyData() { MachineName = "百式", PilotName = "シャア" });DataList.Add(new MyData() { MachineName = "ZZガンダム", PilotName = "ジュドー" });DataList.Add(new MyData() { MachineName = "νガンダム", PilotName = "アムロ" });}
ボタンをおしたらデータの中身を追加


*new public void Dispose()
警告 CS0108 避けに new を付ける.

*public class MyBaseClass : IDisposable
ベースクラスのdispose簡易実装2.
Dispose() を virtual 宣言する

*public class MySubClass : MyBaseClass
サブクラスのdispose簡易実装２.
Dispose() を override 宣言する

*sealed public class MyBaseClass : IDisposable
ベースクラスのdispose簡易実装３.
sealed 宣言して、派生を禁止する


*DateTime tmp = D_Date;
一時変数

*GameObject button = GameObject.Find("GameObject").transform.GetChild(i).gameObject;*button.GetComponent<Button>().onClick.RemoveAllListeners();
以下3行追加

*}
値を保存する処理など


*options.RespectBrowserAcceptHeader = true;
false by default


*using (var writer = new StreamWriter(@".\test.txt", append: true, encoding: Encoding.UTF8))
ファイルパスを渡すと内部でFileStreamが生成されてそこにデータが流し込まれる
StreamWriterにMemoryStreamとかを渡せば書き込み先を変えられる

*await writer.WriteLineAsync("hunngaaa!!");
非同期でも書ける

*await stream.WriteAsync(new byte[] { 0x76, 0x12, 0x23, 0x99, 0x50, 0x43, 0x18, 0x66 });
バイナリの場合も非同期で書ける

*using (var reader = new StreamReader(@".\test.txt", Encoding.UTF8)){Console.WriteLine(reader.ReadLine());
StreamWriterと同じ要領で使える

*using (var stream = new FileStream(@".\test.bin", FileMode.Open, FileAccess.Read)){var buffer = new byte[8];
あんまり使わない


*public string CommandText => Resources.FindUserQuery;
SQL ファイルをリソースファイルに登録しておく。

*private MyState State { get; }
状態へのアクセス

*private MyView View { get; }
UI へのアクセス

*private IDatabase Database { get; }
DI されるサービス

*Form.MyTextBox.Text = text;
MyForm に配置してるテキストボックスのテキストを変更する。
MyTextBox フィールドのアクセス指定子を internal にしておけば、このように別のクラスから触れる。

*internal sealed class TodoItem*{public long ItemId { get; }public string Text { get; }public bool IsDone { get; }}
entities/TodoList.cs


*public ObservableCollection<MyData> DataList { get; set; } = new ObservableCollection<MyData>();
ガンダム情報を格納

*private void Button_Click(object sender, RoutedEventArgs e)*{DataList.Add(new MyData() { MachineName = "ガンダム", PilotName = "アムロ" });DataList.Add(new MyData() { MachineName = "シャアザク", PilotName = "シャア" });DataList.Add(new MyData() { MachineName = "グフ", PilotName = "誰やったっけ？" });DataList.Add(new MyData() { MachineName = "Zガンダム", PilotName = "カミーユ" });DataList.Add(new MyData() { MachineName = "ジ・オ", PilotName = "シロッコ" });DataList.Add(new MyData() { MachineName = "百式", PilotName = "シャア" });DataList.Add(new MyData() { MachineName = "ZZガンダム", PilotName = "ジュドー" });}
ボタンをおしたらデータの中身を追加


*using System;
DateTimeを使用する為追加。

*[SerializeField] Text DateTimeText;
テキストUIをドラッグ&ドロップ

*DateTime TodayNow;
DateTimeを使うため変数を設定

*TodayNow = DateTime.Now;
時間を取得

*DateTimeText.text = TodayNow.Year.ToString() + "年 " + TodayNow.Month.ToString() + "月" + TodayNow.Day.ToString() + "日" + DateTime.Now.ToLongTimeString();
テキストUIに年・月・日・秒を表示させる


*humanPose.muscles[58] = (1 - (2 * actionLeftSkeleton.thumbCurl))
2;  指の第1関節の曲がる量を半分にする

*humanPose.muscles[59] = 1 - (2 * actionLeftSkeleton.indexCurl);
左人差し指

*humanPose.muscles[63] = 1 - (2 * actionLeftSkeleton.middleCurl);
左中指

*humanPose.muscles[67] = 1 - (2 * actionLeftSkeleton.ringCurl);
左薬指

*humanPose.muscles[71] = 1 - (2 * actionLeftSkeleton.pinkyCurl);
左小指

*humanPose.muscles[77] = 1 - (2 * actionRightSkeleton.thumbCurl);
右親指
humanPose.muscles[75] = 1 - (2 * actionRightSkeleton.thumbCurl);

*humanPose.muscles[79] = 1 - (2 * actionRightSkeleton.indexCurl);
右人差し指

*humanPose.muscles[83] = 1 - (2 * actionRightSkeleton.middleCurl);
右中指

*humanPose.muscles[87] = 1 - (2 * actionRightSkeleton.ringCurl);
右薬指

*humanPose.muscles[91] = 1 - (2 * actionRightSkeleton.pinkyCurl);
右小指


*s => s.Created);
結果出力用


*buf[i + 1] = 0;
G

*var histogram = new int[256];
画像色用256配列を用意

*histogram[buf[i + 2]]++;
Rの頻度を数える

*histogram[buf[i + 1]]++;
Gの頻度を数える

*histogram[buf[i]]++;
Bの頻度を数える

*chart.Series.Clear();
Chartコントロール内のグラフ、凡例、目盛り領域を削除

*var ca = chart.ChartAreas.Add("Histogram");
目盛り領域の設定

*ca.AxisY.Minimum = 0;
X軸
ca.AxisX.Title = "Pixel";   タイトル
ca.AxisX.Minimum = 0;            最小値
ca.AxisX.Maximum = 256;          最大値
ca.AxisX.Interval = 64;          目盛りの間隔
ca.AxisY.Title = "Count";        Y軸

*var series = chart.Series.Add("Histogram");
グラフの系列を追加

*series.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;
グラフの種類を折れ線に設定する


*if (FileName_IsError(fileName) == 1) return;*string filePath = Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory)
入力値が正常かチェック

*using (StreamReader sr = new StreamReader(filePath, Encoding.GetEncoding("UTF-8"))){string readText = sr.ReadToEnd();
ファイル読み込み

*List<string> lockData = new List<string>();
データをロック・アンロックでわける

*int dataCount = Math.Min(lockData.Count(), unlockData.Count());
組み合わせのロック開始～アンロックの時間を算出


*for (int i = n, i3 = n * 3; i >= 0; i--, i3 -= 3)
対角要素の右隣の要素を対応するx（計算済み）にかけて引いて割る

*{for (int i = isLoop ? 0 : 1; i < (isLoop ? n : (n-1)); i++){var ofs = (i+1) * 3;var next = (i + 1) % n;var prev = (i - 1 + n) % n;//ランクが下がってしまう場合微調整if (ts[i] == 1 && ts[next] == 0 || !isLoop && i == n - 2 && ts[i] == 1)ts[i] = 0.99999f;if (!isLoop && i == 1 && ts[i] == 0)ts[i] = 0.00001f;var tmp = (1 - ts[i]) * (1 - ts[i]);A[ofs] = (1 - lambdas[prev]) * tmp;A[ofs + 1] = lambdas[prev] * tmp + (2 - (1 + lambdas[i]) * ts[i]) * ts[i];A[ofs + 2] = lambdas[i] * ts[i] * ts[i];}}
係数行列Aを構成（端の部分はStep0で初期化済）

*if (ts[i] == 1 && ts[next] == 0 || !isLoop && i == n - 2 && ts[i] == 1)*ts[i] = 0.99999f;
ランクが下がってしまう場合微調整

*var extendedPs = new ExtendedPlayerControls(ps,cs);
入出力ベクトルを拡張

*SolveTridiagonalEquation(A, extendedCs, extendedPs);
連立方程式を解く

*var cs = CalcBezierControls(points, calcSpace, iteration, isLoop);
ベジェ制御点を計算

*return CalcPlots(cs, plotSpace, stepPerSegment, isLoop);
各セグメントについて、指定されたステップ数で分割した点を計算

*var iteration = 10;
イテレーション回数

*var isLoop = true;
ループするかどうか

*var step = 20;
セグメントごとの分割数

*Vector2[] input = /*更新処理*/;
ユーザ制御点を更新

*var cSpace = new KCurves.CalcSpace(input.Length);
計算用空間確保（本来はキャッシュしておく）

*var pSpace = new KCurves.PlotSpace(input.Length, step, isLoop);
プロット用空間確保（本来はキャッシュしておく）

*var output = KCurves.CalcPlots(input, cSpace, pSpace, iteration, step, isLoop);
実行

*Step0(points, space.C, space.L, space.A, isLoop);
前略


*ui.Keyin(true, ResultElement, "^c");
^ = CTRL

*Process notepad = Process.Start(@"notepad");
notepadを起動させます。

*Thread.Sleep(2000);
起動待ち

*AutomationElement notepadElement = ui.GetMainFrameElement(notepad);
電卓のMainFRameのAutomationElementを取得
notepad = ui.UpdateTargetProcess("メモ帳");  更新

*ui.ClickElement(notepadElement, notepadHelpMenuId);
で、ペーストします。
ui.Keyin(true, notepadElement, "^v");  ^ = CTRL
さらにメニューをクリック操作してバージョンを出します。
string notepadHelpMenuId = "Item 5";  「メニュー」のAutomationId

*Console.WriteLine("notepadの内容を確認して、<enter>して下さい（電卓は消しますがnotepadhaは残します）");
確認のメッセージです。

*calc.CloseMainWindow();
電卓プロセスを終了させます


*public abstract class Template*{protected abstract void Morning();protected abstract void Afternoon();protected abstract void Night();public void Play(){Morning();Afternoon();Night();}}
スーパークラスで処理の枠組みを決めます。


*dynamic obj = new ExpandoObject();
ExpandoObjectクラスのインスタンスを生成

*obj.Height = 100;
プロパティを設定

*Console.WriteLine("Height: {0}", obj.Height);
各プロパティを出力

*dynamic obj = new ExpandoObject();
ExpandoObjectクラスのインスタンスを生成

*obj.Height = 100;
プロパティを設定

*Console.WriteLine("Height: {0}", obj.Height);
各プロパティを出力

*var sr = new StreamReader(@"C:\work\sample.json");
Jsonファイル読み込み

*dynamic obj = JsonConvert.DeserializeObject<ExpandoObject>(json);
ExpandoObjectクラスのインスタンスを生成

*Console.WriteLine(obj.Name);
プロパティ出力


*case CONV_LOWER:*if (record->event.pressed) {key_timer = timer_read();layer_on(_LOWER);}else{layer_off(_LOWER);if(timer_elapsed(key_timer) <= 120){tap_code16(LCTL(KC_SPC));}}
ここから上省略


*var ruleBinArray = int.Parse(Convert.ToString(ruleDec, 2)).ToString("D8").ToCharArray();
ウルフラム・コードを2進数に変換し8桁0埋め

*var n = 7;
近傍の状態を表す10進数

*var firstGene = "0".PadLeft(automatonSize + 2, '0').ToCharArray();
第1世代のセル・オートマトンを生成し初期状態を与える

*var view = cell == '0' ? " " : "*";
セルの状態に応じて描画

*var nextGene = "0";
左端は常に0

*return nextGene + "0";
右端は常に0


*public static class LogUtility*{public static void Log(string message, [CallerMemberName] string callerMember = "", [CallerFilePath] string callerFilePath = "", [CallerLineNumber] int callerLineNumber = -1){Console.WriteLine($"[{callerMember}] {message} ({callerFilePath}:{callerLineNumber})")}}
using System.Runtime.CompilerServices;

*LogUtility.Log("Start!");
のようなコードとしてコンパイルされます。

*public static void LogDebugWithCaller(this ILogger logger, string message, object[] args = null, [CallerMemberName] string callerMember = "", [CallerFilePath] string callerFilePath = "", [CallerLineNumber] int callerLineNumber = -1)
using System.Runtime.CompilerServices;


*HogeAttribute hoge = Attribute.GetAttribute(typeof(TargetClass), typeof(HogeAttribute)) as HogeAttribute;
または


*namespace ForwardToTest*{class Program{static void Main(string[] args){Foo.Bar.Print();Foo.Baz.Print();}}}
Program.exe

*[assembly: System.Runtime.CompilerServices.TypeForwardedTo(typeof(Foo.Bar))]
TypeForwadedToによりAssemblyBのFoo.Barへ転送される


*Beep(523, 500);
ド

*string[] str = Environment.GetCommandLineArgs();*foreach(string s in str) {p(s);}
forループで分割

*System.Threading.Thread.Sleep(3000);
3秒スリープ

*string source = File.ReadAllText("main.cs", Encoding.GetEncoding("shift_jis"));*// 行末のスペースを無視しつつ、改行区切り
読み込み

*string pattern = @"\s*\r\n";
行末のスペースを無視しつつ、改行区切り


*TimeSpan ts = TimeSpan.Parse("30:00");
例外発生


*//public new ImeMode ImeMode { get { return base.ImeMode; } set { base.ImeMode = ImeMode.Disable; } }
[EditorBrowsable(EditorBrowsableState.Never)]

*protected override void OnKeyPress(KeyPressEventArgs e)*{// テキスト開始位置をこの時点で取得selectionStart = base.SelectionStart;base.OnKeyPress(e);}
public new ImeMode ImeMode { get { return base.ImeMode; } set { base.ImeMode = ImeMode.Disable; } }

*selectionStart = base.SelectionStart;
テキスト開始位置をこの時点で取得


*childObject.gameObject.transform.localEulerAngles = new Vector3(0.0f, 0f, 0f);
親と同じ向き

*private void OnCollisionEnter(Collision col){if (col.gameObject.CompareTag("Player")){//衝突した時の処理}}
Playerタグを持ってるオブジェクトとの衝突

*}
衝突した時の処理


*Vector2 start = Vector2.zero;
Tween開始

*Vector2 start = Vector2.zero;
Tween開始


*private List<Linking> linkings = new List<Linking>() {new Linking(){ Text="いぇ", Inputs=new []{ "ye" } },new Linking(){ Text="きゃ", Inputs=new []{ "kya" } },new Linking(){ Text="きゅ", Inputs=new []{ "kyu" } },new Linking(){ Text="きょ", Inputs=new []{ "kyo" } },new Linking(){ Text="ぎゃ", Inputs=new []{ "gya" } },new Linking(){ Text="ぎぃ", Inputs=new []{ "gyi" } },new Linking(){ Text="ぎゅ", Inputs=new []{ "gyu" } },new Linking(){ Text="ぎぇ", Inputs=new []{ "gye" } },new Linking(){ Text="ぎょ", Inputs=new []{ "gyo" } },new Linking(){ Text="くぁ", Inputs=new []{ "qya", "qwa", "qa", "kwa" } },：長過ぎるので割愛};
「し」「ゃ」とかを「しゃ」に連結したパターンを生成する

*int index = 0;
１文字ずつ解析していく
「しゃ」とかも「し」「ゃ」に分割される

*var simpleChars = SimpleChars(c).ToList();
１文字で表現できるものを取得
ローマ字は、文字は同じでも入力方法は複数ある

*currents.Clear();
前回値を今回取得したやつにする

*currents.Clear();
インデクサをクリア

*currents.AddRange(lasts);
最後に追加した要素

*var linkingWord = new TypeChar("ん", "n"){IndexOfWord = at.IndexOfWord,IndexOfSentence = this.IndexOfSentence,Game = this.Sentence.Game,};
次が「や」「な」「あ」行でないなら”n”だけでOK

*prevs.AddRange(at.Prev);
前の要素（候補）

*prevs = prevs.Distinct(new TypeCharEquality()).ToList();
前の要素は重複している可能性があるのでダイエット

*break;
先頭まで戻ってきたら終わり


*string P_s_名前 { get; set; }
名前、プロパティ

*bool P_b_名前があるか { get; }
名前があるか、プロパティ

*void 名前を言え();
名前を言え、メソッド

*private string m_s_名前;
名前、プロパティ

*public bool P_b_名前があるか => !string.IsNullOrWhiteSpace(P_s_名前);
名前があるか、プロパティ

*public void 名前を言え()*{if (P_b_名前があるか)MessageBox.Show($"こんにちは、{P_s_名前}さん");elseMessageBox.Show($"名前を入力してください", "お願い",MessageBoxButton.OK, MessageBoxImage.Exclamation);}
名前を言え、メソッド


*"https:
api.github.comgraphql",


*var esk = new Youmu();
以下略


*.Where(x => x)
FontTextureなど、ロードできないものを除外

*RectOffset iconPadding = new RectOffset(10, 10, 4, 4);
アイコン描画領域に必要な幅を計算

*filter = FilterField(filter, Repaint);
フィルタ

*var headerHeight = 24;
ヘッダ

*var elementMinHeight = 20;
リスト

*if (!string.IsNullOrEmpty(filter) && !icon.name.ToLower().Contains(filter.ToLower())) continue;*var iconRectHeight = Mathf.Max(elementMinHeight, icon.height + iconPadding.top + iconPadding.bottom);
フィルタ内容に応じてスキップ

*GUI.SetNextControlName(controlName);
入力欄

*using (new EditorGUI.DisabledGroupScope(string.IsNullOrEmpty(filter)))*{if (GUILayout.Button("Clear", "SearchCancelButton")){filter = "";}}
クリアボタン


*string path = "Assets/";
Assetsフォルダからのフルパス.

*AssetDatabase.LoadAssetAtPath<GameObject>(path),
GameObjectだったりScriptableObjectだったり.


*this.OnTriggerEnterAsObservable()
敵に当たったら音が鳴ってマテリアル変更→無敵時間を作って終わったらマテリアルを元に戻す


*GeneratedResolver.Instance
今回事前生成しようとしているResolver


*scaleFactor *= 0.95f;
Reduce amplitude slightly to make highly compressed signals fit.

*amplitudeScale *= 0.95f;
公式実装に倣って補正

*var audioImporter = InternalAudioUtil.GetImporterFromClip(clip);
データ取得

*float minOfAll = 0;
全体の最大値・最小値を計算

*int numChannels = clip.channels;
チャンネル数・サンプル数

*float h = rect.height / numChannels;
１チャンネルごとの専有height

*Rect channelRect = new Rect(rect.x, rect.y + h * channel, rect.width, h);
描画範囲計算

*AudioCurveRendering.AudioMinMaxCurveAndColorEvaluator dlg = delegate (float x, out Color col, out float minValue, out float maxValue){if (numSamples <= 0)
描画内容定義

*float p = Mathf.Clamp(x * (numSamples - 2), 0.0f, numSamples - 2);
minMaxDataの現在のx座標に対応する値を取得

*col = colorSetter?.Invoke(channel, x, minValue, maxValue, minOfAll, maxOfAll) ?? new Color(1, 0.54902f, 0, 1);
色を指定

*AudioCurveRendering.DrawMinMaxFilledCurve(channelRect, dlg);
描画

*public static void RenderPreview(Rect rect, AudioClip clip, Color color, float amplitudeScale = 1){RenderPreview(rect, clip, (_, __, ___, ____, _____, ______) => color, amplitudeScale);
単色指定ver

*public static void RenderTimeAwarePreview(Rect rect, AudioClip clip, Color start, Color finish, float amplitudeScale = 1){RenderPreview(rect, clip, (_, t, ___, ____, _____, ______) => Color.Lerp(start, finish, t), amplitudeScale);
時間経過でグラデーションver

*public static void RenderAmplitudeAwarePreview(Rect rect, AudioClip clip, Color lowAmp, Color highAmp, float amplitudeScale = 1){RenderPreview(rect, clip, (channel, _, min, max, minOfAll, maxOfAll) =>
振幅の大小でグラデーションver

*readonly static Type tProjectWindow = typeof(Editor).Assembly.GetType("UnityEditor.ProjectBrowser");
ProjectWindowの型キャッシュ。Ping時にProjectWindowを開くために使用。

*static Dictionary<string, int> objectPickerControls = new Dictionary<string, int>();
ObjectPicker使用時の、対応するプロパティごとのControlID

*static string MakeUniquePropKey(SerializedProperty prop)
プロパティごとのユニークID生成器

*EditorGUI.DrawRect(headerRect, frameColor);
ヘッダ

*EditorGUI.DrawRect(waveRect, bgColor);
背景

*InternalAudioUtil.RenderAmplitudeAwarePreview(waveRect, clip, Color.yellow, Color.red, amplitudeScale);
波形表示


*Console.WriteLine(pe.StandardOutput);
標準出力の結果を出力


*return false;
3


*internal class Class1 : INotifyPropertyChanged
バインディングさせるソースは、INotifyPropertyChangedが必要

*internal Class1 obj { set; get; } = null;
オリジナルなUserControlのデータソースになるクラスのポインタ
Factoryによって、コンストラクタ引数で設定している
このClassLibrary1を利用する側 WpfApp14 には公開したくないので、internalになっている

*internal publicInterface(Class1 sorce)*{obj = sorce;// ★オリジナルなUserControlにデータソースを設定Control1.DataContext = (object)obj;// ★UserControl内の依存関係プロパティとデータソースのプロパティをバインドするControl1.SetBinding(UserControl1.値2Property, nameof(Class1.val1));}
コンストラクタ 上と同じく公開したくないので、internalになっている

*Control1.DataContext = (object)obj;
★オリジナルなUserControlにデータソースを設定

*Control1.SetBinding(UserControl1.値2Property, nameof(Class1.val1));
★UserControl内の依存関係プロパティとデータソースのプロパティをバインドする

*public void Start()*{obj.val1 += 1;}
内部を動かす処理関数

*public UserControl1 Control1 { private set; get; } = new UserControl1();
公開するユーザコントロール

*public static readonly DependencyProperty 値2Property = DependencyProperty.Register("値2", typeof(int), typeof(UserControl1),new FrameworkPropertyMetadata(default(int), new PropertyChangedCallback(On値2Changed)));
オリジナルのUserControl1に表示される値とつながる依存関係プロパティ

*UserControl1 ctrl = obj as UserControl1;
値が変化したときに動く処理。値が設定されたときに動く訳ではないので、注意。

*ctrl.label2.Content = ctrl.値2;
ここで画面更新

*ClassLibrary1Factory factory = ClassLibrary1Factory.GetInstance();
このサンプルでは、WpfApp14プロジェクトが、ClassLibrary1プロジェクトを使って、機能実装するサンプル
ClassLibrary1プロジェクトは、Factoryクラスを持っていて、内部的にインスタンスを生成する
このWpfApp14のMainWindowは、ClassLibrary1が提供する機能を利用し、公開されているUserControlも利用するというサンプル

*UserControl ClassLibrary1から取得した実体のUserControl = factory.公開するものだけを持つクラス.Control1;
公開されているUserControlを取得

*stackPanel1.Children.Add(ClassLibrary1から取得した実体のUserControl);
取得したUserControlをMainWindowに差し込む

*factory.公開するものだけを持つクラス.Start();
公開されている機能を実行すると、その機能の実行結果として、公開されているUserControlの値が更新されるサンプル


*IInputProvider inputProvider;
MoveCubeはどこのどのIInputProviderを使えばいいかわからない

*}
適当な処理

*}
適当な処理

*}
適当な処理

*}
適当な処理

*#if UNITY_ANDROID || UNITY_IOS*JoyStickInputInstaller.Install(Container);
スマホ用

*#if UNITY_WEBGL*KeyInputInstaller.Install(Container);
WebGL


*inStr = "
" + inStr;

*inStr = inStr.Replace("/", "\\");
通信～デシリアライズ前とは逆の変換


*var u2 = v.Property;
二度目は何も変わっていないが，メソッドは再び呼ばれている．


*List<TurnableStone> turnableStoneList = new List<TurnableStone>();
ひっくり返す石のリスト

*turnableStoneList.Add(new TurnableStone(_z, _x));
ひっくり返す対象

*isTurnable = true;
ひっくり返すことができる


*GameObject hogeGameObject = new GameObject(origin);
Hogeを複製


*String path = this.textBox3.Text.Trim() + System.IO.Path.DirectorySeparatorChar + this.pythonFileName;
workフォルダにpythonファイルに書き込む

*button1.Enabled = false;
前処理

*RunCommandLineAsync(path);
実行

*p.BeginOutputReadLine();
非同期で出力とエラーの読み取りを開始

*this.Invoke((MethodInvoker)(() => AppendText(outStringBuilder.ToString(), false)));
吐き出されずに残っているデータの吐き出し

*String pythonFilepath = this.textBox3.Text.Trim() + System.IO.Path.DirectorySeparatorChar + this.pythonFileName;
pythonファイルを削除する

*this.Invoke((MethodInvoker)(() => MessageBox.Show("処理をキャンセルしました")));
完了メッセージ

*this.Invoke((MethodInvoker)(() => MessageBox.Show("処理が完了しました")));
完了メッセージ

*this.Invoke((MethodInvoker)(() => MessageBox.Show("エラーが発生しました")));
完了メッセージ

*this.textBox4.Clear();
Pythonコード部分のクリア

*this.textBox1.Clear();
標準出力エリアのクリア


*public int processId { get; set; }
データグリッドで自動で見せる列

*private Process process;
データグリッドで自動で見せない列


*.RepeatSafe();
判定が終わったら繰り返し


*public int blackScore;
黒の枚数

*GameObject stone = GameObject.Instantiate<GameObject>(firstStone);
石を64枚EMPTYで生成


*private bool isFadeOut = false;
フェードアウト処理の開始、完了を管理するフラグ

*private bool isFadeIn = true;
フェードイン処理の開始、完了を管理するフラグ

*float fadeSpeed = 0.75f;
透明度が変わるスピード

*public Image fadeImage;
画面をフェードさせるための画像をパブリックで取得

*string afterScene;
シーン遷移のための型

*void Start()*{DontDestroyOnLoad(this);SetRGBA(0, 0, 0, 1);//シーン遷移が完了した際にフェードインを開始するように設定SceneManager.sceneLoaded += fadeInStart;}
Start is called before the first frame update

*SceneManager.sceneLoaded += fadeInStart;
シーン遷移が完了した際にフェードインを開始するように設定

*void fadeInStart(Scene scene,LoadSceneMode mode)*{isFadeIn = true;}
シーン遷移が完了した際にフェードインを開始するように設定

*void Update()*{if (isFadeIn == true){//不透明度を徐々に下げるalfa -= fadeSpeed * Time.deltaTime;//変更した透明度を画像に反映させる関数を呼ぶSetColor();if (alfa <= 0)isFadeIn = false;}if (isFadeOut == true){//不透明度を徐々に上げるalfa += fadeSpeed * Time.deltaTime;//変更した透明度を画像に反映させる関数を呼ぶSetColor();if (alfa >= 1){isFadeOut = false;SceneManager.LoadScene(afterScene);}}}
Update is called once per frame

*alfa -= fadeSpeed * Time.deltaTime;
不透明度を徐々に下げる

*SetColor();
変更した透明度を画像に反映させる関数を呼ぶ

*alfa += fadeSpeed * Time.deltaTime;
不透明度を徐々に上げる

*SetColor();
変更した透明度を画像に反映させる関数を呼ぶ

*void SetColor()*{fadeImage.color = new Color(red, green, blue, alfa);}
画像に色を代入する関数

*public void SetRGBA(int r, int g, int b, int a)*{red = r;green = g;blue = b;alfa = a;}
色の値を設定するための関数

*void Start()*{//SceneFadeManagerがアタッチされているオブジェクトを取得ManageObject = GameObject.Find("ManageObject");//オブジェクトの中のSceneFadeManagerを取得fadeManager = ManageObject.GetComponent<SceneFadeManager>();}
Start is called before the first frame update

*ManageObject = GameObject.Find("ManageObject");
SceneFadeManagerがアタッチされているオブジェクトを取得

*fadeManager = ManageObject.GetComponent<SceneFadeManager>();
オブジェクトの中のSceneFadeManagerを取得

*void Update()*{if(Input.GetMouseButtonDown(0)){//SceneFadeManagerの中のフェードアウト開始関数を呼び出しfadeManager.fadeOutStart(0, 0, 0, 0, "Scene2");}}
Update is called once per frame

*fadeManager.fadeOutStart(0, 0, 0, 0, "Scene2");
SceneFadeManagerの中のフェードアウト開始関数を呼び出し


*static readonly Type tAudioUtil = typeof(Editor).Assembly.GetType("UnityEditor.AudioUtil");
AudioUtil型

*static readonly ConcurrentDictionary<Method, Func<object[], object>>
コンパイル済みメソッドのキャッシュ

*static Func<object[], object> GetOrCompile(Method method)*{return compiled.GetOrAdd(method, _m =>{//キャッシュが存在しなければここに来る//MethodInfo取得var m = tAudioUtil.GetMethod(_m.ToString(), BindingFlags.Static | BindingFlags.Public);//voidメソッドのためのreturn先ラベルを定義var voidTarget = Expression.Label(typeof(object));//引数はobject[]var args = Expression.Parameter(typeof(object[]), "args");//MethodInfoのパラメータの型に引数をキャストするExpressionの束var parameters = m.GetParameters().Select((x, index) =>Expression.Convert(Expression.ArrayIndex(args, Expression.Constant(index)),x.ParameterType)).ToArray();//式木構築var lambda = Expression.Lambda<Func<object[], object>>(m.ReturnType == typeof(void)//voidメソッドの場合、ブロックにしてreturn default(object)する必要がある? (Expression)Expression.Block(Expression.Call(null, m, parameters),Expression.Return(voidTarget, Expression.Default(typeof(object))),Expression.Label(voidTarget, Expression.Constant(null)))//返り値がある場合はCallして結果をobjectにキャストするだけ: Expression.Convert(Expression.Call(null, m, parameters),typeof(object)),args);//コンパイルしてキャッシュしつつ返すreturn lambda.Compile();});}
キャッシュからメソッドを取得する。コンパイル済みでなければコンパイルしてキャッシュし、それを返す。

*var m = tAudioUtil.GetMethod(_m.ToString(), BindingFlags.Static | BindingFlags.Public);
キャッシュが存在しなければここに来る
MethodInfo取得

*var voidTarget = Expression.Label(typeof(object));
voidメソッドのためのreturn先ラベルを定義

*var args = Expression.Parameter(typeof(object[]), "args");
引数はobject[]

*var parameters = m.GetParameters().Select((x, index) =>
MethodInfoのパラメータの型に引数をキャストするExpressionの束

*var lambda = Expression.Lambda<Func<object[], object>>(m.ReturnType == typeof(void)
式木構築

*? (Expression)Expression.Block(
voidメソッドの場合、ブロックにしてreturn default(object)する必要がある

*: Expression.Convert(Expression.Call(null, m, parameters),
返り値がある場合はCallして結果をobjectにキャストするだけ

*return lambda.Compile();
コンパイルしてキャッシュしつつ返す


*EditorApplication.update -= Repaint;
増殖を防ぐ

*static readonly FieldInfo fi_m_NativeObjectPtr = typeof(SerializedObject).GetField("m_NativeObjectPtr", BindingFlags.NonPublic | BindingFlags.Instance);
キャッシュ


*async void ButtonClick()*{// context = SynchronizationContext.Current;Debug.Log("Start Click Method : " + Thread.CurrentThread.ManagedThreadId);await Task.Run(HeavyMethod);FinalizeMethod();Debug.Log("End Click Method : " + Thread.CurrentThread.ManagedThreadId);}
private SynchronizationContext context;


*.WithOrigins(new string[] { "http:
localhost:8080" })

*public void Configure(IApplicationBuilder app, IWebHostEnvironment env)*{// ~省略~app.UseEndpoints(endpoints =>{endpoints.MapControllerRoute(name: "default",pattern: "{controller}/{action=Index}/{id?}");});// ↓追加↓app.UseCors();}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*app.UseEndpoints(endpoints =>{endpoints.MapControllerRoute(name: "default",pattern: "{controller}/{action=Index}/{id?}");
~省略~

*app.UseCors();
↓追加↓


*class Class1 : INotifyPropertyChanged
バインディングさせるソースは、INotifyPropertyChangedが必要


*string food = "     apple     ";*Console.WriteLine($"[{food}]");
以下のような変数を定義すると

*→ [     apple     ]
このように出力される

*trimFood = food.TrimStart();*Console.WriteLine($"[{trimFood}]");
先頭のみトリミング

*trimFood = food.TrimEnd();*Console.WriteLine($"[{trimFood}]");
末尾のみトリミング

*fav = fav.Replace("Movie", "Running");
置き換えを行う時はReplaceメソッドを使用する


*iEnumerator = Coroutine();*while (iEnumerator.MoveNext()) {Debug.Log($"Coroutine Return {iEnumerator.Current}");}
iEnumerator.Reset();     <- NotSupportedExceptionがスローされる


*マウスの位置を補足するメソッド()*{}
↓


*private void Hoge( string[] array )*{Extension.Swap(ref sbyte,ref sbyte);Extension.Swap(ref byte,ref byte);Extension.Swap(ref short,ref short);Extension.Swap(ref ushort,ref ushort);Extension.Swap(ref int,ref int);Extension.Swap(ref uint,ref uint);Extension.Swap(ref long,ref long);Extension.Swap(ref ulong,ref ulong);Extension.Swap(ref char,ref char);Extension.Swap(ref float,ref float);Extension.Swap(ref double,ref double);Extension.Swap(ref string,ref string);Extension.Swap<T>(ref T, ref T)where T:UnityEngine.Object;}
入れ替え処理一部intなどは普通の入れ替えより少し処理速度が速いです。

*flag.Switching();
trueならfalseにfalseならtrue。

*T t=array.First();
一番先頭の要素を返す。

*T t=array.Last();
一番最後の要素を返す。

*QuickSort(int[] array,int left,int right,bool ascending = true);
大量のソートを行う場合既存のソートより早いです。

*T t=list.First();
一番先頭の要素を返す。

*T t=list.Last();
一番最後の要素を返す。

*list.RemoveNull();
要素の中にあるnullを削除する

*list.Allocation(T _add,bool _addFlag=false);
要素の中にnullがあればそこに割り振る場合によってはAddする

*GameObject game=gameObject.GetClosestObjectArray(GameObject[] array);
自身のオブジェクトから一番近いオブジェクトを返します

*game=gameObject.GetClosestObjectList(GameObject[] array);
自身のオブジェクトから一番近いオブジェクトを返します

*gameObject.Destroy();
自身を破壊

*gameObject.GetOrAddComponent<T>();
コンポーネントを取得、なければ追加

*game=gameObject.GetTopParent();
最上層の親オブジェクトを返します。親オブジェクトが存在しない場合自身を返す。

*game=gameObject.GetTopParent(string name,bool includeInactive = false);
深い階層まで子オブジェクトを名前で検索します

*GameObject[] games=gameObject.GetChildren(bool includeInactive = false);
全ての子オブジェクトを返します

*gameObject.SetPositionX(float x);
X座標を設定します

*gameObject.SetPositionY(float y);
Y座標を設定します

*gameObject.SetPositionZ(float z);
Z座標を設定します

*gameObject.AddPositionX(int x);
X座標を加算します

*gameObject.AddPositionY(int y);
Y座標を加算します

*gameObject.AddPositionZ(int z);
Z座標を加算します

*gameObject.ResetPosition();
座標を0にリセットします

*Transform tr = transform.GetTopParent();*//深い階層まで子オブジェクトを名前で検索します
最上層の親オブジェクトを返します。親オブジェクトが存在しない場合自身を返す。

*tr = transform.GetTopParent(string name,bool includeInactive = false);*//全ての子オブジェクトを返します
深い階層まで子オブジェクトを名前で検索します

*Transform[] trs=transform.GetChildren(bool includeInactive = false);*//X座標を設定します
全ての子オブジェクトを返します

*transform.SetPositionX(float x);*//Y座標を設定します
X座標を設定します

*transform.SetPositionY(float y);*//Z座標を設定します
Y座標を設定します

*transform.SetPositionZ(float z);*//X座標を加算します
Z座標を設定します

*transform.AddPositionX(int x);*//Y座標を加算します
X座標を加算します

*transform.AddPositionY(int y);*//Z座標を加算します
Y座標を加算します

*transform.AddPositionZ(int z);*//座標を0にリセットします
Z座標を加算します

*transform.ResetPosition();*}
座標を0にリセットします

*Texture2D tex2D=rt.CreateTexture2D(Camera camera);
レンダラーテクスチャからテクスチャ2Dを生成する(かなり重たい処理なので使用には注意)

*Sprite sprite=tex2D.CreateSprite();
Texture2DからSpriteを作成

*GameObject[] game=GameObjectUtils.FindContainsName(string name);
指定した文字列が含まれているオブジェクトを取得

*T t=RandomUtils .RandomArray<T>(T[] array);;
配列の中の要素をランダムで返す

*T t=RandomUtils .RandomList<T>(List<T> list);
listの中の要素をランダムで返す

*bool flag=RandomUtils .BoolValue();
ランダムでtrueかfalseを返す

*DebugUtils.Log(string message);
ログを出力

*DebugUtils.Log(string message, Color color);
色を変更してログを出力

*DebugUtils.Log(string message, float size,Color color);
サイズと色を変えてログを出力

*DebugUtils.LogError(string message);
エラーログを出力します

*DebugUtils.LogWarning(string message);
警告ログを出力します

*DebugUtils.ArrayLog(T[] array);
配列のログを出します

*[Serializable]
仮の保存用データ

*SaveLoadSystem.Save(date,string fileName,string folderName=SaveFolder);
セーブ

*date=(Date)SaveLoadSystem.Load(string fileName,string folderName=SaveFolder);
ロード

*SaveLoadSystem.EncryptionSave(date,string fileName,string folderName=SaveFolder);
暗号化セーブ

*date=(Date)SaveLoadSystem.EncryptionLoad(string fileName,string folderName=SaveFolder);
暗号化ロード

*SaveLoadSystem._password = "password";
パスワードなどを設定、しなければ初期値でセーブします。


*if (!DateTime.TryParse(inputText2, out DateTime _))
CS8183:「暗黙的に型指定された破棄の型を推論できません」対策として型を指定（ここでは、out の次の DateTime）


*public IReadOnlyReactiveProperty<int> SomeIntReactiveProperty => someIntPropertyEntity;
ReactivePropertyとして参照したい箇所ではこれを参照


*private void method(ref x){//処理}
定義側

*}
処理

*y = method(ref x),,,
*builder.ClearProviders();
ログプロバイダをクリア

*builder.AddConsole();
コンソールログを追加

*builder.AddDebug();
デバッグログを追加

*builder.AddEventLog();
イベントログを追加

*builder.AddEventSourceLogger();
イベントソースを追加

*builder.AddProvider(new SampleLoggerProvider());
独自のログプロバイダを追加

*bool ILogger.IsEnabled(LogLevel logLevel)*{return true;}
指定されたログレベルが出力対象かどうかを取得します。

*private void WriteLogLine(string message)*{Console.WriteLine(new string('\t', m_ScopeLevel) + message));}
指定されたログを出力します。

*private int m_ScopeLevel = 0;
スコープのレベル
スレッドセーフは考慮していません

*IDisposable ILogger.BeginScope<TState>(TState state)*{WriteLogLine($"Begin {state}");++m_ScopeLevel;return new Scope<TState>(state, () =>{// スコープが終了されたときの処理if (m_ScopeLevel > 0) { --m_ScopeLevel; }WriteLogLine("End");});}
スコープが開始されたときの処理を行います。

*private struct Scope<TState> : IDisposable
BeginScope の戻り値として返すオブジェクト。
dispose されたときにスコープの終了処理を行います。

*builder.SetMinimumLevel(LogLevel.Debug);
ログレベルを設定

*builder.AddFilter("System", LogLevel.Warning);
カテゴリに対してフィルタを設定

*builder.AddFilter((provider, category, level) =>*{if (provider.EndsWith("ConsoleLoggerProvider")){if (category.StartsWith("Microsoft")){return (level.CompareTo(LogLevel.Warning) >= 0);}}return true;});
フィルタメソッドで設定（Func<string, string, LogLevel, bool>）

*public class MsExtLoggingEventListener : EventListener*{// イベントソースが生成されたときの処理を行います。protected override void OnEventSourceCreated(EventSource eventSource){// EventSourceLogger は "Microsoft-Extensions-Logging" という名前のイベントソースにログを出力します。if (eventSource.Name == "Microsoft-Extensions-Logging"){// この例では FormattedMessage イベントのすべてのログを有効にしています。EnableEvents(eventSource, EventLevel.Verbose, LoggingEventSource.Keywords.FormattedMessage);}}// ログが書き込まれたときの処理を行います。protected override void OnEventWritten(EventWrittenEventArgs eventData){// この例ではイベントデータの内容をコンソールに出力しています。Console.WriteLine($"EventId = {e.EventId}");Console.WriteLine($"EventName = {e.EventName}");Console.WriteLine($"Keywords = {e.Keywords}");Console.WriteLine($"Level = {e.Level}");Console.WriteLine($"Message = {e.Message}");if (e.PayloadNames != null){for (int i = 0; i < e.PayloadNames.Count; ++i){Console.WriteLine($"Payload[{e.PayloadNames[i]}] = {e.Payload[i]}");}}}}
Microsoft.Extensions.Logging.EventSourceLogger から出力されるログを取得するリスナー

*protected override void OnEventSourceCreated(EventSource eventSource)*{// EventSourceLogger は "Microsoft-Extensions-Logging" という名前のイベントソースにログを出力します。if (eventSource.Name == "Microsoft-Extensions-Logging"){// この例では FormattedMessage イベントのすべてのログを有効にしています。EnableEvents(eventSource, EventLevel.Verbose, LoggingEventSource.Keywords.FormattedMessage);}}
イベントソースが生成されたときの処理を行います。

*EnableEvents(eventSource, EventLevel.Verbose, LoggingEventSource.Keywords.FormattedMessage);
この例では FormattedMessage イベントのすべてのログを有効にしています。

*protected override void OnEventWritten(EventWrittenEventArgs eventData)*{// この例ではイベントデータの内容をコンソールに出力しています。Console.WriteLine($"EventId = {e.EventId}");Console.WriteLine($"EventName = {e.EventName}");Console.WriteLine($"Keywords = {e.Keywords}");Console.WriteLine($"Level = {e.Level}");Console.WriteLine($"Message = {e.Message}");if (e.PayloadNames != null){for (int i = 0; i < e.PayloadNames.Count; ++i){Console.WriteLine($"Payload[{e.PayloadNames[i]}] = {e.Payload[i]}");}}}
ログが書き込まれたときの処理を行います。

*Console.WriteLine($"EventId = {e.EventId}");
この例ではイベントデータの内容をコンソールに出力しています。

*using (var listener = new MsExtLoggingEventListener()){イベントハンドラを使ってイベントソースが生成されたときの処理とログが書き込まれたときの処理を行うことも可能です。listener.EventSourceCreated += listener_EventSourceCreated;
リスナーを生成

*listener.EventSourceCreated += listener_EventSourceCreated;
イベントハンドラを使ってイベントソースが生成されたときの処理とログが書き込まれたときの処理を行うことも可能です。

*await CreateHostBuilder(args).RunConsoleAsync();
アプリケーションの処理を実行
この中でイベントソースに対して出力されたログがリスナーによって取得されます

*static void listener_EventSourceCreated(object sender, EventSourceCreatedEventArgs e)*{// 割愛}
イベントソースが生成されたときの処理を行います。

*}
割愛

*static void listener_EventWritten(object sender, EventWrittenEventArgs e)*{// 割愛}
ログが書き込まれたときの処理を行います。

*}
割愛


*_httpClient.PostAsync("https:
api.line.mev2botmessagereply", stringContent).Wait();


*using System;
Actionに必要

*StartCoroutine(DelayMethod(1, () => {Pause(); }));
1フレーム後にPauseする


*Console.WriteLine(array.Length);
arrayの要素数を表示


*Program2 obj = new Program2();
Program2のインスタンスを生成

*obj.star();
Program2クラスのstarメソッドを実行


*protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)*{base.OnConfiguring(optionsBuilder);optionsBuilder.UseMySQL("MySQL接続文字列");}
一部省略

*this.sampleEntities.Database.EnsureDeleted();
接続文字列記載のデータベースを削除

*this.sampleEntities.Database.EnsureCreated();
接続文字列記載のデータベースを作成

*modelBuilder.Entity<MShop>()
エリアと店舗情報で1:nの関係を作成

*modelBuilder.Entity<TDailySales>()
店舗情報と売上高（日別）で1:nの関係を作成

*modelBuilder.Entity<TMonthlySales>()
店舗情報と売上高（月別）で1:nの関係を作成

*[Column("AREA_ID")]
長くなるため一部プロパティは省略

*[Column("SHOP_ID")]
長くなるため一部プロパティは省略

*[Column("SHOP_ID")]
長くなるため一部プロパティは省略

*public MArea Area { get; set; }
このプロパティが「navigation property」

*[Column("AREA_ID")]*public int AreaId { get; set; }
「Area」が「navigation property name」、「Id」が「principal key property name」

*public MArea Area { get; set; }
このプロパティが「navigation property」

*[Column("AREA_ID")]*public int AreaId { get; set; }
「Area」が「navigation property name」になり、その後ろに「Id」をつける。

*[Column("AREA_ID")]*public int MAreaId { get; set; }
「MArea」が「principal entity name」、「Id」が「principal key property name」

*[Column("AREA_ID")]*public int MAreaId { get; set; }
「MArea」が「principal entity name」になり、その後ろに「Id」をつける。

*MArea area = sampleEntities.Areas.Include(a => a.Shops)
エリア、店舗、売上情報取得

*MArea area1 = new MArea { AreaName = "北海道" };
エリア作成

*MShop shopHokkaido = new MShop { Area = area1, Address = "北海道xxxxxxxxxx", ShopName = "北海道店舗" };
エリアに店舗情報追加

*shopHokkaido.SalesDailies = new List<TDailySales>();*shopHokkaido.SalesDailies.Add(new TDailySales { Shop = shopHokkaido, /*紐づけに必要な情報以外は省略*/ });
店舗に売上情報追加：北海道

*sampleEntities.Areas.Add(area1);
登録内容の追加

*sampleEntities.SaveChanges();
登録内容の保存

*MArea area = sampleEntities.Areas.FirstOrDefault();
エリア情報取得
子要素を取得しなくても、リレーションデータの削除されることを確認。

*sampleEntities.Remove(area);
DbSet経由の削除

*sampleEntities.SaveChanges()
削除内容の保存


*driver.Navigate().GoToUrl("https:
www.google.com");


*IEnumerable<string> s;
前略

*//{//    // somthing...//}
if (s.Count() > 0)


*min = randamValues[i] < min ? randamValues[i] : min;
←ここの書き方で差は出るの？


*_context.Remove(d);
先頭を削除する


*Main.spawnTileY = (int)Main.worldSurface - 100 - 3;
多分-3じゃなくて-2程度がいいかも

*}
なんかの処理
base.Close();  必須


*public static DateTime? collectStartDate = DateTime.Today;
今日の日付

*public MainWindow()*{InitializeComponent();//VMクラスをxaml側に反映させるDataContext = myVM;}
コンストラクタ

*DataContext = myVM;
VMクラスをxaml側に反映させる

*private DateTime? _dayTime;
日付

*public void SetProperty(string PropertyName)*{var e = new PropertyChangedEventArgs(PropertyName);PropertyChanged?.Invoke(this, e);}
変更通知

*public event PropertyChangedEventHandler PropertyChanged;
INotifyPropertyChangedに定義されているイベント


*By.XPath("
ol[@id='b_results']lih2a[contains(text(), 'Microsoft Azure')]")));

*Assert.IsTrue(driver.Title.Contains("Azure Pipelines"), "Verified title of the page");
ページのタイトルに「Azure Pipelines」が含まれていたらテスト成功



*}
略
services.AddScoped<IStateMessageService, StateMessageService>();  追記
略


*uint uiCommand,
RIDI_PREPARSEDDATA


*context.Result = new UnauthorizedResult();
未認証なら401を返す


*using UnityEngine.SceneManagement;
シーン移動するために必要

*public class LoadSceneButton : MonoBehaviour*{//[SerializeField]を使うことでpraivateの状態で//publicと同じようにunityのInspectorで入力できる[SerializeField] string loadsceneName = "";public void LoadSceneButtonDown(){//Inspectorで入力された名前が(loadsceneName)に入り//そのシーンをロードするSceneManager.LoadScene(loadsceneName);}}
using UnityEngine.UI;              UIを使う際に必要

*[SerializeField] string loadsceneName = "";
[SerializeField]を使うことでpraivateの状態で
publicと同じようにunityのInspectorで入力できる

*SceneManager.LoadScene(loadsceneName);
Inspectorで入力された名前が(loadsceneName)に入り
そのシーンをロードする


*public Dictionary<string, Fish> FishDict = new Dictionary<string,Fish>();
銛で突いた魚の名前と数を保存

*================================================/ <summary>
シリアライズ、デシリアライズ時のコールバック

*_fishDictJson = Serialize(FishDict);
Dictionaryはそのまま保存されないので、個別にシリアライズしてテキストで保存

*================================================/ <summary>
取得

*string filePath = GetSaveFilePath();
Jsonを保存している場所のパスを取得

*================================================/ <summary>
保存

*================================================/ <summary>
削除

*================================================private static string GetSaveFilePath(){string filePath = "PlayerDataInstance";
保存先のパス

*private static string GetSaveFilePath()*{string filePath = "PlayerDataInstance";//確認しやすいようにエディタではAssetsと同じ階層に保存//それ以外ではApplication.persistentDataPath以下に保存するように。#if UNITY_EDITORfilePath += ".json";#elsefilePath = Application.persistentDataPath + "/" + filePath;#endifDebug.Log(filePath);return filePath;}
================================================

*#if UNITY_EDITOR
確認しやすいようにエディタではAssetsと同じ階層に保存
それ以外ではApplication.persistentDataPath以下に保存するように。

*================================================/ <summary>
PlayerDataUtility

*private void Start()*{//保存しておいたデータを取得する//static変数を取得PlayerDataInstance _pInstance = PlayerDataInstance.Instance;dataList                      = gameObject.GetComponent<DataList>();//各データを保存していたファイルから取得string lanceName = _pInstance.GetLanceName();//初期状態だとlanceNameが""なので、初期装備を設定//lanceNameが存在するなら該当する装備を取得if (lanceName == ""){lance          = dataList.GetLance("ボロのモリ");lance.IsBought = true;}else{lance = dataList.GetLance(lanceName);}money  = _pInstance.GetMoney();fishes = _pInstance.GetFish();}
（中略）

*PlayerDataInstance _pInstance = PlayerDataInstance.Instance;
保存しておいたデータを取得する
static変数を取得

*string lanceName = _pInstance.GetLanceName();
各データを保存していたファイルから取得

*if (lanceName == "")
初期状態だとlanceNameが""なので、初期装備を設定
lanceNameが存在するなら該当する装備を取得

*}
以下省略


*if (collision.gameObject.CompareTag("gravity"))
オブジェクトにgravityタグ


*PrintArray(buf);
512

*result.Add(block);
ブロックリストに追加

*uint[] chunk_array = new uint[32];
例
バイナリ -> ヘックスデシマル -> uint OR バイナリ -> demical
↓チャンクバイナリ 01100001011000100110001110000000 は ヘックスデミカル 0x61626380 である.
CHUNK: [ 32 ] [0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]
= 0x61626380 したがって uint は 1633837952
コピー先のチャンク配列

*Array.Copy(block, x*32, chunk_array, 0, 32);
ブロックの x*32 から 32byte先までをコピー

*var chunk_binary_str = ToBinary(chunk_array);
バイナリに変換

*int[] hoge = { 0, 1, 2, 3, 4 };
こんな配列が

*Console.WriteLine(hoge);
こうすると

*PrintArray(hoge);
こうなるから
Output: System.Int32
自作関数でラップすると

*,,,
いい感じに出力される
Output: [ 0, 1, 2, 3, 4 ]

*private int StrMid(int source, int indexN)
int文字列から特定の位置にある数字を取り出す
12345
↑indexN
return 2

*Array.Copy(plain_bits, n * BLOCK_SIZE, block, 0, BLOCK_SIZE);
ブロックが複数ある場合も想定されるので、
n*512から512先までをコピーしなければいけない。

*private string MakeHash(uint[] s)*{var n = s.Select((v) => $"{v:X2}");return string.Join("", n).ToLower();}
これも不具合発生.


*}
解析するやつ


*<a href="https:
docs.microsoft.comen-usaspnet" target="_blank">About<a>


*var claims = new[] {new Claim(ClaimTypes.Name, loginParam.Username)};
JWT内に入れるクレームです。

*var token = handler.CreateJwtSecurityToken(audience: JwtSecurityConfiguration.Audience,issuer: JwtSecurityConfiguration.Issuer,subject: subject,signingCredentials: credentials);
ここでトークンを生成しています。

*services
省略
JwtBearerOptionsの設定は別クラスでやる

*return true;
実際は、データベースを見たりする。


*string text1 = textBox1.Text;
各テキストボックスの値を取得

*DateTime Today = dateTimePicker1.Value;
日付を取得

*fbDialog.Description = "週報保存先フォルダを選択";
ダイアログの説明文を指定する

*fbDialog.SelectedPath = @"C:";
デフォルトのフォルダを指定する

*fbDialog.ShowNewFolderButton = true;
「新しいフォルダーの作成する」ボタンを表示する

*string filename = filepath +Today.Year.ToString() +CheckNum(Today.Month.ToString()) +CheckNum(Today.Day.ToString()) +"_週報.txt";
ファイル名決定

*StringBuilder sb = new StringBuilder();
タイトル作成

*sb.Append("■今週の報告\n");
今週の報告

*textBox1.ResetText();
全てのテキストボックスの値をクリアする


*s.Prefixes.Add("http:
IPアドレス:ポート番号");


*saveThisObjPosition = this.gameObject.transform.position;*thisObjPosition.x -= 1;
位置を保存

*this.gameObject.transform.position = thisObjPosition;*x_MoveCount -= 1;
位置を変更

*Debug.Log("hit");
接触したときにパズルの位置が入れ替わる


*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

*Title="MainWindow" Height="300" Width="400" Source="Page1.xaml">
Source追加

*,,,
Gridタグを消去

*public partial class MainWindow : NavigationWindow {public MainWindow() {InitializeComponent();}}
NavigationWindowに変更

*Title="Page1" Loaded="Page1_Loaded">
追加:Loaded

*<Grid>
追加

*public partial class Page1 : Page {private NavigationService _navigation;public Page1() {InitializeComponent();}private void Btn_Click(object sender, RoutedEventArgs e) {Application.Current.Properties["Name"] = _name.Text;var _page2 = new Page2();_navigation.Navigate(_page2);}private void Page1_Loaded(object sender, RoutedEventArgs e) {_navigation = this.NavigationService;}}
追加

*<Grid>
追加

*public partial class Page2 : Page {public Page2() {InitializeComponent();_named.Content = Application.Current.Properties["Name"];}}
変更


*button1.Enabled = false;
前処理

*RunCommandLineAsync();
実行

*using (StreamWriter sw = p.StandardInput){sw.Write(this.textBox5.Text.Trim());
標準入力への書き込み

*p.BeginOutputReadLine();
非同期で出力とエラーの読み取りを開始

*this.Invoke((MethodInvoker)(() => AppendText(outStringBuilder.ToString(), false)));
吐き出されずに残っているデータの吐き出し

*this.Invoke((MethodInvoker)(() => MessageBox.Show("処理をキャンセルしました")));
完了メッセージ

*this.Invoke((MethodInvoker)(() => MessageBox.Show("処理が完了しました")));
完了メッセージ

*this.Invoke((MethodInvoker)(() => MessageBox.Show("エラーが発生しました")));
完了メッセージ

*this.textBox5.Clear();
標準入力エリアのクリア

*this.textBox1.Clear();
標準出力エリアのクリア


*using System;
使うusingのみでOKです。


*driver.Navigate().GoToUrl("http:
localhoststest.html");


*var builder = Host.CreateDefaultBuilder(args)サービスの構成.ConfigureServices((HostBuilderContext context, IServiceCollection services) =>
using Microsoft.Extensions.Options;

*.ConfigureServices((HostBuilderContext context, IServiceCollection services) =>*{// コンフィグを登録services.Configure<SampleOption>(context.Configuration);// JSONパーサーによってバインドできない内容の場合は独自の後処理を実装します。services.Configure<SampleOption>((SampleOption option) =>{// 独自の後処理option.Database.ConnectionString = ModifyConnectionString(option);});// 次のどちらかの方法でサービスを登録// 既定のバインディング// コンフィグのインスタンスは SampleService クラスのコンストラクタを通じて受け取ります。services.AddSingleton<IService, SampleService>();// 既定のバインディングに加えて独自の処理を組み込む必要がある場合、// IServiceProvider.GetRequiredService メソッドでインスタンスを取得できます。// 次のコードはコンフィグインスタンスの注入しか行っていませんので、結果的に上と同じ内容になります。services.AddSingleton<IService, SampleService>((IServiceProvider provider) =>{var option = provider.GetRequiredService<IOptions<SampleOption>>();return new SampleService(option);});});
サービスの構成

*services.Configure<SampleOption>(context.Configuration);
コンフィグを登録

*services.Configure<SampleOption>((SampleOption option) =>*{// 独自の後処理option.Database.ConnectionString = ModifyConnectionString(option);});
JSONパーサーによってバインドできない内容の場合は独自の後処理を実装します。

*option.Database.ConnectionString = ModifyConnectionString(option);*});
独自の後処理

*services.AddSingleton<IService, SampleService>();
次のどちらかの方法でサービスを登録
既定のバインディング
コンフィグのインスタンスは SampleService クラスのコンストラクタを通じて受け取ります。

*services.AddSingleton<IService, SampleService>((IServiceProvider provider) =>
既定のバインディングに加えて独自の処理を組み込む必要がある場合、
IServiceProvider.GetRequiredService メソッドでインスタンスを取得できます。
次のコードはコンフィグインスタンスの注入しか行っていませんので、結果的に上と同じ内容になります。

*public SampleService(IOptions<SampleOption> options)*{}
サービスの定義に従って IServiceCollection に登録されたコンフィグのインスタンスが注入されます。

*var builder = Host.CreateDefaultBuilder(args)コンフィグの構成.ConfigureAppConfiguration((HostBuilderContext context, IConfigurationBuilder builder) =>
using Microsoft.Extensions.Options;

*.ConfigureAppConfiguration((HostBuilderContext context, IConfigurationBuilder builder) =>*{// 実行フォルダの MyAppSettings.json を構成に追加します。// ファイルが存在しない可能性がある場合は optional に true を指定します。builder.AddJsonFile($"MyAppSettings.json", optional: true, reloadOnChange: true);builder.AddJsonFile($"MyAppSettings.{context.HostingEnvironment.EnvironmentName}.json", optional: true, reloadOnChange: true);})
コンフィグの構成

*builder.AddJsonFile($"MyAppSettings.json"
実行フォルダの MyAppSettings.json を構成に追加します。
ファイルが存在しない可能性がある場合は optional に true を指定します。

*.ConfigureServices((HostBuilderContext context, IServiceCollection services) =>*{// コンフィグを登録services.Configure<SampleOption>(context.Configuration);// サービスを登録services.AddSingleton<IService, SampleService>();});
サービスの構成（前述している内容と同じですので割愛しています）

*services.Configure<SampleOption>(context.Configuration);
コンフィグを登録

*services.AddSingleton<IService, SampleService>();
サービスを登録

*var builder = Host.CreateDefaultBuilder(args)コンフィグの構成.ConfigureAppConfiguration((HostBuilderContext context, IConfigurationBuilder builder) =>
using Microsoft.Extensions.Options;

*.ConfigureAppConfiguration((HostBuilderContext context, IConfigurationBuilder builder) =>*{// 指定したプレフィクス（この例では "SAMPLEAPP_"）で始まる環境変数を構成に追加します。// プレフィクスが除かれたキーで読み込まれます。builder.AddEnvironmentVariables(prefix: "SAMPLEAPP_");})
コンフィグの構成

*builder.AddEnvironmentVariables(prefix: "SAMPLEAPP_");
指定したプレフィクス（この例では "SAMPLEAPP_"）で始まる環境変数を構成に追加します。
プレフィクスが除かれたキーで読み込まれます。

*.ConfigureServices((HostBuilderContext context, IServiceCollection services) =>*{// コンフィグを登録services.Configure<SampleOption>(context.Configuration);// サービスを登録services.AddSingleton<IService, SampleService>();});
サービスの構成（前述している内容と同じですので割愛しています）

*services.Configure<SampleOption>(context.Configuration);
コンフィグを登録

*services.AddSingleton<IService, SampleService>();
サービスを登録

*var builder = Host.CreateDefaultBuilder(args)コンフィグの構成.ConfigureAppConfiguration((HostBuilderContext context, IConfigurationBuilder builder) =>
using Microsoft.Extensions.Options;

*.ConfigureAppConfiguration((HostBuilderContext context, IConfigurationBuilder builder) =>*{// 追加の構成ファイルbuilder.AddJsonFile($"MyAppSettings.json", optional: true);// 追加の環境変数builder.AddEnvironmentVariables(prefix: "SAMPLEAPP_");// 最後にコマンドライン引数を読み込んで上書きbuilder.AddCommandLine(args);})
コンフィグの構成

*builder.AddJsonFile($"MyAppSettings.json", optional: true);
追加の構成ファイル

*builder.AddEnvironmentVariables(prefix: "SAMPLEAPP_");
追加の環境変数

*builder.AddCommandLine(args);
最後にコマンドライン引数を読み込んで上書き

*.ConfigureServices((HostBuilderContext context, IServiceCollection services) =>*{// コンフィグを登録services.Configure<SampleOption>(context.Configuration);// サービスを登録services.AddSingleton<IService, SampleService>();});
サービスの構成（前述している内容と同じですので割愛しています）

*services.Configure<SampleOption>(context.Configuration);
コンフィグを登録

*services.AddSingleton<IService, SampleService>();
サービスを登録


*num
= 2; この部分を変更


*static readonly string map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
変換表

*var encodedLength = source.Length * 8 / 6;
エンコード後の長さを計算し、余る長さを求める


*private IEnumerable<Toggle> GetTogglesOf(ToggleGroup toggleGroup)
using System.Linq;が必要


*void Start()*{}
Start is called before the first frame update

*public void OnClickBtn()*{var calendarTrigger = new iOSNotificationCalendarTrigger(){Year = 2020,Month = 1,Day = 1,Hour = 20,Minute = 20,Repeats = false};var notification = new iOSNotification(){// You can optionally specify a custom identifier which can later be// used to cancel the notification, if you don't set one, a unique// string will be generated automatically.Identifier = "_notification_01",Title = "Title",Body = "Scheduled at: 2020年1月1日20時20分",Subtitle = "This is a subtitle, something, something important...",ShowInForeground = true,ForegroundPresentationOption = (PresentationOption.Alert | PresentationOption.Sound),CategoryIdentifier = "category_a",ThreadIdentifier = "thread1",Trigger = calendarTrigger,};iOSNotificationCenter.ScheduleNotification(notification);}
ボタンが押された際に呼び出される関数

*// used to cancel the notification, if you don't set one, a unique*// string will be generated automatically.
You can optionally specify a custom identifier which can later be

*Identifier = "_notification_01",*Title = "Title",
string will be generated automatically.


*ClassA classA = new ClassA();
クラスをインスタンス化し、クラスの変数(あれ、ポインタじゃない？)に格納

*Debug.Log(classA.member_a);
int型のmember_aをUnityのコンソールへ出力

*classA = null;
インスタンスを削除


*string dirPath = Application.dataPath + $"
EditorLocalisations{lang}.lproj";  project内に設置したパスを指定

*string targetGuid = project.GetUnityMainTargetGuid();
似たような関数があるので注意　project.GetUnityFrameworkTargetGuidではない


*blockObj.transform.parent = parentBlockObj.transform;
生成したブロックの親が誰かを教える


*var nameProperty = typeof(Document).GetProperty("Name" + index.ToString());
Name[1-5]プロパティに動的にアクセスし、値を設定

*var ageProperty = typeof(Document).GetProperty("Age" + index.ToString());
Age[1-5]プロパティに動的にアクセスし、値を設定


*return new Tuple<Point[], double>(outputMat.ToArray(), Cv2.ContourArea(c.ToArray()));
MEMO : 角のPointコレクションと面積をペアで返します。

*.Where(c => c.Item2 < myMaxArea && c.Item2 > myMinArea);
MEMO : 面積で区切ってゴミを除去してます。

*return new Tuple<Point2f[], double>(corners, Cv2.ContourArea(c.ToArray()));
MEMO : 角のPointコレクションと面積をペアで返します。

*.Where(c => c.Item2 < myMaxArea && c.Item2 > myMinArea);
MEMO : 面積で区切ってゴミを除去してます。


*sqlCom.Connection = this.sqlConnection;
クエリー送信先、トランザクションの指定

*sqlCom.ExecuteNonQuery();
SQLを実行


*receiveBuffer.Length);
data buffer


*MouseDonwStartPoint = e.GetPosition(MyScrollViewer);
クリックした位置を保存
位置の基準にするControlはなんでもいいが、MouseMoveのほうの基準Controlと合わせること。

*MouseCurrentPoint = e.GetPosition(MyScrollViewer);
マウスの現在位置座標を取得（ScrollViewerからの相対位置）
ここは、位置の基準にするControl(GetPositionの引数)はScrollViewrでもthis(Window自体)でもなんでもいい。
Start時とマウス移動時の差分がわかりさえすればよし。

*double offsetX = MouseCurrentPoint.X - MouseDonwStartPoint.X;
移動開始点と現在位置の差から、MouseMoveイベント1回分の移動量を算出

*Matrix matrix = ((MatrixTransform)MyTarget.RenderTransform).Matrix;
動かす対象の図形からMatrixオブジェクトを取得
このMatrixオブジェクトを用いて図形を描画上移動させる

*matrix.Translate(offsetX, offsetY);
TranslateメソッドにX方向とY方向の移動量を渡し、移動後の状態を計算

*MyTarget.RenderTransform = new MatrixTransform(matrix);*// 移動開始点を現在位置で更新する
移動後の状態を計算したMatrixオブジェクトを描画に反映する

*MouseDonwStartPoint = MouseCurrentPoint;
移動開始点を現在位置で更新する
（今回の現在位置が次回のMouseMoveイベントハンドラで使われる移動開始点となる）

*MouseCurrentPoint = e.GetPosition(MyScrollViewer);
ScaleAt()の拡大中心点(引数3,4個目)に渡すための座標をとるときの基準Controlは、拡大縮小をしたいものの一つ上のControlにすること。
ここでは拡大縮小するGridを包んでいるScrollViewerを基準にした。

*if (e.Delta > 0) scale = 1.25;*else scale = 1 / 1.25;
ホイール上に回す→拡大 / 下に回す→縮小

*matrix.ScaleAt(scale, scale, MouseCurrentPoint.X, MouseCurrentPoint.Y);
拡大実施


*req.Headers.TryGetValue("X-Shopify-Topic", out var topic);*req.Headers.TryGetValue("X-Shopify-Hmac-Sha256", out var hMacSha256);
Read all

*log.LogInformation("Topic was: " + topic );*}
do something if it's not the tipc you are looking for

*log.LogInformation("Domain was: " + domain);*}
do something if it's not the domain you are looking for


*this.DataContext = this;
Windowのクラス自身をDataContextにする


*public class    file_io*{// --------------------------------------------------------------------public static string file_to_str_proc (string file_in){StreamReader fp_in = new StreamReader (file_in);string  buff;StringBuilder stb = new StringBuilder ();while ((buff = fp_in.ReadLine ()) != null){stb.Append (buff);}fp_in.Close();string  str_in = stb.ToString ();return  str_in;}}
--------------------------------------------------------------------

*public static string file_to_str_proc (string file_in)*{StreamReader fp_in = new StreamReader (file_in);string  buff;StringBuilder stb = new StringBuilder ();while ((buff = fp_in.ReadLine ()) != null){stb.Append (buff);}fp_in.Close();string  str_in = stb.ToString ();return  str_in;}
--------------------------------------------------------------------


*}
NameSpaceTest名前空間内にある


*using Microsoft.VisualStudio.TestTools.UnitTesting;
https:github.commicrosofttestfx

*new object[]*{new KanriitakuKeiyaku(){keiyakukinAmount = 100,shohizeiRitsu = 8,// .// .// .// いろいろたくさん},108},
テストケース1

*},
いろいろたくさん

*new object[]*{new KanriitakuKeiyaku(){keiyakukinAmount = 100,shohizeiRitsu = 10,// .// .// .// いろいろたくさん},110}
テストケース2

*},
いろいろたくさん


*static void file_write_proc (string file_name,string str_out)*{try{StreamWriter fp_out = new StreamWriter (file_name);fp_out.Write (str_out);fp_out.Close ();}catch{Console.Error.WriteLine ("*** error *** file_write_proc ***");}}
---------------------------------------------------------------------------

*static void Main(string[] args)*{Console.Error.WriteLine("*** 開始 ***");Dictionary <string,Object> dict_aa= new Dictionary <string,Object> ();dict_aa = dict_append_proc (dict_aa,"t2381","名古屋",74125,"2009-1-7");dict_aa = dict_append_proc (dict_aa,"t0922","小山",17982,"2009-5-19");dict_aa = dict_append_proc (dict_aa,"t0923","佐野",46819,"2009-3-28");dict_aa = dict_append_proc (dict_aa,"t0924","足利",65297,"2009-12-21");dict_aa = dict_append_proc (dict_aa,"t0925","日光",14926,"2009-11-25");dict_aa = dict_append_proc (dict_aa,"t0926","下野",28145,"2009-1-26");dict_aa = dict_append_proc (dict_aa,"t0927","さくら",56784,"2009-1-21");string file_out = "/var/tmp/json/tochigi.json";file_write_proc (file_out,str_json);Console.Error.WriteLine("*** 終了 ***");}
---------------------------------------------------------------------------


*matrix.ScaleAt(scaleDelta, scaleDelta, orgX, orgY);
中心を指定して対象を拡大


*var diContainer = new Container();
アプリケーション設定のいろいろ

*var diContainer = new Container();
アプリケーション設定のいろいろ


*MemoryMappedFile share_mem = null;
必要なものを定義

*const string sharedMemoryName = "MySharedMemory";
共有メモリ名

*public struct _MY_DATA_STRUCT
使用する構造体

*public Form1()
コンストラクタ

*private void btnRead_Click(object sender, EventArgs e)
「共有メモリを読む」ボタンをクリックしたときに発生するイベント

*private void btnWrite_Click(object sender, EventArgs e)
「共有メモリに書き込み」ボタンをクリックしたときに発生するイベント

*private T ReadSharedMemoryAsStruct<T>(string sharedMemoryName, bool createOrOpen = false)
共有メモリを構造体として読み取るジェネリック関数

*T result = new T();
構造体を定義

*private bool WriteSharedMemoryAsStruct<T>(string sharedMemoryName, T targetStruct, bool createOrOpen = false)
共有メモリに構造体として書き込むジェネリック関数

*private void Form1_FormClosing(object sender, FormClosingEventArgs e)
リソースの破棄


*driver.FindElement(By.XPath("
ol[@id='b_results']lih2a[contains(text(), 'Microsoft Azure')]")).Click();


*BlobContainerPermissions permissions = new BlobContainerPermissions{PublicAccess = BlobContainerPublicAccessType.Blob};
Set the permissions so the blobs are public.

*blockBlob.Properties.ContentType = formFile.ContentType;*// upload to blob
Set the object's content type

*blockBlob.UploadFromStream(formFile.OpenReadStream());*// get file uri
upload to blob


*public int GetNameCount(Creature creature)*{return creature.GetName().Length;}
名前をカウントする

*public void AllSpecialAttack(IEnumerable<Creature> creatures)*{foreach (var creature in creatures){creature.SpecialAttack();}}
全員スペシャルアタック！


*}
１多重で実行したい処理

*}
１多重で実行したい処理

*}
１多重で実行したい処理

*waitEndEvent.Wait();
取得完了まで待受

*waitResult = instance.WaitOne();
Mutex取得開始

*releaseEvent.Wait();
Mutexの開放まで待機

*instance.ReleaseMutex();
Mutex開放

*waitEndEvent.Wait();
取得完了まで待受

*waitResult = instance.WaitOne();
Mutex取得開始

*releaseEvent.Wait();
Mutexの開放まで待機

*instance.ReleaseMutex();
Mutex開放


*System.Drawing.Printing.PrintDocument pd = new System.Drawing.Printing.PrintDocument();
印刷

*Image img = Image.FromFile("outQR.png");
画像を読み込む

*e.Graphics.DrawImage(img, e.MarginBounds);
画像を描画する

*e.HasMorePages = false;
次のページがないことを通知する

*img.Dispose();
後始末をする

*printingText = @"QRの内容: " + args[0];
印刷

*Image img = Image.FromFile(QRfilename);
画像を読み込む

*e.Graphics.DrawString(printingText, printFont, Brushes.Black, 0, 0);
画像を描画する
e.Graphics.DrawImage(img, e.MarginBounds);  幅全体に描画する場合。
20, 10 の位置に表示
e.Graphics.DrawImage(img, 20, 10, img.Width, img.Height);  サイズ指定する場合
文字

*e.HasMorePages = false;
次のページがないことを通知する

*img.Dispose();
後始末をする

*printingText = @"QRの内容: " + args[0];
印刷

*string PrinterName;
プリンターを指定して印刷

*Image img = Image.FromFile(QRfilename);
画像を読み込む

*e.Graphics.DrawString(printingText, printFont, Brushes.Black, 0, 0);
画像を描画する
e.Graphics.DrawImage(img, e.MarginBounds);  幅全体に描画する場合。
20, 10 の位置に表示
e.Graphics.DrawImage(img, 20, 10, img.Width, img.Height);  サイズ指定する場合
文字

*e.HasMorePages = false;
次のページがないことを通知する

*img.Dispose();
後始末をする


*securableObject.ResetRoleInheritance();
一旦、固有の権限を削除してから、権限の継承を外す
その際に、実行ユーザー以外の権限をすべてクリアする
※ BreakRoleInheritance メソッドの copyRoleAssignments を false にする


*[System.Runtime.InteropServices.DllImport("NativeOpenCv")]
◆追加：ここから１

*protected override void OnCreate(Bundle savedInstanceState)*{～～割愛～～// ◆追加：ここから２// 黒画像と白画像の割合を指定して、平均輝度値を求めるvar y0 = GetMatMeanY(1, 1);     // 255 * 1/2 = 127.5var y1 = GetMatMeanY(2, 1);     // 255 * 1/3 =  85.0var y2 = GetMatMeanY(200, 300); // 255 * 3/5 = 153.0// ◆追加：ここまで２}
◆追加：ここまで１

*}
◆追加：ここから２
黒画像と白画像の割合を指定して、平均輝度値を求める
var y0 = GetMatMeanY(1, 1);      255 * 1/2 = 127.5
var y1 = GetMatMeanY(2, 1);      255 * 1/3 =  85.0
var y2 = GetMatMeanY(200, 300);  255 * 3/5 = 153.0
◆追加：ここまで２


*もしくは、以下の通り明示的にパスを指定することもできます。2つめの引数falseはエラーを無視するか否かの設定です（false=無視しない）LogManager.Configuration = new XmlLoggingConfiguration("/path/to/NLog.config", false);
NLog.configを出力ディレクトリにコピーするように設定してください。

*var logger = LogManager.GetCurrentClassLogger();
もしくは、以下の通り明示的にパスを指定することもできます。2つめの引数falseはエラーを無視するか否かの設定です（false=無視しない）
LogManager.Configuration = new XmlLoggingConfiguration("/path/to/NLog.config", false);
ロガーの初期化・取得

*logger.Info("test message for info");*logger.Warn("test message for warn");
ログの書き込み

*LogManager.Shutdown();
ロガーの終了。プロセスを終了する前にログを送信するために必要


*await new BlobClient(new Uri("https:
aka.msbloburl")).DownloadToAsync(downloadPath);

*using (FileStream file = File.OpenRead(path)){await blob.UploadAsync(file);
Open the file and upload its data


*var builder = new SQLiteConnectionStringBuilder() {DataSource = dbName,Version = 3,LegacyFormat = false,SyncMode = SynchronizationModes.Off,JournalMode = SQLiteJournalModeEnum.Memory};
SQLite設定

*using(var db = new SQLiteConnection(builder.ToString()))using(var file = new FileStream(csvName, FileMode.Open, FileAccess.Read, FileShare.Read, 65536))using(var csv = new StreamReader(file)) {db.Open();
Database,CSVFileオープン

*private void SkipCSV(SQLiteConnection db, StreamReader csv) {long len = context.GetTable<PwnedPasswordsRow>().Count();for(long i = 0; i < len; i++) {csv.ReadLine();}}
DBから入力済みの行数を取得し、読み飛ばす。


*if ( (ts!=prevTs) && tms == 0 ) {
xx.xxx から yy.000 になったときに表示


*var attack = new SlashAttack();
ここを変えるだけ


*var rect = new Rectangle(0, 0, bmp.Width, bmp.Height);
画像のピクセルを byte[] にコピーする


*string HTMLtext;
前回記事のcs参照

*XDocument xdoc = XDocument.Parse(HTMLtext);
XML解析

*var item_name = e.Element("itemName");
出力パラメータ
単数（item以下に入れ子構造なし）

*foreach (var u in e.Element("mediumImageUrls").Elements("imageUrl"))*Console.WriteLine(u.Value);
複数（item以下に入れ子構造あり）

*Console.WriteLine();
空白行


*m_tr.minVertexDistance = 0.01f;
頂点間の距離 曲線の滑らかさに起因


*w => w.RoleAssignments.Include(r => r.Member.Title,r => r.Member.PrincipalType,対象オブジェクトの権限を与えられたユーザー or SPグループのアクセス許可レベルを読み込むr => r.RoleDefinitionBindings.Include(d => d.BasePermissions,d => d.Name,d => d.RoleTypeKind)));
オブジェクトの権限を読み込む

*r => r.RoleDefinitionBindings.Include(d => d.BasePermissions,d => d.Name,d => d.RoleTypeKind)));
対象オブジェクトの権限を与えられたユーザー or SPグループのアクセス許可レベルを読み込む

*,,,
出力結果
ContosoCommunication 所有者 | SharePointGroup | Administrator | 2147483646 | フル コントロール
ContosoCommunication 所有者 | SharePointGroup | WebDesigner | 1012866479 | デザイン
ContosoCommunication 閲覧者 | SharePointGroup | Reader | 138613009 | 閲覧
ContosoCommunication メンバー | SharePointGroup | Editor | 1011031199 | 編集
user 100 | User | None | 1011029151 | 投稿コピー

*w => w.RoleDefinitions.Include(r => r.RoleTypeKind,r => r.BasePermissions,r => r.Name,r => r.Description));
サイトのアクセス許可レベルを読み込む

*,,,
出力結果
Administrator | 2147483646 | フル コントロール || 完全な制御が可能です。
WebDesigner | 1012866479 | デザイン || 表示、追加、更新、削除、承認、カスタマイズができます。
Editor | 1011031199 | 編集 || リストを追加、編集、削除できます。リスト アイテムとドキュメントを表示、追加、更新、削除できます。
Contributor | 1011029151 | 投稿 || リスト アイテムとドキュメントを表示、追加、更新、および削除できます。
Reader | 138613009 | 閲覧 || ページとリスト アイテム の表示、およびドキュメントのダウンロードができます。
Guest | 134287408 | 制限付きアクセス || 権限を与えられている場合は、特定のリスト、ドキュメント ライブラリ、リスト アイテム、フォルダー、またはドキュメントを表示できます。
None | 1011029151 | 投稿コピー ||


*app.UseForwardedHeaders(new ForwardedHeadersOptions{ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto});
・・・一部省略・・・


*// We can clear the index by deleting it if it exists and creating*// it again
If we have run the sample before, this index will be populated

*// See this link for more information*// https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.search.models.softdeletecolumndeletiondetectionpolicy
corresponding document from the search service

*// The sample data set uses SQL integrated change tracking for change detection*// This means that when the indexer runs, it will be able to detect which data has
https:docs.microsoft.com/en-us/dotnet/api/microsoft.azure.search.models.softdeletecolumndeletiondetectionpolicy

*// See this link for more information*// https://docs.microsoft.com/en-us/sql/relational-databases/track-changes/about-change-tracking-sql-server
changed since the last run using built in change tracking

*DataSource dataSource = DataSource.AzureSql(name: "azure-sql",sqlConnectionString: configuration["AzureSQLConnectionString"],tableOrViewName: "hotels",deletionDetectionPolicy: new SoftDeleteColumnDeletionDetectionPolicy(softDeleteColumnName: "IsDeleted",softDeleteMarkerValue: "true"));
https:docs.microsoft.com/en-us/sql/relational-databases/track-changes/about-change-tracking-sql-server

*// but the connection string may need to be updated if it was changed*await searchService.DataSources.CreateOrUpdateAsync(dataSource);
The data source does not need to be deleted if it was already created,

*// To avoid this, reset the indexer if it exists*exists = await searchService.Indexers.ExistsAsync(indexer.Name);
indexed the sample data and not run again

*// but the connection string may need to be updated if it was changed*await searchService.DataSources.CreateOrUpdateAsync(dataSource);
The data source does not need to be deleted if it was already created,

*// To avoid this, reset the indexer if it exists*exists = await searchService.Indexers.ExistsAsync(indexer.Name);
indexed the sample data and not run again


*$"https:
script.google.commacross{gasId}exec",


*var normal = _holeCanvas.up;
壁の場合, transform.upがnormalになる

*var euler = _holeCanvas.eulerAngles;
eularAngleのxz成分を0にすることで穴の向きを合わせる


*builder.RegisterType<MainWindow>();
Shell の登録

*builder.RegisterType<TraceInterceptor>();
共有オブジェクトの依存関係(ログ、interceptorなど)

*}
AutofacではPrism.Moduleを使えない


*var listCsomByTitle = context.Web.Lists.GetByTitle("CsomByTitle");
SharePoint リストオブジェクトを取得すると同時に
既定でアクセスできない HasUniqueRoleAssignments プロパティを読み込む

*context.Load(listCsomByTitle);
2行で書くバージョン

*context.ExecuteQueryRetry();
1行で書くバージョン
context.Load(listCsomByTitle, l => l, l => l.HasUniqueRoleAssignments);


*}*else {if ( (long)wParam == NativeMethods.WM_LBUTTONDOWN ||(long)wParam == NativeMethods.WM_RBUTTONDOWN ) {_hookExitReq = true;var p = Cursor.Position;_lastPoint = new NativeMethods.POINT(){x=p.X, y=p.Y};timer.Start();}// cancelreturn new IntPtr(1);}
注意：WM_MOUSEMOVE をキャンセルすると、カーソル表示が更新されない


*ss = File.ReadAllLines(commandFile);
, Encoding.GetEncoding("SHIFT_JIS"));

*hasHandle = mutex.WaitOne(0, false);
ミューテックスの所有権を要求する

*hasHandle = true;
別のアプリケーションがミューテックスを解放しないで終了した時


*var results = client.DownloadString( $@"https:
qiita.com:443apiv2items?page={(i+1)}&per_page={DocumentPerPage}" );


*var account = new Account();
Arrange：今回の場合は単純で、Accountクラスの新しいインスタンスを作成するだけ

*account.AddTransaction(200m);
Act：200mという金額を口座に入金

*Assert.AreEqual(200m, account.Balance);
Assert：口座の金額が正しいかチェック

*account.Verify();*}
Assert

*var sut = _accountServiceBuilder.WithAccountCalled("Trading Account").AddTransactionOfValue(200m).Build();
Arrange

*_accountServiceBuilder.MockAccount.Verify();*}
Assert


*user.IncrementSessionTicket();
②

*}
何もしない

*}*public bool IsNull {get { return false; }}
何もしない

*user.IncrementSessionTicket();
Null Objectパターンを適用しないと、ここで例外がスローされる

*}*public string Name {get { return "unknown"; }}
何もしない

*user.IncrementSessionTicket();*Console.WriteLine("The user's name is {0}", userName);
Null Objectパターンを適用しないと、ここで例外がスローされる

*class Program {static Adapter dependency = new Adapter();static void Main(string[] args) {dependency.MethodA();}}
クライアントコード

*class Program {static IExpectedInterface dependency = new Adapter(new TargetClass());static void Main(stirng[] args) {dependency.MethodA();}}
クライアントコード

*currentStrategy = (currentStrategy == strategyA) ? strategyB : strategyA;
呼び出しごとに戦略(ストラテジー)を切り替える


*dic.Add("format", "xml");
取得方法　json または xml

*var mylist = new List<string>();
dic.Add("formatVersion", "2"); jsonのみ２を使える　Default 1
dic.Add("hits", "5");  1ページあたりの取得件数　Default 30
dic.Add("page", "1"); 取得ページ数　Default 1
入力パラメータここまで************************************************************************

*try{   client = new HttpClient();  }
クライアント接続開始

*Task<string> task_get = GetRequest(RequestURL);
URLでHTMLを取得する。

*public static string ToUTF8(string Keyword)*{//String型を16進数バイト型文字列に変換　”楽天”→”%E6%A5%BD%E5%A4%A9”byte[] bytedata = Encoding.UTF8.GetBytes(Keyword);Keyword = "%" + BitConverter.ToString(bytedata).Replace("-", "%");return Keyword;}
keywordだけUTF８のバイト変換が必要

*byte[] bytedata = Encoding.UTF8.GetBytes(Keyword);
String型を16進数バイト型文字列に変換　”楽天”→”%E6%A5%BD%E5%A4%A9”

*async static Task<string> GetRequest(string url)*{HttpResponseMessage response = await client.GetAsync(url);string contentstr = response.StatusCode.ToString();Console.WriteLine("【GetRequest Response】" + contentstr);if (response.StatusCode == System.Net.HttpStatusCode.OK){contentstr = await response.Content.ReadAsStringAsync();}else if (response.StatusCode == HttpStatusCode.Redirect){//StatusCode リダイレクトのときの処理var r = client.GetAsync(url).Result;Uri uri = new Uri(new Uri(url), r.Headers.Location);contentstr = client.GetAsync(uri).Result.Content.ReadAsStringAsync().Result;}return contentstr;}
URLからHTMLをゲット

*var r = client.GetAsync(url).Result;
StatusCode リダイレクトのときの処理


*public class Model : ScriptableObject, IDisposable*{private readonly ReactiveProperty<int> _countReactiveProperty = new ReactiveProperty<int>();public IReactiveProperty<int> CountReactiveProperty => _countReactiveProperty;public void CountUp(){_countReactiveProperty.Value++;}public void Dispose(){_countReactiveProperty?.Dispose();}}
Modelは、ScriptableObjectにするかPresenterないでnew して生成していた

*private void Bind()*{_model.CountReactiveProperty.TakeUntilDestroy(this).Subscribe(_view.UpdateCount);}
Modelからパラメータの変更通知は全てここに書いていた

*private void SetEvent()*{_view.OnCountUpAsObservable().TakeUntilDestroy(this).Subscribe(_ => _model.CountUp());}
Viewからの入力受け取りは全てここに書いていた

*public interface IEntity
このように値の更新と更新通知は別のinterfaceに分けた方がいいよなぁ
と思いつつも、つい一緒にまとめてしまう

*public interface IDamageReduceEntity
このEntityが、防御力を管理している場合、防御力の変化とダメージ計算は用途が違うので
interfaceも別にする

*public void Update(int value)*{_reactiveProperty.Value = value;}
状態の更新、場合によっては別のEntityによって計算された値をUseCaseから受け取ることもある

*public int Calculation(int damage)
例えば防御力など、受けたダメージから防御力の数値を引いた結果をUseCaseに返して
HPを管理しているEntityに渡すことも

*public interface IUseCase*{IReadOnlyReactiveProperty<int> OnDefenseChangeAsObservable();void TakeDamage(int damage);void FindCharacter(string charecterId);}
本来は、TakeDamageとFindCharacterは全く用途が違うので別のクラスに分ける

*public IReadOnlyReactiveProperty<int> OnDefenseChangeAsObservable()*{return _entity.ReactiveProperty;}
EntityのReactivePropertyをそのまま流しているだけなので必要なのか？というお気持ちにになることもしばしば

*}
受け取った結果を現在参照しているCharacterを管理するEntityに書き込む

*IObservable<int> TakeDamageAsObservable();
上位レイヤからのイベントはOnを付ける
View からの入力はOnを付けないようにしている

*public void Initialize()
一時期、入力はController、出力はPresenterに分けようかと考えていたが
面倒になったのと、下記方法でさほど問題を感じなかったのでPresenterに入力も出力も全て書くようにした

*private void Bind()*{_useCase.OnDefenseChangeAsObservable().Subscribe(_outputPort.ChangeDefense).AddTo(_disposable);}
MV(R)P期と同じく上位レイヤからのイベント通知監視はこちらに書く

*private void SetEvent()*{_inputPort.TakeDamageAsObservable().Subscribe(_useCase.TakeDamage).AddTo(_disposable);}
View からの入力イベント監視はこちら側に書く

*public interface IDamageable*{void TakeDamage(int damage);}
View間の参照はViewのinterfaceに任せる

*public IObservable<Unit> ButtonClickAsObservable()*{return _button.OnClickAsObservable();}
Button などの入力もIObservableで返すように統一

*private readonly DiContainer _container = default;
FactoryのみDiContainerをInjectすることを許可している。

*public class Installer : MonoInstaller<Installer>
SceneContextにBindするときはScriptableObjectInstaller
それ以外のときはMonoInstallerを使うことが多い
Installerが肥大化したしたときは、用途やレイヤなどの粒度でInstaller<T>に区切るようにする

*Container.BindInterfacesTo<View>().FromComponentOnRoot();
使うのはほぼBindInterfacesTo<T>のみ
以前はMonoBehaviourのBindにはZenjectBindingを使っていたが、
FromComponentOnRootを見つけてからはこっちに以降
(ドキュメントはよく読もう)


*// in the index for this property and it will only be used by code in the client.*[JsonIgnore]
The JsonIgnore attribute indicates that a field should not be created

*static void Main(string[] args)*{IConfigurationBuilder builder = new ConfigurationBuilder().AddJsonFile("appsettings.json");IConfigurationRoot configuration = builder.Build();SearchServiceClient serviceClient = CreateSearchServiceClient(configuration);string indexName = configuration["SearchIndexName"];Console.WriteLine("{0}", "Deleting index...\n");DeleteIndexIfExists(indexName, serviceClient);Console.WriteLine("{0}", "Creating index...\n");CreateIndex(indexName, serviceClient);ISearchIndexClient indexClient = serviceClient.Indexes.GetClient(indexName);Console.WriteLine("{0}", "Uploading documents...\n");UploadDocuments(indexClient);ISearchIndexClient indexClientForQueries = CreateSearchIndexClient(indexName, configuration);RunQueries(indexClientForQueries);Console.WriteLine("{0}", "Complete.  Press any key to end application...\n");Console.ReadKey();}
This sample shows how to delete, create, upload documents and query an index

*private static void UploadDocuments(ISearchIndexClient indexClient)*{var hotels = new Hotel[]{new Hotel(){HotelId = "1",HotelName = "Secret Point Motel",Description = "The hotel is ideally located on the main commercial artery of the city in the heart of New York. A few minutes away is Time's Square and the historic centre of the city, as well as other places of interest that make New York one of America's most attractive and cosmopolitan cities.",DescriptionFr = "L'hôtel est idéalement situé sur la principale artère commerciale de la ville en plein cœur de New York. A quelques minutes se trouve la place du temps et le centre historique de la ville, ainsi que d'autres lieux d'intérêt qui font de New York l'une des villes les plus attractives et cosmopolites de l'Amérique.",Category = "Boutique",Tags = new[] { "pool", "air conditioning", "concierge" },ParkingIncluded = false,LastRenovationDate = new DateTimeOffset(1970, 1, 18, 0, 0, 0, TimeSpan.Zero),Rating = 3.6,Location = GeographyPoint.Create(40.760586, -73.975403),Address = new Address(){StreetAddress = "677 5th Ave",City = "New York",StateProvince = "NY",PostalCode = "10022",Country = "USA"},Rooms = new Room[]{new Room(){Description = "Budget Room, 1 Queen Bed (Cityside)",DescriptionFr = "Chambre Économique, 1 grand lit (côté ville)",Type = "Budget Room",BaseRate = 96.99,BedOptions = "1 Queen Bed",SleepsCount = 2,SmokingAllowed = true,Tags = new[] { "vcr/dvd" }},new Room(){Description = "Budget Room, 1 King Bed (Mountain View)",DescriptionFr = "Chambre Économique, 1 très grand lit (Mountain View)",Type = "Budget Room",BaseRate = 80.99,BedOptions = "1 King Bed",SleepsCount = 2,SmokingAllowed = true,Tags = new[] { "vcr/dvd", "jacuzzi tub" }},new Room(){Description = "Deluxe Room, 2 Double Beds (City View)",DescriptionFr = "Chambre Deluxe, 2 lits doubles (vue ville)",Type = "Deluxe Room",BaseRate = 150.99,BedOptions = "2 Double Beds",SleepsCount = 2,SmokingAllowed = false,Tags = new[] { "suite", "bathroom shower", "coffee maker" }}}},new Hotel(){HotelId = "2",HotelName = "Twin Dome Motel",Description = "The hotel is situated in a  nineteenth century plaza, which has been expanded and renovated to the highest architectural standards to create a modern, functional and first-class hotel in which art and unique historical elements coexist with the most modern comforts.",DescriptionFr = "L'hôtel est situé dans une place du XIXe siècle, qui a été agrandie et rénovée aux plus hautes normes architecturales pour créer un hôtel moderne, fonctionnel et de première classe dans lequel l'art et les éléments historiques uniques coexistent avec le confort le plus moderne.",Category = "Boutique",Tags = new[] { "pool", "free wifi", "concierge" },ParkingIncluded = false,LastRenovationDate =  new DateTimeOffset(1979, 2, 18, 0, 0, 0, TimeSpan.Zero),Rating = 3.60,Location = GeographyPoint.Create(27.384417, -82.452843),Address = new Address(){StreetAddress = "140 University Town Center Dr",City = "Sarasota",StateProvince = "FL",PostalCode = "34243",Country = "USA"},Rooms = new Room[]{new Room(){Description = "Suite, 2 Double Beds (Mountain View)",DescriptionFr = "Suite, 2 lits doubles (vue sur la montagne)",Type = "Suite",BaseRate = 250.99,BedOptions = "2 Double Beds",SleepsCount = 2,SmokingAllowed = false,Tags = new[] { "Room Tags" }},new Room(){Description = "Standard Room, 1 Queen Bed (City View)",DescriptionFr = "Chambre Standard, 1 grand lit (vue ville)",Type = "Standard Room",BaseRate = 121.99,BedOptions = "1 Queen Bed",SleepsCount = 2,SmokingAllowed = false,Tags = new[] { "jacuzzi tub" }},new Room(){Description = "Budget Room, 1 King Bed (Waterfront View)",DescriptionFr = "Chambre Économique, 1 très grand lit (vue sur le front de mer)",Type = "Budget Room",BaseRate = 88.99,BedOptions = "1 King Bed",SleepsCount = 2,SmokingAllowed = false,Tags = new[] { "suite", "tv", "jacuzzi tub" }}}},new Hotel(){HotelId = "3",HotelName = "Triple Landscape Hotel",Description = "The Hotel stands out for its gastronomic excellence under the management of William Dough, who advises on and oversees all of the Hotel’s restaurant services.",DescriptionFr = "L'hôtel est situé dans une place du XIXe siècle, qui a été agrandie et rénovée aux plus hautes normes architecturales pour créer un hôtel moderne, fonctionnel et de première classe dans lequel l'art et les éléments historiques uniques coexistent avec le confort le plus moderne.",Category = "Resort and Spa",Tags = new[] { "air conditioning", "bar", "continental breakfast" },ParkingIncluded = true,LastRenovationDate = new DateTimeOffset(2015, 9, 20, 0, 0, 0, TimeSpan.Zero),Rating = 4.80,Location = GeographyPoint.Create(33.84643, -84.362465),Address = new Address(){StreetAddress = "3393 Peachtree Rd",City = "Atlanta",StateProvince = "GA",PostalCode = "30326",Country = "USA"},Rooms = new Room[]{new Room(){Description = "Standard Room, 2 Queen Beds (Amenities)",DescriptionFr = "Chambre Standard, 2 grands lits (Services)",Type = "Standard Room",BaseRate = 101.99,BedOptions = "2 Queen Beds",SleepsCount = 4,SmokingAllowed = true,Tags = new[] { "vcr/dvd", "vcr/dvd" }},new Room (){Description = "Standard Room, 2 Double Beds (Waterfront View)",DescriptionFr = "Chambre Standard, 2 lits doubles (vue sur le front de mer)",Type = "Standard Room",BaseRate = 106.99,BedOptions = "2 Double Beds",SleepsCount = 2,SmokingAllowed = true,Tags = new[] { "coffee maker" }},new Room(){Description = "Deluxe Room, 2 Double Beds (Cityside)",DescriptionFr = "Chambre Deluxe, 2 lits doubles (Cityside)",Type = "Budget Room",BaseRate = 180.99,BedOptions = "2 Double Beds",SleepsCount = 2,SmokingAllowed = true,Tags = new[] { "suite" }}}}};var batch = IndexBatch.Upload(hotels);try{indexClient.Documents.Index(batch);}catch (IndexBatchException e){// Sometimes when your Search service is under load, indexing will fail for some of the documents in// the batch. Depending on your application, you can take compensating actions like delaying and// retrying. For this simple demo, we just log the failed document keys and continue.Console.WriteLine("Failed to index some of the documents: {0}",String.Join(", ", e.IndexingResults.Where(r => !r.Succeeded).Select(r => r.Key)));}Console.WriteLine("Waiting for documents to be indexed...\n");Thread.Sleep(2000);}
Upload documents in a single Upload request.

*// retrying. For this simple demo, we just log the failed document keys and continue.*Console.WriteLine("Failed to index some of the documents: {0}",
the batch. Depending on your application, you can take compensating actions like delaying and

*Console.WriteLine("Failed to index some of the documents: {0}",String.Join(", ", e.IndexingResults.Where(r => !r.Succeeded).Select(r => r.Key)));
retrying. For this simple demo, we just log the failed document keys and continue.


*[DllImport("user32.dll",SetLastError = true)]public static extern IntPtr WindowFromPoint(POINT point);
public static extern bool GetCursorPos(out POINT lpPoint);

*using (var g = System.Drawing.Graphics.FromHdc(desktopDC)) {g.DrawLine(pen, (float)((p.X-5)*_highDpiScale), (float)((p.Y-5)*_highDpiScale), (float)((p.X+5)*_highDpiScale), (float)((p.Y+5)*_highDpiScale));
描画が欠ける Scalingがうまくいっていないっぽい

*var p = Cursor.Position;*_lastPoint = new NativeMethods.POINT(){x=p.X, y=p.Y};
NativeMethods.GetCursorPos(out _lastPoint);


*namespace Glossary*{public class GlossaryItem{public string Term { get; set; }public string Definition { get; set; }}}
GlossaryItem.cs

*new GlossaryItem*{Term= "Access Token",Definition = "A credential that can be used by an application to access an API. It informs the API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that has been granted."},
leave the glossary untouched

*[HttpGet]*[Route("{term}")]
new code


*HttpResponseMessage response = await client.GetAsync("http:
192.168.10.254");


*"Path=
MacHomeDocumentsprojectORiN2TutorialCaoPingAppCaoPingApptutorial.xml");

*icmpCtrl = caoWS.AddController("Sample", "CaoProv.ICMP", "","Host=" + textBox_IP_Address.Text);
ICMPプロバイダに接続

*CaoVariable stVar = crdPingStatus.AddVariable(Result.Value);
pingの送信

*eng = new CaoEngine();
CAOエンジンの生成

*icmpCtrl = caoWS.AddController("Sample", "CaoProv.ICMP", "","Host=" + textBox_IP_Address.Text);
ICMPプロバイダに接続

*textBox_Message.Text = icmpVar.Value.ToString();
pingの送信


*var pos = mainCamera.WorldToScreenPoint(target.position) - center;
（画面中心を原点(0,0)とした）ターゲットのスクリーン座標を求める

*bool isOffscreen = (pos.z < 0f || d > 1f);*if (isOffscreen) {pos.x /= d;pos.y /= d;}
ターゲットのスクリーン座標が画面外なら、画面端になるよう調整する

*arrow.enabled = isOffscreen;*if (isOffscreen) {arrow.rectTransform.eulerAngles = new Vector3(0f, 0f,Mathf.Atan2(pos.y, pos.x) * Mathf.Rad2Deg);}
ターゲットのスクリーン座標が画面外なら、ターゲットの方向を指す矢印を表示する

*float canvasScale = transform.root.localScale.z;*,,,
ルート（Canvas）のスケール値を取得する

*var halfSize = 0.5f * canvasScale * rectTransform.sizeDelta;*,,,
UI座標系の値をスクリーン座標系の値に変換する

*rectTransform.anchoredPosition = pos / canvasScale;*,,,
スクリーン座標系の値をUI座標系の値に変換する


*string[] args = Environment.GetCommandLineArgs();
コマンドライン引数を取得

*var filePath = arg.Substring("XXX:".Length);
カスタムURLスキームを取り除いた文字列をファイルパスとみなして取得する

*...
filePathを用いてファイルを開く

*string[] args = Environment.GetCommandLineArgs();
コマンドライン引数を取得

*var filePath = arg.Substring("XXX:".Length);
カスタムURLスキームを取り除いた文字列をファイルパスとみなして取得する

*Process.Start("notepad.exe", filePath);
(ここまでは、前の章のソースコードと同じ)
filePathをパラメータに指定して「notepad」でファイルを開く


*private LoadingDelayTimer_Tick(object sender, EventArgs e)*{LoadingDelayTimer.Stop();LoadData();}
DelayTimerのTickイベントハンドラ

*private ListView_SelectedIndexChanged(object sender, EventArgs e)*{LoadingDelayTimer.Stop();LoadingDelayTimer.Start();}
ListViewのSelectedIndexChangedイベントハンドラ

*private void LoadData()*{...}
データ呼び出し処理


*for (int page番号 = 1; page番号 <= reader.NumberOfPages; page番号++)
このpage番号は1オリジンです

*string debug_text_UTF8 = System.Text.Encoding.UTF8.GetString(data);
制御の文字列（オペレータ）は以下に詳しく書かれています。
http:www.kobu.com/docs/pdf/pdfxhand.htm

*match_count++;
合致したケース


*await Task.Delay(200);
何秒ごとにフラグが変わるかのポーリングの秒数なのでお好きにどうぞ


*istr = new C<object>();
NG コンパイルエラー


*wpfWindow.ShowDialog();
modalの場合

*,,,
wpfWindow.Show();        modelessの場合

*var helper = new System.Windows.Interop.WindowInteropHelper(wpfWindow);
Window Handleを操作するためのHelper

*helper.Owner = new System.IntPtr(InventorApplication.MainFrameHWND);
親を設定する

*,,,
表示する
wpfWindow.ShowDialog();     modalの場合
wpfWindow.Show();        modelessの場合

*var wpfWindow = new WpfWindow();
WPF Windowの初期化

*var helper = new WindowInteropHelper(wpfWindow);
WPF WindowのHandleを得る

*var dockableWindow = InventorApplication.UserInterfaceManager.DockableWindows.Add(System.Guid.NewGuid().ToString(), "Test", "Test");
Dockable Windowの作成

*HwndSource.FromHwnd(handle).AddHook(WndProc);
Key hookをセット


*var response = await Client.DeleteAsync("http:
localhost:19691apivalues5");

*BenchmarkRunner.Run<WebApiClient>();
計測を開始する

*public IEnumerable<string> Get()*{return new string[] { "value1", "value2" };}
GET api/values

*public string Get( int id )*{return "value";}
GET api/values/5

*public void Post( [FromBody]string value )*{}
POST api/values

*public void Put( int id, [FromBody]string value )*{}
PUT api/values/5

*public void Delete( int id )*{}
DELETE api/values/5


*else {
0の場合はエラーの可能性がある

*static class NativeMethods*{[DllImport("user32.dll", SetLastError = true)]public static extern int GetWindowThreadProcessId(IntPtr hWnd, out int lpdwProcessId);}
定義部

*void hoge()*{int pid;NativeMethods.GetWindowThreadProcessId(hWnd, out pid);Process p = Process.GetProcessById(pid);}
使用部

*static class NativeMethods*{[StructLayout(LayoutKind.Sequential)]public struct WINDOWINFO{public int   cbSize;public RECT  rcWindow;public RECT  rcClient;public int   dwStyle;public int   dwExStyle;public int   dwWindowStatus;public uint  cxWindowBorders;public uint  cyWindowBorders;public short atomWindowType;public short wCreatorVersion;}[StructLayout(LayoutKind.Sequential)]public struct RECT{public int left;public int top;public int right;public int bottom;}[DllImport("user32.dll",SetLastError = true)]public static extern int GetWindowInfo(IntPtr hwnd, ref WINDOWINFO pwi);}
定義部

*public static WINDOWINFO MyGetWindowInfo(IntPtr hWnd, out int retCode)*{var wi = new WINDOWINFO();wi.cbSize = Marshal.SizeOf(wi);retCode = NativeMethods.GetWindowInfo(hWnd, ref wi);return wi;}
使用部

*static class NativeMethods*{[DllImport("user32")]public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);}
定義部

*static IntPtr SetTabStop(TextBoxBase t, int tabSize)*{int[] tabarray = new int[] { tabSize*4 };int wparam = tabarray.Length;IntPtr parray = Marshal.AllocCoTaskMem(Marshal.SizeOf(typeof(int)) * tabarray.Length);Marshal.Copy(tabarray, 0, parray, tabarray.Length);IntPtr ret = SendMessage(t.Handle, EM_SETTABSTOPS, new IntPtr(wparam), parray);// 解放処理が漏れている。 Marshal.FreeCoTaskMem とかで解放してください。return ret;}
使用部

*return ret;
解放処理が漏れている。 Marshal.FreeCoTaskMem とかで解放してください。


*MixedType list = new MixedType.L(new List<int> { 1, 2 });
listにはIList<int>型の値が入る

*var tuple = new MixedType.T(1, 1);
MixedType型のtupleに対して(1, 1)というタプル値が入る

*var bResult = new MixedType.U( B true);
MixedType型のbResultに対してbool型のtrueという値が入る

*case T (x, y) : x + y,
tupleに入っている値がTのものなら (1,1) → 1+1 つまり2をxへ

*Verify.InRange(index, 0, array.Length - 1);*return array[index];
"index (6) cannot be greater than array.Length - 1 (5)."

*IEnumerable<KeyValuePair<string, int>> Headers = new[]*{new KeyValuePair<string, string>("Hoge", 1),new KeyValuePair<string, string>("Piyo", 3),}
簡略化前

*IEnumerable<KeyValuePair<string, string>> Headers = new KeyValuePair<string, string>[]*{new("Hoge", 1),new("Piyo", 3),}
簡略化後

*IEnumerable<KeyValuePair<string, string>> Headers = new[]*{new("Hoge", 1),new("Piyo", 3),}
更に簡略化後


*var imgPath = Path.Combine(testDataDir, "foo.png");
テストクラスやテストメソッドのリネームに追随できるよう、nameofを使ってパスを定義
var testDataDir = Path.Combine(nameof(SomeTestClass), nameof(SomeTest));  <- テストケースごとに書きかえる必要がある
ディレクトリ内のテストデータを読んでテストする


*System.Console.Write("Hello ");
Systemは省略可能

*処理C
上記の条件に当てはまらない場合

*処理C
上記の条件に当てはまらない場合

*var list = new List<string>();
宣言

*list.Add("Tokyo");
var オブジェクト名　= new List<型>(要素数);
追加

*list.Remove("Osaka");
削除

*Console.WriteLine("[{0}]", string.Join(", ", list));
出力

*>>> [Tokyo, Nagoya]
出力結果

*dict.Add(1,"aaa");
Dictionary<Keyの型名, Valueの型名> オブジェクト名 = new Dictionary<Keyの型名, Valueの型名>()
追加

*dict.Remove(2)
削除

*Console.WriteLine(dict[3])
出力


*static bool OnPreGeneratingCSProjectFiles()*{Debug.LogFormat("<color=cyan>OnPreGeneratingCSProjectFiles</color>");return false;}
Unity標準のジェネレータ「以外」でC#プロジェクトを生成するかどうか返すコールバック(UnityVS等で利用).

*static string OnGeneratedCSProject(string path, string content)*{Debug.LogFormat("<color=blue>OnGeneratedCSProject:</color> {0}\n\n{1}", path, content);return content;}
C#プロジェクトファイルが生成された後に、修正を適用するコールバック.

*static string OnGeneratedSlnSolution(string path, string content)*{Debug.LogFormat("<color=orange>OnGeneratedSlnSolution:</color> {0}\n\n{1}", path, content);return content;}
C#ソリューションファイルが生成された後に、修正を適用するコールバック.

*static void OnGeneratedCSProjectFiles()
VisualStudioのバージョンアップによってcsprojがUnityと互換性が無くなったときの「セーフガード」.
後処理でcsprojを修正、または作り直す. 願わくば、これが必要になりませんように.
...とソースコードに書いてあった(意訳)

*var csc = Paths.Combine(EditorApplication.applicationContentsPath, "Tools", "RoslynScripts", "unity_csc");
プラットフォームに合ったコンパイラ（unity_csc）を探す

*if (!File.Exists(csc))*ThrowCompilerNotFoundException(csc);
コンパイラが見つからなかったら例外

*var psi = new ProcessStartInfo() { Arguments = "/noconfig @" + assembly.GeneratedResponseFile, FileName = csc, CreateNoWindow = true };
ProcessStartInfoを生成し、新しいコンパイルプロセスを開始

*foreach (var t in types)
typesにはCSharpLanguageしか入っていないので、以下と同じ
SupportedLanguages.Add(new CSharpLanguage());

*CSharpSupportedLanguage = SupportedLanguages.Single(l => l.GetType() == typeof(CSharpLanguage));
SupportedLanguagesにはCSharpLanguageしか入っていないので以下略

*ScriptCompilers.SupportedLanguages.RemoveAll(x => x.GetType() == typeof(CustomCSharpLanguage));
SupportedLanguagesにカスタムC#を追加.

*typeof(ScriptCompilers)
CSharpSupportedLanguageはreadonlyなのでリフレクションで上書き.

*EditorBuildRules.GetPredefinedTargetAssemblies()
こちらも上書き.

*bool useCustomCompiler = true;
カスタムコンパイラを使うかどうかのフラグ.
ScriptAssemblyやMonoIslandにはファイル一覧、参照一覧、シンボル一覧、出力ファイル名などの情報が格納されている.
それに応じて必要なアセンブリのみコンパイラを切り替えることが可能。

*return new CustomCSharpCompiler(island, runUpdater);
カスタムコンパイラを使う.

*return base.CreateCompiler(scriptAssembly, island, buildingForEditor, targetPlatform, runUpdater);*}
使わない場合はデフォルトのコンパイラを使う.

*var p = base.StartCompiler();
継承元のコンパイルプロセスは即終了させる.

*// 複数のファイルが生成される場合があるので、outオプションで判定する.*var outopt = string.Format("/out:\"{0}\"", m_Island._output);
最後に生成されたresponse fileを取得する.

*var outopt = string.Format("/out:\"{0}\"", m_Island._output);
複数のファイルが生成される場合があるので、outオプションで判定する.

*var psi = new ProcessStartInfo(){Arguments = ...,FileName = ...,CreateNoWindow = true};
自作のコンパイラでresponse fileを処理する.

*var program = new Program(psi);
プロセスを開始する.


*string url_action = "./logini";
ログインページ
string url_login = "https:grp01.id.rakuten.co.jp/rms/nid/vc?__event=login&service_id=top";
formタグ内のaction

*string url_post = url_login + url_action;
POST要求先

*string USER_ID = "XXXXXXXXXXXXXX@mineo.jp";
ログイン後にジャンプするページ(ホーム画面)
string url_history = "https:www.rakuten.co.jp/";

*client = new HttpClient();
クライアント接続開始

*Task<bool> task_login = PostRequest(url_post, USER_ID, PASSWORD);
POST要求（ログインしてクッキー取得）

*Console.WriteLine(HTMLtext);
HTMLテキスト確認

*Console.ReadKey();
HTML構造解析
string resultstr = AnalizeHtml(50, HTMLtext);
ファイルの保存（別タスクで非同期処理　続けて処理をおこなうときはWait()を削除する）
Task task1 = Task.Run(() => { SaveFile(resultstr); });
task1.Wait();
End待機
Thread.Sleep(1000);

*async static Task<bool> PostRequest(string url_post, string user, string password)*{//POSTで送る内容作成。mContent.Add(属性の値, 属性の名前)MultipartFormDataContent mContent = new MultipartFormDataContent();mContent.Add(new StringContent(user), "u");mContent.Add(new StringContent(password), "p");//ヘッダ情報確認Console.WriteLine("【PostRequest Headers】" + mContent.Headers);//POSTしてレスポンスの要求。（要求先、要求内容）HttpResponseMessage response = await client.PostAsync(url_post, mContent);Console.WriteLine("【PostRequest Response】 " + response.StatusCode.ToString());if (response.StatusCode == HttpStatusCode.OK){//応答ステータスがOKならHTML文字列を取得する。string contentstr = await response.Content.ReadAsStringAsync();Console.WriteLine("【PostRequest HTMLcontent】" + contentstr);Console.WriteLine("【PostRequest Cookie】" + response.Headers.GetValues("Set-Cookie").First());}return true;}
POST要求（ログイン）

*MultipartFormDataContent mContent = new MultipartFormDataContent();
POSTで送る内容作成。mContent.Add(属性の値, 属性の名前)

*Console.WriteLine("【PostRequest Headers】" + mContent.Headers);
ヘッダ情報確認

*HttpResponseMessage response = await client.PostAsync(url_post, mContent);
POSTしてレスポンスの要求。（要求先、要求内容）

*string contentstr = await response.Content.ReadAsStringAsync();
応答ステータスがOKならHTML文字列を取得する。

*MultipartFormDataContent mContent = new MultipartFormDataContent();
POSTで送る内容作成。mContent.Add(属性の値, 属性の名前)

*Console.WriteLine("【PostRequest Headers】" + mContent.Headers);
ヘッダ情報確認

*HttpResponseMessage response = await client.PostAsync(url_post, mContent);
POSTしてレスポンスの要求。（要求先、要求内容）

*string contentstr = await response.Content.ReadAsStringAsync();
応答ステータスがOKならHTML文字列を取得する。

*var r = client.GetAsync(url).Result;
StatusCode リダイレクトのときの処理


*[HttpGet(Name = "hello")]public String Hello(){return "Hello!";
GET: Hello


*private Transform cHips;*private Transform lUpperLeg;
transformを保管する変数

*cHips = transform.Find("Root")*.Find("J_Bip_C_Hips");
腰のtransformを取得

*lUpperLeg = cHips.Find("J_Bip_L_UpperLeg");
股関節のtransformを取得

*lUpperLeg.rotation = Quaternion.AngleAxis(-30.0f, Vector3.right);
脚を30°傾ける

*float pendulum = (float)Math.Sin(Time.time * Math.PI);
1秒周期の振り子を用意する

*lUpperLeg.localRotation = Quaternion.AngleAxis(-60.0f * pendulum, Vector3.right);
股関節を右軸（x軸）を中心に±60°幅で揺らす

*lLowerLeg = lUpperLeg.Find("J_Bip_L_LowerLeg");
膝のtransformを取得

*lUpperLeg.localRotation = Quaternion.AngleAxis(-60.0f * pendulum - 20.0f, Vector3.right);
股関節の動きを少し変更

*lLowerLeg.localRotation = Quaternion.AngleAxis(-60.0f * pendulum + 60.0f, Vector3.right);
膝を揺らす

*cHips = transform.Find("Root")*.Find("J_Bip_C_Hips");
全身の関節のtransformを取得

*float pendulum = (float)Math.Sin(Time.time * Math.PI * 3.0f);
速度を3倍に変更

*lUpperLeg.localRotation = Quaternion.AngleAxis(-60.0f * pendulum - 20.0f, Vector3.right);
脚を揺らす

*cHips.localRotation = Quaternion.AngleAxis(10.0f * pendulum, Vector3.up) * Quaternion.AngleAxis(10.0f, Vector3.right);
腰にひねりを加える

*cChest.localRotation = Quaternion.AngleAxis(-10.0f * pendulum, Vector3.up);
胸は腰と反対にひねる

*lUpperArm.localRotation = Quaternion.AngleAxis(60.0f * pendulum + 30.0f, Vector3.right) * Quaternion.AngleAxis(70.0f, Vector3.forward);*rUpperArm.localRotation = Quaternion.AngleAxis(-60.0f * pendulum + 30.0f, Vector3.right) * Quaternion.AngleAxis(-70.0f, Vector3.forward);
腕を揺らす

*private Vector3 firstHipsPosition;
腰の初期位置を保管する変数

*firstHipsPosition = cHips.localPosition;
腰の初期値を取得する

*float halfPendulum = (float)Math.Sin(Time.time * Math.PI * 3.0f * 2.0f);
周期が半分の振り子を用意する

*cHips.localPosition = firstHipsPosition + new Vector3(0.0f, 0.04f * halfPendulum, 0.0f);
腰の位置を上下させる


*delegate int AddDelegate(int a,int b);
delegate 戻り値定義 デリゲート名(引数定義)

*AddDelegate add = new AddDelegate(Add);
宣言したデリゲート型インスタンスを生成
その際にメソッドを登録(Addメソッド)

*static int Add(int a,int b)*{return a + b;}
2つの整数の加算結果を返すメソッド


*public partial class MainPage : ContentPage*{public MainPage(){InitializeComponent();webView.Navigated += (s, e) =>{progressView.IsVisible = false;webView.IsVisible = true;};}}
略

*Plugin.CurrentActivity.CrossCurrentActivity.Current.Init(this, savedInstanceState);
ココ！

*PermissionsImplementation.Current.OnRequestPermissionsResult(requestCode, permissions, grantResults);
ココ！

*var permissions = new []{Permission.Location,Permission.Camera,};
許可を求める権限群

*var notPermitteds = new List<Permission>();
許可を得ていない権限群

*var statusMap = await CrossPermissions.Current.RequestPermissionsAsync(notPermitteds.ToArray());
許可を求めるダイアログボックスを出す

*}
許可されたら Web アプリ起動
webView.Source = "https:5ce07f72.ngrok.io";


*void Test(string s)*{if(s is null){throw new ArgumentNullException(nameof(s));}...}
これまでの書き方

*void Test(string s!)*{...}
C# 9.0で提案されている書き方


*int NumKeys;
セグメントの総数

*float DistanceToT(float distance)*{float d = distance / DistanceStepSize;int index = Mathf.FloorToInt(d);if(index>=DistanceToTArray.Length-1)return DistanceToTArray[DistanceToTArray.Length-1];float t = d - index;return Mathf.Lerp(DistanceToTArray[index], DistanceToTArray[index+1], t);}
距離からtに変換

*float[] CalcTToDistance()*{var tToDistance = new float[NumKeys];var pp = Paths[0].Pos;float t = 0;for (int n = 1; n < NumKeys; n++){t += 1f / Segment;Vector3 p = CalcPos(t);float d = Vector3.Distance(pp, p);PathLength += d;pp = p;tToDistance[n] = PathLength;}return tToDistance;}
tをSegmentに分割して進んだ距離を配列に入れて返す

*float[] CalcDistanceToT(float[] tToDistance)*{var distanceToT = new float[NumKeys];distanceToT[0] = 0;DistanceStepSize = PathLength/(NumKeys-1);float distance = 0;int tIndex=1;for (int i = 1; i < NumKeys; i++){distance += DistanceStepSize;var d = tToDistance[tIndex];while (d < distance && tIndex < NumKeys - 1){tIndex++;d = tToDistance[tIndex];}var prevD = tToDistance[tIndex - 1];float delta = d - prevD;float t = (distance - prevD) / delta;distanceToT[i] = (1f/Segment)*(t + tIndex - 1);}return distanceToT;}
距離をSegmentに分割してその位置のtを配列に入れて返す


*var saved = false;
データを取得
(1) 保存したいデータと現在のDBのデータを比較して保存する値を決める

*}
(2)　ここで(1)と同じ操作をしなくてはならない


*Player_Nav = GetComponent<NavMeshAgent>();
プレイヤーのNavMeshAgentを取得

*Destination = GameObject.Find("Destination");
目的地のオブジェクトを取得

*Player_Nav.SetDestination(Destination.transform.position);*}
目的地を設定


*ShowPerOne("ウホウホバナナヨコセ");
実行サンプル 文字を1文字ずつ出す

*m_updateDispose =  this.UpdateAsObservable().FirstOrDefault(_ => Input.GetKeyDown(m_keyCode))
特定のキー入力で文字を1文字ずつ出す機能を止める

*m_updateDispose =  this.UpdateAsObservable().FirstOrDefault(_ => Input.GetKeyDown(m_keyCode))
特定のキー入力で文字を1文字ずつ出す機能を止める


*string ret_text = System.Text.Encoding.Unicode.GetString(buf);
Unicodeは .Net では UTF-16 と同義です。


*.ToUniTask();
UniTask<T[]>


*}
コード入れる

*}
コード入れる

*string jsonData = JsonUtility.ToJson(r);
JSON作成とアプリのデータパスに保存します。


*builder = JWTBuilder.Create(),,,builder = builder.WithAlgorithm(new HMACSHA256Algorithm()),,,builder = builder.WithSecret(secret),,,builder = builder.AddHeader(headerName, object)builder = builder.AddClaim(claimName, object),,,token = builder.Encode(),,,token =  JWTBuilder.Create().WithAlgorithm(new HMACSHA256Algorithm()).WithSecret(secret).AddHeader(headerName, object1).AddClaim(claimName, object2).Encode(),,,
*void Start()*{rigidbody = GetComponent<Rigidbody>();}
Start is called before the first frame update

*void Update()*{float moveH = Input.GetAxis("Horizontal");float moveV = Input.GetAxis("Vertical");Vector3 move = new Vector3(moveH, 0, moveV);rigidbody.AddForce(move);}
Update is called once per frame


*internal class InputClass*{internal int CustomerID { get; set; }internal long ProductID { get; set; }internal double DiscountRate { get; set; }}
入力用クラス

*internal class OutputClass*{internal int CustomerID { get; set; }internal int TotalPrice { get; set; }}
出力用クラス

*internal class Product*{internal long ProductID { get; set; }internal int Price { get; set; }}
商品クラス

*internal class Products : List<Product>*{internal Products(){Add(new Product() { ProductID = 10000000001, Price = 100 });Add(new Product() { ProductID = 10000000002, Price = 200 });Add(new Product() { ProductID = 10000000003, Price = 300 });Add(new Product() { ProductID = 20000000004, Price = 1000 });Add(new Product() { ProductID = 20000000005, Price = 2000 });Add(new Product() { ProductID = 20000000006, Price = 3000 });}}
商品マスタ

*var inputs = getData();
入力

*var outputs = new Calculator().Calculation(inputs);
出力

*static IEnumerable<InputClass> getData()*{var input = new List<InputClass>();input.Add(new InputClass { CustomerID = 1, ProductID = 10000000001, DiscountRate = 0.88 });input.Add(new InputClass { CustomerID = 1, ProductID = 10000000002, DiscountRate = 0.19 });input.Add(new InputClass { CustomerID = 1, ProductID = 10000000003, DiscountRate = 0.52 });input.Add(new InputClass { CustomerID = 2, ProductID = 20000000004, DiscountRate = 0.33 });input.Add(new InputClass { CustomerID = 2, ProductID = 20000000005, DiscountRate = 0.56 });input.Add(new InputClass { CustomerID = 3, ProductID = 20000000006, DiscountRate = 0.75 });return input;}
DBからデータを取得。今回は手打ち。

*internal class Calculator*{// 計算を実施する。internal IEnumerable<OutputClass> Calculation(IEnumerable<InputClass> inputs){// 商品マスタの取得var products = new Products();// 中間エンティティを用いて1レコードごとの価格を計算する。var middles = JoinAndCalcProductPrice(inputs, products);// 顧客ごとの集計と同時に結果オブジェクトに変換する。var results = SumPriceAndConvertToOutputs(middles);return results;}// 商品マスタから価格を取得する。計算はオブジェクト側で行う。privete IEnumerable<MiddleClass> JoinAndCalcProductPrice(IEnumerable<InputClass> inputs, IEnumerable<Product> products) => inputs.Join(products,i => i.ProductID,p => p.ProductID,(input, product) => new MiddleClass{CustomerID = input.CustomerID,DiscountRate = input.DiscountRate,Price = product.Price});// 顧客ごとの金額合計を取得して出力クラスにマッピングする。private IEnumerable<OutputClass> SumPriceAndConvertToOutputs(IEnumerable<MiddleClass> middles) => middles.GroupBy(c => c.CustomerID).Select(c => new OutputClass{CustomerID = c.Key,TotalPrice = c.Sum(s => s.Price)});}
計算クラス

*internal IEnumerable<OutputClass> Calculation(IEnumerable<InputClass> inputs)*{// 商品マスタの取得var products = new Products();// 中間エンティティを用いて1レコードごとの価格を計算する。var middles = JoinAndCalcProductPrice(inputs, products);// 顧客ごとの集計と同時に結果オブジェクトに変換する。var results = SumPriceAndConvertToOutputs(middles);return results;}
計算を実施する。

*var products = new Products();
商品マスタの取得

*var middles = JoinAndCalcProductPrice(inputs, products);
中間エンティティを用いて1レコードごとの価格を計算する。

*var results = SumPriceAndConvertToOutputs(middles);
顧客ごとの集計と同時に結果オブジェクトに変換する。

*privete IEnumerable<MiddleClass> JoinAndCalcProductPrice(IEnumerable<InputClass> inputs, IEnumerable<Product> products) => inputs
商品マスタから価格を取得する。計算はオブジェクト側で行う。

*private IEnumerable<OutputClass> SumPriceAndConvertToOutputs(IEnumerable<MiddleClass> middles) => middles
顧客ごとの金額合計を取得して出力クラスにマッピングする。

*internal const double _tax = 0.1;
税率

*internal int CustomerID;
入力側プロパティ ▽

*private int DiscountPrice => Price - (int)(Price * DiscountRate);
出力用プロパティ ▽
入力値が設定されていれば参照時にこの値は決定する。大きいプログラムだとこのプロパティが増えていく。
後々使う可能性があるので割引後価格は単独で持つ。

*internal int CalculatedPrice => DiscountPrice + (int)(discountPrice * _tax);
計算結果を持つプロパティ。入力が変われば割引後価格が変わり、計算結果も連動して変わる。


*if(isIndexStraight && !isMiddleStraight  && !isRingStraight  && !isPinkyStraight ){
人差し指だけまっすぐで、その他が曲がっている


*await jsRuntime.InvokeVoidAsync("barcodeScan.startCapture", DotNetObjectReference.Create(this));
カメラを起動して画面のキャプチャを開始するJS側の関数を呼び出し

*await StopCapture();
例外発生時にはカメラを止めて失敗イベントを発火

*}
バーコード検出時の処理

*BookInfo = await BookInfoClient.GetBookInfoAsync(isbn13);
APIを呼び出して情報を取得


*public int Hp { get { return hp; }}
古いC#でのゲッターオンリーのプロパティ

*public int Hp => hp;
新しいC#では短く書けるゲッターオンリーのプロパティ

*public int Hp*{get { return hp; }set { hp = value; }}
古いC#でのセッター・ゲッタープロパティ

*public int Hp*{get => hp;set => hp = value;}
新しいC#でのセッター・ゲッタープロパティ

*public int Name { get; private set; }
自動実装プロパティ

*private readonly string name;
古いC#では、readonlyのために自動実装プロパティでなく
バッキングフィールドを使う

*public string Name { get; }
新しいC#では、readonlyの自動実装プロパティが使える

*private  string name = "No Name";
古いC#では初期値を設定するために、バッキングフィールドを使う
自動実装プロパティは使えない

*// 自動実装プロパティを使える*public string Name { get; set; } = "No Name";
新しいC#では初期値の設定とともに

*public string Name { get; set; } = "No Name";
自動実装プロパティを使える

*[field:SerializeField]*public int Hp { get; }
Unityでは使ってはいけない

*public static (string name, int level) LoadNameAndLevel() => (name: "Ryota", level: 31);
ValueTupleを返すLoadNameAndLevel

*var (name, level) = LoadNameAndLevel();
分解で返値を受け取る
stringのnameとintのlevel

*Player player = LoadPlayer();
古いC#では冗長

*var targetMonsterName = player?.Target?.Name;
新しいC#ではこんな感じに簡潔に書ける

*Player player = LoadPlayer();
古いC#の書き方

*var targetMonsterName = player?.Target?.Name ?? "Default Target Name";
新しいC#ではこんな感じに簡潔に書ける

*public static void SwitchExample0(object obj)*{switch (obj){case int n when n < 0:Debug.Log("負の数だよ！");break;case 7:Debug.Log("ラッキーセブンだよ！");break;case int n:Debug.Log($"整数だよ！ {n}");break;case string s:Debug.Log($"文字列だよ : {s}");break;case null:Debug.Log("nullだよ");break;default:Debug.Log("それ意外だよ");break;}}
objはどんな型がくるかわからない

*public static void SwitchExample0(Shape shape)*{switch (shape){case Rect r when r.Width == r.Height:Debug.Log($"正方形だよ！ 面積: {r.Area}");break;case Rect r:Debug.Log($"長方形だよ！ 面積 : {r.Area}");break;case Circle c:Debug.Log($"円だよ！ {c.Area}");break;}}
抽象型のShape。列挙型じゃないよ！


*using (var sharedMemory = MemoryMappedFile.CreateNew(GetMemoryMappedFileName(pid), memorySize))
対象プロセスのPIDを含んだ名前のメモリーマップドファイルを作成。
インジェクトされた側は自身のPIDを使用してこのメモリーマップドファイルを開く。

*accessor.Write(position, assemblyLocation, out position);
アセンブリの位置、実行するメソッドが定義されている型、実行するメソッドの名前、通信用の名前付きパイプの名前を書き込む。

*}
書き終わってからインジェクトする。
..略..

*static async Task Main(string[] args)*{// メモ帳のプロセスIDを取得するvar pid = (uint)Process.GetProcessesByName("notepad").First().Id;var injector = new Injector();// メモ帳に自身のDLLをインジェクトし、DLL内のEntoryPoint関数を実行させるusing (var con = await injector.InjectAsync(pid, c => EntryPoint(c))){var buffer = new byte[1024];while (con.IsConnected){// メモ帳にインジェクトしたマネージドコードからの返答を待つvar count = await con.Pipe.ReadAsync(buffer, 0, buffer.Length, CancellationToken.None);var str = Encoding.UTF8.GetString(buffer, 0, count);Console.WriteLine($"recv:{str}");}}}
インジェクトする側(ホスト)のメインメソッド

*var pid = (uint)Process.GetProcessesByName("notepad").First().Id;
メモ帳のプロセスIDを取得する

*using (var con = await injector.InjectAsync(pid, c => EntryPoint(c)))*{var buffer = new byte[1024];while (con.IsConnected){// メモ帳にインジェクトしたマネージドコードからの返答を待つvar count = await con.Pipe.ReadAsync(buffer, 0, buffer.Length, CancellationToken.None);var str = Encoding.UTF8.GetString(buffer, 0, count);Console.WriteLine($"recv:{str}");}}
メモ帳に自身のDLLをインジェクトし、DLL内のEntoryPoint関数を実行させる

*var count = await con.Pipe.ReadAsync(buffer, 0, buffer.Length, CancellationToken.None);
メモ帳にインジェクトしたマネージドコードからの返答を待つ

*public static async ValueTask EntryPoint(Connection con)*{var text = "Hello from notepad.exe!";var buf = Encoding.UTF8.GetBytes(text);// 引数で渡されたConnectionを使用してホストと通信する。await con.Pipe.WriteAsync(buf, 0, buf.Length);}
インジェクトされた側で実行されるメソッド

*await con.Pipe.WriteAsync(buf, 0, buf.Length);
引数で渡されたConnectionを使用してホストと通信する。


*navAgent.destination = Player.transform.position;
navMeshAgentの操作

*void Start()*{particle = GetComponent<ParticleSystem>();//Exploder = player.GetComponent<Exploder>();}
Exploder Exploder;

*IEnumerator OnControllerColliderHit (ControllerColliderHit other)*{Debug.Log("Hit");if (other.gameObject.CompareTag("Enemy")){yield return new WaitForSeconds(0.3f);SceneManager.LoadScene("GameOver");}if (other.gameObject.CompareTag("DeathZone")){yield return new WaitForSeconds(0.01f);SceneManager.LoadScene("GameOver");}}
Use this for initialization


*void Start()*{controller = new Controller();_model = this.FindCubismModel();modelfingers = new Dictionary<Leap.Finger.FingerType, CubismParameter>();modelfingers.Add(Leap.Finger.FingerType.TYPE_INDEX, _model.Parameters[1]);modelfingers.Add(Leap.Finger.FingerType.TYPE_MIDDLE, _model.Parameters[2]);modelfingers.Add(Leap.Finger.FingerType.TYPE_RING, _model.Parameters[3]);modelfingers.Add(Leap.Finger.FingerType.TYPE_PINKY, _model.Parameters[4]);modelfingers.Add(Leap.Finger.FingerType.TYPE_THUMB, _model.Parameters[5]);}
Start is called before the first frame update


*oldMonth = oldMonth - 1;
旧暦月の補正

*int rokuyo = (oldMonth + oldDay) % 6;
ルールとしては
(月 + 日) % 6　の結果が六曜になり
大安→赤口→先勝→友引→先負→仏滅


*void Start()*{texture = new Texture2D(1, 1, TextureFormat.RGBAFloat, false);renderTexture = new RenderTexture(1, 1, 0, RenderTextureFormat.ARGB32);renderTexture.filterMode = FilterMode.Point;buf = new CommandBuffer();buf.name = "GBuffer Test";foreach (var cam in Camera.allCameras){if (!cam){break;}cam.AddCommandBuffer(CameraEvent.AfterGBuffer, buf);}#if UNITY_EDITORvar sceneViewCameras = SceneView.GetAllSceneCameras();foreach (var cam in sceneViewCameras){if (!cam){break;}cam.AddCommandBuffer(CameraEvent.AfterGBuffer, buf);}#endif}
Start is called before the first frame update

*void Update()*{if (!Input.GetMouseButtonDown(0)) return;RenderTexture.active = renderTexture;texture.ReadPixels(new Rect(0, 0, 1, 1), 0, 0);color = texture.GetPixel(0, 0);Debug.Log($"Color:{color}");}
Update is called once per frame


*var castA = new CastA();
CastA型でインスタンス化する


*this.Opacity = 0;
移動前に表示されてしまうので透過させておく

*static Icon Create16x16Icon()*{Bitmap bmp = new Bitmap(16,16);using ( Graphics g = Graphics.FromImage(bmp) ) { g.Clear(Color.Blue); }return Icon.FromHandle(bmp.GetHicon());}
-------------------------------------------


*string savePath = @"C:\DQ\param.yaml";
シリアライズ

*string savePath = @"C:\DQ\param.yaml";
シリアライズ

*var version = "---\nVersion: 1.0.0\n";
1行目を直接記述

*var root_node = (YamlMappingNode)stream.Documents[0].RootNode;*root_node.Add("Date", $"{ new DateTime(1988, 2, 10) }");
先ほど書いた1行目を根ノードとして取得

*string savePath = @"C:\DQ\param.yaml";
シリアライズ

*var input = new StreamReader(yamlPath, Encoding.UTF8);
テキスト抽出

*var deserializer = new Deserializer();
デシリアライザインスタンス作成

*var deserializeObject = deserializer.Deserialize<YamlData>(input);
yamlデータのオブジェクトを作成


*ParallelOptions parallelOptions = new ParallelOptions();
並列処理オプションの設定

*Parallel.ForEach(list, parallelOptions, (value) =>*{Console.Write(value);});
並列処理実行


*m_Nodes.Remove(node);
順序を保持するためのリストから削除


*}
処理


*pr.BeginOutputReadLine();
非同期で標準出力読み取り


*y = 2;
Bai(1)を2に置き換えた


*}).ConfigureAwait(false);
スレッド復帰しない

*Debug.WriteLine("Callback");
ここは同じワーカースレッド

*var task1 = await Task.Run(() =>*{// ここはワーカースレッド1}).ConfigureAwait(false);
ここは UI スレッド

*}).ConfigureAwait(false);
ここはワーカースレッド1

*var task2 = await Task.Run(() =>*{// ここはワーカースレッド2}).ConfigureAwait(true);
ここはワーカースレッド1

*}).ConfigureAwait(true);
ここはワーカースレッド2

*,,,
***注意***
ここはワーカースレッド2

*var task = await Task.Run(() =>*{// ここはワーカースレッド1}).ContinueWith(() =>
ここは UI スレッド

*}).ContinueWith(() =>*{// ここはワーカースレッド1}).ConfigureAwait(true);
ここはワーカースレッド1

*}).ConfigureAwait(true);
ここはワーカースレッド1


*var texture = ScreenCapture.CaptureScreenshotAsTexture(1);
こんな感じ


*string jsonString = JsonSerializer.Serialize(testString, new JsonSerializerOptions { WriteIndented = true});
シリアライズ

*File.WriteAllText(@"C:\Users\user\test.txt", jsonString);
JSON文字列をテキストファイルに保存


*}
本来はStore処理をすべきだけど省略

*public class sys*{public class Console{public static void WriteLine(string value) =>System.Console.WriteLine($"This is \"sys.Console\" class's WriteLine:{value}");}}
命名則に反してるけど笑って許して

*var b = new Base.Nested();
当たり前だけど違う型なので変数も別々

*point.X = 100;
これは出来る。

*point.Y = 100;
property setterの呼び出しはNG(CS0165発生)

*point.Some();
当然、何も関係なくてもメソッドの呼び出しもNG(CS0165発生)

*NoEnveloped hoge = new NoEnveloped();
こいつはExternalLibなる別のアセンブリにある

*OutOfNameSpace piyo = new OutOfNameSpace();
こいつは上のやつ

*NoEnveloped hoge = new NoEnveloped();
この場合、Advent.NoEnvelopedと解釈される

*OutOfNamespace piyo = new OutOfNamespace();
これも同様に、Advent.OutOfNameSpaceと解釈される

*global::OutOfNamespace foo=new global::OutOfNamespace();
これがグローバル名前空間にあるOutOfNamespace

*global::NoEnveloped bar=new global::NoEnveloped();
こいつは、ExternalLibにあるグローバル名前空間にいたNoEnveloped


*private string signedTxHex;
署名済みTxを入れる

*[Serializable]
Jsonの組み立て

*}
public bool extended_tx_info = true; 何故かエラーになります

*public class UnSignTxData*{public string result;}
未署名Txの格納

*private void GetUnSignTxHex()*{string url = "リクエスト先APIサーバー";MonapaApi monapaApi = new MonapaApi();string monapaJson = JsonUtility.ToJson(monapaApi);StartCoroutine(ReqUnSignTxHex(url , monapaJson));IEnumerator ReqUnSignTxHex(string url, string bodyJsonString){UnityWebRequest postRequest = new UnityWebRequest(url, "POST");byte[] bodyRaw = Encoding.UTF8.GetBytes(bodyJsonString);postRequest.uploadHandler = (UploadHandler)new UploadHandlerRaw(bodyRaw);postRequest.downloadHandler = (DownloadHandler)new DownloadHandlerBuffer();postRequest.SetRequestHeader("Content-Type", "application/json");yield return postRequest.SendWebRequest();UnSignTxData unSignTxData = new UnSignTxData();unSignTxData = JsonUtility.FromJson<UnSignTxData>(postRequest.downloadHandler.text);unSignTxHex = unSignTxData.result;if (postRequest.isHttpError || postRequest.isNetworkError){Debug.Log(postRequest.error);}else{Debug.Log(postRequest.downloadHandler.text);}},,,//上記の続きです。private void SignRawTx(){//MonacoinのMainnetに接続NBitcoin.Network network = NBitcoin.Altcoins.Monacoin.Instance.Mainnet;//秘密鍵の読み込みvar bitcoinPrivateKey = new BitcoinSecret("秘密鍵");network = bitcoinPrivateKey.Network;var transaction = Transaction.Create(network);transaction = Transaction.Parse(unSignTxHex, network);//署名するtransaction.Sign(bitcoinPrivateKey, false);signedTxHex = transaction.ToHex();},,,*private void SignRawTx()*{//MonacoinのMainnetに接続NBitcoin.Network network = NBitcoin.Altcoins.Monacoin.Instance.Mainnet;//秘密鍵の読み込みvar bitcoinPrivateKey = new BitcoinSecret("秘密鍵");network = bitcoinPrivateKey.Network;var transaction = Transaction.Create(network);transaction = Transaction.Parse(unSignTxHex, network);//署名するtransaction.Sign(bitcoinPrivateKey, false);signedTxHex = transaction.ToHex();},,,*NBitcoin.Network network = NBitcoin.Altcoins.Monacoin.Instance.Mainnet;
MonacoinのMainnetに接続

*var bitcoinPrivateKey = new BitcoinSecret("秘密鍵");
秘密鍵の読み込み

*transaction.Sign(bitcoinPrivateKey, false);
署名する


*public class ReservationDateTime : IValueObject*{public ReservationDateTime(DateTime start, DateTime end){if (start.CompareTo(end) >= 0)throw new ArgumentException("終了日時は開始日時よりも後にしてください。");Start = start;End = end;}public DateTime Start { get; }public DateTime End { get; }// 以下省略}
利用時間の ValueObject

*}
以下省略

*public class PurposeOfUse : IValueObject*{public PurposeOfUse(string value){Assertion.ArgumentRange(value, 64, nameof(PurposeOfUse));Value = value;}public string Value { get; }// 以下省略}
利用目的 の ValueObject

*}
以下省略

*}
以下省略


*}
のようにして、Constraintを有効にする


*var url = "hogehoge";
臨時キャンペーンの追加
Azure functionsを利用している
アクセスするURL

*var result = await client.GetStringAsync(url);
JSONを受け取って独自クラスにコンバートする

*}
ここにエラー時処理

*[HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = null)] HttpRequest req,
[Table(“LPInfo”)]などでデータとバインディングしている。
詳しい記法は Azure Functions の公式ドキュメントを読んでください。

*var querySegment = cloudTable.ExecuteQuerySegmentedAsync(new TableQuery<LPINFO>(), null);
Azure Table Strageにアクセスし、データをリストに格納する。

*responseContent = new StringContent(JsonConvert.SerializeObject(ls,Formatting.Indented),Encoding.UTF8,"application/json");
すべての格納が終了した後に、Jsonファイルを生成している。

*return new HttpResponseMessage(HttpStatusCode.OK)*{Content = responseContent};
最後に生成したJsonファイルを返す。

*public class LPINFO : TableEntity
レコードを取得する用のクラス。
これを作ることによってListでの管理が可能になる。

*public override View OnCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)*{var view = inflater.Inflate(Resource.Layout.Suggest, container, false);var button = view.FindViewById<Button>(Resource.Id.updateButton/* ボタンのId */);button.Click += Clicked;return view;}
本物の実装ではFragmentを用いているのでちょっと形式が違うと思います…

*}
ここにクリック時の処理を記述...

*private JavaDictionary<string, string> dic = new JavaDictionary<string, string>();
本当はDictionaryを用いたかったが、JavaList<IDictionary<string, object>>()へのキャストでExceptionを吐いてしまうためJavaDictionaryを用いた,

*var lsView = View.FindViewById<ListView>(Resource.Id.outputView);
アダプター作成とセット


*.Replace("\n", string.Empty);
Windowsだったらこの行は不要かも


*speak.cancelPlay();
音声再生をキャンセルする


*set { _text = value; PropertiesUpdated?.Invoke();}
プロパティの変更を通知する


*serializer.Serialize(writer, app, ns);
空白のnamespaceを使ってシリアライズ


*Tween currentPlayTween;
現在再生中のTween

*void Start()*{PlayMoveTween();}
開始時

*void PlayMoveTween()*{// 移動時間float duration = 2f;// 移動値Vector3 endValue = new Vector3(10, 10, 0);// Tweenの作成currentPlayTween = transform.DOMove(endValue, duration);// 相対に切り替えcurrentPlayTween.SetRelative();// イーズタイプの指定currentPlayTween.SetEase(Ease.Linear);// 再生currentPlayTween.Play();}
Tweenの再生

*float duration = 2f;
移動時間

*Vector3 endValue = new Vector3(10, 10, 0);
移動値

*currentPlayTween = transform.DOMove(endValue, duration);*// 相対に切り替え
Tweenの作成

*currentPlayTween.SetRelative();
相対に切り替え

*currentPlayTween.SetEase(Ease.Linear);
イーズタイプの指定

*currentPlayTween.Play();
再生

*Sequence currentPlaySequence;
現在再生中のSequence

*void Start()*{spriteRenderer = GetComponent<SpriteRenderer>();PlaySequence();}
開始時

*void PlaySequence()*{// 移動時間float moveDuration = 1f;// 移動の最終値Vector3 moveEndValue = new Vector3(10, 10, 0);// 待機時間float waitDuration = 1f;// 透過時間float fadeDuration = 1f;//  透過最終値float fadeEndValue = 0f;// 移動Tweenの作成Tween moveTween = transform.DOMove(moveEndValue, moveDuration).SetRelative().SetEase(Ease.Linear);// 透過Tweenの作成Tween fadeTween = spriteRenderer.DOFade(fadeEndValue, fadeDuration);// Sequenceを生成currentPlaySequence = DOTween.Sequence();// Sequenceの構築currentPlaySequence.Append(moveTween).AppendInterval(waitDuration).AppendCallback(()=>Debug.Log("AppendCallback()")).Append(moveTween).Join(fadeTween);// 再生currentPlaySequence.Play();}
Sequenceの再生

*float moveDuration = 1f;
移動時間

*Vector3 moveEndValue = new Vector3(10, 10, 0);
移動の最終値

*float waitDuration = 1f;
待機時間

*float fadeDuration = 1f;
透過時間

*float fadeEndValue = 0f;
透過最終値

*Tween moveTween = transform.DOMove(moveEndValue, moveDuration).SetRelative().SetEase(Ease.Linear);*// 透過Tweenの作成
移動Tweenの作成

*Tween fadeTween = spriteRenderer.DOFade(fadeEndValue, fadeDuration);
透過Tweenの作成

*currentPlaySequence = DOTween.Sequence();
Sequenceを生成

*currentPlaySequence
Sequenceの構築

*currentPlaySequence.Play();
再生

*float duration = 1f;
時間

*int endValue = 100;
最終値

*int currentValue = 0;
現在の値

*currentPlayTween = DOTween.To(() => currentValue,
Tweenの生成

*currentPlayTween.Play();
再生

*float duration = 1f;
移動時間

*Vector3 endValue = new Vector3(10, 10, 0);
移動の最終値

*currentPlayTween = transform.DOMove(endValue, duration).SetRelative().SetEase(Ease.Linear);*// ループの指定
Tweenの生成

*currentPlayTween.SetLoops(-1, LoopType.Incremental);
ループの指定

*currentPlayTween.OnPlay(() => Debug.Log("OnPlay()"));
コールバック群

*currentPlayTween.Play();
再生

*currentPlayTween.Kill();
Tweenの破棄


*,,,
・・・一部省略

*,,,
・・・一部省略

*var response = await HttpClient.GetAsync(_url);
Arrange・Act


*public static void initGPIOPin(int gpio)*{if (Directory.Exists("/sys/class/gpio/gpio" + gpio) == false){///sys/class/gpio/exportにGPIOピン番号を書き込む.using (var writer = new StreamWriter("/sys/class/gpio/export")){writer.WriteLine(gpio.ToString());}}System.Threading.Thread.Sleep(100);// /sys/class/gpio/gpioX/directionusing (var writer = new StreamWriter("/sys/class/gpio/gpio" + gpio + "/direction")){writer.WriteLine("out");writer.Close();}}
GPIOピンの初期設定を行う.

*using (var writer = new StreamWriter("/sys/class/gpio/gpio" + gpio + "/direction")){writer.WriteLine("out");
/sys/class/gpio/gpioX/direction

*using (var writer = new StreamWriter("/sys/class/gpio/gpio" + gpio + "/value")){writer.WriteLine(level.ToString());
/sys/class/gpio/gpioX/valueの内容が0/1でOFF/ONが求まる.

*initGPIOPin(4);
GPIO4を初期化する.

*switchGPIO(4, 1);*// 1秒待機.
LEDを点灯する.(GPIO4をONにする)

*Thread.Sleep(1000);
1秒待機.

*switchGPIO(4, 0);*// 1秒待機.
LEDを消灯する.(GPIO4をOFFにする)

*Thread.Sleep(1000);
1秒待機.

*wiringPiSetupGpio();
wiringPiのセットアップ

*pinMode(14, OUTPUT);
GPIO 14をOUTPUT(1)に設定する.

*pinMode(15, OUTPUT);
GPIO 15をOUTPUT(1)に設定する.

*pinMode(18, PWM_OUTPUT);
GPIO 18をPWM_OUTPUT(2)に設定する.

*digitalWrite(14, 0);
初期状態としてモーターを停止する.

*digitalWrite(14, 1);
モーターを正転する.

*pwmWrite(18, 256);
回転数を1/4に設定する

*Thread.Sleep(3000);
3秒待機する.

*pwmWrite(18, 512);
回転数を1/2に設定する

*Thread.Sleep(3000);
3秒待機する.

*pwmWrite(18, 1024);
回転数を最大に設定する

*Thread.Sleep(3000);
3秒待機する.

*digitalWrite(14, 1);
モーターをブレーキする.


*[SerializeField] public InfoData[] result;
InfoData[] resultで各値を参照

*[SerializeField] public string address;
下で参照する項目を指定することで値を格納し表示する


*public static readonly DependencyProperty SelectedItemsProperty =DependencyProperty.Register("SelectedItems",typeof(IList),typeof(SelectedItemsBehavior),new FrameworkPropertyMetadata(null, FrameworkPropertyMetadataOptions.BindsTwoWayByDefault));
Using a DependencyProperty as the backing store for SelectedItemsProxy.  This enables animation, styling, binding, etc...


*client.OnRoAccessReportReceived +=new delegateRoAccessReport(_LLRPClientOnRoAccessReportReceived);
レポートイベントの登録

*IParameter pEpc = data.EPCParameter[0];*if(pEpc is PARAM_EPC_96) {epc = (pEpc as PARAM_EPC_96).EPC.ToHexString();} else if(pEpc is PARAM_EPCData) {epc = (pEpc as PARAM_EPCData).EPC.ToHexString();}
EPC

*roSpec.ROSpecID      = 1234;
ROSpec の削除, 有効化, 無効化, 開始, 停止で同じ ROSpec ID を使用します.

*reportSpec.N               = 0;
N個のタグを検出もしくは ROSpec の終了を条件にしてタグレポートを発行させる.
0 にしているため, この場合では ROSpec の終了のみを条件としている.

*tagReportContentSelector.AirProtocolEPCMemorySelector = new UNION_AirProtocolEPCMemorySelector();
EPC 領域の先頭 2[word] CRC + PCBits の取得

*tagReportContentSelector.EnableAntennaID          = true;
タグ受信時のレポートに
アンテナID, 周波数ID, [初-末]検出時刻, 受信感度, ROSpecID, タグ検出回数
を含める

*aiSpec.AntennaIDs = new UInt16Array();
使用するアンテナを指定

*aiSpec.AntennaIDs.Add(1);
0 を指定するとリーダが対応しているアンテナすべてを有効化できます.
aiSpec.AntennaIDs.Add(0);

*rfReceiver.ReceiverSensitivity = 1;
受信感度 -80.00[dBm]

*rfTransmitter.TransmitPower = 81;
出力電力 30.00[dBm]


*System.Diagnostics.Process[] ps = System.Diagnostics.Process.GetProcessesByName(ProcessName);
そのプロセス名のプロセスを全部取得し


*BoxCollider2D collider2d;
BoxCollider2D コンポーネント

*Collider2D[] results = new Collider2D[5];
衝突結果を格納 (最大5個まで)

*void Start ( )*{// Colliderをキャッシュcollider2d = GetComponent<BoxCollider2D> ();}
開始処理

*collider2d = GetComponent<BoxCollider2D> ();
Colliderをキャッシュ

*void Update ( )*{if ( IsHitToEnemy ()  ) {Debug.Log ("衝突しています");}}
更新処理

*bool IsHitToEnemy ( )*{// collider2dと衝突しているcolliderの数が返ってくるint hitCount = collider2d.OverlapCollider(new ContactFilter2D(), results);if ( hitCount > 0 ){for ( int i = 0; i < hitCount; i++ ){// 衝突したオブジェクトのTagがEnemyならreturnif ( results [ i ].tag == "Enemy"){return true;}}}return false;}
敵との衝突判定

*int hitCount = collider2d.OverlapCollider(new ContactFilter2D(), results);
collider2dと衝突しているcolliderの数が返ってくる


*private const float ClickTimeSpanThreshould = 0.05f;
クリックされてから次のクリックを受け付けるまでの秒数

*private bool _clickable = true;
ボタンのクリックを受け付けるかどうか

*private float _timer = 0f;
カウンタ

*var gesture = GetComponent<UIGesture>();
注意：　UIGestureは、EventSystemの各種イベントハンドラを実装したクラス

*onClickCallback?.Invoke();
クリックされた時の処理を実行

*private bool _clickable = true;
ボタンのクリックを受け付けるかどうか

*var gesture = GetComponent<UIGesture>();
注意：　UIGestureは、EventSystemの各種イベントハンドラを実装したクラス

*await onClickAsync?.Invoke();
クリックされた時の処理を実行

*var gesture = GetComponent<UIGesture>();
注意：　UIGestureは、EventSystemの各種イベントハンドラを実装したクラス

*onBeforeClick?.Invoke();*// クリックされた時の処理を実行
ここで入力ブロッキングOn

*await onClickAsync?.Invoke();
クリックされた時の処理を実行

*onAfterClick?.Invoke();
ここで入力ブロッキングOff


*ResponseJson response = new ResponseJson();
レスポンス生成


*void Update()*{Shader.SetGlobalFloat("GlobalVal",Mathf.Sin(Time.time));}
Update is called once per frame


*Debug.Log(history.Where(x => x % 2 == 0).Count());
linqも使える


*e is COMException ) {
Note: C#6以降なら when を使ってもう少しきれいに書ける

*return;
もみ消す


*try
「アクティブでないアプリケーションアドイン」のチェック


*key.SetValue("LoadBehavior", 3, RegistryValueKind.DWord);
アクティブになっていないので「3」を設定する

*Console.Error.WriteLine("レジストリ[LoadBehavior]チェック:Exception\n" + e.ToString());
エラーは無視

*try
「無効なアプリケーションアドイン」のチェック


*Console.Error.WriteLine("レジストリ[DisabledItems]チェック:Exception\n" + e.ToString());
エラーは無視

*Console.Error.WriteLine("レジストリ[CrashingAddinList]チェック:Exception\n" + e.ToString());
エラーは無視


*app = new WindowsAppFriend(Process);
魔法の時間、これで相手のプロセスに潜り込んでやりたい放題

*AppVar mainWindow = app.Type<Application>().Current.MainWindow;
UIインスタンスをつかんでみる
おなじみのApplication.Current.MainWindowですね、
MainWindowここにきてるように見えますが、実はきてません（相手プロセスにいます）

*var onlyOne = mainWindow.LogicalTree().ByType<TextBox>().Single();
明らかに一個しかない場合はこれで特定できるが、上のXamlではエラーになります。

*var textbox1 = mainWindow.LogicalTree().ByType<TextBox>().ByBinding("Text1").Single();
普通はもう一段ByBinding書いて対象を絞る。
ByType,ByBidingはDependencyObjectのコレクションを返すのでメソッドチェンできる

*var unkwownType = mainWindow.LogicalTree().ByType("ThirdPartyTextBox").Single();
型参照できない場合は文字列のインターフェスを使う

*var command1Button = mainWindow.LogicalTree().ByType<Button>()[0];
ちなみにあんまりおすすめできないがインデックスアクセスできます

*var textbox2 = mainWindow.Dynamic()._text2;
x:Nameでの捕まえ方、実はリフレクションを使ったフィールドアクセス（と思います）

*var dataContext = mainWindow.Dynamic().DataContext;
リフレクションなのでVisablity関係ないですから、DataContextもとれる
MVVMを採用しれいれば、通常DataContextが内部API詰まってるので、ユニットテストに活用する手もありです
ちなみに、これは結合した状態の生きたインスタンスなので、普段ユニットテストで足場を作る作業は不要ですよ。

*var staticMember = app.Type<MainWindowVM>().StaticMember
staticメンバーへのアクセス
インスタンス前提で話してきたが、staticメンバーの場合はこれでアクセスできます。（結構はまりました）

*WPFTextBox wpfTextBox = new WPFTextBox(textbox1);
UIのふるまいをシミュレートする

*var async = new Async();
Asyncでクリックする、スレッドは止まらない

*var dlg = mainWindow.WaitForNextModal();
モーダルダイアログが表示されるのを確実に待ち合わせる

*var buttonOK = new WPFButtonBase(dlg.Dynamic()._buttonOK);
ダイアログ上のボタンを押す、dlgからしか取れません。

*async.WaitForCompletion();
非同期で実行したモーダルボタン押下の処理が完全に終了するのを待つ


*string path2;
out file name

*if (r1 > 160 && r1 > ((g1+b1)/2*1.2))
ここで抽出する色の条件を決める
一例。赤要素が１６０以上でかつ、
青緑の平均より、2割上回る部分（これがないと単に白色が抽出される）
if (r1 > 160 )

*}
単に白色に置き換えると返って浮く場合は色を調整


*private static SingletonClass _instance = new SingletonClass();
自身のクラスのインスタンスを初期化（アプリ実行時にインスタンスはこの1つしか存在しない）

*private static readonly log4net.ILog _logger = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);
ロガーインスタンス取得コード

*public static SingletonClass Instance => _instance;
自身のインスタンスを外部から使うための手段を用意してあげる
プロパティを使った方法

*public static SingletonClass GetInstance() => _instance;
メソッドを使った方法

*private SingletonClass()*{_logger.Debug("SingletonClassのインスタンスが生成されました");}
外部から直接呼べないコンストラクタ

*private SingletonClass _singletonInstance;
シングルトンインスタンスを保持するフィールド

*_singletonInstance = SingletonClass.GetInstance();
シングルトンインスタンスを取得

*private static readonly log4net.ILog _logger = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);
ロガーインスタンス取得コード

*private static SingletonClass _instance = new SingletonClass();
自身のクラスのインスタンスを初期化


*int step = 2;
(BUFFER_SIZE+WIDTH-1)WIDTH;


*int Inc(int x) => x+1;
+1して返すだけの関数

*var b = new B();
というのがあったとすると

*IA a = new B();
とつかうとGetOne()内で直接B.One()というメソッドが呼ばれます


*_numbers.Enqueue(number);
キューに番号を順に登録

*if (_numbers.Count < 1) throw new Exception("Remaining numbers are already Empty.");*return _numbers.Dequeue();
例外処理：引くくじが残っていない


*PlayFabSettings.staticSettings.TitleId = "ここに Title Id を入れます";
下 2 行を追加


*,,,
#error version -> コンパイラ バージョン: '3.7.0-6.20371.12 (917b9dfa)'。言語バージョン: default。
いや、default ってなんや。


*string deploymentUrl = "<https:
***.***.jphoge.vsto";>


*v.AddRange(vpp);
v配列に appデータを増やす

*v.ForEach(a =>{Console.Write(" {0}",a);
ラムダで書いたバージョン

*//    Console.Write(" {0}",a);
v.ForEach(a =>{


*Marshal.FreeCoTaskMem(pStructure);
確保したアンマネージドメモリの解放


*| NativeMethods.AnimateWindowFlags.AW_BLEND
AW_SLIDE


*int Port = 8080;
ポート番号を指定

*IPEndPoint EP = new IPEndPoint(IPAdd, Port);
UdpClientを作成し、指定したポート番号にバインドする

*udp.BeginReceive(UdpServer, udp);
非同期的な受信を開始する

*private void UdpServer(IAsyncResult ar)*{UdpClient udp = (UdpClient)ar.AsyncState;for (;;){//一度非同期受信を終了するIPEndPoint remoteEP = null;byte[] rcvBytes = udp.Receive(ref remoteEP);//受信したデータを文字列に変換string rcvMsg = System.Text.Encoding.UTF8.GetString(rcvBytes);//"exit"を受信したら終了if (rcvMsg == "exit"){break;}D = rcvMsg.Split(' ');for(i=0;D[i]== null; i++){d[i] = int.Parse(D[i]);}//受信したデータをTextBoxに表示するstring displayMsg = string.Format("{0}", rcvMsg);richTextBox1.BeginInvoke(new Action<string>(ShowReceivedString1), displayMsg);X_Data.BeginInvoke(new Action<string>(ShowReceivedString_x), D[0]);Y_Data.BeginInvoke(new Action<string>(ShowReceivedString_y), D[1]);Z_Data.BeginInvoke(new Action<string>(ShowReceivedString_z), D[2]);}rcvMsg = "終了しました";//UdpClientを閉じるudp.Close();richTextBox1.BeginInvoke(new Action<string>(ShowReceivedString1), rcvMsg);}
データを受信した時の処理

*IPEndPoint remoteEP = null;
一度非同期受信を終了する

*string rcvMsg = System.Text.Encoding.UTF8.GetString(rcvBytes);
受信したデータを文字列に変換

*string displayMsg = string.Format("{0}", rcvMsg);
受信したデータをTextBoxに表示する

*udp.Close();
UdpClientを閉じる


*menu.AddItem(new GUIContent("Reload"), false, () =>*{ReloadUxml();});
メニューアイテムを登録。

*rootVisualElement.Clear();
一度ルートに紐付けられた要素を全て削除する。

*var visualTree = AssetDatabase.LoadAssetAtPath<VisualTreeAsset>("...");
UXMLの読み込み。

*}
その他、レイアウトに関する各種処理。


*if(yY <= coord.y && coord.y <= Yy)
y ≦ cy ≦ay

*public enum ArrowVector
方角を示すEnum

*private static TileBlock GetBestTile(TileBlock origin, int cost)
4方向から進むに最適なタイルを算出

*if (up      != null && up.      GetTileType() != TileType.Walkable && up.GetTileType()      != TileType.GoalTile) up      = null;*if (bottom  != null && bottom.  GetTileType() != TileType.Walkable && bottom.GetTileType()  != TileType.GoalTile) bottom  = null;
ふるいにかける

*if (up      != null && up.      GetAnalyzed())  up     = null;*if (bottom  != null && bottom.  GetAnalyzed())  bottom = null;
どれかが前のoriginだったらやめる

*if (up      != null && up.      GetTileType() == TileType.GoalTile) DrawLineCenterTileToTile(origin.GetCoordinate(), up.    GetCoordinate());*if (bottom  != null && bottom.  GetTileType() == TileType.GoalTile) DrawLineCenterTileToTile(origin.GetCoordinate(), bottom.GetCoordinate());
どれかがゴールだったらそこまで線を描画

*if (up      != null)    up_hcost        = CalculateHeuristic(up.    GetCoordinate(), goalCoord);*if (bottom  != null)    bottom_hcost    = CalculateHeuristic(bottom.GetCoordinate(), goalCoord);
推定コストを計算

*if (up      != null)    up.     SetAnalyzeData(     cost,   up_hcost       );*if (bottom  != null)    bottom. SetAnalyzeData(     cost,   bottom_hcost   );
データをセット

*public static async void AnalyzeMap()
マップを探索

*SetTileAttributesToAll();
各タイル座標に属性を付与


*public Image img;*private void Form1_Paint(object sencdr, PaintEventArgs e) {Graphics g = e.Graphics;// Properties内のResourcesからtestという画像を探すimg = Properties.Resources.test;// 変数名, 設置する座標X, 設置する座標Y, 画像の幅Width, 画像の高さHeight);g.DrawImage(img, 10, 10, 48, 48);}
変数定義

*img = Properties.Resources.test;
Properties内のResourcesからtestという画像を探す

*g.DrawImage(img, 10, 10, 48, 48);
変数名, 設置する座標X, 設置する座標Y, 画像の幅Width, 画像の高さHeight);


*_ => first,
EQ

*T Fix<T>(Func<T, T> f)
× 自然な定義だけどこれは無限再帰して動かない

*Func<T> Fix<T>(Func<Func<T>, Func<T>> f)
○ 値を関数で包んで評価タイミングを調整可能にしたもの

*Func<T, TResult> Fix<T, TResult>(Func<Func<T, TResult>, Func<T, TResult>> f)
◎ さらにパラメータを任意の T に一般化した形


*var savedToken = await _localStorage.GetItemAsync<string>("authToken");
ローカルストレージからトークンとユーザ名を取得

*if (string.IsNullOrWhiteSpace(savedToken))
トークンのチェックを入れる場合ここで一度だけ実施
トークンが見つからい場合は未ログイン

*_httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("bearer", savedToken);
HTTPの認証用のトークンを設定

*return new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity(new[] { new Claim(ClaimTypes.Name, userID) }, "apiauth")));
認証情報を返す

*await _localStorage.SetItemAsync("userID", userID);
ローカルストレージに認証情報を保持して変更通知を行う

*await _localStorage.RemoveItemAsync("userID");
ローカルストレージの認証情報を削除して変更通知を行う

*await Task.Delay(3000);
3秒待機させて本当の応答のように見せる

*var res = new LoginResult(){IsSuccessful = true,IDToken = firebaseResult.FirebaseToken};
トークンを取得

*public async override Task<AuthenticationState> GetAuthenticationStateAsync()*{// 保存したロールを取得var roles = await _localStorage.GetItemAsync<List<string>>("roles");var claims = new List<Claim>();claims.Add(new Claim(ClaimTypes.Name, userID));foreach(var role in roles){claims.Add(new Claim(ClaimTypes.Role,role));}return new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity(claims, "User")));}
略

*var roles = await _localStorage.GetItemAsync<List<string>>("roles");
保存したロールを取得


*Action<ApplicationTitleDescriptor> cb = x => x.title = "なにかしらのエモいタイトル";
こんな感じで実装すれば実現できそう

*Type tEditorApplication = typeof(EditorApplication);
ApplicationTitleDescriptorのTypeを取得.

*EventInfo eiUpdateMainWindowTitle = tEditorApplication.GetEvent("updateMainWindowTitle", BindingFlags.Static | BindingFlags.NonPublic);
関係するイベントとメソッドのInfoを取得.

*Type delegateType = typeof(Action<>).MakeGenericType(tApplicationTitleDescriptor);
Action<object>をAction<ApplicationTitleDescriptor>に変換.

*eiUpdateMainWindowTitle.GetAddMethod(true).Invoke(null, new object[] { del });
UpdateMainWindowTitleを呼び出す前後にイベントの追加/削除.

*typeof(EditorApplication).Assembly.GetTypes()
UnityEditor.ApplicationTitleDescriptor.title = "Solution1_Reflection"; と同様

*[assembly: InternalsVisibleTo("Unity.InternalAPIEditorBridgeDev.001")]
(以下、たくさんのInternalsVisibleToが羅列されている)

*using Microsoft.CodeAnalysis;
あらかじめMicrosoft.CodeAnalysis.CSharpをnugetでインストールしておく

*string[] csproj = File.ReadAllLines(inputCsProjPath);
C#プロジェクトを読み込みます.

*CSharpCompilationOptions compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithMetadataImportOptions(MetadataImportOptions.All);
dllとしてコンパイルさせるオプションを生成します.

*typeof(CSharpCompilationOptions)
BindingFlags.IgnoreAccessibility(1 << 22)を有効化します.

*Regex reg_dll = new Regex("<HintPath>(.*)</HintPath>", RegexOptions.Compiled);
プロジェクトからアセンブリ参照一覧を取得→IEnumerable<PortableExecutableReference>に変換します.

*Regex reg_preprocessorSymbols = new Regex("<DefineConstants>(.*)</DefineConstants>", RegexOptions.Compiled);
プロジェクトからシンボル一覧を取得→IEnumerable<string>に変換します.

*CSharpParseOptions parserOption = new CSharpParseOptions(LanguageVersion.Latest,preprocessorSymbols: preprocessorSymbols);
プロジェクトからソースコード一覧を取得→テキストとして読み込み→IEnumerable<SyntaxTree>に変換します.

*CSharpCompilation.Create(outputAsemblyName, syntaxTrees, metadataReferences, compilationOptions)
コンパイルを実行し、dllを生成します.


*if (vignette)
該当するパラメータがPostProcessVolumeに存在する場合のみ処理をする


*string path2;
out file name

*int quality = 0;
Jpenの保存品質。小さいほど悪い


*c.IncludeXmlComments(GetXmlCommentsPath());
XMLファイルを読込む

*type = "file",description = "UploadFile"},};
type=file設定は必須

*var root = HttpContext.Current.Server.MapPath("~/App_Data");
multipart/form-dataを保存する場所を指定する

*await Request.Content.ReadAsMultipartAsync(provider);
データを読み取る

*var fileInfo = new FileInfo(file.LocalFileName);
ファイルに格納する


*static void SceneUnLoadedListener(Scene scene)
シーンが破棄された故タイミングのリスナ.

*Instance.managerDic?.Clear();
ランタイムマネージャはこのタイミングで破棄.

*static void ActiveSceneChangeListener(Scene before,Scene after)
シーン変更検知,Unityの仕様上beforeには何も入っていない,afterにロードされたシーンがある.


*@"^s?https?:
[-_.!~*'()a-zA-Z0-9;?:@&=+$,%#]+$"


*public override void OnConnectedToMaster()*{// "OnoTest"という名前のルームに参加する（ルームが無ければ作成してから参加する）PhotonNetwork.JoinOrCreateRoom("OnoTest", new RoomOptions(), TypedLobby.Default);print("ルーム作成完了");}
マスターサーバーへの接続が成功した時に呼ばれるコールバック

*PhotonNetwork.JoinOrCreateRoom("OnoTest", new RoomOptions(), TypedLobby.Default);
"OnoTest"という名前のルームに参加する（ルームが無ければ作成してから参加する）

*public override void OnJoinedRoom()*{PhotonNetwork.Instantiate(生成したいPrefabの名前, 生成したい場所, 生成したい向き(角度));}
部屋に入ったらアバター生成

*PhotonNetwork.ConnectUsingSettings();
PhotonServerSettingsに設定した内容を使ってマスターサーバーへ接続する

*public override void OnConnectedToMaster()*{// "OnoTest"という名前のルームに参加する（ルームが無ければ作成してから参加する）PhotonNetwork.JoinOrCreateRoom("OnoTest", new RoomOptions(), TypedLobby.Default);print("ルーム作成完了");}
マスターサーバーへの接続が成功した時に呼ばれるコールバック

*PhotonNetwork.JoinOrCreateRoom("OnoTest", new RoomOptions(), TypedLobby.Default);
"OnoTest"という名前のルームに参加する（ルームが無ければ作成してから参加する）

*public override void OnJoinedRoom()*{int othersCount = PhotonNetwork.PlayerListOthers.Length;PhotonNetwork.Instantiate(networkPlayer.name, playerPositions[othersCount].position, Quaternion.identity);cameraRig.position = playerPositions[othersCount].position;}
部屋に入ったらアバター生成

*avater_Face.transform.parent = cameraTransform;*avater_RightHand.transform.parent = rightHandTransform;
親子関係を設定し、ローカルの座標系の原点に移動


*var guid = new Guid("01234567-89ab-cdef-0123-456789abcdef");*void TestCase(int testNumber, string format, string expected) {// Actvar actual = guid.ToString(format);// AssertAssert.AreEqual(expected, actual, $"No.{testNumber}");}
Arrange

*var actual = guid.ToString(format);*// Assert
Act

*Assert.AreEqual(expected, actual, $"No.{testNumber}");
Assert

*TestCase(1, "D", expected: "01234567-89ab-cdef-0123-456789abcdef");*TestCase(2, "B", expected: "{01234567-89ab-cdef-0123-456789abcdef}");
Test cases

*Assert.AreEqual(expectedExceptionType, exceptionType, $"No.{testNumber}");
Assert

*var guid = new Guid("01234567-89ab-cdef-0123-456789abcdef");*void TestCase(int testNumber, string format, string expected = default, Type expectedExceptionType = default) {TestAA.Act(() => guid.ToString(format)).Assert(expected, expectedExceptionType, message: $"No.{testNumber}");}
Arrange

*TestCase(1, "D", expected: "01234567-89ab-cdef-0123-456789abcdef");*TestCase(2, "B", expected: "{01234567-89ab-cdef-0123-456789abcdef}");
Test cases


*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer

*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer

*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer


*public int ID { get; set; }
ID

*public bool DoneFlg { get; set; }
完了チェック

*[DisplayName("やること")]
やること

*[DisplayName("期日")]
期日

*[DisplayName("備考")]
備考

*public ActionResult Index()*{return View(db.MVCList.ToList());}
一覧画面の表示

*[HttpPost]
一覧画面のチェックボックスの状態を登録

*public ActionResult Create()*{return View();}
新規登録画面の表示

*[HttpPost]
新規登録

*public ActionResult Edit(int? id)*{if (id == null){return new HttpStatusCodeResult(HttpStatusCode.BadRequest);}MVCList mVCList = db.MVCList.Find(id);if (mVCList == null){return HttpNotFound();}return View(mVCList);}
編集画面の表示

*[HttpPost]
リストの内容の編集

*public ActionResult Delete(int? id)*{if (id == null){return new HttpStatusCodeResult(HttpStatusCode.BadRequest);}MVCList mVCList = db.MVCList.Find(id);if (mVCList == null){return HttpNotFound();}return View(mVCList);}
削除画面の表示

*[HttpPost, ActionName("Delete")]
削除処理


*IDevice logDevice = Devices.CreateLogDevice("[格納するファイルのパス]");
独自ストレージを使用する場合、FASTER.core.IDeviceを実装したインスタンスを代わりに生成する
ファイルパスのみ必須。
基本的に同じフォルダに複数ファイルを作る設計なので、複数のログファイルを扱いたい場合、別フォルダに分けるのが良い

*var fls = new FasterLogSettings(){LogDevice = logDevice};
LogDeviceのみ必須

*}
処理
flインスタンスはプロセス内で使い回すこと

*long recordAddress = fl.Enqueue(data);
ReadOnlySpan<byte>でも可
Enqueueの時点ではまだ永続化はされない

*fl.Commit(true);
ここで返ってくるaddress値は、WaitForCommit系のAPIでuntilAddressとして使用する
コミットデータの永続化

*using(FastLogScanIterator iter = fl.Scan(fl.CommittedBeginAddress, fl.CommittedUntilAddress)){enumeratorで走査},,,FasterLog fl;
fl.Scan([論理開始アドレス], [論理終端アドレス])という風にして指定する

*}
enumeratorで走査

*using(FastLogScanIterator iter = fl.Scan(fl.CommittedBeginAddress, fl.CommittedUntilAddress)){dataの型はbyte[]lenはデータ長(bytes)2019.11.18では二つだけだが、最新ソースでは更に long currentAddress も追加になる模様https:github.com/microsoft/FASTER/commit/bf657635374873958d96b31db1299b58ef9a17b1await foreach(var (data, len, currentAddress, nextAddress) in iter.GetAsyncEnumerable()){データの参照}},,,FasterLog fl;
fl.Scan([論理開始アドレス], [論理終端アドレス])という風にして指定する

*await foreach(var (data, len, currentAddress, nextAddress) in iter.GetAsyncEnumerable())
dataの型はbyte[]
lenはデータ長(bytes)
2019.11.18では二つだけだが、最新ソースでは更に long currentAddress も追加になる模様
https:github.com/microsoft/FASTER/commit/bf657635374873958d96b31db1299b58ef9a17b1

*}
データの参照

*using(FastLogScanIterator iter = fl.Scan(fl.CommittedBeginAddress, fl.CommittedUntilAddress)){終端ではnextAddressが-1になるwhile(iter.NextAddress >= 0)
FasterLog fl;

*while(iter.GetNext(out var entry, out var length, out var currentAddress, out var nextAddress))
データを取り出すまでループと待機を行う
引数は、データ本体、データ長、現在のアドレスの三つ

*}
データの参照

*untilAddress = iter.NextAddress;
処理

*fl.Commit(true);
最後にCommitすると変更が反映される

*long logicalAddress = 0;
データを追加するタスク

*int commitCount = 0;
コミットする方のタスク


*MethodInfo methodInfo = typeof(Test).GetMethod(nameof(TargetMethod));
呼び出すメソッド情報を取得

*ParameterExpression valueArg = Expression.Parameter(typeof(int).MakeByRefType());
out引数を定義(MakeByRefTypeを使う)

*TestDelegate compiled = Expression.Lambda<TestDelegate>(Expression.Call(Expression.Constant(this),
ExpressionTreeでdelegateを作成

*compiled.Invoke(out int intValue);*Console.WriteLine($"intValue={intValue}");
呼び出して結果を出力


*.IsDependentOn("Task1")
Task1の依存が重複した

*class MyClass*{public string X;}
型の宣言

*Task("Task1")
"IsRelease"が引数に来た場合に実行されるようにする


*public override bool IsBroadcast => false;
全体に返すか、聞いてきた人だけに返すかの設定

*public override (string, string) DefaultCommandAndHelpMessage => ("date", "日にちと曜日を表示");
HelpCommandで使用される、このコマンドの説明

*RegisterKeyword(CommandPriority.Low, "何日");
どういう日本語に、どれぐらいの優先度で引っ掛けたいか。
ほかのコマンドで同じ単語で引っかかった場合、優先度順に選ばれる。

*public override ValueTask<string> CreateOutputAsync(string user, string channel, string filteredKeyword, string rawWords)
実際に頑張って結果を返す部分。
DefaultCommandまたはRegisterKeywordで選ばれたときしか呼ばれない。


*float distance = Mathf.Abs(Vector2.Distance(mousePos, prevMousePos));
マウスの移動した距離


*private EnumSample() {}
外部からのインスタンス生成不可

*private EnumSample2( int num ) {Num = num;// 重複チェックを入れるとしたらこの辺でやる// Dictionaryに詰めていってContainsKeyでチェックするのが楽そう}
外部からのインスタンス生成不可

*}
重複チェックを入れるとしたらこの辺でやる
Dictionaryに詰めていってContainsKeyでチェックするのが楽そう

*public interface IDropItem {string Name { get; }int Price { get; }string Description { get; }}
ドロップアイテムのインタフェース

*public abstract class Weapon : IDropItem {public static Weapon Sword = new WeaponSword();private class WeaponSword : Weapon {// コンストラクタがpublicでもクラス自体はprivateなので外部からはインスタンス生成不可public WeaponSword() {}public override string Name { get { return "剣"; } }public override int Price { get { return 100; } }public override string Description { get { return "いい感じの説明"; } }public override void Attack() {base.Slash();}}public static Weapon Spear = new WeaponSpear();private class WeaponSpear : Weapon {public WeaponSpear() {}public override string Name { get { return "槍"; } }public override int Price { get { return 50; } }public override string Description { get { return "そんな感じの説明"; } }public override void Attack() {base.Pierce();}}public static Weapon Club = new WeaponClub();private class WeaponClub : Weapon {public WeaponClub() {}public override string Name { get { return "棍棒"; } }public override int Price { get { return 10; } }public override string Description { get { return "とてもアレな説明"; } }// Attack()の実装は省略可能}protected Weapon() {}// 名前、価格、説明は必ず列挙子で定義するpublic abstract string Name { get; }public abstract int Price { get; }public abstract string Description { get; }// 攻撃処理の実装は省略可能public virtual void Attack() {// オーバーライドしない場合はデフォルトとして殴る処理Strike();}// protectedで宣言したプロパティやメソッドは列挙子側からアクセスできるprotected void Slash() {// 切る武器の処理}protected void Pierce() {// 刺す武器の処理}protected void Strike() {// 殴る武器の処理}}
ドロップアイテムとして扱える武器の列挙型

*public WeaponSword() {}
コンストラクタがpublicでもクラス自体はprivateなので外部からはインスタンス生成不可

*}*protected Weapon() {}
Attack()の実装は省略可能

*public abstract string Name { get; }
名前、価格、説明は必ず列挙子で定義する

*public virtual void Attack() {// オーバーライドしない場合はデフォルトとして殴る処理Strike();}
攻撃処理の実装は省略可能

*Strike();
オーバーライドしない場合はデフォルトとして殴る処理

*protected void Slash() {// 切る武器の処理}
protectedで宣言したプロパティやメソッドは列挙子側からアクセスできる

*}*protected void Pierce() {// 刺す武器の処理}
切る武器の処理

*}*protected void Strike() {// 殴る武器の処理}
刺す武器の処理

*}
殴る武器の処理


*if (!dictionary.TryGetValue(key, out var result)) return false;*// 型が一致しない場合はNG
キーがないならNG

*return IsTypeMatch(result.GetType(), value.GetType());
型が一致しない場合はNG

*var tables = worksheet.RangeUsed().AsTable();
項目名称の取得

*var generator = new DataRecordGenerator(columnNames, values);
生成開始

*result[0].Age = (double)50;
数値に関してはClosedXMLの読み取るとdoubleで取得される


*Action close = () => writer.Dispose();
閉じる。


*System.Threading.Thread.CurrentThread.CurrentUICulture = new System.Globalization.CultureInfo("en-GB");
CurrentUICulture の変更。


*if (!CheckRangeValid(Row + j * RowDirection, Col + j * ColDirection) ||*!CheckReverse(Row, Col, Info, i, j)) continue;
ひとつでも変更があればturnChangeFlgをtrueにする。

*if (!CheckRangeValid(Row + j * RowDirection, Col + j * ColDirection) ||*!CheckReverse(Row, Col, Info, i, j)) continue;
ひとつでも変更があればturnChangeFlgをtrueにする。


*public int K { get; private set; }
セキュリティパラメータ（バイト数）

*public BigInteger p;
デバッグ以外ならprivateに設定

*public (BigInteger p, BigInteger g, BigInteger y) Pk*{get => (this.p, this.g, this.y);set{this.p = value.p;this.g = value.g;this.y = value.y;}}
公開鍵

*public BigInteger Sk
秘密鍵
デバッグ以外ならprivateに設定

*public void GenerateKeys(int k)*{p = GenerateRandomPrime(k);Console.WriteLine("ランダムな素数p = {0}", p);g = GenerateGroupGen(k, p);Console.WriteLine("原始元g = {0}", g);x = GenerateRandom(k, 0, p - 2);Console.WriteLine("ランダムな非負整数x = {0}", x);y = BigInteger.ModPow(g, x, p);Console.WriteLine("y = g^x mod p = {0}", y);}
鍵を生成する

*public static int GenerateGroupGen(int k, BigInteger p)*{for (int g = 2; ; g++){bool isGen = true;BigInteger a = 1;for (int i = 1; i <= p - 2; i++){a *= g;if (a >= p) a %= p;if (a == 1){isGen = false;break;}}if (isGen){return g;}}}
原始元を生成する

*public (BigInteger c1, BigInteger c2) Encrypt(BigInteger m)*{var r = GenerateRandom(K, 0, p - 2);Console.WriteLine("ランダムな数r = {0}", r);var c1 = BigInteger.ModPow(g, r, p);var c2 = (m * BigInteger.ModPow(y, r, p)) % p;return (c1, c2);}
暗号化する

*public BigInteger Decrypt((BigInteger c1, BigInteger c2) c)*{return (c.c2 * BigInteger.ModPow(c.c1, p - 1 - x, p)) % p;}
復号する


*static readonly Uri BaseURL = new Uri("https:
api.openweathermap.org");


*else
多分ここから先はきちんと動くか分からないので、先に必ずSetUp関数を終了させておく方がよい

*}
return LoadSprite(assetName);再帰的な処理をしたいがどうなるか分からないので呼び出し下でやりたい


*namespace asp_smp.Controllers*{[Route("")]public class TopController : Controller{private FruitSqlService service = new FruitSqlService();[Route("")]public IActionResult Index(){ViewBag.list = service.All();return View();}[Route("/add")]public IActionResult Add(){return View();}[HttpPost][Route("/add")]public IActionResult AddPost(int Id, string Name, int Number, int Price){var fruit = new Fruit();fruit.Id = Id;fruit.Name = Name;fruit.Number = Number;fruit.Price = Price;service.INSERT(fruit);TempData.Add("result", "追加に成功しました。");return Redirect("/");}[HttpPost][Route("/delete")]public IActionResult DeletePost(int Id){service.DELETE(Id);TempData.Add("result", "削除に成功しました。");return Redirect("/");}[Route("/show/{id}")]public IActionResult Show(int Id){var fruit = service.FindById(Id);return View(fruit);}[HttpPost][Route("/update")]public IActionResult Update(int Id, string Name, int Number, int Price){var fruit = new Fruit();fruit.Id = Id;fruit.Name = Name;fruit.Number = Number;fruit.Price = Price;service.UPDATE(fruit);TempData.Add("result", "更新に成功しました。");return Redirect("/");}}}
For more information on enabling MVC for empty projects, visit https:go.microsoft.com/fwlink/?LinkID=397860


*cellStyle.BorderTop = NPOI.SS.UserModel.BorderStyle.Thin;
セルの上に引く

*cellStyle.BorderBottom = NPOI.SS.UserModel.BorderStyle.Thin;
セルの下に引く

*cellStyle.BorderLeft = NPOI.SS.UserModel.BorderStyle.Thin;
セルの左に引く

*cellStyle.BorderRight = NPOI.SS.UserModel.BorderStyle.Thin;
セルの右に引く

*cellStyle.BorderDiagonal = NPOI.SS.UserModel.BorderDiagonal.Forward;
セルの斜めに引く

*cell.CellStyle = cellStyle;
セルのスタイルを保存

*using (var fs = new FileStream(filepath, FileMode.Create)){book.Write(fs);
ブックを保存


*public IEnumerable<CSV_Format> GetRecords()*{try{using (var reader = new StreamReader(File, Encoding.GetEncoding(EncodingName)))using (var csv = new CsvReader(reader)){csv.Configuration.HasHeaderRecord = HasHeaderRecord;csv.Configuration.RegisterClassMap<CSV_Format_Mapper>();return csv.GetRecords<CSV_Format>();}}catch (Exception ex){//..例外処理..}}
File,Encoding,HasHeaderRecordはどっかで設定

*}
..例外処理..

*public IEnumerable<T> GetRecords()*{try{using (var reader = new StreamReader(File, Encoding.GetEncoding(EncodingName)))using (var csv = new CsvReader(reader)){csv.Configuration.HasHeaderRecord = HasHeaderRecord;//csv.Configuration.RegisterClassMap<CSV_Format_Mapper>(); //いらなくなったreturn csv.GetRecords<T>();}}catch (Exception ex){//..例外処理..}}
File,Encoding,HasHeaderRecordはどっかで設定

*return csv.GetRecords<T>();
csv.Configuration.RegisterClassMap<CSV_Format_Mapper>(); いらなくなった

*}
..例外処理..


*IMessage message = new SampleMessage();
データの用意は省略

*OneofDescriptor oneofField = message.Descriptor.FindDescriptor<OneofDescriptor>("oneof_field");
名前を指定してDescriptorを取得する

*}
フィールド個別の処理...

*IMessage message = new SampleMessage();
SampleMessage.oneof_fieldの場合

*var currentOneof = oneofField.Accessor.GetCaseFieldDescriptor(message);
現在のOneofの値を取得する

*var externalMessageField = message.Descriptor.FindFieldByName("external_message");
新しくOneofの値にexternal_messageを設定する ※MessageDescriptorからもOneofに属しているフィールドが取得できる

*void ProcessMessage(IMessage message)*{// フィールドの処理foreach (var field in message.Descriptor.Fields.InDeclarationOrder()){if (field.ContainingOneof != null){continue;}// Oneofに含まれない通常のフィールドの処理}// Oneofの処理foreach (var oneof in message.Descriptor.Oneofs){foreach (var field in oneof.Fields){// Oneofに含まれるフィールドの処理}}}
メッセージに対する何かしらの処理を行う関数

*}
Oneofに含まれない通常のフィールドの処理

*}
Oneofに含まれるフィールドの処理


*public void OnSaveNewPlayer()*{// セーブデータ作成SavePlayerData player = CreateSavePlayerData();// バイナリ形式でシリアル化BinaryFormatter bf = new BinaryFormatter();// 指定したパスにファイルを作成FileStream file = File.Create(SaveFilePath);// Closeが確実に呼ばれるように例外処理を用いるtry{// 指定したオブジェクトを上で作成したストリームにシリアル化するbf.Serialize(file, player);}finally{// ファイル操作には明示的な破棄が必要です。Closeを忘れないように。if (file != null)file.Close();}}
----- 一部抜粋 -----

*SavePlayerData player = CreateSavePlayerData();
セーブデータ作成

*BinaryFormatter bf = new BinaryFormatter();
バイナリ形式でシリアル化

*FileStream file = File.Create(SaveFilePath);
指定したパスにファイルを作成

*try*{// 指定したオブジェクトを上で作成したストリームにシリアル化するbf.Serialize(file, player);}
Closeが確実に呼ばれるように例外処理を用いる

*bf.Serialize(file, player);
指定したオブジェクトを上で作成したストリームにシリアル化する

*if (file != null)*file.Close();
ファイル操作には明示的な破棄が必要です。Closeを忘れないように。

*private SavePlayerData CreateSavePlayerData()*{SavePlayerData player = new SavePlayerData();player.name = nameInput.text;player.age = int.Parse(ageDropdown.options[ageDropdown.value].text);player.color = colorDropdown.options[colorDropdown.value].text;return player;}
入力された情報をもとにセーブデータを作成

*}
----- 一部抜粋 -----

*private void LoadPlayer()*{if (File.Exists(SaveFilePath)){// バイナリ形式でデシリアライズBinaryFormatter bf = new BinaryFormatter();// 指定したパスのファイルストリームを開くFileStream file = File.Open(SaveFilePath, FileMode.Open);try{// 指定したファイルストリームをオブジェクトにデシリアライズ。SavePlayerData player = (SavePlayerData)bf.Deserialize(file);// 読み込んだデータを反映。var playerObject = Instantiate(playerPrefab) as GameObject;playerObject.GetComponent<PlayerController>().Init(player.name, player.age, player.color);}finally{// ファイル操作には明示的な破棄が必要です。Closeを忘れないように。if (file != null)file.Close();}}else{Debug.Log("no load file");}}
----- 一部抜粋 -----

*BinaryFormatter bf = new BinaryFormatter();
バイナリ形式でデシリアライズ

*FileStream file = File.Open(SaveFilePath, FileMode.Open);
指定したパスのファイルストリームを開く

*SavePlayerData player = (SavePlayerData)bf.Deserialize(file);
指定したファイルストリームをオブジェクトにデシリアライズ。

*var playerObject = Instantiate(playerPrefab) as GameObject;
読み込んだデータを反映。

*if (file != null)*file.Close();
ファイル操作には明示的な破棄が必要です。Closeを忘れないように。

*}
----- 一部抜粋 -----


*Vector3 vTgt = target.position - player.position;
ターゲットへのベクトル

*Quaternion qTgt = Quaternion.LookRotation(vTgt);
ターゲットへのベクトルを前方とするクォータニオン
第二引数はワールド空間的な上（Vector3.up）でいいので省略

*Vector3 vOfs = qTgt * new Vector3(0f, 2f, -5f);
ずらすべき位置ベクトル
ずらしたい量をここでは後方5、高さ2とした場合

*Vector3 cameraPosition = player.position + vOfs;
最終的なカメラ位置（ワールド座標）

*Quaternion cameraRotation = Quaternion.LookRotation(target.position - cameraPosition);
ターゲットへの向き

*Vector3 targetVector = _lookTargetPosition - _attachTarget.position;
ターゲットへのベクトル

*Quaternion targetRotation = targetVector != Vector3.zero ? Quaternion.LookRotation(targetVector) : transform.rotation;*// 位置と向き
ターゲットへのベクトルを前方とするクォータニオン

*Vector3 position = _attachTarget.position + targetRotation * _attachOffset;
位置と向き

*Vector3 targetVector = _lookTargetPosition - _attachTarget.position;
ターゲットへのベクトル

*Quaternion targetRotation = targetVector != Vector3.zero ? Quaternion.LookRotation(targetVector) : transform.rotation;*// 位置と向き
ターゲットへのベクトルを前方とするクォータニオン

*Vector3 position = _attachTarget.position + targetRotation * _attachOffset;
位置と向き


*var file1 = dir2.CombineWithFilePath("d.txt");
abcd.txt

*var files = GetFiles("a/**/*.txt");
aというフォルダの拡張子".txt"というファイルを全て列挙する

*var args = new ProcessArgumentBuilder().Append("/c").Append("echo").Append("abcdefg");
引数付きのコマンドを実行する場合

*DotNetCoreClean("./sampleproject/sampleproject.csproj");
パスはcakeファイルからの相対パス

*Zip(DirectoryPath.FromString("a"), "output.zip");
a/b/c.txt, a/d.txtというファイルがフォルダに存在する場合、
b/c.txt, d.txtというファイルがoutput.zipファイルに圧縮される


*ILogger logger = LogManager.GetCurrentClassLogger();
例えばNLogに出力


*[TestCase("https:
qiita.comnariakiraHaraitemsf1b4d091ed447a283d8d", "title", "業務で使用したC#の便利ライブラリ - Qiita")]

*private static readonly string DATA_PATH = @"resources/Data.xlsx";
先程の画像のExcel Data.xlsxを読み込む

*using(var stream = File.Open(path, FileMode.Open, FileAccess.Read)) {using(var reader = ExcelReaderFactory.CreateReader(stream)) {ds = reader.AsDataSet();
ファイルパスからExcelを読み込む


*[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]public char[] szDevice;
...省略...

*FixedLengthCharArray32 szDevice;
...省略...


*break;
置いたら抜ける


*ExtraModuleNames.AddRange( new string[] { "TestModuleEd" } );
←ここを追加


*private void LoadCsv(string csvPath){// TextFieldParserでCSVを読み込みTextFieldParser parser = new TextFieldParser(csvPath, Encoding.GetEncoding("shift_jis"));parser.TextFieldType = FieldType.Delimited;parser.SetDelimiters(",");while (parser.EndOfData == false) {string[] datas = parser.ReadFields();int cols = datas.length;// 列数が不正だったら終了if(cols != 4){return;}// A列処理if(string.IsNullOrEmpty(datas[0])){// ...略}// B列処理if(string.IsNullOrEmpty(datas[1])){// ...略}// C列処理if(string.IsNullOrEmpty(datas[2])){// ...略}// D列処理if(string.IsNullOrEmpty(datas[3])){// ...略}// 取得したデータをDBに書き込んだり...// その結果を画面に表示させたり...}}
...略

*TextFieldParser parser = new TextFieldParser(csvPath, Encoding.GetEncoding("shift_jis"));*parser.TextFieldType = FieldType.Delimited;
TextFieldParserでCSVを読み込み

*}
...略

*}
...略

*}
...略

*}
...略

*}
取得したデータをDBに書き込んだり...
その結果を画面に表示させたり...

*private enum CsvCols*{// A列ColA = 0,// B列ColB = 1,// Bα列ColBalpha = 2,// C列ColC = 3,// D列ColD = 4}
列のインデックス定義

*ColA = 0,B列ColB = 1,Bα列ColBalpha = 2,C列ColC = 3,D列ColD = 4}列数private static int CSV_COLS = Enum.GetNames(typeof(CsvCols)).Length;
A列

*ColB = 1,Bα列ColBalpha = 2,C列ColC = 3,D列ColD = 4}列数private static int CSV_COLS = Enum.GetNames(typeof(CsvCols)).Length;
B列

*ColBalpha = 2,C列ColC = 3,D列ColD = 4}列数private static int CSV_COLS = Enum.GetNames(typeof(CsvCols)).Length;
Bα列

*ColC = 3,D列ColD = 4}列数private static int CSV_COLS = Enum.GetNames(typeof(CsvCols)).Length;
C列

*ColD = 4}列数private static int CSV_COLS = Enum.GetNames(typeof(CsvCols)).Length;
D列

*private static int CSV_COLS = Enum.GetNames(typeof(CsvCols)).Length;
列数

*// 列数が不正だったら終了(修正後)*if(cols != CSV_COLS){return;}
}

*if(string.IsNullOrEmpty(datas[(int)CsvCols.ColA])){
...略
}
A列処理(修正後)

*}
...略


*var globals = new Globals { foo = foo, bar = bar };
匿名型にしたいけれど、アクセスできないのでこうしてます


*sw.Start();
計測開始

*Type cType = Type.GetType("UI_Module.TestFunc");
クラスの型取得

*MethodInfo m = cType.GetMethod("Func1");
クラスのメソッド取得

*object obj = Activator.CreateInstance(cType);
インスタンス化

*m.Invoke(obj, null);
メソッド実行

*sw.Stop();
計測終了

*var ts = sw.Elapsed;
結果表示

*sw.Start();
計測開始

*Type cType = Type.GetType("UI_Module.TestFunc");
クラスの型取得

*m = cType.GetMethod("Func1");
クラスのメソッド取得

*obj = Activator.CreateInstance(cType);
インスタンス化

*m.Invoke(obj, null);
メソッド実行

*sw.Stop();
計測終了

*var ts = sw.Elapsed;
結果表示


*titleElementBy = By.XPath($"
*GroupText[@Name=\"{title}\"]");

*new Actions(driver)
タイトルの読み上げ

*.Click(titleElement)
ダイアログ内をクリックしてアクティブにする

*.MoveToElement(whenElement, 0, -50)
タイトル欄の左上端まで移動

*.ClickAndHold()
ドラッグを開始し

*.MoveByOffset(titleElement.Size.Width + 10, titleElement.Size.Height - 20)
タイトル欄の右端で

*.Release()
ドロップして

*.ContextClick()
コンテキストメニューを開き

*.SendKeys("U")
音声読み上げのショートカットキー "U" を送る

*try*{// 「選択部分を音声で読み上げる」の終了を待つvar readAloudBy = By.XPath("//*/Document[@Name=\"音声で読み上げる\"]");new WebDriverWait(driver, TimeSpan.FromSeconds(10)).Until(d => !d.FindElements(readAloudBy).Any());}
読み上げ終了待機

*new WebDriverWait(driver, TimeSpan.FromSeconds(10))
「選択部分を音声で読み上げる」の終了を待つ
var readAloudBy = By.XPath("*/Document[@Name=\"音声で読み上げる\"]");

*readAloudCloseButton.Click();
「ここから音声で読み上げる」になっていた場合、強制的に打ち切る
var readAloudCloseButton = driver.FindElement(By.XPath("*/ToolBar[@Name=\"音声で読み上げる\"]/Group/Group/Button[@Name=\"閉じる\"]"));

*titleElement = (WindowsElement)dialog.FindElement(titleElementBy);
タイトル要素を再取得

*titleElement.Click();
以降のショートカットを効かせるためにフォーカスを戻す

*titleElement.SendKeys(Keys.Escape);
イベントダイアログを閉じる


*public int SomeCount => someCount;
サーバーから受け取ったintへのプロパティ。読み取り専用

*public SomeTypes SomeType;
サーバーから受け取ったstringをenumに変換

*public bool SomeUsefulProperty*{get{...}}
データを元に判定を行ったりするプロパティ

*public int SomeUsefulMethod(SomeTypes type)*{......}
データ検索などを行うメソッド

*Enum.TryParse(someType, out SomeType);
文字列をenumに変換

*[Serializable]
サーバーから受け取るjsonをデシリアライズするためのクラス
半自動生成

*public class SomeScene : MonoBehaviour, IAdditiveSceneTask*{// 画面遷移システム[Inject]private SceneLoader _sceneLoader;// View[SerializeField]private Text _text;// サブコントローラー[SerializeField]private SomeSubController _subController;// 画面遷移トゥイーン// インスペクタでリストにトゥイーンを登録するコンポーネントです[SerializeField]private Tweens _tweens;// 初期化private void Start(){_text.text = "";}// 画面遷移システムから画面開始時に呼び出される独自のコールバックです// IAdditiveSceneTaskを実装すると呼ばれますpublic async Task Activate(){/* 画面開始時の処理 */// 通信var someData = await WebRequest.Factory.SomeInfo(param).Send();// データをUIにセット_text.text = someData.name;// サブコントローラーの実行_subController.Execute();// UI出現アニメーションawait _tweens.PlayInAnimations();}public async Task Inactivate(){/* 画面終了時の処理 */// UIを消すアニメーションawait _tweens.PlayOutAnimations();// 各種アンロード}private void OnDestroy(){// 後処理}// ボタンが押されたときの処理// インスペクタでButtonコンポーネントから呼び出すように設定しますpublic void OnClickButton(){// 例でバトルトップ画面に遷移// 画面はシーンをAdditiveロードする仕組み// 次シーンをロードしてActivate()を呼び出し、現在シーンのInactivateを呼び出します_sceneLoader.LoadSceneAdditive(ScenesEnum.BattleTop, false);}}
画面のメインコントローラー

*[Inject]
画面遷移システム

*[SerializeField]
サブコントローラー

*[SerializeField]
画面遷移トゥイーン
インスペクタでリストにトゥイーンを登録するコンポーネントです

*private void Start()*{_text.text = "";}
初期化

*public async Task Activate()
画面遷移システムから画面開始時に呼び出される独自のコールバックです
IAdditiveSceneTaskを実装すると呼ばれます

*var someData = await WebRequest.Factory.SomeInfo(param).Send();
通信

*_text.text = someData.name;
データをUIにセット

*_subController.Execute();
サブコントローラーの実行

*await _tweens.PlayInAnimations();
UI出現アニメーション

*await _tweens.PlayOutAnimations();
UIを消すアニメーション

*}
各種アンロード

*}
後処理

*public void OnClickButton()
ボタンが押されたときの処理
インスペクタでButtonコンポーネントから呼び出すように設定します

*_sceneLoader.LoadSceneAdditive(ScenesEnum.BattleTop, false);
例でバトルトップ画面に遷移
画面はシーンをAdditiveロードする仕組み
次シーンをロードしてActivate()を呼び出し、現在シーンのInactivateを呼び出します

*[Inject]
画面遷移のためのクラス

*_sceneLoader.LoadSceneAdditive(Scenes.SomeFunc,new SomeFuncScene.Arguments{TargetId = 1001});
シーンをAdditiveロード

*var dialog = await DialogLoader.Load<SomeDialog>();
ダイアログ開く

*bool isOk = dialog.WaitClose();
ボタンが押されて閉じられるまで待つ

*}
OKが押されたときの処理

*[SerializeField]
ダイアログ共通処理コンポーネント

*private bool _isOk = false;
OKボタンを押した？

*}
初期化
開く処理はDialogCommonによって自動的に行われます

*}
引数を使った処理

*public void OnClickOkButton()*{_isOk = true;_common.Close();}
OKボタンを押した

*public void OnClickCancelButton()*{_common.Close();}
キャンセルボタンを押した

*public async Task<bool> WaitClose()
ボタンが押されてダイアログが閉じるまで待つ
選択結果を返す

*}
通信エラー時

*});
サーバーからデータ受信したときの処理
例. マッチングしたプレイヤーの情報を表示、チャットメッセージを表示

*[Inject]
アセットバンドルロードシステム


*instance = _instanceDict[type] as T;
事前に生成された単一インスタンスを返す

*instance = Activator.CreateInstance(_typeDict[type]) as T;
インスタンスを生成して返す

*}
正式な処理

*}
デバッグ用の処理

*bool useDebugSystem;
この変数を切り替えることで生成するインスタンス切り替えます
単純化のためクラス内の#defineで定義しています
実際にはScripting Define Symbolsや設定ファイルを読み込んだりして切り替えます

*Locator.Register<ISomeSystem>(new SomeSystem());
正式な処理を行うインスタンスを登録

*Locator.Register<ISomeSystem>(new DebugSomeSystem());
デバッグ用処理を行うインスタンスを登録

*var system = Locator.Resolve<ISomeSystem>();
システムの型を指定して登録されているインスタンスをServiceLocatorから取得

*var system2 = new SomeSystem();
newの場合

*SomeSystem.SomeMethod();
staticの場合

*SomeSystem.Instance.SomeMethod();
シングルトンの場合


*obj = rect;
パースした結果はobjに格納する。


*}
右クリックはcontextmenuを表示させるので、ここでは何もしない


*int numIdx = GetNumberFromChar(nextChar);
ms_digitsに入ったらindex返す

*num = (num*10)+numIdx 的な感じマイナス、少点数などの対応も忘れずに}数字を返すif(isNumber)return new JSONObject(number);
１個ずつの数字を追加していく

*}
num = (num*10)+numIdx 的な感じ
マイナス、少点数などの対応も忘れずに

*if(isNumber)*return new JSONObject(number);
数字を返す

*return new JSONObject(str.Substring(start, length));
結局stringかオブジェクトだったらsubstringしちゃうかー


*Registry.GetContainer().RegisterServices(v =>*{v.AddTransient<IA>(v => new A1());});
...


*[Command("Sample Command 01")]
引数にMonKey上のコマンド名を指定する

*var pathBuilder = new System.Text.StringBuilder(selectedGameObject.name);
親のGameObjectの名前を手前に連結していく。


*Debug.WriteLine(code)
=> Success


*bool isValid = editContext.Validate();
検証を実施して結果を取得

*//messages.AddRange(fieldIdentifier, validationResults.Errors.Select(error => error.ErrorMessage));*messages.Add(fieldIdentifier, validationResults.Errors.Select(error => error.ErrorMessage));
APIの仕様変更のため、Addに変更

*messages.Add(fieldIdentifier, validationResults.Errors.Select(error => error.ErrorMessage));*editContext.NotifyValidationStateChanged();
messages.AddRange(fieldIdentifier, validationResults.Errors.Select(error => error.ErrorMessage));


*void Update()*{if (Input.GetKey(KeyCode.M)){if (SceneController.AlreadyLoadScene("Title")){SceneManager.UnloadSceneAsync("Title");}SceneManager.LoadScene("Main", LoadSceneMode.Additive);}}
Update is called once per frame


*count++;
腹筋カウント


*var decrypted = connector.SendPost($"https:
{メッセージ受信側HTTPサーバのIP:Port}rsaremote", encrypted).Result;

*Console.WriteLine($"Decrypted\r\n{decrypted}\r\n");
サーバで復号した結果を表示

*var publicKeyReader = new PemReader(new StringReader(publickey));
PEMフォーマットの公開鍵を読み込んで KeyParam を生成

*rsa.Init(true, publicKeyParam);
RSA暗号オブジェクトを初期化（第１引数 true は「暗号化」を示す）

*byte[] encrypted = rsa.ProcessBlock(bytes, 0, bytes.Length);
対象のバイト列を渡し暗号化した結果のバイト列を受け取る


*HtmlParser parser = new HtmlParser();
インスタンス作成

*IHtmlDocument doc = parser.ParseDocument(HTMLtext);
HTMLの文字列を分解します。

*var Nodes = doc.GetElementsByClassName("articles");
HTML内の<div class="articles">抜き出したいところ</div>
divは入れ子になっており同名のタグが大量にありますがインデントを目安にすると
抜き取りたいデータが上記タグ内にすべて収まっていることが分かります。

*var dateNodes = Nodes[0].GetElementsByClassName("date");
ここから分岐してdateNodes,bodyNodesにはそれぞれ違う絞り込みをかけます。
今回のHTMLにarticleクラスは1つしか存在しないためNodesの先頭Nodes[0]を参照します。
(取り出した要素が1つでもコレクションになるため必ず[index]が必要です)

*string username = Nodes[0].GetElementsByClassName("user")[0].TextContent.Trim('『').Trim('』');
これはのちのuser（ログインしているユーザー名）を探しています。

*var datelist = new List<string>();
dateNodesの中身抜出し（TextContentはstring型の戻り値なのでTrimが使える）

*int Counter = 0;
bodyNodesの中身抜出し＆正規表現で『』や()の間の文字列を取り出す。

*var dic = new SortedDictionary<string, string>();
ソートディクショナリを宣言して名前順（Key順）にソート

*mylist.Add(username + "," + dic[username]);
先頭にユーザーネームとデータを挿入。

*bodylist.Add(datelist[Counter] + "," + string.Join(",", mylist));
並び替え後のリスト作成

*if (DataCount < Counter)*break;
Counterが指定のデータ数に到達したらループを抜ける


*override protected void InitInstance()*{id = instances.Count;instances.Add(this);}
共通部分


*new object[] {"https:
yahoo.co.jp", 200},


*string s = Console.ReadLine();
文字列の入力

*long n = long.Parse(Console.ReadLine());
整数の入力

*string[] inputStrArray = Console.ReadLine().Split(' ');
文字列配列の入力

*long[] inputLongArray = Console.ReadLine().Split(' ').Select(i => long.Parse(i)).ToArray();
整数配列の入力


*engine.RecognizeAsync(RecognizeMode.Multiple);
開始


*public void ConfigureServices(IServiceCollection services)*{services.AddRazorPages();services.AddDbContext<RazorPagesMovieContext>(options =>options.UseSqlite(Configuration.GetConnectionString("MovieContext")));}
This method gets called by the runtime. Use this method to add services to the container.

*public void Configure(IApplicationBuilder app, IWebHostEnvironment env)*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseExceptionHandler("/Error");// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.app.UseHsts();}app.UseHttpsRedirection();app.UseStaticFiles();app.UseRouting();app.UseAuthorization();app.UseEndpoints(endpoints =>{endpoints.MapRazorPages();});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.


*target.transform.rotation = rot * target.transform.rotation;
左から掛ける


*[Inject]
Injectメソッドで準備された中間要素を受けっとってUseCaseを生成

*public class BMISceneInstaller : MainInstallerBase {// inspectorからアタッチする[SerializeField] SharedScriptableObject sharedData = default;[SerializeField] BMIView bmiView = default;[SerializeField] HistoryView historyView = default;[SerializeField] HistoryElmView historyElmView = default;[SerializeField] AccountView accountView = default;// シーンの最初に呼ばれる。DIを行う。public override void InstallBindings() {base.InstallBindings();var dataStore = new PlayerPrefsHistoryDataStore(sharedData.CurrentUserId)as IHistoryDataStore;Container.Bind<IHistoryListPresenter>().FromInstance(new HistoryListPresenter(historyView, historyElmView)).AsCached().IfNotBound();Container.Bind<IBMIHistoryRepository>().FromInstance(new BMIHistoryRepository(dataStore)).AsCached().IfNotBound();Container.Bind<IBMIPresenter>().FromInstance(new BMIPresenter(bmiView)).AsCached().IfNotBound();Container.Bind<IUserAccountRepository>().FromInstance(new UserAccountRepository(sharedData)).AsCached().IfNotBound();Container.Bind<IAccountPresenter>().FromInstance(new AccountPresenter(accountView)).AsCached().IfNotBound();}}
MainInstallerBaseは後で説明します

*[SerializeField] SharedScriptableObject sharedData = default;
inspectorからアタッチする

*public override void InstallBindings() {base.InstallBindings();var dataStore = new PlayerPrefsHistoryDataStore(sharedData.CurrentUserId)as IHistoryDataStore;Container.Bind<IHistoryListPresenter>().FromInstance(new HistoryListPresenter(historyView, historyElmView)).AsCached().IfNotBound();Container.Bind<IBMIHistoryRepository>().FromInstance(new BMIHistoryRepository(dataStore)).AsCached().IfNotBound();Container.Bind<IBMIPresenter>().FromInstance(new BMIPresenter(bmiView)).AsCached().IfNotBound();Container.Bind<IUserAccountRepository>().FromInstance(new UserAccountRepository(sharedData)).AsCached().IfNotBound();Container.Bind<IAccountPresenter>().FromInstance(new AccountPresenter(accountView)).AsCached().IfNotBound();}
シーンの最初に呼ばれる。DIを行う。

*var canvas = GameObject.Find("Canvas").transform;*bmiView = canvas.Find("BMIView").GetComponent<BMIView>();
find

*var prefab = AssetDatabase.LoadAssetAtPath<GameObject>("Assets/BMIApp/Prefabs/HistoryElm.prefab");
prefab

*Assert.IsEmpty(bmiView.NameInput.text);
最初は未入力

*bmiView.NameInput.onEndEdit.Invoke("test_name");
名前/身長/体重を入力すると[保存]が押せるようになる

*Assert.That(bmiView.BMIText.text, Is.EqualTo("37.0(肥満)"));
計算されたBMIと評価が表示される

*bmiView.SaveButton.onClick.Invoke();
[保存]を押すとリストに追加される

*var elm = historyView.Content.GetChild(0)?.GetComponent<HistoryElmView>();
内容が 日時-名前-BMI

*bmiView.HeightInput.onEndEdit.Invoke("100");
後から追加された方が上にくる

*Assert.That(historyData.Datas.Count, Is.EqualTo(2));
リポジトリにも追加されている

*historyView.ClearButton.onClick.Invoke();
[クリア]でデータが消える

*if (Container.HasBinding<ITest>()) {
Bindの内容でテストによる実行かを判断し、
テストの場合はmainをここで非活性化し、
テストから任意のタイミングでAwakeを呼べるようにする


*VisualElement label = new Label("Hello World! From C#"){style = {fontSize = 64,color = new StyleColor(Color.magenta)}};
初期化と同時に設定

*VisualElement label2 = new Label("Hello World! From C#");
要素ごとに設定

*child.style.unityTextAlign = new StyleEnum<TextAnchor>(TextAnchor.UpperLeft);
子オブジェクトに左上整列を指示


*Text text = GetComponent<Text>();
毎回呼ばれる

*text.text = "文字";
テキストの文字を変更

*Text m_text = null;
キャッシュ用メンバ変数

*m_text = GetComponent<Text>();
最初の一回だけGetComponentを呼び出しキャッシュする

*m_text.text = "文字";
テキストの文字を変更

*m_text.text = "文字";
テキストの文字を変更

*m_text.text = "文字";
テキストの文字を変更


*int FileIndex = 0;
上記の別の書き方
string FilePath = Path.Combine(DesktopDir,FileName) + Extend;
コメントでいただきましたメソッドです。フォルダ階層が深い場合は有効そうですね。

*if (string.IsNullOrWhiteSpace(s) == false)*File.WriteAllText(FilePath, s);
文字列をファイルに保存

*/*********
出力

*/*********
出力

*Task task1 = Task.Run(() =>{  SaveFile(resultstr);  });
ファイルの保存（別タスクで非同期処理　続けて処理をおこなうときはWait()を削除する）


*var response = await client.GetAsync($"https:
apps.autodesk.comwebservicescheckentitlement?{await new FormUrlEncodedContent(parameters).ReadAsStringAsync()}");

*var serializer = new DataContractJsonSerializer(typeof(ServerResponse));
得られたjsonを解析する


*Console.WriteLine("visibleじゃないよ");
ifの計算の結果は0となっている。


*[MenuItem("Window/UIElements/Test")]
メニューバーから呼び出すためのattribute

*wnd.titleContent = new GUIContent("Test");
↓タイトルの設定

*VisualElement root = rootVisualElement;
rootVisualElement（表示されるUIすべての親となるVisualElementの取得）

*VisualElement label = new Label("Hello World! From C#");
VisualElementの一つ、ラベルを生成

*root.Add(label);
rootの子要素として追加、デフォルトだと子要素は上から下にstackされていく

*textField.style.height = 50;
レイアウトにかかわる部分はXX.styleから変更できる


*public delegate void SimpleCalc(int a, int b);
1. まずはデリゲートを定義します。（デリゲートはあくまでメソッドへの参照を表す型です）

*static void Add(int a, int b)*{Console.WriteLine($"{a} + {b} = {a + b}");}
SimpleCalcデリゲートと同じ戻り値の型とパラメーターリストであること関数を用意

*SimpleCalc del_calc = Add;
2. デリゲートをインスタンス化。同じ戻り値の型、パラメーターリストを持つ関数を代入

*del_calc(20, 10);
3. デリゲートインスタンスを通じて関数(この場合Add)を呼び出す

*del_calc = Subtract;
2, 3繰り返す

*IEnumerator LoadImage(string _imagePath, Action<Texture2D> _callback)*{}
デリゲートをわざわざ定義しなくて良い


*tasklist.Start();
まとめて実行


*anotherList.AddRange(list);
2回入れている


*MessageBox.Show("Cannot find end mark\r\n
%%kob58im-ToolEnd%%");


*target.Hp -= singleDamage * 3;
実際にHPを減らす

*(Skill, int priority) candidate = (null, -context.Enemy.Hp);
最も優先度が高い候補を保持する変数。より優先度の高いスキルが現れれば、その都度更新される

*var clone = new EnemyBattler(){Hp = context.Enemy.Hp,Defense = context.Enemy.Defense};
A. シミュレーション中に敵が受けるダメージを実際には反映しないためのクローン

*skill.Run(context, clone);
B. スキルを実際に適用してみる

*var priority = -clone.Hp;
C. スキルの仕様結果を評価する。
敵のHPが少ないほど好ましい状況のはず

*var source = new EnemyBattler() { Hp = 100 };
元のオブジェクト。

*var notClone = source;
変数 source を変数 notClone に代入しただけ。クローンじゃない。
この2つの変数は参照先が同じ

*notClone.Hp = 99;
notClone.Hp を書き換えると source.Hp も書き換わってしまう。

*// この2つの変数は参照先が違う*var clone = new EnemyBattler() { Hp = source.Hp };
変数 source のメンバー変数の値だけを引き継ぐ新しいオブジェクト。これがクローン。

*var clone = new EnemyBattler() { Hp = source.Hp };
この2つの変数は参照先が違う

*clone.Hp = 50;
clone.Hp を書き換えても、 source.Hp は書き換わらない。

*public void Talk(string message)*{// isShownというprivateフィールドをBattleContextに追加しておく。if(isShown) Console.WriteLine(message);}
前略

*if(isShown) Console.WriteLine(message);*}
isShownというprivateフィールドをBattleContextに追加しておく。

*,,,
後略

*context.View.Talk("あなたは狙いを定めて敵を撃ちぬいた！");
Talkメソッド自体は表示の作業はせず、あくまでどのような機能へデータを流すかを制御するだけ。
もはや Console.WriteLine を読んでいるのかどうかを把握することは、呼び出し側の責任ではない

*class ConsoleView : IView*{public void Talk(string text){Console.WriteLine(text);}}
コンソールに表示するモード

*class NullView : IView*{public void Talk(string text){// 何もしない}}
どこにも表示しないモード

*}
何もしない

*public BattleContext(IView view)
コンストラクター引数から受け取って、読み取り専用プロパティに設定する
View プロパティの内容を後から書き換えることのない設計にするつもりのため

*var context = new BattleContext(){Enemy = enemy1,Player = new PlayerBattler(){Hp = 100,Defense = 0,Skills = new Skill[]{new SingleAttackSkill(87),new TripleAttackSkill(39),}}};
前略

*,,,
後略

*var context = new BattleContext(new ConsoleView()){Enemy = enemy2,Player = new PlayerBattler(){Hp = 100,Defense = 0,Skills = new Skill[]{new SingleAttackSkill(87),new TripleAttackSkill(39),}}};
前略

*,,,
後略

*var context = new BattleContext(new NullView()){Enemy = enemy2,Player = new PlayerBattler(){Hp = 100,Defense = 0,Skills = new Skill[]{new SingleAttackSkill(87),new TripleAttackSkill(39),}}};
前略

*,,,
後略

*var cloneContext = new BattleContext(new NullView()){Enemy = context.Enemy,Player = context.Player};
*修正* シミュレーション中に発動するスキルのメッセージを表示しないようにするためのクローン

*var clone = new EnemyBattler()
シミュレーション中に敵が受けるダメージを実際には反映しないためのクローン
割愛しているが、実際はプレイヤーのクローンも生成しておいたり、
敵のクローンはBattleContext.Enemyなどにもsetしておいたほうが
独特なスキルをたくさん実装する際に安全

*skill.Run(cloneContext, clone);
*修正* BattleContext を渡す場所には、メインの BattleContext ではなく
NullView を持たせてあるクローンのほうの BattleContext を渡す


*}
まだ未実装

*linq = linq.Where(x => x.Gender?MyVM.IsManChecked:MyVM.IsWomanChecked);
三項演算子,x.GenderがtrueであればIsMancheckedをみて、falseであればIsWomanCheckを見る。

*linq = linq.Where(x => x.Gender?MyVM.IsManChecked:MyVM.IsWomanChecked);
三項演算子,x.GenderがtrueであればIsMancheckedをみて、falseであればIsWomanCheckを見る。


*[JsonIgnore]
自動実装ではないプロパティを除外する。


*string USER_ID = "mjm54XXXXXX";
ログインページではなくHTML内の$.ajaxのurlを参照
string url_post = "https:pl.sega-mj.com/players/MjmidLogin";
ログイン後にジャンプするページ
string url_history = "https:pl.sega-mj.com/playdata_view/showHistory";

*client = new HttpClient();
クライアント接続開始

*Task<bool> task_login = PostRequest(url_post, USER_ID, PASSWORD);
POST要求（ログインしてクッキー取得）

*string resultstr = AnalizeHtml(50, HTMLtext);
HTML構造解析

*Task task1 = Task.Run(() =>{  SaveFile(resultstr);  });
ファイルの保存（別タスクで非同期処理　続けて処理をおこなうときはWait()を削除する）

*Console.ReadKey();
End待機
Thread.Sleep(1000);

*async static Task<bool> PostRequest(string url_post, string user, string password)*{//POSTで送る内容作成。mContent.Add(属性の値, 属性の名前)MultipartFormDataContent mContent = new MultipartFormDataContent();mContent.Add(new StringContent(user) ,  "mjm_id");mContent.Add(new StringContent(password) ,  "password");//ヘッダ情報確認Console.WriteLine("【PostRequest Headers】" + mContent.Headers);//POSTしてレスポンスの要求。（要求先、要求内容）HttpResponseMessage response = await client.PostAsync(url_post, mContent);Console.WriteLine("【PostRequest Response】 " + response.StatusCode.ToString());if (response.StatusCode == HttpStatusCode.OK){//応答ステータスがOKならHTML文字列を取得する。string contentstr = await response.Content.ReadAsStringAsync();Console.WriteLine("【PostRequest HTMLcontent】" + contentstr);Console.WriteLine("【PostRequest Cookie】" + response.Headers.GetValues("Set-Cookie").First() );}return true;}
POST要求（ログイン）

*MultipartFormDataContent mContent = new MultipartFormDataContent();
POSTで送る内容作成。mContent.Add(属性の値, 属性の名前)

*Console.WriteLine("【PostRequest Headers】" + mContent.Headers);
ヘッダ情報確認

*HttpResponseMessage response = await client.PostAsync(url_post, mContent);
POSTしてレスポンスの要求。（要求先、要求内容）

*string contentstr = await response.Content.ReadAsStringAsync();
応答ステータスがOKならHTML文字列を取得する。

*async static Task<string> GetRequest(string url)*{HttpResponseMessage response = await client.GetAsync(url);string contentstr = response.StatusCode.ToString();Console.WriteLine("【GetRequest Response】" + contentstr);if (response.StatusCode == System.Net.HttpStatusCode.OK){contentstr = await response.Content.ReadAsStringAsync();}else if (response.StatusCode == HttpStatusCode.Redirect){//StatusCode リダイレクトのときの処理var r = client.GetAsync(url).Result;Uri uri = new Uri(new Uri(url), r.Headers.Location);contentstr = client.GetAsync(uri).Result.Content.ReadAsStringAsync().Result;}return contentstr;}
URLからHTMLをゲット（ログインには使用しない）

*var r = client.GetAsync(url).Result;
StatusCode リダイレクトのときの処理


*var b = new byte[W,H];
new


*delvoid();
処理

*delint();
処理

*delstr();
処理

*}
処理

*}
処理
最後にstringを返す

*}
処理
最後にintを返す


*return null;
置換対象ではない


*Array.Resize<byte>(ref encryptKey, AesBlockByteSize);
AES暗号化キーの長さを強制的に16バイトで切る

*aes.BlockSize = AesBlockBitSize;
AES暗号化の設定

*var iv = new byte[AesBlockByteSize];
ランダムなIVを生成

*outputStream.Write(iv, 0, AesBlockByteSize);
復号用にIVの値をファイル先頭に出力する


*[JsonObject("skill")]*class Skill{[JsonProperty("language")]public string language {get; set;}[JsonProperty("ex_year")]public int exyear {get; set;}public Skill(string lang,int year){this.language = lang;this.exyear = year;}}
クラス定義

*List<Skill> skillList= new List<Skill>();
JSONファイルを作る


*PdfDocument document = new PdfDocument();
PDFファイルをロードします。

*JoinTiffImages(SaveAsImage(document), "result.tiff", EncoderValue.CompressionLZW);*}
.tiffで保存します。

*private static Image[] SaveAsImage(PdfDocument document)*{Image[] images = new Image[document.Pages.Count];for (int i = 0; i < document.Pages.Count; i++){images[i] = document.SaveAsImage(i);}return images;}
SaveAsImage()

*private static ImageCodecInfo GetEncoderInfo(string mimeType)*{ImageCodecInfo[] encoders = ImageCodecInfo.GetImageEncoders();for (int j = 0; j < encoders.Length; j++){if (encoders[j].MimeType == mimeType)return encoders[j];}throw new Exception(mimeType + " mime type not found in ImageCodecInfo");}
GetEncoderInfo()メソッドを定義します

*Image tiffImage = Image.FromFile("test.tiff");*Image[] imgs = SplitImages(tiffImage);
tiffをロードします。

*page.Canvas.DrawImage(pdfImg, x, 0, pageSize.Width,pageSize.Height);
PDFで画像を描きます。

*pdfDoc.SaveToFile("result.pdf");
Pdfで保存します。


*}
LINQでこう書くと実際オサレ
return points.Select(matrix.MultiplyPoint).ToArray();

*Profiler.BeginSample("#ByRust");
Rustによる変換

*Profiler.BeginSample("#ByRustR");
Rust(Releaseビルド)による変換

*Profiler.BeginSample("#ByCSharp");
C#による変換

*private static Vector3[] TransByCsharp(Matrix4x4 matrix, IReadOnlyList<Vector3> points)*{var ret = new Vector3[points.Count];for (var count = 0; count < points.Count; count++){ret[count] = matrix.MultiplyPoint(points[count]);}return ret;}
C#による変換

*private static Vector3[] TransByRust(Matrix4x4 matrix, IReadOnlyList<Vector3> points)*{var ret = new Vector3[points.Count];for (var count = 0; count < points.Count; count++){ret[count] = multiply_point(matrix, points[count]);}return ret;}
RustDebugビルドによる変換

*private static Vector3[] TransByRustRelease(Matrix4x4 matrix, IReadOnlyList<Vector3> points)*{var ret = new Vector3[points.Count];for (var count = 0; count < points.Count; count++){ret[count] = multiply_point_r(matrix, points[count]);}return ret;}
RustReleaseビルドによる変換

*private static Task<Vector3[]> GenerateRandomVectorAsync(CancellationToken cancellationToken, int length)*{var random = new System.Random();var points = new Vector3[length];for (var count = 0; count < points.Length; count++){cancellationToken.ThrowIfCancellationRequested();// UnityEngine.RandomのAPIはメインスレッドからしか呼べない...// なので無理矢理ランダムなVector3を生成するpoints[count].x = (float) (random.NextDouble() * random.Next(-100, 100));points[count].y = (float) (random.NextDouble() * random.Next(-100, 100));points[count].z = (float) (random.NextDouble() * random.Next(-100, 100));}return Task.FromResult(points);}
ランダムなVector3の配列を生成

*points[count].x = (float) (random.NextDouble() * random.Next(-100, 100));
UnityEngine.RandomのAPIはメインスレッドからしか呼べない...
なので無理矢理ランダムなVector3を生成する


*bool TerminalCheck()*{int b = ms.ReadByte();if ( b < 0 ) {return true;}else {ms.Position--;return false;}}
---------------------------------------------


*string outputBatPath = Path.Combine(Environment.CurrentDirectory, @"Register.bat");
保存先のパス

*return true;
「ユーザーアカウント制御」ダイアログでキャンセルされたなどによって
起動できなかった時


*string tempPath = "";
色々処理した結果の一時ファイルのパス

*img.Density = new Density(densityX, DensityUnit.PixelsPerInch);
解像度を設定

*img.Write(outPath);
保存


*int toHeight = 50;
拡大後の高さ

*img.FilterType = ImageMagick.FilterType.Lanczos;
フィルター指定

*img.Resize((int)Math.Ceiling(newWid), toHeight);
リサイズ実行

*img.Write(Path.Combine(outPath, $"{filename}_out{ext}"));
保存


*public void Registration()
接続するURL
private const string RegistrationURL = "http:localhost:5000/registration";
ゲームオブジェクトUI > ButtonのInspector > On Click()から呼び出すメソッド

*WWWForm form = new WWWForm();*form.AddField("user_id", m_idInputField.text, Encoding.UTF8);
POSTする情報

*UnityWebRequest webRequest = UnityWebRequest.Post(url, form);*//UnityWebRequestにバッファをセット
URLをPOSTで用意

*webRequest.downloadHandler = new DownloadHandlerBuffer();
UnityWebRequestにバッファをセット

*yield return webRequest.SendWebRequest();
URLに接続して結果が戻ってくるまで待機

*Debug.Log(webRequest.error);
通信失敗

*Debug.Log("Post"+" : "+webRequest.downloadHandler.text);
通信成功

*WWWForm form = new WWWForm();*form.AddField("user_id", m_idInputField.text, Encoding.UTF8);
POSTする情報


*GetWindow<EditorWindowScript>("SceneEditWindow");
エディタウインドウ生成

*string textField1 = "";
テキストフィールド用変数

*EditorGUILayout.Space();
エディタレイアウト
２行開ける

*textField1 = EditorGUILayout.TextField( "セーブするシーン名",textField1 );*using (new GUILayout.HorizontalScope()){//セーブ用ボタン作成if (GUILayout.Button("Save Scene")){//Castle Object内のTag付きObjectを全てセーブしますGameObject castle = GameObject.Find("Castle");//Resources内のCastleObjectData(ScriptableObject)をtextField1を用いてアクセスCastleObjectData data = Resources.Load<CastleObjectData>("CastleObjectData/CastleObjectData"+textField1);//すでに存在するデータ名であれば上書きして良いか警告するif(data != null){//Canselボタンあり、OKかCanselかで処理分けする場合のUnityDialogbool b = EditorUtility.DisplayDialog("警告", "上書きしますか？?", "はい", "いいえ");if(!b) {//”いいえ”ならセーブに必要なTextField1をリセットtextField1 = "";}}Resources.UnloadUnusedAssets();if(textField1!=""){//データ保存用CastleObjectData(ScriptableObject)を作成CastleObjectData castleObjectData = ScriptableObject.CreateInstance<CastleObjectData>();//Castle Object以下の全てのTag付きObjectのPosition,Rotation,ObjectType(Tag)を保存します。（形式についてはCastleObjectDataクラスを参照）(GetAllメソッドについてはGetAllChildrenクラスを参照)List<GameObject> list = GetAllChildren.GetAll(castle);foreach (GameObject obj in list) {ObjectInfo objectInfo = new ObjectInfo();if(obj.tag!="Untagged"){objectInfo.objectTransform = obj.transform.position;objectInfo.objectRotation  = obj.transform.rotation;objectInfo.objectType = obj.tag;castleObjectData.castleObjects.Add(objectInfo);}}//ファイル書き出しAssetDatabase.CreateAsset(castleObjectData, "Assets/Resources/CastleObjectData/CastleObjectData"+textField1+".asset");}}}
セーブ用テキストフィールド作成

*GameObject castle = GameObject.Find("Castle");
Castle Object内のTag付きObjectを全てセーブします

*CastleObjectData data = Resources.Load<CastleObjectData>("CastleObjectData/CastleObjectData"+textField1);
Resources内のCastleObjectData(ScriptableObject)をtextField1を用いてアクセス

*bool b = EditorUtility.DisplayDialog("警告", "上書きしますか？?", "はい", "いいえ");*if(!b) {//”いいえ”ならセーブに必要なTextField1をリセットtextField1 = "";}
Canselボタンあり、OKかCanselかで処理分けする場合のUnityDialog

*textField1 = "";
”いいえ”ならセーブに必要なTextField1をリセット

*CastleObjectData castleObjectData = ScriptableObject.CreateInstance<CastleObjectData>();
データ保存用CastleObjectData(ScriptableObject)を作成

*List<GameObject> list = GetAllChildren.GetAll(castle);*foreach (GameObject obj in list) {ObjectInfo objectInfo = new ObjectInfo();if(obj.tag!="Untagged"){objectInfo.objectTransform = obj.transform.position;objectInfo.objectRotation  = obj.transform.rotation;objectInfo.objectType = obj.tag;castleObjectData.castleObjects.Add(objectInfo);}}
Castle Object以下の全てのTag付きObjectのPosition,Rotation,ObjectType(Tag)を保存します。（形式についてはCastleObjectDataクラスを参照）(GetAllメソッドについてはGetAllChildrenクラスを参照)

*AssetDatabase.CreateAsset(castleObjectData, "Assets/Resources/CastleObjectData/CastleObjectData"+textField1+".asset");
ファイル書き出し

*EditorGUILayout.Space();
２行開ける

*textField2 = EditorGUILayout.TextField( "ロードするシーン名",textField2);*using (new GUILayout.HorizontalScope()){//ロードボタンif (GUILayout.Button("Load Scene")){int prefabNum = 0;GameObject castle = GameObject.Find("Castle");//Canselボタンあり、OKかCanselかで処理分けする場合bool b = EditorUtility.DisplayDialog("警告", "ロードしますか？?", "はい", "いいえ");if(b) {//castle以下のObjectを取得（GetAllメソッドについてはGetAllChildrenクラスを参照）List<GameObject> list = GetAllChildren.GetAll(castle);//元々のシーン上のオブジェクトを破棄foreach(GameObject obj in list){DestroyImmediate(obj);}CastleObjectData data = Resources.Load<CastleObjectData>("CastleObjectData/CastleObjectData"+textField2);foreach(ObjectInfo objectInfo in data.castleObjects){prefabNum++;//プレハブを取得(Tag名とPrefab名は便宜上同じにしておく)GameObject prefab;prefab = (GameObject)Resources.Load("Prefabs/"+objectInfo.objectType);string prefabName = objectInfo.objectType;//プレハブからインスタンスを生成if(prefab!=null){var obj = Instantiate(prefab, objectInfo.objectTransform , objectInfo.objectRotation ,castle.transform);obj.name = prefabName;}}}}}
ロード用テキストフィールド作成

*bool b = EditorUtility.DisplayDialog("警告", "ロードしますか？?", "はい", "いいえ");*if(b) {//castle以下のObjectを取得（GetAllメソッドについてはGetAllChildrenクラスを参照）List<GameObject> list = GetAllChildren.GetAll(castle);//元々のシーン上のオブジェクトを破棄foreach(GameObject obj in list){DestroyImmediate(obj);}CastleObjectData data = Resources.Load<CastleObjectData>("CastleObjectData/CastleObjectData"+textField2);foreach(ObjectInfo objectInfo in data.castleObjects){prefabNum++;//プレハブを取得(Tag名とPrefab名は便宜上同じにしておく)GameObject prefab;prefab = (GameObject)Resources.Load("Prefabs/"+objectInfo.objectType);string prefabName = objectInfo.objectType;//プレハブからインスタンスを生成if(prefab!=null){var obj = Instantiate(prefab, objectInfo.objectTransform , objectInfo.objectRotation ,castle.transform);obj.name = prefabName;}}}
Canselボタンあり、OKかCanselかで処理分けする場合

*List<GameObject> list = GetAllChildren.GetAll(castle);
castle以下のObjectを取得（GetAllメソッドについてはGetAllChildrenクラスを参照）

*GameObject prefab;
プレハブを取得(Tag名とPrefab名は便宜上同じにしておく)

*public enum ObjectType{Block = 0,Bomb = 1,FiveBlock = 2,TowerBlock = 3}
ここにPrefab名とTag名と同じObjectTypeをEnumで定義しておく

*public class CastleObjectData : ScriptableObject{//各ObjectのObjectInfoデータセットのListpublic List<ObjectInfo> castleObjects = new List<ObjectInfo>();}
ScriptableObjectの雛形を定義

*public List<ObjectInfo> castleObjects = new List<ObjectInfo>();
各ObjectのObjectInfoデータセットのList

*[System.Serializable]*public class ObjectInfo{public Vector3 objectTransform;public Quaternion objectRotation;public string objectType;}
ObjectInfoにはTransformPosition、TransformRotation、TagをStringで保存

*public static void GetChildren (GameObject obj, ref List<GameObject> allChildren)*{Transform children = obj.GetComponentInChildren<Transform> ();//子要素がいなければ終了if (children.childCount == 0) {return;}foreach (Transform ob in children) {allChildren.Add (ob.gameObject);GetChildren (ob.gameObject, ref allChildren);}}
子要素を取得してリストに追加


*PdfDocument pdf = new PdfDocument();
PDFをロードします。

*pdf.SaveToFile("ToHtml.html", FileFormat.HTML);
htmlで保存します。


*Handler.URL = "http:
localhostapiindex.php";


*using System.ComponentModel;
CancelEventArgsを使用するため

*NotifyIcon trayIcon = new NotifyIcon();*//trayIcon.Icon = new Icon("hogehoge.ico"); // 何かしらのアイコンを設定しないとタスクトレイに表示されない
this.ShowInTaskbar = false;  TaskTrayTestがFormを継承する場合はコメントアウトを外す

*Icon tmpIcon = MyIconUtil.Create16x16Icon(iconDot);
trayIcon.Icon = new Icon("hogehoge.ico");  何かしらのアイコンを設定しないとタスクトレイに表示されない


*SendMessage(128, 1, icon.Handle);
128 = WM_SETICON


*);
20191121 01:23:45


*void Start()
接続するURL
private const string URL = "http:localhost:5000/";

*StartCoroutine("OnSend", URL);
コルーチンを呼び出す

*UnityWebRequest webRequest = UnityWebRequest.Get(url);
指定したURLでGET

*yield return webRequest.SendWebRequest();
URLに接続して結果が戻ってくるまで待機

*Debug.Log(webRequest.error);
通信失敗

*Debug.Log("Get" + " : "+webRequest.downloadHandler.text);
通信成功

*WWWForm form = new WWWForm();*form.AddField("user_id", idInputField.text, Encoding.UTF8);
POSTする情報


*for (int x = 0; x <= 3; x++)
0,1,2 (3)

*if (x == 0) continue;*round_key[0, x] = (byte)(CURRENT_CHIPHER_KEY[ 0 + (1 * x)] ^ round_key[0, x - 1]);
0は除きたい（横インデックス1から埋め込んでいく）ので x は 1 2 3 のみに絞る


*}
1レコードずつ取り出す処理


*dgv.ColumnHeadersHeight = 0;
これは、うまくいかない

*dgv.GetType().BaseType
dgv は、DataGridView（を継承したクラス）のインスタンス


*for (double n = 1; n < 1e9;)
l = 11 - 13 + 15 - 17 + ... 11e9


*public enum SaveFolder*{Audio   = 0,Stage   = 1,Save    = 2};
ここにセーブフォルダを追加すれば楽になるかも


*string profileUrl       = "https:
api.line.mev2profile";

*ApiResponseCustomTokenData data = new ApiResponseCustomTokenData() {Status      = 0,CustomToken = null};
response

*var verifyResponse  = await _httpClient.SendAsync(veryfyRequest);*data.Status         = (int)verifyResponse.StatusCode;
accessToken検証

*var verifyBody  = await verifyResponse.Content.ReadAsStringAsync();*JObject verify  = JObject.Parse(verifyBody);
channelId抽出


*protected Dictionary<int, Control> items = new Dictionary<int, Control>();
コントロール配列で管理するクラスをDictionaryに入れる
（Listとかに使用と思ったらインデックス-1で登録されてくるケースがあったので
Dictionaryにしました。）

*public short Count()*{return checked((short)this.items.Count);}
コントロール配列内のコントロール数を返します。

*public void BeginInit()*{}
何もしないがこれがないとコンパイルエラー

*public void EndInit()*{}
何もしないがこれがないとコンパイルエラー

*protected override void Dispose(bool disposing)*{if(disposing){items.Clear();}base.Dispose(disposing);}
気持ちの問題か

*public short LBound()*{return 0;}
必要かどうか迷ったが入れておく

*public short UBound()*{return (short)(items.Count - 1);}
必要かどうか迷ったが入れておく

*public TextBoxArray()*{}
コンストラクタの中で何かする必要はなかった

*public TextBoxArray(IContainer Container)*{}
コンストラクタの中で何かする必要はなかった

*public event KeyPressEventHandler KeyPress;
KeyPressイベントハンドラ

*public bool CanExtend(object extendee)*{return extendee is TextBox;}
与えられたこのコントロール配列に入れることが出来るかどうかを返す

*protected Type GetControlInstanceType()*{return typeof(TextBox);}
コントロール配列の型を返す

*public void SetIndex(TextBox item, short index)*{items[index] = item;// コントロール配列のイベントを個々のコントロールに結び付けるif (KeyPress != null) item.KeyPress += KeyPress;}
コントロール配列にコントロールを登録

*if (KeyPress != null) item.KeyPress += KeyPress;*}
コントロール配列のイベントを個々のコントロールに結び付ける


*XamlWriter.Save(uiElement);
string xamlString =

*File.WriteAllText(filePath,xamlString);
uiElement);

*using XmlWriter xmlWriter =XmlWriter.Create(filePath,xmlWriterSettings);
xamlString);

*File.ReadAllText(filePath);
string xamlString =

*var obj =XamlReader.Parse(xamlString);
filePath);

*XamlReader.Parse(xamlString);
var obj =

*using XmlReader xmlReader =XmlReader.Create(filePath);
uiElement = (T)obj;


*await UniTask.DelayFrame(1);
たまに動作しない時があるため1F待機する

*Object.Destroy(_addedRaycaster);
依存関係のため_addedRaycasterから先に削除する


*if ( s.EndsWith(".lnk", true, null) ) {
Note: 第2引数はignoreCase


*this.Invalidate();
to repaint


*private void Start()*{rb = GetComponent<Rigidbody>();count = 0;SetCountText();winText.text = "";}
See also:https:docs.unity3d.com/ja/2019.1/Manual/ExecutionOrder.html


*return Convert.ToByte(color_bits_str, 2);
2進数からbyteに変換

*//private void data_umekomi_b(ref byte base1, ref byte base2, byte umekomi_byte)*//{   //指定されたバイト数値にデータを埋め込む所//    //基礎画像の下位4ビットをカットする。//    string base1_str = Convert.ToString(base1, 2).PadLeft(8, '0'); //8桁の二進数にする。//    base1_str = base1_str.Substring(0, 4); //上位4ビットのみ取得。//    string base2_str = Convert.ToString(base2, 2).PadLeft(8, '0'); //8桁の二進数にする。//    base2_str = base2_str.Substring(0, 4); //上位4ビットのみ取得。//    //空いた下位4ビットにデータを埋め込む//    string umekomi_str = Convert.ToString(umekomi_byte, 2).PadLeft(8, '0'); //8桁の二進数にする。//    base1_str = base1_str + umekomi_str.Substring(0, 4); //下位4ビットに埋め込む//    base1 = Convert.ToByte(base1_str, 2); //2進数からbyteに変換//    base2_str = base2_str + umekomi_str.Substring(4, 4); //下位4ビットに埋め込む//    base2 = Convert.ToByte(base2_str, 2); //2進数からbyteに変換//    //基礎側のバイナリは2つ進む//    base_cnt += 2;//}
ARGB8888なら以下の埋め込み方法だった。

*//{   //指定されたバイト数値にデータを埋め込む所//    //基礎画像の下位4ビットをカットする。//    string base1_str = Convert.ToString(base1, 2).PadLeft(8, '0'); //8桁の二進数にする。//    base1_str = base1_str.Substring(0, 4); //上位4ビットのみ取得。//    string base2_str = Convert.ToString(base2, 2).PadLeft(8, '0'); //8桁の二進数にする。//    base2_str = base2_str.Substring(0, 4); //上位4ビットのみ取得。//    //空いた下位4ビットにデータを埋め込む//    string umekomi_str = Convert.ToString(umekomi_byte, 2).PadLeft(8, '0'); //8桁の二進数にする。//    base1_str = base1_str + umekomi_str.Substring(0, 4); //下位4ビットに埋め込む//    base1 = Convert.ToByte(base1_str, 2); //2進数からbyteに変換//    base2_str = base2_str + umekomi_str.Substring(4, 4); //下位4ビットに埋め込む//    base2 = Convert.ToByte(base2_str, 2); //2進数からbyteに変換//    //基礎側のバイナリは2つ進む//    base_cnt += 2;//}
private void data_umekomi_b(ref byte base1, ref byte base2, byte umekomi_byte)

*,,,
{   指定されたバイト数値にデータを埋め込む所
基礎画像の下位4ビットをカットする。
string base1_str = Convert.ToString(base1, 2).PadLeft(8, '0'); 8桁の二進数にする。
base1_str = base1_str.Substring(0, 4); 上位4ビットのみ取得。
string base2_str = Convert.ToString(base2, 2).PadLeft(8, '0'); 8桁の二進数にする。
base2_str = base2_str.Substring(0, 4); 上位4ビットのみ取得。
空いた下位4ビットにデータを埋め込む
string umekomi_str = Convert.ToString(umekomi_byte, 2).PadLeft(8, '0'); 8桁の二進数にする。
base1_str = base1_str + umekomi_str.Substring(0, 4); 下位4ビットに埋め込む
base1 = Convert.ToByte(base1_str, 2); 2進数からbyteに変換
base2_str = base2_str + umekomi_str.Substring(4, 4); 下位4ビットに埋め込む
base2 = Convert.ToByte(base2_str, 2); 2進数からbyteに変換
基礎側のバイナリは2つ進む
base_cnt += 2;
}
private byte data_toridashi_b(byte base1, byte base2)
{   指定されたバイト数値からデータを取り出す所
基礎画像の上位4ビットをカットする。
string base1_str = Convert.ToString(base1, 2).PadLeft(8, '0'); 8桁の二進数にする。
base1_str = base1_str.Substring(4, 4); 下位4ビットのみ取得。
string base2_str = Convert.ToString(base2, 2).PadLeft(8, '0'); 8桁の二進数にする。
base2_str = base2_str.Substring(4, 4); 下位4ビットのみ取得。
空いた下位4ビットにデータを埋め込む
string toridashi_str = base1_str + base2_str;
基礎側のバイナリは2つ進む
base_cnt += 2;
return Convert.ToByte(toridashi_str, 2); 2進数からbyteに変換
}


*else*{_vertices[i].x = 0.5f;_vertices[i].y = Mathf.Tan(rad) * _vertices[i].x;}
rad in right


*NamingStrategy = new DefaultNamingStrategy()
列挙型名をそのまま値とする

*JsonHandlerAttribute.DefaultJsonResultFactory = () => new JsonNetResult();
JsonHandlerAttributeの設定


*Console.WriteLine(b);
<-- "GetString2"と出力される

*namespace Tests2*{public class Test2{public static string GetString2(){return Test1.GetString("GetString2");}}}
using Tests;  <-- Program.csでglobal usingをしているのでコメントアウト(削除)しても大丈夫


*using System.Reflection;
これだけ先頭に追加。他はTestCodeクラス内


*viewer.ClipboardHandler += this.OnClipBoardChanged;
イベントハンドラを登録

*private void OnClipBoardChanged(object sender, ClipboardEventArgs args)*{Console.WriteLine(args.Text);}
クリップボードにテキストがコピーされると呼び出される


*string d = (string)b;
objectをstringにキャスト　dには"Hello"が入る(ボックス解除？)


*public override void OnBehaviourPlay (Playable playable, FrameData info) {if (!trackObj)return;// なんらかの処理}
各clip開始時に呼び出される

*}
なんらかの処理

*var playable = ScriptPlayable<TestBehaviour>.Create (graph, template);
TestBehaviourを作成

*public GameObject m_TrackBinding;
トラックに入っているGameObject

*public override void OnGraphStart (Playable playable) {if (!m_TrackBinding)return;// Trackの全clipの数を取得int inputCount = playable.GetInputCount ();for (int i = 0; i < inputCount; i++) {// 各clipのbehaviour取得ScriptPlayable<TestBehaviour> inputPlayable =(ScriptPlayable<TestBehaviour>) playable.GetInput (i);TestBehaviour input = inputPlayable.GetBehaviour ();// trackのGameObjectを渡すinput.trackObj = m_TrackBinding;}}
timelineの開始時 初期化

*int inputCount = playable.GetInputCount ();*for (int i = 0; i < inputCount; i++) {// 各clipのbehaviour取得ScriptPlayable<TestBehaviour> inputPlayable =(ScriptPlayable<TestBehaviour>) playable.GetInput (i);TestBehaviour input = inputPlayable.GetBehaviour ();// trackのGameObjectを渡すinput.trackObj = m_TrackBinding;}
Trackの全clipの数を取得

*ScriptPlayable<TestBehaviour> inputPlayable =
各clipのbehaviour取得

*input.trackObj = m_TrackBinding;
trackのGameObjectを渡す

*var playable = ScriptPlayable<TestMixerBehaviour>.Create (graph, inputCount);
TestMixerBehaviourを作成

*playable.GetBehaviour ().m_TrackBinding = trackBinding;
TrackにバインドされたGameObjectをTestMixerBehaviourに渡す


*private object lock_count2 = new object();
同じ


*fontDialog1.Font = richTextBox1.Font;
必要に応じて初期値を設定
初期のフォントを設定

*fontDialog1.Color = richTextBox1.ForeColor;
初期の色を設定

*fontDialog1.MaxSize = 15;
ユーザーが選択できるポイントサイズの最大値を設定する

*fontDialog1.FontMustExist = true;
存在しないフォントやスタイルをユーザーが選択すると
エラーメッセージを表示する

*fontDialog1.AllowVerticalFonts = false;
横書きフォントだけを表示する

*fontDialog1.ShowColor = true;
色を選択できるようにする

*fontDialog1.ShowEffects = true;
取り消し線、下線、テキストの色などのオプションを指定可能にする
デフォルトがTrueのため必要はない

*fontDialog1.FixedPitchOnly = false;
固定ピッチフォント以外も表示する
デフォルトがFalseのため必要はない

*fontDialog1.AllowVectorFonts = true;
ベクタ フォントを選択できるようにする
デフォルトがTrueのため必要はない

*private void tsbFontSetting_Click(object sender, EventArgs e)*{if (fontDialog1.ShowDialog() == DialogResult.OK){//OKボタンが押されたら、フォントを設定するrichTextBox1.SelectionFont = fontDialog1.Font;richTextBox1.SelectionColor = fontDialog1.Color;}}
フォントダイアログボックス呼び出しボタン

*richTextBox1.SelectionFont = fontDialog1.Font;
OKボタンが押されたら、フォントを設定する

*private void tsbIncreaseFontSize_Click(object sender, EventArgs e)*{var currentSize = richTextBox1.SelectionFont.Size;currentSize += 2.0F;richTextBox1.SelectionFont = new Font(richTextBox1.SelectionFont.Name,currentSize,richTextBox1.SelectionFont.Style,richTextBox1.SelectionFont.Unit);}
フォントを大きくするボタン

*private void tsbDecreaseFontSize_Click(object sender, EventArgs e)*{var currentSize = richTextBox1.SelectionFont.Size;currentSize -= 1;richTextBox1.SelectionFont = new Font(richTextBox1.SelectionFont.Name,currentSize,richTextBox1.SelectionFont.Style);}
フォントを小さくするボタン

*private void tsbBold_Click(object sender, EventArgs e)*{richTextBox1.SelectionFont = new Font(richTextBox1.SelectionFont.FontFamily,richTextBox1.SelectionFont.Size,richTextBox1.SelectionFont.Style ^ FontStyle.Bold);}
フォントを太字にするボタン

*private void tsbItalic_Click(object sender, EventArgs e)*{richTextBox1.SelectionFont = new Font(richTextBox1.SelectionFont.FontFamily,richTextBox1.SelectionFont.Size,richTextBox1.SelectionFont.Style ^ FontStyle.Italic);}
フォントを斜字にするボタン

*private void tsbUnderline_Click(object sender, EventArgs e)*{richTextBox1.SelectionFont = new Font(richTextBox1.SelectionFont.FontFamily,richTextBox1.SelectionFont.Size,richTextBox1.SelectionFont.Style ^ FontStyle.Underline);}
テキストに下線を引くボタン

*private void tsbStrikeout_Click(object sender, EventArgs e)*{richTextBox1.SelectionFont = new Font(richTextBox1.SelectionFont.FontFamily,richTextBox1.SelectionFont.Size,richTextBox1.SelectionFont.Style ^ FontStyle.Strikeout);}
テキストに取り消し線を付けるボタン

*private void tsbTextLeft_Click(object sender, EventArgs e)*{richTextBox1.SelectionAlignment = HorizontalAlignment.Left;}
左寄せボタン

*private void tsbTextCenter_Click(object sender, EventArgs e)*{richTextBox1.SelectionAlignment = HorizontalAlignment.Center;}
中央寄せボタン

*private void tsbTextRight_Click(object sender, EventArgs e)*{richTextBox1.SelectionAlignment = HorizontalAlignment.Right;}
右寄せボタン

*private void tsbBullet_Click(object sender, EventArgs e)*{richTextBox1.SelectionBullet = !richTextBox1.SelectionBullet;}
箇条書きボタン

*private void tsbIndent_Click(object sender, EventArgs e)*{richTextBox1.SelectionIndent += 16;}
右インデントボタン

*private void tsbOutdent_Click(object sender, EventArgs e)*{richTextBox1.SelectionIndent -= 16;}
左インデントボタン


*Destroy(gameObject);
オブジェクトを消す


*return str;
メソッド名はReverseであるが基本クラス制約の機能を

*}
確認するためこのクラスでは反転させず、パラメータをそのまま戻す

*class Test<T> where T : ReverseClass*{T obj;public Test(T o){obj = o;}public void ShowReverse(string str){String revStr = obj.ReverseStr(str);Console.WriteLine(revStr);Console.WriteLine();}}
ReverseClassで基本クラス制約をかける


*MapFridge = new Dictionary<string,List<string>>();*MapFridge.Add("野菜",new List<string>(){"きゅうり","トマト","玉ねぎ"});
ローカルで初期化


*Vector2d latLon = new Vector2d(37.784179f, -122.401583f);
初期位置とzoomレベル


*}
End class Program


*Log(msg + "_");
引数を処理させるためにちょいと加工


*if (mi == null) {
Stringクラスを引数とするRunメソッドがあるかをチェック


*string str1 = Result;
ビジネスロジック
string str1 = Result.Replace("ω", "　");
str1 = str1.Replace("Ω", "\t");


*public int ID { get; set; }
public string Title { get; set; }


*selectedToggleName.Subscribe(x => Debug.Log("Changed:" + x));
selectedLabelが変化した瞬間を検知する


*Task.Run(() => CheckDevice());
デバイスをチェック


*readOnlyArray[1] = "second update";
エラー発生

*Console.ReadKey();
first , second , third => stringValuesVeforeCloneの変更が反映されない

*public int Compare(Object x, Object y)*{if (x.ToString().Length < y.ToString().Length){return -1;}else if (x.ToString().Length > y.ToString().Length){return 1;}else{return 0;}}
Call CaseInsensitiveComparer.Compare with the parameters reversed.


*}
ネットワークを経由するなら下の行を入れて反転させる必要がある
return (uint)IPAddress.NetworkToHostOrder(networkOrder);


*DMatch[] good_matches = new DMatch[good_match_length];
閾値以下の要素数で定義

*int j = 0;
good_matchesに格納していく


*Debug.Log(enemyNameGenerator.GetUniqueItem());
null

*enemyNameGenerator.ResetUsageHistory();
履歴を削除

*Debug.Log(enemyNameGenerator.GetUniqueItem());
再び取り出せるようになる


*standardOutput.AutoFlush = true;
StreamWriter が呼び出されるたびに、Write(Char) によって基になるストリームに対するバッファーをフラッシュするかどうかを示す値を取得または設定します。

*Console.WriteLine("標準出力がファイルからディスプレイに戻る。");
ディスプレイに出力


*var WS_EX_TRANSPARENT = 0x20;
コントロールの透明化
※親コントロール描画時に、本コントロールのRegion内の領域も描画してくれるようになる
※兄弟関係による最前面、最背面の概念がなくなる
この拡張コントロールと他のコントロールを兄弟関係で重ねると、重ねた領域の描画が後勝ちになる
※ControlStyles.OptimizedDoubleBufferは透明度をサポートしていないため、これと併用するとRegion内を黒で塗りつぶされる
よってバッファリングできないのでちらつくようになる。また、処理毎に描画するので動作が重くなる

*SetStyle(ControlStyles.Opaque, true);
OnPaintBackgroundを無効化

*g.SmoothingMode = SmoothingMode.AntiAlias;
アンチエイリアスを掛ける

*g.FillPath(new SolidBrush(BackColor), GetGraphicsPath(true));
バック

*if(DisplayBorder)*g.DrawPath(new Pen(new SolidBrush(BorderColor)), GetGraphicsPath(true));
ボーダー

*var displayRect = new Rectangle(0 + Radius / 4, 0 + Radius / 4, Width - (Radius / 2), Height - (Radius / 2));*var drawFormat = new StringFormat {Alignment = StringAlignment.Center,LineAlignment = StringAlignment.Center};
フォント

*diameter -= forPaint ? 2 : 0;*// 角丸
シュリンクすると、縦横-2pxなので、直径も-2px

*gp.StartFigure();
角丸

*var shrink = forPaint ? 1 : 0;*// 四角
何故か右辺と下辺にボーダーが付かないので-1pxしとく

*gp.AddRectangle(new Rectangle(0, 0, Width - shrink, Height - shrink));
四角


*Console.WriteLine($"typeof(int?) = {typeof(int?)}");
typeof(int?)はNullable<int>を返す

*Console.WriteLine($"nullableThree type is {nullableThree.GetType()}");
Nullable<T>.GetType()は未定義のため、object.GetType()が呼ばれる。(ボックス化)
その際HasValue == trueの場合はT型に、falseの場合はnullにボックス化される。(Nullable<int>にはボックス化されない)
int型にボックス化されるため、intを返す

*Console.WriteLine(nullValue.GetType());
nullにボックス化されるため、NullReferenceExceptionの例外発生

*Console.WriteLine($"nullableThree is int = {nullableThree is int}");
is演算子も同様。n is intとn is int?は同じ結果を返す(Nullable<int>に変えても同様)

*Console.WriteLine($"notNullTen is int? = {notNullTen is int?}");
int型の変数に対するn is int?に至っては「常にtrueを返すけどいい？」という注釈が出る

*Console.WriteLine($"IsNullableType(notNullTen) = {IsNullableType(notNullTen)}");
Nullable<int>とintの区別にはNullable.GetUnderlyingType(System名前空間)を使用する

*Console.WriteLine(typeof(Foo).GetProperty(nameof(Foo.Value)).PropertyType);
リフレクションでプロパティやフィールドの型を取得した場合はNullable<T>になる


*namespace UnoSampleApp*{/// <summary>/// An empty page that can be used on its own or navigated to within a Frame./// </summary>public sealed partial class MainPage : Page{public static readonly DependencyProperty IssueItemProperty =DependencyProperty.Register(nameof(Item), typeof(IssueItem), typeof(MainPage), new PropertyMetadata(default(IssueItem)));public MainPage(){this.InitializeComponent();}public IssueItem Item{get => (IssueItem)GetValue(IssueItemProperty);set => SetValue(IssueItemProperty, value);}public IssueStatus[] StatusList => new[]{IssueStatus.Icebox,IssueStatus.Planned,IssueStatus.WIP,IssueStatus.Done,IssueStatus.Removed};public IssueType[] IssueTypeList => new[]{IssueType.Bug,IssueType.Feature,IssueType.Issue,IssueType.Task};protected override void OnNavigatedTo(NavigationEventArgs e){Item = new IssueItem{Id = 1232,Title = "Getting Started",Description = @"Create a page to enter Issues that we need to work on.## Acceptance Criteria- Display the issue Id- Provide an ability to select the issue Type (i.e. Bug, Feature, etc)- Include an Issue Title- Include a full issue description with support for Markdown- Include an issue effort- Include an ability for a developer to update the Status (i.e Icebox, WIP, etc)## Additional CommentsWe would like to have a visual indicator for the type of issue as well as something to visualize the effort involved",Effort = 3,Status = IssueStatus.WIP,Type = IssueType.Feature,CreatedAt = new DateTimeOffset(2019, 04, 03, 08, 0, 0, TimeSpan.FromHours(-8)),StartedAt = new DateTimeOffset(2019, 04, 30, 08, 0, 0, TimeSpan.FromHours(-8))};}// Sets the time when we Complete or Start an issue.private void StatusPicker_SelectionChanged(object sender, SelectionChangedEventArgs args){switch (Item.Status){case IssueStatus.Removed:case IssueStatus.Done:if (Item.CompletedAt is null)Item.CompletedAt = DateTimeOffset.Now.ToLocalTime();break;case IssueStatus.WIP:if (Item.StartedAt is null)Item.StartedAt = DateTimeOffset.Now.ToLocalTime();break;default:Item.StartedAt = null;Item.CompletedAt = null;break;}}// Provides a unique color based on the type of Issueprivate void IssueType_SelectionChanged(object sender, SelectionChangedEventArgs args){var color = Colors.Red;switch (IssueTypeBox.SelectedItem){case IssueType.Feature:color = Colors.Green;break;case IssueType.Issue:color = Colors.Blue;break;case IssueType.Task:color = Colors.Yellow;break;}IssueTypeIndicator.Background = new SolidColorBrush(color);}}}
The Blank Page item template is documented at http:go.microsoft.com/fwlink/?LinkId=402352&clcid=0x409

*private void StatusPicker_SelectionChanged(object sender, SelectionChangedEventArgs args)*{switch (Item.Status){case IssueStatus.Removed:case IssueStatus.Done:if (Item.CompletedAt is null)Item.CompletedAt = DateTimeOffset.Now.ToLocalTime();break;case IssueStatus.WIP:if (Item.StartedAt is null)Item.StartedAt = DateTimeOffset.Now.ToLocalTime();break;default:Item.StartedAt = null;Item.CompletedAt = null;break;}}
Sets the time when we Complete or Start an issue.

*private void IssueType_SelectionChanged(object sender, SelectionChangedEventArgs args)*{var color = Colors.Red;switch (IssueTypeBox.SelectedItem){case IssueType.Feature:color = Colors.Green;break;case IssueType.Issue:color = Colors.Blue;break;case IssueType.Task:color = Colors.Yellow;break;}IssueTypeIndicator.Background = new SolidColorBrush(color);}
Provides a unique color based on the type of Issue


*var pa = (System.Windows.Controls.Panel)cc.Content;
Gridである場合もあるかもしれませんね。

*var button = (System.Windows.Controls.Button)children[0];
なお、確実にChildrenの第1要素がButtonである場合は以下のように取得できています。


*setting.VideoDeviceId = di.Id;
カメラ選択

*var vcon = mediaCapture.VideoDeviceController;
調整しないと暗い場合があるので

*System.IO.Stream stream = System.IO.WindowsRuntimeStreamExtensions.AsStream(randomAccessStream);
ビットマップにして表示


*var result = contexts.PetModels.Where(x=>x.Id==1).Single();*Console.WriteLine("result name:{0}", result.Name);
var result = contexts.PetModels.Single(y=>y.Id==1);

*var result = contexts.PetModels.Where(x=>x.Id==1).First();*Console.WriteLine("result name:{0}", result.Name);
var result = contexts.PetModels.First(y=>y.Id==1);


*void Update()*{}
Update is called once per frame

*void Update()*{if (Input.GetKey(KeyCode.LeftArrow)){this.transform.position += Vector3.left * speed * Time.deltaTime;}if (Input.GetKey(KeyCode.RightArrow)){this.transform.position += Vector3.right * speed * Time.deltaTime;}}
Update is called once per frame

*void Start()*{}
Start is called before the first frame update

*void Update()*{}
Update is called once per frame


*httpClient.DeleteAsync(new URI("http:
samplebucket.s3.amazonaws.com"));


*public override void startCUI()*{System.Console.WriteLine("start sample");/* sample code, but can't run with .net 2.0 , so commented outFunc<string, bool> handleFiles = (string path) => {Console.WriteLine(path);return true;};IEnumerable<string> results =BuildAndRunUtil.ProcessRecurcively("c:\\", "*.txt", handleFiles);*/System.Console.WriteLine("finish sample");}
--------------------------------------------------


*do { b = st.ReadByte(); } while (IsWhiteSpace(b));
skip whitespaces

*ArrayAppend(ref ret, (byte)(upperNibble<<4));
奇数桁で終わっている場合は末尾に'0'を補填する( = (上位nibble<<4) + 0)


*pg.WriteIndirectObj(5,"<<
Font <<F0 <<Type Font BaseFont Times-Roman Subtype Type1 >> >> >>");  [5] Resources


*//{//janken = Console.ReadLine();janken = jankMeNow.ToString();if (!(janken.Equals("0") || janken.Equals("1") || janken.Equals("2"))){Console.WriteLine("0か1か2で入れてください。");loopFlg = true;}else{loopFlg = false;}//}
while (loopFlg)


*modalViewController.ChangeText("hogehoge");
ChangeTextメソッド自体はprivateじゃないので呼び出せる


*public static void Sort(Dictionary<GameObject,float> itemTable)
取得したオブジェクトと距離のデータを距離が近い順でソートするメソッド


*position.y += adjast;
Rayを飛ばす初期位置を調整する

*if (raycastHit2D.Length == 0)*return false;
何も検知できなかった場合、処理を中断し、falseを返す


*var value = callbackContext.ReadValue<float>();
Buttonの入力はfloat

*_jumpInput.Enable();
Enable()で有効化しないと動作しない

*public class ActionMapSample : MonoBehaviour, SampleControls.ISampleMapsActions*{private SampleControls.SampleMapsActions _sampleMapsActions = default;private void Awake(){// SampleControlsに登録したActionMapを生成ます。_sampleMapsActions = new SampleControls.SampleMapsActions(new SampleControls());// SampleControls.ISampleMapsActionsが実装されたクラスをSetCallbacksに指定します。_sampleMapsActions.SetCallbacks(this);}// SampleControls.ISampleMapsActionsによって定義されたMoveActionのコールバックpublic void OnMoveAction(InputAction.CallbackContext callbackContext){var value = callbackContext.ReadValue<Vector2>();Debug.Log($"position {value.x},{value.y}");}// SampleControls.ISampleMapsActionsによって定義されたJumpActionのコールバックpublic void OnJumpAction(InputAction.CallbackContext callbackContext){var value = callbackContext.ReadValue<float>();if (value > 0){Debug.Log("On Jump.");}}private void OnEnable(){// 忘れずEnabl(）_sampleMapsActions.Enable();}private void OnDestroy(){// こっちはDisposeではなくDisable(）_sampleMapsActions.Disable();}}
生成されたクラスはI[ActionMap]インターフェスを持っているので、これを実装します。

*_sampleMapsActions = new SampleControls.SampleMapsActions(new SampleControls());
SampleControlsに登録したActionMapを生成ます。

*_sampleMapsActions.SetCallbacks(this);
SampleControls.ISampleMapsActionsが実装されたクラスをSetCallbacksに指定します。

*public void OnMoveAction(InputAction.CallbackContext callbackContext)*{var value = callbackContext.ReadValue<Vector2>();Debug.Log($"position {value.x},{value.y}");}
SampleControls.ISampleMapsActionsによって定義されたMoveActionのコールバック

*public void OnJumpAction(InputAction.CallbackContext callbackContext)*{var value = callbackContext.ReadValue<float>();if (value > 0){Debug.Log("On Jump.");}}
SampleControls.ISampleMapsActionsによって定義されたJumpActionのコールバック

*_sampleMapsActions.Enable();
忘れずEnabl(）

*_sampleMapsActions.Disable();
こっちはDisposeではなくDisable(）


*Hoge hoge;
ローカル変数


*data[4 * (i + j * width) + 3] = c.Item1;
alpha

*WriteableBitmap bitmap = new WriteableBitmap(width, height);
サーマル画像を作成

*this.MLX90640_DumpEE();
EEPROM読み出し


*listener.Prefixes.Add("http:
192.168.0.16:80");

*string url = "ウェブフック用URL";
POSTする対象のURL

*var json = "{ \"content\" : \"hoge\"}";
POSTメソッドで渡すパラメータ


*string str1 = Result
文字列を置換するようなﾋﾞｼﾞﾈｽﾛｼﾞｯｸ（もしあれば）
string str1 = Result.Replace("ω", "　");
str1 = str1.Replace("Ω", "\t");


*public SelectList Genres { get; set; }
Requires using Microsoft.AspNetCore.Mvc.Rendering;

*var movies = _context.Movies as IQueryable<Movie>;*if (!string.IsNullOrEmpty(SearchString)) {movies = movies.Where(s => s.Title.Contains(SearchString));}
Moviesをフィルタリング

*var genreList = await _context.Movies.OrderBy(m => m.Genre)
ジャンル一覧を生成


*var html = wc.DownloadString( $@"https:
www.nike.comjp" ); OK!!!


*Dispose();
-> <>m__Finally1() -> <>7__wrap1.Dispose()


*_mediaPlayer.URL = @"sound.wav";
mp3も使用可能


*Function2(dataEnumerator);
別の関数でもリストの値を使いたい。


*if (aCube.TargetPosition.x > 3.0f) aCube.TargetPosition.x = 0.0f;
ある程度右へ行ったら最初の位置へ

*aCube.TargetPosition = bCube.transform.localPosition;
var aPos = aCube.TargetPosition; わざわざ1回変数に入れるの無駄に見えるので
var bPos = bCube.TargetPosition;
bCube.TargetPosition = aCube.transform.localPosition; 入れ替えたいキューブの位置を直接指定


*string hashed = string.Concat(hash.Select(b => $"{b:x2}"));
-> 93541bd68ccf06f3d4f9cf56a3ca415f1d2d315f3f672ecec9f52b0c7c3ad9fc


*using (var context = new NorthwindContext()){トランザクション開始using (var transaction = context.Database.BeginTransaction()){1つ目の SaveChanges()var product = await context.Products.SingleAsync(p => p.ProductID == 1).ConfigureAwait(false);
コンテキスト

*using (var transaction = context.Database.BeginTransaction()){1つ目の SaveChanges()var product = await context.Products.SingleAsync(p => p.ProductID == 1).ConfigureAwait(false);
トランザクション開始

*var product = await context.Products.SingleAsync(p => p.ProductID == 1).ConfigureAwait(false);
1つ目の SaveChanges()

*var employee = await context.Employees.SingleAsync(e => e.EmployeeID == 1).ConfigureAwait(false);
2つ目の SaveChanges()

*transaction.Commit();
まとめてコミット

*using (var sqlConnection = new SqlConnection(NorthwindContext.GetConnectionString())){あらかじめ接続を開いておく。sqlConnection.Open();
接続準備

*sqlConnection.Open();
あらかじめ接続を開いておく。

*using (var transaction = sqlConnection.BeginTransaction()){1つ目のコンテキストで保存using (var context = new NorthwindContext(sqlConnection, false)){context.Database.UseTransaction(transaction);
トランザクション開始

*using (var context = new NorthwindContext(sqlConnection, false)){context.Database.UseTransaction(transaction);
1つ目のコンテキストで保存

*using (var context = new NorthwindContext(sqlConnection, false)){context.Database.UseTransaction(transaction);
2つ目のコンテキストで保存

*transaction.Commit();
まとめてコミット

*public class NorthwindContext : DbContext*{:/// <summary>/// コンストラクタ。/// </summary>/// <param name="existingConnection">コンテキストで使用する接続。</param>/// <param name="contextOwnsConnection">false を指定すると、コンテキストが Dispose されたときに接続を Dispose しない。</param>public NorthwindContext(DbConnection existingConnection, bool contextOwnsConnection): base(existingConnection, contextOwnsConnection){}/// <summary>/// 接続文字列を取得する。/// </summary>/// <returns></returns>public static string GetConnectionString(){using (var context = new NorthwindContext()){return context.Database.Connection.ConnectionString;}}:}
コンテキストクラス


*is_active = true;
初期化時は点灯状態

*count = cycle - 5;
初回サイクルを短めに設定

*delay(1000);
1秒間隔

*analogWrite(LED_PIN, 250);
点灯

*count = 0;
再カウント


*backgroundWorker1.CancelAsync();
スレッドの終了を待機

*backgroundWorker1.CancelAsync();
スレッドの終了を待機


*arcfour.Encrypt(ms, msDest, buf.Length);
decrypt

*static string GetPreviewData(FileStream fs)
endobjが見つかるまでのデータをASCIIにして出力。(単語単位では検索してないのでよくない)
可読でない文字は ? に置き換える。
stream...endstreamはそのまま出力。

*pos = 0;
たまたま "endobj" を構成する文字がすべて別の文字なので、検索アンマッチ時は単純に pos=0に戻しているだけでよいが、
"aab"とかだと "aaab"から検索していると"aa"のあと"ab"から検索が始まってとりこぼすおそれがある。


*MemoryStream src  = new MemoryStream(plain, false);
第2引数=falseでreadonly


*return await cs.Task;
この時点でcs.Task.IsCompletedはTrue


*public static readonly GenbaCatType ItsOkIThink = new ExtendedGenbaCatType(2);
それで大丈夫だと思います。

*}
GenbaCatType dog = new GenbaCatType(); できません
GenbaCatType monkey; これはできちゃう(中身はnull)
Console.WriteLine(catNoProblem == catOk); False
Console.WriteLine(catNoProblem == GenbaCatType.NoProblem); True


*string action = "Item";
Attack,Defense,Magic,Item,Escapeのどれかを""の中に入れる


*public GameObject PlayerModel;
プレイヤーのモデルは主にchildのところにいますので、ご忘れないように追加しましょう…


*var roots = TreeBuilder.Rebuild(items, item => new Node(item));
木構造の構築
ITreeItem を実装するクラスのリストと、 ITreeItem から ITreeNode を生成するメソッドを渡す。
渡す ITreeItem のリストは、Left順にソートしてある必要がある。
木構造が構築されて、ルートノードのリストが返ってくる。

*TreeBuilder.Update(roots, node => node.Item);
木構造を表示したり、何らかの操作を加える
Left、Rightの更新
ルートノードのリストと、ITreeNode から ITreeItem を取得するメソッドを渡す。
ITreeItem はnodeの中に持っておくと便利。もしくはディクショナリにでもしておく。


*void DoIt()*{while(true){while(true){// ローカル変数をそのまま参照できる！counter++;// Return文でローカル巻子を抜ける ＝ 多重ループを抜けるif(counter >= 10) return;}}}
多重ループをローカル関数で囲う

*counter++;
ローカル変数をそのまま参照できる！

*if(counter >= 10) return;*}
Return文でローカル巻子を抜ける ＝ 多重ループを抜ける

*DoIt();
ローカル関数を実行

*// 結果*Console.WriteLine($"counter={counter}");
do some other things here

*Console.WriteLine($"counter={counter}");
結果


*string userInputPassword = "";
ユーザが入力したパスワード

*string correctPassword = "3333";
正解のパスワード

*public void InputKey(int number)*{}
パスワードの入力

*void CheckPass()*{if (correctPassword == userInputPassword){// 正解！}else{// 不正解}}
正解を確認する

*}
正解！

*}
不正解


*return;
DB has been seeded


*LineSeries.StrokeThickness = 2;
線の太さ

*LineSeries.Points.Add(new DataPoint(1.0, 10.0 + 10.0 * i));
点を追加

*Model.Series.Add(LineSeries);
線グラフをモデルに追加

*Model.InvalidatePlot(true);
セットした内容を反映させる

*public class OxyColorToSolidColorBrushConverter : IValueConverter*{public object Convert(object value, Type targetType, object parameter, CultureInfo culture){if (value is LineSeries ls){var oc = ls.Color;return new SolidColorBrush(Color.FromArgb(oc.A, oc.R, oc.G, oc.B));}return null;}public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture){throw new NotImplementedException();}}
OxyColorから通常のColorのBrushに戻すコンバータ。


*using (var certificate = await GetCertificateAsync("https:
qiita.com"))


*public class Callee
呼び出される側のスクリプト. GameObjectにアタッチしない.
StartやUpdateを使わないため, MonoBehaviourは不要.
他のスクリプトから読み込むため, publicを付ける.

*public int exampleNumber = 17;
呼び出される変数

*public void Sup()*{Debug.Log("Good!");}
呼び出されるメソッド

*public class UsingOtherComponents : MonoBehaviour*{void Start(){// Another.csのCalleeのインスタンス化Callee _Callee = new Callee();// 変数の呼び出し.int _exampleNumber = _Callee.exampleNumber;Debug.Log("Eample number is " + _exampleNumber);// メソッドの呼び出し._Callee.Sup();}}
呼び出す側のスクリプト. GameObjectにアタッチする.

*Callee _Callee = new Callee();
Another.csのCalleeのインスタンス化

*int _exampleNumber = _Callee.exampleNumber;
変数の呼び出し.

*_Callee.Sup();
メソッドの呼び出し.


*private static Uri DevelopmentServerEndpoint { get; } = new Uri($"http:
localhost:{Port}");

*public void ConfigureServices(IServiceCollection services)*{services.AddControllers();// connect vue app - middlewareservices.AddSpaStaticFiles(options => options.RootPath = "client-app/dist");}
This method gets called by the runtime. Use this method to add services to the container.

*public void Configure(IApplicationBuilder app, IWebHostEnvironment env)*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.app.UseHsts();}app.UseHttpsRedirection();app.UseRouting();app.UseAuthorization();app.UseEndpoints(endpoints =>{endpoints.MapControllers();});// use middleware and launch server for Vueapp.UseSpaStaticFiles();app.UseSpa(spa =>{spa.Options.SourcePath = "client-app";if (env.IsDevelopment()){spa.UseVueDevelopmentServer();}});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.


*namespace Org.BouncyCastle.Crypto.Tls*{public enum CipherSuitesEnum{TLS_NULL_WITH_NULL_NULL = 0x0000,TLS_RSA_WITH_NULL_MD5 = 0x0001,TLS_RSA_WITH_NULL_SHA = 0x0002,TLS_RSA_EXPORT_WITH_RC4_40_MD5 = 0x0003,TLS_RSA_WITH_RC4_128_MD5 = 0x0004,TLS_RSA_WITH_RC4_128_SHA = 0x0005,TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = 0x0006,TLS_RSA_WITH_IDEA_CBC_SHA = 0x0007,TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x0008,TLS_RSA_WITH_DES_CBC_SHA = 0x0009,TLS_RSA_WITH_3DES_EDE_CBC_SHA = 0x000A,TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = 0x000B,TLS_DH_DSS_WITH_DES_CBC_SHA = 0x000C,TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = 0x000D,TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x000E,TLS_DH_RSA_WITH_DES_CBC_SHA = 0x000F,TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = 0x0010,TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = 0x0011,TLS_DHE_DSS_WITH_DES_CBC_SHA = 0x0012,TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 0x0013,TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x0014,TLS_DHE_RSA_WITH_DES_CBC_SHA = 0x0015,TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 0x0016,TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = 0x0017,TLS_DH_anon_WITH_RC4_128_MD5 = 0x0018,TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = 0x0019,TLS_DH_anon_WITH_DES_CBC_SHA = 0x001A,TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = 0x001B,/** Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are reserved to avoid* collision with Fortezza-based cipher suites in SSL 3.*//** RFC 3268*/TLS_RSA_WITH_AES_128_CBC_SHA = 0x002F,TLS_DH_DSS_WITH_AES_128_CBC_SHA = 0x0030,TLS_DH_RSA_WITH_AES_128_CBC_SHA = 0x0031,TLS_DHE_DSS_WITH_AES_128_CBC_SHA = 0x0032,TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 0x0033,TLS_DH_anon_WITH_AES_128_CBC_SHA = 0x0034,TLS_RSA_WITH_AES_256_CBC_SHA = 0x0035,TLS_DH_DSS_WITH_AES_256_CBC_SHA = 0x0036,TLS_DH_RSA_WITH_AES_256_CBC_SHA = 0x0037,TLS_DHE_DSS_WITH_AES_256_CBC_SHA = 0x0038,TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 0x0039,TLS_DH_anon_WITH_AES_256_CBC_SHA = 0x003A,/** RFC 5932*/TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0041,TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = 0x0042,TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0043,TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = 0x0044,TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0045,TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = 0x0046,TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0084,TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = 0x0085,TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0086,TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = 0x0087,TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0088,TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = 0x0089,TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BA,TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BB,TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BC,TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BD,TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BE,TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BF,TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C0,TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C1,TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C2,TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C3,TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C4,TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C5,/** RFC 4162*/TLS_RSA_WITH_SEED_CBC_SHA = 0x0096,TLS_DH_DSS_WITH_SEED_CBC_SHA = 0x0097,TLS_DH_RSA_WITH_SEED_CBC_SHA = 0x0098,TLS_DHE_DSS_WITH_SEED_CBC_SHA = 0x0099,TLS_DHE_RSA_WITH_SEED_CBC_SHA = 0x009A,TLS_DH_anon_WITH_SEED_CBC_SHA = 0x009B,/** RFC 4279*/TLS_PSK_WITH_RC4_128_SHA = 0x008A,TLS_PSK_WITH_3DES_EDE_CBC_SHA = 0x008B,TLS_PSK_WITH_AES_128_CBC_SHA = 0x008C,TLS_PSK_WITH_AES_256_CBC_SHA = 0x008D,TLS_DHE_PSK_WITH_RC4_128_SHA = 0x008E,TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = 0x008F,TLS_DHE_PSK_WITH_AES_128_CBC_SHA = 0x0090,TLS_DHE_PSK_WITH_AES_256_CBC_SHA = 0x0091,TLS_RSA_PSK_WITH_RC4_128_SHA = 0x0092,TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = 0x0093,TLS_RSA_PSK_WITH_AES_128_CBC_SHA = 0x0094,TLS_RSA_PSK_WITH_AES_256_CBC_SHA = 0x0095,/** RFC 4492*/TLS_ECDH_ECDSA_WITH_NULL_SHA = 0xC001,TLS_ECDH_ECDSA_WITH_RC4_128_SHA = 0xC002,TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC003,TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 0xC004,TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 0xC005,TLS_ECDHE_ECDSA_WITH_NULL_SHA = 0xC006,TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = 0xC007,TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC008,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 0xC009,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 0xC00A,TLS_ECDH_RSA_WITH_NULL_SHA = 0xC00B,TLS_ECDH_RSA_WITH_RC4_128_SHA = 0xC00C,TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = 0xC00D,TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 0xC00E,TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 0xC00F,TLS_ECDHE_RSA_WITH_NULL_SHA = 0xC010,TLS_ECDHE_RSA_WITH_RC4_128_SHA = 0xC011,TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = 0xC012,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 0xC013,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 0xC014,TLS_ECDH_anon_WITH_NULL_SHA = 0xC015,TLS_ECDH_anon_WITH_RC4_128_SHA = 0xC016,TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = 0xC017,TLS_ECDH_anon_WITH_AES_128_CBC_SHA = 0xC018,TLS_ECDH_anon_WITH_AES_256_CBC_SHA = 0xC019,/** RFC 4785*/TLS_PSK_WITH_NULL_SHA = 0x002C,TLS_DHE_PSK_WITH_NULL_SHA = 0x002D,TLS_RSA_PSK_WITH_NULL_SHA = 0x002E,/** RFC 5054*/TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = 0xC01A,TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = 0xC01B,TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = 0xC01C,TLS_SRP_SHA_WITH_AES_128_CBC_SHA = 0xC01D,TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = 0xC01E,TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = 0xC01F,TLS_SRP_SHA_WITH_AES_256_CBC_SHA = 0xC020,TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = 0xC021,TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = 0xC022,/** RFC 5246*/TLS_RSA_WITH_NULL_SHA256 = 0x003B,TLS_RSA_WITH_AES_128_CBC_SHA256 = 0x003C,TLS_RSA_WITH_AES_256_CBC_SHA256 = 0x003D,TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = 0x003E,TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = 0x003F,TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = 0x0040,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 0x0067,TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = 0x0068,TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = 0x0069,TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = 0x006A,TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 0x006B,TLS_DH_anon_WITH_AES_128_CBC_SHA256 = 0x006C,TLS_DH_anon_WITH_AES_256_CBC_SHA256 = 0x006D,/** RFC 5288*/TLS_RSA_WITH_AES_128_GCM_SHA256 = 0x009C,TLS_RSA_WITH_AES_256_GCM_SHA384 = 0x009D,TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = 0x009E,TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = 0x009F,TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = 0x00A0,TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = 0x00A1,TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = 0x00A2,TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = 0x00A3,TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = 0x00A4,TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = 0x00A5,TLS_DH_anon_WITH_AES_128_GCM_SHA256 = 0x00A6,TLS_DH_anon_WITH_AES_256_GCM_SHA384 = 0x00A7,/** RFC 5289*/TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC023,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC024,TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC025,TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC026,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 0xC027,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 0xC028,TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 0xC029,TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 0xC02A,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02B,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02C,TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02D,TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02E,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xC02F,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xC030,TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 0xC031,TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 0xC032,/** RFC 5487*/TLS_PSK_WITH_AES_128_GCM_SHA256 = 0x00A8,TLS_PSK_WITH_AES_256_GCM_SHA384 = 0x00A9,TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = 0x00AA,TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = 0x00AB,TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = 0x00AC,TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = 0x00AD,TLS_PSK_WITH_AES_128_CBC_SHA256 = 0x00AE,TLS_PSK_WITH_AES_256_CBC_SHA384 = 0x00AF,TLS_PSK_WITH_NULL_SHA256 = 0x00B0,TLS_PSK_WITH_NULL_SHA384 = 0x00B1,TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = 0x00B2,TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = 0x00B3,TLS_DHE_PSK_WITH_NULL_SHA256 = 0x00B4,TLS_DHE_PSK_WITH_NULL_SHA384 = 0x00B5,TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = 0x00B6,TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = 0x00B7,TLS_RSA_PSK_WITH_NULL_SHA256 = 0x00B8,TLS_RSA_PSK_WITH_NULL_SHA384 = 0x00B9,/** RFC 5489*/TLS_ECDHE_PSK_WITH_RC4_128_SHA = 0xC033,TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = 0xC034,TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = 0xC035,TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = 0xC036,TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = 0xC037,TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = 0xC038,TLS_ECDHE_PSK_WITH_NULL_SHA = 0xC039,TLS_ECDHE_PSK_WITH_NULL_SHA256 = 0xC03A,TLS_ECDHE_PSK_WITH_NULL_SHA384 = 0xC03B,/** RFC 5746*/TLS_EMPTY_RENEGOTIATION_INFO_SCSV = 0x00FF,/** RFC 6367*/TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC072,TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC073,TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC074,TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC075,TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC076,TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC077,TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC078,TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC079,TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC07A,TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC07B,TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC07C,TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC07D,TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC07E,TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC07F,TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = 0xC080,TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = 0xC081,TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = 0xC082,TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = 0xC083,TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = 0xC084,TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = 0xC085,TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC086,TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC087,TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC088,TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC089,TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC08A,TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC08B,TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC08C,TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC08D,TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 0xC08E,TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 0xC08F,TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 0xC090,TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 0xC091,TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 0xC092,TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 0xC093,TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC094,TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC095,TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC096,TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC097,TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC098,TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC099,TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC09A,TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC09B,/** RFC 6655*/TLS_RSA_WITH_AES_128_CCM = 0xC09C,TLS_RSA_WITH_AES_256_CCM = 0xC09D,TLS_DHE_RSA_WITH_AES_128_CCM = 0xC09E,TLS_DHE_RSA_WITH_AES_256_CCM = 0xC09F,TLS_RSA_WITH_AES_128_CCM_8 = 0xC0A0,TLS_RSA_WITH_AES_256_CCM_8 = 0xC0A1,TLS_DHE_RSA_WITH_AES_128_CCM_8 = 0xC0A2,TLS_DHE_RSA_WITH_AES_256_CCM_8 = 0xC0A3,TLS_PSK_WITH_AES_128_CCM = 0xC0A4,TLS_PSK_WITH_AES_256_CCM = 0xC0A5,TLS_DHE_PSK_WITH_AES_128_CCM = 0xC0A6,TLS_DHE_PSK_WITH_AES_256_CCM = 0xC0A7,TLS_PSK_WITH_AES_128_CCM_8 = 0xC0A8,TLS_PSK_WITH_AES_256_CCM_8 = 0xC0A9,TLS_PSK_DHE_WITH_AES_128_CCM_8 = 0xC0AA,TLS_PSK_DHE_WITH_AES_256_CCM_8 = 0xC0AB,/** RFC 7251*/TLS_ECDHE_ECDSA_WITH_AES_128_CCM = 0xC0AC,TLS_ECDHE_ECDSA_WITH_AES_256_CCM = 0xC0AD,TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = 0xC0AE,TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = 0xC0AF,/** RFC 7507*/TLS_FALLBACK_SCSV = 0x5600,/** draft-ietf-tls-chacha20-poly1305-04*/DRAFT_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA8,DRAFT_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA9,DRAFT_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAA,DRAFT_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAB,DRAFT_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAC,DRAFT_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAD,DRAFT_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAE,/** draft-zauner-tls-aes-ocb-04 (code points TBD)*/DRAFT_TLS_DHE_RSA_WITH_AES_128_OCB = 0xFF00,DRAFT_TLS_DHE_RSA_WITH_AES_256_OCB = 0xFF01,DRAFT_TLS_ECDHE_RSA_WITH_AES_128_OCB = 0xFF02,DRAFT_TLS_ECDHE_RSA_WITH_AES_256_OCB = 0xFF03,DRAFT_TLS_ECDHE_ECDSA_WITH_AES_128_OCB = 0xFF04,DRAFT_TLS_ECDHE_ECDSA_WITH_AES_256_OCB = 0xFF05,DRAFT_TLS_PSK_WITH_AES_128_OCB = 0xFF10,DRAFT_TLS_PSK_WITH_AES_256_OCB = 0xFF11,DRAFT_TLS_DHE_PSK_WITH_AES_128_OCB = 0xFF12,DRAFT_TLS_DHE_PSK_WITH_AES_256_OCB = 0xFF13,DRAFT_TLS_ECDHE_PSK_WITH_AES_128_OCB = 0xFF14,DRAFT_TLS_ECDHE_PSK_WITH_AES_256_OCB = 0xFF15,}}
from Org.BouncyCastle.Crypto.Tls.CipherSuite.cs ver 1.8.5


*e.Handled = true;
追加


*}*else if (t is MemoryStream) {var ms = t as MemoryStream;using ( var fs = new FileStream(destPath+".dat", FileMode.Create) ) {ms.WriteTo(fs);}}
Console.WriteLine(t);


*static readonly byte[]  InitialVerticalForceData        = { 0x00, 0x00, 0x00, 0x00, 0x00 };
初期加速度

*public enum MovementState*{OnGround,Jumping}
地面にいるかジャンプ中か

*private bool JumpBtnPrevPress = false;
1フレ前のジャンプボタンの押下状態

*public AcDkJump(int y)*{StartYpos = y;ResetParam();}
constructor

*PosYi = PosYi - DY_I;
定数での上昇

*int Breg = (Counter >> 4) & 0x0f;
フレームカウンタ値から整数・少数を算出する

*PosYi = PosYi + Breg;
フレームカウンタ値による位置更新


*Console.WriteLine(str.Substring(index+length));
$'


*proj.AddBuildProperty(target, "OTHER_LDFLAGS", "-ObjC");
必須！


*public async Task<TEntity> GetOneAsync(Expression<Func<TEntity, bool>> expression)*{return await db.Set<TEntity>().FirstOrDefaultAsync(expression);}
Generic Repository

*_customerRepository.GetOneByIdAsync(id);
引数をLinq Expressionからidへ修正

*_supplierRepository.GetOneByIdAsync(id.Value);
引数をLinq Expressionからidへ修正

*services.AddScoped(typeof(IRepository<>), typeof(GenericRepository<>));
省略
Repository

*}
省略


*ExecuteDelegateCommand = new DelegateCommand(Execute, CanExecute);
コマンド生成：①

*DelegateCommandObservesProperty = new DelegateCommand(Execute, CanExecute).ObservesProperty(() => IsEnabled);
コマンド生成：②

*DelegateCommandObservesCanExecute = new DelegateCommand(Execute).ObservesCanExecute(() => IsEnabled);
コマンド生成：③

*ExecuteGenericDelegateCommand = new DelegateCommand<string>(ExecuteGeneric).ObservesCanExecute(() => IsEnabled);
コマンド生成：④


*[SerializeField] public float eyeHeight = 1.0f;
ターゲットの視点の高さ


*var salesTaxRate = new SalesTaxRate(birthday);
型が異なるのでコンパイルが通らない

*public ContractDate()*{_date = DateTime.Now;}
契約締結時に呼び出す用

*public ContractDate(DateTime date)*{_date = date;}
リポジトリからの読み出し用

*private ContractDate(DateTime date)*{_date = date;}
制約を無視した勝手なインスタンス生成を利用側にされないようprivateにする

*public static ContractDate Conclude()*{return new ContractDate(DateTime.Now);}
契約締結時に呼び出す用

*internal static ContractDate Reconstruct(DateTime date)
リポジトリからの読み出し用
リポジトリ以外からの生成に利用されないようinternalにする

*public SalesTaxRate(ContractDate contractDate)*{// ここで契約日と消費税施行日とを比較し、消費税率を決定する。,,,/// <summary>適用された消費税率</summary>public class AppliedSalesTaxRate{private readonly decimal _rate;// コンストラクタで契約日を受け取るpublic AppliedSalesTaxRate(ContractDate contractDate){// ここで契約日と消費税施行日とを比較し、消費税率を決定する。,,,/// <summary>消費税適用ルール</summary>internal class SalesTaxApplyRule{private readonly List<SalesTax> _salesTaxes;internal SalesTaxApplyRule(){_salesTaxes = new List<SalesTax>();// 最新の施行日から順に格納すること。// (開発者が順番を気にしなくても良いように設計するのがホントは望ましい)_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2019, 10, 1), rate: 0.10m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2014,  4, 1), rate: 0.08m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1997,  4, 1), rate: 0.05m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1989,  4, 1), rate: 0.03m));}internal decimal ApplyRule(ContractDate contractDate){var corresponded = _salesTaxes.Find(tax => tax.EnforcementDate <= contractDate.Value);return corresponded != null ? corresponded.Rate : 0.00m;}},,,/// <summary>適用された消費税率</summary>public class AppliedSalesTaxRate{// 税適用ルールは1つあれば良く、複数生成させないようstatic readonlyとする。private static readonly SalesTaxApplyRule _salesTaxApplyRule = new SalesTaxApplyRule();private readonly decimal _rate;public decimal Value { get { return _rate; } }public AppliedSalesTaxRate(ContractDate contractDate){_rate = _salesTaxApplyRule.ApplyRule(contractDate);}},,,/// <summary>税込金額</summary>public class AmountIncludingTax{private readonly int _amount;public int Value { get { return _amount; } }public AmountIncludingTax(AmountExcludingTax amountExcludingTax,AppliedSalesTaxRate appliedSalesTaxRate){_amount = (int)(amountExcludingTax.Value * (1m + appliedSalesTaxRate.Value));}},,,/// <summary>税抜き金額</summary>public class AmountExcludingTax{private readonly int _amount;public int Value { get { return _amount; } }/// <summary>コンストラクタ</summary>/// <param name="amount">税抜き金額</param>public AmountExcludingTax(int amount){if (!IsValid(amount)){throw new ArgumentOutOfRangeException();}_amount = amount;}/// <summary>税抜き金額を加算する</summary>/// <param name="amountExcludingTax">税抜き金額</param>/// <returns>税抜き金額</returns>public AmountExcludingTax Add(AmountExcludingTax amountExcludingTax){return new AmountExcludingTax(_amount + amountExcludingTax._amount);}/// <summary>有効な税抜き金額であるかを返す</summary>/// <param name="amount">税抜き金額</param>/// <returns>有効な場合true</returns>private static bool IsValid(int amount){return 0 <= amount;}},,,/// <summary>契約日</summary>public class ContractDate{private readonly DateTime _date;public DateTime Value { get { return _date; } }/// <summary>コンストラクタ</summary>/// <param name="date">契約日</param>/// <remarks>制約を無視した勝手なインスタンス生成を利用側にされないようprivateにしている。</remarks>private ContractDate(DateTime date){_date = date;}/// <summary>契約締結時に呼び出す。</summary>/// <returns>契約日</returns>public static ContractDate Conclude(){return new ContractDate(DateTime.Now);}/// <summary>リポジトリから読み出した時に呼び出す。</summary>/// <param name="date">リポジトリから読み出した契約日</param>/// <returns>契約日</returns>/// <remarks>リポジトリ以外からの生成に利用されないようinternalにしている。</remarks>internal static ContractDate Reconstruct(DateTime date){return new ContractDate(date);}},,,/// <summary>消費税</summary>internal class SalesTax{/// <summary>施行日</summary>internal readonly DateTime EnforcementDate;/// <summary>税率</summary>internal readonly decimal Rate;/// <summary>消費税</summary>/// <param name="enforcementDate">施行日</param>/// <param name="rate">税率</param>internal SalesTax(DateTime enforcementDate, decimal rate){if (!IsValidRate(rate)){throw new ArgumentOutOfRangeException();}EnforcementDate = enforcementDate;Rate = rate;}/// <summary>有効な税率かどうかを返す</summary>/// <param name="rate">税率</param>/// <returns>有効な場合true</returns>private static bool IsValidRate(decimal rate){return 0m <= rate;}},,,/// <summary>消費税適用ルール</summary>internal class SalesTaxApplyRule{private readonly List<SalesTax> _salesTaxes;internal SalesTaxApplyRule(){_salesTaxes = new List<SalesTax>();// 最新の施行日から順に格納すること。// (開発者が順番を気にしなくても良いように設計するのがホントは望ましい)_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2019, 10, 1), rate: 0.10m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2014,  4, 1), rate: 0.08m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1997,  4, 1), rate: 0.05m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1989,  4, 1), rate: 0.03m));}/// <summary>消費税ルールを適用する</summary>/// <param name="contractDate">契約日</param>/// <returns>適用された消費税率</returns>internal decimal ApplyRule(ContractDate contractDate){var corresponded = _salesTaxes.Find(tax => tax.EnforcementDate <= contractDate.Value);return corresponded != null ? corresponded.Rate : 0.00m;}},,,/// <summary>適用された消費税率</summary>public class AppliedSalesTaxRate{private static readonly SalesTaxApplyRule _salesTaxApplyRule = new SalesTaxApplyRule();private readonly decimal _rate;public decimal Value { get { return _rate; } }/// <summary>コンストラクタ</summary>/// <param name="contractDate">契約日</param>public AppliedSalesTaxRate(ContractDate contractDate){_rate = _salesTaxApplyRule.ApplyRule(contractDate);}},,,/// <summary>税込金額</summary>public class AmountIncludingTax{private readonly int _amount;public int Value { get { return _amount; } }/// <summary>コンストラクタ</summary>/// <param name="amountExcludingTax">税抜き金額</param>/// <param name="appliedSalesTaxRate">適用された消費税率</param>public AmountIncludingTax(AmountExcludingTax amountExcludingTax,AppliedSalesTaxRate appliedSalesTaxRate){_amount = (int)(amountExcludingTax.Value * (1m + appliedSalesTaxRate.Value));}},,,*,,,
ここで契約日と消費税施行日とを比較し、消費税率を決定する。

*public AppliedSalesTaxRate(ContractDate contractDate)*{// ここで契約日と消費税施行日とを比較し、消費税率を決定する。,,,/// <summary>消費税適用ルール</summary>internal class SalesTaxApplyRule{private readonly List<SalesTax> _salesTaxes;internal SalesTaxApplyRule(){_salesTaxes = new List<SalesTax>();// 最新の施行日から順に格納すること。// (開発者が順番を気にしなくても良いように設計するのがホントは望ましい)_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2019, 10, 1), rate: 0.10m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2014,  4, 1), rate: 0.08m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1997,  4, 1), rate: 0.05m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1989,  4, 1), rate: 0.03m));}internal decimal ApplyRule(ContractDate contractDate){var corresponded = _salesTaxes.Find(tax => tax.EnforcementDate <= contractDate.Value);return corresponded != null ? corresponded.Rate : 0.00m;}},,,/// <summary>適用された消費税率</summary>public class AppliedSalesTaxRate{// 税適用ルールは1つあれば良く、複数生成させないようstatic readonlyとする。private static readonly SalesTaxApplyRule _salesTaxApplyRule = new SalesTaxApplyRule();private readonly decimal _rate;public decimal Value { get { return _rate; } }public AppliedSalesTaxRate(ContractDate contractDate){_rate = _salesTaxApplyRule.ApplyRule(contractDate);}},,,/// <summary>税込金額</summary>public class AmountIncludingTax{private readonly int _amount;public int Value { get { return _amount; } }public AmountIncludingTax(AmountExcludingTax amountExcludingTax,AppliedSalesTaxRate appliedSalesTaxRate){_amount = (int)(amountExcludingTax.Value * (1m + appliedSalesTaxRate.Value));}},,,/// <summary>税抜き金額</summary>public class AmountExcludingTax{private readonly int _amount;public int Value { get { return _amount; } }/// <summary>コンストラクタ</summary>/// <param name="amount">税抜き金額</param>public AmountExcludingTax(int amount){if (!IsValid(amount)){throw new ArgumentOutOfRangeException();}_amount = amount;}/// <summary>税抜き金額を加算する</summary>/// <param name="amountExcludingTax">税抜き金額</param>/// <returns>税抜き金額</returns>public AmountExcludingTax Add(AmountExcludingTax amountExcludingTax){return new AmountExcludingTax(_amount + amountExcludingTax._amount);}/// <summary>有効な税抜き金額であるかを返す</summary>/// <param name="amount">税抜き金額</param>/// <returns>有効な場合true</returns>private static bool IsValid(int amount){return 0 <= amount;}},,,/// <summary>契約日</summary>public class ContractDate{private readonly DateTime _date;public DateTime Value { get { return _date; } }/// <summary>コンストラクタ</summary>/// <param name="date">契約日</param>/// <remarks>制約を無視した勝手なインスタンス生成を利用側にされないようprivateにしている。</remarks>private ContractDate(DateTime date){_date = date;}/// <summary>契約締結時に呼び出す。</summary>/// <returns>契約日</returns>public static ContractDate Conclude(){return new ContractDate(DateTime.Now);}/// <summary>リポジトリから読み出した時に呼び出す。</summary>/// <param name="date">リポジトリから読み出した契約日</param>/// <returns>契約日</returns>/// <remarks>リポジトリ以外からの生成に利用されないようinternalにしている。</remarks>internal static ContractDate Reconstruct(DateTime date){return new ContractDate(date);}},,,/// <summary>消費税</summary>internal class SalesTax{/// <summary>施行日</summary>internal readonly DateTime EnforcementDate;/// <summary>税率</summary>internal readonly decimal Rate;/// <summary>消費税</summary>/// <param name="enforcementDate">施行日</param>/// <param name="rate">税率</param>internal SalesTax(DateTime enforcementDate, decimal rate){if (!IsValidRate(rate)){throw new ArgumentOutOfRangeException();}EnforcementDate = enforcementDate;Rate = rate;}/// <summary>有効な税率かどうかを返す</summary>/// <param name="rate">税率</param>/// <returns>有効な場合true</returns>private static bool IsValidRate(decimal rate){return 0m <= rate;}},,,/// <summary>消費税適用ルール</summary>internal class SalesTaxApplyRule{private readonly List<SalesTax> _salesTaxes;internal SalesTaxApplyRule(){_salesTaxes = new List<SalesTax>();// 最新の施行日から順に格納すること。// (開発者が順番を気にしなくても良いように設計するのがホントは望ましい)_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2019, 10, 1), rate: 0.10m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2014,  4, 1), rate: 0.08m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1997,  4, 1), rate: 0.05m));_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(1989,  4, 1), rate: 0.03m));}/// <summary>消費税ルールを適用する</summary>/// <param name="contractDate">契約日</param>/// <returns>適用された消費税率</returns>internal decimal ApplyRule(ContractDate contractDate){var corresponded = _salesTaxes.Find(tax => tax.EnforcementDate <= contractDate.Value);return corresponded != null ? corresponded.Rate : 0.00m;}},,,/// <summary>適用された消費税率</summary>public class AppliedSalesTaxRate{private static readonly SalesTaxApplyRule _salesTaxApplyRule = new SalesTaxApplyRule();private readonly decimal _rate;public decimal Value { get { return _rate; } }/// <summary>コンストラクタ</summary>/// <param name="contractDate">契約日</param>public AppliedSalesTaxRate(ContractDate contractDate){_rate = _salesTaxApplyRule.ApplyRule(contractDate);}},,,/// <summary>税込金額</summary>public class AmountIncludingTax{private readonly int _amount;public int Value { get { return _amount; } }/// <summary>コンストラクタ</summary>/// <param name="amountExcludingTax">税抜き金額</param>/// <param name="appliedSalesTaxRate">適用された消費税率</param>public AmountIncludingTax(AmountExcludingTax amountExcludingTax,AppliedSalesTaxRate appliedSalesTaxRate){_amount = (int)(amountExcludingTax.Value * (1m + appliedSalesTaxRate.Value));}},,,*,,,
ここで契約日と消費税施行日とを比較し、消費税率を決定する。

*_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2019, 10, 1), rate: 0.10m));
最新の施行日から順に格納すること。
(開発者が順番を気にしなくても良いように設計するのがホントは望ましい)

*private static readonly SalesTaxApplyRule _salesTaxApplyRule = new SalesTaxApplyRule();
税適用ルールは1つあれば良く、複数生成させないようstatic readonlyとする。

*_salesTaxes.Add(new SalesTax(enforcementDate: new DateTime(2019, 10, 1), rate: 0.10m));
最新の施行日から順に格納すること。
(開発者が順番を気にしなくても良いように設計するのがホントは望ましい)


*public class Foo*{public class Factory : PlaceholderFactory<Foo>{}}
Pooling を行わない悪い実装例

*public FooSpawner(Foo.Factory fooFactory)*{_fooFactory = fooFactory;}
Constructor Injection

*public void AddFoo()*{_foos.Add(_fooFactory.Create());}
AddFoo を呼び出たびに、新しいヒープメモリが割り当てられる

*public void RemoveFoo()
RemoveFoo が呼び出されるたびに、FooSpawnerからFooに対する参照が1つずつ失われ
最終的にガーベージコレクタによって回収される。その際、スパイクが発生してしまう。

*public class Pool : MemoryPool<Foo>*{}
Factoryと異なり、PlaceholderFactoryではなくMemoryPoolを継承する。

*public FooSpawner(Foo.Pool fooPool)*{_fooPool = fooPool;}
Constructor Injection

*public void AddFoo()
AddFoo を呼び出たすと、生成時には新しくヒープが割り当てられるが、
未使用のFooがある場合そちらが再利用される。

*_foos.Add(_fooPool.Spawn());
Pool.Spawn()によってFooを生成、再利用する

*public void RemoveFoo()
RemoveFoo が呼び出されるとFooSpawnerからはFooに対する参照は失われるが
Pool内に未使用のFooとして山荘が残される。

*_fooPool.Despawn(foo);
Pool.Despawn()によってPoolに使用していたFooを戻す

*Container.BindMemoryPool<Foo, Foo.Pool>();
BindFactoryではなくBindMemoryPoolになる

*public class Pool : MemoryPool<int, Foo>*{protected override void OnCreated(Foo item){// オブジェクトがプールされた直後に呼ばれます。}protected override void OnDestroyed(Foo item){// オブジェクトがプールから削除された時によばれます。// WithMaxSizeを設定したときや、ShrinkBy、ResizeメソッドによってPoolのサイズ// が明示的に縮小したときに発生します。}protected override void OnSpawned(Foo item){// オブジェクトがPoolから取り出されたときに呼ばれます。}protected override void OnDespawned(Foo item){// オブジェクトがPoolに戻されたときに呼ばれます。}protected override void Reinitialize(int index, Foo foo){// OnSpawnedと呼ばれるタイミングはほぼ同じです。// ただし、Pool.Spawn（）で渡された引数はここで渡されます。foo.Reset(index);}}
パラメータを追加する場合は、引数を追加する。

*}
オブジェクトがプールされた直後に呼ばれます。

*}
オブジェクトがプールから削除された時によばれます。
WithMaxSizeを設定したときや、ShrinkBy、ResizeメソッドによってPoolのサイズ
が明示的に縮小したときに発生します。

*}
オブジェクトがPoolから取り出されたときに呼ばれます。

*}
オブジェクトがPoolに戻されたときに呼ばれます。

*foo.Reset(index);
OnSpawnedと呼ばれるタイミングはほぼ同じです。
ただし、Pool.Spawn（）で渡された引数はここで渡されます。

*_fooPool.Spawn(_index);
パラメータを追加するとSpawnに引数が追加される。

*public class Foo : IPoolable<IMemoryPool>, IDisposable*{private IMemoryPool _pool = default;public void Dispose(){_pool.Despawn(this);}public void OnDespawned(){_pool = null;}// 生成時に呼ばれる。初期化を書くのはここpublic void OnSpawned(IMemoryPool pool){_pool = pool;}//　Factoryの時と同様にPlaceholderFactoryの派生クラスを作る。public class Factory : PlaceholderFactory<Foo>{}}
IPoolable<IMemoryPool>、IDisposableを実装する

*public void OnSpawned(IMemoryPool pool)*{_pool = pool;}
生成時に呼ばれる。初期化を書くのはここ

*public class Factory : PlaceholderFactory<Foo>*{}
Factoryの時と同様にPlaceholderFactoryの派生クラスを作る。

*_foos.Add(_factory.Create());
Factory と同様にCreate()でオブジェクトを生成できる。

*foo.Dispose();
Poolに戻すときはDispose()を呼ぶ。

*Container.BindFactory<Foo, Foo.Factory>()
FromPoolableMemoryPoolを追加する

*public class FooPool : PoolableMemoryPool<IMemoryPool, Foo>*{}
IL2CPP AOT エラーが発生する場合があるので、Poolクラスは明確に定義する必要がある。

*_originalParent = item.transform.parent;*}
Record the original parent which will be set to whatever is used in the UnderTransform method

*public void OnSpawned(Vector3 velocity, IMemoryPool pool)*{transform.position = Vector3.zero;_pool = pool;_velocity = velocity;}
Create()で渡された引数がここに渡される

*public class Factory : PlaceholderFactory<Vector3, Foo>*{}
Factoryになり派生クラスにResetを描く必要がなくなった

*_foos.Add(_fooFactory.Create(Random.onUnitSphere * Random.Range(minSpeed, maxSpeed)));
SpawnからCreateに

*foo.Dispose();
DespawnからDisposeに

*.FromPoolableMemoryPool<Vector3, Foo, FooPool>(
本来ここではFromMonoPoolableMemoryPoolを用いますが、IL2CPPのAOTを回避するために
Poolクラスを明示的に宣言してFromPoolableMemoryPoolを使用します。

*public class FooPool : MonoPoolableMemoryPool<Vector3, IMemoryPool, Foo>*{}
IL2CPP AOT エラーが発生する場合があるので、Poolクラスは明確に定義する必要がある。


*model.SelectId = id;
選択したくじ番号をセット


*if (!ModelState.IsValid)*return View(model);
入力エラーがある時は何もしない

*return RedirectToAction("Index", "Kuji");
くじコントローラーを呼ぶ

*var json = TempData["kuji"]?.ToString();
受け取ったTempDataからデータを取得する


*public async Task<IActionResult> OnPostAsync()*{if (!ModelState.IsValid){return Page();}_context.Movies.Add(Movie);await _context.SaveChangesAsync();return RedirectToPage("./Index");}
more details see https:aka.ms/RazorPagesCRUD.


*[StringLength(20, ErrorMessage = "タイトルは20文字以内で入力してください")]public string Title { get; set; }
タイトル

*[Range(1, 9, ErrorMessage = "1～9の数字を入力してください")]public int NumberOfKuji { get; set; }
くじの数

*public List<ResultModel> Result { get; set; }
くじの結果

*public int SelectId { get; set; }
選択したくじ番号

*[StringLength(5, ErrorMessage = "くじの結果は5文字以内で入力してください")]public string Item { get; set; }
内容

*var model = new KujiModel();
モデルのインスタンスを生成し、ビューに渡す

*var model = new KujiModel();
新しいくじモデルをビューに渡す

*if (!ModelState.IsValid)*return View(model);
入力エラーがある時は何もしない

*return RedirectToAction("Index", "Kuji");
くじコントローラーを呼ぶ


*const string sayConst;
変数と区別するためにsayの後ろにConstを加えました

*void Start() {string say = "Hello World";Debug.Log(say);const string sayConst = "Hello World2";Debug.Log(say);}
例


*receiveBuffer.Length);
data buffer

*StringBuilder id = new StringBuilder(BitConverter.ToString(responseApdu.GetData()));*if (radioButtonNone.Checked) {id.Replace("-", string.Empty);} else if (radioButtonSpace.Checked) {id.Replace("-", " ");}
バイナリ文字列の整形

*int seq = (int)numericUpDown.Value;
データグリッドビューに結果を追加し、連番をカウントアップする


*.SkipWhile(e => e.Text != "https:
qiita.comdraftsnew").Skip(1)

*bool hasNew = Enumerable.Range(0, Math.Min(notificationBitmap.Width, notificationBitmap.Height))*.Any(xy => notificationBitmap.GetPixel(xy, xy).ToArgb() == arrivalBackgroundArgb);
左上から右下に向けて赤を探す（背景が赤なら見つかるはず）

*}
新着の中に「いいね」はあるかは色では判定できません。
上のテキストによる検証と同じになるので省略します。


*ushort delayTimeEndFrame = 100;
unit:[10ms]

*bmps[bmps.Count-1].delayTime = delayTimeEndFrame;
最後のdelayを長くする

*MyGifEncorder.SaveAnimatedGif("out.gif", bmps, LoopCount);*}
生成


*}
〇〇で使う変数群
public const int a=1;    〇〇の数値a
public const int b=5;    〇〇の力量b
public const int c=10;   〇〇のスピードc

*Debug.Log("a:" + Data.a);
Dataクラスの中の情報を呼び出す。

*private static SerializeData serializeData;
SerializeDataクラスの情報

*public static void OnStart(SerializeData serializedata)*{serializeData = serializedata;}
シーン上にあるSerializeDataクラスを取得する。

*public static GameObject obj*{get { return serializeData.obj; }}
ゲッターでSerializeDataクラスの情報を拾う。

*Data.OnStart(GameObject.FindGameObjectWithTag("Serialize").GetComponent<SerializeData>());
ここで、"Serialize"というTag名のオブジェクトにアタッチされているSerializeDataクラスの情報をDataクラスに渡している。

*Debug.Log("obj:" + Data.obj.name);
データクラスから呼び出す。


*var tokenResponse = await context.AcquireTokenAsync("https:
management.azure.com", clientCredential);

*var tenantId= "00000000-0000-0000-0000-000000000000";
注意：Microsoft.Azure.Management.Storage.Fluent ではない


*string hexhex = mHexHex.Groups[0].Value;
2桁の16進文字列 ("12"とか"fc"とか)


*sf.LineAlignment = StringAlignment.Center;
縦中央 ・・・ にならない（？）

*float ascentHeight  = fontHeight * ascent  / emHeight;
下記の各Y座標(pixel単位)で横線を引いてみた
float fontHeight = font.GetHeight(g);  g: 描画に使用するGraphicsクラス


*sf.LineAlignment = StringAlignment.Center;
縦中央


*public string StudentNumber { get; set; }
生徒番号

*public string Name { get; set; }
名前

*public string BloodType { get; set; }
血液型

*public string Department { get; set; }
組

*public int National { get; set; }
国語

*public int Mathematics { get; set; }
算数

*public Student(string studentNumber, string name, string bloodType, string department, int national, int mathematics)*{StudentNumber = studentNumber;Name = name;BloodType = bloodType;Department = department;National = national;Mathematics = mathematics;}
コンストラクタ

*.OrderBy(value => Array.IndexOf(new[] { "O", "A", "AB", "B" }, value.BloodType))
血液型のソート

*.ThenBy(value => Array.IndexOf(new[] { "B", "C", "A" }, value.Department))
組のソート


*var sendBuffer = new byte[] { 0xff, 0xca, 0x00, 0x00, 0x00 };
← IDmを取得するコマンド

*recvBuffer = IDm + SW1 + SW2 (SW = StatusWord)SW1 = 0x90 (144) SW1 = 0x00 (0) で正常だが、ここでは見ていないstring cardId = BitConverter.ToString(recvBuffer, 0, pcbRecvLength - 2);
受信データからIDmを抽出する

*SW1 = 0x90 (144) SW1 = 0x00 (0) で正常だが、ここでは見ていないstring cardId = BitConverter.ToString(recvBuffer, 0, pcbRecvLength - 2);
recvBuffer = IDm + SW1 + SW2 (SW = StatusWord)

*string cardId = BitConverter.ToString(recvBuffer, 0, pcbRecvLength - 2);
SW1 = 0x90 (144) SW1 = 0x00 (0) で正常だが、ここでは見ていない


*void Start()*{}
Start is called before the first frame update

*void Update()*{}
Update is called once per frame


*using System.Windows.Forms;
フォーム: Form, Button, TextBox, ...


*void Start()*{}
Start is called before the first frame update

*void Update()*{bool isUpdate = false;#if UNITY_EDITORif (Input.GetMouseButtonDown(0) || Input.GetMouseButton(1)){isUpdate = true;}#elseif (Input.touchCount == 1 && Input.touches[0].phase == TouchPhase.Began){isUpdate = true;}else if (Input.touchCount == 2){isUpdate = true;}else if (Input.touchCount == 3){_aggregate.Clear();}#endifif (isUpdate){Random rand = new Random();_aggregate.Add((int)(rand.NextDouble() * 100));}}
Update is called once per frame


*Position = 0
先頭位置からの再生を意味するが、streamを新規にnewするときは不要なはず

*player.Play();
再生

*player.Stop();
停止


*Width = RouletteEllipse.Width
2,                   ルーレットの円の半分

*var sb = FindResource("StartRoulettea") as Storyboard;
ルーレットを回すためのStoryBoardを検索

*sb.Begin();
回転開始(スタート)

*sb.Pause();
回転停止(ストップ)


*using UnityEngine;
このスクリプトをプロジェクト下に置くだけで実行されます。
エディター拡張機能なので Editor フォルダに置くと良いです。

*SceneView.onSceneGUIDelegate += onSceneGUIDelegate;
シーンビュー上のイベントを取得するためのメソッドを追加
※この方法でないとメソッド内で全イベントが取得できない

*if (scene.in2DMode)*return;
3Dモード時にマウススクロールにトレースする

*var center = new Vector2(scene.position.width, scene.position.height) * 0.5f;
カーソルの画面中央からの差を計算

*var pivot = scene.pivot;
カメラの中心を拡大率に比例してカーソル方向に動かす


*if (currentCamera.cameraType != CameraType.SceneView)*#endif
Sceneビューには必ず映す

*Camera.current.cameraType == CameraType.Previewではチェックできない(PreviewCameraもCameraType.Gameになる)ので名前で判定if (currentCamera.name == PREVIEW_CAMERA_NAME){foreach (var camera in _selectedCamera){位置、角度、マスクなどの情報から一致するカメラを推測推測制度を高めたい場合は一致させるデータを増やすif (currentCamera.transform.position == camera.transform.position &&
Preview Cameraの場合、選択中のカメラの中にRenderCameraと一致するカメラがあるかチェックする

*if (currentCamera.transform.position == camera.transform.position &&
位置、角度、マスクなどの情報から一致するカメラを推測
推測制度を高めたい場合は一致させるデータを増やす

*void Start()*{}
Start is called before the first frame update

*void Update()*{var sPos = _startObject.transform.position;var ePos = _endObject.transform.position;// 色指定無し、カメラ指定有りDebugLineDrawer.DrawLine(sPos, ePos, camera: Camera.main);// 色指定無しの場合のカラーを変更DebugLineDrawer.SetColor(Color.green);// 色指定無し、カメラ指定有りDebugLineDrawer.DrawLine(sPos + Vector3.up, ePos + Vector3.up, camera: Camera.main);// 色指定有り、カメラ指定無しDebugLineDrawer.DrawLine(sPos + Vector3.up * 2, ePos + Vector3.up * 2, Color.red);// 色指定無し、カメラ指定有りDebugLineDrawer.DrawLine(sPos + Vector3.up * 3, ePos + Vector3.up * 3, camera: Camera.main);// 色指定有り、カメラ指定無し、Mask指定有りDebugLineDrawer.DrawLine(sPos + Vector3.up * 4, ePos + Vector3.up * 4, Color.cyan, layerMask: LayerMask.GetMask("UI"));// 色指定無し、カメラ指定無しDebugLineDrawer.DrawRay(sPos, Vector3.up * 2);// 色指定有り、カメラ指定無しDebugLineDrawer.DrawRay(sPos + Vector3.up * 2, Vector3.up * 2, Color.yellow);}
Update is called once per frame

*DebugLineDrawer.DrawLine(sPos, ePos, camera: Camera.main);
色指定無し、カメラ指定有り

*DebugLineDrawer.SetColor(Color.green);
色指定無しの場合のカラーを変更

*DebugLineDrawer.DrawLine(sPos + Vector3.up, ePos + Vector3.up, camera: Camera.main);
色指定無し、カメラ指定有り

*DebugLineDrawer.DrawLine(sPos + Vector3.up * 2, ePos + Vector3.up * 2, Color.red);
色指定有り、カメラ指定無し

*DebugLineDrawer.DrawLine(sPos + Vector3.up * 3, ePos + Vector3.up * 3, camera: Camera.main);
色指定無し、カメラ指定有り

*DebugLineDrawer.DrawLine(sPos + Vector3.up * 4, ePos + Vector3.up * 4, Color.cyan, layerMask: LayerMask.GetMask("UI"));
色指定有り、カメラ指定無し、Mask指定有り

*DebugLineDrawer.DrawRay(sPos, Vector3.up * 2);
色指定無し、カメラ指定無し

*DebugLineDrawer.DrawRay(sPos + Vector3.up * 2, Vector3.up * 2, Color.yellow);
色指定有り、カメラ指定無し


*interface ISampleService*{void DoSomething(ConsoleAppOptions options);}
interface


*{
enumの定義


*var replyMsg = client.WriteLineAndGetReply(textBox_SendMsg.Text + '\0', TimeSpan.FromSeconds(3));
終端文字を追加する。


*const int TestTimes = 1001;
中央値を取りたいので奇数回にする。

*GC.Collect();
明示的にGCを呼び出すことで、途中でGCが発生しにくくする。

*sw.Restart();*{// 下行のコメントアウトを外してLoadTimeTest_ascii.exe として保存 ・・・ 表中の「ASCII」// File.ReadAllLines("tmp_ascii.txt",System.Text.Encoding.ASCII);// 下行のコメントアウトを外してコンパイルし LoadTimeTest_no_opt.exe として保存 ・・・ 表中の「no_opt (UTF-8)」// File.ReadAllLines("tmp_ascii.txt");// 下行のコメントアウトを外してLoadTimeTest_utf16le.exe として保存 ・・・ 表中の「UTF-16 LE」// File.ReadAllLines("tmp_utf16le.txt",System.Text.Encoding.Unicode);}
計測開始

*}
下行のコメントアウトを外してLoadTimeTest_ascii.exe として保存 ・・・ 表中の「ASCII」
File.ReadAllLines("tmp_ascii.txt",System.Text.Encoding.ASCII);
下行のコメントアウトを外してコンパイルし LoadTimeTest_no_opt.exe として保存 ・・・ 表中の「no_opt (UTF-8)」
File.ReadAllLines("tmp_ascii.txt");
下行のコメントアウトを外してLoadTimeTest_utf16le.exe として保存 ・・・ 表中の「UTF-16 LE」
File.ReadAllLines("tmp_utf16le.txt",System.Text.Encoding.Unicode);

*measuredTicks[i] = sw.ElapsedTicks;
計測結果を取得

*Array.Sort(measuredTicks);
中央値を取得


*objPool.SetActive(new Vector3(0f, 10f, 0f));
使用


*funcGimmick[UnityEngine.Random.Range(0, funcGimmick.Length - 1)];
ステージにギミックをランダムに発生させる

*return 0;
ステージが落ちる

*return 0;
ステージが跳ねる


*NowRotation = new Vector3(-360, 0, 0);
角度の初期化

*StartFrick = Input.mousePosition + NowRotation;
現在の角度と画面にタッチしたVector3値の和を格納し、Update関数を終了

*NowRotation = StartFrick - Input.mousePosition;
マウスでクリックし続けてる間のみ、
現在のタッチしているVector3値とStartFrickの差分で角度を変更する


*static RestSharp.RestClient client= new RestSharp.RestClient("http:
weather.livedoor.comforecastwebservicejsonv1");


*private static AutomationElement FindElementById(AutomationElement rootElement, string automationId)*{return rootElement.FindFirst(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.AutomationIdProperty, automationId));}
指定したID属性に一致するAutomationElementを返します

*private static IEnumerable<AutomationElement> FindElementsByName(AutomationElement rootElement, string name)*{return rootElement.FindAll(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.NameProperty, name)).Cast<AutomationElement>();}
指定したName属性に一致するAutomationElementをすべて返します

*private static IEnumerable<AutomationElement> FindButtonsByName(AutomationElement rootElement, string name)*{const string BUTTON_CLASS_NAME = "Button";return from x in FindElementsByName(rootElement, name)where x.Current.ClassName == BUTTON_CLASS_NAMEselect x;}
指定したName属性に一致するボタン要素をすべて返します

*private static AutomationElementCollection FindElementsByControlType(AutomationElement rootElement, ControlType controlType)*{return rootElement.FindAll(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.ControlTypeProperty, controlType));}
指定したControlType属性に一致する要素をすべて返します


*ImageView starImage;
星の画像

*starImage.Visibility = Android.Views.ViewStates.Visible;
星画像を表示する

*var waitAnimation = AnimationUtils.LoadAnimation(this, Resource.Animation.wait_animation);
アニメーション開始

*starImage.Animation.AnimationEnd += (sender, e) => {// 星画像を非表示にするstarImage.Visibility = Android.Views.ViewStates.Gone;selectedDateLabel.Text = time.ToString("yyyy年MM月dd日")+ $"\r\nあなたは、{GetEto(time.Year)}年 {GetSeiza(time.Month, time.Day)}です。";};
アニメーション完了イベント

*starImage.Visibility = Android.Views.ViewStates.Gone;
星画像を非表示にする


*itemList[index] = ITEM.NONE;
アイテムを使用したので空にする;


*Debug.Log(code.ToString() + " のボタンが押されたよ！！");
コンソールに表示


*private const string ETO = "申酉戌亥子丑寅卯辰巳午未";
十二支

*private static Tuple<string, int, int>[] SEIZA = {Tuple.Create("牡羊座", 321, 419),Tuple.Create("牡牛座", 420, 520),Tuple.Create("双子座", 521, 621),Tuple.Create("蟹座", 622, 722),Tuple.Create("獅子座", 723, 822),Tuple.Create("乙女座", 823, 922),Tuple.Create("天秤座", 923, 1023),Tuple.Create("蠍座", 1024, 1122),Tuple.Create("射手座", 1123, 1221),Tuple.Create("山羊座", 1222, 1231),Tuple.Create("山羊座", 101, 120),Tuple.Create("水瓶座",121, 218),Tuple.Create("魚座", 219, 320)};
星座


*_application  = new Application(){非表示Visible = false,};
Excelアプリケーション生成

*Visible = false,};
非表示

*_workbook = _application .Workbooks.Open(@"e:\book1.xlsx");
Bookを開く

*_workbook.Worksheets.Select();
全シートを選択する

*_workbook.ExportAsFixedFormat(
ファイル名を指定してPDF形式で保存する
ExportAsFixedFormatメソッド: ブックを PDF または XPS 形式に発行する
Type    : タイプ   : XlFixedFormatType xlTypePDF=PDF, xlTypeXPS=XPS
Filename: 出力ファイル名
Quality : 種t力品質: XlFixedFormatQuality xlQualityStandard=標準品質, xlqualityminimum=最小限の品質

*}
TODO: Managed Objectの破棄

*using (var excel = new ExcelManager()){excel.Open();
for Microsoft.Office.Interop.Excel


*public static readonly string TAG = "X:" + typeof(DatePickerFragment).Name.ToUpper();
タグ

*Action<DateTime> dateSelectedHandler = delegate { };
日付選択処理のデリゲート

*Button dateSelectButton;
SELECT DATEボタン

*TextView selectedDateLabel;
選択日付の表示ラベル


*var list = mat.SelectMany(r => r).ToList();
flatten


*Debug.Log(i);
→ 32768


*var process = new Process();*{StartInfo = new ProcessStartInfo(PYTHON_INTERPRITER){UseShellExecute = false,RedirectStandardOutput = true,Arguments = ARGUMENTS}}
プロセスの立ち上げ

*process.Start();
プロセスの実行

*process.WaitForExit();
終了まで待ってから切断する

*APPLICATION_ID = Guid.NewGuid().ToString();
M2Mqttの起動

*_mqttClient.MqttMsgPublishReceived += (sender, e) => {OnReceivedData(Encoding.UTF8.GetString(e.Message));};
購読設定

*try*{data = JsonConvert.DeserializeObject<RasPiData>(message);}
受信データのデシリアライズ

*try*{if (data.MessageType == MessageType.Record || data.MessageType == MessageType.PlayBack){PlayBackAndRecord(data.MessageType, data.Message);Log("Process succeeded.");}else{Log($"unexpected message arrived : {data.Message}");}}
メッセージが指定のJson形式だった場合

*var arguments = "";
命令の種類を受け、Pythonアプリケーションの引数を指定

*var process = new Process(){StartInfo = new ProcessStartInfo(PYTHON_INTERPRITER){UseShellExecute = false,RedirectStandardOutput = true,Arguments = arguments},};
Pythonアプリケーションの起動・実行

*APPLICATION_ID = Guid.NewGuid().ToString();
M2Mqttの起動

*var program = new Program();
コンソールで何の処理を行うかをユーザに尋ねる


*{
enumの定義


*return Vector3.Cross(tmp1, tmp2);
Vector3.Crossは外積を求めるメソッド

*private float[] CalculateEquationOfPlane(Vector3 vec1, Vector3 vec2, Vector3 vec3, Vector3 normal) {float[] ans = new float[]{normal.x,normal.y,normal.z,-normal.x * vec1.x - normal.y * vec1.y - normal.z * vec1.z};return ans;}
このメソッドは、vec1,vec2,vec3の3点を通る平面の方程式ax+by+cz+d=0のa,b,c,dを配列で返す

*private Vector3 CalculateCoordinateOfIntersection(float[] plane, Vector3 angle, Vector3 position) {float parameter = -(plane[0] * position.x + plane[1] * position.y + plane[2] * position.z + plane[3]) / (plane[0] * angle.x + plane[1] * angle.y + plane[2] * angle.z);float x = angle.x * parameter + position.x;float y = angle.y * parameter + position.y;float z = angle.z * parameter + position.z;return new Vector3(x, y, z);}
このメソッドでは、カメラの視線とメッシュとの交点の座標が求められる

*private bool WhetherParameterIsPositive(float[] plane, Vector3 angle, Vector3 position) {float parameter = -(plane[0] * position.x + plane[1] * position.y + plane[2] * position.z + plane[3]) / (plane[0] * angle.x + plane[1] * angle.y + plane[2] * angle.z);return parameter > 0;}
建てたい建築がカメラの正面にあるときにだけ建築できるようにする

*private bool WhetherDistanceIsProper(Vector3 vec0, Vector3 vec1, Vector3 vec2, Vector3 vec3) {Vector3 fromCameraToPlayer = player.transform.position - gameObject.transform.position;Vector3 fromCameraToBuilding = (vec0 + vec1 + vec2 + vec3) / 4 - gameObject.transform.position;return fromCameraToBuilding.magnitude > fromCameraToPlayer.magnitude;}
カメラとプレイヤーとの間に建築されないようにする

*private bool WhetherIntersectionIsInsidePolygon(Vector3[] vertices, Vector3 intersection, Vector3 normal) {float angle_sum = 0f;for (int i = 0; i < vertices.Length; i++) {Vector3 tmp1 = vertices[i] - intersection;Vector3 tmp2 = vertices[(i + 1) % vertices.Length] - intersection;float angle = Vector3.Angle(tmp1, tmp2);Vector3 cross = Vector3.Cross(tmp1, tmp2);if (Vector3.Dot(cross, normal) < 0) angle *= -1;angle_sum += angle;}angle_sum /= 360f;return Mathf.Abs(angle_sum) >= 0.1f;}
このメソッドは引用させていただきました

*private bool CanBuildWallAndStair(Vector3 vertex0, Vector3 vertex1, Vector3 vertex2, Vector3 vertex3) {Vector3[] vertices = new Vector3[] { vertex0, vertex1, vertex2, vertex3 };Vector3 normal = CalculateOuterProduct(vertices[0], vertices[1], vertices[2]);float[] abcd = CalculateEquationOfPlane(vertices[0], vertices[1], vertices[2], normal);Vector3 intersection = CalculateCoordinateOfIntersection(abcd, gameObject.transform.rotation * Vector3.forward, gameObject.transform.position);return WhetherIntersectionIsInsidePolygon(vertices, intersection, normal) &&WhetherDistanceIsProper(vertex0, vertex1, vertex2, vertex3) &&WhetherParameterIsPositive(abcd, gameObject.transform.rotation * Vector3.forward, gameObject.transform.position);}
壁と階段が建築できる条件

*private bool CanBuildFloor(Vector3 vec0, Vector3 vec1, Vector3 vec2, Vector3 vec3) {Vector3 target = (vec0 + vec1 + vec2 + vec3) / 4;Vector3 targetToCameraDirection = (target - gameObject.transform.position).normalized;if (Vector3.Dot(targetToCameraDirection, gameObject.transform.forward.normalized) > 0.97) return true;else return false;}
床が建築できる条件

*float x = gameObject.transform.localEulerAngles.x;*/*下の床*/
カメラが上の方を向いているか、下の方を向いているかを取得する

*if (CanBuildWallAndStair(points[0], points[3], points[15], points[12])) Instantiate(wall, (points[0] + points[3] + points[15] + points[12]) / 4, Quaternion.Euler(0f, 0f, 90f));*else if (CanBuildWallAndStair(points[1], points[2], points[14], points[13])) Instantiate(wall, (points[1] + points[2] + points[14] + points[13]) / 4, Quaternion.Euler(0f, 0f, 90f));
pointsの数字によって壁を回転させなければならない

*float cameraRotationY = gameObject.transform.localEulerAngles.y;*Vector3 pos = (points[0] + points[1] + points[2] + points[3] + points[12] + points[13] + points[14] + points[15]) / 8;
カメラが前後左右のどこを向いているか取得


*htmlAttributes.Add("class", "custom");
アトリビュートの追加


*using UnityEngine.UI;
これをつけ加え忘れるとエラーが出ます

*void Start () {webCamTexture = new WebCamTexture();rawImage.texture = webCamTexture;webCamTexture.Play();}
Start is called before the first frame update


*Console.WriteLine("Configuration path:");
どこに設定ファイルが保存されたかを出力


*using UnityEngine.UI;
UI.Textのために必要

*ClickedTextObject =
eventData.pointerPressメンバから
どのTextObjectがクリックされたか受け取る


*float m_moveSpeedAdjust = 10f;
定位置に戻る速度

*float m_waistObjSpace = 0.2f;
腰との間隔

*float m_thresholdDot = -0.1f;
視線判定の閾値

*public void SetWaistObjSide(WAISTSIDE waistSide)*{waistObjLocalPos = m_waistObj.transform.localPosition;m_waistSide = waistSide;if (m_waistSide == WAISTSIDE.LEFT){m_waistObj.transform.localPosition = new Vector3(-m_waistObjSpace, waistObjLocalPos.y, waistObjLocalPos.z);}else{m_waistObj.transform.localPosition = new Vector3(m_waistObjSpace, waistObjLocalPos.y, waistObjLocalPos.z);}}
腰のオブジェクトをどちら側で固定するか

*Quaternion waistRotation = this.gameObject.transform.parent.transform.rotation;*waistRotation.z = 0;
角度の制限

*Vector3 cameraPos = this.gameObject.transform.parent.position;*this.gameObject.transform.position = new Vector3(cameraPos.x, cameraPos.y-0.5f, cameraPos.z);
腰の位置の固定  0.5fは個人的にベストと感じた腰の位置

*float dot = Vector3.Dot(Vector3.down, this.gameObject.transform.parent.transform.forward);*waistObjLocalPos = m_waistObj.transform.localPosition;
顔面→腰のオブジェクト 、 顔面→顔面の正面  の内積　> 閾値 ) ---＞ 前へ出てくる

*Quaternion waistRotation = this.gameObject.transform.parent.transform.rotation;*waistRotation.z = 0;
角度の制限

*GameObject m_waistObj;
[SerializeField, Header("下を見ると腰のオブジェクトが前に飛び出る")]

*float m_moveSpeedAdjust = 10f;
定位置に戻る速度

*float m_waistObjSpace = 0.2f;
腰との間隔

*float m_thresholdDot = -0.1f;
視線判定の閾値

*float m_waistHeight = 0.5f;
腰とカメラの距離

*public void ChangeWaistObjSide(WAISTSIDE waistSide)*{if (CheckChild() == false) return;waistObjLocalPos = m_waistObj.transform.localPosition;m_waistSide = waistSide;if (m_waistSide == WAISTSIDE.LEFT){m_waistObj.transform.localPosition = new Vector3(-m_waistObjSpace, waistObjLocalPos.y, waistObjLocalPos.z);}else{m_waistObj.transform.localPosition = new Vector3(m_waistObjSpace, waistObjLocalPos.y, waistObjLocalPos.z);}}
腰のオブジェクトをどちら側で固定するか

*bool CheckChild()*{if (this.gameObject.transform.childCount > 0){m_waistObj = this.gameObject.transform.GetChild(0).gameObject;return true;}else{m_waistObj = null;return false;}}
子が存在するか

*Quaternion waistRotation = this.gameObject.transform.parent.transform.rotation;*waistRotation.z = 0;
角度の制限

*Vector3 cameraPos = this.gameObject.transform.parent.position;*this.gameObject.transform.position = new Vector3(cameraPos.x, cameraPos.y - m_waistHeight, cameraPos.z);
腰の位置の固定

*if (CheckChild() == false) return;*//顔面→腰のオブジェクト 、 顔面→顔面の正面  の内積　> 閾値 ) ---＞ 前へ出てくる
子が存在していたら腰のオブジェクトとして認識

*float dot = Vector3.Dot(Vector3.down, this.gameObject.transform.parent.transform.forward);*waistObjLocalPos = m_waistObj.transform.localPosition;
顔面→腰のオブジェクト 、 顔面→顔面の正面  の内積　> 閾値 ) ---＞ 前へ出てくる

*bool CheckChild()*{if (this.gameObject.transform.childCount > 0){m_waistObj = this.gameObject.transform.GetChild(0).gameObject;return true;}else{m_waistObj = null;return false;}}
子が存在するか


*input.Type = 0;
MOUSE = 0


*else {
正規表現にはマッチしなかった。

*Console.WriteLine("Info: Regex mismatch. " + s);
次を検索させる。

*[MethodImpl(MethodImplOptions.NoInlining)]
RunApp()に処理を分離して属性指定している目的:
JITによるinline展開を禁止することで、
Mainメソッド内のGC.Collect()までに余計な(Wordの)COM参照オブジェクトが残らないことを期待する。
ただし、期待通りに動作しているかは確認していない。(そもそも要るのか不明。。)


*string jsonFilePath = @"TestData.json";
デシリアライズ(jsonファイル→クラスオブジェクト)

*string jsonFilePathOut = @"TestDataOut.json";
シリアライズ(クラスオブジェクト→jsonファイル)

*Console.WriteLine("json読み書き完了");
終わり


*public IExcelCrtOcx Xlsx { get; set; }
ExcelCreatorコントロール

*private string _templateFile = string.Empty;
テンプレートの情報

*Xlsx = new Xlsx();
Xlsxインスタンス生成

*GetTemplateConfig();
テンプレートの情報取得

*Xlsx.OpenBook(filename, @"e:\book1.xlsx");
ワークブックオープン(オープンするファイル名, オーバーレイ元ファイル名)

*Xlsx.SheetNo = Xlsx.SheetNo2["Sheet1"];
ワークシート設定

*excelEC.Xlsx.Pos[sx:0, sy:1].Value = "test";
セル書込

*var cellValue1 = excelEC.Xlsx.Pos[sx: 0, sy: 1].Value;
セル読取(R1C1形式)

*var cellValue2 = excelEC.Xlsx.Cell["A2"];
セル読取("A1"形式)

*excelEC.Xlsx.Cell["A1:C3"].Attr.Box(XlsxCrt.XLSX_BORDERSTYLE.xbsThin, XlsxCrt.XLSX_BOXTYPE.xbtBox, XlsxCrt.XLSX_COLOR.xclRed);
罫線を引く("A1:C3"に、実線、箱型、赤色で)


*return 3;
戻り値を返す命令


*public void ConfigureServices(IServiceCollection services)*{services.AddRazorPages();services.AddDbContext<RazorPagesMovieContext>(options =>options.UseSqlite(Configuration.GetConnectionString("MovieContext")));}
This method gets called by the runtime. Use this method to add services to the container.


*timer = CreateTimer();
タイマー生成

*var t = new DispatcherTimer(DispatcherPriority.SystemIdle);
タイマー生成(湯煎度はアイドル時に設定)

*t.Interval = TimeSpan.FromMilliseconds(300);
タイマーイベントの発生間隔を300ミリ秒に設定

*t.Tick += (sender, e) =>*{//タイマーイベントの発生時の処理をここに書く//　現在の時分秒をテキストに設定TextBlock.Text = DateTime.Now.ToString("HH:mm:ss");};
タイマーイベントの定義

*TextBlock.Text = DateTime.Now.ToString("HH:mm:ss");
タイマーイベントの発生時の処理をここに書く
現在の時分秒をテキストに設定

*return t;
生成したタイマーを返す

*timer.Start();
タイマー開始


*Employee empl_1 = new Employee("ichiro", 25, 123456, "system");
インスタンスを生成


*string url = String.Concat("http:
0.0.0.0:", port);

*// For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940*public void ConfigureServices(IServiceCollection services)
This method gets called by the runtime. Use this method to add services to the container.

*public void ConfigureServices(IServiceCollection services)*{}
For more information on how to configure your application, visit https:go.microsoft.com/fwlink/?LinkID=398940

*public void Configure(IApplicationBuilder app, IWebHostEnvironment env)*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}app.UseRouting();app.UseEndpoints(endpoints =>{endpoints.MapGet("/", async context =>{var target = Environment.GetEnvironmentVariable("TARGET") ?? "World";await context.Response.WriteAsync($"Hello {target}!\n");});});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.


*#region "IDisposable Support"
Dispose処理は、下記のページを参考にしています。
[アンマネージドリソースをDisposeパターンで管理する]
(https:days-of-programming.blogspot.com/2018/04/dispose.html)

*}
TODO: Managed Objectの破棄

*_application = new Application(){非表示Visible = trueVisible = false};
Excelアプリケーション生成

*Visible = trueVisible = false};
非表示

*Visible = false};
Visible = true

*_workbook = _application.Workbooks.Open(@"e:\book1.xlsx");
Bookを開く

*_worksheet = _workbook.Worksheets["Sheet1"];
対象シートを設定する

*_workbook.SaveCopyAs(@"e:\book2.xlsx");
ファイル名を指定して保存する

*var cells = _worksheet.Cells;
セルを指定

*range.Value = value;
値を設定

*Marshal.ReleaseComObject(range);
cell解放

*var fileInfo = new FileInfo(@"e:\book1.xlsx");
Excelファイルを開く

*_excelWorksheet = _excelPackage.Workbook.Worksheets["Sheet1"];
シート名で参照

*_excelWorksheet.Cells[row, col].Value = value;
値を書込

*_excelWorksheet.Cells[address].Value = value;
値を書込

*return _excelWorksheet.Cells[row, col].Value;
セル読取

*return _excelWorksheet.Cells[address].Value;
セル読取

*return (object[,])_excelWorksheet.Cells[rowFrom, colFrom, rowTo, colTo].Value;
レンジ読取

*return (object[,])_excelWorksheet.Cells[addresso].Value;
レンジ読取

*excelEx.WriteCell(row: 1, col: 1, value : "test");
セル書込(R1C1形式)

*excelEx.WriteCell(address: "A1", value: 3.1415926538);
セル書込("A1"形式)

*var cellValue1 = excelEx.ReadCell(row: 1, col: 1);
セル読取(R1C1形式)

*var cellValue2 = excelEx.ReadCell("A1");
セル読取("A1"形式)

*var rangeValue1 = excelEx.ReadRange(rowFrom: 1, colFrom: 1, rowTo: 2, colTo: 2);
レンジ読取(R1C1R2C2形式)

*var rangeValue2 = excelEx.ReadRange("A1:B2");
レンジ読取("A1:B2"形式)

*if (excelEx.SaveAs(@"e:\book2.xlsx") == false)
２次元配列(0始まり)から要素を参照
var a = rangeValue2[0, 0];     aには、3.1415926538が入る
名前を付けて保存する


*this.Controls.Add(pdfOcx);
フォームにコントロールを追加

*pdfOcx.LoadFile(@"E:\test.pdf");
PDF ブラウザコントロールに指定したPDFファイルを表示する


*var files = (string[])e.Data.GetData(DataFormats.FileDrop, false);
DataFormats.FileDropを与えて、GetDataPresent()メソッドを呼び出す。

*for (int i = 0; i < files.Length; i++) {
GetDataの戻り値はstring型の配列であり、
複数のファイルがドロップされた場合には
ドロップされた複数のファイル名が取得できる。

*var fileName = files[i];
GetDataにより取得したString型の配列から要素を取り出す。

*if (e.Data.GetDataPresent(DataFormats.FileDrop))
マウスポインター形状変更

DragDropEffects
Copy  :データがドロップ先にコピーされようとしている状態
Move  :データがドロップ先に移動されようとしている状態
Scroll:データによってドロップ先でスクロールが開始されようとしている状態、あるいは現在スクロール中である状態
All   :上の3つを組み合わせたもの
Link  :データのリンクがドロップ先に作成されようとしている状態
None  :いかなるデータもドロップ先が受け付けようとしない状態


*void Start()*{/* OCRハンドラの作成と初期化 */ocrHandle = IntPtr.Zero;ocrHandle = TessBaseAPICreate();if(ocrHandle.Equals(IntPtr.Zero)) Debug.Log("Error:Cannot Create");string dataPath = Application.dataPath + "/tessdata";if(TessBaseAPIInit3(ocrHandle, dataPath, "eng") != 0) Debug.Log("Error:Cannot Init");/* テクスチャから文字を認識する */string recognition = RecognizeFromTexture();output.GetComponent<Text>().text = recognition;}
Start is called before the first frame update


*var ans = await？？？ table.Select(async？？？(x) => ？？？);
どうやって書けばいい？
ここでansを計算して、awaitで待って、この後にansを表示させるなどしたい。

*await Task.Delay(1000);
非同期版の計算メソッド

*var ans = await Task.WhenAll(table.Select(async (x) => await Add100(x)));
★★数値tableに100を足す計算をSelectで行い、それをTask.WhenAllで包む★★

*private async Task<int> Add100(int a)*{Debug.WriteLine($"input is {a}. Start Calc...");await Task.Delay(1000);Debug.WriteLine($"input is {a}. End Calc.");return a + 100;}
100加算して返す(実験的に5秒待つ)


*itemBoxImages[index].sprite = null;
index番目に何も表示しない


*image.sprite = lightOFF;
imageの画像をlightOFFにする


*var column = Columns[order.Column].Data;
Orderのインデックス(Columnプロパティ)から、Columnオブジェクトを得る

*var direction = Enum.Parse<OrderDirection>(System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(order.Dir))
Orderのソート順(Dirプロパティ)から、Enumとして得る


*capture = new VideoCapture(0);
カメラ画像取得用のVideoCapture作成

*frame = new Mat(HEIGHT, WIDTH, MatType.CV_8UC3);
取得先のMat作成

*bmp = new Bitmap(frame.Cols, frame.Rows, (int)frame.Step(), System.Drawing.Imaging.PixelFormat.Format24bppRgb, frame.Data);
表示用のBitmap作成

*pictureBox1.Width = frame.Cols;
PictureBoxを出力サイズに合わせる

*graphic = pictureBox1.CreateGraphics();
描画用のGraphics作成

*backgroundWorker1.RunWorkerAsync();
画像取得スレッド開始

*graphic.DrawImage(bmp, 0, 0, frame.Cols, frame.Rows);
描画

*capture.Grab();
画像取得

*backgroundWorker1.CancelAsync();
スレッドの終了を待機

*Cv2.ImShow("test1", frame);
保存されたキャプチャ画像の出力


*isOnce = false;
処理内容

*Three++;
処理内容


*IDictionary<string, string> refs = GetReferences("CodeGenerationSample");
CodeGenerationSample プロジェクトの参照アセンブリの名前とパスを取得


*agent.GetComponent<AgentController>().className = belongs;
所属しているクラスの情報をAgentControllerに渡す


*var animator = HandBones[0].GetComponent<Animator>();
Animator からボーン情報を持ってきたいので、Animator を取得

*HandBones = new Transform[(int) Bones.NumOfHI5Bones];*//左手と右手で取得すべきボーンが違うから判定
念の為初期化


*ptr[y*bd.Stride + 4*x + 3] = 0;
alpha = 0 (透過)


*void Update()*{transform.Rotate(new Vector3(15,30,45) * Time.deltaTime);}
Update is called once per frame


*destination = GameObject.Find("1-1");
目的地に設定した部屋名を指定

*agent.SetDestination(destination.transform.position);*}
目的地を指定(目的地のオブジェクトの位置情報を渡す）


*return Vector3.Cross(tmp1, tmp2);
Vector3.Crossは外積を求めるメソッド

*private bool WhetherIntersectionIsInsidePolygon(Vector3[] vertices, Vector3 intersection, Vector3 normal) {float angle_sum = 0f;for (int i = 0; i < vertices.Length; i++) {Vector3 tmp1 = vertices[i] - intersection;Vector3 tmp2 = vertices[(i + 1) % vertices.Length] - intersection;float angle = Vector3.Angle(tmp1, tmp2);Vector3 cross = Vector3.Cross(tmp1, tmp2);if (Vector3.Dot(cross, normal) < 0) angle *= -1;angle_sum += angle;}angle_sum /= 360f;return Mathf.Abs(angle_sum) >= 0.1f;}
このメソッドは引用させていただきました


*slider = EditorGUILayout.Slider("Scale In Lightmap", slider, 0, 20);
ここでScale In Lightmapの値を設定

*if (GUILayout.Button("Change all Scale In Lightmap"))
Scale In Lightmap一括変更ボタン
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

*source = EditorGUILayout.ObjectField(source, typeof(LightmapParameters), true);
ここでLightmapParametersを選択

*if (GUILayout.Button("Change all LightmapParameters"))
LightmapParameters一括変更ボタン
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

*isOn =  EditorGUILayout.Toggle("Stitch Seams", isOn);
ここでStitch Seamsを選択

*if (GUILayout.Button("Change all Stitch Seams"))
Stitch Seams一括変更ボタン
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

*if (GUILayout.Button("All Apply"))
一括変更ボタン
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

*ChangeScaleInLightmap(selectionObj);
全部いっぺんにするだけ


*Debug.Log("キックされました。");
退室ボタンを押していないが退室した→つまりキックされた


*protected const int VK_SHIFT = 0x10;
SHIFTキー

*return base.HookProcedure(nCode, wParam, lParam);
この処理で発生したキーイベントは処理しない

*num = 1;
ESCに変換

*if (prevKeyDownCode == 91)*//if(GetKeyState(91) < 0)
0x09                         F9 91(VK_LWIN)→9(VK_TAB)の順番

*{num = 1;inp = new INPUT[num];inp[0].type = INPUT_KEYBOARD;inp[0].ki.wVk = (short)VK_F9;inp[0].ki.wScan = (short)MapVirtualKey(inp[0].ki.wVk, 0);inp[0].ki.dwFlags = KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYDOWN;inp[0].ki.dwExtraInfo = dwExtraInfoNumber;inp[0].ki.time = 0;}
if(GetKeyState(91) < 0)

*return base.HookProcedure(nCode, wParam, lParam);
この処理で発生したキーイベントは処理しない

*num = 1;
ESCに変換


*}).ToArray();
無理矢理。。


*var csvData = ...;
Csv のデータ


*Console.WriteLine(sp.IntColumn);
データベースで生成された値がセット済み。


*var bitmap = new Bitmap(1280, 200);
※using、Dispose文は省略

*bitmap.MakeTransparent();
透過

*var graphics = Graphics.FromImage(bitmap);
BitmapからGraphicsを生成

*stringFormat.FormatFlags = StringFormatFlags.NoWrap;
どんなに長くて単語の区切りが良くても改行しない

*stringFormat.Trimming = StringTrimming.None;
どんなに長くてもトリミングしない

*graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;
ハイクオリティレンダリング

*graphics.SmoothingMode = SmoothingMode.HighQuality;
アンチエイリアスをかける

*var gp = new GraphicsPath();
GraphicsPathを生成

*gp.AddString("山路を登りながら、智に働けば角が立つ。", new FontFamily("メイリオ"), 0, 46, new Point(8, 8), stringFormat);
パスに文字を追加

*graphics.DrawPath(new Pen(Color.Black, 16), gp);
縁取りをする。

*graphics.FillPath(new SolidBrush(Color.White), gp);
文字を塗りつぶす。

*bitmap.Save("D:\\result.png", System.Drawing.Imaging.ImageFormat.Png);
テスト用にBitmapの内容をD:\result.pngに出力


*itemBoxImages[index].sprite = null;
index番目に何も表示しない


*public void OnClickBackTrigger()*{lightStandPanel.SetActive(false);drawerPanel.SetActive(false);pcPanel.SetActive(false);}
ボタンを押したらパネルを全て非表示


*bar();
任意の処理


*public void OnClickImage()*{LightBulbPanel.SetActive(false);alertText.SetActive(false);}
電球の画像をクリックすると電球画像を非表示にする

*public void OnClickTrigger()
引き出しが押されたら
1.電球の画像をだす
2.Textをだす

*public void OnClickImage()*{LightBulbSetActive(false);}
電球の画像をクリックすると電球画像を非表示にする


*pcPanel.SetActive(true);
PCパネルをアクティブにする


*Type executorType =Type.GetType(typeName);
スプレッドシートで型名を文字列で管理し、ScriptableObject.CreateInstanceした際に型名からインスタンス化させようとしている
なお直接 Executor = new PhysicExecutor(); としてもポリモーフィズムが働かないのは変わらない


*public void AutoSelectStart()*{StartCoroutine(AutoSelectStartCoroutine());}
Startボタン押したら呼ばれる

*IEnumerator AutoSelectStartCoroutine()*{for(int i = 0; i < m_levelGetFromSlider.GetLevel(); i++){yield return new WaitForSeconds(m_interval);//ここでどれが選ばれるかランダムに決めるm_randomValue = Random.Range(0, m_tmpListObj.Count);//選ばれたときのイベント呼び出しm_tmpListObj[(int)m_randomValue].GetComponent<PanelSelectedEvent>().BlinkPanel();m_tmpListObj[(int)m_randomValue].GetComponent<PanelSelectedEvent>().CorrectSoundPlay();//選んだオブジェクトをリスト化するg_listObj.Add(m_tmpListObj[(int)m_randomValue]);}}
レベルに応じて自動で選ばれる回数を変える

*m_randomValue = Random.Range(0, m_tmpListObj.Count);
ここでどれが選ばれるかランダムに決める

*m_tmpListObj[(int)m_randomValue].GetComponent<PanelSelectedEvent>().BlinkPanel();
選ばれたときのイベント呼び出し

*g_listObj.Add(m_tmpListObj[(int)m_randomValue]);
選んだオブジェクトをリスト化する

*public void  ToNextSelect()*{//ここでどれが選ばれるかランダムに決めるm_randomValue = Random.Range(0, m_tmpListObj.Count);//選ばれたときのイベント呼び出しm_tmpListObj[(int)m_randomValue].GetComponent<PanelSelectedEvent>().BlinkPanel();//選んだオブジェクトをリスト化するg_listObj.Add(m_tmpListObj[(int)m_randomValue]);}
レーザーで選んだら次が光ってリストを更新

*m_randomValue = Random.Range(0, m_tmpListObj.Count);
ここでどれが選ばれるかランダムに決める

*m_tmpListObj[(int)m_randomValue].GetComponent<PanelSelectedEvent>().BlinkPanel();
選ばれたときのイベント呼び出し

*g_listObj.Add(m_tmpListObj[(int)m_randomValue]);
選んだオブジェクトをリスト化する

*int m_playTime = 10;
このスクリプトはパネルにアタッチされたスクリプトです
何回選ぶか　エンドレスモードがあればここをめちゃくちゃでかい数字に変えればOK

*PanelSelected m_panelSelected;
先程のリストを取ってくる

*public void IncrementSelectedCount()*{if (m_selectedCount < m_playTime){if (m_panelSelected.g_listObj[m_selectedCount] == this.gameObject){m_panelSelected.ToNextSelect();CorrectSoundPlay();m_selectedCount++;}else{WrongSoundPlay();}}else{if (m_panelSelected.g_listObj[m_selectedCount] == this.gameObject){CorrectSoundPlay();m_selectedCount++;if (m_selectedCount == m_playTime + m_levelGetFromSlider.GetLevel()){//ここにクリア時の処理m_clear.ClearTextAppear();}}else{WrongSoundPlay();}}}
選んだものが同じかどうか判定して選択カウント増加

*m_clear.ClearTextAppear();
ここにクリア時の処理


*JabHelpers.AccessibleTreeItem txt = javaTree.children[0].children[1].children[0].children[0].children[1];
テキスト設定

*JabHelpers.DoAccessibleActions(vmID, button.acPtr, "クリック");
クリック実行

*Console.WriteLine("リスト一覧-------------");
リストの内容

*// https://stackoverflow.com/questions/50582769/windowsaccessbridge-for-java-automation-using-c-sharp*public static void Init()
Windows_runはメッセージポンプが必要

*public static void Init()*{JabApi.Windows_run();DoEvents();}
https:stackoverflow.com/questions/50582769/windowsaccessbridge-for-java-automation-using-c-sharp


*Console(a%b)
1


*private BannerView bannerView;
〜〜省略〜〜

*public void BannerHide()*{if (bannerView != null){bannerView.Hide();bannerView.Destroy();//〜〜省略〜〜,,,
*var spriteAssets = await Addressables.LoadAssetsAsync<Sprite> ("Sprites", null).Task.ConfigureAwait (false);
ラベルを指定して一括ロード

*var image = Instantiate (imagePrefab, transform).GetComponent<Image> ();*var text = Instantiate (textPrefab, transform).GetComponent<Text> ();
プレファブからオブジェクトを生成

*}*private async Task loader () {// ～,,,private IEnumerator Start () {yield return StartCoroutine (loader ());// 次の処理},,,/// <summary>タスク拡張</summary>public static class TaskEx {/// <summary>休止間隔</summary>private const int Tick = 16;/// <summary>1フレーム待機</summary>public static Task DelayOneFrame => Task.Delay (Tick);/// <summary>条件が成立する間待機</summary>public static async Task DelayWhile (Func<bool> predicate) {while (predicate ()) {await Task.Delay (Tick);}}/// <summary>条件が成立するまで待機</summary>public static async Task DelayUntil (Func<bool> predicate) {do {await Task.Delay (Tick);} while (!predicate ());}},,,*,,,*private IEnumerator Start () {yield return StartCoroutine (loader ());// 次の処理},,,/// <summary>タスク拡張</summary>public static class TaskEx {/// <summary>休止間隔</summary>private const int Tick = 16;/// <summary>1フレーム待機</summary>public static Task DelayOneFrame => Task.Delay (Tick);/// <summary>条件が成立する間待機</summary>public static async Task DelayWhile (Func<bool> predicate) {while (predicate ()) {await Task.Delay (Tick);}}/// <summary>条件が成立するまで待機</summary>public static async Task DelayUntil (Func<bool> predicate) {do {await Task.Delay (Tick);} while (!predicate ());}},,,*}
次の処理


*Debug.Log("ボタンが押されたよ！！");
コンソールに表示


*var sortedPairs = itemWeightPairs.OrderByDescending(x => x.Value).ToArray();
Weight降順でソート

*float total = sortedPairs.Select(x => x.Value).Sum();
ドロップアイテムの抽選

*public static T Lotto<T>(IEnumerable<T> itemWeightPairs) where T : IHaveWeight*{// Weight順でソートvar sortedPairs = itemWeightPairs.OrderByDescending(x => x.Weight).ToArray();// ドロップアイテムの抽選float total = sortedPairs.Select(x => x.Weight).Sum();float randomPoint = Random.Range(0, total);// randomPointの位置に該当するキーを返すforeach (T elem in sortedPairs){if (randomPoint < elem.Weight){return elem;}randomPoint -= elem.Weight;}return sortedPairs[sortedPairs.Length - 1];}
interface利用

*var sortedPairs = itemWeightPairs.OrderByDescending(x => x.Weight).ToArray();
Weight順でソート

*float total = sortedPairs.Select(x => x.Weight).Sum();
ドロップアイテムの抽選

*public class Item : IHaveWeight*{public string Name;private float _weight;public float Weight => _weight;public Item(string name, float weight){Name = name;_weight = weight;}}
IHaveWeightを継承する！！


*public DbSet<Member> Members { get; set; }
public myopContext (DbContextOptions options) : base(options) {}

*[HttpGet("{id}")]
GET: Members/5

*[HttpPut("{id}")]
PUT: Members/5

*[HttpDelete("{id}")]
DELETE: Members/5

*public void ConfigureServices(IServiceCollection services)*{services.AddDbContext<myopContext>(options => options.UseSqlite("Data Source=members.db"));services.AddControllers();}
This method gets called by the runtime. Use this method to add services to the container.


*return View();
ビューをそのまま返している

*[HttpGet] public IActionResult Edit() => View();
画面表示時に呼ばれる

*[HttpPost] public IActionResult Edit(EditViewModel vm) {if (ModelState.IsValid) {/** データベースへの登録処理とか */}return View();}
フォームの送信で呼ばれる


*public DbSet<Member> Members { get; set; }
public MvcBasicContext (DbContextOptions options) : base(options) {}


*if (i * i == n) return EnumResult.Success;
結果の整数が返せない


*RegistryKey regKey = rootKey.OpenSubKey(keyname, true);
書き込み権限で開く


*branches = new List<Branch>();
樹形図の「枝」を作る。

*bmp.Save(filePath, System.Drawing.Imaging.ImageFormat.Png);
画像をPNG形式で保存する。


*token.Register(() => utcs.TrySetCanceled());
CancellationToken対応

*void HogeCB(string input, Action<bool> onResult)*{callback = onResult;Invoke("AfterWait", 3.0f);}
コールバック方式の非同期メソッドの例


*currentPieceIndex = keyPieces.Count;
範囲外を設定する

*try {lines = File.ReadAllLines(keyLayoutFileNameUTF8);}
雑だが例外処理でファイル有無も併せて判定していく

*Regex r = new Regex(@"^([0-9]+) (undefi|0x[0-9A-Fa-f]+) (undefi|0x[0-9A-Fa-f]+) ([\x21-\x5a\x5c\x5e-\x7e]+)$");*foreach ( string s in lines ) {if ( s.Trim() == String.Empty ) {continue;}Match m = r.Match(s);if ( m.Success ) {int index = Convert.ToInt32(m.Groups[1].Value);string tmpScanCode   = m.Groups[2].Value;string tmpScanCodeFn = m.Groups[3].Value;string tagName       = m.Groups[4].Value;if ( index >= keyPieces.Count ) {return false;}if ( keyPieces[index].TagName != tagName ) {return false;}if ( tmpScanCode.StartsWith("0x") ) {ushort scanCode = (ushort)Convert.ToInt32(tmpScanCode, 16);keyPieces[index].SetScanCode(scanCode, false);}else {keyPieces[index].ClearScanCode(false);}if ( tmpScanCodeFn.StartsWith("0x") ) {ushort scanCodeFn = (ushort)Convert.ToInt32(tmpScanCodeFn, 16);keyPieces[index].SetScanCode(scanCodeFn, true);}else {keyPieces[index].ClearScanCode(true);}}else{Console.WriteLine("unmatch \""+s+"\"");//return false;}}
長さのガードを入れるべきだが面倒なのでそのまま


*var fieldEditorWindow = FieldEditorWindow.GetCurrent();
たとえば、このように、特定のエディタが開いているかどうかで分岐をつくり、

*stringProp.stringValue = EditorGUI.TextField(rect, label, stringProp.stringValue);
通常はただのテキストフィールド

*var actorRepository = fieldEditorWindow.GetActorRepository();
選択対象のオブジェクトをシーンから選択できる場合は、がんばってドロップダウンを出す

*var selectedIndex = EditorGUI.Popup(popupRect, Array.IndexOf(ids, stringProp.stringValue), actorNames);
シーン上のオブジェクトから選択するとかできます
Draw popup

*protected virtual void OnTrackStart(Playable playable)*{}
トラックの最初のフレームで呼ばれる

*protected virtual void OnClipEnable(Playable playable, int enabledIndex, float weight)
あるクリップが再生された最初のフレームで呼ばれる
エディタ上では、指しているクリップが代わった場合に都度呼ばれる

*protected virtual void OnClipDisable(Playable playable, int disabledIndex)
クリップのあるフレームから、クリップのないフレームへ移った場合に呼ばれる
エディタ上では、指しているクリップがなくなった場合に都度呼ばれる

*protected virtual void OnClipEnded(Playable inputPlayable)*{}
あるクリップの最後のフレームで呼ばれる


*public DbSet<Member> Members { get; set; }
public MvcBasicContext (DbContextOptions options) : base(options) {}

*public void ConfigureServices(IServiceCollection services)*{services.AddDbContext<MvcBasicContext>(options => options.UseSqlite("Data Source=members.db"));services.AddControllersWithViews();}
This method gets called by the runtime. Use this method to add services to the container.


*param.Add("TargetData", Visibility.Visible);
パラメータをkeyとvalueの組み合わせで追加

*RegionNavigationService.RequestNavigate(nameof(SelectScreen), param);
第二引数にパラメータを渡すと、viewが切り替わった先でパラメータを受け取る

*ViewboxSampleVisibility = (Visibility)navigationContext.Parameters["TargetData"];
Camera画面から受け取ったパラメータを照合してバインドさせる


*cosTheta = Mathf.Cos(theta);
回転角のcosを計算

*this.transform.position = new Vector3(A * sinTheta, height, -A * cosTheta);*//カメラの方向の代入
カメラの位置の代入

*this.transform.forward = new Vector3(-sinTheta, 0.0f, cosTheta);*}
カメラの方向の代入


*,,,
Labelを作成し、そこに出力するサンプル
label.Content = "(x, y) = ("+ p.X +", "+ p.Y +")";  p.X, p.Yで取得できます。


*string JsonStr = wc.DownloadString(@"https:
www.jma.go.jpbosaiforecastdataoverview_week130000.json");

*class jsonweather*{public string publishingOffice { get; set; }public string reportDatetime { get; set; }public string targetArea { get; set; }public string headlineText { get; set; }public string text { get; set; }}
天気概況（明後日まで）用のクラス

*class jsonweek*{public string publishingOffice { get; set; }public string reportDatetime { get; set; }public string headTitle { get; set; }public string text { get; set; }}
天気概況（週間）用のクラス


*string url = "http:
weather.livedoor.comforecastwebservicejsonv1?city=130010";

*HttpClient client = new HttpClient();
HttpClientインスタンス作成(using System.Net.Http;を忘れないこと)

*string result = client.GetStringAsync(url).Result;
Get通信して結果を文字列として取得

*//Console.WriteLine(result);*//今回はルートが{で始まるオブジェクトなのでJObject.Parse,ルートが配列の場合はJArray.Parseを用いる//(using Newtonsoft.Json.Linq;を忘れないこと)JObject jobj = JObject.Parse(result);//表示してみる//Console.WriteLine(jobj);//jobjが持つforecastsは配列なので以下のようにその配列部分を取得する。JArray jarr = (JArray)jobj["forecasts"];//jarrに入っているのはオブジェクトなので以下のようなforeachで回すforeach(JObject f in jarr) {//fとして取り出したJObjectのdateLabelは文字列なのでstringでキャストしてあげるstring dateLabel = (string)f["dateLabel"];//確認してみる//Console.WriteLine(dateLabel);string telop = (string)f["telop"];string date = (string)f["date"];Console.WriteLine($"{dateLabel}({date})...{telop}");}}
表示

*//今回はルートが{で始まるオブジェクトなのでJObject.Parse,ルートが配列の場合はJArray.Parseを用いる//(using Newtonsoft.Json.Linq;を忘れないこと)JObject jobj = JObject.Parse(result);//表示してみる//Console.WriteLine(jobj);//jobjが持つforecastsは配列なので以下のようにその配列部分を取得する。JArray jarr = (JArray)jobj["forecasts"];//jarrに入っているのはオブジェクトなので以下のようなforeachで回すforeach(JObject f in jarr) {//fとして取り出したJObjectのdateLabelは文字列なのでstringでキャストしてあげるstring dateLabel = (string)f["dateLabel"];//確認してみる//Console.WriteLine(dateLabel);string telop = (string)f["telop"];string date = (string)f["date"];Console.WriteLine($"{dateLabel}({date})...{telop}");}}
Console.WriteLine(result);

*JObject jobj = JObject.Parse(result);
今回はルートが{で始まるオブジェクトなのでJObject.Parse,ルートが配列の場合はJArray.Parseを用いる
(using Newtonsoft.Json.Linq;を忘れないこと)

*JArray jarr = (JArray)jobj["forecasts"];
表示してみる
Console.WriteLine(jobj);
jobjが持つforecastsは配列なので以下のようにその配列部分を取得する。

*string dateLabel = (string)f["dateLabel"];
fとして取り出したJObjectのdateLabelは文字列なのでstringでキャストしてあげる

*string telop = (string)f["telop"];
確認してみる
Console.WriteLine(dateLabel);


*}
OKも自動で押す場合はこれ
var ipOkButton = (InvokePattern)aeOkButton.GetCurrentPattern(InvokePattern.Pattern);
ipOkButton.Invoke();

*string text = FindTextBlockMatches(aeForm, new Regex("^サーバー(.*)が"));*if ( text != null ) {Console.WriteLine(text);// 下記は ID, PASSWORD に応じて適宜変更。機密管理に注意すること。//  やらかし例：ソースにパスワード埋め込んだままGitHubなどでうっかり公開したりとかInputToCredentialWindow(aeForm, "userid", "password");}
対象サイト(?)のメッセージに応じて適宜変更. 改行とか合わせるのが面倒なので正規表現で探すようにした

*InputToCredentialWindow(aeForm, "userid", "password");
下記は ID, PASSWORD に応じて適宜変更。機密管理に注意すること。
やらかし例：ソースにパスワード埋め込んだままGitHubなどでうっかり公開したりとか


*nums.Length
length


*options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver();
Camel形式


*return true;
すべてのウィンドウを列挙する


*ExtendBoth
3


*private void Start()*{rb = GetComponent<Rigidbody>();}
See also:https:docs.unity3d.com/ja/2019.1/Manual/ExecutionOrder.html


*DataRow[] rows =member.AsEnumerable().OrderBy(x => x["Age"])
Ageを昇順にソート

*rows =member.AsEnumerable().OrderByDescending(x => x["Age"])
Ageを降順にソート

*rows =member.AsEnumerable().OrderBy(x => x["Age"])
複数項目（AgeとAddress）でのソート

*DataRow[] rows =member.AsEnumerable().Where(x => (int)x["Age"] > 20 && (string)x["Address"] == "東京")
AND の場合

*rows =member.AsEnumerable().Where(x => (int)x["Age"] > 20 || (string)x["Address"] == "名古屋")
OR の場合


*var dummy = location.Join(fruits.AsEnumerable(), loc => loc["ID"]
dummyは処置待ち用のダミー。locationの操作が目的


*Console.WriteLine("\n");
Friendly linespacing.


*}
namespace Qiita


*DateTime today = DateTime.Today;
集計日

*DateTime monthStart = new DateTime(today.Year, today.Month, 1);
月初め

*DateTime monthEnd = new DateTime(today.Year, today.Month, 1).AddMonths(1).AddDays(-1);
月終わり

*挿入する箇所.Text = today.ToShortDateString();
日付挿入

*public static long Gcd(long a, long b)*{if (a < b)// 引数を入替えて自分を呼び出すreturn Gcd(b, a);while (b != 0){var remainder = a % b;a = b;b = remainder;}return a;}
ユークリッドの互除法

*return Gcd(b, a);
引数を入替えて自分を呼び出す


*const uint CFS_RECT = 0x0001;
追加コード

*case WM_IME_STARTCOMPOSITION: {//入力コンテキストにアクセスするためのお約束IntPtr hImc = ImmGetContext(this.Handle);//コンポジションウィンドウの位置を設定COMPOSITIONFORM info = new COMPOSITIONFORM();info.dwStyle = CFS_POINT;info.ptCurrentPos.x = 10;info.ptCurrentPos.y = 10;ImmSetCompositionWindow(hImc, ref info);// 追加コード(IMEウィンドウ領域の設定)info.dwStyle = CFS_RECT;info.rcArea._Left = 10;info.rcArea._Top = 10;info.rcArea._Right = 100;info.rcArea._Bottom = 100;ImmSetCompositionWindow(hImc, ref info);//コンポジションウィンドウのフォントを設定//ImmSetCompositionFont(hImc, m_Focus->GetFont()->GetInfoLog());//入力コンテキストへのアクセスが終了したらロックを解除するImmReleaseContext(Handle, hImc);base.WndProc(ref m);break;,,,*IntPtr hImc = ImmGetContext(this.Handle);
入力コンテキストにアクセスするためのお約束

*COMPOSITIONFORM info = new COMPOSITIONFORM();
コンポジションウィンドウの位置を設定

*info.dwStyle = CFS_RECT;
追加コード(IMEウィンドウ領域の設定)

*ImmReleaseContext(Handle, hImc);
コンポジションウィンドウのフォントを設定
ImmSetCompositionFont(hImc, m_Focus->GetFont()->GetInfoLog());
入力コンテキストへのアクセスが終了したらロックを解除する


*migrationBuilder.Sql(sql);
NUMERICからINTへの暗黙的な変換。場合によってはここでコケるかもしれません！

*sql = "drop table Products; ";
古いテーブルを削除

*sql = "alter table Products_temp rename to Products";
新テーブルの名前を変更する

*migrationBuilder.Sql("PRAGMA foreign_keys=true;");*}
外部キーを有効にする


*var client = NotificationHubClient.CreateClientFromConnectionString(connectionString, hubName);*// iOSにタグ指定でJsonデータを送信
クライアントを作成

*var task = client.SendAppleNativeNotificationAsync(payload, tag);*// AndroidもSendFcmNativeNotificationAsyncを使うことで簡単にできそうだが未確認
iOSにタグ指定でJsonデータを送信

*}
AndroidもSendFcmNativeNotificationAsyncを使うことで簡単にできそうだが未確認
～以下略～


*INPUT[] input = new INPUT[2];
struct 配列の宣言

*input[0].mi.dwFlags = MOUSEEVENTF_LEFTDOWN;
左ボタン Down

*input[1].mi.dwFlags = MOUSEEVENTF_LEFTUP;
左ボタン Up

*SendInput(2, input, Marshal.SizeOf(input[0]));
イベントの一括生成


*anime.Rewind("アニメーション名");
0フレーム目に巻き戻す


*public string this[int index]{set{this.data[index] = value;}get{return data[index];}}
アクセス 戻り値 this[型 引数]


*conn = DbConnect();
～～省略～～

*,,,
～～省略～～

*conn = DbConnect();
～～省略～～


*Debug.Log("ルームマスター" + player.IsMasterClient);
ルームマスターならTrur。最初に部屋を作成した場合は、基本的にルームマスターなはず。

*public override void OnJoinRandomFailed(short returnCode, string message) {Debug.Log("入室失敗");//ルームを作成する。PhotonNetwork.CreateRoom(null, RoomOPS); //JoinOrCreateroomと同じ引数が使用可能。nullはルーム名を作成したくない場合roomNameを勝手に割り当てる。}
入室失敗したときに呼び出される動作。

*}
ルームを作成する。
PhotonNetwork.CreateRoom(null, RoomOPS); JoinOrCreateroomと同じ引数が使用可能。nullはルーム名を作成したくない場合roomNameを勝手に割り当てる。

*public override void OnCreateRoomFailed(short returnCode, string message) {Debug.Log("作成失敗");}
ルーム作成失敗したときの動作。


*}
諸々省略

*public ImaginaryRoot():base(null)*{}
結局再帰的にどこかにNullが出てきてしまう

*private sealed class PurgedRoot : ITree*{public ITree Parent => throw new InvalidOperationException("Purged root doesn't have Parent element.");public IReadOnlyList<ITree> Children => throw new InvalidOperationException("Purged root doesn't have Children.");}
パージされたなど弁別したいときは増やせる


*[assembly: AssemblyTitle("Test Target")]
アセンブリに関する一般情報は以下の属性セットをとおして制御されます。
アセンブリに関連付けられている情報を変更するには、
これらの属性値を変更してください。

*[assembly: AssemblyTitle("Test Target")]
アセンブリに関する一般情報は以下の属性セットをとおして制御されます。
アセンブリに関連付けられている情報を変更するには、
これらの属性値を変更してください。


*Debug.Log("aaa¥nbbb");
エスケープシーケンスがどう出力されるか見たかっただけ

*string originstr = "aaa¥nbbbbb";
こっちの変数を使って調べる

*Debug.Log(str.Length);
文字列の長さを調べる

*char chars[] =originstr.ToCharArray();
originstrの中身を、一文字ずつ配列に入れる


*// 簡単に言うとforeachの強化版*// データ集合に対しての検索や集約を簡潔に記述できる。
LINQ

*class Practice10_2
簡単に言うとforeachの強化版
データ集合に対しての検索や集約を簡潔に記述できる。
javaのstreamと同様。

*iIte = intList.Where(s => s <= 3);
Where (3以下の値を取り出す)

*iIte = intList.Select(s => s * s);
Select (データを加工する)

*iIte = intList.Distinct();
Distinct (重複削除)

*iIte = intList.OrderBy(s => Math.Abs(s));
Order By (並び替え 昇順降順)

*iIte = intList
全てを複合できる。
実行順序は上からになる。

*int sum = intList.Sum();
Sum 合計値

*double ave = intList.Average();
Average 平均値

*int count = intList.Count();
Count 要素数

*int max = intList.Max();
Max 最大値

*int min = intList.Min();
Min 最小値


*eventParts += new EventPart(eventManager.Action2);
new演算子を使った書き方も可

*eventParts("");
追加した全てのメソッドを実行する。

*eventParts -= eventManager.Action1;
削除もできる。

*static void Show2(Action<string> action)*{action("");}
匿名メソッド


*class Practice9_2*{static void Main(string[] args){var s = new Sample<int, float>(15, 20.0f);s.Show();s = new Sample<int, float>();s.Show();}}
自前のジェネリッククラス

*class Sample<T1, T2>*{private T1 _item1 { get; set; }private T2 _item2 { get; set; }public Sample(){this._item1 = default(T1);this._item2 = default(T2);}public Sample(T1 t1, T2 t2){this._item1 = t1;this._item2 = t2;}public void Show (){Console.WriteLine(_item1.ToString());Console.WriteLine(_item2.ToString());}public (T1, T2) getT(){return (_item1, _item2);}}
ジェネリックなクラスを定義する。


*class Practice9_1*{static void Main(string[] args){// Enum -> 数値long i = (long)Season.Autumn;// 数値 -> Enum型Season s = (Season)Enum.Parse(typeof(Season), i.ToString());Console.WriteLine(i);Console.WriteLine(s);}}
enum

*long i = (long)Season.Autumn;
Enum -> 数値

*Season s = (Season)Enum.Parse(typeof(Season), i.ToString());
数値 -> Enum型


*class Practice8_3*{static void Main(string[] args){Parent p = new Child();p.Show();p.Run();// Is - newしたクラスと一致するかどうか。if (p is Child){}// As - ダウンキャストに失敗した場合，nullになる。// 通常のキャスト (ClassXX)ではキャスト失敗時に例外が発生する。var x = p as Sister;}}
new, virtual - override, abstruct , is, as

*var x = p as Sister;
As - ダウンキャストに失敗した場合，nullになる。
通常のキャスト (ClassXX)ではキャスト失敗時に例外が発生する。

*public virtual void Run()*{Console.WriteLine("親が走る。");}
オーバーライドを許可

*public abstract void Jump();
オーバーライドを強制

*sealed class Child : Parent*{// Overrideできない。(原則使用禁止。)public new void Show(){Console.WriteLine("child");}// Overrideが可能。(しなくてもよい)public override void Run(){Console.WriteLine("子が走る。");}// Overrideが必須。public override void Jump(){}}
sealedで継承不可にする。(javaでいうfinal)

*public new void Show()*{Console.WriteLine("child");}
Overrideできない。(原則使用禁止。)

*public override void Run()*{Console.WriteLine("子が走る。");}
Overrideが可能。(しなくてもよい)

*public override void Jump()*{}
Overrideが必須。


*class Practice8_2*{static void Main(string[] args){// プロパティを介してprivateな変数にアクセスできる。Sample s = new Sample();s.Param1 = 10;int n = s.Param1;FreeArray array = new FreeArray(10);array[3] = 10;}}
インデクサ

*Sample s = new Sample();
プロパティを介してprivateな変数にアクセスできる。

*private int[] _list;
プロパティの配列版
配列にアクセスした際の挙動を決める。

*private int GetIndex(int index)*{return ++index;}
引数で渡したインデックスの次のインデックスを返却する。


*class Practice8_1*{static void Main(string[] args){// プロパティを介してprivateな変数にアクセスできる。Sample s = new Sample();s.Param1 = 10;int n = s.Param1;}}
プロパティ

*Sample s = new Sample();
プロパティを介してprivateな変数にアクセスできる。

*public int Param1*{set{this._param1 = value;}get{return this._param1;}}
SetterとGetterを定義する。

*public int Param2 { get; set; }
自動プロパティ

*public int Param3 { get; private set; }
読み取り専用


*static void Main(string[] args)*{// 参照渡しの場合はrefを書く。(C++の &に相当)int n = 10;Increment(ref n);// 戻り値のデータを書き換えることで配列の値も変わる。var data = new int[] { 10, 20, 30 };int data_0 = Decrement(data);ref int data_1 = ref Decrement(data);data_1 = 40;// out引数による戻り値の設定。int n1 = 100;int n2 = 100;Devide(out n1, out n2);// tupleによる戻り値の設定。(int x, int y, int z) r = ReturnTupple();(var x1, var y1, var z1) = ReturnTupple();var (x2, y2, z2) = ReturnTupple();// tupleによる代入var axis = (100, 200, 300);int sum = axis.Item1 + axis.Item2 + axis.Item3;// 匿名型(名前付きtupleのようなものでreadonly)var tokumei = new { param1 = 1, param2 = "2" };// tokumei.param1 = 10; // エラーになる。}
ref, out , tuple, 匿名型

*int n = 10;
参照渡しの場合はrefを書く。(C++の &に相当)

*var data = new int[] { 10, 20, 30 };
戻り値のデータを書き換えることで配列の値も変わる。

*int n1 = 100;
out引数による戻り値の設定。

*(int x, int y, int z) r = ReturnTupple();
tupleによる戻り値の設定。

*var axis = (100, 200, 300);
tupleによる代入

*var tokumei = new { param1 = 1, param2 = "2" };
匿名型(名前付きtupleのようなものでreadonly)

*}
tokumei.param1 = 10;  エラーになる。

*static void Increment(ref int n)*{n++;}
値の参照渡し

*static ref int Decrement(int[] data)*{data[0]--;return ref data[0];}
戻り値の参照渡し

*static void Devide(out int n1, out int n2)*{n1 = 10;n2 = 20;}
outによる複数の戻り値の設定。

*static (int r1, int r2, int r3) ReturnTupple()*{return (10, 20, 30);}
tupleによる複数の戻り値の設定。


*int Sum(int a, int b) { return a + b; }
ローカル関数


*doc = await parser.ParseDocumentAsync(sorce);
ここが変わっています!!

*ZipFile.ExtractToDirectory(<保存するファイル名（絶対パスで）>, <解凍先フォルダー名>);
ZIPファイルを解凍します


*var products = db.Query<Product>("Select * From Product")
以下と同じ


*string localIpString = "自分のIPアドレス";
バインドするローカルIPとポート番号

*System.Net.IPEndPoint localEP =new System.Net.IPEndPoint(localAddress, localPort);
UdpClientを作成し、ローカルエンドポイントにバインドする

*System.Net.IPEndPoint remoteEP = null;
データを受信する

*string rcvMsg = System.Text.Encoding.UTF8.GetString(rcvBytes);
データを文字列に変換する

*if (RcvMsg[0] =="exit")
受信したデータと送信者の情報を表示する
"exit"を受信したら終了

*udp.Close();
UdpClientを閉じる


*void Start()
↑↑↑↑_AnimatorのLayer番号
VR Motion Recorderでは3番がまばたき用のLayerとなっている
(0, 1, 2, 3, ...と数えるから、実際は4番目のLayer)
扱う_Animatorによって適切に設定すること
AnimatorのLayer機能については前の記事(冒頭に紹介した記事)を参照のこと

*StartCoroutine("AutoBlinkCoroutine");
まばたきループ開始

*private void Update()*{if (isBlink){// isBlink = trueならweightを1にもっていく// 0.05secかけてweightを1にするweight = Mathf.SmoothDamp(weight, 1, ref velocity, 0.05f);}else{// isBlink = falseならweightを0にもっていく// 0.05secかけてweightを0にするweight = Mathf.SmoothDamp(weight, 0, ref velocity, 0.05f);}// AnimatorのLayerのウェイトを更新_Animator.SetLayerWeight(Layer, weight);}
_Animatorのweightを毎フレーム更新する

*weight = Mathf.SmoothDamp(weight, 1, ref velocity, 0.05f);
isBlink = trueならweightを1にもっていく
0.05secかけてweightを1にする

*weight = Mathf.SmoothDamp(weight, 0, ref velocity, 0.05f);
isBlink = falseならweightを0にもっていく
0.05secかけてweightを0にする

*_Animator.SetLayerWeight(Layer, weight);
AnimatorのLayerのウェイトを更新

*IEnumerator AutoBlinkCoroutine()*{//無限ループwhile (true){//まばたき1回目。単発でまばたきをする。yield return new WaitForSeconds(OnceBlinkTime_1);isBlink = true;yield return new WaitForSeconds(CloseTime);isBlink = false;//まばたき2回目。単発でまばたきをする。yield return new WaitForSeconds(OnceBlinkTime_2);isBlink = true;yield return new WaitForSeconds(CloseTime);isBlink = false;//まばたき3回目。ここでは2回連続でまばたきをする。yield return new WaitForSeconds(TwiceBlinkTime_3);isBlink = true;yield return new WaitForSeconds(CloseTime);isBlink = false;yield return new WaitForSeconds(CloseTime);isBlink = true;yield return new WaitForSeconds(CloseTime);isBlink = false;}}
「コルーチン」で呼び出すメソッド

*yield return new WaitForSeconds(OnceBlinkTime_1);
まばたき1回目。単発でまばたきをする。

*yield return new WaitForSeconds(OnceBlinkTime_2);
まばたき2回目。単発でまばたきをする。

*yield return new WaitForSeconds(TwiceBlinkTime_3);
まばたき3回目。ここでは2回連続でまばたきをする。


*class Meteor:Enemy
Enemyクラスを継承してMeteorクラスを作る

*public override void Move()*{Console.WriteLine("まっすぐに移動");}
EnemyクラスのMoveメソッドをオーバーライドする

*ufo = new UFO();
インスタンスを生成する

*ufo.Move();
敵を移動する


*public class MyClass*{}
これが MyClass という class

*MyClass mc = new MyClass();
ここでインスタンスになる(Objectになる)

*MyClass mc = new MyClass();
ここでインスタンスになる(Objectになる)

*public class MyClass*{public string ClassName{ get; set; }public int ClassId { get; set; }public MyClass(string name, int id){ClassName= name;ClassId = id;}}
classの中に　プロパティとコンストラクタを定義

*MyClass mc2 = mc;
ここでインスタンスになる(Objectになる)
MyClass mc = new MyClass("hoge",1); Classname = hoge, ClassId = 1 のMyClassインスタンス

*mc2.Classname = "hogehoge";
MyClassは 読み書きできるので mc2を使って変数を変えてみます

*}
参照型なので、mc  mc2のプロパティは下記のようになる
Output
mc.Classname is "hogehoge"
mc.ClassId is 2
mc2.Classname is "hogehoge"
mc2.ClassId is 2


*agent.SetDestination(target.transform.position);
☆追加


*public Transform ballTrans
ターゲットのオブジェクトのトランスフォーム

*Vector3 dir = (ballTrans.position - arrowTrans.position);
向きたい方向を計算

*arrowTrans .rotation = Quaternion.FromToRotation(Vector3.up, dir)},,,
*string path = @"";
CSVファイルのパス


*void Update()*{if (sprites.Length < 1) return;var index = (int)Mathf.Repeat(Time.frameCount * speed / 100, sprites.Length);var renderer = GetComponent<MeshRenderer>();var material = renderer.material;var sprite = sprites[index];var texSize = new Vector2(sprite.texture.width, sprite.texture.height);var rect = sprite.textureRect;material.mainTexture = sprite.texture;material.mainTextureOffset = new Vector2(rect.x/ texSize.x, rect.y / texSize.y);material.mainTextureScale = new Vector2(rect.width / texSize.x, rect.height / texSize.y);material.SetTexture("_MainTex",sprite.texture);material.SetTextureOffset("_MainTex", new Vector2(rect.x, rect.y));material.SetTextureScale("_MainTex", new Vector2(1 / rect.width, 1 / rect.height));renderer.material = material;}
Update is called once per frame

*public Material material;
ドット絵を保持するマテリアル

*private Vector2Int texSize;
マテリアルのメインテクスチャサイズ

*private RectInt spriteRect;
Spriteのテクスチャ領域

*private Vector2Int texSize;
マテリアルのメインテクスチャサイズ

*private RectInt spriteRect;
Spriteのテクスチャ領域

*public string heplMessage;
Inspector 表示用の警告メッセージ

*}
... 中略 ...

*serializedObject.Update();
シリアライズオブジェクトの更新

*serializedObject.ApplyModifiedProperties();*string help = shed.heplMessage;
シリアライズオブジェクトのプロパティの変更を更新

*public override bool HasPreviewGUI()*{return true;}
プレビューウィンドウを表示するかどうか

*public override void OnPreviewSettings()*{ZoomAroundPivot = GUILayout.Toggle(ZoomAroundPivot, "zoom pivot");}
プレビューウィンドウのヘッダーバーをカスタムする関数

*public override void OnPreviewGUI(Rect r, GUIStyle background)*{if (ZoomAroundPivot) _drawAroundPivot(r);else _drawEntire(r);}
プレビューウィンドウで描画させたいものはここで書く

*var maxPos = new Vector2(offsetPos.x + drawSize.x + border * 2, offsetPos.y + drawSize.y + border * 2);
3D投影サイズ境界のx,zを赤と緑の外殻線で描く

*var drawRect = new Rect(offsetPos.x + border, offsetPos.y + border, drawSize.x, drawSize.y);
中央にスプライト領域を描画

*Handles.DrawSolidRectangleWithOutline(new Rect(r.x, r.yMax, hfWidth, border - 1), Color.green, Color.green);
3D投影サイズ境界のx,zを赤と緑の外殻線で描く

*var drawRect = new Rect(r.x, r.y, r.width, r.height - border);
中央にスプライト領域を描画


*int a = "string";
int型にStringを入れようとしている エラー


*void Do<T>(T item)*where T : struct { }
nullを許容しない

*void Do<T>(T? item)*where T : struct { }
引数でnullを許容する

*void Do0<T>(T item)*where T : class { }
型引数も引数もnull不許容参照型

*void Do1<T>(T? item)*where T : class { }
型引数はnull不許容参照型で、引数はnull許容参照型

*void Do2<T>(T item)
型引数がnull許容参照型ならば、引数もnull許容参照型
型引数がnull不許容参照型ならば、引数もnull不許容参照型

*// void Do3<T>(T? item)*//     where T : class? { }
これは書けない

*//     where T : class? { }
void Do3<T>(T? item)

*//void Do<T>(T? item)*//    where T : notnull { }
これは書けない

*//    where T : notnull { }
void Do<T>(T? item)

*,,,*public abstract class Enum : ValueType {}
where T : notnull { }

*enum MyEnum { ... }
独自定義したとする


*Label getFollowerName = new Label();
Labelインスタンス生成

*flowLayoutPanel1.Controls.Add(profilePic);
FlowLayoutPanelに画像を追加する処理

*profilePic.Width = 60;
プロフィール画像のレイアウトを調整

*profilePic.ImageLocation = tweetieBird.ProfileImageUrl;
フォロワーのプロフィール画像を表示する処理


*PdfDocument pdf = new PdfDocument();
PdfDocument objectを作成します。

*pdf.LoadFromFile("サンプル.pdf");
PDFファイルをロードします。

*pdf.SaveToFile("PDFToExcel.xlsx", FileFormat.XLSX);
Excelで保存します。


*datetimes.Add("past", new Dictionary<string, DateTime>{{"yesterday", new DateTime("yesterday")}} );
An item with the same key has already been added

*datetimes.Add("past", new Dictionary<string, DateTime>{{"yesterday", new DateTime("yesterday")}} );
これはOK


*con.Open();
データベースの接続

*command.CommandText = query;
コマンドのセット

*command.ExecuteNonQuery();
コマンドの実行

*transaction.Commit();
コミット

*transaction.Rollback();
ロールバック

*con.Close();
データベースの接続終了


*public static  IList<Piece> PieceList = new List<Piece> {new Piece(new char[,] {{ ' ','X',' ' },{ 'X','X','X' },{ ' ','X',' ' },}),new Piece(new char[,] {{ ' ','F','F' },{ 'F','F',' ' },{ ' ','F',' ' },}),...,,,public class Piece {// 一つのピースの配列の空白以外の場所の位置を記憶public IList<Point> Points { get; private set; }// 回転、反転させた全てのパターンを列挙（コンストラクタで設定）public IList<Piece> AllSeries { get; private set; }//  ピースのサイズpublic int YSize { get; set; }public int XSize { get; set; }// ピースの形を示す文字public char Char { get; private set; }// 右に90度回転public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point {X = pt.Y, Y = this.XSize - pt.X - 1}).OrderBy(pt => pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}// 左右に反転public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point {X = pt.X, Y = this.YSize - pt.Y - 1}).OrderBy(pt => pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}// 回転、反転の８つのピースを得る （左右対称なら４つ）private IEnumerable<Piece> AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j < 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j < 3; j++) {mirror = mirror.R90();yield return mirror;}}}},,,public bool Solve(int xSize, int ySize) {_board = new Board(xSize, ySize);return Solve(Piece.PieceList);}// 解を求める （再帰メソッド）private bool Solve(IEnumerable<Piece> pieceList) {// 最初のピースを取り出すvar piece = pieceList.FirstOrDefault();if (piece == null)// すべてのペースを使い切った(つまり成功)return true;// ピースを回転、反転させたものを取り出し試していく。foreach (var curr in piece.AllSeries) {// すべての位置を順に取り出す、そこにcurrを置いていくforeach (var topleft in _board.AllPoints) {// 取り出した位置(左上)にピースを置いてみるif (Put(topleft, curr)) {if (CountEmpty().Any(n => n % 5 != 0)) {// 5で割り切れない空き領域があれば、そこにピースははめ込むことができない。// 枝刈り処理 これ以上試しても仕方が無いので、次を試す。Remove(topleft, curr);continue;}var newlist = pieceList.Where(o => o.Char != curr.Char).ToList();// 置けたら残りのピースで同じことを繰り返すif (Solve(newlist) == true)// 成功したら処理を終えるreturn true;// 状態を戻して、次を試すRemove(topleft, curr);}}}return false;},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {public struct Point {public int X { get; set; }public int Y { get; set; }// 上下左右の位置を列挙public IEnumerable<Point> GetAroundPoints() {yield return new Point { X = this.X, Y = this.Y + 1 };yield return new Point { X = this.X + 1, Y = this.Y };yield return new Point { X = this.X - 1, Y = this.Y };yield return new Point { X = this.X, Y = this.Y - 1 };}// BoardにPieceを置く際に利用する。public Point Add(Point pt) {return new Point {X = X + pt.X,Y = Y + pt.Y};}public override int GetHashCode() {return Value;}public int Value {get { return X + Y * 100; }}}},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {public class Piece {public IList<Point> Points { get; private set; }public IList<Piece> AllSeries { get; private set; }public int YSize { get; set; }public int XSize { get; set; }public char Char { get; private set; }private Piece() {}public Piece(char[,] piece) {YSize = piece.GetUpperBound(1) + 1;XSize = piece.GetUpperBound(0) + 1;Points = GetAllPoints().Where(pt => piece[pt.X, pt.Y] != ' ').OrderBy(pt => pt.Value).ToList();var first = Points[0];Char = piece[first.X, first.Y];AllSeries = this.AllCandidates().Distinct(_pieceComparer).ToList();}// 右に90度回転public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point { X = pt.Y, Y = this.XSize - pt.X - 1 }).OrderBy(pt => pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}// 左右に反転public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point { X = pt.X, Y = this.YSize - pt.Y - 1 }).OrderBy(pt => pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}// ピースの全ての位置を列挙するprivate IEnumerable<Point> GetAllPoints() {for (int xx = 0; xx < this.XSize; xx++) {for (int yy = 0; yy < this.YSize; yy++) {yield return new Point { X = xx, Y = yy };}}}// 回転、反転の８つのピースを得る （左右対称なら４つ）private IEnumerable<Piece> AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j < 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j < 3; j++) {mirror = mirror.R90();yield return mirror;}}}private static PieceComparer _pieceComparer = new PieceComparer();// 利用するピースデータpublic static  IList<Piece> PieceList = new List<Piece> {new Piece(new char[,] {{ ' ','X',' ' },{ 'X','X','X' },{ ' ','X',' ' },}),new Piece(new char[,] {{ ' ','F','F' },{ 'F','F',' ' },{ ' ','F',' ' },}),new Piece(new char[,] {{ 'I','I','I','I','I' },}),new Piece(new char[,] {{ 'L',' ' },{ 'L',' ' },{ 'L',' ' },{ 'L','L' },}),new Piece(new char[,] {{ 'N',' ' },{ 'N',' ' },{ 'N','N' },{ ' ','N' },}),new Piece(new char[,] {{ 'P','P' },{ 'P','P' },{ 'P',' ' },}),new Piece(new char[,] {{ 'T','T','T' },{ ' ','T',' ' },{ ' ','T',' ' },}),new Piece(new char[,] {{ 'U',' ','U' },{ 'U','U','U' },}),new Piece(new char[,] {{ 'V',' ',' ' },{ 'V',' ',' ' },{ 'V','V','V' },}),new Piece(new char[,] {{ 'W',' ',' ' },{ 'W','W',' ' },{ ' ','W','W' },}),new Piece(new char[,] {{ ' ','Y' },{ 'Y','Y' },{ ' ','Y' },{ ' ','Y' },}),new Piece(new char[,] {{ 'Z','Z',' ' },{ ' ','Z',' ' },{ ' ','Z','Z' },}),};}},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {public class Board {private char[,] _box;int _xSize;int _ySize;// コンストラクタprivate Board(Board board) {this._xSize = board._xSize;this._ySize = board._ySize;this._box = board._box.Clone() as char[,];}// コンストラクタpublic Board(int xmax, int ymax) {_box = new char[xmax + 2, ymax + 2];_xSize = xmax + 2;_ySize = ymax + 2;foreach (var pt in GetPointsIncludeFrame()) {if (IsValidPoint(pt))this[pt] = ' ';elsethis[pt] = '*';}}// 枠も含めてすべての位置を列挙するprivate IEnumerable<Point> GetPointsIncludeFrame() {for (int yy = 0; yy < this._ySize; yy++) {for (int xx = 0; xx < this._xSize; xx++) {yield return new Point { X = xx, Y = yy };}}}private List<Point> _AllValidPoint = null;// 枠を除いた位置を列挙するpublic IEnumerable<Point> AllPoints {get {if (_AllValidPoint == null) {var list = new List<Point>();for (int yy = 1; yy < this._ySize - 1; yy++) {for (int xx = 1; xx < this._xSize - 1; xx++) {list.Add(new Point { X = xx, Y = yy });}}_AllValidPoint = list.OrderBy(pt => pt.X + pt.Y).ToList();}return _AllValidPoint;}}// インデクサpublic char this[Point pt] {get { return _box[pt.X, pt.Y]; }set { _box[pt.X, pt.Y] = value; }}// Boardの内容をプリントするpublic void Print() {var ystr = new string(Enumerable.Repeat('-', _xSize-2).ToArray());Console.WriteLine($"+{ystr}+");for (int y = 1; y < _ySize - 1; y++) {Console.Write("|");for (int x = 1; x < _xSize - 1; x++) {Console.Write(_box[x, y]);}Console.WriteLine("|");}Console.WriteLine($"+{ystr}+");}// 複製をつくるpublic Board Clone() {return new Board(this);}// 有効な位置か （枠ならばfalse)internal bool IsValidPoint(Point point) {return ((1 <= point.X && point.X < _xSize - 1) &&(1 <= point.Y && point.Y < _ySize - 1));}// Boardの内容を変更してしまうので注意。元の状態に戻すのは呼び出す側の責務とする。// Pointのの位置に注目した時に、いくつの空白があるかをカウントする。pointも含める。// 再帰的に処理をしている。internal int CountEmpty(Point point) {if (this[point] != ' ')return 0;this[point] = '#';int count = 1;foreach (var pt in point.GetAroundPoints()) {if (this[pt] == ' ') {count += CountEmpty(pt);}}return count;}}},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {// 2つのピースを比較するクラスpublic class PieceComparer : IEqualityComparer<Piece> {public bool Equals(Piece a, Piece b) {return a.Points.SequenceEqual(b.Points);}public int GetHashCode(Piece obj) {return obj.Points.Aggregate(0, (hc, pt) => hc ^ pt.GetHashCode());}}},,,using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace PentominoApp {public class Pentomino {private Board _board;// 問題を解くpublic bool Solve(int xSize, int ySize) {_board = new Board(xSize, ySize);return Solve(Piece.PieceList);}// 解を求める （再帰メソッド）private bool Solve(IEnumerable<Piece> pieceList) {// 最初のピースを取り出すvar piece = pieceList.FirstOrDefault();if (piece == null)// すべてのペースを使い切った(つまり成功)return true;// ピースを回転、反転させたものを取り出し試していく。。foreach (var curr in piece.AllSeries) {// すべての位置を順に取り出す、そこにcurrを置いていくforeach (var topleft in _board.AllPoints) {// 取り出した位置(左上)にピースを置いてみるif (Put(topleft, curr)) {if (CountEmpty().Any(n => n % 5 != 0)) {// 5で割り切れない空き領域があれば、そこにピースははめ込むことができない。// 枝刈り処理 これ以上試しても仕方が無いので、次を試す。Remove(topleft, curr);continue;}var newlist = pieceList.Where(o => o.Char != curr.Char).ToList();// 置けたら残りのピースで同じことを繰り返すif (Solve(newlist) == true)// 成功したら処理を終えるreturn true;// 状態を戻して、次を試すRemove(topleft, curr);}}}return false;}// ピースをBoardから取り除くprivate void Remove(Point topleft, Piece piece) {foreach (var pt in piece.Points) {var point = topleft.Add(pt);_board[point] = ' ';}}// ピースを指定位置に置くpublic bool Put(Point basePlace, Piece piece) {List<Point> save = new List<Point>();foreach (var pt in piece.Points) {var point = basePlace.Add(pt);if (_board.IsValidPoint(point) &&  _board[point] == ' ') {_board[point] = piece.Char;save.Add(point);} else {// やっぱり置けなかったので、元に戻す。foreach (var p in save)_board[p] = ' ';return false;}}return true;}// プリントpublic void Print() {_board.Print();}// 空いている領域の面積を列挙する。private IEnumerable<int> CountEmpty() {var bclone = _board.Clone();var pts = bclone.AllPoints.Where(pt => bclone[pt] == ' ').ToArray();return pts.Select(pt => bclone.CountEmpty(pt)).Where(cnt => cnt > 0);}}},,,using System;namespace PentominoApp {class Program {static void Main(string[] args) {Pentomino solver = new Pentomino();Console.WriteLine(DateTime.Now);solver.Solve(12, 5);Console.WriteLine(DateTime.Now);solver.Print();Console.ReadLine();}}},,,*public IList<Point> Points { get; private set; }// 回転、反転させた全てのパターンを列挙（コンストラクタで設定）public IList<Piece> AllSeries { get; private set; }//  ピースのサイズpublic int YSize { get; set; }public int XSize { get; set; }// ピースの形を示す文字public char Char { get; private set; }// 右に90度回転public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point {X = pt.Y, Y = this.XSize - pt.X - 1}).OrderBy(pt => pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}// 左右に反転public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point {X = pt.X, Y = this.YSize - pt.Y - 1}).OrderBy(pt => pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}// 回転、反転の８つのピースを得る （左右対称なら４つ）private IEnumerable<Piece> AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j < 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j < 3; j++) {mirror = mirror.R90();yield return mirror;}}}}
一つのピースの配列の空白以外の場所の位置を記憶

*public IList<Piece> AllSeries { get; private set; }
回転、反転させた全てのパターンを列挙（コンストラクタで設定）

*public int YSize { get; set; }
ピースのサイズ

*public char Char { get; private set; }
ピースの形を示す文字

*public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point {X = pt.Y, Y = this.XSize - pt.X - 1}).OrderBy(pt => pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}
右に90度回転

*public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point {X = pt.X, Y = this.YSize - pt.Y - 1}).OrderBy(pt => pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}
左右に反転

*private IEnumerable<Piece> AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j < 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j < 3; j++) {mirror = mirror.R90();yield return mirror;}}}
回転、反転の８つのピースを得る （左右対称なら４つ）

*private bool Solve(IEnumerable<Piece> pieceList) {// 最初のピースを取り出すvar piece = pieceList.FirstOrDefault();if (piece == null)// すべてのペースを使い切った(つまり成功)return true;// ピースを回転、反転させたものを取り出し試していく。foreach (var curr in piece.AllSeries) {// すべての位置を順に取り出す、そこにcurrを置いていくforeach (var topleft in _board.AllPoints) {// 取り出した位置(左上)にピースを置いてみるif (Put(topleft, curr)) {if (CountEmpty().Any(n => n % 5 != 0)) {// 5で割り切れない空き領域があれば、そこにピースははめ込むことができない。// 枝刈り処理 これ以上試しても仕方が無いので、次を試す。Remove(topleft, curr);continue;}var newlist = pieceList.Where(o => o.Char != curr.Char).ToList();// 置けたら残りのピースで同じことを繰り返すif (Solve(newlist) == true)// 成功したら処理を終えるreturn true;// 状態を戻して、次を試すRemove(topleft, curr);}}}return false;}
解を求める （再帰メソッド）

*var piece = pieceList.FirstOrDefault();
最初のピースを取り出す

*return true;
すべてのペースを使い切った(つまり成功)

*Remove(topleft, curr);
5で割り切れない空き領域があれば、そこにピースははめ込むことができない。
枝刈り処理 これ以上試しても仕方が無いので、次を試す。

*if (Solve(newlist) == true)*// 成功したら処理を終える
置けたら残りのピースで同じことを繰り返す

*return true;
成功したら処理を終える

*Remove(topleft, curr);
状態を戻して、次を試す

*public IEnumerable<Point> GetAroundPoints() {yield return new Point { X = this.X, Y = this.Y + 1 };yield return new Point { X = this.X + 1, Y = this.Y };yield return new Point { X = this.X - 1, Y = this.Y };yield return new Point { X = this.X, Y = this.Y - 1 };}
上下左右の位置を列挙

*public Point Add(Point pt) {return new Point {X = X + pt.X,Y = Y + pt.Y};}
BoardにPieceを置く際に利用する。

*public Piece R90() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point { X = pt.Y, Y = this.XSize - pt.X - 1 }).OrderBy(pt => pt.Value).ToList(),XSize = this.YSize,YSize = this.XSize,};}
右に90度回転

*public Piece Mirror() {return new Piece {Char = this.Char,Points = Points.Select(pt => new Point { X = pt.X, Y = this.YSize - pt.Y - 1 }).OrderBy(pt => pt.Value).ToList(),XSize = this.XSize,YSize = this.YSize,};}
左右に反転

*private IEnumerable<Point> GetAllPoints() {for (int xx = 0; xx < this.XSize; xx++) {for (int yy = 0; yy < this.YSize; yy++) {yield return new Point { X = xx, Y = yy };}}}
ピースの全ての位置を列挙する

*private IEnumerable<Piece> AllCandidates() {yield return this;Piece r1 = this;for (int j = 0; j < 3; j++) {r1 = r1.R90();yield return r1;}var mirror = this.Mirror();if (!_pieceComparer.Equals(this, mirror)) {yield return mirror;for (int j = 0; j < 3; j++) {mirror = mirror.R90();yield return mirror;}}}
回転、反転の８つのピースを得る （左右対称なら４つ）

*public static  IList<Piece> PieceList = new List<Piece> {new Piece(new char[,] {{ ' ','X',' ' },{ 'X','X','X' },{ ' ','X',' ' },}),new Piece(new char[,] {{ ' ','F','F' },{ 'F','F',' ' },{ ' ','F',' ' },}),new Piece(new char[,] {{ 'I','I','I','I','I' },}),new Piece(new char[,] {{ 'L',' ' },{ 'L',' ' },{ 'L',' ' },{ 'L','L' },}),new Piece(new char[,] {{ 'N',' ' },{ 'N',' ' },{ 'N','N' },{ ' ','N' },}),new Piece(new char[,] {{ 'P','P' },{ 'P','P' },{ 'P',' ' },}),new Piece(new char[,] {{ 'T','T','T' },{ ' ','T',' ' },{ ' ','T',' ' },}),new Piece(new char[,] {{ 'U',' ','U' },{ 'U','U','U' },}),new Piece(new char[,] {{ 'V',' ',' ' },{ 'V',' ',' ' },{ 'V','V','V' },}),new Piece(new char[,] {{ 'W',' ',' ' },{ 'W','W',' ' },{ ' ','W','W' },}),new Piece(new char[,] {{ ' ','Y' },{ 'Y','Y' },{ ' ','Y' },{ ' ','Y' },}),new Piece(new char[,] {{ 'Z','Z',' ' },{ ' ','Z',' ' },{ ' ','Z','Z' },}),};
利用するピースデータ

*private Board(Board board) {this._xSize = board._xSize;this._ySize = board._ySize;this._box = board._box.Clone() as char[,];}
コンストラクタ

*public Board(int xmax, int ymax) {_box = new char[xmax + 2, ymax + 2];_xSize = xmax + 2;_ySize = ymax + 2;foreach (var pt in GetPointsIncludeFrame()) {if (IsValidPoint(pt))this[pt] = ' ';elsethis[pt] = '*';}}
コンストラクタ

*private IEnumerable<Point> GetPointsIncludeFrame() {for (int yy = 0; yy < this._ySize; yy++) {for (int xx = 0; xx < this._xSize; xx++) {yield return new Point { X = xx, Y = yy };}}}
枠も含めてすべての位置を列挙する

*public IEnumerable<Point> AllPoints {get {if (_AllValidPoint == null) {var list = new List<Point>();for (int yy = 1; yy < this._ySize - 1; yy++) {for (int xx = 1; xx < this._xSize - 1; xx++) {list.Add(new Point { X = xx, Y = yy });}}_AllValidPoint = list.OrderBy(pt => pt.X + pt.Y).ToList();}return _AllValidPoint;}}
枠を除いた位置を列挙する

*public char this[Point pt] {get { return _box[pt.X, pt.Y]; }set { _box[pt.X, pt.Y] = value; }}
インデクサ

*public void Print() {var ystr = new string(Enumerable.Repeat('-', _xSize-2).ToArray());Console.WriteLine($"+{ystr}+");for (int y = 1; y < _ySize - 1; y++) {Console.Write("|");for (int x = 1; x < _xSize - 1; x++) {Console.Write(_box[x, y]);}Console.WriteLine("|");}Console.WriteLine($"+{ystr}+");}
Boardの内容をプリントする

*public Board Clone() {return new Board(this);}
複製をつくる

*internal bool IsValidPoint(Point point) {return ((1 <= point.X && point.X < _xSize - 1) &&(1 <= point.Y && point.Y < _ySize - 1));}
有効な位置か （枠ならばfalse)

*internal int CountEmpty(Point point) {
Boardの内容を変更してしまうので注意。元の状態に戻すのは呼び出す側の責務とする。
Pointのの位置に注目した時に、いくつの空白があるかをカウントする。pointも含める。
再帰的に処理をしている。

*public class PieceComparer : IEqualityComparer<Piece> {public bool Equals(Piece a, Piece b) {return a.Points.SequenceEqual(b.Points);}public int GetHashCode(Piece obj) {return obj.Points.Aggregate(0, (hc, pt) => hc ^ pt.GetHashCode());}}
2つのピースを比較するクラス

*public bool Solve(int xSize, int ySize) {_board = new Board(xSize, ySize);return Solve(Piece.PieceList);}
問題を解く

*private bool Solve(IEnumerable<Piece> pieceList) {// 最初のピースを取り出すvar piece = pieceList.FirstOrDefault();if (piece == null)// すべてのペースを使い切った(つまり成功)return true;// ピースを回転、反転させたものを取り出し試していく。。foreach (var curr in piece.AllSeries) {// すべての位置を順に取り出す、そこにcurrを置いていくforeach (var topleft in _board.AllPoints) {// 取り出した位置(左上)にピースを置いてみるif (Put(topleft, curr)) {if (CountEmpty().Any(n => n % 5 != 0)) {// 5で割り切れない空き領域があれば、そこにピースははめ込むことができない。// 枝刈り処理 これ以上試しても仕方が無いので、次を試す。Remove(topleft, curr);continue;}var newlist = pieceList.Where(o => o.Char != curr.Char).ToList();// 置けたら残りのピースで同じことを繰り返すif (Solve(newlist) == true)// 成功したら処理を終えるreturn true;// 状態を戻して、次を試すRemove(topleft, curr);}}}return false;}
解を求める （再帰メソッド）

*var piece = pieceList.FirstOrDefault();
最初のピースを取り出す

*return true;
すべてのペースを使い切った(つまり成功)

*Remove(topleft, curr);
5で割り切れない空き領域があれば、そこにピースははめ込むことができない。
枝刈り処理 これ以上試しても仕方が無いので、次を試す。

*if (Solve(newlist) == true)*// 成功したら処理を終える
置けたら残りのピースで同じことを繰り返す

*return true;
成功したら処理を終える

*Remove(topleft, curr);
状態を戻して、次を試す

*private void Remove(Point topleft, Piece piece) {foreach (var pt in piece.Points) {var point = topleft.Add(pt);_board[point] = ' ';}}
ピースをBoardから取り除く

*public bool Put(Point basePlace, Piece piece) {List<Point> save = new List<Point>();foreach (var pt in piece.Points) {var point = basePlace.Add(pt);if (_board.IsValidPoint(point) &&  _board[point] == ' ') {_board[point] = piece.Char;save.Add(point);} else {// やっぱり置けなかったので、元に戻す。foreach (var p in save)_board[p] = ' ';return false;}}return true;}
ピースを指定位置に置く

*foreach (var p in save)*_board[p] = ' ';
やっぱり置けなかったので、元に戻す。

*public void Print() {_board.Print();}
プリント

*private IEnumerable<int> CountEmpty() {var bclone = _board.Clone();var pts = bclone.AllPoints.Where(pt => bclone[pt] == ' ').ToArray();return pts.Select(pt => bclone.CountEmpty(pt)).Where(cnt => cnt > 0);}
空いている領域の面積を列挙する。


*private const float limitPos = 5f;
横幅の制限

*transform.position = new Vector3 (Mathf.Clamp (transform.position.x, -limitPos, limitPos), transform.position.y, transform.position.z);*}
Clamp関数で制限する


*return this.name;
現在のname取得

*public Monkey(){}
Program.cs


*short a=0;
範囲は-128~127で、符号付き8ビット整数

*int a=0;
範囲は-32768~32767で、符号付き16ビット整数

*long a=0;
範囲は-2147483648~2147483647で、符号付き32ビット整数

*byte a=0;
範囲は-9223372036854770000~9223372036854775807で、符号付き64ビット整数

*ushort a=0;
範囲は0~255で、符号なしビット整数

*uint a=0;
範囲は0~65535で、符号なし16ビット整数

*ulong a=0;
範囲は0~4294967295で、符号なし32ビット整数

*float a=1.5;
範囲は0~18446744073709551615で、符号なし64ビット整数

*double a=1.5;
浮動小数点型
範囲は±1.5e-45~±3.4e38(おおよその範囲)で、有効桁数7桁

*bool a = true;
浮動小数点型
範囲は±5.0e-324~±1.7e308(おおよその範囲)で、有効桁数15~16桁

*char a='X';
true/false(ブール値)
真か偽の格納のみを目的とした変数の作成にはbool型が適している

*decimal a = 199.9m;
範囲はU+0000~U+ffffで、Unicode16ビット文字

*string a = "b " + "c";
範囲は±1.0×10-28~±7.9×1028で、有効桁数28~29桁の型がある。

*int[,]a={{1,2,3},{4,5,6}多次元配列1a[1,2]=9;
文字列型

*a[1,2]=9;
多次元配列1

*,,,
多次元配列2
javaは[][]だが,で区切るだけ


*}
MssGetStructureAndValidateValue


*_is_hide = true;
表示状況を反転


*public void AddExp(int exp, int[] expArray)*{//カンストを考慮して加算_exp = Mathf.Clamp(_exp + exp, 0, expArray[expArray.Length - 1]);// 値の更新UpdateLevel(expArray);UpdateRemainExp(expArray);}
Expを加算してLvを初期化する

*_exp = Mathf.Clamp(_exp + exp, 0, expArray[expArray.Length - 1]);
カンストを考慮して加算

*UpdateLevel(expArray);
値の更新

*var maxIdx = expArray.Where(x => x <= _exp).Select((val, idx) => new {V = val, I = idx})
現Exp以下の値の中で最大の値のインデックスを取得

*var minIdx = expArray.Where(x => x > _exp).Select((val, idx) => new {V = val, I = idx})
現Expより大きい値の中で最小の値のインデックスを取得

*public void AddExp(int exp)*{ExpLevel.AddExp(exp, TOTAL_EXP_ARRAY);}
経験値獲得処理

*public (int afterLevel, int remainExp) AddExp(int exp, int[] expArray)*{//カンストを考慮して加算_exp = Mathf.Clamp(_exp + exp, 0, expArray[expArray.Length - 1]);// 値の更新UpdateLevel(expArray);UpdateRemainExp(expArray);return (Level, RemainExp);}
Expを加算してLvを初期化する

*_exp = Mathf.Clamp(_exp + exp, 0, expArray[expArray.Length - 1]);
カンストを考慮して加算

*UpdateLevel(expArray);
値の更新

*var maxIdx = expArray.Where(x => x <= _exp).Select((val, idx) => new {V = val, I = idx})
現Exp以下の値の中で最大の値のインデックスを取得

*var minIdx = expArray.Where(x => x > _exp).Select((val, idx) => new {V = val, I = idx})
現Expより大きい値の中で最小の値のインデックスを取得

*public (int afterLevel, int remainExp) AddExp(int exp)*{return ExpLevel.AddExp(exp, TOTAL_EXP_ARRAY);}
経験値獲得処理


*var groupName = "";
検索したいグループ名

*var members = groupPrincipal.Members.OfType<UserPrincipal>();
名前やメールアドレスを取得できる


*string ShopDomain = "sample.myshopify.com";
自分のShopify ECサイトドメイン

*ShopifyBuy.Client().Query(*// Pass a lambda expression to 'buildQuery'
This example uses named parameters but these could be omitted.


*GUILayout.EndHorizontal();
横並びにしたいGUI達


*[System.Security.SecuritySafeCritical]
auto-generated


*void Start()*{string[] args = System.Environment.GetCommandLineArgs();for (int i = 0; i < args.Length; ++i){switch (args[i]){case "-text":if (i + 1 < args.Length){text.text = args[i + 1];}break;}}}
Start is called before the first frame update


*private OracleConnection conn;
DB接続

*private OracleCommand cmd;
SQL発行に必要

*private OracleDataReader reader;
SELECT時の結果読み取りに利用

*private OracleTransaction transaction;
Transactionに利用

*public static int DATE = 0;
Bind変数に利用する型

*cmd.BindByName = true;
バインド変数の名前解決

*public static String GetString(OracleDataReader read, string target) {if (read.GetValue(read.GetOrdinal(target)).ToString() == "") {return "";} else {return read.GetString(read.GetOrdinal(target));}}


*public static int GetInt16(OracleDataReader read, string target) {return read.GetInt16(read.GetOrdinal(target));}


*public static int GetInt32(OracleDataReader read, string target) {return read.GetInt32(read.GetOrdinal(target));}


*public static float GetFloat(OracleDataReader read, string target) {return read.GetFloat(read.GetOrdinal(target));}


*dbControlt.SetBindVariable("hobby", "山登り", DbControl.VARCHAR2);
第一引数はBind変数、第二引数は値、第三引数はカラムの型に合わせたもの


*void Start()*{}
Start is called before the first frame update

*void Update()*{var body = GameObject.Find ("Sphere").GetComponent<Rigidbody> ();if (Input.GetKey(KeyCode.UpArrow )) {body.WakeUp();}else if (Input.GetKey(KeyCode.DownArrow)){body.WakeUp();}else if (Input.GetKey(KeyCode.RightArrow)){body.WakeUp();}else if(Input.GetKey(KeyCode.LeftArrow)){body.WakeUp();}}
Update is called once per frame


*string localIpString = "自分のIPアドレス";
バインドするローカルIPとポート番号

*System.Net.IPEndPoint localEP =new System.Net.IPEndPoint(localAddress, localPort);
UdpClientを作成し、ローカルエンドポイントにバインドする

*System.Net.IPEndPoint remoteEP = null;
データを受信する

*string rcvMsg = System.Text.Encoding.UTF8.GetString(rcvBytes);
データを文字列に変換する

*if (RcvMsg[0] =="exit")
受信したデータと送信者の情報を表示する
"exit"を受信したら終了

*udp.Close();
UdpClientを閉じる


*internal class ArrayCollector<T>*{private readonly T[] _array;public ArrayCollector(T[] array)=> _array = array;~ArrayCollector(){ArrayPool<T>.Shared.Return(_array);}}
~~~

*var ndarray1 = NdArray.Create(new double[24], new int[]{2, 3, 4});
一次元のT型配列＋シェイプを表すint型配列から作ります

*var ndarray2 = NdArray.Create(new double[2, 3, 4]);
多次元配列を直接渡しても作れます

*var sliced = ndarray1[new Index(1), Range.Whole, new Range(0, 4, 2)];
これ作ったときにはスライス構文はまだプロポーザルの段階だったので独自実装で無理やり。C# 8.0にはそのうちちゃんと対応したい・・・

*var ndarray3 = mndarray1.ToImmutable();
ToImmutableはコピーによる生成。

*var ndarray4 = mndarray2.MoveToImmutable();
MoveToImmutableはムーブによる生成。効率がいい代わりにもとのMutableNdArray<T>を破壊します。

*var result1 = A.Zip(B, (a, b) => a + b);
LinqのZipメソッドの適用

*var result2 = (A, B).Zip((a, b) => a + b);
これも上の式と全く同じ演算

*var result = (ndarray1, ndarray2).Zip((x, y) => x + y, ParallelIterationStrategy.Instance);
System.Threading.Tasks.Parallel.Forによる並列化


*B(3
2);      OK


*CreateNoWindow = CreateNoWindow
コンソール・ウィンドウを開かない


*HostWriter.CreateAppHost(appHostSourceFilePath: AppHostSourcePath,appHostDestinationFilePath: AppHostDestinationPath,appBinaryFilePath: AppBinaryName,windowsGraphicalUserInterface: isGUI,assemblyToCopyResorcesFrom: resourcesAssembly);
CreateAppHost.csより引用

*using (var memoryMappedFile = MemoryMappedFile.CreateFromFile(appHostDestinationFilePath))
HostWriter.csより引用
Re-write the destination apphost with the proper contents.

*private const UInt16 WindowsGUISubsystem = 0x2;
BinaryUtils.csより引用 (★部分は追記部分)

*subsystem[0] = WindowsGUISubsystem;
★WindowsGUISubsystem(2)の書き込み
Set the subsystem to GUI


*output = Unity.MatToTexture(processor.Image, output);
if output is valid texture it's buffer will be re-used, otherwise it will be re-created


*originalPixels[i++]=255;
α


*public string url = "http:
IPアドレス:8000";

*//var www = new WWW(url, form);*//yield return www;
これはおそらくPOSTになってしまう

*yield return webRequest.SendWebRequest();
URLに接続して結果が戻ってくるまで待機


*timer = this.CreateSubject<int>(timerKey);
SubjectPoolに追加


*var config = SpeechConfig.FromSubscription(KEY, REGION);
Azure情報の設定

*if (!string.IsNullOrEmpty(PROXY_HOST))*config.SetProxy(PROXY_HOST, PROXY_PORT);
Proxyの設定

*var result = await RecognizeStartAsync(config, wavefile);
文字起こし開始

*using (var audioInput = AudioConfig.FromWavFileInput(wavefile)){using (var recognizer = new SpeechRecognizer(config, audioInput)){recognizer.Recognizing += (s, e) =>
SpeechToTextの開始

*// {//     Console.WriteLine($"RECOGNIZING: Text={e.Result.Text}");// };
recognizer.Recognizing += (s, e) =>

*//     Console.WriteLine($"RECOGNIZING: Text={e.Result.Text}");
{

*recognizer.Recognized += (s, e) =>*{if (e.Result.Reason == ResultReason.RecognizedSpeech){var time = TimeSpan.FromSeconds(e.Result.OffsetInTicks / 10000000).ToString(@"hh\:mm\:ss");var text = $"{time} {e.Result.Text}\n";Console.Write(text);sb.Append(text);}else if (e.Result.Reason == ResultReason.NoMatch){Console.WriteLine($"NOMATCH: Speech could not be recognized.");}};
};

*// {//     Console.WriteLine("\n    Session started event.");// };
recognizer.SessionStarted += (s, e) =>

*// recognizer.SessionStopped += (s, e) =>*// {//     Console.WriteLine("\n    Session stopped event.");//     Console.WriteLine("\nStop recognition.");//     if (string.IsNullOrEmpty(ret))//         ret = "";//     stopRecognition.TrySetResult(0);// };
};

*// {//     Console.WriteLine("\n    Session stopped event.");//     Console.WriteLine("\nStop recognition.");//     if (string.IsNullOrEmpty(ret))//         ret = "";//     stopRecognition.TrySetResult(0);// };
recognizer.SessionStopped += (s, e) =>

*//     if (string.IsNullOrEmpty(ret))*//         ret = "";
Console.WriteLine("\nStop recognition.");

*// Use Task.WaitAny to keep the task rooted.*Task.WaitAny(new[] { stopRecognition.Task });
Waits for completion.

*Task.WaitAny(new[] { stopRecognition.Task });
Use Task.WaitAny to keep the task rooted.

*var files = new List<string>();
ファイル一覧の取得


*// 描画位置の計算*{var pos = bounds.center;var hoseiX = -(PaddingLeft / 2) + (PaddingRight / 2);var hoseiY = -(PaddingBottom / 2) + (PaddingTop / 2);var hoseiZ = 0.01f;this.Background.transform.localPosition = new Vector3(pos.x + hoseiX, pos.y + hoseiY, pos.z + hoseiZ);}
Debug.Log($"{bounds}");

*{var pos = bounds.center;var hoseiX = -(PaddingLeft / 2) + (PaddingRight / 2);var hoseiY = -(PaddingBottom / 2) + (PaddingTop / 2);var hoseiZ = 0.01f;this.Background.transform.localPosition = new Vector3(pos.x + hoseiX, pos.y + hoseiY, pos.z + hoseiZ);}
描画位置の計算

*{var scale = bounds.extents;var hoseiW = (PaddingLeft + PaddingRight) / 10;var hoseiH = (PaddingTop + PaddingBottom) / 10;this.Background.transform.localScale = new Vector3((scale.x / 10 * 2) + hoseiW, 1, (scale.y / 10 * 2) + hoseiH);}
描画サイズの計算


*void Start()*{}
Start is called before the first frame update


*BinaryReader reader = new BinaryReader(File.OpenRead(<ファイル名>));
インスタンス生成

*using (BinaryReader reader = new BinaryReader(File.OpenRead("BinaryFile1.bin"))){int ret;
"BinaryFile1.bin"を開く

*ret = reader.Read(buf, 0, 4);
4byte読み取り

*while (ret > 0)
1byte以上読み取ったか
※インデックスがファイルの末尾だった場合、Read()は0を返す

*BinaryWriter writer = new BinaryWriter(File.OpenWrite(<ファイル名>)
インスタンス生成

*using (BinaryWriter writer = new BinaryWriter(File.OpenWrite("BinaryFile2.bin"))){byte[] buf = new byte[] { 0x01, 0x02, 0x03, 0x04 };
"BinaryFile2.bin"を開く

*writer.Write(buf);
書き込み

*using (BinaryReader reader = new BinaryReader(File.OpenRead("BinaryFile2.bin"))){int ret;
書き込んだ内容を読み込んでコンソール出力


*StreamReader reader = new StreamReader(<ファイルパス>);
インスタンス生成

*StreamReader reader = new StreamReader(<ファイルパス>, Encoding.GetEncoding("Shift_JIS"));*,,,
エンコーディング指定(Shift_JISを指定する場合)

*using (StreamReader reader = new StreamReader("TextFile1.txt")){string line;
"TextFile1.txt"を開く

*line = reader.ReadLine();
ファイルから1行read

*StreamWriter writer = new StreamWriter(<ファイルパス>);
インスタンス生成

*StreamWriter writer = new StreamWriter(<ファイルパス>, Encoding.GetEncoding("Shift_JIS"));*,,,
エンコーディング指定(Shift_JISを指定する場合)

*using (StreamWriter writer = new StreamWriter("TextFile2.txt")){文字列を書き込むwriter.WriteLine("TextFileWriteSample");
"TextFile2.txt" を開く

*writer.WriteLine("TextFileWriteSample");
文字列を書き込む

*using (StreamReader reader = new StreamReader("TextFile2.txt")){string line;
書き込んだファイルを開いて内容をコンソール出力する


*if (m.Msg == 15)
WM_PAINT = 15

*g.DrawLine(new Pen(Color.Black), 0, this.Height - 1, this.Width, this.Height - 1);
下だけボーダー表示


*FireTime = DateTime.Now.AddSeconds(30),
10 秒後に通知


*var engine = new ExecuteEngineConfig().ConfigureComponents(c => c.Add<IDbProvider>(new DelegateDbProvider(() => new SqliteConnection("Data Source=test.db")))
Initialize

*dao.Insert(new DataEntity { Id = 1L, Name = "Data-1", Type = "A" });
Insert

*var tokenizer = new SqlTokenizer(sql.ToString());
MethodInfoを元にSQLを構築


*var response = s_webClient.UploadValues("https:
slack.comapichat.postMessage", "POST", data);

*CanHandleSessionChangeEvent = true;
OnSessionChange関数をの実行を有効にするため、CanHandleSessionChangeEventをtrueに

*Rootobject rootobject = SlackSendMessage.SendMessage("リモート接続監視");
スラックに投稿


*q.Dequeue();
Id:40, Name:Name40, Age:20


*}
処理

*Foo(a, b, ...);
無限(有限)に引数が増やせる

*var tmp = a[0][0];
各配列の要素が欲しいときは下記のように
a[第1引数][0番目]


*return _samples.FirstOrDefault(_ => _.Id == id);
普通にラムダ式で呼び出し、変数のキャプチャ有り

*return _samples.FirstOrDefault((x, state) => x.Id == state, id);
拡張メソッドを利用、変数のキャプチャ無し

*bool Func(Sample s) => s.Id == id;
ローカル関数経由で呼び出し、変数のキャプチャ有り


*CultureInfo.CurrentCulture = CultureInfo.GetCultureInfo("en-US");
カレントカルチャを英語にする(Twitter データの曜日が英語なので)

*Console.WriteLine("Hello World!");
なぜか残ってる

*var session = OAuth.Authorize("hogehoge", "piyopiyo");
Twitter アプリのコンシューマーキーとシークレット

*Console.WriteLine("Access to {0}, and get PIN code.", session.AuthorizeUri.AbsoluteUri);
アプリ認証用URLを表示させる

*var token = OAuth.GetTokens(session, pin);
認証させる

*var dateTime = GetDate(date);*Console.WriteLine("ここまで消します:{0}", dateTime.ToString());
どこまで消すかのDateTime構造体を取得しておく

*file = file.Substring(file.IndexOf("[") - 1);
tweet.jsの冒頭にある文字を消してプレーンなjsonにするために、最初にくる[までなかったことにする。

*var json = JArray.Parse(file);
パースしてあげる。

*var list = new List<Tweet>();
すべてのツイートを必要な情報だけList<Tweet>にいれておく

*var deleteList = new List<Tweet>();
削除対象のList<Tweet>。処理の簡単のために別のListに。

*var thisDate = GetDate(item.Date);
ツイートの時刻からDateTime構造体を取得して、先ほど指定した時刻より小さかったら？古かったら削除対象リストに入れる。

*Console.WriteLine("実際に消していきます。");
わざわざ言ってくれるの親切。

*try*{// 削除APIを叩く。long型なので変換してやってねtoken.Statuses.Destroy(Convert.ToInt64(item.ID));// 削除できたっぽいので教えてあげる。Console.WriteLine("削除しました: {0} / {1} / {2}", item.ID, item.Date, item.Text);}
キタ！ついに例外処理を始めたぞ！！！

*token.Statuses.Destroy(Convert.ToInt64(item.ID));
削除APIを叩く。long型なので変換してやってね

*Console.WriteLine("削除しました: {0} / {1} / {2}", item.ID, item.Date, item.Text);
削除できたっぽいので教えてあげる。

*// ざんねん！見つからなかったと教えてあげよう。*Console.WriteLine("見つかりませんでした: {0} / {1} / {2}", item.ID, item.Date, item.Text);
よくわかんないけど、ツイートがすでに存在しなかったらこの例外が投げられるのでcatch。

*Console.WriteLine("見つかりませんでした: {0} / {1} / {2}", item.ID, item.Date, item.Text);
ざんねん！見つからなかったと教えてあげよう。

*Thread.Sleep(1000);
1秒間に何度も叩かれるとTwitterさんが困っちゃうと思うので、1000ミリ秒お休みしてもらう

*Console.ReadLine();
入力待ちでポーズ。

*var format = "ddd MMM dd HH:mm:ss K yyyy";*// 普通のDateTime.Parseじゃあ多分例外吐く。
Twitter データのフォーマットがこれなので、これでDateTime構造体に変換してあげる。

*var dateTime = DateTime.ParseExact(date, format, null);*return dateTime;
普通のDateTime.Parseじゃあ多分例外吐く。

*public class Tweet*{public string ID;public string Date;public string Text;}
IDと時間を保持しておくクラス。内容は表示用のおまけ。


*using System.Runtime.InteropServices;
DllImport


*result = false;*foreach(var v in view){if(v == "DocumentType"){result = true;}}
result = view.Contains('DocumentType');


*bufferSize: 4096, useAsync: true))
useAsync=true もしくは options=FileOptions.Asynchronous


*XDocument xml = XDocument.Load(Path.Combine(Directory.GetCurrentDirectory(), @"XMLFile1.xml"));
ファイルを読み込んで XDocument に置換 → XDocument をカスタムモデルにデシリアライズ

*var doc = XmlConvert.SerializeXDocument(myModel);
カスタムモデルを XDocument にシリアライズ → XDocument を XML 形式でファイルに書き込み

*var str = XmlConvert.SerializeObject(myModel);
カスタムモデルを文字列にシリアライズ


*routedEventHandler = new RoutedEventHandler(AssociatedObject_MouseDown);
ButtonBase.ClickイベントのRoutedEventHandlerを登録する

*routedEventHandler = new RoutedEventHandler(AssociatedObject_MouseDown);
UIElement.MouseUpEventイベントのRoutedEventHandlerを登録する


*}
問題のコードをここに書く

*public static int MyFunction (int n) {// 便利な処理// ~~~~~~~~// ~~~~~~~~}
自作の関数

*}
便利な処理
~~~~~~~~
~~~~~~~~

*public static long MySuperAlgorithm (long m) {// ちょーすごいアルゴリズム// ~~~~~~~~// ~~~~~~~~}
自作のすごい関数

*}
ちょーすごいアルゴリズム
~~~~~~~~
~~~~~~~~


*textbox = driver.FindElement(By.Name("q"));
Webページを開く
driver.Navigate().GoToUrl("https:www.google.co.jp/");
検索ボックス

*textbox.SendKeys("Selenium");
検索ボックスに検索ワードを入力

*findbuttom = driver.FindElement(By.Name("btnK"));
検索ボタン

*findbuttom.Click();
検索ボタンをクリック


*private bool _isMouseDown;
マウス押下中フラグ

*private Point _startPoint;
マウスの移動が開始されたときの座標

*private Point _currentPoint;
マウスの現在位置座標

*private void OperationArea_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)*{// フラグを"マウス押下中"にする_isMouseDown = true;// GetPositionメソッドで現在のマウス座標を取得し、マウス移動開始点を更新// （マウス座標は、OperationAreaからの相対的な位置とする）_startPoint = e.GetPosition(OperationArea);// イベントを処理済みとする（当イベントがこの先伝搬されるのを止めるため）e.Handled = true;}
マウス左ボタン押下イベントのイベントハンドラ

*_isMouseDown = true;
フラグを"マウス押下中"にする

*_startPoint = e.GetPosition(OperationArea);
GetPositionメソッドで現在のマウス座標を取得し、マウス移動開始点を更新
（マウス座標は、OperationAreaからの相対的な位置とする）

*e.Handled = true;
イベントを処理済みとする（当イベントがこの先伝搬されるのを止めるため）

*private void OperationArea_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)*{// マウス押下中フラグを落とす_isMouseDown = false;e.Handled = true;}
マウス左ボタン解放イベントのハンドラ

*_isMouseDown = false;
マウス押下中フラグを落とす

*private void OperationArea_MouseMove(object sender, MouseEventArgs e)*{// マウス押下中でなければドラッグ操作ではないのでメソッドを抜けるif (!_isMouseDown){return;}// マウスの現在位置座標を取得（OperationAreaからの相対位置）_currentPoint = e.GetPosition(OperationArea);//移動開始点と現在位置の差から、MouseMoveイベント1回分の移動量を算出double offsetX = _currentPoint.X - _startPoint.X;double offsetY = _currentPoint.Y - _startPoint.Y;// 動かす対象の図形からMatrixオブジェクトを取得// このMatrixオブジェクトを用いて図形を描画上移動させるMatrix matrix = ((MatrixTransform)Target.RenderTransform).Matrix;// TranslateメソッドにX方向とY方向の移動量を渡し、移動後の状態を計算matrix.Translate(offsetX, offsetY);// 移動後の状態を計算したMatrixオブジェクトを描画に反映するTarget.RenderTransform = new MatrixTransform(matrix);// 移動開始点を現在位置で更新する// （今回の現在位置が次回のMouseMoveイベントハンドラで使われる移動開始点となる）_startPoint = _currentPoint;e.Handled = true;}
マウス移動イベントのイベントハンドラ

*_currentPoint = e.GetPosition(OperationArea);
マウスの現在位置座標を取得（OperationAreaからの相対位置）

*double offsetX = _currentPoint.X - _startPoint.X;
移動開始点と現在位置の差から、MouseMoveイベント1回分の移動量を算出

*Matrix matrix = ((MatrixTransform)Target.RenderTransform).Matrix;
動かす対象の図形からMatrixオブジェクトを取得
このMatrixオブジェクトを用いて図形を描画上移動させる

*matrix.Translate(offsetX, offsetY);
TranslateメソッドにX方向とY方向の移動量を渡し、移動後の状態を計算

*Target.RenderTransform = new MatrixTransform(matrix);*// 移動開始点を現在位置で更新する
移動後の状態を計算したMatrixオブジェクトを描画に反映する

*_startPoint = _currentPoint;
移動開始点を現在位置で更新する
（今回の現在位置が次回のMouseMoveイベントハンドラで使われる移動開始点となる）

*private void OperationArea_MouseLeave(object sender, MouseEventArgs e)*{_isMouseDown = false;e.Handled = true;}
マウスが離れたときのイベントハンドラ


*this.button1.Click += new System.EventHandler(this.button1_Click);
button1 省略

*this.button2.Click += new System.EventHandler(this.button2_Click);
button2 省略


*boldFont = new Font(baseFont.FontFamily, baseFont.Size, baseFont.Style | FontStyle.Bold);
実行順序を変えるとtab幅がおかしくなるので注意
baseFont = new Font("ＭＳ ゴシック",     12);  rtxt.Font.Size);

*Load      += (sender,e)=>{spl.SplitterDistance = nudG.Bottom;};
spl.IsSplitterFixed = true; はユーザがつかめないようにするだけで、固定してくれないっぽい。まぎらわしい。。

*return ret;
2019.12.27追記: AllocCoTaskMemに対する解放処理が漏れている


*if ( p.X == c.X && p.Y == c.Y ) {
例外処理


*[SQLiteFunction(Name = "ToUpper", Arguments = 1, FuncType = FunctionType.Scalar)]public class ToUpper : SQLiteFunction{public override object Invoke(object[] args){return args[0].ToString().ToUpper();
https:www.ivankristianto.com/howto-make-user-defined-function-in-sqlite-ado-net-with-csharp/

*Console.WriteLine("=================================================");
トランザクション

*var ct = new ADOX.Catalog();
32bitで動かす必要がある
https:www.c-sharpcorner.com/uploadfile/mahesh/using-adox-with-ado-net/
Microsoft ADO Ext 6.0

*Console.WriteLine("=================================================");
トランザクション

*//C:\Program Files (x86)\MySQL\MySQL Installer for Windows\MySql.Data.dll*using MySql.Data.MySqlClient;
以下を参照

*Console.WriteLine("=================================================");
トランザクション

*using (var cmd = new MySqlCommand("INSERT INTO test_tbl (user_name, age) VALUES (@user, @age)", conn)){cmd.Parameters.AddWithValue("@user", "丹下さくら");
Perform database operations

*using (var cmd = new MySqlCommand("INSERT INTO test_tbl (user_name, age) VALUES (@user, @age)", conn)){cmd.Parameters.AddWithValue("@user", "丹下さくら");
Perform database operations

*using (var cmd = new NpgsqlCommand()){cmd.Connection = conn;


*using (var cmd = new NpgsqlCommand()){cmd.Connection = conn;
Insert some data

*using (var cmd = new NpgsqlCommand("SELECT user_name, age FROM test_tbl", conn))using (var reader = cmd.ExecuteReader()){while (reader.Read()){Console.WriteLine("{0} {1}", reader.GetString(0), reader.GetInt32(1).ToString());
Retrieve all rows

*Console.WriteLine("=================================================");
トランザクション

*Console.WriteLine("=================================================");
トランザクション

*Console.WriteLine("=================================================");
ストアドの試験

*Console.WriteLine("=================================================");
トランザクション

*using (var cmd = new OracleCommand("INSERT INTO test_tbl (user_name, age) VALUES (:userName, :age)", conn)){cmd.Parameters.Add(new OracleParameter("userName", "丹下さくら"));
Perform database operations

*using (var cmd = new OracleCommand("INSERT INTO test_tbl (user_name, age) VALUES (:userName, :age)", conn)){cmd.Parameters.Add(new OracleParameter("userName", "丹下さくら"));
Perform database operations

*Console.WriteLine("=================================================");
トランザクション

*using (var cmd = new SqlCommand("INSERT INTO test_tbl (user_name, age) VALUES (@user, @age)", conn, tran)){cmd.Parameters.AddWithValue("@user", "丹下さくら");
Perform database operations

*using (var cmd = new SqlCommand("INSERT INTO test_tbl (user_name, age) VALUES (@user, @age)", conn, tran)){cmd.Parameters.AddWithValue("@user", "丹下さくら");
Perform database operations


*FastestMedian(InputGrayImage , MedianImage ,5);
入力，出力，n*nのブロックでフィルタ


*bmpOrg = new Bitmap(10,10,PixelFormat.Format32bppArgb);
dummy to avoid null

*// dlg.CheckPathExists = true;*if ( dlg.ShowDialog() == DialogResult.OK ) {Bitmap tmp = null;try {tmp = (Bitmap)Bitmap.FromFile(dlg.FileName);}catch (OutOfMemoryException e) {  MessageBox.Show(e.ToString()); }catch (FileNotFoundException e) { MessageBox.Show(e.ToString()); }catch (InvalidCastException e) {  MessageBox.Show(e.ToString()); }if ( tmp != null ) {bmpOrg = tmp;RedrawPct();}}
dlg.CheckFileExists = true;

*//dlg.CheckPathExists = true;*if ( dlg.ShowDialog() == DialogResult.OK ) {bmpOrg.Save(dlg.FileName, System.Drawing.Imaging.ImageFormat.Png);}
dlg.OverwritePrompt = true;


*previewImageUrl = "https:
sqlvaidccykhi26mlc.blob.core.windows.netmisc-sho-junkboxcoast-preview.jpg"


*const double a = 60 * (Math.PI / 180);
ここはC#からILの段階で畳み込まれる。


*_image.fillAmount = _myHp / 500.0f;
最大が500なので、割り算して比率で突っ込む

*using UnityEngine.UI;
Image系はUIなので追加

*private Image _image;
Image型の変数_imageを宣言しておく

*_image = this.GetComponent<Image>();
thisいらないけど、自分のだよ、ということで説明のために


*Console.WriteLine(instance1 == instance2);
<-- True が出力される


*public void Guard() {
防御処理}


*solver.AddGoal(objVId, 0, true);
true: minimize

*int vId;
変数

*solver.SetBounds(vId, minValues[i], maxValues[i]);
範囲

*solver.SetValue(vId, initialValues[i]);
初期値

*Func<INonlinearModel, int, ValuesByIndex, bool, double> callbackFunc2 =
目的関数をセット

*Func<bool> abortFunc = () =>*{return solver.IterationCount >= maxIter;};
中止関数

*var solverParams = new NelderMeadSolverParams(abortFunc);
解く

*double theta = (i + 1) / (double)paramCnt * Math.PI / 4.0;
直角コーナー


*ExecuteAnotherApp("FusaFusa.exe","hage husa husahusa", false, true);
"hage husa husa"引数は三つ．なしのときは""でいい


*private Light spotLight;
ONOFFするライト

*void Start ()*{spotLight = GetComponent<Light>();}
Use this for initialization

*void Update ()*{}
Update is called once per frame


*try
正常ケース
存在するキーを指定し、値を取得

*try
異常ケース
存在しないキーを指定し、値を取得

*try
正常ケース
存在するキーを指定し、値を設定

*try
正常ケース？
存在しないキーを指定し、値を設定

*Console.WriteLine($"success - value is {a}");
問題なく動く


*DirectorySize += GetDirectorySize(di);
サブフォルダのサイズを合算


*}
省略


*var text2 = string.Format("Value is {0}",v);
string.Format()

*var text0 = $"Value is {v}";
string interpolation


*var tleHtml = wc.DownloadString("https:
celestrak.comsatcattle.php?CATNR=27424");


*public string TestLockMessage { get; set; } = "ろぐいんちゅうでっせー";
ログイン中のメッセージを追加


*startEvent.Invoke();
ここにトリガーをオンにするイベントを登録


*terrainData.SetHeightsDelayLOD(hx, hy, heights);
ハイトマップに反映


*PhotonNetwork.ConnectUsingSettings(null);
Photonに接続する(引数でゲームのバージョンを指定できる)

*void OnJoinedLobby() {Debug.Log("ロビーに入りました。");// ルームに入室するPhotonNetwork.JoinRandomRoom();}
ロビーに入ると呼ばれる

*PhotonNetwork.JoinRandomRoom();
ルームに入室する

*void OnJoinedRoom() {Debug.Log("ルームへ入室しました。");}
ルームに入室すると呼ばれる

*void OnPhotonRandomJoinFailed() {Debug.Log("ルームの入室に失敗しました。");// ルームがないと入室に失敗するため、その時は自分で作る// 引数でルーム名を指定できるPhotonNetwork.CreateRoom("myRoomName");}
ルームの入室に失敗すると呼ばれる

*PhotonNetwork.CreateRoom("myRoomName");
ルームがないと入室に失敗するため、その時は自分で作る
引数でルーム名を指定できる


*if ( (m=rxp.Match(s)).Success ) {
透過色指定


*return ValidationResult.Success;
入力の桁数（トリムしたあと）が1以上なら正常

*return new ValidationResult(_errorMessage);
入力の桁数（トリムしたあと）が0以下なら異常

*MergeAttribute(context.Attributes, "required", "required");
タグに「required="required"」と「required-err-msg="<エラーメッセジ>"」を設定する

*public class InputModel*{[RequiredH5(errorMessage: "メッセージ変更")]public string UserID { get; set; }[RequiredH5][DataType(DataType.Password)]public string Password { get; set; }[Display(Name = "Remember me?")]public bool RememberMe { get; set; }}
(class InputModelの部分を抜粋)


*public ActionResult<IEnumerable<string>> Get(){
略}

*[HttpPut("{id}")]
PUT api/values/5

*[HttpPost]*public void Post( [FromBody] string value ){}
POST api/values

*[HttpDelete("{id}")]
DELETE api/values/5


*textbox = driver.FindElement(By.Name("q"));
Webページを開く
driver.Navigate().GoToUrl("https:www.google.co.jp/");
検索ボックス

*textbox.SendKeys("Selenium");
検索ボックスに検索ワードを入力

*findbuttom = driver.FindElement(By.Name("btnK"));
検索ボタン

*findbuttom.Click();
検索ボタンをクリック


*if (novelListIndex < messageList.Count)
全ての会話を表示していない場合


*Console.WriteLine(y3);
255


*string authValue = ((int)Authority.ReadWrite).ToString();
こんな感じ


*System.Drawing.Bitmap myBitmap;
ピクチャーボックス表示用

*var Magick = new ImageMagick.MagickImage("Sample.svg");
svgファイル読み込み

*myBitmap = Magick.ToBitmap();
ピクチャーボックスへ表示する為、Bitmapへ変換

*myMagick.Dispose();
リソース解放

*pictureBox1.Image = myBitmap;
pictureBox1に表示


*return Redirect ("https:
dongsu.dev");


*void Start () {gamaClearText.gameObject.SetActive (false);resetButton.gameObject.SetActive (false);rdnum = Random.Range (0, cube.Length);scoreText.text = "得 点 : ";gameflag = true;}
Use this for initialization

*void Update () {if(gameflag){for(int i=0;i<cube.Length;i++){if (i != rdnum) {cube [i].gameObject.transform.Rotate (3, 0, 3);} else {cube [i].gameObject.transform.Rotate (-3, 0, -3);}}time += Time.deltaTime;timeText.text = time.ToString("f2");scoreText.text = "得 点 : " + score;if(score == 5){gameflag = false;gamaClearText.gameObject.SetActive (true);resetButton.gameObject.SetActive (true);}}}
Update is called once per frame


*var clipInfo = animator.GetCurrentAnimatorClipInfo(0)[0];
引数はLayer番号、配列の0番目


*var h = domainObject.Height
100.0F;  cm -> m


*[RequireComponent(typeof(MeshRenderer))]
必要コンポーネント

*mesh.RecalculateNormals();
頂点情報をもとに法線を計算


*services.AddMvc ();
MVCモジュールの導入

*services.Configure<RouteOptions> (options => {options.ConstraintMap.Add ("name", typeof (NameRouteConstraint));
定義したカスタムルート制約


*// ちゃんと条件式を書く必要がある。*if (val > 0) {Console.WriteLine("val != 0");} else {Console.WriteLine("val = 0");}
intやStringに値が入っているかは、


*effects.transform.position = hitResult.point;*var cameraPos = Camera.main.transform.position;
エフェクト表示


*string exeName = ExeFileName;
実行ファイル名


*services.AddMvc ();
MVCモジュールの導入

*routes.MapRoute (name: "Default",template: "{controller}/{action}",defaults : new { controller = "Home", action = "Index" });
デフォルトルートの設定

*using Microsoft.AspNetCore.Mvc;*namespace ds.Tutorial.web.Controllers {// 2. Controllerを継承public class HomeController : Controller {// 3. Action Methodの定義public IActionResult Index () {return Content ("Hello World!");}}}
1.MVC名前空間を追加

*public class HomeController : Controller {// 3. Action Methodの定義public IActionResult Index () {return Content ("Hello World!");}}
2. Controllerを継承

*public IActionResult Index () {return Content ("Hello World!");}
3. Action Methodの定義


*void Start()*{}
Start is called before the first frame update

*void Update()*{}
Update is called once per frame

*}
クラスの中身

*}
メソッドの中身

*}
メソッドの中身

*void Start()*{speed = Random.Range(5f, 15f);}
Start is called before the first frame update

*void Update()*{transform.position += new Vector3(Input.GetAxis("Horizontal") * Time.deltaTime, 0f, 0f);}
Update is called once per frame

*void Start()*{speed = 5f;}
Start is called before the first frame update

*}
Start()メソッドはここまでなので、ここで変数 speed は破棄される

*}
ここでは speed 変数は存在しない


*var result = new List<string>();
抽出結果を格納したい

*var matches = Regex.Matches("0123abcdXyx", "[0-9a-fA-F]{2}");
16進数文字列を2文字ずつ取得

*result.AddRange(matches.Cast<Match>().Select(m => m.Value));
MatchCollectionクラスはIEnumerableでIEnumerable<T>じゃないので
そのままだとLinqが使えないのでIEnumerable<Match>にキャストしてから使う。


*_instance = new HogeManager();
Nullの場合だけインスタンス生成


*void Start()*{}
Start is called before the first frame update

*void Update()*{}
Update is called once per frame


*Screen s = Screen.AllScreens[1];
セカンダリ（今回撮るのはこっち）


*textBoxValue = _textBoxValue;
例えば "test" という文字は選択された場合、選択できなくする

*var _comboBoxList = ComboBoxList.ToList();
例えば "test" という文字は選択された場合、選択できなくする
元のデータをバックアップ

*ComboBoxList.Clear();
リストを更新することで強制的にComboBoxの更新を行う

*textBoxValue = _textBoxValue;
元のデータを戻す

*RaisePropertyChanged(nameof(TextBoxValue));
ComboBox以外にも通知する


*private const int FOF_NOCONFIRMATION = 0x0010;
Show no confirmation dialog box to the user

*[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]public struct SHFILEOPSTRUCT{public IntPtr hwnd;
Struct which contains information that the SHFileOperation function uses to perform file operations.


*Console.WriteLine(moji + suji);
C#もこの書き方でOK


*var outerUrl = $"https:
twitter.comintenttweet?text={UnityWebRequest.EscapeURL (outerMessage)}&url={UnityWebRequest.EscapeURL (innerUrl)}";


*Dictionary<String, String> replaceKeyValDic = new Dictionary<string, string>();
変換情報の辞書情報（再帰関数内で使用されるため面倒なのでGlobalで宣言）

*replaceKeyValDic.Add("置き換え対象文字列","置き換え文字列");
置換文字列情報を設定分追加

*app = new Microsoft.Office.Interop.PowerPoint.Application();
PPTのインスタンス作成

*ppt = app.Presentations.Open(pptFilePath,Microsoft.Office.Core.MsoTriState.msoTrue,Microsoft.Office.Core.MsoTriState.msoTrue,Microsoft.Office.Core.MsoTriState.msoFalse);
PPTファイルオープン

*ppt.SaveAs(pptGenerateFilePath,PpSaveAsFileType.ppSaveAsDefault,Microsoft.Office.Core.MsoTriState.msoFalse);
生成PPTファイルの保存を実行

*shape.TextFrame.TextRange.Text = replaceStr(shape.TextFrame.TextRange.Text);
PPT内の文字列置き換えを実施

*getShapeText(childShape);
項目設定文字列を置き換え（再帰呼び出し）

*targetStr = targetStr.Replace("[" + replaceKeyValKey + "]", replaceKeyValDic[replaceKeyValKey]);
PPTテンプレートに「[置き換え対象文字列]」の書式で設定したものを変換


*if(i==0){break;}
１個だけで終了させる

*Marshal.ReleaseComObject(shellApp);
リソースの解放


*public class Repository*{public User FindUser(int id){using (IDbConnection conn = GetConnection()){try{return conn.QueryFirst<User>(@"SELECT * from users where id = @id", new { id });}catch (Exception){// レコードが1件も無いthrow;}}}private IDbConnection GetConnection() => throw new NotImplementedException();}
中略

*throw;
レコードが1件も無い

*public class Repository*{public User FindUser(int id){using (IDbConnection conn = GetConnection()){return conn.QueryFirstOrDefault<User>(@"SELECT * from users where id = @id", new { id });}}private IDbConnection GetConnection() => throw new NotImplementedException();}
中略

*public class Repository*{public User FindUser(int id){using (IDbConnection conn = GetConnection()){try{return conn.QuerySingle<User>(@"SELECT * from users where id = @id", new { id });}catch (Exception){// レコード0件もしくはレコード複数件throw;}}}private IDbConnection GetConnection() => throw new NotImplementedException();}
中略

*throw;
レコード0件もしくはレコード複数件

*public class Repository*{public User FindUser(int id){using (IDbConnection conn = GetConnection()){try{return conn.QuerySingleOrDefault<User>(@"SELECT * from users where id = @id", new { id });}catch (Exception){// レコード複数件throw;}}}private IDbConnection GetConnection() => throw new NotImplementedException();}
中略

*throw;
レコード複数件


*builder.AddSignInManager();
こいつがないとサインインができない

*builder.Services.ConfigureOptions(                <<= なにやらいろいろしているようですが、「IdentityDefaultUIConfigureOptions」がinnerなのでコメントアウト、将来使うかもtypeof(IdentityDefaultUIConfigureOptions<>)
AddRelatedParts(builder, framework);    <<= おそらくここですべてのページを作っているのでコメントアウト

*}
builder.Services.ConfigureOptions(                <<= なにやらいろいろしているようですが、「IdentityDefaultUIConfigureOptions」がinnerなのでコメントアウト、将来使うかも
typeof(IdentityDefaultUIConfigureOptions<>)
.MakeGenericType(builder.UserType));
builder.Services.TryAddTransient<IEmailSender, EmailSender>();   この部分はメールを利用しないなら消してもよさそう、消す場合はclass「EmailSender」も不要
builder.Services.Configure<DefaultUIOptions>(o => o.UIFramework = UIFramework.Bootstrap3);   これは将来的にIdentity画面を変更してBootstrapを利用しないなら不要かと思う


*public void SendText()*{ws.Send(messageInput.text);}
サーバへ、メッセージを送信する

*public void RecvText(string text)*{chatText.text += (text + "\n");}
サーバから受け取ったメッセージを、ChatTextに表示する

*public void RecvClose()*{chatText.text = ("Close.");}
サーバの接続が切れたときのメッセージを、ChatTextに表示する

*ws.Connect();
接続処理。接続先サーバと、ポート番号を指定する
ws = new WebSocket("ws:localhost:12345/");

*sendButton.onClick.AddListener(SendText);
送信ボタンが押されたときに実行する処理「SendText」を登録する

*ws.OnMessage += (sender, e) => RecvText(e.Data);
サーバからメッセージを受信したときに実行する処理「RecvText」を登録する

*ws.OnClose += (sender, e) => RecvClose();
サーバとの接続が切れたときに実行する処理「RecvClose」を登録する

*ws = new WebSocketServer(12345);
ポート番号を指定

*ws.AddWebSocketService<ExWebSocketBehavior>("/");
クライアントからの通信時の挙動を定義したクラス、「ExWebSocketBehavior」を登録

*ws.Start();
サーバ起動

*public static List<ExWebSocketBehavior> clientList = new List<ExWebSocketBehavior>();
誰が現在接続しているのか管理するリスト。

*static int globalSeq = 0;
接続者に番号を振るための変数。

*int seq;
自身の番号

*protected override void OnOpen()*{//ログインしてきた人には、番号をつけて、リストに登録。globalSeq++;this.seq = globalSeq;clientList.Add(this);Debug.Log("Seq" + this.seq + " Login. (" + this.ID + ")");//接続者全員にメッセージを送るforeach (var client in clientList){client.Send("Seq:" + seq + " Login.");}}
誰かがログインしてきたときに呼ばれるメソッド

*globalSeq++;
ログインしてきた人には、番号をつけて、リストに登録。

*protected override void OnMessage(MessageEventArgs e)*{Debug.Log("Seq:" + seq + "..." + e.Data);//接続者全員にメッセージを送るforeach (var client in clientList){client.Send("Seq:" + seq + "..." + e.Data);}}
誰かがメッセージを送信してきたときに呼ばれるメソッド

*protected override void OnClose(CloseEventArgs e)*{Debug.Log("Seq" + this.seq + " Logout. (" + this.ID + ")");//ログアウトした人を、リストから削除。clientList.Remove(this);//接続者全員にメッセージを送るforeach (var client in clientList){client.Send("Seq:" + seq + " Logout.");}}
誰かがログアウトしてきたときに呼ばれるメソッド

*clientList.Remove(this);
ログアウトした人を、リストから削除。

*// {//    client.Send("Seq:" + seq + "..." + e.Data);// }
foreach (var client in clientList)


*Console.WriteLine(@"記事:
記事:
"c\qiita\qiita.txt"

*,,,
記事:
"c\qiita\qiita.txt"

*string pass = "c\\qiita\\qiita.txt";*Console.WriteLine($"記事:{{{pass}}}");
3

*,,,*var item = JsonConvert.DeserializeObject<JObject>($@"{{ ""url"":  ""{url}"" }}");
記事: {c\qiita\qiita.txt}


*GizmosUtility.DrawWireCircle(Vector3.zero, 2f);
円(2D)

*GizmosUtility.DrawWireRegularPolygon(3, new Vector3(4f, 0f, 0f), 2f);
正三角形(2D)

*GizmosUtility.DrawWireRegularPolygon(4, new Vector3(8f, 0f, 0f), 2f);
正四角形(2D)

*GizmosUtility.DrawWireRegularPolygon(5, new Vector3(12f, 0f, 0f), 2f);
正五角形(2D)

*GizmosUtility.DrawWireCircle(new Vector3(16f, 0f, 0f), Quaternion.LookRotation(new Vector3(-1f, 1f, 0f)), 2f);
円(3D)

*GizmosUtility.DrawWireRegularPolygon(3, new Vector3(20f, 0f, 0f), Quaternion.LookRotation(new Vector3(-1f, 1f, 0f)), 2f);
正三角形(3D)

*GizmosUtility.DrawWireRegularPolygon(4, new Vector3(24f, 0f, 0f), Quaternion.LookRotation(new Vector3(-1f, 1f, 0f)), 2f);
正四角形(3D)

*GizmosUtility.DrawWireRegularPolygon(5, new Vector3(28f, 0f, 0f), Quaternion.LookRotation(new Vector3(-1f, 1f, 0f)), 2f);
正五角形(3D)


*services.AddMvc(config =>{このフィルターを追加することで、すべてのページが原則認証されているないと表示できなくなる。ログインページなどは認証されていなくても表示できるようにするため、ページモデルに[AllowAnonymous]が必要となるが、デフォルトで設定されている。var policy = new AuthorizationPolicyBuilder()
認証機能を追加する

*var policy = new AuthorizationPolicyBuilder()
このフィルターを追加することで、すべてのページが原則認証されているないと表示できなくなる。
ログインページなどは認証されていなくても表示できるようにするため、ページモデルに
[AllowAnonymous]が必要となるが、デフォルトで設定されている。

*public static async Task Initialize(IServiceProvider serviceProvider)
初期化時のロール
public static readonly string SystemManagerRole = "SystemManager";       システム管理権限
public static readonly string GroupManagerRole = "GroupManager";         グループ管理権限
初期化時のシステム管理ユーザーID
public static readonly string StstemManageEmail = "system@test.com";     最初のシステム管理ユーザーのメールアドレス
public static readonly string StstemManagePassword = "!initialPassword01";     最初のシステム管理ユーザーの初期パスワード

*var userManager = serviceProvider.GetService<UserManager<IdentityUser>>();
ユーザー管理を取得(using Microsoft.Extensions.DependencyInjectionがないとエラーになる)

*var systemManager = await userManager.FindByNameAsync(StstemManageEmail);
初期のユーザーマネージャーが存在しなければロールの作成と初期システムユーザーを作成する

*var roleManager = serviceProvider.GetService<RoleManager<IdentityRole>>();
ロール管理を取得

*systemManager = new IdentityUser { UserName = StstemManageEmail, Email = StstemManageEmail };
ロールの追加
await roleManager.CreateAsync(new IdentityRole(SystemManagerRole));     システム管理ロール
await roleManager.CreateAsync(new IdentityRole(GroupManagerRole));     グループ管理ロール
初期システム管理者の作成
なぜか知らないが、デフォルトのログイン画面はユーザーIDではなくメールアドレスを要求し、バリデーションもメールで設定されている。
ところが、ログイン処理自体は「Email」ではなく「UserName」で行われるので両方に設定せざるを得ない。
なんでこんなことのなっているのか？　変更するにはログイン画面を変えればいい

*systemManager = await userManager.FindByNameAsync(StstemManageEmail);
システム管理ユーザーにシステム管理ロールを追加

*var host = CreateWebHostBuilder(args).Build();
CreateWebHostBuilder(args).Build().Run();　<= もともとこの１行だけのはず
上の１行のコードを以下のように変更

*var services = scope.ServiceProvider;
サービスプロバイダーの取得

*var context = services.GetRequiredService<ApplicationDbContext>();
データベースの自動マイグレーション

*UserRollInitialize.Initialize(services).Wait();
初期のユーザーとロールの作成


*var spriteHandle = Addressables.LoadAssetsAsync<Sprite> ("Sprites", null);
ラベルを指定して一括ロード

*yield return new WaitUntil (() => textHandle.IsDone && imageHandle.IsDone && spriteHandle.IsDone);
完了の待機

*if (textHandle.Status == UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationStatus.Succeeded*&& imageHandle.Status == UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationStatus.Succeeded
エラーがないことを確認

*var image = Instantiate (imageHandle.Result, transform).GetComponent<Image> ();*var text = Instantiate (textHandle.Result, transform).GetComponent<Text> ();
プレファブからオブジェクトを生成


*services.Configure<AppSettings>(configuration.GetSection("AppSettings"));
設定ファイルの内容をバインドする

*services.AddTransient<IHelloService, HelloService>();
サービスのDI設定を行う


*void Start()*{GetComponent<LocalClock>().localTimeScale = 0.01f;}
Start is called before the first frame update

*void Update()*{}
Update is called once per frame

*void Start()*{}
Start is called before the first frame update

*void Update()*{if (Input.GetKeyDown(KeyCode.T)){if (GetComponent<GlobalClock>().localTimeScale == 0)GetComponent<GlobalClock>().localTimeScale = 1;elseGetComponent<GlobalClock>().localTimeScale = 0;}}
Update is called once per frame


*MyImage.Source = bitmapImage;
「MyImage」は、xamlの<Image Name="MyImage">より。砂嵐を張り付けるImageの名前。


*var hex = Convert.ToInt32("1a", 16);
16進数

*,,,
上から3, 9, 26になる

*str = "123e4";
123456789に変換される


*int retryMax = 3;
リトライ最大回数(引数で指定してもいいかも)

*T result = default( T );
戻り値を初期化しておく

*Thread.Sleep( 500 );
リトライ間隔を適当にあけておく


*Application xlApp = new Application();
ファイルオープン

*Worksheet sheet = xlBook.Sheets["メンバー一覧"];
シートを選択

*Range TableRange = sheet.Range["A1", "B15"];
セルの領域を選択

*object[,] values = TableRange.Value;
選択した領域の値をメモリー上に格納

*System.Runtime.InteropServices.Marshal.ReleaseComObject(TableRange);
使用したCOMオブジェクトを解放

*xlBook.Close();
Excelのクローズ

*System.Runtime.InteropServices.Marshal.FinalReleaseComObject(xlBook);
使用したCOMオブジェクトを解放その２

*object xlApp = Activator.CreateInstance(Type.GetTypeFromProgID("Excel.Application"));
ファイルオープン

*dynamic xlApp = Activator.CreateInstance(Type.GetTypeFromProgID("Excel.Application"));
ファイルオープン

*using ExtractExcelDataInterface;
インターフェースの名前空間

*using Microsoft.Office.Interop.Excel;
Excelを操作するために必要なクラスの名前空間を追加

*Dictionary<string, string> dic = new Dictionary<string, string>();
returnするDicionaryインスタンス

*Application xlApp = new Application();
ファイルオープン

*Worksheet sheet = xlBook.Sheets["メンバー一覧"];
シートを選択

*Range TableRange = sheet.Range["A1", "B15"];
セルの領域を選択

*object[,] values = TableRange.Value;
選択した領域の値をメモリー上に格納
（１セルずつ見ていくよりも早い）

*for (int i = 1; i <= values.GetLength(0); i++)
配列アクセスができるので、それぞれをDictionaryに追加
[WARNING] 配列の開始インデックスは１から

*System.Runtime.InteropServices.Marshal.ReleaseComObject(TableRange);
使用したCOMオブジェクトを解放

*xlBook.Close();
Excelのクローズ

*System.Runtime.InteropServices.Marshal.FinalReleaseComObject(xlBook);
使用したCOMオブジェクトを解放その２

*object sheet = xlBook.GetType().InvokeMember("Sheets", System.Reflection.BindingFlags.GetProperty, null, xlBook, new object[] { "メンバー一覧" });
シートを選択

*object TableRange = sheet.GetType().InvokeMember("Range", System.Reflection.BindingFlags.GetProperty, null, sheet, new object[] { "A1", "B15" });
セルの領域を選択

*object[,] values = TableRange.GetType().InvokeMember("Value", System.Reflection.BindingFlags.GetProperty, null, TableRange, null) as object[,];
選択した領域の値をメモリー上に格納
（１セルずつ見ていくよりも早い）

*for (int i = 1; i <= values.GetLength(0); i++)
配列アクセスができるので、それぞれをDictionaryに追加
[WARNING] 配列の開始インデックスは１から

*System.Runtime.InteropServices.Marshal.ReleaseComObject(TableRange);
使用したCOMオブジェクトを解放

*xlBook.GetType().InvokeMember("Close", System.Reflection.BindingFlags.InvokeMethod, null, xlBook, null);
Excelのクローズ

*System.Runtime.InteropServices.Marshal.FinalReleaseComObject(xlBook);
使用したCOMオブジェクトを解放その２

*dynamic xlApp = Activator.CreateInstance(Type.GetTypeFromProgID("Excel.Application"));
ファイルオープン

*dynamic sheet = xlBook.Sheets["メンバー一覧"];
シートを選択

*dynamic TableRange = sheet.Range["A1", "B15"];
セルの領域を選択

*object[,] values = TableRange.Value;
選択した領域の値をメモリー上に格納
（１セルずつ見ていくよりも早い）

*for (int i = 1; i <= values.GetLength(0); i++)
配列アクセスができるので、それぞれをDictionaryに追加
[WARNING] 配列の開始インデックスは１から

*System.Runtime.InteropServices.Marshal.ReleaseComObject(TableRange);
使用したCOMオブジェクトを解放

*xlBook.Close();
Excelのクローズ

*System.Runtime.InteropServices.Marshal.FinalReleaseComObject(xlBook);
使用したCOMオブジェクトを解放その２


*var type = timelineClip.GetType();*//Debug.Log($"name {timelineClip.name} {timelineClip.GetType()}");
タイムラインのそれぞれのタイプを取得

*var animationTrack = timelineClip as AnimationTrack;
TrackAssetをAnimationTrackで取得

*var binding = playableDirector.GetGenericBinding(animationTrack);*//Debug.Log($"binding: {binding?.name}");
playableDirectorから各トラックを取得する

*var animationClip = animationTrack.infiniteClip;
アニーしょんタックに設定されているアニメーションクリップを取得

*if (animationClip)
アニメーションがすげにある場合
新たにアニメーションを上書きすると情報がおかしくなるので
少々違った方法で

*var animationCurveList = AnimationUtility.GetAllCurves(animationClip).Where(_ => _.propertyName == _propertyName).ToList();
アニメーショントラックからアニメーションカーブを取得する

*AnimationUtility.SetEditorCurve(animationClip, curveBinding, animationCurve!=null?  animationCurve.curve : curve);
アニメーションクリップを再セットする

*Repaint();
再描画を依頼する

*animationClip.SetCurve(isParent == false ? "" : _skinnedMeshRenderer.name, typeof(SkinnedMeshRenderer), _propertyName, curve);
アニメーションクリップをセットする

*Repaint();
再描画を依頼する


*var template = config.logFormat;
まぁ、こんな感じで↑の<logFormat>~<logFormat>が取れるとしよう。


*return RedirectToAction(nameof(Index2));
Getで定義されたActionがないのでエラー


*await UniTask.WaitUntil(() =>ovrTracker.isPositionTracked);
HMDがトラッキングされるまで待つ


*else {
unknown type


*for(int i = 0; i < Paneles.Count; i++)
確認用の表記


*var assembly = Assembly.LoadFrom(asmPath);
"C:\Windows\Microsoft.Net\assembly\GAC_MSIL\System\v4.0_4.0.0.0__b77a5c561934e089\System.dll");(assemblyName);


*ServiceEventLog = new System.Diagnostics.EventLog();
---------- 以下が追加した処理 ----------


*static void test1()*{{Excel.Application app = new Excel.Application();{Excel.Workbooks books = app.Workbooks;Excel.Workbook book = books.Open(@"test.xlsx");Excel.Sheets sheets = book.Sheets;Excel.Worksheet sheet = sheets["Sheet1"];Excel.Range cells = sheet.Cells;Excel.Range cell = cells[1, 1];Console.WriteLine(cell.Value);book.Close(Type.Missing, Type.Missing, Type.Missing);Marshal.ReleaseComObject(cell);Marshal.ReleaseComObject(cells);Marshal.ReleaseComObject(sheet);Marshal.ReleaseComObject(sheets);Marshal.ReleaseComObject(book);Marshal.ReleaseComObject(books);}GC.Collect();GC.WaitForPendingFinalizers();GC.Collect();app.Quit();Marshal.ReleaseComObject(app);}// Application オブジェクトのガベージ コレクトを強制します。GC.Collect();GC.WaitForPendingFinalizers();GC.Collect();}
略

*GC.Collect();
Application オブジェクトのガベージ コレクトを強制します。

*GC.Collect();
Application オブジェクトのガベージ コレクトを強制します。

*private static bool GetPathToObject(ClrHeap heap, ulong objectPointer, Stack<ulong> stack, HashSet<ulong> touchedObjects)*{// Start of the journey - get address of the first objetc on our reference chainvar currentObject = stack.Peek();// Have we checked this object before?if (!touchedObjects.Add(currentObject)){return false;}// Did we find our object? Then we have the path!if (currentObject == objectPointer){return true;}// Enumerate internal references of the objectvar found = false;var type = heap.GetObjectType(currentObject);if (type != null){type.EnumerateRefsOfObject(currentObject, (innerObject, fieldOffset) =>{if (innerObject == 0 || touchedObjects.Contains(innerObject)){return;}// Push the object onto our stackstack.Push(innerObject);if (GetPathToObject(heap, objectPointer, stack, touchedObjects)){found = true;return;}// If not found, pop the object from our stack as this is not the tree we're looking forstack.Pop();});}return found;}
https:blog.maartenballiauw.be/post/2017/01/03/exploring-.net-managed-heap-with-clrmd.html

*static void t1()*{Excel.Application app = new Excel.Application();app.Quit();Console.WriteLine("ここでヒープのチェックを行う");Console.ReadLine();}
using Excel = Microsoft.Office.Interop.Excel;

*static void t1_2()*{Excel.Application app = new Excel.Application();app.Quit();Marshal.ReleaseComObject(app);Console.WriteLine("ここでヒープのチェックを行う");Console.ReadLine();}
using Excel = Microsoft.Office.Interop.Excel;

*static void t1_3()*{Excel.Application app = new Excel.Application();app.Quit();app = null;GC.Collect();GC.WaitForPendingFinalizers();GC.Collect();Console.WriteLine("ここでヒープのチェックを行う t1_3");Console.ReadLine();}
using Excel = Microsoft.Office.Interop.Excel;

*static void t2()*{Excel.Application app = new Excel.Application();// Workbooksの暗黙のオブジェクトの作成Excel.Workbook book = app.Workbooks.Open(@"test.xlsx");Console.WriteLine("ここでヒープのチェックを行う1");Console.ReadLine();book.Close();Marshal.ReleaseComObject(book);app.Quit();Marshal.ReleaseComObject(app);Console.WriteLine("ここでヒープのチェックを行う2");Console.ReadLine();}
using Excel = Microsoft.Office.Interop.Excel;

*Excel.Workbook book = app.Workbooks.Open(@"test.xlsx");
Workbooksの暗黙のオブジェクトの作成

*static void t4()*{Excel.Application app = new Excel.Application();Excel.Workbooks books = app.Workbooks;Excel.Workbook book = books.Open(@"test.xlsx");var book2 = book;Console.WriteLine(book.Name);Console.WriteLine(book2.Name);Console.WriteLine("ここでヒープのチェックを行う1 t_1");Console.ReadLine();book.Close();Marshal.ReleaseComObject(book);Marshal.ReleaseComObject(books);app.Quit();Marshal.ReleaseComObject(app);Console.WriteLine("ここでヒープのチェックを行う2");Console.ReadLine();}
using Excel = Microsoft.Office.Interop.Excel;


*return string.Compare(s1, s2, true);
第3引数の true は、大文字小文字の差異を無視する指定(ignore case)


*{var toolbar = new Toolbar();root.Add(toolbar);var btn1 = new ToolbarButton { text = "Button" };toolbar.Add(btn1);var spc = new ToolbarSpacer();toolbar.Add(spc);var tgl = new ToolbarToggle { text = "Toggle" };toolbar.Add(tgl);var spc2 = new ToolbarSpacer() { name = "flexSpacer1", flex = true };toolbar.Add(spc2);var menu = new ToolbarMenu { text = "Menu" };menu.menu.AppendAction("Default is never shown", a => { }, a => DropdownMenuAction.Status.None);menu.menu.AppendAction("Normal menu", a => { }, a => DropdownMenuAction.Status.Normal);menu.menu.AppendAction("Hidden is never shown", a => { }, a => DropdownMenuAction.Status.Hidden);menu.menu.AppendAction("Checked menu", a => { }, a => DropdownMenuAction.Status.Checked);menu.menu.AppendAction("Disabled menu", a => { }, a => DropdownMenuAction.Status.Disabled);menu.menu.AppendAction("Disabled and checked menu", a => { }, a => DropdownMenuAction.Status.Disabled | DropdownMenuAction.Status.Checked);toolbar.Add(menu);var spc3 = new ToolbarSpacer() { name = "flexSpacer2", flex = true };toolbar.Add(spc3);var popup = new ToolbarMenu { text = "Popup", variant = ToolbarMenu.Variant.Popup };popup.menu.AppendAction("Popup", a => { }, a => DropdownMenuAction.Status.Normal);toolbar.Add(popup);}
Create Toolbar

*{var visualTree = AssetDatabase.LoadAssetAtPath<VisualTreeAsset>("Assets/Editor/Sample2.uxml");// var styleSheet = AssetDatabase.LoadAssetAtPath<StyleSheet>("Assets/Editor/Sample2.uss");VisualElement labelFromUXML = visualTree.CloneTree();// labelFromUXML.styleSheets.Add(styleSheet);root.Add(labelFromUXML);}
Import UXML


*TypeDescriptor.AddAttributes(typeof(System.Collections.Specialized.StringCollection),
StringCollectionの初期の編集画面では追加ができない。
これを実行することで編集画面が変わり、追加できるようになる。

*copiedSettings = new Settings();
設定のコピーを作成する

*copiedSettings[property.Name] = deepCopy(Settings.Default[property.Name]);
StringCollection型のために必要

*propertyGrid1.SelectedObject = copiedSettings;
コピーしたオブジェクトを表示させる

*Settings.Default[property.Name] = deepCopy(copiedSettings[property.Name]);
StringCollection型のために必要

*var categoryTable = new Dictionary<string, Attribute>()*{{ nameof(Settings.BoolSetting),             new CategoryAttribute("組み込みのデータ型") },{ nameof(Settings.StringSetting),           new CategoryAttribute("組み込みのデータ型") },{ nameof(Settings.StringCollectionSetting), new CategoryAttribute("複合データ型") },{ nameof(Settings.DateTimeSetting),         new CategoryAttribute("複合データ型") },{ nameof(Settings.IntSetting),              new CategoryAttribute("組み込みのデータ型") },};
PropertyGridのCategoryを設定する

*var descriptionTable = new Dictionary<string, Attribute>()*{{ nameof(Settings.BoolSetting),             new DescriptionAttribute("bool型の設定") },{ nameof(Settings.StringSetting),           new DescriptionAttribute("string型の設定") },{ nameof(Settings.StringCollectionSetting), new DescriptionAttribute("複数のstring型の設定") },{ nameof(Settings.DateTimeSetting),         new DescriptionAttribute("DateTime型の設定") },{ nameof(Settings.IntSetting),              new DescriptionAttribute("int型の設定") },};
PropertyGridのHelpテキストを設定する

*var fi = p.Attributes.GetType().GetField("_attributes", BindingFlags.NonPublic | BindingFlags.Instance);
属性を追加する。
本当はMemberDescriptor.Attributes.Addのようにしたいのだが、Attributes属性はgetだけ定義されている。
そのためリフレクションを使って属性を追加する

*TypeDescriptor.AddAttributes(typeof(System.Collections.Specialized.StringCollection),
これを追加しないと、StringCollectionの追加ができない

*string fullPath;
ファイルを選択

*try*{// user.configのパスを取得string userConfigPath = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.PerUserRoamingAndLocal).FilePath;// ファイルが無ければSave()して生成するif (!File.Exists(userConfigPath)){Settings.Default.Save();}// エクスポートはファイルをコピーするだけFile.Copy(userConfigPath, fullPath, true);MessageBox.Show("エクスポートしました");}
ファイルをコピー

*string userConfigPath = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.PerUserRoamingAndLocal).FilePath;
user.configのパスを取得

*File.Copy(userConfigPath, fullPath, true);
エクスポートはファイルをコピーするだけ

*var tmpAppConfig  = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
ExeConfigFilenameにインポートするファイルだけ指定しても、そのファイルにはセクション情報が書かれていないためGetSectionで正しく読めない。
さらに、ExeConfigFilenameにアプリケーション設定、RoamingUserConfigFilenameにインポートするファイルを指定しても、正しく動かない場合がある。
例えばインポートするファイルに吐かれていない新規設定がある場合、本来は現在値を保持してほしいが、デフォルト値で上書きしてしまう。
ということで、ExeConfigFilename/RoamingUserConfigFilenam/LocalUserConfigFilenameの3つを指定して読み込む。

*var dict = new Dictionary<string, SettingElement>();
Key:プロパティ名、Value:読み込んだファイルの該当プロパティのSettingElement、のDictionaryを作成する

*var _ChangedSinceLastSerialized = typeof(SettingsPropertyValue).GetField("_ChangedSinceLastSerialized", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Instance);
SerializedValueを1度も参照していないと、参照したときの元の値に戻ってしまうという仕様になっている。
https:referencesource.microsoft.com/#System/sys/system/configuration/SettingsPropertyValue.cs,69
その対策として、リフレクションで無理やり内部のメンバをfalseに変更する。
リフレクションを使わなくても、var dummy = value.SerializedValueを実行して1度参照する方法でもよい。

*value.SerializedValue = element.Value.ValueXml.InnerXml;
値の設定

*value.Deserialized = false;
value.Deserializedをfalseにすると、value.PropertyValueにアクセスしたときにDeserializeされる

*string fullPath = "";
ファイル選択

*ClientSettingsSection section = null;
読み込み

*var tmpAppConfig  = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
ExeConfigFilenameにインポートするファイルだけ指定しても、そのファイルにはセクション情報が書かれていないためGetSectionで正しく読めない。
さらに、ExeConfigFilenameにアプリケーション設定、RoamingUserConfigFilenameにインポートするファイルを指定しても、正しく動かない場合がある。
例えばインポートするファイルに吐かれていない新規設定がある場合、本来は現在値を保持してほしいが、デフォルト値で上書きしてしまう。
ということで、ExeConfigFilename/RoamingUserConfigFilenam/LocalUserConfigFilenameの3つを指定して読み込む。

*try*{// Key:プロパティ名、Value:読み込んだファイルの該当プロパティのSettingElement、のDictionaryを作成するvar dict = new Dictionary<string, SettingElement>();foreach (SettingElement v in section.Settings){dict.Add(v.Name, v);}// 現在の設定を更新するforeach (SettingsPropertyValue value in copiedSettings.PropertyValues){SettingElement element;if (dict.TryGetValue(value.Name, out element)){// SerializedValueを1度も参照していないと、参照したときの元の値に戻ってしまうという仕様になっている。// https://referencesource.microsoft.com/#System/sys/system/configuration/SettingsPropertyValue.cs,69// その対策として、リフレクションで無理やり内部のメンバをfalseに変更する。// リフレクションを使わなくても、var dummy = value.SerializedValueを実行して1度参照する方法でもよい。var _ChangedSinceLastSerialized = typeof(SettingsPropertyValue).GetField("_ChangedSinceLastSerialized", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Instance);_ChangedSinceLastSerialized.SetValue(value, false);// 値の設定value.SerializedValue = element.Value.ValueXml.InnerXml;// value.Deserializedをfalseにすると、value.PropertyValueにアクセスしたときにDeserializeされる.// https://referencesource.microsoft.com/#System/sys/system/configuration/SettingsPropertyValue.cs,40value.Deserialized = false;}}}
データの更新

*var dict = new Dictionary<string, SettingElement>();
Key:プロパティ名、Value:読み込んだファイルの該当プロパティのSettingElement、のDictionaryを作成する

*var _ChangedSinceLastSerialized = typeof(SettingsPropertyValue).GetField("_ChangedSinceLastSerialized", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Instance);
SerializedValueを1度も参照していないと、参照したときの元の値に戻ってしまうという仕様になっている。
https:referencesource.microsoft.com/#System/sys/system/configuration/SettingsPropertyValue.cs,69
その対策として、リフレクションで無理やり内部のメンバをfalseに変更する。
リフレクションを使わなくても、var dummy = value.SerializedValueを実行して1度参照する方法でもよい。

*value.SerializedValue = element.Value.ValueXml.InnerXml;
値の設定

*value.Deserialized = false;
value.Deserializedをfalseにすると、value.PropertyValueにアクセスしたときにDeserializeされる.
https:referencesource.microsoft.com/#System/sys/system/configuration/SettingsPropertyValue.cs,40

*propertyGrid1.SelectedObject = copiedSettings;
画面を更新

*MessageBox.Show("インポートした設定を反映するには保存を押してください");
メッセージ


*public static partial class StringExtend*{// 引数には this + 拡張対象の型 + 変数名 を定義する。public static int ToInt32(this string value) => Convert.ToInt32(value);}
静的クラス・静的メソッドで定義することに注意。

*public static int ToInt32(this string value) => Convert.ToInt32(value);
引数には this + 拡張対象の型 + 変数名 を定義する。

*public int ToInt(string value) => value.ToInt32();
ex) 文字列型"123"が入力されると、数値型123が返ってくる。

*public int ToInt(Engine engine) => engine.ToIndex();
ex) 列挙体の要素 Engine.MySQL が入力されると、対応する数値 1 が返ってくる。

*public static Engine ToEngine(this int index) => (Engine)Enum.ToObject(typeof(Engine), index);
ex) 数値 1 が入力されると、列挙体の要素 Engine.MySQL が返ってくる。

*public static Engine ToEngine(this string value) => (Engine)Enum.Parse(typeof(Engine), value, true);
ex) 文字列 "MySQL" が入力されると、列挙体の要素 Engine.MySQL が返ってくる。


*void Start()*{}
Start is called before the first frame update

*void Update()*{AdjustShutter(1280, 720);}
Update is called once per frame


*if ( !(y >= -20.0 && y <= 20.0) ) {
!でとることで0除算での不定値をはじく


*else
消えかけると激しく点滅


*string aqs = I2cDevice.GetDeviceSelector("I2C1");
すべてのI2Cデバイスを取得するためのセレクタ文字列を取得

*var dis = await DeviceInformation.FindAllAsync(aqs);*if (dis.Count == 0)
セレクタ文字列を使ってI2Cコントローラデバイスを取得

*var settings = new I2cConnectionSettings(ACCEL_I2C_ADDR);
I2Cアドレスを指定して、デフォルトのI2C設定を作成する
private const byte ACCEL_I2C_ADDR = 0x68;

*settings.BusSpeed = I2cBusSpeed.FastMode;
バス速度を設定(FastMode：400 kHz)(指定しないと、標準設定(StandardMode：100kHz)になる)

*I2CAccel = await I2cDevice.FromIdAsync(dis[0].Id, settings);
取得したI2Cデバイスと作成した設定で、I2cDeviceのインスタンスを作成

*try*{// 送信用バッファbyte[] WriteBuf;// 受信用バッファbyte[] ReadBuf;// アドレス取得(イニシャルに必須ではない。どこのサンプルにも書いてるので一応やっとく)WriteBuf = new byte[] { 0x75 };ReadBuf = new byte[1];I2CAccel.WriteRead(WriteBuf, ReadBuf);// センシング開始要求(レジスタ0x6Bに00を書き込み)WriteBuf = new byte[] { 0x6B, 0x00 };I2CAccel.Write(WriteBuf);// センシング開始要求(レジスタ0x37に02を書き込み)WriteBuf = new byte[] { 0x37, 0x02 };I2CAccel.Write(WriteBuf);}
ジャイロセンサ(MPU-9150)の設定を行うための通信

*byte[] WriteBuf;
送信用バッファ

*byte[] ReadBuf;
受信用バッファ

*WriteBuf = new byte[] { 0x75 };
アドレス取得(イニシャルに必須ではない。どこのサンプルにも書いてるので一応やっとく)

*WriteBuf = new byte[] { 0x6B, 0x00 };
センシング開始要求(レジスタ0x6Bに00を書き込み)

*WriteBuf = new byte[] { 0x37, 0x02 };
センシング開始要求(レジスタ0x37に02を書き込み)

*periodicTimer = new Timer(this.TimerCallback, null, 0, 100);
初期化完了。100msごとにデータを採るためのコールバックを作成する

*byte[] WriteBuf;
送信用バッファ

*byte[] ReadBuf;
受信用バッファ

*WriteBuf = new byte[] { 0x3B };
アドレス取得


*private Vector3 _relavivePosition;
手のローカル座標を用いた、ターゲットへの相対位置

*private Vector3 _parentLocalAxis;
virtualParentのローカル座標を用いた、virtualParent.rotation -> virtualChild.rotationへの回転軸

*private float _rotationAngle;*public Transform VirtualParent { get; private set; } = null;
virtualParent.rotation -> virtualChild.rotationへの回転量

*_relavivePosition = VirtualParent.InverseTransformPoint(VirtualChild.position);*// 登録直後の状態のVirtualParentのrotationをVirtualChildのrotationに一致させるための回転行列を求める。
VirtualParentのローカル座標系で表した場合のターゲットオブジェクトの位置

*求めたい回転行列をAとし, VirtualChild, VirtualParentのrotationをC,Pとすると、C = A * Pであり、両辺からPの逆行列（Inverse(P)）をかけると A = C * Inverse(P)var rotationMatrix = VirtualChild.rotation * Quaternion.Inverse(VirtualParent.rotation);
登録直後の状態のVirtualParentのrotationをVirtualChildのrotationに一致させるための回転行列を求める。

*両辺からPの逆行列（Inverse(P)）をかけると A = C * Inverse(P)var rotationMatrix = VirtualChild.rotation * Quaternion.Inverse(VirtualParent.rotation);
求めたい回転行列をAとし, VirtualChild, VirtualParentのrotationをC,Pとすると、C = A * Pであり、

*var rotationMatrix = VirtualChild.rotation * Quaternion.Inverse(VirtualParent.rotation);
両辺からPの逆行列（Inverse(P)）をかけると A = C * Inverse(P)

*rotationMatrix.ToAngleAxis(out _rotationAngle, out Vector3 grobalAxis);
rotationMatrixはグローバル座標を使って表現されているため、virtualParentが少しでも回転した後は使えないが、
Quaternionから回転量（angle）と回転軸（axis）を抽出すると、angleはそのまま使える

*_parentLocalAxis = VirtualParent.InverseTransformVector(grobalAxis);
axisはVirtualParentのローカル座標で表現しておき、
使うタイミングでVirtualParentのrotationをもとにグローバル座標へ変換し直す

*var position = VirtualParent.TransformPoint(_relavivePosition);*var grobalAxis = VirtualParent.TransformVector(_parentLocalAxis);
ローカル座標 -> グローバル座標へ変換

*var rotation = Quaternion.AngleAxis(_rotationAngle, grobalAxis) * VirtualParent.rotation;
(回転行列) * 親のrotation


*catch ( Microsoft.JScript.JScriptException e ) {
コンパイルにするには Microsoft.Vsa.dll を参照に追加する必要がある


*options.UseNpgsql(
<= この部分を変更


*ie.Navigate("https:
www.google.com");


*string url = "https:
stocks.finance.yahoo.co.jpstockshistory?code=998407.O";


*embed.AddField("Googleリンク", "[こちら](https:
www.google.com) をクリック。");

*await message.Channel.SendMessageAsync("テスト", embed: embed.Build());
作成したEmbedをbotに送信させる。


*Quaternion deltaRotation = Quaternion.Inverse(_rotationPrevious) * transform.rotation;*// 角度と回転軸に変換
回転変化量を計算

*deltaRotation.ToAngleAxis(out float angle, out Vector3 axis);
角度と回転軸に変換

*float angularSpeed = (angle * Mathf.Deg2Rad) / Time.deltaTime;
角速度 [rad/s] を算出

*_rotationPrevious = transform.rotation;*}
今回値を覚えておく

*_estimatedAngularVelocity = transform.rotation.eulerAngles - _rotationPrevious.eulerAngles;*_estimatedAngularVelocity = (_estimatedAngularVelocity * Mathf.Deg2Rad) / Time.deltaTime;
回転変化量を計算

*_rotationPrevious = transform.rotation;*,,,
今回値を覚えておく


*bw.Write(bMessage);
文字列のbyte配列


*public string PipelineSource;
パイプライン作成のための文字列.

*private Element _pipeline { get; set; }
文字列から生成したパイプライン格納変数.

*private IntPtr _handle;
コントロールのハンドル.

*this.Dispose += ( sender, args ) =>*{if( _pipeline == null )return;_pipeline.Bus.SyncMessage -= Bus_SyncMessage;_pipeline.Bus.Message -= Bus_Message;_pipeline.SetState( State.Null );_pipeline.Dispose();_pipeline = null;};
開放処理を追加しておく.

*public void Execute()*{if( string.IsNullOrEmpty( PipelineSource ) )return;if( InitGstreamerPipeline() )HandleRealized();}
実行.

*private bool InitGstreamerPipeline()*{if( _pipeline != null )_pipeline.SetState( State.Null );// パイプライン生成_pipeline = Parse.Launch( PipelineSource );if( _pipeline == null )return false;_pipeline.Bus.EnableSyncMessageEmission();_pipeline.Bus.AddSignalWatch();_pipeline.Bus.SyncMessage += Bus_SyncMessage;_pipeline.Bus.Message += Bus_Message;_pipeline.SetState( State.Playing );return true;}
パイプライン作成.

*_pipeline = Parse.Launch( PipelineSource );
パイプライン生成

*break;
エラー処理.

*break;
ストリーム終了.

*break;
再生開始.

*private void HandleRealized()*{_handle = this.Handle();Element overlay = ( ( Gst.Bin ) _pipeline ).GetByInterface( VideoOerlayAdapter.GType );var adapter = new VideoOverlayAdapter( overlay.Handle );adapter.WindowHandle = _handle;adapter.HandleEvent( true );}
コントロールに映像を埋め込むためハンドルを渡す.

*public void Stop()*{if( _pipeline == null )return;_pipeline.Bus.SyncMessage -= Bus_SyncMessage;_pipeline.Bus.Message -= Bus_Message;_pipeline.SetState( State.Null );_pipeline.Dispose();_pipeline = null;}
停止.

*videoPanel.PipelieSource = "/*再生したい内容*/";
Gstreamerのパイプライン生成文字列を入れる.


*private IEnumerator WaitStateChange()*{var currentAnimatorState = _animator.GetCurrentAnimatorStateInfo(0);yield return new WaitWhile(() => currentAnimatorState.IsName("Idle"));Debug.Log("Do Something.");}
NG

*private IEnumerator WaitStateChange()*{yield return new WaitWhile(() => _animator.GetCurrentAnimatorStateInfo(0).IsName("Idle"));Debug.Log("Do Something.");}
OK


*#if !UNITY_EDITOR*using Windows.Networking.Sockets;
<JEM>Ignore unity editor and run this code in the hololens instead</JEM>

*public class ImageReceiver : MonoBehaviour {RawImage rend;bool socketClosed = false;bool writeStringToFile = false;bool loadTexture = false;bool logSize = false;public uint BUFFER_SIZE = 8192;public uint PORT = 8080;private readonly int DELAYMILLISEC = 10;public string textAll = "";string error_message;string error_source;string FILENAME = "received.png"#if !UNITY_EDITORStreamSocketListener listener;#endif// Use this for initializationvoid Start() {#if !UNITY_EDITORrend = this.GetComponent<RawImage>();listener = new StreamSocketListener();listener.ConnectionReceived += _receiver_socket_ConnectionReceived;listener.Control.KeepAlive = true;Listener_Start();#endif}#if !UNITY_EDITORprivate async void Listener_Start(){try{await listener.BindServiceNameAsync(PORT.ToString());Debug.Log("Listener started");Debug.Log(NetworkUtils.GetMyIPAddress() + " : " + PORT.ToString());} catch (Exception e){Debug.Log("Error: " + e.Message);}}private async void _receiver_socket_ConnectionReceived(StreamSocketListener sender, StreamSocketListenerConnectionReceivedEventArgs args){try{if (loadTexture != true) {string folderPath = System.IO.Directory.GetCurrentDirectory();// Create sample file; replace if exists.// Must be set as TemporaryFolder to read files from HoloLens.Windows.Storage.StorageFolder storageFolder = Windows.Storage.ApplicationData.Current.TemporaryFolder;using (var dr = new DataReader(args.Socket.InputStream)) {using (IInputStream input = args.Socket.InputStream) {using (var imageFile = new FileStream(storageFolder.Path + @"\" + FILENAME, FileMode.Create)) {using (FromBase64Transform myTransform = new FromBase64Transform(FromBase64TransformMode.IgnoreWhiteSpaces)) {byte[] data = new byte[BUFFER_SIZE];IBuffer buffer = data.AsBuffer();uint dataRead = BUFFER_SIZE;byte[] dataTransformed = new byte[BUFFER_SIZE];while (dataRead == BUFFER_SIZE) {await input.ReadAsync(buffer, BUFFER_SIZE, InputStreamOptions.Partial);int bytesWritten = myTransform.TransformBlock(data, 0,(int)BUFFER_SIZE, dataTransformed, 0);await Task.Delay(DELAYMILLISEC);imageFile.Write(dataTransformed, 0, bytesWritten);dataRead = buffer.Length;}dataTransformed = myTransform.TransformFinalBlock(data, 0, data.Length - (int)dataRead);imageFile.Write(dataTransformed, 0, dataTransformed.Length);myTransform.Clear();}imageFile.Flush();}}}loadTexture = true;}}catch (Exception e){error_source = e.Source;error_message = e.Message;socketClosed = true;}finally {if (loadTexture == true) {using (var dw = new DataWriter(args.Socket.OutputStream)) {dw.WriteString("OK");await dw.StoreAsync();dw.DetachStream();}} else {using (var dw = new DataWriter(args.Socket.OutputStream)) {dw.WriteString("NG");await dw.StoreAsync();dw.DetachStream();}}}}void Update() {if (logSize) {Debug.Log("SIZE IS : " + BUFFER_SIZE.ToString());logSize = false;}if (socketClosed) {Debug.Log(error_source);Debug.Log(error_message);Debug.Log("OOPS SOCKET CLOSED ");socketClosed = false;Debug.Log(textAll);}if (writeStringToFile) {Debug.Log("WRITTEN TO FILE");writeStringToFile = false;}if (loadTexture) {Debug.Log("LOADING IMAGE CURRENTLY");// Must be set as TemporaryFolder to read files from HoloLens.Windows.Storage.StorageFolder storageFolder = Windows.Storage.ApplicationData.Current.TemporaryFolder;string imgpath = storageFolder.Path + @"\" + FILENAME;Destroy(this.rend.texture);this.rend.texture = ReadPngAsTexture(imgpath);this.rend.SetNativeSize();Debug.Log("LOADED IMAGE");Debug.Log(textAll);loadTexture = false;}}#endifprivate static byte[] ReadPngFile(string path) {byte[] values;using (FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read)) {using (BinaryReader bin = new BinaryReader(fileStream)) {values = bin.ReadBytes((int)bin.BaseStream.Length);}}return values;}private static Texture2D ReadPngAsTexture(string path) {byte[] readBinary = ReadPngFile(path);Texture2D texture = new Texture2D(1, 1);texture.LoadImage(readBinary);return texture;}}
Able to act as a reciever

*void Start() {#if !UNITY_EDITORrend = this.GetComponent<RawImage>();listener = new StreamSocketListener();listener.ConnectionReceived += _receiver_socket_ConnectionReceived;listener.Control.KeepAlive = true;Listener_Start();#endif}
Use this for initialization

*Windows.Storage.StorageFolder storageFolder = Windows.Storage.ApplicationData.Current.TemporaryFolder;*using (var dr = new DataReader(args.Socket.InputStream)) {using (IInputStream input = args.Socket.InputStream) {using (var imageFile = new FileStream(storageFolder.Path + @"\" + FILENAME, FileMode.Create)) {using (FromBase64Transform myTransform = new FromBase64Transform(FromBase64TransformMode.IgnoreWhiteSpaces)) {byte[] data = new byte[BUFFER_SIZE];IBuffer buffer = data.AsBuffer();uint dataRead = BUFFER_SIZE;byte[] dataTransformed = new byte[BUFFER_SIZE];while (dataRead == BUFFER_SIZE) {await input.ReadAsync(buffer, BUFFER_SIZE, InputStreamOptions.Partial);int bytesWritten = myTransform.TransformBlock(data, 0,(int)BUFFER_SIZE, dataTransformed, 0);await Task.Delay(DELAYMILLISEC);imageFile.Write(dataTransformed, 0, bytesWritten);dataRead = buffer.Length;}dataTransformed = myTransform.TransformFinalBlock(data, 0, data.Length - (int)dataRead);imageFile.Write(dataTransformed, 0, dataTransformed.Length);myTransform.Clear();}imageFile.Flush();}}}
Must be set as TemporaryFolder to read files from HoloLens.


*return true;
すべてのウィンドウを列挙する


*[Range(0, 1)] public float HSV_Hue_min = 0.0f;
0 ~ 1

*void Start()*{material =  GetComponent<Renderer>().material;HSV_Hue = HSV_Hue_min;StartCoroutine("Change_Color");}
Start is called before the first frame update


*yield return new WaitUntil (() => Purchaser.Valid || Purchaser.Unavailable);
初期化完了を待つ


*string url = @"http:
d01tsumath.hatenablog.comrss";

*XElement element = XElement.Load(url);
RSS読み込み

*XElement channelElement = element.Element("channel");
channelの取得

*IEnumerable<XElement> elementItems = channelElement.Elements("item");
itemの取得


*listener.Prefixes.Add(@"http:
+:8080");

*listener.Start();
リスナー開始

*HttpListenerContext context = listener.GetContext();
リクエスト取得

*HttpListenerResponse response = context.Response;
レスポンス取得


*OpenWebCommand = new Command(() => Device.OpenUri(new Uri("https:
xamarin.complatform")));

*// by visiting https://aka.ms/xamarinforms-previewer*[DesignTimeVisible(false)]
Learn more about making custom code visible in the Xamarin.Forms previewer

*private void Button_Clicked(object sender, EventArgs e)*{// 自身にバインドされているViewModelを取得する。var viewModel = BindingContext as AboutViewModel;// AppNameを書き換える。viewModel.AppName = "ザマリンサンプルアプリケーション";}
☆ ボタンクリックイベントのハンドラ

*var viewModel = BindingContext as AboutViewModel;
自身にバインドされているViewModelを取得する。

*viewModel.AppName = "ザマリンサンプルアプリケーション";
AppNameを書き換える。


*gameObject.AddComponent<ResetTest>().Reset();
Reset()はpublicで定義


*var localDir = Windows.Storage.ApplicationData.Current.LocalFolder;
UWPアプリ

*Debug.WriteLine(ex.Message);
UWPアプリでない


*public SavedData SetData(int selected_id)
メソッド名　引数には主要キー、返り値にはクラス名

*cmd.Parameters.Add(new SqlParameter("@selected_id", selected_id));
コネクションからコマンドへ-SqlConnectionに関連付けられているSqlCommandオブジェクトを作成

*setdata.ID = demoid.ToString();
クラスプロパティ'ID'のデータ型がintの場合は、このように変換

*return setdata;
メソッドが呼び出されたインスタンス自身を返す


*public TEnum this [TObj o] { get { return (TEnum) Array.IndexOf (objects, o); } }
エラー

*,,,*public class EnumeratedArray<TEnum, TObj> where TEnum : Enum {private TObj [] objects;public TObj this [TEnum n] { get { return objects [Convert.ToInt32 (n)]; } }public TEnum this [TObj o] { get { return (TEnum) Enum.ToObject (typeof (TEnum), Array.IndexOf (objects, o)); } }}
この例は、やりたいことを端的に表現したもので、やりたいことそのものではありません。


*} else {
エラー時の処理


*yield return RunScenario();
シナリオの再生処理

*[UnityTest]
テストしたいコルーチンに必ず付ける必要がある

*[TestCase("file_0001", ExpectedResult = null)]
コルーチンに引数として値を渡すことができる（複数指定可）
この例だと、RunWithTestCase("file_0001")、RunWithTestCase("file_0002")として扱われる
【注意】 コルーチンに[TestCase]を使う場合、ExpectedResult = null を記述しないとエラーになる

*public static IEnumerable FILES*{get{foreach (var path in Directory.GetFiles("<path>")){//  【注意】 [TestCase]同様、Returns(null) を記述しないとエラーになるyield return new TestCaseData(path).Returns(null);}}}
[TestCaseSource]に渡すリスト

*yield return new TestCaseData(path).Returns(null);
【注意】 [TestCase]同様、Returns(null) を記述しないとエラーになる

*[TestCaseSource("FILES")]
[TestCase]をリストで管理できるようにしたもの（動的に定義したい場合などで有用）
各要素ごとを渡したテストとして扱われる
Directory.GetFilesから取得できる文字列がfile_0001、file_0002とすると、
RunWithTestCaseSource("file_0001")、RunWithTestCaseSource("file_0002")となる

*[Timeout(300000)]
テストのタイムアウト時間を指定する
デフォルトだと30秒
ms単位で指定（この例だと5分になる）

*[OneTimeSetUp]
クラス内で最初のテストが実行される前に一度だけ呼ばれる

*[SetUp]
各テストの最初に呼ばれる

*[TearDown]
各テストの最後に呼ばれる（テストが失敗しても呼ばれる）

*[OneTimeTearDown]
クラス内で最後のテストが実行された後に一度だけ呼ばれる

*[OneTimeSetUp]
クラス内で最初のテストが実行される前に一度だけ呼ばれる

*Application.targetFrameRate = 60;
テスト時間短縮のために高速化する

*yield return Press("target");
targetという名前のボタンを押す

*yield return LoadScene("Scenario");
Scenarioシーンをロードする

*yield return WaitFor(new ObjectAppeared("target"));
targetというオブジェクトが登場するまで待機する

*[OneTimeSetUp]
クラス内で最初のテストが実行される前に一度だけ呼ばれる

*Application.logMessageReceived += Log;
ログを残す

*_errorLogs.Clear();
各テストの頭でクリアする

*[TearDown]
各テストの最後に呼ばれる（テストが失敗しても呼ばれる）

*var engineAssembly = Assembly.Load("UnityEngine.TestRunner");
テスト情報を追加する

*var testNamesField = testFilterType.GetField("testNames");
テストの名前を使って実行する
実行するテスト名(メソッド名)は名前空間とクラス名も含めること

*var editorAssembly = Assembly.Load("UnityEditor.TestRunner");
Test Runnerを実行できるクラスを参照する

*var runMethod = listGUIField.FieldType.GetMethod("RunTests", BindingFlags.Instance | BindingFlags.NonPublic);*runMethod.Invoke(listGUI, new object[] { testFilter });
Test Runnerを実行する

*[OneTimeSetUp]
クラス内で最初のテストが実行される前に一度だけ呼ばれる

*Application.logMessageReceived += Log;
【注意】 この例では、Logメソッドを省略

*var assembly = Assembly.Load("UnityEngine.TestRunner");
Restartするため、テスト情報を保持しておく

*[TestCaseSource("FILES")]
【注意】 この例では、FILES変数の宣言は省略

*var assembly = Assembly.Load("UnityEngine.TestRunner");
【注意】 テスト情報の更新処理（今回は名前で更新しているが、カテゴリーなら別の処理が必要）

*testNames = testNames.Where(testName => !_runTestNames.Any(runTestName => testName.Contains(runTestName))).ToArray();
すでに実行しているテストは削除する

*EditorApplication.isPlaying = false;
Unityを止めて、Test Runnerを再び実行する

*private static void Restart(object testFilter)*{var assembly = Assembly.Load("UnityEditor.TestRunner");var runnerWindowType = assembly.GetType("UnityEditor.TestTools.TestRunner.TestRunnerWindow");var runnerWindow = runnerWindowType.GetField("s_Instance", BindingFlags.NonPublic | BindingFlags.Static).GetValue(null);var listGUIField = runnerWindowType.GetField("m_PlayModeTestListGUI", BindingFlags.Instance | BindingFlags.NonPublic);var listGUI = runnerWindow != null ? listGUIField.GetValue(runnerWindow) : Activator.CreateInstance(listGUIField.FieldType);var runMethod = listGUIField.FieldType.GetMethod("RunTests", BindingFlags.Instance | BindingFlags.NonPublic);runMethod.Invoke(listGUI, new object[] { testFilter });EditorApplication.update -= OnRestart;}
コード側からTest Runnerを実行する

*[OneTimeTearDown]
クラス内で最後のテストが実行された後に一度だけ呼ばれる

*EditorApplication.Exit(0);
エラー扱いにするため、1以上を返しても良い


*public class MyClass*{// privateメソッドprivate int AddValue(int additionValue){return _Value + additionValue;}// privateプロパティprivate bool IsZero => _Value == 0;// privateフィールドprivate int _Value = 0;// staticなprivateメソッドprivate static int GetTotalValue(int value1, int value2){return value1 + value2;}}
テスト対象のクラス

*private int AddValue(int additionValue)*{return _Value + additionValue;}
privateメソッド

*private bool IsZero => _Value == 0;
privateプロパティ

*private int _Value = 0;
privateフィールド

*private static int GetTotalValue(int value1, int value2)*{return value1 + value2;}
staticなprivateメソッド

*[TestClass]
MyClassのprivateなメンバーをテストするためのテストコード

*[TestMethod]
privateメソッドのテスト

*var myClass = new MyClass();
PrivateObjectを作成して、AddValueメソッドを呼び出す

*[TestMethod]
privateプロパティとprivateフィールドのテスト

*var myClass = new MyClass();
PrivateObjectを作成して、_ValueフィールドとIsZeroプロパティを呼び出す

*var value = (int) privateObject.GetField("_Value");
privateフィールドを取得

*var isZero = (bool) privateObject.GetProperty("IsZero");
privateプロパティを取得

*[TestMethod]
staticなprivateメソッドのテスト

*var privateType = new PrivateType(typeof(MyClass));
PrivateTypeを作成して、GetTotalValueメソッドを呼び出す

*public static int AddValue(this MyClass myClass, int additionValue)
MyClassの以下のメソッド用の拡張メソッドを定義
private int AddValue(int additionValue)

*public static class MyClassExtensions*{// privateメソッド用の拡張メソッドpublic static int AddValue(this MyClass myClass, int additionValue){return (int) new PrivateObject(myClass).Invoke("AddValue", additionValue);}// privateプロパティ用の拡張メソッドpublic static bool IsZero(this MyClass myClass){return (bool) new PrivateObject(myClass).GetProperty("IsZero");}// privateフィールド用の拡張メソッドpublic static int _Value(this MyClass myClass){return (int) new PrivateObject(myClass).GetField("_Value");}// staticなprivateメソッド用のstaticメソッドpublic static int GetTotalValue(int value1, int value2){return (int) new PrivateType(typeof(MyClass)).InvokeStatic("GetTotalValue", value1, value2);}}
拡張メソッドの定義(テストプロジェクト内で定義)

*public static int AddValue(this MyClass myClass, int additionValue)*{return (int) new PrivateObject(myClass).Invoke("AddValue", additionValue);}
privateメソッド用の拡張メソッド

*public static bool IsZero(this MyClass myClass)*{return (bool) new PrivateObject(myClass).GetProperty("IsZero");}
privateプロパティ用の拡張メソッド

*public static int _Value(this MyClass myClass)*{return (int) new PrivateObject(myClass).GetField("_Value");}
privateフィールド用の拡張メソッド

*public static int GetTotalValue(int value1, int value2)*{return (int) new PrivateType(typeof(MyClass)).InvokeStatic("GetTotalValue", value1, value2);}
staticなprivateメソッド用のstaticメソッド

*[TestClass]
テストコードは、PrivateObjectとPrivateTypeを用いずに、シンプルに記載

*[TestMethod]
privateメソッドのテスト

*[TestMethod]
privateプロパティとprivateフィールドのテスト

*var value = myClass._Value();
privateフィールドを取得

*var isZero = myClass.IsZero();
privateプロパティを取得

*[TestMethod]
staticなprivateメソッドのテスト


*InputTt.ChangeReceiver(this);
本来はレシーバーが直接ChangeReceiverするのではなく別途Managerなどの制御クラスで行うべき

*}
移動処理とか


*@using Radzen.Blazor
略
追加

*var dParam = new Dictionary<string, object>() { { "Message", "メッセージ" } };
ダイアログの表示

*resultText = result.ToString();
ダイアログが閉じたとの結果を取得

*Invoke(() => { StateHasChanged(); });
変更通知


*wwRegion
リージョン

*string hoge = await credentials.GetIdentityIdAsync();
↓おまじない

*}
ここでオブジェクトがとれている（略）


*if (devInfo == null) return;*if (devInfo.Pairing.IsPaired == false)
devInfoが、watcherで取得したデバイス情報。

*}
すでにペアリング済み

*}
すでにペアリング解除済み

*// If this is an App for 'Windows IoT Core' where there is no Windows Consent UX, you may want to provide your own confirmation.*args.Accept();
Windows itself will pop the confirmation dialog as part of "consent" if this is running on Desktop or Mobile

*await rootPage.Dispatcher.RunAsync(CoreDispatcherPriority.Normal, () =>*{ShowPairingPanel("Please enter this PIN on the device you are pairing with: " + args.Pin,args.PairingKind);});
No need for a deferral since we don't need any decision from the user

*// this Windows device. Get a deferral so we can perform the async request to the user.*var collectPinDeferral = args.GetDeferral();
A PIN may be shown on the target device and the user needs to enter the matching PIN on


*string cachePath = "file:
" + Application.temporaryCachePath + "tmp.wav";


*void Update()*{Vector3 accLeft = OVRInput.GetLocalControllerAcceleration(LeftCon) ;Vector3 accRight = OVRInput.GetLocalControllerAcceleration(RightCon);float walkSpeed = 10;float moveSpeed;moveSpeed = accLeft.y + accRight.y;if ( moveSpeed <= -walkSpeed||  moveSpeed >= walkSpeed ){var moveDirect = PlayerCamera.transform.rotation.eulerAngles.y;var moveQuate = Quaternion.Euler(0, moveDirect, 0);transform.position += (moveQuate * Vector3.forward).normalized * Time.deltaTime;}}
Update is called once per frame

*// Start is called before the first frame update*void Start()
Use this for initialization

*void Start()*{LeftCon = OVRInput.Controller.LTouch;RightCon = OVRInput.Controller.RTouch;rd = GetComponent<Rigidbody>();}
Start is called before the first frame update

*void Update()*{Vector3 accLeft = OVRInput.GetLocalControllerAcceleration(LeftCon) ;Vector3 accRight = OVRInput.GetLocalControllerAcceleration(RightCon);float walkSpeed = 10;float moveSpeed;moveSpeed = accLeft.y + accRight.y;if ( moveSpeed <= -walkSpeed||  moveSpeed >= walkSpeed ){var moveDirect = PlayerCamera.transform.rotation.eulerAngles.y;var moveQuate = Quaternion.Euler(0, moveDirect, 0);rd.AddForce((moveQuate * Vector3.forward).normalized);}}
Update is called once per frame


*TaskCompletionSource<string> tcs = new();
ここで TaskCreationOptions.RunContinuationsAsynchronously を指定するとデッドロックしない

*await Task.Delay(100);*result.SetResult($"OK ({item})");
Waiting a bit to emulate some IO-bound operation

*Util.Print($"Logging: {message}");
"Saving" message to the file

*Channel<string> tcs = Channel.CreateBounded<string>(1);
ここで new BoundedChannelOptions(1) { AllowSynchronousContinuations = true } を渡すとデッドロックするようになる

*await Task.Delay(100);*await result.WriteAsync($"OK {item}");
Waiting a bit to emulate some IO-bound operation

*Util.Print($"Logging: {message}");
"Saving" message to the file


*writer.WriteInt16(5);
設定値を作成(ここでは5秒)


*var rnd = new Random();
ランダムな数字を作成するやつ

*var path = "Title.txt";
Title.txtの読込みとその表示

*Console.WriteLine("1~10のどの桁に挑戦しますか");
桁数の入力

*var useNum = new bool[10];
正解の作成
数字が重なることはない

*bool isWrong = true;
正解をあてるループ

*Console.Write("{0,3} > ", time);
予想の入力

*var isCheck = true;
予想のstringをint[]に変換する

*var hit = 0;
hitとblowを数える

*Console.Write("      ");*Console.WriteLine("{0} hit", hit);
表示


*}
privateなメンバなためアクセスできない,プロパティもゲッターのみなので値のセットはできない.
component.hoge.Id = EditorGUILayout.IntField("ID", component.hoge.Id);

*{System.Type fieldType = component.hoge.GetType();FieldInfo fieldInfo = fieldType.GetField("id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);int tempId = (int)fieldInfo.GetValue(component.hoge);fieldInfo.SetValue(component.hoge, (int)EditorGUILayout.IntField("ID", tempId));}
Reflectionを利用してパラメータを操作.


*var rnd = new Random();
ランダムな数字を作成するやつ

*var path = "Title.txt";
Title.txtの読込みとその表示

*Console.WriteLine("何桁に挑戦しますか");
桁数の入力

*var correct = new int[dight];
正解の作成

*bool isWrong = true;
正解を当てるループ

*Console.Write("{0,3} > ", time);
予想の入力

*var isCheck = true;
予想のstringをint[]に変換する

*var a = Check(answer, correct, 0);
大小のチェック

*static int Check(int[] answer, int[] correct, int num)*{// 終点まで同じだったら0を返すif (num == correct.Length){return 0;}// 同じだったら次へif (answer[num] == correct[num]){return Check(answer, correct, num + 1);}// 大きいと1を返すelse if (answer[num] > correct[num]){return 1;}// 小さいと-1を返すelse{return -1;}}
再帰による大小のチェック

*else*{return -1;}
小さいと-1を返す


*using (var stream = new FileStream(@"C:\\secret.json", FileMode.Open, FileAccess.Read)){string credPath = "token.json";
ファイル名は先ほど取得した認証情報のjson

*var results = step.QueryStep(DateTime.Now.AddDays(-1), DateTime.Now);
1日前～現在までのデータを取得


*rewardBasedVideo.Show ();
リワード動画を表示


*using Microsoft.Extensions.DependencyInjection;
CreateScope


*public int X { get; set; }
まさかの一行！！

*,,,
「= 3」の部分が初期化子。
ここでは、初期値3を入れている

*,,,
コンストラクタか、初期化詞を遣えば、1度だけ設定できる。
以後値が変わることはない。


*var card = new HeroCard{Text = "よくある質問を以下に表示します。",Buttons = new List<CardAction>
Create a HeroCard with options for the user to interact with the bot.

*// In this code the emulator is accounted for with the 'title' parameter, but in other channels you may*// need to provide a value for other parameters like 'text' or 'displayText'.
Note that some channels require different values to be used in order to get buttons to display text.

*// need to provide a value for other parameters like 'text' or 'displayText'.*new CardAction(ActionTypes.ImBack, title: "1. Windows 10とは何ですか？", value: "Windows 10"),
In this code the emulator is accounted for with the 'title' parameter, but in other channels you may


*Workbook workbook = new Workbook();
エクセルファイルをロードします。

*sheet.Range["A1:E1"].Style.Color = Color.LightSeaGreen;
Excel Rangeで背景に色を設定します。

*workbook.SaveToFile("SetBackgroundColor.xlsx", ExcelVersion.Version2010);
保存します。

*Workbook workbook = new Workbook();
ファイルをロードします。

*Bitmap bm = new Bitmap(Image.FromFile("logo.png"));
画像を追加します。

*workbook.SaveToFile("SetBackgroundimage.xlsx", ExcelVersion.Version2010);
保存します。


*var res = req.GetResponse();
１．リクエスト送信

*using (var ms = new MemoryStream(Encoding.UTF8.GetBytes(reader.ReadToEnd()))){デシリアイズする型を指定します。var serializer = new DataContractJsonSerializer(typeof(IList<Person>));
２．UTF8 に変換し MemoryStream に格納します。

*var serializer = new DataContractJsonSerializer(typeof(IList<Person>));
デシリアイズする型を指定します。

*var persons = (IList<Person>)serializer.ReadObject(ms);
デシリアイズします。


*}
Cache.Clear(); 的なコード

*.UseMagicOnion(new[] { typeof(Program).Assembly },
ユーザー用

*.UseMagicOnion(new[] { typeof(AdminService) },
管理者用


*Task.Run(async () => await Electron.WindowManager.CreateWindowAsync());
☆ 起動時にElectronを使用するように、この行を追加


*public partial class LoadDialog : Form*{public Inventor.ApplicationAddInSite inventor;private AppDomain appDomain;private Proxy proxy;public LoadDialog(){InitializeComponent();//UpdateControlState();}public void UpdateControlState(){if (appDomain == null){LoadButton.Enabled = File.Exists(DllPathTextBox.Text);UnloadButton.Enabled = false;}else{LoadButton.Enabled = false;UnloadButton.Enabled = true;}}private void ShowErrorDialog(string message, Exception exception = null){if (exception != null){message += Environment.NewLine + exception.ToString();}MessageBox.Show(message, "AddIn Hot Loader", MessageBoxButtons.OK, MessageBoxIcon.Error);}public void UnloadAppDomain(){if (appDomain != null){if (proxy != null && proxy.Activated){try{proxy.Deactivate();}catch (Exception ex){ShowErrorDialog("Deactive()で例外が送出されました。", ex);}}try{AppDomain.Unload(appDomain);appDomain = null;proxy = null;}catch (Exception ex){ShowErrorDialog("AppDomainの解放に失敗しました。", ex);}}}private void LoadButton_Click(object sender, EventArgs e){bool isError = false;try{appDomain = AppDomain.CreateDomain("InventorAddInHotLoaderDomain");proxy = (Proxy)appDomain.CreateInstanceAndUnwrap(Assembly.GetExecutingAssembly().FullName, typeof(Proxy).FullName);}catch (Exception ex){ShowErrorDialog("Proxyの作成に失敗しました。", ex);isError = true;}if (!isError){try{proxy.Initialize(DllPathTextBox.Text, NameSpaceTextBox.Text, ClassNameTextBox.Text);}catch (Exception ex){ShowErrorDialog("Proxyの初期化に失敗しました。", ex);isError = true;}}if (!isError){try{proxy.Activate(inventor, true);}catch (Exception ex){ShowErrorDialog("Activate()で例外が送出されました。", ex);isError = true;}}if (isError){UnloadAppDomain();}UpdateControlState();}private void UnloadButton_Click(object sender, EventArgs e){UnloadAppDomain();UpdateControlState();}private void DllSelectButton_Click(object sender, EventArgs e){using (var fileDialog = new OpenFileDialog()){try{fileDialog.InitialDirectory = Path.GetDirectoryName(DllPathTextBox.Text);fileDialog.FileName = Path.GetFileName(DllPathTextBox.Text);}catch{var dirInfo = Directory.GetParent(System.Reflection.Assembly.GetExecutingAssembly().Location);try{dirInfo = dirInfo.Parent;}catch { }fileDialog.InitialDirectory = dirInfo.FullName;fileDialog.FileName = string.Empty;}fileDialog.Filter = "AddIn DLL Files (*.dll)|*.dll";fileDialog.Title = "AddInを選択";var result = fileDialog.ShowDialog();if (result == DialogResult.OK){DllPathTextBox.Text = fileDialog.FileName;}}}private void DllPathTextBox_TextChanged(object sender, EventArgs e){UpdateControlState();}}
以下のcodeは抜粋で、このままでは動作しません


*material.SetFloat("_OutlineSize", m_OutlineSize);
ここでパラメーター設定行う


*trans.Commit();
DB処理
コミット

*trans.Commit();
DB処理
コミット


*Workbook wb = new Workbook();
workbook objectを作成します。

*wb.Worksheets.Clear();
既定のシートを削除します。

*Worksheet sheet = wb.Worksheets.Add("職員名簿");
新規シートを追加し、それに名をつけます。

*sheet.Range["A1:G1"].Merge();
A1からG1までのセルを横方向に結合します。

*sheet.Range["A1"].Value = "パンダ会社職員個人情報リスト";
A1セルにデータを書き込み、文字の書式などを設定します。

*sheet.Rows[0].RowHeight = 30F;
初めの行の高さを設定します。

*DataTable dt = new DataTable();
创建一个DataTable

*sheet.InsertDataTable(dt, true, 2, 1, true);
DataTableのデータをシートに追加します。

*sheet.Range["A2:G7"].RowHeight = 15F;
このエリアの行の高さを設定します。

*sheet.Range["A2:G7"].Columns[2].ColumnWidth = 15F;
三つ目と五つ目の列の幅を設定しあｍす。

*sheet.Range["A2:G7"].BorderAround(LineStyleType.Medium);
グリッドのスタイルを設定します。

*wb.SaveToFile("Excel.xlsx", FileFormat.Version2013);
.xlsxで保存します。


*GameObject camera_G = new GameObject("OnlyUIRenderingCamera");
カメラ自動生成

*GameObject canvas_G = new GameObject("FaceCanvas");
キャンバス生成＆設定

*GameObject text_G = new GameObject("FpsText");
テキスト生成＆設定

*RectTransform textRect = text_G.GetComponent<RectTransform>();*textRect.sizeDelta = new Vector2(1000, 1000);
テキストのポジションを調整

*canvas_G.layer = LayerMask.NameToLayer("UI");
Layerを変更

*GameObject canvas_G = new GameObject("FaceCanvas");
キャンバス生成＆設定

*faceCanvas.renderMode = RenderMode.WorldSpace;
レンダリングをfaceCameraに

*this.gameObject.transform.parent = Camera.main.transform;*this.gameObject.transform.localPosition = Vector3.zero;
このゲームオブジェクトの親、ポジションを設定

*canvas_G.transform.parent = this.gameObject.transform;*canvas_G.transform.localPosition = new Vector3(0,0,0.3f);
キャンバスの親、ポジションを設定

*GameObject text_G = new GameObject("FpsText");
テキスト生成＆設定

*RectTransform textRect = text_G.GetComponent<RectTransform>();*textRect.sizeDelta = new Vector2(1000, 1000);
テキストのポジションを調整


*var editor = new TextEditor();
テキストエディタとスナップショットマネージャの作成

*editor.AppendText("A");
テキストの追記

*snapShotManager.SaveSnapShot("FirstSnapShot");
スナップショットの保存

*editor.AppendText("B");
さらにテキストを追加

*editor.PrintText();
表示

*editor.PrintText();
復元後の状態でテキストを表示


*var input_floats = GetFloatFromTex2DWithFlip (input);
Texture2Dをモデルの入力に合った形に整形、正規化する。

*var input_onnx_values = new List<NamedOnnxValue> {NamedOnnxValue.CreateFromTensor (input_nodes_name, input_tensor)};
OnnxRuntimeでの入力形式であるNamedOnnxValueを作成する

*var results = session.Run (input_onnx_values);
推論を実行

*Mat img = FixTexture2Input (input);
Texture2Dをモデルの入力に合った形に整形する

*Scalar mean = new Scalar (0.485f, 0.456f, 0.406f);
OpenCVSharpでの入力形式であるblobを作成、同時に正規化を行う。

*Mat scores = model.Forward ();
推論を実行

*var float_values = GetFloatFromTex2DWithFlip(input);
Texture2Dをモデルの入力に合った形に整形、正規化する。

*var shape = new TFShape(1, input.width, input.height, 3);
TensorFlowSharpでの入力形式であるTFTensorを作成する

*var runner = session.GetRunner();
データの入力・推論
input_2:0およびoutput_node0:0はpbファイル作成時につけた入力ノードと出力ノードの名前。

*var output = runner.Run();
推論を実行


*double background = RelativeLuminance(R, G, B);
背景色の相対輝度

*const double border = 0.17912878474779D;
黒文字と白文字の判定に使う相対輝度境界値

*return background >= border ? Color.Black : Color.White;
背景色の相対輝度が境界値以上なら黒文字、未満なら白文字


*public void ConfigureServices(IServiceCollection services)*{services.AddControllersWithViews();services.AddDistributedMemoryCache();services.AddSession(options =>{options.Cookie.Name = ".Session";});var mapperConfig = new MapperConfiguration(mc =>{mc.AddProfile(new UserProfile());});IMapper mapper = mapperConfig.CreateMapper();     /*    AutoMapperに関する処理はここだけ         */services.AddSingleton(mapper);services.AddMvc();}
This method gets called by the runtime. Use this method to add services to the container.


*Console.WriteLine($"c = {c}");
計算した値を使用する。

*}
数回繰り返す（省略）


*enum AudioType
Audioファイル種類定義.
TODO:ファイル出力時に使用したい.

*string[] files = (string[])e.Data.GetData(DataFormats.FileDrop, false);
複数のファイルは受け付けない.

*dropBox.Text = audioFilePath;
音楽ファイル以外はDragEnterで弾かれる.

*audioVolume = audioRate * trackBar1.Value;
trackBarにあわせて音量変更.

*textBox1.Text = resultValue.ToString();
入力された数値をtrackbarへ反映.

*textBox1.Text = trackBar1.Value.ToString();
数値が範囲を超えている.

*textBox1.Text = trackBar1.Value.ToString();
数値以外が入力された.

*MessageBox.Show("ファイルをドラッグアンドドロップしてください。\n");
ダイアログ表示.

*audioReader.Position = 0;
再生位置を戻す.

*MessageBox.Show("ファイル出力が完了しました。\n");
ダイアログ表示.

*MessageBox.Show("ファイルをドラッグアンドドロップしてください。\n");
ダイアログ表示.


*[SerializeField] private GameObject _object;
[SerializeField]を書くことで、シリアライズ可能なフィールドを宣言できる。

*}
publicなフィールドでも可。
public GameObject _object;

*GameObject obj = GameObject.FindWithTag("探したいオブジェクトに設定されたタグ");
指定したタグを持つGameObjectを 1つ 取得する。

*GameObject[] objs = GameObject.FindGameObjectsWithTag("探したいオブジェクトに設定されたタグ");
指定したタグを持つGameObjectを 全て 取得する。

*public class Sample : MonoBehaviour*{[SerializeField] private Example _object;// または// public Example _object;}
欲しいコンポーネントを仮に Example とする

*}
または
public Example _object;

*var cmp = this.gameObject.GetComponent</*欲しいコンポーネント*/>();
自身を持つGameObjectにアタッチされた、他のコンポーネントを取得する場合

*var cmp = GameObject.Find("CUBE").GetComponent</*欲しいコンポーネント*/>();
CUBE という名前のGameObjectから取得したい場合

*var cmp = FindObjectOfType</*欲しいコンポーネント*/>();
シーン内にある、指定したコンポーネントの1つを取得する

*var cmp = FindObjectsOfType</*欲しいコンポーネント*/>();
シーン内にある指定したコンポーネント全てを取得する


*List<ChannelOption> options = new List<ChannelOption> {new ChannelOption("grpc.keepalive_time_ms", 2000),new ChannelOption("grpc.keepalive_timeout_ms", 3000),new ChannelOption("grpc.http2.min_time_between_pings_ms", 5000),};
各種 keepalive 関連のオプションを設定する

*channel = new Channel(m_MagicOnionHost, 12345, ChannelCredentials.Insecure, options);
gRPC チャネル生成時の第3引数に IEnumerable でオプションを指定する

*List<ChannelOption> options = new List<ChannelOption> {new ChannelOption("grpc.keepalive_time_ms", 2000),new ChannelOption("grpc.keepalive_timeout_ms", 3000),new ChannelOption("grpc.http2.min_time_between_pings_ms", 5000),};
各種 keepalive 関連のオプションを設定する

*await MagicOnionHost.CreateDefaultBuilder()
`UseMagicOnion` 関数の第3引数に IEnumerable でオプションを指定する


*[MessagePackObject(true)]
シリアル化させるオブジェクトには、MessagePackObject属性を付ける。
引数をtrueにするとプロパティの名前がそのまま使用される。

*[IgnoreMember]*public string FullName { get { return FirstName + LastName; } }
シリアル化させたくない場合には、[IgnoreMember]を付ける。

*byte[] bytes = MessagePackSerializer.Serialize(myClass1);
MessagePack形式のバイト配列に変換

*MyClass myClass2 = MessagePackSerializer.Deserialize<MyClass>(bytes);
復元

*var json = MessagePackSerializer.ConvertToJson(bytes);
JSONにも変換できる

*[MessagePackObject(false)]
シリアル化させるオブジェクトには、MessagePackObject属性を付ける。
引数をfalseにすると[Key()]を各プロパティに付ける必要がある。

*[IgnoreMember]*public string FullName { get { return FirstName + LastName; } }
シリアル化させたくない場合には、[IgnoreMember]を付ける。

*[MessagePackObject(false)]
シリアル化させるオブジェクトには、MessagePackObject属性を付ける。
引数をfalseにすると[Key()]を各プロパティに付ける必要がある。

*[IgnoreMember]*public string FullName { get { return FirstName + LastName; } }
シリアル化させたくない場合には、[IgnoreMember]を付ける。

*Console.WriteLine(MessagePackSerializer.SerializeToJson(new Sample4 { Foo = 10, Bar = 20, Hoge = 1 }));
{"Hoge":1,"Foo":10}


*}
持っている

*}
持っている


*ReaderWriterLockSlim rwlock = new ReaderWriterLockSlim();
データ読み書き排他用

*rwlock.Dispose();
しっかり破棄する

*rwlock.EnterReadLock();
読み込みロック取得

*if(rwlock.IsReadLockHeld)*rwlock.ExitReadLock();
読み込みロック解放

*_rwlock.EnterWriteLock();
書き込みロック取得

*listData = new List<int>{ 0, 1, 2 };
データを取得するような処理

*if(_rwlock.IsWriteLockHeld)*_rwlock.ExitWriteLock();
書き込みロック解放


*return "https:
drive.google.comuc?id=" + url;


*xmlns:x="http:
schemas.microsoft.comwinfx2006xaml"


*calendar.BlackoutDates.AddDatesInPast();
過去を選択不可能にする

*calendar.BlackoutDates.Add(new DateTime(2019, 8, 1), new DateTime(2019, 8, 31));
2019年8月1日～8月31日を選択不可能にする

*calendar.BlackoutDates.Add(new DateTime(2019, 9, 1));
2019年9月1日を選択不可能にする

*calendar.SelectedDate = inputRange.End;
選択不可範囲を指定しているとエラーになるので補正
(範囲終端を超えているので終端の日付に補正)

*calendar.SelectedDate = inputRange.Start;
選択不可範囲を指定しているとエラーになるので補正
(範囲先端をより過去なので先端の日付に補正)

*calendar.BlackoutDates.Add(inputRange);
2019年8月1日～8月31日を選択不可能にする


*filteredKeywords = Environment.GetEnvironmentVariable("TwKeywords");
Check whether local.settings.json is UTF8 or not

*stream.MatchingTweetReceived += (sender, args) =>*{var lang = args.Tweet.Language;//***** Specify Japanese & Remove Botif (lang == Tweetinvi.Models.Language.Japanese && args.Tweet.Source.Contains(">Twitter ")){log.LogInformation("----------------------------------------------------------------------");log.LogInformation($"** CreatedAt : {args.Tweet.CreatedAt}");log.LogInformation($"** CreatedBy : {args.Tweet.CreatedBy}");log.LogInformation($"** Source    : {args.Tweet.Source}");log.LogInformation($"** Text      : {args.Tweet.Text}");tweets.CreatedAt.Add(args.Tweet.CreatedAt);tweets.CreatedBy.Add(args.Tweet.CreatedBy.ToString());var source = args.Tweet.Source;var position = source.IndexOf(">");source = source.Substring(position + 1);position = source.IndexOf("<");source = source.Substring(0, position);tweets.Source.Add(source);tweets.Text.Add(args.Tweet.Text);}lock (countLock){++counter;}if (counter >= maxCount || (DateTime.UtcNow - startDt) >= maxTimeSpan){stream.Stop();completed = true;}else if ((counter - prevCounter) >= commitInterval){stream.Stop();}};
Read stream

*await CreateParquetFile(tweets);*log.LogInformation($"***** Tweet Data stored to Blob : {DateTime.UtcNow}");
Write tweet data to blob storage

*var createdAtColumn = new Parquet.Data.DataColumn(new DataField<DateTimeOffset>("CreatedAt"),
create data columns with schema metadata and the data

*using (ParquetRowGroupWriter groupWriter = parquetWriter.CreateRowGroup()){groupWriter.WriteColumn(createdAtColumn);
create a new row group in the file


*searcher.Start();
検索開始

*searcher.Finished -= finish;
イベントハンドラ破棄


*using UnityEngine.UI;
これがないとTextUIが使えないので必ず入力する。

*[SerializeField] Text Cal;
テキスト2つ分のSerializeFieldを用意

*public enum Tas*{ADD,SUB,MUL,DIV,}
列挙定数を生成。

*void Start () {//四則演算計算用の数字を設定。int a = 100;int b = 50;//Inspectorで選んだものがどれかで四則演算の種類が決定。if(Cul == Tas.ADD){Cal.text = (a + b).ToString();}else if (Cul == Tas.SUB){Cal.text = (a - b).ToString();}else if (Cul == Tas.MUL){Cal.text = (a * b).ToString();}else{Cal.text = (a / b).ToString();}//列挙定数をテキスト表示に。Str.text = Cul.ToString();}
Use this for initialization

*int a = 100;
四則演算計算用の数字を設定。

*Str.text = Cul.ToString();
列挙定数をテキスト表示に。


*firstFrameNum++;
最後の画像を超えたら　最初に戻る

*Sprite tex = Resources.Load<Sprite>(folderName + "/" + headText + _fixedFirstFrameNum);
画像変更


*<# }
End foreach #>

*var typeDef = new Dictionary<string, string>()*{{ "integer", "int" },{ "varchar", "string" },{ "date", "DateTime" },};
DBの型⇒C#の型変換表 DBMSごとに1つ用意すればよい

*var table = new TableInfo(){Name = "shain_master",Description = "社員マスタ",Columns = new[]{new ColumnInfo() { Name = "shain_id", Type = "integer", IsPrimary = true, NotNull = true },new ColumnInfo() { Name = "shain_name", Type = "varchar", NotNull = true },new ColumnInfo() { Name = "address", Type = "varchar", Description = "住所" },new ColumnInfo() { Name = "created_date", Type = "date" },}};
テーブル情報 実際はDBなどから取得するものとする

*// インターフェースなので、override指定しなくてもTextTemplate側のTransformTextが呼ばれる*ITemplate template = new TextTemplate(typeDef, "MyNameSpace", table);
具象型で受けるとCS1061エラーが発生するため、インターフェースで受ける

*ITemplate template = new TextTemplate(typeDef, "MyNameSpace", table);
インターフェースなので、override指定しなくてもTextTemplate側のTransformTextが呼ばれる

*Console.WriteLine(template.TransformText());*}
実際はファイル ストリームに書き出す


*else*{this._text = (string)stream.ReceiveNext();}
オーナー以外の場合


*PhotonNetwork.PrefabPool = this;
Poolの生成イベントを書き換える

*PhotonNetwork.Instantiate("BigAsteroid", Vector3.zero, Quaternion.identity, 0);
文字列で指定

*PhotonNetwork.Instantiate(prefab.name, Vector3.zero, Quaternion.identity, 0);
Prefabの名前で指定


*SendMessage(imwd, WM_IME_CONTROL, (IntPtr)IMC_SETCONVERSIONMODE, (IntPtr)CMode_Hiragana);
ひらがなモードに設定


*private void Form1_Paint(object sender, PaintEventArgs e)*{// グラフィックオブジェクトの作成Graphics g = this.CreateGraphics();// Penを作成Pen grayPen = new Pen(Color.Gray, 2);// lineの始点と終点を設定Point start_point = new Point(25, 250);Point end_point = new Point(480, 250);// lineを描画g.DrawLine(grayPen, start_point, end_point);// Penを解放するgrayPen.Dispose();// Graphicsを解放するg.Dispose();}
画面中央に引く横線を作成するメソッド

*Graphics g = this.CreateGraphics();
グラフィックオブジェクトの作成

*Pen grayPen = new Pen(Color.Gray, 2);
Penを作成

*Point start_point = new Point(25, 250);
lineの始点と終点を設定

*g.DrawLine(grayPen, start_point, end_point);
lineを描画

*grayPen.Dispose();
Penを解放する

*g.Dispose();
Graphicsを解放する

*private void Buy_btn_Click(object sender, EventArgs e)*{try{Property p = new Property();// ロット数p.Lot = int.Parse(lot_text.Text);// 通貨数p.Tsuka = int.Parse(tsuka_combo.Text);// 0%座標p.Zero = double.Parse(zero_text.Text);// 100%座標p.Hundred = double.Parse(hundred_text.Text);// エントリーポイントp.Entry = entry_combo.Text;// 結果を入れるリストList<string> sList = new List<string>();Calc c = new Calc();sList = c.CalcAskResult(p.Lot, p.Tsuka, p.Zero, p.Hundred, p.Entry);// 結果を表示lost_num.Text = sList[0];win_num.Text = sList[1];loss_amount.Text = "-" + sList[2] + " 円";profit_amount.Text = sList[3] + " 円";} catch{SetHook(this);MessageBox.Show("値を正しく入力してください","エラー",MessageBoxButtons.OK,MessageBoxIcon.Error);lost_num.Text = null;win_num.Text = null;loss_amount.Text = null;profit_amount.Text = null;}}
買ボタン押下時

*p.Lot = int.Parse(lot_text.Text);
ロット数

*p.Tsuka = int.Parse(tsuka_combo.Text);
通貨数

*p.Zero = double.Parse(zero_text.Text);
0%座標

*p.Hundred = double.Parse(hundred_text.Text);
100%座標

*p.Entry = entry_combo.Text;
エントリーポイント

*List<string> sList = new List<string>();
結果を入れるリスト

*lost_num.Text = sList[0];
結果を表示

*public int Lot { get; set; }
自動実装プロパティ

*public List<string> CalcAskResult(int lot, int tsuka, double low, double high, string entry)*{List<string> sList = new List<string>();ListMake lm = new ListMake();// 0%と100%の大小が逆の場合、空のリストを返すif (high <= low){return sList;}double lose_line;double win_line;double loss;double profit;double entry_point;// 取引金額を計算int amount = lot * tsuka;if (entry == "100%"){// 損切ラインを計算lose_line = Math.Round((low + (high - low) * 0.764) * 1000) / 1000;// 利確ラインを計算win_line = Math.Round((low + (high - low) * 1.618) * 1000) / 1000;// 損失を計算loss = Math.Round(amount * (high - lose_line));// 利益を計算profit = Math.Round(amount * (win_line - high));// ListAddsList = lm.ListAdd(lose_line.ToString(), win_line.ToString(), loss.ToString(), profit.ToString());}else if (entry == "161.8%"){// エントリーポイントを計算entry_point = Math.Round((low + (high - low) * 1.618) * 1000) / 1000;// 損切ラインは100%ラインなので、high// 利確ラインを計算win_line = Math.Round((low + (high - low) * 2.618) * 1000) / 1000;// 損失を計算loss = Math.Round(amount * (entry_point - high));// 利益を計算profit = Math.Round(amount * (win_line - entry_point));// ListAddsList = lm.ListAdd(high.ToString(), win_line.ToString(), loss.ToString(), profit.ToString());}else if (entry == "261.8%"){// エントリーポイントを計算entry_point = Math.Round((low + (high - low) * 2.618) * 1000) / 1000;// 損切ラインを計算lose_line = Math.Round((low + (high - low) * 1.618) * 1000) / 1000;// 利確ラインを計算win_line = Math.Round((low + (high - low) * 4.236) * 1000) / 1000;// 損失を計算loss = Math.Round(amount * (entry_point - lose_line));// 利益を計算profit = Math.Round(amount * (win_line - entry_point));// ListAddsList = lm.ListAdd(lose_line.ToString(), win_line.ToString(), loss.ToString(), profit.ToString());}return sList;}
損切ライン・利確ライン・損失・利益を計算(買いポジションなので0%をlow、100%をhighとする)

*int amount = lot * tsuka;
取引金額を計算

*lose_line = Math.Round((low + (high - low) * 0.764) * 1000) / 1000;
損切ラインを計算

*win_line = Math.Round((low + (high - low) * 1.618) * 1000) / 1000;
利確ラインを計算

*loss = Math.Round(amount * (high - lose_line));
損失を計算

*profit = Math.Round(amount * (win_line - high));
利益を計算

*entry_point = Math.Round((low + (high - low) * 1.618) * 1000) / 1000;
エントリーポイントを計算

*win_line = Math.Round((low + (high - low) * 2.618) * 1000) / 1000;
損切ラインは100%ラインなので、high
利確ラインを計算

*loss = Math.Round(amount * (entry_point - high));
損失を計算

*profit = Math.Round(amount * (win_line - entry_point));
利益を計算

*entry_point = Math.Round((low + (high - low) * 2.618) * 1000) / 1000;
エントリーポイントを計算

*lose_line = Math.Round((low + (high - low) * 1.618) * 1000) / 1000;
損切ラインを計算

*win_line = Math.Round((low + (high - low) * 4.236) * 1000) / 1000;
利確ラインを計算

*loss = Math.Round(amount * (entry_point - lose_line));
損失を計算

*profit = Math.Round(amount * (win_line - entry_point));
利益を計算


*public Task<T> FooAsync() => Task.Run(() => Foo);
必要？


*void Start()*{PlayCards();}
Start is called before the first frame update

*void Update()*{}
Update is called once per frame


*var asm = Assembly.GetAssembly(typeof(Hoge));
Hoge は Sample.csproj で public なクラス
テスト対象の Assembly を取得する方法はいくつかあるがライブラリのテストであれば
プロジェクトの参照を持っているだろうし public なクラスもあるはずなので GetAssembly で取得するのが楽

*// そして具体的に Generics のパラメータにどのような型を指定するかは*// 型の最後に[[{型の名前1}],[{型の名前2}],...,[{型の名前n}]]のように指定する
Generics の場合はパラメータとして与えられた型の個数を「`」の後に指定する

*// 型の最後に[[{型の名前1}],[{型の名前2}],...,[{型の名前n}]]のように指定する
そして具体的に Generics のパラメータにどのような型を指定するかは

*var type = asm.GetType("Sample.Foo`2[[Sample.Tests.Bar, Sample.Tests],[Sample.Tests.Bar, Sample.Tests]]");
型の最後に[[{型の名前1}],[{型の名前2}],...,[{型の名前n}]]のように指定する

*var instance = Activator.CreateInstance(type);
取得した type を使用して CreateInstance でインスタンスを作成する

*var type = asm.GetType("Sample.Qux`1+Foo`2[[Sample.Tests.Quux, Sample.Tests],[Sample.Tests.Bar, Sample.Tests],[Sample.Tests.Baz, Sample.Tests]]");
Nested Type の場合 Declaring Type の後に「+」を付けてそのあとに名前を指定します
Generics の具体的な型の指定は Declaring Type も Nested Type もまとめて配列で指定します


*for(var i=0;i<100;i++)
1から列挙しないといけないのに、0から列挙してしまってる。

*}
Fizz Buzzの実装

*}
Fizz Buzzの実装


*var retval = 0;
これは戻り値という情報しか入っていない

*var valueCount = 0;
この変数はなにをカウントしているのかが変数名のみで判断できる


*string[] dirs = Directory.GetDirectories(TRAIN_PATH + "/img", "*", SearchOption.TopDirectoryOnly);
画像が置かれているディレクトリ名をクラス名としている
ディレクトリ配下の画像に、分類しておいた学習データが格納されている

*string[] files = Directory.GetFiles(dirPath, "*", SearchOption.TopDirectoryOnly);
ディレクトリ配下の画像ファイルを学習用のリストに入れていく

*var classification = Path.GetFileName(dirPath);*this.labelList.Add(classDict[classification]);
一緒にクラス名をラベル番号としてclassLabelNoListに設定する

*this.bovw.Learn(trainImgList.ToArray());
Bag of Visual-wordsで画像パターンでベクトル化

*this.vectorList = new List<double[]>();
各画像のベクトルをリストに設定する（学習時に使用する）

*Serializer.Save(this.bovw, BOVW_MODEL_PATH);
BOVWのデータを学習済みデータとして保存

*var smo = new MulticlassSupportVectorLearning<ChiSquare>()*{// 逐次最小問題最適化法というのを用いて2次計画問題に対応する（理解薄い。。）Learner = (param) => new SequentialMinimalOptimization<ChiSquare>(){UseComplexityHeuristic = true,UseKernelEstimation = true}};
一対一多の学習アルゴリズム

*Learner = (param) => new SequentialMinimalOptimization<ChiSquare>()*{UseComplexityHeuristic = true,UseKernelEstimation = true}
逐次最小問題最適化法というのを用いて2次計画問題に対応する（理解薄い。。）

*var inputs = this.vectorList.ToArray();
学習データ

*this.msvm = smo.Learn(inputs, outputs);
学習する

*var calibration = new MulticlassSupportVectorLearning<ChiSquare>()*{// キャリブレーションで使用するアルゴリズムを設定Model = this.msvm, Learner = (param) => new ProbabilisticOutputCalibration<ChiSquare>(){Model = param.Model}};
キャリブレーション

*Model = this.msvm, Learner = (param) => new ProbabilisticOutputCalibration<ChiSquare>()*{Model = param.Model}
キャリブレーションで使用するアルゴリズムを設定


*#pragma warning restore CS0219
変数は割り当てられていますが、その値は使用されていません


*var media = VlcControl.SourceProvider.MediaPlayer;
操作したいコントロールね

*}));
ここでtime/durationを表示するなど


*//{SensorData.text = UpdateText(Input.acceleration, Input.compass, Input.gyro.attitude);nowTime = 0f;//}
if (nowTime > updateSpan && LoggerButton.UpdateFlag)

*public class moveObject : MonoBehaviour*{public GameObject model;public GameObject head;static List<Vector3> listGyro = new List<Vector3>();static List<Vector3> listAcceleration = new List<Vector3>();bool flg = false;float angle;static int currentPOV = 0;static List<string> strPOVkey = new List<string> { "TPS", "FPS", "nulmodel" };Dictionary<string, Vector3> dicPOV = new Dictionary<string, Vector3>(){{"TPS",new Vector3(0f,0f,0f)},{"FPS",new Vector3(0f,-2f,-64f)},{"nulmodel",new Vector3(0f,0f,-350f)}};// Start is called before the first frame updatevoid Start(){//model = GameObject.Find("Model");//head = GameObject.Find("Head");model.transform.localPosition = dicPOV[strPOVkey[currentPOV]];listAcceleration.Add(model.transform.position);listGyro.Add(model.transform.rotation.eulerAngles);}[System.Obsolete]void Update(){if (strPOVkey[currentPOV] != "FPS"){model.transform.localPosition =Vector3.Lerp(listAcceleration.Last(),SetPosition(getSensor.Acceleration) + dicPOV[strPOVkey[currentPOV]],0.5f);model.transform.Rotate(SetRotate(getSensor.Gyro));head.transform.localEulerAngles = new Vector3(0f, 0f, model.transform.localEulerAngles.z);}listAcceleration.Add(model.transform.position);listGyro.Add(model.transform.rotation.eulerAngles);}public void OnResetObjectClick(){model.transform.localPosition = dicPOV[strPOVkey[currentPOV]];do{model.transform.Rotate(listGyro[0] - model.transform.rotation.eulerAngles);}while (model.transform.eulerAngles != new Vector3(0f, 0f, 0f));}private Vector3 SetPosition(Vector3 vec){return new Vector3(vec.x, vec.y, vec.z) * 5f;}private Vector3 SetRotate(Vector3 vec){//ピッチ角は０度で固定//ヨー角は端末の動きに追従return new Vector3(0f,//Mathf.Clamp(-vec.x, -30f, 30f),Mathf.Clamp(-vec.y * listGyro[0].y, -30f, 30f),Mathf.Clamp(vec.z, -30f, 30f)) / 5;//0f,////Mathf.Clamp(-vec.x, -30f, 30f),//Mathf.Clamp(vec.z * listGyro[0].z, -30f, 30f),//Mathf.Clamp(-vec.y, -30f, 30f)) / 5;}//視線（頭）の向きprivate Vector3 HeadOrientation(Vector3 vec){//ピッチ,ロール軸の調整float limOri = 45f;float threshold = 20f;Debug.Log(vec.z);if (vec.z > threshold){return new Vector3(0f,Mathf.Clamp(Mathf.Abs(vec.z), -limOri, limOri),0f);}if (vec.z < -threshold){return new Vector3(0f,Mathf.Clamp(-Mathf.Abs(vec.z), -limOri, limOri),0f);}return new Vector3(0f, 0f, 0f);}//バイクのロール角に応じて体や膝の角度の調整private Vector3 LeanIn(Vector3 vec){return new Vector3(0f, 0f, 0f);}public void ChangePOV(){if (currentPOV < strPOVkey.Count - 1)currentPOV++;elsecurrentPOV = 0;OnResetObjectClick();}}
using System.Numerics;

*void Start()*{//model = GameObject.Find("Model");//head = GameObject.Find("Head");model.transform.localPosition = dicPOV[strPOVkey[currentPOV]];listAcceleration.Add(model.transform.position);listGyro.Add(model.transform.rotation.eulerAngles);}
Start is called before the first frame update

*model.transform.localPosition = dicPOV[strPOVkey[currentPOV]];*listAcceleration.Add(model.transform.position);
head = GameObject.Find("Head");

*return new Vector3(
ピッチ角は０度で固定
ヨー角は端末の動きに追従

*private Vector3 HeadOrientation(Vector3 vec)*{//ピッチ,ロール軸の調整float limOri = 45f;float threshold = 20f;Debug.Log(vec.z);if (vec.z > threshold){return new Vector3(0f,Mathf.Clamp(Mathf.Abs(vec.z), -limOri, limOri),0f);}if (vec.z < -threshold){return new Vector3(0f,Mathf.Clamp(-Mathf.Abs(vec.z), -limOri, limOri),0f);}return new Vector3(0f, 0f, 0f);}
視線（頭）の向き

*float limOri = 45f;
ピッチ,ロール軸の調整

*private Vector3 LeanIn(Vector3 vec)*{return new Vector3(0f, 0f, 0f);}
バイクのロール角に応じて体や膝の角度の調整


*processor.Append(Instruction.Create(OpCodes.Ldarg_0));
base呼び出し


*B = "XXX"
実際は何かのデータを取得 ...


*co++;
coは一度だけ選択を合わせるために使用している、これがないとUpdateなので、常に選択され続ける。


*[DllImport("Dll1.dll", CallingConvention = CallingConvention.Cdecl)]public extern static int UnmanagedAdd(int a, int b);
★ここで、「Dll1＿Win32.dll」「Dll1_x64.dll」とか分けずにDll1を使える！！


*[WithConstructor]
placeholder syntax, up for debate


*midiOutShortMsg(this.hMidi, 0x19c0);
音色を定義 アコースティックギター（スチール弦）0x19(25)

*List<byte> Chord = new List<byte>() { 0x31,0x36,0x3A };
C#

*private byte[] JoinByteArray(params byte[][] arrays)*{List<byte> ret = new List<byte>();foreach (byte[] array in arrays){foreach (byte arr_m in array){ret.Add(arr_m);}}return ret.ToArray();}
複数のbyte配列を結合して一つのbyte配列にまとめる

*StartInfo = new ProcessStartInfo()
pythonExe -> Python.exeのフルパス
pythonScript -> midiChordAnalysis.pyの相対パス
midiFile -> 作成したmidiファイルの相対パス


*textWords[i, n] = tempWords[n];
2次配列textWordsにカンマごとに分けたtempWordsを代入していく

*public void UpdateItem(int count)*{Start();n = 0;//アイテムナンバー、0から始まるので+1をして1から表記uiText.text = (count + 1).ToString("00");//テキストの行数を超えないように制限、テキストをカウントに併せて変更。if(count < rowLength){MaineText.text = (textWords[count, 0]);}}
プレハブ化された表示形式に以下の処理で文字と画像を順番に割り当てていく

*uiText.text = (count + 1).ToString("00");
アイテムナンバー、0から始まるので+1をして1から表記


*_mainModule.loop = false;
Durationの変更はParticleSystemのプレイ中には不可のようです
_mainModule.duration = _durationTimeValue;
Loopのオンオフ

*_minMaxCurve = _startLifeTimeValue;*_mainModule.startLifetime = _minMaxCurve;
StartLifeTimeの値の変更(Constantの場合)

*ParticleSystemCurveMode particleSystemCurveMode = ParticleSystemCurveMode.Curve;
StartLifeTimeのモードの変更(Constant→Curve)

*_minMaxCurve.curve = _animationCurve;
StartLifeTimeの値の変更(Curveの場合)

*_mainModule.startColor = Color.red;
2020/08/18 追記
StartColorの変更

*_MinMaxCurve.constant -= deleteSpeed;
だんだんと消滅させる

*void OnParticleCollision(GameObject other)*{_ParticleSystem.GetCollisionEvents(other, particleCollisionEventList);Vector3 collisionHitPos = particleCollisionEventList[0].intersection;Instantiate(obj,collisionHitPos,Quaternion.identity);}
パーティクルの当たった箇所でオブジェクト出現


*const double black = 0.0D;
黒の相対輝度

*return whiteContrast < blackContrast ? Color.Black : Color.White;
文字色と背景色のコントラスト比を計算
double whiteContrast = RelativeLuminanceRatio(white, background);    文字色：白との比
double blackContrast = RelativeLuminanceRatio(black, background);    文字色：黒との比
コントラスト比が大きい文字色を採用

*Color textColor = chooseTextColor(125, 40, 80);
textColor = Color.White が選ばれる

*Color textColor = chooseTextColor(200, 160, 180);
textColor = Color.Black が選ばれる

*Func<byte, double> toRgb = (rgb) => {double srgb = (double)rgb / 255;return srgb <= 0.03928 ? srgb / 12.92 : Math.Pow((srgb + 0.055) / 1.055, 2.4);};
RGB の各値を相対輝度算出用に変換

*private static double toRgb(byte rgb)*{double srgb = (double)rgb / 255;return srgb <= 0.03928 ? srgb / 12.92 : Math.Pow((srgb + 0.055) / 1.055, 2.4);}
RGB の各値を相対輝度算出用に変換

*public static double RelativeLuminance(byte R, byte G, byte B)*{return 0.2126 * toRgb(R) + 0.7152 * toRgb(G) + 0.0722 * toRgb(B);}
RGB から相対輝度を算出（0.0 ～ 1.0）


*embed.AddField("Googleリンク", "[こちら](https:
www.google.com) をクリック。");

*await message.Channel.SendMessageAsync("テスト", embed: embed.Build());
作成したEmbedをbotに送信させる。


*var kantoh=new Dictionary<string,string>{{"茨城県","水戸市"},{"栃木県","宇都宮市"},{"群馬県","前橋市"},{"埼玉県","さいたま市"},{"神奈川県","横浜市"}};
初期化

*kantoh["千葉県"]="千葉市";
代入

*Console.WriteLine(kantoh.ContainsKey("千葉県"));
要素の有無

*kantoh.Add("東京都","新宿区");
追加

*try{kantoh.Add("東京都","新宿区");}
要素が登録済みの場合、ArgumentException

*Console.WriteLine(kantoh["千葉県"]);
取得

*kantoh["千葉県"]+="中央区";
代入演算子も使用可

*Console.WriteLine(kantoh.Count);
要素数

*kantoh.Remove("千葉県");
要素の削除

*Console.WriteLine(string.Join(",",kantoh.Keys));
キーの配列

*Console.WriteLine(string.Join(",",kantoh.Keys));
値の配列

*kantoh.Clear();
要素のクリア


*account.Validate();
追加


*var ram = new Random();
置換処理の通知を受けたSampleViewModelsクラスの処理

*((INotifyPropertyChanged)this._models).PropertyChanged += this.SampleViewModels_PropertyChanged;*,,,
SampleViewModelsのコンストラクタ内の処理


*public GameObject Player;
追従先

*public float RotateSpeed = 0.1f;
視点回転スピード

*private Vector3 OffsetVector;
追従先との距離ベクトル

*private Transform PlayerTransform;*void Start()
追従先のTransform

*OffsetVector = transform.position - Player.transform.position;
一番最初に一回だけ呼ばれる。
追従先との距離を覚える。

*PlayerTransform = Player.GetComponent<Transform>();*}
追従先のTransformを取る。(カメラが向いた方向に追従先も回転させるため)

*transform.position = Player.transform.position + OffsetVector;*// マウスの回転を感知して回転ベクトル化
追従先との距離を保つ

*Vector3 angle = new Vector3(Input.GetAxis("Mouse X") * 1.0f,
マウスの回転を感知して回転ベクトル化

*transform.eulerAngles += new Vector3(angle.y, angle.x);*// 追従先も加算して回転させる。
回転ベクトルをカメラのもとのベクトルに加算

*PlayerTransform.transform.eulerAngles += new Vector3(0, angle.x, 0);*}
追従先も加算して回転させる。

*public GameObject Player;
自分のオブジェクト

*public float MoveSpeedX = 20.0f;
X軸への移動スピード

*public float MoveSpeedZ = 20.0f;
Z軸への移動スピード

*private float MoveSpeedY = 10f;
ジャンプの高さ

*rb = Player.GetComponent<Rigidbody>();
プレイヤーオブジェクトの物理演算数を取得。

*void FixedUpdate() {// wを押したときif (Input.GetKey(KeyCode.W)){rb.AddForce(Mathf.Cos(transform.localEulerAngles.y * Mathf.Deg2Rad) * MoveSpeedX, 0, -Mathf.Sin(transform.localEulerAngles.y * Mathf.Deg2Rad) * MoveSpeedX);}// sを押したときif (Input.GetKey(KeyCode.S)){Plarb.AddForce(-Mathf.Cos(transform.localEulerAngles.y * Mathf.Deg2Rad) * MoveSpeedX, 0, Mathf.Sin(transform.localEulerAngles.y * Mathf.Deg2Rad) * MoveSpeedX);}// スペースを押したときif (Input.GetKeyDown(KeyCode.Space)){Vector3 go = new Vector3(0, MoveSpeedY, 0);rb.velocity = go;}}
毎フレームごとに実行される。


*decode_table[i] = (char)0xFF;
-1 encoding_tableにありえない値

*ulong merge = 0;
40bitに統合

*merge |= ( (ulong)bytes[i+j] << (BYTE_LENGTH * (DIGIT-j-1)) );
4-j ビットシフトが必要

*byte b;
5bit 毎に分割

*int lastWordLen = builder.Length % PADDING_UNIT;
4文字ずつ分割して不足分は = で埋める

*Debug.LogError( "not base32" );
Base32じゃないよ！

*merge |= (ulong)( index << ( (BYTE_LENGTH-j-1) * DIGIT) );
1文字5bit なので5n bit シフトを行う


*=========================[SerializeField] SetActiveObject[] m_setactiveObjects = null;
SerializeField.

*=========================[System.Serializable]class SetActiveObject{public GameObject m_gameObject;
Public.

*=========================public void OnClick(){if (m_setactiveObjects.Length > 0)
Public Method.

*public void OnClick()*{if (m_setactiveObjects.Length > 0){foreach(var setactiveObject in m_setactiveObjects){setactiveObject.m_gameObject.SetActive(setactiveObject.m_enabled);}}else{Debug.LogError("m_setactiveObjects is empty!");}}
=========================


*var messenger = new Messenger(weatherService);
呼び出す時に機能を注入


*connection.Open();
データベースの接続開始

*command.CommandText = "SELECT * FROM [tableName] " ;
SELECT文を設定します。

*var adapter = new SqlDataAdapter(command);
SQLの実行

*connection.Close();
データベースの接続終了


*・・・
普通にiTmpを使える。


*const float outRangeAlpha = 0.5f;
範囲外のアルファ値

*var iconPos = new Vector3(iconTarget.position.x, defaultPosY, iconTarget.position.z);
アイコンを表示する座標

*spriteRenderer.color = new Color(spriteRenderer.color.r, spriteRenderer.color.g, spriteRenderer.color.b, outRangeAlpha);
マップ範囲外の場合、ミニマップ端までのベクトルを求めて半透明で表示する

*cameraPos.y = targetPos.y = 0;
直線距離で判定するため、yは0扱いにする


*namespace DesignPatternLearn.FactoryMethodLearn.FrameWork*{public abstract class Product{public abstract void Use();}}
Productクラス

*namespace DesignPatternLearn.FactoryMethodLearn.FrameWork*{public abstract class Factory{public Product Create(string owner){var product = CreateProduct(owner);RegisterProduct(product);return product;}public abstract Product CreateProduct(string owner);public abstract void RegisterProduct(Product product);}}
Factory クラス

*using DesignPatternLearn.FactoryMethodLearn.FrameWork;
IdCardクラス(Productクラスの実装)

*using DesignPatternLearn.FactoryMethodLearn.FrameWork;
IdCardFactoryクラス(Factoryクラスの実装)


*using (ParquetRowGroupWriter groupWriter = parquetWriter.CreateRowGroup()){groupWriter.WriteColumn(createdAtColumn);
create a new row group in the file

*var client = new TwitterClient("<your API Key>", "<your API Secret>","<your Access Token>", "<your Access Token Secret>");
User client & stream

*stream.MatchingTweetReceived += (sender, args) =>*{var lang = args.Tweet.Language;// Specify Japanese & Remove bot tweetsif (lang == Tweetinvi.Models.Language.Japanese && args.Tweet.Source.Contains(">Twitter ")){Console.WriteLine("----------------------------------------------------------------------");Console.WriteLine($"** CreatedAt : {args.Tweet.CreatedAt}");Console.WriteLine($"** CreatedBy : {args.Tweet.CreatedBy}");Console.WriteLine($"** Source    : {args.Tweet.Source}");Console.WriteLine($"** Text      : {args.Tweet.Text}");tweets.CreatedAt.Add(args.Tweet.CreatedAt);tweets.CreatedBy.Add(args.Tweet.CreatedBy.ToString());tweets.Source.Add(args.Tweet.Source);tweets.Text.Add(args.Tweet.Text);}++counter;if (counter > maxCount){stream.Stop();}};
Read stream

*var createdAtColumn = new Parquet.Data.DataColumn(new DataField<DateTimeOffset>("CreatedAt"),
create data columns with schema metadata and the data

*using (ParquetRowGroupWriter groupWriter = parquetWriter.CreateRowGroup()){groupWriter.WriteColumn(createdAtColumn);
create a new row group in the file


*SwipeMininalDuration, SwipeMaximalDuration))
Duration


*bitmapData.Width,
当然ながら画像サイズとストライドも必要

*if (bitmapData != null) hugeImage.UnlockBits(bitmapData);*}
ロックした画像を解放


*slime.setIntroduction(setName: "スライム", setExp: 200,setLife:100);
スライムの情報を取得する。


*var isOk = await postClass.PostMethod("グーグル", "中の人何人くらいで動かしてるんやろ", "https:
www.google.co.jp", "#ff0000");


*{
PDFに直接変換したい画像ファイルを複数選択できるようにしている。

*clsZIP cls = new clsZIP();
変換したい画像のリストを取得
string[] fileNames = fileDialog.FileNames;  こんな感じで選択されたファイルのパスが取得できる
PDFは、今回は仮に、最初のファイルと同じフォルダに「test.pdf」として生成される。

*MessageBox.Show("END");
おしまいのメッセージ

*Application.Exit();
さようなら


*}
非同期な処理


*using System.Transactions;
System.Transactions.dll

*fileMgr.CreateDirectory(@"test\a\newfolder");
「newfolder」ディレクトリを作成

*fileMgr.WriteAllText(@"test\a\newfolder\aaa.txt", "あああああ");
「newfolder\aaa.txt」ファイルを作成

*fileMgr.AppendAllText(@"test\a\newfolder\aaa.txt", "いいいい");
「newfolder\aaa.txt」ファイルに追記

*fileMgr.Move(@"test\a\test.txt", @"test\a\test_renamed.txt");
test.txt→test_renamed.txt に変更

*fileMgr.Snapshot(@"test\a\test_renamed.txt");
WriteAllTextはBOMなしのUTF8になるので、エンコードを変えたかったりバイナリを操作したい場合はSnapshotを行う


*io.AddInputCharacter(e);
ImGuiへ通知


*var createdAtColumn = new Parquet.Data.DataColumn(new DataField<DateTimeOffset>("CreatedAt"),
create data columns with schema metadata and the data

*var defaultDir = @"c:\temp\";*var fileName = $"{defaultDir}tweets.parquet";
create file

*using (ParquetRowGroupWriter groupWriter = parquetWriter.CreateRowGroup()){groupWriter.WriteColumn(createdAtColumn);
create a new row group in the file

*var client = new TwitterClient("<your API Key>", "<your API Secret>","<your Access Token>", "<your Access Token Secret>");
User client & stream

*stream.MatchingTweetReceived += (sender, args) =>*{var lang = args.Tweet.Language;// Specify Japanese & Remove bot tweetsif (lang == Tweetinvi.Models.Language.Japanese && args.Tweet.Source.Contains(">Twitter ")){Console.WriteLine("----------------------------------------------------------------------");Console.WriteLine($"** CreatedAt : {args.Tweet.CreatedAt}");Console.WriteLine($"** CreatedBy : {args.Tweet.CreatedBy}");Console.WriteLine($"** Source    : {args.Tweet.Source}");Console.WriteLine($"** Text      : {args.Tweet.Text}");tweets.CreatedAt.Add(args.Tweet.CreatedAt);tweets.CreatedBy.Add(args.Tweet.CreatedBy.ToString());tweets.Source.Add(args.Tweet.Source);tweets.Text.Add(args.Tweet.Text);}++counter;if (counter > maxCount){stream.Stop();}};
Read stream

*var createdAtColumn = new Parquet.Data.DataColumn(new DataField<DateTimeOffset>("CreatedAt"),
create data columns with schema metadata and the data

*var defaultDir = @"c:\temp\";*var fileName = $"{defaultDir}tweets.parquet";
create file

*using (ParquetRowGroupWriter groupWriter = parquetWriter.CreateRowGroup()){groupWriter.WriteColumn(createdAtColumn);
create a new row group in the file


*{
bmpに直接変換したい画像ファイルを選択できるようにしている。

*clsBMP cls = new clsBMP();
変換したい画像のパスを取得
string fileName = fileDialog.FileName;  こんな感じで選択されたファイルのパスが取得できる
Windows Bitmapは、今回は仮に、最初のファイルと同じフォルダに「test.bmp」として生成される。

*MessageBox.Show("END");
おしまいのメッセージ

*Application.Exit();
さようなら


*private Hashtable _postData = new Hashtable();
リクエストデータ格納用

*_webBrowser.RequestHandler = new RequestHandler(this);
リクエストイベント処理登録

*Invoke(new MethodInvoker(() => { SetFocus(_webBrowser.Handle); }));
_webBrowser.Focus()

*string jsScript = null;
読込完了処理を記述

*public bool SetRequestData(string url, string requestBody)*{string aaa = null;if (url.IndexOf("/exec/system/1161228728") >= 0) {if (requestBody.IndexOf("=") != -1) {string[] ary = requestBody.Split("&");for (int i = 0; i <= ary.Length - 1; i++) {string[] param = ary[i].Split("=");_postData.Add(Web.HttpUtility.UrlDecode(param[0]), Web.HttpUtility.UrlDecode(param[1]));}return true;}}return false;}
リクエストのデータセット処理

*public class RequestHandler : IRequestHandler*{private frmMain _frm;// コンストラクタpublic RequestHandler(frmMain frm){_frm = frm;}// リクエストが投げられる前に呼ばれる処理CefReturnValue IRequestHandler.OnBeforeResourceLoad(IWebBrowser browserControl, IBrowser browser, IFrame frame, IRequest request, IRequestCallback callback){if (request.Method == "POST"){using (var postData = request.PostData){var elements = postData.Elements;var charSet = request.GetCharSet();foreach (var element in elements){if (element.Type == PostDataElementType.Bytes){if (_frm.SetRequestData(browserControl.Address, element.GetBody(charSet)))break;}}}}return CefReturnValue.Continue;}bool IRequestHandler.OnOpenUrlFromTab(IWebBrowser browserControl, IBrowser browser, IFrame frame, string targetUrl, WindowOpenDisposition targetDisposition, bool userGesture){return false;}bool IRequestHandler.OnCertificateError(IWebBrowser browserControl, IBrowser browser, CefErrorCode errorCode, string requestUrl, ISslInfo sslInfo, IRequestCallback callback){return false;}void IRequestHandler.OnPluginCrashed(IWebBrowser browserControl, IBrowser browser, string pluginPath){}bool IRequestHandler.GetAuthCredentials(IWebBrowser browserControl, IBrowser browser, IFrame frame, bool isProxy, string host, int port, string realm, string scheme, IAuthCallback callback){callback.Dispose();return false;}void IRequestHandler.OnRenderProcessTerminated(IWebBrowser browserControl, IBrowser browser, CefTerminationStatus status){}void IRequestHandler.OnRenderViewReady(IWebBrowser browserControl, IBrowser browser){}bool IRequestHandler.OnQuotaRequest(IWebBrowser browserControl, IBrowser browser, string originUrl, long newSize, IRequestCallback callback){return false;}bool IRequestHandler.OnProtocolExecution(IWebBrowser browserControl, IBrowser browser, string url){return false;}bool IRequestHandler.OnResourceResponse(IWebBrowser browserControl, IBrowser browser, IFrame frame, IRequest request, IResponse response){return false;}void IRequestHandler.OnResourceLoadComplete(IWebBrowser browserControl, IBrowser browser, IFrame frame, IRequest request, IResponse response, UrlRequestStatus status, long receivedContentLength){}public void OnResourceRedirect(IWebBrowser browserControl, IBrowser browser, IFrame frame, IRequest request, IResponse response, ref string newUrl){}public IResponseFilter GetResourceResponseFilter(IWebBrowser browserControl, IBrowser browser, IFrame frame, IRequest request, IResponse response){return null;}public bool OnBeforeBrowse(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, bool userGesture, bool isRedirect){return false;}public bool OnSelectClientCertificate(IWebBrowser chromiumWebBrowser, IBrowser browser, bool isProxy, string host, int port, X509Certificate2Collection certificates, ISelectClientCertificateCallback callback){return true;}public bool CanGetCookies(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request){return true;}public bool CanSetCookie(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, CefSharp.Cookie cookie){return true;}}
リクエストハンドラークラス

*public RequestHandler(frmMain frm)*{_frm = frm;}
コンストラクタ


*public event KeyCommandEventHandler KeyCommand = ValueTuple => { };
------②

*KeyCommand(input);
イベントを発生


*var config = Configuration.Default.WithDefaultLoader().WithJs();
WithJs()で、JavaScriptを有効 動作してるか不明


*private Vector3 rotate;
キーボード操作用

*Debug.Log("started");
動作確認用のログ

*float speed = Time.deltaTime * 100.0f;
キーボードで視点変更

*else*{Quaternion gratitude = Input.gyro.attitude;gratitude.x *= -1;gratitude.y *= -1;transform.localRotation = Quaternion.Euler(90, 0, 0) * gratitude;}
スマホはジャイロで視点変更

*#if UNITY_EDITOR || UNITY_STANDALONE*private Vector3 rotate;
キーボード操作用

*Debug.Log("started");
動作確認用ログ1

*Debug.Log("non-smartphone");
動作確認用ログ2

*#if UNITY_EDITOR || UNITY_STANDALONE*float speed = Time.deltaTime * 100.0f;
PCの場合はキーボード、スマホはジャイロで視点変更


*private const double perEuro = 121.02;
ユーロ

*public static double DollarToYen(int dollar)*{return dollar * perDollar;}
ドル→円

*public static double YenToDollar(int yen)*{return yen / perDollar;}
円→ドル

*public static double PoundToYen(int pound){return pound * perPound;}
ポンド→円

*public static double YenToPound(int yen){return yen / perPound;}
円→ポンド

*public static double YuanToYen(int yuan)*{return yuan * perPound;}
元→円

*public static double YenToYuan(int yen)*{return yen / perPound;}
円→元

*public static double EuroToYen(int euro)*{return euro * perPound;}
ユーロ→円

*public static double YenToEuro(int yen)*{return yen / perPound;}
円→ユーロ


*string original = "Here is some data encrypt!";
AesCryptoServiceProivder を使うときは  CryptoConfig を使うと良い。
CryptoConfig cryptoConfig = new CryptoConfig();
var aes = (AesCryptoServiceProvider)CryptoConfig.CreateFromName("AES");

*var generatedKey = GenerateKey();*Console.WriteLine($"Key Length: {generatedKey.Length}");
var aes = (AesCryptoServiceProvider)CryptoConfig.CreateFromName("AES");

*//{//    byte[] key = new byte[KeySize / BitsPerByte];//    RandomNumberGenerator.Fill(key);//    Key = key;//}
public sealed override void GenerateKey()

*myAes.GenerateKey();*Console.WriteLine($"KeySize: {myAes.KeySize}");
}

*private static string GenerateKey()*{var buffer = new byte[32];using (var rng = new RNGCryptoServiceProvider()){rng.GetBytes(buffer);return BitConverter.ToString(buffer).Replace("-", string.Empty);}}
Make the key as 256-bit with the HEX string format


*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame


*}
なにがし

*using (var driver = new RemoteWebDriver(uri, options))
docker-compose.yml で立てたseleniumサーバ
var uri = new Uri("http:selenium:4444/wd/hub/");

*}
なにがし


*public static int WS_CAPTION = WS_BORDER | WS_DLGFRAME;
window with a title bar


*dynamic json =  JsonConvert.DeserializeObject("{'a':1}");
二重引用符ではなく一重引用符を含むプロパティ

*json = JsonConvert.DeserializeObject("{a:1}");
引用符なしのプロパティ

*json = JsonConvert.DeserializeObject("{\"a\":NaN}");
NaN,Infinity, -Infinity

*json = JsonConvert.DeserializeObject("{\"a\": 123,}");
末尾のコンマ

*json = JsonConvert.DeserializeObject("[1,,2]");
空のコンマ

*json = JsonConvert.DeserializeObject("{\"a\": 010}");
8進数

*json = JsonConvert.DeserializeObject("{\"a\": 0x010}");
16進数


*Thread.Sleep(1000);
重い処理

*Thread.Sleep(1000);
重い処理

*Thread.Sleep(1000);
重い処理


*ToUV(size.x - size.z, harfX + harfZ + size.y+0.5f),
6:most far top


*this.cancelBtn.Enabled = false;
キャンセル

*private void BackgroundWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)*{if((e.Error is null) == false){//エラーの表示等の処理Console.WriteLine("error");DialogResult = DialogResult.Cancel;}else if (e.Cancelled){//キャンセル時の処理Console.WriteLine("canceled");DialogResult = DialogResult.Cancel;}else{//完了時の処理Console.WriteLine("completed");DialogResult = DialogResult.OK;}//フォームを閉じるthis.Close();}
完了時の挙動

*Console.WriteLine("error");
エラーの表示等の処理

*Console.WriteLine("canceled");
キャンセル時の処理

*Console.WriteLine("completed");
完了時の処理

*this.Close();
フォームを閉じる

*private void BackgroundWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)*{//プログレスバーの値を変更する//設定されてる値の範囲外の値を渡すとエラーが発生することに注意if (e.ProgressPercentage < this.progressBar1.Minimum){this.progressBar1.Value = this.progressBar1.Minimum;}else if (this.progressBar1.Maximum < e.ProgressPercentage){this.progressBar1.Value = this.progressBar1.Maximum;}else{this.progressBar1.Value = e.ProgressPercentage;}//UserStateの内容を表示するprogressLabel.Text = e.UserState.ToString();}
進捗の表示

*if (e.ProgressPercentage < this.progressBar1.Minimum)
プログレスバーの値を変更する
設定されてる値の範囲外の値を渡すとエラーが発生することに注意

*progressLabel.Text = e.UserState.ToString();
UserStateの内容を表示する

*if (!backgroundWorker.IsBusy)
画面表示を開始した際に動いてない場合はRunWorkerAsync()を呼ぶ
二重に叩かないように判定を入れる

*if (backgroundWorker.IsBusy && !backgroundWorker.CancellationPending)
×ボタンで閉じられた際の対処
backgroundWorkerが動いており

*e.Cancel = true;
一度Closingをキャンセルしたうえで、改めてキャンセル処理をする。

*backgroundWorker.ProgressChanged -= BackgroundWorker_ProgressChanged;
フォーム側でイベントハンドラーに加えた処理を外す

*e.Cancel = true;
処理がキャンセルされた場合
※重要：競合を防ぐため、Cancel状態をDoWorkEventArgsにも伝える。
この処理を省くと、 RunWorkerCompletedEventArgs.Canceledがfalseのまま伝わる。

*bw.WorkerSupportsCancellation = true;
キャンセルできる処理を呼び出す

*var res = prgForm.ShowDialog();
進捗表示フォームを呼び出す。

*}*else{//正常終了でない場合の処理}
正常終了時の処理

*}
正常終了でない場合の処理

*bw.WorkerSupportsCancellation = false;
キャンセルできない処理を呼び出す。

*var res = prgForm.ShowDialog();
進捗表示フォームを呼び出す。

*}
正常終了時の処理

*}
正常終了でない場合の処理

*if (e.ProgressPercentage < this.progressBar1.Minimum)
プログレスバーの値を変更する
設定されてる値の範囲外の値を渡すとエラーが発生することに注意

*progressLabel.Text = e.UserState.ToString();
UserStateの内容を表示する

*if (backgroundWorker.IsBusy && !backgroundWorker.CancellationPending)
×ボタンで閉じられた際の対処
backgroundWorkerが動いており

*e.Cancel = true;
一度Closingをキャンセルしたうえで、改めてキャンセル処理をする。

*private void BackgroundWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)*{if((e.Error is null) == false){//エラーの表示等の処理Console.WriteLine("error");DialogResult = DialogResult.Cancel;}else if (e.Cancelled){//キャンセル時の処理Console.WriteLine("canceled");DialogResult = DialogResult.Cancel;}else{//完了時の処理Console.WriteLine("completed");DialogResult = DialogResult.OK;}//フォームを閉じるthis.Close();}
完了時の挙動

*Console.WriteLine("error");
エラーの表示等の処理

*Console.WriteLine("canceled");
キャンセル時の処理

*Console.WriteLine("completed");
完了時の処理

*this.Close();
フォームを閉じる

*this.cancelBtn.Enabled = false;
キャンセル

*if (!backgroundWorker.IsBusy)
画面表示を開始した際に動いてない場合はRunWorkerAsync()を呼ぶ
二重に叩かないように判定を入れる

*backgroundWorker.ProgressChanged -= BackgroundWorker_ProgressChanged;
フォーム側でイベントハンドラーに加えた処理を外す

*backgroundWorker.ProgressChanged -= BackgroundWorker_ProgressChanged;
フォーム側でイベントハンドラーに加えた処理を外す

*if (backgroundWorker.IsBusy && !backgroundWorker.CancellationPending)
×ボタンで閉じられた際の対処
backgroundWorkerが動いており

*e.Cancel = true;
一度Closingをキャンセルしたうえで、改めてキャンセル処理をする。

*return;
処理がキャンセルされた場合
e.Cancel = true;※重要：競合を防ぐため、Cancel状態をDoWorkEventArgsにも伝える。

*bw.DoWork += this.backgroundWorker_DoWork;
イベントハンドラーに処理を渡す。

*var res = prgForm.ShowDialog();*if(res == DialogResult.OK){//正常終了時の処理}
進捗表示フォームを呼び出す。

*}*else{//正常終了でない場合の処理}
正常終了時の処理

*}
正常終了でない場合の処理

*return;
処理がキャンセルされた場合
e.Cancel = true;※重要：競合を防ぐため、Cancel状態をDoWorkEventArgsにも伝える。


*AesEncrypter.WriteAesEncryptedBytesToFile("あいうえお", @"C:\work\test.bin");
"あいうえお"を暗号化

*var d = AesEncrypter.ReadAesEncryptedBytesFromFile(@"C:\work\test.bin");
暗号化したデータを読み出し復号化する

*(1文字あたり8bit→8*32=256bit→キーサイズ)private static readonly string AesKey = @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
キー 半角32文字のランダムな文字列

*private static readonly string AesKey = @"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
(1文字あたり8bit→8*32=256bit→キーサイズ)

*private static readonly int KeySize = 256;
キーサイズ(bit)

*private static readonly int BlockSize = 128;
ブロックサイズ

*public static byte[] Encrypt(string value)*{// AESオブジェクトを取得var aes = GetAesCng();// 対象の文字列をバイトデータに変換var byteValue = Encoding.UTF8.GetBytes(value);// バイトデータの長さを取得var byteLength = byteValue.Length;// 暗号化オブジェクトを取得var encryptor = aes.CreateEncryptor();// 暗号化return encryptor.TransformFinalBlock(byteValue, 0, byteLength);}
暗号化

*var aes = GetAesCng();
AESオブジェクトを取得

*var byteValue = Encoding.UTF8.GetBytes(value);
対象の文字列をバイトデータに変換

*var byteLength = byteValue.Length;
バイトデータの長さを取得

*var encryptor = aes.CreateEncryptor();
暗号化オブジェクトを取得

*return encryptor.TransformFinalBlock(byteValue, 0, byteLength);*}
暗号化

*public static string Decrypt(byte[] encryptValue)*{// AESオブジェクトを取得var aes = GetAesCng();// 復号化オブジェクトを取得var decryptor = aes.CreateDecryptor();// 復号化var decryptValue = decryptor.TransformFinalBlock(encryptValue, 0, encryptValue.Length);// 復号化されたバイトデータを文字列に変換var stringValue = Encoding.UTF8.GetString(decryptValue);return stringValue;}
復号化

*var aes = GetAesCng();
AESオブジェクトを取得

*var decryptor = aes.CreateDecryptor();
復号化オブジェクトを取得

*var decryptValue = decryptor.TransformFinalBlock(encryptValue, 0, encryptValue.Length);*// 復号化されたバイトデータを文字列に変換
復号化

*var stringValue = Encoding.UTF8.GetString(decryptValue);
復号化されたバイトデータを文字列に変換

*private static AesCng GetAesCng()*{// AESオブジェクトを生成し、パラメータを設定します。var aes = new AesCng();aes.KeySize = KeySize;aes.BlockSize = BlockSize;aes.Mode = CipherMode.CBC;aes.IV = Encoding.UTF8.GetBytes(AesIV);aes.Key = Encoding.UTF8.GetBytes(AesKey);aes.Padding = PaddingMode.PKCS7;return aes;}
AESオブジェクトを取得

*var aes = new AesCng();
AESオブジェクトを生成し、パラメータを設定します。

*public static void WriteAesEncryptedBytesToFile(string targetString, string keyFilePath)
文字列を暗号化してファイルに書き出す
targetString 暗号化したい文字列
keyFilePath 暗号化した文字列を書き込むファイル

*public static string ReadAesEncryptedBytesFromFile(string keyFilePath)
暗号化されたファイルからキーを読を復号して返す
keyFilePath キーファイルパス
return ： 復号化された文字列


*enemyEye = enemy.transform.Find("Face
Eye"); Enemyの子のFaceの子のEye


*Action<string> action = (path) =>*{if (path.EndsWith(".txt")) { paths.Add(path); }};
txt パスをリストに追加する

*Debug.Log(path);
各パスに対してやりたいこと

*var p = path + "/";
末尾に \ が付くのを回避（★）


*{
PDFに直接変換したい画像ファイルを複数選択できるようにしている。

*CreateODS cls = new CreateODS();
変換したい画像のリストを取得
string[] fileName = fileDialog.FileNames;  こんな感じで選択されたファイルのパスが取得できる
PDFは、今回は仮に、最初のファイルと同じフォルダに「test.pdf」として生成される。

*cls.title_string = "ここにタイトル";
入力する文字を横着して、ここにて指定。

*cls.main_string =　new string[] { "以下、本文です", "今日は晴れ","湿度は高め", "温度も高め", "いわゆる猛暑日", "とても暑い","困ったものです", "しかし、", "これも夏", "楽しまねば"};
本文のところ。

*MessageBox.Show("END");
おしまいのメッセージ

*Application.Exit();
さようなら


*{
PDFに直接変換したい画像ファイルを複数選択できるようにしている。

*clsPDF cls = new clsPDF();
変換したい画像のリストを取得
string[] fileName = fileDialog.FileNames;  こんな感じで選択されたファイルのパスが取得できる
PDFは、今回は仮に、最初のファイルと同じフォルダに「test.pdf」として生成される。

*MessageBox.Show("END");
おしまいのメッセージ

*Application.Exit();
さようなら


*var playlistUrl = $"https:
www.youtube.complaylist?list={playlistId}";


*[SerializeField] Text textBox;
処理中のメッセージは雑に全部これに表示します。

*var request = new LoginWithCustomIDRequest { CustomId = "MyCustomId", CreateAccount = true };
PlayFabにいつも通りログインします。

*Matchmaking();
ログインできたので続けてマッチングの処理を呼びます。

*var matchmakingPlayer = new MatchmakingPlayer{Entityは下記のコードで決め打ちで大丈夫です。Entity = new PlayFab.MultiplayerModels.EntityKey{Id = PlayFabSettings.staticPlayer.EntityId,Type = PlayFabSettings.staticPlayer.EntityType}};
プレイヤーの情報を作ります。

*Entity = new PlayFab.MultiplayerModels.EntityKey{Id = PlayFabSettings.staticPlayer.EntityId,Type = PlayFabSettings.staticPlayer.EntityType}};
Entityは下記のコードで決め打ちで大丈夫です。

*Creator = matchmakingPlayer,マッチングできるまで待機する秒数を指定します。最大600秒です。GiveUpAfterSeconds = 30,GameManagerで作ったキューの名前を指定します。QueueName = "1vs1Battle"};
先程作っておいたプレイヤー情報です。

*GiveUpAfterSeconds = 30,GameManagerで作ったキューの名前を指定します。QueueName = "1vs1Battle"};
マッチングできるまで待機する秒数を指定します。最大600秒です。

*QueueName = "1vs1Battle"};
GameManagerで作ったキューの名前を指定します。

*var getMatchmakingTicketRequest = new GetMatchmakingTicketRequest{TicketId = result.TicketId,QueueName = request.QueueName};
キューに積んだチケットの状態をマッチングするかタイムアウトするまでポーリングします。

*var seconds = 6f;
ポーリングは1分間に10回まで許可されているので、6秒間隔で実行するのがおすすめです。

*var matchmakingPlayer = new MatchmakingPlayer{Entityは下記のコードで決め打ちで大丈夫です。Entity = new PlayFab.MultiplayerModels.EntityKey{Id = PlayFabSettings.staticPlayer.EntityId,Type = PlayFabSettings.staticPlayer.EntityType},これ以下を追記Attributes = new MatchmakingPlayerAttributes{このプレイヤーは Rate 900～1100 のプレイヤーとしかマッチングしないDataObject = new { Rate = 1000 }}};
マッチングさせるプレイヤーの情報を作ります。

*Entity = new PlayFab.MultiplayerModels.EntityKey{Id = PlayFabSettings.staticPlayer.EntityId,Type = PlayFabSettings.staticPlayer.EntityType},これ以下を追記Attributes = new MatchmakingPlayerAttributes{このプレイヤーは Rate 900～1100 のプレイヤーとしかマッチングしないDataObject = new { Rate = 1000 }}};
Entityは下記のコードで決め打ちで大丈夫です。

*Attributes = new MatchmakingPlayerAttributes{このプレイヤーは Rate 900～1100 のプレイヤーとしかマッチングしないDataObject = new { Rate = 1000 }}};
これ以下を追記

*DataObject = new { Rate = 1000 }}};
このプレイヤーは Rate 900～1100 のプレイヤーとしかマッチングしない


*var response = s_webClient.UploadValues("https:
slack.comapichat.postMessage", "POST", data);


*lineRenderer.SetPosition(1, hitPos);
LineRendererの終点に当てはめる


*public override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context)*{return Task.FromResult(new HelloReply { Message = "Hello " + request.Name });}
Server side handler of the SayHello RPC


*myDataGrid.ColumnHeaderHeight = 20;
列ヘッダがある場合は適当な値を入れます

*myDataGrid.RowHeight = (myDataGrid.ActualHeight - myDataGrid.ColumnHeaderHeight) / 5 - hoge;
行数が5の場合
var hoge = 2;  行数で割るだけだとちょっとはみ出るので微調整


*string line;
プロパティクラスが手元の環境にないため以下


*var children = parent.FindAll(
parent には子要素を調べたい親要素のAutomationElementを指定する。
たとえばRootElementとか･･･。


*var game = PrefabUtility.InstantiatePrefab(obj) as GameObject;
インスタンス化

*var prefab = PrefabUtility.SaveAsPrefabAsset(game, "Assets/prefab.prefab");
〜　処理　〜
プレファブ作成

*PrefabUtility.UnpackPrefabInstance(game, PrefabUnpackMode.OutermostRoot, InteractionMode.AutomatedAction);
リンクを解除

*Object.DestroyImmediate(game);
シーンから削除


*MaxResultsCount = 11
自分と+-5位をあわせて合計11件を取得します。

*Debug.Log($"{item.Position + 1}位: {item.DisplayName} - {item.StatValue}回");
Positionは順位です。0から始まるので+1して表示しています。


*var match = Regex.Match(org, @"[\da-zA-Z]{4}");
②4桁英数字にマッチしたものを探す

*var matches = Regex.Matches(org, @"[\da-zA-Z]{4}");
③4桁英数字にマッチしたものを全部探す


*Stopwatch sw = new Stopwatch();
ストップウォッチを作成

*sw.Restart();
ストップウォッチをスタート

*Thread.Sleep(5000);
測りたい処理

*sw.Stop();
ストップウォッチを止める

*Debug.WriteLine(" 経過時間：" + sw.ElapsedMilliseconds + " ms");
経過時間をsw.Elapsed や sw.ElapsedMilliseconds で取得


*var address = new EndpointAddress("net.tcp:
localhost:8808service");

*var IHelloWorldService = channel.SayHello("test");*Console.WriteLine("SayHello() = {0}", IHelloWorldService);
サービス呼び出し


*writer.AddFrame(bmp);
フレームを追加


*return continuation(context);
とりあえずそのまま返す

*public Task WriteAsync(T message)*{// 書き込む前にintercept_interceptor(message as byte[]);return _baseStream.WriteAsync(message);}
キモの部分

*_interceptor(message as byte[]);
書き込む前にintercept

*public Task CompleteAsync() => _baseStream.CompleteAsync();
以下、インターフェースを満たすための実装

*public T Current*{get{// 読み取る前にintercept_interceptor(_baseStream.Current as byte[]);return _baseStream.Current;}}
キモの部分

*_interceptor(_baseStream.Current as byte[]);
読み取る前にintercept

*public Task<bool> MoveNext(CancellationToken cancellationToken) => _baseStream.MoveNext(cancellationToken);
以下、インターフェースを満たすための実装

*void intercept(byte[] data)*{// 雑にJSON化Debug.Log(MessagePackSerializer.ToJson(data));}
差し込む処理の定義

*Debug.Log(MessagePackSerializer.ToJson(data));
雑にJSON化

*return new AsyncDuplexStreamingCall<TRequest, TResponse>(new MyRequestStream<TRequest>(intercept, call.RequestStream),
自作Streamに差し替えたcallを返す

*public StreamingLoggingInterceptor()*{foreach (var method in typeof(THub).GetMethods()){_methodNameDic[FNV1A32.GetHashCode(method.Name)] = method.Name;}foreach (var method in typeof(TReceiver).GetMethods()){_methodNameDic[FNV1A32.GetHashCode(method.Name)] = method.Name;}}
メソッドIDからメソッド名への変換テーブルを用意

*private void PrintLog(string type, byte[] bytes)*{// 要素数を取得var readSize = 0;var length = MessagePackBinary.ReadArrayHeader(bytes, 0, out readSize);var offset = readSize;// 要素数4はエラー出力なので無視(!)if (length == 4) return;// 要素数3ならはじめはメッセージIDなので捨てるif (length == 3) offset += MessagePackBinary.ReadNext(bytes, offset);// メソッドID取得var methodId = MessagePackBinary.ReadInt32(bytes, offset, out readSize);offset += readSize;// 残りのデータをコピー(ToJsonにoffset渡したい…)var newBytes = BufferPool.Default.Rent();Array.Copy(bytes, offset, newBytes, 0, bytes.Length - offset);// 出力Debug.Log($"[{type}]{_methodNameDic[methodId]}: {MessagePackSerializer.ToJson(newBytes)}");BufferPool.Default.Return(newBytes);}
ログ出力処理本体

*var readSize = 0;
要素数を取得

*if (length == 4) return;*// 要素数3ならはじめはメッセージIDなので捨てる
要素数4はエラー出力なので無視(!)

*if (length == 3) offset += MessagePackBinary.ReadNext(bytes, offset);*// メソッドID取得
要素数3ならはじめはメッセージIDなので捨てる

*var methodId = MessagePackBinary.ReadInt32(bytes, offset, out readSize);
メソッドID取得

*var newBytes = BufferPool.Default.Rent();
残りのデータをコピー(ToJsonにoffset渡したい…)

*Debug.Log($"[{type}]{_methodNameDic[methodId]}: {MessagePackSerializer.ToJson(newBytes)}");
出力


*public static void WriteStringToFile(string path, string data)*{var dir = Path.GetDirectoryName(path);if (!Directory.Exists(dir)){Directory.CreateDirectory(dir);}using (var fs = new FileStream(path, FileMode.Create))using (var sw = new StreamWriter(fs)){sw.Write(data);}}
文字列をファイルに書き込み

*public static void WriteStringToFile2(string path, string data)*{var dir = Path.GetDirectoryName(path);if (!Directory.Exists(dir)){Directory.CreateDirectory(dir);}// 簡素なやり方。第二引数をtrueにすると、同じファイルに追記できる)using (var sw = new StreamWriter(path, true)){sw.Write(data);}}
文字列をファイルに書き込み2

*using (var sw = new StreamWriter(path, true)){sw.Write(data);
簡素なやり方。第二引数をtrueにすると、同じファイルに追記できる)

*public static string ReadStringFromFile(string path)*{string data = string.Empty;if (File.Exists(path)){using (var fs = new FileStream(path, FileMode.Open))using (var sr = new StreamReader(fs)){data = sr.ReadToEnd();}}return data;}
文字列をファイルから読み込み

*public static void WriteBinaryToFile(string path, byte[] data)*{var dir = Path.GetDirectoryName(path);if (!Directory.Exists(dir)){Directory.CreateDirectory(dir);}using (var fs = new FileStream(path, FileMode.Create))using (var sw = new BinaryWriter(fs)){sw.Write(data);}}
バイナリデータをファイルに書き込み(書き込み先のフォルダがない場合は作成する)

*public static byte[] ReadBinaryFromFile(string path)*{if (File.Exists(path)){using (var fs = new FileStream(path, FileMode.Open))using (var sr = new BinaryReader(fs)){int len = (int)fs.Length;byte[] data = new byte[len];sr.Read(data, 0, len);return data;}}return null;}
バイナリデータをファイルから読み込み


*const int automationPropID_dgvCellValue = 30045;
地道な調査で突き止めたID。環境によって違ったりしたらごめんね。

*string cellValue = string.Empty;
GetCachedPropertyValue()てのもあって、気にはなるけどそっちを使うとInvalidOperationExceptionを投げられちゃう


*public HogeHubReceiver Receiver { get; } = new HogeHubReceiver();
さっき作ったやつ

*var gameObject = new GameObject("ConnectionHolder");
DontDestroy化

*var holder = gameObject.AddComponent<ConnectionHolder>();
接続


*lt.ArrayWalk(data, delegate (string d)*{return $"[{d}]";});
匿名メソッド

*p.ArrayWalk(data, (string d) =>*{return $"[{d}]";});
ラムダ式


*enum ResultKind*{Win,Lose,Draw}
勝敗の種類

*enum HandKind*{Guu,Tyoki,Paa}
手の種類

*interface IRule*{// 勝敗を判定するResultKind Judge(HandKind myHand, IEnumerable<HandKind> otherHands);}
ジャンケンのルールを表すインターフェイス

*ResultKind Judge(HandKind myHand, IEnumerable<HandKind> otherHands);
勝敗を判定する

*using static Domain.HandKind;
Enum名の省略

*class StandardRule : IRule*{// 勝敗を判定するpublic ResultKind Judge(HandKind myHand, IEnumerable<HandKind> otherHands){uint winCount = 0;uint loseCount = 0;foreach (var otherHand in otherHands){var resultKind = Judge(myHand, otherHand);if (resultKind == Win) winCount++;else if (resultKind == Lose) loseCount++;}if (winCount * loseCount != 0 || winCount + loseCount == 0) return Draw;if (winCount != 0) return Win;return Lose;}// 1対1の時の勝敗判定private ResultKind Judge(HandKind myHand, HandKind otherHand){if (myHand == otherHand) return Draw;if ((myHand == Guu && otherHand == Paa) ||(myHand == Tyoki && otherHand == Guu) ||(myHand == Paa && otherHand == Tyoki))return Lose;return Win;}}
もっとも一般的なジャンケンのルール

*public ResultKind Judge(HandKind myHand, IEnumerable<HandKind> otherHands)*{uint winCount = 0;uint loseCount = 0;foreach (var otherHand in otherHands){var resultKind = Judge(myHand, otherHand);if (resultKind == Win) winCount++;else if (resultKind == Lose) loseCount++;}if (winCount * loseCount != 0 || winCount + loseCount == 0) return Draw;if (winCount != 0) return Win;return Lose;}
勝敗を判定する

*private ResultKind Judge(HandKind myHand, HandKind otherHand)*{if (myHand == otherHand) return Draw;if ((myHand == Guu && otherHand == Paa) ||(myHand == Tyoki && otherHand == Guu) ||(myHand == Paa && otherHand == Tyoki))return Lose;return Win;}
1対1の時の勝敗判定

*class Human<Rule> where Rule : IRule*{private readonly Rule rule;public HandKind Hand { get; }// ルールと出す手をセットpublic Human(Rule rule, HandKind hand){this.rule = rule;this.Hand = hand;}// 勝敗を知るpublic ResultKind KnowResult(Human<Rule>[] otherHumen)=> rule.Judge(Hand, otherHumen.Select(x => x.Hand));}
ジャンケンをする人間を表す

*public Human(Rule rule, HandKind hand)*{this.rule = rule;this.Hand = hand;}
ルールと出す手をセット

*public ResultKind KnowResult(Human<Rule>[] otherHumen)
勝敗を知る

*interface IView*{event Action<string> OnInput;// 入力を促すvoid ShowRequest();// 再入力を促すvoid ShowTryRequest();// 勝敗を出力するvoid ShowResult(string result, string myHand, IEnumerable<string> aiHands);}
ユーザーとのやりとりをするインターフェイス

*void ShowRequest();
入力を促す

*void ShowTryRequest();
再入力を促す

*void ShowResult(string result, string myHand, IEnumerable<string> aiHands);
勝敗を出力する

*class ConsoleView : Application.IView*{public event Action<string> OnInput;// 入力を促すpublic void ShowRequest(){Console.WriteLine("ジャンケンの手を選んでください（1=グー,2=チョキ,3=パー）");var input = Console.ReadLine();OnInput(input);}// 再入力を促すpublic void ShowTryRequest(){Console.WriteLine("もう一度入力してください");ShowRequest();}// 勝敗を出力するpublic void ShowResult(string result, string myHand, IEnumerable<string> aiHands){Console.WriteLine("あなた:" + myHand);foreach (var aiHand in aiHands)Console.WriteLine("AI:" + aiHand);Console.WriteLine("あなたは" + result + "です");}}
コンソールの入出力をするクラス

*public void ShowRequest()*{Console.WriteLine("ジャンケンの手を選んでください（1=グー,2=チョキ,3=パー）");var input = Console.ReadLine();OnInput(input);}
入力を促す

*public void ShowTryRequest()*{Console.WriteLine("もう一度入力してください");ShowRequest();}
再入力を促す

*public void ShowResult(string result, string myHand, IEnumerable<string> aiHands)*{Console.WriteLine("あなた:" + myHand);foreach (var aiHand in aiHands)Console.WriteLine("AI:" + aiHand);Console.WriteLine("あなたは" + result + "です");}
勝敗を出力する

*static class StringConverter*{// 文字列をHandKindへ変換("1"=グー,"2"=チョキ,"3"=パー)static public HandKind? StringToHandKind(string consoleString){int result;if (int.TryParse(consoleString, out result) == false) return null;if (result < 1 || result > 3) return null;var handKinds = new HandKind[] { HandKind.Guu, HandKind.Tyoki, HandKind.Paa };return handKinds[result - 1];}// ResultKindを文字列へ変換static public string ResultKindToString(ResultKind resultKind){switch (resultKind){case ResultKind.Draw:return "引き分け";case ResultKind.Win:return "勝利";default:return "敗北";}}// ResultKindを文字列へ変換static public string HandKindToString(HandKind handKind){switch (handKind){case HandKind.Guu:return "グー";case HandKind.Tyoki:return "チョキ";default:return "パー";}}}
文字列と相互変換する

*static public HandKind? StringToHandKind(string consoleString)*{int result;if (int.TryParse(consoleString, out result) == false) return null;if (result < 1 || result > 3) return null;var handKinds = new HandKind[] { HandKind.Guu, HandKind.Tyoki, HandKind.Paa };return handKinds[result - 1];}
文字列をHandKindへ変換("1"=グー,"2"=チョキ,"3"=パー)

*static public string ResultKindToString(ResultKind resultKind)*{switch (resultKind){case ResultKind.Draw:return "引き分け";case ResultKind.Win:return "勝利";default:return "敗北";}}
ResultKindを文字列へ変換

*static public string HandKindToString(HandKind handKind)*{switch (handKind){case HandKind.Guu:return "グー";case HandKind.Tyoki:return "チョキ";default:return "パー";}}
ResultKindを文字列へ変換

*class AiHumanCreator*{private readonly Random rand;public AiHumanCreator(Random rand) => this.rand = rand;// Aiの人間を複数生成するpublic Human<Rule>[] CreateAiHumen<Rule>(Rule rule, uint size) where Rule : IRule{var handKinds = new HandKind[] { HandKind.Guu, HandKind.Tyoki, HandKind.Paa };var aiHumen = new Human<Rule>[size];for (int i = 0; i < aiHumen.Length; i++){var aiHandKind = handKinds[rand.Next(3)];aiHumen[i] = new Human<Rule>(rule, aiHandKind);}return aiHumen;}}
Aiの人間を生成するクラス

*public Human<Rule>[] CreateAiHumen<Rule>(Rule rule, uint size) where Rule : IRule*{var handKinds = new HandKind[] { HandKind.Guu, HandKind.Tyoki, HandKind.Paa };var aiHumen = new Human<Rule>[size];for (int i = 0; i < aiHumen.Length; i++){var aiHandKind = handKinds[rand.Next(3)];aiHumen[i] = new Human<Rule>(rule, aiHandKind);}return aiHumen;}
Aiの人間を複数生成する

*class Game*{// ジャンケンゲームを開始するpublic Game(IView view, AiHumanCreator aiHumanCreator){view.OnInput += input =>{var handKind = StringConverter.StringToHandKind(input);if (handKind == null){view.ShowTryRequest();return;}var player = new Human<StandardRule>(new StandardRule(), (HandKind)handKind);var aiHumen = aiHumanCreator.CreateAiHumen(new StandardRule(), 2);view.ShowResult(StringConverter.ResultKindToString(player.KnowResult(aiHumen)),StringConverter.HandKindToString(player.Hand),aiHumen.Select(x => StringConverter.HandKindToString(x.Hand)));};view.ShowRequest();}}
ゲームを表す

*public Game(IView view, AiHumanCreator aiHumanCreator)*{view.OnInput += input =>{var handKind = StringConverter.StringToHandKind(input);if (handKind == null){view.ShowTryRequest();return;}var player = new Human<StandardRule>(new StandardRule(), (HandKind)handKind);var aiHumen = aiHumanCreator.CreateAiHumen(new StandardRule(), 2);view.ShowResult(StringConverter.ResultKindToString(player.KnowResult(aiHumen)),StringConverter.HandKindToString(player.Hand),aiHumen.Select(x => StringConverter.HandKindToString(x.Hand)));};view.ShowRequest();}
ジャンケンゲームを開始する


*private static MySingleton instance = new MySingleton();
アプリで保持すべき唯一のインスタンスをクラスフィールドとして保存

*private MySingleton()*{Console.WriteLine("シングルトンの生成");}
コンストラクターをprivate宣言することで1度だけしかインスタンスが生成されない

*public static MySingleton Instance*{get { return instance; }}
唯一のインスタンスを取得するプロパティ

*Console.WriteLine(obj2.str);
インスタンスは1つしか生成されないため、dataの内容は「シングルトン１」となる


*g.DrawRectangle(pen[i], rectClip[i]);
確認用

*g.SetClip(rectDraw);
clipを元に戻す

*g.DrawPath(Pens.Black, gp);
文字列の縁を描画する


*chart1.AddSeries(series2);
標準系列なのでchart1.Series.Add(series2)でもよい

*series1 = new ScrollSeries() { ChartType = SeriesChartType.Line, Color = Color.Yellow, BorderWidth = 2, UseXValue = true, MaxPoints = MAX_POINTS, SlicePoints = 10 };
X値を使用する例

*private void Timer1_Tick(object sender, EventArgs e)*{var yValue = Math.Sin(Math.PI * (counter-6) / 6d) * 30;series1.AddScrollPoint(new DataPoint(0, yValue));series2.Points.Insert(0,new DataPoint(0, yValue));if(series2.Points.Count > MAX_POINTS){series2.Points.RemoveAt(MAX_POINTS);}counter = (++counter) % 12;bool empty = rand.Next(0,10) == 0 ? false : true;series3.AddScrollPoint(new DataPoint(0, 5){ IsEmpty = empty});//chart1.Invalidate();  // chart1.AddSeriesの代わりにchart1.Series.Addを使用する場合}
100msごとに動作

*}
chart1.Invalidate();   chart1.AddSeriesの代わりにchart1.Series.Addを使用する場合


*selectedPiece = clickedGameObject.FindInParents<PieceAbstract>();
PieceAbstract objectか判定

*isSelected = true;
選択状態をTrueに

*else*{//  Tile objecetの判定if (clickedGameObject.gameObject.tag == "Tile"){// 既に駒が配置されていた場合は、その駒とswapif (clickedGameObject.HasChild()){foreach(Transform child in clickedGameObject.transform){//念のためPieceか確認if (child.HasComponent<PieceAbstract>()){swapPiece(child, selectedPiece);//Childは一つのはずだが、念のためBreakbreak;}}}//  tileにpieceObjectを配置else{setPiece(selectedPiece, clickedGameObject.transform);}// effect解除}else if(clickedGameObject.FindInParents<PieceAbstract>()){//swap処理swapPiece(selectedPiece, clickedGameObject.FindInParents<PieceAbstract>().transform);}// 選択状態をFalseにisSelected = false;selectedPiece = null;}
選択モードの場合

*break;
Childは一つのはずだが、念のためBreak

*else*{setPiece(selectedPiece, clickedGameObject.transform);}
tileにpieceObjectを配置

*}*else if(clickedGameObject.FindInParents<PieceAbstract>()){//swap処理swapPiece(selectedPiece, clickedGameObject.FindInParents<PieceAbstract>().transform);}
effect解除

*swapPiece(selectedPiece, clickedGameObject.FindInParents<PieceAbstract>().transform);*}
swap処理

*isSelected = false;
選択状態をFalseに

*else*{isSelected = false;selectedPiece = null;}
RayCastがhitしなかった場合

*piece.parent = tile.transform;*//TileObjectを親としたローカルポジションを設定
Pieceの親オブジェクトにTileを設定

*piece.localPosition = new Vector3(0, 0, 0);
TileObjectを親としたローカルポジションを設定

*Transform tile1 = piece1.parent;*Transform tile2 = piece2.parent;
各Pieceの親となるTileオブジェクトを見つける

*piece1.parent = tile2;
親となるTileをそれぞれ入れかえ

*piece2.localPosition = new Vector3(0, 0, 0);
駒を新しい親Tileの場所に移動（Swap）


*namespace Tests.Functions*{/// <summary>/// <see cref="Function{TDbContext}">のテストクラス/// </summary>public class FunctionTest : IClassFixture<MyDbContextFixture>, IDisposable{private readonly ITestOutputHelper _output;private readonly MyDbContextFixture _fixture;private readonly MyDBContextName _context;public FunctionTest(MyDbContextFixture fixture, ITestOutputHelper output){_output = output;_fixture = fixture;_context = fixture.Context;}// ご自身で引数のテストデータ作成します// DBに登録したいテストデータをいれます// GetTestData()/// <summary>/// テストデータを削除/// </summary>void IDisposable.Dispose(){var list = _context.PrPrint.ToList<PrPrint>();_context.PrPrint.RemoveRange(list);_context.SaveChanges();}/// <summary>/// ステータスコードが60から70に更新/// </summary>[Theory(DisplayName = "ステータスコード更新")][MemberData(nameof(MyTestDataName))]public void UpdateTest(inputModel){var function = new TestFunction<MyDBContextName>(_context);// テストデータをInsertvar list = GetTestData();_context.TestTable.AddRange(GetTestData());_context.SaveChanges();// テストしたい内容var result = function.Update_Test(inputModel);_output.WriteLine(JsonConvert.SerializeObject(result));var entity = _context.TestTable.Where(x => x.Id == result.Id).SingleOrDefault();// DBのステータスコードが70Assert.Equal("70", entity.StatusCd);}}}
テストしたいプロジェクトを参照するのを忘れずに

*void IDisposable.Dispose()
ご自身で引数のテストデータ作成します
DBに登録したいテストデータをいれます
GetTestData()

*var list = GetTestData();
テストデータをInsert

*var result = function.Update_Test(inputModel);
テストしたい内容

*Assert.Equal("70", entity.StatusCd);
DBのステータスコードが70

*var list = GetTestData();
テストデータをInsert


*class Character*{public double Hp;public double Mp;public double Atk;public Character(){this.Hp = 100;this.Mp = 100;this.Atk = 100;}// ステータスを取得(ダミー)public virtual string GetStatus(){return string.Empty;}}
基底クラス

*public virtual string GetStatus()*{return string.Empty;}
ステータスを取得(ダミー)

*class Soldier : Character*{// 剣士のステータスを取得public override string GetStatus(){this.Hp = this.Hp * 1.5;this.Mp = this.Mp * 0.5;this.Atk = this.Atk * 2;return $"剣士のステータスはHP:{this.Hp},MP:{this.Mp},ATK:{this.Atk}です";}}
派生クラス(剣士)

*public override string GetStatus()*{this.Hp = this.Hp * 1.5;this.Mp = this.Mp * 0.5;this.Atk = this.Atk * 2;return $"剣士のステータスはHP:{this.Hp},MP:{this.Mp},ATK:{this.Atk}です";}
剣士のステータスを取得

*class Wizard : Character*{// 魔法使いのステータスを取得public override string GetStatus(){this.Hp = this.Hp * 1.3;this.Mp = this.Mp * 2;this.Atk = this.Atk * 0.5;return $"魔法使いのステータスはHP:{this.Hp},MP:{this.Mp},ATK:{this.Atk}です";}}
派生クラス(魔法使い)

*public override string GetStatus()*{this.Hp = this.Hp * 1.3;this.Mp = this.Mp * 2;this.Atk = this.Atk * 0.5;return $"魔法使いのステータスはHP:{this.Hp},MP:{this.Mp},ATK:{this.Atk}です";}
魔法使いのステータスを取得

*static void PrintStatus(Character c)*{Console.WriteLine(c.GetStatus());}
キャラのステータス表示メソッド

*public abstract string GetStatus();
抽象メソッド

*interface ICharacter*{string GetStatus();}
インターフェース


*var wordList=words.Replace("\r\n","\n").Split(new[]{'\n','\r'});
using System;

*,,,
1000000ループの処理時間: 474ms(csc/.NET Framework)

*var wordList=words.Split(new[]{"\r\n","\n","\r"},StringSplitOptions.None);
using System;

*,,,
1000000ループの処理時間: 504ms(csc/.NET Framework)


*}
Animalを基底クラス、親クラス、スーパークラスと呼ぶ
Catを派生クラス、子クラス、サブクラスと呼ぶ

*class Animal*{public string Kind;public string Cry;public string Show(){return $"{this.Kind}";}}
親クラス

*class Cat : Animal*{public string Name;// 子クラス独自のメソッドを定義可能public string GetCry(){// 親クラスの変数が利用可能return $"{this.Kind}は{this.Cry}と鳴く";}}
子クラス

*public string GetCry()*{// 親クラスの変数が利用可能return $"{this.Kind}は{this.Cry}と鳴く";}
子クラス独自のメソッドを定義可能

*return $"{this.Kind}は{this.Cry}と鳴く";
親クラスの変数が利用可能

*Console.WriteLine(cat.Show());
親クラスで定義されたShowメソッドを
子クラスのメンバーであるかのように呼び出せる

*public new string Show()*{return $"{this.Kind}の{this.Name}";}
親クラスのShowメソッドを隠蔽

*class Animal*{public string Name { get;}public string Kind { get;}public Animal(string name, string kind){Name = name;Kind = kind;}public virtual string Show()=> $"{this.Kind}の{this.Name}";}
親クラス

*class Cat : Animal*{public int Age { get; }public Cat(string name, string kind, int age) : base(name, kind){Age = age;}public override string Show(){if (Age < 1){return $"{this.Kind}の赤ちゃんの{this.Name}";}else{return base.Show();}}}
子クラス

*class Animal*{public Animal(){Console.WriteLine("動物");}}
親クラス

*class Cat : Animal*{public Cat(){Console.WriteLine("猫");}}
子クラス

*class Animal*{public Animal(string str){Console.WriteLine($"動物が{str}です");}}
親クラス

*class Cat : Animal*{public Cat(string str) : base(str){Console.WriteLine($"猫が{str}です");}}
子クラス

*sealed class Animal*{}
親クラス

*class Cat : Animal  => エラーとなる*{}
子クラス


*} else if (File.Exists (sourcePath)) {
Mac, Windows, iPhone


*void next(){if(getPageCount > openingPage){openingPage++;}}
...

*private int num = 10;
クラス内部で扱われる変数

*public int Num{// 代入される時set{ this.num = value;}// 値を読まれる時get{ return num;}}
R/Wできるプロパティ

*set{ this.num = value;}
代入される時

*get{ return num;}
値を読まれる時

*public string Message{get{ return message; }}
Read onlyなプロパティ

*var a = instance.Num;
numの読み書き

*var msg = instance.Message;
messageの読み書き

*var book = new Book("不思議の国のアリス", pages);
pagesをいい感じになんかしたとして...

*var readingPage = book.getPage();
プロパティにする前

*var readingPage = book.page;
プロパティにしたあと


*.UseAutofacContainerBuilder(containerBuilder)
Must be the first line!

*)*.AddEvents(new[] {typeof(利用者を登録した),typeof(本を登録した),typeof(本を借りた),typeof(本を返した),typeof(本を破棄した),})
.RunBootstrapperOnHostStartup()

*//.Configure((JsonSerializerSettings s) => { })
.AddConverter<SingleValueObjectConverter>()


*string documentPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
特殊ディレクトリのパスを取得

*string documents = Directory.EnumerateFiles(documentFilePath, "*", SearchOption.AllDirectories);
サブディレクトリ含めてパスを全部見る。丸裸よ。


*return "ExampleMemberInfo";
何らかの取得処理の呼び出し

*}
更新処理の呼び出し

*return "ExampleMemberInfo";
何らかの取得処理の呼び出し

*}
更新処理の呼び出し

*return "ExampleMemberInfo";
何らかの取得処理の呼び出し

*}
更新処理の呼び出し


*yield return hogehoge(data2);
ifでどちらかのyield

*continue;
ちゃんと帰りましょう

*continue;
null不要ならそのままcontinue;

*yield return data2 == null ? null : hogehoge(data2);
1行で表現したり


*ProcessStartInfo processStartInfo = new ProcessStartInfo("C:\\Program Files (x86)\\Internet Explorer\\iexplore.exe", "http:
yahoo.co.jp");


*void BrowseFolder()*{using (var ofd = new OpenFileDialog() { FileName = "SelectFolder", Filter = "Folder|.", CheckFileExists = false }){if (ofd.ShowDialog() == DialogResult.OK){Console.WriteLine(Path.GetDirectoryName(ofd.FileName));}}}
using System.IO;


*private Action sFunc[];
スキルの関数を格納する配列


*var taxIncludedPrice = CommonLib.CalcTaxIncludedPrice(100);
デフォルト引数を書いていないこのコードは

*var taxIncludedPrice = CommonLib.CalcTaxIncludedPrice(100, 1.08M);
コンパイル時にこのようなコードに解釈される

*public static decimal CalcTaxIncludedPrice(decimal price, decimal rate)*{return price * rate;}
オーバーロードして利率を渡せるバージョンのメソッドを作る

*public static decimal CalcTaxIncludedPrice(decimal price)*{return CalcTaxIncludedPrice(price, 1.08M);}
元のメソッドはオーバーロードしたメソッドを呼び出すようにする


*if (pointList.Corners.Length < 5) return null;
そもそも頂点が足りない


*}
処理


*void GetComAndDes()*{Component[] components = GetComponentsInChildren<Component>();foreach(Component component in components){if (component.GetType().Name == componentName){DestroyImmediate(component);}}}
コンポーネントを取得して該当コンポーネントを削除

*rootClass.GetComAndDes();
押下時に実行したい処理

*void GetComAndDes()*{Component[] components = GetComponentsInChildren<Component>();foreach(Component component in components){if (component.GetType().Name == componentName){DestroyImmediate(component);}}}
コンポーネントを取得して該当コンポーネントを削除


*public override string ToString()*{return $"{GetType()}: {Message}" + Environment.NewLine + $"MyProperty: {MyProperty}";}
EVIL code

*public override string ToString()*{return base.ToString() + Environment.NewLine + $"MyProperty: {MyProperty}";}
Not good

*throw new MyException(1, "this is an example.");
MyPropertyに1, Messageに"this is an example."を指定

*public override string Message*{get{return base.Message + Environment.NewLine + $"MyProperty: {MyProperty}";}}
Good

*throw new MyException(1, "this is an example.");
MyPropertyに1, Messageに"this is an example."を指定


*Transform SenderAnchor;*// 共有したい座標
送信側のアンカー

*var worldPosition = ts.position;
共有したい座標

*var relativePosition = SenderAnchor.transform.worldToLocalMatrix.MultiplyPoint3x4(worldPosition);*,,,
アンカーからの相対座標に変換します

*Transform ReceiverAnchor;*// 受け取り側のPositionに復元します
受信側のアンカー

*var local = ReceiverAnchor.transform.localToWorldMatrix.MultiplyPoint3x4(relativePosition);*,,,
受け取り側のPositionに復元します

*var worldRotation = ts.rotation;
共有したい姿勢

*var relativeRotation = Quaternion.Inverse(SenderAnchor.transform.rotation) * worldRotation;*,,,
アンカーからの相対角度に変換します

*var local = ReceiverAnchor.transform.rotation * relativeRotation;*,,,
受け取り側のRotationに復元します

*[SerializeField] private GameObject SenderAnchor;
送信側のアンカー

*[SerializeField] private GameObject SenderChild;
送信側の子

*[SerializeField] private GameObject ReceiverAnchor;
受信側のアンカー

*[SerializeField] private GameObject ReceiverChild;
受信側の子

*o.GetComponent<Renderer>().material.color = UnityEngine.Random.ColorHSV();
てきとうにカラーリング

*SenderAnchor.transform.SetPositionAndRotation(UnityEngine.Random.onUnitSphere, UnityEngine.Random.rotation);*ReceiverAnchor.transform.SetPositionAndRotation(UnityEngine.Random.onUnitSphere + new Vector3(7, 0, 0), UnityEngine.Random.rotation);
アンカーをランダムな位置に配置

*SenderChild.transform.position = UnityEngine.Random.onUnitSphere * 2;*SenderChild.transform.rotation = UnityEngine.Random.rotation;
送信側の子オブジェクトをランダムな位置に配置

*var ts = SenderChild.transform;*var (sendP, sendQ) = WorldToRelative(SenderAnchor.transform, ts.position, ts.rotation);
送信側のワールド座標からアンカーからの相対座標に変換

*var (receiveP, receiveQ) = RelativeToWorld(ReceiverAnchor.transform, sendP, sendQ);*ReceiverChild.transform.SetPositionAndRotation(receiveP, receiveQ);
アンカーからの相対座標を受信側のアンカーに依るワールド座標に変換

*SenderAnchor.transform.SetPositionAndRotation(Vector3.zero, Quaternion.identity);*ReceiverAnchor.transform.SetPositionAndRotation(Vector3.zero, Quaternion.identity);
アンカー同士の位置を揃えることで子オブジェクトの位置が揃っていることを確認する


*Cleaners cleaners = new Cleaners();
クリーニング店

*Customer custmer = new Customer(cleaners);
行きつけのクリーニング店のある顧客

*custmer.BuyCouponTicket();
回数券を買う

*custmer.StockDirtyLaundry();
服を汚す

*custmer.GoCleaners();
クリーニング店に行く

*class Customer*{// 行きつけのクリーニング店のある顧客public Customer(Cleaners regularCleaners){RegularCleaners = regularCleaners;CleanLaundry.Add(new Clothes("T-Shirt"));CleanLaundry.Add(new Clothes("Jacket"));}// 汚れた洗濯物public List<Clothes> DirtyLaundry { get; } = new List<Clothes>();// 回数券private Queue<Coupon> CouponTicket { get; } = new Queue<Coupon>();// 行きつけのクリーニング店private Cleaners RegularCleaners = null;// きれいな洗濯物public List<Clothes> CleanLaundry { get; } = new List<Clothes>();// 汚れものを貯めるpublic void StockDirtyLaundry(){// きれいな洗濯物をひとつ取り出して、Clothes clothes = CleanLaundry[0];CleanLaundry.RemoveAt(0);// その洗濯物を、汚れた洗濯物にするclothes.Dirty = true;DirtyLaundry.Add(clothes);}// 回数券を買うpublic void BuyCouponTicket(){// お金は払ってないけれど、省略しているだけCouponTicket.Enqueue(new Coupon());}// クリーニング店に行くpublic void GoCleaners(){// 行きつけのクリーニング店.洗濯する(汚れた洗濯物,回数券);List<Clothes> clothes = RegularCleaners.Wash(DirtyLaundry, CouponTicket.Dequeue());// 仕上り品としてしまうCleanLaundry.AddRange(clothes);}}
顧客

*public Customer(Cleaners regularCleaners)*{RegularCleaners = regularCleaners;CleanLaundry.Add(new Clothes("T-Shirt"));CleanLaundry.Add(new Clothes("Jacket"));}
行きつけのクリーニング店のある顧客

*public List<Clothes> DirtyLaundry { get; } = new List<Clothes>();
汚れた洗濯物

*private Queue<Coupon> CouponTicket { get; } = new Queue<Coupon>();
回数券

*private Cleaners RegularCleaners = null;
行きつけのクリーニング店

*public List<Clothes> CleanLaundry { get; } = new List<Clothes>();
きれいな洗濯物

*public void StockDirtyLaundry()*{// きれいな洗濯物をひとつ取り出して、Clothes clothes = CleanLaundry[0];CleanLaundry.RemoveAt(0);// その洗濯物を、汚れた洗濯物にするclothes.Dirty = true;DirtyLaundry.Add(clothes);}
汚れものを貯める

*Clothes clothes = CleanLaundry[0];
きれいな洗濯物をひとつ取り出して、

*clothes.Dirty = true;
その洗濯物を、汚れた洗濯物にする

*public void BuyCouponTicket()*{// お金は払ってないけれど、省略しているだけCouponTicket.Enqueue(new Coupon());}
回数券を買う

*CouponTicket.Enqueue(new Coupon());
お金は払ってないけれど、省略しているだけ

*public void GoCleaners()*{// 行きつけのクリーニング店.洗濯する(汚れた洗濯物,回数券);List<Clothes> clothes = RegularCleaners.Wash(DirtyLaundry, CouponTicket.Dequeue());// 仕上り品としてしまうCleanLaundry.AddRange(clothes);}
クリーニング店に行く

*List<Clothes> clothes = RegularCleaners.Wash(DirtyLaundry, CouponTicket.Dequeue());
行きつけのクリーニング店.洗濯する(汚れた洗濯物,回数券);

*CleanLaundry.AddRange(clothes);
仕上り品としてしまう

*class Cleaners*{// 洗濯するpublic List<Clothes> Wash(List<Clothes> clothes,Coupon coupon){// 回数券クーポンを破棄し// (略)// 洗濯するforeach(Clothes oneClothes in clothes){oneClothes.Dirty = false;}// 返却するreturn clothes;}}
クリーニング店

*public List<Clothes> Wash(List<Clothes> clothes,Coupon coupon)*{// 回数券クーポンを破棄し// (略)// 洗濯するforeach(Clothes oneClothes in clothes){oneClothes.Dirty = false;}// 返却するreturn clothes;}
洗濯する

*foreach(Clothes oneClothes in clothes)
回数券クーポンを破棄し
(略)
洗濯する

*return clothes;
返却する


*}
FinalException に例外が格納されている


*var size = type.GetField("_size", BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);
_size フィールドを取得

*size.SetValue(ls, capacity);
_size フィールドに capacity を書き込む

*}
var normal = new List<int>(100);  普通に new すると...
normal[50] = 200;                 System.ArgumentOutOfRangeException で死ぬ
Console.WriteLine(normal[50]);
var ls = GenerateList<int>(100);     GenerateList<T> を使えば、
ls[50] = 200;                        アクセスできる！！
Console.WriteLine(ls[50]);           output: 200

*for (int i = 0; i < capacity; i++)
ここで各要素を初期化.
※ C/C++ のネイティブ関数をコールすれば高速化できそう...

*var size = type.GetField("_size", BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);
_size フィールドを取得

*var items = type.GetField("_items", BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);
_items フィールドを取得

*size.SetValue(ls, capacity);
_size フィールドに capacity を書き込む

*items.SetValue(ls, ary);
_items フィールドに ary を書き込む

*Parallel.ForEach(Partitioner.Create(0, capacity), partition =>*{var (start, end) = partition;for (int i = start; i < end; i++)ary[i] = value;});
チャンク分けしてあげる

*Parallel.ForEach(Partitioner.Create(0, capacity), partition =>*{var (start, end) = partition;for (int i = start; i < end; i++)ary[i] = generator(i);});
チャンク分けしてあげる

*var ls = new List<T>();
空配列で初期化させる.
capacity を指定すると, 余計な new が発生する.


*const string roomName = "SampleRoom";
ルームは全員固定

*this.room = await this.Group.AddAsync(roomName);
ルームに参加&ルームを保持

*me = player;
自分の情報も保持

*this.Broadcast(room).OnJoin(me.Name);
参加したことをルームに参加している全メンバーに通知

*await room.RemoveAsync(this.Context);
ルーム内のメンバーから自分を削除

*this.Broadcast(room).OnLeave(me.Name);
退室したことを全メンバーに通知

*this.Broadcast(room).OnSendMessage(me.Name, message);
発言した内容を全メンバーに通知

*me.Position = position;
サーバー上の情報を更新

*this.Broadcast(room).OnMovePosition(me);
更新したプレイヤーの情報を全メンバーに通知

*this.SampleHubTest();
普通の API の呼び出しはコメントアウトしておきます
残しておいても問題はないです（リアルタイム通信と両方動きます）
this.SampleServiceTest(1, 2);

*var player = new Player{Name = "Minami",Position = new Vector3(0, 0, 0),Rotation = new Quaternion(0, 0, 0, 0)};
自分のプレイヤー情報を作ってみる

*await this.sampleHub.JoinAsync(player);
ゲームに接続する

*await this.sampleHub.SendMessageAsync("こんにちは！");
チャットで発言してみる

*player.Position = new Vector3(1, 0, 0);
位置情報を更新してみる

*await this.sampleHub.LeaveAsync();
ゲームから切断してみる

*};
Pathの「Sample.Server」と「Sample.Server.csproj」は実際のものに書き換えてください


*this.rigidBody.constraints = RigidbodyConstraints2D.FreezeRotation;
衝突時にobjectを回転させない設定

*input = new Vector2(Input.GetAxis("Horizontal"),
入力を取得

*rigidBody.position += input * SPEED;
既存のポジションに対して、移動量(vector)を加算する


*G = 0.98f
12.0f;  重力

*void Update () {PlayerAction();}
Update is called once per frame

*float jump()*{A -= G;//PosY += Acc;//if (PosY < 0.0f) // 0.0は地面if(A < 0.0f){// 着地A = 0.0f;}return A;}
ジャンプ中

*//if (PosY < 0.0f) // 0.0は地面*if(A < 0.0f)
PosY += Acc;

*A = 0.0f;
着地

*bool x = false;
右・左

*scale.x = 4;
右向き

*scale.x = -4;
左向き(反転)

*transform.localScale = scale;*float a, b;
代入しなおす

*rigidbody2D.velocity = Vector2.zero;
速度をクリアした2回目のジャンプも1回目と同じ挙動にする。

*Vector2 direction = new Vector2(a, b);
移動する向きを決める

*GetComponent<Rigidbody2D>().velocity = 2.1f * direction * speed;
移動する向きとスピードを代入する


*enum E{}
OK シリアライズされる

*enum L : long {}
Unsupported enum type 'BattlePlayer.Type' used for field 'type' in class 'BattlePlayer'


*private void UpdateCapTouchStates()*{m_isPointing = !OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, m_controller);m_isGivingThumbsUp = !OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, m_controller);}
debouncing.


*static public Func<int, int> func = x => x * 10;
ラムダ式


*var client = new TwitterClient("<your API Key>", "<your API Secret>","<your Access Token>", "<your Access Token Secret>");
User client & stream

*stream.MatchingTweetReceived += (sender, args) =>*{var lang = args.Tweet.Language;// Specify Japanese & Remove bot tweetsif (lang == Tweetinvi.Models.Language.Japanese && args.Tweet.Source.Contains(">Twitter ")){Console.WriteLine("----------------------------------------------------------------------");Console.WriteLine($"** CreatedAt : {args.Tweet.CreatedAt}");Console.WriteLine($"** CreatedBy : {args.Tweet.CreatedBy}");Console.WriteLine($"** Source    : {args.Tweet.Source}");Console.WriteLine($"** Text      : {args.Tweet.Text}");}++counter;if (counter >= maxCount){stream.Stop();}};
Read stream


*private dynamic targetForm;
Formへの参照。
このクラス内でのFormへはdynamic型経由でアクセスしているため、
コントロール名やメソッド名が変わったらここでアクセスする名前も変更しなければいけないことに注意

*var path = System.IO.Path.GetFullPath("TestTarget.exe");
テスト対象のパスを取得

*var app = new WindowsAppFriend(Process.Start(path));
テスト対象のプロセスを開始し、WindowsAppFriendでプロセスへアタッチ

*targetForm = app.Type(typeof(Application)).OpenForms[0];
メインフォームへの参照を取得

*public bool IsExecute_button_Enable()*{return (bool)targetForm.execute_button.Enabled;}
Executeボタンの有効/無効状態の取得するヘルパー

*public string StatusText()*{return (string)targetForm.result_textBox.Text;}
Statusテキストボックスのテキストの取得するヘルパー

*public void PushExecute()*{targetForm.Execute_button_Click(null, null);}
Executeボタンの押下を実行するヘルパー

*public void CloseForm()*{targetForm.Close();}
フォームを閉じるヘルパー

*Assert.AreEqual(false, helper.IsExecute_button_Enable());
起動直後は起動中状態であることを確認

*Thread.Sleep(1500);
起動完了待ち

*Assert.AreEqual(true, helper.IsExecute_button_Enable());
起動完了後のステータス確認

*helper.PushExecute();
実行ボタン押下

*Assert.AreEqual(false, helper.IsExecute_button_Enable());
実行直後のステータス確認

*Thread.Sleep(1500);
実行完了待ち

*Assert.AreEqual(true, helper.IsExecute_button_Enable());
実行完了後のステータス確認


*var api = RestService.For<IGitHubApi>("https:
api.github.com", new RefitSettings


*.Do(i => Console.WriteLine("Do : {0}", i))
途中に処理を挟む

*.Subscribe(i => Console.WriteLine("OnNext : {0}", i));
購読(購読しないとOnNextをしても値が流れないね)

*subject.OnNext(1);
値の発行

*Observable.Range(1, 5)
正常終了する場合
実行結果：1, 2, 3, 4, 5, Completed

*Observable.Range(1, 5)
途中で例外が発生する場合
実行結果：1, 2, Error


*a[i] = i;
a[i]に対する任意の処理

*[Benchmark]
方法1

*[Benchmark]
方法2

*[Benchmark]
方法3

*[Benchmark]
方法4


*[TestClass]
参考：https:www.gesource.jp/weblog/?p=7742

*ret = cls1.AddPublic(1, 2);
publicなメソッドのテスト

*var pbObj = new PrivateObject(cls1);
private、internalなメソッドのテスト

*PrivateType privateType = new PrivateType(typeof(Class1));
private static、internal staticなメソッドのテスト

*var clssub = new Class1Sub();
子クラスから見た親クラスのprivateメソッドをテスト

*}
子クラスから見た親クラスのprivate staticメソッドは、
親クラスのprivate staticテストと同じ。


*using System.Threading;*namespace Sample {class C {static void Main(){Thread thread = new Thread(ThreadWork);thread.Start();Console.WriteLine("キー入力があるまでスレッドが動き続ける");Console.ReadKey();// スレッドを止める(スレッドが止まっている可能性がある場合は// IsAliveプロパティがtrueか確かめる)thread.Abort();}// スレッドを用いて動かすメソッドstatic void ThreadWork(){while(true) {Console.WriteLine("ThreadWork内の処理");Thread.Sleep(2000);}}}}
ThreadクラスはSystem.Threading名前空間に存在

*thread.Abort();
スレッドを止める(スレッドが止まっている可能性がある場合は
IsAliveプロパティがtrueか確かめる)

*static void ThreadWork()*{while(true) {Console.WriteLine("ThreadWork内の処理");Thread.Sleep(2000);}}
スレッドを用いて動かすメソッド

*using System.Threading.Tasks;*namespace Sample {class C {static void Main(){Task task = new Task(ThreadWork);task.Start();Console.WriteLine("キー入力があるまでスレッドが動き続ける");Console.ReadKey();// Mainメソッドが終了すると自動でTaskが終了する}// スレッドを用いて動かすメソッドstatic void ThreadWork(){while(true) {Console.WriteLine("ThreadWork内の処理");Thread.Sleep(2000);}}}}
TaskクラスはSystem.Threading.Tasks名前空間に存在

*}
Mainメソッドが終了すると自動でTaskが終了する

*static void ThreadWork()*{while(true) {Console.WriteLine("ThreadWork内の処理");Thread.Sleep(2000);}}
スレッドを用いて動かすメソッド

*using System.Threading.Tasks;*namespace Sample {class C {static void Main(){// Task.Run(Action)とTask.Run(Func<Task>)で競合が起こるので、明示的にActionにするTask.Run((Action)ThreadWork);Console.WriteLine("キー入力があるまでスレッドが動き続ける");Console.ReadKey();}// スレッドを用いて動かすメソッドstatic void ThreadWork(){while(true) {Console.WriteLine("ThreadWork内の処理");Thread.Sleep(2000);}}}}
TaskクラスはSystem.Threading.Tasks名前空間に存在

*Task.Run((Action)ThreadWork);
Task.Run(Action)とTask.Run(Func<Task>)で競合が起こるので、明示的にActionにする

*static void ThreadWork()*{while(true) {Console.WriteLine("ThreadWork内の処理");Thread.Sleep(2000);}}
スレッドを用いて動かすメソッド

*using System.Threading.Tasks;*namespace Sample {class C {static void Main(){Parallel.For(0, 10, id => {Console.WriteLine($"並列で動作している部分\t id = {id}");});Console.WriteLine("並列処理終了!");}}}
ParallelクラスはSystem.Threading.Tasks名前空間に存在

*using System.Threading.Tasks;*namespace Sample {class C {static void Main(){int[] arr = { 10, 20, 30, 40, 50, 60, 70, 80, 90 };Parallel.ForEach(arr, item => {Console.WriteLine($"並列で動作している部分\t item = {item}");});Console.WriteLine("並列処理終了!");}}}
ParallelクラスはSystem.Threading.Tasks名前空間に存在


*}
対象のメソッド呼び出し


*if (lang.ToLower() == "ja")
Display only Japanese tweets


*[ContentProperty("Key")]
Keyを規定のプロパティに指定

*return AppResources.ResourceManager.GetString(Key, AppResources.Culture) ?? Key;
Keyプロパティに指定されたキーをもとにリソースから文字列を取得

*AppResources.Culture =  new CultureInfo("ja-JP");
日本語を指定する場合

*AppResources.Culture =  new CultureInfo("en-US");
英語を指定する場合

*public partial class App : Application*{public static void SetCulture(CultureInfo culture){AppResources.Culture = culture;}...}
共通プロジェクトのAppクラスでAppResoucesのカルチャを設定するメソッドを追加

*var androidLocale = Java.Util.Locale.Default;
Androidプラットフォームでの言語を取得

*string netLanguage = androidLocale.ToString().Replace("_", "-");
ja_JP を ja-JP に変換

*var culture = (netLanguage == "ja" || netLanguage == "ja-JP")? new System.Globalization.CultureInfo("ja-JP"): new System.Globalization.CultureInfo("en-US");
プラットフォームが日本語ならばカルチャを日本語、それ以外ならカルチャを英語とする

*App.SetCulture(culture);
カルチャを設定する


*}
Console.WriteLine("マウスのXBUTTON2が押されています。");

*this.Visible = true;
フォームを表示する

*new Thread(new ThreadStart(GetMouseButton)).Start();
フォームをアクティブにする


*System.Console.WriteLine("処理開始");
処理開始

*System.Console.WriteLine("更新開始");
更新開始

*System.Console.WriteLine("更新終了");
更新終了

*Working = false;
処理終了とする

*static void Main(string[] args)
手書き--ここから
args[0]:dotファイル（トレース結果）出力先

*public void DoJob()*{Trace.TraceNode("node1", true);Trace.TraceNode("node2");var t = Task.Run(async () =>{//稼動中繰り返すTrace.TraceNode("node3");while (Working){//値を判断Trace.TraceNode("node3");Trace.TraceNode("node4");switch (Value)//省略}public FlowTrace Trace = new FlowTrace();public void InitGraph(){Trace.AddFunc(0);Trace.AddNode(0, "node1", "ellipse", "DoJob\nstart");//省略Trace.AddEdge("node1", "node2", "");Trace.AddEdge("node4", "node5", "case 0:");//省略},,,using System.Linq;using Microsoft.CodeAnalysis.CSharp;using Microsoft.CodeAnalysis.CSharp.Syntax;using System.Text;using System.Text.RegularExpressions;using System.Collections.Generic;using Microsoft.CodeAnalysis;using System.IO;namespace Flow{public class FlowGraph{private static int WORD_WRAP_LENGTH = 40;private List<GraphEdge> EdgeList = new List<GraphEdge>();private Dictionary<SyntaxNode, GraphNode> NodeMap = new System.Collections.Generic.Dictionary<SyntaxNode, GraphNode>();private IEnumerable<BaseMethodDeclarationSyntax> memberDeclarations;private string _sourceCode;private int _seq = 0;//args[0]:対象c#ソースファイル//args[1]:dotファイル（静的フローチャート）出力先//args[2]:変換後ソース（トレース用コード）出力先static void Main(string[] args){string sourceCode = File.ReadAllText(args[0]);FlowGraph graph = new FlowGraph(sourceCode);//静的フロー出力graph.WriteDot(args[1]);//ソースコード変換graph.ConvSource(args[2]);}public FlowGraph(string sourceCode){_sourceCode = sourceCode;var tree = CSharpSyntaxTree.ParseText(_sourceCode);memberDeclarations = tree.GetRoot().DescendantNodes().OfType<BaseMethodDeclarationSyntax>();if(memberDeclarations.Count() == 0){return;}foreach (var funcRoot in memberDeclarations){SyntaxVisitor ast = new SyntaxVisitor(this);if (funcRoot is MethodDeclarationSyntax || funcRoot is ConstructorDeclarationSyntax)ast.VisitRootSyntax(funcRoot);}}//トレース用のソースコード出力public void ConvSource(string outFile){var result = _sourceCode;var keys = new List<SyntaxNode>(NodeMap.Keys).OrderByDescending(x => x.Span.Start);AddInitStatements(ref result, memberDeclarations.Last());foreach (var sNode in keys){AddTraceStatement(ref result, NodeMap[sNode], sNode);}using (System.IO.StreamWriter writer = new System.IO.StreamWriter(outFile, false)){writer.Write(result);}}//ノード、エッジ登録関数部作成private void AddInitStatements(ref string result, SyntaxNode lastMetod){var clustermap = new Dictionary<SyntaxNode, int>();int ipoint = lastMetod.FullSpan.End;string spaces = new string(' ', lastMetod.GetLocation().GetLineSpan().StartLinePosition.Character);var sb = new StringBuilder();sb.Append("\r\n" + spaces + "public FlowTrace Trace = new FlowTrace();\r\n");sb.Append(spaces + "public void InitGraph()\r\n");sb.Append(spaces + "{\r\n");//クラスタIDを追加するstring spaces2 = new string(' ', spaces.Length + 4);int cluster = 0;foreach (var funcRoot in memberDeclarations){sb.Append(spaces2 + "Trace.AddFunc(" + cluster + ");\r\n");foreach (SyntaxNode sNode in NodeMap.Keys){if (sNode == funcRoot || sNode.Ancestors(true).Contains(funcRoot)){var gNode = NodeMap[sNode];string isFunc = sNode == funcRoot ? "true" : "false";string label = gNode.LabelName.Replace("\r", "").Replace("\n", "\\n").Replace("\"", "\\\"");sb.Append(spaces2 + "Trace.AddNode(" + cluster + ", \"" + gNode.NodeId + "\", \"" + gNode.NodeShape + "\", \"" + label + "\"" + ");\r\n");}}cluster++;}foreach (GraphEdge gEdge in EdgeList){string label = gEdge.CenterLabel.Replace("\r", "").Replace("\n", "\\n").Replace("\"", "\\\"");sb.Append(spaces2 + "Trace.AddEdge(\"" + gEdge.TailNode.NodeId + "\", \"" + gEdge.HeadNode.NodeId + "\", \"" + label + "\");\r\n");}sb.Append(spaces + "}\r\n");result = result.Insert(ipoint, sb.ToString());}//トレースコード埋め込みprivate void AddTraceStatement(ref string result, GraphNode gNode, SyntaxNode sNode){string traceStr = $"Trace.TraceNode(\"{gNode.NodeId}\");";var parent = sNode.Parent;if (sNode is BlockSyntax){return;}else if (sNode is MethodDeclarationSyntax ||sNode is ConstructorDeclarationSyntax ||sNode is LocalFunctionStatementSyntax){var property = sNode.GetType().GetProperty("Body");var block = (BlockSyntax)property.GetValue(sNode);string spaces = new string(' ', block.GetLocation().GetLineSpan().StartLinePosition.Character + 4);result = result.Insert(block.Span.Start + 1, "\r\n" + spaces + $"Trace.TraceNode(\"{gNode.NodeId}\", true);");return;}else if (parent is ElseClauseSyntax || parent is IfStatementSyntax){var property = sNode.Parent.GetType().GetProperty("Statement");var statement = property.GetValue(sNode.Parent);string spaces = new string(' ', parent.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(sNode.Span.End, "\r\n" + spaces + "}");string spaces2 = new string(' ', sNode.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(((StatementSyntax)statement).Span.Start, "{" + "\r\n" + spaces2 + traceStr + "\r\n" + spaces2);return;}else if (sNode is ExpressionSyntax expr){if (expr.Parent is DoStatementSyntax doSntax2){try{var lastStatement = doSntax2.Statement.ChildNodes().Last();string spaces = new string(' ', lastStatement.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(lastStatement.Span.End, "\r\n" + spaces + traceStr);}catch { }}return;}else if (sNode is DoStatementSyntax ||sNode is WhileStatementSyntax ||sNode is ForEachStatementSyntax ||sNode is ForStatementSyntax){var property = sNode.GetType().GetProperty("Statement");StatementSyntax statement = (StatementSyntax)property.GetValue(sNode);try{var firstStatement = statement.ChildNodes().First();string spaces = new string(' ', firstStatement.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(firstStatement.Span.Start, traceStr + "\r\n" + spaces);}catch { }}string leftPadding = new string(' ', sNode.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(sNode.Span.Start, traceStr + "\r\n" + leftPadding);}public GraphNode CreateGraphNode(SyntaxNode astNode, string labelName, string nodeShape)//以下省略}},,,using System.Collections.Generic;using System.Linq;namespace Flow{public class FlowTrace{private Dictionary<string, Node> nodeMap = new Dictionary<string, Node>();private Dictionary<(string tailId,string headId),Edge> edgeMap = new Dictionary<(string tailId, string headId), Edge>();private Dictionary<int, string> funcMap = new Dictionary<int, string>();public void AddNode(int funcId, string id, string shape, string label){nodeMap[id] = new Node {FuncId = funcId, Id = id, Shape = shape, Label = label };}public void AddEdge(string tailId,string headId,string label){edgeMap[(tailId, headId)] = new Edge {TailId = tailId,HeadId = headId , Label = label };}public void AddFunc(int id){funcMap[id] = string.Empty;}public void TraceNode(string nodeId, bool reset = false){if (nodeMap.ContainsKey(nodeId)){var node = nodeMap[nodeId];if(funcMap[node.FuncId] != nodeId){nodeMap[nodeId].PassCount++;if (reset){funcMap[node.FuncId] = string.Empty;}if (funcMap[node.FuncId] != string.Empty){var edgeKey = (funcMap[node.FuncId], nodeId);if (!edgeMap.ContainsKey(edgeKey)){edgeMap[edgeKey] = new Edge { TailId = funcMap[node.FuncId], HeadId = nodeId, Label = "Unintended", LineStyle = "dashed" };}edgeMap[edgeKey].PassCount++;}funcMap[node.FuncId] = nodeId;}}}public void WriteDot(string dotFilename){using (System.IO.StreamWriter writer = new System.IO.StreamWriter(dotFilename, false)){writer.WriteLine("digraph G{");writer.WriteLine("rankdir=TB;");writer.WriteLine("node[fontname = \"MS GOTHIC\"]");writer.WriteLine("edge[fontname = \"MS GOTHIC\"]");var clusters = new List<int> { -1 };clusters.InsertRange(0, funcMap.Keys);foreach (var cluster in clusters){if(cluster != -1){writer.WriteLine("subgraph cluster_" + cluster + "{");}foreach (Node node in nodeMap.Values.OrderBy((x) => x.Id)){if (node.FuncId == cluster){string label = node.Label.Replace("\n", "\\n").Replace("\"", "\\\"");string countStr = string.Empty;string colorStr = string.Empty;if (node.PassCount > 0){countStr = "(" + node.PassCount + ")";colorStr = ", color=\"red\"";}writer.WriteLine("\"" + node.Id + "\"" + " [shape = \"" + node.Shape + "\""+ colorStr + ", label = \"" + label + countStr + "\"]");}}if (cluster != -1){writer.WriteLine("}");}}foreach (Edge edge in edgeMap.Values.OrderBy((x) => x.TailId)){string countStr = string.Empty;string colorStr = string.Empty;if (edge.PassCount > 0){countStr = "(" + edge.PassCount + ")";colorStr = ", color=\"red\"";}writer.WriteLine("\"" + edge.TailId + "\"  -> \"" + edge.HeadId + "\""+ " [label =\"" + edge.Label + countStr + "\"" + colorStr + "]");}writer.WriteLine("}");}}private class Node{public int FuncId { get; set; }public string Id {get;set;}public string Shape { get; set; }public string Label { get; set; }public long PassCount { get; set; } = 0;}private class Edge{public string TailId { get; set; }public string HeadId { get; set; }public string Label { get; set; }public long PassCount { get; set; }public string LineStyle { get; set; } = string.Empty;}}},,,*Trace.TraceNode("node3");
稼動中繰り返す

*Trace.TraceNode("node3");
値を判断

*}
省略

*Trace.AddEdge("node1", "node2", "");
省略

*}
省略

*static void Main(string[] args)
args[0]:対象c#ソースファイル
args[1]:dotファイル（静的フローチャート）出力先
args[2]:変換後ソース（トレース用コード）出力先

*graph.WriteDot(args[1]);
静的フロー出力

*graph.ConvSource(args[2]);
ソースコード変換

*public void ConvSource(string outFile)*{var result = _sourceCode;var keys = new List<SyntaxNode>(NodeMap.Keys).OrderByDescending(x => x.Span.Start);AddInitStatements(ref result, memberDeclarations.Last());foreach (var sNode in keys){AddTraceStatement(ref result, NodeMap[sNode], sNode);}using (System.IO.StreamWriter writer = new System.IO.StreamWriter(outFile, false)){writer.Write(result);}}//ノード、エッジ登録関数部作成private void AddInitStatements(ref string result, SyntaxNode lastMetod){var clustermap = new Dictionary<SyntaxNode, int>();int ipoint = lastMetod.FullSpan.End;string spaces = new string(' ', lastMetod.GetLocation().GetLineSpan().StartLinePosition.Character);var sb = new StringBuilder();sb.Append("\r\n" + spaces + "public FlowTrace Trace = new FlowTrace();\r\n");sb.Append(spaces + "public void InitGraph()\r\n");sb.Append(spaces + "{\r\n");//クラスタIDを追加するstring spaces2 = new string(' ', spaces.Length + 4);int cluster = 0;foreach (var funcRoot in memberDeclarations){sb.Append(spaces2 + "Trace.AddFunc(" + cluster + ");\r\n");foreach (SyntaxNode sNode in NodeMap.Keys){if (sNode == funcRoot || sNode.Ancestors(true).Contains(funcRoot)){var gNode = NodeMap[sNode];string isFunc = sNode == funcRoot ? "true" : "false";string label = gNode.LabelName.Replace("\r", "").Replace("\n", "\\n").Replace("\"", "\\\"");sb.Append(spaces2 + "Trace.AddNode(" + cluster + ", \"" + gNode.NodeId + "\", \"" + gNode.NodeShape + "\", \"" + label + "\"" + ");\r\n");}}cluster++;}foreach (GraphEdge gEdge in EdgeList){string label = gEdge.CenterLabel.Replace("\r", "").Replace("\n", "\\n").Replace("\"", "\\\"");sb.Append(spaces2 + "Trace.AddEdge(\"" + gEdge.TailNode.NodeId + "\", \"" + gEdge.HeadNode.NodeId + "\", \"" + label + "\");\r\n");}sb.Append(spaces + "}\r\n");result = result.Insert(ipoint, sb.ToString());}//トレースコード埋め込みprivate void AddTraceStatement(ref string result, GraphNode gNode, SyntaxNode sNode){string traceStr = $"Trace.TraceNode(\"{gNode.NodeId}\");";var parent = sNode.Parent;if (sNode is BlockSyntax){return;}else if (sNode is MethodDeclarationSyntax ||sNode is ConstructorDeclarationSyntax ||sNode is LocalFunctionStatementSyntax){var property = sNode.GetType().GetProperty("Body");var block = (BlockSyntax)property.GetValue(sNode);string spaces = new string(' ', block.GetLocation().GetLineSpan().StartLinePosition.Character + 4);result = result.Insert(block.Span.Start + 1, "\r\n" + spaces + $"Trace.TraceNode(\"{gNode.NodeId}\", true);");return;}else if (parent is ElseClauseSyntax || parent is IfStatementSyntax){var property = sNode.Parent.GetType().GetProperty("Statement");var statement = property.GetValue(sNode.Parent);string spaces = new string(' ', parent.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(sNode.Span.End, "\r\n" + spaces + "}");string spaces2 = new string(' ', sNode.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(((StatementSyntax)statement).Span.Start, "{" + "\r\n" + spaces2 + traceStr + "\r\n" + spaces2);return;}else if (sNode is ExpressionSyntax expr){if (expr.Parent is DoStatementSyntax doSntax2){try{var lastStatement = doSntax2.Statement.ChildNodes().Last();string spaces = new string(' ', lastStatement.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(lastStatement.Span.End, "\r\n" + spaces + traceStr);}catch { }}return;}else if (sNode is DoStatementSyntax ||sNode is WhileStatementSyntax ||sNode is ForEachStatementSyntax ||sNode is ForStatementSyntax){var property = sNode.GetType().GetProperty("Statement");StatementSyntax statement = (StatementSyntax)property.GetValue(sNode);try{var firstStatement = statement.ChildNodes().First();string spaces = new string(' ', firstStatement.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(firstStatement.Span.Start, traceStr + "\r\n" + spaces);}catch { }}string leftPadding = new string(' ', sNode.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(sNode.Span.Start, traceStr + "\r\n" + leftPadding);}public GraphNode CreateGraphNode(SyntaxNode astNode, string labelName, string nodeShape)//以下省略}}
トレース用のソースコード出力

*private void AddInitStatements(ref string result, SyntaxNode lastMetod)*{var clustermap = new Dictionary<SyntaxNode, int>();int ipoint = lastMetod.FullSpan.End;string spaces = new string(' ', lastMetod.GetLocation().GetLineSpan().StartLinePosition.Character);var sb = new StringBuilder();sb.Append("\r\n" + spaces + "public FlowTrace Trace = new FlowTrace();\r\n");sb.Append(spaces + "public void InitGraph()\r\n");sb.Append(spaces + "{\r\n");//クラスタIDを追加するstring spaces2 = new string(' ', spaces.Length + 4);int cluster = 0;foreach (var funcRoot in memberDeclarations){sb.Append(spaces2 + "Trace.AddFunc(" + cluster + ");\r\n");foreach (SyntaxNode sNode in NodeMap.Keys){if (sNode == funcRoot || sNode.Ancestors(true).Contains(funcRoot)){var gNode = NodeMap[sNode];string isFunc = sNode == funcRoot ? "true" : "false";string label = gNode.LabelName.Replace("\r", "").Replace("\n", "\\n").Replace("\"", "\\\"");sb.Append(spaces2 + "Trace.AddNode(" + cluster + ", \"" + gNode.NodeId + "\", \"" + gNode.NodeShape + "\", \"" + label + "\"" + ");\r\n");}}cluster++;}foreach (GraphEdge gEdge in EdgeList){string label = gEdge.CenterLabel.Replace("\r", "").Replace("\n", "\\n").Replace("\"", "\\\"");sb.Append(spaces2 + "Trace.AddEdge(\"" + gEdge.TailNode.NodeId + "\", \"" + gEdge.HeadNode.NodeId + "\", \"" + label + "\");\r\n");}sb.Append(spaces + "}\r\n");result = result.Insert(ipoint, sb.ToString());}
ノード、エッジ登録関数部作成

*string spaces2 = new string(' ', spaces.Length + 4);
クラスタIDを追加する

*private void AddTraceStatement(ref string result, GraphNode gNode, SyntaxNode sNode)*{string traceStr = $"Trace.TraceNode(\"{gNode.NodeId}\");";var parent = sNode.Parent;if (sNode is BlockSyntax){return;}else if (sNode is MethodDeclarationSyntax ||sNode is ConstructorDeclarationSyntax ||sNode is LocalFunctionStatementSyntax){var property = sNode.GetType().GetProperty("Body");var block = (BlockSyntax)property.GetValue(sNode);string spaces = new string(' ', block.GetLocation().GetLineSpan().StartLinePosition.Character + 4);result = result.Insert(block.Span.Start + 1, "\r\n" + spaces + $"Trace.TraceNode(\"{gNode.NodeId}\", true);");return;}else if (parent is ElseClauseSyntax || parent is IfStatementSyntax){var property = sNode.Parent.GetType().GetProperty("Statement");var statement = property.GetValue(sNode.Parent);string spaces = new string(' ', parent.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(sNode.Span.End, "\r\n" + spaces + "}");string spaces2 = new string(' ', sNode.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(((StatementSyntax)statement).Span.Start, "{" + "\r\n" + spaces2 + traceStr + "\r\n" + spaces2);return;}else if (sNode is ExpressionSyntax expr){if (expr.Parent is DoStatementSyntax doSntax2){try{var lastStatement = doSntax2.Statement.ChildNodes().Last();string spaces = new string(' ', lastStatement.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(lastStatement.Span.End, "\r\n" + spaces + traceStr);}catch { }}return;}else if (sNode is DoStatementSyntax ||sNode is WhileStatementSyntax ||sNode is ForEachStatementSyntax ||sNode is ForStatementSyntax){var property = sNode.GetType().GetProperty("Statement");StatementSyntax statement = (StatementSyntax)property.GetValue(sNode);try{var firstStatement = statement.ChildNodes().First();string spaces = new string(' ', firstStatement.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(firstStatement.Span.Start, traceStr + "\r\n" + spaces);}catch { }}string leftPadding = new string(' ', sNode.GetLocation().GetLineSpan().StartLinePosition.Character);result = result.Insert(sNode.Span.Start, traceStr + "\r\n" + leftPadding);}
トレースコード埋め込み

*}
以下省略


*context.Users.Add(new User { Name = "Elizabeth", Gender = GenderEnum.Female });
Femaleは'F'として登録される

*using (var context = new TestDbContext(options)){foreach (var user in context.Users){Console.WriteLine($"Id:{user.Id}");
取得


*_listView0.ItemsSource =wSqliteControl.GetItems(0);
リストビューのデータを更新


*Add1(2).Should().Be(expValue);
ここで失敗する。


*jcr.externalIdFieldName = "Id";
外部 ID 項目　更新挿入操作で必須

*var res = HTTPAccess.GetResponse(method, url, body, contentType, header);
HTTPリクエスト(具体的な実装は割愛)

*JobInfo jobInfo = ParseJson(res.body);
パースしてジョブIDを取得(具体的な実装は割愛)

*string url = DOMAIN + "/services/data/v46.0/jobs/ingest/" + this.jobId + "/batches";
エンドポイント

*string method = "PUT";
メソッド

*string header = "Authorization: Bearer " + loginResult.sessionId;
リクエストヘッダ

*string body = "Id,LastName,FirstName,AccountId" + "\r\n";
リクエストボディ
csv形式で入力　 ジョブ作成時に指定した外部 ID 項目は必須

*var res = HTTPAccess.GetResponse(method, url, body, contentType, header);
HTTPリクエスト(具体的な実装は割愛)

*return (res.StatusCode == 201);
成功時は201

*string url = DOMAIN + "/services/data/v46.0/jobs/ingest/" + this.jobId;
エンドポイント

*string method = "PATCH";
メソッド

*string header = "Authorization: Bearer " + loginResult.sessionId;
リクエストヘッダ

*// state を更新する*string body = "{\"state\":\"" + state + "\"}";
リクエストボディ

*string body = "{\"state\":\"" + state + "\"}";
state を更新する

*var res = HTTPAccess.GetResponse(method, url, body, contentType, header);
HTTPリクエスト(具体的な実装は割愛)

*string url = DOMAIN + "/services/data/v46.0/jobs/ingest/" + this.jobId;
エンドポイント

*string method = "GET";
メソッド

*string header = "Authorization: Bearer " + loginResult.sessionId;
リクエストヘッダ

*var res = HTTPAccess.GetResponse(method, url, null, null, header);
HTTPリクエスト(具体的な実装は割愛)

*JobInfo jobInfo = ParseJson(res.body);
パースしてジョブIDを取得(具体的な実装は割愛)

*break;
完了または失敗になるまで監視する

*string url = DOMAIN + "/services/data/v46.0/jobs/ingest/" + this.jobId + "/successfulResults";
エンドポイント
成功結果取得

*string method = "GET";
失敗結果取得
string url = DOMAIN + "/services/data/v46.0/jobs/ingest/" + this.jobId + "/failedResults";
メソッド

*string header = "Authorization: Bearer " + loginResult.sessionId;
リクエストヘッダ

*var res = HTTPAccess.GetResponse(method, url, null, null, header);
HTTPリクエスト(具体的な実装は割愛)

*string url = DOMAIN + "/services/data";
エンドポイント

*string method = "GET";
メソッド

*var res = HTTPAccess.GetResponse(method, url, null, null, null);
HTTPリクエスト(具体的な実装は割愛)

*this.apiVersion = apis[apis.Count - 1].version;
必要あればソート
apis.Sort((a, b) => string.Compare(a.version, b.version));
最新のバージョンを設定


*[System.Serializable]
SE,BGMの管理用コンテナクラス.

*[SerializeField] AudioClip soundData;
保持するデータ.

*[CustomEditor(typeof(SampleContainer))]
SampleContainerのインスペクタ拡張.

*public override void OnInspectorGUI()*{var data = target as SampleContainer;data.soundData = (AudioClip)EditorGUILayout.ObjectField("AudioClip", data.soundData, typeof(AudioClip));if (GUILayout.Button("PlayClip"))this.PlayClip(data.soundData);if (GUILayout.Button("StopClip"))this.StopClip(data.soundData);}
インスペクタ描画.

*void PlayClip(AudioClip clip)
エディタ上でのサウンド再生.

*void StopClip(AudioClip clip)
エディタ上でのサウンドを停止する.


*public InteractionEvents interactionEvents;
これはOnExecuteでセットしてね

*GraphicsCoordinateSet gcs = ig.GraphicsDataSets.CreateCoordinateSet(0);
点に座標を設定する

*pg.PointRenderStyle = PointRenderStyleEnum.kEndPointStyle;
点の種類を選ぶ

*ig.UpdateOverlayGraphics(View);
常に前面に表示
pg.BurnThrough = true;   無視される。Inventorのbug?
表示を更新。これをしないと、表示されない。


*cam.transform.parent = gameObject.transform;
Cameraの親オブジェクトはCarとする


*void Start () {}
Use this for initialization

*void Update () {pos = TrackPad.GetLastAxis(SteamVR_Input_Sources.RightHand);Debug.Log(pos.x +" " + pos.y);}
Update is called once per frame

*void Start () {}
Use this for initialization

*void Update () {pos = TrackPad.GetLastAxis(SteamVR_Input_Sources.RightHand);transform.localPosition = new Vector3( pos.x * 0.1f,0, pos.y * 0.1f);}
Update is called once per frame

*void Start () {}
Use this for initialization

*void Update () {pos = TrackPad.GetLastAxis(SteamVR_Input_Sources.RightHand);transform.localPosition = new Vector3( pos.x * 0.1f,0, pos.y * 0.1f);r = Mathf.Sqrt(pos.x* pos.x + pos.y* pos.y);sita = Mathf.Atan2(pos.y, pos.x) / Mathf.PI * 180;Debug.Log(r +" "+ sita );}
Update is called once per frame


*public GameObject innerBox;
文字たちを格納するための親オブジェクト（空オブジェクト）

*GameObject word = (GameObject)Resources.Load("Word");
プレハブ生成(この時点では、まだ、空のText)

*newObj.GetComponent<TextMesh>().text = speakText.Substring(i-1,1);
生成された各オブジェクトに文字を1文字ずつ入れる

*newObj.name = "word" + "(" + speakText.Substring(i-1,1) + ")";
生成された各オブジェクトの名前を変更

*newObj.transform.parent = innerBox.transform;*newObj.transform.localPosition = new Vector3(160.0f*(i-1), -151.0f, 0.0f);
各文字の位置を調整


*string sresult = client.DownloadString("https:
slack.comapirtm.connect");


*var z = JsonUtility.FromJson<ItemDict> (y);
デシリアライズ


*LineRenderer lineRenderer;
1.変数を宣言

*lineRenderer = this.gameObject.GetComponent<LineRenderer>();
2.GetComponentします

*gazeIcon = transform.Find("PointerIcon");*progressIndicator = transform.GetComponent<OVRProgressIndicator>();
3.PointerIconはポインターアイコンのオブジェクト名が入る

*lineRenderer.SetPosition(0, startPointObj.transform.position);*lineRenderer.SetPosition(1, endPointObj.transform.position);
4.レーザーの位置を決定

*lineRenderer.enabled = false;
5.消す

*lineRenderer.enabled = true;
6.出す


*vm = (ViewModels.MainWindowViewModel)DataContext;
ViewModelへの参照記憶

*vm.UpdateView = UpdataView;
View側処理をViewModelに設定

*UpdateView();
Viewを更新


*BitConverter.GetBytes( (Int32)1000 ).CopyTo( tcp_keepalive, 8 );
interval.(ms)

*clientSocket.IOControl( IOControlCode.KeepAliveValues, tcp_keepalive, null );
keep-aliveのパラメータ設定


*Negative:
インデントを1段階上げる


*static async Task Main(string[] args)
MagicOnion を await で起動するため、非同期 Main で定義
await でサーバーを起動しないと、即 Main 関数が終了してしまうため

*GrpcEnvironment.SetLogger(new Grpc.Core.Logging.ConsoleLogger());
gRPC のログをコンソールに出力するよう設定

*await MagicOnionHost.CreateDefaultBuilder()
isReturnExceptionStackTraceInErrorDetail に true を設定して
エラー発生時のメッセージがコンソールに出力されるようにする
MagicOnion サーバーが localhost:12345 で Listen する

*using UnityEngine;
MessagePack.UnityShims を利用することで、
Unity の Vector3 や Quaternion を通信でやり取りすることが可能になる

*public interface IGamingHubReceiver
サーバで gRPC が実行された際に、
実行結果をクライアントに返すためのコールバック関数を定義する

*public interface IGamingHub : IStreamingHub<IGamingHub, IGamingHubReceiver>*{Task<Player[]> JoinAsync(string roomName, string userName, Vector3 position, Quaternion rotation);Task LeaveAsync();Task MoveAsync(Vector3 position, Quaternion rotation);}
クライアントがサーバ側で gRPC 実行可能な関数を定義する

*[MessagePackObject]
gRPC 通信で独自に定義したメッセージ Player を扱うための宣言
Player はプレイヤー名, 位置(Vector3), 回転(Quaternion) の変数を所持している

*public class GamingHub : StreamingHubBase<IGamingHub, IGamingHubReceiver>, IGamingHub*{// IGroup を使用することで同一のグループに所属している他ユーザ全員に対して// 一斉にブロードキャスト送信を行うことが出来る (オンラインゲームで言うルームの概念)IGroup room;// ルーム内での自分の情報 (IGamingHub.cs で定義した Player の情報)Player self;// ルームに入室しているユーザ全員（自分も含む）の情報を保持して扱うための変数IInMemoryStorage<Player> storage;// 指定したルームに入室するための関数// 入室するルーム名及び、ユーザ自身の情報(ユーザ名,位置(Vector3),回転(Quaternion)) を引数に取るpublic async Task<Player[]> JoinAsync(string roomName, string userName, Vector3 position, Quaternion rotation){self = new Player() { Name = userName, Position = position, Rotation = rotation };// ルームにユーザが入室する(room, storage) = await Group.AddAsync(roomName, self);// ルームに入室している他ユーザ全員に// 入室したユーザの情報をブロードキャスト送信するBroadcast(room).OnJoin(self);// ルームに入室している他ユーザ全員の情報を配列で取得するreturn storage.AllValues.ToArray();}// ユーザがルームから退出するpublic async Task LeaveAsync(){await room.RemoveAsync(this.Context);// ルームに入室している他ユーザ全員に// ルームから退出したことをユーザの情報と共にブロードキャスト送信するBroadcast(room).OnLeave(self);}// ユーザがルームの中で動くpublic async Task MoveAsync(Vector3 position, Quaternion rotation){// 動いたユーザの位置(xyz) と回転(quaternion) を設定するself.Position = position;self.Rotation = rotation;// 動いたユーザの最新の位置(Vector3)と回転(Quaternion) を// ルームに入室している他ユーザ全員にユーザの最新情報 (Player) をブロードキャスト送信するBroadcast(room).OnMove(self);}}
IGamingHub の実装が記述された GamingHub クラス

*IGroup room;
IGroup を使用することで同一のグループに所属している他ユーザ全員に対して
一斉にブロードキャスト送信を行うことが出来る (オンラインゲームで言うルームの概念)

*Player self;
ルーム内での自分の情報 (IGamingHub.cs で定義した Player の情報)

*IInMemoryStorage<Player> storage;
ルームに入室しているユーザ全員（自分も含む）の情報を保持して扱うための変数

*public async Task<Player[]> JoinAsync(string roomName, string userName, Vector3 position, Quaternion rotation)
指定したルームに入室するための関数
入室するルーム名及び、ユーザ自身の情報(ユーザ名,位置(Vector3),回転(Quaternion)) を引数に取る

*(room, storage) = await Group.AddAsync(roomName, self);
ルームにユーザが入室する

*Broadcast(room).OnJoin(self);
ルームに入室している他ユーザ全員に
入室したユーザの情報をブロードキャスト送信する

*return storage.AllValues.ToArray();
ルームに入室している他ユーザ全員の情報を配列で取得する

*public async Task LeaveAsync()*{await room.RemoveAsync(this.Context);// ルームに入室している他ユーザ全員に// ルームから退出したことをユーザの情報と共にブロードキャスト送信するBroadcast(room).OnLeave(self);}
ユーザがルームから退出する

*Broadcast(room).OnLeave(self);
ルームに入室している他ユーザ全員に
ルームから退出したことをユーザの情報と共にブロードキャスト送信する

*public async Task MoveAsync(Vector3 position, Quaternion rotation)*{// 動いたユーザの位置(xyz) と回転(quaternion) を設定するself.Position = position;self.Rotation = rotation;// 動いたユーザの最新の位置(Vector3)と回転(Quaternion) を// ルームに入室している他ユーザ全員にユーザの最新情報 (Player) をブロードキャスト送信するBroadcast(room).OnMove(self);}
ユーザがルームの中で動く

*self.Position = position;
動いたユーザの位置(xyz) と回転(quaternion) を設定する

*Broadcast(room).OnMove(self);
動いたユーザの最新の位置(Vector3)と回転(Quaternion) を
ルームに入室している他ユーザ全員にユーザの最新情報 (Player) をブロードキャスト送信する

*public class GamingHubClient : IGamingHubReceiver*{// 部屋に参加しているユーザ全員の GameObject (アバター)を保持するDictionary<string, GameObject> players = new Dictionary<string, GameObject>();// サーバ側の関数を実行するための変数IGamingHub client;// 指定したルームに入室するための関数// StreamingHubClient で使用する gRPC チャネル及び、参加したい部屋名、使用するユーザ名を引数に指定するpublic async Task<GameObject> ConnectAsync(Channel grpcChannel, string roomName, string playerName){// サーバ側の関数を実行するための StreamingHubClient を生成するclient = StreamingHubClient.Connect<IGamingHub, IGamingHubReceiver>(grpcChannel, this);// JoinAsync 関数を実行して部屋に入室すると同時に、// 既に入室済みのユーザ全員の情報を配列で取得するvar roomPlayers = await client.JoinAsync(roomName, playerName, Vector3.zero, Quaternion.identity);// 自ユーザ以外を OnJoin 関数に渡して、// this.players に部屋の他ユーザ全員の情報をセットする// 自ユーザの情報は await で JoinAsync を実行した段階で、// OnJoin がコールバックで呼ばれているためセット済みの状態となっているforeach (var player in roomPlayers){if (player.Name != playerName){(this as IGamingHubReceiver).OnJoin(player);}}// 自ユーザの情報を返却するreturn players[playerName];}// 部屋から退出し、部屋の他ユーザ全員に退出したことをブロードキャスト送信するpublic Task LeaveAsync(){return client.LeaveAsync();}// 自ユーザの位置(Vector3) と回転(Quaternion) を更新すると同時に// 部屋の他ユーザ全員にブロードキャスト送信するpublic Task MoveAsync(Vector3 position, Quaternion rotation){return client.MoveAsync(position, rotation);}// StreamingHubClient の解放処理// gRPC のチャネルを破棄する前に実行する必要があるpublic Task DisposeAsync(){return client.DisposeAsync();}// 部屋に新しいユーザが入室したときに呼び出される関数// または ConnectAsync 関数を実行したときに呼び出される関数void IGamingHubReceiver.OnJoin(Player player){// ユーザの GameObject (アバター)を Player 情報を元に生成して// this.players に player.Name をキーにして保持する// 部屋に入室しているユーザの数だけワールド上にキューブを出現するvar cube = GameObject.CreatePrimitive(PrimitiveType.Cube);cube.name = player.Name;cube.transform.SetPositionAndRotation(player.Position, player.Rotation);players[player.Name] = cube;}// 他ユーザが部屋から退出した際に呼び出される関数void IGamingHubReceiver.OnLeave(Player player){// this.players に保持していた GameObject (アバター)を破棄する// ワールド上から該当する GameObject (アバター)のキューブが消滅するif (players.TryGetValue(player.Name, out var cube)){GameObject.Destroy(cube);}}// 部屋の中でいずれかのユーザが動いたときに呼び出される関数void IGamingHubReceiver.OnMove(Player player){// 引数の player の Name を元に this.players 内から GameObject を取得する// ワールド上の該当する GameObject (アバター)の位置(Vector3)と回転(Quaternion) の値を最新のものに更新するif (players.TryGetValue(player.Name, out var cube)){cube.transform.SetPositionAndRotation(player.Position, player.Rotation);}}}
IGamingHubReceiver の実装が記述された GamingHubClient クラス

*Dictionary<string, GameObject> players = new Dictionary<string, GameObject>();
部屋に参加しているユーザ全員の GameObject (アバター)を保持する

*IGamingHub client;
サーバ側の関数を実行するための変数

*public async Task<GameObject> ConnectAsync(Channel grpcChannel, string roomName, string playerName)
指定したルームに入室するための関数
StreamingHubClient で使用する gRPC チャネル及び、参加したい部屋名、使用するユーザ名を引数に指定する

*client = StreamingHubClient.Connect<IGamingHub, IGamingHubReceiver>(grpcChannel, this);
サーバ側の関数を実行するための StreamingHubClient を生成する

*var roomPlayers = await client.JoinAsync(roomName, playerName, Vector3.zero, Quaternion.identity);
JoinAsync 関数を実行して部屋に入室すると同時に、
既に入室済みのユーザ全員の情報を配列で取得する

*foreach (var player in roomPlayers)
自ユーザ以外を OnJoin 関数に渡して、
this.players に部屋の他ユーザ全員の情報をセットする
自ユーザの情報は await で JoinAsync を実行した段階で、
OnJoin がコールバックで呼ばれているためセット済みの状態となっている

*return players[playerName];
自ユーザの情報を返却する

*public Task LeaveAsync()*{return client.LeaveAsync();}
部屋から退出し、部屋の他ユーザ全員に退出したことをブロードキャスト送信する

*public Task MoveAsync(Vector3 position, Quaternion rotation)
自ユーザの位置(Vector3) と回転(Quaternion) を更新すると同時に
部屋の他ユーザ全員にブロードキャスト送信する

*public Task DisposeAsync()
StreamingHubClient の解放処理
gRPC のチャネルを破棄する前に実行する必要がある

*void IGamingHubReceiver.OnJoin(Player player)
部屋に新しいユーザが入室したときに呼び出される関数
または ConnectAsync 関数を実行したときに呼び出される関数

*var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
ユーザの GameObject (アバター)を Player 情報を元に生成して
this.players に player.Name をキーにして保持する
部屋に入室しているユーザの数だけワールド上にキューブを出現する

*void IGamingHubReceiver.OnLeave(Player player)*{// this.players に保持していた GameObject (アバター)を破棄する// ワールド上から該当する GameObject (アバター)のキューブが消滅するif (players.TryGetValue(player.Name, out var cube)){GameObject.Destroy(cube);}}
他ユーザが部屋から退出した際に呼び出される関数

*if (players.TryGetValue(player.Name, out var cube))
this.players に保持していた GameObject (アバター)を破棄する
ワールド上から該当する GameObject (アバター)のキューブが消滅する

*void IGamingHubReceiver.OnMove(Player player)*{// 引数の player の Name を元に this.players 内から GameObject を取得する// ワールド上の該当する GameObject (アバター)の位置(Vector3)と回転(Quaternion) の値を最新のものに更新するif (players.TryGetValue(player.Name, out var cube)){cube.transform.SetPositionAndRotation(player.Position, player.Rotation);}}
部屋の中でいずれかのユーザが動いたときに呼び出される関数

*if (players.TryGetValue(player.Name, out var cube))
引数の player の Name を元に this.players 内から GameObject を取得する
ワールド上の該当する GameObject (アバター)の位置(Vector3)と回転(Quaternion) の値を最新のものに更新する

*[SerializeField]
プレイヤーの Transform (今回はメインカメラの Transform を指定)

*[SerializeField]
部屋に参加するときに使用するユーザ名 (何でも設定可)

*(StreamingHub クライアント同士で交流したい場合は、各クライアントで同一の名前を設定する必要がある)
参加したい部屋のルーム名

*[SerializeField]
(StreamingHub クライアント同士で交流したい場合は、
各クライアントで同一の名前を設定する必要がある)

*private Channel channel = new Channel("localhost", 12345, ChannelCredentials.Insecure);
StreamingHub クライアントで使用する gRPC チャネルを生成

*private GamingHubClient client = new GamingHubClient();
StreamingHub サーバと通信を行うためのクライアント生成

*await this.client.ConnectAsync(this.channel, this.m_RoomName, this.m_UserName);
ゲーム起動時に設定した部屋名のルームに設定したユーザ名で入室する。

*void Update()*{// 毎フレームプレイヤーの位置(Vector3) と回転(Quaternion) を更新し、// ルームに入室している他ユーザ全員にブロードキャスト送信するclient.MoveAsync(m_PlayerTransform.position, m_PlayerTransform.rotation);}
Update is called once per frame

*client.MoveAsync(m_PlayerTransform.position, m_PlayerTransform.rotation);
毎フレームプレイヤーの位置(Vector3) と回転(Quaternion) を更新し、
ルームに入室している他ユーザ全員にブロードキャスト送信する

*await this.client.LeaveAsync();
GameClient が破棄される際の StreamingHub クライアント及び gRPC チャネルの解放処理


*HogePool.Instance.Catch(this);
返却するクラスのインタンスを渡す


*86,
cols


*double dE = Y - a_sub_b;
value after differentiation of squared error because calculation is omitted

*using (StreamWriter sw = new StreamWriter(path, true, Encoding.Unicode)){sw.Write(a.ToString() + "," + b.ToString() + "," + a_sub_b.ToString() + "," +w[0].ToString() + "," + w[1].ToString() + "," +Y.ToString() + "," + dE.ToString() +Environment.NewLine);
record

*using (StreamWriter sw = new StreamWriter(path, true, Encoding.Unicode)){sw.Write(",,," +w[0].ToString() + "," + w[1].ToString() + "," +"," +Environment.NewLine);
final record


*public class SQLServer : Product*{public override void Connect(){Console.WriteLine("SQLServerに繋ぎます～！");}}
ConcreteProduct

*public class PostgreSQL : Product*{public override void Connect(){Console.WriteLine("PostgreSQLに繋ぎます～！");}}
ConcreteProduct

*public class DBCreator : Creator*{private readonly string _name;public DBCreator(string name) => _name = name;public override Product Create(){switch (_name){case "SQLServer":return new SQLServer();case "PostgreSQL":return new PostgreSQL();default:throw new Exception();}}}
ConcreteCreator


*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

*SystemSounds.Asterisk.Play();
ビープ音を鳴らします


*str = Regex.Replace(str, "^
[( |\t|)]*", "");


*var types = Assembly.GetAssembly(typeof(T)).GetTypes().Where(type =>
Tは抽象クラス

*var types = Assembly.GetAssembly(typeof(T)).GetTypes().Where(type =>
Tはインターフェース


*//clientReady.Set();*}, () =>{
This is called once the client has emitted the RTM start command

*}, () =>{
clientReady.Set();


*hoge = hoge.Split(" ".ToCharArray());
型 'string[]' を 'string' に暗黙的に変換できません

*,,,*public int itemType { get; set; }
私にとって１番しっくりきた書き方が見つかった！


*public string screenShotURL= "http:
www.my-server.comcgi-binscreenshot.pl";

*void Start () {StartCoroutine(UploadPNG());}
Use this for initialization

*WWWForm form = new WWWForm();*form.AddField("frameCount", Time.frameCount.ToString());
Create a Web Form


*string AmPmString = AMPM + "  " + dt.ToString("hh:mm") + Environment.NewLine + Mon+"." + dt.Day +" "+ dt.Year ;
12時間表示のstring型へ変換

*Qtext.color = new Color(1, 1, 1, a_color);
テキストの透明度を変更する


*string str = Properties.Settings.Default.MySetting1;
MySetting1はstring型

*Properties.Settings.Default.MySetting1 = 123;
MySetting2はint型

*private string MyString*{get { return Properties.Settings.Default.MySetting1; }set { Properties.Settings.Default.MySetting1 = value; }}
設定値を読み書きするためのプロパティを作成

*public MainWindow()*{InitializeComponent();txt1.Text = MyString;txt2.Text = MyInt.ToString();txt3.Text = MyBool.ToString();txt4.Text = MyDouble.ToString();}
起動時に設定の値を読み込み、画面表示

*private void bt1_Click(object sender, RoutedEventArgs e)*{MyString = txt1.Text;Properties.Settings.Default.Save();}
画面に入力した値を保存する


*return 1500;
女性の場合は割引金額


*WriteCombineFile( item, dst_path );
それを書き込む


*_WaveHdr.lpData = Marshal.AllocHGlobal(dataSize);
メモリを確保

*var cdwh = Marshal.SizeOf<NativeMethods.WaveHdr>();
バッファを準備・追加

*NativeMethods.waveInStart(_Hwi);
録音スタート

*WaveOpen?.Invoke(this, EventArgs.Empty);
オープン

*WaveClose?.Invoke(this, EventArgs.Empty);
クローズ

*OnWaveData();
WAVEデータ

*var headerSize = 44;
WAVEデータをコピーするバイト配列を作成

*Array.Copy(Encoding.ASCII.GetBytes("RIFF"), 0, waveData, 0, 4);
WAVEヘッダを設定

*NativeMethods.waveInUnprepareHeader(_Hwi, ref _WaveHdr, Marshal.SizeOf<NativeMethods.WaveHdr>());
バッファを開放

*Marshal.FreeHGlobal(_WaveHdr.lpData);
メモリ開放


*transaction.End();
実際の処理


*}
エラー処理


*interactionEvents = null;
必要なら、後処理



*ExitGames.Client.Photon.Hashtable roomHash;
ハッシュテーブルを宣言

*public void SetRoomProperty()*{// ハッシュに要素を追加(同じ名前があるとエラーになる)roomHash.Add("hoge", 0);// ハッシュに要素を追加、既に同じ名前のキーがあれば上書きroomHash["hoge"] = 1;// ルームにハッシュを送信するPhotonNetwork.room.SetCustomProperties(roomHash);}
ローカルで使っているハッシュをルームにセット

*roomHash.Add("hoge", 0);
ハッシュに要素を追加(同じ名前があるとエラーになる)

*roomHash["hoge"] = 1;
ハッシュに要素を追加、既に同じ名前のキーがあれば上書き

*PhotonNetwork.room.SetCustomProperties(roomHash);
ルームにハッシュを送信する

*public void OnPhotonCustomRoomPropertiesChanged(ExitGames.Client.Photon.Hashtable changedRoomHash)*{// 変更されたハッシュを受け取るroomHash = changedRoomHash;}
ルームのハッシュが送信されたら、送信されたハッシュが入ってくる(Photonの機能で戻り値の型、関数名、引数を一致させると勝手に呼ばれる)

*roomHash = changedRoomHash;
変更されたハッシュを受け取る

*private static ExitGames.Client.Photon.Hashtable roomHash;
ルームプロパティ用のハッシュ(Dictionary)

*roomHash = new ExitGames.Client.Photon.Hashtable();
ルームプロパティ用のこのプレイヤーのハッシュ(Dictionary)を生成

*public void OnPhotonCustomRoomPropertiesChanged(ExitGames.Client.Photon.Hashtable changedRoomHash)
ルームプロパティ ===========================================
RoomPropertyが更新された時に呼ばれる

*roomHash = changedRoomHash;
更新したプレイヤーが保持しているハッシュを入れる

*public static void SetRoomProperty<T>(string key, T value)
ルームプロパティのセット -----------------------------------
キーが既に存在していたら上書き

*PhotonNetwork.room.SetCustomProperties(roomHash);
自身のハッシュをネット上に送信

*public static void SetRoomPropertyArray<T>(string key, T[] value)*{// 要素数256を超える場合はここをshortなどに変更してくださいfor(byte i = 0; i < value.Length; i++){roomHash[key + i] = value[i];}// 自身のハッシュをネット上に送信PhotonNetwork.room.SetCustomProperties(roomHash);}
一次元配列用

*PhotonNetwork.room.SetCustomProperties(roomHash);
自身のハッシュをネット上に送信

*PhotonNetwork.room.SetCustomProperties(roomHash);
自身のハッシュをネット上に送信

*public static void SetRoomPropertyAdd<T>(string key, T value)*{roomHash.Add(key, value);// 自身のハッシュをネット上に送信PhotonNetwork.room.SetCustomProperties(roomHash);}
キーが既に存在している場合エラーが出る

*PhotonNetwork.room.SetCustomProperties(roomHash);
自身のハッシュをネット上に送信

*public static T GetRoomProperty<T>(string key)*{// outを受け取るための変数を用意object value;// 指定したキーがあれば返すif (roomHash.TryGetValue(key, out value)){// ボックス化解除return (T)value;}// 無かったらnullが返るreturn (T)value;}
ルームプロパティをゲット -----------------------------------

*object value;
outを受け取るための変数を用意

*return (T)value;
ボックス化解除

*return (T)value;
無かったらnullが返る

*public static T GetRoomPropertyArray<T>(string key, byte arrayNum)*{// outを受け取るための変数を用意object value;// 指定したキーがあれば返すif(roomHash.TryGetValue(key + arrayNum, out value)){// ボックス化解除return (T)value;}return (T)value;}
一次元配列用

*object value;
outを受け取るための変数を用意

*return (T)value;
ボックス化解除

*===============================================================hogeというキーで0をセットPhotonProperty.SetRoomProperty("hoge", 0);
値の設定方法

*PhotonProperty.SetRoomProperty("hoge", 0);
hogeというキーで0をセット

*int[] array = { 0, 1, 2, 3 };
一次元配列を作成

*PhotonProperty.SetRoomPropertyArray("array", array);
arrayというキーでarray配列をセット

*===============================================================戻り値の型をint型に指定してキーを入力int hoge = PhotonProperty.GetRoomProperty<int>("hoge");
値の取得方法

*int hoge = PhotonProperty.GetRoomProperty<int>("hoge");
戻り値の型をint型に指定してキーを入力

*int fuga = PhotonProperty.GetRoomPropertyArray<int>("array", 0);
戻り値の型をint型に指定してキーと取得したい要素番号を入力


*ApplicationDeployment deploy;
バージョンチェック＆更新処理

*bolCheckUpdate = deploy.CheckForUpdate();
アップデートがあるかチェック

*bool bolUpdate = deploy.Update();
アップデートがあるので、アップデート処理

*Application.Restart();
更新処理が終わったのでアプリケーションをリスタートする

*}
更新がエラーしたので任意の処理


*string dicPath = (true) ? "Dictionary1.xaml" : "Dictionary2.xaml";
条件により、読み込むDictionary.xamlを変える


*static Product karinto = new Product(123, "かりんとう", 180);
ここを変更した↓


*hWnd = NativeAPIUtility.GetForegroundWindow();
アクティブウィンドウのデバイスコンテキストを取得

*NativeAPIUtility.RECT rect = new NativeAPIUtility.RECT();
ウィンドウサイズを取得

*NativeAPIUtility.DwmGetWindowAttribute(hWnd, (int)NativeAPIUtility.DwmWindowAttribute.DWMWA_EXTENDED_FRAME_BOUNDS, out var bounds, Marshal.SizeOf(typeof(NativeAPIUtility.RECT)));
TODO:クラシックモードを考慮していないことに注意（Aaro有効を前提）

*Bitmap bmp = new Bitmap(bounds.right - bounds.left, bounds.bottom - bounds.top);
Bitmapの作成

*graphics = Graphics.FromImage(bmp);
Graphicsの作成

*hDC = graphics.GetHdc();
Graphicsのデバイスコンテキストを取得

*NativeAPIUtility.BitBlt(hDC, 0, 0, bmp.Width, bmp.Height, windowDC, bounds.left - rect.left, bounds.top - rect.top, NativeAPIUtility.SRCCOPY);
Bitmapに画像をコピー


*PubKey pub = ...
上で得たのと同じ公開鍵


*Task.Run(() => Task.WhenAll(
NEST

*ex.Handle(ex2 => ex2.Message == "1-1");*}catch(AggregateException ex3){
例外ハンドリングを行ったが、"1-1"しかハンドリングできなかったと仮定

*Console.WriteLine("--- Unhandle InnerExceptions ---");
ここ呼ばれない


*public static LayerMask LayerMaskField(string label,LayerMask layerMask)
LayerMaskFieldはデフォルトでは無いので自作.

*[CustomEditor(typeof(Sample))]
エディタ拡張部分.


*services
元からある行

*services.Configure<AppSetting>(Configuration);
これを追記


*var targets = particles.Select(p => new Data(p))
textureSheetAnimation を使っているもの、組み込み texture を使っているものは除外

*var sheet = p.Particle.textureSheetAnimation;
x,y を固定して使うための設定

*sheet.numTilesX = Mathf.RoundToInt(1 / packInfo.width);
サイズ、位置を指定


*var image = new BitmapImage(new Uri($"pack:
application:,,,FirstRevitPlugin;componentResources{iconName}"));


*public enum DrawMode*{Solid,Wire,}
描画モード.

*[CustomEditor(typeof(Sample))]
エディタ拡張部分.

*GUI.changed = false;
プリミティブタイプが変更された場合,メッシュを差し替える.

*EditorGUILayout.ObjectField(component.mesh, typeof(Mesh));
取得したメッシュを確認できるようにしているだけ.

*GUI.changed = false;
プリミティブタイプが変更された場合,メッシュを差し替える.


*public static void DefineItem(int type)
絶対なさそうな名前を選んだ

*}
絶対なさそうなメソッド組んだ


*double dE = Y - a_add_b;
value after differentiation of squared error because calculation is omitted

*using (StreamWriter sw = new StreamWriter(path, true, Encoding.Unicode)){sw.Write(a.ToString() + "," + b.ToString() + "," + a_add_b.ToString() + "," +w[0].ToString() + "," + w[1].ToString() + "," +Y.ToString() + "," + dE.ToString() +Environment.NewLine);
record

*using (StreamWriter sw = new StreamWriter(path, true, Encoding.Unicode)){sw.Write(",,," +w[0].ToString() + "," + w[1].ToString() + "," +"," +Environment.NewLine);
final record


*Channel channel = new Channel("10.0.2.2:50051", ChannelCredentials.Insecure);
127.0.0.1から10.0.2.2に接続先のアドレスを修正する。
Channel channel = new Channel("127.0.0.1:50051", ChannelCredentials.Insecure);


*if(i<=(pot_k-16))
28時間以下って条件は必要ないかな。comboBoxが28時間までだから

*fill_FF_area(start_address_POT+(k*16*16)+0x20, start_address_POT+(k*16*16)+0xFF, micom, output_file_name);
0x100の256byteを埋める。jが1で16byte


*public static T[] GetComponentsInActiveScene<T>(bool includeInactive = true)*{// ActiveなSceneのRootにあるGameObject[]を取得するvar rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();// 空の IEnumerable<T>IEnumerable<T> resultComponents = (T[])Enumerable.Empty<T>();foreach (var item in rootGameObjects){// includeInactive = true を指定するとGameObjectが非活性なものからも取得するvar components = item.GetComponentsInChildren<T>(includeInactive);resultComponents = resultComponents.Concat(components);}return resultComponents.ToArray();}
通常trueしか指定しないのでデフォルト引数をtrueにしてます

*var rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();
ActiveなSceneのRootにあるGameObject[]を取得する

*IEnumerable<T> resultComponents = (T[])Enumerable.Empty<T>();
空の IEnumerable<T>

*var components = item.GetComponentsInChildren<T>(includeInactive);
includeInactive = true を指定するとGameObjectが非活性なものからも取得する

*public static T GetComponentInActiveScene<T>(bool includeInactive = true)*{// ActiveなSceneのRootにあるGameObject[]を取得するvar rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();// 空の IEnumerable<T>IEnumerable<T> resultComponents = (T[])Enumerable.Empty<T>();foreach (var item in rootGameObjects){// includeInactive = true を指定するとGameObjectが非活性なものからも取得するvar components = item.GetComponentsInChildren<T>(includeInactive);resultComponents = resultComponents.Concat(components);}return resultComponents.First();}
1つだけ取得したい場合はこちら（GetComponentsInActiveSceneを元にして書いたので少し非効率です）

*var rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();
ActiveなSceneのRootにあるGameObject[]を取得する

*IEnumerable<T> resultComponents = (T[])Enumerable.Empty<T>();
空の IEnumerable<T>

*var components = item.GetComponentsInChildren<T>(includeInactive);
includeInactive = true を指定するとGameObjectが非活性なものからも取得する

*private void Reset()*{MenuContentHandlers = MyGameObjectUtility.GetComponentsInActiveScene<MenuContentHandler>();}
Scriptをアタッチした際に自動で呼ばれる, Inspectorからも呼べる


*Plane[] planes = GeometryUtility.CalculateFrustumPlanes(Camera.main);
メソッドの戻り値の配列は要素数6で、それぞれカメラ側から見て
[0]: 左の面, [1]: 右の面, [2]: 下の面, [3]: 上の面, [4]: 手前の面, [5]: 奥の面


*yield return www;
WWWクラス定義
WWW www = new WWW("http:urx3.nu/QwZk");
wwwダウンロード開始

*void Start()*{TestUniTask();}
using UniRx.Async;

*await www;
WWWクラス定義
WWW www = new WWW("http:urx3.nu/QwZk");
wwwダウンロード開始

*async void Test()*{//TestUniTask終了まで待つint a = await TestUniTask();Debug.Log("Complete");}
using UniRx.Async;

*int a = await TestUniTask();
TestUniTask終了まで待つ

*await UniTask.DelayFrame(5);
5フレーム待つ


*}
カウントが閾値を超えたときの処理


*dateTimeFormat.GetAbbreviatedEraName(eraIndex)
=> 明


*public void ConfigureServices(IServiceCollection services)*{//省略services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);//省略}
This method gets called by the runtime. Use this method to add services to the container.

*services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
省略

*}
省略

*public void ConfigureServices(IServiceCollection services)*{//省略services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2).AddJsonOptions(opt =>{opt.SerializerSettings.ContractResolver = new Newtonsoft.Json.Serialization.DefaultContractResolver();});//省略}
This method gets called by the runtime. Use this method to add services to the container.

*services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2)
省略

*}
省略


*var item = irome.Item;
irome.Item = new Something(); コンパイルエラー

*item = irome.GetSomething();
irome.DoSomething(new Something()); コンパイルエラー

*}
irome.Dispose(); コンパイルエラー


*driver.Navigate().GoToUrl("https:
www.google.com");


*var tfg = new TransformGroup();*tfg.Children.Add(new ScaleTransform(3, 3));
TransformGroupを作成(大きさを3倍にして、右に10pixcelずらす)

*bt.RenderTransform = tfg;*}
ボタンのRenderTransformにセット


*if (!this.IsLastSibling ()) return;
自身が最前でなければ何もしない


*Console.WriteLine(string.Format(CultureInfo.InvariantCulture, "{0:yyyy/MM/dd}", DateTime.Now));
↓

*Console.WriteLine(((IFormattable)$"{DateTime.Now:yyyy/MM/dd}").ToString(null, CultureInfo.InvariantCulture));
↓


*myUsecase.OnlineChanged += ReceiveOnlineChanged;
いつ -= する？

*}
省略

*this.app = new App();
省略...


*private GameObject guiTextSignUp;
新規登録テキスト

*private bool isLogIn;
ログイン画面のときtrue, 新規登録画面のときfalse

*private bool logInButton;
ボタンが押されると対応する変数がtrueになる

*public string id;
テキストボックスで入力される文字列を格納

*guiTextLogIn  = GameObject.Find ("GUITextLogIn");
ゲームオブジェクトを検索し取得する

*if( logInButton )*FindObjectOfType<UserAuth>().logIn( id, pw );
ログインボタンが押されたら

*if( signUpMenuButton )*isLogIn = false;
新規登録画面に移動するボタンが押されたら

*else {drawSignUpMenu();// 新規登録ボタンが押されたらif( signUpButton )FindObjectOfType<UserAuth>().signUp( id, mail, pw );// 戻るボタンが押されたらif( backButton )isLogIn = true;}
新規登録画面

*if( signUpButton )*FindObjectOfType<UserAuth>().signUp( id, mail, pw );
新規登録ボタンが押されたら

*if( backButton )*isLogIn = true;
戻るボタンが押されたら

*if( FindObjectOfType<UserAuth>().currentPlayer() != null )*Application.LoadLevel("Stage");
currentPlayerを毎フレーム監視し、ログインが完了したら

*guiTextSignUp.SetActive (false);
テキスト切り替え

*GUI.skin.textField.fontSize = 20;
テキストボックスの設置と入力値の取得

*int btnW = 180, btnH = 50;
ボタンの設置

*guiTextLogIn.SetActive (false);
テキスト切り替え

*int txtW = 150, txtH = 35;
テキストボックスの設置と入力値の取得

*int btnW = 180, btnH = 50;
ボタンの設置

*private UserAuth instance = null;
シングルトン化する ------------------------

*public GameObject player;
Playerプレハブ

*private GameObject title;
タイトル

*private bool leaderBoardButton;
ボタンが押されると対応する変数がtrueになる

*title = GameObject.Find ("Title");
Titleゲームオブジェクトを検索し取得する

*if( logOutButton )*FindObjectOfType<UserAuth> ().logOut ();
ログアウトボタンが押されたら

*if ( Event.current.type == EventType.MouseDown)*GameStart ();
画面タップでゲームスタート

*if( FindObjectOfType<UserAuth>().currentPlayer() == null )*Application.LoadLevel("Login");
ログアウト完了してたらログインメニューに戻る

*title.SetActive (false);
ゲームスタート時に、タイトルを非表示にしてプレイヤーを作成する

*title.SetActive (true);
ゲームオーバー時に、タイトルを表示する

*return title.activeSelf == false;
ゲーム中かどうかはタイトルの表示/非表示で判断する

*int btnW = 140, btnH = 50;
ボタンの設置


*url: "hoge
{filename}.jpg", ハンドリング対象URL


*protected int HResult { get; set; }
略

*}
略

*public int HResult { get; protected set; }
略

*}
略

*}
例外発生

*| System.Reflection.BindingFlags.Public
この Project のターゲットが .Net Framework 4.5　より前であっても
.Net Framework 4.5 以上のアセンブリが参照される可能性があるので Public を指定しておく


*string[] JapanHolidayfromCAO = new string[1] { "https:
www8.cao.go.jpchoseishukujitsusyukujitsu.csv" };

*Console.WriteLine("エラーが発生しました\r\n\r\n" + e.ToString());
URLのファイルが見つからない等のエラーが発生


*counterList.Add((".", "Processor", "% Processor Time", "_Total"));
コンピュータ名 = "." はローカルコンピュータを表す。コンピュータ名は省略可能（省略時は"."）
Memory/Available MBytesのようにインスタンスを指定できない項目は、インスタンスを空文字にする
取りたい情報を並べる

*counterList.ForEach((x) =>*{if (!PerformanceCounterCategory.Exists(x.category, x.machine)){//カテゴリが存在するか確かめるConsole.WriteLine("登録されていないカテゴリです：" + x.category);}else if (!PerformanceCounterCategory.CounterExists(x.counter, x.category, x.machine)){//カウンタが存在するか確かめるConsole.WriteLine("登録されていないカウンタです：" + x.counter);}else{//PerformanceCounterオブジェクトの作成pcList.Add(new PerformanceCounter(x.category, x.counter, x.instance, x.machine));}});
エラーチェック後、PerformanceCounterオブジェクトの作成を作成

*Console.WriteLine("登録されていないカテゴリです：" + x.category);
カテゴリが存在するか確かめる

*Console.WriteLine("登録されていないカウンタです：" + x.counter);
カウンタが存在するか確かめる

*pcList.Add(new PerformanceCounter(x.category, x.counter, x.instance, x.machine));*}
PerformanceCounterオブジェクトの作成

*Console.WriteLine(x.CategoryName + " / " + x.CounterName + "：" + x.NextValue());
計算された値を取得し、表示する

*System.Threading.Thread.Sleep(1000);
1秒待機する


*const string Dir = @"C:\PDFTest";
ディレクトリの指定

*string[] files = System.IO.Directory.GetFiles(Dir, "*", System.IO.SearchOption.AllDirectories);
ディレクトリ内のファイル名一覧を取得する。

*var excels = Process.GetProcessesByName("EXCEL");
エクセルのプロセスが残っているか確認して、残っていたら終了する。

*application = new Application();
Applicationクラスのインスタンス作成

*Console.WriteLine("----------Excelファイル展開開始----------");
Excelファイルを開く

*workbook.Close(true, Type.Missing, Type.Missing);
workbookをClose

*application.Quit();
applicationをClose


*return await GetClient().CreateDocumentCollectionAsync(database.SelfLink, new DocumentCollection { Id = collectionId });
Default is S1 tier


*m_StartTime += Time.deltaTime;
開始時間を調節する

*m_Time = Time.timeSinceLevelLoad - m_StartTime;
経過時間を求める

*StartTimer(m_Duration);
以下を実行してループを抜ける

*StartTimer(m_Duration, true, m_LoopCount);
再度セットする

*m_Duration = 0f;
駆動を終了する

*OnDoneMeasure(EventArgs.Empty);
計測終了イベントを実行する

*Break();
全パラメータをリセットする

*if(IsStop()) return false;*m_StartTime = Time.timeSinceLevelLoad;
停止中に再度再開はできない

*return IsWork() ? m_Time : 0f;
駆動中でないなら０を返す

*return IsWork() ? Mathf.FloorToInt(m_Time) : 0;
駆動中なら秒、そうでないなら０を返す

*text.text = GetTimeSec().ToString();
文字(秒数)を表示

*timer.OnDoneMeasureHandler -= handler;
ここに計測終了時に行いたい処理を書く

*}
ここに計測終了時に行いたい処理を書く


*tkm.start(9);
IDの呼び出し順が昇順でないパターン（レポートはID順に出る）・かつ、stopしたままで終了するパターン（レポートに警告が出る）


*PdfDocument document = new PdfDocument();
PdfDocument objectを作成します。

*PdfUnitConvertor unitCvtr = new PdfUnitConvertor();
マージンを設定します。

*PdfPageBase page = document.Pages.Add(PdfPageSize.A4, margins);
新規ページを追加します。

*PdfTrueTypeFont font = new PdfTrueTypeFont(new Font("Ms mincho", 20f), true);
カスタムのPdfTrueTypeFont、PdfPenインスタンスを作成します。

*string text = "初めてのPDFです！";
DrawStringメソッドでテキストを書きます。

*document.SaveToFile("PDF作成.pdf");
保存します・


*ShowDialogCommand = new ReactiveCommand(Operand.ObserveHasErrors.Select(x => !x))*.WithSubscribe(_ => DialogHelper.ShowDialog($"N = {Operand.Value}"));
コンストラクタ内

*ShowDialogCommand = new ReactiveCommand().WithSubscribe(_ => DialogHelper.ShowDialog($"N^2 = {Answer.Value}"));
コンストラクタ内


*DataTable dt = new DataTable();
テスト用にテーブルを作成

*Repeater1.DataSource = dt;
リピーターコントロールにテーブルをBindする

*((Literal)e.Item.FindControl("lits")).Text = "./newpage.aspx?KEY=" + view["KEY"] + "";
A案

*((HyperLink)e.Item.FindControl("hlk")).NavigateUrl = "./newpage.aspx?KEY=" + view["KEY"];
C案


*Response.Redirect(openfilename);
PDFに遷移


*Object[] selectedAsset = Selection.GetFiltered (typeof(Object), SelectionMode.Assets);*foreach (var sel in selectedAsset) {Debug.Log (sel.name + " : " + sel.GetType ());//選択したものがフォルダなら、フォルダ内にあるマテリアルとテクスチャを検索してリストに追加if ((sel.GetType ().ToString () == "UnityEditor.DefaultAsset")){var folder = (DefaultAsset)sel;var dirpath = AssetDatabase.GetAssetPath(folder);string[] diraug = {dirpath};//マテリアルに対する処理var mfiles = AssetDatabase.FindAssets("t:Material",diraug);foreach(var mf in mfiles){var mfpath = AssetDatabase.GUIDToAssetPath(mf);var mfasset = AssetDatabase.LoadAllAssetsAtPath(mfpath);foreach(var mfa in mfasset){mlist.Add((Material)mfa);}}//テクスチャに対する処理var tfiles = AssetDatabase.FindAssets("t:Texture2D",diraug);foreach(var tf in tfiles){var tfpath = AssetDatabase.GUIDToAssetPath(tf);var tfasset = AssetDatabase.LoadAllAssetsAtPath(tfpath);foreach(var tfa in tfasset){tlist.Add((Texture2D)tfa);Debug.Log(tfa);}}}}
選択したフォルダの取得

*var mfiles = AssetDatabase.FindAssets("t:Material",diraug);*foreach(var mf in mfiles){var mfpath = AssetDatabase.GUIDToAssetPath(mf);var mfasset = AssetDatabase.LoadAllAssetsAtPath(mfpath);foreach(var mfa in mfasset){mlist.Add((Material)mfa);}}
マテリアルに対する処理

*var tfiles = AssetDatabase.FindAssets("t:Texture2D",diraug);*foreach(var tf in tfiles){var tfpath = AssetDatabase.GUIDToAssetPath(tf);var tfasset = AssetDatabase.LoadAllAssetsAtPath(tfpath);foreach(var tfa in tfasset){tlist.Add((Texture2D)tfa);Debug.Log(tfa);}}
テクスチャに対する処理


*using (var transaction = new TinyTransaction(doc, "処理の名前"))
docの初期化など


*return;
この場合は、Abort()される。

*//*} catch (Exception ex) {
いろいろとオブジェクトを操作する

*} catch (Exception ex) {


*transaction.Abort();
異常時はAbortする

*transaction.End();
変更した場合のみ、End()する。
例外のcatchで先にAbort()していた場合は、このEnd()は無視される。

*}
managedリソースの破棄

*Abort();
unmanagedリソースの破棄


*[Migration(0, "creating schema")]
バージョン番号をプロジェクトで一意にする
重複があるとエラーになる
2回目以降は、同じ番号のマイグレーションはスキップする
カスタム属性を使うとより管理しやすい
https:fluentmigrator.github.io/articles/migration/migration-attribute-custom.html

*Delete.Table("testtable").InSchema("aa");
バージョン番号を下げるときに実行される

*Create.Schema("aa");
バージョン番号を上げるときに実行される

*IfDatabase("SqlServer")
SQLServer系列の場合だけ、デフォルトの文字列照合設定を変更する

*Create.Column("col1").OnTable("table1").AsString(128).Nullable();
null許可する場合

*Create.Column("col2").OnTable("table1").AsString(128).NotNullable();
null許可しない場合

*_Param = null;
DIを設定していない場合にはこちらが呼ばれる

*}
以下マイグレーションコード....


*var processInfo = new ProcessStartInfo();
（省略）


*tokens.Statuses.Update(status => $"私の名前は「{name}」です。#NameChangeBot");
名前変更の報告ツイート

*public static IEnumerable<TKey> GetKeys<TKey, TValue>(this Dictionary<TKey, TValue> self) {foreach (var item in self.Keys) {yield return item;}}
DictionaryのKeyをまとめてIEnumerableにして返す

*public static T Random<T>(this IEnumerable<T> self) {if (!self.Any()) {return default;}Random random = new Random();var idx = random.Next(0, self.Count());return self.ElementAt(idx);}
ランダムな要素を返す

*public static IEnumerable<Status> GetNotFavoTweets(this IEnumerable<Status> tweets,Tokens token) =>
ふぁぼされてないツイートだけ抽出


*NativeMethods.GetKeyboardState(keys);
Controlキーを押しっぱなしにする

*}
ループか何かで、複数回BrowserNode.DoSelect()する


*keys[VK_CONTROL] = savedControlKey;
Controlキーを復元する

*parentNode.Expanded = true;
BrowserNodeを開く


*motoData = motoData.Replace("<","&lt;").Replace(">","&gt;").Replace("\"","&quot;");
まずは、HTMLエンコードをする(既にエンコード済の文字が再エンコードされないように「<」「>」「"」だけエンコードする)

*Regex regex0 = new Regex("&lt;(((/)?((b)|(i)))|(br)|(/font))&gt;", RegexOptions.IgnoreCase | RegexOptions.Singleline);
<b></b><i></i><br></font>など属性のない許可タグ(と閉じタグ)を元に戻す
&lt;(((/)?((b)|(i)))|(br)|(/font))&gt;
→
&lt;
(
(
(/)?((b)|(i))
)
|
(br)
|
(/font)
)
&gt;

*Regex regex1 = new Regex("&lt;font(( size=&quot;[0-9]+&quot;)|( color=&quot;[a-z0-9#]+&quot;))+&gt;", RegexOptions.IgnoreCase | RegexOptions.Singleline);
fontタグのsizeとcolorだけ許可する
&lt;font(( size=&quot;[0-9]+&quot;)|( color=&quot;[a-z0-9#]+&quot;))+&gt;
→
&lt;font
(
( size=&quot;[0-9]+&quot;)
|
( color=&quot;[a-z0-9#]+&quot;)
)+
&gt;


*c0.type = "Contact";
オブジェクト指定

*System.Xml.XmlElement[] contactFields = new System.Xml.XmlElement[4];
XML作成

*contactFields[0] = doc.CreateElement("LastName");
氏

*contactFields[1] = doc.CreateElement("FirstName");
名

*contactFields[3] = doc.CreateElement("AccountId");
勤務先

*UpsertResult[] upsertResults = binding.upsert("Email", upserts);
Email一致の場合UPDATE、それ以外の場合INSERT


*if (image.Width > _MAX_IMAGE_WIDTH)
トラッキングの処理効率を上げるために内部的には最大幅640pxのイメージとして処理する
この時、内部の_initRect, _boundingBox等は縮小したイメージで処理されるので、
publicメソッド内で復元して呼び出し元に返却する


*[SerializeField] private MicRecorder _micRecorder;
特に依存しているComponentはないです

*_micRecorder.StartRecord();
録音開始。これは別にCoroutineではない

*yield return StartCoroutine(_micRecorder.StopRecord());
録音停止するときは処理をぜんぶ終える必要があるため、Coroutineの終了を待機してあげる

*// 完全に終了するまでの間もfalseなのであんま信用してはいけない*Debug.Log($"Are you listening? {_micRecorder.IsRecording}");
録音中フラグだがMicRecorder.StopRecordを実行してから

*Debug.Log($"Are you listening? {_micRecorder.IsRecording}");
完全に終了するまでの間もfalseなのであんま信用してはいけない


*#nullable disable
ここ以下の行はnull許容参照型が無効になる(従来通り)


*var completed = Task.WhenAny(heavyTask, Task.Delay(1000));
最初に完了したTaskが戻り値となる

*if (heavyTask == completed)
heavyTaskが完了したかどうか
heavyTask.IsCompletedを調べるのでもよい


*using System.Runtime.InteropServices;
DllImport属性を使用するために必要

*[DllImport("kernel32.dll")]
デバック時のみコンソールアプリを呼び出す

*AllocConsole();
コンソールアプリ表示（Nlogのコンソールへのログ出力が見えるようになります）
AllocConsole();以後は、
Console.ReadKey();　とかけば停止ができる。デバックで便利。キー押せば再開する。


*int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);*// 目的のウィンドウを作成したスレッドのIDを取得
フォアグラウンドウィンドウを作成したスレッドのIDを取得

*int targetID = GetWindowThreadProcessId(handle, out processId);
目的のウィンドウを作成したスレッドのIDを取得

*AttachThreadInput(targetID, foregroundID, true);*// 現在の設定を timeout に保存
スレッドのインプット状態を結び付ける

*SystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, timeout, 0);
現在の設定を timeout に保存

*SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, dummy, SPIF_SENDCHANGE);
ウィンドウの切り替え時間を 0ms にする

*isSuccess = SetForegroundWindow(handle);
ウィンドウをフォアグラウンドに持ってくる

*SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, timeout, SPIF_SENDCHANGE);
設定を元に戻す

*AttachThreadInput(targetID, foregroundID, false);*return isSuccess;
スレッドのインプット状態を切り離す

*for (int i = 0; i < 3; i++)*if (ForceActive(this.Handle)) break;
タスクバーが点滅しフォーカスはあるのに入力できない状態になるため

*for (int i = 0; i < 3; i++)*if (ForceActive(helper.Handle)) break;
タスクバーが点滅しフォーカスはあるのに入力できない状態になるため


*GameObject FoldinfImage;
折り畳み部分を取得

*bool OpenFold = false;
折り畳み部分を表示するか非表示にするか

*RectTransform button;*VerticalLayoutGroup contentLayout;
ボタンの画像を回転

*yield return null;
1フレーム停止

*contentLayout.enabled = false;
再開後の処理


*BrowserNode node;
存在しているのに表示されていないBrowserNode

*,,,
中略
node.DoSelect();        何も選択されない
_ = node.Expanded;      例外にならない
node.Expanded = false;  例外が送出される!!


*string ToolTipText = "",
Ribbonのbuttonにポインタを合わせた時に表示されます。


*void Start()*{}
Start is called before the first frame update

*void Update()*{if (Delay > 0){Delay -= Time.deltaTime;}else{if (isAnimation){CurrentTime += Time.deltaTime;float r = Mathf.Clamp01(CurrentTime / Duration);//EaseOutr = -r * (r - 2.0f);transform.localPosition = Vector3.Lerp(PrePosition, ToPosition, r);}else{transform.localPosition = ToPosition;}}}
Update is called once per frame


*Form1 frm = new Form1();
(中略)


*public void Command_OnExecute(NameValueMap Context)*{interactionEvents = m_inventorApplication.CommandManager.CreateInteractionEvents();interactionEvents.SelectEvents.OnPreSelect += SelectEvents_OnPreSelect;interactionEvents.SelectEvents.OnSelect += SelectEvents_OnSelect;//  selectEvents = interactionEvents.SelectEvents;interactionEvents.Start();}
private SelectEvents selectEvents;

*someObject.ReferenceKeyManager.BindKeyToObject(ref byteArray1, 0, out dummy);
(中略)
↓ これは通る(場合がある)

*anotherObject.ReferenceKeyManager.BindKeyToObject(ref byteArray2, 0, out dummy);
↓ ここで落ちる

*dummy = null;
(中略)
↓ OK

*}
ここで、objは常にnullのはずだが、3Dスケッチから抜けたときだけは、nullではない。
フィーチャーもしくはスケッチが編集中かどうかを、
ActiveEditDocument.ActivatedObject == nullで判断すると、バグる。
代わりに、EditObjectがDocumentかどうかで判断することで、回避する。


*string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
クライアントからLock scriptの文字列を受け取る

*Script redeemScript = new Script(requestBody);
ScriptクラスへLock scriptを渡す

*BitcoinAddress address = redeemScript.Hash.GetAddress(Network.Main);
P2SH形式のビットコインアドレスを生成する

*return address != null? (ActionResult)new OkObjectResult(address.ToString()): new BadRequestObjectResult("Please pass a name on the query string or in the request body");
生成されたビットコインアドレスを返す

*bool broadcast = (req.Query["b"] == "1");
トランザクションをブロードキャストするか否かのフラグ

*string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
クライアントからのパラメータを受け取る

*WebResponse response = request.GetResponse();
chain.soでビットコインアドレスのUTXOを取得する
WebRequest request = WebRequest.Create("https:chain.so/api/v2/get_tx_unspent/" + network + "/" + btcAddress);

*String[] unlockingScripts = unlockingScript.Split(" ", StringSplitOptions.RemoveEmptyEntries);
半角スペース区切りでOPコードを取得する

*Op[] ops = new Op[] {};
OPコードを格納する配列


*MySqlConnection cn = new MySqlConnection("Server=＜値＞;Database=＜値＞;Uid=＜値＞;Pwd=＜値＞;Port=3306;");
コネクション作成

*cn.Open();
cn.Openがないサンプル結構あるが、これを書かずにcmd.ExecuteReader行うと例外になりコネクション系の沼にはまる
世の中には、cn.Open()で済む話をcmd.ExecuteReaderが使えないバグと称して嘘を書いているものがあるので注意


*private Sprite sprite;
一時キャッシュ用

*private void LateUpdate ()*{foreach (Image img in FindObjectsOfType<Image>()){//シーン上に存在し、spriteが割り当てられているかif (img.gameObject.activeInHierarchy && img.sprite != null){sprite = img.sprite;img.sprite = null;img.sprite = sprite;}}}
Update、FixedUpdate、OnRenderObjectだと修正前の画像が一瞬見えてしまう(特にコルーチン)


*class Calculator*{// バージョン情報static public readonly Version version = new Version(1, 2, 2);// 製作者名static public readonly string maker = "HitsujiRere";// 接頭辞と初期値のディクショナリstatic public Dictionary<char, bool> prefixs = new Dictionary<char, bool>(){['&'] = true,['@'] = false,};// 演算子と計算のディクショナリstatic public Dictionary<string, Func<double, string[], double>> operatorsOf1 =new Dictionary<string, Func<double, string[], double>>(){["=%"] = (a, _) => a * 0.01,["-%"] = (a, _) => a * 100.0,["++"] = (a, _) => a + 1.0,["--"] = (a, _) => a - 1.0,["*-"] = (a, _) => a * -1.0,["sq"] = (a, _) => a * a,["sqrt"] = (a, _) => Math.Sqrt(a),["bx"] = (a, _) => a * a * a,["bxrt"] = (a, _) => Math.Pow(a, 1.0 / 3.0),};static public Dictionary<string, Func<double, double, string[], double>> operatorsOf2 =new Dictionary<string, Func<double, double, string[], double>>(){["+"] = (a, b, _) => a + b,["-"] = (a, b, _) => a - b,["*"] = (a, b, _) => a * b,["/"] = (a, b, _) => a / b,["%"] = (a, b, _) => a % b,["mod"] = (a, b, _) => a % b,["div"] = (a, b, _) => (a - (a % b)) / b,["^"] = (a, b, _) => Math.Pow(a, b),};static public Dictionary<string, Func<double[], string[], double>> operatorsAll =new Dictionary<string, Func<double[], string[], double>>(){["cnt"] = (a, _) => a.Count(),["sum"] = (a, _) => a.Sum(),["ave"] = (a, _) => a.Average(),};// 命令と計算のディクショナリstatic public Dictionary<string, Action<Calculator, string[]>> instructions =new Dictionary<string, Action<Calculator, string[]>>(){["sort"] = (calc, _) =>{calc.numStack = new Stack<double>(calc.numStack.OrderBy(x => x));},["rev"] = (calc, _) =>{calc.numStack = new Stack<double>(calc.numStack);},["clr"] = (calc, _) => { calc.numStack.Clear(); },["help"] = (calc, _) =>{Console.WriteLine("特殊な接頭辞");Prints(prefixs.Select(x => x.Key.ToString()));Console.WriteLine("1項演算子");Prints(operatorsOf1.Select(x => x.Key));Console.WriteLine("2項演算子");Prints(operatorsOf2.Select(x => x.Key));Console.WriteLine("全てへの演算子");Prints(operatorsAll.Select(x => x.Key));Console.WriteLine("命令");Prints(instructions.Select(x => x.Key));void Prints(IEnumerable<string> a){foreach (var item in a){Console.WriteLine("{0,6} = {1}", item,comments.ContainsKey(item) ? comments[item] : "not found");}Console.WriteLine();}},["xvar"] = (calc, names) =>{foreach (var name in names){if (!calc.variables.ContainsKey(name)){calc.variables[name] = 0.0;}}},["xin"] = (calc, names) =>{foreach (var name in names){if (calc.numStack.Count >= 1){calc.variables[name] = calc.numStack.Pop();}}},["xout"] = (calc, names) =>{foreach (var name in names){if (calc.variables.ContainsKey(name)){calc.numStack.Push(calc.variables[name]);}}},["xcout"] = (calc, _) =>{foreach (var item in calc.variables){Console.WriteLine("{0,6} = {1}", item.Key, item.Value);}Console.WriteLine();},};// 接頭辞,演算子,命令についての説明static public Dictionary<string, string> comments =new Dictionary<string, string>(){["&"] = "計算のために取得した数字を削除しない",["@"] = "全ての数に対して演算を行う（実装中）",["=%"] = "前の数値を、パーセント数値にする（*100する）",["-%"] = "前のパーセント数値を、数値にする（*0.01する）",["++"] = "前の数字を、+1する",["--"] = "前の数字を、-1する",["*-"] = "前の数字を、*(-1)する",["sq"] = "前の数字を、平方する",["sqrt"] = "前の数字を、平方根にする",["bx"] = "前の数字を、立方する",["bxrt"] = "前の数字を、立方根にする",["+"] = "前の数字2つを、足し算する",["-"] = "前の数字2つを、引き算する",["*"] = "前の数字2つを、掛け算する",["/"] = "前の数字2つを、割り算する",["%"] = "前の数字2つを、割り算し、その余りをとる",["mod"] = "前の数字2つを、割り算し、その余りをとる",["div"] = "前の数字2つを、割り算し、その商をとる",["^"] = "前の数字2つを、累乗する",["cnt"] = "前の数字全てを、計数する",["sum"] = "前の数字全てを、合計する",["ave"] = "前の数字全てを、平均する",["sort"] = "数値スタックを、昇順にソートする",["rev"] = "数値スタックを、順序逆転する",["clr"] = "数値スタックを、全て消去する",["help"] = "演算子,命令の一覧,説明を、出力する",["xvar"] = "変数を登録する",["xin"] = "前の数字を、変数に入れる",["xout"] = "変数を数値Stackに入れる",["xcout"] = "全ての変数とその値を出力する",};// 数値を入れておくスタックpublic Stack<double> numStack = new Stack<double>();// 変数のディクショナリpublic Dictionary<string, double> variables =new Dictionary<string, double>();// 計算もしくは数字を追加するpublic bool PassString(string[] txts){var main = txts[0];var options = txts.Skip(1).ToArray();// 演算子が有効かどうかvar havePrefixs = new Dictionary<char, bool>(prefixs);// 先頭に接頭辞が見つからなくなるまで繰り返すvar isContain = true;while (isContain){if (havePrefixs.ContainsKey(main[0])){havePrefixs[main[0]] ^= true;main = main.Substring(1);isContain = true;}else{isContain = false;}}if (numStack.Count >= 1 && operatorsOf1.ContainsKey(main)){var num = havePrefixs['&'] ? numStack.Pop() : numStack.Peek();numStack.Push(operatorsOf1[main](num, options));return true;}else if (numStack.Count >= 2 && operatorsOf2.ContainsKey(main)){var num1 = havePrefixs['&'] ? numStack.Pop() : numStack.Peek();var num2 = havePrefixs['&'] ? numStack.Pop() : numStack.Peek();numStack.Push(operatorsOf2[main](num2, num1, options));return true;}else if (operatorsAll.ContainsKey(main)){var nums = numStack.ToArray();if (havePrefixs['&'])numStack.Clear();numStack.Push(operatorsAll[main](nums, options));return true;}else if (instructions.ContainsKey(txts[0])){instructions[main](this, options);return true;}else if (double.TryParse(main, out var num)){numStack.Push(num);return true;}else if (variables.ContainsKey(main)){numStack.Push(variables[main]);return true;}return false;}public bool PassString(string word){var elements = word.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries);return PassString(elements);}// txtsを順に計算もしくは数字を追加するpublic double[] PassStrings(string[] words, bool debug = false){bool existNotFound = false;foreach (var word in words){if (PassString(word.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries))){if (debug){Console.Write("= ");if (numStack.Count > 0){foreach (var num in numStack.Reverse()){Console.Write("{0}, ", num);}Console.Write('\n');}else{Console.WriteLine("nothing");}}}else{Console.WriteLine("{0} is not found", word);existNotFound = true;}}if (debug || existNotFound){Console.WriteLine();}return numStack.Reverse().ToArray();}// txtの命令を実行するpublic bool Instruction(string words){var word = words.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries);if (instructions.ContainsKey(word[0])){instructions[word[0]](this, word.Skip(1).ToArray());return true;}return false;}}
計算機

*static public readonly Version version = new Version(1, 2, 2);
バージョン情報

*static public readonly string maker = "HitsujiRere";
製作者名

*static public Dictionary<char, bool> prefixs = new Dictionary<char, bool>()*{['&'] = true,['@'] = false,};
接頭辞と初期値のディクショナリ

*static public Dictionary<string, Func<double, string[], double>> operatorsOf1 =
演算子と計算のディクショナリ

*static public Dictionary<string, Action<Calculator, string[]>> instructions =
命令と計算のディクショナリ

*static public Dictionary<string, string> comments =
接頭辞,演算子,命令についての説明

*public Stack<double> numStack = new Stack<double>();
数値を入れておくスタック

*public Dictionary<string, double> variables =
変数のディクショナリ

*public bool PassString(string[] txts)*{var main = txts[0];var options = txts.Skip(1).ToArray();// 演算子が有効かどうかvar havePrefixs = new Dictionary<char, bool>(prefixs);// 先頭に接頭辞が見つからなくなるまで繰り返すvar isContain = true;while (isContain){if (havePrefixs.ContainsKey(main[0])){havePrefixs[main[0]] ^= true;main = main.Substring(1);isContain = true;}else{isContain = false;}}if (numStack.Count >= 1 && operatorsOf1.ContainsKey(main)){var num = havePrefixs['&'] ? numStack.Pop() : numStack.Peek();numStack.Push(operatorsOf1[main](num, options));return true;}else if (numStack.Count >= 2 && operatorsOf2.ContainsKey(main)){var num1 = havePrefixs['&'] ? numStack.Pop() : numStack.Peek();var num2 = havePrefixs['&'] ? numStack.Pop() : numStack.Peek();numStack.Push(operatorsOf2[main](num2, num1, options));return true;}else if (operatorsAll.ContainsKey(main)){var nums = numStack.ToArray();if (havePrefixs['&'])numStack.Clear();numStack.Push(operatorsAll[main](nums, options));return true;}else if (instructions.ContainsKey(txts[0])){instructions[main](this, options);return true;}else if (double.TryParse(main, out var num)){numStack.Push(num);return true;}else if (variables.ContainsKey(main)){numStack.Push(variables[main]);return true;}return false;}
計算もしくは数字を追加する

*var havePrefixs = new Dictionary<char, bool>(prefixs);
演算子が有効かどうか

*var isContain = true;
先頭に接頭辞が見つからなくなるまで繰り返す

*public double[] PassStrings(string[] words, bool debug = false){bool existNotFound = false;
txtsを順に計算もしくは数字を追加する

*public bool Instruction(string words)*{var word = words.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries);if (instructions.ContainsKey(word[0])){instructions[word[0]](this, word.Skip(1).ToArray());return true;}return false;}
txtの命令を実行する

*var calc = new Calculator();
計算機

*var isRepeat = true;
下のwhileを繰り返すかどうか

*Console.Write("> ");*var inputs = Console.ReadLine().Split(new[] { ' ', ',' }, StringSplitOptions.RemoveEmptyEntries);
コマンドから入力したものを' '（空白）もしくは','で分割する

*var nums = calc.PassStrings(inputs, debug: false);
分割した入力配列を渡す


*this.Loading.SetActive (false);
クルクルを非表示

*private void OnDestroy () {if (this.Texture2D) { Destroy (this.Texture2D); }if (this.Sprite) { Destroy (this.Sprite); }}
自分が消えるときには、作ったデータも消す


*}
スタートからクリア判定を置く
isClear = true;

*void Update () {if (Input.GetMouseButtonDown (0)) {SceneManager.LoadScene ("GameResult");}}
クリックしたら「GameResult」に遷移

*GameObject resultObj = GameObject.Find ("ResultObject");
オブジェクトを名前で探す

*Debug.Log (resultObj.GetComponent<GamePlaying> ().test);
変数「test」を参照しDebug.Logに出力

*resultObj.transform.position = new Vector3 (*resultObj.transform.position.x,
オブジェクトの位置情報を変更

*PlayerPrefs.SetInt("SCORE", 20);
「SCORE」というキーで、Int値の「20」を保存

*int resultScore = PlayerPrefs.GetInt("SCORE");
「SCORE」というキーで保存されているInt値を読み込み


*,,,
出力結果
1.23399996757507
1.23399996757507
1.234


*public DelegateCommand ButtonCommand { get; }
ボタン押下時処理

*private bool _colorChangeFlag = false;
★〇の色を切り替えるためのフラグ

*public UserControl1ViewModel()*{this.ButtonCommand = new DelegateCommand(() =>{// ★ボタンをおしたら、フラグが切り替わるColorChangeFlag = !ColorChangeFlag;});}
コンストラクタ

*ColorChangeFlag = !ColorChangeFlag;
★ボタンをおしたら、フラグが切り替わる

*[Dependency]*public IRegionManager RegionManager { get; set; }
--------- Prismお決まり部分 -------------


*await Task.Delay(200);
指定時間のwait

*task.Wait();
タスクを実行、完了まで待機


*public class MainActivity : AppCompatActivity*{/// <summary>content_mainページ表示用ボタン</summary>private Button BtnShowContent { get; set; }/// <summary>activity_mainページ表示用ボタン</summary>private Button BtnShowActivity { get; set; }/// <summary>アプリ起動時</summary>/// <param name="savedInstanceState"></param>protected override void OnCreate(Bundle savedInstanceState){base.OnCreate(savedInstanceState);Xamarin.Essentials.Platform.Init(this, savedInstanceState);// 初期ページを表示SetContentView(Resource.Layout.activity_main);// contentページ表示ボタンBtnShowContent = FindViewById<Button>(Resource.Id.btn_show_content_main_page);BtnShowContent.Click += BtnShowContent_Click;}/// <summary>contentページ表示イベント</summary>/// <param name="sender"></param>/// <param name="e"></param>private void BtnShowContent_Click(object sender, EventArgs e){SetContentView(Resource.Layout.content_main);// activityページ表示ボタンBtnShowActivity = FindViewById<Button>(Resource.Id.btn_show_activity_main_page);BtnShowActivity.Click += BtnShowActivity_Click;}/// <summary>activityページ表示イベント</summary>/// <param name="sender"></param>/// <param name="e"></param>private void BtnShowActivity_Click(object sender, EventArgs e){SetContentView(Resource.Layout.activity_main);// contentページ表示ボタンBtnShowContent = FindViewById<Button>(Resource.Id.btn_show_content_main_page);BtnShowContent.Click += BtnShowContent_Click;}//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,*SetContentView(Resource.Layout.activity_main);
初期ページを表示

*BtnShowContent = FindViewById<Button>(Resource.Id.btn_show_content_main_page);
contentページ表示ボタン

*BtnShowActivity = FindViewById<Button>(Resource.Id.btn_show_activity_main_page);
activityページ表示ボタン

*BtnShowContent = FindViewById<Button>(Resource.Id.btn_show_content_main_page);
contentページ表示ボタン


*private HitTestResult hit = null;
指定した座標のグラフ要素を保持するオブジェクト

*private bool IsHitBorderLine(string seriesName)*{return checkBox1.Checked && seriesName == "Border";}
直線状態のBorderをクリックしたか

*HitTestResult test = chart1.HitTest(e.X, e.Y);
マウス座標上にヒットしたグラフ要素を取得し、それがDataPointかつ存在するものかチェックする

*double dx = ca.AxisX.PixelPositionToValue(e.X);
NOTE:マウスの座標の範囲チェックをしないと例外が出る

*var points = hit.Series.Points;
全ての線を移動させる

*hit = null;
取得したグラフ要素を捨てる

*var point = points.Where(v => v.XValue == curPoint.XValue).FirstOrDefault();
クリックしたX軸のデータをBorder以下のY軸にする

*var points = chart1.Series["Border"].Points;
Borderの全Pointを最大値に合わせる（直線にする）


*page.Orientation = PageOrientation.Landscape;
用紙の向き


*Response.Redirect(openfilename);
PDFに遷移


*public Int32 Add([MarshalAs(UnmanagedType.BStr)]string str)
★マーシャリングする！


*.Where(i => "" == i.description.Substring(0, 1)).ToList();
OK


*public IActionResult Index()
https:localhost:<ポート番号>/<コントローラ名>/<アクション名> で発火
https:localhost:<ポート番号>/Hello で発火

*ViewBag.Message = "Here is 'Hello/Index.cshtml'";
cshtml ファイル (View) に向けて値を受け渡す
ViewBag や ViewData を使ってデータをやり取りする

*public IActionResult sayHello()*{ViewBag.Message = "Hello World!";// Views/Hello/Index.cshtml に処理を反映させるreturn View("Index");}
https:localhost:<ポート番号>/Hello/sayHello で発火

*return View("Index");
Views/Hello/Index.cshtml に処理を反映させる


*public enum HapicPower*{NONE = 0,WEEK = 1000,MIDDLE = 2000,STRONG = 4000}
振動の強さ三段階

*public void ControllerHaptic()
振動メソッドたち
パターン①

*public void ControllerHaptic(HapicPower hapicPower)*{float seconds = (float)hapicPower / 1000000f;hapicAction.Execute(0, seconds, 1f / seconds, 1, handType);}
パターン②

*public void ControllerHaptic(ushort microSecondsDuration)*{float seconds = (float)microSecondsDuration / 1000000f;hapicAction.Execute(0, seconds, 1f / seconds, 1, handType);}
パターン③

*ControllerHaptic();
パターン①

*ControllerHaptic(HapicPower.STRONG)
パターン②

*ControllerHaptic(3200);
パターン③


*Company newCompanyA = companyA.DeepClone();
会社データ(新)A[会社データ(旧)Aを詳細コピー]

*newCompanyA.ceo = personD;
社長→山田太郎Jrに変更、社員から山田太郎Jrを削除

*//else*//{//    tempList.Add(null);//}
今回は空データはスキップするが、必要に応じてListに空データを追加する

*//{//    tempList.Add(null);//}
else

*Console.Write("会社名 {0}(新) 社長:{1} 社員: {2} \r\n", newCompanyA.name, newCompanyA.ceo.name, commonClass.NullCheck(string.Join(", ", nameList2)));
出力


*await DoSomethingAsync();
この辺でもなんかやる
最後に1個だけ非同期メソッドを呼ぶ

*return DoSomethingAsync();
この辺でもなんかやる
直接Taskを返すとちょっと速い

*return thing.DoAsync();
この辺でもなんかやる

*return thing.DoAsync();
この辺でもなんかやる

*var ret = thing.DoAsync();
この辺でもなんかやる

*thing.Dispose();
finallyの中身はreturnの前に実行される

*return ret;
ObjectDisposedExceptionで死ぬ
死ぬタイミングは thing.DoAsync() の中身次第

*await thing.DoAsync();
この辺でもなんかやる
これならDoAsync()が終わった後にDispose()される


*List<FaceInfo> faceInfoBaseList = faceInfoList.Where(x => x.faceDivision == DIVISION_BASE).ToList();
FaceInfoクラスのリストを仕分け

*ShowImage(urlBase, faceInfoBaseList);
比較元画像の表示

*ShowImage(urlTarget, faceInfoTargetList);
比較先画像の表示

*using (Mat image = new Mat(url)){foreach (FaceInfo faceInfo in faceInfoList){顔の検出箇所に赤枠を表示Rect rect = new Rect(faceInfo.recLeft, faceInfo.recTop, faceInfo.recWidth, faceInfo.recHeight);
画像の読み込み

*Rect rect = new Rect(faceInfo.recLeft, faceInfo.recTop, faceInfo.recWidth, faceInfo.recHeight);
顔の検出箇所に赤枠を表示

*Cv2.PutText(image, faceInfo.faceId, new Point(faceInfo.recLeft, faceInfo.recTop)
FaceIDを描画

*List<FaceInfo> faceInfoList = FaceDetect.Detect(imageUrls);
FindSimilarのパラメータとなるfaceId、その他を取得

*dispImageByOpenCV(URL_BASE, URL_TARGET, faceInfoList);
追加箇所 From----------------------------------------

*}
追加箇所 To------------------------------------------

*Cv2.DestroyAllWindows();
追加箇所 From----------------------------------------

*}
追加箇所 To------------------------------------------

*client.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", ConfigurationManager.AppSettings["subscriptionKey"]);
リクエストヘッダー

*MatchFaceSimilar matchFaceSimilar = new MatchFaceSimilar(faceInfoBase.faceId, targetFaceIdList.ToArray());
リクエストボディをJSON形式にする

*content.Headers.ContentType = new MediaTypeHeaderValue("application/json");
リクエストヘッダーの作成

*var contentString = await response.Content.ReadAsStringAsync();
実行結果からJSONの取得

*List<FaceConfidence> faceConfidence = JsonConvert.DeserializeObject<List<FaceConfidence>>(contentString);
JSONを整形して出力


*var millisec = ts.Milliseconds;
ミリ秒

*var millisec2 = sw.ElapsedMilliseconds;
計測した時間の合計をミリ秒で取得

*}
続きから計測する場合は再度Start()を呼ぶ
sw.Start();
0から再度計測する場合はReset()を呼んだあとにStart()を呼ぶ
sw.Reset();
sw.Start();


*Hoge hoge = x => Debug.Log(x);
これがラムダ式

*hoge("Hello World!!");
引数 => 処理の流れがあれば基本動く
Hogeは絶対に引数にstringとるからラムダ式での引数も勝手にstringになる
これだけ覚えとけばなんとかなる


*MLContext mlContext = new MLContext(seed: 1);
コンテキストの生成

*string dataPath = @".\Data\winequality-red.csv";
データのロード

*var split = mlContext.Data.TrainTestSplit(data, testFraction: 0.2, seed: 0);
学習データとテストデータに分割

*var dataProcessPipeline = mlContext.Transforms.Concatenate(
学習パイプラインの定義
学習データの定義

*var trainer = mlContext.Regression.Trainers.Sdca(labelColumnName: nameof(WineQualityData.Quality), featureColumnName: "Features");
学習アルゴリズムの定義

*var trainingPipeline = dataProcessPipeline.Append(trainer);
学習アルゴリズムをパイプラインに設定

*var trainedModel = trainingPipeline.Fit(split.TrainSet);
学習データを用いて学習モデルを生成

*IDataView predictions = trainedModel.Transform(split.TestSet);
テストデータによるモデルの評価
生成した学習モデルにテストデータを設定

*var metrics = mlContext.Regression.Evaluate(predictions, labelColumnName: nameof(WineQualityData.Quality), scoreColumnName: "Score");*Console.WriteLine($"*   損失関数(LossFn): {metrics.LossFunction}");
学習モデルの評価

*mlContext.Model.Save(trainedModel, split.TrainSet.Schema, modelFilePath);
学習モデルをファイルに保存

*ITransformer model = mlContext.Model.Load(modelFilePath, out DataViewSchema inputSchema);*//推論エンジンの生成
学習モデルのロード

*var predictionEngine = mlContext.Model.CreatePredictionEngine<WineQualityData, WineQualityPrediction>(model);
推論エンジンの生成

*WineQualityData wineQualityData = new WineQualityData(){TODO: 各属性の設定FixedAcidity = ....};
各説明変数を定義したオブジェクトを生成

*FixedAcidity = ....};
TODO: 各属性の設定

*WineQualityPrediction predictionResult = predictionEngine.Predict(wineQualityData);
推論の実行


*private void BtnSetPicture_Click(object sender, EventArgs e)*{int flg = -1;var dialog = new OpenFileDialog();dialog.ShowDialog();string filePath = dialog.FileName;//MessageBox.Show(filePath);if (optWhite.Checked == true) { flg = 0; }if (optYellow.Checked == true) { flg = 1; }if (optBlue.Checked == true) { flg = 2; }if (optRed.Checked == true) { flg = 3; }if (optGreen.Checked == true) { flg = 4; }if (optOrange.Checked == true) { flg = 5; }wholeCube.SetColors(flg, Python.ReadColors(flg.ToString()));RefreshView();}
フォーム上のクリックイベント

*public static class Python*{public static string ReadColors(string filePath){return ReadDummyColors(filePath);}private static string ReadDummyColors(string filePath){string ret = "";if (filePath == "0") { ret = "000000000"; }else if (filePath == "1") { ret = "111111111"; }else if (filePath == "2") { ret = "222222222"; }else if (filePath == "3") { ret = "333333333"; }else if (filePath == "4") { ret = "444444444"; }else if (filePath == "5") { ret = "555555555"; }return ret;}}
共通関数側の呼び出し処理(スタブ)


*sp.Close();
シリアルポートのクローズ


*const string DIVISION_TARGET = "target";
区分：比較先

*List<FaceInfo> faceInfoList = FaceDetect.Detect(imageUrls);
Face DetectからfaceIdその他を取得


*Update(userId, newPassword);
コンパイルエラー

*PasswordUtil.Check("001", "password");
パスワードをチェックしたいときはCheckメソッドを使う

*PasswordUtil.Update("001", "password", "new_password");
パスワードを変更したいときはUpdateメソッドを使う


*foo = null;
この行はコンパイルエラー


*public DelegateCommand LoadedCommand { get; }
★ボタンのコマンドをやめて、Loaded時のコマンドにした


*Debug.Log("initialize AR camera manager frame received");
アプリ起動時処理

*this.arRaycastManager = GetComponent<ARRaycastManager>();
AR起動時処理

*this.objectDetector = goObjectDetector.GetComponent<TinyYolo3Detector>();
物体認識

*this.similarWordClient = goSimilarWordClient.GetComponent<SimilarWordClient>();
関連語REST APIクライアント

*unsafe void OnCameraFrameReceived(ARCameraFrameEventArgs eventArgs)*{if (!arCameraManager.TryAcquireLatestCpuImage(out XRCpuImage image)){return;}var conversionParams = new XRCpuImage.ConversionParams{inputRect = new RectInt(0, 0, image.width, image.height),outputDimensions = new Vector2Int(image.width, image.height),outputFormat = TextureFormat.RGBA32,transformation = XRCpuImage.Transformation.None};int imageSize = image.GetConvertedDataSize(conversionParams);var buffer = new NativeArray<byte>(imageSize, Allocator.Temp);image.Convert(conversionParams, new IntPtr(buffer.GetUnsafePtr()), buffer.Length);image.Dispose();this.m_Texture = new Texture2D(conversionParams.outputDimensions.x,conversionParams.outputDimensions.y,conversionParams.outputFormat,false);this.m_Texture.LoadRawTextureData(buffer);this.m_Texture.Apply();buffer.Dispose();Detect();}
ARカメラの画像を取得

*private void Detect()*{if (this.isDetecting){return;}if (this.detectionTargetQueue.Count() == 0){return;}var detectionTarget = this.detectionTargetQueue.Dequeue();this.isDetecting = true;StartCoroutine(ProcessImage(this.objectDetector.IMAGE_SIZE, detectionTarget.CurrentTexture2D, picture =>{StartCoroutine(this.objectDetector.Detect(picture, itemsDetected =>{if (itemsDetected.Count > 0){var detected = new Detected{HitPose = detectionTarget.HitPose,ItemsDetected = itemsDetected,};this.detectedQueue.Enqueue(detected);}Resources.UnloadUnusedAssets();this.isDetecting = false;}));}));}
物体認識

*private void RequestSimilarWord()*{if (this.detectedQueue.Count()==0){return;}var detected = this.detectedQueue.Dequeue();StartCoroutine(this.similarWordClient.SimilarWordAPI(detected.ItemsDetected[0].PredictedItem.Label, 20, results =>{Debug.Log($"result {results}");var detectedSimilarWords = new DetectedSimilarWords{HitPose = detected.HitPose,SimilarWords=results,};this.detectedSimilarWordsQueue.Enqueue(detectedSimilarWords);}));}
関連語をリクエスト

*public enum LabelLanguages*{EN,JP};
ラベルの言語。英語or日本語

*Debug.Log("Run detection");
Coroutineで物体認識を実行


*System.Array.Resize( ref planes, 4 );
near,far面を排除

*}
入った！！


*}
...


*static ServiceControllerStatus StartMSSqlService(string instanceName)*{if (string.IsNullOrEmpty(instanceName))throw new ArgumentNullException(nameof(instanceName));try{using (var controller = new ServiceController($"MSSQL${instanceName}", ".")){if (controller.Status == ServiceControllerStatus.Stopped){controller.Start();controller.WaitForStatus(ServiceControllerStatus.Running);}return controller.Status;}}catch{throw;}}
using System.ServiceProcess;


*private void button3_Click(object sender, EventArgs e)*{AutomationElement mainForm = null;String message = "茜ちゃん、かわいい！やったー！";foreach (var p in Process.GetProcesses()){if (p.MainWindowTitle.Contains("VOICEROID2")){mainForm = AutomationElement.FromHandle(p.MainWindowHandle);}}if (mainForm == null){Debug.WriteLine("起動してない");return;}{var elems = mainForm.FindAll(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.ClassNameProperty, "TextBox"));ValuePattern txtboxName = elems[0].GetCurrentPattern(ValuePattern.Pattern) as ValuePattern;txtboxName.SetValue(message);}{var elems = mainForm.FindAll(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.ClassNameProperty, "Button"));InvokePattern btn = elems[0].GetCurrentPattern(InvokePattern.Pattern) as InvokePattern;btn.Invoke();}AutomationElementCollection stsMessage;do{Thread.Sleep(500);stsMessage = mainForm.FindAll(TreeScope.Element | TreeScope.Descendants,new PropertyCondition(AutomationElement.NameProperty, "テキストの読み上げは完了しました。"));} while (stsMessage.Count == 0);}
UIAutomationを使用します。


*runner.StateMachine = stateMachine;
set after create delegate.


*_connection.Close();
コネクションのクローズ

*_connection = new NpgsqlConnection(_connInfo);
コネクションのオープン

*//EventLog.WriteEntry(EVENT_LOG_NAME, formatQuery, EventLogEntryType.Information, 1, 100, null);*// SQL実行&結果取得
EventLog.WriteEntry(EVENT_LOG_NAME, "RunQuery", EventLogEntryType.Information, 1, 100, null);

*NpgsqlCommand command = new NpgsqlCommand(formatQuery, _connection);*String data = null;
SQL実行&結果取得


*DateTime dt = new DateTime("2021
0423");  エラー


*ConditionExpression = "attribute_not_exists(Id)"
重複時は作成不可

*new TransactWriteItem*{Put = new Put{TableName = "Log",Item = new Dictionary<string, AttributeValue>(){{"Id", new AttributeValue {S = /* ID */ }},{"DateTimeStr", new AttributeValue {S = /* 操作日時 */ }},{"Operation", new AttributeValue {S = /* 操作内容 */ }}}}}
ログテーブルへの書き込み


*private ManualResetValueTaskSourceCore<T> _core;
mutable struct; do not make this readonly

*public ValueTask<int> Enqueue()*{if (_Worker.IsCompleted || _Worker.IsCanceled){throw new Exception("thread already stopped");}var vts = _Pool.Get();vts.SetPool(_Pool);vts.Reset();// System.Threading.ChannelsにIValueTaskSourceのインスタンスを渡すif (!_Channel.Writer.TryWrite(vts)){throw new Exception("failed to write to channel");}return new ValueTask<int>(vts, vts.Version);}
ValueTaskの生成

*async ValueTask Worker()*{try{while (!_Cts.IsCancellationRequested){if (!await _Channel.Reader.WaitToReadAsync().ConfigureAwait(false)){break;}while (!_Cts.IsCancellationRequested && _Channel.Reader.TryRead(out var item)){item.SetResult(1);}}}catch (Exception e){Console.WriteLine(e);}}
ワーカースレッド


*public static void Hoge()*{// ヒープからのアロケーションが発生しないvar s = new S();}
...

*var s = new S();
ヒープからのアロケーションが発生しない

*public static void HogeS<T>(Store<T> s)*{_ = s.Value;}
structをそのまま引数に取る

*public static void HogeI<T>(IStore<T> s)*{_ = s.Value;}
interfaceで受け取る

*HogeS(s);
アロケーションなし

*HogeI(s);
アロケーションあり!

*public static void HogeG<TStore, T>(TStore s)
引数をジェネリックなTStoreに変更
TStoreにIStore<T>制約をかけるためにTも型引数とする必要がある

*HogeS(s);
アロケーションなし

*HogeI(s);
アロケーションあり!

*HogeG<IStore<int>, int>(s);
アロケーションなし

*}
型引数が推論できずにエラー
メソッド 'A.HogeG<TStore, T>(TStore)' の型引数を使い方から推論することはできません。型引数を明示的に指定してください。
HogeG(s);

*public static void HogeG<TStore, T>(TStore s, T __)
Tを引数に取るとTのサイズ分のスタックの確保とコピーが発生してしまう
そもそもTの値をどうやって取得するのかという問題がある

*public static void HogeG<TStore, T>(TStore s, TypeHint<T> __ = default)
第二引数にTypeHint<T>をとるが推論にのみ用いる

*public static TypeHint<T> GetTypeHint<T>(Store<T> _) => default;
Store<T>からTypeHint<T>を取得するメソッド

*HogeG(s, GetTypeHint(s));
型引数を書かなくてよい!!

*var v = GetTypeHint(s).Default;
TypeHintを渡さないと推論できずにエラー...
HogeG(s);
ついでにIStore<T>.Valueの型のデフォルト値の変数を作ることもできる

*public struct TypeHint<T1, T2>*{public TypeHint<T1> Arg1 => default;public TypeHint<T2> Arg2 => default;}
型情報を提供するstruct

*public static void HogeG<TStore1, T1, TStore2, T2>(TStore1 store1, TStore2 store2, TypeHint<T1, T2> __ = default)
二つの異なる型のIStoreを取る

*public static TypeHint<T1, T2> CreateTypeHint<T1, T2>(TypeHint<T1> _, TypeHint<T2> __) => default;
1型引数のTypeHintから2型引数のTypeHintを作る

*HogeG(s1, s2, CreateTypeHint(GetTypeHint(s1), GetTypeHint(s2)));
型引数を書かなくてよい!!

*var s3 = Create((s1, s2));
こんなこともできる


*Chart1.ChartAreas[0].AxisY.Maximum = 5;
最大値指定


*string lserver = $"LDAP:
{LDAPサーバーのIPアドレス}ou=testou,dc=gebogebo,dc=com";


*num = 50.0
3.0;   16.6666...が返る


*subject.OnNext(1);
エラーにならない


*public static float BackCoefficient = 1.0F;
Backの戻る値


*SerialPort serialPort = new SerialPort("COM3", 250000, Parity.None, 8, StopBits.One);
受信Only


*do*{//対象を26で割った余りint amari = index % 26;//対象を26で割った商int sho = index / 26;//割り切れた時（Zを出すため）if (amari == 0){amari = 26;sho--;}//余りの数のアルファベットを出力result = ((char)((int)'A' + amari - 1)).ToString() + result;//商を次の対象とするindex = sho;}
26より大きい場合は繰り返す

*int amari = index % 26;
対象を26で割った余り

*int sho = index / 26;
対象を26で割った商

*result = ((char)((int)'A' + amari - 1)).ToString() + result;
余りの数のアルファベットを出力

*index = sho;
商を次の対象とする

*result = ((char)((int)'A' + index - 1)).ToString() + result;
残りのアルファベットを出力


*void Start()*{dist = Vector3.Distance(transform.position, targ.transform.position);}
Start is called before the first frame update

*void Update()*{transform.position = Vector3.MoveTowards(transform.position, targ.transform.position, dist/30);}
Update is called once per frame


*a * a == b * b + c * c -2 * b * c * Mathf.Cos(θ);
余弦定理


*public interface I利用者を登録するCommand : ICommand*{string 苗字 { get; }string 名前 { get; }I利用者を登録するCommand Create(string _苗字, string _名前);}
↓コマンドの一例.

*await CommandBus.ExecuteAsync(_command);
コマンド実行前に好きなことする.

*}
コマンド終了後に好きなことする.


*void Cry();
鳴き声を出力する

*public class Cat : IAnimal*{public Cat() => Console.WriteLine(" 猫 コンストラクタ");public void Cry() => Console.WriteLine("ニャ～");}
ネコ(IAnimalインターフェースの実装)

*public class Dog : IAnimal*{public void Cry() => Console.WriteLine("バウ！");public Dog() => Console.WriteLine(" 犬 コンストラクタ");}
イヌ(IAnimalインターフェースの実装)

*public class Person*{[Dependency]public IAnimal Pet { get; set; }// ペットを呼ぶpublic void CallPet() => Pet.Cry();}
依存性を注入されるクラス

*public void CallPet() => Pet.Cry();
ペットを呼ぶ


*private int Crynum = 0;
鳴く回数

*public class Person*{// 名前を指定すると、RegisterInstanceで名前を指定したものを使用する//[Dependency("Dog12")]// 名前を指定しないと、RegisterInstanceで名前を指定しておらず、一番後に登録されたものを使用する(あと勝ちで使われるっぽい)[Dependency]public IAnimal Pet { get; set; }// ペットを呼ぶpublic void CallPet() => Pet.Cry();}
依存性を注入されるクラス

*[Dependency]
名前を指定すると、RegisterInstanceで名前を指定したものを使用する
[Dependency("Dog12")]
名前を指定しないと、RegisterInstanceで名前を指定しておらず、一番後に登録されたものを使用する(あと勝ちで使われるっぽい)

*public void CallPet() => Pet.Cry();
ペットを呼ぶ


*Icon = new TaskDialogIcon(this.Icon),ProgressBar = new TaskDialogProgressBar(){State = TaskDialogProgressBarState.Paused},Buttons ={reconnectButton,cancelButton}};
Note however that the task dialog will not scale the icon.

*using (var timer = new Timer(){Enabled = true,Interval = 100}){timer.Tick += (s, e) =>
Create a WinForms timer that raises the Tick event every tenth second.

*initialButtonYes.Click += (sender, e) =>*{initialPage.Navigate(inProgressPage);};
When the user clicks "Yes", navigate to the second page.

*var psi = new ProcessStartInfo("cmd.exe", "/k echo Hi, this is an elevated command prompt."){UseShellExecute = true,Verb = "runas"};
Try to start an elevated cmd.exe.

*var page2 = new TaskDialogPage(){Heading = "AfterNavigation.",Buttons ={TaskDialogButton.Close}};
Navigate to a new page.


*int vtx_num = 0;*foreach(Transform child in gameObject.transform){SkinnedMeshRenderer skin = child.GetComponent<SkinnedMeshRenderer>();vtx_num += skin.sharedMesh.vertices.Length;}
頂点数を数える

*int count = 0;*foreach(Transform child in gameObject.transform){SkinnedMeshRenderer skin = child.GetComponent<SkinnedMeshRenderer>();Mesh child_mesh = skin.sharedMesh;for(int i = 0; i < child_mesh.vertices.Length; i++){float x = child_mesh.vertices[i].x;float y = child_mesh.vertices[i].y;float z = child_mesh.vertices[i].z;vtx_posi_array[count] = new Vector3(x, y, z);count++;}}
頂点座標を取得

*try{filename = filename + ".csv";bool append = false;using(var sw = new System.IO.StreamWriter(@filename, append)){for(int i = 0; i < vtx_posi_array.Length; ++i){sw.WriteLine("{0},{1},{2}", vtx_posi_array[i].x, vtx_posi_array[i].y, vtx_posi_array[i].z);}}}
csvファイルに書き込む


*if (GameSceneManager.IsGameStart) return;*//リワード広告後は無視
ゲーム中は無視

*if (_isRewarding) return;*if (!pauseStatus) _isOpenOfflineEarning = true;
リワード広告後は無視

*if (CalcOfflineEarning() <= 0) return;*SceneManager.LoadSceneAsync(SceneName.OfflineEarningScene, LoadSceneMode.Additive);
もし稼ぎが0ならなし


*[SerializeField] private Animator _masterAnimator;
オークリーダーのAnimator

*private Vector3 _masterStartPosition;
オークリーダーの初期位置

*public readonly Subject<(Vector3, int, float)> MasterInfo = new Subject<(Vector3, int, float)>();
初期位置からの差分, stateNameHash, normalizedTime


*const string uriBase = "https:
westcentralus.api.cognitive.microsoft.comfacev1.0detect";

*string imageFilePath = Console.ReadLine();
画像ファイルパスの入力

*static async void MakeAnalysisRequest(string imageFilePath)*{HttpClient client = new HttpClient();// リクエストヘッダーclient.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", subscriptionKey);// リクエストパラメータstring requestParameters = "returnFaceId=true&returnFaceLandmarks=false" +"&returnFaceAttributes=age,gender,headPose,smile,facialHair,glasses," +"emotion,hair,makeup,occlusion,accessories,blur,exposure,noise";// Face API呼び出し時のURLを作成string uri = uriBase + "?" + requestParameters;HttpResponseMessage response;// ローカルの画像ファイルパスを文字列からバイト型配列へ変換byte[] byteData = GetImageAsByteArray(imageFilePath);using (ByteArrayContent content = new ByteArrayContent(byteData)){// リクエストヘッダーの作成content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");// Face APIの呼び出しresponse = await client.PostAsync(uri, content);// 実行結果からJSONの取得string contentString = await response.Content.ReadAsStringAsync();// JSONの出力Console.WriteLine("\nResponse:\n");Console.WriteLine(JsonPrettyPrint(contentString));Console.WriteLine("\nPress Enter to exit...");}}
Face APIを使用して画像分析を行う

*client.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", subscriptionKey);
リクエストヘッダー

*string requestParameters = "returnFaceId=true&returnFaceLandmarks=false" +
リクエストパラメータ

*string uri = uriBase + "?" + requestParameters;
Face API呼び出し時のURLを作成

*byte[] byteData = GetImageAsByteArray(imageFilePath);
ローカルの画像ファイルパスを文字列からバイト型配列へ変換

*content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");
リクエストヘッダーの作成

*response = await client.PostAsync(uri, content);
Face APIの呼び出し

*string contentString = await response.Content.ReadAsStringAsync();
実行結果からJSONの取得

*Console.WriteLine("\nResponse:\n");
JSONの出力

*static byte[] GetImageAsByteArray(string imageFilePath)*{using (FileStream fileStream =new FileStream(imageFilePath, FileMode.Open, FileAccess.Read)){BinaryReader binaryReader = new BinaryReader(fileStream);return binaryReader.ReadBytes((int)fileStream.Length);}}
ファイルパス上にある画像をバイト配列に変換

*static string JsonPrettyPrint(string json)*{if (string.IsNullOrEmpty(json))return string.Empty;json = json.Replace(Environment.NewLine, "").Replace("\t", "");StringBuilder sb = new StringBuilder();bool quote = false;bool ignore = false;int offset = 0;int indentLength = 3;foreach (char ch in json){switch (ch){case '"':if (!ignore) quote = !quote;break;case '\'':if (quote) ignore = !ignore;break;}if (quote)sb.Append(ch);else{switch (ch){case '{':case '[':sb.Append(ch);sb.Append(Environment.NewLine);sb.Append(new string(' ', ++offset * indentLength));break;case '}':case ']':sb.Append(Environment.NewLine);sb.Append(new string(' ', --offset * indentLength));sb.Append(ch);break;case ',':sb.Append(ch);sb.Append(Environment.NewLine);sb.Append(new string(' ', offset * indentLength));break;case ':':sb.Append(ch);sb.Append(' ');break;default:if (ch != ' ') sb.Append(ch);break;}}}return sb.ToString().Trim();}
JSONの整形を行う


*}
追加


*Debug.Log(this.range);
-> 10


*_music.PlayLooping();
ループ再生


*for (int YAxisIndex = YAxes.Count; YAxisIndex < Signals.Count; YAxisIndex++)
軸インデックスがない場合は追加する

*WpfPlot1.Plot.AxisAuto();
オートスケール

*var AxisLimits = WpfPlot1.Plot.GetAxisLimits();
X軸を表示制限


*GameObject camera_G = new GameObject("OnlyUIRenderingCamera");
カメラ自動生成

*GameObject canvas_G = new GameObject("FaceCanvas");
キャンバス生成＆設定

*Vector3 canvasPosition = canvas_G.transform.position;*canvasPosition.x = 0;
キャンバスのポジションを調整

*faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
レンダリングをfaceCameraに

*GameObject panel_G = new GameObject("FacePanel");
パネル生成＆設定

*panel_G.transform.parent = canvas_G.transform;*//パネルのポジションを正面、スケールをいい感じに調整
パネルをキャンバスの子に設定

*Vector3 panelPosition = panel_G.transform.localPosition;*Vector3 panelScale = panel_G.transform.localScale;
パネルのポジションを正面、スケールをいい感じに調整

*canvas_G.transform.parent = faceCamera.transform;*//Layerを変更
キャンバスをカメラの子に設定

*canvas_G.layer = LayerMask.NameToLayer("UI");
Layerを変更

*Time.fixedDeltaTime = FIXEDUPDATE_DELTATIME;
Fixed Timestepを固定

*[Serializable]
パラメータをひとまとめにしたクラス

*using (new EditorGUI.PropertyScope(position, label, property))*{//ラベル領域の幅を調整EditorGUIUtility.labelWidth = 100;position.height = EditorGUIUtility.singleLineHeight;//各プロパティーの Rect を求めるRect panelColorRect = new Rect(position){y = position.y + EditorGUIUtility.singleLineHeight + 1};Rect fadeTimeRect = new Rect(panelColorRect){y = panelColorRect.y + EditorGUIUtility.singleLineHeight + 2};Rect alpha_PanelRect = new Rect(fadeTimeRect){y = fadeTimeRect.y + EditorGUIUtility.singleLineHeight + 2};//各プロパティーの SerializedProperty を求めるSerializedProperty panelColorProperty = property.FindPropertyRelative("panelColor");SerializedProperty fadeTimeProperty = property.FindPropertyRelative("fadeTime");SerializedProperty alpha_PanelProperty = property.FindPropertyRelative("alpha_Panel");//各プロパティーの GUI を描画panelColorProperty.colorValue =EditorGUI.ColorField(panelColorRect,"フェードの色",panelColorProperty.colorValue);fadeTimeProperty.floatValue= EditorGUI.FloatField(fadeTimeRect, "フェードの時間", fadeTimeProperty.floatValue);alpha_PanelProperty.floatValue = EditorGUI.Slider(alpha_PanelRect, "透明度",alpha_PanelProperty.floatValue, 0, 1);}
元は 1 つのプロパティーであることを示すために PropertyScope で囲む

*EditorGUIUtility.labelWidth = 100;
ラベル領域の幅を調整

*Rect panelColorRect = new Rect(position){y = position.y + EditorGUIUtility.singleLineHeight + 1};
各プロパティーの Rect を求める

*SerializedProperty panelColorProperty = property.FindPropertyRelative("panelColor");
各プロパティーの SerializedProperty を求める

*panelColorProperty.colorValue =EditorGUI.ColorField(panelColorRect,"フェードの色",panelColorProperty.colorValue);
各プロパティーの GUI を描画

*[Serializable]
パラメータをひとまとめにしたクラス

*GameObject camera_G = new GameObject("OnlyUIRenderingCamera");
カメラ自動生成

*GameObject canvas_G = new GameObject("FaceCanvas");
キャンバス生成＆設定

*Vector3 canvasPosition = canvas_G.transform.position;*canvasPosition.x = 0;
キャンバスのポジションを調整

*faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
レンダリングをfaceCameraに

*GameObject panel_G = new GameObject("FacePanel");
パネル生成＆設定

*panel_G.transform.SetParent(canvas_G.transform);*//パネルのポジションを正面、スケールをいい感じに調整
パネルをキャンバスの子に設定

*Vector3 panelPosition = panel_G.transform.localPosition;*Vector3 panelScale = panel_G.transform.localScale;
パネルのポジションを正面、スケールをいい感じに調整

*canvas_G.transform.SetParent(faceCamera.transform);*//Layerを変更
キャンバスをカメラの子に設定

*canvas_G.layer = LayerMask.NameToLayer("UI");
Layerを変更

*Time.fixedDeltaTime = FIXEDUPDATE_DELTATIME;
Fixed Timestepを固定

*using (new EditorGUI.PropertyScope(position, label, property))*{//ラベル領域の幅を調整EditorGUIUtility.labelWidth = 100;position.height = EditorGUIUtility.singleLineHeight;//各プロパティーの Rect を求めるRect panelColorRect = new Rect(position){y = position.y + EditorGUIUtility.singleLineHeight + 1};Rect fadeTimeRect = new Rect(panelColorRect){y = panelColorRect.y + EditorGUIUtility.singleLineHeight + 2};Rect alpha_PanelRect = new Rect(fadeTimeRect){y = fadeTimeRect.y + EditorGUIUtility.singleLineHeight + 2};//各プロパティーの SerializedProperty を求めるSerializedProperty panelColorProperty = property.FindPropertyRelative("panelColor");SerializedProperty fadeTimeProperty = property.FindPropertyRelative("fadeTime");SerializedProperty alpha_PanelProperty = property.FindPropertyRelative("alpha_Panel");//各プロパティーの GUI を描画panelColorProperty.colorValue = EditorGUI.ColorField(panelColorRect, "フェードの色", panelColorProperty.colorValue);fadeTimeProperty.floatValue = EditorGUI.FloatField(fadeTimeRect, "フェードの時間", fadeTimeProperty.floatValue);alpha_PanelProperty.floatValue = EditorGUI.Slider(alpha_PanelRect, "透明度", alpha_PanelProperty.floatValue, 0, 1);}
元は 1 つのプロパティーであることを示すために PropertyScope で囲む

*EditorGUIUtility.labelWidth = 100;
ラベル領域の幅を調整

*Rect panelColorRect = new Rect(position){y = position.y + EditorGUIUtility.singleLineHeight + 1};
各プロパティーの Rect を求める

*SerializedProperty panelColorProperty = property.FindPropertyRelative("panelColor");
各プロパティーの SerializedProperty を求める

*panelColorProperty.colorValue = EditorGUI.ColorField(panelColorRect, "フェードの色", panelColorProperty.colorValue);
各プロパティーの GUI を描画


*GameObject tapObj = EventSystem.current.currentSelectedGameObject;
タップ検知したGameObjectを取得。

*Button btn = tapObj.GetComponent<Button>();
取得したオブジェクトからButtonを取得。

*return btn;
ボタンがnullかどうかを返す。


*LinerDarkRed,
以下、 線形グラデーション

*RadialRedBrush,
以下、放射状グラデーション

*return null;
透明色の場合はnullを返す

*ShaderType = ShaderType.Liner,Colors = new SKColor[] { SKColors.White, SKColors.LightGray, SKColors.Black },ColorPos = new float[] { 0, 0.5f, 1 }};
3色のグラデーションの場合はColorsとColorPosに3つを指定

*ShaderType = ShaderType.Radial,Colors = new SKColor[] { SKColors.White, Color.FromHex("#FFFF2020").ToSKColor() },ColorPos = new float[] { 0, 1 }};
放射状グラデーション

*ShaderType = ShaderType.Radial,Colors = new SKColor[] { SKColors.White, Color.FromHex("#FF2020FF").ToSKColor() },ColorPos = new float[] { 0, 1 }};
放射状グラデーション

*ShaderType = ShaderType.Radial,Colors = new SKColor[] { SKColors.White, SKColors.Yellow },ColorPos = new float[] { 0, 1 }};
放射状グラデーション

*private void SkCanvasView_OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)
コンストラクタとプロパティの定義は省略(詳細はGitHubのソースコード参照)
描画するハンドラ

*Initialized = true;
初期描画済みとする

*canvas.Clear();
canvas上にすでに何かを描画済みであればいったんクリアする(透明色にする)

*SKRect rect = new SKRect(0, 0, info.Width, info.Height);
描画範囲をコントロール全体として指定

*GradientModel gradientModel = GradientModelFactory.Instance.CreateGradientModel(BackGradientColor);
グラデーション設定を取得

*return;
グラデーション設定もグラデーション無しの背景色も、どちらも未設定であれば透明とする

*using (SKPaint paint = CreateSKPaint()){if (gradientModel != null){背景グラデーション用のShaderの設定paint.Shader = CreateShader(gradientModel, rect);
塗りつぶしのグラデーション用のSKPaintを作成

*paint.Shader = CreateShader(gradientModel, rect);
背景グラデーション用のShaderの設定

*paint.Color = BackgroundColor.ToSKColor();
グラデーション設定がない場合はBackgroundColorから取得

*DrawFill(canvas, paint, rect);
背景を描画

*if (StrokeWidth < 0.01) return;*// 枠線用のSKPaintを作成
枠線の太さが0に近ければ枠線は描画しない

*using (SKPaint paint = CreateSKPaint(BorderColor.ToSKColor(), SKPaintStyle.Stroke, StrokeWidth)){枠線を描画DrawStroke(canvas, paint, rect);
枠線用のSKPaintを作成

*DrawStroke(canvas, paint, rect);
枠線を描画

*return (float)Math.Min(rect.Width, rect.Height) / 2 - 1;
円から絶対にはみ出ないように半径は1小さくする

*return SKShader.CreateLinearGradient(new SKPoint(rect.Left, rect.Top),
矩形の場合

*float radius = GetRadius(rect);
円の場合
矩形のサイズから円の半径を算出する

*return SKShader.CreateRadialGradient(new SKPoint(rect.MidX - radius * 0.5f, rect.MidY - radius * 0.5f),
グラデーションの始点位置を中心から左上にずらし、そのずれた分だけ半径を大きくする


*request.Headers.Referrer = new Uri("https:
app.splatoon2.nintendo.nethome");


*return val.ToString() + unit + behind;
★これが、TextBlockに表示される


*RestClient client = new RestClient("http:
ここにURL.co.jp");

*RestRequest request = new RestRequest("/ここにresourceのURL/",Method.POST);
client.Authenticator = new HttpBasicAuthenticator("username", "password"); 認証が必要な場合

*object x = new { query = new { range = new {occurred_at = new {gt = "2017-08-16 16:18:00+0900", lte = "now",format = "yyyy-MM-dd HH:mm:ssZ" } } } };
リクエストJSONは無名で作った方が楽

*var jsonObj = DynamicJson.Parse(response.Content);
ここにドキュメントを処理するコード


*Presentation ppt = new Presentation();
PowePoint Objectを作成します。

*ppt.LoadFromFile(@"Sample.pptx");
ファイルをロードします。

*ppt.SaveToFile("ConvertPPTtoHtml.html", FileFormat.Html);
HTMLで保存します。


*string text = value.Text;
Tweet


*!type.IsPrimitiveRecursiveStruct())
allow System.Int32 to contain a field of its own type


*var config = Configuration.Default.WithCookies().WithDefaultLoader();
Cookieを有効化

*Console.WriteLine(context.Active.Location);
URLを取得
await context.OpenAsync("https:qiita.com/login");
ログイン前のURL表示

*var document = await context.Active.Forms[0].SubmitAsync(new{identity = "Qiitaのユーザー名またはメールアドレス",password = "Qiitaのパスワード"});
submit

*Console.WriteLine(context.Active.Location);
ログイン後のURL表示

*var notifications = document.QuerySelector(".st-Header_notifications");*Console.WriteLine(notifications.InnerHtml);
通知件数取得


*vm.ViewsideAction = this.ViewsideAction;
★スライダーの範囲表示更新処理をViewModelに登録


*適当なクラス.適当なメソッド();
テスト対象メソッドを実行

*File.Copy("ログファイル", "一時的なログファイル", true);
メインのログファイルは読み込めないため、確認用に一時的にコピー

*string line = file.ReadLine();
ファイルの先頭行を読み込み

*Assert.IsTrue(line.Contains("出力されるべきメッセージ"));
ログ内に適切な文言が存在するかどうか


*myXmlDocument.Load(tempSgmlReader);*try{String str = "";XmlNodeList myXmlNodeList = myXmlDocument.ChildNodes;for(int i=0;i<myXmlNodeList.Count;i++){str += EscapeHTML(myXmlNodeList[i]);}Console.WriteLine(str);}catch (Exception ee){Console.Error.WriteLine(ee.ToString());}
myXmlDocument.XmlResolver = null;

*tagStart = "<" + node.Name;
"#"で始まらないノードのみ


*myPlotModel.InvalidatePlot(false);
-- 変更点 ---


*IReadOnlyList<Monster> monsterList = LoadMonsterList();
良い例

*,,,
悪い例
DBから読み場合最後まで読むという無駄な処理が必要
無限なシーケンスだと終わらない
bool isEmptyMonsters = monsterList.Count() == 0;

*IReadOnlyCollection<Monster> maxLevelMonsters = monsterList.MaxBy(it => it.Level);
MaxByは一番大きい要素(複数)を探すメソッド

*IEnumerable<IReadOnlyList<Monster>> bufferedMonsters = monsterList.Buffer(8);
Bufferは先頭から指定数ごとにまとめるメソッド

*IEnumerable<Monster> monsters = monsterListOfList.Flatten();
Flattenは、リストのリストなどをIEnumerable<T>に平滑化するメソッド
「平滑化するよ」ということがメソッド名から伝わる

*bool isEmptyMonster = monsters.IsEmpty();
メソッド名が超わかりやすい!
無限シーケンスでも終わるし、余分な処理しない


*LineSeries.StrokeThickness = 2;
線の太さ

*LineSeries.ItemsSource = Datas;
データを関連付け加

*Datas.Add(new DataPoint(1.0, 0.0));
点を追加

*Model.Series.Add(LineSeries);
グラフをモデルに追加

*Model.InvalidatePlot(true);
セットした内容を反映させる


*return code;
漢字


*int R = (int)redNumericUpDown.Value;
RGB の値を取得

*DrawingPanel(R, G, B);
設定した色をパネルに表示

*CreateHexadecimal(R, G, B);
16進数カラーコードで表示

*var R = Int32.Parse(redTextBox.Text, System.Globalization.NumberStyles.HexNumber);
16進数カラーコードを取得し、16進数を10進数に変換

*DrawingPanel(R, G, B);
設定した色をパネルに表示

*CreateRGB(R, G, B);
RGB で表示

*MessageBox.Show(@"Please check either ""RGB → HexcolorCodes"" or ""HexcolorCodes → RGB""");
チェックボックスの選択に不備があることをメッセージボックスで警告

*DialogResult dialogResult = colorDialog.ShowDialog();
カラーダイアログを表示

*int R = colorDialog.Color.R;
カラーダイアログからRGB の値を取得

*DrawingPanel(R, G, B);
設定した色をパネルに表示

*CreateHexadecimal(R, G, B);
16進数カラーコードで表示

*CreateRGB(R, G, B);
RGB で表示

*colorPanel.BackColor = Color.FromArgb(R, G, B);
パネルに設定された色を表示

*hexcolorCodesRichTextBox.Text = "#" + $"{R:x2}" + $"{G:x2}" + $"{B:x2}";
RGBを16進数に変換し、16進数カラーコードを「hexcolorCodesRichTextBox」に表示

*hexcolorCodesRichTextBox.Select(1, 0);
「hexcolorCodesRichTextBox」に表示されたの文字を色分け

*redNumericUpDown.Value = R;
設定されたRGBをRGBグループの各RGBに表示

*redTextBox.Text = $"{R:x2}";
設定されたRGBをHex color codesグループの各RGBに表示


*this.Items.Filter += obj =>
プログラムの処理によってコンボボックス内のテキストが空に上書きされた場合、ここに入る。
この処理がないと、コンボボックス内のテキストを空に上書きするときにプルダウンが開いてしまう。

*return true;
プルダウン部分へ適用されているフィルターを解除する。

*this.Items.Filter += obj =>*{if (!(obj is ComboBoxItem)){return true;}var item = obj as ComboBoxItem;if (((string)item.Content).Contains(_textBox.Text)){//「選択肢の文字列の中に入力された文字列が含まれる場合」にフィルターを通過させる。// フィルターを通過すると、展開された選択肢の中に表示される。return true;}return false;};
入力がある都度、即時フィルターをかける。

*return true;
「選択肢の文字列の中に入力された文字列が含まれる場合」にフィルターを通過させる。
フィルターを通過すると、展開された選択肢の中に表示される。

*_popUp.IsOpen = true;
コンボボックスの入力欄にフォーカスが当たったとき、プルダウンを展開する。

*PrefecturesComboBox.ItemsSource = new List<Prefecture>()*{new Prefecture(){ Name = "北海道", PrefecturalCapitalCityName = "札幌市"},new Prefecture(){ Name = "青森県", PrefecturalCapitalCityName = "青森市"},// 中略new Prefecture(){ Name = "鹿児島県", PrefecturalCapitalCityName = "鹿児島市"},new Prefecture(){ Name = "沖縄県", PrefecturalCapitalCityName = "那覇市"},};
コンストラクタ内でItemsSourceを積み込むとする。

*new Prefecture(){ Name = "鹿児島県", PrefecturalCapitalCityName = "鹿児島市"},new Prefecture(){ Name = "沖縄県", PrefecturalCapitalCityName = "那覇市"},};
中略

*this.Items.Filter += obj =>*{if (!(obj is ComboBoxItem)){return true;}var item = obj as ComboBoxItem;if (((string)item.Content).Contains(_textBox.Text)){//「選択肢の文字列の中に入力された文字列が含まれる場合」にフィルターを通過させる。// フィルターを通過すると、展開された選択肢の中に表示される。return true;}return false;};
入力がある都度、即時フィルターをかける。

*return true;
「選択肢の文字列の中に入力された文字列が含まれる場合」にフィルターを通過させる。
フィルターを通過すると、展開された選択肢の中に表示される。

*this.Items.Filter += obj =>*{if (!(obj is Prefecture)){return true;}var item = obj as Prefecture;if (item.Name.Contains(_textBox.Text)){//「PrefectureのNameの中に入力された文字列が含まれる場合」にフィルターを通過させる。// フィルターを通過すると、展開された選択肢の中に表示される。return true;}return false;};
入力がある都度、即時フィルターをかける。

*return true;
「PrefectureのNameの中に入力された文字列が含まれる場合」にフィルターを通過させる。
フィルターを通過すると、展開された選択肢の中に表示される。

*this.Items.Filter += obj =>*{if (!(obj is Prefecture)){return true;}var item = obj as Prefecture;// ↓「item.Name」を「item.PrefecturalCapitalCityName」に変えただけif (item.PrefecturalCapitalCityName.Contains(_textBox.Text)){return true;}return false;};
入力がある都度、即時フィルターをかける。


*namespace NetCoreApp1*{class SampleBatch1 : BatchBase{[Command("exec1")]public void Execute(string name1, int repeat1 = 3){for (int i = 0; i < repeat1; i++){this.Context.Logger.LogInformation($"{this.GetType().Name}.Execute from {name1} ({i + 1}/{repeat})");}}}}
起動アセンブリのルート名前空間に定義したバッチクラス

*namespace NetCoreApp1.Batches*{class SampleBatch2 : BatchBase{[Command("exec2")]public void Execute(string name2, int repeat2 = 3) {}}}
起動アセンブリのルート名前空間の配下に定義したバッチクラス

*namespace Batches*{class SampleBatch3 : BatchBase{[Command("exec3")]public void Execute(string name3, int repeat3 = 3) {}}}
起動アセンブリのルート名前空間外に定義したバッチクラス

*namespace BatchLibrary1*{public class SampleBatch4 : BatchBase{[Command("exec4")]public void Execute(string name4, int repeat4 = 3) {}}}
別アセンブリに定義したバッチクラス

*await BatchHost.CreateDefaultBuilder().RunBatchEngineAsync<SampleBatch1>(args);
起動アセンブリのルート名前空間の配下に定義したバッチクラス

*await BatchHost.CreateDefaultBuilder().RunBatchEngineAsync<Batches.SampleBatch2>(args);
起動アセンブリのルート名前空間の配下の名前空間に定義したバッチクラス

*await BatchHost.CreateDefaultBuilder().RunBatchEngineAsync<global::Batches.SampleBatch3>(args);
起動アセンブリのルート名前空間外に定義したバッチクラス

*await BatchHost.CreateDefaultBuilder().RunBatchEngineAsync<BatchLibrary1.SampleBatch4>(args);
別アセンブリに定義したバッチクラス

*public void ExecuteNotCommand(string name, int repeat = 3) {}}},,,
*var from = new EmailAddress(){Name = name,Email = email};
Send email to the customers to confirm the email sent


*String.Format("{0:D6}", i)
iは数字


*LineSeries.StrokeThickness = 2;
線の太さ

*LineSeries.ItemsSource = Datas;
データを関連付け加

*Datas.Add(new DataPoint(1.0, 10.0));
点を追加

*Model.Series.Add(LineSeries);
グラフをモデルに追加

*Model.InvalidatePlot(true);
セットした内容を反映させる


*iwasirigid.AddTorque(Vector3.down * rotationSpeed, ForceMode.Impulse);
左向き、下向きにトルクをかける

*iwasirigid.AddTorque(Vector3.up * rotationSpeed, ForceMode.Impulse);
右向き、下向きにトルクをかける

*iwasirigid.AddTorque(Vector3.down * rotationSpeed, ForceMode.Impulse);
左向き、上向きにトルクをかける

*iwasirigid.AddTorque(Vector3.up * rotationSpeed, ForceMode.Impulse);
右向き、上向きにトルクをかける

*iwasirigid.AddTorque(Vector3.up * rotationSpeed, ForceMode.Impulse);
右向きにトルクをかける

*iwasirigid.AddTorque(Vector3.down * rotationSpeed, ForceMode.Impulse);
左向きにトルクをかける

*iwasirigid.velocity = this.gameObject.transform.forward * speed;*//外積で元に戻す　X軸方向
前に進む

*Vector3 left = this.gameObject.transform.TransformVector(Vector3.left);*Vector3 hori_left = new Vector3(left.x, 0, left.z).normalized;
外積で元に戻す　X軸方向

*Vector3 forward = this.gameObject.transform.TransformVector(Vector3.forward);*Vector3 hori_forward = new Vector3(forward.x, 0, forward.z).normalized;
外積で元に戻す　Z軸方向


*GetComponent<Rigidbody>().rotation = Quaternion.Euler (turn.x, turn.y, turn.z + GetComponent<Rigidbody>().velocity.x * tilt * f);
修正


*m_view.SetListItemCount(m_list.Length);
データ個数を変更して表示を更新する

*m_view.gameObject.SetActive(true);
ScrollViewを非表示にしてる場合は表示するため

*LogHandler data = m_list[index];
Cellの元となるLogデータはLogHandlerを継承したクラスで管理している

*LogCellView itemOriginal;
UIの更新はLogCellViewを継承した各CellごとのComponentで行う


*var ns2 = XNamespace.Get("http:
example.combar");


*acc = accumulator(acc, item);
accumulatorも原因

*public static IEnumerable<TSource> Scan<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, TSource> accumulator)
C# 7では、静的ローカル関数に対応していないのでコンパイルエラー

*static IEnumerable<TSource> Impl(IEnumerable<TSource> source, Func<TSource, TSource, TSource> accumulator)*{var hasSeed = false;var acc = default(TSource);foreach (var item in source){if (!hasSeed){hasSeed = true;acc = item;continue;}acc = accumulator(acc, item);yield return acc;}}
引数として、sourceとaccumulatorを渡す

*public static IEnumerable<TSource> Scan<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, TSource> accumulator)
C# 7では、名前が衝突してコンパイルエラー

*IEnumerable<TSource> Impl(IEnumerable<TSource> source, Func<TSource, TSource, TSource> accumulator)
コンパイルエラー
sourceとaccumulator名前はもう使われているから

*public static IEnumerable<TSource> Scan<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, TSource> accumulator)
C# 7でもC# 8でもコンパイルが通る

*IEnumerable<TSource> Impl(IEnumerable<TSource> sourceImpl, Func<TSource, TSource, TSource> accumulatorImpl)
コンパイルエラーを回避
sourceとaccumulator名前はもう使われているから、sourceImplとaccumulatorImplという名前を使う

*public static IEnumerable<TSource> Scan<TSource>(
C# 7では、名前が衝突してコンパイルエラー
C# 8では、「変数のシャドーイング」が認められ、コンパイルが通る

*IEnumerable<TSource> Impl(IEnumerable<TSource> source, Func<TSource, TSource, TSource> accumulator)*{var hasSeed = false;var acc = default(TSource);foreach (var item in source){if (!hasSeed){hasSeed = true;acc = item;continue;}acc = accumulator(acc, item);yield return acc;}}
C#8では、変数のシャドーイングが認められて、sourceとaccumulatorという名前でもOK


*void RaySelfAbove()*{Vector3 thisPos = this.gameObject.transform.position;Ray ray = new Ray(new Vector3(thisPos.x,thisPos.y+1,thisPos.z), Vector3.down);RaycastHit hit = new RaycastHit();if (Physics.Raycast(ray.origin, ray.direction, out hit, Mathf.Infinity) ){if(hit.collider.gameObject.name == this.gameObject.name){hit.collider.gameObject.layer = LayerMask.NameToLayer("Top");}if(hit.collider.gameObject.name != this.gameObject.name && movaChildBlock.isMove == false){this.gameObject.layer = LayerMask.NameToLayer("Default");}}}
自身の真上から自身に向けてレイを出す

*void OnTriggerEnter(Collider other)*{BoxCollider thisCollider = this.gameObject.GetComponent<BoxCollider>();GameObject otherObj = other.gameObject;BoxCollider otherObjBoxCollider = otherObj.GetComponent<BoxCollider>();//コライダーの大きさを比較して衝突先の方が大きければ移動if (otherObjBoxCollider.size.x > thisCollider.size.x){Vector3 otherObjPos = otherObj.transform.position;moveChildBlock.beforeMovePosition = new Vector3(otherObjPos.x, otherObjPos.y+ thisCollider.size.y*3, otherObjPos.z);moveChildBlock.isMove = false;}}
ブロック同士の衝突時にルール通りの移動かどうか判定する


*if (SentakuID > 2) SentakuID = 0;*if (SentakuID < 0) SentakuID = 2;
一番端にいったら反転


*h(x, y);
OK


*int year = date.Year;
西暦の年


*var connection = @"Server=(localdb)\mssqllocaldb;Database=EFGetStarted.AspNetCore.NewDb;Trusted_Connection=True;ConnectRetryCount=0";
ここ


*var queue = server.DefaultPrintQueue;
A4 縦の用紙を準備

*var area = queue.GetPrintCapabilities().PageImageableArea;
印刷可能領域を取得

*var page = new FixedPage();
用紙いっぱいにイメージを配置

*PrintQueue.CreateXpsDocumentWriter(queue).Write(page, ticket);
デフォルトプリンタで印刷


*List<XpsDocument> sourceXps = new List<XpsDocument>();
ソースドキュメントの準備

*var name = destinationPath;
出力先

*XpsDocumentWriter writer = XpsDocument.CreateXpsDocumentWriter(destXps);
ライター

*writer.Write(seq);
終了処理


*else Bullet_List[Obj_No].SetActive(true);
Listにあればそのオブジェクトをアクティブに

*return Bullet_List[Obj_No];
使うオブジェクトを返す

*rid2d = GetComponent<Rigidbody2D>();
Rigidbody取得

*Vector2 ShotPos = transform.position;*//10フレームに1回発射
自身の座標取得

*WaitFrame++;*if (WaitFrame > 10) {shotmenu.n_way_Shot(20, 5, 30, ShotPos);WaitFrame = 0;}
10フレームに1回発射

*float diffusion_angle = PI * (Degree / 180);*//弾インスタンスに渡す角度の計算
n-way弾の端から端までの角度

*if (Angle_Split > 1)*Theta = (diffusion_angle / (Angle_Split - 1)) * i - 0.5f * diffusion_angle;
弾インスタンスに渡す角度の計算

*GameObject Bullet_obj = objp.poolBullet(shotPos);
弾の座標を撃つ場所に

*Bullet_Sc bullet_cs = Bullet_obj.GetComponent<Bullet_Sc>();
いろいろ弾に渡す部分


*hoge(tmp);
参照型なのでコピーは発生しない


*var req = WebRequest.Create("http:
localhost:3000Post");


*[SerializeField]
花火の種のParticleSystem

*particleNum--;
音源再生の処理


*void ControllerInputSingle()*{holdAnime.SetFloat("holdRate", squeezeVal);holdAnime.Play("Hold", 0, squeezeVal);float animeSpeed = holdAnime.speed;if (holdAnime.GetFloat("holdRate") < 0.1){holdAnime.speed = 0;}else{holdAnime.speed = animeSpeed;}}
コントローラの入力(0~1)


*public ScoreData(string name, int score)*{this.name = name;this.score = score;}
↓追加する．

*static ScoreData[] BubbleSort(ScoreData[] scoreDatas)*{var ary = new ScoreData[scoreDatas.Length];for (int i = 0; i < scoreDatas.Length; i++){ary[i] = scoreDatas[i];}for (int i = 1; i < ary.Length; i++){for (int j = ary.Length - 1; j >= i; j--){if (ary[j - 1].score > ary[j].score){ScoreData temp = ary[j - 1];ary[j - 1] = ary[j];ary[j] = temp;}}}return ary;}
ソート関数


*static MyDebugEditor()*{EditorApplication.playModeStateChanged += OnPlayMode;}
コンストラクタでPlayMode,EditModeの切り替え時の処理を登録

*rootClass.ResetPosition();
ポジションをもとに戻す処理を書いたメソッド

*public void ResetPosition()*{this.gameObject.transform.position = thisObjPos;}
Editor上でのみ使うメソッド。座標を開始位置まで戻す

*public void Fall()*{if (runCoroutine == null){runCoroutine = StartCoroutine(MoveCoroutine());}}
利用時はこれを呼ぶ

*#if UNITY_EDITOR*[CustomEditor(typeof(MyDebug))]
ここからEditor拡張

*static MyDebugEditor()*{EditorApplication.playModeStateChanged += OnPlayMode;}
コンストラクタでPlayMode,EditModeの切り替え時の処理を登録

*rootClass.thisObjPos = rootClass.gameObject.transform.position;*rootClass.isStart = true;
開始位置の座標保存


*IEnumerable<string> intermediateDirectories =
傘の下の中間ディレクトリーたち。こいつらが消える。

*PathFlat.VisitIntermadiateDirectory(intermediateDir);
再帰呼出し。

*Trace.WriteLine($"GoRename: {directoryLikeUmbrella}.");
傘の直下のファイルは既にフラットなのでやる必要なし。
ここまでで、フラットになっている。
ファイルの頭に、傘を付けていく。

*// Ｃ＃のメソッド名は、ノード名なのか、フルパスなのか、はっきりわかるように名付けてほしい。最後のノード名は、ファイル名を取るメソッドで代用した。*var joinedName = $"{directoryLikeUmbrella}\\{Path.GetFileName(directoryLikeUmbrella)}$%{Path.GetFileName(fileName)}";
親ディレクトリーの下に、親ディレクトリーの名前と、主体のファイル名を $% でくっつけたものを置く。

*var joinedName = $"{directoryLikeUmbrella}\\{Path.GetFileName(directoryLikeUmbrella)}$%{Path.GetFileName(fileName)}";
Ｃ＃のメソッド名は、ノード名なのか、フルパスなのか、はっきりわかるように名付けてほしい。最後のノード名は、ファイル名を取るメソッドで代用した。

*new TraceableFile(fileName).Move(new TraceableFile(joinedName));
リネーム☆ 運用で衝突を避けるが、衝突すれば Move が例外を投げる。

*IEnumerable<string> moreIntermediateDirectories =
もっと中間ディレクトリーたち。

*PathFlat.VisitIntermadiateDirectory(moreIntermediateDir);
再帰呼出し。

*IEnumerable<string> files =
この階層のファイル。これを残す。

*var joinedName = $"{Directory.GetParent(file.FullName).Name}$%{Path.GetFileName(file.FullName)}";
親ディレクトリーの名前と、主体のファイル名を $% でくっつける。

*var parentParentDirectory = Directory.GetParent(Directory.GetParent(file.FullName).FullName).FullName;
親の親ディレクトリーのフル名。（なければ例外）

*Trace.WriteLine($"parentParentDirectory: '{parentParentDirectory}', joinedName: '{joinedName}'.");
親の親ディレクトリーの下に さっきくっつけた名前。衝突したら Move が例外を投げる。

*file.Move(destination);
古い名前から、新しい名前へ移動。


*string assemblyFileName = url.Substring(0, url.IndexOf(':'));
メソッドの指定はAssemblyFileName:NameSpace.ClassName.MethodNameで指定されるものとする。

*Assembly asm = Assembly.Load(assemblyFileName);
クラスを呼び出す前にアセンブリをロードする

*Type type = asm.GetType(fullObjectName);
名前空間も含んだフルパスでオブジェクト名を指定する

*object ret = type.InvokeMember(methodName, BindingFlags.InvokeMethod, null, null,new object[]{ arg1,arg2,... });
静的メソッドはInvokeMemberで呼び出す。引数は最後のオブジェクト配列で渡す

*return ret;
戻り値はobject型になるので適切な型にキャストして返すこと


*public RECT WorkingArea;
Exclude TaskBar

*if (object.ReferenceEquals(c1, c2))
nullの確認（構造体のようにNULLにならない型では不要）
両方nullか（参照元が同じか）
(c1 == c2)とすると、無限ループ

*(c1 == null)とすると、無限ループif (((object)c1 == null) || ((object)c2 == null)){return false;
どちらかがnullか

*public String ClassName;
ウィンドウの情報

*public int BelongMonitor;
モニターとの関係

*Common.EnumWindows(EnumWindowCallBack, (IntPtr)null);
すべてのウィンドウを列挙する

*int textLen = Common.GetWindowTextLength(hWnd);
ウィンドウのタイトルの長さを取得する

*StringBuilder tsb = new StringBuilder(textLen + 1);
ウィンドウのタイトルを取得する

*StringBuilder csb = new StringBuilder(256);
ウィンドウのクラス名を取得する

*var rc = new RECT();
ウィンドウ位置を取得する

*WINDOWPLACEMENT wp = new WINDOWPLACEMENT();
ウィンドウ情報を取得する


*bool OnTouch()*{if (0 < Input.touchCount){Touch touch= Input.GetTouch(0);if (touch.phase == TouchPhase.Began){//タッチした位置からRayを飛ばすRay ray = Camera.main.ScreenPointToRay(touch.position);RaycastHit hit = new RaycastHit();if (Physics.Raycast(ray, out hit)){if (hit.collider.gameObject == this.gameObject){return true;}}}}return false;}
タッチされたらtrueを返す

*Ray ray = Camera.main.ScreenPointToRay(touch.position);
タッチした位置からRayを飛ばす

*public void OpenURL(string url)*{Application.OpenURL(url);}
URLを開く

*public void Explosion(GameObject obj)*{obj.SetActive(true);}
爆発


*null,
変更時イベントハンドラ

*private void SkCanvasView_OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)*{SKImageInfo info = e.Info;SKSurface surface = e.Surface;SKCanvas canvas = surface.Canvas;canvas.Clear();// 描画範囲をコントロール全体として指定SKRect rect = new SKRect(0, 0, info.Width, info.Height);// グラデーション設定を取得GradientModel gradientModel = GradientModelFactory.Instance.CreateGradientModel(BackGradientColor);if (gradientModel == null){return;}// 塗りつぶしのグラデーション用のSKPaintを作成SKPaint paint = new SKPaint{IsAntialias = true,Style = SKPaintStyle.Fill,Shader = SKShader.CreateLinearGradient(new SKPoint(rect.Left, rect.Top), new SKPoint(rect.Left, rect.Bottom),gradientModel.Colors, gradientModel.ColorPos, SKShaderTileMode.Clamp)};// 背景を描画canvas.DrawRoundRect(rect, CornerRadius, CornerRadius, paint);// 枠線用にSKPaintを変更paint.Style = SKPaintStyle.Stroke;paint.Shader = null;paint.Color = BorderColor.ToSKColor();paint.StrokeWidth = StrokeWidth;// 枠線の描画canvas.DrawRoundRect(rect, CornerRadius, CornerRadius, paint);// 初期描画済みInitialized = true;}
描画するハンドラ

*SKRect rect = new SKRect(0, 0, info.Width, info.Height);
描画範囲をコントロール全体として指定

*GradientModel gradientModel = GradientModelFactory.Instance.CreateGradientModel(BackGradientColor);
グラデーション設定を取得

*SKPaint paint = new SKPaint{IsAntialias = true,Style = SKPaintStyle.Fill,Shader = SKShader.CreateLinearGradient(new SKPoint(rect.Left, rect.Top), new SKPoint(rect.Left, rect.Bottom),gradientModel.Colors, gradientModel.ColorPos, SKShaderTileMode.Clamp)};
塗りつぶしのグラデーション用のSKPaintを作成

*canvas.DrawRoundRect(rect, CornerRadius, CornerRadius, paint);
背景を描画

*paint.Style = SKPaintStyle.Stroke;
枠線用にSKPaintを変更

*canvas.DrawRoundRect(rect, CornerRadius, CornerRadius, paint);
枠線の描画

*Initialized = true;
初期描画済み

*private static void BackGradientColorPropertyChanged(BindableObject bindable, object oldValue, object newValue)*{if (bindable == null || newValue == null ||newValue.GetType() != BackGradientColorProperty.ReturnType){return;}GradientRect gradientRect = (GradientRect)bindable;// 初期描画前であれば何もしないif (gradientRect.Initialized == false){return;}// 再描画するgradientRect._SkCanvasView.InvalidateSurface();}
BackGradientColor変更後ハンドラ

*gradientRect._SkCanvasView.InvalidateSurface();
再描画する

*public enum Status*{ToDo,Doing,Done,}
ステータスを表すenum

*public class StatusToGradientColorConverter : IValueConverter*{public object Convert(object value, Type targetType, object parameter, CultureInfo culture){var status = (Status)value;switch (status){case Status.ToDo:return GradientColor.DarkRed;case Status.Doing:return GradientColor.DarkYellow;case Status.Done:return GradientColor.LightBlue;default:throw new Exception("Invalid status");}}public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture){throw new NotImplementedException();}}
StatusをGradientColorに変換するコンバーター


*System.Math.Atan2( 0.0,  0.0);
0


*public RxProg()*{// Observerを登録subj.DistinctUntilChanged().Where((f) => f == 0).Take(1).Subscribe(ProcInit);subj.DistinctUntilChanged().Where((f) => f >= 0).Take(1).Subscribe(Proc0Frame);subj.DistinctUntilChanged().Where((f) => f >= 5).Take(1).Subscribe(Proc5Frame);subj.DistinctUntilChanged().Where((f) => f >= 7).Take(1).Subscribe(Proc7or11Frame);subj.DistinctUntilChanged().Where((f) => f >= 11).Take(1).Subscribe(Proc7or11Frame);subj.DistinctUntilChanged().Where((f) => f > 15).Take(1).Subscribe(ProcFinal, (ex) => { }, () => { this.subj.Dispose(); });}
コンストラクタ

*subj.DistinctUntilChanged().Where((f) => f == 0).Take(1).Subscribe(ProcInit);
Observerを登録

*Action<int> ProcInit = (f) => { Console.WriteLine("Initialize"); };
ジェネリックデリゲートに処理を用意（直接ラムダ式でSubscribeに入れてもOK）

*MoveFrame();
フレーム更新

*subj.OnNext((int)GetFrameNow());
イベント通知


*private static readonly string[] folders = new string[]{"Scenes","Prefabs","Scripts","Animations","Materials","PhysicsMaterials","Fonts","Textures","Audios","Resources","Editor","Plugins",};
フォルダー名の一覧

*var target = EditorUtility.OpenFolderPanel("Select Project Folder", Application.dataPath, "Project");
作成先となるフォルダーのパスを取得

*AssetDatabase.Refresh();
エディターの更新


*}
エラー処理

*HttpResponseMessage res = await client.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead);
1. GETでデータ取得
string uri = "http:localhost:50984/WebService/WebService.asmx/GetBinaryOfZip?userId=1";

*string outputFilePath = "C:\temp\test.zip"using (var fs = new FileStream(@outputFilePath, FileMode.Create, FileAccess.Write)){3. 受信データの中身を読み込むvar resXml = await res.Content.ReadAsStringAsync();
2. 保存するzipファイルのストリームをオープン

*var resXml = await res.Content.ReadAsStringAsync();
3. 受信データの中身を読み込む

*byte[] zipBinary =System.Convert.FromBase64String(xmlDoc.GetElementsByTagName("base64Binary")[0].InnerText);
4. Webサービスから取得したBase64文字列をバイト型配列に変換

*await fs.WriteAsync(zipBinary, 0, zipBinary.Length);
5. ファイルに書き込む

*using (var zipArchive = new System.IO.Compression.ZipArchive(ms, ZipArchiveMode.Create, true)){string entryName = userId + "_test.jpg";
メモリストリーム上にZipArchiveを作成する

*System.IO.Compression.ZipArchiveEntry entry = zipArchive.CreateEntry(entryName);
ファイル名を指定してエントリを作成

*es.Write(buffer, 0, buffer.Length);
エントリにバイナリを書き込む


*pixels[4 * i + 3] = (byte)255;
alpha

*int stride = width * 4;
バイト列をBitmapImageに変換する

*MainViewDispatcher.BeginInvoke(new Action(() =>
TaskはUIスレッドと別のスレッドのため、ビットマップにバインドしたプロパティの操作はUIスレッドでやってもらう
そのために、Dispatcherを使う


*public ListViewRecordColumn[] records {
追加

*private SforceService binding;*public Form1()
bindingオブジェクト

*binding = new SforceService();*binding.Timeout = 30000;
初期化

*MessageBox.Show(e.Code + ":" + e.Message);
失敗

*return false;
パスワード失効
binding.setPassword(userId, newPassword) で更新が必要

*binding.SessionHeaderValue = new SessionHeader();
エンドポイント更新
string authEndPoint = binding.Url;       初期化時のログイン認証URL
binding.Url = loginResult.serverUrl;     認証後のサービス用URL
セッションヘッダ追加

*GetUserInfoResult userInfo = loginResult.userInfo;
結果表示

*String soqlQuery = "SELECT Id, FirstName, LastName, Account.Name FROM Contact";
SOQL発行
リレーション項目も取得可能(取引先担当者が所属する取引先名Account.Name)

*QueryResult qr = binding.query(soqlQuery);
デフォルトだと500件までしか取れない

*break;
おわり

*qr = binding.queryMore(qr.queryLocator);
500件以上存在する場合、次の500件を取得

*MessageBox.Show(ex.Message);
エラー

*sObject[] upserts = new Contact[1];
更新対象配列作成(テストなので適当)

*c0.CustomDate__cSpecified = true;*c0.CustomDate__c = System.DateTime.Now;
カスタム項目を扱う場合、指定フラグを立てる必要がある

*UpsertResult[] upsertResults = binding.upsert("Email", upserts);
Email一致の場合UPDATE、それ以外の場合INSERT


*var folderPath = System.Environment.GetFolderPath(System.Environment.SpecialFolder.Personal);
Androidのファイル・ディレクトリ取得


*Console.WriteLine(i);
=> 10

*public void value1( int x ) {x = 10;}
値型の値渡し

*public void value2( ref int x ) {x = 10;}
値型の参照渡し


*int fs = 1800;
サンプリング周波数

*output[i] = input[reverseBitArray[i]];
バタフライ演算のための置き換え

*private static int[] BitScrollArray(int arraySize)*{var result = new int[arraySize];var halfSize = arraySize >> 1;result[0] = 0;for (int i = 1; i < arraySize; i <<= 1){for (int j = 0; j < i; j++) result[j + i] = result[j] + halfSize;halfSize >>= 1;}return result;}
ビットを左右反転した配列を返す


*ChildRects = GetComponentsInChildren<RectTransform>().Where(x=>x != MyRect).Where(x=>x.GetComponent<LayoutElement>() == null ? true : !x.GetComponent<LayoutElement>().ignoreLayout).ToArray();*_LayoutGroup = GetComponent<VerticalLayoutGroup>();
自身のRectTransformと子のLayoutElementでignoreLayoutのものは除外する


*graphics.MeasureString(item.ToString() , this.Font).Width);
ドロップダウンリストの内容の幅を取得している


*string to_file_path_;
コピーするファイルパスを決定するぞい

*to_file_path_ = Path.GetDirectoryName(from_file_path_) + @"\";
元ファイルと同じフォルダーにコピーします

*to_file_path_ += DateTime.Now.ToString("yyyyMMdd_HHmm");
ファイル名は現在時刻を元に決定
2021年05月01日18時25分なら『20210501_1825』

*to_file_path_ += Path.GetExtension(from_file_path_);
拡張子は元ファイルから引き継ぎます

*File.Copy(from_file_path_, to_file_path_);
ファイルコピー実行！


*void Update() {_wait -= Time.deltaTime;if (_wait <= 0f) {_wait = _bpm / 60f;_ring.Play();}}
Updateは60FPSで回っているとします


*[SerializeField] GameObject center;
円運動の中心となるGameObject

*float speed = 20;
円運動の速度

*void Update () {//RotateAround(円運動の中心,進行方向,速度)transform.RotateAround(center.transform.position,transform.forward, speed * Time.deltaTime);}
Update is called once per frame

*transform.RotateAround(center.transform.position,*transform.forward, speed * Time.deltaTime);
RotateAround(円運動の中心,進行方向,速度)

*[SerializeField] Rigidbody rbody;
円運動させたい物体。Rigidbodyをコンポーネントさせておく

*private float speed =1.0f;
速度を設定

*private float radius =2.0f;
半径を設定

*float movex;
float型を定義しておく

*void Update () {//movex(Sin波）・moveZ座標(Cos波）の指定をしておく。わからないときは三角関数を調べる。movex = radius * Mathf.Sin(Time.time * speed);movez = radius * Mathf.Cos(Time.time * speed);//Rigidbodyのオブジェクトを移動。rbody.MovePosition(new Vector3(movex, transform.position.y, movez));}
Update is called once per frame

*movex = radius * Mathf.Sin(Time.time * speed);
movex(Sin波）・moveZ座標(Cos波）の指定をしておく。わからないときは三角関数を調べる。

*rbody.MovePosition(new Vector3(movex, transform.position.y, movez));*}
Rigidbodyのオブジェクトを移動。


*GameObject[] Bullet = new GameObject[2304];
とりあえずの配列数144*16

*float AngleRange = PI * (Degree / 180);
n-way弾流用。360度方向にだす

*_theta = (AngleRange / (Angle_Split - 1)) * i + 0.5f * (PI - AngleRange);
弾インスタンスに渡す角度の計算

*GameObject Bullet_obj = poolBullet();
弾インスタンスからスクリプト取得

*bullet_cs.Bulletmove_flag = true;
アクティブになったフラッグ

*bullet_cs.Lpos = transform.position;*bullet_cs.theta = _theta;
角度と初速に加えて、ランチャーの座標も渡す(消滅までの距離測るため)

*int Obj_No = -1;
プールから使うオブジェクトのナンバー。初期化はｰ1

*int Obj_Cnt = transform.childCount;*//for文で調べる非アクティブのオブジェクトがあれば抜ける
プールの中のオブジェクトの数

*return Bullet[Obj_No];
使うオブジェクトを返す

*rid2d = GetComponent<Rigidbody2D>();
Rigidbody取得

*Vector2 bulletV = rid2d.velocity;
角度を考慮して弾の速度計算

*Vector2 Bpos = transform.position;*float Distance_to_Luncher = Vector2.Distance(Bpos, Lpos);
弾の座標とランチャーから送られてきた座標で距離を計算

*if (Distance_to_Luncher >= 50) Object_false();*}
今回はランチャーからの距離が消滅の条件

*void Object_false() {transform.position = Lpos;gameObject.SetActive(false);}
非アクティブになる前に座標をリセット


*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"


*void Start()*{Debug.Log(DLL.add_function(1, 1));}
Start is called before the first frame update


*controller = new Controller();
LeapMotionのコントローラー

*var handsStream = this.UpdateAsObservable().Select(_ => controller.Frame().Hands);
LeapMotionから手の情報を取得

*var beginDoubleRockGripStream = handsStream.Where(hands => IsDoubleRockGrip(hands));
両手グー開始判定ストリーム

*var endDoubleRockGripStream = handsStream.Where(hands => !IsDoubleRockGrip(hands));
両手グー終了判定ストリーム

*beginDoubleRockGripStream
カメラ拡縮

*beginDoubleRockGripStream
カメラ回転

*beginDoubleRockGripStream
カメラ移動

*hands.Count == 2 &&
両手なら

*hands[0].Fingers.ToArray().Count(x => x.IsExtended) == 0 &&
１つ目の手の指の内、開いている数が0個なら

*hands[1].Fingers.ToArray().Count(x => x.IsExtended) == 0;
２つ目の手の指の内、開いている数が0個なら

*beginDoubleRockGripStream
カメラ拡縮

*.Select(hands => hands[0].PalmPosition.DistanceTo(hands[1].PalmPosition))
両手の距離を計算

*.Where(distance => distance > 0.0f)
距離が正の値なら（0割防止）

*.Buffer(2, 1)
バッファに前回と今回の２つの値を詰める

*.Select(distances => distances[1] / distances[0])
今回と前回の商から距離の変化量を計算

*.TakeUntil(endDoubleRockGripStream).RepeatUntilDestroy(this)
両手グーが終了したらバッファをクリアにする

*.Where(distanceRate => distanceRate > 0.0f)
距離変化割合が正の値なら（0割防止）

*.Subscribe(distanceRate => transform.localScale /= distanceRate);*,,,
カメラを拡縮

*beginDoubleRockGripStream
カメラ回転

*.Select(hands => ToVector3(hands[1].PalmPosition - hands[0].PalmPosition))
両手の差ベクトルを計算

*.Where(diff => diff.magnitude > 0.0f)*// バッファに前回と今回の２つの値を詰める
距離が正の値なら（0割防止）

*.Buffer(2, 1)
バッファに前回と今回の２つの値を詰める

*.Select(diffs => Quaternion.AngleAxis(Vector3.Angle(diffs[0], diffs[1]), Vector3.Cross(diffs[1], diffs[0])))*// 両手グーが終了したらバッファをクリアにする
方向の変化量（クォータニオン）を内積と外積から計算

*.TakeUntil(endDoubleRockGripStream).RepeatUntilDestroy(this)
両手グーが終了したらバッファをクリアにする

*.Subscribe(quaternion => transform.rotation *= quaternion);*,,,
カメラを回転

*beginDoubleRockGripStream
カメラ移動

*.Select(hands => ToVector3((hands[0].PalmPosition + hands[1].PalmPosition) * 0.5f))
両手のひらの中点の位置を取得

*.Buffer(2, 1)
バッファに前回と今回の２つの値を詰める

*.Select(positions => positions[1] - positions[0])
今回と前回の差から中点の移動ベクトルを計算

*.TakeUntil(endDoubleRockGripStream).RepeatUntilDestroy(this)
両手グーが終了したらバッファをクリアにする

*.Subscribe(movement => transform.Translate(-speed * movement));*,,,
カメラを移動


*if (e.KeyData == (Keys.Control | Keys.Shift | Keys.T))
Ctrl+Shift+Tを捕まえたい


*new Claim(ClaimTypes.NameIdentifier, Input.Email),
ユニークID

*var claimsIdentity = new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme);
一意の ID 情報

*await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme,new ClaimsPrincipal(claimsIdentity),
ログイン

*IsPersistent = Input.RememberMe});
Cookie をブラウザー セッション間で永続化するか？（ブラウザを閉じてもログアウトしないかどうか）


*public enum Type*{Cube,Ball,}
列挙型：種類を列挙


*StartCoroutine(SpawnWaves());
敵の生成を開始


*var r_stickForce = m_joyconR.GetStick();
Updateの中

*var currentPosition = _camera.position;
_camera = カメラPrefabのRootObject

*var q = m_joyconR.GetVector().eulerAngles;
_right = バットのTransform
JoyconとUnityの角度の表し方がは違うらしいがこれで縦持ちでしっくり来る

*_rightCollider.OnCollisionEnterAsObservable().TakeUntilDestroy(this).Subscribe(
_rightCollider = バットのCollider

*return;
家具に当たったときの判定がめんどくさいのでキャラのパーツすべてにGameControllerのタグを付ける

*_animator.enabled = false;
キャラのAnimatorをdisable。本来ならcollision.gameObjectからどうにかして引っこ抜く。

*var rigid = collision.gameObject.GetComponent<Rigidbody>() ?? collision.gameObject.AddComponent<Rigidbody>();
そのComponentがないときにGetComponentするとnullが返ってくるのでその場合はAddComponentする。
トリッキーなコードなので使ったらだめ。


*ICharQueue iq;
インターフェース参照用変数

*iq = sq;
SimpleQueueオブジェクトを参照する

*iq.Enqueue((char)('A' + i));
参照先のクラスを意識せずメソッドを呼びだせる

*tempCh = iq.Dequeue();
参照先のクラスを意識せずメソッドを呼びだせる

*iq = lq;
ListQueueオブジェクトを参照する

*iq.Enqueue((char)('A' + i));
参照先のクラスを意識せずメソッドを呼びだせる

*tempCh = iq.Dequeue();
参照先のクラスを意識せずメソッドを呼びだせる


*void Awake() {Debug.Log("パターン1（Awakeで初期化）");var gameCharacter = new GameObject("GameCharacter");gameCharacter.AddComponent<GameCharacter>();Debug.Log("Game Start!");}
ゲーム開始時にキャラクターを生成する

*void Awake() {Debug.Log("Initializing GameCharacter");throw new System.Exception("GameCharacter: Initialization failed");}
だがそいつは初期化時にエラーを起こしてしまう死のキャラクターだった！

*void Awake() {Debug.Log("パターン2（Initメソッドで初期化）");var gameCharacter = new GameObject("GameCharacter");gameCharacter.AddComponent<GameCharacter>().Init();Debug.Log("Game Start!");}
ゲーム開始時にキャラクターを生成する

*public void Init() {Debug.Log("Initializing GameCharacter");throw new System.Exception("GameCharacter: Initialization failed");}
だがそいつは初期化時にエラーを起こしてしまう死のキャラクターだった！

*try {var gameCharacter = new GameObject("GameCharacter");gameCharacter.AddComponent<GameCharacter>();} catch {Debug.LogWarning("キャラクター生成できなかったけどいいよね？");}
パターン1 + try-catch

*try {var gameCharacter = new GameObject("GameCharacter");gameCharacter.AddComponent<GameCharacter>().Init();} catch {Debug.LogWarning("キャラクター生成できなかったけどいいよね？");}
パターン2 + try-catch


*string  _UploadFile
アップロードファイル名

*_sftp.ChangeDirectory(_UploadPath);
カレントディレクトリ変更

*var _RemotePath = _UploadPath + "/" + Path.GetFileName(_UploadFile);
アップロード先パス


*string url = "https:
www.google.co.jp";


*httpClient.BaseAddress = new Uri($"https:
{hostName}");

*var databaseAccount = await documentClient.GetDatabaseAccountAsync();
適当

*public class SampleContext : DbContext*{public SampleContext(DbContextOptions<SampleContext> options): base(options){ }public DbSet<Sample> Samples { get; set; }}
適当

*dbContext.Database.OpenConnection();
適当


*substitute.GetIntValue().Returns(1);
例） IsomeInterfaceのGetIntValue()メソッドの結果を1に差し替える

*var substitute = Substitute.For<ISomeInterface>();
あかーん例


*EditorGUILayout.Space();
少しスペースを空ける

*EditorGUILayout.Space();
少しスペースを空ける

*}
押下時の処理


*return Task.FromResult(new TestResponse { Value = request.Value });
リクエストされた値をおうむ返ししているだけです

*obj => MessagePack.MessagePackSerializer.Serialize<T>(obj)
バイト配列へのシリアライズ

*, bytes => MessagePack.MessagePackSerializer.Deserialize<T>(bytes)
バイト配列からのデシリアライズ

*MethodType.Unary
RPCメソッドの種類

*, "TestService"
サービス名

*, "GetResponse"
メソッド名

*, requestMarshaller
リクエスト／レスポンスのマーシャラー

*TestService service = new TestService()RPCメソッドを追加TestRpcMethods はRPCメソッドの定義（Method<TRequest, TResponse>）をまとめたクラスです
サービスメソッドへの参照を必要とするため、サービスクラスのインスタンスを生成

*ServerServiceDefinition.Builder builder = ServerServiceDefinition.CreateBuilder();
RPCメソッドを追加
TestRpcMethods はRPCメソッドの定義（Method<TRequest, TResponse>）をまとめたクラスです

*ServerServiceDefinition definition = builder.Build();
ビルド

*definition = definition.Intercept(CreateInterceptorA()).Intercept(CreateInterceptorB());
インターセプターを設定するならここで設定する

*server.Start();
開始

*invoker = invoker.Intercept(CreateInterceptorA()).Intercept(CreateInterceptorB());
インターセプターを設定するならここで設定する

*return Invoker.BlockingUnaryCall(TestRpcMethods.GetResponse, "", options, request);
TestRpcMethods はRPCメソッドの定義（Method<TRequest, TResponse>）をまとめたクラスです


*", SampleHz=" + wh.nSamplesPerSec.ToString();
サンプリング周波数(44.1kHzとか48kHzとか)


*rectTransform.DOLocalMoveX(-100, 0.40f).SetRelative();
0.4秒かけて現在地からみて-100に移動する

*transform.DOMove(new Vector3(, , ), 1).SetRelative();*,,,
ちなみに3Dオブジェクトなら　DOMoveを使用する

*gameObj.GetComponent<ScrollBar>.value = 1.0f;
ダメなやり方

*gameObj.GetComponent<ScrollRect>.verticalNormalizedPosition = 1.0f;
正しいやり方

*,,,
DOTween使用
canvasGroup.DOFade(0, 1.0f); 1.0f秒かけながら、alpha0になっていく

*private float gameObjInitX;
初期位置格納用

*void Awake()*{gameObjInitX = gameObj.GetComponent<RectTransform>().anchoredPosition.x;gameObjInitY = gameObj.GetComponent<RectTransform>().anchoredPosition.y;}
最初に初期位置の取得

*private void Initialize()*{gameObj.GetComponent<RectTransform>().anchoredPosition = new Vector2(gameObjInitX, gameObjInitY);}
初期位置に戻したいときに呼ぶ

*float width = rectTransform.sizeDelta.x;*float height = rectTransform.sizeDelta.y;
幅と高さを取得

*rectTransform.sizeDelta = new Vector2 (width + 加えたい幅, height);*,,,
今の幅+足したい幅

*public Image _image;
インスペクタからアタッチ

*_image.sprite = _sprite;
_iamgeの画像を_spriteに変更


*}
end of class C


*Button button1 = FindViewById<Button>(Resource.Id.button1);
ボタンを取得し、イベントを設定する（ボタンのidとして設定されているbutton1を指定）

*Toast.MakeText(Application.Context, "click " + DateTime.Now.ToString(), ToastLength.Long).Show();
通知出力


*var folder = GetCalenderFolder(mailOrName);
対象フォルダの取得

*var items = GetScheduleItems(folder, start, end);
スケジュールの検索

*var schedules = ExpansionAndConvert(items, start, end);
定期的なスケジュールを展開して、ScheduleItemに変換

*var recur = pattern.GetOccurrence(cur);
ここの取得が成功したらスケジュールが存在するって判定になる

*ret = ret.Where(x => start <= x.Start)
指定の日付幅だけにする、ついでにソート

*var schedules = outlookManager.GetScheduleList("test@test.com", DateTime.Today);
メールアドレス もしくは 名前 を指定
対象日時を指定（Start～Endでの指定もできます）


*[SerializeField] Text TriggerText;
追加

*void Start () {}
Use this for initialization

*void Update () {// ここから2行追加transform.rotation = VvrController.Orientation();TriggerText.text = VvrController.Trigger().ToString();}
Update is called once per frame

*transform.rotation = VvrController.Orientation();*TriggerText.text = VvrController.Trigger().ToString();
ここから2行追加


*this.Weights[i]++;
if (this.Weights[i] < this.Weights.Length)  上限を撤廃

*randomResult.Select((value, index) => (value, index)).ToLookup(t => t.value, t => t.index).SelectMany(ToDiff)*));
shuffleResult.Select((value, index) => (value, index)).ToLookup(t => t.value, t => t.index).SelectMany(ToDiff)


*Thread.Sleep(millisec);
Task.Run内Sleep


*Console.WriteLine(y);
5. yを画面に出力．


*private int id;
クラス自体の変数は下記の4行で定義

*public int Id { get; set; }
下記の4行でStudentクラスの変数に直接アクセスできない様にカプセル化

*var N = int.Parse(Console.ReadLine());
渡されるデータが幾つなのかはコンソールから渡す

*var listH = new List<Student>();
今回は身長によって2つのクラスに分ける

*Student src = new();
Ver. 9.0からStudentクラスをインスタンス化(newだけで以下のクラス名は省略できる)

*int studentTall = int.Parse(Console.ReadLine());
コンソールからまず身長が渡されるとする

*src.Id = i;
Student型の変数srcに新規内容として格納(iが出席番号)

*int[] weightArr = Array.ConvertAll(Console.ReadLine().Trim().Split(' '), int.Parse);
体重がコンソールから入力される(半角スペース区切りで1行の入力)

*string[] nameArr = Console.ReadLine().Trim().Split(' ');
名前がコンソールから入力される(半角スペース区切りで1行の入力)

*if (listH.Find(x => x.Id == i) != null)
身長によって入れているListが異なるので条件分岐にて振り分ける
その際に出席番号としてidをclassで持たせているので
そのidがListに入っているStudentクラスにあるかどうかを判定する
listのメソッドのFindメソッドを利用して、
その中でラムダ式にて該当idを探す ←これ大切です‼️‼️‼️‼️‼️

*listH.Find(x => x.Id == i).Weight = weightArr[i];
コンソールから取得した体重と名前をFIndメソッドで見つけたidのクラスに付与する

*listL.Find(x => x.Id == i).Weight = weightArr[i];
コンソールから取得した体重と名前をFIndメソッドで見つけたidのクラスに付与する

*if (listH.Find(x => x.Id == i) != null*&& listH.Find(x => x.Id == i).Weight > dictHighList["heaviest"])
各グループに存在するID で一番体重が重たい


*var alwaysFalse = myList.Any();
常にfalse


*Excel.Range start_cell = cells[2, 1];
タイトルは含めない


*searchQuery.category = PolyCategory.ANIMALS;
カテゴリ：動物

*searchQuery.keywords = "dog";
犬を検索


*IEnumerable<string> names = GetFriendsNames();
2回目

*IEnumerable<string> names = GetFriendsNames();
2回目

*var nameList = new List<string>();
Listを生成

*var nameList = new List<string>();
Listを生成

*Console.WriteLine(name);
↑すでにメモリ上にあるnameListを使うので、再度リスト作成することはない

*var mick = nameList.Where(x => x == "ミック・ジャガー");
まったく意味ないが


*private void picHeader_MouseDown(object sender, MouseEventArgs e)*{if (e.Button == MouseButtons.Left){Win32Api.MouseLeftDownOnFormTitleBar(this);}}
using System.Runtime.InteropServices;


*private Action _Callback = delegate { };
こんな感じで初期化しておくと呼び出すときにnullチェック不用

*private OnceAction _Callback = OnceAction.Default;
こんな感じで初期化しておくとnullチェック不用


*Vector2 pos = transform.position;*pos.x += 0.1f * Input.GetAxisRaw("Horizontal");
ランチャーの移動================================

*//スペースキーで弾発射*if (Input.GetKeyDown(KeyCode.Space)) {for (int i = 0; i <= (Angle_Split - 1); i++) {//n-way弾の端から端までの角度float AngleRange = PI * (Degree / 180);//弾インスタンスに渡す角度の計算if (Angle_Split > 1) _theta = (AngleRange / (Angle_Split - 1)) * i + 0.5f * (PI - AngleRange);else _theta = 0.5f * PI;//弾インスタンスを取得し、初速と発射角度を与えるGameObject Bullet_obj = (GameObject)Instantiate(Bullet, transform.position, transform.rotation);BulletSc bullet_cs = Bullet_obj.GetComponent<BulletSc>();bullet_cs.theta = _theta;bullet_cs.Velocity_0 = _Velocity_0;}}
================================================

*float AngleRange = PI * (Degree / 180);
n-way弾の端から端までの角度

*if (Angle_Split > 1) _theta = (AngleRange / (Angle_Split - 1)) * i + 0.5f * (PI - AngleRange);*else _theta = 0.5f * PI;
弾インスタンスに渡す角度の計算

*GameObject Bullet_obj = (GameObject)Instantiate(Bullet, transform.position, transform.rotation);*BulletSc bullet_cs = Bullet_obj.GetComponent<BulletSc>();
弾インスタンスを取得し、初速と発射角度を与える

*rid2d = GetComponent<Rigidbody2D>();
Rigidbody取得

*Vector2 bulletV = rid2d.velocity;
角度を考慮して弾の速度計算

*if (Angle_Split > 1) _theta = (AngleRange / (Angle_Split - 1)) * i - 0.5f * AngleRange;*else _theta = 0;
弾インスタンスに渡す角度の計算


*[MenuItem("CONTEXT/MonoBehaviour/Set ScriptName To GameObject")]
1.コンテキストメニューから処理を呼び出せるように属性を付加

*var name = command.context.GetType().ToString();
2.選択したスクリプト名を取得

*var target = command.context.ToString().Split(' ')[0];
4.選択したコンテキストの先頭文字は現在のオブジェクト名になる

*GameObject.Find(target).name = name;
シーン内にあるオブジェクトを取得してスクリプト名を設定


*if (AsinX >= 1) AsinX = 1.0f;
Asinの中身が1を超えるとまずいので

*float _theta = 0.5f * Mathf.Asin(AsinX);
θ算出

*if (LuncherPos.x > TargetPos.x) _theta = Mathf.PI - 0.5f * Mathf.Asin(AsinX);*//弾インスタンスを取得し、初速と発射角度を与える
ターゲットとの位置関係で発射方向反転

*GameObject Bullet_obj = (GameObject)Instantiate(Bullet, transform.position, transform.rotation);*BulletSc bullet_cs = Bullet_obj.GetComponent<BulletSc>();
弾インスタンスを取得し、初速と発射角度を与える

*rid2d = GetComponent<Rigidbody2D>();
Rigidbody取得

*Vector2 bulletV = rid2d.velocity;
角度を考慮して弾の速度計算


*await Task.Delay(millisecond);
ミリ秒待つ

*jsonString = await DeeplFileTranslator.Download(document_id, document_key, output_path);
Deeplからダウンロード

*Application.OpenURL("file:C:\\Users\\" + Environment.UserName + "\\Downloads");
翻訳完了を知らせるために, ダウンロードフォルダを開く


*using MyExtension;
拡張メソッドのnamespaceを入れておく

*int number = 5;
サンプル1個目

*var slist = new List<string>();
サンプル2個目

*Console.WriteLine("オラ".MyMakeOraora(10, "ァァァァァ！"));
サンプル3個目


*ITokenClaim claim = new TokenClaim{JwtID = Guid.NewGuid().ToString(),Audience = "testAudience",Expiration = DateTimeOffset.UtcNow.AddSeconds(120),NotBefore = DateTimeOffset.UtcNow.AddSeconds(-5),};
create a claim and a payload.

*bool valid = validator.ValidateToken(tokenString, out ITokenClaim tokenClaim, out TestPayload tokenPayload, out TokenState state, out string errorMessage);
validate the token.

*int secondsBefore = 60;*TokenManager manager = CreateManager(secondsBefore);
create the token manager.

*if (!m_Validator.ValidateToken(*tokenString
refresh the token

*TokenInfo accessToken = new TokenInfo(provider.CreateToken(claim, payload), claim.Expiration, claim.NotBefore);*// create a refresh token.
create a access token.


*public Hoge(string initName)
コンストラクタ.

*[assembly: AssemblyIsEditorAssembly]
自身がエディタのアセンブリだという宣言.

*void OnGUI()
何かの処理とか.
Hoge hogeData;  どこかでインスタンスを取得する.

*hoge.Name = "I Love Unity";
こちら側でのアクセスはErrorを吐き出す.


*public void RaiseCanExecuteChanged()*{CanExecuteChanged?.Invoke(this, EventArgs.Empty);}
他のメソッドなどは省略

*public event EventHandler CanExecuteChanged*{add { CommandManager.RequerySuggested += value; }remove { CommandManager.RequerySuggested -= value; }}
他のメソッドなどは省略

*CanExecuteChanged?.Invoke(this, EventArgs.Empty);
手抜き 本来はCanExecuteの値が変わる時だけ呼び出すべき


*var fields = parser.ReadFields();
⇒ string[] { "abc", "d\"ef", "gh,i", "jk" }

*class Class1*{public string Dummy { get; set; }}
カスタムクラスとそのインスタンスを用意

*var xslt = new XslCompiledTransform();*xslt.Load("test.xsl", new XsltSettings(true, true), null);
XSL ファイルを読み込む

*using (var writer = XmlWriter.Create(memory, new XmlWriterSettings() { Encoding = Encoding.UTF8, Indent = true })){var serializer = new XmlSerializer(obj.GetType());
カスタムクラスの内容を XML としてメモリに書き込む

*using (var stream = new FileStream("sample.xml", FileMode.Create)){memory.Position = 0;
メモリ内の XML を XSL 変換してファイルに出力


*HttpListener server = new HttpListener();
string endPoint = "http:localhost:8080";  こちらは例外でない
string endPoint = "http:<host>:8080";  こっちは例外が出る


*GlobalConfiguration.Configuration.Filters.Add(new CustomExceptionFilter());
例外ハンドラの登録


*string url = "https:
jsonplaceholder.typicode.composts";


*UnsafeUtility.MemCpyStride(dest, sizeof(Guid), src, sizeof(Stride0), sizeof(Guid), size);
Stride0のフィールド X を destにコピペする


*using Microsoft.EntityFrameworkCore;
追加

*[HttpPut]
省略
追加

*//追加//*[HttpDelete("{id}")]
省略

*[HttpDelete("{id}")]
追加


*return this.Service.GetText();
プロパティ経由でDIコンテナから依存オブジェクトを取得して使用する。

*this.registerMocks += builder => builder.RegisterMock(mock);
RegisterMock はジェネリック引数（ここでは暗黙指定）から型を判定するので、登録処理自体をデリゲートに収める。
（List<Mock> では型を渡せない）

*var serviceMock = CreateMock<Service>();
モック設定

*using (var autoMock = GetLoose()){テスト対象オブジェクトを生成var client = autoMock.Create<Client>();
モックのDI登録

*var client = autoMock.Create<Client>();
テスト対象オブジェクトを生成

*string result = client.Act();
テスト対象メソッドを実行

*Assert.AreEqual("UnitTest", result);
戻り値の検証
※モックの検証は基底クラスで自動的に行われる。


*var task3 = Task<double>.Run(() => { Thread.Sleep(2000); return 3.33; });
task3 開始

*Debug.WriteLine("戻り値2：" + task2.Result);
戻り値
Debug.WriteLine("戻り値1：" + task1.Result);  ここでブロックかかり、task1が終わるまでの5秒間UIフリーズ


*.UseUnityServiceProvider()
<-- こっちが正解.

*//.ConfigureContainer<IUnityContainer>((hostContext, container) =>*//{//    container.RegisterType<I~~Repository, ~~Repository>();//    // 省略//})
.UseServiceProviderFactory<IUnityContainer>(new ServiceProviderFactory(new UnityContainer()))

*//{//    container.RegisterType<I~~Repository, ~~Repository>();//    // 省略//})
.ConfigureContainer<IUnityContainer>((hostContext, container) =>

*.RunConsoleAppFrameworkAsync<MainApp>(args);
省略
})


*var payload = "message=" +
メッセージを入力;


*return new string[] { "value1", "value2" };
←ココにブレークポイントを設定


*foo.Hello();
ここでコピー発生。

*}
元のfooではなく、fooのコピーをつくってから Hello() を呼びだす。
メソッド呼び出しで値が変わるか知る方法がないため。


*#if UNITY_IOS && !UNITY_EDITOR_OSX
Unityエディタ上でもビルドターゲットをiOSにしているとUNITY_IOSがtrueとなるため
iOS実機ビルド時のみ __internal 読み込みとなるよう指定


*TextBox1= session.FindElementByAccessibilityId("TextBox1");
オブジェクトのNameプロパティで選択

*Button1= session.FindElementByName("ボタン1");
AccessibleNameプロパティで選択

*Button1.Click();
ボタンをクリック

*Thread.Sleep(TimeSpan.FromSeconds(1));
テキストボックスに文字入力
TextBox1.SendKeys("あいうえお"); キー入力
スリープ（文字入力後は少し待たないと、.Textプロパティの戻り値が途中経過みたいになってFailするぽい

*Assert.AreEqual("あいうえお", TextBox1.Text);
テキストボックスの内容が期待通りか確認

*Assert.AreEqual("あいうえお", TextBox1.GetAttribute("Value.Value").ToString());
チェックボックスの状態は.Selectedプロパティ
Assert.IsTrue(CheckBox1.Selected); チェックされてればパス
CheckBox1.Click(); クリックして状態を変更
Assert.IsTrue(CheckBox1.Selected); ここでフェイル
その他、inspect.exeで取得できるプロパティは.GetAttribute()メソッドを使う


*uint dof = 1;
スカラー

*}*{var FEM = new SampleFEM(world);{//var solver = new IvyFEM.Linear.LapackEquationSolver();//solver.Method = IvyFEM.Linear.LapackEquationSolverMethod.Dense;//solver.IsOrderingToBandMatrix = true;//solver.Method = IvyFEM.Linear.LapackEquationSolverMethod.Band;//solver.Method = IvyFEM.Linear.LapackEquationSolverMethod.PositiveDefiniteBand;//FEM.Solver = solver;}{//var solver = new IvyFEM.Linear.LisEquationSolver();//solver.Method = IvyFEM.Linear.LisEquationSolverMethod.Default;//FEM.Solver = solver;}{var solver = new IvyFEM.Linear.IvyFEMEquationSolver();solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.NoPreconCG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.CG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.ICCG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.NoPreconBiCGSTAB;FEM.Solver = solver;}FEM.Solve();double[] U = FEM.U;world.UpdateFieldValueValuesFromNodeValues(valueId, FieldDerivativeType.Value, U);fieldDrawerArray.Update(world);mainWindow.glControl.Invalidate();mainWindow.glControl.Update();WPFUtils.DoEvents();}
WPFUtils.DoEvents();

*}*{//var solver = new IvyFEM.Linear.LisEquationSolver();//solver.Method = IvyFEM.Linear.LisEquationSolverMethod.Default;//FEM.Solver = solver;}
FEM.Solver = solver;

*}*{var solver = new IvyFEM.Linear.IvyFEMEquationSolver();solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.NoPreconCG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.CG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.ICCG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.NoPreconBiCGSTAB;FEM.Solver = solver;}
FEM.Solver = solver;


*SHISAKU.MOJI = "文字";
ここではstring型やint型の編集ルールをそのまま用いる。


*else if (sight_x < 0)
sight_x が0度を下回ると360からsight_xを引く、残った分はsight_xに残る


*where T : IAdd<T>
T型に対して「IAdd<T>インターフェースを実装していないとダメ！」という制約を設けられる.

*return lhs.Add(rhs);
IAdd<T>を実装していることが前提のため, Add()メソッドを利用することが可能に！！

*amount= 2500}},,,class Program{static T Sum<T>(T lhs, T rhs)
output:

*var sum = Sum(num1, num2);
以下のコードはエラーに...


*void Start()*{Test();Debug.Log(4);Test();}
Start is called before the first frame update

*using System.Threading;
Taskを使用する準備

*private SynchronizationContext context;
おまじない

*async Task Start()*{//おまじないcontext = SynchronizationContext.Current;//実行時にawaitを使用await Test();Debug.Log(4);//実行時にawaitを使用しないTest();await Test();//1000ms待つawait Task.Delay(1000);Test();Debug.Log("StartFuncFinish!");}
voidをasync Taskに置き換え

*context = SynchronizationContext.Current;
おまじない

*await Test();
実行時にawaitを使用

*Test();
実行時にawaitを使用しない

*await Task.Delay(1000);
1000ms待つ

*async Task Test()*{Debug.Log(1);//1000ms待つawait Task.Delay(1000);Debug.Log(2);//1000ms待つawait Task.Delay(1000);Debug.Log(3);//1000ms待つawait Task.Delay(1000);}
voidをasync Taskに置き換え

*await Task.Delay(1000);
1000ms待つ

*await Task.Delay(1000);
1000ms待つ

*await Task.Delay(1000);
1000ms待つ

*using System.Threading;
タスクを使用する準備

*private SynchronizationContext context;
おまじない

*async Task Start()*{//おまじないcontext = SynchronizationContext.Current;//足し算の結果が返ってくるまで待つ．返ったらcに格納される．int c = await MyAddFuncAsync(5, 4);//cを出力Debug.Log(c);Debug.Log("StartFuncFinish!");}
Start is called before the first frame update

*context = SynchronizationContext.Current;
おまじない

*int c = await MyAddFuncAsync(5, 4);
足し算の結果が返ってくるまで待つ．返ったらcに格納される．

*Debug.Log(c);
cを出力

*async Task<int> MyAddFuncAsync(int a,int b)
引数2つを足し算し結果を返すTask
返り値はintなのでTask<int>のTaskとなる．

*int MyAddFunc(int a, int b)*{return a + b;}
待たない関数で普通に書いたらこうなる

*using System.Threading;
タスクを使用する準備

*private SynchronizationContext context;
おまじない

*void Start()*{//awaitをつけずにTaskを実行StartAsync();Debug.Log("StartFuncFinish!");}
Start is called before the first frame update

*StartAsync();
awaitをつけずにTaskを実行

*context = SynchronizationContext.Current;
おまじない

*using UniRx.Async;
UniTaskを使用する準備

*void Start()*{//awaitをつけずにTaskを実行StartAsync();Debug.Log("StartFuncFinish!");}
Start is called before the first frame update

*StartAsync();
awaitをつけずにTaskを実行


*Dapper.DefaultTypeMap.MatchNamesWithUnderscores = true;
↓ ここに入れる


*public LBool   m_bool;
bool型

*[System.Serializable] public class LGameObject : ReorderList<GameObject> { }
UnityEngine

*[System.Serializable] public class LText : ReorderList<UnityEngine.UI.Text> {}
追加 TextComponentをReorderableListで使えるようにする


*swing = Quaternion.identity;
no swing

*twist = Quaternion.AngleAxis(180.0f, twistAxis);*} else {
always twist 180 degree on singularity

*// http://www.euclideanspace.com/maths/geometry/rotations/for/decomposition/*Vector3 p = Vector3.Project(r, twistAxis);
formula & proof:


*[SerializeField] private AudioClip m_LandSound;
the sound played when character touches back on ground.

*private void Start()*{m_CharacterController = GetComponent<CharacterController>();m_Camera = Camera.main;m_OriginalCameraPosition = m_Camera.transform.localPosition;m_FovKick.Setup(m_Camera);m_HeadBob.Setup(m_Camera, m_StepInterval);m_StepCycle = 0f;m_NextStep = m_StepCycle/2f;m_Jumping = false;m_AudioSource = GetComponent<AudioSource>();m_MouseLook.Init(transform , m_Camera.transform);}
Use this for initialization

*private void Update()*{if (AllowRotate){RotateView();}// the jump state needs to read here to make sure it is not missedif (!m_Jump){m_Jump = CrossPlatformInputManager.GetButtonDown("Jump");}if (!m_PreviouslyGrounded && m_CharacterController.isGrounded){StartCoroutine(m_JumpBob.DoBobCycle());PlayLandingSound();m_MoveDir.y = 0f;m_Jumping = false;}if (!m_CharacterController.isGrounded && !m_Jumping && m_PreviouslyGrounded){m_MoveDir.y = 0f;}m_PreviouslyGrounded = m_CharacterController.isGrounded;}
Update is called once per frame

*Vector3 desiredMove = transform.forward*m_Input.y + transform.right*m_Input.x;*// get a normal for the surface that is being touched to move along it
always move along the camera forward as it is the direction that it being aimed at

*float horizontal = CrossPlatformInputManager.GetAxis("Horizontal");*float vertical = CrossPlatformInputManager.GetAxis("Vertical");
Read input

*m_IsWalking = !Input.GetKey(KeyCode.LeftShift);*#endif
keep track of whether or not the character is walking or running

*// only if the player is going to a run, is running and the fovkick is to be used*if (m_IsWalking != waswalking && m_UseFovKick && m_CharacterController.velocity.sqrMagnitude > 0)
handle speed change to give an fov kick


*NLog.LogManager.Shutdown();
Flush and close down internal threads and timers


*services.AddDbContext<BookContext>(options => options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
追加


*var Person = module.GetType("CSharpDll.Person");
利用するクラス(or 構造体)を取得

*dynamic p1 = Activator.CreateInstance(Person, "Aiueo", 29);
CSharpDll.Personクラスをインスタンス化.
コンストラクタへ引数を渡すことも可能.

*Console.WriteLine($"name= {p1.Name}");
dynamicで受けているので, 面倒なプロパティ取得やメソッド取得を省略できる.


*uint pad_trg = inputController.Trigger();
パッドトリガ入力


*yield return this.CreateDescriptor(child);
子要素を列挙


*class Base*{private static bool baseStaticFieldInitialized = ConsoleOut("(1) 基底型静的フィールドの初期化");private bool baseInstanceFieldInitialized = ConsoleOut("(4) 基底型インスタンスフィールドの初期化");public Base(){ConsoleOut("(5) 基底型コンストラクタの実行");// ※派生型コンストラクタはまだ実行されていないが、この時点でもインスタンスは派生型Assert.AreEqual(typeof(Derived), this.GetType());// ※オーバーライドされた派生型メソッドが実行される。OverridableMethod();}// 仮想メソッドprotected virtual void OverridableMethod(){// ※インスタンス型でオーバーライドされている場合、コンストラクタからの呼び出しでも実行されない。Assert.Fail();}protected static bool ConsoleOut(string step){Console.WriteLine(step);return true;}}
基底クラス

*Assert.AreEqual(typeof(Derived), this.GetType());
※派生型コンストラクタはまだ実行されていないが、この時点でもインスタンスは派生型

*OverridableMethod();
※オーバーライドされた派生型メソッドが実行される。

*protected virtual void OverridableMethod()*{// ※インスタンス型でオーバーライドされている場合、コンストラクタからの呼び出しでも実行されない。Assert.Fail();}
仮想メソッド

*Assert.Fail();
※インスタンス型でオーバーライドされている場合、コンストラクタからの呼び出しでも実行されない。

*sealed class Derived : Base*{private static bool derivedStaticFieldInitialized = ConsoleOut("(2) 派生型静的フィールドの初期化");// ※基底型インスタンスフィールド、基底型コンストラクタより先に処理される。private bool derivedInstanceFieldInitialized = ConsoleOut("(3) 派生型インスタンスフィールドの初期化");private bool derivedConstructorCalled = false;public Derived(){ConsoleOut("(7) 派生型コンストラクタの実行");this.derivedConstructorCalled = true;}// オーバーライドメソッドprotected override void OverridableMethod(){ConsoleOut("(6) 派生型オーバーライドメソッドの実行");// ※基底型コンストラクタから呼び出された場合、// 　派生型フィールドは初期化済みだが、派生型コンストラクタが未処理のまま実行されてしまう。Assert.IsTrue(this.derivedInstanceFieldInitialized);Assert.IsFalse(this.derivedConstructorCalled);}}
派生クラス

*private bool derivedInstanceFieldInitialized = ConsoleOut("(3) 派生型インスタンスフィールドの初期化");
※基底型インスタンスフィールド、基底型コンストラクタより先に処理される。

*protected override void OverridableMethod()*{ConsoleOut("(6) 派生型オーバーライドメソッドの実行");// ※基底型コンストラクタから呼び出された場合、// 　派生型フィールドは初期化済みだが、派生型コンストラクタが未処理のまま実行されてしまう。Assert.IsTrue(this.derivedInstanceFieldInitialized);Assert.IsFalse(this.derivedConstructorCalled);}
オーバーライドメソッド

*Assert.IsTrue(this.derivedInstanceFieldInitialized);
※基底型コンストラクタから呼び出された場合、
派生型フィールドは初期化済みだが、派生型コンストラクタが未処理のまま実行されてしまう。


*ServiceCollection services = CreateMessagePipeServices();
MessagePipe を使用するためのサービスを生成する

*services.AddTransient<Form1>();
フォームのインスタンスをDIで生成する場合はアプリケーションのフォームを登録する

*ServiceProvider provider = services.BuildServiceProvider();
サービスプロバイダーを生成する

*Application.SetHighDpiMode(HighDpiMode.SystemAware);
Windowsフォームアプリケーションの既定の初期処理

*Application.Run(provider.GetRequiredService<Form1>());
これではDIを利用できない
後述するどちらかの方法でフォームのインスタンスを生成してアプリケーションを開始する
Application.Run(new Form1());
サービスプロバイダーからフォームのインスタンスを生成する
コンストラクタの引数に定義された MessagePipe のインスタンスが注入される

*Application.Run(new Form1(new MyContext(provider)));
サービスプロバイダーを内包したコンテキストを渡す
フォーム内で MessagePipe のインスタンスを生成する

*services.AddMessagePipe(options =>{全てのメッセージに適用したいフィルタはグローバルフィルタとして定義するとよいoptions.AddGlobalMessageHandlerFilter(typeof(SampleFilter<>));
MessagePipe の標準サービスを登録する

*options.AddGlobalMessageHandlerFilter(typeof(SampleFilter<>));
全てのメッセージに適用したいフィルタはグローバルフィルタとして定義するとよい

*services.AddSingleton(typeof(MessagePipe.IPublisher<,>), typeof(MessageBroker<,>));
使用するメッセージを登録する

*m_Releaser = m_Subscriber?.Subscribe("form1", x =>{System.Diagnostics.Debug.WriteLine($"subscribe: {x.Message}");
キーが "form1" であるメッセージを購読する

*m_Publisher?.Publish("form1"
メッセージを発行する
前述のサブスクライバには一つめのメッセージのみが送られる


*bool f = (3 >= 7);
fはfalse．


*class ProgramOverride : ProgramBase
中身を何も書かないとエラーを吐く。下に書くオーバーライドを用いて実装する必要があるようだ。


*GC.Collect();
必要なさそうだけど一応GC(ほんとに要らないかも)


*using (var server = new NamedPipeServerStream("tmp-app.world", PipeDirection.InOut)){Console.WriteLine("waiting for client connection...");
サーバーの作成

*server.WaitForConnection();
クライアント接続待ち

*char c;
受信

*Console.WriteLine(message);
typeとdataが設定されたJSON文字列が送信されてくる

*var data = "pong";
返信

*writer.Write("{ \"type\": \"app.message\", \"data\": \"" + data + "\" }" + "\f");
node-ipcが解釈できる形のJSON文字列 + \fを返す。

*server.WaitForPipeDrain();
クライアント側が送信メッセージを読み終わるまで待つ


*public Text camSwitchButton;
GUIText -> Textに変更


*[DllImport("DllTest.dll", CallingConvention = CallingConvention.Cdecl)]public extern static void Test_MyApi2([MarshalAs(UnmanagedType.LPWStr)]string lpText, [MarshalAs(UnmanagedType.LPWStr)]string lpCaption);
下記でも、うまく動く。(CharSetの代わりにMarshallAsでLPWSTRを指定する)

*[DllImport("DllTest.dll", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode)]public extern static void Test_MyApi3(int count);
public extern static void Test_MyApi2([MarshalAs(UnmanagedType.LPWStr)]string lpText, [MarshalAs(UnmanagedType.LPWStr)]string lpCaption);


*}
notepad.exe killed

*Workingset = 0x00000001,ProcessTime = 0x00000002,JobTime = 0x00000004,ActiveProcess = 0x00000008,Affinity = 0x00000010,PriorityClass = 0x00000020,PreserveJobTime = 0x00000040,SchedulingClass = 0x00000080,Extended LimitsProcessMemory = 0x00000100,JobMemory = 0x00000200,DieOnUnhandledException = 0x00000400,BreakawayOk = 0x00000800,SilentBreakawayOk = 0x00001000,KillOnJobClose = 0x00002000,SubsetAffinity = 0x00004000,Notification LimitsJobReadBytes = 0x00010000,JobWriteBytes = 0x00020000,RateControl = 0x00040000,}[StructLayout(LayoutKind.Sequential)]struct JOBOBJECT_BASIC_LIMIT_INFORMATION{public Int64 PerProcessUserTimeLimit;
Basic Limits

*ProcessMemory = 0x00000100,JobMemory = 0x00000200,DieOnUnhandledException = 0x00000400,BreakawayOk = 0x00000800,SilentBreakawayOk = 0x00001000,KillOnJobClose = 0x00002000,SubsetAffinity = 0x00004000,Notification LimitsJobReadBytes = 0x00010000,JobWriteBytes = 0x00020000,RateControl = 0x00040000,}[StructLayout(LayoutKind.Sequential)]struct JOBOBJECT_BASIC_LIMIT_INFORMATION{public Int64 PerProcessUserTimeLimit;
Extended Limits

*JobReadBytes = 0x00010000,JobWriteBytes = 0x00020000,RateControl = 0x00040000,}[StructLayout(LayoutKind.Sequential)]struct JOBOBJECT_BASIC_LIMIT_INFORMATION{public Int64 PerProcessUserTimeLimit;
Notification Limits


*const int NUM = 8;
定数も再定義はエラー


*status = okvideo id = sm32207616title = 【BGM素材】褪せし青の故郷【村】description = ゲームミュージック風ループBGM素材です。ニコニ・コモンズよりダウンロード可能です。[nc168769] 自由にお使いください。使用した画像[nc4917][nc4915] 他動画 → [mylist/24914088 ] Twitter @hiki_neet_puser nickname = tana＠ヒキニートP}}},,,*video id = sm32207616title = 【BGM素材】褪せし青の故郷【村】description = ゲームミュージック風ループBGM素材です。ニコニ・コモンズよりダウンロード可能です。[nc168769] 自由にお使いください。使用した画像[nc4917][nc4915] 他動画 → [mylist/24914088 ] Twitter @hiki_neet_puser nickname = tana＠ヒキニートP}}},,,*title = 【BGM素材】褪せし青の故郷【村】description = ゲームミュージック風ループBGM素材です。ニコニ・コモンズよりダウンロード可能です。[nc168769] 自由にお使いください。使用した画像[nc4917][nc4915] 他動画 → [mylist/24914088 ] Twitter @hiki_neet_puser nickname = tana＠ヒキニートP}}},,,*description = ゲームミュージック風ループBGM素材です。ニコニ・コモンズよりダウンロード可能です。[nc168769] 自由にお使いください。使用した画像[nc4917][nc4915] 他動画 → [mylist/24914088 ] Twitter @hiki_neet_puser nickname = tana＠ヒキニートP}}},,,*user nickname = tana＠ヒキニートP}}},,,*}
user nickname = tana＠ヒキニートP


*keyCodes.Add (KeyCode.F, "F");
入力判定用にFとJを設定


*value = atk,
ダメージ量

*[Inject] ISubscriber<PlayerAttackData> OnAttacked { get; set; }
Zenjectによって自動的に攻撃イベントが注入される

*hp -= attack.value;
プレイヤーの攻撃範囲内の場合、ダメージを受ける

*disposable.Dispose();
破棄されるタイミングでOnAttackイベントの購読をやめる


*var query3 =tItem.AsEnumerable().Join(tReceipt.AsEnumerable(),i => new { f1 = i.Field<int>("id") },
query3とquery4は迷走時の黒歴史。文末の追記のほうが良いです。


*public GameObject enemyTag;
Text3Dのprefabを割り当て

*void Start () {enemyGroup = new EnemyGroup(enemies.Length);Iterator it = enemyGroup.iterator();for(int i = 0; i < enemies.Length; i++){enemyGroup.AddEnemy(enemies[i]);}while (it.HasNext()){var e = it.Next();GenerateEnemy((Enemy)e);}}
Use this for initialization

*void Update () {}
Update is called once per frame

*void Start () {}
Use this for initialization

*void FixedUpdate () {time += Time.deltaTime;if(time >= 1){time = 0;foreach (GameObject obj in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))){if(obj.GetComponent<Bomb>() != null){obj.GetComponent<Bomb>().CountDown();}}}}
Update is called once per frame


*public SteamVR_TrackedObject targetObject;
割り当て固定対象のオブジェクト

*public void AssignTrackedObject(){SteamVR_TrackedObject.EIndex tmp;var buffer = new StringBuilder(256);var error = ETrackedPropertyError.TrackedProp_Success;for(int i = 0; i < trackedObjects.Length; i++){SteamVR.instance.hmd.GetStringTrackedDeviceProperty((uint)trackedObjects[i].index, ETrackedDeviceProperty.Prop_SerialNumber_String, buffer, (uint)buffer.Capacity, ref error);if(error == ETrackedPropertyError.TrackedProp_Success){Debug.Log(buffer.ToString());if(buffer.ToString() == serialNumberTarget){tmp = trackedObjects[i].index;targetObject.SetDeviceIndex((int)tmp);}}}}
つまりserialNumberTargetとtargetObjectが対応づけされる


*var res = new DateTime( DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day + 1, hour, mini, sec );
例外が出るよ

*var res = new DateTime( DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, hour, mini, sec).AddDays(1);
こっちならOK


*print("Cubeに衝突");
やりたい処理


*// async IEnumerable<int> DoAsync(){,,,async IAsyncEnumerable<int> DoAsync(){await Task.Delay(1000);yield return 1;},,,await foreach(var item in asyncStream) {Console.WriteLine(item);},,,async IAsyncEnumerable<int> DoAsync() {foreach(var item in Enumerable.Range(1, 100).Select(x => x * 5)) {await Task.Delay(item);yield return item;}},,,async ValueTask DoSomething() {await foreach(var item in DoAsync()) {Console.WriteLine(item);}},,,public static class Ex{// 受けとったTaskの配列をIAsyncEnumerableとしてreturnする拡張メソッドpublic static IAsyncEnumerable<T> AsAsyncEnumerable<T>(this IEnumerable<Task<T>> tasks) => tasks switch {null => throw new ArgumentNullException(nameof(tasks)),IEnumerable<Task<T>> ts => ts.AsAsyncEnumerableImpl(),};static async IAsyncEnumerable<T> AsAsyncEnumerableImpl<T>(this IEnumerable<Task<T>> tasks) {foreach(var task in tasks) {yield return await task;}}},,,async ValueTask DoSomething() {var tasks = new List<Task<int>>();tasks.Add(Task.Delay(1000).ContinueWith(_ => 1));tasks.Add(Task.Delay(3000).ContinueWith(_ => 2));tasks.Add(Task.Delay(5000).ContinueWith(_ => 3));tasks.Add(Task.Delay(2000).ContinueWith(_ => 4));tasks.Add(Task.Delay(4000).ContinueWith(_ => 5));await foreach(int item inAsyncEnumerableEx.AsAsyncEnumerable(tasks)) {Console.WriteLine(item);}},,,*,,,*async IAsyncEnumerable<int> DoAsync(){await Task.Delay(1000);yield return 1;},,,await foreach(var item in asyncStream) {Console.WriteLine(item);},,,async IAsyncEnumerable<int> DoAsync() {foreach(var item in Enumerable.Range(1, 100).Select(x => x * 5)) {await Task.Delay(item);yield return item;}},,,async ValueTask DoSomething() {await foreach(var item in DoAsync()) {Console.WriteLine(item);}},,,public static class Ex{// 受けとったTaskの配列をIAsyncEnumerableとしてreturnする拡張メソッドpublic static IAsyncEnumerable<T> AsAsyncEnumerable<T>(this IEnumerable<Task<T>> tasks) => tasks switch {null => throw new ArgumentNullException(nameof(tasks)),IEnumerable<Task<T>> ts => ts.AsAsyncEnumerableImpl(),};static async IAsyncEnumerable<T> AsAsyncEnumerableImpl<T>(this IEnumerable<Task<T>> tasks) {foreach(var task in tasks) {yield return await task;}}},,,async ValueTask DoSomething() {var tasks = new List<Task<int>>();tasks.Add(Task.Delay(1000).ContinueWith(_ => 1));tasks.Add(Task.Delay(3000).ContinueWith(_ => 2));tasks.Add(Task.Delay(5000).ContinueWith(_ => 3));tasks.Add(Task.Delay(2000).ContinueWith(_ => 4));tasks.Add(Task.Delay(4000).ContinueWith(_ => 5));await foreach(int item inAsyncEnumerableEx.AsAsyncEnumerable(tasks)) {Console.WriteLine(item);}},,,*public static IAsyncEnumerable<T> AsAsyncEnumerable<T>(this IEnumerable<Task<T>> tasks) => tasks switch {
受けとったTaskの配列をIAsyncEnumerableとしてreturnする拡張メソッド


*IPXPmxBuilder bdx = host.Builder.Pmx;
PMXビルダ

*,,,
PMX関連
IPXPmx pmx = connect.Pmx.GetCurrentState();      PMX取得
IPXHeader header = pmx.Header;                   header   :ヘッダ
IPXModelInfo info = pmx.ModelInfo;               info     :モデル情報
IList<IPXVertex> vertex = pmx.Vertex;            vertex   :頂点   | リスト
IList<IPXMaterial> material = pmx.Material;      material :材質   | リスト
IList<IPXBone> bone = pmx.Bone;                  bone     :ボーン | リスト
IList<IPXMorph> morph = pmx.Morph;               morph    :モーフ | リスト
IList<IPXNode> node = pmx.Node;                  node     :表示枠 | リスト
IList<IPXBody> body = pmx.Body;                  body     :剛体   | リスト
IList<IPXJoint> joint = pmx.Joint;               joint    :Joint  | リスト
IList<IPXSoftBody> sbody = pmx.SoftBody;         sbody    :SoftBody  | リスト


*Console.WriteLine(konan.Age);
->7のまま

*}
本名を変えることはできません
konan.Realname = "江戸川コナン";  そのプロパティはRead-Only専用と怒られる
じゃあコナン君、本名は？
Console.WriteLine(konan.Realname);  ->工藤新一。あっ……やっぱり。

*return 処理した結果;
なんか処理

*this.フィールド = 処理した結果;
valueを使ってなんか処理

*,,,
Console.WriteLine(konan.Secret); ←Write-Onlyと怒られる


*private CancellationTokenSource? m_CurrentCancellation;
実行中のタスクをキャンセルするためのキャンセルトークン

*private readonly ConcurrentDictionary<Guid, CancellationTokenSource> m_CurrentCancellations
実行中のタスクをキャンセルするためのキャンセルトークン

*private Guid? m_CurrentTaskId;
実行中のタスクを表すID


*StartCoroutine(Fuga());
コルーチンの実行

*Destroy(gameObject);
コルーチンが終了する前にゲームオブジェクトを削除

*,,,
ここで列挙が終了する。
3回目のMoveNextを呼べばDisposeされるがGameObjectが削除されているので呼ばれない。
enumerator.MoveNext()
もしくはenumeratorがDisposeされるならばDisposeが呼ばれる。
if (enumerator is IDisposable d) d.Dispose();


*static int solve(int a, int b, int c) {
a < b < c


*this.UndoManager = new UndoManager();
編集履歴を記録する対象に当ViewModelを指定します。

*UndoManager.FromReference(this).AddPropertyChange(this, propertyName, storage, value);
UndoManagerに変更値を登録

*this.ShowHistory();
UndoRedoの履歴を表示

*UndoManager.FromReference(this).AddPropertyChange(this, propertyName, storage, value);
UndoManagerに変更値を登録

*this.ShowHistory();
UndoRedoの履歴を表示


*DefaultModelBinder.ResourceClassKey = nameof(Messages);
リソース名の設定

*DataAnnotationsModelValidatorProvider.RegisterAdapter(
アダプターの設定
第1引数は独自Validationサブクラス、第2引数はRegularExpressionAttributeAdapter を指定


*return Marshal.StringToHGlobalAuto("hoge fuga piyo");
string型をIntPtrに変換してreturn


*public string KeywordA { get; set; } = "";
初期表示の場合は""、検索条件なしで検索した場合はnull


*ModelState.Remove(nameof(SearchViewModel.KeywordA));
検索後の入力値はModelState(入力パラメータ）が優先されるため、検索結果が入らない
ModelStateの値を削除することで検索結果が表示されるようにする


*private PersistenceGroup taregetGroup = new PersistenceGroup();
保存対象のコントロールグループ

*private MemoryStream saveMemoryStrem;
保存内容のMemoryStream

*SettingSaveTargetControls();
保存対象のプロパティやコントロールの設定などを行う。

*this.SetSettingsControl(this.comboBox);
保存対象のコントロールに対し、保存するプロパティを設定する。

*PersistenceManager.SetPersistenceGroup(this.comboBox, taregetGroup);
保存対象のコントロールを１つのグループとして登録。

*PersistenceManager.SetPersistenceGroup(this.comboBox, taregetGroup);
保存対象のコントロールを１つのグループとして登録。

*saveMemoryStrem = PersistenceManager.Save(taregetGroup);
保存処理

*PersistenceManager.Load(taregetGroup, saveMemoryStrem);
読込処理


*this.xamDataGrid.DataSource = LoadJsonFile();
Jsonをシリアライズ化してサンプルデータを設定

*string fileContent = System.IO.File.ReadAllText(JSON_FILE_PATH);
Jsonファイルを読み込み、デシリアライズ化し、SampleDataに設定します。

*List<SampleData> records = this.xamDataGrid.DataSource as List<SampleData>;
行を追加する

*List<SampleData> records = this.xamDataGrid.DataSource as List<SampleData>;
選択行を削除する。

*targetData.Age = editData.Age;
編集内容を反映

*this.xamDataGrid.DataSource = null;
XamDataGridに反映

*this.xamDataGrid.SelectedDataItem = targetData;
データソース反映時に選択行が解除されるため、再設定

*xamPropGrid.SelectedObject = this.xamDataGrid.ActiveDataItem;
選択行のオブジェクトをXamPropertyGridに表示


*return false;
生成忌避


*,,,
他のシーンを呼び出す
Application.LoadLevel("Main");  非推奨
SceneManager.LoadScene("Main");  OK
遷移前のシーンを残して、他のシーンを呼び出す
Application.LoadLevelAdditive("Main");  非推奨
SceneManager.LoadScene("Main", LoadSceneMode.Additive);  OK
現在読み込んでいるシーンを再読込
Application.LoadLevel(Application.loadedLevel);  非推奨
SceneManager.LoadScene(SceneManager.GetActiveScene().name);  OK


*var apiResponse = (await XXXAsync(XXX, YYY));
外部APIの呼び出し


*var responce = ...;
色々あった。

*public MessageController(IRequestHandler<MessageRequest,MessageResponse> handler) {this.handler = handler;}
型情報から先程のMessageHandlerのインスタンスを受け取ることが出来る。

*}
詳細略

*}
略


*d.Url = "http:
example.selenium.jpreserveApp";

*ReserveFormPage.SetForm(d);
予約入力画面

*ReserveConfirmPage.ClickConfirmBtn(d);
予約確認画面

*Assert.AreEqual(ReserveCompletePage.GetMessage(d), "予約を完了しました。");
予約完了画面

*ReserveFormPage.SetForm(d);
予約入力画面

*Assert.AreEqual(ErrorPage.GetPageTitle(d), "予約エラー");
エラー画面

*ReserveFormPage.SetForm(d);
予約画面操作

*ReserveConfirmPage.ClickBackBtn(d);
予約確認画面操作

*ReserveFormPage.SetForm(d);
予約画面操作

*ReserveConfirmPage.ClickConfirmBtn(d);
予約確認画面操作

*Assert.AreEqual(ReserveCompletePage.GetMessage(d), "予約を完了しました。");
予約完了画面操作


*//descriptor.Claims = new Dictionary<string, object> {//    { "userpayload", JsonConvert.SerializeObject(payload) }//    { "jti", claim.ID }//};
定義済でない項目をクレームに含めるには、Claims ではなく Subject に格納します。

*//    { "userpayload", JsonConvert.SerializeObject(payload) }
descriptor.Claims = new Dictionary<string, object> {

*//    { "jti", claim.ID }
{ "userpayload", JsonConvert.SerializeObject(payload) }

*//};*descriptor.Subject = new ClaimsIdentity(new Claim[] {new Claim("userpayload", JsonConvert.SerializeObject(payload)),new Claim("jti", claim.ID)});
{ "jti", claim.ID }

*descriptor.Subject = new ClaimsIdentity(new Claim[] {new Claim("userpayload", JsonConvert.SerializeObject(payload)),
};

*parameters.ValidateLifetime = true;*parameters.LifetimeValidator = m_LifetimeValidator;
有効期限を検証するかどうか

*claim = new MsJwtClaim(){ID = GetClaim(claims, "jti),Audience = GetClaim(claims, "aud")};
クレーム情報

*string payloadJson = claims.FindFirst("userpayload")?.Value;
ペイロード

*claim = null;
有効期限が不正

*tokenState = TokenState.Invalid;
NotBefore でも Expires でもない

*claim = null;
発行者が不正

*claim = null;
利用者が不正


*double rt = 1.5;
96dpi_rt=1, 144dpi_rt=1.5

*}*catch(Exception ex){MessageBox.Show("読み取りエラー\n\n"+ex);}
Clipboard.SetDataObject(Result,true,20,500);


*Console.log(-(1.5.Ceiling()));
<- このように解釈される


*public static bool MyInputKey(KeyCode key)*{if(Input.anyKey == false) isCheck_Input = false;if (isCheck_Input==false){if (Input.GetKey(key)){isCheck_Input = true;return true;}}return false;}
真の同時押し不可


*driver.FindElement(By.XPath("
input[@value='ログイン'] | button[text()='ログイン']")).Click();


*"https:
+:44300sample");


*using System.Drawing.Imaging;
追加

*var bmp = clip.GetData(typeof(Bitmap)) as Bitmap;
画像ファイルのみ取り込み


*Color32[] texColors = Enumerable.Repeat<Color32>(bgColor, width * height).ToArray();
背景が透明なTexture2Dを作る
http:d.hatena.ne.jp/shinriyo/20140520/p2

*Color[] wcolor = { color };
color of pixels


*private string name2;
name for 2


*this.xamDataGrid.DataSource = LoadJsonFile();
Jsonをシリアライズ化してサンプルデータを設定

*string fileContent = System.IO.File.ReadAllText(JSON_FILE_PATH);
Jsonファイルを読み込み、デシリアライズ化し、SampleDataに設定します。

*List<SampleData> records = this.xamDataGrid.DataSource as List<SampleData>;
行を追加する

*List<SampleData> records = this.xamDataGrid.DataSource as List<SampleData>;
選択行を削除する。

*targetData.Age = editData.Age;
編集内容を反映

*this.xamDataGrid.DataSource = null;
XamDataGridに反映

*this.xamDataGrid.SelectedDataItem = targetData;
データソース反映時に選択行が解除されるため、再設定

*xamPropGrid.SelectedObject = this.xamDataGrid.ActiveDataItem;
選択行のオブジェクトをXamPropertyGridに表示


*driver.FindElement(By.XPath("
input[@value='登録'] | button[text()='登録']")).Click();


*controller = new Controller();
LeapMotionのコントローラー

*var handsStream = this.UpdateAsObservable().Select(_ => controller.Frame().Hands);
LeapMotionから手の情報を取得

*var endRockGripStream = handsStream.Where(hands => !IsRockGrip(hands));
グー終了判定ストリーム

*handsStream
カメラ制御

*.Where(hands => IsRockGrip(hands))
グーなら

*.Select(hands => ToVector3(hands[0].PalmPosition))
手のひらの位置を取得

*.Buffer(2, 1)
バッファに前回と今回の２つの値を詰める

*.Select(positions => positions[1] - positions[0])
今回と前回の差から手のひらの移動ベクトルを計算

*.Do(movement => Debug.Log("移動: " + movement))
値をログに出力

*.TakeUntil(endRockGripStream).RepeatUntilDestroy(this)
グーが終了したらバッファをクリアにする

*.Subscribe(movement => transform.Translate(-speed * movement));*}
カメラを移動

*hands.Count == 1 &&
片手なら

*hands[0].Fingers.ToArray().Count(x => x.IsExtended) == 0;
全ての指の内、開いている数が0個なら


*my.ToString();
nullの場合もここを通る

*// 変数は、使用しない場合省略できる*if (point is (1, 2)) {}
型名は、自明な場合に省略できる

*// 実際には単なる一時的なタプルの構築が行われる。*switch (x, str) {case (0, string s):break;case (int n, string s) when s.Length > 0:break;default:break;}
switch文の対象に複数の値を書くことができるようになった。


*class Student {[DataMember(Name = "id", Order = 1)]public int Id { set; get; }[DataMember(Name = "name", Order = 2)]public string Name { set; get; }[DataMember(Name = "v1")]public int V1 { set; get; }[DataMember(Name = "v2")]public int V2 { set; get; }}
CSV文字列化したいクラス

*static class StudentExtension {public static string ToCsvString(this Student student) {var list = student.GetType().GetProperties().OrderBy(_ => GetOrder(_)).ThenBy(_ => _.Name).Select(_ => _.GetValue(student));return string.Join(", ", list);}private static int GetOrder(PropertyInfo info) {if (Attribute.GetCustomAttribute(info, typeof(DataMemberAttribute))is DataMemberAttribute attr){return attr.Order;}return -1;}}
CSV文字列化を拡張メソッドで実装してみた

*class Program {static void Main(string[] args) {var student = new Student() { Id = 1, Name = "山田", V1 = 1, V2 = 2 };Console.WriteLine(student.ToCsvString());}}
StudentクラスのCSV文字列化


*public static void DoGetHostEntry(string hostname)*{IPHostEntry host = Dns.GetHostEntry(hostname);Console.WriteLine($"GetHostEntry({hostname}) returns:");foreach (IPAddress address in host.AddressList){Console.WriteLine($"    {address}");}}
ホストネームからアドレスを取得する


*IEnumerator<int> IEnumerable<int>.GetEnumerator()*{if (<>1__state == -2 && <>l__initialThreadId == nvironment.CurrentManagedThreadId){<>1__state = 0;return this;}return new <YieldSample>d__1(0);}
途中略


*string name;
パケットから取得したファイル名


*var ret = MasterContext.Where( g => g.email == "xxxxx@xxxxxxxx.xxx" ).Any();
No coercion operator is defined between types 'System.Int16' and 'System.Boolean'.

*var ret = ( MasterContext.Where( g => g.Email == "xxxxx@xxxxxxxx.xxx" ).Select( g => new { g.Email } ).FirstOrDefault()) != null;
Any()メソッドはbool以外が返ってきて例外がでるので、別回避する必要あり


*var color = tex.GetPixels();
ガンマ補正


*Color diffColor = Color.Red;
画像の差分に付ける色。

*diffBmp.SetPixel(i, j, diffColor);*isSame = false;
画像のサイズが違う時は、ピクセルを取得できずにエラーとなるが、ここでは「差分」として扱う。


*private const float WINDOWSIZE_H = 200.0f;
ウィンドウサイズ縦幅

*window.maxSize = window.minSize = new Vector2(WINDOWSIZE_W,WINDOWSIZE_H);
ウィンドウサイズ設定(minとmaxを=しているのはウィンドウサイズを固定するため)


*,,,
行毎の合計を撮る
var sums = array.Rows.Select(r => r.Sum()).ToArray();  => [ 6, 15, 24 ]


*0x03,
[2] 00000011


*Task<string> task = GetLastUrl(url);
リダイレクト先を知りたいURL
string url = "https:goo.gl/xBVejN";
リダイレクト先の取得が終わるまで待つ

*Debug.WriteLine("リダイレクト先 : " + task.Result);
リダイレクト先を表示

*public static async Task<string> GetLastUrl(string url)*{HttpClient client = new HttpClient();HttpResponseMessage response = await client.GetAsync(url);response.EnsureSuccessStatusCode();return response.RequestMessage.RequestUri.ToString();}
リダイレクト先の取得


*#endregion
ClientStreaming, ServerStreaming, DuplexStreaming も実装の流れは同じですので割愛します。

*#endregion
ClientStreaming, ServerStreaming, DuplexStreaming も実装の流れは同じですので割愛します。


*uint dof = 2;
Vector2

*}*{//var solver = new IvyFEM.Linear.LisEquationSolver();//solver.Method = IvyFEM.Linear.LisEquationSolverMethod.Default;//FEM.Solver = solver;}
FEM.Solver = solver;

*}*{var solver = new IvyFEM.Linear.IvyFEMEquationSolver();solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.NoPreconCG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.CG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.ICCG;//solver.Method = IvyFEM.Linear.IvyFEMEquationSolverMethod.NoPreconBiCGSTAB;FEM.Solver = solver;}
FEM.Solver = solver;


*http:
opensource.orglicensesmit-license.php

*string randomLine = Guid.NewGuid().ToString("N").Substring(0, 10);
ランダム文字列生成


*window.location.href = "https:
s3.amazonaws.comstatic-files.lookingglassfactory.comWebCalibrationBridgeLKG_ThreeJsDriver_Mac.pkg"


*// input for prediction operations*// - First 4 properties are inputs/features used to predict the label
IrisData is used to provide training data, and as

*public class IrisData*{[LoadColumn(0)]public float SepalLength;[LoadColumn(1)]public float SepalWidth;[LoadColumn(2)]public float PetalLength;[LoadColumn(3)]public float PetalWidth;[LoadColumn(4)]public string Label;}
- Label is what you are predicting, and is only set when training

*public class IrisPrediction*{[ColumnName("PredictedLabel")]public string PredictedLabels;}
IrisPrediction is the result returned from prediction operations

*var pipeline = mlContext.Transforms.Conversion.MapValueToKey("Label")*.Append(mlContext.Transforms.Concatenate("Features", "SepalLength", "SepalWidth", "PetalLength", "PetalWidth"))
Convert the Label back into original text (after converting to number in step 3)

*// You can change these numbers to test different predictions*var prediction = model.CreatePredictionEngine<IrisData, IrisPrediction>(mlContext).Predict(
STEP 5: Use your model to make a prediction


*void Start () {targetRenderer = GetComponent<MeshRenderer>();}
Use this for initialization

*void Update () {}
Update is called once per frame


*private enum FOS
not fully defined


*NullValueHandling = NullValueHandling.Ignore
nullは出力しない


*options.AccessDeniedPath = "
IdentityAccessDenied"; AccessDenied は未実装


*db.Blogs.Add(new Blog { Url = "http:
blogs.msdn.comadonet" + i.ToString() });

*Console.WriteLine("使用テーブル名やレコード数取得とか");
念願のinformation_schema.TABLESテーブル取得＆表示

*//    name: "information_schema");*migrationBuilder.CreateTable(
migrationBuilder.EnsureSchema(

*migrationBuilder.CreateTable(name: "Blogs",columns: table => new{BlogId = table.Column<int>(nullable: false)
name: "information_schema");

*//    schema: "information_schema",*//    columns: table => new
name: "TABLES",

*//    columns: table => new*//    {//        TABLE_CATALOG = table.Column<string>(nullable: false),//        TABLE_SCHEMA = table.Column<string>(nullable: false),//        TABLE_NAME = table.Column<string>(nullable: false),//        TABLE_TYPE = table.Column<string>(nullable: false),//        ENGINE = table.Column<string>(nullable: true),//        VERSION = table.Column<ulong>(nullable: true),//        ROW_FORMAT = table.Column<string>(nullable: true),//        TABLE_ROWS = table.Column<ulong>(nullable: true),//        AVG_ROW_LENGTH = table.Column<ulong>(nullable: true),//        DATA_LENGTH = table.Column<ulong>(nullable: true),//        MAX_DATA_LENGTH = table.Column<ulong>(nullable: true),//        INDEX_LENGTH = table.Column<ulong>(nullable: true),//        DATA_FREE = table.Column<ulong>(nullable: true),//        AUTO_INCREMENT = table.Column<ulong>(nullable: true),//        CREATE_TIME = table.Column<DateTime>(nullable: true),//        UPDATE_TIME = table.Column<DateTime>(nullable: true),//        CHECK_TIME = table.Column<DateTime>(nullable: true),//        TABLE_COLLATION = table.Column<string>(nullable: true),//        CHECKSUM = table.Column<ulong>(nullable: true),//        CREATE_OPTIONS = table.Column<string>(nullable: true),//        TABLE_COMMENT = table.Column<string>(nullable: true)//    },
schema: "information_schema",

*//    {//        TABLE_CATALOG = table.Column<string>(nullable: false),//        TABLE_SCHEMA = table.Column<string>(nullable: false),//        TABLE_NAME = table.Column<string>(nullable: false),//        TABLE_TYPE = table.Column<string>(nullable: false),//        ENGINE = table.Column<string>(nullable: true),//        VERSION = table.Column<ulong>(nullable: true),//        ROW_FORMAT = table.Column<string>(nullable: true),//        TABLE_ROWS = table.Column<ulong>(nullable: true),//        AVG_ROW_LENGTH = table.Column<ulong>(nullable: true),//        DATA_LENGTH = table.Column<ulong>(nullable: true),//        MAX_DATA_LENGTH = table.Column<ulong>(nullable: true),//        INDEX_LENGTH = table.Column<ulong>(nullable: true),//        DATA_FREE = table.Column<ulong>(nullable: true),//        AUTO_INCREMENT = table.Column<ulong>(nullable: true),//        CREATE_TIME = table.Column<DateTime>(nullable: true),//        UPDATE_TIME = table.Column<DateTime>(nullable: true),//        CHECK_TIME = table.Column<DateTime>(nullable: true),//        TABLE_COLLATION = table.Column<string>(nullable: true),//        CHECKSUM = table.Column<ulong>(nullable: true),//        CREATE_OPTIONS = table.Column<string>(nullable: true),//        TABLE_COMMENT = table.Column<string>(nullable: true)//    },
columns: table => new

*//    constraints: table =>*//    {//        table.PrimaryKey("PK_TABLES", x => new { x.TABLE_CATALOG, x.TABLE_SCHEMA, x.TABLE_NAME, x.TABLE_TYPE });//    });
},

*//    {//        table.PrimaryKey("PK_TABLES", x => new { x.TABLE_CATALOG, x.TABLE_SCHEMA, x.TABLE_NAME, x.TABLE_TYPE });//    });
constraints: table =>

*//        table.PrimaryKey("PK_TABLES", x => new { x.TABLE_CATALOG, x.TABLE_SCHEMA, x.TABLE_NAME, x.TABLE_TYPE });
{

*migrationBuilder.CreateTable(name: "Posts",columns: table => new{PostId = table.Column<int>(nullable: false)
});

*//    schema: "information_schema");*migrationBuilder.DropTable(
name: "TABLES",

*migrationBuilder.DropTable(name: "Blogs");
schema: "information_schema");


*num = num * -1;
こうとか

*num = -num;
こうとか

*}
↑なんか微妙

*num = Math.Abs(num);
Math.Absですっきり


*"ST: service:WANIPConnection:1\r\n"
ST:例


*var (minValue, maxValue) = FindMinAndMax(source);
ValueTupleとしでなく、分解して受ける

*}
中略

*return (min, max);
中略
ここでsource中の最小値・最大値を探す。空なら例外を投げる

*}
略


*manager.JudgeApproveItem(item1);
マネージャーにPC購入の承認を判定してもらう

*manager.JudgeApproveItem(item2);
マネージャーにHigh Spec PC購入の承認を判定してもらう

*manager.JudgeApproveItem(item3);
マネージャーにSuper High Spec PC購入の承認を判定してもらう

*manager.JudgeApproveItem(item4);
マネージャーにUltra High Spec PC購入の承認を判定してもらう


*MemoryStream data = new MemoryStream(File.ReadAllBytes(tb_FileName2.Text));
ファイル読みこみ

*var metadata = new BitmapMetadata("jpg");*metadata.SetQuery("/app1/ifd/gps/subifd:{ushort=1}", GPSLatitudeRef);
metaデータを準備

*using (FileStream stream = new FileStream(tb_FileName2.Text, FileMode.Open)){var enc = new JpegBitmapEncoder();
ファイルに書き込み


*Uri uri = new Uri(tb_FileName.Text, UriKind.Absolute);
ファイル/Metadata読み込み

*,,,
GetQueryしてエラーになる場合、
クエリの中の型(「ushort」の部分)が間違っているかもしれない。
その時は、「読み込み位置の指定(クエリ)の実験」で行ったMetadataの列挙のところで
出力される型を確認する。(画像ファイルによって、型が異なる？)
varの型が実際何かは、デバッグ実行して、この下でとめて、ウォッチの「種類」欄で帰ってきた値の型を見る。
var GPSLatitudeRef = metadata.GetQuery("/app1/ifd/gps/subifd:{ushort=1}");   北緯or南緯
var GPSLatitude = metadata.GetQuery("/app1/ifd/gps/subifd:{ushort=2}");      緯度
var GPSLongitudeRef = metadata.GetQuery("/app1/ifd/gps/{ushort=3}");         東経or西経
var GPSLongitude = metadata.GetQuery("/app1/ifd/gps/{ushort=4}");            経度
var Maker = metadata.GetQuery("/app1/ifd/{ushort=271}");                     メーカー名
var Model = metadata.GetQuery("/app1/ifd/{ushort=272}");                     モデル名
var MakerExif = metadata.GetQuery("/app1/ifd/exif/{ushort=34864}");          Exifバージョン

*Uri uri = new Uri(tb_FileName.Text, UriKind.Absolute);
ファイル/Metadata読み込み

*BitmapMetadata metadata4 = (BitmapMetadata)metadata.GetQuery("/app1/{ushort=0}");
以下は、上の処理と同じ


*public T[] GetFromStr(string str, string tagName)
tagName : データーとして扱うタグ名 (例:<a>data<a> -> a)

*/* ここに文字列から<tagName></tagNeme>で囲まれた文字列をDictionaryに入れていく処理を書く */
keySet<string(タグの名前),string(タグで囲まれた文字列)>


*yield return new WaitUntil(() => ThisProjectSingleton.Instance.isHoleEnter);
ホールにボールが入るまで待つ

*yield return new WaitForSeconds(0.5f);
ホールが消える


*public static M2DVector RotateVector(M2DVector srcVector, double degree)*{double radian = GetRadianByDegree(degree);M2DVector destVector = new M2DVector();destVector.U = (srcVector.U) * Math.Cos(radian) - (srcVector.V) * Math.Sin(radian);destVector.V = (srcVector.U) * Math.Sin(radian) + (srcVector.V) * Math.Cos(radian);return destVector;}
位置ベクトルの回転

*SetMotorSpeed _func_SetMotorSpeed;
SetMotorSpeedメソッドのデリゲート変数

*int _direction = 1;
回転方向 1:正転 -1:逆転

*int _speed = 0;
回転速度


*return $"<speak version='1.0' xmlns='https:
www.w3.org200110synthesis' xml:lang='{speechRecognitionLanguage}'><voice name='{speechName}'>{text}<voice><speak>";


*rate = Mathf.Pow(rate, m_ReactionDistance);
指数関数を加えることにより、収束する勢いを変更できるようにしてる


*Show(Enumerable.Range(5, 3));
コード

*5 6 7
出力


*public static List<Func<int, int, int>> GetFunctionList()*{var list = new List<Func<int, int ,int>>();list.Add(GetAnsPlus);list.Add(GetAnsMinus);list.Add(GetAnsMultiple);list.Add(GetAnsDivide);//list.Add((int x, int y) => x + y);//list.Add((int x, int y) => x - y);//list.Add((int x, int y) => x * y);//list.Add((int x, int y) => x / y);list.Add((x, y) => x + y);list.Add((x, y) => x - y);list.Add((x, y) => x * y);list.Add((x, y) => x / y);return list;}
関数定義

*public static void Export(List<Func<int, int, int>> list, int x, int y)*{foreach (var f in list){Console.WriteLine(f(x, y));}}
出力


*public class ListBox  { }
System.Windows.Forms.Form.ListBox  の代役 }

*public abstract class ChangedHistory*{public bool isChanged = false;public List<string> list = new List<string>();public abstract void SetChangedData(string arg);public int GetHistCnt() { return list.Count; }}
履歴を保持して最新を返すという抽象クラス

*public class HistoryA : ChangedHistory, ICommon*{public override void SetChangedData(string arg){isChanged = true;list.Add(arg);}public string GetValue(){string ret = "HistoryA:";if (isChanged){ret = list[list.Count - 1];}return ret;}}
「何かA」の変更履歴を管理するクラス (※このサンプルではA/B同型だけどホントは異なるつもりで。)

*public class HistoryB : ChangedHistory, ICommon*{public override void SetChangedData(string arg){isChanged = true;list.Add(arg);}public string GetValue(){string ret = "HistoryB:";if (isChanged){ret = list[list.Count - 1];}return ret;}}
「何かB」の変更履歴を管理するクラス (※このサンプルではA/B同型だけどホントは異なるつもりで。)

*public class TextBoxEx : TextBox, ICommon*{public string GetValue(){string ret = "TextBoxEx:";//ret = TextBoxから値を取得return ret;}}
TextBoxから値を取得するクラス

*return ret;
ret = TextBoxから値を取得

*public class ComboBoxEx : ComboBox, ICommon*{public string GetValue(){string ret = "ComboBoxEx:";//ret = ComboBoxから値を取得return ret;}}
ComboBoxから値を取得するクラス

*return ret;
ret = ComboBoxから値を取得

*public class ListBoxEx : ListBox, ICommon*{public string GetValue(){string ret = "ListBoxEx:";//ret = ListBoxから値を取得return ret;}}
ListBoxから値を取得するクラス

*return ret;
ret = ListBoxから値を取得


*Console.WriteLine("itr = [" + itr.ToString() + "], y = [" + y.ToString() + "]");
ループを実況。。。


*temp = await resGetAsync();
サーバからのメッセージを受け取る


*context.ResponseTrailers.Add("result", "1");
ServerCallContext にトレーラーを格納し、

*throw new RpcException(new Status(StatusCode.Unauthenticated, "Unauthenticated.")
ServerCallContext からトレーラーを取得して例外に格納する。

*Metadata trailers = new Metadata();
Metadata にトレーラーを格納し、

*throw new RpcException(new Status(StatusCode.Unauthenticated, "Unauthenticated.")
Metadata を例外に格納する。

*Response response = await rpcClient.GetData(new Request());
このメソッド呼び出しが終わらない。

*Debug.WriteLine(ex.ToString());
切断されたりするまで例外はキャッチされない。


*.Select(count => (count & 1) == 0);
trueから開始


*private const string TargetDirectory = "Assets/ServerDefinition";
監視するディレクトリ

*var files = new[] { importedAssets, deletedAssets, movedAssets, movedFromAssetPaths }.SelectMany(_ => _);
TargetDirectory のファイルが更新されたか確認

*var process = Process.Start(new ProcessStartInfo{FileName = "/path/to/mpc",Arguments = "-i Assets -o Assets/GeneratedScripts/GeneratedResolver.cs",UseShellExecute = false,RedirectStandardOutput = true,RedirectStandardError = true,});
外部プロセス起動

*UnityEngine.Debug.Log(process.StandardOutput.ReadToEnd());
標準出力

*var error = process.StandardError.ReadToEnd();
標準エラー出力

*private const string TargetDirectory = "Assets/ServerDefinition";
監視するディレクトリ

*private const string AutoBuildMenuPath = "Tools/MessagePack/Auto Build";
自動ビルド設定のMenuPath

*if (!Menu.GetChecked(AutoBuildMenuPath)) return;*// TargetDirectory のファイルが更新されたか確認
自動ビルドがOFFなら終了

*var files = new[] { importedAssets, deletedAssets, movedAssets, movedFromAssetPaths }.SelectMany(_ => _);
TargetDirectory のファイルが更新されたか確認

*Environment.SetEnvironmentVariable("PATH", "/usr/local/share/dotnet");
dotnet コマンドのパスを通す

*DoProcess(command: "../Tools/MagicOnionCodeGenerator/osx-x64/moc",arguments: "-i ../Server/ServerDefinition/ServerDefinition.csproj -o Assets/GeneratedScripts/MagicOnionResolver.cs");
MagicOnionCodeGenerator

*DoProcess(command: "../Tools/MessagePackCompiler/osx-x64/mpc",arguments: "-i Assets -o Assets/GeneratedScripts/GeneratedResolver.cs");
MessagePackCompiler


*}
ここに各イベントごとの呼び出し処理を書く


*[Inject]
👇 "?" はこのプロパティ値が null になり得ることを示します.

*await this.JS!.InvokeVoidAsync("foo");
👇 "!" 記号で、null 状態確認を無視させる。

*[Inject, AllowNull]*public IJSRuntime JS { get; set; }
👇 [AllowNull] 属性を追加

*this.JS = null;
👇 null を設定してもコンパイラから何も言われない 😥

*#pragma warning disable CS8618
👇 "warning disable" プラグマで当該プロパティを囲う

*,,,*public partial class MyComponent {...// コードビハインドの C# ファイル中辛はそれを使うだけ。await this.JS.InvokeVoidAsync("foo");,,,*await this.JS.InvokeVoidAsync("foo");
コードビハインドの C# ファイル中辛はそれを使うだけ。


*, EventLogEntryType.Information);
, 4);


*,,,
実行結果
これは間違いなので確認してください(列番号 : 1)

*System.Console.WriteLine($"{alert}{number})");
こんな方法もあります1(by @albireo さん)

*ちょっと変数を変えて
こんな方法もあります2(by @shoe0227 さん)

*,,,
実行結果
これは間違いなので確認してください(列番号 : 1)


*string[] berries = new string[]{"blackberry", "blueberry", "strawberry", "cranberry", "raspberry", "blueberry"};
リスト

*string[] berries = new string[]{"blackberry", "blueberry", "strawberry", "cranberry", "raspberry", "blueberry"};
リスト


*public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)*{if (values[0] is string == false) throw new ArgumentException("第1引数がstring型ではありません。");if (values[1] is double == false) throw new ArgumentException("第2引数がdouble型ではありません。");if (values[2] is TextBlock == false) throw new ArgumentException("第3引数がTextBlock型ではありません。");var str = values[0] as string;var actualWidth = (double)values[1];var textBlock = values[2] as TextBlock;double displayWidth = actualWidth - 10;double currentWidth = GetDrawingWidth(str, textBlock);// 省略時に末尾に設定する文字列string ellipsis = "(略";// Xaml側でConverterParameterに"(略"を設定している場合は以下でも処理できました// string ellipsis = (string)parameter;if (string.IsNullOrWhiteSpace(str) || displayWidth <= 0){return str + ellipsis;}if (currentWidth < displayWidth){return str;}else{string trimmedText = str;while (currentWidth > displayWidth){trimmedText = trimmedText.Substring(0, trimmedText.Length - 1);currentWidth = this.GetDrawingWidth(trimmedText + ellipsis, textBlock);if (string.IsNullOrWhiteSpace(trimmedText)){break;}}return trimmedText + ellipsis;}}
ViewModel -> Viewの通知が動作した時処理されるConverter

*string ellipsis = "(略";Xaml側でConverterParameterに"(略"を設定している場合は以下でも処理できましたstring ellipsis = (string)parameter;
省略時に末尾に設定する文字列

*if (string.IsNullOrWhiteSpace(str) || displayWidth <= 0)
Xaml側でConverterParameterに"(略"を設定している場合は以下でも処理できました
string ellipsis = (string)parameter;

*private double GetDrawingWidth(string str, TextBlock textBlock)*{var formattedText = new FormattedText(str,CultureInfo.CurrentCulture,textBlock.FlowDirection,new Typeface(textBlock.FontFamily, textBlock.FontStyle, textBlock.FontWeight, textBlock.FontStretch),textBlock.FontSize,textBlock.Foreground);return formattedText.Width;}
実際の書式設定で文字列の描画幅を取得します

*public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)*{throw new NotImplementedException();}
View -> ViewModelの通知が動作した時処理されるConverter


*public FirstPageViewModel()*{this.NavigateNextCommand = new RelayCommand<object>(this.NavigateNext);}
：

*protected void NavigateNext(object parameter)*{var navigationWindow = (NavigationWindow)Application.Current.MainWindow;navigationWindow.Navigate(new SecondPage(), parameter);}
：

*public Uri NavigatePage*{get { return (Uri)GetValue(NavigatePageProperty); }set {  SetValue(NavigatePageProperty, value); }}
遷移先のページ

*public object NavigateExtraData*{get { return GetValue(NavigateExtraDataProperty); }set { SetValue(NavigateExtraDataProperty, value); }}
遷移先に渡すパラメータ

*private void AssociatedObjectClick(object sender, RoutedEventArgs e)*{if (this.NavigatePage == null){return;}var button = (ButtonBase)sender;var navigationService = GetNavigationService(button);if (navigationService == null){return;}// 現ページのパッケージURLを取得して相対パスを絶対パスに変換する。// ※new Uri(((IUriContext)navigationWindow).BaseUri, this.NavigatePage) だと// 　ナビゲーションウィンドウXAMLからの相対パスになるので、サブディレクトリとの間で遷移できない。var baseUri = BaseUriHelper.GetBaseUri(button);var uri = new Uri(baseUri, this.NavigatePage);// ナビゲートnavigationService.Navigate(uri, this.NavigateExtraData);}
クリックされたときの処理

*var baseUri = BaseUriHelper.GetBaseUri(button);
現ページのパッケージURLを取得して相対パスを絶対パスに変換する。
※new Uri(((IUriContext)navigationWindow).BaseUri, this.NavigatePage) だと
ナビゲーションウィンドウXAMLからの相対パスになるので、サブディレクトリとの間で遷移できない。

*navigationService.Navigate(uri, this.NavigateExtraData);
ナビゲート

*return navigationWindow.NavigationService;
NavigationWindow の場合

*return frame.NavigationService;
プレーンな（非 Navigation）Window で Frame を使用している場合


*this.Refresh();
これを忘れると抑制解除したあとで描画が行われません

*private void button2_Click(object sender, EventArgs e)*{using (var sus = new FormRedrawSuspension(this)){// このなかでフォームの描画が抑制されます}// 抜けるとき（FormRedrawSuspensionオブジェクトがDisposeされるとき）に、フォームがRefreshされます。}
※2019/3/12 追加：こちらのほうがより安全

*}
このなかでフォームの描画が抑制されます

*}
抜けるとき（FormRedrawSuspensionオブジェクトがDisposeされるとき）に、フォームがRefreshされます。

*private NativeMethods() { }
https:docs.microsoft.com/ja-jp/visualstudio/code-quality/ca1060-move-p-invokes-to-nativemethods-class

*private NativeMethods() { }
https:docs.microsoft.com/ja-jp/visualstudio/code-quality/ca1060-move-p-invokes-to-nativemethods-class


*Console.WriteLine(result);
=> "edo"

*Type ctorType = typeof(HogeClass);
生成するインスタンスの型

*ParameterExpression propParam = Expression.Parameter(typeof(int), "propParam");
引数で受け取る値のパラメータ

*NewExpression ctor = Expression.New(ctorType);
インスタンス生成式

*ParameterExpression local = Expression.Parameter(ctorType, "instance");
生成したインスタンスを参照するローカル変数

*MemberExpression prop = Expression.Property(local, "AnyProperty");
インスタンスのプロパティアクセス

*LabelTarget returnTarget = Expression.Label(ctorType);
戻り値の型

*GotoExpression returnExpr = Expression.Return(returnTarget, local, ctorType);
戻り値の設定

*LabelExpression returnLabel = Expression.Label(returnTarget, Expression.Default(ctorType));
ちょっとこれの理由は不明・・・

*BlockExpression body = Expression.Block(new[] { local },Expression.Assign(local, ctor),
上記処理を行うブロック文

*LambdaExpression lambda = Expression.Lambda<Func<int, HogeClass>>(body, propParam);
ラムダ式の生成

*var result = func(33);
結果を受け取る

*ParameterExpression arg1 = Expression.Parameter(typeof(AnyBase), "arg1");
メソッドの引数に対象クラスのTypeをもらう想定
ラムダ式の引数として与えられるパラメータ

*ParameterExpression local1 = Expression.Parameter(type, "instance1");
ローカルで利用するためのローカル変数パラメータ

*MethodCallExpression convertExpr1 = Expression.Call(typeof(Convert), "ChangeType", null, arg1, Expression.Constant(local1.Type));
引数をキャストする

*BinaryExpression castAssign1 = Expression.Assign(local1, valueCast1);
キャストした引数をローカル変数にアサインする


*[Theory]
Theoryは引数ありテスト
MemberDataのメソッドから引数を取得する

*public static IEnumerable<object[]> Constructor_Data()*{return new[] {new object[] { TypeKind.Null  , ""        },new object[] { TypeKind.Null  , "null"    },new object[] { TypeKind.Bool  , "true"    },new object[] { TypeKind.Bool  , "false"   },new object[] { TypeKind.Number, "0.0"     },new object[] { TypeKind.Number, "789"     },new object[] { TypeKind.Number, "-12.345" },new object[] { TypeKind.String, "a123"    },new object[] { TypeKind.String, "$#@?+"   }};}
上記テストメソッドに引数を渡す

*public interface IHoge*{int  Fuga(int x);void Piyo(int x);}
モックにしたいインターフェイス

*mock.Setup(hoge => hoge.Fuga(It.IsAny<int>()))
Fugaメソッドの呼び出しをセットアップする
常に「引数 + 1」を返すように設定

*mock.Verify(hoge => hoge.Piyo(  1), Times.Once);*mock.Verify(hoge => hoge.Piyo(  2), Times.AtLeastOnce);
Piyoメソッドの呼び出しを検証する

*[Dependency]
IHogeインターフェイスに注入する
Hogeクラスへの依存が存在しない

*var container = new UnityContainer();
DIコンテナの設定

*var fuga = container.Resolve<Fuga>();
Fugaインスタンスの生成


*public void WriteLine()*{Console.WriteLine($"{Value} : {ToString(TypeKind)}");}
...


*private float x_speed = 0;
フリック時のスピード

*private float cameraSpeed = 0.4f;
カメラ拡大縮小時のスピード（実装環境によって要調整）

*private Vector2 startPos;
初期位置

*private float duration = 0;
最初のタップからの経過時間

*private float moveRatio = 0.5f;
オブジェクトの移動比率を操作する変数（実装環境によって要調整）

*public GameObject obj;
スワイプするオブジェクト（この場合スクロールビューのコンテンツ）の外部参照

*public Camera cam;
拡大縮小用カメラの外部参照

*duration += Time.deltaTime;
経過時間の計算

*Touch touch = Input.GetTouch(0);
タップ情報の取得

*case TouchPhase.Began:
タップ開始

*this.startPos = Input.mousePosition;
タッチ開始座標、時間取得

*case TouchPhase.Moved:
タップ中、指が動いている

*Vector3 nowPosi = obj.transform.localPosition;*nowPosi.x = nowPosi.x - touch.deltaPosition.x*moveRatio;
オブジェクト移動(スワイプ)

*case TouchPhase.Ended:
タップ終了

*Vector2 endPos = Input.mousePosition;
タップ終了位置取得

*this.x_speed = x_flickLength / 500.0f;
フリックの長さを速度に変換する

*this.x_speed = 0;
フリック判定じゃない場合はcameraのTranslate速度を0にする

*obj.transform.Translate(this.x_speed, this.y_speed, 0);*//毎フレーム減速させる
オブジェクト移動(フリック)

*this.x_speed *= 0.8f;
毎フレーム減速させる

*Touch touchZero = Input.GetTouch(0);
両方のタップ情報を取得

*Vector2 touchZeroPrePos = touchZero.position - touchZero.deltaPosition;
前フレームでのタップ位置

*float preTouchDeltaMag = (touchZeroPrePos - touchOnePrePos).magnitude;
各フレームのタッチ間の距離

*float deltaMagnitudeDif = preTouchDeltaMag - touchDeltaMag;*//タッチ間の距離の変化からカメラの平行投影サイズを変更
各フレーム間の距離の差

*cam.orthographicSize += deltaMagnitudeDif * cameraSpeed;*// 平行投影サイズは0以上になるようにする(クランプの範囲は要調整)
タッチ間の距離の変化からカメラの平行投影サイズを変更

*cam.orthographicSize = Mathf.Clamp(cam.orthographicSize, 0f , 2.0f);
平行投影サイズは0以上になるようにする(クランプの範囲は要調整)


*public static double AddByStaticStrategy_Primitive()*{var result = 0.0;{var x = new Container<int>(1);var y = new Container<int>(1);for(var i = 0; i < Iteration; ++i)x = Container<int>.AddByStaticStrategy(x, y);result += x.Value;}{var x = new Container<double>(1);var y = new Container<double>(1);for(var i = 0; i < Iteration; ++i)x = Container<double>.AddByStaticStrategy(x, y);result += x.Value;}return result;}
こんな感じのメソッドをPrimitive/Struct/Class、および各特殊化手法ごとに定義していく


*File.WriteAllLines(fi.FullName, lines);
上の行を削除してFile.WriteAllText(fi.FullName, toCsv)でもOK

*// File.WriteAllLines(fi.FullName, content.Replace("\t", ",").Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries));
ワンライナー版

*string[] sepArr = new string[] { "\r\n" };
File.WriteAllLines(fi.FullName, content.Replace("\t", ",").Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries));


*throw;
適宜


*private const int WM_IME_ENDCOMPOSITION = 0x10E;
IME変換終了

*IntPtr himc = ImmCreateContext();
Imeを関連付ける

*IntPtr hImc = ImmGetContext(this.Handle);
入力コンテキストにアクセスするためのお約束

*COMPOSITIONFORM info = new COMPOSITIONFORM();
コンポジションウィンドウの位置を設定

*ImmReleaseContext(Handle, hImc);
コンポジションウィンドウのフォントを設定
ImmSetCompositionFont(hImc, m_Focus->GetFont()->GetInfoLog());
入力コンテキストへのアクセスが終了したらロックを解除する

*base.WndProc(ref m);
IME以外のメッセージは元のプロシージャで処理


*using (var request  = new HttpRequestMessage(HttpMethod.Get, new Uri("https:
127.0.0.1:8443test.dat")))


*public byte[] FileDataColumn { get; set; }
：


*RenderSettings.skybox = sky;
切り替えたいタイミングでこれを書く

*RenderSettings.skybox = sky;
切り替えたいタイミングでこれを書く

*[Range(0.01f,0.1f)]
回転スピード

*RenderSettings.skybox = sky;
切り替えたいタイミングでこれを書く


*return $"<speak version='1.0' xmlns='https:
www.w3.org200110synthesis' xml:lang='ja-JP'><voice name='ja-JP-NanamiNeural'>{text}<voice><speak>";


*options.AddPolicy("SellerPolicy", policy => policy.RequireRole("Seller"));
アクセス制限用ポリシーを追加

*options.Conventions.AuthorizeAreaFolder("Seller", "/Items", "SellerPolicy");
販売者の作品関連ページ

*options.Conventions.AuthorizeFolder("/Purchase");
購入関連ページ

*options.Conventions.AllowAnonymousToPage("/Purchase/Cart");
カートページはログインしていなくても許可

*});
NOTE: まとめて以下のように書いても良い
options.Conventions
.AuthorizeFolder("/Purchase")
.AllowAnonymousToPage("/Purchase/Cart");

*options.Conventions.AuthorizePage("/User/Purchase");
購入作品一覧ページ

*options.AddPolicy("SellerPolicy", policy => policy.RequireRole("Seller"));
アクセス制限用ポリシーを追加

*options.Conventions.AuthorizeAreaFolder("Seller", "/Items","SellerPolicy");
販売者の作品関連ページ

*options.Conventions.AuthorizeFolder("/Purchase");
購入関連ページ

*options.Conventions.AllowAnonymousToPage("/Purchase/Cart");
カートページはログインしていなくても許可

*options.Conventions.AuthorizePage("/User/Purchase");
購入作品一覧ページ


*time += Time.deltaTime;
timeを加算し続ける。

*print(time);
時間経過を見るためコンソールに時間を表示させる。


*static Refresh()*{EditorApplication.update += ProjectWindowUpdate;}
コンストラクタ

*static Refresh()*{EditorApplication.update += ProjectWindowUpdate;}
コンストラクタ


*string input_str = base64_textbox_before.Text;*// 指定された文字コードでインスタンス化する
テキストボックス（base64_textbox_before）に入力された文字列を取得する

*Encoding enc = Encoding.GetEncoding(base64_radio_button);
指定された文字コードでインスタンス化する

*byte[] convert_str = enc.GetBytes(input_str);
指定された文字コードに従い,バイト型で取り扱う

*string after_str = Convert.ToBase64String(convert_str);
Base64エンコードし,文字列として結果を保存する（注：引数はコードページ値もしくはWebNameプロパティ値であること）

*byte[] convert_str = Convert.FromBase64String(input_str);
デコードする場合,以下の方法でデコードする

*base64_textbox_after.Text = after_str;
変換結果をもう一つのテキストボックス（base64_textbox_after）に表示する

*string input_str = url_textbox_before.Text;*// 指定された文字コードを取得
テキストボックスに入力された文字列を取得

*System.Text.Encoding charcode = System.Text.Encoding.GetEncoding(url_radio_button);
指定された文字コードを取得

*string after_str = System.Web.HttpUtility.UrlEncode(input_str,charcode);
文字列を指定された文字コードに従い,URLエンコードする

*string after_str = System.Web.HttpUtility.UrlDecode(tmp_str,charcode);
デコードの場合,以下のメソッドを利用する

*url_textbox_after.Text = after_str;
変換結果をもう一つのテキストボックスに表示する

*string after_str = System.Web.HttpUtility.HtmlEncode(input_str);
文字実体参照にエンコードする

*string after_str = System.Web.HttpUtility.HtmlDecode(input_str);
数値文字参照および文字実体参照をデコードする

*this.[textbox_name].KeyDown += new System.Windows.Forms.KeyEventHandler(this.[textbox_name]_KeyDown);
以下を対応するForm.Designer.csに追記する

*private void [textbox_name]_KeyDown(object sender, KeyEventArgs e)*{if (e.Control && e.KeyCode == Keys.A){[textbox_name].SelectAll();}}
以下を対応するForm.csに追記する

*今回はindex=0（文字列コレクションの一番上の文字列）を初期値とするthis.comboBox1.SelectedIndex = 0;
以下を対応するForm.Designer.csに追記する

*this.comboBox1.SelectedIndex = 0;
今回はindex=0（文字列コレクションの一番上の文字列）を初期値とする


*var dataList = new List<WriteData>();*foreach (var assertion in ret.assertions) {dataList.Add(new WriteData(assertion.User_Id, assertion.User_Name, assertion.User_DisplayName));}
dataList

*readData.data = new byte[0];*foreach (var data in dataList) {var tmp = data.data1.ToList().Concat(data.data2).Concat(data.data3).ToList();readData.data = readData.data.ToList().Concat(tmp).ToArray();}
data

*public static byte[] Decrypt(byte[] inData)*{// AES-256key = Encoding.UTF8.GetBytes("ygmh8zudlw5u0a9w4vc29whc4b8wuech");iv = Encoding.UTF8.GetBytes( "o10wi1q3x2f98cobfkyisnwy9s9wxop7");// Rijndael// Mode = CBC// BlockSize = 256bit// PaddingMode = Zerovar cbcBlockCipher = new CbcBlockCipher(new RijndaelEngine(256));cipher = new PaddedBufferedBlockCipher(cbcBlockCipher, new ZeroBytePadding());parametersWithIV = new ParametersWithIV(new KeyParameter(key), iv);cipher.Init(false, parametersWithIV);var bytes = new byte[cipher.GetOutputSize(inData.Length)];var length = cipher.ProcessBytes(inData, bytes, 0);var ret = cipher.DoFinal(bytes, length);return bytes;}
inDataが暗号化されているデータです

*Mode = CBCBlockSize = 256bitPaddingMode = Zerovar cbcBlockCipher = new CbcBlockCipher(new RijndaelEngine(256));
Rijndael

*BlockSize = 256bitPaddingMode = Zerovar cbcBlockCipher = new CbcBlockCipher(new RijndaelEngine(256));
Mode = CBC

*PaddingMode = Zerovar cbcBlockCipher = new CbcBlockCipher(new RijndaelEngine(256));
BlockSize = 256bit

*pems.RemoveAt(0);
ヘッダとフッダは飛ばす

*var base64 = String.Join("", pems);
つなげる

*return (Convert.FromBase64String(base64));
もどす

*public static byte[] Encrypt(byte[] inData)*{key = Encoding.UTF8.GetBytes("ygmh8zudlw5u0a9w4vc29whc4b8wuech");iv = Encoding.UTF8.GetBytes( "o10wi1q3x2f98cobfkyisnwy9s9wxop7");// Rijndael// Mode = CBC// BlockSize = 256bit// PaddingMode = Zerovar cbcBlockCipher = new CbcBlockCipher(new RijndaelEngine(256));cipher = new PaddedBufferedBlockCipher(cbcBlockCipher, new ZeroBytePadding());parametersWithIV = new ParametersWithIV(new KeyParameter(key), iv);cipher.Init(true, parametersWithIV);var bytes = new byte[cipher.GetOutputSize(inData.Length)];var length = cipher.ProcessBytes(inData, bytes, 0);cipher.DoFinal(bytes, length);return bytes;}
inDataがDER形式の秘密鍵です

*Mode = CBCBlockSize = 256bitPaddingMode = Zerovar cbcBlockCipher = new CbcBlockCipher(new RijndaelEngine(256));
Rijndael

*BlockSize = 256bitPaddingMode = Zerovar cbcBlockCipher = new CbcBlockCipher(new RijndaelEngine(256));
Mode = CBC

*PaddingMode = Zerovar cbcBlockCipher = new CbcBlockCipher(new RijndaelEngine(256));
BlockSize = 256bit

*private async Task<bool> setNewPIN()*{var status = await gebo.CTAP2.WebAuthnModokiDesktop.Credentials.SetPin(gebo.CTAP2.DevParam.GetDefaultParams(), "1234");if( status.isSuccess == false) {// Errorreturn false;}return true;}
PINは1234

*var name = new X509Name(ord, attr);
証明書の生成

*var mem = new MemoryStream();*using (var writer = new StreamWriter(mem, Encoding.ASCII)) {var pemWriter = new PemWriter(writer);pemWriter.WriteObject(cert);pemWriter.Writer.Flush();}
証明書の出力

*var devParam = gebo.CTAP2.DevParam.GetDefaultParams();
newpin=新しいPIN、currentpin=現在のPIN

*} else {
OK

*public static string ConvertPrivateKeyDERtoPEM(byte[] der)
1.Base64エンコード
2.64文字ごとに改行コードをいれる
3.ヘッダとフッタを入れる

*var privateKeyReader = new PemReader(new StringReader(pemPrivateKey));
PEMフォーマットの秘密鍵を読み込んで KeyPair オブジェクトを生成

*using (var z = ZipFile.Open(zipFile, ZipArchiveMode.Update)){z.CreateEntryFromFile(targetFile, targetFileName, CompressionLevel.Optimal);
zipに固める

*private AsymmetricKeyParameter readPublicKeyfromCert(string certFile)*{Org.BouncyCastle.X509.X509Certificate readedCert;// 証明書の読み込みusing (var reader = new StreamReader(certFile, Encoding.ASCII)) {var pemReader = new PemReader(reader);readedCert = (Org.BouncyCastle.X509.X509Certificate)pemReader.ReadObject();}var publicKey = readedCert.GetPublicKey();return (publicKey);}
certFileは証明書のパスファイル名です

*using (var reader = new StreamReader(certFile, Encoding.ASCII)) {var pemReader = new PemReader(reader);
証明書の読み込み


*var dict = new Dictionary<string, int> {{ "a", 0 },{ "b", 0 },{ "c", 0 },{ null, 0 },};
例外が発生する


*this.PixelShader = pixelShader;
ShaderEffect.PixelShader プロパティにセット


*var requestMock = new HttpRequestMock(new NameValueCollection() { { "hoge", "12345" } });
Arrange


*// 'Operation is not supported on this platform.'*rsa.FromXmlString(privateKey);
ここで PlatformNotSupportedException がスローされます。

*rsa.FromXmlStringEx(privateKey);
鍵を読み込むことができます。.NET Core 2.1 で確認。
シグネチャが同一である場合は拡張メソッドではなく本体に実装されているメソッドが優先されるため、メソッド名は変更しました。


*private void Form1_Load(object sender, EventArgs e)*{//開始時に現在時刻の記録DateTime localTime = DateTime.Now;File.AppendAllText(@"timelog.txt", localTime+" ", Encoding.UTF8);}
Form開始時の処理

*DateTime localTime = DateTime.Now;
開始時に現在時刻の記録

*private void Form1_FormClosing(object sender, FormClosingEventArgs e)*{//終了時に現在時刻の記録DateTime localTime = DateTime.Now;File.AppendAllText(@"timelog.txt", localTime + Environment.NewLine, Encoding.UTF8);}
Form終了時の処理

*DateTime localTime = DateTime.Now;
終了時に現在時刻の記録


*8,
GraphicsMode.Default.Samples,

*GLControl glControl = new GLControl(mode);
コンテキストの作成

*glControl.Load += glControl_Load;
イベントの追加

*glHost.Child = glControl;
ホストの子に設定

*GL.ClearColor(Color4.White);
背景色の設定

*GL.Viewport(0, 0, glControl.Width, glControl.Height);
ビューポートの設定

*GL.MatrixMode(MatrixMode.Projection);
視体積の設定

*GL.MatrixMode(MatrixMode.Modelview);
視界の設定

*GL.Enable(EnableCap.DepthTest);
デプスバッファの使用

*GL.Enable(EnableCap.Lighting);
光源の使用

*GL.Viewport(0, 0, glControl.Width, glControl.Height);
ビューポートの設定


*using (var context = new NorthwindEntities()){トランザクション開始using (var transaction = context.Database.BeginTransaction()){1つめの SaveChanges()var product = await context.Products.SingleAsync(p => p.ProductID == 1).ConfigureAwait(false);
コンテキスト

*using (var transaction = context.Database.BeginTransaction()){1つめの SaveChanges()var product = await context.Products.SingleAsync(p => p.ProductID == 1).ConfigureAwait(false);
トランザクション開始

*var product = await context.Products.SingleAsync(p => p.ProductID == 1).ConfigureAwait(false);
1つめの SaveChanges()

*var employee = await context.Employees.SingleAsync(e => e.EmployeeID == 1).ConfigureAwait(false);
2つめの SaveChanges()

*transaction.Commit();
まとめてコミット

*var workspace = NorthwindEntities.GetMetadataWorkspace();
接続準備

*sqlConnection.Open();
あらかじめ接続を開いておく。

*using (var transaction = sqlConnection.BeginTransaction()){1つ目のコンテキストを操作する。using (var context = new NorthwindEntities(entityConnection1, false)){context.Database.UseTransaction(transaction);
トランザクション開始

*using (var context = new NorthwindEntities(entityConnection1, false)){context.Database.UseTransaction(transaction);
1つ目のコンテキストを操作する。

*using (var context = new NorthwindEntities(entityConnection2, false))
別の EntityConnection を使って2つ目のコンテキストを操作する。
※同じ EntityConnection を使用すると InvalidOperationException が発生する。

*transaction.Commit();
まとめてコミット

*public partial class NorthwindEntities : DbContext*{/// <summary>/// コンストラクタ。/// </summary>/// <param name="existingConnection">コンテキストで使用する接続。</param>/// <param name="contextOwnsConnection">false を指定すると、コンテキストが Dispose されたときに接続を Dispose しない。</param>public NorthwindEntities(DbConnection existingConnection, bool contextOwnsConnection): base(existingConnection, contextOwnsConnection){}/// <summary>/// メタデータワークスペースを取得する。/// </summary>/// <returns></returns>public static MetadataWorkspace GetMetadataWorkspace(){using (var context = new NorthwindEntities()){var objectContext = ((IObjectContextAdapter)context).ObjectContext;return objectContext.MetadataWorkspace;}}}
コンテキストの部分クラス


*Hello();
シンボルAAAが定義されていないため、下のHello()の呼び出しはコンパイルされない


*UpdateCube(frame);
デバッグ用Cubeを表示する

*Vector3 pos_forward = TriangleNormal(now_pos[7], now_pos[4], now_pos[1]);*bone_t[0].position = now_pos[0] * scale_ratio + new Vector3(init_position.x, heal_position, init_position.z);
センターの移動と回転

*bone_t[8].rotation = Quaternion.AngleAxis(head_angle, bone_t[11].position - bone_t[14].position) * bone_t[8].rotation;
顔の向きを上げる調整。両肩を結ぶ線を軸として回転


*private const string EndpointUrl = "https:
<your-account>.documents.azure.com:443";

*Database database = await cosmosClient.CreateDatabaseIfNotExistsAsync(DatabaseId);*Console.WriteLine("Created Database: {0}\n", database.Id);
Create a new database

*Container container = await cosmosClient.GetDatabase(DatabaseId).CreateContainerIfNotExistsAsync(ContainerId, "/LastName");*Console.WriteLine("Created Container: {0}\n", container.Id);
Create a new container

*Family andersenFamily = new Family{Id = "Andersen.1",LastName = "Andersen",Parents = new Parent[]{new Parent { FirstName = "Thomas" },new Parent { FirstName = "Mary Kay" }},Children = new Child[]{new Child{FirstName = "Henriette Thaulow",Gender = "female",Grade = 5,Pets = new Pet[]{new Pet { GivenName = "Fluffy" }}}},Address = new Address { State = "WA", County = "King", City = "Seattle" },IsRegistered = false};
Create a family object for the Andersen family

*ItemResponse<Family> andersenFamilyResponse = await container.ReadItemAsync<Family>(andersenFamily.Id, new PartitionKey(andersenFamily.LastName));*Console.WriteLine("Item in database with id: {0} already exists\n", andersenFamilyResponse.Resource.Id);
Read the item to see if it exists.

*Console.WriteLine("Created item in database with id: {0}\n", andersenFamilyResponse.Resource.Id);
Note that after creating the item, we can access the body of the item with the Resource property off the ItemResponse.

*Family wakefieldFamily = new Family{Id = "Wakefield.7",LastName = "Wakefield",Parents = new Parent[]{new Parent { FamilyName = "Wakefield", FirstName = "Robin" },new Parent { FamilyName = "Miller", FirstName = "Ben" }},Children = new Child[]{new Child{FamilyName = "Merriam",FirstName = "Jesse",Gender = "female",Grade = 8,Pets = new Pet[]{new Pet { GivenName = "Goofy" },new Pet { GivenName = "Shadow" }}},new Child{FamilyName = "Miller",FirstName = "Lisa",Gender = "female",Grade = 1}},Address = new Address { State = "NY", County = "Manhattan", City = "NY" },IsRegistered = true};
Create a family object for the Wakefield family

*Console.WriteLine("Created item in database with id: {0}\n", wakefieldFamilyResponse.Resource.Id);
Note that after creating the item, we can access the body of the item with the Resource property off the ItemResponse. We can also access the RequestCharge property to see the amount of RUs consumed on this request.

*var sqlQueryText = "SELECT * FROM c";*Console.WriteLine("Running query: {0}\n", sqlQueryText);
var sqlQueryText = "SELECT * FROM c WHERE c.LastName = 'Andersen'";

*using (FeedIterator<Family> feedIterator = container.GetItemQueryIterator<Family>(queryDefinition))*{while (feedIterator.HasMoreResults){FeedResponse<Family> response = await feedIterator.ReadNextAsync();foreach (Family family in response){//families.Add(family);Console.WriteLine("\tRead {0}\n", family);}}}
List<Family> families = new List<Family>();

*Console.WriteLine("\tRead {0}\n", family);
families.Add(family);

*wakefieldFamilyResponse = await container.ReplaceItemAsync<Family>(itemBody, itemBody.Id, new PartitionKey(itemBody.LastName));*Console.WriteLine("Updated Family [{0},{1}].\n \tBody is now: {2}\n", itemBody.LastName, itemBody.Id, wakefieldFamilyResponse.Resource);
replace the item with the updated content

*ItemResponse<Family> wakefieldFamilyResponse = await container.DeleteItemAsync<Family>(familyId, new PartitionKey(partitionKeyValue));*Console.WriteLine("Deleted Family [{0},{1}]\n", partitionKeyValue, familyId);
Delete an item. Note we must provide the partition key value and id of the item to delete


*var response = await base.UnaryServerHandler(request, context, continuation);
通常処理

*Services = { service.ServerServiceDefinition.Intercept(new HogeInterceptor()) },挟まない場合はこうServices = { service },Ports = { new ServerPort("localhost", 12345, ServerCredentials.Insecure) }};
ここで Interceptor を挟んだ ServerServiceDefinition を渡す

*Services = { service },Ports = { new ServerPort("localhost", 12345, ServerCredentials.Insecure) }};
挟まない場合はこう

*Ports = { new ServerPort("localhost", 12345, ServerCredentials.Insecure) }};
Services = { service },

*var invoker = channel.Intercept(new HogeInterceptor());
ここで Interceptor を挟んだ CallInvoker を生成

*,,,
挟まない場合はこう
var client = MagicOnionClient.Create<IMyFirstService>(channel);


*}
なにかしらの処理


*"20"
第2引数

*var sr = process.StandardOutput;
python側でprintした内容を取得


*tab.Height = tab.ItemSize.height * tab.RowCount + tabPage.Height;
「タブの高さ」×「タブストリップの行数」＋「タブページの高さ」でtab全体を表示するための高さを取得


*app.UseForwardedHeaders(new Microsoft.AspNetCore.Builder.ForwardedHeadersOptions{ForwardedHeaders = Microsoft.AspNetCore.HttpOverrides.ForwardedHeaders.XForwardedFor | Microsoft.AspNetCore.HttpOverrides.ForwardedHeaders.XForwardedProto});
リバースプロキシー設定用

*services.Configure<Microsoft.Extensions.WebEncoders.WebEncoderOptions>(options =>{options.TextEncoderSettings = new System.Text.Encodings.Web.TextEncoderSettings(System.Text.Unicode.UnicodeRanges.All);
UTF8文字コード設定


*Console.WriteLine(isSatisfy);
True


*this.startPos = Input.mousePosition;*} else if(Input.GetMouseButtonUp(0)) {
クリックした座標

*Vector2 endPos = Input.mousePosition;
離した座標

*this.speed = swipeLength / 500.0f;
スワイプの長さを初速度に変換する

*void Start(){}
Use this for initialization

*void Update()*{// ポイント１_1// 1度目のスワイプのみ有効if (this.movedFlg == false){// スワイプの長さを求めるif (Input.GetMouseButtonDown(0)){// クリックした座標this.startPos = Input.mousePosition;}else if (Input.GetMouseButtonUp(0)){// 離した座標Vector2 endPos = Input.mousePosition;// ポイント２// タップの場合は動作させないfloat swipeLength = endPos.x - this.startPos.x;if (swipeLength > 0 || swipeLength < 0){// 初速度設定this.speed = swipeLength / 500.0f;// ポイント１_2this.movedFlg = true;}}}// 移動速度設定transform.Translate(this.speed, 0, 0);this.speed *= 0.98f;}
Update is called once per frame

*if (this.movedFlg == false)
ポイント１_1
1度目のスワイプのみ有効

*this.startPos = Input.mousePosition;
クリックした座標

*Vector2 endPos = Input.mousePosition;
離した座標

*float swipeLength = endPos.x - this.startPos.x;
ポイント２
タップの場合は動作させない

*this.speed = swipeLength / 500.0f;
初速度設定

*this.movedFlg = true;
ポイント１_2

*transform.Translate(this.speed, 0, 0);*this.speed *= 0.98f;
移動速度設定

*if (this.movedFlg == false)
ポイント１_1
1度目のスワイプのみ有効

*this.speed = swipeLength / 500.0f;
初速度設定

*this.movedFlg = true;
ポイント１_2

*float swipeLength = endPos.x - this.startPos.x;
ポイント２
タップの場合は動作させない

*void Start()*{this.car = GameObject.Find("car");this.flag = GameObject.Find("flag");this.distance = GameObject.Find("Distance");// ポイント1_1this.sceneName = SceneManager.GetActiveScene().name;// ポイント2_1this.defaultLength = this.flag.transform.position.x - this.car.transform.position.x - 1.53f;}
Use this for initialization

*this.sceneName = SceneManager.GetActiveScene().name;
ポイント1_1

*this.defaultLength = this.flag.transform.position.x - this.car.transform.position.x - 1.53f;*}
ポイント2_1

*internal void Update()*{this.length = this.flag.transform.position.x - this.car.transform.position.x - 1.53f;if (this.finishFlg == false){// ポイント2_2// 車が停止中のテキスト表示if (this.length.Equals(this.defaultLength)){this.distance.GetComponent<Text>().text = "スワイプでゴールを目指せ！\nゴールを越えたらゲームオーバー";}// ポイント2_3// 逆走したらリトライelse if (this.length > this.defaultLength){// ポイント1_3Invoke("Retry", 1);}// 車が動作中のテキスト表示else if (this.length >= 0){this.distance.GetComponent<Text>().text = "ゴールまで" + this.length.ToString("F2") + "m";// ポイント3_2Invoke("GetScore", 10);}// ポイント2_4// ゴールを超えたらゲームオーバーelse{this.distance.GetComponent<Text>().text = "ゲームオーバー";// ポイント1_3Invoke("Retry", 1);}}}
Update is called once per frame

*if (this.length.Equals(this.defaultLength))
ポイント2_2
車が停止中のテキスト表示

*else if (this.length > this.defaultLength)
ポイント2_3
逆走したらリトライ

*Invoke("Retry", 1);
ポイント1_3

*Invoke("GetScore", 10);
ポイント3_2

*else
ポイント2_4
ゴールを超えたらゲームオーバー

*Invoke("Retry", 1);
ポイント1_3

*void GetScore()*{this.finishFlg = true;if (this.length < 0.5){this.distance.GetComponent<Text>().text = "perfect!!!";}else if (this.length < 1){this.distance.GetComponent<Text>().text = "great!!";}else if (this.length < 1.5){this.distance.GetComponent<Text>().text = "good!";}else{this.distance.GetComponent<Text>().text = "too bad...";}// ポイント1_3Invoke("Retry", 2);}
ポイント3_1

*Invoke("Retry", 2);
ポイント1_3

*public void Retry()*{SceneManager.LoadScene(this.sceneName);}
ポイント1_2

*this.sceneName = SceneManager.GetActiveScene().name;
ポイント1_1

*public void Retry(){SceneManager.LoadScene(this.sceneName);}
ポイント1_2

*Invoke("Retry", 1);
ポイント1_3

*this.defaultLength = this.flag.transform.position.x - this.car.transform.position.x -1.53f;*,,,
ポイント2_1

*if (this.length.Equals(this.defaultLength))
ポイント2_2
車が停止中のテキスト表示

*else if (this.length > this.defaultLength)
ポイント2_3
逆走したらリトライ

*Invoke("Retry", 1);
ポイント1_3

*else
ポイント2_4
ゴールを超えたらゲームオーバー

*Invoke("Retry", 1);
ポイント1_3

*void GetScore()*{this.finishFlg = true;if (this.length < 0.5){this.distance.GetComponent<Text>().text = "perfect!!!";}else if (this.length < 1){this.distance.GetComponent<Text>().text = "great!!";}else if (this.length < 1.5){this.distance.GetComponent<Text>().text = "good!";}else{this.distance.GetComponent<Text>().text = "too bad...";}// ポイント1_3Invoke("Retry", 2);}
ポイント3_1

*Invoke("Retry", 2);
ポイント1_3

*Invoke("GetScore", 10);
ポイント3_2

*Invoke("GetScore", 10);
ポイント3_2


*var successStream =this.OnConnectedToMasterAsObservable().Take(1).IgnoreElements().DoOnCompleted(() =>
OnNext --- （ConnectedToMaster => OnJoinedRoom）

*var failureStream = this.OnDisconnectedAsObservable().Where(cause => cause != DisconnectCause.None && cause != DisconnectCause.DisconnectByClientLogic)
OnError --- （OnDisconnected or OnJoinRoomFailed）


*using (var context = new NorthwindEntities()){SaveChanges() を実行するたびに接続が開閉され、分散トランザクションになるのを防ぐため、あらかじめ開いておく。((IObjectContextAdapter)context).ObjectContext.Connection.Open();
コンテキスト

*((IObjectContextAdapter)context).ObjectContext.Connection.Open();
SaveChanges() を実行するたびに接続が開閉され、分散トランザクションになるのを防ぐため、あらかじめ開いておく。

*var options = new TransactionOptions { IsolationLevel = IsolationLevel.ReadCommitted };
TransactionScope で囲む。

*var product = context.Products.Single(p => p.ProductID == 1);
1つめの SaveChanges()

*var employee = context.Employees.Single(e => e.EmployeeID == 1);
2つめの SaveChanges()

*scope.Complete();
まとめてコミット

*using (var connection = new EntityConnection("name=NorthwindEntities")){SaveChanges() を実行するたびに接続が開閉され、分散トランザクションになるのを防ぐため、あらかじめ開いておく。connection.Open();
共用する接続の作成

*connection.Open();
SaveChanges() を実行するたびに接続が開閉され、分散トランザクションになるのを防ぐため、あらかじめ開いておく。

*var options = new TransactionOptions { IsolationLevel = IsolationLevel.ReadCommitted };
TransactionScope で囲む。

*using (var context = new NorthwindEntities(connection, false)){var product = context.Products.Single(p => p.ProductID == 1);
1つめのコンテキスト（接続を指定して生成）

*using (var context = new NorthwindEntities(connection, false)){var employee = context.Employees.Single(e => e.EmployeeID == 1);
2つめのコンテキスト（接続を指定して生成）

*scope.Complete();
まとめてコミット

*public partial class NorthwindEntities : DbContext*{/// <summary>/// コンストラクタ。/// </summary>/// <param name="existingConnection">コンテキストで使用する接続。</param>/// <param name="contextOwnsConnection">false を指定すると、コンテキストが Dispose されたときに接続を Dispose しない。</param>public NorthwindEntities(DbConnection existingConnection, bool contextOwnsConnection): base(existingConnection, contextOwnsConnection){}}
コンテキストの部分クラス

*using (var transaction = connection.BeginTransaction()){try{var product = context.Products.Single(p => p.ProductID == 1);
トランザクション開始

*transaction.Commit();
コミット

*transaction.Rollback();
ロールバック


*collection.Where(/*条件*/).ForEach(/*collectionの各要素に行う処理*/);
LINQに書き換える


*static void CreateEditorFolder()
FolderCreate("フォルダ名");　で新しいフォルダ追加可能


*DateTimeOffset expiration = s_JwtHelper.DateTimeProvider.GetNow().AddMinutes(5);
トークンの有効期限を5分後に設定します。

*return new UserInfo*{Role = UserRole.User,Permissions = UserPermissions.Get | UserPermissions.Modify};
IDとパスワードが妥当であり、そのユーザーの情報を取得できたものとします。

*const string secretKey = "GQDstcKsx0NHjPOuXOYg5MbeJ1XT0uFiwDVvVBrk";
秘密鍵。当然ですが、実際にはストレージなどから読み込みます。

*const string secretKey = "GQDstcKsx0NHjPOuXOYg5MbeJ1XT0uFiwDVvVBrk";
秘密鍵。当然ですが、実際にはストレージなどから読み込みます。

*internal const string AuthorizationToken = "authorization";
リクエストヘッダーにトークンを格納するときのキー

*internal const string AuthenticateResult = "www-authenticate";
レスポンスヘッダーにトークン認証結果を格納するときのキー

*private bool VaridateToken(ServerCallContext context, out UserInfo userInfo, out RpcException exception)*{if (!TryGetToken(context, out string token) || string.IsNullOrEmpty(token)){userInfo = null;exception = new RpcException(new Status(StatusCode.Unauthenticated, "Token is not set."));return false;}try{string[] values = token.Split(".");var json = s_JwtHelper.Decoder.Decode(token, secretKey, verify: true);var payload = s_JwtHelper.JsonSerializer.Deserialize<Dictionary<string, object>>(json);userInfo = s_JwtHelper.JsonSerializer.Deserialize<UserInfo>((string)payload["user"]);exception = null;return true;}catch (JWT.TokenExpiredException){userInfo = null;Metadata trailers = new Metadata();trailers.Add(AuthHeaderKeys.AuthenticateResult, "expired");exception = new RpcException(new Status(StatusCode.Unauthenticated, "Token has expired."), trailers);return false;}catch (JWT.SignatureVerificationException){userInfo = null;Metadata trailers = new Metadata();trailers.Add(AuthHeaderKeys.AuthenticateResult, "invalid");exception = new RpcException(new Status(StatusCode.Unauthenticated, "Token has invalid signature."), trailers);return false;}catch (Exception ex){userInfo = null;Metadata trailers = new Metadata();trailers.Add(AuthHeaderKeys.AuthenticateResult, "invalid");exception = new RpcException(new Status(StatusCode.Unauthenticated, "Could not get user information."), trailers);return false;}}
コンテキストに格納されている情報からトークンの検証を行います。

*return new Response();
処理を行ってレスポンスを返します。


*public int hp = xxx;
(数字を設定する)


*_connectString = ConfigurationManager.ConnectionStrings[connectionString].ConnectionString;
接続文字列を生成

*sqlCom.Connection = this._con;
クエリー送信先、トランザクションの指定


*[Option('a', "aaa", Required = false, HelpText = "Aの説明です。")]public string A { get; set; }
-a と -aaa の二つ指定可能

*[Option('b', "bbb", Required = false, HelpText = "Bの説明です。")]public bool B { get; set; }
string 以外でも受け取れる（この場合はオプションがあるかどうか）

*[Option('c', "ccc", Separator = ',', HelpText = "Cの説明です。")]public IEnumerable<string> C { get; set; }
Sepalatorで指定下文字を区切り文字として、複数の値を渡せる

*[Option('d', "ddd", HelpText = "Cの説明です。")]public HogeInfo D { get; set; }
enumもいける（Hoge, Fuga などと指定する）

*[Value(1, MetaName = "Others")]public IEnumerable<string> Others { get; set; }
上記指定以外のオプションや文字列が入る

*var parseResult = Parser.Default.ParseArguments<Options>(args);
ジェネリクスでオプションクラスを指定し、パースする

*case ParserResultType.Parsed:
パース成功

*var parsed = parseResult as Parsed<Options>;
パースの成否でパース結果のオブジェクトの方が変わる

*opt = parsed.Value;
成功時はキャストしたオブジェクトからパース結果が取得可能

*string strC = string.Concat("{ ", string.Join(", ", opt.C.Select(e => $"\"{e}\"")), " }");
表示用に整形

*case ParserResultType.NotParsed:
パース失敗

*var notParsed = parseResult as NotParsed<Options>;
パースの成否でパース結果のオブジェクトの方が変わる


*writer.Flush();
StreamWriter.Flush を呼ばないとバッファーからメモリに書き込まれないので注意

*readonly TodoService service = new TodoService();
サンプルなので DI せず直にインスタンス化


*#else
省略


*class Program : ConsoleAppBase
inherit ConsoleAppBase

*public void Run(string name, int repeat = 3){for (int i = 0; i < repeat; i++)
allows void/Task return type, parameter is automatically binded from string[] args.


*Debug.Log(ret);
インライン展開されて消えることがないようにちゃんと戻り値を使う


*new MathTest(100.0).run();
メモリキャッシュとか対策にちょっと回す


*return false;
強制で切断した場合に Socket が null になるため、例外を無視


*void Update()*{if( step <= 0 ){return;}Mult();Sin();Sqrt();Atan();Exp();Pow();Pow2();}
Update is called once per frame


*public struct MyQuaternion*{//q = u + xi + yj + zkpublic float u;public float x;public float y;public float z;//コンストラクタpublic MyQuaternion(float u, float x, float y, float z)=> (this.u, this.x, this.y, this.z) = (u, x, y, z);}
くぉーたにおん！

*public MyQuaternion(float u, float x, float y, float z)
コンストラクタ

*public MyQuaternion(float x, float y, float z)*{var rx = x * Mathf.Deg2Rad;var ry = y * Mathf.Deg2Rad;var rz = z * Mathf.Deg2Rad;var cx = Mathf.Cos(rx / 2);var sx = Mathf.Sin(rx / 2);var cy = Mathf.Cos(ry / 2);var sy = Mathf.Sin(ry / 2);var cz = Mathf.Cos(rz / 2);var sz = Mathf.Sin(rz / 2);this.u = cx * cy * cz + sx * sy * sz;this.x = sx * cy * cz - cx * sy * sz;this.y = cx * sy * cz + sx * cy * sz;this.z = cx * cy * sz - sx * sy * cz;}
Quaternion.Euler(x,y,z)のやつ

*public Vector3 Project(float f)
光源(f,0,0,0)からスクリーンu=0への透視投影

*public Vector3 ProjectParallel() => new Vector3(x, y, z);
平行投影はu座標を消すだけ

*public MyQuaternion Rotate(MyQuaternion QL, MyQuaternion QR) => QL * this * QR;
回転（原点中心）

*public MyQuaternion Rotate(float x1, float y1, float z1, float x2, float y2, float z2)
６つのオイラー角からデュアルクォータニオンを作って適用

*超平面u=0との交線を求める。すべての頂点が同じ側にある場合は交わらない。if (A.u < 0 && B.u < 0 && C.u < 0 || A.u > 0 && B.u > 0 && C.u > 0)
超立方体の面を構成する各三角形ABCについて、

*if (A.u < 0 && B.u < 0 && C.u < 0 || A.u > 0 && B.u > 0 && C.u > 0)
超平面u=0との交線を求める。
すべての頂点が同じ側にある場合は交わらない。

*var t = -C.u / (A.u - C.u);
AC上、u=0の点Pを求める。

*var s = -C.u / (B.u - C.u);
BC上、u=0の点Qを求める。

*return new[] { P, Q };
PQは求めたい交線である。


*return this.Service.GetText();
プロパティ経由でDIコンテナから依存オブジェクトを取得して使用する。

*var serviceMock = CreateMock<Service>();
モック設定

*var client = new Client();
テスト対象オブジェクトを生成

*string result = client.Act();
テスト対象メソッドを実行

*Assert.AreEqual("UnitTest", result);
戻り値の検証
※モックの検証は基底クラスで自動的に行われる。


*using System.IO;
冒頭に左記を追加する必要がある

*GetExecutable(args).Exec();
実行クラスを取得し、実行

*return new ReadBoard();
引数が指定されない場合、投稿内容を表示

*return new WriteBoard(args[0]);
引数が1個指定された場合、引数の内容を投稿する

*var contentList = ReadFile();
投稿内容リスト

*yield break;
ファイルが未作成の場合：NOP

*string line;
投稿リストを1行ずつ処理

*yield return Contents.Parse(line);
Contents インスタンスに変換して返す

*writer.WriteLine(new Contents(message));
投稿内容インスタンスを作成し、ファイル末尾に出力


*IPEndPoint remoteEP = null;
任意の送信元からのデータを受信

*private void sendCmd(string cmd)*{txtCmd.Text = cmd;byte[] data = Encoding.ASCII.GetBytes(cmd);this.udpForCmd.Send(data, data.Length, "192.168.10.1", 8889);}
コマンド送信

*recognizer.SpeechRecognized +=new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);
Add a handler for the speech recognized event.

*void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)*{Debug.WriteLine("SpeechRecognized...");if (e.Result.Semantics != null){if (e.Result.Semantics.ContainsKey("singleCommands")){Debug.WriteLine("..." + e.Result.Semantics["singleCommands"].Value);sendCmd((string)e.Result.Semantics["singleCommands"].Value);}else if (e.Result.Semantics.ContainsKey("moveCommands") &&e.Result.Semantics.ContainsKey("moveCm")){Debug.WriteLine("..." + e.Result.Semantics["moveCommands"].Value + " " + e.Result.Semantics["moveCm"].Value);sendCmd((string)e.Result.Semantics["moveCommands"].Value + " " + ((int)e.Result.Semantics["moveCm"].Value).ToString());}}}
Handle the SpeechRecognized event.


*var appSettings = new AppSettings();
バインディングしたい場合は、そのクラスを作りオブジェクト化してバインディングする


*this.expenseItems.DataContext = ExpenseDao.selectByUser(data as User);
追加


*private Subject<object>[] _subjectable;
Subjectまとめとこうとするとなんかエラー出る.
SubjectってもしかしてListとかArrayとかに入れられないやつ？
CompositeDisposableみたいなのを自作する必要がある？
他のObservableTriggerBase継承クラスはSubjectひとつひとつにOnCompletedやDisposeしている…….

*Subject<Unit> ConnectMaster = new Subject<Unit>();
OnConnectedToMaster時にOnCompletedされる想定


*​
ループを3回おこない、ループごとにiに1から3が代入される


*private T Compare<T>(T x, T y) where T : IComparable
ジェネリクスを使って比較メソッドを実装
比較可能な型を指定した時にのみ このメソッドを呼び出せる

*private delegate void SomeDelegate();
SomeDelegate という名前のデリゲート型を定義

*SomeDelegate hoge = WriteDatetimeNow;
SomeDelegate型の変数にメソッドを代入
型を明示的に宣言する必要がある

*hoge.Invoke();
このように代入したメソッドを呼び出す

*public delegate void SomeDelegate();
SomeDelegate という名前のデリゲート型を定義

*public event SomeDelegate HogeEvent;
何らかのイベントを定義

*SomeDelegate someDelegate = WriteDatetimeNow;
SomeDelegate型の変数にメソッドを代入
型を明示的に宣言する必要がある

*HogeEvent += someDelegate;
イベントにメソッドを割り付ける

*});
何かしらの処理

*Task.Run(() => WriteDateTimeNow());
もしくはこっち

*{Console.WriteLine(DateTime.Now);});
{}の中身が名前のないメソッド

*() =>*{//何かしらの処理});
この()は何なのか

*});
何かしらの処理

*Action Hoge = () => Console.WriteLine(DateTime.Now);
パターン1
引数は無し
戻り値はvoid

*Task.Run(() => Console.WriteLine(DateTime.Now));
もしくはこう書く

*Action<int> Fuga = x => Console.WriteLine(x);
パターン2
引数はint型を1つ
戻り値はvoid

*Task.Run(() =>*{var t = 1;Console.WriteLine(t);});
もしくはこう書く

*Func<int, string> Hoge = (int x) => x.ToString();
パターン1
引数はint型を1つ
戻り値はstring型

*hoge = Task.Run(() =>*{var x = 1;return x.ToString();});
もしくはこう書く

*Func<int, int, string> Fuga = (x, y) => (x + y).ToString();
パターン2
引数はint型を2つ
戻り値はstring型

*fuga = Task.Run(() =>*{var t = 1;var v = 2;return (t + v).ToString();});
もしくはこう書く

*});
何かしらの処理

*Task.Run(() =>*{for (var i = 1; i <= 10000; ++i){textBox1.Text = i.ToString();}});
非同期処理にしてやれば全てうまくいくはず

*Invoke(new Action(() =>*{textBox1.Text = i.ToString();}));
Invokeメソッド内ではUIスレッドに戻してくれる

*Task.Run(async () =>
巨大なファイルを読み込むつもりならここはあえてawaitキーワードを外すべき
UIスレッドで処理をさせると固まってしまうのでスレッドプールに処理を投げる
Task.Runメソッド内でawait を使用しているので、asyncキーワードを付ける

*using (var file = new FileStream(csvFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)){result = new byte[file.Length];
ファイルオープン

*await file.ReadAsync(result, 0, (int)file.Length);
バイナリデータを非同期的に読み込む
全部を読み込み終わるまで待っとくで～

*Invoke(new Action(() =>*{textBox1.Text = builder.ToString();}));
UIを更新できるのはUIスレッドだけなので Invoke でUIスレッドに一旦処理を戻してやる

*await Task.Delay(1000);
タイマーイベントの代わり
1秒待つ


*if (IsPlaying() == false && audioSource.clip != BGM_Data.BGMList[keyname])
シーン再読み込みのために消さない

*/*public SEPlayer(string keyname)*{audioSource = audioObject.AddComponent<AudioSource>();audioSource.clip = SE_Data.SEList[keyname];audioSource.volume = SE_Data.SEVolumeList[keyname] * PlayerPrefs.GetFloat("SEVolume", 1);}*/
AudioSource audioSource=null;


*var filepath = Path.Combine(@"C:\", filename);
Unity Editor上

*var filepath = Path.Combine(UnityEngine.Application.persistentDataPath, filename));
それ以外


*ws.IndentChars = "  ";
<- インデントの空白数ではなくて、1つ分のインデントとして使う文字列を直接指定します。


*).SetValidateNotifyError(x => String.IsNullOrEmpty(x) ? "何か入力してください。" : null)
バリデーション.


*1000
最大高


*}
なんか


*using GalaSoft.MvvmLight.Ioc;
using GalaSoft.MvvmLight;  コメントアウト
using CommonServiceLocator;  追加


*NLog.LogEventInfo info = new NLog.LogEventInfo(NLog.LogLevel.Info, logger.Name, message);
ログ情報を生成します。

*logger.Log(typeof(NLoggerExtensions), info);
ロガーの型に NLoggerExtensions を指定します。

*NLog.LogEventInfo info = new NLog.LogEventInfo(NLog.LogLevel.Info, logger.Name, message);
ログ情報を生成します。

*logger.Log(typeof(NLoggerExtensions), info);
ロガーの型に NLoggerExtensions を指定します。

*info.SetCallerInfo(callerClassName, callerMemberName, callerFilePath, callerLineNumber);
呼び出し元情報を設定します。

*info.SetCallerInfo(callerClassName, callerMemberName, callerFilePath, callerLineNumber);
呼び出し元情報を設定します。


*int[] current = { 9, 9, 11, 7, 3, 2, 1, 2 };
現在の数: 9人 -> 2人 (8種類で合計44人)

*int iteration = 0;
繰り返し数を引数から取得(なければ0)

*int[] current = { 9, 9, 11, 7, 3, 2, 1, 2 };
現在の数: 9人 -> 2人 (8種類で合計44人)

*int[] r = new int[current.Sum()];
44人分の空配列

*int startRemain = 9;
9人 -> 2人 で8回ループして44人の現在保持数を設定

*int tmp = rand.Next(103);
対象内の誰かだったら☆数を++

*int remain = 0;
結果発表♪


*await Task.Delay(10);
10ms待機する


*array[h*wLength + w];
場合によっては[(h-1)*wLength + (w-1)]


*}
なんかいろいろな処理

*}
なんかいろいろな処理

*void Start()*{//カメラ自動生成camera_G = new GameObject("OnlyUIRenderingCamera");faceCamera = camera_G.AddComponent<Camera>();faceCamera.clearFlags = CameraClearFlags.Depth;faceCamera.cullingMask = (1 << LayerMask.NameToLayer("UI"));//キャンバス生成＆設定GameObject canvas_G = new GameObject("FaceCanvas");faceCanvas = canvas_G.AddComponent<Canvas>();canvas_G.AddComponent<CanvasRenderer>();//キャンバスのポジションを調整Vector3 canvasPosition = canvas_G.transform.position;canvasPosition.x = 0;canvasPosition.y = 0;canvasPosition.z = 0.1f;canvas_G.transform.localPosition = canvasPosition;//レンダリングをfaceCameraにfaceCanvas.renderMode = RenderMode.ScreenSpaceCamera;faceCanvas.worldCamera = faceCamera;//パネル生成＆設定GameObject panel_G = new GameObject("FacePanel");facePanel = panel_G.AddComponent<Image>();Color tmpColor = facePanel.color;tmpColor.a = 0f;facePanel.color = tmpColor;//パネルをキャンバスの子に設定panel_G.transform.parent = canvas_G.transform;//パネルのポジションを正面に調整Vector3 panelPosition = panel_G.transform.localPosition;panelPosition.x = 0;panelPosition.y = 0;panelPosition.z = 0;panel_G.transform.localPosition = panelPosition;//キャンバスをカメラの子に設定canvas_G.transform.parent = faceCamera.transform;//Layerを変更canvas_G.layer = LayerMask.NameToLayer("UI");panel_G.layer = LayerMask.NameToLayer("UI");}
Start is called before the first frame update

*camera_G = new GameObject("OnlyUIRenderingCamera");
カメラ自動生成

*GameObject canvas_G = new GameObject("FaceCanvas");
キャンバス生成＆設定

*Vector3 canvasPosition = canvas_G.transform.position;*canvasPosition.x = 0;
キャンバスのポジションを調整

*faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
レンダリングをfaceCameraに

*GameObject panel_G = new GameObject("FacePanel");
パネル生成＆設定

*panel_G.transform.parent = canvas_G.transform;*//パネルのポジションを正面に調整
パネルをキャンバスの子に設定

*Vector3 panelPosition = panel_G.transform.localPosition;*panelPosition.x = 0;
パネルのポジションを正面に調整

*canvas_G.transform.parent = faceCamera.transform;*//Layerを変更
キャンバスをカメラの子に設定

*canvas_G.layer = LayerMask.NameToLayer("UI");
Layerを変更

*Time.fixedDeltaTime = FIXED_UPDATE_DELTATIME;
Fixed Timestepを固定

*startTime = Time.time;
スタートの時間記録

*startTime = Time.time;
スタートの時間記録

*print(Time.time - startTime);
フェード中の時間、Alphaを確認

*print(Time.time - startTime);
フェード中の時間、Alphaを確認

*Time.fixedDeltaTime = FIXED_UPDATE_DELTATIME;
Fixed Timestepを固定


*updateScore("false");
発火


*await next(message, ct);
ハンドラ本体の処理を待機

*logger.LogDebug("メッセージを送信しました");
後処理

*options.AddGlobalMessageHandlerFilter(typeof(AsyncLoggingFilter<string>), -10000 /*優先順位*/);
任意のMessageHandlerの実行前後に、AsyncL


*void Start()*{//カメラ自動生成camera_G = new GameObject("OnlyUIRenderingCamera");faceCamera = camera_G.AddComponent<Camera>();faceCamera.clearFlags = CameraClearFlags.Depth;faceCamera.cullingMask = (1 << LayerMask.NameToLayer("UI"));//キャンバス生成＆設定GameObject canvas_G = new GameObject("FaceCanvas");faceCanvas = canvas_G.AddComponent<Canvas>();canvas_G.AddComponent<CanvasRenderer>();//キャンバスのポジションを調整Vector3 canvasPosition = canvas_G.transform.position;canvasPosition.x = 0;canvasPosition.y = 0;canvasPosition.z = 0.1f;canvas_G.transform.localPosition = canvasPosition;//レンダリングをfaceCameraにfaceCanvas.renderMode = RenderMode.ScreenSpaceCamera;faceCanvas.worldCamera = faceCamera;//パネル生成＆設定GameObject panel_G = new GameObject("FacePanel");facePanel = panel_G.AddComponent<Image>();Color tmpColor = facePanel.color;tmpColor.a = 0f;facePanel.color = tmpColor;//パネルをキャンバスの子に設定panel_G.transform.parent = canvas_G.transform;//パネルのポジションを正面に調整Vector3 panelPosition = panel_G.transform.localPosition;panelPosition.x = 0;panelPosition.y = 0;panelPosition.z = 0;panel_G.transform.localPosition = panelPosition;//キャンバスをカメラの子に設定canvas_G.transform.parent = faceCamera.transform;//Layerを変更canvas_G.layer = LayerMask.NameToLayer("UI");panel_G.layer = LayerMask.NameToLayer("UI");}
Start is called before the first frame update

*camera_G = new GameObject("OnlyUIRenderingCamera");
カメラ自動生成

*GameObject canvas_G = new GameObject("FaceCanvas");
キャンバス生成＆設定

*Vector3 canvasPosition = canvas_G.transform.position;*canvasPosition.x = 0;
キャンバスのポジションを調整

*faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
レンダリングをfaceCameraに

*GameObject panel_G = new GameObject("FacePanel");
パネル生成＆設定

*panel_G.transform.parent = canvas_G.transform;*//パネルのポジションを正面に調整
パネルをキャンバスの子に設定

*Vector3 panelPosition = panel_G.transform.localPosition;*panelPosition.x = 0;
パネルのポジションを正面に調整

*canvas_G.transform.parent = faceCamera.transform;*//Layerを変更
キャンバスをカメラの子に設定

*canvas_G.layer = LayerMask.NameToLayer("UI");
Layerを変更

*Time.fixedDeltaTime = FIXED_UPDATE_DELTATIME;
Fixed Timestepを固定

*startTime = Time.time;
スタートの時間記録

*startTime = Time.time;
スタートの時間記録

*print(Time.time - startTime);
フェード中の時間、Alphaを確認

*print(Time.time - startTime);
フェード中の時間、Alphaを確認


*SetLocalGravity ();
重力をAddForceでかけるメソッドを呼ぶ。FixedUpdateが好ましい。


*IPEndPoint remoteEP = null;
任意の送信元からのデータを受信

*_TermH264Decoder();
後片付けの方法はあとで考える。（呼ばれない）

*private void sendCmd(string cmd)*{byte[] data = Encoding.ASCII.GetBytes(cmd);this.udpForCmd.Send(data, data.Length, "192.168.10.1", 8889);}
コマンド送信

*private void btnStart_Click(object sender, EventArgs e)*{SetupTello();this.txtRet.Text = "";this.btnCmd.Enabled = false;sendCmd("command");}
開始ボタン

*private void btnCmd_Click(object sender, EventArgs e)*{this.txtRet.Text = "";this.btnCmd.Enabled = false;sendCmd(this.txtCmd.Text);}
コマンド送信ボタン押下


*time = 0;
timeを0にする。


*[assembly: CLSCompliant(true)]
↓この角括弧が何やってるか分けわかんなければ消してくれだぜ。

*using Grayscale.ResourcePracticeWithConsole.Properties;
↓リソースファイルを使おうとしている。
リソースファイルの作り方は Qiita で別の人が書いてるだろ、勝手に調べろだぜ。

*Resources.Culture = new CultureInfo("en-US");
使うリソースを 英語（米国）を使う。

*Thread.CurrentThread.CurrentCulture = Resources.Culture;
↓C#デフォルトのエラーメッセージや、画面に効いてくる。

*Trace.WriteLine(Resources.HelloWorld);
↓英語（米国）テーブルの HelloWorld キーに対応した値が表示される。

*Resources.Culture = new CultureInfo("ja-JP");
使うリソースを 日本 に変える。

*Trace.WriteLine(Resources.HelloWorld);
↓日本テーブルの HelloWorld キーに対応した値が表示される。

*Thread.Sleep(15000);
15秒待つ。

*var dateValue = new DateTime(2019, 2, 16, 13, 57, 0);
日付。

*(CultureInfo CultureInfo, string TimeZone)[] cultures ={(new CultureInfo("ja-JP"), "Tokyo Standard Time"),(new CultureInfo("en-US"), "GMT Standard Time"),(new CultureInfo("fr-FR"), "Romance Standard Time"),(new CultureInfo("de-DE"), "Romance Standard Time"),};
System.ValueTuple


*}
30％の確率で起こるイベント


*else Console.Error.Write(map[x, y]);
-1でなければプレイヤーID(0以上)を出力。

*class Position
キャラクターの座標を登録・記憶しておくための入れ物。
Main 関数が受け取る標準入力の情報を格納するための構造体のようなもの。
Player インスタンスの各メソッドの引数は標準入力とのやり取りを意識せず、この構造体を期待できる。

*public override string ToString()*{//return "{X0:" + X0 + ", Y0:" + Y0 + ", X1:" + X1 + ", Y1:" + Y1 + "}";return String.Format("{{X0:{0}, Y0:{1}, X1:{2}, Y1:{3}}}", X0, Y0, X1, Y1);}
デバッグなどで出力される際のフォーマットを制御する。

*return String.Format("{{X0:{0}, Y0:{1}, X1:{2}, Y1:{3}}}", X0, Y0, X1, Y1);
return "{X0:" + X0 + ", Y0:" + Y0 + ", X1:" + X1 + ", Y1:" + Y1 + "}";


*private void Button01_Click()*{var w = new Window01();w.Show();}
Window○○ は、自前のWindowクラス。

*,,,
以下略

*private void OpenWindow<T>() Where T : Window, new()
Window○○ は、自前のWindowクラス。


*success();
成功のメソッド


*string[] strings = new string[] { "a", "b" };
参照型 B を参照型 A に代入できるなら、配列 B[] も A[] に代入できる。

*Assert.IsTrue(Object.ReferenceEquals(objects, strings));
代入後の配列インスタンスは同一参照

*try
ただし、要素に別の派生型の値を設定しようとすると実行時例外が発生する。
配列には値を返すだけでなく受け取る役目もあるのに、
丸ごと（本来適用すべきでない受け取り操作を含めて）共変を許してしまったことの弊害である。

*Console.WriteLine(ex.ToString());
「配列と互換性のない型の要素にアクセスしようとしました」

*/* コンパイルエラー「型 'int[]' を型 'object[]' に暗黙的に変換できません。」*objects = new int[] { 0, 1 };
配列の共変性は、不変である値型には適用されない。

*BaseGetter returnsDerived = this.GetDerived;
共変性のサポートがこの代入を可能にする。

*private void EventArgsHandler(object sender, EventArgs e)*{// :}
EventArgs 型の引数を受け取るイベントハンドラ

*this.KeyDown += this.EventArgsHandler;
KeyDown が期待するイベント引数型は KeyEventArgs だが、
反変性のサポートによって EventArgs 型引数のイベントハンドラも登録できる。

*IEnumerable<Derived> derivedEnumerable = new List<Derived>();
これは .NET 3.5 でもできた。

*IEnumerable<Base> baseEnumerable = derivedEnumerable;
IEnumerable<out T> のように共変であることを表す out キーワードで修飾されるようになった。
列挙だけなら Derived 型オブジェクトを Base 型として扱っても問題ない。

*/* コンパイルエラー「変換できません」
設定もできる場合、共変は許されない。
（List<Base> は Derived 以外の派生型オブジェクトを受け取ることもあるから）

*Action<Derived> derivedAction = baseAction;
Action<in T> のように、反変であることを表す in キーワードで修飾されるようになった。
基底型の引数に派生型のオブジェクトが渡されても問題ない。

*derivedAction.Invoke(new Derived());
引数を渡す側は、派生型を渡してそれが基底型として扱われても不都合はないはず。


*[Test]
バカみたいに失敗するテスト

*[Test]
バカみたいに成功するテスト


*FilePath = AppDomain.CurrentDomain.BaseDirectory.TrimEnd('\\');
EXEを実行したカレントディレクトリ (ショートカット等でカレントディレクトリが変わるのでこの方式で)


*HTuple hWin1;
HWindowの名前を付ける

*HObject img;
画像を読み込む

*Op.DispImage(img, hWin1);
HWindowに画像を表示する


*public class RER : SingletonMonoBehaviour<RER>*{#region lifecyclepublic void OnEnable(){PhotonNetwork.NetworkingClient.EventReceived += OnEvent;}public void OnDisable(){PhotonNetwork.NetworkingClient.EventReceived -= OnEvent;}#endregion// ①// eventCode. 0~199。0は特殊な扱いのため1から始めるpublic enum RaiseEventType : byte{SampleEvent = 1,}// ②public Action<string> OnSampleEvent;// ③public void OnEvent(EventData photonEvent){var type = (RaiseEventType) Enum.ToObject(typeof(RaiseEventType), photonEvent.Code);Debug.Log("RaiseEvent Received. Type = " + type);switch (type){case RaiseEventType.SampleEvent:OnSampleEvent?.Invoke(photonEvent.CustomData as string);break;default:return;}}}
RaiseEventReceiver

*public enum RaiseEventType : byte*{SampleEvent = 1,}
eventCode. 0~199。0は特殊な扱いのため1から始める

*public void OnEvent(EventData photonEvent)*{var type = (RaiseEventType) Enum.ToObject(typeof(RaiseEventType), photonEvent.Code);Debug.Log("RaiseEvent Received. Type = " + type);switch (type){case RaiseEventType.SampleEvent:OnSampleEvent?.Invoke(photonEvent.CustomData as string);break;default:return;}}
③

*public static class RES*{// ④public static void SendSampleEvent(string message){var raiseEventOptions = new RaiseEventOptions{Receivers = ReceiverGroup.All,CachingOption = EventCaching.AddToRoomCache,};PhotonNetwork.RaiseEvent((byte) RER.RaiseEventType.SampleEvent, message, raiseEventOptions, SendOptions.SendReliable);}}
RaiseEventSender

*public static void SendSampleEvent(string message)*{var raiseEventOptions = new RaiseEventOptions{Receivers = ReceiverGroup.All,CachingOption = EventCaching.AddToRoomCache,};PhotonNetwork.RaiseEvent((byte) RER.RaiseEventType.SampleEvent, message, raiseEventOptions, SendOptions.SendReliable);}
④

*public class RER : SingletonMonoBehaviour<RER>*{#region lifecyclepublic void OnEnable(){PhotonNetwork.NetworkingClient.EventReceived += OnEvent;}public void OnDisable(){PhotonNetwork.NetworkingClient.EventReceived -= OnEvent;}#endregion// ①// eventCode. 0~199。0は特殊な扱いのため1から始めるpublic enum RaiseEventType : byte{SampleEvent = 1,ChangeColor,}// ②public Action<string> OnSampleEvent;public Action<PunSampleManager.CubeColor> OnChangeColor;// ③public void OnEvent(EventData photonEvent){var type = (RaiseEventType) Enum.ToObject(typeof(RaiseEventType), photonEvent.Code);Debug.Log("RaiseEvent Received. Type = " + type);switch (type){case RaiseEventType.ChangeColor:var color = (PunSampleManager.CubeColor) Enum.ToObject(typeof(PunSampleManager.CubeColor), photonEvent.CustomData);OnChangeColor?.Invoke(color);break;case RaiseEventType.SampleEvent:default:return;}}}
RaiseEventReceiver

*public enum RaiseEventType : byte*{SampleEvent = 1,ChangeColor,}
eventCode. 0~199。0は特殊な扱いのため1から始める

*public void OnEvent(EventData photonEvent)*{var type = (RaiseEventType) Enum.ToObject(typeof(RaiseEventType), photonEvent.Code);Debug.Log("RaiseEvent Received. Type = " + type);switch (type){case RaiseEventType.ChangeColor:var color = (PunSampleManager.CubeColor) Enum.ToObject(typeof(PunSampleManager.CubeColor), photonEvent.CustomData);OnChangeColor?.Invoke(color);break;case RaiseEventType.SampleEvent:default:return;}}
③

*public static class RES*{// ④public static void SendSampleEvent(string message){var raiseEventOptions = new RaiseEventOptions{Receivers = ReceiverGroup.All,CachingOption = EventCaching.AddToRoomCache,};PhotonNetwork.RaiseEvent((byte) RER.RaiseEventType.SampleEvent, message, raiseEventOptions, SendOptions.SendReliable);}public static void ChangeColor(PunSampleManager.CubeColor cubeColor){var content = (int) cubeColor;var raiseEventOptions = new RaiseEventOptions{Receivers = ReceiverGroup.All,CachingOption = EventCaching.AddToRoomCache,};PhotonNetwork.RaiseEvent((byte) RER.RaiseEventType.ChangeColor, content, raiseEventOptions, SendOptions.SendReliable);}}
RaiseEventSender

*public static void SendSampleEvent(string message)*{var raiseEventOptions = new RaiseEventOptions{Receivers = ReceiverGroup.All,CachingOption = EventCaching.AddToRoomCache,};PhotonNetwork.RaiseEvent((byte) RER.RaiseEventType.SampleEvent, message, raiseEventOptions, SendOptions.SendReliable);}
④

*void Start()*{RER.Instance.OnChangeColor += OnChangeColor;}
Start is called before the first frame update

*void Start()*{RER.Instance.OnSpinCube += () => { StartCoroutine(SpinCube()); };}
Start is called before the first frame update


*this[index] = new T();
初期値

*public virtual IEnumerable<int> GetAllIndexes()*{for (int y = 1; y <= this.YSize; y++){for (int x = 1; x <= this.XSize; x++){yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する

*public virtual IEnumerable<int> EnumerateIndexes(int x, int y, int direction)*{for (int index = ToIndex(x, y); IsOnBoard(index); index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Horizontal(int x, int y)
(x,y)から右(水平)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Virtical(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantR(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantL(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む


*Application.ThreadException += newThreadExceptionEventHandler(ApplicationThreadException);
ThreadExceptionイベント・ハンドラの登録

*}
ほかの処理

*public static void ApplicationThreadException(object sender, ThreadExceptionEventArgs e)*{// 第二引数にエラーメッセージShowErrorMessage(e.Exception, "ApplicationThreadException");}
未処理例外をキャッチするイベント・ハンドラ

*ShowErrorMessage(e.Exception, "ApplicationThreadException");
第二引数にエラーメッセージ

*public static void ShowErrorMessage(Exception ex, string extraMessage)*{// ダイアログを自動的に閉じるようにしたいので以下の処理を追記var w = new Form() { Size = new Size(0, 0) };// ここでは約5秒後に閉じるように設定Task.Delay(TimeSpan.FromSeconds(5)).ContinueWith((t) => w.Close(), TaskScheduler.FromCurrentSynchronizationContext());// ダイアログに表示させるメッセージを記述MessageBox.Show(w, "エラーが発生しました。約5秒後にアプリケーションの再起動を行います。\n\nしばらくお待ちください。\n\n\n", "Error : " + extraMessage);// エラーダイアログが閉じた後に実行する処理（アプリの終了処理を書いたり）Application.Exit();}
ユーザー・フレンドリなダイアログを表示するメソッド

*var w = new Form() { Size = new Size(0, 0) };
ダイアログを自動的に閉じるようにしたいので以下の処理を追記

*Task.Delay(TimeSpan.FromSeconds(5))
ここでは約5秒後に閉じるように設定

*MessageBox.Show(w, "エラーが発生しました。約5秒後にアプリケーションの再起動を行います。\n\nしばらくお待ちください。\n\n\n", "Error : " + extraMessage);
ダイアログに表示させるメッセージを記述

*Application.Exit();
エラーダイアログが閉じた後に実行する処理（アプリの終了処理を書いたり）


*GameObject canvas_G = new GameObject("FaceCanvas");
～省略～
キャンバス生成＆設定

*faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
レンダリングをメインカメラに

*GameObject panel_G = new GameObject("FacePanel");
パネル生成＆設定

*panel_G.transform.parent = canvas_G.transform;*//パネルのポジションを正面に調整
パネルをキャンバスの子に設定

*Vector3 panelPosition = panel_G.transform.localPosition;*panelPosition.x = 0;
パネルのポジションを正面に調整

*void Start()*{//キャンバス生成＆設定GameObject canvas_G = new GameObject("FaceCanvas");faceCanvas = canvas_G.AddComponent<Canvas>();canvas_G.AddComponent<CanvasScaler>();canvas_G.AddComponent<GraphicRaycaster>();//レンダリングをメインカメラにfaceCanvas.renderMode = RenderMode.ScreenSpaceCamera;faceCanvas.worldCamera = FindObjectOfType<Camera>();//パネル生成＆設定GameObject panel_G = new GameObject("FacePanel");facePanel = panel_G.AddComponent<Image>();Color tmpColor = facePanel.color;tmpColor.a = 0f;facePanel.color = tmpColor;//パネルをキャンバスの子に設定panel_G.transform.parent = canvas_G.transform;//パネルのポジションを正面に調整Vector3 panelPosition = panel_G.transform.localPosition;panelPosition.x = 0;panelPosition.y = 0;panel_G.transform.localPosition = panelPosition;}
Start is called before the first frame update

*GameObject canvas_G = new GameObject("FaceCanvas");
キャンバス生成＆設定

*faceCanvas.renderMode = RenderMode.ScreenSpaceCamera;
レンダリングをメインカメラに

*GameObject panel_G = new GameObject("FacePanel");
パネル生成＆設定

*panel_G.transform.parent = canvas_G.transform;*//パネルのポジションを正面に調整
パネルをキャンバスの子に設定

*Vector3 panelPosition = panel_G.transform.localPosition;*panelPosition.x = 0;
パネルのポジションを正面に調整


*object[,] array2D = new object[100,100];
この初期化だと、配列の要素番号が一次元、二次元ともに0からスタートする。

*int[] lower = { 1, 1 };
二次元配列の各次元の最小要素番号

*int[] length = { rowIdx, colIdx };
二次元配列の各次元の要素数


*x = radius *Mathf.Sin(Time.time * speed);
三角関数による動きの設定。

*transform.position = new Vector3(x+transform.position.x,transform.position.y,transform.position.z);*}
X座標のみ三角関数による動きの設定を反映

*void Start()*{}
Start is called before the first frame update

*void Update()*{transform.position = new Vector3(Mathf.PingPong(Time.time,3),transform.position.y,transform.position.z);}
Update is called once per frame


*unsafe*{for (nIndexHeight = 0; nIndexHeight < nHeightSize; nIndexHeight++){for (nIndexWidth = 0; nIndexWidth < nWidthSize; nIndexWidth++){// バイト型のポインタで、画像のPixelデータのアドレスを取得しています。byte* pPixel = (byte*)bitmapData.Scan0 + nIndexHeight * bitmapData.Stride + nIndexWidth * 4;double dCalB = 0.0;double dCalG = 0.0;double dCalR = 0.0;double dCalA = 0.0;int nIndexWidthMask;int nIndexHightMask;int nFilter = 0;while (nFilter < m_nFilterMax){for (nIndexHightMask = 0; nIndexHightMask < nMasksize; nIndexHightMask++){for (nIndexWidthMask = 0; nIndexWidthMask < nMasksize; nIndexWidthMask++){if (nIndexWidth + nIndexWidthMask > 0 &&nIndexWidth + nIndexWidthMask < nWidthSize &&nIndexHeight + nIndexHightMask > 0 &&nIndexHeight + nIndexHightMask < nHeightSize){// フィルタ処理のために、バイト型のポインタで、画像のPixelデータのアドレスを取得しています。byte* pPixel2 = (byte*)bitmapData.Scan0 + (nIndexHeight + nIndexHightMask) * bitmapData.Stride + (nIndexWidth + nIndexWidthMask) * 4;dCalB += pPixel2[0] * m_dMask[nIndexWidthMask, nIndexHightMask];dCalG += pPixel2[1] * m_dMask[nIndexWidthMask, nIndexHightMask];dCalR += pPixel2[2] * m_dMask[nIndexWidthMask, nIndexHightMask];dCalA += pPixel2[3] * m_dMask[nIndexWidthMask, nIndexHightMask];}}}nFilter++;}// ポインタなので、SetPixelのようなメソッドを呼ばなくて、そのままフィルタ処理後の値を設定できます。pPixel[0] = DoubleToByte(dCalB);pPixel[1] = DoubleToByte(dCalG);pPixel[2] = DoubleToByte(dCalR);pPixel[3] = DoubleToByte(dCalA);}}m_bitmapImageFilter.UnlockBits(bitmapData);}
unsafeで囲みます

*byte* pPixel = (byte*)bitmapData.Scan0 + nIndexHeight * bitmapData.Stride + nIndexWidth * 4;
バイト型のポインタで、画像のPixelデータのアドレスを取得しています。

*byte* pPixel2 = (byte*)bitmapData.Scan0 + (nIndexHeight + nIndexHightMask) * bitmapData.Stride + (nIndexWidth + nIndexWidthMask) * 4;
フィルタ処理のために、バイト型のポインタで、画像のPixelデータのアドレスを取得しています。

*pPixel[0] = DoubleToByte(dCalB);
ポインタなので、SetPixelのようなメソッドを呼ばなくて、そのままフィルタ処理後の値を設定できます。

*byte bytePixel2B = m_pixelData[nIndexWidth + nIndexWidthMask, nIndexHeight + nIndexHightMask, (int)Pixel.B];
Pixelデータの取得はフィルタ処理中でなく、事前に取得しています。
ここでGetPixelするとオーバーヘッドが凄すぎて断念しました...

*m_bitmapImageFilter.SetPixel(nIndexWidth, nIndexHeight, Color.FromArgb(bytePixelA, bytePixelR, bytePixelG, bytePixelB));
フィルタ処理後に、SetPixelで画像のPixelデータを設定しています。

*}
ポインタなどの処理


*interface IExplainer*{string Explain();}
各クラスが自分自身の説明をするための共通のインターフェース

*class WithSoupRamen : IExplainer {private string Name;private Noodles Noodles;private Soup Soup;private Topping Topping;public WithSoupRamen(string name, Noodles noodles, Soup soup, Topping topping) {Name = name;Noodles = noodles;Soup = soup;Topping = topping;}public string Explain() {return Name + "の\n" + Noodles.Explain() + "\n" + Soup.Explain() + "\n" + Topping.Explain();}}
汁あり

*class Noodles : IExplainer {private string WidthType;public Noodles(string widthType) {WidthType = widthType;}public string Explain() {return "麺の太さは" + WidthType + "です。";}}
麺

*class Soup : IExplainer {private Fond Fond;private Sauce Sauce;private Oil Oil;public Soup(Fond fond, Sauce sauce, Oil oil) {Fond = fond;Sauce = sauce;Oil = oil;}public string Explain() {return Fond.Explain() + "\n" + Sauce.Explain() + "\n" + Oil.Explain();}}
スープ

*class Fond : IExplainer {private List<string> Ingredients = new List<string>();public Fond(string ingredient) {AddFond(ingredient);}public void AddFond(string ingredient) {Ingredients.Add(ingredient);}public string Explain() {return "出汁は" + String.Join(", ", Ingredients) + "です。";}}
出汁

*class Sauce : IExplainer {private List<string> Seasonings = new List<string>();public Sauce(string seadoning) {AddSauce(seadoning);}public void AddSauce(string seadoning) {Seasonings.Add(seadoning);}public string Explain() {return "タレは" + String.Join(", ", Seasonings) + "です。";}}
タレ

*class Oil : IExplainer {private List<string> Oiltypes = new List<string>();public Oil(string oiltype) {AddOil(oiltype);}public void AddOil(string oiltype) {Oiltypes.Add(oiltype);}public string Explain() {return "香味油は" + String.Join(", ", Oiltypes) + "です。";}}
香味油

*class Topping : IExplainer {private List<string> Toppings = new List<string>();public Topping(string topping) {AddTopping(topping);}public void AddTopping(string topping) {Toppings.Add(topping);}public string Explain() {return "具は" + String.Join(", ", Toppings) + "です。";}}
具


*protected readonly long chunkStart;
chunk head + 8 (type + size)


*public void ConfigureServices(IServiceCollection services)*{services.Configure<CookiePolicyOptions>(options =>{// This lambda determines whether user consent for non-essential cookies is needed for a given request.options.CheckConsentNeeded = context => true;options.MinimumSameSitePolicy = SameSiteMode.None;});services.AddLocalization(options => options.ResourcesPath = "Resources");services.AddMvc().AddViewLocalization(LanguageViewLocationExpanderFormat.Suffix).SetCompatibilityVersion(CompatibilityVersion.Latest);}
This method gets called by the runtime. Use this method to add services to the container.

*public void Configure(IApplicationBuilder app, IHostingEnvironment env)*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseExceptionHandler("/Home/Error");// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.app.UseHsts();}var supportedCultures = new[]{new CultureInfo("ja-JP"),new CultureInfo("en-US"),};app.UseRequestLocalization(new RequestLocalizationOptions{DefaultRequestCulture = new RequestCulture("ja-JP"),// Formatting numbers, dates, etc.SupportedCultures = supportedCultures,// UI strings that we have localized.SupportedUICultures = supportedCultures});app.UseHttpsRedirection();app.UseStaticFiles();app.UseCookiePolicy();app.UseMvc(routes =>{routes.MapRoute(name: "default",template: "{controller=Home}/{action=Index}/{id?}");});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*SupportedCultures = supportedCultures,UI strings that we have localized.SupportedUICultures = supportedCultures});
Formatting numbers, dates, etc.

*SupportedUICultures = supportedCultures});
UI strings that we have localized.


*return ret.Substring(ret.Length - digits.Value, digits.Value);
間引き 例：(ret, digits) = ("1010", 3) => "010"

*return ret.PadLeft(digits.Value, '0');
0埋め 例：(ret, digits) = ("101", 5) => "00101"


*public const int SIGNIFICANT_DIGIT = 16;
有効桁数

*private const string DECIMAL = @"[\+\-]?\d+(?:\.\d+)?";
小数点も取得する数値を表すPattern

*public static string Calculation(string calcStr)*{string result = "";// 対象文字列の半角スペースを削除result = Regex.Replace(calcStr, @"\s", "");// +-の符号重複を整理result = OperatorOrganize(result);// 余分な括弧を整理するresult = BracketsOrganize(result);// 関数の計算result = ProcFunction(result);// ()内を計算result = CalculationBrackets(result);// カッコが全て計算された後の通常計算result = NormalCalculation(result);// 先頭の + は削除するresult = Regex.Replace(result, @"^\+", "");return result;}
文字列を計算して結果を返す

*result = Regex.Replace(calcStr, @"\s", "");
対象文字列の半角スペースを削除

*result = OperatorOrganize(result);
+-の符号重複を整理

*result = BracketsOrganize(result);
余分な括弧を整理する

*result = ProcFunction(result);
関数の計算

*result = CalculationBrackets(result);
()内を計算

*result = NormalCalculation(result);
カッコが全て計算された後の通常計算

*result = Regex.Replace(result, @"^\+", "");
先頭の + は削除する

*private static string OperatorOrganize(string calcStr)*{// + または - が２個連続している箇所を検出string pattern = @"[\+\-]{2}";return CalculationBase(calcStr, pattern, (baseMatch) =>{string result;// ２つ続いている演算子を取得Match match = Regex.Match(baseMatch.Value, @"([\+\-])([\+\-])");result = (match.Result("$1") == match.Result("$2")) ? "+" : "-";return result;});}
+ または - 演算子の重複を解消する

*string pattern = @"[\+\-]{2}";
+ または - が２個連続している箇所を検出

*Match match = Regex.Match(baseMatch.Value, @"([\+\-])([\+\-])");
２つ続いている演算子を取得

*private static string BracketsOrganize(string calcStr)*{string d = @"[\+\-\*\/]|" + DECIMAL;string pattern = @"\({2}((?:" + d + @"|\((?:" + d + @")+\))+)\){2}";return CalculationBase(calcStr, pattern, (baseMatch) =>{string result = baseMatch.Result("($1)");return result;});}
余計な括弧をまとめる

*private static string ProcFunction(string calcStr)*{// Sin() や Cos() など関数の形に一致string d = @"[\+\-\*\/]|" + DECIMAL;string d1 = d + @"\,?";string d2 = @"\((?:" + d + @")+\)\,?";string f = @"[a-zA-Z_]\w+";string pattern = "(" + f + @")\(((?:" + d1 + "|" + d2 + @")*)\)";return CalculationBase(calcStr, pattern, (baseMatch) =>{// 後ろで正規表現を使用するので、$1が消える前に関数名を取得しておくstring func = baseMatch.Result("$1");// 引数をカンマ区切りで取得し、それぞれを計算するstring[] args = baseMatch.Result("$2").Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);for (int i = 0; i < args.Length; i++){args[i] = CalculationBrackets(args[i]);args[i] = NormalCalculation(args[i]);}// 関数呼び出しstring result = StringCalculationFunctions.InvokeMethod(func, args);// 小数点第n位まで取得し、後ろの余分な0を切り捨てるresult = result.ToDouble().ToStringWithDigit(SIGNIFICANT_DIGIT);return result;});}
関数の計算

*string d = @"[\+\-\*\/]|" + DECIMAL;
Sin() や Cos() など関数の形に一致

*string func = baseMatch.Result("$1");
後ろで正規表現を使用するので、$1が消える前に関数名を取得しておく

*string[] args = baseMatch.Result("$2").Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
引数をカンマ区切りで取得し、それぞれを計算する

*string result = StringCalculationFunctions.InvokeMethod(func, args);
関数呼び出し

*result = result.ToDouble().ToStringWithDigit(SIGNIFICANT_DIGIT);
小数点第n位まで取得し、後ろの余分な0を切り捨てる

*private static string CalculationBrackets(string calcStr)*{// 一番内側の括弧に一致string d = DECIMAL;string pattern = @"\(((?:[\-\+\*\/]|" + d + @")+)\)";return CalculationBase(calcStr, pattern, (baseMatch) =>{string result = baseMatch.Result("$1");result = OperatorOrganize(result);result = NormalCalculation(result);return result;});}
カッコ付きの箇所の計算

*string d = DECIMAL;
一番内側の括弧に一致

*private static string NormalCalculation(string calcStr)*{// 掛け算と割り算string result = MultiDiv(calcStr);// 足し算と引き算result = AddSub(result);return result;}
カッコなしの通常の計算を行う

*string result = MultiDiv(calcStr);
掛け算と割り算

*result = AddSub(result);
足し算と引き算

*private static string MultiDiv(string calcStr)*{// 掛け算、または割り算に一致string d = DECIMAL;string pattern = d + @"\*" + d + "|" + d + @"\/" + d;return CalculationBase(calcStr, pattern, (baseMatch) =>{double nResult = 0;// 演算子で分割し、計算Match match = Regex.Match(baseMatch.Value, @"\*|\/");string l = match.Result("$`");string r = match.Result("$'");if (match.Value == "*"){nResult = (l.ToDouble() * r.ToDouble());}else if (match.Value == "/"){nResult = (l.ToDouble() / r.ToDouble());}else{nResult = match.Value.ToDouble();}// 小数点第n位まで取得し、後ろの余分な0を切り捨てるstring result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);// 計算結果が + の場合、前方の文字と結合する際に符号なしでくっついてしまう※ので、符号を追加// ※この関数の結果が10、前方の文字が123だとした場合、123 10 => 12310 になってしまう。// 　+ を記述しておけば、 123 +10 => 123+10 と正しい数式の形に戻せる。string prefix = nResult >= 0 ? "+" : "";return prefix + result;});}
* または / の計算を行う

*string d = DECIMAL;
掛け算、または割り算に一致

*Match match = Regex.Match(baseMatch.Value, @"\*|\/");
演算子で分割し、計算

*string result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);
小数点第n位まで取得し、後ろの余分な0を切り捨てる

*string prefix = nResult >= 0 ? "+" : "";
計算結果が + の場合、前方の文字と結合する際に符号なしでくっついてしまう※ので、符号を追加
※この関数の結果が10、前方の文字が123だとした場合、123 10 => 12310 になってしまう。
+ を記述しておけば、 123 +10 => 123+10 と正しい数式の形に戻せる。

*private static string AddSub(string calcStr)*{// 足し算、または引き算に一致string d = DECIMAL;string pattern = d + @"\+" + d + "|" + d + @"\-" + d;return CalculationBase(calcStr, pattern, (baseMatch) =>{double nResult = 0;// 演算子で分割し、計算Match match = Regex.Match(baseMatch.Value, @"(" + d + @")([\+\-])(" + d + @")");string l = match.Result("$1");string r = match.Result("$3");string op = match.Result("$2");if (op == "+"){nResult = (l.ToDouble() + r.ToDouble());}else if (op == "-"){nResult = (l.ToDouble() - r.ToDouble());}else{nResult = match.Value.ToDouble();}// 小数点第n位まで取得し、後ろの余分な0を切り捨てるstring result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);return result;});}
+ または - の計算を行う

*string d = DECIMAL;
足し算、または引き算に一致

*Match match = Regex.Match(baseMatch.Value, @"(" + d + @")([\+\-])(" + d + @")");
演算子で分割し、計算

*string result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);
小数点第n位まで取得し、後ろの余分な0を切り捨てる

*private static string CalculationBase(string calcStr, string pattern, Func<Match, string> callback, Match argMatch = null)*{// 指定したパターンに一致するMatch match = argMatch ?? Regex.Match(calcStr, pattern);if (match.Success){// あとで結合するので、計算する文字列の前後を取得しておくstring pre = match.Result("$`");string suf = match.Result("$'");// 計算はコールバックに任せるstring result = callback(match);// 計算結果を元の場所に結合result = string.Format("{0}{1}{2}", pre, result, suf);// まだ計算するべき数式があるかチェックMatch nMatch = Regex.Match(result, pattern);if (nMatch.Success){result = CalculationBase(result, pattern, callback, nMatch);}return result;}return calcStr;}
各種計算用メソッドのベース

*Match match = argMatch ?? Regex.Match(calcStr, pattern);
指定したパターンに一致する

*string pre = match.Result("$`");
あとで結合するので、計算する文字列の前後を取得しておく

*string result = callback(match);
計算はコールバックに任せる

*result = string.Format("{0}{1}{2}", pre, result, suf);
計算結果を元の場所に結合

*Match nMatch = Regex.Match(result, pattern);
まだ計算するべき数式があるかチェック

*private const double E = 2.71828182845904523536;
ネイピア数

*private const int SIGNIFICANT_DIGIT = StringCalculation.SIGNIFICANT_DIGIT;
有効桁数

*private static readonly Dictionary<(string, int), Func<string[], string>> _methodCache = new Dictionary<(string, int), Func<string[], string>>*{{("Sin",   new Type[]{typeof(string)}.GetValueHash()), (args)=>{ return Sin(args[0]); }},{("Cos",   new Type[]{typeof(string)}.GetValueHash()), (args)=>{ return Cos(args[0]); }},{("Tan",   new Type[]{typeof(string)}.GetValueHash()), (args)=>{ return Tan(args[0]); }},{("Log10", new Type[]{typeof(string)}.GetValueHash()), (args)=>{ return Log10(args[0]); }},{("Log",   new Type[]{typeof(string)}.GetValueHash()), (args)=>{ return Log(args[0]); }},{("Log",   new Type[]{typeof(string), typeof(string)}.GetValueHash()), (args)=>{ return Log(args[0], args[1]); }},{("Ln",    new Type[]{typeof(string)}.GetValueHash()), (args)=>{ return Ln(args[0]); }},};
メソッド呼び出し用辞書

*private static int GetValueHash(this Type[] types)*{int result = 0;int length = types.Length;for (int i = 0; i < length; i++){var shift_l = (i % 32);var shift_r = 32 - shift_l;var hash = types[i].GetHashCode();result += hash << shift_l | hash >> shift_r;}return result;}
Type[]で同じ並びの際に同じハッシュ値を返す

*public static string InvokeMethod(string methodName, params object[] args)*{var argTypesHash = ((args == null) ? Type.EmptyTypes : args.Select(x => x.GetType()).ToArray()).GetValueHash();var cacheKey = (methodName, argTypesHash);var func = _methodCache[cacheKey];return func(args);}
登録されたメソッドを呼び出す

*====================================================================================================Sinpublic static string Sin(string calcStr){double result = Math.Sin(Deg2rad(calcStr.ToDouble()));
実体メソッド

*public static string Sin(string calcStr)*{double result = Math.Sin(Deg2rad(calcStr.ToDouble()));return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
Sin

*public static string Cos(string calcStr)*{double result = Math.Cos(Deg2rad(calcStr.ToDouble()));return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
Cos

*public static string Tan(string calcStr)*{double result = Math.Tan(Deg2rad(calcStr.ToDouble()));return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
Tan

*public static string Log10(string calcStr)*{double result = Math.Log10(calcStr.ToDouble());return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
log - 10を底としたlogの計算を行う

*public static string Log(string calcStr)*{double result = Math.Log(calcStr.ToDouble());return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
log - ネイピア数 e を底としたlogの計算を行う

*public static string Log(string calcStr, string baseStr)*{double result = Math.Log(calcStr.ToDouble(), baseStr.ToDouble());return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
log - 自前でベース値を設定する

*public static string Ln(string calcStr)*{double result = Math.Log(calcStr.ToDouble(), E);return result.ToStringWithDigit(SIGNIFICANT_DIGIT);}
log - ネイピア数 e を底としたlogの計算を行う

*private static double Deg2rad(double num)*{return num / 180.0 * Math.PI;}
角度をラジアンに変換

*public static string ToStringWithDigit(this double value, int digit)*{// 小数点第digit位まで取得し、後ろの余分な0を切り捨てるstring result = string.Format("{0:f" + digit + "}", value);return Regex.Replace(result, @"(\.?0+)$", "");}
小数点第n位まで取得し、後ろの余分な0を切り捨てて文字列にする

*string result = string.Format("{0:f" + digit + "}", value);
小数点第digit位まで取得し、後ろの余分な0を切り捨てる

*public static double ToDouble(this string str)*{if (double.TryParse(str, out double ret)){return ret;}throw new ArgumentException("<" + str + ">をdouble型に変換できません");}
文字列をdouble型に変換します

*Match match = argMatch ?? Regex.Match(calcStr, pattern);
指定したパターンに一致する

*string pre = match.Result("$`");
あとで結合するので、計算する文字列の前後を取得しておく

*string result = callback(match);
計算はコールバックに任せる

*result = string.Format("{0}{1}{2}", pre, result, suf);
計算結果を元の場所に結合

*Match nMatch = Regex.Match(result, pattern);
まだ計算するべき数式があるかチェック

*string pattern = @"[\+\-]{2}";
+ または - が２個連続している箇所を検出

*Match match = Regex.Match(baseMatch.Value, @"([\+\-])([\+\-])");
２つ続いている演算子を取得

*string d = DECIMAL;
足し算、または引き算に一致

*Match match = Regex.Match(baseMatch.Value, @"(" + d + @")([\+\-])(" + d + @")");
演算子で分割し、計算

*string result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);
小数点第n位まで取得し、後ろの余分な0を切り捨てる

*string d = DECIMAL;
掛け算、または割り算に一致

*Match match = Regex.Match(baseMatch.Value, @"\*|\/");
演算子で分割し、計算

*string result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);
小数点第n位まで取得し、後ろの余分な0を切り捨てる

*string prefix = nResult >= 0 ? "+" : "";
計算結果が + の場合、前方の文字と結合する際に符号なしでくっついてしまう※ので、符号を追加
※この関数の結果が10、前方の文字が123だとした場合、123 10 => 12310 になってしまう。
+ を記述しておけば、 123 +10 => 123+10 と正しい数式の形に戻せる。

*string result = MultiDiv(calcStr);
掛け算と割り算

*result = AddSub(result);
足し算と引き算

*string d = DECIMAL;
一番内側の括弧に一致

*string d = @"[\+\-\*\/]|" + DECIMAL;
Sin() や Cos() など関数の形に一致

*string func = baseMatch.Result("$1");
後ろで正規表現を使用するので、$1が消える前に関数名を取得しておく

*string[] args = baseMatch.Result("$2").Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
引数をカンマ区切りで取得し、それぞれを計算する

*string result = StringCalculationFunctions.InvokeMethod(func, args);
関数呼び出し

*result = result.ToDouble().ToStringWithDigit(SIGNIFICANT_DIGIT);
小数点第n位まで取得し、後ろの余分な0を切り捨てる

*result = Regex.Replace(calcStr, @"\s", "");
対象文字列の半角スペースを削除

*result = OperatorOrganize(result);
+-の符号重複を整理

*result = BracketsOrganize(result);
余分な括弧を整理する

*result = ProcFunction(result);
関数の計算

*result = CalculationBrackets(result);
()内を計算

*result = NormalCalculation(result);
カッコが全て計算された後の通常計算

*result = Regex.Replace(result, @"^\+", "");
先頭の + は削除する

*void Start()*{// 通常計算_Recalculation("3.5 - 0.5 + 21 * 2 / 2.5",3.5 - 0.5 + 21 * 2 / 2.5);// 通常計算_Recalculation("-2 + 1 * +2 / -2 / 2.0 * -2 + 5 * 2",-2 + 1 * +2 / -2 / 2.0 * -2 + 5 * 2);// 括弧付き計算_Recalculation("(1 + 2.5 + (2 - 3.5) * (1 + 1)) * 5 + 3 * (20 - 8)",(1 + 2.5 + (2 - 3.5) * (1 + 1)) * 5 + 3 * (20 - 8));// 演算子重複_Recalculation("1 * (+2 + (-3)) - -+4 - -+ +- -5",1 * (+2 + (-3)) - -+4 - -+ +- -5);// 括弧の計算_Recalculation("2 - (1 * -11)",2 - (1 * -11));// 括弧の計算_Recalculation("1 * (+2 + (-3)) - (-(+4)) - (-(+(+(-(-5)))))",1 * (+2 + (-3)) - (-(+4)) - (-(+(+(-(-5))))));// 括弧の計算_Recalculation("((-20.25) + 4) / ((4 / 2) + 3 * (1 * 2))",((-20.25) + 4) / ((4 / 2) + 3 * (1 * 2)));// 関数の計算_Recalculation("Sin(45)",Math.Sin(Deg2rad(45)));// 関数の計算_Recalculation("Cos(45)",Math.Cos(Deg2rad(45)));// 関数の計算_Recalculation("Tan(45)",Math.Tan(Deg2rad(45)));// 関数の計算_Recalculation("Cos((12)) + Tan((179) + Sin(75))",Math.Cos(Deg2rad((12))) + Math.Tan(Deg2rad((179) + Math.Sin(Deg2rad(75)))));// 余分な括弧の計算_Recalculation("((((-(2 + 3) + 9))))",((((-(2 + 3) + 9)))));// 関数と過剰な括弧の計算_Recalculation("((Cos(Sin(( Cos(((((45+45)))) + 90) * - 90 )) * 180)) + 20 + Tan((180)))",((Math.Cos(Deg2rad(Math.Sin((Deg2rad(Math.Cos(Deg2rad(((((45 + 45)))) + 90)) * -90))) * 180))) + 20 + Math.Tan(Deg2rad((180)))));// 関数と過剰な括弧の計算_Recalculation("Cos((((((((-(2+3)+9))))))))",Math.Cos(Deg2rad((((((((-(2 + 3) + 9))))))))));// Log計算_Recalculation("Sin(Log10(10))",Math.Sin(Deg2rad(Math.Log10(10))));// Log計算_Recalculation("Sin(Log(10))",Math.Sin(Deg2rad(Math.Log(10))));// Log計算_Recalculation("Sin(Log(10+2*3, 4*2.4-5))",Math.Sin(Deg2rad(Math.Log(10 + 2 * 3, 4 * 2.4 - 5))));// Log計算_Recalculation("Log10(0.1)",Math.Log10(0.1));// Log計算_Recalculation("Ln(42.22*2)",Math.Log(42.22 * 2, Math.E));}
Use this for initialization

*_Recalculation("3.5 - 0.5 + 21 * 2 / 2.5",3.5 - 0.5 + 21 * 2 / 2.5);
通常計算

*_Recalculation("-2 + 1 * +2 / -2 / 2.0 * -2 + 5 * 2",-2 + 1 * +2 / -2 / 2.0 * -2 + 5 * 2);
通常計算

*_Recalculation("(1 + 2.5 + (2 - 3.5) * (1 + 1)) * 5 + 3 * (20 - 8)",
括弧付き計算

*_Recalculation("1 * (+2 + (-3)) - -+4 - -+ +- -5",
演算子重複

*_Recalculation("2 - (1 * -11)",
括弧の計算

*_Recalculation("1 * (+2 + (-3)) - (-(+4)) - (-(+(+(-(-5)))))",
括弧の計算

*_Recalculation("((-20.25) + 4) / ((4 / 2) + 3 * (1 * 2))",
括弧の計算

*_Recalculation("Sin(45)",
関数の計算

*_Recalculation("Cos(45)",
関数の計算

*_Recalculation("Tan(45)",
関数の計算

*_Recalculation("Cos((12)) + Tan((179) + Sin(75))",
関数の計算

*_Recalculation("((((-(2 + 3) + 9))))",
余分な括弧の計算

*_Recalculation("((Cos(Sin(( Cos(((((45+45)))) + 90) * - 90 )) * 180)) + 20 + Tan((180)))",
関数と過剰な括弧の計算

*_Recalculation("Cos((((((((-(2+3)+9))))))))",
関数と過剰な括弧の計算

*_Recalculation("Sin(Log10(10))",
Log計算

*_Recalculation("Sin(Log(10))",
Log計算

*_Recalculation("Sin(Log(10+2*3, 4*2.4-5))",
Log計算

*_Recalculation("Log10(0.1)",
Log計算

*_Recalculation("Ln(42.22*2)",
Log計算

*private void _Recalculation(string str, double nResult)*{string sResult = StringCalculation.Calculation(str);// 計算結果が文字列として一致、もしくは誤差の範囲内かどうかstring isSuccess = (sResult == nResult.ToString() || Math.Abs(sResult.ToDouble() - nResult) <= 0.000000000001) ? "○" : "×";string resultStr = "検算結果 : " + "" + isSuccess + "\n" + str + "  =>\n STR : [" + sResult + "]\n NUM : [" + nResult + "]\n\n";_dbgStr += resultStr;}
文字列の式と実際に計算した際の数値結果を入力し、検算を行う

*string isSuccess = (sResult == nResult.ToString() || Math.Abs(sResult.ToDouble() - nResult) <= 0.000000000001) ? "○" : "×";
計算結果が文字列として一致、もしくは誤差の範囲内かどうか

*private static string _logText = "";
Debug用変数

*result = Regex.Replace(calcStr, @"\s", "");
対象文字列の半角スペースを削除

*result = OperatorOrganize(result);
+-の符号重複を整理

*result = BracketsOrganize(result);
余分な括弧を整理する

*result = ProcFunction(result);
関数の計算

*result = CalculationBrackets(result);
()内を計算

*result = NormalCalculation(result);
カッコが全て計算された後の通常計算

*result = Regex.Replace(result, @"^\+", "");
先頭の + は削除する

*string pattern = @"[\+\-]{2}";
+ または - が２個連続している箇所を検出

*Match match = Regex.Match(baseMatch.Value, @"([\+\-])([\+\-])");
２つ続いている演算子を取得

*string d = @"[\+\-\*\/]|" + DECIMAL;
Sin() や Cos() など関数の形に一致

*string func = baseMatch.Result("$1");
後ろで正規表現を使用するので、$1が消える前に関数名を取得しておく

*string[] args = baseMatch.Result("$2").Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
引数をカンマ区切りで取得し、それぞれを計算する

*result = result.ToDouble().ToStringWithDigit(SIGNIFICANT_DIGIT);
小数点第n位まで取得し、後ろの余分な0を切り捨てる

*string d = DECIMAL;
一番内側の括弧に一致

*string result = MultiDiv(calcStr);
掛け算と割り算

*result = AddSub(result);
足し算と引き算

*string d = DECIMAL;
掛け算、または割り算に一致

*Match match = Regex.Match(baseMatch.Value, @"\*|\/");
演算子で分割し、計算

*string result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);
小数点第n位まで取得し、後ろの余分な0を切り捨てる

*string prefix = nResult >= 0 ? "+" : "";
計算結果が + の場合、前方の文字と結合する際に符号なしでくっついてしまう※ので、符号を追加
※この関数の結果が10、前方の文字が123だとした場合、123 10 => 12310 になってしまう。
+ を記述しておけば、 123 +10 => 123+10 と正しい数式の形に戻せる。

*string d = DECIMAL;
足し算、または引き算に一致

*Match match = Regex.Match(baseMatch.Value, @"(" + d + @")([\+\-])(" + d + @")");
演算子で分割し、計算

*string result = nResult.ToStringWithDigit(SIGNIFICANT_DIGIT);
小数点第n位まで取得し、後ろの余分な0を切り捨てる

*Match match = argMatch ?? Regex.Match(calcStr, pattern);
指定したパターンに一致する

*string pre = match.Result("$`");
あとで結合するので、計算する文字列の前後を取得しておく

*CalculationLog("  match : " + pre + "  [" + mat + "]  " + suf + "\n");
マッチ結果を表示

*string result = callback(match);
計算はコールバックに任せる

*result = string.Format("{0}{1}{2}", pre, result, suf);
計算結果を元の場所に結合

*Match nMatch = Regex.Match(result, pattern);
まだ計算するべき数式があるかチェック

*====================================================================================================/ <summary>
debug デバッグ出力用


*PostProcessVolume processVolume;
CameraにAdd

*public void Tunnel_ON()*{if(processVolume.weight == 0){coroutine = StartCoroutine(Tunnel_ON_Coroutine());}}
トンネル開始

*public void Tunnel_OFF()*{if (processVolume.weight == 1){coroutine = StartCoroutine(Tunnel_OFF_Coroutine());}}
トンネル解除

*public void Tunnel_ON()*{if(processVolume.weight == 0){coroutine = StartCoroutine(Tunnel_ON_Coroutine());}}
トンネル開始

*public void Tunnel_OFF()*{if (processVolume.weight == 1){coroutine = StartCoroutine(Tunnel_OFF_Coroutine());}}
トンネル解除


*Microsoft.Win32.RegistryKey regkey = Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"Software\TodoListDon\sub", false);
以下の行でレジストリを取り扱う

*AccessToken = (string)regkey.GetValue("AccessToken");
読み込む

*OAuthlink.LinkVisited = true;
リンク先に移動したことにする

*System.Diagnostics.Process.Start(OAuthlink.Text);
ブラウザで開く

*string registryKeyName = @"Software\TodoListDon\Sub";
操作するレジストリ・キーの名前

*string registryValueName = "hostname";
取得処理を行う対象となるレジストリの値の名前

*using (RegistryKey registryKey = Registry.LocalMachine.CreateSubKey(registryKeyName)){レジストリの値を設定registryKey.SetValue(registryValueName, host);
キー（HKEY_CURRENT_USER\Software\Sample）を開く

*registryKey.SetValue(registryValueName, host);
レジストリの値を設定

*registryValueName = "AccessToken";
取得処理を行う対象となるレジストリの値の名前

*using (RegistryKey registryKey = Registry.LocalMachine.CreateSubKey(registryKeyName)){レジストリの値を設定registryKey.SetValue(registryValueName, tokens.AccessToken);
キー（HKEY_CURRENT_USER\Software\Sample）を開く

*registryKey.SetValue(registryValueName, tokens.AccessToken);
レジストリの値を設定


*var startDateTime = DateTime.Now;
ここで開始時間を保存しておく

*var collapsedTime = DateTime.Now - startDateTime;*Console.WriteLine($"End [{methodName}] took {collapsedTime.TotalMilliseconds:F2}ms");
ここで経過時間を求める

*using (WriteLineMeasureTimeAsDisposable())*{await Task.Delay(2000);}
ここで先ほどの計測関数を実装

*,,,
・・・・

*Console.WriteLine(CreateLogString(log, header));
ログ出力

*Console.WriteLine(CreateLogString(ex.ToString(), header));
例外情報出力


*void Ping(int i)
登録するメソッドにint型引数を持たす


*listener.Prefixes.Add("http:
+:80Temporary_Listen_Addresses");


*HeavyActionAsync();
次のコンパイル警告が検出されます。
この呼び出しを待たないため、現在のメソッドの実行は、呼び出しが完了するまで続行します。
呼び出しの結果に 'await' 演算子を適用することを検討してください。

*private async void BtnHeavyAction_Click(object sender, EventArgs e)*{Debug.WriteLine("BtnHeavyAction_Click enter");// await をつけます。// BtnHeavyAction_Click に async をつけないと次のコンパイルエラーが検出されます。// 'await' 演算子は、非同期メソッド内でのみ使用できます。// このメソッドに 'async' 修飾子を指定し、戻り値の型を 'Task' に変更することを検討してください。await HeavyActionAsync();Debug.WriteLine("BtnHeavyAction_Click exit");}
async をつけます。

*await HeavyActionAsync();
await をつけます。
BtnHeavyAction_Click に async をつけないと次のコンパイルエラーが検出されます。
'await' 演算子は、非同期メソッド内でのみ使用できます。
このメソッドに 'async' 修飾子を指定し、戻り値の型を 'Task' に変更することを検討してください。

*Task nowait = HeavyActionAsync();
戻り値を受けます。
このような場合、私は nowait のような変数名にすることが多いです。
人間に対しても「待つ必要がない」ということが伝わるからです。

*HeavyActionAsync().Wait();
ここでフリーズします。

*int result = HeavyFuncAsync(2, 3).Result;*Debug.WriteLine($"result={result}");
ここでフリーズします。

*private async void BtnHeavyAction_Click（object sender, EventArgs e)*{Debug.WriteLine("BtnHeavyAction_Click enter");// await をつけます。await HeavyActionAsync();Debug.WriteLine("BtnHeavyAction_Click exit");}
async をつけます。

*await HeavyActionAsync();
await をつけます。

*HeavyActionAsync().Wait();
HeavyActionAsync の実行中 UI はブロックされますが、フリーズすることはなくなります。

*await Task.Delay(3000).ConfigureAwait(false);
ConfigureAwait(false) をつけます。

*Debug.WriteLine($"{ex.GetType().Name}:{ex.Message}");
ここではキャッチできない。

*// ※ただ待ちたいだけなら await を使いましょう。*while (task.IsCompleted) {}
タスクが完了するまでポーリングしたりすると例外が排出されます。

*Debug.WriteLine($"{ex.GetType().Name}:{ex.Message}");
ここで例外がキャッチされます。

*HeavyActionAsync().Wait();
Wait で完了を待つ。

*Debug.WriteLine($"{ex.GetType().Name}:{ex.Message}");
ここで例外がキャッチされます。

*btnHeavyAction.Enabled = false;
コントロールにアクセス

*btnHeavyAction.Enabled = true;
コントロールにアクセス

*await Task.Delay(3000).ConfigureAwait(false);
ここまでは呼び出し元スレッド

*,,,
ここから後は別のスレッド


*var enumVal = EnumA.Member2;
Member2 メンバの属性を取得してみる


*if (Input.GetKeyDown(KeyCode.T))
VRのカメラオン


*@"C:\ProgramData\Application Data",
よくある隠しフォルダ

*await Task.Run(async () =>*{//ファイル取得var filePaths = await GetAllFilesAsync(@"C:\");//一回でList型で取得するのではなく//1ファイル読み込み毎に何らかの処理をしたいからIEnumerable型で取得したいforeach (var filePath in filePaths){//タスクのキャンセルがされていたら例外を投げる_cancellationToken.ThrowIfCancellationRequested();//1ファイル読み込み毎に何らかの処理}}, _cancellationToken);
スレッドプールさん、処理をお願いします何でもしますから

*var filePaths = await GetAllFilesAsync(@"C:\");
ファイル取得

*foreach (var filePath in filePaths)
一回でList型で取得するのではなく
1ファイル読み込み毎に何らかの処理をしたいからIEnumerable型で取得したい

*_cancellationToken.ThrowIfCancellationRequested();
タスクのキャンセルがされていたら例外を投げる

*}
1ファイル読み込み毎に何らかの処理

*return Directory.EnumerateFiles(folderPath).Concat(directories);
同階層のファイル取得をして再帰的に同階層のフォルダを検索しに行く

*var files = GetAllFiles(folderPath).ToList();
パターン1
IEnumerable型で取得した後にList化して初めからListで返すパターンとの比較を行う

*//IEnumerableで取得したものをforeachで展開させる*foreach (var file in GetAllFiles(folderPath))
パターン2

*this.Dispatcher.Invoke(() =>*{this.txtFileCount.Text = file.index + Environment.NewLine + file.value;});
Dispatcher.InvokeでUIスレッドに処理をさせる

*await Task.Run(() =>*{foreach (var file in GetAllFiles(folderPath).Select((value, index) => new { value, index })){//UIスレッドに戻ってきてUIを更新させるthis.Dispatcher.Invoke(() =>{this.txtFileCount.Text = file.index + Environment.NewLine + file.value;});}});
スレッドプールに処理を任せといた

*this.Dispatcher.Invoke(() =>*{this.txtFileCount.Text = file.index + Environment.NewLine + file.value;});
UIスレッドに戻ってきてUIを更新させる

*var filePaths = await Task.WhenAll(directories.Select(async x => await GetAllFilesAsync(x)))
再帰的にフォルダを探し続ける

*var tcs = new TaskCompletionSource<IEnumerable<string>>();
タスクを作成する

*yield break;
ディレクトリにアクセスできないならファイルはない

*var tcs = new TaskCompletionSource<IEnumerable<string>>();
タスクを作成

*await Task.Run(async () =>*{var enumerateFilesCollection = GetAllFilesAsync(@"C:\");await enumerateFilesCollection.ForEachAsync(async enumerateFiles =>{foreach (var file in await enumerateFiles){//キャンセルされれば例外で止める_cancellationToken.ThrowIfCancellationRequested();this.Dispatcher.Invoke(() =>{++count;this.txtFileCount.Text = count + Environment.NewLine + file;});}}, 200, _cancellationToken);}, _cancellationToken);
スレッドプールさん、処理をお願いします何でもしますから

*_cancellationToken.ThrowIfCancellationRequested();
キャンセルされれば例外で止める

*await Task.Run(async () =>
パターン1に関しては省略
パターン2の計測の仕方

*_cancellationToken.ThrowIfCancellationRequested();
キャンセルされれば例外で止める

*Interlocked.Increment(ref count);
念の為スレッドセーフにインクリメントを行う

*await Task.Factory.StartNew(async () =>*{var enumerateFilesCollection = GetAllFilesAsync(@"C:\");await enumerateFilesCollection.ForEachAsync(async enumerateFiles =>{foreach (var file in await enumerateFiles){//キャンセルされれば例外で止める_cancellationToken.ThrowIfCancellationRequested();//念の為スレッドセーフにインクリメントを行うInterlocked.Increment(ref count);if (count >= 50000){_cancellationTokenSource.Cancel();}}}, 200, _cancellationToken);}, _cancellationToken, TaskCreationOptions.LongRunning, TaskScheduler.Default);
Task.RunではTaskCreationOptionsを設定できないのでTask.Factoryを使用する

*_cancellationToken.ThrowIfCancellationRequested();
キャンセルされれば例外で止める

*Interlocked.Increment(ref count);
念の為スレッドセーフにインクリメントを行う

*,,,
}, _cancellationToken); こうじゃない
}, DispatcherPriority.Background, _cancellationToken); こっち

*_cancellationToken.ThrowIfCancellationRequested();
キャンセルされれば例外で止める

*Interlocked.Increment(ref count);
念の為スレッドセーフにインクリメントを行う

*this.Dispatcher.InvokeAsync(() =>*{this.txtFileCount.Text = count + Environment.NewLine + file;}, DispatcherPriority.Background, _cancellationToken);
意図的にawaitを付けない

*.Where(x => _exceptFolder.All(y => !x.StartsWith(y, StringComparison.CurrentCultureIgnoreCase)));
.AsParallel() 悪夢の元凶

*var filePaths = await Task.WhenAll(directories.Select(async x => await GetAllFilesAsync(x)))
再帰的にフォルダを探し続ける

*var tcs = new TaskCompletionSource<IEnumerable<string>>();
タスクを作成する

*try*{await Task.Run(async () =>{var enumerateFilesCollection = GetAllFilesAsync(@"C:\");await enumerateFilesCollection.ForEachAsyncNoLock(async enumerateFiles =>{foreach (var file in await enumerateFiles){//キャンセルされれば例外で止める_cancellationToken.ThrowIfCancellationRequested();//念の為スレッドセーフにインクリメントを行うInterlocked.Increment(ref count);//意図的にawaitを付けないthis.Dispatcher.InvokeAsync(() =>{this.txtFileCount.Text = count + Environment.NewLine + file;}, DispatcherPriority.Background, _cancellationToken);}}, _cancellationToken);}, _cancellationToken);}
省略

*_cancellationToken.ThrowIfCancellationRequested();
キャンセルされれば例外で止める

*Interlocked.Increment(ref count);
念の為スレッドセーフにインクリメントを行う

*this.Dispatcher.InvokeAsync(() =>*{this.txtFileCount.Text = count + Environment.NewLine + file;}, DispatcherPriority.Background, _cancellationToken);
意図的にawaitを付けない

*}
省略


*MessageEffectSubject.OnNext("failure");
イベントを通知


*public static extern int Add(int a, int b);
dll内の関数

*public int tooltip_int;
dll内の関数

*public int header_int;
dll内の関数


*xmlns:i="http:
schemas.microsoft.comexpression2010interactivity"

*private IRegionNavigationService RegionNavigationService { get; set; }
OnNavigatedToで取得したものを保持.

*public DelegateCommand GoToSubBCommand { get; }
この画面から別の画面に遷移するためのトリガー.

*public SubaViewModel() => GoToSubBCommand = new DelegateCommand(() => RegionNavigationService.RequestNavigate(nameof(SubbView)));
コンストラクタでGoToSubBCommandの設定.RegionNavigationServiceを使用すればRegionManagerやRegionNameを意識しなくて良い.

*public void OnNavigatedTo(NavigationContext navigationContext) => RegionNavigationService = navigationContext.NavigationService;
OnNavigatedToで手に入るIRegionNavigationServiceを保持.

*public ContentViewModel() => PopupWindowCommand = new DelegateCommand(() => PopupWindowRequest.Raise(new PopupNotification(), PopupWindowRequestCallback));*private void PopupWindowRequestCallback(PopupNotification n)
リクエストをRaiseしてウィンドウが閉じられたときの挙動を設定.

*// Notificationはコンストラクタの時点ではまだ注入されていなかった.*private void Loaded()
PopupWindowActionで指定したViewのLoaded時に入れ物クラスに詰めておく.

*private void Loaded()*{if (Notification is PopupNotification n)n.PopupRegionManager = PopupRegionManager.Value;}
Notificationはコンストラクタの時点ではまだ注入されていなかった.


*var status = tokens.Statuses.Show(id => ************/*対象のツイートのID*/));
対象ツイートの取得

*var replies = tokens.Search.Tweets(q=>"to:"+ status.User.ScreenName,count=>100, since_id=>status.Id );
対象ツイート以降に投稿されたツイート主へのリプライを取得

*var targetReplies = replies.Where(w => w.InReplyToStatusId == status.Id);
リプライの中でも、宛先が対象のツイートとなっているもののみを取得


*DateTime gantan = new DateTime(targetYear, 1, 1);
対象年の1月1日(元旦)の曜日を取得する。

*DateTime date;
対象年の1月において、引数で指定した曜日に該当する最初の日付を取得する

*var days = FindWantDayOfWeek(targetYear, wantDayOfWeek);
対象年の指定された曜日に該当する日付を全て取得する。

*// さらに、ElementAtで各月のN番目の〇曜日の日付を抽出する。*var newDays = days.Select(day => new { Day = day, Month = day.Month }).GroupBy(day => day.Month)
日付を月単位でGroupByした後、Whereで「第N〇曜日が存在する月」に絞り込む。

*var newDays = days.Select(day => new { Day = day, Month = day.Month }).GroupBy(day => day.Month)
さらに、ElementAtで各月のN番目の〇曜日の日付を抽出する。

*int elapsedYear = end.Year - start.Year + 1;
開始年～終了年の指定された曜日に該当する日付を全て取得する。

*var newDays = days.Where(day => day >= start && day <= end).ToList();
得られた日付リストを、開始日～終了日の間に絞り込む。

*var days = DateUtils.FindWantDayOfWeek(2019, DayOfWeek.Tuesday, 2, new DateTime(2018, 4, 1), new DateTime(2019, 3, 31));
2018年4月1日～2019年3月31日の第2火曜日の日付を取得する。


*material.SetFloat("_GlossyReflections", 0);
0:OFF, 1:ON


*new PropertyMetadata(XXX_PropertyChanged)
コールバックを登録

*private static void XXX_PropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {var textBox = d as TextBox;if (textBox == null) return;//イベントハンドラの登録if (e.NewValue != null) {textBox.PreviewTextInput += TextBox_PreviewTextInput;} else {textBox.PreviewTextInput -= TextBox_PreviewTextInput;}}
コールバック

*private static void TextBox_PreviewTextInput(object sender, TextCompositionEventArgs e) {//振る舞い}
イベントハンドラ

*}
振る舞い

*private void AssociatedObject_Loaded(object sender, RoutedEventArgs e) {//振る舞い}
イベントハンドラ

*}
振る舞い


*public Result OnStartup(UIControlledApplication application)*{// Add a new ribbon panelRibbonPanel ribbonPanel = application.CreateRibbonPanel("NewRibbonPanel");// Create a push button to trigger a command add it to the ribbon panel.string thisAssemblyPath = Assembly.GetExecutingAssembly().Location;PushButtonData buttonData = new PushButtonData("cmdHelloWorld","Hello World", thisAssemblyPath, "HelloWorld.HelloWorld");PushButton pushButton = ribbonPanel.AddItem(buttonData) as PushButton;// Optionally, other properties may be assigned to the button// a) tool-tippushButton.ToolTip = "Say hello to the entire world.";// b) large bitmapUri uriImage = new Uri(@"C:\Users\会社\Documents\Visual Studio 2015\Projects\HelloWorld\地球アイコン9.jpeg");BitmapImage largeImage = new BitmapImage(uriImage);pushButton.LargeImage = largeImage;return Result.Succeeded;}
Both OnStartup and OnShutdown must be implemented as public method

*public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,ref string message, ElementSet elements)
The main Execute method (inherited from IExternalCommand) must be public


*transform.position = new Vector3(x+defPosition.x,defPosition.y, z+defPosition.z);
自分のいる位置から座標を動かす。


*var gatt = await device.GetGattServicesAsync();*Debug.WriteLine($"{device.Name} Services: {gatt.Services.Count}, {gatt.Status}, {gatt.ProtocolError}");
SERVICES!!


*}
（略）


*var toggleResult = EditorGUILayout.Toggle(flagName, isToggle);
確認したフラグが違ってたら反転

*EditorGUI.BeginDisabledGroup(true);*{EditorGUILayout.LabelField("CurrentFlag", _outputFlag.ToString());EditorGUILayout.LabelField("FlagHexValue", _outputFlag.ToString("X"));}
今のフラグの状態の表示


*private const string ENDPOINT = "https:
api-free.deepl.comv2translate?";

*var languages = Enum.GetNames(typeof(Language));
ドロップダウンメニュー作成

*fromLanguageDd.OnValueChangedAsObservable()*.Subscribe(value => { fromLanguage = (Language) value; })
翻訳元言語

*toLanguageDd.OnValueChangedAsObservable()*.Subscribe(value => { toLanguage = (Language) value; })
翻訳後言語

*translateButton.OnClickAsObservable()
翻訳ボタン押下

*var result = GetTranslation(fromLanguage, toLanguage, inputField.text, token);
結果が送られてくるまで待ってから表示

*var requestInfo = ENDPOINT + API_KEY;*requestInfo += $"&text={speechText}&source_lang={from}&target_lang={to}";
POSTメソッドのリクエストを作成

*var second = TimeSpan.FromSeconds(3);
結果受け取り


*static int[,] ReadData(string path) {int[,] nums = new int[9, 9];var lines = File.ReadAllLines(path);for (int y = 0; y < 9; y++) {int x = 0;foreach (var n in lines[y].Split(',')) {nums[x++, y] = int.Parse(n);}}return nums;}
データを読み込む

*yield return _board.Clone();*} else {
完成したら、answerに答えを入れる。

*var pos = _board.AlloLocations().Where(p => _board.IsVacant(p))
空いている位置をひとつ取り出す

*var answer = SolveInner();
置けたので、再帰的に次の数を置いていく。

*_board.Put(pos, 0);
次の数を置くために、今置いた場所には 0 を入れなおす。

*}
1..9どれも駄目。つまり失敗->  呼び出し元に戻る

*public Board(int[,] mat) {this.sheet = mat;}
コンストラクタ

*private Board() {sheet = new int[9, 9];}
コンストラクタ

*public Board Clone() {var nboard = new Board();nboard.sheet = (int[,])this.sheet.Clone();return nboard;}
クローン

*public void Put(Location pos, int num) {sheet[pos.X, pos.Y] = num;}
チェックはしない CanPutを呼び出しているのが前提

*public bool CanPut(Location pos, int num) {if (sheet[pos.X, pos.Y] != 0)return false;// 仮に置いてみる。sheet[pos.X, pos.Y] = num;try {return IsValid(pos);} finally {// 元に戻すsheet[pos.X, pos.Y] = 0;}}
置けるか

*sheet[pos.X, pos.Y] = num;*try {return IsValid(pos);} finally {// 元に戻すsheet[pos.X, pos.Y] = 0;}
仮に置いてみる。

*sheet[pos.X, pos.Y] = 0;
元に戻す

*public bool IsCompleted() {if (!Enumerable.Range(0, 9).All(nums => IsCompleted(VerticalNums(nums))))return false;if (!Enumerable.Range(0, 9).All(nums => IsCompleted(HorizontalNums(nums))))return false;return BoxLocations().All(pos => IsCompleted(BoxNums(pos)));}
完成か

*public bool IsCompleted(IEnumerable<int> nums) {return nums.Where(n => n >= 1).Distinct().Count() == 9;}
完成したか

*public bool IsVacant(Location pos) {return sheet[pos.X, pos.Y] == 0;}
空いているか

*public bool IsValid(Location pos) {return IsValid(VerticalNums(pos.X)) &&IsValid(HorizontalNums(pos.Y)) &&IsValid(BoxNums(pos));}
posの位置に関する配置は違反していないか

*public bool IsValid(IEnumerable<int> nums) {return nums.Where(n => n >= 1).Distinct().Count() == nums.Where(n => n >= 1).Count();}
numsに重複はないか （つまり違反していないか）IsCompletedとは別。

*public IEnumerable<Location> BoxLocations() {return from x in Enumerable.Range(0, 2)from y in Enumerable.Range(0, 2)select new Location(x * 3, y * 3);}
９つある小さな四角形の左上のLocationを列挙

*public IEnumerable<int> BoxNums(Location pos) {return from x in Enumerable.Range(0, 3)from y in Enumerable.Range(0, 3)select sheet[pos.X / 3 * 3 + x, pos.Y / 3 * 3 + y];}
注目している位置が含まれる3*3の領域の数を列挙

*public IEnumerable<int> VerticalNums(int x) {for (int y = 0; y < 9; y++) {yield return sheet[x, y];}}
注目している位置が含まれる縦一列の数を列挙

*public IEnumerable<int> HorizontalNums(int y) {for (int x = 0; x < 9; x++) {yield return sheet[x, y];}}
注目している位置が含まれる横一列の数を列挙

*public IEnumerable<Location> AlloLocations() {return from x in Enumerable.Range(0, 9)from y in Enumerable.Range(0, 9)select new Location(x, y);}
すべての位置を列挙する


*string str = Properties.Resources.Multi4,,,public static string GetName(this CountType e){switch (e){case CountType.Multi4:return Properties.Resources.Multi4;
日本語用リソースだと”4逓倍”、英語用だと”Multiple 4”


*Calc(4, 5, CalcType.Add).Is(9);
足し算

*Calc(4, 5, CalcType.Subtract).Is(-1);
引き算

*Calc(4, 5, CalcType.Multiple).Is(20);
掛け算

*Calc(4, 5, CalcType.Divide).Is((decimal) 0.8);
割り算

*var value =(typeof(TSelf).GetFields(BindingFlags.GetField | BindingFlags.Public | BindingFlags.Static |BindingFlags.DeclaredOnly).Where(f => !f.IsLiteral)).FirstOrDefault()?.GetValue(null);
without this, Count might be 0 on first time

*ProgRockBands.Values.Is(ProgRockBands.MoonSafari,ProgRockBands.GentleGiant,ProgRockBands.Genesis,ProgRockBands.CameliasGarden,ProgRockBands.IQ,ProgRockBands.PFM,ProgRockBands.YoninBayashi,ProgRockBands.TheFlowerKings);
All


*}
他のクラスメンバー略...

*,,,
だめだ。よくわかんねぇ

*var dic = Employees.Select(x => { return new KeyValuePair<int, string>(x.Id, x.Name); }).Tolist();
これじゃList<KeyValuePair> なんだぜ。。。

*var dic2 = Employees.Select(x => { return new KeyValuePair<int, string>(x.Id, x.Name); }).ToDictionary(x => x.Key);
KeyにKeyは入ってるけど、ValueにKeyValuePairが入ってる気がした。


*{
モバイルの場合は下記のエラーになるので移動しない

*Thread.Sleep(100);
ちょっと待たないとスクロールが間に合わない

*Bitmap lastSc = screenshots.Last();
最後の画像は重複部分を切り取る

*decimal bitmapWidth = lastSc.Width;
画像の縦横のサイズとJavascriptで取得した幅と高さから比率計算し、切り取るべきサイズを算出する

*Rectangle rect = new Rectangle(0, duplHeight, cutWidth, cutHeight);
算出したサイズで切り出す


*void Start () {controller = new Controller();fingers = new Finger[5];isGripFingers = new bool[5];}
Use this for initialization

*void Update () {Frame frame = controller.Frame();if(frame.Hands.Count != 0){List<Hand> hand = frame.Hands;fingers = hand[0].Fingers.ToArray();isGripFingers = Array.ConvertAll(fingers, new Converter<Finger, bool>(i => i.IsExtended));Debug.Log(isGripFingers[0]+","+ isGripFingers[1] + "," + isGripFingers[2] + "," + isGripFingers[3] + "," + isGripFingers[4]);int extendedFingerCount = isGripFingers.Count(n => n == true);if(extendedFingerCount == 0){rsp = RSP.Rock;}else if(extendedFingerCount < 4){rsp = RSP.Scissors;}else{rsp = RSP.Paper;}}}
Update is called once per frame


*private const string ENDPOINT = "https:
translation.googleapis.comlanguagetranslatev2?";

*var languages = Enum.GetNames(typeof(Language));
ドロップダウンメニュー作成

*fromLanguageDd.OnValueChangedAsObservable()*.Subscribe(value => { fromLanguage = (Language) value; })
翻訳元言語

*toLanguageDd.OnValueChangedAsObservable()*.Subscribe(value => { toLanguage = (Language) value; })
翻訳後言語

*translateButton.OnClickAsObservable()
翻訳ボタン押下

*var result = GetTranslation(fromLanguage, toLanguage, inputField.text, token);
結果が送られてくるまで待ってから表示

*var requestInfo = ENDPOINT;*requestInfo += $"key={API_KEY}&q={speechText}&detectedSourceLanguage={from}&target={to}";
POSTメソッドのリクエストを作成

*var second = TimeSpan.FromSeconds(3);
結果受け取り


*{
電話が来たらカッコ内の処理を流す．


*sample.Name = null;
ArgumentNullException がスローされる。これをレビューとテストで取り除くことができるか？

*Sample b = new Sample() { CreateDateTime = a.CreateDateTime };
a.CreateDateTime プロパティの値を b.CreateDateTime に代入（参照がコピーされる）

*Sample c = new Sample() { CreateDateTime = a.CreateDateTime.Clone() };
a.CreateDateTime プロパティの値のクローンを c.CreateDateTime に代入

*a.CreateDateTime.Seconds -= 60 * 60;
a.CreateDateTime の値から1時間を引く

*// 参照型と値型の違いを理解していない場合、わかりにくいバグを埋め込むリスクがあります*Debug.WriteLine($"a.CreateDateTime={a.CreateDateTime}");
当然ながら b.CreateDateTime の値も1時間が引かれます

*Debug.WriteLine($"a.CreateDateTime={a.CreateDateTime}");
参照型と値型の違いを理解していない場合、わかりにくいバグを埋め込むリスクがあります

*a.ParentID = new NullableInt32() { Value = 1 };
このように記述しなくてはいけません。partialファイルでコンストラクタや暗黙型変換を実装する必要あり？

*b.ParentID = null;
null を代入することはできます。

*b.ParentID = a.ParentID;
このようなコーディングは危険。

*HashSet<Player> hash = new HashSet<Player>();
a2 は重複していると扱われて格納されません

*Dictionary<Player, bool> dic = new Dictionary<Player, bool>();
a2 は重複していると扱われて ArgumentException がスローされます

*DateTime ISample.CreateDateTime*{get { return CreateDateTime.ToDateTime(); }set { CreateDateTime =Google.Protobuf.WellKnownTypes.Timestamp.FromDateTime(value.ToUniversalTime());}}
ProtoBuf モデルクラスとシグネチャが一致するメンバは明示的に実装する必要はありません。

*private SampleServiceClient m_Client;
アプリケーションロジックから使用するメソッド

*return SampleData.FromRpcModel(m_Client.GetSample(request.ToRpcModel(), options));
RPCメソッドを呼び出す

*public class SampleData*{// 割愛public static SampleData FromRpcModel(Sample rpcModel) {}}
アプリケーションロジックから使用するモデルクラス

*public static SampleData FromRpcModel(Sample rpcModel) {}
割愛

*public Request ToRpcModel() {}
割愛


*string sql = $@"
「@」をつけると逐語的文字列リテラルとなります。
文字列内ではエスケープシーケンスが不要になり、改行も可能になります。
また、C#6.0からは「$」による文字列埋め込みが使えます。
（SQLインジェクション対策としては、生の文字列埋め込みではなくDBパラメータの利用が推奨です。）
$@が正解ですが、@$とするとコンパイルエラーを起こすので注意。


*value = Math.Ceilng(value);
切り上げ

*value = Math.Floor(value2);
切り下げ
Floor: -3、Truncate: -2

*value = Math.Round(value, MidpointRounding.AwayFromZero);
四捨五入
MidpointRounding.AwayFromZeroを指定しないと結果は2となる


*hogeInstance.Command.Execute(1);
これだと引数は1


*//targetObjが動く場合はtargetObj.transform.positionで直接取得*tmpVec = Vector3.MoveTowards(tmpVec, targetObj.transform.position, speed);
~省略

*tmpVec = Vector3.MoveTowards(tmpVec, targetObj.transform.position, speed);*this.gameObject.transform.position = tmpVec;
targetObjが動く場合はtargetObj.transform.positionで直接取得


*using System;
Needed for Math


*Note = Instantiate(Don, SpawnPoint.position, Quaternion.identity);
default don

*Note.GetComponent<NoteController>().setParameter(type, timing);
setParameter関数を発火

*void play() {PlayTime = Time.time * 1000;isPlaying = true;Debug.Log("Game Start!");}
ゲーム開始時に追加した変数に値をセット

*Distance = Math.Abs(BeatPoint.position.x - SpawnPoint.position.x);
追加した変数に値をセット

*void play() {PlayTime = Time.time * 1000;isPlaying = true;Debug.Log("Game Start!");}
ゲーム開始時に追加した変数に値をセット

*this.UpdateAsObservable()
ノーツを発射するタイミングかチェックし、go関数を発火


*public interface enum ITask<TState> where TState : Enum*{TState State {get;set;}}
様々な処理タスクのインターフェイス

*public class EncodeTask : ITask<EncodeState>*{}


*public enum EncodeState*{Queued = 0,Downloading = 1,Encoding = 2,Uploading = 3,// 必要な処理を書いていく}
処理の状態を定義するEnum

*}
必要な処理を書いていく


*private void AddModule<T>(string regionName) where T : UserControl*{var name = typeof(T).Name;// 重複チェック対策var viewTarget = _regionManager.Regions[regionName].Views.FirstOrDefault(x => x.GetType().Name == name);if (viewTarget == null){var view = _container.Resolve<T>();_regionManager.Regions[regionName].Add(view, name);}}
指定リージョンにモジュールを追加

*var viewTarget = _regionManager.Regions[regionName].Views.FirstOrDefault(x => x.GetType().Name == name);
重複チェック対策

*private void RemoveModule<T>(string regionName) where T : UserControl*{var viewToRemove = _regionManager.Regions[regionName].Views.FirstOrDefault(x => x.GetType().Name == typeof(T).Name);if (viewToRemove != null)_regionManager.Regions[regionName].Remove(viewToRemove);}
指定リージョンからモジュールを削除


*System.Console.WriteLine("和集合(Union)：" + string.Join(",", list1.Union(list2)));
和集合（重複データは除かれる）

*System.Console.WriteLine("和集合(Concat)：" + string.Join(",", list1.Concat(list2)));
和集合（重複データも含まれる）

*System.Console.WriteLine("積集合(Intersect)：" + string.Join(",", list1.Intersect(list2)));
積集合

*System.Console.WriteLine("差集合(Except)[list1-list2]：" + string.Join(",", list1.Except(list2)));
差集合

*System.Console.WriteLine("和集合＋昇順：" + string.Join(",", list1.Union(list2).OrderBy(cityName=>cityName)));
和集合（重複データは除かれる）を求めた後、文字列の昇順にソートする。

*System.Console.WriteLine("和集合＋降順：" + string.Join(",", list1.Union(list2).OrderByDescending(cityName => cityName)));
和集合（重複データは除かれる）を求めた後、文字列の降順にソートする。


*public Text scoreText;
取得した手のトラッキングデータをUIに表示

*Hand rightHand = null;
右手と左手を取得する


*trackingPos = transform.rotation * trackingPos;*// 固定したい位置から hmd の位置を.
回転.

*transform.position = Vector3.Lerp(transform.position,offset.position - trackingPos, 0.05f);
固定したい位置から hmd の位置を.
差し引いて実質 hmd の移動を無効化する.


*var readResult = await pr.ReadAsync();
同期版はpr.TryRead(out var readResult)

*}
読出し

*}
終了処理

*pr.AdvanceTo(readResult.Buffer.End);
これをしないと次回のReadで例外

*void WriteData(PipeWriter pw, ReadOnlySpan<byte> rsp)
async内ではSpanが使用できないため別関数にする
将来的にはこの制限が緩和される可能性あり

*await pw.FlushAsync();
実行時点でPipeReaderにデータが流れるようになる


*IntPtr hWnd;
自ウィンドウのハンドルをここに取得したい

*hWnd = FindWindow(null, Application.productName);
Player設定で入れた Product Name がタイトルになる


*var userData = new UserData() { name = "HOGE", age = 20 };
保存データクラスをインスタンス化

*string json = JsonUtility.ToJson(userData);
クラスをJSON文字列に変換

*byte[] arr = System.Text.Encoding.UTF8.GetBytes(json);
byte配列に変換

*AesEncryptSample(arr);
AES暗号化サンプル処理

*XorEncrypt(arr);
XOR暗号化サンプル処理

*===================================int aesKeySize = 128;
AES設定値

*byte[] arrEncrypted = AesEncrypt(arr, aesKeySize, aesBlockSize, aesIv, aesKey);
AES暗号化

*string path = System.IO.Path.Combine(Application.temporaryCachePath, "UserDataAES");
ファイル書き込み

*byte[] arrRead = System.IO.File.ReadAllBytes(path);
ファイル読み込み

*byte[] arrDecrypt = AesDecrypt(arrRead, aesKeySize, aesBlockSize, aesIv, aesKey);
復号化

*string decryptStr = System.Text.Encoding.UTF8.GetString(arrDecrypt);
byte配列を文字列に変換

*string keyString = "123456789";
暗号化文字列

*string path = System.IO.Path.Combine(Application.temporaryCachePath, "UserDataXOR");
ファイル書き込み

*byte[] arrRead = System.IO.File.ReadAllBytes(path);
ファイル読み込み

*string decryptStr = System.Text.Encoding.UTF8.GetString(arrDecrypt);
byte配列を文字列に変換

*var aes = GetAesManager(aesKeySize, aesBlockSize, aesIv, aesKey);
AESマネージャー取得

*byte[] encryptText = aes.CreateEncryptor().TransformFinalBlock(byteText, 0, byteText.Length);*return encryptText;
暗号化

*var aes = GetAesManager(aesKeySize, aesBlockSize, aesIv, aesKey);
AESマネージャー取得

*byte[] decryptText = aes.CreateDecryptor().TransformFinalBlock(byteText, 0, byteText.Length);*return decryptText;
復号化


*void Start()*{Mat mat = Unity.TextureToMat(this.texture);Mat changedMat = new Mat();Cv2.CvtColor(mat, changedMat,ColorConversionCodes.BGR2RGB );Texture2D changedTex = Unity.MatToTexture(changedMat);GetComponent<RawImage>().texture = changedTex;}
Use this for initialization

*void Update()*{}
Update is called once per frame

*void Start()*{Mat mat = Unity.TextureToMat(this.texture);for(int yi = 0; yi < mat.Height; yi++){for(int xi = 0; xi < mat.Width; xi++){Vec3b v = mat.At<Vec3b>(yi,xi);float gr = 0.2126f * v[2] + 0.7152f * v[1] + 0.0722f * v[0];v[0] = (byte)gr;v[1] = (byte)gr;v[2] = (byte)gr;mat.Set<Vec3b>(yi, xi, v);}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<RawImage>().texture = changedTex;}
Use this for initialization

*void Update()*{}
Update is called once per frame

*void Start()*{Mat mat = Unity.TextureToMat(this.texture);for (int yi = 0; yi < mat.Height; yi++){for (int xi = 0; xi < mat.Width; xi++){Vec3b v = mat.At<Vec3b>(yi, xi);Debug.Log(v[0]);float gr = 0.2126f * v[2] + 0.7152f * v[1] + 0.0722f * v[0];if(gr < 128){gr = 0;}else{gr = 255;}v[0] = (byte)gr;v[1] = (byte)gr;v[2] = (byte)gr;mat.Set<Vec3b>(yi, xi, v);}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<RawImage>().texture = changedTex;}
Use this for initialization

*void Update()*{}
Update is called once per frame

*void Start()*{Mat mat = Unity.TextureToMat(this.texture);float[] results = new float[256];float[,] grs = new float[mat.Height,mat.Width];for(int yi = 0; yi < mat.Height; yi++){for(int xi = 0; xi < mat.Width; xi++){Vec3b v = mat.At<Vec3b>(yi, xi);float gr = 0.2126f * v[2] + 0.7152f * v[1] + 0.0722f * v[0];grs[yi, xi] = gr;}}for(int thi = 1; thi < 255; thi++){int w0 = 0;int w1 = 0;float M0 = 0;float M1 = 0;foreach(float gr in grs){if(gr < thi){w0++;M0 += gr;}else{w1++;M1 += gr;}}Debug.Log(w0 + w1);float tmp0 = w0 == 0 ? 0 : M0 / w0;float tmp1 = w1 == 0 ? 0 : M1 / w1;results[thi] = ((float)w0 / (mat.Height * mat.Width)) * ((float)w1 / (mat.Height * mat.Width)) * Mathf.Pow(tmp0 - tmp1 , 2);}int z = 0;for(int i = 1; i < 255; i++){if (results[i] > results[z]) z = i;}for(int yi = 0; yi < mat.Height; yi++){for(int xi = 0; xi < mat.Width; xi++){if(grs[yi,xi] < z){Vec3b v = new Vec3b();v[0] = (byte)0;v[1] = (byte)0;v[2] = (byte)0;mat.Set<Vec3b>(yi, xi, v);}else{Vec3b v = new Vec3b();v[0] = (byte)255; v[1] = (byte)255; v[2] = (byte)255;mat.Set<Vec3b>(yi, xi, v);}}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<RawImage>().texture = changedTex;}
Use this for initialization

*void Update()*{}
Update is called once per frame

*void Start()*{Mat mat = Unity.TextureToMat(this.texture);Mat changedMat = new Mat();Mat changedMat1 = new Mat();Cv2.CvtColor(mat, changedMat, ColorConversionCodes.BGR2HSV);for(int yi = 0; yi < mat.Height; yi++){for(int xi = 0; xi < mat.Width; xi++){Vec3b v = changedMat.At<Vec3b>(yi, xi);Debug.Log(v[0]);v[0] = (byte)((v[0] - 180) % 360);changedMat.Set<Vec3b>(yi, xi, v);}}Cv2.CvtColor(changedMat,changedMat1, ColorConversionCodes.HSV2BGR);Texture2D changedTex = Unity.MatToTexture(changedMat1);GetComponent<RawImage>().texture = changedTex;}
Use this for initialization

*void Update()*{}
Update is called once per frame

*void Start()*{Mat mat = Unity.TextureToMat(this.texture);for (int yi = 0; yi < mat.Height; yi++){for (int xi = 0; xi < mat.Width; xi++){Vec3b v = mat.At<Vec3b>(yi, xi);v[0] = (byte)(ReduceColor(v[0]));v[1] = (byte)(ReduceColor(v[1]));v[2] = (byte)(ReduceColor(v[2]));mat.Set<Vec3b>(yi, xi, v);}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<RawImage>().texture = changedTex;}
Use this for initialization

*void Update()*{}
Update is called once per frame

*void Start()*{Mat mat = Unity.TextureToMat(this.texture);for(int yi = 0; yi < 16; yi++){for(int xi = 0; xi < 16; xi++){Vector3 sum = new Vector3();for(int yj = 0; yj < 8; yj++){for(int xj = 0; xj < 8; xj++){Vec3b v = mat.At<Vec3b>(yi * 8 + yj,xi * 8 + xj);sum[0] += v[0];sum[1] += v[1];sum[2] += v[2];}}Vec3b ave = new Vec3b();ave[0] = (byte)(sum[0] / 64);ave[1] = (byte)(sum[1] / 64);ave[2] = (byte)(sum[2] / 64);for (int yj = 0; yj < 8; yj++){for (int xj = 0; xj < 8; xj++){mat.Set<Vec3b>(yi * 8 + yj, xi * 8 + xj, ave);}}}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<RawImage>().texture = changedTex;}
Use this for initialization

*void Update()*{}
Update is called once per frame

*void Start()*{Mat mat = Unity.TextureToMat(this.texture);for (int yi = 0; yi < 16; yi++){for (int xi = 0; xi < 16; xi++){Vec3b max = new Vec3b();for (int yj = 0; yj < 8; yj++){for (int xj = 0; xj < 8; xj++){Vec3b v = mat.At<Vec3b>(yi * 8 + yj, xi * 8 + xj);if (max[0] < v[0]) max[0] = v[0];if (max[1] < v[1]) max[1] = v[1];if (max[2] < v[2]) max[2] = v[2];}}for (int yj = 0; yj < 8; yj++){for (int xj = 0; xj < 8; xj++){mat.Set<Vec3b>(yi * 8 + yj, xi * 8 + xj, max);}}}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<RawImage>().texture = changedTex;}
Use this for initialization

*void Update()*{}
Update is called once per frame

*void Start()*{Mat mat = Unity.TextureToMat(this.texture);Vector3[,] v = new Vector3[mat.Height, mat.Width];for (int yi = 0; yi < mat.Height; yi++){for (int xi = 0; xi < mat.Width; xi++){Vec3b vyx = mat.At<Vec3b>(yi, xi);v[yi, xi][0] = vyx[0];v[yi, xi][1] = vyx[1];v[yi, xi][2] = vyx[2];}}v = Gaussian(v, mat.Height, mat.Width);for(int yi = 0; yi < mat.Height; yi++){for(int xi = 0; xi < mat.Width; xi++){Vec3b vyx = new Vec3b();vyx[0] = (byte)v[yi, xi][0];vyx[1] = (byte)v[yi, xi][1];vyx[2] = (byte)v[yi, xi][2];mat.Set<Vec3b>(yi, xi, vyx);}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<RawImage>().texture = changedTex;}
Use this for initialization

*void Update()*{}
Update is called once per frame

*void Start()*{Mat mat = Unity.TextureToMat(this.texture);Mat changedMat = new Mat();Cv2.GaussianBlur(mat, changedMat, new Size(3,3),1.3,1.3);Texture2D changedTex = Unity.MatToTexture(changedMat);GetComponent<RawImage>().texture = changedTex;}
Use this for initialization

*void Update()*{}
Update is called once per frame

*void Start()*{Mat mat = Unity.TextureToMat(this.texture);Vector3[,] v = new Vector3[mat.Height, mat.Width];for (int yi = 0; yi < mat.Height; yi++){for (int xi = 0; xi < mat.Width; xi++){Vec3b vyx = mat.At<Vec3b>(yi, xi);v[yi, xi][0] = vyx[0];v[yi, xi][1] = vyx[1];v[yi, xi][2] = vyx[2];}}v = Median(v, mat.Height, mat.Width);for (int yi = 0; yi < mat.Height; yi++){for (int xi = 0; xi < mat.Width; xi++){Vec3b vyx = new Vec3b();vyx[0] = (byte)v[yi, xi][0];vyx[1] = (byte)v[yi, xi][1];vyx[2] = (byte)v[yi, xi][2];mat.Set<Vec3b>(yi, xi, vyx);}}Texture2D changedTex = Unity.MatToTexture(mat);GetComponent<RawImage>().texture = changedTex;}
Use this for initialization

*void Update()*{}
Update is called once per frame

*void Start()*{Mat mat = Unity.TextureToMat(this.texture);Mat changedMat = new Mat();Cv2.MedianBlur(mat, changedMat, 3);Texture2D changedTex = Unity.MatToTexture(changedMat);GetComponent<RawImage>().texture = changedTex;}
Use this for initialization

*void Update()*{}
Update is called once per frame


*var duplicates = list.GroupBy(name => name).Where(name => name.Count() > 1)
要素名でGroupByした後、グループ内の件数が2以上（※重複あり）に絞り込み、
最後にIGrouping.Keyからグループ化に使ったキーを抽出している。

*List<string> cityNames = new List<string>() {"Tokyo", "Osaka", "Yokohama", "Nagoya", "Kobe","Tokyo", "Yokohama", "Sapporo", "Fukuoka", "Tokyo"};
"Tokyo"と"Yokohama"が重複しているリスト


*DateTime gantan = new DateTime(targetYear, 1, 1);
対象年の1月1日(元旦)の曜日を取得する。

*DateTime date;
対象年の1月において、引数で指定した曜日に該当する最初の日付を取得する

*List<DateTime> days = new List<DateTime>();
7日ずつ日付をずらして、対象年における指定した曜日の日付を全て取得する。

*var days = DateUtils.FindWantDayOfWeek(2019, DayOfWeek.Sunday);
2019年の日曜日の日付を取得する。


*var profile = new Dictionary<string, string>() {{"name", "お名前"},{"age", "３０歳"},{"address", "日本"},{"blood", "AB型"},};
サンプルデータ

*var profile = new Dictionary<string, string>() {{"name", "お名前"},{"age", "２０歳"},{"address", "日本"},{"blood", "AB型"},};
サンプルデータ

*var profile = new Dictionary<string, string>() {{"name", "お名前"},{"age", "２０歳"},{"address", "日本"},{"blood", "AB型"},};
サンプルデータ


*DataRow[] rows =member.AsEnumerable().Where(x => (int)x["Age"] > 10)
rowsで結果を取得

*DataTable dataTable =member.AsEnumerable().Where(x => (int)x["Age"] > 10)
dataTableで結果を取得


*il.Emit(Ret);
スタックにはJobHandleのみが残っているのでこれを返り値とする


*var j = new KeyValuePair<BlendShapePreset, float>(BlendShapePreset.Joy,1);
喜

*var a = new KeyValuePair<BlendShapePreset, float>(BlendShapePreset.Angry,1);
怒

*var s = new KeyValuePair<BlendShapePreset, float>(BlendShapePreset.Sorrow,1);
哀

*var f = new KeyValuePair<BlendShapePreset, float>(BlendShapePreset.Fun,1);
楽


*var ctr500milli = new TimeSpan(0, 0, 0, 0, 500);
コンストラクタで生成 => 読み辛い。「この男、素人か。」と思う。

*var fromMilli500 = TimeSpan.FromMilliseconds(500);
FromMilliSecondで生成 => 定石

*var ext500Milli = 500.Milliseconds();
拡張メソッドを定義して以下のように書く。

*await Task.Delay(3.5.Seconds());
3.5秒待つ場合は以下のような感じ


*double a = r * r * Math.PI;
円周率=Math.PI


*var nameProperty = attribute.ResourceType.GetProperty(attribute.Name,BindingFlags.Static | BindingFlags.Public);
Display属性が定義してある場合、リソースの値を返す

*return value.ToString();
Display属性が定義していなかった場合、Enumの名称を返す


*Assert.IsTrue(s2AsObj.Equals(s1));
Object 型のメソッド呼び出しでもオーバーライドされた Equals メソッドが使用されます。

*Assert.IsFalse(Object.ReferenceEquals("s", s1));
リテラルから生成されていない値とは一致しません。

*Assert.IsTrue(sb1AsStr.Equals(sb1.ToString()));
文字列同士なら一致します。

*Assert.IsTrue(Object.Equals(sb1, sb1Assigned));
代入された同一インスタンスとは一致します。


*Console.WriteLine(enumerator2.Current);
このCurrentは一番目の要素を指すべき


*if (Input.GetKeyDown(KeyCode.Return)) StartMove();*if (Input.GetKeyDown(KeyCode.Space)) StartReturn();
Test


*private static Dictionary<Filter, string> Filters = new Dictionary<Filter, string>*{{Filter.All, "all"},{Filter.Closed, "closed"},{Filter.Members, "members"},{Filter.Open, "open"},{Filter.Organization, "organization"},{Filter.Public, "public"},{Filter.Starred, "starred"},};
Enumを作るごとにこれをコピペして中身を書き換えるのは大変


*var list = titles.Select(title => new { Name = title, Index = ToInt(title) })
{Name,Index}という匿名クラスのリストを作り、Indexに従ってソートする。


*var array = Enumerable.Repeat("あいうえお",10).ToArray();
要素数が10で、値が「あいうえお」の配列を生成する

*var list = Enumerable.Repeat("あいうえお",10).ToList();
要素数が10で、値が「あいうえお」のリストを生成する

*var array = Enumerable.Range(5, 7).ToArray();
5から始まり、7個の連続した値（5,6,7,8,9,10,11）の配列を生成する。

*var list = Enumerable.Range(5, 7).ToList();
5から始まり、7個の連続した値（5,6,7,8,9,10,11）のリストを生成する。

*var txt = string.Join(",", Enumerable.Range(1, 10).Select(num => num.ToString() + "番目"));
「1番目,2番目,...10番目」という文字列を作成する。


*void OnProcessingDone()*{print("保存開始");}
保存開始時

*void OnFileSaveProgress(int id, float percent)*{print("保存中:" + Math.Truncate(percent * 100.0) + "/" + "100％");}
保存中　idという引数はよくわからん

*void OnFileSaved(int id, string filepath)*{print("保存完了:" + "100" + "/" + "100％" + filepath);isSave = false;}
保存終了時　idという引数はよくわからん

*IEnumerator RecCountDown()*{isRec = true;float second = 1f;int count = 0;//録画カウントダウンprint("録画開始まで");yield return new WaitForSeconds(second);print("3");yield return new WaitForSeconds(second);print("2");yield return new WaitForSeconds(second);print("1");yield return new WaitForSeconds(second);print("開始");rec.Record();//残り秒数の表示for (int i = 0; i < rec.ReturnBufferSize(); i++){yield return new WaitForSeconds(second);count++;print("録画時間" + ":" + count + "/" + rec.ReturnBufferSize()+"秒");}//録画終了print("録画終了");//保存開始rec.Save();yield return new WaitForSeconds(second);isRec = false;StopCoroutine(runCoroutine);}
録画開始～終了まで

*print("録画開始まで");
録画カウントダウン

*print("録画終了");
録画終了

*rec.Save();
保存開始


*await SendRequest(httpClient, log, "https:
httpstat.us429");

*log.LogInformation("finish func");*}
await SendRequest(httpClient, log, "https:httpstat.us/200?sleep=11000");


*Console.Write($"{result, 2}");
resultを最低二桁で表示


*var num = 0;
「定義済のint型変数の値をインクリメントする」だけの処理をAction型変数に代入する

*Action action1 = delegate () { num++; };
1．delegateキーワードを使った古典的な書き方

*var action2 = new Action(delegate () { num++; });
2. var を使った書き方

*Action action3 = () => num++;
3. ラムダ式で書く

*var action4 = new Action(() => num++);
4. var を使った書き方

*// 1．delegateキーワードを使った古典的な書き方*Action<int> action5 = delegate (int num) { num++; };
例として「int型の引数の値をインクリメントする」だけの処理をAction<int>型変数に代入する

*Action<int> action5 = delegate (int num) { num++; };
1．delegateキーワードを使った古典的な書き方

*var action6 = new Action<int>(delegate (int num) { num++; });
2. var を使った書き方

*Action<int> action7 = num => num++;
3. ラムダ式で書く

*var action8 = new Action<int>(num => num++);
4. var を使った書き方


*ComplexObjectResponse response = new ComplexObjectResponse() { };
レスポンスのインスタンスは使いまわす

*Dictionary<string, int> indexes = new Dictionary<string, int>();
オブジェクトのキーとインデックスの組み合わせ

*yield return new ComplexHeader() { Id = "1", Description = "オブジェクト1" };
実際にはデータベースなどからデータを取得して返すような実装になります。

*string createdDate = DateTime.Now.ToString();*yield return new ComplexItem() { Id = "1", CreatedDate = createdDate, Value = 1001 };
実際にはデータベースなどからデータを取得して返すような実装になります。

*yield return new ComplexSubItem() { Id = "1", Value = "サブアイテム1-1" };
実際にはデータベースなどからデータを取得して返すような実装になります。

*List<ComplexObject> objects = new List<ComplexObject>();
取得したオブジェクトを格納するリスト


*if (list.Count == 0
つまり値の変化が無かった


*ilgen.Emit(OpCodes.Ret);
戻り値とせよ


*ProtectedString secret = LoadEncryptedGuestIssuerSecret();
暗号化されたGuest Issuer secretをストレージから読み込む。

*var guestIssuer = TeamsAPI.CreateVersion1GuestIssuerClient(secret, "your_guest_issuer_id");
GuestIssuerClientのインスタンスを作成する。

*var guest = (await guestIssuer.CreateGuestUserAsync("my-guest-id", "ゲスト太郎")).GetData();
Guest Userを作成する。

*var teams = TeamsAPI.CreateVersion1Client(guest, new TeamsRetryHandler(4));
ゲストユーザ用のTeamsAPIClientインスタンスを作成する(リトライ機能付き)。

*var message = (await teams.CreateMessageAsync("space_id_to_post", "こんにちは、私はゲストユーザです！！")).GetData();*Console.WriteLine("メッセージが投稿されました: ID = {0}", message.Id);
ゲストユーザからメッセージを投稿する。


*public virtual DbSet<BUSHO> BUSHOs { get; set; }
Table

*modelBuilder.Conventions.Remove<System.Data.Entity.ModelConfiguration.Conventions.PluralizingTableNameConvention>();
テーブル名を複数形化せずモデルクラス名をそのまま使う


*public void Execute()*{if (!string.IsNullOrEmpty(ArgSerialized) && !string.IsNullOrEmpty(ArgType)){DeserializeFromString();}if (MethodArgument != null){TargetObject.SendMessage(CallbackName, MethodArgument);}else{TargetObject.SendMessage(CallbackName);}}
実行時MethodArgumentをデシリアライズ

*void DeserializeFromString()*{if (string.IsNullOrEmpty(ArgSerialized) || string.IsNullOrEmpty(ArgType)){return;}//System.TypeとUnityEngine.Typeのデシリアライズvar type = System.Type.GetType(ArgType);if (type == null)type = System.Reflection.Assembly.Load("UnityEngine.dll").GetType(ArgType);if (type == typeof(string))MethodArgument = ArgSerialized;if (type == typeof(bool))MethodArgument = bool.Parse(ArgSerialized);else if (type == typeof(int))MethodArgument = int.Parse(ArgSerialized);else if (type == typeof(float))MethodArgument = float.Parse(ArgSerialized);else if (type == typeof(double))MethodArgument = double.Parse(ArgSerialized);else if (type == typeof(Vector2))MethodArgument = Vector2FromString(ArgSerialized);else if (type == typeof(Vector3))MethodArgument = Vector3FromString(ArgSerialized);else if (type == typeof(Vector4))MethodArgument = Vector4FromString(ArgSerialized);}
デシリアライズ処理

*var type = System.Type.GetType(ArgType);
System.TypeとUnityEngine.Typeのデシリアライズ

*MethodList.ForEach(item => item.Execute());
呼び出し　これは好きなタイミングで呼ぶ

*public void Test(string t)*{Debug.Log("Test Log : " + t);}
テスト用メソッド群

*var ListProp = serializedObject.FindProperty("MethodList");
ReorderableList作成

*int NameIndex = methods.FindIndex(item => item == m.CallbackName);
メソッド名のインデックスを取得(見つからなかったらNoneである0にする)

*List<string> CollectMethods(SelectMethod m)*{if (m == null || !m.TargetObject){return null;}List<string> result = new List<string>();result.Add("None");var methods = m.TargetObject.GetType().GetMethods(BindingFlags.Instance | BindingFlags.Public).Where(x => x.DeclaringType == m.TargetObject.GetType()).Where(x => x.GetParameters().Length <= 1).Select(x => x.Name).ToArray();result.AddRange(methods);return result;}
メソッドの取得(SendMessageを使うので引数が1以下かつpublicに限定)


*Matcher Number = '1'.To('9') + '0'.To('9')._0Max();
優先度１

整数値

*Matcher Alphabet = ('A'.To('Z') | 'a'.To('z'));
アルファベット

*Matcher Identifier = (Alphabet | '_') + (Alphabet | '0'.To('9') | '_')._0Max();*// 「リテラル値式」のマッチャーを作る。(但し中身は空っぽ)
識別子

*RecursionMatcher LiteralExp = new RecursionMatcher();
「リテラル値式」のマッチャーを作る。(但し中身は空っぽ)

*RecursionMatcher ParenExp = new RecursionMatcher();
「括弧式」のマッチャーを作る。(但し中身は空っぽ)

*RecursionMatcher AssignableExp = new RecursionMatcher();
「代入可能式」のマッチャーを作る。(但し中身は空っぽ)

*RecursionMatcher FunctionCallExp = new RecursionMatcher();
「関数呼び出し式」のマッチャーを作る。(但し中身は空っぽ)

*RecursionMatcher MemberAccessExp = new RecursionMatcher();
「メンバアクセス式」のマッチャーを作る。(但し中身は空っぽ)

*RecursionMatcher IndexAccessExp = new RecursionMatcher();
「インデックスアクセス式」のマッチャーを作る。(但し中身は空っぽ)

*Matcher PostDecrementExp = AssignableExp + "--";
「後置デクリメント」のマッチャーを作る。(但し中身は空っぽ)

*Matcher PostIncrementExp = AssignableExp + "++";
「後置インクリメント」のマッチャーを作る。(但し中身は空っぽ)

*Matcher Priority1Exp = LiteralExp | Identifier | ParenExp | AssignableExp |*FunctionCallExp | IndexAccessExp | MemberAccessExp | PostDecrementExp | PostIncrementExp ;
優先順位１式

*Matcher PreDecrementExp = "--" + AssignableExp;
優先度２

「前置デクリメント」のマッチャーを作る。(但し中身は空っぽ)

*Matcher PreIncrementExp = "++" + AssignableExp;
「前置インクリメント」のマッチャーを作る。(但し中身は空っぽ)

*RecursionMatcher PreMinusExp = new RecursionMatcher();
「前置マイナス」のマッチャーを作る。(但し中身は空っぽ)

*RecursionMatcher PrePlusExp = new RecursionMatcher();
「前置プラス」のマッチャーを作る。(但し中身は空っぽ)

*Matcher Priority2Exp = PreDecrementExp | PreIncrementExp | PreMinusExp | PrePlusExp ;
優先順位２式

*Matcher PriorityAbove2Exp = Priority1Exp | Priority2Exp ;
優先順位２以上式

*RecursionMatcher MulDivExp = new RecursionMatcher();
優先度３

「乗除算式」のマッチャーを作る。(但し中身は空っぽ)

*Matcher Priority3Exp = MulDivExp ;
優先順位３式

*Matcher PriorityAbove3Exp = PriorityAbove2Exp | Priority3Exp ;
優先順位３以上式

*RecursionMatcher AddSubExp = new RecursionMatcher();
優先度４

「加減算式」のマッチャーを作る。(但し中身は空っぽ)

*Matcher Priority4Exp = AddSubExp ;
優先順位４式

*Matcher PriorityAbove4Exp = PriorityAbove3Exp | Priority4Exp ;
優先順位４式

*Matcher Exp = PriorityAbove4Exp;
(優先順位の低い演算子を増やしたい場合はここに挿入する。)

式の全て

*Matcher AssignStatement = AssignableExp + '=' + Exp;
優先度９９９

代入演算文

*ParenExp.Inner = '(' +
以下、中身が未設定なマッチャーの中身を設定

括弧式の中身

*LiteralExp | Identifier | ParenExp | FunctionCallExp |*IndexAccessExp | MemberAccessExp | PostDecrementExp | PostIncrementExp |
代入可能式を除く優先順位１式

*Priority2Exp | Priority3Exp | Priority4Exp
優先順位２以下の全ての式

*AssignableExp.Inner = Identifier | MemberAccessExp | IndexAccessExp | ( '(' + AssignableExp + ')' );*// 関数呼び出し式の中身
代入可能式の中身

*FunctionCallExp.Inner = (FunctionCallExp | IndexAccessExp | AssignableExp) + '(' + Exp._0Max(',') + ')';
関数呼び出し式の中身

*IndexAccessExp.Inner = (FunctionCallExp | IndexAccessExp | AssignableExp) + '[' + Exp._1Max(',') + ']';
インデックスアクセス式の中身

*MemberAccessExp.Inner = Priority1Exp + '.' + Identifier;*// 前置マイナス式の中身
メンバアクセス式の中身

*PreMinusExp.Inner = '-' + (Priority1Exp | PreDecrementExp | PreIncrementExp | PrePlusExp);
前置マイナス式の中身

*PrePlusExp.Inner = '+' + (Priority1Exp | PreDecrementExp | PreIncrementExp | PreMinusExp);
前置プラス式の中身

*MulDivExp.Inner =  PriorityAbove3Exp + ('*'._() | '/') + PriorityAbove2Exp;
乗除算式の中身

*AddSubExp.Inner =  PriorityAbove4Exp + ('+'._() | '-') + PriorityAbove3Exp;
加減算式の中身


*Bitmap grayBmp = new Bitmap(width, height);
グレースケールの画像。

*Color pixelColor = bmp.GetPixel(i, j);
NTSC規格などに準拠せず、RGB値の平均値をグレースケールに変える。
https:dobon.net/vb/dotnet/graphics/grayscale.html

*Color grayColor = Color.FromArgb(pixelColor.A, grayScale, grayScale, grayScale);
RGBだけでなく、アルファ値もセットする。


*if (rootFrame == null)
ウィンドウに既にコンテンツが表示されている場合は、アプリケーションの初期化を繰り返さずに、
ウィンドウがアクティブであることだけを確認してください

*rootFrame = new Frame();
ナビゲーション コンテキストとして動作するフレームを作成し、最初のページに移動します

*Xamarin.Forms.Forms.Init(e);
これを追加

*LoadApplication(new TakeMeThereXamarinForms.App(new UwpInitializer()));
追加

*namespace TakeMeThereXamarinForms.UWP*{/// <summary>/// それ自体で使用できる空白ページまたはフレーム内に移動できる空白ページ。/// </summary>public sealed partial class MainPage{public MainPage(){this.InitializeComponent();LoadApplication(new TakeMeThereXamarinForms.App(new UwpInitializer()));}}public class UwpInitializer : IPlatformInitializer{public void RegisterTypes(IContainerRegistry containerRegistry){// Register any platform specific implementations}}}
空白ページの項目テンプレートについては、https:go.microsoft.com/fwlink/?LinkId=402352&clcid=0x411 を参照してください


*case string str:
when obj is string

*do*{piyopiyo} while(statement);
do while template


*Assert.IsFalse(float.NaN.Equals(double.NaN));
float ← double は暗黙の型変換不可

*private enum ZeroUndefined*{One = 1,Two}
列挙型定義

*private ZeroUndefined zeroUndefinedUnassigned;
フィールド

*public void EnumUndefinedMember()*{// 0 はメンバとして定義されていません。Assert.IsFalse(Enum.IsDefined(typeof(ZeroUndefined), 0));// ★既定値はメンバの定義がなくても 0 です。 default(T) もフィールドも同様です。Assert.AreEqual((ZeroUndefined)0, default(ZeroUndefined));Assert.AreEqual((ZeroUndefined)0, this.zeroUndefinedUnassigned);// ★リテラルや定数の 0 は特別に列挙型への暗黙変換が許可されているため、キャストなしで代入できます。ZeroUndefined undefinedZero = 0;/* int 型変数の代入はコンパイルエラーになります。int zero = 0;ZeroUndefined undefinedZero = zero;*/// 0 はどのメンバとも一致しません。foreach (ZeroUndefined each in Enum.GetValues(typeof(ZeroUndefined))){Assert.IsTrue(undefinedZero != each);}// int にキャストすると 0 になります。Assert.IsTrue((int)undefinedZero == 0);// 0 をキャストしたものと一致します。Assert.IsTrue(undefinedZero == (ZeroUndefined)0);// ★リテラルや定数の 0 は特別に列挙型への暗黙変換が許可されているため、キャストなしで等価比較できます。Assert.IsTrue(undefinedZero == 0);Assert.IsTrue(0 == undefinedZero);// ★int 型との Equals 比較は false になります。Assert.IsFalse(undefinedZero.Equals(0));Assert.IsFalse(0.Equals(undefinedZero));// 最大定義値を超える場合も数値は保持されます。ZeroUndefined maxValue = (ZeroUndefined)int.MaxValue;Assert.IsTrue(maxValue == (ZeroUndefined)int.MaxValue);Assert.IsTrue((int)maxValue == int.MaxValue);}
検証

*Assert.IsFalse(Enum.IsDefined(typeof(ZeroUndefined), 0));
0 はメンバとして定義されていません。

*Assert.AreEqual((ZeroUndefined)0, default(ZeroUndefined));
★既定値はメンバの定義がなくても 0 です。 default(T) もフィールドも同様です。

*ZeroUndefined undefinedZero = 0;
★リテラルや定数の 0 は特別に列挙型への暗黙変換が許可されているため、キャストなしで代入できます。

*Assert.IsTrue((int)undefinedZero == 0);
int にキャストすると 0 になります。

*Assert.IsTrue(undefinedZero == (ZeroUndefined)0);
0 をキャストしたものと一致します。

*Assert.IsTrue(undefinedZero == 0);
★リテラルや定数の 0 は特別に列挙型への暗黙変換が許可されているため、キャストなしで等価比較できます。

*Assert.IsFalse(undefinedZero.Equals(0));
★int 型との Equals 比較は false になります。

*ZeroUndefined maxValue = (ZeroUndefined)int.MaxValue;
最大定義値を超える場合も数値は保持されます。


*[HttpGet("sample
{segments}")] *つけ忘れ

*string postfix = segmentsArray[segmentsArray.Length - 1];
最後の一つで条件分岐


*Thread.Sleep(100);
Task.Delay(100);Delayが使えればDelayが良いな･･･。


*)
（省略）

*services.AddSingleton(typeof(IStartup), sp =>*{var hostingEnvironment = sp.GetRequiredService<IHostingEnvironment>();return new ConventionBasedStartup(StartupLoader.LoadMethods(sp, startupType, hostingEnvironment.EnvironmentName));});
(省略)

*});
(省略)

*services.AddSingleton<IHostingEnvironment>(_hostingEnvironment);
（省略）

*var configuration = builder.Build();
（省略）

*,,,
（省略）


*Console.WriteLine(Enumerable.Range(x[0], x[1] - x[0] + 1).Count(q => x[2] % q == 0));
int[] x = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();でもよい


*driver.FindElement(By.XPath("
input[@value='登録']")).Submit();


*Duck duck = new Duck(new SmallQuack());
通常のアヒルを生成

*Duck redHead = new RedHeadDuck(new Quack());
アメリカホシハジロを生成

*Duck rubber = new RubberDuck(new Squeak());
ゴムのアヒルを生成

*Duck decoy = new DecoyDuck(new MuteQuack());
偽物のアヒルを生成

*duck.quack();
アヒルの鳴き声

*redHead.quack();
アメリカホシハジロの鳴き声

*rubber.quack();
ゴムのアヒルの鳴き声

*decoy.quack();
偽物のアヒルの鳴き声

*List<Duck> duckList = new List<Duck>();
リストに格納して実行することもできます


*this[index] = new T();
初期値

*public virtual IEnumerable<int> GetAllIndexes() {for (int y = 1; y <= this.YSize; y++) {for (int x = 1; x <= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する

*public virtual IEnumerable<int> EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index); index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Horizontal(int x, int y)
(x,y)から右(水平)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Virtical(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantR(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantL(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む


*public class MyControl : UserControl {public static DependencyProperty XXXProperty= DependencyProperty.Register(nameof(XXX),typeof(bool),typeof(MyControl),new PropertyMetadata());public bool XXX {get { return (bool)GetValue(XXXProperty); }set { SetValue(XXXProperty, value); }}}
UserControlはDependencyObjectを継承している


*nameof(data)
"data"がゲットできる


*a = System.Linq.Enumerable.Range(0, 100_000_000);
普通のIEnumerable

*c = a.ToArray();
配列

*d = a.Where(x => x == x);
無駄にWhereしてみる

*var intList = Enumerable.Range(0, 100_000_000).ToList();
Listの作成

*var odd = intList.Where(x=>x % 2 != 0);
ここではまだ評価しない

*return odd.Count();
Countで中身を見なければならないので、ここで評価

*var intList = Enumerable.Range(0, 100_000_000).ToList();
Listの作成

*var odd = intList.Where(x=>x % 2 != 0);
ここではまだ評価しない

*return odd.Count();
Countで中身を見なければならないので、ここで評価

*ICollection<TSource> collection = source as ICollection<TSource>;
ICollection<T>ではないし、

*ICollection collection2 = source as ICollection;
ICollectionでもない

*int num = 0;
ここまで来る

*internal int state;
元クラスのメンバ

*private List<TSource> source;
派生クラスのメンバ

*return a.Where(x => (x % 9_999_991 == 0) && (x % 2 == 0)).Count();
こいつが理想だが

*return a.Where(x => x % 2 == 0).Where(x => x % 9_999_991 == 0).Count();
これよりは

*return a.Where(x => x % 9_999_991 == 0).Where(x => x % 2 == 0).Count();
こっちのほうがマシ


*Assert.IsTrue(o1.Equals(o2));
Object.Equals が int の Equals を呼び出すので値で比較されます。

*Assert.IsTrue(Object.Equals(o1, o2));
o1 != o2 かつ o1 != null なら上の o1.Equals(o2) と同じ結果となります。

*Assert.IsFalse(o1 == o2);
★ボックス化（値型 → object）すると参照比較になるので一致しません。

*Assert.IsFalse(Object.ReferenceEquals(1, 1));
★引数として渡されるときにボックス化されるので一致しません。

*Assert.IsTrue(i == l);
比較演算子では、int が long に暗黙的に型変換され、long 同士として比較されます。

*Assert.IsTrue(l.Equals(i));
暗黙の型変換ができるなら Equals で比較できます。

*Assert.IsFalse(i.Equals(l));
★暗黙の型変換ができないと Equals は false を返します。
コンパイルは通り、例外も発生しないので見逃しがちです。

*object iBoxed = i;
★異なる型へのボックス化解除は失敗します。

*bool b = (l == (long)iBoxed);
int 型をボックス化しているので long 型に戻すことはできません。（InvalidCastException が発生）

*Assert.IsFalse(Type.Equals(1, 2));
実行されるのは Object.Equals です。
字面だけ見ると true を期待してしまいそう(?)です。


*[SerializeField] GameObject newtext;
GameObjectの設定

*[SerializeField] Renderer RendererCube;
CubeRendererの設定

*Vector3 pos = new Vector3(-1.0f, 1.0f, 0);
Cubeが消えたところにTextを表示させる。

*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame

*void OnTriggerEnter(Collider other)*{//Rendererを偽（オフ）にする。RendererCube.enabled = false;//new Textクローンの生成Instantiate(newtext, transform.position +pos, Quaternion.identity);//4f後にCubeが消えるDestroy(gameObject, 4f);}
Sphereが当たった時の設定

*RendererCube.enabled = false;
Rendererを偽（オフ）にする。

*Instantiate(newtext, transform.position +pos, Quaternion.identity);*//4f後にCubeが消える
new Textクローンの生成

*Destroy(gameObject, 4f);
4f後にCubeが消える


*Math.Abs(x-y) < EPSILON
true


*}
ほげほげ

*}
ほげほげ

*}
ほげほげ


*WriteVal(st, 2, 8);
wBitsPerSample


*int[][] data = new int[3][];
3つのary格納


*WebClient wc = new WebClient();
参照サイト
https:qiita.com/okazuki/items/a4eb94f608bbc26c6a5f
https:usefuledge.com/csharp-webscraping-anglesharp.html
var urlstring = "https:www.yahoo.co.jp/";

*// foreach (var item in document.QuerySelectorAll("h1.thumb"))*foreach (var item in document.QuerySelectorAll("section#tabpanelTopics1 li"))
Console.WriteLine(document.Title);


*BufferResponse response = new BufferResponse();
レスポンスのインスタンスは使いまわす

*yield return new FileStream(@"image1.jpg", FileMode.Open, FileAccess.Read);
実際には条件に該当するファイルなどから列挙するように実装します。

*using (Image image = Image.FromStream(stream))using (Form frm = new Form()){PictureBox box = new PictureBox();
単純にダイアログフォームで表示します。


*};
ここに処理を追加


*Velocity.y = JumpPower;
Velocity.yをJumpPowerにする


*public class BindingProxy : Freezable {protected override Freezable CreateInstanceCore()=> new BindingProxy();//依存関係プロパティを定義するpublic static readonly DependencyProperty DataProperty= DependencyProperty.Register(nameof(Data),typeof(object),typeof(BindingProxy),new PropertyMetadata(null));public object Data {get { return (object)GetValue(DataProperty); }set { SetValue(DataProperty, value); }}}
Freezableを継承する

*public static readonly DependencyProperty DataProperty
依存関係プロパティを定義する


*namespace Gamepad*{public class InputStructures {[DllImport("user32.dll", SetLastError = true)]public extern static intSendInput(int length, ref InputEvent events, int size);[DllImport("user32.dll", EntryPoint = "MapVirtualKeyA")]public extern static int MapVirtualKey(int wCode, int wMapType);public const int MOUSEEVENTF_MOVE       = 0x01;public const int MOUSEEVENTF_LEFTDOWN   = 0x02;public const int MOUSEEVENTF_LEFTUP     = 0x04;public const int MOUSEEVENTF_RIGHTDOWN  = 0x08;public const int MOUSEEVENTF_RIGHTUP    = 0x10;public const int MOUSEEVENTF_MIDDLEDOWN = 0x20;public const int MOUSEEVENTF_MIDDLEUP   = 0x40;public const int KEYEVENTF_KEYUP        = 0x02;public const int MAPVK_VK_TO_VSC        = 0;[StructLayout(LayoutKind.Sequential)]public struct InputEvent{public int Type;public InputUnion Data;}[StructLayout(LayoutKind.Explicit)]public struct InputUnion{[FieldOffset(0)] public MouseInput Mouse;[FieldOffset(0)] public KeyboardInput Keyboard;}[StructLayout(LayoutKind.Sequential)]public struct MouseInput{public int X;public int Y;public int MouseData;public int Flags;public int Time;public IntPtr ExtraInfo;}[StructLayout(LayoutKind.Sequential)]public struct KeyboardInput{public short VirtualKey;public short ScanCode;public int Flags;public int Time;public IntPtr ExtraInfo;}}[ComVisible(true)]public class Bridge : InputStructures {public class ControllerEvent{public string type  { get; set; }public string key   { get; set; }public int button   { get; set; }public float x      { get; set; }public float y      { get; set; }}public void dispatch(string s){var e = JsonSerializer.Deserialize<ControllerEvent>(s);switch(e.type){case "mousemove":   SendMouseMove(e);   break;case "mousedown":   SendMouse(e);       break;case "mouseup":     SendMouse(e);       break;case "keydown":     SendKeyboard(e);    break;case "keyup":       SendKeyboard(e);    break;}}static readonly Dictionary<string,object>flag = new Dictionary<string,object>(){{"keydown",     0},{"keyup",       KEYEVENTF_KEYUP},{"mousemove",   MOUSEEVENTF_MOVE},{"mousedown",   new []{MOUSEEVENTF_LEFTDOWN,MOUSEEVENTF_MIDDLEDOWN,MOUSEEVENTF_RIGHTDOWN,}},{"mouseup",     new []{MOUSEEVENTF_LEFTUP,MOUSEEVENTF_MIDDLEUP,MOUSEEVENTF_RIGHTUP,}}};static void SendMouseMove(ControllerEvent e){var v = new InputEvent(){Type = 0};v.Data.Mouse    = new MouseInput(){Flags       = (int)flag[e.type],X           = (int)Math.Round(e.x),Y           = (int)Math.Round(e.y),};SendInput(1, ref v, Marshal.SizeOf(v));}static void SendMouse(ControllerEvent e){var v = new InputEvent(){Type = 0};v.Data.Mouse    = new MouseInput(){Flags       = (int)(flag[e.type] as int[])[e.button]};SendInput(1, ref v, Marshal.SizeOf(v));}static void SendKeyboard(ControllerEvent e){if (Keys.TryParse(e.key, out Keys k)){var v = new InputEvent(){Type = 1};v.Data.Keyboard = new KeyboardInput(){VirtualKey  = (short)k,ScanCode    = (short)MapVirtualKey((int)k,MAPVK_VK_TO_VSC),Flags       = (int)flag[e.type],};SendInput(1, ref v, Marshal.SizeOf(v));}}}public class Browser : Form {public Browser(string html){ClientSize = new System.Drawing.Size(600,400);Text = "Gamepad";var v = new WebView2(){Source  = new Uri(GetPath()+"\\"+html),Size    = ClientSize,};v.NavigationCompleted += (s,e) =>v.CoreWebView2.AddHostObjectToScript("bridge",new Bridge());SizeChanged += (s,e) => v.Size = ClientSize;Controls.Add(v);}private static string GetPath(){var p = System.Diagnostics.Process.GetCurrentProcess();return System.IO.Path.GetDirectoryName(p.MainModule.FileName);}}static class Program{[STAThread]static void Main(){Application.SetHighDpiMode(HighDpiMode.SystemAware);Application.EnableVisualStyles();Application.SetCompatibleTextRenderingDefault(false);Application.Run(new Browser("Gamepad.html"));}}}
https:www.it-swarm-ja.com/ja/c%23/user32dll%e3%81%aesendinput%e3%82%92%e4%bb%8b%e3%81%97%e3%81%a6%e3%82%ad%e3%83%bc%e3%82%92%e9%80%81%e4%bf%a1%e3%81%99%e3%82%8b/1068919389/


*var morake = "hello";
as string


*Console.WriteLine(x);
べき乗計算はMathクラスのPowメソッドを使う。ex.double result = Math.Pow(2, 3); resultは8

*int a = int.Parse(str[0]);
String.SplitメソッドとはStringクラスメソッドの一つで、文字列を指定した区切り文字で分割し配列に格納する場合に使う


*Sample sample = new Sample();*Type[] paramTypes = new Type[] { typeof(bool).MakeByRefType() };
引数を false から true に変える ChangeByRefToTrue メソッドを呼び出す。

*bool isEnum = type.IsEnum;
列挙型か。

*bool isValueType = type.IsValueType;
値型か。

*bool isNullableValueType = (Nullable.GetUnderlyingType(type) != null);
Nullを許可する値型か。

*var body = (UnaryExpression)lambda.Body;
TProperty が object の場合、ボックス化によって UnaryExpression となる。

*string propertyName = GetPropertyName((Sample s) => s.PublicProperty);
使用例


*#elif GG
else ifと同じ

*}
ここには入らない。
#elseelseと同じ
ここには入らない。
#endifif文がここまでという宣言。

*#region
こんな感じに閉じることが出来る。

*using System.Diagnostics;
必要

*}
TESTが存在する際に実行される処理

*[Conditional("TEST")]
戻り値がvoidじゃない為、エラーになる


*Process.Start(proc);
別プロセスで本アプリを起動する

*return;
現在プロセス終了

*Process.Start(proc);
別プロセスで本アプリを起動する

*return;
現在プロセス終了


*while (e.MoveNext())*,,,
(2)


*yield return 0;
適当なデータです


*HeightRequest = 200,BackgroundColor = Color.FromHex("53CF9E"),});
VerticalOptions = LayoutOptions.FillAndExpand,縦方向に余白を最大限に利用する


*this[index] = new T();
初期値

*public virtual IEnumerable<int> GetAllIndexes() {for (int y = 1; y <= this.YSize; y++) {for (int x = 1; x <= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する

*public virtual IEnumerable<int> EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index); index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Horizontal(int x, int y)
(x,y)から右(水平)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Virtical(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantR(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantL(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む


*regionManager.RegisterViewWithRegion("ContentRegion", typeof(ViewA));
RegionにViewを読み出す ★重要

*var view = _container.Resolve<ViewA>();
RegionにViewを読み出す ★重要

*public CompositeCommand(bool monitorCommandActivity);
概要:
Initializes a new instance of Prism.Commands.CompositeCommand.

パラメーター:
monitorCommandActivity:
Indicates when the command activity is going to be monitored.

*bool IsActive { get; set; }
Gets or sets a value indicating whether the object is active.

*bool IsNavigationTarget(NavigationContext navigationContext);
ナビゲーションが移る前にコールされる。
trueを返すと、このインスタンスが使いまわされる。
falseを返すと、別のインスタンスが作成される。
サンプルの動作だとボタンクリックの度にタブが増えていく。

*void OnNavigatedFrom(NavigationContext navigationContext);
ナビゲーションが他に移る時にコールされる。

*void OnNavigatedTo(NavigationContext navigationContext);
ナビゲーションが移ってきた時にコールされる。
これでカウンタをインクリメントしていた。

*private void Views_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
こちらはボタンクリック(ViewA/B)追加の度にAddが来る
ViewAインスタンスが消える際にはRemoveが来る

*bool KeepAlive { get; }
インスタンスを非アクティブ化時に保持するか？

*SelectedCommand = new DelegateCommand<object[]>(x =>{if (x != null && x.Count() > 0)
This command will be executed when the selection of the ListBox in the view changes.


*%namespace GPPGCalculator2
定義部
---------------------------
出力するクラスのnamespace

*%scannertype CalculatorScanner
出力するクラス名

*%visibility internal
出力するクラスのアクセシビリティ

*%tokentype Token
トークンに使用するenumの型名

*%option stack, minimize, parser, verbose, persistbuffer, noembedbuffers
オプション
stack          : これを付けると、状態をスタックに保存できるようになる。
C言語のコメント(/*  */)の解釈のように、状態を管理したい場合に使用する。
電卓では不要だが付けておく。
minimize       : これを付けると、内部構造のDFSA(決定性有限オートマトン)を最小化してくれる
verbose        : これを付けると、ビルドの途中経過が出力される
persistbuffer  : これを付けると、入力を全てバッファに格納してから解析するようになる。
それにより、ScanBuff.GetString()で任意の位置から読めるようになる。
しかし、入力ファイルのサイズが大きいと、メモリ使用量も増えるので注意が必要となる。
noembedbuffers : これを付けると、バッファとしてGplexBuffersクラスを使うようになる。
これにより、アプリ側でバッファを利用したい場合に便利になる。
付けないと、バッファにアクセスできない。

*{L}({L}|{D})*               { yylval.text = yytext; return (int)Token.VARIABLE; }
ルール部
---------------------------
変数名

*0[xX]{H}+                   { yylval.real = (double)Convert.ToInt32(yytext, 16); return (int)Token.CONSTANT; }
16進数

*0{D}+                       { yylval.real = (double)Convert.ToInt32(yytext, 8);  return (int)Token.CONSTANT; }
8進数

*{D}+                        { yylval.real = double.Parse(yytext); return (int)Token.CONSTANT; }
10進数の整数

*{D}+{E}                     { yylval.real = double.Parse(yytext); return (int)Token.CONSTANT; }
指数表示の10進数の整数

*{D}*"."{D}+({E})?           { yylval.real = double.Parse(yytext); return (int)Token.CONSTANT; }
実数

*"="                         { return '='; }
演算子

*.                           /* Skip */
該当しない文字は無視する

*,,,
コード部
---------------------------

*using System;
不要な関数を削除したぐらいで大きな変更なし

*%namespace GPPGCalculator2
宣言部
---------------------------
出力するクラスのnamespace

*%partial
生成するクラスがpartialクラスになる
そうすることで、実装部分を*.yではなく、*.csに書けるようになるので便利

*%parsertype CalculatorParser
出力するクラス名

*%visibility internal
出力するクラスのアクセシビリティ

*%tokentype Token*%union {public double real;public string text;}
トークンに使用するenumの型名

*// ---------------------------*main            : assignment                    { m_result = $1.real; }
ルール部

*main            : assignment                    { m_result = $1.real; }
---------------------------

*,,,
コード部
---------------------------

*private double m_result;
Parseした結果が格納される。
格納する処理は、Calculator.Language.grammer.yの中に記述している。

*private Dictionary<string, double> m_variables = new Dictionary<string, double>();
変数を格納するためのディクショナリ
Keyが変数名、Valueが格納している値

*var parser = new CalculatorParser();
作った電卓のParserを生成
字句解析器も、この中で生成されている

*Console.Write("> ");
式を入力。空文字なら終了。

*double result;
式を解析して結果を出力


*var filePath = System.IO.Path.Combine(Environment.CurrentDirectory, "Test.ini");
iniから前回のフォーム位置、サイズ取得

*var filePath = System.IO.Path.Combine(Environment.CurrentDirectory, "Test.ini");
iniにフォーム位置、サイズ保存


*RedirectUri = redirectUri,
オプションに追加することで応答URLを指定できる


*void Start()*{this.GetComponent().preserveAspect = true;this.GetComponent().SetNativeSize();Vector2 CanvasSize = transform.root.GetComponent().sizeDelta;Vector2 ThisImageSize = this.GetComponent().sizeDelta;if(CanvasSize.x<CanvasSize.y){scaleRate = CanvasSize.x / ThisImageSize.x;}else{scaleRate = CanvasSize.y / ThisImageSize.y;}this.GetComponent<RectTransform>().localScale = new Vector3(scaleRate, scaleRate, 1);}
Start is called before the first frame update


*RpcConfigurationConfig config = LoadConfig(@".\GrpcServer.config");
設定ファイルを読み込みます。

*using (RpcConfigurationContext context = new RpcConfigurationContext(config, true))
コンテキストを生成します。
第二引数は、コンテキストが dispose された時に生成した gRPC オブジェクトを破棄（チャネルをシャットダウン）するかどうかを表します。

*server.Services.Add(context.Intercept(ExampleService.BindService(new ExampleServiceImpl()), "example1"));
設定上のサービス名を指定してサービスに対してインターセプターを適用します。

*server.Ports.Add(context.GetServerPort("channel1"));
設定上のチャネル名を指定してサーバーポートを生成します。

*Type[] extraTypes ={typeof(ExampleInterceptorConfig)};
ExtraInterceptors などに指定した型をシリアライザに渡します。

*RpcConfigurationConfig config = LoadConfig(@".\GrpcClient.config");
設定ファイルを読み込みます。

*using (RpcConfigurationContext context = new RpcConfigurationContext(config, true))
コンテキストを生成します。
第二引数は、コンテキストが dispose された時に生成した gRPC オブジェクトを破棄（チャネルをシャットダウン）するかどうかを表します。

*Type[] extraTypes ={typeof(ExampleInterceptorConfig)};
ExtraInterceptors などに指定した型をシリアライザに渡します。

*CallInvoker invoker = m_RpcContext.GetCallInvoker("invoker1");
設定上の名称を指定して CallInvoker を生成します。


*[TestMethod, Timeout(100)]
100ミリ秒でタイムアウト
1000ミリ秒のSleepがあるので確実にタイムアウトする


*var handle = ((HwndSource)HwndSource.FromVisual(element)).Handle;
ロード完了後でないとハンドラを登録できない


*new ObservableClass(1).Goshujin = g;
これでListViewが更新！


*public string FileName { get; set; }
ファイルダイアログと同名のプロパティを定義する

*}
以下省略


*await Task.Delay(1000);
1秒待つ

*Tello.controllerState.setAixs(0, 0, 0, 0);
静止


*int version = _version;
ここと

*var a = new List<int>();
特に何もしない。

*var b = new List<int>(num);
コンストラクタの引数であらかじめCapacityを設定できる。


*NUlid.Ulid id = NUlid.Ulid.NewUlid();
新規IDを生成


*var parser = new Calculator.CalculatorParser();
作った電卓のParserを生成する。
字句解析器は、この中で生成されている。

*Console.Write("> ");
式を入力。空文字なら終了。

*parser.Parse(input);
式を解析。この中で結果も出力される。


*.AddLogging(configure => configure.AddJsonConsole())
JSONとして出力する（構造化）

*logger.LogError ("Hello {@aaa}", new Hoge { Id = 0, Name = "あいうえお"});
LogTemplateに@を付けると、プロパティーの構造をそのままログに出してくれる


*TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider();
準備 =================================================================================
key, iv
byte[] key = Encoding.UTF8.GetBytes("123456789012345678901234"); 半角24文字 196bit
byte[] iv = Encoding.UTF8.GetBytes("12345678"); 半角8文字 64bit
3DES

*string srcStr = "hogehoge";
文字列

*Console.WriteLine("元の文字列: " + srcStr);
出力

*byte[] srcByte = Encoding.UTF8.GetBytes(srcStr);
暗号化処理 ============================================================================
byte変換

*string encStr = System.Convert.ToBase64String(encData);
普通に出力すると文字化け？するので、Base64でエンコード。

*byte[] encByte = System.Convert.FromBase64String(encStr);
複合処理 ============================================================================


*sum += Mathf.Abs(data[i]);
データ（波形）の絶対値を足す

*m_volumeRate = Mathf.Clamp01(sum * m_gain / (float)data.Length);
データ数で割ったものに倍率をかけて音量とする


*_cachedRectTransform.IsAlive()
こんなメソッドはありません。あくまでも概念です

*private bool isCached;
public RectTransform RectTransform => _cachedRectTransform != null ? _cachedRectTransform : (_cachedRectTransform = transform as RectTransform); これは辞めて


*IEnumerable<IList<int>> buffered = new List<int> { 0, 1, 2, 3, 4, 5 }.Buffer(count: 2);
[[0, 1], [2, 3], [4, 5]] みたいな感じでまとめられます。

*IEnumerable<IList<int>> buffered = new List<int> { 0, 1, 2, 3, 4, 5, 6 }.Buffer(count: 2);
[[0, 1], [2, 3], [4, 5], [6]] みたいな感じでまとめられます。

*IEnumerable<IList<int>> buffered = new List<int> { 0, 1, 2, 3, 4 }.Buffer(count: 3, skip: 1);
[[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4], [4]] みたいな感じでまとめられます。

*IEnumerable<IList<int>> buffered = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7 }.Buffer(count: 2, skip: 3);
[[0, 1], [3, 4], [6, 7]] みたいな感じでまとめられます。

*public static IEnumerable<TResult> Repeat<TResult>(TResult value)
渡した要素を何回でも繰り返すIEnumerable<T>をつくる

*public static IEnumerable<TSource> Repeat<TSource>(this IEnumerable<TSource> source)
IEnumerable<T>の拡張関数で、何回でも要素を繰り返すIEnumerable<T>をつくる

*public static IEnumerable<TSource> Repeat<TSource>(this IEnumerable<TSource> source, int count)
IEnumerable<T>の拡張関数で、指定した回数繰り返すIEnumerable<T>をつくる


*Tello.startConnecting();
接続開始

*if (inputStr == "takeoff" && Tello.connected && !Tello.state.flying)
離陸
Telloと接続中、かつ、飛行していない

*if (inputStr == "land" && Tello.connected && Tello.state.flying)
着陸
Telloと接続中、かつ、飛行中

*Tello.land();
とりあえず着陸命令だしておく

*Thread.Sleep(1000);
これだと、命令が送られる前にアプリケーションが終了してしまうので、
ちょっと待つ


*public class Point*{public float X { get; set; }public float Y { get; set; }public Point(float x, float y){X = x;Y = y;}}
座標

*public class Line*{public Point Start { get; set; }public Point End { get; set; }}
通知データ  線分を表すクラス

*public class LissajousCurve : IObservable<Line>*{private int halfW;private int halfH;private int pa;private int pb;public LissajousCurve(int paramA, int paramB, int width, int height){pa = paramA;pb = paramB;halfW = width / 2;halfH = height / 2;}public void Start(){int startx = (int)(halfW * Math.Sin(0));int starty = (int)(halfH * Math.Sin(0));double rad = 0.0;int prevx = startx;int prevy = starty;do{rad += 0.02;int x = (int)(halfW * Math.Sin(pa * rad));int y = (int)(halfH * Math.Sin(pb * rad));Line line = new Line{Start = new Point(prevx, prevy),End = new Point(x, y)};Publish(line);prevx = x;prevy = y;} while (prevx != startx || prevy != starty);Complete();}// 終了を通知するprivate void Complete(){foreach (var observer in _observers){observer.OnCompleted();}}// 状況変化を知らせるために購読者に通知するprivate void Publish(Line state){foreach (var observer in _observers){observer.OnNext(state);}}private List<IObserver<Line>> _observers = new List<IObserver<Line>>();public IDisposable Subscribe(IObserver<Line> observer){_observers.Add(observer);return observer as IDisposable;}}
リサジュー曲線クラス

*private void Complete()*{foreach (var observer in _observers){observer.OnCompleted();}}
終了を通知する

*private void Publish(Line state)*{foreach (var observer in _observers){observer.OnNext(state);}}
状況変化を知らせるために購読者に通知する


*var entities = this.ChangeTracker.Entries().Where(e => e.State == EntityState.Added && e.CurrentValues.PropertyNames.Contains("CreatedDateTime"))
追加エンティティのうち、CreatedDateTime プロパティを持つものを抽出

*var entities = this.ChangeTracker.Entries<IEntity>()
追加エンティティのうち、IEntity を実装したものを抽出

*continue;
除外エンティティ


*var rcOwner = Win32Native.GetWindowRect(hOwner);
オーナーウィンドウとメッセージボックスの領域を取得

*var x = rcOwner.Left + (rcOwner.Width - rcMsgBox.Width) / 2;
メッセージボックスをオーナーウィンドウの中央位置に移動

*Win32Native.UnhookWindowsHookEx(hHook);
フックを解除


*Configuration = config;
コンストラクタでコンフィグを初期化

*services.AddOptions();
オプションを使用するためのサービスを追加します。

*services.Configure<MyOptions>(Configuration);
バインドするオプションクラスに対し、設定情報を登録します。

*services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
※上記は services.AddMvc() より前で設定しなくても動きましたが、公式ドキュメント通り、前で設定しています。

*}
以下略

*public OptionsController(IOptionsMonitor<MyOptions> optionsMonitor) {// CurrentValueプロパティでオプションクラスのインスタンスが得られるoptions = optionsMonitor.CurrentValue;}
コンストラクタで OptionsMonitor<TOptions> が DI される

*options = optionsMonitor.CurrentValue;
CurrentValueプロパティでオプションクラスのインスタンスが得られる

*private readonly MyOptions options;
オプションクラスのインスタンスをフィールドに保持

*[HttpGet]*public IActionResult GetOptions() {// JSON で返してみるreturn Ok(options);}
api/options

*return Ok(options);
JSON で返してみる

*public class MySubOptions {public string SubOption1 { get; set; }public int SubOption2 { get; set; }public Guid SubOption3 { get; set; }}
バインドするクラスを用意

*public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>
ここで自動的に appsettings.json が読み込まれる


*Console.WriteLine(str);
hoge


*Value = target.ID == "PDF" ? $"https:
dl.acm.org{match.Groups[1].Value}" : match.Groups[1].Value


*BurstFunc.TryParse(str_list[1], out elem.somethingData);
Burst 適用済み delegate

*}
略

*}
略

*}
そのほか、byte, UInt16 との相互変換、
Equals(), 比較演算子(==, !=, <=, <, >=, >)などを一通り実装

*public static class NativeListExt*{public static UnsafeRefToNativeList<T> GetUnsafeRef<T>(this NativeList<T> target)where T : unmanaged{return new UnsafeRefToNativeList<T>(target);}}
UnsafeRef を簡単に作成するための拡張メソッド

*_list = passed_list.GetUnsafeList();
NativeList<T> 内部の UnsafeList へのポインタを取得
参照先が共通なので UnsafeRef への変更は元の NativeList にも反映される

*public interface IPtrGetter*{public void* GetUnsafePtr();}
interface

*public unsafe void Func1(IPtrGetter source)
普通のInterfaceの使い方 -> Boxing が起きる
Burst でコンパイルできない

*public unsafe void Func2<T>(T source)
Generic Interface の書き方 -> struct を渡す時には参照型を生成しない (高速)
Burst でコンパイルしてさらに速くできる

*public struct Data { };
BurstFunc が受け取れる型 Data

*public struct DataType2*{public implicit operator Data(DataType2 data) {return new Data(/* converion */)};};
Data への暗黙の型変換を実装した型

*public struct DataType3*{public Data data_member;};
関数のオーバーロードで該当するメンバを取り出して渡す例

*[BurstCompile]
Burst 関数ポインタへのエントリポイント

*private static bool Proccess<T>(T data)
Burstへのエントリポイント以外では参照渡ししなくても、
Genericな関数を使っても、
void以外を返してもよい

*public static void Func(ref Data data)*{_funcDelegade(ref data);}
Data と DataType2 を渡せる　(暗黙にDataへの型変換が行われる)

*public static void Func(ref DataType3 data)*{_funcDelegade(ref data.data_member);}
DataType3 を渡せる (オーバーロード)


*戻り値=DER形式の公開鍵byte[] authPubKey = JPKIReaderLib.JPKIReader.GetAuthenticationPublicKey();
認証用公開鍵GETする

*byte[] authPubKey = JPKIReaderLib.JPKIReader.GetAuthenticationPublicKey();
戻り値=DER形式の公開鍵

*第1引数=PIN第2引数=電子署名する対象のファイル(パス＆ファイル）戻り値=電子署名byte[] sig = JPKIReaderLib.JPKIReader.SignatureUsingAuthenticationPrivateKey("9999", file);
ファイルの電子署名を作成する

*第2引数=電子署名する対象のファイル(パス＆ファイル）戻り値=電子署名byte[] sig = JPKIReaderLib.JPKIReader.SignatureUsingAuthenticationPrivateKey("9999", file);
第1引数=PIN

*戻り値=電子署名byte[] sig = JPKIReaderLib.JPKIReader.SignatureUsingAuthenticationPrivateKey("9999", file);
第2引数=電子署名する対象のファイル(パス＆ファイル）

*byte[] sig = JPKIReaderLib.JPKIReader.SignatureUsingAuthenticationPrivateKey("9999", file);
戻り値=電子署名

*第1引数=DER形式の公開鍵第2引数=電子署名第3引数=電子署名する対象のファイル(パス＆ファイル）戻り値=true/falsebool isVerifySuccess = JPKIReaderLib.Verify.VerifySignature(authPubKey , sig , file),,,*第2引数=電子署名第3引数=電子署名する対象のファイル(パス＆ファイル）戻り値=true/falsebool isVerifySuccess = JPKIReaderLib.Verify.VerifySignature(authPubKey , sig , file),,,*第3引数=電子署名する対象のファイル(パス＆ファイル）戻り値=true/falsebool isVerifySuccess = JPKIReaderLib.Verify.VerifySignature(authPubKey , sig , file)
第2引数=電子署名

*戻り値=true/falsebool isVerifySuccess = JPKIReaderLib.Verify.VerifySignature(authPubKey , sig , file),,,*bool isVerifySuccess = JPKIReaderLib.Verify.VerifySignature(authPubKey , sig , file)*,,,
戻り値=true/false


*pubkey_pkcs8.AddRange(Common.HexStringToBytes("30820122300d06092a864886f70d01010105000382010f00").ToArray());
ここで取れるpubkey_pkcs1はPKCS#1形式の公開鍵
先頭に
30820122300d06092a864886f70d01010105000382010f00
を付加するとOpenSSLで取り扱い可能なPKCS#8になる


*private AudioSource bgmSource;
BGMは一つづつ鳴るが、SEは複数同時に鳴ることがある

*IEnumerable<AudioSource> audioSources = GetComponents<AudioSource>().Select(a => { a.playOnAwake = false; a.volume = BGM_VOLUME; a.loop = true; return a; });
LinQを使い、BGMはループさせ、ボリュームをそれぞれ代入しました。

*private AudioSource bgmSource;
BGMは一つづつ鳴るが、SEは複数同時に鳴ることがある


*ConsoleWriteIEnumerable("OrderedSet:", os);
0, 1, 2, 3, 4


*List<int> numbers = new List<int> { 1, 2, 3, 4 };
Creating a list of numbers

*List<int> numbers = new List<int> { 1, 2, 3, 4 };
Creating a list of numbers


*class Table1 : RealmObject*{// プロパティがカラムになる。// 主キーには PrimaryKey 属性を付ける。[PrimaryKey]public int PrimaryKey { get; set; }public string Column1 { get; set; }public string Column2 { get; set; }// インデックスを作る項目には Indexed 属性を付ける。[Indexed]public string Column3 { get; set; }}
RealmObject を継承したクラスがテーブルになる。

*[PrimaryKey]
プロパティがカラムになる。
主キーには PrimaryKey 属性を付ける。

*[Indexed]*public string Column3 { get; set; }
インデックスを作る項目には Indexed 属性を付ける。

*internal class Table1 : RealmObject*{// ...[Preserve][WovenProperty]public string Column1{[CompilerGenerated]get{if (base.IsManaged){return base.GetStringValue("Column1");}return this.Column1;}[CompilerGenerated]set{if (!base.IsManaged){this.Column1 = value;base.RaisePropertyChanged("Column1");}else{base.SetStringValue("Column1", value);}}}// ...}
...

*var threadRealm = Realm.GetInstance(config);
スレッド用に Realm オブジェクトを用意する。

*threadRealm.Write(() =>*{updateTarget.Column1 = "NewValue";Console.WriteLine("Updated: {0}", threadRealm.Find<Table1>(1));// トランザクションの完了を少し待機する。Thread.Sleep(2000);});
更新もトランザクション内で行う。

*Thread.Sleep(2000);
トランザクションの完了を少し待機する。

*Thread.Sleep(1000);
更新が済むまで少し待機する。

*realm = Realm.GetInstance(config);
トランザクションが完了する前は変更内容が見えない。
Realm オブジェクトは毎回取得しなおす。取得し直さないと他スレッドでの変更は見れない。

*Thread.Sleep(3000);
トランザクションが完了するまで少し待機する。

*realm = Realm.GetInstance(config);
トランザクションが完了したので変更内容が見える。

*public Table2 Object1 { get; set; }
一対一は単にプロパティを作る。

*public IList<Table3> ObjectN { get; }
一対多は IList のプロパティを作る。

*[Backlink(nameof(Table1.Object1))]*public IQueryable<Table1> Owners1 { get; }
Table1.Object1 の逆参照

*[Backlink(nameof(Table1.ObjectN))]*public IQueryable<Table1> OwnersN { get; }
Table1.ObjectN の逆参照

*var target = realm.Find<Counter>(COUNTER_KEY);
Realm.Find で取得しなおしたオブジェクト経由で変更しても変更通知は伝わる。

*target.Count++;
INotifyPropertyChanged による変更通知で画面の表示が自動で変わる。


*ilgen.Emit(OpCodes.Ret);
戻り値とせよ


*}
returnステートメント不要

*await Task.Run(() =>*{HeavyWork(x)});
重い処理なのでUIスレッドから逃す

*await Task.Run(() => {Console.WriteLine("処理1");Thread.Sleep(3000);Console.WriteLine("処理2");Thread.Sleep(3000);});
ラムダ式を与えるコード

*await Task.Delay( 3000 );
なんか処理


*}
以下同様の分岐が続く...

*return stringResult;
CommandAの処理
・・・

*return doubleResult;
CommandBの処理
・・・

*,,,
以下同様のメソッド多数...
・・・

*}*class CommandResultDto{public string FieldResult1 {get;set;}public double FieldResult2 {get;set;}//必要なフィールドを定義する}
必要なフィールドを定義する

*}
必要なフィールドを定義する

*return result;
コマンドAの処理
・・・
・・・

*return result;
コマンドBの処理
・・・
・・・

*commandDic.Add("commandA",commandAExec);
コマンドとメソッドの組み合わせをディクショナリに格納する

*,,,
必要な組み合わせを追加

*if (commandDic.ContainsKey(commandString)){
argsに引数を設定する
・・・
キーが存在するかどうかは先にチェックする


*Dictionary<int, string> Table = new();
右辺を省略できる

*,,,
今までは、こう書いていた。
Dictionary<int, string> Table = new Dictionary<int, string>();
もしくは、varが使える場面では、
var Table = new Dictionary<int, string>();

*case SketchLine:
C#8.0では'種類のパターン'が使えないので、次のように書く必要があった。
case SketchLine _:


*huga = hoge;
暗黙的な変換

*hoge = (int)huga;
明示的な変換


*public const double payo = Math.Sqrt(10);
NG

*if(Moge == PI)*//処理
コンパイルで生成される中間言語では下の条件式はmyData == 3.14となる

*}
処理

*}
なんか

*Hoge();
実際にはコンパイル時にHoge(100);となっている

*this.Piyo = huga;
コンストラクタ内で書き換え可能

*this.Piyo = mohu;
書き込み不可でエラー


*class Sub : Expr {
式-式を表す


*}
何か処理

*Set();
以下、再スタートさせるための再取得

*}
何か処理

*yield return new WaitForSeconds ( 1f );
処理記述(1)

*yield return new WaitForSeconds ( 1f );
処理記述(2)

*yield return new WaitForSeconds ( 1f );
処理記述(3)

*yield return new WaitForEndOfFrame();
piyoのisComplete変数がtrueになるまで待機

*}
childのアニメーションが終了したとき
(child.isCompleteがtrueになったとき)
ここより下にかかれた処理が実行される&lt;/code&gt;&lt;/p&gt;
シンプルに実装できるので、アニメーションを組み合わせた演出などを作る時に便利。

*}
処理


*DataContext = this;
Binding用


*devicePort = "/dev/ttyUSB0";
Linux等(Raspbian Stretchで動作確認)

*skStackClient.OpenAsync(devicePort, 115200, 8, Parity.None, StopBits.One).Wait();
シリアルポートOpen


*var i = _count;
追加

*numberBtList[_count].onClick.AddListener(() => OnClickNumber(i));
iを引数で渡す

*void Update () {}
Update is called once per frame


*delegate int Delegate_A(string s);
Delegate_A という名前の「型」を定義

*int result = dlg("123");
デリゲートはひとつの「型」なので、他のクラスを使用するときと同じ書き方でインスタンス化できる
Delegate_A dlg = new Delegate_A(work);     C#1.0
Delegate_A dlg = work;                 C#2.0 で new なしで書けるようになった
作成したインスタンスに引数を渡しつつ呼び出す

*private static int work(string s)*{return int.Parse(s);}
デリゲートから呼び出されるメソッド

*static void Main()*{// 定義済デリゲートのインスタンスを生成（newを省略した書き方）Func<string,int> dlg = work;// 作成したインスタンスに引数を渡しつつ呼び出すint result = dlg("123");}
独自デリゲート型の宣言が不要になった

*Func<string,int> dlg = work;
定義済デリゲートのインスタンスを生成（newを省略した書き方）

*int result = dlg("123");
作成したインスタンスに引数を渡しつつ呼び出す

*private static int work(string s)*{return int.Parse(s);}
デリゲートから呼び出されるメソッド

*//Func<string,int> dlg = (string s) => { return int.Parse(s); };
メソッドの内容を (引数) => {処理(式)} で書ける

*// 引数の型(string)は型推論により省略可能*// 処理部分がreturn のみの場合は{}も省略可能
Func<string,int> dlg = (string s) => { return int.Parse(s); };

*// 処理部分がreturn のみの場合は{}も省略可能
引数の型(string)は型推論により省略可能

*Func<string,int> dlg = s => int.Parse(s);
処理部分がreturn のみの場合は{}も省略可能

*int result = dlg("123");
作成したインスタンスに引数を渡しつつ呼び出す


*public static void Method_A()
静的メソッド --> インスタンス化せずに呼び出せる

*}
処理を実装

*public void Method_B()*{// 処理を実装}
「静的クラスでインスタンスのメンバーを宣言することはできません」と怒られます。

*}
処理を実装


*protected override void PostCreateHost(IHost webHost)*{_webHost = webHost;base.PostCreateHost(webHost);}
Host が作成された際に PostCreateHost が呼び出されるので field に Host を保存しておく

*public void Dispose()*{_webHost?.Dispose();_webHost = null;}
LambdaEntryPoint が不要になったタイミングで解放するために Dispose を実装する

*using var lambdaFunction = new LambdaEntryPoint();
テストメソッドのスコープを外れたタイミングで Dispose して Host を解放する


*void Start () {//画像ファイルの読み込みstring file="Assets/cat.jpg";var labels = File.ReadAllLines("Assets/synset.txt");var tensor=CreateTensorFromImageFile(file);var graph=new TFGraph();string modelFile="Assets/plugins/beginner-const-graph.pb";var model=File.ReadAllBytes(modelFile);graph.Import(model,"");using (var session=new TFSession(graph)){var runner=session.GetRunner();runner.AddInput(graph["input"][0],tensor);runner.Fetch(graph["prob"][0]);var output=runner.Run();var result=output[0];var bestIdx = 0;float best = 0;// 尤も確率が高いものを調べて表示するvar probabilities = ((float[][])result.GetValue(true))[0];for (int i = 0; i < probabilities.Length; i++){if (probabilities[i] > best){bestIdx = i;best = probabilities[i];}}Debug.Log($"{file} best match: [{bestIdx}] {best * 100.0}% {labels[bestIdx]}");}}
Use this for initialization

*string file="Assets/cat.jpg";
画像ファイルの読み込み

*var probabilities = ((float[][])result.GetValue(true))[0];
尤も確率が高いものを調べて表示する

*void Update () {}
Update is called once per frame

*using (var session = new TFSession (graph)) {var normalized = session.Run (inputs: new [] { input },inputValues: new [] { tensor },outputs: new [] { output });
Execute that graph to normalize this one image

*// specific normalized format (a particular image size, shape of the input tensor,*// normalized pixel values etc.).
The inception model takes as input the image described by a Tensor in a very

*private static void ConstructGraphToNormalizeImage (out TFGraph graph, out TFOutput input, out TFOutput output, TFDataType destinationDataType = TFDataType.Float){Some constants specific to the pre-trained model at:https:storage.googleapis.com/download.tensorflow.org/models/inception5h.zip- The model was trained after with images scaled to 224x224 pixels.- The colors, represented as R, G, B in 1-byte each were converted tofloat using (value - Mean)/Scale.const int W = 224;
inception model.


*Debug.WriteLine(await Task.Run(() => HeavyFunc(15)).ConfigureAwait(false));
ただ単に非同期で実行したいだけなら、Task.Run を使えばよいと思います。


*Console.WriteLine(var1.Equals(var2));
falseになる

*l.Experience = 0;
直接値を設定するような書き方ができる

*public int Experience {set {if (value < 0) {throw new ArgumentException("経験年数は正の数値を入力してください。");}this._experience = value;}get {return this._experience;}}
プロパティ


*[System.Serializable]
マスターデータテーブルの各項目の基底クラス

*public abstract class MasterDataTableBase<T> : ScriptableObject where T : MasterDataItemBase
データテーブルそのものの基底クラス
ジェネリック化しているので、派生クラス作成時にMasterDataTableBaseを継承した項目クラスを設定するだけでおｋ

*if(index == -2) return;*// 見つからない場合は新規追加
異常値の場合は何もしない

*else*{list[index] = item;}
既にある場合はその要素を更新

*public class CreateMasterDataObject
テーブル用のScriptableObjectとその元となる.csファイルの作成&更新を行うスクリプト
GoogleSpreadSheetの情報をAPIで取得して、そこからファイルを作成する

*private const string CONSTANT_SPREAD_SHEET = "シートIDを適宜入れる";
各スプレッドシートIDとシート名

*private static void CreateOrUpdateCalc<B, T>(string spreadSheetId, string sheetName) where B : MasterDataItemBase where T : MasterDataTableBase<B>*{string resultText = string.Empty;m_NowUpdate = SendWebRequestToGet(string.Format(URL_FORMAT, API_URL, spreadSheetId, sheetName), (string result)=>{ resultText = result; });while(m_NowUpdate.MoveNext()){}if(resultText.IsNullOrEmpty()){Debug.LogWarning("resultTextが空の為、終了しました");return;}// ScriptableObjectのファイル名はテーブルの型名と同じにしておくstring tableFileName = typeof(T).ToString();string masterAssetPath = string.Format("{0}{1}.asset", MASTER_DATA_OBJECT_PATH, tableFileName);T master = AssetDatabase.LoadAssetAtPath<T>(masterAssetPath);// データが無い場合は新規作成if(master == null){master = Editor.CreateInstance<T>();AssetDatabase.CreateAsset(master, masterAssetPath);AssetDatabase.Refresh();}// 取得したAPIResultをJsonに変換してテーブルに格納するvar json = MiniJSON.Json.Deserialize(resultText) as Dictionary<string, object>;var tableList = json.GetValueList<Dictionary<string, object>>("Table");// クリアしてから格納するmaster.Clear();foreach (var item in tableList){master.AddOrUpdate(item);}//ダーティとしてマークする(変更があった事を記録する)EditorUtility.SetDirty(master);//保存するAssetDatabase.SaveAssets();Debug.LogFormat("{0}作成完了", tableFileName);Debug.Log(masterAssetPath);}
テーブル作成or更新～保存処理までの共通処理

*string tableFileName = typeof(T).ToString();*string masterAssetPath = string.Format("{0}{1}.asset", MASTER_DATA_OBJECT_PATH, tableFileName);
ScriptableObjectのファイル名はテーブルの型名と同じにしておく

*var json = MiniJSON.Json.Deserialize(resultText) as Dictionary<string, object>;
取得したAPIResultをJsonに変換してテーブルに格納する

*master.Clear();
クリアしてから格納する

*EditorUtility.SetDirty(master);
ダーティとしてマークする(変更があった事を記録する)

*AssetDatabase.SaveAssets();*Debug.LogFormat("{0}作成完了", tableFileName);
保存する

*private static IEnumerator SendWebRequestToGet(string url, Action<string> callback)*{Debug.Log("API通信開始");UnityWebRequest request = UnityWebRequest.Get(url);yield return request.SendWebRequest();while(!request.isDone){yield return 0;}// エラーチェックif(request.isNetworkError || request.responseCode != 200){Debug.LogError(request.responseCode);Debug.LogError(request.error);m_NowUpdate = null;if(callback != null){callback(string.Empty);}yield break;}Debug.Log(request.downloadHandler.text);Debug.Log(request.downloadHandler.data);if(callback != null){// ここで改行を置き換え無いと改行がDebug.LogやuGUI.textで反映されないstring text = request.downloadHandler.text.Replace("\\n", Environment.NewLine);callback(text);}m_NowUpdate = null;Debug.Log("API通信終了");}
Web通信用関数

*string text = request.downloadHandler.text.Replace("\\n", Environment.NewLine);
ここで改行を置き換え無いと改行がDebug.LogやuGUI.textで反映されない

*public static class StringExtensions*{public static bool IsNullOrEmpty(this string source){if(source == null || source.Length <= 0 || source == "null" || source == "Null" || source == "NULL"){return true;}return false;}}
stringの拡張クラス


*#region IList like implements
IListではないが、検索順序操作のためにIList風プロパティとメソッドも実装する


*GetComponent<Rigidbody>().NullCast()?.AddForce(force, mode);
推論が効くはず


*case 3:
下

*}
IEnumeratorを返す関数を引数に置くことでCoroutineが動く。


*//以下はApplicationCommands.Newにバインドする例*public static class AttachedCommandBindings {public static DependencyProperty NewCommandProperty= DependencyProperty.RegisterAttached("NewCommand",typeof(ICommand),typeof(AttachedCommandBindings),new PropertyMetadata(null, OnNewCommandChanged));public static void SetNewCommand(UIElement element, ICommand value)=> element.SetValue(NewCommandProperty, value);public static ICommand GetNewCommand(UIElement element)=> (ICommand)element.GetValue(NewCommandProperty);private static void OnNewCommandChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e) {UIElement element = sender as UIElement;if (element == null)return;ICommand command = e.NewValue as ICommand;if (command == null)return;RegisterCommandBinding(element, ApplicationCommands.New, command);}private static void RegisterCommandBinding(UIElement element, RoutedUICommand routedCommand, ICommand command) {var binding = new CommandBinding(routedCommand,(sender1, e1) => command.Execute(null),(sender1, e1) => e1.CanExecute = command.CanExecute(null));CommandManager.RegisterClassCommandBinding(element.GetType(), binding);element.CommandBindings.Add(binding);}}
コマンドごとに添付プロパティを実装する

*public static class AttachedCommandBindings {public static DependencyProperty NewCommandProperty= DependencyProperty.RegisterAttached("NewCommand",typeof(ICommand),typeof(AttachedCommandBindings),new PropertyMetadata(null, OnNewCommandChanged));public static void SetNewCommand(UIElement element, ICommand value)=> element.SetValue(NewCommandProperty, value);public static ICommand GetNewCommand(UIElement element)=> (ICommand)element.GetValue(NewCommandProperty);private static void OnNewCommandChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e) {UIElement element = sender as UIElement;if (element == null)return;ICommand command = e.NewValue as ICommand;if (command == null)return;RegisterCommandBinding(element, ApplicationCommands.New, command);}private static void RegisterCommandBinding(UIElement element, RoutedUICommand routedCommand, ICommand command) {var binding = new CommandBinding(routedCommand,(sender1, e1) => command.Execute(null),(sender1, e1) => e1.CanExecute = command.CanExecute(null));CommandManager.RegisterClassCommandBinding(element.GetType(), binding);element.CommandBindings.Add(binding);}}
以下はApplicationCommands.Newにバインドする例


*private static Dictionary<ScrollViewer, string> _scrollViewers
ScrollViewerとグループ名の対応リスト

*private static Dictionary<string, double> _horizontalScrollOffsets
水平方向のスクロール位置のリスト

*private static Dictionary<string, double> _verticalScrollOffsets
垂直方向のスクロール位置のリスト

*public static readonly DependencyProperty ScrollGroupProperty
グループ名の添付プロパティ

*scrollViewer.ScrollChanged -= ScrollViewer_ScrollChanged;
登録解除

*scrollViewer.ScrollToHorizontalOffset(_horizontalScrollOffsets[newGroup]);
既存のグループ名の場合は、現在のスクロール位置を反映する

*_horizontalScrollOffsets[newGroup] = scrollViewer.HorizontalOffset;
新しいグループ名の場合は、スクロール位置を記録する

*_scrollViewers.Add(scrollViewer, newGroup);
ScrollViewerを登録

*scrollViewers
同じグループのScrollViewerにスクロール位置を反映

*scrollViewers
同じグループのScrollViewerにスクロール位置を反映


*yield return new WaitForSeconds(5);
なんかいろいろやる

*observer.OnNext(s);
コールバックに入ってきた値をそのままobserverに渡します。

*return Disposable.Empty;
ここではcancellation tokenを返しますが
キャンセル機構を持っていないのでEmptyでいいでしょう

*yield return new WaitForSeconds(5);
なんかいろいろやる


*continuation();
続きを実行

*regist = cancellationToken.Register(()=>{tween.Kill(true);});
tokenが発火したらTweenをKillする

*public static TweenAwaiter ToAwaiter(this Tween self, CancellationToken cancellationToken = default){return new TweenAwaiter(self, cancellationToken);
TweenにToAwaiter拡張メソッドを追加

*source = new CancellationTokenSource();
CancellationTokenSourceを準備

*source.Cancel();
CancellationTokenSourceを破棄する

*await transform.DOMove(new Vector3(0, 5, 0), 3).ToAwaiter(token);*Debug.Log("Step1");
上に移動、ToAwaiter拡張メソッドにCancellationTokenを渡す

*await transform.DOMove(new Vector3(5, 5, 0), 3).ToAwaiter(token);*Debug.Log("Step2");
右斜め上に移動


*byteArray[i] = temp;
byte型を取得

*Debug.Log("width" + message.width);
取得したデータを出力

*void Coordinates()*{pcl = new Vector3[size];//この部分でbyte型をfloatに変換for (int n = 0; n < size; n++){int x_posi = n * point_step + 0;int y_posi = n * point_step + 4;int z_posi = n * point_step + 8;float x = BitConverter.ToSingle(byteArray, x_posi);float y = BitConverter.ToSingle(byteArray, y_posi);float z = BitConverter.ToSingle(byteArray, z_posi);pcl[n] = new Vector3(y, z, x);//結果を出力Debug.Log("pclCoordinates:x=" + pcl[n].x + ",y=" + pcl[n].y + ",z=" + pcl[n].y);}}
点群の座標を変換

*Debug.Log("pclCoordinates:x=" + pcl[n].x + ",y=" + pcl[n].y + ",z=" + pcl[n].y);
結果を出力


*await Task.Delay(500);
適当なウェイトかける


*var procStack = new List<Action>();
スタックを用意

*procStack.Add(() => { Console.WriteLine("aaa"); });
ラムダ式で任意の処理をスタックする

*procStack[2]();
任意の順番で呼び出す

*actions.ForEach(action => action());
逐次実行

*Parallel.ForEach(actions, action => action());
並列実行


*NativeMethods.WH_KEYBOARD_LL, this.KeyboardProc,
←これ


*MethodInfo Contains = typeof(string).GetMethod("Contains");
文字列を指定してメソッドの情報を取得する

*var propertyAccess = Expression.MakeMemberAccess(parameter, property);
例)p.Nameの形式を作成

*var body0 = Expression.NotEqual(Expression.Constant(null), propertyAccess);
例)null != p.Nameの形式を作成

*var body1 = Expression.Call(propertyAccess,Contains, Expression.Constant(keyword));
p.Name.Contains(keyword)の形式を作成

*var newBody = Expression.AndAlso(body0, body1);
例)null != p.Name && p.Name.Contains(keyword)の形式を作成

*return Expression.Lambda<Func<Student, bool>>(newBody, parameter);
例)p => null != p.Name && p.Name.Contains(keyword)の形式を作成


*for (int i = 1; i < nLabels; i++) {
0番目のラベルは背景のため飛ばす

*var ctrdOnImg = new Point(centroids.get(maxAreaLabel, 0)[0], centroids.get(maxAreaLabel, 1)[0]);
画像上の重心位置をワールド座標に変換

*_fire.transform.position = new Vector3((float)ctrdOnWorld.x, (float)ctrdOnWorld.y, FIRE_Z_POS);*}
炎を手の位置に移動


*}
遅らせたい処理


*public enum EnumSample {[Description("項目1")]A,[Description("項目2")]B,[Description("項目3")]C,[Description("項目4")]D}
表示させたい文字列をDescription属性に指定する


*if (window.DataContext is IClosing)*e.Cancel = (window.DataContext as IClosing).OnClosing();
ViewModelがインターフェイスを実装していたらメソッドを実行する


*_webBrowser.KeyboardHandler = new KeyboardHandler(this);
キーイベント処理登録

*MessageBox.Show("KeyDown")
Enterキー押下時の処理を記述する。

*public class KeyboardHandler : IKeyboardHandler*{private frmMain _frm;public KeyboardHandler(frmMain frm){_frm = frm;}public bool OnKeyEvent(IWebBrowser browserControl, IBrowser browser, KeyType type, int windowsKeyCode, int nativeKeyCode, CefEventFlags modifiers, bool isSystemKey){return false;}public bool OnPreKeyEvent(IWebBrowser browserControl, IBrowser browser, KeyType type, int windowsKeyCode, int nativeKeyCode, CefEventFlags modifiers, bool isSystemKey, ref bool isKeyboardShortcut){_frm.OnMyPreviewKeyDown(windowsKeyCode, modifiers);return false;}}
KeyboardHandleクラス


*int iMinNum = iaArray.Min();
最小

*liListName.Add("追加するデータ");
追加

*liListName.Clear();
特定の要素削除
全て削除

*liListName.Sort();
昇順

*liListName.Sort((a, b) => b - a);
降順（ラムダ式）

*sString (0)
1文字のみ（charで取得される）

*sString.Substring("n番目（index番号）から", "m文字取得");
あ
複数文字

*sString.Substring(1, 2);
例　１番目から２文字取得

*,,,
いう

*,,,
パターン１
Console.WriteLine( string.Concat(sString .Reverse()) );　おえういあ
パターン２（LINQを使用しているため「using System.Linq」を読み込む）
Console.WriteLine( new string(sString.Reverse().ToArray()) );　おえういあ

*}
ループ内容

*▼「”」のエスケープ処理*$"私の名前は\"{Name}\"です"
私の名前はhogeです

*▼「{}」のエスケープ処理
私の名前は"hoge"です


*if (this != Instance)
他のGameObjectにアタッチされているか調べる.
アタッチされている場合は破棄する.

*Debug.LogWarning(typeof(T) +
Destroy(this.gameObject);

*Began = 0,
以下は UnityEngine.TouchPhase の値に対応


*var assetPath = AssetDatabase.GetAssetPath(obj);![SpriteAtlasInspector.PNG](https:
qiita-image-store.s3.amazonaws.com016088daacc87f-3ef1-fb1c-7495-804062243688.png)


*Matcher Number = '0'.To('9');
整数値

*Matcher DivExp = Number + '/' + Number;
除算

*Matcher Number = '0'.To('9');
整数値

*RecursionMatcher DivExp = new RecursionMatcher();
「除算」のマッチャーを作る。(但し中身は空っぽ)

*DivExp.Inner = ((Number | DivExp) + '/' + Number);
「除算」の中身を設定する。

*Matcher Number = '0'.To('9');
整数値

*RecursionMatcher DivExp = new RecursionMatcher();
「除算」のマッチャーを作る。(但し中身は空っぽ)

*DivExp.Inner = ((Number | DivExp) + '/' + Number);
「除算」の中身を設定する。

*RecursionMatcher SubExp = new RecursionMatcher();
「減算」のマッチャーを作る。(但し中身は空っぽ)

*SubExp.Inner = ((Number | DivExp | SubExp) + '-' + (Number | DivExp));
「減算」の中身を設定する。

*Matcher Number = '0'.To('9');
整数値

*RecursionMatcher DivExp = new RecursionMatcher();
「除算」のマッチャーを作る。(但し中身は空っぽ)

*DivExp.Inner = ((Number | DivExp) + '/' + Number);
「除算」の中身を設定する。

*RecursionMatcher SubExp = new RecursionMatcher();
「減算」のマッチャーを作る。(但し中身は空っぽ)

*SubExp.Inner = ((Number | DivExp | SubExp) + '-' + (Number | DivExp));
「減算」の中身を設定する。

*RecursionMatcher LShiftExp = new RecursionMatcher();*// 「左シフト演算」の中身を設定する。
「左シフト演算」のマッチャーを作る。(但し中身は空っぽ)

*LShiftExp.Inner = ((Number | DivExp | SubExp | LShiftExp) + "<<" + (Number | DivExp | SubExp));*,,,
「左シフト演算」の中身を設定する。


*Test("
\"''\"\"\"'''\"'''", "-");


*private const string EndPointHarvest = "http:
harvest.soracom.io";

*client.Dispose();
HTTPクライアントインスタンスを破棄

*private async void btnSend_ClickAsync(object sender, EventArgs e)*{txtResponse.Text = string.Empty;var json = "{\"element1\":\"" + trackBar1.Value.ToString() + "\", \"element2\":\"" + trackBar2.Value.ToString() + "\"}";var content = new StringContent(json, Encoding.UTF8, @"application/json");var response = await client.PostAsync(EndPointHarvest, content);txtResponse.Text = response.ReasonPhrase;}
Harvestへ送信


*/** 中略 **/
ファイルを展開

*string mediaDir = unzipDir + "/" + type + "/media";
解凍したフォルダから画像ファイルを取り出す

*Directory.Delete(unzipDir, true);
zipファイルと解凍したフォルダ削除


*var myClass2 = TinyhandSerializer.Deserialize<MyClass>(b, TinyhandSerializerOptions.Standard.WithCompression(TinyhandCompression.Lz4));
Same as TinyhandSerializerOptions.Lz4


*+ (fparam.external * deltaTime)
外力による移動量

*nextTail = tposition + normalize(nextTail - tposition) * fparam.m_length;
長さをboneLengthに強制

*var normal = normalize(dir);
ヒット。Colliderの半径方向に押し出す

*nextTail = tposition + normalize(posFromCollider - tposition) * fparam.m_length;
長さをboneLengthに強制

*public static void Register(GameObject target, VRMSpringBone bone)*{VRMSpringBoneColliderGroup[] groups = bone.ColliderGroups;if (groups == null){return;}bone.enabled = false;foreach (var item in target.GetComponents<VRMSpringBoneJobGroup>()){if (item.groups.Count != groups.Length || item.m_center != bone.m_center){continue;}bool same = true;for (int j = 0; j < groups.Length; ++j){if (groups[j] != item.groups[j]){same = false;break;}}if (!same){continue;}item.Setup(bone);return;}{var item = target.AddComponent<VRMSpringBoneJobGroup>();item.Setup(bone);}}
VRMSprintBoneを登録する


*vh.AddUIVertexTriangleStream(vertices);
変更を加えたメッシュを戻す


*public class Hoge : MonoBehaviour*{// この Hoge クラスのステートマシンprivate ImtStateMachine<Hoge> stateMachine;// この Hoge クラスのアイドリング状態クラスprivate class IdleState : ImtStateMachine<Hoge>.State{// 何もしない状態クラスなら何も書かなくても良い（むしろ無駄なoverrideは避ける）}// この Hoge クラスのなにかを処理している状態クラスprivate class ProcessState : ImtStateMachine<Hoge>.State{// 状態へ突入時の処理はこのEnterで行うprotected internal override void Enter(){}// 状態の更新はこのUpdateで行うprotected internal override void Update(){}// 状態から脱出する時の処理はこのExitで行うprotected internal override void Exit(){}// 状態で発生した未処理の例外がキャッチされた時の処理はこのErrorで行うprotected internal override bool Error(Exception exception){// 未処理の例外をハンドリングしたのなら true を返すことで、ステートマシンはエラーから復帰しますreturn true;}// ステートマシンが状態の遷移をする前にステートマシンのイベント入力を処理するならこのGuardEventで行うprotected internal override bool GuardEvent(int eventId){// 特定のタイミングで遷移を拒否（ガード）するなら true を返せばステートマシンは遷移を諦めますif (!Context.isActiveAndEnabled){return true;}// 遷移を許可するなら false を返せばステートマシンは状態の遷移をしますreturn false;}// ステートマシンが前回のプッシュした状態に復帰する時の処理をするならこのGuardPopで行うprotected internal override bool GuardPop(){// 復帰を拒否（ガード）するなら true を返せばステートマシンは復帰を諦めますif (!Context.isActiveAndEnabled){return true;}// 復帰を許可するなら false を返せばステートマシンは復帰しますreturn false;}}}
状態を定義しているだけの何もしないクラス

*private ImtStateMachine<Hoge> stateMachine;
この Hoge クラスのステートマシン

*private class IdleState : ImtStateMachine<Hoge>.State*{// 何もしない状態クラスなら何も書かなくても良い（むしろ無駄なoverrideは避ける）}
この Hoge クラスのアイドリング状態クラス

*}
何もしない状態クラスなら何も書かなくても良い（むしろ無駄なoverrideは避ける）

*private class ProcessState : ImtStateMachine<Hoge>.State*{// 状態へ突入時の処理はこのEnterで行うprotected internal override void Enter(){}// 状態の更新はこのUpdateで行うprotected internal override void Update(){}// 状態から脱出する時の処理はこのExitで行うprotected internal override void Exit(){}// 状態で発生した未処理の例外がキャッチされた時の処理はこのErrorで行うprotected internal override bool Error(Exception exception){// 未処理の例外をハンドリングしたのなら true を返すことで、ステートマシンはエラーから復帰しますreturn true;}// ステートマシンが状態の遷移をする前にステートマシンのイベント入力を処理するならこのGuardEventで行うprotected internal override bool GuardEvent(int eventId){// 特定のタイミングで遷移を拒否（ガード）するなら true を返せばステートマシンは遷移を諦めますif (!Context.isActiveAndEnabled){return true;}// 遷移を許可するなら false を返せばステートマシンは状態の遷移をしますreturn false;}// ステートマシンが前回のプッシュした状態に復帰する時の処理をするならこのGuardPopで行うprotected internal override bool GuardPop(){// 復帰を拒否（ガード）するなら true を返せばステートマシンは復帰を諦めますif (!Context.isActiveAndEnabled){return true;}// 復帰を許可するなら false を返せばステートマシンは復帰しますreturn false;}}
この Hoge クラスのなにかを処理している状態クラス

*protected internal override void Enter()*{}
状態へ突入時の処理はこのEnterで行う

*protected internal override void Update()*{}
状態の更新はこのUpdateで行う

*protected internal override void Exit()*{}
状態から脱出する時の処理はこのExitで行う

*protected internal override bool Error(Exception exception)*{// 未処理の例外をハンドリングしたのなら true を返すことで、ステートマシンはエラーから復帰しますreturn true;}
状態で発生した未処理の例外がキャッチされた時の処理はこのErrorで行う

*return true;
未処理の例外をハンドリングしたのなら true を返すことで、ステートマシンはエラーから復帰します

*protected internal override bool GuardEvent(int eventId)*{// 特定のタイミングで遷移を拒否（ガード）するなら true を返せばステートマシンは遷移を諦めますif (!Context.isActiveAndEnabled){return true;}// 遷移を許可するなら false を返せばステートマシンは状態の遷移をしますreturn false;}
ステートマシンが状態の遷移をする前にステートマシンのイベント入力を処理するならこのGuardEventで行う

*return false;
遷移を許可するなら false を返せばステートマシンは状態の遷移をします

*protected internal override bool GuardPop()*{// 復帰を拒否（ガード）するなら true を返せばステートマシンは復帰を諦めますif (!Context.isActiveAndEnabled){return true;}// 復帰を許可するなら false を返せばステートマシンは復帰しますreturn false;}
ステートマシンが前回のプッシュした状態に復帰する時の処理をするならこのGuardPopで行う

*return false;
復帰を許可するなら false を返せばステートマシンは復帰します

*private ImtStateMachine<Hoge> stateMachine;
この Hoge クラスのステートマシン

*private class IdleState : ImtStateMachine<Hoge>.State*{}
この Hoge クラスのアイドリング状態クラス

*private class ProcessState : ImtStateMachine<Hoge>.State*{}
この Hoge クラスのなにかを処理している状態クラス

*stateMachine.AddTransition<遷移元の状態クラスの型, 遷移先の状態クラスの型>(入力値);
この関数を呼ぶと（遷移元状態クラスの状態で、入力値の入力をされた時に、遷移先状態クラスの状態へ遷移する）という定義になります。

*public enum StateEventId*{Finish,Reset,}
ステートマシンの入力（イベント）を判り易くするために列挙型で定義

*private ImtStateMachine<Hoge> stateMachine;
この Hoge クラスのステートマシン

*stateMachine.AddTransition<IdleState, ProcessState>((int)StateEventId.Finish);
ステートマシンのインスタンスを生成して遷移テーブルを構築
stateMachine = new ImtStateMachine<Hoge>(this);  自身がコンテキストになるので自身のインスタンスを渡す

*stateMachine.SetStartState<IdleState>();
起動ステートを設定（起動ステートは IdleState）

*private enum StateEventId*{Enable,Disable,}
ステートマシンのイベントID列挙型

*private ImtStateMachine<Player> stateMachine;
中略...
ステートマシン変数の定義、もちろんコンテキストは Player クラス

*private void Awake()
中略...
コンポーネントの初期化

*stateMachine = new ImtStateMachine<Player>(this);
中略...
ステートマシンの遷移テーブルを構築（コンテキストのインスタンスはもちろん自分自身）

*stateMachine.SetStartState<EnabledState>();
起動状態はDisabled

*stateMachine.Update();
中略...
ステートマシンを起動

*private void FixedUpdate()*{// ステートマシンの更新stateMachine.Update();}
Playerクラスと言っておきながら移動コンポーネントなのでFixedUpdateでステートマシンを回す

*stateMachine.Update();
ステートマシンの更新

*public void EnableMove()*{// ステートマシンに有効イベントを叩きつけるstateMachine.SendEvent((int)StateEventId.Enable);}
プレイヤーの操作を有効にします

*stateMachine.SendEvent((int)StateEventId.Enable);
ステートマシンに有効イベントを叩きつける

*public void DisableMove()*{// ステートマシンに無効イベントを叩きつけるstateMachine.SendEvent((int)StateEventId.Disable);}
プレイヤーの操作を無効にします

*stateMachine.SendEvent((int)StateEventId.Disable);
ステートマシンに無効イベントを叩きつける

*private class DisabledState : ImtStateMachine<Player>.State*{}
プレイヤーの移動も何も出来ない哀れな状態クラス

*private class EnabledState : ImtStateMachine<Player>.State*{// 状態の更新を行いますprotected override void Update(){// 中略...}}
プレイヤーの移動が許された状態クラス

*protected override void Update()*{// 中略...}
状態の更新を行います

*}
中略...

*private enum StateEventId*{Dead,Revive,}
状態イベントの定義

*public bool IsAlive => stateMachine.IsCurrentState<AliveState>();
現在の状態が生存状態なら生存していることを返すプロパティ

*stateMachine.SendEvent((int)StateEventId.Dead);
死亡イベントを送る

*stateMachine.SendEvent((int)StateEventId.Revive);
ステートマシンに復活イベントを送る

*}
中略...

*}
中略...

*private enum StateEventId*{Play,Miss,Retry,Exit,AllBlockBloken,Finish,}
ステートマシンのイベントID列挙型

*private ImtStateMachine<MainGameScene> stateMachine;
中略...
ステートマシン変数の定義、もちろんコンテキストは MainGameScene クラス

*private void Awake()*{// ステートマシンの遷移テーブルを構築（コンテキストのインスタンスはもちろん自分自身）stateMachine = new ImtStateMachine<MainGameScene>(this);stateMachine.AddTransition<ResetState, StandbyState>((int)StateEventId.Finish);stateMachine.AddTransition<StandbyState, PlayingState>((int)StateEventId.Play);stateMachine.AddTransition<PlayingState, MissState>((int)StateEventId.Miss);stateMachine.AddTransition<PlayingState, GameClearState>((int)StateEventId.AllBlockBloken);stateMachine.AddTransition<MissState, StandbyState>((int)StateEventId.Retry);stateMachine.AddTransition<MissState, GameOverState>((int)StateEventId.Exit);stateMachine.AddTransition<GameClearState, ResetState>((int)StateEventId.Finish);stateMachine.AddTransition<GameOverState, ResetState>((int)StateEventId.Finish);// 起動状態はResetstateMachine.SetStartState<ResetState>();}
コンポーネントの初期化

*stateMachine = new ImtStateMachine<MainGameScene>(this);
ステートマシンの遷移テーブルを構築（コンテキストのインスタンスはもちろん自分自身）

*stateMachine.SetStartState<ResetState>();
起動状態はReset

*stateMachine.Update();
ステートマシンを起動

*stateMachine.Update();
ステートマシンの更新

*stateMachine.SendEvent((int)StateEventId.Miss);
ステートマシンにミスイベントを送る


*Provider = new ServiceCollection().BuildServiceProvider();
ServiceProviderインスタンス生成

*Commands = new CommandService();
自身のアセンブリにコマンドの処理を構築する為、自身をCommandServiceに追加

*Client = new DiscordSocketClient();
Botアカウントに機能を追加

*var token = "";
BotアカウントLogin

*await Task.Delay(-1);
タスクを常駐

*int argPos = 0;
Botコマンドかどうか判定（判定条件は接頭辞"!"付き発言 or Botアカウントへのメンション）

*var context = new CommandContext(Client, message);
実行

*var resultText = new StringBuilder();
サイコロを振ってます・・・

*var embed = new EmbedBuilder();
結果一覧の埋め込み要素を作成

*await ReplyAsync($"{face}面ダイスを{throwCount}回振ったよ！\r\n合計は{summary}、平均値は{((double)summary / throwCount).ToString("#,0.00")}でした。", embed: embed.Build());
結果返却


*Invoke("BoolOn", 0.2f);
連続で切ってしまわないように少し遅らせる。適宜調整する

*attachedMeshFilter = GetComponent<MeshFilter>();
meshの取得

*DVector3 p1, p2, p3;
いろいろ、Vector3は精度のためにdoubleで扱えるようにしたDVector3を使用↓にclassあり

*p1 = new DVector3(transform.TransformPoint(attachedMesh.vertices[attachedMesh.triangles[i]]));*p2 = new DVector3(transform.TransformPoint(attachedMesh.vertices[attachedMesh.triangles[i + 1]]));
メッシュの3つの頂点を取得

*p1Bool = DVector3.Dot(new DVector3(cutPlane.normal), p1) + (double)cutPlane.distance > 0 ? true : false;
頂点がカットする面のどちら側にあるか

*DVector3 p, c1, c2;
3つの頂点が同じ側にない場合の処理１、以下仲間外れの頂点をp,それ以外をcとする

*DVector3 cross1 = p + (c1 - p) * (((double)cutPlane.distance + DVector3.Dot(new DVector3(cutPlane.normal), p)) / DVector3.Dot(new DVector3(cutPlane.normal), p - c1));
カットした面に生じる新しい頂点を計算、カットする平面の法線方向に対するpとcの距離の比からc-pの長さを決める

*Vector2 cross1Uv = Vector2.Lerp(attachedMesh.uv[attachedMesh.triangles[i + n1]], attachedMesh.uv[attachedMesh.triangles[i + n2]], (float)System.Math.Sqrt((cross1 - p).sqrMagnitude / (p - c1).sqrMagnitude));
新しい頂点のuvを計算、pとcの間で線形補間

*cross1 = new DVector3(transform.InverseTransformPoint(cross1.ToVector3()));*cross2 = new DVector3(transform.InverseTransformPoint(cross2.ToVector3()));
本来はDVector3内でやりたいがよくわからないのでVector3のInverseTransfromPointを使用

*crossVertices.Add(cross1);
断面をつくるために取っておく

*vertices1.Add(cross1);
p側のメッシュを追加

*vertices2.Add(cross2);
c側のメッシュを追加１

*vertices2.Add(cross2);
c側のメッシュを追加2

*vertices2.Add(cross1);
p側のメッシュを追加

*vertices1.Add(cross2);
c側のメッシュを追加１

*vertices1.Add(cross2);
c側のメッシュを追加2

*reduceMesh(ref vertices1, ref uvs1, ref normals1, cutPlane);
meshを減らす処理を行う。(断面以外の処理)、↓に関数あり

*if ((crossVertices[i] - crossVertices[k]).sqrMagnitude < delta || (crossVertices[i] - crossVertices[k + 1]).sqrMagnitude < delta*|| (crossVertices[i + 1] - crossVertices[k]).sqrMagnitude < delta || (crossVertices[i + 1] - crossVertices[k + 1]).sqrMagnitude < delta)
同一の頂点を持つかどうか→一直線上にある

*for (int i = 0; i < crossVertices.Count; i++)
断面の三角形を作る処理
等しい点を消去

*crossVertices.Insert(i, crossVertices[j]);
並び替え

*triangles1.Clear();
ひとつのtriangleについてそれぞれ3つずつの頂点を作っているため最後に順番通りにいれる

*var list1 = new List<Vector3>();
DVector3を通常のVector3に直す、もっと賢いやりかたがありそう

*GameObject obj = new GameObject("cut obj", typeof(MeshFilter), typeof(MeshRenderer), typeof(MeshCollider), typeof(Rigidbody), typeof(MeshCut));
カット後のオブジェクト生成、いろいろといれる

*Destroy(gameObject);
このオブジェクトをデストロイ

*verticeIndices.Clear();
まずは同一平面上にある三角形を見つけ出すが、基準となるiをとりあえず追加

*if (DVector3.Dot(DVector3.Cross((vertices[i + 1] - vertices[i]).normalized, (vertices[i + 2] - vertices[i + 1]).normalized).normalized,*DVector3.Cross((vertices[j + 1] - vertices[j]).normalized, (vertices[j + 2] - vertices[j + 1]).normalized).normalized) > 1 - delta)
同一の平面上にある三角形かどうか。deltaで調整

*for (int k = 0; k < verticeIndices.Count; k++)
平面上の三角形が2つ以上ある場合
pの入れ物に三角形を3つの直線にしていれる

*int sameLineCount = 0;
等しい直線を消す（面の外周でない線を消す）

*if (sameLineCount != verticeIndices.Count - 1)
同一平面上のn個の隣接する三角形にはn-1個の等しい直線があるはずが、ない場合(ここまでの処理がうまくいっていない場合)は処理をやめる
ここらへんは検討中　→　新しい処理追加

*if (returnBool2)
同一平面上にあるが三角形が隣接していない場合（本来同一平面上と判定されるはずの三角形が
同一平面上と判定されなかった(切断面の頂点を求める際にある2点がほぼ同じ値を取ってしまった場合)）
にcutPlaneをちょっとずらしてもう一度計算させる。
一度だけ処理させるように以下の分岐でゴニョゴニョ

*Cut(new Plane(cutPlane.normal, -cutPlane.normal * cutPlane.distance + new Vector3(0.02f, 0.02f, 0.02f)));
ずらす量は暫定的

*if ((pVertices[l] - pVertices[k]).sqrMagnitude < delta || (pVertices[l] - pVertices[k + 1]).sqrMagnitude < delta*|| (pVertices[l + 1] - pVertices[k]).sqrMagnitude < delta || (pVertices[l + 1] - pVertices[k + 1]).sqrMagnitude < delta)
同一の点を持つ→一直線上にある

*pVertices.Insert(k, pVertices[l]);
並び替え

*i += 3 * (pVertices.Count - 3);
処理した三角形を考慮してループの位置を調整

*pVertices.Clear();
初期化しておく

*int numRep(int i)*{if (i % 3 == 0){return 0;}else if (i % 3 == 1){return 1;}else if (i % 3 == 2){return 2;}else{return 0;}}
ループで使いたかった関数

*public class DVector3*{public double x;public double y;public double z;public DVector3(Vector3 a){x = a.x;y = a.y;z = a.z;}public DVector3(double a, double b, double c){x = a;y = b;z = c;}public double sqrMagnitude{get { return x * x + y * y + z * z; }}public Vector3 ToVector3(){return new Vector3((float)x, (float)y, (float)z);}public override string ToString(){return string.Format("({0:0.00000}, {1:0.00000}, {2:0.00000})", x, y, z);}public DVector3 normalized{get { return new DVector3(x / System.Math.Sqrt(this.sqrMagnitude), y / System.Math.Sqrt(this.sqrMagnitude), z / System.Math.Sqrt(this.sqrMagnitude)); }}public static double Dot(DVector3 a, DVector3 b){return a.x * b.x + a.y * b.y + a.z * b.z;}public static DVector3 Cross(DVector3 a, DVector3 b){return new DVector3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);}public static DVector3 operator -(DVector3 a, DVector3 b){return new DVector3(a.x - b.x, a.y - b.y, a.z - b.z);}public static DVector3 operator +(DVector3 a, DVector3 b){return new DVector3(a.x + b.x, a.y + b.y, a.z + b.z);}public static DVector3 operator *(DVector3 a, double b){return new DVector3(a.x * b, a.y * b, a.z * b);}public static DVector3 operator /(DVector3 a, double b){return new DVector3(a.x / b, a.y / b, a.z / b);}}
Vector3をdoubleで使うクラス、使う機能のみ

*void OnTriggerEnter(Collider other)
動く方向で切断する場合
private Vector3 prePos = Vector3.zero;
private Vector3 prePos2 = Vector3.zero;
void FixedUpdate ()
{
prePos = prePos2;
prePos2 = transform.position;
}
このコンポーネントを付けたオブジェクトのCollider.IsTriggerをONにする

*var cutPlane = new Plane (transform.right, transform.position);*//動きで切断する場合
一方向のみで切断する方法、方向については適宜変更

*//var cutPlane = new Plane (Vector3.Cross(transform.forward.normalized, prePos - transform.position).normalized, transform.position);*meshCut.Cut(cutPlane);
動きで切断する場合


*}
初期化後の処理


*services.AddProgressiveWebApp();
←これを追加


*IdentityResult newUser = await _userManager.CreateAsync(applicationUser,user.Password);
Create new user

*public void ConfigureServices(IServiceCollection services)*{//Sqlservices.AddDbContext<JetonModelContext>(options =>options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));services.AddDbContext<ApplicationDbContext>(options =>options.UseSqlServer(Configuration.GetConnectionString("UserDabtaseConnection")));services.AddIdentity<ApplicationUserDataModel, IdentityRole>().AddEntityFrameworkStores<ApplicationDbContext>().AddUserManager<UserManager<ApplicationUserDataModel>>().AddDefaultTokenProviders();services.Configure<IdentityOptions>(options =>{// Password settingsoptions.Password.RequireDigit = false;options.Password.RequiredLength = 6;options.Password.RequireNonAlphanumeric = false;options.Password.RequireUppercase = false;options.Password.RequireLowercase = false;options.Password.RequiredUniqueChars = 3;// Lockout settingsoptions.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(30);options.Lockout.MaxFailedAccessAttempts = 5;options.Lockout.AllowedForNewUsers = true;// User settingsoptions.User.RequireUniqueEmail = true;});services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();services.AddTransient<IAccountHandler, AccountHandler>();services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);// Register the Swagger generator, defining 1 or more Swagger documentsservices.AddSwaggerGen(c =>{c.SwaggerDoc("v1", new Info{Title = "{title}",Version = "1",Description = "{description}",Contact = new Contact{Name = "{name}",Email = "{email}",Url = "{url}"}});c.OperationFilter<AddAuthorizationHeaderParameterOperationFilter>();// Set the comments path for the Swagger JSON and UI.string xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";string xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);c.IncludeXmlComments(xmlPath);});}
This method gets called by the runtime. Use this method to add services to the container.

*services.AddDbContext<JetonModelContext>(options =>options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
Sql

*services.AddSwaggerGen(c =>{c.SwaggerDoc("v1", new Info{Title = "{title}",Version = "1",Description = "{description}",Contact = new Contact{Name = "{name}",Email = "{email}",Url = "{url}"}});
Register the Swagger generator, defining 1 or more Swagger documents

*string xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
Set the comments path for the Swagger JSON and UI.

*public void Configure(IApplicationBuilder app, IHostingEnvironment env)*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseHsts();}// Enable middleware to serve generated Swagger as a JSON endpoint.app.UseSwagger();// Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.),// specifying the Swagger JSON endpoint.app.UseSwaggerUI(c =>{c.SwaggerEndpoint("/swagger/v1/swagger.json", "Jeton API V1");c.RoutePrefix = string.Empty;});app.UseAuthentication();app.UseHttpsRedirection();app.UseMvc();}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*// specifying the Swagger JSON endpoint.*app.UseSwaggerUI(c =>
Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.),

*app.UseSwaggerUI(c =>{c.SwaggerEndpoint("/swagger/v1/swagger.json", "Jeton API V1");
specifying the Swagger JSON endpoint.


*xmlns:x="http:
schemas.microsoft.comwinfx2009xaml"

*Compass.ReadingChanged += Compass_ReadingChanged;
値を取得したときのイベントハンドラをセット

*Compass.Start(SensorSpeed.UI);
コンパス値の取得開始

*private void Compass_ReadingChanged(object sender, CompassChangedEventArgs e)*{var data = e.Reading;//ラベルに表示LabelCompass.Text = data.HeadingMagneticNorth.ToString();}
値を取得したときに実行される

*LabelCompass.Text = data.HeadingMagneticNorth.ToString();
ラベルに表示


*connection.Open();
データベースと接続

*command.Connection = connection;
コマンドの組み立て

*using (SqlDataReader rdr = command.ExecuteReader()){while (rdr.Read()){ひたすら詰め替えるOrderHeader model = new OrderHeader();
SQLの実行

*OrderHeader model = new OrderHeader();
ひたすら詰め替える

*connection.Open();
データベースと接続

*return connection.Query<OrderHeader>(selectQuery).ToList();
Dapperでマッピング

*return DBSimple.SimpleMap<OrderHeader>(connectionString, selectQuery);
DBSimpleでマッピング


*public void ConfigureServices(IServiceCollection services)*{services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();//Sqlservices.AddDbContext<ApplicationDbContext>(options =>options.UseSqlServer(Configuration.GetConnectionString("UserDabtaseConnection")));// ADDEDservices.AddIdentity<ApplicationUserDataModel, IdentityRole>().AddEntityFrameworkStores<ApplicationDbContext>().AddDefaultTokenProviders();// Register the Swagger generator, defining 1 or more Swagger documentsservices.AddSwaggerGen(c =>{c.SwaggerDoc("v1", new Info{Title = "{title}",Version = "1",Description = "{description}",Contact = new Contact{Name = "{name}",Email = "{email}",Url = "{url}"}});c.OperationFilter<AddAuthorizationHeaderParameterOperationFilter>();// Set the comments path for the Swagger JSON and UI.string xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";string xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);c.IncludeXmlComments(xmlPath);});}
This method gets called by the runtime. Use this method to add services to the container.

*services.AddDbContext<ApplicationDbContext>(options =>options.UseSqlServer(Configuration.GetConnectionString("UserDabtaseConnection")));
Sql

*services.AddSwaggerGen(c =>{c.SwaggerDoc("v1", new Info{Title = "{title}",Version = "1",Description = "{description}",Contact = new Contact{Name = "{name}",Email = "{email}",Url = "{url}"}});
Register the Swagger generator, defining 1 or more Swagger documents

*string xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
Set the comments path for the Swagger JSON and UI.

*public void Configure(IApplicationBuilder app, IHostingEnvironment env)*{if (env.IsDevelopment()){app.UseDeveloperExceptionPage();}else{app.UseHsts();}// Enable middleware to serve generated Swagger as a JSON endpoint.app.UseSwagger();// Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.),// specifying the Swagger JSON endpoint.app.UseSwaggerUI(c =>{c.SwaggerEndpoint("/swagger/v1/swagger.json", "{name}");c.RoutePrefix = string.Empty;});// ADDEDapp.UseAuthentication();app.UseHttpsRedirection();app.UseMvc();}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*// specifying the Swagger JSON endpoint.*app.UseSwaggerUI(c =>
Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.),

*app.UseSwaggerUI(c =>{c.SwaggerEndpoint("/swagger/v1/swagger.json", "{name}");
specifying the Swagger JSON endpoint.


*if (reqObj["event"]["namespace"].Value<string>() == "AudioPlayer")
オーディオイベントの制御
Clovaでのオーディオ再生が終わった際に呼び出される

*cache.StopRequest.BeforId = beforeId;*cache.StopRequest.IsPaused = false;
DBに存在する停止レコードに、直近の再生済みオーディオのIDを更新する

*response.Response.Directives.Add(GetAudioResponseDirective(beforeId, "一時停止中", Consts.SilentAudioFileUrl));*response.ShouldEndSession = true;
一時停止状態の場合は無音を流す（無限ループ）

*await PlayStatusService.DeleteAsync(cache);
キャッシュ削除

*await AddAudioPlayAndPushPictureAsync(response, userId, null, beforeId, log);*}
次のオーディオ再生（画像送付があればそれも）を実施

*cache.StopRequest.IsStopped = true;
再生中断された場合

*再生開始時はStopped=falseで登録if (cache?.StopRequest == null){await PlayStatusService.AddCacheAsync(userId, beforeId);
再生開始OK：DBに記録


*SetScale(MaxScale);
サイズを最大に

*nowScale = scale;
Spriteにスケールを設定

*SetScale(Mathf.Max(NormalScale, nowScale - (ScaleSpeed * Time.deltaTime)));
サイズが大きければ元のサイズまで徐々に戻す


*if (parent == null)
戻る遷移の場合は parent が null


*Debug.LogError (string.Format ("Fail Whale!\n{0}", www.error));
エラーを表示


*CompressStream compressStream;*InOutStream CreateStream(Stream baseStream){// baseStreamストリームを包む// 例えば、何かを圧縮するストリームを生成するcompressStream = new CompressStream(baseStream);// 何かを圧縮するストリームを包んだInOutStream(System.IO.Stream)を返す// 入力側は圧縮するのでcompressStreamだけど、// 出力側は圧縮しないのでbaseStreamそのままを引数に与えるreturn new InOutStream(compressStream, baseStream);}}
例えば、何か圧縮するストリームだとする。

*compressStream = new CompressStream(baseStream);
baseStreamストリームを包む
例えば、何かを圧縮するストリームを生成する

*return new InOutStream(compressStream, baseStream);
何かを圧縮するストリームを包んだInOutStream(System.IO.Stream)を返す
入力側は圧縮するのでcompressStreamだけど、
出力側は圧縮しないのでbaseStreamそのままを引数に与える


*EditorGUILayout.PropertyField(this.serializedPropertyB);
取得できない.なんでなん？
var propertyBName = this.propertyB.FindPropertyRelative("name");

*serializedObjectB.Update();
Bのメンバを更新する為ちゃんと実行しておきます.

*serializedObjectB.ApplyModifiedProperties();*}
Bのメンバを更新する為ちゃんと実行しておきます.


*XmlSerializeUtility.Serialize(CreateConfig(), path);
シリアライズ

*SampleAppConfig config = XmlSerializeUtility.Deserialize<SampleAppConfig>(path);
デシリアライズ

*System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema()*{return null;}
これらのメンバはアプリケーションから直接利用するものではないため、明示的に実装しています。

*[XmlType("Item")]
シリアライズされるときのタグを XmlType 属性で指定しています。

*DatabaseConfig db1 = new PostgreSqlConfig{ConnectionString = "User ID=user1; Password=password1; Host=localhost; Database=sampleDb1;",
PostgreSqlConfig クラスのインスタンスを生成


*int medal = 0;
Medal枚数退避エリア（表示するのはこっち）

*void Start () {this.medalText = GameObject.Find("Medal");}
初期化

*void Update () {medalText.GetComponent<Text>().text = "MEDAL: " + medal.ToString("D1");}
常時動作

*public void InsertMedal()*{this.medalSwap -= 3;this.medal = this.medalSwap;}
bet枚数反映処理

*public void GetMedal(int koyaku)
抽選結果をもとにwin枚数を返すメソッド

【memo】
それぞれの小役に対応する番号とwin枚数は以下の通り。
0：ＢＲ　0
1：リプ　3
2：チェ　4
3：ベル　10
4：ｽｲｶ 　15
5：バー　150
6：赤７　350
7：青７　711

*public void WinMedal()*{this.medal = this.medalSwap;}
medalSwapに入れたwin枚数含む現時点でのMedal枚数をmedalに反映する処理

*private int GetKoyaku(int lottery)
抽選結果から小役振り分け（ここ次第で勝ち負けが大きく変わる）
【memo】
それぞれの小役に対応する番号と対応する抽選結果の範囲は以下の通り。
0：ＢＲ　0～769　（約1.3分の1）
1：リプ　770～894（8分の1）
2：チェ　945～984（20分の1）
3：ベル　945～984（25分の1）
4：ｽｲｶ   985～992（125分の1）
5：バー　993～996（250分の1）
6：赤７　997～998（500分の1）
7：青７　999     （1000分の1）

*//            else if (lottery >= 770 && lottery <= 894) return 1;*//            else if (lottery >= 895 && lottery <= 944) return 2;
if (lottery >= 0 && lottery <= 769) return 0;

*//            else if (lottery >= 895 && lottery <= 944) return 2;*//            else if (lottery >= 945 && lottery <= 984) return 3;
else if (lottery >= 770 && lottery <= 894) return 1;

*//            else if (lottery >= 945 && lottery <= 984) return 3;*//            else if (lottery >= 985 && lottery <= 992) return 4;
else if (lottery >= 895 && lottery <= 944) return 2;

*//            else if (lottery >= 985 && lottery <= 992) return 4;*//            else if (lottery >= 993 && lottery <= 996) return 5;
else if (lottery >= 945 && lottery <= 984) return 3;

*//            else if (lottery >= 993 && lottery <= 996) return 5;*//            else if (lottery >= 997 && lottery <= 998) return 6;
else if (lottery >= 985 && lottery <= 992) return 4;

*//            else if (lottery >= 997 && lottery <= 998) return 6;*//            else if (lottery <= 999) return 7;
else if (lottery >= 993 && lottery <= 996) return 5;

*//            else if (lottery <= 999) return 7;*if      (lottery >=   0 && lottery <= 249) return 1;
else if (lottery >= 997 && lottery <= 998) return 6;

*if      (lottery >=   0 && lottery <= 249) return 1;*else if (lottery >= 250 && lottery <= 499) return 5;
else if (lottery <= 999) return 7;


*return isSuccess.ToString();
ログインの成否 (成功="True" or 失敗="False")


*[Obsolete("Old version. Don't use.")]
メソッドを対象に属性付与
Obsoleteの説明は後述

*}
何らかの処理

*[Conditional("DEBUG"), Obsolete("Old version. Don't use.")]
Conditionalの説明も後述

*}
何らかの処理

*[StringLength(15, ErrorMessage = "会社名は15文字以内で記述してください。")]public String OfficeName,,,[Required(ErrorMessage="入力必須項目です。"), StringLength(20, ErrorMessage="名前は20桁以内で入力してください")]String OfficeName;
StringLengthの説明も後述

*[method: CustomAttribute]
getメソッドに対応

*[return: Required]
getの返却値に対応

*[method: CustomAttribute]
setメソッドに対応

*[param: Required]*set { }
setが受け取るvalue引数に対応

*[field: CustomAttribute]*public int AutoProp { get; }
バッキングフィールドを対象とする

*[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct,AllowMultiple = true, Inherited = false)]
この場合はクラスと構造体に対し属性の設定が可能で、複数回付与でき、属性のターゲットが継承時には属性は引き継がれません。

*private string Name;
作者名

*public float Version;*public AuthorAttribute(string name) { Name = name; }
対象が動作するバージョン


*Console.ReadKey();
コンソールが閉じないように。


*protected override void Start()*{base.Start();sp = new Stopwatch();NativeArray = GameObject.Find(nameof(NativeArray)).GetComponent<Text>();Array = GameObject.Find(nameof(Array)).GetComponent<Text>();UnsafeArray = GameObject.Find(nameof(UnsafeArray)).GetComponent<Text>();Ptr = GameObject.Find(nameof(Ptr)).GetComponent<Text>();UnsafePtr = GameObject.Find(nameof(UnsafePtr)).GetComponent<Text>();}
Start is called before the first frame update


*Observable.
*オペレータ*.Subscribe(したい処理);

*Observable.Range(0,10)
偶数のときだけ処理をする

*Observable.Range(0,10)
10倍にする（処理の中で変化させた値を使用できる）

*var s = new Subject<nt>();
入力
登録

*s.OnNext();
発火

*OnNext
出力

*var t = Observable.Timer(TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(1));
5秒後に１秒間隔で値が発行される


*public int count;
生成数

*struct Group*{[ReadOnly]public SharedComponentDataArray<Cube> Spawner;public ComponentDataArray<Position> Position;public EntityArray Entity;public readonly int Length;}
要求リスト一覧

*// so before we get to the next spawner we have to reinject them*UpdateInjectedComponentGroups();
Instantiate & AddComponent & RemoveComponent calls invalidate the injected groups,


*if (new System.Random().Next() % 2 == 0)
占い結果を返す。今回は適当占いなのでランダムにどちらか
(本来はここでスロットの星座を受け取ってそれに基づいた処理を行う)

*response.AddText("あなたの星座を教えてください。占ってあげます。");
使い方

*response.AddText("よくわかりませんでしたが、まあまあだと思います。");
その他のインテントの場合

*response.AddText("よくわかりませんでしたが、たぶんラッキーな1日になると思いますよ。");
エラー

*response.AddText("よくわかりませんでしたが、きっと大丈夫ですよ。");
エラー


*public bool HasName() => string.IsNullOrEmpty(_Name);
戻り値があるメソッド

*class Student : Person*{private string _Name;private int _Number;private int _Score;public string Name => _Name;public int Number => _Number;public int Score => _Score;public Student(string name, int number){_Name = name;_Number = number;}public void SetScore(int score) => _Score = score;public bool HasName() => string.IsNullOrEmpty(_Name);public int CompareNumber(Student student) => _Number.CompareTo(student?.Number ?? 0);}
48行 → 17行

*class Teacher : Person*{private List<Student> _Students = new List<Student>();public List<Student> Students => _Students;public Teacher(IEnumerable<Student> students){_Students.AddRange(students);}public double AverageScore() => _Students.Select(student => student.Score).DefaultIfEmpty(0).Average();}
20行 → 10行

*class Test*{public void ResetScore(Student student) => student?.SetScore(0);public IEnumerable<Student> CreateSample(int count) => Enumerable.Range(1, count).Select(number => new Student($"生徒{number.ToString()}", number));public IEnumerable<Student> GetAllStudents(IEnumerable<Teacher> teachers) => teachers.SelectMany(teacher => teacher.Students);public IEnumerable<String> GetStudentNames(IEnumerable<Person> people) => people.OfType<Student>().Select(student => student.Name);}
41行 → 7行


*public class MoveScript : MonoBehaviour*{private Vector3 changePosition;void Update(){//Move sphere straightchangePosition = new Vector3(0.1f,0.0f,0.0f);transform.position += changePosition;}}
Transform.position example


*var videosList = youtubeService.Videos.List("LiveStreamingDetails");
引数で取得したい情報を指定

*var videoListResponse = videosList.Execute();
動画情報の取得

*return null;
動画情報取得できない場合はnullを返す


*var t = SendCommandToESP8266Async("GPIOSW");
処理に時間がかかる場合があるのでawaitせずに実行

*Log($"{client.Client.RemoteEndPoint},404,{path}");
コマンド受信時はわざとエラーを返すことで、VRC_Panoramaが再度接続してくるようにする。


*Matcher Rahmen = ("醤油"._() | "みそ"._() | "豚骨"._()) + "ラーメン"._();
(中略)

*Matcher Rahmen = ("醤油"._() | "みそ"._() | "豚骨"._()) + "ラーメン"._();
(中略)

*Matcher Numeric = '0'.To('9');
数字１文字

*Matcher UpperCaseAlphabet = 'A'.To('Z');
大文字１文字

*Matcher LowerCaseAlphabet = 'a'.To('z');
小文字１文字

*Matcher WordChar = Numeric | UpperCaseAlphabet | LowerCaseAlphabet ;
数字か大文字か小文字１文字

*Matcher Curry = Begin + "カレーライス" + End;
(中略)

*Matcher Minus = '-'._();
マイナス記号

*Matcher Numeric = '0'.To('9');
数字

*Matcher IntegerValue = '0' | (Minus._01() + '1'.To('9') + Numeric._1Max());
整数値

*Matcher Numerics = Numeric._1Max();
ゼロで始まっても良い整数値

*Matcher RealPart = '.' + Numerics;
小数部

*Matcher Sign = Minus | '+';
正負の符号

*Matcher ExponentPart = ('e'._() | 'E') + Sign._01() + Numerics;
指数部

*Matcher RealNumber = IntegerValue + RealPart._01() + ExponentPart._01();
実数値

*Matcher Numeric = '0'.To('9');
数字１文字

*Matcher Alphabet = 'A'.To('Z') | 'a'.To('z');
アルファベット１文字

*Matcher Identifier = (Alphabet | '_') + (Alphabet | '_' | Numeric)._0Max();*,,,
識別子


*currentBaseState = anim.GetCurrentAnimatorStateInfo (0);
参照用のステート変数にBase Layer (0)の現在のステートを設定する


*namespace Main{public class Hello{public static void Main(){Console.WriteLine("hello world!");}}}
Mainという名前空間にHelloクラスが属している


*int Samples;
波サンプルデータの長さ

*for(int i = 2; i <= Samples; i *= 2)*if(Samples % i != 0 || Samples <= 0) throw new DomainException();
引数の値が2の自然数乗でなければ例外を投げる

*this.Samples = Samples;
波サンプルデータの長さを格納

*// 引数 Function には自作した窓関数を指定することができる*public double[] GetSpectrum(double[] WaveSamples, WindowFunction Window) {// 引数となる配列の長さが Samples に等しくなければ例外を投げるif(WaveSamples.Length != Samples) throw new SampleDataLengthException();// 返り値になる周波数成分データdouble[] Spectrum = new double[Samples];// 波サンプルに窓関数を掛けるfor(int i = 0; i < Samples; i++) WaveSamples[i] *= Window((double)i / Samples);// 離散フーリエ変換for(int i = 0; i < Samples; i++) {double re = 0, im = 0;for(int j = 0; j < Samples; j++) {double arg = -2 * Math.PI / Samples * i * j;re += Math.Cos(arg) * WaveSamples[j];im += Math.Sin(arg) * WaveSamples[j];}Spectrum[i] = Math.Sqrt(re * re + im * im);}// Spectrum を返すreturn Spectrum;}
周波数成分を取得するメソッド

*public double[] GetSpectrum(double[] WaveSamples, WindowFunction Window) {// 引数となる配列の長さが Samples に等しくなければ例外を投げるif(WaveSamples.Length != Samples) throw new SampleDataLengthException();// 返り値になる周波数成分データdouble[] Spectrum = new double[Samples];// 波サンプルに窓関数を掛けるfor(int i = 0; i < Samples; i++) WaveSamples[i] *= Window((double)i / Samples);// 離散フーリエ変換for(int i = 0; i < Samples; i++) {double re = 0, im = 0;for(int j = 0; j < Samples; j++) {double arg = -2 * Math.PI / Samples * i * j;re += Math.Cos(arg) * WaveSamples[j];im += Math.Sin(arg) * WaveSamples[j];}Spectrum[i] = Math.Sqrt(re * re + im * im);}// Spectrum を返すreturn Spectrum;}
引数 Function には自作した窓関数を指定することができる

*if(WaveSamples.Length != Samples) throw new SampleDataLengthException();*// 返り値になる周波数成分データ
引数となる配列の長さが Samples に等しくなければ例外を投げる

*double[] Spectrum = new double[Samples];
返り値になる周波数成分データ

*for(int i = 0; i < Samples; i++) WaveSamples[i] *= Window((double)i / Samples);*// 離散フーリエ変換
波サンプルに窓関数を掛ける

*return Spectrum;
Spectrum を返す

*int Samples;
波サンプルデータの長さ

*double[,] Twiddle;
回転因子

*int[] Bitreverse;
ビット逆順

*for(int i = 2; i <= Samples; i *= 2)*if(Samples % i != 0 || Samples <= 0) throw new DomainException();
引数の値が2の自然数乗でなければ例外を投げる

*this.Samples = Samples;
波サンプルデータの長さを格納

*Twiddle = new double[2, Samples / 2];*for(int i = 0; i < Samples / 2; i++) {double arg = -2.0 * Math.PI / Samples * i;Twiddle[0, i] = Math.Cos(arg);Twiddle[1, i] = Math.Sin(arg);}
回転因子を格納する

*Bitreverse = new int[Samples];*for(int i = 0; i < Samples; i++) {int Order = i, Reverse = 0;for(int j = Samples / 2; j >= 1; j /= 2) {Reverse += (Order % 2) * j;Order /= 2;}Bitreverse[i] = Reverse;}
ビット逆順を格納する

*// 引数 Function には自作した窓関数を指定することができる*public double[] GetSpectrum(double[] WaveSamples, WindowFunction Window) {// 引数となる配列の長さが Samples に等しくなければ例外を投げるif(WaveSamples.Length != Samples) throw new SampleDataLengthException();// 引数の波形データは予め虚数部に代入するdouble[] Wave_Re = new double[Samples], Wave_Im = WaveSamples;// ビット逆順をかけた波形データを実数部に入れ替える// 入れ替えたデータはその都度クリアしていく// ついでに窓関数をかけておくfor(int i = 0; i < Samples; i++) {Wave_Re[i] = Wave_Im[Bitreverse[i]] * Window((double)Bitreverse[i] / Samples);Wave_Im[Bitreverse[i]] = 0.0;}// バタフライ演算をするfor(int i = 1; i < Samples; i *= 2)for(int j = 0; j < Samples; j += i * 2)for(int k = 0; k < i; k++) {int a = j + k;int b = a + i;int w = Samples / (2 * i) * k;doublear = Wave_Re[a] + Wave_Re[b] * Twiddle[0, w] - Wave_Im[b] * Twiddle[1, w],ai = Wave_Im[a] + Wave_Re[b] * Twiddle[1, w] + Wave_Im[b] * Twiddle[0, w],br = Wave_Re[a] - Wave_Re[b] * Twiddle[0, w] + Wave_Im[b] * Twiddle[1, w],bi = Wave_Im[a] - Wave_Re[b] * Twiddle[1, w] - Wave_Im[b] * Twiddle[0, w];Wave_Re[a] = ar;Wave_Im[a] = ai;Wave_Re[b] = br;Wave_Im[b] = bi;}// 複素数形式の波形データの絶対値を返すfor(int i = 0; i < Samples; i++) Wave_Re[i] = Math.Sqrt(Wave_Re[i] * Wave_Re[i] + Wave_Im[i] * Wave_Im[i]);return Wave_Re;}
周波数成分を取得するメソッド

*public double[] GetSpectrum(double[] WaveSamples, WindowFunction Window) {// 引数となる配列の長さが Samples に等しくなければ例外を投げるif(WaveSamples.Length != Samples) throw new SampleDataLengthException();// 引数の波形データは予め虚数部に代入するdouble[] Wave_Re = new double[Samples], Wave_Im = WaveSamples;// ビット逆順をかけた波形データを実数部に入れ替える// 入れ替えたデータはその都度クリアしていく// ついでに窓関数をかけておくfor(int i = 0; i < Samples; i++) {Wave_Re[i] = Wave_Im[Bitreverse[i]] * Window((double)Bitreverse[i] / Samples);Wave_Im[Bitreverse[i]] = 0.0;}// バタフライ演算をするfor(int i = 1; i < Samples; i *= 2)for(int j = 0; j < Samples; j += i * 2)for(int k = 0; k < i; k++) {int a = j + k;int b = a + i;int w = Samples / (2 * i) * k;doublear = Wave_Re[a] + Wave_Re[b] * Twiddle[0, w] - Wave_Im[b] * Twiddle[1, w],ai = Wave_Im[a] + Wave_Re[b] * Twiddle[1, w] + Wave_Im[b] * Twiddle[0, w],br = Wave_Re[a] - Wave_Re[b] * Twiddle[0, w] + Wave_Im[b] * Twiddle[1, w],bi = Wave_Im[a] - Wave_Re[b] * Twiddle[1, w] - Wave_Im[b] * Twiddle[0, w];Wave_Re[a] = ar;Wave_Im[a] = ai;Wave_Re[b] = br;Wave_Im[b] = bi;}// 複素数形式の波形データの絶対値を返すfor(int i = 0; i < Samples; i++) Wave_Re[i] = Math.Sqrt(Wave_Re[i] * Wave_Re[i] + Wave_Im[i] * Wave_Im[i]);return Wave_Re;}
引数 Function には自作した窓関数を指定することができる

*if(WaveSamples.Length != Samples) throw new SampleDataLengthException();*// 引数の波形データは予め虚数部に代入する
引数となる配列の長さが Samples に等しくなければ例外を投げる

*double[] Wave_Re = new double[Samples], Wave_Im = WaveSamples;
引数の波形データは予め虚数部に代入する

*for(int i = 0; i < Samples; i++) {
ビット逆順をかけた波形データを実数部に入れ替える
入れ替えたデータはその都度クリアしていく
ついでに窓関数をかけておく

*for(int i = 1; i < Samples; i *= 2)*for(int j = 0; j < Samples; j += i * 2)
バタフライ演算をする

*for(int i = 0; i < Samples; i++) Wave_Re[i] = Math.Sqrt(Wave_Re[i] * Wave_Re[i] + Wave_Im[i] * Wave_Im[i]);*return Wave_Re;
複素数形式の波形データの絶対値を返す


*int C_num = B_C_request[B_num];
B_numからいらいを受けた人


*string url = "http:
localhost:5000bikes" + id + "";


*public class ReceivedCallback : UnityEngine.Events.UnityEvent<string>*{}
UnityEventの引数指定用のダミークラス

*public static ReceivedCallback OnReceivedEvent = new ReceivedCallback();
データを受信したときに発火されるイベント

*OnReceivedEvent.Invoke(text);
登録したイベントを発火

*public int baudRate = 115200;
ボーレート (bit/sec)

*public void Open(string portName)*{if(isRunning) return;currentPortName = portName;serialPort = new SerialPort(portName, baudRate, Parity.None, 8, StopBits.One);serialPort.Open();isRunning = true;task = ReadAsync();}
ポート名を指定してSerialPortを開く


*Console.WriteLine($"{a[i1]}, {a[i2]}");
"3, 6"


*Action<in DateTime> action;
コンパイルエラーになる


*public GameObject _attakTarget;
ダメージを与える敵をアタッチする

*var damagetarget = _attakTarget.GetComponent<IDamagable>();
_attakTarget にセットされたオブジェクトから、IDamagable を呼ぶ


*public byte d;
1byte


*this.webView.Post(() =>*{this.webView.LoadUrl($"javascript:MyCalc.onResult({result});");});
メインスレッドから呼ばないとエラー

*webView.Configuration.UserContentController.AddScriptMessageHandler(this, "MyHeavyAdd");
JavaScript から呼び出すハンドラを追加。

*var script ="MyCalc = {};" +
JavaScript 側で MyCalc.heavyAdd(n) が呼ばれた時に window.webkit.messageHandlers.xxx を呼ぶようにする。

*await Task.Delay(1000);
時間のかかる処理

*var webView = this.NativeView as WKWebView;*webView.EvaluateJavaScript($"MyCalc.onResult({result});", null);
結果を通知


*anim.SetFloat("speed", v);
Animator側で設定している"Speed"パラメタにvを渡す


*#if UNITY_EDITOR*if (Input.GetMouseButtonDown(0))
エディタ上

*#else
端末上での動作


*if (person != null)
ここでnullチェックをせずに person を使用しようとすると警告が表示される。
Console.WriteLine(person.age);

*}
なんやかんや

*break;
numの数値が1～7の範囲かどうか

*Console.WriteLine($"{num[fromBegin]}, {num[fromEnd]}");
出力結果は 1,7


*si.RedirectStandardError = true;
ウィンドウ表示を完全に消したい場合
si.CreateNoWindow = true;

*proc.OutputDataReceived += (sender, ev) =>*{Console.WriteLine($"stdout={ev.Data}");};
コールバックの設定

*ctoken.Cancel();
プロセスが終了すると呼ばれる

*proc.Start();
プロセスの開始

*proc.BeginErrorReadLine();
非同期出力読出し開始

*ctoken.Token.WaitHandle.WaitOne();
終了まで待つ

*si.RedirectStandardError = true;
ウィンドウ表示を完全に消したい場合
si.CreateNoWindow = true;

*proc.Exited += (sender, ev) =>*{Console.WriteLine($"exited");// プロセスが終了すると呼ばれるctoken.Cancel();};
コールバックの設定

*ctoken.Cancel();
プロセスが終了すると呼ばれる

*proc.Start();
プロセスの開始


*note.eventTime = (int)(timeDifference * tempTempoList[j].tick) + tempoList[j].eventTime;
計算後のテンポ変更イベント時間+そこからの自分の時間


*0,
idThread


*namespace xcallbackurl*{[Register("AppDelegate")]public class AppDelegate : UIApplicationDelegate{// 略[Export("application:openURL:options:")]public override bool OpenUrl(UIApplication app, NSUrl url, NSDictionary options){var uri = new Uri(url.AbsoluteString);var query = HttpUtility.ParseQueryString(uri.Query);var xSuccess = query.Get("x-success");if (!string.IsNullOrEmpty(xSuccess)){app.OpenUrl(new NSUrl(xSuccess + "?hoge=fuga"), new NSDictionary(), null);}return true;}}}
略

*[Export("application:openURL:options:")]
略


*int line = int.Parse(Console.ReadLine());
自分の得意な言語で
Let's チャレンジ！！

*int answerNum = Array.IndexOf(haveMoneyArray, searchNum) + 1;
探したい文字のインデックス番号を取得

*int line1 = int.Parse(Console.ReadLine());
調べる文字と調べられる文字列を各配列に格納

*string[] NMK = Console.ReadLine().Split(' ');
自分の得意な言語で
Let's チャレンジ！！


*var obj = GetNullOrString();
半々の確率でnullか実体のあるstringを返してくれるメソッド

*}
nullではない場合if内部を通る

*//但しスコープはif文限りのため外からはstr変数を使えないことに注意*}
null時には型無し = string型では無いためif内部を通らない

*}
但しスコープはif文限りのため外からはstr変数を使えないことに注意


*var f = new int[H, W];
フィールド


*Label label;
UIのコントロールで、UIスレッドでしかアクセス不可

*));
ポイントは、「LoadFromFileの直後に回される」のではなく、
「LoadFromFileの直後に『UIスレッドが暇なときに回される』という処理を回す」
ということで、コードの雰囲気とは若干タイミングがずれている


*watcher.Query = new EventQuery($"SELECT * FROM RegistryKeyChangeEvent WHERE Hive='{Hive.Name}' AND KeyPath='{KeyPath}'");
キーを監視する場合

*watcher.Query = new EventQuery($"SELECT * FROM RegistryValueChangeEvent WHERE Hive='{Hive.Name}' AND KeyPath='{KeyPath}' AND ValueName='{ValueName}'");
値を監視する場合

*RegistryKeyWatcher watcher = new RegistryKeyWatcher(RegistryHive.LocalMachine, RegistryView.Registry64, @"SOFTWARE\\Test\\Watch");*watcher.RegistryKeyChanged += (sender, eventArgs) => { Console.WriteLine("Changed"); };
Registry64を使用

*RegistryKey baseKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry64);
Registry64をBaseKeyとして開いておく


*.UseUrls("http:
*:5000")   <- ここの行を追加


*string line = Console.ReadLine();
自分の得意な言語で
Let's チャレンジ！！

*var N = int.Parse(Console.ReadLine());
自分の得意な言語で
Let's チャレンジ！！

*startTimeArray = timeArray[0].Split(':');
工事開始時刻

*addHH = int.Parse(timeArray[1]);
工事時間（HH：時　MM：分）24時以上60分以上になる場合の処理

*Console.WriteLine(stringHH + ":" + stringMM);
工事終了時間


*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame

*void Start () {}
Use this for initialization

*void FixedUpdate () {current = Mathf.SmoothDamp(current,10,ref speed,2f);transform.position = new Vector3(current, 0, 0);}
Update is called once per frame


*GrpcEnvironment.SetLogger(new Grpc.Core.Logging.ConsoleLogger());
コンソールにログを表示させる

*var server = new global::Grpc.Core.Server{Services = { service },Ports = { new ServerPort("localhost", 12345, ServerCredentials.Insecure) }};
localhost:12345でListen

*server.Start();
MagicOnion起動

*Console.ReadLine();
コンソールアプリが落ちないようにReadLineで待つ

*const string roomName = "SampleRoom";
ルームは全員固定

*this.room = await this.Group.AddAsync(roomName);
ルームに参加&ルームを保持

*me = userName;
自分の名前も保持

*this.Broadcast(room).OnJoin(userName);
参加したことをルームに参加している全メンバーに通知

*await room.RemoveAsync(this.Context);
ルーム内のメンバーから自分を削除

*this.Broadcast(room).OnLeave(me);
退室したことを全メンバーに通知

*this.Broadcast(room).OnSendMessage(me, message);
発言した内容を全メンバーに通知

*public Text ChatText;
受信メッセージ

*public Button JoinOrLeaveButton;
入室・退室UI

*public Button SendMessageButton;
テキスト送信UI

*void Start()*{this._isJoin = false;//Client側のHubの初期化this._channel = new Channel("localhost:12345", ChannelCredentials.Insecure);this._chutHub = StreamingHubClient.Connect<IChatHub, IChatHubReceiver>(this._channel, this);//メッセージ送信ボタンはデフォルト非表示this.SendMessageButton.gameObject.SetActive(false);}
Start is called before the first frame update

*this._channel = new Channel("localhost:12345", ChannelCredentials.Insecure);
Client側のHubの初期化

*this.SendMessageButton.gameObject.SetActive(false);
メッセージ送信ボタンはデフォルト非表示

*void Update()*{}
Update is called once per frame

*this.SendMessageButton.gameObject.SetActive(false);
メッセージ送信ボタンを非表示に

*this.SendMessageButton.gameObject.SetActive(true);
メッセージ送信ボタンを表示

*if (!this._isJoin)*return;
入室してなかったら何もしない


*animal.Walk();
CatもDogもWalkを実装済み。


*"  categories are" + categories[ki]);
カテゴリを適当に表示する

*model_data.Dispose();
モデルデータの破棄

*static unsafe int[] ExtractTopKIndexList(float* first, float* last, int k)*{var q = new List<Tuple<float, int>>();for (var i = 0; first != last; first++, i++){q.Add(Tuple.Create(*first, i));}return q.OrderByDescending(_ => _.Item1).Take(k).Select(_ => _.Item2).ToArray();}
-------------------------------------------------


*var cl = new CoroutineList();
ロード処理を並列で実行する

*}
通信処理をごにょごにょ

*}
プレハブ読み込みをごにょごにょ

*}
その他並列で読み込みたいものをごにょごにょ


*void RequestTokenCallback(bool success) {if (!success) return;Application.OpenURL(Twity.Oauth.authorizeURL);}
Twityライブラリではリクエストトークンを取得した時点でOauth.authorizeURLに認可用URLが格納されます

*}
success == trueの時点でOauth.accessToken、Oauth.accessTokenSecret、Oauth.screenNameにはそれぞれの情報が格納されています。

*Twity.Oauth.accessToken = access_token;
access_tokenとaccess_token_secretが端末内に保存されている場合（＝認可済の場合）

*Dictionary<string, string> p = new Dictionary<string, string> {{"screen_name", Twity.Oauth.screenName}};
access_tokenが何らかの原因で正しくないものになっていないか確認するため、試しにユーザー情報を取得する

*PlayerPrefs.DeleteAll();*} else {
何らかの原因でaccess_token等がおかしい可能性があるので、一旦削除して最初からやりなおす

*}
認可は成功している

*Twity.Oauth.requestToken = request_token;
端末内にrequest_tokenがある場合、

*} else {
この状態はpin入力のシーンである場合があるので、入力用のUIを表示する

*GenerateRequestToken()
まだ何もない状態なので、request_tokenの取得を行う

*bool CheckAuthorizationInfo() {access_token = PlayerPrefs.GetString("access_token", "");access_token_secret = PlayerPrefs.GetString("access_token_secret", "");screen_name = PlayerPrefs.GetString("screen_name", "");if (string.IsNullOrEmpty(access_token) || string.IsNullOrEmpty(access_token_secret) || string.IsNullOrEmpty(screen_name)) {return false;} else {return true;}}
端末内にaccess_tokenとaccess_token_secretが保存されているか確認する

*bool CheckRequestToken() {request_token = PlayerPrefs.GetString("request_token", "");request_token_secret = PlayerPrefs.GetString("request_token_secret", "");if (string.IsNullOrEmpty(request_token) || string.IsNullOrEmpty(request_token_secret)) {return false;} else {return true;}}
端末内にrequest_tokenとrequest_token_secretが保存されているか確認する

*GetUserInfo("toofu__");
この時点で認証完了。試しに特定のユーザー情報を出力する


*var line = int.Parse(Console.ReadLine());
自分の得意な言語で
Let's チャレンジ！！

*string[] nameAge = Console.ReadLine().Split(' ');
nameAgeに名前と年齢を格納

*int age = int.Parse(nameAge[1]) + 1;
年齢に1歳加える


*Console.WriteLine(SharpDX.Diagnostics.ObjectTracker.ReportActiveObjects());
一覧表示


*Debug.WriteLine(date1.GetMonthDiff(date2));*Debug.WriteLine(date2.GetMonthDiff(date1));
拡張メソッド版

*Debug.WriteLine(DateTimeUtility.GetFiscalYear(date1, 4));
年度の開始月を引数で指定する

*Debug.WriteLine(date1.GetFiscalYear(4));
拡張メソッド版

*Debug.WriteLine(DateTimeUtility.GetFirstDateOfFiscalYear(date1, 4));
年度の開始月を引数で指定する

*Debug.WriteLine(date1.GetFirstDateOfFiscalYear(4));
拡張メソッド版

*Debug.WriteLine(DateTimeUtility.GetLastDateOfFiscalYear(date1, 4));
年度の開始月を引数で指定する

*Debug.WriteLine(date1.GetLastDateOfFiscalYear(4));
拡張メソッド版

*Debug.WriteLine(DateTimeUtility.GetFirstDateOfQuarter(date1, 4));
対象日付と年度の開始月を引数で指定する

*Debug.WriteLine(DateTimeUtility.GetFirstDateOfQuarter(2018, QuarterPeriod.First, 4));
年度, 四半期, 年度の開始月を引数で指定する

*Debug.WriteLine(date1.GetFirstDateOfQuarter(4));
拡張メソッド版

*Debug.WriteLine(DateTimeUtility.GetLastDateOfQuarter(date1, 4));
対象日付と年度の開始月を引数で指定する

*Debug.WriteLine(DateTimeUtility.GetLastDateOfQuarter(2018, QuarterPeriod.First, 4));
年度, 四半期, 年度の開始月を引数で指定する

*Debug.WriteLine(date1.GetLastDateOfQuarter(4));
拡張メソッド版

*Debug.WriteLine(date1.GetFirstDateOfYear());
拡張メソッド版

*Debug.WriteLine(date1.GetLastDateOfYear());
拡張メソッド版

*Debug.WriteLine(date1.GetFirstDateOfMonth());
拡張メソッド版

*Debug.WriteLine(date1.GetLastDateOfMonth());
拡張メソッド版

*Debug.WriteLine(date1.GetFirstDateOfWeek());
拡張メソッド版

*Debug.WriteLine(date1.GetLastDateOfWeek());
拡張メソッド版

*Debug.WriteLine(date1.GetDateOfCurrentWeek(DayOfWeek.Friday));
拡張メソッド版

*Debug.WriteLine(date1.GetDateOfNextWeek(DayOfWeek.Friday));
拡張メソッド版


*using System.Collections.Generic;
List


*x = x + 1;
ここはC# 5.0まででもOK


*using Microsoft.Bot.Connector.Authentication;
認証

*_isProduction = env.IsProduction();
現在の実行環境がProductionかチェック

*var builder = new ConfigurationBuilder().SetBasePath(env.ContentRootPath).AddJsonFile("appsettings.json", optional: true, reloadOnChange: true).AddEnvironmentVariables();
AppSettingsと環境変数を取得

*public void ConfigureServices(IServiceCollection services)*{// .botのパスとシークレット取得var secretKey = Configuration.GetSection("botFileSecret")?.Value;var botFilePath = Configuration.GetSection("botFilePath")?.Value;// .botの読み込みvar botConfig = BotConfiguration.Load(botFilePath ?? @".\BotConfiguration.bot", secretKey);services.AddSingleton(sp => botConfig ?? throw new InvalidOperationException($"The .bot config file could not be loaded. ({botConfig})"));// 現在の実行環境におけるエンドポイントを取得var environment = _isProduction ? "production" : "development";var service = botConfig.Services.Where(s => s.Type == "endpoint" && s.Name == environment).FirstOrDefault();if (!(service is EndpointService endpointService)){throw new InvalidOperationException($"The .bot file does not contain an endpoint with name '{environment}'.");}services.AddBot<StrCountBot>(options =>{//APP認証情報options.CredentialProvider = new SimpleCredentialProvider(endpointService.AppId, endpointService.AppPassword);});}
This method gets called by the runtime. Use this method to add services to the container.

*var secretKey = Configuration.GetSection("botFileSecret")?.Value;
.botのパスとシークレット取得

*var botConfig = BotConfiguration.Load(botFilePath ?? @".\BotConfiguration.bot", secretKey);*services.AddSingleton(sp => botConfig ?? throw new InvalidOperationException($"The .bot config file could not be loaded. ({botConfig})"));
.botの読み込み

*var environment = _isProduction ? "production" : "development";
現在の実行環境におけるエンドポイントを取得

*options.CredentialProvider = new SimpleCredentialProvider(endpointService.AppId, endpointService.AppPassword);
APP認証情報

*public void Configure(IApplicationBuilder app, IHostingEnvironment env)*{app.UseBotFramework();}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.


*bool closed = false;
外部のウィンドウを作成する。

*asd.Engine.InitializeByExternalWindow(window.altseed.Child.Handle, System.IntPtr.Zero, (int)window.altseed.RenderSize.Width, (int)window.altseed.RenderSize.Height, new asd.EngineOption());
外部のウィンドウを利用してAltseedを初期化する。

*MainWindow.DoEvents();
外部のウィンドウの処理を進める。

*var font = asd.Engine.Graphics.CreateDynamicFont("", 30, new asd.Color(255, 255, 255), 0, new asd.Color());
フォントを生成する。

*asd.TextObject2D obj = new asd.TextObject2D();
文字描画オブジェクトを生成する。

*obj.Font = font;
描画に使うフォントを設定する。

*obj.Position = new asd.Vector2DF(100, 100);
描画位置を指定する。

*obj.Text = "C++完全に理解した";
描画する文字列を指定する。

*asd.Engine.AddObject2D(obj);
文字描画オブジェクトのインスタンスをエンジンへ追加する。


*label1.Text = "Answer = " + AmicableSum
2;同じ組を2回数えてしまうため2で割る


*int a = 1;
使用されていない変数


*int iDataNum = int.Parse(Console.ReadLine());
ループする回数取得

*var varList = new List<List<int>>();
2 次元配列のように扱える List の定義

*varList.Add(new List<int>());
i 行目の要素に List を作成する

*varList[i].Add(int.Parse(array_1D_ab[j]));
要素の追加

*var varArray = varList.Select(line => line)
List をジャグ配列に変換する

*Array.Sort(varArray, StructuralComparisons.StructuralComparer);
ジャグ配列をソートする

*Console.WriteLine(varArray[i][j]);
末尾改行あり出力

*else*{// 末尾改行なし出力Console.Write(varArray[i][j] + " ");}
j 列目が最後の要素では無いなら

*Console.Write(varArray[i][j] + " ");
末尾改行なし出力

*int iDataNum = int.Parse(Console.ReadLine());
ループする回数取得

*var varList = new List<List<int>>();
2 次元配列のように扱える List の定義

*varList.Add(new List<int>());
i 行目の要素に List を作成する

*varList[i].Add(array_1D_ab[j]);
要素の追加

*var varArray = varList.Select(line => line)
List をジャグ配列に変換する

*Array.Sort(varArray, StructuralComparisons.StructuralComparer);
ジャグ配列をソートする

*Console.WriteLine(varArray[i][j - 1]);
末尾改行あり出力

*else*{// 末尾改行なし出力Console.Write(varArray[i][j + 1] + " ");}
j 列目が最後の要素では無いなら

*Console.Write(varArray[i][j + 1] + " ");
末尾改行なし出力


*Xamarin.Essentials.Platform.Init(this, savedInstanceState);
追加！

*public override void OnRequestPermissionsResult(int requestCode, string[] permissions, [GeneratedEnum] Android.Content.PM.Permission[] grantResults)*{Xamarin.Essentials.Platform.OnRequestPermissionsResult(requestCode, permissions, grantResults);base.OnRequestPermissionsResult(requestCode, permissions, grantResults);}
追加！

*ShowDisplayInfo.Clicked += async (sender, e) =>*{var mainDisplayInfo = DeviceDisplay.MainDisplayInfo;var width = mainDisplayInfo.Width;var height = mainDisplayInfo.Height;await DisplayAlert("Display Info", $"width: {width}px, height: {height}px", "Close");};
以下を追記


*EditorGUILayout.EndVertical();
20191008 追記　これで閉じないと警告が出まくる

*EditorGUILayout.Space();
少しスペースを空ける


*Application.Idle += (e, sender) => this.ExitThread();
アプリケーション終了

*Application.EnterThreadModal += this.Application_EnterThreadModal;
モーダル状態を捕捉

*Application.Idle += this.Application_Idle;
Idleイベント登録

*this.App.Dispose();
App破棄

*Application.Idle -= this.Application_Idle;
Idleイベント一時解除

*Application.Idle += this.Application_Idle;
Idleイベント再登録

*while (!SafeNativeMethods.PeekMessage(*out SafeNativeMethods.MSG _, IntPtr.Zero, 0, 0, 0))
ウィンドウメッセージを受信するまでループ処理

*this.App.DoWork();
アプリケーションの処理を実行

*}
初期化処理を書く
エラーなどで終了したい場合は、return false;

*}
メイン処理を書く
アプリケーションを終了するときは、this.ExitApp();

*base.Dispose(disposing);
リソースの解放処理を書く

*Application.Idle += (e, sender) => this.ExitThread();
アプリケーション終了

*Application.EnterThreadModal += this.Application_EnterThreadModal;
モーダル状態を捕捉

*while (!SafeNativeMethods.PeekMessage(*out SafeNativeMethods.MSG _, IntPtr.Zero, 0, 0, 0))
ウィンドウメッセージを受信するまでループ処理

*this.App.DoWork();
アプリケーションの処理を実行


*var result = source.Aggregate((sum, item) => sum + item);
⇒ 6


*browser = new ChromiumWebBrowser("https:
web.basemark.com")


*using NCMB;
追記

*yield break;
ログインしていない

*query.WhereEqualTo("キー", "値");
一致する値で取得（例えばユーザーID）

*query.OrderByDescending("updateDate");
ソートkeyを設定,updateDateやcreateDateもOK

*query.WhereGreaterThanOrEqualTo("updateDate", new DateTime(2018,12,1));
12/1~12/31で抽出,DateTime型で渡せばOK

*query.FindAsync((List<NCMBObject> objList, NCMBException e) =>*{if (e != null){//検索失敗時の処理Debug.Log("失敗");}else{Debug.Log("成功");//objListを使う処理OnResult(objList);}// ログイン処理終了isConnecting = false;});
検索結果を取得

*Debug.Log("失敗");
検索失敗時の処理

*OnResult(objList);
objListを使う処理

*isConnecting = false;
ログイン処理終了

*yield return new WaitWhile(() => { return isConnecting; });
ログイン処理が終了するまで以下の行で待機

*Debug.log(objList[0]["createDate"]);
ただし...
エラーになる

*Debug.log(objList[0]["updateDate"]);
エラーになる


*byte[] data = e.Value.ToNativeEvent();
MIDI生値に変換

*var port = new MidiInPort("loopMIDI Port");
ポートを開く

*port.Received += MidiReceived;
受信イベント登録


*from name in Parse.CharExcept(new[] { '(', ')', ',' }).AtLeastOnce().Text()
関数名の部分 関数名にカッコやカンマは含まれないはずなので除外する

*from lparen in Parse.Char('(')
関数の最初のカッコ

*from arguments in Parse.Ref(() => Arguments).DelimitedBy(Parse.Char(',').Token())
関数の引数の部分 引数に関数を取る場合があり得るので`Ref`を使用して再帰的にパースされるように定義する

*from rparen in Parse.Char(')')
関数の閉じカッコ

*select CallFunction(name, arguments.ToArray());
関数を表す文字列と引数を表す文字列をExpressionにする関数を呼び出す

*private static readonly Parser<Expression> Constant =*Parse.CharExcept(new[] { '(', ')', ',' }).AtLeastOnce().Token().Text().Select(Expression.Constant);
引数のうち、関数でないもの（＝定数）

*private static readonly Parser<Expression> Arguments = Function.Or(Constant);
引数は関数か定数であるはず。なので、まず関数かどうかを評価してから関数でない場合は定数と判断する（なので`Or`を利用している）


*// foreachのコメントアウトを外してもコンパイルは通る。*//foreach (var val in q3)
Executeメソッドがnullのみを返すのでこのforeachで"ランタイム"エラーとなる。

*//{//   Console.WriteLine($"{val}");//}
foreach (var val in q3)

*//   Console.WriteLine($"{val}");
{


*var saveData = new byte[32];
保存するデータとして仮定

*var encryptData = Encrypt(saveData, buf);
暗号化する処理

*SaveFile(encryptData);
ファイルに保存する処理


*IEnumerator AnimateCoroutine(Transform transform, float time, Vector3? position, Quaternion? rotation)
tranform 移動させたいtranform
time     何秒かけて推移させるか
position 目標とするposition...nullを入れると値は変化しない
rotation 目標とするrotation...nullを入れると値は変化しない

*var currentPosition = transform.position;*var currentRotation = transform.rotation;
現在のposition, rotation

*var targetPosition = position ?? currentPosition;
目標のposition, rotation

*sumTime += Time.deltaTime;
Coroutine開始フレームから何秒経過したか

*var ratio = sumTime / time;
指定された時間に対して経過した時間の割合

*break;
目標の値に到達したらこのCoroutineを終了する
~.Lerpは割合を示す引数は0 ~ 1の間にClampされるので1より大きくても問題なし

*void Start()*{_reset.onClick.AddListener(() =>{if (_animationCoroutine != null){StopCoroutine(_animationCoroutine);}_cylinder.transform.SetPositionAndRotation(new Vector3(6f, 0f, 0f),Quaternion.Euler(0f, 0f, -60f));});_reset.onClick.Invoke();_go.onClick.AddListener(() =>{if (_animationCoroutine != null){StopCoroutine(_animationCoroutine);}_animationCoroutine =StartCoroutine(AnimateCoroutine(_cylinder.transform,_slider.value,new Vector3(-6f, 0f, 0f),Quaternion.Euler(0f, 0f, 60f)));});_slider.onValueChanged.AddListener(arg => _field.text = arg.ToString());}
Use this for initialization

*IEnumerator AnimateCoroutine(Transform transform, float time, Vector3? position, Quaternion? rotation)
tranform 移動させたいtranform
time     何秒かけて推移させるか
position 目標とするposition...nullを入れると値は変化しない
rotation 目標とするrotation...nullを入れると値は変化しない

*var currentPosition = transform.position;*var currentRotation = transform.rotation;
現在のposition, rotation

*var targetPosition = position ?? currentPosition;
目標のposition, rotation

*sumTime += Time.deltaTime;
Coroutine開始フレームから何秒経過したか

*var ratio = sumTime / time;
指定された時間に対して経過した時間の割合

*break;
目標の値に到達したらこのCoroutineを終了する
~.Lerpは割合を示す引数は0 ~ 1の間にClampされるので1より大きくても問題なし


*var url = "http:
192.168.1.1:80osccommandsexecute";


*public static void NoWait(this Task task, Action<Task> action = null, CancellationToken? ct = null)*{if (action != null) {if (ct != null) {task.ContinueWith(action, (CancellationToken)ct).ConfigureAwait(false);} else {task.ContinueWith(action).ConfigureAwait(false);}} else {if (ct != null) {task.ContinueWith(_ => {}, (CancellationToken)ct).ConfigureAwait(false);} else {task.ContinueWith(_ => {}).ConfigureAwait(false);}}}
返り値なし

*public static void NoWait<TResult>(this Task<TResult> task, Action<Task<TResult>> action = null, CancellationToken? ct = null)*{if (action != null) {if (ct != null) {task.ContinueWith(action, (CancellationToken)ct).ConfigureAwait(false);} else {task.ContinueWith(action).ConfigureAwait(false);}} else {if (ct != null) {task.ContinueWith(_ => {}, (CancellationToken)ct).ConfigureAwait(false);} else {task.ContinueWith(_ => {}).ConfigureAwait(false);}}}
返り値あり

*public static void NoWait(this Task task, Action<Task> action = null, CancellationToken ct = default)*{task.ContinueWith(action ?? (_ => { }), ct).ConfigureAwait(false);}
返り値なし

*public static void NoWait<TResult>(this Task<TResult> task, Action<Task<TResult>> action = null, CancellationToken ct = default)*{task.ContinueWith(action ?? (_ => { }), ct).ConfigureAwait(false);}
返り値あり

*AsyncMethod().NoWait();
返り値なし、後処理なし

*AsyncMethodWithResult(ct).NoWait(task => { var result = task.Result; }, ct);
返り値あり、後処理あり、CancellationTokenあり


*return (2 * Math.PI) + n;
360度を足す

*private void Publish(LineInfo state)*{foreach (var observer in _observers){observer.OnNext(state);}}
状況変化を知らせるために購読者に通知する


*=> Task.FromResult((string?)"");
これだと Task<string?> とみなしてくれない


*.Skip(1)
1行目はカラム名

*var data = ReadCSV("forcsts.csv");*var forecasts = Forecststify(data);
メインメソッド

*class RevealingReferences {readonly IList<Forecast> forecasts;// CSVデータでなくIEnumerable<Forecast>を受け取るpublic RevealingReferences(IEnumerable<Forecast> forecasts) {this.forecasts = forecasts.ToList();}public int[] TemperatureDeferences() =>forecasts.Select(f =>f.HighestTemperature - f.OptimumTemperature).ToArray();public double AverageHighTemperature() =>forecasts.Average(f => f.HighestTemperature);}
明瞭な参照


*}
処理とかいろいろ

*}
処理とかいろいろ


*loadedModel = mlContext.Model.Load(modelLocation, out var modelInputSchema);
モデル読み込み

*var predictor = mlContext.Model.CreatePredictionEngine<ImageNetData, ImageNetPrediction>(loadedModel);
画像読み込み


*public bool DirectoryExists(string Folderpath)*{string DisideOfSelsct;Console.WriteLine("フォルダの存在チェック");if (!Directory.Exists(Folderpath)){Console.WriteLine("フォルダが存在しません。フォルダを作成しますか？");Console.WriteLine("作成：yes　作成しない：no");DisideOfSelsct = Console.ReadLine();CreateDirectory(Folderpath, DisideOfSelsct);}else{Console.WriteLine(Folderpath + "は存在します");}return true;}
フォルダの存在確認を行う

*private void CreateDirectory(string DirectoryFolder, string Answer)*{if (!Directory.Exists(DirectoryFolder) && Answer.Equals("yes")){Directory.CreateDirectory(DirectoryFolder);}else if(Directory.Exists(DirectoryFolder) && Answer.Equals("no")){return;}}
フォルダの作成を行う


*serializer.Serialize(writer, value, emptyNamespaces);
3.


*object.Equals(myBase, mySub1)
内部でObject.Equals()が呼ばれる


*YourBrowser_Open();
ここで自由に調理してください


*public string CodeC { get; set; }
固有のコード体系

*}
/* ... */                          固有のデータ構造

*public class ServiceA*{public MixedStructure Get(string codeA) => { /* ... */ }}
SubStructureA を使うサービス

*public class ServiceB*{public MixedStructure Get(string codeB) => { /* ... */ }}
SubStructureB を使うサービス

*public class ServiceC*{public MixedStructure Get(string codeC) => { /* ... */ }}
SubStructureC を使うサービス


*ClickOnceController clickOnce = new ClickOnceController(null, true);
自動ダウンロードを有効にするには、第二引数に true を指定します

*clickOnce.RegistAssemblyDownloadGroup("ClassLibrary1", "Group1");
アセンブリ名とダウンロードグループ名の組み合わせを登録します


*count++;
ボールがDestroyされるたびにcountを1追加

*image = childrenTransform.GetComponent<Image>();*image.color = Color.yellow;
一例として子のイメージコンポーネントを取得して色を変える

*void LightSelectedImage()*{//一度foreachを通ったらimageにはコンポーネントが入っているif (image != null){return;}foreach(Transform childrenTransform in this.gameObject.transform){image = childrenTransform.GetComponent<Image>();image.color = Color.yellow;}}
選んだイメージを光らせる

*mr[i].SetFloat("_Enabled", 1);
例)Shaderの疑似bool値をオンに


*if(e.KeyValue == 18 )
18:Alt Key Num

*}
System.Diagnosticsはusingで定義済み


*_Parent = parent;
オプションセット済みの親コマンドのインスタンスが渡される

*_Parent.OnExecute();
親コマンドの実行も可能

*Console.WriteLine($"parent X = {_Parent.X}, Y = {Y}");
親クラスのオプションの取得も可能

*class MyCommand*{[Option]public string X { get; set; }public void OnExecute(){Console.WriteLine($"in {nameof(MyCommand)}");}}
親コマンド

*app.Conventions.UseConstructorInjection(services.BuildServiceProvider()).UseDefaultConventions();
UseConstructorInjectionに空引数を指定すれば、デフォルトのServiceProviderが使用される
属性ベースのAPIを使用する場合はUseDefaultConventions()は必須


*Dictionary<int, string> romanArabicNum = new Dictionary<int, string>();
アラビア数字とローマ数字のペアを用意する

*string ret = string.Empty;
戻り値を宣言する

*int romanCount = arabicNo / pair.Key;
arabicNoをペアの数字割って商を求める
商＝ローマ数字で出力する数となる

*arabicNo -= romanCount * pair.Key;
商の分の数をarabicNoから引く


*musics.Add(new msta("bgm_main",bgm_0));
音楽を格納する場所 増やす場合これを増やしていく

*musics.Add(new msta("se_gold",se_1));
musics.Add(new msta("名前",bgm_1)); 名前はなんでも。soundman.bgm="名前"で呼び出せるようになります
musics.Add(new msta("se_buy",se_0)); seも同じく


*{Console.WriteLine(ex.TargetSite);}
例外発生した部分表示

*,,,
1つの処理で複数例外でる場合、throwで別のメソッドに再スローすればいい
逆に複数処理で1つの例外でる場合、whenでまとめればいい


*this.Cond = cond;
引数を保存（テストコードで内容を検証できるように）

*return new DeliveryScheduleSearchResultModel*{DeliveryScheduleDate = new DateTime(2018, 12, 7)};
都合のいいようにデータを作って返却する

*var mock = new DeliveryScheduleSearchSvcForTest();
初期化処理（フレームワークやデータベースの初期化など）
納期検索サービスのモックを作る

*var input = new ReceiveOrderInputModel{受注内容をセット};
商品受注サービスの入力データ

*};
受注内容をセット

*var targetSvc = new ReceiveOrderSvc(mock);
商品受注サービスにモックを渡してインスタンス生成

*var result = targetSvc.Exec(input);
商品受注サービスを呼び出す

*AssertEqual(ReceiveSatus.SUCCESS, result.Status);
結果を検証

*}
以下、result の内容を検証する

*static void AssertEqual(object expected, object actual)*{if (!object.Equals(expected, actual)) throw new Exception($"Assertion error! expected: {expected}, but actually: {actual}");}
検証用のメソッド（あくまで簡易な実装例。本当はもっと考慮すべきことがある）


*fs.Write(data, 0, data.Length);
We can also use ReadOnlySpan


*var diff = transform.position - TrackingCamera.transform.position;*// 鏡面の垂直ベクトル
カメラから鏡面へのベクトル

*var normal = transform.forward;*// 鏡面からの反射ベクトル
鏡面の垂直ベクトル

*var reflection = diff + 2 * (Vector3.Dot(-diff, normal)) * normal;*// 鏡面座標に反転させた反射ベクトルを加算する
鏡面からの反射ベクトル

*ReflectionCamera.transform.position = transform.position - reflection;*,,,
鏡面座標に反転させた反射ベクトルを加算する

*ReflectionCamera.transform.LookAt(Specular.position);*,,,
鏡面の方向に向ける

*var distance = Vector3.Distance(transform.position, ReflectionCamera.transform.position);*ReflectionCamera.nearClipPlane = distance* 0.9f;
カメラ設定の更新

*ReflectionCamera.fieldOfView = 2 * Mathf.Atan(Size / (2 * distance)) * Mathf.Rad2Deg;
焦点距離と表示したい鏡面サイズから画角(FOV)を計算する

*Specular.rotation = Quaternion.LookRotation(Specular.position - TrackingCamera.transform.position);*,,,
鏡面をカメラ方向に向ける

*Frame.localScale = new Vector3(Size, Size, 1);
フレームのサイズを更新

*var angle = Vector3.Angle(-transform.forward, ReflectionCamera.transform.forward);*var specularSize = Size + Mathf.Sin(angle * Mathf.Deg2Rad);
鏡面のサイズを調整

*SceneView.RepaintAll();
シーンビュー更新


*xlRange.Interior.ColorIndex = 15;
グレー


*new SigningCredentials(AuthConfig.ApiJwtSigningKey, SecurityAlgorithms.HmacSha256)
署名に使うCredential

*var encodedJwt = new JwtSecurityTokenHandler().WriteToken(jwt);
トークンを作成（トークンは上記クレームをBase64エンコードしたものに署名をつけただけ）


*Thread.Sleep(1000);
何か重い処理

*SomethingNextMethod(str);
重い処理をした続きの処理

*Debug.Log(str);
何か続きの処理

*Thread.Sleep(1000);
何か重い処理

*SomethingNextMethod("Hoge");
そのままメソッドを続けて書いた場合

*_mainContext.Post(_ => SomethingNextMethod("Fuga"), null);
メインスレッドに処理を戻したい場合

*Thread.Sleep(1000);
何か重い処理

*string result = await Task.Run(() => HeavyMethod("hoge"));
重い処理を非同期で実行し、その結果を得る

*SomethingNextMethod(result);
重い処理をした続きの処理

*var task = Task.Run(() => HeavyMethod("hoge"));
Taskはawaitせず直接受け取って

*SomethingNextMethod(result);
task.Resultで直接、値にアクセスする
var result = task.Result;  ここで結局スレッドが止まる

*var task = HogeHogeAsync();
HogeHogeAsync()のタスク(Task<string>)をそのまま受け取り

*task.Wait();
taskの完了を待つ

*SomethingNextMethod(task.Result);
taskの処理は終了しているので、Resultを参照

*}
return await Task.Run(() => HeavyMethod("hoge")).ConfigureAwait(false);  これならデッドロックしない

*Task.Run(() => HeavyMethod("hoge"));
特に問題ないけど、あまり好きではない

*var _ = Task.Run(() => HeavyMethod("hoge"));
C# 6.0ならこう

*_ = Task.Run(() => HeavyMethod("hoge"));
C# 7.0以降ならこう ... discards (値の破棄)

*}
クライアントとの送信・受信処理


*public Test()*{//new した際にやりたい処理}
コンストラクタ(クラスと同じ名前にする)

*}
new した際にやりたい処理

*~Test()*{//Dispose した際にやりたい処理}
デストラクタ(クラスと同じ名前にする)

*}
Dispose した際にやりたい処理

*private int _hp = 10;
入れ物

*private int _maxHp = 10;
最大HP

*public int HP*{//変数を取得するときget{//取得するときに渡す値return _hp;}//変数を設定するときset{//入ってきた値（value）が０以下なら０に固定する。if (value < 0){value = 0;}//入ってきた値（value）が最大値より大きければ最大値に固定する。if (value > _maxHp){value = _maxHp;}_hp = value;}}
プロパティ（ここにアクセスして使う）

*get*{//取得するときに渡す値return _hp;}
変数を取得するとき

*return _hp;
取得するときに渡す値

*set*{//入ってきた値（value）が０以下なら０に固定する。if (value < 0){value = 0;}//入ってきた値（value）が最大値より大きければ最大値に固定する。if (value > _maxHp){value = _maxHp;}_hp = value;}
変数を設定するとき

*int i = flag ? 1 : -1 ;
変数＝条件式？true：false


*// BossEnemyFactoryを使う際はこう書けた方が便利なことがある*// public override BossEnemy Create () { return new BossEnemy(); }
↓こう書きたい。けれどコンパイルエラーになってしまう

*// public override BossEnemy Create () { return new BossEnemy(); }
BossEnemyFactoryを使う際はこう書けた方が便利なことがある

*// ↓こう書くしかない。*public override Enemy Create() { return new BossEnemy(); }
実際は、BossEnemy型のインスタンスしか返さない

*public override Enemy Create() { return new BossEnemy(); }
↓こう書くしかない。


*this.View = new ContainerView();
差し替える

*}
省略...

*private IEnumerable<NSLayoutConstraint> CreateConstraint(NSView parent, NSView child) {// X座標を親の中心を軸に配置yield return NSLayoutConstraint.Create(child, NSLayoutAttribute.CenterX, NSLayoutRelation.Equal,parent, NSLayoutAttribute.CenterX, 1.0f, new nfloat(0));// Y座標を親の中心を軸に配置yield return NSLayoutConstraint.Create(child, NSLayoutAttribute.CenterY, NSLayoutRelation.Equal,parent, NSLayoutAttribute.CenterY, 1.0f, new nfloat(0));yield return NSLayoutConstraint.Create(child, NSLayoutAttribute.Width, NSLayoutRelation.Equal,null, NSLayoutAttribute.Width, 1.0f, new nfloat(80));yield return NSLayoutConstraint.Create(child, NSLayoutAttribute.Height, NSLayoutRelation.Equal,null, NSLayoutAttribute.Height, 1.0f, new nfloat(30));}
省略...

*yield return NSLayoutConstraint.Create(child, NSLayoutAttribute.CenterX, NSLayoutRelation.Equal,parent, NSLayoutAttribute.CenterX, 1.0f, new nfloat(0)
X座標を親の中心を軸に配置

*yield return NSLayoutConstraint.Create(child, NSLayoutAttribute.CenterY, NSLayoutRelation.Equal,parent, NSLayoutAttribute.CenterY, 1.0f, new nfloat(0)
Y座標を親の中心を軸に配置


*vlcControl1.Play(ms);
再生


*using System.Xml.Linq
重要

*XDocument xml = XDocument.Load(@"C:\sample.xml");
ディレクトリ指定してファイルを読み込み

*XElement table = xml.Element("リスト");
テーブルを読み込む

*var rows = table.Elements("データ");
データの中身すべてを取得


*return (2 * Math.PI) + n;
360度を足す

*private double ToDegree(double rad)*{return rad * 360 / (2 * Math.PI);}
ラジアンを度の変換

*private double ToRadian(double deg)*{return deg * (2 * Math.PI) / 360;}
度をラジアンに変換

*private double LineLength(Point p1, Point p2)*{double w = (p2.X - p1.X);double h = (p2.Y - p1.Y);return Math.Sqrt(w * w + h * h);}
２点の線分の長さを求める

*private void Complete()*{foreach (var observer in _observers){observer.OnCompleted();}}
終了を通知する

*private void Publish(Line state)*{foreach (var observer in _observers){observer.OnNext(state);}}
状況変化を知らせるために購読者に通知する


*var dc = this.DataContext as MainWindowViewModel;
ここが致命的。ViewがViewModelのことを知っていることになる。

*System.Windows.Interactivity.EventTrigger trigger = new System.Windows.Interactivity.EventTrigger();
イベント1つぶんの記述。ここから

*triggers.Add(trigger);
ここまで

*System.Windows.Interactivity.EventTrigger trigger = new System.Windows.Interactivity.EventTrigger();
イベント1つぶんの記述。ここから

*triggers.Add(trigger);
ここまで


*[CustomPropertyDrawer(typeof(UnityEvent<bool>), true)]
この行を追加


*string query = "SELECT * FROM <テーブル名> ";
クエリ

*con.Open();
コネクション開始

*Console.WriteLine(e.Message);
エラーメッセージ

*con.Close();
コネクション終了

*command.CommandText = @"INSERT INTO <テーブル名> VALUES('" + <DATA_DATETIME> + "'," + <DATA_ID> + ","+ <DATA_VALUE> + ")";
クエリ

*command.ExecuteNonQuery();
SQLの実行

*Console.WriteLine(e.Message);
エラーメッセージ

*con.Close();
コネクション終了


*DownCommand.Subscribe(_ => Counter.Value--);
(() => Counter.Value--)ではコンパイルエラー


*case 37:
100

*Debug.Log (Result + "：" + (TotalTime / n) + "ms");
かかった時間を表示


*string json = Newtonsoft.Json.JsonConvert.SerializeObject(cardObject);
修正


*using var serializerStream = new MemoryStream();
シリアル化

*var byteArray = Encoding.UTF8.GetBytes(jsonString);
デシリアル化

*Encoder = JavaScriptEncoder.Create(UnicodeRanges.All)};
すべての言語セットをエスケープせずにシリアル化させる

*var summary = BenchmarkRunner.Run<MeasurementJsonSerializer>();
計測開始


*services.AddSingleton<OlkarStatusModel>();
Singleton として登録しておくことで、プロセスが生きている間は状態が保持される

*config.HandshakeTimeout = TimeSpan.FromSeconds(15);
明示的にしておくことで、勝手にタイムアウトしていくのを防ぐ

*app.UseSignalR(routes => routes.MapHub<OlkarHub>("/olkar"));
SignalR のルート

*return Content(message?.Challenge ?? "NULL");
Content で HTTP 200 を返しつつ応答メッセージを返せる

*var user = eventJson["user"];
基本情報

*}
フィールドに HttpClient http = new HttpClient(); がいます
var result = await this.http.PostAsync("https:slack.com/api/chat.postMessage", content);


*}
await部分

*var task = Task.Delay(1000);
await を展開した部分

*var awaiter = task.GetAwaiter();
Awaiterを取り出す

*Action continuation = () =>*{// awiterの結果を受け取る// タスクの中で例外が発生していた場合などはGetResultを呼んだスレッドで改めて例外が投げられるawaiter.GetResult();// 本来の後続部分を実行HogeContinuation();};
後続部分

*awaiter.GetResult();
awiterの結果を受け取る
タスクの中で例外が発生していた場合などはGetResultを呼んだスレッドで改めて例外が投げられる

*HogeContinuation();
本来の後続部分を実行

*else*{awaiter.OnCompleted(continuation);}
完了していない場合はAwaiterに後続部分の処理を任せる

*もしcompletionSource.Taskが誰かにawaitされている場合(=AwaiterのOnCompletedが呼ばれている場合)、この関数の中でawaitの続きの処理が実行されるcompletionSource.SetResult(true);
後続処理がすべて終わったことを通知する

*completionSource.SetResult(true);
もしcompletionSource.Taskが誰かにawaitされている場合(=AwaiterのOnCompletedが呼ばれている場合)、
この関数の中でawaitの続きの処理が実行される

*return completionSource.Task;
後続処理がすべて終わった後に完了するタスクを返す

*await UniTask.Yield(PlayerLoopTiming.Update, token);
1フレーム待つ

*[DebuggerHidden]
UniTask.csより引用

*[DebuggerHidden]
UniTask.csより引用

*readonly IAwaiter awaiter;
UniTask.csより引用

*public static UniTask Yield(PlayerLoopTiming timing, CancellationToken cancellationToken)*{return new UniTask(new YieldPromise(timing, cancellationToken));}
UniTask.Delay.csより引用

*class YieldPromise : PlayerLoopReusablePromiseBase*{public YieldPromise(PlayerLoopTiming timing, CancellationToken cancellationToken): base(timing, cancellationToken, 2){}protected override void OnRunningStart(){}public override bool MoveNext(){Complete();if (cancellationToken.IsCancellationRequested){TrySetCanceled();}else{TrySetResult();}return false;}}
UniTask.Delay.csより引用

*public void OnCompleted(Action action)*{UnsafeOnCompleted(action);}
ReusablePromise.csより引用

*public override bool IsCompleted*{get{if (Status == AwaiterStatus.Canceled || Status == AwaiterStatus.Faulted) return true;if (!isRunning){isRunning = true;ResetStatus(false);OnRunningStart();#if UNITY_EDITORTaskTracker.TrackActiveTask(this, capturedStackTraceForDebugging);#endifPlayerLoopHelper.AddAction(timing, this);}return false;}}
ReusablePromise.csより引用

*public override bool MoveNext()*{Complete();if (cancellationToken.IsCancellationRequested){TrySetCanceled();}else{TrySetResult();}return false;}
UniTask.Delay.csより引用

*public virtual bool TrySetResult()*{if (status == AwaiterStatus.Pending){status = AwaiterStatus.Succeeded;TryInvokeContinuation();return true;}return false;}
ReusablePromise.csより引用


*var ws = analyzerResult.GetWorkspace();
仮にAllowUnsafeBlockオプションを有効にしてみる
Buildalyzerの分析結果をanalyzerResultとする
分析結果から、RoslynWorkspaceを取得する

*var project = ws.CurrentSolution.Projects.First();
roslynプロジェクトを取得

*project = project.WithCompilationOptions(cscompopt.WithAllowUnsafe(true));
基本的にroslyn関連クラスのプロパティは直接書き換えできないので、With...で再セットする

*var compilationUnit = project.GetCompilationAsync().Result;
コンパイル結果取得

*,,,
諸々の処理

*envopts.TargetsToBuild.Clear();
"Clean"と"Build"がデフォルトで含まれている

*envopts.TargetsToBuild.Add("Clean");
必ずコンパイルを走らせないと、アイテムリストを作ってくれないため

*}
ビルド結果の解析

*envopts.TargetsToBuild.Clear();
"Clean"と"Build"がデフォルトで含まれている

*envopts.TargetsToBuild.Add("ResolveAssemblyReferencesDesignTime");
Cleanタスクを省略

*}
何も列挙されない場合がある

*var tmppath = [ランダムなディレクトリ];
必ず末尾をパス区切り文字(System.IO.Path.DirectorySeparatorChar)で終わらせること
ディレクトリは実行時に生成されるため、存在していなくても問題ない。

*var analyzerManager = new AnalyzerManager();
ProjectAnalyzerとEnvironmentOptionsの準備...

*envopts.GlobalProperties["IntermediateOutputPath"] = tmppath;
中間出力ファイルディレクトリの指定

*}
分析の開始...


*sb.AppendLine("XXX");
<--これ


*a(256);
この例では a(256) が呼ばれる。

*//{//    Console.Write("A({0}) が呼ばれました。\n", n);//}
static void A(int n)

*//    Console.Write("A({0}) が呼ばれました。\n", n);
{

*}
Console.Write("A({0}) が呼ばれました。\n", n);
}


*var results = _FizzBuzz(i + 1, n);
★


*private WaveIn sourceStream = null;
録音なのでWaveInを使用

*DeviceNumber = 0,Waveのフォーマット(サンプルレート等)を指定WaveFormat = new WaveFormat(44100, WaveIn.GetCapabilities(0).Channels)};
デフォルトデバイスを選択

*WaveFormat = new WaveFormat(44100, WaveIn.GetCapabilities(0).Channels)};
Waveのフォーマット(サンプルレート等)を指定

*WaveInProvider waveIn = new WaveInProvider(sourceStream);
指定したバッファにwaveデータを入力するやつ(WaveInProvider)に変換

*waveOut = new DirectSoundOut();
(たぶん)リアルタイムで入力音源を直で出力へ送る。

*sourceStream.StartRecording();
録音の開始

*play.Init(new WaveInProvider(sourceStream));
音声ファイルの読み込み

*play.Play();
音声ファイルの再生

*play.Stop();
音声ファイルの停止


*.Select(i => i * i)
値を2乗する


*;
select a;

*{8,7,6}
結果

*876
結果

*{16, 14, 12}
結果

*True
結果

*{1, 2, 3}
結果

*{1, 4, 5}
結果

*{4, 5, 6}
結果

*{}
結果

*{4, 5}
結果

*{4, 5}
結果


*class Animal*{public int age = 0;}
C#7.0以前

*}
なんかデータ

*Animal animal = (Animal)obj;
ここ注目!!!!!!!!!!!!!!!!!!!!

*Console.WriteLine(animal.age);
なんかの処理

*class Hoge*{public void Piyo(Object obj){// ここ注目!!!!!!!!!!!!!!!!!!!!// obj が Animal クラスにキャストできた場合はキャスト結果を animal という変数に入れる// obj が null の場合はfalseとなって中の処理はもちろんキャストも通らないif (obj is Animal animal){// なんかの処理Console.WriteLine(animal.age);}else{Console.WriteLine(false);}}}
C#7.0以降

*if (obj is Animal animal)
ここ注目!!!!!!!!!!!!!!!!!!!!
obj が Animal クラスにキャストできた場合はキャスト結果を animal という変数に入れる
obj が null の場合はfalseとなって中の処理はもちろんキャストも通らない

*Console.WriteLine(animal.age);
なんかの処理

*class Huga*{public void Mohu(Object obj){try{// ここ注目!!!!!!!!!!!!!!!!!!!!Animal animal = (Animal)obj;Console.WriteLine(animal.age);}// ここ注目!!!!!!!!!!!!!!!!!!!!// キャストできなかった場合の例外はInvalidCastExceptioncatch (InvalidCastException){Console.WriteLine(false);}}}
普通のキャストの場合

*Animal animal = (Animal)obj;
ここ注目!!!!!!!!!!!!!!!!!!!!

*catch (InvalidCastException)
ここ注目!!!!!!!!!!!!!!!!!!!!
キャストできなかった場合の例外はInvalidCastException

*class Huga*{public void Humo(Object obj){// ここ注目!!!!!!!!!!!!!!!!!!!!Animal animal = obj as Animal;if(animal == null){Console.WriteLine("動物継承してないね");}else{Console.WriteLine(animal.age);}}}
as演算子を用いたキャストの場合

*Animal animal = obj as Animal;
ここ注目!!!!!!!!!!!!!!!!!!!!


*public float radius = 0.5f;
円の大きさ


*dynamic data = JsonConvert.DeserializeObject(requestBody);
dynamicで型が取れるのはC#は便利ですねー

*var url = new Uri(data0.data.url.ToString());
BlobのURLを解析は少し厄介です...

*CloudBlockBlob blockBlob_download = blobcontainer.GetBlockBlobReference(blobname);
ダウンロードするファイル名を指定

*//ダウンロード後のパスとファイル名を指定。*var downloadFile = $"{tempFilePath}" ;
ダウンロード処理

*var downloadFile = $"{tempFilePath}" ;
ダウンロード後のパスとファイル名を指定。

*using (var client = new SftpClient("<SFTPサーバ アドレス>", "<userid>", "<password>"))*{client.Connect();// await a file uploadusing (var localStream = File.OpenRead(filePath)){client.ChangeDirectory("<アップロードパス>");await client.UploadAsync(localStream, $"{fileName}");// disconnect like you normally wouldclient.Disconnect();}}
clientを作成して

*using (var localStream = File.OpenRead(filePath)){client.ChangeDirectory("<アップロードパス>");
await a file upload

*CloudBlockBlob blockBlob_download = blobcontainer.GetBlockBlobReference(blobname);
ダウンロードするファイル名を指定

*//ダウンロード後のパスとファイル名を指定。*var downloadFile = $"{tempFilePath}" ;
ダウンロード処理

*var downloadFile = $"{tempFilePath}" ;
ダウンロード後のパスとファイル名を指定。

*using (var client = new SftpClient("<ホストIP or FQDN>", "<ユーザ>", "<パスワード>"))*{client.Connect();// await a file uploadusing (var localStream = File.OpenRead(filePath)){client.ChangeDirectory("/home/ubuntu/sftp");await client.UploadAsync(localStream, $"{fileName}");// disconnect like you normally wouldclient.Disconnect();}}
setup client

*using (var localStream = File.OpenRead(filePath)){client.ChangeDirectory("/home/ubuntu/sftp");
await a file upload


*System.Console.WriteLine(obj + str);
▲


*else dc.OnKeyHit(cki.KeyChar);
Event発生

*public event Action EventAction;
自動実装ｲﾍﾞﾝﾄ

*public void OnEvents() => this.EventAction?.Invoke();
?.Invokeで全部呼出

*var observer = new Observer();
ｲﾝｽﾀﾝｽ化

*observer.EventAction += sub1.SubjectAction;
Eventに登録する(ｲﾍﾞ名+=ﾃﾞﾘ名)

*observer.OnEvents();
ｲﾍﾞ呼出

*}
出力内容
> "Action!"
> "Action!"

*}
出力内容
> "Action!"
> "Action!"


*var thread = new Thread(HeavyFunc);
スレッドを作成

*thread.Start();
非同期処理開始

*thread.Join();
ここで非同期処理が終わるまで待機

*Console.WriteLine("スリー！");
非同期処理が終わってから実行

*static void HeavyFunc(){for (int i = 0; i < 100000; i++){for (int p = 0; p < 10000; p++){}}Console.WriteLine("ツー！");}
暫定的な重い処理の見本

*,,,
実行結果
ワン！
ツー！
スリー

*Task task = Task.Run(() => HeavyFunc());
非同期処理開始

*task.Wait();
ここで非同期処理が終わるまで待機

*Console.WriteLine("スリー！");
非同期処理が終わってから実行

*static void HeavyFunc(){for (int i = 0; i < 100000; i++){for (int p = 0; p < 10000; p++){}}Console.WriteLine("ツー！");}
暫定的な重い処理の見本

*Task<string> task = StartAsync();
非同期処理開始

*task.Wait();
ここで非同期処理が終わるまで待機

*Console.WriteLine(task.Result);
StartAsyncから帰ってきた返り値を使える

*static async Task<string> StartAsync(){await Task.Run(() => HeavyFunc());Console.WriteLine("スリー");return "フォー";}
メソッドを定義

*static void HeavyFunc(){for (int i = 0; i < 100000; i++){for (int p = 0; p < 10000; p++){}}Console.WriteLine("ツー！");}
暫定的な重い処理の見本


*public SuperClass(int num, string text)*{// 処理}
継承先に引数がないパターン

*}
処理

*}
処理

*public SuperClass(int num, string text)*{// 処理}
継承先の引数が多いパターン

*}
処理

*}
処理


*this.Items = items?.AsReadOnly();
外部公開用には変更不可にラップ


*audioSource = GetComponent<AudioSource>();
空の Audio Sourceを取得

*audioSource.clip = Microphone.Start(null, true, 1, 44100);
Audio Source の Audio Clip をマイク入力に設定
引数は、デバイス名（null ならデフォルト）、ループ、何秒取るか、サンプリング周波数

*audioSource.Play();
再生開始（録った先から再生、スピーカーから出力するとハウリングします）

*MouthOpenParameter.Value = Mathf.Clamp01(currentVolume);
CubismParameterの更新はLateUpdate()内で行う必要がある点に注意

*SetParameter(HeadAngleX, currentRotateion.x);
頭の角度

*SetParameter(EyeBallX, currentRotateion.x * EyeBallXRate * (ReversedGazing ? -1 : 1));
眼球の向き


*str = "";
文字列とストップウォッチをリセット

*Debug.Log ("+= s1：" + (TotalTime / 10) + "ms");
かかった時間を表示

*Debug.Log ("Append (s1)：" + (TotalTime / 10) + "ms");
かかった時間を表示

*Debug.Log ("+= s2 + s3：" + (TotalTime / 10) + "ms");
かかった時間を表示

*Debug.Log ("Append (s2).Append (s3)：" + (TotalTime / 10) + "ms");
かかった時間を表示

*Debug.Log ("Append (s2 + s3)：" + (TotalTime / 10) + "ms");
かかった時間を表示


*HttpRequestBody<NurieImageEntity> requestBody;*try {requestBody = await req.GetBodyAsync<NurieImageEntity>();}
バリデーション

*Bitmap fgBitmap, bgBitmap;*try {fgBitmap = entity.image_fg_datauri.ReadAsBitmap();}
ビットマップへの変換

*var cropFgToolbar = false;
ペン入力ツールバーのクロップ有無

*var nurieBitmap = MergeTwoImages(fgBitmap, bgBitmap, cropFgToolbar);
画像の合成

*Bitmap fgBitmap;*if (cropToolbar) {fgBitmap = fg.Clone(new Rectangle(0, 0, fg.Width, fg.Height - 60), fg.PixelFormat);}
ツールバーの60pxを切り抜き

*using (var g = Graphics.FromImage(bitmapBase)) {g.DrawImage(fgBitmap, g.VisibleClipBounds);
ビットマップに前景画像を描画


*t.text = t.text.Remove(0, line.Length + 1);
見切れている文字数が0になるまで、テキストの先頭行から消してゆく


*var spotName = result.entities.Where(e => e.type == "spot").First();
ココと

*var spotName = result.entities.Where(e => e.type == "spot").First();
ココが同じ


*public static void ForEach<T>(this IEnumerable<T> source, Action<T> action){source.All(x => {action(x); return true;});}
albireoさんの提案のコード追記


*public class Author {public int AuthorId { get; set; }public string Name { get; set; }public DateTime Birthday { get; set; }// 著者は複数の著書に紐づきますpublic IList<Book> Books { get; set; }}
著者エンティティ

*public IList<Book> Books { get; set; }
著者は複数の著書に紐づきます

*public class Book {public int BookId { get; set; }public string Title { get; set; }public int PublushYear { get; set; }// 書籍は一人の筆者に紐づきます（内容から外れるので共著はないものとする）public int AuthorId { get; set; }public Author Author { get; set; }}
書籍エンティティ

*public int AuthorId { get; set; }
書籍は一人の筆者に紐づきます（内容から外れるので共著はないものとする）

*options.SerializerSettings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
↓ JSONシリアル化で循環参照を無視する設定

*options.UseSqlServer(Configuration.GetConnectionString(nameof(RelationalEntitiesSeeding)));
DB は SQL Server local DB を使うことにします


*int num = 0;
forの処理

*int[] array2 = TestArray;
foreachの処理

*int num = 0;
forの処理

*List<int>.Enumerator enumerator = list.GetEnumerator();
foreachの処理


*using UnityEngine.UI;
UI関連コンポーネントを使うのに必要

*_button.onClick.AddListener(OnClickAction);
privateな関数を渡す場合

*_button.onClick.AddListener(() => Debug.Log("ラムダ式"));
ラムダ式で渡す場合


*List<Test> hquerymin =new List<Test>*{//ＬＩＮＱで最低点数の人のデータのみを取得tests.OrderBy(x => x.Points).First()};
List<T> リスト名 = new List<T> { LINQ文};

*tests
ＬＩＮＱで最低点数の人のデータのみを取得

*dataGridView1.DataSource = hquerymin;
表示


*Process process = Process.GetProcessById(_app.ProcessId);
SoftwareKeyboardTestAppの終了

*_drv.txtInputText.EmulateChangeText("");
txtInputTextをクリア

*_drv.cmbMode.EmulateChangeSelectedIndex(0);
ひらがなを選択

*Assert.AreEqual<System.Windows.Visibility>(_drv.grdHiragana.Visibility, System.Windows.Visibility.Visible);
ひらがなが表示、カタカナが非表示

*var btnA = _drv.GetButton("あ");
「あ」入力

*var btnI = _drv.GetButton("い");
「い」入力


*private Vector3 prevTargetPos;
前フレームのターゲットの位置

*bool move = Mathf.Abs(delta.x) > 0.0f;
手ブレ

*if (EnableFieldOfViewAtten) nowfov = Mathf.Lerp(nowfov, move ? MoveFieldOfView : FieldOfView, Time.deltaTime);*else nowfov = FieldOfView;
FoV

*void Start ()*{cam = GetComponent<Camera>();nowfov = FieldOfView;nowPos = TargetObject.transform.position;}
Use this for initialization

*void Update ()*{RotAngle -= Input.GetAxis("Mouse X") * 5.0f;HeightAngle += Input.GetAxis("Mouse Y") * 5.0f;HeightAngle = Mathf.Clamp(HeightAngle, 0.0f, 80.0f);var delta = TargetObject.transform.position - deltaTarget;deltaTarget = TargetObject.transform.position;// 減衰if (EnableAtten){var deltaPos = TargetObject.transform.position - prevTargetPos;prevTargetPos = TargetObject.transform.position;deltaPos *= ForwardDistance;addForward += deltaPos * Time.deltaTime * 20.0f;addForward = Vector3.Lerp(addForward, Vector3.zero, Time.deltaTime * AttenRate);nowPos = Vector3.Lerp(nowPos, TargetObject.transform.position + Vector3.up * Height + addForward, Mathf.Clamp(Time.deltaTime * AttenRate, 0.0f, 1.0f));}else nowPos = TargetObject.transform.position + Vector3.up * Height;// 手ブレbool move = Mathf.Abs(delta.x) > 0.0f;var noise = new Vector3();if (EnableNoise){var ns = (move ? MoveNoiseSpeed : NoiseSpeed);var nc = (move ? MoveNoiseCoeff : NoiseCoeff);var t = Time.time * ns;var nx = Mathf.PerlinNoise(t, t) * nc;var ny = Mathf.PerlinNoise(t + 10.0f, t + 10.0f) * nc;var nz = Mathf.PerlinNoise(t + 20.0f, t + 20.0f) * nc * 0.5f;noise = new Vector3(nx, ny, nz);}// FoVif (EnableFieldOfViewAtten) nowfov = Mathf.Lerp(nowfov, move ? MoveFieldOfView : FieldOfView, Time.deltaTime);else nowfov = FieldOfView;cam.fieldOfView = nowfov;// カメラ位置if (EnableAtten) nowRotAngle = Mathf.Lerp(nowRotAngle, RotAngle, Time.deltaTime * RotAngleAttenRate);else nowRotAngle = RotAngle;if (EnableAtten) nowHeightAngle = Mathf.Lerp(nowHeightAngle, HeightAngle, Time.deltaTime * RotAngleAttenRate);else nowHeightAngle = HeightAngle;var deg = Mathf.PI / 180.0f;var cx = Mathf.Sin(nowRotAngle * deg) * Mathf.Cos(nowHeightAngle * deg) * Distance;var cz = -Mathf.Cos(nowRotAngle * deg) * Mathf.Cos(nowHeightAngle * deg) * Distance;var cy = Mathf.Sin(nowHeightAngle * deg) * Distance;transform.position = nowPos + new Vector3(cx, cy, cz);// カメラ向きvar rot = Quaternion.LookRotation((nowPos - transform.position).normalized) * Quaternion.Euler(noise);if (EnableAtten) transform.rotation = Quaternion.Slerp(transform.rotation, rot, Time.deltaTime * AngleAttenRate);else transform.rotation = rot;}
Update is called once per frame

*bool move = Mathf.Abs(delta.x) > 0.0f;
手ブレ

*if (EnableFieldOfViewAtten) nowfov = Mathf.Lerp(nowfov, move ? MoveFieldOfView : FieldOfView, Time.deltaTime);*else nowfov = FieldOfView;
FoV

*if (EnableAtten) nowRotAngle = Mathf.Lerp(nowRotAngle, RotAngle, Time.deltaTime * RotAngleAttenRate);*else nowRotAngle = RotAngle;
カメラ位置

*var rot = Quaternion.LookRotation((nowPos - transform.position).normalized) * Quaternion.Euler(noise);*if (EnableAtten) transform.rotation = Quaternion.Slerp(transform.rotation, rot, Time.deltaTime * AngleAttenRate);
カメラ向き


*devicePort = "/dev/ttyUSB0";
Linux等(Raspbian Stretchで動作確認)

*using (var skdevice = serviceProvider.GetService<SKDevice>())*{//シリアル通信を開くskdevice.Open(devicePort, 115200, 8, Parity.None, StopBits.One);//EVENTのイベントハンドラを登録skdevice.OnEVENTReceived += (sender, e) =>{logger.LogDebug(e.ToString());};//ERXUDP(UDP受信)のイベントハンドラを登録skdevice.OnERXUDPReceived += (sender, e) =>{logger.LogDebug(e.ToString());};//各種コマンドはSKDeviceクラスにメソッドとして実装var eInfo = await skDevice.SKInfoAsync();logger.LogInformation(eInfo.ToString());var eVer = await skDevice.SKVerAsync();logger.LogInformation(eVer.ToString());}
SKDeviceクラスをインスタンス化します

*skdevice.Open(devicePort, 115200, 8, Parity.None, StopBits.One);
シリアル通信を開く

*skdevice.OnEVENTReceived += (sender, e) =>*{logger.LogDebug(e.ToString());};
EVENTのイベントハンドラを登録

*skdevice.OnERXUDPReceived += (sender, e) =>*{logger.LogDebug(e.ToString());};
ERXUDP(UDP受信)のイベントハンドラを登録

*var eInfo = await skDevice.SKInfoAsync();
各種コマンドはSKDeviceクラスにメソッドとして実装


*RtnType = null;
戻り値の型は不明とする

*Parameters = paraNames.Select((value, index) => new { Value = value, Index = index })
関数定義部がある場合

*FormulaParts = parts.ConvertAll(x =>{ParameterExpression pExpr = Array.Find(Parameters, para => para.Name == (string)x)?.DeclExpression;
パラメータ記述部分をParameterExpressionに変換

*private void ParseFuncDef(string defStr, out string[] paraNames, out string[] typeNames)*{Regex reg = new Regex("^Func\\<(?<types>.*?)\\>\\((?<paras>.*)\\)$");Match m = reg.Match(defStr);typeNames = m.Groups["types"].Value.Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);paraNames = m.Groups["paras"].Value.Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);//型の数=パラメータの数+1if (typeNames.Length == paraNames.Length + 1){//型名とパラメータ名の合理性チェックif (typeNames.All(name => GetFieldType(name) != null)){Regex regVar = new Regex("^[a-zA-Z][a-zA-Z0-9_]*$");if (paraNames.All(value => regVar.IsMatch(value)))return;}}throw new FormatException();}
関数定義部からパラメータ名と型を抽出する

*public Delegate GetDelegete(Expression rootExp)*{ParameterExpression[] paramExpressions = Parameters.Select(p => p.DeclExpression).ToArray();List<Type> declTypes = Parameters.Select(p => p.DeclType).ToList();declTypes.Add(RtnType);Type lambdaDef = LAMBDA_DEFS[paramExpressions.Length];Type genericType = lambdaDef.MakeGenericType(declTypes.ToArray());ParameterExpression valueExpression = Expression.Variable(genericType);return Expression.Lambda(Expression.Block(new[] { valueExpression },rootExp),paramExpressions).Compile();}
演算関数を作成する

*dlg3 = FormulaConverter.GetDelegate("(int)para1/2 + 5 - 10 * 2.3333d + (int)0.5f");
ForamulaConverter（関数定義なし）

*Delegate dlg15 = FormulaConverter.GetDelegate("Func<int,int,int>(x,y)=(2+x*2)/(y-2.5)*(x+5)");
ForamulaConverter（関数定義あり）

*Func<int, int, int> func15 = (x, y) => (int)((2 + x * 2) / (y - 2.5) * (x + 5));
ラムダ式（ForamulaConverter「関数定義あり」の同等コード）

*var dele = FormulaConverter.GetDelegate("Func<int,int,double>(x,y)=(int)x/2 + 5 - 10 * 2.3333d + (int)0.5f+Math.Pow(Math.Abs(y),2)");
FormulaConverter定義

*Func<int, int, double> func = (x, y) => (double)((int)x / 2 + 5 - 10 * 2.3333d + (int)0.5f + Math.Pow(Math.Abs(y), 2));
ラムダ式定義

*double TestFunc(int x,int y)*{return (double)((int)x / 2 + 5 - 10 * 2.3333d + (int)0.5f + Math.Pow(Math.Abs(y), 2));}
専用関数

*var rtn = (double)dele.DynamicInvoke(7, -5);
FormulaConverter 100万回実行

*var rtn = func(7, -5);
ラムダ式 100万回実行

*var rtn = TestFunc(7, -5);
専用関数 100万回実行


*Application.Current.Dispatcher.Invoke(delegate{if(args.TryGetValue(_ActionTypeCode, out string value))
Need to dispatch to UI thread if performing UI operations


*}
<- ここで FooDbContext.Dispose() される


*public class User*{[MaxLength(4)][Required]public string UserID { get; set; }public string UserName { get; set; }[Range(0, 999)]public int Age { get; set; }public DateTime BirthDay { get; set; }public bool IsActive { get; set; }}
Using System.ModelComponentModel.DataAnotaions が必要。


*void Ldr(int n)*{if (n > 0){Dlu(n - 1);GoLeft();Ldr(n - 1);GoDown();Ldr(n - 1);GoRight();Urd(n - 1);}}
┗

*void Urd(int n)*{if (n > 0){Rul(n - 1);GoUp();Urd(n - 1);GoRight();Urd(n - 1);GoDown();Ldr(n - 1);}}
┏┓

*void Rul(int n)*{if (n > 0){Urd(n - 1);GoRight();Rul(n - 1);GoUp();Rul(n - 1);GoLeft();Dlu(n - 1);}}
┛

*void Dlu(int n)*{if (n > 0){Ldr(n - 1);GoDown();Dlu(n - 1);GoLeft();Dlu(n - 1);GoUp();Rul(n - 1);}}
┗┛

*private void Publish(DrawInfo state)*{foreach (var observer in _observers){observer.OnNext(state);}}
状況変化を知らせるために購読者に通知する


*toGoPoint = goalPoint.transform.position;
目的地に設置したオブジェクトの座標


*#r "Microsoft.Extensions.Configuration"
DLL 参照

*using Microsoft.Extensions.Configuration;
名前空間の参照

*var config = new ConfigurationBuilder().AddEnvironmentVariables().Build();
環境変数からの取得

*}
----- 省略 -----


*EventName();
ｲﾍﾞﾝﾄ発生

*}
me.EventName += () => mc2.Show2; λでスリム
me.OnEventName();ｲﾍﾞﾝﾄ発生

*using System;
何かデリゲートの学習してるみたいだけど、元来のイベント処理手順がわかった。

*class EventClass*{public event Handler KeyHit;public void OnKeyHit(char ch){if (KeyHit != null)KeyHit(ch);}}
2.field

*class Show*{int sum = 0;public void KeyShow(char ch){if (Char.IsDigit(ch)){int a = (int)char.GetNumericValue(ch);sum += a;Console.Write($"+{a}\n");Console.Write($"={sum}\n");}else if (ch == 'c'){sum = 0;Console.Write("合計がクリアされました\n");}else return;}}
3.handler

*class Event2*{public static void Main(){ConsoleKeyInfo cki;EventClass ec = new EventClass();Show s = new Show();ec.KeyHit += new Handler(s.KeyShow);while (true){if (Console.KeyAvailable){cki = Console.ReadKey(true);if (cki.KeyChar == 'x')break;else ec.OnKeyHit(cki.KeyChar);}}}}
4.Main

*,,,
何かデリゲートの学習してるみたいだけど、元来のイベント処理手順がわかった。

*Func<int, bool> IsOdd = (n) =>*{return n % 2 != 0;};
ラムダ式でデリゲートを定義して使う従来の書き方

*bool IsEven(int n)
出力：odds=1,3,5,7,9
ローカル関数も、通常のメソッドと同様にデリゲートとして扱える

*}
出力：evens=2,4,6,8,10


*RaycastHit hit;
レイが衝突したオブジェクト

*}
もしrayとhitが衝突した場合．．．の処理内容

*}
もしhitのタグが"Block"と一致していた場合．．．の処理内容

*}
もしhitのレイヤーが指定した"レイヤーの名前"と一致していた場合．．．の処理内容


*public class xxxValueObject*{private IyyyService yyyService { get; }public int Value { get; }// staticファクトリーメソッド.必要なら値チェックしてから生成.public static xxxValueObject Create(IyyyService _yyyService, int _value)=> new xxxValueObject(_yyyService, _value);private xxxValueObject(IyyyService _yyyService, int _value){yyyService = _yyyService;Value = _value;}public int ここでやらなければならないこと => yyyService.なんかやる(Value);// 以下、等価性担保...}
値オブジェクト.

*public static xxxValueObject Create(IyyyService _yyyService, int _value)
staticファクトリーメソッド.必要なら値チェックしてから生成.

*...
以下、等価性担保

*public class zzzModel*{private IyyyService yyyService { get; }// コンストラクタインジェクション.public zzzModel(IyyyService _yyyService){yyyService = _yyyService;}// 使用する場所.public void hogehoge(){var vo = xxxValueObject.Create(yyyService, 10);// vo.ここでやらなければならないこと を呼んでなんかやる.// vo.ここでやらなければならないこと を使わないときでも注入必要....}}
使用するクラス.

*public zzzModel(IyyyService _yyyService)*{yyyService = _yyyService;}
コンストラクタインジェクション.

*public void hogehoge()*{var vo = xxxValueObject.Create(yyyService, 10);// vo.ここでやらなければならないこと を呼んでなんかやる.// vo.ここでやらなければならないこと を使わないときでも注入必要....}
使用する場所.

*...
vo.ここでやらなければならないこと を呼んでなんかやる.
vo.ここでやらなければならないこと を使わないときでも注入必要.


*Debug.WriteLine(EnumHelper.FromAlias<SampleEnum>("N"));
エイリアスから列挙値へ変換

*Debug.WriteLine(EnumHelper.FromAlias<SampleEnum>("X"));
存在しないエイリアスから列挙値への変換

*Debug.WriteLine(EnumHelper.GetAlias(SampleEnum.None));
列挙値をエイリアスに変換

*Debug.WriteLine(SampleEnum.Left.GetAlias());
列挙値をエイリアスに変換（拡張メソッド版）

*EnumHelper.RegistAlias<SampleEnum>(enumValue =>{定義名を大文字に変換したものをエイリアスとするreturn new EnumAliasInfo(enumValue.ToString().ToUpper());
任意の変換メソッドを登録した変換

*return new EnumAliasInfo(enumValue.ToString().ToUpper());
定義名を大文字に変換したものをエイリアスとする

*Debug.WriteLine(EnumHelper.GetDisplayName(SampleEnum.None));
表示名を取得

*Debug.WriteLine(SampleEnum.Left.GetDisplayName());
表示名を取得（拡張メソッド版）

*IList<SampleEnum> values = EnumHelper.GetOrderedValues<SampleEnum>(false);
表示順で列挙値を取得

*IList<SampleEnum> values = EnumHelper.GetOrderedValues<SampleEnum>(true);
表示順で列挙値を取得（非表示を除く）

*EnumHelper.RegistDisplayInfo<SampleEnum>(enumValue =>{定義名を大文字に変換したものを表示名とする数値に変換したものを表示順とするreturn new EnumDisplayInfo(enumValue.ToString().ToUpper(), (int)enumValue);
任意の変換メソッドを登録した変換

*return new EnumDisplayInfo(enumValue.ToString().ToUpper(), (int)enumValue);
定義名を大文字に変換したものを表示名とする
数値に変換したものを表示順とする

*Debug.WriteLine(EnumHelper.ToNumericString(SampleEnum.Left));
数値文字列へ変換

*Debug.WriteLine(SampleEnum.Left.ToNumericString());
数値文字列へ変換（拡張メソッド版）

*Debug.WriteLine(EnumHelper.FromNumericString<SampleEnum>("1"))
数値文字列から変換


*var writer = new StringWriter();
出力先のWriterを定義

*SaveData save = new SaveData();
セーブするデータを作成

*string xml=XMLClass.SaveToString<SaveData>(save);
データをXML化

*SaveData sdata =XMLClass.LoadFromString<T>(string s);
データをxmlから復元

*Console.WriteLine(sdata.data);
データの確認


*[AllowAnonymous]
認証トークン発行

*// ID のユーザー情報を返す*[HttpGet("{id}")]
認証が必要

*[HttpGet("{id}")]
ID のユーザー情報を返す

*public class AppUser {public int ID { get; set; }public string UserName { get; set; }public string Password { get; set; }public string Token { get; set; }}
ユーザーモデル

*public class MyDbContext : DbContext {public MyDbContext(DbContextOptions<MyDbContext> options): base(options) { }public DbSet<AppUser> Users { get; set; }protected override void OnModelCreating(ModelBuilder modelBuilder) =>modelBuilder.Entity<AppUser>().HasData(new AppUser { ID = 1, UserName = "user1", Password = "password1" },new AppUser { ID = 2, UserName = "user2", Password = "password2" });}
データベースコンテキスト

*AppUser IAuthService.Authenticate(string userName, string password) {var foundUser = myDbContext.Users.SingleOrDefault(x => x.UserName == userName && x.Password == password);if (foundUser is null) {return null;}foundUser.Token = GetSerializedToken(foundUser.ID, expiredDay: DateTime.UtcNow.AddDays(7));foundUser.Password = null;return foundUser;}
認証処理

*string GetSerializedToken(int id, DateTime expiredDay) {var tokenHandler = new JwtSecurityTokenHandler();// 秘密鍵var key = Encoding.ASCII.GetBytes(appSettings.Secret);var tokenDescriptor = new SecurityTokenDescriptor {Subject = new ClaimsIdentity(new Claim[] {new Claim(ClaimTypes.Name, id.ToString())}),// 有効期限Expires = expiredDay,// 署名SigningCredentials = new SigningCredentials(key: new SymmetricSecurityKey(key),algorithm: SecurityAlgorithms.HmacSha256Signature)};var token = tokenHandler.CreateToken(tokenDescriptor);var serializedToken = tokenHandler.WriteToken(token);return serializedToken;}
token 発行

*var key = Encoding.ASCII.GetBytes(appSettings.Secret);*var tokenDescriptor = new SecurityTokenDescriptor {Subject = new ClaimsIdentity(new Claim[] {new Claim(ClaimTypes.Name, id.ToString())}),// 有効期限Expires = expiredDay,// 署名SigningCredentials = new SigningCredentials(key: new SymmetricSecurityKey(key),algorithm: SecurityAlgorithms.HmacSha256Signature)};
秘密鍵

*Expires = expiredDay,署名SigningCredentials = new SigningCredentials(key: new SymmetricSecurityKey(key),algorithm: SecurityAlgorithms.HmacSha256Signature)};
有効期限

*SigningCredentials = new SigningCredentials(key: new SymmetricSecurityKey(key),
署名

*services.AddDbContext<MyDbContext>(options => {options.UseInMemoryDatabase(databaseName: "MyDb");
インメモリ DB を使う設定

*var appSettingsSection = Configuration.GetSection("AppSettings");
appsettings.json の AppSettings に 秘密鍵があるので設定を読み取ります。
※本来は環境変数などから読み取ります。

*app.UseCors(corsPolicyBuilder => {corsPolicyBuilder.AllowAnyOrigin()
クロスオリジンを想定しているので


*_view.Title = "MvpWinFormsTest!";
HACK: 本当はこのあたりはModelから取得されるはずのデータ


*using (var fs = new System.IO.FileStream(fileFullPath, System.IO.FileMode.Open, System.IO.FileAccess.Read)){データ格納用の配列を確保するresult = new byte[fs.Length];
ファイルを読み取りモードで開く

*result = new byte[fs.Length];
データ格納用の配列を確保する

*await fs.ReadAsync(result, 0, (int)fs.Length);
バイナリデータを非同期的に読み込む


*int len = src.Count;
nは1以上かつsrcの長さよりも短い必要がある。


*public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)*{var targetDate = (DateTime)values[0];// ----------------省略----------------,,,
*[HtmlExporter]
←これ

*}
(略)


*skillResponse.Response.ShouldEndSession = true;
セッション終了を指定


*var attrManager=new AttributesManager(userId,_tableName);
このインスタンス化でテーブルが作られます。
userIdはセッション情報から取得します。
これがプライマリキー（id）として使われます。

*attrManager.SetPersistentAttributes("sign", "ふたご座");
ユーザーの星座情報をsignをキーにしてセット。
任意のキーで数値、文字列、一次元のリストや配列を格納することができます。
ここではまだ変数に追加しているだけ。

*attrManager.SavePersistentAttributes();
セットした情報をDynamoDBに保存。
ここでDynamoDBに追加！

*var attr=attrManager.GetPersistentAttributes();
値の取得


*NpgsqlCommand cmd = null;
SQL処理で用いる変数を予め宣言

*string conn_str1 = "Server=192.168.56.111;Port=5432;User ID=postgres;Database=tes_db1;Password=password;Enlist=true";
接続文字列

*using (TransactionScope ts = new TransactionScope()){接続その1(tes_db1へ接続)using (NpgsqlConnection conn1 = new NpgsqlConnection(conn_str1)){PostgreSQLへ接続後、INSERT処理を実施し、SELECT結果を取得conn1.Open();
TransactionScopeの利用(分散トランザクション)

*using (NpgsqlConnection conn1 = new NpgsqlConnection(conn_str1)){PostgreSQLへ接続後、INSERT処理を実施し、SELECT結果を取得conn1.Open();
接続その1(tes_db1へ接続)

*conn1.Open();
PostgreSQLへ接続後、INSERT処理を実施し、SELECT結果を取得

*cmd_str = "DELETE FROM test1";
test対象のテーブルをリセット(全データDELETE)

*cmd_str = "INSERT INTO test1 VALUES(1, 'AAA'), (2, 'BBB')";
INSERT処理

*dt = new DataTable();
SELECT処理

*Console.WriteLine("tes_db1:");
SELECT結果表示

*using (NpgsqlConnection conn2 = new NpgsqlConnection(conn_str2)){PostgreSQLへ接続後、INSERT処理を実施し、SELECT結果を取得conn2.Open();
接続その2(tes_db2へ接続)

*conn2.Open();
PostgreSQLへ接続後、INSERT処理を実施し、SELECT結果を取得

*cmd_str = "DELETE FROM test2";
test対象のテーブルをリセット(全データDELETE)

*cmd_str = "INSERT INTO test2 VALUES(3, 'ccc'), (4, 'ddd')";
INSERT処理

*dt = new DataTable();
SELECT処理

*Console.WriteLine("tes_db2:");
SELECT結果表示

*ts.Complete();
トランザクション完了

*NpgsqlCommand cmd = null;
SQL処理で用いる変数を予め宣言

*string conn_str = "Server=123.45.67.89;Port=5432;User ID=postgres;Database=postgres;Password=password;Enlist=true";
接続文字列

*using (TransactionScope ts = new TransactionScope()){接続その1using (NpgsqlConnection conn1 = new NpgsqlConnection(conn_str)){PostgreSQLへ接続後、INSERT処理を実施conn1.Open();
TransactionScopeの利用

*using (NpgsqlConnection conn1 = new NpgsqlConnection(conn_str)){PostgreSQLへ接続後、INSERT処理を実施conn1.Open();
接続その1

*conn1.Open();
PostgreSQLへ接続後、INSERT処理を実施

*cmd_str = "DELETE FROM test";
test対象のテーブルをリセット(全データDELETE)

*cmd_str = "INSERT INTO test VALUES(1, 'AAA'), (2, 'BBB'), (3, 'CCC')";
INSERT処理

*using (NpgsqlConnection conn2 = new NpgsqlConnection(conn_str)){PostgreSQLへ接続後、DELETE処理を実施し、SELECT結果を取得conn2.Open();
接続その2

*conn2.Open();
PostgreSQLへ接続後、DELETE処理を実施し、SELECT結果を取得

*cmd_str = "DELETE FROM test WHERE col1 % 2 = 0";
DELETE処理

*dt = new DataTable();
SELECT処理

*ts.Complete();
トランザクション完了

*string conn_str = "Server=123.45.67.89;Port=5432;User ID=postgres;Database=postgres;Password=password;Enlist=true";
接続文字列

*conn.Open();
PostgreSQLへ接続

*NpgsqlCommand cmd = null;
SQL処理で用いる変数を予め宣言

*string conn_str = "Server=123.45.67.89;Port=5432;User ID=postgres;Database=postgres;Password=password;Enlist=true";
接続文字列

*using (TransactionScope ts = new TransactionScope()){接続その1using (NpgsqlConnection conn = new NpgsqlConnection(conn_str)){PostgreSQLへ接続後、INSERT、DELETE処理を実施し、SELECT結果を取得conn.Open();
TransactionScopeの利用

*using (NpgsqlConnection conn = new NpgsqlConnection(conn_str)){PostgreSQLへ接続後、INSERT、DELETE処理を実施し、SELECT結果を取得conn.Open();
接続その1

*conn.Open();
PostgreSQLへ接続後、INSERT、DELETE処理を実施し、SELECT結果を取得

*cmd_str = "DELETE FROM test";
test対象のテーブルをリセット(全データDELETE)

*cmd_str = "INSERT INTO test VALUES(1, 'AAA'), (2, 'BBB'), (3, 'CCC')";
INSERT処理

*cmd_str = "DELETE FROM test WHERE col1 % 2 = 0";
DELETE処理

*dt = new DataTable();
SELECT処理

*ts.Complete();
トランザクション完了


*}
ここに書く

*}
ここに書く


*//Platforms.SetPlatform<SystemDrawingPlatform>();*}
.NET Coreのパッケージの場合は、このコードが必要？

*}*public EasyCanvas(int width, int height) {canvas = Platforms.Current.CreateImageCanvas(new Size(width, height), scale: 2);}
Platforms.SetPlatform<SystemDrawingPlatform>();

*private Dictionary<string, bool> MakeRule(int rule) {var list = new[] {"111", "110", "101", "100", "011", "010", "001", "000"};return list.Reverse().Select(k => {var b = (rule & 0x01) == 0x01;rule = rule >> 1;return new { Key = k, Value = b };}).ToDictionary(p => p.Key, p => p.Value);}
ルール番号からルールを作成

*public IEnumerable<bool[]> AllGenerations() {yield return _cells;while (true) {List<bool> area = new List<bool>();foreach (var la in GetAdjoints()) {area.Add(_rule[LocalAreaToString(la)]);}_cells = area.ToArray();yield return _cells;}}
すべての世代を列挙する。永遠に列挙するので注意。

*string LocalAreaToString(bool[] area) {string s = "";foreach (var a in area) {s += a == true ? "1" : "0";}return s;}
３つのセルを文字列に変換

*IEnumerable<bool[]> GetAdjoints() {bool[] area = new bool[3];for (int i = 0; i < _cells.Length; i++) {area[0] = (i == 0) ? false : _cells[i - 1];area[1] = _cells[i];area[2] = (i == _cells.Length - 1) ? false : _cells[i + 1];yield return area;}}
隣接した３つのセルを配列として順に取り出す。


*int Num = 2000000;
リストの最大値


*private static List<TodoItem> items = new List<TodoItem>() {new TodoItem() { Id = 1, Name = @"犬の散歩", IsDone = false, },new TodoItem() { Id = 2, Name = @"買い物", IsDone = true, },new TodoItem() { Id = 3, Name = @"本棚の修理", IsDone = false },};
Todoアイテムの初期データ。本来はデータベースなどから取得する。

*item.Id = items.Max(i => i.Id) + 1;
新しいTodoItemのIdは、最大値＋１にする
本当はSQLでやる


*private static bool hasDoneSomething;
static member

*int foo;
フィールド

*public int Foo { get {...} set { ... } }
プロパティ

*void MyMethod(int number)*{int value = number + 2;Debug.Log(value);}
メソッド


*rectTransform.anchorMin = targetMinAnchor;*rectTransform.anchorMax = targetMaxAnchor;
anchorの更新

*var diffLeft = parent.rect.width * diffMin.x;*var diffRight = parent.rect.width * diffMax.x;
上下左右の距離の差分を計算

*rectTransform.sizeDelta += new Vector2(diffLeft - diffRight, diffBottom - diffTop);*var pivot = rectTransform.pivot;
サイズと座標の修正

*var rectTransform = transform as RectTransform;*// Pivotを(0.0f,0.0f)にする
使い方

*rectTransform.SetPivotWithKeepingPosition(Vector2.zero);*// Pivotを(0.2f,0.7f)にする
Pivotを(0.0f,0.0f)にする

*rectTransform.SetPivotWithKeepingPosition(0.2f, 0.7f);*// Anchorを中心(0,5f,0.5f)にする
Pivotを(0.2f,0.7f)にする

*rectTransform.SetAnchorWithKeepingPosition(0.5f, 0.5f);*// AnchorMinを左下(0.0f,0.0f)、AnchorMacを右上(1.0f,1.0f)にする (ストレッチ)
Anchorを中心(0,5f,0.5f)にする

*rectTransform.SetAnchorWithKeepingPosition(Vector2.zero, Vector2.one);*,,,
AnchorMinを左下(0.0f,0.0f)、AnchorMacを右上(1.0f,1.0f)にする (ストレッチ)

*void SetPivotWithKeepingPosition(Vector2 targetPivot)
座標を保ったままPivotを変更するメソッド

*void SetAnchorWithKeepingPosition(Vector2 targetMinAnchor, Vector2 targetMaxAnchor)
座標を保ったままAnchorを変更する

*rectTransform.SetPivotWithKeepingPosition(Vector2.zero);*// Pivotを(0.2f,0.7f)にする
Pivotを(0.0f,0.0f)にする

*rectTransform.SetPivotWithKeepingPosition(0.2f, 0.7f);*// Anchorを中心(0,5f,0.5f)にする
Pivotを(0.2f,0.7f)にする

*rectTransform.SetAnchorWithKeepingPosition(0.5f, 0.5f);*// AnchorMinを左下(0.0f,0.0f)、AnchorMacを右上(1.0f,1.0f)にする (ストレッチ)
Anchorを中心(0,5f,0.5f)にする

*rectTransform.SetAnchorWithKeepingPosition(Vector2.zero, Vector2.one);*,,,
AnchorMinを左下(0.0f,0.0f)、AnchorMacを右上(1.0f,1.0f)にする (ストレッチ)


*namespace Sample.AnyLibrary*{public class Index{// 任意の処理（これをラップしたい）public OutParam Execute(InParam param) {  /* ... */ }}public class InParam { /* ... */ }public class OutParam { /* ... */ }}
任意のライブラリ

*public OutParam Execute(InParam param) {  /* ... */ }
任意の処理（これをラップしたい）

*namespace AnyLibraryAdapter*{public class IndexAdapter{public Index Index { get; }public Converter Converter { get; }public IndexAdapter(Index index, Converter converter){Index = index;Converter = converter;}// 任意の処理のラッパー処理public OutParam Execute(InParam param){// パラメーターもラップするvar inParam = Converter.ConvertToInnerInParam(param);// 対象の処理を実行するvar result = Index.Execute(inParam);// 戻り値もラップするreturn Converter.ConvertToOuterOutParam(result);}}public class Converter{// ラッパー用の InParam から ライブラリ用の InParam へ変換するpublic AnyLibrary.InParam ConvertToInnerInParam(InParam param) {  /* ... */ }// ライブラリ用の OutParam からラッパー用の OutParam へ変換するpublic OutParam ConvertToOuterOutParam(AnyLibrary.OutParam param) {  /* ... */ }}public class InParam { /* ... */ }public class OutParam { /* ... */ }}
ライブラリのアダプター（ラッパー）

*public OutParam Execute(InParam param)*{// パラメーターもラップするvar inParam = Converter.ConvertToInnerInParam(param);// 対象の処理を実行するvar result = Index.Execute(inParam);// 戻り値もラップするreturn Converter.ConvertToOuterOutParam(result);}
任意の処理のラッパー処理

*var inParam = Converter.ConvertToInnerInParam(param);
パラメーターもラップする

*var result = Index.Execute(inParam);
対象の処理を実行する

*return Converter.ConvertToOuterOutParam(result);
戻り値もラップする

*public AnyLibrary.InParam ConvertToInnerInParam(InParam param) {  /* ... */ }
ラッパー用の InParam から ライブラリ用の InParam へ変換する

*public OutParam ConvertToOuterOutParam(AnyLibrary.OutParam param) {  /* ... */ }
ライブラリ用の OutParam からラッパー用の OutParam へ変換する

*public class Container*{// 対象処理をラップする処理public U Execute<T, U>(Func<TransactionInfo, T, U> proc, T param){// トランザクション情報を取得するvar info = GetTransactionInfo();// トランザクションを開始するStartTransaction(info);try{// 対象処理を実行するvar result = proc(info, param);// トランザクションをコミットするCommitTransaction(info);// 対象処理の戻り値を返すreturn result;}catch (Exception){// 例外が発生した場合// トランザクションをロールバックするRollbackTransaction(info);// 発生した例外はそのままスローするthrow;}}// Overloadpublic T Execute<T>(Func<TransactionInfo, T> proc) { /* ... */ }public void Execute<T>(Action<TransactionInfo, T> proc, T param) { /* ... */ }public void Execute<T>(Action<TransactionInfo> proc) { /* ... */ }// Private Methodprivate TransactionInfo GetTransactionInfo() { /* ... */ }private void StartTransaction(TransactionInfo info) { /* ... */ }private void CommitTransaction(TransactionInfo info) { /* ... */ }private void RollbackTransaction(TransactionInfo info) { /* ... */ }}
コンテナー（ラッパー相当）

*public U Execute<T, U>(Func<TransactionInfo, T, U> proc, T param)*{// トランザクション情報を取得するvar info = GetTransactionInfo();// トランザクションを開始するStartTransaction(info);try{// 対象処理を実行するvar result = proc(info, param);// トランザクションをコミットするCommitTransaction(info);// 対象処理の戻り値を返すreturn result;}catch (Exception){// 例外が発生した場合// トランザクションをロールバックするRollbackTransaction(info);// 発生した例外はそのままスローするthrow;}}
対象処理をラップする処理

*var info = GetTransactionInfo();
トランザクション情報を取得する

*StartTransaction(info);
トランザクションを開始する

*var result = proc(info, param);
対象処理を実行する

*CommitTransaction(info);
トランザクションをコミットする

*return result;
対象処理の戻り値を返す

*RollbackTransaction(info);
例外が発生した場合
トランザクションをロールバックする

*throw;
発生した例外はそのままスローする

*public T Execute<T>(Func<TransactionInfo, T> proc) { /* ... */ }
Overload

*private TransactionInfo GetTransactionInfo() { /* ... */ }
Private Method

*public class TransactionInfo { /* ... */ }
何かしらトランザクションに関係する情報

*public class Client*{public Container Container { get; }public Client(Container container){Container = container;}// メイン処理public void MainProcess(){// 対象処理に必要なパラメーターを用意するvar param = new Param();// ラッパー経由で処理を実行するvar result = Container.Execute(TargetProcess, param);// 受け取った結果を使って何かする// ...}// 対象処理 → ※ これをラップしたいprivate Result TargetProcess(TransactionInfo info, Param param) { /* ... */ }// 対象処理の引数と戻り値private class Param { /* ... */ }private class Result { /* ... */ }}
ラッパーを使う人

*public void MainProcess()*{// 対象処理に必要なパラメーターを用意するvar param = new Param();// ラッパー経由で処理を実行するvar result = Container.Execute(TargetProcess, param);// 受け取った結果を使って何かする// ...}
メイン処理

*var param = new Param();
対象処理に必要なパラメーターを用意する

*var result = Container.Execute(TargetProcess, param);
ラッパー経由で処理を実行する

*}
受け取った結果を使って何かする
...

*private Result TargetProcess(TransactionInfo info, Param param) { /* ... */ }
対象処理 → ※ これをラップしたい

*private class Param { /* ... */ }
対象処理の引数と戻り値


*public DetailsPage(Speaker speaker)*{//省略ButtonFace.Clicked += ButtonFaceClicked;}
上のコード省略

*ButtonFace.Clicked += ButtonFaceClicked;
省略

*async void ButtonFaceClicked(object sender, EventArgs e)*{var subscriptionKey = "<自分のkey>";//以下URLは自分のリージョンにあったやつを記載var faceEndpoint="https://westcentralus.api.cognitive.microsoft.com";FaceClient faceClient = new FaceClient(new ApiKeyServiceClientCredentials(subscriptionKey),new System.Net.Http.DelegatingHandler[] { });faceClient.Endpoint = faceEndpoint;IList<DetectedFace> faceList =await faceClient.Face.DetectWithUrlAsync(speaker.Avatar, true, false, faceAttributes);var age = faceList[0].FaceAttributes.Age;var gender = faceList[0].FaceAttributes.Gender;var happiness = faceList[0].FaceAttributes.Emotion.Happiness * 100;await DisplayAlert("faceAPI", $"Age: {age}\n Gender: {gender}\n Happiness: {happiness}%", "OK");}
省略

*FaceClient faceClient = new FaceClient(
以下URLは自分のリージョンにあったやつを記載
var faceEndpoint="https:westcentralus.api.cognitive.microsoft.com";


*Console.WriteLine(s);
2018年11月09日 17時54分54秒 + 09:00

*}
KはUTCとの時差表示(JPは+9)

*}
ローカル表記。ローカル時刻は作るしかない？


*public SslServerCredentials(IEnumerable<KeyCertificatePair> keyCertificatePairs, string rootCertificates, bool forceClientAuth);
従来のコンストラクタ

*public SslServerCredentials(IEnumerable<KeyCertificatePair> keyCertificatePairs, string rootCertificates, SslClientCertificateRequestType clientCertificateRequest);
SslClientCertificateRequestType 列挙体を受け取るコンストラクタが追加されました。

*Server server = new Server();
資格情報を指定してポートを登録します。

*, SslClientCertificateRequestType.RequestAndRequireAndVerify*);
クライアント資格情報の要求動作を指定します

*Channel = new Channel("127.0.0.1:50001"), GetClientCredentials());
資格情報を指定してチャネルを生成します。


*AmazonDynamoDBClient client = new AmazonDynamoDBClient();
これを介してDynamoDBにアクセスする

*var table = Table.LoadTable(client, tableName);
目的のテーブルを取得

*var result3 = table.GetItemAsync("testUser").Result;
id(プライマリキー)がtestUserであるレコードを取得する

*var attrData = result3["attributes"].AsDocument();
そのレコードのattributes列に格納されているデータをDocument型で取得。

*var sign=attrData["sign"];
Document型のattrDataから「sign」をキーにして値を取得。

*return new SkillResponse
手抜き確認。
Versionにsignを入れて確認する。。。


*public Color after_color;
フェード後の色


*await Task.Delay(100);
If you add wait, then, the it switch the Thread.


*item["attributes"] = attr2;
attributes列。上で作成したattr2を入れる。


*TableName = tableName,
追加先のテーブル名

*Item = new Dictionary<string, AttributeValue>*{{"id",new AttributeValue{S= userId} },{"attributes",attrs}}
各カラムの値を指定

*var result = client.PutItemAsync(request).Result;
テーブルに追加


*KeyType = KeyType.HASH
Partition key

*TableName = tableName};
テーブル名


*case Keys.Control | Keys.Z:
Ctrl + Z


*_reactivePropertyAA Completed !!
ReactivePropertyのDisposeでOnCompleted()が呼ばれる


*bioPosition.SetTargetTransform(target);
targetは対象のオブジェクトのTransform


*int Num = 1000000;
リストの最大値


*ftpReq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.NoCacheNoStore);
キャッシュしない


*MessageReceived[] receivers = GameObject.FindObjectsOfType<Fungus.MessageReceived>();
シーン中のFlowchartのExecuteOnEventに設定されたMessageReceivedを取得する


*void JumpToScene()
シーンの切り替え


*var receivedMessage = turnContext.Activity.Text;
メッセージ取得

*string registerKey = "docomoAPIから取得したKey";
本当は関数に切り出した方がいいんだろうけど、とりあえずここにdocomoAPIの処理
string baseUrl = "https:api.apigw.smt.docomo.ne.jp/naturalChatting/v1/dialogue";
key


*} else {



*var c = new MyClass(10);
コンパイルエラー

*var dict = new Dictionary<string, int> {["apple"] = 100,["orange"] = 150,["banana"] = 200};
`<string, int>`を省略できない

*// クラス名を同じにするとそれっぽい（型引数あるなしでユーザー定義型として区別可能）*static class Dictionary {public static Dictionary<TKey, TValue> New<TKey, TValue>(params (TKey key, TValue value)[] tuples) {var dict = new Dictionary<TKey, TValue>();foreach (var (key, value) in tuples) {dict.Add(key, value);}return dict;}}
Dictionary<TKey, TValue>のファクトリークラス

*static class Dictionary {public static Dictionary<TKey, TValue> New<TKey, TValue>(params (TKey key, TValue value)[] tuples) {var dict = new Dictionary<TKey, TValue>();foreach (var (key, value) in tuples) {dict.Add(key, value);}return dict;}}
クラス名を同じにするとそれっぽい（型引数あるなしでユーザー定義型として区別可能）


*SuppressChangeType = 131072,
0x00020000


*item.PropertyChanged += OnPropertyChanged;
イベント変更通知を登録


*root.AddEntry(dir1);
フォルダーを追加する

*root.AddEntry(file1);
ファイルを追加する

*item.Output(someDepth + 1);
階層を1つ深くする


*manager.AddComponent<BoidPrefabType>(prefab_entity);
Prefabであることを示す空のComponent

*manager.RemoveComponent<BoidPrefabType>(entity);
BoidPrefabType を BoidType に付け替え

*manager.SetComponentData(entity, new Translation { Value = this.random.NextFloat3(1f) });
適当に値を設定

*float dt = Time.DeltaTime;
パラメータをローカル変数として置いておき、ラムダ式にキャプチャさせる

*Dependency = Entities.WithName("MoveJob").WithAll<BoidType>().
ジョブの定義

*private EntityQuery query;
チャンク検索のため EntityQuery が必須 (IJobEntityBatch.Schedule()の引数)

*[ReadOnly] public ComponentTypeHandle<Translation> translationHandle;
アクセサのハンドルを受け取るためのメンバ。 var で受け取れないのでひたすら面倒

*for(int i=0; i<batchInChunk.Count; i++)
チャンク内のイテレーションは自分で書く。
1段ネストが増える分手間だしバグ混入の危険も増える

*pos_array.Dispose();
ComponentType のアクセサが NativeArray<> を返すので Dispose する必要がある

*translationHandle = GetComponentTypeHandle<Translation>(),
必要な ComponentType, BufferType の Handle をいちいち渡す必要がある

*Dependency = job.ScheduleParallel(query, 1, Dependency);
ここで渡す EntityQuery も自分で組み立てる必要がある


*public readonly ItemApi Api = new ItemApi();*private App() {}
App.Instance.Api でアクセスできるようにする

*private AsyncSubject<List<ItemInfo>> m_ItemInfos = new AsyncSubject<List<ItemInfo>>();
非同期専用のSubject

*item.ActionOnClick += val =>*{Debug.Log("clicked: " + val.name);};
アクションイベントの登録（委譲元）

*public Action<ItemInfo> ActionOnClick;
アクションイベントを実行する（委譲先）


*public IEnumerable<List<string>> ReadCsvData(IEnumerable<string> data)*{// 返却用リストList<string> retLine = new List<string>();// データの改行有無フラグbool hasNewLine = false;foreach(string line in data){int iStart = 0;// 前の読み取り行に改行付きデータがあれば、ダブルクォートの終点探しif (hasNewLine){retLine[retLine.Count - 1] += Environment.NewLine;int iEnd = SearchCloseQuot(line, iStart);if (iEnd == -1){retLine[retLine.Count - 1] += line.Replace("\"\"", "\"");continue;}retLine[retLine.Count - 1] += line.Substring(iStart, iEnd).Replace("\"\"", "\"");hasNewLine = false;iStart = line.IndexOf(',', ++iEnd);if(iStart == -1){yield return retLine;retLine = new List<string>();continue;}iStart++;}// 行始まりか、前行からの改行データ終わりから読み取り開始for (; iStart < line.Length; iStart++){//始点がダブルクォートなら、終点のダブルクォートの探索if(line[iStart] == '"'){int iEnd = SearchCloseQuot(line, iStart + 1);if (iEnd == -1){retLine.Add(line.Substring(iStart));hasNewLine = true;break;}retLine.Add(line.Substring(iStart + 1, iEnd - iStart - 1).Replace("\"\"", "\""));if(iEnd == line.Length - 1){break;}else{iStart = line.IndexOf(',', iEnd + 1);continue;}}// 始点がカンマなら、空文字データがあるとして処理else if (line[iStart] == ','){retLine.Add("");continue;}// 始点がそれ以外なら、次のカンマを探索else{int iEnd = line.IndexOf(',', iStart);if(iEnd == -1){retLine.Add(line.Substring(iStart).Trim());break;}else{retLine.Add(line.Substring(iStart, iEnd - iStart));iStart = iEnd;continue;}}}// 行内のデータに改行がなければ、リストを返却してリセットif (!hasNewLine){if (line.Length == 0 || line[line.Length - 1] == ','){retLine.Add("");}yield return retLine;retLine = new List<string>();}}// 読み取りが終わった時に改行があれば異常処理if (hasNewLine)throw new InvalidDataException();}
File.ReadLines(string path)辺りを引数で渡すつもりで作成

*List<string> retLine = new List<string>();
返却用リスト

*bool hasNewLine = false;
データの改行有無フラグ

*else*{int iEnd = line.IndexOf(',', iStart);if(iEnd == -1){retLine.Add(line.Substring(iStart).Trim());break;}else{retLine.Add(line.Substring(iStart, iEnd - iStart));iStart = iEnd;continue;}}
始点がそれ以外なら、次のカンマを探索

*if (hasNewLine)*throw new InvalidDataException();
読み取りが終わった時に改行があれば異常処理

*private int SearchCloseQuot(string data, int startIndex)*{for (int i = startIndex; i < data.Length; i += 2){i = data.IndexOf('"', i);if (i == data.Length - 1 || data[i + 1] != '"' || i == -1){return i;}}return -1;}
データ終端のダブルクォートを探すサブ関数


*var i = 0;
最初に0が入ってるんだからこれでいいじゃないか


*private Button[] BtnArray;
セットする配列

*BtnArray = new Button[] { Button1, Button2, Button3 };
順番を考慮して配列にセットする必要がある

*int index = Array.IndexOf(BtnArray, ((Button)sender));
イベント内で配列の何番目かを取得するには、実際に配列の中身を探しに行かなくてはいけない


*}
存在してたら実行

*}
アクティブなら実行


*public bool Dial(string number)
interface(抽象メンバ)なのでそれぞれ定義した

*interface Vehicle {// all are the abstract methods.void changeGear(int a);void speedUp(int a);void applyBrakes(int a);}
interface declaration

*class Bicycle : Vehicle{int speed;int gear;// to change gearpublic void changeGear(int newGear){gear = newGear;}// to increase speedpublic void speedUp(int increment){speed = speed + increment;}// to decrease speedpublic void applyBrakes(int decrement){speed = speed - decrement;}public void printStates(){Console.WriteLine("speed: " + speed +" gear: " + gear);}}
class implements interface

*public void changeGear(int newGear)*{gear = newGear;}
to change gear

*public void speedUp(int increment)*{speed = speed + increment;}
to increase speed

*public void applyBrakes(int decrement)*{speed = speed - decrement;}
to decrease speed

*class Bike : Vehicle {int speed;int gear;// to change gearpublic void changeGear(int newGear){gear = newGear;}// to increase speedpublic void speedUp(int increment){speed = speed + increment;}// to decrease speedpublic void applyBrakes(int decrement){speed = speed - decrement;}public void printStates(){Console.WriteLine("speed: " + speed +" gear: " + gear);}}
class implements interface

*public void changeGear(int newGear)*{gear = newGear;}
to change gear

*public void speedUp(int increment)*{speed = speed + increment;}
to increase speed

*public void applyBrakes(int decrement){speed = speed - decrement;}
to decrease speed

*public static void Main(String []args)*{// creating an instance of Bicycle// doing some operationsBicycle bicycle = new Bicycle();bicycle.changeGear(2);bicycle.speedUp(3);bicycle.applyBrakes(1);Console.WriteLine("Bicycle present state :");bicycle.printStates();// creating instance of bike.Bike bike = new Bike();bike.changeGear(1);bike.speedUp(4);bike.applyBrakes(3);Console.WriteLine("Bike present state :");bike.printStates();}
Main Method


*private Transform pivot;
キャラクターの中心にある空のオブジェクトを選択してください

*if(character == null)*character = transform.parent;
エラーが起きないようにNullだった場合、それぞれ設定

*[Range(-0.999f, -0.5f)]
カメラ上下移動の最大、最小角度です。Inspectorウィンドウから設定してください

*void Update()*{//マウスのX,Y軸がどれほど移動したかを取得しますfloat X_Rotation = Input.GetAxis("Mouse X");float Y_Rotation = Input.GetAxis("Mouse Y");//Y軸を更新します（キャラクターを回転）取得したX軸の変更をキャラクターのY軸に反映しますcharacter.transform.Rotate(0, X_Rotation, 0);//次はY軸の設定です。float nowAngle = pivot.transform.localRotation.x;//最大値、または最小値を超えた場合、カメラをそれ以上動かない用にしています。//キャラクターの中身が見えたり、カメラが一回転しないようにするのを防ぎます。if (-Y_Rotation != 0){if (0 < Y_Rotation){if (minYAngle <= nowAngle){pivot.transform.Rotate(-Y_Rotation, 0, 0);}}else{if (nowAngle <= maxYAngle){pivot.transform.Rotate(-Y_Rotation, 0, 0);}}}}
Update is called once per frame

*float X_Rotation = Input.GetAxis("Mouse X");
マウスのX,Y軸がどれほど移動したかを取得します

*character.transform.Rotate(0, X_Rotation, 0);*//次はY軸の設定です。
Y軸を更新します（キャラクターを回転）取得したX軸の変更をキャラクターのY軸に反映します

*float nowAngle = pivot.transform.localRotation.x;*//最大値、または最小値を超えた場合、カメラをそれ以上動かない用にしています。
次はY軸の設定です。

*if (-Y_Rotation != 0)
最大値、または最小値を超えた場合、カメラをそれ以上動かない用にしています。
キャラクターの中身が見えたり、カメラが一回転しないようにするのを防ぎます。

*float X_Rotation = Input.GetAxis("Mouse X");
マウスのX,Y軸がどれほど移動したかを取得します

*pivot.transform.Rotate(0, X_Rotation, 0);*//次はY軸の設定です。
Y軸を更新します（キャラクターを回転）取得したX軸の変更をキャラクターのY軸に反映します

*float nowAngle = pivot.transform.localRotation.x;*//最大値、または最小値を超えた場合、カメラをそれ以上動かない用にしています。
次はY軸の設定です。

*if (-Y_Rotation != 0)
最大値、または最小値を超えた場合、カメラをそれ以上動かない用にしています。
カメラが一回転しないようにするのを防ぎます。

*pivot.eulerAngles = new Vector3(pivot.eulerAngles.x, pivot.eulerAngles.y, 0f);
操作していると、Z軸がだんだん動いていくので、0に設定してください。


*TableName = tableName,
追加先のテーブル名

*Item = new Dictionary<string, AttributeValue>*{{"ThisIsId",new AttributeValue{N= "2"} },{"ThisIsSomething",new AttributeValue{N="5"} }}
各カラムの値を指定

*var result = client.PutItemAsync(request).Result;
テーブルに追加


*private bool _isMac;
追加する

*}
ここまで

*if (_isWindows && inputChar == 'y' && currentChar == 'i' &&*(prevChar == '\0' || prevChar == 'a' || prevChar == 'i' || prevChar == 'u' || prevChar == 'e' ||
「い」の柔軟な入力（Windowsのみ）

*if (inputChar == 'w' && currentChar == 'u' && (prevChar == '\0' || prevChar == 'a' || prevChar == 'i' ||*prevChar == 'u' || prevChar == 'e' || prevChar == 'o'))
「う」の柔軟な入力（「whu」はWindowsのみ）

*if (_isWindows && inputChar == 'c' && prevChar != 'k' &&*currentChar == 'k' && (nextChar == 'a' || nextChar == 'u' || nextChar == 'o'))
「か」「く」「こ」の柔軟な入力（Windowsのみ）

*if (inputChar == 'z' && prevChar != 'j' && currentChar == 'j' &&*(nextChar == 'a' || nextChar == 'u' || nextChar == 'e' || nextChar == 'o'))
「じゃ」「じゅ」「じぇ」「じょ」の柔軟な入力

*if (_isWindows && inputChar == 'c' && prevChar != 's' && currentChar == 's' &&*(nextChar == 'i' || nextChar == 'e'))
「し」「せ」の柔軟な入力（Windowsのみ）

*if (inputChar == 'u' && prevChar == 't' && currentChar == 's' &&*(nextChar == 'a' || nextChar == 'i' || nextChar == 'e' || nextChar == 'o'))
「つぁ」「つぃ」「つぇ」「つぉ」の柔軟な入力

*if (inputChar == 'w' && prevChar == 'f' &&*(currentChar == 'a' || currentChar == 'i' || currentChar == 'e' || currentChar == 'o'))
「ふぁ」「ふぃ」「ふぇ」「ふぉ」の柔軟な入力（一部Macのみ）

*if (inputChar == 'n' && prevChar2 != 'n' && prevChar == 'n' && currentChar != 'a' && currentChar != 'i' &&*currentChar != 'u' && currentChar != 'e' && currentChar != 'o' && currentChar != 'y')
「ん」の柔軟な入力（「n'」には未対応）

*if (inputChar == 'i' && currentChar == 'y' &&*(prevChar == 'k' || prevChar == 's' || prevChar == 't' || prevChar == 'n' || prevChar == 'h' ||
「きゃ」「にゃ」などを分解する

*if (inputChar == 'i' &&*(currentChar == 'a' || currentChar == 'u' || currentChar == 'e' || currentChar == 'o') &&
「しゃ」「ちゃ」などを分解する

*if (_isWindows && inputChar == 'c' && currentChar == 's' && prevChar != 's' && nextChar == 'y' &&*(nextChar2 == 'a' || nextChar2 == 'u' || nextChar2 == 'e' || nextChar2 == 'o'))
「しゃ」を「c」で分解する（Windows限定）

*if ((inputChar == 'x' || inputChar == 'l') &&*(currentChar == 'k' && nextChar == 'k' || currentChar == 's' && nextChar == 's' ||
「っ」の柔軟な入力

*if (_isWindows && inputChar == 'c' && currentChar == 'k' && nextChar == 'k' &&*(nextChar2 == 'a' || nextChar2 == 'u' || nextChar2 == 'o'))
「っか」「っく」「っこ」の柔軟な入力（Windows限定）

*if (_isWindows && inputChar == 'c' && currentChar == 's' && nextChar == 's' &&*(nextChar2 == 'i' || nextChar2 == 'e'))
「っし」「っせ」の柔軟な入力（Windows限定）


*options.Limits.MaxConcurrentConnections = 100;
接続最大数は 100 件までですよ

*options.Limits.MaxRequestBodySize = 100 * 1024 * 1024;
リクエスト数は100Mまでですよ


*KeyType = "RANGE"
Sort key

*ProvisionedThroughput = new ProvisionedThroughput{ReadCapacityUnits = 5,WriteCapacityUnits = 5},テーブル名TableName = tableName};
勉強中

*TableName = tableName};
テーブル名

*var result=client.CreateTableAsync(request).Result;
テーブル作成リクエストを投げる！
ただし、非同期メソッドの返りを待たねければならない。
待たないと先にこのLambdaが終了して、DynamoDBのテーブル作成処理を完了せずに終わる。
でもメソッドにasyncつけたら、最終的にスキルのレスポンスの型もTask<SkillResponse>にしなきゃいけなくなってだめ。
.Wait()メソッドで非同期メソッドを同期メソッドにしちゃえば、返り値も変えなくていいし、テーブル作成完了まで待つことができる。
一回完結のサーバー側の処理で非同期でなきゃいけない理由ないしね。
client.CreateTableAsync(request).Wait();
Waitメソッドではただ非同期メソッドの完了を待つだけでしたが、非同期メソッドの返り値を取得したい場合は、Resultプロパティを使いましょう。
Resultプロパティにアクセスすることで、非同期メソッドの完了を待った上で結果を取得することができます。
結果を使って何か処理を行いたい場合はこちらが良いのではないでしょうか。

*var tableList=client.ListTablesAsync().Result;
テーブル一覧を取得

*return tableList.TableNames.Exists(s => s.Equals(tableName));
TableNamesプロパティをチェック


*Console.ReadKey();
何かキーを押せばアプリ終了。


*var regionManager = containerProvider.Resolve<IRegionManager>();
画面遷移を行う
今回の本題とは関係ないので説明略

*public void RegisterTypes(IContainerRegistry containerRegistry)*{// ContainerRegistryが抽象化されたコンテナへの登録用Interface// GetContainerでUnityのコンテナに直接アクセスできる// NugetにてUnity、Prism.Unityを導入する必要ありvar container = containerRegistry.GetContainer();// 普通にUnityが利用可能container.RegisterType<Models.ModelA>(new InjectionFactory(x =>{return new Models.ModelA("Hello, Prism 7.x !");}));// Viewの登録containerRegistry.RegisterForNavigation<ViewA>();}
ここでコンテナへの登録作業を行う

*var container = containerRegistry.GetContainer();
ContainerRegistryが抽象化されたコンテナへの登録用Interface
GetContainerでUnityのコンテナに直接アクセスできる
NugetにてUnity、Prism.Unityを導入する必要あり

*container.RegisterType<Models.ModelA>(new InjectionFactory(x =>{return new Models.ModelA("Hello, Prism 7.x !");
普通にUnityが利用可能

*containerRegistry.RegisterForNavigation<ViewA>();
Viewの登録


*logic.Run();
IBusinessLogic には Run メソッドを作ると決める

*}
処理

*}
処理


*skillResponse.Response.ShouldEndSession = true;
セッション終了を指定

*}
テスト


*[SerializeField] private TextMeshProUGUI textRoman;
ここにローマ字表示のTextMeshProをアタッチする。


*string instanceId = await starter.StartNewAsync("HelloWorld", null);*log.LogInformation($"Started orchestration with ID = '{instanceId}'.");
Function input comes from the request content.


*public class TestMain : MonoBehaviour {void Start (){// yield return の実行テスト//StartCoroutine(TaskForYieldReturn()); // --- (1)// .MoveNext の実行テスト//StartCoroutine(TaskForMoveNext()); // --- (2)}// 直接yield return の実行テストprivate IEnumerator TaskForYieldReturn(){Debug.Log($"START : [ {Time.frameCount} ]");yield return StartCoroutine( SubTask() );Debug.Log($"END : [ {Time.frameCount} ]");}// .MoveNext の実行テストprivate IEnumerator TaskForMoveNext(){Debug.Log($"START : [ {Time.frameCount} ]");var e = SubTask();while(e.MoveNext()) { yield return e.Current; }Debug.Log($"END : [ {Time.frameCount} ]");}// 遅延処理がないコルーチンprivate IEnumerator SubTask(){Debug.Log($"SubTask : [ {Time.frameCount} ]  ");yield break;}}
コルーチン実行テスト

*}
yield return の実行テスト
StartCoroutine(TaskForYieldReturn());  --- (1)
.MoveNext の実行テスト
StartCoroutine(TaskForMoveNext());  --- (2)

*private IEnumerator TaskForYieldReturn()*{Debug.Log($"START : [ {Time.frameCount} ]");yield return StartCoroutine( SubTask() );Debug.Log($"END : [ {Time.frameCount} ]");}
直接yield return の実行テスト

*private IEnumerator TaskForMoveNext()*{Debug.Log($"START : [ {Time.frameCount} ]");var e = SubTask();while(e.MoveNext()) { yield return e.Current; }Debug.Log($"END : [ {Time.frameCount} ]");}
.MoveNext の実行テスト

*private IEnumerator SubTask()*{Debug.Log($"SubTask : [ {Time.frameCount} ]  ");yield break;}
遅延処理がないコルーチン


*AVAudioSession.SharedInstance().SetCategory(AVAudioSessionCategory.PlayAndRecord, AVAudioSessionCategoryOptions.AllowBluetooth);
Bluetoothを使う場合は AVAudioSessionCategoryOptions.AllowBluetooth が必須

*case (int)AVAudioSessionRouteChangeReason.NewDeviceAvailable:
新しくデバイス（Bluetoothやイヤホンジャック）が接続された場合

*AVAudioSession.SharedInstance().OverrideOutputAudioPort(AVAudioSessionPortOverride.None, out error);
出力先を既定にする

*case (int)AVAudioSessionRouteChangeReason.OldDeviceUnavailable:
デバイスが使えなくなった場合（Bluetoothの切断やイヤホンジャックを抜いた場合）

*AVAudioSession.SharedInstance().OverrideOutputAudioPort(AVAudioSessionPortOverride.Speaker, out error);
出力先を内蔵スピーカーに強制する


*double val = 1.12345;
文字列化したいdouble型

*Debug.WriteLine ("Before: " + val.ToString("R"));
端末依存のCultureInfoで文字列出力した場合
文字列から数値に戻せるように書式指定子にR（ラウンドトリップ書式指定子）を指定

*CultureInfo culture = CultureInfo.InvariantCulture;
CultureInfo.InvariantCultureでen-USの書式を取得

*NumberFormatInfo format = culture.NumberFormat;*// CultureInfo.InvariantCultureのNumberFormatInfoを指定して出力
数値文字列のフォーマットを取得

*Debug.WriteLine ("After: " + val.ToString ("R", format));*,,,
CultureInfo.InvariantCultureのNumberFormatInfoを指定して出力


*["apple"] = 180,
<- 重複


*if (System.Text.RegularExpressions.Regex.IsMatch(
時刻の形式が正しいか？
（数字2桁:数字2桁か簡易チェックしてOKならDateTime型に変換できるかチェックする）

*ErrMsg("時刻を正しく入力してください。例）12:34");
時刻として正しくない

*ErrMsg("メッセージを入力してください。");
メッセージ未入力（または空白しか入力されていない）

*if (timeAndMsgs.ContainsKey(timeText.Text))
時刻もメッセージも入力されている
まだ追加されていない時刻かチェック

*listBox.Items.Add(timeText.Text + "\t" + msgText.Text);
一覧に追加


*var rss = testfile.Root.Elements();
XMLファイルの取得
var testfile = XDocument.Load("http:alfalfalfa.com/index.rdf");
ルート要素を選択

*var title = x.Element("title");*if (title != null){//"title"タグの値を表示Console.WriteLine(title.Value);}
"title"タグを選択

*Console.WriteLine(title.Value);
"title"タグの値を表示

*,,,*namespace ConsoleApp1{class Program{static void Main(string[] args){//XMLファイルの取得var testfile = XDocument.Load("http://alfalfalfa.com/index.rdf");//ルート要素を選択var rss = testfile.Root.Elements();foreach(var x in rss){//Namespaseの値を取得(修正箇所)var ns = x.Name.Namespace;//ns + "title"タグを選択(修正箇所)var title = x.Element(ns + "title");if (title != null){//ns + "title"タグの値を表示Console.WriteLine(title.Value);}}}}}
何も表示されない

*var rss = testfile.Root.Elements();
XMLファイルの取得
var testfile = XDocument.Load("http:alfalfalfa.com/index.rdf");
ルート要素を選択

*var ns = x.Name.Namespace;
Namespaseの値を取得(修正箇所)

*var title = x.Element(ns + "title");*if (title != null){//ns + "title"タグの値を表示Console.WriteLine(title.Value);}
ns + "title"タグを選択(修正箇所)

*Console.WriteLine(title.Value);
ns + "title"タグの値を表示


*var pkfile = new PrivateKeyFile(keyFile, sshPasswd);
keyFile：ダウンロードしたid_rsaの物理ファイルパス
sshPasswd：「パスワードを聞かれるのでお好きなパスワード入力」で入力したパスワード

*string host = "xxxxx.sakura.ne.jp";
さくらのホスト名(xxxxx.sakura.ne.jp)

*string user = "xxxxx";
user：さくらのユーザ名(xxxxx)

*sshClient.Connect();
ここで例外エラーが起こらなければSSH接続はOK

*string serverName = "yyyyy.db.sakura.ne.jp";
さくらのサーバコントロールパネル-データベース一覧の「データベースサーバ」を設定


*[WebService(Namespace = "http:
tempuri.org")]

*public class SampleWS : System.Web.Services.WebService
この Web サービスを、スクリプトから ASP.NET AJAX をしようして呼び出せるようにするには、次の行のコメントを解除します。
[System.Web.Script.Services.ScriptService]


*hederList.Add("応答");
timings.receive

*sw.WriteLine(string.Join(",", hederList));
ヘッダー


*var prepare = awaiter.GetPrepare();
awaiterには何かしらのインターフェースを継承させておく

*prepare();
戻り値を準備させる
実際は戻り値をどのようにして準備させるかによってもっと複雑になる

*var _copy = CopyStateMachine(copy);
何度呼び出されてもいいようにもう一度コピーしてそっちを使用する


*static readonly string uri = "ws:
192.168.***.***:9090";


*System.Diagnostics.Debug.WriteLine(BaseClass.GetName<BaseClass>());
ArgumentException(´・ω・`)


*public float ClockingAlpha = 0;
参照する値

*float time = 0.0f;
変動する値

*[SerializeField] private float angularFrequency = 3.5f;
設定する値

*[SerializeField] private CanvasGroup canvasGroup;
エディタでアタッチしてもしてなくても動く


*Version = "1.0",
お約束

*return skillResponse;
とりあえずreturnしておくことにした


*ChannelState state = channel.State;
状態が変更されるまで待機する

*OnChannelStateChanged(state, channel.State);
状態が変更されたときの処理を実行する


*void Start () {ResetBlock();}
Use this for initialization

*void Update () {_iLevelValue = _dLevelValue.value;_fTimeLimit -= Time.deltaTime;if (_fTimeLimit <= 0.0){_iBlockRedMain[_iCounter].gameObject.SetActive(true);_iBlockBlueMain[_iCounter].gameObject.SetActive(true);_iCounter++;_fTimeLimit = 0.5f;}if (_iCounter == 5){ResetBlock();_iCounter = 0;}}
Update is called once per frame

*void Start () {_fBaseNumber = Mathf.Round(Random.Range(0f, 10f));_iSaveCount = 0;if (main._iLevelValue == 0) { _fWorldTime = 15;}else if (main._iLevelValue == 1) { _fWorldTime = 7;}else if (main._iLevelValue == 2) { _fWorldTime = 1;}else { _fWorldTime = 100;}_fTimeLimit = _fWorldTime;for (int i = 1;i < 6; i++){_iBlockRed[i].gameObject.SetActive(false);_iBlockBlue[i].gameObject.SetActive(false);}ResetAnswerField();MakeQuestion();}
Use this for initialization

*void Update () {_fMakeCountTimer += Time.deltaTime;if (_fWorldTime != 100) {_fTimeLimit -= Time.deltaTime;if (_fTimeLimit <= 0.0) {_iBlockRed[_iCheckNumberBlockRed].gameObject.SetActive(true);_iCheckNumberBlockRed++;_fTimeLimit = _fWorldTime;}}if (_fModValue == _fResultNumber){MakeQuestion();}_tAnswerCounterText.text = "求める値:" + _fResultNumber;_tMakeCountTimerText.text = "生成時間:" + Mathf.Round(_fMakeCountTimer);if (_iCheckNumberBlockRed == 6){SceneManager.LoadScene("Lose Scene");}else if (_iCheckNumberBlockBlue == 6){SceneManager.LoadScene("Win Scene");}}
Update is called once per frame

*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame

*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame


*double d = md.Discri(1.0, 2.0, 3.0);
代入

*namespace PC*{partial class A{int num = 0;void MethodA() { }partial void MethodC();}}
File1.cs 内:

*namespace PC*{partial class A{void MethodB() { }partial void MethodC() { }}}
File2.cs 宣言内:

*partial class Earth : Planet, IRotate { }
--

*class Earth : Planet, IRotate, IRevolve { }
これらは、次の宣言と等価です。


*xmlns:x="http:
schemas.microsoft.comwinfx2009xaml"


*Response = new ResponseBody()
お約束

*if (input.Request.Type == nameof(Alexa.NET.Request.Type.LaunchRequest))
リクエストタイプが「LaunchRequest」かそれ以外の「IntentRequest」か判別する
今回はスキル起動時に送られる「LaunchRequest」のときとそれ以外のときで異なるレスポンスを返すようにした。

*var intentRequest = (IntentRequest) input.Request;
LaunchRequest以外はこちら
つまりIntentRequestもこちら
IntentRequestの場合
SampleIntentとGreetingIntentの2種類＋ビルトインインテント数種類がある
今回は自分で登録したSmapleIntentとGreetingIntentだけを扱う。
RequestをIntentRequestにキャスト

*var intentName = intentRequest.Intent.Name;
インテント名はこのIntentRequestオブジェクトが持っている

*skillResponse.Response.ShouldEndSession = true;
セッション終了させる。


*return new Empty();
受信完了を返す

*var request = new HelloRequest{Name = "Mete - on C#",Age = 34,Sentiment = Sentiment.Happy};
Create a request

*var fs = new FileStream("00013646_72B.jpg", FileMode.Open);
チャンクデータの作成

*var task = Task.Run(async () =>*{Stopwatch sw = new Stopwatch();sw.Start();for (int i = 0; i < 100; i++){// 送信var stream = client.filesend();var chunk = Google.Protobuf.ByteString.CopyFrom(data, 0, data.Length);await stream.RequestStream.WriteAsync(new Chunk() { Chunk_ = chunk });await stream.RequestStream.CompleteAsync();var res = await stream.ResponseAsync;}sw.Stop();Console.WriteLine(sw.Elapsed);});
ファイルの送信処理

*var stream = client.filesend();
送信


*var beforeLength = _gameObjects.Length;*// nullと重複を除く
Inspectorに入力された長さを覚えておく

*_gameObjects = _gameObjects.Where(o => o != null)
nullと重複を除く

*var length = beforeLength - _gameObjects.Length;
(入力された長さ) - (現在の長さ)
で足りない長さを調べる

*_gameObjects = _gameObjects.Concat(Enumerable.Repeat<GameObject>(null, length))
不足がある場合は,足りない長さの空の配列を作ってConcatで追加

*[SerializeField]
なんの変哲もないGameObjectの配列


*if (isLeft != prev_isLeft) {
現在のプレイヤーの向きが1フレーム前と異なっていたら


*[TypeConverter(typeof(ListTypeConverter))]
*追加*


*...
send document to log storage


*Response = new ResponseBody()
お約束

*if (input.Request.Type == nameof(Alexa.NET.Request.Type.LaunchRequest))
リクエストタイプが「LaunchRequest」かそれ以外の「IntentRequest」か判別する
今回はスキル起動時に送られる「LaunchRequest」のときとそれ以外のときで異なるレスポンスを返すようにした。

*skillResponse.Response.ShouldEndSession = true;
セッション終了させる。


*OthelloCell[,] OthelloCells;
8x8のOthelloCell.csの配列参照 (Start()で生成している)

*internal bool CanPlaceHere(Vector2 location)
中略
押下された位置が反転可能かの判定

*if (OthelloCells[(int)location.x, (int)location.y].OwnerID != -1)*return false;
押下された位置は、そもそも空いているか

*return true;
一つの方向でも見つかればそれで終わり

*private OthelloCell FindAllyChipOnOtherSide(Vector2 directionVector, Vector2 fromV, bool EnemyFound)*{Vector2 to = fromV + directionVector;//ボードの外に出ていないか、空マスでないかif (IsInRangeOfBoard(to) && OthelloCells[(int)to.x, (int)to.y].OwnerID != -1){//見つかったマスのオセロは自分のオセロかif (OthelloCells[(int)to.x, (int)to.y].OwnerID == OthelloBoard.Instance.CurrentTurn){//既に間に一回敵オセロを見つけているか(つまり挟んだか)if (EnemyFound)return OthelloCells[(int)to.x, (int)to.y];return null;}else//見つかったのは敵オセロなので、EnemyFoundを真にし、自分のオセロを見つけるまで再帰的に同メソッドを呼ぶreturn FindAllyChipOnOtherSide(directionVector, to, true);}//ここまでにreturnされない場合nullを返すreturn null;}
指定された方角に対して、挟む事ができるかを判定する再帰メソッド

*if (EnemyFound)*return OthelloCells[(int)to.x, (int)to.y];
既に間に一回敵オセロを見つけているか(つまり挟んだか)

*return FindAllyChipOnOtherSide(directionVector, to, true);
見つかったのは敵オセロなので、EnemyFoundを真にし、自分のオセロを見つけるまで再帰的に同メソッドを呼ぶ

*return null;
ここまでにreturnされない場合nullを返す

*OthelloCell onOtherSide = FindAllyChipOnOtherSide(directionVector, othelloCell.Location, false);
2.2のメソッドを再利用

*ChangeOwnerBetween(othelloCell, onOtherSide, directionVector);
挟んだ敵のセルをひっくり返す

*private void ChangeOwnerBetween(OthelloCell from, OthelloCell to, Vector2 directionVector)*{for (Vector2 location = from.Location + directionVector; location != to.Location; location += directionVector){OthelloCells[(int)location.x, (int)location.y].OwnerID = CurrentTurn;}}
fromからtoの間で、挟んだ敵のセルをひっくり返す

*public int EnemyID { get { return (CurrentTurn+1) % 2; } }
敵のIDは、今のプレイヤーが0なら1、1なら0を返す

*CurrentTurn = EnemyID;
今のターンのプレイヤーを入れ替える

*return;
見つかったので無事次のプレイヤーの順番

*if (!isAlreadyEnded)*//もう一度同処理を再帰的に呼ぶ ただしisAlreadyEndedフラグを立てて呼ぶ
見つかっていない

*EndTurn(true);*else {//両プレイヤー共に置く所がないGameOver();}
もう一度同処理を再帰的に呼ぶ ただしisAlreadyEndedフラグを立てて呼ぶ

*GameOver();
両プレイヤー共に置く所がない


*Parent childInParent = new Child();
コイツの動作が変わる

*Console.ReadLine();
出力
parent.Hoge();                  Parent#Hoge()
parent.VirtualMethod();         Parent#VirtualMethod()
child.Hoge();                   Child#Hoge()
child.VirtualMethod();          Child#VirtualMethod()
childInParent.Hoge();           Parent#Hoge() ← Parentが出力（※1）
childInParent.VirtualMethod();  Child#VirtualMethod()

*public virtual void VirtualMethod() {Console.WriteLine("Parent#VirtualMethod()");}
virtualとoverride修飾子はペア（※3）

*public new void Hoge() {Console.WriteLine("Child#Hoge()");}
new修飾子で隠ぺい（※2）

*public override void VirtualMethod() {Console.WriteLine("Child#VirtualMethod()");}
オーバーライド（※3）


*var ar1 = new byte[128];
最初の領域の定義

*seg1.Memory = ar1.AsMemory();
Memory<T>としてデータを保持する

*seg1.RunningIndex = 0;
データの開始点は0

*var ar2 = new byte[128];
次の領域の定義

*seg2.RunningIndex = ar1.Length;
全体の配列で見たときの、この領域の開始点を指定する

*seg1.Next = seg2;
次の領域へのリンクを付ける

*var seq = new ReadOnlySequence<byte>(seg1, 0, seg2, seg2.Length);
開始点の場所と、終点の場所を指定する(2,4引数は、セグメント中のインデックス番号)

*}
GetEnumeratorを実装しているので、foreachでSystem.ReadOnlyMemory<T>が取得できる
開始点がSegmentの途中を指していた場合、開始点から切り取られた状態で取得ができる。

*SequencePosition pos = seq.GetPosition(N);
末尾データを取得したい場合は、seq.GetPosition(0, seq.End)のように指定する

*var segment = (ReadOnlySequenceSegment<T>)pos.GetObject();
GetObjectは必ずobjectを返すため、キャストして使用すること


*ElementCategoryFilter filter = new ElementCategoryFilter(BuiltInCategory.OST_FloorAnalytical);
フィルターセット(例では解析モデル床でフィルタリング)

*return elementIds;
要素IDを取得する


*await TagLibMP4Extentions.SetMetaTagAsync(mp4Path, new string[] { "test1", "テスト２", "test３"} );
タグの設定

*var getTag = await TagLibMP4Extentions.GetMetaTagAsync(mp4Path);
タグの取得


*www.Dispose();
<- ここで明示的に破棄を指定

*yield return Resources.UnloadUnusedAssets();
Unity にリソースの解放を依頼。あくまで依頼なので、このタイミングで確実に解放されるわけではない

*Texture2D texture = new Texture2D(2048, 2048, TextureFormat.DXT5Crunched, false);
DXT5Crunched の空のテクスチャを用意

*www.LoadImageIntoTexture(texture);
ここでテクスチャを読み込み

*texture.Compress(false);
テクスチャ圧縮

*textureArray[key] = (T)(object)texture;
圧縮後のテクスチャを割り当て

*www.Dispose()
読み込みは終わったので Dispose()


*string url = string.Format("https:
api.chatwork.comv2rooms{0}files", roomID);

*string stBuffer = cReader.ReadLine();
ファイルを 1 行ずつ読み込む

*stResult += stBuffer + System.Environment.NewLine;
読み込んだものを追加で格納する

*var reqStream = req.GetRequestStream();
データをPOST送信するためのStreamを取得

*reqStream.Write(postDataBytes, 0, postDataBytes.Length);
送信するデータを書き込む

*var res = req.GetResponse();
サーバーからの応答を受信する

*var resStream = res.GetResponseStream();
応答データを受信するためのStreamを取得

*var sr = new StreamReader(resStream, enc);
受信して表示

*var responseMessage = sr.ReadToEnd();
結果受信


*public Book(string title, string author) {
コンストラクタの引数に id を渡さない

*book.Property(e => e.Title);
book.HasKey(nameof(Book.Id)); 不要


*using JumpState = animJump.JumpState;
UniRxのJumpStateと命名が被ってしまっているので、UniRxが入っている場合に必要です。

*var isGroundHit = Physics.Raycast(
プレイヤーの位置から下向きにRaycast
レイヤーマスクでGroundを設定しているので、
地面のGameObjectにGroundのレイヤーを設定しておけば、
Groundのレイヤーを持つGameObjectで一番近いものが一つだけヒットする

*distance = float.MaxValue;
ヒットしなかった場合はキャラの下方に地面が存在しないものとして扱う


*delIntro(name);
ここで引数の関数が実行される。後ろにカッコをつけないと、関数は実行されない。

*public static void IntroduceMyself(string name)*{Console.WriteLine("Hi. I am " + name + ".");}
このメソッドを、メソッドごと変数に突っ込む予定。（※正確にはメソッドへの参照を渡す）

*DelegateSubIntroduce delIntro = Someone.IntroduceMyself;
ここでは何も出力されない。メソッドをDelegateIntroduceに代入する（※メソッドへの参照を渡す）だけ。

*Lisa.Talk(delIntro, "Yuki");
ここで初めてコンソール出力される。


*Task RunTasks<T1, T2, T3>(T1 arg1, T2 arg2, T3 arg3)*{// 例外をキャッチしてスローしなおすtry{return Task.WhenAll(Execute001Async(arg1), Execute002Async(arg2, arg3));}catch (Exception ex){throw new Exception("処理中に例外が発生しました。", ex);}}
ローカル関数を介して処理を実行する

*try*{return Task.WhenAll(Execute001Async(arg1), Execute002Async(arg2, arg3));}
例外をキャッチしてスローしなおす


*vcap.Dispose();
Memory release


*public class CommonModel*{public void CommonProc() =>Console.WriteLine("(*・з・*)");}
共通ロジック

*public class Successor : CommonModel*{}
継承の場合

*public class Director*{private CommonModel Model { get; }public Director() => Model = new CommonModel();public void CommonProc() => Model.CommonProc();}
使用の場合


*public object GetValue(int i)*{return m_Enumerator.Current[i];}
IDataReader の各メンバを実装します。ここでは割愛します。

*return expectedValues[NextRandomInt32(0, expectedValues.Count - 1)];
NextRandomInt32メソッドは指定された範囲内でランダムな値を返すメソッド

*private int NextRandomInt32(int minValue, int maxValue)*{return (RandomInt32 ?? s_DefaultRandomInt32).NextValue(minValue, maxValue);}
NextAnyメソッドから呼び出しているメソッドです。

*int dataCount = 20;
生成するデータ数

*var fields = Observable連番.Range(1, dataCount)今日から一か月間のランダムな日付.And(generator.Random(dataCount, DateTime.Today, DateTime.Today.AddMonths(1)).Select(d => d.Date))
データ項目

*.Range(1, dataCount)
連番

*.And(generator.Random(dataCount, DateTime.Today, DateTime.Today.AddMonths(1)).Select(d => d.Date))
今日から一か月間のランダムな日付

*.And(generator.Random(dataCount, 1, 100).Select(value => value.ToString("d3")))
1～100 のランダムな整数を前ゼロ編集した文字列

*.And(generator.Each(dataCount, "a", "b", "c", "d", "e"))
a, b, c, d, e を順番に返す

*.And(generator.Any(dataCount, "A", "B", "C", "D", "E"))
A, B, C, D, E の何れかを返す

*.And(generator.AnyWithProbability(dataCount, new string[] { "A", "B", "C", "D", "E" }, new double[] { 0.5, 0.3, 0.1, 0.05 }))
A, B, C, D, E の何れかを返す（A:50%, B:30%, C:10%, D:5%, E:5%）

*.And(generator.Any(dataCount, "a", "b", "c").Zip(generator.Any(dataCount, 1, 2, 3), (a, i) => a + i))
[a, b, c] と [1, 2, 3] の何れかを組み合わせた文字列

*.And(generator.RandomOrNull(dataCount, 0.25, -10000, 10000))
-10000～10000 のランダムな整数または25%の確率でnull

*var plan = fields.Then((field1, field2, field3, field4, field5, field6, field7, field8) =>*new object[] { field1, field2, field3, field4, field5, field6, field7, field8 }
データ項目の配列にまとめて返す

*var source = Observable.When(plan);
Observable なデータソースを生成


*Console.WriteLine(log);
C#


*for (int i = 0; i < 10; i++)
getｱｸｾｻに使用


*static public string ConvertEOL(string text, string toEOL ="\n"){return text.Replace("\r\n", toEOL).Replace("\r", toEOL).Replace("\n", toEOL);
改行コードを統一


*AssociatedObject.Cursor = Cursors.IBeam;
マウスオーバー時のカーソルはIビームに変更

*SelectText(AssociatedObject.ContentStart, AssociatedObject.ContentEnd);*} else {
ダブルクリック (全選択)

*Point mouseUpPoint = e.GetPosition(AssociatedObject);
選択中文字列の背景色変更

*Point mouseUpPoint = e.GetPosition(AssociatedObject);
選択終了

*TextRange ntr = new TextRange(start, end);
TextBlockから選択範囲文字列取得


*path = path.Replace("https:
", "https:" + user + ":" + pass + "@");


*[Inject] IPlayerVoiceService service)
Functionの引数にインジェクトしたい場合、Inject属性が必要だよ！

*builder.RegisterType<InMemoryPlayerVoiceRepository>().As<IPlayeVoiceRepository>();
インターフェイスと、それに対応する実装クラスを指定！
いろんな設定方法があるので、本家Autofacを参考にしてね！
https:github.com/autofac/Autofac#get-started

*public PlayerVoiceService(IPlayeVoiceRepository repository)
PlayerVoiceServiceとInMemoryRepositoryの両方を登録しているので、
コンストラクタ引数へInMemoryRepositoryのインスタンスをインジェクトしてくれるよ！
Functionの引数じゃないのでInject属性は不要だよ！


*services.Configure<Microsoft.Extensions.WebEncoders.WebEncoderOptions>(options =>{options.TextEncoderSettings = new System.Text.Encodings.Web.TextEncoderSettings(System.Text.Unicode.UnicodeRanges.All);
UTF8文字コードがHTMLエンティティされる問題を解決するおまじない


*}
(略)

*container.RegisterType<IVehicle, Car>(nameof(Car));
(略)
同じ型に対して、複数の型情報を登録するため名前付きにする

*}
(略)

*}
(略)

*container.RegisterType<IVehicle, Car>(nameof(Car));
同じ型に対して、複数の型情報を登録するため名前付きにする


*public class MessageWindowCtr : MonoBehaviour*{[SerializeField] float messageScaleTime = 0.3f;[SerializeField] float displayTime = 2.5f;[SerializeField] TextMeshProUGUI MessageText;public IEnumerator TimeForDisplay(string message){MessageText.text = message;transform.DOScale(Vector3.one, messageScaleTime);yield return new WaitForSeconds(displayTime);transform.DOScale(Vector3.zero, messageScaleTime);}//アタッチされたScript上で右クリックを押して動作確認できます[ContextMenu("testMessage")]public void testMessage(){StartCoroutine(TimeForDisplay("これはテストです！"));}}
メッセージウィンドウにアタッチして使います

*[ContextMenu("testMessage")]*public void testMessage(){StartCoroutine(TimeForDisplay("これはテストです！"));}
アタッチされたScript上で右クリックを押して動作確認できます


*static List<uint> notificationIds = new List<uint>();
通知リスト

*Console.WriteLine("------------- Add! : " + n.Id + "------------- ");
新しい通知だ！

*notificationIdsNow.Add(n.Id);*}
現在の通知を記録していく

*List<uint> removeIdList = new List<uint>();
存在しなくなった通知を検出する

*Console.WriteLine("------------- Remove! : " + id + "------------- ");
消えた通知だ！


*var img = FindResource("neko") as BitmapImage;
元の画像はとりあえずリソースから取得

*var filePath = System.IO.Path.GetTempPath() + "image.jpg";*using (var fs = new FileStream(filePath, FileMode.Create)) {BitmapEncoder enc = new JpegBitmapEncoder();enc.Frames.Add(BitmapFrame.Create(img));enc.Save(fs);}
テンプラリフォルダに画像ファイル作成

*var dataObject = new DataObject(DataFormats.FileDrop, new[] { filePath });
ドラッグ開始


*proc.StartInfo.FileName = "exeへのフルパス";
exeファイルパス設定

*proc.StartInfo.ArgumentList.Add("引数");
引数設定

*proc.Start();
exe呼出

*proc.WaitForExit();
exeの終了を待つ


*Navigate("https:
qiita.com");


*char c[6];
(6byte)


*//{//  return type.IsPrimitive && (type != typeof(bool)) && (type != //typeof(char));//}
public static bool IsNumeric(this Type type)


*this[index] = new T();
初期値

*public virtual IEnumerable<int> GetAllIndexes() {for (int y = 1; y <= this.YSize; y++) {for (int x = 1; x <= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する

*public virtual IEnumerable<int> EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index) && this[index] != null; index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Horizontal(int x, int y)
(x,y)から右(水平)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Virtical(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantR(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantL(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む

*Replay(moves);
棋譜を再現

*private static void Replay(IEnumerable<Move> moves) {var board = new OthBoard();board.Print();Console.ReadLine();foreach (var move in moves) {Console.SetCursorPosition(0, 0);board.Put(move.Stone, move.Place);board.Print();Console.ReadLine();}}
棋譜を再現

*public IEnumerable<Move> Solve(OthBoard board) {// 最初はどこに打っても同じなので、ひとつに固定。int p = board.ToIndex(3, 4);board.Put(board.Turn, p);var queu = new Queue<OthBoard>();queu.Enqueue(new OthBoard(board));var current = board;while (queu.Count != 0) {//キューの先頭からノード currentNode を取り出すcurrent = queu.Dequeue();if ((current.StoneCount(Stone.Black) == 0) ||(current.StoneCount(Stone.White) == 0)) {// 解がひとつ見つかれば終了。その手順を返す。return current.GetMoves();}foreach (var pos in current.PutablePlaces(current.Turn)) {var next = new OthBoard(current);next.Put(next.Turn, pos);// 試した手の状態はキューに入れるqueu.Enqueue(next);}}// 見つからなかったreturn new Move[0];}
幅優先探索で調べる

*int p = board.ToIndex(3, 4);
最初はどこに打っても同じなので、ひとつに固定。

*current = queu.Dequeue();
キューの先頭からノード currentNode を取り出す

*return current.GetMoves();
解がひとつ見つかれば終了。その手順を返す。

*queu.Enqueue(next);
試した手の状態はキューに入れる

*return new Move[0];
見つからなかった

*namespace CooperatedOthello {public class Stone {public static readonly Stone Black = new Stone { Value = 'X' };public static readonly Stone White = new Stone { Value = 'O' };public static readonly Stone Empty = new Stone { Value = '.' };public char Value { get; set; }}public class Move {public int Place { get; set; }public Stone Stone { get; set; }public Move(Stone stone, int place) {Stone = stone;Place = place;}}public class OthBoard : BoardBase<Stone> {// 現在の手番の事。public Stone Turn { get; set; }// これまでの棋譜private List<Move> Moves = new List<Move>();// コンストラクタpublic OthBoard(): base(8, 8) {Turn = Stone.Black;Initialize();}// コンストラクタ （Cloneと同じ用途)public OthBoard(OthBoard board): base(board) {Turn = board.Turn;Moves = board.Moves.ToList();}// 初期化public void Initialize() {foreach (var p in GetAllIndexes())this[p] = Stone.Empty;this[ToIndex(4, 4)] = Stone.White;this[ToIndex(5, 5)] = Stone.White;this[ToIndex(4, 5)] = Stone.Black;this[ToIndex(5, 4)] = Stone.Black;}// 相手の石public Stone Opponent(Stone stone) {return stone == Stone.White ? Stone.Black : Stone.White;}// 石の数をカウントpublic int StoneCount(Stone stone) {return this.GetAllIndexes().Count(p => this[p] == stone);}// ８つの方向を列挙 （このBoardは、番兵用に一回り大きなサイズとなっている）public IEnumerable<int> Directions() {//return new int[] { -OuterWidth-1, -OuterWidth, -OuterWidth+1, 1, OuterWidth + 1, OuterWidth, OuterWidth-1, -1 };return new int[] {ToDirection(-1, -1),ToDirection( 0, -1),ToDirection(+1, -1),ToDirection(+1,  0),ToDirection(+1, +1),ToDirection( 0, +1),ToDirection(-1, +1),ToDirection(-1,  0),};}// 置ける場所を列挙するpublic IEnumerable<int> PutablePlaces(Stone stone) {return this.GetVacantIndexes().Where(index => CanPut(stone, index));}private IEnumerable<int> GetVacantIndexes() {return this.GetAllIndexes().Where(p => this[p] == Stone.Empty);}// 石を置けるかpublic bool CanPut(Stone stone, int place) {if (this[place] != Stone.Empty)return false;return Directions().Any(d => CanReverse(stone, place, d));}// direction方向の石をひっくり返せるかpublic bool CanReverse(Stone stone, int place, int direction) {Stone opponent = Opponent(stone);int np = place + direction;while (this[np] == opponent)np += direction;return (this[np] == stone && np != place + direction);}// direction方向にstoneと同じ色の石があるかpublic bool FindStone(Stone stone, int place, int direction) {Stone opponent = Opponent(stone);int np = place + direction;while (this[np] == opponent)np += direction;return (this[np] == stone);}// direction方向の石をひっくり返えすpublic void Reverse(Stone stone, int place, int direction) {if (!FindStone(stone, place, direction))return;Stone opponent = Opponent(stone);int np = (int)(place + direction);while (this[np] == opponent) {this[np] = stone;np += direction;}}// stoneをplace位置に置く (必ず置けることを前提としている）public void Put(Stone stone, int place) {this[place] = stone;Stone opponent = Opponent(stone);foreach (int direction in Directions()) {Reverse(stone, place, direction);}Moves.Add(new Move(stone, place));// 通常は相手の番になるが、相手が置ける場所が無い場合は、連続して打てるif (PutablePlaces(Turn).Any())Turn = opponent;elseTurn = stone;}// 現時点での手順を返す。public IEnumerable<Move> GetMoves() {return Moves;}public void Print() {Console.Clear();for (int y = 1; y <= YSize; y++) {for (int x = 1; x <= XSize; x++) {Console.Write("{0} ", this[x, y].Value);}Console.WriteLine("");}Console.WriteLine();}}}
Boardから継承し、特有の機能を追加

*public Stone Turn { get; set; }
現在の手番の事。

*private List<Move> Moves = new List<Move>();
これまでの棋譜

*public OthBoard()*: base(8, 8) {Turn = Stone.Black;Initialize();}
コンストラクタ

*public OthBoard(OthBoard board)*: base(board) {Turn = board.Turn;Moves = board.Moves.ToList();}
コンストラクタ （Cloneと同じ用途)

*public void Initialize() {foreach (var p in GetAllIndexes())this[p] = Stone.Empty;this[ToIndex(4, 4)] = Stone.White;this[ToIndex(5, 5)] = Stone.White;this[ToIndex(4, 5)] = Stone.Black;this[ToIndex(5, 4)] = Stone.Black;}
初期化

*public Stone Opponent(Stone stone) {return stone == Stone.White ? Stone.Black : Stone.White;}
相手の石

*public int StoneCount(Stone stone) {return this.GetAllIndexes().Count(p => this[p] == stone);}
石の数をカウント

*public IEnumerable<int> Directions() {//return new int[] { -OuterWidth-1, -OuterWidth, -OuterWidth+1, 1, OuterWidth + 1, OuterWidth, OuterWidth-1, -1 };return new int[] {ToDirection(-1, -1),ToDirection( 0, -1),ToDirection(+1, -1),ToDirection(+1,  0),ToDirection(+1, +1),ToDirection( 0, +1),ToDirection(-1, +1),ToDirection(-1,  0),};}
８つの方向を列挙 （このBoardは、番兵用に一回り大きなサイズとなっている）

*return new int[] {ToDirection(-1, -1),ToDirection( 0, -1),ToDirection(+1, -1),ToDirection(+1,  0),ToDirection(+1, +1),ToDirection( 0, +1),ToDirection(-1, +1),ToDirection(-1,  0),};
return new int[] { -OuterWidth-1, -OuterWidth, -OuterWidth+1, 1, OuterWidth + 1, OuterWidth, OuterWidth-1, -1 };

*public IEnumerable<int> PutablePlaces(Stone stone) {return this.GetVacantIndexes().Where(index => CanPut(stone, index));}
置ける場所を列挙する

*public bool CanPut(Stone stone, int place) {if (this[place] != Stone.Empty)return false;return Directions().Any(d => CanReverse(stone, place, d));}
石を置けるか

*public bool CanReverse(Stone stone, int place, int direction) {Stone opponent = Opponent(stone);int np = place + direction;while (this[np] == opponent)np += direction;return (this[np] == stone && np != place + direction);}
direction方向の石をひっくり返せるか

*public bool FindStone(Stone stone, int place, int direction) {Stone opponent = Opponent(stone);int np = place + direction;while (this[np] == opponent)np += direction;return (this[np] == stone);}
direction方向にstoneと同じ色の石があるか

*public void Reverse(Stone stone, int place, int direction) {if (!FindStone(stone, place, direction))return;Stone opponent = Opponent(stone);int np = (int)(place + direction);while (this[np] == opponent) {this[np] = stone;np += direction;}}
direction方向の石をひっくり返えす

*public void Put(Stone stone, int place) {this[place] = stone;Stone opponent = Opponent(stone);foreach (int direction in Directions()) {Reverse(stone, place, direction);}Moves.Add(new Move(stone, place));// 通常は相手の番になるが、相手が置ける場所が無い場合は、連続して打てるif (PutablePlaces(Turn).Any())Turn = opponent;elseTurn = stone;}
stoneをplace位置に置く (必ず置けることを前提としている）

*if (PutablePlaces(Turn).Any())*Turn = opponent;
通常は相手の番になるが、相手が置ける場所が無い場合は、連続して打てる

*public IEnumerable<Move> GetMoves() {return Moves;}
現時点での手順を返す。


*void Move()*{if (Input.GetKey (KeyCode.RightArrow))rigid.AddForce (Vector2.right * 3.0f);else if (Input.GetKey (KeyCode.LeftArrow))rigid.AddForce (Vector2.left * 3.0f);elserigid.velocity = new Vector2 (0.0f,rigid.velocity.y);}
テスト用に書いた移動処理なので参考にしないほうが良い

*void Jump()*{//最大の段階のジャンプを超えてたらジャンプしないif (jumpCount >= maxJumpSteps)return;//ジャンプの力を加えるrigid.AddForce (Vector2.up * 5.0f, ForceMode2D.Impulse);//ジャンプの段階を１段階あげるjumpCount++;}
ジャンプ処理

*if (jumpCount >= maxJumpSteps)*return;
最大の段階のジャンプを超えてたらジャンプしない

*rigid.AddForce (Vector2.up * 5.0f, ForceMode2D.Impulse);
ジャンプの力を加える

*jumpCount++;
ジャンプの段階を１段階あげる

*Vector2 dir = contact.point - (Vector2)transform.position;*//接触しているゲームオブジェクトの下向きのベクトル
自分から接触ポイントへのベクトル

*Vector2 contactObjectDown = -contact.collider.gameObject.transform.up;*//接触しているオブジェクトの下向きのベクトルと自身から接触しているポイントへのベクトルの
接触しているゲームオブジェクトの下向きのベクトル

*if (Vector2.Angle (contactObjectDown, dir) < 10.0f)
接触しているオブジェクトの下向きのベクトルと自身から接触しているポイントへのベクトルの
角度が１０度未満であった場合にジャンプの段階数のリセットする

*if (jumpCount >= maxJumpSteps)*return;
最大の段階のジャンプを超えてたらジャンプしない

*rigid.AddForce (Vector2.up * 5.0f, ForceMode2D.Impulse);
ジャンプの力を加える

*jumpCount++;
ジャンプの段階を１段階あげる

*Vector2 dir = contact.point - (Vector2)transform.position;*//接触しているゲームオブジェクトの下向きのベクトル
自分から接触ポイントへのベクトル

*Vector2 contactObjectDown = -contact.collider.gameObject.transform.up;*//接触しているオブジェクトの下向きのベクトルと自身から接触しているポイントへのベクトルの
接触しているゲームオブジェクトの下向きのベクトル

*if (Vector2.Angle (contactObjectDown, dir) < 10.0f)
接触しているオブジェクトの下向きのベクトルと自身から接触しているポイントへのベクトルの
角度が１０度未満であった場合にジャンプの段階数のリセットする


*Environment.SetEnvironmentVariable(
API とサービスの認証情報でサービスアカウントを作成し、
ダウンロードしたアクセスキーファイルのパスを環境変数で指定

*db.Collection("testxml").AddAsync(TestXml).Wait();
ここでfirestoreにデータ追加

*public XElement TestXmlXElement { get; private set; }
XElementはマッピングでエラーになるので登録しない

*[FirestoreProperty("test_xml_string")]
登録したい名前をつけれる
なにもない場合はそのまま

*[FirestoreProperty]*public Child Child => new Child() { XmlChild = TestXmlXElement.Element("Child") };
クラスもできる


*var builder = new SiloHostBuilder().UseLocalhostClustering().Configure<ClusterOptions>(options =>
define the cluster configuration


*abstract class AFoodFactory { }
割愛


*}
サーバーがダウンしていてもここでは例外は発生しません。

*IClientStreamWriter<TRequest> streamWriter = CreateClientStreamWriter(call.RequestStream, context);
ストリームライターをラップ

*Task<TResponse> getResponse = InterceptGetResponse(call.ResponseAsync, context);
Callオブジェクトのメソッドをラップ

*return new AsyncClientStreamingCall<TRequest, TResponse>(streamWriter, getResponse, getHeader, getStatus, getTrailer, call.Dispose);
ラッパーを内包したCallオブジェクトを返す

*}
例外が発生したときの処理

*}
例外が発生したときの処理

*}
例外が発生したときの処理


*continue;
breakだと終了

*class ContinueTest*{static void Main(){for (int i = 1; i <= 10; i++){if (i < 9){continue;}Console.WriteLine(i);}// Keep the console open in debug mode.Console.WriteLine("Press any key to exit.");Console.ReadKey();}}
②i<=10まで続けるがif(i<9)までcontinueなので結果9と10のみ

*}
処理

*int count = 0;
具体例

*{int i = 0;do {i++;MessageBox.Show (i.ToString ());} while (i <= 3);}
while do


*ToolStripMenuItemViewFontSizeMedium.CheckState = CheckState.Indeterminate;
初期設定（チェックマークをつけておきます）
フォームデザイナでプロパティ指定してもよいです。

*var thisItem = clickedItem as System.Windows.Forms.ToolStripMenuItem;
選択されたメニュー項目

*var containerItem = thisItem.GetCurrentParent();
その親項目

*containerItem.Items.OfType<System.Windows.Forms.ToolStripMenuItem>()
(Linqを使った例）
その子項目をToolStripMenuItem型のみ（つまりセパレータなどは除外して）列挙を行い
選択された項目であればIntermediate、それ以外はUncheckedを、CheckStateプロパティに設定します。
2018-10-20 All()使用でリソース消費を抑えています - albireoさんのコメントより

*}
もとはこちら
containerItem.Items.OfType<System.Windows.Forms.ToolStripMenuItem>().ToList()
.ForEach(f => f.CheckState = (f == thisItem) ? CheckState.Indeterminate : CheckState.Unchecked);


*using System.Linq;
Linqを使うから忘れないように.

*var hoge = reading_books.OrderBy((x) => x.Value);
個人名とその人の読書数の辞書があったとする.reading_booksとしておく.
これで値の小さい順のソートができる.xはラムダ式で,適当な変数である.

*var hogehoge = reading_books.OrderByDescending((x) => x.Value);
同様に,大きい順でのソート.


*wRange = string.Format("{0}!A{1}:B{1}", sheetName, rowNumber);
行を追加


*settings.ChannelCredentials = new SslCredentials(File.ReadAllText(@".\Certs\TestCA.crt"));
gRPC で接続するときの接続文字列
var settings = EventStoreClientSettings.Create(@"esdb:127.0.0.1:2113?tls=true");
ルート証明書を明示的に設定する（自己証明書の場合のみ？）
これを設定しない場合、gRPC のエラー "failed to connect to all addresses." が発生した

*return WriteCommandAsync("sampleEvent", "sampleStream", command);
TODO: コマンドの型からイベントタイプとストリーム名を特定できるようにするのが望ましい

*static IEnumerable<EventData> ToEventData(string eventType, IEnumerable<TCommand> commands)*{foreach (var obj in commands){yield return new EventData(Uuid.NewUuid(), eventType, m_Serializer.Serialize(obj));}}
コマンドを格納したイベントデータを列挙するメソッド

*await using EventStoreClient client = CreateEventStoreClient();
頻繁に書き込みを行うアプリケーションの場合、クライアントの生成と破棄を繰り返さないほうがよいと思われる

*return ReadCommandsAsync<TCommand>(streamName, GetNextStreamPosition(streamName));
次の読み込み位置を指定する

*await using var client = CreateEventStoreClient();
頻繁に書き込みを行うアプリケーションの場合、クライアントの生成と破棄を繰り返さないほうがよいと思われる

*LastStreamPosition[streamName] = stream.Current.Event.EventNumber;
最後に読み込んだ位置を格納する

*return ReadAllCommandsAsync(GetLastTransactionPosition());
最後の読み込み位置を指定する

*await using EventStoreClient client = CreateEventStoreClient();
頻繁に書き込みを行うアプリケーションの場合、クライアントの生成と破棄を繰り返さないほうがよいと思われる

*LastTransactionPosition = result.Event.Position;
最後に読み込んだ位置を格納する

*private StreamSubscriptionState m_SubcribeSampleCommandState;
購読の状態を管理するオブジェクト

*Task onReceiveCommandAsync(SampleEventCommand command)*{System.Diagnostics.Debug.WriteLine($"onReceiveCommandAsync: {command}");return Task.CompletedTask;}
コマンドを受け取ったときの処理

*CancellationTokenSource cancellation = new CancellationTokenSource();
購読をキャンセルするためのトークン

*async Task OnEventAsync(StreamSubscription subscription, ResolvedEvent @event, CancellationToken cancellation)*{// イベントからコマンドを取得する// SubscribeToStreamAsync メソッドの引数にはイベントタイプがない// 購読対象でない型のコマンドである可能性があるif (TryGetCommand(@event, out TCommand cmd)){await onReceiveAsync(cmd).ConfigureAwait(false);}}
イベントを受け取ったときの処理

*if (TryGetCommand(@event, out TCommand cmd))
イベントからコマンドを取得する
SubscribeToStreamAsync メソッドの引数にはイベントタイプがない
購読対象でない型のコマンドである可能性がある

*return new StreamSubscriptionState(client, subscription, cancellation);
購読に関連するオブジェクトをまとめた状態オブジェクトを返す

*private StreamSubscriptionState m_SubcribeAllCommandState;
購読の状態を管理するオブジェクト

*Task onReceiveAllCommandAsync(IEventCommand command)*{System.Diagnostics.Debug.WriteLine($"onReceiveAllCommandAsync: {command}");return Task.CompletedTask;}
コマンドを受け取ったときの処理

*CancellationTokenSource cancellation = new CancellationTokenSource();
購読をキャンセルするためのトークン

*async Task OnEventAsync(StreamSubscription subscription, ResolvedEvent @event, CancellationToken cancellation)*{// TODO: 最後に読み込んだときの位置と同じ場合はスキップする。位置が不変であるのか調査が必要。if (lastPosition.CommitPosition >= @event.Event.Position.CommitPosition){return;}// イベントからコマンドを取得するif (TryGetCommand(@event, out IEventCommand cmd)){await onReceiveAsync(cmd).ConfigureAwait(false);}}
イベントを受け取ったときの処理

*return new StreamSubscriptionState(client, subscription, cancellation);
購読に関連するオブジェクトをまとめた状態オブジェクトを返す


*return NullSample.Instance;
何にも該当しない場合もNullを返すとややこしくなるのでNullObjectパターンを作っておくと優しい。


*sw.Start();
foreach:一時変数

*sw.Start();*foreach (var item in list.Select((v, i) => new { v, i }))
foreach

*sw.Start();
foreach:一時変数

*sw.Start();*foreach (var item in list2.Select((value, index) => new { value, index }))
foreach


*[ApplicationRegistry(BuiltInAccessors.CommandlineArguments,BuiltInAccessors.EnvironmenetVariable,BuiltInAccessors.UserRegistry,BuiltInAccessors.MachineRegistry)]
C#


*HttpWebRequest req = PathUtil.getHttpWebRequest(uploadURL, true, new NetworkCredential("ユーザーID", "パスワード"));
HTTPリクエストを作成する


*req.AllowWriteStreamBuffering = false;
デフォルト値はtrueだが、1GB近いサイズのファイルをアップロードした時の処理遅延対策としてfalseに変更する。


*public (string hashedPassword, byte[] salt) HashPassword(string rawPassword) {byte[] salt = GetSalt();string hashed = HashPassword(rawPassword, salt);return (hashed, salt);}
ハッシュ化...平文パスワードを渡すとハッシュ化パスワード、使用されたソルトが返る

*public bool VerifyPassword(string hashedPassword, string rawPassword, byte[] salt) =>*hashedPassword == HashPassword(rawPassword, salt);
認証...ハッシュ化パスワード、平文パスワード・ソルトを渡すと正しいパスワードなら true が返る

*var rawPassword = "nossa1234";
平文パスワード

*var (hashed, salt) = sut.HashPassword(rawPassword);
テスト対象のクラス
var sut = new PasswordService();   sut means System Under Test
パスワードをハッシュ化、使用したソルトを得る

*Assert.True(sut.VerifyPassword(hashed, rawPassword, salt));*}
「ハッシュ」と「パスワード・ソルトから作成したハッシュ」が一致するかテスト

*[HttpPost]*public IActionResult RegisterUser([FromBody]RegisterUserRequest request) {bool success = userService.Register(request.UserName, request.RawPassword);return success ? Ok() : (IActionResult)Conflict();}
UsersController の登録処理の抜粋

*[HttpPost]*public IActionResult Authenticate([FromBody]AuthenticateRequest request) {bool ok = userService.Authenticate(request.UserName, request.RawPassword);return ok ? Ok() : (IActionResult)Unauthorized();}
LoginController の認証の抜粋

*public bool Register(string username, string rawPassword) {bool duplicated = dbContext.Users.Any(u => u.Name == username);if (duplicated) {return false;}(string hashed, byte[] salt) = passwordService.HashPassword(rawPassword);var user = new User {Name = username,HashedPassword = hashed,Salt = salt};dbContext.Users.Add(user);dbContext.SaveChanges();return true;}
ユーザー登録

*public bool Authenticate(string username, string rawPassword) {var user = dbContext.Users.SingleOrDefault(u => u.Name == username);if (user is null) {return false;}return passwordService.VerifyPassword(user.HashedPassword, rawPassword, user.Salt);}
認証


*Assert.AreEqual("FFC0", Extensions.ToHexString(new byte[] { 255, 192 });
大文字の 16 進文字列を返す？

*Assert.AreEqual("ffc0", Extensions.ToHexString(new byte[] { 255, 192 });
小文字の 16 進文字列を返す？

*Assert.AreEqual("FFC0", Extensions.ToHexString(new byte[] { 255, 192 }, toLower: false);
大文字の 16 進文字列を返す

*Assert.AreEqual("ffc0", Extensions.ToHexString(new byte[] { 255, 192 }, toLower: true);
小文字の 16 進文字列を返す

*var source = new byte[] { 255, 192 };
準備

*var actual = Extensions.ToHexString(source, toLower);
実施

*Assert.AreEqual(expected, actual);
検証

*public void バイト配列を大文字の１６進文字列に変換() {
こういうのは読む量が増えるし、似ているコードは何が違うのかに
注意を払いながら読む必要があるのでかなり気を遣う。
（結局同じだったりする）

*var message = $"No.{item.testNumber}";
実施

*(int testNumber, byte[] source, bool toLower, string expected, Type expectedExceptionType)[] TestCases() => new[] {(1, new byte[] { 255, 192 }, false        , "FFC0", (Type)null),(2, new byte[] { 255, 192 }, true         , "ffc0", (Type)null),(3, null                   , default(bool), null  , (Type)typeof(ArgumentNullException)),};
テストケース一覧。


*this.MaximizeBox = false;
デザイナで初期設定してもOK

*base.SetVisibleCore(_initialized && value);
コントロールの表示状態を強制：初回は非表示にする

*this.Visible = false;
フォームを閉じる操作をされた
base.OnClosing(e);

*Application.Exit();
終了ボタン押下

*SetFormLocation();
タスクトレイ（通知領域）のアイコンダブルクリック

*private void SetFormLocation()*{var wa = Screen.PrimaryScreen.WorkingArea;if (0 < wa.Left){//  タスクバーは左this.Location = new System.Drawing.Point(wa.Left, wa.Bottom - this.Height);}else if (0 < wa.Top){//  タスクバーは上this.Location = new System.Drawing.Point(wa.Right - this.Width, wa.Top);}else{//  タスクバーは右か下this.Location = new System.Drawing.Point(wa.Right - this.Width, wa.Bottom - this.Height);}}
ここが今回のキモ！！

*this.Location = new System.Drawing.Point(wa.Left, wa.Bottom - this.Height);
タスクバーは左

*this.Location = new System.Drawing.Point(wa.Right - this.Width, wa.Top);
タスクバーは上

*this.Location = new System.Drawing.Point(wa.Right - this.Width, wa.Bottom - this.Height);
タスクバーは右か下


*var defaultEvent = control.GetType().GetDefaultEvent();
デフォルトイベント発生時に手動でデータソースを更新
(DataSourceUpdateMode.OnPropertyChanged だと、TextBox.TextChanged イベント後にデータソースが更新されるため)


*RaisePropertyChanged(nameof(ReadOnly));
読み取りのみプロパティ通知用

*ReadAndWrite_RP.Value = "Changed from VM";
ReadOnly = "Changed from VM";コンパイルエラー

*}
ReadOnly_RP.Value = "Changed from VM";コンパイルエラー


*string fileCount;
@Zuishinさんに教えていただいた方法


*using (var swTextC = new StreamWriter($@"{documentFolderPath}\c.txt"))
こちらは案1と同じで重ねただけ。


*}
例外処理


*return;
すでに再生中なら変えない


*path = args[0];
コマンドライン引数があるとき

*path = Environment.GetFolderPath(Environment.SpecialFolder.MyMusic);
コマンドライン引数がないとき

*string[] files = Directory.GetFiles(path, "*.mp3", SearchOption.AllDirectories);
*.mp3に一致するファイルの取得


*Console.WriteLine(result);
False

*,,,
<<=第2オペランドの値分左にシフトし、第1オペランドに格納
\>>= 第2オペランドの値分右にシフトし、第1オペランドに格納
int a = 5;         二進数の 0000000000000101 (5)
int b = a << 3;    二進数の 0000000000101000（左に3，十進数の40)
int c = b >> 3;    二進数の 0000000000000101 (右に3，最初の値に戻った)
int b = a << 14;   二進数の 0100000000000000 (左に14，1が捨てられた)


*struct LinearEquation*{public double A { get; set; }public double B { get; set; }public double Solve(double x) => this.A * x + this.B;}
y = Ax + B

*struct ExponentialEquation*{public double A { get; set; }public double B { get; set; }public double Solve(double x) => Math.Exp(this.A * x) * this.B;public static ExponentialEquation Approximate(Coordinate[] data){var pt = data.Select(item => new Coordinate(item.X, Math.Log(item.Y)));var eq = LinearEquation.Approximate(pt.ToArray());return new ExponentialEquation() { A = eq.A, B = Math.Exp(eq.B) };}}
y = B･exp(Ax)


*bool result = signer.VerifySignature(plain, sign[0], sign[1]);
④

*byte[] signature = Sign(clearText, @"..\..\secp256k1.privatekey");*Console.WriteLine(string.Join("", signature.Select(b => $"{b:x02}")));
署名

*AsymmetricCipherKeyPair pair = null;
鍵を読み込む

*var signer = new ECDsaSigner();
署名インスタンスを生成＆署名

*var sign1 = sign[0].ToByteArray().SkipWhile(b => b == 0x00).Reverse();
署名の値をbyte[]にしておく

*AsymmetricCipherKeyPair pair = null;
鍵を読み込む

*var sign1 = signature.Take(32).Reverse().ToArray();*if ((sign1[0] & 0x80) == 0x80) sign1 = new byte[] { 0x00 }.Concat(sign1).ToArray();
署名の値をBigIntegerに変換する

*var signer = new ECDsaSigner();
検証する


*var path = "C:\\VRM\\AliciaSolid.vrm";
VRMファイルのパスを指定します

*var bytes = File.ReadAllBytes(path);
ファイルをByte配列に読み込みます

*var context = new VRMImporterContext();
VRMImporterContextがVRMを読み込む機能を提供します

*context.ParseGlb(bytes);
GLB形式でJSONを取得しParseします

*Debug.LogFormat("meta: title:{0}", meta.Title);
VRMのメタデータを取得
var meta = context.ReadMeta(false); 引数をTrueに変えるとサムネイルも読み込みます
読み込めたかどうかログにモデル名を出力してみる

*context.Load();
同期処理で読み込みます

*var root = context.Root;
読込が完了するとcontext.RootにモデルのGameObjectが入っています

*root.transform.SetParent(transform, false);*//メッシュを表示します
モデルをワールド上に配置します

*context.ShowMeshes();
メッシュを表示します

*var path = "C:\\VRM\\AliciaSolid.vrm";
VRMファイルのパスを指定します

*var bytes = File.ReadAllBytes(path);
ファイルをByte配列に読み込みます

*var context = new VRMImporterContext();
VRMImporterContextがVRMを読み込む機能を提供します

*context.ParseGlb(bytes);
GLB形式でJSONを取得しParseします

*Debug.LogFormat("meta: title:{0}", meta.Title);
VRMのメタデータを取得
var meta = context.ReadMeta(false); 引数をTrueに変えるとサムネイルも読み込みます
読み込めたかどうかログにモデル名を出力してみる

*context.LoadAsync(_ => OnLoaded(context));
非同期処理で読み込みます

*var root = context.Root;
読込が完了するとcontext.RootにモデルのGameObjectが入っています

*root.transform.SetParent(transform, false);*//メッシュを表示します
モデルをワールド上に配置します

*context.ShowMeshes();
メッシュを表示します

*var path = "C:\\VRM\\AliciaSolid.vrm";
VRMファイルのパスを指定します

*var bytes = File.ReadAllBytes(path);
ファイルをByte配列に読み込みます

*var context = new VRMImporterContext();
VRMImporterContextがVRMを読み込む機能を提供します

*context.ParseGlb(bytes);
GLB形式でJSONを取得しParseします

*Debug.LogFormat("meta: title:{0}", meta.Title);
VRMのメタデータを取得
var meta = context.ReadMeta(false); 引数をTrueに変えるとサムネイルも読み込みます
読み込めたかどうかログにモデル名を出力してみる

*await context.LoadAsyncTask();
非同期処理(Task)で読み込みます

*var root = context.Root;
読込が完了するとcontext.RootにモデルのGameObjectが入っています

*root.transform.SetParent(transform, false);*//メッシュを表示します
モデルをワールド上に配置します

*context.ShowMeshes();
メッシュを表示します

*private async static Task<Byte[]> ReadAllBytesAsync(string path)*{byte[] result;using (FileStream SourceStream = File.Open(path, FileMode.Open)){result = new byte[SourceStream.Length];await SourceStream.ReadAsync(result, 0, (int)SourceStream.Length);}return result;}
Byte列を得る

*Debug.LogFormat("meta: title:{0}", meta.Title);
VRMのメタデータを取得
var meta = context.ReadMeta(false); 引数をTrueに変えるとサムネイルも読み込みます
読み込めたかどうかログにモデル名を出力してみる

*root.transform.SetParent(transform, false);*//メッシュを表示します
モデルをワールド上に配置します

*context.ShowMeshes();
メッシュを表示します


*enum Number*{One,Two,Three,Four,Five,Six,Seven,Eight,Nine,Ten}
Switch

*private readonly Dictionary<Number, int> _numberTable = new Dictionary<Number, int>*{{ Number.One,    1 },{ Number.Two,    2 },{ Number.Three,  3 },{ Number.Four,   4 },{ Number.Five,   5 },{ Number.Six,    6 },{ Number.Seven,  7 },{ Number.Eight,  8 },{ Number.Nine,   9 },{ Number.Ten,   10 }};
Dictionary

*private class NumberComparer : IEqualityComparer<Number>*{public bool Equals(Number x, Number y){return x == y;}public int GetHashCode(Number obj){return (int)obj;}}
Dictionary with EqualityComparer


*yield return new Syntax(@"
\*[\s\S]*?\*|.*", this.CommentColor);

*var textChanged = true;
テキスト変更フラグ (テキスト変更時に ON、ハイライト後に OFF)

*var start = this.richTextBox.SelectionStart;
キャレット位置を保持

*using (var highlighter = new SqlHighlighter())using (var font = new Font("Consolas", 11)){richTextBox1.Rtf = highlighter.GetRtf(richTextBox1.Text, font);
ハイライト

*this.richTextBox.Select(start, length);
キャレット位置を復元


*return ope.GetString();
Operatorをstringに変換する拡張メソッド（詳細は省略）

*public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)*{//（略）}
文字列から演算子への変換

*}
（略）


*public void Delete(int id, Program p, TodoEditMode edit)*{p.TodoList.RemoveAt(id - 1);if (p.Conform() == true){Console.WriteLine("Please Write id to delete");int i = int.Parse(Console.ReadLine());this.Delete(id, p, this);}else{p.ModeSelect(0, p, this);}}
モードセレクトのクラスを作るしかない。それで、最後に確認をやって確認がTrueなら

*System.IO.StreamReader sr = new System.IO.StreamReader(@"AccessToken.txt",System.Text.Encoding.GetEncoding("utf-8"));
"C:\test\1.txt"をShift-JISコードとして開く

*var AccessToken = sr.ReadLine();
内容を一行ずつ読み込む

*sr.Close();
閉じる

*System.IO.StreamWriter sw = new System.IO.StreamWriter(@"AccessToken.txt",false,System.Text.Encoding.GetEncoding("utf-8"));
ファイルを上書きし、utf-8で書き込む

*sw.WriteLine(tokens.AccessToken);
txtの内容を1行ずつ書き込む

*sw.Close();
閉じる

*cancellationToken.Cancel();
キャンセル要求出す

*task.Wait();
タスクがキャンセルされるまで待機

*Console.WriteLine("Task is cancelled.");
タスクがキャンセルされるとここが実行される

*System.IO.StreamWriter sw = new System.IO.StreamWriter(@"TodoList.txt",false,System.Text.Encoding.GetEncoding("utf-8"));
ファイルを上書きし、Shift JISで書き込む

*sw.Close();
閉じる

*System.IO.StreamReader sr = new System.IO.StreamReader(@"TodoList.txt",System.Text.Encoding.GetEncoding("utf-8"));
"C:\test\1.txt"をShift-JISコードとして開く

*sr.Close();
閉じる

*System.IO.StreamReader sr = new System.IO.StreamReader(@"AccessToken.txt",System.Text.Encoding.GetEncoding("utf-8"));
"C:\test\1.txt"をShift-JISコードとして開く

*var AccessToken = sr.ReadLine();
内容を一行ずつ読み込む

*sr.Close();
閉じる

*System.IO.StreamWriter sw = new System.IO.StreamWriter(@"AccessToken.txt",false,System.Text.Encoding.GetEncoding("utf-8"));
ファイルを上書きし、Shift JISで書き込む

*sw.WriteLine(tokens.AccessToken);
TextBox1.Textの内容を1行ずつ書き込む

*sw.Close();
閉じる

*cancellationToken.Cancel();
キャンセル要求出す

*task.Wait();
タスクがキャンセルされるまで待機

*Console.WriteLine("Task is cancelled.");
タスクがキャンセルされるとここが実行される

*cancellationToken.Cancel();
キャンセル要求出す

*task.Wait();
タスクがキャンセルされるまで待機

*Console.WriteLine("Task is cancelled.");
タスクがキャンセルされるとここが実行される


*}
Exception にはエラーになった行を特定する情報は含まれていない。

*var errorRow = copy.GetLastDataRow();
エラーになった行の DataRow とインデックスを取得する。


*}
処理

*}
処理

*}
処理

*}
処理

*}
処理

*}
処理

*Namespace = "ネームスペース",User = "ユーザー名",Password = "パスワード",};
Port = 1972,

*}
処理


*private void ShowWindow()*{// SampleWindow : WPF のViewType winType = typeof(SampleWindow);// Windowのインスタンスを取得Window win = GetWindowInstance(winType);// Windowを表示させますwin.Show();win.Title = "サンプル";win.Activate();win.WindowState = WindowState.Normal;}
ボタンをクリックで呼び出すコード

*Type winType = typeof(SampleWindow);
SampleWindow : WPF のView

*Window win = GetWindowInstance(winType);
Windowのインスタンスを取得

*win.Show();
Windowを表示させます

*private Window GetWindowInstance(Type winType)*{// Windowsを取得Window win;win =System.Windows.Application.Current.Windows.OfType<Window>().SingleOrDefault(w => w.GetType() == winType);// まだ表示されていない場合はインスタンスを生成するif (win == null){win = (Window)Activator.CreateInstance(winType, _regionManager);}return win;}
Windowのインスタンス取得処理

*Window win;
Windowsを取得


*kernelInitialize = computeShader.FindKernel("Initialize");
カーネルIdの取得

*waveTexture = new RenderTexture(256, 256, 0, RenderTextureFormat.RG32);
波の高さを格納するテクスチャの作成

*drawTexture = new RenderTexture(256, 256, 0, RenderTextureFormat.ARGB32);
レンダリング用のテクスチャの作成

*uint threadSizeX, threadSizeY, threadSizeZ;
スレッド数の取得

*computeShader.SetTexture(kernelInitialize, "waveTexture", waveTexture);
波の高さの初期化

*this.computeShader.SetFloat("time", Time.time);
波の追加

*this.computeShader.SetFloat("deltaSize", deltaSize);
波の高さの更新

*this.computeShader.SetTexture(kernelDraw, "waveTexture", waveTexture);
波の高さをもとにレンダリング用のテクスチャを作成


*Transform RightThumbProximal = chara.GetBoneTransform(HumanBodyBones.RightThumbProximal);*RightThumbProximal.localRotation = Quaternion.Euler(ThumbR/2, 0, 0);
右手親指------------------------------------------------------------------------------------

*Transform RightIndexProximal = chara.GetBoneTransform(HumanBodyBones.RightIndexProximal);*RightIndexProximal.localRotation = Quaternion.Euler(0,0,IndexR/2);
人差し指------------------------------------------------------------------------------------

*}
以降は人差し指と同じ要領で小指まで

*Transform RightThumbProximal = chara.GetBoneTransform(HumanBodyBones.RightThumbProximal);
右手
親指------------------------------------------------------------------------------------

*Transform RightIndexProximal = chara.GetBoneTransform(HumanBodyBones.RightIndexProximal);*RightIndexProximal.localRotation = Quaternion.Euler(IndexR / 800, -IndexR / 800, IndexR/2);
人差し指------------------------------------------------------------------------------------

*Transform RightMiddleProximal = chara.GetBoneTransform(HumanBodyBones.RightMiddleProximal);*RightMiddleProximal.localRotation = Quaternion.Euler(0, 0, MiddleR / 2);
中指------------------------------------------------------------------------------------

*Transform RightRingProximal = chara.GetBoneTransform(HumanBodyBones.RightRingProximal);*RightRingProximal.localRotation = Quaternion.Euler(-RingR / 800, RingR / 800, RingR / 2);
薬指------------------------------------------------------------------------------------

*Transform RightLittleProximal = chara.GetBoneTransform(HumanBodyBones.RightLittleProximal);*RightLittleProximal.localRotation = Quaternion.Euler(-LittleR / 400, LittleR / 400, LittleR / 2);
小指------------------------------------------------------------------------------------


*}
何かしらの DB処理

*}
省略


*currencyManager1 = (CurrencyManager)this.BindingContext[_food.fruits];
List<Fruits> fruitsの現在行を管理

*textBoxName1.DataBindings.Add("Text", binds[0], "Name");
dataSourceObjectにSystem.Windows.Forms.BindingSource（binds[]）を指定

*textBoxName2.DataBindings.Add("Text", _food.fruits[1], "Name");
dataSourceObjectにList（food.fruits[]）を指定

*textBoxName3.DataBindings.Add("Text", _food[2], "Name");
dataSourceObjectにインデクサ（food[]）を指定


*myAdminGetUserDetailByIds.HostName = "cybz.com";
インストールしたサーバーのホスト名

*AdminGetUserDetailByIdsRequestType adminGetUserDetailByIdsRequest = new AdminGetUserDetailByIdsRequestType();
リクエストデータの生成

*myAdminGetUserDetailByIds.AdminGetUserDetailByIdsRequest = adminGetUserDetailByIdsRequest;
自作AdminAPIクラスにリクエストデータを設定

*myAdminGetUserDetailByIds.soapSendReceive();
AdminAPIの実行

*List<UserDetail> userDetailList = myAdminGetUserDetailByIds.AdminGetUserDetailByIdsResponse.userDetail.ToList();
レスポンスデータの取得


*RuleFor(x => x.Surname).NotNull().DependentRules(() => {RuleFor(x => x.Forename).NotNull();});
姓が入力されている場合に、名が入力されているか検証する。


*public OutArgument<String> result { get; set; }
戻り値はstring


*result.Set(context, text + " Hello world.");
追記


*Task task = MainAsync();
コンソールアプリケーションからAsyncを呼び出す大元はTaskを使用する

*task.Wait();
終了を待つ

*static async Task MainAsync()*{await xxxxxxxxAsync();}
AsyncなMain。ここでは非同期処理をawaitを使って同期的処理のように扱うことができる

*return MainAsync().Result;
コンソールアプリケーションからAsyncを呼び出す大本はTaskを使用する;

*private static async Task<int> MainAsync()*{await xxxxxxxxAsync();return 0;}
AsyncなMain


*dict[args.BluetoothAddress] = args.Advertisement.LocalName;
こうでないと重複例外が出る


*public static string ToErrorMessage<TErrorCode>(this Response<TErrorCode> response) {
← this が追加されました

*}else{
特別処理


*Console.WriteLine($"Osako = {y}");
Osako = 4


*new CardImage("http:
adaptivecards.iocontentcats2.png"),


*var meta = new File(){Name = System.IO.Path.GetFileName(filePath),};
アップロード済みのファイルを更新するにはAPIを切り替える必要がある

*var request = service.Files.Update(meta, file.Id, stream, GetMimeType(filePath));
更新

*meta.MimeType = GetMimeType(filePath);*meta.Parents = new List<string> { _Configuration.DriveDirectoryId };
新規追加


*var user = Service.FindUserByName(name);
DBからUSERを取得したとする

*var viewModel = new UserViewModel(){UserId = user.USER_ID;
USER -> UserViewModel

*var user = Service.FindUserByName(name);
DBからUSERを取得したとする

*var viewModel = new UserViewModel(){UserId = user.USER_ID;
USER -> UserViewModel

*var users = Service.FindUsers();
DBからUSER一覧を取得したとする

*var viewModel = new UserViewModel(){UserId = user.USER_ID;
USER -> UserViewModel

*var user = Service.FindUserByName(name);
DBからUSERを取得したとする

*var viewModel = new UserViewModel(){UserId = user.USER_ID;
USER -> UserViewModel

*Fax = user.FAX;
追加

*var users = Service.FindUsers();
DBからUSER一覧を取得したとする

*var viewModel = new UserViewModel(){UserId = user.USER_ID;
USER -> UserViewModel

*Fax = user.FAX;
追加

*var user = Service.FindUserByName(name);
DBからUSERを取得したとする

*var users = Service.FindUsers();
DBからUSER一覧を取得したとする


*[UnityTest]*public IEnumerator NewEditModeTestWithEnumeratorPasses() {// Use the Assert class to test conditions.// yield to skip a frameyield return null;}
and allows you to yield null to skip a frame in EditMode


*string [] files = GetStreamingAssetFiles("sample", "*.png");
ファイルリストの取得


*private string convertBackString;
入力文字列

*public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)*{try{if (!(value is double)) return null;string format = (parameter as string) ?? string.Empty;if (!string.IsNullOrEmpty(convertBackString)){//フォーマットを「整数部」と「小数部」に分けるvar formatParts = format.Split('.');if (formatParts.Length >= 2){//入力文字列が小数点で終わっていたら、「整数部」＋「小数点そのもの」をフォーマットにするif (convertBackString.EndsWith(culture.NumberFormat.NumberDecimalSeparator)){format = formatParts[0] + @"\" + culture.NumberFormat.NumberDecimalSeparator;}else{var pos = convertBackString.IndexOf(culture.NumberFormat.NumberDecimalSeparator);if (pos >= 0){//入力文字列に小数部があれば、「整数部」＋「ピリオド」＋「入力文字列の小数の桁数分の０」をフォーマットにするvar digitLength = convertBackString.Length - pos - 1;format = formatParts[0] + @"."+ new string('0', digitLength)+ formatParts[1].Substring(Math.Min(digitLength, formatParts[1].Length));}}}}return ((double)value).ToString(format);}finally{convertBackString = null;}}
doubleから文字列への変換（表示時に使われる）

*var formatParts = format.Split('.');*if (formatParts.Length >= 2)
フォーマットを「整数部」と「小数部」に分ける

*var digitLength = convertBackString.Length - pos - 1;
入力文字列に小数部があれば、「整数部」＋「ピリオド」＋「入力文字列の小数の桁数分の０」をフォーマットにする

*public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)*{//入力文字列を保存するconvertBackString = value as string;if (!string.IsNullOrEmpty(convertBackString)&& double.TryParse(convertBackString, out double newValue)){//入力文字列をパーズして戻すreturn newValue;}else{return null;}}
文字列からdoubleへの変換（入力時に使われる）

*convertBackString = value as string;
入力文字列を保存する

*return newValue;
入力文字列をパーズして戻す


*Max
MAX に相当

*public int Number { get; }
カードに書かれた数字

*public _Card(int number) { }
number: カードに書かれた数字

*internal class _Deck*{// プレイヤーがドローするカード列public IEnumerable<_Card> DeckCards { get; }// ソート済みの全カードpublic IEnumerable<_Card> SortedCards { get; }// allNumber  : 全カードの数字列// deckNumbers: プレイヤーがドローするカードの数字列public _Deck(IEnumerable<int> allNumbers, IEnumerable<int> deckNumbers) { }}
カードのデッキ

*public IEnumerable<_Card> DeckCards { get; }
プレイヤーがドローするカード列

*public IEnumerable<_Card> SortedCards { get; }
ソート済みの全カード

*// deckNumbers: プレイヤーがドローするカードの数字列*public _Deck(IEnumerable<int> allNumbers, IEnumerable<int> deckNumbers) { }
allNumber  : 全カードの数字列

*public _Deck(IEnumerable<int> allNumbers, IEnumerable<int> deckNumbers) { }
deckNumbers: プレイヤーがドローするカードの数字列

*public string Name { get; }
プレイヤーの名前

*private _Inference _Inference { get; }
推論に関する情報

*public _Player(string name, IEnumerable<_VisibleCard> visibleCards, IEnumerable<_Card> allCards, _PlayerOrder order) { }
name: プレイヤーの名前
visibleCards: 他プレイヤーのカード
allCards    : 全カード
order       : 手番の順序

*// orderIndex: _PlayerOrder上における現在の順番*public PlayerAnswer SayAnswer(int orderIndex) { }
答えを宣言する

*public PlayerAnswer SayAnswer(int orderIndex) { }
orderIndex: _PlayerOrder上における現在の順番

*internal struct _VisibleCard*{// カードを所持するプレイヤーの名前public string PlayerName { get; }// 見えているカードpublic _Card Card { get; }// playerName: カードを所持するプレイヤーの名前// card: 見えているカードpublic _VisibleCard(string playerName, _Card card) { }}
見えているカード

*public string PlayerName { get; }
カードを所持するプレイヤーの名前

*public _Card Card { get; }
見えているカード

*// card: 見えているカード*public _VisibleCard(string playerName, _Card card) { }
playerName: カードを所持するプレイヤーの名前

*public _VisibleCard(string playerName, _Card card) { }
card: 見えているカード

*internal class _Inference*{// 推論対象のプレイヤーの名前private string _PlayerName { get; }// プレイヤーに見えているカード列private IEnumerable<_VisibleCard> _VisibleCards { get; }// 全カード列private IEnumerable<_Card> _AllCards { get; }// 手番の順序private _PlayerOrder _Order { get; }// _Inferメソッドのメモprivate Dictionary<_MemoKey, PlayerAnswer> _Memo { get; }// playerName  : 推論対象のプレイヤーの名前// visibleCards: プレイヤーに見えているカード列// allCards    : 全カード列// order       : 手番の順序public _Inference(string playerName, IEnumerable<_VisibleCard> visibleCards, IEnumerable<_Card> allCards, _PlayerOrder order) { }// 現在の順番に基づき、答えを導出する// orderIndex: _PlayerOrder上における現在の順番// return    : 答えpublic PlayerAnswer Infer(int orderIndex) { }}
推論に関する情報

*private string _PlayerName { get; }
推論対象のプレイヤーの名前

*private IEnumerable<_VisibleCard> _VisibleCards { get; }
プレイヤーに見えているカード列

*private IEnumerable<_Card> _AllCards { get; }
全カード列

*private _PlayerOrder _Order { get; }
手番の順序

*private Dictionary<_MemoKey, PlayerAnswer> _Memo { get; }
_Inferメソッドのメモ

*public _Inference(string playerName, IEnumerable<_VisibleCard> visibleCards, IEnumerable<_Card> allCards, _PlayerOrder order) { }
playerName  : 推論対象のプレイヤーの名前
visibleCards: プレイヤーに見えているカード列
allCards    : 全カード列
order       : 手番の順序

*public PlayerAnswer Infer(int orderIndex) { }
現在の順番に基づき、答えを導出する
orderIndex: _PlayerOrder上における現在の順番
return    : 答え

*internal class _PlayerOrder*{// 全プレイヤーの名前列private IEnumerable<string> _PlayerNames { get; }// playerNames: 全プレイヤーの名前列public _PlayerOrder(IEnumerable<string> playerNames) { }// 手番の順序を生成する// return: 順序付けられたプレイヤーの名前列public IEnumerable<string> GetPlayerNames() { }}
手番の順序

*private IEnumerable<string> _PlayerNames { get; }
全プレイヤーの名前列

*public _PlayerOrder(IEnumerable<string> playerNames) { }
playerNames: 全プレイヤーの名前列

*// return: 順序付けられたプレイヤーの名前列*public IEnumerable<string> GetPlayerNames() { }
手番の順序を生成する

*public IEnumerable<string> GetPlayerNames() { }
return: 順序付けられたプレイヤーの名前列

*public PlayerAnswer Infer(int orderIndex)
現在の順番に基づき、答えを導出する
orderIndex: _PlayerOrder上における現在の順番
return    : 答え

*public PlayerAnswer _Infer(string targetPlayerName, IEnumerable<_VisibleCard> visibleCards, int limit)
答えを導出する
targetPlayerName: 推論対象のプレイヤーの名前
visibleCards    : プレイヤーに見えているカード列
orderIndex      : _PlayerOrder上における現在の順番
return          : 答え

*var possibleCardList = _AllCards.Except(visibleCards.Select(x => x.Card))
自分のカードである可能性のあるカード列（あとで削除するためリストにする）

*var candidates = visibleCards.Concat(new[] { new _VisibleCard(targetPlayerName, p) }).Where(x => x.PlayerName != prevPlayerName)
前の手番を仮定する

*var inferred = _Infer(prevPlayerName, candidates, prevIndex);
仮定を元に答えを導出する


*public float[] VRMLipValue = new float[15];
VRMLipSync用フィールド変数


*xmlns:x="http:
schemas.microsoft.comwinfx2006xaml"


*instance.Method();
ここはcreateInstanceで生成するインスタンスによって処理が変わる。

*interface IDerived*{void Func();}
本当は名前が不適切なことはわかっているが、継承と比較するためにこうした


*public class MainActivity : global::Xamarin.Forms.Platform.Android.FormsAppCompatActivity
global::~が


*var hoge1 = new hoge();
事前処理でQueueには何か入ってる

*hoge[] array = hogehoge();
まとめて突っ込みたいコレクションが出来てしまった。

*queue = new Queue<hoge>(queue.ToArray().Concat(array));
forでなくQueueに1行で突っ込む
重複を除きたいならUnion 今回のケースでは冗長だった・・・。
queue = new Queue<hoge>(queue.ToArray().Union(array));
重複を許容するならConcat↓


*private GameObject Object;
カメラの設定

*public float maxCamSize = 9.0f;
カメラ範囲の設定

*private float lastDist = 0.0f;
直前の指同士の距離

*private Vector2 centerPos;
指同士の中心座標

*private Vector2 lastTouchWorld;
一本指タッチしたワールド座標

*private int lastCount = 0;
直前の触れている指の数

*public float zoomSpeed = 1.0f;
スピード調整

*float sizeDiff;*//カメラが画面外を映さないように処理
カメラサイズの差分

*void CameraSlide()*{if (cam.transform.position.x > maxCamX - cam.orthographicSize * 9 / 16){cam.transform.position = new Vector3(maxCamX - cam.orthographicSize * 9 / 16, cam.transform.position.y, cam.transform.position.z);}if (cam.transform.position.x < minCamX + cam.orthographicSize * 9 / 16){cam.transform.position = new Vector3(minCamX + cam.orthographicSize * 9 / 16, cam.transform.position.y, cam.transform.position.z);}if (cam.transform.position.y > maxCamY - cam.orthographicSize){cam.transform.position = new Vector3(cam.transform.position.x, maxCamY - cam.orthographicSize, cam.transform.position.z);}if (cam.transform.position.y < minCamY + cam.orthographicSize){cam.transform.position = new Vector3(cam.transform.position.x, minCamY + cam.orthographicSize, cam.transform.position.z);}}
カメラが画面外を映さないように処理

*Object = GameObject.Find("Main Camera");
カメラを設定

*Touch touch3 = Input.GetTouch(0);
タッチ位置取得

*nowTouchWorld = lastTouchWorld;
前回の座標を保存

*t = touch3.position;
今の座標を保存

*cam.transform.position = new Vector3(cam.transform.position.x + (lastTouchWorld.x - nowTouchWorld.x) * moveSpeed, cam.transform.position.y + (lastTouchWorld.y - nowTouchWorld.y) * moveSpeed, cam.transform.position.z);*CameraSlide();
カメラを移動

*Touch touch1 = Input.GetTouch(0);
タッチ位置取得

*lastDist = Vector2.Distance(touch1.position, touch2.position);
指同士の距離と中心座標を取得

*float newDist = Vector2.Distance(touch1.position, touch2.position);
指同士の距離を計算

*sizeDiff = cam.orthographicSize * cam.orthographicSize * (newDist - lastDist) / 10000.0f * zoomSpeed;*cam.orthographicSize -= sizeDiff;
ズーム処理

*else*{cam.transform.position = new Vector3(centerPos.x + cam.orthographicSize / (cam.orthographicSize + sizeDiff) * (cam.transform.position.x - centerPos.x), centerPos.y + cam.orthographicSize / (cam.orthographicSize + sizeDiff) * (cam.transform.position.y - centerPos.y), cam.transform.position.z);}
指同士の中心位置がピンチ操作の中心となるようにカメラを平行移動


*string Version = typeof(Application).Assembly.GetName().Version.ToString();
これはダメらしくnullになる
string Version = typeof(Application).Assembly.GetCustomAttribute<AssemblyVersionAttribute>()?.Version;
こうする


*public static float score = 0;
スコア

*Debug.Log("Score: "+ Game.getScore());
ログ出力


*response = await client.PostAsync("https:
api.cmtelecom.comv1.0otpverify", content);


*[SerializeField] private Text _title;
ダイアログのタイトル

*[SerializeField] private Text _description;
ダイアログの説明文

*[SerializeField] public Button _okButton;
OKボタン

*[SerializeField] public Button _ngButton;
NGボタン

*public UnityAction onDestroyed;
ダイアログ終了時イベント

*[SerializeField] private Image _background;
ダイアログのまわりの灰色の背景.触られたときにダイアログを消す

*private static readonly string PREFAB_NAME = "DialogCanvasPrefab";
ダイアログのprefab名

*private static GameObject prefab;
一応prefabをキャッシュしておく.

*public static DialogHandler ShowDialog(
title:ダイアログのタイトル
description:ダイアログの説明文
ok:OKボタンの文言
ng:NGボタンの文言
デフォルト引数により,OKボタンとNGボタンの文言を入力しなければ両ボタンは表示されない.入力すれば表示される

*prefab = Resources.Load(PREFAB_NAME) as GameObject;
static変数に置くべきか,毎回読み込むべきか.
ベストプラクティスがよくわからない.

*var instance = Instantiate(prefab);
prefabをInstantiateして,そのインスタンスからこのDialogHandlerを取得する.

*handler._title.text = title;
タイトルと説明文を設定.

*Destroy(handler._okButton.gameObject);
okの文言がなかったらOKボタンを消す.
しっかり参照も消す.

*handler._okButton.GetComponentInChildren<Text>().text = ok;
okの文言があったらボタンにセット.
クリックされたらダイアログを消す.

*var eventTrigger = _background.gameObject.AddComponent<EventTrigger>();
imageをクリックされたときにアクションを行う.
スクリプトで付与.
この場合はダイアログ以外の場所を押されたらダイアログを消す.

*onDestroyed?.Invoke();
ダイアログ終了イベント.


*if (time >= 1)
currentTime >= lifeTimes[i].Value + deathTime


*static readonly AbstractSkill[] skills = {new LightningSkill(),new HealSkill()};
スキル一覧

*public AbstractSkill Create(SkillKind skillKind)*{return skills.SingleOrDefault(skill => skill.SkillKind == skillKind);}
SkillKindを引数に、それに応じたスキルを返す

*public abstract SkillFactory.SkillKind SkillKind { get; }
スキル種別の抽象プロパティ

*public abstract void Play();
スキル実行の抽象メソッド

*public override SkillFactory.SkillKind SkillKind*{get {return SkillFactory.SkillKind.Lightning;}}
スキル種別

*public override void Play() {Debug.Log("Lightning!");}
スキル「ライトニング」の実行

*public override SkillFactory.SkillKind SkillKind*{get {return SkillFactory.SkillKind.Heal;}}
スキル種別

*private SkillFactory.SkillKind selectedSkillKind;
選択中のスキル


*while (step > 1) {
stepが1になるまで繰り返す。

*[Conditional("DEBUG")]*public void DebugPrint() {for (int x = 0; x < _xSize; x++) {for (int y = 0; y < _ySize; y++) {string s = (_map[x, y] <= -2)? "***": (_map[x, y] == -1)? "   ": string.Format("{0,2} ", _map[x, y]);Console.Write(s);}Console.WriteLine();}Console.WriteLine();}
迷路をConsoleに表示する [Debug用]


*using NCMB;
追記

*[SerializeField]GameManager _GameManager;
GameManagerのサンプル（https:qiita.com/azumagoro/items/d2b1a4e59ae8f48996c3）
Save,Loadメソッドを呼ぶのに必要

*[SerializeField]GameObject ButtonDownStopper;
最前面で画面全体を覆う RaycastBlock = true なImageコンポーネントを持つGameObject

*string path;
パスとファイル名

*private static DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, 0);
Timestamp用, 別途TimeUtilクラスを設けてそっちに書いても可

*public static long GetUnixTime(DateTime dateTime)*{return (long)(dateTime - UnixEpoch).TotalSeconds;}
DateTimeからUnixTimeへ変換

*path = Application.persistentDataPath + "/";
SaveDataクラス（http:magnaga.com/unity/2016/04/25/unity-save2/）で書き込むpathと同じにする

*public void UploadSaveData()*{Debug.Log("UploadSaveData");//ログインチェック,ログインの処理は別途用意しておく//参考)オートログイン:https://qiita.com/azumagoro/items/2a82b55422354ac7cee8if (NCMBUser.CurrentUser == null){Debug.Log("ログインしてません");return;}//UI操作の制御ButtonDownStopper.SetActive(true);//JSONファイルを読んでstring,byteへstring str = "";if (File.Exists(path + fileName)){using (StreamReader sr= new StreamReader(path + fileName, Encoding.GetEncoding("utf-8"))){str = sr.ReadToEnd();}}byte[] data = System.Text.Encoding.UTF8.GetBytes(str);//ファイル名重複を避けるためユーザーID+Timestampでファイル名を固有にするstring NCMBFileName= "SaveData-"+ SaveData.GetString("NCMB_UserName")+ "-" + GetUnixTime(DateTime.Now);//セーブ用NCMBFileを作成NCMBFile file = new NCMBFile(NCMBFileName, data);//ファイルストアにセーブfile.SaveAsync((NCMBException error) =>{if (error != null){Debug.Log("ファイルのアップロードに失敗しました");//UI操作制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("ファイルのアップロードに成功しました");//セーブ用クラスにレコードを追加AddRecord(NCMBFileName);}});}
セーブデータファイルをサーバーにアップロード

*if (NCMBUser.CurrentUser == null)
ログインチェック,ログインの処理は別途用意しておく
参考)オートログイン:https:qiita.com/azumagoro/items/2a82b55422354ac7cee8

*ButtonDownStopper.SetActive(true);
UI操作の制御

*string str = "";
JSONファイルを読んでstring,byteへ

*string NCMBFileName
ファイル名重複を避けるためユーザーID+Timestampでファイル名を固有にする

*NCMBFile file = new NCMBFile(NCMBFileName, data);
セーブ用NCMBFileを作成

*file.SaveAsync((NCMBException error) =>*{if (error != null){Debug.Log("ファイルのアップロードに失敗しました");//UI操作制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("ファイルのアップロードに成功しました");//セーブ用クラスにレコードを追加AddRecord(NCMBFileName);}});
ファイルストアにセーブ

*ButtonDownStopper.SetActive(false);
UI操作制御を解除

*AddRecord(NCMBFileName);
セーブ用クラスにレコードを追加

*void AddRecord(string filename)*{NCMBObject obj = new NCMBObject("BackupSaveData");//フィールドに値を設定,NCMB_UserNameは会員登録時に予め設定して、セーブ済みobj.Add("userName", SaveData.GetString("NCMB_UserName"));obj.Add("fileName", filename);obj.Save((NCMBException e) =>{if (e != null){Debug.Log("セーブ用クラスのレコード追加に失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("セーブ用クラスのレコード追加に成功しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}});}
userID-fileName の紐づけ情報を管理するNCMBクラスにレコードを追加する処理

*obj.Add("userName", SaveData.GetString("NCMB_UserName"));
フィールドに値を設定,NCMB_UserNameは会員登録時に予め設定して、セーブ済み

*ButtonDownStopper.SetActive(false);
UI操作の制御を解除

*ButtonDownStopper.SetActive(false);
UI操作の制御を解除

*public void LoadSaveData()*{Debug.Log("LoadSaveData");//ログインチェック,ログインの処理は別途用意しておくif (NCMBUser.CurrentUser == null){Debug.Log("ログインしてません");return;}//UI操作の制御ButtonDownStopper.SetActive(true);//Queryを作成NCMBQuery<NCMBObject> query = new NCMBQuery<NCMBObject>("BackupSaveData");//設定追加：ユーザー名で抽出query.WhereEqualTo("userName", SaveData.GetString("NCMB_UserName", ""));//設定追加：作成日時・降順でソートquery.OrderByDescending("createDate");//検索結果を取得,検索結果はobjListに格納されるquery.FindAsync((List<NCMBObject> objList, NCMBException e) =>{if (e != null){//検索失敗時の処理Debug.Log("データのダウンロードに失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("データのダウンロードに成功しました");//最新のファイルを読み込むLoadSaveFile(objList[0]["fileName"].ToString());//レコード数が2以下になるまで古いデータから順に削除for (int i = objList.Count - 1; i > 1; i--){NCMBObject objDelete = new NCMBObject("BackupSaveData");//ObjectIdを指定して削除してるけど、objList[i].DeleteAsyncでOKかもobjDelete.ObjectId = objList[i].ObjectId;objDelete.DeleteAsync((NCMBException error) =>{if (e != null){Debug.Log("古いレコードの削除に失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("古いレコードの削除に成功しました");}});}//ファイル数が2以下になるまで古いデータから順に削除for (int i = objList.Count - 1; i > 1; i--){NCMBFile file = new NCMBFile(objList[i]["fileName"].ToString());file.DeleteAsync((NCMBException error) =>{if (error != null){Debug.Log("古いファイルの削除に失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("古いファイルの削除に成功しました");}});}}});}
ファイル名を取得, ファイルを取得, 読み込む

*ButtonDownStopper.SetActive(true);
UI操作の制御

*NCMBQuery<NCMBObject> query = new NCMBQuery<NCMBObject>("BackupSaveData");
Queryを作成

*query.WhereEqualTo("userName", SaveData.GetString("NCMB_UserName", ""));
設定追加：ユーザー名で抽出

*query.OrderByDescending("createDate");
設定追加：作成日時・降順でソート

*query.FindAsync((List<NCMBObject> objList, NCMBException e) =>*{if (e != null){//検索失敗時の処理Debug.Log("データのダウンロードに失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("データのダウンロードに成功しました");//最新のファイルを読み込むLoadSaveFile(objList[0]["fileName"].ToString());//レコード数が2以下になるまで古いデータから順に削除for (int i = objList.Count - 1; i > 1; i--){NCMBObject objDelete = new NCMBObject("BackupSaveData");//ObjectIdを指定して削除してるけど、objList[i].DeleteAsyncでOKかもobjDelete.ObjectId = objList[i].ObjectId;objDelete.DeleteAsync((NCMBException error) =>{if (e != null){Debug.Log("古いレコードの削除に失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("古いレコードの削除に成功しました");}});}//ファイル数が2以下になるまで古いデータから順に削除for (int i = objList.Count - 1; i > 1; i--){NCMBFile file = new NCMBFile(objList[i]["fileName"].ToString());file.DeleteAsync((NCMBException error) =>{if (error != null){Debug.Log("古いファイルの削除に失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("古いファイルの削除に成功しました");}});}}});
検索結果を取得,検索結果はobjListに格納される

*Debug.Log("データのダウンロードに失敗しました");
検索失敗時の処理

*ButtonDownStopper.SetActive(false);
UI操作の制御を解除

*LoadSaveFile(objList[0]["fileName"].ToString());
最新のファイルを読み込む

*objDelete.ObjectId = objList[i].ObjectId;
ObjectIdを指定して削除してるけど、objList[i].DeleteAsyncでOKかも

*ButtonDownStopper.SetActive(false);
UI操作の制御を解除

*ButtonDownStopper.SetActive(false);
UI操作の制御を解除

*void LoadSaveFile(string Name)*{NCMBFile file = new NCMBFile(Name);file.FetchAsync((byte[] fileData, NCMBException error) =>{if (error != null){Debug.Log("ファイルの取得に失敗しました");//UI操作の制御を解除ButtonDownStopper.SetActive(false);}else{Debug.Log("ファイルの取得に成功しました");SaveBytesTo(fileData);//ロードと初期化LoadAndInit();//UI操作の制御を解除ButtonDownStopper.SetActive(false);//UIに成功メッセージを表示する}});}
SaveDataファイルを取得

*ButtonDownStopper.SetActive(false);
UI操作の制御を解除

*LoadAndInit();
ロードと初期化

*ButtonDownStopper.SetActive(false);
UI操作の制御を解除

*}
UIに成功メッセージを表示する

*void SaveBytesTo(byte[] b)*{Debug.Log("SaveBytesTo");//UTF8 エンコードでbyteからstringへstring text = System.Text.Encoding.UTF8.GetString(b);Debug.Log("SaveBytesTo:" + text);//上書きStreamWriter writer = new StreamWriter(path + fileName, false, Encoding.GetEncoding("utf-8"));writer.WriteLine(text);writer.Close();}
Byteデータをsavedata.jsonに書き込む

*string text = System.Text.Encoding.UTF8.GetString(b);
UTF8 エンコードでbyteからstringへ

*StreamWriter writer = new StreamWriter(path + fileName, false, Encoding.GetEncoding("utf-8"));
上書き

*void LoadAndInit()*{Debug.Log("LoadAndInit");//ファイルの読み込みSaveData.UpdateSaveData();//ゲームデータのLoadgameManager.Load();//復元ペナルティがあればここに書いてSave()する}
ファイルからデータを読み込む

*SaveData.UpdateSaveData();
ファイルの読み込み

*gameManager.Load();
ゲームデータのLoad

*}
復元ペナルティがあればここに書いてSave()する


*var response = client.PostAsync("https:
gw.cmtelecom.comv1.0message", content).GetAwaiter().GetResult();


*====================,,,********************$end$********************,,,/*** @param $end$*/,,,☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★$end$☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★,,,ﾟ+｡*ﾟ+｡｡+ﾟ*｡+ﾟ ﾟ+｡*ﾟ+｡｡+ﾟ*｡+ﾟ ﾟ+｡*$end$ﾟ+｡*ﾟ+｡｡+ﾟ*｡+ﾟ ﾟ+｡*ﾟ+｡｡+ﾟ*｡+ﾟ ﾟ+｡*,,,
*public Player player = new Player();
プレイヤーの情報

*public List<Character> ownCharacters = new List<Character>();
手持ちキャラクターの情報

*public Battle battle = new Battle();
バトルの情報

*public GameFlags gameFlags = new GameFlags();
フラグ情報

*[SerializeField] private MasterData _MasterData;
マスタデータ

*public static GameManager instance;*void Awake(){//GameManager.instanceでの取得用の初期化instance = this;//SceneをまたいでもGameObjectを残すためDontDestroyOnLoad(gameObject);//開発用にEditorでは毎回初期化する,念を入れてDebug.isDebugBuildもif条件に。#if UNITY_EDITORif (Debug.isDebugBuild){SaveData.Clear();}#endif//ロード処理Load();}
こうしておくとGameManager.instanceでGetComponentせずに取得できる

*instance = this;
GameManager.instanceでの取得用の初期化

*DontDestroyOnLoad(gameObject);
SceneをまたいでもGameObjectを残すため

*#if UNITY_EDITOR*if (Debug.isDebugBuild)
開発用にEditorでは毎回初期化する,念を入れてDebug.isDebugBuildもif条件に。

*Load();
ロード処理

*SaveData.SetClass("player", player);
セーブデータの設定

*SaveData.Save();
セーブ

*player = SaveData.GetClass("player", new Player());
ロード

*var ch = ownCharacters[i];
キャラクターデータ

*ch.skills.Clear();
覚えているスキル

*public CharacterData data;
キャラクター固有の情報 CharacterDataはScriptableObjectを継承

*public List<SkillBase> skills = new List<SkillBase>();
覚えているスキル SkillBaseはScriptableObjectを継承


*string category = "C#";
=> 検索条件として渡されたと仮定


*private double? prevValue;
前回表示した値

*public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)*{try{if (!(value is double)) return null;double newValue = (double)value;try{if (!string.IsNullOrEmpty(convertBackString)&& prevValue.HasValue && (prevValue == newValue)){//入力文字列があり、前回表示した値と同じ値を表示するなら、入力文字列をそのまま戻すreturn convertBackString;}else{//そうでなければ、値をdouble型で戻す//→StringFormatを使ってフォーマットされるreturn newValue;}}finally{prevValue = newValue;}}finally{convertBackString = null;}}
doubleから文字列への変換（表示時に使われる）

*return convertBackString;
入力文字列があり、前回表示した値と同じ値を表示するなら、入力文字列をそのまま戻す

*return newValue;
そうでなければ、値をdouble型で戻す
→StringFormatを使ってフォーマットされる

*public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)*{//入力文字列を保存するconvertBackString = value as string;if (!string.IsNullOrEmpty(convertBackString)&& double.TryParse(convertBackString, out double newValue)){//入力文字列をパーズして戻すreturn newValue;}else{return null;}}
文字列からdoubleへの変換（入力時に使われる）

*convertBackString = value as string;
入力文字列を保存する

*return newValue;
入力文字列をパーズして戻す


*else {
次の回答者がいなかったらおしまい。

*static string ToAlphabet(int number) {string alphabet = "";do {alphabet = Convert.ToChar(number % 26 + 0x41) + alphabet;} while((number=number/26-1) != -1);return alphabet;}
数字をアルファベットに変換！

*}*class Player {private Card _card;public Card card {get { return this._card; }}private string _name;public string name {get { return this._name; }}public Player(string name) {this._name = name;}//カードを一枚引いて額にかざすpublic void Draw(List<Card> cards) {Random random = new Random(Environment.TickCount);int index = random.Next(cards.Count);this._card = cards[index];cards.RemoveAt(index);}//MAX, MID, MIN, ?public string Answer(List<Player> players) {//ここがこの問題の肝となるアルゴリズムです！//是非チャレンジしてみてくださいね！return "?";}}
現実世界のカードは自分から動かないのでメソッドを持たない！

*public void Draw(List<Card> cards) {Random random = new Random(Environment.TickCount);int index = random.Next(cards.Count);this._card = cards[index];cards.RemoveAt(index);}
カードを一枚引いて額にかざす

*public string Answer(List<Player> players) {//ここがこの問題の肝となるアルゴリズムです！//是非チャレンジしてみてくださいね！return "?";}
MAX, MID, MIN, ?

*return "?";
ここがこの問題の肝となるアルゴリズムです！
是非チャレンジしてみてくださいね！


*_animator.SetBool("Idle", false);
<- 追加


*private void BindEventHandler(object sender, PropertyChangedEventArgs e)*{if (_dict.ContainsKey((sender.GetType(), e.PropertyName)))foreach (BindInfo b in _dict[(sender.GetType(), e.PropertyName)])b.SetValue();}
トリガープロパティに値がセットされたとき動作するハンドラー

*public void AddBindMember<T>(object control, string memberName, Expression<Func<T>> expression)*{Delegate deleg = expression.Compile();BindInfo bindInfo = new BindInfo(control, memberName, deleg);//コントロールのプロパティに初期値がセットされるbindInfo.SetValue();//PropertyInfoを収集するvar visitor = new ExVisitor();visitor.Visit(expression);//プロパティ変更イベント発生時参照するディクショナリを作るforeach (PropertyInfo info in visitor.Properties.Distinct())_dict.GetWithNew((info.DeclaringType, info.Name)).Add(bindInfo);}
バインド定義を処理

*bindInfo.SetValue();
コントロールのプロパティに初期値がセットされる

*var visitor = new ExVisitor();
PropertyInfoを収集する

*foreach (PropertyInfo info in visitor.Properties.Distinct())*_dict.GetWithNew((info.DeclaringType, info.Name)).Add(bindInfo);
プロパティ変更イベント発生時参照するディクショナリを作る

*public class BindInfo*{private object _target;private string _memberName;private Delegate _deleg;public BindInfo(object control, string memberName, Delegate deleg){_target = control;_memberName = memberName;_deleg = deleg;}public void SetValue(){PropertyInfo p = _target.GetType().GetProperty(_memberName);p.SetValue(_target, _deleg.DynamicInvoke());}}
バインド情報を持つクラス

*,,,
Input=Hoge  とコンソール出力される。

*_bm = new BindManager();
バインド定義

*public void SetProperty<T>(object sender,ref T target, T value, [CallerMemberName] string caller = "")*{target = value;if (PropertyChanged == null)return;PropertyChangedEventArgs arg = new PropertyChangedEventArgs(caller);PropertyChanged.Invoke(sender, arg);}
プロパティ変更通知


*Console.WriteLine("true!");
以下else if..

*Console.WriteLine($"int:{int.MinValue}~{int.MaxValue}");
GetType(型調べる)
Console.WriteLine(100.GetType());int
Console.WriteLine(5.1.GetType());double
Console.WriteLine(1.7.GetType());double
Console.WriteLine(3.4.GetType());double
MaxValue(範囲調べる)


*private bool disposedValue = false;
重複する呼び出しを検出するには

*disposedValue = true;
ここでマネージリソースを解放


*void Start () {camera = Camera.main;}
Use this for initialization

*void Update () {if (Input.GetMouseButtonDown(0)) {RayCheck();}if (beRay) {MovePoisition();}if (Input.GetMouseButtonUp(0)) {beRay = false;}}
Update is called once per frame


*public static readonly string[] Messages ={Message1,Message2,Message3};
列挙用配列。しかし、この配列の公開はNG

*NGSample.Messages = new [] { "Compile Error!" };
コンパイルエラーになる

*NGSample.Messages[1] = "This message is spoiled.";
実際に値が入れかえられる

*static readonly string[] _Messages ={Message1,Message2,Message3};
列挙用配列

*public static IEnumerable<string> Messages*{get{foreach (var e in _Messages)yield return e;}}
これは外部から変更不可能

*public static IEnumerable<string> Messages*{get{return _Messages.AsEnumerable();}}
注意！外部から変更可能！

*OKSample.Messages[1] = "Compile Error!",,,NotSupportedExceptionをスローする(OKSample.Messages as IList<string>)[1] = "Throw an exception";
コンパイルエラーになる

*(OKSample.Messages as IList<string>)[1] = "Throw an exception";
NotSupportedExceptionをスローする

*,,,
実行結果は以下の通り。Clear()したのに！
1
2

*public static IReadOnlyList<string> Messages { get; }
問題なし。IReadOnlyCollection<string>型として公開するのはおすすめしない

*public static string[] MessagesProperty { get; } =
問題のある値の公開。外部から値を変更できてしまう！

*public static string[] MessagesProperty*{get{return _Messages.ToArray();}}
バイナリ互換性を保ったまま、値を変更できないように修正。


*Choices awake = new Choices(AwakeWord);
呼び出し

*Choices actions = new Choices();
指示

*engine.SpeechRecognized += recogEngine_SpeechRecognized;
音声認識が認識処理を終えたときのイベントハンドラを設定する。

*engine.SpeechHypothesized += recogEngine_SpeechHypothesized;
音声認識が推定処理を終えたときのイベントハンドラを設定する。

*engine.LoadGrammar(new Grammar(gb));
SystemSpeech を利用したディクテーションを行う場合には、

*engine.SetInputToDefaultAudioDevice();
実行環境の標準の入力を音声認識エンジンの入力とする。

*engine.RecognizeAsync(RecognizeMode.Multiple);
非同期の認識を継続して実行するようにして音声認識を開始する。

*bool isSilent = SilentWords.Any(x => e.Result.Text.Contains(x));
処理を分ける


*lArea.Reverse();
出現箇所を後ろから処理


*a = null;
値を設定しないとエラーなる。

*}
a = null;    nullは「非Null許容型であるため、NullをStrictSに変換できません」となる。


*proc.Verb = "RunAs";
管理者として実行する為のおまじない


*long span = 1000 * 10;
= 1ms


*public class SearchEx*{private string _text = string.Empty;private int[] _suffixArray;//コンストラクタpublic SearchEx(string text){if (string.IsNullOrEmpty(text)) throw new ArgumentNullException(nameof(text));this._text = text;this.CreateSuffixArray();}//(中略)//接尾辞配列作成メソッドprivate void CreateSuffixArray(){//連番配列を作成var suffixArray = Enumerable.Range(0, this._text.Length).ToList();//ソート部分suffixArray.Sort((x, y) =>{return string.Compare(this._text, x, this._text y, this._text.Length);});this._suffixArray = suffixArray.ToArray();}}
文字列探索クラス

*public SearchEx(string text)*{if (string.IsNullOrEmpty(text)) throw new ArgumentNullException(nameof(text));this._text = text;this.CreateSuffixArray();}
コンストラクタ

*private void CreateSuffixArray()
(中略)
接尾辞配列作成メソッド

*var suffixArray = Enumerable.Range(0, this._text.Length).ToList();
連番配列を作成

*suffixArray.Sort((x, y) =>
ソート部分

*private void CreateSuffixArray()*{//実体化にかなり時間がかかる//var suffixArray = Enumerable.Range(0, this._text.Length.ToList();//配列を作成後、数値を代入するvar suffixArray = new int[text.Length];for (var index = 0; index < text.Length; index++){suffixArray[index] = index;}(中略)}
接尾語配列生成メソッド

*var suffixArray = new int[text.Length];
実体化にかなり時間がかかる
var suffixArray = Enumerable.Range(0, this._text.Length.ToList();
配列を作成後、数値を代入する

*Array.Sort(this._suffixArray,(x, y) => InternalCompare(x, y, textSize));
Array.Sortに変更。

*private int InternalCompare(int indexA, int indexB, int maxLength)*{return CultureInfo.CurrentCulture.CompareInfo.Compare(this._text,indexA,(maxLength - indexA),this._text,indexB,(maxLength - indexB),CompareOptions.None);}
文字列比較用メソッド


*date = SystemDate.GetSystemDate()
DateTime.Now()を返すだけのメソッド


*}
本当にやりたかった処理


*// is needed for a given request.*options.CheckConsentNeeded = context => true;
This lambda determines whether user consent for non-essential cookies


*private void button1_Click(object sender, RibbonControlEventArgs e)*{var dialogResult = MessageBox.Show(@"Hello", @"Title", MessageBoxButtons.OKCancel);if(dialogResult == DialogResult.OK){System.Diagnostics.Trace.WriteLine("Ok");}}
using System.Windows.Forms;


*#endregion
) ===== BUNDLE_SIZE_API =====


*CallInvoker callInvoker = new Channel("localhost:50000", ChannelCredentials.Insecure).Intercept(new IntercepterC()).Intercept(new IntercepterB()).Intercept(new IntercepterA());
Channel.Intercept 拡張メソッドは内部で DefaultCallInvoker を生成して返しています。

*public virtual AsyncClientStreamingCall<TRequest, TResponse> AsyncClientStreamingCall<TRequest, TResponse>(ClientInterceptorContext<TRequest, TResponse> context, AsyncClientStreamingCallContinuation<TRequest, TResponse> continuation){
ClientStreaming クライアントサイド用

*public virtual Task<TResponse> ClientStreamingServerHandler<TRequest, TResponse>(IAsyncStreamReader<TRequest> requestStream, ServerCallContext context, ClientStreamingServerMethod<TRequest, TResponse> continuation){
ClientStreaming サーバーサイド用


*psInfo = new ProcessStartInfo(){FileName = "schtasks",Arguments = "/create /tn AutoTask /tr \"" + Assembly.GetExecutingAssembly().Location+ "\" /sc onevent /ec Microsoft-Windows-NetworkProfile/Operational /mo "+ "\"*[System[Provider[@Name=\'Microsoft-Windows-NetworkProfile\'] and EventID=10000]]\" /F",CreateNoWindow = true,UseShellExecute = false};
登録されていない場合は登録する


*var splitedStr = new string[COL_NUM];
結果を格納するための配列を生成する

*var count = 0;
区切り文字を見つけた件数

*var posi = new int[COUNT_OF_DELIMITER];
区切り文字の位置を格納する配列

*for (var i = 0; i < str.Length; i = i + 1)
文字列をchar配列でループして、一文字ずつ区切り文字であるか判定
区切り文字であるなら、区切り文字の位置を保存

*splitedStr[0] = str.Substring(0, posi[0]);
Substringで文字列をスプリットしていく
1つ目の引数は、開始位置(0始まり)
2つ目の引数は、文字数
-----------------------------------------------------
※区切り文字を「カンマ」として説明を記載
・1列目のデータは、以下で抽出
開始位置：0
文字数：最初のカンマの位置（最初のカンマの位置＝最初の文字数になる）

*splitedStr[1] = str.Substring(posi[0] + 1, posi[1] - posi[0] - 1);
・2列目のデータは、以下で抽出（3列目以降も同じ感じ）
開始位置：最初のカンマの位置 + 1
文字数：次のカンマの位置 - 最初のカンマの位置 - 1

*splitedStr[4] = str.Substring(posi[3] + 1);
・最後のデータは、以下で抽出
開始位置：最後のカンマの位置
文字数：指定なし（最後まで）

*var splitedStr = new string[COL_NUM];
結果を格納するための配列を生成する

*var count = 0;
区切り文字を見つけた件数

*var start = 0;
切り出し開始位置

*for (var i = 0; i < str.Length; i++)
文字列をchar配列でループして、一文字ずつ区切り文字であるか判定
区切り文字であるなら、区切り文字の位置を保存

*splitedStr[count] = str.Substring(start, i - start);
Substringで文字列をスプリットしていく

*splitedStr[count + 1] = str.Substring(i + 1);
最後のデータは、以下で抽出

*var splitTargets = new string[]{"12345,D,555555,115151,EEEEEE"};
スプリットの対象文字

*Console.WriteLine("---------------------------Check---------------------------");
正しくスプリットできているかチェックする

*Console.WriteLine("---------------------------Start---------------------------");*Console.WriteLine("Loop Count:{0}", LOOP_COUNT);
スプリットの速度計測

*private static void Check(string name, Func<string, string[]> splitFunc, string[] splitTargets)*{foreach(var text in splitTargets){var splitedValues = splitFunc(text);foreach(var val in splitedValues){Console.WriteLine("{0}:{1}", name, val);}}}
スプリットの検証用メソッド

*private const int LOOP_COUNT = 200000;
速度図るためのカウント

*private static void Sokutei(string name, Func<string, string[]> splitFunc, string[] splitTargets)*{var sw = new System.Diagnostics.Stopwatch();sw.Start();for (int i = 0; i < LOOP_COUNT; i++){foreach(var text in splitTargets){splitFunc(text);}}sw.Stop();Console.WriteLine("{0}:{1}", name, sw.Elapsed.ToString());}
スプリットの速度計測用メソッド

*private const char DELIMITER = ',';
区切り文字

*private const int COL_NUM = 5;
何個に区切るか

*private const int COUNT_OF_DELIMITER = COL_NUM - 1;
区切り文字の数

*private static string[] nomalSplit(string str)*{return str.Split(DELIMITER);}
通常のスプリット

*private static string[] fastSplit(string str)*{//結果を格納するための配列を生成するvar splitedStr = new string[COL_NUM];//区切り文字を見つけた件数var count = 0;//区切り文字の位置を格納する配列var posi = new int[COUNT_OF_DELIMITER];//文字列をchar配列でループして、一文字ずつ区切り文字であるか判定//区切り文字であるなら、区切り文字の位置を保存for (var i = 0; i < str.Length; i = i + 1){if (str[i] == DELIMITER){posi[count] = i;if (count == COUNT_OF_DELIMITER - 1)break;count = count + 1;}}//-----------------------------------------------------//Substringで文字列をスプリットしていく//1つ目の引数は、開始位置(0始まり)//2つ目の引数は、文字数//-----------------------------------------------------//※区切り文字を「カンマ」として説明を記載//・1列目のデータは、以下で抽出//　開始位置：0//    文字数：最初のカンマの位置（最初のカンマの位置＝最初の文字数になる）splitedStr[0] = str.Substring(0, posi[0]);//・2列目のデータは、以下で抽出（3列目以降も同じ感じ）//　開始位置：最初のカンマの位置 + 1//    文字数：次のカンマの位置 - 最初のカンマの位置 - 1splitedStr[1] = str.Substring(posi[0] + 1, posi[1] - posi[0] - 1);splitedStr[2] = str.Substring(posi[1] + 1, posi[2] - posi[1] - 1);splitedStr[3] = str.Substring(posi[2] + 1, posi[3] - posi[2] - 1);//・最後のデータは、以下で抽出//　開始位置：最後のカンマの位置//    文字数：指定なし（最後まで）splitedStr[4] = str.Substring(posi[3] + 1);return splitedStr;}
お手製スプリット

*var splitedStr = new string[COL_NUM];
結果を格納するための配列を生成する

*var count = 0;
区切り文字を見つけた件数

*var posi = new int[COUNT_OF_DELIMITER];
区切り文字の位置を格納する配列

*for (var i = 0; i < str.Length; i = i + 1)
文字列をchar配列でループして、一文字ずつ区切り文字であるか判定
区切り文字であるなら、区切り文字の位置を保存

*splitedStr[0] = str.Substring(0, posi[0]);
Substringで文字列をスプリットしていく
1つ目の引数は、開始位置(0始まり)
2つ目の引数は、文字数
-----------------------------------------------------
※区切り文字を「カンマ」として説明を記載
・1列目のデータは、以下で抽出
開始位置：0
文字数：最初のカンマの位置（最初のカンマの位置＝最初の文字数になる）

*splitedStr[1] = str.Substring(posi[0] + 1, posi[1] - posi[0] - 1);
・2列目のデータは、以下で抽出（3列目以降も同じ感じ）
開始位置：最初のカンマの位置 + 1
文字数：次のカンマの位置 - 最初のカンマの位置 - 1

*splitedStr[4] = str.Substring(posi[3] + 1);
・最後のデータは、以下で抽出
開始位置：最後のカンマの位置
文字数：指定なし（最後まで）

*var splitedStr = new string[COL_NUM];
結果を格納するための配列を生成する

*var count = 0;
区切り文字を見つけた件数

*var start = 0;
切り出し開始位置

*for (var i = 0; i < str.Length; i++)
文字列をchar配列でループして、一文字ずつ区切り文字であるか判定
区切り文字であるなら、区切り文字の位置を保存

*splitedStr[count] = str.Substring(start, i - start);
Substringで文字列をスプリットしていく

*splitedStr[count + 1] = str.Substring(i + 1);
最後のデータは、以下で抽出

*var splitTargets = new string[] { "12345,D,555555,115151,EEEEEE" };
スプリットの対象文字

*Console.WriteLine("Version: {0}", Environment.Version.ToString());
環境

*Console.WriteLine("---------------------------Check---------------------------");
正しくスプリットできているかチェックする

*Console.WriteLine("---------------------------WarmUp--------------------------");
温める

*ResultDic = new Dictionary<string, List<TimeSpan>>();
合計のリセット

*Console.WriteLine("---------------------------Start---------------------------");*Console.WriteLine("Loop Count:{0}", LOOP_COUNT);
スプリットの速度計測

*private static void Check(string name, Func<string, string[]> splitFunc, string[] splitTargets)*{foreach (var text in splitTargets){var splitedValues = splitFunc(text);foreach (var val in splitedValues){Console.WriteLine("{0}:{1}", name, val);}}}
スプリットの検証用メソッド

*private const int LOOP_COUNT = 2000000;
速度図るためのカウント

*private static void Sokutei(string name, Func<string, string[]> splitFunc, string[] splitTargets)*{System.Threading.Thread.Sleep(10);var sw = new System.Diagnostics.Stopwatch();sw.Start();for (int i = 0; i < LOOP_COUNT; i++){foreach (var text in splitTargets){splitFunc(text);}}sw.Stop();var elapsed = sw.Elapsed;//結果表示Console.WriteLine("{0}:{1}", name, elapsed.ToString());//結果の保存List<TimeSpan> results;if (ResultDic.TryGetValue(name, out results) == false){results = new List<TimeSpan>();ResultDic.Add(name, results);}results.Add(elapsed);}
スプリットの速度計測用メソッド

*Console.WriteLine("{0}:{1}", name, elapsed.ToString());
結果表示

*List<TimeSpan> results;
結果の保存

*private const char DELIMITER = ',';
区切り文字

*private const int COL_NUM = 5;
何個に区切るか

*private const int COUNT_OF_DELIMITER = COL_NUM - 1;
区切り文字の数

*private static string[] nomalSplit(string str)*{return str.Split(DELIMITER);}
通常のスプリット

*private static string[] fastSplit(string str)*{//結果を格納するための配列を生成するvar splitedStr = new string[COL_NUM];//区切り文字を見つけた件数var count = 0;//区切り文字の位置を格納する配列var posi = new int[COUNT_OF_DELIMITER];//文字列をchar配列でループして、一文字ずつ区切り文字であるか判定//区切り文字であるなら、区切り文字の位置を保存for (var i = 0; i < str.Length; i = i + 1){if (str[i] == DELIMITER){posi[count] = i;if (count == COUNT_OF_DELIMITER - 1)break;count = count + 1;}}//-----------------------------------------------------//Substringで文字列をスプリットしていく//1つ目の引数は、開始位置(0始まり)//2つ目の引数は、文字数//-----------------------------------------------------//※区切り文字を「カンマ」として説明を記載//・1列目のデータは、以下で抽出//　開始位置：0//    文字数：最初のカンマの位置（最初のカンマの位置＝最初の文字数になる）splitedStr[0] = str.Substring(0, posi[0]);//・2列目のデータは、以下で抽出（3列目以降も同じ感じ）//　開始位置：最初のカンマの位置 + 1//    文字数：次のカンマの位置 - 最初のカンマの位置 - 1splitedStr[1] = str.Substring(posi[0] + 1, posi[1] - posi[0] - 1);splitedStr[2] = str.Substring(posi[1] + 1, posi[2] - posi[1] - 1);splitedStr[3] = str.Substring(posi[2] + 1, posi[3] - posi[2] - 1);//・最後のデータは、以下で抽出//　開始位置：最後のカンマの位置//    文字数：指定なし（最後まで）splitedStr[4] = str.Substring(posi[3] + 1);return splitedStr;}
お手製スプリット

*var splitedStr = new string[COL_NUM];
結果を格納するための配列を生成する

*var count = 0;
区切り文字を見つけた件数

*var posi = new int[COUNT_OF_DELIMITER];
区切り文字の位置を格納する配列

*for (var i = 0; i < str.Length; i = i + 1)
文字列をchar配列でループして、一文字ずつ区切り文字であるか判定
区切り文字であるなら、区切り文字の位置を保存

*splitedStr[0] = str.Substring(0, posi[0]);
Substringで文字列をスプリットしていく
1つ目の引数は、開始位置(0始まり)
2つ目の引数は、文字数
-----------------------------------------------------
※区切り文字を「カンマ」として説明を記載
・1列目のデータは、以下で抽出
開始位置：0
文字数：最初のカンマの位置（最初のカンマの位置＝最初の文字数になる）

*splitedStr[1] = str.Substring(posi[0] + 1, posi[1] - posi[0] - 1);
・2列目のデータは、以下で抽出（3列目以降も同じ感じ）
開始位置：最初のカンマの位置 + 1
文字数：次のカンマの位置 - 最初のカンマの位置 - 1

*splitedStr[4] = str.Substring(posi[3] + 1);
・最後のデータは、以下で抽出
開始位置：最後のカンマの位置
文字数：指定なし（最後まで）

*var splitedStr = new string[COL_NUM];
結果を格納するための配列を生成する

*var count = 0;
区切り文字を見つけた件数

*var start = 0;
切り出し開始位置

*for (var i = 0; i < str.Length; i++)
文字列をchar配列でループして、一文字ずつ区切り文字であるか判定
区切り文字であるなら、区切り文字の位置を保存

*splitedStr[count] = str.Substring(start, i - start);
Substringで文字列をスプリットしていく

*splitedStr[count + 1] = str.Substring(i + 1);
最後のデータは、以下で抽出


*throw new ArgumentOutOfRangeException("retryFrequency");
最大リトライ回数

*throw new ArgumentOutOfRangeException("retryInterval");
リトライ間隔

*throw new ArgumentNullException("action");
処理

*return action();
メソッド

*if (retryCount++ < retryFrequency)
リトライが必要な処理で例外が発生した場合
指定回数リトライ

*System.Threading.Thread.Sleep(retryInterval);
最大リトライ回数に達していない場合

*throw e;
最大リトライ回数に達した場合

*throw new ArgumentOutOfRangeException("retryFrequency");
最大リトライ回数

*throw new ArgumentOutOfRangeException("retryInterval");
リトライ間隔

*throw new ArgumentNullException("action");
処理

*if (retryCount++ < retryFrequency)
リトライが必要な処理で例外が発生した場合
指定回数リトライ

*System.Threading.Thread.Sleep(retryInterval);
最大リトライ回数に達していない場合

*throw e;
最大リトライ回数に達した場合

*RetryExecutorNameSpace.RetryExecutor.Execute(4,1000, () => { System.Console.WriteLine("Hello World!"); });
System.Console.WriteLine("Hello World!")をリトライ対象のメソッドに置き換えて、ご使用ください。


*var engine = Python.CreateEngine();
IronPython ボイラープレート

*var variables = scope.GetVariable<dynamic>("path");
戻り値 k の println


*}
クリックのアクション

*}
ダブルクリックのアクション


*void Update()*{UpdateSight();}
Update is called once per frame


*list = list.OrderByDescending(n => n).ToList();
16 13 10 4 3 2 1


*gameObject.name = "Test";
UnityException


*// 例えばswitchによって分けるなど*}
処理

*}
例えばswitchによって分けるなど

*public enum Weather_State*{cloudy,sunny,rainy}
天気の列挙

*public static class Weather_Class
晴れ→曇り→雨→晴れの順にループすることにする
クラスの宣言

*// 天気状態型のweather_caseを宣言し、それによってswitchでわける*public static Weather_State Weather_Loop(this Weather_State weather_case)
メソッドの宣言

*public static Weather_State Weather_Loop(this Weather_State weather_case)*{switch (weather_case){case Weather_State.sunny: return Weather_State.cloudy;case Weather_State.cloudy: return Weather_State.rainy;case Weather_State.rainy: return Weather_State.sunny;default: throw new NotImplementedException();}}
天気状態型のweather_caseを宣言し、それによってswitchでわける


*if (x <= 0 || y <= 0) return 0;
最大公約数を求めるのに0やマイナスを渡すことはないだろうけど、念のため


*public class Maze {private char[,] _map;public int XSize { get; private set; }public int YSize { get; private set; }private Position _start;// コンストラクタpublic Maze(string mapfile) {ReadMap(mapfile);_start = FindPosition('S');}// Mapデータを読み込むpublic void ReadMap(string mapfile) {string[] map = File.ReadAllLines(mapfile);this._map = new char[map[0].Length, map.Length];for (int y = 0; y < map.Length; y++) {var line = map[y];for (int x = 0; x < line.Length; x++) {this._map[x, y] = line[x];}}XSize = map[0].Length;YSize = map.Length;}// インデクサ （これは、表示のみに利用する)public char this[int x, int y] {get { return _map[x, y]; }}// relativeの場所が何かを返すpublic Place Look(Position relative) {var pos = GetAbsolutePosition(relative);// pos = GetPosition(pos, direction);if (pos.X < 0 || pos.X >= this.XSize)return Place.Wall;if (pos.Y < 0 || pos.Y >= this.YSize)return Place.Wall;switch (_map[pos.X, pos.Y]) {case 'G':return Place.Goal;case 'S':return Place.Start;case ' ':return Place.Path;default:return Place.Wall;}}// 相対位置から絶対位置に変換 （相対位置は、startの位置を基準とする)public Position GetAbsolutePosition(Position relative) {return new Position {X = _start.X + relative.X,Y = _start.Y + relative.Y};}// target で指定した文字がある場所を求める。public Position FindPosition(char target) {for (int x = 0; x < XSize; x++) {for (int y = 0; y < YSize; y++) {if (_map[x, y] == target)return new Position { X = x, Y = y };}}throw new ApplicationException();}// Positionは値型なので、呼び出し元には影響を与えないpublic static Position GetPosition(Position current, Direction direction) {switch (direction) {case Direction.South:current.Y++;break;case Direction.East:current.X++;break;case Direction.North:current.Y--;break;case Direction.West:current.X--;break;}return current;}// 反対方向を求めるpublic static Direction BackDirection(Direction direction) {switch (direction) {case Direction.South:return Direction.North;case Direction.East:return Direction.West;case Direction.North:return Direction.South;case Direction.West:return Direction.East;}return Direction.None;}}
迷路クラス

*public Maze(string mapfile) {ReadMap(mapfile);_start = FindPosition('S');}
コンストラクタ

*public void ReadMap(string mapfile) {string[] map = File.ReadAllLines(mapfile);this._map = new char[map[0].Length, map.Length];for (int y = 0; y < map.Length; y++) {var line = map[y];for (int x = 0; x < line.Length; x++) {this._map[x, y] = line[x];}}XSize = map[0].Length;YSize = map.Length;}
Mapデータを読み込む

*public char this[int x, int y] {get { return _map[x, y]; }}
インデクサ （これは、表示のみに利用する)

*public Place Look(Position relative) {var pos = GetAbsolutePosition(relative);// pos = GetPosition(pos, direction);if (pos.X < 0 || pos.X >= this.XSize)return Place.Wall;if (pos.Y < 0 || pos.Y >= this.YSize)return Place.Wall;switch (_map[pos.X, pos.Y]) {case 'G':return Place.Goal;case 'S':return Place.Start;case ' ':return Place.Path;default:return Place.Wall;}}
relativeの場所が何かを返す

*if (pos.X < 0 || pos.X >= this.XSize)*return Place.Wall;
pos = GetPosition(pos, direction);

*public Position GetAbsolutePosition(Position relative) {return new Position {X = _start.X + relative.X,Y = _start.Y + relative.Y};}
相対位置から絶対位置に変換 （相対位置は、startの位置を基準とする)

*public Position FindPosition(char target) {for (int x = 0; x < XSize; x++) {for (int y = 0; y < YSize; y++) {if (_map[x, y] == target)return new Position { X = x, Y = y };}}throw new ApplicationException();}
target で指定した文字がある場所を求める。

*public static Position GetPosition(Position current, Direction direction) {switch (direction) {case Direction.South:current.Y++;break;case Direction.East:current.X++;break;case Direction.North:current.Y--;break;case Direction.West:current.X--;break;}return current;}
Positionは値型なので、呼び出し元には影響を与えない

*public static Direction BackDirection(Direction direction) {switch (direction) {case Direction.South:return Direction.North;case Direction.East:return Direction.West;case Direction.North:return Direction.South;case Direction.West:return Direction.East;}return Direction.None;}
反対方向を求める

*public struct Position {public int X { get; set; }public int Y { get; set; }public override string ToString() {return $"({X},{Y})";}}
位置情報構造体

*public enum Direction {None,East,West,South,North}
Position

*public class MazeSolver : IObservable<Direction> {
深さ優先探索
自分がいる絶対的な位置を知ることはできないものとする。
スタート位置を(0,0とし、どのように進んだかを自分自身で把握することで
相対的な位置だけはわかる。
迷路についてわかるのは自分の周りが道なのか壁なのかゴールなのかだけとする。

*public IEnumerable<Direction> Solve(Maze maze) {_maze = maze;_footprint.Add(_current);_Solve();return _path.Reverse();}
解く。必ず解が存在することが前提。

*public IEnumerable<Direction> Directions() {if (_lastDirection != Direction.None)yield return _lastDirection;if (_lastDirection != Direction.South)yield return Direction.South;if (_lastDirection != Direction.East)yield return Direction.East;if (_lastDirection != Direction.North)yield return Direction.North;if (_lastDirection != Direction.West)yield return Direction.West;}
４つの方向を列挙する （直前の方向を最初にする)

*private bool _Solve(int level = 0) {foreach (var direction in Directions().ToList()) {var temp = Maze.GetPosition(_current, direction);
Solveの下請け 再帰的に呼び出される

*private void Walk(Direction direction) {_current = Maze.GetPosition(_current, direction);_footprint.Add(_current);_path.Push(direction);_lastDirection = direction;Publish(direction);}
指定した方向へ歩く。

*public void Back(Direction direction) {var dir = Maze.BackDirection(direction);_current = Maze.GetPosition(_current, dir);Publish(dir);_path.Pop();}
逆の方向に戻る。

*private void TurnBack(Direction direction) {while (true) {var dir = Maze.BackDirection(_path.Pop());Back(dir);foreach (var nd in Directions()) {var temp = Maze.GetPosition(_current, nd);if (_maze.Look(temp) == Place.Path && !AlreadyPassed(temp))// その方向が指す場所は、まだ試していない （_footprintにない) なら、もう戻らなくて良いreturn;}// 行くべき道がないから、さらに戻る}}
逆戻りする

*return;
その方向が指す場所は、まだ試していない （_footprintにない) なら、もう戻らなくて良い

*}
行くべき道がないから、さらに戻る

*private bool AlreadyPassed(Position pos) {return _footprint.Exists(p => p.X == pos.X && p.Y == pos.Y);}
指定した方向は既に通った場所か

*private List<IObserver<Direction>> _observers = new List<IObserver<Direction>>();
このプログラムでは購読者は、Viewerオブジェクトの一つだけ。

*private void Complete() {foreach (var observer in _observers) {observer.OnCompleted();}}
終了を通知する

*private void Publish(Direction state) {foreach (var observer in _observers) {observer.OnNext(state);}}
状況変化を知らせるために購読者に通知する

*public IDisposable Subscribe(IObserver<Direction> observer) {_observers.Add(observer);return observer as IDisposable;}
observer(購読者) が通知を受け取れるようにする

*public void OnNext(Direction d) {// d方向に一つ動いた位置を新しい位置にする_current = Maze.GetPosition(_current, d);// 絶対位置を求めvar pos = _maze.GetAbsolutePosition(_current);// 足跡を残すConsole.SetCursorPosition(pos.X, pos.Y);Console.Write('.');Console.SetCursorPosition(pos.X, pos.Y);System.Threading.Thread.Sleep(100);}
状態が変化した （引数 d には、動いた方向が渡ってくる)

*_current = Maze.GetPosition(_current, d);
d方向に一つ動いた位置を新しい位置にする

*var pos = _maze.GetAbsolutePosition(_current);
絶対位置を求め

*Console.SetCursorPosition(pos.X, pos.Y);
足跡を残す

*public void Print() {for (int y = 0; y < _maze.YSize; y++) {for (int x = 0; x < _maze.XSize; x++) {Console.Write(_maze[x, y]);}Console.WriteLine();}}
迷路をConsoleに表示する


*PrefabUtility.ReplacePrefab(prefab, prefabAsset);
反映.

*public static void ScanTree(GameObject gameObj, System.Action<GameObject> onExecute)*{if (gameObj == null) return;if (onExecute == null) return;onExecute(gameObj);if (gameObj.transform.childCount > 0){for (int i = 0; i < gameObj.transform.childCount; ++i){var child = gameObj.transform.GetChild(i);ScanTree(child.gameObject, onExecute);}}}
子どものGameObjectを走査して処理を適用するためのヘルパ.

*targets.Add("Assets/Prefabs/PrefabA.prefab");
ディレクトリパスを指定.

*GameObject child = new GameObject();
新しい子ノードを追加してあげたりとか、

*PrefabChanger.ScanTree(prefab, gameObj => {GameObject.DestroyImmediate(gameObj.GetComponent<Hoge>());
要らなくなったコンポーネントを削除するとか、


*BluetoothLEAdvertisementWatcher watcher = new BluetoothLEAdvertisementWatcher();
https:docs.microsoft.com/ja-jp/windows/uwp/devices-sensors/ble-beacon よりPickUp


*public override Playable CreatePlayable(PlayableGraph graph, GameObject go)*{var behaviour = new TextPlayableBehaviour();behaviour.charaObject = charaObj.Resolve(graph.GetResolver());// behaviour.text = text;return ScriptPlayable<TextPlayableBehaviour>.Create(graph, behaviour);}
Factory method that generates a playable based on this asset

*public class TextPlayableBehaviour : PlayableBehaviour*{public GameObject charaObject;private string text;// Called when the owning graph starts playingpublic override void OnGraphStart(Playable playable) {this.text = this.charaObject.GetComponent<TextMeshPro>().text;this.charaObject.GetComponent<TextMeshPro>().text = "";}// Called when the owning graph stops playingpublic override void OnGraphStop(Playable playable) {this.charaObject.GetComponent<TextMeshPro>().text = this.text;}// Called when the state of the playable is set to Playpublic override void OnBehaviourPlay(Playable playable, FrameData info) {}// Called when the state of the playable is set to Pausedpublic override void OnBehaviourPause(Playable playable, FrameData info) {}// Called each frame while the state is set to Playpublic override void ProcessFrame(Playable playable, FrameData info, object playerData){// PlayableTrackのClip上でシークバーが移動するたびに呼ばれ続ける（PrepareFrameの後）if (charaObject == null) { return; }var percent = (float)playable.GetTime() / (float)playable.GetDuration();this.charaObject.GetComponent<TextMeshPro>().text =this.text.Substring(0, (int)Mathf.Round(this.text.Length * percent));}}
A behaviour that is attached to a playable

*public override void OnGraphStart(Playable playable) {this.text = this.charaObject.GetComponent<TextMeshPro>().text;this.charaObject.GetComponent<TextMeshPro>().text = "";}
Called when the owning graph starts playing

*public override void OnGraphStop(Playable playable) {this.charaObject.GetComponent<TextMeshPro>().text = this.text;}
Called when the owning graph stops playing

*public override void OnBehaviourPlay(Playable playable, FrameData info) {}
Called when the state of the playable is set to Play

*public override void OnBehaviourPause(Playable playable, FrameData info) {}
Called when the state of the playable is set to Paused

*public override void ProcessFrame(Playable playable, FrameData info, object playerData)*{// PlayableTrackのClip上でシークバーが移動するたびに呼ばれ続ける（PrepareFrameの後）if (charaObject == null) { return; }var percent = (float)playable.GetTime() / (float)playable.GetDuration();this.charaObject.GetComponent<TextMeshPro>().text =this.text.Substring(0, (int)Mathf.Round(this.text.Length * percent));}
Called each frame while the state is set to Play


*public Rigidbody parentRigidBody;
本体

*void Start () {rigidBody = GetComponent<Rigidbody>();}
Use this for initialization

*void Update () {if (Input.GetKey(KeyCode.Mouse1)){float deltaY = glindStartedY - parentRigidBody.position.y;if (deltaY >= 0){parentRigidBody.velocity = parentRigidBody.transform.forward.normalized * Mathf.Sqrt(2 * Physics.gravity.magnitude * deltaY);}}else{parentRigidBody.useGravity = true;glindStartedY = parentRigidBody.position.y;}}
Update is called once per frame


*NVelocity.App.Velocity.Init();
初期処理

*NVelocity.VelocityContext context = new NVelocity.VelocityContext();
コンテキストを生成する

*context.Put("name", "あいうえお");
変数と値の組み合わせを格納する

*StringBuilder sb = new StringBuilder();
テンプレートファイルを指定してテキストを生成する


*Console.WriteLine(dt.ToString("yyyy/MM/dd"));
例外発生

*}
例外発生時はチェックNG


*var notebooks = await graphClient.Me.Onenote.Sections.Request().GetAsync();
Note の セクション一覧を取得

*var pageList = await graphClient.Me.Onenote.Sections[secId].Pages.Request().GetAsync();
指定の セクションのページ一覧を取得

*Debug.WriteLine(page.Title + " " + page.LastModifiedDateTime);*Debug.WriteLine(page.Links.OneNoteWebUrl.Href);
指定のページの最終更新年月日を比較 新しい物を取得対象とする。

*var contentSt = await graphClient.Me.Onenote.Pages[doc.Id].Content.Request().GetAsync();
ページ取得のループ


*GetCalendar(credential, "(カレンダーID)");
アクセスしたいカレンダーのID


*Console.WriteLine(str);
①ifのスコープ内なので変数strが利用可能

*if(!(obj is string str)) return;
変数objがstring型であるならばキャストして変数strとして定義し、
変数objがstring型でないならreturnする

*Console.WriteLine(str);
①if文のスコープ外であるはずだが、変数strが利用できる

*if(!(obj is string)) return;*// if文の判定後にキャスト
変数objがstring型でないならreturnする

*string str = (string)obj;
if文の判定後にキャスト


*SimpleExcelCreator simpleExcelCreator = new SimpleExcelCreator("test.xlsx");
新規のExcelファイルを作成

*SimpleExcelCreator simpleExcelCreator = new SimpleExcelCreator("template.xlsx", "use_template.xlsx");
テンプレートとなるExcelを基にファイル作成

*simpleExcelCreator.Save();
保存

*simpleExcelCreator.AddSheet("SampleSheet1");
シート追加

*simpleExcelCreator.SelectSheet("SampleSheet2");
シート選択

*simpleExcelCreator.SetSheetName("ChangeName");
選択中のシート名変更

*simpleExcelCreator.RemoveSheet("SampleSheet3");
シートの削除

*simpleExcelCreator.WriteCell("A", 1, 1000);
アルファベットとy座標でデータ書込

*simpleExcelCreator.WriteCell(1, 1, "temp");
x,y座標指定でデータ書込(0は範囲外になります)

*simpleExcelCreator.WriteCell("A2", "temp");
セル指定でデータ書込

*simpleExcelCreator.RowCopyPaste(2, 5, false);
行のコピー&ペースト

*simpleExcelCreator.RowCopyPaste(2, 5, true);
コピーした行を挿入


*byte[] buf = img.GetPropertyItem(0x5100).Value;
PropertyTagFrameDelay


*app.UseLocalTimeZone();
← ココ


*ctxt.Acceptable = true;
<- 委譲元のAcceptableの値を変更


*using System.Web.Mvc;
追記

*protected void Application_Start(object sender, EventArgs e)*{// 以下の４行を追加AreaRegistration.RegisterAllAreas();FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);RouteConfig.RegisterRoutes(RouteTable.Routes);BundleConfig.RegisterBundles(BundleTable.Bundles);}
中略

*AreaRegistration.RegisterAllAreas();
以下の４行を追加

*public static void RegisterBundles(BundleCollection bundles)*{// 適宜追加// Web FormsからもBundleしたファイルを呼び出せます}
バンドルの詳細については、http:go.microsoft.com/fwlink/?LinkId=301862  を参照してください

*}
適宜追加
Web FormsからもBundleしたファイルを呼び出せます

*}
適宜追加

*routes.MapMvcAttributeRoutes();
属性でルーティング


*.AsEnumerable()
<- IEnumerable<T> に切り替わる


*ImmAssociateContext(handle, imeRet);
IMEを復元


*public bool IsDeleted { get; set; }
Column for Azure Search soft delete

*public bool IsDeleted { get; set; }
Column for Azure Search soft delete


*// 出力先を変えたい時は登録するロガー変えたり、追加する*static readonly ILoggerFactory loggerFactory = new LoggerFactory(new[] {new ConsoleLoggerProvider((category, level) =>category == DbLoggerCategory.Database.Command.Name&& level == LogLevel.Information, true) });
ロガーファクトリに ConsoleLoggerProvider を登録する。

*static readonly ILoggerFactory loggerFactory = new LoggerFactory(new[] {new ConsoleLoggerProvider((category, level) =>
出力先を変えたい時は登録するロガー変えたり、追加する

*protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) =>
UseLoggerFactory で上記のロガーファクトリを登録する。
Insert 文の値をロギングするために EnableSensitiveDataLogging を許可する。

*protected override void OnModelCreating(ModelBuilder modelBuilder) =>
データベースに初期値をシーディングする。
※データベースに値がない場合のみ Insert 文が走るので２重に登録される心配はない

*dbContext.Database.EnsureCreated();
まだDBがない場合にデータベースを作成。
存在する場合何もしないのでモデルとの整合性は保証されないが、
今回は使い捨てでマイグレーションを行わないのでこれでOK


*if (Input.GetButton("Jump")) return true;
ジャンプキー押しっぱなしで連続ジャンプ

*// または、 if (Input.GetKeyUp(KeyCode.Space)) return true; とかでも可*return false;
if (Input.GetButtonDown("Jump")) return true;     ジャンプキーが押された時だけジャンプにする時はこっち

*return false;
または、 if (Input.GetKeyUp(KeyCode.Space)) return true; とかでも可

*var isGroundHit = Physics.Raycast(
プレイヤーの位置から下向きにRaycast
レイヤーマスクでGroundを設定しているので、
地面のGameObjectにGroundのレイヤーを設定しておけば、
Groundのレイヤーを持つGameObjectで一番近いものが一つだけヒットする

*_groundDistance = float.MaxValue;
ヒットしなかった場合はキャラの下方に地面が存在しないものとして扱う

*if (_groundDistance < _groundDistanceLimit) {
地面とキャラの距離は環境によって様々で
完全にゼロにはならない時もあるため、
ジャンプしていない時の値に多少のマージンをのせた
一定値以下を接地と判定する
通常あり得ないと思われるが、オーバーフローされると再度アクションが実行されてしまうので、越えたところで止める

*// 状態が安定したものとして接地処理またはジャンプ処理を行う*if (_isGroundStateChange == _isGround && _notGround == 0) {if (landingAction != null) landingAction();} else
接地後またはジャンプ後、特定フレーム分状態の変化が無ければ、

*var inputStream = this.UpdateAsObservable().Select(_ => {
入力ストリーム

*if (jumpInput || Input.GetButton("Jump")) jumpInput = true;*return jumpInput;
if (jumpInput || JumpInput()) jumpInput = true;

**/
入力ストリームを通すと処理が遅れるようでリアルタイムなやり取りが難しかったので
今回はパス

*this.FixedUpdateAsObservable()
FixedUpdateを主軸にし、そこにinputStreamを合成する

*.Subscribe(x =>{if (jumpInput && !isJumping)  {
.WithLatestFrom(inputStream, (_, jump_input) => jump_input)

*// 状態が安定したものとして接地処理またはジャンプ処理を行う*_is_ground.Where(value => value == _isGroundStateChange).Subscribe(x => {jumpInput = false;isJumping = false;});
接地後またはジャンプ後、特定フレーム分状態の変化が無ければ、

*_is_ground.Where(value => value == _isGroundStateChange).Subscribe(x => {jumpInput = false;isJumping = false;});
状態が安定したものとして接地処理またはジャンプ処理を行う

*var isGroundHit = Physics.Raycast(
プレイヤーの位置から下向きにRaycast
レイヤーマスクでGroundを設定しているので、
地面のGameObjectにGroundのレイヤーを設定しておけば、
Groundのレイヤーを持つGameObjectで一番近いものが一つだけヒットする

*_groundDistance = float.MaxValue;
ヒットしなかった場合はキャラの下方に地面が存在しないものとして扱う

*if (_groundDistance < _groundDistanceLimit) {
地面とキャラの距離は環境によって様々で
完全にゼロにはならない時もあるため、
ジャンプしていない時の値に多少のマージンをのせた
一定値以下を接地と判定する
通常あり得ないと思われるが、オーバーフローされると再度アクションが実行されてしまうので、越えたところで止める


*var index1st = Array.IndexOf(list, max1st);
最大確率のインデックスを取得

*this.Text_Result_1st.Text = ans + ":" + max1st.ToString();
結果表示


*string fileName = "ShortCut.url";
ファイル名

*string shortcutPath = System.IO.Path.Combine(Directory.GetCurrentDirectory(), fileName);
作成するURLショートカットのパス

*System.Text.Encoding enc = System.Text.Encoding.GetEncoding("utf-8");
ショートカットのリンク先
string url = "https:www.google.co.jp/";
テキストファイルに書き込む

*var filePath = shortcutPath;
ファイルダウンロード


*System.Console.Out.WriteLine(FormatPhoneNumber("08001112222"));
0800:OK

*var numList5_1 = new List<string>()*{"01564", "01558", "01586", "01587", "01634", "01632","01547", "05769", "04992", "04994", "01456", "01457","01466", "01635", "09496", "08477", "08512", "08396","08388", "08387", "08514", "07468", "01655", "01648","01656", "01658", "05979", "04996", "01654", "01372","01374", "09969", "09802", "09912", "09913", "01398","01377", "01267", "04998", "01397", "01392",};
市外局番5桁、局番1桁の番号

*var numList4_2 = new List<string>()*{"0768", "0770", "0772", "0774", "0773", "0767", "0771", "0765","0748", "0747", "0746", "0826", "0749", "0776", "0763", "0761","0766", "0778", "0824", "0797", "0796", "0555", "0823", "0798","0554", "0820", "0795", "0556", "0791", "0790", "0779", "0558","0745", "0794", "0557", "0799", "0738", "0567", "0568", "0585","0586", "0566", "0564", "0565", "0587", "0584", "0581", "0572","0574", "0573", "0575", "0576", "0578", "0577", "0569", "0594","0827", "0736", "0735", "0725", "0737", "0739", "0743", "0742","0740", "0721", "0599", "0561", "0562", "0563", "0595", "0596","0598", "0597", "0744", "0852", "0956", "0955", "0954", "0952","0957", "0959", "0966", "0965", "0964", "0950", "0949", "0942","0940", "0930", "0943", "0944", "0948", "0947", "0946", "0967","0968", "0987", "0986", "0985", "0984", "0993", "0994", "0997","0996", "0995", "0983", "0982", "0973", "0972", "0969", "0974","0977", "0980", "0979", "0978", "0920", "0898", "0855", "0854","0853", "0553", "0856", "0857", "0863", "0859", "0858", "0848","0847", "0835", "0834", "0833", "0836", "0837", "0846", "0845","0838", "0865", "0866", "0892", "0889", "0887", "0893", "0894","0897", "0896", "0895", "0885", "0884", "0869", "0868", "0867","0875", "0877", "0883", "0880", "0879", "0829", "0550", "0228","0226", "0225", "0224", "0229", "0233", "0237", "0235", "0234","0223", "0220", "0192", "0191", "0187", "0193", "0194", "0198","0197", "0195", "0238", "0240", "0260", "0259", "0258", "0257","0261", "0263", "0266", "0265", "0264", "0256", "0255", "0243","0242", "0241", "0244", "0246", "0254", "0248", "0247", "0186","0185", "0144", "0143", "0142", "0139", "0145", "0146", "0154","0153", "0152", "0138", "0137", "0125", "0124", "0123", "0126","0133", "0136", "0135", "0134", "0155", "0156", "0176", "0175","0174", "0178", "0179", "0184", "0183", "0182", "0173", "0172","0162", "0158", "0157", "0163", "0164", "0167", "0166", "0165","0267", "0250", "0533", "0422", "0532", "0531", "0436", "0428","0536", "0299", "0294", "0293", "0475", "0295", "0297", "0296","0495", "0438", "0466", "0465", "0467", "0478", "0476", "0470","0463", "0479", "0493", "0494", "0439", "0268", "0480", "0460","0538", "0537", "0539", "0279", "0548", "0280", "0282", "0278","0277", "0269", "0270", "0274", "0276", "0283", "0551", "0289","0287", "0547", "0288", "0544", "0545", "0284", "0291", "0285",};
市外局番4桁、局番2桁の番号

*var numList4_3 = new List<string>()*{"0120", "0570", "0800", "0990"};
市外局番4桁、局番3桁の番号

*var numList3_3 = new List<string>()*{"058", "052", "011", "096", "049", "015", "048", "072","084", "028", "024", "076", "023", "047", "029", "075","025", "055", "026", "079", "082", "027", "078", "077","083", "022", "086", "089", "045", "044", "092", "046","017", "093", "059", "073", "019", "087", "042", "018","043", "088",};
市外局番3桁、局番3桁の番号

*var numList3_4 = new List<string>()*{"050",};
市外局番3桁、局番4桁の番号

*var numList2_4 = new List<string>()*{"03", "04", "06",};
市外局番2桁、局番4桁の番号

*var numList3_3or4 = new List<string>()*{"020", "070", "080", "090",};
市外局番3桁、一般ルールなら局番4桁、総務省ルールなら局番3桁

*var replacer = new Replacer();
番号変換クラスに変換ルールを登録

*var number = Regex.Replace(input, @"\D", "");
入力文字列から数値以外の文字を除去

*var formatted = replacer.TryReplace(number);*if (formatted != "")
変換を実行

*var matches = Regex.Match(number, @"\A(00(?:[013-8]|2\d|91[02-9])\d)(\d+)\z");
局番なしの場合の変換


*app.UsePathBase("
pathtoproject_directory");  ※ app.UseStaticFiles();に影響します


*base.Walk();
←SuperClassメソッドの呼び出し

*}
処理1

*}
処理2

*}
処理3


*string to = "";
コピー先


*var assemblyLoadMethodInfo = assemblyType.GetMethod("XXXX");
型を書けないので変数をnullで初期化できない
絶対にnullが返ってくる引数でGetMethodを呼び出して型推論させる

*// var assemblyLoadMethodInfo = assemblyType.GetMethod("Load", new[] { typeof(string) });
stringを引数に使うほうならGetMethodでも大丈夫だけどAssemblyNameのほうを使用したかったので使わない

*var bindingFlagsType = assemblyType.Assembly.GetType("System.Reflection.BindingFlags");
Instance | NonPublicのフラグ作成

*var enumType = assemblyLoadMethodInfo.MemberType.GetType().BaseType;*var toObjectMethodInfo = enumType.GetMethod("ToObject", new[] { enumType.GetType().BaseType, typeof(int) });
既存のEnum(MemberType)からenumの型情報取得

*var filedGetValueMethodInfo = invocationFlagsField.GetType().GetMethod("GetValue", new[] { typeof(object) });
invocationFlagsFieldがobjectなのでGet/Setもリフレクション経由

*var originalInvocationFlags = filedGetValueMethodInfo.Invoke(invocationFlagsField, new object[] { assemblyLoadMethodInfo });
INITIALIZEDのフラグ設定

*var assemblyLoadMethodInfo = assemblyType.GetMethod("Load", new[] { typeof(string) });
アセンブリのロードは文字列直接のほうを使う

*var consoleAssembly = assemblyLoadMethodInfo.Invoke(null, new[] { "System.Console" });
アセンブリのロードとタイプの取得


*<html xmlns="http:
www.w3.org1999xhtml">

*<asp:DropDownList ID="ddlPublish" runat="server" Width="150px" AutoPostBack="True" OnSelectedIndexChanged="DDLPublish_SelectedIndexChanged">
AutoPostBack="True"にしてOnSelectedIndexChangedイベントを追加すること

*dicPublish.Add(1, "日経BP社");
出版社情報定義

*books.Add(new Book("978-4-8222-9644-5", "アプリを作ろう! Android入門", 2000, 1, DateTime.ParseExact("2015/08/21", "yyyy/MM/dd", null), false));
書籍情報定義

*var ddlPublish = (DropDownList)sender;
senderオブジェクトよりコントロールを取得

*var ddlBook = ddlPublish.Parent.FindControl("ddlBook") as DropDownList;
ddlPublishの親コントロールを取得する


*HashSet<Player> hash = new HashSet<Player>();
p2 は重複していると扱われて格納されません

*Dictionary<Player, bool> dic = new Dictionary<Player, bool>();
p2 は重複していると扱われて ArgumentException がスローされます


*var ddt = TimeZoneInfo.ConvertTime(now, jddtTimeZone);
-> 20180831 13:44:05 +11:00

*var dt1 = new DateTimeOffset(2018, 9, 1, 12, 34, 56,jddtTimeZone.BaseUtcOffset + jddtTimeZone.GetAdjustmentRules()[0].DaylightDelta);
(4-2) 特定日時の場合

*} else*{var dt3 = new DateTimeOffset(dt2, jddtTimeZone.BaseUtcOffset);// -> 2018/10/01 12:34:56 +09:00}
-> 2018/09/01 12:34:56 +11:00

*var now1 = DateTimeOffset.Now.AddHours(1);
現在時刻の１時間後(夏時間考慮込み)

*jddstTimeZone.ConvertTime(now1);
結局出力は(自作した)TimeZoneInfoで変換するので、DateTimeOffsetなら問題ない


*Console.WriteLine(a);
5が出力される。


*Vector3 cLTxLB = Vector3.Cross(ToLeftTop, ToLeftBottom);
左端


*enum Hoge*{X, Y, Z}
using CommandLine;

*[Option('a', "aaa", Required = false, HelpText = "AAAA")]public string A { get; set; }
基本的な形式

*[Option('b', "bbb", Required = false, HelpText = "BBBB")]public bool B { get; set; }
プリミティブ型であれば、string以外でも受け取ることが可能

*[Option('c', "ccc", Separator = ',')]public IEnumerable<string> C { get; set; }
複数の値を受け取ることが可能。区切り文字はSeparatorで指定

*[Option('d', "ddd")]*public Hoge D { get; set; }
enumを受け取ることも可能(指定にはenumの名前を指定する)

*[Value(1, MetaName = "remaining")]public IEnumerable<string> Remaining { get; set; }
オプション以外の引数を受け取るための属性

*[Option('a', "aaa", Description = "option A", Required = false)]
第一引数がショート形式、第二引数がロング形式
第一、第二引数は省略可

*[Value(0, MetaName = "XValue")]public string X { get; set; }
MetaNameはヘルプ時に表示される

*Parser.Default.ParseArguments<Options>(args)*.WithParsed(opt => {/*パースに成功した場合*/})
using CommandLine.Text;

*await Parser.Default.ParseArguments<Options>(args)
非同期でint値を返す

*async opt =>*{// 何かの非同期処理await Task.Yield();return 0;}
成功した場合

*await Task.Yield();
何かの非同期処理

*async er =>*{// 何かの非同期処理await Task.Yield();return -1;}
失敗した場合

*await Task.Yield();
何かの非同期処理

*var parsed = (Parsed<Options>)result;
パース成功時

*}
処理

*var notParsed = (NotParsed<Options>)result;
パース失敗時

*}
処理

*Parser.Default.ParseArguments<MySubCommand, MySubCommand2>(args)*.WithParsed<MySubCommand>(opt1 => { /**/ })
MySubCommandとMySubCommand2があるとする

*using(var parser = new Parser((setting) => setting.HelpWriter = null))*{var parsed = parser.ParseArguments<Options>(args);parsed.WithNotParsed(er =>{// パース結果からデフォルトの文を生成したい場合は、HelpText.AutoBuildを使用するvar helpText = HelpText.AutoBuild(parsed);// 生成後にhelpText = helpText.Add...で追加記述も可能Console.WriteLine($"parse failed: {helpText}");});// 処理...}
using CommandLine.Text;

*var helpText = HelpText.AutoBuild(parsed);
パース結果からデフォルトの文を生成したい場合は、HelpText.AutoBuildを使用する

*Console.WriteLine($"parse failed: {helpText}");
生成後にhelpText = helpText.Add...で追加記述も可能

*}
処理...


*}
略...


*var filterSize = 5;
ここで1,3,5,7と変更しました。

*imageMat = imageMat.GaussianBlur(new OpenCvSharp.Size(filterSize, filterSize), 0);
偶数はガウシアンフィルタの原理上指定できないようです。
偶数を指定するとExceptionが発生します。

*var filterResult = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(imageMat);
ビットマップに戻します


*> m.Background = new SolidColorBrush(Colors.Purple);
ウインドウの背景色が紫色に変わる


*second.Subscribe(new Observer<string>(s =>{Console.WriteLine($"値:{s}");
before

*second.Subscribe(s => Console.WriteLine($"値:{s}"));
after

*var second = new Observable<string>(o =>{root.Subscribe(new Observer<string>(s =>{Console.WriteLine($"'{s}' が流れてきました。2倍にします。");
before

*var second = root.Select(s =>{Console.WriteLine($"'{s}' が流れてきました。2倍にします。");
after

*var third = new Observable<string>(o =>{second.Subscribe(new Observer<string>(s =>{if (s == "ふがふが")
before

*var third = second.Where(s =>{if (s == "ふがふが")
after


*.Where(x => x.Column_a == user_input);
このxは直前のJoinのテーブルが対象となる

*}
クエリでデータが取得できた場合の処理

*}
データが取得できなかった場合


*x1 = ref x2;
参照先=呼び出し元には影響しないので書ける

*}
呼び出し元には、x1=1, x2=3 が出力(out)される

*void DoSomethingIn(in int x1 = default) {},,,ref int DoReturnRef(in int x1, ref int x2, out int x3) {x3 = 1;
in引数はオプション引数にできる

*//}*if (x2 > x3) {return ref x2;}
return ref x1;  読み取り専用の参照(in)を読み取り可能な参照(ref)では返せない

*ref int y = ref a;
x = 100;  これはNG


*public static bool PlayBgm (SoundFile soundFile) {return Instance.DoPlayBgm (soundFile);}
BGMの再生.

*public static void PauseBgm (bool flag) {Instance.DoPauseBgm (flag);}
BGMの一時停止.

*public static void StopBgm () {Instance.DoStopBgm ();}
BGMの停止.

*public bool DoPlayBgm (SoundFile soundFile) {if ((int)soundFile != _bgmFileIdx) {_bgmChannel.Stop();_bgmFileIdx = (int)soundFile;var clip = soundFile.ToAudioClip();if (clip == null) return false;_bgmChannel.clip = clip;_bgmChannel.loop = true;_bgmChannel.volume = 1;_bgmChannel.Play ();}return true;}
BGMの再生.

*public void DoPauseBgm (bool flag) {if (flag) {_bgmChannel.Pause ();} else {_bgmChannel.Play ();}}
BGMの一時停止.

*public void DoStopBgm () {_bgmChannel.Stop ();_bgmFileIdx = -1;}
BGMの停止.

*public static AudioSource PlaySe (SoundFile soundFile) {return Instance.DoPlaySe (soundFile);}
SE再生.


*return false;
見つからなかった


*const string FILE_PATH = @"C:\Hoge.txt";
パスを定数で定義する

*System.IO.File.SetCreationTime(FILE_PATH, DateTime.Now);
作成日時を現在のローカル時刻で更新する

*System.IO.File.SetLastWriteTime(FILE_PATH, DateTime.Now);
更新日時を現在のローカル時刻で更新する

*System.IO.File.SetLastAccessTime(FILE_PATH, DateTime.Now);
アクセス日時を現在のローカル時刻で更新する


*string name = user.Name;
=> user が null なら System.NullReferenceException

*string name;
if 文

*var name = (user == null) ? null : user.Name;
三項演算子


*this.hook = SetWindowsHookEx(MouseLowLevelHook, handler, module, 0);
IntPtr module = Marshal.GetHINSTANCE(typeof(MouseHook).Assembly.GetModules()[0]);  ここを消すかコメントアウト

*this.hook = SetWindowsHookEx(KeyboardHookType, callback, module, 0);
IntPtr module = Marshal.GetHINSTANCE(typeof(KeyboardHook).Assembly.GetModules()[0]);  ここを消すかコメントアウト


*}
省略

*}
省略

*}
省略


*[System.Web.Services.Protocols.SoapRpcMethodAttribute("BaseGetUsersByLoginName", RequestNamespace="http:
wsdl.cybozu.co.jpbase2008", ResponseNamespace="http:wsdl.cybozu.co.jpbase2008", Use=System.Web.Services.Description.SoapBindingUse.Literal)]

*BaseBinding baseAPI = new BaseBinding();
base区分のAPIクライアント

*ActionElement actionElement = new ActionElement();
ヘッダ情報追加
--------------------------------------------------------
Garoon共通のSOAPヘッダー

*actionElement.actionValue = "BaseGetUsersByLoginName";
呼び出すAPI名

*securityElement.usernameToken = userNameTokenElement;
アクセス者
userNameTokenElement.Username = "xxxxx";  GaroonのログインID
userNameTokenElement.Password = "xxxxx";  ログインパスワード

*timeStampElement.Created = DateTime.UtcNow;
タイムスタンプ

*baseAPI.action = actionElement;
ヘッダー設定

*string[] param = { "yyyyy" };
リクエスト(Body)作成
--------------------------------------------------------
このAPIだとログインID配列のみ

*UserType[] userTypes = baseAPI.BaseGetUsersByLoginName(param);
SOAPリクエスト
--------------------------------------------------------

*Console.WriteLine(ex.Message);
ユーザーIDに一致するユーザーがいない場合もここに来る


*DialogVM.IsOpen.Value = true;
ダイアログ内容VMのOpenプロパティを変更することで、ダイアログのOpen・Closeを制御する

*await DialogVM.IsOpen;
ダイアログのOpenプロパティが変更されるのを待つ

*DialogResultText.Value = DialogVM.IsOK.Value == true ? "おーけー" : "きゃんせる";
ダイアログ結果を文字列に加工して表示

*IsOpen
ダイアログが開いたときにダイアログ結果をNullに設定


*return new Color(base.color.r, base.color.g, base.color.b, (base.color.a + (int)_blendType) / 2.0f);
加算の場合はアルファ値を0.0 ~ 0.5, 乗算の場合は0.5 ~ 1.0になるように変換をかける


*const int meetPointCount = 1;*void Start () {ResetMapData();CreateSpaceData();CreateDangeon();}
道の集合点を増やしたいならこれを増やす

*void Update () {}
Update is called once per frame


*private static TestSingleton _instance;
静的なインスタンスとして持つ

*private TestSingleton(){}
コンストラクタはprivate

*public static TestSingleton GetInstance()*{lock(_lockObject){if ( _instance == null){//インスタンス生成_instance = new TestSingleton();}return  _instance;}}
インスタンス取得のためのstaticメソッド

*_instance = new TestSingleton();
インスタンス生成


*var rnd = new Random();
使用する値をランダムに並び替える


*public class Maze {private char[,] _map;public int XSize { get; private set; }public int YSize { get; private set; }private Position _start;// コンストラクタpublic Maze(string mapfile) {ReadMap(mapfile);_start = FindPosition('S');}// Mapデータを読み込むpublic void ReadMap(string mapfile) {string[] map = File.ReadAllLines(mapfile);this._map = new char[map[0].Length, map.Length];for (int y = 0; y < map.Length; y++) {var line = map[y];for (int x = 0; x < line.Length; x++) {this._map[x, y] = line[x];}}XSize = map[0].Length;YSize = map.Length;}// インデクサ （これは、表示のみに利用する)public char this[int x, int y] {get { return _map[x, y]; }}// relativeの場所が何かを返すpublic Place Look(Position relative) {var pos = GetAbsolutePosition(relative);// pos = GetPosition(pos, direction);if (pos.X < 0 || pos.X >= this.XSize)return Place.Wall;if (pos.Y < 0 || pos.Y >= this.YSize)return Place.Wall;switch (_map[pos.X, pos.Y]) {case 'G':return Place.Goal;case 'S':return Place.Start;case ' ':return Place.Path;default:return Place.Wall;}}// 相対位置から絶対位置に変換 （相対位置は、startの位置を基準とする)public Position GetAbsolutePosition(Position relative) {return new Position {X = _start.X + relative.X,Y = _start.Y + relative.Y};}// target で指定した文字がある場所を求める。public Position FindPosition(char target) {for (int x = 0; x < XSize; x++) {for (int y = 0; y < YSize; y++) {if (_map[x, y] == target)return new Position { X = x, Y = y };}}throw new ApplicationException();}// Positionは値型なので、呼び出し元には影響を与えないpublic static Position GetPosition(Position current, Direction direction) {switch (direction) {case Direction.South:current.Y++;break;case Direction.East:current.X++;break;case Direction.North:current.Y--;break;case Direction.West:current.X--;break;}return current;}// 反対方向を求めるpublic static Direction BackDirection(Direction direction) {switch (direction) {case Direction.South:return Direction.North;case Direction.East:return Direction.West;case Direction.North:return Direction.South;case Direction.West:return Direction.East;}return Direction.None;}}
迷路クラス

*public Maze(string mapfile) {ReadMap(mapfile);_start = FindPosition('S');}
コンストラクタ

*public void ReadMap(string mapfile) {string[] map = File.ReadAllLines(mapfile);this._map = new char[map[0].Length, map.Length];for (int y = 0; y < map.Length; y++) {var line = map[y];for (int x = 0; x < line.Length; x++) {this._map[x, y] = line[x];}}XSize = map[0].Length;YSize = map.Length;}
Mapデータを読み込む

*public char this[int x, int y] {get { return _map[x, y]; }}
インデクサ （これは、表示のみに利用する)

*public Place Look(Position relative) {var pos = GetAbsolutePosition(relative);// pos = GetPosition(pos, direction);if (pos.X < 0 || pos.X >= this.XSize)return Place.Wall;if (pos.Y < 0 || pos.Y >= this.YSize)return Place.Wall;switch (_map[pos.X, pos.Y]) {case 'G':return Place.Goal;case 'S':return Place.Start;case ' ':return Place.Path;default:return Place.Wall;}}
relativeの場所が何かを返す

*if (pos.X < 0 || pos.X >= this.XSize)*return Place.Wall;
pos = GetPosition(pos, direction);

*public Position GetAbsolutePosition(Position relative) {return new Position {X = _start.X + relative.X,Y = _start.Y + relative.Y};}
相対位置から絶対位置に変換 （相対位置は、startの位置を基準とする)

*public Position FindPosition(char target) {for (int x = 0; x < XSize; x++) {for (int y = 0; y < YSize; y++) {if (_map[x, y] == target)return new Position { X = x, Y = y };}}throw new ApplicationException();}
target で指定した文字がある場所を求める。

*public static Position GetPosition(Position current, Direction direction) {switch (direction) {case Direction.South:current.Y++;break;case Direction.East:current.X++;break;case Direction.North:current.Y--;break;case Direction.West:current.X--;break;}return current;}
Positionは値型なので、呼び出し元には影響を与えない

*public static Direction BackDirection(Direction direction) {switch (direction) {case Direction.South:return Direction.North;case Direction.East:return Direction.West;case Direction.North:return Direction.South;case Direction.West:return Direction.East;}return Direction.None;}
反対方向を求める

*public struct Position {public int X { get; set; }public int Y { get; set; }public override string ToString() {return $"({X},{Y})";}}
位置情報構造体

*public enum Direction {None,East,West,South,North}
Direction

*public class Tracks {private List<Direction> _directionPath = new List<Direction>();private List<Position> _positionPath = new List<Position>();// コンストラクタpublic Tracks() {_directionPath.Add(Direction.None);_positionPath.Add(new Position { X = 0, Y = 0 });}// 進行方向の履歴public IEnumerable<Direction> GetDirectionPath() {return _directionPath;}// 位置の履歴public IEnumerable<Position> GetPositionPathh() {return _positionPath;}// 経路を追加public void Add(Position pos, Direction dir) {_positionPath.Add(pos);_directionPath.Add(dir);}// 最後の位置と方向を取得public (Position, Direction) Last() {return (_positionPath.Last(), _directionPath.Last());}// 現在の位置と方向を取得public (Position, Direction) Current {get {return (_positionPath.Last(), _directionPath.Last());}}public Tracks Clone() {var obj = new Tracks() {_directionPath = this._directionPath.ToList(),_positionPath = this._positionPath.ToList()};return obj;}}
経路を表すクラス 位置と進行方向からなる

*public Tracks() {_directionPath.Add(Direction.None);_positionPath.Add(new Position { X = 0, Y = 0 });}
コンストラクタ

*public IEnumerable<Direction> GetDirectionPath() {return _directionPath;}
進行方向の履歴

*public IEnumerable<Position> GetPositionPathh() {return _positionPath;}
位置の履歴

*public void Add(Position pos, Direction dir) {_positionPath.Add(pos);_directionPath.Add(dir);}
経路を追加

*public (Position, Direction) Last() {return (_positionPath.Last(), _directionPath.Last());}
最後の位置と方向を取得

*public (Position, Direction) Current {get {return (_positionPath.Last(), _directionPath.Last());}}
現在の位置と方向を取得

*public class MazeSolver : IObservable<Position> {private Maze _maze;// 解く。必ず解が存在することが前提。public IEnumerable<Direction> Solve(Maze maze) {_maze = maze;var tracks = _Solve();return tracks.GetDirectionPath();}public Tracks _Solve() {Queue<Tracks> queu = new Queue<Tracks>();queu.Enqueue(new Tracks());while (queu.Count != 0) {//キューの先頭から経路情報取り出すvar tracks = queu.Dequeue();var (currentPosition, currentDirection) = tracks.Current;foreach (var direction in Directions(currentDirection).ToList()) {// 次に進む位置を求めるvar nextpos = Maze.GetPosition(currentPosition, direction);// その場所の種類を調べるswitch (_maze.Look(nextpos)) {case Place.Goal:return tracks;case Place.Path:if (!AlreadyPassed(tracks, nextpos)) {// 通路でまだ通っていない場所ならば、キューに入れて覚えてくvar clone = tracks.Clone();clone.Add(nextpos, direction);queu.Enqueue(clone);Publish(nextpos);}break;}// 壁とStart位置ならば何もせずに、次の方向を調べる}}return null;}// ４つの方向を列挙する （できるだけ直進するように直前の方向を最初にする)public IEnumerable<Direction> Directions(Direction lastDirection) {if (lastDirection != Direction.None)yield return lastDirection;if (lastDirection != Direction.South)yield return Direction.South;if (lastDirection != Direction.East)yield return Direction.East;if (lastDirection != Direction.North)yield return Direction.North;if (lastDirection != Direction.West)yield return Direction.West;}// 指定した方向は既に通った場所かprivate bool AlreadyPassed(Tracks tracks, Position pos) {return tracks.GetPositionPathh().Any(p => p.X == pos.X && p.Y == pos.Y);}// このプログラムでは購読者は、Viewerオブジェクトの一つだけ。private List<IObserver<Position>> _observers = new List<IObserver<Position>>();// 終了を通知するprivate void Complete() {foreach (var observer in _observers) {observer.OnCompleted();}}// 状況変化を購読者に通知するprivate void Publish(Position state) {foreach (var observer in _observers) {observer.OnNext(state);}}// observer(購読者) が通知を受け取れるようにするpublic IDisposable Subscribe(IObserver<Position> observer) {_observers.Add(observer);return observer as IDisposable;}}
幅優先探索で解く

*public IEnumerable<Direction> Solve(Maze maze) {_maze = maze;var tracks = _Solve();return tracks.GetDirectionPath();}
解く。必ず解が存在することが前提。

*var tracks = queu.Dequeue();
キューの先頭から経路情報取り出す

*var nextpos = Maze.GetPosition(currentPosition, direction);
次に進む位置を求める

*var clone = tracks.Clone();
通路でまだ通っていない場所ならば、キューに入れて覚えてく

*}
壁とStart位置ならば何もせずに、次の方向を調べる

*public IEnumerable<Direction> Directions(Direction lastDirection) {if (lastDirection != Direction.None)yield return lastDirection;if (lastDirection != Direction.South)yield return Direction.South;if (lastDirection != Direction.East)yield return Direction.East;if (lastDirection != Direction.North)yield return Direction.North;if (lastDirection != Direction.West)yield return Direction.West;}
４つの方向を列挙する （できるだけ直進するように直前の方向を最初にする)

*private bool AlreadyPassed(Tracks tracks, Position pos) {return tracks.GetPositionPathh().Any(p => p.X == pos.X && p.Y == pos.Y);}
指定した方向は既に通った場所か

*private List<IObserver<Position>> _observers = new List<IObserver<Position>>();
このプログラムでは購読者は、Viewerオブジェクトの一つだけ。

*private void Complete() {foreach (var observer in _observers) {observer.OnCompleted();}}
終了を通知する

*private void Publish(Position state) {foreach (var observer in _observers) {observer.OnNext(state);}}
状況変化を購読者に通知する

*public IDisposable Subscribe(IObserver<Position> observer) {_observers.Add(observer);return observer as IDisposable;}
observer(購読者) が通知を受け取れるようにする

*public void OnNext(Position relative) {// 絶対位置を求めvar pos = _maze.GetAbsolutePosition(relative);// 足跡を残すConsole.SetCursorPosition(pos.X, pos.Y);Console.Write('.');Console.SetCursorPosition(pos.X, pos.Y);System.Threading.Thread.Sleep(100);}
状態が変化した （引数 relative は、相対位置)

*var pos = _maze.GetAbsolutePosition(relative);
絶対位置を求め

*Console.SetCursorPosition(pos.X, pos.Y);
足跡を残す

*public void Replay(IEnumerable<Direction> path) {var current = new Position { X = 0, Y = 0 };foreach (var d in path) {current = Maze.GetPosition(current, d);var pos = _maze.GetAbsolutePosition(current);Console.SetCursorPosition(pos.X, pos.Y);Console.Write('.');Console.SetCursorPosition(pos.X, pos.Y);System.Threading.Thread.Sleep(80);}Console.SetCursorPosition(0, _maze.YSize + 1);}
リプレイする

*public void Print() {for (int y = 0; y < _maze.YSize; y++) {for (int x = 0; x < _maze.XSize; x++) {Console.Write(_maze[x, y]);}Console.WriteLine();}}
迷路をConsoleに表示する


*public int ID { get; set; }
ID は自動で主キー

*// For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940*public void ConfigureServices(IServiceCollection services)
This method gets called by the runtime. Use this method to add services to the container.

*public void ConfigureServices(IServiceCollection services)*{services.AddMvc();services.AddDbContext<ShopDbContext>();}
For more information on how to configure your application, visit https:go.microsoft.com/fwlink/?LinkID=398940

*public void Configure(IApplicationBuilder app, IHostingEnvironment env)*{if (env.IsDevelopment())app.UseDeveloperExceptionPage();app.UseMvc();app.Run(async (context) => await context.Response.WriteAsync("Hello World!"));}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.


*using (var context = new BooksDbContext(options))
インメモリ DB を使うオプション設定を渡す

*var service = new BooksService(context);
サービスクラスをインスタンス化しデータベースコンテキストを DI

*using (var context = new BooksDbContext(options)){Assert.Equal(1, context.Books.Count());
再びインメモリ DB から値を取り出してテスト


*}
割愛

*AsyncClientStreamingCall<string, string> call1;
呼び出し

*await call1.AsRequestStreamingCall().SendRequestsAndCompleteAsync(requests).ConfigureAwait(false);
IAsyncRequestStreamingCall<TRequest> の拡張メソッドとして定義すれば次のように呼び出せます


*string[] fileDirArray = { @"C:\hoge.jpg", @"C:\fuga.jpg" };
添付したいファイルのパス

*MessageCreateThreadTypeFile[] files = new MessageCreateThreadTypeFile[0];
添付ファイル実体配列

*contentFile[] cFiles = new contentFile[0];
添付ファイル情報配列

*FileStream fs = new FileStream(fileDir, FileMode.Open, FileAccess.Read);
ファイル実体
------------------
1.添付するファイルをバイト配列にする

*MessageCreateThreadTypeFile file = new MessageCreateThreadTypeFile();
2.ファイル設定

*Array.Resize(ref files, cnt + 1);
3.添付ファイル配列に追加

*contentFile cFile = new contentFile();
ファイル情報
------------------
1.ファイル情報設定

*Array.Resize(ref cFiles, cnt + 1);
2.添付ファイル配列に追加

*messageThreadType.file = files;
添付ファイル実体配列、添付ファイル情報配列をそれぞれセット


*var loadImage = Cv2.ImRead(filename, ImreadModes.Color);
イメージの読み込み

*var hsvImage = loadImage.CvtColor(ColorConversionCodes.BGR2HSV, 3);
HSVカラーに変換

*var mask = hsvImage.InRange(new Scalar(5, 5, 5), new Scalar(250, 250, 250));
処理対象だけを抜き出す為のマスク
HSVcolor [0] 色相
HSVcolor [1] 彩度
HSVcolor [2] 輝度
手動で画像加工した時に真っ白BGR(255,255,255)、真っ黒(0,0,0) がいると閾値がずれてしまったので除去する。

*var res = new Mat();
マスクを通した結果画像を取得

*var gray = res.CvtColor(ColorConversionCodes.BGR2GRAY);
グレースケール変換

*var binImg = gray.Threshold(0, 255, ThresholdTypes.Otsu);
2値化

*var contours = new Mat[] { };
画像内の輪郭を抽出

*var squares = contours.Where(a =>{BoundingRectだと傾いたQRコードが検出できない？var rect = a.BoundingRect();
正方形っぽいものを抽出する

*var rect = a.MinAreaRect();
BoundingRectだと傾いたQRコードが検出できない？
var rect = a.BoundingRect();
var area = Math.Abs(Cv2.ContourArea(a));
var area_ratio = area / (rect.Width * rect.Height);
var rect_ratio = ((rect.Size.Width < rect.Size.Height) ?
(double)rect.Size.Width / (double)rect.Size.Height :
(double)rect.Size.Height / (double)rect.Size.Width);
return area > 10 && area_ratio > 0.7 && rect_ratio > 0.9;  正方形っぽいものを探して

*return area > 10 && !double.IsNaN(rect_ratio) && !double.IsInfinity(rect_ratio) && rect_ratio > 0.7;
この辺の数字は適宜調整してください

*return null;
正方形らしき輪郭は見つからなかったので

*var finderPattarn = squares.Where(a => squares.Count(b => a.BoundingRect().Contains(b.BoundingRect())) == 3).ToArray();
自らを含め3つの矩形を内包した矩形を探す = ファインダパターンの検出
黒、白、黒の3つの輪郭の最外郭が検出できる

*return null;
ファインダパターンは3つのコーナーに存在するはず
3つ無い時はQRコードが画像中に無いと考える。

*var qrCodeContour = Cv2.MinAreaRect(finderPattarn.Select(a => a.MinAreaRect().Points()).SelectMany(b => b));
ファインダパターンの頂点を含む矩形 = QRコードの輪郭

*var imgDetect = Cv2.ImRead(filename, ImreadModes.Color);
検出した輪郭を描画する為のイメージ(確認用のため不要です)

*Cv2.DrawContours(imgDetect, contours, -1, Scalar.Gold);
検出した輪郭を描画する。

*Cv2.DrawContours(imgDetect, squares, -1, Scalar.Blue);
正方形らしきものの輪郭を描画する。

*Cv2.DrawContours(imgDetect, finderPattarn, -1, Scalar.Red);
ファインダパターンの輪郭を描画する。

*for (int i = 0; i < 4; i++)*Cv2.Line(imgDetect, qrCodeContour.Points()[i], qrCodeContour.Points()[(i + 1) % 4], Scalar.LimeGreen);
QRコードの輪郭を描画する

*Cv2.ImShow("contuours", imgDetect[qrCodeContour.BoundingRect()]);
結果の表示

*return OpenCvSharp.Extensions.BitmapConverter.ToBitmap(loadImage[qrCodeContour.BoundingRect()]);
トリミングしたビットマップを取得


*System.Console.Out.WriteLine(FormatPhoneNumber("08001112222"));
0800:OK


*.ToList();
ToList でクエリが実行されるため ToList は必要

*[HttpPost]*public ActionResult<PostItem> Post([FromBody] PostItem postItem) {postItem.PostDateTime = DateTime.Now;BbsContext.PostItems.Add(postItem);BbsContext.SaveChanges();return postItem;}
POST api/bbs


*var ray = new Ray(animator.GetIKPosition(AvatarIKGoal.RightFoot), -transform.up);*RaycastHit hit;
右足

*animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, 1);
weightはとりあえず1で固定しておく（0f:元のアニメーション,1f:IKを完全に反映）

*ray = new Ray(animator.GetIKPosition(AvatarIKGoal.LeftFoot), -transform.up);*if (Physics.Raycast(ray, out hit, rayRange, LayerMask.GetMask(fieldLayerName)))
左足


*Console.WriteLine(AppState.Active.getViewStr());
<- メソッド呼び出し


*string newTodo;
private フィールドを追加する

*return;
テキストボックスが空なら追加しない

*todos.Add(new TodoItem { Title = newTodo });
Todo リストに新しい Todo を追加する

*newTodo = "";
テキストボックスを空に戻す。


*private double _weight    { get; set; }
体重


*this.socket = IO.Socket("http:
localhost:3000");


*newAngle = MainCamera.transform.localEulerAngles;*lastMousePosition = Input.mousePosition;
マウスクリック開始(マウスダウン)時にカメラの角度を保持(Z軸には回転させないため).

*newAngle.y += (Input.mousePosition.x - lastMousePosition.x) * 0.1f;
マウスの移動量分カメラを回転させる.


*app.UseCookiePolicy();
2.1 コードベース追加


*void FixedUpdate ()*{prePos = prePos2;prePos2 = transform.position;}
Update is called once per frame

*void OnTriggerEnter(Collider other)*{var meshCut = other.gameObject.GetComponent<MeshCut>();if (meshCut == null) { return; }var cutPlane = new Plane (Vector3.Cross(transform.forward.normalized, prePos - transform.position).normalized, transform.position);meshCut.Cut(cutPlane);}
このコンポーネントを付けたオブジェクトのCollider.IsTriggerをONにすること！


*class Program*{// 変換後のenumenum Status{Success = 0,Error = 99,}static void Main(string[] args){{var convertedText = ConvertToTextType<int>("99");Console.WriteLine(convertedText.GetType().Name + ", " + convertedText);// Int32, 99}{var convertedText = ConvertToTextType<Status>("99");Console.WriteLine(convertedText.GetType().Name + ", " + convertedText);// Status, Error}}// text を 型 T に変換するメソッドprivate static object ConvertToTextType<T>(string text){// ここに何か実装したい}}
結果確認用プログラム

*enum Status*{Success = 0,Error = 99,}
変換後のenum

*}*{var convertedText = ConvertToTextType<Status>("99");Console.WriteLine(convertedText.GetType().Name + ", " + convertedText);// Status, Error}
Int32, 99

*private static object ConvertToTextType<T>(string text)*{// ここに何か実装したい}
text を 型 T に変換するメソッド

*}
ここに何か実装したい

*private static object ConvertToTextType<T>(string text) where T : struct*{if (typeof(T) == typeof(int)){var canConvert = int.TryParse(text, out int result);if (!canConvert){throw new Exception("エラー");}return result;}else if (typeof(T).IsEnum){var canConvert = Enum.TryParse(text, out T result);if (!canConvert){throw new Exception("エラー");}return result;}return default(T);}
text を 型 T に変換するメソッド

*private static object ConvertToTextType<T>(string text)*{if (typeof(T) == typeof(int)){var converter = new Int32Converter();return converter.ConvertFrom(text);}else if (typeof(T).IsEnum){var converter = new EnumConverter(typeof(T));return converter.ConvertFrom(text);}return default(T);}
text を 型 T に変換するメソッド

*private static object ConvertToTextType<T>(string text)*{var converter = TypeDescriptor.GetConverter(typeof(T));return converter.ConvertFrom(text);}
text を 型 T に変換するメソッド

*var converter = TypeDescriptor.GetConverter(typeof(MyClass));
string型からMyClass型への変換

*public class MyConverter : TypeConverter*{public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value){if (value is string){return new MyClass { X = (string)value };}return base.ConvertFrom(context, culture, value);}}
自作Converter


*internal static DateTime GetDate(int year, short month, byte day)*{return new DateTime(year, month, day);}
例

*internal static DateTime GetDate(int year, short month, byte day)*{return new DateTime(year, month, day);}
例

*internal static DateTime GetDate(int year, short month, byte day)*{return new DateTime(year, month, day);}
例

*internal static DateTime GetDate(int year, short month, byte day)*{return new DateTime(year, month, day);}
例

*internal static DateTime GetDate(int year, short month, byte day)*{return new DateTime(year, month, day);}
例


*void Start()*{terrainData = GetComponent<Terrain>().terrainData;StartCoroutine(UpdateTerrainCoroutine());}
Use this for initialization

*void Update()*{terrainData = GetComponent<Terrain>().terrainData;StartCoroutine(UpdateTerrainCoroutine());//Debug.Log(terrainData.heightmapHeight);renderArea = 50;t += 1;}
Update is called once per frame


*Edition[] Editions = new [] {new Edition { Code = 1, Text = "Home" },new Edition { Code = 2, Text = "Pro" },new Edition { Code = 3, Text = "Enterprise" },};
"Edition" class has "int Code" and "string Text" properties.


*StreamWriter sw2 = new StreamWriter("hugahuga.csv", false, Encoding.GetEncoding("shift_jis"));*// -> 例外 ArgumentException: 'shift_jis' is not a supported encoding name.
-> OK

*,,,
-> 例外 ArgumentException: 'shift_jis' is not a supported encoding name.


*Task nowait = Task.Run(async () =>*{// client.Receive は ServerStreaming メソッドusing (var call = client.Receive(request, callOptions)){try{while (await call.ResponseStream.MoveNext().ConfigureAwait(false)){// レスポンスを受け取ったときの処理OnResponse(call.ResponseStream.Current);}catch (Exception ex){// 発生した例外に対する処理。キャンセルした場合も例外が発生します。}}}}
レスポンスストリームの読み込みが完了するまでブロックされるため、待機しないように実装する必要があります。

*using (var call = client.Receive(request, callOptions)){try{while (await call.ResponseStream.MoveNext().ConfigureAwait(false)){レスポンスを受け取ったときの処理OnResponse(call.ResponseStream.Current);
client.Receive は ServerStreaming メソッド

*OnResponse(call.ResponseStream.Current);
レスポンスを受け取ったときの処理

*}
発生した例外に対する処理。キャンセルした場合も例外が発生します。

*Action onDispose = () =>*{lock (m_Observers){m_Observers.Remove(observer);}};
dispose されたら監視オブジェクトを削除する

*Task nowait = Task.Run(async () =>*{try{// 1. RPCメソッドを実行し、配信オブジェクトを生成します。using (observable = client.Receive(request, callOptions).ToObservable()){// 2. 監視オブジェクトを生成します。observer = GrpcObservable.CreateObserver<Response>(// レスポンスを受け取ったときの処理response => OnResponse(response)// 例外が発生したときの処理, ex => OnError(ex)// 完了したときの処理, () => OnComplete());// 3. 監視オブジェクトを渡して購読オブジェクトを受け取ります。subscriver = observable.Subscribe(observer);// 4. 監視を開始します。await observable.ObserveAsync().ConfigureAwait(false);}}catch (Exception ex){// 配信クラスでは発生した例外を再スローしています。}finally{// 配信クラスでは dispose 時に購読オブジェクトを解放しています。// if (subscriber!= null) {subscriber.Dispose();}}}
レスポンスストリームの読み込みが完了するまでブロックされるため、待機しないように実装する必要があります。

*using (observable = client.Receive(request, callOptions).ToObservable()){2. 監視オブジェクトを生成します。observer = GrpcObservable.CreateObserver<Response>(
1. RPCメソッドを実行し、配信オブジェクトを生成します。

*observer = GrpcObservable.CreateObserver<Response>(レスポンスを受け取ったときの処理response => OnResponse(response)
2. 監視オブジェクトを生成します。

*response => OnResponse(response)
レスポンスを受け取ったときの処理

*, ex => OnError(ex)
例外が発生したときの処理

*, () => OnComplete()
完了したときの処理

*subscriver = observable.Subscribe(observer);
3. 監視オブジェクトを渡して購読オブジェクトを受け取ります。

*await observable.ObserveAsync().ConfigureAwait(false);
4. 監視を開始します。

*}
配信クラスでは発生した例外を再スローしています。

*subscriber.Dispose();
5. 購読を終了するには購読オブジェクトを解放します。

*var observer2 = GrpcObservable.CreateObserver<Response>(レスポンスを受け取ったときの処理response => OnResponse2(response)
2'. 新しい監視オブジェクトを生成します。

*response => OnResponse2(response)
レスポンスを受け取ったときの処理

*, ex => OnError2(ex)
例外が発生したときの処理

*, () => OnComplete2()
完了したときの処理

*var subscriver2 = observable.Subscribe(observer2);
3'. 新しい監視オブジェクトを渡して購読オブジェクトを受け取ります。

*Task nowait = Task.Run(async () =>*{try{// 1. RPCメソッドを実行し、配信オブジェクトを生成します。using (observable = client.Receive(callOptions).ToObservable()){// 2. 監視オブジェクトを生成します。observer = GrpcObservable.CreateObserver<Response>(// レスポンスを受け取ったときの処理response => OnResponse(response)// 例外が発生したときの処理, ex => OnError(ex)// 完了したときの処理, () => OnComplete());// 3. 監視オブジェクトを渡して購読オブジェクトを受け取ります。subscriver = observable.Subscribe(observer);// 4. 監視を開始します。await observable.ObserveAsync().ConfigureAwait(false);}}catch (Exception ex){// 配信クラスでは発生した例外を再スローしています。}finally{// 配信クラスでは dispose 時に購読オブジェクトを解放しています。// if (subscriber!= null) {subscriber.Dispose();}}}
レスポンスストリームの読み込みが完了するまでブロックされるため、待機しないように実装する必要があります。

*using (observable = client.Receive(callOptions).ToObservable()){2. 監視オブジェクトを生成します。observer = GrpcObservable.CreateObserver<Response>(
1. RPCメソッドを実行し、配信オブジェクトを生成します。

*observer = GrpcObservable.CreateObserver<Response>(レスポンスを受け取ったときの処理response => OnResponse(response)
2. 監視オブジェクトを生成します。

*response => OnResponse(response)
レスポンスを受け取ったときの処理

*, ex => OnError(ex)
例外が発生したときの処理

*, () => OnComplete()
完了したときの処理

*subscriver = observable.Subscribe(observer);
3. 監視オブジェクトを渡して購読オブジェクトを受け取ります。

*await observable.ObserveAsync().ConfigureAwait(false);
4. 監視を開始します。

*}
配信クラスでは発生した例外を再スローしています。

*await observable.WriteRequestAsync(request).ConfigureAwait(false);
5. リクエストを書き込む。

*await observable.CompleteRequestAsync().ConfigureAwait(false);
6. リクエストの完了を通知する。

*subscriber.Dispose();
7. 購読を終了するには購読オブジェクトを解放します。

*var observer2 = GrpcObservable.CreateObserver<Response>(レスポンスを受け取ったときの処理response => OnResponse2(response)
2'. 新しい監視オブジェクトを生成します。

*response => OnResponse2(response)
レスポンスを受け取ったときの処理

*, ex => OnError2(ex)
例外が発生したときの処理

*, () => OnComplete2()
完了したときの処理

*var subscriver2 = observable.Subscribe(observer2);
3'. 新しい監視オブジェクトを渡して購読オブジェクトを受け取ります。


*Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
ScreenPointToRayに因るベクトルの取得


*{
コンストラクタで各種情報を設定

*job_handles[ i ] = job_router.Schedule();
ジョブをスケジュール

*JobHandle.ScheduleBatchedJobs();
ジョブを開始

*Route[] results = new Route[ goals.Length ];
順番に経路探索ジョブを待って、結果を作成

*job_handles[ i ].Complete();
ジョブ待ち

*var route = new Route();
結果をルートに変換


*DateTime dt = DateTime.Now;
開始時の現在時刻を取得しておく

*IEnumerable<string[]> context = Context(@"C:\うんたらかんたら\KEN_ALL.CSV", ",", Encoding.GetEncoding(932));
郵便番号データのコンテキストを生成

*Console.WriteLine(dt);
開始時の現在時刻を表示

*Console.WriteLine(DateTime.Now);
終了時の現在時刻を表示

*public static IEnumerable<string[]> Context(string path, string separator = ",", Encoding encoding = null)
指定されたCSVファイルへのコンテキストを生成する

*DateTime dt = DateTime.Now;
開始時の現在時刻を取得しておく

*using (Stream stream = new MemoryStream(Encoding.Default.GetBytes(readToEnd[i]))){using (TextFieldParser parser = new TextFieldParser(stream, Encoding.GetEncoding(932))){parser.TextFieldType = FieldType.Delimited;
１行のstringをstream化してTextFieldParserで処理する

*Console.WriteLine(dt);
開始時の現在時刻を表示

*Console.WriteLine(DateTime.Now);
終了時の現在時刻を表示

*DateTime dt = DateTime.Now;
開始時の現在時刻を取得しておく

*using (Stream stream = new MemoryStream(Encoding.Default.GetBytes(sr.ReadLine()))){using (TextFieldParser parser = new TextFieldParser(stream, Encoding.GetEncoding(932))){parser.TextFieldType = FieldType.Delimited;
１行のstringをstream化してTextFieldParserで処理する

*Console.WriteLine(dt);
開始時の現在時刻を表示

*Console.WriteLine(DateTime.Now);
終了時の現在時刻を表示

*DateTime dt = DateTime.Now;
開始時の現在時刻を取得しておく

*IEnumerable<string[]> context = Context(@"C:\なんでんかんでん\KEN_ALL.CSV", ",", Encoding.GetEncoding(932));
郵便番号データのコンテキストを生成

*Console.WriteLine(dt);
開始時の現在時刻を表示

*Console.WriteLine(DateTime.Now);
終了時の現在時刻を表示

*public static IEnumerable<string[]> Context(string path, string separator = ",", Encoding encoding = null)
指定されたCSVファイルへのコンテキストを生成する


*for (int i = angle * 6, j = 0; i < triangles.Length; i += 6, j += 2)
上下面


*float size = 2000;
NOTE!

*void Update () {transform.Translate (0, 0, speed);if (this.transform.position.z + size < 0) {Debug.Log("out of display");this.transform.Translate(0, 0, size * 2);}}
Update is called once per frame

*void Update()*{transform.Translate(0, 0, speed);if (this.transform.position.z >500){Debug.Log("out of display");this.transform.Translate(0, 0, -1000 );}}
Update is called once per frame


*Dealer.Take(faceUp: false);
2枚目は裏向き

*WriteLine($"<< {Player.Name} turn! >>");
ユーザーのターン

*WriteLine($"<< {Dealer.Name} turn! >>");
ディーラーのターン

*WriteLine("<< Result >>");
判定

*bool ConfrimHitOrStand(string message, char hit, char stand) {while (true) {Write($"{message} [{hit}/{stand}]");var key = ReadKey().KeyChar;WriteLine();if (key == hit)return true;if (key == stand)return false;WriteLine($"Invalid key. Please input {hit} or {stand}.");}}
ヒット・スタンド確認

*void Won() {WriteLine($"{Player.Name} won. Congrats!");End();}
勝ち

*void Lost() {WriteLine($"{Player.Name} lost.");End();}
負け

*void Drawn() {WriteLine("This game was drawn...");End();}
引き分け

*void End() {WriteLine("To close, press any key.");ReadKey(intercept: true);Environment.Exit(0);}
終了


*var indexs = choices.Select(choice => new InversedIndex(choice));
全ての候補の転置インデックスを作成する

*var paths = new List<Path>();
初期のPathを作成する

*var selectedChoice = paths.OrderByDescending(Path => Path.Score()).First().Source();
一番スコアの高いPathを採択


*MainLabel.Content = "Hello World!";
ここ


*float ObjectHeight;
オブジェクトの高さ

*void Start()*{m_MainCamera = GameObject.Find("Main Camera").GetComponent<Camera>();//カメラ領域の左下の座標を取得BottomLeft = m_MainCamera.ScreenToWorldPoint(Vector3.zero);// カメラ領域の右上の座標を取得TopRight = m_MainCamera.ScreenToWorldPoint(new Vector3(Screen.width, Screen.height, 0.0f));//オブジェクトの幅・高さを取得ObjectWidth = this.GetComponent<MeshRenderer>().bounds.size.x;ObjectHeight = this.GetComponent<MeshRenderer>().bounds.size.y;//カメラの領域の幅・高さをワールド座標系数値で取得Width = (TopRight.x - BottomLeft.x) ;Height = (TopRight.y - BottomLeft.y) ;//上記二値からスケール（ローカル座標系）を調整transform.localScale = new Vector3(Width/ ObjectWidth, Height/ ObjectHeight, 0);}
Start is called before the first frame update

*BottomLeft = m_MainCamera.ScreenToWorldPoint(Vector3.zero);
カメラ領域の左下の座標を取得

*TopRight = m_MainCamera.ScreenToWorldPoint(new Vector3(Screen.width, Screen.height, 0.0f));
カメラ領域の右上の座標を取得

*ObjectWidth = this.GetComponent<MeshRenderer>().bounds.size.x;
オブジェクトの幅・高さを取得

*Width = (TopRight.x - BottomLeft.x) ;
カメラの領域の幅・高さをワールド座標系数値で取得

*transform.localScale = new Vector3(Width/ ObjectWidth, Height/ ObjectHeight, 0);*}
上記二値からスケール（ローカル座標系）を調整


*var following = (await token.Friends.IdsAsync()).ToArray();
Following取得

*var n = 100;
ListId(ぶち抜いたListIdを代入)
var listid = 5554560721;値変えてね
100人ずつ追加

*await Task.Delay(2000);
2秒間隔で実行。フォローが多い場合はこの値を調整して手加減する


*if (y + i < 8 && x + i < 8 && map[y + i, x + i] == 'Q') return false;*if (y - i >= 0 && x + i < 8 && map[y - i, x + i] == 'Q') return false;
if (map[y, i] == 'Q') return false;


*frame[14] = sw ? (byte)0x30 : (byte)0x31;
0x30がスイッチオン 0x31がスイッチオフ


*var number = testList[0];
エラー

*var number = testList[0];
正常に動作する

*((List<int>)testList)[0] = 100;
キャスト変換により値が変更可能

*((List<int>)testList)[0] = 200;
キャスト変換により値が変更可能

*Test(readOnlyLists.AsReadOnly());
ReadOnlyCollection<T>オブジェクトにする

*((List<int>)testList)[0] = 200;
エラー
実行時,System.InvalidCastExceptionが発生する


*listBucketResponse.Dump();
バケット一覧を表示

*}
ListObjects のパラメータには ListObjectsRequest クラスを使うこともできるが、
上記のようにクラスを作成せずに使える場合もある。

*using (var sr = new StreamReader(getObjectResponse.ResponseStream)){var content = await sr.ReadToEndAsync();
StreamReader を使って ResponseStream から文字列を読む

*}
次のようにファイルに保存することもできる。
getObjectResponse.WriteResponseStreamToFile(@"C:\Temp\test");

※StreamReader と WriteResponseStreamToFile を同時に使うことはできない。


*public Component(){....}
コンストラクタ

*public void update(){....}
更新

*private string Name;
1.こういう書き方はせず

*string Name { get; set; }
2.こういう書き方をする

*if (!Util.IsRegisteredLicense(Name))*return false;
Utilのライセンスの判定処理がうまくいかない場合があるので, 一旦マスク


*sphereOnGui.Rotate ();
黄色い球

*this.transform.RotateAround (*center,
Rotate around the center of (0,0,0)


*[Tooltip("The service URL (optional). This defaults to \"https:
api.us-south.speech-to-text.watson.cloud.ibm.com\"")]


*//  See the License for the specific language governing permissions and*//  limitations under the License.
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

*namespace DurableTask.AzureStorage.Tracking*{using DurableTask.Core;using Microsoft.WindowsAzure.Storage.Table;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Xml.Linq;/// <summary>/// OrchestrationInstanceStatusQueryBuilder is a builder to create a StorageTable Query/// </summary>internal class OrchestrationInstanceStatusQueryCondition{public IEnumerable<OrchestrationStatus> RuntimeStatus { get; set; }public DateTime CreatedTimeFrom { get; set; }public DateTime CreatedTimeTo { get; set; }public TableQuery<T> ToTableQuery<T>()where T : TableEntity, new(){var query = new TableQuery<T>();if (!((RuntimeStatus == null || (!RuntimeStatus.Any())) && CreatedTimeFrom == default(DateTime) && CreatedTimeTo == default(DateTime))){query.Where(GetConditions());}return query;}private string GetConditions(){var conditions = new List<string>();if (default(DateTime) != this.CreatedTimeFrom){conditions.Add(TableQuery.GenerateFilterConditionForDate("CreatedTime", QueryComparisons.GreaterThanOrEqual, new DateTimeOffset(this.CreatedTimeFrom)));}if (default(DateTime) != this.CreatedTimeTo){conditions.Add(TableQuery.GenerateFilterConditionForDate("CreatedTime", QueryComparisons.LessThanOrEqual, new DateTimeOffset(this.CreatedTimeTo)));}if (this.RuntimeStatus != null && this.RuntimeStatus.Any()){var runtimeCondition = this.RuntimeStatus.Select(x => TableQuery.GenerateFilterCondition("RuntimeStatus", QueryComparisons.Equal, x.ToString())).Aggregate((a, b) => TableQuery.CombineFilters(a, TableOperators.Or, b));if (runtimeCondition.Count() != 0){conditions.Add(runtimeCondition);}}if (conditions.Count == 1){return conditions[0];}else{return conditions.Aggregate((a, b) => TableQuery.CombineFilters(a, TableOperators.And, b));}}/// <summary>/// Parse is a factory method of the OrchestrationInstanceStatusConditionQuery/// </summary>/// <param name="createdTimeFrom">CreatedTimeFrom</param>/// <param name="createdTimeTo">CreatedTimeTo</param>/// <param name="runtimeStatus">RuntimeStatus</param>/// <returns></returns>public static OrchestrationInstanceStatusQueryCondition Parse(DateTime createdTimeFrom, DateTime? createdTimeTo, IEnumerable<OrchestrationStatus> runtimeStatus){var condition = new OrchestrationInstanceStatusQueryCondition();condition.CreatedTimeFrom = createdTimeFrom;condition.CreatedTimeTo = (createdTimeTo != null) ? (DateTime)createdTimeTo : default(DateTime);condition.RuntimeStatus = runtimeStatus;return condition;}}}
----------------------------------------------------------------------------------

*//  See the License for the specific language governing permissions and*//  limitations under the License.
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

*namespace DurableTask.AzureStorage.Tests*{using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using DurableTask.AzureStorage.Tracking;using DurableTask.Core;using DurableTask.ServiceBus.Tracking;using Microsoft.VisualStudio.TestTools.UnitTesting;[TestClass]public class OrchestrationInstanceStatusQueryConditionTest{[TestMethod]public void OrchestrationInstanceQuery_RuntimeStatus(){var runtimeStatus = new OrchestrationStatus[] { OrchestrationStatus.Running };var condition = new OrchestrationInstanceStatusQueryCondition{RuntimeStatus = runtimeStatus};var query = condition.ToTableQuery<OrchestrationInstanceStatus>();Assert.AreEqual("RuntimeStatus eq 'Running'", query.FilterString);}[TestMethod]public void OrchestrationInstanceQuery_CreatedTime(){var condition = new OrchestrationInstanceStatusQueryCondition{CreatedTimeFrom = new DateTime(2018, 1, 10, 10, 10, 10),CreatedTimeTo = new DateTime(2018, 1, 10, 10, 10, 50)};var result = condition.ToTableQuery<OrchestrationInstanceStatus>().FilterString;Assert.AreEqual("(CreatedTime ge datetime'2018-01-10T01:10:10.0000000Z') and (CreatedTime le datetime'2018-01-10T01:10:50.0000000Z')", condition.ToTableQuery<OrchestrationInstanceStatus>().FilterString);}[TestMethod]public void OrchestrationInstanceQuery_CreatedTimeOnly(){var condition = new OrchestrationInstanceStatusQueryCondition{CreatedTimeFrom = new DateTime(2018, 1, 10, 10, 10, 10),CreatedTimeTo = default(DateTime),RuntimeStatus = new List<OrchestrationStatus>(),};var result = condition.ToTableQuery<OrchestrationInstanceStatus>().FilterString;Assert.AreEqual("CreatedTime ge datetime'2018-01-10T01:10:10.0000000Z'", condition.ToTableQuery<OrchestrationInstanceStatus>().FilterString);}[TestMethod]public void OrchestrationInstanceQuery_CreatedTimeVariations(){var condition = new OrchestrationInstanceStatusQueryCondition{CreatedTimeFrom = new DateTime(2018, 1, 10, 10, 10, 10)};Assert.AreEqual("CreatedTime ge datetime'2018-01-10T01:10:10.0000000Z'", condition.ToTableQuery<OrchestrationInstanceStatus>().FilterString);condition = new OrchestrationInstanceStatusQueryCondition{CreatedTimeTo = new DateTime(2018, 1, 10, 10, 10, 50)};Assert.AreEqual("CreatedTime le datetime'2018-01-10T01:10:50.0000000Z'", condition.ToTableQuery<OrchestrationInstanceStatus>().FilterString);}[TestMethod]public void OrchestrationInstanceQuery_Combination(){var runtimeStatus = new OrchestrationStatus[] { OrchestrationStatus.Running };var condition = new OrchestrationInstanceStatusQueryCondition{RuntimeStatus = runtimeStatus,CreatedTimeFrom = new DateTime(2018, 1, 10, 10, 10, 10),CreatedTimeTo = new DateTime(2018, 1, 10, 10, 10, 50)};Assert.AreEqual("((CreatedTime ge datetime'2018-01-10T01:10:10.0000000Z') and (CreatedTime le datetime'2018-01-10T01:10:50.0000000Z')) and (RuntimeStatus eq 'Running')", condition.ToTableQuery<OrchestrationInstanceStatus>().FilterString);}[TestMethod]public void OrchestrationInstanceQuery_NoParameter(){var condition = new OrchestrationInstanceStatusQueryCondition();var query = condition.ToTableQuery<OrchestrationInstanceStatus>();Assert.IsNull(query.Expression);}[TestMethod]public void OrchestrationInstanceQuery_MultipleRuntimeStatus(){var runtimeStatus = new OrchestrationStatus[] { OrchestrationStatus.Running , OrchestrationStatus.Completed };var condition = new OrchestrationInstanceStatusQueryCondition{RuntimeStatus = runtimeStatus,CreatedTimeFrom = new DateTime(2018, 1, 10, 10, 10, 10),CreatedTimeTo = new DateTime(2018, 1, 10, 10, 10, 50)};Assert.AreEqual("((CreatedTime ge datetime'2018-01-10T01:10:10.0000000Z') and (CreatedTime le datetime'2018-01-10T01:10:50.0000000Z')) and ((RuntimeStatus eq 'Running') or (RuntimeStatus eq 'Completed'))", condition.ToTableQuery<OrchestrationInstanceStatus>().FilterString);}[TestMethod]public void OrchestrationInstanceQuery_Parse(){var runtimeStatus = new List<OrchestrationStatus>();runtimeStatus.Add(OrchestrationStatus.Running);var condition = OrchestrationInstanceStatusQueryCondition.Parse(new DateTime(2018, 1, 10, 10, 10, 10), new DateTime(2018, 1, 10, 10, 10, 50), runtimeStatus);Assert.AreEqual("((CreatedTime ge datetime'2018-01-10T01:10:10.0000000Z') and (CreatedTime le datetime'2018-01-10T01:10:50.0000000Z')) and (RuntimeStatus eq 'Running')", condition.ToTableQuery<OrchestrationInstanceStatus>().FilterString);}[TestMethod]public void OrchestrationInstanceQuery_ParseOptional(){var runtimeStatus = new List<OrchestrationStatus>();runtimeStatus.Add(OrchestrationStatus.Running);var condition = OrchestrationInstanceStatusQueryCondition.Parse(default(DateTime), null, runtimeStatus);var query = condition.ToTableQuery<OrchestrationInstanceStatus>();Assert.AreEqual("RuntimeStatus eq 'Running'", query.FilterString);}}}
----------------------------------------------------------------------------------

*CloudStorageAccount storageAccount = CloudStorageAccount.Parse(CloudConfigurationManager.GetSetting("StorageConnectionString"));
Retrieve the storage account from the connection string


*this[index] = new T();
初期値

*public virtual IEnumerable<int> GetAllIndexes() {for (int y = 1; y <= this.YSize; y++) {for (int x = 1; x <= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する

*public virtual IEnumerable<int> EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index) && this[index] != null; index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Horizontal(int x, int y)
(x,y)から右(水平)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Virtical(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantR(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantL(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む

*_combinations = Combination.Enumerate(new int[] { 1, 2, 3, 4, 5, 6 }, 2, false).ToArray();
重複無しの組み合わせを求める

*InnerSolve(1, Stone.Black);
まずは、1行目から黒を置いてゆく

*public void InnerSolve(int y, Stone stone) {if (y == 7) {if (stone == Stone.Black)// 今度は、１行目から白を置いてゆくInnerSolve(1, Stone.White);else if (stone == Stone.White) {// 黒白両方置き終わった（解が見つかったので通知する)Publish(board);}return;}// y行にstoneを２つずつ置くforeach (var combi in _combinations) {int a = combi[0];int b = combi[1];if (board[a, y] != Stone.Empty || board[b, y] != Stone.Empty)continue;board[a, y] = stone;board[b, y] = stone;try {if (board.IsCorrect(a, y, stone) && board.IsCorrect(b, y, stone)) {// 条件を満たしているので、次の行を処理する。InnerSolve(y + 1, stone);}} finally {// バックトラックするため、状態を戻す。board[a, y] = Stone.Empty;board[b, y] = Stone.Empty;}}return;}
ｙで指定した行にstone(White or Black)を置く

*InnerSolve(1, Stone.White);*else if (stone == Stone.White) {// 黒白両方置き終わった（解が見つかったので通知する)Publish(board);}
今度は、１行目から白を置いてゆく

*Publish(board);
黒白両方置き終わった（解が見つかったので通知する)

*InnerSolve(y + 1, stone);
条件を満たしているので、次の行を処理する。

*board[a, y] = Stone.Empty;
バックトラックするため、状態を戻す。

*private void Publish(Board board) {foreach (var observer in observers)observer.OnNext(board);}
状況変化を知らせるために購読者に通知する

*private void Complete() {foreach (var observer in observers) {observer.OnCompleted();}}
終了を通知する

*Up = this.ToDirection(0, -1);
計算回数を少なくするために、事前に求めておく。

*internal bool IsCorrect(int x, int y, Stone piece) {return EightLines(x, y).All(line => line.Count(p => this[p] == piece) <= 2);}
x,y 座標にpieceを置いたが、条件を満たしているか

*public IEnumerable<int[]> EightLines(int x, int y) {// 縦方向 （この配列要素順は問わない、以下も同様）yield return this.EnumerateIndexes(x, y, Up).Skip(1).Concat(EnumerateIndexes(x, y, Down)).ToArray();// 横方向yield return this.EnumerateIndexes(x, y, Left).Skip(1).Concat(EnumerateIndexes(x, y, Right)).ToArray();// 右斜め４５％  （＼）yield return this.EnumerateIndexes(x, y, UpperLeft).Skip(1).Concat(EnumerateIndexes(x, y, BottomRight)).ToArray();// 左斜め４５％ （／）yield return this.EnumerateIndexes(x, y, UpperRight).Skip(1).Concat(EnumerateIndexes(x, y, BottomLeft)).ToArray();// 下右右  （傾斜が緩い 右斜め）yield return this.EnumerateIndexes(x, y, UpperLeftLeft).Skip(1).Concat(EnumerateIndexes(x, y, BottomRightRight)).ToArray();// 下左左  （傾斜が緩い 左斜め）yield return this.EnumerateIndexes(x, y, UpperRightRight).Skip(1).Concat(EnumerateIndexes(x, y, BottomLeftLeft)).ToArray();// 下下右  （傾斜がきつい 右斜め）yield return this.EnumerateIndexes(x, y, UpperUpperLeft).Skip(1).Concat(EnumerateIndexes(x, y, BottomBottomRight)).ToArray();// 下下左 （傾斜がきつい 左斜め）yield return this.EnumerateIndexes(x, y, UpperUpperRight).Skip(1).Concat(EnumerateIndexes(x, y, BottomBottomLeft)).ToArray();}
indexで指定した位置を通る８本の線を列挙する

*yield return this.EnumerateIndexes(x, y, Up).Skip(1)
縦方向 （この配列要素順は問わない、以下も同様）

*yield return this.EnumerateIndexes(x, y, Left).Skip(1)
横方向

*yield return this.EnumerateIndexes(x, y, UpperLeft).Skip(1)
右斜め４５％  （＼）

*yield return this.EnumerateIndexes(x, y, UpperRight).Skip(1)
左斜め４５％ （／）

*yield return this.EnumerateIndexes(x, y, UpperLeftLeft).Skip(1)
下右右  （傾斜が緩い 右斜め）

*yield return this.EnumerateIndexes(x, y, UpperRightRight).Skip(1)
下左左  （傾斜が緩い 左斜め）

*yield return this.EnumerateIndexes(x, y, UpperUpperLeft).Skip(1)
下下右  （傾斜がきつい 右斜め）

*yield return this.EnumerateIndexes(x, y, UpperUpperRight).Skip(1)
下下左 （傾斜がきつい 左斜め）

*var unused = withRepetition ? items : items.SkipWhile(e => !e.Equals(item)).Skip(1).ToList();
item よりも前のものを除く （順列と組み合わせの違い)
重複を許さないので、unusedから item そのものも取り除く


*Debug.Log(target?.name);
`UnassignedReferenceException`が投げられる


*class Person {public string Name { get; set; }public static bool operator ==(Person lhs, Person rhs) {Console.WriteLine("called ==");return object.ReferenceEquals(lhs, rhs);}public static bool operator !=(Person lhs, Person rhs) {Console.WriteLine("called !=");return !object.ReferenceEquals(lhs, rhs);}}
本当はEqualsとかも実装するべき


*public DateTime End {  get { return Last + TimeSpan.FromTicks(1); } }
!< 期間の最後の次

*if (((object)l == null) || ((object)r == null))
どちらかがnullならfalse
objectでキャストしないと無限ループになるので注意


*Debug.Log(ReferenceEquals(target, null));
Falseと表示される


*public interface ISample {int Hoge();int Fuga(int n);int hogeProp { get; set; }}
モック作成元のインターフェース

*[Test]*public void Returns() {// モックの作成var mockSample = Substitute.For<ISample>();// 戻り値設定mockSample.Hoge().ReturnsForAnyArgs(99);Assert.AreEqual(99, mockSample.Hoge());// 戻り値設定 (特定引数)mockSample.Fuga(0).Returns(99);Assert.AreEqual(99, mockSample.Fuga(0));// 処理呼び出しmockSample.Fuga(2).Returns(n => { Debug.Log("called."); return 0; });mockSample.Fuga(2);// 1回目は10, 2回目は20を返すmockSample.Fuga(1).Returns(10, 20);Assert.AreEqual(10, mockSample.Fuga(1));Assert.AreEqual(20, mockSample.Fuga(1));}
挙動を設定

*var mockSample = Substitute.For<ISample>();
モックの作成

*mockSample.Hoge().ReturnsForAnyArgs(99);
戻り値設定

*mockSample.Fuga(0).Returns(99);
戻り値設定 (特定引数)

*mockSample.Fuga(2).Returns(n => { Debug.Log("called."); return 0; });
処理呼び出し

*mockSample.Fuga(1).Returns(10, 20);
1回目は10, 2回目は20を返す

*[Test]*public void Received() {// モックの作成var mockSample = Substitute.For<ISample>();// 呼び出されたことを確認mockSample.Hoge();mockSample.ReceivedWithAnyArgs().Hoge();// 呼び出されたことを確認  (特定引数)mockSample.Fuga(1);mockSample.Received().Fuga(1);mockSample.DidNotReceive().Fuga(2);// 呼び出された回数確認mockSample.ReceivedWithAnyArgs(1).Fuga(1);mockSample.Fuga(9);mockSample.Fuga(9);mockSample.ReceivedWithAnyArgs(3).Fuga(1);// プロパティが呼び出されたことを確認var dummy = mockSample.DidNotReceive().hogeProp;dummy = mockSample.hogeProp;dummy = mockSample.Received().hogeProp;mockSample.DidNotReceive().hogeProp = 1;mockSample.hogeProp = 1;mockSample.Received().hogeProp = 1;// 呼び出し状態クリアmockSample.ClearReceivedCalls();mockSample.Received(0).Hoge();}
呼び出し結果確認

*var mockSample = Substitute.For<ISample>();
モックの作成

*mockSample.Hoge();
呼び出されたことを確認

*mockSample.Fuga(1);
呼び出されたことを確認  (特定引数)

*mockSample.ReceivedWithAnyArgs(1).Fuga(1);
呼び出された回数確認

*var dummy = mockSample.DidNotReceive().hogeProp;
プロパティが呼び出されたことを確認

*mockSample.ClearReceivedCalls();
呼び出し状態クリア


*Console.WriteLine(outValue);
これはエラーにならない

*}
後述のエラー2


*AppDomain ad = AppDomain.CreateDomain("TEST");
ドメインを生成

*Object instance = ad.CreateInstanceAndUnwrap("ClassLibrary1", "ClassLibrary1.Class1");
インスタンス生成

*instance.test();
DLLのメソッド実行

*AppDomain.Unload(ad);
ドメインを開放

*public string ExecuteName { get; set; }
取込処理名

*public string Arguments { get; set; }
取込処理の引数

*public frmDoWork()*{InitializeComponent();}
コンストラクタ

*private void frmDoWork_Shown(object sender, EventArgs e)*{// アセンブリ名を使ってクラス ライブラリーを動的に読み込みstring baseName = Path.GetFileNameWithoutExtension(ExecuteName);Assembly assembly = Assembly.Load(baseName);_myType = assembly.GetType(baseName + ".Program");_instance = Activator.CreateInstance(_myType);// アセンブリ内のクラスの Update イベントの EventInfo を取得EventInfo eventInfo = _myType.GetEvent("Update");var methodInfo = this.GetType().GetMethod("OnUpdate");Delegate handler = Delegate.CreateDelegate(eventInfo.EventHandlerType, this, methodInfo);// EventInfo に対してイベント ハンドラーを追加eventInfo.AddEventHandler(_instance, handler);// 閉じるボタンを無効にするbtnClose.Enabled = false;// ProgressChangedイベントが発生するようにするbgWorker.WorkerReportsProgress = true;// 処理を開始するbgWorker.RunWorkerAsync();}
画面初回表示時

*string baseName = Path.GetFileNameWithoutExtension(ExecuteName);
アセンブリ名を使ってクラス ライブラリーを動的に読み込み

*EventInfo eventInfo = _myType.GetEvent("Update");
アセンブリ内のクラスの Update イベントの EventInfo を取得

*eventInfo.AddEventHandler(_instance, handler);
EventInfo に対してイベント ハンドラーを追加

*btnClose.Enabled = false;
閉じるボタンを無効にする

*bgWorker.WorkerReportsProgress = true;
ProgressChangedイベントが発生するようにする

*bgWorker.RunWorkerAsync();
処理を開始する

*private void btnClose_Click(object sender, EventArgs e)*{Close();}
画面を閉じる

*private void bgWorker_DoWork(object sender, DoWorkEventArgs e)*{BackgroundWorker bgWorker = (BackgroundWorker)sender;// 処理を開始するint result = (int)_myType.InvokeMember("Main", BindingFlags.InvokeMethod, null, _instance, new object[] { Arguments.Split(',') });// 結果を設定するe.Result = result;}
取込処理

*int result = (int)_myType.InvokeMember("Main", BindingFlags.InvokeMethod, null, _instance, new object[] { Arguments.Split(',') });
処理を開始する

*e.Result = result;
結果を設定する

*private void bgWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)*{// ProgressBarの値を変更するInvoke((Action)delegate (){prbDowork.Value = e.ProgressPercentage;// タイトルのテキストを変更するlblTitle.Text = (e.ProgressPercentage).ToString() + " %";});}
途中経過イベント処理

*Invoke((Action)delegate ()*{prbDowork.Value = e.ProgressPercentage;// タイトルのテキストを変更するlblTitle.Text = (e.ProgressPercentage).ToString() + " %";});
ProgressBarの値を変更する

*lblTitle.Text = (e.ProgressPercentage).ToString() + " %";
タイトルのテキストを変更する

*private void bgWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)*{Invoke((Action)delegate (){if (e.Error != null){// エラーが発生したときlblTitle.Text = "エラー:" + e.Error.Message;}else{// ProgressBarの結果を取得するint result = (int)e.Result;if (result == -1){// エラーで中断したときlblTitle.Text = "処理を中断しました。";}else{// 正常に終了したときprbDowork.Value = prbDowork.Maximum;lblTitle.Text = "完了しました。";}}// 閉じるボタンを有効に戻すbtnClose.Enabled = true;});}
取込処理が終わったときに呼び出される

*lblTitle.Text = "エラー:" + e.Error.Message;
エラーが発生したとき

*int result = (int)e.Result;
ProgressBarの結果を取得する

*lblTitle.Text = "処理を中断しました。";
エラーで中断したとき

*prbDowork.Value = prbDowork.Maximum;
正常に終了したとき

*btnClose.Enabled = true;
閉じるボタンを有効に戻す

*public void OnUpdate(object sender, ProgressChangedEventArgs e)*{// ProgressChangedイベントハンドラを呼び出しbgWorker.ReportProgress(e.ProgressPercentage);}
進捗値の更新

*bgWorker.ReportProgress(e.ProgressPercentage);
ProgressChangedイベントハンドラを呼び出し

*public void Execute(string executeName, string args)*{this.ExecuteName = executeName;this.Arguments = args;this.ShowDialog();}
実行処理

*DialogResult result = MessageBox.Show("実行します。よろしいですか ? ","処理実行",MessageBoxButtons.YesNo,MessageBoxIcon.Question,MessageBoxDefaultButton.Button2);
メッセージボックスを表示する

*AppDomain appDomain = AppDomain.CreateDomain("Domain");
処理実行

*proxy.Execute("SUB00001.dll", "");
実行ファイル名 サンプルなので固定
進捗画面表示

*public Proxy()*{string path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);Assembly asm = Assembly.LoadFile(Path.Combine(path, "DoWork.dll"));Type type = asm.GetType("DoWork.frmDoWork");instance = Activator.CreateInstance(type);}
進捗画面アセンブリのロード

*public void Execute(string executeName, string args)*{instance.Execute(executeName, args);}
進捗画面表示

*public event ProgressChangedEventHandler Update;
更新されると起きるイベント

*SetProgress(100);
完了

*private bool SubProccess10()*{System.Threading.Thread.Sleep(200);SetProgress(10);return true;}
処理10%

*private bool SubProccess30()*{System.Threading.Thread.Sleep(200);SetProgress(30);return true;}
処理30%

*private bool SubProccess50()*{System.Threading.Thread.Sleep(200);SetProgress(50);return true;}
処理50%

*private bool SubProccess70()*{System.Threading.Thread.Sleep(200);SetProgress(70);return true;}
処理70%

*private bool SubProccess90()*{System.Threading.Thread.Sleep(200);SetProgress(90);return true;}
処理90%

*private void SetProgress(int value)*{// 更新イベントを起こすProgressChangedEventArgs e = new ProgressChangedEventArgs(value, null);Update?.Invoke(this, e);}
進捗状況を標準出力に出力する

*ProgressChangedEventArgs e = new ProgressChangedEventArgs(value, null);
更新イベントを起こす


*IEnumerable<string[]> context = TextField.Context(@"C:\うんたらかんたら\KEN_ALL.CSV", ",", Encoding.GetEncoding(932));
郵便番号データのコンテキストを生成

*public static IEnumerable<string[]> Context(string path, string separator = ",", Encoding encoding = null)
指定されたCSVファイルへのコンテキストを生成する


*http:
neue.cc20110917_343.html


*void Update()*{if (Input.GetKey(KeyCode.LeftArrow)){// 左キー(orボタン）が押されている}}
Input時代の書き方

*}
左キー(orボタン）が押されている

*}
左キー(orボタン）が押されている

*}
左キー(orボタン）が押されている


*}
省略

*public System.Windows.Forms.ProgressBar progressBar1;
↓privateからpublicに変更する
private System.Windows.Forms.ProgressBar progressBar1;

*namespace ProgressBarTest*{class BackGroundClass1{private Form1 f1;private Form2 f2;public BackGroundClass1(Form1 f1){this.f1 = f1;this.f2 = new Form2();}public void start(){Thread t = new Thread(new ThreadStart(LongTask));t.IsBackground = true;t.Start();f2.ShowDialog(f1);f2.Dispose();}private void LongTask(){//ここにすっげー時間かかる処理を書く想定for (int i = 0; i <= 100; i++){Thread.Sleep(100);f2.BeginInvoke(new UpdateProgressBarDelegate(UpdateProgressBar), new object[] { i });}}private delegate void UpdateProgressBarDelegate(int val);private void UpdateProgressBar(int val){f2.progressBar1.Value = val;if (val >= 100){f2.Close();}}}}
using System.Windows.Forms;


*string[] cmds = System.Environment.GetCommandLineArgs();
コマンドライン引数を配列で取得する


*string loadText = await model.LoadedText;
ReactivePropertyの変更を待つ


*using System.Collections.Generic;
for List<>


*Console.WriteLine(sum);
1060

*if (n == 1) return false;*if (n == 2) return true;
素数かどうか判定する <- みたいなコメントがいる。(IsPrime なら自明)

*var count = numbers.Count(n => IsPrime(n));
素数だけをカウント

*bool isAllPrime = numbers.All(n => IsPrime(n));
すべて素数か？

*bool containsPrime = numbers.Any(n => IsPrime(n));
素数が混じっているか？

*int max = numbers.Where(n => IsPrime(n)).Max();
最大の素数

*int first = numbers.First(n => IsPrime(n))
数列中に最初に現れる素数

*IEnumerable<int> PrimeGen() {int n = 1;while (true) {if (IsPrime(n)) yield return n;n++;}}
無限に素数を返すイテレータ

*,,,
素数を5個取り出す
var primes = PrimeGen().Take(5);  => 2, 3, 5, 7, 11 のシーケンス


*data.Rows.Add(add);
add.RowState:DataRowState.Added

*Console.WriteLine("--------------------");
修正
var mod = data.Rows[0];      mod.RowState:DataRowState.Unchanged
mod["ID"] = 9;               mod.RowState:DataRowState.Modified
削除
・削除された行として存在する。
var del = data.Rows[1];     del.RowState:DataRowState.Unchanged
del.Delete();               del.RowState:DataRowState.Deleted
除外
・DataTableから除外される。
・data.RejectChanges();しても、dataから除外されたままになる。
var rmv = data.Rows[2];     rmv.RowState:DataRowState.Unchanged
data.Rows.Remove(rmv);      rmv.RowState:DataRowState.Detached

*// →DataRowVersion.Original を付けて、削除前の状態の値を取得する。*Console.WriteLine($"ID:{row["ID", DataRowVersion.Original]},RowState={row.RowState}");
削除された行の値をアクセスしようとする例外が発生する。

*Console.WriteLine($"ID:{row["ID", DataRowVersion.Original]},RowState={row.RowState}");
→DataRowVersion.Original を付けて、削除前の状態の値を取得する。


*Thread.Sleep((3 + count) * 1000);
It will change the end time for the concurrently started thread.

*semaphore.Release(3);*Console.WriteLine($"{semaphore.CurrentCount} tasks can enter the semaphore.");
increase avairable Semaphore


*private const string ENDPOINT = "https:
api.cognitive.microsofttranslator.com";

*var languages = Enum.GetNames(typeof(Language));
ドロップダウンメニュー作成

*fromLanguageDd.OnValueChangedAsObservable()*.Subscribe(value => { fromLanguage = (Language) value; })
翻訳元言語

*toLanguageDd.OnValueChangedAsObservable()*.Subscribe(value => { toLanguage = (Language) value; })
翻訳後言語

*translateButton.OnClickAsObservable()
翻訳ボタン押下

*var result = GetTranslation(fromLanguage, toLanguage, inputField.text, token);
結果が送られてくるまで待ってから表示

*var requestInfo = "translate?api-version=3.0";*requestInfo += $"&from={from}&to={to}";
POSTメソッドのリクエストを作成

*var speechData = new SpeechData {Text = speechText};
リクエストに使用するJSON作成

*request.SetRequestHeader("Ocp-Apim-Subscription-Region", LOCATION);
ヘッダーに必要な情報を追加

*var second = TimeSpan.FromSeconds(3);
結果受け取り

*var languages = Enum.GetNames(typeof(Language));
ドロップダウンメニュー作成

*fromLanguageDd.OnValueChangedAsObservable()*.Subscribe(value => { fromLanguage = (Language) value; })
翻訳元言語

*toLanguageDd.OnValueChangedAsObservable()*.Subscribe(value => { toLanguage = (Language) value; })
翻訳後言語


*Hello.CallMe(namePtr, respPtr);
呼び出し


*public static Vector2 Get(OVRInput.Axis2D virtualMask, OVRInput.Controller controllerMask = OVRInput.Controller.Active){return GvrControllerInput.GetDevice(GvrControllerHand.Dominant).TouchPos;
このメソッドと入れ替える

*ReplaceMethod(typeof(OVRInput), typeof(OVRInputEmulator), "Get", new System.Type[] { typeof(OVRInput.Axis2D), typeof(OVRInput.Controller) });
タッチパッド上の座標


*options.UseNpgsql(
<= この部分は使うＤＢに合わせてください

*public static async Task Initialize(IServiceProvider serviceProvider)
初期化時のロール
public static readonly string SystemManagerRole = "SystemManager";       システム管理権限
public static readonly string GroupManagerRole = "GroupManager";         グループ管理権限
初期化時のシステム管理ユーザーID
public static readonly string SystemUserName = "system";     最初のシステム管理ユーザーのメールアドレス
public static readonly string SystemManageEmail = "system@test.com";     最初のシステム管理ユーザーのメールアドレス
public static readonly string SystemManagePassword = "!initialPassword01";     最初のシステム管理ユーザーの初期パスワード
初期化時のグループ管理ユーザーID
public static readonly string GroupUserName = "groupuser";     最初のグループ管理ユーザーのメールアドレス
public static readonly string GroupUserEmail = "groupuser@test.com";     最初のグループ管理ユーザーのメールアドレス
public static readonly string GroupUserPassword = "!initialPassword02";     最初のグループ管理ユーザーの初期パスワード

*var userManager = serviceProvider.GetService<UserManager<IdentityUser>>();
ユーザー管理を取得(using Microsoft.Extensions.DependencyInjectionがないとエラーになる)

*var systemManager = await userManager.FindByNameAsync(SystemUserName);
初期のユーザーマネージャーが存在しなければロールの作成と初期システムユーザーを作成する

*var roleManager = serviceProvider.GetService<RoleManager<IdentityRole>>();
ロール管理を取得

*systemManager = new IdentityUser { UserName = SystemUserName, Email = SystemManageEmail };
ロールの追加
await roleManager.CreateAsync(new IdentityRole(SystemManagerRole));     システム管理ロール
await roleManager.CreateAsync(new IdentityRole(GroupManagerRole));     グループ管理ロール
初期システム管理者の作成

*systemManager = await userManager.FindByNameAsync(SystemUserName);
システム管理ユーザーにシステム管理ロールを追加

*var groupUser = new IdentityUser { UserName = GroupUserName, Email = GroupUserEmail };
グループユーザーの作成

*groupUser = await userManager.FindByNameAsync(GroupUserName);
グループユーザーにグループユーザーロールを追加

*var host = CreateHostBuilder(args).Build();
CreateHostBuilder(args).Build().Run(); <= もともとこの1行のみ

*var services = scope.ServiceProvider;
サービスプロバイダーの取得

*var context = services.GetRequiredService<ApplicationDbContext>();
データベースの自動マイグレーション

*UserRollInitialize.Initialize(services).Wait();
初期のユーザーとロールの作成

*[Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)][ApiController][Route("[controller]/[action]")]public class AuthController : ControllerBase{設定管理オブジェクトIConfiguration _config;
[Authorize]

*IConfiguration _config;
設定管理オブジェクト

*SignInManager<IdentityUser> _signInManager =null;
サインインマネージャー（DefaultIdenityを利用している）

*public AuthController(SignInManager<IdentityUser> signInManager, IConfiguration config, UserManager<IdentityUser> userManage)
コンストラクタ
サインインマネージャーとコンフィグ管理のオブジェクトをＤＩ

*[HttpPost]
ログイン処理

*var result = await _signInManager.PasswordSignInAsync(request.userId, request.password, false, false);
ASP.Net core のdDefaultIdentityを利用してIDとパスワードの確認

*return Ok(new { token = await BuildToken(request) });
ログイン成功でおJWTトークンを返す

*[HttpPost]
ログアウト処理

*private async Task<string> BuildToken(LoginRequest request)*{var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config["Jwt:Key"]));var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);var user = await _userManage.FindByNameAsync(request.userId);var principal = await _signInManager.CreateUserPrincipalAsync(user);var roles = await _userManage.GetRolesAsync(user);var claims = new List<Claim>(principal.Claims);claims.Add(new Claim(JwtRegisteredClaimNames.Sub, user.UserName));claims.Add(new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()));foreach(var role in roles){claims.Add(new Claim(ClaimTypes.Role, role));}var token = new JwtSecurityToken(issuer: _config["Jwt:Issuer"],audience: _config["Jwt:Issuer"],expires: DateTime.Now.AddMinutes(30),signingCredentials: creds,claims: claims);var tmp = new JwtSecurityTokenHandler().WriteToken(token);return tmp;}
JWTトークンの作成

*[HttpPost]
テスト用

*options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
JWT Bearer をデフォルトにする


*this[index] = new T();
初期値

*public virtual IEnumerable<int> GetAllIndexes() {for (int y = 1; y <= this.YSize; y++) {for (int x = 1; x <= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する

*public virtual IEnumerable<int> EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index) && this[index] != null; index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Horizontal(int x, int y)
(x,y)から右(水平)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Virtical(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantR(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantL(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む

*public Board(Board board) : base(board) {}
コピーコンストラクタ

*public void Put(int place) {this[place] = Piece.Queen;}
駒を置く

*public void Clear(int place) {this[place] = Piece.Empty;}
指定した位置から駒を取り去る

*public bool CanPut(int place) {if (this[place] != Piece.Empty)return false;if (Courses(place).Any(p => this[p] == Piece.Queen))return false;return true;}
引数で与えた位置に駒を置けるか

*public IEnumerable<int> Courses(int index) {
与えられた位置の右、下、ななめ右下、ななめ左下の位置を
それぞれぐるっと一回転するまで列挙する。
ただし、与えられた位置は除く。

*public IEnumerable<int> Oblique(int x, int y) {for (int i = 0; i < _width; i++) {x += 1;y -= 1;if (x > _width)x = 1;if (y == 0)y = _width;yield return ToIndex(x, y);}}
左下がりの斜線の各位置を列挙する

*public IEnumerable<int> BackOblique(int x, int y) {for (int i = 0; i < _width; i++) {x += 1;y += 1;if (x > _width)x = 1;if (y > _width)y = 1;yield return ToIndex(x, y);}}
右下がりの斜線の各位置を列挙する

*private IEnumerable<Board> SolveInner(Board board, int y) {if (y > board.YSize) {yield return new Board(board);yield break;}foreach (int pos in board.Horizontal(1, y)) {if (board.CanPut(pos)) {board.Put(pos);foreach (var b in SolveInner(board, y + 1))yield return b;board.Clear(pos);}}}
y行よりも下に置く駒を求める － 鏡像、回転を除くことは考慮していない


*Console.WriteLine($"整形={d.ToString("yyyy年MM月dd日")}");
<------ MM だけ大文字だ


*var sut = new ColorConverter();
sut means `System under test`


*else*{// diff が startVec より左側 *または* diff が endVec より右側の時if (GetCross2d(startVec, diff) >= 0 || GetCross2d(endVec, diff) <= 0){return true;}return false;}
扇型の角度が180度以上の場合

*using Assert = UnityEngine.Assertions.Assert;
AssertはNUnitのではなくUnityのものを使う

*else*{// diff が startVec より左側 *または* diff が endVec より右側の時if (GetCross2d(startVec, diff) >= 0 || GetCross2d(endVec, diff) <= 0){return true;}return false;}
扇型の角度が180度以上の場合


*var listRequest = service.Files.List();
フォルダ「HogeFolder」下のファイル一覧を取得する
リクエストパラメータの定義
service(DriveService)はユーザ認証部分なので割愛

*listRequest.Q = "(name = 'HogeFolder') and (mimeType = 'application/vnd.google-apps.folder') and (trashed = false)";
取得するフォルダの条件をクエリ構文で指定

*var folderId = listRequest.Execute().Files.First().Id;
フォルダIDの取得

*// '{folderId}' in parentsにより、フォルダ「HogeFolder」下にあるファイルとフォルダのみが対象となる
フォルダ「HogeFolder」下のファイルの条件をクエリ構文で指定

*listRequest.Q = $"('{folderId}' in parents) and (mimeType != 'application/vnd.google-apps.folder') and (trashed = false)";
'{folderId}' in parentsにより、フォルダ「HogeFolder」下にあるファイルとフォルダのみが対象となる

*var files = listRequest.Execute().Files;
ファイル一覧の取得

*var id = files.First().Id;
一番最初にとれたファイルのIDを取得する

*string saveTo = "HogeFolder";
保存するファイル先を指定する

*var request = service.Files.Get(id);
ファイルをダウンロードする


*await sharedDictionary.LoadFromStorageAsync();
Storageに保存されている設定を読み込む

*sharedDictionary.SetProperty("text", "sssss");
もちろん基本データ型の保存はできて

*sharedDictionary.SetProperty("data", new Data());
Utf8JsonまたはSpanJsonによって、ユーザー定義型の保存もできる

*await sharedDictionary.SaveToStorageAsync();
Storageに書き込む

*string text = sharedDictionary.GetProperty<string>("text");
設定を読み込む


*public string ExecuteName { get;  set; }
取込処理名

*public string Arguments { get; set; }
取込処理の引数

*private Type _myType = null;
動的DLL処理用

*public frmDoWork()*{InitializeComponent();}
コンストラクタ

*private void frmDoWork_Load(object sender, EventArgs e)*{// アセンブリ名を使ってクラス ライブラリーを動的に読み込みstring baseName = Path.GetFileNameWithoutExtension(ExecuteName);Assembly assembly = Assembly.Load(baseName);_myType = assembly.GetType(baseName + ".Program");_instance = Activator.CreateInstance(_myType);// アセンブリ内のクラスの Update イベントの EventInfo を取得EventInfo eventInfo = _myType.GetEvent("Update");var methodInfo = this.GetType().GetMethod("OnUpdate");Delegate handler = Delegate.CreateDelegate(eventInfo.EventHandlerType, this, methodInfo);// EventInfo に対してイベント ハンドラーを追加eventInfo.AddEventHandler(_instance, handler);}
画面ロード時

*string baseName = Path.GetFileNameWithoutExtension(ExecuteName);
アセンブリ名を使ってクラス ライブラリーを動的に読み込み

*EventInfo eventInfo = _myType.GetEvent("Update");
アセンブリ内のクラスの Update イベントの EventInfo を取得

*eventInfo.AddEventHandler(_instance, handler);
EventInfo に対してイベント ハンドラーを追加

*private void frmDoWork_Shown(object sender, EventArgs e)*{// 閉じるボタンを無効にするbtnClose.Enabled = false;// ProgressChangedイベントが発生するようにするbgWorker.WorkerReportsProgress = true;// 処理を開始するbgWorker.RunWorkerAsync();}
画面初回表示時

*btnClose.Enabled = false;
閉じるボタンを無効にする

*bgWorker.WorkerReportsProgress = true;
ProgressChangedイベントが発生するようにする

*bgWorker.RunWorkerAsync();
処理を開始する

*private void btnClose_Click(object sender, EventArgs e)*{Close();}
画面を閉じる

*private void bgWorker_DoWork(object sender, DoWorkEventArgs e)*{BackgroundWorker bgWorker = (BackgroundWorker)sender;// 処理を開始するint result = (int)_myType.InvokeMember("Main", BindingFlags.InvokeMethod, null, _instance, new object[] { Arguments });// 結果を設定するe.Result = result;}
取込処理

*int result = (int)_myType.InvokeMember("Main", BindingFlags.InvokeMethod, null, _instance, new object[] { Arguments });
処理を開始する

*e.Result = result;
結果を設定する

*private void bgWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)*{// ProgressBarの値を変更するprbDowork.Value = e.ProgressPercentage;// タイトルのテキストを変更するlblTitle.Text = (e.ProgressPercentage).ToString() + " %";}
途中経過イベント処理

*prbDowork.Value = e.ProgressPercentage;
ProgressBarの値を変更する

*lblTitle.Text = (e.ProgressPercentage).ToString() + " %";
タイトルのテキストを変更する

*private void bgWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)*{if (e.Error != null){// エラーが発生したときlblTitle.Text = "エラー:" + e.Error.Message;}else{// ProgressBarの結果を取得するint result = (int)e.Result;if(result == -1){// エラーで中断したときlblTitle.Text = "処理を中断しました。";}else{// 正常に終了したときprbDowork.Value = prbDowork.Maximum;lblTitle.Text = "完了しました。";}}// 閉じるボタンを有効に戻すbtnClose.Enabled = true;}
取込処理が終わったときに呼び出される

*lblTitle.Text = "エラー:" + e.Error.Message;
エラーが発生したとき

*int result = (int)e.Result;
ProgressBarの結果を取得する

*lblTitle.Text = "処理を中断しました。";
エラーで中断したとき

*prbDowork.Value = prbDowork.Maximum;
正常に終了したとき

*btnClose.Enabled = true;
閉じるボタンを有効に戻す

*public void OnUpdate(object sender, EventArgs e)*{PropertyInfo prop_value = e.GetType().GetProperty("value");int percentage = Convert.ToInt32(prop_value.GetValue(e, null));// ProgressChangedイベントハンドラを呼び出しbgWorker.ReportProgress(percentage);}
進捗値の更新

*bgWorker.ReportProgress(percentage);
ProgressChangedイベントハンドラを呼び出し

*DialogResult result = MessageBox.Show("実行します。よろしいですか ? ","処理実行",MessageBoxButtons.YesNo,MessageBoxIcon.Question,MessageBoxDefaultButton.Button2);
メッセージボックスを表示する

*frmDoWork frm = new frmDoWork();
処理実行

*frm.ExecuteName = "SUB00001.dll";
実行ファイル名 サンプルなので固定

*frm.ShowDialog();
進捗画面表示

*public event EventHandler Update;
更新されると起きるイベント

*SetProgress(100);
完了

*private bool SubProccess10()*{System.Threading.Thread.Sleep(200);SetProgress(10);return true;}
処理10%

*private bool SubProccess30()*{System.Threading.Thread.Sleep(200);SetProgress(30);return true;}
処理30%

*private bool SubProccess50()*{System.Threading.Thread.Sleep(200);SetProgress(50);return true;}
処理50%

*private bool SubProccess70()*{System.Threading.Thread.Sleep(200);SetProgress(70);return true;}
処理70%

*private bool SubProccess90()*{System.Threading.Thread.Sleep(200);SetProgress(90);return true;}
処理90%

*private void SetProgress(int value)*{// 更新イベントを起こすUpdateEventArgs e = new UpdateEventArgs();e.value = value;Update?.Invoke(this, e);}
進捗状況を標準出力に出力する

*UpdateEventArgs e = new UpdateEventArgs();
更新イベントを起こす


*System.Drawing.Rectangle rect = new System.Drawing.Rectangle((int)this.Left, (int)this.Top, (int)this.Width, (int)this.Height);
自身のウィンドウを囲む長方形を定義，thisはGUIアプリのクラス

*System.Windows.Forms.Screen screenData = System.Windows.Forms.Screen.FromRectangle(rect);
長方形のある（ウィンドウのある）ディスプレイのスクリーン情報を取得

*int screenHeight = screenData.WorkingArea.Height;
縦と横の解像度を取得

*scaleX = source.CompositionTarget.TransformToDevice.M11;*scaleY = source.CompositionTarget.TransformToDevice.M22;
ここでDPIの係数を取得

*this.Height = (double)screenHeight / scaleY;
サイズを画面の縦サイズと同じにする


*GetMousePoint( &MouseX, &MouseY ) ;
マウスカーソルの座標を取得

*PrevInput = NowInput ;
マウスボタンの入力状態を更新

*if( EdgeInput & MOUSE_INPUT_1 )
掴んでいない場合
左クリックされたらモデルをクリックしたかを調べる

*ScreenPos1.x = ( float )MouseX ;
モデルとの当たり判定用の線分の２座標を作成

*MV1RefreshCollInfo( ModelHandle, -1 ) ;
モデルの当たり判定情報を更新

*MV1_COLL_RESULT_POLY Result = MV1CollCheck_Line( ModelHandle, -1, WorldPos1, WorldPos2 ) ;
モデルと線分の当たり判定

*Catch = 1 ;
掴んでいるかどうかのフラグを立てる

*CatchMouseX = MouseX ;
掴んだときのスクリーン座標を保存

*Catch3DModelPosition = MV1GetPosition( ModelHandle ) ;
掴んだときのモデルのワールド座標を保存

*Catch3DHitPosition = Result.HitPosition ;
掴んだときのモデルと線分が当たった座標を保存( 座標をスクリーン座標に変換したものも保存しておく )


*Debug.Log("Out" + Uncode.posData);
JSONをJSONWriteクラスに変換した結果を出力


*Console.WriteLine("items[1][0]:" + items1[1][0]);
items[1][0]:-

*hoges.RemoveAll(b => b < 5);
RemoveAllメソッドを使った場合


*DateTime dt = DateTime.Now;
今日の日付、現在の時刻を取得する


*env.ConfigureNLog("nlog.config");
～略～
NLogを使う設定を宣言し

*Trace.Listeners.Add(new NLogTraceListener()*{IndentSize = 4,Name = "MyNLogTraceListener",});
さらにNLogに流し込むListenerを追加することをでTrace.Xxxxでの出力がNLog設定で書き出される

*Trace.TraceInformation("Appcation Start!");*}
本来もっと前に記録したいところだけど記述準的にここで初めてTraceをNLogに流し込めるようになるのでここでAppStartログ

*public static class ExceptionHelper*{public static string ExtractException(this Exception ex, int indent = 2){var indentStr = new String(' ',indent);StringBuilder traceLog = new StringBuilder();StackTrace trace = new StackTrace(ex, true);foreach (var frame in trace.GetFrames()){traceLog.AppendLine($"{indentStr}File Name : {frame.GetFileName()}");traceLog.AppendLine($"{indentStr}Class Name : {frame.GetMethod().ReflectedType.Name}");traceLog.AppendLine($"{indentStr}Method Name : {frame.GetMethod()}");traceLog.AppendLine($"{indentStr}Line Number : {frame.GetFileLineNumber()}");traceLog.AppendLine($"=======================================================");}return traceLog.ToString();}}
https:teratail.com/questions/24669


*services.AddTransient<IOtherClient>(client =>{return new OtherClient();
Registration with Function

*var someClient1 = provider.GetRequiredService<ISomeClient>();*Console.WriteLine($"SomeClient1(Singleton): Type: {someClient1.GetType()} Id: {someClient1.Id}");
Singleton

*var otherClient1 = provider.GetService<IOtherClient>();*Console.WriteLine($"OtherClient1(Transient): Type: {otherClient1.GetType()} Id: {otherClient1.Id}");
Transient

*services.Configure<SomeOption>(o => new SomeOption{Value1 = "Hello",Value2 = "World"});
Register Option value object

*services.AddSingleton<SomeClient>(serviceProvider =>{var options = serviceProvider.GetRequiredService<IOptions<SomeOption>>();
Options


*private bool isPassing = false;
trueの場合すでに探索済みfalseなら未探索


*}
出力:
1
2
3

*[Test]*public void Test2 ([Values]bool b) {Debug.Log (b);// 出力:// True// False}
boolの場合、Valuesの引数は省略できる

*}
出力:
True
False

*[Test]*public void Test3 ([Values (1, 2)]int i, [Values(-2, -4)]int j) {Debug.Log (i + "," + j);// 出力:// 1, -2// 1, -4// 2, -2// 2, -4}
複数の引数にValuesをつけた場合、組み合わせてテストケースを作成する

*}
出力:
1, -2
1, -4
2, -2
2, -4

*// static int[] testValues {//   get {//     return new [] { 1, 2, 3 };//   }// }
こっちでも通る

*//   get {//     return new [] { 1, 2, 3 };//   }
static int[] testValues {

*//     return new [] { 1, 2, 3 };
get {

*// こっちでも通る*// static int[] testValues () {//   return new [] { 1, 2, 3 };// }
}

*// static int[] testValues () {//   return new [] { 1, 2, 3 };// }
こっちでも通る

*//   return new [] { 1, 2, 3 };
static int[] testValues () {

*[Test]*public void Test ([ValueSource ("testValues")]int i) {Debug.Log (i);}
}

*}
出力:
1,3,3
2,2,1
3,3,3

*// static int[][] testCases {//   get {//     return new[] {//       new [] { 1, 3, 3 },//       new [] { 2, 2, 1 },//       new [] { 3, 3, 3 }//     };//   }// }
こっちでも通る

*//   get {//     return new[] {//       new [] { 1, 3, 3 },//       new [] { 2, 2, 1 },//       new [] { 3, 3, 3 }//     };//   }
static int[][] testCases {

*//     return new[] {//       new [] { 1, 3, 3 },//       new [] { 2, 2, 1 },//       new [] { 3, 3, 3 }//     };
get {

*//       new [] { 1, 3, 3 },
return new[] {

*//       new [] { 2, 2, 1 },
new [] { 1, 3, 3 },

*//       new [] { 3, 3, 3 }
new [] { 2, 2, 1 },

*// こっちでも通る*// static int[][] testCases () {//   return new[] {//     new [] { 1, 3, 3 },//     new [] { 2, 2, 1 },//     new [] { 3, 3, 3 }//   };// }
}

*// static int[][] testCases () {//   return new[] {//     new [] { 1, 3, 3 },//     new [] { 2, 2, 1 },//     new [] { 3, 3, 3 }//   };// }
こっちでも通る

*//   return new[] {//     new [] { 1, 3, 3 },//     new [] { 2, 2, 1 },//     new [] { 3, 3, 3 }//   };
static int[][] testCases () {

*//     new [] { 1, 3, 3 },
return new[] {

*//     new [] { 2, 2, 1 },
new [] { 1, 3, 3 },

*//     new [] { 3, 3, 3 }
new [] { 2, 2, 1 },

*[Test, TestCaseSource ("testCases")]*public void Test (int i, int j, int k) {Debug.Log (i + ", " + j + ", " + k);// 出力:// 1,3,3// 2,2,1// 3,3,3}
}

*}
出力:
1,3,3
2,2,1
3,3,3

*[Test]*public void Test1 ([NUnit.Framework.Range (3, 7)]int i) {Debug.Log (i);// 出力:// 3// 4// 5// 6// 7}
3 ~ 7 の値で順にテストする

*}
出力:
3
4
5
6
7

*[Test]*public void Test2 ([NUnit.Framework.Range (3, 7, 3)]int i) {Debug.Log (i);// 出力:// 3// 6}
3 ~ 7 の値で3飛ばしにテストする

*}
出力:
3
6

*[Test]*public void Test1 ([Random (3)]int i) {Debug.Log (i);}
ランダムな値で3回テストする

*[Test]*public void Test2 ([Random (-10, 10, 3)]int i) {Debug.Log (i);}
-10 ~ 10 のランダムな値で3回テストする

*[Test, Combinatorial]*public void Test1 ([Values (1, 2, 3)]int i, [Values(-2, -4)]int j, [Values ("A", "B", "C")]string s) {Debug.Log (i + "," + j + "," + s);// 出力:// 1,-2,A// 1,-2,B// 1,-2,C// 1,-4,A// 中略// 3,-4,C}
全18パターンの組み合わせでテストする

*}
出力:
1,-2,A
1,-2,B
1,-2,C
1,-4,A
中略
3,-4,C

*[Test, Sequential]*public void Test2 ([Values (1, 2, 3)]int i, [Values(-2, -4)]int j, [Values ("A", "B", "C")]string s) {Debug.Log (i + "," + j + "," + s);// 出力:// 1,-2,A// 2,-4,B// 3,0,C}
全3パターンの組み合わせでテストする

*}
出力:
1,-2,A
2,-4,B
3,0,C

*[Test, Pairwise]*public void Test3 ([Values (1, 2, 3)]int i, [Values(-2, -4)]int j, [Values ("A", "B", "C")]string s) {Debug.Log (i + "," + j + "," + s);// 出力:// 1,-2,A// 1,-4,C// 1,-4,B// 2,-2,B// 中略// 3,-4,A}
全9パターンの組み合わせでテストする

*}
出力:
1,-2,A
1,-4,C
1,-4,B
2,-2,B
中略
3,-4,A

*[TestTest, Timeout (1000)]*public void Test1 () {yield return new WaitForSeconds (1.5f);Debug.Log ("テストは失敗し、何も出力されない");}
指定する時間はミリ秒

*[Test, MaxTime (1000)]*public IEnumerator Test2 () {yield return new WaitForSeconds (1.5f);Debug.Log ("テストは失敗するが、このログは出力される");}
指定する時間はミリ秒

*Assert.Greater (i % 10, 2);
一桁目が2より大きくないと許さない


*public string Get(string valueString)*{}
GET api/Values/email@address.com


*outputArray.AddRange(new float[21125]);
125×13×13


*ERROR2 = 2,
エラー 2


*.Memoize()
キャッシュ


*public string ExecuteName { get;  set; }
取込処理名

*public string Arguments { get; set; }
取込処理の引数

*private Process _proc = null;
プロセス処理用

*public frmDoWork()*{InitializeComponent();}
コンストラクタ

*private void frmDoWork_Load(object sender, EventArgs e)*{// 取込処理の準備_proc = new Process();// プロセスの実行名をセット_proc.StartInfo.FileName = ExecuteName;// プロセスの引数をセット_proc.StartInfo.Arguments = Arguments;// ウィンドウを表示しないようにする_proc.StartInfo.CreateNoWindow = true;//入力できるようにする_proc.StartInfo.UseShellExecute = false;_proc.StartInfo.RedirectStandardInput = true;//非同期で出力を読み取れるようにする_proc.StartInfo.RedirectStandardOutput = true;_proc.OutputDataReceived += proc_OutputDataReceived;}
画面ロード時

*_proc = new Process();
取込処理の準備

*_proc.StartInfo.FileName = ExecuteName;
プロセスの実行名をセット

*_proc.StartInfo.Arguments = Arguments;
プロセスの引数をセット

*_proc.StartInfo.CreateNoWindow = true;
ウィンドウを表示しないようにする

*_proc.StartInfo.UseShellExecute = false;
入力できるようにする

*_proc.StartInfo.RedirectStandardOutput = true;
非同期で出力を読み取れるようにする

*private void frmDoWork_Shown(object sender, EventArgs e)*{// 閉じるボタンを無効にするbtnClose.Enabled = false;// ProgressChangedイベントが発生するようにするbgWorker.WorkerReportsProgress = true;// 処理を開始するbgWorker.RunWorkerAsync();}
画面初回表示時

*btnClose.Enabled = false;
閉じるボタンを無効にする

*bgWorker.WorkerReportsProgress = true;
ProgressChangedイベントが発生するようにする

*bgWorker.RunWorkerAsync();
処理を開始する

*private void btnClose_Click(object sender, EventArgs e)*{Close();}
画面を閉じる

*private void proc_OutputDataReceived(object sender, DataReceivedEventArgs e)*{if (e.Data == null) return;Regex regex = new Regex(@"進捗 (\d.)%");Match match = regex.Match(e.Data);if(match.Groups.Count > 1){int percentage = int.Parse(match.Groups[1].Value);// ProgressChangedイベントハンドラを呼び出しbgWorker.ReportProgress(percentage);}}
行が出力されるたびに呼び出される

*bgWorker.ReportProgress(percentage);
ProgressChangedイベントハンドラを呼び出し

*private void bgWorker_DoWork(object sender, DoWorkEventArgs e)*{BackgroundWorker bgWorker = (BackgroundWorker)sender;// 処理を開始する_proc.Start();// 非同期で出力の読み取りを開始する_proc.BeginOutputReadLine();_proc.WaitForExit();// 結果を設定するe.Result = _proc.ExitCode;}
取込処理

*_proc.Start();
処理を開始する

*_proc.BeginOutputReadLine();
非同期で出力の読み取りを開始する

*e.Result = _proc.ExitCode;
結果を設定する

*private void bgWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)*{// ProgressBarの値を変更するprbDowork.Value = e.ProgressPercentage;// タイトルのテキストを変更するlblTitle.Text = (e.ProgressPercentage).ToString() + " %";}
途中経過イベント処理

*prbDowork.Value = e.ProgressPercentage;
ProgressBarの値を変更する

*lblTitle.Text = (e.ProgressPercentage).ToString() + " %";
タイトルのテキストを変更する

*private void bgWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)*{if (e.Error != null){// エラーが発生したときlblTitle.Text = "エラー:" + e.Error.Message;}else{// ProgressBarの結果を取得するint result = (int)e.Result;if(result == -1){// エラーで中断したときlblTitle.Text = "処理を中断しました。";}else{// 正常に終了したときprbDowork.Value = prbDowork.Maximum;lblTitle.Text = "完了しました。";}}// 閉じるボタンを有効に戻すbtnClose.Enabled = true;}
取込処理が終わったときに呼び出される

*lblTitle.Text = "エラー:" + e.Error.Message;
エラーが発生したとき

*int result = (int)e.Result;
ProgressBarの結果を取得する

*lblTitle.Text = "処理を中断しました。";
エラーで中断したとき

*prbDowork.Value = prbDowork.Maximum;
正常に終了したとき

*btnClose.Enabled = true;
閉じるボタンを有効に戻す

*DialogResult result = MessageBox.Show("実行します。よろしいですか ? ","処理実行",MessageBoxButtons.YesNo,MessageBoxIcon.Question,MessageBoxDefaultButton.Button2);
メッセージボックスを表示する

*frmDoWork frm = new frmDoWork();
処理実行

*frm.ExecuteName = "SUB00001.exe";
実行ファイル名 サンプルなので固定

*frm.ShowDialog();
進捗画面表示

*SetProgress(100);
完了

*static bool SubProccess10()*{System.Threading.Thread.Sleep(200);SetProgress(10);return true;}
処理10%

*static bool SubProccess30()*{System.Threading.Thread.Sleep(200);SetProgress(30);return true;}
処理30%

*static bool SubProccess50()*{System.Threading.Thread.Sleep(200);SetProgress(50);return true;}
処理50%

*static bool SubProccess70()*{System.Threading.Thread.Sleep(200);SetProgress(70);return true;}
処理70%

*static bool SubProccess90()*{System.Threading.Thread.Sleep(200);SetProgress(90);return true;}
処理90%

*static void SetProgress(int value)*{Console.WriteLine(string.Format("進捗 {0}%", value));}
進捗状況を標準出力に出力する


*string[] deviceIds = command.GetDeviceIds();*if (deviceIds.Length == 0) { return; }
接続されているデバイスIDを取得する

*string targetDeviceId = String.Empty;
RICOH THETA V デバイスを取得する

*command.Close();
デバイスよさようなら

*{MtpOperationCode.OpenSession,          DataPhase.NoDataPhase},
データフェーズのないオペレーション

*{MtpOperationCode.GetDeviceInfo,            DataPhase.DataReadPhase},
R->Iのデータフェーズがあるオペレーション

*{MtpOperationCode.SetDevicePropValue,       DataPhase.DataWritePhase},
I->Rのデータフェーズがあるオペレーション

*string[] deviceIds = command.GetDeviceIds();*if (deviceIds.Length == 0) { return; }
接続されているデバイスIDを取得する

*string targetDeviceId = String.Empty;
RICOH THETA V デバイスを取得する

*command.MtpEvent += MtpEventListener;
イベントを受け取れるようにする

*command.Close();
デバイスよさようなら


*@"http:
schemas.microsoft.commapiproptag0x39FE001E";

*if (sender.AddressEntryUserType ==*Outlook.OlAddressEntryUserType.
Now we have an AddressEntry representing the Sender

*Outlook.ExchangeUser exchUser =sender.GetExchangeUser();
Use the ExchangeUser object PrimarySMTPAddress


*mres.Set();
ServiceAsync関数側に通知します。


*yield return mes1;
イテレータ (反復子)

*Console.WriteLine(CEN_FLG_YN.ARI);
個々に表示する

*CMessage mes = new CMessage();
New()を使用するタイプ


*DateTimeOffset localTime = DateTimeOffset.Now;
UTC+XをTimeSpan型にする（今回はUTC-4）
TimeSpan userOffset = new TimeSpan(-4, 0, 0);  時、分、秒
今のローカル時間（日本時間）を取得
ここでDateTimeOffsetを使うのは、
DateTimeだと時差情報がオブジェクトに含まれていないため

*DateTimeOffset utcTime = new DateTimeOffset(localTime.UtcDateTime, TimeSpan.Zero);
一度UTC（標準時間）に変換する
UtcDateTimeプロパティではDateTimeが取得されるため、またDateTimeOffsetにする

*DateTime targetTime = utcTime.ToOffset(userOffset);
取得したUTCから時差の分ずらす

*Console.Write(targetTime.ToString("yyyy/MM/dd HH:mm:ss"));
表示


*str = instance.Name;
なにかさせる


*var fm = this[dest] as Footmark;
fm が null なら PGミス

*public int MovableCount(int place) {return Destinations(place).Count(ix => this[ix] == Piece.Empty);}
騎士が移動可能な場所の数

*private static int[] _blockA = new int[] { 28, 29, 40, 41, 50, 51, 52, 53, 62, 63, 64, 65, 26, 27, 38, 39, };
４つのブロックの座標(インデックス）を設定。
ここだけが番兵の存在に依存している。かなり力業だが...
4隅(4マス)の座標は、各配列の最後に格納する。

*// ひとつのブロックには、最大でも４つのKnightを配置すれば条件を満たせるはず。*private void _Solve(Chessboard board, int level, int nowpos, int[] block) {if (board.IsOver(block))return;if (board.IsCorrect(block)) {// 現在のブロックが正しいので、次のブロックを求めるint[] nextblock = board.NextBlock(block);if (nextblock != null) {// 次のブロックの解を求める_Solve(board, level, nowpos, nextblock);} else {// すべてのブロックを処理し終わったので、解が見つかったか調べるif (board.IsFinish()) {// Levelの値と置いた騎士の数は一致する。置いた騎士の数が少ないほうがより良い解。if (_mincount > level) {// より良い解が見つかったので、解を覚える。_answer = new Chessboard(board);// _answer.Print();  // デバッグ用 暫定解を表示_mincount = level;}}}return;}if (level + 1 >= _mincount)//  現在の最良解よりも悪いものなので、この探索は途中で打ち切るreturn;// 現在のブロックのそれぞれに対し、騎士が置けるかを調べるvar list = block.Where(ix => board[ix] == Piece.Empty).ToList();foreach (int pos in list) {if (Array.IndexOf(block, pos) > Array.IndexOf(block, nowpos)) {// 直前に置いた騎士の位置よりもインデックスが小さいなら既に試してあるので、// インデックスが大きい場合に、新たに騎士をおいて、次の探索に行く。board.Put(pos);_Solve(board, level + 1, pos, block);// pos位置での試しは終わったので、次の探索ができるようにするためクリアする。board.Clear(pos);}}}
４つに区切って探索する。

*private void _Solve(Chessboard board, int level, int nowpos, int[] block) {if (board.IsOver(block))return;if (board.IsCorrect(block)) {// 現在のブロックが正しいので、次のブロックを求めるint[] nextblock = board.NextBlock(block);if (nextblock != null) {// 次のブロックの解を求める_Solve(board, level, nowpos, nextblock);} else {// すべてのブロックを処理し終わったので、解が見つかったか調べるif (board.IsFinish()) {// Levelの値と置いた騎士の数は一致する。置いた騎士の数が少ないほうがより良い解。if (_mincount > level) {// より良い解が見つかったので、解を覚える。_answer = new Chessboard(board);// _answer.Print();  // デバッグ用 暫定解を表示_mincount = level;}}}return;}if (level + 1 >= _mincount)//  現在の最良解よりも悪いものなので、この探索は途中で打ち切るreturn;// 現在のブロックのそれぞれに対し、騎士が置けるかを調べるvar list = block.Where(ix => board[ix] == Piece.Empty).ToList();foreach (int pos in list) {if (Array.IndexOf(block, pos) > Array.IndexOf(block, nowpos)) {// 直前に置いた騎士の位置よりもインデックスが小さいなら既に試してあるので、// インデックスが大きい場合に、新たに騎士をおいて、次の探索に行く。board.Put(pos);_Solve(board, level + 1, pos, block);// pos位置での試しは終わったので、次の探索ができるようにするためクリアする。board.Clear(pos);}}}
ひとつのブロックには、最大でも４つのKnightを配置すれば条件を満たせるはず。

*int[] nextblock = board.NextBlock(block);*if (nextblock != null) {// 次のブロックの解を求める_Solve(board, level, nowpos, nextblock);} else {// すべてのブロックを処理し終わったので、解が見つかったか調べるif (board.IsFinish()) {// Levelの値と置いた騎士の数は一致する。置いた騎士の数が少ないほうがより良い解。if (_mincount > level) {// より良い解が見つかったので、解を覚える。_answer = new Chessboard(board);// _answer.Print();  // デバッグ用 暫定解を表示_mincount = level;}}}
現在のブロックが正しいので、次のブロックを求める

*_Solve(board, level, nowpos, nextblock);*} else {
次のブロックの解を求める

*_answer = new Chessboard(board);
より良い解が見つかったので、解を覚える。

*_mincount = level;
_answer.Print();   デバッグ用 暫定解を表示

*return;
現在の最良解よりも悪いものなので、この探索は途中で打ち切る

*var list = block.Where(ix => board[ix] == Piece.Empty).ToList();*foreach (int pos in list) {if (Array.IndexOf(block, pos) > Array.IndexOf(block, nowpos)) {// 直前に置いた騎士の位置よりもインデックスが小さいなら既に試してあるので、// インデックスが大きい場合に、新たに騎士をおいて、次の探索に行く。board.Put(pos);_Solve(board, level + 1, pos, block);// pos位置での試しは終わったので、次の探索ができるようにするためクリアする。board.Clear(pos);}}
現在のブロックのそれぞれに対し、騎士が置けるかを調べる

*board.Put(pos);
直前に置いた騎士の位置よりもインデックスが小さいなら既に試してあるので、
インデックスが大きい場合に、新たに騎士をおいて、次の探索に行く。

*board.Clear(pos);
pos位置での試しは終わったので、次の探索ができるようにするためクリアする。


*GameObject.Find("Master").GetComponent<GameMaster>().GameOver("ゲーム失敗．また挑戦しよう");
<=====文字列を引数へ

*void Start () {resultMessageText.text = DataSender.resultMessage;}
Use this for initialization

*void Update () {}
Update is called once per frame

*void Start () {}
Use this for initialization

*void Update () {if (Input.GetKey(KeyCode.Space)) {SceneManager.LoadScene("Main");}}
Update is called once per frame


*Debug.Log(i.ToString().PadRight(5, '*'));
123**


*public enum State { Alive, Dead }
生死

*internal State Current { get; private set; }
現在の生死

*State Next { get; set; }
次の世代の生死

*IList<Cell> Neighbours { get; }
周囲のセル

*Rule Rule { get; }
次の世代の生死を判定するルール

*public Cell(State state, Rule rule) {Current = state;Rule = rule;Neighbours = new List<Cell>();}
初期状態を受け取る。ルールはDIします。

*internal void SetNextState() =>
次の世代の生死を設定します。

*internal void ToNextGen() => Current = Next;
世代を進めます。

*internal void AddNeighbour(Cell neighbour) => Neighbours.Add(neighbour);
周囲のセルを設定します。

*public override string ToString() => Current == State.Alive ? "o " : ". ";
コンソール出力時の描画

*internal Cell.State GetNextState(Cell.State self, IList<Cell> neighbours) {int alives = neighbours.Count(cell => cell.Current == Cell.State.Alive);bool willBorn = alives == 3;bool isSurvive = alives == 2 && self == Cell.State.Alive;return (willBorn || isSurvive) ? Cell.State.Alive : Cell.State.Dead;}
周囲の生きているセルの数から次代の生死を判定する

*public void ToNextGen() {var flattened = Cells.SelectMany(row => row);foreach (var cell in flattened)cell.SetNextState();foreach (var cell in flattened)cell.ToNextGen();}
セル達を次の世代へ進めます。

*public CellBuilder(Rule rule) => Rule = rule;
各セルに設定するルールをコンストラクタで受け取ります。

*public Cell[][] BuildCells(int rowLength, int colLength, int percentOfLivingCells) {var random = new Random();var cells = Enumerable.Range(1, rowLength).Select(_ => Enumerable.Range(1, colLength).Select(__ => {var state = (random.Next(1, 100) < percentOfLivingCells)? Cell.State.Alive: Cell.State.Dead;return new Cell(state, Rule);}).ToArray()).ToArray();return ConnectNeighbours(cells);}
縦横の長さと生きたセルの割合を受け取りグリッド（配列の配列）を返します。

*Cell[][] ConnectNeighbours(Cell[][] cells) {foreach (var (row, rowIndex) in cells.Select((row, i) =>(row, i))) {foreach (var (cell, colIndex) in row.Select((cell, i) =>(cell, i))) {foreach (Cell neighbour in GetNeighbours(rowIndex, colIndex, cells.Length, row.Length))cell.AddNeighbour(neighbour);}}return cells;// 周囲のセルを取得します。ローカル関数です。IEnumerable<Cell> GetNeighbours(int rowIndex, int colIndex, int rowLength, int colLength) {for (int i = -1; i < 2; i++) {for (int j = -1; j < 2; j++) {if (i == 0 && j == 0) continue;int offsetRow = circlate(rowIndex + i, rowLength);int offsetCol = circlate(colIndex + j, colLength);yield return cells[offsetRow][offsetCol];}}}}
各セルに周囲のセルを接続します。

*IEnumerable<Cell> GetNeighbours(int rowIndex, int colIndex, int rowLength, int colLength) {for (int i = -1; i < 2; i++) {for (int j = -1; j < 2; j++) {if (i == 0 && j == 0) continue;int offsetRow = circlate(rowIndex + i, rowLength);int offsetCol = circlate(colIndex + j, colLength);yield return cells[offsetRow][offsetCol];}}}
周囲のセルを取得します。ローカル関数です。

*// 周囲のセルを取得する際にグリッド端のセルはハミ出るのでこれで逆の端と繋げます。*int circlate(int index, int length) {if (index < 0) return index + length;if (index >= length) return index - length;else return index;}
はみ出るインデクスを循環させます。(C#ではマイナスのインデクスで配列の後ろからn番目でアクセスができない)

*int circlate(int index, int length) {if (index < 0) return index + length;if (index >= length) return index - length;else return index;}
周囲のセルを取得する際にグリッド端のセルはハミ出るのでこれで逆の端と繋げます。

*public ConsoleDrawer(TextWriter writer) => StdOut = writer;
TextWriterは外部からDIします。

*public void DrawCells(Cell[][] cells) {Console.CursorTop = 0;Console.CursorLeft = 0;foreach (var row in cells) {foreach (var cell in row) {StdOut.Write(cell);}StdOut.WriteLine();}StdOut.Flush();}
グリッドをTextWriter.Flushで一気に出力します。


*var url = $"http:
www.kmoni.bosai.go.jpnewwebservicehypoeew{time}.json";


*var distance = new Vector2Int{X = to.X - from.X,Y = to.Y - from.Y};
-----1. 補間する距離を調べる

*bool isRight   = distance.X >= 0;
-----2. 補間方向を調べる

*distance.X = Math.Abs(distance.X);
方向判定に使い終わったので使いやすいように絶対値にしておく

*var dotPositions = new List<Vector2Int>();
これが補間されたドットのデータ一覧になる

*dotPositions.Add(from + shift);*//大きい方の数値を減らす
データ追加

*if(distance.X > distance.Y) distance.X--;*else distance.Y--;
大きい方の数値を減らす


*private void Start()*{if (Controller)device = SteamVR_Controller.Input((int)Controller.index);}
Use this for initialization

*protected void Update()*{if (device != null)ControllerFunction(device);else if (Controller)device = SteamVR_Controller.Input((int)Controller.index);}
Update is called once per frame

*}
Debug.Log("トリガーを浅く引いた");

*}
Debug.Log("トリガーを深く引いた");

*}
Debug.Log("トリガーを離した");

*}
Debug.Log("タッチパッドをクリックした");

*}
Debug.Log("タッチパッドをクリックしている");

*}
Debug.Log("タッチパッドをクリックして離した");

*}
Debug.Log("タッチパッドに触った");

*}
Debug.Log("タッチパッドを離した");

*}
Debug.Log("メニューボタンをクリックした");

*}
Debug.Log("グリップボタンをクリックした");

*}
Debug.Log("トリガーを浅く引いている");

*}
Debug.Log("トリガーを深く引いている");

*}
Debug.Log("タッチパッドに触っている");


*}
処理

*}
処理


*IgnoreNullValues = true,文字コードの設定Encoder = JavaScriptEncoder.Create(UnicodeRanges.All),整形出力を行うWriteIndented = true};
すべての null 値プロパティを除外

*Encoder = JavaScriptEncoder.Create(UnicodeRanges.All),整形出力を行うWriteIndented = true};
文字コードの設定

*WriteIndented = true};
整形出力を行う

*public static string ToJson<T>(this T model)*{var optionsUTF8 = new JsonSerializerOptions{// すべての null 値プロパティを除外IgnoreNullValues = true,// 文字コードの設定Encoder = JavaScriptEncoder.Create(UnicodeRanges.All),// 整形出力を行うWriteIndented = true};return JsonSerializer.Serialize(model, optionsUTF8);}
拡張メソッドにしておくとちょっと便利

*IgnoreNullValues = true,文字コードの設定Encoder = JavaScriptEncoder.Create(UnicodeRanges.All),整形出力を行うWriteIndented = true};
すべての null 値プロパティを除外

*Encoder = JavaScriptEncoder.Create(UnicodeRanges.All),整形出力を行うWriteIndented = true};
文字コードの設定

*WriteIndented = true};
整形出力を行う


*if (novelListIndex < messageList.Count)
全ての会話を表示したか


*Debug.Log(element.id + "," + element.name);
出力例 : 100,HogeItem


*slideContents.Add(slide.NotesPage.Shapes.Placeholders[2].TextFrame.TextRange.Text);
placefolders[1] is slide itself.


*.SelectMany(x => x.Buffer(20))
20:明細最大行数

*}
.SelectMany(x => x.Buffer(20) は
.Select(x => x.Buffer(20)).SelectMany(x => x) とも書ける


*/**************************/
共通変数

*/**************************/
トークンの作成

*/**************************/
tokens.Statuses.Update(new { status = text });  ツイート

*/**************************/
検索・リツイートの繰り返し

*/**************************/
検索

*var result = tokens.Search.Tweets(count => 100, q => keyWord);
検索実行

*/**************************/
リツイート実行

*string tweetComent = tweet.Text;
つぶやき格納

*Console.WriteLine("===Tweet【" + tweetCntNo + "】【ID:"+ tweet.Id + "】===============================================");
コンソールに表示

*tweetCntNo += 1;
カウンタ

*tokens.Statuses.Retweet(id => tweet.Id);
リツイート

*tokens.Favorites.Create(id => tweet.Id);
いいね

*Console.WriteLine("{0}: {1}",tweet.User.ScreenName, tweet.Text);
コンソールに表示

*xrpTweetAsync();
再帰的呼出

*/**************************/*String APIKEY = "{API key}";
APIキーの設定

*/**************************/
トークン作成

*if (!tweet.Language.Equals("ja"))
いいねの数
---------------------------
if (tweet.FavoriteCount < 1)
{
return false;
}
---------------------------
日本語
---------------------------

*HashtagEntity[] hashTags = tweet.Entities.HashTags;
タグの数
---------------------------
タグのカウント

*foreach(var tag in hashTags)
除外タグ検索
---------------------------

*if (tweet.Text.Contains("プレゼント") ||
除外ワード検索
---------------------------

*if (tweet.Text.Contains("プレゼント"))
除外ワード検索
---------------------------

*if (keyWordFlag && !tweet.Text.Contains("XRP"))
XRP検索時、本文にXRPが入っていない場合は除外
---------------------------

*string tweetCmnt = "";
XRPが含まれているだけのリツイートは除外
---------------------------

*return true;
合格


*ClickUp = 1 << 5,
ボタンを離したとき

*これを忘れると、interactable = false でもクリックできてしまうif (!interactable){return;
OnPointerDown は Button.interactable とは関係無い

*// 全て if-elseif にしているのは、イベントを投げるときに 1フレームに1イベントだけ投げるようにするため*if ((_eventBitCode & ButtonEventType.ClickDown) == ButtonEventType.ClickDown)
ここで ButtonEventType の各フラグを見て、どのイベントを投げるのか決定している。

*interactable = false;
ClickDown 時に interactable を false にして、入力が2つ(スマホだと指2本で1つのボタンをタップするとか)あっても 2個目以上は弾くようにしている

*interactable = true;
ClickUp したら、ボタンが再度 Click できるようにする。


*(int)(_arr_control_storage[_pos].Height * _form_ratio_height));
use for sizing


*GameObject go = Instantiate(arrowPrefab) as GameObject;
instantiateメソッドに引数arrowPrefabを渡すと、戻り値としてPrefabのインスタンスを返す。強制型変換であるキャストを使い、戻り値をGameObject型に変換


*int width = 30;
四角形の大きさ

*const int SINK_PERMISSION_NUM = 18;
グリッド描画めり込み最低値

*int vertex = width * 8;
頂点数

*var center = new { X = width * 0.5f, Y = height * 0.5f };
中心点

*float toAngle = (float)Math.PI / vertex;
先にDegree -> Radian用の数値を作っておく

*double angle = toAngle * i;
円を生成していく

*int sink = (int)((py % 1.0f) * 100);
円頂点のドットへのめり込み量を調べる

*int dotUpY = (int)(center.Y - j);
上側のポジションY 偶数時の補正をするならここに-1

*int dotDownY = (int)(center.Y + j);
下側のポジションY

*}
~~~~~~~描画~~~~~~~
DrawDot(dotX,dotUpY,dotDownY);
~~~~~~~~~~~~~~~~~~


*context.SaveChanges();
これでエラー発生しない！


*Console.WriteLine(book.Title);
1984年

*public Logger(TextWriter writer) => this.writer = writer;
コンストラクタでプライベートフィールドを初期化する


*return false;
ここをコメントアウトするとデータが尽きるまでズンドコ言い続ける


*File.WriteAllText(@"C:\Myfolder\test.txt", "Good morning!");
第1引数：ファイルパス
第2引数：追記するテキスト

*File.AppendAllText(@"C:\Myfolder\test.txt", "Good morning!");
第1引数：ファイルパス
第2引数：追記するテキスト

*File.AppendAllText(@"C:\Myfolder\test.txt", "Good morning!"+Environment.NewLine);
第1引数：ファイルパス
第2引数：追記するテキスト

*string readText = File.ReadAllText(@"C:\Myfolder\test.txt");
第1引数：ファイルパス

*}
ここにファイルIO処理を記述する


*static void Main(string[] args) {// 問題の集合と部分和を入力するConsole.Write("集合=> ");var strs = Console.ReadLine().Split(',');int[] nums = strs.Select(s => int.Parse(s.Trim())).ToArray();// 一つの集合に対して、複数のターゲットを調べることができるwhile (true) {Console.Write("ターゲット=> ");var line = Console.ReadLine();if (line == "")break;int target = int.Parse(line);// 問題を解くvar ssp = new SubsetSumProblem(nums);var ans = ssp.Solve(target);if (ans.Length > 0) {// 解が見つかったので、解を表示する。var ansStrings = ans.Select(n => n.ToString()).ToArray();var text = string.Join(" + ", ansStrings) + " = " + target;Console.WriteLine(text);} else {Console.WriteLine("解は存在しません");}}Console.ReadLine();}
ここは問題の本質じゃないbので手抜き

*Console.Write("集合=> ");
問題の集合と部分和を入力する

*var ssp = new SubsetSumProblem(nums);
問題を解く

*var ansStrings = ans.Select(n => n.ToString()).ToArray();
解が見つかったので、解を表示する。

*public class SubsetSumProblem {private int[] _nums;// numsの要素は、正整数とするpublic SubsetSumProblem(int[] nums) {this._nums = nums.ToArray();}private int[] _work;public int[] Solve(int target) {// 0. 配列pを用意する。サイズは、部分和(target)+1 とする。_work = new int[target + 1];// 1. 配列_workを初期化する _work[0] = 0, それ以外は -1 をセット。_work[0] = 0;for (int i = 1; i <= target; i++)_work[i] = -1;// 2. 集合からひとつ要素を取り出し、m とする。foreach (var m in _nums) {for (int i = target; i >= 0; i--) {// 3. 配列pを最後から見ていき、-1 以外の時に、4の処理を行うif (_work[i] == -1)continue;// 4. i + m <= target で、_work[i+m] == -1 ならば、_work[i+m] に m を代入する。if (i + m <= target && _work[i + m] == -1)_work[i + m] = m;}// 5. _work[target] != -1 ならば、解が見つかったので、処理を終了する。//    _work[target] == -1 ならば 1.に戻って処理を繰り返す。if (_work[target] != -1)break;}return ToResult(_work, target);}// 作業用の配列から、部分集合を求めるprivate int[] ToResult(int[] work, int target) {var result = new List<int>();if (work[target] != -1) {while (target > 0) {result.Add(work[target]);target = target - work[target];}}return (result as IEnumerable<int>).Reverse().ToArray();}}
部分和問題を動的計画法で解く

*public SubsetSumProblem(int[] nums) {this._nums = nums.ToArray();}
numsの要素は、正整数とする

*_work = new int[target + 1];
0. 配列pを用意する。サイズは、部分和(target)+1 とする。

*_work[0] = 0;
1. 配列_workを初期化する _work[0] = 0, それ以外は -1 をセット。

*if (_work[i] == -1)*continue;
3. 配列pを最後から見ていき、-1 以外の時に、4の処理を行う

*if (i + m <= target && _work[i + m] == -1)*_work[i + m] = m;
4. i + m <= target で、_work[i+m] == -1 ならば、_work[i+m] に m を代入する。

*_work[target] == -1 ならば 1.に戻って処理を繰り返す。if (_work[target] != -1)break;
5. _work[target] != -1 ならば、解が見つかったので、処理を終了する。

*if (_work[target] != -1)*break;
_work[target] == -1 ならば 1.に戻って処理を繰り返す。

*private int[] ToResult(int[] work, int target) {var result = new List<int>();if (work[target] != -1) {while (target > 0) {result.Add(work[target]);target = target - work[target];}}return (result as IEnumerable<int>).Reverse().ToArray();}
作業用の配列から、部分集合を求める


*System.Reflection.Assembly asm = System.Reflection.Assembly.GetExecutingAssembly();
自分自身のAssemblyを取得し、名前を返す

*System.Reflection.Assembly asm = System.Reflection.Assembly.GetExecutingAssembly();
自分自身のAssemblyを取得し、バージョンを返す


*parameters.Exponent = Base64.Decode(key[@"e"]);
公開指数


*,,,*var list = new List<int>(){1,2,3,4,5};
=> 1 4 9 16 25

*,,,*var array = new[] {new{Name = "A", Age = 1},new{Name = "C", Age = 2},new{Name = "B", Age = 1},new{Name = "E", Age = 5},new{Name = "D", Age = 3},};
=>2 4

*,,,*var list = new List<int>() { 1, 2, 3, 4, 5 };
=> {A,1} {B,1} {C,2} {D,3} {E,5}

*,,,*var list = new List<int>(){1,2,2,3,3,3,4,5,5};
=> 5

*,,,*var listA = new List<int>(){1,2,3,4,5};
=> 1 2 3 4 5

*,,,*var listA = new List<int>(){1,2,3,4,5};
=> 1 2 3 4 5 6 7 8

*,,,*var list = new List<int>(){1,2,3,4,5};
=> 4 5

*,,,*var list = new List<int>(){1,2,3,4,5};
=>True

*,,,*var list = new List<int>(){1,2,3,4,5};
=>True


*if (string.IsNullOrEmpty(loadJsonStr))
セーブデータがない場合無駄な処理を行わないためのif文


*Debug.Print(output.ToString());
結果の出力

*var lastFive = resQueue.Skip(resQueue.Count - 5);
最後の5個を取り出す

*var seedArr = string.Concat(inputStr.Select(x => x).Distinct());
ここが重要
inputStrを分解し、重複を削除してから結合

*var answerArr = inputStr.Select(x => seedArr.IndexOf(x));
inputStrをseedArrのindexに置き換え

*resStack.Push(rnd.Next(0, lastIdx));
0～lastIdx未満の整数を追加

*var revStack = resStack.Reverse();
比較用に反転


*if (this.chatClient != null) this.chatClient.Disconnect();*// 接続
切断

*chatClient.Connect(this.appId, "1.0", new ExitGames.Client.Photon.Chat.AuthenticationValues("MyName"));
接続


*connectableInterval.Connect();
Observable.Interval自体をHot化（ObservableソースがHot化する）

*IDisposable connection = connectableObservable.Connect();
Observale.IntervalをHot化したものに接続する

*await Task.Delay(3000);
3秒経ったら切断して再接続する


*BigInteger value = new BigInteger(valueByteData.Reverse().ToArray());
バイトオーダーをBigEndienからLittle Endienに変換してからBigIntegerを生成

*int[] values = Oid.Split('.').Select(int.Parse).ToArray();
OIDをピリオドで区切って数値配列に分けて格納する。

*result.AddRange(ConvByte(ParseXY(values[0], values[1])));
1個目、2個目

*udp.BeginReceive(ReceiveCallback, udp);
非同期受信開始

*Invoke(new ShowReceiveValueDelegate(ShowReceiveValue), value);
別スレッドから呼び出された場合


*Task task = Task.Run(() => Sleep(startTick, "3", "4", 250, 0));
await前にTaskが終わるケース（UIスレッドの場合）

*await Task.Run(() => B(startTick));
await後にTaskが終わるケース（UIスレッドの場合）

*await Task.Run(() => Sleep(startTick, "8?", "9", 500, 500));
await後にTaskが終わるケース（ワーカースレッドの場合）

*Task task = Task.Run(() => Sleep(startTick, "11", "12", 250, 1000));
await前にTaskが終わるケース（ワーカースレッドの場合）


*str = ary[0];
string型の変数にobject型は代入できない


*Console.WriteLine("abcde".Slice(3,4));
"d"


*Console.WriteLine(data[0]);
アドレスが更新されたため。


*gameWindow.offsetMax = new Vector2(right, top);
今回は上部分をずらすのでTopのみ修正
top = ;任意サイズ
gameWindow.offsetMin = new Vector2(left, bottom);下部分をずらしたいときに使用


*IEnumerable<int> evenList = idxList.Where(x => x % 2 == 1);
偶数桁目はindex=1,3,...

*IEnumerable<int> oddDigit = EncodeToInt(oddList, barcode);
奇数／偶数のリストごとに、Selectで値を加工
（ここでは文字列.Substringにindexを渡して取り出し、数値リストに加工）
下記のサブメソッドEncodeToIntに分けてもよいかも

*int sumAll = sumOdd + sumEven;
それぞれSumで合計、奇数桁目は3倍の重み付け（ウェイト）
int sumOdd = oddDigit.Sum(x => x * 3);   一旦Selectで(x => x * 3)、あるいは次で3倍してもOK
int sumEven = evenDigit.Sum();           こちらはそのまま
合計をstringに変換

*int lastDigit = Integer.Parse(sumStr.Last());
10から「合計の下１桁」を引く

*}
チェックディジットは数値であることが前提なので、例外は起こします
必要に応じて例外処理を加えて下さい。
return list.Select(idx => barcode.Substring(idx, 1))         文字列を切り出して
.Select(chr => Integer.Parse(chr));               改めて数値リストに変換


*void Start () {StartCoroutine(UpdateBankruptShader());}
coroutine を呼び出し

*this.GetComponent<Renderer>().material.SetFloat("progress", this.GetComponent<Renderer>().material.GetFloat("progress") + 0.01f);
Material 内部の progress プロパティの値を 0.01f 加算

*yield return new WaitForSeconds(0.01f);
0.01sec 待つ


*DateTime a = DateTime.Now;
日付


*yield return num;
とループ外で宣言してから


*PATH_VOICEROID = @"...\VOICEROID.exe";
VOICEROIDのパスの割り当て

*Process.Start(vr);
VOICEROIDの起動

*Thread.Sleep(5000);
起動の待ち時間: 5000ms = 5s

*tb = main.IdentifyFromZIndex(2, 0, 0, 1, 0, 1, 1);*//再生ボタン
テキストボックス

*playbtn = new FormsButton(main.IdentifyFromZIndex(2, 0, 0, 1, 0, 1, 0, 3));*//保存ボタン
再生ボタン

*savebtn = new FormsButton(main.IdentifyFromZIndex(2, 0, 0, 1, 0, 1, 0, 1));*,,,
保存ボタン

*tb["Text"](text);
テキストボックスにテキストを渡す

*playbtn.EmulateClick();
再生

*var text = talklist[0];
テキストを入手

*playbtn.EmulateClick();
再生

*var columnImage = new DataGridViewImageColumn();
TimelineとしてDataGridViewを作成
columnの作成

*Timeline.Columns.Add(columnImage);
columnの追加

*Timeline.AutoSizeRowsMode = DataGridViewAutoSizeRowsMode.AllCells;
セルの内容に合わせて、行の高さが自動的に調節されるようにする

*Timeline.Columns["ツイート"].DefaultCellStyle.WrapMode = DataGridViewTriState.True;
ツイート列のセルのテキストを折り返して表示する

*Timeline.RowHeadersVisible = false;
左側の項目を消す

*user = ScreenNametext = ツイートの内容WebClient wc = new WebClient();
img = アイコンのURL

*text = ツイートの内容WebClient wc = new WebClient();
user = ScreenName

*WebClient wc = new WebClient();
text = ツイートの内容


*this._発言者.Add(pricure);
リストはセリフ自体の特性なので、外から与えないこととした。

*private List<セリフ> 開始の合図 = new List<セリフ>();
List自体を、外から差し替えられないようにprivateにしている

*if( 開始の合図 != null)
Listは「変身シーンのセリフ」の特性であると考えられるため、
引数のリストをそのまま代入せずに、中身だけを代入する


*udp.BeginReceive(ReceiveCallback, udp);
非同期受信開始

*Invoke(new ShowReceiveMessageDelegate(ShowReceiveMessage), message);
別スレッドから呼び出された場合


*fTempo[0] = modelview[0] * objx + modelview[4] * objy + modelview[8] * objz + modelview[12];
w is always 1


*static string[] Scopes = { SheetsService.Scope.Spreadsheets };
もしスコープを変えた時は事前にあるcredential（~/.credentials/sheets.googleapis.com-dotnet-quickstart.json）を消すこと

*using (var stream =new FileStream("client_secret.json", FileMode.Open, FileAccess.Read))
credentialを取得

*var service = new SheetsService(new BaseClientService.Initializer(){HttpClientInitializer = credential,ApplicationName = ApplicationName,});
Google Sheets API サービスを作る

*String spreadsheetId = "コピーしたスプレッドシートID";
スプレッドシートID

*var wv = new List<IList<object>>()*{new List<object>{"=ROW()","Bです","日付：", DateTime.Now.ToString()}};
データを新しい行に書き込む

*Console.WriteLine("書き込み完了");
終わり


*1.0
sec


*new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J2, NextTime =  6,            SlipTime = 1 },波動拳                    状態は押している         キーは左下 次の入力は 6フレーム以内 次の入力同時押し不可NextFrame判定new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J3, NextTime =  6,            SlipTime = 1 },波動拳                    状態は押している         キーは右   次の入力は 7フレーム以内 次の入力同時押し可能ThisFrame判定new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J6, NextTime =  7,            SlipTime = 0 },波動拳                    状態は押した             キーはP    最後なので 0に必ずする   最後なので 0に必ずするnew MoveCommand { DoFinger = Finger.Pressed, InputKey = Key.HP, NextTime =  0,            SlipTime = 0 },},,,,foreach (List<MoveCommand> MoveCommandData in MoveCommandList) MoveCommandData.Reverse();
波動拳                    状態は押している         キーは左   次の入力は 6フレーム以内 次の入力同時押し不可NextFrame判定

*new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J3, NextTime =  6,            SlipTime = 1 },波動拳                    状態は押している         キーは右   次の入力は 7フレーム以内 次の入力同時押し可能ThisFrame判定new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J6, NextTime =  7,            SlipTime = 0 },波動拳                    状態は押した             キーはP    最後なので 0に必ずする   最後なので 0に必ずするnew MoveCommand { DoFinger = Finger.Pressed, InputKey = Key.HP, NextTime =  0,            SlipTime = 0 },},,,,foreach (List<MoveCommand> MoveCommandData in MoveCommandList) MoveCommandData.Reverse();
波動拳                    状態は押している         キーは左下 次の入力は 6フレーム以内 次の入力同時押し不可NextFrame判定

*new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J6, NextTime =  7,            SlipTime = 0 },波動拳                    状態は押した             キーはP    最後なので 0に必ずする   最後なので 0に必ずするnew MoveCommand { DoFinger = Finger.Pressed, InputKey = Key.HP, NextTime =  0,            SlipTime = 0 },},,,,foreach (List<MoveCommand> MoveCommandData in MoveCommandList) MoveCommandData.Reverse();
波動拳                    状態は押している         キーは右   次の入力は 7フレーム以内 次の入力同時押し可能ThisFrame判定

*new MoveCommand { DoFinger = Finger.Pressed, InputKey = Key.HP, NextTime =  0,            SlipTime = 0 },},,,,foreach (List<MoveCommand> MoveCommandData in MoveCommandList) MoveCommandData.Reverse();
波動拳                    状態は押した             キーはP    最後なので 0に必ずする   最後なので 0に必ずする

*new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J2, NextTime =  6,            SlipTime = 1 },波動拳                    状態は押している         キーは左下 次の入力は 6フレーム以内 次の入力同時押し不可NextFrame判定new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J3, NextTime =  6,            SlipTime = 1 },波動拳                    状態は押している         キーは右   次の入力は 7フレーム以内 次の入力同時押し可能ThisFrame判定new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J6, NextTime =  7,            SlipTime = 0 },波動拳                    状態は押した             キーはP    最後なので 0に必ずする   最後なので 0に必ずするnew MoveCommand { DoFinger = Finger.Pressed, InputKey = Key.HP, NextTime =  0,            SlipTime = 0 },},};
波動拳                    状態は押している         キーは左   次の入力は 6フレーム以内 次の入力同時押し不可NextFrame判定

*new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J3, NextTime =  6,            SlipTime = 1 },波動拳                    状態は押している         キーは右   次の入力は 7フレーム以内 次の入力同時押し可能ThisFrame判定new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J6, NextTime =  7,            SlipTime = 0 },波動拳                    状態は押した             キーはP    最後なので 0に必ずする   最後なので 0に必ずするnew MoveCommand { DoFinger = Finger.Pressed, InputKey = Key.HP, NextTime =  0,            SlipTime = 0 },},};
波動拳                    状態は押している         キーは左下 次の入力は 6フレーム以内 次の入力同時押し不可NextFrame判定

*new MoveCommand { DoFinger = Finger.Hold,    InputKey = Key.J6, NextTime =  7,            SlipTime = 0 },波動拳                    状態は押した             キーはP    最後なので 0に必ずする   最後なので 0に必ずするnew MoveCommand { DoFinger = Finger.Pressed, InputKey = Key.HP, NextTime =  0,            SlipTime = 0 },},};
波動拳                    状態は押している         キーは右   次の入力は 7フレーム以内 次の入力同時押し可能ThisFrame判定

*new MoveCommand { DoFinger = Finger.Pressed, InputKey = Key.HP, NextTime =  0,            SlipTime = 0 },},};
波動拳                    状態は押した             キーはP    最後なので 0に必ずする   最後なので 0に必ずする

*float x = Input.GetAxisRaw("Horizontal");
十字キーの状態を取得

*Hold = Key.Zero;
十字キーおよびパンチキックの"押している"状態を変数に設定

*Pressed = Key.Zero;
パンチキックの"押した"状態を変数に設定

*foreach (List<MoveCommand> MoveCommandData in MoveCommandList) MoveCommandData.Reverse();
技のコマンドリストの順序を反転
波動拳は下⇒右下⇒右⇒Pだが、
処理順はP⇒右⇒右下⇒下の順序で判定を行なうため反転。

*Application.targetFrameRate = 60;
フレームレートの設定

*Profiler.BeginSample("check_GC_Alloc");
GC Alloc 等確認用プロファイラースタート

*DebugStopwatch1.Restart();
処理時間計測用のストップウォッチスタート

*InputGetKeyData.Update();
InputGetKeyData追加処理更新

*int i = Time.frameCount % InputGetKeyDataHistoryMax;
InputGetKeyDataの履歴保持用に今回のフレームのキー情報を取得

*while (InputGetKeyTinyHistoryList.Count >= InputGetKeyDataHistoryMax) InputGetKeyTinyHistoryList.RemoveAt(0);*// InputGetKeyDataの履歴保持用Listの末尾に今回のフレームのキー情報を追加
InputGetKeyDataの履歴保持用Listが最大数以上の場合には先頭から順次削除

*InputGetKeyTinyHistoryList.Add(InputGetKeyTinyHistoryData[i]);
InputGetKeyDataの履歴保持用Listの末尾に今回のフレームのキー情報を追加

*foreach (List<MoveCommand> MoveCommandData in MoveCommandList)
技のコマンドリストを順次判定処理
本コードは波動拳だけなので1回転のみ

*DebugStopwatch2.Restart();
処理時間計測用のストップウォッチスタート

*foreach (MoveCommand record in MoveCommandData)
技のコマンドのひとつひとつを順次判定処理
波動拳は下⇒右下⇒右⇒Pなので4回転
foreach1回目はP 　の判定
foreach2回目は右　の判定
foreach3回目は右下の判定
foreach4回目は下　の判定

*StaticInputKey = record.InputKey;
GC Alloc 対策

*DebugStopwatch3.Restart();
処理時間計測用のストップウォッチスタート

*InputGetKeyTinyHistoryDataRow = record.DoFinger switch
技のコマンドのひとつひとつを順次判定処理
波動拳は下⇒右下⇒右⇒Pなので4回判定
foreach1回目はP 　の判定
foreach2回目は右　の判定
foreach3回目は右下の判定
foreach4回目は下　の判定

*StaticFrameCount = InputGetKeyTinyHistoryDataRow.FrameCount;
次の判定用に判定用のStaticFrameCountを更新。allowを1にする。

*else*{allow = false;break;}
抽出データが存在しない場合は波動拳コマンド入力受付否認。

*if (DebugStopwatch3.IsRunning) DebugStopwatch3.Stop();*}
処理時間計測用のストップウォッチストップ

*if (DebugStopwatch2.IsRunning) DebugStopwatch2.Stop();*// コマンド入力受付承認?
処理時間計測用のストップウォッチストップ

*Debug.Log($"{Time.frameCount}fr [判定所要時間]{DebugStopwatch2.ElapsedTicks,6:D}ticks, [受付承認技名]波動拳");
Consoleデバック表示

*Debug.Log($"{Time.frameCount}fr [判定所要時間]{DebugStopwatch2.ElapsedTicks,6:D}ticks, [受付否認技名]波動拳");
Consoleデバック表示

*if (DebugStopwatch1.IsRunning) DebugStopwatch1.Stop();*// GC Alloc 等確認用プロファイラーストップ
処理時間計測用のストップウォッチストップ

*Profiler.EndSample();
GC Alloc 等確認用プロファイラーストップ


*private Int32 version = 0;
SNMP V1


*ExecuteMainProcessHandler(new GenericEventArgs<string>("Hello World!"));
共通の前処理の実施
（イベント発生】呼び出し元個別の処理
呼び出し元でイベント発生時の処理を記述

*}
共通の後処理を実施

*ExecuteExceptionHandler(new GenericEventArgs<Exception>(e));
呼び出し元でイベント発生時の処理を記述

*EventHandler<GenericEventArgs<string>> handler = this.MainProcessHandler;
イベントが呼び出し元で定義されている場合のみイベント処理を実施

*EventHandler<GenericEventArgs<Exception>> handler = this.ExceptionHandler;
イベントが呼び出し元で定義されている場合のみイベント処理を実施

*SomeProcessExecutor executor = new SomeProcessExecutor();
ある処理のインスタンスを生成し、イベントの処理を定義

*executor.Execute();
ある処理を実行する処理を実行

*MessageBox.Show(args.EventData);
呼び出し元個別の処理を定義

*MessageBox.Show(args.EventData.ToString());
呼び出し元個別の処理を定義（例外発生時）


*using Assert = UnityEngine.Assertions.Assert;
AssertはNUnitのではなくUnityのものを使う

*public class ZenjectTest*{[Test]public void ResolveTest(){var container = new DiContainer();container.BindInstance("hoge");Assert.AreEqual("hoge", container.Resolve<string>());}[Test]public void ResolveAllTest(){var container = new DiContainer();container.BindInstance("hoge");container.BindInstance("fuga");var all = container.ResolveAll<string>();Assert.AreEqual(2, all.Count);Assert.AreEqual("hoge", all[0]);Assert.AreEqual("fuga", all[1]);}}
Zenjectの挙動確認を行う（あらかじめZenjectの導入が必要）

*public class HogeComponent : MonoBehaviour*{public int count { get; private set; }void Start(){this.count = 1;}}
適当なコンポーネントを定義

*public class HogeComponentTest*{[UnityTest]public IEnumerator CountTest(){var go = new GameObject("Hoge");var hoge = go.AddComponent<HogeComponent>();// Start()前Assert.AreEqual(0, hoge.count);yield return null;// Start()後Assert.AreEqual(1, hoge.count);}}
テスト用クラス

*Assert.AreEqual(0, hoge.count);
Start()前

*Assert.AreEqual(1, hoge.count);
Start()後


*[SerializeField] Item iteminfo;
さっきのアイテム情報をアタッチ

*using UnityEngine;
プレイヤーの所持アイテムはここで管理

*public ReactiveCollection<Item> GetItemLists()*{return itemLists;}
アイテムリストを返す

*using System.Collections.Generic;
所持アイテムをアイテム画面に映す。改良の余地あり

*void Start()*{PlayersItem.itemLists.ObserveAdd().Subscribe(_ => ReloadItemSlots());PlayersItem.itemLists.ObserveRemove().Subscribe(_ => ReloadItemSlots());}
Use this for initialization


*int[] values = Oid.Split('.').Select(int.Parse).ToArray();
OIDをピリオドで区切って数値配列に分けて格納する。

*result.AddRange(ConvByte(ParseXY(values[0], values[1])));
1個目、2個目


*var lazy = new LazySlim1<Foo>(() => new Foo());
LazySlim2, Lazyに差し替えた版も用意


*digitalWrite(LED, LOW);
オフ


*var urls = doc.Root.Descendants("{http:
search.yahoo.commrss}thumbnail")


*writer.Write(loggingEvent.RenderedMessage);
なんか色々文字置換とかの処理をここでしましょう
↓このままだと、設定されたメッセージがそのまま出力されるので、いい感じに変えてください


*Console.WriteLine(list.Sum().Value);
6

*,,,*if (a is { X: { Y: { Z: 4 } } }) { ... }
例：#line (1, 1) - (2, 2) 3 "test.cs"


*var hashStr = SignUp(password);
サインアップ

*Console.WriteLine(SignIn(password, hashStr));
サインイン


*var tuple = ("鍵山雛", 50, 45, 49);
何の数字かはお察しください...

*var Fujinroku = new Character[] {new Character(162, 84, 52, 83) {Name = "秋静葉",Category = "東方風神録"},new Character(163, 94, 62, 81) {Name = "秋穣子",Category = "東方風神録"},new Character(172, 94, 57, 89) {Name = "鍵山雛",Category = "東方風神録"},new Character(161, 88, 52, 91) {Name = "河城にとり",Category = "東方風神録"},new Character(165, 86, 64, 83) {Name = "犬走椛",Category = "東方風神録"},new Character(169, 92, 55, 88) {Name = "射命丸文",Category = "東方花映塚"}new Character(168, 94, 65, 94) {Name = "東風谷早苗",Category = "東方風神録"},new Character(176, 88, 60, 88) {Name = "八坂神奈子",Category = "東方風神録"}new Character(152, 79, 52, 80) {Name = "洩矢諏訪子",Category = "東方風神録"}};
数値については異論を認める

*public int GetTall() {return Tall;}
一つずつGetterを作るのは面倒だよね

*public (int, int, int) GetThreeSize() {return (Bust, Waist, Hip);}
プロパティを根こそぎ浚える

*UdonChang.SetColor(("#DA81F5", "#FE2E2E", null));
ぱんつはいてません

*(int Bust, int Waist, int Hip) = HinaChangNoThreeSize;
ローカル変数と同じ扱いなので、雛ちゃんのスリーサイズは同一スコープ内で利用できる

*(Bust, Waist, Hip) = Fujinroku[2].GetThreeSize();
直接メソッドから取ることもできる

*tupleList.Add((1, new Character(171, 89, 52, 88) {Name = "博麗霊夢",Category = "自機"}));
世界一位

*tupleList.Add((2, new Character(167, 84, 57, 90) {Name = "霧雨魔理沙",Category = "自機"}));
悔しいので来年は抜いてやるぜ

*tupleList.Add((9, new Character(174, 92, 63, 91) {Name = "アリス・マーガトロイド",Category = "東方妖々夢"}));
⑨位でいいの。謙虚だもの私


*var userList = (from n in db.user_info select n).ToList();
dbの処理


*static class ArrayRotation {// 中央横軸を中心に回転するpublic static int[,] HorRotate(this int[,] array) {var work = array.Clone() as int[,];int xLeng = work.GetLength(0);for (int x = 0; x < xLeng / 2; x++) {for (int y = 0; y < work.GetLength(1); y++) {int temp = work[x, y];work[x, y] = work[xLeng - x - 1, y];work[xLeng - x - 1, y] = temp;}}return work;}}
２次元配列の回転を行うクラス（要素数には依存しない)

*public static int[,] HorRotate(this int[,] array) {var work = array.Clone() as int[,];int xLeng = work.GetLength(0);for (int x = 0; x < xLeng / 2; x++) {for (int y = 0; y < work.GetLength(1); y++) {int temp = work[x, y];work[x, y] = work[xLeng - x - 1, y];work[xLeng - x - 1, y] = temp;}}return work;}
中央横軸を中心に回転する

*static class ArrayRotation {......// 左上から右下への斜め対角線軸を中心に反転するpublic static int[,] RightDownDiagRotate(this int[,] array) {var work = array.Clone() as int[,];for (int y = 1; y < work.GetLength(1); y++) {for (int x = 0; x < y; x++) {int temp = work[x, y];work[x, y] = work[y, x];work[y, x] = temp;}}return work;}}
２次元配列の回転を行うクラス（要素数には依存しない)

*public static int[,] RightDownDiagRotate(this int[,] array) {var work = array.Clone() as int[,];for (int y = 1; y < work.GetLength(1); y++) {for (int x = 0; x < y; x++) {int temp = work[x, y];work[x, y] = work[y, x];work[y, x] = temp;}}return work;}
左上から右下への斜め対角線軸を中心に反転する

*static class ArrayRotation {// これが基準public static int[,] TurnLeft90(this int[,] array) {return array.RightDownDiagRotate().HorRotate();}public static int[,] TurnLeft180(this int[,] array) {return array.TurnLeft90().TurnLeft90();}public static int[,] TurnLeft270(this int[,] array) {return array.TurnLeft180().TurnLeft90();}public static int[,] TurnLeft360(this int[,] array) {return array.Clone() as int[,];}public static int[,] TurnRight90(this int[,] array) {return array.TurnLeft270();}public static int[,] TurnRight180(this int[,] array) {return array.TurnLeft180();}public static int[,] TurnRight270(this int[,] array) {return array.TurnLeft90();}public static int[,] TurnRight360(this int[,] array) {return array.Clone() as int[,];}public static int[,] VertRotate(this int[,] array) {return array.RightDownDiagRotate().TurnRight90();}// 中央横軸を中心に回転するpublic static int[,] HorRotate(this int[,] array) {var work = array.Clone() as int[,];int xLeng = work.GetLength(0);for (int x = 0; x < xLeng / 2; x++) {for (int y = 0; y < work.GetLength(1); y++) {int temp = work[x, y];work[x, y] = work[xLeng - x - 1, y];work[xLeng - x - 1, y] = temp;}}return work;}public static int[,] RightUpDiagRotate(this int[,] array) {return array.TurnLeft180().RightDownDiagRotate();}// 左上から右下への斜め軸を中心に回転するpublic static int[,] RightDownDiagRotate(this int[,] array) {var work = array.Clone() as int[,];for (int y = 1; y < work.GetLength(1); y++) {for (int x = 0; x < y; x++) {int temp = work[x, y];work[x, y] = work[y, x];work[y, x] = temp;}}return work;}}
２次元配列の回転を行うクラス（要素数には依存しない)

*public static int[,] TurnLeft90(this int[,] array) {return array.RightDownDiagRotate().HorRotate();}
これが基準

*public static int[,] HorRotate(this int[,] array) {var work = array.Clone() as int[,];int xLeng = work.GetLength(0);for (int x = 0; x < xLeng / 2; x++) {for (int y = 0; y < work.GetLength(1); y++) {int temp = work[x, y];work[x, y] = work[xLeng - x - 1, y];work[xLeng - x - 1, y] = temp;}}return work;}
中央横軸を中心に回転する

*public static int[,] RightDownDiagRotate(this int[,] array) {var work = array.Clone() as int[,];for (int y = 1; y < work.GetLength(1); y++) {for (int x = 0; x < y; x++) {int temp = work[x, y];work[x, y] = work[y, x];work[y, x] = temp;}}return work;}
左上から右下への斜め軸を中心に回転する

*// array[0,2]->13  array[4,0]-> 51*{ 11, 12, 13, 14, 15, 16, 17, 18, 19 },
array[x,y]でアクセス。x軸が縦、y軸が横

*{ 11, 12, 13, 14, 15, 16, 17, 18, 19 },
array[0,2]->13  array[4,0]-> 51


*var result = Enumerable.Repeat("", 9).ToArray();
albireoさま コメントよりコピー


*Padding = new Thickness(100, top, 100, 0);
これに変更！！


*//effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent*if (Physics.Raycast (ray, out hit, maxRayDistance, collisionLayer)) {//we're going to get the position from the contact pointm_HitTransform.position = hit.point;Debug.Log (string.Format ("x:{0:0.######} y:{1:0.######} z:{2:0.######}", m_HitTransform.position.x, m_HitTransform.position.y, m_HitTransform.position.z));//and the rotation from the transform of the plane colliderm_HitTransform.rotation = hit.transform.rotation;}
we'll try to hit one of the plane collider gameobjects that were generated by the plugin

*m_HitTransform.rotation = hit.transform.rotation;*}
and the rotation from the transform of the plane collider

*//effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent*if (Physics.Raycast (ray, out hit, maxRayDistance, collisionLayer)) {//we're going to get the position from the contact pointm_HitTransform.position = hit.point;Debug.Log (string.Format ("x:{0:0.######} y:{1:0.######} z:{2:0.######}", m_HitTransform.position.x, m_HitTransform.position.y, m_HitTransform.position.z));//and the rotation from the transform of the plane colliderm_HitTransform.rotation = hit.transform.rotation;}
we'll try to hit one of the plane collider gameobjects that were generated by the plugin

*m_HitTransform.rotation = hit.transform.rotation;*}
and the rotation from the transform of the plane collider


*delegate int Calculate (int a, int b);
Calculateデリゲートの宣言

*delegate void Printer (string s);*class Test {public static void Main() {// デリゲートの生成Printer print = new Printer(Console.WriteLine);// デリゲートの実行print("Hello World");}}
デリゲートの宣言

*Printer print = new Printer(Console.WriteLine);
デリゲートの生成

*print("Hello World");
デリゲートの実行

*delegate void Printer (string s);*class Test {public static void Main() {// デリゲートの生成Printer print = delegate (string s) {Console.WriteLine(s);}// デリゲートの実行print("Hello World");// 匿名メソッドはデリゲート変数に代入することも可能print = delegate (string s) {Console.WriteLine($"You inputed \"{s}\"");};print("I'm fine");}}
デリゲートの宣言

*Printer print = delegate (string s) {Console.WriteLine(s);
デリゲートの生成

*print("Hello World");
デリゲートの実行

*print = delegate (string s) {Console.WriteLine($"You inputed \"{s}\"");
匿名メソッドはデリゲート変数に代入することも可能

*}
式

*}
式

*delegate void Printer (string s);*class Test {public static void Main() {Printer print = (string s) => {Console.WriteLine($"You inputed \"{s}\"");};print("I'm fine");}}
デリゲートの宣言


*private void ChangeisOpen()
状態が変わったことを１秒遅れにするためにInvokeメソッド


*private Text mGameOverText;
TextGameOverを指定

*case STATE.LOAD_STAGE:
ステージの生成

*case STATE.WAIT_ENTER_KEY:
Enter入力でゲームを開始

*case STATE.PLAY:
プレイ中

*[SerializeField]
タイムテキスト
---------------------------------------------------------------------------------

*追加        mRestTime = 100;
制限時間を設定

*mConstructor.OnActivePlayer();
プレイヤーとチェイサーの行動開始

*StartCoroutine("PopupFollower");
コルーチンを開始

*private int mRestTime;
制限時間
---------------------------------------------------------------------------------

*mRestTime--;
制限時間終了でプレイヤーをダウン状態へ遷移 → それによってEndGameが呼ばれる

*if (mRestTime == 10) GameController.Instance.UiManager.ChangeTimeTextColorIntoRed();*GameController.Instance.UiManager.RenewTime(mRestTime);
残り時間10秒になったときにテキストの色を赤に変更する


*GL.Ortho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
平行投影


*log4net.GlobalContext.Properties["user"] = "user";
クライアントのユーザーIDを設定する


*return new DowntimeReport[] {GetFailureDowntimeReport("Team01", "Team01POI", date),GetFailureDowntimeReport("Team01", "Team01POI", (date + TimeSpan.FromSeconds(1))),GetFailureDowntimeReport("Team01", "Team01POI", (date + TimeSpan.FromSeconds(2)))};
Normal case failure


*list.Select(x => x * 2);*// { 2, 4, 6, 8, 10 }
{引数} => {処理内容&return}


*var parser = new MimeParser(stream, MimeFormat.Mbox);
パーサを生成

*var message = parser.ParseMessage();
メッセージをパースする

*Console.WriteLine("[From]");
メッセージを使って何かする


*string path2;
out file name


*lookup[2000]
=> 発行年が2000年の book オブジェクト一覧が返る

*var lookup = books.ToLookup(b => b.PublishedYear, b => b.Title);
第二引数にラムダ式を与えることで、値を指定できる

*var dic = books.ToLookup(b => b.PublishedYear)
ToLookup と ToDictionary で2度ループが回る

*var dic = books.GroupBy(b => b.PublishedYear)
GroupBy と ToDictionary なら ループが回るのは ToDictionary の一度だけ


*Func<NamedPipeServerStream> createpipe = delegate() {var ps = new PipeSecurity();ps.AddAccessRule(new PipeAccessRule("Everyone", PipeAccessRights.FullControl, System.Security.AccessControl.AccessControlType.Allow));return new NamedPipeServerStream(this._PipeName, PipeDirection.InOut, 1, PipeTransmissionMode.Message, PipeOptions.Asynchronous, 1024, 1024, ps);};
パイプサーバ作成


*string[] str = Console.ReadLine().Split(' ');
ここで半角スペース区切りで取る


*public string GetString(string resourceKeyName) {return Translator<Properties.Resources>.Translate(resourceKeyName);}
...


*private State mCurrentState;
現在のステート

*if (mSwitchTable.ContainsKey(prevState) && mSwitchTable[prevState].ContainsKey(nextState))
すでにprevStateとnextStateの組み合わせでコールバックが仕込まれていたら
prevStateとnextStateの組み合わせのコールバックは１つのみ

*var p = Expression.Parameter(typeof(S), "target");
次のラムダ式を式木で構築
(S s) => (T)s


*public partial class WebUserControl1 : ViewUserControl*{// ...}
上を下に

*var ctx = new ControllerContext(new RequestContext( httpCtx, rt ), new WebFormController() );
create a controller context for the route and http context

*var vctx = new ViewContext( ctx, view,new ViewDataDictionary { Model = model },new TempDataDictionary() );
create a view context and assign the model


*string returnStr = inst.ReadString();
応答を文字列で取得する


*App.Main();
Run WPF startup code.

*var resourceName = thisAssembly.GetManifestResourceNames().Where(*s => s.EndsWith(dllName, true, null)).FirstOrDefault();
in the same folder as the app.


*this[index] = new T();
初期値

*public virtual IEnumerable<int> GetAllIndexes() {for (int y = 1; y <= this.YSize; y++) {for (int x = 1; x <= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する

*public virtual IEnumerable<int> EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index); index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Horizontal(int x, int y)
(x,y)から右(水平)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Virtical(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantR(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantL(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む

*List<int> list = board.CanPutPlaces(nowPlace).OrderBy(n => board.CanPutPlaces(n).Count()).ToList();*foreach (int pos in list) {board.Jump(pos);// 枝刈り用の処理：この判断が無いととてつもなく遅くなってしまう。if (board[pos] is Footmark fm) {// 開始位置からJumpする場所が無いなら、これ以上探しても意味が無いので次の可能性へ。if ((fm.Number != board.YSize * board.XSize) &&(board.CanPutPlaces(_startPlace).Count() == 0)) {board.Clear(pos);continue;}}// 枝刈り：ここまでvar ans = SolveInner(board, pos);if (ans != null)return ans;board.Clear(pos);}
OrderBy を入れるか入れないかで、圧倒的な速度差が出る

*var ans = SolveInner(board, pos);
枝刈り：ここまで

*return null;
ジャンプできる場所はすべて試した。解は見つからない。


*static T CreateObjBase<T>(int id1, int id2, int id3) where T : ObjBase {var maker = NewObjectHelper<T>.CreateMethod<Func<int, int, int, T>>();return maker(id1, id2, id3);}
引数ありコンストラクターを呼ばせるジェネリックで関数

*static class NewObjectHelper<TInstance> {//使うFunc型から引数の型だけ抜き出すstatic Type[] CreateParameterType<TFunc>() where TFunc : Delegate {//Type.GetGenericArguments()で//ジェネリック型に指定された型を全て取り出せるvar method_use_types = new List<Type>(typeof(TFunc).GetGenericArguments());//使うFunc型の戻り値の型だけ除外var deleteIndex = method_use_types.FindIndex((i) => i == typeof(TInstance));method_use_types.RemoveAt(deleteIndex);return method_use_types.ToArray();}//Type配列から式木用の配列を作成static List<ParameterExpression> CreateParamsListFromTypes(Type[] types) {var paramList = new List<ParameterExpression>(types.Length);foreach (var i in types) paramList.Add(Expression.Parameter(i));return paramList;}//式木を使ってコンストラクタを呼ぶ関数を作成public static TFunc CreateMethod<TFunc>() where TFunc : Delegate {var argsType = CreateParameterType<TFunc>();var paramList = CreateParamsListFromTypes(argsType);var flag = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;var constructor = typeof(TInstance).GetConstructor(flag,Type.DefaultBinder,argsType,null);return Expression.Lambda<TFunc>(Expression.New(constructor, paramList),paramList).Compile();}//式木を使ってコンストラクタを呼ぶ関数を作成////引数のtypeValueで戻り値の型推論をさせるpublic static TFunc CreateMethod<TFunc>(TFunc typeValue) where TFunc : Delegate {var argsType = CreateParameterType<TFunc>();var paramList = CreateParamsListFromTypes(argsType);var flag = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;var constructor = typeof(TInstance).GetConstructor(flag,Type.DefaultBinder,argsType,null);return Expression.Lambda<TFunc>(Expression.New(constructor, paramList),paramList).Compile();}}
TInstanceに戻り値の型を指定

*static Type[] CreateParameterType<TFunc>() where TFunc : Delegate {//Type.GetGenericArguments()で//ジェネリック型に指定された型を全て取り出せるvar method_use_types = new List<Type>(typeof(TFunc).GetGenericArguments());//使うFunc型の戻り値の型だけ除外var deleteIndex = method_use_types.FindIndex((i) => i == typeof(TInstance));method_use_types.RemoveAt(deleteIndex);return method_use_types.ToArray();}
使うFunc型から引数の型だけ抜き出す

*var method_use_types = new List<Type>(typeof(TFunc).GetGenericArguments());
Type.GetGenericArguments()で
ジェネリック型に指定された型を全て取り出せる

*var deleteIndex = method_use_types.FindIndex((i) => i == typeof(TInstance));
使うFunc型の戻り値の型だけ除外

*static List<ParameterExpression> CreateParamsListFromTypes(Type[] types) {var paramList = new List<ParameterExpression>(types.Length);foreach (var i in types) paramList.Add(Expression.Parameter(i));return paramList;}
Type配列から式木用の配列を作成

*public static TFunc CreateMethod<TFunc>() where TFunc : Delegate {var argsType = CreateParameterType<TFunc>();var paramList = CreateParamsListFromTypes(argsType);var flag = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;var constructor = typeof(TInstance).GetConstructor(flag,Type.DefaultBinder,argsType,null);return Expression.Lambda<TFunc>(Expression.New(constructor, paramList),paramList).Compile();}
式木を使ってコンストラクタを呼ぶ関数を作成

*public static TFunc CreateMethod<TFunc>(TFunc typeValue) where TFunc : Delegate {
式木を使ってコンストラクタを呼ぶ関数を作成

引数のtypeValueで戻り値の型推論をさせる

*abstract class ObjBase {public int Id1;public int Id2;public int Id3;public override string ToString() {return  "[" + Id1 + " : " + Id2 + " : " + Id3 + "]";}}
テスト用クラス


*System.Threading.Thread.Sleep(len);
一定時間音を鳴らし続ける


*var pattern = @"\b(\w+?)\s\1\b";
重複した単語を探す


*var primeFactorizes = nums.Select(n => PrimeFactorize(n));
１．各要素の値ごとに、素因数分解

*var dic = LineUpPowerIndex(primeFactorizes);
２．素数リストの各値について、素因数分解した結果から指数を並べる

*var result = Calc(dic);
３．最小公倍数・最大公約数の計算

*var i = 0;
指数の初期化

*i++;
割ったら余りが0の時、指数を+1し、除算

*var plist = new List<int>();
素因数のリスト作成

*primes.ToList().ForEach(p => dic.Add(p, Enumerable.Repeat<int>(0, primeFactorizes.Count()).ToArray()));
素因数のリストと、それに対応する指数の配列作成(初期値0)

*var idx = 0;
素因数分解の結果を反映

*var ar = kv.Value.Select(v => (int)Math.Pow(kv.Key, v)).ToArray();
素因数の指数乗を計算

*leastCommonMultiple = leastCommonMultiple * (ar.Max());
最大値の積→最小公倍数

*greatestCommonDivisor = greatestCommonDivisor * (ar.Min());
最小値の積→最大公約数

*return new Tuple<int, int>(leastCommonMultiple, greatestCommonDivisor);
結果をタプルで返す


*ServicePointManager.DnsRefreshTimeout = 10 * 1000;
10秒に設定


*if (drawPosition >= result.GetLength(0))
マネージリソース(Line bar[])の解放は自動でガベージコレクションが行う

*bar[j].HorizontalAlignment = HorizontalAlignment.Left;
描画する方法 (Brush)を設定
bar[j].Stroke = brush;   System.Windows.Media.Brushes.LightBlue;
(親要素内に作成されるときに適用される)水平方向の配置特性を、(親要素のレイアウトのスロットの)左側に設定

*bar[j].VerticalAlignment = VerticalAlignment.Center;
(親要素内に作成されるときに適用される)垂直方向の配置特性を、(親要素のレイアウトのスロットの)中央に設定

*bar[j].X1 = j * 7 + 32;
始点のx座標を設定

*bar[j].X2 = j * 7 + 32;
終点のx座標を設定

*bar[j].Y1 = 0;
始点のy座標を設定

*bar[j].Y2 = 7700 * result[drawPosition, j];
終点のy座標を設定 (result[,]は、0 ~ 1の値)

*if (bar[j].Y2 >= 400)*bar[j].Y2 = 400;
長さが400より大きい場合は長さを400にする

*bar[j].StrokeThickness = 5;
幅を設定

*grid.Children.Add(bar[j]);
画面にLine(バー)を追加

*barDrawn = true;
描画済みにする


*var mode = Mode.READ;
意図通りのコード

*mode = 4;
想定外の値も入ってしまう!

*mode = 4;
ビルドエラー!!


*private RectTransform myRectTransform;
オブジェクト自身の位置

*void Start () {this.myRectTransform = GetComponent<RectTransform>( );}
Use this for initialization

*void Update () {// マウスカーソルに追尾するかどうかを切り替えるif (Input.GetKeyDown("space")) {this.canMove = !this.canMove;}// 追尾可能ならマウスに追従させるif (this.canMove) {MoveOnMouse(ref this.myRectTransform, Camera.main);}}
Update is called once per frame


*var c = null == CONST;
false


*public const string NICONICO_LOGIN_URL = "https:
secure.nicovideo.jpsecurelogin?site=niconico";

*www.redirectLimit = 0;
これがめっちゃ重要

*Debug.Log(keyNotFoundException.Message);
post情報が間違っててSet-Cookieすら含まれない状態

*//他は"deleted"とsecureなんたらとかいうの。いらない。（知らんけど)*foreach(string cookie in setCookieHeader.Split(new string[] {"user_session="}, StringSplitOptions.None)) {
Set-Cookieヘッダに含まれるuser_sessionは3つあって、そのうち必要なものはuser_sessionから始まる


*if (text.Contains(target))
<-拡張メソッドのほうの Contains


*case 2:
フェードイン


*var sut = new FizzBuzzService();
sut はSystem under testを指す

*public FizzBuzzController(IFizzBuzz fizzbuzz) =>
Startup.cs の設定によりコンストラクタの引数に FizzBuzzService が渡される


*DataTable personTable = new DataTable("PersonTable");
[1] バインドデータ作成
----------------------------------------

*personTable.Columns.AddRange(new DataColumn[]{new DataColumn("ID", typeof(string))
カラム設定

*personTable.Rows.Add(new string[] { "001", "Taro Tanaka", "Male", "Normal Employee" });
データを追加

*this.PersonView.DataSource = new DataView(personTable);
[2] GridViewにバインド
----------------------------------------

*e.Row.Cells[0].RowSpan = 2;
IDセルの行幅を設定


*1000
最大高


*ViewData["CurrentFilterDateFrom"] = dateFrom?.ToString("yyyy-MM-dd") ?? "";
下2行を追加

*public async Task<IActionResult> Index(DateTime? dateFrom, DateTime? dateTo)*{//return View(await _context.Salary.ToListAsync());var refUrl = Request.Headers["Referer"].ToString();var refUri = new System.Uri(refUrl);if (refUri.Segments.Length > 2 && (refUri.Segments[2] == "Details/" || refUri.Segments[2] == "Edit/")){dateFrom = TempData["CurrentFilterDateFrom"] as DateTime?;dateTo = TempData["CurrentFilterDateTo"] as DateTime?;}TempData["CurrentFilterDateFrom"] = dateFrom?.ToString("yyyy-MM-dd") ?? (TempData["CurrentFilterDateFrom"] as DateTime?)?.ToString("yyyy-MM-dd");TempData["CurrentFilterDateTo"] = dateTo?.ToString("yyyy-MM-dd") ?? (TempData["CurrentFilterDateTo"] as DateTime?)?.ToString("yyyy-MM-dd");TempData.Keep();var salaries = from s in _context.Salary select s;salaries = salaries.Where(x => x.RegisterUser == (User.Identity.Name ?? "DUMMY"));if (!(dateFrom == null) && !(dateTo == null)){salaries = salaries.Where(x => x.PaymentDate >= dateFrom && x.PaymentDate <= dateTo);} else if (!(dateFrom == null)){salaries = salaries.Where(x => x.PaymentDate >= dateFrom);} else if (!(dateTo == null)){salaries = salaries.Where(x => x.PaymentDate <= dateTo);}return View(await salaries.ToListAsync());}
GET: Salaries


*.Select( (v,idx) => v.Equals(refer[idx]) ? "" : v)
差分なしは何を返せばいいのか? nullは嫌だ


*Method(map);
キー入力を受け取る->keyInputに格納

*string keyInput = Console.ReadLine();
キー入力を受け付ける


*public int  Dmy3;
予約(0)

*public static BitVector32.Section Mode1     = BitVector32.CreateSection(5);
()内の数値はその区間が使用するビット数
二つ目以降はビット数とそのセクションが始まる直前のセクションを書く

*public void SetConfig(ref _Sel sel){BitVector32 bv = new BitVector32();bv[Mode1]     = sel.Mode1;bv[SelectCh]  = sel.SelectCh;bv[Function1] = sel.Function1;WriteDevice(bv.Data);}
ビットフィールドに構造体をセットする場合

*public void GetConfig(ref _Sel sel)*{int data = 0;ReadDevice(ref data);//インスタンスを作るときに数値を入れるとそのビットフィールドが持つ数値を設定できる．//bv.Dataのアクセサはgetだけなのでインスタンス生成時に引数として入れる必要があるBitVector32 bv = new BitVector32(data);sel.Mode1     = bv[Mode1];sel.SelectCh  = bv[SelectCh];sel.Function1 = bv[Function1];}
ビットフィールドから構造体へセットする場合

*BitVector32 bv = new BitVector32(data);
インスタンスを作るときに数値を入れるとそのビットフィールドが持つ数値を設定できる．
bv.Dataのアクセサはgetだけなのでインスタンス生成時に引数として入れる必要がある


*this[index] = new T();
初期値

*public virtual IEnumerable<int> GetAllIndexes() {for (int y = 1; y <= this.YSize; y++) {for (int x = 1; x <= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する

*public virtual IEnumerable<int> EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index) && this[index] != null; index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Horizontal(int x, int y)
(x,y)から右(水平)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Virtical(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantR(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantL(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む


*Console.WriteLine(hhmmss);
14:50:21


*var list = Enumerable.Range(1, 10);
対象のコレクション

*var chunkSize = 3;*var chunks = list.Select((v, i) => new { v, i })
N 個ずつの N


*_dic.Add(this.button1, this.panel1);
ボタンとパネルの組み合わせを登録

*AddEvent();
ボタンのクリックイベント登録

*SelectPanel(this.button1);
画面初期表示時はボタン1を選択

*button.BackColor = Color.DarkBlue;
選択時

*button.BackColor = Color.Gray;
選択されていない時

*this.Controls.Add(this.panel3);
行の順番を変えるとデザイナ上のパネルの表示順が変わる

*_dic.Add(this.button1, this.panel1);
例：button1をクリックしたらpanel1を表示

*private void button1_Click(object sender, EventArgs e)*{// パネル1を表示button1.BackColor = Color.DarkBlue;button1.ForeColor = Color.White;panel1.Visible = true;// パネル2を非表示button2.BackColor = Color.Gray;button2.ForeColor = Color.Black;panel2.Visible = false;// パネル3を非表示button3.BackColor = Color.Gray;button3.ForeColor = Color.Black;panel3.Visible = false;}
ボタン1をクリック

*button1.BackColor = Color.DarkBlue;
パネル1を表示

*button2.BackColor = Color.Gray;
パネル2を非表示

*button3.BackColor = Color.Gray;
パネル3を非表示


*Array.Clear(_items, 0, size);
Clear the elements so that the gc can reclaim the references.


*Console.CancelKeyPress += Console_CancelKeyPress;
中断の割り込みがあったときのイベントを受け取る

*Console.WriteLine(DateTime.Now);
動いてるアピール

*Thread.Sleep(5000);
何か時間のかかる処理のつもり

*Console.WriteLine("Ctrl+C");
中断を受け付けましたアピール

*running = false;
もう頑張らなくていいことをメイン処理に伝える

*e.Cancel = true;
今は終わらんよと伝える


*var num = 1;
int型に

*var strList = new List<string>() { };
List<string>型に

*}
処理

*return "async!";
何か重い処理

*arr.Any(s => s == "a");
含んでいるか

*arr.Where(s => s.Length >= 2);*// IEnumerable<string> { "bb", "ccc" }
絞り込み

*arr.Select(s => s + s);*// IEnumerable<string> { "aa", "bbbb", "cccccc" }
射影


*cameraPivot.transform.GetComponent<Rigidbody>().AddTorque(new Vector3(5f, 5f, 5f));*}
5,5,5!な斜め方向に。

*cameraPivot.transform.GetComponent<Rigidbody>().AddTorque(new Vector3(-5f, -5f, -5f));*}
-5,-5,-5!な斜め方向に。⇒右クリックで回転を止める

*//if (OVRInput.IsControllerConnected(OVRInput.Controller.RTrackedRemote))*// GetMouseButtonDownで、UnityEditor上で動作確認できます。
接続確認したいとか

*cameraPivot.transform.GetComponent<Rigidbody>().AddTorque(new Vector3(5f, 5f, 5f));*}
5,5,5!な斜め方向に。

*cameraPivot.transform.GetComponent<Rigidbody>().AddTorque(new Vector3(-10f, -10f, -10f));*}
-10,-10,-10!な斜め方向に。⇒右クリックで回転を止める

*public QueryAnimationController queryAnim = null;
クエリちゃん設定

*public GameObject cameraPivot = null;
回転対象

*UnityEngine.XR.XRSettings.eyeTextureResolutionScale = 1.25f;
【Unite Tokyo 2018】Oculusで作るスタンドアローン・モバイルVRコンテンツ
https:www.slideshare.net/UnityTechnologiesJapan002/unite-tokyo-2018oculusvr-96453609/UnityTechnologiesJapan002/unite-tokyo-2018oculusvr-96453609
上記スライドを参考にした設定
アイバッファ解像度 scale 1.0 == 1024x1024

*OVRManager.tiledMultiResLevel = OVRManager.TiledMultiResLevel.LMSLow;
外枠側のレンダリング設定。>>HIGH　外側の解像度が減っていく

*OVRManager.display.displayFrequency = 72.0f;
72Hzモード（フレームレートは上がるが綺麗）

*queryAnim.ChangeAnimation(QueryAnimationController.QueryChanAnimationType.FLY_IDLE);
浮いてるアニメーション再生

*cameraPivot.transform.GetComponent<Rigidbody>().AddTorque(new Vector3(5f, 5f, 5f));*}
5,5,5!な斜め方向に。

*//if (OVRInput.IsControllerConnected(OVRInput.Controller.RTrackedRemote))*// GetMouseButtonDownで、UnityEditor上で動作確認できます。
接続確認したいとか


*private enum STATE
状態
---------------------------------------------------------------------------------

*void Update()
更新
---------------------------------------------------------------------------------

*case STATE.LOAD_STAGE:
ステージの生成

*case STATE.PLAY:
プレイ中

*//---------------------------------------------------------------------------------*public bool IsGameOver { get; set; }
フラグ

*public bool IsGameOver { get; set; }
---------------------------------------------------------------------------------

*mConstructor.OnActivePlayer();
プレイヤーとチェイサーの行動開始

*StartCoroutine("PopupFollower");
コルーチンを開始

*case STATE.LOAD_STAGE:
ステージの生成

*追加            case STATE.WAIT_ENTER_KEY:
Enter入力でゲームを開始

*case STATE.PLAY:
プレイ中

*private bool WaitEnter()
入力
---------------------------------------------------------------------------------

*mConstructor.OffActiveChaser();
チェイサーを除去

*StopAllCoroutines();
コルーチン終了

*GameController.Instance.IsGameOver = true;
フラグを立てる

*public void OnRestartButton()
シーン管理
---------------------------------------------------------------------------------

*case STATE.LOAD_STAGE:
ステージの生成

*case STATE.WAIT_ENTER_KEY:
Enter入力でゲームを開始

*case STATE.PLAY:
プレイ中


*<dd:DragDrop.DragAdornerTemplate>
Adornerを変更するところ


*追加    private FollowCamera mFollowCameraMinimap;
MinimapCameraを指定


*private Rigidbody sphere;
バウンドさせたいオブジェクトを宣言

*private void OnCollisionEnter(Collision collision){//Y軸方向に常に同じ力を与えるsphere.AddForce(Vector3.up*10f,ForceMode.Impulse);}
sphereに触れた時のメソッド

*sphere.AddForce(Vector3.up*10f,ForceMode.Impulse);
Y軸方向に常に同じ力を与える


*private string property1;
フィールド

*public string Property1*{set{this.property1 = value;}get{return this.property1;}}
プロパティ

*public string Attribute1 { set; get; }
プロパティ

*public string attribute1;
フィールド

*private string attribute1;
フィールド

*public string Attribute1*{set{this.attribute1 = value;}get{return this.attribute1;}}
プロパティ


*await Task.Delay(1000).ConfigureAwait(false);
←重要


*DateTime inputTime;
日付パースできなければNG

*var now = DateTime.Now;*if (now.Subtract(inputTime).Minutes > permitMinutes) { return false; }
現在日付 > 渡された日付の場合

*var inputTimeMax = inputTime.AddSeconds(59).AddMilliseconds(999);*if (inputTimeMax.Subtract(now).Minutes > permitMinutes) { return false; }
現在日付 < 渡された日付の場合


*public string[] scenarios;
住人の話す内容

*public GameObject heart;
プレイヤーが一定範囲内に入ったら会話できるサインを表すオブジェクト

*bool Aflagflag = false;
プレイヤーが範囲内にいるかどうかの判定

*iventScript.StartIvent (Aflagflag, scenarios);
IventScriptのStartIventメソッドに会話が可能な状態であることを示すフラグと、住人の話す内容を送る。

*heart.transform.position = gameObject.transform.position + new Vector3 (-0.5f, 1f, 0);*heart.SetActive (true);
住人の頭上にオブジェクトを表示(座標は自由に変えてください)

*Aflagflag = false;
プレイヤーが範囲外に出たら会話しない。

*bool flag2=false;
CharacterScriptから送られてきたAflagflagの格納用

*string[] scenarios2;*public void StartIvent (bool flag,string[] scenarios) {flag2 = flag;scenarios2 = scenarios;}
CharacterScriptから送られてきたscenariosの格納用

*private string[] scenarios2;
シナリオを格納

*private Text uiText;
uiTextへの参照を保つ

*int currentLine;
現在の行番号

*public Text message;
セリフを表示するテクスト(文字の大きさや色はここにアタッチしたTextをいじって決定する)

*public GameObject panel;
テキストウィンドウ

*public void StartText (string[] scenarios) {flag=1;scenarios2=scenarios;currentLine = 0;uiText = message;//パネルを表示panel.SetActive (true);//テクストを表示uiText.gameObject.SetActive (true);TextUpdate ();}
Use this for initialization

*panel.SetActive (true);
パネルを表示

*uiText.gameObject.SetActive (true);
テクストを表示

*uiText.gameObject.SetActive (false);
最後まで行ったら、テキストとテキストウィンドウを消す

*uiText.text = scenarios2 [currentLine];
現在の行番号をuiTextに流し込み、現在の行番号を一つ追加する


*public static string scientificName;
インスタンス化してもPersonは皆ホモサピエンスで変わらない。

*public class MyBaseC*{public struct MyStruct{public static int x = 100;}}
例


*// 1. 配列を初期化*float[] weights = { 61.2f, 62.5f, 64.9f, 63.2f, 65.1f, 63.6f, 67.9f };
foreachを使って、配列の値をすべて表示する

*float[] weights = { 61.2f, 62.5f, 64.9f, 63.2f, 65.1f, 63.6f, 67.9f };
1. 配列を初期化

*//foreach (型名 変数名 in 配列名)*foreach (float w in weights)
2. foreachを回す


*using System.Collections.Generic;
以下の名前空間を追加

*Dictionary<string, float> weights = new Dictionary<string, float>();
Dictionaryを使い日付と体重データを保持する例
1. Dictionary型の変数を作る

*weights.Add("2017/12/10", 62.6f);
2. Dictionaryに要素を追加

*Console.WriteLine(weights["2017/12/13"]);
3. 2017/12/13の体重を表示


*// 1. 配列を初期化*float[] weights = { 61.2f, 62.5f, 64.9f, 63.2f, 65.1f, 63.2f, 65.1f, 63.2f, 62.7f };
1週間分の体重データから最大値を求める例

*float[] weights = { 61.2f, 62.5f, 64.9f, 63.2f, 65.1f, 63.2f, 65.1f, 63.2f, 62.7f };
1. 配列を初期化

*float max = 0.0f;
2. 最も重い体重を記憶する変数"max"を用意

*Console.WriteLine("最大値は" + max + "です");
5. 出力


*using System.Linq;
Listを使う際には以下を宣言する

*List<float> weights = new List<float>();
1週間分の体重で3日目の体重データを削除してから表示する例
1. List型の変数を作る

*weights.Add(61.2f);
2. Listに要素を追加する

*weights.RemoveAt(2);
例：weights[1] = 61.2f
3. Listの先頭から3番目を削除する

*}
weights.Add(71.2f);が消えている！


*using System.Linq;
Listを使う際には以下を宣言する

*List<float> weights = new List<float>();
Listは簡単に並び替えができる
リスト名.Sort();で並び替えができる
1週間分の体重データで軽い順にベスト3を表示する例
1. List型の変数を作る
ここでは、リスト名：weights

*weights.Add(61.2f);
2. Listに要素を追加する

*weights.Sort();
例：weights[1] = 61.2f
3. 小さい順に並び替える


*if (countOfPlayerRank == 53) { break; }
52位まで決まったらメインループを抜け出す


*mRigid.isKinematic = false;
物理挙動を一時的に有効にする

*private readonly string TAG_CHASER = "Chaser";
当たり判定
---------------------------------------------------------------------------------

*SetSpeed();
速度を再設定


*if (countOfPlayerRank > 52) { break; }
52位まで決まったらメインループを抜け出す


*this[index] = new T();
初期値

*public virtual IEnumerable<int> GetAllIndexes() {for (int y = 1; y <= this.YSize; y++) {for (int x = 1; x <= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する

*public virtual IEnumerable<int> EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index) && this[index] != null; index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Horizontal(int x, int y)
(x,y)から右(水平)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Virtical(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantR(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantL(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む


*public class EventManager : SingletonMonoBehaviour<EventManager> {//初期値を２０に設定public static float ene = 20;//energyの書き込みpublic void setScore (float n){ene = n;}//energyの取得public float getScore(){return ene;}}
EventManagerをシングルトンにする

*public static float ene = 20;
初期値を２０に設定

*public void setScore (float n){ene = n;}
energyの書き込み

*public float getScore(){return ene;}
energyの取得

*private static float maxbarHp = 300f;
barのマックスの値を３００に設定

*private float Hp;
energyをこのスクリプトではHpと呼ぶことにする

*float Hp = EventManager.Instance.getScore ();
EventManagerからスコアを取得

*HpSlider = this.GetComponent<Slider>();
barの中の位置を取得

*HpSlider.value = (float)Hp/ (float)maxbarHp;
barの最大の長さを１としているので、長さはHp/300ということになる

*EventManager.Instance.setScore (Hp);
EventManagerに値を返す(不要かも)

*void Update () {//EventManagerからスコアを取得float Hp = EventManager.Instance.getScore ();//エネルギー自動減少(私のゲームでの設定)Hp -= Time.deltaTime;EventManager.Instance.setScore (Hp);//下の関数を実行(あとで使うのでとりあえず書いておく)UpdateHpValue ();//energyがゼロになったらゲームオーバーシーンになる(私のゲームでの設定)if (Hp <= 0) {SceneManager.LoadScene (GameOver);}}
Update is called once per frame

*float Hp = EventManager.Instance.getScore ();
EventManagerからスコアを取得

*Hp -= Time.deltaTime;
エネルギー自動減少(私のゲームでの設定)

*UpdateHpValue ();
下の関数を実行(あとで使うのでとりあえず書いておく)

*public void UpdateHpValue(){var Hp = EventManager.Instance.getScore ();HpSlider.value = (float)Hp / (float)maxbarHp;,,,public GameObject edgepoint;//５ｐ泡を取った時public void EneUp5(){//EventManagerからスコアを取得、５点追加var Hp = EventManager.Instance.getScore ();Hp += 5f;//大事！！！//パッと表示させたいImageを、edgepointの子としてInstantiateImage bubbleP5 = Instantiate(plus5, Vector3.zero, Quaternion.identity) as Image;bubbleP5.transform.SetParent (edgepoint.transform, false);//１．５秒後にDestroy。同時にtextも消去Text txt5 =bubbleP5.GetComponentInChildren<Text>();Destroy (bubbleP5, 1.5f);Destroy (txt5, 1.5f);bubbleP5 = null;txt5 = null;//energyをEventManagerに返すEventManager.Instance.setScore (Hp);}//Hp表示用アップデートpublic void UpdateHpValue(){var Hp = EventManager.Instance.getScore ();HpSlider.value = (float)Hp / (float)maxbarHp;Text energycount = this.GetComponentInChildren<Text> ();energycount.text= Hp.ToString("f0");,,,using UnityEngine;using System.Collections;using UnityEngine.UI;public class BubbleScript : MonoBehaviour {private GameObject energybar;private HpController hpController;// Use this for initializationvoid Start () {//barを見つけるGameObject energybar = GameObject.Find ("EnergyBar");//barに付けるスクリプトHpControllerを見つけるhpController = energybar.GetComponentInChildren<HpController>();}//Playerにぶつかったときの反応void OnTriggerEnter (Collider col){if (col.tag == "Player") {//HpControllerに"Eneup"を実行するように指示hpController.SendMessage ("EneUp5");//HpControllerに"UpdateHpValue"を実行するように指示hpController.SendMessage("UpdateHpValue");//ぶつかった泡(このスクリプトがついているgameobject)をDestroyするDestroy(this.gameObject);}}},,,*public void EneUp5(){//EventManagerからスコアを取得、５点追加var Hp = EventManager.Instance.getScore ();Hp += 5f;//大事！！！//パッと表示させたいImageを、edgepointの子としてInstantiateImage bubbleP5 = Instantiate(plus5, Vector3.zero, Quaternion.identity) as Image;bubbleP5.transform.SetParent (edgepoint.transform, false);//１．５秒後にDestroy。同時にtextも消去Text txt5 =bubbleP5.GetComponentInChildren<Text>();Destroy (bubbleP5, 1.5f);Destroy (txt5, 1.5f);bubbleP5 = null;txt5 = null;//energyをEventManagerに返すEventManager.Instance.setScore (Hp);}//Hp表示用アップデートpublic void UpdateHpValue(){var Hp = EventManager.Instance.getScore ();HpSlider.value = (float)Hp / (float)maxbarHp;Text energycount = this.GetComponentInChildren<Text> ();energycount.text= Hp.ToString("f0");,,,using UnityEngine;using System.Collections;using UnityEngine.UI;public class BubbleScript : MonoBehaviour {private GameObject energybar;private HpController hpController;// Use this for initializationvoid Start () {//barを見つけるGameObject energybar = GameObject.Find ("EnergyBar");//barに付けるスクリプトHpControllerを見つけるhpController = energybar.GetComponentInChildren<HpController>();}//Playerにぶつかったときの反応void OnTriggerEnter (Collider col){if (col.tag == "Player") {//HpControllerに"Eneup"を実行するように指示hpController.SendMessage ("EneUp5");//HpControllerに"UpdateHpValue"を実行するように指示hpController.SendMessage("UpdateHpValue");//ぶつかった泡(このスクリプトがついているgameobject)をDestroyするDestroy(this.gameObject);}}},,,*var Hp = EventManager.Instance.getScore ();
EventManagerからスコアを取得、５点追加

*Image bubbleP5 = Instantiate(plus5, Vector3.zero, Quaternion.identity) as Image;
大事！！！
パッと表示させたいImageを、edgepointの子としてInstantiate

*Text txt5 =bubbleP5.GetComponentInChildren<Text>();
１．５秒後にDestroy。同時にtextも消去

*EventManager.Instance.setScore (Hp);
energyをEventManagerに返す

*public void UpdateHpValue(){var Hp = EventManager.Instance.getScore ();HpSlider.value = (float)Hp / (float)maxbarHp;Text energycount = this.GetComponentInChildren<Text> ();energycount.text= Hp.ToString("f0");,,,using UnityEngine;using System.Collections;using UnityEngine.UI;public class BubbleScript : MonoBehaviour {private GameObject energybar;private HpController hpController;// Use this for initializationvoid Start () {//barを見つけるGameObject energybar = GameObject.Find ("EnergyBar");//barに付けるスクリプトHpControllerを見つけるhpController = energybar.GetComponentInChildren<HpController>();}//Playerにぶつかったときの反応void OnTriggerEnter (Collider col){if (col.tag == "Player") {//HpControllerに"Eneup"を実行するように指示hpController.SendMessage ("EneUp5");//HpControllerに"UpdateHpValue"を実行するように指示hpController.SendMessage("UpdateHpValue");//ぶつかった泡(このスクリプトがついているgameobject)をDestroyするDestroy(this.gameObject);}}},,,*void Start () {//barを見つけるGameObject energybar = GameObject.Find ("EnergyBar");//barに付けるスクリプトHpControllerを見つけるhpController = energybar.GetComponentInChildren<HpController>();}//Playerにぶつかったときの反応void OnTriggerEnter (Collider col){if (col.tag == "Player") {//HpControllerに"Eneup"を実行するように指示hpController.SendMessage ("EneUp5");//HpControllerに"UpdateHpValue"を実行するように指示hpController.SendMessage("UpdateHpValue");//ぶつかった泡(このスクリプトがついているgameobject)をDestroyするDestroy(this.gameObject);}}},,,*GameObject energybar = GameObject.Find ("EnergyBar");
barを見つける

*hpController = energybar.GetComponentInChildren<HpController>();
barに付けるスクリプトHpControllerを見つける

*void OnTriggerEnter (Collider col){if (col.tag == "Player") {//HpControllerに"Eneup"を実行するように指示hpController.SendMessage ("EneUp5");//HpControllerに"UpdateHpValue"を実行するように指示hpController.SendMessage("UpdateHpValue");//ぶつかった泡(このスクリプトがついているgameobject)をDestroyするDestroy(this.gameObject);}}},,,*hpController.SendMessage ("EneUp5");
HpControllerに"Eneup"を実行するように指示

*hpController.SendMessage("UpdateHpValue");
HpControllerに"UpdateHpValue"を実行するように指示

*Destroy(this.gameObject);
ぶつかった泡(このスクリプトがついているgameobject)をDestroyする


*var option = new ExpandPropertyOptions(){MaxReferenceLevel=2};
2階層目までOK


*public class move : MonoBehaviour {GameObject player;//  動かしたいプレイヤーbool right = false;//  右ボタンを押しているかの真偽値bool left = false;//  左ボタンを押しているかの真偽値// Use this for initializationvoid Start () {}// Update is called once per framevoid Update () {if (right) {goright ();//          右に動かすためのメソッドを呼び出す}else if (left) {goleft ();//          左に動かすためのメソッドを呼び出す} else {//          ボタンを押していない時transform.rotation = Quaternion.Euler (0, 0, 0);//          プレイヤーを元の角度に戻す}}public void rPushDown(){//      右ボタンを押している間right = true;}public void rPushUp(){//      右ボタンを押すのをやめた時right = false;}public void lPushDown(){//      左ボタンを押している間left = true;}public void lPushUp(){//      左ボタンを押すのをやめた時left = false;}public void goright(){if (transform.position.x <= 5.0f) {//          プレイヤーの位置が5.0f以下の時//          ↑画面からはみ出さないための条件transform.position += new Vector3 (5.0f * Time.deltaTime, 0, 0);//          プレイヤーをx軸方向に秒速5.0fで動かすtransform.rotation = Quaternion.Euler (0, -20, -10);//          プレイヤーの角度をy軸周りに-20度、z軸周りに-10度回転させる//          ↑プレイヤーがグッと肩を入れて移動してる感を出す、この一文は無くても問題なし}}public void goleft(){if (transform.position.x >= -5.0f) {//          プレイヤーの位置が-5.0f以上の時//          ↑画面からはみ出さないための条件transform.position += new Vector3 (-5.0f * Time.deltaTime, 0, 0);//          プレイヤーをx軸方向に秒速-5.0fで動かすtransform.rotation = Quaternion.Euler (0, 20, 10);//          プレイヤーの角度をy軸周りに20度、z軸周りに10度回転させる//          ↑プレイヤーがグッと肩を入れて移動してる感を出す、この一文は無くても問題なし}}}
UIを使うときのおまじない、忘れずに書く

*bool right = false;
動かしたいプレイヤー

*bool left = false;
右ボタンを押しているかの真偽値

*void Start () {}
Use this for initialization

*void Update () {if (right) {goright ();//          右に動かすためのメソッドを呼び出す}else if (left) {goleft ();//          左に動かすためのメソッドを呼び出す} else {//          ボタンを押していない時transform.rotation = Quaternion.Euler (0, 0, 0);//          プレイヤーを元の角度に戻す}}
Update is called once per frame

*} else {
左に動かすためのメソッドを呼び出す

*transform.rotation = Quaternion.Euler (0, 0, 0);*//          プレイヤーを元の角度に戻す
ボタンを押していない時

*}
プレイヤーを元の角度に戻す

*right = true;
右ボタンを押している間

*right = false;
右ボタンを押すのをやめた時

*left = true;
左ボタンを押している間

*left = false;
左ボタンを押すのをやめた時

*transform.position += new Vector3 (5.0f * Time.deltaTime, 0, 0);
プレイヤーの位置が5.0f以下の時
↑画面からはみ出さないための条件

*transform.rotation = Quaternion.Euler (0, -20, -10);*//          プレイヤーの角度をy軸周りに-20度、z軸周りに-10度回転させる
プレイヤーをx軸方向に秒速5.0fで動かす

*}
プレイヤーの角度をy軸周りに-20度、z軸周りに-10度回転させる
↑プレイヤーがグッと肩を入れて移動してる感を出す、この一文は無くても問題なし

*transform.position += new Vector3 (-5.0f * Time.deltaTime, 0, 0);
プレイヤーの位置が-5.0f以上の時
↑画面からはみ出さないための条件

*transform.rotation = Quaternion.Euler (0, 20, 10);*//          プレイヤーの角度をy軸周りに20度、z軸周りに10度回転させる
プレイヤーをx軸方向に秒速-5.0fで動かす

*}
プレイヤーの角度をy軸周りに20度、z軸周りに10度回転させる
↑プレイヤーがグッと肩を入れて移動してる感を出す、この一文は無くても問題なし


*pipeline.Add(new TextLoader<WineQualityData>(trainDataPath, useHeader: true, separator: ";"));
データファイルのロード

*pipeline.Add(new ColumnCopier((nameof(WineQualityData.Quality), "Label")));
予測列の定義
予測したい列を "Label" という名前で作成
タプルとして定義している点に注意

*pipeline.Add(new ColumnConcatenator("Features",
学習に用いるデータの定義
"Features" という名前で、各列を一つにまとめる

*pipeline.Add(new FastTreeRegressor());
アルゴリズムの定義

*var model = pipeline.Train<WineQualityData, WineQualityPrediction>();
学習を実施しモデルを作成

*var testData = new TextLoader<WineQualityData>(testDataPath, useHeader: true, separator: ";");
評価用データのロード

*var evaluator = new RegressionEvaluator();
評価用のクラスの生成

*var metrics = evaluator.Evaluate(model, testData);
評価の実行

*Console.WriteLine($"Rms={metrics.Rms}");
評価指標の出力

*var data = SplitData(@".\Data\winequality-red.csv", 7);
データの分割

*var model = Train(data.trainDataPath);
学習

*Evalute(model, data.testDataPath);
評価


*private float mSpeed;
現在の速度

*if (!SearchAround(1.5f)) mIsExcited = false;*}
プレイヤーが索敵できなくなった場合は非活性状態へ遷移

*GameObject player = GameController.Instance.StageManager.GetPlayer();
目的地を設定
---------------

*mAgent.SetDestination(player.transform.position);*}
活性状態の場合はプレイヤーを追従

*Vector3? temp = player.GetComponent<PlayerRaycastPoint>().GetDestinationPoint();
非活性状態の場合はプレイヤー進行方向へ先回り

*mPatrolPosList = GameController.Instance.StageManager.GetPatrolPosList();
リストをシャッフルすれば巡回するポイントの順番をランダムに決定可能

*if (!SearchAround(2.0f)) mIsExcited = false;*}
プレイヤーが索敵できなくなった場合は非活性状態へ遷移

*GameObject player = GameController.Instance.StageManager.GetPlayer();
目的地を設定
---------------

*mAgent.SetDestination(player.transform.position);*}
活性状態の場合はプレイヤーを追従

*mPatrolIndex = 0;
初回は目標地点がないためプレイヤー座標を仮に設定する

*if (mAgent.remainingDistance >= 3.0f) newTarget = false;
新しい目標が決定した直後は3.0f離れるまで到達判定を行わない
これをしないと前回の目標地点が到達判定で使用されて次の目標地点が飛ばされる場合がある


*using NCMB;
忘れないように

*string path;
パスとファイル名

*List<NCMBObject> saveDataList;
セーブデータ

*player.PlayerName = "アズマ1";
テスト用に値書き換え,バックアップされる

*SavePlayer();
セーブ

*player.PlayerName = "アズマ2";
テスト用に値書き換え,バックアップされてない

*loadSaveData();
バックアップのロード、savedata.jsonに上書き

*player = SaveData.GetClass<Player>("Player", new Player());
savedata.jsonからロード

*Debug.Log("player.PlayerName = " + player.PlayerName);
値変更確認,バックアップされた「アズマ1」が出力されれば成功

*void SavePlayer(){SaveData.SetClass<Player>("Player", player);SaveData.Save();}
JsonUtilityでセーブ

*string NCMBFileName = Application.companyName + "." + Application.productName + ".savedata" + "-" + DateTime.Now.Year+DateTime.Now.Month+DateTime.Now.Day+DateTime.Now.Hour+DateTime.Now.Minute+DateTime.Now.Second;
ファイル名重複を避けるためファイル名を日付＋乱数で生成

*}
失敗
Debug.Log("UploadPlayer : 失敗"); 追記

*}
成功
Debug.Log("UploadPlayer : 成功"); 追記

*AddRecord(NCMBFileName);
バックアップレコードを追加

*void AddRecord(string filename)*{NCMBObject obj = new NCMBObject("SaveData");obj.Add("username", PlayerPrefs.GetString(userNameKey, ""));obj.Add("savedatafile", filename);obj.Add("date", DateTime.Now.Date);obj.Save((NCMBException e) => {if (e != null){Debug.Log("save data error");showError(e);}else{//成功時の処理Debug.Log("UpdateSaveData : 成功");}});}
バックアップの更新

*Debug.Log("UpdateSaveData : 成功");
成功時の処理

*void loadSaveData()*{saveDataList = new List<NCMBObject>();//QueryTestを検索するクラスを作成NCMBQuery<NCMBObject> query = new NCMBQuery<NCMBObject>("SaveData");//ユーザー名で抽出query.WhereEqualTo("username", PlayerPrefs.GetString(userNameKey, ""));//ソートkeyを設定query.OrderByDescending("createDate");//検索結果を取得query.FindAsync((List<NCMBObject> objList, NCMBException e) => {if (e != null){//検索失敗時の処理Debug.Log("loadSaveData : 失敗");}else{Debug.Log("loadSaveData : 成功");//最新のファイルを読み込むDebug.Log(objList[0]["username"] + " " + objList[0]["savedatafile"]);LoadSaveFile(objList[0]["savedatafile"].ToString());}});}
ファイル名を取得, ファイルを取得, 読み込む

*NCMBQuery<NCMBObject> query = new NCMBQuery<NCMBObject>("SaveData");
QueryTestを検索するクラスを作成

*query.WhereEqualTo("username", PlayerPrefs.GetString(userNameKey, ""));
ユーザー名で抽出

*query.OrderByDescending("createDate");
ソートkeyを設定

*query.FindAsync((List<NCMBObject> objList, NCMBException e) => {if (e != null){//検索失敗時の処理Debug.Log("loadSaveData : 失敗");}else{Debug.Log("loadSaveData : 成功");//最新のファイルを読み込むDebug.Log(objList[0]["username"] + " " + objList[0]["savedatafile"]);LoadSaveFile(objList[0]["savedatafile"].ToString());}});
検索結果を取得

*Debug.Log("loadSaveData : 失敗");
検索失敗時の処理

*Debug.Log(objList[0]["username"] + " " + objList[0]["savedatafile"]);
最新のファイルを読み込む

*void LoadSaveFile(string Name)*{NCMBFile file = new NCMBFile(Name);file.FetchAsync((byte[] fileData, NCMBException error) => {if (error != null){// 失敗Debug.Log("LoadSaveFile : 失敗");}else{//成功Debug.Log("LoadSaveFile : 成功");SaveBytesTo(fileData);}});}
SaveDataファイルを取得

*Debug.Log("LoadSaveFile : 失敗");
失敗

*Debug.Log("LoadSaveFile : 成功");
成功

*void SaveBytesTo(byte[] b)*{Debug.Log("SaveBytesTo");//UTF8 エンコードでbyteからstringへstring text = System.Text.Encoding.UTF8.GetString(b);//上書きStreamWriter writer = new StreamWriter(path + fileName, false, Encoding.GetEncoding("utf-8"));writer.WriteLine(text);writer.Close();}
Byteデータをsavedata.jsonに書き込む

*string text = System.Text.Encoding.UTF8.GetString(b);
UTF8 エンコードでbyteからstringへ

*StreamWriter writer = new StreamWriter(path + fileName, false, Encoding.GetEncoding("utf-8"));
上書き

*using System.Collections.Generic;
テスト用ClassをまとめたScript
class構成が大きな影響を与えることはないと思われるので、任意に書き換えてOK

*public Item(string name, int id)*{Name = name;Id = id;}
コンストラクタ

*[System.Serializable]
※Skillクラスは各skillに継承される

*public Skill(string name, int id)*{Name = name;Id = id;}
コンストラクタ

*public Fire(string name, int id) : base(name, id)*{Name = name;Id = id;}
継承クラスのコンストラクタはこう書く

*public Ice(string name, int id) : base(name, id)*{Name = name;Id = id;}
継承クラスのコンストラクタはこう書く

*public Poison(string name, int id) : base(name, id)*{Name = name;Id = id;}
継承クラスのコンストラクタはこう書く


*private void AsyncSample(string argText)
引数は最低一つ必要なだけなので値はなんでもよい

*Thread.Sleep(3000);
実際にはここに時間のかかる処理が入る。今回はwaitで代用

*using (StreamWriter sw = new StreamWriter(localFolderPath)){sw.Write("処理が完了しました");
ローカルファイルに書き込む

*using (StreamReader sr = new StreamReader(localFolderPath)){TempData["message"] = sr.ReadLine();
ローカルファイルを見に行く

*[HttpGet]
↓は今回使ってないけどこいうやり方もあるので勉強して別途記事を書きたい ----


*public class DataReceivedEventArgs : EventArgs
使い方
宣言
TcpServer.ClassTcpServer classTcpServer = new TcpServer.ClassTcpServer();
初期化、スタート
classTcpServer.ipaddress = "0.0.0.0";
classTcpServer.port = 49152;
classTcpServer.timerinterval = 100;
classTcpServer.DataReceived += new TcpServer.ClassTcpServer.DataReceivedEventHandler(TcpServer_DataReceived);
classTcpServer.Start();
停止
classTcpServer.Stop();
イベントハンドラ
private void TcpServer_DataReceived(object sender, TcpServer.DataReceivedEventArgs e)
{
イベントが発生したとき
textBox1.AppendText(e.Message + Environment.NewLine);
}

*listener = new System.Net.Sockets.TcpListener(System.Net.IPAddress.Parse(ipaddress), port);
TcpListenerオブジェクトを作成する

*listener.Start();
Listenを開始する

*timer.Interval = timerinterval;
タイマスタート

*timer.Stop();
タイマストップ

*listener.Stop();
リスナを閉じる

*System.Net.Sockets.TcpClient client = listener.AcceptTcpClient();
接続要求があったら受け入れる

*System.Net.Sockets.NetworkStream ns = client.GetStream();
NetworkStreamを取得

*ns.ReadTimeout = 10000;
読み取り、書き込みのタイムアウト
デフォルトはInfiniteで、タイムアウトしない
(.NET Framework 2.0以上が必要)

*System.Text.Encoding enc = System.Text.Encoding.UTF8;
クライアントから送られたデータを受信する

*resSize = ns.Read(resBytes, 0, resBytes.Length);
データの一部を受信する

*ms.Write(resBytes, 0, resSize);
受信したデータを蓄積する

*} while (ns.DataAvailable || resBytes[resSize - 1] != '\n');
まだ読み取れるデータがあるか、データの最後が\nでない時は、
受信を続ける

*string resMsg = enc.GetString(ms.GetBuffer(), 0, (int)ms.Length);
受信したデータを文字列に変換

*resMsg = resMsg.TrimEnd('\n');
末尾の\nを削除

*DataReceivedEventArgs ee = new DataReceivedEventArgs();
イベント発生して呼び出し元にデータを返す

*string sendMsg = resMsg.Length.ToString();
クライアントにデータを送信する
クライアントに送信する文字列を作成

*byte[] sendBytes = enc.GetBytes(sendMsg + '\n');
文字列をByte型配列に変換

*ns.Write(sendBytes, 0, sendBytes.Length);
データを送信する

*ns.Close();
閉じる


*private readonly float THICKNES_HALF = 0.05f;
四方を囲む壁の厚さの半分


*IEnumerator Start()
アプリ起動時に呼ばれるメソッド (オートログイン)
---------------------------------------------------------------------------------------------

*string userName = PlayerPrefs.GetString(userNameKey, "");
Unity(端末)に保存された `ユーザ名` と `パスワード` を取得 (保存されていない場合は空文字で初期化)

*Debug.Log("No User Info on Unity");
保存なし -> ユーザ登録処理

*yield return StartCoroutine(loginCoroutine(userName, password));
ログインしていない -> ログイン処理

*const string letters = "abcdefghijklmnopqrstuvwxyz1234567890";
任意文字数のランダム文字列を生成するメソッド
---------------------------------------------------------------------------------------------

*private IEnumerator userRegistrationCoroutine()
会員登録を行うメソッド
---------------------------------------------------------------------------------------------

*NCMBUser user = new NCMBUser();
NCMBUserクラスのインスタンス生成

*string password = genRandomString(16);
パスワード

*bool isSuccess = false;
UserIDが重複したらやり直し

*user.UserName = genRandomString(16);*user.SignUpAsync((NCMBException e) => {if (e != null){// ユーザ登録失敗if (e.ErrorCode != NCMBException.DUPPLICATION_ERROR){// ユーザ名重複以外のエラーが発生Debug.Log("Failed to registerate: " + e.ErrorMessage);}}else{// ユーザ登録成功isSuccess = true;Debug.Log("Succeeded to registrate");// Unity(端末)に情報を設定PlayerPrefs.SetString(userNameKey, user.UserName);PlayerPrefs.SetString(passwordKey, password);}// ユーザ登録処理（１ループ）終了isConnecting = false;});
ランダム文字列でユーザ名を設定してユーザ登録実行（非同期処理）

*Debug.Log("Failed to registerate: " + e.ErrorMessage);
ユーザ名重複以外のエラーが発生

*isSuccess = true;
ユーザ登録成功

*PlayerPrefs.SetString(userNameKey, user.UserName);
Unity(端末)に情報を設定

*isConnecting = false;
ユーザ登録処理（１ループ）終了

*yield return new WaitWhile(() => { return isConnecting; });
ユーザ登録処理（１ループ）が終了するまで以下の行でストップ（強制的に同期処理にする）

*private IEnumerator loginCoroutine(string userName, string password)
ログインを行うメソッド
---------------------------------------------------------------------------------------------

*Debug.Log("Failed to login: " + e.ErrorMessage);
ログイン失敗

*Debug.Log("Succeeded to login");
ログイン成功

*isConnecting = false;
ログイン処理終了

*yield return new WaitWhile(() => { return isConnecting; });
ログイン処理が終了するまで以下の行でストップ


*private const string baseUrl = "http:
weather.livedoor.comforecastwebservicejsonv1";

*public class WeatherResponse*{public Pinpointlocation[] pinpointLocations { get; set; }public string link { get; set; }public Forecast[] forecasts { get; set; }public Location location { get; set; }public DateTime publicTime { get; set; }public Copyright copyright { get; set; }public string title { get; set; }public Description description { get; set; }}
ここから下は受け取るJsonのデータ型を定義しているよ -----------------------


*string S = Console.ReadLine();
-文字列を受け取る

*int currentSIndex = 0;
-文字列の中から連続したb,wの数をカウントして、List<int> resultに格納する

*int count = 0;
-List<int> result内の要素を半角スペース区切りで出力する


*static int GetSumOfRowNumber(List<List<int>> OriginMagicSquare ,int row)
引数2に指定した行riの合計値(ri_c0+ri_c1+ri_c2...ri_cN)を返すメソッド


*Debug.Log (v2 + ", "+h2);
スティックの倒れた向きを向く---------------------------------
float v2 = leftController.GetTouchPosition.y; y軸方向の値をとる
float h2 = leftController.GetTouchPosition.x; x軸方向の値をとる

*Vector3 direction = new Vector3(h2,0,v2);
ジョイスティックが傾いている方向を向く


*mAgent.velocity = Vector3.zero;
減速ではなくピタっと止める

*private readonly string TAG_POPUP_POINT = "PopupPoint";
当たり判定
---------------------------------------------------------------------------------

*if (other.tag == TAG_POPUP_POINT) TakeFollower(other.GetComponent<PopupPoint>());*}
ポップアップポイントに接触した

*private List<FollowerModel> mFollowerList = new List<FollowerModel>();
フォロワーの追従
---------------------------------------------------------------------------------

*Transform target = mTrans;*int followerCount = mFollowerList.Count;
フォロワーに追従させる対象を決定する（すでにフォロワーが追従している場合は一番後ろのフォロワーを対象にする）

*FollowerModel follower = popup.DeleverFollower();
フォロワーの追従開始

*mFollowerList.Add(follower);
フォロワーをリストに追加し、プレイヤーとフォロワーの移動速度を再設定


*DoHeavyTask();
← 10秒かかる重い処理

*var task = DoSomethingAsync();*Console.WriteLine("after DoSomethingAsync: {0:N0}ms", stopwatch.ElapsedMilliseconds);
ここではバックグラウンド？で DoSomethingAsync を開始だけしたつもり（非同期のつもり）

*await task;*Console.WriteLine("after await: {0:N0}ms", stopwatch.ElapsedMilliseconds);
ここで await することで完了を待っているつもり


*URL = string.Format("https:
docs.google.comformsde1FAIpQLSdjLLjO0OEYT44hJlxUBFRm2wz2GTqpatku7sJb-aBv8eOcxgviewform?usp=pp_url&entry.1543890908={0}&entry.966225331={1}&entry.451690904={2}&entry.465137427={3}",


*private int mFollowerCount;
アクティブ状態のフォロワー数


*book.Worksheet( sheetName ).Delete();
削除

*book.AddWorksheet( sheetName, 1 );
シート「新規追加したいシート名」を新規追加

*book.Save();
保存


*case XLDataType.Text:
文字列


*private Vector3 mDistance;
ターゲットとの距離

*[SerializeField]
カメラの追従設定
---------------------------------------------------------------------------------


*mAnimator.SetLayerWeight(1, 1);
レイヤーウェイト = そのレイヤーのアニメーションをどの程度反映させるかどうか0.0f~1.0f

*//override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {////}
OnStateEnter is called when a transition starts and the state machine starts to evaluate this state

*// OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks*//override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {////}
}

*//override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {////}
OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks

*override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)*{PlayerAnimation pa = animator.gameObject.GetComponent<PlayerAnimation>();if (pa.AnimId == PlayerAnimation.ANIM_ID.IDLE) pa.OnCallChangeFace(PlayerAnimation.DEFAULT_FACE);}
OnStateExit is called when a transition ends and the state machine finishes evaluating this state

*//override public void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {////}
OnStateMove is called right after Animator.OnAnimatorMove(). Code that processes and affects root motion should be implemented here

*// OnStateIK is called right after Animator.OnAnimatorIK(). Code that sets up animation IK (inverse kinematics) should be implemented here.*//override public void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {////}
}

*//override public void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {////}
OnStateIK is called right after Animator.OnAnimatorIK(). Code that sets up animation IK (inverse kinematics) should be implemented here.


*Debug.Log("foo は null ");
NG


*byte[] vals = { 0x0d};
, 0x0a


*string path2;
out file name


*var scount = 0;
たまに繁体字・簡体字両方含んでるやつがあるので、そのときは多い方にする

*if (Kanji.IsMatch(text))
ここに来た時点ではまだ日本語・繁体字・簡体字どれも可能性あるんだけど、
どれにも含まれる漢字しか使われてないので、日本語フォントでも問題なく表示される。


*this[index] = new T();
初期値

*public virtual IEnumerable<int> GetAllIndexes() {for (int y = 1; y <= this.YSize; y++) {for (int x = 1; x <= this.XSize; x++) {yield return ToIndex(x, y);}}}
盤上のすべての位置(index)を列挙する

*public virtual IEnumerable<int> EnumerateIndexes(int x, int y, int direction) {for (int index = ToIndex(x, y); IsOnBoard(index) && this[index] != null; index += direction)yield return index;}
(x,y)からdirection方向の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Horizontal(int x, int y)
(x,y)から右(水平)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> Virtical(int x, int y)
(x,y)から下(垂直)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantR(int x, int y)
(x,y)から右斜め下(45度)の位置を列挙する　(x,y)含む

*public virtual IEnumerable<int> SlantL(int x, int y)
(x,y)から左斜め下(45度)の位置を列挙する　(x,y)含む


*if (buf.CompareTo("FXSHRXW") >= 1)*throw new ArgumentOutOfRangeException("Argument range max \"FXSHRXW\"");
変換後がint.MaxValueに収まるか?


*var people = new List<Person>*{new Person { Name = "明石家さんま", Age = 63, Gender = Gender.Male, BirthPlace = "東京都"},new Person { Name = "阿部寛", Age = 54, Gender = Gender.Male, BirthPlace = "神奈川県"},new Person { Name = "マツコ・デラックス", Age = 46, Gender = Gender.Male, BirthPlace = "千葉県"},new Person { Name = "内村光良", Age = 54, Gender = Gender.Male, BirthPlace = "熊本県"},new Person { Name = "新垣結衣", Age = 30, Gender = Gender.Female, BirthPlace = "神奈川県"},new Person { Name = "浅田真央", Age = 28, Gender = Gender.Female, BirthPlace = "東京都"},new Person { Name = "綾瀬はるか", Age = 33, Gender = Gender.Female, BirthPlace = "熊本県"}};
芸能人好感度ランキングから名前を借りました。出身地や年齢は加工しています。

*,,,
明石家さんま 63才 男 東京都出身

*,,,
明石家さんま 63才 男 東京都出身
阿部寛 54才 男 神奈川県出身
マツコ・デラックス 46才 男 千葉県出身
内村光良 54才 男 熊本県出身

*,,,
新垣結衣 30才 女 神奈川県出身

*,,,
浅田真央 28才 女 東京都出身
新垣結衣 30才 女 神奈川県出身
綾瀬はるか 33才 女 熊本県出身
マツコ・デラックス 46才 男 千葉県出身
阿部寛 54才 男 神奈川県出身
内村光良 54才 男 熊本県出身
明石家さんま 63才 男 東京都出身

*,,,
明石家さんま 63才 男 東京都出身
阿部寛 54才 男 神奈川県出身
内村光良 54才 男 熊本県出身
マツコ・デラックス 46才 男 千葉県出身
綾瀬はるか 33才 女 熊本県出身
新垣結衣 30才 女 神奈川県出身
浅田真央 28才 女 東京都出身

*,,,
熊本県
内村光良 54才 男 熊本県出身
綾瀬はるか 33才 女 熊本県出身
神奈川県
阿部寛 54才 男 神奈川県出身
新垣結衣 30才 女 神奈川県出身
千葉県
マツコ・デラックス 46才 男 千葉県出身
東京都
明石家さんま 63才 男 東京都出身
浅田真央 28才 女 東京都出身

*,,,
東京都
神奈川県
千葉県
熊本県

*var max = people.Max(p => p.Age);
最小値:28

*var average = people.Average(p => p.Age);
最大値:63

*var sum = people.Sum(p => p.Age);
平均値:44


*var addedList = list.Add(11);
ImmutableなListは、項目が追加された別のインスタンスを生成する

*list.Add(11);
MutableなListは、自身の中身を書き換える

*var builder = originalList.ToBuilder();
大量の変更が必要な場合、Builderに。

*var newList = builder.ToImmutable();
変更後、ToImmutable()で、Immutableに。

*var builder = new StringBuilder(originalString);
大量の変更が必要な場合、Builderに。

*var newStr = builder.ToString();
Immutableに。


*string connectString ="Data Source = " + dbServer+ ";Initial Catalog = " + dbName
接続文字列を生成

*this.sqlConnection = new SqlConnection(connectString);
SqlConnection の新しいインスタンスを生成 (接続文字列を指定)

*this.sqlConnection.Open();
データベース接続を開く

*sqlCom.Connection = this.sqlConnection;
クエリー送信先、トランザクションの指定

*SqlDataReader reader = sqlCom.ExecuteReader();
SQLを実行

*sqlCom.Connection = this.sqlConnection;
クエリー送信先、トランザクションの指定

*sqlCom.ExecuteNonQuery();
SQLを実行

*private const string DATABASE_SERVER = "hogehoge";
データベース接続情報

*private const string DATABASE_SERVER = "hogehoge";
データベース接続情報


*Console.WriteLine(message.Value);
"Hello"と出力

*public class Person*{public string Name { get; set; }public int Age { get; set; }}
ViewModelで使いたいModelクラス

*public class VM1 : ObservableObject*{private Person _person;public int Age{get => _person.Age;set => SetProperty(_person.Age, value, (model, newval) => model.Age = newval);}public string Name{get => _person.Name;set => SetProperty(_person.Name, value, (model, newval) => model.Name = newval);//SetProperty(古値, 新値, 更新(古値!=新値)時に実行するcallback);}}
ViewModelでラップしてPropertyChangedに反応させる

*}
SetProperty(古値, 新値, 更新(古値!=新値)時に実行するcallback);


*true
読み込むStreamを破棄しないかどうか

*var body = reader.ReadToEnd();
リクエストBodyを読み込む

*reader.BaseStream.Position = 0;
読み込み開始位置を先頭にする(どっちの方法でやっても大丈夫)

*context.Request.EnableRewind();
リクエストBodyを複数回読み込めるようにする

*using (var reader = new StreamReader(context.Request.Body, Encoding.UTF8, true, 1024, true)){リクエストBody読み込みvar body = await reader.ReadToEndAsync();
リクエストBodyのStreamを破棄しないようにする

*var body = await reader.ReadToEndAsync();
リクエストBody読み込み

*reader.BaseStream.Position = 0;
リクエストBodyの読み込み位置を先頭にする

*var body = await reader.ReadToEndAsync();
リクエストBody再読み込み


*this.EmployeesDataGrid.Columns.ToList().ForEach(c => c.SortDirection = null);
各ColumnHeaderのSortDirectionをクリアする

*this.EmployeesDataGrid.DataContext = null;
DataGridのDataContextを再設定する


*public string ProjectName { get; set; }
ここに"projects"の最初の要素の"name"を割り当てたい

*[JsonProperty("company")]
JsonPropertyでDeserializeしたいメンバーを持つJsonObject名を指定
JsonConverterの宣言でObjectMemberPickerの型と指定したいPathをパラメーターで渡す
(このパラメーターがObjectMemberPickerのコンストラクタへ引数として渡される)

*[JsonProperty("projects")]
一つのJsonPropertyは一つのPropertyにしか割り当てられないようなので、
今のところDepartmentNameにDeserializeするならComopanyNameは諦めるしかない
Deserialize自体は下記のPath指定でできた。
[JsonProperty("company")]
[JsonConverter(typeof(ObjectMemberPicker), "department.name")]
public string DepartmentName { get; set; }


*Console.WriteLine(data);
上の説明文から、Main内のdataがインクリメントされたままで値が出力されるため、2となっている。


*format.ToString(new CultureInfo("en-US"));
$1,234.56


*public event PropertyChangedEventHandler PropertyChanged;
これ

*namespace models
このコードはテンプレートから生成されました。

このファイルを手動で変更すると、アプリケーションで予期しない動作が発生する可能性があります。
このファイルに対する手動の変更は、コードが再生成されると上書きされます。
</auto-generated>
------------------------------------------------------------------------------


*using UnityEngine.Events;
追加

*ActionMethod (ActionCallbackMethod);
処理を実行するメソッドにコールバックを受け取りたいメソッドを渡す

*ActionMethod (() =&gt; {Debug.Log("ラムダ式UnityAction実行完了 : "+testVal);});
ラムダ式UnityAction

*private void ActionMethod (UnityAction callback) {// コールバック実行callback ();}
実行メソッド

*callback ();
コールバック実行

*public void ActionCallbackMethod () {Debug.Log ("UnityAction実行完了");}
UnityActionのコールバックで呼び出されるメソッド

*private delegate void OnComplete (string text);*void Start () {// 処理を実行するメソッドにコールバックを受け取りたいメソッドを渡すDelegateMethod (DelegateCallbackMethod);// ラムダ式delegateDelegateMethod ((string text) =&gt; {Debug.Log ("ラムダ式delegate実行完了 : " + text);});}
delegate型の宣言

*DelegateMethod (DelegateCallbackMethod);
処理を実行するメソッドにコールバックを受け取りたいメソッドを渡す

*DelegateMethod ((string text) =&gt; {Debug.Log ("ラムダ式delegate実行完了 : " + text);});
ラムダ式delegate

*private void DelegateMethod (OnComplete callback) {// コールバック実行callback ("文字列だよ");}
実行メソッド

*callback ("文字列だよ");
コールバック実行

*public void DelegateCallbackMethod (string text) {Debug.Log ("delegate実行完了 : "+text);}
delegateのコールバックで呼び出されるメソッド

*using UnityEngine.Events;
追加

*if (unityEvent == null)*unityEvent = new UnityEvent ();
インスタンスを生成

*unityEvent.AddListener (UnityEventCallbackMethod_1);
Invoke()で実行させるメソッドを登録する

*unityEvent.Invoke();
登録されたメソッドを一斉に実行する

*private void UnityEventCallbackMethod_1 () {Debug.Log ("UnityEvent実行完了 その1");}
Invoke時に実行されるメソッド1

*private void UnityEventCallbackMethod_2 () {Debug.Log ("UnityEvent実行完了 その2");}
Invoke時に実行されるメソッド2


*UnsubscribeEvents();
イベント削除

*public void OnClick()*{//平面が認識されている時if(unityAnchor.GetCurrentPlaneAnchors().Count != 0) {//1個目の平面オブジェクトのポジション取得Vector3 vFloor = unityAnchor.GetCurrentPlaneAnchors()[0].gameObject.transform.position;//VR空間の高さを変更するobjFloor.transform.position = new Vector3 (0f, vFloor.y, 0f);}}
ボタンなどに設定

*Vector3 vFloor = unityAnchor.GetCurrentPlaneAnchors()[0].gameObject.transform.position;*//VR空間の高さを変更する
1個目の平面オブジェクトのポジション取得

*objFloor.transform.position = new Vector3 (0f, vFloor.y, 0f);*}
VR空間の高さを変更する


*dbSet.FromSqlRaw<T>($"SELECT * FROM [{テーブル名}] WITH (UPDLOCK)")
dbSet は DbContext と紐づけられた DbSet<T> のインスタンスです

*using var transaction = context.Database.BeginTransaction();
context は DbContext のインスタンスです

*if (context.SaveChanges() > 0)
この時点ではロックは取得しない
データ編集等

*transaction.Commit();
SaveChangesメソッドで更新系クエリが発行され、更新ロックが取得され、
Commitを行うまでの間ロックが保持される


*var toDoList = new ToDoList.ToDoList().GetToDos().Select(t => new ToDo { id = t.Id, title = t.Title, content = t.Content})
さすがにハイジャックはされたくなのでむき出しの配列では返さない。


*public CoroutineEx(IEnumerator routine) {this.routine = routine;}
コンストラクタ

*public void Update() {IsDone = !routine.MoveNext();}
更新処理

*public CoroutineEx(IEnumerator routine) {stack.Push(routine);}
コンストラクタ

*public CoroutineEx(IEnumerator routine) {stack.Push(routine);}
コンストラクタ

*public void Update() {if (stack.Count == 0) {Done();return;}var peek = stack.Peek();if (peek == null) {stack.Pop();Current = null;}else if (peek is IEnumerator) {var e = (IEnumerator)peek;try {if (e.MoveNext()) {stack.Push(e.Current);Update();} else {stack.Pop();Update();}}catch (Exception error) {stack.Clear();Error = error;Done();}}else if (peek is AsyncOperation) {if (!((AsyncOperation)peek).isDone) {Current = null;} else {stack.Pop();Update();}}else {stack.Pop();Current = peek;}}
更新処理


*[SerializeField] int DisplaySpan = 10;
表示周期(編集可能)

*[SerializeField] GameObject AdsButton;
表示ボタン

*public UnityEvent _UnityEvent;
リワード処理


*byte[] buf;
文字列


*// input for prediction operations*// - First 4 properties are inputs/features used to predict the label
IrisData is used to provide training data, and as

*public class IrisData*{[Column("0")]public float SepalLength;[Column("1")]public float SepalWidth;[Column("2")]public float PetalLength;[Column("3")]public float PetalWidth;[Column("4")][ColumnName("Label")]public string Label;}
- Label is what you are predicting, and is only set when training

*public class IrisPrediction*{[ColumnName("PredictedLabel")]public string PredictedLabels;}
IrisPrediction is the result returned from prediction operations

*// This is a classification scenario (What type of iris is this?)*pipeline.Add(new StochasticDualCoordinateAscentClassifier());
Add a learning algorithm to the pipeline.

*pipeline.Add(new StochasticDualCoordinateAscentClassifier());*// Convert the Label back into original text (after converting to number in step 3)
This is a classification scenario (What type of iris is this?)

*pipeline.Add(new PredictedLabelColumnOriginalValueConverter() { PredictedLabelColumn = "PredictedLabel" });
Convert the Label back into original text (after converting to number in step 3)

*// You can change these numbers to test different predictions*var prediction = model.Predict(new IrisData()
STEP 6: Use your model to make a prediction

*var prediction = model.Predict(new IrisData(){SepalLength = 3.3f,SepalWidth = 1.6f,PetalLength = 0.2f,PetalWidth = 5.1f,});
You can change these numbers to test different predictions


*/**uint? data = conn.QueryFirst<uint?>(sql, new { UserId = userId });
ExecuteScalar が使えることを教えてもらいました


*var path = @"XXXXXXX\受信トレイ_20180522-2132\メッセージ";
メールをエクスポートしたフォルダ

*throw new Exception();
タイトル名の後に'¥'が来ないのはおかしい(予想外の形式)ので止める

*throw new Exception();
おかしい

*var yen = int.Parse(yenStr);
intになってるはずなので例外チェックしない

*var isFirst = true;
デバッグ用

*throw new Exception();
タイトル名の後に'¥'が来ないのはおかしい(予想外の形式)ので止める

*throw new Exception();
おかしい

*var yen = int.Parse(yenStr);
intになってるはずなので例外チェックしない


*new AmazonS3Client();
おそらく production は EC2 のインスタンスメタデータ等から接続するはず


*var targetFilePath = @"C:\Windows\System32\shell32.dll";
サンプルDLL

*var hModule = NativeMethods.LoadLibraryEx(filePath, IntPtr.Zero, NativeMethods.LoadLibraryExFlags.DONT_RESOLVE_DLL_REFERENCES | NativeMethods.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE);
メッセージテーブルリソースをもつファイルを読み込みます。

*NativeMethods.EnumResourceNames(hModule, new IntPtr(NativeMethods.RT_STRING), (hMod, typ, nam, prm) =>*{// 文字列リソースIDは、得られたリソース名（INTRESOURCE）-1の16倍var resId = (nam.ToInt32() - 1) * 16;var hRes = NativeMethods.FindResource(hMod, nam, typ);if (!IntPtr.Zero.Equals(hRes)){var hGlobal = NativeMethods.LoadResource(hMod, hRes);if (!IntPtr.Zero.Equals(hGlobal)){var bytesLen = NativeMethods.SizeofResource(hMod, hRes);var ptr = NativeMethods.LockResource(hGlobal);if (!IntPtr.Zero.Equals(ptr)){Int32 offset = 0;while(offset < bytesLen){var strLen = (UInt16)Marshal.ReadInt16(ptr + (int)offset);offset += 2;if (strLen > 0){var str = Marshal.PtrToStringUni(ptr + (int)offset, strLen);offset += strLen * 2;retVal.Add(new System.Tuple<Int32, string>(resId, str));}resId += 1;}}}}return true;}, IntPtr.Zero);
STRINGテーブルのエントリを列挙させます。

*var resId = (nam.ToInt32() - 1) * 16;
文字列リソースIDは、得られたリソース名（INTRESOURCE）-1の16倍

*NativeMethods.FreeLibrary(hModule);
読み込んだファイルを閉じます。


*var r8 = r1 with { Length = 11 };
OK


*RowHeight = 60
Cellの高さを設定

*listView.ItemsSource = new String[] {"ダミーテキスト","ダミーテキスト","ダミーテキスト","ダミーテキスト","ダミーテキスト",};
ListViewに表示するデータを設定

*public async Task<List<QiitaArticleEntity>> AsyncGetWebAPIData()
QiitaAPIのURl
public string API_URL = "https:qiita.comapi/v2/items";
データを取得するメソッド

*articleList = new List<QiitaArticleEntity>();
Listの作成

*HttpClient httpClient = new HttpClient();
HttpClientの作成

*Task<string> stringAsync = httpClient.GetStringAsync(API_URL);
非同期でAPIからデータを取得

*articleList = JsonConvert.DeserializeObject<List<QiitaArticleEntity>>(result);
JSON形式のデータをデシリアライズ

*return articleList;
List でデータを返す

*public class QiitaArticleEntity*{public string title { get; set; }public string url { get; set; }}
QiitaApiから取得するデータのEntity

*async void fetchArticles(QiitaAPI api)*{try{// 取得したデータをListに設定articleList = await api.AsyncGetWebAPIData();var items = new List<String>();foreach (QiitaArticleEntity value in articleList){items.Add(value.title);}listView.ItemsSource = items;}// エラー表示処理catch (System.Exception ex){await DisplayAlert("Error", ex.Message.ToString(), "OK");}}
非同期でデータ取得のメソッドを実行するメソッド

*articleList = await api.AsyncGetWebAPIData();
取得したデータをListに設定

*catch (System.Exception ex)*{await DisplayAlert("Error", ex.Message.ToString(), "OK");}
エラー表示処理


*NativeMethods.EnumWindows((h, p) => {
トップレベルウインドウを列挙

*NativeMethods.EnumChildWindows(h, EnumChildWindowsProc, new IntPtr(1));
子ウインドウを列挙

*NativeMethods.EnumChildWindows(hWnd, EnumChildWindowsProc, new IntPtr(lParam.ToInt32() + 1));
さらに自身の子ウインドウを列挙


*var targetFilePath = @"C:\Windows\System32\kernel32.dll";
サンプルDLL

*var hModule = NativeMethods.LoadLibraryEx(filePath, IntPtr.Zero, NativeMethods.LoadLibraryExFlags.DONT_RESOLVE_DLL_REFERENCES | NativeMethods.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE);
メッセージテーブルリソースをもつファイルを読み込みます。

*var numOfBlocks = Marshal.ReadInt32(topOfResourceData);
ブロック数はDWORD

*var lowID = (UInt32)Marshal.ReadInt32(ptrInBlocks);
先頭IDはDWORD

*var highID = (UInt32)Marshal.ReadInt32(ptrInBlocks);
終端IDはDWORD

*var offsetFromTop = Marshal.ReadInt32(ptrInBlocks);
オフセットはDWORD

*var lengthInBytes = Marshal.ReadInt16(ptrOfMessage);
この構造のバイトサイズはWORD

*var flag = Marshal.ReadInt16(ptrOfMessage);
フラグ（文字種）はWORD

*NativeMethods.FreeLibrary(hModule);
読み込んだファイルを閉じます。


*}
なんらかの処理


*Debug.Log("IsTouching : " + GvrControllerInput.IsTouching);
タッチパッドにタッチしている間ずっとTrue

*Debug.Log("TouchPos : " + GvrControllerInput.TouchPos);
タッチパッドのタッチしている位置 0~1

*Debug.Log("TouchPosCentered : " + GvrControllerInput.TouchPosCentered);
タッチパッドのタッチしている位置 -1~1

*Debug.Log("Orientation : " + GvrControllerInput.Orientation);
コントローラの傾き

*Vector3 rayDir = GvrControllerInput.Orientation * Vector3.forward;*Debug.Log("rayDir : " + rayDir);
コントローラの正面方向のベクトル

*Debug.Log("Gyro : " + GvrControllerInput.Gyro);
角速度 | 回転の動きを取得
操作しないとVector3.zeroに戻る
ex.一定速度以上でコントローラを振ったらボールを投げる

*Debug.Log("Accel : " + GvrControllerInput.Accel);
加速度 | 重力、振動、衝撃を計測
ex.コントローラが傾いているとか、ぶら下がっているとかを判定する


*public interface IDisposable {// 《自分自身を》破棄するvoid Dispose();}
『破棄できる』インタフェース

*void Dispose();
《自分自身を》破棄する

*public interface IComparable<in T> {// 《自分自身を》T型の他のオブジェクトと『比較する』int CompareTo(T other);}
『比較できる』インタフェース

*int CompareTo(T other);
《自分自身を》T型の他のオブジェクトと『比較する』

*public interface IEnumerable<out T> {// 『《自分自身を》「列挙する人」を取得する』IEnumerator<T> GetEnumerator();}
『列挙できる』インタフェース

*IEnumerator<T> GetEnumerator();
『《自分自身を》「列挙する人」を取得する』

*,,,
ややこしいので非ジェネリクスのIEnumerableの継承は省略

*public interface ICustomFormatter {// 受け取った引数を元に『フォーマットする』String Format (String format, Object arg, IFormatProvider formatProvider);}
『フォーマットする人』インタフェース

*String Format (String format, Object arg, IFormatProvider formatProvider);*}
受け取った引数を元に『フォーマットする』

*public interface IEnumerator<out T> : IDisposable {// 《列挙する対象を》次の要素へ移動するbool MoveNext();// 《列挙する対象を》現在の要素を取得するT Current { get; }// 《列挙する対象を》初期状態に戻すvoid Reset();}
『列挙する人』インタフェース

*bool MoveNext();
《列挙する対象を》次の要素へ移動する

*T Current { get; }
《列挙する対象を》現在の要素を取得する

*void Reset();
《列挙する対象を》初期状態に戻す

*,,,
ややこしいので非ジェネリクスのIEnumeratorの継承は省略

*public interface ICollection<T> : IEnumerable<T> {// 《自分自身の》持つ要素数int Count { get; }// 《自分自身が》読み取り専用か否かbool IsReadOnly { get; }// 《自分自身に》T型の新しい要素を追加するvoid Add(T item);// 《自分自身の》要素を空にするvoid Clear();// 《自分自身に》対象の要素が含まれているか判断するbool Contains(T item);// 《自分自身の》arrayIndex番目の要素以降をarrayにコピーするvoid CopyTo(T[] array, int arrayIndex);// 《自分自身から》対象の要素を削除するbool Remove(T item);}
『コレクション』を表すインタフェース

*int Count { get; }
《自分自身の》持つ要素数

*bool IsReadOnly { get; }
《自分自身が》読み取り専用か否か

*void Add(T item);
《自分自身に》T型の新しい要素を追加する

*void Clear();
《自分自身の》要素を空にする

*bool Contains(T item);
《自分自身に》対象の要素が含まれているか判断する

*void CopyTo(T[] array, int arrayIndex);
《自分自身の》arrayIndex番目の要素以降をarrayにコピーする

*bool Remove(T item);
《自分自身から》対象の要素を削除する

*// 『リスト』は『コレクション』に加えて以下のことが可能*public interface IList<T> : ICollection<T> {// 《自分自身の》index番目の要素を取得、設定するT this[int index] { get; set; }// 《自分自身の》何番目に対象の要素があるか判断するint IndexOf(T item);// 《自分自身の》index番目に対象の要素を挿入するvoid Insert(int index, T item);// 《自分自身の》index番目の要素を削除するvoid RemoveAt(int index);}
『リスト』を表すインタフェース

*public interface IList<T> : ICollection<T> {// 《自分自身の》index番目の要素を取得、設定するT this[int index] { get; set; }// 《自分自身の》何番目に対象の要素があるか判断するint IndexOf(T item);// 《自分自身の》index番目に対象の要素を挿入するvoid Insert(int index, T item);// 《自分自身の》index番目の要素を削除するvoid RemoveAt(int index);}
『リスト』は『コレクション』に加えて以下のことが可能

*T this[int index] { get; set; }
《自分自身の》index番目の要素を取得、設定する

*int IndexOf(T item);
《自分自身の》何番目に対象の要素があるか判断する

*void Insert(int index, T item);
《自分自身の》index番目に対象の要素を挿入する

*void RemoveAt(int index);
《自分自身の》index番目の要素を削除する

*interface IPrintable {// 《自分自身を》印刷するvoid Print();}
『印刷できる』

*void Print();
《自分自身を》印刷する

*class Document : IPrintable { /*...*/ }
例えば、印刷できるドキュメント型

*interface ICutter {// 《他のものを》切るPaper[] Cut(Paper paper);}
『カッター(切るもの)』

*Paper[] Cut(Paper paper);
《他のものを》切る

*class Scissor : ICutter { /*...*/ }
例えば、他の物を切ることができるハサミ型

*interface IRemoteControllable {// 《自分自身を》操作するためのリモコンを取得するIRemoteController GetController();}
『リモコンで操作できる』

*IRemoteController GetController();
《自分自身を》操作するためのリモコンを取得する

*interface IRemoteController {// 『《遠隔操作する対象の》電源を入切する』void Power(bool turningOn);// 『《遠隔操作する対象の》チャネルを変更する』void ChangeChannel(int channel);}
『リモコン(遠隔操作するもの)』

*void Power(bool turningOn);
『《遠隔操作する対象の》電源を入切する』

*void ChangeChannel(int channel);
『《遠隔操作する対象の》チャネルを変更する』

*class Television : IRemoteControllable {bool _powerOn;int _channel;// 自分自身を対象とするリモコンを返却public IRemoteController GetController() {return new RemoteController(this);}// リモコン型class RemoteController : IRemoteController {Television _television;// コンストラクタで対象のテレビを受け取るpublic RemoteController(Television television) {_television = television;}public void ChangeChannel(int channel) {_television._channel = channel;}public void Power(bool turningOn) {_television._powerOn = turningOn;}}}
リモコン操作可能なテレビ型

*public IRemoteController GetController() {return new RemoteController(this);}
自分自身を対象とするリモコンを返却

*class RemoteController : IRemoteController {Television _television;// コンストラクタで対象のテレビを受け取るpublic RemoteController(Television television) {_television = television;}public void ChangeChannel(int channel) {_television._channel = channel;}public void Power(bool turningOn) {_television._powerOn = turningOn;}}
リモコン型

*public RemoteController(Television television) {_television = television;}
コンストラクタで対象のテレビを受け取る

*interface ICar {// 『《自分自身の》エンジンを開始する』void StartEngine();// 『《自分自身を》加速する』void Accel();// 『《自分自身を》減速する』void Break();}
『車』

*void StartEngine();
『《自分自身の》エンジンを開始する』

*void Accel();
『《自分自身を》加速する』

*void Break();
『《自分自身を》減速する』

*class Car : ICar { /* ・・・*/ }
様々な車


*string destFileName = Path.Combine(_destFolder ,Path.GetFileName(picturePath) + ".jpg");
コピー先はjpg形式とする。

*}
ファイルのロードに失敗する場合は次へ行く。


*pdf.PageScaling = PdfPrintPageScaling.ActualSize;
実際の大きさ

*}
何もしない


*#if _IOS_
iOSがターゲットのOSの際には、実行されるもの


*routeTemplate: "api
{controller}{action}{id}", ここは編集する。


*var minimumSize = this.minimumSize;
最小サイズを設定

*parent = foundChildItem;
すでに同じ名前のAdvancedDropdownItemがあった場合は次へ

*pathDictionary[lastItem.id] = path;
KeyをAdvacnedDropdownItemnのidにしてパスを取得できるようにする

*button.style.width = BUTTON_WIDTH;
ボタンの表示方法を設定

*sampleDropdown.onItemSelected += OnItemSelected;
イベント購読


*// Note that default(T) is not equal to null for value types except when T is Nullable<U>.*return ((value is T) || (value == null && default(T) == null));
Non-null values are fine.  Only accept nulls if T is a class or Nullable<U>.

*// before adding the new element.*//
increased by one. If required, the capacity of the list is doubled


*var data = 1;
上のCountUpのdataと、このdataは別物！


*TokenAudience = new Uri("https:
api.loganalytics.io"),


*var hogeTypes = (HogeType[])Enum.GetValues(typeof(HogeType));
System.Arrayが返されるので、キャストする。


*float speed = 0.01f;
後で速度変更しやすいように敢えて変数にしている

*void Start()*{rectTransform = this.GetComponent<RectTransform>();}
Start is called before the first frame update

*void Update()*{if (Increase){i += speed;}else{i -= speed;}if (i >= 1){Increase = false;}if (i <= 0){Increase = true;}rectTransform.localScale = new Vector3(i, i, 0);}
Update is called once per frame


*using (Process process = this.CreateFCProcess(sourceFileName, destinationFileName)) {await this.StartCommandAsync(process);
Processを非同期に実行

*this.m_FCResult = "";
プロセスからの情報を受け取る変数の初期化

*started = process.Start();
プロセスの開始


*T Current { get; }
現在の要素を取得する。

*bool MoveNext();
次の要素に移動する。次の要素があればtrue,無ければfalseを返す。

*}
その他の定義は省略

*IEnumerator<T> GetEnumerator();
イテレータを取得

*}
その他の定義は省略

*,,,
実際には例外処理や後処理などがあるが、ここでは省略

*static IEnumerable<int> Generate5Primes() {yield return 2;yield return 3;yield return 5;yield return 7;yield return 11;}
イテレータ構文と呼ばれているが、実際にはジェネレータ

*static IEnumerable<double> RandomDoubles() {var random = new Random();while (true) {yield return random.NextDouble();}}
無限ループも使い方次第


*user.NotifyMessage(message);*}
各ユーザにメッセージを通知する。

*Log.ErrorFormat("通知に失敗 : ErrorCode = {0}", ne.ErrorCode, ne);
通知に失敗したのでログに出力

*user.NotifyMessage(message);*}
各ユーザにメッセージを通知する。

*Log.ErrorFormat("通知に失敗 : ErrorCode = {0}, UserGUID = {1}", ne.ErrorCode, user.Guid, ne);
通知に失敗したのでログに出力


*void Start () {}
Use this for initialization

*void Update () {this.GetComponent<Text>().text = "ここに文字が表示されます。";}
Update is called once per frame

*void Start () {}
Use this for initialization

*void Update () {int sum = x + y;this.GetComponent<Text>().text = "x + y =" + sum.ToString();}
Update is called once per frame


*string finishedUrl = @"https:
api.twitter.comoauthauthorize";

*pin = html.Substring(codeIndex + 6, 7);
<code>があった=認証に成功した場合

*MessageBox.Show("認証に失敗しました．");
<code>がなかった=認証に失敗した場合


*.UseStartup<Startup>()
Startupクラスを使用する

*app.Run(async context => await context.Response.WriteAsync("Hello World!"));
リクエストを受け付けたら「Hello World!」と出力する

*.Configure(app => app.Run(async context => await context.Response.WriteAsync("Hello World!")))
UseStartupの代わりに以下を記述する

*services.AddMvcCore();
Dependency InjectionでASP.NET Core MVC周りの機能を解決できるようにする

*app.UseMvc(route =>{とりあえず[コントローラ名]/[アクション名]でURLをルーティングroute.MapRoute("default", "{controller}/{action}");
ASP.NET Core MVCのルーティングを有効化する

*route.MapRoute("default", "{controller}/{action}");
とりあえず[コントローラ名]/[アクション名]でURLをルーティング

*public class ValueController : ControllerBase*{public string Index(){return "value";}}
ControllerではなくControllerBaseを継承させる

*services.AddMvc();
Dependency InjectionでASP.NET Core MVCのView周りの機能を解決できるようにする

*return View();
アクション名に一致するViewを返す

*.UseContentRoot(Directory.GetCurrentDirectory())
各ファイルの基点となるディレクトリを設定


*void Start () {}
Use this for initialization

*void Update () {transform.position += (new Vector3(x,y,z));}
Update is called once per frame

*void Start () {}
Use this for initialization

*void Update () {if (Input.GetKey (KeyCode.LeftArrow)) {print ("左押したよ");transform.position -= (new Vector3 (x, 0, 0));}if (Input.GetKey (KeyCode.RightArrow)) {print ("右押したよ");transform.position += (new Vector3 (x, 0, 0));}if (Input.GetKey (KeyCode.UpArrow)) {print ("上押したよ");transform.position += (new Vector3 (0, 0, z));}if (Input.GetKey (KeyCode.DownArrow)) {print ("下押したよ");transform.position -= (new Vector3 (0, 0, z));}}
Update is called once per frame

*public float mvsp = 3;
移動スピードをpublicで初期化

*void Start () {}
Use this for initialization

*void Update () {// 左キー押されたらTime.deltaTimeとmvspでddt値を作成if (Input.GetKey (KeyCode.LeftArrow)) {float ddt = Time.deltaTime * mvsp;transform.position += (new Vector3 (-ddt, 0, 0));}// 右キー押されたらTime.deltaTimeとmvspでddt値を作成if (Input.GetKey (KeyCode.RightArrow)) {float ddt = Time.deltaTime * mvsp;transform.position += (new Vector3 (ddt, 0, 0));}if (Input.GetKey (KeyCode.UpArrow)) {float ddt = Time.deltaTime * mvsp;transform.position += (new Vector3 (0, 0, ddt));}if (Input.GetKey (KeyCode.DownArrow)) {float ddt = Time.deltaTime * mvsp;transform.position += (new Vector3 (0, 0, -ddt));}}
Update is called once per frame

*public float speed = 10;
speedを制御する

*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame


*void Start () {//単純にコンソールで文字を表示させるだけprint("ハローワールド");}
Use this for initialization

*print("ハローワールド");
単純にコンソールで文字を表示させるだけ

*void Update () {}
Update is called once per frame

*void Start () {//単純に今度はコンソールでDebug Logで出力するDebug.Log("ハローワールドDebug Log");}
Use this for initialization

*Debug.Log("ハローワールドDebug Log");
単純に今度はコンソールでDebug Logで出力する

*void Update () {}
Update is called once per frame

*void Start () {int kotae = x + y;print ("答えは" + kotae);}
Use this for initialization

*void Update () {}
Update is called once per frame

*void Start () {if (x == testx) {print ("合ってる");} else {print ("間違っている");}}
Use this for initialization

*void Update () {}
Update is called once per frame

*void Start () {if (fuga == 3) {print ("3で合ってるよ");} else if (fuga == 4) {print ("おしい。それ４だから");} else {print ("３じゃないよ");}}
Use this for initialization

*void Update () {}
Update is called once per frame

*void Start () {}
Use this for initialization

*void Update () {while (cont <= tasukazu) {sum += cont;cont++;}print (sum);}
Update is called once per frame

*void Start () {for (int cont = 1; cont <= 100; cont++) {sum += cont;}print(sum);}
Use this for initialization

*void Update () {}
Update is called once per frame


*continue;
一致しなかったらスキップ

*continue;
対象のコンポーネントが存在しないのでスキップ

*var nonPublicFields = contextType.GetFields(BindingFlags.Instance | BindingFlags.NonPublic);
NonPublicなフィールドのうち、SerializeField属性が設定されてるものを取得する


*new HighKobold(new Mage()).Show();
Hp:20 Mp:10 Skill:コボルトサンダー


*private void Move(Stack<int> s1, Stack<int> s2, Stack<int> s3, int n) {if (n > 0) {Move(s1, s3, s2, n - 1);int x = s1.Pop();s3.Push(x);OnChanged();Move(s2, s1, s3, n - 1);}}
当プログラムの核となるメソッド

*private void OnChanged() {foreach (var observer in _observers) {observer.OnNext(_state);}}
状況変化を知らせるために購読者に通知する

*public IDisposable Subscribe(IObserver<HanoiState> observer) {_observers.Add(observer);return observer as IDisposable;}
購読する場合に呼び出すメソッド

*private int count = -1;
初期状態時にもOnNextが呼ばれるので0ではなく、-1にしておく。

*public void OnCompleted() {Console.WriteLine($"\n{count}手で移動完了");}
IObserver<T> インターフェース

*public void OnError(Exception error) {Console.WriteLine("{0]", error.Message);}// IObserver<T> インターフェースpublic void OnNext(HanoiState value) {count++;DisplayState(value);}private void DisplayState(HanoiState value) {var t1 = TowerToString(value.Number, value.StickA);var t2 = TowerToString(value.Number, value.StickB);var t3 = TowerToString(value.Number, value.StickC);for (int i = 0; i < t1.Length; i++) {Console.WriteLine($"{t1[i]} {t2[i]} {t3[i]}");}Console.WriteLine();}private string[] TowerToString(int n, IEnumerable<int> tower) {// 塔の下から組み立てる// 幅2の円盤だけがあるときは、tower は、{ 2 } となり、Count() == 1 になので注意する。var rewot = tower.Reverse().ToArray();var list = new List<char[]>();for (var i = 0; i < n; i++) {var w = i < rewot.Length ? rewot[i] : 0;var s = new string(' ', n - w) + new string('=', w * 2 + 1) + new string(' ', n - w);list.Add(s.ToArray());}list.Add(new string(' ', n * 2 + 1).ToArray());foreach (var floor in list) {floor[n] = '|';}// 最後に逆転させる。1階が配列の一番最後に来るようにする。return list.Select(f => new string(f)).Reverse().ToArray();}}
IObserver<T> インターフェース

*public void OnNext(HanoiState value) {count++;DisplayState(value);}
IObserver<T> インターフェース

*幅2の円盤だけがあるときは、tower は、{ 2 } となり、Count() == 1 になので注意する。var rewot = tower.Reverse().ToArray();
塔の下から組み立てる

*var rewot = tower.Reverse().ToArray();
幅2の円盤だけがあるときは、tower は、{ 2 } となり、Count() == 1 になので注意する。

*return list.Select(f => new string(f)).Reverse().ToArray();
最後に逆転させる。1階が配列の一番最後に来るようにする。


*public Queries(string intent, double score)
ここのintentとかはluisの要素と一緒にしないとダメかも


*var xmlfile = "WinServiceAppSample1.XMLSettingFile.xml";
【重要】xmlファイル名を指定する場合は「プロジェクト名.File1.xml」という形式にする必要がある


*FieldInfo field = type.GetField("_field", BindingFlags.InvokeMethod | BindingFlags.NonPublic | BindingFlags.Instance);
Typeからフィールドを探す。フィールド名とBindingFlagsを引数にする。

*MethodInfo method = type.GetMethod("PrivateMethod", BindingFlags.InvokeMethod | BindingFlags.NonPublic | BindingFlags.Instance);
Typeからメソッドを探す。メソッド名とBindingFlagsを引数にする。

*object instance = Activator.CreateInstance(type);
インスタンスを作成する

*int methodResult = (int)(method.Invoke(instance, new object[2] { 3, 4 }));
探したメソッドを実行する。　呼ぶメソッドはint,intを引数にし、戻り値もintのため、intにcastしている


*p.Show(title:Console.ReadLine());
名前付き引数


*string filename = "CompanyInfo.xml";*using(Stream filestream = File.Open(filename, FileMode.Open)) {//Actvar deserialize = XMLDataContract.Load<CompanyInfo>(filestream);//AssertAssert.AreEqual(deserialize.Company, "ほんにゃら産業");}
Arrange

*string filename = "CompanyInfo.xml";*using(Stream filestream = File.Open(filename, FileMode.Open)) {//Actvar deserialize = XMLDataContract.Load<CompanyInfo>(filestream);//AssertAssert.AreEqual(deserialize.Departments[1].DeparmentName, "総務部");}
Arrange

*string filename = "CompanyInfo.xml";*using(Stream filestream = File.Open(filename, FileMode.Open)) {//Actvar deserialize = XMLDataContract.Load<CompanyInfo>(filestream);//AssertAssert.AreEqual(deserialize.Departments[0].Employees[1].EmployeeName, "木村課長");Assert.AreEqual(deserialize.Departments[0].Employees[1].Gender, "男");}
Arrange


*ApplicationDeployment.CurrentDeployment.DataDirectory
ApplicationDeployment.IsNetworkDeployedがtrueの時に取得可能


*string dataDirectory;
ClickOnceで配布されたアプリケーションを実行した場合は、

*dataDirectory = ApplicationDeployment.CurrentDeployment.DataDirectory;
データディレクトリに保存します (最後に'\'は含まないので注意)

*else*{// exeと同じパスに保存します (最後に'\'を含む)dataDirectory = AppDomain.CurrentDomain.BaseDirectory;}
直接exeを実行した場合は、

*dataDirectory = AppDomain.CurrentDomain.BaseDirectory;
exeと同じパスに保存します (最後に'\'を含む)

*string dataPath = Path.Combine(dataDirectory, "data.ini");
ディレクトリの最後の'\'の有無が異なるため、Path.Combineでつなげる

*using (var writer = new StreamWriter(dataPath)){writer.WriteLine("data");
出力


*Console.WriteLine("{0}ミリ秒", sw.ElapsedMilliseconds);
結果 → 3003ミリ秒


*var arObject = _markerNameAndPrefabDictionary[trackedImage.referenceImage.name];
認識した画像マーカーの名前を使って辞書から任意のオブジェクトを引っ張り出す

*var markerFrontRotation = imageMarkerTransform.rotation * Quaternion.Euler(90f, 0f, 0f);*arObject.transform.SetPositionAndRotation(imageMarkerTransform.transform.position, markerFrontRotation);
位置合わせ

*arObject.SetActive(trackedImage.trackingState == TrackingState.Tracking);
トラッキングの状態に応じてARオブジェクトの表示を切り替え


*this.LabelEdit = false;
テキストボックスを表示するので、編集不可にしておく


*private bool[] _disks;*public PennyFlipping(int n) {_number = n;_disks = new bool[n];}
falseが表

*public IEnumerable<(int, bool[])> Solve() {int count = 0;foreach (var n in Repeat(Enumerable.Range(1, _number))) {Turn(n);yield return (n, _disks.ToArray());count++;if (IsFin())break;}}
問題を解く

*private IEnumerable<int> Repeat(IEnumerable<int> nums) {while (true) {foreach (var n in nums)yield return n;}}
1,2,3,...n,1,2,3,...n,1,2,3,...nを永遠に繰り返す

*public void Turn(int n) {var r = _disks.Take(n).Reverse().ToArray();for (int i = 0; i < n; i++) {_disks[i] = !r[i];}}
先頭N枚のコインをひっくり返す。

*public bool IsFin() {return _disks.All(d => d == false);}
終了したかどうか

*public int Solve(Action<int, bool[]> progress) {int count = 0;foreach (var n in Repeat(Enumerable.Range(1, _number))) {Turn(n);progress(n, _disks.ToArray());count++;if (IsFin())break;}return count;}
問題を解く


*var index = keys.IndexOf(key);
for を駆使する場合もある。

*return values[index];
エラー判定は省略

*}
エラー処理は省略


*LoadCommand =new ReactiveCommand<RoutedEventArgs>()
必要に応じて.addToやClassTerminateなどでオブジェクトの解放を定義しておきます。

*hogehogeCommand=
例えばこんな感じのコマンドを作ってウィンドウを閉じることが出来ます。
このコードはメンバ定義もバインディングもしてないのでこのままでは動きません。


*int a = 100;
aとbそれぞれに、値を入れて、いろいろ試してみます。

*Console.WriteLine("a > b : {0}",     (a > b));
Javaなら、System.out.printf("a > b : %s%n", (a > b));とか。

*var array = new int[] { 3, 1, -2147483647, -5 };
整数値の配列

*var list = new List<int>(array);
リストに格納

*list.Sort((a, b) =>
ラムダ式で評価してソート


*if (1 is var x && (x = x * 2) != 1) { }
Intなので恐らく2倍して1になる数値はない


*tokenSource.Cancel();
Taskキャンセル


*AutomaticMigrationsEnabled = true;
trueに変更

*SetSqlGenerator("System.Data.SQLite", new SQLiteMigrationSqlGenerator());
以下のコードを追加

*var internalContext = context.GetType().GetProperty("InternalContext", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(context);
providerNameをコードを使って取得する。
コードを使わずに、直接"System.Data.SQLite"を使ってもいい
https:stackoverflow.com/questions/36060478/dbmigrator-does-not-detect-pending-migrations-after-switching-database

*var configuration = new Configuration()
Migratorが使うConfigurationを生成する。
TargetDatabaseはDbMigratorの方ではなく、Configurationの方に設定しないと効果が無い。

*var migrator = new DbMigrator(configuration);
DbMigratorを生成する

*var _historyRepository = migrator.GetType().GetField("_historyRepository", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(migrator);
EF6.13では問題ないが、EF6.2の場合にUpdateのタイミングで以下の例外が吐かれないようにする対策
System.ObjectDisposedException: '破棄されたオブジェクトにアクセスできません。
オブジェクト名 'SQLiteConnection' です。'
https:stackoverflow.com/questions/47329496/updating-to-ef-6-2-0-from-ef-6-1-3-causes-cannot-access-a-disposed-object-error/47518197

*migrator.Update();
Migrationを実行する。

*public DbSet<TestPoco> Tests { get; set; }
追加


*private const string ApiBaseUrl = "https:
www.finds.jpwsrgeocode.php?json&lon={0}&lat={1}";

*string url = string.Format(ApiBaseUrl, longitude, latitude);
URLに経緯度パラメータを埋め込み

*using (WWW www = new WWW(url)){API非同期実行用yield returnyield return www;
APIを実行して経緯度を保持

*yield return www;
API非同期実行用yield return

*var desirializedData = (Dictionary<string, object>)Json.Deserialize(www.text);
結果JSONのデシリアライズ

*var result = (Dictionary<string, object>)desirializedData["result"];
都道府県+市区町村を文字列として保持

*lonLatInfo = GameObject.Find("LonLatInfo").GetComponent<Text>();
テキストラベルオブジェクトを保持

*lonLatGetter = GetComponent<LonLatGetter>();
経緯度取得オブジェクトオブジェクトを保持

*lonLatToAddr = GetComponent<LonLatToAddr>();
逆ジオコーディングオブジェクトを取得


*var configuration = new Configuration();
Enable-Migrationsで自動生成されたクラス


*var list = new ArrayList();
適当に色んな型のオブジェクトをぶっこむ

*Type answerType = list[new Random().Next(0, list.Count - 1 )].GetType();
答えとなる型をランダムで選ぶ

*var methods = answerType.GetMethods().Where(x => x.IsPublic).Select(x => x.Name).Distinct().ToList();
ランダムで選んだ型のメンバから公開メソッドの名前のみを抽出、オーバーロードの重複はまとめる。

*string hintMethodName = methods[new Random().Next(0, methods.Count - 1)];*Console.WriteLine($"問題 : このオブジェクトは「{hintMethodName}」メソッドを持っています。型名は何でしょう？");
その中からランダムでヒントとなるメソッド名を一つ取得

*string answer = Console.ReadLine();
ヒントを参考に答えを入力


*public const int HOGE_HOGE = 1;
スネークケースは推奨されていない。

*public int iHoge { get; set; }
ハンガリアン記法も過去のもの。

*}
args[i] に何か処理。

*}
item に何か処理。

*Hoge(new string[] { });
どれもエラーにならない！

*return list.ToArray();
あれこれ list.Add() する処理

*return list;
あれこれ list.Add() する処理

*fuga.Add("");
書き込みはできない
コンパイルエラー


*var w = UIScreen.MainScreen.Bounds.Size.Width;
ディスプレイサイズ取得


*namespace CSVpractice.Models
このコードはテンプレートから生成されました。

このファイルを手動で変更すると、アプリケーションで予期しない動作が発生する可能性があります。
このファイルに対する手動の変更は、コードが再生成されると上書きされます。
</auto-generated>
------------------------------------------------------------------------------

*public class CsvReaderOneLine<T, U> :IDisposable where T:LineData,new() where U:class, new()*{private StreamReader reader;private bool skip;Stream fileStream;object ret;// コンストラクタpublic CsvReaderOneLine(Stream fileStream, bool skip=true, string filePath = ""){if(filePath != ""){if(!filePath.EndsWith(".csv", StringComparison.InvariantCultureIgnoreCase)){throw new FormatException("拡張子が.csvではないファイルが指定されました");}}this.fileStream = fileStream;this.skip = skip;reader = new StreamReader(fileStream);if (skip) reader.ReadLine();}public bool MoveNext(){string line = reader.ReadLine();if(line != null){string[] lineSplited = line.Split(',');var lineObj = new T();lineObj.SetDataFrom(lineSplited);var modelObj = new U();// ここの実装が力技すぎてダサい ----------------------PropertyInfo[] getItems = lineObj.GetType().GetProperties();foreach (PropertyInfo getItem in getItems){PropertyInfo[] tmpItems = modelObj.GetType().GetProperties();foreach (PropertyInfo tmpItem in tmpItems){if (getItem.Name == tmpItem.Name){tmpItem.SetValue(modelObj, getItem.GetValue(lineObj, null));}}}//---------------------------------------ret = modelObj;return true;}else{ret = null;return false;}}public object current{get{if(ret != null){return ret;}else{throw new NullReferenceException();}}}public void Reset(){reader.BaseStream.Seek(0, SeekOrigin.Begin);}public void Dispose(){this.reader.Dispose();}}
TはLineDataの継承(AddressMasterLineData)、UはModelのクラス(ADDRESS_MASTER)

*public CsvReaderOneLine(Stream fileStream, bool skip=true, string filePath = ""){if(filePath != ""){if(!filePath.EndsWith(".csv", StringComparison.InvariantCultureIgnoreCase)){throw new FormatException("拡張子が.csvではないファイルが指定されました");
コンストラクタ

*PropertyInfo[] getItems = lineObj.GetType().GetProperties();
ここの実装が力技すぎてダサい ----------------------

*public ActionResult Index()*{return View();}
GET: FileUpload


*string[] srcFilesPath = Directory.GetFileSystemEntries(sourceDirectory);
sourceディレクトリの全てのファイル・フォルダを取得(サブフォルダの内部までは見ない)
sourceフォルダに入れたものは全てAssetBundle化対象

*string fileName = Path.GetFileNameWithoutExtension(srcFilePath);
ファイルの名前を取得し、AssetBundleの名前に設定する

*string assetBundleDirectory = "Assets/AssetBundles/";
無いフォルダは作る

*BuildPipeline.BuildAssetBundles(assetBundleDirectory + iOSPath, BuildAssetBundleOptions.None, BuildTarget.iOS);
各OS向けにビルド

*BuildPipeline.BuildAssetBundles(assetBundleDirectory + editerPath, BuildAssetBundleOptions.None, BuildTarget.StandaloneOSX);
Windowsの方はBuildTarget.StandaloneWindowsにでも変更してください


*var m2 = new Messeage(2);
静的コンストラクターは実行されない


*chrome.Navigate().GoToUrl(@"http:
www.opoona.com");

*var options = new ChromeOptions();
ChromeOptionsオブジェクトを生成します。

*options.AddArgument("--headless");
--headlessを追加します。

*var chrome = new ChromeDriver(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location), options);
ChromeOptions付きでChromeDriverオブジェクトを生成します。

*Console.WriteLine(chrome.Title);
URLに移動します。
chrome.Url = @"http:www.opoona.com/";
タイトルを表示します。

*Console.ReadKey();
すぐ終了しないよう、キーが押されるまで待機します。

*chrome.Quit();
ブラウザを閉じます。


*void Update()*{if (_proxy == null){_proxy = GetComponent<VRMBlendShapeProxy>();}else{foreach (BlendShapePreset t in Enum.GetValues(typeof(BlendShapePreset))){_proxy.SetValue(t, GetPropertyValue(t));}}}
Update is called once per frame


*BitmapSource GetImageSourceLock(string path,Rotation rotation = Rotation.Rotate0) {
単純なImageコントロールへの画像のセット

*BitmapSource GetImageSource(string path,Rotation rotation = Rotation.Rotate0) {
画像ファイルロックをしないコントロールへの画像のセット


*DataRow dr;
DataRowを宣言

*dr = dt.NewRow();
行を作成

*dt.Rows.Add(dr);
行を表に追加

*dt.Rows.Add(dr);
※以下のような書き方も可能。ただし、列と値、その位置は揃える事。
⇒『td.Rows.Add(001, "test", "田中太郎");』


*dtGetLog = (DateTime)pso.Properties["TimeCreated"].Value;
ログの日付取得

*}
なんかやりたい本処理
～～～～～～～～～～～～～～～～～～


*return (T) _componentCache[type];
Dictionaryから返却

*samplerNormal.Begin();
普通の使い方

*samplerDefaultGetComponent.Begin();
GetComponentおじさん

*samplerOverrideGetComponent.Begin();
貼るだけで速くなるコード(?)

*samplerCache.Begin();
メンバ変数でキャッシュ

*//    {//        var type = typeof(T);//        if (_componentCache.ContainsKey(type) == false)//        {//            var component = base.GetComponent<T>();//            if (component == null) component = gameObject.AddComponent<T>();////            _componentCache.Add(type, component);//        }////        return (T) _componentCache[type];//    }
public new T GetComponent<T>() where T : Component

*//        {//            var component = base.GetComponent<T>();//            if (component == null) component = gameObject.AddComponent<T>();////            _componentCache.Add(type, component);//        }
if (_componentCache.ContainsKey(type) == false)

*//            if (component == null) component = gameObject.AddComponent<T>();*//
var component = base.GetComponent<T>();

*public new T GetComponent<T>() where T : Component*{return (T) _componentCache[typeof(T)];}
}


*public const int UPPER_LIMIT = 999999999;
上限値

*public const int LOWER_LIMIT = 0;
下限値

*} else {
問題がなければ、二値の和をそのまま返す。


*public override bool TrySetMember(SetMemberBinder binder, object value)*{this.dictionary[binder.Name] = value;return true;}
プロパティに値を設定しようとしたときに呼ばれる

*public override bool TryGetMember(GetMemberBinder binder, out object result)*{result = this.dictionary[binder.Name];return true;}
プロパティから値を取得しようとしたときに呼ばれる

*dynamic args = new ArgsObject();
ここでdynamicを使用することが大事


*if (m.Msg == 0x31D && Clipboard.ContainsImage()) OnClipboardImageUpdate();
WM_CLIPBOARDUPDATE

*}*protected virtual void OnClipboardImageUpdate() {if (!_notifyIcon.ContextMenu.MenuItems[0].Checked) return;uint seq = GetClipboardSequenceNumber();if (seq == _lastSeq) return;_lastSeq = seq;var t = new Thread(() => {Image img;if (Clipboard.ContainsData("PNG")) {IDataObject data  = Clipboard.GetDataObject();img = Image.FromStream((Stream)data.GetData("PNG"));} else {img = Clipboard.GetImage();}if (img != null && img.Height >= _minImageSize && img.Width >= _minImageSize) {string filename = Path.Combine(_imageDir, @"ScreenShot-" + DateTime.Now.ToString("yyyyMMddHHmmss") + ".png");img.Save(filename, System.Drawing.Imaging.ImageFormat.Png);if (_notifyIcon.ContextMenu.MenuItems[1].Checked) {_notifyIcon.ShowBalloonTip(1000,"","Screenshot saved!", ToolTipIcon.Info);} else {Console.Beep(500,200);}}});t.SetApartmentState(ApartmentState.STA);t.Start();}
t.Join();  uncomment to avoid "System.Runtime.InteropServices.ExternalException (0x800401D0)" error


*private int _version;
Do not rename (binary serialization)


*_ansPos0[_star[0]] = 1;
位置0に置いた番号を記憶する 対称性排除のため

*if (_tipIndexes.Contains(nextix) && _ansPos0.ContainsKey(n))*continue;
回転して得られる対称解を省く

*public bool IsAnswer() {return GetLines(_star).All(line => line.Sum() == 26);}
解か？

*public bool IsCorrect() {foreach (var line in GetLines(_star)) {// 26より大きければダメif (line.Sum() > 26)return false;// 直線に数字が全て埋まっていて、26より小さければダメif (line.All(x => x > 0) && line.Sum() < 26)return false;// 鏡像を省くif ((_star[2] != 0 && _star[3] != 0) && (_star[2] > _star[3]))return false;}return true;}
正しいか （途中の状態を調べる）

*if (line.Sum() > 26)*return false;
26より大きければダメ

*if (line.All(x => x > 0) && line.Sum() < 26)*return false;
直線に数字が全て埋まっていて、26より小さければダメ

*if ((_star[2] != 0 && _star[3] != 0) && (_star[2] > _star[3]))*return false;
鏡像を省く

*public IEnumerable<int[]> GetLines(int[] stars) {yield return new int[] { stars[0], stars[2], stars[5], stars[7] };yield return new int[] { stars[0], stars[3], stars[6], stars[10] };yield return new int[] { stars[1], stars[2], stars[3], stars[4] };yield return new int[] { stars[1], stars[5], stars[8], stars[11] };yield return new int[] { stars[7], stars[8], stars[9], stars[10] };yield return new int[] { stars[4], stars[6], stars[9], stars[11] };}
6本の直線を列挙する

*static class EnumerableExtensions {public static IEnumerable<(T, int)> Enumerate<T>(this IEnumerable<T> seq, int startIndex) {var i = startIndex;foreach (var e in seq) {yield return (e, i);i++;}}}
こんな拡張メソッド書けば、インデックス付きのforeachができる。


*public decimal CalculatePaymentPrice(decimal price, bool canRemoveTax, bool canDiscount)*{if (price < 0){throw new ArgumentOutOfRangeException("商品価格は0以上の数値を入力してください。");}else if (canRemoveTax){// 消費税なしで割引適用if (canDiscount){return price * 0.9m;}else{return price;}}else{// 消費税ありで割引適用if (canDiscount){return price * 1.08m * 0.9m;}else{return price * 1.08m;}}}
客が支払う金額を計算する

*decimal taxRate;
消費税率確定

*decimal discountRate;
割引率確定

*return price * (1m + taxRate) * discountRate;
支払価格を計算する


*return year % 4 == 0 && year % 100 != 0;
400で割り切れないので、4で割り切れるかつ100で割り切れない

*country = GetCountry(countryId);
数行の処理

*Country country = GetCountry(countryId);
数行の処理


*Content = new StackLayout
C＃勉強会、５日目のコンストラクターの生成構文参照


*if (sdr.Read())
コマンドによってwhileだったりifだったりする

*return true;
ここに処理を書く


*using System.Net.NetworkInformation;*namespace test
Pingを使用するにはこの名前空間が必要。

*var reply = ping.Send("google.com");
Sendメソッドでリクエストを送り、結果を格納したPingReplyクラスを返す。

*var isSucceeded = replies.Any(reply => reply.Status == IPStatus.Success);*Console.WriteLine($"ping succeeded is {isSucceeded}");
Pingの返答が正しく返ってきたときはStatusプロパティでIPStatus列挙のSuccessを返す。Success以外はFalseである

*var averageTime = replies.Average(reply => reply.RoundtripTime);*Console.WriteLine($"ping average time is {averageTime}");
時間がどれだけかかったかを知りたい場合はRoundtripTimeプロパティで取得可能


*var h = new Hoge ("constructor"){value = "initializer"};
それぞれの（）{}で、コメントアウトすると、結果が変わるよ☆


*var task = Task.Run(async () =>*{//１．ここでawaitすると同期処理にvar alpha = GetsSum(5);var bravo = GetsSum(7);//２．ここでawaitすると非同期処理にint a = await alpha;int b = await bravo;Console.WriteLine($"{a}+{b}={a + b}");});
Main内でasyncする場合はTaskを用意して走らせる必要がある。

*var alpha = GetsSum(5);
１．ここでawaitすると同期処理に

*int a = await alpha;
２．ここでawaitすると非同期処理に

*static async Task<int> GetsSum(int interval)*{Console.WriteLine($"task start interval {interval}");var intTask = Task<int>.Run(() =>{var sum = 0;for (int i = 0; i < 1000/interval; i++){sum += i;Console.WriteLine($"interval {interval}'s sum : {sum}");Thread.Sleep(interval);}return sum;});return await intTask;}
一定時間ごとに値を加算、コンソールに出力する。


*void Fetch(int number) {// 重い処理。Thread.Sleep(100);}
00:00:02.0102643

*Thread.Sleep(100);
重い処理。

*,,,*source.AsParallel().ForAll(i => {Fetch(i);});
00:00:02.0139477

*,,,*Parallel.ForEach(source, i => {Fetch(i);});
00:00:00.5032450


*await Task.Delay(1000);
1秒差でColdなObservableソースを2回購読


*{
文法ファイルが存在する場合

*MessageBox.Show("音声認識の設定に失敗しました。", "音声認識", MessageBoxButtons.OK,MessageBoxIcon.None, MessageBoxDefaultButton.Button1, MessageBoxOptions.DefaultDesktopOnly);
音声認識の設定に失敗

*this.checkBoxVoiceInput.Enabled = false;
チェックボックス(音声入力)を非活性

*this.Engine.Dispose();
音声認識エンジンのオブジェクトを解放

*this.Engine = null;
音声認識エンジンを初期化

*var lines = File.ReadAllLines(path, Encoding.Default).Where(line => !line.StartsWith(comment)).ToList();
コメント以外の行を取得

*string dirPath = Path.GetDirectoryName(path);
ファイルを作成するフォルダが存在するかチェック
存在しない場合は、フォルダを作成

*File.AppendAllText(path, data, Encoding.Default);
ファイルの末尾に書き加える

*File.WriteAllText(path, data, Encoding.Default);
ファイルを上書きする


*public class Employee*{// 従業員IDpublic int Id { get; set;}// 部署IDpublic int DepartmentId { get; set;}// 従業員名public string Name { get; set;}}
従業員

*public int Id { get; set;}
従業員ID

*public int DepartmentId { get; set;}
部署ID

*public string Name { get; set;}
従業員名

*public class Department*{// 部署IDpublic int Id { get; set;}// 部署名public string Name { get; set;}}
部署

*public int Id { get; set;}
部署ID

*public string Name { get; set;}
部署名

*var employeeList = new List<Employee>*{new Employee { Id = 100, Name = "佐藤", DepartmentId = 1 },new Employee { Id = 101, Name = "鈴木", DepartmentId = 2 },new Employee { Id = 102, Name = "高橋", DepartmentId = 3 },new Employee { Id = 103, Name = "田中", DepartmentId = 2 },new Employee { Id = 104, Name = "伊藤", DepartmentId = 1 },new Employee { Id = 105, Name = "渡辺", DepartmentId = 3 },new Employee { Id = 106, Name = "山本", DepartmentId = 1 },};
従業員データ

*var departmentList = new List<Department>*{new Department { Id = 1, Name = "開発部" },new Department { Id = 2, Name = "研究部" },new Department { Id = 3, Name = "総務部" }};
部署データ

*public class Employee*{// 従業員IDpublic int Id { get; set;}// 部署ID(null許容型)public int? DepartmentId { get; set;}// 従業員名public string Name { get; set;}}
従業員

*public int Id { get; set;}
従業員ID

*public int? DepartmentId { get; set;}
部署ID(null許容型)

*public string Name { get; set;}
従業員名

*public class Department*{// 部署IDpublic int Id { get; set;}// 部署名public string Name { get; set;}}
部署

*public int Id { get; set;}
部署ID

*public string Name { get; set;}
部署名

*var employeeList = new List<Employee>*{new Employee { Id = 100, Name = "佐藤", DepartmentId = 1 },new Employee { Id = 101, Name = "鈴木", DepartmentId = 2 },new Employee { Id = 102, Name = "高橋", DepartmentId = null },new Employee { Id = 103, Name = "田中", DepartmentId = null },new Employee { Id = 104, Name = "伊藤", DepartmentId = 1 },new Employee { Id = 105, Name = "渡辺", DepartmentId = 3 },new Employee { Id = 106, Name = "山本", DepartmentId = 1 },};
従業員データ

*var departmentList = new List<Department>*{new Department { Id = 1, Name = "開発部" },new Department { Id = 2, Name = "研究部" },new Department { Id = 3, Name = "総務部" }};
部署データ


*void Start () {//オブジェクトの色を赤に変更するGetComponent<Renderer>().material.color = Color.red;}
Use this for initialization

*GetComponent<Renderer>().material.color = Color.red;
オブジェクトの色を赤に変更する

*void Update () {}
Update is called once per frame

*void Start () {//オブジェクトの色をRGBA値を用いて変更するGetComponent<Renderer>().material.color = new Color32(248, 168, 133, 1);}
Use this for initialization

*GetComponent<Renderer>().material.color = new Color32(248, 168, 133, 1);
オブジェクトの色をRGBA値を用いて変更する

*void Update () {}
Update is called once per frame

*void Start () {//オブジェクトの色を用意したMaterialの色に変更するGetComponent<Renderer>().material.color = colorA.color;}
Use this for initialization

*GetComponent<Renderer>().material.color = colorA.color;
オブジェクトの色を用意したMaterialの色に変更する

*void Update () {}
Update is called once per frame


*Console.Beep(540, 250);
BEEPでカエルの歌の途中まで作成


*}
ここでHook登録

*}
ここでHook削除

*args.Handled = true;
処理するので処理しましたフラグを建てる

*BinaryReader reader = new BinaryReader(new MemoryStream(args.Msg.readBuffer, args.Index, args.Length));
今回はゴーストが移動したときにテレポートさせたいだけなので、一度テラリアサーバーが行う処理と同じことをする。

*ShortTeleportGhost(player);
ゴーストを短距離テレポート

*RemoteClient.CheckSection(playerIndex, player.position);
ゴーストにタイル情報送信

*}
今は何もしない

*private int[,] lastControlChangedTicks = new int[Main.player.Length, 4];
配列に入力切り替わり時間と前回の入力を保存しておく(上左下右)

*Vector2 teleportOffset = Vector2.Zero;
テレポート相対位置

*lastControlChangedTicks[playerIndex, 0] = currentGameTick;
プレイヤーコントロール入力変化(上入力あり→なし)

*lastControlChangedTicks[playerIndex, 1] = currentGameTick;
プレイヤーコントロール入力変化(上入力あり→なし)

*lastControlChangedTicks[playerIndex, 2] = currentGameTick;
プレイヤーコントロール入力変化(左入力あり→なし)

*lastControlChangedTicks[playerIndex, 3] = currentGameTick;
プレイヤーコントロール入力変化(右入力あり→なし)

*lastPlayerControl[playerIndex, 0] = player.controlUp || player.controlJump;
プレイヤー入力を記録(パケットが来るまで入力は変化しないため、リセット等は必要ない)

*}
TODO: 実際にテレポートさせる

*if (teleportOffset != Vector2.Zero)
(省略)
移動距離が0以外の場合

*NetMessage.SendData((int)PacketTypes.PlayerUpdate, playerIndex, -1, null, playerIndex);
クライアントにプレイヤー情報送信(事実上のテレポート)

*private int[,] lastControlChangedTicks = new int[Main.player.Length, 4];
配列に入力切り替わり時間と前回の入力を保存しておく(上左下右)

*args.Handled = true;
処理するので処理しましたフラグを建てる

*BinaryReader reader = new BinaryReader(new MemoryStream(args.Msg.readBuffer, args.Index, args.Length));
今回はゴーストが移動したときにテレポートさせたいだけなので、一度テラリアサーバーが行う処理と同じことをする。

*ShortTeleportGhost(player);
ゴーストを短距離テレポート

*RemoteClient.CheckSection(playerIndex, player.position);
ゴーストにタイル情報送信

*Vector2 teleportOffset = Vector2.Zero;
テレポート相対位置

*lastControlChangedTicks[playerIndex, 0] = currentGameTick;
プレイヤーコントロール入力変化(上入力あり→なし)

*lastControlChangedTicks[playerIndex, 1] = currentGameTick;
プレイヤーコントロール入力変化(上入力あり→なし)

*lastControlChangedTicks[playerIndex, 2] = currentGameTick;
プレイヤーコントロール入力変化(左入力あり→なし)

*lastControlChangedTicks[playerIndex, 3] = currentGameTick;
プレイヤーコントロール入力変化(右入力あり→なし)

*lastPlayerControl[playerIndex, 0] = player.controlUp || player.controlJump;
プレイヤー入力を記録(パケットが来るまで入力は変化しないため、リセット等は必要ない)

*NetMessage.SendData((int)PacketTypes.PlayerUpdate, playerIndex, -1, null, playerIndex);
クライアントにプレイヤー情報送信(事実上のテレポート)


*StringBuilder conditions = new StringBuilder("WHERE key IN (");
WHERE句生成

*StringBuilder conditions = new StringBuilder("WHERE key IN (");
WHERE句生成


*{ "h|help", "show help.", v => help = v != null },
引数を取らないオプション


*return Gcd(b, a);
引数を入替えて自分を呼び出す

*private static void PrintNumber(int n) {Console.WriteLine(n.ToString());}
8桁の数が求められるたびに呼び出される。


*return 1000.0 * (double)sw.ElapsedTicks
(double)Stopwatch.Frequency;  処理時間


*GUILayout.EndHorizontal();
【サービスの行表示】 終了

*m_PastedCredentials = EditorGUILayout.TextArea(m_PastedCredentials);
Credential情報を貼り付けるテキストエリア

*GUI.SetNextControlName("Apply");
Credential情報を反映するApplyボタン

*cfg.Credentials.Add(newInfo);
過去にCredential情報があれば削除する処理

*SaveConfig();
成功もしくは失敗のダイアログを表示

*}
実際の処理は省略


*public bool Equals(AVocaloid other)*{return LastName == other.LastName;}
LastNameのみで等値性を評価

*public override int GetHashCode()*{return LastName.GetHashCode();}
LastNameのみでハッシュ値を生成

*class Vocaloid : AVocaloid*{}
具象クラスを定義する

*var groups = people.GroupBy(v => v);
LastNameでグループ化する（ここで「既定の等値比較子」を使用している）

*var groups = people.GroupBy(v => (AVocaloid)v);
LastNameでグループ化する（ここで「既定の等値比較子」を使用している）

*public override bool Equals(object obj)*{return obj is AVocaloid ? Equals((AVocaloid)obj) : base.Equals(obj);}
これを追加

*public static bool operator==(AVocaloid obj1, AVocaloid obj2){return obj1.Equals(obj2);
ついでに演算子も追加しておく


*}
df.Dispose() が呼ばれる


*var p = new Person ("太朗","山田");
引数をこれで指定

*public Person(string firstName,string lastName){this.FirstName = firstName;this.LastName = astName;}
コンストラクター（フィールドの初期値を明示）

*public Person () :this("權兵衞","名無し"){}
コンストラクター(引数を省略)


*var lines = File.ReadLines("FileName");
ディレクトリ名が入ったテキストファイルからディレクトリ情報を取得し、IEnumerable<DirectoryInfo>を生成

*var nestedFiles = directories.Select(directory=>directory.EnumerateFiles());
上で作成したディレクトリ情報集をもとに、ネストされたファイル情報集を生成する
このときnestedFilesの型はIEnumerable<IEnumerable<FileInfo>>である

*var lines = File.ReadLines("FileName");
ディレクトリ名が入ったテキストファイルからディレクトリ情報を取得し、IEnumerable<DirectoryInfo>を生成

*var nestedFiles = directories
上で作成したディレクトリ情報集をもとに、ネストされたファイル情報集を生成する
このときnestedFilesの型はIEnumerable<IEnumerable<FileInfo>>である

*var flatternFiles = nestedFiles.SelectMany(file=>file);
ネストされたファイル情報集を平坦化する。


*var row = rows.Where(x => x.name == "yamada");
抽出

*var row = rows.FirstOrDefault(x => x.id == 2);
1件抽出

*var row = rows.Select(x => x * x);
全件に処理

*var row = rows.Any(x => x.id == 2);
存在確認


*}
空を飛ばないので、このメソッドでは何もしない

*}
歩かずに常に空を飛んで移動するので、このメソッドでは何もしない


*Debug.Log(b[i]);
配列外アクセス


*string[] marks = new string[] { "ハート", "スペード", "クラブ", "ダイヤ" };
マーク

*string[] nos = new string[] { "A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K" };
数字

*List<string> decks = new List<string>();
山札作成

*decks.Add($"{mark}の{no}");
「ハートの5」、「スペードのJ」などの文字列が順番にdecksに代入される

*Random random = new Random();
カードを引く

*}
......ここで条件分岐。1と11と12と13の場合、AとJとQとKを返却する

*}
......ここで条件分岐。11と12と13の場合、ともに10を返却する


*textField.EditingDidEnd += (sender, args) => { textField.Text = ""; };
これを追加

*//{//    plugin.Load();//}
public void Include(MvvmCross.Plugin.Json.Plugin plugin)


*var config = Configuration.Default.WithDefaultLoader();
対象ページを読み込み
const string _targetUrl = "https:www.seiyu.co.jp/service/5off/";

*var saleDays = doc.QuerySelectorAll("li.off_calendar_item").Select(_ =>*{return new SaleDay{Month = int.TryParse(_.QuerySelector("span.off_calendar_month").InnerHtml.Replace("/", ""), out var month) ? month : 0,Day = int.TryParse(_.QuerySelector("span.off_calendar_day").InnerHtml, out var day) ? day : 0,};});
セールの月日を取得

*var isExtendingYears = saleDays.Select(_ => _.Month).Distinct().All(_ => _ == 1 || _ == 12);
年をまたぐかどうか

*var currentYear = DateTime.Now.Year;
セールの年を設定して返す
（対象ページには年は表示されていないのでこちらで設定する）

*public string UniqueId { get { return StartDateTime.ToString("yyyyMMdd"); } }
以下iCalendar用の項目

*var body = new StringBuilder();*{body.AppendLine("BEGIN:VCALENDAR");body.AppendLine($"PRODID:{ProdId}");body.AppendLine("VERSION:2.0");body.AppendLine("METHOD:PUBLISH");{body.AppendLine("BEGIN:VTIMEZONE");body.AppendLine("TZID:Asia/Tokyo");{body.AppendLine("BEGIN:STANDARD");body.AppendLine("DTSTART:19390101T000000");body.AppendLine("TZOFFSETFROM:+0900");body.AppendLine("TZOFFSETTO:+0900");body.AppendLine("TZNAME:JST");body.AppendLine("END:STANDARD");}body.AppendLine("END:VTIMEZONE");}// セール日をそれぞれイベントとして生成するforeach (var _ in saleDays){body.AppendLine("BEGIN:VEVENT");{body.AppendLine("CLASS:PUBLIC");body.AppendLine($"UID:{_.UniqueId}");body.AppendLine($"DTSTAMP:{timestamp}");body.AppendLine($"SUMMARY:{_.Summary}");body.AppendLine($"DESCRIPTION:{_.Description}");body.AppendLine($"DTSTART;VALUE=DATE:{_.StartDateTime:yyyyMMdd}");body.AppendLine($"DTEND;VALUE=DATE:{_.EndDateTime:yyyyMMdd}");}body.AppendLine("END:VEVENT");}body.AppendLine("END:VCALENDAR");}
http:www.asahi-net.or.jp/~ci5m-nmr/iCal/ref.html

*public ApiGatewayResponse FunctionHandler(ILambdaContext context)*{// セール日を取得var webScraper = new WebScraper();var saleDays = webScraper.GetSaleDaysAsync();saleDays.Wait();// iCal形式に変換var converter = new CalendarConverter();var calendar = converter.Convert(saleDays.Result);// API Gateway用のレスポンス形式に変換// ★ハマったポイント: Json文字列ではなく、オブジェクトを返すこと！var response = ToApiGatewayResponseAsync(calendar);response.Wait();return response.Result;}
★ハマったポイント: 戻り値はstringではなくクラス

*var webScraper = new WebScraper();
セール日を取得

*var converter = new CalendarConverter();
iCal形式に変換

*var response = ToApiGatewayResponseAsync(calendar);
API Gateway用のレスポンス形式に変換
★ハマったポイント: Json文字列ではなく、オブジェクトを返すこと！


*col.SendMessage ("Damage");
ダメージを与えて

*Destroy (this.gameObject);
自分は消える

*void Start () {myRect = GetComponent<RectTransform> ();}
Use this for initialization

*void Update () {myRect.LookAt (Camera.main.transform);}
Update is called once per frame


*var storage = await StorageClient.CreateAsync();*var storageObject = storage.GetObject(bucketName, $"{path}/{fileName}");
Google Storage

*storageObject.CacheControl = "no-cache";
キャッシュを無効にするように追加


*tokenSource.Cancel();
Taskキャンセル


*var pinchMultiply = 0.001f;
適当に調整するなりしてください

*transform.localScale += (pinchDistanceDelta * pinchMultiply) * Vector3.one;*})
ピンチで拡大・縮小


*InitOnlyProperty = "baz",
OK


*values.Select(v => v * v);
結果：1, 4, 9, 16, 25


*HttpPostedFileBase file = model.UploadFile;
その1

*string path = System.Web.Hosting.HostingEnvironment.MapPath(""C:/test/test/" + fileName);
その2

*}
その3
ファイルを読み込む

*}
取得したデータをDBに登録する処理


*PlayGamesClientConfiguration config = new PlayGamesClientConfiguration.Builder().EnableSavedGames().Build();
ログイン処理例

*public void PressCloudSyncButton() {OpenSavedGame();}
バックアップボタンから呼ぶメソッド

*public void OpenSavedGame() {if (!hasInternetConnection) {Debug.Log("No Internet Connection");return;}if (!isAuthed) {Debug.Log("Not Authed");return;}isSaving = false;Debug.Log("Opening savedGame in the cloud");((PlayGamesPlatform)Social.Active).SavedGame.OpenWithAutomaticConflictResolution(saveFileName,DataSource.ReadCacheOrNetwork,ConflictResolutionStrategy.UseLongestPlaytime,OnSavedGameOpened);}
まずクラウド上のファイルをOPEN

*((PlayGamesPlatform)Social.Active).SavedGame.OpenWithAutomaticConflictResolution(*saveFileName,
first, open the file

*void OnSavedGameOpened(SavedGameRequestStatus status, ISavedGameMetadata gameMetadata) {if (status == SavedGameRequestStatus.Success) {openedSavedGame_commitDate = gameMetadata.LastModifiedTimestcurrentOpenedSavedGameMetadata = gameMetadata;if (isSaving) {BuildBackupDate();byte[] data = ToBytes(saveString);var builder = new SavedGameMetadataUpdate.Builder();var updateMetadata = builder.WithUpdatedPlayedTime(GameController.statTotalBattleTime).WithUpdatedDescription("SAVED AT:" + DateTime.UtcNow.ToLocalTime().ToShortDateString()).Build();((PlayGamesPlatform)Social.Active).SavedGame.CommitUpdate(gameMetadata, updateMetadata, data, OnSavedGameWritten);} else {SAVEDGAME_STATUS stat = SAVEDGAME_STATUS.Default;if (gameMetadata.Description == null || gameMetadata.Description == "") {stat = SAVEDGAME_STATUS.NoData;}if (gameMetadata.TotalTimePlayed > GameController.statTotalBattleTime) {stat = SAVEDGAME_STATUS.LongerPlaytime;} else {if (gameMetadata.TotalTimePlayed == GameController.statTotalBattleTime) {stat = SAVEDGAME_STATUS.Default;} else {stat = SAVEDGAME_STATUS.ShorterPlaytime;}}switch (stat) {case SAVEDGAME_STATUS.Default:Debug.Log("バックアップデータの更新は不要です");break;case SAVEDGAME_STATUS.NoData:case SAVEDGAME_STATUS.LongerPlaytime:case SAVEDGAME_STATUS.ShorterPlaytime:OpenDialog(stat);break;}}}}
OPENできたらwrite/readする

*void OpenDialog(SAVEDGAME_STATUS stts) {Debug.Log("OPEN DIALOG:" + stts);switch (stts) {default:break;case SAVEDGAME_STATUS.NoData:Debug.Log("バックアップデータがありません、バックアップしますか？");break;case SAVEDGAME_STATUS.ShorterPlaytime:Debug.Log("バックアップしますか？");break;case SAVEDGAME_STATUS.LongerPlaytime:Debug.Log("バックアップしたデータをロードしますか？");break;}}
ダイアログ表示,YES NOを選択すると対応するメソッドを呼ぶ。具体的な内容にはこの記事では触れない

*saveString = "(バックアップしたいデータ)";
バックアップしたいデータをここで代入する

*void DistributeLoadedData(byte[] dataFromCloud) {if (dataFromCloud == null) {Debug.Log("No data saved on the cloud yet");return;}Debug.Log("Decoding cloud data from bytes.");string stringFromCloud = FromBytes(dataFromCloud);if (stringFromCloud == "") {Debug.Log("No data saved on the cloud yet");return;}//データを反映するHogeHoge(SaveString);//念の為アプリを落とすQuitApp();}
ロードしたデータをゲームに反映する処理

*HogeHoge(SaveString);
データを反映する

*QuitApp();
念の為アプリを落とす


*OpenWithArguments(option);
メソッド呼び出し

*static void OpenWithArguments(string options)*{Process cmd = new Process();cmd.StartInfo.FileName = "PowerShell.exe";//PowerShellのWindowを立ち上げずに実行。cmd.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;// 引数optionsをShellのコマンドとして渡す。cmd.StartInfo.Arguments = options;cmd.Start();}
PowerShellの実行メソッド（引数:PowerShellコマンド)

*cmd.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
PowerShellのWindowを立ち上げずに実行。

*cmd.StartInfo.Arguments = options;
引数optionsをShellのコマンドとして渡す。


*i
= 1024; GB


*foreach (var prime in primes)
<- ここで例外が発生する


*private void DragDrop(object sender, DragEventArgs e)*{// ドロップされたファイルを順に確認するforeach (string file in (string[])e.Data.GetData(DataFormats.FileDrop)){// ファイルの拡張子を取得string extension = Path.GetExtension(file);// ファイルへのショートカットは拡張子".lnk"if (".lnk" == extension){IWshRuntimeLibrary.WshShell shell = new IWshRuntimeLibrary.WshShell();// ショートカットオブジェクトの取得IWshRuntimeLibrary.IWshShortcut shortcut = (IWshRuntimeLibrary.IWshShortcut)shell.CreateShortcut(file);// ショートカットのリンク先の取得string targetPath = shortcut.TargetPath.ToString();}}}
ドロップ時のイベント

*string extension = Path.GetExtension(file);
ファイルの拡張子を取得

*IWshRuntimeLibrary.IWshShortcut shortcut = (IWshRuntimeLibrary.IWshShortcut)shell.CreateShortcut(file);
ショートカットオブジェクトの取得

*string targetPath = shortcut.TargetPath.ToString();
ショートカットのリンク先の取得


*where T : Enum
コンパイルエラー


*Assert.Equal($"おはよう！{name}さん！", greeting);
Assert


*Console.WriteLine(src);
Point2D { X = 10, Y = 20 }


*void Start () {ClockText = GetComponentInChildren<Text>();}
Use this for initialization

*void Update () {ClockText.text = DateTime.Now.ToLongTimeString();}
Update is called once per frame

*ClockText.text = DateTime.Now.ToShortTimeString();
時、分を取得する（hh:mm (AM/PM)）

*ClockText.text = DateTime.Now.ToLongTimeString();
時、分、秒を取得する（hh:mm:ss (AM/PM)）

*ClockText.text = DateTime.Now.ToShortTimeString();
日付を取得する（MM/dd/yyyy）

*ClockText.text = DateTime.Now.ToLongTimeString();
日付を取得する（曜日,日付,yyyy）


*public Color Get(string name)
パレットから色を取得
---------------------------------------------------

*[MenuItem("Tool/Create ColorPallet")]
ScriptableObject 作成
---------------------------------------------------

*var element = property.GetArrayElementAtIndex(ii);
カラーパレットからデータを取得

*asset.list.Add(data);
ScriptableObject にデータを格納


*int fcount = 0;
0の数

*private bool NeedCount(bool[] line) {if (IsRound(line))// 左右対称ならば、他に鏡像となるパターンはないので、これは調べる必要がある。return true;// 左右対称でないならば、鏡像のパターンが他にもうひとつあるので、// 片方だけを調べるようにする。return ToInt(line.Reverse().ToArray()) > ToInt(line);}
鏡像をカウントしないようにするための判定メソッド

*return true;
左右対称ならば、他に鏡像となるパターンはないので、これは調べる必要がある。

*return ToInt(line.Reverse().ToArray()) > ToInt(line);
左右対称でないならば、鏡像のパターンが他にもうひとつあるので、
片方だけを調べるようにする。

*private bool IsRound(bool[] line) {int j = line.Length - 1;int i = 0;while (i < j) {if (line[i++] != line[j--]) {return false;}}return true;}
ビットパターンが左右対称かどうかを調べる

*private int ToInt(bool[] line) {return line.Aggregate(0, (r, b) => r * 2 + (b ? 1 : 0));}
bool[]をビットパターンとみなし、intに変換する

*public bool[] ToArray(int n, int width) {var array = new bool[width];int mask = 1;width.Times(i => {array[i] = (n & mask) != 0;mask <<= 1;});return array;}
整数nを width個からなるbool配列に変換する

*private bool[] NextLine(bool[] line) {var next = new bool[line.Length - 1];int i = 0;// ここで、Aggregateを使うのは邪道かな？line.Aggregate((a, b) => {next[i++] = a ^ b;return b;});return next;}
1段下のラインを排他的論理和を使い求める

*line.Aggregate((a, b) => {next[i++] = a ^ b;return b;});
ここで、Aggregateを使うのは邪道かな？

*public static void ForEach<T>(this IEnumerable<T> source, Action<T> action) {foreach (var x in source) {action(x);}}
要素の数だけ、actionを呼び出す

*public static void Times(this int count, Action<int> action) {for (int i = 0; i < count; i++)action(i);}
n回、actionを呼び出す


*builder.SetPositiveButton("OK", (EventHandler<DialogClickEventArgs>)null);
(1)コールバック関数なしでボタンを登録する

*public void OnShow(IDialogInterface dialog){// ダイアログが表示された後でないとButtonを取得できないvar okButton = dialog_.GetButton((int)Android.Content.DialogButtonType.Positive);okButton.Click += OkEventHandler;}
(2)ダイアログが表示された時にボタンにコールバックを割当てる

*var okButton = dialog_.GetButton((int)Android.Content.DialogButtonType.Positive);
ダイアログが表示された後でないとButtonを取得できない

*private void OkEventHandler(object sender, EventArgs args){// (3)条件を満たした場合はDismiss()でダイアログを閉じるif(is_satisfy_close_condition())dialog_.Dismiss();}
OKボタンが押されたとき

*if(is_satisfy_close_condition())*dialog_.Dismiss();
(3)条件を満たした場合はDismiss()でダイアログを閉じる


*: dotCount
2;                           一辺の要素数が偶数の時

*matrix[row, col] = random.Next( 0, 2 ) == 1 ? true : false;
行列の左半分にランダムにドットを打つ

*matrix[row, ( dotCount - 1 ) - col] = matrix[row, col];
行列の右半分にコピー

*var dotPattern = CreateSymmetricalDotPatternRandomly( COUNT_DOT, random );
ドットパターンをランダムに生成

*var foreColor = GetColorRandomly( random );*var backGroundColor = CreateInvertedColor( foreColor );
前景色・背景色を生成

*var image = new Bitmap( pictureBox.ClientSize.Width, pictureBox.ClientSize.Height );
アイデンティコンを描画


*CollectionAssert.AreEquivalent(new string[] { "A", "B", }, new string[] { "B", "A", });
AreEquivalentは順不同

*CollectionAssert.IsSubsetOf(new string[] { "C", "B", }, new string[] { "A", "B", "C", });
IsSubsetOfは順不同


*return this.data;
thisで、フィールドのdataにアクセスし、値を返す。


*xamDataGrid.DataSource = datas;
Gridへのデータソースを設定

*FlatDataSource flatData = new FlatDataSource(){ItemsSource = datas,ConnectionSettings = new FlatDataConnectionSettings(){ ItemsSource = datas}};
Pivotに対するデータソースを設定

*SettingDatas<SampleData>(datas);
サンプルデータを設定


*string reqUrl = $"https:
chart.googleapis.comchart?cht=qr&chl={urlEnc}&chs=300x300&chld=H|1";


*> d.ToString("ggyy年MM月dd日", cul)
ToStringの方が記述量は少ない


*public string FunctionHandler(ILambdaContext context)
デフォルトのテンプレートでは下の関数が書かれているが
public string FunctionHandler(string input, ILambdaContext context)
オーバロードしたこちらの関数を使ったほうが、色々幸せになる

*var weather = TokyoWeather();*var name = $"山本一成{weather}Ponanza";
OpenWeatherMapAPIから天気を取得して対応するEmojiを返す

*UpdateScreenName(name);*return $"{DateTime.Now}:{name}";
TwitterAPIを経由してnameに変更する

*}
お昼かどうかの可能判定

*}
日の出日の入り時刻は最大でも一日で一分程度しかズレないのでほぼ問題ない。


*using (var client = new HttpClient()){using (var uploadResponse = await client.GetAsync(pdfUrl)){URL先からストリームを取得var temp = await uploadResponse.Content.ReadAsStreamAsync();
HTTPクライアントを生成

*var temp = await uploadResponse.Content.ReadAsStreamAsync();
URL先からストリームを取得

*pdfDoc = await PdfDocument.LoadFromStreamAsync(temp.AsRandomAccessStream());
一時ファイルストリームをPDFドキュメントとしてパース

*using (var client = new HttpClient()){using (var uploadResponse = await client.GetAsync(pdfUrl)){URL先からストリームを取得var temp = await uploadResponse.Content.ReadAsStreamAsync();
HTTPクライアントを生成

*var temp = await uploadResponse.Content.ReadAsStreamAsync();
URL先からストリームを取得

*pdfDoc = await PdfDocument.LoadFromStreamAsync(temp.AsRandomAccessStream());
一時ファイルストリームをPDFドキュメントとしてパース


*private void Button_Click_1(object sender, RoutedEventArgs e)*{//メッセージボックスを出力するMessageBox.Show("お使いのパソコンは正常ではありません","DANGER!!",MessageBoxButton.OK, MessageBoxImage.Error);//メッセージボックスを閉じた後指定のアドレスにジャンプするSystem.Diagnostics.Process.Start("http://www.google.com");Close();}
ボタンクリックでイベント発生

*MessageBox.Show("お使いのパソコンは正常ではありません","DANGER!!",MessageBoxButton.OK, MessageBoxImage.Error);
メッセージボックスを出力する

*Close();
メッセージボックスを閉じた後指定のアドレスにジャンプする
System.Diagnostics.Process.Start("http:www.google.com");


*FilesResource.ListRequest listRequest = DriveService.service.Files.List();
リクエストパラメータの定義
service(DriveService)はユーザ認証部分なので割愛

*listRequest.Q = "mimeType = 'application/vnd.google-apps.presentation'";
Google Slidesのみ取得する

*IList<Google.Apis.Drive.v3.Data.File> files = listRequest.Execute().Files;
ファイル一覧の取得

*var id = files.First().Id;
例えば一番最初にとれたファイルをダウンロードする

*string saveTo = /*ファイル先*/;
保存するファイル先を指定する

*var request = DriveService.service.Files.Export(id, "application/pdf");
例えばGoogle SlidesをPDF形式でダウンロードする


*var prefix = "folder1
folder2samp";    ファイル名の中間一致

*GetList(containerName, prefix);
var prefix = "folder1/fol";           フォルダ名の中間一致でもOK


*void Start () {//Playerタグのつけ忘れに注意！player = GameObject.FindGameObjectWithTag("Player").transform;//見つからない場合は自身を設定if(player == null){player = transform;}}
Use this for initialization

*player = GameObject.FindGameObjectWithTag("Player").transform;*//見つからない場合は自身を設定
Playerタグのつけ忘れに注意！

*void Update () {float vertical = Input.GetAxis("Vertical");float horizontal = Input.GetAxis("Horizontal");//アナログスティックのグラつきを想定して±0.01以下をはじくif(Mathf.Abs(horizontal) + Mathf.Abs(vertical) > 0.1F){//カメラからみたプレイヤーの方向ベクトルVector3 camToPlayer = player.position - Camera.main.transform.position;// π/2 - atan2(x,y) == atan2(y,x)float inputAngle = Mathf.Atan2(horizontal,vertical) * Mathf.Rad2Deg;float cameraAngle = Mathf.Atan2(camToPlayer.x,camToPlayer.z) * Mathf.Rad2Deg;Quaternion targetRotation = Quaternion.Euler(0, inputAngle + cameraAngle, 0);//deltaTimeを用いることで常に一定の速度になるplayer.rotation = Quaternion.Slerp(player.rotation, targetRotation, Time.deltaTime * rotateSpeed);}}
Update is called once per frame

*Vector3 camToPlayer = player.position - Camera.main.transform.position;*// π/2 - atan2(x,y) == atan2(y,x)
カメラからみたプレイヤーの方向ベクトル

*player.rotation = Quaternion.Slerp(player.rotation, targetRotation, Time.deltaTime * rotateSpeed);
deltaTimeを用いることで常に一定の速度になる

*void Start () {//Playerタグのつけ忘れに注意！player = GameObject.FindGameObjectWithTag("Player").transform;//見つからない場合は自身を設定if(player == null){player = transform;}}
Use this for initialization

*player = GameObject.FindGameObjectWithTag("Player").transform;*//見つからない場合は自身を設定
Playerタグのつけ忘れに注意！

*void Update () {float vertical = Input.GetAxis("Vertical");float horizontal = Input.GetAxis("Horizontal");//アナログスティックのグラつきを想定して±0.01以下をはじくif(Mathf.Abs(horizontal) + Mathf.Abs(vertical) > 0.1F){//カメラからみたプレイヤーの方向ベクトルVector3 camToPlayer = player.position - Camera.main.transform.position;// π/2 - atan2(x,y) == atan2(y,x)float inputAngle = Mathf.Atan2(horizontal,vertical) * Mathf.Rad2Deg;float cameraAngle = Mathf.Atan2(camToPlayer.x,camToPlayer.z) * Mathf.Rad2Deg;Quaternion targetRotation = Quaternion.Euler(0, inputAngle + cameraAngle, 0);//deltaTimeを用いることで常に一定の速度になるplayer.rotation = Quaternion.Slerp(player.rotation, targetRotation, Time.deltaTime * rotateSpeed);}}
Update is called once per frame

*Vector3 camToPlayer = player.position - Camera.main.transform.position;*// π/2 - atan2(x,y) == atan2(y,x)
カメラからみたプレイヤーの方向ベクトル

*player.rotation = Quaternion.Slerp(player.rotation, targetRotation, Time.deltaTime * rotateSpeed);
deltaTimeを用いることで常に一定の速度になる


*Console.WriteLine(x => x * x);
-> 16


*sw.WriteLine("<gpx creator=\"GenericScript\" version=\"1.1\" xmlns=\"http:
www.topografix.comGPX11\" xmlns:xsi=\"http:www.w3.org2001XMLSchema-instance\" xsi:schemaLocation=\"http:www.topografix.comGPX11 http:www.topografix.comGPX11gpx.xsd\">");


*}
xはインスペクタ上のUV RectのXです、y,w,hも以下同文


*return EnumAttributeCache<TAttribute>.GetOrAdd(enumKey, _ => enumKey.GetAttributeCore<TAttribute>());
キャッシュに無かったら、リフレクションを用いて取得、キャッシュへの追加をして返す

*var fieldInfo = enumKey.GetType().GetField(enumKey.ToString());
リフレクションを用いて列挙体の型から情報を取得

*var attributes
指定した属性のリスト

*if ((attributes?.Count() ?? 0) <= 0)*return null;
属性がなかった場合、nullを返す

*return attributes.First();
同じ属性が複数含まれていても、最初のみ返す


*using UnityEngine;
Unityスクリプトリファレンス/CharacterController.Moveより
https:docs.unity3d.com/ja/current/ScriptReference/CharacterController.Move.html

*public class MyCharacterController : MonoBehaviour {public float speed = 6.0F;public float jumpSpeed = 8.0F;public float gravity = 20.0F;private Vector3 moveDirection = Vector3.zero;void Update() {CharacterController controller = GetComponent<CharacterController>();if (controller.isGrounded) {moveDirection = new Vector3(Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical"));moveDirection = transform.TransformDirection(moveDirection);moveDirection *= speed;if (Input.GetButton("Jump"))moveDirection.y = jumpSpeed;}moveDirection.y -= gravity * Time.deltaTime;controller.Move(moveDirection * Time.deltaTime);}}
クラス名はファイル名に一致させる


*temp = char.ToUpper(name[0]) + name.Substring(1).ToLower();
"Erasermotorphantom"

*temp = hoge.Substring(0, 5);
先頭から5文字抜き出す　abcde

*temp = hoge.Substring(5, 2);
5文字スキップし、6文字目から2文字取得　fg

*temp = hoge.Substring(22);
22文字スキップし、それ以降の文字列を取得する　wxyz

*temp = hoge.Replace("hoge", "piyo");
文字列中の"hoge"を"piyo"に置換 piyopiyoになる

*temp = hoge.Replace("piyo", "");
文字列中から"piyo"を削除 hogeになる

*string line = string.Join(",", elements);
Joinで一発。for文で最後の要素以外にコンマを追加とかしなくていい

*string[] splitStr = line.Split(',');
一行をコンマで区切って配列に入れる。


*Console.WriteLine(p.Show());
ParsonクラスのなかのShowメソッドが呼び出される。


*try*{using (FileStream fs = File.OpenRead(filePath)) { }return true;}
File.Exists()で存在するとなっても、実際は存在しないことがあるので再チェック


*DateTime dt = DateTime.Now;
現在時刻取得

*int resetTime = int.Parse(txtReset.Text);
入力したリセットまでの時間

*ChTimeList.Add(((CheckBox)(sender)), dt.AddSeconds(resetTime));
呼びだされたchboxとリセットの時刻を保持

*timer.Tick += new EventHandler(chReset);
1秒周期でメソッド実行

*private void chReset(object sender, EventArgs e)*{List<CheckBox> removeList = new List<CheckBox>();//Dictionaryの要素がなければ何もしないif (ChTimeList.Count == 0){return;}foreach (KeyValuePair<CheckBox, DateTime> a in ChTimeList){//要素が今の時間より過去ならリセットif (DateTime.Compare(a.Value, DateTime.Now) < 0){a.Key.Checked = false;removeList.Add(a.Key);}}//削除リストforeach (CheckBox ch in removeList){CHandTIME.Remove(ch);}timer.Stop();}
chリセット処理


*chrRewriter.Add(nameof(dmyAge), nameof(Character.YearsOld));
chrRewriter.Add("dmyAge", "YearsOld");

*var usrWhere = usrRewriter.Rewrite(p => dmyLevel < 10 && dmyAge > 16);
クエリのすり替え

*using (var ctx = new SampleContext()){ctx.Database.Log = Console.WriteLine;
実際にＤＢアクセス

*var dmyLevel = 0;
ダミー変数の定義

*using (var ctx = new SampleContext()){ctx.Database.Log = Console.WriteLine;
実際にＤＢアクセス

*var dmyLevel = 0;
ダミー変数の定義

*using (var ctx = new SampleContext()){ctx.Database.Log = Console.WriteLine;
実際にＤＢアクセス

*public IEnumerable<TEntity> GetEntities(params Expression<Func<TEntity, bool>>[] filters)*{IQueryable<TEntity> query = Context.Set<TEntity>();foreach (var f in filters){query = query.Where(this.Rewriter.Rewrite(f));}return query;}
コメントを参考にさせていただきました。さらにRewriter適用バージョンです。

*public IEnumerable<TEntity> GetPowerful()*{return this.GetEntities(p => DmyLevel >= 20 && DmyAge >= 20);}
つよーい人を取得(レベル20以上、二十歳以上)

*public IEnumerable<TEntity> GetGreaterOrEqual(int level, int age)*{return this.GetEntities(p => DmyLevel >= level && DmyAge >= age);}
level以上、かつage以上の一覧を取得します。

*var usrItems = usr.GetPowerful().ToList();
つぉーい人取得

*var grt = chr.GetGreaterOrEqual(10, 10).ToList();
引数付き、レベル、年齢共に10以上取得

*int DmyLevel = 0, DmyAge = 0;
インターフェースに拘るとダミー変数をどこに置くかが新たな課題。ローカル変数である必要は無さそう。

*PowerUp(usr, new UserAccessor());
Userをパワーアップ

*PowerUp(chr, new CharacterAccessor());
Characterをパワーアップ

*}
パワーアップの処理を反映・・・　しないでおく。
ctx.SaveChanges();

*var expression = Expression.Lambda<Func<User, bool>>(Expression.GreaterThanOrEqual(Expression.Property(Expression.Parameter(typeof(User), "p"),
p => p.Level >= 10


*Console.WriteLine(TodaysNikkei(DateTime.Today, 23456.7));
参照したメソッドを呼び出す

*Action hello = () => { Console.WriteLine("Hello, World!!"); };
例１

*Func<int, int> add = (n) => { return n + 1; };
例２

*Func<DateTime, double, string> TodaysNikkei = (dt, price) => { return dt.ToShortDateString() + " の日経平均株価終値は" + price.ToString() + "円です。"; };
例３

*double mathAve = CalcMathAverage(results, tr => tr.Math);
受験者全員の数学の平均点を求めたい

*double mathAve = CalcAverage(results, tr => tr.Math);
受験者全員の数学の平均点を求めたい

*double mathAve = ListUtil.CalcAverage(results, tr => tr.Math);
受験者全員の数学の平均点を求めたい

*double mathAve = results.CalcAverage(tr => tr.Math);
受験者全員の数学の平均点を求めたい

*double mathAve = results.CalcAverage(tr => tr.Math);
受験者全員の数学の平均点を求めたい


*[HttpGet("ArgumentNullException")]*public string GetArgumentNullException() {throw new ArgumentNullException("ArgumentNullException");}
GET api/values/ArgumentNullException

*[HttpGet("APIException")]*public string GetAPIException() {throw new APIException(HttpStatusCode.BadRequest, "Your exception message");}
GET api/values/APIException


*Console.WriteLine($"exist value = {sourceDict.GetOrAdd("A", 10000)}");
これのみDictionaryが変化しない

*var copiedDict = sourceDict.ToDictionary();
Dictionaryを別のDictionaryに変換（値コピー）

*copiedDict["A"] = 100;
元のDictionaryを変更しても、コピー先には反映されない

*var filterdDict = sourceDict.Where(x => x.Key == "A").ToDictionary();
LINQで加工したものもDictionaryにできる

*,,,
実行時エラー　複数のKeyに同じValueがあった場合、入れ替えるとKeyが重複してしまう
sourceDict["B"] = 10;
flipedDict = sourceDict.FlipKeyValue();

*var mergedDict = sourceDict.Merge(secondDict).ToDictionary();
2つのDictionaryを合流、Keyが重複していたら、先のDictionaryのValueが使用される


*_driver = new ChromeDriver(path);
NOTE: 起動にはそこそこ時間がかかる

*}
起動後は好きなようにChromeを操作できる
_driver.Navigate().GoToUrl("http:yahoo.co.jp");


*Coroutine _Coroutine;
Coroutineを中断するために変数として宣言しておく

*[SerializeField]float ScrollSpeed = 0.2f;
スクロールスピード

*public void ScrollLeft ()*{if (_Coroutine != null) {StopCoroutine (_Coroutine);}_Coroutine = StartCoroutine (TimeForScrollLeft ());}
LeftButtonに登録

*public void ScrollLeftest ()*{if (_Coroutine != null) {StopCoroutine (_Coroutine);}_Coroutine = StartCoroutine (TimeForScrollLeft (300f));}
LeftestButtonに登録

*IEnumerator TimeForScrollLeft (float SpeedRate = 1f){while (_Scrollbar.value > 0) {
左スクロールコルーチン

*public void ScrollRight ()*{if (_Coroutine != null) {StopCoroutine (_Coroutine);}_Coroutine = StartCoroutine (TimeForScrollRight ());}
Rightボタンに登録

*public void ScrollRightest ()*{if (_Coroutine != null) {StopCoroutine (_Coroutine);}_Coroutine = StartCoroutine (TimeForScrollRight (300f));}
RightestButtonに登録

*IEnumerator TimeForScrollRight (float SpeedRate = 1f){while (_Scrollbar.value < 1) {
右スクロールコルーチン

*public void StopScroll ()*{if (_Coroutine != null) {StopCoroutine (_Coroutine);}}
EventTriggerのPointerUpイベントに登録する処理


*var transportBinding = new HttpTransportBindingElement();
soap1.1を使いたい場合は、第二引数にBasicHttpBindingをnewすればOK

*public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)*{app.UseWhen(ctx => ctx.Request.Headers.ContainsKey("SOAPAction"), app2 =>{app2.UseSoapEndpoint<TestService>("/Service.svc", new BasicHttpBinding(), SoapSerializer.DataContractSerializer);});app.UseWhen(ctx => !ctx.Request.Headers.ContainsKey("SOAPAction"), app2 =>{var transportBinding = new HttpTransportBindingElement();var textEncodingBinding = new TextMessageEncodingBindingElement(MessageVersion.Soap12WSAddressing10, System.Text.Encoding.UTF8);app2.UseSoapEndpoint<TestService>("/Service.svc", new CustomBinding(transportBinding, textEncodingBinding), SoapSerializer.DataContractSerializer);});}
using System.ServiceModel.Channels;


*var json = Resources.Load<TextAsset>("sample").ToString();
今回は実際のレスポンスではなくJSONデータのロードで検証

*Debug.Log(data.detectedLanguage.language);
各Valueをログに吐き出す

*[Serializable]
配列をラップ

*[Serializable]
TranslateDataが新たにルートになる

*public Root[] root;
レスポンスのルートをここに入れる

*var rawJson = Resources.Load<TextAsset>("sample").ToString();*var json = "{" + $"\"root\":{rawJson}" + "}";
今回は実際のレスポンスではなくJSONデータのロードで検証

*Debug.Log(data.root[0].translations[0].text);
各Valueをログに吐き出す

*var rawJson = Resources.Load<TextAsset>("sample").ToString();
今回は実際のレスポンスではなくJSONデータのロードで検証

*Debug.Log(data.translations[0].text);
各Valueをログに吐き出す


*var expressions =(from object childNode in element.ChildNodeswhere childNode is XmlElementselect BuildExpression((XmlElement) childNode)).ToList();
子Elementを再帰的に探索してIExpressionを生成する


*draw = true;
衝突したらその先の放物線は表示しない

*GameObject arcObjectsParent = new GameObject("ArcObject");
親オブジェクトを作り、LineRendererを持つ子オブジェクトを作る

*lineRenderers[i].receiveShadows = false;
光源関連を使用しない

*lineRenderers[i].material = arcMaterial;
線の幅とマテリアル

*Vector3 startPosition = GetArcPositionAtTime(startTime);
Linecastする線分の始終点の座標

*RaycastHit hitInfo;
衝突判定

*float distance = Vector3.Distance(startPosition, endPosition);
衝突したColliderまでの距離から実際の衝突時間を算出

*shootVelocity = barrelObject.transform.up * speed;*// 弾の生成座標を更新
弾の初速度を更新

*instantiatePosition = barrelObject.transform.position;*// 発射
弾の生成座標を更新

*GameObject obj = Instantiate(bulletPrefab, instantiatePosition, Quaternion.identity);
弾を生成して飛ばす

*Destroy(obj, 5.0F);
5秒後に消える


*public static SimpleMessage Msg = new SimpleMessage();
ここと

*MessageList.Add(msg);
ここのようなthis.～からthis.を外します
public void AddMessage内の処理ですが、
これをpublic static bool jusin内へ移動します

*myIns.RePaint();
AddMessageメソッドを引数なしのRePaintメソッドに変更して、
jusinメソッドの呼び出しも修正します

*public void RePaint()*{// 手動での更新通知this.StateHasChanged();}
また、RePaintメソッドは以下のようにシンプルにします

*this.StateHasChanged();
手動での更新通知

*@using Microsoft.AspNetCore.Blazor.Browser.Services;
usingの追加（一回だけなので書かなくてもおｋです）

*var url = new BrowserUriHelper().GetAbsoluteUri();*url = $"{url}{(url.EndsWith("/") ? "index" : string.Empty)}";
OnInit内に記述


*if (IsPopssible()) {
この判定は、速度アップのため （不要な探索は行わないようにする）

*var q = from n in _baseLinejoin m in Diff(_baseLine) on n equals mselect m;
引き算をして得られた数が、baseLineにある数と同じならばダメ。


*Console.WriteLine(dt1 == dt2);
→ True

*Console.WriteLine(dt.ToString("yyyy/MM/dd HH:mm:ss"));
→ 2018/01/02 午後 12:23:45


*Console.WriteLine($"{num2:00000}");
"00123"


*using UnityEngine.UI;
UI弄るときに必須

*void Start()*{}
Start is called before the first frame update

*void Update()*{countTime += Time.deltaTime * speed;if (countTime > commandlist.Length){countTime = 0f;}if (lastTime != (int)countTime){foreach (var command in commandlist){command.color = new Color(1, 1, 1);}lastTime = (int)countTime;commandlist[(int)countTime].color = new Color(1, 0, 0);}if (Input.GetKeyDown(KeyCode.Space)){speed = 0;}}
Update is called once per frame

*void Start()*{}
Start is called before the first frame update

*void Update()*{countTime += Time.deltaTime * speed;if (countTime > commandlist.Length){countTime = 0f;}if (lastTime != (int)countTime){foreach (var command in commandlist){command.color = new Color(1, 1, 1);}lastTime = (int)countTime;commandlist[(int)countTime].color = new Color(1, 0, 0);}if (Input.GetKeyDown(KeyCode.Space)){speed = 0;//ここで(int)countTimeを他スクリプトに送信}}
Update is called once per frame

*}
ここで(int)countTimeを他スクリプトに送信

*void Start()*{}
Start is called before the first frame update

*void Update()*{//タイマーAcountTime += Time.deltaTime * speed;if (countTime > commandlist.Length){countTime = 0f;}//タイマーBfireTime += Time.deltaTime;if (lastTime != (int)countTime){fireTime = 0f;foreach (var command in commandlist){command.color = new Color(1, 1, 1);}lastTime = (int)countTime;commandlist[(int)countTime].color = new Color(1, 0, 0);}if (Input.GetKeyDown(KeyCode.Space)){isStop = true;lottery = Random.Range(990, 997) * 0.001f;}if (isStop){speed *= lottery;}if (fireTime >= 2.5 && justOnce){fireTime = 0;justOnce = false;//(int)countTimeを他スクリプトに送信}}
Update is called once per frame

*countTime += Time.deltaTime * speed;
タイマーA

*fireTime += Time.deltaTime;
タイマーB

*}
(int)countTimeを他スクリプトに送信


*ex. https:yarana-api.azurewebsites.net/api/kotos?userId=d59964bb713fd6f4f5ef6a7c7e029388string userId = req.GetQueryNameValuePairs().FirstOrDefault(q => string.Compare(q.Key, "userId", true) == 0)
Parse url query parameter

*string userId = req.GetQueryNameValuePairs().FirstOrDefault(q => string.Compare(q.Key, "userId", true) == 0)
ex. https:yarana-api.azurewebsites.net/api/kotos?userId=d59964bb713fd6f4f5ef6a7c7e029388

*string responseJSON = JsonConvert.SerializeObject(docs);*log.Info($"JSON to response: {responseJSON}");
Create JSON to return


*public float forceStrength;
打ち出す力の強さ


*EditorSceneManager.SaveOpenScenes();
現在編集中のシーンを保存する

*string[] openingScenePaths = Enumerable.Range(0, openingSceneCount).Select(i => EditorSceneManager.GetSceneAt(i))
処理後にシーン状態を戻すために現在のシーン一覧を記録しておく

*.Where(s => !string.IsNullOrEmpty(s.path))
保存されていないシーンは取り除く

*EditorSceneManager.NewScene(NewSceneSetup.EmptyScene, NewSceneMode.Single);
既に開かれているシーンを再度開こうとすると処理が止まるので、新規シーンのみにする

*EditorSceneManager.NewScene(NewSceneSetup.EmptyScene, NewSceneMode.Single);
編集前のシーン状態に戻す

*if (original != null)*PrefabUtility.DisconnectPrefabInstance(obj);
スクリプトによる変更を有効にするためにPrefabとのリンクを切る

*if (original != null)*PrefabUtility.ConnectGameObjectToPrefab(root, original);
Prefabとのリンクを再接続

*EditorSceneManager.MarkAllScenesDirty();
UnityにSceneの変更を通知する（通知しないと保存されない）

*EditorUtility.SetDirty(component);
UnityにComponentの変更を通知する（通知しないと保存されない）


*private bool disposedValue = false;
重複する呼び出しを検出するには

*}
TODO: マネージ状態を破棄します (マネージ オブジェクト)。

*disposedValue = true;
TODO: アンマネージ リソース (アンマネージ オブジェクト) を解放し、下のファイナライザーをオーバーライドします。
TODO: 大きなフィールドを null に設定します。

*// ~MyDisposableClass() {//   // このコードを変更しないでください。クリーンアップ コードを上の Dispose(bool disposing) に記述します。//   Dispose(false);// }
TODO: 上の Dispose(bool disposing) にアンマネージ リソースを解放するコードが含まれる場合にのみ、ファイナライザーをオーバーライドします。

*public void Dispose()
このコードを変更しないでください。クリーンアップ コードを上の Dispose(bool disposing) に記述します。
Dispose(false);
}
このコードは、破棄可能なパターンを正しく実装できるように追加されました。

*Dispose(true);
このコードを変更しないでください。クリーンアップ コードを上の Dispose(bool disposing) に記述します。

*}
TODO: 上のファイナライザーがオーバーライドされる場合は、次の行のコメントを解除してください。
GC.SuppressFinalize(this);


*var visual = new DrawingVisual();
描画用の Visual を用意


*const string webHookUrl = "https:
hooks.slack.comservicesXXX...";


*Console.WriteLine($"{p1.LastName}{p1.FirstName}");
$は{}内の指示語展開のスイッチ（C#6で搭載）


*ShowLoader(2. masterデータを読むLoadMasterData((res) =>
1. 読み込み中の表示を始める

*LoadMasterData((res) =>*{// 3. masterデータを元に3Dモデルを読むLoad3DModel(res, () =>{// 4. userデータとマップデータを同時に読むLoadUserDataAndMapData(() =>{// 5. 読み込み中の表示を終了するHideLoader(onEnd);});});});
2. masterデータを読む

*Load3DModel(res, () =>*{// 4. userデータとマップデータを同時に読むLoadUserDataAndMapData(() =>{// 5. 読み込み中の表示を終了するHideLoader(onEnd);});});
3. masterデータを元に3Dモデルを読む

*LoadUserDataAndMapData(() =>*{// 5. 読み込み中の表示を終了するHideLoader(onEnd);});
4. userデータとマップデータを同時に読む

*HideLoader(onEnd);
5. 読み込み中の表示を終了する

*}
... ユーザーデータとマップデータを同時に読む処理。両方終わったらcallback実行

*await ShowLoaderAsync();
1. 読み込み中の表示を始める

*int res = await LoadMasterDataAsync();
2. masterデータを読む

*await Load3DModelAsync(res);
3. masterデータを元に3Dモデルを読む

*await Task.WhenAll(new Task[]{LoadUserDataAsync(), LoadMapDataAsync()});
4. userデータとマップデータを同時に読む

*await HideLoaderAsync();
5. 読み込み中の表示を終了する

*UnityEngine.Debug.Log("Coroutine after: " + Time.frameCount);
1フレーム経過している

*Func<IEnumerator> callback = () =>*{yield return null;};
NG. deleagte内ではyield return出来ない

*public static TaskAwaiter<bool> GetAwaiter(this Tweener tweener)*{var tcs = new TaskCompletionSource<bool>();TweenCallback callback = null;callback = () =>{tweener.onComplete -= callback;tcs.SetResult(true);};tweener.onComplete += callback;return tcs.Task.GetAwaiter();}
TweenerをAwaitableにする

*public static TaskAwaiter<bool> GetAwaiter(this Sequence seq)*{var tcs = new TaskCompletionSource<bool>();TweenCallback callback = null;callback = () =>{seq.onComplete -= callback;tcs.SetResult(true);};seq.onComplete += callback;return tcs.Task.GetAwaiter();}
SequenceをAwaitableにする

*private async Task ExceptionTest()*{Image img = null;img.gameObject.SetActive(true);}
log出ない例

*private async void ExceptionTest()*{Image img = null;img.gameObject.SetActive(true);}
log出る


*.ObserveOn(this.Dispatcher)
Textboxにアクセスするので、UIスレッド上で購読

*x => this.textBox.Text += x,
OnNextは流れてきた文字をそのままTextboxに書き足す

*() => textBox.Text += Properties.Resources.Take);
CompleteしたらリソースからAAを取得してTextboxに書き足す

*.Interval(TimeSpan.FromMilliseconds(10))
10msecごとに

*.Select(_ => pops[random.Next(maxCount)]);
ランダムに「ポ」「プ」「テ」「ピピック」のどれか

*return Observable.Repeat("", maxCount)
※テスト用　最初がいきなり「ポプテピピック」になる
.Select(i => pops[i % maxCount]);
バッファを空白で埋めておく (["","","","",""])

*.Buffer(maxCount + 1, 1)
最後の「ピピック」をOnNextに流すために1つ余分にBufferをもつ

*.TakeWhile(x => !x.Take(maxCount).SequenceEqual(pops))
Bufferの前が「ポプテピピック」に一致する状態(["ポ","プ","テ","ピピック",*])になるまで続行

*.Select(x => x.Last());
Bufferの最後をOnNextに流す  ([*,*,*,*,○]　の　○)


*await new HttpClient().GetStringAsync(@"https:
docs.microsoft.comja-jp");


*public ThisAddIn(global::Microsoft.Office.Tools.Outlook.Factory factory, global::System.IServiceProvider serviceProvider) :*base(factory, serviceProvider, "AddIn", "ThisAddIn") {Globals.Factory = factory;}
(中略)

*internal static global::Microsoft.Office.Tools.Outlook.Factory Factory {get {return _factory;}set {if ((_factory == null)) {_factory = value;}else {throw new System.NotSupportedException();}}}
(中略)

*,,,
(中略)

*Outlook.ReportItem copiedReport = item.Copy();
ReportItemのままだと送信先が取れないため、
いったんIPM.Noteとして別名保存⇒ロードしてからRecipientsを取得する

*var newReportItem = Globals.ThisAddIn.Application.Session.GetItemFromID(copiedReport.EntryID);
IPM.Noteとして保存してからロードするとMailItemとして扱えるようになる

*List<Outlook.Recipient> recipientsList = new List<Outlook.Recipient>();
受信者の情報をリストに入れる

*else*{continue;}
選択されていないリソースの場合

*else*{recipientsList.Add(recipients[i]);}
送信者、To、Ccの場合

*Assembly asm = Assembly.LoadFrom(@".\ORCAUnitTest\bin\Debug\OutlookRecipientConfirmationAddin.dll");
(中略)
アセンブリを読み込み、モジュールを取得

*Type type = mod.GetType("OutlookRecipientConfirmationAddin.Utility");
テスト対象のクラス（Utility）のタイプを取得

*object obj = Activator.CreateInstance(type);
インスタンスを生成し、メソッドにアクセスできるようにする

*}
(中略)

*TestFactory testFactory = new TestFactory();
(中略)
ThisAddInクラスのインスタンスを生成

*Type typeThisAddIn = testAddIn.GetType();
ThisAddInのApplicaitionフィールドを取得し、モックの値（testApp）をセット

*testNs = Substitute.For<NameSpace>();
モックのApplication（testApp）のSessionに値(tesNs)をセットする

*Type typeGlobal = mod.GetType("OutlookRecipientConfirmationAddin.Globals");
GlobalsのThisAddinプロパティに、モックなどを使って作った値(testAddIn)をセットする

*testNs = Substitute.For<NameSpace>();
モックのApplication（testApp）のSessionに値(tesNS)をセットする

*}
(中略)

*dynamic Copy();
(中略)

*}
(中略)

*public abstract void Close(OlInspectorClose SaveMode);
(中略)

*,,,
(中略)

*string[] testRecNames = { "testemailaddress1@example.com", "testemailaddress2@example.com" };
モックでつかうデータを用意

*List<Recipient> expectedRecList = new List<Recipient>();
期待結果を入れるリスト

*MyTestNs myTestNs = Substitute.For<MyTestNs>();
モックのReturn値と、期待結果のリストの値を設定

*var objArray = new object[] { testReport, Utility.OutlookItemType.Mail, false };
テストするメソッドにアクセスし、実際の結果を取得

*List<Recipient> actualRecList = new List<Recipient>();
テスト対象メソッドの返り値をList<Recipient>型にする

*Assert.AreEqual(actualRecList.Count, expectedRecList.Count);
actualとexpectedのリストを比較

*Assert.That(objArray[1], Is.EqualTo(Utility.OutlookItemType.Report));
ref引数のtypeが正しいことを確認


*public class MainActivity : Activity*{protected override void OnCreate(Bundle savedInstanceState){base.OnCreate(savedInstanceState);SetContentView(Resource.Layout.Main);var button = FindViewById<Button>(Resource.Id.myButton);var sounds = new int[]{Resource.Raw.trumpet1,Resource.Raw.trumpet2};button.Click += async (sender, e) =>{foreach (var id in sounds){await PlayAsync(id);}};}// 再生が終了したら true を、エラーだったら false を返すprivate Task<bool> PlayAsync(int rscId){var compSource = new TaskCompletionSource<bool>();var mp = MediaPlayer.Create(this, rscId);mp.Completion += (_, __) =>{compSource.SetResult(true);};mp.Error += (_, __) =>{compSource.SetResult(false);};mp.Start();return compSource.Task;}}
using System.Threading.Tasks;

*private Task<bool> PlayAsync(int rscId)*{var compSource = new TaskCompletionSource<bool>();var mp = MediaPlayer.Create(this, rscId);mp.Completion += (_, __) =>{compSource.SetResult(true);};mp.Error += (_, __) =>{compSource.SetResult(false);};mp.Start();return compSource.Task;}
再生が終了したら true を、エラーだったら false を返す


*public string Name { get; set; }
名前

*public int Age { get; set; }
年齢

*people.Sort((a, b) => a.Age - b.Age);
年齢昇順

*people.Sort((a, b) => b.Age - a.Age);
年齢降順

*people.Sort((a, b) => string.Compare(a.Name, b.Name));
名前昇順


*context.YYYYYs.Add(
YYYYY Entity の Statesが
Unchanged状態→Added状態へ。


*await context.OpenAsync("https:
www.google.co.jp");


*Container.Bind<Foo>().AsTransient();
それを求めるすべてのクラスに対してFooの新しいインスタンスを作成する

*Container.Bind<IFoo>().To<Foo>().AsTransient();
IFooを要求するクラスごとにFooの新しいインスタンスを作成する

*Container.Bind(typeof(IFoo)).To(typeof(Foo)).AsTransient();
非ジェネリックバージョン

*Container.Bind<Foo>().AsSingle();
Fooの1つの最終的なインスタンスを作成し、それを求めるすべてのクラスに対して再利用します

*Container.Bind<IFoo>().To<Foo>().AsSingle();
Fooの1つの最終的なインスタンスを作成し、IFooを要求するすべてのクラスに対してそのインスタンスを再利用します

*Container.Bind<Foo>().AsSingle();
この例では、Fooの同じインスタンスが3つのすべてのケースで使用されます

*Container.Bind(typeof(Foo)).AsSingle();
非ジェネリックバージョン

*Container.Bind(typeof(Foo), typeof(IFoo)).To(typeof(Foo)).AsSingle();
または、1つのバインドステートメント

*Container.BindInterfacesTo<Foo>().AsSingle();
Fooが実装するすべてのインターフェイスを、Foo型の新しいシングルトンにバインドする

*Container.Bind<ITickable>().To<Foo>().AsSingle();
たとえば、FooがITickableとIInitializableを実装している場合、上記の行は次のようになります。

*Container.Bind<Foo>().FromInstance(new Foo());
Fooが使用されているあらゆる場所で、指定されたインスタンスを使用する

*Container.BindInstance(new Foo());
これは単に上記バインディングのショートカットです
これは、タイプ引数がパラメータから導き出されることができるので、少し好きかもしれません

*Container.Bind<Foo>().FromInstance(new Foo());
複数のバインディングを許可し、複数のバインディングで同じインスタンスをAsSingleで再利用することはできないため、
FromInstanceはAsSingleとは異なることに注意してください。
たとえば、次のようにしてList <Fooのコンストラクタパラメータ >（単一のFooを要求するパラメータの例外をスローする）

*Container.Bind<int>().FromInstance(10);
intが要求されるたびに10を使用するあなたはこれをやりたいとは思っていません。
プリミティブ値にはほとんどの場合、When条件を使うべきです（下記の条件節を参照）

*Container.BindInstance(10);
これらは上記と同じです
これは型引数がパラメータから導き出されるためです
また、条件を使用して値の使用範囲を制限するように注意してください
上記のようにSettingsオブジェクトを使用することを検討してください

*Container.Bind<Foo>().FromMethod(GetFoo);
要求されたときに、指定されたメソッドを使用してFooのインスタンスを作成するもっと複雑な構築シナリオでは、
代わりにファクトリを使用することを検討してください

*Container.Bind<IFoo>().FromMethod(GetFoo);
IFooのいくつかの異なる実装のうちの1つをランダムに返します
Foo1がそのメンバを注入するように、ここではインスタンス化をnewの代わりに使用します

*Container.Bind<Foo>().FromMethod((ctx) => new Foo());
ラムダ構文の使用

*Container.Bind<Foo>().FromMethod((ctx) => ctx.Container.Instantiate<Foo>());
これはAsTransientと同等です

*Container.Bind<Foo>().AsSingle();
別の依存関係のプロパティにバインドする
これは、クラス間の結合を減らすのに役立ちます

*Container.Bind<string>().FromResolveGetter<Foo>(foo => foo.GetTitle());
値を使用する別の例

*Container.Bind<Foo>().FromNewComponentOnNewGameObject().AsSingle();
シーンのルートに新しいゲームオブジェクトを作成し、そこにFoo MonoBehaviourを追加し、それに "Foo"という名前を付けます。

*Container.Bind<Foo>().FromNewComponentOnNewGameObject().WithGameObjectName("Foo1").AsSingle();
WithGameObjectNameを使用して使用するゲームオブジェクト名を指定することもできます

*Container.Bind<IFoo>().To<Foo>().FromNewComponentOnNewGameObject().AsSingle();
インターフェイスにバインドする

*GameObject fooPrefab;
与えられたプレハブを使ってシーンのルートに新しいゲームオブジェクトを作成する
ここではFooはMonoBehaviourであり、Fooは以前にプレハブに追加されているものと仮定しています
zenjectが与えられたプレハブから新しいGameObjectを作成すると、
プレファブで 'Foo'型のコンポーネントを検索し、それを返します

*Container.Bind<IFoo>().To<Foo>().FromComponentInNewPrefab(fooPrefab).AsSingle();
代わりにインターフェイスにバインドする

*GameObject prefab;
この例では、AsSingleを使用していますが、異なるコンポーネントを使用しています。
ここでは、特定のプレハブのインスタンスが1つだけ作成されることに注意してください。
AsSingleはプレハブ自体に適用され、プレハブから返されるタイプには適用されません。
これが機能するには、Foo MonoBehaviourとBar MonoBehaviourの両方がプレハブのどこかに存在する必要があります

*GameObject fooPrefab = null;
Fooのインスタンスが毎回 'fooPrefab'の新しいコピーをインスタンス化する
コンストラクタパラメータ、注入されたフィールドなどによって要求されます。

*Container.Bind<Foo>().FromComponentInNewPrefab(fooPrefab).AsTransient();
ここでも、AsTransientがデフォルトであるため、これは同等です

*Container.Bind<IFoo>().To<Foo>().FromComponentInNewPrefab(fooPrefab);
代わりにインターフェイスにバインドする

*Container.Bind<string>().WithId("PlayerName").FromInstance("name of the player");
グローバルにアクセス可能な文字列を 'PlayerName'という名前でバインドすることをお勧めします。
しかし、より良い選択肢は、Settingsオブジェクトを作成してバインドすることです

*Container.BindInstance("name of the player").WithId("PlayerName");
これは上記の行に相当し、もう少し読みやすくなります

*Container.Bind<string>().WithId("FooA").FromInstance("foo");
IDを使用して、同じタイプの複数のインスタンスをバインドすることもできます。

*public class Norf*{[Inject(Id = "FooA")]string _foo;}
次に、これらの依存関係を注入するときには、同じIDを使用する必要があります。

*Container.Bind<Foo>().AsCached();
この例では、Fooの3つのインスタンスをバインドします.1つはIDなし

*public class Norf
[Inject]フィールドでIDが指定されていない場合は、最初のインスタンスが使用されます.
IDなしのBindingsはデフォルトとして使用でき、同じタイプの特定のバージョンのIDを指定できます

*public class Qux
Qux._fooはNorf._fooと同じインスタンスになります。
これは、AsTransではなくAsCachedを使用しているためです。
AsSingleを使用しないことに注意してください。
この場合、Qux._foo2も同じインスタンスを使用するためです

*Container.Bind<Foo>().AsSingle().WhenInjectedInto<Bar>();
これにより、BarはFooに依存することができます
Fooを他のクラスのコンストラクタに追加すると、それを見つけることができません

*Container.Bind<IFoo>().To<Foo1>().AsSingle().WhenInjectedInto<Bar>();
IFooのさまざまな実装を使用する
クラスが注入されている

*Container.Bind<IFoo>().To<Foo1>().AsSingle();
「Foo1」をデフォルトの実装として使用する場合は、
クラスQux、その場合はFoo2を使用する

*Container.Bind<Foo>().AsSingle().WhenInjectedInto(typeof(Bar), typeof(Qux), typeof(Baz));
Fooに依存するいくつかの選択されたクラスでのみ許可

*Container.BindInstance("my game").WithId("Title").WhenInjectedInto<Gui>();
識別子 "Title"を持つGuiクラスに注入された文字列の "my game"を提供する

*Container.BindInstance(5).WhenInjectedInto<Gui>();
Guiクラスに注入されたすべてのintの5を供給する

*Container.BindInstance(5.0f).When(ctx =>
Guiの中のパラメータやフィールドに注入されたすべてのintを 'width'という名前で入力します。
フィールドの名前は簡単に変更でき、バインディングを破ることができますが、ここでは例として示しています。

*Container.Bind<IFoo>().To<Foo>().AsTransient().When(
'Bar'クラスの構築の一部として作成されたすべてのクラスに対して新しい 'Foo'を作成する
したがって、BarがQux型のコンストラクタパラメータを持ち、QuxがIFoo型のコンストラクタパラメータを持っている場合、
そのケースに対して新しいFooが作成されます

*Container.BindInstance(foo1).When(c => c.ParentContexts.Where(x => x.MemberType == typeof(Bar) && x.Identifier == "Bar1").Any());*Container.BindInstance(foo2).When(c => c.ParentContexts.Where(x => x.MemberType == typeof(Bar) && x.Identifier == "Bar2").Any());
ここでは、注入コンテキストの 'ParentContexts'プロパティを使用して、複数の対応する識別子を同期させます

*GameObject fooPrefab;
これにより、
Container.Resolve<Bar>("Bar1").Foo == foo1
Container.Resolve<Bar>("Bar2").Foo == foo2
これにより、IBar、IFoo、およびFooがすべてFooの同じインスタンスにバインドされます。
これは、指定されたプレハブのどこかに存在すると仮定されています

*GameObject fooPrefab = null;
これにより、上記と同じ動作になります

*Container.Bind<IFoo>().To<Foo>().AsSingle();
Rebindは、以前のバインディングを上書きするために使用できます
これは、IFooがBarのみにバインドされることになります
Fooへのバインディングは削除されます
通常、バインディングが発生する順序はまったく重要ではありませんが、
Rebindは順序依存性を作成して慎重に使用します

*FooInstaller.Install(Container);
すぐにFooInstallerでInstallBindings（）を呼び出します。

*Container.BindInstance("foo").WhenInjectedInto<FooInstaller>();
FooInstallerを呼び出す前に、そのプロパティを設定してください

*// この行は上記の2行に相当します*FooInstaller.Install(Container, new object[] { "foo" });
引数を直接渡すこともできます

*FooInstaller.Install(Container, new object[] { "foo" });
この行は上記の2行に相当します

*FooInstaller.Install(Container);
FooInstallerを呼び出した後、そのバインディングの1つをオーバーライドします
FooInstallerがIFooを何かにBindすると仮定します

*var foo = new Foo();
これは、[Inject]とマークされた任意のパラメータを記入し、任意の[Inject]メソッド

*Container.Resolve<IFoo>();
以前に追加されたバインディングを使用して、IFooのインスタンスを返します。
内部的には、IFoo型のコンストラクタパラメータを入力するとトリガされるものです
注：一致が見つからない場合は例外がスローされます

*Container.TryResolve<IFoo>();
上記と同じですが、指定された型が見つからない場合はnullを返します。

*Container.BindInstance(new Foo());
Foo型の2つのインスタンスのリストを返す

*Container.Instantiate<Foo>();
Fooの新しいインスタンスを作成し、そのメンバーのいずれかに注入する
Fooが持つ可能性のある任意のコンストラクタパラメータを入力します

*GameObject go = Container.InstantiatePrefab(prefab);
新しいプレハブをインスタンス化し、プレハブに注入可能なものを埋め込む

*Foo foo2 = Container.InstantiatePrefabForComponent<Foo>(prefab);
新しいプレハブをインスタンス化し、特定のモノオブジェクトを返す

*Foo foo3 = Container.InstantiateComponent<Foo>(gameObject);
既存のゲームオブジェクトに新しいコンポーネントを追加する


*namespace INotifyPropertyChanged_2172d2073f184d9db6d12b49f79a37c0 {
このコードはツールによって生成されました。
ランタイム バージョン:4.0.30319.42000

このファイルへの変更は、以下の状況下で不正な動作の原因になったり、
コードが再生成されるときに損失したりします。
</auto-generated>
------------------------------------------------------------------------------


*var denominator = 1;
分母 もっと大きな数から始められるはずだが...

*var numerator = denominator * x;*var frac = $"{k}{numerator}{denominator}";
分子  K + N / D = 100 となる N を求めている --> N = D * (100 - K)

*break;*if (IsKomachi(frac)) {yield return new Answer {WholeNumber = k,Numerator = numerator,Denominator = denominator};}
これ以上やっても解はない。小町にはならない

*private bool IsKomachi(string s) {return s.OrderBy(c => c).SequenceEqual("123456789");}
小町数か、（引数は数値を文字列に変換したもの）


*var dateNode = doc.DocumentNode.SelectNodes("
div[@class='top-matter']p[2]time");


*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame

*winnerLabelObject.SetActive(true);
オブジェクトをアクティブにする

*int sceneIndex = SceneManager.GetActiveScene().buildIndex;
現在のシーン番号を取得

*SceneManager.LoadScene(sceneIndex);
現在のシーンを再読込する


*return Clients.All.SendAsync("AddMessage", msg);
プレビュー１の場合

*}
α2の場合
return Clients.All.InvokeAsync("AddMessage", msg);

*services.AddSignalR();
この１行を追加します

*app.UseSignalR(routes =>{使用するClassを登録しているようですroutes.MapHub<ChatHub>("/chathub");
UseMvcの後でもいいかどうか不明ですが

*routes.MapHub<ChatHub>("/chathub");
使用するClassを登録しているようです

*protected void 発言()*{RegisteredFunction.Invoke<bool>("迷信", Msg);}
ここはC#内で完結するため日本語メソッド名が利用できました

*RegisteredFunction.Invoke<bool>("log", "「AddMessage」よばれたー");
JavaScriptでログ出力

*Console.Out.WriteLine("「AddMessage」よばれたー");
C#でのログ出力を行うと
WASM: 「AddMessage」よばれたー
と出力されます

*this.StateHasChanged();
手動での更新通知


*private readonly int MAX_TIME = 3599;
限界は59分59秒

*mGame = GameController.Instance;
ゲーム全体の初期化

*mGame.GameLevel = GameController.LEVEL_EASY;
初期レベルはイージー

*追加        mTimer = new GameTimer();
タイマーの生成

*private void StartGame()
ゲームの開始と終了
---------------------------------------------------------------------------------

*private GameTimer mTimer;
時間管理
---------------------------------------------------------------------------------


*追加
フラグの解除

*int xLength;
ゲームレベルによってサイズと爆弾の数を決定

*InstantiateBlocks(xLength, yLength);
ブロックを並べる

*SetBombs(bombCount);
ブロックに爆弾を設置

*float cameraX = xLength * BLOCK_SIZE / 2.0f;
カメラを中心に設定


*private enum STATE
状態と更新
---------------------------------------------------------------------------------

*public static string TAG_BLOCK = "Block";
タグ

*BlockModel target = go.GetComponent<BlockModel>();
対象が爆弾ブロックか判定

*if (target.IsCheck) return;*// チェックしていないなら開いてゲームオーバー
チェック済ならば何もしない

*}else
チェックしていないなら開いてゲームオーバー
GameOver(target);

*OpenBlock(target);
爆弾でないならば一連の開く処理

*}
ゲームクリアの判定
JudgeGameClear();

*Action<int, int> action = (posX, posY) =>*{BlockModel model = GetBlock(posX, posY);if (model != null) result.Add(model);};
定義済みデリゲート

*action(x - 1, y - 1);
各座標をチェックしてリストに追加していく

*if (target.IsOpen || target.IsCheck) return;*// 対象ブロックの隣接1マスにあるブロックを取得
対象がすでに開かれている or チェック済の場合は何もしない

*List<BlockModel> aroundBlocks = GetAroundBlocks(target.X, target.Y);
対象ブロックの隣接1マスにあるブロックを取得

*int bombCount = aroundBlocks.Count(block => block.HasBomb);
周囲の爆弾の数を取得

*target.Open(bombCount);
対象ブロックを開く


*追加
カメラを中心に設定


*public bool IsOpen { get; private set; }
フラグ
---------------------------------------------------------------------------------
開かれたブロックの場合はtrue

*public void Open()
アクション
---------------------------------------------------------------------------------

*private static Vector2[] UV_CHECK =
UVマップの定義
---------------------------------------------------------------------------------

*private void Awake()
初期化
---------------------------------------------------------------------------------

*ChangeUvToCheck();
チェックマークを表示

*public void ChangeUvToCheck()
UVマップの切り替え
---------------------------------------------------------------------------------

*private void Awake()
初期化
---------------------------------------------------------------------------------

*ChangeUvToBlank();
最初は何も表示しないテクスチャを設定

*private static Vector2[] UV_ONE =
UVマップの切り替え
---------------------------------------------------------------------------------

*//---------------------------------------------------------------------------------*public int X { get; private set; }
ポジション

*public int X { get; private set; }
---------------------------------------------------------------------------------

*public bool HasBomb { get; set; }
フラグ
---------------------------------------------------------------------------------
爆弾ブロックの場合はtrue

*public bool IsOpen { get; private set; }
開かれたブロックの場合はtrue

*public bool IsCheck { get; private set; }
チェック済ブロックの場合はtrue

*public void Open(int aroundBombs)
アクション
---------------------------------------------------------------------------------


*private static readonly GameController mInstance = new GameController();
初期化タイミングでインスタンスを生成

*private GameController() { }
コンストラクタをprivateにすることによって他クラスからnewできないようにする

*public static GameController Instance*{get{return mInstance;}}
他クラスからこのインスタンスを参照する

*Application.targetFrameRate = 30;
フレームレートの設定

*private enum STATE
状態と更新
---------------------------------------------------------------------------------


*Debug.Log($"Interval time:{start_time - previous_time}");
10msではなく、1frame待つことになる。

*yield return new WaitForSeconds(0.01f);
10msではなく、1frame待つことになる。

*await Task.Delay(10);
1frame + α待つことになる。

*_nextTickTime = (float)_tempo.SecondsPerTick();
1Tickあたりの時間を代入する。

*.Skip(_tempo.TickPerTuplet * 8)
始めの1小節は不安定なので発行しない。

*_rhythmObserver.FourBars.OnNext(new TimingForFourBars(_Timing));
4小節毎に発行する。

*_rhythmObserver.Bar.OnNext(new TimingForBar(_Timing));
1小節毎に発行する。

*_rhythmObserver.Beat.OnNext(new TimingForBeat(_Timing));
1beat毎に発行する。

*_rhythmObserver.Tuplet.OnNext(new TimingForTuplet(_Timing));
連符毎に発行する。

*_rhythmObserver.Tick.OnNext(new TimingForTick(_Timing));
Tick毎に発行する。

*_nextTickTime += (float)_tempo.SecondsPerTick();
1Tickあたりの時間を追加する。

*_rhythmReceiver.Bar
1小節毎に購読する。


*private static void PrintResult(int denominator, IEnumerable<int> numerators) {StringBuilder sb = new StringBuilder();int i = 1;foreach (var n in numerators) {int den2 = n * denominator;sb.AppendFormat("{0,2} : {1} / {2} = 1 / {3}\n", i++, n, den2, denominator);}Console.WriteLine(sb.ToString());}
n == denominatorの時の解をプリントする

*public static IEnumerable<int> Solve(int denominator) {
denominator 分母 2-9 まで
1/denominatorとなる小町数を求める
単位分数の分母が 2-9までの場合は、小町数になる分数の分子と分母は、４桁/5桁になる


*Monitor.Enter(lockObject);
テストが同時に走らないためにロックを使う

*Monitor.Exit(lockObject);
テストが同時に走らないためのロック解放


*Name = "Query";
クエリあることを設定する

*Field<CharacterInterface>("hero", resolve: context => data.GetDroidByIdAsync("3"));
heroというクエリを定義　　　　　　　　　　　　　　　　　　↓LINQが書ける


*UIApplication.SharedApplication.SetStatusBarStyle(UIStatusBarStyle.LightContent, false);
← これ


*public static readonly DependencyProperty NameProperty =DependencyProperty.Register("Name", typeof(string), typeof(ownerclass), new PropertyMetadata(""));
Using a DependencyProperty as the backing store for Name.  This enables animation, styling, binding, etc...

*public static readonly DependencyProperty NameProperty =DependencyProperty.RegisterAttached("Name", typeof(string), typeof(ownerclass), new PropertyMetadata(""));
Using a DependencyProperty as the backing store for Name.  This enables animation, styling, binding, etc...

*get => (string)GetValue(NameProperty);
依存関係プロパティ

*public static string GetName(DependencyObject obj) => (string)obj.GetValue(NameProperty);
添付プロパティ


*float acos =Acos(cos);
ここも必要に応じて変更する

*return angle;
度に変換すること


*sieve[1] = 0;
0 : 素数ではない

*// primesB 候補となる素数 （どんどん絞られてゆく）*private IEnumerable<int[]> Solve(IEnumerable<int> primesA, IEnumerable<int> primesB) {// 素因数分解した結果を文字列にし、小町数かどうかを調べるvar s = ToString(primesA);if (IsKomachi(s)) {yield return primesA.ToArray();} else {// 小町の可能性があるならば、PrimesBから一つ取り出し、// その因数を解PrimesAに加え、再帰処理してゆく。if (IsValid(s)) {foreach (var n in primesB) {var ans = Solve(primesA.Concat(new int[] { n }), primesB.SkipWhile(a => a <= n));foreach (var primes in ans)yield return primes;}}}}
primesA 素因数分解した途中結果 (必ず小さい因数から順に並ぶ）

*private IEnumerable<int[]> Solve(IEnumerable<int> primesA, IEnumerable<int> primesB) {// 素因数分解した結果を文字列にし、小町数かどうかを調べるvar s = ToString(primesA);if (IsKomachi(s)) {yield return primesA.ToArray();} else {// 小町の可能性があるならば、PrimesBから一つ取り出し、// その因数を解PrimesAに加え、再帰処理してゆく。if (IsValid(s)) {foreach (var n in primesB) {var ans = Solve(primesA.Concat(new int[] { n }), primesB.SkipWhile(a => a <= n));foreach (var primes in ans)yield return primes;}}}}
primesB 候補となる素数 （どんどん絞られてゆく）

*var s = ToString(primesA);*if (IsKomachi(s)) {yield return primesA.ToArray();} else {// 小町の可能性があるならば、PrimesBから一つ取り出し、// その因数を解PrimesAに加え、再帰処理してゆく。if (IsValid(s)) {foreach (var n in primesB) {var ans = Solve(primesA.Concat(new int[] { n }), primesB.SkipWhile(a => a <= n));foreach (var primes in ans)yield return primes;}}}
素因数分解した結果を文字列にし、小町数かどうかを調べる

*// その因数を解PrimesAに加え、再帰処理してゆく。*if (IsValid(s)) {foreach (var n in primesB) {var ans = Solve(primesA.Concat(new int[] { n }), primesB.SkipWhile(a => a <= n));foreach (var primes in ans)yield return primes;}}
小町の可能性があるならば、PrimesBから一つ取り出し、

*private bool IsValid(string s) {var length = s.Length;// 重複していれば、Distinctした個数とは一致しないreturn s.Distinct().Count() == length;}
適合しているか （同じ数字があるとダメ）

*return s.Distinct().Count() == length;
重複していれば、Distinctした個数とは一致しない

*private string ToString(IEnumerable<int> nums) {var s = "";foreach (var n in nums) {s += n.ToString();}return s;}
int配列を文字列に変換

*private bool IsKomachi(string s) {if (s.Length != 9)return false;return s.OrderBy(c => c).SequenceEqual("123456789");}
小町数か、（引数は数値を文字列に変換したもの）

*var ans = Solve(primesA.Concat(new int[] { n }), primesB.Where(a => a != n));
解答primesAにnを追加。候補となる素数リストprimeBからnを除外


*Console.WriteLine(string.Format("{0} is {1}? {2}", nonGenericInterfaceClass, nonGenericInterfaceType, nonGenericInterfaceClass is INonGenericInterface));
Interface を実装したクラスは当然 is で判定可能

*foreach (Type interfaceType in subClassOfNonGenericInterfaceClassType.GetInterfaces())
例えそのクラス自体がインターフェースを定義していなくても
インターフェースを実装したクラスのサブクラスであればインターフェースを取得できる事が分かる

*Type genericInterfaceType = typeof(IGenericInterface<>);
そもそもこういう書き方できるんだね、っていうw
しかし、genericInterfaceClass is IGenericInterface<> とは書けない

*}
↑これやー！


*var query = list.GroupBy(item => item.Category);
集約keyはint型とします。


*new Human("Yamada", new List<int>(){ 150, 40, 180, 110, 20 }),
適当なインスタンスを作成

*List<int> BadSample1 = new List<int>();
Humansリスト内の全ての要素のList<int> NumbersをひとつのList<int>にまとめたい
冗長なコードの例1

*List<int> BadSample2 = new List<int>();
冗長なコードの例2

*List<List<int>> AllNumbers = Humans.Select(h => h.Numbers).ToList();
LINQを使った例
HumansのNumbersのリストの列挙を作成

*List<int> AllNum = AllNumbers.SelectMany(a => a).ToList();
List<List<T>>をList<T>にする（Listを平坦化する）

*List<int> allNum = Humans.SelectMany(x => x.Numbers).ToList();
List<Human>から一発でList<int>に変換する


*}
返り値の型が間違っていてもエラーしない
return (bool)value ? TextWrapping.Wrap : TextWrapping.NoWrap;

*}
返り値の型が間違っているのでエラーする
return (bool)value ? TextWrapping.Wrap : TextWrapping.NoWrap;


*static Encoding ScriptCharCode => Encoding.UTF8;
文字コードは、UTF8

*static void Main() {LoadEmbedScripts();JSCallTest();}
Main関数が最初に実行される

*//Scriptタグを動的に定義する処理*static void LoadEmbedScripts() {//リソースが埋め込まれたアセンブリを取得するvar asm = System.Reflection.Assembly.GetExecutingAssembly();//アセンブリ内のリソースを全て読み出すforeach (var i in asm.GetManifestResourceNames()) {//リソースをbyte配列で取得var datas = asm.GetManifestResourceData(i);//byte配列をString型に変換var js = ScriptCharCode.GetString(datas);//↓を実行することで埋め込んだスクリプトを使えるようになるDocument.Head.AppendChild(new HTMLScriptElement { TextContent = js });}}
リソースを読み出し、

*static void LoadEmbedScripts() {//リソースが埋め込まれたアセンブリを取得するvar asm = System.Reflection.Assembly.GetExecutingAssembly();//アセンブリ内のリソースを全て読み出すforeach (var i in asm.GetManifestResourceNames()) {//リソースをbyte配列で取得var datas = asm.GetManifestResourceData(i);//byte配列をString型に変換var js = ScriptCharCode.GetString(datas);//↓を実行することで埋め込んだスクリプトを使えるようになるDocument.Head.AppendChild(new HTMLScriptElement { TextContent = js });}}
Scriptタグを動的に定義する処理

*var asm = System.Reflection.Assembly.GetExecutingAssembly();
リソースが埋め込まれたアセンブリを取得する

*var datas = asm.GetManifestResourceData(i);*//byte配列をString型に変換
リソースをbyte配列で取得

*var js = ScriptCharCode.GetString(datas);
byte配列をString型に変換

*Document.Head.AppendChild(new HTMLScriptElement { TextContent = js });
↓を実行することで埋め込んだスクリプトを使えるようになる

*static void JSCallTest() {Console.WriteLine(JSTest.ScriptTestA.GetStr());}
読み込んだスクリプトを使う

*namespace JSTest {
jsファイルの関数をインポートするクラスがある名前空間は、
他の名前空間と被らないように注意！
被ってしまうと、どういうわけかエラーが出てしまう

*[External]
使用するJsファイルを使えるようにするためのクラス

jsファイルに定義した、
JSTest.ScriptTestA.GetStr()のインポート

*[External]
インポート対象の関数には、
Bridge.External属性を指定し、
extern修飾子とstaticをつける

関数内部処理は書かない


*var andon = new Form2();
あんどん表示を第2モニタに表示し、このフォームは閉じる

*var andon = new Window2();
あんどん表示を第2モニタに表示し、このフォームは閉じる


*using Prism.Commands;
prism6

*}
ToDo: Upの処理

*private void btn_PreviewMouseDown(object sender, MouseButtonEventArgs e)
WPF MVVM Buttonのupとdownイベント発生時に各コマンドをICommandに送る

*public DelegateCommand<object> LatXPCommand
Prismの場合。

*if(! para.HasValue)
nullは、Click
trueは PreviewMouseDown
falseは PreviewMouseUp


*element.SendKeys(OpenQA.Selenium.Keys.Return);
もしくはKeys.Enter

*List<string> url_list = new List<string>();
URLリストを定義する

*url_list.Add(lsc_yoku_listdata_rec.Yoku_itemurl);
Console.WriteLine(lsc_yoku_listdata_rec.Yoku_itemurl);          アドレス
urlを配列に代入する

*url_arr = url_list.ToArray();
リストを配列に載せ替える

*url_count = url_arr.Count();
配列のカウント

*int i = 0;
カウント

*e.Cancel = true;
キャンセルされてた場合の処理

*var parser = new HtmlParser();
htmlファイルを読み込む
var html = File.ReadAllText(driver.PageSource, System.Text.Encoding.UTF8);
HTMLParserのインスタンス生成

*var doc = parser.ParseDocument(driver.PageSource);
htmlをパースする

*var detail_element = doc.GetElementById("pageTop");
idを指定してElement取得

*Invoke(new Action<string>(status_mess), i +" / "+ url_count+ "件取得済み");
マルチスレット対応してテキストボックスを操作

*List<IWebElement> details = driver.FindElements(By.ClassName("p-goods-information-action")).ToList();*int flg = 0;
詳細

*flg = 1;
見つかったときはフラグ:1

*worksheet.Cell(i, 6).Value = cell_name;
セルに値を入れる


*using UnityEngine.EventSystems;
追加を忘れないように！

*public class EventCtr : MonoBehaviour*{//EventTriggerをアタッチしておくpublic EventTrigger _EventTrigger;//StopCoroutineのためにCoroutineで宣言しておくCoroutine PressCorutine;bool isPressDown = false;float PressTime = 2f;void Awake (){//PointerDownイベントの登録EventTrigger.Entry pressdown = new EventTrigger.Entry ();pressdown.eventID = EventTriggerType.PointerDown;pressdown.callback.AddListener ((data) => PointerDown ());_EventTrigger.triggers.Add (pressdown);//PointerUpイベントの登録EventTrigger.Entry pressup = new EventTrigger.Entry ();pressup.eventID = EventTriggerType.PointerUp;pressup.callback.AddListener ((data) => PointerUp ());_EventTrigger.triggers.Add (pressup);}//EventTriggerのPointerDownイベントに登録する処理void PointerDown (){Debug.Log ("Press Start");//連続でタップした時に長押しにならないよう前のCoroutineを止めるif (PressCorutine != null) {StopCoroutine (PressCorutine);}//StopCoroutineで止められるように予め宣言したCoroutineに代入PressCorutine = StartCoroutine (TimeForPointerDown ());}//長押しコルーチンIEnumerator TimeForPointerDown (){//プレス開始isPressDown = true;//待機時間yield return new WaitForSeconds (PressTime);//押されたままなら長押しの挙動if (isPressDown) {Debug.Log ("Long Press Done");//お好みの長押し時の挙動をここに書く}//プレス処理終了isPressDown = false;}//EventTriggerのPointerUpイベントに登録する処理void PointerUp (){if (isPressDown) {Debug.Log ("Short Press Done");isPressDown = false;//お好みの短押し時の挙動をここに書く(無い場合は書かなくても良い)}Debug.Log ("Press End");}}
長押しを発生させるuGUI(ImageやText)にアタッチして使う

*public EventTrigger _EventTrigger;
EventTriggerをアタッチしておく

*Coroutine PressCorutine;
StopCoroutineのためにCoroutineで宣言しておく

*EventTrigger.Entry pressdown = new EventTrigger.Entry ();
PointerDownイベントの登録

*EventTrigger.Entry pressup = new EventTrigger.Entry ();
PointerUpイベントの登録

*void PointerDown ()*{Debug.Log ("Press Start");//連続でタップした時に長押しにならないよう前のCoroutineを止めるif (PressCorutine != null) {StopCoroutine (PressCorutine);}//StopCoroutineで止められるように予め宣言したCoroutineに代入PressCorutine = StartCoroutine (TimeForPointerDown ());}
EventTriggerのPointerDownイベントに登録する処理

*PressCorutine = StartCoroutine (TimeForPointerDown ());
StopCoroutineで止められるように予め宣言したCoroutineに代入

*IEnumerator TimeForPointerDown ()*{//プレス開始isPressDown = true;//待機時間yield return new WaitForSeconds (PressTime);//押されたままなら長押しの挙動if (isPressDown) {Debug.Log ("Long Press Done");//お好みの長押し時の挙動をここに書く}//プレス処理終了isPressDown = false;}
長押しコルーチン

*isPressDown = true;
プレス開始

*yield return new WaitForSeconds (PressTime);
待機時間

*}
お好みの長押し時の挙動をここに書く

*isPressDown = false;
プレス処理終了

*void PointerUp ()*{if (isPressDown) {Debug.Log ("Short Press Done");isPressDown = false;//お好みの短押し時の挙動をここに書く(無い場合は書かなくても良い)}Debug.Log ("Press End");}
EventTriggerのPointerUpイベントに登録する処理

*}
お好みの短押し時の挙動をここに書く(無い場合は書かなくても良い)


*var postkey = c.GetStringAsync("http:
ow.live.nicovideo.jpapigetpostkey?thread=" + thread).Result.Replace("postkey=", "");


*}
省略


*Array.Sort(a); Array.Reverse(a);
Array.Sortは昇順ソートを行います

*var words = new string[] { "maerd", "remaerd", "esare", "resare" };
問題文にある文字列を逆にしたもの

*var t = new int[N + 1];
初期状態をt[0], x[0], y[0]とすることで便利になります


*public bool ShouldAddProjectItem(string filePath) => true;
無条件でProjectItemを生成する

*var dte = (EnvDTE._DTE)automationObject;
選択中のプロジェクトはActiveSolutionProjectsの配列の先頭にある


*var ie = MoveNext((IEnumerator)current);
currentがIEnumeratorの場合再帰的に実行

*else if (type == typeof(Coroutine))
IEnumerator以外はcurrent.GetType()で判断する
下記は説明用の分岐。


*var responses = vision.Images.Annotate(new BatchAnnotateImagesRequest()
Post text detection request to the Vision API


*public const int Value = 10;
constだけでstatic扱いなのでstaticは不要


*else if(mIsActive && !mIsPlayer)
アクティブかつ敵の場合はAI行動を決定＆実行

*mAi.DecideMovement();
移動目標を決定

*mAi.CheckMovement();
移動完了の判定

*mAi.CalTurretRotation();
砲台向きを計算

*mAi.Fire();
発射

*mHealthScript.RenewHealthBar();
HP描画はアクティブに影響を受けないで更新


*case STATE.PLAY:
ゲームプレイ中

*if (Input.GetKeyDown(KeyCode.Backspace)) mGame.OnRestartButton();*}
リスタート

*SceneManager.LoadScene(SceneManager.GetActiveScene().name);
シーンの再読み込み


*case STATE.PLAY:
ゲームプレイ中


*break;
初期化処理

*break;
プレイ中

*break;
ゲームオーバー

*private static readonly GameController mInstance = new GameController();
初期化タイミングでインスタンスを生成

*private GameController() { }
コンストラクタをprivateにすることによって他クラスからnewできないようにする

*public static GameController Instance*{get{return mInstance;}}
他クラスからこのマネージャーを参照する

*private readonly float FIXED_TIME_STEP = 0.03f;
FixedUpdateの間隔

*Time.fixedDeltaTime = FIXED_TIME_STEP;
更新間隔の設定

*private readonly float FIXED_TIME_STEP = 0.03f;
FixedUpdateの間隔

*Time.fixedDeltaTime = FIXED_TIME_STEP;
更新間隔の設定

*追加        SetLayerCollision();
当たり判定の設定

*Physics.IgnoreLayerCollision(LAYER_WHEEL, LAYER_WHEEL, true);
車輪同士の接触は無効

*Physics.IgnoreLayerCollision(9, 11, true);
車輪と本体の接触は無効

*public static string TAG_TANK = "Tank";
タグ

*bool IsDead = collider.transform.GetComponent<TankHealth>().AddDamage(mAttackValue);*if (!IsDead)
被弾した戦車にダメージを与える

*Vector3 hitPos = collider.ClosestPointOnBounds(mTrans.position);
おおまかな接触点を取得（OnCollisionEnterとは異なり、triggerでは正確な座標を取得できない：でも着弾点としては十分？）

*Instantiate(mExplosionSmallPrefab, hitPos, Quaternion.identity);
接触した場所に爆発エフェクトを生成

*Vector3 hitPos = collider.transform.position;*Instantiate(mExplosionLargePrefab, hitPos, Quaternion.identity);
HPが無くなった場合は戦車中央のポイントに大きな爆発エフェクトを生成

*collider.transform.GetComponent<TankModel>().IsDead = true;*}
対象を死亡状態へ

*Sleep();
この弾を休眠状態へ


*private float mPreFillAmount;
増減アクションの終了条件となるHPバーのfillAmount

*mMovementScript.CheckInput();
移動入力の受付

*mTurretScript.CalRotation();
砲台角度を計算

*mFireScript.CheckInput();
弾発射の入力を受付

*追加        mHealthScript.RenewHealthBar();
HPバーの更新


*private Transform mTransFirePoint;
発射時の弾とエフェクトについて、位置と方向を決定する

*public void CheckInput()*{if (Input.GetMouseButtonDown(0)) Fire();}
----------------------------------------------------------------------------------------

*private readonly float BULLET_OFFSET = 1.0f;
発射
----------------------------------------------------------------------------------------
発射地点のTransformから正面方向に1.0f進んだ座標に弾を生成する

*private List<BulletModel> mBulletList = new List<BulletModel>();
生成された弾オブジェクトをプーリング

*private int mBulletCount = 3;
所持している弾数

*private int mBulletAttack = 10;
弾の攻撃力

*private float mBulletSpeed = 40.0f;
弾の速さ

*mBulletCount--;
所持弾数をデクリメント

*CreateMuzzleFire();
発射エフェクト生成

*CreateBullet();
弾生成

*GameObject bulletGo = Instantiate(mBulletPrefab, mTransFirePoint.position + mTransFirePoint.forward * BULLET_OFFSET, mTransFirePoint.rotation) as GameObject;*bulletGo.transform.parent = mTransBulletGroup;
再利用できるオブジェクトが無かった場合は新しく生成してリストに格納する

*public void OnSleepBullet()
デリゲート受け取り
----------------------------------------------------------------------------------------


*serialPort1.Open();
ポートを開く


*public void GetMousePosition3d()*{// カメラからマウスポインタの方向へ伸びるRayを作成Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);// Rayが接触したコライダーの情報を格納する入れ物RaycastHit hit;// Rayの衝突判定if(Physics.Raycast(ray, out hit)){// 衝突したコライダーのTransformから座標を取得するTransform hitTrans = hit.transform;Vector3 position = hitTrans.position;}}
Ray（光線）を使ってマウスポインタの3D空間上の座標を取得する

*Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
カメラからマウスポインタの方向へ伸びるRayを作成

*RaycastHit hit;
Rayが接触したコライダーの情報を格納する入れ物

*Transform hitTrans = hit.transform;*Vector3 position = hitTrans.position;
衝突したコライダーのTransformから座標を取得する

*private Plane mTempPlane;
地面の代わりとして使う仮の平面

*private float mDistance;
Rayを飛ばした際にmTempPlaneと接触するまでの距離

*mTempPlane = new Plane();
mTempPlaneを予め生成し、Groundと同じ位置に配置しておく

*Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
カメラからマウスポインタの方向へRayを飛ばす

*Vector3 mousePosition3d = ray.GetPoint(mDistance);
RayとmTempPlaneとの接点を取得

*private Vector3 mTurretRotation = Vector3.zero;
次のFixedUpdateで砲台に適用するRotation値

*public void CalRotation()*{// カメラからマウスポインタの方向へRayを飛ばすRay ray = Camera.main.ScreenPointToRay(Input.mousePosition);if (mTempPlane.Raycast(ray, out mDistance)){// RayとmTempPlaneとの接点を取得Vector3 mousePosition3d = ray.GetPoint(mDistance);// 対象座標 - 観測座標 = 観測座標から対象座標へ向かうベクトルVector3 direction = mousePosition3d - mTurretTrans.position;// 砲台の正面が対象を向いたときの角度を計算Quaternion quaternion = Quaternion.FromToRotation(transform.forward, direction);// 砲台の回転軸をYのみに制限するmTurretRotation = quaternion.eulerAngles;mTurretRotation.x = 0.0f;mTurretRotation.z = 0.0f;/*// Y軸の値について、インスペクタ上のRotationでは-180~180の表記だが、コード上では0~360で計算されているif (mTurretRotation.y < 30.0f){mTurretRotation.y = 30.0f;}else if (mTurretRotation.y > 270.0f){mTurretRotation.y = 30.0f;}else if (mTurretRotation.y > 150.0f){mTurretRotation.y = 150.0f;}*/}}
GetMousePosition3d()から名称を変更

*Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
カメラからマウスポインタの方向へRayを飛ばす

*Vector3 mousePosition3d = ray.GetPoint(mDistance);
RayとmTempPlaneとの接点を取得

*Vector3 direction = mousePosition3d - mTurretTrans.position;
対象座標 - 観測座標 = 観測座標から対象座標へ向かうベクトル

*Quaternion quaternion = Quaternion.FromToRotation(transform.forward, direction);*// 砲台の回転軸をYのみに制限する
砲台の正面が対象を向いたときの角度を計算

*mTurretRotation = quaternion.eulerAngles;
砲台の回転軸をYのみに制限する

*public void ApplyRotation()*{mTurretTrans.rotation = Quaternion.Euler(mTurretRotation);}
計算された角度を砲台のRotationに適用する

*mMovementScript.CheckInput();
移動入力の受付

*追加            mTurretScript.CalRotation();
砲台角度を計算

*mMovementScript.ApplyVelocity();
移動力の更新

*追加        mTurretScript.ApplyRotation();
砲台角度の更新


*this.gameObject.layer = 11;
Layer11 >> for MainBody.

*Physics.IgnoreLayerCollision(LAYER_WHEEL, LAYER_WHEEL, true);
車輪同士の接触は無効

*Physics.IgnoreLayerCollision(9, 11, true);
車輪と本体の接触は無効


*il.DeclareLocal(method.ReturnParameter.ParameterType);
result

*var label1 = il.DefineLabel();
ラベルの宣言

*il.Emit(OpCodes.Ldarg_0);
dictionaryField の値をスタックに積む

*il.Emit(OpCodes.Ldnull);
null をスタックに積む

*il.Emit(OpCodes.Ceq);
スタックに積まれた dictionaryFiled の値と null が等しければ true を等しくなければ false を boolVariable1 に代入

*il.Emit(OpCodes.Ldloc_2);
boolVariable1 が false なら label1 にジャンプ

*il.Emit(OpCodes.Ldarg_0);
dictionaryField に Dictionary<Param, T> を代入

*il.Emit(OpCodes.Ldc_I4, parameterTypes.Length);
object[] を用意

*il.Emit(OpCodes.Newobj, paramConstructor);
Param を作成してローカル変数 0 に保存

*il.Emit(OpCodes.Ldloc_3);
TryGetValue の結果が false なら label2 へ

*il.Emit(OpCodes.Br_S, label3);
リターン位置へジャンプ

*il.Emit(OpCodes.Ldarg_0);
メモ


*FilteredElementCollector collectorLevel = new FilteredElementCollector(doc).OfClass(typeof(Level));
まず、LevelだけのFilteredElementCollectorを取得する

*ICollection<ElementId> exIds = collectorLevel.ToElementIds();
CollectorからElementIDのリストを取得する。これを除外リストとして使う

*if (el.Category == null) continue;*// 建物の階にチェックが入っているものは除外リストから外す
念のため

*collectorLevel.Excluding(exIds);
除外実行

*IOrderedEnumerable<Level> lstLevels = from Level lv in collectorLevel orderby lv.LookupParameter(@"高さ").AsDouble() ascending select lv;
高さでソート（昇順）


*const string host_in = "https:
httpbin.org";


*const string host_in = "https:
httpbin.org";


*public void Execute()*{if (commands.Count > 0){IEnumerator enumerator = commands.GetEnumerator();while (enumerator.MoveNext()){ICommand obj =(ICommand)enumerator.Current;obj.Execute();}}}
実行

*public virtual void Apppend(ICommand addCommand)*{if (addCommand != this) commands.Push(addCommand);}
追加

*public void Undo()*{if (commands.Count > 0) commands.Pop();}
削除

*public void Clear() => commands.Clear();
全件削除

*protected IDrawable drawable;
描画対象

*private Point point;
描画位置

*public DrawCommand(IDrawable drawable, Point point)*{this.drawable = drawable;this.point = point;}
コンストラクタ

*public void Execute()*{drawable.Draw(point.X, point.Y);}
実行

*private Color color = Color.Black;
描画色

*private int radius = 6;
半径

*private MacroCommand history = null;
履歴

*public void SetHistory(MacroCommand history) => this.history = history;
履歴セット（本来はコンストラクタ、今回はメソッドを用意）

*public void Draw(int x, int y)*{using (Graphics g = CreateGraphics())using (Brush brush = new SolidBrush(color)){Rectangle rectangle = new Rectangle(x, y, radius, radius);g.FillEllipse(brush, rectangle);}}
描画

*private void DrawCanvas_Paint(object sender, PaintEventArgs e)*{if (history != null){history.Execute();}}
再描画

*private MacroCommand history = new MacroCommand();
描画履歴

*private void drawCanvas1_MouseMove(object sender, MouseEventArgs e)*{if (drag){ICommand command = new DrawCommand(drawCanvas1, e.Location);history.Apppend(command);command.Execute();}}
マウスが動いている時

*private void ClearButton_Click(object sender, EventArgs e)*{history.Clear();drawCanvas1.Invalidate();}
Clearボタン押下

*private void Undo_Click(object sender, EventArgs e)*{history.Undo();drawCanvas1.Invalidate();}
Undoボタン押下


*SetTextIfEmpty(ref LastName, "Doe");
コンパイルエラー

*private void SetTextIfEmpty(ref string value, string textEmpty)*{if (String.IsNullOrEmpty(value)){value = "John";}}
参照渡しで受け取った文字列が空白だった、別の文字列を代入する

*private void SetTextIfEmpty(string value, Action assingAction)*{if (String.IsNullOrEmpty(value)){assingAction();}}
文字列が空白だったら、受け取ったデリゲートを実行する

*private void SetTextIfEmpty(Expression<Func<string>> propertySelector, string textEmpty)*{Utilitiy.SetIf(propertySelector,predicate: x => String.IsNullOrEmpty(x),inputValue: textEmpty);}
文字列を取得して空白だったら、生成した代入デリゲートを実行する

*var value = propertySelector.Compile().Invoke();
式木からデリゲート生成、生成したデリゲートを実行して現在の値を取得する

*var assignAction = Utilitiy.CreateAssignActionExpr(propertySelector).Compile();
プロパティを取得する式木を材料にプロパティへの代入をする式木を組み立てて、デリゲート生成

*assignAction.Invoke(inputValue);
生成した代入デリゲートに値を指定して実行

*var inputExpr = Expression.Parameter(typeof(TValue), "x");
生成される式：x

*var assignExpr = Expression.Assign(propertySelector.Body,inputExpr);
生成される式：this.Name = x

*return Expression.Lambda<Action<TValue>>(assignExpr, inputExpr);
生成される式：x => this.Name = x


*var grouped = balls.Grouping(b => b.Color);
色別にグルーピング

*IEnumerable<Ball> redBalls = grouped.GetItem(RGB.Red);*foreach (Ball ball in redBalls) {...}
赤色のボールについて何かする

*grouped.Remove(RGB.Green);
緑色のボールを削除

*var grouped = balls.GroupBy(b => b.Color);
色別にグルーピング

*var redBalls = grouped.Single(g => g.Key == RGB.Red);
grouped の型は IEnumerable<IGrouping<RGB, Ball>>
赤色のボールについて何かする

*grouped = grouped.Where(g => g.Key != RGB.Green);
緑色のボールを削除

*ILookUp<RGB, Ball> grouped = balls.ToLookUp(b => b.Color);
色別にグルーピング

*IEnumerable<Ball> redBalls = grouped[RGB.Red];
grouped の型は ILookUp<RGB, Ball>
赤色のボールについて何かする

*,,,
緑色のボールを削除
grouped.Remove(RGB.Green);  No such method.

*Dictionary<RGB, List<Ball>> grouped = new Dictionary<RGB, List<Ball>>();*foreach (Ball ball in balls) {List<Ball> list;if (!grouped.TryGetValue(ball.Color)) {list = new List<Ball>();grouped.Add(ball.Color, list);}list.Add(ball);}
色別にグルーピング

*List<Ball> redBalls = grouped[RGB.Red];*foreach (Ball ball in redBalls) {...}
赤色のボールについて何かする

*grouped.Remove(RGB.Green);
緑色のボールを削除

*Dictionary<RGB, IGrouping<RGB, Ball>> grouped = balls.GroupBy(b => b.Color).ToDictionary(g => g.Key);
色別にグルーピング

*var redBalls = grouped[RGB.Red];
grouped の型は Dictionary<RGB, IGrouping<RGB, Ball>>
赤色のボールについて何かする

*...
IGrouping<RGB, Ball> は IEnumerable<Ball> の子クラス

*grouped.Remove(RGB.Green);
緑色のボールを削除

*IGrouping<RGB, Ball> blackBalls;*if (grouped.TryGetValue(RGB.Black, out blackBalls)) {foreach (Ball ball in blackBalls) {...}}
黒色のボールがあれば何かする

*var grouped = balls.GroupBy(b => b.Color).ToDictionary(g => g.Key, g => g as IEnumerable<Ball>);
色別にグルーピング

*var redBalls = grouped[RGB.Red];
grouped の型は Dictionary<RGB, IEnumerable<Ball>>
赤色のボールについて何かする

*grouped.Remove(RGB.Green);
緑色のボールを削除

*IEnumerable<Ball> blackBalls;*if (grouped.TryGetValue(RGB.Black, out blackBalls)) {foreach (Ball ball in blackBalls) {...}}
黒色のボールがあれば何かする


*}
ここに張り付ける

*public class Rootobject*{public Result[] result { get; set; }}
ここに張り付ける


*VmMyCommand1.RaiseCanExecuteChanged();
★CanExecuteが変化したことを使えないと、フラグ切り替えても有効無効変わらない！

*public async Task MyAsyncFunc()*{Debug.WriteLine("押された");await Task.Delay(2000);Debug.WriteLine("処理完了");}
実験用 押したときに2秒かかる処理実施

*public bool MyCanExecute()*{return MyCamExecuteFlag;}
フラグのON/OFFでボタンの有効無効を切り替える

*private bool isExecuting = false;
処理中フラグ

*public bool CanExecute(object parameter) => (canExecute != null) ? (canExecute() && !isExecuting) : (!isExecuting);
本クラスを使う側が設定するCanExecuteに加え、処理中フラグのON/OFFを有効無効条件に加える

*public async void Execute(object parameter)*{IsExecuting = true;await execute();IsExecuting = false;}
処理実行の前後に、無効化→有効化、の処理を追加する


*string result = string.Copy(_defaultText);
元データと比べたいためコピーを作る

*var regex = new Regex(@"\B[A-Z]");
検索パターン。今回は先頭末尾以外の大文字を検索する

*var matches = regex.Matches(result);
パターンに一致した文字列を配列で確保

*int searchIndex = 1;
先頭文字には挿入させないため1にしておく

*const int ADD_SEARCH_NUM = 2;
次の文字列の検索するための増加分

*const string INSERT_TEXT = "_";
挿入したい文字を入れる。今回はアンダーバー

*int findIndex = result.IndexOf(match.ToString(), searchIndex);
文字列の場所を検索。成功すると0以上の数字が返ってくる

*string result = string.Copy(_defaultText);
元データと比べたいためコピーを作る


*var d = new Dictionary<string, MyClass>();
<キーの型, 値の型>


*handle = FindWindow(null, WINDOW_NAME);
起動したウィンドウを指定

*SetWindowPos(handle, HWND_TOPMOST, 0, 0, displayWidth, displayHeight, SWP_SHOWWINDOW);
SetWindowLongによる変更を適用


*db.Configuration.ProxyCreationEnabled = false;
動的プロキシ禁止

*ModelResponse<T1> ret = new ModelResponse<T1>();
戻り値生成

*ret.token = this.GenerateToken();
トークンの設定

*ModelRequest<T2> req = (ModelRequest<T2>)DeserializeJson<T2>(request);
検索用パラメータの取得

*ret.resultCode = resultCode.Select_WithInfo;
検証失敗時

*{object Records = null;int ResultCodeOrSelectCount = 0;// トランザクションを使用する場合if (IsUseTransaction){using (var tran = db.Database.BeginTransaction()){try{ResultCodeOrSelectCount = Execute(req.data, out Records);// 更新実行if (this.SaveChanges()){//更新正常終了tran.Commit();ResultCodeOrSelectCount = DBParameters.ResultCode.UpdateSuccess;}else{//更新失敗(検証失敗、検証以外は例外をスロー)tran.Rollback();ResultCodeOrSelectCount = DBParameters.ResultCode.UpdateValidateError;}}catch (Exception ex){// 検証以外の例外時は例外を再スローtran.Rollback();throw ex;}}}else{ResultCodeOrSelectCount = Execute(req.data, out Records);}// 取得レコードが存在する場合、レスポンスデータに設定if (Records != null){logger.Info("");ret = (ModelResponse<T1>)Records;}// 戻り値の設定{// 返却メッセージ初期化ret.message = CommonStrings.DataBase.EmptyMessage;// 戻り値によって返却値、メッセージを設定switch (ResultCodeOrSelectCount){case DBParameters.Parameter.SelectMin:ret.resultCode = resultCode.Select_NotFoundResult;ret.message = CommonStrings.DataBase.Warning.Select_RecordNotExist;break;case DBParameters.Parameter.SelectMax:ret.resultCode = resultCode.Select_WithInfo;ret.message = CommonStrings.DataBase.Question.Select_OverRecords;break;case DBParameters.ResultCode.UpdateSuccess:ret.resultCode = resultCode.Update_Success;break;case DBParameters.ResultCode.UpdateValidateError:ret.resultCode = resultCode.Update_WithWarinig;break;default:ret.resultCode = resultCode.Select_Success;break;}}}
処理実行

*tran.Commit();
更新正常終了

*tran.Rollback();
更新失敗(検証失敗、検証以外は例外をスロー)

*tran.Rollback();
検証以外の例外時は例外を再スロー

*{// 返却メッセージ初期化ret.message = CommonStrings.DataBase.EmptyMessage;// 戻り値によって返却値、メッセージを設定switch (ResultCodeOrSelectCount){case DBParameters.Parameter.SelectMin:ret.resultCode = resultCode.Select_NotFoundResult;ret.message = CommonStrings.DataBase.Warning.Select_RecordNotExist;break;case DBParameters.Parameter.SelectMax:ret.resultCode = resultCode.Select_WithInfo;ret.message = CommonStrings.DataBase.Question.Select_OverRecords;break;case DBParameters.ResultCode.UpdateSuccess:ret.resultCode = resultCode.Update_Success;break;case DBParameters.ResultCode.UpdateValidateError:ret.resultCode = resultCode.Update_WithWarinig;break;default:ret.resultCode = resultCode.Select_Success;break;}}
戻り値の設定

*ret.message = CommonStrings.DataBase.EmptyMessage;
返却メッセージ初期化

*logger.Fatal(ex.Message);
オプティミスティック同時実行制御違反

*logger.Fatal(ex.Message);
データベースへの更新送信エラー

*logger.Fatal(error.ErrorMessage);
ログ出力

*logger.Fatal(ex.Message);
非サポートコマンド実施

*logger.Fatal(ex.Message);
コンテキスト破棄エラー

*logger.Fatal(ex.Message);
コマンド送信時コンテキスト内部処理エラー

*HttpResponseMessage result = Request.CreateResponse(HttpStatusCode.OK);
作成したファイルをストリーム送信用に変換


*int loop = 1000000;
100万回


*if (y * d != c)
yは切り捨てされるので、ここで、再度チェック


*var model = new MainModel();
ViewModelを登録する

*(DataContext as MainModel).ClickMeCommand.Execute(sender);
メニュー(ButtonMenuItem)のCommandプロパティに「"{Binding ClickMeCommand}"」と
設定しても動かなかったので、コードビハインドに見せかけてDataContextを直接叩く荒業

*public ICommand ClickMeCommand { get; private set; }
プロパティ

*private void ClickMe(object sender, EventArgs e) {MessageBox.Show("I was clicked!");}
実行するメソッド

*public MainModel() {ClickMeCommand = new Command(ClickMe);LabelText = "Some Content";}
コンストラクタ

*this.Menu.ApplicationMenu.Text = "ファイル(&F)";
メニューバーを書き変える

*var model = new MainModel();
ViewModelを登録する

*var image1 = new Eto.Drawing.Bitmap(w1, h2, PixelFormat.Format24bppRgb);
画像データを用意する

*using(var g = new Eto.Drawing.Graphics(image1)){image2から切り出す範囲を指定(下記例だと左上座標は(x,y)、幅w3・高さh3の範囲)var cropRect = new Eto.Drawing.Rectangle(x, y, w3, h3);
Eto.Drawing.Graphics型はIDisposeを継承しているのでusingが使える

*var cropRect = new Eto.Drawing.Rectangle(x, y, w3, h3);
image2から切り出す範囲を指定(下記例だと左上座標は(x,y)、幅w3・高さh3の範囲)

*var tempImage = image2.Clone(cropRect);
tempImageはimage2から切り出された範囲

*g.DrawImage(tempImage, x2, y2);
image1の指定した位置(x2,y2)にtempImageを貼り付ける
ちなみにGraphics.DrawImage(Image, float x, float y)メソッドは
見ての通り第2・第3引数がなぜか実数だが、整数を入れてもキャストされるので
問題なく使用できる


*public IEnumerator CardOpen ()
カードのGameObjectにアタッチしたScriptに記述
右回転用

*transform.eulerAngles = new Vector3 (0, 180, 0);
カードを予め-180度回転させ裏面用の画像を表示する
裏面表示はコルーチン外で行っても良い
CanvasGroupでなくspriteのalpha値を操作しても良い

*ReversedFace_CanvasGroup.alpha = 0f;
裏面用の画像を非表示(表面が表示される)

*transform.eulerAngles = new Vector3 (0, 0, 0);*}
綺麗に0度にならないことがあるため、補正


*transform.localRotation = Quaternion.Euler(0, 0, 0);*duration = 2f;
reset property


*string scriptPath = Application.dataPath + "/StreamingAssets/ProcessScripts/";
プロセスを起動させるbatファイルが格納されたディレクトリのパス

*if (process != null) return;*// 新規プロセスを作成し、batファイルのパスを登録
他のプロセスが実行しているなら行わない

*process = new Process();
新規プロセスを作成し、batファイルのパスを登録

*process.EnableRaisingEvents = true;
外部プロセスの終了を検知するための設定

*process.Start();
外部プロセスを実行

*void process_Exited(object sender, System.EventArgs e)*{process.Dispose();process = null;}
外部プロセスの終了を検知してプロセスを終了


*ExcelWorksheet sheet = pck.Workbook.Worksheets[1];
Ver4.5では、Worksheetsは 0 から始まるように変更


*public abstract U Convert(T value, Type targetType, object parameter, string language);
継承クラスで実装する型Tから型UへのConvert関数

*public object Convert(object value, Type targetType, object parameter, string language)*{switch (value){case T t_val:return Convert(t_val, targetType, parameter, language);case IEnumerable<T> t_arr:return t_arr.Select(t => Convert(t, targetType, parameter,language));default:return null;}}
IValueConverterの実装

*public abstract T ConvertBack(U value, Type targetType, object parameter, string language);
継承クラスで実装する型Uから型TへのConvertBack関数

*public object ConvertBack(object value, Type targetType, object parameter, string language)*{switch (value){case U u_val:return ConvertBack(u_val, targetType, parameter, language);case IEnumerable<U> u_arr:return u_arr.Select(u => ConvertBack(u, targetType, parameter, language));default:return null;}}
IValueConverterの実装

*public abstract class ValueConverterBase<T, U> : Windows.UI.Xaml.Data.IValueConverter*{public object Convert(object value, Type targetType, object parameter, string language){switch (value){case T t_val:return Convert(t_val, targetType, parameter, language);case IEnumerable<T> t_arr:return t_arr.Select(t => Convert(t, targetType, parameter, language));default:return null;}}public object ConvertBack(object value, Type targetType, object parameter, string language){switch (value){case U u_val:return ConvertBack(u_val, targetType, parameter, language);case IEnumerable<U> u_arr:return u_arr.Select(u => ConvertBack(u, targetType, parameter, language));default:return null;}}public abstract U Convert(T value, Type targetType, object parameter, string language);public abstract T ConvertBack(U value, Type targetType, object parameter, string language);}
TからUへの変換


*bool CheckDuplication()*{HashSet<Pokemon> hashSet = new HashSet<Pokemon> ();foreach (var item in Party) {hashSet.Add (item);}//重複がある場合は要素数が減るif (Party.Count > hashSet.Count) {return false;}return true;}
重複時はfalseを返す


*.Publish();
Publish以前のIObservableを保持したIConnectableObservableにする

*observable.Subscribe(Console.WriteLine);
Publishの内部が持つSubjectを購読

*observable.Connect();
Publish以前のIObservableをSubscribeして、Subjectに伝える


*handle = FindWindow(null, WINDOW_NAME);
指定したウィンドウを取得

*SetWindowPos(handle, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_FRAMECHANGED | SWP_SHOWWINDOW);
タイトルバーを非表示
uint style = GetWindowLong(handle, GWL_STYLE);  ウィンドウの情報を取得
SetWindowLong(handle, GWL_STYLE, style ^ WS_CAPTION);  ウィンドウの属性を変更
SetWindowLongによる変更を適用


*StartCoroutine(CoTalk());
会話シナリオを呼び出します

*Debug.Log("call co talk");
「宴」のシナリオ「Start」タグの会話シーンを呼び出す
会話をどのように構成するか、条件分岐、フラグ設定などは
なんと１つのエクセルでできてしまいます・・・
なお「Start」はデフォルトで入っているタグなので
設定しなくとも下記コードは動きます


*if(index == -1)*index = 0;
type string missing


*SetLayeredWindowAttributes(handle, TRANSPARENT_COLOR, 0, LWA_COLORKEY);
ウィンドウの特定の色を透過


*private async Task HandleCard(CardEventArgs args) {try {//(前のカードが残ってたら消しておく)card?.Dispose();//カードのインスタンス作ってcard = args.SmartCard.CreateMiFareCard();var localCard = card;//カード情報引いたりvar cardIdentification = await localCard.GetCardInfo();DisplayText("Connected to card\r\nPC/SC device class: " + cardIdentification.PcscDeviceClass.ToString() + "\r\nCard name: " + cardIdentification.PcscCardName.ToString());// MiFareカードならif (cardIdentification.PcscDeviceClass == MiFare.PcSc.DeviceClass.StorageClass&& (cardIdentification.PcscCardName == CardName.MifareStandard1K || cardIdentification.PcscCardName == CardName.MifareStandard4K)) {// 2セクタ0ブロックを読み込みvar data = await localCard.GetData(2, 0, 48);// ダンプしたり何なりする// 2セクタ1ブロックを0フィルawait localCard.SetData(2,1, Enumerable.Range(0,16).Select<byte>(i=>0x00).ToArray());//更新を適用await localCard.Flush();}} catch (Exception e) {PopupMessage("HandleCard Exception: " + e.Message);}}
カードが接続されたら

*card?.Dispose();
(前のカードが残ってたら消しておく)

*card = args.SmartCard.CreateMiFareCard();
カードのインスタンス作って

*var cardIdentification = await localCard.GetCardInfo();*DisplayText("Connected to card\r\nPC/SC device class: " + cardIdentification.PcscDeviceClass.ToString() + "\r\nCard name: " + cardIdentification.PcscCardName.ToString());
カード情報引いたり

*var data = await localCard.GetData(2, 0, 48);
2セクタ0ブロックを読み込み

*await localCard.SetData(2,1, Enumerable.Range(0,16).Select<byte>(i=>0x00).ToArray());
ダンプしたり何なりする
2セクタ1ブロックを0フィル

*await localCard.Flush();
更新を適用

*card?.Dispose();
(前のカードが残ってたら消しておく)

*var keySet = new List<SectorKeySet>(){new SectorKeySet(){Sector=1,KeyType=KeyType.KeyA,"FFFFFFFFFFFF"),new SectorKeySet(){Sector=1,KeyType=KeyType.KeyB,"A0A1A2A3A4A5"),new SectorKeySet(){Sector=2,KeyType=KeyType.KeyA,"000000000000"),new SectorKeySet(){Sector=2,KeyType=KeyType.KeyB,"BBBBBBAAAAAA"),// : 以下略}//こうじゃcard = args.SmartCard.CreateMiFareCard(keySet);,,,//セクターを読んでvar sector = card.GetSector(2);//(必要なら)データブロックごとの権限を設定してforeach (var area in sector.Access.DataAreas) {area.Read = DataAreaAccessCondition.ConditionEnum.KeyAOrB;area.Write = DataAreaAccessCondition.ConditionEnum.KeyB;area.Increment = DataAreaAccessCondition.ConditionEnum.KeyB;area.Decrement = DataAreaAccessCondition.ConditionEnum.KeyB;}//こうじゃawait sector.FlushTrailer("FFFFFFFFFFFF", "FF00FF00FF00");,,,*}
: 以下略

*card = args.SmartCard.CreateMiFareCard(keySet);
こうじゃ

*var sector = card.GetSector(2);
セクターを読んで

*await sector.FlushTrailer("FFFFFFFFFFFF", "FF00FF00FF00");
こうじゃ


*public void StartRecord()
公開変数
public int maxDuration;                  最大の録音時間（20秒とか）
public AudioClip audioClip;              音声データ
非公開変数
private const int sampleRate = 16000;    録音のサンプリングレート
private string mic;                      マイクのデバイス名

*mic = Microphone.devices[0];
マイク名

*audioClip = Microphone.Start(mic, false, maxDuration, sampleRate);
録音開始。audioClipに音声データを格納。

*int position = Microphone.GetPosition(mic);
マイクの録音位置を取得

*Microphone.End(mic);
マイクの録音を強制的に終了

*Debug.Log("修正前の録音時間: " + audioClip.length);
再生時間を確認すると、停止した時間に関わらず、maxDurationの値になっている。これは無音を含んでいる？

*float[] soundData = new float[audioClip.samples * audioClip.channels];
音声データ一時退避用の領域を確保し、audioClipからのデータを格納

*float[] newData = new float[position * audioClip.channels];
新しい音声データ領域を確保し、positonの分だけ格納できるサイズにする。

*AudioClip newClip = AudioClip.Create(audioClip.name, position, audioClip.channels, audioClip.frequency, false);
新しいAudioClipのインスタンスを生成し、音声データをセット

*AudioClip.Destroy(audioClip);
audioClipを新しいものに差し替え

*Debug.Log("修正後の録音時間: " + newClip.length);
再生時間


*//Projectウィンドウのファイル選択→右クリック、または左上のAssetsボタンから呼ぶことができる*public class EDITOR_FileOpenInApp: EditorWindow {[MenuItem("Assets/Open in System Default Application")]private static void GetSelectFile(){if(Selection.assetGUIDs != null && Selection.assetGUIDs.Length > 0){List<string> fileList = new List<string>();foreach(var files in Selection.assetGUIDs){var path = AssetDatabase.GUIDToAssetPath(files);fileList.Add(path);}foreach (string directory in fileList) {Command("open " + Application.dataPath + directory.Substring(6, directory.Length - 6));}}}static string Command(string cmd){var p = new Process();p.StartInfo.FileName = "/bin/bash";p.StartInfo.Arguments = "-c \" " + cmd + " \"";p.StartInfo.UseShellExecute = false;p.StartInfo.RedirectStandardOutput = true;p.Start();var output = p.StandardOutput.ReadToEnd();p.WaitForExit();p.Close();return output;}}
システムのデフォルトアプリケーションでファイルを開く機能を

*public class EDITOR_FileOpenInApp: EditorWindow {[MenuItem("Assets/Open in System Default Application")]private static void GetSelectFile(){if(Selection.assetGUIDs != null && Selection.assetGUIDs.Length > 0){List<string> fileList = new List<string>();foreach(var files in Selection.assetGUIDs){var path = AssetDatabase.GUIDToAssetPath(files);fileList.Add(path);}foreach (string directory in fileList) {Command("open " + Application.dataPath + directory.Substring(6, directory.Length - 6));}}}static string Command(string cmd){var p = new Process();p.StartInfo.FileName = "/bin/bash";p.StartInfo.Arguments = "-c \" " + cmd + " \"";p.StartInfo.UseShellExecute = false;p.StartInfo.RedirectStandardOutput = true;p.Start();var output = p.StandardOutput.ReadToEnd();p.WaitForExit();p.Close();return output;}}
Projectウィンドウのファイル選択→右クリック、または左上のAssetsボタンから呼ぶことができる


*int result = DateTime.Compare(date1, date2);
比較

*}
現在時刻が対象先の日付時刻よりも早い場合の処理

*}
現在時刻が対象先の日付時刻よりも遅い場合の処理
Close();アプリケーション終了


*StartCoroutine(TurnEndProcessing());
コルーチンを開始

*IEnumerator TurnEndProcessing ()*{//1.勝敗判定if (CheckAlive()) {yield break;}//2.同速チェックと並び替えbool isSame = Sort ();//3.天候解除if (WeatherProcessing ()) {yield return new WaitForSeconds (1f);}/* 中略 *///4.素早さが同じ場合は順番をシャッフルするShuffle (isSame);//5.毒ダメージforeach (var item in SortedUnits) {if (PoizonProcessing (item)) {yield return new WaitForSeconds (0.5f);}}/* 中略 *///6.勝敗判定if (CheckAlive()) {yield break;}//7.交代の有無を確認if(CheckChange()){//交代の処理CharacterChange();} else {//ターン開始に移る処理TurnStart();}}
コルーチン処理

*bool isSame = Sort ();
2.同速チェックと並び替え

*Shuffle (isSame);
4.素早さが同じ場合は順番をシャッフルする

*CharacterChange();*} else {
交代の処理

*TurnStart();
ターン開始に移る処理

*}
myPokemonとenemyPokemonの素早さを比較
素早さが高い順にSortedPokemonsにAddする
素早さが同じ場合はtrue,それ以外はfalseを返す

*}
素早さが同じ場合は順番のシャッフルを行う
素早さが同じでない場合は何もしない

*}
天候解除の有無を判定する
天候解除ありの場合はエフェクトやUI表示を更新してtrueを返す
それ以外はfalseを返す

*}
pokemonが瀕死状態ならfalseを返して終了する
pokemonが毒状態ならエフェクトと毒ダメージの処理を行う
それ以外はfalseを返す

*}
対戦の勝敗判定を行う
勝ちまたは負けの判定が出た場合はtrueを返す
それ以外はfalseを返す

*}
交代の有無を判定して交代が必要な場合はtrueを返す

*}
ポケモンの交代の必要があれば交代画面に映る

*}
ターン開始時に移る


*var nums = new List<int>();
nums は、_Solveの作業用領域

*private IEnumerable<int[]> _Solve(List<int> nums) {if (IsRight(nums)) {if (nums.Count() == 9) {// 解が求まったyield return nums.ToArray();} else {for (int i = 1; i <= 9; i++) {if (nums.Contains(i))continue;// i をリストに入れて試すnums.Add(i);// _Solveを再帰的に呼び出す。foreach (var ans in _Solve(nums))yield return ans.ToArray();// 次のiを試すために、iをリストから削除する。nums.Remove(i);}}}// 現在のnumsでの試行が終了した。}
バックトラックにより、解を求める。

*yield return nums.ToArray();*} else {
解が求まった

*nums.Add(i);
i をリストに入れて試す

*foreach (var ans in _Solve(nums))*yield return ans.ToArray();
_Solveを再帰的に呼び出す。

*nums.Remove(i);
次のiを試すために、iをリストから削除する。

*}
現在のnumsでの試行が終了した。

*private bool IsRight(List<int> nums) {
９つ揃っていなくても、途中までを判断する。
完全な誤りならば、falseを返す。そうでないならば、trueを返す
例えば、[4, 9, 1]というリストは、まだ間違いとは言えないので、trueが返る。
これを元に枝刈りをする。

*return true;
まだ、海のものとも山のものともわからない。次を調べる必要があるから、trueを返す。

*return false;
小町リングになっていない

*return true;
現時点で、小町リングになっている

*nums.Length ==9 ならば、5つの値(合計)が列挙される。private IEnumerable<int> GetSums(List<int> nums) {
numsの値をもとに、各リング内の合計を求める。

*private IEnumerable<int> GetSums(List<int> nums) {int length = nums.Count;if (length < 2)yield break;yield return nums[0] + nums[1];for (int i = 3; i < length; i += 2) {yield return nums[i - 2] + nums[i - 1] + nums[i];}if (length == 9)yield return nums[7] + nums[8];}
nums.Length ==9 ならば、5つの値(合計)が列挙される。


*var client = new MongoClient("mongodb:
localhost:27017");

*using (var tarWriter = WriterFactory.Open(tarMs, SharpCompress.Common.ArchiveType.Tar,new WriterOptions(SharpCompress.Common.CompressionType.None) { LeaveStreamOpen = true }))
Create Tar

*using (var outfs = new FileStream(destFileName, FileMode.Create, FileAccess.Write))using (var gzWriter = WriterFactory.Open(outfs, SharpCompress.Common.ArchiveType.GZip,new WriterOptions(SharpCompress.Common.CompressionType.GZip) { LeaveStreamOpen = true })){gzWriter.Write(tarEntryName, tarMs, DateTime.Now);
Compress Gzip

*using (var tarWriter = WriterFactory.Open(tarMs, SharpCompress.Common.ArchiveType.Tar,new WriterOptions(SharpCompress.Common.CompressionType.None) { LeaveStreamOpen = true }))
Create Tar

*using (var outfs = new FileStream(destFileName, FileMode.Create, FileAccess.Write))using (var xzStream = new XZOutputStream(outfs)){var buf = new byte[1 * 1024 * 1024];
Compress XZ


*b = new sample();
インスタンスを作成


*void Update()*{if (Input.GetKeyDown(KeyCode.Space)){_behaviour.Move(this);}}
Update is called once per frame


*data += vb.ToString() + ",";
12


*Console.WriteLine(x > y ? x : y);
2


*client.BaseAddress = new Uri("https:
spla2.yuu26.com");


*case "tstz":
参考：http:www.npgsql.org/doc/types/datetime.html

*result.AppendLine("--- SELECT *　FROM テーブル ---");
SELECT *　FROM テーブル(各3回)

*result.AppendLine("--- SELECT *　FROM テーブル ORDER BY tstz---");
SELECT * FROM テーブル ORDER BY tstz(各5回)

*System.IO.File.WriteAllText("indexbench.txt", result.ToString());
結果の保存


*}
選択時にSelectAllにする場合はこちら
AssociatedObject.Select(0, AssociatedObject.Text.Length);

*AssociatedObject.Text = Provider.ToDisplayString();
ToDisplayString:表示できる形式で書式設定された文字列

*if (Provider.Replace(e.Text, position))*position++;
上書きモード

*if (Provider.InsertAt(e.Text, position))*position++;
挿入モード

*if (Provider.ToDisplayString().Equals(AssociatedObject.Text))*return;
同じときは更新なし


*request.RequestFormat = DataFormat.Json;
パラメータやアップロードファイルなどあればセットする
リクエストBodyの形式を指定

*request.AddParameter("application/json", jsonString, ParameterType.RequestBody);
Body部分にJson文字列をセット
名前部分にapplication/jsonを指定し、パラメータタイプにRequestBodyを指定


*BeginInvoke(d, new object[] { text });
<--ここを変える


*var format = img.Format;
画像フォーマット


*if (view.distance <= 0.0f)*return;
can't draw


*a += new SomeDelegate(dt2.FuncC);
FuncCを追加

*a(10);
引数を渡す場合は同じ型でなければならない


*private char charname;
文字の名前

*private String fontdata;
大きな文字を表現する文字列

*public void print()*{Console.Write(fontdata);}
大きい文字を表示

*private Hashtable pool = new Hashtable();
既に作ったBigCharのインスタンスを管理

*private static BigCharFactory bigCharFactory = new BigCharFactory();
Singletonパターン

*public BigChar getBigChar(char charname)*{BigChar bigChar = (BigChar)pool["" + charname];if (bigChar == null){bigChar = new BigChar(charname);pool.Add("" + charname, bigChar);}return bigChar;}
BigCharのインスタンス作成

*private BigChar[] bigchars;
「大きな文字」の配列

*public void print()*{for(int i=0; i < bigchars.Length; i++){bigchars[i].print();}}
表示


*var result = await commands.ExecuteAsync(context, argPos, services);
実行


*if (!Item1Value.HasValue) return null;
null値の場合はGet~すると死ぬのでここで返す

*// JsonValueKind.Object => new[] {  JsonSerializer.Deserialize<HogeHoge>(ItemValue.Value.GetRawText()) },
object,arrayのコード例


*this.label1.Text = Common.Class1.CreateIntroduction("寿司");
私の好きなものは寿司です。

*this.label1.Text = Common.Class1.CreateIntroduction("野球");
私の好きなものは野球です。

*this.label1.Text = Common.Class1.CreateIntroduction("寿司", isShout);
私の好きなものは寿司です。/ オレの好きなものは寿司だぜ！！

*return CreateIntroductionShout(strFavorite);
シャウト版

*return CreateIntroduction(strFavorite);
シャウトしない版


*int NumberOfDice=0;
ダイス判定処理


*public override int SaveChanges()*{var ret = base.SaveChanges();HttpRuntime.Cache.Remove(cacheKey);return ret;}
作成更新削除があったらこのメソッドでキャッシュをクリアします。

*}
Index 等の実装・・・


*this.speed *= 0.98f;
徐々に減速

*GetComponent<AudioSource>().Play();
効果音再生


*}
ローカル変数が優先され、999のダメージを与えることになる。


*this.label1.Text = Common.Class1.CreateIntroduction("野球");
Commonプロジェクトの関数を使えるようになった

*using Common;
Usingディレクティブを使った場合

*this.label1.Text = Class1.CreateIntroduction("野球");
「Common.」は書かなくてもCommonの中のClass1なんだと分かってくれる


*void Start () {SayHello();}
Use this for initialization

*void Start () {CallName("Tom");}
Use this for initialization

*void Start () {int answer;answer = Add(2, 3);Debug.Log(answer);}
Use this for initialization


*List<Task> tasks = new List<Task>(5);
5スレッド使う


*Vector3 RotCenter = new Vector3(1, 2, 3);
回転の中心を（1,2,3)とする


*int v = PlayerPrefs.GetInt("Test");
testというキーで読み出し


*using UnityEngine.UI;
ここ注意

*float m_X;
変数設定

*public GameObject target;
知りたい座標のGaeObjectの設定

*void Start () {}
Use this for initialization

*void Update () {//それぞれに座標を挿入m_X = target.transform.position.x;m_Y = target.transform.position.y;m_Z = target.transform.position.z;//テキストに表示this.GetComponent<Text> ().text = "X座標は" + m_X.ToString() + "\nY座標は" + m_Y.ToString() + "\nZ座標は" + m_Z.ToString();}
Update is called once per frame

*m_X = target.transform.position.x;*m_Y = target.transform.position.y;
それぞれに座標を挿入

*this.GetComponent<Text> ().text = "X座標は" + m_X.ToString() + "\nY座標は" + m_Y.ToString() + "\nZ座標は" + m_Z.ToString();
テキストに表示


*g3.GetComponent<RectTransform>().sizeDelta = new Vector2(t.preferredWidth, t.preferredHeight);
2回必要


*SearchCommand?.ChangeCanExecute();
検索コマンドの実行可否 更新

*WindowLoaded = Command.Factory.CreateSync<RoutedEventArgs>(e =>{IsBusy = false;TargetPath = @"C:\ProgramData";PathList = new ObservableCollection<string>();
ウィンドウ起動

*SearchCommand = CommandFactory.Create(executeAsync: async () =>
検索

*return !string.IsNullOrWhiteSpace(TargetPath);
パスが空のときは無効

*await Task.Delay(100);
すぐ終わらないよう少し待つ

*yield return dir;
1つ返す

*return true;
処理成功したらtrue


*var encode = new UTF8Encoding(false);
BOMなしUTF8

*using (var fs = new FileStream("jyugemu.msg.lz4", FileMode.Create, FileAccess.Write)){var binary = LZ4MessagePackSerializer.Serialize<string>(str);
MessagePackのLZ4

*var msgpackBinary = MessagePackSerializer.Serialize<dynamic>(data);
MessagePackでPack（匿名型もいける）

*using (var fs = new FileStream("frameformat.msg.lz4", FileMode.Create, FileAccess.Write))*using (var lz4Stream = LZ4Stream.CreateCompressor(fs, LZ4StreamMode.Write))
IonKiwi.lz4.netでFrame Fomat圧縮

*byte[] decompBinary;
IonKiwi.lz4.netでFrame Fomat解凍

*var obj = MessagePackSerializer.Deserialize<dynamic>(decompBinary);
MessagePackのUnpack

*,,,
id:1 str:じゅげむ
id:2 str:じゅげむ
id:3 str:ごこうのすりきれ
id:4 str:かいじゃりすいぎょの
id:5 str:すいぎょうまつ
id:6 str:うんらいまつ
id:7 str:ふうらいまつ
id:8 str:くうねるところにすむところ
id:9 str:やぶらこうじのぶらこうじ
id:10 str:ぱいぽ
id:11 str:ぱいぽ
id:12 str:ぱいぽのしゅーりんがん
id:13 str:しゅーりんがんのぐーりんだい
id:14 str:ぐーりんだいのぽんぽこぴーの
id:15 str:ぽんぽこなーの
id:16 str:ちょうきゅうめいのちょうすけ


*Debug.Log(objectName);
オブジェクト名をコンソールに表示


*).Subscribe(x => Debug.Log('OK'))
NG


*public static void Main(string[] args)*{var alphabets = "ABC";foreach (var (alphabet, index) in alphabets.WithIndex()){Console.WriteLine("{0} => {1}", index, alphabet);}}
利用例


*self.level = 1;
これはコンストラクタをサボってる

*public static List<QuestResult> All { get; set; }
ロードは後で書く


*if (Controller.isGrounded && FallSpeed <= 0)*FallSpeed = Physics.gravity.y * (GravityModifier * 0.002f);
calculate gravity influence


*await Conversation.SendAsync(activity, () => new Dialogs.RootDialog());
RootDialogとなっている部分を上で作成したクラス名に変更

*protected override async Task RespondFromQnAMakerResultAsync(IDialogContext context, IMessageActivity message, QnAMakerResults result)*{var bestAnswer = result.Answers.First();await context.PostAsync($"{bestAnswer.Answer}");if (result.Answers.Count > 1){var sb = new StringBuilder();sb.Append("以下の情報も関連しているかもしれません");int count = 0;foreach (var answer in result.Answers.Skip(1)){count += 1;sb.Append($"\n\n{count}.{answer.Answer}\n\n");}await context.PostAsync(sb.ToString());}}
複数の解答を返したい場合

*protected override async Task QnAFeedbackStepAsync(IDialogContext context, QnAMakerResults result)*{if (!IsConfidentAnswer(result)){var sb = new StringBuilder();sb.Append("以下の情報が関連しているかもしれません");int count = 0;foreach (var answer in result.Answers){count += 1;sb.Append($"\n\n{count}.{answer.Answer}\n\n");}await context.PostAsync(sb.ToString());}}
スコアが低い解答しか得られない場合


*new Idol("安部菜々", 17),
ウーサミン！

*// dicの中身はKeyValuePair<int, string>型で*// [0] {[17, 安部菜々]}
あくまでLINQによる解決策

*// [0] {[17, 安部菜々]}
dicの中身はKeyValuePair<int, string>型で

*// [1] {[12, 櫻井桃華]}
[0] {[17, 安部菜々]}

*// [2] {[22, 相原雪乃]}
[1] {[12, 櫻井桃華]}

*var dic = list.GroupBy(idol => idol.Value)
[2] {[22, 相原雪乃]}


*mPlayer.time = 15f;
こんな感じで再生途中再生したい時間を


*Console.WriteLine(string.Join(", ", z1));
0, 1, 2

*,,,
[-1, 1, 2], [10, 11, 12] ← 2次元の場合はディープコピーにならない

*var masterEnemy = new[]{new {Id = 1, Name = "スライム", MaxHp = 10},new {Id = 2, Name = "ドラキー", MaxHp = 15},new {Id = 3, Name = "スライムベス", MaxHp = 20}};
匿名型でマスターデータを定義

*Func<int[], dynamic> encount = (idlist) =>*{//Battleのオブジェクト作成はこれだけvar battle = idlist.Select(x => masterEnemy.Where(y => y.Id == x).FirstOrDefault()).OrderBy(x => x.Id).Select(x => new { Id = x.Id, Name = x.Name, NowHp = x.MaxHp, MaxHp = x.MaxHp }).ToArray();//Consoleに表示foreach (var x in battle) Console.WriteLine($"{x.Name} があらわれた！ HP:{x.NowHp}/{x.MaxHp}");return battle;};
匿名型を返せないのでdynamicで

*var battle = idlist.Select(x => masterEnemy.Where(y => y.Id == x).FirstOrDefault())
Battleのオブジェクト作成はこれだけ

*,,,
スライム があらわれた！ HP:10/10
ドラキー があらわれた！ HP:15/15
ドラキー があらわれた！ HP:15/15
スライムベス があらわれた！ HP:20/20


*link_names = "1"
メンションを有効にする


*List<string> uidList = client.GetMessageUids();
全メールのUIDL取得

*Message message = client.GetMessage(i);
メール情報取得

*fromAddress = message.Headers.From.MailAddress.Address;
差出人メールアドレス取得

*subject = message.Headers.Subject;
件名取得

*uid = client.GetMessageUid(i);
UID取得

*var plainText = message.FindFirstPlainTextVersion();
本文取得

*Console.WriteLine("UID={0} ,FROM={1} ,SUBJECT={2}", uid, fromAddress, subject);
取得情報出力

*}*catch (Exception e) {Console.WriteLine(e.Message);}
Console.WriteLine("BODY={0}", body);


*const int Port = 50051;
サーバーを起動する処理、ここから

*Channel channel = new Channel("127.0.0.1:50051", ChannelCredentials.Insecure);
サーバーを起動する処理、ここまで

*server.ShutdownAsync().Wait();
起動したサーバーをシャットダウンする処理、ここから

*return reply;
起動したサーバーをシャットダウンする処理、ここまで

*class GreeterImpl : Greeter.GreeterBase*{// Server side handler of the SayHello RPCpublic override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context){return Task.FromResult(new HelloReply { Message = "Hello " + request.Name });}}
サーバーサイドの処理、ここから

*public override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context)*{return Task.FromResult(new HelloReply { Message = "Hello " + request.Name });}
Server side handler of the SayHello RPC

*}
サーバーサイドの処理、ここまで

*return Task.FromResult(new HelloReply { Message = "Hello Server " + request.Name });
"Hello "から"Hello Server "に文字列を修正


*var url = "http:
〇〇.comuploadfile.php";


*BitmapDecoder decoder = BitmapDecoder.Create(stream,BitmapCreateOptions.PreservePixelFormat,BitmapCacheOption.OnLoad);
画像をデコード

*double scaleX = (double)scaledWidth / decoder.Frames[0].PixelWidth;
拡大/縮小したイメージを生成する

*bmp = new TransformedBitmap(decoder.Frames[0], new ScaleTransform(scale, scale));*}
TransformedBitmapをそのまま保持する

*bmp = new WriteableBitmap(decoder.Frames[0]);
原寸でイメージを生成する

*bmp = new WriteableBitmap(new TransformedBitmap(decoder.Frames[0], new ScaleTransform(scale, scale)));*,,,
生成したTransformedBitmapから再度WritableBitmapを生成する


*var seq = new List<Foo> {new Foo { Id = 2 }, new Foo { Id = 0 }, new Foo { Id = 1 },};
Fooのリストを生成

*var query = from x in seqselect x.Id;
Fooのリストに対しクエリを発行

*Console.WriteLine ("--- loop start! ---");*foreach (var q in query) {Console.WriteLine ("{0}", q);}
ループ開始


*var element = (System.Windows.IInputElement)param;
マウス座標取得


*Console.WriteLine(Config.Mossari.Get());
"fusafusa"と出力


*SFML.Window.Styles.Close
ウィンドウ右上に×ボタンを設置

*window.Closed += (sender, e) => window.Close();
window.Closedイベントで、
×ボタンが押されたときの処理を追加できる

window.Close関数を呼ぶとウィンドウを閉じる

*window.DispatchEvents();
ウィンドウのイベント処理を実行
（必ずこれを実行すること！）

*var image = new Image("0.png");
画像を読み込み

*var texture = new Texture(image);
画像をテクスチャに変換

*var sprite = new Sprite(texture);*while (window.IsOpen) {window.DispatchEvents();//ウィンドウを黒で塗りつぶすwindow.Clear();sprite.Position = new SFML.System.Vector2f(20, 20);//画像の描画window.Draw(sprite);//描画したものを表示window.Display();}
描画用オブジェクトを作成

*window.Clear();
ウィンドウを黒で塗りつぶす

*window.Draw(sprite);
画像の描画

*window.Display();
描画したものを表示

*var font = new Font(fontName);
フォント読み込み

*var text = new Text(textStr, font);*while (window.IsOpen) {window.DispatchEvents();//ウィンドウを黒で塗りつぶすwindow.Clear();text.Position = new SFML.System.Vector2f(20, 20);//テキストを描画window.Draw(text);//描画したものを表示window.Display();}
テキスト描画用オブジェクトを作成

*window.Clear();
ウィンドウを黒で塗りつぶす

*window.Draw(text);
テキストを描画

*window.Display();
描画したものを表示

*var font = new Font(fontName);*foreach (var i in textStr) {//フォントテクスチャに、//指定した文字を書き込むfont.GetGlyph(i, textSize, false);}
フォント読み込み

*font.GetGlyph(i, textSize, false);
フォントテクスチャに、
指定した文字を書き込む

*var texture = font.GetTexture(textSize);
フォントからテクスチャを作成

*window.Clear();*for (var i = 0; i < textStr.Length; i++) {//表示したい文字を描画するためのデータを取得var glyph = font.GetGlyph(textStr[i], textSize, false);sprite.Position = new SFML.System.Vector2f(20 + textSize * i, 20);sprite.TextureRect = glyph.TextureRect;//文字列を表示window.Draw(sprite);}
ウィンドウを黒で塗りつぶす

*var glyph = font.GetGlyph(textStr[i], textSize, false);
表示したい文字を描画するためのデータを取得

*window.Draw(sprite);
文字列を表示

*window.Display();
描画したものを表示

*var music = new Music("0.wav");
音再生用オブジェクトの作成

WAVファイルとOGGファイルの再生が
できることを確認

MIDとMP3の再生は残念ながらできない
（読み込み時にエラーが出る）

*music.Loop = true;
Loopプロパティでループ再生できるかどうかを指定できる
（ただし、Play関数を呼ぶ前に指定しないと反映されない）
初期値はfalse

falseならループしない
trueならループする

*music.Play();*while (window.IsOpen) {window.DispatchEvents();}
音再生の開始

*window.SetFramerateLimit(fps);
フレームレートの指定
引数はuint型

（この例では60 Fpsを指定）

*window.Display();
この関数を使うと、
window.SetFramerateLimit関数で指定したFpsになる

（この例では60 Fpsになる）

*window.Draw(sprite);
既定のスプライトを表示

*window.Draw(spriteTester);
自作スプライトを表示

*TextureDrawer.Draw(window, texture, 20, 100);
スプライトを使わずに画像を表示

*static class TextureDrawer {public　static Vertex[] Vertexs { get; } = new Vertex[4];public static void Draw(RenderTarget target,Texture texture, float x, float y){//描画データの指定var transform = Transform.Identity;//描画範囲を指定var left = x;var right = x + texture.Size.X;var top = y;var bottom = y + texture.Size.Y;//左上Vertexs[0].Position = new Vector2f(left, top);Vertexs[0].TexCoords = new Vector2f(0, 0);//左下Vertexs[1].Position = new Vector2f(left, bottom);Vertexs[1].TexCoords = new Vector2f(0, texture.Size.Y);//右上Vertexs[2].Position = new Vector2f(right, top);Vertexs[2].TexCoords = new Vector2f(texture.Size.X, 0);//右下Vertexs[3].Position = new Vector2f(right, bottom);Vertexs[3].TexCoords = new Vector2f(texture.Size.X, texture.Size.Y);for (var i = 0; i < Vertexs.Length; i++) {//new Color(255, 255, 255, 255)//で画像の色変更なしVertexs[i].Color = new Color(255, 255, 255, 255);}var states = default(RenderStates);//これも指定しないと表示されないstates.BlendMode = BlendMode.Alpha;//描画データをstatesに指定するstates.Transform = transform;//テクスチャをstatesに指定する////states.Textureがnullの場合は矩形が表示されるstates.Texture = texture;//描画開始target.Draw(Vertexs, 0, (uint)Vertexs.Length, PrimitiveType.TrianglesStrip, states);}}
スプライトを使わずに画像を表示するためのクラス

*var transform = Transform.Identity;*//描画範囲を指定
描画データの指定

*var left = x;
描画範囲を指定

*Vertexs[0].Position = new Vector2f(left, top);
左上

*Vertexs[1].Position = new Vector2f(left, bottom);
左下

*Vertexs[2].Position = new Vector2f(right, top);
右上

*Vertexs[3].Position = new Vector2f(right, bottom);
右下

*Vertexs[i].Color = new Color(255, 255, 255, 255);
で画像の色変更なし

*states.BlendMode = BlendMode.Alpha;
これも指定しないと表示されない

*states.Transform = transform;*//テクスチャをstatesに指定する
描画データをstatesに指定する

*states.Texture = texture;
テクスチャをstatesに指定する

states.Textureがnullの場合は矩形が表示される

*target.Draw(Vertexs, 0, (uint)Vertexs.Length, PrimitiveType.TrianglesStrip, states);
描画開始

*sealed class SpriteTester : Drawable {public Vertex[] Vertexs { get; } = new Vertex[4];public Texture Texture { get; }public Transform Transform { get; set; }public float X { get; set; }public float Y { get; set; }public float Width { get; set; }public float Height { get; set; }public float Left => X;public float Right => X + Width;public float Top => Y;public float Bottom => Y + Height;public SpriteTester(Texture texture) {//テクスチャの指定Texture = texture;//描画データの指定Transform = Transform.Identity;Width = Texture.Size.X;Height = Texture.Size.Y;}public void Draw(RenderTarget target, RenderStates states) {//左上Vertexs[0].Position = new Vector2f(Left, Top);Vertexs[0].TexCoords = new Vector2f(0, 0);//左下Vertexs[1].Position = new Vector2f(Left, Bottom);Vertexs[1].TexCoords = new Vector2f(0, Height);//右上Vertexs[2].Position = new Vector2f(Right, Top);Vertexs[2].TexCoords = new Vector2f(Width, 0);//右下Vertexs[3].Position = new Vector2f(Right, Bottom);Vertexs[3].TexCoords = new Vector2f(Width, Height);for (var i = 0; i < Vertexs.Length; i++) {//new Color(255, 255, 255, 255)//で画像の色変更なしVertexs[i].Color = new Color(255, 255, 255, 255);}//描画データをstatesに指定するstates.Transform = Transform;//テクスチャをstatesに指定する////states.Textureがnullの場合は矩形が表示されるstates.Texture = Texture;//描画開始target.Draw(Vertexs, 0, (uint)Vertexs.Length, PrimitiveType.TrianglesStrip, states);}}
自作スプライト

*Texture = texture;
テクスチャの指定

*Transform = Transform.Identity;*Width = Texture.Size.X;
描画データの指定

*Vertexs[0].Position = new Vector2f(Left, Top);
左上

*Vertexs[1].Position = new Vector2f(Left, Bottom);
左下

*Vertexs[2].Position = new Vector2f(Right, Top);
右上

*Vertexs[3].Position = new Vector2f(Right, Bottom);
右下

*Vertexs[i].Color = new Color(255, 255, 255, 255);
で画像の色変更なし

*states.Transform = Transform;*//テクスチャをstatesに指定する
描画データをstatesに指定する

*states.Texture = Texture;
テクスチャをstatesに指定する

states.Textureがnullの場合は矩形が表示される

*target.Draw(Vertexs, 0, (uint)Vertexs.Length, PrimitiveType.TrianglesStrip, states);
描画開始


*ScriptManager.ScriptResourceMapping.AddDefinition("vue", null, scriptRefVue);
ここで指定した名前がマッピングされる


*Console.WriteLine(result);
200


*UnityWebRequest liverequest = UnityWebRequest.Get(urisample);
testURI + apikey);

*var mjson = (IDictionary)MiniJSON.Json.Deserialize(jsontext);
MiniJSON　つかうー！！！！

*videoId = (string)sid["videoId"];
videoIdを取得

*var searchChannel = youtubeAPIbase + channnelSearch + videoId + "&key=" + apikey;
ChatIdを取得しにいくよ！！

*chatId = (string)clad["activeLiveChatId"];
chatIdを取得

*var chatURI = youtubeAPIbase + chatURIUp + chatId + pagetoken + nextPageTokenstr + chatURIbottom2 + apikey;
チャットを取りに行く！！！

*}
Youtubeへ接続しに行ってます

*}
videoIdを基に、chatIdを探しに行っています。

*}
chatIdを基に、コメントを取得します。

*}
StartCoroutine(GetComment()); で、コメントを再取得しにいっています。

*nextPageTokenstr = (string)commentlogjson["nextPageToken"];
中略

*var chatURI = youtubeAPIbase + chatURIUp + chatId + pagetoken + nextPageTokenstr + chatURIbottom2 + apikey;
チャットを取りに行く！！！

*GameObject cvn = Instantiate(canvas);
中略
使うときに生成

*var citems = (IList)commentlogjson["items"];
パーッ寿司ながら中身取り出しにいく。

*cvn.transform.Find("Description").gameObject.GetComponent<Text>().text = message;*var author = (IDictionary)cslsd["authorDetails"];
本文を取得

*cvn.transform.Find("Name").gameObject.GetComponent<Text>().text = dispName;*,,,
名前をつける


*textWords[i, n] = tempWords[n];
2次配列textWordsにカンマごとに分けたtempWordsを代入していく


*var mjson = (IDictionary)MiniJSON.Json.Deserialize(jsontext);
MiniJSON　つかうー！！！！

*videoId = (string)sid["videoId"];
videoIdを取得


*builder.EntitySet<Customer>("Customers");
エンティティを追加

*config.Count().Filter().OrderBy().Expand().Select().MaxTop(null);
オプションを有効化 ↓この行を追加（必要なものだけでOK）

*config.MapODataServiceRoute(routeName: "ODataRoute",routePrefix: null,model: builder.GetEdmModel());



*_easyHttpRPC = new EasyHttpRPC(this.GetCancellationTokenOnDestroy());
newするとサーバが起動する.CancellationTokenが必要.
任意でポート番号も指定できる.デフォルトは1234.

*_easyHttpRPC.RegisterRPC(nameof(Instantiate), Instantiate);
外から呼び出すメソッドを登録する.

*private async Task<string> Instantiate(NameValueCollection arg)
引数のNameValueCollectionにはGetのパラメータがそのまま入っている.
Taskなので終了まで待ってからレスポンスを返せる.


*{
出力

*string rec = p.ToString() + "," + a.ToString() + "," + b.ToString() + "," + a_mul_b.ToString() + ",";
二乗誤差
double dE = Y - a_mul_b;計算省略のため二乗誤差微分後の値
記録

*for (int cl = 0; cl < cell; cl++)
逆伝播
∂E/∂In
double[] dE_dI = new double[cell];
for (int cl = 0; cl < cell; cl++)
{
dE_dI[cl] = 2 * h_in[cl] * w[1][cl, 0] * dE;
}
w-Δw
for (int cl = 0; cl < cell; cl++)
{
w[0][0, cl] = w[0][0, cl] - η * (a * dE_dI[cl]);
w[0][1, cl] = w[0][1, cl] - η * (b * dE_dI[cl]);
}

*string last_rec = new string(',', In + Out + 1);
最終記録

*File.SetAttributes(path, FileAttributes.ReadOnly);
読取専用


*TcpClient tcp = new TcpClient("127.0.0.1", 8081);
InputHostに接続

*private Point GetDisplayPosition(Point p)*{int x = (int)(p.X / image.ActualWidth * displayWidth);int y = (int)(p.Y / image.ActualHeight * displayHeight);return new Point(x, y);}
マウスの位置を端末のタッチ座標に変換


*ms.Position = 0;
Positionが最後に行っているので最初に戻す

*var compressor = new SevenZipCompressor();
メモリに圧縮

*var extractor = new SevenZipExtractor(archiveMemoryStream);
メモリに解凍

*using (var ms = new MemoryStream())using (var sr = new StreamReader(ms)){extractor.ExtractFile(finfo.FileName, ms);
Console.WriteLine(finfo.FileName);


*Console.WriteLine($"(a==1 && a!=2 && a==3) : {a == 1 && a != 2 && a == 3}");
true


*ServiceStack.Text.JsonSerializer.DeserializeFromStream<Data>(sr.BaseStream);
ServiceStackの場合

*}
Jil.JSON.Deserialize<Data>(sr);Jilの場合
Utf8Json.JsonSerializer.Deserialize<Data>(sr.BaseStream);Utf8Jsonの場合

*}
Utf8Json.JsonSerializer.Deserialize<Data>(sr.BaseStream);                                                                                                                               Utf8Json.JsonSerializer.Deserialize<Data>(sr.BaseStream);Utf8Jsonの場合


*chart1.Series.Clear();
Chartには、最初からSeriesが設定されているので削除しておく。


*var platform = new Platform(0);*var device = platform.CreateDevice(0);
面倒だけど必要なこいつらを手軽に用意

*var data = new float[] { 3F, 4.5F, 0F, -4.4F };
いわゆるcl_memを用いたプログラム

*data = new float[] { 3F, 4.5F, 0F, -4.4F };
CL_MEM_COPY_HOST_PTRを利用した場合

*dataSize = sizeof(float) * 4;
CL_MEM_ALLOC_HOST_PTRを使用した場合(unsafeが必要)

*data = new float[] { 3F, 4.5F, 0F, -4.4F };
CL_MEM_USE_HOST_PTRを使用した場合

*dataSize = sizeof(float) * 4;
SVM(unsafeが必要)

*var platform = new Platform(0);*var device = platform.CreateDevice(0);
面倒だけど必要なこいつらを手軽に用意


*== [1, 3, 5, 7, 9]oddsAndEvens[false];
oddsAndEvens[true];

*== [2, 4, 6, 8, 10],,,var items = new[]{new {Name = "A", HasError = false },new {Name = "B", HasError = true },new {Name = "C", HasError = false },new {Name = "D", HasError = true }};
oddsAndEvens[false];

*,,,
指定したキーのデータがなかった時は例外になるので注意
validOrInvalidItems[false].Select(x => x.Name);
== ["A", "C"]
validOrInvalidItems[true].Select(x => x.Name);
== ["B", "D"]


*Input.GetKey("joystick button 5")
Gripのボタンの取得


*{
出力

*string rec = p.ToString() + "," + a.ToString() + "," + b.ToString() + "," + a_mul_b.ToString() + ",";
二乗誤差
double dE = Y - a_mul_b;計算省略のため二乗誤差微分後の値
記録

*double[] dE_dI = new double[cell];
逆伝播
∂E/∂In

*string last_rec = new string(',', In + Out + 1);
最終記録

*File.SetAttributes(path, FileAttributes.ReadOnly);
読取専用


*if(!anim.isPlaying){
<- falseのとき動くかんじにしたかった

*}
実行したい処理


*float timer = 10f;
制限時間をセット

*timer -= Time.deltaTime;
Update()の中などに何度も呼ばれるメソッドの中に記述し、Time.deltaTimeを引きつづける

*float timer = 0f;
(参考)
初期化

*timer += Time.deltaTime;
カウントアップ

*limitTime -= Time.deltaTime;
制限時間との差を取得しつづける

*timerText.text = limitTime.ToString();
文字列に変換して表示

*timerText.text = "Finish";
Finishと表示

*IEnmerator コルーチン関数名(){// 処理1yield return new WaitforSeconds(止めたい秒数);// 処理2}
処理1と処理2の間で任意の秒数待つ

*yield return new WaitforSeconds(止めたい秒数);*// 処理2
処理1

*}
処理2

*public int TIME_LIMIT = 10;
制限時間

*StartCoroutine("Timer");
コルーチンを呼ぶ

*int count = TIME_LIMIT;
変数へ初期値を代入

*timerText.text = count.ToString();
テキストの更新

*yield return new WaitForSeconds(1.0f);
1秒待機

*count--;
カウントを1減らす

*timerText.text = "Finish";
テキストの表示

*TimeSpan timeSpan = DateTime.Now.AddSeconds(3) - DateTime.Now;
これはOK
DateTime.Now.AddSeconds(3)で現在時刻より3秒後 , DateTime.Nowで現在時刻を得られます

*limitTime = DateTime.Now.AddSeconds(3);
現在時刻から3秒後をセット

*timeSpan = LimitTime - DateTime.Now;
現在時刻との差を取得しつづける

*timerText.text = timeSpan.ToString();
文字列に変換して表示

*timerText.text = "Finish";
Finishと表示

*timerText.text = timeSpan.ToString();
デフォルト（例:00.00.04のような表示）

*timerText.text = timeSpan.ToString("s");
s秒（例:4のような表示）

*timerText.text = timeSpan.ToString("ss':'ff");
ss秒mmミリ秒（例:04.37のような表示）

*timerText.text = timeSpan.ToString("ss':'fff");
ss秒mmmミリ秒（例:04.375のような表示）

*timerText.text = dateTime.ToString("ss:ff");
DateTimeだと「:」など文字でないものをシングルクォーテーションで囲まなくてよい
ss秒mmミリ秒（例:04.37のような表示）

*DateTime time = DateTime.Now.AddSeconds(3) - DateTime.Now;
これはダメ


*public class ImeStatus : IMessageFilter
ウィンドウメッセージを処理するために
IMessageFilter インターフェイスを実装します。

*Application.AddMessageFilter(this);
コンストラクター内で
メッセージフィルターとして自身を登録します。

*public bool PreFilterMessage(ref Message m)
アプリケーションがウィンドウメッセージを処理する前に
呼び出されます。

*Compositing = true;
日本語入力の開始

*Compositing = false;
日本語入力の終了


*{
列見出し

*Random cRandom = new Random();
0.0 以上 1.0 以下の乱数を取得

*double a = cRandom.NextDouble();
値設定

*double Y = a * w[0] + b * w[1];
順伝播

*using (StreamWriter sw = new StreamWriter(path, true, Encoding.Unicode))
最小二乗誤差
double dE = Y - a_sub_b;計算省略のため二乗誤差微分後の値
記録

*w[0] = w[0] - (a * dE);
逆伝播

*using (StreamWriter sw = new StreamWriter(path, true, Encoding.Unicode)){sw.Write(",,," +w[0].ToString() + "," + w[1].ToString() + "," +"," +Environment.NewLine);
最終記録

*File.SetAttributes(path, FileAttributes.ReadOnly);
読取専用


*gamer.Bet();
ゲームを進める


*var client = new RestClient();
クライアント＆リクエストの作成

*client.BaseUrl = new Uri("リクエスト先のURLをここに指定する");
URLの設定

*request.Method = Method.POST;
メソッド、パラメータの指定

*request.AddFile("ファイルパラメータ名", "ファイルパス", "ContentType");
ParameterTypeはいろいろあるが、GETとPOSTで特に指定なく
stringパラメータを設定する場合は、GetOrPost
ファイルをアップロードする場合

*var response = client.Execute(request);
ContentTypeは拡張子などから適切なものを選ぶ
リクエスト送信

*File.WriteAllBytes("出力先のパス", response.RawBytes);
レスポンスがファイルなどで、復元したい場合

*bool isOK = response.StatusCode == HttpStatusCode.OK;
レスポンスのステータスコードが欲しいなどの場合


*[RequireComponent(typeof(TestClassB))]
必要なコンポーネントを定義

*[RequireComponent(typeof(TestClassB))]
必要なコンポーネントを定義


*{
列見出し

*Random cRandom = new Random();
0.0 以上 1.0 以下の乱数を取得

*double a = cRandom.NextDouble();
値設定

*double Y = a * w[0] + b * w[1];
順伝播

*using (StreamWriter sw = new StreamWriter(path, true, Encoding.Unicode))
最小二乗誤差
double dE = Y - a_add_b;計算省略のため二乗誤差微分後の値
記録

*w[0] = w[0] - (a * dE);
逆伝播

*using (StreamWriter sw = new StreamWriter(path, true, Encoding.Unicode)){sw.Write(",,," +w[0].ToString() + "," + w[1].ToString() + "," +"," +Environment.NewLine);
最終記録

*File.SetAttributes(path, FileAttributes.ReadOnly);
読取専用


*var request = new HttpRequestMessage(HttpMethod.Get, "https:
qiita.comtoryuneko");


*new UriTemplateAction("住所を送る","line:
nvlocation")

*replyMessage = new TemplateMessage("menu", new ButtonsTemplate(title: "注文",text: "毎度！注文ですね。何にしましょう？",actions: new List<ITemplateAction>(){
注文だがメニューがわからない場合はメニューをボタンで提示


*"http:
localhost:8080");


*using System;
IntPtr型を使用するのに必要

*using System.Runtime.InteropServices;
Dllの読み込みに必要

*[DllImport("DllForDebug")]
Dll内の関数を宣言

*void Start()*{Debug.Log(add_b())}
Use this for initialization

*void Update()*{}
Update is called once per frame


*using System;
IntPtr型を使用するのに必要

*using System.Runtime.InteropServices;
Dllの読み込みに必要

*[DllImport("DllForDebug")]
Dll内の関数を宣言

*void Start()*{Loop();}
Use this for initialization

*void Update()*{Debug.Log(ReturnA());}
Update is called once per frame

*using System;
IntPtr型を使用するのに必要

*using System.Runtime.InteropServices;
Dllの読み込みに必要

*[DllImport("DllForDebug")]
Dll内の関数を宣言

*void Start()*{}
Use this for initialization

*void Update()*{LoopNotToUseWhile();Debug.Log(ReturnA());}
Update is called once per frame

*using System;
IntPtr型を使用するのに必要

*using System.Runtime.InteropServices;
Dllの読み込みに必要

*[DllImport("DllForDebug")]
Dll内の関数を宣言

*void Start()*{ResetConstants();}
Use this for initialization

*void Update()*{LoopNotToUseWhile();Debug.Log(ReturnA());}
Update is called once per frame


*using System;
IntPtr型を使用するのに必要

*using System.Runtime.InteropServices;
Dllの読み込みに必要

*[DllImport("DllForDebug")]
Dll内の関数を宣言

*void Start()*{int i = 0;// 格納したい配列先int[] arrInt = new int[5];float[] arrFloat = new float[5];char[] arrChar = new char[5];// 配列の先頭ポインタをIntPtr型の変数にそれぞれ格納するIntPtr ptrInt = ReturnIntArray();IntPtr ptrFloat = ReturnFloatArray();IntPtr ptrChar = ReturnCharArray();// コピーMarshal.Copy(ptrInt, arrInt, 0, 5);Marshal.Copy(ptrFloat, arrFloat, 0, 5);Marshal.Copy(ptrChar, arrChar, 0, 5);// Logfor (i = 0;i <=4; i++){Debug.Log(arrInt[i]);Debug.Log(arrFloat[i]);Debug.Log(arrChar[i]);}}
Use this for initialization

*int[] arrInt = new int[5];
格納したい配列先

*IntPtr ptrInt = ReturnIntArray();
配列の先頭ポインタをIntPtr型の変数にそれぞれ格納する

*Marshal.Copy(ptrInt, arrInt, 0, 5);
コピー

*void Update()*{}
Update is called once per frame


*cmd.InsertAllWithPrepared(array);
ここがInsertAllからInsertAllWithPreparedに変更

*var sb = new StringBuilder();
SQLite3.7.11以降可能な書き方＋プリペアドステートメント
プリペアドステートメント

*command.Parameters.Clear();
パラメーター追加


*extendStyle &= ~WS_EX_TRANSPARENT;
フラグを消す

*var handle = new WindowInteropHelper( this ).Handle;
WindowHandle(Win32) を取得

*var hwndSource = HwndSource.FromHwnd( handle );
Alt + F4 を無効化

*handled = true;
処理済みにセットする
(Windowは閉じられなくなる)


*double[] deltaE = new double[] { Y0_out - alpha, Y1_out - beta };
計算省略のため二乗誤差微分後の値

*using (StreamWriter sw = new StreamWriter(path, true, Encoding.Unicode)){sw.Write(a.ToString() + "," + b.ToString() + "," + c.ToString() + "," + d.ToString() + "," +alpha.ToString() + "," + beta.ToString() + "," +w[0][0, 0].ToString() + "," + w[0][0, 1].ToString() + "," + w[0][0, 2].ToString() + "," + w[0][0, 3].ToString() + "," +w[0][1, 0].ToString() + "," + w[0][1, 1].ToString() + "," + w[0][1, 2].ToString() + "," + w[0][1, 3].ToString() + "," +w[0][2, 0].ToString() + "," + w[0][2, 1].ToString() + "," + w[0][2, 2].ToString() + "," + w[0][2, 3].ToString() + "," +w[0][3, 0].ToString() + "," + w[0][3, 1].ToString() + "," + w[0][3, 2].ToString() + "," + w[0][3, 3].ToString() + "," +h_net[0][0].ToString() + "," + h_out[0][0].ToString() + "," +h_net[0][1].ToString() + "," + h_out[0][1].ToString() + "," +h_net[0][2].ToString() + "," + h_out[0][2].ToString() + "," +h_net[0][3].ToString() + "," + h_out[0][3].ToString() + "," +w[1][0, 0].ToString() + "," + w[1][0, 1].ToString() + "," + w[1][0, 2].ToString() + "," + w[1][0, 3].ToString() + "," +w[1][1, 0].ToString() + "," + w[1][1, 1].ToString() + "," + w[1][1, 2].ToString() + "," + w[1][1, 3].ToString() + "," +w[1][2, 0].ToString() + "," + w[1][2, 1].ToString() + "," + w[1][2, 2].ToString() + "," + w[1][2, 3].ToString() + "," +w[1][3, 0].ToString() + "," + w[1][3, 1].ToString() + "," + w[1][3, 2].ToString() + "," + w[1][3, 3].ToString() + "," +w[1][4, 0].ToString() + "," + w[1][4, 1].ToString() + "," + w[1][4, 2].ToString() + "," + w[1][4, 3].ToString() + "," +h_net[1][0].ToString() + "," + h_out[1][0].ToString() + "," +h_net[1][1].ToString() + "," + h_out[1][1].ToString() + "," +h_net[1][2].ToString() + "," + h_out[1][2].ToString() + "," +h_net[1][3].ToString() + "," + h_out[1][3].ToString() + "," +w[2][0, 0].ToString() + "," + w[2][0, 1].ToString() + "," + w[2][0, 2].ToString() + "," + w[2][0, 3].ToString() + "," +w[2][1, 0].ToString() + "," + w[2][1, 1].ToString() + "," + w[2][1, 2].ToString() + "," + w[2][1, 3].ToString() + "," +w[2][2, 0].ToString() + "," + w[2][2, 1].ToString() + "," + w[2][2, 2].ToString() + "," + w[2][2, 3].ToString() + "," +w[2][3, 0].ToString() + "," + w[2][3, 1].ToString() + "," + w[2][3, 2].ToString() + "," + w[2][3, 3].ToString() + "," +w[2][4, 0].ToString() + "," + w[2][4, 1].ToString() + "," + w[2][4, 2].ToString() + "," + w[2][4, 3].ToString() + "," +h_net[2][0].ToString() + "," + h_out[2][0].ToString() + "," +h_net[2][1].ToString() + "," + h_out[2][1].ToString() + "," +h_net[2][2].ToString() + "," + h_out[2][2].ToString() + "," +h_net[2][3].ToString() + "," + h_out[2][3].ToString() + "," +w[3][0, 0].ToString() + "," + w[3][0, 1].ToString() + "," + w[3][0, 2].ToString() + "," + w[3][0, 3].ToString() + "," +w[3][1, 0].ToString() + "," + w[3][1, 1].ToString() + "," + w[3][1, 2].ToString() + "," + w[3][1, 3].ToString() + "," +w[3][2, 0].ToString() + "," + w[3][2, 1].ToString() + "," + w[3][2, 2].ToString() + "," + w[3][2, 3].ToString() + "," +w[3][3, 0].ToString() + "," + w[3][3, 1].ToString() + "," + w[3][3, 2].ToString() + "," + w[3][3, 3].ToString() + "," +w[3][4, 0].ToString() + "," + w[3][4, 1].ToString() + "," + w[3][4, 2].ToString() + "," + w[3][4, 3].ToString() + "," +h_net[3][0].ToString() + "," + h_out[3][0].ToString() + "," +h_net[3][1].ToString() + "," + h_out[3][1].ToString() + "," +h_net[3][2].ToString() + "," + h_out[3][2].ToString() + "," +h_net[3][3].ToString() + "," + h_out[3][3].ToString() + "," +w[4][0, 0].ToString() + "," + w[4][0, 1].ToString() + "," + w[4][0, 2].ToString() + "," + w[4][0, 3].ToString() + "," +w[4][1, 0].ToString() + "," + w[4][1, 1].ToString() + "," + w[4][1, 2].ToString() + "," + w[4][1, 3].ToString() + "," +w[4][2, 0].ToString() + "," + w[4][2, 1].ToString() + "," + w[4][2, 2].ToString() + "," + w[4][2, 3].ToString() + "," +w[4][3, 0].ToString() + "," + w[4][3, 1].ToString() + "," + w[4][3, 2].ToString() + "," + w[4][3, 3].ToString() + "," +w[4][4, 0].ToString() + "," + w[4][4, 1].ToString() + "," + w[4][4, 2].ToString() + "," + w[4][4, 3].ToString() + "," +h_net[4][0].ToString() + "," + h_out[4][0].ToString() + "," +h_net[4][1].ToString() + "," + h_out[4][1].ToString() + "," +h_net[4][2].ToString() + "," + h_out[4][2].ToString() + "," +h_net[4][3].ToString() + "," + h_out[4][3].ToString() + "," +w[5][0, 0].ToString() + "," + w[5][0, 1].ToString() + "," +w[5][1, 0].ToString() + "," + w[5][1, 1].ToString() + "," +w[5][2, 0].ToString() + "," + w[5][2, 1].ToString() + "," +w[5][3, 0].ToString() + "," + w[5][3, 1].ToString() + "," +w[5][4, 0].ToString() + "," + w[5][4, 1].ToString() + "," +Y0_net.ToString() + "," + Y0_out.ToString() + "," + deltaE[0].ToString() + "," +Y1_net.ToString() + "," + Y1_out.ToString() + "," + deltaE[1].ToString() +Environment.NewLine);
記録

*using (StreamWriter sw = new StreamWriter(path, true, Encoding.Unicode)){sw.Write(",,,," +",," +w[0][0, 0].ToString() + "," + w[0][0, 1].ToString() + "," + w[0][0, 2].ToString() + "," + w[0][0, 3].ToString() + "," +w[0][1, 0].ToString() + "," + w[0][1, 1].ToString() + "," + w[0][1, 2].ToString() + "," + w[0][1, 3].ToString() + "," +w[0][2, 0].ToString() + "," + w[0][2, 1].ToString() + "," + w[0][2, 2].ToString() + "," + w[0][2, 3].ToString() + "," +w[0][3, 0].ToString() + "," + w[0][3, 1].ToString() + "," + w[0][3, 2].ToString() + "," + w[0][3, 3].ToString() + "," +",," +",," +",," +",," +w[1][0, 0].ToString() + "," + w[1][0, 1].ToString() + "," + w[1][0, 2].ToString() + "," + w[1][0, 3].ToString() + "," +w[1][1, 0].ToString() + "," + w[1][1, 1].ToString() + "," + w[1][1, 2].ToString() + "," + w[1][1, 3].ToString() + "," +w[1][2, 0].ToString() + "," + w[1][2, 1].ToString() + "," + w[1][2, 2].ToString() + "," + w[1][2, 3].ToString() + "," +w[1][3, 0].ToString() + "," + w[1][3, 1].ToString() + "," + w[1][3, 2].ToString() + "," + w[1][3, 3].ToString() + "," +w[1][4, 0].ToString() + "," + w[1][4, 1].ToString() + "," + w[1][4, 2].ToString() + "," + w[1][4, 3].ToString() + "," +",," +",," +",," +",," +w[2][0, 0].ToString() + "," + w[2][0, 1].ToString() + "," + w[2][0, 2].ToString() + "," + w[2][0, 3].ToString() + "," +w[2][1, 0].ToString() + "," + w[2][1, 1].ToString() + "," + w[2][1, 2].ToString() + "," + w[2][1, 3].ToString() + "," +w[2][2, 0].ToString() + "," + w[2][2, 1].ToString() + "," + w[2][2, 2].ToString() + "," + w[2][2, 3].ToString() + "," +w[2][3, 0].ToString() + "," + w[2][3, 1].ToString() + "," + w[2][3, 2].ToString() + "," + w[2][3, 3].ToString() + "," +w[2][4, 0].ToString() + "," + w[2][4, 1].ToString() + "," + w[2][4, 2].ToString() + "," + w[2][4, 3].ToString() + "," +",," +",," +",," +",," +w[3][0, 0].ToString() + "," + w[3][0, 1].ToString() + "," + w[3][0, 2].ToString() + "," + w[3][0, 3].ToString() + "," +w[3][1, 0].ToString() + "," + w[3][1, 1].ToString() + "," + w[3][1, 2].ToString() + "," + w[3][1, 3].ToString() + "," +w[3][2, 0].ToString() + "," + w[3][2, 1].ToString() + "," + w[3][2, 2].ToString() + "," + w[3][2, 3].ToString() + "," +w[3][3, 0].ToString() + "," + w[3][3, 1].ToString() + "," + w[3][3, 2].ToString() + "," + w[3][3, 3].ToString() + "," +w[3][4, 0].ToString() + "," + w[3][4, 1].ToString() + "," + w[3][4, 2].ToString() + "," + w[3][4, 3].ToString() + "," +",," +",," +",," +",," +w[4][0, 0].ToString() + "," + w[4][0, 1].ToString() + "," + w[4][0, 2].ToString() + "," + w[4][0, 3].ToString() + "," +w[4][1, 0].ToString() + "," + w[4][1, 1].ToString() + "," + w[4][1, 2].ToString() + "," + w[4][1, 3].ToString() + "," +w[4][2, 0].ToString() + "," + w[4][2, 1].ToString() + "," + w[4][2, 2].ToString() + "," + w[4][2, 3].ToString() + "," +w[4][3, 0].ToString() + "," + w[4][3, 1].ToString() + "," + w[4][3, 2].ToString() + "," + w[4][3, 3].ToString() + "," +w[4][4, 0].ToString() + "," + w[4][4, 1].ToString() + "," + w[4][4, 2].ToString() + "," + w[4][4, 3].ToString() + "," +",," +",," +",," +",," +w[5][0, 0].ToString() + "," + w[5][0, 1].ToString() + "," +w[5][1, 0].ToString() + "," + w[5][1, 1].ToString() + "," +w[5][2, 0].ToString() + "," + w[5][2, 1].ToString() + "," +w[5][3, 0].ToString() + "," + w[5][3, 1].ToString() + "," +w[5][4, 0].ToString() + "," + w[5][4, 1].ToString() + "," +",,," +",," +Environment.NewLine);
記録

*File.SetAttributes(path, FileAttributes.ReadOnly);
読取専用

*e.Paint(e.ClipBounds, DataGridViewPaintParts.All);
セルを描画する

*Rectangle indexRect = e.CellBounds;
行番号を描画する範囲を決定する
e.AdvancedBorderStyleやe.CellStyle.Paddingは無視しています

*TextRenderer.DrawText(e.Graphics,(e.RowIndex + 1).ToString(),
行番号を描画する

*e.Handled = true;
描画が完了したことを知らせる


*Console.WriteLine($"検証結果: {res}");
false


*collider.isTrigger = true;
干渉しないようにisTriggerをつける

*ThrowingBall();
マウス左クリックでボールを射出する

*GameObject ball = Instantiate(ThrowingObject, this.transform.position, Quaternion.identity);*// 標的の座標
Ballオブジェクトの生成

*Vector3 targetPosition = TargetObject.transform.position;*// 射出角度
標的の座標

*float angle = ThrowingAngle;
射出角度

*Vector3 velocity = CalculateVelocity(this.transform.position, targetPosition, angle);*// 射出
射出速度を算出

*Rigidbody rid = ball.GetComponent<Rigidbody>();
射出

*float rad = angle * Mathf.PI / 180;
射出角をラジアンに変換

*float x = Vector2.Distance(new Vector2(pointA.x, pointA.z), new Vector2(pointB.x, pointB.z));
水平方向の距離x

*float y = pointA.y - pointB.y;
垂直方向の距離y

*float speed = Mathf.Sqrt(-Physics.gravity.y * Mathf.Pow(x, 2) / (2 * Mathf.Pow(Mathf.Cos(rad), 2) * (x * Mathf.Tan(rad) + y)));
斜方投射の公式を初速度について解く

*return Vector3.zero;
条件を満たす初速を算出できなければVector3.zeroを返す


*driver = new ChromeDriver();
Chromeの場合

*driver = new SafariDriver();
Safariの場合

*driver = new FirefoxDriver();
FireFoxの場合


*Thread.Sleep(500);
成功するまでTry

*previousTime = DateTime.Now;
前回記録時間の更新

*private static EventHandler<SuperSocket.ClientEngine.ErrorEventArgs> OnError(string ticker)*{return delegate (object s, SuperSocket.ClientEngine.ErrorEventArgs e){var errorStr = string.Format("({0}){1}", ticker, e.Exception.ToString());ErrorLog(errorStr);};}
エラー時

*static object _errorLogLock = new Object();
エラーログメソッド

*lock (_errorLogLock)*{using (var sw = new StreamWriter(Environment.CurrentDirectory + "\\error.log", true, Encoding.UTF8))using (var writerSync = TextWriter.Synchronized(sw)){sw.WriteLine(str);}}
TextWriter.Synchronizedだけだとエラー発生するっぽいので自前ロック

*private static void AutoReconnectCallBack(object args)*{var i = 0;foreach (var ws in _sockets){if (ws.State == WebSocketState.Closed){//再接続var str = string.Format("({0})Try to reconnect", _tickers[i]);ErrorLog(str);ws.Open();}i++;}}
再接続（テスト版）

*var str = string.Format("({0})Try to reconnect", _tickers[i]);
再接続

*public static void OpenAll()*{foreach (var ws in _sockets) ws.Open();//自動再接続をオン_autoReconnectTimer = new Timer(AutoReconnectCallBack);_autoReconnectTimer.Change(_autoRecconectInterval, _autoRecconectInterval);}
一括接続

*_autoReconnectTimer = new Timer(AutoReconnectCallBack);
自動再接続をオン

*public static void CloseAll()*{foreach (var ws in _sockets) ws.Close();//自動再接続をオフif (_autoReconnectTimer != null) _autoReconnectTimer.Change(Timeout.Infinite, Timeout.Infinite);}
一括切断

*if (_autoReconnectTimer != null) _autoReconnectTimer.Change(Timeout.Infinite, Timeout.Infinite);*}
自動再接続をオフ


*m_stateVector.EnableRefreshTrace = true;
一致条件実行ログのデバッグ出力を有効化


*var hostName = "";
空文字にする


*var properties = new ExitGames.Client.Photon.Hashtable();
全体カウントダウンのスタート時間をセット


*Console.WriteLine(CreatePassword());
=> 91760


*public int[] Num3 = new int[5] { 0, 1, 2, 3, 4 };
配列系の確認 ＜　[]のアレイ　＞ とりあえず宣言と初期値設定まとめ
＜　宣言時のもろもろな書き方　＞
------------------------------------------------------
①　多分基本形はこれだけど、要素数と要素を合わせるのが面倒でメリットが薄そう

*public int[] Num;
②　とりあえず変数宣言のみのスタイル
Start() などの実行時か、UnityEditorのインスペクタで値を入れないと中身を作れない
結局これでいい気がするけど・・・
これ以外は、Unityの場合は初期値を変数宣言時に行うと、メタファイルに情報が残るからか？
あとから宣言時の値をスクリプトで管理しにくいのが不便に感じる...

*public int[] Num1 = new int[3];
③　要素数だけ決めて中身は後からのスタイル
インスタンスを入れたり、座標の合成代入先など...

*//　　　要素を書いたら要素数が決まる！　要素数は省略できる！*public int[] Num2a =new int[] { 0, 1, 2, 3 };
④　いきなり要素を作るスタイル

*public int[] Num2a =new int[] { 0, 1, 2, 3 };
要素を書いたら要素数が決まる！　要素数は省略できる！

*public int[] Num2b = { 0, 1, 2, 3 };
new int[] も省略可能...だが変数宣言時のみ下記のスタイルが許容されている

*//　　　public int[] Num2c =new int { 0, 1, 2, 3 };
中途半端な省略はエラーになる

*int[] NumX;
※　その他のエラーパターン
・ 因みに 下のように最後に（）をつけてはいけない！
上のどのパターンでも()は付けたらダメ！　Listと勘違いしないように！っと
public int[] i_NumXX4 = new int[5] { 0, 1, 2, 3, 4 }();
・ 当然、配列の枠と要素数とが合っていない場合はエラー。
public int[] i_Num4 = new int[5] { 0,1, 2, 3, 4,5,6 };
------------------------------------------------------
＜　関数内での書き方　＞
------------------------------------------------------

*//　　下記はやっぱりコンパイルエラーになる。*//  　NumX2 = {9,8,7};
new int[] 省略形　はアウト！

*//  　NumX2 = {9,8,7};
下記はやっぱりコンパイルエラーになる。

*//　　▼　これならOK*NumX = new int[]{9,8,7};
NumX2 = {9,8,7};

*NumX = new int[]{9,8,7};
▼　これならOK

*int[] num2b=new int[4];
new int[] 省略形は、 このように変数の要素をさきに作っても...

*// num1b = { 0, 1, 2, 3 };
下記の行はコンパイルエラーがでて許容されない。

*//　　多分つまり...この書き方は変数宣言時にしか使えない。*int[] numX = {9,8,7};
変数宣言時ならローカル変数でも問題ない...わかりにくい！ ("=";)

*int[] numX = {9,8,7};
多分つまり...この書き方は変数宣言時にしか使えない。

*public int[] NumInStart;
＜　Start()内での確認　＞
------------------------------------------------------
変数を宣言し、Start()　内部で要素数を決める。
この書式は汎用性があり使いやすい。
結果的に行が増えるが、Unityでは変数宣言時に要素数を決めないほうが使いやすいのでは？？
要素もプールとして使うなら、 for などのループ処理で生成するほうが使いやすいのでは？


*using MyGameAsset;
←ココ

*pointTarget = GameObject.Find("GameObjectName");
シーンに配置されたGameObjectの名前から取得する


*float floatValue = float.Parse("6.2");
文字列からFloat値を取得


*,,,*public class Soldier : CharacterBase {public override string Attack() {return "戦士は斬りかかった！";}}
var character = new CharacterBase(); ←これは無理

*public override bool IsValid() {if (String.IsNullOrWhiteSpace(this._model.Name)) {return false;}if (this._model.Name.Length > 20) {return false;}return true;}
入力されているかつ20文字以下なら可

*public override bool IsValid() {var age = DateTime.Now.Year - this._model.Birth.Year;if (DateTime.Now < this._model.Birth.AddYears(age)) {age--;}if (!(20 <= age && age <= 40)) {return false;}return true;}
20歳以上40歳以下なら可

*public override bool IsValid() {return !this._model.Married;}
結婚していない人のみ可

*var model = new Model() {Name = "名無しの権兵衛",Birth = new DateTime(1992, 7, 17),Married = false};
※実際にはユーザーの入力値がバインドされることを想定しています。

*}
順に検証して処理する


*string url = "https:
office.yahoo.co.jp";

*res = (HttpWebResponse)req.GetResponse();
サーバーからの応答を受信するためのWebResponseを取得


*input[1].mi.dwFlags = MOUSEEVENTF_LEFTUP;
左ボタン Up

*SetCursorPos(pt.X, pt.Y);
マウス位置を元に戻す

*input[0].mi.dwFlags = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
マウスカーソルの移動 例

*string processName = WindowsHandles.GetActiveProcessName();
自身がアクティブなら何もしない

*this.Activate();
これを実行しないとフォーカスが奪えない

*this.Topmost = true;
最前面にした後に解除することで前面化させる

*WindowsHandles.ForceActive((int)this.Left + 10, (int)this.Top + 10);
PCによってはフォーカスが奪えないため、マウスクリックでアクティブ化する。

*public static void ForceActive(IntPtr handle)*{const uint SPI_GETFOREGROUNDLOCKTIMEOUT = 0x2000;const uint SPI_SETFOREGROUNDLOCKTIMEOUT = 0x2001;const int SPIF_SENDCHANGE = 0x2;const int SW_RESTORE = 9;IntPtr dummy = IntPtr.Zero;IntPtr timeout = IntPtr.Zero;// 最小化状態なら元に戻すif (IsIconic(handle))ShowWindowAsync(handle, SW_RESTORE);int processId;// フォアグラウンドウィンドウを作成したスレッドのIDを取得int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);// 目的のウィンドウを作成したスレッドのIDを取得int targetID = GetWindowThreadProcessId(handle, out processId);// スレッドのインプット状態を結び付けるAttachThreadInput(targetID, foregroundID, true);// 現在の設定を timeout に保存SystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, timeout, 0);// ウィンドウの切り替え時間を 0ms にするSystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, dummy, SPIF_SENDCHANGE);// ウィンドウをフォアグラウンドに持ってくるSetForegroundWindow(handle);// 設定を元に戻すSystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, timeout, SPIF_SENDCHANGE);// スレッドのインプット状態を切り離すAttachThreadInput(targetID, foregroundID, false);}
ウィンドウを強制的にアクティブにする

*if (IsIconic(handle))*ShowWindowAsync(handle, SW_RESTORE);
最小化状態なら元に戻す

*int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);*// 目的のウィンドウを作成したスレッドのIDを取得
フォアグラウンドウィンドウを作成したスレッドのIDを取得

*int targetID = GetWindowThreadProcessId(handle, out processId);
目的のウィンドウを作成したスレッドのIDを取得

*AttachThreadInput(targetID, foregroundID, true);*// 現在の設定を timeout に保存
スレッドのインプット状態を結び付ける

*SystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, timeout, 0);
現在の設定を timeout に保存

*SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, dummy, SPIF_SENDCHANGE);
ウィンドウの切り替え時間を 0ms にする

*SetForegroundWindow(handle);
ウィンドウをフォアグラウンドに持ってくる

*SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, timeout, SPIF_SENDCHANGE);
設定を元に戻す

*AttachThreadInput(targetID, foregroundID, false);*}
スレッドのインプット状態を切り離す

*public static void ForceActive(IntPtr handle)*{const int SW_RESTORE = 9;// 最小化状態なら元に戻すif (IsIconic(handle))ShowWindowAsync(handle, SW_RESTORE);int processId;// フォアグラウンドウィンドウを作成したスレッドのIDを取得int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);// 目的のウィンドウを作成したスレッドのIDを取得int targetID = GetWindowThreadProcessId(handle, out processId);// スレッドのインプット状態を結び付けるAttachThreadInput(targetID, foregroundID, true);// ウィンドウをフォアグラウンドに持ってくるSetForegroundWindow(handle);// スレッドのインプット状態を切り離すAttachThreadInput(targetID, foregroundID, false);}
ウィンドウを強制的にアクティブにする

*if (IsIconic(handle))*ShowWindowAsync(handle, SW_RESTORE);
最小化状態なら元に戻す

*int foregroundID = GetWindowThreadProcessId(GetForegroundWindow(), out processId);*// 目的のウィンドウを作成したスレッドのIDを取得
フォアグラウンドウィンドウを作成したスレッドのIDを取得

*int targetID = GetWindowThreadProcessId(handle, out processId);
目的のウィンドウを作成したスレッドのIDを取得

*AttachThreadInput(targetID, foregroundID, true);*// ウィンドウをフォアグラウンドに持ってくる
スレッドのインプット状態を結び付ける

*SetForegroundWindow(handle);
ウィンドウをフォアグラウンドに持ってくる

*AttachThreadInput(targetID, foregroundID, false);*}
スレッドのインプット状態を切り離す

*this.Activate();
自身をアクティブにする

*this.Topmost = true;
表示の最初は最前面とする

*this.Topmost = false;
最前面にした後に解除することで前面化させる

*var helper = new System.Windows.Interop.WindowInteropHelper(this);
強制的にフォーカスを奪う

*this.Topmost = true;
再度、再設定する
表示の最初は最前面とする

*this.Topmost = false;
最前面にした後に解除することで前面化させる

*Window_Activated(null, EventArgs.Empty);
アクティブイベントを呼ぶ

*public static void SetTopMostWindow(IntPtr handle, bool isTopMost)*{const int SWP_NOSIZE = 0x0001;const int SWP_NOMOVE = 0x0002;const int SWP_SHOWWINDOW = 0x0040;const int HWND_TOPMOST = -1;const int HWND_NOTOPMOST = -2;if (isTopMost){// 最前面SetWindowPos(handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);}else{// 最前面解除SetWindowPos(handle, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);}}
ウィンドウの最前面/解除

*SetWindowPos(handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
最前面

*SetWindowPos(handle, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);
最前面解除

*this.Activate();
自身をアクティブにする

*WindowsHandles.SetTopMostWindow(helper.Handle, true);
表示の最初は最前面とする

*WindowsHandles.SetTopMostWindow(helper.Handle, false);
最前面にした後に解除することで前面化させる

*WindowsHandles.ForceActive(helper.Handle);
強制的にフォーカスを奪う

*WindowsHandles.SetTopMostWindow(helper.Handle, true);
表示の最初は最前面とする

*WindowsHandles.SetTopMostWindow(helper.Handle, false);
最前面にした後に解除することで前面化させる

*Window_Activated(null, EventArgs.Empty);
アクティブイベントを呼ぶ


*.AddTo(this);
MonoBehaviourなら死活管理もこれでOK

*Container.Bind<IMessagePublisher>().To<ShopMessageBroker>().AsSingle();
IMessageBrokerではなく、IMessagePublisher/IMessageReceiverと明確にできることの権限を分ける

*})
何らかの処理


*Console.WriteLine( test2 == null);
ここはNullじゃないのでFalseになる


*void Start () {}
Use this for initialization

*void Update () {switch(MyLoopMode){case LoopMode.Foreach:// int count=0;//　▲　Switch文はif文と違ってスコープが別れていないので、同名のローカル変数を作りにくい？//　▼ ・・・と思ったけどスコープの外に書いているからダメだったのがアドバイスで解りました。{int count=0;foreach(int num in IntArray){print("foreach__"+num.ToString());count++;if(count==IntArray.Length){MyLoopMode=LoopMode.Stop;}}break;}case LoopMode.For:int maxF=IntArray.Length-1;for(int i=0;i<=maxF;i++){print("for__"+IntArray[i].ToString());if(i==maxF){MyLoopMode=LoopMode.Stop;}}break;case LoopMode.While:int countW=0,maxW=5;//while(int id < IntArray.Length)//　　　　　↑　と　型を書いて定義することはできないっぽい。//ちょっとしたミスで、無限ループになる可能性がそこそこある…Unityが固まる。while( countW <= maxW){print("while__"+IntArray[countW].ToString());if(countW==maxW){MyLoopMode=LoopMode.Stop;}countW++;}break;case LoopMode.Stop:break;}}
Update is called once per frame

*//　▲　Switch文はif文と違ってスコープが別れていないので、同名のローカル変数を作りにくい？*//　▼ ・・・と思ったけどスコープの外に書いているからダメだったのがアドバイスで解りました。
int count=0;

*//　▼ ・・・と思ったけどスコープの外に書いているからダメだったのがアドバイスで解りました。*{int count=0;foreach(int num in IntArray){print("foreach__"+num.ToString());count++;if(count==IntArray.Length){MyLoopMode=LoopMode.Stop;}}break;}
▲　Switch文はif文と違ってスコープが別れていないので、同名のローカル変数を作りにくい？

*{int count=0;foreach(int num in IntArray){print("foreach__"+num.ToString());count++;if(count==IntArray.Length){MyLoopMode=LoopMode.Stop;}}break;}
▼ ・・・と思ったけどスコープの外に書いているからダメだったのがアドバイスで解りました。

*while( countW <= maxW)
↑　と　型を書いて定義することはできないっぽい。
ちょっとしたミスで、無限ループになる可能性がそこそこある…Unityが固まる。


*public string url = "ws:
192.168.1.1:6437";環境ごとに変更


*interface ISavable*{void Save();}
ISavable

*public class ReactiveSavableList<T> where T:ISavable*{}
ReactiveSavableList

*abstract public class ISavable*{public void Save(){}}
ISavable

*public class ReactiveSavableList<T> where T:ISavable*{}
ReactiveSavableList


*public IEnumerable<int> Solve() {// 計算時間を考慮して、1-9999999までの自然数に限定しました。foreach (var num in Enumerable.Range(1, 10000000 / multiplier)) {if (IsCyclicNumber(num)) {yield return num;}}}
multiplier倍すると巡回する数を求める。

*private bool IsCyclicNumber(int num) {string numstr = num.ToString();string result = (num * multiplier).ToString();// 速度を速めるための泥臭い判断  ここから ↓if (result.Length != numstr.Length)return false;foreach (var c in result)if (!numstr.Contains(c))return false;// ↑ ここまで （無くても正しく動作する）return (GetCyclics(num).Any(x => result == x));}
numが巡回数かどうかを調べる

*if (result.Length != numstr.Length)*return false;
速度を速めるための泥臭い判断  ここから ↓

*return (GetCyclics(num).Any(x => result == x));
↑ ここまで （無くても正しく動作する）

*private IEnumerable<string> GetCyclics(int num) {string s = num.ToString();for (int i = 0; i < s.Length - 1; i++) {s = s.Substring(1) + s[0];yield return s;}}
numを巡回させた数を文字列に変換し列挙する。


*void Start () {//例：Testsqという名前のGameObjectをobj1に格納obj1 = GameObject.Find("Testsq");//フラグを初期化showflag = true;}
Use this for initialization

*obj1 = GameObject.Find("Testsq");
例：Testsqという名前のGameObjectをobj1に格納

*showflag = true;
フラグを初期化

*private GameObject obj1;
スクリプトで制御するGameObjectを用意

*private bool showflag;
オブジェクトが見えているかの判定をするフラグ

*void Start () {//例：Testsqという名前のGameObjectをobj1に格納obj1 = GameObject.Find("Testsq");//フラグを初期化showflag = true;}
Use this for initialization

*obj1 = GameObject.Find("Testsq");
例：Testsqという名前のGameObjectをobj1に格納

*showflag = true;
フラグを初期化

*void Update () {if (Input.GetMouseButtonDown(0)){//showflagがtureなら、表示オブジェクトを消すif (showflag) {Debug.Log("click");//ここでオブジェクトを消すobj1.SetActive(false);//フラグを管理showflag = false;}else if (showflag == false){//オブジェクトを表示obj1.SetActive(true);//フラグを管理showflag = true;}}}
Update is called once per frame

*obj1.SetActive(false);
ここでオブジェクトを消す

*showflag = false;
フラグを管理

*obj1.SetActive(true);
オブジェクトを表示

*showflag = true;
フラグを管理


*postAsyncTask.Wait();
asyncawaitは.NET4.0だから使えない...


*method();
計測するメソッド本体

*string methodName = method.Method.Name;*Console.WriteLine($@"メソッド名：{methodName}
計測メソッド名の取得

*main.MeasurementClock(main.StringBuilder);
ここで計測したいメソッド名を引数にして呼ぶ。

*method();
計測するメソッド本体

*string methodName = method.Method.Name;*Console.WriteLine($@"メソッド名：{methodName}
計測メソッド名の取得


*task.Start(queuedTaskScheduler);
タスクを開始するときにタスクスケジューラを指定します

*mainThread = new Thread(new ThreadStart(Execute)){Name = threadName};
スレッドを生成し、名前を付けます。スレッドは下記のExecuteを実行します。

*mainThread.Start();
スレッドを開始

*// タスクがないときは、foreachは停止しています。*foreach (var task in tasksCollection.GetConsumingEnumerable())
tasksCollectionにタスクがある間だけ、このforeachが回ります。

*protected override IEnumerable<Task> GetScheduledTasks()*{return tasksCollection.ToArray();}
オーバーライドしなければなりません。

*protected override void QueueTask(Task task)*{// タスクをキューイングします。if (task != null){tasksCollection.Add(task);}}
オーバーライドしなければなりません。

*protected override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued)*{// falseを返すと、taskがキューに並びます。return false;// ここでtrueを返すと、キューに入れずにそのまま実行させてしまいます。}
オーバーライドしなければなりません。

*return false;
falseを返すと、taskがキューに並びます。

*}
ここでtrueを返すと、キューに入れずにそのまま実行させてしまいます。


*mail.Body = "C#でOutlookを操作する";
メール本文の内容を記載する(例："C#でOutlookを操作する")。


*piyo2 = 3;
静的でないフィールド、メソッド、またはプロパティで、オブジェクト参照が必要です
piyo = 2;

*// public abstract static void Method3();*public static void Method4() { }
静的メンバーを override、virtual、または abstract とすることはできません。

*public static void Method4() { }
public abstract static void Method3();

*public new static void Method4() { }
newキーワードによる隠蔽は可能

*Hoge.Fuga2(i);
静的メソッドはクラス修飾で呼び出せます。

*var hoge = new Hoge();
インスタンスメソッドは、インスタンス修飾で呼び出せます。

*}
静的メソッドをインスタンス修飾で呼び出すことはできません。
hoge.Fuga2(i);


*class SecondLevelException : Exception
2つの派生Exceptionをネストされた例外の
動きをみるためのデモ用に定義する

*public ThirdLevelException( string message )
前Exceptionを受け取らないコンストラクタ

*Rethrow( );
この`Rethrow`関数は0ディビジョンを行う
別関数を呼び出します。

*current = ex;
このコードではネストされた例外をInnerExceptionプロパティを
用いて紐解きます

*static void Rethrow()
`Rethrow`関数は`DivideBy0( )`関数からの例外をキャッチし
別の例外を生成します。

*static void DivideBy0( )
`DivideBy0`関数は0ディビジョンを実行し
2番目の例外を生成します。


*var nameList = new List<string> {"Tokyo", "Osaka", "Aichi", "America", "London", "Australia",};
テストケース

*var nameBuf1 = nameList.Where(s => 6 <= s.Length);
リスト内から6文字以上の文字列を探す場合
-----------------------------------------
パターン１

*Func<string, bool> func2 = (s) => 6 <= s.Length;
パターン２

*Func<string, bool> func3 = (s) => { return 6 <= s.Length; };
パターン３

*Func<string, bool> func4 = Judge;
パターン４


*public IEnumerable<int> GetSequence(ICollection<ICollection<int>> list) {foreach (var bin in list)foreach (var n in bin)yield return n;}
ビンに詰められている全ての要素を順に取り出す

*var binsList = _solver.Solve(items);*while (true) {// 空きの小さい順に並べ替え、// 空きが最も小さいビンを最終解答領域(result)へ入れる（確定）var bin = binsList.OrderByDescending(b => b.Sum()).First();result.Add(bin);// listから確定したビンを取り除くbinsList.Remove(bin);// 残ったビンは無いので、処理終了if (binsList.Count == 0)break;// 残ったビンに入っている項目で、再度解を求めるbinsList = _solver.Solve(GetSequence(binsList).ToArray());}
一旦答えを求める

*var bin = binsList.OrderByDescending(b => b.Sum())
空きの小さい順に並べ替え、
空きが最も小さいビンを最終解答領域(result)へ入れる（確定）

*binsList.Remove(bin);
listから確定したビンを取り除く

*if (binsList.Count == 0)*break;
残ったビンは無いので、処理終了

*binsList = _solver.Solve(GetSequence(binsList).ToArray());
残ったビンに入っている項目で、再度解を求める


*[SerializeField]
Inspectorで録音デバイスを指定する場合の名前(未指定は既定)

*[SerializeField]
口パク対象(SkinnedMeshRenderer)のIndex

*[SerializeField]
入力音量に口パク具合を合わせる係数

*SkinnedMeshRenderer Skinned;
このスクリプトは口パク対象(SkinnedMeshRenderer)に付ける前提

*WaveIn Wave;
入力音声データ

*float Weight = 0;
入力音声データを音量としてBlendShapeに設定する値

*DeviceName = WaveIn.GetCapabilities(0).ProductName;
録音デバイス未指定なら既定

*Wave = new WaveIn();
NAudioの録音初期化

*void Wave_DataAvailable(object sender, WaveInEventArgs e)*{Weight = 0;var buffer = new WaveBuffer(e.Buffer);for (int index = 0; index < e.BytesRecorded / 2; index++){Weight += Mathf.Abs(buffer.ShortBuffer[index]);}Weight /= e.BytesRecorded / 2;}
音量取得

*void Update()*{Skinned.SetBlendShapeWeight(Index, Weight * Gain);}
取得した音量に係数をかけて調整してBlendShapeに設定


*float waitTimeRate = 0.002f;
生成スパンを徐々に短く

*Invoke ("GoNextScene", 5f);
生成スパンが最短になったらシーンをロード

*SteamVR_LoadLevel.Begin("NextScene");
コルーチンを止める場合
StopCoroutine ("Fire");
fade


*string videoclipfile = "Movie/動画ファイル名";
とりあえず特定のファイル名を指定

*string rawImage = "Prefabs/MovieRawImage";*public void VideoStart(){// ボタンクリック処理StartCoroutine (VideoPlayStart ());}
再生画面用のRaw Imageは「MovieRawImage」という名称でプレハブ化されている前提

*StartCoroutine (VideoPlayStart ());
ボタンクリック処理

*var obj = GameObject.Find ("Video Player");
あらかじめVideo PlayerがSceneに登録されている前提

*var audioSource = videoPlayer.GetComponent<AudioSource>();
あらかじめVideo PlayerにAudio Sourceが登録されている前提

*VideoClip vclip = (VideoClip)Resources.Load (videoclipfile);
ファイルをロードし、再生する動画のサイズに合わせてRender Textureを準備する

*videoPlayer.playOnAwake = false;
Video Playerの設定を行う

*videoPlayer.SetTargetAudioSource(0, audioSource);
Audio SourceにあらかじめVideo Playerに追加したAudio Sourceを設定する

*videoPlayer.Prepare();
Video Playerの準備（完了まで待つ）

*var _prefab = Resources.Load(rawImage);
Video Playerの準備が完了した後
プレハブから動画再生用のRawImageをロードする

*GameObject cvs = GameObject.Find("Canvas");
Canvasが親になるようにtransformを代入する

*RawImage screen = _rawImg.GetComponent<RawImage>();
RawImageに動画再生用のRenderTextureを設定する

*videoPlayer.Play();
動画の再生開始（再生完了まで待つ）

*videoPlayer.clip = null;
動画の再生完了


*}
end of method MyClass::Display


*Thread t = new Thread(ClipBoardSetter);
スレッドの中にシングルスレッドにしたいメソッドを入れる


*var opponentInput = new StubOpponentInput(0);
新しく作ったクラスを使う

*var jankenChecker = new JankenChecker(output);
実際にテストしたいクラス

*Assert.Equal("あいこでした！", output.Output);
結果を確認。第１引数が想定の、第２引数が実際の値


*// 宣言と同時に初期化 or コンストラクタで初期化する場合は「private set;」の記述不要*public ReactiveProperty<int> SelectedMode { get; private set; }
プロパティ

*public ReactiveProperty<int> SelectedMode { get; private set; }
宣言と同時に初期化 or コンストラクタで初期化する場合は「private set;」の記述不要

*SelectedMode = new ReactiveProperty<int>();
メソッド内での記述
デフォルト値で初期化

*SelectedMode = new ReactiveProperty<int>(3);
指定した数値(この場合は3)で初期化

*int selectedMode = SelectedMode.Value;
値を引き出す・書き換える際はValueプロパティを参照すること

*SelectedMode.Subscribe(x => DoFunc(x));
コンストラクタ内で

*private CompositeDisposable Disposable { get; } = new CompositeDisposable();
Disposeが必要なReactivePropertyやReactiveCommandを集約させるための仕掛け

*public ReactiveProperty<int> Hoge{ get; }
ReactivePropertyやReactiveCommandを用意する

*this.Hoge = new ReactiveProperty<int>().AddTo(this.Disposable);
AddToメソッドでDisposeしたいオブジェクトをDisposableプロパティ(の実体)に登録する

*Disposable.Dispose();
まとめてDisposeする

*SelectedMode.Subscribe(_ => DoFunc(SelectedMode.Value));*//値が変更された時の動作(色々行うので{}が必要)
値が変更された時の動作

*SelectedMode.Subscribe(_ => {DoFunc1(SelectedMode.Value);
値が変更された時の動作(色々行うので{}が必要)

*public ReactiveProperty<int> Input1 { get; } = ReactiveProperty<int>();
変数を宣言

*Output1 = Input1.Select(x => x * 2).ToReactiveProperty();
定義する際に、どう加工するかをメソッドチェーンで示す
(Output1は、Input1を2倍にした数値となる)

*Output2 = Input1.Select(x => (x % 2 == 0)).ToReactiveProperty();
この「Select」は、普通のLINQと同様、型変換にも使える
(Output2は、Input1が偶数ならtrue、機数ならfalseとなる)

*(Output3は、Input1 == Input2なら"同じ", それ以外なら"違う"となる)Output3 = Input1.CombineLatest(Input2, (x, y) => (x == y ? "同じ" : "違う")).ToReactiveProperty();
2つ以上のReactivePropertyを合成することも可能

*Output3 = Input1.CombineLatest(Input2, (x, y) => (x == y ? "同じ" : "違う")).ToReactiveProperty();
(Output3は、Input1 == Input2なら"同じ", それ以外なら"違う"となる)

*SelectedMode.Subscribe(_ => DoFunc(SelectedMode.Value));
値が変更された時の動作

*SelectedMode.Subscribe(x => DoFunc(x));
実はこういった風に書ける

*SelectedMode.Subscribe(DoFunc);
更に、DoFuncメソッドが引数1のみでオーバーロードが無ければここまで略せる(意味は上と等価)

*public ReactiveCommand ButtonCommand {get; private set; }
何らかのコマンド

*public ReactiveProperty<bool> ButtonFlg1 { get; } = new ReactiveProperty<bool>();
何らかのフラグ

*ButtonCommand = ButtonFlg1.ToReactiveCommand();
フラグが有効な時にのみコマンドを有効にする(例えばボタンのコマンドが無効になっている際は、ボタン自体も無効色になる)

*ButtonCommand = ButtonFlg1.CombineLatest(ButtonFlg2, (x,y) => x & y).ToReactiveCommand();
フラグが2つとも有効な場合にのみコマンドを有効にする

*ButtonCommand = new[] { ButtonFlg1, ButtonFlg2, ButtonFlg3 }.CombineLatest(x => x.All(y => y)).ToReactiveCommand();
フラグが3つとも有効な場合にのみコマンドを有効にする

*ButtonCommand = ButtonFlg1.CombineLatest(ButtonFlg2, (x,y) => x | y).ToReactiveCommand();
フラグが1つでも有効な場合にのみコマンドを有効にする

*ButtonCommand = new[] { ButtonFlg1, ButtonFlg2, ButtonFlg3 }.CombineLatest(x => x.Any(y => y)).ToReactiveCommand();
フラグが1つでも有効な場合にのみコマンドを有効にする

*ButtonCommand = new[] { ButtonFlg1, ButtonFlg2, ButtonFlg3 }.CombineLatestValuesAreAllTrue().ToReactiveCommand();
フラグが全て有効な場合にのみコマンドを有効にする

*ButtonCommand = new[] { ButtonFlg1, ButtonFlg2, ButtonFlg3 }.CombineLatestValuesAreAllFalse().ToReactiveCommand();
フラグが全て無効な場合にのみコマンドを有効にする

*using System.ComponentModel.DataAnnotations;
バリデーション用のクラス
(以下のサンプルは、int型にパースできた時のみ「入力値が正常」だと判断する)

*[IntValidationAttribute]*public ReactiveProperty<string> X {get;} = new ReactiveProperty<string>();
バリデーションを設定する

*ButtonCommand = X.ObserveHasErrors.Select(x => !x).ToReactiveCommand();
バリデーションが通る(入力値が正常)な時のみコマンドを有効にする

*ButtonCommand = X.ObserveHasErrors.ToReactiveCommand();
バリデーションが通らない(入力値が異常)な時のみコマンドを有効にする

*ButtonCommand = new[]{ButtonFlg1.ObserveHasErrors,ButtonFlg2.ObserveHasErrors}.CombineLatest(x => x.All(y => !y)).ToReactiveCommand();
2つのバリデーションが通る時のみコマンドを有効にする

*public class Model : BindableBase{
Model側(各種プロパティを実装した側)
ここでBindableBaseは、Prism.Mvvm.BindableBaseのような、
INotifyPropertyChanged実装済みのヘルパークラスだとする

*Property1 = model.ToReactivePropertyAsSynchronized(m => m.X);
BindingのModeがTwoWayなプロパティ(つまり双方向)

*Property2 = model.ObserveProperty(m => m.X).ToReactiveProperty();
BindingのModeがOneWayなプロパティ(つまりView→ViewModelのみ)

*Property3 = ReactiveProperty.FromObject(model, m => m.X);
BindingのModeがOneWayToSourceなプロパティ(つまりViewModel→Viewのみ)


*var text = @"ドンドンはドンドコの父なり。ドンドンの子ドンドコ、ドンドコドンを生み、ドンドコドン、ドコドンドンとドンタカタを生む。ドンタカタ、ドカタンタンを生めり。";
『バブリング創世記』（筒井康隆著）の冒頭部分を抜粋（改行せずに1文字列にしている）


*namespace Tests.Functions*{[TestFixture]public class NUnitTest{private MyDbContextFixture _fixture;private MyDBContextName _context;[OneTimeSetUp]public void OneTimeSetup(){_fixture = new MyDbContextFixture();}[SetUp]public void SetUp(){_context = _fixture.Context;}// ご自身で引数のテストデータ作成します// DBに登録したいテストデータをいれます// GetTestData()/// <summary>/// テストデータを削除/// </summary>[TearDown]public void TearDown(){var list = _context.PrPrint.ToList<PrPrint>();_context.PrPrint.RemoveRange(list);_context.SaveChanges();}/// <summary>/// ステータスコードが60から70に更新/// </summary>[TestCaseSource(nameof(MyTestDataName))]public void UpdateTest(inputModel){var function = new TestFunction<MyDBContextName>(_context);// テストデータをInsertvar list = GetTestData();_context.TestTable.AddRange(GetTestData());_context.SaveChanges();// テストしたい内容var result = function.Update_Test(inputModel);var entity = _context.TestTable.Where(x => x.Id == result.Id).SingleOrDefault();// DBのステータスコードが70Assert.That("70", Is.EqualTo(entity.StatusCd));}}}
テストしたいプロジェクトを参照するのを忘れずに

*[TearDown]
ご自身で引数のテストデータ作成します
DBに登録したいテストデータをいれます
GetTestData()

*var list = GetTestData();
テストデータをInsert

*var result = function.Update_Test(inputModel);
テストしたい内容

*Assert.That("70", Is.EqualTo(entity.StatusCd));
DBのステータスコードが70

*var list = GetTestData();
テストデータをInsert


*p <- i;
mはメジアンで配列を中央で二分割するための指数
T[i...j]は一時的な配列

*p <- A[l]
Pは配列の最初の値でこれを軸とする
入力される値は配列A[0...n -1]の部分配列でlは左、rは右を意味する
出力する値は配列を２つに分けるための分割点の値を返す

*//s は分割点*if l / r {s <- Partition(A[l...r])Quicksort(A[l...s - 1])Quicksort(A[s + 1...r])}
部分配列をクイックソートする


*...
await code


*i_projectile.GetComponent<PhotonView> ().TransferOwnership (PhotonNetwork.player.ID);
所有権の移譲


*var binList = new List<ICollection<int>>();
最初に一つのビンを用意する

*var target = binList.Select(b => new { Bin = b, Space = BinSize - b.Sum(t => t) })
nが入るビンを見つける （空きが最小のビン）

*bin.Add(n);*} else {
nが入るビンが見つかったので、そこに入れる

*List<int> bin2 = new List<int>() { n };
見つからなかったので、新しいビンを用意する


*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"

*this.MouseLeftButtonDown += (sender, e) => { this.DragMove(); };
ウィンドウをマウスのドラッグで移動できるようにする

*StartLearning();
既存の画像データ集を用いて学習を開始する

*private void StartLearning()*{var catsCreator = new ItemsFactory("cats", directoryPath, itemList, 0);var birdsCreator = new ItemsFactory("birds", directoryPath, itemList, 1);var dogsCreator = new ItemsFactory("dogs", directoryPath, itemList, 2);bagofVW = new TrainFactory(codeWordCount, bagofVW, itemList).bagofVW;var inputs = new InputFactory(itemList).input;var outputs = new OutputFactory(itemList).output;msvm = new MulticlassSupportVectorMachine<ChiSquare>(0, new ChiSquare(), classes);// 学習アルゴリズムを作成するvar teacher = new MulticlassSupportVectorLearning<ChiSquare>(){Learner = (param) => new SequentialMinimalOptimization<ChiSquare>(){UseComplexityHeuristic = true,UseKernelEstimation = true}};msvm = teacher.Learn(inputs, outputs);var calibration = new MulticlassSupportVectorLearning<ChiSquare>(){Model = msvm,Learner = (param) => new ProbabilisticOutputCalibration<ChiSquare>(){Model = param.Model}};calibration.ParallelOptions.MaxDegreeOfParallelism = 1;calibration.Learn(inputs, outputs);inkCanvas.Strokes.Clear();textBox1.Clear();}
学習を開始する

*var teacher = new MulticlassSupportVectorLearning<ChiSquare>()*{Learner = (param) => new SequentialMinimalOptimization<ChiSquare>(){UseComplexityHeuristic = true,UseKernelEstimation = true}};
学習アルゴリズムを作成する

*internal class ItemsFactory*{private string directoryPath;private List<ImageItem> itemList;public ItemsFactory(string animalName, string directoryPath, List<ImageItem> itemList, int classNum){this.directoryPath = directoryPath;this.itemList = itemList;List<String> list = new List<String>();System.IO.DirectoryInfo di = new System.IO.DirectoryInfo(Path.Combine(directoryPath, animalName));IEnumerable<System.IO.FileInfo> files =di.EnumerateFiles("*", System.IO.SearchOption.AllDirectories);//ファイルを列挙するforeach (System.IO.FileInfo f in files){list.Add(f.FullName);}foreach (String fileName in list){ImageItem ii;ii = new ImageItem();ii.FileName = fileName;FileStream fs;fs = new FileStream(fileName, FileMode.Open, FileAccess.Read);Bitmap source= (Bitmap)System.Drawing.Bitmap.FromStream(fs);fs.Close();ii.bmp = new Bitmap(source);ii.Classification = classNum;itemList.Add(ii);}}}
各動物の画像を学習用データに加える

*internal class TrainFactory*{public BagOfVisualWords bagofVW;public TrainFactory(int codeWordCount, BagOfVisualWords bagofVW, List<ImageItem> itemList){BinarySplit binarySplit = new BinarySplit(codeWordCount);bagofVW = new BagOfVisualWords(binarySplit);List<Bitmap> bitmapList = new List<Bitmap>();foreach (ImageItem item in itemList){bitmapList.Add(item.bmp);}Bitmap[] trainImages = bitmapList.ToArray();bagofVW.Learn(trainImages);foreach (ImageItem item in itemList){item.codeWord = bagofVW.Transform(item.bmp);}this.bagofVW = bagofVW;}}
訓練用インプットデータを作成する

*internal class InputFactory*{public double[][] input;public InputFactory(List<ImageItem> list){var inputList = new List<double[]>();foreach (ImageItem item in list){inputList.Add(item.codeWord);}input = inputList.ToArray();}}
学習用インプットデータを作成する

*internal class OutputFactory*{public int[] output;public OutputFactory(List<ImageItem> list){var outputList = new List<int>();foreach (ImageItem item in list){outputList.Add(item.Classification);}output = outputList.ToArray();}}
学習用アウトプットデータを作成する

*private void Button_Click(object sender, RoutedEventArgs e)*{this.Close();}
アプリを終了する

*private void Button_Click_1(object sender, RoutedEventArgs e)*{Bitmap bitmap = new BitmapFactory(inkCanvas).bitmap;double[] codeword = bagofVW.Transform(bitmap);int classResult = msvm.Decide(codeword);textBox1.Text = "Result:" + Convert.ToString(classResult) + "\r\n";String cryStr;if (classResult == 0){cryStr = @"・・・ねこのなきごえ.mp3";}else if (classResult == 1){cryStr = @"・・・とりのなきごえ.mp3";}else{cryStr = @"・・・いぬのなきごえ.mp3";}Uri cryFile = new Uri(cryStr);mediaPlayer.Open(cryFile);mediaPlayer.Play();,,,//フィードバック// Configure the message box to be displayedstring messageBoxText = "猫ならYes、犬ならNo、鳥ならCancelを押してください。";string caption = "フィードバック";MessageBoxButton button = MessageBoxButton.YesNoCancel;MessageBoxImage icon = MessageBoxImage.Question;// Display message boxMessageBoxResult result = MessageBox.Show(messageBoxText, caption, button, icon);string animalStr = "";// Process message box resultsswitch (result){//猫case MessageBoxResult.Yes:animalStr = "cats";break;//犬case MessageBoxResult.No:animalStr = "dogs";break;//鳥case MessageBoxResult.Cancel:animalStr = "birds";break;}string saveDi = Path.Combine(directoryPath, animalStr);string imagePath = DateTime.Now.ToString("yyyyMMddhhmmss") + ".jpg";string savePath = Path.Combine(saveDi, imagePath);SaveImage(savePath);//再学習StartLearning();}
判定するイラストの読み込みと鳴き声

*string messageBoxText = "猫ならYes、犬ならNo、鳥ならCancelを押してください。";
フィードバック
Configure the message box to be displayed

*case MessageBoxResult.Yes:
猫

*case MessageBoxResult.No:
犬

*case MessageBoxResult.Cancel:
鳥

*StartLearning();
再学習

*private void SaveImage(string file)*{Rect rectBounds = inkCanvas.Strokes.GetBounds();DrawingVisual dv = new DrawingVisual();DrawingContext dc = dv.RenderOpen();dc.PushTransform(new TranslateTransform(-rectBounds.X, -rectBounds.Y));dc.DrawRectangle(inkCanvas.Background, null, rectBounds);inkCanvas.Strokes.Draw(dc);dc.Close();RenderTargetBitmap rtb = new RenderTargetBitmap((int)rectBounds.Width, (int)rectBounds.Height,96, 96,PixelFormats.Default);rtb.Render(dv);BitmapEncoder enc = new JpegBitmapEncoder();if (enc != null){enc.Frames.Add(BitmapFrame.Create(rtb));System.IO.Stream stream = System.IO.File.Create(file);enc.Save(stream);stream.Close();}}
InkCanvasを画像として保存する

*private void Button_Click_2(object sender, RoutedEventArgs e)*{inkCanvas.Strokes.Clear();}
お描き画像を消す

*internal class BitmapFactory*{public Bitmap bitmap;private InkCanvas inkCanvas;public BitmapFactory(InkCanvas inkCanvas){this.inkCanvas = inkCanvas;double width = inkCanvas.ActualWidth;double height = inkCanvas.ActualHeight;RenderTargetBitmap bmpCopied = new RenderTargetBitmap((int)Math.Round(width), (int)Math.Round(height), 96, 96, PixelFormats.Default);DrawingVisual dv = new DrawingVisual();using (DrawingContext dc = dv.RenderOpen()){VisualBrush vb = new VisualBrush(inkCanvas);dc.DrawRectangle(vb, null, new Rect(new System.Windows.Point(), new System.Windows.Size(width, height)));}bmpCopied.Render(dv);System.Drawing.Bitmap bitmap;using (MemoryStream outStream = new MemoryStream()){BitmapEncoder enc = new BmpBitmapEncoder();enc.Frames.Add(BitmapFrame.Create(bmpCopied));enc.Save(outStream);bitmap = new System.Drawing.Bitmap(outStream);}this.bitmap = bitmap;}}
InkCanvasをBitMapで返す


*Thread.Sleep(100);
ちょっと待つ

*Task.Run(() => {// スレッド終了を何も考えていない while (true)// 実際は、キーが入力されたらスレッドを終了する、などが必要while (true){var data = sharedQueue.Poll();Console.WriteLine($"Poll: {data}");}});
Consumerスレッド生成＆開始

*while (true)
スレッド終了を何も考えていない while (true)
実際は、キーが入力されたらスレッドを終了する、などが必要


*Console.WriteLine(mock.DoSomething);
=> True


*input.mi.dwFlags = 0x0001;
MOVE (RELATIVE)


*private StatusLife[,] calc_cell_1step(StatusLife[,] field, int size_x, int size_y)
外周1マスは端をつなげるための領域である
return:field[size_x,size_y]

*for (int x = 0; x < size_x; x++)
4隅
f_calc[0, 0] = field[size_x - 1, size_y - 1];           左上
f_calc[size_x + 1, 0] = field[0, size_y - 1];           右上
f_calc[size_x + 1, size_y + 1] = field[0, 0];            右下
f_calc[0, size_y + 1] = field[size_x - 1, 0];            左下
外枠直線
上下


*if (start < 0) throw new ArgumentOutOfRangeException(nameof(start));*if (end <= start) throw new ArgumentException("start must be less than end.");
引数の評価処理も反復子に含まれている為、実際に反復処理が行われるまで評価が遅延されてしまう。

*if (start < 0) throw new ArgumentOutOfRangeException(nameof(start));*if (end <= start) throw new ArgumentException("start must be less than end.");
反復子がローカル関数に隔離されているので、引数の評価は即時に行われる。

*public Person(string name) {_name = name;}
コンストラクター

*~Person() {Console.Error.WriteLine("Finalized");}
ファイナライザー

*public string Name {get { return _name; }set { _name = value; }}
プロパティ

*public Person(string name) => _name = name;
コンストラクター

*~Person() => Console.Error.WriteLine("Finalized");
ファイナライザー

*public string Name {get => _name;set => _name = value;}
プロパティ

*public Person(string name) {Name = name ?? throw new ArgumentNullException(nameof(name));}
null 合体演算子

*public string GetFirstName() {var parts = Name.Split(' ');return (parts.Length > 0) ? parts[0] : throw new InvalidOperationException("No name!");}
条件演算子

*public string GetLastName() => throw new NotImplementedException();
式形式のラムダ


*var unspec = new DateTime(2017, 12, 25, 20, 0, 0);
未指定なので、DateTimeKind.Unspecified

*,,,
Kindがローカルのものを変換
var localToLocal = local.ToLocalTime();     2017-12-25 20:00:00 <- JSTのまま
var localToUtc = local.ToUniversalTime();   2017-12-25 11:00:00 <- UTCに
KindがUTCのものを変換
var utcToLocal = utc.ToLocalTime();         2017-12-26 05:00:00 <- JSTに
var utcToUtc = utc.ToUniversalTime();       2017-12-25 20:00:00 <- UTCのまま
Kindを明示しなかったものを変換
var unsToUtc = unspec.ToUniversalTime();    2017-12-25 11:00:00 <- Unspecified = Localだと判断されてUTCに
var unsToLocal = unspec.ToLocalTime();      2017-12-26 05:00:00 <- Unspecified = Utcだと判断されてJSTに
インスタンス間の差を計算。9時間の時差はあるが、差は0という結果。
TimeSpan sub = local.Subtract(utc);     local - utc も可。 sub.TotalSeconds == 0

*Jst = new DateTime(2017, 12, 25, 13, 0, 0, DateTimeKind.Local),
DateTime型
Kindプロパティ：Local

*Unspec = new DateTime(2017, 12, 25, 13, 0, 0),Kindプロパティ：UtcUtc = new DateTime(2017, 12, 25, 13, 0, 0, DateTimeKind.Utc),DateTimeOffsetUTCからのタイムゾーンのズレ：9時間(日本時間)JstOffset = new DateTimeOffset(2017, 12, 25, 13, 0, 0, TimeSpan.FromHours(9)),UTCUtcOffset = new DateTimeOffset(2017, 12, 25, 13, 0, 0, TimeSpan.FromHours(0))};
Kindプロパティ：明示しないので、Unspecifiedになる

*Utc = new DateTime(2017, 12, 25, 13, 0, 0, DateTimeKind.Utc),DateTimeOffsetUTCからのタイムゾーンのズレ：9時間(日本時間)JstOffset = new DateTimeOffset(2017, 12, 25, 13, 0, 0, TimeSpan.FromHours(9)),UTCUtcOffset = new DateTimeOffset(2017, 12, 25, 13, 0, 0, TimeSpan.FromHours(0))};
Kindプロパティ：Utc

*JstOffset = new DateTimeOffset(2017, 12, 25, 13, 0, 0, TimeSpan.FromHours(9)),UTCUtcOffset = new DateTimeOffset(2017, 12, 25, 13, 0, 0, TimeSpan.FromHours(0))};
UTCからのタイムゾーンのズレ：9時間(日本時間)

*UtcOffset = new DateTimeOffset(2017, 12, 25, 13, 0, 0, TimeSpan.FromHours(0))};
UTC

*document = new DateTimeCheck{Jst = new DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Local),Unspec = new DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Unspecified),Utc = new DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Utc),JstOffset = new DateTimeOffset(2017, 12, 23, 13, 0, 0, TimeSpan.FromHours(9)),UtcOffset = new DateTimeOffset(2017, 12, 23, 13, 0, 0, TimeSpan.FromHours(0))};
元のドキュメント

*searchOutput = DateTimeCheck{Jst = DateTime(2017, 12, 23, 4, 0, 0, DateTimeKind.Utc),Unspec = DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Utc),Utc = DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Utc),JstOffset = DateTimeOffset(2017, 12, 23, 4, 0, 0, TimeSpan.FromHours(0)),UtcOffset = DateTimeOffset(2017, 12, 23, 13, 0, 0, TimeSpan.FromHours(0)),};
取得したドキュメント

*document = new DateTimeCheck{Jst = new DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Local),Unspec = new DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Unspecified),Utc = new DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Utc),JstOffset = new DateTimeOffset(2017, 12, 23, 13, 0, 0, TimeSpan.FromHours(9)),UtcOffset = new DateTimeOffset(2017, 12, 23, 13, 0, 0, TimeSpan.FromHours(0))};
元のドキュメント

*cosmosOutput = DateTimeCheck{Jst = DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Local),Unspec = DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Unspecified),Utc = DateTime(2017, 12, 23, 13, 0, 0, DateTimeKind.Utc),JstOffset = DateTimeOffset(2017, 12, 23, 13, 0, 0, TimeSpan.FromHours(9)),UtcOffset = DateTimeOffset(2017, 12, 23, 22, 0, 0, TimeSpan.FromHours(9))};
取得したドキュメント


*IEnumerable<int> numbers = Enumerable.Range(1, 100);
1から100までの偶数の和を表示する

*IEnumerable<int> numbers = Enumerable.Range(1, 100);
1から100までの偶数の和を表示する

*IEnumerable<int> numbers = Enumerable.Range(1, 100);
1から100までの整数に101が含まれていないか？

*IEnumerable<int> numbers = Enumerable.Range(1, 100);
1から100までの整数に101が含まれていないか？

*Debug.Log(string.Format("{0}: {1}", nameof(_hoge), _hoge));
※ nameof演算子もC# 6.0相当の機能


*public OrderedDictionary<string, OrderedDictionary<string, string>> SectionDic { get; set; }
Iniファイル情報格納(OrderedDictionary型)

*public DataSet SectionDataSet { get; set; }
Iniファイル情報格納(DataSet型)

*public Encoding Encording { get; set; }
エンコーディング

*public string SectionSeparator { get; set; }
セクション番号区切り文字

*public string KeySeparator { get; set; }
キー番号区切り文字

*public string InsertSpace { get; set; }
セクションと値の間の空白

*public string RootName { get; set; }
XML用ルート名

*public const string SECTION_GROUP_ATTR = "Grp";
セクショングループ用属性値

*public const string PARAMETER_INDEX_ATTR = "Idx";
パラメーターグループ用属性値

*public const string DEFAULT_ROOT_NAMER = "Root";
XML用ルート名

*const string SECTION_PATTERN = @"^\s*\[(?<section>[^\]]+)\].*$";
セクション用正規表現パターン

*const string PARAMETER_PATTERN = @"^\s*(?<name>[^=]+)=(?<value>.*?)(\s+;(?<comment>.*))?$";
パラメーター用正規表現パターン

*public IniManager()*{Encording = Encoding.UTF8;SectionSeparator = "";KeySeparator = "";InsertSpace = " ";RootName = DEFAULT_ROOT_NAMER;}
コンストラクタ

*SectionDic = GetSections(filePath);
Ini情報のセット

*if (isDataSet) return ToDataSet();*return true;
DataSet型に変換

*string xml = ConvertDicToXML();
XMLデータに変換する

*using (StringReader reader = new StringReader(xml)){SectionDataSet.ReadXml(reader);
DataSet型に変換する

*sections[string.Empty] = new OrderedDictionary<string, string>();
セクション名が明示されていない先頭部分のセクション名を""として扱う

*if (IsBlank(line))*continue;
空行は読み飛ばす

*if (line.StartsWith(";", StringComparison.Ordinal))*continue;
コメント行は読み飛ばす

*sections[currentSection][matchNameValue.Groups["name"].Value.Trim()] = matchNameValue.Groups["value"].Value.Trim();
name=valueの行

*currentSection = matchSection.Groups["section"].Value;
[section]の行

*var dic = GetSections(filePath);
Iniファイル情報を取得する

*var sortSections = new OrderedDictionary<string, OrderedDictionary<string, string>>(StringComparer.Ordinal);
並び替えた情報を格納

*if (sortSections.ContainsKey(sec.Key) && sortSections[sec.Key].ContainsKey(pair.Key))*continue;
既に登録済みなら何もしない

*if (!sortSections.ContainsKey(sec.Key))*sortSections[sec.Key] = new OrderedDictionary<string, string>();
未登録なら追加する

*Dictionary<string, string> lastdic = new Dictionary<string, string>();
セクションの最終キーを格納

*//if (!result) return false;*result = Write(filePath, sortSections, lastdic);
result = WriteIni(section.Key, pair.Key, pair.Value, filePath);

*sections[string.Empty] = new OrderedDictionary<string, string>();
セクション名が明示されていない先頭部分のセクション名を""として扱う

*bool isContinue = IsBlank(line);
空行は読み飛ばす

*if (line.StartsWith(";", StringComparison.Ordinal))*isContinue = true;
コメント行は読み飛ばす

*if (sortSections.Count == 0)*isContinue = true;
全て終わった

*var matchNameValue = regexNameValue.Match(line);
存在しなかったら追記

*string keyName = matchNameValue.Groups["name"].Value.Trim();
name=valueの行

*newline = line.Replace(curvalue, value);
現在値に空白が含まれていた場合、単純な置換(キーやコメントなども置換される可能性がある)

*newline = Regex.Replace(line, @"(=\s+|=)([^;|\s]+)(\s+;.*|)", "${1}" + value + "${3}");
現在値に空白が含まれていない場合、値のみ置換

*isSave = true;
現在値と違う値なら保存する

*newline = Regex.Replace(line, @"(=)(\s[^;].*)", "${1}" + InsertSpace + value + "${2}");
= の位置に半角スペースを1つ空けて値をセット

*if (newline != line) isSave = true;*}
現在値と違う値なら保存する

*sb.AppendLine(newline);
書き換え行のセット

*sortSections.Remove(currentSection);
セクションを削除する

*isExistsSection = true;
対象のセクション行が存在

*sb.AppendLine(line);
行のセット

*sb.AppendLine(string.Format("{0}" + InsertSpace + "=" + InsertSpace + "{1}", pair.Key, pair.Value));
パラメーターを追加する

*OrderedDictionary<string, int> secCount = GetSectionGroupCount();
同一名カウントチェック

*if (grpno == -1 && key != "" && secCount[key] > 1) grpno = 0;*// パラメーターが連番のみかチェック
複数存在するならグループ扱い

*bool isDataGrp = true;
パラメーターが連番のみかチェック

*sb.AppendLine(string.Format("<{0}>{1}</{0}>", pkey, pair.Value));
セクションが無い場合

*Regex re = new Regex(@"\s");
空行(全角スペース、タブ、半角スペースのみを対象にする)


*using (var res = await client.GetAsync("http:
localhost:10001").ConfigureAwait(false))

*static async Task MultiThreadedHttpWebRequest()*{// Do 1000 concurrent tasks, loop 10 timesvar tasks = Enumerable.Range(0, 1000).Select(async idx =>{for (int i = 0; i < 10; i++){try{// HttpWebRequestはそのリクエストごとに毎回インスタンスを作成するvar client = HttpWebRequest.CreateHttp("http://localhost:10001");using(var res = client.GetResponse() as HttpWebResponse){if((int)res.StatusCode < 200 || (int)res.StatusCode >= 300 ){throw new Exception($"http response failed:{res.StatusCode}");}}break;}catch (Exception e){Console.WriteLine($"error({idx},{i}): {e}");}}Console.WriteLine($"done{idx}");}).ToArray();await Task.WhenAll(tasks).ConfigureAwait(false);Console.WriteLine($"all done");}
予めhttp:localhost:10001で適当なhttpサーバーを動かしておく

*var tasks = Enumerable.Range(0, 1000).Select(async idx =>*{for (int i = 0; i < 10; i++){try{// HttpWebRequestはそのリクエストごとに毎回インスタンスを作成するvar client = HttpWebRequest.CreateHttp("http://localhost:10001");using(var res = client.GetResponse() as HttpWebResponse){if((int)res.StatusCode < 200 || (int)res.StatusCode >= 300 ){throw new Exception($"http response failed:{res.StatusCode}");}}break;}catch (Exception e){Console.WriteLine($"error({idx},{i}): {e}");}}Console.WriteLine($"done{idx}");}).ToArray();
Do 1000 concurrent tasks, loop 10 times

*using(var res = client.GetResponse() as HttpWebResponse)
HttpWebRequestはそのリクエストごとに毎回インスタンスを作成する
var client = HttpWebRequest.CreateHttp("http:localhost:10001");


*var decrypted = crypter.TryDecrypt(encrypted);
bytes[] { 0, 1, 2}


*"https:
www.twilio.comdocsdocuments25justthefaxmaam.pdf");


*[SerializeField] GameObject m_ProjectilePrefab;
ボールのプレファブ

*}
到達した後の処理はこの下に


*// labelShift*//


*this.labelShift.AutoSize = true;*this.labelShift.Font = new System.Drawing.Font("MS UI Gothic", 48F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(128)));


*int AtoZ = 0;
A-Zキーが押されているときは非0が入る


*SetPlayerName ("Player-Id: " + PhotonNetwork.player.ID);
初期設定

*void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info) {if (stream.isWriting) {// 自分の情報を送るstring myName = this.gameObject.name;int myHealthPoint = m_healthPoint;stream.SendNext (myName);stream.SendNext (myHealthPoint);} else {// 他人の情報を受け取るstring otherName = (string)stream.ReceiveNext();int otherHealthPoint = (int)stream.ReceiveNext();SetPlayerName (otherName);SetHealthPoint (otherHealthPoint);}}
ストリーム同期

*string myName = this.gameObject.name;
自分の情報を送る

*string otherName = (string)stream.ReceiveNext();
他人の情報を受け取る

*[PunRPC]*void Shoot(Vector3 i_pos, Vector3 i_angle) {Quaternion rot = Quaternion.Euler (i_angle);GameObject bullet = GameObject.Instantiate (m_BulletPrefab ,i_pos ,rot);bullet.GetComponent<Rigidbody> ().AddForce (transform.forward * 20, ForceMode.VelocityChange);Destroy(bullet, 3);}
イベント同期

*SetHealthPoint (m_healthPoint - 10);
ダメージを受ける

*Vector3 pos = transform.position + transform.forward * 2f;*Vector3 angle = transform.eulerAngles;
自分自身の弾丸でトリガーを引かないようにやや手前から発射

*m_photonView.RPC ("Shoot", PhotonTargets.AllViaServer, pos, angle);
処理が重いのでPhotonViewを付けずに位置と角度を渡す

*var v = Input.GetAxis ("Vertical");
キーボード入力による移動処理

*var h = Input.GetAxis ("Horizontal");
キーボード入力による回転処理

*===============================public void SetPlayerDeathState( bool isDeath ) {var properties  = new ExitGames.Client.Photon.Hashtable();
ここから重要

*public void SetPlayerDeathState( bool isDeath ) {var properties  = new ExitGames.Client.Photon.Hashtable();properties.Add ("player-id", PhotonNetwork.player.ID);properties.Add ("isDeath", isDeath);PhotonNetwork.player.SetCustomProperties( properties );}
===============================

*var aliveList = new ArrayList();
全員分回す


*GameObject avatar = PhotonNetwork.Instantiate ("Avatar", new Vector3(0f,1f,0f), Quaternion.identity, 0);
自分のアバターを他のクライアントにも生成

*SetPlayerName ("Player-Id: " + PhotonNetwork.player.ID);
初期設定

*void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info) {if (stream.isWriting) {// 自分の情報を送るstring myName = this.gameObject.name;int myHealthPoint = m_healthPoint;stream.SendNext (myName);stream.SendNext (myHealthPoint);} else {// 他人の情報を受け取るstring otherName = (string)stream.ReceiveNext();int otherHealthPoint = (int)stream.ReceiveNext();SetPlayerName (otherName);SetHealthPoint (otherHealthPoint);}}
ストリーム同期

*string myName = this.gameObject.name;
自分の情報を送る

*string otherName = (string)stream.ReceiveNext();
他人の情報を受け取る

*[PunRPC]*void Shoot(Vector3 i_pos, Vector3 i_angle) {// 全クライアントの中の自分が一斉に弾丸を発射するQuaternion rot = Quaternion.Euler (i_angle);GameObject bullet = GameObject.Instantiate (m_BulletPrefab ,i_pos ,rot);bullet.GetComponent<Rigidbody> ().AddForce (transform.forward * 20, ForceMode.VelocityChange);Destroy(bullet, 3);}
イベント同期

*Quaternion rot = Quaternion.Euler (i_angle);
全クライアントの中の自分が一斉に弾丸を発射する

*SetHealthPoint (m_healthPoint - 10);
ダメージを受ける

*Vector3 pos = transform.position + transform.forward * 2f;*Vector3 angle = transform.eulerAngles;
自分自身の弾丸でトリガーを引かないようにやや手前から発射

*m_photonView.RPC ("Shoot", PhotonTargets.AllViaServer, pos, angle);
処理が重いのでPhotonViewを付けずに位置と角度を渡す

*var v = Input.GetAxis ("Vertical");
自分のアバターだけを動かす


*int BUFFER_SIZE = 32;
バッファーサイズ(あえて小さく設定)

*using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)){検索ブロック位置の繰り返しfor (int i = 0; ; i++)
ファイル共有モードで開く

*offset = Math.Min((int)fs.Length, (i + 1) * BUFFER_SIZE);
ブロック開始位置に移動

*if (foundCount > 0 || fs.Length > 0) break;*// 行が未存在
ファイルの先頭まで達した場合

*throw new ArgumentOutOfRangeException("NOT FOUND DATA");
行が未存在

*int readLength = offset - BUFFER_SIZE * i;
ブロックの読み込み

*loc = k + 1;
所定の行数が見つかった場合

*fs.Seek(-offset + loc, SeekOrigin.End);
見つかった場合


*void Start () {}
Use this for initialization

*void Update () {transform.position =GameObject.Find("Main Camera").transform.position+ InputTracking.GetLocalPosition(XRNode.RightHand)- InputTracking.GetLocalPosition(XRNode.Head);transform.eulerAngles =InputTracking.GetLocalRotation(XRNode.RightHand).eulerAngles;}
Update is called once per frame

*public Transform muzzle;*// 弾丸の速度
弾丸発射点

*public float speed = 1000;
弾丸の速度

*void Start () {}
Use this for initialization

*void Update () {time += Time.deltaTime;if(Input.GetAxis("10th axis") == 1F && time > 1){Debug.Log("Fire");// 弾丸の複製GameObject bullets = GameObject.Instantiate(bullet) as GameObject;// 弾丸の位置を調整bullets.transform.position = muzzle.position;bullets.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * speed);cannon2 = GetComponent<AudioSource>();cannon2.PlayOneShot(cannon2.clip);time = 0;}transform.position =GameObject.Find("Main Camera").transform.position +InputTracking.GetLocalPosition(XRNode.RightHand)-InputTracking.GetLocalPosition(XRNode.Head);transform.eulerAngles = InputTracking.GetLocalRotation(XRNode.RightHand).eulerAngles;}
Update is called once per frame

*GameObject bullets = GameObject.Instantiate(bullet) as GameObject;
弾丸の複製

*bullets.transform.position = muzzle.position;*bullets.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * speed);
弾丸の位置を調整


*var googleHomeWebhookUrl = "https:
xxxxxxxx.ngrok.iogoogle-home-notifier";


*}
ここでStyleCopを呼ぶ

*var tmpLogs = new List<string>();
全ファイルを表示するとログ出力がTruncateされるので違反が出たファイルと箇所だけ表示するように整形

*bool existsViolation = violationCount > 0;
結果をまとめる


*int total = items.Sum();
最低限必要なビンを用意し、listに入れる

*var target = binList.Select(b => new { Bin = b, Space = BinSize - b.Sum(t => t) })
nが入るビンを見つける （空きが最大のビン）

*bin.Add(n);*} else {
nが入るビンが見つかったので、そこに入れる

*List<int> bin2 = new List<int>() { n };
見つからなかったので、新しいビンを用意する

*private static void PrintResult(IEnumerable<IEnumerable<int>> result) {var sb = new StringBuilder();foreach (var bin in result) {var list = string.Join(",", bin.Select(n => n.ToString()).ToArray());var sum = bin.Sum();sb.AppendLine($"{sum,5}: [{list}]");}Console.WriteLine(sb.ToString());}
結果を表示


*unit.Code = c;
unit を初期化


*var indexPath = "http:
127.0.0.1:80sample.html";


*var builder = new DeserializerBuilder();
デシリアライザをデフォルトの設定で生成

*SomeObject deserializedObj = null;
ファイルの内容をSomeObjectにデシリアライズ

*Console.WriteLine(string.Format("Number : {0}", deserializedObj.Number));
結果をコンソール出力


*internal static int sub(int v1, int v2)*{throw new NotImplementedException();}
返り値intできちんとつくられた！


*var settings = new ConnectionConfiguration(new Uri("http:
" + host + ":" + port))

*public static class Extensions*{public static IEnumerable<IEnumerable<T>> Chunks<T>(this IEnumerable<T> list, int size){while (list.Any()){yield return list.Take(size);list = list.Skip(size);}}}
from https:webbibouroku.com/Blog/Article/chunk-linq


*Select(element).SelectByText("text");
表示テキスト


*animation?.TryStart(DestinationImage, new UIElement[] { DescriptionRoot });
省略


*Debug.Log("マイナス側：" + _numberLoopList[-_index]);
0 3 2 1 0 3 2 1...


*string modelFile = @"E:\****\beginner-const-graph.pb.pb";
シリアル化されたGraphDefをファイルからロードします。

*runner.AddInput(graph["input"][0], tensor);
学習モデルのグラフを指定する。
入出力テンソルの名前をsessionに登録する


*Console.WriteLine(outputStr);
StorageのShaaredAccessSignatureのテスト

*await new CloudBlobContainer(new Uri(setting.WriteContainerSas))
書込SasUriを利用してアクセス


*Console.WriteLine(query);
2, 4, 6


*NSApplication.SharedApplication.Delegate = new AppDelegate();
SharedApplication に触れるのは Init の後


*string NonErrorHandling(string name){return $"Hello! {name}";}
メソッド定義

*var userName = "Sho";
呼び出し

*string ReturningResultOnly(string name)*{if (string.IsNullOrEmpty(name)) return null;return $"Hello! {name}";}
メソッド定義

*var userName = "Sho";
呼び出し

*string ReturningResultOrErrorCode(string name)*{if (string.IsNullOrEmpty(name)) return "E001";// some validation with return error code "Exxx";return $"Hello! {name}";}
メソッド定義

*return $"Hello! {name}";
some validation with return error code "Exxx";

*var userName = "Sho";
呼び出し

*bool ReturningIsValidAndSettingResultToOutVar(string name, out string greeting)*{if (string.IsNullOrEmpty(name)){greeting = null;return false;}greeting = $"Hello! {name}";return true;}
メソッド定義

*var userName = "Sho";
呼び出し

*greeting = $"Hello! {name}";
some validation with return error code "Exxx";

*var userName = "Sho";
呼び出し

*enum ErrorType*{NoError,NameIsEmpty,// SomeError}
エラーの種類

*ErrorType ReturningErrorTypeAndSettingResultToOutVar(string name, out string greeting)*{if (string.IsNullOrEmpty(name)){greeting = null;return ErrorType.NameIsEmpty;}// some validation with return error code "Exxx";greeting = $"Hello! {name}";return ErrorType.NoError;}
メソッド定義

*greeting = $"Hello! {name}";
some validation with return error code "Exxx";

*var userName = "Sho";
呼び出し

*enum ErrorType*{NoError,NameIsEmpty,// SomeError}
エラーの種類

*(string result, ErrorType errorType) ReturningResultAndErrorAsValueTuple(string name)*{if (string.IsNullOrEmpty(name)){return (null, ErrorType.NameIsEmpty);}// some validation with return error code "Exxx";return ($"Hello! {name}", ErrorType.NoError);}
メソッド定義

*return ($"Hello! {name}", ErrorType.NoError);
some validation with return error code "Exxx";

*var userName = "Sho";
呼び出し

*class MyException : Exception*{public string ErrorCode {get; set;}}
独自定義の例外

*(string result, Exception exception) ReturningResultAndExceptionAsValueTuple(string name)*{if (string.IsNullOrEmpty(name)){return (null, new ArgumentNullException(nameof(name)));}string person = FindByName(name);if (person == null){return (null, new MyException { ErrorCode = "E001" });}return ($"Hello! {name}", null);}
メソッド定義

*return null;
見つからなかった

*var userName = "Sho";
呼び出し

*string ReturningResultAndThrowingBusinessException(string name)*{if (string.IsNullOrEmpty(name)) throw new ArgumentNullException(nameof(name));return $"Hello! {name}";}
メソッド定義

*var userName = "Sho";
呼び出し


*mock.Object.DoSomething("abc");
-> "ABC"


*object excelBooks = excelApp.GetType().InvokeMember("Workbooks", BindingFlags.GetProperty, null, excelApp, null);
ワークブックコレクションオブジェクトを生成する。

*object excelBook = excelBooks.GetType().InvokeMember("Open", BindingFlags.InvokeMethod, null, excelBooks,new object[]{strMacroPath,System.Type.Missing, System.Type.Missing, System.Type.Missing,System.Type.Missing, System.Type.Missing, System.Type.Missing,System.Type.Missing, System.Type.Missing, System.Type.Missing,System.Type.Missing, System.Type.Missing, System.Type.Missing});
Excelファイルのオープン

*public static object call(object o, string name, params object[] args)*{return o.GetType().InvokeMember(name, BindingFlags.InvokeMethod, null, o, args);}
paramsは可変長引数

*var presentation = OLEHelper.call(presentations, "Open", path);
Openの引数は4つあるが必要な数だけ渡すので大丈夫らしい

*OLEHelper.freeObject(presentations);
presentationsを解放しても開いたpresentationに影響はない

*OLEHelper.freeObject(slideshowview);
オブジェクトを全部解放しないとウインドウが閉じられない


*SampleInterpreter.Execute("1*(1-1)");
=> "0"


*if (mouseDownFlag) pictureBox2.Width = e.X;
ドラッグ中にオレンジの波形の幅を変更

*audioFile.Position = (int)(((double)e.X / pictureBox1.Width) * audioFile.Length);
ドラッグが終了した場所から曲の再生位置を計算して設定


*Cells = Enumerable.Range(0, CountRowColumn).Select(row =>
セルの生成

*.Select(p => new Cell { Position = p }))
位置をセルに変換

*.SelectMany(x => x)
1次元に平坦化

*Cells.ForEach(cell => cell.SetNeiberCells(Cells));
全セルに自身の隣人を登録させる

*Generation = timer.ToReadOnlyReactiveProperty();
Timerの更新回数を現在の世代として公開

*timer.Subscribe(_ =>{並列で全セルに次の世代での生死を決定Cells.AsParallel().ForEach(c => c.DetermineNextGeneration());
Timer実行内容の登録

*Cells.AsParallel().ForEach(c => c.DetermineNextGeneration());
並列で全セルに次の世代での生死を決定

*Cells.ForEach(c => c.UpdateGeneration());
生死の更新

*ReadSavedStatesFromFile();
登録パターンをファイルから呼び出す

*var aliveCellPositions = GetAlivePositions();
生存しているセルの位置情報を集める

*var minPosition = new Position();
左上端の位置を計算

*var currentState = new WorldState{Name = saveName,AliveCellPositions = aliveCellPositions位置パターンを左上つめ（最小化）する.Select(x => x - minPosition)
保存パターンの生成

*.Select(x => x - minPosition)
位置パターンを左上つめ（最小化）する

*this.SavedStates.Add(currentState);
パターンコレクションに追加

*WriteSavedStatesToFile();
パターンコレクションをファイル保存

*var maxPosition = new Position();
生存セルが中央に配置されるように調整

*Cells.ForEach(c =>c.IsAlive = centerdAlivePositions.Any(p => p == c.Position));
生存セルリストと位置が一致していたら生、していなかったら死に変更

*else*{//誕生なら生if (countneiberAlive == 3){return true;}}
死んでいて、

*return currentAlive;
それ以外はそのまま


*int n = Encoding.GetEncoding("Shift_JIS").GetByteCount("字");*,,,
半角なら 1, 全角なら 2

*var srcmap = new List<MapData>();*var kindTexts = new List<string>(new string[] { "_", "N", "A", "H", "W", "F", "Na", });
読み込み

*var map = new List<int>();
undefined も含めたマッピング構築

*throw new InvalidDataException();
昇順になっていない場合は異常と判断

*int cp = char.ConvertToUtf32(elm[0], elm[1]);
サロゲートペアの場合

*this.column += this.GetWidth(elm[0]);
結合文字は、１文字目だけで判定


*1 : 1
結果

*Console.WriteLine("[" + target.PadRight(197-192) + "]");
結果 [123  ]

*Console.WriteLine("[" + target.PadRight(197-192 + 1) + "]");
結果 [123   ]


*InputedText = "Init Value";
画面初期表示時に表示したい文字をセットしておく

*this.DataContext = new MainWindowViewModel();
viewはDataContext経由でViewModelを取得するので、設定する

*MessageBox.Show(_vm.InputedText);
テストなのでメッセージを出すだけにしとく


*int index = String.Empty.Length;
0をセット


*await waitQueueTask;
実際に待ち合わせを行う

*while (_queue.TryDequeue(out var t)) await t(ct);*}
キューイングされているものを待つ

*var waitLoginTask = _onLoggedIn.FirstAsync(x => x.userId == userId).ToTask();
先にTaskを起動しておかないとMock等で即コールバックが呼ばれた時に取りこぼす


*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"


*,,,
（1行の場合）

*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame

*void Start () {}
オブジェクト起動時に実行

*void Update () {}
フレーム毎に連続実行

*public void ObjectSetActive()*{//hogeObjectをアクティブにするhogeObject.SetActive(true);}
このメソッドが呼び出されたときに実行

*hogeObject.SetActive(true);
hogeObjectをアクティブにする

*public GameObject hogeObject;
アクティブにしたいゲームオブジェクト（キャラクター、ボタンなど）

*public void ObjectSetActive()*{//hogeObjectをアクティブにするhogeObject.SetActive(true);}
このメソッドが呼び出されたときに実行

*hogeObject.SetActive(true);
hogeObjectをアクティブにする

*public void ObjectSetActive()*{//hogeObjectをアクティブにするhogeObject.SetActive(true);}
このメソッドが呼び出されたときに実行

*hogeObject.SetActive(true);
hogeObjectをアクティブにする


*List<string> func1(List<Student> data){List<string> output;foreach(var student in data){if(student.Height >= 170){output.Add(student.Name);}}return output;}
学生の一覧から、身長が170cm以上の者達の名前の一覧を作成する

*List<string> func2(List<Student> data){return data.Where(s => s.Height >= 170).Select(s => s.Name).ToList();}
同上(LINQ版)

*func1();
処理1

*func2();
処理2(時間がかかる処理)

*func3();
処理3

*func1();
処理1

*await func2Async();
処理2(時間がかかる処理)
非同期処理する関数では、関数名の末尾にAsyncを付けるのが慣例

*func3();
処理3


*Console.WriteLine(roObs.Count);
1


*m_Mesh.Clear();
もともとあったコード。m_meshに頂点情報(座標と順番)や色情報を渡している |

*//Add following 2 lines. This cord attaches triangular mesh information to collider.*GetComponent<MeshCollider>().sharedMesh = null;
下記の2行を新たに追加。上記で作成した三角形の集合をコライダーに反映

*Session.CreateAnchor(Pose);
または


*#if !___server___*Task<
サーバ側のコンパイラスイッチには___server___の定数を指定

*ValueTask<int> TallyAsync(int a, int b#if !___server___, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)
戻り値ありはValueTask<T>

*Task MethodAsync(int a, int b#if !___server___, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)
戻り値なしはTask

*public interface Interface : INetStitchContract
SharedProjectに参照させる。
RPCで呼び出すインターフェースを識別するためにContractのインターフェースを指定

*var client = new NetStitchClient(url);
普通にインスタンス生成　オーバーロードにHttpClientの引数もあるため、認証周りはそちらで指定

*await client.Create<Interface>.TallyAsync(100, 4);
SharedProjectに定義したインターフェースをGenericの型に指定する

*public class Startup*{public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory){//クラスからDLLを参照し、DLLに含まれるINetStitchContractを継承した//メソッドを呼び出せるようにする。app.UseNetStitch(typeof(Startup));}}
ASP.Net Core で使ういつものやつ

*app.UseNetStitch(typeof(Startup));
クラスからDLLを参照し、DLLに含まれるINetStitchContractを継承した
メソッドを呼び出せるようにする。

*public class MyClass : Interface*{public async ValueTask<int> TallyAsync(int a, int b){return a + b;}}
SharedProjectに定義したインターフェースを実装するだけ


*/* ------------------------------*/
日付更新ファイルから日付を取得

*System.IO.FileStream fs = new System.IO.FileStream(filePath,System.IO.FileMode.OpenOrCreate,System.IO.FileAccess.ReadWrite,System.IO.FileShare.None);
排他ロックをかける

*TextFieldParser parser = new TextFieldParser(fs, Encoding.GetEncoding("Shift_JIS"));*parser.TextFieldType = FieldType.Delimited;
ファイル読込

*/* ------------------------------*/
キーに紐づく日付の加算

*/* ------------------------------*/
一つの文字列に格納

*/* ------------------------------*/
更新処理

*}*{// 成功}
失敗

*}
成功


*Write(array.ToArray());
こうして書き換えられるのを防止する


*private GraphicsCaptureBridge.Capture capture = null;
この行を追加

*capture = new GraphicsCaptureBridge.Capture(pictureBox1.Handle.ToInt64());
コンストラクタの段階ではウィンドウハンドルが生成されていないのでダメ


*Status s = tokens.Statuses.Update(status: "upload image", media_ids: ids);
画像をツイート


*class BinPackingSolver1 : IBinPacking {public int BinSize { get; set; }public BinPackingSolver1(int size) {this.BinSize = size;}public ICollection<ICollection<int>> Solve(int[] items) {// 最初に一つのビンを用意するvar binList = new List<ICollection<int>>();binList.Add(new List<int>());// 各項目をビンに入れてゆくforeach (var n in items) {// nが入るビンを見つける （空きが最大のビン）var target = binList.Select(b => new { Bin = b, Space = BinSize - b.Sum(t => t) }).Where(x => x.Space >= n).OrderByDescending(x => x.Space).Select(x => x.Bin);var bin = target.FirstOrDefault();if (bin != null) {// nが入るビンが見つかったので、そこに入れるbin.Add(n);} else {// 見つからなかったので、新しいビンを用意するList<int> bin2 = new List<int>() { n };binList.Add(bin2);}}return binList;}}
解法A：最も空きが多いビンに入れていく解法

*var binList = new List<ICollection<int>>();
最初に一つのビンを用意する

*var target = binList.Select(b => new { Bin = b, Space = BinSize - b.Sum(t => t) })
nが入るビンを見つける （空きが最大のビン）

*bin.Add(n);*} else {
nが入るビンが見つかったので、そこに入れる

*List<int> bin2 = new List<int>() { n };
見つからなかったので、新しいビンを用意する

*private static (int[] ,int) InputDate() {Console.Write("荷物の重さ(カンマ区切り)=> ");var itemsText = Console.ReadLine();var items = itemsText.Split(',').Select(x => int.Parse(x.Trim())).ToArray();Console.Write("1台のコンテナの容量=> ");var sizeText = Console.ReadLine();int binsize = int.Parse(sizeText);return (items, binsize);}
データの入力

*private static void PrintResult(IEnumerable<IEnumerable<int>> result) {var sb = new StringBuilder();foreach (var bin in result) {var list = string.Join(",", bin.Select(n => n.ToString()).ToArray());var sum = bin.Sum();sb.AppendLine($"{sum,5}: [{list}]");}Console.WriteLine(sb.ToString());}
結果を表示

*class BinPackingSolver2 : IBinPacking {public int BinSize { get; set; }public BinPackingSolver2(int size) {BinSize = size;}public ICollection<ICollection<int>> Solve(int[] items) {// 最初に一つのビンを用意するvar binList = new List<ICollection<int>>();binList.Add(new List<int>());// 各項目をビンに入れてゆくforeach (var n in items) {// nが入るビンを見つける （空きが最小のビン）var target = binList.Select(b => new { Bin = b, Space = BinSize - b.Sum(t => t) }).Where(x => x.Space >= n).OrderBy(x => x.Space).Select(x => x.Bin);var bin = target.FirstOrDefault();if (bin != null) {// nが入るビンが見つかったので、そこに入れるbin.Add(n);} else {// 見つからなかったので、新しいビンを用意するList<int> bin2 = new List<int>() { n };binList.Add(bin2);}}return binList;}}
解法０２：最も空きが少ないビンに入れていく解法

*var binList = new List<ICollection<int>>();
最初に一つのビンを用意する

*var target = binList.Select(b => new { Bin = b, Space = BinSize - b.Sum(t => t) })
nが入るビンを見つける （空きが最小のビン）

*bin.Add(n);*} else {
nが入るビンが見つかったので、そこに入れる

*List<int> bin2 = new List<int>() { n };
見つからなかったので、新しいビンを用意する


*StripeConfiguration.SetApiKey(ConfigurationManager.AppSettings["StripeSecretKey"]);
Stripe の初期設定

*private readonly HomeControlerService service;
カード処理を実装するアプリケーションサービス

*[Authorize]
商品を発注、カード決裁入力

*ViewBag.PublishableKey = ConfigurationManager.AppSettings["StripePublishableKey"];
カード情報入力画面（checkout.js）に必要な引数をセット（Stripeの公開鍵とメールアドレス）

*[HttpPost]
カード決済と、決裁結果を表示

*Response.Headers["Expires"] = "-1";
クロスドメインでも実行できるように

*service.Charge(stripeEmail, stripeToken);
課金処理

*ViewBag.Message = "エラー発生：" + ex.Message;
課金エラー処理
本当なら service からスローされたエラーを処理します
こんなアバウトなキャッチはだめですよ！(^^;;

*public void Charge(string stripeEmail, string stripeToken)*{var customersService = new StripeCustomerService();var chargesService = new StripeChargeService();StripeCustomer customer;Customer dbCustomer;// DBにメアドが存在しなければ、顧客登録を行うvar dbCustomers = AppDb.Customers.Where(c => c.Email == stripeEmail);if (dbCustomers.Count() == 0){// Stripe に顧客を追加customer = customersService.Create(new StripeCustomerCreateOptions{Email = stripeEmail,SourceToken = stripeToken});// DB に顧客を追加dbCustomer = new Customer(){Email = stripeEmail,StripeId = customer.Id};AppDb.Customers.Add(dbCustomer);AppDb.SaveChanges();}else{// Stripe の顧客を取得dbCustomer = dbCustomers.First();customer = customersService.Get(dbCustomer.StripeId);}// 課金を追加var charge = chargesService.Create(new StripeChargeCreateOptions{Amount = 1000,Currency = "jpy",Description = "Example charge",CustomerId = customer.Id});// ここで課金結果をDBに登録（今回は実装しない）// DBに charge.id を保管すれば、Stripe 側の課金情報と紐づけできる}
カード決裁処理

*var dbCustomers = AppDb.Customers.Where(c => c.Email == stripeEmail);
DBにメアドが存在しなければ、顧客登録を行う

*customer = customersService.Create(new StripeCustomerCreateOptions{Email = stripeEmail,SourceToken = stripeToken});
Stripe に顧客を追加

*dbCustomer = new Customer(){Email = stripeEmail,StripeId = customer.Id};
DB に顧客を追加

*dbCustomer = dbCustomers.First();
Stripe の顧客を取得

*var charge = chargesService.Create(new StripeChargeCreateOptions{Amount = 1000,Currency = "jpy",Description = "Example charge",CustomerId = customer.Id});
課金を追加

*}
ここで課金結果をDBに登録（今回は実装しない）
DBに charge.id を保管すれば、Stripe 側の課金情報と紐づけできる


*return string.Join(", ", s.Select(e => e.ToString()));
おそらくここにナミナミが...


*}
以下caseに応じた分岐処理

*if (_settings.MaterialNameList.Count <= _selectedMaterialIndex) _settings.SelectedMaterialIndex = 0;*_selectedMaterialIndex = EditorGUILayout.Popup("使用するマテリアル", _settings.SelectedMaterialIndex, _settings.MaterialNameList.ToArray());
リストの設定漏れは一番若い数字に

*_settings.SelectedMaterialName = _settings.MaterialNameList[_selectedMaterialIndex];
変更した値を設定側で保持

*var materialSettings = Resources.Load<MaterialSettings>("MaterialSettings");
マテリアル設定用ScriptableObject読み込み

*var materialName = materialSettings.SelectedMaterialName;
選択したマテリアル名取得

*var useMaterial = materialSettings.MaterialList.Where(material => material)
マテリアル名から使用するマテリアル取得

*transform.GetComponent<MeshRenderer>().material = useMaterial;*}
マテリアル適用


*si.SvgPixelsPerUnit = 50;
変更したい項目をここに書く


*= new Person3();
C#3版

*}
= new Person5();  C#5版
= new Person6();  C#6版
= new Person7();  C#7版
= new Person3X();  C#3式木版
= new PersonVM(); 独自ViewModel継承版
= new PersonNB(); 独自ViewModel継承バッキングフィールド無し版
= new PersonEX(); 拡張メソッド使用版
= new PersonMV(); MVVMライブラリ使用版
= new PersonRP(); ReactiveProperty版
= new PersonFD(); Fody使用版

*var memberEx = propertyName.Body as MemberExpression;
ラムダ式のBodyを取得する。MemberExpressionじゃなかったら駄目

*if (EqualityComparer<TResult>.Default.Equals(source, value))*return false;
値が同じだったら何もしない

*RaisePropertyChanged(propertyName);
イベント発行

*private Dictionary<string, object> currentPropertyValues = new Dictionary<string, object>();
プロパティ名をKeyとしたバッキングフィールド代わりのDictionary

*=> GetPropertyValue(default(TResult), propertyName);
プロパティの型の既定値を初期値とする

*if (!currentPropertyValues.ContainsKey(propertyName))*currentPropertyValues[propertyName] = initialValue;
キーに値が無かったら初期値を現在値に入力

*return (TResult)currentPropertyValues[propertyName];
Dictionaryから現在値を取得してプロパティの型に変換する

*if (EqualityComparer<TResult>.Default.Equals(GetPropertyValue<TResult>(propertyName), value))*return false;
値が同じだったら何もしない

*currentPropertyValues[propertyName] = value;
プロパティの現在値に入力

*RaisePropertyChanged(propertyName);
イベント発行

*if (_this == null) return;*// ラムダ式のBodyを取得する。MemberExpressionじゃなかったら駄目
ハンドラに何も登録されていない場合は何もしない

*if (!(propertyName.Body is MemberExpression memberEx))*throw new ArgumentException();
ラムダ式のBodyを取得する。MemberExpressionじゃなかったら駄目

*if (!(memberEx.Expression is ConstantExpression senderExpression))
() => NameのNameの部分の左側に暗黙的に存在しているオブジェクトを取得する式をゲット
ConstraintExpressionじゃないと駄目

*var sender = senderExpression.Value;
○：定数なのでValueプロパティからsender用のインスタンスを得る

*_this(sender, new PropertyChangedEventArgs(memberEx.Member.Name));
下準備が出来たので、イベント発行！！

*if (EqualityComparer<TResult>.Default.Equals(source, value))*return false;
値が同じだったら何もしない

*Raise(_this, propertyName);
イベント発行


*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame

*public Text Formula;
式入力テキスト

*public Text Answer;
結果表示テキスト

*public Button[] bNumber;
各数字ボタン

*public Button bDivide;
割るボタン

*public Button bEqual;
計算ボタン

*public Button bClear;
クリアボタン

*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame

*public void InputNumber(Text number){}
各数字ボタン押下

*public void InputDivide(Text divideButton){}
割るボタン押下

*public void InputEqual(Text equal){}
計算ボタン押下

*public void InputClear(Text equal){}
クリアボタン押下

*public Text Formula;
式入力テキスト

*public Text Answer;
結果表示テキスト

*public Button[] bNumber;
各数字ボタン

*public Button bDivide;
割るボタン

*public Button bEqual;
計算ボタン

*public Button bClear;
クリアボタン

*void Start () {//初期化Formula.text = "";Answer.text = "";}
Use this for initialization

*Formula.text = "";
初期化

*void Update () {}
Update is called once per frame

*public void InputNumber(Text number){// 押下したボタンの数字を式欄に追記するFormula.text += number.text;}
数字ボタン押下

*Formula.text += number.text;
押下したボタンの数字を式欄に追記する

*public void InputDivide(Text divideButton){// 数字が未入力か、すでに÷があればスルーif(Formula.text == "" || Formula.text.Contains("÷")){return;}// ÷を式欄に追記するFormula.text += divideButton.text;}
割るボタン押下

*Formula.text += divideButton.text;
÷を式欄に追記する

*public void InputEqual(Text equal){// ÷がないか、文字列の最後が÷ならスルー★if(!Formula.text.Contains("÷")){return;}// 入力した式を割る数と割られる数に分けるstring[] inputString = Formula.text.Split('÷');int leftNumber = int.Parse(inputString[0]);int rightNumber = int.Parse(inputString[1]);// 割られる数がゼロならスルーif(rightNumber == 0){return;}// 商int quotient = leftNumber / rightNumber;// 余りint remainder = leftNumber % rightNumber;// 計算結果を表示Answer.text = quotient.ToString() + "…" + remainder.ToString();}
計算ボタン押下

*string[] inputString = Formula.text.Split('÷');
入力した式を割る数と割られる数に分ける

*int quotient = leftNumber / rightNumber;
商

*int remainder = leftNumber % rightNumber;
余り

*Answer.text = quotient.ToString() + "…" + remainder.ToString();
計算結果を表示

*public void InputClear(Text equal){//初期化Formula.text = "";Answer.text = "";}
クリアボタン押下

*Formula.text = "";
初期化


*ret[i] = Sin(1000.0 * sr * i);
1000ヘルツ


*型名 変数 = (型名)e.Current;
(3)

*}
Dispose処理(4)

*private Cell Head;
先頭のセルを格納するフィールド。

*//空のセル(フィールドがnullなセル。要素の格納はできない)を作成する*public Array() { Head = new Cell(null); }
まず、コレクションのインスタンスを生成したと同時に

*public Array() { Head = new Cell(null); }
空のセル(フィールドがnullなセル。要素の格納はできない)を作成する

*class ArrayEnumerator : IEnumerator
ここはあくまで現在のセルの場所を示すためのものなので、
例えば、新たにセルを加えたりなどセルの場所を扱う必要のない操作に関しては
一切不要（セルを加える操作では、このコレクションの場合常に先頭に追加されるため不要）

*public class Cell*{public Object Item { set; get; }public Cell Next { set; get; }//新たにセルが作られたとき、各フィールドに値を代入する。//コンストラクタの引数は、セルの要素。public Cell(Object item){Item = item;}}
セル。要素と次のセルを格納するフィールドを持つ。

*public Cell(Object item)
新たにセルが作られたとき、各フィールドに値を代入する。
コンストラクタの引数は、セルの要素。

*public void Add(Object item)*{//現在の先頭のセル(ヘッド)を一時的に保存Cell temphead = Head;//ヘッドに、新たに作成したセルを格納。Head = new Cell(item);//ヘッドのもつ、次のセルを格納するフィールドに追加するセルを代入。Head.Next = temphead;}
これがなくては何もできない。

*Cell temphead = Head;
現在の先頭のセル(ヘッド)を一時的に保存

*Head = new Cell(item);
ヘッドに、新たに作成したセルを格納。

*Head.Next = temphead;
ヘッドのもつ、次のセルを格納するフィールドに追加するセルを代入。

*public Object Current { get { return CurrentCell.Item; } }
矢印が指し示すセルの要素を返す

*public bool MoveNext()
返り値は、ちゃんと動かせたかどうか。
true(矢印を動かせた)、false(もうこれ以上矢印を動かせない)

*if (CurrentCell == null)*//矢印の位置を初期位置(Head)に戻す。
現在指し示しているセルの次のセル(Next)があるかどうかを調べる。、

*CurrentCell = Array.Head;
矢印の位置を初期位置(Head)に戻す。

*CurrentCell = CurrentCell.Next;
矢印を動かす。

*if (CurrentCell == null)*return false;
条件文が同じなので統合したくなるが、それはできない。

*public void Reset() { CurrentCell = null; }
先頭位置を元に戻す

*private Cell Head;
先頭のセルを格納するフィールド。

*public Array() { Head = new Cell(null); }
空のセル(フィールドがnullなセル。要素の格納はできない)を作成する

*class ArrayEnumerator : IEnumerator*{Cell CurrentCell;Array Array;public ArrayEnumerator(Array array){this.Array = array;//初めにどのセルを指し示すのかを決める。CurrentCell = null;}//現在指し示されているセルの要素を返すpublic Object Current { get { return CurrentCell.Item; } }//返り値のbool値は、ちゃんと動かせたかどうかという情報。//true(矢印を動かせた)、false(もうこれ以上矢印を動かせない)public bool MoveNext(){//現在指し示しているセルの次のセル(Next)があるかどうかを調べる。、if (CurrentCell == null)//矢印の位置を初期位置(Head)に戻す。CurrentCell = Array.Head;else//矢印を動かす。CurrentCell = CurrentCell.Next;//条件文が同じなので統合したくなるが、それはできない。if (CurrentCell == null)return false;return true;}//先頭位置を元に戻すpublic void Reset() { CurrentCell = null; }}
反復子のクラス

*CurrentCell = null;
初めにどのセルを指し示すのかを決める。

*public Object Current { get { return CurrentCell.Item; } }
現在指し示されているセルの要素を返す

*public bool MoveNext()
返り値のbool値は、ちゃんと動かせたかどうかという情報。
true(矢印を動かせた)、false(もうこれ以上矢印を動かせない)

*if (CurrentCell == null)*//矢印の位置を初期位置(Head)に戻す。
現在指し示しているセルの次のセル(Next)があるかどうかを調べる。、

*CurrentCell = Array.Head;
矢印の位置を初期位置(Head)に戻す。

*CurrentCell = CurrentCell.Next;
矢印を動かす。

*if (CurrentCell == null)*return false;
条件文が同じなので統合したくなるが、それはできない。

*public void Reset() { CurrentCell = null; }
先頭位置を元に戻す

*public class Cell*{public Object Item { set; get; }public Cell Next { set; get; }//新たにセルが作られたとき、各フィールドに値を代入する。public Cell(Object item){Item = item;}}
セル。要素と次のセルを格納するフィールドを持つ。

*public Cell(Object item)*{Item = item;}
新たにセルが作られたとき、各フィールドに値を代入する。

*var temphead = Head;
現在のヘッドを一時的に保存

*Head = new Cell(item);
先頭のセルを、追加したセルに切り替える。

*Head.Next = temphead;
先頭のセルのもつ、次のセルを格納するフィールドに追加するセルを代入。


*var orgFileName = ContentDispositionHeaderValue
ここではオリジナルのファイル名の拡張子を取り出し
格納するときは GUID をベースの名前に変えている。

*}
stream からデータを取り、
それを適当なストレージに格納し、
その URL を返す 処理を実装。
return "https:xxx.xxx.xxx/xxx/" + fileName;


*public delegate void DisplayProgress(Mat img, int threshold);
【Cameraクラス側】

*public string Decode(int min, int max, int add, Mat img, int threshold, DisplayProgress callback)*{// (中略)// フォーム側処理を呼ぶcallback?.Invoke(img2, value);// (中略)}
デコード処理

*callback?.Invoke(img2, value);
(中略)
フォーム側処理を呼ぶ

*}
(中略)

*string value = await Task.Run(() => _camera.Decode(min, max, 1, img, threshold, AnalyzeDisplay));
【フォーム側処理】
しきい値を中央に解析する

*VideoCapture _cap = null;
【Cameraクラス側】

*_cap = new VideoCapture(0) { AutoFocus = false };
カメラ有無 0:バックカメラ 1:フロントカメラ

*bool _isRunning = false;
【フォーム側処理】

*private void bgWorker_DoWork(object sender, DoWorkEventArgs e)*{BackgroundWorker worker = (BackgroundWorker)sender;if (!_camera.Enabled) return;while (_isRunning){// bgWorker_ProgressChangedイベントで画像取得Mat dst = _camera.Read();worker.ReportProgress(0, dst);}}
バッググラウンド処理

*Mat dst = _camera.Read();
bgWorker_ProgressChangedイベントで画像取得

*private void bgWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)*{// カメラ画像表示picMain.ImageIpl = (Mat)e.UserState;}
バッググラウンド進行変更イベント処理

*picMain.ImageIpl = (Mat)e.UserState;
カメラ画像表示

*private void CaputureStart()*{_isRunning = true;bgWorker.RunWorkerAsync();tmrCapture.Enabled = true;}
キャプチャー開始処理

*private void CaputureStop()*{_isRunning = false;bgWorker.CancelAsync();tmrCapture.Enabled = false;}
キャプチャー停止処理

*picMain.Controls.Add(picTargetMain);
ターゲットアイコン用(メイン用)

*const string CAPTURE_PATH = "caputure.png";
キャプチャー画面

*private void tmrCapture_Tick(object sender, EventArgs e)*{if (picMain.Image == null) return;// 画面キャプチャー保存picMain.ImageIpl.SaveImage(CAPTURE_PATH);// 画像読込(中央あたりをトリミング)Mat src = new Mat(CAPTURE_PATH);Rect rc = new Rect((src.Width - picMain.Width) / 2,(src.Height - picMain.Height) / 2 - Camera.IMAGE_MERGIN_SIZE,picMain.Width,picMain.Height + Camera.IMAGE_MERGIN_SIZE);picCapture.ImageIpl = new Mat(new Mat(CAPTURE_PATH), rc);// そのまま解析Result result = _camera.Analyze(picCapture.ImageIpl);if (result == null) return;string decode = result.ToString().Trim();if (decode != "" && decode != "error"){// 解析出来たなら入力値へ送信Send(decode);}// 解析可能性があるif (decode == "error"){// 自動解析処理AnalyzeAuto(picCapture.ImageIpl, trbThreshold.Value);}}
タイマー処理

*picMain.ImageIpl.SaveImage(CAPTURE_PATH);
画面キャプチャー保存

*Mat src = new Mat(CAPTURE_PATH);
画像読込(中央あたりをトリミング)

*Result result = _camera.Analyze(picCapture.ImageIpl);
そのまま解析

*Send(decode);
解析出来たなら入力値へ送信

*AnalyzeAuto(picCapture.ImageIpl, trbThreshold.Value);
自動解析処理

*public Mat Read()*{Mat result = null;if (_cap.IsOpened()){Mat frame = new Mat();result = new Mat();// カメラ画像の読込み_cap.Read(frame);// グレースケール化Cv2.CvtColor(frame, result, ColorConversionCodes.BGRA2GRAY);}return result;}
カメラ画像の読込み

*_cap.Read(frame);
カメラ画像の読込み

*Cv2.CvtColor(frame, result, ColorConversionCodes.BGRA2GRAY);
グレースケール化

*public Result Analyze(Mat img)*{BarcodeReader reader = new BarcodeReader{AutoRotate = true,TryInverted = true,// Code-39とQRコードに限定Options = new ZXing.Common.DecodingOptions{TryHarder = true,PossibleFormats = new[] { BarcodeFormat.QR_CODE }.ToList()}};return reader.Decode(img.ToBitmap());}
解析処理

*Options = new ZXing.Common.DecodingOptions{TryHarder = true,PossibleFormats = new[] { BarcodeFormat.QR_CODE }.ToList()}};
Code-39とQRコードに限定

*public const int IMAGE_MERGIN_SIZE = 22;
ファインダパタンの中央点から端までの差

*int stX = 0;
ポイント情報からQRコード部分を切り取る

*stX = (int)GetMinValue(result.ResultPoints[0].X, result.ResultPoints[1].X) - IMAGE_MERGIN_SIZE;
左下→左上→右上

*stX = (int)GetMinValue(result.ResultPoints[1].X, result.ResultPoints[2].X) - IMAGE_MERGIN_SIZE;
右下→左下→右上

*private float GetMinValue(float min1, float min2)*{return (min1 <= min2 ? min1 : min2);}
引数の小さい値を取得する

*private float GetMaxValue(float max1, float max2)*{return (min1 >= min2 ? max1 : max2);}
引数の大きい値を取得する


*/**************************************************************/
世代管理開始


*public IEnumerator CreatePDF (string path) {Document doc = new Document(PageSize.A4.Rotate());var writer = PdfWriter.GetInstance(doc, new FileStream(path, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None));doc.Open();doc.NewPage();yield return StartCoroutine(TakeScreenshot(mainCam, Screen.width, Screen.height));AddImageToPDF(writer, capturedTex, 0, 0);doc.Close();}
create pdf to specific path

*public IEnumerator TakeScreenshot (Camera cam, int width, int height) {RenderTexture rt = new RenderTexture(width, height, 24, RenderTextureFormat.ARGB32);rt.antiAliasing = 8;cam.targetTexture = rt;cam.Render();yield return new WaitForEndOfFrame();RenderTexture.active = rt;capturedTex = new Texture2D(width, height, TextureFormat.RGB24, false);capturedTex.ReadPixels(new Rect(0, 0, width, height), 0, 0);capturedTex.Apply();cam.targetTexture = null;}
coroutine to take screenshot

*public void AddImageToPDF(PdfWriter pdfWriter, Texture2D img, float posX, float posY){byte[] imageBytes = img.EncodeToPNG();iTextSharp.text.Image finalImage = iTextSharp.text.Image.GetInstance(imageBytes);finalImage.ScaleAbsolute(PageSize.A4.Rotate());finalImage.SetAbsolutePosition(posX, posY);var pdfContentByte = pdfWriter.DirectContent;pdfContentByte.AddImage(finalImage);}
add image to pdf


*AnalyzerManager manager = new AnalyzerManager();
Buildalyzerの起点

*ProjectAnalyzer analyzer = manager.GetProject(@"C:\MyCode\MyProject.csproj");
C#プロジェクトのオープン

*Microsoft.CodeAnalysis.AdhocWorkspace workspace = analyzer.GetWorkspace();
プロジェクト情報からRoslynで使うWorkspace(プロジェクトやソリューションをまとめたもの)を生成する。
Buildalyzer.Workspacesが必要

*var compilation = await project.GetCompilationAsync();
個々のプロジェクト処理
プロジェクトのコンパイル(シンボル情報構築)
型がAssemblyではなく、Microsoft.CodeAnalysis.Compilationなので注意

*}
コンパイルエラー等がある場合、
完了後にGetDiagnostics()を使用してエラー情報を取得する

*foreach(var clsSymbol in compilation.GetSymbolsWithName(_ => true, SymbolFilter.Type).OfType<ITypeSymbol>())
compilation.GetSymbolsWithNameでクラス定義等が取得可能
キャストしないとISymbolで取得されるため、情報が非常に限定される

*foreach(var memberSymbol in clsSymbol.GetMembers())
メンバーの取得
(メソッドやインナークラス等も入るため、ISymbol.Kindで場合分けを行う事)


*var url = "http:
localhost:xxxxxapivalues"


*UnityEngine.iOS.Device.SetNoBackupFlag(path);
iOSでデータをiCloudにバックアップさせない設定


*var num = 1;
コンパイル時にintとしてコンパイルされる

*var str = "Hello,World";
stringとしてコンパイルされる

*num = "1";
numはintとしてコンパイルされるのでコンパイルエラー

*var collect = new UserCollection(users);
使用する側

*var count = collect.Count;
Countプロパティにアクセス

*var user = collect[1];
Indexerにインデックスを指定することによってアクセス

*collect.count = 10;
※CountプロパティにはSetアクセサーが実装されていないため、コンパイルエラーになる

*}
ここで例外がスローされても、conは確実にDisposeが呼ばれる


*XXXXX xx = new XXXXX();
呼び出したいdllの呼び出し情報


*return 0;
最初のステップにもどる


*key=FONT, no=12,,,Regex reg = new Regex("(?<No>[0-9]+$)");
結果


*var resources = new List<ResourceDictionary> { Application.Current.Resources };
現在のアプリケーションのResourceDictionaryと入れ子になっているResourceDictionaryを平坦化

*.SelectMany(x => x.Values.OfType<DataTemplate>())
ResourceからValueを取り出しDataTemplate型だけ抽出して平坦化

*.Select(x =>new{Contentを生成してView型情報に変換viewType = x.LoadContent().GetType(),
DataTemplateを匿名型に変換

*viewType = x.LoadContent().GetType(),DataTypeをViewModel型情報に変換viewModelType = x.DataType as Type});
Contentを生成してView型情報に変換

*viewModelType = x.DataType as Type});
DataTypeをViewModel型情報に変換

*var selectViewModelType = dataTemplateExs.FirstOrDefault(a => a.viewType == ViewType)
一致するView型を探し、対応するViewModel型を選択

*var vm = Activator.CreateInstance(selectViewModelType);
該当するViewModel型を作成


*AdditiveTransparent,
加算半透明

*}
materialEditor.EnableInstancingField();    GPU Instancing未対応

*this.SetupBlendMode(material, (BlendMode)material.GetFloat("_BlendMode"));
MaterialのShader切り替え時にBlend指定が変更されてしまうので再設定


*app.UseSwaggerUi();
追加

*[HttpGet("{id}")]
GET api/values/5


*System.Diagnostics.Process[] ps =System.Diagnostics.Process.GetProcessesByName("notepad");
notepadのプロセスを取得

*p.Kill();
プロセスを強制的に終了させる


*public class DataAccessObject*{private static readonly string BasePath = Application.persistentDataPath + "/DAO/";private const string Extention = ".json";// 存在確認public static bool Exists( string fileName ){return ExistsFile( fileName );}// カスタムクラスを読み込みpublic static T Read<T>( string fileName ){string text = ReadFile( fileName );if( string.IsNullOrEmpty( text ) )return default(T);return JsonUtility.FromJson<T>( text );}// カスタムクラスを保存public static void Save( object data, string fileName ){string text = JsonUtility.ToJson( data );OverWriteFile( fileName, text );}// 削除public static void Delete( string fileName ){DeleteFile( fileName );}// パスの取得private static string MakeFilePath( string fileName ){return BasePath + "/" + fileName + Extention;}// ファイルの存在確認private static bool ExistsFile( string fileName ){string path = MakeFilePath( fileName );return File.Exists( path );}// ファイルの読み込みprivate static string ReadFile( string fileName ){string path = MakeFilePath( fileName );if( !ExistsFile( fileName ) )return null;return File.ReadAllText( path );}// ファイルの上書きprivate static void OverWriteFile( string fileName, string text ){if( !Directory.Exists( BasePath ) )Directory.CreateDirectory( BasePath );string path = MakeFilePath( fileName );DeleteFile( fileName );File.WriteAllText( path, text );}// ファイルの削除private static void DeleteFile( string fileName ){string path = MakeFilePath( fileName );if( Exists( fileName ) )File.Delete( path );}}
クライアントのデータ保存・読み込み・削除・存在確認

*public static bool Exists( string fileName )*{return ExistsFile( fileName );}
存在確認

*public static T Read<T>( string fileName )*{string text = ReadFile( fileName );if( string.IsNullOrEmpty( text ) )return default(T);return JsonUtility.FromJson<T>( text );}
カスタムクラスを読み込み

*public static void Save( object data, string fileName )*{string text = JsonUtility.ToJson( data );OverWriteFile( fileName, text );}
カスタムクラスを保存

*public static void Delete( string fileName )*{DeleteFile( fileName );}
削除

*private static string MakeFilePath( string fileName )*{return BasePath + "/" + fileName + Extention;}
パスの取得

*private static bool ExistsFile( string fileName )*{string path = MakeFilePath( fileName );return File.Exists( path );}
ファイルの存在確認

*private static string ReadFile( string fileName )*{string path = MakeFilePath( fileName );if( !ExistsFile( fileName ) )return null;return File.ReadAllText( path );}
ファイルの読み込み

*private static void OverWriteFile( string fileName, string text )*{if( !Directory.Exists( BasePath ) )Directory.CreateDirectory( BasePath );string path = MakeFilePath( fileName );DeleteFile( fileName );File.WriteAllText( path, text );}
ファイルの上書き

*private static void DeleteFile( string fileName )*{string path = MakeFilePath( fileName );if( Exists( fileName ) )File.Delete( path );}
ファイルの削除

*public class Example : MonoBehaviour*{// データ保存用クラス[Serializable]private class TestData{public string testString;public int    testInt;public override string ToString(){return   "Test Data :: "+ "Test String : " + testString + ", "+ "Test Int : " + testInt;}}private void Start(){var testData = new TestData();{testData.testString = "string";testData.testInt = 15;}// 保存DataAccessObject.Save( testData, "fileName" );// 読み込みDebug.Log( DataAccessObject.Read<TestData>( "fileName" ).ToString() );// 存在確認Debug.Log( DataAccessObject.Exists( "fileName" ) );// 削除DataAccessObject.Delete( "fileName" );Debug.Log( DataAccessObject.Exists( "fileName" ) );}}
使用例

*[Serializable]
データ保存用クラス

*DataAccessObject.Save( testData, "fileName" );
保存

*Debug.Log( DataAccessObject.Read<TestData>( "fileName" ).ToString() );
読み込み

*Debug.Log( DataAccessObject.Exists( "fileName" ) );
存在確認

*DataAccessObject.Delete( "fileName" );
削除

*public class DataAccessObject*{private static readonly string BasePath = Application.persistentDataPath + "/DAO/";private const string Extention = ".json";public static T Read<T>( string fileName ){string text = ReadFile( fileName );if( string.IsNullOrEmpty( text ) )return default(T);return JsonUtility.FromJson<T>( text );}private static string MakeFilePath( string fileName ){return BasePath + "/" + fileName + Extention;}private static bool ExistsFile( string fileName ){string path = MakeFilePath( fileName );return File.Exists( path );}private static string ReadFile( string fileName ){string path = MakeFilePath( fileName );if( !ExistsFile( fileName ) )return null;return File.ReadAllText( path );}}
クライアントのデータ読み込み

*public interface IRead<T>*{T Read();}
インターフェイス：読み込み

*public class DaoFactory*{private readonly string basePath;private readonly string fileName;private DaoFactory( string fileName ){this.basePath = Application.persistentDataPath + "/DAO/";this.fileName = fileName;}public static IRead<T> CreateReader<T>( string fileName ){return new DaoFactory( fileName ).CreateReader<T>();}private IRead<T> CreateReader<T>( string fileName ){var textReader = new TextReader( basePath, fileName );return new DeserializeReader<T>( textReader );}}
IReadの作成

*public class TextReader : IRead<string>*{private readonly string basePath;private readonly string fileName;public TextReader( string basePath, string fileName ){this.basePath = basePath;this.fileName = fileName;}public string Read(){string path = basePath + fileName;if( !Directory.Exists( basePath ) || !File.Exists( path ) )return null;return File.ReadAllText( path );}}
テキストの読み込み

*public class DeserializeReader<T> : IRead<T>*{private readonly IRead<string> stringReader;public DeserializeReader( IRead<string> stringReader ){this.stringReader = stringReader;}public T Read(){string text = stringReader.Read();if( string.IsNullOrEmpty( text ) )return default(T);return JsonUtility.FromJson<T>( text );}}
Jsonを指定されたクラスとして読み込み

*public class Example : MonoBehaviour*{// データ保存用クラス[Serializable]private class TestData{public string testString;public int    testInt;public override string ToString(){return   "Test Data :: "+ "Test String : " + testString + ", "+ "Test Int : " + testInt;}}private void Start(){// Data Access Objectの取得var testDataDAO = DaoFactory.Create<TestData>( "fileName" );var testData = new TestData();{testData.testString = "test";testData.testInt = 99;}// 保存testDataDAO.Save( testData );// 読み込みDebug.Log( testDataDAO.Read().ToString() );// 存在確認Debug.Log( testDataDAO.Exists() );// 削除testDataDAO.Delete();Debug.Log( testDataDAO.Exists() );}}
使用例

*[Serializable]
データ保存用クラス

*var testDataDAO = DaoFactory.Create<TestData>( "fileName" );
Data Access Objectの取得

*testDataDAO.Save( testData );
保存

*Debug.Log( testDataDAO.Read().ToString() );
読み込み

*Debug.Log( testDataDAO.Exists() );
存在確認

*testDataDAO.Delete();
削除

*using UniDAO;
簡単なモック

*namespace UniDAO.Old*{public class DataAccessObject{public static T Read<T>( string fileName ){// 読み込まれたテキストは暗号化されている想定string encryptedText = ReadFile( fileName );// 何らかの方法で復号化string text = Decrypt( encryptedText );// ログを出力Debug.Log( text );if( string.IsNullOrEmpty( text ) )return default(T);return JsonUtility.FromJson<T>( text );}}}
そのまま関数を拡張したパターン

*string encryptedText = ReadFile( fileName );
読み込まれたテキストは暗号化されている想定

*string text = Decrypt( encryptedText );
何らかの方法で復号化

*Debug.Log( text );
ログを出力

*namespace UniDAO*{// 復号化public class DecryptReader : IRead<string>{private readonly IRead<string> stringReader;public DecryptReader( IRead<string> stringReader ){this.stringReader = stringReader;}public string Read(){return Decrypt( stringReader.Read() );}}// ログ出力public class LogReader : IRead<string>{private readonly IRead<string> stringReader;public LogReader( IRead<string> stringReader ){this.stringReader = stringReader;}public string Read(){string str = stringReader.Read();Debug.Log( str );return str;}}public class DaoFactory{private IRead<T> CreateReader<T>( string fileName ){var textReader  = new TextReader( basePath, fileName );// 復号化機能をデコレーションvar decryptReader = new DecryptReader( textReader );// ログ出力機能をデコレーションvar logReader  = new LogReader( decryptReader );return new DeserializeReader<T>( logReader );}}}
デコレーターで拡張したパターン

*public class DecryptReader : IRead<string>*{private readonly IRead<string> stringReader;public DecryptReader( IRead<string> stringReader ){this.stringReader = stringReader;}public string Read(){return Decrypt( stringReader.Read() );}}
復号化

*public class LogReader : IRead<string>*{private readonly IRead<string> stringReader;public LogReader( IRead<string> stringReader ){this.stringReader = stringReader;}public string Read(){string str = stringReader.Read();Debug.Log( str );return str;}}
ログ出力

*var decryptReader = new DecryptReader( textReader );
復号化機能をデコレーション

*var logReader  = new LogReader( decryptReader );
ログ出力機能をデコレーション

*public class DeserializeReader<T> : IRead<T>*{private readonly IRead<string> stringReader;public DeserializeReader( IRead<string> stringReader ){this.stringReader = stringReader;}public T Read(){string text = stringReader.Read();if( string.IsNullOrEmpty( text ) )return default(T);return JsonUtility.FromJson<T>( text );}}
Jsonを指定されたクラスとして読み込み

*public class DaoFactory*{private IRead<T> CreateReader<T>( string fileName ){// 自力で依存関係を解決var textReader        = new TextReader( basePath, fileName );var decryptReader     = new DecryptReader( textReader );var logReader         = new LogReader( decryptReader );var deserializeReader = new DeserializeReader<T>( logReader );return deserializeReader;}}
IReadの作成

*var textReader        = new TextReader( basePath, fileName );
自力で依存関係を解決

*public class DeserializeReader<T> : IRead<T>*{private readonly IRead<string> stringReader;private readonly IDeserialize<string> deserializer;public DeserializeReader( IRead<string> stringReader, IDeserialize<string> deserializer ){this.stringReader = stringReader;this.deserializer = deserializer;}public T Read(){string text = stringReader.Read();if( string.IsNullOrEmpty( text ) )return default(T);// IDeserializeにデシリアライズ処理を委譲return deserializer.Deserialize<T>( text );}}
JsonUtilityへの依存をなくしたDeserializeReader

*return deserializer.Deserialize<T>( text );
IDeserializeにデシリアライズ処理を委譲

*public interface IRead<T>*{T Read();}
インターフェイス：読み込み

*public interface IDataAccessObject<T>*{bool Exists();T Read();void Save( T data );void Delete();}
インターフェイス：存在確認・読み込み・保存・削除

*public class TextDao : IDataAccessObject<string>*{private readonly string basePath;private readonly string fileName;private string Path{get{return basePath + fileName;}}public TextDao( string basePath, string fileName ){this.basePath = basePath;this.fileName = fileName;}public bool Exists(){return File.Exists( Path );}public string Read(){if( !Exists() )return null;return File.ReadAllText( Path );}public void Save( string text ){if( !Directory.Exists( basePath ) )Directory.CreateDirectory( basePath );Delete();File.WriteAllText( Path, text );}public void Delete(){if( Exists() )File.Delete( Path );}}
テキストの存在確認・読み込み・保存・削除

*public class SerializeDao<T> : IDataAccessObject<T>
シリアライズしたテキストを保存
テキストをデシリアライズして読み込み
テキストの存在確認・削除 ← 委譲しているだけ！

*return stringDao.Exists();
委譲しているだけ

*stringDao.Delete();
委譲しているだけ


*for(var i = 0; i < source.Length; i++)
作業用変数の宣言
var wordbreakIndex = 0;           現在の単語の始まりのインデックス
var currentWordLength = 0;        現在の単語の文字数
var current = '\0';               ループの中で現在参照している文字
var isLowerBefore = false;        一つ前の文字が小文字だったかどうか
var isUpperCurrent = false;       現在の文字が大文字かどうか

*yield return source.Substring(wordbreakIndex, currentWordLength);
小文字から大文字に切り替わった時に単語を切り出す。

*yield return source.Substring(wordbreakIndex, source.Length - wordbreakIndex);
最後の単語の返却漏れがないように


*int size = 1;
デバイス数 ÷ 16


*return default(T);
コンパイルが通ってしまう


*e.Paint(e.ClipBounds, DataGridViewPaintParts.All);
セルを描画する

*Rectangle indexRect = e.CellBounds;
行番号を描画する範囲を決定する
e.AdvancedBorderStyleやe.CellStyle.Paddingは無視しています

*TextRenderer.DrawText(e.Graphics,(e.RowIndex + 1).ToString(),
行番号を描画する

*e.Handled = true;
描画が完了したことを知らせる


*#if UNITY_EDITOR*Input.gyro.enabled = false;
ジャイロを有効にする

*#if UNITY_EDITOR*#elif UNITY_ANDROID
androidとiosで座標系が違うのでデバイスごとに設定

*rightCam.transform.localPosition = new Vector3(-parallax, 0, 0)/2;*leftCam.transform.localPosition = new Vector3(parallax, 0, 0)/2;
視差の変更があったら反映する


*var e = new Vector(1, 0);
単位ベクトル


*string str = "Hello, C#";
文字列型の変数「str」宣言

*const string str = "Hello, C#";
ローカルスコープ内で定義した定数はconstを指定

*using System.Collections.Generic;
辞書データを実装するためにはDictionaryクラスが必要

*func.Func(num: 1);
引数名を指定しての設定と指定なしの両方が可能


*protected virtual void Hoge()*{x = 114514;}
仮想関数

*protected abstract void Hoge();
純粋仮想関数


*TextBox newTextBox = new TextBox();
TextBoxの追加

*InkCanvas.SetTop(newTextBox, 5);
TextBoxの表示位置

*FocusManager.SetFocusedElement(FocusManager.GetFocusScope(newTextBox), newTextBox);
フォーカスの設定

*InputMethod.Current.ImeState = InputMethodState.On;
IMEの変更


*//展開結果は配列にする*//q1{1,1,1}{1,1,2}{1,1,3}{1,2,1}…{3,3,3}
結合条件なしで重複ありの全組み合わせを展開

*//q1{1,1,1}{1,1,2}{1,1,3}{1,2,1}…{3,3,3}
展開結果は配列にする

*var q1 = from s1 in itemsfrom s2 in itemsfrom s3 in itemsselect new int[] { s1, s2, s3 };
q1{1,1,1}{1,1,2}{1,1,3}{1,2,1}…{3,3,3}

*//要素の個数と、各要素の値の種類数が一致していれば重複無しと判断*// q1={1,3,1}の場合、要素の個数は3、値の種類数は2(1と3しかないから)→×：除外
各要素の重複なしのレコードのみ抽出して返す

*q1={1,3,1}の場合、要素の個数は3、値の種類数は2(1と3しかないから)→×：除外q1={1,3,2}の場合、要素の個数は3、値の種類数は3→○：抽出q1={1,1,1}の場合、要素の個数は3、値の種類数は1(1しかないから)→×：除外var q2 = q1.Where(ar => ar.Length == ar.Distinct().Count());
要素の個数と、各要素の値の種類数が一致していれば重複無しと判断

*q1={1,3,2}の場合、要素の個数は3、値の種類数は3→○：抽出q1={1,1,1}の場合、要素の個数は3、値の種類数は1(1しかないから)→×：除外var q2 = q1.Where(ar => ar.Length == ar.Distinct().Count());
q1={1,3,1}の場合、要素の個数は3、値の種類数は2(1と3しかないから)→×：除外

*q1={1,1,1}の場合、要素の個数は3、値の種類数は1(1しかないから)→×：除外var q2 = q1.Where(ar => ar.Length == ar.Distinct().Count());
q1={1,3,2}の場合、要素の個数は3、値の種類数は3→○：抽出

*var q2 = q1.Where(ar => ar.Length == ar.Distinct().Count());
q1={1,1,1}の場合、要素の個数は3、値の種類数は1(1しかないから)→×：除外

*//q1{1,1,1}{1,1,2}{1,1,3}{1,2,1}…{3,3,3}
結合条件なしで重複ありの全組み合わせを展開

*var q1 = from s1 in itemsfrom s2 in itemsfrom s3 in itemsselect new { N1 = s1, N2 = s2, N3 = s3 };
q1{1,1,1}{1,1,2}{1,1,3}{1,2,1}…{3,3,3}

*//要素の個数と、各要素の値の種類数が一致していれば重複無しと判断*// q1={1,3,1}の場合、要素の個数は3、値の種類数は2(1と3しかないから)→×：除外
各要素の重複なしのレコードのみ抽出して返す

*q1={1,3,1}の場合、要素の個数は3、値の種類数は2(1と3しかないから)→×：除外q1={1,3,2}の場合、要素の個数は3、値の種類数は3→○：抽出q1={1,1,1}の場合、要素の個数は3、値の種類数は1(1)→×：除外var q2 = q1.Where(v =>
要素の個数と、各要素の値の種類数が一致していれば重複無しと判断

*q1={1,3,2}の場合、要素の個数は3、値の種類数は3→○：抽出q1={1,1,1}の場合、要素の個数は3、値の種類数は1(1)→×：除外var q2 = q1.Where(v =>
q1={1,3,1}の場合、要素の個数は3、値の種類数は2(1と3しかないから)→×：除外

*q1={1,1,1}の場合、要素の個数は3、値の種類数は1(1)→×：除外var q2 = q1.Where(v =>
q1={1,3,2}の場合、要素の個数は3、値の種類数は3→○：抽出

*var q2 = q1.Where(v =>{var ar = new int[] { v.N1, v.N2, v.N3 };return ar.Length == ar.Distinct().Count();
q1={1,1,1}の場合、要素の個数は3、値の種類数は1(1)→×：除外


*.UseUrls("http:
192.168.xx.xx:8080")


*public UnityTerrain terrain = null;
GameObjectにアタッチされたTerrainコンポーネントを保持

*UnityTerrain left_terrain = null;
独自の名前空間にTerrainを使っていて名称の混乱が起きているので、using UnityTerrain = UnityEngine.Terrainしています。

*SplatPrototype[] splatprototype = new SplatPrototype[1];
今のところテクスチャ一枚をすべてのTerrainの全面に貼る機能しかありません。

*TerrainData tData = terrain.terrainData;
ワールド座標をチャンクサイズで割って小数部だけ取り出せば、Terrain内の欲しい位置が割り出せる算段

*public static void reset(GameObject game_object, TerrainConfig terrain_config, WorldConfig world_config)
TerrainService初期化
ConfigData.instantiate_texture2Dは後述

*public static IEnumerator update(int player_x, int player_z)
プレイヤー移動時のTerrainアップデートを行います。
生成済みのTerrainは有効/無効の切り替えのみ。
未生成のTerrainは新しく生成します。

*public static void createUnityTerrains()
Terrain初期化時のみ使用します。
TerrainConfigで指定した範囲のTerrainを順次生成します。

*public static void setupTerrainCollection()
Terrain初期化時のみ使用します。
createUnityTerrainsで作ったTerrain達に対して追加の調整を実施していきます。

*private static void createTerrain(int x, int z, int chunk_size, float terrain_seed, float perlin_noise_scale)*{int xs = x * chunk_size;int zs = z * chunk_size;float[,] heights = createHeightMap(xs, zs, terrain_seed, perlin_noise_scale);terrain_collection[x, z] = TerrainEntityFactory.create(x, z, heights, terrain_config, terrain_parent);terrain_collection[x, z].disable();}
Terrain生成

*private static void setupTerrain(int x, int z, int chunk_size)*{terrain_collection[x, z].setNeighbors(terrain_collection[x - 1, z],terrain_collection[x, z + 1],terrain_collection[x + 1, z],terrain_collection[x, z - 1]);terrain_collection[x, z].setTexture(texture, chunk_size);TerrainEntityRepository.set(terrain_collection[x, z]);terrain_collection[x, z].enable();}
createTerrainで生成したTerrainに対して、追加で調整を行います。

*private static float[,] createHeightMap(int xs, int zs, float terrain_seed, float perlin_noise_scale)
Terrain1つ分のハイトマップ生成
ここが壊れていると針の山が出来たり地形に切れ目が出来ます
Mathf.PerlinNoiseに渡す引数を作っているRand.calucurate_perlin_valueについては後述

*public static float getHeight(float x, float z)
ワールド座標を受け取って、その位置の地形高さを返します。
Terrain生成後にプレイヤーキャラクターを初期化しているので、地形に埋まらないようにこれで高さを取得しています。


*using (SymmetricAlgorithm algo = new Speck()){algo.BlockSize = 128;
Speck ECB mode

*using (SymmetricAlgorithm algo = new SpeckCTR()){algo.BlockSize = 128;
Speck CTR mode


*var actionBlock = new ActionBlock<string>(async key =>{using (var s3Client = new AmazonS3Client())
ITargetBlock<T> を継承する ActionBlock で key を受け取ってファイルの中身を読み取る

*new ExecutionDataflowBlockOptions*{CancellationToken = cancellationToken,MaxDegreeOfParallelism = Environment.ProcessorCount});
Select で Task にくるんで WaitAll と異なりこの辺の制御ができる。

*await actionBlock.SendAsync(key, cancellationToken);
actionBlock に key を渡して投げる

*actionBlock.Complete();
actionBlock にもう依頼は無い事を通知する。

*await actionBlock.Completion;
actionBlock を await して全部終わるのを待つ。


*if (p.MainWindowTitle != "")
プロセス名(string)
p.ProcessName

*lists += p.MainWindowTitle + "\n";
タイトル名(string)


*public static AnimalTypeProperties GetProperties(this AnimalType code)*{AnimalTypeTable.TryGetValue(code, out AnimalTypeProperties prop);return prop;}
拡張メソッド


*var choosed = new T[] { };
選択結果は空からスタート

*var query = Expand(choices, choosed);
展開開始

*var newChoosed = choosed.Concat(new T[] { choice });
選択肢から1つ選んで、選択済要素に入れる

*var newChoices = choices.Where(v => !choice.Equals(v));
選択肢から削除

*var query = Expand(newChoices, newChoosed);
新たな選択肢と選択済要素で再帰

*yield return qq.ToArray();
配列を順次返す


*transform.Find("Panel
Text").GetComponent<Text>().text = notificationText(streamEvent);  GameObjectの親子関係は適宜直してください

*unitychan.GetComponent<NotificationUnitychan>().Response(CheckUnitychanResponse(streamEvent));
フキダシ(先述)
...
ユニティちゃん

*private string CheckUnitychanResponse(Twity.StreamEvent streamEvent)*{List<string> eventNameForUnitychanJump = new List<string>() { "favorite", "follow" };List<string> eventNameForUnitychanSad = new List<string>() { "unfavorite" };if (eventNameForUnitychanJump.IndexOf(streamEvent.event_name) != -1){return "Jump";}else if (eventNameForUnitychanSad.IndexOf(streamEvent.event_name) != -1){return "Sad";}else{return null;}}
streamEventに応じて"Jump"か"Sad"のどちらかを返す


*if( ガード条件 == 真 ){
ガード条件が真ならば、

*,,,
略

*private void entryサンプル状態状態1()*{_サンプル状態 = state.name;状態1のentryアクション}
状態1状態のentry/do/exit

*private void entryサンプル状態状態2()*{_サンプル状態 = state.name;状態2のentryアクション}
状態2状態のentry/do/exit

*private void entry状態マシン1状態a()*{_状態マシン1 = state.name;notifyStarted();}
状態a状態のentry/do/exit


*System.Threading.Thread.Sleep( 5000 );
5秒間スリープするだけ。

*await Task.Delay( 5000 );
1．Task.Delayはasyncで定義されている。なので、await識別子を指定する事が可能。
awaitすることで、一旦UIスレッドに処理を返す事が出来る。
= > 重たい処理が実行中でも、UI操作が可能。フリーズしない。
処理が終了すると、処理スレッドに戻る。

*}
2．Thread.Sleep処理はasyncで定義されていないので、await識別子を指定することが出来ない。
= > 「HeavyProcAsync」メソッドにasyncの定義があるが、UI操作が不可能。
System.Threading.Thread.Sleep( 5000 );
3. 2の処理に対して、非同期処理を行いたい場合は、
Task処理として動作させれば良い。
await Task.Factory.StartNew( () =>
{
System.Threading.Thread.Sleep( 5000 );
}
);


*var url = "https:
qiita.comapiv2items";


*if ( readSize1 != readSize2 ) { return DiffType.Unknown; }
unexpected.


*var d = this.RxProp.Zip(this.RxProp.Skip(1), (old, _) => old)
値の変更時に古い値を Dispose する

*d.AddTo(this.Disposer);
これは別件


*int ret2 = num?.Let((int nonNullNum) => nonNullNum * 2) ?? -1;
-> -1


*GlobalConfiguration.Configure({{クラス名}}.Controllers.WebApiConfig.Register);
以下を追加


*ReversePolishNotation rpn = ConvertToRpn(exp);
数式を逆ポーランド記法へ変換

*return RpnCalculator.Calculate(rpn);
逆ポーランド記法の式を計算する

*private static ReversePolishNotation ConvertToRpn(string exp) {var context = new Context(exp);var node = new ExpressionNode();node.Parse(context);if (!context.IsTerminate)throw new ArithmeticException("正しい式ではありません");return context.Notation;}
数式を逆ポーランド記法へ変換

*ReversePolishNotation rpn = ConvertToRpn(exp);
数式を逆ポーランド記法へ変換

*return RpnCalculator.Calculate(rpn);
逆ポーランド記法の式を計算する

*private static ReversePolishNotation ConvertToRpn(string exp) {var context = new Context(exp);var node = new ExpressionNode();node.Parse(context);if (!context.IsTerminate)throw new ArithmeticException("正しい式ではありません");return context.Notation;}
数式を逆ポーランド記法へ変換

*// https://qiita.com/gushwell/items/a40f4119a35a1e6d7622 のコメント*public class RpnCalculator {static Dictionary<string, Func<decimal, decimal, decimal>> binaryOperators =new Dictionary<string, Func<decimal, decimal, decimal>>() {["+"] = (a, b) => a + b,["-"] = (a, b) => a - b,["*"] = (a, b) => a * b,["/"] = (a, b) => a / b,};// 後置記法を計算するpublic static decimal Calculate(ReversePolishNotation rpn) {Stack<object> stack = new Stack<object>();foreach (var token in rpn.Tokens) {if (binaryOperators.ContainsKey(token)) {var b = (decimal)stack.Pop();var a = (decimal)stack.Pop();var c = binaryOperators[token](a, b);stack.Push(c);} else {stack.Push(decimal.Parse(token));}}return (decimal)stack.Pop();}}
shiracamusさんのコードを採用

*public class RpnCalculator {static Dictionary<string, Func<decimal, decimal, decimal>> binaryOperators =new Dictionary<string, Func<decimal, decimal, decimal>>() {["+"] = (a, b) => a + b,["-"] = (a, b) => a - b,["*"] = (a, b) => a * b,["/"] = (a, b) => a / b,};// 後置記法を計算するpublic static decimal Calculate(ReversePolishNotation rpn) {Stack<object> stack = new Stack<object>();foreach (var token in rpn.Tokens) {if (binaryOperators.ContainsKey(token)) {var b = (decimal)stack.Pop();var a = (decimal)stack.Pop();var c = binaryOperators[token](a, b);stack.Push(c);} else {stack.Push(decimal.Parse(token));}}return (decimal)stack.Pop();}}
https:qiita.com/gushwell/items/a40f4119a35a1e6d7622 のコメント

*public static decimal Calculate(ReversePolishNotation rpn) {Stack<object> stack = new Stack<object>();foreach (var token in rpn.Tokens) {if (binaryOperators.ContainsKey(token)) {var b = (decimal)stack.Pop();var a = (decimal)stack.Pop();var c = binaryOperators[token](a, b);stack.Push(c);} else {stack.Push(decimal.Parse(token));}}return (decimal)stack.Pop();}
後置記法を計算する

*public class Tokenizer {private string _expression;IEnumerator<string> _ite;public Tokenizer(string exp) {_expression = exp;_ite = GetTokens().GetEnumerator();}public bool MoveNext() {return _ite.MoveNext();}public string Current {get { return _ite.Current; }}private IEnumerable<string> GetTokens() {char c = NextChar();var token = "";while (c != (char)0) {if (char.IsDigit(c)) {token += c;} else if (c == '.' && token.All(x => x != '.')) {token += c;} else {if (token != "")yield return token;token = "";if (IsSymbol(c))yield return c.ToString();else if (c != ' ')throw new ArithmeticException("正しい式ではありません");}c = NextChar();}if (token != "")yield return token;}private static bool IsSymbol(char c) {if (c == '+' || c == '-' || c == '*' || c == '/' ||c == '(' || c == ')')return true;return false;}private int _currentIndex = 0;private char NextChar() {if (_currentIndex < _expression.Length)return _expression[_currentIndex++];return (char)0;}}
Tokenに分解する


*string animalName = animalType.GetTypeName();
イヌ


*private void Button_Click(object sender, RoutedEventArgs e)*{var vm = this.DataContext as ViewModel;if (null == vm) { return; }// ツリー表示となるデータを追加するvm.Add(new Person(vm._dumpData, vm.Data) { Name = "天財女王", Age = 57, VisibleGroup = Visibility.Visible });}
行追加ボタン押下処理

*vm.Add(new Person(vm._dumpData, vm.Data) { Name = "天財女王", Age = 57, VisibleGroup = Visibility.Visible });
ツリー表示となるデータを追加する

*public class Person : BindableBase*{private ObservableCollection<Person> _Child;private ObservableCollection<Person> _Parent;// 名前public string Name { get; set; }// 年齢private int _Age;public int Age{get => _Age;set{if (value < 0){MessageBox.Show("範囲外の値が設定されました。");OnPropertyChanged("Age");}else{SetProperty(ref _Age, value);}}}// 階層を展開するためのボタンの表示状態public Visibility VisibleGroup { get; set; } = Visibility.Collapsed;// 子階層を表示しているか否かprivate bool _IsOpen = false;public bool IsOpen{get => _IsOpen;set{_IsOpen = value;if (null != _Child){// 子階層があれば、表示／非表示に応じて、データを挿入／削除するif (_IsOpen){int index = _Parent.IndexOf(this) + 1;foreach (Person item in _Child){_Parent.Insert(index, item);}}else{int index = _Parent.IndexOf(this) + 1;foreach (Person item in _Child){_Parent.RemoveAt(index);}}}}}public Person() { }// 子階層と親階層を設定するpublic Person(ObservableCollection<Person> child, ObservableCollection<Person> parent){_Child = child;_Parent = parent;}}
DataGridに表示するデータ

*public string Name { get; set; }
名前

*private int _Age;
年齢

*public Visibility VisibleGroup { get; set; } = Visibility.Collapsed;
階層を展開するためのボタンの表示状態

*private bool _IsOpen = false;
子階層を表示しているか否か

*public Person(ObservableCollection<Person> child, ObservableCollection<Person> parent)*{_Child = child;_Parent = parent;}
子階層と親階層を設定する

*public ObservableCollection<Person> _dumpData = new ObservableCollection<Person>*{new Person{Name="　天財息子", Age=29},new Person{Name="　天財娘", Age=27}};
子階層用のデータ

*private ObservableCollection<Person> _Data = new ObservableCollection<Person>*{new Person{Name="天財太郎", Age=19},new Person{Name="天財次郎", Age=17}};
初期データ


*user.UserName = "urashimataro";
Change UserName column


*var startTime = new DateTime(2021, 2, 1);
ドキュメントによると現在の時刻より60日以上前にすることはできないようです。


*m.UploadStringFunc = () => throw new Exception("なんかエラー");
接続エラーをシミュレート

*HogeServiceClient3 h = new HogeServiceClient3(m);
モックオブジェクトを HogeServiceClient のコンストラクタに渡す


*[AllFilter("Controller2", Order = 0)]
Orderの順序検証用

*throw new Exception();
ExceptionFilter確認用

*}
～ Filter実装部省略 ～


*public void print3(){
ただの上書き定義


*var settings = new ConnectionSettings(new Uri("http:
<host>:<port>"))

*var health = client.CatHealth().Records.SingleOrDefault();
単一ホストのクラスタの場合

*var health = client.CatHealth().Records;
複数ホストのクラスタの場合


*var res = await client.PostAsJsonAsync("https:
api.line.mev2botmessagereply",

*new ReplyMessageObject()*{ReplyToken = data.ReplyToken,Messages = replyMessages}
送信データを作成


*Console.WriteLine(Object.ReferenceEquals("hogefuga","hogefuga"));
(A-5) True


*// ない場合「Entity type 'Item' has composite primary key defined with data annotations. To set composite primary key, use fluent API.」と表示される*modelBuilder.Entity<Item>().HasKey(c => new { c.Id, c.PointNo });
複合キーの場合、以下のように指定してやる。

*modelBuilder.Entity<Item>().HasKey(c => new { c.Id, c.PointNo });
ない場合「Entity type 'Item' has composite primary key defined with data annotations. To set composite primary key, use fluent API.」と表示される

*var item = new Item(){ Id = int.Parse(this.idText.Text),ItemName = this.itemNameText.Text,PointNo = int.Parse(this.pointIdText.Text),SortNum = int.Parse(this.sortNumText.Text)};
本当はMVVMにのっとってやるべきだけど、今回は動確ということでサボり

*db.SaveChanges();
コミット


*list.Sort(comparer);
comparer を使い回す


*e.Paint(e.ClipBounds, DataGridViewPaintParts.All);
セルを描画する

*Rectangle indexRect = e.CellBounds;
行番号を描画する範囲を決定する
e.AdvancedBorderStyleやe.CellStyle.Paddingは無視しています

*TextRenderer.DrawText(e.Graphics,(e.RowIndex + 1).ToString(),
行番号を描画する

*e.Handled = true;
描画が完了したことを知らせる


*power = this.Statuses[0].ModifyPower(power);
状態異常の0番目が攻撃力アップだとして


*this.options = options;
設定記述子

*}
データベースとの接続処理等を記述する。


*Application.Quit();
ゲーム終了

*cache_obj = instantiated_obj ?? GameObject.Instantiate(orig_obj);
やばい

*decode_buf = new byte[size];
YUVテクスチャのため注意

*decode_hn = GCHandle.Alloc(decode_buf, GCHandleType.Pinned);
GCHandleでbyte配列のポインタを取得


*List<Dictionary<string, string>> stationRecords = new List<Dictionary<string, string>>();
取得したレコードをListで保持します。
取得したデータはすべてstring型とする。

*using ( var sqliteConn = new SQLiteConnection( "Data Source=" + dbFilePath ) ){sqliteConn.Open();
DBに接続して、クエリを実行する。

*command.CommandText = "SELECT * from station";
クエリ実行

*Dictionary<string, string> record = new Dictionary<string, string>() {{ "stationName", reader["station_name"].ToString() },{ "longitude", reader["lon"].ToString() },{ "latitude",  reader["lat"].ToString()}};
Listに追加

*XElement rootElement = new XElement( "records" );
ルート部分のエレメントオブジェクト作成

*XElement rootElement = new XElement( "records" );
ルート部分のエレメントオブジェクト作成

*string xmlStream = SQLiteIF.GetStations( ".dbファイルのフルパスを指定" );
XMLストリームを取得

*XElement stationsElement = XElement.Parse( xmlStream );
XMLストリームからXElementオブジェクトを作成する場合は、
LoadではなくParseを使うこと。

*IEnumerable<XElement> stations = stationsElement.Elements( "record" );
<record>要素のコレクションを取得


*const int GC_PR_FGD = 3;
前景らしい領域を表す定数

*Mat image = new Mat("iphone8IMGL7576_TP_V4.jpg", ImreadModes.Color);
対象画像オブジェクト

*Rect rectangle = new Rect(300, 20, 650, 500);
前景を含む領域

*var result = new Mat(image.Size(), MatType.CV_8U);
前景を抽出

*Cv2.GrabCut(image, result, rectangle, bgdModel, fgdModel, 5, GrabCutModes.InitWithRect);
GrabCutするイテレーションに5回を指定

*Mat foreground = new Mat(image.Size(), MatType.CV_8UC3, new Scalar(255, 255, 255));*image.CopyTo(foreground, result);
抽出した前景を貼り付ける画像、ソースと同サイズの真っ白な画像を指定

*Cv2.ImShow("タイトル", foreground);*Cv2.WaitKey();
表示


*void Ping(string path)*{//対象アセットをロードvar obj = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(path);//存在すればPingif (obj)EditorGUIUtility.PingObject(obj);}
指定したパスのファイルにPingを飛ばす。パスは "Assets/..." で拡張子まで。

*var obj = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(path);
対象アセットをロード

*if (obj)*EditorGUIUtility.PingObject(obj);
存在すればPing

*var flag = BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static;
メソッド検索オプションを設定

*var asm = Assembly.Load("UnityEditor");
UnityEditor.dllを取得

*var projectwindowtype = asm.GetType("UnityEditor.ProjectBrowser");
ProjectBrowserクラスを取得

*var viewmodetype = asm.GetType("UnityEditor.ProjectBrowser+ViewMode");
列挙体 ProjectBrowser.ViewMode を取得

*var GetFolderInstanceIDs = projectwindowtype.GetMethod("GetFolderInstanceIDs", flag);
フォルダIDを取得するメソッドを取得

*var SetFolderSelection = projectwindowtype.GetMethod("SetFolderSelection", flag);
任意IDのフォルダを選択するメソッドを取得

*var InitViewMode = projectwindowtype.GetMethod("InitViewMode", flag);
ビューモードを設定するメソッドを取得

*var projectwindow = EditorWindow.GetWindow(projectwindowtype, false, "Project", false);
プロジェクトウィンドウを取得

*projectwindow.Focus();
プロジェクトウィンドウにフォーカス

*InitViewMode.Invoke(projectwindow, new[] { Enum.GetValues(viewmodetype).GetValue(1) });
プロジェクトウィンドウを２カラム表示に変更

*int[] folderids = (int[])GetFolderInstanceIDs.Invoke(null, new[] { paths });
渡されたパスのフォルダIDを取得

*SetFolderSelection.Invoke(projectwindow, new object[] { folderids, false });
取得したIDのフォルダを選択（第二引数はとりあえずfalse）


*ws.MessageReceived += async (s, e) =>*{var data = DynamicJson.Parse(e.Message);if (!data.IsDefined("type")) return;string type = data["type"];if (!string.IsNullOrEmpty(type)){if (type == "goodbye"){Console.WriteLine("Slack goodbye.");isExit = true;}// メッセージ以外は弾くif (type != "message") return;if (data.IsDefined("subtype")) return;// 編集されたテキストは弾くif (data.IsDefined("edited")) return;var channel = data["channel"].ToString();var c = client.FindChannel(channel);if (c == null) return;// troomに投稿されたメッセージか確認if (c.name != "troom" && channel != "troom") return;// 文字列に犬の鳴き声があるstring text = data["text"];var mc = Regex.Matches(text, @"(わん|ワン|wan|ﾜﾝ)", RegexOptions.Multiline);if (mc.Count <= 0) return;// shibe.online から画像URLを取得var mes = WWW.GET("http://shibe.online/api/shibes?count=1&urls=true&httpsUrls=false");var res = DynamicJson.Parse(mes);// 同じ画像でも展開されるように、現在時刻をUnixTimeで入れるvar imageUrl = string.Format("{0}?{1}", res[0].ToString(), TimeUtil.GetUnixTime(DateTime.Now));// チャンネルに投稿await client.PostMessageAsync(channel, imageUrl, "shibainu", icon_emoji: ":shibainu:");}};
文字列受信

*if (type != "message") return;*if (data.IsDefined("subtype")) return;
メッセージ以外は弾く

*if (data.IsDefined("edited")) return;*var channel = data["channel"].ToString();
編集されたテキストは弾く

*if (c.name != "troom" && channel != "troom") return;*// 文字列に犬の鳴き声がある
troomに投稿されたメッセージか確認

*string text = data["text"];
文字列に犬の鳴き声がある

*var res = DynamicJson.Parse(mes);
shibe.online から画像URLを取得
var mes = WWW.GET("http:shibe.online/api/shibes?count=1&urls=true&httpsUrls=false");

*var imageUrl = string.Format("{0}?{1}", res[0].ToString(), TimeUtil.GetUnixTime(DateTime.Now));
同じ画像でも展開されるように、現在時刻をUnixTimeで入れる

*await client.PostMessageAsync(channel, imageUrl, "shibainu", icon_emoji: ":shibainu:");
チャンネルに投稿

*ws.Closed += (s, e) =>*{// 閉じられたConsole.WriteLine("Websocket close!");isExit = true;};
サーバーから切断された

*Console.WriteLine("Websocket close!");
閉じられた

*ws.Open();
サーバ接続開始

*ws.Open();
サーバ接続開始


*options.Cookie.SameSite = Microsoft.AspNetCore.Http.SameSiteMode.None;
外す場合


*var dealer_cards = new Cards(Console.ReadLine());
ディーラーのカード


*private const int Bufsize = 4096;
?


*this.options = options;
設定記述子

*}
データベースとの接続処理等を記述する。


*#endif*}
GL.InvalidateState();


*return Redirect("Welcome");
登録処理とか


*"asdfghjkl1234567890qwertyuiop0987654321");
スプレッドシートのURLに記載のID

*// 参考：https://www.codeproject.com/Tips/1007522/Temper-USB-Thermometer-in-Csharp*static readonly byte[] ini = { 0x01, 0x01 };
初期化に必要なレポートデータ

*static readonly byte[] ini = { 0x01, 0x01 };
参考：https:www.codeproject.com/Tips/1007522/Temper-USB-Thermometer-in-Csharp

*for (int i = 0; i < 2; i++)
上記で準備完了なのだが、この時点で温度を取得すると75℃といった異常な値が取れる。
2回ほど読み捨ててごみを除去する。

*private static double GetTemperatureCelsius(IHidDevice bulk)*{var report = WriteAndReadReport(bulk, 0x00, temp);int rawReading = (report.Data[3] & 0xFF) + (report.Data[2] << 8);const double calibrationOffset = -1.70;const double calibrationScale = 1;double temperatureCelsius = (calibrationScale * (rawReading * (125.0 / 32000.0))) + calibrationOffset;return temperatureCelsius;}
摂氏で今の温度を取得する


*int screen_width = _liveCamera.OutputTexture.width;
カメラ映像の縦横を取得しておく

*mat_calibration = new Mat(screen_height, screen_width, CvType.CV_8UC4);
キャリブレーション画像の領域をRGBAで初期化しておく。

*using (Mat mat_livecamera = new Mat(screen_height, screen_width, CvType.CV_8UC4))
openCV系のライブラリをUpdate()の中で使う場合にはusingを多用してリソースをちゃんとリリースさせたほうがよい。すぐ落ちるから。
カメラ画像もRGBAを想定して４チャンネル分を確保しておく。

*Utils.textureToMat(_liveCamera.OutputTexture, mat_livecamera);
カメラ画像はTextureで取れるので、それをMAT型に変換しOpenCVで画像処理しやすいようにする。

*Core.flip(mat_bg_rgba, mat_bg_rgba, 0);
画像データ（数値データ）を反転させる(0->255へ。255->0へ)

*mog2.apply(mat_calibration, fgMaskMat);
BackgroundSubtractorMOG2メソッドを使って背景差分を導出する

*Imgproc.threshold(fgMaskMat, fgMaskMat, 100, 255, Imgproc.THRESH_BINARY);
場合によっては2値化させる前に画像をぼやかして、ちいさい差分を消す。（なかったことにする）
Imgproc.medianBlur(fgMaskMat, fgMaskMat, 10);
透過させる場所をはっきりさせるため、2値下する。

*Core.bitwise_not(fgMaskMat, bgMaskMat);
マスク画像をつかって画像を反転させる。

*Utils.matToTexture(mat_livecamera, texture);
完成した画像をMAT型から元のTexture型に変換する。


*}
メソッドやプロパティの列挙も可能.


*System.Windows.Forms.PowerLineStatus pls = SystemInformation.PowerStatus.PowerLineStatus;*switch (pls)
AC電源の状態

*BatteryChargeStatus bcs =SystemInformation.PowerStatus.BatteryChargeStatus;
バッテリーの充電状態を取得する

*float blp = SystemInformation.PowerStatus.BatteryLifePercent;*System.Windows.MessageBox.Show("バッテリー残量は、"+ blp * 100+"%です。");
バッテリー残量（割合）

*int blr = SystemInformation.PowerStatus.BatteryLifeRemaining;*if (-1 < blr)
バッテリー残量（時間）

*System.Windows.MessageBox.Show("バッテリー残り時間は、不明です");
AC電源がオンラインの時など

*int bfl = SystemInformation.PowerStatus.BatteryFullLifetime;*if (-1 < bfl)
バッテリーがフル充電された時の持ち時間（バッテリー駆動時間）


*byte[] emptyBytes = {0, 0, 0, 0};
コンテンツの長さを取得する。

*throw new ArgumentException("PEM file is too large.");
Intにしてるので4byte以上の場合はパースできない。

*throw new ArgumentException("PEM file is too large.");
Intにキャスト失敗した場合はパースできない。

*contentLength = privKeyBuf[index++];
最上位Bitが立っていなければ、そのbyte自体がコンテンツの長さを表す。


*context.Notation.Add(token);
これを追加


*int result = await task;
-> 1998


*Swap(ref x, ref y);*Console.WriteLine("x = {0:d}, y = {1:d}\n", x, y);
x と y の値を交換

*static void Swap(ref int x, ref int y)*{var u = x;x = y;y = u;}
x と y の値を交換するメソッド


*session = OAuth.Authorize("APIKEY", "APISECRET");
Pinの発行

*string pincode = textBox.Text;
トークンの発行

*var text = "認証成功";
ツイート


*List<int> list =  Enumerable.Range(0, 10).Where(i => i % 2 == 0).Select(i => i * 2).ToList();
実際に使用できる


*Increment = Counter.Select(x => x < 10).ToReactiveCommand();
Increment コマンドは、 Counter が 10 未満の間、使用可能

*Increment.Subscribe(x => Counter.Value = Counter.Value + 1);
Increment コマンドが実行されたら Counter を +1 してく


*private static void Main()*{int[] array = new int[]{0,1,2,3,4,5,6};for (int i = 0; i < array.Length; i++){Console.WriteLine(array[i]);}}
ConsoleAppArrayFor.Program

*private static void Main()*{int[] array = new int[]{0,1,2,3,4,5,6};int[] array2 = array;for (int i = 0; i < array2.Length; i++){int num = array2[i];Console.WriteLine(num);}}
ConsoleAppArrayFor.Program

*private static void Main()*{int[] numbers = new int[]{0,1,2,3,4,5,6};foreach (int i in numbers){Console.WriteLine(i);}}
Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250


*MMDevice device;
音量を変更


*var max = doubleList.Max();
1回目ループ

*var min = doubleList.Min();
2回目ループ

*var average = doubleList.Average();
3回目ループ

*var max = doubleList.First();
NaNチェックを避けるため1つ目の値をいれておく


*public class Association<TKey1, TKey2, TValue> where TValue : class
where T : class が Tは参照型のみの意味


*return *((short *) pbyte);
この行はリトルエンディアンでしか使用できない。


*public partial class MainWindow : NavigationWindow
この行を変更

*var secondPage = new SecondPage();
下記2行を追加


*g.AddEdge(new Edge("d8", "ee", "f", 0));
E -> finish


*void Start () {//本来はUpdateに書いた方が良さそうな内容だが、プリントがやたら出るのでStartにてテスト//------------------------------//スイッチ文のサンプル//条件には、string型,float型などは使えない。//intとenumが使える。//int を直接数値で使う場合は状態のイメージがわかないので、//書いてみると、レベルやhpなど数値で分かるものを利用すべきだと思った。switch (State){case 1:print (State);//breakは無いと VSCode上でエラーが出る。役目はスイッチ文からの脱出//原語や環境によっては、break必須ではなさそう。break;//breakの下に命令を書いても意味がないし、これもVSCode上でエラーが出る。case 2:print (State);break;case 3:print (State);break;//default は書かなくても動く　elseと同じ役割default:print (State);break;}//------------------------------//上のスイッチ文と同じ結果になるif文if(State==0){print (State);}else if(State==1){print (State);}else if(State==3){print (State);}else{print (State);}//必ずしもif文が長くなる訳では無いことが・・・・分かるなぁ・・・//特に複雑な条件で分岐させるには　if文が強そう。//------------------------------//なるほど enum と相性が良さそう！//状態を分けるのはif文を利用して、その後の処理はSwitch文を利用するのが良さそう。switch (e_MyState){case MyState.Wait:print (e_MyState);break;case MyState.Run:print (e_MyState);break;case MyState.Sleep:print (e_MyState);break;default:print (e_MyState);break;}}
Use this for initialization

*switch (State)
本来はUpdateに書いた方が良さそうな内容だが、プリントがやたら出るのでStartにてテスト
------------------------------
スイッチ文のサンプル
条件には、string型,float型などは使えない。
intとenumが使える。
int を直接数値で使う場合は状態のイメージがわかないので、
書いてみると、レベルやhpなど数値で分かるものを利用すべきだと思った。

*break;
breakは無いと VSCode上でエラーが出る。役目はスイッチ文からの脱出
原語や環境によっては、break必須ではなさそう。

*case 2:
breakの下に命令を書いても意味がないし、これもVSCode上でエラーが出る。

*default:
default は書かなくても動く　elseと同じ役割

*//特に複雑な条件で分岐させるには　if文が強そう。*//------------------------------
必ずしもif文が長くなる訳では無いことが・・・・分かるなぁ・・・

*switch (e_MyState)
特に複雑な条件で分岐させるには　if文が強そう。
------------------------------
なるほど enum と相性が良さそう！
状態を分けるのはif文を利用して、その後の処理はSwitch文を利用するのが良さそう。


*Console.WriteLine(a);
5


*}
処理

*}
処理

*}
処理

*}
処理

*}
処理

*}
処理

*}
処理


*alpha = 0;
alpha値の初期化(色が透明な状態)


*counter++;
処理


*gamemanagerOBJ = GameObject.FindGameObjectWithTag("GameManager");
GameManagerを取得

*gamemanagerOBJ.SendMessage("GetScore",enemystatus.sc);
取得したGameManagerの"GetScore"を呼び出す


*using TimeSeriesData = Dictionary<DateTime, int>;
時系列データを表す型をusing宣言

*Dictionary<string, TimeSeriesData> supplyData;
更にそれを種類ごとに記録するためのDictionary
例：
supplyData["燃料"][DateTime.Parse("2017/11/22 10:20:30")] = 12345
supplyData["資金"][DateTime.Parse("2017/11/23 11:21:31")] = 23456

*private PlotModel graphModel;*public PlotModel GraphModel {get => graphModel;set {graphModel = value;NotifyPropertyChanged();}}
Model側

*var newGraphModel = new PlotModel();*newGraphModel.Axes.Add(new LinearAxis { Position = AxisPosition.Bottom, Title = "X軸" });
PlotModelを作成して上書きする

*newGraphModel.InvalidatePlot(true);
グラフの要素を画面に反映する

*DateTime graphMin, graphMax;
軸の最小・最大値

*var dateTimeAxis = new DateTimeAxis{最小値を設定Minimum = DateTimeAxis.ToDouble(graphMin),最大値を設定Maximum = DateTimeAxis.ToDouble(graphMin),表記を書式文字列で設定下記例では「2017/11/21」といった風になるStringFormat = "yyyy/MM/dd"};
時刻表示向けの軸としてDateTimeAxisがあるのでそれを初期化する

*Minimum = DateTimeAxis.ToDouble(graphMin),最大値を設定Maximum = DateTimeAxis.ToDouble(graphMin),表記を書式文字列で設定下記例では「2017/11/21」といった風になるStringFormat = "yyyy/MM/dd"};
最小値を設定

*Maximum = DateTimeAxis.ToDouble(graphMin),表記を書式文字列で設定下記例では「2017/11/21」といった風になるStringFormat = "yyyy/MM/dd"};
最大値を設定

*StringFormat = "yyyy/MM/dd"
表記を書式文字列で設定
下記例では「2017/11/21」といった風になる

*DateTime plotX;
DateTimeAxis.ToDoubleは、ChartコントロールにおけるDateTime#ToOADateのようなもの

*MajorStep = 5,小さな間隔を指定MinorStep = 1,大きな間隔で置かれる罫線のスタイル(この場合は実線・黒色)MajorGridlineStyle = LineStyle.Solid,MajorGridlineColor = OxyColors.Black,小さな間隔で置かれる罫線のスタイル(この場合は実線・灰色)MinorGridlineStyle = LineStyle.Dot,MinorGridlineColor = OxyColors.Gray};
大きな間隔を指定

*MinorStep = 1,大きな間隔で置かれる罫線のスタイル(この場合は実線・黒色)MajorGridlineStyle = LineStyle.Solid,MajorGridlineColor = OxyColors.Black,小さな間隔で置かれる罫線のスタイル(この場合は実線・灰色)MinorGridlineStyle = LineStyle.Dot,MinorGridlineColor = OxyColors.Gray};
小さな間隔を指定

*MajorGridlineStyle = LineStyle.Solid,MajorGridlineColor = OxyColors.Black,小さな間隔で置かれる罫線のスタイル(この場合は実線・灰色)MinorGridlineStyle = LineStyle.Dot,MinorGridlineColor = OxyColors.Gray};
大きな間隔で置かれる罫線のスタイル(この場合は実線・黒色)

*MinorGridlineStyle = LineStyle.Dot,MinorGridlineColor = OxyColors.Gray};
小さな間隔で置かれる罫線のスタイル(この場合は実線・灰色)

*var y1Axis = new LinearAxis{ Position = AxisPosition.Left,  Key = "Primary" };
Keyに設定する文字列は一意なら何でもいい。それこそ"左軸"・"右軸"とかでもいい

*var lineSeries1 = new LineSeries();
Series作成時に、どちら側の軸に属するかを設定する

*plotModel.Axes.Add(new LinearAxis {Position = AxisPosition.Left});
横軸・縦軸を追加する。今回は縦軸をLinearAxisとした(LabelListはList<string>など、ラベルを表す値)

*// ループが「積み上げ棒の各成分」→「各積み上げ棒における成分値」となっていることに注意*for (int type = 0; type < Type.Max; ++k) {// インスタンスを初期化var columnSeries = new ColumnSeries();// 積み上げられるようにするcolumnSeries.IsStacked = true;// ここに代入しておくと、積み上げ棒の成分の名前(判例)がマウスオーバーで表示できるようになるcolumnSeries.Title = $"{columnLabel[k]}";// 成分値を追加していくfor (int n = 0; n < Data[type].Max; ++n) {columnSeries.Items.Add(new ColumnItem(Data[type][n]));}plotModel.Series.Add(columnSeries);}
グラフ要素を追加する

*var columnSeries = new ColumnSeries();
インスタンスを初期化

*columnSeries.IsStacked = true;
積み上げられるようにする

*columnSeries.Title = $"{columnLabel[k]}";
ここに代入しておくと、積み上げ棒の成分の名前(判例)がマウスオーバーで表示できるようになる


*print(b);
これは結局、b=1がb++2回処理されるので　３がプリントされる


*bc.SetBrightness(40);
輝度 40


*...
Dispose e


*StandingTypeInvoke ();
演出の種類を切り替える関数の呼び出し


*ilGenerator.Emit(OpCodes.Ldarg_1);
インデックス1の引数(target)をスタックに積む

*ilGenerator.Emit(OpCodes.Castclass, pi.DeclaringType);
pi.DeclaringType(Data型)のキャスト

*ilGenerator.Emit(OpCodes.Callvirt, pi.GetGetMethod());
スタック上にあるオブジェクトのプロパティ(StringValue)のGetメソッドを呼び出す

*ilGenerator.Emit(OpCodes.Ret);
戻り値を返す

*ilGenerator.Emit(OpCodes.Ldarg_1);
インデックス1の引数(target)をスタックに積んでpi.DeclaringType(Data型)にキャスト

*ilGenerator.Emit(OpCodes.Ldarg_2);
インデックス2の引数(value)をスタックに積んでpi.PropertyType(string型)にキャスト

*ilGenerator.Emit(OpCodes.Callvirt, pi.GetSetMethod());
スタック上にあるオブジェクトのプロパティ(StringValue)のSetメソッドを呼び出す

*ilGenerator.Emit(OpCodes.Ret);
戻る

*ilGenerator.Emit(OpCodes.Box, pi.PropertyType);
Box化する

*}
ここにValueType用のコードを追加

*ilGenerator.Emit(OpCodes.Ldarg_1);
以下はstringの時のコードに同じ

*var hasValue = ilGenerator.DefineLabel();
ValueType用のコード

*ilGenerator.Emit(OpCodes.Ret);
nullの時
...

*ilGenerator.MarkLabel(hasValue);
null以外の時

*ilGenerator.MarkLabel(hasValue);
分岐で飛んでくるラベルの定義

*ilGenerator.Emit(OpCodes.Ldarg_1);
インデックス1の引数(target)をスタックに積んでpi.DeclaringType(Data型)にキャスト

*ilGenerator.Emit(OpCodes.Ldarg_2);
インデックス2の引数(value)をスタックに積んでUnbox

*ilGenerator.Emit(OpCodes.Callvirt, pi.GetSetMethod());
スタック上にあるオブジェクトのプロパティ(IntValue)のSetメソッドを呼び出す

*ilGenerator.Emit(OpCodes.Ret);
戻る

*ilGenerator.Emit(OpCodes.Ldarg_1);
インデックス1の引数(target)をスタックに積んでpi.DeclaringType(Data型)にキャスト

*}
プリミティブ以外の処理(次章以降で解説)

*ilGenerator.Emit(OpCodes.Callvirt, pi.GetSetMethod());
スタック上にあるオブジェクトのプロパティのSetメソッドを呼び出す

*ilGenerator.Emit(OpCodes.Ret);
戻る

*var local = ilGenerator.DeclareLocal(pi.PropertyType);
ローカル変数の宣言

*ilGenerator.Emit(OpCodes.Ldloca_S, local);
ローカル変数のアドレスをスタック

*ilGenerator.Emit(OpCodes.Initobj, pi.PropertyType);
型の初期化

*ilGenerator.Emit(OpCodes.Ldloc_0);
ローカル変数をスタック

*var type = pi.PropertyType.IsEnum ? pi.PropertyType.GetEnumUnderlyingType() : pi.PropertyType;
Enumならその基となる型で、初期値用の処理をテーブルから取得

*var local = ilGenerator.DeclareLocal(pi.PropertyType);
structの処理

*ilGenerator.Emit(OpCodes.Newobj, typeof(NotSupportedException).GetConstructor(Type.EmptyTypes));
NotSupportedExceptionを作って

*ilGenerator.Emit(OpCodes.Throw);
throwする

*,,,
...既存のIL生成コードの記述


*i0 = 1,i1 = g.Where(c => c.Group == 1).Count(),
Group = g.Key,

*i0 = 1,i1 = g.Where(c => c.Group == 1).Count(),
Group = g.Key,

*public class Employee*{public int Group { set; get; }public string Name { set; get; }}
Define other methods and classes here


*System.Windows.Media.Imaging.BitmapImage bitmapImage;
BitmapImage型の画像

*System.Windows.Media.Imaging.BitmapImage bitmapImage;
BitmapImage型の画像

*System.Windows.Media.Imaging.BitmapSource bitmapSource = bitmapImage;
BitmapImage→BitmapSource(型変換を明示する必要はない)

*System.Windows.Media.Imaging.BitmapImage bitmapImage2 = (System.Windows.Media.Imaging.BitmapImage)bitmapSource;
BitmapSource→BitmapImage(型変換を明示する必要がある)

*System.Drawing.Bitmap bitmap;
変換元の画像

*using (var ms = new System.IO.MemoryStream()) {MemoryStreamに書き出すbitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Bmp);
MemoryStreamを利用した変換処理

*bitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Bmp);
MemoryStreamに書き出す

*ms.Seek(0, System.IO.SeekOrigin.Begin);
MemoryStreamをシーク

*System.Windows.Media.Imaging.BitmapSource bitmapSource =
MemoryStreamからBitmapFrameを作成
(BitmapFrameはBitmapSourceを継承しているのでそのまま渡せばOK)

*System.Drawing.Bitmap bitmap;
変換元の画像

*using (var ms = new System.IO.MemoryStream()) {bitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Bmp);
MemoryStreamを利用した変換処理

*ms.Position = 0;
MemoryStreamのポジションを設定？

*var bitmapImage = new System.Windows.Media.Imaging.BitmapImage();
BitmapImageを初期化

*bitmapImage.BeginInit();
MemoryStreamを書き込むために準備する

*bitmapImage.StreamSource = ms;
MemoryStreamを書き込む

*bitmapImage.Freeze();
ここでFreezeしておくといいらしい(参考資料参照)

*System.Windows.Media.Imaging.BitmapSource bitmapSource = bitmapImage;
BitmapImageはBitmapSourceを継承しているのでそのまま渡せばOK

*System.Drawing.Bitmap bitmap;
変換元の画像

*var hBitmap = bitmap.GetHbitmap();
HBitmapに変換

*try {var bitmapSource = System.Windows.Interop.Imaging.CreateBitmapSourceFromHBitmap(hBitmap,System.IntPtr.Zero,System.Windows.Int32Rect.Empty,System.Windows.Media.Imaging.BitmapSizeOptions.FromEmptyOptions());}
HBitmapからBitmapSourceを作成

*System.Windows.Media.Imaging.BitmapSource bitmapSource;
LockBitsとUnlockBitsを使う方法
フォーマット決め打ちなので、他フォーマットだと別途変換が必要。
詳しくは参考資料における「ルーチェ's Homepage」または「nuits.jp blog」のコードを参照すること
元画像

*var bitmap = new System.Drawing.Bitmap(bitmapSource.PixelWidth,bitmapSource.PixelHeight,System.Drawing.Imaging.PixelFormat.Format32bppPArgb);
処理

*System.Windows.Media.Imaging.BitmapSource bitmapSource;
Encoderを使う方法
かなり楽だがその分遅い。
SampleEncoderがSystem.Windows.Media.Imaging.BmpBitmapEncoderなら不透明部分を扱えず、
System.Windows.Media.Imaging.PngBitmapEncoderなら高性能な分余計に遅くなる
元画像

*var encoder = new SampleEncoder();
処理

*bitmap = new System.Drawing.Bitmap(temp);
このおまじないの意味は参考資料を参照


*q = null;
ガベコレの対象になるはず


*IEnumerable<Order> Read();
受注データを列挙して返す

*void Delete();
ファイルを削除する

*}*public void Delete() {// ファイル削除処理}
固定長テキストの処理

*}
ファイル削除処理

*}*public void Delete() {// ファイル削除処理}
CSVファイルの処理

*}
ファイル削除処理

*}*public void Delete() {// ファイル削除処理}
XMLファイルの処理

*}
ファイル削除処理

*}
orderをDB登録する処理


*this.transform.localScale = Vector3.zero;
みえない大きさにする

*}
ぶつかった位置にexplodeというprefabを配置する


*var typeInfo = typeBuilder.CreateTypeInfo();
(ここでプロパティ、コンストラクタ、メソッドを定義)

*ilGenerator.Emit(OpCodes.Ldarg_0);
インデックス0の引数(this)をスタックに積む

*ilGenerator.Emit(OpCodes.Ldfld, sourceField);
スタック上にあるオブジェクト内のフィールド(source)を取得

*ilGenerator.Emit(OpCodes.Ret);
戻り値を返す

*ilGenerator.Emit(OpCodes.Ldarg_0);
objectのコンストラクタを呼ぶ

*ilGenerator.Emit(OpCodes.Ldarg_0);
引数のsourceの値をフィールドのsourceに格納する

*ilGenerator.Emit(OpCodes.Ret);
戻る

*ilGenerator.Emit(OpCodes.Newobj, ci);
インスタンス生成

*ilGenerator.Emit(OpCodes.Ret);
返す

*ilGenerator.Emit(OpCodes.Ldarg_1);
argumentsの

*ilGenerator.EmitLdcI4(i);
i番目を

*ilGenerator.Emit(OpCodes.Ldelem_Ref);
スタックして

*ilGenerator.EmitTypeConversion(ci.GetParameters()[i].ParameterType);
型変換

*ilGenerator.Emit(OpCodes.Newobj, ci);
インスタンス生成

*ilGenerator.Emit(OpCodes.Ret);
返す


*this.options = options;
設定記述子

*}
データベース接続処理等を記述する。


*public ReversePolishNotation Notation { get; } = new ReversePolishNotation();
逆ポーランド記法を表すオブジェクト

*// MoveNextを呼び出した後でも、このプロパティを見れば、次があるかどうかがわかる。*public bool IsTerminate { get; private set; } = false;
トークンの取得が終わったかどうかを示す。

*public bool IsTerminate { get; private set; } = false;
MoveNextを呼び出した後でも、このプロパティを見れば、次があるかどうかがわかる。

*public Context(string exp) {_tokenizer = new Tokenizer(exp);_tokenizer.MoveNext();}
コンストラクタ　加減乗除を行う数式を引数で受け取る

*// 最初のトークンを取り出すには、まず、MoveNextを呼び出す必要がある。*public bool MoveNext() {if (_tokenizer.MoveNext())return true;IsTerminate = true;return false;}
次のトークンを取り出すためにカレントを移動する

*public bool MoveNext() {if (_tokenizer.MoveNext())return true;IsTerminate = true;return false;}
最初のトークンを取り出すには、まず、MoveNextを呼び出す必要がある。

*public string CurrentToken {get { return _tokenizer.Current; }}
現在のトークン


*詳細については、http:
go.microsoft.comfwlink?LinkID=314055 をご覧ください。 ---> System.Web.UI.ViewStateException: 無効な viewstate です。


*EnumExt.TryParse("5", out ss);
true, ss = SolarSystem.Jupiter


*public event PropertyChangedEventHandler PropertyChanged;
INotifyPropertyChanged実装

*private List<object> _ItemSource;
添付プロパティでItemSourceは不要になる

*new FrameworkPropertyMetadata()*{PropertyChangedCallback = OnSelectedEnumItemChanged,BindsTwoWayByDefault = true});
デフォルトBindingモードをTwoWayにするために、FrameworkPropertyMetadataを使用

*Type newType = e.NewValue?.GetType();
添付プロパティの変更値が有効でなかったら無効

*var selector = d as Selector;
添付されたコントロールがSelector以外では無効

*selector.ItemsSource = Enum.GetValues(newType);
添付されたSelectorのItemSourceに列挙型の全値を入力

*selector.SelectedItem = e.NewValue;
SelectedItemに直接値を入力

*var binding = new Binding(){Path = new PropertyPath(AutoEnumSource.SelectedEnumItemProperty),RelativeSource = RelativeSource.Self,Mode = BindingMode.TwoWay};
SelectorのSelctedItemにこの添付プロパティを双方向Bindingする


*this.options = options;
設定記述子

*}
データベース接続処理等を記述する。


*yield return new WaitForSeconds(0.5f);
0.5秒待って


*public int ID { get; } = 1;
getのみも可能

*} catch (ArgumentException e) when (e.Message == "unknown") {Messageがunknownの時はメッセージを出力Console.WriteLine(e.Message);
Messageがtestの時はエラー無視

*Console.WriteLine(e.Message);*} catch (ArgumentException e) {
Messageがunknownの時はメッセージを出力

*throw;
その他


*public void function(){// 複合フラグメントbreak の前に描かれた処理if( Guard == true ){// 複合フラグメントbreak 内に描かれた処理return;}// 複合フラグメントbreak の後に描かれた処理return;}
シーケンス図が、1つのメソッドの場合の例

*return;
複合フラグメントbreak 内に描かれた処理

*return;
複合フラグメントbreak の後に描かれた処理

*break;
複合フラグメントbreak 内に描かれた処理

*break;
複合フラグメントbreak の後に描かれた処理

*break;
複合フラグメントbreak 内に描かれた処理

*}
複合フラグメントbreak の後に描かれた処理


*UInt64 bleAddress = 0xff00ff00ff00ff00;
ダミーアドレス

*var bleDevice = AsyncWrapper.Await<BluetoothLEDevice>(() =>
ラムダ式を渡す場合はAwait<返り値の型>と明示する必要あり
IAsyncOperationなどを返すメソッドはAsTask()で明示的にTaskに変換する


*public EventAggregator HelloRequest { get; }
Viewへのリクエスト

*public ReactiveCommand HelloCommand { get; }
ボタンの動作

*HelloCommand.Subscribe(_ => HelloRequest.GetEvent<PubSubEvent>().Publish());
ボタン押下時、Viewへリクエストを発行する。

*var viewModel = new _MainWindowViewModel();
ViewModelの初期設定

*var hello = "Hello, Prism!";
リクエストが発行されたら、MessageBoxを表示する

*viewModel.HelloRequest.GetEvent<PubSubEvent>().Subscribe(() => MessageBox.Show(hello));
リクエストが発行されたら、MessageBoxを表示する
var hello = "Hello, Prism!";   ローカル変数にする
ここのラムダ式がGCに回収される！

*var hello = "Hello, Prism!";
リクエストが発行されたら、MessageBoxを表示する

*viewModel.HelloRequest.GetEvent<PubSubEvent>().Subscribe(() => MessageBox.Show(hello), true);
第2引数にtrueを指定する


*Expression.Lambda<Func<int>>(Expression.Add(Expression.Constant(4),
引数なし、返り値がintのラムダ式を表す

*Func<int> func=expr.Compile();
動的コード生成

*Console.WriteLine(func());
実行してみる

*Expression.Lambda<Func<int,int,int>>(Expression.Add(x,y),x,y
引数なし、返り値がintのラムダ式を表す

*Func<int,int,int> func=expr.Compile();
動的コード生成

*Console.WriteLine(func(4,6));
実行してみる


*this.options = options;
設定記述子

*}
データベースとの接続処理等を記述する。


*private delegate bool WNDENUMPROC(IntPtr hWnd, IntPtr lParam);
EnumWindowsから呼び出されるコールバック関数WNDENUMPROCのデリゲート

*public class Window*{public string ClassName;public string Title;public IntPtr hWnd;}
Windowsクラス

*public static List<List<Window>> WindowsList { get; set; }
Windowsクラスの格納リスト

*public static void Initialize(string processName, bool isAll = false){キャッシュクリアしない場合、同じプロセス名なら画面情報を再利用するif (_oldProcessName == null || _oldProcessName.ToUpper() != processName.ToUpper()){初期化_hWndList.Clear();
初期化

*_hWndList.Clear();
初期化

*_targetProcessName = processName;
画面情報の取得

*public static bool ExistsTitle(string title)*{bool result = false;foreach (List<Window> win in WindowsList){result = win.Any(x => x.Title == title);if (result) break;}return result;}
タイトル存在チェック

*public static void Clear()*{_oldProcessName = null;_hWndList = new List<IntPtr>();}
キャッシュをクリアする

*public static string GetActiveProcessName()*{// 現在アクティブなプロセスIDとプロセス名を取得int processId;GetWindowThreadProcessId(GetForegroundWindow(), out processId);return Process.GetProcessById(processId).ProcessName;}
アクティブなプロセス名を取得する

*int processId;
現在アクティブなプロセスIDとプロセス名を取得

*public static void SetActiveWindow(IntPtr hWnd)*{const int SWP_NOSIZE = 0x0001;const int SWP_NOMOVE = 0x0002;const int SWP_SHOWWINDOW = 0x0040;const int HWND_TOPMOST = -1;const int HWND_NOTOPMOST = -2;SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);SetWindowPos(hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);}
ウィンドウをアクティブにする

*private static List<Window> GetAllChildWindows(Window parent, List<Window> dest, bool isAll)*{// タブコントロールなどで選択タブ以外は取得しないif (!isAll && !IsWindowVisible(parent.hWnd)) return dest;dest.Add(parent);EnumChildWindows(parent.hWnd).ToList().ForEach(x => GetAllChildWindows(x, dest, isAll));return dest;}
指定したウィンドウの全ての子孫ウィンドウを取得し、リストに追加する

*if (!isAll && !IsWindowVisible(parent.hWnd)) return dest;*dest.Add(parent);
タブコントロールなどで選択タブ以外は取得しない

*private static IEnumerable<Window> EnumChildWindows(IntPtr hParentWindow)*{IntPtr hWnd = IntPtr.Zero;while ((hWnd = FindWindowEx(hParentWindow, hWnd, null, null)) != IntPtr.Zero) { yield return GetWindow(hWnd); }}
与えた親ウィンドウの直下にある子ウィンドウを列挙する(孫ウィンドウは見つけてくれない)

*private static Window GetWindow(IntPtr hWnd)*{int textLen = GetWindowTextLength(hWnd);string windowText = null;if (0 < textLen){// ウィンドウのタイトルを取得するStringBuilder windowTextBuffer = new StringBuilder(textLen + 1);GetWindowText(hWnd, windowTextBuffer, windowTextBuffer.Capacity);windowText = windowTextBuffer.ToString();}// ウィンドウのクラス名を取得するStringBuilder classNameBuffer = new StringBuilder(256);GetClassName(hWnd, classNameBuffer, classNameBuffer.Capacity);return new Window() { hWnd = hWnd, Title = windowText, ClassName = classNameBuffer.ToString() };}
ウィンドウハンドルを渡すと、ウィンドウテキスト(ラベルなど)、クラス、スタイルを取得してWindowsクラスに格納して返す

*StringBuilder windowTextBuffer = new StringBuilder(textLen + 1);
ウィンドウのタイトルを取得する

*StringBuilder classNameBuffer = new StringBuilder(256);
ウィンドウのクラス名を取得する

*private static bool EnumWindowCallBack(IntPtr hWnd, IntPtr lparam)*{// ウィンドウが可視かどうか調べるif (!IsWindowVisible(hWnd)) return true;// ウィンドウハンドルからプロセスIDを取得int processId;GetWindowThreadProcessId(hWnd, out processId);// プロセスIDからProcessクラスのインスタンスを取得if (_targetProcessName == "" ||Process.GetProcessById(processId).ProcessName.ToUpper() == _targetProcessName.ToUpper()){// ウィンドウのタイトルの長さを取得するint textLen = GetWindowTextLength(hWnd);if (0 < textLen){_hWndList.Add(hWnd);}}return true;}
コールバック関数

*if (!IsWindowVisible(hWnd)) return true;*// ウィンドウハンドルからプロセスIDを取得
ウィンドウが可視かどうか調べる

*int processId;
ウィンドウハンドルからプロセスIDを取得

*if (_targetProcessName == "" ||*Process.GetProcessById(processId).ProcessName.ToUpper() == _targetProcessName.ToUpper())
プロセスIDからProcessクラスのインスタンスを取得

*int textLen = GetWindowTextLength(hWnd);
ウィンドウのタイトルの長さを取得する

*public class Window*{public string ClassName;public string Title;public IntPtr hWnd;}
Windowsクラス

*public static List<List<Window>> WindowsList { get; set; }
Windowsクラスの格納リスト

*WindowsHandles.Initialize("notepad");
プロセス名がnotepad(メモ帳)の画面情報を取得します。

*bool exists = WindowsHandles.ExistsTitle("キャンセル");
画面情報に「キャンセル」ボタンがあるかチェックします。

*MessageBox.Show(exists.ToString());
結果を表示

*,,,
WindowsHandles.WindowsListプロパティはPublicなのでご自由に。
List<List<WindowsHandles.Window>> list = WindowsHandles.WindowsList;


*CodeList.add("\r\n\t
Operations");

*CodeList.add("\t{" + getOperationDefinition(opes[i]) + "\r\n\t}");
class


*if(other.gameObject.tag == "Player")
プレイヤーが武器を取ったら消す


*if (Input.GetMouseButtonDown(0)) controller.OnClick();
左クリックで呼び出す


*private const int CHECKBOX_INFLATE_SIZE = 8;
チェックボックス拡大サイズ

*bool cellSelected = (elementState & DataGridViewElementStates.Selected) != 0;
塗りつぶしと枠線描画

*Rectangle checkboxRect = this.GetCheckboxBounds(graphics, cellStyle, rowIndex);
チェックボックス描画


*<p>Learn about <a href="https:
docs.microsoft.comaspnetcore">building Web apps with ASP.NET Core<a>.<p>


*string example = " 　";
空白


*private const string TestPageUrl = @"http:
localhost:3000login.aspx";

*var model = new CopyTestsModels { Name = "Test Name" };
Reference type


*Trace.WriteLine("OK");
TraceクラスのWriteLineメソッドを利用


*var tuples1 = strs.SelectMany((str) => nums.Select((num) => new Tuple<string, int>(str, num)));
"べた"に書く場合:

*var tuples2 = product(strs, nums, (str, num) => new Tuple<string, int>(str, num));
メソッド定義した場合:

*var xs = new List<int>() { 1, 2, 3 };
引数が3つの場合:

*}
===> "べた"に書く場合 <===
(a, 1)
(a, 2)
(a, 3)
(b, 1)
(b, 2)
(b, 3)
(c, 1)
(c, 2)
(c, 3)
===> メソッド定義した場合 <===
(a, 1)
(a, 2)
(a, 3)
(b, 1)
(b, 2)
(b, 3)
(c, 1)
(c, 2)
(c, 3)
===> 引数が3つの場合 <===
(1, 1, 1)
(1, 1, 2)
(1, 1, 3)
(1, 2, 1)
(1, 2, 2)
(1, 2, 3)
(1, 3, 1)
(1, 3, 2)
(1, 3, 3)
(2, 1, 1)
(2, 1, 2)
(2, 1, 3)
(2, 2, 1)
(2, 2, 2)
(2, 2, 3)
(2, 3, 1)
(2, 3, 2)
(2, 3, 3)
(3, 1, 1)
(3, 1, 2)
(3, 1, 3)
(3, 2, 1)
(3, 2, 2)
(3, 2, 3)
(3, 3, 1)
(3, 3, 2)
(3, 3, 3)


*string[] sp = lines[0].Split(',');
ヘッダ

*string[] sp2 = lines[0].Split(',');
指定カラム名値判定

*int scoreClm = 0;
指定カラム名列判定


*ReversePolishNotation rpn = ConvertToRpn(exp);
数式を逆ポーランド記法へ変換

*return RpnCalculator.Calculate(rpn);
逆ポーランド記法の式を計算する

*public class Tokenizer {private string _expression;IEnumerator<string> _ite;public Tokenizer(string exp) {_expression = exp;_ite = GetTokens().GetEnumerator();}public bool MoveNext() {return _ite.MoveNext();}public string Current {get { return _ite.Current; }}private IEnumerable<string> GetTokens() {char c = NextChar();var token = "";while (c != (char)0) {if (char.IsDigit(c)) {token += c;} else if (c == '.' && token.All(x => x != '.')) {token += c;} else {if (token != "")yield return token;token = "";if (IsSymbol(c))yield return c.ToString();else if (c != ' ')throw new ArithmeticException("正しい式ではありません");}c = NextChar();}if (token != "")yield return token;}private static bool IsSymbol(char c) {return "+-*/()".Any(x => x == c);}private int _currentIndex = 0;private char NextChar() {if (_currentIndex < _expression.Length)return _expression[_currentIndex++];return (char)0;}}
Tokenに分解する


*string[] lines = File.ReadAllLines(@"D:\vcCsvPrc\test.csv",Encoding.GetEncoding("Shift_JIS"));
行数を取得(ヘッダー分含まず)

*using (var sr = new System.IO.StreamReader(@"D:\vcCsvPrc\test.csv",
分割数の決定
long syou = cntRow / 9;    商(切捨) 9は可変にする
long amari = cntRow % 9;   余り     9は可変にする
ファイル読込

*string headRow = sr.ReadLine();
ヘッダー読込

*sw.WriteLine(headRow);
ヘッダー挿入

*sw.WriteLine(sr.ReadLine());
商分書き込む

*amari = amari - 1;
余り - 1

*sw.WriteLine(sr.ReadLine());
商分書き込む


*intIterator = (IEnumerable<int>) d;
4


*}
end while

*Map.DrawMap();
まず描画します

*List<MapObject> mapObjects = new List<MapObject>();
配列の内容をListに入ます。

*var goalcount = mapObjects.Count(s => s.objType == MapObject.OBJ_TYPE.GOAL);*if(goalcount <= 0){Console.WriteLine("ゲームクリア！¥nゲームを終了します");//コンソールの終了Environment.Exit(0);}
ゴールの数が0以下ならばゲームクリアです。

*Environment.Exit(0);
コンソールの終了

*mapobject = getObject(c);
c の内容によって生成するオブジェクトのTYPEを決定する

*public static void DrawMap()*{for (int i = 0; i < map.Length; i++){switch (map[i].objType){case MapObject.OBJ_TYPE.PLAYER: Console.Write('P'); break;case MapObject.OBJ_TYPE.NIMOTU: Console.Write('N'); break;case MapObject.OBJ_TYPE.WALL: Console.Write('■'); break;case MapObject.OBJ_TYPE.GOAL: Console.Write('G'); break;case MapObject.OBJ_TYPE.FLOOR: Console.Write('□'); break;case MapObject.OBJ_TYPE.GOAL_ON_NIMOTU: Console.Write('D'); break;}//幅の数だけ表示したら改行させますif ((i + 1) % mapWidth == 0){Console.Write(Environment.NewLine);}}}
オブジェクトのOBJ_TYPEを見てコンソールに出力する


*public MainWindow win = null;
GUI にイベントを表示するための独自実装（無くてもよい）

*Application.Current.Dispatcher.BeginInvoke(DispatcherPriority.Background,new Action(() => {
GUI にイベントを表示するための独自実装（無くてもよい） ===>>>

*}
GUI にイベントを表示するための独自実装（無くてもよい） ===<<<<

*Application.Current.Dispatcher.BeginInvoke(DispatcherPriority.Background,new Action(() => {
GUI にイベントを表示するための独自実装（無くてもよい） ===>>>

*}
GUI にイベントを表示するための独自実装（無くてもよい） ===<<<<

*m_connectionPoint.Unadvise(m_sinkCookie);
イベントシンクとの切断

*Marshal.ReleaseComObject(m_connectionPoint);
COMオブジェクトの開放


*Player_pos = transform.position;
プレイヤーの位置を更新


*0xC3
ret


*public class Calculator
アクセス修飾子をinternalからpublicへ変更する


*var testValue = config["AppSettings:TestConstValue"];
設定値の取得

*testValue = config.GetSection("AppSettings")["TestConstValue"];
以下の書き方でも取得できます。

*var connectionString = config.GetConnectionString("Default");
ConnectionString は専用のメソッドが用意されています。

*connectionString = config["ConnectionStrings:Default"];
下記の書き方でも取得できますが、専用のメソッドを利用するほうが簡単です。

*configBuilder.SetBasePath(Directory.GetCurrentDirectory());
設定ファイルのベースパスをカレントディレクトリ( 実行ファイルと同じディレクトリ )にします。

*configBuilder.AddJsonFile(@"AppConfig.json");
Json ファイルへのパスを設定します。SetBasePath() で設定したパスからの相対パスになります。


*var type = list.GetType().GetGenericArguments().First();
入れの子のGenericには対応していない

*Clipboard.SetText(list.ToTsv());
クリップボードに出力


*e.Paint(e.ClipBounds, DataGridViewPaintParts.All);
セルを描画する

*Rectangle indexRect = e.CellBounds;
行番号を描画する範囲を決定する
e.AdvancedBorderStyleやe.CellStyle.Paddingは無視しています

*TextRenderer.DrawText(e.Graphics,(e.RowIndex + 1).ToString(),
行番号を描画する

*e.Handled = true;
描画が完了したことを知らせる


*class Complex*{private double mReal;private double mImaginary;public Complex() { mReal = 1.0; mImaginary = 0.1; }public double Real{get { return mReal; }set { mReal = value; }}public double Imaginary{get { return mImaginary; }set { mImaginary = value; }}}
テスト用のクラス

*static void constuct()*{for (int j=0; j < kCount0o/sFactor; ++j){for (int i=0; i < kCount0i; ++i){var temp = new Complex();sVolatileInt = (int)temp.Real;}}}
コンストラクト

*static int maxInt(int iLhs, int iRhs)*{return (iLhs > iRhs)?iLhs:iRhs;}
テスト用の通常メソッド

*static Type max<Type>(Type iLhs, Type iRhs) where Type : IComparable*{return (iLhs.CompareTo(iRhs) > 0)?iLhs:iRhs;}
テスト用のジェネリック・メソッド

*static void normalInt()*{for (int j=0; j < kCount0o/sFactor; ++j){for (int i=0; i < kCount0i; ++i){sVolatileInt = maxInt(i, j);}}}
通常関数

*static void genericsInt()*{for (int j=0; j < kCount0o/sFactor; ++j){for (int i=0; i < kCount0i; ++i){sVolatileInt = max<int>(i, j);}}}
int型

*static void genericsDouble()*{for (int j=0; j < kCount0o/sFactor; ++j){for (int i=0; i < kCount0i; ++i){sVolatileInt = (int)max<double>(i, j);}}}
double型

*static void genericsString()*{for (int j=0; j < kCount0o/sFactor; ++j){for (int i=0; i < kCount0i; ++i){sVolatileInt =int.Parse(max<String>(i.ToString(), j.ToString()));}}}
string型


*this.options = options;
設定記述子

*}
データベース接続処理等を記述する。

*public string nameSei { get; set; }
【ポイント】HTMLのFormタグのID名とEntityのプロパティ名を揃えること。


*ToastNotificationManager.CreateToastNotifier(appId).Show(notification);*,,,
トースト通知を飛ばす


*// 実際の値: [b,a][b,a]*// ===> new List<string>() { "a", "a" }が複製されていないことが確認できます。
想定していた値: [b,a][a,a]

*// ===> new List<string>() { "a", "a" }が複製されていないことが確認できます。
実際の値: [b,a][b,a]

*}
===> new List<string>() { "a", "a" }が複製されていないことが確認できます。

*}
想定していた値 => [b,a][a,a]
実際の値       => [b,a][a,a]


*private List<Piyo> m_piyos = new List<Piyo>();
コンポジション

*private static List<Piyo> m_piyosCheckList = new List<Piyo>();
部分が他の全体に属しているかをチェックするリスト

*return false;
すでに他の全体に属しています

*m_piyos.Add(piyo);
部分として保持

*m_piyosCheckList.Add(piyo);
この要素が全体に属したことを記憶する

*bool ans = m_piyos.Remove(piyo);
部分としてのリストから削除

*m_piyosCheckList.Remove(piyo);
この要素が全体に属したことを記憶から消す


*var DataList = new List<Data>();
Dataクラスはid, name, pointプロパティを持つとする。

*var record　= DataList.Find(data => data.id =="1");
②と同様の結果が得られる(LINQではなくListのメソッド)


*var result = list.Select((string s) => { return s + ".txt"; });
← 直接リテラルを書く


*public void Post([FromForm] TorokuFormEntity formData)
成功：[FromForm] TorokuFormEntity formData

*}
DB登録等の処理を記述する。


*response.Play(url: "https:
api.twilio.comcowbell.mp3", loop: 1);

*var response = new VoiceResponse();
録音終了
var url = request.RecordingUrl;  録音データURL

*}
録音データ保存完了


*m_piyos[u].Execute();
要素有無のチェックは省略


*private async Task<string> HeavyProcessingAsync()*{string hoge = "hoge";//重たい処理return "hoge";}
async句をつけたメソッドはAsyncのsuffixを付けることが推奨されています。

*return "hoge";
重たい処理

*string hoge = await HeavyProcessingAsync();
処理A

*}
処理B

*}
あるいはTask.Result();

*token.ThrowIfCancellationRequested();
重たい処理

*// {//     throw new OperationCanceledException(token)// }
if (token.IsCancellationRequested)

*return hoge;
重たい処理


*aes.Padding = PaddingMode.PKCS7;
デフォルト

*using (CryptoStream cs = new CryptoStream(fs, decryptor, CryptoStreamMode.Read)){byte[] buffer = new byte[1024];
暗号化されたデータを読み込むための復号ストリーム


*using System;
Actionに必要

*// -------------------------------------------*public class InputManager : MonoBehaviour {public event Action Idle;public event Action Attack01;public event Action Attack02;void Update () {if (Input.GetKeyDown (KeyCode.Space) && Idle != null) {Idle ();}if (Input.GetKeyDown (KeyCode.F1) && Attack01 != null) {Attack01 ();}if (Input.GetKeyDown (KeyCode.F2) && Attack02 != null) {Attack02 ();}}}
委譲先 アクションメソッドを実行する

*public class InputManager : MonoBehaviour {public event Action Idle;public event Action Attack01;public event Action Attack02;void Update () {if (Input.GetKeyDown (KeyCode.Space) && Idle != null) {Idle ();}if (Input.GetKeyDown (KeyCode.F1) && Attack01 != null) {Attack01 ();}if (Input.GetKeyDown (KeyCode.F2) && Attack02 != null) {Attack02 ();}}}
-------------------------------------------

*// -------------------------------------------*public class ActionTest1 : MonoBehaviour {private InputManager inputManager;void Awake() {// scriptの参照GameObject inputManagerObj = GameObject.Find("InputManager");if (inputManagerObj != null) {inputManager = inputManagerObj.GetComponent<InputManager> ();}if (inputManager == null) {Debug.Log ("Cannot find 'InputManager' script");}}void OnEnable() {// アクションメソッドの登録inputManager.Idle += Idle;inputManager.Attack01 += Run;inputManager.Attack01 += Punch;inputManager.Attack02 += Jump;inputManager.Attack02 += Kick;}void OnDisable() {// アクションメソッドの削除inputManager.Idle -= Idle;inputManager.Attack01 -= Run;inputManager.Attack01 -= Punch;inputManager.Attack02 -= Jump;inputManager.Attack02 -= Kick;}void Idle() {Debug.Log ("[ActionTest1] Idle...");}void Run() {Debug.Log ("[ActionTest1] Run...");}void Jump() {Debug.Log ("[ActionTest1] Jump...");}void Kick() {Debug.Log ("[ActionTest1] Kick...");}void Punch() {Debug.Log ("[ActionTest1] Punch...");}}
委譲元 アクションメソッドの登録・削除（実行はしない）

*public class ActionTest1 : MonoBehaviour {private InputManager inputManager;void Awake() {// scriptの参照GameObject inputManagerObj = GameObject.Find("InputManager");if (inputManagerObj != null) {inputManager = inputManagerObj.GetComponent<InputManager> ();}if (inputManager == null) {Debug.Log ("Cannot find 'InputManager' script");}}void OnEnable() {// アクションメソッドの登録inputManager.Idle += Idle;inputManager.Attack01 += Run;inputManager.Attack01 += Punch;inputManager.Attack02 += Jump;inputManager.Attack02 += Kick;}void OnDisable() {// アクションメソッドの削除inputManager.Idle -= Idle;inputManager.Attack01 -= Run;inputManager.Attack01 -= Punch;inputManager.Attack02 -= Jump;inputManager.Attack02 -= Kick;}void Idle() {Debug.Log ("[ActionTest1] Idle...");}void Run() {Debug.Log ("[ActionTest1] Run...");}void Jump() {Debug.Log ("[ActionTest1] Jump...");}void Kick() {Debug.Log ("[ActionTest1] Kick...");}void Punch() {Debug.Log ("[ActionTest1] Punch...");}}
-------------------------------------------

*GameObject inputManagerObj = GameObject.Find("InputManager");*if (inputManagerObj != null) {inputManager = inputManagerObj.GetComponent<InputManager> ();}
scriptの参照

*inputManager.Idle += Idle;
アクションメソッドの登録

*inputManager.Idle -= Idle;
アクションメソッドの削除

*// -------------------------------------------*public class ActionTest2 : MonoBehaviour {private InputManager inputManager;void Awake() {// scriptの参照GameObject inputManagerObj = GameObject.Find("InputManager");if (inputManagerObj != null) {inputManager = inputManagerObj.GetComponent<InputManager> ();}if (inputManager == null) {Debug.Log ("Cannot find 'InputManager' script");}}void OnEnable() {// アクションメソッドの登録inputManager.Idle += Talk;inputManager.Attack01 += PunchSound;inputManager.Attack02 += KickSound;}void OnDisable() {// アクションメソッドの削除inputManager.Idle -= Talk;inputManager.Attack01 -= PunchSound;inputManager.Attack02 -= KickSound;}void Talk() {Debug.Log ("[ActionTest2] Talk...");}void KickSound() {Debug.Log ("[ActionTest2] KickSound...");}void PunchSound() {Debug.Log ("[ActionTest2] PunchSound...");}}
委譲元 アクションメソッドの登録・削除（実行はしない）

*public class ActionTest2 : MonoBehaviour {private InputManager inputManager;void Awake() {// scriptの参照GameObject inputManagerObj = GameObject.Find("InputManager");if (inputManagerObj != null) {inputManager = inputManagerObj.GetComponent<InputManager> ();}if (inputManager == null) {Debug.Log ("Cannot find 'InputManager' script");}}void OnEnable() {// アクションメソッドの登録inputManager.Idle += Talk;inputManager.Attack01 += PunchSound;inputManager.Attack02 += KickSound;}void OnDisable() {// アクションメソッドの削除inputManager.Idle -= Talk;inputManager.Attack01 -= PunchSound;inputManager.Attack02 -= KickSound;}void Talk() {Debug.Log ("[ActionTest2] Talk...");}void KickSound() {Debug.Log ("[ActionTest2] KickSound...");}void PunchSound() {Debug.Log ("[ActionTest2] PunchSound...");}}
-------------------------------------------

*GameObject inputManagerObj = GameObject.Find("InputManager");*if (inputManagerObj != null) {inputManager = inputManagerObj.GetComponent<InputManager> ();}
scriptの参照

*inputManager.Idle += Talk;
アクションメソッドの登録

*inputManager.Idle -= Talk;
アクションメソッドの削除


*public static decimal Calculate(ReversePolishNotation rpn) {Stack<object> stack = new Stack<object>();foreach (var token in rpn.Tokens) {if (IsOperator(token)) {var b = (decimal)stack.Pop();var a = (decimal)stack.Pop();var c = Operate(a, b, token);stack.Push(c);} else {stack.Push(decimal.Parse(token));}}return (decimal)stack.Pop();}
後置記法を計算する


*public int Index { get; private set; }
左側もしくは右側の頂点配列のインデックス

*public Vector3 Position { get; private set; }
位置

*public bool IsLeft { get; private set; }
左側か右側のフラグ

*if (triangles.Count() < 2)*return null;
三角形の数が2つ未満の場合は計算できないので空のパスを返す

*if (!CreateVertices3D(triangles))*return null;
与えられた三角形リストから３次元における左右の頂点配列を作成する

*CopyVertices3DToVertices2D();
3次元における頂点配列を２次元における頂点配列にコピーする

*ConvertTo2D();
コピーした頂点配列を2次元に変換する

*ConvertToXYPlane();
XY平面上に変換する

*apex = new Apex(0, leftVertices2d[0], true);
Funnelの先端を始点にセットする (右側も左側も同じなのでどっちを採用してももいい。ここでは左側を採用)

*leftIndices.Add(1);
Funnelの左側の頂点リストに最初の頂点を追加する(先端から1つ進んだとこから開始する)

*rightIndices.Add(1);
Funnelの右側の頂点リストに最初の頂点を追加する(先端から1つ進んだとこから開始する)

*apexes.Add(apex);
終点にたどり着いたら現在のFunnelの先端を追加する

*apexes.Add(new Apex(leftVertices2d.Length - 1, leftVertices2d.Last(), true));
終点を追加する(ここも左、右側のどちらを採用してもOK)

*var path = MakePath();
共有辺との交点()を求め、最終的なパスを計算する

*var commonEdges = new List<Edge>();
三角形リストから共有辺のリストを作成する

*var commonEdge = pair.Left.FindCommonEdge(pair.Right);
前後の三角形から共有辺を探す

*return false;
共有辺が見つからない場合は連結してないので失敗

*leftVertices3d = new Vector3[commonEdges.Count + 2];
３次元における頂点配列を初期化する。 長さは 始点 + 終点 + 共有辺の数 になる

*var startPoint = triangles.First().FindOppositeVertex(commonEdges.First()).Value;
始点を求める。始点は最初の三角形の頂点の内、最初の共有辺に向かいあう頂点

*leftVertices3d[0] = rightVertices3d[0] = startPoint;
始点を両サイドの頂点配列に追加

*var i = 1;
共有辺の頂点を左、右に分けていく

*var endPoint = triangles.Last().FindOppositeVertex(commonEdges.Last()).Value;
終点を求める。終点は最後の三角形の頂点の内、最後の共有辺に向かいある頂点

*leftVertices3d[leftVertices3d.Length - 1] = rightVertices3d[leftVertices3d.Length - 1] = endPoint;
終点を両サイドの頂点配列に追加

*leftVertices2d = leftVertices3d.Select(v => new Vector3(v.x, v.y, v.z)).ToArray();
3次元における頂点配列をそのままコピーする
コピーしたものをあとで2次元に変換する

*var isLeftEqual = leftVertices2d[i].Equals(leftVertices2d[i - 1]);
回転対象の頂点をもとめる

*var originNormal = Vector3.Cross(leftVertices2d[i - 1] - rightVertices2d[i - 1], origin - leftVertices2d[i - 1]).normalized;
origin - edge 平面の法線

*var targetNormal = Vector3.Cross(rightVertices2d[i - 1] - leftVertices2d[i - 1], target - rightVertices2d[i - 1]).normalized;
target - edge 平面の法線

*var angle = MathUtility.SignedVectorAngle(originNormal, targetNormal, leftVertices2d[i - 1] - rightVertices2d[i - 1]);
2つの法線間の角度を求める

*var rotation = Quaternion.AngleAxis(angle, rightVertices2d[i - 1] - leftVertices2d[i - 1]);
edge を軸としてangleだけ回転するQuaternionを求める

*var translation = leftVertices2d[i - 1] - (rotation * leftVertices2d[i - 1]);
回転軸に回転を適用して平行移動量を求める

*leftVertices2d[j] = rotation * leftVertices2d[j];
求めた変換パラメータを現在の頂点以降の頂点全てに適用する
適用する順番は回転->平行移動の順にすること

*var nextOrigin = isLeftEqual ? rightVertices2d[i - 1] : leftVertices2d[i - 1];
次の回転の起点を求める

*var origin = leftVertices2d[0];
始点を原点に移動するパラメータを求める

*var startIndex = pair.Left.Index;
現在の先端の頂点インデックスを開始インデックスとする

*var endIndex = pair.Right.Index;
次の先端の頂点インデックスを終了インデックスとする

*var startPoint = (pair.Left.IsLeft ? leftVertices3d : rightVertices3d)[pair.Left.Index];
現在の先端のポジション(3次元)をパスに追加

*normals.Add(Vector3.Cross(rightVertices3d[1] - leftVertices3d[1], rightVertices3d[1] - leftVertices3d[0]).normalized);
始点の場合

*var lerp = Vector3.Distance(intersection, leftVertices2d[i]) / Vector3.Distance(rightVertices2d[i], leftVertices2d[i]);
後から3次元に変換できるように共有辺の左側の頂点から交点までの長さを割合として計算する

*var left3dpos = leftVertices3d[i];
各サイドの3次元における頂点を取得

*var position = Vector3.MoveTowards(left3dpos, right3dpos, Vector3.Distance(left3dpos, right3dpos) * lerp);
先ほど求めた割合から3次元における交点を算出する

*var currentOpposite = rightVertices3d[i].Equals(rightVertices3d[i - 1]) ? leftVertices3d[i - 1] : rightVertices3d[i - 1];
現在の面の法線を求める

*var nextOpposite = rightVertices3d[i + 1].Equals(rightVertices3d[i]) ? leftVertices3d[i] : rightVertices3d[i];
次の面の法線を求める

*positions.Add(position);
パスに追加

*var endPoint = leftVertices3d[leftVertices3d.Length - 1];
3次元における終点をパスに追加

*var endNormal = Vector3.Cross(leftVertices3d[leftVertices3d.Length - 2] - rightVertices3d[rightVertices3d.Length - 2], leftVertices3d[leftVertices3d.Length - 2] - leftVertices3d.Last()).normalized;
終点の法線を求める

*var positionGroups = positions.SplitByEquality();
同じポジションでグループ化する

*var resultNormals = new List<Vector3>();
法線を合成する

*var resultNormal = MathUtility.Synthesize(normals.Skip(skipCount).Take(g.Count()));
ポジションリストに対応する法線リストを取得して合成する

*if (leftVertices2d.Length - 1 <= leftIndices.Last())*return false;
Funnelの左側の頂点リストが終点にたどり着いたら終了 (右側も終点になるはずなので左側のチェックでよい)

*Push(rightVertices2d, leftVertices2d, ref rightIndices, ref leftIndices, false);
左側に追加できた場合は右側に追加する

*var crossedIndex = IsCrossedOppositeVertices(targets, opposites, targetIndices, oppositeIndices);
進めた際にFunnnelの反対側の頂点リストを追い越さないかを調べる

*apexes.Add(apex);
追い越した場合は現在のFunnelの先端を記録する

*apex = new Apex(crossedIndex, opposites[crossedIndex], !isLeft);
Funnelの先端を追い越されたほうの頂点にセットする

*var nextIndex = apex.Index + 1;
Funnelの両サイドのインデックスをセットする

*if (!apex.Position.Equals(opposites[nextIndex]))*break;
Funnelの先端と同じ座標にいる場合は座標が変わるまでインデックスを進める

*return false;
進めることができなかったのでFalseを返す

*var next = targetIndices.Last() + 1;
進めることができる

*targetIndices.Clear();
Funnelが絞られるので一度頂点リストをクリアする

*targetIndices.Add(next);
新しい頂点として追加

*return true;
進めることができたのでTrueを返す

*var lastVec = (targets[targetIndices.Last() + 1] - apex.Position).normalized;
先端から、進める側の最後の頂点に向かうベクトル

*var firstVec = (targets[targetIndices.First()] - apex.Position).normalized;
先端から、進める側の最初の頂点に向かうベクトル

*var oppositeVec = (opposites[oppositeIndices.First()] - apex.Position).normalized;
先端から、反対側の最初の頂点に向かうベクトル

*var lastVec = targets[targetIndices.Last()] - apex.Position;
先端から、進める側の最後の頂点に向かうベクトル

*var nextVec = targets[targetIndices.Last() + 1] - apex.Position;
先端から、進める側の追加する頂点に向かうベクトル

*var oppositeVec = opposites[i] - apex.Position;
先端から、反対側のi番目の頂点に向かうベクトル

*if (target == Vector3.zero || current == Vector3.zero || next == Vector3.zero)*return false;
不正なベクトルの場合はダメ

*var currentCross = Vector3.Cross(target, current).normalized;
更新前のベクトルと基準となるベクトルの外積をとる

*var nextCross = Vector3.Cross(target, next).normalized;
更新後のベクトルと基準となるベクトルの外積をとる

*return dot <= 0;
外積が反対方向なら追い越したことになる


*this.btn3.Click += (sender, e) => MessageBox.Show("Button3だよ");
直接メソッドを書く方法。


*this.Invoke((MethodInvoker)(() => TextBox.Text = "hoge"));
別スレッドによるUI操作

*TextBox.Text = "hoge";
UIスレッドからのUI操作


*var res = await httpClient.GetAsync("http:
gochiusa.com");


*|| (length >= 2 && path[1] == VolumeSeparatorChar) )
':'

*if ( path[0] == DirectorySeparatorChar*|| path[0] == AltDirectorySeparatorChar ) return true;
先頭の文字が '\' 若しくは '/' の場合、絶対パスと判定。

*if ( length >= 2 && path[1] == VolumeSeparatorChar ) return true;*}
二文字目が ':' の場合、絶対パスと判定。

*return false;
上記２パターン以外は全て相対パスと判定。

*char c1 = path.at(0);
先頭の文字が '\' 若しくは '/' の場合、絶対パスと判定。

*char c2 = path.at(1);
二文字目が ':' の場合、絶対パスと判定。

*return false;
上記２パターン以外は全て相対パスと判定。


*using UnityEditor;
エディタ拡張関連はUnityEditor名前空間に定義されているのでusingしておく。

*public class EditorExWindow : EditorWindow*{// メニューのWindowにEditorExという項目を追加。[MenuItem("Window/EditorEx")]static void Open(){// メニューのWindow/EditorExを選択するとOpen()が呼ばれる。// 表示させたいウィンドウは基本的にGetWindow()で表示＆取得する。EditorWindow.GetWindow<EditorExWindow>( "EditorEx" ); // タイトル名を"EditorEx"に指定（後からでも変えられるけど）}// Windowのクライアント領域のGUI処理を記述void OnGUI(){// 試しにラベルを表示EditorGUILayout.LabelField( "ようこそ！　Unityエディタ拡張の沼へ！" );}}
エディタに独自のウィンドウを作成する

*[MenuItem("Window/EditorEx")]
メニューのWindowにEditorExという項目を追加。

*}
メニューのWindow/EditorExを選択するとOpen()が呼ばれる。
表示させたいウィンドウは基本的にGetWindow()で表示＆取得する。
EditorWindow.GetWindow<EditorExWindow>( "EditorEx" );  タイトル名を"EditorEx"に指定（後からでも変えられるけど）

*void OnGUI()*{// 試しにラベルを表示EditorGUILayout.LabelField( "ようこそ！　Unityエディタ拡張の沼へ！" );}
Windowのクライアント領域のGUI処理を記述

*EditorGUILayout.LabelField( "ようこそ！　Unityエディタ拡張の沼へ！" );
試しにラベルを表示


*if (range.EntireColumn.OutlineLevel < 8) {
最大8段階


*.Where(x => x.NewItem.SkipWhile(n => !n).Skip(1).Any(n => n))
コントロールの個数を考えるとCount()を素直に使ってよさそうですね


*IDatabase db = RedisRepository.SelectCache(0);
RedisのDBを選択

*var key = "hoge";
キーを生成

*var unixSeconds = DateTimeOffset.Now.ToUnixTimeSeconds();
スコア算出の為、Unixtimeを取得

*var score = (double)unixSeconds;
経過秒数をスコアとして保存

*db.SortedSetAdd(key, "りんご", score);
閲覧履歴の情報をソート済みセット型で登録

*db.KeyExpire(key, new TimeSpan(30, 0, 0, 0));
保持期間を設定する場合は下記（例：30日）

*var current = db.SortedSetRangeByScore(key);
最大件数を設定する場合は下記

*db.SortedSetRemoveRangeByRank(key,0,0);
最下位のデータを削除

*var list = db.SortedSetRangeByScore(key, order: Order.Descending);
最新の閲覧順（スコアが高い順）に取得


*int cellwidth = 4;
結合セル


*int m = 0;
重解 multiple root

*a = BitConverter.ToInt32(bs, 0);
Int32に変換する

*} while (a == 0);*rng.GetBytes(bs);
a = -1;

*b = BitConverter.ToInt32(bs, 0);
Int32に変換する

*c = BitConverter.ToInt32(bs, 0);
Int32に変換する

*d = BitConverter.ToInt32(bs, 0);
Int32に変換する


*} else {
2分割

*this.RangeToLocation(range.Row, range.Column, out x, out y, rangeLocationFlags);*} else {
セル位置取得

*this.RangeToLocation(range.Row, range.Column, out x, out y);
セル位置取得


*Application.Quit();
アプリ終了

*Application.runInBackground = false;
アプリ終了


*int a = Random.Range(0,10);
エラー 'Random' は、'UnityEngine.Random' と 'System.Random' 間のあいまいな参照です

*int RUNDOM_NUMBER_1 = UnityEngine.Random.Range(0,10);
UnityEngine名前空間のクラスであることを明示（0以上10未満の乱数が返る）

*System.Random r = new System.Random();
System名前空間のクラスであることを明示（0以上10未満の乱数が返る）

*System.Random r = new System.Random(1000);
シード値（1000）を使用して初期化
シード値が変わらなければ毎回同じ乱数を返す

*int RANDOM_NUMBER_1 = r.Next(10);
0以上10未満の乱数を整数で返す

*int RANDOM_NUMBER_2 = r.Next(-10,10);
-10以上10未満の乱数を整数で返す

*int RANDOM_NUMBER_3 = r.Next();
0以上Int32.MaxValue（32bit符号付き整数の最大有効値:2147483647）未満の乱数を整数で返す

*int RANDOM_NUMBER = UnityEngine.Random.Range(0,10);
0以上10未満の乱数を浮動小数点数で返す


*[Route("api
TorokuForm")] [Route("api[controller]")]

*this.options = options;
設定記述子

*}
処理を書く。


*var value    = buffer.ElementAt(3);
(2)


*Group[] group ={ new Group { No = 1, Name = "Cat", Members = new List<Member> {
初期化：GroupクラスはMemberクラスのリストを要素に持つ

*var q = group.SelectMany(r => r.Members, (g, m) => new { g, m })
IsIndoor == true の Group Name と Member Name を取得


*.AddErrorDescriber<Resources.IdentityErrorDescriberJP>()
←これ


*int m = 0;
重解 multiple root

*a = BitConverter.ToInt32(bs, 0);
Int32に変換する

*} while (a == 0);*rng.GetBytes(bs);
a = -1;

*b = BitConverter.ToInt32(bs, 0);
Int32に変換する

*c = BitConverter.ToInt32(bs, 0);
Int32に変換する


*hoge.Animate();
各Animate() には StartCoroutine を呼び出すロジックが書いてある


*return S_FALSE;
0と1ではOK返してるけど、2以降ではfalseを返す


*case Reset:
Sourceの配列がClearされたので, targetの配列もClearする

*customers.Add(new Customer());
customerWatchers は customers と同期する


*var ssid = wifiManager.ConnectionInfo.SSID;*var bssid = wifiManager.ConnectionInfo.BSSID;
SSIDとBSSIDの取得

*string GetSSID();
SSIDを取得


*dynamic mat = input;
Matのメソッドに触れるためdynamicに突っ込む

*return input;
特に操作せずに返却→デフォルトのDumpによる表示が行われる

*}
なんか処理とかするする

*Util.HorizontalRun("origin,half,gray,binary", origin, half, gray, binary).Dump();
横に並べて表示してくれるやつ。
文字列がキャプションになって、それ以降の引数のobjectに対してDumpメソッドを呼んでくれる。


*var t = typeof(Properties.Resources);*foreach (var p in t.GetProperties(BindingFlags.Public | BindingFlags.NonPublic |BindingFlags.Static)) {if (p.PropertyType == typeof(Bitmap)) {//いろいろする}}
リフレクションを使ってBitmap型のリソースを取得

*}
いろいろする

*}
いろいろする


*public event PropertyChangedEventHandler PropertyChanged;
INotifyPropertyChangedは必ずこのイベントをもっていなければならない

*public void SetProperty<T>(ref T target, T value, [CallerMemberName] string caller ="")
自作したプロパティのセッター
必ずプロパティ変更通知を飛ばす

*}
UIに値を書き込む
WPFならxaml(View)にプロパティを書き込むことになる

*player.HP = 200;
HPに値が入ったら, 自動的にgauge側で登録した処理が行われる


*}
end of method GCAllocTest::Update


*_Model = new MyModel();
モデルのインスタンスを生成


*_compositeDisposable1.Dispose();
Disposeしてみる

*_compositeDisposable2.Clear();
Clearしてみる

*void Start () {//テスト用IDisposable_test1 = Observable.Interval(TimeSpan.FromSeconds(1)).Subscribe(_ => Debug.Log("Dispose1")).AddTo(_compositeDisposable1);_test2 = Observable.Interval(TimeSpan.FromSeconds(1)).Subscribe(_ => Debug.Log("Dispose2")).AddTo(_compositeDisposable1);_test3 = Observable.Interval(TimeSpan.FromSeconds(1)).Subscribe(_ => Debug.Log("Clear1")).AddTo(_compositeDisposable2);_test4 = Observable.Interval(TimeSpan.FromSeconds(1)).Subscribe(_ => Debug.Log("Clear2")).AddTo(_compositeDisposable2);//実験用Observable.Interval(TimeSpan.FromSeconds(1.5f)).Subscribe(_ => {TestDispose();TestClear();});}
Use this for initialization

*_test1 = Observable.Interval(TimeSpan.FromSeconds(1)).Subscribe(_ => Debug.Log("Dispose1"))
テスト用IDisposable

*Observable.Interval(TimeSpan.FromSeconds(1.5f))*.Subscribe(_ => {TestDispose();TestClear();});
実験用


*var l1 = new List<int>(){1,2};
Your code here!


*var duration = GetMovieDuration(inputMoviePath);
see [Gist](https:gist.github.comkokeiro001a8a6194296ea7973a55c6fe3c2865cf2#file-imageextractor-cs-L176-L197)

*var seekSecEnum = Enumerable.Range(0, (int)(duration.TotalSeconds / interval.TotalSeconds)).Select(x => new { SeekSec = x * interval.TotalSeconds, No = x });
処理対象時間を列挙する


*SceneManager.LoadScene("next", LoadSceneMode.Additive);
nextシーンを追加

*GameObject bullet = Instantiate (BulletPrefab, transform.position, transform.rotation);*Rigidbody rb = bullet.GetComponent<Rigidbody>();
大砲（親要素）の位置と回転をもった弾丸を生成し、

*rb.AddForce(transform.up * 30, ForceMode.VelocityChange);*}
推力をvec3で設定し、力のタイプ（加速、衝撃、速度変化）を決める

*collision.gameObject.SendMessage("hit");
衝突したgameObjectのメソッドをコール

*Destroy(gameObject);
破壊


*users = (List<User>)JsonSerializer.SerializerList<User>().ReadObject(fs3);
ここで例外


*Random r = new Random(seed++);
毎回シード値を変更して、
1以上100000未満の整数（乱数のようなもの）を生成する

*Console.Write(num + " ");
生成した乱数のようなものを出力して、
区切り文字としてスペースも出力する

*string[] str = Console.ReadLine().Split(' ');
string型の配列に1つ1つ格納

*start = DateTime.Now;
計測開始

*Console.Write(int.Parse(str[i]) % 10 + " ");
配列strの中身をint型に変換してから
10で割った余りを出力する

*end = DateTime.Now;
計測終了

*Console.WriteLine((end - start).TotalSeconds);
処理にかかった時間を秒単位で出力

*string[] str = Console.ReadLine().Split(' ');
string型の配列に1つ1つ格納

*start = DateTime.Now;
計測開始

*Console.Write(str[i][str[i].Length - 1] + " ");
配列strのi番目の要素の、
配列strのi番目の要素の文字列の長さ - 1 番目の文字を出力する

*end = DateTime.Now;
計測終了

*Console.WriteLine((end - start).TotalSeconds);
処理にかかった時間を秒単位で出力


*using UnityEngine;
エラー修正前

AutoBlink.cs
オート目パチスクリプト
2014/06/23 N.Kobayashi


*using UnityEngine;
エラー修正後

AutoBlink.cs
オート目パチスクリプト
2014/06/23 N.Kobayashi



*private static IEnumerable<T> Merge<T>(IEnumerable<T> a1, IEnumerable<T> a2, Comparison<T> compare) {if (!a1.Any()) {return a2;} else if (!a2.Any()) {return a1;}var x1 = a1.First();var x2 = a2.First();if (compare(x1, x2) < 0) {return (new T[] { x1 }).Concat(Merge(a1.Skip(1), a2, compare));} else {return (new T[] { x2 }).Concat(Merge(a1, a2.Skip(1), compare));}}
再帰版　Mergeメソッド

*private static IEnumerable<T> Merge<T>(IEnumerable<T> a1, IEnumerable<T> a2, Comparison<T> compare) {var ite1 = a1.GetEnumerator();var ite2 = a2.GetEnumerator();var exists1 = ite1.MoveNext();var exists2 = ite2.MoveNext();while (exists1 == true && exists2 == true) {T x1 = ite1.Current;T x2 = ite2.Current;if (compare(x1, x2) < 0) {yield return x1;exists1 = ite1.MoveNext();} else {yield return x2;exists2 = ite2.MoveNext();}}while (exists1) {yield return ite1.Current;exists1 = ite1.MoveNext();}while (exists2) {yield return ite2.Current;exists2 = ite2.MoveNext();}}
非再帰版　Mergeメソッド

*class Program {static void Main(string[] args) {Random rnd = new Random();var nums = new int[10000];for (int count = 0; count < 10; count++) {for (int i = 0; i < nums.Length; i++) {nums[i] = rnd.Next(1, 10000);}var result = MargeSort.Sort(nums, (a, b) => a - b);// LINQのOrderByメソッドの結果と比較することで、MergeSortが正しく整列されているかを確認しているbool isEqual = Enumerable.SequenceEqual(result, nums.OrderBy(n => n));Console.WriteLine(isEqual);}Console.ReadLine();}}
MergeSortの検証用コード

*bool isEqual = Enumerable.SequenceEqual(result, nums.OrderBy(n => n));
LINQのOrderByメソッドの結果と比較することで、MergeSortが正しく整列されているかを確認している


*public GameObject Cube2Quad(GameObject _parent)
Cubeの頂点座標
Vector3[] cubeLocalSharedVert = new Vector3[24]; ローカル座標系での頂点座標(ダブりあり)
List<Vector3> cubeLocalVert = new List<Vector3>(); ローカル座標系での頂点座標(ダブりなし)
Vector3[] cubeWorldVert = new Vector3[8]; ワールド座標系での頂点座標
Quadオブジェクトを2つ生成して子オブジェクトとして登録する関数

*cubeLocalVert.Add(cubeLocalSharedVert[0]);
ダブってる頂点を削除する

*int[,] surfaces = new int[6, 4];
面のインデックスを取得

*Matrix4x4 matrix = meshFilter.transform.localToWorldMatrix;*for (int i = 0; i < cubeLocalVert.Count; ++i)
変換行列Get

*List<float> areas = new List<float>();
最も面積の大きい面を探す

*int[] indicesOfMaxAreaSurfaces = new int[2];
最も面積の大きい二つの面を探す

*float verticalX = 0f, verticalY = 0f, verticalZ = 0f;
どの軸で貼られた面なのかを調べる

*else*{newQuadPos[0] = new Vector3(-0.5f, -0.5f, 0.5f);newQuadPos[1] = new Vector3(-0.5f, 0.5f, -0.5f);newQuadPos[2] = new Vector3(-0.5f, -0.5f, -0.5f);newQuadPos[3] = new Vector3(-0.5f, 0.5f, 0.5f);}
x = -0.5 の面の場合

*else*{newQuadPos[0] = new Vector3(-0.5f, -0.5f, 0.5f);newQuadPos[1] = new Vector3(0.5f, -0.5f, -0.5f);newQuadPos[2] = new Vector3(0.5f, -0.5f, 0.5f);newQuadPos[3] = new Vector3(-0.5f, -0.5f, -0.5f);}
y = -0.5 の面の場合

*else*{newQuadPos[0] = new Vector3(-0.5f, -0.5f, -0.5f);newQuadPos[1] = new Vector3(0.5f, 0.5f, -0.5f);newQuadPos[2] = new Vector3(0.5f, -0.5f, -0.5f);newQuadPos[3] = new Vector3(-0.5f, 0.5f, -0.5f);}
z = -0.5 の面の場合

*GameObject quad = GameObject.CreatePrimitive(PrimitiveType.Quad);
ゲームオブジェクトを新規作成

*Mesh mesh = quad.GetComponent<MeshFilter>().mesh;
Cubeの面をQuadとして定義しなおす

*Transform quadTrans = quad.GetComponent<Transform>();*quadTrans.position = matrix.MultiplyPoint(quadTrans.position);
座標変換

*quad.GetComponent<Renderer>().material = gameObject.GetComponent<Renderer>().material;
マテリアルの引継ぎ


*int size = 1234;
WriteIf: 第一引数が true の場合、メッセージを出力

*int index = -1;
Assert: 第一引数が false の場合、プログラムを中断してメッセージを出力

*[Conditional("DEBUG")]
このメソッドは DEBUG 定数が定義されている時だけ実行される

*[ConditionalAttribute("DEBUG")]
Debug.WriteLine メソッドの定義

*[ConditionalAttribute("TRACE")]
Trace.WriteLine メソッドの定義


*}
なんか

*}
略

*public MoreEventWindow()*{this.ResizeBegin += (object sender, EventArgs e) => { this.isBeingMoved = true; };this.ResizeEnd += (object sender, EventArgs e) => { this.isBeingMoved = false; };this.Move += (object sender, EventArgs e) =>{if(true == this.willBeAdjusted && this.IsLocationGood()){this.willBeAdjusted = false;this.OnDelayedDpiChanged(new DelayedDpiChangedEventArgs(this.dpiOld, this.wParam_, this.lParam_));}};}
ばっさり省略


*boo = new sampleDelegate(fuga.hello);
これは出来ない


*using (var solver = Solver.CreateSolver("IntegerProgramming", "CBC_MIXED_INTEGER_PROGRAMMING")) {
解く問題を初期化(IDisposable対応)
・線形計画法/整数計画法なので"IntegerProgramming"
・ソルバーとしてCoin-or branch and cut(CBC)を使うので"CBC_MIXED_INTEGER_PROGRAMMING"
※ソルバーにGlop(”GLOP_LINEAR_PROGRAMMING”)を指定すると、整数制約が守られないので注意

*var objective = solver.Objective();
最適化の方向を設定する
最大化→SetMaximization、最小化→SetMinimization

*var e1 = solver.MakeConstraint(double.NegativeInfinity, 13.5);
制約式の数・範囲

*var x = solver.MakeIntVar(0.0, double.PositiveInfinity, "X");
変数の数・名前・範囲
実数→MakeNumVar、整数→MakeIntVar、0-1変数→MakeBoolVar
(0-1変数以外だと、下限および上限を指定できる)
なお、MakeVarだと引数で整数制約があるか否かをbool指定できる

*objective.SetCoefficient(x, 5);
目的関数の係数

*e1.SetCoefficient(x, 1.5);
制約式の係数

*int resultStatus = solver.Solve();
最適化

*// 結果の返り値はdoubleなので注意*if (resultStatus != Solver.OPTIMAL) {Console.WriteLine("ソルバーで解けませんでした。");return;}
結果表示


*Console.WriteLine(date1.AddMonths(1));
4302017 12:00:00 AM

*,,,
DateTime date2 = new DateTime(2017, 4, 31);   これはエラー
[System.ArgumentOutOfRangeException: Year, Month, and Day parameters describe an un-representable DateTime.]


*var solver = new SimplexSolver();
解く問題を初期化(IDisposableではない)

*int x, y, z = 0, e1, e2, e3;
使用する変数のID・制約式のID・目的関数のIDを宣言する

*solver.AddRow("目的関数値", out z);
最適化の方向を設定する
AddGoal(目的関数の数値が代入される変数のID, (不明), 最大化するならfalse・最小化するならtrue)

*solver.AddRow("条件1", out e1);
制約式の数・名前・範囲

*solver.AddVariable("X", out x);
変数の数・名前・範囲
SetIntegralityメソッドで整数条件を付与できることがポイント

*solver.SetCoefficient(z, x, 5);
目的関数の係数

*solver.SetCoefficient(e1, x, 1.5);
制約式の係数

*solver.Solve(new SimplexSolverParams());
最適化

*Console.WriteLine($"Z = {solver.GetValue(z).ToDouble()}");
結果表示
GetValueメソッドの返り値はRational型……要するに分数なので、
ToDouble()メソッドでdouble型にすると分かりやすい


*#endif
UNITY_IOS


*if ( textLength < 0 ) { return 0; }
overflow


*public int Age { get; set; }
オートプロパティ


*NewSettingParam.CopyTo(PreSettingParam);
最新設定パラメータを前回設定パラメータにコピーする


*sum = TimeSpan.Zero;
配列として0チェック(foreach版)

*sum = TimeSpan.Zero;
配列として0チェック(for版)

*sum = TimeSpan.Zero;
IEnumerableとして0チェック

*sum = TimeSpan.Zero;
Enumerable.Anyとして0チェック

*sum = TimeSpan.Zero;
Enumerable.Allとして0チェック

*sum = TimeSpan.Zero;
unchecked下で forで0チェックを行う

*sum = TimeSpan.Zero;
uncheckを使用した上でforで0方向による0チェックを行う

*sum = TimeSpan.Zero;
unsafeを用いて ポインタによる0チェックを行う

*sum = TimeSpan.Zero;
unsafeを用いて long間隔で0チェックを行う


*ResourceService.Current.ChangeCulture("zh-CN");
上記サンプルでは「中国語」を表す


*using(mp.Step("step_b"))*{// 処理B}
処理A

*}
処理B

*using(mp.Step("step_d"))*{// 処理D}
処理C

*}
処理D

*mp.Stop()
計測を終了したい時は、Stop()を実行する
実行しないと、処理時間が大幅に変わってしまうので注意

*void ProcessTiming(Timing t)*{// tに対して何らかの処理if(t.HasChildren){foreach(var child in t.Children){// 再帰的に処理するProcessTiming(child);}}}
計測終了

*ProcessTiming(child);
再帰的に処理する


*int[] a12345 = { 1, 2, 3, 4, 5 };
単純な循環リスト

*var rnd = new Random();*Func<int>[] r = { () => rnd.Next() };
ランダムな値を返す関数のリストにすればランダムな無限リストが得られる


*+ "YOUR_ACCESSKEY";
アクセスキー

*var ekiResult = await client.GetStringAsync(ekiRequest);
路線情報の取得

*var stationList = "";
停車駅情報を編集


*string str = "Hello\"World";
Hello"World


*web.Navigate($"https:
translate.google.co.jp#{sourceLang}{resultLang}");


*PieSeries.Slices = Slices;
SeriesにSlicesをセット

*PlotModel.Series.Add(PieSeries);
PlotModelにSeriesを追加

*var sortedList = _DonutModel.ItemList.Where(x => x.Value > 0)
リストのソート

*_InsidePie.UpdateSlices(sortedList.Select(x => new PieSlice(x.Label, x.Value)));
内側のグラフの更新

*_OutsidePie.UpdateSlices(_Categories.Select(x => new PieSlice(x.ToString(),
外側のグラフの更新


*string executeTime = (DateTime.Now.ToString("yyyy_MMdd_HHmmss_ffff"));
保存パス生成

*var bitmap = new System.Drawing.Bitmap((int)size.Width,
保存するBitmap(handWrite)


*if (list[i].Equals(default(T)) == true)
0の場合は空文字列をセット


*Info("Information");*// Show warning
Show information


*Link google = AbstractFactory.CreateLink("Google", "http:
www.google.com");

*Console.ReadLine();
実行が一瞬で終わって確認ため、キーの入力を待ちます


*public void writeToConsole(string msg)*{textbox.Text += msg + Environment.NewLine;}
呼び出すメソッドの定義(匿名メソッドを使う場合は不要)

*Invoke( new Action<string>(writeToConsole), "解析終了" );
戻り値がvoidで、引数がstring1個の場合

*public void funcp0()*{...}
呼び出すメソッドの定義

*Invoke( new Action(funcp0) );
マルチスレッドから呼び出す

*public void funcp2(string msg, int nLineNo)*{...}
呼び出すメソッドの定義

*Invoke( new Action<string, int>(funcp2), "解析終了", 100 );
マルチスレッドから呼び出す

*public double funcdp2(string d, int n)*{...return 100.0;}
呼び出すメソッドの定義

*Invoke( new Action<string, int, double>(funcdp2), "50.0", 75 );
マルチスレッドから呼び出す


*list.RemoveAt(2);
Listの2番目の要素を削除する


*using(GeometrySink geom = result.Open())
usingを追加


*using (StreamWriter sw = new StreamWriter(path + "test.txt")){for (int i = 1; i < 50000000; i++)
テスト用ファイルを作る

*Dictionary<int, StreamWriter> writer = new Dictionary<int, StreamWriter>();
書き込み用のStreamWriterを開く

*using (StreamReader sr = new StreamReader(path + "test.txt")){while (sr.Peek() >= 0)
ここで内容判断、書き込み先の分岐処理を行う


*namespace App8.Helpers
https:github.com/Microsoft/WindowsTemplateStudio/blob/master/templates/_composition/MVVMBasic/Project/Helpers/Observable.cs から引用
名前空間を修正

*namespace App8.Views*{/// <summary>/// それ自体で使用できる空白ページまたはフレーム内に移動できる空白ページ。/// </summary>public sealed partial class MainPage : Page{public ViewModels.MainPageViewModel ViewModel { get; private set; } = new ViewModels.MainPageViewModel();public MainPage(){this.InitializeComponent();ViewModel.Initialize(this);this.DataContext = ViewModel;}}}
空白ページの項目テンプレートについては、https:go.microsoft.com/fwlink/?LinkId=402352&clcid=0x411 を参照してください

*namespace App8.Helpers
https:github.com/Microsoft/WindowsTemplateStudio/blob/master/templates/Projects/Default/Helpers/ResourceExtensions.cs から引用
名前空間を修正


*Livet.DispatcherHelper.UIDispatcher = Dispatcher;
↓が必要!


*public static IEnumerable<string> AsLineEnumerable(this TextReader source)*{string s;while ((s = source.ReadLine()) != null){yield return s;}}
TextReaderから一行ずつを要素にして返すよ

*class Program*{static void Main(string[] args){Console.In.AsLineEnumerable().All(line => { Console.WriteLine($"[{line}]"); return true; });}}
実行サンプル(C#6.0以降)


*Array.Resize(ref 顧客, i + 1);
配列のリサイズ。既存値はそのまま。リサイズ直後の値はNull(のようだ)。


*private ReactiveProperty<string> _sensorMsg = new ReactiveProperty<string>();*public IReadOnlyReactiveProperty<string> SensorMsg { get { return _sensorMsg; } }
説明用のため、細かいところは省略してあります。


*public Task()*{//データソースを読み込むstring line;try {using (var reader = new StreamReader(_filePath, Encoding.UTF8)){while ((line = reader.ReadLine()) != null){string key;string value;int sepPos = line.IndexOf("-");if (sepPos < 0){key = line;value = "";}else{key = line.Substring(0, sepPos);value = line.Substring(sepPos + 1);}_TaskDict[key] = value;}}}catch (Exception e){Console.WriteLine("ファイルの読み込みに失敗しました" + e.Message);}}
コンストラクタ

*string line;*try {using (var reader = new StreamReader(_filePath, Encoding.UTF8)){while ((line = reader.ReadLine()) != null){string key;string value;int sepPos = line.IndexOf("-");if (sepPos < 0){key = line;value = "";}else{key = line.Substring(0, sepPos);value = line.Substring(sepPos + 1);}_TaskDict[key] = value;}}}
データソースを読み込む

*public void AddTask(string date,string value)*{//要素を追加するthis._TaskDict[date] = value;//要素を追加したのでテキストファイルに書き込む//テキストファイルを空にするメソッドを呼び出すRefreshFile(_filePath);//テキストファイルに書き込むメソッドを呼び出すWriteFile(_filePath);}
タスクを追加する

*this._TaskDict[date] = value;
要素を追加する

*RefreshFile(_filePath);
要素を追加したのでテキストファイルに書き込む
テキストファイルを空にするメソッドを呼び出す

*WriteFile(_filePath);
テキストファイルに書き込むメソッドを呼び出す

*public void ShowTask()*{Console.WriteLine("\n-----タスク一覧-----\n");foreach (var task in _TaskDict){Console.WriteLine("{0}：{1}",task.Key,task.Value);}Console.WriteLine("\n--------------------\n");}
タスクを見る

*public void RemoveTask(string value)*{if(!_TaskDict.Keys.Contains(value))Console.WriteLine("指定された日付のタスクはありません。");else{_TaskDict.Remove(value);Console.WriteLine(value + "のタスクを削除しました");//テキストファイルを空にするメソッドを呼び出すRefreshFile(_filePath);//テキストファイルに書き込むメソッドを呼び出すWriteFile(_filePath);}}
タスクを削除する

*RefreshFile(_filePath);
テキストファイルを空にするメソッドを呼び出す

*WriteFile(_filePath);
テキストファイルに書き込むメソッドを呼び出す

*private void RefreshFile(string filePath)*{try{File.WriteAllText(filePath, "");}catch (Exception e){Console.WriteLine("ファイルが見つかりませんでした" + e.Message);}}
テキストファイルを空にするメソッド

*private void WriteFile(string filePath)*{try{using (var writer = new StreamWriter(_filePath, append: true)){foreach (var task in _TaskDict)writer.WriteLine(task.Key + "-" + task.Value);}}catch (Exception e){Console.WriteLine("書き込みに失敗しました" + e.Message);}}
テキストファイルに書き込むメソッド


*webViewObject.OnDestroyAsObservable().Subscribe(_ => _uniWebView.CleanCache()).AddTo(webViewObject);
キャッシュのクリア

*_uniWebView.AddUrlScheme("web-view-demo");
スキームを追加

*_uniWebView.OnMessageReceived += (view, message) =>*{switch (message.Path){//閉じるボタン押下case "close"://WebViewを非表示にするif (_uniWebView != null) _uniWebView.Hide(true);break;//↑ボタン押下case "up":player.Translate(Vector3.forward);break;//↓ボタン押下case "down":player.Translate(Vector3.down);break;//→ボタン押下case "right":player.Translate(Vector3.right);break;//←ボタン押下case "left":player.Translate(Vector3.left);break;}};
メッセージ受け取りイベント

*case "close":
閉じるボタン押下

*if (_uniWebView != null) _uniWebView.Hide(true);*break;
WebViewを非表示にする

*case "up":
↑ボタン押下

*case "down":
↓ボタン押下

*case "right":
→ボタン押下

*case "left":
←ボタン押下

*_uniWebView.OnOrientationChanged += (view, orientation) =>*{_uniWebView.Frame = new Rect(0, 0, Screen.width, Screen.height);};
画面の向きが変わるたびに解像度を変更

*_uniWebView.Frame = new Rect(0, 0, Screen.width, Screen.height);
画面サイズを設定

*var color = Color.white;
背景色

*_uniWebView.SetShowToolbar(false);
ツールバー非表示

*_uniWebView.SetHorizontalScrollBarEnabled(false);
横スクロールバー非表示

*_uniWebView.SetShowSpinnerWhileLoading(true);
インジケータ

*var exchangeUrl = UniWebViewHelper.StreamingAssetURLForPath(url);
内部保持してるサイトを読み込み

*_uniWebView.Show();
画面表示


*"Using": [ "Serilog.Sinks.File" ],
ファイルに出力

*"Default": "Verbose"
最小ログレベル

*],
拡張
"WithThreadId", スレッドID
"WithThreadName", スレッド名
"WithMachineName", マシン名
"WithEnvironmentUserName", ユーザー名
"WithProcessId", プロセスID
"WithProcessName", プロセス名
"WithAssemblyName", アセンブリ名
"WithAssemblyVersion", アセンブリバージョン
"WithMemoryUsage", メモリ使用量
"WithExceptionDetails" 例外の詳細情報

*"Name": "Logger",*"Args": {"configureLogger": {"WriteTo": [{"Name": "File","Args": {//ログファイルパス"path": "Logs/All/Default/all.log",//ログファイルのフォーマット"outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss} | [{Level:u3}] | {ThreadId:00}:{ThreadName} | {ProcessId:00}:{ProcessName} | {Message:lj} | {AssemblyName} | {AssemblyVersion} | {MachineName} | {EnvironmentUserName} | {MemoryUsage} B | {NewLine}{Exception}",//1日毎にロールする"rollingInterval": "Day",//直近の7ファイルを保持する（デフォルトでは直近の31ファイル）"retainedFileCountLimit": 7,//ファイルサイズの制限を削除（デフォルトでは1GB）"fileSizeLimitBytes": null,//書き込みをバッファリングする"buffered": true}}]}}
通常のテキスト形式で、全レベルのログを出力するためのLogger

*"path": "Logs/All/Default/all.log",
ログファイルパス

*"outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss} | [{Level:u3}] | {ThreadId:00}:{ThreadName} | {ProcessId:00}:{ProcessName} | {Message:lj} | {AssemblyName} | {AssemblyVersion} | {MachineName} | {EnvironmentUserName} | {MemoryUsage} B | {NewLine}{Exception}",
ログファイルのフォーマット

*"rollingInterval": "Day",
1日毎にロールする

*"retainedFileCountLimit": 7,
直近の7ファイルを保持する（デフォルトでは直近の31ファイル）

*"fileSizeLimitBytes": null,
ファイルサイズの制限を削除（デフォルトでは1GB）

*"buffered": true
書き込みをバッファリングする

*"Name": "Logger",*"Args": {"configureLogger": {"WriteTo": [{"Name": "File","Args": {"path": "Logs/All/Compact/all_compact.json",//JsonFormatter"formatter": "Serilog.Formatting.Compact.CompactJsonFormatter, Serilog.Formatting.Compact","rollingInterval": "Day","retainedFileCountLimit": 7,"fileSizeLimitBytes": null,"buffered": true}}]}}
JSON形式で、全レベルの構造化ログを出力するためのLogger

*"formatter": "Serilog.Formatting.Compact.CompactJsonFormatter, Serilog.Formatting.Compact",*"rollingInterval": "Day",
JsonFormatter

*"Name": "Logger",*"Args": {"configureLogger": {"Filter": [{"Name": "ByIncludingOnly","Args": {"expression": "(@Level = 'Error' or @Level = 'Fatal' or @Level = 'Warning')"}}],"WriteTo": [{"Name": "File","Args": {"path": "Logs/Error/Default/error.log","outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss} | [{Level:u3}] | {ThreadId:00}:{ThreadName} | {ProcessId:00}:{ProcessName} | {Message:lj} | {AssemblyName} | {AssemblyVersion} | {MachineName} | {EnvironmentUserName} | {MemoryUsage} B | {NewLine}{Exception}","rollingInterval": "Day","retainedFileCountLimit": 7,"fileSizeLimitBytes": null,"buffered": true}}]}}
通常のテキスト形式で、Warning以上のログを出力するためのLogger

*"Name": "Logger",*"Args": {"configureLogger": {"Filter": [{"Name": "ByIncludingOnly","Args": {"expression": "(@Level = 'Error' or @Level = 'Fatal' or @Level = 'Warning')"}}],"WriteTo": [{"Name": "File","Args": {"path": "Logs/Error/Compact/error_compact.json","formatter": "Serilog.Formatting.Compact.CompactJsonFormatter, Serilog.Formatting.Compact","rollingInterval": "Day","retainedFileCountLimit": 7,"fileSizeLimitBytes": null,"buffered": true}}]}}
JSON形式で、Warning以上の構造化ログを出力するためのLogger


*reader.Close();
<------一旦クローズ!!!

*command.CommandText = "select 氏名, 所属 from ユーザマスタ where 社員番号 = '456456'";
2回目----------------------------------------------------------------------


*Contract.Result<int>() >= 0
事後条件


*var signUpRequest = new SignUpRequest{ClientId = ConfigurationManager.AppSettings["CLIENT_ID"],Password = user.Password,Username = user.Name,};
リクエストオブジェクト生成

*var signUpResult = await _client.SignUpAsync(signUpRequest);
リザルトオブジェクト取得

*var getUserReq = new GetUserRequest(){AccessToken = authResp.AuthenticationResult.AccessToken};
AccessTokenを元にUser名を取得


*var main = WindowControl.FromZTop(_app);
ウィンドウの特定 - バリエーション4つ
1. 最前面にあるウィンドウ

*main = WindowControl.IdentifyFromTypeFullName(_app, "WpfApplication.MainWindow");*main = WindowControl.IdentifyFromWindowText(_app, "Friendly Handson");
2, 3. ウィンドウ情報を基に特定する - MainWindow.xamlに記載されている

*var mainWindowCore = _app.Type<Application>().Current.MainWindow;
4. 現在操作中のアプリケーションのメインウィンドウ

*var logicalMain = main.LogicalTree();
タブの特定
logicalツリー：xamlファイルの木構造を取得する

*AppVar tabCore = logicalMain.ByType<TabControl>().Single();
AppVar => コントロールオブジェクトそのもの
オブジェクトのポインタのようなものが入っているイメージ

*tab.EmulateChangeSelectedIndex(1);
タブの操作

*.
以下、テキストボックスの特定、コンボボックスの特定 と続いたが、ここでは省略


*public ActionResult Index()*{ViewData["msg"] = "こんにちは！ MVC頑張ろう！";return View();}
GET: Hello


*param["Text"] = "hogehoge message";
とりあえずTextパラメータは必須


*AssetDatabase.Refresh ();
アセットDBの更新


*const string AesIV = @"<半角16文字（1byte=8bit, 8bit*16=128bit>";
初期化ベクトル            ----- (4)

*const string AesKey = @"<半角32文字（8bit*32文字=256bit）>";
暗号化鍵

*AesManaged aes = new AesManaged();
暗号化方式はAES           ----- (1)

*aes.KeySize = 256;
鍵の長さ                  ----- (2)

*aes.BlockSize = 128;
ブロックサイズ（何文字単位で処理するか）

*aes.Mode = CipherMode.CBC;
暗号利用モード             ----- (3)

*aes.Padding = PaddingMode.PKCS7;
パディング                 ----- (5)

*byte[] byteText = Encoding.UTF8.GetBytes(text);
暗号化するためにはバイトの配列に変換する必要がある

*byte[] encryptText = aes.CreateEncryptor().TransformFinalBlock(byteText, 0, byteText.Length);*// Base64形式（64種類の英数字で表現）で返す
暗号化

*return Convert.ToBase64String(encryptText);
Base64形式（64種類の英数字で表現）で返す

*string encryptStr = p.Encrypt("Hello World!");*Console.WriteLine("暗号化後の文字列:{0}", encryptStr);
暗号化


*var str = await new HttpClient().GetStringAsync("http:
hogehoge.com");


*string val = prop.GetValue(obj).ToString();
値

*DisplayNameAttribute dispNameAttr = Attribute.GetCustomAttribute(prop, typeof(DisplayNameAttribute)) as DisplayNameAttribute;
DisplayName属性取得

*StringLengthAttribute lenAttr = Attribute.GetCustomAttribute(prop, typeof(StringLengthAttribute)) as StringLengthAttribute;
StringLength属性取得

*RequiredAttribute reqAttr = Attribute.GetCustomAttribute(prop, typeof(RequiredAttribute)) as RequiredAttribute;
Required属性取得

*,,,
ID(123456)は最大桁数5桁を超えています。
なまえは必須項目です。


*private void SendFunc(int[] SendedData){
相手が送ってきたときに自動的に発動

*}
相手から来たデータを自分の受け皿に上書き保存


*cellReport1.FileName = @"C:\Book1.xlsx";
①-1デザインファイル名を指定します。

*cellReport1.Report.Start();
①-2帳票ドキュメントの作成を開始します。

*cellReport1.Report.File();
①-3帳票の作成を開始します。

*cellReport1.Page.Start("Sheet1", "1");
②-1デザインシートを指定します。

*cellReport1.Cell("A1").Value = "VB-Reportのサンプル";
②-2セルに値を設定します。

*cellReport1.Page.End();
②-3ページ処理を終了します。

*cellReport1.Report.End();
③-1帳票ドキュメント作成を終了します。

*viewerControl1.Document = cellReport1.Document;
③-2作成した帳票ドキュメントをビューアに設定します。

*public static readonly DependencyProperty DocumentProperty =DependencyProperty.Register("Document", typeof(Document), typeof(ViewerControlEx), new PropertyMetadata(null, new PropertyChangedCallback(OnDocumentChanged)));
Using a DependencyProperty as the backing store for Document.  This enables animation, styling, binding, etc...

*doc.Load(@"見積書リスト.xml");
請求リストを読み込みます。

*cellReport1.Cell("**Date").Value = DateTime.Now;
日付

*cellReport1.Cell("**EndDate").Value = (double)DateTime.Now.ToOADate() + 7;
見積有効日

*cellReport1.Cell("**Mitsumori").Value = node.SelectSingleNode("./見積書番号").InnerText;
見積書番号

*string officename = node.SelectSingleNode("./会社名").InnerText;
会社名

*string sectionname = node.SelectSingleNode("./部署名").InnerText;
部署名

*cellReport1.Cell("**UserName").Value = node.SelectSingleNode("./お客様名").InnerText + " 様";
お客様名

*cellReport1.Cell("**Post").Value = "〒" + node.SelectSingleNode("./郵便番号").InnerText;
郵便番号

*cellReport1.Cell("**Address1").Value = node.SelectSingleNode("./住所県").InnerText;
住所県

*cellReport1.Cell("**Address2").Value = node.SelectSingleNode("./住所その他").InnerText;
住所その他

*int y = 0;
商品一覧

*string discount = "";
一括割引対象品と除外品を判断するためのフラグ("1"→"0"に変更した時点で割引額の表示)

*if ((discount == "0") && (discountPrev == "1"))
一括割引対象品でなくなった時点で、割引額を求める
全て割引除外品の場合、計算を行わない

*cellReport1.Cell("**Shouhin", 0, y).Value = node2.SelectSingleNode("./商品名").InnerText;
商品名

*int unitNumber = Convert.ToInt32(node2.SelectSingleNode("./数量").InnerText);
数量

*int unitPrice = Convert.ToInt32(node2.SelectSingleNode("./単価").InnerText);
単価

*int totalPrice = unitNumber * unitPrice;
金額

*cellReport1.Cell("**Biko", 0, y).Value = node2.SelectSingleNode("./備考").InnerText;
備考

*cellReport1.Cell("**Zeinuki").Value = totalSeikyu;
税抜

*int tax = (int)(totalSeikyu * 0.05);
消費税

*cellReport1.Cell("**Zeikomi").Value = totalSeikyu + tax;
税込


*Debug.WriteLine($"Start Action: Token = {token}");
アクションが実行される前の処理

*Debug.WriteLine("End Action: Token = {token}");
アクションが実行された後の処理


*}
このブロックを抜けたらcommand 、conn はDisposeされます。

*}
メソッドの定義 ここまで---------------------------------↑


*using Lottie.Forms.iOS.Renderers;
Lottie用に追加

*AnimationViewRenderer.Init();
Lottie用に追加


*GpioOperationHelper.Open(2);
2番ピンが開いていない場合はOpenします。

*GpioOperationHelper.SetDirection(2, GpioDirection.Out);
信号を出力方向に設定します。。

*var task = Task.Run(async () =>*{//とりあえず10回ON/OFFforeach(var i in Enumerable.Range(1,10)){//トグルさせてみる。if (GpioOperationHelper.GetValue(2) == 1){Console.WriteLine("Off");GpioOperationHelper.SetValue(2, 0);}else{Console.WriteLine("On");GpioOperationHelper.SetValue(2, 1);}//0.5秒ごとにチカチカ！await Task.Delay(500);}});
Lチカタスクを作成します。

*await Task.Delay(500);
0.5秒ごとにチカチカ！

*task.Wait();
タスクを実行し、完了を待機します。


*xmlns:materialDesign="http:
materialdesigninxaml.netwinfxxamlthemes"

*Button genderComboBoxclearButton = GenderComboBox.Template.FindName("PART_ClearButton", GenderComboBox) as Button;
ComboBoxのClearButtonを取得します

*ScaleTransform st = new ScaleTransform(0.75,0.75);*genderComboBoxclearButton.RenderTransform = st;
ComboBoxのClearButtonの大きさを少し小さめにします

*genderComboBoxclearButton.Padding = new System.Windows.Thickness(2, 4, -5, -4);
ComboBoxのClearButtonの表示位置を調整します


*int pid = System.Diagnostics.Process.GetCurrentProcess().Id;
ログファイルにプロセス番号も出力できるようにする

*const string APPENDER_NAME = "test1";
出力するログファイル名を動的に変更するため設定されているFileAppenderを取得する

*string file = fileAppender.File;
ファイル名を「MyLog_{YYYYMMDD}_{pid}.log」の形式に置き換え、変更前のファイルを削除する


*:
Console.WriteLine($"SpecialFoo : {((SpecialFoo)specialFoo).GetSome()}");   コンパイル不可


*} else {
タッチされていない場合→スティックを元の位置に戻す

*//m_MouseLook.LookRotation (transform, m_Camera.transform);*}
↓↓↓FPSCameraControllerの回転と衝突するのでコメントアウト


*var agg = new AggregateCatalog(assm, extensions);
2つのカタログをマージしたカタログを作成する

*}
ex.Value.Execute();  拡張機能クラスのインスタンスは作成しない


*private int _writeIndex = -1;
書き終わった位置


*.ObservesProperty(() => Flag);
ObservesPropertyでFlagを監視するよう指定する


*var fooMock = Substitute.For<Foo>();
モックの生成

*fooMock.GetBaz().Returns("baz");
戻り値を設定

*fooMock.Received().GetBaz();
メソッドが呼ばれたかどうかをテスト


*_isInited = true;
何かしらの初期化処理を実行


*public ushort UshortVal { get; set; } = 0xabcd;
組み込み型


*string host = "localhost";
ListenするIPアドレスを決める

*int port = xxxx;
Listenするポート番号

*System.Net.Sockets.TcpListener listener
TcpListenerオブジェクトの生成

*listener.Start();*Console.WriteLine("Listenを開始しました({0}:{1})。",
Listenを開始する

*System.Net.Sockets.TcpClient client = listener.AcceptTcpClient();*Console.WriteLine("クライアント({0}:{1})と接続しました。",
接続要求があったら受け入れる

*System.Net.Sockets.NetworkStream ns = client.GetStream();
NetworkStream取得

*System.Text.Encoding enc = System.Text.Encoding.UTF8;
クライアントから送られたデータを受信する

*int resSize = ns.Read(resBytes, 0, resBytes.Length);
データの一部を受信する

*ms.Write(resBytes, 0, resSize);
受信したデータを蓄積する

*resMsg = enc.GetString(ms.ToArray());
受信したデータを文字列に変換

*string sendMsg = resMsg.ToString();
クライアントにデータを送信する
クライアントに送信する文字列を作成

*byte[] sendBytes = enc.GetBytes(sendMsg);
文字列をByte型配列に置換

*ns.Write(sendBytes, 0, sendBytes.Length);
データを送信する

*ns.Close();
閉じる

*listener.Stop();
リスナを閉じる


*PerformSegue("MyNamedSegue", this);*,,,
Display the Scene defined by the given Segue ID


*public static readonly DependencyProperty targetDataGridProperty =DependencyProperty.Register("targetDataGrid", typeof(DataGrid), typeof(OxyPlot_Behavior), new PropertyMetadata(null));
Using a DependencyProperty as the backing store for targetDataGrid.  This enables animation, styling, binding, etc...


*var callbackUrl = Url.Page("/Account/ConfirmEmail",pageHandler: null,values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },protocol: Request.Scheme);
code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));

*//    pageHandler: null,*//    values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },
"/Account/ConfirmEmail",

*values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },protocol: Request.Scheme);
pageHandler: null,

*await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",$"Please confirm your account by <a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>clicking here</a>.");
protocol: Request.Scheme);

*//    $"Please confirm your account by <a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>clicking here</a>.");
await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",

*[Display(Name = "支給額")][Required(ErrorMessage = "支給額は必須入力です")]↓これをつけると3桁カンマあり小数0埋めなしになる[DisplayFormat(DataFormatString = "{0:#,##0.#}", ApplyFormatInEditMode = true)]public decimal PaymentAmount { get; set; }
支給額

*[DisplayFormat(DataFormatString = "{0:#,##0.#}", ApplyFormatInEditMode = true)]public decimal PaymentAmount { get; set; }
↓これをつけると3桁カンマあり小数0埋めなしになる


*var result = await client.GetStringAsync("http:
weather.livedoor.comforecastwebservicejsonv1?city=" + cityId);

*result = Uri.UnescapeDataString(result);
API 取得したデータをデコードして WeatherModel に取得

*var titleColumnSet = new ColumnSet();
タイトル作成

*var mainColumnSet = new ColumnSet();
本文作成
天気情報をセット

*string day = forcast.dateLabel;*string date = DateTime.Parse(forcast.date).Date.ToString("M/d");
天気データの取得と加工

*string maxTemp, minTemp;
temperature が null の場合は "--" に変換

*AddTextBlock(mainColumn, $"{day}({date})", TextSize.Large, HorizontalAlignment.Center);AddTextBlock(mainColumn, $"{maxTemp} / {minTemp} °C", TextSize.Medium, HorizontalAlignment.Center);AddImage(mainColumn, forcast.image.url, ImageSize.Medium, HorizontalAlignment.Center);}}}
データのセット


*private List<Piyo> m_piyos = new List<Piyo>();
集約

*m_piyos.Add(piyo);
チェックが必要ならば、この辺でする。
車とタイヤの例ならば、「車」クラスが「走行中」状態のときにAddされないようにガードするとか。

*return m_piyos.Remove(piyo);
Addと同じく、チェックが必要ならば、この辺でする。

*}
特になし

*private List<Piyo> m_piyos = new List<Piyo>();
コンポジション

*}
Disposeなど、削除に必要なものを実装


*,,,*int[][] array = { new int[]{ 1, 2, }, new int[] { 3, 4 } };
{1, 2, 3, 4}


*sw.WriteLine($"
{dicItemName[x.Item2]}");

*case TileID.Dirt:
土のブロック

*case TileID.Stone:
石のブロック


*public DbSet<HogeModel> HogeHogeModel { get; set; }
こいつを元にTableが作られる

*Database.EnsureDeleted();
DBの中身を空にするらしい

*Database.EnsureCreated();
DbSetを元にTableを作るらしい

*optionsBuilder.UseSqlite(@"Data Source='hoge\hoge.db'");
DBのパスを入れよう

*SQLitePCL.Batteries_V2.Init();
こんなん初見でわかるわけないやろ


*new EndpointAddress("net.pipe:
localhostHogeSearchService")).CreateChannel()


*[Commands("hello")]
コマンドとして使用する文字列をアトリビュートで設定


*void Start ()*{input = gameObject.GetComponent<LocalHandInput>();_initializePos = gameObject.transform.localPosition;material = new Material(Shader.Find("Diffuse"));gameObject.GetComponent<Renderer>().material = material;}
Use this for initialization

*void Update ()*{//if Hand is lost,this gameobject's color is become Red.material.color = InputSources.Instance.hands.GetHandState(input.Handedness, input.MinConfidence) == null ? Color.red : new Color(.4f,.4f,1f);gameObject.transform.position = _initializePos + input.LocalPosition;}
Update is called once per frame


*var leftTex = leftCam.targetTexture;
RenderTextureからTexture2Dに変換します

*count = count + 1;
ここでfor文との行ずれを調整するために別に用意した変数の値を1ずつ加算します


*private void CutTask() {Task.Run(() => {if (semaphore1.CurrentCount == 0) {System.Threading.Interlocked.Increment(ref count_x);semaphore2.Release();semaphore1.Release();}semaphore1.Wait();semaphore2.Wait();if (count_x > 0) {System.Threading.Interlocked.Decrement(ref count_x);return;}HeavyProcess();semaphore2.Release();semaphore1.Release();});}
--------------------


*.SelectMany(d => Directory.EnumerateFiles(d))
戻り値 IEnumerable<string>　（ファイルのリスト）


*Console.WriteLine("Doing!");
Doing! の位置で評価タイミングがわかる！違いに注意


*//foreach版-----------------------------------------------*//結果を格納する変数を作成する。
<Scoreの合計を抽出します>

*int ret1 = 0;
foreach版-----------------------------------------------
結果を格納する変数を作成する。

*ret1 += m.Score;
値を足していく。

*var ret2 = members.Select(x => x.Score).Sum();
Linq版--------------------------------------------------
メンバー表の中からスコアだけを射影し、合計する。

*var ret2 = members.Sum(x => x.Score);
Linq版--------------------------------------------------
メンバー表の中からスコアの合計を求めます。

*//foreach版-----------------------------------------------*//結果を格納する変数を作成する。
<男の数をカウントします>

*int ret1 = 0;
foreach版-----------------------------------------------
結果を格納する変数を作成する。

*ret1++;
男性の場合はカウントアップ

*var ret2 = members.Count(x => x.Sex == "男");
Linq版--------------------------------------------------
membersの中で性別が男性の個数を返します。

*//foreach版-----------------------------------------------*//計算用の合計値
<Ageの平均値を集計します。>

*double sum = 0;
foreach版-----------------------------------------------
計算用の合計値

*int count = 0;
計算用の件数

*sum += m.Age;
合計値と件数をカウントアップ

*double ret1 = sum / count;
平均値を算出する

*var ret2 = members.Average(x => x.Age);
Linq版--------------------------------------------------
membersの年齢の平均値を算出する

*//foreach版-----------------------------------------------*//最大値を格納する変数
<Scoreの最大値を集計します。>

*int ret1 = 0;
foreach版-----------------------------------------------
最大値を格納する変数

*ret1 = mem.Score;
ret1の値を超える値が出てきた場合は値を更新

*var ret2 = members.Max(x => x.Score);
Linq版--------------------------------------------------
membersの中でScoreが最大のものを抽出

*//foreach版-----------------------------------------------*//最小値を格納する変数に、int型の上限値を入れて初期化
<Scoreの最小値を集計します。>

*int ret1 = int.MaxValue;
foreach版-----------------------------------------------
最小値を格納する変数に、int型の上限値を入れて初期化

*if (mem.Score < ret1)*ret1 = mem.Score;
ret1の値よりも小さい値が出てきた場合は値を更新

*var ret2 = members.Min(x => x.Score);
Linq版--------------------------------------------------
membersの中でスコアが最小のものを抽出

*//foreach版-----------------------------------------------*//積算合計を保持する変数
<Scoreの積算を取得する>

*int ret1 = 1;
foreach版-----------------------------------------------
積算合計を保持する変数

*ret1 = ret1 * mem.Score;
値を積算していく。

*var ret2 = members.Aggregate(1,(n, next) => n * next.Score);
Linq版--------------------------------------------------
memberのScoreを順次積算していく。

*//for版-----------------------------------------------*//最高スコア
<最高スコアの人を名前付きで出力する>

*int maxScore = 0;
for版-----------------------------------------------
最高スコア

*int index = 0;
リスト検索用インデックス

*maxScore = members[i].Score;
最大値が見つかったら更新し、インデックスを保持。

*var ret2 = members.Aggregate(members.First(),
Linq版--------------------------------------------------
membersの中からスコアが最大のものを取得し、名前と一緒に表示する

*(max, next) => max.Score < next.Score ? next : max,
スコア最大を求める

*x => $"最高点 : {x.Score}点 / {x.Name }");
表示結果を作成する


*string url = "https:
" + customerId + ".ods.opinsights.azure.comapilogs?api-version=2016-04-01";


*var MonsterList = new List<Monster>();
モンスターを格納するリスト

*MonsterList.Add(new Monster());
リストに生成したモンスターのインスタンスを追加

*int randomValue = rd.Next(97);
Randomクラスからランダム値を生成
HP値が最大100になるように範囲を設定

*AddHP = AddHP + "|";
ランダム値の分だけ「|」を生成してAddHPに追加

*WriteLine("Moster" + Convert.ToString(RoopCount) + "HP:" +
出力


*}
読み込み

*}
保存

*}
読み込み

*}
保存


*var sample = new List<List<string>>();
各列のリストを初期化

*var strWithIndex = str.Select(x => x.Split(',').Where(word => !string.IsNullOrWhiteSpace(word)).Select((word, i) => new { word, i }));
1行をカンマで分割して、0からインデックスを追加

*var oneColumnData = strWithIndex.SelectMany(word => word).ToLookup(x => x.i);
全ての行を平坦化して、先ほど追加したインデックスでグループ化する.


*<add key="AuthenticationUri" value="https:
westus.api.cognitive.microsoft.comstsv1.0issueToken" >

*this.SubscriptionKey,
Custom Speech ServiceのEndpointページに書かれたSubscription Key

*this.SubscriptionKey,
Custom Speech ServiceのサブのKey Azureポータルをみるとわかる。ただ上のSubscription Keyと同じでも動く

*);
Custom Speech ServiceのEndpointページに書かれたWebSocket for LongDictation mode
"https:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.api.cris.ai/ws/cris/speech/recognize/continuous"


*return token;
TODO ここに実装方法を記述
例：app.configから取得　定数クラスから取得等

*await this.ReplyTextMessageSampleEvent( channelAccessToken , replyToken , "追加されました" );
TODO ここにイベント内容を記載
以下サンプル


*raise(Unit);
Sends an event to itself


*Console.WriteLine(result);
p@5k#2Az


*var weatherResult = await client.GetStringAsync("http:
weather.livedoor.comforecastwebservicejsonv1?city=140010");

*weatherResult = Uri.UnescapeDataString(weatherResult);
API 取得したデータをデコードして WeatherModel に取得

*var message = context.MakeMessage();
返答メッセージを作成

*WeatherModel weather = await GetWeatherAsync();
天気を取得

*var weatherCard = GetCard(weather);
message.Text = $"今日の天気は {weather.forecasts[0].telop.ToString()} です";
取得した天気情報をカードにセット

*await context.PostAsync(message);
返答メッセージをPost

*var titleColumnSet = new ColumnSet();
タイトル作成

*var mainColumnSet = new ColumnSet();
本文作成
天気情報をセット

*var mainImage = new AdaptiveCards.Image();
天気アイコンをセット

*var titleColumnSet = new ColumnSet();
タイトル作成

*var mainColumnSet = new ColumnSet();
本文作成
天気情報をセット

*string day = item.dateLabel;
天気データの取得と加工

*string maxTemp, minTemp;
temperature が null の場合は "--" に変換

*AddTextBlock(mainColumn, $"{day}({ date})", TextSize.Large, HorizontalAlignment.Center);
データのセット


*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"


*private const string WindowsManagementUri = "https:
management.core.windows.net";


*{XmlSerializer xs = new XmlSerializer(typeof(Product));StringWriter sw = new StringWriter();xs.Serialize(sw, item);serializedData = sw.ToString();}
Serialize

*{XmlSerializer xs = new XmlSerializer(typeof(Product));Product deserilizedObject = xs.Deserialize(new StringReader(serializedData)) as Product;}
Deserialize

*{BinaryFormatter bf = new BinaryFormatter();MemoryStream mem = new MemoryStream();bf.Serialize(mem, item);serializedData = mem.ToArray();}
Serialize

*{BinaryFormatter bf = new BinaryFormatter();MemoryStream mem = new MemoryStream(serializedData);Product deserilizedObject = bf.Deserialize(mem) as Product;}
Deserialize

*{JavaScriptSerializer js = new JavaScriptSerializer();serializedData = js.Serialize(item);}
Serialize

*{JavaScriptSerializer js = new JavaScriptSerializer();Product deserilizedObject = js.Deserialize<Product>(serializedData);}
Deserialize

*{DataContractSerializer ds = new DataContractSerializer(typeof(Product));MemoryStream mem = new MemoryStream();ds.WriteObject(mem, item);serializedData = mem.ToArray();}
Serialize

*{DataContractSerializer bf = new DataContractSerializer(typeof(Product));MemoryStream mem = new MemoryStream(serializedData);Product deserilizedObject = bf.ReadObject(mem) as Product;}
Deserialize

*{DataContractJsonSerializer ds = new DataContractJsonSerializer(typeof(Product));MemoryStream mem = new MemoryStream();ds.WriteObject(mem, item);serializedData = mem.ToArray();}
Serialize

*{DataContractJsonSerializer bf = new DataContractJsonSerializer(typeof(Product));MemoryStream mem = new MemoryStream(serializedData);Product deserilizedObject = bf.ReadObject(mem) as Product;}
Deserialize


*Question1();
----------------- 問題1--------------------

*var datas = new[] { "水本", "椎名", "中野" };
input datas

*// ----------------- foreach版--------------------*// ----------------- Linq版--------------------
ここに処理を追加してみて

*return;
----------------- foreach版--------------------
----------------- Linq版--------------------

*Question1();
----------------- 問題1--------------------

*var datas = new[] { "水本", "椎名", "中野" };
input datas

*//do something(foreach)*// 結果を受け取るリストを用意
----------------- foreach版--------------------

*var forResultDatas = new List<string>();*// ちゃん付けしてリストに入れる
結果を受け取るリストを用意

*foreach (var data in datas)*forResultDatas.Add(data + "ちゃん");
ちゃん付けしてリストに入れる

*foreach (var forResultData in forResultDatas)*Console.WriteLine(forResultData);
ちゃん付けで表示

*var linqResultDatas = datas.Select(x => x + "ちゃん");
----------------- Linq版--------------------
do something(LINQ)
ちゃん付けした列挙を取得

*foreach (var linqResultData in linqResultDatas)
ちゃん付けで表示
output datas

*Question2();
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------

*var datas = new[] { "うづき", "りん", "みお", "みく", "なお" };
input datas

*// ----------------- foreach版--------------------*// ----------------- Linq版--------------------
ここに処理を追加してみて

*return;
----------------- foreach版--------------------
----------------- Linq版--------------------

*Question2();
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------

*var datas = new[] { "うづき", "りん", "みお", "みく", "なお" };
input datas

*//do something(foreach)*// 結果を受け取るリストを用意
----------------- foreach版--------------------

*var forResultDatas = new List<string>();*foreach (var data in datas)
結果を受け取るリストを用意

*if (data.EndsWith("お"))*forResultDatas.Add(data);
末尾が"お"のdataをListに入れる

*foreach (var forResultData in forResultDatas)*Console.WriteLine(forResultData);
文字列の末尾が"お"のデータを表示

*var linqResultDatas = datas.Where(x => x.EndsWith("お"));
----------------- Linq版--------------------
do something(LINQ)
文字列の末尾が"お"の列挙を取得

*foreach (var linqResultData in linqResultDatas)*Console.WriteLine(linqResultData);
文字列の末尾が"お"のデータを表示

*var ret3a = Question3("りん");
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
Question2();
----------------- 問題3--------------------
引数は４パターン試してね！
完全一致パターン

*foreach (var a in ret3a)*Console.Write(a);
表示

*var ret3b = Question3("み%");
前方一致パターン

*foreach (var b in ret3b)*Console.Write(b);
表示

*var ret3c = Question3("%お");
後方一致パターン

*foreach (var c in ret3c)*Console.Write(c);
表示

*var ret3d = Question3("%づき%");
部分一致パターン

*foreach (var d in ret3d)*Console.Write(d);
表示

*var datas = new[] { "うづき", "りん", "みお", "みく", "なお" };
data sources

*return null;
ここに処理を追加してみて

*var ret3a = Question3("りん");
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
Question2();
----------------- 問題3--------------------
引数は４パターン試してね！
完全一致パターン

*foreach (var a in ret3a)*Console.Write(a);
表示

*var ret3b = Question3("み%");
前方一致パターン

*foreach (var b in ret3b)*Console.Write(b);
表示

*var ret3c = Question3("%お");
後方一致パターン

*foreach (var c in ret3c)*Console.Write(c);
表示

*var ret3d = Question3("%づき%");
部分一致パターン

*foreach (var d in ret3d)*Console.Write(d);
表示

*var datas = new[] { "うづき", "りん", "みお", "みく", "なお" };
data sources

*if (value.StartsWith("%") && value.EndsWith("%"))
部分一致
一文字目が%かつ末尾が%の場合

*var partMatchedCase = datas.Where(a => a.Contains(value.Trim('%')));
valueから%を除いたものとdatasの中に存在してるのが一致してる列挙を取得

*else if (value.EndsWith("%"))
前方一致
末尾が%の場合

*var forwardMatchedCase = datas.Where(b => b.StartsWith(value.Trim('%')));*foreach (var matchedB in forwardMatchedCase)
valueから%を除いたものとdatasの中に存在してる一文字目が一致してる列挙を取得

*else if (value.StartsWith("%"))
後方一致
一文字目が%の場合

*var backMatchedCase = datas.Where(c => c.EndsWith(value.Trim('%')));
valueから%を除いたものとdatasの中に存在してる末尾が一致してる列挙を取得

*else
完全一致
それ以外

*var matchedCase = datas.Where(d => d.Equals(value));
valueとdatasの中に存在してる文字列が一致してる列挙を取得

*IEnumerable<string> cute = new[] { "まゆ", "ちえり", "ゆかり", "きょうこ", "さえ" };
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
Question2();
----------------- 問題3--------------------
引数は４パターン試してね！
完全一致パターン
var ret3a = Question3("りん");
表示
foreach (var a in ret3a)
Console.Write(a);
前方一致パターン
var ret3b = Question3("み%");
表示
foreach (var b in ret3b)
Console.Write(b);
後方一致パターン
var ret3c = Question3("%お");
表示
foreach (var c in ret3c)
Console.Write(c);
部分一致パターン
var ret3d = Question3("%づき%");
表示
foreach (var d in ret3d)
Console.Write(d);
----------------- 問題4--------------------
列挙を作るよ

*var ret4a = Divide(cute, 2);
分割した列挙を入れるよ

*foreach (var r in ret4a)*Console.WriteLine(string.Join(",", r));
表示

*return null;
ここに処理を追加してみて

*IEnumerable<string> cute = new[] { "まゆ", "ちえり", "ゆかり", "きょうこ", "さえ" };
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
Question2();
----------------- 問題3--------------------
引数は４パターン試してね！
完全一致パターン
var ret3a = Question3("りん");
表示
foreach (var a in ret3a)
Console.Write(a);
前方一致パターン
var ret3b = Question3("み%");
表示
foreach (var b in ret3b)
Console.Write(b);
後方一致パターン
var ret3c = Question3("%お");
表示
foreach (var c in ret3c)
Console.Write(c);
部分一致パターン
var ret3d = Question3("%づき%");
表示
foreach (var d in ret3d)
Console.Write(d);
Console.WriteLine();
----------------- 問題4--------------------
列挙を作るよ

*var ret4a = Divide(cute, 2);
分割した列挙を入れるよ

*foreach (var r in ret4a)*Console.WriteLine(string.Join(",", r));
表示

*yield return datas.Take(value);
valueの分だけデータを貰って

*datas = datas.Skip(value);
valueの分だけスキップ

*var LiPPS = new[] { "しき", "しゅうこ", "かなで", "高田純次", "みか" };
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
Question2();
----------------- 問題3--------------------
引数は４パターン試してね！
完全一致パターン
var ret3a = Question3("りん");
表示
foreach (var a in ret3a)
Console.Write(a);
前方一致パターン
var ret3b = Question3("み%");
表示
foreach (var b in ret3b)
Console.Write(b);
後方一致パターン
var ret3c = Question3("%お");
表示
foreach (var c in ret3c)
Console.Write(c);
部分一致パターン
var ret3d = Question3("%づき%");
表示
foreach (var d in ret3d)
Console.Write(d);
Console.WriteLine();
----------------- 問題4--------------------
列挙を作るよ
IEnumerable<string> cute = new[] { "まゆ", "ちえり", "ゆかり", "きょうこ", "さえ" };
分割した列挙を入れるよ
var ret4a = Divide(cute, 2);
表示
foreach (var r in ret4a)
Console.WriteLine(string.Join(",", r));
----------------- 問題5--------------------
LiPPS ?　をてきとーな数に分けてくれー！

*foreach (var r in LiPPS)*Console.WriteLine(string.Join(",", r));
表示

*public static IEnumerable<IEnumerable<T>> Divide<T>(this IEnumerable<T> datas, int value)
作ったDivideを
①Extensionsクラスに切り出して、IEnumerableの拡張メソッドにする
②ジェネリック（<T>）型に対応させ、string以外の型でも処理できるようにする
返却する最後の列挙数が指定したvalue数に満たない場合、
切り捨てを行う処理を追加する。
（例えば、前回の例でいうと{"さえ"}の個数は指定したvalue（２個）に満たないので、
切り捨てることとする）

*return null;
ここに処理を書いて

*var LiPPS = new[] { "しき", "しゅうこ", "かなで", "高田純次", "みか" }.Divide(3);
----------------- 問題1--------------------
Question1();
----------------- 問題2--------------------
Question2();
----------------- 問題3--------------------
引数は４パターン試してね！
完全一致パターン
var ret3a = Question3("りん");
表示
foreach (var a in ret3a)
Console.Write(a);
前方一致パターン
var ret3b = Question3("み%");
表示
foreach (var b in ret3b)
Console.Write(b);
後方一致パターン
var ret3c = Question3("%お");
表示
foreach (var c in ret3c)
Console.Write(c);
部分一致パターン
var ret3d = Question3("%づき%");
表示
foreach (var d in ret3d)
Console.Write(d);
Console.WriteLine();
----------------- 問題4--------------------
列挙を作るよ
IEnumerable<string> cute = new[] { "まゆ", "ちえり", "ゆかり", "きょうこ", "さえ" };
分割した列挙を入れるよ
var ret4a = Divide(cute, 2);
表示
foreach (var r in ret4a)
Console.WriteLine(string.Join(",", r));
----------------- 問題5--------------------
LiPPS ?　わぁお！ここで拡張メソッド呼べちゃう！
.Divide(3)っていうのもわかりやすい！

*foreach (var r in LiPPS)*Console.WriteLine(string.Join(",", r));
表示

*public static IEnumerable<IEnumerable<T>> Divide<T>(this IEnumerable<T> datas, int value)
作ったDivideを
Extensionsクラスに切り出して、IEnumerableの拡張メソッドにする
ジェネリック（<T>）型に対応させ、string以外の型でも処理できるようにする
返却する最後の列挙数が指定したvalue数に満たない場合、
切り捨てを行う処理を追加する。
（例えば、今回の例でいうと{"さえ"}の個数は指定したvalue（２個）に満たないので、
切り捨てることとする)

*throw new ArgumentNullException();
そもそも分割するdatasが無いのはおかしくね？
Exceptionを出して、使った人に告知してあげようかな

*if (!datas.Any())*yield break;
要素が無いとbreak

*yield return datas.Take(value);
value分だけをyield return

*foreach (var s in datas.Skip(value).Divide(value))*// きちんと分割できるか判定
上の処理でTakeした分だけSkipしたものから再帰して自分REST@RT

*if (value == s.Count())*// 分割したものを各自yield return
きちんと分割できるか判定

*yield return s;
分割したものを各自yield return


*string mutexName = "MyApp";
Mutex名を決める ■■■ 必ずアプリケーション固有の文字列に変更すること！ ■■■

*bool createdNew;
Mutexオブジェクトを作成する

*MessageBox.Show("多重起動はできません。");
されなかった場合は、すでに起動していると判断して終了

*Application.EnableVisualStyles();
はじめからMainメソッドにあったコードを実行

*mutex.ReleaseMutex();
ミューテックスを解放する


*var vari = Dictionaly.GetDictionaly();
異体字一覧（辞書）を取得する

*var f = vari.FirstOrDefault(x => x.Key == c.ToString());
文字が異体字リストにあれば、異体字を取得する。
ex. 浜 →  [浜|濵|濱]

*return result;
結果を返す

*var query = from c in db.Entitywhere SqlFunctions.PatIndex("%" + regStrings + "%", c.Modid) == 1select c;
regStringsが検索ワード（[浜|濵|濱][崎|隑|陭|徛|﨑|㟢|碕|埼|嵜]）等


*mesh.triangles = verticesIndex;
四角ポリゴンなのでtriangleを使うべきなのかは謎。


*Task<string> dl3 = hc.GetStringAsync("https:
www.microsoft.comen-us");

*await Task.WhenAll(dl1, dl2, dl3);
すべてのダウンロード完了を待つ


*CollectionChangedEventManager.RemoveListener(collection, listener1);
非UIスレッドでAddListenerしたものをUIスレッドでRemoveListener → 削除されない

*Task.Run(() => CollectionChangedEventManager.RemoveListener(collection, listener2)).Wait();
UIスレッドでAddListenerしたものを非UIスレッドでRemoveListener → 削除されない

*Task.Run(() => CollectionChangedEventManager.RemoveListener(collection, listener3)).Wait();
非UIスレッドでAddListenerしたものを非UIスレッドでRemoveListener → 削除されるかもしれないしされないかもしれない


*await Task.Delay(6000);*Console.WriteLine($"Eternal Loop: {DateTime.Now}");
if (ct.IsCancellationRequested) { return; }

*await Task.Delay(6000);*Console.WriteLine($"Eternal Loop: {DateTime.Now}");
if (ct.IsCancellationRequested) { return; }


*});
非同期で行いたい処理を記述

*});
非同期で行いたい処理を記述

*}
同期させた後に書きたい処理を書く


*var entities = new List<TEntity>();
戻り値

*var getterDelegateItems = new Dictionary<int, Func<TModel, object>>();
Getアクセッサ デリゲートキャッシュ

*var setterDelegateItems = new Dictionary<int, Action<TEntity, object>>();
Setアクセッサ デリゲートキャッシュ

*Func<TModel, object> getter = null;
Getアクセッサ デリゲート

*Action<TEntity, object> setter = null;
Setアクセッサ デリゲート

*var entityTargetProps = new List<PropertyInfo>();
設定対象プロパティリスト

*var entityProps = typeof(TEntity).GetProperties().Where(a => a.CanWrite).ToDictionary(a => a.Name);
TEntityプロパティリスト ディクショナリ(パフォーマンス対策)

*var modelProps = typeof(TModel).GetProperties().Where(a => a.CanRead);
TModel プロパティリスト

*PropertyInfo entityProp = null;
設定対象プロパティを抽出

*entityTargetProps.Add(entityProp);
設定対象プロパティに追加

*var entity = new TEntity();
設定先TEntity

*getter = CreateGetDelegate<TModel>(setProp.Name);
Getアクセッサ デリゲートを生成

*getterDelegateItems.Add(setProp.MetadataToken, getter);
生成したGetデリゲートをキャッシュ

*setter = CreateSetDelegate<TEntity>(setProp.Name);
Setアクセッサ デリゲートを生成

*setterDelegateItems.Add(setProp.MetadataToken, setter);
生成したSetデリゲートをキャッシュ

*var val = getter(item);
プロパティ値を取得

*setter(entity, val);
プロパティ値を設定


*// query allWeatherForecasts {//   allWeatherForecasts {//     nodes {//       id//       dt//       temperatureC//       summary//     }//   }// }
クエリー

*//   allWeatherForecasts {//     nodes {//       id//       dt//       temperatureC//       summary//     }//   }
query allWeatherForecasts {

*//     nodes {//       id//       dt//       temperatureC//       summary//     }
allWeatherForecasts {

*public class WeatherForecast*{public int Id { get; set; }public DateTime Dt { get; set; }private double _tempC;public double TemperatureC{get{return _tempC;}set{_tempC = value;}}public double TemperatureF{get{return 32 + (_tempC / 0.5556);}set{_tempC = (value - 32) * 0.5556;}}public string Summary { get; set; }public WeatherForecast(){Dt = DateTime.Now.Date;}}
}

*// {//   "data": {//     "allWeatherForecasts": {//       "nodes": [//         {//           "id": 1,//           "dt": "2000-01-01",//           "temperatureC": 7,//           "summary": "Hot"//         },//         {//           "id": 2,//           "dt": "2000-01-02",//           "temperatureC": -16,//           "summary": "Cool"//         },////         （中略）////       ]//     }//   }// }
レスポンス例

*//   "data": {//     "allWeatherForecasts": {//       "nodes": [//         {//           "id": 1,//           "dt": "2000-01-01",//           "temperatureC": 7,//           "summary": "Hot"//         },//         {//           "id": 2,//           "dt": "2000-01-02",//           "temperatureC": -16,//           "summary": "Cool"//         },////         （中略）////       ]//     }//   }
{

*//     "allWeatherForecasts": {//       "nodes": [//         {//           "id": 1,//           "dt": "2000-01-01",//           "temperatureC": 7,//           "summary": "Hot"//         },//         {//           "id": 2,//           "dt": "2000-01-02",//           "temperatureC": -16,//           "summary": "Cool"//         },////         （中略）////       ]//     }
"data": {

*//       "nodes": [*//         {//           "id": 1,//           "dt": "2000-01-01",//           "temperatureC": 7,//           "summary": "Hot"//         },
"allWeatherForecasts": {

*//         {//           "id": 1,//           "dt": "2000-01-01",//           "temperatureC": 7,//           "summary": "Hot"//         },
"nodes": [

*//         },*//         {//           "id": 2,//           "dt": "2000-01-02",//           "temperatureC": -16,//           "summary": "Cool"//         },
"summary": "Hot"

*//         {//           "id": 2,//           "dt": "2000-01-02",//           "temperatureC": -16,//           "summary": "Cool"//         },
},

*public class AllWeatherForecastsResponse
（中略）

]
}
}
}

*public async Task<List<WeatherForecast>> GetForecastListAsync()
行儀が良くないですが、今回はここにGraphQLエンドポイントのURLを書いてしまいます
private const string graphql_http = "http:192.168.1.7/15000/graphql";

*//{//    未実装//}
public async Task UpdateForecastAsync(WeatherForecast forecastToUpdate)

*}
未実装
}
public async Task DeleteForecastAsync(WeatherForecast forecastToRemove)
{
未実装
}
public async Task InsertForecastAsync(WeatherForecast forecastToInsert)
{
未実装
}


*sign = sign * -1;
signをトグルさせる


*var foo = helper.GetSecret<Foo>();
型情報から、データを取得して、値を詰めて返す。


*sb.Length = 0;
これで前回編集していた文字列がクリアされて、新しい編集が開始できる。

*string text = sb.ToString();
なんか文字列編集する処理


*var baseUrl = "https:
abc.vault.azure.net";


*var helper =  new KeyVaultHelper(keyVaultClientMock.Object, "https:
abc.vault.azure.net");


*var secretIdentifier = "https:
spikekey.vault.azure.netsecretsSomeSecret";


*private void Imprison(Kusogaki k, TimeOfCrime e)
書き換え


*ServicePointManager.Expect100Continue = false;
HTTPエラー(417)対応


*.Where( s => !s.StartsWith("
") )

*PaizaUtility.IO = new TestData();
もうちょっとカッコイイ実装（JavaのCDIみたいな）にしたかったけど、paiza用なんでこれで良いよね。

*int a = 0;
【サンプル実装】ヘッダパーサを独自に指定するパターン。
ヘッダで２種類のデータ数が指定され、
それらが連続したデータ行として与えられる、みたいなケースを想定。
（実際にそんな問題があるのかどうかは知らん）

*a = token[0];
二種類のデータ数をそれぞれ控える。

*return a + b;
二種類のデータの合計数を返す（読み込み行数）

*var args = PaizaUtility.ReadArgs( parser ).ToList();
ヘッダのパーサを指定して ReadArgs を呼び出す。


*productMock.Verify(product => product.GetContent("http:
www.microsoft.com"));


*GlobalConfiguration.Configure(WebApiConfig.Register);
ルーティングの処理などを書く


*public static readonly DependencyProperty MyPropertyProperty =DependencyProperty.Register("MyProperty", typeof(int), typeof(ownerclass), new PropertyMetadata(0));
Using a DependencyProperty as the backing store for MyProperty.  This enables animation, styling, binding, etc...

*public static readonly DependencyProperty MyPropertyProperty =DependencyProperty.Register("MyProperty", typeof(int), typeof(ownerclass),new PropertyMetadata(0, (s, e) => ((ownerclass)s)._myProperty = (int)e.NewValue));
Using a DependencyProperty as the backing store for MyProperty.  This enables animation, styling, binding, etc...


*using ObjCRuntime;
現在のテンプレートには含まれません

*}*public override NSObject RepresentedObject {get {return base.RepresentedObject;}set {base.RepresentedObject = value;// Update the view, if already loaded.}}
Do any additional setup after loading the view.

*ClickedLabel.StringValue = string.Format("The button has been clicked {0} time{1}.",++numberOfTimesClicked, (numberOfTimesClicked < 2) ? "" : "s");
Update counter and label


*Talk(GetTalkableObject());
話しかけられる状態かつプレイヤーが生きていたら話しかける


*string filePath = "【CSVファイルが置いているフォルダ】/Oita.csv";
ファイルのパス

*private void CreateCsv(string filePath)*{try{//ファイルを読み込みで開くSystem.IO.StreamReader sr = new System.IO.StreamReader(filePath);//一時ファイルを作成するstring tmpPath = System.IO.Path.GetTempFileName();//一時ファイルを書き込みで開くSystem.IO.StreamWriter sw = new System.IO.StreamWriter(tmpPath);//書き込む用の変数string writeLine = "";//内容を一行ずつ読み込むwhile (sr.Peek() > -1){//一行読み込むstring line = sr.ReadLine();int len = line.Length;//true → 読み飛ばす(continue) / false →CSV書換え処理if(isCheckWords(line)){continue;}int output;bool flag = Int32.TryParse(line, out output);if (flag){if("1" == line){writeLine += line;}else{System.Text.StringBuilder sb = new System.Text.StringBuilder(writeLine);string pr = sb.ToString();sw.WriteLine(pr);writeLine = "";writeLine += line;}}else{writeLine += "," + line;}}//閉じるsr.Close();sw.Close();//一時ファイルと入れ替えるSystem.IO.File.Copy(tmpPath, filePath, true);System.IO.File.Delete(tmpPath);}catch (System.Exception e){// ファイルを開くのに失敗したときSystem.Console.WriteLine(e.Message);}}
CSV書換え

*System.IO.StreamReader sr = new System.IO.StreamReader(filePath);
ファイルを読み込みで開く

*string tmpPath = System.IO.Path.GetTempFileName();
一時ファイルを作成する

*System.IO.StreamWriter sw = new System.IO.StreamWriter(tmpPath);
一時ファイルを書き込みで開く

*string writeLine = "";
書き込む用の変数

*string line = sr.ReadLine();
一行読み込む

*sr.Close();
閉じる

*System.IO.File.Copy(tmpPath, filePath, true);
一時ファイルと入れ替える

*System.Console.WriteLine(e.Message);
ファイルを開くのに失敗したとき

*private bool isCheckWords(String line){if (line.Contains("市町村名") ||line.Contains("避難施設一覧") ||line.Contains("市町村名") ||line.Contains("/") ||line.Contains("町丁目名") ||line.Contains("名称") ||line.Contains("整理") ||line.Contains("別添") ||line.Contains("機密")){//必要ないワードのため読み飛ばす処理（continue）に進むreturn true;}else{//必要なワードのためCSVに書き込む処理に進むreturn false;}}
C避難所が書いていない行以外は無視する

*return true;*}else{
必要ないワードのため読み飛ばす処理（continue）に進む

*return false;
必要なワードのためCSVに書き込む処理に進む


*using (var command = scope.Resolve<Command>())
ここでエラーになる


*public Command(IBackend backend)
Command に IBackend を Injection する書き方


*var url = "http:
www.data.jma.go.jpobdstatsdatamdrrtem_rctalltablemxtemsadext00_rct.csv";


*Debug.Log(transform.position);
ここだとOK


*var records = csv.GetRecords<Foo>();
csv データが行毎に Foo クラスに格納され、IEnumerable<Foo> として
records に割り当てられます。

*PrepareHeaderForMatch = args => args.Header.ToLower(),
読み取ったヘッダが小文字に変換されるように ToLower() を仕込みます。

*var records = csv.GetRecords<Foo>();
csv データが行毎に Foo クラスに格納され、IEnumerable<Foo> として
records に割り当てられます。

*csv.Context.RegisterClassMap<FooMap>();
クラスマップを使って読み込み順序を指定します

*var records = csv.GetRecords<Foo>();
csv データが行毎に Foo クラスに格納され、IEnumerable<Foo> として
records に割り当てられます。

*csv.Read();
読み込み開始準備を行います

*csv.ReadHeader();
ヘッダを読み込みます

*csv.WriteRecords(records);
この１行で保存ができる

*HasHeaderRecord = false,};
ヘッダを出力しないように指定


*GC.Collect();
GCの実行

*GC.WaitForPendingFinalizers();
ファイナライズ(後述)の完了を待つ

*GC.Collect();
ファイナライズで参照されなくなったオブジェクトを開放

*Console.WriteLine("Dispose");
確保したリソースを開放する処理

*Console.WriteLine("Finalize");
確保したアンマネージリソースを開放する処理

*public class SuppressFinalize*{public SuppressFinalize(){GC.SuppressFinalize(this);}~SuppressFinalize(){Console.WriteLine("このメッセージは出力されない");}}
超ナンセンスなクラス

*}
マネージリソースの開放

*disposed = true;
アンマネージリソースの開放

*sw = new StreamWriter(file);
IOExceptionが発生するかも

*sw?.Dispose();
Exception が発生してもしなくても Dispoose() は呼びたい


*[HttpGet("{id}")]
GET api/values/5

*[HttpPut("{id}")]
PUT api/values/5

*[HttpDelete("{id}")]
DELETE api/values/5


*private string name;
フィールド

*private int id;
バッキングフィールド

*public int ID*{// getアクセサget { return id; }// setアクセサ// valueはプロパティに代入された値set { id = value; }}
プロパティ

*get { return id; }
getアクセサ

*// valueはプロパティに代入された値*set { id = value; }
setアクセサ

*set { id = value; }
valueはプロパティに代入された値

*// public 戻り値 プロパティ名*// {//     ....// }
プロパティは内部的には以下のようになる。

*// {//     ....// }
public 戻り値 プロパティ名

*private int id;
バッキングフィールド

*public int ID*{// getアクセサ// public とは書いていないけど public である。get { return id; }// setアクセサ// valueはプロパティに代入された値private set { id = value; }}
プロパティ

*// public とは書いていないけど public である。*get { return id; }
getアクセサ

*get { return id; }
public とは書いていないけど public である。

*// valueはプロパティに代入された値*private set { id = value; }
setアクセサ

*private set { id = value; }
valueはプロパティに代入された値

*public int ID { get; private set; }
プロパティ

*// public int ID { get; private set; } = 100;
内部ではデータを変更したい場合、以下のように書く。

*public class VirtualProp*{public virtual int MyProperty{get{return MyProperty + 100;}}}
基底クラス

*public class OverrideProp : VirtualProp*{public override int MyProperty{get{return MyProperty + 200;}}}
サブクラス


*var test = nodes.Item(0).InnerText;
この様な形でテーブル名を取得可能


*var cmdline = $"-parentHWND {GetWallpaperHWND()}";
子ウィンドウとして起動


*}
dbを使った処理
db.Database.Connection.Close();   Closeを明記している


*public static IEnumerable<T[]> Enumerate<T>(IEnumerable<T> items) {var original = items.ToArray();foreach (var element in Permutation.Enumerate(items, items.Count(), false)) {bool isComplete = element.Zip(original, (a, b) => a.Equals(b)).All(x => x == false);if (isComplete)yield return element;}}
攪乱順列（完全順列ともいう）を列挙する


*Assert.AreEqual("期待するログメッセージ", logMessage);
受け取ったログメッセージで期待値検証する


*url: new Uri("https:
www.noraneko.co.jpvoice.xml"));


*}
遷移先から戻ってきたときの処理


*_Mutex = new System.Threading.Mutex(false,"SubProcess");
ミューテックスクラスのインスタンス生成

*if (_Mutex.WaitOne(0, false) == false)*return true;
Mutexの所有権を要求

*string AppName = Process.GetCurrentProcess().MainModule.FileName;
プロセスを取得

*if (ProcessFlg)*return true;
起動済ならreturn


*//var info = (Product)serializer.ReadObject(resStream);*//Console.WriteLine("id: {0} name: {1} category: {2} price: {3}", info.Id, info.Name, info.Category, info.Price);
var serializer = new DataContractJsonSerializer(typeof(Product));

*//Console.WriteLine("id: {0} name: {1} category: {2} price: {3}", info.Id, info.Name, info.Category, info.Price);
var info = (Product)serializer.ReadObject(resStream);


*string html = wc.DownloadString("http:
www.microsoft.com");

*private async void button1_Click(object sender, EventArgs e)
www.microsoft.com の応答が遅くてもウィンドウが固まらない。
Task(async/await) を使うとダウンロード処理をUIスレッドではない別のスレッドで実行してくれる。

*textBox1.Text = html;
WebClient.DownloadStringTaskAsync() の戻り値の型は Task<string>
await キーワードを付けると Task の完了を待つと同時に string 型に変換してくれる。
Task の完了を待っている間、UIスレッドはブロックされない（ウィンドウは固まらない）。
string html = await wc.DownloadStringTaskAsync("http:www.microsoft.com/");

*bool isPrime = await Task.Run(() =>
テキストボックスに入力された数値が素数かどうかを表示する。
入力された数値が非常に大きい場合、
計算に時間がかかりUIスレッドがブロックされてしまうので
Task.Run()を使って別スレッドに処理させる。

*Task<string> scrapingTask = downloadTask.ContinueWith(dlTask =>
ダウンロードしたWebコンテンツからリンクURLを抜き出して表示する。
ダウンロードとスクレイピングには時間がかかる可能性がある。
ダウンロードが終わったらスクレイピング処理を実行させたい。
Task<string> downloadTask = new WebClient().DownloadStringTaskAsync("https:msdn.microsoft.com/ja-jp/library/dd460693(v=vs.110).aspx");

*public static void Main()*{int num = 1000000;List<int> oddNumbers = new List<int>();Parallel.For(0, num, i =>{if (i % 2 == 1) oddNumbers.Add(i);});Console.WriteLine($"List: {num}以下の奇数は{oddNumbers.Count}個です。");}
マルチコアCPUなPCで実行すると毎回結果が変わる不思議なプログラム

*public static void Main()*{int num = 1000000;ConcurrentBag<int> oddNumbers = new ConcurrentBag<int>();Parallel.For(0, num, i =>{if (i % 2 == 1) oddNumbers.Add(i);});Console.WriteLine($"ConcurrentBag: {num}以下の奇数は{oddNumbers.Count}個です。");}
毎回正確な結果が得られる安全なプログラム。


*public bool PartialMactch { get; set; }
部分一致

*public bool IsDeviceConnected()*{ManagementObjectSearcher mos = new ManagementObjectSearcher();mos.Query.QueryString = QueryString;var moc = mos.Get();return moc.Count > 0;}
接続されてるか確認

*public string GetPortName()*{ManagementObjectSearcher mos = new ManagementObjectSearcher();var check = new System.Text.RegularExpressions.Regex("(COM[1-9][0-9]?[0-9]?)");mos.Query.QueryString = QueryString;var moc = mos.Get();foreach(var m in moc){string value = m.GetPropertyValue("Name") as string;if(value == null){continue;}if (check.IsMatch(value)){var match = check.Match(value);return match.Captures[0].Value;}}return null;}
ポート番号取得


*private void MethodWait()*{Print($"Before await. Thread Id: {Thread.CurrentThread.ManagedThreadId}");var task = MethodAsync();// 結果待ちをするためにスレッドをロックして他のスレッドから触れなくしてしまう。task.Wait();Print($"After wait. Thread Id: {Thread.CurrentThread.ManagedThreadId}");}
awaitを使っていないのでasync不要。

*task.Wait();*Print($"After wait. Thread Id: {Thread.CurrentThread.ManagedThreadId}");
結果待ちをするためにスレッドをロックして他のスレッドから触れなくしてしまう。

*await Task.Run(() => Print($"In task run. Thread Id: {Thread.CurrentThread.ManagedThreadId}"));
処理終了後に元のスレッドに戻そうとするが、元のスレッドがTask.Wait()によりロックされており戻せない。

*private void MethodWait()*{Print($"Before await. Thread Id: {Thread.CurrentThread.ManagedThreadId}");var task = MethodAsync();// 結果待ちをするためにスレッドをロックして他のスレッドから触れなくしてしまう。task.Wait();Print($"After wait. Thread Id: {Thread.CurrentThread.ManagedThreadId}");}
awaitを使っていないのでasync不要。

*task.Wait();*Print($"After wait. Thread Id: {Thread.CurrentThread.ManagedThreadId}");
結果待ちをするためにスレッドをロックして他のスレッドから触れなくしてしまう。

*Print($"After configure await. Thread Id: {Thread.CurrentThread.ManagedThreadId}");
ConfigureAwait(false)の後なのでメインスレッドに戻らず実行される。

*SynchronizationContext.SetSynchronizationContext(null);*await Task.Run(() => Print($"In task run. Thread Id: {Thread.CurrentThread.ManagedThreadId}"));
SynchronizationContext.Currentをnullに設定する。ここではメインスレッドに対して設定している。


*}
Disposeは勝手にやってくれるらしいです。


*byte[] bin = ToBinary(ase);
.aseのバイナリを取得

*int colorCount = bin[11];
RGBの個数の取得

*int pos = 40;
RGB値を取り出していく


*this.Items.Add(new BaseNode());
ダミーノードの追加

*catch (Exception e) when (e is UnauthorizedAccessException || e is DirectoryNotFoundException || e is FileNotFoundException)*{Console.WriteLine(e.Source + "：" + e.Message);}
アクセス拒否、ディレクトリ・ファイルが見つからないエラーをスキップ

*public static readonly DependencyProperty CommandProperty =DependencyProperty.Register("Command", typeof(ICommand), typeof(ExplorerStyleTreeView_Behavior), new PropertyMetadata(null));
Using a DependencyProperty as the backing store for Message.  This enables animation, styling, binding, etc...

*var selectedItemStartingPoint = (Point)(selectedItem.PointToScreen(new Point(0.0d, 0.0d)) - treeView.PointToScreen(new Point(0.0d, 0.0d)));
選択中Itemの始点設定

*var selectedItemEndPoint = new Point(selectedItemStartingPoint.X + selectedItem.ActualWidth, selectedItemStartingPoint.Y + selectedItem.ActualHeight);
選択中Itemの終点設定

*C_Load.Subscribe(x => Load(x as TreeView));
コンストラクタ内

*}
処理


*[FunctionName("EchoExec")]
Point 4


*byte[] bytes = texture.EncodeToPNG ();
使うAPIによってURLが変わる
var url = "https:westus.api.cognitive.microsoft.com/emotion/v1.0/recognize";

*var headers = new Dictionary<string, string> () {{"Ocp-Apim-Subscription-Key", [取得したAPI_KEYを入力してください]},{"Content-Type", "application/octet-stream"}};
ヘッダはだいたい固定

*var request = new EntityEmoteModel ();
JSON形式でくるので適当にデータクラスに突っ込む

*if(callback != null)*callback (request);
データを返す


*private const string LOG_FORMAT = "{0:000} {1:00000}";
ミリ秒３桁 linenumber５桁想定


*User = "moge@example.com"
G Suiteの管理者アカウントを設定する。このアカウントが実行したことになる

*CalendarService service = new CalendarService(new BaseClientService.Initializer(){HttpClientInitializer = credential,ApplicationName = "Calendar API Sample",});
Create the service.

*var cal = service.Calendars.Get("piyo@example.com").Execute();
ドメイン内のカレンダーを取得

*var schedule = new Event(){Summary = "APIからのテストスケジュール",Start = new EventDateTime(){DateTime = new DateTime(2017, 7, 10, 12, 0, 0)},End = new EventDateTime(){DateTime = new DateTime(2017, 7, 10, 13, 0, 0)},Description = "詳細"};
ドメイン内のカレンダーに予定を作成


*PenSize = 10;
初期値指定

*PenStyleChanged();
ペンのスタイル指定

*PenAttrivutes = new DrawingAttributes(){太さWidth = PenSize,高さHeight = PenSize,形状StylusTip = PenStyle == true ? StylusTip.Ellipse : StylusTip.Rectangle,色Color = Colors.Green,滑らかな線（ギザギザするのでTrue推奨）FitToCurve = true,蛍光ペン（背景画像の上に色を置くのでTrue推奨）IsHighlighter = true};
DrawingAttributesの指定

*Width = PenSize,高さHeight = PenSize,形状StylusTip = PenStyle == true ? StylusTip.Ellipse : StylusTip.Rectangle,色Color = Colors.Green,滑らかな線（ギザギザするのでTrue推奨）FitToCurve = true,蛍光ペン（背景画像の上に色を置くのでTrue推奨）IsHighlighter = true};
太さ

*Height = PenSize,形状StylusTip = PenStyle == true ? StylusTip.Ellipse : StylusTip.Rectangle,色Color = Colors.Green,滑らかな線（ギザギザするのでTrue推奨）FitToCurve = true,蛍光ペン（背景画像の上に色を置くのでTrue推奨）IsHighlighter = true};
高さ

*StylusTip = PenStyle == true ? StylusTip.Ellipse : StylusTip.Rectangle,色Color = Colors.Green,滑らかな線（ギザギザするのでTrue推奨）FitToCurve = true,蛍光ペン（背景画像の上に色を置くのでTrue推奨）IsHighlighter = true};
形状

*Color = Colors.Green,滑らかな線（ギザギザするのでTrue推奨）FitToCurve = true,蛍光ペン（背景画像の上に色を置くのでTrue推奨）IsHighlighter = true};
色

*FitToCurve = true,蛍光ペン（背景画像の上に色を置くのでTrue推奨）IsHighlighter = true};
滑らかな線（ギザギザするのでTrue推奨）

*IsHighlighter = true};
蛍光ペン（背景画像の上に色を置くのでTrue推奨）

*string extension = System.IO.Path.GetExtension(dlgSave.FileName).ToUpper();
拡張子を取得する

*Rect rectBounds = inkCanvas.Strokes.GetBounds();
ストロークが描画されている境界を取得

*DrawingVisual drawingVisual = new DrawingVisual();
描画先を作成

*context.DrawRectangle(inkCanvas.Background, null, rect);
描画エリアを作成

*RenderTargetBitmap rtb = new RenderTargetBitmap((int)rect.Width, (int)rect.Height, 96, 96, PixelFormats.Default);
ビットマップに変換

*BitmapEncoder enc = new PngBitmapEncoder();
ビットマップエンコーダー変数の宣言

*enc.Frames.Add(BitmapFrame.Create(rtb));
ビットマップフレームを作成してエンコーダーにフレームを追加する

*System.IO.Stream stream = System.IO.File.Create(dlgSave.FileName);
ファイルに書き込む

*inkCanvas.Strokes.Clear();
現在のストロークをクリア


*private string appPath;
メンバ変数

*private void Form1_Load(object sender, EventArgs e)*{//パスの取得this.appPath = System.Windows.Forms.Application.ExecutablePath;//ディレクトリthis.appDir = System.IO.Path.GetDirectoryName(this.appPath);//ファイル名this.appName = System.IO.Path.GetFileName(this.appPath);//ファイル名(拡張子含まず)this.appNameWoExt = System.IO.Path.ChangeExtension(this.appName, null);//設定ファイル名this.confFileName = System.IO.Path.ChangeExtension(this.appPath, ".conf");//バージョンSystem.Diagnostics.FileVersionInfo ver_info = System.Diagnostics.FileVersionInfo.GetVersionInfo(System.Reflection.Assembly.GetExecutingAssembly().Location);if (ver_info == null){this.appVer = "0.0";this.appVerFull = "0.0.0.0";}else{this.appVer =ver_info.FileMajorPart+ "." + ver_info.FileMinorPart+ "." + ver_info.FileBuildPart+ "." + ver_info.FilePrivatePart;this.appVerFull = ver_info.FileVersion;}//タイトルバーthis.Text = this.appNameWoExt + " ver." + this.appVer;//------------------------------//設定//設定をロードthis.mySettings = new AppSettings();this.mySettings = (AppSettings)this.mySettings.loadSettings(this.confFileName);if (this.mySettings == null){this.mySettings = new AppSettings();}//最小サイズthis.MinimumSize = this.Size;//設定を反映this.mySettings.SetWinStat(this);//------------------------------this.updateCtrl = true;//----------//----------this.updateCtrl = false;//------------------------------this.ctrlEnable();}
フォーム Load イベントハンドラ

*this.appPath = System.Windows.Forms.Application.ExecutablePath;
パスの取得

*this.appDir = System.IO.Path.GetDirectoryName(this.appPath);
ディレクトリ

*this.appName = System.IO.Path.GetFileName(this.appPath);
ファイル名

*this.appNameWoExt = System.IO.Path.ChangeExtension(this.appName, null);
ファイル名(拡張子含まず)

*this.confFileName = System.IO.Path.ChangeExtension(this.appPath, ".conf");
設定ファイル名

*System.Diagnostics.FileVersionInfo ver_info = System.Diagnostics.FileVersionInfo.GetVersionInfo(System.Reflection.Assembly.GetExecutingAssembly().Location);
バージョン

*this.Text = this.appNameWoExt + " ver." + this.appVer;
タイトルバー

*this.mySettings = new AppSettings();
設定
設定をロード

*this.MinimumSize = this.Size;
最小サイズ

*this.mySettings.SetWinStat(this);
設定を反映

*private void Form1_FormClosing(object sender, FormClosingEventArgs e)*{//ウインドウ状態の取得this.mySettings.GetWinStat(this);//保存this.mySettings.saveSettings(this.confFileName);}
フォーム FromClosing イベントハンドラ

*this.mySettings.GetWinStat(this);
ウインドウ状態の取得

*this.mySettings.saveSettings(this.confFileName);
保存

*private void ctrlEnable()*{}
メソッド


*string addr_ip;
IPアドレス

*string hostname = System.Net.Dns.GetHostName();
ホスト名を取得

*System.Net.IPAddress[] addr_arr = System.Net.Dns.GetHostAddresses(hostname);
ホスト名からIPアドレスを取得

*addr_ip = "";
探す


*void listBox1_MouseUp(object sender, MouseEventArgs e)
参考
C#.NET Tips
http:codepanic.itigo.jp/cs/listbox_select_right.html
注意
コンテキストメニューを割り当てていると、右クリック時 MouseUp イベントが発生しない。
この場合、MouseUp イベントハンドラ内で、自前でコンテキストメニューを表示させる。

というようなことが参考記事には書かれていたが、
VS2015community では、コンテキストメニューを割り当てても、MouseUp イベント発生した。
コントロール名
リストボックス ... listBox1
コンテキストメニュー ... contextMenuStrip1
============================================================
リストボックスの MouseUp イベントハンドラ

*int index = listBox1.IndexFromPoint(e.Location);
マウス座標から選択すべきアイテムのインデックスを取得

*listBox1.ClearSelected();
すべての選択状態を解除してから

*listBox1.SelectedIndex = index;
アイテムを選択

*}
コンテキストメニューを表示
Point pos = listBox1.PointToScreen(e.Location);
contextMenuStrip1.Show(pos);


*this.MinimumSize = this.Size;
参考
フォームのサイズを制限する .NET Tips C#, VB.NET
http:dobon.net/vb/dotnet/form/minimumsize.html
============================================================
フォームの Load イベントハンドラ

*[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
フォームの幅や高さ固定

*RECT rect = (RECT)System.Runtime.InteropServices.Marshal.PtrToStructure(m.LParam, typeof(RECT));
フォームの範囲を取得

*//{//  rect.Bottom = rect.Top + this.MinimumSize.Height;//}
if (rect.Bottom - rect.Top > this.MinimumSize.Height)

*System.Runtime.InteropServices.Marshal.StructureToPtr(rect, m.LParam, true);
フォームの範囲を設定


*private void Form1_Load(object sender, EventArgs e)*{//Xxxのドラッグ＆ドロップを許可this.Xxx.AllowDrop = true;}
フォームのLoadイベントハンドラ

*this.Xxx.AllowDrop = true;
Xxxのドラッグ＆ドロップを許可

*private void Xxx_DragEnter(object sender, DragEventArgs e)*{if (e.Data.GetDataPresent(DataFormats.FileDrop)){e.Effect = DragDropEffects.Copy;}else{e.Effect = DragDropEffects.None;}}
DragEnterイベントハンドラ

*private void Xxx_DragDrop(object sender, DragEventArgs e)*{if (e.Data.GetDataPresent(DataFormats.FileDrop)){string[] file_arr = (string[])(e.Data.GetData(DataFormats.FileDrop));//■file_arrを使った処理■}}
DragDropイベントハンドラ

*}
■file_arrを使った処理■


*using System.Data;
参考
C#で文字列式を演算する
http:www.infortec.co.jp/blog/archives/Item_710
============================================================
using

*public static T StrCalc<T>(string s, params object[] args)*{using (DataTable dt = new DataTable()){s = string.Format(s, args);object result = dt.Compute(s, "");var converter = TypeDescriptor.GetConverter(typeof(T));return (T)converter.ConvertFromString(result.ToString());}}
通常のメソッドで使用

*string exp1 = "(2.5 + 1.5) * 3";
呼び出し

*static class Class1*{public static T Calc<T>(this string s, params object[] args){using (DataTable dt = new DataTable()){s = string.Format(s, args);object result = dt.Compute(s, "");var converter = TypeDescriptor.GetConverter(typeof(T));return (T)converter.ConvertFromString(result.ToString());}}}
string型の拡張メソッドで使用

*string exp1 = "(2.5 + 1.5) * 3";
呼び出し


*private void textBoxWriteLine(string str)
コントロール名
テキストボックス ... textBox1
注意
行数が増えると遅くなるので注意
------------------------------
C#


*var result = Rps.Battle(own, opponent) switch
Draw, Lose, Winのままなら
var result = Rps.Battle(own, opponent).ToString();


*private void ctrlEnable()
コントロール名
ListView ... listView1
上ボタン ... buttonUp
下ボタン ... buttonDown
コントロールの有効無効

*int sel_id = this.getListViewSelectedIndex();
ListViewの選択綱目のIDを取得

*this.buttonUp.Enabled = false;
ボタン無効

*this.buttonUp.Enabled = (sel_id > 0);
0番以外は、UPボタン有効

*this.buttonDown.Enabled = (sel_id < this.listView1.Items.Count - 1);
末尾以外は、DOWNボタン有効

*private int getListViewSelectedIndex()*{if (this.listView1.SelectedIndices == null || this.listView1.SelectedIndices.Count == 0){return -1;}else{return this.listView1.SelectedIndices[0];}}
ListViewの選択綱目のIDを取得

*private void listView1_SelectedIndexChanged(object sender, EventArgs e)*{//コントロールの有効無効this.ctrlEnable();}
ListViewの SelectedIndexChanged イベントハンドラ

*this.ctrlEnable();
コントロールの有効無効

*private void buttonUp_Click(object sender, EventArgs e)*{//マイナス方向に項目移動this.listViewItemUpDown(-1);}
UPボタンの Click イベントハンドラ

*this.listViewItemUpDown(-1);
マイナス方向に項目移動

*private void buttonDown_Click(object sender, EventArgs e)*{//マイナス方向に項目移動this.listViewItemUpDown(1);}
DOWNボタンの Click イベントハンドラ

*this.listViewItemUpDown(1);
マイナス方向に項目移動

*private void listViewItemUpDown(int direction)
ListViewの項目移動
引数
direction ... 移動方向(マイナス方向=-1、プラス方向=1)

*int sel_id = this.getListViewSelectedIndex();
ListViewの選択綱目のIDを取得

*if (sel_id < 0) return;*//マイナス方向移動？
未選択？

*if (sel_id <= 0) return;*//
0番は移動できない

*else*{//末尾は移動できないif (sel_id >= this.listView1.Items.Count - 1) return;//direction = 1;}
プラス方向

*if (sel_id >= this.listView1.Items.Count - 1) return;*//
末尾は移動できない

*this.listView1.BeginUpdate();
ListView更新開始

*ListViewItem item = this.listView1.Items[sel_id];
移動する項目

*this.listView1.Items.RemoveAt(sel_id);
移動する項目を削除

*this.listView1.Items.Insert(sel_id + direction, item);
移動する項目をずらして挿入

*this.listView1.EndUpdate();
ListView更新終了


*this.listView1.AutoResizeColumns(ColumnHeaderAutoResizeStyle.ColumnContent);
参考
ListViewの列の幅を自動調節する .NET Tips C#, VB.NET
http:dobon.net/vb/dotnet/control/lvautocolumnwidth.html
------------------------------
項目のテキスト幅で、自動調節

*this.listView1.AutoResizeColumns(ColumnHeaderAutoResizeStyle.HeaderSize);
ヘッダと項目のテキスト幅で、自動調節


*//文字列配列 → リストビュー項目生成 → リストビューへ追加*string[] lv_item_str = { "aaa", "bbb", "ccc" };
方法1

*string[] lv_item_str = { "aaa", "bbb", "ccc" };
文字列配列 → リストビュー項目生成 → リストビューへ追加

*int id = this.listView1.Items.Count;
方法2
リストビューへ文字列を項目追加 → 追加した項目にサブ項目追加


*private int getListViewSelectedIndex()*{if ( this.listView1.SelectedIndices == null || this.listView1.SelectedIndices.Count == 0 ){return -1;}else{return this.listView1.SelectedIndices[0];}}
C#


*this.toolStripStatusLabel1.Spring = true;
参考
【C++CLI】StatusStrip（ステータスバー）上のコントロールを右揃えに配置する　画像処理ソリューション
http:imagingsolution.blog107.fc2.com/blog-entry-77.html
============================================================
1個のステータスラベルを右寄せ
------------------------------
C#

*this.toolStripStatusLabel1.Spring = true;
2個のステータスラベルで、
toolStripStatusLabel1 が 左寄せ、toolStripStatusLabel2 が右寄せ
------------------------------
C#


*//  コンボボックスの幅を自動的にアイテムの内容にあわせる - Paradigm Shift Design*//  http://ishitoya.hatenablog.com/entry/20090209/1234179378
参考

*Graphics g = this.comboBox1.CreateGraphics();
コンボボックスの幅を自動的にアイテムの内容にあわせる - Paradigm Shift Design
http:ishitoya.hatenablog.com/entry/20090209/1234179378


*var res = await client.GetAsync("https:
対象サイトFQDN");


*var userAccount = new ChannelAccount(id: "29:2WLwfakXxSbEze4gfeGxeS31nXfELePLX3deELoxHw");
送信先ユーザー ※IDは適当だけどこんな感じの文字列だった


*}
ロジックを書く


*protected override bool ProcessDialogKey(Keys keyData)
参考
テキストボックスで CTRL+A を有効にする - BiBoLoG
http:d.hatena.ne.jp/Guernsey/20081016/1224135096
テキストボックスのCtrl-A (改)

*}
このほかにもショートカットキーなどをここに記述できる

*public static Control GetRealActiveControl(ContainerControl parentControl)
参考
現在アクティブな（選択されている、フォーカスのある）コントロールを取得する、指定したコントロールをアクティブにする .NET Tips C#, VB.NET
http:dobon.net/vb/dotnet/control/selectcontrol.html

*Control ac = parentControl.ActiveControl;
ActiveControlプロパティを取得


*sw.Restart();
+演算子


*builder.RegisterType<Shell>();
Shell の登録

*Application.Current.MainWindow = (Shell)Shell;
Shell を MainWindow に設定して表示する。

*new Bootstrapper().Run();
Bootstrapperを起動

*RegionManager.RegisterViewWithRegion("MainRegion", typeof(SamplePage));
MainRegion に SamplePage を表示

*builder.RegisterType<SampleMessageProvider>().As<ISampleMessageProvider>();
SampleMessageProvider を ISampleMessageProvider として登録

*builder.RegisterType<SamplePage>();
SamplePage を登録

*builder.RegisterType<Shell>();
Shell の登録

*builder.RegisterModule<Modules.SampleModule.SampleModuleRegistry>();
Autofac Module の登録

*var mc = (ModuleCatalog)ModuleCatalog;
Prism Module の登録

*Application.Current.MainWindow = (Shell)Shell;
Shell を MainWindow に設定して表示


*public textPrefab;
(事前に用意）


*public event EventHandler Time;
データを持たないイベントデリゲートの宣言
ここでは"Time"というイベントデリゲートを宣言する

*Time(this, EventArgs.Empty);
"Time"イベントの発生

*clsSleep.Time += new EventHandler(this.SleepClass_Time);
イベントハンドラの追加

*MessageBox.Show("OK!");
イベントが発生したとき

*public event EventHandler Time;
データを持たないイベントデリゲートの宣言

*public class TimeEventArgs : EventArgs
Timeイベントで返されるデータ
ここではstring型のひとつのデータのみ返すものとする

*public delegate void TimeEventHandler(object sender, TimeEventArgs e);
デリゲートの宣言
TimeEventArgs型のオブジェクトを返すようにする

*public event TimeEventHandler Time;
イベントデリゲートの宣言

*TimeEventArgs e = new TimeEventArgs();
返すデータの設定

*OnTime(e);
イベントの発生

*MessageBox.Show(e.Message);
返されたデータを取得し表示


*memos = new List<MemoData>();
データを設定

*lstMemo.ItemsSource = memos;
リストビューのソースに設定

*btnListAdd.Clicked += (sender, e) => {memos.Add(new MemoData() { Title = "NewData" });};
ボタンイベント


*if (!loopSwap)
Swapが一度も実行されなかった場合はソート終了


*Available = false;
ネットワークが無効な場合.

*var ok = false;
メッセージをしばらく受信していない場合.

*Action<byte[]> replyConsumer =
確認メッセージに対する返信の Consumer を定義.

*ok = true;
正式な返信なら OK.

*Send(new byte[] { 0 });
確認メッセージを送信.

*yield return new WaitForSeconds(CheckTimeoutSeconds);
返信を待機.

*Available = ok;
引き続きメッセージを受信していない場合、結果を反映.

*yield return new Poll(Client.Client);
Socket.Poll で到着を待機.

*byte[] message = Client.Receive(ref endpoint);
以下、受信処理.

*public static void Start()*{int port = DefaultPort;string[] args = Environment.GetCommandLineArgs();for (var i = 0; i < args.Length; i++){if (args[i] == "-executeMethodArgs" &&i + 1 < args.Length &&int.TryParse(args[++i], out port) &&port < 0){// 独自に定義した引数のポート番号が不正だった場合.Debug.LogError("Invalid port number");port = DefaultPort;break;}}Start(IPAddress.Any, port);}
サイレントモードでのみ呼び出される想定の起動処理.

*Debug.LogError("Invalid port number");
独自に定義した引数のポート番号が不正だった場合.

*public static void Start(IPAddress addr, int port)*{Debug.LogFormat("[Server] Service is available at {0}:{1}", addr, port);var udp = new UdpClient(new IPEndPoint(addr, port));IPEndPoint from = null;var freeMessageSerializer = new FreeMessageSerializer();while (true){byte[] message = udp.Receive(ref from);if (message.Length > 0){var theme = (Theme)message[0];if (theme == Theme.Check){// 確認メッセージの返信.Debug.Log("[Server] Received: ping");udp.Send(new byte[] { (byte)Theme.Check }, 1, from);}else if (theme == Theme.Free){// 自由メッセージの返信.var stream = new MemoryStream(message);FreeMessage deserialized = freeMessageSerializer.Deserialize(stream);Debug.Log("[Server] Received: " + deserialized.Text);Debug.Log("[Server] Length: " + message.Length);deserialized.Text = "Thanks!";stream = new MemoryStream();freeMessageSerializer.Serialize(stream, deserialized);byte[] buffer = stream.ToArray();udp.Send(buffer, buffer.Length, from);}}else{Debug.LogError("[Server] Received message size is zero.");}}}
エディタでの再生時のみ呼び出される想定の起動処理.

*Debug.Log("[Server] Received: ping");*udp.Send(new byte[] { (byte)Theme.Check }, 1, from);
確認メッセージの返信.

*var stream = new MemoryStream(message);
自由メッセージの返信.

*Service = new Thread(new ThreadStart(StartServer));
アクティブ時にスレッドを開始.

*Service.Abort();
非アクティブ時にスレッドを終了.


*List<User> UserList = new List<User>*{ new User { ID = 0, Name = "ID0" },
今回はDB用意するのは面倒なので適当にユーザーデータを作成する


*public partial class App : Application
XamlになれるとC#コードでも普通に画面書けることに気が付いた。
Intellisenseとコード補完最大限に効くので結構書きやすい。
物凄く読みにくいけどね🍣

*var browsePage = new ItemsPage{Title = "Browse"};
browse page

*var aboutPage = new AboutPage{Title = "About"};
aboutPage

*_innerNavPage = new NavigationPage(browsePage){Title = browsePage.Title};
InnerNavigationPage


*// support library). There is no need to create a notification*// channel on older versions of Android.
Notification channels are new in API 26 (and not a part of the

*Log.Debug(TAG, "Notification Message Body: " + message.GetNotification().Body);*SendNotification(message.GetNotification().Body);
These is how most messages will be received

*SendNotification(message.Data.Values.First());*}
Only used for debugging payloads sent from the Azure portal

*hub = new NotificationHub(Constants.NotificationHubName,*Constants.ListenConnectionString, this);
Register with Notification Hubs


*context.PostAsync($"こんにちは！ドリンクおすすめ Botです。");
デフォルトのメッセージをセット

*var cvEp = new PredictionEndpoint { ApiKey = "YOUR_PREDICTION_KEY" };
変数定義
bool food = false;   "food" タグの有無
string tag ="";      食べ物カテゴリータグ
string msg = "";     返答メッセージ
Custom Vision API を使う準備

*await context.PostAsync(msg);
画像が送られてきたら Custom Vision を呼び出してタグを取得
メッセージをセット
※次以降の項目で作成します

*var photoUrl = activity.Attachments[0].ContentUrl;
送られてきた画像を Stream として取得

*var cvResult = await cvEp.PredictImageAsync(cvGuid, photoStream);
画像を判定

*await context.PostAsync(msg);
メッセージをセット
※次以降の項目で作成します

*msg = "この写真は " + tag + " だね♪";
タグに応じてメッセージをセット

*switch (tag)
タグに応じてメッセージをセット
msg = "この写真は " + tag + " だね♪";


*return
シーケンスから例外が Throw された場合、
predicate でリトライするかどうかを判定する。


*return Observable.Throw<T>(e);
predicate から例外が Throw された場合、
後続のシーケンスに例外を流す（＝リトライせずオブザーバーに例外を捕捉させる）。


*return RetryWhenRecursive(source, predicate);
predicate から例外が Throw されなかった場合、
再度、起点となったシーケンスに繋げる（＝リトライ）。



*videoClip = Resources.Load(__path) as VideoClip;
動画読み込み

*vp.audioOutputMode = VideoAudioOutputMode.AudioSource;
下の2つは念のための程度の設定です
AudioのOutputModeを選択

*videoPlayer.EnableAudioTrack(0,true);
audioTrack[0]を有効に

*videoPlayer.SetTargetAudioSource(0,audioSource);
audioSourceにaudioTrack[0]を設定？？

*videoPlayer.clip = videoClip;
コレが最後に来るのが大事(直感)

*videoPlayer.Play();
再生


*~SomeClass() {// ログ出力の自作クラス、内部で自作のロガーに警告ログを転送しているFinalizeLog.Warning(nameof(SomeClass));Dispose(false);}
GC発生時にこちらで回収された

*FinalizeLog.Warning(nameof(SomeClass));
ログ出力の自作クラス、内部で自作のロガーに警告ログを転送している

*public void Dispose() => Dispose(true);*void Dispose(bool disposing) {...}
ロジックのバグで呼ばれなかった


*videoPlayer.renderMode = VideoRenderMode.CameraNearPlane;
動画のレンダリングの仕方。デフォルトだとカメラが見れる一番遠く(Far)でレンダリングするっぽい
カメラの設定を使う場合はスクリプトをカメラにアタッチしたほうが良いかも

*videoPlayer.frame = 100;
開始フレームの設定(最初にスキップするフレームの数)

*videoPlayer.isLooping = true;
ループONに

*videoPlayer.loopPointReached += Loop;
動画が最後まで来たときのループ処理

*void Loop(VideoPlayer vp)*{print("LoooooP");}
引数ないと怒られます


*using System.IO;
←add this on the top of your code!

*void Start () {date = DateTime.Now;}
Use this for initialization

*void Update () {string str;string format = "yyyy-MM-dd-HH-mm-ss";string filename = "/data/" + date.ToString (format) + ".csv";fi = new FileInfo(Application.dataPath + filename);str = this.gameObject + "," + (transform.position.x) + "," +(transform.position.y) + "," + (transform.position.z)+","+ transform.rotation.x +","+ transform.rotation.y +","+ transform.rotation.z +","+ transform.rotation.w  ;sw = fi.AppendText();sw.WriteLine(str);sw.Flush();sw.Close();}
Update is called once per frame


*var urlstring = $"http:
stocks.finance.yahoo.co.jpstocksdetail?code={code}";

*var doc = default(IHtmlDocument);
指定したサイトのHTMLをストリームで取得する

*var parser = new HtmlParser();
AngleSharp.Html.Parser.HtmlParserオブジェクトにHTMLをパースさせる

*var priceElement = doc.QuerySelector("#main td[class=stoksPrice]");
クエリーセレクタを指定し株価部分を取得する

*int.TryParse(priceNode.TextContent, NumberStyles.AllowThousands, null, out var price);*Debug.WriteLine("コクヨ(7984.T)の株価: {0}円", price);
取得した株価がstring型なのでint型にパースする

*var doc = default(IHtmlDocument);
休講情報を取得したいサイトのURL
var urlstring = "https:www.ead.tut.ac.jp/board/main.aspx";
指定したサイトのHTMLをストリームで取得する

*var parser = new HtmlParser();
AngleSharp.Html.Parser.HtmlParserオブジェクトにHTMLをパースさせる

*var items = doc.QuerySelectorAll("#grvCancel > tr")
クエリーセレクタを指定して休講情報テーブル部分を取得する

*var data = item.GetElementsByTagName("td");
td単位で複数のデータを取得する

*var date = data[1].TextContent;
休講日

*var period = data[2].TextContent;
時限

*var subject = data[3].TextContent;*return new { Date = date, Period = period, Subject = subject };
授業の名前

*items.ToList().ForEach(item =>*{Debug.WriteLine("${item.Date}({item.Period}) {item.Subject}");});
取得した休講情報を出力する

*var doc = default(IHtmlDocument);
新刊情報を取得したいサイトのURL
var urlstring = "http:www.shuwasystem.co.jp/newbook.html";
指定したサイトのHTMLをストリームで取得する

*var parser = new HtmlParser();
AngleSharp.Html.Parser.HtmlParserオブジェクトにHTMLをパースさせる

*var priceElement = doc.GetElementById("sinkan");
最初のsinkanがコンピュータの関連書籍

*var listItems = priceElement.GetElementsByTagName("dl").Select(n =>
必要な情報を読み取る

*var title = n.QuerySelector("dt").TextContent.Trim();
書籍のタイトルを取得する

*var isbn = n.QuerySelector("dd > p > strong")
書籍のISBNを取得する

*listItems.ToList().ForEach(item =>*{Debug.WriteLine($"{item.Title} ({item.Isbn})");});
結果を出力する


*FileInfo file = new FileInfo(path)
フルパス・拡張子必要

*}
Close() メソッドはWindows Store系アプリの場合使えないのでDispose()で代用
sr.Dispose(); ↑結構大事


*}*foreach(var value in dic.Values) {// valueが欲しいとき}
keyが欲しいとき

*}
valueが欲しいとき


*ServiceManager.Init();
サービス情報を初期化する
Init 内で "認可された 権限コード(AuthorityCode) のリスト" を初期化する

*var users = new List<IUser>()*{new User("foo", AuthorityCode.A), new User("bar", AuthorityCode.B)};
User(Name, AuthorityCode) のリストを作成する(userManager に渡すため)

*var userManager = new UserManager(users);
サービスにて認可された 権限コード(AuthorityCode) を所有したユーザーだけを表示する
プロジェクト実装上 User:"foo" だけが表示される

*var authzCode = new List<AuthorityCode>() { AuthorityCode.S, AuthorityCode.A };
ここからリフレクション
ServiceManager > authorizedCode(private static) に値割り当てる
結果的に ServiceManager > GetServiceAuthorizedCode() の返却値がスタブされている

*var user1 = Substitute.For<IUser>();
ここまでリフレクション


*int freeTrialExpire = 60 * 60 * 24 * 7 * 2;
期間は2週間


*charaState.SetAnimation (0, "Idle", true);
SetAnimationでアニメーションの変更
引数：Track(後述)、アニメーション名、ループ再生か否か

*charaState.Complete += (処理);
アニメーション終了後処理

*charaSkel.SetSlotsToSetupPose ();
スキン変更後は必ず呼ぶ。
SkeletonDataのSlotDataリストの値を使用して、スロットをsetup poseに設定する。


*int v = (player_col - 1) *32;
最初4 色に応じてユーザーの色の画像を指定y


*void _ms_wi_DataAvailable(object sender, WaveInEventArgs e) {try {if (_ms_wloop != null) {byte[] output = Convert16(e.Buffer, e.BytesRecorded, _ms_wloop.WaveFormat);_ms_wloop_ss.WriteLoop(output, 0, output.Length);,,,_micClient = SpeechRecognitionServiceFactory.CreateDataClient(SpeechRecognitionMode.LongDictation, _recog_lang_set, _keyBingSAPI1);_micClient.OnPartialResponseReceived += this.OnPartialResponseReceivedHandler;_micClient.OnResponseReceived += this.OnMicDictationResponseReceivedHandler;_micClient.OnConversationError += this.OnConversationErrorHandler;_micClient.SendAudioFormat(SpeechAudioFormat.create16BitPCMFormat(16000));var recorder = new RecordModel();recorder.RecordDataAvailabled += (sender2, e2) => {if (0 < e2.Length) {try {lock (recorder) {_micClient.SendAudio(e2.Buffer, e2.Length);}} catch (InvalidOperationException w_e4) {}}};recorder.Start();// Bing Speech API1回14秒までなので、14秒まできたら打ち切るtimer = new System.Timers.Timer(13800);timer.Start();timer.Elapsed += (sender2, e2) => {try {recorder.Stop();} catch (TaskCanceledException w_e4) {}};do {if (this.Worker.CancellationPending || cToken.IsCancellationRequested) {e.Cancel = true;break;}Thread.Sleep(Convert.ToInt32(Math.Round(_threadwaitsec/4)));} while (!recorder.isStoped);timer.Stop();timer.Dispose();,,,var speechtxt = outtext;if (0 < lastspeaktext.Length) {// 前回の発言内容とスペースを除去try {speechtxt = speechtxt.Substring(lastspeaktext.Length, speechtxt.Length - lastspeaktext.Length);} catch (Exception w_e4) {speechtxt = speechtxt.Replace(lastspeaktext, "");FuncWriteLogFile(w_e4.ToString());}speechtxt = Regex.Replace(speechtxt, @"\s", "");},,,var speechtxt = outtext;if (0.8 < note.Results[0].Stability) {if (0 < lastspeaktext.Length) {}var subtext = "";if (1 < note.Results.Count) {subtext = note.Results[1].Alternatives[0].Transcript;if (0 < subtext.Length) {speechtxt += subtext;}}// 前回の発言内容を除去try {if (10 < lstLastspeaktext.Count) lstLastspeaktext.Clear();foreach (var tmpStr in lstLastspeaktext) {speechtxt = speechtxt.Replace(tmpStr, "");}} catch (Exception w_e4) {FuncWriteLogFile(w_e4.ToString());}},,,// ループバックの場合MMDevice outdevice = null;// 既定の出力をキャプチャ、出力サウンドデバイスは別の場所で別途設定outdevice = new MMDeviceEnumerator().GetDefaultAudioEndpoint(DataFlow.Render, Role.Multimedia); // 既定の出力_ms_wloop = new WasapiLoopbackCapture(outdevice);//_ms_wloop = new WasapiLoopbackCapture(new MMDeviceEnumerator().GetDevice(MainWindow.MMDoutputDevice));//WaveFormat format = new WaveFormat(8000, 16, 1);//_ms_writer = new WaveFileWriter(Environment.CurrentDirectory + "\\kikisen-vc.wav", format);_ms_wloop.DataAvailable += _ms_wi_DataAvailable;_ms_wloop.ShareMode = AudioClientShareMode.Shared;_ms_wloop_ss = new SpeechStreamer(100000);,,,*timer = new System.Timers.Timer(13800);
Bing Speech API1回14秒までなので、14秒まできたら打ち切る

*try {speechtxt = speechtxt.Substring(lastspeaktext.Length, speechtxt.Length - lastspeaktext.Length);} catch (Exception w_e4) {speechtxt = speechtxt.Replace(lastspeaktext, "");FuncWriteLogFile(w_e4.ToString());}speechtxt = Regex.Replace(speechtxt, @"\s", "");},,,var speechtxt = outtext;if (0.8 < note.Results[0].Stability) {if (0 < lastspeaktext.Length) {}var subtext = "";if (1 < note.Results.Count) {subtext = note.Results[1].Alternatives[0].Transcript;if (0 < subtext.Length) {speechtxt += subtext;}}// 前回の発言内容を除去try {if (10 < lstLastspeaktext.Count) lstLastspeaktext.Clear();foreach (var tmpStr in lstLastspeaktext) {speechtxt = speechtxt.Replace(tmpStr, "");}} catch (Exception w_e4) {FuncWriteLogFile(w_e4.ToString());}},,,// ループバックの場合MMDevice outdevice = null;// 既定の出力をキャプチャ、出力サウンドデバイスは別の場所で別途設定outdevice = new MMDeviceEnumerator().GetDefaultAudioEndpoint(DataFlow.Render, Role.Multimedia); // 既定の出力_ms_wloop = new WasapiLoopbackCapture(outdevice);//_ms_wloop = new WasapiLoopbackCapture(new MMDeviceEnumerator().GetDevice(MainWindow.MMDoutputDevice));//WaveFormat format = new WaveFormat(8000, 16, 1);//_ms_writer = new WaveFileWriter(Environment.CurrentDirectory + "\\kikisen-vc.wav", format);_ms_wloop.DataAvailable += _ms_wi_DataAvailable;_ms_wloop.ShareMode = AudioClientShareMode.Shared;_ms_wloop_ss = new SpeechStreamer(100000);,,,*try {if (10 < lstLastspeaktext.Count) lstLastspeaktext.Clear();foreach (var tmpStr in lstLastspeaktext) {speechtxt = speechtxt.Replace(tmpStr, "");}} catch (Exception w_e4) {FuncWriteLogFile(w_e4.ToString());}},,,// ループバックの場合MMDevice outdevice = null;// 既定の出力をキャプチャ、出力サウンドデバイスは別の場所で別途設定outdevice = new MMDeviceEnumerator().GetDefaultAudioEndpoint(DataFlow.Render, Role.Multimedia); // 既定の出力_ms_wloop = new WasapiLoopbackCapture(outdevice);//_ms_wloop = new WasapiLoopbackCapture(new MMDeviceEnumerator().GetDevice(MainWindow.MMDoutputDevice));//WaveFormat format = new WaveFormat(8000, 16, 1);//_ms_writer = new WaveFileWriter(Environment.CurrentDirectory + "\\kikisen-vc.wav", format);_ms_wloop.DataAvailable += _ms_wi_DataAvailable;_ms_wloop.ShareMode = AudioClientShareMode.Shared;_ms_wloop_ss = new SpeechStreamer(100000);,,,*MMDevice outdevice = null;
ループバックの場合

*_ms_wloop = new WasapiLoopbackCapture(outdevice);
既定の出力をキャプチャ、出力サウンドデバイスは別の場所で別途設定
outdevice = new MMDeviceEnumerator().GetDefaultAudioEndpoint(DataFlow.Render, Role.Multimedia);  既定の出力

*//WaveFormat format = new WaveFormat(8000, 16, 1);*//_ms_writer = new WaveFileWriter(Environment.CurrentDirectory + "\\kikisen-vc.wav", format);
_ms_wloop = new WasapiLoopbackCapture(new MMDeviceEnumerator().GetDevice(MainWindow.MMDoutputDevice));

*//_ms_writer = new WaveFileWriter(Environment.CurrentDirectory + "\\kikisen-vc.wav", format);*_ms_wloop.DataAvailable += _ms_wi_DataAvailable;
WaveFormat format = new WaveFormat(8000, 16, 1);


*Console.WriteLine(node["A"]["B"]["C"].Exists);
false


*gc.ClearScreen();
画面を白で塗りつぶします

*gc.DrawImage(0, 0, 0);
0番の画像を描画します


*} while (i != -1);
使用できる文字がない場合は「-1」が返る


*var container = new Container();
まずコンテナインスタンスの作成

*container.For<IService1>().As<Service1>(Lifecycle.Singleton);
シングルトンインスタンスの登録
インターフェイス - 実体の型を登録

*container.For<IService2>().As(service2);
インスタンスを登録

*container.For<IService3>().As(() => new Service3(), Lifecycle.Singleton);*container.For<IService4>().As((IService3 service3) => new Service4(service5), Lifecycle.Singleton);
ラムダ式で登録

*container.For<IService6>().As<Service6>(Lifecycle.Transient);
都度生成の場合
インターフェイス - 実体の型を登録

*container.For<IService7>().As(() => new Service7(), Lifecycle.Transient);*container.For<IService8>().As((IService7 service7) => new Service8(service7), Lifecycle.Transient);
ラムダ式で登録

*container.For<IService9>().As<Service6>(Lifecycle.ThreadLocal);
スレッド単位生成の場合
インターフェイス - 実体の型を登録

*container.For<IService10>().As(() => new Service10(), Lifecycle.ThreadLocal);*container.For<IService11>().As((IService10 service10) => new Service11(service10), Lifecycle.ThreadLocal);
ラムダ式で登録

*container.GetInstance<IService1>();
通常通り生成

*container.GetInstance<Func<IService6>>();
生成するデリゲートを出力

*container.GetInstance<Lazy<IService7>>();
遅延生成


*https:
stackoverflow.comquestions25619169deploying-32-bit-access-system-to-64-bit-office-machine


*//if (!string.IsNullOrWhiteSpace(data.ToString())) properties[i].SetValue(person, data);*}
これでもOK


*+ Camera.main.transform.forward * 100 * n;
カメラから距離を取ってカメラと被らないようにさせているだけ


*int money;
変数の宣言

*public override void UpdateGame()*{//タップした時の処理if (gc.GetPointerFrameCount(0)==1 && ! isComplete) {money -= 100;if (gc.Random(0,3)==0){new_card = gc.Random(0,4);}else{new_card = gc.Random(5,9);}card_count[new_card]++;for (int i = 0; i < 5; i++) {if (card_count[i] > 4){isComplete = true;}}}//長押しした時の処理if(gc.GetPointerFrameCount(0) >= 120){resetValue();}}
１フレームごとに呼ばれる・動きの処理を入れる

*public override void DrawGame()*{gc.ClearScreen();gc.SetColor(255,0,0);gc.SetFontSize(36);gc.DrawString("money:"+money,60, 40);if(new_card >= 0){gc.DrawString("new:"+card_name[new_card],60, 80);}for(int i=0 ; i< CARD_TYPE ; i++){gc.DrawString(card_name[i] + ":" + card_count[i],60, 120+i*80);}if(isComplete ){gc.DrawString("complete!!",60, 920);}}
１フレームごとに呼ばれる・描画の処理


*string plainText = "Hello, World!";*Console.WriteLine("PlainText : {0}\n", plainText);
平文の文字列

*string cipher = Encrypt(plainText, AES_IV, AES_Key);*Console.WriteLine("Cipher : {0}\n" ,cipher);
暗号化された文字列

*string plainText = "Hello, world!";
平文の文字列

*string encrypted, decrypted;
暗号化、復号された文字列

*string publicKey, privateKey;
公開鍵と秘密鍵

*publicKey = rsa.ToXmlString(false);
公開鍵、秘密鍵をXML形式で取得する


*var url = "https:
www.google.commaps?q=" + latitude.ToString() + "," + longitude.ToString();


*return;
error

*public class Person*{public bool Checked { get; set; }public string Name { get; set; }public string Race { get; set; }private string codename;public string Codename {get { return codename; }set { codename = value.ToUpper(); }}}
Name, Race, Codename


*using System.Collections;
参考
http:nn-hokuson.hatenablog.com/entry/2016/12/08/200133

*void Start () {Texture2D mainTexture = (Texture2D)GetComponent<Renderer>().material.mainTexture;Color[] pixels = mainTexture.GetPixels();buffer = new Color[pixels.Length];pixels.CopyTo(buffer, 0);drawTexture = new Texture2D(mainTexture.width, mainTexture.height, TextureFormat.RGBA32, false);drawTexture.filterMode = FilterMode.Point;}
Use this for initialization

*public void Draw(Vector2 p)*{//buffer.SetValue(Color.black, (int)p.x + 256 * (int)p.y);//太字for (int x = 0; x < 256; x++){for (int y = 0; y < 256; y++){if ((p - new Vector2(x, y)).magnitude < 5){buffer.SetValue(Color.black, x + 256 * y);}}}}
ブラシの太さを変える

*void Update () {if (Input.GetMouseButton(0)){Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);RaycastHit hit;if (Physics.Raycast(ray, out hit, 100.0f)){Draw(hit.textureCoord * 256);}drawTexture.SetPixels(buffer);drawTexture.Apply();GetComponent<Renderer>().material.mainTexture = drawTexture;}}
毎フレーム、テクスチャ上のすべてのピクセルをチェックして、マウスが乗っている座標からの距離が8以下なら黒く塗りつぶします。

*public void SaveTexture()*{byte[] data = drawTexture.EncodeToJPG();File.WriteAllBytes(Application.dataPath + "/saveImage.jpg", data);}
テクスチャをjpgとして保存

*static TFTensor CreateTensorFromImageFile(string file)*{var contents = File.ReadAllBytes(file);// DecodeJpeg uses a scalar String-valued tensor as input.var tensor = TFTensor.CreateString(contents);TFGraph graph;TFOutput input, output;// Construct a graph to normalize the imageConstructGraphToNormalizeImage(out graph, out input, out output);// Execute that graph to normalize this one imageusing (var session = new TFSession(graph)){var normalized = session.Run(inputs: new[] { input },inputValues: new[] { tensor },outputs: new[] { output });return normalized[0];}}
Convert the image in filename to a Tensor suitable as input to the Inception model.

*using (var session = new TFSession(graph)){var normalized = session.Run(inputs: new[] { input },inputValues: new[] { tensor },outputs: new[] { output });
Execute that graph to normalize this one image

*static void ConstructGraphToNormalizeImage(out TFGraph graph, out TFOutput input, out TFOutput output)
開始モデルは、非常に特定の正規化されたフォーマット（特定の画像サイズ、入力テンソルの形状、正規化されたピクセル値など）
でテンソルによって記述された画像を入力として取ります。
このファンクションは、入力としてJPEGでエンコードされた文字列を取り込み、
入力モデルとしての入力として適したテンソルを戻すTensorFlow操作のグラフを作成します。

*const int W = 28;
- モデルは28x28ピクセルにスケーリングされた画像で訓練されました。
- モノクロなので表される色は1色のみ。（値 - 平均）/ スケールを使用してfloatに変換して使用する。
画素値を0-255 から 0-1 の範囲にするので、変換値 = (Mean　- 画素値) / Scale の式から,
Mean = 255, Scale = 255 となる。

*public void MNSIT_read_model()*{var graph = new TFGraph();//var model = File.ReadAllBytes("tensorflow_inception_graph.pb");// シリアル化されたGraphDefをファイルからロードします。var model = File.ReadAllBytes(Application.dataPath + "/models/Auto_model.pb");graph.Import(model, "");using (var session = new TFSession(graph)){var labels = File.ReadAllLines(Application.dataPath + "/models/labels.txt");var file = Application.dataPath + "/saveImage.jpg";//画像ファイルに対して推論を実行する//複数のイメージの場合、session.Run（）はループで（同時に）呼び出すことができます。//あるいは、モデルが画像データのバッチを入力として受け入れるので、画像をバッチ処理することができる。var tensor = CreateTensorFromImageFile(file);var runner = session.GetRunner();// 学習モデルのグラフを指定する。// 入出力テンソルの名前をsessionに登録する// 手動で変換したモデルの読込のときは、.AddInput(graph["dropout"][0], 0.5f)はいらない。runner.AddInput(graph["input"][0], tensor).AddInput(graph["dropout"][0], 0.5f).Fetch(graph["output"][0]);var output = runner.Run();// output[0].Value（）は、「バッチ」内の各画像のラベルの確率を含むベクトルです。 バッチサイズは1であった。//最も可能性の高いラベルインデックスを見つけます。var result = output[0];var rshape = result.Shape;if (result.NumDims != 2 || rshape[0] != 1){var shape = "";foreach (var d in rshape){shape += $"{d} ";}shape = shape.Trim();Debug.Log($"Error: expected to produce a [1 N] shaped tensor where N is the number of labels, instead it produced one with shape [{shape}]");Environment.Exit(1);}var bestIdx = 0;float best = 0;// 尤も確率が高いものを調べて表示するvar probabilities = ((float[][])result.GetValue(true))[0];for (int i = 0; i < probabilities.Length; i++){if (probabilities[i] > best){bestIdx = i;best = probabilities[i];}}Debug.Log($"{file} best match: [{bestIdx}] {best * 100.0}% {labels[bestIdx]}");}}
pythonで作成したモデルの読込を行う

*var model = File.ReadAllBytes(Application.dataPath + "/models/Auto_model.pb");
シリアル化されたGraphDefをファイルからロードします。

*var tensor = CreateTensorFromImageFile(file);
画像ファイルに対して推論を実行する
複数のイメージの場合、session.Run（）はループで（同時に）呼び出すことができます。
あるいは、モデルが画像データのバッチを入力として受け入れるので、画像をバッチ処理することができる。

*runner.AddInput(graph["input"][0], tensor).AddInput(graph["dropout"][0], 0.5f).Fetch(graph["output"][0]);
学習モデルのグラフを指定する。
入出力テンソルの名前をsessionに登録する
手動で変換したモデルの読込のときは、.AddInput(graph["dropout"][0], 0.5f)はいらない。

*var result = output[0];
output[0].Value（）は、「バッチ」内の各画像のラベルの確率を含むベクトルです。 バッチサイズは1であった。
最も可能性の高いラベルインデックスを見つけます。

*var probabilities = ((float[][])result.GetValue(true))[0];
尤も確率が高いものを調べて表示する


*}
エラー発生時の処理


*int sec = 0;
変数の宣言

*gc.SetResolution(720, 1280);
キャンバスの大きさを設定します

*sec = (int)gc.TimeSinceStartup;
起動からの経過時間を取得します

*gc.ClearScreen();
画面を白で塗りつぶします

*gc.DrawImage(0, 0, 0);
0番の画像を描画します

*gc.SetColor(0, 0, 0);
黒の文字を描画します


*public Dto GetDto()*{try{// ファイルから読み込んだ情報をDtoに変換する。// (コードは省略)return new Dto();}catch (Exception e){// ファイルフォーマットエラーしか発生しないので、// エラーログを呼び出し元で出力する。return null;}}
パターン1,2

*return new Dto();
ファイルから読み込んだ情報をDtoに変換する。
(コードは省略)

*return null;
ファイルフォーマットエラーしか発生しないので、
エラーログを呼び出し元で出力する。

*public void Update()*{try{// テーブルのレコード更新// (コードは省略)}catch (Exception e){// ロールバック。// (コードは省略)throw e;}}
パターン3

*}
テーブルのレコード更新
(コードは省略)

*throw e;
ロールバック。
(コードは省略)

*public Dto GetDto1()*{// ファイルから読み込んだ情報をDtoに変換する。// (コードは省略)// 想定外例外は外側の共通例外処理でキャッチされる。return new Dto();}
パターン1

*return new Dto();
ファイルから読み込んだ情報をDtoに変換する。
(コードは省略)
想定外例外は外側の共通例外処理でキャッチされる。

*public ReadResult GetDto2()*{// ファイルのフォーマットチェックif (HasFormatError()){return new ReadResult(){HasFormatError = true,Dto = null};}else{// ファイルから読み込んだ情報をDtoに変換する。// (コードは省略)// 想定外例外は外側の共通例外処理でキャッチされる。return new ReadResult(){HasFormatError = false,Dto = new Dto()};}}
パターン2

*return new ReadResult()
ファイルから読み込んだ情報をDtoに変換する。
(コードは省略)
想定外例外は外側の共通例外処理でキャッチされる。

*public void Update()*{try{// テーブルのレコード更新// (コードは省略)}catch (Exception e){// ロールバック。// (コードは省略)// 再スローする場合、eを書いてはいけない。throw;}}
パターン3

*}
テーブルのレコード更新
(コードは省略)

*throw;
ロールバック。
(コードは省略)
再スローする場合、eを書いてはいけない。

*return true;
ファイルフォーマットチェック
コードは省略

*public class ReadResult*{public bool HasFormatError;public Dto Dto { get; set; }}
ファイル読み込み結果


*,,,*var digits = int[] { 2, 3, 4, 8, 9, 0, 3, 2 };
result => [2, 3, 4, 8, 9, 0, 3, 2]


*var perm = source.Perm(2);
k = 2

*var source = new int[] { 1, 2, 3 };
C(n=3, r=2)の例


*builder.RegisterModule(module);
設定ファイルによるコンポーネントの構築


*foreach (AnimatorStateTransition transition in state.transitions)
トランジション


*int result = palyer_hand - pc_hand;
(1) 基となる差を求める。

*result %= 3;
(2) 除数であまりを求め、±除数の範囲に収める。

*result += 3;
(3) 除数を1回加えることでプラス化。

*result %= 3;
(4) 再度除数であまりを求め、+除数の範囲に収める。

*System.Console.WriteLine("Hellow C#");*foreach(string player_hand in new string[]{"グー", "チョキ", "パー"}) {
Your code here!


*exitTransitionC2.AddCondition(UnityEditor.Animations.AnimatorConditionMode.If, 0, "TransitionNow");
条件にトリガーを追加する。


*static TFTensor CreateTensorFromImageFile(string file)*{var contents = File.ReadAllBytes(file);// DecodeJpeg uses a scalar String-valued tensor as input.var tensor = TFTensor.CreateString(contents);TFGraph graph;TFOutput input, output;// Construct a graph to normalize the imageConstructGraphToNormalizeImage(out graph, out input, out output);// Execute that graph to normalize this one imageusing (var session = new TFSession(graph)){var normalized = session.Run(inputs: new[] { input },inputValues: new[] { tensor },outputs: new[] { output });return normalized[0];}}
Convert the image in filename to a Tensor suitable as input to the Inception model.

*using (var session = new TFSession(graph)){var normalized = session.Run(inputs: new[] { input },inputValues: new[] { tensor },outputs: new[] { output });
Execute that graph to normalize this one image

*static void ConstructGraphToNormalizeImage(out TFGraph graph, out TFOutput input, out TFOutput output)
開始モデルは、非常に特定の正規化されたフォーマット（特定の画像サイズ、入力テンソルの形状、正規化されたピクセル値など）
でテンソルによって記述された画像を入力として取ります。
このファンクションは、入力としてJPEGでエンコードされた文字列を取り込み、
入力モデルとしての入力として適したテンソルを戻すTensorFlow操作のグラフを作成します。

*const int W = 28;
- モデルは28x28ピクセルにスケーリングされた画像で訓練されました。
- モノクロなので表される色は1色のみ。（値 - 平均）/ スケールを使用してfloatに変換して使用する。
画素値を0-255 から 0-1 の範囲にするので、変換値 = (Mean　- 画素値) / Scale の式から,
Mean = 255, Scale = 255 となる。

*void MNSIT_read_model()*{var graph = new TFGraph();//var model = File.ReadAllBytes("tensorflow_inception_graph.pb");// シリアル化されたGraphDefをファイルからロードします。var model = File.ReadAllBytes("Manual_model.pb");graph.Import(model, "");using (var session = new TFSession(graph)){var labels = File.ReadAllLines("labels.txt");var file = "temp.jpg";//画像ファイルに対して推論を実行する//複数のイメージの場合、session.Run（）はループで（同時に）呼び出すことができます。//あるいは、モデルが画像データのバッチを入力として受け入れるので、画像をバッチ処理することができる。var tensor = CreateTensorFromImageFile(file);var runner = session.GetRunner();// 学習モデルのグラフを指定する。// 入出力テンソルの名前をsessionに登録する// 手動で変換したモデルの読込のときは、.AddInput(graph["dropout"][0], 0.5f)はいらない。runner.AddInput(graph["input"][0], tensor).Fetch(graph["output"][0]);var output = runner.Run();// output[0].Value（）は、「バッチ」内の各画像のラベルの確率を含むベクトルです。 バッチサイズは1であった。//最も可能性の高いラベルインデックスを見つけます。var result = output[0];var rshape = result.Shape;if (result.NumDims != 2 || rshape[0] != 1){var shape = "";foreach (var d in rshape){shape += $"{d} ";}shape = shape.Trim();Console.WriteLine($"Error: expected to produce a [1 N] shaped tensor where N is the number of labels, instead it produced one with shape [{shape}]");Environment.Exit(1);}var bestIdx = 0;float best = 0;// 尤も確率が高いものを調べて表示するvar probabilities = ((float[][])result.GetValue(true))[0];for (int i = 0; i < probabilities.Length; i++){Console.WriteLine(probabilities[i]);if (probabilities[i] > best){bestIdx = i;best = probabilities[i];}}Console.WriteLine($"{file} best match: [{bestIdx}] {best * 100.0}% {labels[bestIdx]}");}}
pythonで作成したモデルの読込を行う

*var model = File.ReadAllBytes("Manual_model.pb");
シリアル化されたGraphDefをファイルからロードします。

*var tensor = CreateTensorFromImageFile(file);
画像ファイルに対して推論を実行する
複数のイメージの場合、session.Run（）はループで（同時に）呼び出すことができます。
あるいは、モデルが画像データのバッチを入力として受け入れるので、画像をバッチ処理することができる。

*runner.AddInput(graph["input"][0], tensor).Fetch(graph["output"][0]);
学習モデルのグラフを指定する。
入出力テンソルの名前をsessionに登録する
手動で変換したモデルの読込のときは、.AddInput(graph["dropout"][0], 0.5f)はいらない。

*var result = output[0];
output[0].Value（）は、「バッチ」内の各画像のラベルの確率を含むベクトルです。 バッチサイズは1であった。
最も可能性の高いラベルインデックスを見つけます。

*var probabilities = ((float[][])result.GetValue(true))[0];
尤も確率が高いものを調べて表示する


*hoge?.Piyo();
nullチェック込みで簡潔に書ける

*var list = new List<string>();
これはコンパイルエラー
hoge?.Fuga = "ほげほげ";
nullじゃない場合に、何かのメソッドの引数として実行したい。

*,,,
構文的にあてはまるものがない...
list.Add(str?);

*hoge?.Invoke(h => h.Fuga = "ほげほげ");
例えば上の方で書いた例だと
nullじゃない場合に代入（ちょっと冗長。。）

*str?.Invoke(list.Add);
nullじゃない場合にメソッド呼び出し

*int? ni = GetNullableInteger();
nullable型も、Valueの取り出しが自然に行えます。


*myPlotModel.InvalidatePlot(true);
-- (3) , ここで軸設定が反映され、PlotViewが更新される


*if ( textLength < 0 ) { return 0; }
overflow


*KeyBindPropertyChanged));
KeyBindingが指定された時に呼ばれるコールバック

*menuItemKB.Command = kb.Command;
KeyBindingに結び付けられたコマンドをこのMenuItemのCommandに反映

*menuItemKB.InputGestureText = (kb.Gesture as KeyGesture).GetDisplayStringForCulture(CultureInfo.CurrentCulture);
KeyBindingのローカライズされた文字列("Ctrl"など)をこのMenuItemのInputGestureTextに反映


*var unused = withRepetition ? items : items.SkipWhile(e => !e.Equals(item)).Skip(1).ToList();
item よりも前のものを除く （順列と組み合わせの違い)
重複を許さないので、unusedから item そのものも取り除く


*this.StartStopButtonText.Value = "Stop";
初期化

*var res = await Task.Run(async () =>*{foreach (var item in StreamCreater.Create(inputPattern, finishedPattern)){if (cancellationTokenSource.IsCancellationRequested) return false;this.ResultText.Value += item + ',';this.StreamCount.Value++;await Task.Delay(1);}this.ResultText.Value += output;this.IsStarted.Value = false;return true;}, this.cancellationTokenSource.Token);
Streamを非同期で生成


*DebugUtil.ListDump("ほげ","ふが");
OK


*string postUrl = "https:
****.****.com****upload";


*int i = 1;
ボックス化

*int j = (int)o;
ボックス化解除


*var t = dict["test"];
↑で作ったばかりなので入ってるはずもなく、KeyNotFoundException

*,,,
var t = dict["test"];↑で作ったばかりなので入ってるはずもなく、KeyNotFoundException
var t = dict.GetOrDefault("test");  default値を指定しない場合はdefault(KV),KV=stringなので、stringのデフォ値のnullがtに入る
var t2 = dict.GetOrDefault("test2","入ってなかったよ");  default値を明示的に指定した場合は、keyが存在しない場合にそれが使用される。


*if (t <= 0) {
Java版はt==0で脱出、C#版はt==-1で脱出

*++I;
空白・改行のときここに来る。空白・改行とも 0 < t < '0' の範囲内にある


*// Use Activity.MembersAdded and Activity.MembersRemoved and Activity.Action for info*// Not available in all channels
Handle conversation state changes, like members being added and removed

*await context.PostAsync($"You sent {activity.Text} which was {length} characters");
return our reply to the user

*//await context.PostAsync($"You sent {activity.Text} which was {length} characters");
return our reply to the user

*string message = $"You sent {activity.Text} which was {length} characters";
await context.PostAsync($"You sent {activity.Text} which was {length} characters");


*public TestContext TestContext { get; set; }
必須


*void Start () {InputManager.Instance.PushFallbackInputHandler(gameObject);}
Use this for initialization

*void Update () {if (isDrag){Vector3 pos;currentInputSource.TryGetPosition(id, out pos);Debug.Log(pos);obj.transform.position = pos;}}
Update is called once per frame

*void Start () {InputManager.Instance.PushFallbackInputHandler(gameObject);}
Use this for initialization

*void Update () {if (isDrag){Vector3 pos;currentInputSource.TryGetPosition(id, out pos);Debug.Log(pos);obj.transform.position = pos;}}
Update is called once per frame


*int cnt = 0;
変数である必要は無い（Qiitaでのコメントを頂いた事で発覚）


*public Vector3 targetPoint;
注視点

*void Update () {float mouseX = Input.GetAxis("Mouse X");float mouseY = Input.GetAxis("Mouse Y");float mouseWheelScroll = Input.GetAxis("Mouse ScrollWheel");// 平行移動if (Input.GetMouseButton(2)){targetPoint += transform.right * mouseX * translateSpeed;targetPoint += transform.up * mouseY * translateSpeed;this.transform.Translate(mouseX * translateSpeed, mouseY * translateSpeed, 0);}// 回転if (Input.GetMouseButton(1)){float dist = Vector3.Distance(this.transform.position, targetPoint);this.transform.rotation = Quaternion.AngleAxis(rotateSpeed * -mouseY, transform.right) * transform.rotation;this.transform.rotation = Quaternion.AngleAxis(rotateSpeed * mouseX, Vector3.up) * transform.rotation;targetPoint = this.transform.position + this.transform.forward * dist;}// ズームif(mouseWheelScroll != 0){this.transform.Translate(Vector3.forward * mouseWheelScroll * zoomSpeed);float dist = Vector3.Distance(this.transform.position, targetPoint);if(dist <= 1f){targetPoint = this.transform.position + this.transform.forward * 1f;}}// 注視点の周りを回るif (Input.GetMouseButton(0) && (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))){this.transform.RotateAround(targetPoint, transform.right, -mouseY * rotateSpeed);this.transform.RotateAround(targetPoint, Vector3.up, mouseX * rotateSpeed);}}
Update is called once per frame


*var rank = playerRankingQuery.Count;
自分のスコアのランク（-1）取得

*dispRank = Mathf.Max(0, rank - 2);
TOP5同様、降順＋Limit5 に加え、自分のRank-2をSkipすることで、自分のスコアの2つ上のユーザーから取得


*}
処理なし


*{
処理なし }

*await proxy.HogeHoge();
起動時にに呼び出すActorのメソッドをコール


*case XPaths.Post_CommentCOunt: return @"
*[@id=""main""]articlediv[1]div[2]divdiv[2]divulli[2]div[1]text()";


*client = new EmotionServiceClient("{your subscription key}");
クライアント

*var datafile = await KnownFolders.PicturesLibrary.GetFileAsync("emotion.jpg");
ファイル呼び出し

*var emotions = await client.RecognizeAsync(fileStream.AsStream());
APIの呼び出し

*var task = Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, () =>*{canvas.Children.Clear();if (emotions != null){foreach (var emotion in emotions){var ranked = emotion.Scores.ToRankedList();resultTbox.Text = "";Color color = Colors.Transparent;foreach(var rank in ranked){switch (rank.Key){case "Anger":resultTbox.Text = resultTbox.Text + "怒り : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Red;}break;case "Contempt":resultTbox.Text = resultTbox.Text + "軽蔑 : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.White;}break;case "Disgust":resultTbox.Text = resultTbox.Text + "嫌悪 : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Purple;}break;case "Fear":resultTbox.Text = resultTbox.Text + "恐怖 : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Black;}break;case "Happiness":resultTbox.Text = resultTbox.Text + "喜び : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Pink;}break;case "Neutral":resultTbox.Text = resultTbox.Text + "中立 : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Green;}break;case "Sadness":resultTbox.Text = resultTbox.Text + "悲しみ : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Blue;}break;case "Surprise":resultTbox.Text = resultTbox.Text + "驚き : " + rank.Value.ToString("F4") + "\n";if (color == Colors.Transparent){color = Colors.Yellow;}break;}}var faceRect = emotion.FaceRectangle;Windows.UI.Xaml.Shapes.Rectangle rect = new Windows.UI.Xaml.Shapes.Rectangle{Height = faceRect.Height,Width = faceRect.Width,Stroke = new SolidColorBrush(color),StrokeThickness = 2};canvas.Children.Add(rect);Canvas.SetLeft(rect, faceRect.Left);Canvas.SetTop(rect, faceRect.Top);}}});
結果を表示


*lastGetTime = (long)query.Result.First()["createTime"];
createTimeの新しい順に並んでいるので、先頭(First)のcreateTimeを保持しておく。


*static ~TestClass()
← staticなデストラクタはコンパイルエラーになる

*OuterLib.Initialize();
外部ライブラリの初期化

*OuterLib.Finalize();
メインの処理
外部ライブラリの終了処理

*OuterLib.Finalize();
ここに終了処理を記述！！！


*}
COMを使った処理

*}
COMを使った処理


*yield return so.SaveAsync();
こちらは新規登録処理


*client = new VisionServiceClient("{your subscription key}", "https:
southeastasia.api.cognitive.microsoft.comvisionv1.0");

*var datafile = await KnownFolders.PicturesLibrary.GetFileAsync("cvpict.jpg");
ファイル呼び出し

*var visuals = new VisualFeature[] {VisualFeature.Adult,VisualFeature.Categories,VisualFeature.Color,VisualFeature.Description,VisualFeature.Faces,VisualFeature.ImageType,VisualFeature.Tags};
取得する項目の設定

*var response = await client.AnalyzeImageAsync(fileStream.AsStream(), visuals);
APIの呼び出し

*var task = Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, () =>*{canvas.Children.Clear();resultTbox.Text = "説明:\n" + captions[0].Text + "\n\n";var i = 0;Windows.UI.Color color;foreach (var face in faces){resultTbox.Text = resultTbox.Text + "Face No." + (i + 1).ToString() + "\n";resultTbox.Text = resultTbox.Text + "年齢:\n" + face.Age.ToString() + "\n";resultTbox.Text = resultTbox.Text + "性別:\n" + face.Gender.ToString() + "\n";if (face.Gender == "Male"){color = Windows.UI.Colors.Blue;}else{color = Windows.UI.Colors.Red;}Windows.UI.Xaml.Shapes.Rectangle rect = new Windows.UI.Xaml.Shapes.Rectangle{Height = face.FaceRectangle.Height,Width = face.FaceRectangle.Width,Stroke = new Windows.UI.Xaml.Media.SolidColorBrush(color),StrokeThickness = 2};canvas.Children.Add(rect);Canvas.SetLeft(rect, face.FaceRectangle.Left);Canvas.SetTop(rect, face.FaceRectangle.Top);i++;}});
結果を表示


*this.顧客リストTableAdapter.Fill(this.kintoneDataSet.顧客リスト);
TODO: このコード行はデータを 'kintoneDataSet.顧客リスト' テーブルに読み込みます。必要に応じて移動、または削除をしてください。

*this.contactTableAdapter.Fill(this.salesforceDataSet.Contact);*,,,
TODO: このコード行はデータを 'salesforceDataSet.Contact' テーブルに読み込みます。必要に応じて移動、または削除をしてください。


*this.recipientsTableAdapter.Fill(this.sendGridDataSet.Recipients);
TODO: このコード行はデータを 'sendGridDataSet.Recipients' テーブルに読み込みます。必要に応じて移動、または削除をしてください。

*this.contactTableAdapter.Fill(this.salesforceDataSet.Contact);*,,,
TODO: このコード行はデータを 'salesforceDataSet.Contact' テーブルに読み込みます。必要に応じて移動、または削除をしてください。

*Invoke(new Action(() =>*{this.btImport.Enabled = true;this.Text = "完了";}));
エラー処理は省略


*private IEnumerable<byte> ConvertBytes(short[] sampleData)*{foreach (var s in sampleData){var bytes = BitConverter.GetBytes(s);yield return bytes[0];yield return bytes[1];}}
http:opensource.org/licenses/mit-license.php

*rivate void OnTextMessage(object sender,MessageWebSocketMessageReceivedEventArgs messageWebSocketMessageReceivedEventArgs)
http:opensource.org/licenses/mit-license.php

*}
ここでUnity側に値を表示するロジックを実装する。

*private void OnVoiceMessage(object sender,MessageWebSocketMessageReceivedEventArgs messageWebSocketMessageReceivedEventArgs)
http:opensource.org/licenses/mit-license.php


*void Start()*{}
Use this for initialization

*void Update()*{if (Input.GetMouseButtonDown(0)){Vector3 position = Input.mousePosition;iTween.MoveTo(player.gameObject, iTween.Hash("x", playerTapPoint.x, "y", playerTapPoint.y, "time", 10.0f));}}
Update is called once per frame


*generateType = Constant.Dungeon.BlockType.RoomFloor;
部屋の床としておくことで、普通の床と区別します.

*break;
壁オブジェクトを生成.

*break;
床オブジェクトを生成.


*var hoge = GetHoge();
どこかから対象オブジェクトを取得

*var oldValue = hoge.Fuga;
変更前の値を保持

*var newValue = "new";
これから変更する値。

*var command = new UndoCommand(() => hoge.Fuga = oldValue, () => hoge.Fuga = new Vlaue);
Redo/Undo用のオブジェクトを生成

*command.Redo();
適用

*command.Undo();
元に戻す

*command.Redo();
再適用


*var a = new { x = 1, y = "a" };
匿名型

*var vt2 = (x, y);
ValueTupleでは名前がつかない

*var vt2_ = (x:x, y:y);
名前を付けるためは、ちゃんと名前を書かないとダメ

*var a2 = new { x, y };
匿名型では名前がつく

*(int x, string y) vt3 = (1, "ccc");
明示的に名前付きのValueTupleとしても宣言可能

*public Tuple<int, string> GetTuple(Tuple<int, string> t) => t;
Tupleは引数・戻値に利用できます。

*public (int, string) GetValueTuple((int, string) vt) => vt;
ValueTupleも、引数にも、戻り値にも利用可能です。

*public (int x, string y) GetValueTuple2((int i, string s) vt) => vt;
もちろん名前を付けることも

*(int, string) vt = null;
structなので、null初期化できない
Null 非許容の値型であるため、Null を '(int, string)' に変換できません

*Tuple<int, string> t = null;
classなのでnull初期化可能

*Add(ref t.Item1);
プロパティまたはインデクサーを out か ref のパラメーターとして渡すことはできません。

*var vt = (1, "a");
割り当て可能

*var t = Tuple.Create(1, "a");
プロパティまたはインデクサー 'Tuple<int, string>.Item1' は読み取り専用であるため、割り当てることはできません

*var a = new { Item1 = 1, Item2 = "a" };
プロパティまたはインデクサー '<anonymous type: int Item1, string Item2>.Item1' は読み取り専用であるため、割り当てることはできません

*tuple.i = 2;
'tuple' のメンバーは 'foreach 繰り返し変数' であるため変更できません


*public static void Deconstruct(this System.Windows.Point p, out double x, out double y)*{x = p.X;y = p.Y;}
例えば、Pointに対する拡張メソッドを定義しておくと

*var (x, y) = new System.Windows.Point(2, 3);*Console.WriteLine($"{x}:{y}");
分割代入ができるようになります。


*var a = f(10);
匿名型を返す


*Debug.Log("TimeOut");
タイムアウト

*break;
タイムアウト処理




*public void Set()*{activate = true;}
開始時に呼ぶ

*public void Emit()*{if (activate){Timer += Time.deltaTime;for(int i = 0;i < list.Count; i++){if (list[i].Time < Timer){GameObject obj = (GameObject)Instantiate(list[i].Prefab, list[i].Pos, Quaternion.Euler(list[i].Rot));obj.transform.parent = transform;list.Remove(list[i]);}}}}
出現させたい間呼ぶ

*public class EmitPrefabAttribute : PropertyAttribute { }
ReorderableListの作成


*string actionName;
動的に変更したいログインページのアクション


*var rawObject = Unpacking.UnpackObject(objectProvider.GetData());
Dictionary<string, ocbect>[]へのデシリアライズ


*}
Disposeメソッドは書かれていないが、最後にfile.Disaposeが呼ばれる


*return false;
何かrequest.Urlを見たりして処理する


*static SingletonClass() {}
suppress beforefieldinit


*var jarRoot = @"..\..\stanford-corenlp-3.7.0-models";*// Annotation pipeline configuration
Path to the folder with models extracted from `stanford-corenlp-3.7.0-models.jar`

*var Index = new CoreAnnotations.IndexAnnotation().getClass();
Indexは1からスタート

*var text = "Kosgi Santosh sent an email to Stanford University. He didn't get a reply.";*var result = NLP.Run(text);
Text for processing


*private void OnAudioFilterRead(float[] buffer, int numChannels)*{if (!_isStart) return;lock (this){foreach (var f in buffer){samplingData.Add(FloatToInt16(f));}}}
http:opensource.org/licenses/mit-license.php

*private void Awake()*{CheckForErrorOnCall(MicStream.MicInitializeCustomRate((int)StreamType, AudioSettings.outputSampleRate));}
http:opensource.org/licenses/mit-license.php

*private void OnAudioFilterRead(float[] buffer, int numChannels)*{if (!_isStart) return;lock (this){CheckForErrorOnCall(MicStream.MicGetFrame(buffer, buffer.Length, numChannels));foreach (var f in buffer){samplingData.Add(FloatToInt16(f));}}}
http:opensource.org/licenses/mit-license.php


*public class YorozuyaMember*{public string ID { get; set; }public string YorozuyaMemberName { get; set; }}
このクラスはDBから取得したエンティティクラスのつもり。

*TeacherList.ForEach(t => Console.WriteLine(t.TeacherName));
出力結果
1    坂田銀時
2    定春

*static List<YorozuyaMember> YorozuyaMemberList = new List<YorozuyaMember>()*{new YorozuyaMember{ID = "1", YorozuyaMemberName = "坂田銀時" },new YorozuyaMember{ID = "2", YorozuyaMemberName = "定春" }};
データ登録処理

*public class YorozuyaMember*{public string ID { get; set; }public string YorozuyaMemberName { get; set; }}
このクラスはDBから取得したエンティティクラスのつもり。

*public class JouihaMember*{public string ID { get; set; }public string JouihaMemberName { get; set; }}
このクラスもDBから取得したエンティティクラスのつもり。

*YorozuyaMemberList.ForEach(y => Console.WriteLine(y.ID + "    " + y.YorozuyaMemberName));
出力結果
1    坂田銀時
2    定春
1    桂小太郎
2    エリザベス

*static List<YorozuyaMember> YorozuyaMemberList = new List<YorozuyaMember>()*{new YorozuyaMember{ID = "1", YorozuyaMemberName = "坂田銀時" },new YorozuyaMember {ID = "2", YorozuyaMemberName = "定春" }};
万事屋データ登録処理

*static List<JouihaMember> JouihaMemberList = new List<JouihaMember>()*{new JouihaMember{ID = "1", JouihaMemberName = "桂小太郎" },new JouihaMember{ID = "2", JouihaMemberName = "エリザベス" }};
攘夷派データ登録処理

*string ID { get; }
Programクラスから変更されないように、getのみ。

*public class YorozuyaMember : Person*{public string ID { get; set; }public string YorozuyaMemberName { get; set; }//インターフェイス Person の Name プロパティを実装する必要がある。public string Name => YorozuyaMemberName;}
このクラスはDBから取得したエンティティクラスのつもり。

*public string Name => YorozuyaMemberName;
インターフェイス Person の Name プロパティを実装する必要がある。

*public class JouihaMember : Person*{public string ID { get; set; }public string JouihaMemberName { get; set; }//インターフェイス Person の Name プロパティを実装する必要がある。public string Name => JouihaMemberName;}
このクラスもDBから取得したエンティティクラスのつもり。

*public string Name => JouihaMemberName;
インターフェイス Person の Name プロパティを実装する必要がある。

*List<Person> PersonList = new List<Person>();
Personリストを作り、万事屋と攘夷派のミックスリストを作る。

*PersonList.OrderBy(p => p.Name).ToList().ForEach(p1 =>*{//出力結果//2    エリザベス//1    桂小太郎//1    坂田銀時//2    定春Console.WriteLine(p1.ID + "    " + p1.Name);});
名前順にソートして表示

*Console.WriteLine(p1.ID + "    " + p1.Name);
出力結果
2    エリザベス
1    桂小太郎
1    坂田銀時
2    定春

*static List<YorozuyaMember> YorozuyaMemberList = new List<YorozuyaMember>()*{new YorozuyaMember{ID = "1", YorozuyaMemberName = "坂田銀時" },new YorozuyaMember {ID = "2", YorozuyaMemberName = "定春" }};
万事屋データ登録処理

*static List<JouihaMember> JouihaMemberList = new List<JouihaMember>()*{new JouihaMember{ID = "1", JouihaMemberName = "桂小太郎" },new JouihaMember{ID = "2", JouihaMemberName = "エリザベス" }};
攘夷派データ登録処理


*if(this.BackFunction == null)return;*this.UseCount--;
BackFunctionが存在しない時は終了

*if(this.UseCount != 0)return;*this.BackFunction.Backward();
他の関数に対しても出力している場合にはまだ勾配を計算しない

*public virtual Tensor[] Predict(params Tensor[] inputs){return this.FunctionForward(inputs);}
...


*foreach (var item in root*.DescendantNodes()
usingの一覧を収集

*classes.AddRange(root.DescendantNodes()
自動生成対象とするインターフェースの一覧及びそのメンバの一覧を収集

*var name = syntax.Name.ToString().Split('.').Last();
インターフェースが自動生成の対象かを判定、Syntaxのみでの判定なのでちょっと手抜き

*return new ClassInfo*{Namespace = nds.Name.ToString(),Interface = ids.Identifier.Text,Methods = ids.Members.OfType<MethodDeclarationSyntax>().Select(CreateMethodInfo).ToArray()};
自動生成するクラスの元になる情報

*return new MethodInfo*{Name = mds.Identifier.Text,ReturnType = mds.ReturnType.ToString(),ParameterTypes = String.Join(", ", mds.ParameterList.Parameters.Select(ps => String.Format("typeof({0})", ps.Type.ToString()))),ArgumentsWithTypes = String.Join( ",", mds.ParameterList.Parameters.Select(ps => String.Format("{0} {1}", ps.Type.ToString(), ps.Identifier.Text))),Arguments = String.Join(", ", mds.ParameterList.Parameters.Select(ps => ps.Identifier.Text))};
自動生成するクラスのメソッドの元になる情報


*private const string SpeechTranslateUrl = @"wss:
dev.microsofttranslator.comspeechtranslate?";

*using (var waveStream = new FileStream(file, FileMode.Open)){var reader = new RawSourceWaveStream(waveStream, new WaveFormat(16000, 16, 1));
http:opensource.org/licenses/mit-license.php

*service.AddSamplingData(buffer, 0, 32000);
この部分は再生するwaveに応じて変更してください。
サンプルでは3～4秒程度のデータを送っていました。

*service.AddSamplingData(w, 0, w.Length);
無音データを意図的に送っています。

*private void OnVoiceMessage(object sender, MessageWebSocketMessageReceivedEventArgs messageEventArgs)*{using (var reader = messageEventArgs.GetDataStream())using (var stream = reader.AsStreamForRead())using (var mStream = new MemoryStream()){var bufferSize = 32000;var bytes = new List<byte>();var buf = new byte[bufferSize];var length = stream.Read(buf, 0, buf.Length);while (length - bufferSize == 0){bytes.AddRange(buf);length = stream.Read(buf, 0, buf.Length);}if (length > 0)bytes.AddRange(buf.Take(length).ToArray());var fullData = bytes.ToArray();mStream.Write(fullData, 0, fullData.Length);mStream.Position = 0;var bitsPerSampleBytes = fullData.Skip(34).Take(2).ToArray();var channelBytes = fullData.Skip(22).Take(2).ToArray();var samplingBytes = fullData.Skip(24).Take(4).ToArray();var bitsPerSample = BitConverter.ToInt16(bitsPerSampleBytes, 0);var channel = BitConverter.ToInt16(channelBytes, 0);var samplingRate = BitConverter.ToInt32(samplingBytes, 0);using (var player = new WasapiOutRT(AudioClientShareMode.Shared, 250)){player.Init(() =>{var waveChannel32 =new WaveChannel32(new RawSourceWaveStream(mStream,new WaveFormat(samplingRate, bitsPerSample, channel)));var mixer = new MixingSampleProvider(new[] {waveChannel32.ToSampleProvider()});return mixer.ToWaveProvider16();});player.Play();while (player.PlaybackState == PlaybackState.Playing){}}}}
http:opensource.org/licenses/mit-license.php


*InputManager.Instance. PushFallbackInputHandler(gameObject);
AirTapを検出したとき、OnInputClickedが呼ばれる。

*void OnInputClicked(InputClickedEventData eventData){//AirTap検出時の処理を記述}
AirTapを検出したとき呼ばれるメソッド

*}
AirTap検出時の処理を記述


*Thread.Sleep( 4000 );
スクリプト実行まで時間が掛かるので適当にwait


*var NotepadSession = new WindowsDriver<WindowsElement>(new Uri("http:
127.0.0.1:4723"), appCapabilities);


*return IsOk.Yes;
画面に設定されたフラグ値を取得する。ビルドのため、固定値になっている。

*return "○";
画面に設定されたフラグに対する表示値を取得する。ビルドのため、固定値になっている。

*}
文字を太字にする。コードは省略。

*return IsOk.Yes;
画面に設定されたフラグ値を取得する。ビルドのため、固定値になっている。

*return "○";
画面に設定されたフラグに対する表示値を取得する。ビルドのため、固定値になっている。

*}
文字を太字にする。コードは省略。


*});
stringが変更された時の処理

*void Start()*{appState.Subscribe(value =>{Debug.Log("APP_STATE:" + value);});}
Start is called before the first frame update


*checkBox.CheckedChanged += CheckBoxCheckedChanged;
用途に合わせて、どちらか一方を使うとよいかと思います。

*void CheckBoxCheckedChanged(object sender, EventArgs e)
CheckedChangedイベントは、
ユーザー操作だけでなく、
プログラムからCheckBoxのCheckedプロパティを操作した場合もコールされる。

*void CheckBoxClick(object sender, EventArgs e)
Clickイベントは、
ユーザー操作からは呼ばれる。
（「クリック(Click)」という名称だが、スペースキーでCheck状態を操作しても呼んでくれる。）
プログラムからCheckBoxのCheckedプロパティを操作した場合はコールされない。

*checkBox.CheckedChanged += CheckBoxCheckedChanged;
用途に合わせて、どちらか一方を使うとよいかと思います。
checkBox.Click += CheckBoxClick;

*void CheckBoxCheckedChanged(object sender, EventArgs e)*{// window titleif ( checkBox.Checked ) {Text = "Checked";}else {Text = "Not checked";}}
void CheckBoxClick(object sender, EventArgs e)


*ViewData["Message"] = System.Runtime.InteropServices.RuntimeInformation.OSDescription;*return View();
ViewData["Message"] = "Your application description page.";


*void Start () {StartCoroutine (Calcurate ());}
Use this for initialization

*void Update () {}
Update is called once per frame


*button = GameObject.Find("Canvas").transform.Find("ChildButtonController").GetComponent<ChildButtonController>();*}
改善の余地あり


*else if (num % 2 == 0) return false;
偶数はあらかじめ除く

*return false;
素数ではない

*return true;
素数である


*System.Diagnostics.Debug.Assert(max >= 2);
maxは2以上の数

*var searchList = Enumerable.Range(2, max - 1).ToList();
■ステップ 1
探索リストに2からxまでの整数を昇順で入れる。

*prime = searchList.First();
■ステップ 2
探索リストの先頭の数を素数リストに移動し、その倍数を探索リストから篩い落とす。

*primeList.Add(prime);
素数リストに追加

*searchList.RemoveAll(n => n % prime == 0);
倍数をふるい落とす

*} while (prime < sqrtMax);
■ステップ 3
上記の篩い落とし操作を探索リストの先頭値がxの平方根に達するまで行う。

*primeList.AddRange(searchList);
■ステップ 4
探索リストに残った数を素数リストに移動して処理終了。


*using (var cryptoStream = new CryptoStream(inputStream, decryptor, CryptoStreamMode.Read))
暗号化データ → 圧縮データ

*int byteCount;
圧縮データ → MemoryStream


*public int Add(int x, int y)*{return x + y;}
テスト対象メソッド

*[Fact]
テストメソッド

*[Fact(DisplayName = "1+1=2のはず", Skip = "諸々の事情により実行したくない")]public void Test(){Add(1, 1).Is(2);
テストメソッド

*public static object[][] AddTestData => Enumerable.Range(1, 10).Select(i => new object[] { i, i, i + i }).ToArray();
テストデータ１: プロパティ

*public static IEnumerable<object[]> MakeAddTestData(int from, int count)*{return Enumerable.Range(from, count).Select(i => new object[] { i, i, i + i });}
テストデータ２: メソッド

*[Theory]
テストメソッド

*public string GetYoubi(DateTime date)*{return date.ToString("dddd", new System.Globalization.CultureInfo("ja-JP"));}
テスト対象メソッド

*class TestDataClass : IEnumerable<object[]>*{List<object[]> _testData = new List<object[]>();public TestDataClass(){_testData.Add(new object[] { new DateTime(2017, 4, 27), "木曜日" });_testData.Add(new object[] { new DateTime(2017, 4, 28), "金曜日" });}public IEnumerator<object[]> GetEnumerator() => _testData.GetEnumerator();IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();}
テストデータ作成クラス

*[Theory]
テストメソッド

*public void Write(string message)*{if(message == null){throw new ArgumentNullException(nameof(message), "ぬるぬる");}Console.WriteLine(message);}
テスト対象メソッド

*[Fact]
テストメソッド

*var ex = Assert.Throws<ArgumentNullException>(() =>*{Write(null);});
ArgumentNullExceptionが発生するはず

*var ex2 = Assert.ThrowsAny<ArgumentException>(() =>*{Write(null);});
ArgumentExceptionかそのサブクラスの例外が発生するはず

*public async Task<string> ReadAllTextAsync(string file)*{if (file == null){throw new ArgumentNullException(nameof(file));}using(var sr = new StreamReader(file)){return await sr.ReadToEndAsync();}}
テスト対象メソッド

*[Fact]
テストメソッド

*[Fact]
テストメソッド(Exception)

*var ex = await Assert.ThrowsAsync<ArgumentNullException>(() =>*{return ReadAllTextAsync(null);});
ArgumentNullExceptionが発生するはず


*}
一部省略

*}
一部省略

*}
一部省略

*}
一部省略


*string url = "https:
api.a3rt.recruit-tech.co.jptalkv1smalltalk";

*WWWForm form = new WWWForm();*form.AddField("apikey", apikey);
ChatAPIに送る情報を入力

*string itemJson = request.downloadHandler.text;
取得したものをJsonで整形

*Debug.Log("JsonNode:" + e.Message);
エラーが出たらこれがログに吐き出される


*public static List<T> GetMasterData<T>(List<long> id) where T : IMasterData, new()
new T() のため.

*if (cachedMasterDictionary.ContainsKey(dataPath))
---拡張しました---
同じキー(dataPath)が呼び出されたら.

*return Filter(cachedData, id);
キャッシュしていたデータを渡します.

*StreamReader sr = new StreamReader(dataPath, Encoding.UTF8);
UTF8形式でデータを読み込みます.

*var table = Json.Deserialize(source) as IList;
インターフェースを通してデータを初期化します.

*cachedMasterDictionary.Add(dataPath, result);
---拡張しました---
初期化済みマスタデータをdataPathをキーとしてキャッシュしておきます.

*return Filter(result, id);
IDが一致したデータのみ渡します.


*var primes = CountPrime(0, number);
素数の一覧を取得

*var primes = new List<long>() { 2 };
最小の素数をリストに

*yield break;
割れなくなったらやめる

*primes.Add(tmp);
最大の素数が残っている数の平方より大きいなら残っている数は素数

*primes.Add(Enumerable.Range(maxPrime, tmp - maxPrime)
次の素数を求める


*public void TestA()
このSampleのメソッドをGetActionのUnityEventに指定する
</Summary>

*Action action = (Action)System.Delegate.CreateDelegate(typeof(Action), SetUnityEvent.GetPersistentTarget(i), SetUnityEvent.GetPersistentMethodName(i));
CreateDelegateでUnityActionを作っている


*x = x.Val- 0.1 * x.Dif;
xの更新

*Console.WriteLine(y.Val + "\t" + x.Val);
yの極小値とその時のx


*using (DirectoryEntry DE = new DirectoryEntry(string.Format("LDAP:
{0}", new ADSystemInfo().UserName))) {


*.ToList();
Whereの結果をList<int>に変換する


*return fields[8];
c-ip


*private List<DataGridColumnInfo> _defaultSettings;
元（デザイン状態）の列設定

*_defaultSettings = this.TargetGrid.Columns.Select((x, index) => new DataGridColumnInfo()
デフォルトの並び順・幅を確保する

*var saveValue = Properties.Settings.Default[SettingsKey].ToString();
ユーザ設定から保存値を取得し、DataGridに反映する

*var newSettings = this.TargetGrid.Columns.Select((x, index) => new DataGridColumnInfo()
列情報コレクションに現在のDisplayIndexとWidthを確保

*Properties.Settings.Default[SettingsKey] = xmlSerialize<List<DataGridColumnInfo>>(newSettings);
ユーザ設定へ保存

*setColumns(_defaultSettings);
最初にとっておいた_defaultSettingsで設定する

*Properties.Settings.Default[SettingsKey] = null;
ユーザ設定へはnullを保存する


*var table1 = default(DataTable)using (var context = new DataContext()){var tmp = context.Model1.ToArray();
その1 単純に変換

*var table2 = default(DataTable)
その2 匿名型
もちろんJoinとかの結果でも大丈夫


*public static readonly DependencyProperty DataProperty =DependencyProperty.Register("Data",typeof(object),typeof(BindingProxy),new UIPropertyMetadata(null));
Using a DependencyProperty as the backing store for Data.  This enables animation, styling, binding, etc...


*browser.Address = "https:
google.co.jp";


*return null;
TODO: スタブ

*}
何もせず if を抜けます


*ExecuteAsync();
非同期１つ目。待たなくてもいいパターン

*var result = await ExecuteAsync2();
非同期２つ目。後続がこの処理の結果を必要とするので待つ必要がある。

*await ExecuteAsync3(result);
非同期3つ目。2つ目の結果を受け取って処理する。


*}
以下ゲーム開始の処理


*[SerializeField] private float speed;
移動スピード

*[SerializeField] private Rigidbody2D _rigidbody;
SpaceshipのRigidbody

*protected virtual void Move (Vector2 direction)*{_rigidbody.velocity = direction * speed;}
機体の移動

*float x = Input.GetAxisRaw ("Horizontal");
右・左

*float y = Input.GetAxisRaw ("Vertical");
上・下

*Vector2 direction = new Vector2 (x, y).normalized;
移動する向きを求める

*movable.Move (direction);
移動


*var displayName = account.DisplayName;
設定しいるユーザー名が取れる


*var pickerDataModel = new pickerDataModel();
UIPickerViewを生成する

*public event EventHandler<EventArgs> ValueChanged;
プロパティの変更を検知するプロパティ

*List<Item> items = new List<Item>();
Pickerに表示するデータを格納するフィールド

*public Tuple<int, string> SelectedItem*{get{var returnType = new Tuple<int, string>(items[selectedIndex].ItemId, items[selectedIndex].ItemName);return returnType;}}
選択された値を取得するメソッド

*public pickerDataModel()*{items = new List<Item>();}
コンストラクター

*public override nint GetComponentCount(UIPickerView pickerView)*{return 1;}
カラム数

*public override nint GetRowsInComponent(UIPickerView pickerView, nint component)*{return items.Count;}
行数

*public override string GetTitle(UIPickerView pickerView, nint row, nint component)*{return items[(int)row].ItemName;}
文字列取得

*public override void Selected(UIPickerView pickerView, nint row, nint component)*{selectedIndex = (int)row;if (ValueChanged != null){ValueChanged(this, new EventArgs());}}
選択されたときの挙動


*cell.TextLabel.Text = item.name;
任意のプロパティ


*var d1 = DateTime.Parse($"{yy:D2}/01/01");
DateTime.Parse()

*var d2 = DateTime.ParseExact($"{yy:D2}/01/01", "yy/MM/dd", null);
DateTime.ParseExact()

*DateTime d3; DateTime.TryParseExact($"{yy:D2}/01/01", "yy/MM/dd", null, System.Globalization.DateTimeStyles.None, out d3);
DateTime.TryParseExact()

*Console.WriteLine($"{yy:D2}/01/01 → {d1:yyyy/MM/dd}, {d2:yyyy/MM/dd}, {d3:yyyy/MM/dd}");
出力

*var culture = new System.Globalization.CultureInfo("ja-JP");
カルチャの生成 (年2桁の解釈(TwoDigitYearMax)を2099(2000～2099)にする)

*var d1 = DateTime.Parse($"{yy:D2}/01/01", culture);
DateTime.Parse() + カルチャ明示

*var d2 = DateTime.ParseExact($"{yy:D2}/01/01", "yy/MM/dd", culture);
DateTime.ParseExact() + カルチャ明示

*DateTime d3; DateTime.TryParseExact($"{yy:D2}/01/01", "yy/MM/dd", culture, System.Globalization.DateTimeStyles.None, out d3);
DateTime.TryParseExact() + カルチャ明示

*Console.WriteLine($"{yy:D2}/01/01 → {d1:yyyy/MM/dd}, {d2:yyyy/MM/dd}, {d3:yyyy/MM/dd}");
出力


*endpoints.MapControllerRoute(name: "areas",pattern: "{area:exists}/{controller=Home}/{action=Index}/{id?}");
ルーティングのルールによって、エリアを持つルートはエリアを持たないルート具体的なので、前に配置する必要がある

*[Area("Personnel")]
エリア属性によって、該当コントローラーを指定のエリアと関連付ける

*options.AreaViewLocationFormats.Clear();
既存のエリアビューの検出ルールをクリア

*options.AreaViewLocationFormats.Add("/MyAreas/{2}/Views/{1}/{0}.cshtml");
新しいエリアビューの検出ルールを登録する

*[Area("Personnel")]
親コントローラーにArea属性を設定
Controllerが抽象クラスなので、PersonnelBaseControllerは抽象にしてもしなくても良いです

*public class HomeController : PersonnelBaseController*{public IActionResult Index(){return View();}}
親コントローラーにエリア属性を設定しているので、該当子コントローラーには設定しなくてもPersonnelエリアと関連付けている


*listener.Prefixes.Add("http:
localhost:9999");


*app.UseForwardedHeaders(new ForwardedHeadersOptions{ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto});
クライアントのIPアドレスを取得するため、NginxのProxyヘッダを使う設定


*string uri = "http:
api.microsofttranslator.comv2Http.svcTranslate?text=" +


*Task<string> task = hc.GetStringAsync("https:
www.microsoft.com");

*Console.WriteLine("ちょっとまってね");
www.microsoft.com の応答が超速なら、このメッセージは表示されない！


*System.IO.IOException: The process cannot access the file 'hoge.txt' because it is being used by another process.
わりと頻繁に発生

*}
まだ何も書いてない

*System.IO.IOException: The process cannot access the file 'hoge.txt' because it is being used by another process.
希に発生


*Action act1 = () =>*{Console.WriteLine("");};
引数void、戻り値void

*Action<string> act2 = (string value) =>*{Console.WriteLine(value);};
引数string、戻り値void

*Func<int, int, string> funcAdd = (x, y) =>*{return (x + y).ToString();};
引数int,int、戻り値string

*act1();
呼び出し


*else
Remove Select All chkBox

*public bool Selected { get; set; }
public string items { get; set; }


*var s = string.Format("{0:0.000}", 1.2345);
= "1.235"


*public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)*{loggerFactory.AddConsole(Configuration.GetSection("Logging"));loggerFactory.AddDebug();if (env.IsDevelopment()){app.UseDeveloperExceptionPage();app.UseBrowserLink();}else{app.UseExceptionHandler("/Home/Error");}app.UseStaticFiles();app.UseCookieAuthentication();app.UseOpenIdConnectAuthentication(new OpenIdConnectOptions{ClientId = Configuration["Authentication:AzureAd:ClientId"],Authority = Configuration["Authentication:AzureAd:AADInstance"] + Configuration["Authentication:AzureAd:TenantId"],CallbackPath = Configuration["Authentication:AzureAd:CallbackPath"]});app.UseMvc(routes =>{routes.MapRoute(name: "default",template: "{controller=Home}/{action=Index}/{id?}");});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.


*private void checkedListBox1_ItemCheck(object sender, ItemCheckEventArgs e)*{if (e.Index != lastCheckedIndex){if(lastCheckedIndex != -1)checkedListBox1.SetItemCheckState(lastCheckedIndex, CheckState.Unchecked);lastCheckedIndex = e.Index;}}
ItemCheck event handler for your checkedListBox1


*public class InputRecord*{public int ID { get; set; }public string Fruit1 { get; set; }public int Price1 { get; set; }public string Fruit2 { get; set; }public int Price2 { get; set; }public string Fruit3 { get; set; }public int Price3 { get; set; }}
分割前のデータ1行が入る

*public class OutputRecord*{public int Sequence { get; set; }public string Fruit { get; set; }public int Price { get; set; }}
分割後のデータ1行が入る

*var input = new List<InputRecord>*{new InputRecord{ID = 1,Fruit1 = "りんご",Price1 = 150,Fruit2 = "みかん",Price2 = 50,Fruit3 = "はっさく",Price3 = 100,},new InputRecord{ID = 2,Fruit1 = "ぶんたん",Price1 = 200,Fruit2 = "ぶどう",Price2 = 300,Fruit3 = "いちご",Price3 = 400,},new InputRecord{ID = 3,Fruit1 = "めろん",Price1 = 2000,Fruit2 = "なし",Price2 = 130,Fruit3 = "ざくろ",Price3 = 500,},};
テストデータ(分割前表と同じ内容)

*List<OutputRecord> output = ConvertToOutput(input).ToList();
メソッド呼び出し


*.ToDictionary(x => x, x => User32.GetWindowText(x));
ここから下は Linq to object


*string html = await wc.DownloadDataTaskAsync("http:
www.google.co.jp");


*script.Attack ();
UnityChanScriptにある関数Attackを実行する


*long count = GetUInt32(4, false) + 24;
CELLレコードのサイズ

*count += GetUInt32(count + 4, false);
CELLレコード後のGROUPのサイズを加算


*void Update()*{if (Sd1_on.activeSelf){time += Time.deltaTime;if (Input.GetKeyDown(KeyCode.F)){audioSource.PlayOneShot(Operandum1SE);if (time > DRL){audioSource.PlayOneShot(PointSE);CountText.text = "Point : " + Point.ToString();Point += 1;time = 0;}else{time = 0;}}}if (Sd1_off.activeSelf){time = 0;}}
New

*void Update()*{if (Sd1_on.activeSelf){time += Time.deltaTime;if (Input.GetKeyDown(KeyCode.F)){audioSource.PlayOneShot(Operandum1SE);if (time < DRH){audioSource.PlayOneShot(PointSE);CountText.text = "Point : " + Point.ToString();Point += 1;time = 0;}else{time = 0;}}}if (Sd1_off.activeSelf){time = 0;}}
New

*void Update()*{if (Sd1_on.activeSelf){time += Time.deltaTime;if (Input.GetKeyDown(KeyCode.F)){audioSource.PlayOneShot(Operandum1SE);if (time < DRHTime){if (Counter == DRHTimes){audioSource.PlayOneShot(PointSE);CountText.text = "Point : " + Point.ToString();Point += 1;time = 0;Counter = 0;}}else{time = 0;Counter = 0;}}}if (Sd1_off.activeSelf){time = 0;Counter = 0;}}
New


*var appRegistration = new AppRegistration
MastodonClient.CreateApp で得たものを保存しとく必要があるけど面倒だから UnitTest(MastodonClientTests)のを使わせてもらった
var appRegistration = await MastodonClient.CreateApp(instanceUrl, "MastoConsoleStandard", Scope.Read);

*streaming.OnUpdate += (_, e) =>*{Console.WriteLine("--");Console.WriteLine($"{e.Status.CreatedAt.ToLocalTime().ToString()} - {e.Status.Account.AccountName}:");Console.WriteLine(e.Status.Content);};
Register events


*string langPath = @"C:\tessdata";
言語ファイルの格納先

*string lngStr = "eng";
言語（日本語なら"jpn"）

*var img = new Bitmap(@"C:\Temp\test.jpg");
画像ファイル

*Tesseract.Page page = tesseract.Process(img);
OCRの実行

*Console.WriteLine(page.GetText());
表示


*_session.Reset();
既存の平面をリセット

*_arPlaneManager.requestedDetectionMode = PlaneDetectionMode.None;
平面認識の機能をオフ

*_arPlaneManager.requestedDetectionMode = PlaneDetectionMode.Horizontal;
平面認識の機能をオン

*var hitPose = _hits[0].pose;
RayとARPlaneが衝突したところのPose

*_arObject.transform.position = hitPose.position;*var cameraPos = Camera.main.transform.position;
オブジェクトの配置


*[System.Web.Services.Protocols.SoapRpcMethodAttribute("MessageSaveCreateThreads", RequestNamespace="http:
wsdl.cybozu.co.jpmessage2008", ResponseNamespace="http:wsdl.cybozu.co.jpmessage2008", Use=System.Web.Services.Description.SoapBindingUse.Literal)]

*securityElement.usernameToken = userNameTokenElement;
送信者
userNameTokenElement.Username = this.Account.Text.ToString(); 送信者のﾕｰｻﾞｰｱｶｳﾝﾄ;
userNameTokenElement.Password = this.Password.Text.ToString(); 送信者のﾕｰｻﾞｰﾊﾟｽﾜｰﾄ;

*messageAPI.action = actionElement;
Soapヘッダー

*threadType.id = "dummy";
ダミー情報

*threadTypeFolder.id = "dummy";
フォルダー

*threadTypeFollow.id = "dummy";
コメント

*threadType.content = content1;
標題
threadType.subject = this.Subject.Text.ToString();標題
本文
content1.body = this.Content.Text.ToString();本文

*threadType.confirm = false;
確認フラグ

*int i = 0;
宛先

*messageThreadType.thread = threadType;
メッセージの送信


*Gizmos.DrawIcon(pivotCenter, "MyGizmoCircleOrange");
ギズモのアイコンは自分で設定してね！


*var builder = new ConfigurationBuilder().SetBasePath(env.ContentRootPath).AddJsonFile("appsettings.json", optional: false, reloadOnChange: true).AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true).AddEnvironmentVariables();
構成ファイル、環境変数等から、構成情報をロード

*Configuration = builder.Build();
構成情報をプロパティに設定

*bool isDemoMode = this.Configuration.GetValue<bool>("UserSettings:IsDemoMode");
各構成情報の取得
ブール値のロード

*string defaultUserName = this.Configuration["UserSettings:DefaultUser:Name"];
文字列値のロードは、インデクサで指定可能

*int defaultUserAge = this.Configuration.GetValue<int>("UserSettings:DefaultUser:Age");
int 値のロード

*public void ConfigureServices(IServiceCollection services)*{// Add framework services.services.AddMvc();//構成情報から、UserSettings クラスへバインドservices.Configure<UserSettings>(this.Configuration.GetSection("UserSettings"));}
This method gets called by the runtime. Use this method to add services to the container.

*services.Configure<UserSettings>(this.Configuration.GetSection("UserSettings"));
構成情報から、UserSettings クラスへバインド

*this._userSettings = userSettings.Value;
ユーザー設定情報インスタンスをフィールドに保持


*xmlns:x="http:
schemas.microsoft.comwinfx2006xaml"

*var mv = new MainView();
メイン画面を作成して表示する

*sw.Start();
計測開始

*sw.Stop();
この間に処理を行う
計測終了

*long time = sw.ElapsedMilliseconds;
結果を返す(ミリ秒単位)

*var r = new System.Random();
乱数を初期化

*int dice = r.Next(6);
0以上6未満の整数一様乱数を発生させる

*int x = r.Next(-10, 11);
-10以上11未満の整数一様乱数を発生させる
つまり下記は[-10,10]であり[-10,11]ではない

*int y = r.Next();
0以上Int32.MaxValue未満の整数一様乱数を発生させる

*double z = r.NextDouble();
0.0以上1.0未満の実数一様乱数を発生させる
つまり[0.0,1.0)であり[0.0,1.0]ではない


*nums6.Aggregate((x, y) => x * y);
3628800

*var primeOrOdd = primes.Union(oddNums);*// -> { 2, 3, 5, 7, 11, 13, 1, 9 }
-> { 1, 3, 5, 7, 9, 11, 13 }

*var primeAndOdd = primes.Intersect(oddNums);*// -> { 3, 5, 7, 11, 13 }
-> { 2, 3, 5, 7, 11, 13, 1, 9 }

*var noPrimeOdd = oddNums.Except(primes);*// -> { 1, 9 }
-> { 3, 5, 7, 11, 13 }

*,,,*var nums7 = new[] { 1, 2, 3, 4, 5, 6 };
-> { 1, 9 }

*string[] arrayoftype = alist.OfType<string>().ToArray();*// -> { "First", "Second", "Third" }
-> { "First", "Second", null, "Third" }


*this._hostingEnvironment = hostingEnvironment;
IHostingEnvironment をフィールドに保持

*DataContractJsonSerializer jsonSerializer = new DataContractJsonSerializer(typeof(Person));
シリアライザーのインスタンスを生成

*using (FileStream stream = new FileStream(filePath, FileMode.Open))using (Stream stream = System.IO.File.Open(filePath, FileMode.Open)){逆シリアライズdeSerializedPerson = jsonSerializer.ReadObject(stream) as Person;
入力ファイル ストリームの生成

*using (Stream stream = System.IO.File.Open(filePath, FileMode.Open)){逆シリアライズdeSerializedPerson = jsonSerializer.ReadObject(stream) as Person;
using (FileStream stream = new FileStream(filePath, FileMode.Open))

*deSerializedPerson = jsonSerializer.ReadObject(stream) as Person;
逆シリアライズ


*public bool CompareNullableDatetime(DateTime? date1, DateTime? date2)*{int result = Nullable.Compare(date1, date2);return result > 0;}
date1がdate2より遅い日付の場合True


*var devices = await DeviceInformation.FindAllAsync(DeviceClass.VideoCapture);*var device = devices[0];
http:opensource.org/licenses/mit-license.php

*var properties = capture.VideoDeviceController.GetMediaStreamProperties(MediaStreamType.VideoPreview) as VideoEncodingProperties;
使用するカメラの最大画素数を取得するためのプロパティ

*var property = ImageEncodingProperties.CreateJpeg();
Jpeg形式でガメラの最大解像度で取得する。

*using (var stream = new InMemoryRandomAccessStream()){カメラから画像をキャプチャする。注：この処理はawaitが使えない。今のところ原因は不明ですが、スレッド関連の問題だと思われる。capture.CapturePhotoToStreamAsync(property, stream).GetAwaiter().GetResult();
http:opensource.org/licenses/mit-license.php

*capture.CapturePhotoToStreamAsync(property, stream).GetAwaiter().GetResult();
カメラから画像をキャプチャする。
注：この処理はawaitが使えない。今のところ原因は不明ですが、スレッド関連の問題だと思われる。

*stream.Seek(0);
検索位置を戻す

*Face[] face = await _faceClient.DetectAsync(stream.AsStreamForRead());
Face APIの呼び出し

*capture.CapturePhotoToStreamAsync(property, stream).GetAwaiter().GetResult();
カメラから画像をキャプチャする。
注：この処理はawaitが使えない。今のところ原因は不明ですが、スレッド関連の問題だと思われる。

*stream.Seek(0);
検索位置を戻す

*Emotion[] emotion = await _emotionClient.RecognizeAsync(stream.AsStreamForRead());
Emotion APIの呼び出し

*stream.Seek(0);
カメラから画像をキャプチャする。
注：この処理はawaitが使えない。今のところ原因は不明ですが、スレッド関連の問題だと思われる。    capture.CapturePhotoToStreamAsync(property, stream).GetAwaiter().GetResult();
検索位置を戻す

*AnalysisResult vision = await _visionClient.GetTagsAsync(stream.AsStreamForRead());
Computer Vision APIの呼び出し


*void CirclarMotionByDiameter(){//cosθ = a(底辺)/c(斜辺)//a = c*cosθ//a = radius*cosθ//sinθ = b(高さ)/c(斜辺)//b = c * sinθ;//b = radius * sinθ//円の中心Vector3 a = left.position;Vector3 b = right.position;Vector3 center = new Vector3 ((a.x + b.x) / 2, (a.y + b.y) / 2, (a.z + b.z) / 2);//円の半径float radius = Vector3.Distance (a, center);float c = Time.time * speed;float x = radius * Mathf.Cos (c);float y = radius * Mathf.Sin (c);obj.position = new Vector3 (x, y, obj.position.z) + center;}
2点間を直径とする正円運動

*a = c*cosθa = radius*cosθsinθ = b(高さ)/c(斜辺)b = c * sinθ;
cosθ = a(底辺)/c(斜辺)

*a = radius*cosθsinθ = b(高さ)/c(斜辺)b = c * sinθ;
a = c*cosθ

*sinθ = b(高さ)/c(斜辺)b = c * sinθ;
a = radius*cosθ

*Vector3 a = left.position;
sinθ = b(高さ)/c(斜辺)
b = c * sinθ;
b = radius * sinθ
円の中心

*float radius = Vector3.Distance (a, center);
円の半径

*void ElliptiicalMotionBy2Points(){Vector3 a = left2.position;Vector3 b = right.position;Vector3 center = new Vector3 (a.x , b.y, (a.z + b.z) / 2);//円の半径float radiusX = Vector3.Distance (b, center);float radiusY = Vector3.Distance (a, center);float c = Time.time * speed;float x = radiusX * Mathf.Cos (c);float y = radiusY * Mathf.Sin (c);obj.position = new Vector3 (x, y, obj.position.z) + center;}
2点を通る楕円運動

*float radiusX = Vector3.Distance (b, center);
円の半径

*void CirclarMotionBy2Points(){//中心(a,b)の円の半径を求める式は//(x-a)^2 + (y - b)^2 = r^2//これを一般形にすると、(aとbになんでもいいから入れるとわかる）//x^2 + y^2 +lx + my + n = 0//となるので、まず3点を定義する//とやろうと思ったけどプログラムで連立方程式なんてできるの。。。？//なので、//中心をO(x,y)とすると、OA=OB=OCであるので、Vector3 a = left2.position;Vector3 b = right.position;Vector3 c = left.position;}
3点を通る正円運動

*(x-a)^2 + (y - b)^2 = r^2これを一般形にすると、(aとbになんでもいいから入れるとわかる）x^2 + y^2 +lx + my + n = 0となるので、まず3点を定義するとやろうと思ったけどプログラムで連立方程式なんてできるの。。。？なので、中心をO(x,y)とすると、OA=OB=OCであるので、Vector3 a = left2.position;
中心(a,b)の円の半径を求める式は

*これを一般形にすると、(aとbになんでもいいから入れるとわかる）x^2 + y^2 +lx + my + n = 0となるので、まず3点を定義するとやろうと思ったけどプログラムで連立方程式なんてできるの。。。？なので、中心をO(x,y)とすると、OA=OB=OCであるので、
(x-a)^2 + (y - b)^2 = r^2

*x^2 + y^2 +lx + my + n = 0となるので、まず3点を定義するとやろうと思ったけどプログラムで連立方程式なんてできるの。。。？なので、中心をO(x,y)とすると、OA=OB=OCであるので、Vector3 a = left2.position;
これを一般形にすると、(aとbになんでもいいから入れるとわかる）

*Vector3 a = left2.position;
となるので、まず3点を定義する
とやろうと思ったけどプログラムで連立方程式なんてできるの。。。？
なので、
中心をO(x,y)とすると、OA=OB=OCであるので、


*break;
UNC を指定したときに発生
存在しない UNC を指定したときに発生


*public System.Collections.ObjectModel.ObservableCollection<ZipRecord> ZipRecords { get; set; }
郵便番号データのコレクション

*this.ZipRecords = new System.Collections.ObjectModel.ObservableCollection<ZipRecord>();
郵便番号データのコレクションを初期化

*listView.DataContext = this.ZipRecords;
関連付け


*System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);
System.Text.Encoding.CodePages を NuGet で追加
コンソールの文字コードの設定

*DataContractJsonSerializer jsonSerializer = new DataContractJsonSerializer(typeof(Person));
シリアライザーのインスタンスを生成

*using (FileStream stream = new FileStream(filePath, FileMode.OpenOrCreate)){シリアライズjsonSerializer.WriteObject(stream, person);
出力ファイル ストリームの生成

*jsonSerializer.WriteObject(stream, person);
シリアライズ

*using (FileStream stream = new FileStream(filePath, FileMode.Open))using (Stream stream = File.Open(filePath, FileMode.Open)){逆シリアライズdeSerializedPerson = jsonSerializer.ReadObject(stream) as Person;
入力ファイル ストリームの生成

*using (Stream stream = File.Open(filePath, FileMode.Open)){逆シリアライズdeSerializedPerson = jsonSerializer.ReadObject(stream) as Person;
using (FileStream stream = new FileStream(filePath, FileMode.Open))

*deSerializedPerson = jsonSerializer.ReadObject(stream) as Person;
逆シリアライズ


*void Update()*{if (Sd1_on.activeSelf){time += Time.deltaTime;if (Input.GetKeyDown(KeyCode.F)){audioSource.PlayOneShot(Operandum1SE);}if (time >= FTTime){audioSource.PlayOneShot(PointSE);CountText.text = "Point : " + Point.ToString();Point += 1;time = 0;}}if (Sd1_off.activeSelf){time = 0;}}
New


*list.Add("item");
追加 : O(1)

*var item = list[0];
取得 : O(1)

*int index = list.IndexOf("item");
検索 : O(n)

*list.Sort();
ソート : O(n log n)

*bool removed = list.Remove("itemmmm");
削除 : O(n)

*LinkedListNode<string> addedNode = llist.AddLast("value");
追加 : O(1)

*bool contains = llist.Contains("value");
検索 : O(n)

*LinkedListNode<string> findNode = llist.Find("value");
検索と取得 : O(n)

*bool removed = llist.Remove("value");
削除(要素指定) : O(n)

*llist.Remove(addedNode2);
削除(ノード指定) : O(1)

*queue.Enqueue("item");
エンキュー : O(1)

*bool contains = queue.Contains("item");
検索 : O(n)

*var item = queue.Peek();
ピーク : O(1)

*var item2 = queue.Dequeue();
デキュー : O(1)

*stack.Push("item");
プッシュ : O(1)

*bool contains = stack.Contains("item");
検索 : O(n)

*var item = stack.Peek();
ピーク : O(1)

*var item2 = stack.Pop();
ポップ : O(1)

*dict.Add("key", "value");
追加 : O(1)

*bool containsKey = dict.ContainsKey("key");
検索 : O(1)

*var value = dict["key"];
取得 : O(1)

*bool removed = dict.Remove("key");
削除 : O(1)

*sdict.Add("key2", "value2");
追加：O(log n)

*bool contains = sdict.ContainsKey("key");
検索：O(log n)

*var value = sdict["key"];
取得：O(log n)

*bool removed = sdict.Remove("key");
削除：O(log n)

*slist.Add("key", "value");
追加：O(n)

*bool containsKey = slist.ContainsKey("key");
検索：O(log n)

*var value = slist["key"];
取得：O(log n)

*var keybyindex = slist.Keys[0];
取得(インデックス使用)：O(1)

*bool removed = slist.Remove("key");
削除：O(n)

*bool added = set.Add("item");
追加：O(1)

*bool contains = set.Contains("item");
検索：O(1)

*set.UnionWith(new[] { "otheritem" });
集合演算：O(n) ~ O(n+m)

*bool removed = set.Remove("item");
削除：O(1)

*int removedCount = set.RemoveWhere(_ => _.StartsWith("it"));
削除(条件指定)：O(n)

*bool added = sset.Add("item");
追加：O(log n)

*bool contains = sset.Contains("item");
検索：O(log n)

*sset.UnionWith(new[] { "otheritem" });
集合演算：O(n) ~ O(n+m)

*bool removed = sset.Remove("item");
削除：O(log n)

*int removedCount = sset.RemoveWhere(_ => _.StartsWith("it"));
削除（条件指定）：O(n)


*if (quoteCount % 2 == 0)
is not value(quoted)

*//        "Escape:",*//        "{",//        "}",
"C",

*//        "{",//        "}",
"Escape:",

*Old == New:True,,,
*List<string> AllTags*{get{return InternalEditorUtility.tags.ToList();}}
tagのList

*public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)*{var list = AllTags;var selectedIndex = list.FindIndex(item => item.Equals(property.stringValue));if (selectedIndex == -1){selectedIndex = list.FindIndex(item => item.Equals(list[0]));}selectedIndex = EditorGUI.Popup(position, label.text, selectedIndex, list.ToArray());property.stringValue = list[selectedIndex];}
ドロップダウンメニューの作成


*void Update()*{if (Sd1_on.activeSelf){if (Input.GetKeyDown(KeyCode.F)){Counter += 1;audioSource.PlayOneShot(Operandum1SE);if (Counter == FRTimes){audioSource.PlayOneShot(PointSE);CountText.text = "Point : " + Point.ToString();Point += 1;Counter = 0;}}}if (Sd1_off.activeSelf){Counter = 0;}}
New


*Debugger.Array(data);
123


*var ssr = ScriptSourceResolver.Default.WithBaseDirectory(Environment.CurrentDirectory);
スクリプトのパス設定

*var gameRuleClass = CSharpScript.EvaluateAsync<Type>(script,so).Result;
Roslynでスクリプト実行


*List<string> AllSceneName*{get{List<string> sceneNames = new List<string>();//BuildSettingsからSceneのPathを読み込むList<string> AllPaths = (from scene in EditorBuildSettings.scenes where scene.enabled select scene.path).ToList();//PathからScene名を切り出すforeach (string x in AllPaths){int slash = x.LastIndexOf("/");int dot = x.LastIndexOf(".");sceneNames.Add(x.Substring(slash + 1, dot - slash - 1));}return sceneNames;}}
Scene名のList

*List<string> AllPaths = (from scene in EditorBuildSettings.scenes where scene.enabled select scene.path).ToList();
BuildSettingsからSceneのPathを読み込む

*public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)*{var list = AllSceneName;var selectedIndex = list.FindIndex(item => item.Equals(property.stringValue));if (selectedIndex == -1){selectedIndex = list.FindIndex(item => item.Equals(list[0]));}selectedIndex = EditorGUI.Popup(position, label.text, selectedIndex, list.ToArray());property.stringValue = list[selectedIndex];}
ドロップダウンメニューの作成

*[SerializeField, SceneChangerAttribute]
どんな名前でもいいのでstring型のフィールドに付ける


*return Code.GetHashCode() ^ Level.GetHashCode();
Tuple の実装があればこっちの方がイケてる気がする
return Tuple.Create(Code, Level).GetHashCode();


*int count = this.Count;
終端がNULLの場合、除外する


*Console.WriteLine("文字数が5文字を超えるのは：" + index6 + "番目の要素でした。");
出力:文字数が5文字を超えるのは：2番目の要素でした。


*var isUpdatedSubject1 = subject1.Timestamp > subject2.Timest
TimeStampを見て、新しい方が今流れてきたと判断


*hoge.StartInstantiate();
registInstantiateで登録したアクションを一気に動かす


*var dtoes = new List<Dto>();
NG1 戻り値がなく、引数を更新しているのにGetメソッド

*dtoes = SetData();
NG2 戻り値があるのにSetメソッド

*var dto2 = SetDto2();
NG3 正しいSetterが混在していて読みにくい

*dtoes.Add(new Dto());
DBから取得する想定。

*var dtoes = new List<Dto>();
DBから取得する想定。

*var dtoes = new List<Dto>();
OK 引数更新

*dtoes = GetData();
OK 戻り値が取得データになっている。

*var dto2 = GetDto2();
OK GetterとSetterが統一されて読みやすくなった。

*dtoes.Add(new Dto());
DBから取得する想定。

*var dtoes = new List<Dto>();
DBから取得する想定。


*public class Enemy{public string name;public int hp;public int attack;public Enemy(){}public Enemy(string name, int hp, int attack){this.name = name;this.hp = hp;this.attack = attack;}// ステータスをコンソールに表示public void DebugStatus(){// string.Formatを使うと， + でつなげるよりも見た目わかりやすく文字を連結できる．Debug.Log (string.Format ("名前; {0}, HP: {1}, 攻撃; {2}", name, hp, attack));}}
敵

*public void DebugStatus(){// string.Formatを使うと， + でつなげるよりも見た目わかりやすく文字を連結できる．Debug.Log (string.Format ("名前; {0}, HP: {1}, 攻撃; {2}", name, hp, attack));}
ステータスをコンソールに表示

*Debug.Log (string.Format ("名前; {0}, HP: {1}, 攻撃; {2}", name, hp, attack));
string.Formatを使うと， + でつなげるよりも見た目わかりやすく文字を連結できる．


*process.StartInfo.CreateNoWindow = true;
not show cmd window


*Thread.Sleep(100);
時間のかかる処理を想定


*return book;
Bookオブジェクトを返す


*f.ShowDialog(this);
親はthis、つまり「form親」だよの設定。

*label1.Text = Form親.Form親Instance.TargetStr;
Form親の変数を取得

*Form親.Form親Instance.TargetStr = "ABCDE";
Form親の変数を書き換えちゃう

*label1.Text = Form親.Form親Instance.TargetStr;
Form親の変数を取得


*.ToList()
ConvertAll メソッドを使用するため一旦 List に変換する

*var resultList2 = list.Where(x => x % 2 == 0)
FindAll メソッドを Where メソッドに、ConvertAll メソッドを Select メソッドに書き換え（処理は同じ）

*var resultList3 =
クエリ構文で書き換え（処理は同じ）
（実は最初に紹介した「LINQ の典型的な例」と同じ）

*========================================var resultList1 = list.Where(x => x % 2 == 0)
LINQ を使って実装

*var resultList1 = list.Where(x => x % 2 == 0)
========================================

*// LINQ は使わず、foreach と for を使って実装*// ========================================
========================================

*========================================var resultList2 = new List<int>();
LINQ は使わず、foreach と for を使って実装


*.Subscribe(...)
thisが死んだら OnCompleted() からの Dispose()


*parameters ["id"] = tweet.id_str;
リツイートするツイートのID


*[Sort(0)]*public string FirstName { get; set; }
Attributeは省略できる

*var entitys = new List<Entity>() {new Entity() { LastName = "Ono", FirstName = "Shinji", Age = 37 },new Entity() { LastName = "Honda", FirstName = "Keisuke",  Age = 30 },new Entity() { LastName = "Nakayama", FirstName = "Masashi", Age = 49 },};
出力する内容

*.Where(e => Attribute.IsDefined(e, typeof(SortAttribute)))
SortAttribute属性が設定されているプロパティのみ対象

*.OrderBy(e => ((SortAttribute)Attribute.GetCustomAttribute(e, typeof(SortAttribute))).SortIndex)
SortAttribute属性のSortIndexプロパティでソート

*.Select(e => e.Name);
プロパティ名を取得

*result.AppendLine(string.Join(",", propertyNames));*foreach (var entity in this.Entitys) {//要素出力var element = propertyNames.Select(n => typeof(T).GetProperty(n).GetValue(entity));result.AppendLine(string.Join(",", element));}
ヘッダー出力

*var element = propertyNames.Select(n => typeof(T).GetProperty(n).GetValue(entity));
要素出力

*var entitys = new List<Entity>() {new Entity() { LastName = "Ono", FirstName = "Shinji", Age = 37 },new Entity() { LastName = "Honda", FirstName = "Keisuke",  Age = 30 },new Entity() { LastName = "Nakayama", FirstName = "Masashi", Age = 49 },};
出力する内容


*string summary = null;
管理者向けには詳細ログを表示する。

*SetSummary(summary);
関数呼び出しの部分を条件分岐から分離した。


*[SerializeField]
クロスフェードに使用するImageオブジェクト

*[SerializeField]
テクスチャ1枚目

*[SerializeField]
テクスチャ2枚目

*[SerializeField]
変化の速度 (秒)

*Material material = ImageUI.GetComponent<Image>().material;
Imageのマテリアルを取得

*material.SetFloat("_Blend", 0.0f);
ブレンド率を0.0に設定

*material.SetTexture("_Texture1", Texture1);
テクスチャを設定する

*material.DOFloat(1.0f, "_Blend", Speed).SetLoops(-1, LoopType.Yoyo);
ブレンド率を操作する (DoTweenを使用しています)


*sumDelegate sumDele = Sum;
メソッドをデリゲートに代入

*sumDele(1, 2);
引数を入れて、Sumメソッドを使う

*FormClosed += new FormClosedEventHandler(Form1_FormClosed);
フォームクローズイベントに、Form1_FormClosedメソッドの処理を追加する

*MessageBox.Show(sender.ToString() + "\n" + e.ToString() + "\n" + e.CloseReason.ToString());
1行目：1つ目の引数確認
2行目：2つ目の引数確認
3行目：ついでにイベント発生原因を格納したプロパティ確認

*FormClosed += new FormClosedEventHandler(Form1_FormClosed);
フォームクローズイベントに、Form1_FormClosedメソッドの処理を追加する

*FormClosedEventArgs sample = new FormClosedEventArgs(CloseReason.WindowsShutDown);
FormClosedEventArgsクラス作成
引数に、フォームが閉じられた理由を渡す
(今回は「ウィンドウズがシャットダウンされるから」という理由にしてます)

*Form1_FormClosed(this, sample);
フォームコントロールとFormClosedEventArgsオブジェクトを渡して呼び出し


*var a = 0;
ダメなコメントのパターンです。

*var a = 0;
コメントは別の行に記述します。

*}
処理

*public int MyProperty { get; set; } = 0;
prop -> tab -> tabで補完できます。

*public int MyConstructor { }
ctor -> tab -> tabで補完できます。

*this.Click += this.SampleForm_OnClick;
推奨する記法(C#2.0)
Event名 += -> tab -> tabで補完できます。

*this.Click += new EventHandler(this.SampleForm_OnClick);
古い記法(C#1.0)

*this.Click += delegate(object s, EventArgs e) =>*{// TODO: 処理};
匿名メソッド(C#2.0)

*};
TODO: 処理

*this.Click += (s, e) =>*{// TODO: 処理};
ラムダ式(C#3.0)

*};
TODO: 処理

*}
TODO: クリックされたときの処理を実装します。

*if (!isNotFound)*if (!IsNotNull())
二重否定

*if (Exists())*if (Contains())
肯定形

*var mean = (a + b) / 2;
文脈から意味が読み取れる場合

*if ((a >= 90 && a <= 180) ||*(a >= 270 && a <= 360))
比較演算子の左を主とした場合

*if ((90 <= a && a <= 180) ||*(270 <= a && a <= 360))
比較演算子の向きを揃えた場合

*var evenMax = 0;
通常のループ

*var oddMin = decimals.Where(x => (x % 2) == 1)
LINQ(メソッド構文 + ラムダ式)

*var averageAgeOfMan = (from person in personswhere (person.Sex == Sex.Man)
LINQ(クエリ構文)

*if (obj != null &&*obj.Value is int)
古い記法(C#1.0)

*var instance = obj as IDisposable;
as演算子

*// while ((len--) > 0)と等価*var len = 100;
特異な記述

*var len = 100;
while ((len--) > 0)と等価

*}
99 .. 0 のループ

*}
99 .. 0 のループ

*}
処理

*db.Rollback();
原因を呼び出し元に伝える場合

*Debug.WriteLine(ex.ToString());
原因の詳細がそれ以上必要ない場合

*byte[] bytes1 = new byte[2] { 0x00, 0xFF };
Array

*Thread.Sleep(ms);
古い書き方
スレッドごと停止します。

*Task.Delay(ms).Wait();
.NET4以降

*await Task.Delay(ms);
asyncメソッド内であればawaitを使います。

*var coord = $"({x}, {y})";
var coord = String.Format("({0}, {1})", x, y);

*var percent = $"f={f:P2}";
f=10.00%

*var currency = $"yen={yen,10:C}";
yen=    \1,000

*var hex = $"b=0x{b,-5:X4}";
b=0x00FF

*//var date = String.Format("{0:yyyy/MM/dd HH:mm:ss.fff}", DateTime.Now);
var date = DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss.fff");

*var date = $"{DateTime.Now:yyyy/MM/dd HH:mm:ss.fff}";
var date = String.Format("{0:yyyy/MM/dd HH:mm:ss.fff}", DateTime.Now);

*var date = $@"{TimeSpan.MaxValue:yyyy\/MM\/dd HH\:mm\:ss\.fff}";
var date = TimeSpan.MaxValue.ToString(@"yyyy\/MM\/dd HH\:mm\:ss\.fff")


*using (var g = new TFGraph ()) {セッションの作成。var s = new TFSession (g);
グラフを作成。

*var s = new TFSession (g);
セッションの作成。

*var feed = g.Placeholder (TFDataType.Int32);
ここでは "int"を使用するので、演算時のキャストはintにする。
placeholderというデータが格納される箱(値は実行時に入れる).引数として予めグラフに与える。

*var x = g.Const (2);
中身が2のconstantの作成。

*var x2 = g.Square (x);
xの2乗を求める。

*var add = g.Add (x2, feed);
和を求める。

*var runner = s.GetRunner ();
runnerの作成。

*runner.AddInput (feed, new TFTensor ((int)3));
Placeholderに値を入れる。

*Console.WriteLine ("2^2 + 3 ={0}", runner.Run (add).GetValue ());
実行及び結果表示


*List<Hoge> hogeList = Enumerable.Range(0, 10).Select(i => new Hoge { i = i * 10 }).ToList();
List<T>


*if (progressCounter != null)
なんらかの処理
進捗表示

*var progressCounter = new Modify.ProgressCounter();*var something = new Qiita.CounterOK.Something(progressCounter);
改良後

*_progressCounter.MaxCount = maxCount;
nullの代わりにNullObjectを渡してくる前提のため、nullチェックはしない。

*_progressCounter.Update(i + 1);
なんらかの処理
進捗表示


*var text = "hoge foo  bar　Hoge　　Foo";
半角空白, 連続半角空白, 全角空白, 連続全角空白


*reportProgress(progressCount, num);
進捗%更新

*return Task.WhenAll(taskList.ToArray());
このメソッドからの戻り値


*case 11:
throw の改善

*object o = "3";
ここの代入値を変更してみる。

*FuncHypo Hypo = (double x, double y) => Math.Sqrt(x * x + y * y);
ラムダ式で定義したローカル関数

*double hypotenuse(double x, double y)*{return Math.Sqrt(x * x + y * y);}
ローカル関数(新機能)

*ref int p = ref findIt(3, arry);
3 の参照が返される。

*p = -1;
参照なので p を変更すれば配列の要素が変更される。

*public string Name*{get => name == null ? "NULL" : name;set => name = value;}
=> を使ってメソッド本体を書けるようになった。

*public int Length => 0;
Read Only の場合はこういう書き方ができる。

*public int getValue() => throw new NotImplementedException();
ラムダ式のように throw を書ける。


*InitializeView(id);
画面の初期表示処理

*_table1Rows = GetTable1Rows(id);
画面の初期表示処理

*SetView();
画面へ設定する。


*public abstract class FaceDetectBase : IUWPBridgeService*{public delegate void SetFaceObject(List<FaceInformation> list);public int FrameSizeWidth;public int FrameSizeHeight;public SetFaceObject OnDetected;public abstract void DetectFace();}
http:opensource.org/licenses/mit-license.php

*private void Update()*{if (Time.frameCount % FRAME_INTERVAL == 0){if (Service == null){#if UNITY_EDITOR// For Debug.when this application execute by unity,call this.Service = new FaceDetectStub();#else// execute For HoloLens.Service = UWPBridgeServiceManager.Instance.GetService<FaceDetectBase>();TextData.text = "Service Initialized.";#endifService.OnDetected = SetFaceObject;}Service.DetectFace();}}
http:opensource.org/licenses/mit-license.php

*public override void DetectFace()*{AppCallbacks.Instance.InvokeOnUIThread(async () =>{var properties =_capture.VideoDeviceController.GetMediaStreamProperties(MediaStreamType.VideoPreview) asVideoEncodingProperties;if (properties == null)return;//coution! face detect is only supported 'BitmapPixelFormat.Gray8'.var videoFrame = new VideoFrame(BitmapPixelFormat.Gray8, (int) properties.Width, (int) properties.Height);this.FrameSizeWidth = (int) properties.Width;this.FrameSizeHeight = (int) properties.Height;var previewFrame = await _capture.GetPreviewFrameAsync(videoFrame);var detector = await FaceDetector.CreateAsync();var detectFaces = await detector.DetectFacesAsync(previewFrame.SoftwareBitmap);var faceInformations = detectFaces.Select(x => new FaceInformation{X = x.FaceBox.X,Y = x.FaceBox.Y,Width = x.FaceBox.Width,Height = x.FaceBox.Height}).ToList();AppCallbacks.Instance.InvokeOnAppThread(() => { OnDetected(faceInformations); }, false);}, true);}
http:opensource.org/licenses/mit-license.php


*public class Lazy<TParam, TOut>*{protected TParam param;protected TOut value;protected Func<TParam, TOut> provider;public Lazy(TParam param, Func<TParam, TOut> provider){this.param = param;this.provider = provider;}public TOut Value{get { return value != null ? value : (value = provider(param)); }}}
Basic

*public sealed class LazyObject<T> : Lazy<object, T>*{public LazyObject(Func<T> provider) : base(null, o => provider()){}}
Without initialization params

*public sealed class LazyResource<T> : Lazy<string, T> where T : UnityEngine.Object*{public LazyResource(string path) : base(path, Resources.Load<T>){}}
Resource


*Vector3 diff = transform.position - latestPos;*latestPos = transform.position;
ワールドでの移動量

*localDiff = transform.InverseTransformDirection(diff.normalized);*tiltVector = new Vector3(
ローカル用に変換する


*using (WebApp.Start<StartUp>("http:
*:8080"))


*private void Update()*{if (Service == null){#if UNITY_EDITOR// For Debug.when this application execute by unity,call this.Service = new SampleStub();#else// execute For HoloLens.Service = UWPBridgeServiceManager.Instance.GetService<ISampleService>();#endifService.OnDetected = SetFaceObject;}Service.DetectFace();}
http:opensource.org/licenses/mit-license.php


*1.0f
アニメーション時間

*seq.Append(rectTransform.DOLocalMove(Vector3.one, 1.0f)
(1,1,1)に移動

*seq.Append(rectTransform.DOScale(Vector3.zero, 1.0f)
(0,0,0)にスケーリング

*seq.Append(rectTransform.DOLocalMove(Vector3.one, 1.0f)
(1,1,1)に移動

*seq.Join(rectTransform.DOScale(Vector3.zero, 1.0f)
(0,0,0)にスケーリング

*});*hoge.OnUpdate(() => {// 対象の値が変更される度によばれる});
アニメーション開始時によばれる

*});*hoge.OnComplete(() => {// アニメーションが終了時によばれる});
対象の値が変更される度によばれる

*});
アニメーションが終了時によばれる


*rb.angularVelocity = Vector3.zero;
回転運動の停止


*connection.ConnectionString = String.Format("Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST={0})(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=gounn.WH))); User Id=test;Password=fuga", "192.168.64.190");
or 192.168.64.173

*public class FactoryViewModel*{// 選択肢の値をセットします。public string Value { get; set; }// 選択肢として表示するテキストを取得するためのプロパティ。public string DisplayText{get{return $"{this.Value}";}}}
ドロップダウンリストの選択肢を表す ViewModel です。

*public string Value { get; set; }
選択肢の値をセットします。

*public string DisplayText*{get{return $"{this.Value}";}}
選択肢として表示するテキストを取得するためのプロパティ。

*public class DropDownListViewModel
ページに必要な情報を全て持つ ViewModel です。
View はこの ViewModel から値を取得するようにしています。

*public string Factory { get; set; }
ドロップダウンリストで選択している値を取得または設定するためのプロパティです。

*// ※ ViewBag で代用も可能。*public IEnumerable<FactoryViewModel> FactoryOptions { get; set; }
ドロップダウンリストの選択肢をセットします。

*public IEnumerable<FactoryViewModel> FactoryOptions { get; set; }
※ ViewBag で代用も可能。

*vm.FactoryOptions = this.GetFactoryOptions();
ここでビューモデルに選択肢をセットしています。

*vm.FactoryOptions = this.GetFactoryOptions();
もう一度ビューモデルに選択肢をセットしています。
Post されてこの箇所に来た時点で、
FactoryOptions プロパティは null になっているので、
再度セットする必要があります。

*private IEnumerable<FactoryViewModel> GetFactoryOptions()*{string[] sourceDatas = new string[] { "Context190", "Context173" };return sourceDatas.Select(t => new FactoryViewModel() { Value = t });}
工場一覧の選択肢を取得するためのメソッドです。


*var conn = new HubConnection("http:
~~~~~~~~~~~.azurewebsites.netsignalr");


*else { dishes[dishes.Count-1].Add(a); }
要素数-1 で最後の要素

*int i = 0;
結果


*using RabbitMQ.Client;
Execute : Command :  バックグラウンドで実行する
: nohup ./tamesi33a2_cs.exe > ./tamesi33a2_cs.out.log 2> ./tamesi33a2_cs.err.log < /dev/null &
Check   :         :  tamesi33a1_cs.exe を使う
--------------------------------------------------------------------------------
tamesi33a2_cs.cs
Ubuntu の RabbitMQ はソースのバージョンが古いのか、API が異なった。
#define UBUNTU

*public static RotationBuffer rollingBuffer = new RotationBuffer();
回転式バッファー

*m_channels_[index].QueueDeclare(QUEUE_NAMES[index], false, false, false, false, false, null);
Ubuntuでは何故か Spring.Messaging.Amqp.Rabbit の引数 7 つのやつになっている。

*m_consumers_[index] = new EventingBasicConsumer();
Ubuntuでは何故か v1.4.0 の引数が 0 個のやつになっている。調べたが引数が1個～6個のものは無かった。

*message += "daze";
末尾に daze を付ける。

*rollingBuffer.PutMessage(message);
回転式バッファーに入れる

*StartDequeue();
常時監視をスタート

*Enqueue(message);
エンキューする

*}
このプログラムは、自分では接続を切らない。

*CloseChannel(ENQUEUE_INDEX);
対応するオープンは無いが、ちゃんと閉じないと、レシーブしてくれない。

*consumer.Received += GetReceiveHandler();
受信できたときに割り込んでくる処理

*channel.BasicConsume( QUEUE_NAMES[DEQUEUE_INDEX], true, "", null, consumer);
Ubuntuでは何故か引数が 5 個のやつになっている。

*}
割込み処理の削除
consumer.Received -= GetReceiveHandler();
対応するオープンは無いが、ちゃんと閉じないと、レシーブしてくれない。
CloseChannel(DEQUEUE_INDEX);


*void Start()*{Debug.Log("上書きされた");}
Start is called before the first frame update


*publisherList.Items.Add(publisherName);
出版社のListBoxに値をセット


*var vInfo = typeof(Hoge).GetField("v", BindingFlags.NonPublic | BindingFlags.Instance);
privateなフィールド、メソッドにアクセスするためにリフレクションを使用する

*var hoge = FormatterServices.GetUninitializedObject(typeof(Hoge)) as Hoge;
コンストラクタを呼ばずにインスタンスを作成

*var result = heavyFuncInfo.Invoke(hoge, null);
HeavyFuncを実行する

*vInfo.SetValue(hoge, result);
フィールドに値をセット

*Debug.Log(hoge.Value);
正しくインスタンスが作成されている

*Debug.Log($"Application.isPlaying:{Application.isPlaying}");
Application.isPlayingはメインスレッドで呼ばなければ例外が発生する

*v = HeavyFunc();
コンストラクタで重い処理をしている

*Thread.Sleep(5000);
重い初期化処理

*return 42;
計算結果


*ProcessStartInfo psUE4Exe = new ProcessStartInfo();
UE4exeを起動する

*System.Threading.Thread.Sleep(5000);
5秒後間スリープ

*ps.Kill();
プロセスを殺す

*ProcessStartInfo psUE4Exe = new ProcessStartInfo();
UE4exeを起動する

*System.Threading.Thread.Sleep(1000 * 10);
10秒後間スリープ

*System.Diagnostics.Process[] ps = System.Diagnostics.Process.GetProcessesByName(killProcessName);
UE4Gameに一致するプロセスを殺す

*ProcessStartInfo psUE4Exe = new ProcessStartInfo();
UE4exeを起動する

*System.Threading.Thread.Sleep(1000 * 10);
10秒後間スリープ

*System.Diagnostics.Process[] ps = System.Diagnostics.Process.GetProcessesByName(killProcessName);
UE4Gameに一致するプロセスを殺す

*using (var results = search.Get().GetEnumerator()){if (!results.MoveNext()) throw new ApplicationException("Couldn't Get ParrentProcessId.");
クエリから結果を取得

*return (uint)queryResult["ParentProcessId"];
親プロセスのPIDを取得


*System.Diagnostics.Process.Start(e.Uri.AbsoluteUri);
絶対URIを起動

*e.Handled = true;
イベントを処理済みとしてマークする


*break;
条件不成立 (index >= list.Count) なら終了。


*startButtonL.IsEnabled = false;
ボタン無効化

*isCanceled = false;
キャンセルフラグ初期化

*statusLabelL.Text = "処理中...";
ステータス表示更新

*fileListL.Items.Clear();
リストボックスクリア

*bool complete = await TimeConsumingProcessLAsync();
時間のかかる処理呼び出し

*statusLabelL.Text = complete ? "処理完了しました。" : "処理を中断しました。";
ステータス表示更新

*startButtonL.IsEnabled = true;
ボタン有効化

*return false;
キャンセルされたら終了

*fileListL.Items.Add(item);
リストボックスにファイルパス追加

*await Task.Delay(1500);
（動作確認のため）1500ミリ秒待つ

*isCanceled = true;
キャンセルフラグ設定

*startButtonR.IsEnabled = false;
ボタン無効化

*statusLabelR1.Text = "処理中...";
ステータス表示更新

*fileListR.Items.Clear();
リストボックスクリア

*cts = new System.Threading.CancellationTokenSource();
キャンセル用トークンソース生成

*bool complete = await TimeConsumingProcessRAsync(cts.Token);
時間のかかる処理呼び出し

*statusLabelR1.Text = complete ? "処理完了しました。" : "処理を中断しました。";
ステータス表示更新

*startButtonR.IsEnabled = true;
ボタン有効化

*fileListR.Items.Add(item);
リストボックスにファイルパス追加

*await Task.Delay(1500, token);
（動作確認のため）1500ミリ秒待つ

*cts?.Dispose();
キャンセルされた
キャンセル用トークンソース解放

*statusLabelR2.Text = $"例外、OperationCanceledException:{ex.Message}";
ステータス表示更新

*return false;
終了

*MessageBox.Show(ex.Message);
例外発生

*cts.Cancel();
キャンセル要求


*if(hp < 5)
5より小さい


*var TItems = new ObservableCollection<TItem>();
実際にはバインドしている値なのでこの辺はイメージ

*var count = TItems.Sum(v => v.TreeCount());
欲しい値


*Console.Write(result);
計算結果を表示する
win.FindElementByUid("121").Click();                       =
var result = win.FindElementByUid("150").Properties.Name; 結果のテキスト

*private static readonly IDictionary<char, int> keyIds = new Dictionary<char, int>() .{{'.', 84}, {'/', 91}, {'*', 92}, {'+', 93}, {'-', 94}, {'=', 121},{'0', 130}, {'1', 131}, {'2', 132}, {'3', 133}, {'4', 134},{'5', 135}, {'6', 136}, {'7', 137}, {'8', 138}, {'9', 139},};
電卓のキーとidの対応表

*static void initializeLoggingRule() {
ログをコマンド用に設定する
Infoは出力しない
Warn以上を標準エラー出力に出す

*target.Error = true;
出力先を標準エラー出力へ

*var rule = new NLog.Config.LoggingRule("*", NLog.LogLevel.Warn, target);
Warning以上だけ表示

*static void checkAlreadyRunning() {var procname = System.IO.Path.GetFileNameWithoutExtension(calcPath);if (System.Diagnostics.Process.GetProcessesByName(procname).Any()) {Console.Error.WriteLine("error!, already running calc process");Environment.Exit(1);}}
対象のアプリが起動してないか？


*static void Main(string[] args)*{// 共通鍵を用意var keyString = "hogehogehogehoge";// トークン操作用のクラスを用意var handler = new System.IdentityModel.Tokens.Jwt.JwtSecurityTokenHandler();// 共通鍵なのでSymmetricSecurityKeyクラスを使う// 引数は鍵のバイト配列var key = new Microsoft.IdentityModel.Tokens.SymmetricSecurityKey(Encoding.UTF8.GetBytes(keyString));// 署名情報クラスを生成// 共通鍵を使うのでアルゴリズムはHS256使っとけばいいはずvar credentials = new Microsoft.IdentityModel.Tokens.SigningCredentials(key, "HS256");// トークンの詳細情報クラス？を生成var descriptor = new Microsoft.IdentityModel.Tokens.SecurityTokenDescriptor{Issuer = "GHKEN",SigningCredentials = credentials,};// トークンの生成//SecurityTokenDescriptor使わずにhandler.CreateJwtSecurityToken("GHKEN", null, null, null, null, null, credentials)でもOKvar token = handler.CreateJwtSecurityToken(descriptor);// トークンの文字列表現を取得var tokenString = handler.WriteToken(token);// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE0ODc4MjQ3MTQsImV4cCI6MTQ4NzgyODMxNCwiaWF0IjoxNDg3ODI0NzE0LCJpc3MiOiJHSEtFTiJ9.PJ-5KzFq7n2hBiJnoZMli0XajaJPNup0BztIO9QlDFYConsole.WriteLine(tokenString);Console.Read();}
issuerがGHKENのJWTを生成する

*var keyString = "hogehogehogehoge";
共通鍵を用意

*var handler = new System.IdentityModel.Tokens.Jwt.JwtSecurityTokenHandler();
トークン操作用のクラスを用意

*var key = new Microsoft.IdentityModel.Tokens.SymmetricSecurityKey(Encoding.UTF8.GetBytes(keyString));
共通鍵なのでSymmetricSecurityKeyクラスを使う
引数は鍵のバイト配列

*var credentials = new Microsoft.IdentityModel.Tokens.SigningCredentials(key, "HS256");
署名情報クラスを生成
共通鍵を使うのでアルゴリズムはHS256使っとけばいいはず

*var descriptor = new Microsoft.IdentityModel.Tokens.SecurityTokenDescriptor{Issuer = "GHKEN",SigningCredentials = credentials,};
トークンの詳細情報クラス？を生成

*var token = handler.CreateJwtSecurityToken(descriptor);
トークンの生成
SecurityTokenDescriptor使わずにhandler.CreateJwtSecurityToken("GHKEN", null, null, null, null, null, credentials)でもOK

*var tokenString = handler.WriteToken(token);
トークンの文字列表現を取得

*static void Main(string[] args)
共通鍵で署名されたトークンを検証する
トークンの内容は
aud: 空
iss: "GHKEN"
exp: 期限切れ

*var keyString = "hogehogehogehoge"; ;
鍵

*var handler = new System.IdentityModel.Tokens.Jwt.JwtSecurityTokenHandler();
トークン操作用のクラス

*var tokenString = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE0ODc4MjUxMjMsImV4cCI6MTQ4NzgyODcyMywiaWF0IjoxNDg3ODI1MTIzLCJpc3MiOiJHSEtFTiJ9.AJFdztPP3GOBBjtiJeHc6wvy5Z3idQW2yGw9yCd6_wc";
トークンの文字列表現

*// Audience, Issuer, Lifetimeに関してはデフォルトで検証が有効になっている*// audが空でexpが期限切れなのでValidateAudienceとValidateLifetimeはfalseにしておく
トークン検証用のパラメータを用意

*// audが空でexpが期限切れなのでValidateAudienceとValidateLifetimeはfalseにしておく*var validationParams = new Microsoft.IdentityModel.Tokens.TokenValidationParameters
Audience, Issuer, Lifetimeに関してはデフォルトで検証が有効になっている

*var validationParams = new Microsoft.IdentityModel.Tokens.TokenValidationParameters{ValidateAudience = false,ValidIssuer = "GHKEN",ValidateLifetime = false,IssuerSigningKey = key,};
audが空でexpが期限切れなのでValidateAudienceとValidateLifetimeはfalseにしておく

*handler.ValidateToken(tokenString, validationParams, out token);
第三引数にSecurityToken型の変数を参照で渡しておくと、検証済みのトークンが出力される

*Console.WriteLine("トークンが無効です: " + e.Message);
ValidateTokenで検証に失敗した場合はここにやってくる

*var keyString = "<RSAKeyValue><Modulus>yT12/iqZLNcrnTTFGy3NMuCjo6wJNLuG5j5L2yM6iX7CT5sWVq2BuXtdbq6PFuOIkzwJ+5Sng+qthAX5qHnuxRMI+QITe1qP+k0pOtK/EVtuedz6zdu2+Sp24CvGIMt1y8yMeOBXrRZTZzxpH9VsSq9kA/ylHKuWRfWLHysIqsdO0Tgf9eLwNAhRr6vpkvsAwvJnreIdWr/7aTrt9vq3EIJI3NYHV7/zqbZ7mKS1GbvJkAMbrQkYJ45hhEBUdYE45V8Dhkb9NTlExIcrar3vqsXSOVjQvuiGN4HsYmqPGUw26P9F7DrPyM4eQksb+PRMdkPW4dTjIRj9X3OIBHXrBw==</Modulus><Exponent>AQAB</Exponent><P>8Qw9p6A+11Tu6Dsl6+ndb7qiQP3u4cE5JMDRuq71A11XiEKU9K+1j5O26TtcJaJUCeH01RCKvMa/hNp2G7NqPnjxpRQU06Vj+bvJono7YTHcScC4Apa8cSsFQ62Iu2jpoHIkEz/5j7EdkToyFpC4opxbcHANPc9lXwfjIJTyieE=</P><Q>1bkXNBVazXVSGaP2DXVSSme9uXF5DmiEdKbpqRY6hlW+wIUBOG3RStkPC5ah62+3ObAooehVveR+kJOmSl2qLYvSaqV/DPkTyRyFOpTlpOSpLBsRvzPMoA7BFweXiy3YIbDsSr7S1qC1JgoMK4Htz742tDXLBUM32SWZr9OFoec=</Q><DP>aE8rvwYRK42NdOFjn5ssP9U7sXQxk2/SEp1+JJLhY/tYjZaCbwA6SU9ar8MINSDxzPUCxdDKuLYo2ozO313cc/xSVWVDPfMsOD2TG8RZPc4dzayf9D7WfQJo3MiTisXzk4LRKaNdk1jJura8RheKTpPq3dUfZcgBzgXTu5249wE=</DP><DQ>E8JP9d2/jl05YOt6tRXSrNRYgwuNoJpjHJHN6ncGpCLLRutFCJ2Giv/0VyLvB2BFtUynBQkA3FSCqwUri5aLRDi4FGoGjAF/JcnAO4FGle8aANzj0CSO14FlsqZeCV0MrVi5D9QClBs5hDHLnD4f6WPxlMmgYnUrdaT3R30rzqM=</DQ><InverseQ>dSfitpkpXxGrKbPA4HxVtSZU71tWOMbvIjYKy8cYTw+/EsQ7LW84Q1I8WDrbB7m/Zj67EufC2n1VNaP+x9dOCXpud+R/48piD2bp5JDCv5wUSs7xsjPsx8o1ScrHaXOeySQ486HTLji4RaqiiD1I46fF6NV1ZKRmOSUmMInxDDM=</InverseQ><D>DqjBkEY+HjwWWz9K1G4Dsp8WjIetq/+1FfSXxgDM9NMdCHt9pxbAimhoJ/XjSoGMo10ORRtREJT5ytI8m382W3jFgI4cKTIxpsQUKsrLTFJiu9HTG0fUDlZ/jljh9+WaURw3Z17AREWKEc0ew0jiuJYKLRgsVuhQ7Au09LJH0VjOTj9h62Trb2srbz/s+XjnTi8cch6oSBeqV/2YbYQla9bAMswR84fRRNUonDPrYvwC5rnhw5Xp0vJueHZpmTsruXjQJasue/Tgp/p6CsZlZX1CvTX8muSROyJ8vCjbG1dGplx+3Jbca+RoXj1FajdlmfrZxvDiH+v4M2mLenuDgQ==</D></RSAKeyValue>";
秘密鍵を用意

*var rsa = new System.Security.Cryptography.RSACryptoServiceProvider();
RSAを使うのでRsaSecurityKeyを使う

*var handler = new System.IdentityModel.Tokens.Jwt.JwtSecurityTokenHandler();
トークン操作用のクラスを用意

*var credentials = new Microsoft.IdentityModel.Tokens.SigningCredentials(key, "RS256");
署名情報クラスを生成
非対称鍵を使うのでアルゴリズムはRS256使っとけばいいはず

*var descriptor = new Microsoft.IdentityModel.Tokens.SecurityTokenDescriptor{Issuer = "GHKEN",SigningCredentials = credentials,};
トークンの詳細情報クラス？を生成

*var token = handler.CreateJwtSecurityToken(descriptor);
トークンの生成
SecurityTokenDescriptor使わずにhandler.CreateJwtSecurityToken("GHKEN", null, null, null, null, null, credentials)でもOK

*var tokenString = handler.WriteToken(token);
トークンの文字列表現を取得

*var keyString = "<RSAKeyValue><Modulus>yT12/iqZLNcrnTTFGy3NMuCjo6wJNLuG5j5L2yM6iX7CT5sWVq2BuXtdbq6PFuOIkzwJ+5Sng+qthAX5qHnuxRMI+QITe1qP+k0pOtK/EVtuedz6zdu2+Sp24CvGIMt1y8yMeOBXrRZTZzxpH9VsSq9kA/ylHKuWRfWLHysIqsdO0Tgf9eLwNAhRr6vpkvsAwvJnreIdWr/7aTrt9vq3EIJI3NYHV7/zqbZ7mKS1GbvJkAMbrQkYJ45hhEBUdYE45V8Dhkb9NTlExIcrar3vqsXSOVjQvuiGN4HsYmqPGUw26P9F7DrPyM4eQksb+PRMdkPW4dTjIRj9X3OIBHXrBw==</Modulus><Exponent>AQAB</Exponent></RSAKeyValue>"; ;
公開鍵を用意

*var rsa = new System.Security.Cryptography.RSACryptoServiceProvider();
RSAを使うのでRsaSecurityKeyを使う

*var handler = new System.IdentityModel.Tokens.Jwt.JwtSecurityTokenHandler();
トークン操作用のクラス

*var tokenString = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE0ODgyNjgyNDgsImV4cCI6MTQ4ODI3MTg0OCwiaWF0IjoxNDg4MjY4MjQ4LCJpc3MiOiJHSEtFTiJ9.qgyYG-q8-aDdjabt-Wp3dn3wNVIu8WGP2n8Mnv_AxrFY98Abmb96M_SP3dnZI3mDKk5NC3QYKf42cbvu20DbAAdiawAVclLMXYBgKZJqHc-5Wkq7PsGA9ECoVE2KLzKGisqHFrZUm-kv51gdCegPsANm0ukdp5CWAy26Em1og02WG9--q0peGOWgYjtE5V2sM8b861QtAsWUtUSKs6kf_r9c5bcvN2xFS4_iw5luVY0u4dSjdeaaeIOjMqLCpZaelleTAubyEdoJ89J9vz6gj6ghzYe9dvND_mlUYpfiperSceSR8eKLPtwsno0zn7DaYYqcMI5uERqUtj2YKWcIgg";
トークンの文字列表現

*// Audience, Issuer, Lifetimeに関してはデフォルトで検証が有効になっている*// 今回発行したトークンの内容
トークン検証用のパラメータを用意

*var validationParams = new Microsoft.IdentityModel.Tokens.TokenValidationParameters
Audience, Issuer, Lifetimeに関してはデフォルトで検証が有効になっている
今回発行したトークンの内容
Audience: 空なので検証スキップ
Issuer: "GHKEN"
Lifetime: 期限切れなので検証スキップ

*handler.ValidateToken(tokenString, validationParams, out token);
第三引数にSecurityToken型の変数を参照で渡しておくと、検証済みのトークンが出力される

*Console.WriteLine("トークンが無効です: " + e.Message);
ValidateTokenで検証に失敗した場合はここにやってくる


*byte[] byteArray = BitConverter.GetBytes(sJisCharCode);
コードからbyteを取得(4byte)

*byte[] rtn = new byte[2];
ShiftJISは2byteのため、4→2byteに変換する

*rtn = Convert2To1ByteIfNeeded(rtn);
1バイト文字の場合は2→1バイトに変換する

*else*{return checkArray;}
2バイト文字


*public enum MonitorDefaultTo { Null, Primary, Nearest }
MonitorFromWindowが返したディスプレイの種類

*enum MonitorDpiType { Effective, Angular, Raw, Default = Effective }NativeMethodsclass NativeMethods {ウィンドウハンドルから、そのウィンドウが乗っているディスプレイハンドルを取得[DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]public static extern IntPtr MonitorFromWindow(IntPtr hwnd, MonitorDefaultTo dwFlags);
GetDpiForMonitorが返したDPIの種類

*class NativeMethods {// ウィンドウハンドルから、そのウィンドウが乗っているディスプレイハンドルを取得[DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]public static extern IntPtr MonitorFromWindow(IntPtr hwnd, MonitorDefaultTo dwFlags);// ディスプレイハンドルからDPIを取得[DllImport("SHCore.dll", CharSet = CharSet.Unicode, PreserveSig = false)]public static extern void GetDpiForMonitor(IntPtr hmonitor, MonitorDpiType dpiType, ref uint dpiX, ref uint dpiY);}
NativeMethods

*[DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]public static extern IntPtr MonitorFromWindow(IntPtr hwnd, MonitorDefaultTo dwFlags);
ウィンドウハンドルから、そのウィンドウが乗っているディスプレイハンドルを取得

*[DllImport("SHCore.dll", CharSet = CharSet.Unicode, PreserveSig = false)]public static extern void GetDpiForMonitor(IntPtr hmonitor, MonitorDpiType dpiType, ref uint dpiX, ref uint dpiY);
ディスプレイハンドルからDPIを取得

*Dpi GetDpi() {// 当該ウィンドウののハンドルを取得するvar helper = new WindowInteropHelper(this);var hwndSource = HwndSource.FromHwnd(helper.Handle);// ウィンドウが乗っているディスプレイのハンドルを取得するvar hmonitor = NativeMethods.MonitorFromWindow(hwndSource.Handle, MonitorDefaultTo.Nearest);// ディスプレイのDPIを取得するuint dpiX = Dpi.Default.X;uint dpiY = Dpi.Default.Y;NativeMethods.GetDpiForMonitor(hmonitor, MonitorDpiType.Default, ref dpiX, ref dpiY);return new Dpi(dpiX, dpiY);}
現在のディスプレイにおけるDPIを取得する

*var helper = new WindowInteropHelper(this);
当該ウィンドウののハンドルを取得する

*var hmonitor = NativeMethods.MonitorFromWindow(hwndSource.Handle, MonitorDefaultTo.Nearest);
ウィンドウが乗っているディスプレイのハンドルを取得する

*uint dpiX = Dpi.Default.X;
ディスプレイのDPIを取得する

*protected override void OnSourceInitialized(EventArgs e) {base.OnSourceInitialized(e);// 最初にDPIを取得するResizeWindowByDpi(GetDpi());}
初期化直後の処理

*ResizeWindowByDpi(GetDpi());
最初にDPIを取得する

*enum WindowMessage { DpiChanged = 0x02E0 }フックするルーチンprotected override void OnSourceInitialized(EventArgs e) {base.OnSourceInitialized(e);
DPI変更時に飛んでくるウィンドウメッセージ

*protected override void OnSourceInitialized(EventArgs e) {base.OnSourceInitialized(e);// ウィンドウメッセージを取得するvar helper = new WindowInteropHelper(this);var source = HwndSource.FromHwnd(helper.Handle);source.AddHook(new HwndSourceHook(WndProc));}
フックするルーチン

*var helper = new WindowInteropHelper(this);
ウィンドウメッセージを取得する

*IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled) {if(msg == (int)WindowMessage.DpiChanged) {// wParamの下位16bit・上位16bitがそれぞれX・Y方向のDPIを表しているvar dpiX = (uint)wParam & 0xFFFF;   //下位16bitvar dpiY = (uint)wParam >> 16;      //上位16bitResizeWindowByDpi(new Dpi(dpiX, dpiY));handled = true;}return IntPtr.Zero;}
ウィンドウプロシージャ

*ResizeWindowByDpi(new Dpi(dpiX, dpiY));
wParamの下位16bit・上位16bitがそれぞれX・Y方向のDPIを表している
var dpiX = (uint)wParam & 0xFFFF;   下位16bit
var dpiY = (uint)wParam >> 16;      上位16bit


*string computerName = Environment.MachineName;
コンピューター名を取得する

*byte[] sid;
SID取得

*throw new Win32Exception(lastError);
ここもコンストラクターは空でいい気もするけど気分的にこのまま

*sid = new byte[sidLen];
SIDを取得する

*IntPtr pSidString;*if (!ConvertSidToStringSid(sid, out pSidString)) {throw new Win32Exception();}
SIDを文字列に変換する

*string sidString = Marshal.PtrToStringUni(pSidString);
stringに変換


*detail += "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
効率悪い例：

*StringBuilder retSb = new StringBuilder();
改善例：


*public SampleUserControl()*{InitializeComponent();/* 初期化処理など */this.Disposed += (sender, args) =>{//// ここに後処理を記述//};}
コンストラクタ

*};
ここに後処理を記述



*private bool disposedValue = false;
To detect redundant calls

*// ~CSVWriter() {//   // Do not change this code. Put cleanup code in Dispose(bool disposing) above.//   Dispose(false);// }
TODO: override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources.

*public void Dispose()*{// Do not change this code. Put cleanup code in Dispose(bool disposing) above.Dispose(true);// TODO: uncomment the following line if the finalizer is overridden above.// GC.SuppressFinalize(this);}
This code added to correctly implement the disposable pattern.


*DateTimeOffset.Now.ToOffset(TimeSpan.FromHours(2.5))
UTC+2.5のタイムゾーンは存在しないはず・・・

*,,,
日本時間(JST)に変換する
DateTimeOffset.Now.ToOffset(TimeSpan.FromHours(9))  JST以外に設定されている場合にエラー

*...
端末のタイムゾーンが切り替わる


*public static IEnumerable<int> HighlyCompositeNumber(int limit)*{var maxDivisorCount = 0;for (int i = 2; i < limit; i++){var divisorCount = CountDivisor(i);if (maxDivisorCount < divisorCount){yield return i;maxDivisorCount = divisorCount;}}}
result:2,4,12,24,36,60,120,180,240,360,720,840,1260,1680,2520,5040,7560


*private bool disposedValue = false;
To detect redundant calls

*// ~CSVReader() {//   // Do not change this code. Put cleanup code in Dispose(bool disposing) above.//   Dispose(false);// }
TODO: override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources.

*public void Dispose()*{// Do not change this code. Put cleanup code in Dispose(bool disposing) above.Dispose(true);// TODO: uncomment the following line if the finalizer is overridden above.// GC.SuppressFinalize(this);}
This code added to correctly implement the disposable pattern.


*string hoge = "静的言語です";
敢えて型推論varで宣言はしません


*int index = type_name.IndexOf ("<");*if (index >= 0) {type_name = type_name.Remove (index) + "`1";}
ジェネリック対応処理


*enum Example*{[SubValue( "ABCDEFG" )]StringValue = 0,[SubValue( 12345 )]IntValue,[SubValue( new[] { "A", "B", "C" } )]ArrayValue,}
こんな形でEnumに属性を付けます。

*string   stringValue     = Example.StringValue.ToSubValue<string>();
こんな感じで取れます

*Console.WriteLine( "StringValue \t= {0}", stringValue );
出力

*StringValue     = ABCDEFGIntValue        = 12345ArrayValue      = A,B,C},,,using System;
結果：

*IntValue        = 12345ArrayValue      = A,B,C},,,using System;
StringValue     = ABCDEFG

*ArrayValue      = A,B,C},,,using System;
IntValue        = 12345

*[AttributeUsage( AttributeTargets.Field )]
カスタム属性

*public static class EnumEx*{public static string ToStringFromSubValue( this Enum enm ){return enm.GetType().GetRuntimeField( enm.ToString() ).GetCustomAttributes( typeof( StringAttribute ), false ).Cast<StringAttribute>().Single().String;}}
拡張メソッド

*string   stringValue     = Example.StringValue.ToStringFromSubValue();
こんな感じで取れます
string   stringValue   = Example.StringValue.ToSubValue<string>();

*Console.WriteLine( "StringValue \t= {0}", stringValue );
出力

*StringValue     = ABCDEFG},,,
*open.StartInfo.RedirectStandardOutput = true;
標準出力をリダイレクトで取得したい


*Stream pngStream = snapshot.AsPNG().AsStream();
.AsJPEG() もあるよ


*string str = "AAAAAAAAAAAAAAAAAAAAAAA";
①stringで受け取る版
stringで入れた文字列の長さ(文字数)が、C++側に渡されるwchar_tのバッファの長さになるっぽい
string str = "";にすると、なにも帰ってこない

*IntPtr buf = Marshal.AllocHGlobal((int)16);
②IntPtrで受ける版

*var buf = new byte[16];
③byteで受け取る版

*[DllImport("DllTest.dll", CharSet = CharSet.Unicode)]public extern static void CopyStringToBuffer(string s);
①stringで受け取る版

*[DllImport("DllTest.dll", EntryPoint = "CopyStringToBuffer")]public extern static void CopyStringToBuffer_2(IntPtr s);
②IntPtrで受ける版

*[DllImport("DllTest.dll", EntryPoint = "CopyStringToBuffer")]public extern static void CopyStringToBuffer_3(byte[] s);
③byteで受け取る版


*return view;
（こんな調子で様々な初期設定を行う）
...


*var param = new UpdateParameter(_dao).SetHeader(1).SetHeader2("a").SetHeader3(2);
DBから現時点の情報を取得する。

*SetValueFromView(param);
画面の情報を反映する。

*_dao.Update(param);
DBを更新する。

*}
画面の値を取得したパラメータのHeader1,2,3に反映する。
コードは省略

*return new Header() { Id = id };
ヘッダーの取得

*return new Header2() { Code = code };
ヘッダー２の取得

*return new Header3() { Id = id };
ヘッダー３の取得

*}
DB更新処理を実行する。コードは省略

*var param = new UpdateParameter();
DBから現時点の情報を取得する。

*param.Header = _dao.GetHeader(1);
メイン処理でDBからデータを取得する。

*SetValueFromView(param);
画面の情報を反映する。

*_dao.Update(param);
DBを更新する。

*}
画面の値を取得したパラメータのHeader1,2,3に反映する。
コードは省略

*}
Daoの参照を削除

*return new Header() { Id = id };
ヘッダーの取得

*return new Header2() { Code = code };
ヘッダー２の取得

*return new Header3() { Id = id };
ヘッダー３の取得

*}
DB更新処理を実行する。コードは省略


*xmlns:l="http:
schemas.livet-mvvm.net2011wpf"

*public WPFButtonBase[] Buttons { get; }
ここ追加


*loggerMock.VerifyLogging(null, LogLevel.Warning);*loggerMock.VerifyLogging(null, LogLevel.Debug, Times.Exactly(3));
ログの内容にかかわらず、呼び出されることのみ確認

*loggerMock.VerifyLogging(null, LogLevel.Error, Times.Never());*loggerMock.VerifyLogging("testaaa", LogLevel.Warning, Times.Never());
呼び出されないことの確認

*}
loggerMock.VerifyLogging("test", LogLevel.Debug, Times.Never()); これはログレベルが違うので失敗する


*using MySqlServerDatum;*public void SqlBackup(){try{//SQLへの接続情報MySqlServerDatum.Info info = new MySqlServerDatum.Info();SqlConnection sc = new SqlConnection(info.connectionString);Server s = new Server(new ServerConnection(sc));//ここの型への名前空間はあえてフルパスにしています。Backupでも動作しますが、念のため。Microsoft.SqlServer.Management.Smo.Backup b = new Microsoft.SqlServer.Management.Smo.Backup();b.Action = BackupActionType.Database;b.Database = info.databaseName;b.Incremental = false;b.Initialize = true;b.LogTruncation = BackupTruncateLogType.Truncate;//バックアップする場所を設定BackupDeviceItem backupItemDevice = new BackupDeviceItem("C:\\"+@"\"+info.databaseName+".bak", DeviceType.File);b.Devices.Add(backupItemDevice);b.SqlBackup(s);} catch(Exception ex){}}
SQLの接続情報が入っているdll

*MySqlServerDatum.Info info = new MySqlServerDatum.Info();
SQLへの接続情報

*Microsoft.SqlServer.Management.Smo.Backup b = new Microsoft.SqlServer.Management.Smo.Backup();
ここの型への名前空間はあえてフルパスにしています。Backupでも動作しますが、念のため。

*BackupDeviceItem backupItemDevice = new BackupDeviceItem("C:\\"+@"\"+info.databaseName+".bak", DeviceType.File);
バックアップする場所を設定


*public void ColorChange(Color color)*{Renderer[] renderers = gameObject.GetComponentsInChildren<Renderer>();foreach(Renderer renderer in renderers){renderer.material.color = color;}}
モデルのマテリアルの色を変更する


*return true;
false や null を返すかもしれない


*using JsAPI = System.Func<object, System.Threading.Tasks.Task<object>>;
毎回 Func<object, Task<object>> と書くのが億劫なのでエイリアスを...

*public static void Main() {}
emitEntryPoint を true にしているのでとりあえず入れなくてはならない


*public IEnumerable<IEnumerable<T>> Do<T>(IEnumerable<IEnumerable<T>> values, T blankValue)
参照型だと後で変更したときにほかの部分も変わるから値型のみ受け付ける。

*public IEnumerable<IEnumerable<T>> Do<T>(IEnumerable<IEnumerable<T>> values, Func<T> blankValue)*{return Enumerable.Range(0, values.Max(c => c.Count())).Select(i => values.Select(c => i < c.Count() ? c.ElementAt(i) : blankValue()));}
毎回newとかさせれば上記の問題が解消できるからFuncデリゲート入れてラムダ式とかでいけるようにする。

*var tValues = Do(values, () => new T());
使い方例


*});
ここにコマンド処理

*});
ここにコマンドの処理


*private void Button_Click(object sender, RoutedEventArgs e)*{this.DialogResult = true;}
OK時

*private void Button_Click_1(object sender, RoutedEventArgs e)*{this.DialogResult = false;}
キャンセル時


*var strLine = sr.ReadLine();
一行読み込み

*var printer = new InfoPrinter(strLine);
一行ごとに行われる何らかの処理

*var strList = new List<string>();
読み込み部分

*var strList2 = new List<string>();
フィルタ部分

*var printer = new InfoPrinter(strLine);
一行ごとに行われる何らかの処理

*IEnumerable<string> strList = CreateSequence();
読み込み部分

*IEnumerable<string> strList2 = StrFilter(strList);
フィルタ部分

*PrintForAll(strList2);
終端部分

*var printer = new InfoPrinter(strLine);
一行ごとに行われる何らかの処理

*IEnumerable<string> strList = CreateSequence();
読み込み部分

*IEnumerable<string> strList2 = StrFilter(strList).Tolist;
フィルタ部分

*PrintForAll(strList2);
終端部分


*label1.BackColor = SystemColors.ActiveCaption;
その1

*label2.BackColor = Color.Transparent;
その2

*var PictureBox = Image.FromFile("../../sample.png");
その3

*flowLayoutPanel4.BorderStyle = BorderStyle.FixedSingle;
その4


*public void Update ()*{deltaTime = ( Time.unscaledTime - prevTime ) * timeScale;time += deltaTime;prevTime = Time.unscaledTime;}
LateUpdateなどで呼んでやる

*private IEnumerator インコにヘッドホンのもふもふかじられて辛い()
どこかにインスタンスを保持していると仮定
var myTimer = new Timer();

*yield return new WaitForSecond(3.0f * myTimer.timeScale);
行き場のない気持ちに悶え３秒停止する

*private void Update ()
どこかにインスタンスを保持していると仮定
var myTimer = new Timer();

*timeScale=1のとき必ず当選するtimeScale=0のとき必ず落選するList<bool> lotTable = new List<bool>();
timeScaleが減少していくにつれて抽選の当選確率が下がる

*timeScale=0のとき必ず落選するList<bool> lotTable = new List<bool>();
timeScale=1のとき必ず当選する

*List<bool> lotTable = new List<bool>();
timeScale=0のとき必ず落選する

*float result = 0f;
くじ引きして当選していたらランダム値を獲得する


*value = int.Parse(inputValue.ToString());
NG 何でも文字列にすれば良いという考えは止めよう

*value = Convert.ToInt32((object)inputValue);
NG 無駄なキャスト1

*value = inputValue.Value;
OK プロパティを使用

*value = (int)inputValue;
OK 無駄なキャストに見えるが、inputValue.Valueが呼ばれる。

*castValue = int.Parse(objectValue.ToString());
NG 文字列にしてキャストするのは無駄が多い

*castValue = Convert.ToInt32(objectValue);
OK .Net Frameworkで用意された変換処理を使う

*castValue = (int)objectValue;
OK 通常のキャスト


*class FileDropBehaviorC
behaivorの継承要らない

*element.PreviewDragOver += Element_PreviewDragOver;
この場合、イベントの購読解除はどこでやるんだ？


*r = g = b = 0;
black

*public static void ARGBfromAHSV(ref byte aOut, ref byte r, ref byte g, ref byte b, double aIn, double h, double s, double v){aOut = (byte)(255*aIn);r = (byte)(255*v);g = (byte)(255*v);b = (byte)(255*v);if (s <= 0.0) return;h *= 6.0;int i = (int)h;double f = h-i;switch(i){case 0:g = (byte)(g*(1-s*(1-f)));b = (byte)(b*(1-s));break;case 1:r = (byte)(r*(1-s*f));b = (byte)(b*(1-s));break;case 2:r = (byte)(r*(1-s));b = (byte)(b*(1-s*(1-f)));break;case 3:r = (byte)(r*(1-s));g = (byte)(g*(1-s*f));break;case 4:r = (byte)(r*(1-s*(1-f)));g = (byte)(g*(1-s));break;case 5:g = (byte)(g*(1-s));b = (byte)(b*(1-s*f));break;}}
ARGBからAHSVへ変換


*public int columns;
最大の桁数

*public int width;
プログレスバーの長さ

*public int par=0;
進捗度

*public int parMax;
目標進捗度

*protected int rowLate=CursorTop;
最後に出力したカーソルの行

*public Progress(int width,int parMax){this.columns=WindowWidth;this.width=width;this.parMax=parMax;}
モノクロ版プログレスバー

*public virtual void update(string message){int row0=CursorTop;float parcent=(float)par/parMax;int widthNow=(int)Math.Floor(width*parcent);string gauge=new string('>',widthNow)+new string(' ',width-widthNow);string status=$"({(parcent*100).ToString("f1")}%<-{par}/{parMax})";Error.WriteLine($"#[{gauge}]#{status}");clearScreenDown();Error.WriteLine(message);rowLate=CursorTop;SetCursorPosition(0,row0);par++;}
プログレスバーの更新

*public virtual void done(string doneAlert){int sideLen=(int)Math.Floor((float)(width-doneAlert.Length)/2);string gauge=new string('=',sideLen)+doneAlert;gauge+=new string('=',width-gauge.Length);string status=$"(100%<-{parMax}/{parMax})";clearScreenDown();Error.WriteLine($"#[{gauge}]#{status}");}
プログレスバーの完了

*protected void clearScreenDown(){int clearRange=rowLate-(CursorTop-1);Error.Write(new string(' ',columns*clearRange));SetCursorPosition(CursorLeft,CursorTop-clearRange);}
コンソール表示の掃除

*class ProgressColor:Progress{public ProgressColor(int width,int parMax):base(width,parMax){}//プログレスバーの更新public override void update(string message){int row0=CursorTop;float parcent=(float)par/parMax;int widthNow=(int)Math.Floor(width*parcent);string status=$"({(parcent*100).ToString("f1")}%<-{par}/{parMax})";BackgroundColor=ConsoleColor.Yellow;ForegroundColor=ConsoleColor.DarkYellow;Error.Write("{");BackgroundColor=ConsoleColor.Cyan;Error.Write(new string(' ',widthNow));BackgroundColor=ConsoleColor.DarkCyan;Error.Write(new string(' ',width-widthNow));BackgroundColor=ConsoleColor.Yellow;Error.Write("}");ResetColor();Error.WriteLine(status);clearScreenDown();Error.WriteLine(message);rowLate=CursorTop;SetCursorPosition(0,row0);par++;}//プログレスバーの完了public override void done(string doneAlert){int sideLen=(int)Math.Floor((float)(width-doneAlert.Length)/2);string gauge=new string(' ',sideLen)+doneAlert;gauge+=new string(' ',width-gauge.Length);string status=$"(100%<-{parMax}/{parMax})";clearScreenDown();BackgroundColor=ConsoleColor.Yellow;ForegroundColor=ConsoleColor.DarkYellow;Error.Write("{");BackgroundColor=ConsoleColor.Green;ForegroundColor=ConsoleColor.Red;Error.Write(gauge);BackgroundColor=ConsoleColor.Yellow;ForegroundColor=ConsoleColor.DarkYellow;Error.Write("}");ResetColor();Error.WriteLine(status);}}
カラー版プログレスバー

*public override void update(string message){int row0=CursorTop;float parcent=(float)par/parMax;int widthNow=(int)Math.Floor(width*parcent);string status=$"({(parcent*100).ToString("f1")}%<-{par}/{parMax})";BackgroundColor=ConsoleColor.Yellow;ForegroundColor=ConsoleColor.DarkYellow;Error.Write("{");BackgroundColor=ConsoleColor.Cyan;Error.Write(new string(' ',widthNow));BackgroundColor=ConsoleColor.DarkCyan;Error.Write(new string(' ',width-widthNow));BackgroundColor=ConsoleColor.Yellow;Error.Write("}");ResetColor();Error.WriteLine(status);clearScreenDown();Error.WriteLine(message);rowLate=CursorTop;SetCursorPosition(0,row0);par++;}
プログレスバーの更新

*public override void done(string doneAlert){int sideLen=(int)Math.Floor((float)(width-doneAlert.Length)/2);string gauge=new string(' ',sideLen)+doneAlert;gauge+=new string(' ',width-gauge.Length);string status=$"(100%<-{parMax}/{parMax})";clearScreenDown();BackgroundColor=ConsoleColor.Yellow;ForegroundColor=ConsoleColor.DarkYellow;Error.Write("{");BackgroundColor=ConsoleColor.Green;ForegroundColor=ConsoleColor.Red;Error.Write(gauge);BackgroundColor=ConsoleColor.Yellow;ForegroundColor=ConsoleColor.DarkYellow;Error.Write("}");ResetColor();Error.WriteLine(status);}
プログレスバーの完了

*var prg=new ProgressColor(width,works);
モノクロ版
var prg=new Progress(width,works);
カラー版


*abstract class Animal
加abstract关键字，表明是抽象类

*}
在方法的返回值前加abstract表明此方法是抽象方法，抽象方法没有方法体，直接在括号后加“；”

*}
声明一个Ichangething接口，此接口有一个方法Changthing，参数是一个字符串变量，返回一字符串。


*public static Schedule Create(string タイトル,Date 日付,time 開始時間,TimeSpan 期間,string 場所,Member 同行者)
メソッド定義

*}
省略

*var schedule=Schedule.Create(タイトル: "買い物",日付: new Date(2017, 1, 1),
メソッド使用時、名前付き引数で可読性をあげる

*public interface IReader*{string GetValue();}
読み取りInterface

*public interface IWriter*{void SetValue(string value);}
書き込みInterface

*class ConfigReader : IReader*{public void ReadValue(){var data = ConfigManager.Get();//何らかの処理（省略）}}
設定ファイル：読込のみ

*}
何らかの処理（省略）

*class ConfigWriter : IReader,IWriter*{private string _data;public void ReadValue(){_data = ConfigManager.Get();//何らかの処理（省略）}public void WriteValue(){ConfigManager.Set(_data);}}
設定ファイル：読込と書込

*}
何らかの処理（省略）

*var length = "かくかくしかじか".Info("文字数取得").Length;
例１ infoメッセージ

*var str = "ポチ".Is()+"犬です。",,,例１var schedule=Schedule.Create(タイトル: "買い物",日付: new Date(2017, 1, 1),開始時間: 10:00,期間: new TimeSpan(1, 30, 0),場所: "大阪",同行者:"友人A");
例２　Is

*var schedule=Schedule.Create(タイトル: "買い物",日付: new Date(2017, 1, 1),
例１

*var schedule=Schedule.Create().タイトル("買い物").日付(new Date(2017, 1, 1)).開始時間(10:00).期間(new TimeSpan(1, 30, 0)).場所("大阪").同行者("友人A");
例２

*var schedule=Schedule.Create().タイトル("買い物").日付(new Date(2017, 1, 1)).開始時間(10:00).期間(new TimeSpan(1, 30, 0)).場所("大阪").同行者("友人A");
例２（再掲）

*return new Schedule();
スケジュール作成時の処理（省略）

*return this;
タイトル追加の処理（省略）

*return this;
日付追加の処理（省略）

*return this;
開始時間追加の処理（省略）

*return this;
期間追加の処理（省略）

*return this;
場所追加の処理（省略）

*return this;
同行者追加の処理（省略）

*public interface IScheduleAdd
例：処理は順番に1回だけ行いたい場合
タイトル追加Interface

*public interface IScheduleDay*{IScheduleFrom 日付(DateTime date);}
日付追加Interface

*public interface IScheduleFrom*{IScheduleDuration 開始時間(string startTime);}
開始時刻追加Interface

*public interface IScheduleDuration*{IScheduleAt 期間(TimeSpan duration);}
期間追加Interface

*public interface IScheduleAt*{IScheduleAdd 場所(string area);}
場所追加Interface

*public class Schedule: IScheduleAdd, IScheduleDay, IScheduleFrom, IScheduleDuration, IScheduleAt*{public static IScheduleAdd Create(){return new Schedule();}public IScheduleDay Addタイトル(string title){return this;}public IScheduleFrom 日付(DateTime date){return this;}public IScheduleDuration 開始時間(string startTime){return this;}public IScheduleAt 期間(TimeSpan duration){return this;}public IScheduleAdd 場所(string area){return this;}}
スケジュールクラス

*public class Shopping*{//買い物開始public static Shopping Start(){return new Shopping();}//商品選択public Shopping SelectItem(string items){return this;}//商品試着public Shopping 試着(Action<Fitting> action){using (var 試着室 = FittingRoom.Prepare()){if(試着室.CanUse())action(new Fitting());}return this;}//商品購入public void 購入(){}}
Shoppingクラス

*public static Shopping Start(){return new Shopping();}
買い物開始

*public Shopping SelectItem(string items)*{return this;}
商品選択

*public Shopping 試着(Action<Fitting> action)*{using (var 試着室 = FittingRoom.Prepare()){if(試着室.CanUse())action(new Fitting());}return this;}
商品試着

*public void 購入()*{}
商品購入

*public class Fitting*{//スタッフの補助ありpublic void WithHelp(string item){}//スタッフの補助なしpublic void Self(string item){}}
試着クラス

*public void WithHelp(string item)*{}
スタッフの補助あり

*public void Self(string item)*{}
スタッフの補助なし

*public class FittingRoom : IDisposable*{public static FittingRoom Prepare(){return new FittingRoom();}//試着室が使えるかチェックpublic bool CanUse(){return true;}//試着室解放public void Dispose(){}}
試着室クラス

*public bool CanUse()*{return true;}
試着室が使えるかチェック

*public void Dispose()*{}
試着室解放

*var shopping = Shopping.Start().SelectItem("洋服A").SelectItem("洋服B").試着(fittingt =>
大筋からは試着室の事は隠ぺいし、モデルの俯瞰図的な使用をおこなっている


*public class PlayerMovementSystem : SystemBase {// 移動の入力情報InputAction m_MoveInput;protected override void OnUpdate () {// 移動の入力を取得するVector2 input = m_MoveInput.ReadValue<Vector2>();float3 movement = new float3(input.x,0f,input.y);// 移動させるfloat deltaTime = UnityEngine.Time.deltaTime;Entities.WithAll<Player>().ForEach((Mover mover,ref Translation translation) => {translation.Value += movement * mover.Speed * deltaTime;}).WithBurst().ScheduleParallel();}}
プレイヤーを移動させるためのシステム

*InputAction m_MoveInput;*protected override void OnUpdate () {// 移動の入力を取得するVector2 input = m_MoveInput.ReadValue<Vector2>();float3 movement = new float3(input.x,0f,input.y);// 移動させるfloat deltaTime = UnityEngine.Time.deltaTime;Entities.WithAll<Player>().ForEach((Mover mover,ref Translation translation) => {translation.Value += movement * mover.Speed * deltaTime;}).WithBurst().ScheduleParallel();}
移動の入力情報

*Vector2 input = m_MoveInput.ReadValue<Vector2>();
移動の入力を取得する

*float deltaTime = UnityEngine.Time.deltaTime;
移動させる

*m_Input = new PlayerInputActions();
PlayerInputActionsをインスタンス化し、有効にする

*m_MoveInput = m_Input.Player.Move;
PlayerInputActionsに定義されているMoveをm_MoveInputに割り当てる

*Vector2 input = m_MoveInput.ReadValue<Vector2>();
移動の入力を取得する

*float deltaTime = UnityEngine.Time.deltaTime;
移動させる


*this.Step = tensor.Shape[this.Dim] * tensor.Size / tensor.Shape.GetRange(0, this.Dim + 1).Aggregate((now, next) => now * next);*for (int i = 0; i < tensor.Size; i += this.Step){for (int j = 0; j < this.RepeatNum; j++){Array.Copy(tensor.Data, i, data, i * this.RepeatNum + j * this.Step, this.Step);}}
対象となるDim以下の要素数を取得

*public Tensor[] Parameters {get;}
...

*public Tensor[] Params = new Tensor[]{};
...

*public Tensor[] Parameters{get{return this.Params;}}
...

*}
何もしない


*new PyList<int>() { 1 } * 4;
[1,1,1,1]

*static public PyList<T> operator *(PyList<T> list, int rate)*{var temp = new PyList<T>(list);if (temp.Count != 0){for (int i = 0; i < rate-1; i++)foreach (var item in list)temp.Add(item);}else{for (int i = 0; i < rate; i++){temp.Add(default(T));}}return temp;}
*したときに複製をするようにした


*{
あったよー！


*$"{d:n1}";
123.5


*"https:
dinosaur-facts.firebaseio.com",


*using System.Windows.Forms;
OpenFileDialog用に使う

*open_file_dialog.ShowDialog();
ダイアログを開く

*string file_name = open_file_dialog.FileName;
取得したファイル名をstringに代入する


*{var destType = dest.GetType();var sourceType = source.GetType();//構造体の場合はValueTypeにいったん置き換えないと値が更新されない。//ValueType vt = dest;//構造体の場合は以下のdestをvtに置き換えが必要//お互いのフィールドとプロパティを列挙して名前が一致したものコピーするforeach (var destProperty in destType.GetProperties()){foreach (var sourceProprty in sourceType.GetProperties().Where(v => v.Name==destProperty.Name)){destProperty.SetValue(dest, sourceProprty.GetValue(source));}foreach (var sourceField in sourceType.GetFields().Where(v => v.Name==destProperty.Name)){destProperty.SetValue(dest, sourceField.GetValue(source));}}foreach (var destField in destType.GetFields()){foreach (var sourceProperty in sourceType.GetProperties().Where(v => v.Name==destField.Name)){destField.SetValue(dest, sourceProperty.GetValue(source));}foreach (var sourceField in sourceType.GetFields().Where(v => v.Name==destField.Name)){destField.SetValue(dest, sourceField.GetValue(source));}}//以下のはまた構造体のときに必要//構造体に戻す//dest = (T2)vt;}
where T2 : structこれがないとValueType vt = dest;ができない。

*foreach (var destProperty in destType.GetProperties())
構造体の場合はValueTypeにいったん置き換えないと値が更新されない。
ValueType vt = dest;
構造体の場合は以下のdestをvtに置き換えが必要
お互いのフィールドとプロパティを列挙して名前が一致したものコピーする

*}
以下のはまた構造体のときに必要
構造体に戻す
dest = (T2)vt;


*}
編集ボタン、削除ボタン、詳細表示ボタン、活性

*}
承認ボタン、差し戻しボタン、詳細表示ボタン活性

*}
詳細表示ボタン活性

*}
承認ボタン、差し戻しボタン、詳細表示ボタン活性

*}
詳細表示ボタン活性

*bool firstApproved = firstApproverId != null;
各ボタンを非活性で初期化済み。
この書き方を知らない人が私の周りでは多かった。

*}
編集ボタン、削除ボタン、活性

*}
詳細表示ボタン　活性

*}
承認ボタン、差し戻しボタン、活性

*}
承認詳細ボタン活性

*}
承認ボタン、差し戻しボタン

*}
詳細表示ボタン活性

*bool firstApproved = firstApproverId != null;
第一承認済み

*bool secondApproved = firstApproved && secondApproverId != null;
第二承認済み

*bool isAuthor = AuthorId == loginUserId;
文字列比較はEqualsでも良いが、==でも文字列比較が可能。

*bool editButtonEnabled = isAuthor && !firstApproved;
ボタン活性制御
編集ボタン

*bool deleteButtonEnabled = isAuthor && !firstApproved;
削除ボタン

*bool approvalButtonEnabled = (isFirstManager && !firstApproved) || (isSecoundManager && !secondApproved);
承認ボタン

*bool detailButtonEnabled = isAuthor || isFirstManager || isSecoundManager;
詳細ボタン


*int angle = 0,
degree


*}
かなり大きめの処理なので省略…


*var rand = new Random();
1. データ点からランダムに k 個のクラスタ平均を初期値として取る。

*var assignments = new int[data.Length];
2. 収束判定のためにループ外に assignments 変数を持っておく。

*var prevAssignments = assignments.Select(v => v).ToArray();
2. 収束判定のために 1 つ前の状態をコピー。

*assignments = data.Select(v => means.IndexOf(means.MinBy(m => Math.Pow(v - m, 2)))).ToArray();
2.1. 各データ点について、自身に最も近いクラスタに割り当てる。

*if (Enumerable.Range(0, data.Length).All(i => assignments[i] == prevAssignments[i])) break;*// 2.2. 各クラスタについて、所属するデータ点の平均を計算して新しいクラスタ平均とする。
2. 収束していたら計算終了。

*means = means.Select((m, i) => data.Where((v, j) => i == assignments[j]).DefaultIfEmpty(m).Average()).ToList();
2.2. 各クラスタについて、所属するデータ点の平均を計算して新しいクラスタ平均とする。

*var rand = new Random();
1. データ点からランダムに k 個のクラスタ平均を初期値として取る。

*var assignments = new int[data.Length];
2. 収束判定のためにループ外に assignments 変数を持っておく。

*while (true)*,,,
2. 収束するまで繰り返す。

*var prevAssignments = assignments.Select(v => v).ToArray();
2. 収束判定のために 1 つ前の状態をコピー。

*assignments = data.Select(v => means.IndexOf(means.MinBy(m => Math.Pow(v - m, 2)))).ToArray();
2.1. 各データ点について、自身に最も近いクラスタに割り当てる。

*if (Enumerable.Range(0, data.Length).All(i => assignments[i] == prevAssignments[i])) break;*,,,
2. 収束していたら計算終了。

*means = means.Select((m, i) => data.Where((v, j) => i == assignments[j]).DefaultIfEmpty(m).Average()).ToList();
2.2. 各クラスタについて、所属するデータ点の平均を計算して新しいクラスタ平均とする。

*public static Tuple<Vector2[], int[]> KMeans(Vector2[] data, int k)*{var rand = new Random();var means = data.OrderBy(v => rand.Next()).Take(k).ToList();var assignments = new int[data.Length];while (true){var prevAssignments = assignments.Select(v => v).ToArray();assignments = data.Select(v => means.IndexOf(means.MinBy(m => (v - m).LengthSquared()))).ToArray();if (Enumerable.Range(0, assignments.Length).All(i => assignments[i] == prevAssignments[i])) break;means = means.Select((m, i) => data.Where((v, j) => i == assignments[j]).DefaultIfEmpty(m).Average()).ToList();}return Tuple.Create(means.ToArray(), assignments);}
Vector2 には System.Numerics.Vectors が必要（ライセンスに同意する必要あり）。


*<input type="submit" name="Search" value="検索">
テキストボックス等の入力項目の設定

*}
検索ボタンが押された場合の処理

*}
クリアボタンが押された場合の処理

*<input type="submit" name="cmd" value="検索">
テキストボックス等の入力項目の設定

*}
検索ボタンが押された場合の処理

*}
クリアボタンが押された場合の処理

*public string ButtonName { get; set; }
アクションメソッド付加時に設定したボタン名を保存

*return controllerContext.Controller.ValueProvider.GetValue(ButtonName) != null;
設定したボタン名と同名のデータが存在するかチェック（Requestで返ってきているか）

*<input type="submit" name="Search" value="検索">
テキストボックス等の入力項目の設定

*}
検索ボタンが押された場合の処理


*Count = 0;
0にする

*}
---------略------------


*public void ButtonPushedByManual(){StartCoroutine(Compare(result_before, result_after));}
ボタンをクリックしたとき


*if (m.Msg == 15)
WM_PAINT == 15

*g.FillRectangle(new System.Drawing.SolidBrush(this.BackColor), this.ClientRectangle);
描画を一旦消してしまう

*var placeholderTextColor = System.Drawing.Color.FromArgb((this.ForeColor.A >> 1 + this.BackColor.A >> 1), (this.ForeColor.R >> 1 + this.BackColor.R >> 1), ((this.ForeColor.G >> 1 + this.BackColor.G) >> 1), (this.ForeColor.B >> 1 + this.BackColor.B >> 1));
プレースホルダのテキスト色を、前景色と背景色の中間として文字列を描画する


*.AddReferences("System.Core")
これが必要

*}
何か


*Properties.Settings.Default.Properties[設定名]?.DefaultValue
次でアクセスできる

*Properties.Settings.Default.PropertyValues[設定名]?.PropertyValue
次でアクセスできる


*float x = 0;
xの合計値

*float x2 = 0;
x^2の合計値

*float xy = 0;
x * yの合計値

*float xz = 0;
x * zの合計値

*float y = 0;
yの合計値

*float y2 = 0;
y^2の合計値

*float yz = 0;
y * zの合計値

*float z = 0;
zの合計値

*float vx = v.x;
最小二乗平面との誤差は高さの差を計算するので、（今回の式の都合上）Yの値をZに入れて計算する

*float l = 1 * data.Length;
matA[0, 0]要素は要素数と同じ（\sum{1}のため）

*float[,] matA = new float[,]{{l,  x,  y},{x, x2, xy},{y, xy, y2},};
求めた和を行列の要素として2次元配列を生成

*return LUDecomposition(matA, b);
求めた値を使ってLU分解→結果を求める

*int N = aMatrix.GetLength(0);
行列数（Vector3データの解析なので3x3行列）

*float[,] lMatrix = new float[N, N];
L行列(零行列に初期化)

*float[,] uMatrix = new float[N, N];
U行列(対角要素を1に初期化)

*float[,] buffer = new float[N, N];
計算用のバッファ

*float[] l1 = new float[n];
l1成分をコピー

*float[] u1 = new float[n];
u1^T成分をコピー

*float[,] A1 = new float[n, n];
A1を求める

*aMatrix = A1;
A1を新しいaMatrixとして利用する

*float[] y = new float[N];
求めたLU行列を使って連立方程式を解く

*float[] result = CalcLeastSquaresPlane(samplingData);
最小二乗平面を用いた推測値を元に速度を求める

*Vector3 v = samplingData.Last();
サンプリングした最後のデータを用いて、理想平面の値を求める

*Vector3 vec = new Vector3(v.x, y, v.z);
実際に利用したいデータ


*List<GameObject> list_toggle_ = new List<GameObject>();
生成したObjectを持っておくためのList

*GameObject toggle_instance = Instantiate(toggle_prefab_) as GameObject;
インスタンスを作成

*list_toggle_.Add(toggle_instance);
生成したインスタンスをリストで持っておく

*list_toggle_.Clear();
リスト自体をキレイにする

*List<GameObject> list_toggle_ = new List<GameObject>();
生成したObjectを持っておくためのList

*GameObject toggle_instance = Instantiate(toggle_prefab_) as GameObject;
インスタンスを作成

*list_toggle_.Add(toggle_instance);
生成したインスタンスをリストで持っておく

*list_toggle_.Clear();
リスト自体をキレイにする

*List<Toggle> list_toggle_ = new List<GameObject>();
生成したObjectを持っておくためのList（ただしToggleクラスのリストを保持する)

*GameObject toggle_instance = Instantiate(toggle_prefab_) as GameObject;
インスタンスを作成(ただしGameObject)

*list_toggle_.Add(toggle_instance.GetComponent<Toggle>());
生成したインスタンスをリストで持っておく(GameObject内部のToggleを取り出してリストに入れる)

*list_toggle_.Clear();
リスト自体をキレイにする


*List<string> destDir = new List<string>();
作成する別名ディレクトリのリスト

*Regex reg = new Regex("orig");
1つ目の文字列だけ置換するためRegexインスタンス作成

*if (destDir.Contains(reg.Replace(dir.Remove(dir.LastIndexOf('\\')), "TestDir", 1)))*continue;
リスト内に既に文字列がある場合はAdd処理を飛ばす

*destDir.Add(reg.Replace(dir.Remove(dir.LastIndexOf('\\')), "TestDir", 1));
最初に出現した文字列をTestDirに置き換える

*Directory.CreateDirectory(dir);
取得したパスはエスケープがされている状態なので、そのままディレクトリ作成

*string directoryPath = @"C:\Users\watame\Desktop\orig";
メンバ変数

*string[] filePaths = Directory.GetFiles(directoryPath, searchFileName, SearchOption.AllDirectories);
対象のフォルダ以下の .txt ファイル一覧を取得

*CreateDestDir(filePaths);
ディレクトリの作成


*private AnimatorStateInfo currentState;
現在のステート状態を保存する参照

*void Start ()*{// 各参照の初期化anim = GetComponent<Animator> ();currentState = anim.GetCurrentAnimatorStateInfo (0);startPosZ = transform.position.z;transform.position = new Vector3(transform.position.x, transform.position.y, startPosZ);}
Use this for initialization

*anim = GetComponent<Animator> ();
各参照の初期化

*void  Update ()*{//向く方向の決定transform.LookAt(new Vector3(lookAtObj.position.x, 0, lookAtObj.position.z), new Vector3(0,1,0));//左クリック時の処理if (Input.GetButtonDown("Fire1")){anim.SetBool("Jump", true);transform.position = new Vector3(transform.position.x, transform.position.y, startPosZ);}//カーソルが移動した時の処理//targetとの距離がしきい値dxより大きくなったら歩くfloat dx = transform.position.x - lookAtObj.position.x;if (lookAtObj != null){if (Mathf.Abs(dx) > 0.3f){currentState = anim.GetCurrentAnimatorStateInfo(0);anim.SetBool("Walk", true);}else{anim.SetBool("Walk", false);currentState = anim.GetCurrentAnimatorStateInfo(0);}}if (currentState.fullPathHash == walkingState){transform.position = new Vector3(transform.position.x - Mathf.Sign(dx)*0.01f, transform.position.y, startPosZ);}if (currentState.fullPathHash == standingState){transform.position = new Vector3(transform.position.x, transform.position.y, startPosZ);}}
Update is called once per frame

*transform.LookAt(new Vector3(lookAtObj.position.x, 0, lookAtObj.position.z), new Vector3(0,1,0));*//左クリック時の処理
向く方向の決定

*float dx = transform.position.x - lookAtObj.position.x;
カーソルが移動した時の処理
targetとの距離がしきい値dxより大きくなったら歩く


*using System;*class Ref{public class Box{public int value;public Box(int value){this.value = value;}}//関数定義時と呼び出し時にrefをつけると参照渡しになるpublic static void Foo(ref Box box){box.value = 42;}public static void Bar(ref Box box){box = new Box(42);}public static void Main(string[] args){Box box1 = new Box(334);Console.WriteLine("foo: ");Console.WriteLine(box1.value);Foo(ref box1);Console.WriteLine(box1.value);Box box2 = new Box(334);Console.WriteLine("bar: ");Console.WriteLine(box2.value);Bar(ref box2);Console.WriteLine(box2.value);}}
C#

*public static void Foo(ref Box box){box.value = 42;}
関数定義時と呼び出し時にrefをつけると参照渡しになる

*using System;*class Ptr{public class Box{public int value;public Box(int value){this.value = value;}}//refをつけないとクラスは参照の値渡しになるpublic static void Foo(Box box){box.value = 42;}public static void Bar(Box box){box = new Box(42);}public static void Main(string[] args){Box box1 = new Box(334);Console.WriteLine("foo: ");Console.WriteLine(box1.value);Foo(box1);Console.WriteLine(box1.value);Box box2 = new Box(334);Console.WriteLine("bar: ");Console.WriteLine(box2.value);Bar(box2);Console.WriteLine(box2.value);}}
C#

*public static void Foo(Box box){box.value = 42;}
refをつけないとクラスは参照の値渡しになる


*Console.WriteLine(exp.MyFunction(exp.MyValue, exp.AnotherValue));
30

*public override bool TryConvert(ConvertBinder binder, out object result)*{Console.WriteLine($"{nameof(TryConvert)} : {binder.Type}");if (binder.Type != typeof(int)){return base.TryConvert(binder, out result);}result = _x;return true;}
キャスト

*public override bool TryUnaryOperation(UnaryOperationBinder binder, out object result)*{Console.WriteLine($"{nameof(TryUnaryOperation)} : {binder.Operation}");switch (binder.Operation){case ExpressionType.UnaryPlus:result = _x;return true;default:return base.TryUnaryOperation(binder, out result);}}
単項演算

*public override bool TryBinaryOperation(BinaryOperationBinder binder, object arg, out object result)*{Console.WriteLine($"{nameof(TryBinaryOperation)} : {binder.Operation}");switch (binder.Operation){case ExpressionType.Add:result = _x + (arg as MyDynamic)?._x ?? 0;return true;default:return base.TryBinaryOperation(binder, arg, out result);}}
二項演算

*public override bool TryGetMember(GetMemberBinder binder, out object result)*{Console.WriteLine($"{nameof(TryGetMember)} : {binder.Name}");switch (binder.Name){case "X":result = _x;return true;default:return base.TryGetMember(binder, out result);}}
プロパティの get

*public override bool TrySetMember(SetMemberBinder binder, object value)*{Console.WriteLine($"{nameof(TrySetMember)} : {binder.Name} = {value}");switch (binder.Name){case "X":_x = value is int ? (int)value : 0;return true;default:return base.TrySetMember(binder, value);}}
プロパティの set

*public override bool TryGetIndex(GetIndexBinder binder, object[] indexes, out object result)*{Console.WriteLine($"{nameof(TryGetIndex)} : [{indexes.Select(x => x.ToString()).Aggregate((x, y) => $"{x}, {y}")}]");if (!indexes.All(x => x is int)){return base.TryGetIndex(binder, indexes, out result);}result = indexes.Cast<int>().Aggregate((x, y) => x + y);return true;}
インデクサの get

*public override bool TrySetIndex(SetIndexBinder binder, object[] indexes, object value)*{Console.WriteLine($"{nameof(TrySetIndex)} : [{indexes.Select(x => x.ToString()).Aggregate((x, y) => $"{x}, {y}")}] = {value}");if (!indexes.All(x => x is int) && value is int){return base.TrySetIndex(binder, indexes, value);}_x = indexes.Cast<int>().Aggregate((x, y) => x + y) + (int)value;return true;}
インデクサの set

*public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)*{Console.WriteLine($"{nameof(TryInvokeMember)} : {binder.Name}({(args.Length == 0 ? "" : args.Select(x => x.ToString()).Aggregate((x, y) => $"{x}, {y}"))})");if (!args.All(x => x is string)){return base.TryInvokeMember(binder, args, out result);}result = args.Cast<string>().Aggregate((x, y) => x + y);return true;}
メンバ呼び出し

*public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)*{Console.WriteLine($"{nameof(TryInvoke)} : ({(args.Length == 0 ? "" : args.Select(x => x.ToString()).Aggregate((x, y) => $"{x}, {y}"))})");result = null;return true;}
自身に () をつけて呼び出し


*grph.Clear( Color.Black );
塗りつぶす

*grph.DrawRectangle( Pens.Aqua, 90, 50, 160, 50 );
四角い枠を描く

*using ( Font font = new Font( "Arial", 20 ) ) {grph.DrawString( "ABCDEFG", font, Brushes.White, 100, 60 );
枠の中に文字を書く

*}
後略

*float scale = grph.DpiX / 96f;
四角い枠を描く

*float scale = grph.DpiX / 96f;
四角い枠を描く

*grph.Clear( Color.Black );
塗りつぶす

*float scale = grph.DpiX / 96f;
DPIに合わせてワールド変換を設定

*using ( Pen pen = new Pen( Color.Aqua, 1 / scale ) ) {grph.DrawRectangle( pen, 90, 50, 160, 50 );
四角い枠を描く

*using ( Font font = new Font( "Arial", 20 / scale ) ) {grph.DrawString( "ABCDEFG", font, Brushes.White, 100, 60 );
枠の中に文字を書く

*grph.Transform = morg;*}
ワールド変換を元に戻しておく


*Process.Start("https:
twitter.com"); ここはスキなのでいいです。Unityのとこも


*public override void InferCallBack(int inferID, string inputImage, bool isSuccessed, floatVector results)*{textBox.Dispatcher.Invoke((Action)(() =>{int i = 0;textBox.Text += $"CallBack   inferID[{inferID}] : [inputImage] = {inputImage}" + System.Environment.NewLine;foreach (float result in results){textBox.Text += $"CallBack   inferID[{inferID}] : [{i}] = {Math.Round(result, 4, MidpointRounding.AwayFromZero)}" + System.Environment.NewLine;i += 1;}textBox.Text += $"---------------------" + System.Environment.NewLine;}));}
dll側から呼ばれる

*textBox.Text +=  $"[{i}] :  {Math.Round(output, 4, MidpointRounding.AwayFromZero)}" + System.Environment.NewLine;
textBox.Text += string.Format("{0} : {1:f4}", i, outputVec[i]) + System.Environment.NewLine;

*Task.Run(() =>*{instance.Initialize(networkInfo);instance.SetInferCallBack(obj);foreach (string inputImage in inputImageFiles){instance.InferASync(inputImage);}});
instance.GetAvailableDevices();


*return v.X <= v.Y
コンパイルが成功するための実装。


*List<City> cityList = new List<City>*{new City { Id = 0, Name = "tokyo", Path = "./path/tokyo" },new City { Id = 1, Name = "osaka", Path = "./path/osaka" }};
1. List作成

*string filepath = cityList.Find(x => x.Id == 0).Path;
2. Findで取得

*Console.WriteLine(filepath);
表示確認


*private static string baseAddress = "http:
localhost:9000";

*object result = null;
戻り値

*if (routeData.Values.TryGetValue(name, out result))
取得対象のデータがrouteDataに含まれていたら、返す。
含まれていなければ、<T>のdefaultを返す


*var uwq = UnityWebRequest.Get("http:
google.com");


*ApplyVacation?.Invoke(this, e);
C#6.0以上でのみ可能


*SqlConnection connection = new SqlConnection();
データをdataGridView品目リストにセットする--------------------------------------

*DataTable dt = new DataTable();
DataSet ds = new DataSet();        データセットに格納する場合

*connection.ConnectionString = f.DB接続文字列;
接続文字列を設定します。
Formメイン f = new Formメイン();     他のフォームからPublic変数を呼び出し。

*adapter.Fill(dt);
SQLを実行し結果をdsの中に格納します。
【お勉強】Fill()でOpen/Closeを自動で行ってくれるので、記述不要。
但し、Openしたら、Close要。
adapter.Fill(ds);             データセット格納する場合

*dataGridView品目リスト.Columns[0].HeaderText = "品目コード";
dataGridView品目リストの設定----------------------------------------------------
ユーザの操作規制　←これはFormのLoadへ持って行っても良い
dataGridView品目リスト.ReadOnly = true;                      読取専用
dataGridView品目リスト.AllowUserToDeleteRows = false;        行削除禁止
dataGridView品目リスト.AllowUserToAddRows = false;           行挿入禁止
dataGridView品目リスト.AllowUserToResizeRows = false;        行の高さ変更禁止
dataGridView品目リスト.RowHeadersVisible = false;            行ヘッダーを非表示にする
dataGridView品目リスト.MultiSelect = false;                  ル、行、列が複数選択禁止
dataGridView品目リスト.SelectionMode = DataGridViewSelectionMode.FullRowSelect;      　セルを選択すると行全体が選択されるようにする
ヘッダー名変更

*dataGridView品目リスト.Columns[0].Width = 60;
カラム幅設定


*hp -= damage;
hp から damageを引き算する


*...
bitmapに対する処理

*bitmap.Save("save.png", System.Drawing.Imaging.ImageFormat.Png);
フォーマット指定

*g.FillRectangle(Brushes.White,g.VisibleClipBounds);
画像塗りつぶし

*using( Pen p = new Pen(Color.Black,1)){またはPens.Black;
幅1pxのペン

*Pens.Black;
または

*g.DrawLine(p,x,y,x2,y2);
線を引く

*g.DrawRectangle(p,x,y,w,h);
長方形


*struct MyStruct
Error ( Field ' MyStruct.myString ' must be fully assigned before it leaves the constructor ).


*public void ConfigureServices(IServiceCollection services)*{// Add framework services.services.AddApplicationInsightsTelemetry(Configuration);services.AddDbContext<ApplicationDbContext>(options =>options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));services.AddIdentity<ApplicationUser, IdentityRole>().AddEntityFrameworkStores<ApplicationDbContext>().AddDefaultTokenProviders();//DBContextを読み込むservices.AddDbContext<ScaffoldDBContext>(); // この行を追加services.AddMvc();// Add application services.services.AddTransient<IEmailSender, AuthMessageSender>();services.AddTransient<ISmsSender, AuthMessageSender>();}
This method gets called by the runtime. Use this method to add services to the container.

*services.AddMvc();
DBContextを読み込む
services.AddDbContext<ScaffoldDBContext>();  この行を追加


*list.ForEach(Console.WriteLine);
1 3 5


*Debug.Log("test");
testと表示される


*using APP_NAME.Models;
環境依存

*var user = new ApplicationUser();
ユーザーの追加

*user.PasswordHash = new PasswordHasher().HashPassword("test@test.com");
ハッシュ化する

*user.SecurityStamp = Guid.NewGuid().ToString();
SecurityStampを設定する（これがNullだと認証でエラーとなる）

*ApplicationDbContext adb = new ApplicationDbContext();
追加処理

*var signInManager = this.HttpContext.GetOwinContext().Get<ApplicationSignInManager>();
そのままサインイン処理

*var user = new ApplicationUser { UserName = model.Email, Email = model.Email };
抜粋

*var userManager = this.HttpContext.GetOwinContext().GetUserManager<ApplicationUserManager>();
UserManager生成（ユーザーを検索するため：生成にも使える）

*var signInManager = this.HttpContext.GetOwinContext().Get<ApplicationSignInManager>();
SignInManager生成（認証するため）

*AuthenticationManager.SignOut(DefaultAuthenticationTypes.ApplicationCookie);
サインアウト

*private IAuthenticationManager AuthenticationManager*{get{return HttpContext.GetOwinContext().Authentication;}}
ヘルパー

*public class ApplicationRole : IdentityRole*{}
for role

*var roleManager = this.HttpContext.GetOwinContext().Get<ApplicationRoleManager>();
RoleManagerの取得

*roleManager.Create(new ApplicationRole { Name = "admin"});
Roleの生成

*var userManager = this.HttpContext.GetOwinContext().GetUserManager<ApplicationUserManager>();
UserManagerの取得

*var user = userManager.Find("test@test.com", "test@test.com");
adminにするユーザーの検索

*userManager.AddToRole(user.Id, "admin");
紐づけ

*[Authorize(Roles ="admin")]public ActionResult AdminOnly (){return Content("こんにちはAdminさん。");
adminのみにアクセスを許可


*RealProxy rp = RemotingServices.GetRealProxy(this._target);
以下、コンストラクタを実行する処理

*string execFlag = ConfigurationManager.AppSettings["ASYNC_EXEC_FLAG"];
以下、コンストラクタ以外のメソッドを実行する処理

*res = RemotingServices.ExecuteMessage(this._target, call);
メソッド実行

*Console.WriteLine("非同期キューにSEND：start");
メソッド前処理

*res = new ReturnMessage(0, null, 0, null, call);
メソッド実行


*var r_def=new XorShift.defaultSeed();
XorShift乱数ジェネレータの初期化
論文デフォルトシード

*var r_const=new XorShift(100);*// 時間シード
固定値シード

*var r=new XorShift();*//デフォルトシード値の取得
時間シード

*Console.WriteLine(">> defaults");
デフォルトシード値の取得

*Console.WriteLine(">> seeds in r");
適用したシード値の取得

*Console.WriteLine(">> rand 0 to UInt32Max");*for(int i=0;i<5;i++){Console.WriteLine(r_def.rand());}
乱数の生データを取得

*Console.WriteLine(">> randInt 0 to 100");*for(int i=0;i<5;i++){Console.WriteLine(r_const.randInt(0,100));}
0-100の乱数(100含む)を整数で取得

*Console.WriteLine(">> randFloat 0 to 1");*for(int i=0;i<5;i++){Console.WriteLine(r.randFloat());}
0-1の乱数を浮遊小数点で取得

*Console.WriteLine(">> shuffle Array");
静的配列のシャッフル
値渡しとなるので元の配列は破壊されない

*Console.WriteLine(">> shuffle List<T>");
List<T>のシャッフル

*Console.WriteLine(">> randCount in r");
今の乱数を回した回数


*Debug.Log( "func2:" + func2.NullSafe(1) + ";" );
"func2:;"


*[SerializeField] private float azimuthalAngle = 45.0f;
angle with x-axis


*(x) => -1
f'

*public static Tensor Minus(Tensor In){return new Lambda("Minus",(x) => -x,(x) => -1).Forward(In);}
-X

*public static Tensor ReLU(Tensor In){return new Lambda("ReLU",(x) => x > 0 ? x : 0,(x) => x > 0 ? 1 : 0).Forward(In);}
ReLU

*public static Tensor Exp(Tensor In){return new Lambda("Exp",(x) => System.Math.Exp(x),(x) => System.Math.Exp(x)).Forward(In);}
Exponential

*public static Tensor Log(Tensor In){return new Lambda("Log_e",(x) => System.Math.Log(x),(x) => 1 / x).Forward(In);}
Log


*var inc = (int x) => x + 1;
エラー


*public void SetDisposable(IDisposable disposable)*{if (disposable == null) throw new ArgumentNullException(nameof(disposable));if(_disposable!=null) throw new InvalidOperationException();_disposable = disposable;}
This method is not protected from multi thread.


*someFunction(notBeConverted);
大丈夫


*this.label_x.Text = TempStr;
ラベルに値を書き込み値を保管。

*描画();
PictureBoxに書き込む

*Bitmap canvas = new Bitmap(pictureBox1.Width, pictureBox1.Height);
doubleに変換可能
↓
描画先とするImageオブジェクトを作成する

*Graphics g = Graphics.FromImage(canvas);
ImageオブジェクトのGraphicsオブジェクトを作成する

*g.DrawLine(Pens.Black, 0, 100, 200, 100);
座標軸

*g.DrawEllipse(Pens.Black, 0, 0, 200, 200);
基本円

*x = (float)(100 * Math.Cos(R));
x,yの座標を確定→floatに変換
R = Math.PI * (d * 90) / 180;  ラジアンを確保！

*g.Dispose();
リソースを解放する

*pictureBox1.Image = canvas;
PictureBox1に表示する


*pin.SetDriveMode(GpioPinDriveMode.Output);
GPIO5を出力モードにする

*pin.Dispose();
終了処理


*public BezierCurve Curve;
ベジェ線の入ったPrefabをセット

*public float MoveTime = 2f;
移動にかける時間（秒）

*private int _currentPoint;
現在の地点を保持

*private float _currentTime;
経過時間

*private bool _isComplete;
移動完了フラグ

*if(_isComplete) return;
こういうのが嫌ならCorutine使ってwhile(true)で回して、
_isCompleteの条件があったらbreakでいいと思う。

*transform.position =
カーブに沿って移動
ポイント１とポイント２の間に作られるカーブの、xx%時点での位置を取得する


*baseDir = args[1];
アセンブリパス


*yield return null;
1フレーム待機


*.Subscribe(_ => this.TestMessage.Text += $"LongPressed!:{DateTime.Now}\n");
実行したいメソッド

*var progress = down.Select(_ => Observable
100になるまでGenerateしてもらいます。この100がトリガーです。

*this.Progress
ProgressというボタンとProgressBarというプログレスバーがあったとします

*this.Resumable
Resumableという名前のボタンがあるとします。


*context.GetLink(IDocument);
IDocument型を渡す方が多いと思います


*public class Pixel*{public byte a;public byte r;public byte g;public byte b;public Pixel(byte b, byte g, byte r, byte a){this.a = a;this.r = r;this.g = g;this.b = b;}}
RGBA のバイト情報をピクセル単位で扱えるようにするためのクラス

*public static class BitmapConverter*{// ビットマップをピクセルデータに変換するpublic static IList<Pixel> ConvertBitmapToPixels(Bitmap bitmap){byte[] byteArray = null;using (bitmap){byteArray = ConvertBitmapToByteArray(bitmap);}var ret = new List<Pixel>();for (var i = 0; i < byteArray.Length; i += 4){ret.Add(new Pixel(byteArray[i + 0],byteArray[i + 1],byteArray[i + 2],byteArray[i + 3]));}return ret;}// ビットマップをバイト配列に変換するprivate static byte[] ConvertBitmapToByteArray(Bitmap bitmap){var ret = new byte[bitmap.Width * bitmap.Height * 4];BitmapData bitmapData = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),ImageLockMode.ReadOnly,PixelFormat.Format32bppArgb);Marshal.Copy(bitmapData.Scan0, ret, 0, ret.Length);bitmap.UnlockBits(bitmapData);return ret;}// ピクセルデータをビットマップに戻すpublic static Bitmap ConvertPixelsToBitmap(IList<Pixel> pixels, int width, int height){var byteArray = new byte[width * height * 4];var index = 0;foreach (var pixel in pixels){byteArray[index++] = pixel.b;byteArray[index++] = pixel.g;byteArray[index++] = pixel.r;byteArray[index++] = pixel.a;}return ConvertByteArrayToBitmap(byteArray, width, height);}// バイト配列をビットマップに戻すprivate static Bitmap ConvertByteArrayToBitmap(byte[] byteArray, int width, int height){Bitmap ret = new Bitmap(width, height);BitmapData bitmapData = ret.LockBits(new Rectangle(0, 0, ret.Width, ret.Height),ImageLockMode.ReadWrite,PixelFormat.Format32bppArgb);Marshal.Copy(byteArray, 0, bitmapData.Scan0, byteArray.Length);ret.UnlockBits(bitmapData);return ret;}}
ビットマップとピクセルデータ間の変換処理を行うクラス

*public static IList<Pixel> ConvertBitmapToPixels(Bitmap bitmap)*{byte[] byteArray = null;using (bitmap){byteArray = ConvertBitmapToByteArray(bitmap);}var ret = new List<Pixel>();for (var i = 0; i < byteArray.Length; i += 4){ret.Add(new Pixel(byteArray[i + 0],byteArray[i + 1],byteArray[i + 2],byteArray[i + 3]));}return ret;}
ビットマップをピクセルデータに変換する

*private static byte[] ConvertBitmapToByteArray(Bitmap bitmap)*{var ret = new byte[bitmap.Width * bitmap.Height * 4];BitmapData bitmapData = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height),ImageLockMode.ReadOnly,PixelFormat.Format32bppArgb);Marshal.Copy(bitmapData.Scan0, ret, 0, ret.Length);bitmap.UnlockBits(bitmapData);return ret;}
ビットマップをバイト配列に変換する

*public static Bitmap ConvertPixelsToBitmap(IList<Pixel> pixels, int width, int height)*{var byteArray = new byte[width * height * 4];var index = 0;foreach (var pixel in pixels){byteArray[index++] = pixel.b;byteArray[index++] = pixel.g;byteArray[index++] = pixel.r;byteArray[index++] = pixel.a;}return ConvertByteArrayToBitmap(byteArray, width, height);}
ピクセルデータをビットマップに戻す

*private static Bitmap ConvertByteArrayToBitmap(byte[] byteArray, int width, int height)*{Bitmap ret = new Bitmap(width, height);BitmapData bitmapData = ret.LockBits(new Rectangle(0, 0, ret.Width, ret.Height),ImageLockMode.ReadWrite,PixelFormat.Format32bppArgb);Marshal.Copy(byteArray, 0, bitmapData.Scan0, byteArray.Length);ret.UnlockBits(bitmapData);return ret;}
バイト配列をビットマップに戻す

*public static class ImageFormatResolver*{// 画像ファイルの拡張子から決定するpublic static ImageFormat ResolveFromExtension(string extension){switch (extension.ToLower()){case ".bmp": return ImageFormat.Bmp;case ".gif": return ImageFormat.Gif;case ".jpg":case ".jpeg": return ImageFormat.Jpeg;case ".png":default: return ImageFormat.Png;}}}
画像ファイルの保存形式 ImageFormat を決定するクラス

*public static ImageFormat ResolveFromExtension(string extension)*{switch (extension.ToLower()){case ".bmp": return ImageFormat.Bmp;case ".gif": return ImageFormat.Gif;case ".jpg":case ".jpeg": return ImageFormat.Jpeg;case ".png":default: return ImageFormat.Png;}}
画像ファイルの拡張子から決定する


*if (Input.GetKeyDown(KeyCode.Escape))
初期位置へスポーン

*var rotate = (-mouseY * transform.right + mouseX * transform.up + -h * transform.forward).normalized;*// 与える力の計算（線形補間）
トルクベクトルの計算

*if (v >= 0) power = Mathf.Lerp(power, maxPower, v * accel * Time.deltaTime);*else power = Mathf.Lerp(power, 0, -v * accel * Time.deltaTime);
与える力の計算（線形補間）

*body.AddForce(transform.forward * power);*body.AddTorque(rotate * toruque);
力を与える


*void Start()*{}
Use this for initialization

*void Update()*{this.transform.position += this.transform.forward;if (Input.GetKey(KeyCode.S)){transform.Rotate(-0.5f, 0, 0);}if (Input.GetKey(KeyCode.W)){transform.Rotate(0.5f, 0, 0);}if (Input.GetKey(KeyCode.A)){transform.Rotate(0, 0, 0.5f);}if (Input.GetKey(KeyCode.D)){transform.Rotate(0, 0, -0.5f);}}
Update is called once per frame


*{
スピンボタンから編集

*up.EmulateClick();
５回Upする

*dw.EmulateClick();
２回Downする

*var commitButton = new WPFButtonBase(subLogicalTree.ByBinding("CommitCommand").Single());
確定

*Assert.AreEqual((int.Parse(age) + 5 - 2).ToString() , dataGrid.GetCellText(0, 1));
ちゃんと年齢が書き換わっている（元の値から+5、-2されている）ことを確認

*return new Tuple<ButtonBase, ButtonBase>(IntegerUpDown.Descendants<ButtonBase>().First(c => c.Name == "PART_IncreaseButton"),
IntegerUpDownのVisualTreeから検索


*public partial class ThisAddIn*{private void ThisAddIn_Startup(object sender, System.EventArgs e){Application.ItemSend += Application_ItemSend;Application.OptionsPagesAdd += Application_OptionsPagesAdd;}void Application_OptionsPagesAdd(Outlook.PropertyPages Pages){Pages.Add(new MyPropPage(), "General");// 複数ページあれば、さらに Add します。}// .... ほかのコードがあれば続行}
Outlook:ThisAddin.cs

*}
複数ページあれば、さらに Add します。

*}
.... ほかのコードがあれば続行

*[System.Runtime.InteropServices.ComVisible(true)]
MyPropPage.cs : 「ユーザーコントロール」をテンプレートにプロパティページを作成します。COM 参照可能なよう ComVisible(true) 属性をつけ、Microsoft.Office.Interop.Outlook.PropertyPage インターフェイスを組み込みます。

*textBoxUserName.Text = Properties.Settings.Default.UserName;
「設定 (Settings)」に UserName（String 型）を記憶させ、プロパティシート上の textBoxUserName（テキストボックス）で変更を扱う場合

*if (_propertyPageSite != null)*_propertyPageSite.OnStatusChange();
テキストボックスが編集されたら、OnStatusChange メソッドで通知します。

*Type type = typeof(System.Object);
プロパティ変更の通知先を得ます
=> リフレクションを利用して .NET ライブラリ中の System.Windows.Forms.UnsafeNativeMethods.IOleObject クラスにある GetClientSite メソッドを呼び出します。

*Properties.Settings.Default.UserName = textBoxUserName.Text;
OK や 適用ボタンをクリックされたときの処理を記述します。

*return (textBoxUserName.Text != Properties.Settings.Default.UserName);
適用ボタンを有効にしたい状態の場合は true を返すようにします。ここでは、「設定」の記憶値とテキストボックスの値が異なっている場合に true を返すようにしています。

*}
ヘルプファイル (.chm) を指定できるようです。不要なら何も書かないでよいです。

*}
.... ほかのコードがあれば


*static readonly string fileName = $@"{Application.StartupPath}\r.xml";
独自データのファイルは、実行時のフォルダに固定名称で r.xml としておく

*XmlSerializer s = new XmlSerializer(typeof(RFile));
独自データ読込

*XmlSerializer s = new XmlSerializer(typeof(RFile));
独自データ保存


*int form_num = this.OwnedForms.Length;*MessageBox.Show("children form : " + form_num.ToString());
どれだけの画面からOwnerに指定されているか

*// children form : 3*Form[] form_info = this.OwnedForms;
メッセージボックスに表示される結果

*Form[] form_info = this.OwnedForms;*for (int i = 0; i < form_info.Length; i++)
children form : 3

*}
メッセージボックスに表示される結果
this is c1
this is c2
this is c3


*index = 0;
インデックスをリセット


*{
ブロックの形と色のパターンをswtich文で実装。


*Console.WriteLine("終了");
ここに到達できません


*dynamic dx = 1;
dx の型は dynamic 型


*StreamReader reader = new StreamReader(templatePath, Encoding.GetEncoding("Shift_JIS"));*string template = reader.ReadToEnd();
テンプレートを読み込んでtempに格納

*string scriptText = template.Replace("#SCRIPTNAME#", scriptName);
テンプレート中の文字列"#SCRIPTNAME#"をスクリプト名に置換

*File.WriteAllText("Assets/Scripts/" + scriptName + ".cs", scriptText, Encoding.UTF8);
csファイルとしてScriptsフォルダに保存

*File.WriteAllText(tempFilePath, scriptName, Encoding.UTF8);
一時ファイルを生成し、必要な情報(ここではスクリプト名のみ)を書き込んで保存

*scriptName = reader.ReadLine();
スクリプト名を読み込み

*CreateAttachedPrefab();
空のGameObjectを生成してスクリプトをアタッチし、プレハブ化(後述)

*File.Delete(tempFilePath);
一時ファイルの削除

*GameObject go = new GameObject(scriptName);
空のGameObjectの生成

*go.AddComponent(Type.GetType(scriptName));
生成したスクリプトをアタッチ

*string prefabPath = "Assets/" + scriptName + ".prefab";
プレハブの生成

*EditorGUI.BeginDisabledGroup(EditorApplication.isCompiling);
コンパイル中は操作できないように

*scriptName = EditorGUILayout.TextField("ScriptName", scriptName);
スクリプト名を入力

*StreamReader reader = new StreamReader(templatePath, Encoding.GetEncoding("Shift_JIS"));*string template = reader.ReadToEnd();
テンプレートを読み込んでtempに格納

*string scriptText = template.Replace("#SCRIPTNAME#", scriptName);
テンプレート中の文字列"#SCRIPTNAME#"をスクリプト名に置換

*File.WriteAllText("Assets/Scripts/" + scriptName + ".cs", scriptText, Encoding.UTF8);
csファイルとしてScriptsフォルダに保存

*File.WriteAllText(tempFilePath, scriptName, Encoding.UTF8);
一時ファイルを生成し、必要な情報(ここではスクリプト名のみ)を書き込んで保存

*scriptName = reader.ReadLine();
スクリプト名を読み込み

*CreateAttachedPrefab();
空のGameObjectを生成してスクリプトをアタッチし、プレハブ化

*File.Delete(tempFilePath);
一時ファイルの削除

*GameObject go = new GameObject(scriptName);
空のGameObjectの生成

*go.AddComponent(Type.GetType(scriptName));
生成したスクリプトをアタッチ

*string prefabPath = "Assets/" + scriptName + ".prefab";
プレハブの生成


*Application.OpenURL("https:
twitter.comintenttweet?text=hello&hashtags=way");


*float[] data = new float[44100];
音声データを格納する配列


*encoding = System.Text.Encoding.GetEncoding(932);
TODO:その内プロパティ化

*fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
TODO: 必要そうならその内、開き方を指定できるようにする

*if (length < len)*OnRenewted(new EventArgs());
ファイルサイズが小さくなったら、ログが変わったと判断する

*byte[] bs = new byte[length - len];
TODO: 最初に大容量のファイルを開かれた場合、問題になるかもしれないので、その内検証する


*Visio.Document activeDocument = this.Application.ActiveDocument;
現在アクティブなVisioファイルの取得方法


*Display b4 =new SideBorder(new FullBorder(new SideBorder(new FullBorder(new StringDisplay("こんにちは。")),'*')),'/');
+---------------+

*Console.ReadLine();
/|*|こんにちは。|*|/
/|*+------------+*|/
/+----------------+/
実行が一瞬で終わって確認できないので、キーの入力を待ちます

*public abstract class Display*{public abstract int Columns { get; }public abstract int Rows { get; }public abstract string GetRowText(int row);public void Show(){for(int i = 0; i < Rows; i++){Console.WriteLine(GetRowText(i));}}}
・機能を追加するときの核

*public class StringDisplay : Display*{private string str;public StringDisplay(string str){this.str = str;}public override int Columns{get{Encoding sjisEnc = Encoding.GetEncoding("shift_jis");return sjisEnc.GetByteCount(str);}}public override int Rows{get { return 1; }}public override string GetRowText(int row){if (row == 0){return str;}else{return null;}}}
・Componentを実装

*public abstract class Border : Display
・Componentと同じインターフェース（API）を持つ
・飾る対象となるComponentを持つ

*public class SideBorder : Border*{private char borderChar;public SideBorder(Display display, char ch) : base(display){this.borderChar = ch;}public override int Columns{get{return 1 + display.Columns + 1;}}public override int Rows{get{return display.Rows;}}public override string GetRowText(int row){return borderChar + display.GetRowText(row) + borderChar;}}
・Decoratorを実装

*public class FullBorder : Border*{public FullBorder(Display display) : base(display) { }public override int Columns{get{return 1 + display.Columns + 1;}}public override int Rows{get{return 1 + display.Rows + 1;}}public override string GetRowText(int row){if (row == 0){return "+" + MakeLine('-', display.Columns) + "+";}else if (row == display.Rows + 1){return "+" + MakeLine('-', display.Columns) + "+";}else{return "|" + display.GetRowText(row - 1) + "|";}}private string MakeLine(char ch, int count){StringBuilder sb = new StringBuilder();for (int i = 0; i < count; i++){sb.Append(ch);}return sb.ToString();}}
・Decoratorを実装


*internal PtrHandle<UnLoadJobInfo> _info;
UnLoadJob の管理情報


*public class ApplicationUser : IdentityUser<int, CustomUserLogin, CustomUserRole, CustomUserClaim>*{// UserManager<ApplicationUser> -> UserManager<ApplicationUser, int>public async Task<ClaimsIdentity> GenerateUserIdentityAsync(UserManager<ApplicationUser, int> manager){var userIdentity = await manager.CreateIdentityAsync(this, DefaultAuthenticationTypes.ApplicationCookie);return userIdentity;}}
IdentityUser -> IdentityUser<int, CustomUserLogin, CustomUserRole, CustomUserClaim>

*public async Task<ClaimsIdentity> GenerateUserIdentityAsync(UserManager<ApplicationUser, int> manager)*{var userIdentity = await manager.CreateIdentityAsync(this, DefaultAuthenticationTypes.ApplicationCookie);return userIdentity;}
UserManager<ApplicationUser> -> UserManager<ApplicationUser, int>

*public class ApplicationDbContext : IdentityDbContext<ApplicationUser, CustomRole, int, CustomUserLogin, CustomUserRole, CustomUserClaim>*{// base("DefaultConnection", throwIfV1Schema: false) -> base("DefaultConnection")public ApplicationDbContext(): base("DefaultConnection"){}public static ApplicationDbContext Create(){return new ApplicationDbContext();}}
IdentityDbContext<ApplicationUser> -> IdentityDbContext<ApplicationUser, CustomRole, int, CustomUserLogin, CustomUserRole, CustomUserClaim>

*public class ApplicationUserManager : UserManager<ApplicationUser, int>*{// IUserStore<ApplicationUser> -> IUserStore<ApplicationUser, int>public ApplicationUserManager(IUserStore<ApplicationUser, int> store): base(store){}public static ApplicationUserManager Create(IdentityFactoryOptions<ApplicationUserManager> options, IOwinContext context){// UserStore<ApplicationUser>() -> UserStore<ApplicationUser, CustomRole, int, CustomUserLogin, CustomUserRole, CustomUserClaim>()var manager = new ApplicationUserManager(new UserStore<ApplicationUser, CustomRole, int, CustomUserLogin, CustomUserRole, CustomUserClaim>(context.Get<ApplicationDbContext>()));...,,,public void ConfigureAuth(IAppBuilder app){...app.UseCookieAuthentication(new CookieAuthenticationOptions{AuthenticationType = DefaultAuthenticationTypes.ApplicationCookie,LoginPath = new PathString("/Account/Login"),Provider = new CookieAuthenticationProvider{// OnValidateIdentity<ApplicationUserManager, ApplicationUser> -> OnValidateIdentity<ApplicationUserManager, ApplicationUser, int>OnValidateIdentity = SecurityStampValidator.OnValidateIdentity<ApplicationUserManager, ApplicationUser, int>(validateInterval: TimeSpan.FromMinutes(30),// regenerateIdentity -> regenerateIdentityCallbackregenerateIdentityCallback: (manager, user) => user.GenerateUserIdentityAsync(manager),// 【getUserIdCallbackを追加】getUserIdCallback: (id) => id.GetUserId<int>())}});,,,// XxxxClass<ApplicationUser>XxxxClass<ApplicationUser, int>// User.Identity.GetUserId();User.Identity.GetUserId<int>();// function(string userId)// if (userId == null)function(int userId)if (userId == default(int)),,,public class ApplicationUser : IdentityUser{},,,public class IdentityUser : IdentityUser<string>{public IdentityUser();public IdentityUser(string userName);},,,public class IdentityUser<TKey> : IdentityUser<TKey, IdentityUserClaim<TKey>, IdentityUserRole<TKey>, IdentityUserLogin<TKey>> where TKey : IEquatable<TKey>{public IdentityUser();},,,// IdentityUser -> IdentityUser<int>public class ApplicationUser : IdentityUser<int>{},,,// IdentityDbContext<ApplicationUser> -> IdentityDbContext<ApplicationUser, IdentityRole<int>, int>public class ApplicationDbContext : IdentityDbContext<ApplicationUser, IdentityRole<int>, int>{public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options): base(options){}...},,,public class Startup{...public void ConfigureServices(IServiceCollection services){services.AddDbContext<ApplicationDbContext>(options =>options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));// AddIdentity<ApplicationUser, IdentityRole> -> AddIdentity<ApplicationUser, IdentityRole<int>>// AddEntityFrameworkStores<ApplicationDbContext> -> AddEntityFrameworkStores<ApplicationDbContext, int>services.AddIdentity<ApplicationUser, IdentityRole<int>>().AddEntityFrameworkStores<ApplicationDbContext, int>().AddDefaultTokenProviders();...,,,*OnValidateIdentity = SecurityStampValidator.OnValidateIdentity<ApplicationUserManager, ApplicationUser, int>(validateInterval: TimeSpan.FromMinutes(30),
OnValidateIdentity<ApplicationUserManager, ApplicationUser> -> OnValidateIdentity<ApplicationUserManager, ApplicationUser, int>

*getUserIdCallback: (id) => id.GetUserId<int>())
【getUserIdCallbackを追加】

*// if (userId == null)*function(int userId)
function(string userId)

*public class ApplicationUser : IdentityUser<int>*{},,,// IdentityDbContext<ApplicationUser> -> IdentityDbContext<ApplicationUser, IdentityRole<int>, int>public class ApplicationDbContext : IdentityDbContext<ApplicationUser, IdentityRole<int>, int>{public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options): base(options){}...},,,public class Startup{...public void ConfigureServices(IServiceCollection services){services.AddDbContext<ApplicationDbContext>(options =>options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));// AddIdentity<ApplicationUser, IdentityRole> -> AddIdentity<ApplicationUser, IdentityRole<int>>// AddEntityFrameworkStores<ApplicationDbContext> -> AddEntityFrameworkStores<ApplicationDbContext, int>services.AddIdentity<ApplicationUser, IdentityRole<int>>().AddEntityFrameworkStores<ApplicationDbContext, int>().AddDefaultTokenProviders();...,,,*public class ApplicationDbContext : IdentityDbContext<ApplicationUser, IdentityRole<int>, int>*{public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options): base(options){}...},,,public class Startup{...public void ConfigureServices(IServiceCollection services){services.AddDbContext<ApplicationDbContext>(options =>options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));// AddIdentity<ApplicationUser, IdentityRole> -> AddIdentity<ApplicationUser, IdentityRole<int>>// AddEntityFrameworkStores<ApplicationDbContext> -> AddEntityFrameworkStores<ApplicationDbContext, int>services.AddIdentity<ApplicationUser, IdentityRole<int>>().AddEntityFrameworkStores<ApplicationDbContext, int>().AddDefaultTokenProviders();...,,,
*System.GC.Collect();
ファイナライズされたばかりのオブジェクトに関連するメモリを開放


*using System.Threading;
EventWaitHandle


*webBrowser1.Navigate($"http:
www.upload.nicovideo.jpedit?f={e.Node.Tag}");


*}
参照が必要な処理

*}
参照が必要な処理


*}
その他のメソッドは省略しています


*var viewModel = this.BindingContext as GamePageViewModel;
対応するViewModelを割り出し、プロパティ公開しているICommandを取り出す

*BaseLayer.GameEndCommand = cmd;
CocosSharp側の基底LayerにStatic公開しているICommandプロパティに渡してやる

*this.GameFinishCommand = new DelegateCommand(async () =>*{if (this.IsBusy) return;this.IsBusy = true;await this.NavigationService.NavigateAsync(Consts.NavigationUrl.HOME_PAGE);this.IsBusy = false;}, () => !this.IsBusy);
プロパティ公開しているコマンドでしかるべき処理（今回はPrism画面遷移）

*Device.BeginInvokeOnMainThread(() =>
NOTE:リソースの解放やらなにやら
終了処理として受け渡されているコマンドを実行
中身はViewModelで定義の通りゲームページからホームページへの遷移
UIスレッドで動かす必要があるためDevice.BeginInvokeOnMainThreadをかませる


*webBrowser1.Navigate($"http:
www.upload.nicovideo.jpedit?f={e.Node.Tag}");


*Regex regex = new Regex("\n");
改行検索


*doc.LoadFromFile("リスト.docx");
ファイルテンプレートをロードします。

*doc.Replace("a.price", "5.5", true, true);
リストのデータに更新します。

*doc.IsUpdateFields = true;
フィールドを更新します。

*doc.SaveToFile("output.docx", FileFormat.Docx2013);
保存します。


*richTextBox2.Update();
step4


*String fileName = "";
任意のファイルパス

*FileStream fs = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
ファイルを読込専用、他プロセスからの読書き可能として開き、読込んで読込み位置を取得する

*FileSystemWatcher fsw = new FileSystemWatcher();
指定のファイルのみ更新された際に、非同期にイベントを呼出す

*OpenFileDialog dlg = new OpenFileDialog();
オープンファイルダイアログを表示

*fs = new FileStream(dlg.FileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
TODO:ファイルが選ばれなかった場合などの処理が必要
ファイルを読込専用、他プロセスからの読書き可能として開き、読込んで読込み位置を取得する

*fsw = new FileSystemWatcher();
指定のファイルのみ、更新された際に非同期にイベントを呼出す

*byte[] bs = new byte[0x1000];
ファイルを一時的に読み込むバイト型配列を作成する

*int readSize = fs.Read(bs, 0, bs.Length);
ファイルの一部を読み込む

*if (readSize == 0)*break;
ファイルをすべて読み込んだときは終了する

*tb.Text += System.Text.Encoding.GetEncoding(932).GetString(bs);
部分的に読み込んだデータを使用したコードをここに記述する

*tb.SelectionStart = tb.Text.Length;
カーソルを行末に移動して、スクロールさせる

*fs.Seek(pos, SeekOrigin.Begin);
ファイルの先頭から指定した位置までストリーム内の読込み位置を変更し、追加分のデータを読込んで、読込み位置を最後の位置にする


*int num = 1000000;
配列数

*int loop = 10;
繰り返し回数

*// Note it will also go to _defaultCapacity first, not 1, then 2, etc.*using(IEnumerator<T> en = collection.GetEnumerator()) {while(en.MoveNext()) {Add(en.Current);}}
This enumerable could be empty.  Let Add allocate a new array, if needed.

*using(IEnumerator<T> en = collection.GetEnumerator()) {while(en.MoveNext()) {Add(en.Current);}}
Note it will also go to _defaultCapacity first, not 1, then 2, etc.


*System.Threading.Thread.Sleep(1000);
重い処理

*this.Invoke(new Action(() =>*{lock(this.progressBar1) {this.progressBar1.Value += 1;}}));
コントロールの制御

*System.Threading.Thread.Sleep(1000);
重い処理

*this.Invoke(new Action(() =>*{lock(this.progressBar1) {this.progressBar1.Value += 1;}}));
コントロールの制御


*Document document = new Document();
word objectを作成します。

*Section section = document.AddSection();
sectionとparagraphを追加します。

*paragraph.AppendText("今日の日付: ");
paragraphにテキストを追加します。

*Field field = paragraph.AppendField("Date", FieldType.FieldData) as Field;
日付フィールドを設定します。

*document.SaveToFile("Sample.docx", FileFormat.Docx2013);
保存します。

*CreateIfField(document, paragraph);*string[] fieldName = { "Count" };
CreateFieldメソッドを使用して値を指定します。

*document.MailMerge.Execute(fieldName, fieldValue);
Ifフィールドに値をマージします。

*document.IsUpdateFields = true;
フィールドを更新します。

*document.SaveToFile("sample.docx", FileFormat.Docx);
保存します

*IfField ifField = new IfField(document);*ifField.Type = FieldType.FieldIf;
Ifフィールドを追加して条件を設定します。

*paragraph.AppendTOC(1, 3);
TOCを追加します

*Paragraph para1 = section.AddParagraph();
段落にテキストを追加します。

*document.UpdateTableOfContents();
TOCを更新します

*document.SaveToFile("TOC.docx", FileFormat.Docx);
保存します


*var doubledEnumerable = oddEnumerable.Select(x => x * 2);
=> 4,8,12,16


*SetWatchFaceStyle(new WatchFaceStyle.Builder( owner )
ウォッチフェイスのスタイルを設定します。

*.SetCardPeekMode( WatchFaceStyle.PeekModeShort )
ユーザーからのタップイベントを有効にするかどうか設定します。
true  : 有効
false : 無効（デフォルト）
.SetAcceptsTapEvents( true )
通知が来た時の通知カードの高さを設定します。

*.SetBackgroundVisibility( WatchFaceStyle.BackgroundVisibilityInterruptive )
通知カード（small cardの表示時）の背景の表示方法を設定します。
WatchFaceStyle.BackgroundVisibilityInterruptive : 一部の重要な通知に限り、表示します。（デフォルト）
WatchFaceStyle.BackgroundVisibilityPersistent   : 通知カードの種類にかかわらず、表示します。

*.SetShowSystemUiTime( false )
システムUIのデジタル時計を表示するするかどうかを設定します。（使用している例として、デフォルトで用意されている「シンプル」があります。）
true  : 表示
false : 非表示（デフォルト）

*.Build()
設定したスタイル情報をビルドします。このメソッドは最後に呼び出します。

*backgroundPaint = new Paint();
背景用のグラフィックスオブジェクトを生成します。

*backgroundPaint.Color = resources.GetColor( Resource.Color.background );
リソースから背景色を読み込みます。

*hourHandPaint = new Paint();
時針用のPaintグラフィックスオブジェクトを生成します。

*hourHandPaint.StrokeWidth = resources.GetDimension( Resource.Dimension.hour_hand_stroke );
時針の幅を設定します。

*hourHandPaint.AntiAlias = true;
アンチエイリアスを有効にします。

*hourHandPaint.StrokeCap = Paint.Cap.Round;
線端の形は丸形を指定します。

*minuteHandPaint = new Paint();
分針用のPaintグラフィックスオブジェクトを生成します。

*secondHandPaint = new Paint();
秒針用のPaintグラフィックスオブジェクトを生成します。

*nowTime = Java.Util.Calendar.GetInstance( Java.Util.TimeZone.Default );
時刻を格納するオブジェクトを生成します。

*backgroundPaint.Color = owner.Resources.GetColor( Resource.Color.background );
非推奨となった方法

*int argb = ContextCompat.GetColor( owner, Resource.Color.background );
代わりに推奨された方法

*backgroundPaint.Color = ContextCompat.GetColor( owner, Resource.Color.background );
注 : ContextCompat.GetColorメソッドの戻り値を、Paint.Colorプロパティに直接代入できません。

*updateTimeHandler.RemoveMessages( MessageUpdateTime );
UpdateTimeHandlerにセットされているメッセージを削除します。

*}
Android Wearのウィンドウが丸形かどうかを判別します。
bool isRound = insets.IsRound;

*isRequiredLowBitAmbient = properties.GetBoolean( PropertyLowBitAmbient, false );
アンビエントモード時、Low-Bit制限を必要とするかどうかの値を取得します。

*isReqiredBurnInProtection = properties.GetBoolean( PropertyBurnInProtection, false );
アンビエントモード時、焼き付き防止を必要とするかどうかの値を取得します。

*Invalidate();
ウォッチフェイスを再描画します。

*isAmbient = inAmbientMode;
現在のアンビエントモードをセットします。

*hourHandPaint.AntiAlias = antiAlias;
アンビエントモードの時は、針のPaintオブジェクトのアンチエイリアスを無効にし、
そうでなければ有効にします。

*Invalidate();
ウォッチフェイスを再描画します。

*UpdateTimer();
タイマーを更新します。

*updateTimeHandler.RemoveMessages( MessageUpdateTime );
UpdateTimeHandlerからMessageUpdateTimeメッセージを取り除きます。

*updateTimeHandler.SendEmptyMessage( MessageUpdateTime );
UpdateTimeHandlerにMessageUpdateTimeメッセージをセットします。

*bool inMuteMode = ( interruptionFilter == InterruptionFilterNone );
InterruptionフィルターがInterruptionFilterNoneであるかどうか判別します。

*Invalidate();
ウォッチフェイスを再描画します。

*break;
TODO : ユーザーが画面をタッチした時の処理を入れます。

*break;
TODO : ユーザーが画面をタッチしたまま、指を動かした時の処理を入れます。

*break;
TODO : ユーザーがタップした時の処理を入れます。

*}
中略

*canvas.DrawColor( Color.Black );
アンビエントモードの時は、黒色で塗りつぶします。

*canvas.DrawRect( 0, 0, canvas.Width, canvas.Height, backgroundPaint );
そうでない時は、背景画像を描画します。

*float centerX = bounds.Width() / 2.0f;
中心のXY座標を求めます。

*float hourHandLength = centerX - 80;
針の長さを求めます。

*float hourHandRotation = ( ( nowTime.Get( Java.Util.CalendarField.Hour ) + ( nowTime.Get( Java.Util.CalendarField.Minute ) / 60f ) ) / 6f ) * ( float )Math.PI;
時針の先端のXY座標を求めます。

*canvas.DrawLine( centerX, centerY, centerX + hourHandX, centerY + hourHandY, hourHandPaint );
時針を描画します。

*float minuteHandRotation = nowTime.Get( Java.Util.CalendarField.Minute ) / 30f * ( float )Math.PI;
分針の先端のXY座標を求めます。

*canvas.DrawLine( centerX, centerY, centerX + minuteHandX, centerY + minuteHandY, minuteHandPaint );
分針を描画します。

*float secondHandRotation = nowTime.Get( Java.Util.CalendarField.Second ) / 30f * ( float )Math.PI;
秒針の先端のXY座標を求めます。

*canvas.DrawLine( centerX, centerY, centerX + secondHandX, centerY + secondHandY, secondHandPaint );
分針を描画します。

*var intentFilter = new IntentFilter( Intent.ActionTimezoneChanged );
タイムゾーン用のレシーバーを登録します。

*nowTime = Java.Util.Calendar.GetInstance( Java.Util.TimeZone.Default );
ウォッチフェイスが描画されていない時にタイムゾーンが変化した場合の備え、現在タイムゾーンの時の現在時刻を取得します。

*Application.Context.UnregisterReceiver( timeZoneReceiver );
タイムゾーン用のレシーバーを登録解除します。

*UpdateTimer();
タイマーの動作を更新します。

*}*public override void OnPropertiesChanged( Bundle properties ) {base.OnPropertiesChanged( properties );isRequiredLowBitAmbient = properties.GetBoolean( PropertyLowBitAmbient, false );isReqiredBurnInProtection = properties.GetBoolean( PropertyBurnInProtection, false );}
bool isRound = insets.IsRound;


*}
中略

*[MetaData( "com.google.android.wearable.watchface.preview", Resource = "@drawable/preview" )]丸形[MetaData( "com.google.android.wearable.watchface.preview_circular", Resource = "@drawable/preview_circular" )],,,[IntentFilter( new[] { "android.service.wallpaper.WallpaperService" }, Categories = new[] { "com.google.android.wearable.watchface.category.WATCH_FACE" } )],,,[Service( Label = "@string/watch_name", Permission = "android.permission.BIND_WALLPAPER" )][MetaData( "android.service.wallpaper", Resource = "@xml/watch_face" )][MetaData( "com.google.android.wearable.watchface.preview", Resource = "@drawable/preview" )][MetaData( "com.google.android.wearable.watchface.preview_circular", Resource = "@drawable/preview_circular" )][IntentFilter( new[] { "android.service.wallpaper.WallpaperService" }, Categories = new[] { "com.google.android.wearable.watchface.category.WATCH_FACE" } )]public class AnalogWatchFaceService : CanvasWatchFaceService {中略},,,中略public class AnalogWatchFaceService : CanvasWatchFaceService {インタラクティブモードにおける更新間隔（ミリ秒単位）を表します。Java.Util.Concurrent.TimeUnit.Seconds.ToMillisメソッドは、指定した秒の値をミリ秒に変換します。（※）private static readonly long InteractiveUpdateRateMilliseconds = Java.Util.Concurrent.TimeUnit.Seconds.ToMillis( 1 );
四角形

*[MetaData( "com.google.android.wearable.watchface.preview_circular", Resource = "@drawable/preview_circular" )],,,[IntentFilter( new[] { "android.service.wallpaper.WallpaperService" }, Categories = new[] { "com.google.android.wearable.watchface.category.WATCH_FACE" } )],,,[Service( Label = "@string/watch_name", Permission = "android.permission.BIND_WALLPAPER" )][MetaData( "android.service.wallpaper", Resource = "@xml/watch_face" )][MetaData( "com.google.android.wearable.watchface.preview", Resource = "@drawable/preview" )][MetaData( "com.google.android.wearable.watchface.preview_circular", Resource = "@drawable/preview_circular" )][IntentFilter( new[] { "android.service.wallpaper.WallpaperService" }, Categories = new[] { "com.google.android.wearable.watchface.category.WATCH_FACE" } )]public class AnalogWatchFaceService : CanvasWatchFaceService {中略},,,中略public class AnalogWatchFaceService : CanvasWatchFaceService {インタラクティブモードにおける更新間隔（ミリ秒単位）を表します。Java.Util.Concurrent.TimeUnit.Seconds.ToMillisメソッドは、指定した秒の値をミリ秒に変換します。（※）private static readonly long InteractiveUpdateRateMilliseconds = Java.Util.Concurrent.TimeUnit.Seconds.ToMillis( 1 );
丸形

*}
中略

*public class AnalogWatchFaceService : CanvasWatchFaceService {// インタラクティブモードにおける更新間隔（ミリ秒単位）を表します。// Java.Util.Concurrent.TimeUnit.Seconds.ToMillisメソッドは、指定した秒の値をミリ秒に変換します。（※）private static readonly long InteractiveUpdateRateMilliseconds = Java.Util.Concurrent.TimeUnit.Seconds.ToMillis( 1 );// インタラクティブモードにて、定期的に時刻を更新するための、ハンドラー用のメッセージのIDを表します。// 値は何でもOKです。private const int MessageUpdateTime = 0;// 中略}
中略

*private static readonly long InteractiveUpdateRateMilliseconds = Java.Util.Concurrent.TimeUnit.Seconds.ToMillis( 1 );
インタラクティブモードにおける更新間隔（ミリ秒単位）を表します。
Java.Util.Concurrent.TimeUnit.Seconds.ToMillisメソッドは、指定した秒の値をミリ秒に変換します。（※）

*private const int MessageUpdateTime = 0;
インタラクティブモードにて、定期的に時刻を更新するための、ハンドラー用のメッセージのIDを表します。
値は何でもOKです。

*}
中略

*public class AnalogWatchFaceService : CanvasWatchFaceService {// 中略private class AnalogWatchFaceEngine : CanvasWatchFaceService.Engine {}}
中略

*private class AnalogWatchFaceEngine : CanvasWatchFaceService.Engine {}
中略

*public class AnalogWatchFaceService : CanvasWatchFaceService {// 中略public override WallpaperService.Engine OnCreateEngine() {return new AnalogWatchFaceEngine( this );}private class AnalogWatchFaceEngine : CanvasWatchFaceService.Engine {}}
中略

*public override WallpaperService.Engine OnCreateEngine() {return new AnalogWatchFaceEngine( this );}
中略

*private CanvasWatchFaceService owner;
CanvasWatchFaceServiceオブジェクトの参照を格納します。

*private readonly Handler updateTimeHandler;
時刻を更新する時の処理を行うハンドラーを表します。

*private Java.Util.Calendar nowTime;
現在時刻を表します。

*private Paint backgroundPaint;
背景用のペイントオブジェクトを表します。

*private Paint hourHandPaint;
時針、分針、秒針用のオブジェクトを表します。

*private bool isAmbient;
アンビエントモードであるかどうかを表します。

*private bool isRequiredLowBitAmbient;
アンビエントモード時、デバイスがLow-Bitの制限を必要としているかどうかを表します。

*private bool isReqiredBurnInProtection;
アンビエントモード時、デバイスが焼き付け防止を必要としているかどうかを表します。

*private bool isMute;
ミュート状態であるかどうかを表します。

*private TimeZoneReceiver timeZoneReceiver;
タイムゾーンを変更した時に通知を受け取るレシーバーを表します。（※）

*}
中略

*public class TimeZoneReceiver : BroadcastReceiver {// タイムゾーンを変更した通知を受け取った時に実行するデリゲートを表します。private Action<Intent> receiver;// OnReceiveメソッドで実行する処理をpublic TimeZoneReceiver( Action<Intent> _receiver ) {receiver = _receiver;}// タイムゾーンを変更した通知を受け取った時に実行します。public override void OnReceive( Context context, Intent intent ) {receiver?.Invoke( intent );}}
タイムゾーンを変更した時に通知を受け取るレシーバーを提供します。

*private Action<Intent> receiver;
タイムゾーンを変更した通知を受け取った時に実行するデリゲートを表します。

*public TimeZoneReceiver( Action<Intent> _receiver ) {receiver = _receiver;}
OnReceiveメソッドで実行する処理を

*public override void OnReceive( Context context, Intent intent ) {receiver?.Invoke( intent );}
タイムゾーンを変更した通知を受け取った時に実行します。

*this.owner = owner;
CanvasWatchFaceServiceクラスを継承したオブジェクトの参照をセットします。

*updateTimeHandler = new Handler(message => {Whatプロパティでメッセージを判別します。switch( message.What ) {
時刻を更新する時の処理を構成します。

*Invalidate();
TODO : 時刻の更新のメッセージの時の処理を入れます。
ウォッチフェイスを再描画します。

*long delayMilliseconds = InteractiveUpdateRateMilliseconds - ( timeMillseconds % InteractiveUpdateRateMilliseconds );
delayMs = 更新間隔 - ( 現在時刻（ミリ秒） % 更新間隔) -> 更新間隔との差

*updateTimeHandler.SendEmptyMessageDelayed( MessageUpdateTime, delayMilliseconds );
UpdateTimeHandlerにメッセージをセットします。
SendEmptyMessageDelayedメソッドは指定した時間後にメッセージを発行します。

*timeZoneReceiver = new TimeZoneReceiver(BroadcastReceiver.OnReceiveメソッドの実行時に実行します。intent => {新しいタイムゾーンを設定します。nowTime.TimeZone = Java.Util.TimeZone.Default;});
TimeZoneReceiverのインスタンスを生成します。

*intent => {// 新しいタイムゾーンを設定します。nowTime.TimeZone = Java.Util.TimeZone.Default;}
BroadcastReceiver.OnReceiveメソッドの実行時に実行します。

*nowTime.TimeZone = Java.Util.TimeZone.Default;
新しいタイムゾーンを設定します。

*private bool ShouldTimerBeRunning =>
UpdateTimeHandlerを動作させるかどうかを表す値を取得します。

*nowTime.Clear( intent.GetStringExtra( "time-zone" ) );
GetStringExtraメソッドで、Android Wearとペアリングしているスマートフォンで設定したタイムゾーンのIDを取得します。

*nowTime.TimeZone = Java.Util.TimeZone.Default;
TimeZone.Defaultプロパティは、Android Wearとペアリングしているスマートフォンで設定しているタイムゾーンのIDを取得します。
もちろん、AndroidのTimeクラスのように、GetStringExtraメソッドで取得したタイムゾーンのIDを設定してもOK

*nowTime = DateTime.Now;
DateTime.Nowプロパティで取得する時刻は、Android Wearとペアリングしているスマートフォンで
設定しているタイムゾーンが適用されています。


*videoCallBackFlg = false;
コールバック済みフラグをリセット

*,,,
〜〜省略

*GameSceneSingleton.Instance.setVideoSdkCallbackListener(this);
〜〜省略


*sw.Stop();
処理


*void Update()*{if (Sd1_on.activeSelf){time += Time.deltaTime;if (Input.GetKeyDown(KeyCode.F)){audioSource.PlayOneShot(Operandum1SE);if (time >= FITime){audioSource.PlayOneShot(PointSE);CountText.text = "Point : " + Point.ToString();Point += 1;time = 0;}}}if (Sd1_off.activeSelf){time = 0;}}
New


*var index = 1;
1 からの連番

*}
今回なにもする必要なし

*}
今回なにもする必要なし

*}
今回なにもする必要なし


*dictionary.TryGetValue(key, out result);
keyが見つからない場合は result に default(TValue) が代入される


*this.salesforce予定表TableAdapter.Fill(this.sharePointDataSet.Salesforce予定表);*// TODO: このコード行はデータを 'salesforceDataSet.Event' テーブルに読み込みます。必要に応じて移動、または削除をしてください。
TODO: このコード行はデータを 'sharePointDataSet.Salesforce予定表' テーブルに読み込みます。必要に応じて移動、または削除をしてください。

*this.eventTableAdapter.Fill(this.salesforceDataSet.Event);*,,,
TODO: このコード行はデータを 'salesforceDataSet.Event' テーブルに読み込みます。必要に応じて移動、または削除をしてください。


*x => x.Type == "http:
schemas.xmlsoap.orgws200505identityclaimsnameidentifier")?.Value;


*c.myEvent += func1;
イベントの登録

*private void func1(string txt) => Debug.WriteLine(txt);
呼出側が、発生側のクラスに登録するメソッド

*public class TestClass*{// デリゲートを登録public delegate void TestDelegate(string txt);public TestDelegate myDelegate;// イベントを登録public event TestDelegate myEvent;// Actionもデリゲートなので、eventにできるpublic event Action<string> myAction;// 登録したイベント/デリゲートを読んでみるメソッドpublic void doFunc(TestDelegate func){myDelegate?.Invoke("デリゲートです");myAction?.Invoke("アクションです");myEvent?.Invoke("イベントです");}}
「発生側」のクラス

*public delegate void TestDelegate(string txt);
デリゲートを登録

*public event TestDelegate myEvent;
イベントを登録

*public event Action<string> myAction;
Actionもデリゲートなので、eventにできる

*public void doFunc(TestDelegate func)*{myDelegate?.Invoke("デリゲートです");myAction?.Invoke("アクションです");myEvent?.Invoke("イベントです");}
登録したイベント/デリゲートを読んでみるメソッド

*private void OnSensorDataReceived(int temperature)*{textbox1.Text = temperature.ToString();}
View/ViewModelが用意するメソッド

*sensorModel.OnSensorDataReceived += OnSensorDataReceived;
温度更新時に読んでほしいメソッドをModelに登録


*string targetName = name;
ここがポイント


*VoiceClient.Send(buffer, 0, blockSize);
Send the buffer to Discord


*X509ChainStatusFlags.UntrustedRoot;
ルート証明書が信頼されていない

*//By default, we trust all certificates.*return true;
This is where you implement logic to determine if you trust the certificate.


*switch (Start.Key)
エンターキーが押されたときの動作


*public float moveSpeed  = 10.0f;
移動速度を数パターン設定（後進は-で定義)

*currentGyro = Input.gyro.attitude;
Gyroセンサーを感知

*float angle = diveCamera.transform.eulerAngles.x;*// 2.ある角度以内であれば前進させる
1.カメラの傾きを取得

*public void moveForward() {Vector3 direction = new Vector3 (diveCamera.transform.forward.x, 0, diveCamera.transform.forward.z).normalized * moveSpeed * Time.deltaTime;Quaternion rotation = Quaternion.Euler (new Vector3 (0, -diveCamera.transform.rotation.eulerAngles.y, 0));diveCamera.transform.Translate (rotation * direction);diveCamera.transform.position = new Vector3 (diveCamera.transform.position.x, yOffset, diveCamera.transform.position.z);}
2.速度に合わせて移動(moveForward,runForward,moveBackward)を定義


*});
Parallel.For


*WritingCreator.ReleaseDate = DateTime.Now;
投稿時の日付を自動記載


*| ActivityFlags.ExcludeFromRecents
最近使ったアプリの一覧に表示しない

*var scene = Layers.GameStartLayer.GetScene(mainWindow);
ゲームの起点画面に遷移

*gv.DesignResolution = new CCSizeI(Helpers.Settings.AppWidth, Helpers.Settings.AppHeight);
Helpersはアプリ内でGlobalに使いまわす自作ヘルパ

*return base.OnBackButtonPressed();
戻るボタン無効化するならfalse

*CommonImagesCache.Add(key.ToKey(), GameImageLoader.GetSprite(key.ToName()));
GameImageLoader.GetSpriteはAssemblyからpng読み出してCCSpriteインスタンスを作り返すメソッド


*reticle.transform.position = hit.point + (hit.normal * hitRayPosition);
hitRayPosition は画像が当たった対象にめり込まない程度に設定する

*}
略

*else {reticle.transform.localPosition = new Vector3(0, 0, defaultPos.z);reticle.transform.localRotation = defaultRotation;}
デフォルトのRayの位置


*new Claim("http:
schemas.xmlsoap.orgws200505identityclaimsnameidentifier", userid)

*var principal = new GenericPrincipal(identity, null);
Principalを生成し、HttpContextのUserにセットする。

*ctrl = new TestCardsController();
テスト対象のコントローラを生成し、ControllerContextをセットする。

*var instance = System.Data.Entity.SqlServer.SqlProviderServices.Instance;
未使用DLLはテストプロジェクトの実行領域にコピーされないためインスタンスを生成する。


*ExtensionConfiguration = new ExtensionConfiguration()
Diagnosticsの拡張機能とロールを紐づける

*var response = managementClient.Deployments.Create(CloudServiceName, deploymentSlot, parameters);
デプロイ実行 ComputeManagementClientを以下の様に利用する


*Bitmap bitmap;
保存したいBitmapが格納済み

*String imgname = "img_";
保存する画像の名前を決める

*ContextWrapper cw = new ContextWrapper(this.ApplicationContext);
保存先のパスとか

*using (var os = new System.IO.FileStream(myfile.AbsolutePath, System.IO.FileMode.Create)){bitmap.Compress(Android.Graphics.Bitmap.CompressFormat.Png, 100, os);
保存


*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"


*.DisableDirectStreaming()
これはデバッグ用


*Enumerable.Range(0, 100)
第一引数が初期値で、第二引数は繰り返し回数になる。1ずつインクリメントされる。


*Graphics.Blit(mainTexture, paintMainTexture);
メインテクスチャのコピー

*material.SetTexture(mainTexturePropertyID, paintMainTexture);
マテリアルのテクスチャをRenderTextureに変更


*int LengthValue = 0;
一行の配列の長さ

*LengthValue = EndPoint - StartPoint + 1 - 2;
CRLF分減らす

*byte[] LineVal = GetByteFromByte(_GetBinData, StartPoint, LengthValue);
行データ取得

*int count = 0;
取込データ出力


*private string ApiUrl = "http:
api.ekispert.jp";

*ArrayList YearArray = new ArrayList();
年

*index = 0;
月

*index = 0;
日

*ArrayList HourArray = new ArrayList();
時

*ArrayList MinuteArray = new ArrayList();
分


*cs.Dispatch(emitKernel, emitNum
THREAD_NUM_X, 1, 1);    emitNumの数だけ発生

*void Update () {// マウスボタンがクリックされたらカーソルの位置からパーティクルを生成するif (Input.GetMouseButton(0)){Vector3 mpos = Input.mousePosition;mpos.z = 10;Vector3 pos = camera.ScreenToWorldPoint(mpos);EmitParticle(pos);}UpdateParticle();}
Update is called once per frame


*NiceAsyncMethod().Wait();
Waitしてもデッドロックしない！


*var xslt = new XslCompiledTransform();*xslt.Load(stylesheetUri);
XSLTファイル の読み込み

*var output = new StringBuilder();
出力先を 文字列 として準備

*var settings = new XmlWriterSettings();
出力フォーマット の指定

*using(var writer = XmlWriter.Create(output, settings)) {xslt.Transform(inputUri, writer);
XSLT を利用した 変換処理

*Console.WriteLine(output.ToString());
LaTeXの文字列はoutput.ToString()で得られる


*var evens = Positives.Where(i => i%2 != 0);
変数名もつけられる

*}
略


*int Seed = Environment.TickCount;
TickCountで取得した、コンピュータを起動してからの経過時間をミリ秒単位で取得し、ランダムデータ生成のSeed値とする

*int MaxRoop = 100;
ランダムデータ生成件数

*Random SeedRoopCountRondom1 = new Random();
普通のランダムクラスのインスタンスを生成

*int SeedRoopCount1 = SeedRoopCountRondom1.Next(200);
上限値を適当に設定し、数値をひとつ取り出す

*rnd = new Random(Seed++);
ランダムクラス「rnd」にSeed値をインクリメントしたものを与えてインスタンス生成
ここでループを繰り返してSeed値を与えることで、よりランダム性のある数値を作ることができる

*int value = rnd.Next(1, 100000);
ランダムデータとして取り出したい範囲の値を設定

*System.Threading.Thread.Sleep(51);
51ミリ秒待つのがポイント(根拠は正直あまりない…)
ここで待機時間を入れないとマシンの性能によってはSeed値に規則性が生まれてしまい、ランダムデータが規則的な間隔で出力されるため

*sw.WriteLine(value);
csvにデータを書き込みする


*10.0f
どれくらいの時間

*,,,
省略


*public class ProfileSettings*{public string[] Genders { get; set; }}
設定クラス

*services.Configure<ProfileSettings>(Configuration.GetSection("ProfileSettings"));
設定ファイルのセクションの内容をProfileSettingsとして登録

*[MetricsFilter]
使用例

*return services.BuildServiceProvider();
ここでカスタムIServiceProviderを返せばそれが使用される


*void Start () {seedPs = GetComponent<ParticleSystem>();StartCoroutine(ProgressCo());}
Use this for initialization

*void Update () {}
Update is called once per frame

*explodeAudioObj.GetComponent<AudioSource>().pitch *= Random.Range(0.8f, 1.2f);
爆発音

*Destroy(gameObject);
消滅


*int count = 0;*using (IEnumerator<TSource> e = source.GetEnumerator()) {checked {while (e.MoveNext()) count++;}}
～～ (省略) ～～

*Console.WriteLine("件数：{0}", intArray.Count());
ICollectionを実装して無い為、全要素をループして件数をカウンティングする。

*Console.WriteLine("件数：{0}", intList.Count());
宣言はIEnumerable<T>でも実体はICollectionを実装している為、プロパティの値を返してくれる。


*gazedTime += Time.deltaTime;
Rayが当たっている時間をincrease


*// List<T> の代わりに System.ComponentModel.BindingList<T> を使えばリストを更新するだけでコントロールも更新されるようです。機能は少々ゴテっとしていますが。*// private BindingList<string> stringList = new BindingList<string> { "abc", "123" };
2016-12-19 追記

*// private BindingList<string> stringList = new BindingList<string> { "abc", "123" };
List<T> の代わりに System.ComponentModel.BindingList<T> を使えばリストを更新するだけでコントロールも更新されるようです。機能は少々ゴテっとしていますが。

*public UserControl1()*{InitializeComponent();comboBox1.DataSource = stringList;}
private BindingList<string> stringList = new BindingList<string> { "abc", "123" };

*// DataSource (List<string>) と ComboBox を直結*stringList.AddRange(new List<string> { "x", "y" });
全体入れ替え - アイテムに x, y が追加される

*stringList.AddRange(new List<string> { "x", "y" });
DataSource (List<string>) と ComboBox を直結

*comboBox1.DataSource = null;
ComboBox を更新、null 代入が必要

*// DataSource (List<string>) と ComboBox を直結*var newList = new List<string> { "x", "y" };
全体入れ替え - アイテム x, y が追加される

*var newList = new List<string> { "x", "y" };
DataSource (List<string>) と ComboBox を直結

*comboBox1.DataSource = newList;
ComboBox を更新

*var bindingSource1 = new BindingSource(stringList, "");
List<> と ComboBox の間に BindingSource をかます

*stringList.Add("def");
データソースに def を追加して

*bindingSource1.ResetBindings(false);
ComboBox を更新

*var bindingSource1 = new BindingSource(stringList, "");
項目更新
List<> と ComboBox の間に BindingSource をかます

*private List<UserData> userDataList = new List<UserData>
12-06-2016 追加
string ではなくユーザデータを DataSource に。


*asd.Engine.Initialize("Empty", 640, 480, new asd.EngineOption());
Altseedを初期化する。

*asd.Engine.Update();
Altseedを更新する。

*asd.Engine.Terminate();
Altseedの終了処理をする。


*var traceProfiler = new TraceProfler();
IAdoNetProfilerを実装したクラスのオブジェクト

*}
DBアクセス処理

*AdoNetProfilerFactory.Initialize(typeof(TraceProfiler));
アプリケーションの起動時または初期化時に呼び出す

*var factory = DbproviderFactories.GetFactory("System.Data.SqlClient");
これまで通りDbProviderFactoryを取得

*using (var connection = factory.CreateConnection()){connection.ConnectionString = "[接続文字列]";
AdoNetProfilerConnectionが生成される

*}
DBアクセス処理


*public static readonly int HANDVALUE_PAA = 2;
パーを表す値

*public interface Strategy*{Hand NextHand();void Study(bool win);}
・戦略を定めるためのインターフェース（API）を定める

*public class WinningStrategy : Strategy*{private Random random;private bool won = false;private Hand prevHand;public WinningStrategy(int seed){random = new Random(seed);}public Hand NextHand(){if (!won){prevHand = Hand.GetHand(random.Next(3));}return prevHand;}public void Study(bool win){won = win;}}
・Strategyのインターフェース（API）を実装する

*public class ProbStrategy : Strategy*{private Random random;private int prevHandValue = 0;private int currentHandValue = 0;private int[][] history ={new int[] { 1, 1, 1, },new int[] { 1, 1, 1, },new int[] { 1, 1, 1, },};public ProbStrategy(int seed){random = new Random(seed);}public Hand NextHand(){int bet = random.Next(GetSum(currentHandValue));int handvalue = 0;if (bet < history[currentHandValue][0]){handvalue = 0;}else if (bet < history[currentHandValue][0] + history[currentHandValue][1]){handvalue = 1;}else{handvalue = 2;}prevHandValue = currentHandValue;currentHandValue = handvalue;return Hand.GetHand(handvalue);}private int GetSum(int hv){int sum = 0;for (int i = 0; i < 3; i++){sum += history[hv][i];}return sum;}public void Study(bool win){if (win){history[prevHandValue][currentHandValue]++;}else{history[prevHandValue][(currentHandValue + 1) % 3]++;history[prevHandValue][(currentHandValue + 2) % 3]++;}}}
ConcreteStrategy

*public class Player
・Strategyを利用する
・ConcreteStrategyのインスタンスを持っていて、必要に応じて利用する
・呼び出すのはStrategyのインターフェース


*decimaltest = c.Decimal(nullable: false, precision: 18, scale: 2),,,public class CustomAttributes{[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]public sealed class DecimalPrecisionAttribute : Attribute{public DecimalPrecisionAttribute(byte precision, byte scale){Precision = precision;
percisionとscaleの値を変更してやればお望みの桁数にできる


*foreach(var obj in Objects.ToArray())
ToArray() でコピー

*enum RegistrationCommand*{Add = 0,Remove = 1,}
コレクションの操作の種類：追加、削除

*class EventToManageObject*{public EventToManageObject(Layer layer, Object content, RegistrationCommand command){ObjectManager = objectManager;Content = content;Command = command;}// 描画オブジェクトを追加または削除する対象のレイヤーprivate Layer Layer { get; }// 追加または削除する描画オブジェクトpublic Object Content { get; }// 行う処理が追加なのか削除なのかpublic RegistrationCommand Command { get; }// 実際に追加・削除をするpublic void Commit(){// 追加操作であれば実際に追加if(Command == RegistrationCommand.Add){// ImmediatelyAddObjectはバッファリングを介さず直接追加するLayer.ImmediatelyAddObject(Content);}// 削除操作であれば実際に削除else if(Command == RegistrationCommand.Remove){// ImmediatelyRemoveObjectはバッファリングを介さず直接削除するLayer.ImmediatelyRemoveObject(Content);}}}
描画オブジェクトのコレクションに対する操作イベント

*private Layer Layer { get; }
描画オブジェクトを追加または削除する対象のレイヤー

*public Object Content { get; }
追加または削除する描画オブジェクト

*public RegistrationCommand Command { get; }
行う処理が追加なのか削除なのか

*public void Commit()*{// 追加操作であれば実際に追加if(Command == RegistrationCommand.Add){// ImmediatelyAddObjectはバッファリングを介さず直接追加するLayer.ImmediatelyAddObject(Content);}// 削除操作であれば実際に削除else if(Command == RegistrationCommand.Remove){// ImmediatelyRemoveObjectはバッファリングを介さず直接削除するLayer.ImmediatelyRemoveObject(Content);}}
実際に追加・削除をする

*Layer.ImmediatelyAddObject(Content);
ImmediatelyAddObjectはバッファリングを介さず直接追加する

*Layer.ImmediatelyRemoveObject(Content);
ImmediatelyRemoveObjectはバッファリングを介さず直接削除する


*Console.WriteLine(record.No+ "," + record.ReceptDate.ToString());
ちゃんと読み込めているか確認してみる


*var record = reader.ReadLine().Split(',').Select(a => a.Trim('"')).ToArray();
CSVを分解（囲み文字の二重引用符も除去）

*var output = new string[]{ record[0], record[2], record[1], record[3] };
入れ替え

*writer.WriteLine(string.Join(",", output.Select(a => "\"" + a + "\"")));
CSV形式で出力


*var req = new HttpRequestMessage(HttpMethod.Post, new Uri("https:
hoge.hogehoge"));


*var d2 = Math.Ceiling(-0.5);
0


*services.AddOptions();
IOptions<T>でのインジェクション有効化


*string path = System.IO.Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), "RegAsm.exe");
RegAsm のパスを取得

*Console.WriteLine("[" + path + "]");
パスをコンソールに出力

*StringBuilder buff = new StringBuilder(128);
渡されたコマンドライン引数をそのまま渡す

*p.StartInfo.UseShellExecute = false;
出力を取得できるようにする

*p.StartInfo.CreateNoWindow = true;
ウィンドウを表示しない

*p.Start();
起動

*string results = p.StandardOutput.ReadToEnd();
出力を取得

*p.WaitForExit();
プロセス終了まで待機する

*Console.WriteLine(results);
出力された結果を表示


*var perm = new Permutation();*foreach (var n in perm.Enumerate(new[] { 1, 2, 3, 4 })) {
確認用コード


*process.Kill();
例外が発生する可能性のあるメソッド


*protected override C Apply(B b)
エラー: 共変戻り値不可


*class Program*{static void Main(string[] args){SampleClass cls = new SampleClass();cls.SampleMethod("テスト実行");Console.ReadLine();}}
EntryPoint

*[MyAspect]
実行対象クラス

*RealProxy rp = RemotingServices.GetRealProxy(this._target);
以下、コンストラクタを実行する処理

*//メソッド前処理*Console.WriteLine("[{0}]{1} : 実行開始",
以下、コンストラクタ以外のメソッドを実行する処理

*Console.WriteLine("[{0}]{1} : 実行開始",DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"), call.MethodName);
メソッド前処理

*res = RemotingServices.ExecuteMessage(this._target, call);
メソッド実行

*Console.WriteLine("[{0}]{1} : 実行終了",DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"), call.MethodName);
メソッド後処理

*void PreProcessing(IMethodCallMessage call);
メソッド実行前処理メソッド

*void PostProcessing(IMethodCallMessage call, IMethodReturnMessage res);
メソッド実行後処理メソッド

*Console.WriteLine("[{0}]{1} : 実行開始",DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"), call.MethodName);
メソッド前処理

*Console.WriteLine("[{0}]{1} : 実行終了",DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"), call.MethodName);
メソッド後処理

*RealProxy rp = RemotingServices.GetRealProxy(this._target);
以下、コンストラクタを実行する処理

*//メソッド前処理*//Console.WriteLine("[{0}]{1} : 実行開始",
以下、コンストラクタ以外のメソッドを実行する処理

*Console.WriteLine("[{0}]{1} : 実行開始",DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"), call.MethodName);
メソッド前処理

*this._container.PreProcessing(call);
Console.WriteLine("[{0}]{1} : 実行開始",
DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"), call.MethodName);

*res = RemotingServices.ExecuteMessage(this._target, call);
メソッド実行

*Console.WriteLine("[{0}]{1} : 実行終了",DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"), call.MethodName);
メソッド後処理

*this._container.PostProcessing(call, res);
Console.WriteLine("[{0}]{1} : 実行終了",
DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"), call.MethodName);


*var accountName = "teststorage";
storageAccountの作成（接続情報の定義）
アカウントネームやキー情報はAzureポータルから確認できる。

*CloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();
こういう書き方もできるし、Configから読み込むこともできる。
CloudStorageAccount storageAccount = CloudStorageAccount.Parse("DefaultEndpointsProtocol=https;AccountName=アカウントネーム;AccountKey=アクセスキー");
blob

*CloudBlockBlob blockBlob_upload = container.GetBlockBlobReference("aaa.jpg");
もし無かったら作る
container.CreateIfNotExists();
upload
アップロード後のファイル名を指定（無くてよい）

*using (var fileStream = System.IO.File.OpenRead(@"C:\Users\hoge\Desktop\bbb.jpg"))
アップロード処理
アップロードしたいローカルのファイルを指定

*CloudBlockBlob blockBlob_download = container.GetBlockBlobReference("ccc.jpg");
ダウンロードするファイル名を指定

*blockBlob_download.DownloadToFile(@"C:\Users\hoge\Desktop\ddd.jpg", System.IO.FileMode.CreateNew);
ダウンロード処理
ダウンロード後のパスとファイル名を指定。

*Console.WriteLine("処理を完了しました。");
削除
blockBlob_download.Delete();

*var accountName = "teststorage";
アカウントネームやキー情報はAzureポータルから確認できる。

*CloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();
ここまではstorage共通
blob

*container.CreateIfNotExistsAsync();
無かったら作る

*CloudAppendBlob appendBlob = container.GetAppendBlobReference("server01.log");
ここまではblob共通
appendblob
BlockBlobではなくAppenDBlobのリファレンスを取得する

*if(!appendBlob.Exists()) appendBlob.CreateOrReplace();*//書き込み
無かったら作る

*appendBlob.AppendText(DateTime.Now+" Log message.\n");
書き込み

*Console.WriteLine(appendBlob.DownloadText());
内容表示

*Console.ReadLine();
待つ


*System.Environment.Exit(returnCd);
リターンコードを返却しながら終了する。


*public static Tensor operator +(Tensor tensor1, Tensor tensor2)*{return new Add().Forward(tensor1, tensor2);}
演算子のオーバーロード


*_immutable.Value = value;
CS1648が発生｡

*Console.WriteLine($"_mutable.Count:{_mutable.Count}");
1

*Console.WriteLine($"_mutable.Counter:{_mutable.Counter.Count}");
1

*Console.WriteLine($"_immutable.Count:{_immutable.Count}");
0のまま!

*Console.WriteLine($"_immutable.Counter:{_mutable.Counter.Count}");
1

*Console.WriteLine($"_immutable.Count:{_immutable.Count}");
0

*Console.WriteLine($"_immutable.Counter:{_immutable.Counter.Count}");
1


*.UseUrls("http:
*:80")     ここを追加


*using(FileStream fs = new FileStream("./test.txt",FileMode.Append))using(StreamWriter writer = new StreamWriter(fs)){writer.WriteLine(DateTime.Now+"Time is "+sw.Elapsed);
write log


*using(var connection = new SqlConnection(constr)){commandusing(var command = connection.CreateCommand()){try{connection.Open();
connection

*using(var command = connection.CreateCommand()){try{connection.Open();
command

*using(var reader = command.ExecuteReader()){loopwhile(reader.Read() == true){Console.WriteLine(reader["id"]+" "+reader["name"]+" "+reader["email"]);
reader

*public class Member*{public int id {get;set;}public string name {get;set;}public string email {get;set;}}
data

*public class MyContext:DbContext*{public DbSet<Member> Members{get;set;}protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)=> optionsBuilder.UseSqlServer(@"server=192.168.77.129;database=sample;uid=sa;pwd=P@ssw0rd!;");}
context

*public class Program*{public static void Main(string[] args){using(var context = new MyContext()){//selectvar ret = context.Members.ToList();foreach(var x in ret){Console.WriteLine($"{x.name} {x.email}");}}}}
main

*var ret = context.Members.ToList();
select

*public class Member*{public int id {get;set;}public string name {get;set;}public string email {get;set;}}
model

*public static void Main(string[] args)*{using(var connection = new SqlConnection(@"Data Source=192.168.77.129;Initial Catalog=sample;User Id=sa;Password=P@ssw0rd!;")){connection.Open();var members = connection.Query<Member>("select * from members");foreach(var member in members){Console.WriteLine(member.name + " " + member.email);}}}
main


*.ToArray();
→ Aオブジェクト1つだけの配列となる

*var arrayOfA2 = objects.OfType<A>();
以下のように`OfType`を用いても同じ結果になるので、こう書く方がベター


*Console.ReadLine();
実行が一瞬で終わって確認できないので、キーの入力を待ちます

*public class Display
・機能のクラス階層の最上位クラス
・Implementorを使用して基本的なメソッドを実装する
・機能クラスの階層と実装クラスの階層を橋渡しするImplementerを保持

*public class CountDisplay : Display*{public CountDisplay(DisplayImpl impl) : base(impl) { }public void MultiDisplay(int times){Open();for (int i = 0; i < times; i++){Print();}Close();}}
・Abstractionに対して機能を追加

*public abstract class DisplayImpl
・実装のクラス階層の最上位クラス
・Abstranctionのインターフェース（API）を規定する

*public class StringDisplayImpl : DisplayImpl*{private string str;private int width;public StringDisplayImpl(string str){this.str = str;Encoding sjisEnc = Encoding.GetEncoding("shift_jis");this.width = sjisEnc.GetByteCount(str);}public override void RawOpen(){PrintLine();}public override void RawPrint(){Console.WriteLine($"|{str}|");}public override void RawClose(){PrintLine();}public void PrintLine(){Console.Write("+");for (int i = 0; i <width; i++){Console.Write("-");}Console.WriteLine("+");}}
・Implementatorを具体的に実装する


*bool isMove = false;*if(Input.GetKey(KeyCode.W)){isMove = true;moveVec = new Vector3(viewVec.x, 0, viewVec.z).normalized * speed * Time.deltaTime;Rigidbody.velocity = new Vector3(moveVec.x, Rigidbody.velocity.y, moveVec.z);}
Move

*void LookAtSet(){camPos = this.transform.position + viewVec;this.transform.LookAt(new Vector3(camPos.x, this.transform.position.y, camPos.z));camera.transform.position = new Vector3(camPos.x, this.transform.position.y + 0.5f, camPos.z);camera.transform.LookAt(camera.transform.position + viewVec);}
Viewpoint

*bool isMove = false;*if(Input.GetKey(KeyCode.W)){isMove = true;moveVec = new Vector3(viewVec.x, 0, viewVec.z).normalized * speed * Time.deltaTime;Rigidbody.velocity = new Vector3(moveVec.x, Rigidbody.velocity.y, moveVec.z);}
Move


*command.CommandText = "PRAGMA TABLE_INFO(employee);";
employeeテーブル情報取得

*var tableInfo = new TableInfo {ColumnName = reader["name"].ToString(),DataType = reader["type"].ToString()};
name: カラム名, type: データ型

*var name = new CodeNamespace(nameSpace);
名前空間を設定

*var classType = new CodeTypeDeclaration(className);*foreach (var t in tableInfo) {//propertyを定義var field = new CodeMemberField {Attributes = MemberAttributes.Public | MemberAttributes.Final,Name = $"{ t.ColumnName } {{ get; set; }}",Type = new CodeTypeReference(this.GetPropertyDataType(t.DataType)),};classType.Members.Add(field);}
クラス定義 引数にはクラス名を設定

*var field = new CodeMemberField {Attributes = MemberAttributes.Public | MemberAttributes.Final,Name = $"{ t.ColumnName } {{ get; set; }}",
propertyを定義

*var fileName = $"{ classType.Name }.{ provider.FileExtension }";
CSharpCodeProvider().FileExtensionで｢cs｣拡張子を取得できます

*using (var writer = File.CreateText(fileName)) {provider.GenerateCodeFromCompileUnit(compileUnit,writer,new CodeGeneratorOptions());
Entityクラスを出力

*namespace Namespace1 {
このコードはツールによって生成されました。
ランタイム バージョン:4.0.30319.42000

このファイルへの変更は、以下の状況下で不正な動作の原因になったり、
コードが再生成されるときに損失したりします。
</auto-generated>
------------------------------------------------------------------------------

*string fileDetail = File.ReadAllText(fileName).Replace("};", "}");
ファイルを読込み､波括弧末尾のセミコロンを削除

*using (var writer = new StreamWriter(fileName)) {writer.Write(fileDetail);
再度ファイルに書き出す

*var name = new CodeNamespace(nameSpace);
名前空間を設定

*var classType = new CodeTypeDeclaration(className);*foreach (var t in tableInfo) {//propertyを定義var field = new CodeMemberField {Attributes = MemberAttributes.Public | MemberAttributes.Final,Name = $"{ t.ColumnName } {{ get; set; }}",Type = new CodeTypeReference(this.GetPropertyDataType(t.DataType)),};classType.Members.Add(field);}
クラス定義 引数にはクラス名を設定

*var field = new CodeMemberField {Attributes = MemberAttributes.Public | MemberAttributes.Final,Name = $"{ t.ColumnName } {{ get; set; }}",
propertyを定義

*var fileName = $"{ classType.Name }.{ provider.FileExtension }";
CSharpCodeProvider().FileExtensionで｢cs｣拡張子を取得できます

*using (var writer = File.CreateText(fileName)) {provider.GenerateCodeFromCompileUnit(compileUnit, writer, new CodeGeneratorOptions());
Entityクラスを出力

*this.DeletePropertysEndSemicolon(fileName);
各プロパティ末尾のセミコロン削除

*namespace Namespace1 {
このコードはツールによって生成されました。
ランタイム バージョン:4.0.30319.42000

このファイルへの変更は、以下の状況下で不正な動作の原因になったり、
コードが再生成されるときに損失したりします。
</auto-generated>
------------------------------------------------------------------------------

*var name = new CodeNamespace("Namespace1");
名前空間を設定

*name.Imports.Add(new CodeNamespaceImport("System"));
Systemをインポート

*var classType = new CodeTypeDeclaration("HelloWorld");
クラス定義 引数にはクラス名を設定

*var method = new CodeEntryPointMethod();
public static void Main() を作成

*var writeLine = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression("Console"), "WriteLine",
Console.WriteLine("Hello World!"); を定義

*var readKey = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression("Console"), "ReadKey"
Console.ReadKey(); を定義

*method.Statements.Add(new CodeExpressionStatement(writeLine));
上記で定義した処理をMain()に追加する

*provider.GenerateCodeFromCompileUnit(compileUnit, Console.Out, new CodeGeneratorOptions());
確認のため生成コードをコンソールへ出力

*var param = new CompilerParameters { GenerateExecutable = true, OutputAssembly = "HelloWorld.exe" };
実行ファイル(HelloWorld.exe)を作成


*var referenceNodes = doc.DocumentNode.SelectNodes("
itemgroupreference");


*var human = new Human();
OK

*interface IChirp*{void chirp();}
追加

*}
鳴く処理

*}
飛ぶ処理

*var jsonString = GetJson();
ここで継承先でそれぞれの通信を実装

*return new { json = jsonString };
jsonStringをオブジェクトにして返す(今回は省略)

*return "TwitterAPIの結果のJSON";
通信して結果のオブジェクトを作成
APIからJSONを取得して返す

*return "InstagramAPIの結果のJSON";
通信して結果のオブジェクトを作成
APIからJSONを取得して返す

*return "YoutubeAPIの結果のJSON";
通信して結果のオブジェクトを作成
APIからJSONを取得して返す

*IObject[] objects = new IObject[] { twitterApi, instagramApi, youtubeApi };
上記のインスタンス


*public class hogehoge : Program
継承させてProgramクラスの動作を再利用


*Link google = factory.CreateLink("Google", "http:
www.google.com");

*Console.ReadLine();
実行が一瞬で終わって確認できないので、キーの入力を待ちます

*public abstract class Item*{protected string caption;public Item(string caption){this.caption = caption;}public abstract string MakeHTML();}
・AbstractFactoryによって作り出される抽象的な部品や製品のインターフェース（API）を定める

*public abstract class Link : Item*{protected string url;public Link(string caption, string url) : base(caption){this.url = url;}}
AbstractProduct

*public abstract class Tray : Item*{protected List<Item> tray = new List<Item>();public Tray(string caption) : base(caption) { }public void Add(Item item){tray.Add(item);}}
AbstractProduct

*public abstract class Page*{protected string title;protected string author;protected List<Item> content = new List<Item>();public Page(string title, string author){this.title = title;this.author = author;}public void Add(Item item){this.content.Add(item);}public void Output(){try{string filename = title + ".html";using (StreamWriter writer = new StreamWriter(filename, false, Encoding.UTF8)){writer.Write(this.MakeHTML());}Console.WriteLine($"{filename}を作成しました。");}catch(IOException e){Console.Error.WriteLine(e);}}public abstract string MakeHTML();}
AbstractProduct

*public abstract class Factory*{public static Factory GetFactory(string classname){Factory factory = null;try{Assembly assembly = Assembly.GetExecutingAssembly();factory = (Factory)assembly.CreateInstance(classname,false,BindingFlags.CreateInstance,null,null,null,null);}catch(TypeLoadException){Console.Error.WriteLine($"クラス{classname}が見つかりません。");}catch(Exception e){Console.Error.WriteLine(e.StackTrace);}return factory;}public abstract Link CreateLink(string caption, string url);public abstract Tray CreateTray(string caption);public abstract Page CreatePage(string title, string author);}
・AbstractProductのインスタンスを作り出すためのインターフェース（API）を定める

*public class ListFactory : Factory*{public override Link CreateLink(string caption, string url){return new ListLink(caption, url);}public override Tray CreateTray(string caption){return new ListTray(caption);}public override Page CreatePage(string title, string author){return new ListPage(title, author);}}
ConcreteFactory

*public class ListLink : Link*{public ListLink(string caption, string url) : base(caption, url) { }public override string MakeHTML(){return $"  <li><a href=\"{url}\">{caption}</a></li>\n";}}
ConcreteProduct

*public class ListTray : Tray*{public ListTray(string caption) : base(caption) { }public override string MakeHTML(){StringBuilder sb = new StringBuilder();sb.Append("<li>\n");sb.Append($"{caption}\n");sb.Append("<ul>\n");IEnumerator<Item> e = tray.GetEnumerator();while (e.MoveNext()){sb.Append(e.Current.MakeHTML());}sb.Append("</ul>\n");sb.Append("</li>\n");return sb.ToString();}}
ConcreteProduct

*public class ListPage : Page*{public ListPage(string title, string author) : base(title, author) { }public override string MakeHTML(){StringBuilder sb = new StringBuilder();sb.Append($"<html><head><title>{title}</title></head>\n");sb.Append("<body>\n");sb.Append($"<h1>{title}</h1>");sb.Append("<ul>\n");IEnumerator<Item> e = content.GetEnumerator();while (e.MoveNext()){sb.Append(e.Current.MakeHTML());}sb.Append("</ul>\n");sb.Append($"<hr><address>{author}</address>");sb.Append("</body></html>\n");return sb.ToString();}}
ConcreteProduct

*public class TableFactory : Factory*{public override Link CreateLink(string caption, string url){return new TableLink(caption, url);}public override Tray CreateTray(string caption){return new TableTray(caption);}public override Page CreatePage(string title, string author){return new TablePage(title, author);}}
Concrete Factory

*public class TableLink : Link*{public TableLink(string caption, string url) : base(caption, url) { }public override string MakeHTML(){return $"<td><a href=\"{url}\">{caption}</a></td>\n";}}
ConcreteProduct

*public class TableTray : Tray*{public TableTray(string caption) : base(caption) { }public override string MakeHTML(){StringBuilder sb = new StringBuilder();sb.Append("<td>");sb.Append("<table width=\"100%\" border=\"1\"><tr>");sb.Append($"<td bgcolor=\"#cccccc\" align=\"center\" colspan=\"{tray.Count}\"<b>{caption}</b></td>");sb.Append("</tr>\n");sb.Append("<tr>\n");IEnumerator<Item> e = tray.GetEnumerator();while (e.MoveNext()){sb.Append(e.Current.MakeHTML());}sb.Append("<tr></table>");sb.Append("</tr>");return sb.ToString();}}
ConcreteProduct

*public class TablePage : Page*{public TablePage(string title, string author) : base(title, author) { }public override string MakeHTML(){StringBuilder sb = new StringBuilder();sb.Append($"<html><head><title>{title}</title></head>\n");sb.Append("<body>\n");sb.Append($"<h1>{title}</h1>\n");sb.Append("<table width=\"80%\" border=\"3\">\n");IEnumerator<Item> e = content.GetEnumerator();while (e.MoveNext()){sb.Append($"<tr>{e.Current.MakeHTML()}</tr>");}sb.Append("</table>\n");sb.Append($"<hr><address>{author}</address>");sb.Append("</body></html>\n");return sb.ToString();}}
ConcreteProduct


*using (ShimsContext.Create())*{var c2 = new ClassLibrary1.Class2();ClassLibrary1.Fakes.ShimClass1.AllInstances.CalInt32Int32 = (ClassLibrary1.Class1 obj, int x, int y) =>{// c1.Cal(1, 2); が実行されていることを確認するAssert.AreEqual(c2.c1, obj);Assert.AreEqual(1, x);Assert.AreEqual(2, y);return 999999;};var act = c2.CallCal();// Shimで偽装した値が返ってくることを確認する。Assert.AreEqual(999999, act);}
ShimsContextのブロック内のみ偽装する。

*Assert.AreEqual(c2.c1, obj);
c1.Cal(1, 2); が実行されていることを確認する

*Assert.AreEqual(999999, act);
Shimで偽装した値が返ってくることを確認する。

*private Test6Ret test6()*{return new Test6Ret();}
パラメータまたは戻り値が公開された型でないので偽装ができない。

*using (ShimsContext.Create())*{var c2 = new ClassLibrary1.Class2();ClassLibrary1.Fakes.ShimClass3.AllInstances.test1 = (ClassLibrary1.Class3 obj) =>{return 11;};ClassLibrary1.Fakes.ShimClass3.test2 = () =>{return 22;};ClassLibrary1.Fakes.ShimClass3.AllInstances.test3 = (ClassLibrary1.Class3 obj) =>{return 33;};ClassLibrary1.Fakes.ShimClass3.AllInstances.test4 = (ClassLibrary1.Class3 obj) =>{return 44;};ClassLibrary1.Fakes.ShimClass3.AllInstances.test5 = (ClassLibrary1.Class3 obj) =>{return null;};//これは作られない。//ClassLibrary1.Fakes.ShimClass3.AllInstances.test6 = (ClassLibrary1.Class3 obj) =>//{//    return null;//};}
ShimsContextのブロック内のみ偽装する。

*//ClassLibrary1.Fakes.ShimClass3.AllInstances.test6 = (ClassLibrary1.Class3 obj) =>*//{//    return null;//};
これは作られない。

*//{//    return null;//};
ClassLibrary1.Fakes.ShimClass3.AllInstances.test6 = (ClassLibrary1.Class3 obj) =>

*using (ShimsContext.Create())*{DateTime exp = new DateTime(2000, 10, 5);System.Fakes.ShimDateTime.NowGet = () =>{return exp;};var act = System.DateTime.Now;Assert.AreEqual(exp, act);}
ShimsContextのブロック内のみ偽装する。

*using (ShimsContext.Create())*{System.Fakes.ShimEnvironment.UserNameGet = () =>{return "user";};System.Fakes.ShimEnvironment.MachineNameGet = () =>{return "machine";};Assert.AreEqual("user", Environment.UserName);Assert.AreEqual("machine", Environment.MachineName);}
ShimsContextのブロック内のみ偽装する。

*using (ShimsContext.Create())*{ClassLibrary1.Fakes.ShimClass5.ShimClass5Inner.AllInstances.Test5Inner = (ClassLibrary1.Class5.Class5Inner obj) =>{return 99;};var o = new ClassLibrary1.Class5.Class5Inner();Assert.AreEqual(99, o.Test5Inner());}
ShimsContextのブロック内のみ偽装する。

*using (ShimsContext.Create())*{ClassLibrary1.Fakes.ShimClass6Base.AllInstances.Test6Base = (ClassLibrary1.Class6Base obj) =>{return 99;};var o = new ClassLibrary1.Class6();Assert.AreEqual(100, o.Test6BasePlus1());}
ShimsContextのブロック内のみ偽装する。

*using (ShimsContext.Create())*{bool callSwap = false;ClassLibrary1.Fakes.ShimClass7.SwapOf1M0RefM0Ref<int>((ref int x, ref int y) =>{//callSwap = true;Assert.AreEqual(1, x);Assert.AreEqual(9, y);return;});ClassLibrary1.Class7.Test7();Assert.AreEqual(true, callSwap);}
ShimsContextのブロック内のみ偽装する。

*using (ShimsContext.Create())*{bool callLog = false;ClassLibrary1.Fakes.ShimClass8<int,string>.AllInstances.Log = (ClassLibrary1.Class8<int,string> obj) =>{//callLog = true;};var o = new ClassLibrary1.Class8<int, string>();o.Log();Assert.AreEqual(true, callLog);}
ShimsContextのブロック内のみ偽装する。

*using (ShimsContext.Create())*{ClassLibrary1.Fakes.ShimClass1.AllInstances.CalInt32Int32 = (ClassLibrary1.Class1 obj, int x, int y) =>{// c1.Cal(1, 2); が実行されていることを確認するAssert.AreEqual(1, x);Assert.AreEqual(2, y);// 実行時のClass1.xxxxが123であることを確認するAssert.AreEqual(123, obj.xxxx);return 999999;};}
ShimsContextのブロック内のみ偽装する。

*Assert.AreEqual(1, x);
c1.Cal(1, 2); が実行されていることを確認する

*Assert.AreEqual(123, obj.xxxx);
実行時のClass1.xxxxが123であることを確認する

*using (ShimsContext.Create())*{int callCalCnt = 0;ClassLibrary1.Fakes.ShimClass1.AllInstances.CalInt32Int32 = (ClassLibrary1.Class1 obj, int x, int y) =>{// 実行した回数を数える++callCalCnt;return 999999;};var c2 = new ClassLibrary1.Class2();var act = c2.CallCal();Assert.AreEqual(1, callCalCnt, "c1.Calが1回実行されていることを確認");}
ShimsContextのブロック内のみ偽装する。

*++callCalCnt;
実行した回数を数える

*int ix = callIncCnt;
実行した回数を数える


*interStitialView.OnAdFailedToLoad += HandleInterstitialFailedToLoad;
広告が閉じたときのイベント登録
ちなみに古いAdmobのSDKだと.AdClosedとか微妙に違う


*int n1 = 0;
C#6までの書き方


*var property = typeof(Student).GetProperty("Name");
プロパティ情報の取得

*var beforeName = property.GetValue(student);*// インスタンスに値を設定
インスタンスの値を取得

*property.SetValue(student, "newName");*Console.WriteLine($"{student.ID}, {beforeName}, {student.Name}");
インスタンスに値を設定


*using System;
コンソールアプリケーションで実行を確認しました

*static void Main(string[] args)*{if (args.Length != 1){Program.Usage();Environment.Exit(0);}if (args[0].Equals("plain")){TextBuilder textbuilder = new TextBuilder();Director director = new Director(textbuilder);director.Construct();string result = textbuilder.Result;Console.WriteLine(result);}else if (args[0].Equals("html")){HTMLBuilder htmlbuilder = new HTMLBuilder();Director director = new Director(htmlbuilder);director.Construct();string filename = htmlbuilder.Filename;Console.WriteLine(filename + "が作成されました。");}else{Program.Usage();Environment.Exit(0);}// 実行が一瞬で終わって確認できないので、キーの入力を待ちますConsole.ReadLine();}
・Builderを利用する

*Console.ReadLine();
実行が一瞬で終わって確認できないので、キーの入力を待ちます

*public abstract class Builder
・インスタンスを作成するためのインターフェース（API）を定める
・インスタンスの各部分を作るためのメソッドを用意する

*public class Director
・Builderのインターフェース（API）を使ってインスタンスを生成する
・Builderのメソッドのみを使用する

*public class TextBuilder : Builder
・Builderのインターフェース（API）を実装する
・実際のインスタンス作成で呼び出されるメソッドを定義する

*public class HTMLBuilder : Builder
・Builderのインターフェース（API）を実装する
・実際のインスタンス作成で呼び出されるメソッドを定義する


*mmf = MemoryMappedFile.CreateOrOpen("TestMap", (uint)Marshal.SizeOf(typeof(Test1)));
頻繁に開け閉めしなくてもよいので起動時に作成

*testclass.A = int.Parse(this.A.Text);
UIからデータを取り込む(右辺は全部WPFのテキストボックスです)

*int size = Marshal.SizeOf(typeof(Test1));
構造体の体裁を整えたデータクラスをファイルマッピングのストリームに流すためにバイト列に変換する

*mmvs.Write(bytes, 0, size);
ファイルマッピングに書く

*int size = Marshal.SizeOf(typeof(Test1));
構造体の体裁を整えたデータクラスをファイルマッピングのストリームに流すためにバイト列に変換する

*mmvs.Write(bytes, 0, size);
ファイルマッピングに書く


*{
プレイヤーをゲーム画面から出さないための範囲指定


*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"


*foreach(Nabeatsu Nabe in NabeList.ToArray())
これで自信がない処を削除


*interface Command<T>*{T Execute();}
戻り値を返すコマンド

*interface Command<T>*{T Execute();}
戻り値を返すコマンド

*interface Command*{void Execute();}
戻り値を返さないコマンド


*Int32 x3 = f(x1, x2);
例外が発生！

*var result1 = Sum<int>(n1);*var n2 = new int[] { 1, 2, 3, 4, 5 };
1回目にILコードが生成されキャッシュされる。ILコードの生成の分、遅いはず。

*var result2 = Sum<int>(n2);*var n3 = new Int64[] { 1, 2, 3, 4 };
キャッシュされたFuncが使用される。直接ハードコーディングした場合とほぼ同じ速度が出るはず。

*var result3 = Sum<int>(n3);
Int64なのでInt64用のILコードが生成されキャッシュされる。


*switch (item.GetType().Name)
switchの条件分岐の値は定数しか使えない

*}
HTMLの構築処理とか

*}
HTMLの構築処理とか

*}
HTMLの構築処理とか


*public static List<User> GetUserList(){return new List<User> GetUserLists(){new User(){ id=1, userName="佐藤",age=20 },new User(){ id=2, userName="山田",age=30 },new User(){ id=3, userName="田中",age=28 },}}
ユーザーリストを返すメソッド


*resolver.Configure(container => container.Register(storage));
RequestScopeStorageでのオブジェクト管理機能をStandardResolverに追加

*storage.Clear();
Request Scopeで管理されるオブジェクトの破棄

*app.UseSmartResolverRequestScope(resolver);
UseMvcの前に記述

*app.UseMvc(routes =>{routes.MapRoute(name: "default",template: "{controller=Home}/{action=Index}/{id?}");
Enable request scope


*byte[] buffer = new byte[65536];
64KB chunks

*while (ms.Length < 65536 * 10)*Thread.Sleep(1000);
Pre-buffering some data to allow NAudio to start playing


*new List<List<string>>()*{new List<string>() {"1a", "2a", "3a"},new List<string>() {"1b", "2b", "3b"},new List<string>() {"1c", "2c", "3c"}}
変換後

*new List<List<string>>()*{new List<string>() {"1a", "1b", "1c"},new List<string>() {"2a", "2b", "2c", "2d"},new List<string>() {"3a", "3b", "3c"}}
変換前

*new List<List<string>>()*{new List<string>() {"1a", "2a", "3a"},new List<string>() {"1b", "2b", "3b"},new List<string>() {"1c", "2c", "3c"},new List<string>() {"2d"}}
変換後


*var enumNames = new Dictionary<string, string[]>();
enumの中身を入れとく


*services.AddSingleton<IControllerActivator>(new SmartResolverControllerActivator(resolver));
標準のASP.NET設定はここ


*var human = new Person();
Personクラスのpublicメンバーを構造体形式でコンソール出力する

*var memberInfos = classes.GetMembers(BindingFlags.Public | BindingFlags.Instance);
publicのプロパティとフィールドを検索

*// ※1より後に出力があるのは、掘り進めた深い階層の構造体を先に定義したいがため*Console.WriteLine("typedef struct\r\n{");foreach (var item in memberNames){string replaceValue;if (!convertDeclaration.TryGetValue(item.Key, out replaceValue)){replaceValue = item.Key;}if (string.Compare(item.Key, "string", true) == 0){Console.WriteLine("    {0} {1}[256];", replaceValue, item.Value);}else{Console.WriteLine("    {0} {1};", replaceValue, item.Value);}}Console.Write("} ");
コンソール出力をファイル出力(.h)で出すとしぁゎせ。ファイル出力する場合はstreamを引数にするとか工夫しよう。

*Console.WriteLine("typedef struct\r\n{");foreach (var item in memberNames){string replaceValue;if (!convertDeclaration.TryGetValue(item.Key, out replaceValue)){replaceValue = item.Key;}if (string.Compare(item.Key, "string", true) == 0){Console.WriteLine("    {0} {1}[256];", replaceValue, item.Value);}else{Console.WriteLine("    {0} {1};", replaceValue, item.Value);}}Console.Write("} ");
※1より後に出力があるのは、掘り進めた深い階層の構造体を先に定義したいがため


*string pattern = string.Empty;
五十順


*.Concat(Task.Delay(TimeSpan.FromMilliseconds(1000)).ToObservable()
なんとなく待つ


*var length = name.Length;
Warning でない


*int[] numbers = { 0b0000_0001, 0b0000_0010, 0b0000_0011, 0b0000_0100 };
int[] numbers = { 1, 2, 3, 4 };と同じ


*print (json.Get<double> (new object[]{"fuga"}));
拡張版の書き方

*print (json["hoge"]["bool"].Get<bool> ());
従来のJsonNodeの書き方でもOK


*using System;
コンソールアプリケーションで実行を確認しました

*Console.ReadLine();
実行が一瞬で終わって確認できないので、キーの入力を待ちます

*public class MessageBox : Product*{private char decochar;public MessageBox(char decochar){this.decochar = decochar;}public void Use(string s){Encoding sjisEnc = Encoding.GetEncoding("Shift_JIS");int length  = sjisEnc.GetByteCount(s);for (int i = 0; i < length + 4; i++){Console.Write(decochar);}Console.WriteLine("");Console.WriteLine($"{decochar} {s} {decochar}");for (int i = 0; i < length + 4; i++){Console.Write(decochar);}Console.WriteLine("");}public object Clone(){return this.MemberwiseClone();}public Product CreateClone(){return (Product)this.Clone();}}
ConcretePrototype

*public class UnderlinePen : Product*{private char ulchar;public UnderlinePen(char ulchar){this.ulchar = ulchar;}public void Use(string s){Encoding sjisEnc = Encoding.GetEncoding("Shift_JIS");int length = sjisEnc.GetByteCount(s);Console.WriteLine($"\"{s}\"");Console.Write(" ");for (int i = 0; i < length; i++){Console.Write(ulchar);}Console.WriteLine("");}public object Clone(){return this.MemberwiseClone();}public Product CreateClone(){return (Product)this.Clone();}}
ConcretePrototype

*public interface Product : ICloneable*{void Use(string s);Product CreateClone();}
Prototype

*public class Manager*{private Dictionary<string, Product> showcase = new Dictionary<string, Product>();public void Register(string name, Product proto){showcase.Add(name, proto);}public Product Create(string protoname){Product p = showcase[protoname];return p.CreateClone();}}
Client


*DesiredAccuracy = 30};
解像度を1.3mに設定


*static List<Slider> SliderList = new List<Slider>();
globalな変数（う～ん）

*SliderList = new List<Slider>();
Sliderを洗い出す
************************

*Location Goal = new Location(strX.Length, strY.Length);
総当たりを仕掛ける
************************


*currentSymbols = PlayerSettings.GetScriptingDefineSymbolsForGroup(BuildTargetGroup.Standalone).Split(';');
インスペクタ上では;区切り


*public event EventHandler [eventName];
event本体：[eventName]には、event名が入ります

*public event System.Windows.Forms.UICuesEventHandler ChangeUICues;
event本体：[eventName]には、event名が入ります

*public event System.Windows.Forms.ControlEventHandler [eventName];
event本体：[eventName]には、event名が入ります

*public event System.Windows.Forms.DragEventHandler [eventName];
event本体：[eventName]には、event名が入ります

*public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;
event本体

*public event System.Windows.Forms.HelpEventHandler HelpRequested;
event本体

*[System.ComponentModel.Browsable(false)]
event本体

*public event System.Windows.Forms.KeyEventHandler [eventName];
event本体：[eventName]には、event名が入ります

*public event System.Windows.Forms.KeyPressEventHandler KeyPress;
event本体

*public event System.Windows.Forms.LayoutEventHandler Layout;
event本体

*public event System.Windows.Forms.MouseEventHandler [eventName];
event本体：[eventName]には、event名が入ります

*public event System.Windows.Forms.PaintEventHandler Paint;
event本体

*public event System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown;
event本体

*public event System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp;
event本体

*public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;
event本体

*public event System.ComponentModel.CancelEventHandler Validating;
event本体


*hd.TryGetValue("buz", out buz)
false

*,,,
Relation<string, string>はないのでコンパイルエラー
string hoge;
hd.TryGetValue("hoge", out hoge);


*Singleton obj2 = Singleton.GetInstance();
=> インスタンスを生成しました。

*}
=> obj1とobj2は同じインスタンスです。

*Console.ReadLine();
実行が一瞬で終わって確認できないので、キーの入力を待ちます


*Product card2 = factory.Create("toshi0607");
=> nyanchuのカードを作ります。

*card1.Use();
=> toshi0607のカードを作ります。

*card2.Use();
=> nyanchuのカードを使います。

*Console.ReadLine();
=> toshi0607のカードを使います。
実行が一瞬で終わって確認できないので、キーの入力を待ちます

*public abstract class Product*{public abstract void Use();}
Product

*public abstract class Factory*{public Product Create(string owner){Product p = CreateProduct(owner);RegisterProduct(p);return p;}protected abstract Product CreateProduct(string owner);protected abstract void RegisterProduct(Product product);}
Creator

*public class IDCard : Product*{public string Owner { get; private set; }internal IDCard(string owner){Console.WriteLine($"{owner}のカードを作ります。");this.Owner = owner;}public override void Use(){Console.WriteLine($"{Owner}のカードを使います。");}}
ConcreteProduct

*public class IDCardFactory : Factory*{private List<string> Owners { get; set; } = new List<string>();protected override Product CreateProduct(string owner){return new IDCard(owner);}protected override void RegisterProduct(Product product){Owners.Add(((IDCard)product).Owner);}}
ConcreteCreator


*var multiItems = Enumerable.Repeat(new Dummy(0,null),100 );
ダメな奴
同一参照のオブジェクトを返す。1つ変えると全部変わる

*var multiItems = Enumerable.Repeat(0,100).Select(v=>new Dummy(v,null));
最初は同じだけど別々のオブジェクト

*var multiItems = Enumerable.Range(0, 100).Select(v =>new Dummy(v, null));
Indexをつけたりして最初から別々にしたい場合はRangeにして↑同様に

*class Dummy*{public Dummy(int number,string name){this.Number = number;this.Name = name;}public int Number { get; set; }public string Name { get; set; }public override string ToString(){return $"{this.Number}:{this.Name}";}}
↑で使ったクラス


*var image= new WriteableBitmap(width, height, 96, 96, PixelFormats.Gray8, BitmapPalettes.Gray256);
1.適当に画像を作成

*byte* dp = (byte*)image.BackBuffer;
2.この辺で画像をいじる

*image.AddDirtyRect(new System.Windows.Int32Rect(0, 0, image.PixelWidth, image.PixelHeight));
3.ここで入れたサイズの領域が更新される。ここがないと真っ黒。


*using UniRx.Triggers;
これが必須

*this.FixedUpdateAsObservable()
フラグが有効な間、上向きに力を加える

*this.OnTriggerEnterAsObservable()
WarpZoneに侵入したらフラグを有効にする

*this.OnTriggerExitAsObservable()
WarpZoneから出たらフラグを無効にする

*Observable.FromCoroutine<int>(observer => GameTimerCoroutine(observer, 60))
60秒カウントするストリームをコルーチンから作る

*var button = GetComponent<Button>();
uGUIのデフォルトのUnityイベントの名前をしたObservableが用意されている

*inputField.onValueChanged.AsObservable().Subscribe();
なお、このような記述もある

*,,,
この2つの記法の違いは、Subscribe時に現在の値を初期値を発行するかどうかである
Subscribe時に初期値が必要である場合は前者を使うとよい
inputField.OnValueChangedAsObservable(); 初期値あり
inputField.onValueChanged.AsObservable();初期値なし

*.Subscribe(x => Debug.Log(x));
https:google.comをHTTP GETする
ObservableWWW.Get("https:google.com")

*charcterController
CharacterControllerのIsGroundedを監視
false → trueになったらログに出す

*Observable.EveryUpdate()
↑のコードは↓とほぼ同義

*,,,
ObserveEveryValueChangedは
EveryUpdate + Select + DistinctUntilChanged
の省略記法と思ってよい


*string format3 = "%x";
符号なし16進数として出力する

*Console.WriteLine(Format(format, 3.1415926535));*Console.WriteLine(Format(format2, 3.1415926535));
変換指定子を使って数値を変換したい！

*Console.ReadLine();
結果表示


*Console.ReadKey();
キー入力までウィンドウが閉じないようにする


*using System;
コンソールアプリケーションで実行を確認しました

*Console.ReadLine();
|こんにちは！|
|こんにちは！|
|こんにちは！|
|こんにちは！|
|こんにちは！|
+------------+
実行が一瞬で終わって確認できないので、キーの入力を待ちます

*public void Display()*{this.Open();for(int i = 0; i < 5; i++){this.Print();}this.Close();}
テンプレートメソッド

*public class CharDisplay : AbstractDisplay*{private char Ch { get; set; }public CharDisplay(char ch){this.Ch = ch;}public override void Open(){Console.Write("<<");}public override void Print(){Console.Write(Ch);}public override void Close(){Console.WriteLine(">>");}}
テンプレートメソッドの挙動はサブクラスでの実装に依る


*Favorites = 8,
Unique

*…
デフォルトタブの存在チェック、ない場合には追加

*,,,
trueでFavAdd,falseでFavRemove

*if (post.IsFav)*favTab.AddPostQueue(post);
Fav済み発言だったらFavoritesタブに追加


*Console.WriteLine((x + y)?.ToString() ?? "NULL");
114556が出力される。

*Console.WriteLine((x + z)?.ToString() ?? "NULL");
NULLが出力される。


*private Plane[] planes = new Plane[6];
Plane配列を使いまわして余計なヒープ確保をさせない

*var meth = typeof(GeometryUtility).GetMethod("Internal_ExtractPlanes",BindingFlags.Static | BindingFlags.NonPublic,null,new System.Type[] { typeof(Plane[]), typeof(Matrix4x4) },null);
MEMO: 自前でやってもいいのだがInternalはネイティブコードを呼び出すのでこっちの方が早い･･･と思うのだけれど

*this.CalculateFrustumPlanes(this.planes, Camera.main.projectionMatrix * Camera.main.worldToCameraMatrix);
カメラの視錘台を取得

*Bounds bound = new Bounds(this.transform.position, Vector3.one);*// 視錘台判定はそのまま使う
Boundsサイズは任意

*if (!GeometryUtility.TestPlanesAABB(this.planes, bound))*Debug.LogWarning("Out of Camera");
視錘台判定はそのまま使う


*inputMotor.GetSpeed = () => 0;
GetSpeedの動作を入れ替える


*Transform t = this.gameObject.GetComponent<Transform>();
=> 約 0.73 秒

*// Transform t = GetComponent<Transform>();              // => 約 0.53 秒*// Transform t = transform;                              // => 約 0.24 秒
Transform t = gameObject.GetComponent<Transform>();    => 約 0.73 秒

*// Transform t = transform;                              // => 約 0.24 秒*}
Transform t = GetComponent<Transform>();               => 約 0.53 秒

*}
Transform t = transform;                               => 約 0.24 秒


*public IEnumerable<string> Solve() {int[] nums = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };foreach (var s in GetRisingNumbers("", nums)) {if (IsEmirp(s))yield return s;}}
問題を解く 答えは文字列として列挙する

*private IEnumerable<string> GetRisingNumbers(string rn, IEnumerable<int> nums) {if (nums.Count() == 0)yield break;int i = 0;foreach (var n in nums) {i++;string s = rn + n.ToString();yield return s;foreach (var r in GetRisingNumbers(s, nums.Skip(i)))yield return r;}}
上昇数 を求める 再帰メソッドの中で、yield return を使っている。

*private bool IsEmirp(string s) {if (s.Length >= 2 &&PrimeNumber.IsPrime(long.Parse(s)) &&PrimeNumber.IsPrime(long.Parse(ReverseString(s))))return true;return false;}
エマープか？

*private string ReverseString(string s) {return new string(s.Reverse().ToArray());}
文字列を反転する


*chart1.Dock = DockStyle.Fill;
特に設定していないなら不要。


*Console.WriteLine(formattedString);
This is a test.


*Console.WriteLine(result.IsCompleted);
false


*var socket = IO.Socket("http:
192.168.1.3:3000");

*socket.On(Socket.EVENT_CONNECT, async () =>*{// UIとは別スレッドなので Dispatcher を利用するawait Dispatcher.RunAsync(CoreDispatcherPriority.Normal, () =>{ReceivedText.Text = "接続しました";});});
接続時のイベント

*await Dispatcher.RunAsync(CoreDispatcherPriority.Normal, () =>*{ReceivedText.Text = "接続しました";});
UIとは別スレッドなので Dispatcher を利用する

*socket.On("msg", async (data) =>*{// UIとは別スレッドなので Dispatcher を利用するawait Dispatcher.RunAsync(CoreDispatcherPriority.Normal, () =>{ReceivedText.Text = Convert.ToString(data);});});
"msg" 受信時

*await Dispatcher.RunAsync(CoreDispatcherPriority.Normal, () =>*{ReceivedText.Text = Convert.ToString(data);});
UIとは別スレッドなので Dispatcher を利用する


*return WinError.MAKE_HRESULT(WinError.SEVERITY_SUCCESS, 0, 1);
追加したメニュー項目の数を返す

*if (WinApi.HighWord(ici.lpVerb.ToInt32()) != 0)
ici.lpVerb の上位ワードが NULL でなければ
このメソッドは別のアプリケーションによって呼出されたものなので
そのまま返す

*if (WinApi.LowWord(ici.lpVerb.ToInt32()) == IDM_SHOW_FILENAME)
そうでなければ
シェルが呼出したもので
ici.lpVerb の下位ワードが、ユーザが選択したメニュー項目


*particleSystem.Stop();
ストップ


*public short ParentIndex;
親ボーンのインデックス なしの場合は-1

*public short TailIndex;
子ボーンのインデックス なしの場合は0

*public Vector3 HeadPosition;
ボーンの根本の位置

*public Vector3 Position;
ボーンの根本の位置

*public int ParentIndex;
親ボーンのインデックス なしの場合は-1

*public int TailIndex;
子ボーンのインデックス なしの場合は-1

*public int Rank;
ボーンの変形階層

*public BoneFlagEnum BoneFlag;
ボーンの変形フラグ

*public SkinBone Parent { get; set; }
親ボーン

*public List<SkinBone> Children { get; set; }
子ボーンのリスト

*public int Rank { get; private set; }
階層

*public Matrix Init { get; private set; }
初期姿勢行列

*public Matrix Offset { get; private set; }
オフセット行列

*public Quaternion Rotate { get; set; }
回転量

*public Vector3 Translate { get; set; }
移動量

*public Quaternion MotionRotate { get; set; }
モーション用の回転・移動量

*private void UpdateBone() {foreach(var b in Bones) {b.Bone = CalcTranspose(b.Rotate, b.Translate) * b.Init;if(b.Parent != null) b.Bone *= b.Parent.Bone;}}
ボーン行列の更新

*public Matrix CalcTranspose(Quaternion Rotation, Vector3 Translation) {return Matrix.RotationQuaternion(Rotation) * Matrix.Translation(Translation);}
回転と移動から変換行列の作成

*public Matrix[] Results {get {return Bones.Select(x => x.Offset * x.Bone).ToArray();}}
変換行列配列

*if(nowList.Count == 0) continue;*int startFrm = motionList[i].StartFrame;
このボーンのモーションがない場合

*boneMng.SetPose(motMng.GetMotion());
現在のフレームのボーンの動きを取得し、セットする

*boneMng.Update();
変換行列を計算する。

*effect.SetBoneMatrix(boneMng.Results);
シェーダにセットする

*effect.DrawAll(camera);
描画


*.WithReferences(Assembly.GetEntryAssembly()),
CreviceApp.exe

*Unhook();
既にフックが実行されているとして


*int carry = 0;
繰り上がりの数

*if (carry == 0 && b == firstDigit && r[0] != '0')
例えば N=6,firstDigit=4の場合、最初のループでは、
int a = b * n + carry;        a <- 24 (= 6 * 4 + 0)
int m = a % 10;               m <- 4 (= 24 % 10)
carry = a / 10;               carry <- 2 (= 24 / 10)
b = m;                        現時点での最上位の桁の数は 4 である。


*var book = CreateNewBook( filePath );
ブック作成

*book.CreateSheet( "newSheet" );
シート無しのexcelファイルは保存は出来るが、開くとエラーが発生する

*using( var fs = new FileStream( filePath, FileMode.Create ) ) {book.Write( fs );
ブックを保存

*static IWorkbook CreateNewBook( string filePath )*{IWorkbook book;var extension = Path.GetExtension( filePath );// HSSF => Microsoft Excel(xls形式)(excel 97-2003)// XSSF => Office Open XML Workbook形式(xlsx形式)(excel 2007以降)if( extension == ".xls" ) {book = new HSSFWorkbook();}else if( extension == ".xlsx" ) {book = new XSSFWorkbook();}else {throw new ApplicationException( "CreateNewBook: invalid extension" );}return book;}
ブック作成

*// XSSF => Office Open XML Workbook形式(xlsx形式)(excel 2007以降)*if( extension == ".xls" ) {book = new HSSFWorkbook();}
HSSF => Microsoft Excel(xls形式)(excel 97-2003)

*var book = WorkbookFactory.Create( "sample.xlsx" );
ブック読み込み

*var sheet = book.GetSheet( "newSheet" );
シート名からシート取得

*WriteCell( sheet, 0, 0, "0-0" );
セルに設定

*var style = book.CreateCellStyle();
日付表示するために書式変更

*using( var fs = new FileStream( "sample2.xlsx", FileMode.Create ) ) {book.Write( fs );
ブックを保存

*public static void WriteCell( ISheet sheet, int columnIndex, int rowIndex, string value )*{var row = sheet.GetRow( rowIndex ) ?? sheet.CreateRow( rowIndex );var cell = row.GetCell( columnIndex ) ?? row.CreateCell( columnIndex );cell.SetCellValue( value );}
セル設定(文字列用)

*public static void WriteCell( ISheet sheet, int columnIndex, int rowIndex, double value )*{var row = sheet.GetRow( rowIndex ) ?? sheet.CreateRow( rowIndex );var cell = row.GetCell( columnIndex ) ?? row.CreateCell( columnIndex );cell.SetCellValue( value );}
セル設定(数値用)

*public static void WriteCell( ISheet sheet, int columnIndex, int rowIndex, DateTime value )*{var row = sheet.GetRow( rowIndex ) ?? sheet.CreateRow( rowIndex );var cell = row.GetCell( columnIndex ) ?? row.CreateCell( columnIndex );cell.SetCellValue( value );}
セル設定(日付用)

*public static void WriteStyle( ISheet sheet, int columnIndex, int rowIndex, ICellStyle style )*{var row = sheet.GetRow( rowIndex ) ?? sheet.CreateRow( rowIndex );var cell = row.GetCell( columnIndex ) ?? row.CreateCell( columnIndex );cell.CellStyle = style;}
書式変更


*WebRule webRule1 = Rule.WebInfo(webConfig).And.Config(myConfig).Build();
複雑な生成方法のつもり

*WebRule webRule1 = WebRule.Rule.WebInfo(webConfig).Config(myConfig);
複雑な生成方法のつもり


*Console.WriteLine( $"OS : {( Environment.Is64BitOperatingSystem ? "64bit" : "32bit" )}" );
OSが何ビットで動作しているか確認

*Console.WriteLine( $"プロセス : {( Environment.Is64BitProcess ? "64bit" : "32bit" )}" );
プロセスが何ビットで動作しているか確認

*[DllImport( "Library32.dll", EntryPoint = "Test" )]static extern void Test_32();
32bit版のC/C++関数の宣言

*[DllImport( "Library64.dll", EntryPoint = "Test" )]static extern void Test_64();
64bit版のC/C++関数の宣言

*static void Test()*{if ( Environment.Is64BitProcess )Test_64();elseTest_32();}
現在のプロセスにより32bit/64bit版の関数を呼び分けるラッパーメソッド

*static void Main()*{Test();}
クライアント


*using System;
コンソールアプリケーションで実行を確認しました

*class Program*{static void Main(string[] args){Print p = new PrintBanner("Hello");p.PrintWeak();// => (Hello)p.PrintStrong();// => *Hello*// 実行が一瞬で終わって確認できないので、キーの入力を待ちますConsole.ReadLine();}}
Client

*Console.ReadLine();
実行が一瞬で終わって確認できないので、キーの入力を待ちます

*public class Banner
このクラスは既に提供されているものとします
Adaptee

*public interface Print*{void PrintWeak();void PrintStrong();}
Target

*public class PrintBanner : Banner, Print*{public PrintBanner(string str) : base(str) { }public void PrintWeak(){this.ShowWithPattern();}public void PrintStrong(){this.ShowWithAster();}}
Adapter

*using System;
コンソールアプリケーションで実行を確認しました

*static void Main(string[] args)*{Print p = new PrintBanner("Hello");p.PrintWeak();// => (Hello)p.PrintStrong();// => *Hello*// 実行が一瞬で終わって確認できないので、キーの入力を待ちますConsole.ReadLine();}
Client

*Console.ReadLine();
実行が一瞬で終わって確認できないので、キーの入力を待ちます

*public class Banner
このクラスは既に提供されているものとします
Adaptee

*public abstract class Print*{public abstract void PrintWeak();public abstract void PrintStrong();}
Target

*public class PrintBanner : Print*{private Banner banner;public PrintBanner(string str){this.banner = new Banner(str);}public override void PrintWeak(){this.banner.ShowWithPattern();}public override void PrintStrong(){this.banner.ShowWithAster();}}
Adapter


*right_side.subIndices.Count - 1
カット面。最後のサブメッシュとしてトライアングルを追加


*public int ID { get; set; }
データベース上のキー

*public string Name { get; set; }
投稿者名

*public string Comment { get; set; }
投稿内容

*[DataType(DataType.Date)]*public DateTime ReleaseDate { get; set; }
投稿日時


*readonly string s;
外部から変更不可

*readonly List<string> str;
外部から変更可能

*readonly List<T> str = new List<T>();
Tが参照型の時、コレクション自体は変更できないが、
要素のインスタンス（Tクラス）内部を変更可能


*int sum =i[0]+i[1]+i[2];
3要素の合計


*Motor.CreateMotor = MotorStub.CreateMotorBody;
インスタンス生成メソッドを入れ替える

*instance.SampleMethod();
Act (実行)

*}
Assert (検証)
何か処理が行われたことを確認する
今回は省略


*((MotorStub)inputMotor).SpeedValue = 1;
Speedプロパティが返す値を設定

*instance.SampleMethod(inputMotor);
Act (実行)

*}
Assert (検証)
何か処理が行われたことを確認する
今回は省略


*originalMethod = LcdConsoleWrapper.WriteLine;
もともとのメソッドを退避させる

*privateType.SetStaticField(
スタブメソッドに入れ替える
PrivateType privateType = new PrivateType(typeof(LcdConsoleWrapper));    privateなメンバにアクセスするためのオブジェクト

*instance.SampleMethod();
Act (実行)

*}
Assert (検証)
何か処理が行われたことを確認する
今回は省略


*static void Main(string[] args)*{FileCopyRetry(sorcePass: "sorce/abc.txt", destPass: "dest/abc.txt", retryCounts: 5, waitMilliSeconds: 500);}
メソッド利用部分

*public static void FileCopyRetry(string sorcePass, string destPass, int retryCounts, int waitMilliSeconds)*{Exception exStack = new Exception();foreach (var i in Enumerable.Range(1, retryCounts + 1)){try{File.Copy(sorcePass, destPass);return;}catch (Exception ex){exStack = ex;}if (i <= retryCounts) Thread.Sleep(waitMilliSeconds);}throw exStack;}
ファイルコピーを行なうメソッド

*private void Form1_Load(object sender, EventArgs e)*{SomeClass.someStaticMethod(() => button1_Click(sender, e));}
メソッド呼び出し部

*}
何らかの処理

*someNonStaticMethod();
何らかの処理


*var numArray = Enumerable.Repeat( 0, 3 ).ToArray();*// 中身が{ 0, 0, 0 } のList<int>
中身が{ 0, 0, 0 } のint[3]

*var numList = Enumerable.Repeat( 0, 3 ).ToList();
中身が{ 0, 0, 0 } のList<int>

*var persons = Enumerable.Repeat(new Person( "クローン人間", 20, "無職" ), 5 ).ToList();
少子化対策

*var jobList = new[] { "整備士", "会計士", "弁護士", "運転士", "建築士" };
仕事を与える

*persons.ForEach( p => Console.WriteLine( p ) );
自己紹介をお願いします

*public struct Person*{// 以下省略,,,var persons = Enumerable.Range( 0, 5 ).Select( _ => new Person( "クローン人間", 20, "無職" ) ).ToArray();,,,using System;using System.Collections.Generic;using System.Linq;namespace Post._20161009{public static class MyEnumerable{/// <summary>/// activatorを工夫して、参照型の/// 複数の異なる実体への参照をゲットしよう/// </summary>/// <typeparam name="T"></typeparam>/// <param name="activator"></param>/// <param name="count"></param>/// <returns></returns>public static IEnumerable<T> Repeat<T>( Func<int, T> activator, int count ){for ( int i = 0; i < count; i++ )yield return activator( i );}}class Program{private static void Main(){// 少子化対策// MyEnumerable.Repeat()の使用箇所var persons = MyEnumerable.Repeat( i => new Person( "クローン人間", 20, "無職" ), 5 ).ToList();// 仕事を与えるvar jobList = new[] { "整備士", "会計士", "弁護士", "運転士", "建築士" };persons = persons.Select( ( p, index ) =>{ p.Job = jobList[index]; return p; } ).ToList();// 自己紹介をお願いしますpersons.ForEach( p => Console.WriteLine( p ) );}}},,,*,,,
以下省略

*var persons = MyEnumerable.Repeat( i => new Person( "クローン人間", 20, "無職" ), 5 ).ToList();
少子化対策
MyEnumerable.Repeat()の使用箇所

*var jobList = new[] { "整備士", "会計士", "弁護士", "運転士", "建築士" };persons = persons.Select( ( p, index ) =>{ p.Job = jobList[index]; return p; } ).ToList();// 自己紹介をお願いしますpersons.ForEach( p => Console.WriteLine( p ) );}
仕事を与える

*persons.ForEach( p => Console.WriteLine( p ) );
自己紹介をお願いします


*user.Password = new PasswordHasher<SMSUser>().HashPassword(user, Input.Password);
追加部分

*var callbackUrl = Url.Page("/Account/ConfirmEmail",pageHandler: null,values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },protocol: Request.Scheme);
code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));

*//    pageHandler: null,*//    values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },
"/Account/ConfirmEmail",

*values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },protocol: Request.Scheme);
pageHandler: null,

*await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",$"Please confirm your account by <a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>clicking here</a>.");
protocol: Request.Scheme);

*//    $"Please confirm your account by <a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>clicking here</a>.");
await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",

*//{//    return RedirectToPage("RegisterConfirmation", new { email = Input.Email, returnUrl = returnUrl });//}
if (_userManager.Options.SignIn.RequireConfirmedAccount)

*//    return RedirectToPage("RegisterConfirmation", new { email = Input.Email, returnUrl = returnUrl });
{

*//else*//{await _signInManager.SignInAsync(user, isPersistent: false);return LocalRedirect(returnUrl);//}
}

*//{await _signInManager.SignInAsync(user, isPersistent: false);return LocalRedirect(returnUrl);//}
else

*//[EmailAddress]*//public string Email { get; set; }
[Required]

*//public string Email { get; set; }
[EmailAddress]

*services.AddDefaultIdentity<IdentityUser>()
ここから追加

*services.AddControllersWithViews();
ここまで追加

*[Display(Name = "Email")]public string Email { get; set; }
[EmailAddress]

*//public string Email { get; set; }
[Display(Name = "Email")]

*[Required]*[StringLength(100, ErrorMessage = "{0} は {2} ～ {1} 文字で入力してください。", MinimumLength = 6)]
public string Email { get; set; }

*var callbackUrl = Url.Page("/Account/ConfirmEmail",pageHandler: null,values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },protocol: Request.Scheme);
code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));

*//    pageHandler: null,*//    values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },
"/Account/ConfirmEmail",

*values: new { area = "Identity", userId = user.Id, code = code, returnUrl = returnUrl },protocol: Request.Scheme);
pageHandler: null,

*await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",$"Please confirm your account by <a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>clicking here</a>.");
protocol: Request.Scheme);

*//    $"Please confirm your account by <a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>clicking here</a>.");
await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",

*//[EmailAddress]*//public string Email { get; set; }
[Required]

*//public string Email { get; set; }
[EmailAddress]


*StateClient stateClient = activity.GetStateClient();
Stateの初期化

*BotData userData = await stateClient.BotState.GetUserDataAsync(activity.ChannelId, activity.From.Id);
UserDataの値取り出し

*userData.SetProperty<boot>("Greeting", true);
UserDataの値セット

*await LUIS(activity);
既定文にヒットしなかったらLUISを呼ぶ


*double sigma_C = 0;
i=0 のときは計算されない。つまりZ[0]=B[0]

*List<double> A_press = (num * 2 - 1).Loop(i => gain.Select_ToList(a => Math.Pow(a, i)).Sum());
あらかじめ用意しておく

*List<List<double>> A = num.Loop(i => num.Loop(j => A_press[i + j]));
A行列の場合、i+jがそのまま次数となるためそれを利用

*下記で、Ax=B⇒LUx=B⇒Ly=Bからyを求めるc行列の計算List<double> Z = ListUtil.CreateNewList<double>(num); 指定数の配列を作成する独自の拡張メソッド
上記で、行列AをL行列、U行列に分解

*for (int i = 0; i < num; i++)
下記で、Ax=B⇒LUx=B⇒Ly=Bからyを求める
c行列の計算
List<double> Z = ListUtil.CreateNewList<double>(num); 指定数の配列を作成する独自の拡張メソッド

*List<double> res = ListUtil.CreateNewList<double>(num);
最後にy(既知)=Uxを計算しxをはじき出す
出力行列の計算


*public static IEnumerable<int> Take(int n) {yield return 0;int ans = 0;for (int i = 1; i < n; i++) {ans += i;yield return ans;}}
三角数を列挙する

*public static bool IsCorrect(long x) {long a = 8 * x + 1;long b = (long)(Math.Sqrt(a));if (b * b != a)return false;return (b - 1) % 2 == 0;}
三角数かを調べる

*public static long GetAt(int nth) {return (long)nth * (nth + 1) / 2;}
ｎ番目の三角数を求める


*string _apiUrlBase = "https:
api.projectoxford.aivisionv1.0generateThumbnail";

*content.Headers.ContentType = new MediaTypeWithQualityHeaderValue("application/octet-stream");*var uri = $"{_apiUrlBase}?width={width}&height={height}&smartCropping={smartCropping.ToString()}&Subscription-Key={_subscriptionKey.ToString()}";
get response


*public Point GetMapChipPoint(int nth)*{return new Point(nth * MapChipSize, 0);}
指定したマップチップのMapImage上での開始位置を返します。

*public Bitmap GetMapChip(int nth)*{var mcpoint = GetMapChipPoint(nth);Rectangle rect = new Rectangle(mcpoint.X, mcpoint.Y, MapChipSize, MapChipSize);Bitmap bmpNew = MapImage.Clone(rect, MapImage.PixelFormat);return bmpNew;}
指定したマップチップの画像を返します

*public Bitmap GetMap(int nth)*{var mapdata = this.Maps[nth];var xLen = mapdata.MapChips.GetLength(1);var yLen = mapdata.MapChips.GetLength(0);var bmp = new Bitmap(xLen * this.MapChipSize, yLen * this.MapChipSize);Graphics g = Graphics.FromImage(bmp);for(int y = 0; y < yLen; y++){for (int x = 0; x < xLen; x++){var mapchip = this.GetMapChip(mapdata.MapChips[y, x]);g.DrawImage(mapchip, new PointF(x * this.MapChipSize, y * this.MapChipSize));mapchip.Dispose();}}g.Dispose();return bmp;}
指定したマップの画像を返します。

*var integerMapChips = new int[,] {{ 0,0,0,0,0,0,0,0,0 },{ 0,0,0,0,0,0,0,0,0 },{ 0,0,2,0,0,0,0,0,0 },{ 0,0,0,0,1,0,0,0,0 },{ 0,1,0,0,0,0,0,0,0 },{ 0,0,0,0,0,0,0,0,0 },{ 0,0,0,0,0,0,0,0,0 }};
今回表示するマップのマップチップ配列。0:草原,1:山,2:家


*var points = new[] { 20, 30, 40, 40, 50 };
コレクションを用意

*// ----------------- foreach版--------------------*// 結果を受け取る配列を用意
全て２倍した集合がほしい！

*var result1 = new int[points.Length];
----------------- foreach版--------------------
結果を受け取る配列を用意

*var i = 0;
ポインタを作成

*result1[i] = p * 2;
配列に2倍した値を入力

*i++;
ポインタを更新

*Console.WriteLine(string.Join(",", result1));
画面に表示

*var result2 = points.Select(x => x * 2).ToArray();
----------------- Linq版--------------------
2倍した集合を取得

*Console.WriteLine(string.Join(",", result2));
画面に表示

*var points = new[] { 20, 30, 40, 40, 50 };
コレクションを用意

*// ----------------- foreach版--------------------*// 結果を受け取るリストを用意
４０以上の値だけ抜き出したい！

*var result1 = new List<int>();
----------------- foreach版--------------------
結果を受け取るリストを用意

*result1.Add(p);
リストに値を追加

*Console.WriteLine(string.Join(",", result1));
画面に表示

*var result2 = points.Where(x => x >= 40).ToList();
----------------- Linq版--------------------
40以上の値だけ抜き出したい！

*Console.WriteLine(string.Join(",", result2));
画面に表示

*var points = new[] { 20, 30, 40, 40, 50 };
コレクションを用意

*// ----------------- foreach版--------------------*// 結果を受け取るリストを用意
重複を排除したい！

*var result1 = new List<int>();
----------------- foreach版--------------------
結果を受け取るリストを用意

*result1.Add(p);
リストに値を追加

*Console.WriteLine(string.Join(",", result1));
画面に表示

*var result2 = points
----------------- Linq版--------------------
重複を排除したい！

*Console.WriteLine(string.Join(",", result2));
画面に表示

*var points1 = new[] { 20, 30, 40, 40, 50 };
コレクションを用意

*var points2 = new[] { 60, 70, 70, 80 };
コレクションを用意

*// ----------------- foreach版--------------------*// 結果を受け取るリストを用意
くっつける！

*var result1 = new List<int>();
----------------- foreach版--------------------
結果を受け取るリストを用意

*result1.Add(p);
points1の値を入れる

*result1.Add(p);
points2の値を入れる

*Console.WriteLine(string.Join(",", result1));
画面に表示

*var result2 = points1.Concat(points2).ToList();
----------------- Linq版--------------------
くっつける！

*Console.WriteLine(string.Join(",", result2));
画面に表示

*var points = new[] { 20, 30, 40, 40, 50 };
コレクションを用意

*// ----------------- foreach版--------------------*// 結果を受け取るリストを用意
3つ飛ばして4つ目から見たい！

*var result1 = new List<int>();
----------------- foreach版--------------------
結果を受け取るリストを用意

*result1.Add(points[i]);
pointsの値を入れる

*Console.WriteLine(string.Join(",", result1));
画面に表示

*var result2 = points.Skip(3).ToList();
----------------- Linq版--------------------
3つ飛ばして4つ目から見たい！

*Console.WriteLine(string.Join(",", result2));
画面に表示

*var points = new[] { 20, 30, 40, 40, 50 };
コレクションを用意

*// ----------------- foreach版--------------------*// 結果を受け取るリストを用意
2つ目から4つ目まで見たい!

*var result1 = new List<int>();
----------------- foreach版--------------------
結果を受け取るリストを用意

*result1.Add(points[i]);
pointsの値を入れる

*Console.WriteLine(string.Join(",", result1));
画面に表示

*var result2 = points.Skip(1).Take(3).ToList();
----------------- Linq版--------------------
2つ目から4つ目まで見たい!

*Console.WriteLine(string.Join(",", result2));
画面に表示

*Console.ReadLine();
----------------- 表示--------------------

*var productList = new Dictionary<string, int> {{ "りんご", 200 },{ "バナナ", 150 },{ "すいか", 150 },{ "ぶどう", 400 },};
コレクションを用意

*// ----------------- foreach版--------------------*// 結果を受け取るDictionaryを作成
全てのValueを+50したDictionaryがほしい！

*var result1 = new Dictionary<string, int>();
----------------- foreach版--------------------
結果を受け取るDictionaryを作成

*var result2 = productList
----------------- Linq版--------------------
全ての要素を+50したDictionaryを取得

*Console.WriteLine(string.Join("\n", elements.Select(x => {return x.Key + "\t" + x.Value;})));
Key、Valueのペアを表示


*var randGen = new CryptoApiRandomGenerator();
鍵のジェネレータ

*var keyGen = new RsaKeyPairGenerator();
鍵生成

*var name = new X509Name(ord, attr);
証明書の生成

*using (var writer = new StreamWriter(@"D:\Downloads\privatekey.pem", false, Encoding.ASCII)){var pemWriter = new PemWriter(writer);
秘密鍵の出力

*using (var writer = new StreamWriter(@"D:\Downloads\publickey.pem", false, Encoding.ASCII)){var pemWriter = new PemWriter(writer);
公開鍵の出力

*using (var reader = new StreamReader(@"D:\Downloads\privatekey.pem", Encoding.ASCII)){var pemReader = new PemReader(reader);
秘密鍵の読み込み

*using (var reader = new StreamReader(@"D:\Downloads\publickey.pem", Encoding.ASCII)){var pemReader = new PemReader(reader);
公開鍵の読み込み

*var certEntry = new X509CertificateEntry(cert);*var keyEntry = new AsymmetricKeyEntry(privateKey.Private);
PKCS12の生成

*using (var stream = new FileStream(@"D:\Downloads\pkcs12.p12", FileMode.Create)){p12.Save(stream, "password".ToCharArray(), rand);
PKCS12の出力

*using (var stream = new FileStream(@"D:\Downloads\pkcs12.p12", FileMode.Open)){readedP12 = new Pkcs12Store(stream, "password".ToCharArray());
PKCS12の読み込み

*using (var writer = new StreamWriter(@"D:\Downloads\pkcs12privatekey.pem", false, Encoding.ASCII)){var pemWriter = new PemWriter(writer);
秘密鍵の取得と書き込み


*static void Main(string[] args)*{BookShelf bookShelf = new BookShelf();bookShelf.appendBook(new Book("Around the world in 80 days"));bookShelf.appendBook(new Book("Bible"));bookShelf.appendBook(new Book("Cinderella"));bookShelf.appendBook(new Book("Daddy-Long-Legs"));IIterator it = bookShelf.Iterator();while(it.HasNext()){Book book = (Book)it.Next();Console.WriteLine(book.Name);}// 実行結果// Around the world in 80 days// Bible// Cinderella// Daddy-Long-Legs// 実行が一瞬で終わって確認できないので、キーの入力を待ちますConsole.ReadLine();}
コンソールアプリケーションで実行を確認しました

*Console.ReadLine();
実行結果
Around the world in 80 days
Bible
Cinderella
Daddy-Long-Legs
実行が一瞬で終わって確認できないので、キーの入力を待ちます

*public interface IAggregate*{IIterator Iterator();}
集合体を表すインターフェース

*public interface IIterator*{bool HasNext();object Next();}
数え上げ、スキャンを表すインターフェース

*public class Book*{public string Name { get; set; }public Book(string name){this.Name = name;}}
本を表すクラス

*public class BookShelf : IAggregate*{List<Book> books = new List<Book>();int Last { get; set; } = 0;public Book GetBookAt(int index){return books[index];}public void appendBook(Book book){this.books.Add(book);Last++;}public int GetLength(){return this.Last;}public IIterator Iterator(){return new BookShelfIterator(this);}}
本棚を表すクラス

*public class BookShelfIterator : IIterator*{BookShelf BookShelf { get; set; }int Index { get; set; }public BookShelfIterator(BookShelf bookShelf){this.BookShelf = bookShelf;this.Index = 0;}public bool HasNext(){if(Index < BookShelf.GetLength()){return true;} else {return false;}}public object Next(){Book book = BookShelf.GetBookAt(Index);this.Index++;return book;}}
本棚をスキャンするクラス


*void Start () {}
Use this for initialization

*void Update () {float x = Input.GetAxisRaw ("Horizontal");float y = Input.GetAxisRaw ("Vertical");//移動する向きを求めるVector2 direction = new Vector2 (x, y);moveObject.Move (direction);if (Input.GetKey (KeyCode.Z)) {//プレイヤーと同じ位置/角度で発射StartCoroutine(spaceShip.Shot(transform));}}
Update is called once per frame

*Vector2 direction = new Vector2 (x, y);
移動する向きを求める

*StartCoroutine(spaceShip.Shot(transform));*}
プレイヤーと同じ位置/角度で発射

*private void OnTriggerEnter2D (Collider2D c)*{// レイヤー名を取得string layerName = LayerMask.LayerToName(c.gameObject.layer);// レイヤー名がBullet (Enemy)の時は弾を削除if( layerName == "Bullet(Enemy)"){// 弾の削除Destroy(c.gameObject);}// レイヤー名がBullet (Enemy)またはEnemyの場合は爆発if( layerName == "Bullet(Enemy)" || layerName == "Enemy"){// 爆発するspaceShip.Explosion();// プレイヤーを削除Destroy (gameObject);}}
ぶつかった瞬間に呼び出される

*string layerName = LayerMask.LayerToName(c.gameObject.layer);
レイヤー名を取得

*Destroy(c.gameObject);
弾の削除

*spaceShip.Explosion();
爆発する

*Destroy (gameObject);
プレイヤーを削除

*void Start () {}
Use this for initialization

*void Update () {Vector2 direction = new Vector2 (1, 1);moveObject.Move (direction);StartCoroutine(spaceShip.Shot(transform));}
Update is called once per frame

*string layerName = LayerMask.LayerToName(c.gameObject.layer);
レイヤー名を取得

*if( layerName != "Bullet(Player)") return;*// 弾の削除
レイヤー名がBullet (Player)以外の時は何も行わない

*Destroy(c.gameObject);
弾の削除

*spaceShip.Explosion();
爆発

*Destroy(gameObject);
エネミーの削除


*void Start () {idx = 0;Profiler.BeginSample("ClampPattern1");clamp1();Profiler.EndSample();idx = 0;Profiler.BeginSample("ClampPattern2");clamp2();Profiler.EndSample();idx = 0;Profiler.BeginSample("ClampPattern3");clamp3();Profiler.EndSample();UnityEditor.EditorApplication.isPlaying = false;}
Use this for initialization


*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame

*public float shotDelay;
弾の発射間隔

*public bool canShot;
弾を打てるか

*private bool isRunning = false;
次の弾の

*if (!canShot)*yield break;
弾を打てるか

*if (isRunning)*yield break;
弾の発射準備中か

*void Start () {}
Use this for initialization

*void Update () {float x = Input.GetAxisRaw ("Horizontal");float y = Input.GetAxisRaw ("Vertical");//移動する向きを求めるVector2 direction = new Vector2 (x, y);moveObject.Move (direction);if (Input.GetKey (KeyCode.Z)) {//プレイヤーと同じ位置/角度で発射StartCoroutine(spaceShip.Shot(transform));}}
Update is called once per frame

*Vector2 direction = new Vector2 (x, y);
移動する向きを求める

*StartCoroutine(spaceShip.Shot(transform));*}
プレイヤーと同じ位置/角度で発射

*void Start () {}
Use this for initialization

*void Update () {Vector2 direction = new Vector2 (1, 1);moveObject.Move (direction);StartCoroutine(spaceShip.Shot(transform));}
Update is called once per frame

*void Start () {Vector2 direction = new Vector2 (1, 1);moveObject.Move (direction);}
Use this for initialization

*void Update () {}
Update is called once per frame


*}
処理


*//using Rwin = SlimDX.RawInput;*protected virtual void MouseInput(object sender, Rwin.MouseInputEventArgs e) { }
using SlimDX.Multimedia;

*protected virtual void MouseInput(object sender, Rwin.MouseInputEventArgs e) { }
using Rwin = SlimDX.RawInput;

*break;
処理

*}*protected override void MouseInput(object sender, Rwin.MouseInputEventArgs e) {switch(e.ButtonFlags) {case Rwin.MouseButtonFlags.MiddleDown:isMiddleMoving = true;break;case Rwin.MouseButtonFlags.MiddleUp:isMiddleMoving = false;break;}if(isMiddleMoving) {movingNow.posX += e.X;movingNow.posY += e.Y;}if(e.WheelDelta > 0) {movingNow.posZ++;} else if(e.WheelDelta < 0) {movingNow.posZ--;}}
省略

*public int rotX;
省略

*public void ResetRotXY() { rotX = rotY = 0; }
省略

*case Rwin.MouseButtonFlags.RightDown:
省略

*}
省略


*using (IWebDriver webDriver = WebDriverFactory.CreateInstance(AppSettings.BrowserName.Chrome)){https:www.google.co.jp に遷移させるwebDriver.Url = @"https:www.google.co.jp";
AppSettings.BrowserName.Firefoxを変更することによって対象のブラウザを変更できます

*IWebElement element = webDriver.FindElement(By.CssSelector("#lst-ib"));
https:www.google.co.jp に遷移させる
webDriver.Url = @"https:www.google.co.jp";
#lst-ibの要素を取得する

*element.SendKeys("Selenium2");
上記取得した要素に対してテキストを入力してサブミット

*Thread.Sleep(TimeSpan.FromSeconds(3));
一瞬で完了するため3秒スリープ

*webDriver.Quit();
ブラウザを閉じる


*OnDamage += (damage) => { Player.SetDamage(damage); };
ダメージ通知の関数を登録.

*OnDamage.Invoke(100);
実際にダメージを与える

*OnDamage.Clear();
~~~ (略) ~~~
登録した関数を全破棄.


*long N = 100;
約数を算出したい値

*List<long> ans = new List<long>();
算出した約数を格納するリスト

*for (long i = 1; i * i <= N; i++)
約数列挙
--------
iが割り切れたらiの2乗も割り切れるので、Forループの条件はi*iで加算していくように設定する
大きな値にも対応できるようlong型でループする

*ans.Add(i);
iの値が割り切れるなら約数なのでリストに追加

*ex:N=100のとき、i=2,N/i=50ex:N=100のとき、i=10,N/i=10↑昇順と降順で走査してるのでいずれ値がぶつかる。ぶつかった値を入れてしまうと同じ値が二重にリストに追加されてしまうのでそれを避ける。if (i != N / i){ans.Add(N / i);
iと(N/i)が同じ値でない時は(N/i)の値もリストに追加する(約数である)

*ex:N=100のとき、i=10,N/i=10↑昇順と降順で走査してるのでいずれ値がぶつかる。ぶつかった値を入れてしまうと同じ値が二重にリストに追加されてしまうのでそれを避ける。if (i != N / i){ans.Add(N / i);
ex:N=100のとき、i=2,N/i=50

*if (i != N / i)
ex:N=100のとき、i=10,N/i=10
↑昇順と降順で走査してるのでいずれ値がぶつかる。
ぶつかった値を入れてしまうと同じ値が二重にリストに追加されてしまうのでそれを避ける。

*ans.Sort();
リストを昇順にならべかえ


*}
描画処理


*br.ReadSingle();
バージョン(読み飛ばし)


*Vector3 pos = Camera.main.WorldToScreenPoint(transform.position);*// draw health bar background
Draw a health bar.


*dataGridView1[0, 0].Value = 0.ToString();
"0"をセット

*dataGridView1.Rows[0].Cells[0].Value = 0.ToString();
"0"をセット

*dataGridView1.Rows.Add();
空白行を追加

*dataGridView1.Rows.Add(new string[] { "1", "Good Product" });
セル内容を指定して行を追加


*using (RijndaelManaged rijndael = new RijndaelManaged()){Rijindaelのブロックサイズの設定初期値128ビットを256ビットに変更rijndael.BlockSize = 256;
Rijindaelのオブジェクトを作成

*rijndael.BlockSize = 256;
Rijindaelのブロックサイズの設定
初期値128ビットを256ビットに変更


*,,,
10000.Loopは1万回ループしていると思ってください


*public float speed;
移動スピード

*public float shotDelay;
弾を撃つ間隔

*public GameObject bullet;
弾のPrefab

*public bool canShot;
弾を撃つかどうか

*public void Move (Vector2 direction)*{GetComponent<Rigidbody2D>().velocity = direction * speed;}
機体の移動

*public float shotDelay;
弾の発射間隔

*public bool canShot;
弾を打てるか

*private bool isRunning = false;
次の弾を打つインターバルが終わっているか

*void Start () {}
Use this for initialization

*void Update () {float x = Input.GetAxisRaw ("Horizontal");float y = Input.GetAxisRaw ("Vertical");//移動する向きを求めるVector2 direction = new Vector2 (x_speed * x, y_speed * y);base.Move (direction);if (Input.GetKey (KeyCode.Z)) {//プレイヤーと同じ位置/角度で発射StartCoroutine(Shot(transform));}}
Update is called once per frame

*Vector2 direction = new Vector2 (x_speed * x, y_speed * y);
移動する向きを求める

*StartCoroutine(Shot(transform));*}
プレイヤーと同じ位置/角度で発射

*void Start () {}
Use this for initialization

*void Update () {Vector2 direction = new Vector2 (x_speed, -y_speed);base.Move (direction);StartCoroutine(Shot(transform));}
Update is called once per frame

*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame


*public float speed = 5;
移動スピード

*public GameObject bullet;
PlayerBulletプレハブ

*IEnumerator Start ()*{while (true) {// 弾をプレイヤーと同じ位置/角度で作成Instantiate (bullet, transform.position, transform.rotation);// 0.05秒待つyield return new WaitForSeconds (0.05f);}}
Startメソッドをコルーチンとして呼び出す

*Instantiate (bullet, transform.position, transform.rotation);*// 0.05秒待つ
弾をプレイヤーと同じ位置/角度で作成

*yield return new WaitForSeconds (0.05f);
0.05秒待つ

*float x = Input.GetAxisRaw ("Horizontal");
右・左

*float y = Input.GetAxisRaw ("Vertical");
上・下

*Vector2 direction = new Vector2 (x, y).normalized;
移動する向きを求める

*GetComponent<Rigidbody2D>().velocity = direction * speed;
移動する向きとスピードを代入する

*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame

*public GameObject bullet;
PlayerBulletプレハブ

*IEnumerator Start ()*{while (true) {// 弾をプレイヤーと同じ位置/角度で作成Instantiate (bullet, transform.position, transform.rotation);// 0.05秒待つyield return new WaitForSeconds (0.05f);}}
Startメソッドをコルーチンとして呼び出す

*Instantiate (bullet, transform.position, transform.rotation);*// 0.05秒待つ
弾をプレイヤーと同じ位置/角度で作成

*yield return new WaitForSeconds (0.05f);
0.05秒待つ

*float x = Input.GetAxisRaw ("Horizontal");
右・左

*float y = Input.GetAxisRaw ("Vertical");
上・下

*Vector2 direction = new Vector2 (x, y).normalized;
移動する向きを求める

*base.Move(direction);
移動する向きとスピードを代入する


*AsyncV();
本当は await AsyncV();としたかった


*.ToDictionary(o => o["AccountNumber"].ToString(), o => o);
AccountNumberをキー、DataRowViewを値とするDictionaryに変換


*using (var parse = new CsvReader(new StreamReader(filename))){parse.Configuration.HasHeaderRecord = false;
絶対ファイルパス

*namespace ML*{class SVM{MulticlassSupportVectorMachine msvm;double[][] inputs { get; set; }int[] outputs { get; set; }public SVM(double[][] inputs, int[] outputs){this.inputs = inputs;this.outputs = outputs;}public SVM() { }public void learn(){var kernel = new Accord.Statistics.Kernels.Linear();var classes = outputs.GroupBy(x => x).Count();msvm = new MulticlassSupportVectorMachine(0, kernel, classes);var teacher = new MulticlassSupportVectorLearning(msvm, inputs, outputs);teacher.Algorithm = (machine, inputs, outputs, class1, class2) =>{var smo = new SequentialMinimalOptimization(machine, inputs, outputs);smo.UseComplexityHeuristic = true;return smo;};teacher.Run();}public int predict(double[] data){var result = msvm.Compute(data);return result;}}}
http:accord-framework.net/docs/html/N_Accord_MachineLearning_VectorMachines.htm

*var preIndex = truelabel.Select((x, i) => new { Content = x, Index = i })
ラベルがitemのもののindexを正解ラベルからとってくる


*Debug.WriteLine(a);
買い物 掃除 洗濯


*dog4.Naku2();
わん わん


*private int _interval = 1 * 1000;
呼び出し間隔（ミリ秒）


*progressBar1.Invoke(new DelBar(SetBarValue), new object[] { i });
コントロールを生成したスレッドではないスレッドから操作することはできない
progressBar1.Value = i;
Invokeメソッドを使う

*Debug.WriteLine("done.");
5秒後に実行

*Task t1 = Task.Factory.StartNew(Worker);
.NET4.0～使用可

*Task t2 = new Task(Worker);
.NET4.0～使用可

*Task t3 = Task.Run(() => Worker());
.NET4.5～使用可

*Task.WaitAll(t1, t2, t3);
全てのタスクが終了するまで待機


*}
処理

*}
処理


*num[i] = string.Format("num_{0}", i);
84byte

*num[i] = $"num_{i.ToString()}";
64byte

*class C*{byte a;long b;byte c;long d;byte e;long f;byte g;long h;}
80byte

*class C*{long b;long d;long f;long h;byte a;byte c;byte e;byte g;}
56byte

*Debug.Log(animator.GetParameter(i).name);
animators.parameters[i].nameとほぼ同じ


*IEnumerable<XElement> q = from n in xdoc.Descendants(ex + "observation")
検査結果エレメント

*IEnumerable<XElement> s = from n in ee.Descendants(ex + "code")
検査内容(コード、検査項目名)

*IEnumerable<XElement> t = from n in ee.Descendants(ex + "value")
検査結果()


*var storageAccount = new CloudStorageAccount(new StorageCredentials(_storageAccountName,_storageAccessKey),false);
Azure Storageにデータを入れる


*var sum = evens.Sum();
二つ目のループ・・・のようには別れません


*public class HotKeyForm : Form*{[DllImport("user32.dll")]extern static int RegisterHotKey(IntPtr HWnd, int ID, int MOD_KEY, Keys KEY);[DllImport("user32.dll")]extern static int UnregisterHotKey(IntPtr HWnd, int ID);const int WM_HOTKEY = 0x0312;public readonly int modKey;public readonly Keys key;public readonly int id;public readonly ThreadStart proc;//ホットキー登録public HotKeyForm(int modKey, Keys key, ThreadStart proc){for (int i = 0x0000; i <= 0xbfff; i++){if (RegisterHotKey(this.Handle, i, modKey, key) != 0){this.modKey = modKey;this.key = key;this.id = i;this.proc = proc;break;}}}//ウィンドウメッセージ監視protected override void WndProc(ref Message m){base.WndProc(ref m);//ホットキーが押された時の処理if (m.Msg == WM_HOTKEY){if ((int)m.WParam == this.id){this.proc();}}}//ホットキー解除protected override void Dispose(bool disposing){UnregisterHotKey(this.Handle, this.id);base.Dispose(disposing);}}
クラス（ホットキー登録・解除用フォーム）

*public HotKeyForm(int modKey, Keys key, ThreadStart proc)*{for (int i = 0x0000; i <= 0xbfff; i++){if (RegisterHotKey(this.Handle, i, modKey, key) != 0){this.modKey = modKey;this.key = key;this.id = i;this.proc = proc;break;}}}
ホットキー登録

*protected override void WndProc(ref Message m)*{base.WndProc(ref m);//ホットキーが押された時の処理if (m.Msg == WM_HOTKEY){if ((int)m.WParam == this.id){this.proc();}}}
ウィンドウメッセージ監視

*protected override void Dispose(bool disposing)*{UnregisterHotKey(this.Handle, this.id);base.Dispose(disposing);}
ホットキー解除

*public class HotKeyController : Form*{public List<HotKeyForm> HotKeyFormList;//ホットキー登録・解除用フォームを表示すると、ウィンドウメッセージの監視が開始されるprivate void HotKeyController_Load(object sender,EventArgs e){foreach (HotKeyForm hotKeyForm in this.HotKeyFormList){hotKeyForm.WindowState = System.Windows.Forms.FormWindowState.Minimized;hotKeyForm.Show();hotKeyForm.Hide();}}private void HotKeyController_FormClosing(object sender,EventArgs e){foreach (HotKeyForm hotKeyForm in this.HotKeyFormList){if (!hotKeyForm.IsDisposed){hotKeyForm.Close();}}}public HotKeyController(){this.HotKeyFormList = new List<HotKeyForm>();this.WindowState = System.Windows.Forms.FormWindowState.Minimized;this.ShowInTaskbar = false;this.Load += HotKeyController_Load;this.FormClosing += HotKeyController_FormClosing;}}
クラス（ホットキー制御用フォーム）

*private void HotKeyController_Load(object sender,EventArgs e)*{foreach (HotKeyForm hotKeyForm in this.HotKeyFormList){hotKeyForm.WindowState = System.Windows.Forms.FormWindowState.Minimized;hotKeyForm.Show();hotKeyForm.Hide();}}
ホットキー登録・解除用フォームを表示すると、ウィンドウメッセージの監視が開始される


*app.Run(context => {StringBuilder sb = new StringBuilder();
アプリケーションの設定方法の詳細については、http:go.microsoft.com/fwlink/?LinkID=316888 を参照してください


*AtlasTex = new Texture2D(2048, 2048);
AtlasTextureの生成.

*yield return new WaitForSeconds(3f);
Unity起動直後は正確に計測できないのでしばらく待つ.

*Stopwatch sw = new Stopwatch();
~~~~~計測開始~~~~~

*// Rects に各Textureの領域情報が返ってくる、順番は引数のTexture配列と同じ.*Rects = AtlasTex.PackTextures(new [] {BodyTex, HairTex, EyeTex}, 2);
TextureのAtlas化を行う.

*Rects = AtlasTex.PackTextures(new [] {BodyTex, HairTex, EyeTex}, 2);
Rects に各Textureの領域情報が返ってくる、順番は引数のTexture配列と同じ.

*AtlasMaterial.mainTexture = AtlasTex;
Atlas用のMaterialにAtlasTextureを割り当てる

*ApplyUVAndMaterial(BodyMeshs, Rects[0], AtlasMaterial);
PackTextureに渡した順番でUVを更新

*sw.Stop();
~~~~~計測終了~~~~~

*public void ApplyUVAndMaterial(SkinnedMeshRenderer[] meshs, Rect rect, Material atlasMaterial)*{foreach (var mesh in meshs){var uvs = new List<Vector2>();// 元のMesh情報を上書きしないように、Instanctiateしてメッシュをコピーmesh.sharedMesh = Instantiate(mesh.sharedMesh);// 元々のUV情報を取得mesh.sharedMesh.GetUVs(0, uvs);// Atlasマテリアルを割り当てmesh.material = atlasMaterial;for (int i = 0; i < uvs.Count; ++i){// Atlas化してずれたUVを更新する.uvs[i] = new Vector2(uvs[i].x * rect.width + rect.x, uvs[i].y * rect.height + rect.y);// 新しいUVを割り当てmesh.sharedMesh.SetUVs(0, uvs);}}}
UVを更新して、AtlasMaterialを割り当てる

*mesh.sharedMesh = Instantiate(mesh.sharedMesh);
元のMesh情報を上書きしないように、Instanctiateしてメッシュをコピー

*mesh.sharedMesh.GetUVs(0, uvs);
元々のUV情報を取得

*mesh.material = atlasMaterial;
Atlasマテリアルを割り当て

*uvs[i] = new Vector2(uvs[i].x * rect.width + rect.x, uvs[i].y * rect.height + rect.y);
Atlas化してずれたUVを更新する.

*mesh.sharedMesh.SetUVs(0, uvs);
新しいUVを割り当て


*Print(  chara);
Normal

*static void Print(  Status s){Console.WriteLine(  "{0}  {1}", Convert.ToString(   (int)s, 2).PadLeft(4,'0'), s);}
状態を確認するメソッド


*driver.Navigate().GoToUrl("http:
webya.in");


*return Gcd(b, a);
引数を入替えて自分を呼び出す

*private static bool IsPrime(long number) {long boundary = (long)Math.Floor(Math.Sqrt(number));if (number == 1)return false;if (number == 2)return true;for (long i = 2; i <= boundary; ++i) {if (number % i == 0)return false;}return true;}
効率は良くないが、これでも十分な速度がでたので、良しとする。


*Assert.That(() => { someMethod2(1, 2); }, Throws.ArgumentNullException.With.Message.EqualTo("値を Null にすることはできません。"));
Messageは専用のプロパティが用意されている

*Assert.That(5, Is.GreaterThan(-10).And.LessThan(10));
積結合

*Assert.That(5, Is.EqualTo(3).Or.EqualTo(5));
和結合

*Assert.That(5, Is.Not.EqualTo(0));
否定


*string pass = amap.GetOption("-p", string.Empty);*Console.WriteLine("pass: {0}", pass);
userName: username


*.FirstOrDefault()
最初の一回だけでそのあとは捨てる（というか破棄される）


*dragEventArgs.Effect =DragItems.All(di => string.Compare(Path.GetExtension(di), ".txt", StringComparison.InvariantCultureIgnoreCase) == 0)
ドラッグしたファイルの拡張子が ".txt" ならコピー可能、そうでなければコピー不可のアイコンにする

*CountLines();
ドロップしたときの処理

*MessageBox.Show(builder.ToString());
メッセージボックスで表示する


*return true;
常に表示する

*var menu = new ContextMenuStrip();
メニューを生成して項目を追加する

*return menu;
メニューを返す

*MessageBox.Show(builder.ToString());
メッセージボックスで表示する


*if (dict.TryGetValue("none", out var value))
YES! var


*[assembly: CollectionBehavior(MaxParallelThreads = n)]このアセンブリ内のテストを並列で処理するデフォルト : false[assembly: CollectionBehavior(DisableTestParallelization = true)],,,*[assembly: CollectionBehavior(DisableTestParallelization = true)]
このアセンブリ内のテストを並列で処理する
デフォルト : false


*}
テスト前の処理

*}
テスト後の処理

*}
Context の初期化処理

*}
Context の終了処理

*this.fixture = fixture;
テスト用 Context のシングルトンがここの引数で渡される。

*}
テストをいつも通り書く


*var primeCandidte = p + i;
30m+2, 30m+3, 30m+4, 30m+5, 30m+6、30m+8、30m+9、30m+12... は割る必要はない。

*var primeCandidte = p + i;
30m+2, 30m+3, 30m+4, 30m+5, 30m+6、30m+8、30m+9、30m+12... は割る必要はない。


*break;
スリープ直前

*break;
復帰直後

*break;
バッテリーや電源に関する通知があった


*services.AddDbContext<AppDbContext>(option => options.
AppDbContextはDbContextを継承して作ったクラスで、
Code Firstの形式で定義したクラス

*services.AddDbContext<AppDbContext>(option => options.
AppDbContextはDbContextを継承して作ったクラスで、
Code Firstの形式で定義したクラス


*using System.Drawing;
for PointF


*Encoding.GetEncoding("Shift-JIS"));
文字コードを設定してCSVファイルの読み込み


*new PointF(600, 6),
X,Y


*var jstTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById("Tokyo Standard Time");
日本時間のタイムゾーン情報

*var etTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time");
米国東海岸時間のタイムゾーン情報

*var jstDateTimeOffsetSample1 = new DateTimeOffset(2016, 8, 29, 15, 30, 11, jstTimeZoneInfo.BaseUtcOffset);
DateTimeOffsetでの変換 - 1（日本時間から夏時間な東海岸時間に）
2016年8月29日 15時30分11秒 (UTC+9) = いわゆる日本時間の2016年8月29日 15時30分11秒

*var etDateTimeOffsetSample1 = TimeZoneInfo.ConvertTime(jstDateTimeOffsetSample1, etTimeZoneInfo);
東海岸時間に変換
jstDateTimeOffset1に入っている日時は、東海岸時間では夏時間にあたり13時間差なので
2016年8月29日 2時30分11秒 (UTC-4)が返る

夏時間だろうが冬時間だろうが、TimeZoneInfo.ConvertTime()がよきに計らってくれる

*//DateTimeOffsetはある一意の地点を指しているので、変換したとしてもイコールである*Console.WriteLine($"jstDateTimeOffsetSample1.Equals(etDateTimeOffsetSample1) = {jstDateTimeOffsetSample1.Equals(etDateTimeOffsetSample1)}");
=> 日本時間の8/29/2016 3:30:11 PM +09:00を東海岸時間に変換すると8/29/2016 2:30:11 AM -04:00です

*Console.WriteLine($"jstDateTimeOffsetSample1.Equals(etDateTimeOffsetSample1) = {jstDateTimeOffsetSample1.Equals(etDateTimeOffsetSample1)}");
DateTimeOffsetはある一意の地点を指しているので、変換したとしてもイコールである

*var jstDateTimeOffsetSample2 = new DateTimeOffset(2016, 1, 29, 15, 30, 11, jstTimeZoneInfo.BaseUtcOffset);
DateTimeOffsetでの変換 - 2（日本時間から冬時間な東海岸時間に）
2016年1月29日 15時30分11秒 (UTC+9) = いわゆる日本時間の2016年1月29日 15時30分11秒

*var etDateTimeOffset2 = TimeZoneInfo.ConvertTime(jstDateTimeOffsetSample2, etTimeZoneInfo);
東海岸時間に変換
jstDateTimeOffset2に入っている日時は、東海岸時間では冬時間で14時間差なので
2016年1月29日 1時30分11秒 (UTC-5)が返る

夏時間だろうが冬時間だろうが、TimeZoneInfo.ConvertTime()がよきに計らってくれる

*Console.WriteLine("");
=> 日本時間の1/29/2016 3:30:11 PM +09:00を東海岸時間に変換すると1/29/2016 1:30:11 AM -05:00です

*var jstDateTime1 = new DateTime(2016, 3, 13, 15, 59, 59, DateTimeKind.Unspecified);
DateTimeのよくある残念なパターン1 - 指定できない時刻

『2016年3月13日 15時59分59秒』と『2015年11月1日 16時00分00秒』を日本時間として扱い、それぞれ東海岸時間にしようとする。
すると、それぞれ『2016年3月13日 1時59分59秒』と『2016年3月13日 3時00分00秒』に変換される。
なぜなら、東海岸時間で冬時間から夏時間に変わるときには1時59分59秒の次は3時00分00秒がくるので、
前者は『冬時間の1時59分59秒』、後者は『夏時間の3時00分00秒』という変換のされ方になる。


*Console.WriteLine($"日本時間の{jstDateTime1Plus1Sec}は東海岸時間の{TimeZoneInfo.ConvertTime(jstDateTime1Plus1Sec, jstTimeZoneInfo, etTimeZoneInfo)}です");
=> 日本時間の3/13/2016 3:59:59 PMは東海岸時間の3/13/2016 1:59:59 AMです

*Console.WriteLine("↑↑↑おかしい↑↑↑");
=> 日本時間の3/13/2016 4:00:00 PMは東海岸時間の3/13/2016 3:00:00 AMです

*var jstDateTimeOffset1 = new DateTimeOffset(2016, 3, 13, 15, 59, 59, jstTimeZoneInfo.BaseUtcOffset);
DateTimeOffsetなら、時刻を正しく扱える

*Console.WriteLine($"日本時間の{jstDateTimeOffset1Plus1Sec}は東海岸時間の{TimeZoneInfo.ConvertTime(jstDateTimeOffset1Plus1Sec, etTimeZoneInfo)}です");
=> 日本時間の3/13/2016 3:59:59 PM +09:00は東海岸時間の3/13/2016 1:59:59 AM -05:00です

*Console.WriteLine("↑↑↑DateTimeOffsetなら、オフセット部分が-5時間から-4時間に変化しているので問題無い↑↑↑");
=> 日本時間の3/13/2016 4:00:00 PM +09:00は東海岸時間の3/13/2016 3:00:00 AM -04:00です

*var jstDateTime2 = new DateTime(2015, 11, 1, 14, 59, 59, DateTimeKind.Unspecified);
DateTimeのよくある残念なパターン2 - ダブる時刻

『2015年11月1日 14時59分59秒』と『2015年11月1日 15時00分00秒』を日本時間として扱い、それぞれ東海岸時間にしようとする。
すると、それぞれ『2015年11月1日 1時59分59秒』と『2015年11月1日 1時00分00秒』に変換される。
なぜなら、東海岸時間で夏時間から冬時間に変わるときには1時59分59秒の次にもう1回1時00分00秒がくるので、
前者は『夏時間の1時59分59秒』、後者は『冬時間の1時00分00秒』という変換のされ方になる。


*Console.WriteLine($"日本時間の{jstDateTime2Plus1Sec}は東海岸時間の{TimeZoneInfo.ConvertTime(jstDateTime2Plus1Sec, jstTimeZoneInfo, etTimeZoneInfo)}です");
=> 日本時間の11/1/2015 2:59:59 PMは東海岸時間の11/1/2015 1:59:59 AMです

*Console.WriteLine("↑↑↑おかしい↑↑↑");
=> 日本時間の11/1/2015 3:00:00 PMは東海岸時間の11/1/2015 1:00:00 AMです

*var jstDateTimeOffset2 = new DateTimeOffset(2015, 11, 1, 14, 59, 59, jstTimeZoneInfo.BaseUtcOffset);
DateTimeOffsetなら、時刻を正しく扱える

*Console.WriteLine($"日本時間の{jstDateTimeOffset2Plus1Sec}は東海岸時間の{TimeZoneInfo.ConvertTime(jstDateTimeOffset2Plus1Sec, etTimeZoneInfo)}です");
=> 日本時間の11/1/2015 2:59:59 PM +09:00は東海岸時間の11/1/2015 1:59:59 AM -04:00です

*Console.WriteLine("↑↑↑DateTimeOffsetなら、オフセット部分が-4時間から-5時間に変化しているので問題無い↑↑↑");
=> 日本時間の11/1/2015 3:00:00 PM +09:00は東海岸時間の11/1/2015 1:00:00 AM -05:00です

*try
DateTimeのよくある残念なパターン3 - 変換しようとして例外が発生する時刻（パターン1の裏返し）

『2016年3月13日 2時30分11秒』を東海岸時間として扱い、それを日本時間にしようとすると、ArgumentExceptionが発生する。
なぜなら、2016年3月13日は冬時間から夏時間に戻る日で、1時59分59秒の次は3時00分00秒なので、
東海岸時間には『2016年3月13日 2時30分11秒』は存在しないから。


*Console.WriteLine($"{TimeZoneInfo.ConvertTime(new DateTime(2015, 11, 1, 0, 59, 59), etTimeZoneInfo, jstTimeZoneInfo)}");
DateTimeのよくある残念なパターン4 - 指定できない時刻（パターン2の裏返し）

『2015年11月1日 0時59分59秒』と『2015年11月1日 1時00分00秒』を東海岸時間として扱い、それぞれ日本時間にしようとする。
すると、それぞれ『2015年11月1日 13時59分59秒』と『2015年11月1日 15時00分00秒』に変換される。
なぜなら、夏時間から冬時間に変わるときは1時59分59秒の次にもう1回1時0分0秒がくるので
UTCからのオフセット値がないと東海岸時間午前1時台は曖昧にしか表現できないため。



*public R[] Data, Grad;
Dataは変数データ、Gradは勾配データを格納する

*public List<int> Shape;
Shapeはデータの形を保存している

*public int UseCount = 0;
UseCountは計算グラフで使用された回数を保存することで、勾配の計算漏れを防ぐ

*public IFunction BackFunction;
Backward時に呼び出す。IFunctionはRein.Functionsのinterface

*public Tensor(int[] shape)*{System.Random random = new System.Random();this.Shape = shape.ToList();this.Size = shape.Aggregate((now, next) => now * next);// 乱数で初期化this.Data = Enumerable.Range(0, this.Size).Select(_ => (R)random.NextDouble()).ToArray();this.Grad = new R[this.Size];}
データの形で初期化

*this.Data = Enumerable.Range(0, this.Size).Select(_ => (R)random.NextDouble()).ToArray();
乱数で初期化

*public Tensor(R[] data)*{this.Shape = new List<int>(1){ data.Length };this.Size = data.Length;this.Data = data;this.Grad = new R[this.Size];}
データを直接入力して初期化

*public Tensor(R[] data, int[] shape)*{this.Shape = shape.ToList();this.Size = shape.Aggregate((now, next) => now * next);// データ自体のサイズとshapeから得られるサイズが異なる時にエラーを投げる。if(data.Length != this.Size) throw new InvalidSizeException();this.Data = data;this.Grad = new R[this.Size];}
データとshapeで初期化

*if(data.Length != this.Size) throw new InvalidSizeException();*this.Data = data;
データ自体のサイズとshapeから得られるサイズが異なる時にエラーを投げる。

*public Tensor(R[] data, List<int> shape){this.Shape = shape;this.Size = shape.Aggregate((now, next) => now * next);if(data.Length != this.Size) throw new InvalidSizeException();this.Data = data;this.Grad = new R[this.Size];}
Shapeがリスト型で与えられた時

*public void Backward()*{// BackFunctionが存在しない時は終了if(this.BackFunction == null)return;this.UseCount--;// 他の関数に対しても出力している場合にはまだ勾配を計算しないif(this.UseCount != 0)return;this.BackFunction.Backward();}
...

*if(this.BackFunction == null)return;*this.UseCount--;
BackFunctionが存在しない時は終了

*if(this.UseCount != 0)return;*this.BackFunction.Backward();
他の関数に対しても出力している場合にはまだ勾配を計算しない


*string url = "https:
api.projectoxford.aiemotionv1.0recognize";

*Dictionary<string, string> header = new Dictionary<string, string>();
リクエストヘッダー

*WWW www = new WWW(url, bytes, header);
リクエストする

*yield return www;
非同期なのでレスポンスを待つ

*var emotionJsonArray = JArray.Parse(www.text);
JSON の中身をパース

*JObject scores = (JObject) emotionJsonArray[0]["scores"];
今回は顔が一人分だけ写っていると仮定し0番目を取り出す

*string emotion = getEmotion(scores);
取れたスコアに基づき最も強かった感情をstringで返す

*Girl g = girl.GetComponent<Girl>();
キャラクターにその感情にあった表情をさせる


*checkBox.FontSiZe = 50;
これが反映されない

*public class ListData*{public string Name {get; set;}}
***データクラス***

*<DataGrid Name="MainDataGrid">
***UserControl内XAML***

*public static readonly DependencyProperty ListDataProperty = DependencyProperty.Register(
***UserControl内コードビハインド***
外部からDataGridにバインドするデータを受け取る用

*mainDataGrid.ItemsSource = this.ListData;
ロードイベントなりなんなり好きなところで


*Character character = (Character)Activator.CreateInstance(type);
インスタンス作ったり

*MethodInfo method = type.GetMethod("Move");
メソッド呼んだり

*// Object[] args = { "A", "B", "C" };
引数渡したい場合


*,,,*namespace System.Diagnostics {public static class Debug {[ConditionalAttribute("DEBUG")]public static void Assert(bool condition);}}
Error !!


*base.Start();
スーパークラス参照


*}
requestInfo.Bodyにバイナリデータが入っている


*}
Functionsで行う処理などを書く
適宜telemetryClient.TrackTrace()やtelemetryClient.TrackMetric()などを呼び出してもよい。


*writer.IndentChar = ' ';
indent character

*Console.OutputEncoding = new UTF8Encoding();
日本語化けないようにする

*XmlDocument xmlDocument = new XmlDocument();
サンプルXML構築 (整形を確認するために意図的に崩してある)

*Console.WriteLine("----------------------------------------");
インデント付き整形表示


*using System.Text.RegularExpressions;
for Regex


*var ber = BerConverter.Encode("{tststs}",LDAP_TAG_EXOP_MODIFY_PASSWD_ID, accountDN,LDAP_TAG_EXOP_MODIFY_PASSWD_OLD, oldPasswd,LDAP_TAG_EXOP_MODIFY_PASSWD_NEW, newPasswd);
https:tools.ietf.org/html/rfc3062

*ldapConnection.Bind();
パスワードを変更するユーザーでバインドする

*ldapConnection.SendRequest(modifyPasswdRequest);*// 応答が「成功」か確認
パスワード変更要求を送信

*if (modifyPasswdResponse.ResultCode != ResultCode.Success)*throw new Exception("Could not change password. (" + modifyPasswdResponse.ResultCode + ")");
応答が「成功」か確認


*WndProcHooker.HookWndProc(listView1, new WndProcHooker.WndProcCallback(WM_Hook_Handler), WM_HSCROLL);
次の２行を追加する


*string diffs = diffs.Patch;
追加行、削除行などの差分情報

*LibGit2Sharp.CloneOptions options = new LibGit2Sharp.CloneOptions();
オプション変数

*options.BranchName = branch;
オプション：チェックアウトするブランチ名。簡略名(FriendlyName)でもOK

*options.OnCheckoutProgress = (p,n,t)=>checkout_progress_handler(p,n,t);
オプション：進行状況のコールバック指定

*options.RepositoryOperationStarting = (c)=>operation_start_handler(c);
オプション：開始時のコールバックを指定

*LibGit2Sharp.Repository.Clone( remote_path, local_path, options );
入出力のパスとオプションを指定してクローンを実行します。
string remote_path：クローンするリモートリポジトリのパス
string local_path：クローンを作成するパス
CloneOptions options


*private void listView1_ItemCheck(object sender, ItemCheckEventArgs e) {Point pnt = listView1.PointToClient(Cursor.Position);ListViewItem item = listView1.Items[e.Index];ListViewItem.ListViewSubItem stem = item.GetSubItemAt(pnt.X, pnt.Y);if(stem != null && stem.Bounds.Contains(pnt))if(item.SubItems.IndexOf(stem) == 1)e.NewValue = e.CurrentValue;}
カラム2の直接編集ちっくモードに入るときに、ItemのCheckが入らないようにする


*Console.WriteLine(element);
Debug.Log() for Unity


*pageResult.Html.CssSelect("ul li").First().InnerText;
まずはスクレイピング対象のページを取得してくる。
var pageResult = browser.NavigateToPage(new Uri("http:example.com/page.html"));
ページに対してCSSセレクタを適用し、該当するDOMノードの最初のものを取り出す。
→ 「hoge 1」が返る

*pageResult.Html.CssSelect("ul li").First(elem => elem.InnerText.Contains("fuga")).InnerText;
ページに対してCSSセレクタを適用してDOMノード群を取り出し、ノード群の中からinnerTextに「fuga」が入っている最初のノードをLINQで絞り込む
→ 「fuga 2」が返る

*}
<td>タグ内に「location」という文字が入っているノードの隣のノードをXPathで絞り込む
→ 「Tokyo」が返る
pageResult.Html.SelectNodes("td[contains(text(),'location')]/following-sibling::td").First().InnerText;


*ball_rb.AddForce(sliderDirection * changePower);
ボールに力を加える


*float viewMin = 20.0f;
カメラ視覚の範囲

*private float backDist = 0.0f;
直前の2点間の距離.

*float view = 60.0f;
初期値

*void Update () {// マルチタッチかどうか確認if (Input.touchCount >= 2){// タッチしている２点を取得Touch t1 = Input.GetTouch (0);Touch t2 = Input.GetTouch (1);//2点タッチ開始時の距離を記憶if (t2.phase == TouchPhase.Began){backDist = Vector2.Distance (t1.position, t2.position);}else if (t1.phase == TouchPhase.Moved && t2.phase == TouchPhase.Moved){// タッチ位置の移動後、長さを再測し、前回の距離からの相対値を取る。float newDist = Vector2.Distance (t1.position, t2.position);view = view + (backDist - newDist) / 100.0f;v = v + (newDist - backDist) / 1000.0f;// 限界値をオーバーした際の処理if(v > vMax){v = vMax;}else if(v < vMin){v = vMin;}// 相対値が変更した場合、カメラに相対値を反映させるif(v != 0){map.transform.localScale = new Vector3(v, v, 1.0f);}}}}
Update is called once per frame

*Touch t1 = Input.GetTouch (0);
タッチしている２点を取得

*float newDist = Vector2.Distance (t1.position, t2.position);
タッチ位置の移動後、長さを再測し、前回の距離からの相対値を取る。


*Console.WriteLine($"Name={p.Name}, Age={p.Age}");
Name=Mike, Age=43


*}
出力結果
aaabbbccc

*}
出力結果
aaa

*}
出力結果
aaabbb

*}
出力結果
aaabbbccc


*}*private IEnumerator Sample(){int i = 0;Debug.Log("yield:"+ i + ":" + 1);yield return null;i++;Debug.Log("yield:"+ i + ":" + 2);yield return null;i++;Debug.Log("yield:"+ i + ":" + 3);yield return null;i++;Debug.Log("yield:"+ i + ":" + 4);yield return null;i++;Debug.Log("yield:"+ i + ":" + 5);yield return null;i++;}
アップデートの中で呼ぶと危険


*.Message("こんにちは! 野菜の○ブウェイです。ご注文を承ります！")
.Message("こんにちは! 野菜の○ブウェイです。ご注文をどうぞ!")
.Build();


*Digit(12345);
=> 5


*app.UseStaticFiles();
前略．．．
wwwrootに対して静的コンテンツサービスを登録

*app.UseFileServer(new FileServerOptions{登録するフォルダーを指定、絶対パスを設定する必要があるFileProvider = new PhysicalFileProvider("C:\\StaticContent"),
wwwroot以外に静的コンテンツサービスを登録

*FileProvider = new PhysicalFileProvider("C:\\StaticContent"),});
登録するフォルダーを指定、絶対パスを設定する必要がある

*}
後略．．．

*app.UseStaticFiles();
前略．．．
パラメータなしの場合は「wwwroot」フォルダー及びサブフォルダの全ファイルを静的コンテンツとして提供する
デフォルトでは認証と認可ミドルウェアの前に登録されているので、「wwwroot」の静的コンテンツをアクセスする際は認証と認可は不要

*app.UseAuthentication();
後略．．．

*}
後略．．．

*app.UseStaticFiles();
前略．．．
パラメータなしの場合は「wwwroot」フォルダー及びサブフォルダの全ファイルを静的コンテンツとして提供する

*app.UseStaticFiles(new StaticFileOptions
「wwwroot」以外に「StaticContent」フォルダーも静的ファイルを提供する
app.UseStaticFiles();の呼び出しがないと「wwwroot」へのアクセスができなくなる

*app.UseAuthentication();
後略．．．

*}
後略．．．

*app.UseDefaultFiles();
前略．．．

*app.UseStaticFiles(new StaticFileOptions
「wwwroot」以外に「StaticContent」フォルダーも静的ファイルを提供する
app.UseStaticFiles();の呼び出しがないと「wwwroot」へのアクセスができなくなる

*app.UseAuthentication();
後略．．．

*}
後略．．．

*DefaultFilesOptions defaultFilesOptions = new DefaultFilesOptions();
前略．．．
既定ドキュメントの設定

*defaultFilesOptions.DefaultFileNames.Clear();
デフォルトのファイル名設定をクリア

*defaultFilesOptions.DefaultFileNames.Add("myIndex.html");
既定ドキュメント名を指定

*app.UseStaticFiles(new StaticFileOptions
「wwwroot」以外に「StaticContent」フォルダーも静的ファイルを提供する
app.UseStaticFiles();の呼び出しがないと「wwwroot」へのアクセスができなくなる

*app.UseAuthentication();
後略．．．

*}
後略．．．

*EnableDirectoryBrowsing = trueの時、下記を呼び出す必要があるservices.AddDirectoryBrowser();
前略．．．

*services.AddDirectoryBrowser();
EnableDirectoryBrowsing = trueの時、下記を呼び出す必要がある

*}
後略．．．

*app.UseStaticFiles();
前略．．．

*app.UseStaticFiles(new StaticFileOptions
「wwwroot」以外に「StaticContent」フォルダーも静的ファイルを提供する
app.UseStaticFiles();の呼び出しがないと「wwwroot」へのアクセスができなくなる

*app.UseDirectoryBrowser(new DirectoryBrowserOptions{ディレクトリ参照の対象フォルダーFileProvider = new PhysicalFileProvider("C:\\StaticContent"),
ディレクトリ参照を起用する

*FileProvider = new PhysicalFileProvider("C:\\StaticContent"),ディレクトリ参照するためのURL相対パスhttps:<hostname>/DirectoryBrowser
ディレクトリ参照の対象フォルダー

*RequestPath = "/DirectoryBrowser"
ディレクトリ参照するためのURL相対パス
https:<hostname>/DirectoryBrowser

*app.UseAuthentication();
略．．．

*}
後略．．．

*EnableDirectoryBrowsing = trueの時、下記を呼び出す必要があるservices.AddDirectoryBrowser();
前略．．．

*services.AddDirectoryBrowser();
EnableDirectoryBrowsing = trueの時、下記を呼び出す必要がある

*}
後略．．．

*app.UseStaticFiles();
前略．．．

*app.UseFileServer(new FileServerOptions{静的ファイルを提供する対象フォルダーFileProvider = new PhysicalFileProvider("C:\\StaticContent"),
「wwwroot」以外に「StaticContent」フォルダーも静的ファイルを提供する

*FileProvider = new PhysicalFileProvider("C:\\StaticContent"),デフォルトがtrue:デフォルトファイルを起用EnableDefaultFiles = true,デフォルトがfalse:ディレクトリブラウザ禁止EnableDirectoryBrowsing = true静的コンテンツをアクセスするための相対パスRequestPath = "/StaticFiles",});
静的ファイルを提供する対象フォルダー

*EnableDefaultFiles = true,デフォルトがfalse:ディレクトリブラウザ禁止EnableDirectoryBrowsing = true静的コンテンツをアクセスするための相対パスRequestPath = "/StaticFiles",});
デフォルトがtrue:デフォルトファイルを起用

*EnableDirectoryBrowsing = true静的コンテンツをアクセスするための相対パスRequestPath = "/StaticFiles",});
デフォルトがfalse:ディレクトリブラウザ禁止

*RequestPath = "/StaticFiles",});
静的コンテンツをアクセスするための相対パス

*app.UseAuthentication();
略．．．

*}
後略．．．

*webBuilder.UseStartup<Startup>().UseWebRoot("C:\\NewWebRoot");
ここで既定の「wwwroot」を指定したフォルダーに変更できる


*page = GetPage("http:
www.jikokuhyo.co.jpsearchdetailline_iskanto_takasaki");

*class parser1 : parser*{private bool state;private string comment;public parser1(){state = true;}public bool status{get{return this.state;}set{this.state = value;}}public string m_comment{set{this.comment = value;}get{return this.comment;}}//find tagpublic override void find_tag(string tag){}//find atrributepublic override void find_attribute(string tag, Dictionary<string, string> attr_list){}//find datapublic override void find_data(string tag, Dictionary<string, string> attr_list, string data){if (tag == "div"){foreach (KeyValuePair<string, string> sPair in attr_list){if (sPair.Key == "class" && sPair.Value == "corner_block_row_detail_d"){if ( (data != "\r\n現在、平常通り運転しています。") && (data !="\r\n情報提供時間は4：00～翌2：00となっています。") ){//なにかするm_comment = data;status = false;}else{}}}}}}
～～～～～～～～～～

*public override void find_tag(string tag)*{}
find tag

*public override void find_attribute(string tag, Dictionary<string, string> attr_list)*{}
find atrribute

*public override void find_data(string tag, Dictionary<string, string> attr_list, string data)*{if (tag == "div"){foreach (KeyValuePair<string, string> sPair in attr_list){if (sPair.Key == "class" && sPair.Value == "corner_block_row_detail_d"){if ( (data != "\r\n現在、平常通り運転しています。") && (data !="\r\n情報提供時間は4：00～翌2：00となっています。") ){//なにかするm_comment = data;status = false;}else{}}}}}
find data

*m_comment = data;
なにかする


*float _startTime = Time.realtimeSinceStartup;*for (int i =0; i < 1000000; i++ ){test_string.text = "集計" + i;}
スタート時間

*float _endTime = Time.realtimeSinceStartup;
終了時間

*float _startTime = Time.realtimeSinceStartup;*for (int i =0; i < 1000000; i++ ){test_string.GetComponent<Text>().text = "集計" + i;}
スタート時間

*float _endTime = Time.realtimeSinceStartup;
終了時間

*float _startTime = Time.realtimeSinceStartup;*for (int i =0; i < 1000000; i++ ){GameObject test_string = Parent.transform.FindChild("Text").gameObject;test_string.GetComponent<Text>().text = "集計" + i;}
スタート時間

*float _endTime = Time.realtimeSinceStartup;
終了時間


*HttpWebRequest req = (HttpWebRequest)WebRequest.Create("http:
example.comapihoge");


*xmlns:mc="http:
schemas.openxmlformats.orgmarkup-compatibility2006"


*var fuga = hoge.Cast<double>();
InvalidCastExceptionが発生する

*var piyo = hoge.OfType<double>();
結果は空（すなわちキャスト出来ていない）

*var element = (double)((object)1);
要素に対する等価式（当然例外になる）


*AudioBuffer.Instance.Enqueue(_audioRecord);
最初に空読みさせないと、リスナーのイベントが発生しないらしい

*public virtual void SetRecordPositionUpdateListener(IOnRecordPositionUpdateListener listener, Handler handler);
または

*public event EventHandler<MarkerReachedEventArgs> MarkerReached;
１つめ

*public event EventHandler<PeriodicNotificationEventArgs> PeriodicNotification;*,,,
２つめ


*viewModel.Model2.Model1 = model1_2;
10, 20, 30...

*,,,
↑SelectMany(m1 => m1.ToReactivePropertyAsSynchronized(x => x.Number))と同じ結果


*string[] scenes = EditorBuildSettings.scenes.Where(it => it.enabled)
ビルド対象シーンのパスの配列

*string errorMessage = BuildPipeline.BuildPlayer(levels: scenes,locationPathName: outputPath,target: BuildTarget.Android,options: BuildOptions.None);
先のビルド対象シーンのパスの配列を引数にとるBuildPipeline.BuildPlayerメソッド

*EditorBuildSettingsScene[] scenes = EditorBuildSettings.scenes.Where(it => it.enabled)
ビルド対象シーンの配列

*string errorMessage = BuildPipeline.BuildPlayer(levels: scenes,locationPathName: outputPath,target: BuildTarget.Android,options: BuildOptions.None);
先のビルド対象シーンの配列を引数にとるBuildPipeline.BuildPlayerメソッド


*public string Affiliation;
作者所属

*}
中身は省略

*GetAuthors(t);
クラスの Author

*GetAuthors(info);
メソッドの Author


*public enum SandwichOptions*{RoastBeef, BLT, SubwayClub, RoastChicken,TeriyakiChicken, TurkeyBreast, Ham, Tuna, VeggieDelite}
質問項目と回答


*WriteReadCommand[22] = (byte)sum;
CheckSum（これまでの数値の和の下位１バイト）

*int offset_Write = 0;
WriteReadCommand 送信

*byte[] inBuffer = new byte[23];
WriteReadCommand 受信


*var obj = new DerivedClass();
子クラスをインスタンス化


*dbContext.SaveChanges();
エラーは出ないがDBに反映されない・・・


*await auth.GetUserCredential( "http:
localhost:8080GoogleFitsteps" );

*}
ここが認証後のリダイレクト先ルート


*[Key, DatabaseGenerated(DatabaseGeneratedOption.None)]
[Key] これだけだとエラーが出る


*result.Add("None");
常に「指定しない」の意味で `None` を追加

*string componentName = component.GetType().Name;
該当コンポーネントの名前を取得（階層構造のいわゆるディレクトリ的な扱いで使う）

*string[] methodNames = component.GetType().GetMethods(BindingFlags.Instance | BindingFlags.Public).Where(x => x.DeclaringType == component.GetType())
該当コンポーネントから「public」でかつ「引数 0」のメソッドを抜き出す

*return (string[])result.ToArray(typeof(string));
string[] に変換して返す

*public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)*{var rect = new Rect(position.x, position.y, position.width, EditorGUIUtility.singleLineHeight);// 折りたたまれているかの状態を得るm_Unfoled = EditorGUI.Foldout(rect, m_Unfoled, label);// 折りたたまれている場合はGUIの更新をせずに終了if (!m_Unfoled) {return;}var backupIndent = EditorGUI.indentLevel;EditorGUI.indentLevel = 0;label = EditorGUI.BeginProperty(position, label, property);// 表示に使うメソッドリストへの参照string[] methods;// レイアウトのスタート位置float y = position.y;{// `Target` プロパティを取得SerializedProperty targetProperty = property.FindPropertyRelative("Target");// 指定したプロパティから、実際に設定されている値を取り出しGameObject target = targetProperty.objectReferenceValue as GameObject;// 設定されているターゲットを対象に、コンポーネントの条件に合うメソッドリストを収集methods = CollectMethods(target);// Yの位置を更新y += EditorGUIUtility.singleLineHeight + 5f; ;// インデントレベルを修正EditorGUI.indentLevel++;// ターゲットのラベルをレンダリングvar targetRect = new Rect(position.x, y, position.width, EditorGUIUtility.singleLineHeight);EditorGUI.PropertyField(targetRect, targetProperty, new GUIContent("Target"));}{if (methods.Length > 0) {// `HandleMethod` プロパティから値を取得SerializedProperty handleMethodProperty = property.FindPropertyRelative("HandleMethod");y += EditorGUIUtility.singleLineHeight + 5f; ;// メソッドのラベルをレンダリングvar methodRect = new Rect(position.x, y, position.width, EditorGUIUtility.singleLineHeight);EditorGUI.LabelField(methodRect, new GUIContent("Method"));if (!methods.Contains(handleMethodProperty.stringValue)) {handleMethodProperty.stringValue = "";}string selected = handleMethodProperty.stringValue == "" ? "None" : handleMethodProperty.stringValue;int index = methods.Select((Name, Index) => new { Name, Index }).First(x => x.Name == selected).Index;var padding = 105f;methodRect.x += padding;methodRect.width -= padding;index = EditorGUI.Popup(methodRect, index, methods);handleMethodProperty.stringValue = methods[index];}}EditorGUI.EndProperty();EditorGUI.indentLevel = backupIndent;}
GUIのレンダリング

*m_Unfoled = EditorGUI.Foldout(rect, m_Unfoled, label);
折りたたまれているかの状態を得る

*string[] methods;
表示に使うメソッドリストへの参照

*float y = position.y;*{// `Target` プロパティを取得SerializedProperty targetProperty = property.FindPropertyRelative("Target");// 指定したプロパティから、実際に設定されている値を取り出しGameObject target = targetProperty.objectReferenceValue as GameObject;// 設定されているターゲットを対象に、コンポーネントの条件に合うメソッドリストを収集methods = CollectMethods(target);// Yの位置を更新y += EditorGUIUtility.singleLineHeight + 5f; ;// インデントレベルを修正EditorGUI.indentLevel++;// ターゲットのラベルをレンダリングvar targetRect = new Rect(position.x, y, position.width, EditorGUIUtility.singleLineHeight);EditorGUI.PropertyField(targetRect, targetProperty, new GUIContent("Target"));}
レイアウトのスタート位置

*SerializedProperty targetProperty = property.FindPropertyRelative("Target");
`Target` プロパティを取得

*GameObject target = targetProperty.objectReferenceValue as GameObject;
指定したプロパティから、実際に設定されている値を取り出し

*methods = CollectMethods(target);
設定されているターゲットを対象に、コンポーネントの条件に合うメソッドリストを収集

*y += EditorGUIUtility.singleLineHeight + 5f; ;
Yの位置を更新

*EditorGUI.indentLevel++;
インデントレベルを修正

*var targetRect = new Rect(position.x, y, position.width, EditorGUIUtility.singleLineHeight);
ターゲットのラベルをレンダリング

*SerializedProperty handleMethodProperty = property.FindPropertyRelative("HandleMethod");
`HandleMethod` プロパティから値を取得

*var methodRect = new Rect(position.x, y, position.width, EditorGUIUtility.singleLineHeight);
メソッドのラベルをレンダリング

*public override float GetPropertyHeight(SerializedProperty property, GUIContent label)*{// 折りたたまれている場合は1行分だけの高さif (!m_Unfoled) {return EditorGUIUtility.singleLineHeight;}// それ以外の場合は3行（プロパティの数）＋マージンvar height = EditorGUIUtility.singleLineHeight * 3 + 5f + 5f;return height;}
プロパティのインスペクタ上で占める範囲の高さ

*var height = EditorGUIUtility.singleLineHeight * 3 + 5f + 5f;
それ以外の場合は3行（プロパティの数）＋マージン

*bool m_Unfoled = false;
折りたたみ状態かどうかを保持するプロパティ

*m_Unfoled = EditorGUI.Foldout(rect, m_Unfoled, label);
中略
該当プロパティが閉じている状態かを取得

*public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
以下、閉じていた場合と開いている場合で処理を分岐
GetPropertyHeightメソッド内で、展開の状態に応じて高さの値を変えることで、
双方の状態を適切な高さで表現することができる


*param ["bllimit"] = "16";
取得するリンク数の上限

*yield return www;
WikipediaからJSONを取得
WWW www = this.GET("http:ja.wikipedia.org/w/api.php?", param);

*var wikipedia = JsonUtility.FromJson (www.text, typeof(Wikipedia.RootObject)) as Wikipedia.RootObject;
JSONデータ -> Wikipediaオブジェクト


*using System.Xml.XPath;
XDocumentでXPath用の拡張メソッドを使うのに必要

*var doc = XDocument.Load(new StringReader(xmlString));
XML文字列からXDocumentオブジェクトを生成

*var nsmgr = new XmlNamespaceManager(new NameTable());
名前空間のための処理
string nameSpace = "http:example.com";

*var nodeD = doc.XPathSelectElement("ns:nodeA/ns:nodeB/ns:nodeC/ns:nodeD", nsmgr);
名前空間を指定して検索

*var doc = XDocument.Load(new StringReader(xmlString));
XML文字列からXDocumentオブジェクトを生成

*foreach(var e in doc.Descendants())　e.Name = e.Name.LocalName;*//上記処理により、検索時に名前空間の指定が不要
各ノードのNameを名前空間なしの要素名にする

*var nodeD = doc.XPathSelectElement("nodeA/nodeB/nodeC/nodeD");
上記処理により、検索時に名前空間の指定が不要


*ClockSkew = TimeSpan.Zero
←これがポイント


*var range = sheet.Cells["A1:B10"];
A1:B10の矩形範囲にはすべて値が詰まっている｡

*Console.WriteLine(ReferenceEquals(foo, bar));
こいつはTrueになる｡

*//foo:B2*Console.WriteLine($"foo:{foo.Current.Address}");
だもんで､foo及びbarをMoveNextした結果が､それぞれにに反映される｡

*Console.WriteLine($"foo:{foo.Current.Address}");
foo:B2

*Console.WriteLine($"bar:{bar.Current.Address}");
bar:B2

*var rangeA = sheet.Cells["A1:B10"];
A1:B10の矩形範囲にはすべて値が詰まっている｡

*Console.WriteLine(ReferenceEquals(rangeA, rangeB));
Falseになる｡

*Console.WriteLine(ReferenceEquals(foo, bar));
当然こいつはFalseになる｡

*//foo:B1*Console.WriteLine($"foo:{foo.Current.Address}");
共々独立しているのでめでたしめでたし

*Console.WriteLine($"foo:{foo.Current.Address}");
foo:B1

*Console.WriteLine($"bar:{bar.Current.Address}");
bar:A1


*Console.WriteLine(range.Count());
セーブ後､ロードすると0になる｡

*Console.WriteLine(range.Count());
予想としてA1から､B10の矩形範囲なので20が返ると思いがちだけど
0が返ってくる｡

*Console.WriteLine(range.Count());
この段階では､2が戻ってくる｡

*Console.WriteLine(range.Count());
20が戻ってくる｡


*.SetSubtitle(new Subtitle { Text = "Source: <a href=\"http:
WorldClimate.com\">WorldClimate.com<a>", UseHTML = true })


*//    {//    if (activity.Type == ActivityTypes.Message)://    }
public async Task<HttpResponseMessage> Post([FromBody]Activity activity)

*//    if (activity.Type == ActivityTypes.Message)*:
{


*public static int Lcm(int a, int b) {return a * b / Gcd(a, b);}
最小公倍数

*public static int Gcd(int a, int b) {if (a < b)// 引数を入替えて自分を呼び出すreturn Gcd(b, a);while (b != 0) {var remainder = a % b;a = b;b = remainder;}return a;}
ユークリッドの互除法

*return Gcd(b, a);*while (b != 0) {var remainder = a % b;a = b;b = remainder;}
引数を入替えて自分を呼び出す


*Item m_nextState;
次実行のセット

*public void Command(Action<float,string,string> func,string p1=null, string p2=null)*{var i = new Item();i.state = func;i.p1 = p1;i.p2 = p2;m_queue.Enqueue(i);}
実行登録

*public void Update()*{m_elapsed += Time.deltaTime;if (m_curState == null){if (m_queue.Count != 0){m_nextState = m_queue.Dequeue();}}if (m_nextState != null){m_curState  = m_nextState;m_nextState = null;m_elapsed = 0;}if(m_curState != null){m_curState.state(m_elapsed, m_curState.p1, m_curState.p2);}}
更新処理　上位関数から更新時呼び出しを想定

*public void Done()*{m_curState = null;}
ステートの終了告知用

*m_ss.Command(S_START);
処理の登録

*void S_START(float t,string p1, string p2)*{if (t == 0){Debug.Log("S_START Initailize");}else if (t > 1){m_ss.Done();}}
以下、ステート関数


*wRange = String.Format("{0}!A{1}:B{1}", sheetName, rowNumber);
行を追加


*// ローカルで宣言した変数を使うとその名前と値がそのまま利用される*// int index = anyList.Select((Name, Index) => new { Name, Index });
さらに短くするとこう書ける

*// int index = anyList.Select((Name, Index) => new { Name, Index });
ローカルで宣言した変数を使うとその名前と値がそのまま利用される

*,,,*var person = new { Name = "edo", Age = 20 };
int index = anyList.Select((Name, Index) => new { Name, Index });


*public event DataEventHandler DataPassEvent;
このイベントをメインフォームでListenする。

*if(!string.IsNullOrWhiteSpace(StringDate))
ここでデータを加工したりする処理をして・・・
空白でない時だけ、イベントを起こしたりも出来る。

*}
データベースからデータを取得する処理。

*DatabaseUpdateCompleted?.Invoke(null, new EventArgs());
ここでデータベースにレコードをInsertしたりUpdateしたりして・・・
その後、イベント起動。

*DataClass.DataPassEvent += DataClass_DataPassEvent;
データ管理用クラスの、データ変更イベントをListenする。

*new SubForm().Method();
サブフォーム内に実装した、データを変更するメソッドを呼び出す。
下記メソッドはどのクラスから呼び出してもいいが、今回は2つしかクラスがないので、このクラスで呼び出す。

*MessageBox.Show($"変更前は { e.OldStringData } で 変更後は { e.NewStringData } ");
データ変更前後の値を表示する。
メッセージBOXは4回表示され、表示結果は以下
------------------------------------------
①変更前は で 変更後は あいうえお
②変更前は あいうえお で 変更後は かきくけこ
③変更前は かきくけこ で 変更後は さしすせそ
④変更前は さしすせそ で 変更後は たちつてと
------------------------------------------

*public void Method()*{DataClass.StringValue = "あいうえお";DataClass.StringValue = "かきくけこ";DataClass.StringValue = "さしすせそ";DataClass.StringValue = "たちつてと";}
データ管理用クラスのデータを変更する。

*public static class DataClass*{public delegate void DataEventHandler(DataChangeEventArgs e);//このイベントをメインフォームとサブフォームでListenする。public static event DataEventHandler DataPassEvent;private static string oldValue;private static string newValue;public static string StringValue{get { return newValue; }set{//データ変更前後の値が違っていれば・・・if (oldValue != value){//元々あった値をoldValueに退避oldValue = newValue;//newValueにセットし・・・newValue = value;//データ変更イベントを起動する。DataPassEvent?.Invoke(new DataChangeEventArgs(oldValue, newValue));};}}}
データ管理用クラス

*public static event DataEventHandler DataPassEvent;
このイベントをメインフォームとサブフォームでListenする。

*oldValue = newValue;
元々あった値をoldValueに退避

*newValue = value;
newValueにセットし・・・

*DataPassEvent?.Invoke(new DataChangeEventArgs(oldValue, newValue));
データ変更イベントを起動する。

*public class DataChangeEventArgs : EventArgs*{public string OldStringData { get; set; }public string NewStringData { get; set; }public DataChangeEventArgs(string oldData, string newData){OldStringData = oldData;NewStringData = newData;}}
変更前後の値を渡す為のEventArgs


*anyClassName = target as anyClassName;
AnyClassNameコンポーネントを取得

*var options = new []{ GUILayout.Width(64), GUILayout.Height(64) };
レイアウト情報付き

*int selectedIndex = EditorGUILayout.Popup(index, list);
`selectedIndex`には選択された新しいindexが格納される

*_anyNameProperty = serializedObject.FindProperty("_anyName");
各種Propertyを取得する

*serializedObject.Update();
シリアライズされたPropertyを更新しておく

*serializedObject.ApplyModifiedProperties();*}
更新された値を適用する


*void Start () {routine = coroutine();StartCoroutine(routine);}
Use this for initialization

*void Update ()*{if (Input.GetKeyDown(KeyCode.X)){StopCoroutine(routine);StartCoroutine(routine);}}
Update is called once per frame


*app.MapSignalR();
← この行を追加


*private Dictionary<SceneID, string> m_sceneNameDictionary = new Dictionary<SceneID, string> {{SceneID.Game, "Game"},{SceneID.Title, "Title"}};
enumからシーン名を取得するために必要

*public void LoadSceneEX(SceneID sceneID) {SceneManager.LoadScene(m_sceneNameDictionary[sceneID]);)}
これを呼んでシーン遷移を行う

*SceneManager.LoadScene(SceneID.Title);
文字列を渡すとそもそも型が違うのでエラー
SceneIDで定義している値しか受け付けない

*var sceneNames = UnityEditor.EditorBuildSettings.scenes.Select (scene => Path.GetFileNameWithoutExtension (scene.path))
BuildSettingsに登録した全てのシーン名文字列が格納された配列が取得できる


*iProgress.Report(i * 20);
進捗(%)を報告

*private void onProgressChanged(int per)*{label1.Text = $"{per}%";}
進捗通知を受けたらラベルに表示


*}
try 文

*}
catch 文 その1

*}
catch 文 その2

*}
finally 文


*}
が表示される｡

*var immutableList = ImmutableList.Create(0, 1, 2, 3, 4);
ImmutableList<T>はCtorを持ってないので､ファクトリ使って構築する｡

*var immutableList = ImmutableList.Create(0, 1, 2, 3, 4);
ImmutableList<T>はCtorを持ってないので､ファクトリ使って構築する｡

*immutableList.Add(42);
Addできる

*immutableList.RemoveAt(0);
RemoveAtも出来る

*var immutableList = ImmutableList.Create(0, 1, 2, 3, 4);
ImmutableList<T>はCtorを持ってないので､ファクトリ使って構築する｡

*var addAfterList = immutableList.Add(42);
Addできる

*var removeAfterList = immutableList.RemoveAt(0);
RemoveAtも出来る

*Console.WriteLine("immutableList");
元は不変

*Console.WriteLine("addAfterList");
Addはされている

*Console.WriteLine("removeAfterList");
RemoveAtもされている

*var immutableList = ImmutableList.Create(0, 1, 2, 3, 4);
ImmutableList<T>はCtorを持ってないので､ファクトリ使って構築する｡

*Console.WriteLine("immutableList");
当然不変

*Console.WriteLine("after");
変更されている

*var immutalbe = Enumerable.Range(0, 10).ToImmutableList();
こさえる

*var build = immutalbe.ToBuilder();
Builderをこさえる｡

*build[0] = 42;
Builderに対してはMutableな操作が効く｡

*Console.WriteLine("build");
当然操作の結果は変化する｡

*var after = build.ToImmutable();
ToImmutableでImmutable化できる｡

*Console.WriteLine("after");
操作結果は反映される


*}
ユーザーデータ削除時のアクション、メッセージを記載

*}
メンバー追加、削除といった会話ステータスの変更を把握
Activity.MembersAdded, Activity.MembersRemoved,
Activity.Action で詳細を確認

*}
コンタクトリストの追加、削除
詳細は Activity.From + Activity.Action で確認

*}
会話の入力時のアクション、メッセージを記載

*}
Ping時のアクション、メッセージを記載

*int length = (activity.Text ?? string.Empty).Length;
文字数をカウント

*Activity reply = activity.CreateReply($"You sent {activity.Text} which was {length} characters");
返答の文章を作成


*ctmd = DefCtxmData[CtxmCode.ReserveView];
メニューアイテム:予約一覧

*ctmd = DefCtxmData[CtxmCode.TunerReserveView];
メニューアイテム:使用予定チューナー


*.OrderBy(info => info.tunerID).ToList();
多分大丈夫だけど一応ソートしておく


*public static int Gcd(int a, int b) {if (a < b)// 引数を入替えて自分を呼び出すreturn Gcd(b, a);while (b != 0) {var remainder = a % b;a = b;b = remainder;}return a;}
ユークリッドの互除法

*return Gcd(b, a);*while (b != 0) {var remainder = a % b;a = b;b = remainder;}
引数を入替えて自分を呼び出す


*global::X.XClass.Greeting();
X.XClass: Greeting()


*string result = String.Join("", uniq_str);
文字列に再変換


*Effects.Add(Effect.Resolve("mycompany.CustomMasterDetailEffect"));
Effect を追加する


*string pluginsPath = Directory.GetCurrentDirectory() + @"\plugins";
フォルダがなければ作る。

*using (var catalog = new DirectoryCatalog(pluginsPath, "SummationPlugin.dll"))using (var container = new CompositionContainer(catalog)){if (catalog.LoadedFiles.Count > 0) container.SatisfyImportsOnce(this);
プラグイン読み込み


*label1.Text = ret.ToString();
UIスレッド


*public partial class PropertyGridPlus : PropertyGrid
ControlからPropertyGridに変更する

*int retDepth = currentDepth;
サブツリーの展開

*if (retDepth < childDepth)*retDepth = childDepth;
サブツリーの中で最も深い深さを取得する。

*ret.Append(new string('\t', currentDepth));
インデントのため、タブを現在の深さ分挿入する。

*string expandSign = "";
子アイテムがあるときの記号。自由に設定してください。

*ret.Append($"{expandSign}{item.Label.TrimStart('\t')}");
プロパティ名の追加

*ret.Append($"{new string('\t', maxDepth - currentDepth + 1)}");
プロパティ名と値の間のスペースを追加

*ret.AppendLine($"{item.Value}");
値の出力

*private void ToolStripMenuItemCopyAllWithIndent_Click(object sender, EventArgs e)*{string text = CreateText(SelectedGridItem, true);Clipboard.SetText(text);}
コンテキストメニューのClickイベントハンドラ


*direction_light_offset = this.transform.rotation;*}
太陽光の傾きオフセットをシーンの設定から保持

*gyro_to_light = Input.gyro.attitude;
端末の傾きを保持

*float yz_change;
yz軸の値を入れ替え

*this.transform.rotation = gyro_to_light * direction_light_offset;*}
ライトの向きを端末の傾き＋元の設定のオフセットで変更


*public virtual ActionResult GetFiles(string dir, bool onlyFolders, bool onlyFiles, string[] rootFolders)
←rootFoldersの引数をstring型からstring配列型に変更

*dir = Server.UrlDecode(dir);
Web画面の初回表示時に、dirに、2つ設定したルートフォルダの情報が渡されるので、その情報をList<string>インスタンスに変換して保持する。
（なお、フォルダ・ファイルのクリック時には、そのクリックしたノードの情報のみ渡される。
2つのノード情報がカンマ区切りで送られてくるのは初回表示時のみ）


*var rnds = new int[5].Select(_ => rnd.Next());
new int[5]は0を5個の配列になる

*var empty = Enumerable.Empty<int>();
空のシーケンスを返すだけ(いわゆるφ空集合)
あんまり用途ないけど戻り値nullだと駄目なパターンとか
型引数は推論できないため明示してあげる必要あり
出力なし


*[Import(typeof(IPlugin))]
プラグインを"1つだけ"読み込む

*string pluginsPath = Directory.GetCurrentDirectory() + @"\plugins";
フォルダがなければ作る。

*using (var catalog = new DirectoryCatalog(pluginsPath))using (var container = new CompositionContainer(catalog)){f (catalog.LoadedFiles.Count > 0) container.SatisfyImportsOnce(this);
プラグイン読み込み


*var fieldInfo = value.GetType().GetField(value.ToString());
リフレクションを用いて列挙体の型から情報を取得

*var attributes
指定した属性のリスト

*if ((attributes?.Count() ?? 0) <= 0)*return null;
属性がなかった場合、空を返す

*return attributes.First();
同じ属性が複数含まれていても、最初のみ返す


*var fibos = Fibonacci.Enumerate().Select((Value, Index) => new { Index, Value })
f(0)..f(50)までを列挙する

*long[] array = new long[] { 0, 1 };
無限に求める オーバーフローは無視


*,,,*string json = @"{'Name': 'Bad Boys','ReleaseDate': '1995-4-7T00:00:00','Genres': ['Action','Comedy']}";
}


*[DiagnosticAnalyzer(LanguageNames.CSharp)]
DiagnosticAnalyzerクラスを継承する

*public const string DiagnosticId = "任意のIDを割振る。";
分析で問題があると判断された箇所に表示するメッセージを定義する。

*private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(
上で定義した諸々をベースに DiagnosticDescriptor を作成する。
ソースコードに問題が見つかった場合に表示するメッセージ形式を定義している。

*context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);
SymbolKindの部分がポイント。ここで分析対象を指定している。NamedTypeは、クラス名やメソッド名などの名前。
第一引数に分析の処理を指定する。

*}
Tips: 分析対象はSyntaxKindでも指定可能。
その場合、RegisterSyntaxNodeActionメソッドを呼び出す。
context.RegisterSyntaxNodeAction(AnalyzeBlock, SyntaxKind.XXX);

*private static void AnalyzeSymbol(SymbolAnalysisContext context)*{// contextからソースコードの情報を取り出して、任意の分析処理を実行する。var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;if (namedTypeSymbol.Name.ToCharArray().Any(char.IsLower)){/* 「3. 必要に応じて分析処理の結果を表示する。」 に該当する部分 */var diagnostic = Diagnostic.Create(Rule, namedTypeSymbol.Locations[0], namedTypeSymbol.Name);context.ReportDiagnostic(diagnostic);}}
context.RegisterSymbolAction　の第一引数で指定されているメソッド

*var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;
contextからソースコードの情報を取り出して、任意の分析処理を実行する。


*Console.Write($"Hello, {value}")
"Hello, .NET Core"


*public void ConfigureServices(IServiceCollection services)*{// Add framework services.services.AddMvc();// リポジトリを登録services.AddSingleton<IPersonRepository, PersonRepository>();// SwaggerGen を追加services.AddSwaggerGen();}
This method gets called by the runtime. Use this method to add services to the container.

*services.AddSingleton<IPersonRepository, PersonRepository>();
リポジトリを登録

*services.AddSwaggerGen();
SwaggerGen を追加

*public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)*{loggerFactory.AddConsole(Configuration.GetSection("Logging"));loggerFactory.AddDebug();app.UseMvc();// .tag ファイルを扱えるようにするvar provider = new FileExtensionContentTypeProvider();provider.Mappings[".tag"] = "riot/tag";// wwwroot/index.html を起動時に表示するようにするapp.UseDefaultFiles();// 静的ファイルを扱えるようにするapp.UseStaticFiles(new StaticFileOptions{ContentTypeProvider = provider});// UseSwagger と UseSwaggerUi を追加app.UseSwagger();app.UseSwaggerUi();}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*var provider = new FileExtensionContentTypeProvider();
.tag ファイルを扱えるようにする

*app.UseDefaultFiles();
wwwroot/index.html を起動時に表示するようにする

*app.UseStaticFiles(new StaticFileOptions{ContentTypeProvider = provider});
静的ファイルを扱えるようにする

*app.UseSwagger();
UseSwagger と UseSwaggerUi を追加

*services.AddSingleton<IPersonRepository, pository>();
リポジトリを登録

*var location = System.Reflection.Assembly.GetEntryAssembly().Location;
XML Document のパスを取得する

*services.AddSwaggerGen(options => {XML Document Comment を読込むoptions.IncludeXmlComments(xmlPath);
SwaggerGen を追加

*options.IncludeXmlComments(xmlPath);
XML Document Comment を読込む


*Console.WriteLine(x);
TryParseが先に呼ばれてxは初期化されるはずだが・・・
「エラー  CS0165  未割り当てのローカル変数 'x' が使用されました。」

*private static void validate(ref int x, bool parseResult)*{int min = 1, max = 1000, defaultVal = 100;x = !parseResult ? defaultVal: x < min ? min: max < x ? max: x;}
Parse成功なら範囲チェック、失敗ならデフォルト値をセット

*private static void validate(bool parseResult, ref int x)*{validate(ref x, parseResult);}
逆順だと通る


*void Start()*{// Hoge()を実行Hoge();}
Use this for initialization

*Hoge();
Hoge()を実行

*this.UpdateAsObservable()
Time.time > 1.5f の場合に１回だけHoge()を実行


*var json = payload.String("json");
json    Google によって提供される文字列にエンコードされた JSON
signature    Google によって提供される JSON パラメーターの署名


*Activity reply = activity.CreateReply($"You sent {activity.Text} which was {length} characters");
return our reply to the user

*Activity reply = activity.CreateReply($"「{activity.Text}！」");
「オウム返しだ」「オウム返しだ！」

*return message.CreateReply($"「こんにちは！」");
アイサツは実際大事。古事記にもそう書かれている。

*Activity reply = activity.CreateReply($"「{activity.Text}！」");
「オウム返しだ」「オウム返しだ！」

*return message.CreateReply($"「こんにちは！」");
アイサツは実際大事。古事記にもそう書かれている。

*return null;
省略


*var array = new int[5][][];
3次元ジャグ配列

*For(0, 5, 0, 5, (i, j) =>*{if (j == 0) array[i] = new int[5][];array[i][j] = new int[5];});
arrayの配列要素を生成

*For(0, 5, 0, 5, 0, 5, (i, j, k) =>*{// i + j + k が奇数なら-1, 偶数なら1をセットarray[i][j][k] = ((i + j + k) % 2) == 0 ? 1 : -1;});
arrayの要素を初期化

*array[i][j][k] = ((i + j + k) % 2) == 0 ? 1 : -1;
i + j + k が奇数なら-1, 偶数なら1をセット

*return i * j < 50;
何かしらの処理


*services.AddSingleton<IPersonRepository, PersonRepository>();
リポジトリを登録

*[HttpGet("{id}", Name="GetPerson")]public IActionResult Get(string id){var person = People.Find(id);
GET api/v1/person/{id}

*[HttpPut("{id}")]
PUT api/v1/person/{id}

*[HttpDelete("{id}")]
DELETE api/v1/person/{id}

*[HttpDelete("{id}")]
DELETE api/v1/person/{id}

*[HttpGet("{id}", Name="GetPerson")]public IActionResult Get(string id){...},,,[HttpGet]public IEnumerable<Person> Get() => People.GetAll();
GET api/v1/person/{id}


*int upper = 100;
1 - 100 までのメビウス関数を求める

*var primes = new List<int>() { 2, 3 };
2,3は既知の素数とする

*int ix = 0;*while (true) {int prime1st = primes[ix];int prime2nd = primes[++ix];// ふるい用の配列の下限、上限を求め、配列を確保する。var lower = prime1st * prime1st;var upper = prime2nd * prime2nd - 1;// ふるいは、[4:8], [9:24], [25:48], [49:120]... と変化する。// []内の数値は、配列の下限と上限var sieve = new BoundedBoolArray(lower, upper);// 求まっている素数を使い、ふるいに掛けるforeach (var prime in primes.Take(ix)) {var start = (int)Math.Ceiling((double)lower / prime) * prime;for (int index = start; index <= upper; index += prime)sieve[index] = true;}// ふるいに掛けられて残った値が素数。これを列挙する。// 併せて、求まった素数は、primesリストに記憶していく。// この素数が次にふるいに掛ける際に利用される。for (int i = lower; i <= upper; i++) {if (sieve[i] == false) {primes.Add(i);yield return i;}}}
4以上の整数から素数を列挙する。int.MaxValueを超えたときには対処していない

*var lower = prime1st * prime1st;
ふるい用の配列の下限、上限を求め、配列を確保する。

*var sieve = new BoundedBoolArray(lower, upper);
ふるいは、[4:8], [9:24], [25:48], [49:120]... と変化する。
[]内の数値は、配列の下限と上限

*for (int i = lower; i <= upper; i++) {
ふるいに掛けられて残った値が素数。これを列挙する。
併せて、求まった素数は、primesリストに記憶していく。
この素数が次にふるいに掛ける際に利用される。

*class BoundedBoolArray {private BitArray _array;private int _lower;public BoundedBoolArray(int lower, int upper) {_array = new BitArray(upper - lower + 1);_lower = lower;}public bool this[int index] {get {return _array[index - _lower];}set {_array[index - _lower] = value;}}}
下限、上限が指定できるbool型配列


*var soundPool = new SoundPool(1, Stream.Music, 0);
先に効果音を読み込んでおく

*var duration = GetSoundDuration(Resource.Raw.cat);
SoundPool は再生完了のコールバックがないので、事前に長さを得ておく

*var result = audioManager.RequestAudioFocus(this, Stream.Music, AudioFocus.GainTransientMayDuck);
ダッキングを許可する AudioFocus を要求

*soundPool.Play(soundId, 1.0f, 1.0f, 0, 0, 1.0f);
効果音を再生する

*await Task.Delay((int)duration);
再生完了まで待つ

*audioManager.AbandonAudioFocus(this);
AudioFocus を開放

*private long GetSoundDuration(int rawId)*{using (var player = MediaPlayer.Create(ApplicationContext, rawId)){return player.Duration;}}
音声の再生長さを得る

*public void OnAudioFocusChange([GeneratedEnum] AudioFocus focusChange)*{// 今回は使用しない}
IOnAudioFocusChangeListener の実装（RequestAudioFocus のために必要）

*}
今回は使用しない


*socket.OnOpen += (sender, e) => {[このときに実行したい処理を記述する]};
WebSocketの接続が確立されたときのイベントハンドラ

*socket.OnMessage += {[このときに実行したい処理を記述する]};
WebSocketからメッセージが送信されたときのイベントハンドラ

*socket.OnError += (sender, e) => {[このときに実行したい処理を記述する]};
WebSocketとの接続にエラーが発生したときのイベントハンドラ

*socket.OnClose += (sender, e) => {[このときに実行したい処理を記述する]};
WebSocketとの接続が終了したときのイベントハンドラ


*==========================再生ボタン押下_musicPlayerView.PlayButton.OnClickAsObservable().Subscribe(_ => { _musicPlayerModel.PlayMusic(_musicPlayerView.SeekBar.value); }).AddTo(_disposables);
View → Modelへの反映

*_musicPlayerView.PlayButton.OnClickAsObservable()*.Subscribe(_ => { _musicPlayerModel.PlayMusic(_musicPlayerView.SeekBar.value); }).AddTo(_disposables);
再生ボタン押下

*_musicPlayerView.StopButton.OnClickAsObservable()*.Subscribe(_ => { _musicPlayerModel.StopMusic(); }).AddTo(_disposables);
停止ボタン押下

*_musicPlayerView.SeekBar.OnPointerDownAsObservable()*.Subscribe(_ => { _musicPlayerModel.StopMusic(); }).AddTo(_disposables);
シークバーのドラッグ開始

*_musicPlayerView.SeekBar.OnPointerUpAsObservable()*.Subscribe(_ => { _musicPlayerModel.PlayMusic(_musicPlayerView.SeekBar.value); }).AddTo(_disposables);
シークバーのドラッグ終了

*==========================再生時間を反映_musicPlayerModel.MusicPlayTimeRP.Subscribe(time =>
Model → Viewへの反映

*_musicPlayerModel.MusicPlayTimeRP
再生時間を反映

*_musicPlayerView.SeekBar.value = time;
シークバーに反映

*_musicPlayerView.SetPlayTime(_musicPlayerModel.GetMusicTime());
テキストに反映

*_musicPlayerModel.MusicPlayModeRP
再生モード変更に応じてボタンの表示を切り替え


*}
その他 .AddMvc() など...


*var imageQuery = bingContainer.Image(word, null, null, null, null, null);
docの記述

*var imageQuery = bingContainer.Image(word, null, null, null, null, null, null);
こうすればパスる（null1個追加)

*using Systemt;
↓をやってます。

*m_numberOfItem = 0;
以下で定義されたメンバ変数を使って検索、結果を格納します。
入力
引数word が検索単語です。
以下のコードで使っている定義です。呼び出す前に設定済です。
private const string BING_SEARCH_API_URL = "https:api.datamarket.azure.com/Bing/Search/";
private string m_BingKey = "プライマリ アカウント キー";
private int m_count;  何回目の検索であるかが設定されています。
出力
以下に成功失敗が入ります。
private bool m_success;
失敗の際には以下にエラー（例外メッセージ）が入ります。
private string m_exceptionMeggase;
成功の際には、以下の個数が入ります。
private int m_numberOfItem;
以下にタイトルと画像のURLをそれぞれ入れます。
private string[] m_title = new string[50];
private string[] m_mediaUri = new string[50];


*public void ConfigureServices(IServiceCollection services)*{// Add framework services.services.AddMvc();}
This method gets called by the runtime. Use this method to add services to the container.

*public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)*{loggerFactory.AddConsole(Configuration.GetSection("Logging"));loggerFactory.AddDebug();app.UseMvc();// wwwroot/index.html を起動時に表示するようにするapp.UseDefaultFiles();// 静的ファイルを扱えるようにするapp.UseStaticFiles();}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*app.UseDefaultFiles();
wwwroot/index.html を起動時に表示するようにする

*app.UseStaticFiles();
静的ファイルを扱えるようにする

*public void ConfigureServices(IServiceCollection services)*{// Add framework services.services.AddMvc();}
This method gets called by the runtime. Use this method to add services to the container.

*public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)*{loggerFactory.AddConsole(Configuration.GetSection("Logging"));loggerFactory.AddDebug();app.UseMvc();// .tag ファイルを扱えるようにするvar provider = new FileExtensionContentTypeProvider();provider.Mappings[".tag"] = "riot/tag";// wwwroot/index.html を起動時に表示するようにするapp.UseDefaultFiles();// 静的ファイルを扱えるようにするapp.UseStaticFiles(new StaticFileOptions{ContentTypeProvider = provider});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*var provider = new FileExtensionContentTypeProvider();
.tag ファイルを扱えるようにする

*app.UseDefaultFiles();
wwwroot/index.html を起動時に表示するようにする

*app.UseStaticFiles(new StaticFileOptions{ContentTypeProvider = provider});
静的ファイルを扱えるようにする


*var publicParameters = CreatePublicKeyParameters(PublicKey);
暗号化

*var privateParameters = CreatePrivateKeyParameters(PrivateKey);
復号化

*var publicParameters = CreatePublicKeyParameters(PublicKey);
暗号化

*var privateParameters = CreatePrivateKeyParameters(PrivateKey);
復号化

*return new RSAParameters*{Exponent = Adjustment(parameters?.Exponent?.ToByteArray()),Modulus = Adjustment(parameters?.Modulus?.ToByteArray())};
$"OID:{info.AlgorithmID.Algorithm.Id}".Dump();

*const string PrivateKey = @"-----BEGIN RSA PRIVATE KEY-----MIICXAIBAAKBgQC7Np2qTFhnZD0meg7OqzPMLzQjZLhCjLpmVoeTPAaeTpvQij0rEG9FmS+Gbj4oGBiV8BaOraWlRTmPh2DnJJv/WmsAmd+WRsbCowGfpmukG7X0bEp7XIRvbwzTHV34X3JyWdq9eGyr6FjidyiMPnA+sBRuvJhvsf4kmadrHIGXuQIDAQABAoGACJHfdcQ458K26eP8eYlsvZQLlvMtXB6FCdo8Kok85FJE3670Tdxau5zfiA/T2JIBzhtHbRCV3JLmp6NS1EHgwiOVgohrzLj2QME+pN05Kxs+d8snfyl+izmuluV/4qfOEcq1q3BiKI5jjrF78vVJzkRJNN/xLDxfk+duXYxnHeECQQDoQCcVGRKThyDpcD/flayKf0ejtfKFZieTkOcKmU5zNdACDu7QgvcgwA2emu/cH/yFIExzPcg6vAXccXAg6CLTAkEAzlt6zfaLfGGeWrp+2W+J9svrc060ckeFRzDHiwWA/T3c/F1fjCDsB2qouZuRWxSQJ5XTro4uKRvd+GjBZxALwwJAC5+qVRP8KgYJT6WejMIg8I2OOFNS3/pM4MXPymgB1SJMVs4IhccIN0tlYxq+BnZTXRZQvTPKYaYnZPEIe50ioQJBALe0mrvWu1BsexPcKOcbM+Ago6gQLfX6k7zPwSSTLsTDmQKVgWT3PghQPIqX4qwJv1duO3ePHar9IvttDpfYog8CQAMy9RiFqJ3K/St4iVZizsoeG/GAa+o/kKiTjK4+wnoxUdkJEZh/7lkKbw9h2CVURIjUitmKDrfjkeJ7GsdKvAM=-----END RSA PRIVATE KEY-----";
CMD:openssl genrsa > private-key.pem

*const string PublicKey = @"-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC7Np2qTFhnZD0meg7OqzPMLzQjZLhCjLpmVoeTPAaeTpvQij0rEG9FmS+Gbj4oGBiV8BaOraWlRTmPh2DnJJv/WmsAmd+WRsbCowGfpmukG7X0bEp7XIRvbwzTHV34X3JyWdq9eGyr6FjidyiMPnA+sBRuvJhvsf4kmadrHIGXuQIDAQAB-----END PUBLIC KEY-----";
CMD:openssl rsa -pubout < private-key.pem > public-key.pem


*SceneView.RepaintAll();
シーンビュー更新


*static readonly string BASE_URL = "http:
vccw.dev";


*int count2 = query2.Count();
7件中の2件抽出


*if (!goal && next[x] >= 0) {
分かれ道を進む


*class BoundedBoolArray {private BitArray _array;private int _lower;public BoundedBoolArray(int lower, int upper) {_array = new BitArray(upper - lower + 1);_lower = lower;}public bool this[int index] {get {return _array[index - _lower];}set {_array[index - _lower] = value;}}}
下限、上限が指定できるbool型配列

*var primes = new List<int>() { 2, 3 };
2,3は既知の素数とする

*int ix = 0;*while (true) {int prime1st = primes[ix];int prime2nd = primes[++ix];// ふるい用の配列の下限、上限を求め、配列を確保する。var lower = prime1st * prime1st;var upper = prime2nd * prime2nd - 1;// ふるいは、[4:8], [9:24], [25:48], [49:120]... と変化する。// []内の数値は、配列の下限と上限var sieve = new BoundedBoolArray(lower, upper);// 求まっている素数を使い、ふるいに掛けるforeach (var prime in primes.Take(ix)) {var start = (int)Math.Ceiling((double)lower / prime) * prime;for (int index = start; index <= upper; index += prime)sieve[index] = true;}// ふるいに掛けられて残った値が素数。これを列挙する。// 併せて、求まった素数は、primesリストに記憶していく。// この素数が次のステップ以降で、ふるいに掛ける際に利用される。for (int i = lower; i <= upper; i++) {if (sieve[i] == false) {primes.Add(i);yield return i;}}}
4以上の整数から素数を列挙する。int.MaxValueを超えたときには対処していない

*var lower = prime1st * prime1st;
ふるい用の配列の下限、上限を求め、配列を確保する。

*var sieve = new BoundedBoolArray(lower, upper);
ふるいは、[4:8], [9:24], [25:48], [49:120]... と変化する。
[]内の数値は、配列の下限と上限

*for (int i = lower; i <= upper; i++) {
ふるいに掛けられて残った値が素数。これを列挙する。
併せて、求まった素数は、primesリストに記憶していく。
この素数が次のステップ以降で、ふるいに掛ける際に利用される。

*var primes = Primes().Take(1000);
1000個の素数を取得

*var primes = Primes().TakeWhile(p => p <= 500);
500以下の素数を取得

*var prime = Primes().First(p => p > 500);
500より大きい最初の素数を取得


*hogeMethod_ ();
ネイティブコード上のメソッドを呼び出す


*app.UseDefaultFiles();
追加分


*using (var stream = new FileStream(path, FileMode.Open)){デシリアライズするvar serializer = new XmlSerializer(typeof(Members));
ファイルを開く

*var serializer = new XmlSerializer(typeof(Members));
デシリアライズする

*return model.Person;
person 要素を返す


*BasePath = "https:
xamarin-chat-sample.firebaseio.com"


*client_secret = appSecret,
FacebookアプリのSecret

*fb.AccessToken = result.access_token;
取得したアプリアクセストークンを使うようにFacebookClientに設定

*dynamic testUsers = fb.Get($"/{appId}/accounts/test-users");
次にアプリに属すテストユーザーのデータを読み出す

*var userToken = ((IEnumerable<dynamic>)testUsers.data).FirstOrDefault(_ => _.id == "123455555").access_token;
最後に、テストユーザーのID(例えば"123455555")を元に、ユーザーアクセストークンを取り出す

*fb.AccessToken = userToken;*fb.Post("/me/feed", new { message = "hello from unit test" });
後は、ユーザーアクセストークンを元に投稿するなどする


*_calendarButton = datePicker.Template.FindName("PART_Button", datePicker) as Button;
年月のみでカレンダーを表示させる場合に使用します

*this.IscustomizeFormat = !string.IsNullOrEmpty(this.CustomDateFormat);
表示用と編集用で表示フォーマットを変更します

*_textBox.Text = this.ToEditingDateFormat(datePicker.SelectedDate.Value, datePicker);
フォーカスが合っていて、編集可能なときは、編集用の書式にする。

*TempText = AssociatedObject.SelectedDate.Value.ToString();
変換前に値を一時保持

*datePicker.DisplayDate = DateTime.Now;
PART_TextBoxの値がない場合は、カレンダーの初期値を本日にします

*var dateTextBox = datePicker.Template.FindName("PART_TextBox", datePicker) as DatePickerTextBox;
テンプレート内のテキストボックスを検索します。

*TempText = datePicker.SelectedDate.Value.ToString();
変換前に値を一時保持


*public static readonly DependencyProperty HeaderProperty =DependencyProperty.Register("Header", typeof(FrameworkElement), typeof(HeaderControl), new PropertyMetadata(null));
Using a DependencyProperty as the backing store for Header.  This enables animation, styling, binding, etc...

*public static readonly DependencyProperty ContentProperty =DependencyProperty.Register("Content", typeof(FrameworkElement), typeof(HeaderControl), new PropertyMetadata(null));
Using a DependencyProperty as the backing store for Content.  This enables animation, styling, binding, etc...


*string path = "output.png";
このようにファイル名で指定します。

*int PrepareDragAndDrop(string[] files, string text);
以下の関数処理を実装する事で、アプリケーションが実現出来ます。
実際は CuiHelperApplication.cs を見てもらってもよろしいでしょうか・・

*m_ComboBoxData = new[] {new CuiHelperComboBoxData { Name = "Goto Home", Commnad = COMMAND_GO_HOME },new CuiHelperComboBoxData { Name = "Calc", Commnad = COMMAND_CALC },new CuiHelperComboBoxData { Name = "View jpg/png file", Commnad = COMMAND_IMAGE },};
CuiHelperComboBoxData[]の生成


*string[] data = {"A","B","C"};
ループ内でカンマ追記判定

*string[] data = {"A","B","C"};
ループ後にカンマ削除

*Console.Write(csv);
csv = csv.TrimEnd(','); C#ならTrimEndでもいい

*string[] data = {"A","B","C"};
ループ中にカンマ文字列定義

*string[] data = {"A","B","C"};
先に先頭の値をセット

*string[] data = {"A","B","C"};
String.Joinメソッド


*return RepeatRandomChoiceInternal(source);
要素取得時ではなく関数呼び出し時に上記の引数チェックが行われるように、
yield を用いた処理は別関数にする。

*return TakeUntilMatchingPatternInternal(source, pattern);
要素取得時ではなく関数呼び出し時に上記の引数チェックが行われるように、
yield を用いた処理は別関数にする。


*Utils.webCamTextureToMat(webCamTexture, mat, colors);
ArgumentException: The output Mat object has to be of the same size

*}
以下Mat処理

*texture = new Texture2D(webCamTexture.width, webCamTexture.height);
宣言

*}
以下Mat処理


*Console.WriteLine("ok");
OK のとき

*Console.WriteLine("cancel");
それ以外

*ShowMessageBox = () => MessageBox.Show(messageBoxText, caption, button, icon);
メッセージ ボックスを表示する関数を設定

*var result = ShowMessageBox();
メッセージボックスを表示して結果を受取る

*if (!_acts.ContainsKey(result) || _acts[result] == null)*return;
存在しないかあっても null の場合は何もしない

*_acts[result]();
実行

*var confirm = ChainableMessageBox.Create("確認です。", "確認", MessageBoxButton.OKCancel, MessageBoxImage.Question);
確認

*var confirm = ChainableMessageBox.Create(MessageBoxButton.OKCancel, MessageBoxImage.Question);
確認

*var error = ChainableMessageBox.Create(MessageBoxButton.OK, MessageBoxImage.Error);
エラー

*await Task.Delay(TimeSpan.FromSeconds(2));
なにか重たい処理...


*InMobiAndroid.init ("Property ID", dict);
Property IDを引数に渡します。(string型)

*InMobiAndroid.createBanner (Placement ID, name, InMobiAdPosition.BottomCenter, 320, 50, 30, "test1,test2,test3", dict);
Placement ID(long型), bannerの名前, bannerの位置, 横のサイズ, 縦のサイズ, インターバルの時間 を引数に渡します。

*InMobiAndroid.loadBanner(name);
作成したbannerの名前を引数に渡します。


*}
テストケース内で次のようにアクセス出来る。
_appsettingsFixture.Configuration


*FileName = config.AppSettings.Settings["FileName"].Value;
config読みだし

*config.AppSettings.Settings["FileName"].Value = FileName;
config書き込み


*private void Set(IEntityPersister persister, object[] state, string propertyName, object value)*{var index = Array.IndexOf(persister.PropertyNames, propertyName);if (index == -1)return;state[index] = value;}
ref: http:stackoverflow.com/a/24908880


*public void ConfigureServices(IServiceCollection services)*{// Add framework services.services.AddMvc();}
This method gets called by the runtime. Use this method to add services to the container.

*public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)*{loggerFactory.AddConsole(Configuration.GetSection("Logging"));loggerFactory.AddDebug();app.UseMvc();// プロジェクトで扱う各種静的ファイルの場所を指定する// js/css ファイルの読込み先var location = "wwwroot/app";// 実行時に表示する html ファイルを指定するvar options = new DefaultFilesOptions();options.DefaultFileNames.Clear();options.DefaultFileNames.Add("app/index.html");app.UseDefaultFiles(options);app.UseStaticFiles();// javascriptapp.UseStaticFiles(new StaticFileOptions{FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), $"{location}/scripts")),RequestPath = new PathString("/scripts"),});// cssapp.UseStaticFiles(new StaticFileOptions{FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), $"{location}/styles")),RequestPath = new PathString("/styles")});// html テンプレートapp.UseStaticFiles(new StaticFileOptions{FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), $"{location}/views")),RequestPath = new PathString("/views")});}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.

*var location = "wwwroot/app";
プロジェクトで扱う各種静的ファイルの場所を指定する
js/css ファイルの読込み先

*var options = new DefaultFilesOptions();
実行時に表示する html ファイルを指定する

*app.UseStaticFiles(new StaticFileOptions{FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), $"{location}/scripts")),
javascript

*app.UseStaticFiles(new StaticFileOptions{FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), $"{location}/styles")),
css

*app.UseStaticFiles(new StaticFileOptions{FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), $"{location}/views")),
html テンプレート


*yield return i;
ここで列挙してしまう


*bool b3 = obj is Oneisan;
False


*private bool disposedValue = false;
重複するDispose()呼び出しを検出する

*public void Dispose()
IDisposableを実装しておくと、xUnitがテスト終了時に呼び出してくれる
https:xunit.github.io/docs/shared-context.html#class-fixture

*}
テストケースが続く．．．．．．．


*hiddenNeurons: new int[] { 1 });
出力層の次元

*new GaussianWeights(network).Randomize();
ネットワークの重みをガウス分布で初期化する

*var teacher = new PerceptronLearning(network);
DBNの学習アルゴリズムの生成（誤差関数を決める部分）

*for (int i = 0; i < 1000; i++)*teacher.RunEpoch(inputs, outputs);
学習実行。同じデータを1000回学習させる。

*network.UpdateVisibleWeights();
重みの更新


*else
スペースキーから指を離したとき

*CurrentLineObject = null;
現在描画中の線があったらnullにして次の線を描けるようにする。

*if (Input.GetKeyDown(KeyCode.Delete)) Destroy(gameObject);*}
削除


*public double GetBmi() {
2. メソッド


*var now = DateTime.Now;
ページイメージをファイルに保存する


*static void Func(object anonymousObj)*{var dict = new RouteValueDictionary(anonymousObj);foreach (var kv in dict){Console.WriteLine($"{kv.Key} => {kv.Value}");}}
匿名型のオブジェクトを受け取り、辞書に変換する


*{
ここに行く


*};
このクラスの中身がここに入る

*void Start () {}
Use this for initialization

*void Update () {}
Update is called once per frame

*void Start () {}
Use this for initialization

*void Update () {int count = transform.childCount;if(prayerTransform.childCount==count){//プレイヤーの子の数と自分の子の数が同じ場合の処理}}
Update is called once per frame

*
プレイヤーの子の数と自分の子の数が同じ場合の処理


*public ActionResult ExecProcessCompleted(AsyncTestModel key)
AsyncManager.Parametersに指定したkey名で引数を受とる。


*public class Dog : RealmObject*{[ObjectId]public string SSN { get; set; }public string Name { get; set; }public int Age { get; set; }public Person Owner { get; set; }}
Define your models like regular C# classes

*this.realm.Write(() =>*{var id = this.Count();var mydog = realm.CreateObject<Dog>();mydog.SSN = (id).ToString ();mydog.Name = newDog.Name;mydog.Age = newDog.Age;});
トランザクションを用いてオブジェクトを保存・更新します.

*using (var trans = this.realm.BeginWrite()){これはだめ.foreach (var dog in realm.All<Dog>())
トランザクションを開始してオブジェクトを削除します.

*//              {//                  this.realm.Remove(dog);//              }
foreach (var dog in realm.All<Dog>())

*using (var trans = this.realm.BeginWrite ()) {this.realm.Remove(obj);
Delete an object with a transaction


*HttpResponseMessage aResponse = await httpClient.PostAsync("http:
flashairupload.cgi", fileContent);

*var str = await uploadStringToFile("任意の文字列");
呼び出し例


*Debug.WriteLine(cnt);
=> 2になるはず

*new Task(() =>
Threadは使えません！
new Thread(() =>


*if (n <= 0) return 0;*// (n & (n - 1)) == 0 の時は、nが2の冪乗であるため、そのままnを返す。
nが0以下の時は0とする。

*if ((n & (n - 1)) == 0) return (uint)n;*// bitシフトを用いて、2の冪乗を求める。
(n & (n - 1)) == 0 の時は、nが2の冪乗であるため、そのままnを返す。

*uint ret = 1;*while (n > 0) { ret <<= 1; n >>= 1; }
bitシフトを用いて、2の冪乗を求める。

*if (n <= 0) return 0;*// (n & (n - 1)) == 0 の時は、nが2の冪乗であるため、そのままnを返す。
nが0以下の時は0とする。

*if ((n & (n - 1)) == 0) return (uint)n;*// bitシフトを用いて、2の冪乗を求める。
(n & (n - 1)) == 0 の時は、nが2の冪乗であるため、そのままnを返す。

*uint ret = 1;*while (n > 0) { ret <<= 1; n >>= 1; }
bitシフトを用いて、2の冪乗を求める。


*var startDateProperty = validationContext.ObjectInstance.GetType().GetProperty(StartDatePropertyName);
開始日プロパティ取得

*var startDateValue = startDateProperty.GetValue(validationContext.ObjectInstance, null );
開始日プロパティの値取得


*Programs programs = new Programs();
コンストラクタの呼び出し

*programs = null;
programsインスタンスを破棄

*public Programs()*{Console.WriteLine("コンストラクタが自動で呼ばれました");}
コンストラクタの定義

*Programs programs1 = new Programs();
コンストラクタの呼び出し

*public Programs()*{Console.WriteLine("引数が無いコンストラクタです");}
コンストラクタの定義


*config.Filters.Add(new PrettyPrintFilterAttribute());
Web API の設定およびサービス

*config.MapHttpAttributeRoutes();
Web API ルート


*var source2 = source.ToArray();
シーケンスを配列に変換します。

*var block = new T[numInBlock];*for( int i = 0; i < source2.Length; i++ ) {// シーケンスのi番目の要素を、ブロックの( i mod numInBlock )番目に代入します。block[i % numInBlock] = source2[i];// iをnumInBlockで割った余りが、ブロックの末尾のインデックスと等しい or// iがシーケンスの末尾のインデックスと等しいかどうか判別します。if( i % numInBlock == numInBlock - 1 || i == source2.Length - 1 ) {// ブロックを返します。yield return block;// 新しいブロックを作成します。（注：配列は参照型です）block = new T[numInBlock];}}
ブロックとなる配列です。

*block[i % numInBlock] = source2[i];
シーケンスのi番目の要素を、ブロックの( i mod numInBlock )番目に代入します。

*// iがシーケンスの末尾のインデックスと等しいかどうか判別します。*if( i % numInBlock == numInBlock - 1 || i == source2.Length - 1 ) {// ブロックを返します。yield return block;// 新しいブロックを作成します。（注：配列は参照型です）block = new T[numInBlock];}
iをnumInBlockで割った余りが、ブロックの末尾のインデックスと等しい or

*yield return block;
ブロックを返します。

*block = new T[numInBlock];
新しいブロックを作成します。（注：配列は参照型です）

*return source.Select( ( v, i ) => new KeyValuePair<int, T>( i / numInBlock, v ) )
各要素にインデックスを付加し、numInBlockで割った値と要素の値とのペアを作成します。

*.GroupBy( v1 => v1.Key, v2 => v2.Value )
numInBlockで割った値でグループ化し、そのグループに属する要素の値を抽出します。

*.Select( block => block.ToArray() );
グループに属する要素の値を配列に変換します。

*var block = new T[numInBlock];
ブロックとなる配列です。

*block[s.Key] = s.Value;
要素のキーをブロックのインデックスとして指定し、要素の値を代入します。

*yield return block;
ブロックを返します。

*block = new T[numInBlock];
新しいブロックを作成します。

*int indexInBlock = numInBlock - 1;
ブロック内のインデックスです。

*var block = new T[numInBlock];
ブロックとなる配列です。

*block[s.Key] = s.Value;
ブロック内の要素にシーケンスの要素を代入します。

*yield return block;
ブロックを返します。

*block = new T[numInBlock];
新しいブロックを作成します。

*// シーケンスの末尾側の要素がforeach文内でまだ返していないので、*// ここで返します。
indexInBlockの値が、ブロック内の末尾のインデックスより前にいる時、

*// ここで返します。*if( indexInBlock < numInBlock - 1 ) {yield return block;}
シーケンスの末尾側の要素がforeach文内でまだ返していないので、

*int indexInBlock = numInBlock - 1;
ブロック内のインデックスです。

*var block = new T[numInBlock];
ブロックとなる配列です。

*block[s.Key] = s.Value;
ブロック内の要素にシーケンスの要素を代入します。

*yield return block;
ブロックを返します。

*block = new T[numInBlock];
新しいブロックを作成します。

*// シーケンスの末尾にある端数の要素がforeach文内でまだ返していないので、*// ここで返します。
indexInBlockの値が、ブロック内の末尾のインデックスより前にいる時、

*// ここで返します。*if( includeLastFractionBlock && indexInBlock < numInBlock - 1 ) {yield return block;}
シーケンスの末尾にある端数の要素がforeach文内でまだ返していないので、

*string rnaSeq = "AUGAUGGAGCUUCGGAGCUAG";
塩基配列（RNA）

*var codon = rnaSeq.ToBlockSequence( 3 ).Select( c => new string( c ) );
コドンに変換します。

*Console.WriteLine( $"Codon      : {string.Join( "-", codon )}" );
コドンを出力します。

*Console.WriteLine( $"Amino acid : {string.Join( "-", codon.Select( c => RNACodonTable[c] ) )}" );
コドン表に従ってアミノ酸に変換し、出力します。


*Get["/"] = _ => View["index"];
View を返す

*List<Person> _values = new List<Person>*{new Person { Id = 1, Name = "Francis" },new Person { Id = 2, Name = "Nancy" },};
TODO: スタブ

*Get["/"] = _ => Response.AsJson(_values);
JSON に変換して返す

*Get["/{id}"] = p => Response.AsJson(_values.Where(x => x.Id == p.id)
指定された ID の Person を JSON に変換して返す

*nancyConventions.ViewLocationConventions
View のロケーションを追加

*nancyConventions.StaticContentsConventions.Clear();
静的コンテンツの場所をクリア

*nancyConventions.StaticContentsConventions
静的コンテンツの場所を追加
Bower

*nancyConventions.StaticContentsConventions
JSファイル

*nancyConventions.StaticContentsConventions
CSSファイル


*var v =  new Vector2(-vec.y,vec.x).normalized * width;
90度回転させてから正規化*widthで左右への幅ベクトルを得る

*vertices.Add(currentPos-v);
指定した横幅に広げる


*Application.Quit();
Applicationを強制終了

*UnityEditor.EditorApplication.isPlaying = false;
Editorを強制終了

*Application.Quit();
Applicationを強制終了

*UnityEditor.EditorApplication.isPlaying = false;
Editorを強制終了

*Application.Quit();
Applicationを強制終了

*UnityEditor.EditorApplication.isPlaying = false;
Editorを強制終了


*List<Person> _values = new List<Person>*{new Person { Id = 1, Name = "Francis" },new Person { Id = 2, Name = "Nancy" },};
TODO: スタブ

*Get["/"] = _ => View["index"];
View を返す

*Get["/api/person"] = _ => Response.AsJson(_values);
JSON に変換して返す

*Get["/api/person/{id}"] = p => Response.AsJson(_values.Where(x => x.Id == p.id)
指定された ID の Person を JSON に変換して返す

*// For more information on how to configure your application, visit http://go.microsoft.com/fwlink/?LinkID=398940*public void ConfigureServices(IServiceCollection services)
This method gets called by the runtime. Use this method to add services to the container.

*public void ConfigureServices(IServiceCollection services)*{}
For more information on how to configure your application, visit http:go.microsoft.com/fwlink/?LinkID=398940

*public void Configure(IApplicationBuilder app)*{app.UseOwin(pipeline => pipeline.UseNancy(options => options.Bootstrapper = new BootStrapper()));}
This method gets called by the runtime. Use this method to configure the HTTP request pipeline.


*Get["
"] = _ => View["index"];"Hello World!";

*Get["/api/person"] = _ => Response.AsJson(_values);
JSON に変換して返す

*Get["/api/person/{id}"] = p => Response.AsJson(_values.Where(x => x.Id == p.id)
指定された ID の Person を JSON に変換して返す


*actionExecutedContext.Response = actionExecutedContext.Request.CreateResponse();
HttpCode:200を返して何事もなかったようにする


*var argTypes = new Type[]{Arg0?.GetType() ?? typeof(object),Arg1?.GetType() ?? typeof(object),Arg2?.GetType() ?? typeof(object),Arg3?.GetType() ?? typeof(object),};
各引数の型から動的に ScriptArguments<> オブジェクトを作り出す。

*_runner = CSharpScript.Create(Script, ScriptOptions, _args?.GetType()).CreateDelegate(); ;
スクリプトをコンパイルしてデリゲートを作成する。

*await _runner?.Invoke(_args);
デリゲートを実行

*public T0 Arg0 { get; set; }
4個も引数があれば足りるでしょ。


*public static readonly DependencyProperty TextProperty =DependencyProperty.Register("Text", typeof(string), typeof(RichEditEx), new PropertyMetadata(string.Empty, callback));
Using a DependencyProperty as the backing store for TextProperty.  This enables animation, styling, binding, etc...


*Debug.Log(x);
コンソールに1を出力

*,,,
コンソールに"Check is true"を出力


*Buffer.Memcpy((byte*)dmem, (byte*)smem, charCount * 2);
2 used everywhere instead of sizeof(char)

*if (count > 0)
中略
copyToのコピー実態


*public ActionResult Index()*{return View(db.Books.ToList());}
GET: Books

*public ActionResult Details(int? id)*{if (id == null){return new HttpStatusCodeResult(HttpStatusCode.BadRequest);}Book book = db.Books.Find(id);if (book == null){return HttpNotFound();}return View(book);}
GET: Books/Details/5

*public ActionResult Create()*{return View();}
GET: Books/Create

*詳細については、http:go.microsoft.com/fwlink/?LinkId=317598 を参照してください。[HttpPost][ValidateAntiForgeryToken]public ActionResult Create([Bind(Include = "id,Title,Price,ISBN,PublishDate")] Book book){if (ModelState.IsValid){db.Books.Add(book);
過多ポスティング攻撃を防止するには、バインド先とする特定のプロパティを有効にしてください。

*[HttpPost]
詳細については、http:go.microsoft.com/fwlink/?LinkId=317598 を参照してください。

*public ActionResult Edit(int? id)*{if (id == null){return new HttpStatusCodeResult(HttpStatusCode.BadRequest);}Book book = db.Books.Find(id);if (book == null){return HttpNotFound();}return View(book);}
GET: Books/Edit/5

*詳細については、http:go.microsoft.com/fwlink/?LinkId=317598 を参照してください。[HttpPost][ValidateAntiForgeryToken]public ActionResult Edit([Bind(Include = "id,Title,Price,ISBN,PublishDate")] Book book){if (ModelState.IsValid){db.Entry(book).State = EntityState.Modified;
過多ポスティング攻撃を防止するには、バインド先とする特定のプロパティを有効にしてください。

*[HttpPost]
詳細については、http:go.microsoft.com/fwlink/?LinkId=317598 を参照してください。

*public ActionResult Delete(int? id)*{if (id == null){return new HttpStatusCodeResult(HttpStatusCode.BadRequest);}Book book = db.Books.Find(id);if (book == null){return HttpNotFound();}return View(book);}
GET: Books/Delete/5


*ap.showImage(file.Path);
画像表示


*var input = new StreamReader(@"cshp.yaml", Encoding.UTF8);
YAMLのストリームを解析して読み込むとき

*var thema = (YamlScalarNode)mapping.Children[new YamlScalarNode("thema")];*Console.WriteLine("thema\t{0}", thema.Value);
2015-5-28-01

*}
title   .NETプログラミングにピンポイントで役立つテクニックとヒント集
url     http:www.atmarkit.co.jp/ait/subtop/features/dotnet/dotnettips_index.html
title   初めてのＣ＃
url     http:homepage3.nifty.com/midori_no_bike/CS/

*DeserializedObject obj = YamlImporter.Deserialize("cshp.yaml");
C#のクラスにデシリアライズして読み込むとき


*Spawners[waveNumber]();
result: Wave1


*button1.Clicked += delegate
button1はButtonインスタンス

*var content = new ContentPage{Title = "helloxamarin",Content = new StackLayout{VerticalOptions = LayoutOptions.Center,Children = {new Label {HorizontalTextAlignment = TextAlignment.Center,Text = "Welcome to Xamarin Forms!"},label1,button1,}},};
The root page of your application

*button1.Clicked += delegate{label1.TextColor = Color.Aqua;
これ以降でイベントの定義


*w.WriteLine (string.Format ("
CFBundleDisplayName = \"{0}\";", "ほげほげ"));

*File.WriteAllText (projPath, pbxproj.WriteToString ());
設定保存


*csv.Configuration.HasHeaderRecord = false;
Headerはなし


*public bool IsPuaseLoading { get; set; }
Note: Navigation操作に関わるバグへの対処
読み込み中にナビゲーション等によって ListView の LayoutUpdate が阻害されると
IncrementalLoading 処理が呼び出し続けられてしまいます（※未検証）
これを防止するため、Page.NavigationTo/From で IsPuaseLoading をスイッチして対応してください
なおPage.NavigationFromでIncrementalLoadingCollectionをItemsSourceから外すとより確実に読み込みを一時停止できます

*await Task.Delay(500);
多重読み込み防止のため
リスト表示に反映されるまで
タスクの終了を遅延させる必要があります

*IIncrementalSourceの実装で head == 1 の時に強制的にアイテムソースのリストを更新させるよう対応してください_Position = 1;
Note: PullToRefresh等で要素を削除した時のための対応

*_Position = 1;
IIncrementalSourceの実装で head == 1 の時に
強制的にアイテムソースのリストを更新させるよう対応してください


*var targetUri = new Uri("https:
www.gotokyo.orgeventlistjalist");


*"B13EC36903F8BF4701D498261A0802EF63642BC3"
DigiCert High Assurance EV Root CA


