More than 1 year has passed since last update.動的配列(C++でいうvector&lt;T&gt;)を扱う際，C#ではList&lt;T&gt;を使用します．
そこでタイトルにあるように任意の値・要素数で初期化したい時に，C++ではコンストラクタで(要素数)または(要素数，値)と与えることで目的の動作を得ることができます．C#でも同じようなことを行いたいと思って調べたんですが，C++のように単純にはいかないようです．公式リファレンスのList&lt;T&gt;のコンストラクタ部分を見てみます．int型の引数をとっているそれっぽいコンストラクタがあります．
中身を詳しく見てみます．このコンストラクタではCapacityというプロパティを設定しているようです．
Capacityに関してはこの記事がわかりやすいです．要するにCapacityを設定することにより，高速にデータの追加を行うことができます．
ここで注意なのがこのCapacityはそのリストのサイズではないということです(ここでは説明を割愛します)．なので次のようなコードでは，a[i] = 0部分で例外をはいて止まります．コメントに示したようにAddメソッドを使用した場合は正しく動作します．この記事の目標としては，なんらかの方法を用いてListを生成し，以下のプログラムが通るようにしたいです．競プロなどでは，0やINFで埋めた配列に対して何らかの操作を行うことが多いので，デフォルトでこの機能を実装してもらいたいです(この記事で挙げる以外の方法でなにか公式な方法があるんですかね，stackoverflowにも同じような質問をしている人がいました)．ここではいくつかの実装方法を挙げて，後に実行速度を測定したいと思います．aはListのコンストラクタを使用しています．Listのコンストラクタでは，IEnumerableインターフェイスを実装しているクラスを引数に取ることができるので，指定要素数を備えた配列を引数に渡すことでListを生成する事ができます．
bではLINQを使用して配列をListに変換しています．
またnewすることで配列の中身は0に初期化されますが，逆に0以外の値を用いて一気に初期化することができません．LINQのEnumerableクラスでは様々なメソッドが実装されています．
その中のRepeatメソッドを使用することで，指定した値で指定した要素数もつ配列を取得することができます．
それをListのコンストラクタに渡すか，LINQでListに変換することにより，目的の動作を得ます．またEnumerableクラスではRangeメソッドも実装されているので，始点と終点の値を与えることで連続した数列を持つListも生成することが可能です．参考URL:https://docs.microsoft.com/ja-jp/dotnet/api/system.linq.enumerable.range?view=netframework-4.8#System_Linq_Enumerable_Range_System_Int32_System_Int32_こちらの方法はコメントにて@NCT48 さんから教えていただきました．ワンライナーではなくなってしまいますが方法１，方法２より高速な方法になります．
詳細な解説はコメントを参照して下さい．あとで速度測定を行いますが，一番高速な方法です．シンプルにforで要素を追加していきます．
スマートではないです．拡張メソッドやリフレクションを使用する方法をコメントで教えていただきました．
気になる方はコメント欄も参照してみてください．それぞれの方法の速度をBenchmarkDotNetを使用して測定しました．方法１(A,B)では，0以外の値で初期化できないというデメリットはありますが，実行速度だけでみるととても高速に動いています．
方法２(C,D)では，Enumerableクラスのメソッドを使用して一行で配列を生成していますが，Listのコンストラクタの仕様上結局内部でAddを呼び出しているだけ(コメント参照)らしいので，速度はあんまりです．
方法１と方法２より，LINQのToListメソッドを利用するほうがListのコンストラクタに直接渡すより若干ですが速くなりました．
方法３(E)では，AddRangeメソッドを使用することにより方法２より速くなりました．AddRangeメソッドでは内部的にInsertメソッドを呼びだしているらしいです．
方法４(F)ではシンプルな実装で目的の動作を得ることができる上，速度も高速です．通常使う場合は方法４で実装するといいかもしれません．
見た目はアレですが，速度の面で圧倒的に有利ですし，シンプルで見た人がわかりやすいです．
forで逐次的に要素を追加することにより，他の方法のように確保するメモリも節約できると考えられるため，その点も良いです.


