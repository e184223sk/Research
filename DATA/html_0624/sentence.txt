前回の記事で、DiagnosticSourceからEventSourceへ出力する記事 を書いたが、今回は、そのEventSourceのデータを処理するためのライブラリの使い方を書く。これによって、コマンドラインで来たデータを加工したり、あるいはWPFで流す等の処理も書けるようになる。今回調査に使ったソースをgistに貼っておく。前回の記事でも作成したソースを使用する。Microsoft.Diagnostics.NETCore.ClientとMicrosoft.Diagnostics.Tracing.TraceEventが必要。EventPipeプロトコルでdotnetプロセスにアタッチするためのライブラリ。dotnetプロセスが用意するEventPipe読み込みの口へ、PIDをキーにしてアクセスして、データを受け取る。主に使用するクラスは以下(名前空間はMicrosoft.Diagnostics.NETCore.Clientからの相対位置)さて、これだけではEventPipeの生データが取得できるだけで、中身はバイナリデータなので人に読めるものではない(いや、もしかしたら読める人もいるかもしれないが)。
これを解析してくれるライブラリが、Microsoft.Diagnostics.Tracing.TraceEventとなる前述のEventPipeSessionから得たデータを解釈して、プログラム的に解析するためのライブラリ。起点はStreamから読み込むので、先のEventPipeSession.EventStreamをの内容をそのまま出力したファイルを使っても良いEventStreamの解析に使用する場合、主に使用するクラスはMicrosoft.Diagnostics.Tracing.EventPipeEventSourceである。System.IO.Streamをコンストラクタにとる。Streamには、EventPipeSession.EventStreamから得たデータが入っている想定。
データ解析手順には非同期イベントパターン(EAP)を採用しているので、EventPipeEventSourceに付随するイベントを購読する。
また、IObservable&lt;T&gt;を返すインターフェイスも提供している。イベントは、共通のヘッダ部分以外はイベント固有のデータが流れてくるため、そのイベント用の解析クラスを用意する必要がある。
このイベント解析用ベースクラスがTraceEventParserで、解析クラスはこれを継承して各イベントの解析処理を実装している。例えば、CLRのイベント(GCの回収イベントとか)は、専用のパーサーが用意されており、EventPipeEventSource.Clrで専用のイベントが用意されている。なお、汎用的な用途に使えるDynamicTraceEventParserも存在しており、ライブラリ側で用意されていない場合はこちらを使用することになるだろう。そして、一通りのイベント設定が終わったら、EventPipeEventSource.Processで解析を開始する。
注意点として、Processを実行した時点でスレッドがロックされるため、途中キャンセル等をしたい場合は、
別スレッドを展開して、別のスレッドから、EventPipeEventSource.StopProcessingと、元のストリームのクローズ(EventPipeSessionからStreamを取得している場合は、EventPipeSession.Stopを実行する
具体的には以下なお、これを通さないAction&lt;TraceEvent&gt; EventPipeEventSource.AllEventsなるイベントもあるが、これを通すとPayloadNames(イベントデータプロパティの名前)など、主にPayload関連について、セットされないプロパティが出てくる。その場合は、TraceEvent.EventData()でバイトデータを取得して、自力でパースする必要がある。EventPipeEventSource.Dynamic.Allの中では、TraceEvent.PayloadNamesとTraceEvent.PayloadByName(string name)の組み合わせでデータを取得する。具体的には以下のようになる。pobjが何になるか、というところは、プリミティブ型(数値、文字列)ならばそのままキャストすればOK。しかし、それ以外のオブジェクト等がイベント発生元で渡された場合は少々工夫が必要。この場合、実際の型はinternalで隠蔽されているが、取り出す時にはIDictionary&lt;string, object&gt;[]で取り出すことができる([]なことに注意)。
IDictionary&lt;string, object&gt;には二つ要素が格納されており、それぞれのキーはKeyとValueで、値の方にそれぞれプロパティ名と、実際の値が格納されている
具体的には以下のように値を取り出す。より複雑な型の場合はネストして処理が必要になるだろうが、そもそもEventSourceでそこまで複雑なデータは作らない方が良いと思う。
パーサー自体についての詳細なドキュメントは、 githubのmicrosoft/perfviewのドキュメントにある解析コールバックの中で例外をキャッチし損ねると、以後のイベントが流れなくなり、更に、StopProcessingも受け付けなくなった。
なので、現時点ではコールバックの中ではtry-catchで囲った方が良い。少なくともMicrosoft.Diagnostics.Tracing.TraceEvent-2.0.61時点では、一つも該当するイベントが無いようなEventPipeProviderを設定すると、EventPipeEventSourceのコンストラクタで処理が止まってしまうという不具合があるらしい。
詳しい内容は下記issue前回の記事の派生で、EventPipeについて調べてみたけど、取っ掛かりは思ったより簡単だなという感想だった。
ここから、自分なりに使いやすいモニタリングツールを作ってみるのもいいかもしれない。また、EventPipe自体はローカル限定なので、ここから外部ネットワークに流す口を作るというのも面白い発想かもしれない。今回紹介したのはイベントの取得のみだが、その他にもメモリダンプを取ることもできる等、トラブルシューティングに役立つ機能があるので、うまく活用していきたい。


