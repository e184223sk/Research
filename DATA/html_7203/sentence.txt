More than 3 years have passed since last update.エラトステネスの篩 (エラトステネスのふるい)を使った素数を求めるC#のプログラムです。エラトステネスのふるいについては、Wikipediaの こちらをみてください。Primesが素数を求めるメソッドです。2から引数で与えた整数(maxnum)の間の素数を列挙しています。
この引数の値で、内部でふるい用の配列(sieve)の要素数を決定します。戻り値は、IEnumerable&lt;T&gt;です。もう少し、メモリ効率を良くしたバージョンも載せておきます。intの配列ではなくて、boolの配列にしています。コメントのようにBitArray使えば、もっとメモリ効率は良くなります。GitHubでこのソースコードを公開しています。ところで、ここまで書いて思ったんですが、このメソッドは、列挙が始まるのが遅すぎるのが難点ですね。全部の素数が求まらないと列挙が始まりません。
最初のfor文の中で、yield return を書ければ、列挙を開始するのがもっと早くなるはずです。
いくつまでの素数が必要かわからない場合は、列挙開始が速くなれば、トータルの処理時間も短くなる可能性もあります。で、書いたのが次のコードです。うーーん、でも、Math.Sqrt(maxnum) の値までしか列挙開始を早められないから、ほとんどメリット無いかな。
一瞬、良いアイデアと思ったんですが...
もっと突き詰めて考えれば、もう少し実用的なコードになるような気もするのですが、とりあえずこれで止めておきます。もう少し、突き詰めて考えてみました。
良く考えてみると、つまり、整数nで篩を掛け終わった時には、(n+1) * (n+1) - 1 以下の素数が求まっているということです。実質的に、n+1で篩を掛けることができるのは、(n+1)*(n+1)からであり、これより小さい値は、n以下の値ですでに篩を掛けてあるからです。そこで書き換えたのが以下のコードとなります。このコードでは、sieveのtrueとfalseの意味を反対にしています。GitHubでこのコードを公開しています。2つ目のfor文がなくなり、yield returnは、最初のfor文の中に全て移動できた関係で、最初のバージョンから比べると、スムーズに列挙が進むようになりました。それと、「列挙開始を早くする」で示したコードよりも、コードもそれほど複雑にならずに実現できました。とは言え、引数に最大値を指定しないといけないという欠点は残ります。「1000までの素数を求めたい」という要求には答えられますが、「小さい順に1000個の素数を求めたい」という要求には、うまく対応できません。
yone64さんがコメントしてくれたような工夫が必要になりそうです。これについては、時間ができた時に、再度考えてみたいと思います。この記事は、Gushwell's C# Programming Pageで公開したものを加筆・修正したものです。


