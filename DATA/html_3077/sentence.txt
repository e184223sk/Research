AES は共通鍵のアルゴリズムで、他の共通鍵の暗号化方式と比べて強力なようです。
今回は、AESS の暗号化・複号化のライブラリの使い方を理解してみたいと思います。基本的にとても簡単です。 AesManaged というクラスか、AesCryptoServiceProvider というクラスが存在するので、そのクラスを使って、暗号化、復号化を行います。このライブラリを使う上で重要なコンセプトは、暗号化の Key と、IV (Initialization Vector)というパラメータです。この二つを理解する必要があります。Key は暗号化を行うときの共通鍵です。このライブラリのキーサイズを見てみると、256 bit です。AesManaged クラスは、初期化した際に、Key と IV は自動作成されるようです。個別に GenerateKey() というメソッドも用意されています。その中のコードを見てみましょう。想像のとり、ランダムな数字のジェネレーターでバイト配列を作成しています。最終的に internal sealed partial class RandmNumberGeneratorImplementation で実装されているので、外からはうかがい知ることができません。これと似たような実装を外部ですると、次のようになるでしょう。 RNGCryptoServiceProviderはまさにランダムの数字を生成してくれますので、とても良い感じです。GetBytes メソッドで、バイト配列を埋めるところも、結構実装が似ていますね。ちなみに、実装を追っていくと、結局 RandomNumberGeneratorImplementation にたどり着いたので、多分実装は同じですね。私のマシンでは、new byte[16] でないと、256 bit になりませんでしたので、こうしています。IV は (Initialization vector) の略です。リンクをした公式ドキュメントには記述してありますが、ASEのアルゴリズムの初期のトランスフォーメーションの初期値として与えられます。ASEのアルゴリズムで、変換を行っていく過程で、前に変換をした値を使うのですが、１回目の時にはその値がありません。ですので、作成して与える必要があります。これが、IVの概要です。細かいことはよく知りませんが、この記事を理解すると、わかるようになると思います。ほとんど公式にあるサンプルそのままですが、出力がどんな感じになるのか試しています。ライブラリが勝手に暗号化・復号化してくれうるので楽ですね。自分がいろいろ試したコードを含めています。キーを自分でジェネレートした例、ライブラリを使ってジェネレートした例概要はこちらがわかりやすいです。
https://it-trend.jp/encryption/article/64-0070


