More than 1 year has passed since last update.某社のエンジニア様に「大規模開発に参加するにあたって読むべき本はなにか？」という質問をしたところ「現場で役立つシステム設計の原則」と「Java言語で学ぶデザインパターン入門」をおススメされたので読んでみました。読んだだけだと全然実際の運用での肌感覚的なものが理解できなかったので、Unityと絡めてどんな時にどんなデザインパターンが有用なのか考えてみることにします。これを読んでるあなたも考えてね、間違ってるところがあったら教えてください。GoF(Gang of Four)(カッコいいね)と呼ばれる4人のエンジニアが「オブジェクト指向における再利用のためのデザインパターン」の中で言及した、再利用や修正が容易なコードの書き方（依存関係の持たせ方、抽象化の手法）などをまとめたもの。
全部で23パターンあるぞ。少しずつマスターしていこう…23パターンはその特性からに大別されます。今回はを重視してやっていきたいと思います。「集合から次々に要素を抽出する行為」を一般化したものです。
「for文を使って一つ一つの要素を触る」「for文を使って偶数番目の要素を触る」などといった実装をメインのコードや集合自身から分離した部分で定めることができます。
こんな風にインスペクタ上で設定した敵とステータスの書かれたUIが出現するシステムを作ってみます。
まずはMonoBehaviorを継承しない部分のクラスからまずはName、HP、MP、enemyType(形状)のフィールドを持ったEnemyクラスを作ります。次に集合用のインタフェース(Aggregate)とイテレータ用のインターフェース(Iterator)を作り（抽象クラス）、それを使ってEnemyGroupとEnemyGroupIteratorを生成します（具体クラス）。Enemyクラスにgetterがあるのは許して…
次にMonoBehaviorを継承した、Unityに直接かかわるクラスの実装をしていこうと思います。EnemyのListを生成、インスペクタに表示して、それをEnemyGroupに格納した上でwhile文でIteratorを回してEnemyを取得します。（今回は簡単のため格納して取り出すっていう無駄な処理をしています。許して）同じwhile文の中で取得したEnemyの情報からGameObjectを生成します。さらにenemyTagに格納してあったオブジェクトにあるTextMeshを取得して、textに情報を書き込みます。コレでEnemy生成をすることができました。今回はInspectorから値を設定しているのでAggregateとIteratorの良さがいまいちわかりませんね。しかしここから簡単に次のようなことができます。こういった変更が簡単に出来るのがIteratorパターンのうま味です。既成のシステムと要求されるものに微妙なズレがあるとき、規制クラスの外部にそれを補うようなクラスを書いて要求される仕様に合わせるデザインパターンをAdapterと呼びます。既成システムに手を加えず外側で加工するコードを書くので、既成システムのテストなどをやり直さずに済むのでおいしいです。
具体的にはといった状況で、「クラスAを継承した仲介用のクラスA'を作り、クラスA'をインターフェースBに適合するように書こう」というのがAdapterの考え方です。例えば、次のようなEnemy2クラスに加え、爆発物を取り扱うインターフェース、Bombが存在したとします。今までBombインターフェースは爆発物、例えば時限爆弾や毒ガスなどに用いられていたとします。ここで、「ばくだんいわ」、みたいな一定時間で爆発する敵を作りたいと思ったときに、Bombインターフェースを付けられると良いのですが、残念ながらEnemy2クラスにはCoundDownやActivateBombといったメソッドは存在しません。ここでEnemy2クラスに直接これらのメソッドを付与してしまうと、爆発しない敵とする敵の両方がEnemy2クラスに集まってしまい、処理の分岐が面倒になってしまう可能性があります。
こういう時は、Enemy2クラスとBombインターフェースを継承したBombEnemyクラスを新しく作ると良さそうです。こうすることで、Bombインターフェースを用いてオブジェクトとしての爆弾と爆発する敵を同じように処理することができます。
コレがAdapterの考え方です、多分。
では実際に爆破の処理を書いてみましょう。一秒ごとにすべてのオブジェクトを取得してBombインターフェースを持つコンポネントに対してCountDownメソッドを呼び出しています。
これらをエディタ上に配置してみましょう。


実行してみると次のようになります。
これのようにEnemyクラスとBombインターフェースから簡単に爆発する敵を生成することができます。
Adapterの利点として一々書き直す手間を省いたり、新しくコードを書いてテストする手間を省いたり出来るので大変便利。本を読んだだけでは真の理解にはつながってないんだろうな、と思っていたところ案の定いい例を思いつくのに時間がかかりました。いいトレーニングになりそう。23パターンコンプリートしていきたいですね。続きの投稿日時は未定ですが、長い目で見守っていてくれると幸いです。


