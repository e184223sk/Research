More than 1 year has passed since last update.Azure素人の自分がMicrosoft AzureのBot FrameworkとCognitive Serviceと触れ合いながら、難易度も人への接し方も“やさしい”チャットボットを作ってみた際の備忘録の第4部です。どんなチャットボットを作るのかを含め、これまでの手順は第1部、第2部、第3部にございます。
PowerPointで記録していたものをQiita化してみたものになるので、そんな感じの画像が頻出します。
Qiita初心者なので、書き方が下手でも広い心で許してほしいです。そして全体的にゆるいです。以下の5部構成になります。この記事は第4部にあたります。なお、公式ドキュメントに沿って作りましたので、それらのリンクを張り付けつつ、辿った道筋通りに書いていきます。
その筋の方からすると遠回りだったり野暮ったかったりすると思いますが、ご容赦ください。これまで、第1部で作ったチャットボットのソースコードを、第2部でAzure（クラウド）上へデプロイし、ユーザーから受け取ったコメントをAzure Cognitive ServiceのText Analyticsを使って、ネガティブorポジティブの判定をしてみました。今回は、図中の赤枠部分、Text Analyticsの判定結果がネガティブだった場合、Twitterで偉人さんのありがたいお言葉をつぶやく励ましBotさんのつぶやきをランダムに選択し、ユーザーに返してあげる部分を作っていこうと思います。
Twitterの各種APIを使うためには、Developer登録が必要となります。審査に数日かかるようです。
こちらにDeveloper登録について、詳しく書かれているので参考にしてください。
手順中で、Access tokenとaccess token secretが生成されますので、忘れずにメモをしておいてください。後々使います。C#からTwitterAPI を扱うためのライブラリである、CoreTweetのインストールをします。第3部のTextAnalyticsの設定でも実施したパッケージのインストールをします。検索ボックスでCoreTweetと検索して、インストールを実行します。第3部で作成したソースコードを前提に、必要な変更を加えていきます。まずは、ユーザーのメッセージをText Analyticsリソースに投げて分析しているsentimentAnalysisExampleメソッドが、呼び出し元に分析結果のスコアを返すようにコードを変更します。呼び出し側でも戻り値を格納する変数を用意する必要がありますので、OnMessageActivityAsync内でsentimentAnalysisExampleの部分に以下の通り変更を加えます。Debug.WriteLineは値の受け渡しが正常にできているかの確認のための出力です。Text Analyticsでは0~1の間の値を返します。1に近いほどポジティブで、0に近いほどネガティブな判定という意味となります。
今回は、スコアが0.5以上の場合はポジティブとみなして塩対応し、0.5未満の場合はTwitterからありがたいお言葉をとってきたいと思いますので、OnMessageActivityAsync内で条件分岐をし、それぞれの場合でDebug.WriteLineで出力確認をしたいと思います。
今までのOnMessageActivityAsyncに対する変更をまとめると以下の通りとなります。一度実行して試してみましょう。ボットに話しかけたメッセージと、そのスコア（2回）、スコアに応じた対応内容が出力されていればOKです。
ちゃんとスコアを受け取り、条件分岐できていることが確認できたので、いよいよTwitterとの連携部分を作っていきます。事前準備でインストールしたCoreTweetを使うので、以下の通りソースコードの上の方（usingほげほげがあるところ）に追加します。そしてpublic class EchoBotの中のsentimentAnalysisExampleと同じレベル（深さ）に、Twitterからツイートを取ってくるためのgetTweetメソッドを用意します。それぞれ簡単に説明していきます。Random cRandom = new System.Random();
一括でとってきたツイートたちから、どれか1つを選択する際に使う乱数です。var tokens = Tokens.Create()
Twitterに接続する際のトークンです。それぞれ以下の手順で確認して、正しいものを入れていきます。Twitter Developerサイトにアクセスし、画面の右上で、自分のTwitterアカウントより、Appsを選択します。
該当アプリのDetailsボタンをクリックします。
Keys and tokensタブをクリックします。API keyとAPI secret keyが表示されます。Access tokenとaccess token secretについては、事前準備のTwitter Developer登録でメモしておいたものを使います。もしメモし損ねてしまっていたら、Regenerateボタンで再作成してください。
var tweet = "";
取得してきたツイート群から、実際にユーザーに返すものを格納する変数です。var parm = new Dictionary();
取得するツイートの条件を指定するためのDictionaryクラスです。今回は取得してくる全ツイート数（60ツイート）と、取得対象のTwitterアカウントのID（hagemasi1_bot）を指定しています。Dictionaryクラスの公式リファレンスはこちらvar tweets = await tokens.Statuses.UserTimelineAsync(parm);
直前のDictionaryクラスで指定した内容を引数にして、hagemasi1_botのツイートを60ツイート取得してきています。戻り値は取得したツイートたちです。CoreTweetの公式リファレンスはこちらvar random = cRandom.Next(61);
取得した60個のツイートから、何番目のツイートをユーザーに返すか、乱数で決めています。randomには0~60の値のいずれかが入ります。tweet = tweets[random].Text;
取得した60個のツイートのうち、random番目のものを選んで、tweet変数に格納しています。これをユーザーに返します。return tweet;
tweet変数を呼び出し元に返します。Twitterからツイートを取得するメソッドができたので、OnMessageActivityAsync内の条件分岐でDebug.WriteLine($"励まし対応")としていた部分からgetTweetを呼び出して、結果を出力するようにします。ではここでまた、実行してみましょう。できるだけネガティブな発言をボットに投げかけてくださいね。
ネガティブ判定され、Twitterから偉人さんのありがたいお言葉を取得してくることができました！TextAnalyticsの分析スコアが0.5以上だった場合の、塩対応用メソッドgetShioCommentを、OnMessageActivityAsync内、getTweetと同じレベル（深さ）に作っていきます。こちらは特に何かと連携はせずに、コード内に書いたいくつかの塩対応フレーズからランダムに選んで返すだけのものにします。励まし対応の部分と被る要素が多いので、説明は割愛します。呼び出し側も以下の通り変更します。条件分岐の塩対応部分でgetShioCommentメソッドを呼び出し、結果を出力することと、条件分岐外でres変数を定義し、塩対応、励まし対応それぞれの戻り値をres変数に格納する形にしました。それではまたここで実行してみましょう。今度はできるだけポジティブな言葉を投げかけてください。
0.5以上のスコアで塩対応されていれば成功です！ここまできたら、後はもう少しです！今までデバッグとして出力させていたコメントを、ボットからユーザーに発言させるようにします。
まず、せっかくですので、返事に分析スコアもつけるため、score変数（小数点以下2桁まで）とres変数を連結します。Environment.NewLineは間で改行をするために入れています。
いよいよユーザーへの発言ですが、OnMessageActivityAsync内のawait turnContext.SendActivityAsync(MessageFactory.Text(replyText, replyText), cancellationToken);部分で、ボットはオウム返しをしていますので、この部分を以下の通り変更して、塩対応/励まし対応の条件分岐後（返事をres変数に格納した後）に持ってきます。また、オウム返しのテキストを作っているvar replyText = $"Echo: {turnContext.Activity.Text}";は不要になるので、削除します。ここまでの全ソースコードはこちらです。PC上（ローカル）でBot Framework Emulatorを使って十分にテストができたら、Azure上に再度更新版のアプリをデプロイしましょう。
第2部に公式ドキュメントに沿ったデプロイ方法の記載がありますが、ちょっと面倒な手順なので、今回はVisual Studioから直接デプロイしてみます。途中でAzureへのサインインを要求されたら、適宜サインインをお願いします。まず、ソリューションエクスプローラーから、ソリューション名を右クリックし、発行を選択します。
次にデプロイ先のAzureリソースを選んでいきます。今回は第2部で作成したAzureリソースに再デプロイするので、App Servive、既存のものを選択を選んで、プロファイルの作成をクリックします。
続いて、App Serviceの詳細を指定します。サブスクリプションの部分で、デプロイ先のAzureサブスクリプションを選びます。表示部分はリソースグループを選択し、下のボックスでデプロイ対象のリソースグループ、WebAppリソースを選択して、OKをクリックします。
最後に発行をクリックして、デプロイが終わるのを待ちます。
デプロイされたら、第2部 Webチャットでのテストの手順を参考に、テストをします。
ポジティブな発言とネガティブな発言をして、適切な返事が返ってきていれば成功です！以降の工程はこのようになっています。
次回はいよいよ、Azure上にあるボットアプリと、LINE経由でおしゃべりができるようにしてみたいと思います。


