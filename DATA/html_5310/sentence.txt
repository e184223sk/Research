More than 3 years have passed since last update.今回は自分が妄想しているそれっぽいページができるように変更を加えていきます。C#の実験的なBlazor（WebAssembly＋Razor）とSignalRでチャットを作ってみた
* １準備編
* ２実装編
* ３実用っぽいの編（ココこのシリーズはBlazorを主体としてついでにSignalRと考えているためチャットのログの保存は考えていません。
ここからは実用的なものに近づけるべくチャットはホーム（Index）以外で表示するようにします。実はローカルで動いたものの、Azureへ発行すると動かなくなっていたのですが、原因は言語サービスの更新をし忘れてMyGetのパッケージのみ更新してしまっていたことでした。タイミングが悪くて言語サービスの更新通知が来ていなかっただけかもしれませんが、日々の作業の準備としてBlazor言語サービスを最新にし、MyGetのパッケージも最新にしておきます。これは毎日しておいた方が良いかもしれません。
なお、サーバープロジェクトのターゲットフレームワークは「.NET Core 2.1」にしておきます（Blazorのターゲットが現時点で2.1となっていますので、実際に作成する際はその時の最新のBlazorが対応するターゲットのバージョンにしてください）。ソース(GitHub)
動作サンプル
１・２で作成したソースを別ブランチとして残しておき、変更を加えていっています。１・２回目ではチャットは単独ページでしたが、これを各ページ（ソリューション作成時のテンプレで用意されたIndex以外のページです）へ埋め込むように変更します。ファイルをPagesディレクトリからShareディレクトリへ移動します。

次に、ChatをURLから判断して移動するページではなく埋め込みで使用するためのサブページなのでソースの@pageを削除します。また、それに伴いNaviMenuから"/chat"を削除してください。これでChat.schtmlがページからコンポーネント扱いに変わりましたので、Indexを除く他のページに埋め込みます。
図のようにChatのクラス名をタグのように入力すると、途中で入力候補に出てきますので選んでからタグを閉じて""としてください。
今回はパラメータがありませんので指定してませんが、埋め込み元ページからしか受け取れない情報が必要な場合は埋め込みページの方へpublicプロパティを追加してください、そうすればタグにクラス名を入力後、スペースを空けると選択候補にプロパティが表示されますので"プロパティ名=渡したい値"と入力すればできます。今回は不要なのでやりませんが、以下に試したソースを提示します。と、文字列だけでなくオブジェクトも指定できます。さて、現段階で一度動かしてみるとエラーが起きてしまいます。これはChatクラスがPagesからSharedに移動したことにより、JavaScriptからC#メソッド呼び出し時のnamespaceの指定も変える必要があるためです。試しでC#内でthisをポイントすると～.Pages.Chatから～.Shared.Chatに変わっているのが確認できるかと思います。C#側から渡せばいいのですが、今はこのままとしておきます。
IndexからCounterへ移動し、入力して発言ボタンをクリックするとこれで一見正常に動いたように見えますが、Fetch dataへ移動するとエラーが発生しています。

これはJavaScriptでSignalRのconnectionを格納する変数が既にあるのにまた宣言してるよってな意味のエラーになります。今までSignalRを普通に触っていただけなら起きなかったと思われますが、SPAとしたため、メニューからURLが切り替わってもブラウザ上でのページとしては切り替わっていない（サーバーへ読みに行って表示しているわけではないという意味です）ページのインスタンスは変更されておらず、JavaScriptのインスタンスもそのままなのでLetで同じ変数を複数回宣言してるよと怒られたことになります。これがvarならインスタンスが破棄されているのか問題なさそうに動くのですが、connectionが別物に切り替わっているため望んでいた動きとは異なってしまいますのでletでもエラーとならないように修正する必要があります。前述のとおり、ページの切り替えではリロードが起きているわけではないことから、Chat部分の読み込みのたびに初期化が走るのが問題となりますので、外部ファイル化し、index.htmlで１度だけロードする様にに変更します。なお、JavaScriptファイルはwwwrootの下に配置します。すでにsignalrがありますので、自作ファイルとライブラリ／フレームワークとの違いが分かるようにsignalrはjs/libへ、chat.jsはjs直下へ置いています。index.htmlの修正も忘れないようにしてください。上記の通りにしてDOM構築完了に合わせてSignalRのコネクションを開始するようにします。実際にページを何度切り替えても初期ロードのメッセージは１度しか出力されなくなっています。また、切り替え後でも問題なくチャットのはつげんボタンでチャットログが追加されていることが確認できます。ただし、ページを切り替えるとログが消えてしまいますのでちょっと寂しい気がします。ではどうすればログが消えないのかということですが、一つはサーバーでログを保存してそれを読み込むというのがありますが、ページ切り替えのたびにログの読み直しは正直面倒です。特に先ほどのJavaScriptの件でブラウザ上でのページインスタンス（今どきのブラウザはタブ・ウィンドウ毎にプロセスを立ち上げるため、同一プロセスと読み替えた方が良いかもしれません）は同じでBlazorのChatインスタンスは別々ということが分かりましたので、これを利用しますので、別インスタンスでも共通となるとstaticさんの出番です。というわけでとりあえず面倒なので入力と出力の両方をstaticに変更してみます。正直AddMessageが要らない子のようになってしまいましたが、this.StateHasChanged();で再描画の指示を出せるのはインスタンスのみですので、ここだけを利用する形になってしまいました。protectedなのでmyIns.StateHasChanged();で呼び出せませんので、更新メソッドを用意します。これでメニューからページを切り替えてもチャットログも入力欄も消えなくなりました。あといい加減わかりにくいので、入力欄にラベルを張り付けておきます。上が名前で下が発言内容なので分かりやすいようにラベルをつけておいてください。SignalRにはグループ機能があります。で、各ページの下にチャットを埋め込むようにしたので折角だからページごとのグループを作って同じページを閲覧している人同士でチャットできるようにしてみようと思います。ページごとのグループにするならページのURLをグループ名にすれば確実かと思いましたのでURLを取得することにします。サンプルにはなかったのでBlazorのソースを適当にそれっぽいところを重点的にみているとMicrosoft.AspNetCore.Blazor.Browser.Services.BrowserUriHelperクラスにGetAbsoluteUriというメソッドで取得できることが分かりました。取得したURLを元に"/counter"のようなメニューで指定するURLへ変換するためにUriクラスを使用します。なお、"/"の場合は後ろにIndexをつける処理を追加しています。また、Groupをサーバーへ送信するためにSimpleMessageクラスへプロパティを追加します。後はグループ追加と離脱の処理をServerとJavaScriptに加えるとひとまずはそれっぽくグループ機能が動くかと思います。
ただ、問題なのがページの表示タイミングはOnInitで拾えますが、ページから離脱するイベントは取得できません。JavaScriptにならあるのですが仕方がないのでOnInit内でstaticにしたMsg.roomから初期表示なのかページ切り替えなのかを判断してグループの離脱・追加を行うようにします。JavaScript側の方はBlazor.registerFunctionで登録している以外は通常のSignalRと変わりませんので省略します。また、サーバーサイドも同様に省略します。
これでページごとのグループでのチャットができるようになりました。グループ関係なしで発信できるようにサンプルではSharedの方へ定数を定義し、C#クライアントで送信メッセージのインスタンスを複製し、roomの値に定数を使用し、サーバーサイドで同じ定数で判断するようにしています。これも設定した定数を変更する必要が出た際にはSharedの値を変更するだけでクライアントサイドもサーバーサイドも同時に変更できるのがBlazorのメリットと言えますね。チャット部分に関しては実用品とするにはまだまだ手を入れる部分がありますが、だいぶんそれっぽい形になったと思います。これ以上のところはもうBlazor要素がなくなりそうですし、そもそも設計方針やどんな機能を実装したいかにもよる部分がありますのでご自身で色々試すなりASP.NET CoreのSiganlRでググるなりすれば解決するかと思います。
今回僕自身が思ったことは、VSの通知に出ていなくてもソースをいじる前にツールの「拡張機能と更新プログラム」でBlazorの言語サービスの更新を行っておくことと、MyGet(NuGetのパッケージ管理)も最新にしておくこと、それとオープンソースなのでこんな機能があると思うけどどうすればいいのか？と思ったらとりあえずソースを落としてVSで開いてみることが重要かと思いました。ちなみにVSで開く理由は自分で使用する際にnamespaceが分からないと困るのでVSで開いてポイントすれば表示してくれるという理由です。またそのクラスの定義へ移動できるのもメリットです。
それではこの後は肝心なコンテンツ部分がテンプレそのままでしたのでしばらくは主に画面サイドの機能をいろいろと調べていこうと思いますので、それなりに記事に起こせるような情報がたまったらその４を書こうかと思います。


