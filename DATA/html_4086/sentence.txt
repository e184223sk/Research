More than 1 year has passed since last update.このようなインクリメントを後置くインクリメントと言います。
for文を使う場合このようなインクリメントを前置インクリメントと言います。for文を使う場合後置インクリメントだと内部でインスタンスの生成が発生するので、ちょっと処理に時間がかかるようです。ただ現在ではコンパイラの発達により、どちらでもほとんどが出ないことが多いです「ビット演算した方が速い」と一般的によく言われるが、実際どのような場合にビット演算を使うのかピンとこない場合が多いと思います。そんなとき最もよく使いやすいケースが上記の2倍のケースではないだろうか?
ただし、初見では???となることが多い(可読性が下がる)ので使い所は考えた方がいいかもしれません。※ 右シフト(num &gt;&gt; 1, 半分, 1/2)は符号付き(負の値)での計算において、 num / 2 と num &gt;&gt; 1 で実行結果が変わることがあります。C#やJavaなどのList(C++だとVector)にあたるような可変長配列を用いる場合、その配列の中に値が存在するかどうか判定する処理を書くと以下のような処理と同等の処理が行われます。例えば、このListの中にデータが10000件ある場合、最大10000回のチェックをすることになります。(このような処理を線形探索といいます)
HashSetやDictionary(JavaではHashMapなど)を用いた場合、１回の処理で、該当の値を取得することができます。そのため判定も1回だけになるので速度が速くなります。(このような処理をハッシュ探索といいます。詳しくは参考などをご覧下さい。よく使われるRailsで行う場合SQLでORDER BY文を発行するとたとえLIMIT 1であっても、件数が増えれば処理が遅くなります。(基本的にソート処理は重たい)
MySQLにはINFORMATION_SCHEMAというテーブル情報など、MySQL内において各種定義値などのメタ情報を記録しているテーブルがデフォルトで存在します。このINFORMATION_SCHEMAテーブルからは読み込みのみ可能で、SELECT文を用いることで値を取得することができます。INFORMATION_SCHEMAのテーブルの情報にはそのテーブルの件数(TABLE_ROWS)や末尾の情報(AUTO_INCREMENT)の情報も記録されています。そこで、このテーブルから情報を取得することで高速に実行することができます。
※ ただし注意点もあることも忘れずに。他にもちょっと書き方を変えるだけで速度が改善できるようんケースがあれば追記していきたいと思います。


