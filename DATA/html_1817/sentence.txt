More than 1 year has passed since last update.ある程度の文法のVue.js/Blazor/Angularにおいて同様の動作を実現するための方法についてまとめました。分離元
VueVsBlazorにソースコードをまとめています。ちなみにVue.jsではTypeScriptを採用しています。Vue.js Sample
Blazor Sample
Angular Sampleここでのサンプルは全てルーター上の1ページとして表現しています。
土台となるルーターの実装例から順に比較していきます。コンポーネントの内容はただのhtmlから可能です。templateタグで囲みます。
1つのブロックのみとする必要があります。特別考慮する点はありません。
書いた分だけhtmlとして動きます。
通常、scriptタグは使用できません。TypeScript内にhtmlをテンプレートとして挿入します。
htmlやcssはファイルを分ける方が主流のようですが、ここでは同一ファイルとして扱います。styleタグで囲むことでスタイルを記述できます。
style scopedを使うことでコンポーネント内に「スコープ」を作ることができます。CSSに関するBlazor特有の仕組みはありません。
諦めてbodyにstyleタグを置いています。
まぁ、大体のブラウザでは動きます。
html的には良いのか悪いのかわかりませんが。htmlの中にstyleを記述することが認められています。
ここでは示しませんが別ファイルからインポートすることも可能です。コードブロックで定義している変数はhtml内に埋め込むことができます。
(Vue.js/Angularは{{hoge}}(thisは常に付加される)、C#は@hogeで呼び出し)scriptタグ内(TypeScriptを使う場合はlang=ts要)に記述します。@codeブロック内にスクリプト処理を記述します。そもそもTypeScriptベースなので特筆よることはあまり無いでしょうか。
○○.component.tsのクラス内に処理を記述します。html中に埋め込めるのは変数のみではありません。
数式を埋め込むこともできます。{{}}内ではグローバルオブジェクトを扱えないことについて注意します。@のエスケープは@@と記述します。Vue.jsと同様に{{}}内でグローバルオブジェクトを扱うことはできません。Vue.js/Blazor/Angularにはhtmlのonload/unonloadのように
コンポーネントの状態でフックされるライフサイクルメソッドというものがあります。Vue.jsのライフサイクル
Blazorのライフサイクル
Angularのライフサイクル初期化処理は大体レンダリング後に該当する処理で間に合う気がします。
Blazorはデストラクタがページ更新時に動作しないので注意が必要です。
(その場合、現状としてはjsのunonloadをなんとか使うしかない?)言語にJavaScript/TypeScriptを選択しているフレームワークでは
ブラウザ依存のDOM APIをそのまま使用することができます。BlazorではJavaScriptに頼らずDOM APIを扱うことは不可能なので
JavaScriptのメソッドを呼び出す必要があります。JavaScriptを使うにはIJSRuntimeをinjectして
IJSRuntime.InvoveAsync・IJSRuntime.InvokeVoidAsyncメソッドを呼び出します。プロパティの類には一切取得できないのでその用途にはevalを使うか
別にjsファイルを用意して関数として呼び出す必要があります。Vue.js/Blazor/Angularではdocument.element.valueを直接操作する代わりに変数と要素の値をバインド(同期)します。v-model属性を使用します。@bind属性を使用します。
テキストの更新にリアルタイム性を求める場合は@bind-value/@bind-value:event属性を使用します(第20項参照)。[(ngModel)]属性を使用します。
[]はスクリプト処理によって値が変更され、
()は人為的な操作により値に変更を与えられることを示します。変数からdocument.element.valueを一方的に更新することもできます。v-bind:valueを属性に指定します。
v-bind:はスクリプト処理によって値が変更されることを示します。
v-bind:は:のように省略することができるので:valueと書けます。valueへ直接@で変数として割り当てることができます。[ngModel]属性を使用します。
前項の[(ngModel)]から()(人為的な変更)を外したものとなります。イベントハンドラはそれぞれちょいちょい表記が異なるので通常のhtmlについても併記します。
Vue.js/Blazorでは指定するものはメソッド名のみでメソッド呼び出しを意味する"()"は不要です。onclick属性の代わりにv-on:click属性を使用します。
v-on:は人為的な操作により値に変更を与えられることを示します。
v-on:は@と表記することもできるので@clickと書くことが出ます。通常のイベント名に@を付けたものがイベント属性となります。
つまりこの例では@onclick属性です。onclick属性の代わりに(click)属性を使用します。Vue.js/Angularでは@chenge/(change)イベントとv-model/[(ngModel)]を同時に使うことができますが、
Blazorでは@onchangeイベントと@bindを同時に使うことはできません。Changeイベントは双方向バインディングの操作で内部的に使用されているため、
プロパティ(get/set)を咬ませることでイベントの発火を受け取ることができます。スクリプトによるスタイルの変更はhtmlではdocument.element.styleの変更によって行われていました。
Vue.js/Blazor/Angularではその代わり属性に直接値をバインドさせることで変更を行います。v-bind:style属性にJSON形式の文字列で渡します。
変更したいスタイルのキーに対してスタイルの文字列を返す処理を書き込むか
スタイルの含まれる文字列変数を割り当てます。style属性に渡す文字列を変更することでスタイルの変更を行います。
(CSSそのものの書式で文字列として与える必要があります)[style.○○]属性に渡す文字列を変更することでスタイルの変更を行います。
○○には変更したスタイルを記述します。クラスについてもスタイルと同様にバインドできます。v-bind:class属性にJSON形式の文字列で渡します。
変更したいクラス名のキーに対してboolean値を割り当てて行います。スタイルの変更と同様にclass属性に渡す文字列を直接編集します。[class.○○]属性にboolean値を割り当てて適用/不適用を切り替えます。
○○には対応するクラス名を記述します。Vue.js/Blazor/Angularでは場合分けで表示状態を変更できます。v-if属性を対象の要素に含めると表示状態を変更できます。
v-ifで表示の切り替えを行うとライフサイクルが働くこととなります。
コンポーネントの状態を保ったまま表示切替を行いたい場合はv-showを使います。
(内部的にdisplay: none;を使っています)@ifを使います。
動作としてはVue.jsにおけるv-ifと同様です。
コンポーネントの状態を保つ場合はstyle/class属性で直接隠すようにします。*ngIf属性を使用します。
コンポーネントの状態を保って非表示にする場合は[style.display]属性に"none"を与えます。Vue.js/Blazor/Angularでは同じ構成のタグであれば繰り返して表示させることができます。ループで生成されるリストにはコンポーネントの同一性などを担保するためにkey属性の追加が推奨されます。
(Blazorでは推奨されてない?)
動作が高速になるとも言われます。
v-bind:keyはVue.js、@keyはBlazorにおける表記方法です。
Vue.js
Blazorv-for属性を繰り返したい要素に含めます。
これはtemplateタグを無名のタグとして使い、囲んでループさせても問題ありません。
大体の主流なブラウザではオブジェクトの順序は一定となりますが、仕様上で保障されていないので注意してください。
(Mapも一応使えますが情報量が少なくて少し怪しいです。
書き方はv-for="[key,value] of list]"と通常のfor文っぽく書くと使えるようです)@for/@foreachを使います。*ngFor属性を繰り返したい要素に含めます。
Vue.jsのtemplateと同様にng-containerを~要素として使用できます。Vue.js/Blazor/Angularではhtmlタグ中に自作の要素(コンポーネント)を埋め込むことをできます。
Blazorでは自動で全てのコンポーネントを読み込みますが、
Vue.jsではimport文で読み込むコンポーネントを指定する必要があります。
Angularではapp.modile.tsに記載します。Vue.js/Blazor/Angularでは子コンポーネントに属性を与え、
与えられた子コンポーネント中でプロパティとして使用することができます。
Vue.jsでは@Prop、Blazorでは[Parameter]、Angularでは@Inputで属性名を指定します。Vue.js/Blazor/Angularでは子コンポーネント中のメンバーを呼び出すことができます。ref属性でバインドする変数名を指定します。
クラス中でも使用するために宣言が必要です。@ref属性でバインドする変数名を指定します。
クラス中でも使用するために宣言が必要です。コンポーネントをインポートし、クラス内で@ViewChildデコレータを割り当てることで使用します。どのコンポーネントからでも参照できるグローバル変数のようなもの。
ここでは変数の読み書き程度の極々簡単のみ行っています。Vue.jsでは公式なライブラリとしてVuexが存在します。
Blazorでは特にそのようなものは存在しませんが、Blazorの基本機能のみで同じようにコンテナを扱う方法が存在します。
参考1 参考2
Angularではサービスをコンテナとして使用することができます。詳細については割愛し、動作例のみ記載します。Program.csにサービスとしてコンテナを登録する必要があります。Vue.js/Blazor/AngularではJSONファイルを読み込んで表示することができます。
(クライアントサイドなので書き込みはできません)ここでは次のJSONファイルを読み込みします。require関数を使用し、JSONファイルを/src/assets/以下に配置します。HttpClient.GetJsonAsyncを使用し、JSONファイルを/wwwroot/以下に配置します。HttpClientモジュールのgetメソッドを使用します。
使用するにはadd.module.tsにサービスを追加する必要があります。
JSONファイルの配置パスは/src/assets/以下とする必要があります。Vue.jsのみではプレーンなテキストファイルを読み込むことはできません。
読み込む方法としてVue.jsの公式でaxiosを使うことを提案しています。
プロジェクトにはyarnやnpmで追加が可能です。また、この方法でもJSONを読み込めますが、少々ファイルの扱いが異なるので注意が必要です。JSONと同様にHttpClient.GetStringAsyncを用いて読み込みます。JSONと同様にHttpClient.getを使用できます。
テキストファイルを読み込むには引数に{responseType:"text"}を加える必要があります。Vue.js/Blazor/Angularではhtmlにおけるelement.innerHTMLと同様にHTMLを書き出すことができます。v-html属性に値をバインドさせます。
script要素は使用できません。文字列をMarkupString型にキャストして任意の場所に書き出すことでHTMLを出力できます。
script要素は使用できません。[innerHTML]属性に値をバインドさせます。
script要素に加えてstyle要素も使用できません。最後に今回使ったルーターの例を示します。/src/router.index.tsをページが増えるたびに追加する必要があります。/src/app/app-routing.module.tsをページが増えるたびに追加する必要があります。以上、Vue.jsとBlazor(+Angular)の文法の比較についてまとめてみました。
styleの仕様など、どうにもならない部分はありますが、大部分はほぼ同じように書けるのではないかと思います。
まだ、速度の面で苦しいなぁと感じていますが今後のBlazorに期待したいと思います。


