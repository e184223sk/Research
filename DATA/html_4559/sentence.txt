More than 1 year has passed since last update.システムにおいて必ずといっていいほど存在するエラーコード。
このエラーコードってプロジェクトによってさまざまな形式だったりします。
そんなエラーコードとそのハンドリングで比較的上手くいっているパターンについてご紹介します。具体的には列挙体を使ったエラーハンドリングです。ソフトウェアやハードウェア、およそコンピュータに関わっていれば必ずといっていいほど目にするエラーコード。
皆さんが作っているシステム、日々携わっているシステム、それらのエラーコードってどのようなものでしょうか。
より具体的に言えばどんな型のエラーコードを取り扱っていますか？例えば数字です。
80011
こんなエラーコードがあるでしょう。例えば文字列です。
'E1000'
こういったエラーコードもあるでしょう。色々なエラーコードが存在する世の中で今挙げたエラーコードを取り扱っている方もいれば、全く違うエラーコードの場合もあるでしょう。そんなエラーコードですが私はプログラム中では必ず列挙体を使うようにしています。
というわけで今回はエラーコードを列挙体にするというお話です。エラーコードを列挙体で表現するメリットは何でしょうか。物事のメリットを考える時、比較をすることでそれのメリットが浮き彫りになることはあると思います。
前述の文字列や数字のエラーコードと比較をしていきましょう。まずは次のエラーコードをご覧ください。404このエラーコードは何を意味するのでしょうか。
もしかしたら「見つからなかった」という意図を受け取ることができた人がいるかもしれません。
人によってその解釈はあいまいになると思います。では同じエラーを列挙体で表すとどうでしょうか。UpdateUserError.UserNotFound印象がだいぶ変わって見えますね。数字や文字列をエラーコードにした場合、ある種の暗号を扱うことと同義です。
これらをエラーコードにしてしまうとそれだけで解読するのは難しくなってしまいます。プログラムでマジックナンバーを避けるのと同様、可能であれば避けたいところです。列挙体を利用すると、エラーコードそのものに意味がわかるように名前をつけることができるのでこの問題が解決されます。エラーコードを見るだけでそれが何のエラーかわかる。
とても素敵なことですね。一意性とは意味や値が一つに確定しているという性質です。
これも列挙体のメリットです。例えばユースケースは異なるけれど、とても似通ったエラーは存在します。数字や文字列でエラーコードを表現した場合、意図せずして同じエラーコードになってしまうことがあります。
特に先ほどの 404 などは典型で、ユースケース毎に担当者が異なった場合に、今回の「見つからなかった」に着目すると、結果として次のようなコード対応表になってしまうことがあります。数字や文字列等のある種暗号めいたものをエラーコードにした場合、エラーコードが重複することがあります。
そのエラーコードが何を表しているのかはコンテキスト（文脈）を確認しないと判別できません。"更新処理の"、"削除処理の" それぞれがコンテキストです。列挙体はこのコンテキストを型の名前や実際の値の名前で表すことができます。「ユーザが見つからない」というエラーですが、それぞれユースケースが異なるのがわかります。また 404 という数字を検索して、そのエラーコードを発生させた箇所を探すのはうんざりするような検索処理です。
検索結果に出てくるのがエラーコードだけであればよいですが、たまたま全く同じ数値がコード上に存在していたりすると、付近のコードを見て判断するしかなかったりします。列挙体であれば参照されているところを検索すれば OK です。コードを見るだけでそれがどこで起きたエラーかわかる。
とても素敵なことですね。エラーコードを数字や文字列で管理する場合にこんな表で管理することがあったりします。
エラーコード単体では意味がわからないので、エラーが発生するたびにコードとこの対応表とを見比べることになります。さて「ユーザを更新しようとしたがユーザ名重複により失敗した」というエラーを追加しようしてみましょう。
現在のコードに文末に追加する形になると思います。こうなると、作成処理、更新処理、削除処理とエラーコードが入り乱れることになります。
なるべくなら処理ごとに分けて俯瞰できるように管理しておきたいものですね。管理できるようにするのであれば、例えば次のようなコード体系にすれば追加削除も容易でしょうか。このコード群に「更新用のユーザ名が重複している」エラーを追加するとこんな感じです。作成処理は 5000 番台、更新処理は 5001 番台、削除処理は 5002 番台と整理されています。
エラーが発生する際にエラーコードとその意味を突き合わせをする必要は発生しますが、上手く管理されているエラーコードではないでしょうか。　　　　:
　　　　:
　　　　:さて、列挙体の場合は次のようになります。もはや対応表は不要でしょう。
Excel を使う理由が一つ減りました。先ほど例に挙げた更新処理に重複エラーを追加すると次のようになります。エラー内容の追加に備えたコード体系を考える必要もなくなります。コードがあれば対応表が要らない。
とても素敵なことですね。列挙体をエラーコードにすると以下のメリットがあります。いかがでしょうか。
少し興味が沸いたでしょうか。
興味が沸いたならここから先のエラーコードを列挙体にしたときの実装をご覧になるとよいでしょう。いよいよ実装をしていきます。
ここまでで決まった基本方針はエラーコードを極力列挙体にすることだけです。勿論エラーというものにはエラーコード以外にもいくつも考えなくてはいけない事柄があります。
まずはエラーコードを列挙体にしてみて、その過程でエラーコード以外の要素に触れながら組み立てていきましょう。エラーコードの発行自体はほとんどいままでと変わりません。
文字列や数字で表現していたエラーコードを列挙体で表すようにするだけです。あまり面白みはないので、列挙体にしたことで大きく変更する余地のあるエラーハンドリングを見てみましょう。エラーは種々様々なものが存在しますが、その取扱い方は比較的単純なパターンに収まることが多いです。
具体例を挙げるなら「エラーコードに対応したメッセージを表示する」というパターンは代表的なハンドリングです。パターン化できるということは「なんとかして」共通化をすれば毎回似たような処理を書いたり、あるいはコピペをするといったことをしなくて済みそうです。
今回はユーザ更新というユースケースをモデルにして処理の共通化を図っていきます。まずはユーザ更新のレスポンスとそのエラーコードを定義してみます。このクラスを使ってエラーからメッセージを表示するスクリプトは次のようになります。ユーザ更新についてはこの程度よいでしょう。
次は「ユーザ削除」のハンドリングをご覧ください。非常に似通ったコードになります。この重複はどのユースケースでも必ず起きる重複です。
つまり必然的な重複です。共通化すべきものです。
この部分の共通化を目指します。共通化をする場合、目標を定めるのはとてもよいプラクティスかと思います。
今回はこんなコードを目標とします。なかなかシンプルで良い目標に思えます。この共通化のための第一歩はレスポンスにスーパークラスを用意することでしょう。ErrorContainer というコンテナクラスにエラーコードを含めるようにしているのは、エラーによってはそのエラーが起きた原因をメッセージに表示する必要があるケースに対処するためです（後述）。
このResponseをすべてのレスポンスオブジェクトが継承すれば、少なくともresponse.HasError()までは動きそうです。そうなると次はresponse.ToErrorMessage()の部分への実装方法が気になりますね。
どうやって実現すべきでしょうか。まずはResponseのメソッドとして用意してみましょう。これは大きな問題を抱えたコードです。
スーパークラスがサブクラスの知識を持ってしまうというのがそれですね。
サブクラスの知識とはTErrorCodeにUserUpdateErrorという型が指定されるという「知識」です。例えばエラーコードを追加したとしましょう。
そのたびにResponseにはエラーコードに対応したメッセージを追加する変更を行う必要があります。例えばUserGetResponseクラスを追加したとしましょう。
そのたびにResponseは新たなクラスが利用するエラーコード用のメッセージを追加する変更を行う必要があります。これは非常に手間ですし、ともすれば定義をし忘れます。
またコードに変更がある以上Responseクラスがデグレする危険に晒されます。また細かい点ですが(UserUpdateError) (object) codeというキャストでオートボクシングとアンボクシングが発生するのも少し気になるところです。一体どのようにすれば納得感のあるToErrorMessageを実現できるのでしょうか。そもそもエラーメッセージはどこに定義するべきでしょうか。エラーメッセージはエラーコードに密接な関係性を持っているので、なるべくならエラーコードと一緒に定義しておきたいものです。
特にプロジェクトが一つでエラーコードが同一バイナリであれば尚更です。enum にはフィールドを定義できませんがアトリビュートやアノテーションを利用するという手段であればこれを実現できます。これは非常に管理がしやすいです。
メッセージを変えたいといった要望にも気軽に答えることができます。
（多言語化をする場合はメッセージ ID を定義することになります）アトリビュートを利用した場合のResponseは次のような実装になります。少し込み入った処理が記述されていますが、型からアトリビュートを取り出してそこに設定されたメッセージを表示しているだけです。
この段階で以下のスクリプトが実現できています。プレゼンテーションのロジックがだいぶすっきりしてきました。ところでResponseはそもそもレイヤーを超えてデータを渡すための DTO のようなものでした。
その目的は「データを渡すため」です。データを渡すためのオブジェクトに、プレゼンテーションのためにメッセージを準備するメソッドを定義すべきでしょうか。メッセージはプレゼンテーションのためのものです。
プレゼンテーションのためのものはプレゼンテーション層のモジュールとして用意すべきでしょう。プレゼンテーション層のモジュールとして用意する場合は次のようなヘルパークラスを用意します。これを利用すればすべてのレスポンスのエラーメッセージ簡単なコードで取得することができます。しかし目標としていたresponse.ToErrorMessage()という記述の表現力は魅力的です。表現力以外にも、インテリセンスを利かせるだけでエラーメッセージを取得するメソッドを呼び出せるというのも魅力です。
Helperの名前が何であったかを思い出す必要がなくなります。こういった場合には拡張メソッドを利用するのがよいでしょう。
修正は先ほどのヘルパークラスの名前を変えて少し変更を加えるだけです。ところで今のエラーメッセージのモジュールは複数のエラーが出現したときに常に改行コードでエラーメッセージ同士を結合してしまいます。
Console に表示するときはとても使いやすいですが、Web 用のメッセージの場合改行は改行コードではなく '&lt;br&gt;' で結合されていた方が都合がよい場合もあるでしょう。
もし今のまま '&lt;br&gt;' で結合したい場合は改行コードを置換する必要があります。一度出来上がったメッセージを再度編集するのは処理的に少し無駄があります。
可能であれば編集も同時にこなしてメッセージを作りたいところです。これを実現するにはまず拡張メソッドを次のようなコードに改変します。MessageProvider 関連のコードは次の通りです。最後は MessageFormatter です。もし '&lt;br&gt;' で結合したメッセージが欲しい場合は次のような Formetter を用意して引数に渡しましょう。　ところで ErrorContainer には Item というプロパティがあります。
これは入力値をエラーメッセージに組み込ませたい場合等に使います。
例）「'taro@'というユーザ名には利用できない文字が利用されています」というエラーメッセージ今のコードであれば次のようにすれば置換することができます。より親切なメッセージになりますね。場合によっては特定のエラーコードだけ処理を変えたいこともあると思います。
そういった場合にはErrorsフィールドを見ることで処理を分岐できます。クリティカルな部分で、きめ細かくユーザさんをフォローしたいときにはこういった処理を書いてあげるとよいでしょう。今回のように列挙体をエラーコードにするとユースケース毎で「何のエラーが起こりうるのか」といった仕様がコード上に見えてきます。
これはビジネスロジックの単体テストを行う上での重要な指針となります（少なくともすべての列挙体のエラーが出るようにする）。またエラーコードからそれが発生している具体的なコードの箇所も、列挙体が利用されているところを検索すればよいので容易かつ高速です。
対応表とにらめっこする必要がないので目に優しいですし、暗号のようなコードを覚える必要もないので脳にも優しいです。もし API を叩いて戻ってくるエラーコードが数字や文字列だったとしても、それを受け取った直後に列挙体に変換するとよいでしょう。
それをするだけの価値はあると思います。エラー設計はシステムのクオリティです。必要に応じて細かくハンドリングが行えるエラー設計は、ユーザーに優しいシステムです。
エラーコードからそのエラー発生個所がわかるエラー設計は、保守に優しいシステムです。
可能な限りパターン化してすべてのハンドリングが不要なエラー設計は、開発に優しいシステムです。エラー設計を最大の課題として、優しいシステムを作っていきましょう。記事にでてきたコードです。
ロジックについては手抜きですが、Sample プロジェクトを実行して動きを確かめることはできると思います。
https://github.com/nrslib/CompetentResponse


