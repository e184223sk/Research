More than 1 year has passed since last update.提供されたDLLが方やx64、方やx86指定でないと使えないものを1つのアプリケーションで使う必要にかられました。今まで自分ではアーキテクチャ依存のコードはほとんど書いたことがないため、意外とこういった状況は経験がありませんでした。とりあえず一つのプロセスではx64とx86は共存できません。さてどうしたものか。プロセス間通信の手段として思いつくのは、この辺は割とすぐに思いつくものの、お互いがお互いを知らないといけないと言うなるべく避けたい構成。.Netリモーティングなるものもあるらしい
C# プロセス間通信（IPC）割と新しい記事ではWCFを勧められている記事が多め？
そもそも記事数が少ないのでイバラの道の予感しかありませんが。色々と大変だったので備忘録。WCFサービスライブラリでx86DLLをラップしたサービスライブラリを作ってみる、
x64でサービス参照を追加。
WCFサービスをx86指定でビルドして通信！と思ったらデバッグ開始時点で落ちます。
どうやらWCFサービスのホストが64bitマシンでは標準でx64が選択されるようでそこで落ちてしまう様です。指定するのにVSコマンドプロンプトでコマンド打って・・・みたいなのもありましたが、アプリ配布時に面倒な環境設定が必要になるかも？な予感。
x86DLLを本体側でx64DLLをWCFと言う手段もなくはないですが、アプリ内での使用頻度と遅延を思うと、x64DLLを本体側に配置したい。ということで勉強がてらホスト部分を自作してみることにしました。主に以下のプロジェクトを用意しました。WPFアプリとWCFサービスアプリでお互いにインターフェースを参照しておくことでデータの型などが制限できます。注意点として無くてもいいですが目的の形に近づけるためにx86DLLを作りました。テンプレートは「空のプロジェクト」を選びました。
出力タイプはクラスライブラリに設定。System.ServiceModelを参照に追加。
今回は適当な文字列を返すメソッドのを定義してみます。テンプレートは「コンソールアプリ」を選択。
System.ServiceModelを参照に追加。
WCFサービスのコントラクトプロジェクトを参照に追加。実験のためにx86指定のDLLを参照。
プロジェクト自体もx86指定に。サービス実装クラスを記述。コンソールアプリのProgram.Mainでサービスをホストする。App.configでサービスの設定を追記
使いたいDLLは古－－－－－－－いものだったので、地味にuseLegacyV2RuntimeActivationPolicy="trur"が無いと動かなったです。
多分今時X86DLLを使わなければならない様なものは同じ躓きがあるかも知れません。サービス起動時に管理者権限が必要でした・・・。
新しい項目の追加でapp.manifestを追加しコメントに従って変更します。Httpバインディングでは管理者権限が必要ですが、Net.TCPバインディングなら管理者権限は不要でした。とりあえず空のWPFを作りました。
本題ではないのでMainWindow.xaml.csにWCFサービスのプロセス管理とサービスへのアクセスを記述しました。Loadedイベントで呼び出している部分でサービスのメソッドを呼んでます。起動したらコンソールに無事文字が出ました。これで何とかなりました。WCFHostWPFAppTest


