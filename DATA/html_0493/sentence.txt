フィールドにreadonly修飾子を付けて宣言すると、フィールド初期化子もしくはコンストラクタでしか値を代入できなくなるため、不用意に値を変更される心配がなくなって非常に安心できます。ところがUnityでは（というかMonoBehaviourなクラスでは）、コンストラクタを定義できないため、readonlyなフィールドを初期化することができないのです。
これではいつどこで値が書き換えられるか不安で夜も眠れません。別にフィールド初期化子で初期化すればいいじゃんと思うかもしれませんが、Startメソッド内で初期化したいシチュエーションは結構あります。
例えば、次のようにSerializeFieldで受け取った値を元にして別のクラスを作るような場合などが挙げられます。SerializeFieldで受け取った値を元にしてDictionaryを作っているので、フィールド初期化子で値を初期化できません。
このような場合、どうしてもStart内で初期化する必要が出てきます。しかし、かといってreadonlyをやめてしまえば、いつかの自分もしくは別の誰かが手が滑ってnullを代入してしまう可能性が残ってしまい、夜も眠れなくなります。そこで、どうにかしてMonoBehaviourなクラスでreadonlyを実現する方法を考えました。通常の方法ではMonoBehaviourでreadonlyを使用できないので、同等の機能を実現するUniReadOnly&lt;T&gt;クラスを作りました。
このクラスは以下の特徴を持ちます。1回のみ初期化可能で、あとは読み取り専用として機能するので、readonlyの代わりとして利用できます。実装は次の通りです。
そのままコピペするだけで使えます。使い方は簡単です。以下のように使用します。具体的な使用例は以下のようになります。
※処理内容についてのツッコミは勘弁してくださいStartメソッド内でInitializeメソッドを呼び出し、読み取り専用にする値を設定しています。
これ以降に再びInitializeメソッドを呼び出すと、自作例外クラスであるAlreadyInitializedExceptionがスローされるため、値が書き換わらないことが保証されます。さらに、UniReadOnly&lt;T&gt;のインスタンス自体はフィールド初期化子でインスタンス化してしまえば良いので、readonly修飾子を付けることができます。
そのため、UniReadOnly&lt;T&gt;インスタンス自体を書き換えられる心配もなく、Initializeメソッドで設定したTインスタンスの不変性1がしっかりと担保されます。以上から、UniReadOnly&lt;T&gt;クラスを使用することで、MonoBehaviourなクラスでもreadonly修飾子とほぼ同等の機能を実現することが可能となります。ただ、通常のreadonly修飾子を使った方法とは違って、毎回毎回Valueプロパティから中身にアクセスしなければならないのが面倒です。
そこで、UniReadOnly&lt;T&gt;にはTへのimplicit operatorを実装してあります。implicit operatorは聞き慣れない人も多いと思いますが、暗黙的な型変換を定義することができる演算子です。
例えば、double型の変数にint型の値をそのまま入れられるのは、doubleからintへ暗黙的な型変換が行われているからです。このように、UniReadOnly&lt;T&gt;にも、UniReadOnly&lt;T&gt;からTへの暗黙的な変換を定義しました。これにより、以下のような記述が可能になり、ただのreadonlyフィールドと同じような扱いを可能にしています。ただし、UniReadOnly&lt;T&gt;からTへの暗黙的な型変換がいつも都合良く行われるというわけではありません。
以下のような場合、暗黙の型変換が行われず、素直にValueプロパティを使用する羽目になります。暗黙的な型変換が行われるのは、「変換先の型インスタンス(T)が求められる場面で、変換元のインスタンス(UniReadOnly&lt;T&gt;)が代入された場合」となります。
つまり、以下のようにTインスタンスを直接使用しない場合は暗黙的な型変換が行われず、エラーとなります。このようなことがしたい場合は、以下のようにきちんとValueプロパティを書かなければなりません。インターフェイスが絡む場合も何故か暗黙的な型変換が使用できないみたいです。以下のようなことはできません。このようなことがしたい場合は、Valueプロパティを使うか、もしくはキャスト（明示的な型変換）を行う必要があります。なぜインターフェイスが絡むと暗黙的な型変換が使用できないか、いまいち理由がわかりません。誰か教えて下さい。implicit operatorのおかげで、ある場面では通常の読み取り専用フィールドと同様の使用感を得られます。
しかし、また別の場面ではValueプロパティを介す必要がある場合もあります。このように、統一した使い方ができないことから、読みづらくなる、可読性が下がると感じる方もいると思います。
僕自身は、そこまで問題とは感じない（むしろそこら中に.Valueがある方が読みづらいと感じる）のですが、implicit operatorの実装の是非は好みが分かれるところだと思いますので、好みに応じて調整してください（というか意見いただけると嬉しいです）。readonlyのためにここまでする必要あるかって意見もあると思いますが、僕はどうしても気になるタチなので専用クラスを作ってしまいました。
賛否両論あると思いますが、よければ使ってみてください。ご意見ご感想あればコメントよろしくお願いします！言うまでもありませんが、Tインスタンスがイミュータブルであることが保証されるという意味ではありません。 ↩


