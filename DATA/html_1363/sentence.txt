C# Tokyo オンライン「Unity 祭り」で登壇した資料も追加しておきます。あわせて御覧ください。UniTaskが大きくアップデートされて、Ver2となりました！
今回はその変更点についてまとめてみました。※ Ver.2.0.25準拠で書いています。まずは1系からの破壊的変更。導入時に気をつける必要があるところです。2018.4.13f1 が最低サポートバージョンとなりました。名前空間がUniRx.AsyncからCysharp.Threading.Tasksに変更されました。
もともとUniRxのライブラリの一部だった名残なのですが、今回のアップデートで完全に名残がなくなりました。同じUniTaskに対しての2回以上のawaitが明確に禁止となりました。
IValueTaskSource準拠の挙動なので、これは本家ValueTaskと同じ挙動です。もし同じUniTaskを2回以上awaitする必要があるならば、Preserve()を利用しましょう。AsyncOperationをawaitするときに利用できていたConfigureAwaitが廃止となりました。IProgress&lt;float&gt;やCancellationTokenを指定したい場合はToUniTask()またはWithCancellation()を利用する必要があります。UniTaskの一部コンストラクタが廃止されました。
こちらはUniTaskの起動を遅延実行するために利用できたコンストラクタです。
（UniTask.Lazyに相当していた）これ相当のファクトリメソッドとして、UniTask.DeferとUniTask.Lazyがあるのでこちらを使いましょう。上記の多重await禁止の変更をうけて、UniTask.Lazyの戻り値がAsyncLazyに変換されました。AsyncLazyはawaitableなので、そのままawaitすることができます。
もしUniTaskに変換したい場合はAsyncLazy.Taskを使いましょう。WhenAnyの戻り値も変更されました。UniTask.DelayFrameの戻り値がUniTask&lt;int&gt;からUniTaskに変更されました。CancellationToken, bool useFirstValue の順序が bool useFirstValue, CancellationTokenと逆になりました。UniTaskから同期的に結果を取得するResultプロパティが削除されました。
あと完了したかを表すIsCompletedも削除されました。もし同等の機能が必要な場合はGetAwaiter()を経由することで一応取得はできます。UniTaskの状態を表すenumの名前がAwaiterStatusからUniTaskStatusに変わりました。全体的にパフォーマンスが向上しています。
内部でUniTaskとAsyncMethodBuilder、Runnerの再利用が自動的に行われるようになり、ゼロアロケーションで動作するようになりました。UniTaskCompletionSourceにReset()メソッドが追加されました。
こちらを利用することでUniTaskCompletionSourceを再利用することができるようになりました。UniTaskCompletionSource.Reset()は2.0.19で廃止されました。
かわりにUniTaskCompletionSourceの挙動がTaskCompletionSourceに揃えられました。すなわちUniTaskCompletionSourceから生成したUniTaskは何回でもawaitができるという仕様に変更されました。
（UniTaskCompletionSourceをフィールドに定義して、そこから生成したUniTaskをプロパティとして公開しても問題なくなった）AutoResetUniTaskCompletionSourceも追加されました。
こちらはUniTaskCompletionSourceと挙動は同じですが、破棄したときに内部のインスタンスが自動的に再利用される仕組みになっています。なお、こちらから生成したUniTaskは1回しかawaitできません。
メソッド内でUniTaskを生成する、みたいな局所的な場所でUniTaskCompletionSourceを生成してすぐ使い捨てるみたいな場合はこちらを使ったほうがよいでしょう。ファクトリメソッドがいくつか追加されました。UniTaskをデリゲートから生成するファクトリメソッドとして、次の3つがあります。これら3つは引数がどれも同じですが、微妙に挙動に違いがあります。DeferとLazyの違いは直接UniTaskを生成するか、AsyncLazyを生成するかの違いです。Deferから生成されるUniTaskは2回awaitできません。
Lazyから生成されるUniTask(AsyncLazy.UniTask)は何回でもawaitが可能です。Lazyと比べてDeferの方がより軽量になっています。
そのためawait回数が1度のみならDeferを使いましょう。一方で何度もawaitする必要がある場合はLazyを使いましょう。PlayerLoopTimingが追加され、次の種類となりました。とくにLastPostLateUpdateが重要で、こちらはコルーチンにおけるWaitForEndOfFrameに相当します。
いままでUniTaskではyield return new WaitForEndOfFrame()ができなかったのですが、今回のアップデートから可能となりました。JobSystemのJobHandleにWaitAsyncが追加されました。
こちらを利用することで、任意のPlayerLoopのタイミングに切り替えてから完了待ちができます。AsyncTrigger系のメソッド(this.GetAsyncCollisionEnterTriggerとか)がIUniTaskAsyncEnumerableに対応しました。CancellationToken.WaitUntilCanceledという拡張メソッドが追加されました。
これを用いると、CancellationTokenが完了するのをawaitできるようになります。同様に、CancellationToken.ToUniTaskでUniTaskを生成することもできます。
このUniTaskはCancellationTokenがキャンセルされると正常終了（Succeeded）状態となります。DoTweenのawaitにも対応しました。ただし動作させるためには次の設定が必要です。AsyncOperationHandleのawaitも可能になりました。UniRxで便利だったAddToのCancellationToken版も追加されました。UniTaskAsyncEnumerableはUniTask2の目玉機能です。IUniTaskAsyncEnumerable&lt;T&gt;はC# 8.0のIAsyncEnumerable&lt;T&gt;をUniTaskとして実装したものです。
なんとこちらはC# 7.x系のUnityでも利用可能になっています。何をするためのものかというと、「非同期処理を複数個まとめて扱う」ことができるようになる機能です。
Observable（IObservable&lt;T&gt;）と似ていますが、こちらはPull型として機能するという違いがあります。ObservableはPush型なのに対して、UniTaskAsyncEnumerableはPull型です。
そのためUniTaskAsyncEnumerableでは非同期処理の実行タイミングを受信側でコントロールできるというメリットがあります。対するObservableはPush型のため、多数のObserverに対してメッセージをブロードキャストするのに向いています。複数個の非同期処理を管理する場合は基本にはUniTaskAsyncEnumerableを使う。
イベント駆動を制御する場合にはObservableを使う。という使い方をするとよいでしょう。C# 8.0であればawait foreachが使えるのですが、それが使えないUnityバージョンでは代替としてForEachAsyncを利用します。
感覚としては、IObservable&lt;T&gt;に対するSubscribe()に似ています。
ですがこちらは「ForEachAsync()の完了をさらにawaitで待つ」といったことが可能となります。また、ForEachAsyncの他にForEachAwaitAsyncもあります。
こちらはデリゲートの内部でasync/awaitが利用でき、この非同期処理が完了するまで次のメッセージを取りに行きません。また、Subscribeというメソッドも用意されています。
こちらはIObservable.Subscribe()と似た感覚で利用できます。なお、こちらはデリゲート内部でasync/awaitが利用できますが、その結果を待機しません(Forgetする）。それぞれの大きな違いは登録したデリゲートの呼び出し方にあります。
ForEachAwaitAsyncとSubscribeは非同期処理を用いたときに挙動が異なるので注意が必要です。UniTaskAsyncEnumerableはさまざまな方法で生成することができます。C#8の非同期イテレータに相当するものとして、UniTaskAsyncEnumerable.Createがあります。this.GetAsyncCollisionEnterTrigger()など。ChannelはGoにおけるChannelと同義です。
挙動としてはObservableにおけるSubjectに相当します。実装としてはCreateSingleConsumerUnboundedが用意されています。
CreateSingleConsumerUnboundedは内部でメッセージをキューイングしているため、メッセージの取りこぼしは発生しません。なお、CreateSingleConsumerUnboundedは同時に１箇所でしかメッセージの消費が行なえません。
2箇所以上でForEachAsync等を行った場合は正しく動作しません。もし2箇所以上で消費したい（値を分配したい）場合はPublish()を利用しましょう。AsyncReactivePropertyはUniRxのReactivePropertyのUniTask版です。
ベースとしてIUniTaskAsyncEnumerable&lt;T&gt;が利用されています。
（ReactivePropertyはベースがIObservable&lt;T&gt;）基本的な使い方はReactivePropertyと変わりません。結論から先にいうと次になります。UniRx.ReactivePropertyとAsyncReactivePropertyはそれぞれ次の点が異なります。UniRx.ReactiveProperty&lt;T&gt;は直接awaitできますが、そのときの挙動がコントロールできません。
たとえば「特定のパラメータに変化するまで待つ」といったことがしたい場合、Operatorを経由する必要があります。ただOperatorを使ってしまうとIObservable&lt;T&gt;に対するawaitになるため、取り扱いが面倒くさいことになります。UniRx.ReactiveProperty&lt;T&gt;はawaitとは相性があまり良くないですが、複数の購読者に対して一斉にメッセージを送ることについては抜群に得意です。一方のAsyncReactiveProperty&lt;T&gt;はIUniTaskAsyncEnumerable&lt;T&gt;ベースのため、awaitと非常に相性がよいです。
素直にそのまま書くことができ、CancellationTokenの指定も簡単です。ただしAsyncReactiveProperty&lt;T&gt;はawaitのタイミングによっては値の取りこぼしが発生してしまいます。
そのため確実にメッセージをブロードキャストして相手に確実に届けるという用途には向いていません。
（その点はUniRx.ReactiveProperty&lt;T&gt;のほうが有利です）取りこぼしの防止策として、後述するQueue()を使う方法もあります。IUniTaskAsyncEnumerable&lt;T&gt;にはLINQメソッドが用意されています。
利用するためにはasmdef「UniTask.Linq」への参照を追加する必要があります。使えるメソッドは次です。AwaitAsyncがついているものはasync/awaitを内部で利用できます。こちらはCancellationTokenを内部で必要とするときに使います。IUniTaskAsyncEnumerable&lt;T&gt;はPull型として動作します。
そのためメッセージの受信準備が整い、内部でイテレータのMoveNextAsync()が実行されたタイミングで次のメッセージを取りに行きます。ですが、UniTaskAsyncEnumerableではメッセージ発行がPushなIUniTaskAsyncEnumerable&lt;T&gt;も存在します（ややこしい）これらはPushされてきたイベントをIUniTaskAsyncEnumerable&lt;T&gt;として提供します。
そのためMoveNextAsync()とタイミングが合わなかった場合は、その間に発行されたイベントは取りこぼされるという点に注意が必要です。逆に、このイベントの取りこぼしを利用して処理を組むこともできます。QueueはUniTask.Linqが提供するLINQメソッドの1つです。IUniTaskAsyncEnumerable&lt;T&gt;に対して先にMoveNextAsync()を実行し、その結果をキューに詰めて再度IUniTaskAsyncEnumerable&lt;T&gt;として提供します。
（ObservableでいうところのPublish()に相当します）Queueを使えばイベントの取りこぼしを防ぐことができるため、必要に応じて利用しましょう。C# 8.0のIAsyncEnumerable相当の処理をいち早くUnityでも利用できるため、かなり期待が高いアップデートとなりました。
UniTaskAsyncEnumerableとAsyncReactivePropertyが刺さる人にはかなり刺さる機能でしょう（自分はさっそく使いたい）ぶっちゃけ、非同期処理の用途としてUniRx（Observable）が選択肢に上がってくることがなくなりました。
async/await + UniTask / UniTaskAsyncEnumerable でほとんどの非同期処理のシチュエーションはカバーできてしまいます。じゃあObservableはお役御免かというとそうではなく、「イベント駆動」として使う方ではまだまだ活用が可能です。
特にイベントメッセージが飛び交うゲーム開発ではObservableが活躍するシチュエーションは多いでしょう。とくにReactivePropertyとAsyncReactivePropertyの使い分けが特に今後は重要になってくるかなと思います。


