More than 3 years have passed since last update.個人プロジェクトで気軽に C# + WPF を使ってみたら、メモリリークに手ひどくやられたので勉強まとめ以下の記事が詳しいのでおすすめです。.NETにおけるマネージヒープとガベージコレクション - Qiitaガベージコレクション（英語: garbage collection; GC）とは、プログラムが動的に確保したメモリ領域のうち、不要になった領域を自動的に解放する機能である。「ガベージコレクション」を直訳すれば「ゴミ集め」「ごみ拾い」となる。1959年ごろ、LISPにおける問題を解決するためジョン・マッカーシーによって発明された[1][2]。
メモリの断片化を解消する機能はコンパクションと呼ばれ、実現方法によってはガベージコレクションと共にコンパクションも行う仕組みになっている。そのためコンパクションを含めてガベージコレクションと呼ぶ場合もあるが、厳密には区別される。
また、ガベージコレクションを行う主体はガベージコレクタと呼ばれる。ガベージコレクタはタスクやスレッドとして実装される場合が多い。
参照カウント方式のガベージコレクションは通常煩雑なコーディングを必要とするが、それを必要なく実装したライブラリとしスマートポインタがある。
引用: ガベージコレクション - Wikipedia別名: マネージヒープ, マネージメモリGCの管理下にあるリソース。通常のC#での実装はこちらに該当する。別名: アンマネージヒープ, アンマネージメモリGCの管理下にないリソース。ファイルハンドルやウィンドウハンドル、データベース接続などが該当する。
要はあえてアンマネージリソースを取得するAPIを使用している(AllocCoTaskMemなどでの明示的なAlloc/Freeの使用）、またはCやC++などのライブラリをC#から使用している場合に内部でメモリ確保されたリソースはアンマネージリソースとなる。
アンマネージリソースを取り扱うAPIは、リソース解放のため明示的にCloseや、Disposeを呼ぶ必要があるケースが多い。AllocHGlobalとAllocCoTaskMem　どちらを使うべきか？ - QiitaQ. 親子関係のあるオブジェクトで相互に参照を持ちたいときに循環参照になるのを回避するには？
A. 弱参照を使う[C#][.NET 4.5~] WeakReference/弱参照の使い方 - QiitaQ. 例外処理とか、Closeの実装忘れとかで解放されていない
A. using を使える場合は常に使うようにする使用側:
using ステートメント (C# リファレンス)
C# Tips －usingを使え、使えったら使え(^^)－実装側:
やりがちなアンマネージドメモリのリークと対処方法 - QiitaQ. 明示的に System.GC.Collect() を呼ぶのは有効？
A. gen0に対する回収は高頻度でよばれているため、デバッグ用途以外で明示的に呼ぶのは特に有効ではないらしい。ただし、System.GC.Collect() はすべての世代に対して回収を実施するため、gen2まで回収させたい場合には有効？仮に明示的にGCを実行する場合は以下のようにする。参考: .NET アプリケーションのパフォーマンスとスケーラビリティの向上 - 第 5 章 「マネージ コ ード パフォーマンスの向上」TODO: 要調査
85KB以上のサイズのオブジェクトは世代別管理のヒープ（generation 0）ではなく、LOH(Large Object Heap)に割り当てられて、扱いとしてはgen2の扱いで回収されるらしい。なので、明示的に System.GC.Collect() 呼ぶのも意味がないわけでもない？（未調査）.NET Framework 4.5.1から、GC時のLOHのコンパクションの有効化オプションが追加された（ただしかなり遅くなるらしい）
GCSettings.LargeObjectHeapCompactionMode プロパティ (System.Runtime)Q. WPFのリークの解決方法
A. 調査中（なにかわかったら問題別に記事を書きます・・・）[C#][.NET] オブジェクトの世代別ガベージコレクションでの世代番号を確認する - Qiita自動メモリ管理
.NET アプリケーションのパフォーマンスとスケーラビリティの向上 - 第 5 章 「マネージ コ ード パフォーマンスの向上」
.NETにおけるマネージヒープとガベージコレクション - Qiita
ガベージコレクション、マネージリソース、アンマネージリソース、Dispose、Finalize - goungoun技術系雑記帳


