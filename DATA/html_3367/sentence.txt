More than 1 year has passed since last update.dotnet core 3.0より、IValueTaskSourceの素として使えそうなManualResetValueTaskSourceCoreなるクラスが追加されたようなので、使い方等を書く。IValueTaskSource自体については、 http://tooslowexception.com/implementing-custom-ivaluetasksource-async-without-allocations/ が詳しい。この記事は、単純にライブラリから渡されたValueTaskをawaitするという場合には特に意識するところではないが、
例えば非同期Queueの処理結果を通知したい場合等、今まではTaskCompletionSourceを使っていたような場面で参考になると思う。
今回使ったソースは https://github.com/itn3000/valuetasklabs にまとめてある。C#にはasync awaitという非同期処理のための機能が存在する。
ここでクラスとしてTask&lt;T&gt;が主に使われているが、定義としてはクラスのため、どうしても実行の度にアロケーションが行われる。アロケーションのコストは、個々で見ると大きくはないが、これが数十万以上となってくると、GCやヒープアロケーションの負荷が無視できなくなってきて、効率的な実行を阻害してしまう場合がある。
これ自体は、非同期処理という性質上どうしてもコンテキストが変わるタイミングで必要な情報をスタック以外に確保する必要があるなど、仕方なかった所もある。しかし、dotnet coreの進歩に伴い、パフォーマンスアップというのがdotnet coreの大きな目標の一つとなった(主にasp.net)ため、このオーバーヘッドをどうにかしたいという要望が出てきた。そこで登場したのがValueTask&lt;T&gt;である。
これは従来クラスだったTask&lt;T&gt;に対し、構造体として定義されたTaskのようなオブジェクトとなる。
これにより、awaitを通らないケースが大半の場合の処理で大幅なパフォーマンスアップが見込めることになった。しかし、awaitのタイミングで結局Task&lt;T&gt;をアロケーションしてしまう+ボクシングが発生してしまうため、awaitの回数が多いと却って遅くなる場合があるという問題点があった。ValueTaskからコンテキスト情報を追い出し、少なくともValueTask内部では完全に新規アロケーションが発生しないようにするため、IValueTaskSourceというものが導入された。
IValueTaskSourceを実装したインスタンスを使い回すことにより、大量に非同期処理を行っても、使い回しの分だけしかアロケーションは発生しないので、より効率的にリソースを使用できるという仕組みになる。
これにより、System.Threading.Channels等のValueTaskを使用するプログラムでは、性能向上とアロケーションフリーが同時に達成された。
だが、 解説ページを見てもわかる通り、実装の仕方がややこしく、うまく実装しないと結局使わないより性能が劣化するということもあった。そのため、パフォーマンスを重視する人たち(Kestrelを実装している人やStackOverflowの中の人等)は、このIValueTaskSourceを早速駆使して性能向上を図っていたようだが、一般人にはどうにも扱いが難しい代物だった。
そこで、実装を簡単にするべくnetcoreapp3.0及びnetstandard2.1から導入されるのが、冒頭で書いたManualResetValueTaskSourceCoreとなる。なお、ManualResetValueTaskSourceCoreのソースはここにあるが、内部APIを利用しているためそのままでは実装はできない(特にSynchronizationContextにQueueするところ)。
しかし、参考にできる場所も多いと思う。さて、このManualResetValueTaskSourceCore、直接IValueTaskSourceを実装しているわけではない。
ManualResetValueTaskSourceCoreをメンバーに持つようなクラスを定義する必要がある。具体例としては以下。基本的には委譲するだけであるが、オブジェクトプール。注意点としては、GetResult(short token)の時に、オブジェクトプールに自分自身を返還しているという点である。この辺りは厳密に考えると、CompareExchange等で安全性を見た方が良いかもしれないが、サンプルコードなのでとりあえずこのまま。さて、上記を定義したら、今度はValueTaskを生成する側である。基本的には、というようになる。具体例としては以下のようになる。単純に、他のTaskやValueTaskと同じようにawaitすればいいだけである。参考までに今回の方法で実装した非同期キューと、TaskCompletionSource&lt;int&gt;で実装したソースの比較値を書いておく。
ベンチマークコードさて、IValueTaskSourceだが、netstandard2.1のライブラリで、System.Threading.Tasks.Extensionsを参照するライブラリと一緒に使おうとすると、ビルド時に以下のようなエラーになる。csprojは以下のようになる。これは、netstandard2.1でIValueTaskSourceとValueTaskが標準入りしたため、nugetパッケージのSystem.Threading.Tasks.Extensionsのものと競合を起こしているためである。
netcoreapp3.0では特殊実装されているため問題は無いが、preview段階でのnetstandard2.1の実装の際は注意が必要。
同パッケージを使っているライブラリは多いため(NpgsqlとかSE.Redisとか)、割と致命的だと思うので、リリースまでには対処してくるとは思う。
3.0pre6で対応済み今までTaskCompletionSourceを使用していた部分に採用すれば、より効率の良い処理が実装できると思うので、早くdotnet core 3.0リリースを願うばかりである。


