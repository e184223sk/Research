More than 3 years have passed since last update.プログラマの方は、演算時には、オーバーフローに関しては、
常に気を使っていると思いますが、
それでも忘れがちなケースを簡単にまとめます。この記事は、以下の内容からピックアップした外伝的な内容です。話しを単純にするために、32bitの符号付き整数型を想定します。
今回の内容に関しては、精度が決まっている符号付きの整数型であれば、
他のサイズでも該当するはずです。Java, C#, C/C++では、
int、Int32, int32などを思いうかべると良いかと思います。
(C/C++では、int型が32ビットの処理系を想定。)大きな数値同士の掛け算とかは、オーバーフローしやすいのは、
すぐイメージできると思うので、本題ではありません。本題としては、以下のようなケースです。aには、-2147483648が入っていますが、
-1を掛けると、32ビットの符号付き整数で表現可能な2147483647を超えます。
手元の環境では、いずれもanswer変数の結果は、-2147483648になりました。
C#に関しては、checkedにした場合は、OverFlowExceptionが発生します。ビルドやコンパイル時点で、値が評価できる場合は、
その時点で、オーバーフローを検出する場合もあります。整数の割り算では、オーバーフローは発生しないと、
勘違いされているケースもありますが、ちゃんと(？！)オーバーフローする場合があります。掛け算の場合と同様ですが、
-1で割ると、-1を掛けるとの同じことなので、
32ビットの符号付き整数で表現可能な2147483647を超えます。
手元の環境では、Javaでは、answer変数の結果は、-2147483648になりました。
C++では、整数オーバーフローの例外が発生しました。
C#に関しては、checkedかどうかにかかわらず、OverFlowExceptionが発生します。


