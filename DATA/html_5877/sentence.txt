More than 3 years have passed since last update.インターフェースは機能の実装を強制する仕組みです。
このインターフェースを継承するクラスは○○の機能を持ってるよ、ということを保証します。参考：
http://ufcpp.net/study/csharp/oo_interface.html
https://qiita.com/IganinTea/items/e1d35db0a14a84bda452私が一番よく使っている標準クラスライブラリのインターフェースはIDisposableです。
このインターフェースを継承するとDisposeの実装が強制されます。Disposeの実装が強制されて何が嬉しいかというと、usingステートメントを使用することができます。
そしてusingステートメントが利用できるとアンマネージリソース1を扱うときにリソースの解放忘れを気にしなくて良くなります。usingを使う代表的な例がStreamReaderクラスです。
StreamReaderの親クラスであるTextReaderがIDisposableを継承しています。ちなみに上記のコードは以下のコードと等価です。IDisposableを継承してテキストファイルを表すクラスを実装すると以下のようになります。
（全く意味ないクラスだけど無理やり作ってみた）Open/Closeという概念があるクラスの場合、IDisposableを継承しusingステートメントを利用できるようにしておくと分かりやすく堅牢になるため良いです。  後述のIEnumerable/IEnumerable&lt;T&gt;インターフェースを使うと、foreachステートメントを利用できたりもします。
自作のコレクションなんて使ったこと無いけど。。。みなさんLinq使ってますか？
私はLinqの為にC#を使っていると言っても過言ではないくらいLinq大好きです。
LinqでSelectとかWhereとか使うと、返ってくるのはIEnumerable&lt;T&gt;ですよね。ここではIEnumerable&lt;T&gt;が返ってくると何が嬉しいのか考えてみます。まずListをSelectした例を見てみたいと思います。Listに対してSelectを通しただけの文ですが、この時resultsの実体は何なのでしょうか？
正解はWhereSelectListIterator&lt;TSource, TResult&gt;クラスのインスタンスです。
http://referencesource.microsoft.com/#System.Core/System/Linq/Enumerable.cs,37c6daad6e403a3b,references
これがListではなく配列だった場合、WhereSelectArrayIterator&lt;TSource, TResult&gt;が返ってきますし、
これがSelectではなくWhereだった場合、WhereListIterator&lt;TSource&gt;が返ってきます。この時Selectの実装はこんな感じです。http://referencesource.microsoft.com/#System.Core/System/Linq/Enumerable.cs,5c652c53e80df013,references様々なクラスのインスタンスがreturnされますが、戻り値はIEnumerable&lt;T&gt;の為これらのインスタンスはIEnumerable&lt;T&gt;としかふるまいませんし扱われません。つまりインスタンスが何であるかは気にしなくて良いのです。
私たちがSelectやWhereに期待することはIEnumerable&lt;T&gt;を継承するコレクションから呼び出せて、結果をIEnumerable&lt;T&gt;として戻すこと、それだけで十分なのです。もちろんインデクサを使ったアクセスや要素の追加・削除がしたい場合はIEnumerable&lt;T&gt;では不十分です。
その場合はToList()してListとして扱うと良いです。またIEnumerable&lt;T&gt;を継承さえしていればインスタンスは何でも良い状態は変化に強いと言えます。仮にSelectの実装に変更があり、WhereSelectEnumerableIterator&lt;TSource, TResult&gt;が全く違うクラスに置き換わったとしても、利用する側に影響は無いでしょう。もう一つ例を見てみます。業務システムで受注データをファイルから読み取り、DBへ格納するという処理は割と一般的です。
そして受注データのファイルが取引先によって形式もフォーマットもバラバラということもまた一般的です。
この処理を実装してみたいと思います。まずDBへ格納するパラメータは商品（ItemId）・納期（DeliveryDate）・数量（Quantity）の3つとしましょう。
それを1件分保持する構造体を作ります。そして受注ファイルのインターフェースIOrderFileを作成します。
ファイルの内容（受注データ）を列挙して返すReadメソッドと、読み終わったファイルを削除するDeleteメソッドをふるまいとして定義します。受注ファイルの具象クラスOrderFileFromA・OrderFileFromB・OrderFileFromCも作成します。
各クラスでそれぞれのメソッドに対し個別の処理を実装をします。コンストラクタでファイルパスを受けてローカル変数として保持していますが、Readメソッドで必要になる（はず）です。前提となるコードが多いですが頑張りましょう。IOrderFileの具象クラスを3つ定義しましたが、これらの生成（new）はどうやってやりましょう？それぞれのファイル形式が異なる（拡張子で判別できる）ので、ファイルパスから判別できます。2
（ファイル名から取引先が判別できればそれでも良いと思います。）
ファイルパスをインプットして、具象クラスをアウトプットするFactoryクラスが今回は適当です。3くどいようですが、具象クラスのインスタンスをreturnしても戻り値はインターフェースという点がポイントです。最後にMainクラスです。ファイルパスはargsから受け取る想定です。MainクラスではIOrderFileの具象クラスは登場せず、インターフェースのみで動いています。
必要なのはRead()とDelete()の機能のみであり、ファイルがテキストだろうがCSVだろうが関係ないのです。そして具象クラスに依存するコードは全てIOrderFileFactoryにあります。
当然取引先が増えることも減ることもありえるでしょう。しかしその際はIOrderFileFactoryだけの変更で済みます。変更に対する影響範囲が限定されることは大きなメリットの一つでしょう。今までインターフェースを使ったことが無い人にはIDisposableがオススメです。利点もわかりやすいし、実装も簡単です。インターフェースは使おうと思わないと使わない機能なので、意識して使っていく気持ちが大事です。なんでもかんでもインターフェースにすれば良いというものではありませんが、「これってインターフェースにできないかな？」と考える癖をつけてみましょう。「インターフェースに対してプログラミングしろ」という原則は特に目新しいものでもなく、本稿の結論も全く同じです。しかし車とか林檎とかの概念で説明されても正直わかりません。
私はデザインパターンを勉強する中で実際に手を動かしやっと利点がつかめた気がしました。初心者・初級者の方のふわっとした理解が少しでも固まる手助けになれば幸いです。ファイルとかDBコネクションとか ↩拡張子が嘘ついてなければ ↩SimpleFactoryパターン ↩


