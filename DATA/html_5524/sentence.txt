More than 3 years have passed since last update.Python初心者です。普段C#を使っている自分がPythonを勉強して驚いたことをまとめました。公式チュートリアルの勉強メモです。この公式チュートリアルはよくできていて、プログラミング経験者ならこれを読むのが一番わかりやすいと思います。環境：Python3.6(64bit)、Anaconda 4.3.0(64bit)、Visual Studio 2017 CommunityVisual Studio Installer経由でPython、Anacondaを同時にインストールできます。Anacondaのオプションを入れるとJupyter NotebookやNumpyもまとめてインストールしてくれるのでおすすめ。Jupyter Notebookの初回起動時にコンソールが一瞬表示されて起動しないことがありますが、パスが通っていないのが原因なので修正しましょう。参考：Visual Studio 2017におけるPythonサポート (1/2)
http://www.atmarkit.co.jp/ait/articles/1708/18/news028.html
Jupyter Notebookを立ち上げると，一瞬だけコンソール画面が出てから落ちる
http://publicjournal.hatenablog.com/entry/2017/02/04/010544これは感動しました。2つの値を入れ替えるという操作をよくするのですが、仮の変数を用意しなくてもよくなります。例えばバブルソート。C#（他よくある言語）だと入れ替え部分でtmpのような変数を用意する必要があります。追記：C#でもC#7.0で導入されたValueTupleを使うと同じことができます。コメントで指摘してくださった方ありがとうございました。多重ループで次のようなバグをよくやります。こういうやらかしが出なくなるのがいいですよね。C#でもforではなくforeachを使えという声もあります。PHPでもforの中で変数名のプレフィックスの$を忘れたりfor文自体バグが出やすいんですよね。上のコードをforeachを使って書き直します（自分はこっちのほうが好きです）。Pythonのfor文とそっくりですよね。Pythonのfor文でリストを回すときにインデックスが欲しい場合はenumerate()を使ってKey，Value形式にできます。（for key, value in enumerate(list):）string.Joinで結合するのだるくなくて感動。ただC#（VisualStudio）の場合はとても優秀なデバッガーがあるのでこれだけで比較するのなと思います。Pythonはとてもシンプルです。きっかけはPythonで列挙するシーケンスに対して、ループ内で変更を加えるという怪しい（？）操作ができることから。C#の場合ここはしっかりしていて、同じことをするとSystem.InvalidOperationExceptionの例外が発生します。Pythonの例で元の値に準じてループをしたい（つまり0,1,2で終わらせたい）場合は、スライス記法[:]でコピーすることが推奨されています。Pythonの公式ドキュメントを見るとループ内部でイテレートしているシーケンスを修正する必要があれば (例えば選択されたアイテムを複製するために)、最初にコピーを作ることをお勧めします。シーケンスに対するイテレーションは暗黙にコピーを作りません。スライス記法はこれを特に便利にします:ただ、これシャローコピーなんですよね。チュートリアルの「データ構造」に詳しく書いてありました。list.copy()
リストの浅い (shallow) コピーを返します。a[:] と等価です。シャローコピー自体は悪いことではないんですが、どういう挙動になるかよく知った上で使わないといけません。イミュータブルなオブジェクトの場合は、変数の値がコピーされます。id(x)はユニークなオブジェクト識別子を返す関数で、実行ごとに結果は変わります。f,g,hの中身のIDは全て同じなのに（なぜディープコピーまで中身のIDが等しくなっているかというと、Pythonの代入は参照渡しだから：後述）、代入後f[0]のIDと値のみ変わっていますね。タプルはイミュータブルな型なので、スライス記法でもディープコピーと同様の結果が得られます。タプルをリスト（ミュータブルな型）にするとどうでしょうか。f（直接代入）とg（シャローコピー）リストの中身のIDのみ一致するようになり、代入後はf,gが連動する形で値が変わっています。gがシャローコピー、hがディープコピーえあることを確認しやすいのはこちらでしょう。ここでいうディープコピー、シャローコピーというのは、ミュータブルなオブジェクトに対して再帰的に値をコピーするかと考えてよさそうです。本当にディープコピーをしたいのであればcopy.deepcopy()を使うべきです。「あれ、そういえばこんな挙動見たことあるぞ」とピンと思い出します。そうです。C#のToArray()と同じです。前のC#の例ではリストだったのに今回は配列になっていますが、どっちも参照型なので挙動は変わりません。ToArray()は配列にコピーするメソッドですが再帰的にディープコピーする機能はありません。なるほど、これですっきりしました。最初「Pythonも値型や参照型の違いのような挙動をするんじゃ？」と思ったのですが、どうもこれは違いました。例えば次のように変数のアドレスを見てみます。C#の場合このようにブレークポイントを配置しても、変数x,yのアドレスは全てにおいて変わりません（値型だからそれはそう）。

ただ、Pythonで同じことをやると結果が変わります。y = xと代入したところでxのIDがそのまま代入されてる！！？ その後xに別の値を放り込むとIDは変わります。Pythonでは変数の代入は参照渡しで、オブジェクト指向言語にあるような参照型と値型の違いというようなのはイミュータブルかミュータブルかという点に集約されるようです。詳細は以下の記事で。参考：Pythonの値渡しと参照渡し
http://amacbee.hatenablog.com/entry/2016/12/07/004510しかし、ループ中の変数に追加されるのがまかり通って代入が参照渡しって、特にブラックボックス化しがちな内包表記の中でハマるとひどそうですね。気をつけないと。for文でbreakしなかった場合にelseが呼ばれます。一体何のためにあるだろうと考えて小一時間、有用そうな例を見つけられました。rangeが5まではbreakしていないのでfinishが呼ばれますが、それ以上はbreakしたためfinishが呼ばれません。これ、continueだけでは書けないんですよね（有限なら挙動は同じになるが、無限ループの場合は最後まで到達しない）。for…elseがない場合はループがbreakしたかどうかの変数を用意するか、この部分だけ関数化してif…returnします。前者はちょっとダサいので省略します。後者の関数化した場合はこうです。この書き方だと馴染みがあります。空のループに対してもelseが呼ばれます。なのでループ内でループ外変数を初期化するケースで、シーケンスが空でループが呼ばれなかった場合に書いておく…みたいなトリッキーな書き方のもできると思います。ループ外で一度初期化しておけばいいだけの話ですが。これはちょっと頭をかしげました。関数のデフォルト値って再帰関数でよく使うんですよね。再帰の例でよく出て来る階乗関数を実装してみます。確かにうまく行っています。デフォルト引数をリストに変えて、カウントダウンをする関数を定義します。else以下の第2引数をtmp.append(x)とするとエラー（AttributeError: 'NoneType' object has no attribute 'append'）になります。tmp.append()だと参照はtmpのままだけど、tmp+[x]だと参照が新しいリストになるのかな？再帰ではなくもう少しわかりやすい例で。追記：エラーになるのはappend()の返り値がNoneだからだそうです。コメントで指摘してくださった方ありがとうございました。こんなトリッキーな実装されたら泣きそう。引数に対応したインデックスだけ1にする場合は、先程のスライス記法[:]を使ってみます。デフォルト値は一度しか評価されないというをふまえつつ、代入する対象の参照に気をつけるのが大事ということなのかなと。追記：switch_newはこう書く方が多いそうです。コメントで指摘してくださった方ありがとうございました。関数のオーバーロードやオプション用のクラス定義をしなくていいのがいいと思いました。例えばラーメン屋店主になったつもりで、お客さんのスープや麺の量、トッピングの注文を聞いて値段を計算する関数を作ってみます。普通ここまでオプションが多くなると、トッピング用のクラスを定義してそのインスタンスを引数に指定するのですが、そこらへんの手間を省けるのが動的型付けの強みだなと（もちろんそれ故のデメリットもあると思います）。すごくLINQを使いたくなります。関数表記すると例えばmapしてsortするとなると、sort(map(…))のように操作と逆順に関数をネストしないといけないので直感的じゃないんですよね。せめてメソッドチェーンを使えれば、操作順になるので多少マシと思ったものの、返り値がNoneなのでチェーンできないと。もちろんライブラリを使えばできるのでしょうが。一番腑に落ちたのがリストの内包表現（公式チュートリアルでも内包表現を推奨しています）。ただこれでもメソッドチェーンできないし、つなげようとすると逆順になるというアレ。例えば、次のような簡単なRPGを想定します（数値は適当）。書いてて結構もどかしかったです。いきなりRPGなんてと思うかもしれませんが、実践的にはこういう操作、言語を問わず非常に多いです。モンスターのマスターデータの構造はMySQLに代表されるRDBMSの形式そのものですし、Pythonをサーバーで動かしてWebアプリを作ろうと思ったら必ずこのようなケースにぶち当たります。デスクトップでもExcelのシートやcsvやJSONのデータを引っ張ってくると、ほぼ同様の問題に当たります。
同様のケースをC#で書いてみます。本当はこの手の問題はちゃんとクラスを定義すべきですが、Pythonではクラスを使わなかったのでC#では匿名型でやってみました。なくて初めてわかるLINQのありがたみ。追記：Pythonの場合に、encount関数をこうするともうちょっと綺麗にかけるよとコメントで教えていただきました。ありがとうございました。LINQ万能のように書いてしまいましたが、実はPythonのzip関数はとても直感的でわかりやすいです。次の例で考えてみましょう。これもよくありがちな例です。長さが異なるリストに対して最短のリストに合わせてループをするというケースです。リストの要素数が暫定的に同じであっても、IndexOutOfRangeを出さないために、リストの長さが等しくなるように保証してあげる必要というのがよくあります。Pythonのzip関数はとても明瞭です。並べるリストの数がいくらになろうともタプルに変換されるので問題ないです。
全く同じことをC#でやろうとするとこうなります。LINQのZipメソッドがごちゃごちゃしすぎて意味不明ですよね。なので以下のほうがまだわかりやすいでしょう。こうしてみるとPythonのzip関数はとても優秀です。これ見た時相当落ち込みました。確かに名前マンニングを使って先頭に__（アンダーバーを2個）引けば擬似的なプライベート変数は作れます。ただし強引にアクセスできてしまいます。なので、こんなことをされる可能性はあります。（しずかちゃんのインスタンスって何なの？という疑問はあったので、クラスメソッドにしました）エンジニアののび太くんは「しずかちゃんのお風呂がのぞけない？それならインスタンス作って、.Shizuka_bath(nobita)すればいいじゃん」なんて言ってくるかもしれません。この書き方は公式ドキュメントにもある通り、非推奨です。
JavaScriptはじめprivateの概念が全く無い言語はありますが、Pythonの場合下手にprivate-likeなことができるのが悲しみを産んでいるのかなと。こののび太くんの言い分は一理あって、派生クラスで親クラスの変数を取得するときちょっと楽できます。ただ、知らないとハマります。この場合はカプセル化と天秤にかけるとどっちがいいともいえないと思います。とても重要なことですが、コンストラクタをオーバーロードする場合、継承先でスーパークラスのコンストラクタを呼び出すのを忘れないようにしましょう。自分はこれで数時間ハマりました。継承先でオーバーロードする場合は、これをやらないとMainClass_main_textがないと言われます。変数名でもメソッドでもプロパティでもエラーです。dir()をのぞくと、スーパークラスのインスタンスメソッドはあるからコールはできているのに、インスタンス変数が呼び出せていないという謎の現象。継承先でコンストラクタを作らない場合は特にエラーが出ませんでした。さらに、継承先からスーパークラスのインスタンス変数なりメソッドなりを呼び出す場合は、super()ではなくselfです。ここもハマりました。スーパークラスのインスタンス変数を呼ぶのに非推奨の書き方をやめて、プロパティやメソッドに変えてみます。幸い、Pythonにはキーワード引数という便利なものがあるので、変数の数が多くなってきた場合、セットのメソッドを一括にまとめることができます。ゲッターの場合は返り値を辞書式にすればいいと思います。dir()見てると完全には隠蔽はできてなさそうですね。そういう仕様だと割り切るしかありません。yieldという文字を見ると楽しくなってきますね。例えばxまでの素数を生成する関数を定義しましょう。100までの双子素数を列挙します。双子素数とは2つの差が2である素数の組み合わせです。for～elseも使えてとてもPythonらしいプログラムになりました。これは美しい。PHPと同じようにデフォルトでSQLite3が使えます。ダブルクオーテーション3つ（"""）で複数行のStringが定義できるのありがたや～。executemanyでプリペアドステートメントを一気に突っ込めるのと、SELECTをイテレーターで一気に回せるのがとても心強いです。パフォーマンスを検証していませんが、クエリ的なことをすると結構もどかしいので、面倒な処理はSQLiteにまかせてしまうというのもありかもしれない。randomモジュールはとても充実しているのでいろいろ遊べます。11連ガチャをするプログラムを作ってみましょう。実行結果は次のようになります。ガチャ爆死お疲れ様でした。実際こうして作ってみると生々しいですね。排出率を変えて遊べます。当然モンテカルロ・シミュレーションもできます。円周率の近似値を求めるプログラムです。仕組みは簡単です。まず、x=0～1、y=0～1の範囲内に、半径1の1/4円（扇形）を思い浮かべます。この中にランダムに点を落としていって円の内側か外側かを判定します。円の面積の公式はπr^2ですから、1/4の円の面積はπ/4。一方で、辺の長さが1の正方形の面積は1ですから、円の内側に入った点の個数の4倍が円周率の近似値となります。詳しくはこちらを参照
結果は実行ごとに異なりますが、とりあえず小数第2位ぐらいまでは正確そうですね。一様乱数の他にも正規乱数やベータ分布に従う乱数までも用意されている至れり尽くせりの仕様なので本当いろいろ遊べます。ここまで組み込みモジュールで用意されていて無料の言語、他にRぐらいしか知らないです。実はこの円周率の近似計算、Numpyを使ってもできます。Visual Studio Installerを使ってAnaconda4.3.0をインストールしておきます。プロジェクトのPythono環境を右クリック→Python環境を追加/削除でAnacondaをPython環境に追加します。追加したら、Python環境下のAnacondaを右クリック→環境のアクティブ化を忘れずにしておきます。これしないとNumpyが読み込まれません。Numpyの配列では配列どうしの計算ができるので、関数表記を減らすことができます。Numpyを使った場合の書き方はPythonそのものよりもだいぶRに近い気がしました。Rもfor文やめてベクトル計算やapplyを使うと高速化できるので、Pythonもfor文やめると高速化できるかもしれない。Numpyを使わない場合（13）と比較して、経過時間は次のようになりました（それぞれ3回実行）。Numpyを使わない場合
2.359299659729004
2.3497982025146484
2.3798024654388428Numpyを使った場合
0.12251543998718262
0.1140141487121582
0.1230156421661377単位は秒です。Numpyを使うとざっと20倍ぐらいになります。これむちゃくちゃ速いです。ちなみに同じことをC#で書くと次のようになります。実行速度は、次のようになりました。00:00:00.1150376
00:00:00.1043071
00:00:00.1089778NumpyよりC#のほうが若干速いような気がするけどまぁいいや。別にC#が最速だなんてこれっぽっちも思っていませんが、Numpy使わない場合のPythonって結構遅いんですね。追記：大変おバカなことをしてしまったようで、Numpyの場合は**2（2乗）表記を使うべきでした。コメントで指摘してくださった方ありがとうございました。これだと余計な1-randの計算が省かれる分C#より若干速くなります。AnacondaのライブラリにはデフォルトでPycURLとBeautifulSoup4が入っていて、これだけでスクレイピングができます。気象庁の積雪深から青森県の2/6現在の積雪を取得してみます。もうちょっと綺麗に書けるかもしれない。ちなみに、気象庁のデータはcsvで公開されているので、わざわざスクレイピングする意味ないです。結果は以下の通り。PycURLはcurlそのものなので、curl_multiを使って並行リクエストもできます。ちょっとしたWEBサービスぐらいなら作れそうですね。長いエントリーになってしまいましたが、Python学習の参考になれば幸いです。C#でLINQに慣れている方なら内包表記も馴染みやすいと思いますよ。


