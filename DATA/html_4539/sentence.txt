EF Core 5.0では階層化されたエンティティのマッピング方法として、従来のTablePerHierarchy（階層単位のマッピング）とは別にTablePerType（テーブル単位のマッピング）が追加されました。この記事ではEF Core 5.0でTablePerTypeの階層化マッピングを作成する方法と注意点について説明します。接続データベースにMySQL、データベースアダプターにPomelo.EntityFrameworkCore.MySqlを利用しています。次のような継承関係を持つエンティティーがあったとします。

コードにするとこんな感じですね。EF Core 5.0ではこのようなエンティティーをデータベースに反映する場合、2つの手段をとることができます。まずは従来から利用可能な階層単位のマッピングでデータベースに表定義を反映していきましょう。
DataContextを下記のように定義します。ここでTestをDbContextに定義しないと、TestAとTestBは全く関係のないテーブルになってしまうので注意してください。データベースマイグレーションを実施すると下記のようなSQLが発行されます。次のコードでデータベースにサンプルデータを追加していきます。データの登録時は親クラスであるTestに対して登録しても、子クラスであるTestAやTestBに登録しても結果は変わりません。Testテーブルには次のようにデータが格納されています。TestAのPropAとTestBのPropBがTestという1つのテーブルに定義され、関係ないプロパティーにはnullが格納されているのが分かります。また、エンティティーを識別するDiscriminatorというカラムが自動的に追加され、そのレコードがTestAのものなのか、TestBのものなのかが判別できるようになっています。
TestAから1行読み出してみると、こんなSQLが発行されました。このSQLだったらDiscriminatorにIndexを張りたい気がしますね（まぁPropAで検索している時点でダメダメなんですけれど）。続いてEF Core 5.0から利用になったテーブルの単位マッピングです。OnModelCreating時にToTableメソッドを使って配置するテーブル名を指定しています。マイグレーション時には、下記のようなDDLが発行されます。TestテーブルとTestAテーブル、TestBテーブルの3つのテーブルが作成され、ON DELETE CASCADEオプション付きで外部制約が張られていることが確認できます。ER図にするとクラス定義と同じ形にマッピングされていることが確認できます。個人的にはこちらの方がすっきりしてよさそうな気がしますね。
データを追加すると、親であるTestテーブルと子供であるTestAテーブル、TestBテーブルの両方にちゃんとデータ格納されていることが分かります。
先ほどと同じように1行読み出してみると、下記のようにTestテーブルとTestAテーブルが結合されて取得されているのが分かります。出来上がるテーブルの構造だけ見るとテーブル単位マッピングのほうが素直に実装されているので何となくこちらの方がよさそうに見えます。ただし、EF Coreのパフォーマンスマッピング - 継承のマッピングというトピックでは、Joinは負荷の高い処理であるため従来の階層単位のマッピングのほうがパフォーマンスが良くなるという記載があります。例にあるクラスを実際にローカルのコンテナで実行しているMySQLに対してパフォーマンスを計測してみました。
この例ではRootクラスと継承関係にある6つのエンティティー（Child1, Child1A, Child1B, Child2, Child2A, Child2B）に対してそれぞれ5000件のデータを挿入し、全件読み込む速度を計測したものです。
確かに階層単位のマッピングの平均が205.444 msなのに対し、テーブル単位マッピングは532.521 msかかっています。考えてみれば、階層単位のマッピングは単一テーブルをそのままSelectするのに対し、テーブル単位マッピングはRootテーブルと子供テーブルを常にJoinする必要があるのでわからなくもないです。
どちらを利用するかは、メンテナンスコストとパフォーマンスコストのどちらを優先するかをしっかりと検討する必要がありそうですね。


