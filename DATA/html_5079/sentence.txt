More than 3 years have passed since last update.Collections系の記事を書こうとしていたら、System.Collections.Immutable名前空間の型をまったく使えていなかったことに気づき、反省も兼ねて記事にしてみました。仕様は調べて書いているつもりですが、使いこなせていない人(=私)の記事ですので、実戦で使いこなしている方からの温かいツッコミを期待しています！まずはImmutableなデータ型の代表的な特徴は以下の通り。これを意識したクラスを自分で作ったことがあるかどうかはさておき、使ったことがない人はいないと思います。
なぜならば、C#ではstring型はImmutableだからです。
「Immutableってなんだったっけ？」と思ったら、string型を思い出すと良いでしょう。System.Collections.Immutable名前空間には、一通りのコレクション系クラスが揃っています。これらのクラスはコンストラクタ持ちません。代わりに対応する静的クラスのファクトリメソッドCreate&lt;T&gt;()からインスタンス生成をしましょう。同じようなメソッド名のコレクション操作を持ちますが、操作後は別のインスタンスが生成されることに注意します。いざ使うときに左辺を書き忘れそうで怖い……不変なデータ型を扱うときに欠かせない、BuilderがそれぞれのImmutableコレクション型に存在しており、ToBuilder()メソッドでBuilderに、ToImmutable()メソッドで元のImmutableコレクションに、それぞれ移行できます。
ちょうど、String型に対する`StringBuilder'型のようなものだと思えば、しっくりくると思います。初めからBuilderを生成するためのファクトリメソッドもあります。"マルチスレッドな操作で" "コレクションそのものを扱うとき" Immutableなコレクションが生きてくると思います。同様にマルチスレッド操作で登場するConcurrentなコレクションとは役割が違うので、それぞれを適した場面で使うことになります。
また、ReadOnlyなインタフェースとも似ているようですが、出番が全く違います。System.Collections.Immutable名前空間がマルチスレッドの全てを解決するわけではないですが、この存在を認識していれば必ず活躍する場があると思います。実際に使用する際にはImmutableInterlockedクラスなども合わせて、うまく組み立てる必要がありそうですので、試行錯誤しつつ使っていきたいと思います。


