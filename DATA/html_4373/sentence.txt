PRISMライブラリのDialog Serviceと、ReactivePropertyを併用する場合には
ちゃんとReactivePropertyを破棄しよう！の話Dialog Service内に限らず、使い終わったものは処分（破棄）するのがマナーです
ReactivePropertyの後始末 - かずきのBlog@hatenaReactiveProperty作者様のブログ（↑コレ）から一部引用させていただくと・・・Disposeしないといけないケース
他のIObservableをソースとしてReactivePropertyなんかを作ったときは、内部動作としてSubscribeをしているので、Disposeを呼ぶ必要があります。さらに同記事から引用させていただくと・・・こういう時は、ReactivePropertyを持っているクラスが不要になったタイミングでDisposeを呼んでやらないと、予期せぬ動作をすることがあるかもしれません。この予期せぬ動作に遭遇したので、経緯と対策（私はどうしたか）を書き残すダイヤログは、その性質上、呼び出しとクローズ処理が頻繁に行われるつまり（それがシングルトンでない場合）、頻繁にインスタンスが生成され、もしそれが適切なタイミングで破棄されなければ、メモリに悪影響を及ぼすことが予想される⇒ 以上の理由から、この記事ではダイヤログをやり玉にあげているデフォルトのMainWindowから自作MyDialog（ユーザーコントロール）を開くだけのアプリをつくるPrism.Wpfのバージョンは7.2.0をつかったモデルは一定間隔で連番を生成するObservablePropをもっている超絶参考：【Reactive Extensions】 Hot変換はどういう時に必要なのか？ - 問題の解決策「Hot変換」ダイヤログは、モデルのObservableをもとにToReactivePropertyしてつくられた
_reactivePropertyAAと_reactivePropertyBBをもっているモデルとダイヤログをそれぞれPrism.UnityのDIコンテナに登録するメインウィンドウからダイヤログを開いて閉じる動作を3回行う
以下ログに説明を入れたもの。（キャプチャした時のログとは違うので、数字が異なる箇所もある）ダイヤログが破棄された（デストラクタが呼ばれた）あとでも
OnNextが実行されつづけており、不気味な感じがする。この調子でダイヤログを開いて閉じてを繰り返すと
ダイヤログから見捨てられたオブザーバーが延々とOnNextを実行しつづけて・・・ダイヤログビューモデルクラスのprivate変数であるReactivePropertyと
それをSubscribeしているオブザーバーが
ダイヤログがいなくなってから（デストラクタ後）も存続し続けている（ように見える）

この周辺の理解がまだ足りなく、もしかしたら重大な誤解をしているかもしれない（！？）
ダイヤログビューモデルを変更するReactivePropertyをnewしたタイミングで、同時に_disposablesにAddToしておいて
ダイヤログが閉じたときに、呼ばれるOnDialogClosedメソッドの中で_disposablesをDispose()する実際に動作している動画以下ログに説明を入れたもの。（キャプチャした時のログとは違うので、数字が異なる箇所もある）繰り返しになるが
ダイヤログのビューとビューモデルが破棄された（デストラクタが呼ばれた）あとでも
メンバ変数のオブザーバーが動きつづけるあたり、よくわからないなににせよ、よそのクラスのIObservableをToReactivePropertyしたときにはAddTo()することを
忘れないようにしておけばいいと思う本題よりも、RxのHot/Coldの理解に時間を割いた気がする


