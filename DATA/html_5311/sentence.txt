More than 3 years have passed since last update.今日こんなコードに出会ってよく理解できなかった。しかし、ここから、Multithreaded execution was detected. がスローされているのは間違いない。しかしやってることがよくわからなかった。DurableOrchestrationContext.csコードを調べていると結局 Thread.CurrentThread.ManagedThreadId が現在のスレッドで、このクラスが初期化されたときに、owingThread にスレッドIDが記入される。つまり、ここで、セットしたスレッドIDと違っていれば例外をスローする。つまり、シングルスレッドしか許されていないことを表現するためのコードの様子。さて、じゃあ、マルチスレッドが発生するようなコードを試しに書いてみた。実はなかなかうまくいかなかった。スレッドプールは相当優秀な様子。しかし、Parallel.For や、親子のスレッドを作ること再現できた。この実行結果はこんな感じ。クラスのなかで、Async のクラスを何回も呼びまくっても、スレッドプールがうまくやっているため、スレッドが切り替わっていないのもわかる。親子や、Parallel.For だと様子が違うみたいだ。もともとはこのコードは、Durable Functions で、マルチスレッドのコードを禁止するためのコードだ。しかし、残念ながらスレッドプールがあるため、必ずしもマルチスレッドのコードが出てくとされるわけではない。だから、注意書きに次のように書いていたのだろう。TODO: これは、ベストエフォートの解決策。async の仕事がスケジューリングされても、同じスレッドで実行される可能性がある。Durable Functions から、クロススレッドを検出するための唯一の保証された方法。この部分のテストはフリーキーだけど、それもうなづける内容。スレッドプールは本当に優秀だな。しかし、残念ながら、なぜ、このエラーが発生したのか知りたいところ。コードをもっと読んでみよう。


