More than 1 year has passed since last update.さてさて始まりましたXamarin Advent Calendar 2018の6日目として、生Xamarin.Macでのアプリケーション作成をお送りしたいと思います。
ただ、StoryboardやInterface Builderを使用した例は、Web検索すればいくらでも見つかります。
なのでハードモードと称して、Web検索してもあまりサンプルが見つからない、コードだけでの作成(Nibless Application)をお送りしたいかと思います。Xamarin.Macによるアプリケーション作成のため、MacOS環境での.NET上の開発となります。
あと私は日和っているので、Visual Studio for Macでの解説となりますがご了承をば。ここでは、Xamarin.Mac込みでVisual Studio for Macがインストール済みで話を進めます。
記憶が定かではないですが、インストーラー回せばいい感じに勝手にいい感じにセットアップしてくれたように思えます。プロジェクトテンプレートとして、Mac &gt; アプリ &gt; Cocoa アプリの順に選択し、プロジェクトを作成します。Niblessアプリを作成するための準備として、info.plistを開き、ソースを選択します。NSApplicationStoryBoardFileの行を削除します。MainWindowController.csを新規ファイルとして追加します。アイテムテンプレートとして、General &gt; 空のクラスの順に選択します。名前は、MainWindowControllerとします。親クラスとして、AppKit.NSWindowControllerを指定します。次いで、コンストラクタを作成します。
サイズを指定してウインドウを初期表示したいため、コンストラクタでサイズを受け取れるようにします。
以降、using指定は、適宜追加してください。ウインドウコントローラーのインスタンス化、および表示するコードを追加します。明示的にAppDelidateをインスタンス化し引き渡します。とりあえず、空のウインドウが表示されたかと思います。ただ、MacOS村に旧くから受け継がれている慣習により、メインウインドウを閉じてもアプリケーションは終了しません1。
あえて風習に逆らうのもどうかと思いますので、次章で、メインメニューからの終了の選択でアプリケーションを終わらせるよう修正します。AppDelegate#WillFinishLaunchingにメインメニュー初期化のコードを追加します。Quitメニューアイテムに選択された場合のイベントハンドラを追加しています。
このイベントハンドラで、有無を言わさずアプリを終了させています。メニュー &gt; Quitの選択で、アプリケーションの終了が確認できます。空のウインドウを表示しただけでは面白くないので、次章で何か部品を置けるようにしてみたいと思います。NSWindowはただの枠なので、部品を置けるようにするためにはコンテナを用意してあげる必要があります。ContainerViweController.csを追加します。アイテムテンプレートとして、General &gt; 空のクラスの順に選択します。名前は、ContainerViweControllerとします。親クラスとして、AppKit.NSViewControllerを指定します。Macアプリは、nibリソースが存在することを前提としている節があります。
そのため、nibのないViewControllerは、実行時にエラー吐いて落ちます。niblessでコンテナを扱えるようにするため、NSViewController#LoadViewメソッドが用意されています。
これをオーバーライドすることで、niblessなコンテナを作成することができます。コンテナが割り当てられたことがわかるよう背景色をつけています。領域がうっすら色づいたウインドウが表示されます。次章で、このコンテナにボタンを貼り付け、クリックでメッセージを表示させます。ContainerViewController#ViewDidLoadで、ボタンをインスタンス化し、コンテナに追加します。
ボタンには、クリックされた場合のイベントハンドラも割り当てておきます。実行すると、ウインドウ内にボタンが表示され、クリックするとメッセージが表示されます。ただ、場所がなんというか・・・。
使う側視点として、上から下に配置するため、できれば座標も上から下に向けて大きくなって欲しいところ。左上が原点に指定する方法がXamarin.mac (cocoa)には用意されてはいます。
がしかし、実はそんなことをしなくても、別の方法で解決することができます。
次章で、その方法を説明します。Xamarin.mac (cocoa)は、Mac は OS X Lion以降、AutoLayoutというレイアウトシステムが用意されています。
これは、親子間の相対的な位置や、もしくはサイズ指定により柔軟に配置を行えるようになるものです。日本語で書かれた解説やチュートリアルが既に多く存在しているため、ここでは詳細については述べません。AutoLayoutによる配置を行わせるために、NSViewController#UpdateViewConstraintsメソッドをオーバーライドします。このメソッド内で、コンテナとボタンとの相対位置関係を定義します。
ここでは、ボタンをコンテナの左上から(100, 50)の位置に配置させます。実行すると・・・・、あれボタンが表示されません＞＜実はAutoLayoutを有効にするのに、これだけでは不十分で、以下の2点を行う必要があります。コンテナを含むすべての部品に対して、NSView#TranslatesAutoresizingMaskIntoConstraintsプロパティの値をfalseに変更する。AutoLayoutベースで、配置することを宣言する。前者は、単にプロパティを変更するだけです。
AutoLayoutベースを予定しているため、ボタンのインスタンス化の際のサイズ指定も取り除いています。後者は、NSView#RequiresConstraintBasedLayout()メソッドの戻り値がtrueの場合、AutoLayoutが有効になります。
staticメソッドであるため、new修飾子をつけて、メソッドを置き換えます。
また、ExportAttributeで置き換えの意思があることも宣言しておきます。忘れると有効になりません(1敗)。今回は、ContainerViweController.csにNSViewの派生クラスを用意します。ContainerViewController#ViewDidLoadで、利用するViewを差し替えます。実行すると、ボタンの配置が変わったかと思います。ボタンをコンテナ中央に配置したい場合は、以下のようにします。実行すると、ボタンがウインドウの中央に配置されます。Xamarin.Macを用いたNibless Applicationの作成について、プロジェクトの作成から、またハマりどころについて解説しました。もっとも、全宇宙の99.999999999%の人類は、Storyboardを用いて、アプリケーション作成を行うと思われますので、この記事が役に立つこときっとないでしょう（なぜ書いたし）。NSApplicationDelegate#ApplicationShouldTerminateAfterLastWindowClosed()メソッドをオーバーライドし、trueを返させることで、Windowsっぽい挙動にできます。 ↩


