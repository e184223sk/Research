More than 1 year has passed since last update.気になった記事の該当部分のコピペ抜粋です　あとできっちりまとめる予定Rxの場合do 自分の外の状態（Counter2）を変更する分かりにくいクロージャ
map 引数の値を2倍にして返すだけ。それ以外に余計なこと(クロージャ外の状態変えたり)しない分かりやすいクロージャ
do データベースを操作しローカルの環境を大きく変える分かりにくいクロージャ
subscribe 自分の外の状態（Counter）を変更する分かりにくクロージャ
Rxでは登録したクロージャは分かりやすいもの、そうでないもの、明確な区別なくObserverに保持されます。また今回はmapを分かりやすいクロージャにしましたが、
map内でスコープの広い状態の変更やデータベース操作などをすることで、分かりにくいクロージャにすることもできます。この辺は制約が無いため、Rxを使う人によってかなり幅がでます。Doメソッド
DoメソッドはIObservableから発行された値を受けて処理を行うだけのメソッドです。5.4.1のDrag処理でも使用しましたが、要素を受け取って処理を行いIObservableの要素に対しては何も加工を行ったりしません。コード例を下記に示します。このコードを実行すると、Subscribeで値を購読している処理の前にDoの処理が行われていることが確認出来ます。IObserverオブジェクトの詳細
最初の「同じ実行結果のRxとforeach文のコード」の例ではIObserverインターフェイスのメンバのうち、OnNextメソッドのデリゲートしか記述していなかった。このOnNextは、値がオブザーバに届くたびに実行されるメソッドで、最も利用されるものだろう。残りの2つのうち、OnErrorは例外発生時に実行されるメソッド、OnCompletedはシーケンスが完了後に実行されるメソッドを表す。これら3つのメソッドのデリゲートを指定する場合の、Subcribeメソッドのコード例を示す。 do-vb.vbOnError／OnCompletedメソッドのデリゲートを含めたSubcribeメソッドのコードの実行例（上：C#、下：VB）
Doメソッドはパイプラインを通過する値に処理を加えて、元の値はそのまま後続へ渡す。今回は値が「3」のときに例外を発生させるようにした。 
上記のコードを実行した場合、Rangeメソッドにより「1」～「5」の値の生成が完了すると、OnCompletedメソッドが呼ばれる、もしくは途中で例外が発生するとOnErrorメソッドが呼ばれるのが確認できるだろう。なお、OnErrorメソッド、もしくはOnCompletedメソッドは、どちらか片方しか呼ばれることはない。つまり、OnErrorメソッドが呼ばれた後にOnCompletedメソッドが呼ばれたりすることはない。また、OnErrorメソッド、もしくはOnCompletedメソッドが呼ばれた後にOnNextメソッドが呼ばれることもない*3。*3　この法則はRxに標準で用意されているメソッドではすべて守られている。また、メソッドを自作する場合でもObservable.CreateメソッドといったRx標準で用意されている生成メソッドを用いれば守られる。さらにSubscirbeメソッドの呼び出し時にもRxで用意されているObserver（前述のSystem.ObservableExtensionsクラスによる拡張メソッド、もしくはObserver.Createメソッド）を使えば自動的に守られるようになっている。このように、幾重にも渡って法則が厳守されるようになっているため、ほぼ100％この法則が破られることはないが、IObservable&lt;T&gt;／IObserver&lt;T&gt;オブジェクトをすべて一から自前で実装する場合は、この法則に反する挙動をする可能性もある。ただし、そのような実装はすべきではない。安全のためにも、IObservable&lt;T&gt;インターフェイスやIObserver&lt;T&gt;インターフェイスを実装する際は、極力、Rxに用意されているObservable.Create／Observer.Createメソッドを利用して実装すべきだろう。どうしてもそれらが利用できない場合は、法則を守るように注意深く実装する必要がある。


