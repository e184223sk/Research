More than 1 year has passed since last update.こちらの記事を参考にセーブデータをローカルのファイルに書き込む際、自分なりの書き方を紹介します。PlayerPrefsと同じような使い方で独自クラスもセーブできる機能実装【Unity】【セーブ】【Json】自分の場合、セーブしたいデータのほとんどをGameManager classで管理してます。
Save用メソッドとLoad用メソッドも同じ場所に書きます。
（どこかにまとまっていた方が管理しやすいと思います）Unityでセーブデータを管理する場合、EasySaveなどのアセットを使う方法もあります。
しかし、それを使う場合、データの持ち方によってはセーブできない場合があります。特に問題なのが、EasySaveだと自作したclassのListをセーブできません。
簡単なゲームであれば回避しやすいですが、RPGやカードゲームのようにデータが複雑になりやすいゲームだと回避が難しい問題です。今回のGameManagerで言えば、
public List&lt;Character&gt; ownCharacters = new List&lt;Character&gt;();
が当てはまります。更にCharacter classを見ると
public List&lt;SkillBase&gt; skills = new List&lt;SkillBase&gt;();
を持っており、更に入れ子になってます。こうなってしまうとEasySaveではお手上げに近いです。しかし、JsonUtilityを使ってJsonにして丸ごと保存！とすればいくら入れ子になっていても大丈夫です。ただ、JsonUtilityでファイルに書き込む部分の実装を自分で書くと大変なので、冒頭で紹介したコードを拝借するのがいいと思います。また、セーブデータをバックアップしたり、データ移行する際もJsonファイルごと移し替えれば済むので、シンプルに解決しやすいメリットも大きいです。１．セーブするclassには忘れずに[System.Serializable]を付けましょう。
　　[SerializeField]ではダメです（※冒頭のリンク先では間違って記載されてます）２．最後にSaveData.Save();を忘れず実行しましょう。１．セーブ時のkeyと同じkeyを使いましょう（書き直しやコピペで書いてるとうっかりミスしやすいです）２．ScriptableObjectもセーブされますが、そのままだとアップデートで問題が発生します。
書き込まれたセーブデータファイルを見てみると分かりますが、ScriptableObjectやSpriteなどのフィールドは、オブジェクトID（正確な用語は違うかもしれません...）としてシリアライズされてます。アップデート時にこれらが変更される場合があるようで（具体的なトリガーは正確に把握してません）、アップデートしてアプリを立ち上げると参照先がぐちゃぐちゃになったり、Spriteをうまく参照できずに画像が表示されなくなったりする不具合を確認しています。自分の解決方法は、ScriptableObjectがキャラクターやスキルなら、それらのIDもintやstringでセーブして、アプリ起動時にIDをkeyにマスタデータから取得し直すようにしました。なお、IDはScriptableObject継承classを取得する際、同時にScriptableObject継承クラスに設けたidフィールドを取得して初期化します。「ロード時の注意点」で紹介したように、ScriptableObjectがオブジェクトIDとしてシリアライズされるせいでハマる落とし穴はありますが、メリットもあります。それは、セーブデータのファイルサイズをコンパクトにできることです。もしScriptableObjectでないCharacterclassにキャラクター名やキャラクターの説明、その他ステータスといった情報も全て記載してしまうと、それらも全部Jsonとしてシリアライズされてファイルに書き込まれます。これはキャラクターが増えるごとに膨れていくため、キャラクターが10体くらいなら問題は小さいですが、これが何百体にも及ぶようだとサイズが大変なことになります。自分のゲーム『ReRotation』はポケモン風のキャラクターデータがあり、多い人だと300体以上のキャラクターを保有できますが、それでもセーブデータのサイズは300KBに届きません。この工夫がなければきっと10倍以上になったことでしょう・・・解説は以上になります。
駆け足で書いたので不足があれば追って補いたいと思います。


