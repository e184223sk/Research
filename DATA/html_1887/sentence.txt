More than 1 year has passed since last update.Freeradicalの中の人、yamarahです。
普段は、Autodesk InventorのAddIn作成に関する記事を書いています。
今回は、WPFのDataGridにおいて、複数選択を許可した場合に、選択状態をどのようにViewModelにbindするかという記事です。
WPF自体は詳しくないので、おかしな点があればご指摘歓迎です。20.02.21 17:55 JST 追記
やっぱり仮想化をオフしないと、連動しませんでした。
具体的には、視界外のIsSelectedをtrueにしても、無視されるようです。
解決策が見つかれば、記事を更新します。work aroundがあれば、よろおねです。まず前提として、DataGrid.SelectedItemsはbindできません。単選択なら問題になりませんが、複数選択の状態を知るには少し手間が必要です。
では、方針ですが、概ね次の記事に従います。リンク : ListViewの選択項目を取得/設定するつまりは、ListViewItem.IsSelected に対するバインディングは OneWay (VM -&gt; Vのみ)にする
ListView.SelectedItems の内容は一切信用しない
VからVMへの反映は、SelectionChanged イベントで自力でやるということです。
SelectedItemsのようなCollectionを用意するのではなく、各Item内のIsSelectedを選択状態と同期するようになります。
ただし、折角だからコードビハインドは嫌だよね、ってことで、Behaviorを使って実装します。Behaviorに汎用性を持たせたいので、IsCheckedはData型に直接書くのではなく、基底classに書いてそれを継承するようにします。では、これを継承したテスト用のclassを作ります。SelectionChangedをhookして、選択状態の変化を各Itemに設定します。やっぱり、選択数は欲しいですよね。ItemsSourceをなめてIsSelectedを数えるのは非効率なので、これもBehaviorを作ります。さて、いよいよxamlに記載・・・の前に、xaml内にBehaviorを記述するのに準備が必要です。
ググると、BlendのSDKを・・・という記事がヒットしますが、VS2019では勝手が違うので注意。
リンク : 新しい Behavior ライブラリへの更新 #27
xamlの名前空間指定は、次のようになります。まずは、Viewから。です。bind方向の指定は、上記の通りに忘れず設定してください。せっかくコードを書いたんだから、SelectedItemsCountのModeのDefault値をOneWayToSourceにしたかったのですが、簡単には出来ないようなので諦めました。次に、ViewModelです。実際のアプリケーションでは、SelectedItemsCountにReactivePropertyなどを使うことになるでしょう。では、これらのコードでWindowを表示してみましょう。(スタートアップのコードは、各自でどうぞ)

選択状態を変化させると、上端の選択数と、左端桁のTrue/Falseが変化するのが見て取れます。という方は、次の記事を参考にどうぞ。
リンク : WPFのDataGridで選択された複数のアイテムをバインドするためのビヘイビア


