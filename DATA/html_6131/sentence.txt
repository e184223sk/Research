More than 3 years have passed since last update.【C#】LINQ備忘録1 ～初級編～を投稿して、約10か月経ちました。
勿論、まだまだ勉強不足のところはありますが、業務や趣味で遊んでいく中で10か月前よりもC#が使えるようになり、やっとC#erとしてのスタートラインに立てた感じがします。ほんと、C#最高っす。今回は、LINQの集計メソッドを使って計算を行う方法を備忘録的に残したいと思います。今回も前回と同様に、foreach・forを使って求める方法と、LINQで計算を行う方法を２通り紹介していきます。今回のサンプルソースはGitHubに公開しています。
https://github.com/logikuma1024/LinqRemind2集計とは？寄せ集めたいくつかの数を合計すること。また，合計した数。（Weblioより）集計メソッドは、要素集合の中の値を計算し、計算結果を返します。
LINQの集計メソッドには下記があり、合計だけではなく、それぞれ特定の計算結果を返すことが出来ます。それぞれSQLの集約関数ライクなメソッドになっており、求められる計算結果を集計して返すことが出来ます。列挙の中の値の計算がしたいことは非常に多いので、活躍機会のとっても多いメソッド群です。今回は例が集計メソッドということもあり、下記のようなデータソースを用意し、これに対してクエリを行っていきます。表にすると、下記のような形になります。Sumは、シーケンス内の要素の合計を返します。実行結果
SUMは、値を合計することが出来ます。今回の例では合計したい部分が表の中の「Score」列だけなので、その部分を抜き出し、Sum()メソッドで集計しています。foreach版と比べ、やりたいことに日本語的に即しているので、可読性が高いように感じます。
このコードは更に短縮できます。Sum()メソッドにはFunc&lt;TSource,hoge&gt;を指定するオーバーロードがあり、Selectの中で行っている射影処理をSum(x =&gt; x)として記述することが出来ますこうすると、かなりスッキリ集計処理を行うことができますね。集合の中の欲しい部分のみを指定すればよいので、考え方も難しくなく、使いやすいメソッドです。Countは要素の個数を返します。実行結果
どうでしょう。従来のforeachを用いた書き方ではどうしてもループにif文が挟まり、可読性の低いコードになっていましたが、Linq版は１行でとってもスマートになります。Sumの時にSelectを省略出来たのと同様に、Countの時はWhereを省略できます。実際に実務でもよく使うコードだけに、基本は押さえておきたいです。Averageは、要素の平均値を計算します。実行結果
これもCountと同様、かなりコードがきれいになります。どうしても計算が絡むとコードが複雑になり、計算式の間違いからミスが生まれたりもしますが、Linqを用いて算出すると確実です。また、count変数の初期値が0なのは、除算を行うのにかなり危険な気がします。使いましょう、Average。Maxは、シーケンス内の最大値を抽出します。実行結果
foreach版のretの扱いが難しく、何度か想定しない結果が返ってきました。で、foreach版のコードとしての可読性はやはり高くありません。ここで抽出するものは「最大値」なのですから、Linqで用意されているMaxメソッドを用いた方が、日本語的にもキレイに見えます。Minは、シーケンスの中の最小値を抽出します。実行結果
Maxと同様に、こちらは最小値を求められるメソッドです。foreach版ではいわゆる「HighValue」を定義する必要があったのに対し、Linq版では意識する必要がありません。Aggregateは、シーケンスの各要素に式を適用し、計算結果を求めます。実行結果
Aggregateは、式に計算式を適用して畳み込みを行います。言葉で書くと結構わかりづらいので、図でイメージを書いてみました。
Aggregate関数は、元となるシーケンスに順次計算式を適用して、シーケンスの最後まで計算を実行、作成した値を返却します。シード値は計算の一番先頭に入れる集計結果のベースとなる値、計算式は各ステップで実行する計算式です。例ではAggregateによって1,〇,△,□を順次積算していって、最終的な答えを出しています。
Aggregateは式をカスタマイズしてやれば様々な計算が出来ます。Sum・Count・Max・Min・Averageではカバーしきれないものについて、良い感じに使ってみたいです！Aggregateのオーバーロードを使って、計算結果をさらに処理してみます。実行結果
Aggregateメソッドのオーバーロードを用いて、処理した結果を射影し、出力結果を作成しています。Person自体をAggregateしているので、シードはmembers.First()として集計しています。今回の例のように、オブジェクト（今回はPerson）のプロパティを計算する場合はforで回すとindexの管理が必要になり、煩雑でした。Aggregateを用いるとスッキリと纏めて書くことができるので、とても素敵です！昨年からC#を使い始め、そろそろC#erとして１歳になります。.NET CoreやWPF等色々触ってきましたがどれも魅力的で、覚えることが沢山ありとても楽しいです。今後もC#について色々学んでみたいと思います。C#ってステキ！MSDN
https://msdn.microsoft.com/ja-jp/library/bb896340(v=vs.110).aspx[C#] Aggregateを使う[LINQ]
https://chomado.com/programming/c-sharp/c-aggregate%E3%82%92%E4%BD%BF%E3%81%86linq/ C# やるなら LINQ を使おう
http://yohshiy.blog.fc2.com/blog-entry-274.html


