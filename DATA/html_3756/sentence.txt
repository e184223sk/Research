More than 1 year has passed since last update.リフレクションは遅いので、それを少しでも高速化できればと式木について調べたので、逆引き的な感じでやり方をメモしておこうと思います。
（なので新しいものとかあったら随時更新予定）なお、基礎的なところは以下の記事が色々と比較しながら記載してくれているので参考にしてみてください。
本記事は、ある程度知識がある状態で、「これはどうしたらいいんだ？」というのを解決するためのメモです。まずは簡単に、引数をふたつ取ってそれを加算し返すだけのシンプルな式木を作成してみます。次に、配列とそのindexを引数に渡して合計するサンプルを作ってみます。さて、もう少し実践的なところで、インスタンスを生成する処理を見てみます。シンプルですね。インスタンスの生成には Expression.New を利用し、引数には Type 型の値を渡します。さて、次は引数付きのコンストラクタを持つクラスのインスタンス化についてです。
通常、引数を伴わないコンストラクタだけでプログラムをすることはまずないと思うので、引数を扱うのは必須ですね。上記のインスタンス生成は、引数なし／引数ありのコンストラクタを呼び出す処理でした。
それとは別に、初期化子を伴ったインスタンスの生成は以下のようになります。今度は該当クラスのプロパティ／フィールドにアクセスする式木を構築してみます。
なお、public / private 関係なくアクセスできるようです。ちなみに以下のような式の想定です。こちらの例は、コンストラクタ引数や初期化子などを利用せず、生成したインスタンスに対してプロパティ経由で値を設定して、その生成したインスタンスを返す、というケースです。
イメージ的には以下のようなコードを、式木を使って生成します。なお、こちらのコードは以下の記事を参考にさせていただきました。引数でベースクラスを受け取り、それを使用したいクラスにキャストして利用する、みたいなケースです。
本来はあまりお行儀のよくない処理ですが、今回実装にチャレンジしているメタプログラミングはあるシステムを構築する場合なので、利用ケースは限定的であり、安全に利用できる前提での話となります。Expression.Callを利用してConvertクラスのメソッドを呼び出します。なお、今回利用したのは以下のシグネチャを持つメソッドです。（→ドキュメント）余談ですが、Unaryは「単項」という意味の単語なので、それ単体で意味を成す式、という感じでしょうか。


