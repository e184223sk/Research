More than 1 year has passed since last update.【Blazor入門】Blazor初心者がログインからチャット機能まで付けてデプロイしてみた ～その1～
の続きです。前回までは、ログイン画面をそれとなく作って、チャットページに遷移するまで作りました。
今回は実際にチャットができる所までやってみたいと思います。そこまで難しくないので頑張っていきましょー新たに、Chat.razorファイル・Char.razor.csファイルを作りましょう。
これを実行してみると、ブラウザ間の通信がうまくいきません。
それもそのはず、SignalRが未実装だからです。
SignalRとは何ぞや、というのは以下の記事が参考になると思います。
ASP.NET SignalRを知る (1/5)簡単に言えば、サーバーとクライアント間の非同期通信を簡単に実装できるフレームワークです。
SignalRを使用した典型的な例としてチャットが挙げられるので、今回はチャットを作成します。.NET MVCでもSignalRを実装した事がありますが、当然(?)ながら当時はJavaScriptを使用してクライアントへの画面描画を行っていました。しかしBlazorではクライアント処理もフルC#で書くことが出来る為煩わしさが若干軽減されます。NugetからMicrosoft.AspNetCore.SignalR.Clientをインストールします。
(Microsoft.AspNetCore.SignalR.Client.Coreではなく。)あとは、Chat.razor.csを以下のように書き換えてください。コンストラクタに書いても良かったんですが、OnInitializedAsyncメソッドを使用する為にComponentBaseクラスを継承しています。(razorファイル内でのコンストラクタってどうやって書くんだろう。。。)ハブの追加は以下のページに詳細に書いてあるので、この手順に沿って追加すればおｋ。
ASP.NET Core SignalR を Blazor WebAssembly と共に使用するソリューションにHubsフォルダとChatHub.csを追加。
メッセージを受け取ったら、全クライアントにメッセージを流す処理を追加する。全部載せる必要もないと思いますが、上記のURL通りにStartup.csを以下の様にSignalRに対応させる記述を書きます。これでSignalRの実装ができました。実際に動作を見てみましょう。
どういう順序で処理が発生しているのかを追ってみましょう。①まず最初に、[送信]ボタンを押す所から処理がスタートするので、Chat.razorを見ます。②送信ボタン押下時に発火するのはSendAsyncメソッドであり、この処理が紐づいているのはコードビハインドとなります。③SendAsyncメソッドでは定義したChatHubのSendMessageClientsAllメソッドを呼んでいます。④SendMessageClientsAllメソッド内でReceiveMessageが呼ばれます。これはChat.razor.csのOnInitializedAsyncメソッドでハブを定義した際に作った処理です。⑤送信時に入力されているメッセージが_messagesに追加され最後にStateHasChangedメソッドを呼ぶ事でChat.razorの処理を通って画面に反映されます。今の記述だと、メッセージを送信する為に毎回ボタンを押す必要があり、少し手間です。
そこでEnter押下時にもメッセージが送信されるように修正してみましょう。修正方法としては簡単で、@bind:event="oninput"と@onkeydown="KeyDownAsync"を付けてください。@onkeydown="KeyDownAsync"はわかりやすいと思いますが、割り付けている項目に対してキーダウンイベントを発生させるようにします。@bind:eventにはデフォルトでは@bind:event="onchange"が割付いており、これはフォーカスロストした場合に発火します。つまり文字を入力して次にエンターを押下しても、項目に対してフォーカスが入ったままなのでプロパティに反映されず_messageInputにはnullが入っている事になります。これを避ける為にも、@bind:event="oninput"とすることにより入力文字が変化する度にプロパティへの値の反映をさせることができます。あとはKeyDownAsyncメソッドを追加して、Enter押下時にのみSendAsyncメソッドを呼び出すようにしてあげれば完了です。もし分かる方がいらっしゃれば教えて頂きたいです。
SignalRの自動再接続についてです。以下の様にWithAutomaticReconnectメソッドを噛ましており、RandomRetryPolicyクラスを引数として渡しているのでサーバーが落ちた場合に2～5秒おきに無限回の再接続要求がされると考えていました。次のような想定
1. デバッグでサーバー側を起動
2. 同じURLを指定し、別のタブでチャットを起動
3. デバッグを終了
4. デバッグを再開
5. 2で開いたタブが2~5秒おきに再接続を試みており復帰しかし実際には、サーバー側が復帰してもクライアント側は自動接続されず、リロードが求められてしまいます。
ReconnectedイベントにStartAsyncメソッドを実装しているのでリロードを必要とせず復帰するかと思いきやそんなことはなかった。何か思い違いをしているのでしょうか。。。SignalRを使った場合でもBlazorであればフルC#で書けることが分かりました。Enter押下時の処理などもJavaScriptでif(keycode == '13'){}などのような記述をしていたりしましたが、@onkeydownと書くことにより処理をC#に任せられるというのはかなりよいですね。次回は正しいユーザーでログインした場合にログインを許可するような実装を行います。参考にさせて頂いたページ


