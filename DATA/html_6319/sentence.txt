More than 3 years have passed since last update.利便性を考えて、アプリで特定のMenuItemにキーボードショートカット（ex. Ctrl+Oで「開く」）を導入することがよくあります。
しかし、WPF標準のMenuItemではKeyGestureの説明表示は出来ても、その検出は出来ません。
そのためMenuItemとは別に、Window直下に検出するKeyBindingを書かなければいけません。
これは同じような記述を離れた場所に書くことになり、バグの原因になります。
そこで、KeyBindingを受け取ることのできる拡張MenuItemを作ることで、この問題を解決します。
こんなアプリを題材にします。
Menu-&gt;Hogeを選択するか、Ctrl+Hを押すと、TextBoxに"-Hoge"が追記されます。ViewではGridで区切って上にMenu、下にTextBoxが置いてあるだけです。コードビハインドには何も書いていないので省略します。ViewModelは今回の本題にはあまり関係ありませんが、以下のとおりです。
HogeCommandが使用されたらMyTextに"-Hoge"と追記します。
ReactivePropertyを使用していますが、他のMVVMライブラリでも話は同じだと思います。ViewにWindow直下のKeyBindingとMenuItemがあります。両者はともにHogeCommandとKeyGesture(*)を含んでいます。
今は短いから問題には感じませんが、これが膨大なMenuを持つアプリ（ex. VisualStudio）になったら、両者が食い違っていても、コードから発見するのは困難でしょう。(*) MenuItemのInputGestureTextは単に指定したテキストをMenuの右側に表示するだけで、機能は持ちません。
InputGestureTextに書いたのに応答しない！という罠はこれを利用した全員がはまる通過儀礼のようなものです。
名前をGestureCaptionとかにしとけば、もう少し混乱が少なくて済んだのになぁ。この問題の解決で最初に思いつく方法はMenuItem自体にKeyBinding機能を持たせることです。
しかしKeyBindingはその時Focusがあるコントロールでしか検出できません。
つまりMenuItemに実装しても選択されている時以外は動作しない無意味なKeyBindingになってしまいます。
そこでKeyBinding自体は通常通りWindow直下で実装して、それをx:Nameで拡張MenuItemに渡してしまい、そこからCommandとKeyGestureを同期します。まずKeyBindingを受け取るMenuItemを継承した拡張MenuItemです。依存関係プロパティとしてKeyBindingを受け取り、中身を継承元MenuItemのCommandとInputGestureTextに渡しています。
InputGestureTextにはKeyGestureを現在のCultureでローカライズした文字列(ex. "Ctrl")を設定します。
なおKeyGestureのModifierKeysやDisplayStringを使用しても"Control"や空白になっており、うまく動きません。使用する際はWindowのKeyBinding側にCommandとGestureを書いて、x:Name経由で拡張MenuItemにKeyBindingごと渡します。ViewModelと実行結果は同じです。VisualStudio2017
.NET Framework 4.6
C#6今回はKeyBindingにx:Nameをつけ、KeyBinding経由でCommandとKeyGestureを共有しました。
別の方法として、Command側にKeyGestureを埋め込む方法もあります。How to Display Working Keyboard Shortcut for Menu Items?-stackoverflow中段あたりのCommandWithHotkeyの回答


