More than 3 years have passed since last update.SC（非公式）Advent Calendar 2017 の１９日目です。Azure Storageのセキュリティ周りについて調べる機会があったので、
まとめとしてのPOST。Azure Portalから設定できるものは設定するセキュリティホールというと大袈裟ですが、
Azure StorageはPrimaryとSecondaryの2つのアクセスKeyで運用しています。
うらを返せば、Primary Keyが流出したら、基本的にはBlobに格納している全データにアクセス可能になってしまいます。
公式には、2つのKeyを運用レベルで切り替えて片方をRegenerateしてくださいってことなんだそうです。お客さんによって、コンプライアンスに引っかかるということがあると思います。
何かしらセキュリティ対策をしないといけない。先のサービスの暗号化とはちがい、Blobに格納する前にアプリケーションで暗号化をかけましょうという話。AzureのSDKもそのユースケースに対応したクラスが用意されています。Uploadするときに、BlobRequestOptionsにEncryptionPolicyを追加することによって、RsaKeyで暗号化されます。Downloadするときも同じポリシーを指定します。地味にC#7.1の新機能非同期Mainを使ってみました。
やはりC#の書き心地はいいです。もう一つの有効な手段として、SASを指定して、基本的にはSAS経由でアクセスする方法があります。複数のアプリがアクセスKeyを持つのではなく、1か所で管理して、それ以外のアプリは、SASをもらうという設計です。以下はSasSampleMain.exeからSasSampleWorker.exeにSasUriだけを渡して、任意のAzureStorageBlobへのアクセスを許可しています。Workerクラスの方では、
containerSasUriでsas-read-containerのSasRead.txtを読み取って、
"_Sasで取得したデータ"という文字列を追加して、
outContainerSasUriでsas-write-containerのSasWrite.txtにアップロードするシナリオです。SecOpsの観点からいくと、クライアント暗号化した時も、SASを使用した時も、結局Storageのアクセスキーを運用でローテーションさせていくことになります。
次回はAzure Key Vaultを使用してアクセスキーの自動ローテーションを試してみたいと思います。


