More than 1 year has passed since last update.これは「オフラインリアルタイムどう書く E29」で出題された「アンエスケープ」という問題のC#による実装例です。問題 : http://nabetani.sakura.ne.jp/hena/orde29unes/
実装リンク集 : https://qiita.com/Nabetani/items/f2db9b916c0a301b744f問題は、「ファイルパスの文字列表現が与えられる。区切り文字は / だが、ディレクトリエントリ名の中でも使うことができる。その際は、// と二重に書くことでエスケープするか、"  " または '  ' のようにクォートする。与えられた文字列表現を解析して、生のディレクトリエントリ名のリストを出力せよ。」です。細かい制約などは上のリンク先を読んでください。出題はファイルパスと言っているけど、ダブルクォートのあたりはなんだかCSVにも似ているな。ってことはこの問題を解いていれば、CSVパーサーを実装する練習にもなりそうだ。俺は詳しいんだ1。さてこの記事では、わりとまじめにパーサーを実装して問題を解いてみます。「わりとまじめに」というのは、コードの短さよりも丁寧さを優先する、という意味です。パーサーの実装方法として、「有限ステートマシン」「パーサーコンビネーター」の２通りを試しました。パーサーが1文字読み取るごとに内部状態を遷移させ、それに応じて出力が変わる、というかっこうです。たとえば「"を読み取ったのでダブルクォート状態に遷移する」とか、「/を読み取ったのでエスケープ状態に遷移する」とか、そのようなルールをもれなく矛盾なく構成する感じです。出力を伴う有限ステートマシンには、出力が内部状態だけに依存する関数となるもの（ムーア・マシン）と、出力が入力と内部状態の両方に依存する関数となるもの（ミーリ・マシン）の2通りがあります。今回は入出力の文字種がそこそこあるので、状態数を減らすためにミーリ・マシンを選びました。コードの前に、状態遷移図を見てみましょう。ではコードです。テストコード部分は飛ばして構いません。コアは MealyMachineクラスのNext静的メソッドです。現在状態と読み取った文字の2つを引数として、次の状態と出力のタプルが戻り値になっています。中身は巨大な switch 文を複数メソッドに分割した形になっています。状態遷移図を愚直にコードに落としているのがわかるでしょうか。パーサーコンビネーターというのは簡単に言えば、ごく小さなパーサー部品（たとえば、「二重引用符を一文字読み取る」など）を関数として作り、関数合成によって部品を組み合わせていき、最終的に目的のパーサーを作り上げる、というものです。このスタイルでパーサーを作る場合は、状態遷移図をステートマシンで表現した例とは違い、パーサーが正しく読み取れる文字列の集合を形式言語として文法定義して、それをコードに落とすことができます。形式文法といえばBNFやEBNFが有名ですが、ここではPEGという文法でファイルパスのパーサーを定義してみます。PEGは、PEGで書かれた規則を左から順に試していくことが決められているもので、曖昧さが存在しないかわりに左再帰ができない（無限ループに陥る）という特徴があります。詳細はWikipediaのページを読んでください。コードの前に、今回の問題をPEGで表現してみたものを見てみましょう。一番上で定義されたファイルパスは、「空でないファイルエントリーが1つか、または複数の空でないファイルエントリーがセパレーターで区切られたもの」となっています。こちらも、ファイルエントリーが空ではないことを表現するのがちょっと面倒でした。そして途中は飛ばしますが、一番下にあるのが終端記号で、「スラッシュ」「二重引用符」「引用符」「英数字」「二重引用符の内側で使える文字」「引用符の内側で使える文字」が定義されています。ではコードです。ネタです。 ↩今回のコードではSpan&lt;T&gt;は使えませんでした。Span&lt;T&gt;はスタック上に置かれることを保証するため、ジェネリック型引数にできないという制約があります。 ↩関数型言語に馴染みのある人向けに言うと、このメソッドのシグネチャはflatMapとmapを合成したものになっています。それは、本文で書いたようにLINQのクエリ構文を使うために満たさないといけないルールなのですが、なぜflatMapそのものではないかというと、ネストが深くなるとコンパイルに時間がかかってしまうから、とのことです。これとかこれにそのことが取り上げられています。 ↩


