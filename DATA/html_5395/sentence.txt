More than 3 years have passed since last update.UnityのCoroutineは基本StopCoroutine(),StopAllCoroutineAll()で一時停止する仕様になっているが、ネストしたCoroutineも含めて親のCoroutineからStopCoroutineするとネストしたCoroutineが終了してからしか一時停止しません。例えば以下のようなコードでCoroutineを実行中に以下のように親のCoroutineをStopしようとしてもNestCoroutineの終了を待ってからしかStopしてくれません。これが結構不便で、例えばゲームのポーズを実装したい場合にStopAllCoroutineで全部停止して済むなら良いのですが、特定のCoroutineだけ止めたい場合もあるわけで。
こういう場合に親のCoroutineをStopCoroutineさせるだけではネストしたCoroutineが止まってくれないので、ネストした全てのCoroutine中にフラグを設定してフラグで制御するとか、すべてのネストしたCoroutineを変数に格納しておいてStopCoroutineするなど面倒な制御を要求されます。こういった細かい制御をしたい場合IEnumeratorを自前でMoveNext()していく方法があります。
MoveNestでCoroutineを実行していく場合、以下のように書きます。UpdateでMoveNextを回して行くのが一般的ですが、あえてStartCoroutine中でMoveNextを回していきます。理由は後述。ただし、MoveNext（）を単純に回して行くだけだとネストしたコルーチンには対応できません。
ではどうするかというと、実はネストしたコルーチンの情報はIEnumeratorのCurrentの部分に含まれているのでこれをまたMoveNext()で回して行けばよいのです。後は、currentの型を判断してネストしたコルーチンに何が含まれているかで場合分けして処理を分けます。typeがIEnumeratorの場合はネストしたコルーチンなので、再帰的にMoveNextを実行します。
前述したようにStartCoroutineでMoveNextを実行しているのは、IEnumerator以外の型の場合はUnity側に処理を任せるためです。後は、唯一設定したフラグ_isPauseを制御することで、ネストしたコルーチン含めて一時停止、一時停止解除することが出来ます。上記のコードを見ると分かりますが一時停止できるのはネストしたコルーチンがyield return (IEnumerator関数)の時だけで、yield return new WaitForSecound(1.0f)とか、yield return StartCoroutine(Coroutine())  とかの場合には無理です。てか、StopCoroutineがそもそもネストしたコルーチンも含めてStopできないのが問題なのです。


