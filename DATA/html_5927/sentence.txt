最近看了很多关于syscall的文章，国外大多数安全研究员使用syscall来绕过edr的hook，使用的语言也五花八门，而我c系列的语言只会一点c#，所以我就用C#来简单实现一个syscall。本文全文参考以下两篇文章，部分讲解的不如原文清楚，要详细了解的请移步：在Windows中，进程处理体系被分为两种：用户模式和内核模式。而两者之间的切换正是syscall在起作用。使用ProcessMonitor观察记事本创建文件的操作可以看到蓝色的就是用户模式(User Mode)，红色的是内核模式(Kernel Mode)。两者之间对于CreateFile进行了切换，从KernelBase.dll!CreateFileW-&gt;ntdll.dll!NtCreateFile-&gt;ntoskrnl.exe!NtCreateFile。有两个不同的NtCreateFile函数调用，一个来自ntdll.dll模块，另一个来自ntoskrnl.exe模块，为什么？ntdll.dll里导出Windows原生API，ntoskrnl里是对其的实现(内核API)。来看一下两种模式之间的切换在CPU中的具体指令。WinDBG随意Attach一个进程，键入x ntdll!NtCreateFile命令这里看到NtCreateFile的汇编指令为在syscall指令下发后CPU会跳入内核模式，把函数调用参数从用户模式堆栈复制到内核模式堆栈，执行NtCreateFile的内核版本ZwCreateFile函数，完成后把返回值返回到用户模式，整个系统调用完成。在cpp中只需要内联asm代码就行，比如我们想编写一个利用NtCreateFile syscall的程序，只需要内联其汇编代码。而在C#中没有内联汇编，因为托管代码的原因。简述下托管代码和非托管代码：C#需要通过.net CLR进行翻译执行，而在CLR中提供了自动垃圾回收、异常处理等，C#代码托管给CLR来运行，叫做托管代码。而cpp是直接编译为系统指令，没有中间商处理，所以叫非托管代码。尽管没有内联汇编，但是C#仍然提供了一种方式突破托管代码和非托管代码之间的界限：P/Invoke(Platform Invoke)加委托。P/Invoke允许C#访问非托管DLL中的结构体、函数等，主要是通过System.Runtime.InteropServices命名空间来操作，先来一个实例，通过该命名空间来调用MessageBox。通过P/Invoke的DllImport导入user32.dll里的MessageBox函数来进行调用。C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 System.Delegate 类。先看下委托的基本用法，后面配合P/Invoke进行syscall代码中定义了一个EnumWindowsProc委托，将委托作为第一个参数传入EnumWindows API函数，查看EnumWindows的函数定义第一个参数是一个指针，指向程序定义的回调。意思就是可以通过传递OutputWindow函数指针进行调用OutputWindow函数。现在我们知道，委托类似于cpp中的指针，可以将委托作为参数传递。假如我们通过VirtualAlloc分配一段内存并将其返回给我们的委托，那么我们可以通过Type marshaling来转换传入的数据类型，以在非托管代码和native code之间进行转换，也就意味着我们可以通过这种方式来执行shellcode。通过Marshal.GetDelegateForFunctionPointer来将函数指针转为委托。原作者给出的NtOpenProcess的实例。首先通过WinDBG拿到NtOpenProcess的汇编指令，涉及指针操作的代码需要用到unsafe关键字，fixed关键字用来防止CLR的垃圾回收修改变量地址。当拿到memoryAddress之后我们就可以将其传递给委托使用。即通过Marshal.GetDelegateForFunctionPointer来将函数指针转为委托。在windbg中拿到的汇编指令如下首先看下api返回值是NTSTATUS一个结构体，ACCESS_MASK、OBJECT_ATTRIBUTES等都是结构体，那么需要先在自己代码中定义其结构体。在https://www.pinvoke.net/ 中可以查到函数及结构体的定义，并且给出了c#代码。在SharpSysCall\Native.cs中定义了所有用到的结构体和标识符。然后定义了一个委托先定义NtCreateFile的汇编指令字节数组接下来是对委托的实现在实现中，拿到NtCreateFile的在内存中的地址，而在Windows安全模型中，内存需要分配合适的访问权限。通过windbg可以看到NtCreateFile的权限为PAGE_EXECUTE_READ而进程的地址是私有的，一个程序不能修改另一个程序的数据，所以要通过VritualProtect将权限设置为PAGE_EXECUTE_READWRITE。接下来通过Marshal.GetDelegateForFunctionPointer将指针转化为委托，接下来将委托的执行结果返回。在Program.cs中进行调用。
总结一下流程：在ProcessMonitor中监视其堆栈确实是syscall直接系统调用。缺点：优点：胡言乱语：当Marshal.GetDelegateForFunctionPointer被hook时岂不是无解？


