More than 1 year has passed since last update.なかなか一言での説明が難しいですね。
なにか複数あるものを1個ずつ取得しようとする処理をreturnを使って書けようにするキーワード、といったところでしょうか。
LINQのWhereやOrderByなどの中間操作の内部処理等で多く使用されています。サンプルコードをみてみましょう。このコードの実行結果は次のようになります。予想通りでしたか？YieldSample() を呼び出すと、一見そのメソッドの処理を最初から最後まで実行するように見えてしまいますが、そうではありません。
このように、「値が必要になったときに値を取るために必要な処理をする」という遅延評価の仕組みをreturnに似たキーワードを使って書けるもの、それがyield returnである、と言うことができそうです。今ままでの部分の説明はわりとよく見かけるかもしれません。
ただ、実際にどうやって動いているのか、と少しもやもやは残ります。そこで例によって（前回の記事【図解】C#のasync/awaitの内部挙動を理解すると同じ作戦で）、yieldが定義されていない頃のC#で逆コンパイルした結果を見てみようと思います。yieldはC#2.0で定義されたのでC#1.0で逆コンパイルします。逆コンパイルにはILSpyというツールを使用します。先ほどのサンプルコードの逆コンパイル結果です。まず、yield returnがあったYieldSampleメソッドの中身は、あるインスタンスをnewしてreturnするのみ、というとてもシンプル内容で置き換わっていることが確認できます。属性のところからStateMachineという文字も見えますね。次に、この見覚えのない&lt;YieldSample&gt;d__1というクラスの定義部分について見てみましょう。少し長いですが、内容はわりとシンプルなのでそのまま載せてしまいます。細かいところは後においておくとして、この記事で主に伝えたかったポイントは下記の2点です。yield returnをするメソッドは公式ドキュメントから戻り値の型は、IEnumerable、IEnumerable&lt;T&gt;、IEnumerator、または IEnumerator&lt;T&gt; であることが必要です。とあります。今回のサンプルコードでは戻り値の型をIEnumerable&lt;int&gt;としました。
サンプルコードからコンパイラによって自動生成された&lt;YieldSample&gt;d__1クラスは次のインターフェースを実装しています。逆コンパイル結果を見てみると、IEnumerableで定義されるメソッドGetEnumeratorでは、自分自身をthisとして返してしまう処理があります。このようにIEnumerableとしてもIEnumeratorとしても使えるように作られていることがわかります。もし、戻り値の型をIEnumerator&lt;int&gt;とした場合は、となります。同時に、IEnumerableで定義されるGetEnumeratorメソッドの実装もなくなります。ちなみに、戻り値の型を非ジェネリックにした場合、コンパイラが生成したクラスが実装するインタフェースのジェネリック部分がobjectになって自動生成されました。最後まで説明しませんでしたが、密かにIDisposableも実装していますね。
これについては次節で説明します。前節の通り、yield returnを記述した場合、コンパイルが生成するクラスは全てIDisposableを実装していました。そして、上記のサンプルコードの逆コンパイル結果ではDisposeメソッドが空になっていました。実は、yield returnを記述するメソッドでtry-finallyやusingを使うと、Disposeの中にも処理が記述されます。具体的にはfinally句で記述した処理が実行されるようになります1。これにより、次のようなプログラムを実行すると、次のような結果となります。finally句で記述した処理が、最後にに実行されていることがわかります。なぜこのような動きになるかと言うと、です。例えば、サンプルコードでのforeach文は、内部的に次のように展開されて、e.Dispose()の中身の処理でConsole.WriteLine("dispose")が呼ばれるというイメージです。サンプルコードの逆コンパイル結果に次のようなメソッドがありました。この中で&lt;&gt;1__stateというフィールドが使用されていますね。
文字通り、状態遷移機械の状態を保持する役割を担っています。0, 1, 2の数字の場合は、見ての通りyield returnを記述したメソッドの処理がどこまで進んだかを管理するために使用されていることがわかります。では、-1はどうでしょう？switch文で分岐するときには、defaultに入ってreturn falseをするのみで何もさせないようになっていますね。
case 2:で-1を設定している方については状態遷移機会の終了状態を表していると考えられます。
case 0:やcase 1:で 一時的に設定されているのは何でしょう？これはおそらく排他制御の役割をしているものだと思います。例えば、このEnumeratorを他のスレッドも使って並行的にMoveNextメソッドを実行した場合に、複数スレッドで同じ部分の処理（例えば上の例でのConsole.WriteLine）を重複して行わないように制御しているものだと考えられます。最後に-2というものも登場していました。Mainメソッドの隣に自分で記述した（がコンパイラに中身を書き換えられた）メソッドと、コンパイラが生成したクラス&lt;YieldSample&gt;d__1で定義されるコンストラクタとGetEnumeratorメソッドです。この部分は、インタフェースと実装についての部分でも簡単に触れましたが、コンパイラに生成された1つのクラス&lt;YieldSample&gt;d__1がIEnumerableとIEnumeratorの役割の両方を担おうとしていて、さらにこのGetEnumeratorの最初の1度の呼び出しだけ自分自身のインスタンスをそのままIEnumeratorとして流用させる目的があるものと思われます2。
一度GetEnumeratorを実行すると&lt;&gt;1__stateの値が0となり、次回以降のGetEnumerator呼び出しでは新しいインスタンスを生成するようになります。また、今回のサンプルコードとは別にyield returnを記述するメソッドの戻り値をIEnumerator（ジェネリック版も含む）にした場合は、のようにコンストラクタで初期化する際の&lt;&gt;1__stateは0となります。
この場合は、インタフェースと実装についてで記載したように、クラス&lt;YieldSample&gt;d__1はIEnumerableを実装しない（すなわちGetEnumeratorメソッドを持たない）ため、このクラスから複数のIEnumeratorが生成されることを考慮しなくてよいからだと考えられます。最後まで読んでいただき、ありがとうございました！
また、長くなってしまった。。。
前回の記事【図解】C#のasync/awaitの内部挙動を理解すると同じく、なんとなく動きはわかるけど、どのように処理されているかがいまいちピンんとこないものをILSpyで覗いてみました。個人的にも新しい発見が多くあり、いろいろ学びながら推測しながら書かせていただきました。もし誤りやよくない記述、改善コメントがありましたら、是非コメントお願いいたします！ここではコンパイラが生成するコードの記載は省略しますが、気になる方はILSpy等を使って是非覗いてみてください。 ↩同時にGetEnumeratorを実行したスレッドが、コンストラクタを呼び出したスレッドと同じかどうかの確認も行っているようです。 ↩


