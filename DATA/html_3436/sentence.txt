More than 1 year has passed since last update.ルールとか もろもろこちらのサイトでまるわかりです→ハノイの塔プログラミング界隈では再帰処理の勉強方法として定番の題材のようです。みんなどうやって実装しているのだろう？と思って調べましたが、
最小手数での解き方ばかりで"サクッと遊べるハノイの塔作った！"というのは見つけられませんでした。会社でサクッと簡単にハノイの塔をVRで実装するというミニハッカソンみたいなものをやった際に
私以外のエンジニアの方の実装方法が、(私にとって)斬新でおもしろかったのでまとめます。ちなみに私は、それぞれのブロックに大きさ順でIndexを与えるというやり方で実装に取り掛かり、
2時間後、真っ白なプロジェクトがそこにありました。上司と私はマシンガンと水鉄砲くらいの性能差があるので
コード自体には目をつぶって考え方だけを真剣に見ていただけると幸いです。Ray、Layer、ColliderSizeの比較をうまいこと使います。それぞれのBlock(土台も含む)が自身の上空から、自身に向かってRayを飛ばします。
もしそのRayを妨げる障害物がなければ
LayerはTopに変更されます。次にLayerをTop同士しか衝突しない設定にします。
これにより、一番上のオブジェクト(Top)のみ衝突するので比較対象を限定することができます。そして、最後に一番上のオブジェクト(Top)同士のColliderの大きさを比較します。
自分より小さいColliderをもつオブジェクトの上に置けない実装にすれば完了です。
(モデルは会社のパイセンが作ってくださいましたありがとうございます。)次はコードです。
今回の説明に関係ないクラス(つかむ、もとの位置に戻る等)が気になる方は
GitHubでプロジェクトごと落としてきて確認してください。→GitHubいろいろと端折っているので
要点だけ かい摘んで説明しますと、
ここ↓で自身の真上から自身に向かってRayが出てます。そして、ここ↓で自身が一番上のオブジェクトかどうかを
Rayが衝突したオブジェクトの名前を見てあげることで判断し、Layerを変更しています。〇〇Collider.size.軸で指定した軸のColliderSizeを取得できます。今回の記事の題材となった"ハノイの塔ミニハッカソン"では
Unityのおもしろさを再認識しました。汎用性とか、処理速度とか何も考えずに作成した場合に限られるかもしれませんが、
そんなのありかよ！　というチートみたいな方法が
Unityを使うと実現可能です。まだまだ知らない機能ばかりですし、どんどん便利になっているようなので
これからの開発も楽しみです。あ、ハノイの塔の実装でさらなるチートをご存知の方は
コメントでも対抗記事でもなんでもお気軽に書いちゃってください喜びます。


