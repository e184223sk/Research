<!DOCTYPE html><html><head><meta charset="utf-8" /><title>[C#]await利用時の同期コンテキストと実行スレッドの動きについてコードを動かして見ていく - Qiita</title><meta content="width=device-width,initial-scale=1,shrink-to-fit=no,viewport-fit=cover" name="viewport" /><meta content="#55c500" name="theme-color" /><meta content="XWpkTG32-_C4joZoJ_UsmDUi-zaH-hcrjF6ZC_FoFbk" name="google-site-verification" /><meta content="telephone=no" name="format-detection" /><link rel="canonical" href="https://qiita.com/Kosei-Yoshida/items/7afe6c2f6158f36f50b1" /><link href="/manifest.json" rel="manifest" /><link href="/opensearch.xml" rel="search" title="Qiita" type="application/opensearchdescription+xml" /><link as="script" href="https://www.googletagservices.com/tag/js/gpt.js" rel="preload" /><link href="https://securepubads.g.doubleclick.net" rel="preconnect" /><script async="" src="https://www.googletagservices.com/tag/js/gpt.js"></script><meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="BzP4uFVOyEGlKz1gRIF8BreGiGX156zi4zwCZyne5/N6c2VQOSNu22rTrazOgQSOJ+wq1fC0Dgyh3wTRbX3gzQ==" /><link rel="shortcut icon" type="image/x-icon" href="https://cdn.qiita.com/assets/favicons/public/production-c620d3e403342b1022967ba5e3db1aaa.ico" /><link rel="apple-touch-icon" type="image/png" href="https://cdn.qiita.com/assets/favicons/public/apple-touch-icon-ec5ba42a24ae923f16825592efdc356f.png" /><link rel="stylesheet" media="all" href="https://cdn.qiita.com/assets/public/article-2eaa7dbedc42a8ea65c722cda46d0ebb.min.css" /><script src="https://cdn.qiita.com/assets/public/v3-article-bundle-63de2d91fef827269d3f6b958db2335b.min.js" defer="defer"></script><meta name="twitter:card" content="summary_large_image"><meta content="@Qiita" name="twitter:site" /><meta content="@H9mqVsEISnSFEEY" name="twitter:creator" /><meta property="og:type" content="article"><meta property="og:title" content="[C#]await利用時の同期コンテキストと実行スレッドの動きについてコードを動かして見ていく - Qiita"><meta property="og:image" content="https://qiita-user-contents.imgix.net/https%3A%2F%2Fcdn.qiita.com%2Fassets%2Fpublic%2Farticle-ogp-background-1150d8b18a7c15795b701a55ae908f94.png?ixlib=rb-4.0.0&amp;w=1200&amp;mark64=aHR0cHM6Ly9xaWl0YS11c2VyLWNvbnRlbnRzLmltZ2l4Lm5ldC9-dGV4dD9peGxpYj1yYi00LjAuMCZ3PTg0MCZoPTM4MCZ0eHQ2ND1XME1qWFdGM1lXbDA1WWlwNTVTbzVwbUM0NEd1NVpDTTVweWY0NEt6NDRPejQ0T0c0NEt0NDRLNTQ0T0k0NEdvNWE2ZjZLR000NEs1NDRPczQ0T0Q0NE9KNDRHdTVZdVY0NEdONDRHcjQ0R2s0NEdFNDRHbTQ0S3o0NE84NDRPSjQ0S1M1WXVWNDRHTDQ0R1g0NEdtNkthTDQ0R200NEdFNDRHUCZ0eHQtY29sb3I9JTIzMzMzJnR4dC1mb250PUhpcmFnaW5vJTIwU2FucyUyMFc2JnR4dC1zaXplPTU0JnR4dC1jbGlwPWVsbGlwc2lzJnR4dC1hbGlnbj1jZW50ZXIlMkNtaWRkbGUmcz04YjgxYTYwNGMxZDI5ZTc3MmU2ZGNkOWRjODFlZDg2Nw&amp;mark-align=center%2Cmiddle&amp;blend64=aHR0cHM6Ly9xaWl0YS11c2VyLWNvbnRlbnRzLmltZ2l4Lm5ldC9-dGV4dD9peGxpYj1yYi00LjAuMCZ3PTg0MCZoPTUwMCZ0eHQ2ND1RRXR2YzJWcExWbHZjMmhwWkdFJnR4dC1jb2xvcj0lMjMzMzMmdHh0LWZvbnQ9SGlyYWdpbm8lMjBTYW5zJTIwVzYmdHh0LXNpemU9NDUmdHh0LWFsaWduPXJpZ2h0JTJDYm90dG9tJnM9ZWFkYzlhNzg2MzhlNWY0ODkxZWE1OGYzOWNjM2M4ODY&amp;blend-align=center%2Cmiddle&amp;blend-mode=normal&amp;s=0274f249810179f14536a2c5fe1cbe50"><meta property="og:description" content="private async Task MethodAsync()
{
    Print($&quot;1:Before await. Thread Id: {Thread.CurrentThread.ManagedThreadId}&quot;);

..."><meta content="https://qiita.com/Kosei-Yoshida/items/7afe6c2f6158f36f50b1" property="og:url" /><meta content="Qiita" property="og:site_name" /><meta content="564524038" property="fb:admins" /><meta content="C#,.NET,WPF,非同期処理" name="keywords" /><script>!function(f,b,e,v,n,t,s)
{if(f.fbq)return;n=f.fbq=function(){n.callMethod?
n.callMethod.apply(n,arguments):n.queue.push(arguments)};
if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
n.queue=[];t=b.createElement(e);t.async=!0;
t.src=v;s=b.getElementsByTagName(e)[0];
s.parentNode.insertBefore(t,s)}(window, document,'script',
'https://connect.facebook.net/en_US/fbevents.js');
fbq('init', '668972150489891');
fbq('track', 'PageView');</script><style data-emotion-css="17jxvjw 11t2ec1 1dvr2p8 18lkoru 1g4cku8 1iupg5d ijvq0v 15cocm3 12rp90f 115f4t 1b8uj5v 79elbk 16hhh7b fcbn8c 1gj7nt 154zy0m yikrym 1jqivyb 1ode1bp le4d8r 1hbd3g7 helsa7 8qb8m4 2imjyh he5w1s 70qvj9 3ojehk 100alwu 1dtnjt5 10ougpm 1ay9vb9 m19uds cgzq40 1wa99t2 1l3zk9f 4czcte 1yzj1fm 1uv1qiv 109dbrr 5jpx49 mnxgyc 1vlpknv fsjkhv 1b17vb0 7i7f4d"}>.css-17jxvjw{display:grid;display:-ms-grid;grid-template-columns:80px minmax(0,1fr) 300px;-ms-grid-columns:80px minmax(0,1fr) 300px;grid-template-rows:minmax(270px,auto) 1fr;-ms-grid-rows:minmax(270px,auto) 1fr;max-width:1280px;margin-right:auto;margin-left:auto;padding-top:24px;padding-right:24px;padding-left:24px;}@media (max-width:1200px){.css-17jxvjw{padding-bottom:0;padding-left:0;padding-right:0;}}@media (max-width:992px){.css-17jxvjw{grid-template-columns:80px 452px 300px;-ms-grid-columns:80px 452px 300px;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;}}@media (max-width:770px){.css-17jxvjw{display:block;}}@media (max-width:480px){.css-17jxvjw{padding-top:0;}}.css-11t2ec1{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;z-index:5;position:-webkit-sticky;position:sticky;top:calc(56px + 24px + 16px + 32px - 16px);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;padding:16px;width:80px;}.css-11t2ec1:after{content:'';display:table;}.css-11t2ec1:before{content:'';display:table;}@media (max-width:770px){.css-11t2ec1{display:none;}}.css-1dvr2p8{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;margin-bottom:16px;}.css-18lkoru{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border:2px solid #55C500;border-radius:50%;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:40px;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;padding:0;width:40px;background-color:#FFFFFF;}.css-1g4cku8{display:inline-block;vertical-align:middle;height:20px;width:20px;fill:#55C500;}.css-1iupg5d{color:#55C500;cursor:pointer;font-size:14px;font-weight:bold;}.css-ijvq0v{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;margin-bottom:16px;}.css-15cocm3{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#FFFFFF;border:2px solid #6E6F70;border-radius:50%;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:40px;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;padding:2px 0px 0px;width:40px;}.css-12rp90f{display:inline-block;vertical-align:bottom;height:17.77777777777778px;width:16px;fill:#6E6F70;}.css-115f4t{color:#6E6F70;font-size:14px;font-weight:bold;}.css-1b8uj5v{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:#6E6F70;cursor:pointer;font-size:20px;height:32px;outline:none;width:32px;margin-bottom:16px;padding:0;}.css-79elbk{position:relative;}.css-16hhh7b{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:#6E6F70;cursor:pointer;font-size:20px;height:32px;outline:none;width:32px;padding:0;}.css-fcbn8c{display:none;bottom:initial;left:initial;right:initial;top:initial;left:100%;top:calc(-8px - (14px * 1.8) - 16px - 4px);}.css-1gj7nt{color:rgba(0,0,0,0.6);font-size:14px;font-weight:bold;line-height:1.8;padding:8px 16px;}.css-154zy0m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:rgba(0,0,0,0.87);cursor:pointer;font-size:16px;font-weight:normal;line-height:1.8;padding:4px 16px;}.css-154zy0m:hover{-webkit-text-decoration:none;text-decoration:none;background-color:#F2F2F2;}.css-yikrym{width:20px;}.css-1jqivyb{color:rgba(0,0,0,0.6);font-size:13px;}.css-1ode1bp{background-color:rgba(0,0,0,0.12);height:1px;width:100%;margin:8px 0;}.css-le4d8r{display:inline-block;vertical-align:middle;height:13px;width:13px;fill:rgba(0,0,0,0.6);}.css-1hbd3g7{height:250px;}.css-helsa7{background-color:#FFFFFF;padding:32px;margin-bottom:24px;}@media (max-width:992px){.css-helsa7{margin:0 auto 40px;}}@media (max-width:480px){.css-helsa7{margin:0 0 40px;padding:32px 16px;}}.css-8qb8m4{margin-bottom:48px;}.css-2imjyh{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.css-he5w1s{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;width:100%;}@media (max-width:770px){.css-he5w1s{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;}}.css-70qvj9{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.css-3ojehk{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin-right:4px;}.css-100alwu{display:inline-block;border-radius:50%;line-height:1;overflow:hidden;vertical-align:middle;}.css-1dtnjt5{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.css-10ougpm{color:rgba(0,0,0,0.87);font-size:14px;font-weight:600;line-height:1.8;margin-right:4px;text-wrap:break-word;word-break:break-all;}.css-1ay9vb9{margin-right:16px;}.css-m19uds{color:rgba(0,0,0,0.6);font-size:14px;line-height:1.8;}.css-cgzq40{color:rgba(0,0,0,0.87);font-size:32px;font-weight:bold;line-height:1.4;margin-top:8px;text-wrap:break-word;word-break:break-all;}.css-1wa99t2{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:rgba(0,0,0,0.6);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-top:8px;}.css-1l3zk9f{color:rgba(0,0,0,0.6);font-size:20px;margin-right:8px;}.css-4czcte{margin-right:4px;color:inherit;font-size:14px;line-height:1.8;}.css-4czcte:not(:last-child)::after{content:',';margin-right:4px;}.css-1yzj1fm{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-top:32px;}.css-1uv1qiv{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:#6E6F70;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;font-size:20px;height:32px;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;margin-right:16px;outline:none;padding:0;width:32px;}.css-109dbrr{background-color:#F9F9F9;border-top:1px solid rgba(0,0,0,0.12);bottom:0;box-shadow:0px 1px 4px rgba(0,0,0,0.14);display:none;height:calc(env(safe-area-inset-bottom,0px) + 56px);-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;padding-bottom:env(safe-area-inset-bottom);position:-webkit-sticky;position:sticky;width:100%;z-index:2000;}@media (max-width:770px){.css-109dbrr{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}.css-5jpx49{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:space-evenly;-webkit-justify-content:space-evenly;-ms-flex-pack:space-evenly;justify-content:space-evenly;width:100%;}.css-mnxgyc{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;}.css-1vlpknv{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border:2px solid #55C500;border-radius:50%;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:40px;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;padding:0;width:40px;margin-right:4px;background-color:#FFFFFF;}.css-fsjkhv{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;}.css-1b17vb0{color:#6E6F70;font-size:14px;font-weight:bold;margin-left:4px;}.css-7i7f4d{display:none;bottom:initial;left:initial;right:initial;top:initial;bottom:32px;right:0;}</style></head><body><div class="allWrapper"><div><div id="GlobalHeader-react-component-64774de5-d040-487c-a42e-38bb2b42ede3"><div class="st-Header"><div class="st-Header_container"><div class="st-Header_start"><a href="/" class="st-Header_logo"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 426.57 130"><circle cx="167.08" cy="21.4" r="12.28"></circle><path d="M250.81 29.66h23.48v18.9h-23.48z"></path><path d="M300.76 105.26a22.23 22.23 0 01-6.26-.86 12.68 12.68 0 01-5.17-3 14.41 14.41 0 01-3.56-5.76 28 28 0 01-1.3-9.22V48.56h29.61v-18.9h-29.52V3.29h-20.17v83.34q0 11.16 2.83 18.27a27.71 27.71 0 007.7 11.2 26.86 26.86 0 0011.43 5.62 47.56 47.56 0 0012.34 1.53h15.16v-18zM0 61.7a58.6 58.6 0 015-24.21A62.26 62.26 0 0118.73 17.9 63.72 63.72 0 0139 4.78 64.93 64.93 0 0164 0a65 65 0 0124.85 4.78 64.24 64.24 0 0120.38 13.12A62 62 0 01123 37.49a58.6 58.6 0 015 24.21 58.34 58.34 0 01-4 21.46 62.8 62.8 0 01-10.91 18.16l11.1 11.1a10.3 10.3 0 010 14.52 10.29 10.29 0 01-14.64 0l-12.22-12.41a65 65 0 01-15.78 6.65 66.32 66.32 0 01-17.55 2.3 64.63 64.63 0 01-45.23-18A62.82 62.82 0 015 85.81 58.3 58.3 0 010 61.7zm21.64.08a43.13 43.13 0 0012.42 30.63 42.23 42.23 0 0013.43 9.09A41.31 41.31 0 0064 104.8a42 42 0 0030-12.39 42.37 42.37 0 009-13.64 43.43 43.43 0 003.3-17 43.77 43.77 0 00-3.3-17A41.7 41.7 0 0080.55 22 41.78 41.78 0 0064 18.68 41.31 41.31 0 0047.49 22a42.37 42.37 0 00-13.43 9.08 43.37 43.37 0 00-12.42 30.7zM331.89 78a47.59 47.59 0 013.3-17.73 43.22 43.22 0 019.34-14.47A44.25 44.25 0 01359 36a47.82 47.82 0 0118.81-3.58 42.72 42.72 0 019.26 1 46.5 46.5 0 018.22 2.58 40 40 0 017 3.84 44.39 44.39 0 015.71 4.63l1.22-9.47h17.35v85.83h-17.35l-1.17-9.42a42.54 42.54 0 01-5.84 4.67 43.11 43.11 0 01-7 3.79 44.86 44.86 0 01-8.17 2.59 43 43 0 01-9.22 1A47.94 47.94 0 01359 119.9a43.3 43.3 0 01-14.47-9.71 44.17 44.17 0 01-9.34-14.47 47 47 0 01-3.3-17.72zm20.27-.08a29.16 29.16 0 002.17 11.34 27 27 0 005.92 8.88 26.69 26.69 0 008.76 5.76 29.19 29.19 0 0021.44 0 26.11 26.11 0 008.72-5.76 27.57 27.57 0 005.88-8.84 29 29 0 002.16-11.38 28.62 28.62 0 00-2.16-11.22 26.57 26.57 0 00-5.93-8.8 27.68 27.68 0 00-19.51-7.9 28.29 28.29 0 00-10.77 2.05 26.19 26.19 0 00-8.71 5.75 27.08 27.08 0 00-5.84 8.8 28.94 28.94 0 00-2.13 11.31zm-194.97-30.5h19.78v73.54h-19.78zm49.25 0h19.78v73.54h-19.78z"></path><circle cx="216.33" cy="21.4" r="12.28"></circle></svg></a><div class="st-Header_communitySelector" tabindex="0"><span class="fa fa-caret-down"></span></div><div class="st-Header_dropdown"><div class="st-Header_dropdownHeading">Qiita Teams that are logged in</div><div class="st-Header_dropdownItemNote">You are not logged in to any team</div><hr class="st-Header_dropdownDivider st-Header_dropdownDivider-shrink"/><a href="https://teams-center.qiita.com/find_team" class="st-Header_dropdownItem"><span class="fa fa-fw fa-sign-in st-Header_dropdownItemIcon"></span><div>Log in to Qiita Team</div></a><div class="st-Header_dropdownDivider"></div><div class="st-Header_dropdownHeading">Community</div><a href="/organizations" class="st-Header_dropdownItem">Organization</a><a href="/official-events/open" class="st-Header_dropdownItem">Event</a><a href="/advent-calendar" class="st-Header_dropdownItem">Advent Calendar</a><a href="https://qiitadon.com/" class="st-Header_dropdownItem" target="_blank">Qiitadon (β)</a><div class="st-Header_dropdownDivider"></div><div class="st-Header_dropdownHeading">Service</div><a href="https://jobs.qiita.com/?utm_source=qiita&amp;utm_medium=referral&amp;utm_content=header" class="st-Header_dropdownItem" target="_blank">Qiita Jobs</a><a href="https://zine.qiita.com/?utm_source=qiita&amp;utm_medium=referral&amp;utm_content=header" class="st-Header_dropdownItem" target="_blank">Qiita Zine</a><a href="https://blog.qiita.com/?utm_source=qiita&amp;utm_medium=referral&amp;utm_content=header" class="st-Header_dropdownItem" target="_blank">Qiita Blog</a></div><form class="st-Header_search" action="/search" method="get"><span class="fa fa-search st-Header_searchIcon"></span><input type="search" class="st-Header_searchInput" autoComplete="off" placeholder="Search" value="" name="q" required=""/></form><form class="st-Header_searchModal" action="/search" method="get"><input type="text" class="st-Header_searchModalInput" autoComplete="off" placeholder="Search" value="" name="q" required=""/></form></div><div class="st-Header_end"><div class="st-Header_searchButton"><span class="fa fa-search"></span></div><a class="st-Header_signupButton" href="/signup?redirect_to=%2FKosei-Yoshida%2Fitems%2F7afe6c2f6158f36f50b1">Signup</a><a class="st-Header_loginLink" href="/login?redirect_to=%2FKosei-Yoshida%2Fitems%2F7afe6c2f6158f36f50b1">Login</a></div><div class="st-Header_overlay"></div></div></div></div>
      <script type="application/json" class="js-react-on-rails-component" data-component-name="GlobalHeader" data-dom-id="GlobalHeader-react-component-64774de5-d040-487c-a42e-38bb2b42ede3">{"unreadNotificationsCount":null,"realms":[{"humanName":"Qiita","isCurrentRealm":true,"isQiita":true,"isQiitaTeam":false,"loggedInUser":null,"teamId":null,"url":"https://qiita.com/"}],"teamFindUrl":"https://teams-center.qiita.com/find_team","isTeamOnlyUser":null,"currentUser":null}</script>
      
</div><div class="st-HeaderAlert st-HeaderAlert-warning"><div class="st-HeaderAlert_body"></div></div><script type="application/ld+json">{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"/","name":"Qiita"}},{"@type":"ListItem","position":2,"item":{"@id":"/tags/csharp","name":"C#"}}]}</script><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","datePublished":"2021-03-02T10:36:45.000+09:00","dateModified":"2021-03-03T16:16:50.000+09:00","headline":"[C#]await利用時の同期コンテキストと実行スレッドの動きについてコードを動かして見ていく","image":"https://qiita-user-contents.imgix.net/https%3A%2F%2Fcdn.qiita.com%2Fassets%2Fpublic%2Farticle-ogp-background-1150d8b18a7c15795b701a55ae908f94.png?ixlib=rb-4.0.0\u0026w=1200\u0026mark64=aHR0cHM6Ly9xaWl0YS11c2VyLWNvbnRlbnRzLmltZ2l4Lm5ldC9-dGV4dD9peGxpYj1yYi00LjAuMCZ3PTg0MCZoPTM4MCZ0eHQ2ND1XME1qWFdGM1lXbDA1WWlwNTVTbzVwbUM0NEd1NVpDTTVweWY0NEt6NDRPejQ0T0c0NEt0NDRLNTQ0T0k0NEdvNWE2ZjZLR000NEs1NDRPczQ0T0Q0NE9KNDRHdTVZdVY0NEdONDRHcjQ0R2s0NEdFNDRHbTQ0S3o0NE84NDRPSjQ0S1M1WXVWNDRHTDQ0R1g0NEdtNkthTDQ0R200NEdFNDRHUCZ0eHQtY29sb3I9JTIzMzMzJnR4dC1mb250PUhpcmFnaW5vJTIwU2FucyUyMFc2JnR4dC1zaXplPTU0JnR4dC1jbGlwPWVsbGlwc2lzJnR4dC1hbGlnbj1jZW50ZXIlMkNtaWRkbGUmcz04YjgxYTYwNGMxZDI5ZTc3MmU2ZGNkOWRjODFlZDg2Nw\u0026mark-align=center%2Cmiddle\u0026blend64=aHR0cHM6Ly9xaWl0YS11c2VyLWNvbnRlbnRzLmltZ2l4Lm5ldC9-dGV4dD9peGxpYj1yYi00LjAuMCZ3PTg0MCZoPTUwMCZ0eHQ2ND1RRXR2YzJWcExWbHZjMmhwWkdFJnR4dC1jb2xvcj0lMjMzMzMmdHh0LWZvbnQ9SGlyYWdpbm8lMjBTYW5zJTIwVzYmdHh0LXNpemU9NDUmdHh0LWFsaWduPXJpZ2h0JTJDYm90dG9tJnM9ZWFkYzlhNzg2MzhlNWY0ODkxZWE1OGYzOWNjM2M4ODY\u0026blend-align=center%2Cmiddle\u0026blend-mode=normal\u0026s=0274f249810179f14536a2c5fe1cbe50","mainEntityOfPage":"https://qiita.com/Kosei-Yoshida/items/7afe6c2f6158f36f50b1","author":{"@type":"Person","address":"東京","email":"koseiasengineer@gmail.com","identifier":"Kosei-Yoshida","name":"Kosei-Yoshida","image":"https://qiita-user-profile-images.imgix.net/https%3A%2F%2Fs3-ap-northeast-1.amazonaws.com%2Fqiita-image-store%2F0%2F206591%2Fec95458225498b3b38288ee72ca33adcecf2fa3c%2Fx_large.png%3F1591664178?ixlib=rb-4.0.0\u0026auto=compress%2Cformat\u0026lossless=0\u0026w=75\u0026s=7f3c7a8d6eddffdfe19d431f7817743a","url":"https://qiita.com/Kosei-Yoshida","description":"","memberOf":[{"@type":"Organization","address":"東京都 品川区 西五反田 7-22-17 TOCビル 9階 1号室","legalName":"株式会社Synamon","image":"https://s3-ap-northeast-1.amazonaws.com/qiita-organization-image/61602936865dc500beef696ce467a66b8671dcef/original.jpg?1591883373","logo":"https://s3-ap-northeast-1.amazonaws.com/qiita-organization-image/788a109cb689ab1b5028a547f7bf94e63c84be6b/original.jpg?1593083579","identifier":"synamon","description":"Synamonは「XRが当たり前の世界をつくる」ことをミッションに、未来づくりに挑戦しているXRスタートアップです。\r\n市場をつくっていくためには、日常で使われる仕組みを生みだしていくことが重要です。\r\nそのため、toB領域をメインに、未来への取り組みや事業づくりにチャレンジしている企業様への支援や、XR活用のユースケースづくり、継続的に使われるための仕組みづくりに取り組んでいます。"}]},"publisher":{"@type":"Organization","name":"Qiita","logo":{"@type":"ImageObject","url":"//cdn.qiita.com/assets/public/qiita-logo-c39ded593afa388e2e1ba435b110554e.png"}}}</script><style type="text/css">.wb-CampaignLink {
  background-color: #333333;
  width: 100%;
}

.wb-CampaignLink_container {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  max-width: 1100px;
  margin: 0 auto;
  font-size: 13px;
  padding: 0.8em;
}
.wb-CampaignLink_container > a {
  color: #fff;
}

.wb-CampaignLink_container > a:hover {
  text-decoration: underline;
}</style><div class="wb-CampaignLink"><div class="wb-CampaignLink_container"><a target="_blank" id="header_text_message_1" href="https://zine.qiita.com/interview/202107-line-growth-technology/?utm_source=qiita&amp;utm_medium=header-banner">運用ではなくサービス運営の課題解決。LINE Growth Technologyに聞くGrowth開発</a><a target="_blank" id="header_text_message_2" href="https://zine.qiita.com/interview/202107-line-growth-technology/?utm_source=qiita&amp;utm_medium=header-banner">詳しくはこちら</a></div><script>td.trackEvent(
  'front_events',
  {"query_parameters":{},"path_parameters":{"controller":"public/items","action":"show","user_id":"Kosei-Yoshida","type":"items","id":"7afe6c2f6158f36f50b1"},"user_id":null,"event_category":"Header Text Ads Banner","event_action":"Show","data":{"message":"運用ではなくサービス運営の課題解決。LINE Growth Technologyに聞くGrowth開発","url":"https://zine.qiita.com/interview/202107-line-growth-technology/?utm_source=qiita\u0026utm_medium=header-banner","sub_message":"詳しくはこちら"}}
)</script><script>document.getElementById('header_text_message_1').addEventListener('click', function() {
  td.trackEvent(
    'front_events',
    {"query_parameters":{},"path_parameters":{"controller":"public/items","action":"show","user_id":"Kosei-Yoshida","type":"items","id":"7afe6c2f6158f36f50b1"},"user_id":null,"event_category":"Header Text Ads Banner","event_action":"Click","data":{"index":0,"pos_id":"header_text_message_1","message":"運用ではなくサービス運営の課題解決。LINE Growth Technologyに聞くGrowth開発","url":"https://zine.qiita.com/interview/202107-line-growth-technology/?utm_source=qiita\u0026utm_medium=header-banner","sub_message":"詳しくはこちら"}}
  )
})</script><script>document.getElementById('header_text_message_2').addEventListener('click', function() {
  td.trackEvent(
    'front_events',
    {"query_parameters":{},"path_parameters":{"controller":"public/items","action":"show","user_id":"Kosei-Yoshida","type":"items","id":"7afe6c2f6158f36f50b1"},"user_id":null,"event_category":"Header Text Ads Banner","event_action":"Click","data":{"index":0,"pos_id":"header_text_message_2","message":"運用ではなくサービス運営の課題解決。LINE Growth Technologyに聞くGrowth開発","url":"https://zine.qiita.com/interview/202107-line-growth-technology/?utm_source=qiita\u0026utm_medium=header-banner","sub_message":"詳しくはこちら"}}
  )
})</script></div><script type="application/json" id="js-react-on-rails-context">{"railsEnv":"production","inMailer":false,"i18nLocale":"en","i18nDefaultLocale":"en","href":"https://qiita.com/Kosei-Yoshida/items/7afe6c2f6158f36f50b1","location":"/Kosei-Yoshida/items/7afe6c2f6158f36f50b1","scheme":"https","host":"qiita.com","port":null,"pathname":"/Kosei-Yoshida/items/7afe6c2f6158f36f50b1","search":null,"httpAcceptLanguage":null,"actionPath":"public/items#show","settings":{"analyticsTrackingId":"UA-24675221-12","assetsMap":{},"csrfToken":"y8Nh184XRlnvO3MDFlj0wSnr4JCK5+K1YVX/QLGgBwi2g/w/onrgwyDD48+cWIxJuYFCII+0QFsjtvn29QMANg==","locale":"en"},"currentUser":null,"isLoggedIn":false,"recaptchaSiteKey":"6LfNkiQTAAAAAM3UGnSquBy2akTITGNMO_QDxMw6","serverSide":false}</script>
<div id="PersonalArticlePage-react-component-4f5e9ca6-0e85-44ba-81cb-09b28c837bc8"><div class="p-items_wrapper"><div class=" css-17jxvjw"><div class="css-11t2ec1"><div class="css-1dvr2p8"><button class=" css-18lkoru"><svg size="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 392.81 429" color="#55C500" class="css-1g4cku8 e31pr5q0"><path d="M14.19 5.4h53.86v149.45h90.05v44.87H14.19zM288.4 93.77h100.79q1.29 25-5.66 45.39a96.79 96.79 0 01-20.33 34.89 92 92 0 01-32.13 22.45 104 104 0 01-40.95 7.93 109.71 109.71 0 01-76-29.92 104.05 104.05 0 01-23-32.56 95.46 95.46 0 01-8.47-39.88 94.78 94.78 0 018.47-39.87 104.38 104.38 0 0123-32.42A107.71 107.71 0 01248.23 8a110.79 110.79 0 01118.48 22.49l-35.07 35.08a51.25 51.25 0 00-17.75-15 52.83 52.83 0 00-44.67-1.23 52.92 52.92 0 00-17 12 57.07 57.07 0 00-11.45 18.11 60 60 0 00-4.23 22.77 60 60 0 004.23 22.68 56.57 56.57 0 0011.45 18.19 52.62 52.62 0 0017 12 50.5 50.5 0 0020.9 4.36q20.19 0 31.07-7.51a35.75 35.75 0 0014.46-20.55h-47.39zM51.29 279.55H0v-44.86h156v44.86h-51.13V429H51.29zM283.36 381.71l-41.72-62V429h-53.86V234.69h47.47L290 312l55.9-77.29h46.9V429h-53.86V320.27l-42.43 61.44z"></path></svg></button><a href="/Kosei-Yoshida/items/7afe6c2f6158f36f50b1/likers" class="css-1iupg5d">60</a></div><div class="css-ijvq0v"><button class=" css-15cocm3"><svg size="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 353.02 398" color="#6E6F70" class="css-12rp90f e11v00bf0"><path d="M176.72 398c-67.52 0-130.16-29-171.84-79.69l-4.46-5.42V78.05H353v234.84l-4.45 5.42C306.88 369 244.24 398 176.72 398zm-137.2-99.34c34.17 38.37 83.78 60.25 137.2 60.25s103-21.88 137.21-60.25V117.14H39.52zM0 0h351.12v40.94H0z"></path></svg></button><span class="css-115f4t">64</span></div><div class="css-1b8uj5v"><span class="fa fa-twitter"></span></div><div class="css-1b8uj5v"><span class="fa fa-facebook"></span></div><div class="css-79elbk"><button class="css-16hhh7b"><i class="fa fa-ellipsis-h"></i></button><div class="css-fcbn8c"><div class="css-1gj7nt">Improve article</div><a href="/drafts/7afe6c2f6158f36f50b1/edit" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-code-fork css-1jqivyb" aria-hidden="true"></i></span>Send edit request</a><div class="css-1ode1bp"></div><div class="css-1gj7nt">Article information</div><a href="/Kosei-Yoshida/items/7afe6c2f6158f36f50b1/revisions" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-history css-1jqivyb" aria-hidden="true"></i></span>Revisions</a><a href="/Kosei-Yoshida/items/7afe6c2f6158f36f50b1/patches" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-inbox css-1jqivyb" aria-hidden="true"></i></span>Edit Requests</a><a href="/Kosei-Yoshida/items/7afe6c2f6158f36f50b1/likers" class="css-154zy0m"><span class="css-yikrym"><svg size="13" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 392.81 429" color="rgba(0, 0, 0, 0.6)" class="css-le4d8r e31pr5q0"><path d="M14.19 5.4h53.86v149.45h90.05v44.87H14.19zM288.4 93.77h100.79q1.29 25-5.66 45.39a96.79 96.79 0 01-20.33 34.89 92 92 0 01-32.13 22.45 104 104 0 01-40.95 7.93 109.71 109.71 0 01-76-29.92 104.05 104.05 0 01-23-32.56 95.46 95.46 0 01-8.47-39.88 94.78 94.78 0 018.47-39.87 104.38 104.38 0 0123-32.42A107.71 107.71 0 01248.23 8a110.79 110.79 0 01118.48 22.49l-35.07 35.08a51.25 51.25 0 00-17.75-15 52.83 52.83 0 00-44.67-1.23 52.92 52.92 0 00-17 12 57.07 57.07 0 00-11.45 18.11 60 60 0 00-4.23 22.77 60 60 0 004.23 22.68 56.57 56.57 0 0011.45 18.19 52.62 52.62 0 0017 12 50.5 50.5 0 0020.9 4.36q20.19 0 31.07-7.51a35.75 35.75 0 0014.46-20.55h-47.39zM51.29 279.55H0v-44.86h156v44.86h-51.13V429H51.29zM283.36 381.71l-41.72-62V429h-53.86V234.69h47.47L290 312l55.9-77.29h46.9V429h-53.86V320.27l-42.43 61.44z"></path></svg></span>Show all likers</a><a href="/Kosei-Yoshida/items/7afe6c2f6158f36f50b1.md" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-file-text-o css-1jqivyb" aria-hidden="true"></i></span>Show article in Markdown</a><div class="css-1ode1bp"></div><div class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-flag css-1jqivyb" aria-hidden="true"></i></span>Report article</div></div><div class="st-Modal"><div class="st-Modal_backdrop"></div><div class="st-Modal_body"><form><div class="st-Form"><span class="st-Form_label">Help us understand the problem. What is going on with this article?</span></div><div class="st-Form"><label><input type="radio" name="reason" value="illegal" required=""/>It&#x27;s illegal (copyright infringement, privacy infringement, libel, etc.)</label></div><div class="st-Form"><label><input type="radio" name="reason" value="inappropriate_content" required=""/>It&#x27;s socially inappropriate (offensive to public order and morals)</label></div><div class="st-Form"><label><input type="radio" name="reason" value="advertising" required=""/>It&#x27;s advertising</label></div><div class="st-Form"><label><input type="radio" name="reason" value="spam" required=""/>It&#x27;s spam</label></div><div class="st-Form"><label><input type="radio" name="reason" value="guideline_violation" required=""/>Other than the above, but not suitable for the Qiita community (violation of guidelines)</label></div><div class="st-Form st-Form-right"><input type="submit" class="st-Form_submit" value="Submit"/></div></form></div></div></div></div><div class="p-items_options"><div class="mt-2"><div class="css-1hbd3g7"></div></div></div><div class="p-items_toc"><div class="mt-2"><div class="css-1hbd3g7"></div></div></div><div class="p-items_main"><div class="css-helsa7"><div class="css-8qb8m4"><div class="css-2imjyh"><div class="css-he5w1s"><div class="css-70qvj9"><div class="css-3ojehk"><a href="/Kosei-Yoshida"><img class="css-100alwu eyfquo10" src="https://s3-ap-northeast-1.amazonaws.com/qiita-image-store/0/206591/ec95458225498b3b38288ee72ca33adcecf2fa3c/x_large.png?1591664178" width="24" height="24" loading="lazy"/></a></div><div class="css-1dtnjt5"><a href="/Kosei-Yoshida" class="css-10ougpm">@<!-- -->Kosei-Yoshida</a><div class="css-1ay9vb9"><span><meta content="2021-03-02T01:36:45Z"/><time dateTime="2021-03-03T07:16:50Z" class="css-m19uds">updated at 2021-03-03</time></span></div></div></div></div></div><h1 class="css-cgzq40">[C#]await利用時の同期コンテキストと実行スレッドの動きについてコードを動かして見ていく</h1><div class="css-1wa99t2"><span class="fa fa-tags mr-1of2 css-1l3zk9f" aria-hidden="true"></span><a href="/tags/csharp" class="css-4czcte">C#</a><a href="/tags/.net" class="css-4czcte">.NET</a><a href="/tags/wpf" class="css-4czcte">WPF</a><a href="/tags/%e9%9d%9e%e5%90%8c%e6%9c%9f%e5%87%a6%e7%90%86" class="css-4czcte">非同期処理</a></div></div><section class="it-MdContent"><div id="personal-public-article-body"><div><div class="code-frame" data-lang="c#"><div class="highlight"><pre class="with-code"><code><span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"1:Before await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">Print</span><span class="p">(</span><span class="s">$"2:In task run. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">));</span>

    <span class="nf">Print</span><span class="p">(</span><span class="s">$"3:After await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>いきなりですが問題です。</strong></p>

<p>上のコードには3つのPrint出力があり、それぞれの出力処理が行われる実行スレッドを出力します。<br>
ではこのコードを実行した場合、それぞれの出力の実行スレッドはどうなるでしょうか？</p>

<p>①1~3全て同じスレッドになる<br>
②1~3全て別のスレッドになる<br>
③1,2が同じスレッドで、3だけ別スレッド<br>
④1,3が同じスレッドで、2だけ別スレッド</p>

<p>ただし、WPFアプリケーションでの実行+このメソッドはメインスレッドから呼ばれるとする。</p>

<p>この記事を読むと、この問題の答えは何か？なぜそうなるのか？が理解できます。</p>

<h1>
<span id="はじめに" class="fragment"></span><a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB"><i class="fa fa-link"></i></a>はじめに</h1>

<p>C#の非同期処理について調べだすと、<strong>「同期コンテキストが存在する場合、awaitは処理後に自動でスレッドを戻してくれる」、という説明をよく見ます。</strong></p>

<p>自分はその説明を読んだだけではしっかり意味がわからなかったので、<strong>実際にコードを書いてみてその辺りの動きを確認</strong>しようと思いました。</p>

<p>その確認した内容を、自分の備忘録、兼、他の人の理解の助けにもなるだろうと思いまとめたのがこの記事です。</p>

<p>またawait利用時の同期コンテキストがわかれば、副産物として<code>Task.Wait</code>, <code>Task.Result</code>の利用が推奨されていない理由も理解しやすくるなるので、そちらについても書いています。</p>

<h1>
<span id="想定してる読者" class="fragment"></span><a href="#%E6%83%B3%E5%AE%9A%E3%81%97%E3%81%A6%E3%82%8B%E8%AA%AD%E8%80%85"><i class="fa fa-link"></i></a>想定してる読者</h1>

<ul>
<li>C#の基本文法はわかっている</li>
<li>async/await, Taskの存在ぐらいは知っている</li>
<li>記事の冒頭にある問題がわからなかった</li>
</ul>

<h2>
<span id="環境" class="fragment"></span><a href="#%E7%92%B0%E5%A2%83"><i class="fa fa-link"></i></a>環境</h2>

<p>記事の中ででてくるコードはWPFで動かしています。<br>
ただWindowsFormやUnityなどの"C#+GUI"のものなら理屈はほぼ同じなはずなので、その辺を普段使っている人にも読んでもらえると思います。</p>

<p>※CUIアプリケーションでは、この記事に書いてある内容が一部通じないので注意してください。</p>

<ul>
<li>WPF （C#のGUIフレームワーク）</li>
<li>.NET Core 3.1</li>
</ul>

<h1>
<span id="同期コンテキストとは何か" class="fragment"></span><a href="#%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%A8%E3%81%AF%E4%BD%95%E3%81%8B"><i class="fa fa-link"></i></a>同期コンテキストとは何か？</h1>

<p>「同期コンテキスト ≒ 複数スレッドに跨る処理を安全に行うための仕組み」です。</p>

<p>非同期処理は、うっかりすると、デッドロックや再現性の低いバグを起こしてしまいます。<br>
このようなバグはほとんどがマルチスレッドの処理が原因で起きるものです。<br>
同期コンテキストは、スレッド間の処理の受け渡しなどを上手く管理してくれる仕組みです。</p>

<p>つまり、<strong>同期コンテキストというのは、マルチスレッド処理が原因の不具合を避けC#の非同期処理を安全に使いやすくしてくれるための仕組みです。</strong></p>

<p>C#では同期コンテキストの仕組みを扱うために<code>System.Threading.SynchronizationContext</code>クラスとうものが用意されています。実は、<code>await</code>を利用している裏ではこの<code>SynchronizationContext</code>が良い感じにスレッド間の動きを調整してくれているのです。</p>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.synchronizationcontext?view=net-5.0" rel="nofollow noopener" target="_blank">System.Threading.SynchronizationContext</a></li>
</ul>

<h1>
<span id="awaitと同期コンテキスト" class="fragment"></span><a href="#await%E3%81%A8%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88"><i class="fa fa-link"></i></a>awaitと同期コンテキスト</h1>

<p><code>await</code>を使ったときの同期コンテキストがどうなっているか見ていきます。</p>

<p>下のコードは、単純に<code>await</code>を使った場合について実行スレッドがどうなっているかを確かめるもので、記事の冒頭に書いた問題に、メソッドを呼び出すButton_Clickがついただけのコードです。<br>
（画面上にButtonが一つ置いており、それを押すとButton_Clickが呼ばれるという状況です）</p>

<div class="code-frame" data-lang="c#"><div class="highlight"><pre class="with-code"><code><span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">Button_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"Button click. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="k">await</span> <span class="nf">MethodAsync</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"Before await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">Print</span><span class="p">(</span><span class="s">$"In task run. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">));</span>

    <span class="nf">Print</span><span class="p">(</span><span class="s">$"After await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre class="with-code"><code>Button click. Thread Id: 1
Before await. Thread Id: 1
In task run. Thread Id: 5
After await. Thread Id: 1
</code></pre></div>
</div>

<p><code>await</code>している<code>Task.Run()</code>の中では、スレッドIdが異なっています。逆に<code>await</code>の前後では、スレッドIdが一致しています。<br>
（なので、記事冒頭の問題の答えは「④1,3が同じスレッドで、2だけ別スレッド」でした。）</p>

<p>つまり、<strong>awaitには、「awaitする前後で実行スレッドを保存しておく機能」があります。</strong><br>
もっと正確にいうと、<code>await</code>には「<code>System.Threading.SynchronizationContext.Current</code>がnullでない場合に、<code>await</code>の前後で実行スレッドを自動で保存してくれる機能」があります。</p>

<p>詳しくは後述しますが、WPFなどではメインスレッドに対して自動で<code>SynchronizationContext.Current</code>がセットされています。そして上のコードではメインスレッド上で<code>await Task.Run()</code>が実行されているため、その後にスレッドが元に戻っています。</p>

<p>自動でセットされている<code>SynchronizationContext.Current</code>を、意図的に<code>null</code>にした場合も見ておきましょう。</p>

<div class="code-frame" data-lang="C#">
<div class="code-lang"><span class="bold">SynchronizationContext.Currentがnullの場合</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">Button_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"ButtonClick. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="k">await</span> <span class="nf">MethodAsync</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"Before await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// SynchronizationContext.Currentをnullに設定する。ここではメインスレッドに対して設定している。</span>
    <span class="n">SynchronizationContext</span><span class="p">.</span><span class="nf">SetSynchronizationContext</span><span class="p">(</span><span class="k">null</span><span class="p">);</span>

    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">Print</span><span class="p">(</span><span class="s">$"In task run. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">));</span>

    <span class="nf">Print</span><span class="p">(</span><span class="s">$"After await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre class="with-code"><code>ButtonClick. Thread Id: 1
Before await. Thread Id: 1
In task run. Thread Id: 5
After await. Thread Id: 5
</code></pre></div>
</div>

<p><code>await</code>後にスレッドが元に戻らず<code>Task.Run()</code>の中と同じスレッドIdとなっています。<br>
これは、<code>await</code>する前のスレッド（ここではメインスレッド）で、<code>SynchronizationContext.Current</code>に<code>null</code>が代入されたためです。<br>
※通常このような処理をする事はないと思います。ここでは説明のため、わざと<code>null</code>を代入しています。</p>

<p><strong>awaitにはその前後で実行スレッドを自動で保存してくれる機能があり、それは"SynchronizationContext.Current != null"の場合のみ働く。</strong></p>

<p>この辺りの働きをさらに詳しく知りたければ、以下のページなどが参考になると思います。</p>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/archive/msdn-magazine/2015/november/asynchronous-programming-async-from-the-start" rel="nofollow noopener" target="_blank">非同期プログラミング - スタートアップから非同期に</a></li>
</ul>

<h4>
<span id="そもそもsynchronizationcontextcurrentはどこでセットされているのか" class="fragment"></span><a href="#%E3%81%9D%E3%82%82%E3%81%9D%E3%82%82synchronizationcontextcurrent%E3%81%AF%E3%81%A9%E3%81%93%E3%81%A7%E3%82%BB%E3%83%83%E3%83%88%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%8B"><i class="fa fa-link"></i></a>そもそもSynchronizationContext.Currentはどこでセットされているのか</h4>

<p>上でWPFなどではメインスレッドに対して自動で同期コンテキスト（<code>SynchronizationContext.Current</code>）が設定されていると書きました。<br>
では、メインスレッドの同期コンテキストはどこで設定されているのでしょうか？</p>

<p>WPFの場合は、<code>System.Windows.Threading.DispatcherSynchronizationContext</code>（<code>System.Threading.SynchronizationContext</code>クラスを継承）が、メインスレッドの<code>SynchronizationContext.Current</code>として自動で設定されています。</p>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.windows.threading.dispatchersynchronizationcontext?view=net-5.0" rel="nofollow noopener" target="_blank">System.Windows.Threading.DispatcherSynchronizationContext</a></li>
</ul>

<p>WindowsFormやUnityの場合もそれぞれ適当なクラスがメインスレッドの同期コンテキストとして自動で設定されています。そのため、メインスレッドで<code>await</code>を使った場合には、自動でスレッドが元に戻るようになっています。</p>

<h4>
<span id="cuiとguiだと何故挙動が変わるか" class="fragment"></span><a href="#cui%E3%81%A8gui%E3%81%A0%E3%81%A8%E4%BD%95%E6%95%85%E6%8C%99%E5%8B%95%E3%81%8C%E5%A4%89%E3%82%8F%E3%82%8B%E3%81%8B"><i class="fa fa-link"></i></a>CUIとGUIだと何故挙動が変わるか</h4>

<p>環境の項目で、次のように書きました。</p>

<blockquote>
<p>※CUIアプリケーションでは、この記事に書いてある内容が一部通じないので注意してください。</p>
</blockquote>

<p>これは、上述したようにGUIアプリケーションではメインスレッド（UIスレッド）に対する同期コンテキストが自動で設定されているのに対し、CUIアプリケーションではそれが行われていないためです。<br>
逆に言えば、根本的な<code>await</code>の働き自体にはGUIとCUIで差がありません。<br>
CUIでも同期コンテキストが設定されていれば、<code>await</code>後にスレッドが元に戻ります。</p>

<h4>
<span id="await自体には別スレッドに切り替える働きがないことに注意" class="fragment"></span><a href="#await%E8%87%AA%E4%BD%93%E3%81%AB%E3%81%AF%E5%88%A5%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%AB%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%82%8B%E5%83%8D%E3%81%8D%E3%81%8C%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E3%81%AB%E6%B3%A8%E6%84%8F"><i class="fa fa-link"></i></a>await自体には、別スレッドに切り替える働きがないことに注意</h4>

<p>ここまで見てきたコードで一つ勘違いしやすいポイントがあります。<br>
それは、<strong>awaitには別スレッドに切り替える働きはない</strong>ということです。</p>

<p>上のコード例では、<code>await</code>している部分でスレッドIdが変化していますが、これは<code>await</code>の働きではなく<code>Task.Run()</code>の働きによるものです。<strong>Task.Run()は、その引き数に与えられたデリゲートをスレッドプール上で実行します。この働きによって実行スレッドが変わっています。</strong></p>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task.run?view=net-5.0" rel="nofollow noopener" target="_blank">System.Threading.Task.Run</a></li>
</ul>

<p>上のコードもよく見てもらうと、Button_Clickから<code>await</code>をつけてMethodAsyncが実行されていますが、Button_Click内と、MethodAsyncの<code>await</code>前の部分で実行スレッドが変化していません。</p>

<p>スレッドプールについても一応簡単に説明しておきます。<br>
スレッドは必要になったときにその都度新しくつくるより、最初にいくつかつくっておきそれを使いまわす方が効率が良いです。その使いまわしの仕組みがスレッドプールです。<br>
C#には<code>Task.Run</code>などスレッドプールを簡単に使うために提供されている仕組みがあるので、基本的にスレッドプールも自分で直接操作する必要はなく、それらを使えば大丈夫です。<br>
スレッドプールの働きなどについてもう少し知りたければ以下の記事がわかりやすいです。</p>

<ul>
<li><a href="https://ufcpp.net/study/csharp/misc_task.html" rel="nofollow noopener" target="_blank">ufcpp [雑記] スレッド プールとタスク</a></li>
</ul>

<h4>
<span id="awaitと同期コンテキストの働きのまとめ" class="fragment"></span><a href="#await%E3%81%A8%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%AE%E5%83%8D%E3%81%8D%E3%81%AE%E3%81%BE%E3%81%A8%E3%82%81"><i class="fa fa-link"></i></a>awaitと同期コンテキストの働きのまとめ</h4>

<p>単純に<code>await</code>を利用した場合の同期コンテキストの動きについてまとめておきます。</p>

<ul>
<li>
<code>await</code>には、その前後で実行スレッドを保存してくれる働きがある

<ul>
<li>正確には実行スレッドではなく同期コンテキストを保存している</li>
<li>この働きは、<code>System.Threading.SynchronizationContext.Current</code>が<code>null</code>でない場合にのみ働く</li>
</ul>
</li>
<li>WPFなどではメインスレッドに対して自動で実行コンテキスト（<code>SynchronizationContext.Current</code>）が設定されている</li>
<li>
<code>await</code>しただけでは、その処理の実行スレッドは変わらない

<ul>
<li>実行スレッドが変化するのは<code>Task.Run()</code>などの機能</li>
</ul>
</li>
</ul>

<h1>
<span id="taskwait-taskresultが推奨でない理由" class="fragment"></span><a href="#taskwait-taskresult%E3%81%8C%E6%8E%A8%E5%A5%A8%E3%81%A7%E3%81%AA%E3%81%84%E7%90%86%E7%94%B1"><i class="fa fa-link"></i></a>Task.Wait, Task.Resultが推奨でない理由</h1>

<p>C#の非同期処理について調べると、「<code>Task.Wait</code>, <code>Task.Result</code>は使ってはいけない」という記述がよく見られます。この理由は、<code>await</code>を使う際の同期コンテキストの働きを知っていれば、容易に理解できます。</p>

<p><code>Task.Wait</code>, <code>Task.Result</code>が推奨でない理由は、デッドロックが簡単に起きてしまうからです。<br>
まず、<code>Task.Wait</code>を使ってデッドロックが起きてしまう例を見てみます。<br>
例の中で行っているのは、</p>

<ul>
<li>TaskをWaitすること</li>
<li>WaitされているTaskの中ではawait Task.Run()が使うこと</li>
</ul>

<p>だけです。</p>

<div class="code-frame" data-lang="c#">
<div class="code-lang"><span class="bold">Task.Waitでデッドロックするパターン</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">private</span> <span class="k">void</span> <span class="nf">Button_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">MethodWait</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// awaitを使っていないのでasync不要。</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">MethodWait</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"Before await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="nf">MethodAsync</span><span class="p">();</span>

    <span class="c1">// 結果待ちをするためにスレッドをロックして他のスレッドから触れなくしてしまう。</span>
    <span class="n">task</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>

    <span class="nf">Print</span><span class="p">(</span><span class="s">$"After wait. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 処理終了後に元のスレッドに戻そうとするが、元のスレッドがTask.Wait()によりロックされており戻せない。</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">Print</span><span class="p">(</span><span class="s">$"In task run. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre class="with-code"><code>Before await. Thread Id: 1
In task run.Thread Id: 4
// (After wait.~は出力されずUIもフリーズする）
</code></pre></div>
</div>

<p>MethodAsync()内の処理まで実行された後、task.Wait()の部分で処理がフリーズしてしまっています。<br>
これは、以下のようにお互いの処理待ちをしてしまうからです。</p>

<ul>
<li>task.Wait側は、タスクの完了までスレッドをロックする</li>
<li>await Task.Run()~側は、処理終了し元のスレッドに戻して完了させたいが、元のスレッドがロックされているので戻せず完了できない

<ul>
<li>
<code>Task.Run()</code>の働きにより別スレッドで実行されている。<code>await</code>はその後スレッドを元に戻そうとする。</li>
<li>元のスレッドに戻すとこまでやって、このTask(MethodAsync()の戻り値)は完了となる</li>
</ul>
</li>
</ul>

<p>このように、<strong>awaitが自動で行ってくれている同期コンテキストの保存と、Task.Wait(Task.Result)によるスレッドのロックが組み合わさることによりデッドロック起きてしまいます。</strong><br>
そのため、<code>await</code>か<code>Task.Wait</code>のどちらかの利用を避けたいところです。<br>
ここで、<code>await</code>は有用な仕組みのため、<code>Task.Wait</code>(<code>Task.Result</code>)の利用を抑えます。<br>
これが、<code>Task.Wait</code>, <code>Task.Result</code>の利用が推奨されない理由です。</p>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task.wait?view=net-5.0" rel="nofollow noopener" target="_blank">System.Threading.Tasks.Task.Wait</a></li>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task-1.result?view=net-5.0" rel="nofollow noopener" target="_blank">System.Threading.Tasks.Task.Result</a></li>
</ul>

<p>（Task.Resultがやっていることは、Task.Wait+結果取り出しです。つまり、デッドロックが起きる理由はTask.Waitと同様なため、ここでは解説を省略します。）</p>

<h3>
<span id="呼び出し元から非同期化することによってwaitを使わない" class="fragment"></span><a href="#%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E5%85%83%E3%81%8B%E3%82%89%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%8C%96%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6wait%E3%82%92%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84"><i class="fa fa-link"></i></a>呼び出し元から非同期化することによってWaitを使わない。</h3>

<p>Task.Waitは利用したくないと書きましたが、その一番シンプルな代替方法はawaitを使うことです。</p>

<div class="code-frame" data-lang="c#">
<div class="code-lang"><span class="bold">Task.Waitではなくawaitを使う</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">Button_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="nf">MethodAwaitAsync</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MethodAwaitAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"Before await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="nf">MethodAsync</span><span class="p">();</span>
    <span class="k">await</span> <span class="n">task</span><span class="p">;</span>

    <span class="nf">Print</span><span class="p">(</span><span class="s">$"After wait. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">Print</span><span class="p">(</span><span class="s">$"In task run. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre class="with-code"><code>Before await. Thread Id: 1
In task run.Thread Id: 4
After wait. Thread Id: 1
</code></pre></div>
</div>

<p>きちんとフリーズすることなく実行されました。<br>
<code>Task.Wait</code>の代わりに<code>await</code>で処理完了を待っています。また、<code>await</code>を使うためにメソッドに<code>async</code>キーワードがついています。（<code>async</code>を使う場合は戻り値を<code>void</code>ではなく<code>Task</code>あるいは<code>Task&lt;TResult&gt;</code>としましょう。その唯一の例外は、上コードのButton_ClickのようにUIイベントにデリゲートを登録する場合だけです。）</p>

<p>この例のように、<code>Task.Wait</code>ではなく<code>await</code>を使うようにしていくと、呼び出し元のメソッドも<code>async/await</code>を使う必要があり、自然と一連の処理が全て非同期メソッドとなっていきます。<br>
「呼び出し元まで全て非同期メソッドにしていってよいのか？」と迷うかもしれませんが、<strong>呼び出し元から非同期コードで統一することはMicrosoftのベストプラクティスでも推奨されています。</strong>ぜひやりましょう。</p>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming" rel="nofollow noopener" target="_blank">非同期プログラミングのベスト プラクティス</a></li>
</ul>

<h3>
<span id="waitを使いたいならconfigureawaitを使う" class="fragment"></span><a href="#wait%E3%82%92%E4%BD%BF%E3%81%84%E3%81%9F%E3%81%84%E3%81%AA%E3%82%89configureawait%E3%82%92%E4%BD%BF%E3%81%86"><i class="fa fa-link"></i></a>Waitを使いたいならConfigureAwaitを使う</h3>

<p>また、<code>await</code>後に元のスレッドに戻そうとすることでデッドロックが起きるなら、その働きをなくすことでもデッドロックを防ぐことができます。<br>
やり方は、<code>await</code>している<code>Task</code>の後ろに<code>ConfigureAwait(false)</code>をつけるだけです。</p>

<div class="code-frame" data-lang="c#">
<div class="code-lang"><span class="bold">ConfigureAwait(false)を使ってデッドロックを防ぐ</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">private</span> <span class="k">void</span> <span class="nf">Button_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nf">MethodWait</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// awaitを使っていないのでasync不要。</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">MethodWait</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"Before await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="nf">MethodAsync</span><span class="p">();</span>

    <span class="c1">// 結果待ちをするためにスレッドをロックして他のスレッドから触れなくしてしまう。</span>
    <span class="n">task</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>

    <span class="nf">Print</span><span class="p">(</span><span class="s">$"After wait. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">Print</span><span class="p">(</span><span class="s">$"In task run. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">))</span>
        <span class="p">.</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>

    <span class="c1">// ConfigureAwait(false)の後なのでメインスレッドに戻らず実行される。</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"After configure await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre class="with-code"><code>Before await. Thread Id: 1
In task run.Thread Id: 4
After configure await. Thread Id: 4
After wait. Thread Id: 1
</code></pre></div>
</div>

<p>詳しくは下で説明しますが、<code>ConfigureAwait(false)</code>を利用することで、<code>await</code>後に元のスレッドに戻る働きをなくし、デッドロックを防ぐことができます。<br>
（元のスレッドに戻らないのは<code>ConfigureAwait(false)</code>を使った<code>async</code>メソッド内だけです。）</p>

<p><strong>基本的には上で紹介したように、そもそもTask.Wait(Task.Result)を使わずに全てawaitに置き換えることが理想です。</strong><br>
しかし、ライブラリ作成者と利用者が一致しない場合など、利用者側にそれを徹底できない場合があります。<br>
そのため、<strong>同期コンテキストを保持する必要がない場合はConfigureAwait(false)をつけ、コンテキストに依存しないコードを書くようにしておくのが無難です。</strong>（特に誰が利用するかわからないコードを書く時は）</p>

<p>Microsoftのベストプラクティスでも以下のように書かれています。</p>

<blockquote>
<p>... 可能な場合は常に ConfigureAwait を使用すべきであるということになります。コンテキストに依存しないコードは、GUI アプリケーションのパフォーマンスを向上し、部分的に非同期のコードベースに取り組む際のデッドロックを回避するのに役立ちます。この指針の例外は、コンテキストが必要なメソッドです。</p>
</blockquote>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming" rel="nofollow noopener" target="_blank">非同期プログラミングのベスト プラクティス</a></li>
</ul>

<h1>
<span id="awaitで同期コンテキストを保持しない" class="fragment"></span><a href="#await%E3%81%A7%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%97%E3%81%AA%E3%81%84"><i class="fa fa-link"></i></a>awaitで同期コンテキストを保持しない</h1>

<p>上で、<code>Task.Wait</code>と<code>await</code>の併用によるデッドロックを避けるため、<code>ConfigureAwait(false)</code>オプションを使うと書きました。<br>
これは、オプションをつけることにより、同期コンテキストを意図的に保持しないという選択になります。<br>
<strong>この章では、その「同期コンテキストを保持しない」というところについて、もう少し掘り下げていきます。</strong></p>

<p>※説明する人によっては、同期コンテキストを「保持しない」ではなく「キャプチャしない」、「拾わない」と表現している場合もありますが、同じ意味です。</p>

<h3>
<span id="configureawaitfalse" class="fragment"></span><a href="#configureawaitfalse"><i class="fa fa-link"></i></a>ConfigureAwait(false)</h3>

<p>まずは、先ほどもでてきた<code>ConfigureAwait(false)</code>についてです。<br>
凄くシンプルに<code>ConfigureAwait(false)</code>を使った場合を見てみます。</p>

<div class="code-frame" data-lang="c#">
<div class="code-lang"><span class="bold">ConfigureAwait(false)をつけると実行コンテキストを拾わない</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">Button_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="nf">MethodAsync</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"Before await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">Print</span><span class="p">(</span><span class="s">$"In task run. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">)).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>

    <span class="nf">Print</span><span class="p">(</span><span class="s">$"After await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre class="with-code"><code>Before await. Thread Id: 1
In task run.Thread Id: 5
After await. Thread Id: 5
</code></pre></div>
</div>

<p><code>await</code>している<code>Task</code>に<code>ConfigureAwait(false)</code>オプションをつけることで、<code>await</code>後に実行スレッドがメインスレッドに戻らなくなっています。<br>
このように、<strong>awaitするTaskにConfigureAwait(false)オプションをつけると実行コンテキストが保持されなくなります。</strong><br>
（実行コンテキストを拾わない、キャプチャしないと言ったりもします。）</p>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task.configureawait?view=net-5.0" rel="nofollow noopener" target="_blank">System.Threading.Tasks.ConfigureAwait</a></li>
</ul>

<p>先ほども紹介したように、<strong>デッドロックなどを防ぐためには、このConfigureAwait(false)などを使って、実行コンテキストを保持しないことがとても重要になってきます。</strong>C#で非同期処理をするならぜひ覚えておきましょう。</p>

<h4>
<span id="configureawaitの注意事項" class="fragment"></span><a href="#configureawait%E3%81%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85"><i class="fa fa-link"></i></a>ConfigureAwaitの注意事項</h4>

<p>同期コンテキストを保持しなくなる<code>ConfigureAwait(false)</code>オプションですが、一点気を付けたい部分があります。<br>
それは、あるasyncメソッド内で一度<code>ConfigureAwait(false)</code>を使うと、もとの同期コンテキストを復活できないことです。<br>
コード例で見てみましょう。</p>

<div class="code-frame" data-lang="c#">
<div class="code-lang"><span class="bold">ConfigureAwait(false)で同期コンテキストを捨てると復活できない</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">Button_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="nf">MethodAsync</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"Before await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">Print</span><span class="p">(</span><span class="s">$"In task run1. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">)).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>

    <span class="nf">Print</span><span class="p">(</span><span class="s">$"After await1. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">Print</span><span class="p">(</span><span class="s">$"In task run2. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">)).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>

    <span class="nf">Print</span><span class="p">(</span><span class="s">$"After await2. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre class="with-code"><code>Before await. Thread Id: 1
In task run1.Thread Id: 4
After await1. Thread Id: 4
In task run2.Thread Id: 5
After await2. Thread Id: 5
</code></pre></div>
</div>

<p>一つめのawait Task.Run()では<code>ConfigureAwait(false)</code>を使っているため、"After await1"のスレッドIdがメインスレッドと異なっているのは先ほどまでと同じです。<br>
ただ、二つめのawait Task.Run()では<code>ConfigureAwait(true)</code>としているのに、await後の処理がメインスレッドに戻っていません。</p>

<p>asyncメソッド内に<code>await</code>が複数回ある場合、途中で同期コンテキストを捨ててしまって大丈夫か注意してください。</p>

<h3>
<span id="continuewith" class="fragment"></span><a href="#continuewith"><i class="fa fa-link"></i></a>ContinueWith</h3>

<p>上で<code>ConfigureAwait(false)</code>を使うことによって同期コンテキストを保持しない方法について紹介しましたが、<code>ContinueWith</code>オプションでも似たようなことができます。</p>

<div class="code-frame" data-lang="c#">
<div class="code-lang"><span class="bold">ContinueWithをオプションなしで使う</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">Button_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="nf">MethodAsync</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"Before await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">Print</span><span class="p">(</span><span class="s">$"In task run. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">))</span>
        <span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="nf">Print</span><span class="p">(</span><span class="s">$"Continue. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="p">},</span>
            <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">Default</span>
        <span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre class="with-code"><code>Before await. Thread Id: 1
In task run.Thread Id: 5
Continue.Thread Id: 10
</code></pre></div>
</div>

<p><code>ContinueWith</code>の第二引数に<code>TaskScheduler.Default</code>を渡すと、第一引き数で渡したデリゲートがスレッドプール上で実行されます。（<code>ContinueWith</code>の第二引数を省略した場合でも同じようにスレッドプール上で実行されます。<code>TaskScheduler.Default</code>が規定値なため）<br>
<code>ConfigureAwait(false)</code>と違って同期コンテキストを捨てているわけではないですが、このようにして、<code>await</code>前のメインスレッドとは違うスレッドで実行することもできます。</p>

<p>逆に<code>ContinueWith</code>を使って、<code>await</code>前のスレッドに明示的に処理を戻すこともできます。</p>

<div class="code-frame" data-lang="c#">
<div class="code-lang"><span class="bold">ContinueWithをつかってawait前のスレッドに戻す</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">Button_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="nf">MethodAsync</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="s">$"Before await. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">var</span> <span class="n">currentSynchronizationContextScheduler</span> <span class="p">=</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="nf">FromCurrentSynchronizationContext</span><span class="p">();</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">Print</span><span class="p">(</span><span class="s">$"In task run. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">))</span>
        <span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="nf">Print</span><span class="p">(</span><span class="s">$"Continue. Thread Id: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">ManagedThreadId</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="p">},</span>
            <span class="n">currentSynchronizationContextScheduler</span>
        <span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</div>

<div class="code-frame" data-lang="text">
<div class="code-lang"><span class="bold">実行結果</span></div>
<div class="highlight"><pre class="with-code"><code>Before await. Thread Id: 1
In task run.Thread Id: 4
Continue.Thread Id: 1
</code></pre></div>
</div>

<p><code>await</code>前に現在の同期コンテキストから<code>TaskScheduler</code>をつくっておき<code>ContinueWith</code>の引数として渡すことで、<code>await</code>前のスレッドで実行できていますね。</p>

<p><code>ContinueWith</code>では、このように<code>TaskScheduler</code>を使った柔軟なスレッドコントロールや、<code>TaskContinuationOptions</code>を使った処理フローのコントロールが可能です。<br>
同期コンテキストを捨てるだけなら<code>ConfigureAwait(false)</code>で十分ですが、複雑な非同期処理フローが必要になる場合にはこちらを使うと良いでしょう。</p>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task.continuewith?view=net-5.0#System_Threading_Tasks_Task_ContinueWith_System_Action_System_Threading_Tasks_Task_System_Object__System_Object_System_Threading_Tasks_TaskContinuationOptions_" rel="nofollow noopener" target="_blank">System.Threading.Tasks.Task.ContinueWith</a></li>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.taskscheduler?view=net-5.0" rel="nofollow noopener" target="_blank">System.Threading.Tasks.TaskScheduler</a></li>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=net-5.0" rel="nofollow noopener" target="_blank">System.Threading.Tasks.TaskContinuationOptions</a></li>
</ul>

<h3>
<span id="おわりにまとめ" class="fragment"></span><a href="#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB%E3%81%BE%E3%81%A8%E3%82%81"><i class="fa fa-link"></i></a>おわりに、まとめ</h3>

<p>この記事では、<code>await</code>を使う際の同期コンテキストの働きについて、実際のコード例とともにまとめました。</p>

<p>記事冒頭の問題の答えは、「④1,3が同じスレッドで、2だけ別スレッド」です。<br>
その理由は、以下です。</p>

<ul>
<li>WPFではメインスレッド（UIスレッド）に対して同期コンテキスト（<code>SynchronizaitonContext.Current</code>）が自動で設定される</li>
<li>同期コンテキストが設定されているスレッドで<code>await</code>を使った場合、<code>await</code>以後の処理に戻る際に同期コンテキストを保持する（≒実行スレッドを元に戻してくれる）</li>
<li>Task.Run()での処理はスレッドプール上で行われる（なので2は別スレッドで出力される）</li>
</ul>

<p>また、GUIアプリケーションで<code>Task.Wait</code>, <code>Task.Result</code>の利用が推奨されない理由は以下です。</p>

<ul>
<li>「<code>Task.Wait</code>(<code>Task.Result</code>)のTaskの処理が完了するまでスレッドをロックする働き」と「<code>await</code>の処理終了後に実行スレッドを元に戻して処理を完了させる働き」がぶつかり、デッドロックを起こすため</li>
</ul>

<h3>
<span id="参考文献" class="fragment"></span><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><i class="fa fa-link"></i></a>参考文献</h3>

<p>この記事は、await利用時の同期コンテキストの働きという点に注目してまとめました。</p>

<p>非同期処理をさらに理解して使いこなすには、複数の人の解説を読んで、色んな角度から見てみるのが良いと思いますので、自分が参考にさせてもらった記事のリンクをいくつか貼らせてもらいます。</p>

<ul>
<li>
<a href="https://qiita.com/acple@github/items/8f63aacb13de9954c5da#task%E3%81%AF%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%AE%E5%91%AA%E7%B8%9B%E3%81%8B%E3%82%89%E8%A7%A3%E6%94%BE%E3%81%95%E3%82%8C%E3%81%9F-" id="reference-b087017875f52f5b4b90">Taskを極めろ！async/await完全攻略</a>

<ul>
<li>Taskクラスを中心に非同期処理について解説された記事</li>
<li>非同期詳しくない人でもめちゃくちゃわかりやすい</li>
</ul>
</li>
<li>
<a href="https://ufcpp.net/study/csharp/sp_thread.html" rel="nofollow noopener" target="_blank">ufcpp</a>

<ul>
<li>排他制御とか含めた非同期処理全般についてまとまってる。</li>
<li><a href="https://ufcpp.wordpress.com/2012/11/12/asyncawait%E3%81%A8%E5%90%8C%E6%99%82%E5%AE%9F%E8%A1%8C%E5%88%B6%E5%BE%A1/" rel="nofollow noopener" target="_blank">同期コンテキストをテーマに書かれている部分はこちら</a></li>
</ul>
</li>
<li>
<a href="https://www.kekyo.net/2016/12/06/6186" rel="nofollow noopener" target="_blank">kekyoの丼-できる！C#で非同期処理(Taskとasync-await)</a>

<ul>
<li>C#の非同期処理入門記事。</li>
<li>使い始めの人がやりがちな危ない処理について、"なぜ使っては駄目か"がわかりやすくまとまってる。</li>
<li>非同期処理を学びだす早い段階で呼んでおくとよさげ。</li>
</ul>
</li>
<li>
<a href="https://www.kekyo.net/2015/06/04/4735" rel="nofollow noopener" target="_blank">kekyoの丼-.NET非同期処理(async-await)を制御する、様々な方法</a>

<ul>
<li>より実践的な非同期処理の使い方の話</li>
</ul>
</li>
<li>
<a href="https://www.kekyo.net/2019/10/07/6995" rel="nofollow noopener" target="_blank">kekyoの丼-“パターンでわかる! .NET Coreの非同期処理” と楽屋ネタ</a>

<ul>
<li>より実践的な非同期処理の使い方の話②</li>
<li>動画とスライド</li>
</ul>
</li>
<li>
<a href="https://qiita.com/hiki_neet_p/items/d6b3addda6c248e53ef0#synchronizationcontext" id="reference-022971c0f67dfc5b31b9">C# 非同期、覚え書き。</a>

<ul>
<li>C#の非同期処理で使うクラスやメソッドがよくまとまっている</li>
<li>非同期処理の基本的なことがわかってから読むとよさげ</li>
</ul>
</li>
<li><a href="https://docs.microsoft.com/ja-jp/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming" rel="nofollow noopener" target="_blank">Microsoftドキュメント-Async/Await非同期プログラミングのベスト プラクティス</a></li>
</ul>
</div></div></section><div class="css-1yzj1fm"><div class="css-1uv1qiv"><span class="fa fa-twitter"></span></div><div class="css-1uv1qiv"><span class="fa fa-facebook"></span></div></div><div class="apm-Content"><div class="apm-Content_title">Why not register and get more from Qiita?</div><ol class="apm-Content_list"><li>We will deliver articles that match you<div class="description">By following users and tags, you can catch up information on technical fields that you are interested in as a whole</div></li><li>you can read useful information later efficiently<div class="description">By &quot;stocking&quot; the articles you like, you can search right away</div></li><div><a class="apm-Content_help" href="https://help.qiita.com/ja/articles/qiita-login-user" target="_blank"><i class="fa fa-fw fa-arrow-circle-right"></i>What you can do with signing up</a></div></ol><a href="/signup?callback_action=login_or_signup&amp;redirect_to=%2FKosei-Yoshida%2Fitems%2F7afe6c2f6158f36f50b1&amp;realm=qiita" class="apm-Content_button apm-Content_button-signup">Sign up</a><a href="/login?callback_action=login_or_signup&amp;redirect_to=%2FKosei-Yoshida%2Fitems%2F7afe6c2f6158f36f50b1&amp;realm=qiita" class="apm-Content_button apm-Content_button-signin">Login</a></div></div><div class="css-helsa7"></div></div></div></div><div class="css-109dbrr"><div class="css-5jpx49"><div class="css-mnxgyc"><button class=" css-1vlpknv"><svg size="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 392.81 429" color="#55C500" class="css-1g4cku8 e31pr5q0"><path d="M14.19 5.4h53.86v149.45h90.05v44.87H14.19zM288.4 93.77h100.79q1.29 25-5.66 45.39a96.79 96.79 0 01-20.33 34.89 92 92 0 01-32.13 22.45 104 104 0 01-40.95 7.93 109.71 109.71 0 01-76-29.92 104.05 104.05 0 01-23-32.56 95.46 95.46 0 01-8.47-39.88 94.78 94.78 0 018.47-39.87 104.38 104.38 0 0123-32.42A107.71 107.71 0 01248.23 8a110.79 110.79 0 01118.48 22.49l-35.07 35.08a51.25 51.25 0 00-17.75-15 52.83 52.83 0 00-44.67-1.23 52.92 52.92 0 00-17 12 57.07 57.07 0 00-11.45 18.11 60 60 0 00-4.23 22.77 60 60 0 004.23 22.68 56.57 56.57 0 0011.45 18.19 52.62 52.62 0 0017 12 50.5 50.5 0 0020.9 4.36q20.19 0 31.07-7.51a35.75 35.75 0 0014.46-20.55h-47.39zM51.29 279.55H0v-44.86h156v44.86h-51.13V429H51.29zM283.36 381.71l-41.72-62V429h-53.86V234.69h47.47L290 312l55.9-77.29h46.9V429h-53.86V320.27l-42.43 61.44z"></path></svg></button><a href="/Kosei-Yoshida/items/7afe6c2f6158f36f50b1/likers" class="css-1iupg5d">60</a></div><div class="css-fsjkhv"><button class=" css-15cocm3"><svg size="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 353.02 398" color="#6E6F70" class="css-12rp90f e11v00bf0"><path d="M176.72 398c-67.52 0-130.16-29-171.84-79.69l-4.46-5.42V78.05H353v234.84l-4.45 5.42C306.88 369 244.24 398 176.72 398zm-137.2-99.34c34.17 38.37 83.78 60.25 137.2 60.25s103-21.88 137.21-60.25V117.14H39.52zM0 0h351.12v40.94H0z"></path></svg></button><span class="css-1b17vb0">64</span></div><div class="css-79elbk"><button class="css-16hhh7b"><i class="fa fa-ellipsis-h"></i></button><div class="css-7i7f4d"><div class="css-1gj7nt">Improve article</div><a href="/drafts/7afe6c2f6158f36f50b1/edit" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-code-fork css-1jqivyb" aria-hidden="true"></i></span>Send edit request</a><div class="css-1ode1bp"></div><div class="css-1gj7nt">Article information</div><a href="/Kosei-Yoshida/items/7afe6c2f6158f36f50b1/revisions" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-history css-1jqivyb" aria-hidden="true"></i></span>Revisions</a><a href="/Kosei-Yoshida/items/7afe6c2f6158f36f50b1/patches" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-inbox css-1jqivyb" aria-hidden="true"></i></span>Edit Requests</a><a href="/Kosei-Yoshida/items/7afe6c2f6158f36f50b1/likers" class="css-154zy0m"><span class="css-yikrym"><svg size="13" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 392.81 429" color="rgba(0, 0, 0, 0.6)" class="css-le4d8r e31pr5q0"><path d="M14.19 5.4h53.86v149.45h90.05v44.87H14.19zM288.4 93.77h100.79q1.29 25-5.66 45.39a96.79 96.79 0 01-20.33 34.89 92 92 0 01-32.13 22.45 104 104 0 01-40.95 7.93 109.71 109.71 0 01-76-29.92 104.05 104.05 0 01-23-32.56 95.46 95.46 0 01-8.47-39.88 94.78 94.78 0 018.47-39.87 104.38 104.38 0 0123-32.42A107.71 107.71 0 01248.23 8a110.79 110.79 0 01118.48 22.49l-35.07 35.08a51.25 51.25 0 00-17.75-15 52.83 52.83 0 00-44.67-1.23 52.92 52.92 0 00-17 12 57.07 57.07 0 00-11.45 18.11 60 60 0 00-4.23 22.77 60 60 0 004.23 22.68 56.57 56.57 0 0011.45 18.19 52.62 52.62 0 0017 12 50.5 50.5 0 0020.9 4.36q20.19 0 31.07-7.51a35.75 35.75 0 0014.46-20.55h-47.39zM51.29 279.55H0v-44.86h156v44.86h-51.13V429H51.29zM283.36 381.71l-41.72-62V429h-53.86V234.69h47.47L290 312l55.9-77.29h46.9V429h-53.86V320.27l-42.43 61.44z"></path></svg></span>Show all likers</a><a href="/Kosei-Yoshida/items/7afe6c2f6158f36f50b1.md" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-file-text-o css-1jqivyb" aria-hidden="true"></i></span>Show article in Markdown</a><div class="css-1ode1bp"></div><div class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-flag css-1jqivyb" aria-hidden="true"></i></span>Report article</div></div><div class="st-Modal"><div class="st-Modal_backdrop"></div><div class="st-Modal_body"><form><div class="st-Form"><span class="st-Form_label">Help us understand the problem. What is going on with this article?</span></div><div class="st-Form"><label><input type="radio" name="reason" value="illegal" required=""/>It&#x27;s illegal (copyright infringement, privacy infringement, libel, etc.)</label></div><div class="st-Form"><label><input type="radio" name="reason" value="inappropriate_content" required=""/>It&#x27;s socially inappropriate (offensive to public order and morals)</label></div><div class="st-Form"><label><input type="radio" name="reason" value="advertising" required=""/>It&#x27;s advertising</label></div><div class="st-Form"><label><input type="radio" name="reason" value="spam" required=""/>It&#x27;s spam</label></div><div class="st-Form"><label><input type="radio" name="reason" value="guideline_violation" required=""/>Other than the above, but not suitable for the Qiita community (violation of guidelines)</label></div><div class="st-Form st-Form-right"><input type="submit" class="st-Form_submit" value="Submit"/></div></form></div></div></div></div></div></div>
      <script type="application/json" class="js-react-on-rails-component" data-component-name="PersonalArticlePage" data-dom-id="PersonalArticlePage-react-component-4f5e9ca6-0e85-44ba-81cb-09b28c837bc8">{"authorAnalyticsTrackingId":null,"organizationAnalyticsTrackingId":null}</script>
      
<footer id="globalFooter" class="st-Footer"><div class="st-Footer_container"><div class="st-Footer_start"><div class="st-Footer_logo"><svg viewbox="0 0 426.57 130" xmlns="http://www.w3.org/2000/svg"><circle cx="167.08" cy="21.4" r="12.28" /><path d="M250.81 29.66h23.48v18.9h-23.48z" /><path d="M300.76 105.26a22.23 22.23 0 01-6.26-.86 12.68 12.68 0 01-5.17-3 14.41 14.41 0 01-3.56-5.76 28 28 0 01-1.3-9.22V48.56h29.61v-18.9h-29.52V3.29h-20.17v83.34q0 11.16 2.83 18.27a27.71 27.71 0 007.7 11.2 26.86 26.86 0 0011.43 5.62 47.56 47.56 0 0012.34 1.53h15.16v-18zM0 61.7a58.6 58.6 0 015-24.21A62.26 62.26 0 0118.73 17.9 63.72 63.72 0 0139 4.78 64.93 64.93 0 0164 0a65 65 0 0124.85 4.78 64.24 64.24 0 0120.38 13.12A62 62 0 01123 37.49a58.6 58.6 0 015 24.21 58.34 58.34 0 01-4 21.46 62.8 62.8 0 01-10.91 18.16l11.1 11.1a10.3 10.3 0 010 14.52 10.29 10.29 0 01-14.64 0l-12.22-12.41a65 65 0 01-15.78 6.65 66.32 66.32 0 01-17.55 2.3 64.63 64.63 0 01-45.23-18A62.82 62.82 0 015 85.81 58.3 58.3 0 010 61.7zm21.64.08a43.13 43.13 0 0012.42 30.63 42.23 42.23 0 0013.43 9.09A41.31 41.31 0 0064 104.8a42 42 0 0030-12.39 42.37 42.37 0 009-13.64 43.43 43.43 0 003.3-17 43.77 43.77 0 00-3.3-17A41.7 41.7 0 0080.55 22 41.78 41.78 0 0064 18.68 41.31 41.31 0 0047.49 22a42.37 42.37 0 00-13.43 9.08 43.37 43.37 0 00-12.42 30.7zM331.89 78a47.59 47.59 0 013.3-17.73 43.22 43.22 0 019.34-14.47A44.25 44.25 0 01359 36a47.82 47.82 0 0118.81-3.58 42.72 42.72 0 019.26 1 46.5 46.5 0 018.22 2.58 40 40 0 017 3.84 44.39 44.39 0 015.71 4.63l1.22-9.47h17.35v85.83h-17.35l-1.17-9.42a42.54 42.54 0 01-5.84 4.67 43.11 43.11 0 01-7 3.79 44.86 44.86 0 01-8.17 2.59 43 43 0 01-9.22 1A47.94 47.94 0 01359 119.9a43.3 43.3 0 01-14.47-9.71 44.17 44.17 0 01-9.34-14.47 47 47 0 01-3.3-17.72zm20.27-.08a29.16 29.16 0 002.17 11.34 27 27 0 005.92 8.88 26.69 26.69 0 008.76 5.76 29.19 29.19 0 0021.44 0 26.11 26.11 0 008.72-5.76 27.57 27.57 0 005.88-8.84 29 29 0 002.16-11.38 28.62 28.62 0 00-2.16-11.22 26.57 26.57 0 00-5.93-8.8 27.68 27.68 0 00-19.51-7.9 28.29 28.29 0 00-10.77 2.05 26.19 26.19 0 00-8.71 5.75 27.08 27.08 0 00-5.84 8.8 28.94 28.94 0 00-2.13 11.31zm-194.97-30.5h19.78v73.54h-19.78zm49.25 0h19.78v73.54h-19.78z" /><circle cx="216.33" cy="21.4" r="12.28" /></svg></div><div class="st-Footer_catchcopy">How developers code is here.</div><div class="st-Footer_socials"><a class="fa fa-twitter" href="https://twitter.com/qiita"></a><a class="fa fa-facebook-square" href="https://www.facebook.com/qiita/"></a></div></div><div class="st-Footer_end"><div class="st-Footer_qiita"><div class="st-Footer_label">Qiita</div><div class="st-Footer_list"><div class="st-Footer_column"><a href="/about">About</a><a href="/terms">Terms</a><a href="/privacy">Privacy</a><a target="_blank" href="http://help.qiita.com/ja/articles/qiita-community-guideline">Guideline</a><a target="_blank" href="https://help.qiita.com/ja/articles/others-brand-guideline">Design Guideline</a></div><div class="st-Footer_column"><a href="/release-notes">Release</a><a href="/api/v2/docs">API</a><a href="/feedback/new">ご意見</a><a href="https://help.qiita.com">Help</a><a target="_blank" href="https://qiita.com/ads?utm_source=qiita&amp;utm_medium=referral&amp;utm_content=footer">Advertisement</a></div></div></div><div class="st-Footer_increments"><div class="st-Footer_label">Increments</div><div class="st-Footer_list"><div class="st-Footer_column"><a href="https://increments.co.jp/company/">About</a><a href="https://increments.co.jp/jobs/">採用情報</a><a href="https://blog.qiita.com">Blog</a></div><div class="st-Footer_column"><a href="https://teams.qiita.com/">Qiita Team</a><a href="https://jobs.qiita.com?utm_source=qiita&amp;utm_medium=referral&amp;utm_content=footer">Qiita Jobs</a><a href="https://zine.qiita.com?utm_source=qiita&amp;utm_medium=referral&amp;utm_content=footer">Qiita Zine</a></div></div></div></div></div><div class="st-Footer_copyright">© 2011-2021 Increments Inc.</div></footer><div id="Snackbar-react-component-cbe2dd04-6814-4c7a-8aaf-ac376d883896"></div>
      <script type="application/json" class="js-react-on-rails-component" data-component-name="Snackbar" data-dom-id="Snackbar-react-component-cbe2dd04-6814-4c7a-8aaf-ac376d883896">{}</script>
      
<div id="LoginModal-react-component-436c8af7-8347-4f36-88ef-1a65b5d1b16b"></div>
      <script type="application/json" class="js-react-on-rails-component" data-component-name="LoginModal" data-dom-id="LoginModal-react-component-436c8af7-8347-4f36-88ef-1a65b5d1b16b">{}</script>
      
<div id="StockModal-react-component-30008146-7877-4910-ac81-f60a91fd5f0c"></div>
      <script type="application/json" class="js-react-on-rails-component" data-component-name="StockModal" data-dom-id="StockModal-react-component-30008146-7877-4910-ac81-f60a91fd5f0c">{}</script>
      
</div><div id="dataContainer" style="display: none;" data-config="{&quot;actionPath&quot;:&quot;public/items#show&quot;,&quot;settings&quot;:{&quot;analyticsTrackingId&quot;:&quot;UA-24675221-12&quot;,&quot;assetsMap&quot;:{},&quot;csrfToken&quot;:&quot;RE9++5MBIXrk99kOkKUk0CmKsHVsge9h4QgnouZLaR05D+MT/2yH4CsPScIapVxYueASxWnSTY+j6yEUouhuIw==&quot;,&quot;locale&quot;:&quot;en&quot;},&quot;currentUser&quot;:null}" /></body></html><script type="application/json" data-js-react-on-rails-store="AppStoreWithReactOnRails">{"snackbar":{"type":"","body":"","isActive":false},"article":{"article":{"body":"\u003cdiv class=\"code-frame\" data-lang=\"c#\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"1:Before await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"2:In task run. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"3:After await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003eいきなりですが問題です。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e上のコードには3つのPrint出力があり、それぞれの出力処理が行われる実行スレッドを出力します。\u003cbr\u003e\nではこのコードを実行した場合、それぞれの出力の実行スレッドはどうなるでしょうか？\u003c/p\u003e\n\n\u003cp\u003e①1~3全て同じスレッドになる\u003cbr\u003e\n②1~3全て別のスレッドになる\u003cbr\u003e\n③1,2が同じスレッドで、3だけ別スレッド\u003cbr\u003e\n④1,3が同じスレッドで、2だけ別スレッド\u003c/p\u003e\n\n\u003cp\u003eただし、WPFアプリケーションでの実行+このメソッドはメインスレッドから呼ばれるとする。\u003c/p\u003e\n\n\u003cp\u003eこの記事を読むと、この問題の答えは何か？なぜそうなるのか？が理解できます。\u003c/p\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"はじめに\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eはじめに\u003c/h1\u003e\n\n\u003cp\u003eC#の非同期処理について調べだすと、\u003cstrong\u003e「同期コンテキストが存在する場合、awaitは処理後に自動でスレッドを戻してくれる」、という説明をよく見ます。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e自分はその説明を読んだだけではしっかり意味がわからなかったので、\u003cstrong\u003e実際にコードを書いてみてその辺りの動きを確認\u003c/strong\u003eしようと思いました。\u003c/p\u003e\n\n\u003cp\u003eその確認した内容を、自分の備忘録、兼、他の人の理解の助けにもなるだろうと思いまとめたのがこの記事です。\u003c/p\u003e\n\n\u003cp\u003eまたawait利用時の同期コンテキストがわかれば、副産物として\u003ccode\u003eTask.Wait\u003c/code\u003e, \u003ccode\u003eTask.Result\u003c/code\u003eの利用が推奨されていない理由も理解しやすくるなるので、そちらについても書いています。\u003c/p\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"想定してる読者\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E6%83%B3%E5%AE%9A%E3%81%97%E3%81%A6%E3%82%8B%E8%AA%AD%E8%80%85\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e想定してる読者\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003eC#の基本文法はわかっている\u003c/li\u003e\n\u003cli\u003easync/await, Taskの存在ぐらいは知っている\u003c/li\u003e\n\u003cli\u003e記事の冒頭にある問題がわからなかった\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"環境\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E7%92%B0%E5%A2%83\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e環境\u003c/h2\u003e\n\n\u003cp\u003e記事の中ででてくるコードはWPFで動かしています。\u003cbr\u003e\nただWindowsFormやUnityなどの\"C#+GUI\"のものなら理屈はほぼ同じなはずなので、その辺を普段使っている人にも読んでもらえると思います。\u003c/p\u003e\n\n\u003cp\u003e※CUIアプリケーションでは、この記事に書いてある内容が一部通じないので注意してください。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eWPF （C#のGUIフレームワーク）\u003c/li\u003e\n\u003cli\u003e.NET Core 3.1\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"同期コンテキストとは何か\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%A8%E3%81%AF%E4%BD%95%E3%81%8B\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e同期コンテキストとは何か？\u003c/h1\u003e\n\n\u003cp\u003e「同期コンテキスト ≒ 複数スレッドに跨る処理を安全に行うための仕組み」です。\u003c/p\u003e\n\n\u003cp\u003e非同期処理は、うっかりすると、デッドロックや再現性の低いバグを起こしてしまいます。\u003cbr\u003e\nこのようなバグはほとんどがマルチスレッドの処理が原因で起きるものです。\u003cbr\u003e\n同期コンテキストは、スレッド間の処理の受け渡しなどを上手く管理してくれる仕組みです。\u003c/p\u003e\n\n\u003cp\u003eつまり、\u003cstrong\u003e同期コンテキストというのは、マルチスレッド処理が原因の不具合を避けC#の非同期処理を安全に使いやすくしてくれるための仕組みです。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eC#では同期コンテキストの仕組みを扱うために\u003ccode\u003eSystem.Threading.SynchronizationContext\u003c/code\u003eクラスとうものが用意されています。実は、\u003ccode\u003eawait\u003c/code\u003eを利用している裏ではこの\u003ccode\u003eSynchronizationContext\u003c/code\u003eが良い感じにスレッド間の動きを調整してくれているのです。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.synchronizationcontext?view=net-5.0\" rel=\"nofollow noopener\" target=\"_blank\"\u003eSystem.Threading.SynchronizationContext\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"awaitと同期コンテキスト\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#await%E3%81%A8%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eawaitと同期コンテキスト\u003c/h1\u003e\n\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003eを使ったときの同期コンテキストがどうなっているか見ていきます。\u003c/p\u003e\n\n\u003cp\u003e下のコードは、単純に\u003ccode\u003eawait\u003c/code\u003eを使った場合について実行スレッドがどうなっているかを確かめるもので、記事の冒頭に書いた問題に、メソッドを呼び出すButton_Clickがついただけのコードです。\u003cbr\u003e\n（画面上にButtonが一つ置いており、それを押すとButton_Clickが呼ばれるという状況です）\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"c#\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eButton_Click\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003esender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eRoutedEventArgs\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"Button click. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"Before await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"In task run. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"After await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e実行結果\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003eButton click. Thread Id: 1\nBefore await. Thread Id: 1\nIn task run. Thread Id: 5\nAfter await. Thread Id: 1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003eしている\u003ccode\u003eTask.Run()\u003c/code\u003eの中では、スレッドIdが異なっています。逆に\u003ccode\u003eawait\u003c/code\u003eの前後では、スレッドIdが一致しています。\u003cbr\u003e\n（なので、記事冒頭の問題の答えは「④1,3が同じスレッドで、2だけ別スレッド」でした。）\u003c/p\u003e\n\n\u003cp\u003eつまり、\u003cstrong\u003eawaitには、「awaitする前後で実行スレッドを保存しておく機能」があります。\u003c/strong\u003e\u003cbr\u003e\nもっと正確にいうと、\u003ccode\u003eawait\u003c/code\u003eには「\u003ccode\u003eSystem.Threading.SynchronizationContext.Current\u003c/code\u003eがnullでない場合に、\u003ccode\u003eawait\u003c/code\u003eの前後で実行スレッドを自動で保存してくれる機能」があります。\u003c/p\u003e\n\n\u003cp\u003e詳しくは後述しますが、WPFなどではメインスレッドに対して自動で\u003ccode\u003eSynchronizationContext.Current\u003c/code\u003eがセットされています。そして上のコードではメインスレッド上で\u003ccode\u003eawait Task.Run()\u003c/code\u003eが実行されているため、その後にスレッドが元に戻っています。\u003c/p\u003e\n\n\u003cp\u003e自動でセットされている\u003ccode\u003eSynchronizationContext.Current\u003c/code\u003eを、意図的に\u003ccode\u003enull\u003c/code\u003eにした場合も見ておきましょう。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"C#\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eSynchronizationContext.Currentがnullの場合\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eButton_Click\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003esender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eRoutedEventArgs\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"ButtonClick. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"Before await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// SynchronizationContext.Currentをnullに設定する。ここではメインスレッドに対して設定している。\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eSynchronizationContext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eSetSynchronizationContext\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"In task run. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"After await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e実行結果\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003eButtonClick. Thread Id: 1\nBefore await. Thread Id: 1\nIn task run. Thread Id: 5\nAfter await. Thread Id: 5\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e後にスレッドが元に戻らず\u003ccode\u003eTask.Run()\u003c/code\u003eの中と同じスレッドIdとなっています。\u003cbr\u003e\nこれは、\u003ccode\u003eawait\u003c/code\u003eする前のスレッド（ここではメインスレッド）で、\u003ccode\u003eSynchronizationContext.Current\u003c/code\u003eに\u003ccode\u003enull\u003c/code\u003eが代入されたためです。\u003cbr\u003e\n※通常このような処理をする事はないと思います。ここでは説明のため、わざと\u003ccode\u003enull\u003c/code\u003eを代入しています。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eawaitにはその前後で実行スレッドを自動で保存してくれる機能があり、それは\"SynchronizationContext.Current != null\"の場合のみ働く。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eこの辺りの働きをさらに詳しく知りたければ、以下のページなどが参考になると思います。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/archive/msdn-magazine/2015/november/asynchronous-programming-async-from-the-start\" rel=\"nofollow noopener\" target=\"_blank\"\u003e非同期プログラミング - スタートアップから非同期に\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"そもそもsynchronizationcontextcurrentはどこでセットされているのか\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%81%9D%E3%82%82%E3%81%9D%E3%82%82synchronizationcontextcurrent%E3%81%AF%E3%81%A9%E3%81%93%E3%81%A7%E3%82%BB%E3%83%83%E3%83%88%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%8B\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eそもそもSynchronizationContext.Currentはどこでセットされているのか\u003c/h4\u003e\n\n\u003cp\u003e上でWPFなどではメインスレッドに対して自動で同期コンテキスト（\u003ccode\u003eSynchronizationContext.Current\u003c/code\u003e）が設定されていると書きました。\u003cbr\u003e\nでは、メインスレッドの同期コンテキストはどこで設定されているのでしょうか？\u003c/p\u003e\n\n\u003cp\u003eWPFの場合は、\u003ccode\u003eSystem.Windows.Threading.DispatcherSynchronizationContext\u003c/code\u003e（\u003ccode\u003eSystem.Threading.SynchronizationContext\u003c/code\u003eクラスを継承）が、メインスレッドの\u003ccode\u003eSynchronizationContext.Current\u003c/code\u003eとして自動で設定されています。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/dotnet/api/system.windows.threading.dispatchersynchronizationcontext?view=net-5.0\" rel=\"nofollow noopener\" target=\"_blank\"\u003eSystem.Windows.Threading.DispatcherSynchronizationContext\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eWindowsFormやUnityの場合もそれぞれ適当なクラスがメインスレッドの同期コンテキストとして自動で設定されています。そのため、メインスレッドで\u003ccode\u003eawait\u003c/code\u003eを使った場合には、自動でスレッドが元に戻るようになっています。\u003c/p\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"cuiとguiだと何故挙動が変わるか\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#cui%E3%81%A8gui%E3%81%A0%E3%81%A8%E4%BD%95%E6%95%85%E6%8C%99%E5%8B%95%E3%81%8C%E5%A4%89%E3%82%8F%E3%82%8B%E3%81%8B\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eCUIとGUIだと何故挙動が変わるか\u003c/h4\u003e\n\n\u003cp\u003e環境の項目で、次のように書きました。\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e※CUIアプリケーションでは、この記事に書いてある内容が一部通じないので注意してください。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eこれは、上述したようにGUIアプリケーションではメインスレッド（UIスレッド）に対する同期コンテキストが自動で設定されているのに対し、CUIアプリケーションではそれが行われていないためです。\u003cbr\u003e\n逆に言えば、根本的な\u003ccode\u003eawait\u003c/code\u003eの働き自体にはGUIとCUIで差がありません。\u003cbr\u003e\nCUIでも同期コンテキストが設定されていれば、\u003ccode\u003eawait\u003c/code\u003e後にスレッドが元に戻ります。\u003c/p\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"await自体には別スレッドに切り替える働きがないことに注意\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#await%E8%87%AA%E4%BD%93%E3%81%AB%E3%81%AF%E5%88%A5%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%AB%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%82%8B%E5%83%8D%E3%81%8D%E3%81%8C%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E3%81%AB%E6%B3%A8%E6%84%8F\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eawait自体には、別スレッドに切り替える働きがないことに注意\u003c/h4\u003e\n\n\u003cp\u003eここまで見てきたコードで一つ勘違いしやすいポイントがあります。\u003cbr\u003e\nそれは、\u003cstrong\u003eawaitには別スレッドに切り替える働きはない\u003c/strong\u003eということです。\u003c/p\u003e\n\n\u003cp\u003e上のコード例では、\u003ccode\u003eawait\u003c/code\u003eしている部分でスレッドIdが変化していますが、これは\u003ccode\u003eawait\u003c/code\u003eの働きではなく\u003ccode\u003eTask.Run()\u003c/code\u003eの働きによるものです。\u003cstrong\u003eTask.Run()は、その引き数に与えられたデリゲートをスレッドプール上で実行します。この働きによって実行スレッドが変わっています。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task.run?view=net-5.0\" rel=\"nofollow noopener\" target=\"_blank\"\u003eSystem.Threading.Task.Run\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e上のコードもよく見てもらうと、Button_Clickから\u003ccode\u003eawait\u003c/code\u003eをつけてMethodAsyncが実行されていますが、Button_Click内と、MethodAsyncの\u003ccode\u003eawait\u003c/code\u003e前の部分で実行スレッドが変化していません。\u003c/p\u003e\n\n\u003cp\u003eスレッドプールについても一応簡単に説明しておきます。\u003cbr\u003e\nスレッドは必要になったときにその都度新しくつくるより、最初にいくつかつくっておきそれを使いまわす方が効率が良いです。その使いまわしの仕組みがスレッドプールです。\u003cbr\u003e\nC#には\u003ccode\u003eTask.Run\u003c/code\u003eなどスレッドプールを簡単に使うために提供されている仕組みがあるので、基本的にスレッドプールも自分で直接操作する必要はなく、それらを使えば大丈夫です。\u003cbr\u003e\nスレッドプールの働きなどについてもう少し知りたければ以下の記事がわかりやすいです。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://ufcpp.net/study/csharp/misc_task.html\" rel=\"nofollow noopener\" target=\"_blank\"\u003eufcpp [雑記] スレッド プールとタスク\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"awaitと同期コンテキストの働きのまとめ\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#await%E3%81%A8%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%AE%E5%83%8D%E3%81%8D%E3%81%AE%E3%81%BE%E3%81%A8%E3%82%81\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eawaitと同期コンテキストの働きのまとめ\u003c/h4\u003e\n\n\u003cp\u003e単純に\u003ccode\u003eawait\u003c/code\u003eを利用した場合の同期コンテキストの動きについてまとめておきます。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003ccode\u003eawait\u003c/code\u003eには、その前後で実行スレッドを保存してくれる働きがある\n\n\u003cul\u003e\n\u003cli\u003e正確には実行スレッドではなく同期コンテキストを保存している\u003c/li\u003e\n\u003cli\u003eこの働きは、\u003ccode\u003eSystem.Threading.SynchronizationContext.Current\u003c/code\u003eが\u003ccode\u003enull\u003c/code\u003eでない場合にのみ働く\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eWPFなどではメインスレッドに対して自動で実行コンテキスト（\u003ccode\u003eSynchronizationContext.Current\u003c/code\u003e）が設定されている\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003eawait\u003c/code\u003eしただけでは、その処理の実行スレッドは変わらない\n\n\u003cul\u003e\n\u003cli\u003e実行スレッドが変化するのは\u003ccode\u003eTask.Run()\u003c/code\u003eなどの機能\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"taskwait-taskresultが推奨でない理由\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#taskwait-taskresult%E3%81%8C%E6%8E%A8%E5%A5%A8%E3%81%A7%E3%81%AA%E3%81%84%E7%90%86%E7%94%B1\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eTask.Wait, Task.Resultが推奨でない理由\u003c/h1\u003e\n\n\u003cp\u003eC#の非同期処理について調べると、「\u003ccode\u003eTask.Wait\u003c/code\u003e, \u003ccode\u003eTask.Result\u003c/code\u003eは使ってはいけない」という記述がよく見られます。この理由は、\u003ccode\u003eawait\u003c/code\u003eを使う際の同期コンテキストの働きを知っていれば、容易に理解できます。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eTask.Wait\u003c/code\u003e, \u003ccode\u003eTask.Result\u003c/code\u003eが推奨でない理由は、デッドロックが簡単に起きてしまうからです。\u003cbr\u003e\nまず、\u003ccode\u003eTask.Wait\u003c/code\u003eを使ってデッドロックが起きてしまう例を見てみます。\u003cbr\u003e\n例の中で行っているのは、\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eTaskをWaitすること\u003c/li\u003e\n\u003cli\u003eWaitされているTaskの中ではawait Task.Run()が使うこと\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eだけです。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"c#\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eTask.Waitでデッドロックするパターン\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eButton_Click\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003esender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eRoutedEventArgs\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003eMethodWait\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// awaitを使っていないのでasync不要。\u003c/span\u003e\n\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodWait\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"Before await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003etask\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 結果待ちをするためにスレッドをロックして他のスレッドから触れなくしてしまう。\u003c/span\u003e\n    \u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWait\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"After wait. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 処理終了後に元のスレッドに戻そうとするが、元のスレッドがTask.Wait()によりロックされており戻せない。\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"In task run. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e実行結果\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003eBefore await. Thread Id: 1\nIn task run.Thread Id: 4\n// (After wait.~は出力されずUIもフリーズする）\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eMethodAsync()内の処理まで実行された後、task.Wait()の部分で処理がフリーズしてしまっています。\u003cbr\u003e\nこれは、以下のようにお互いの処理待ちをしてしまうからです。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003etask.Wait側は、タスクの完了までスレッドをロックする\u003c/li\u003e\n\u003cli\u003eawait Task.Run()~側は、処理終了し元のスレッドに戻して完了させたいが、元のスレッドがロックされているので戻せず完了できない\n\n\u003cul\u003e\n\u003cli\u003e\n\u003ccode\u003eTask.Run()\u003c/code\u003eの働きにより別スレッドで実行されている。\u003ccode\u003eawait\u003c/code\u003eはその後スレッドを元に戻そうとする。\u003c/li\u003e\n\u003cli\u003e元のスレッドに戻すとこまでやって、このTask(MethodAsync()の戻り値)は完了となる\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eこのように、\u003cstrong\u003eawaitが自動で行ってくれている同期コンテキストの保存と、Task.Wait(Task.Result)によるスレッドのロックが組み合わさることによりデッドロック起きてしまいます。\u003c/strong\u003e\u003cbr\u003e\nそのため、\u003ccode\u003eawait\u003c/code\u003eか\u003ccode\u003eTask.Wait\u003c/code\u003eのどちらかの利用を避けたいところです。\u003cbr\u003e\nここで、\u003ccode\u003eawait\u003c/code\u003eは有用な仕組みのため、\u003ccode\u003eTask.Wait\u003c/code\u003e(\u003ccode\u003eTask.Result\u003c/code\u003e)の利用を抑えます。\u003cbr\u003e\nこれが、\u003ccode\u003eTask.Wait\u003c/code\u003e, \u003ccode\u003eTask.Result\u003c/code\u003eの利用が推奨されない理由です。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task.wait?view=net-5.0\" rel=\"nofollow noopener\" target=\"_blank\"\u003eSystem.Threading.Tasks.Task.Wait\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task-1.result?view=net-5.0\" rel=\"nofollow noopener\" target=\"_blank\"\u003eSystem.Threading.Tasks.Task.Result\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e（Task.Resultがやっていることは、Task.Wait+結果取り出しです。つまり、デッドロックが起きる理由はTask.Waitと同様なため、ここでは解説を省略します。）\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"呼び出し元から非同期化することによってwaitを使わない\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E5%85%83%E3%81%8B%E3%82%89%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%8C%96%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6wait%E3%82%92%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e呼び出し元から非同期化することによってWaitを使わない。\u003c/h3\u003e\n\n\u003cp\u003eTask.Waitは利用したくないと書きましたが、その一番シンプルな代替方法はawaitを使うことです。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"c#\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eTask.Waitではなくawaitを使う\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eButton_Click\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003esender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eRoutedEventArgs\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAwaitAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAwaitAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"Before await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003etask\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"After wait. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"In task run. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e実行結果\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003eBefore await. Thread Id: 1\nIn task run.Thread Id: 4\nAfter wait. Thread Id: 1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eきちんとフリーズすることなく実行されました。\u003cbr\u003e\n\u003ccode\u003eTask.Wait\u003c/code\u003eの代わりに\u003ccode\u003eawait\u003c/code\u003eで処理完了を待っています。また、\u003ccode\u003eawait\u003c/code\u003eを使うためにメソッドに\u003ccode\u003easync\u003c/code\u003eキーワードがついています。（\u003ccode\u003easync\u003c/code\u003eを使う場合は戻り値を\u003ccode\u003evoid\u003c/code\u003eではなく\u003ccode\u003eTask\u003c/code\u003eあるいは\u003ccode\u003eTask\u0026lt;TResult\u0026gt;\u003c/code\u003eとしましょう。その唯一の例外は、上コードのButton_ClickのようにUIイベントにデリゲートを登録する場合だけです。）\u003c/p\u003e\n\n\u003cp\u003eこの例のように、\u003ccode\u003eTask.Wait\u003c/code\u003eではなく\u003ccode\u003eawait\u003c/code\u003eを使うようにしていくと、呼び出し元のメソッドも\u003ccode\u003easync/await\u003c/code\u003eを使う必要があり、自然と一連の処理が全て非同期メソッドとなっていきます。\u003cbr\u003e\n「呼び出し元まで全て非同期メソッドにしていってよいのか？」と迷うかもしれませんが、\u003cstrong\u003e呼び出し元から非同期コードで統一することはMicrosoftのベストプラクティスでも推奨されています。\u003c/strong\u003eぜひやりましょう。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming\" rel=\"nofollow noopener\" target=\"_blank\"\u003e非同期プログラミングのベスト プラクティス\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"waitを使いたいならconfigureawaitを使う\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#wait%E3%82%92%E4%BD%BF%E3%81%84%E3%81%9F%E3%81%84%E3%81%AA%E3%82%89configureawait%E3%82%92%E4%BD%BF%E3%81%86\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eWaitを使いたいならConfigureAwaitを使う\u003c/h3\u003e\n\n\u003cp\u003eまた、\u003ccode\u003eawait\u003c/code\u003e後に元のスレッドに戻そうとすることでデッドロックが起きるなら、その働きをなくすことでもデッドロックを防ぐことができます。\u003cbr\u003e\nやり方は、\u003ccode\u003eawait\u003c/code\u003eしている\u003ccode\u003eTask\u003c/code\u003eの後ろに\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eをつけるだけです。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"c#\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eConfigureAwait(false)を使ってデッドロックを防ぐ\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eButton_Click\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003esender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eRoutedEventArgs\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003eMethodWait\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// awaitを使っていないのでasync不要。\u003c/span\u003e\n\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodWait\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"Before await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003etask\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 結果待ちをするためにスレッドをロックして他のスレッドから触れなくしてしまう。\u003c/span\u003e\n    \u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWait\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"After wait. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"In task run. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eConfigureAwait\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// ConfigureAwait(false)の後なのでメインスレッドに戻らず実行される。\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"After configure await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e実行結果\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003eBefore await. Thread Id: 1\nIn task run.Thread Id: 4\nAfter configure await. Thread Id: 4\nAfter wait. Thread Id: 1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e詳しくは下で説明しますが、\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eを利用することで、\u003ccode\u003eawait\u003c/code\u003e後に元のスレッドに戻る働きをなくし、デッドロックを防ぐことができます。\u003cbr\u003e\n（元のスレッドに戻らないのは\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eを使った\u003ccode\u003easync\u003c/code\u003eメソッド内だけです。）\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e基本的には上で紹介したように、そもそもTask.Wait(Task.Result)を使わずに全てawaitに置き換えることが理想です。\u003c/strong\u003e\u003cbr\u003e\nしかし、ライブラリ作成者と利用者が一致しない場合など、利用者側にそれを徹底できない場合があります。\u003cbr\u003e\nそのため、\u003cstrong\u003e同期コンテキストを保持する必要がない場合はConfigureAwait(false)をつけ、コンテキストに依存しないコードを書くようにしておくのが無難です。\u003c/strong\u003e（特に誰が利用するかわからないコードを書く時は）\u003c/p\u003e\n\n\u003cp\u003eMicrosoftのベストプラクティスでも以下のように書かれています。\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e... 可能な場合は常に ConfigureAwait を使用すべきであるということになります。コンテキストに依存しないコードは、GUI アプリケーションのパフォーマンスを向上し、部分的に非同期のコードベースに取り組む際のデッドロックを回避するのに役立ちます。この指針の例外は、コンテキストが必要なメソッドです。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming\" rel=\"nofollow noopener\" target=\"_blank\"\u003e非同期プログラミングのベスト プラクティス\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"awaitで同期コンテキストを保持しない\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#await%E3%81%A7%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%97%E3%81%AA%E3%81%84\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eawaitで同期コンテキストを保持しない\u003c/h1\u003e\n\n\u003cp\u003e上で、\u003ccode\u003eTask.Wait\u003c/code\u003eと\u003ccode\u003eawait\u003c/code\u003eの併用によるデッドロックを避けるため、\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eオプションを使うと書きました。\u003cbr\u003e\nこれは、オプションをつけることにより、同期コンテキストを意図的に保持しないという選択になります。\u003cbr\u003e\n\u003cstrong\u003eこの章では、その「同期コンテキストを保持しない」というところについて、もう少し掘り下げていきます。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e※説明する人によっては、同期コンテキストを「保持しない」ではなく「キャプチャしない」、「拾わない」と表現している場合もありますが、同じ意味です。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"configureawaitfalse\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#configureawaitfalse\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eConfigureAwait(false)\u003c/h3\u003e\n\n\u003cp\u003eまずは、先ほどもでてきた\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eについてです。\u003cbr\u003e\n凄くシンプルに\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eを使った場合を見てみます。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"c#\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eConfigureAwait(false)をつけると実行コンテキストを拾わない\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eButton_Click\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003esender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eRoutedEventArgs\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"Before await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"In task run. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e)).\u003c/span\u003e\u003cspan class=\"nf\"\u003eConfigureAwait\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"After await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e実行結果\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003eBefore await. Thread Id: 1\nIn task run.Thread Id: 5\nAfter await. Thread Id: 5\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003eしている\u003ccode\u003eTask\u003c/code\u003eに\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eオプションをつけることで、\u003ccode\u003eawait\u003c/code\u003e後に実行スレッドがメインスレッドに戻らなくなっています。\u003cbr\u003e\nこのように、\u003cstrong\u003eawaitするTaskにConfigureAwait(false)オプションをつけると実行コンテキストが保持されなくなります。\u003c/strong\u003e\u003cbr\u003e\n（実行コンテキストを拾わない、キャプチャしないと言ったりもします。）\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task.configureawait?view=net-5.0\" rel=\"nofollow noopener\" target=\"_blank\"\u003eSystem.Threading.Tasks.ConfigureAwait\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e先ほども紹介したように、\u003cstrong\u003eデッドロックなどを防ぐためには、このConfigureAwait(false)などを使って、実行コンテキストを保持しないことがとても重要になってきます。\u003c/strong\u003eC#で非同期処理をするならぜひ覚えておきましょう。\u003c/p\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"configureawaitの注意事項\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#configureawait%E3%81%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eConfigureAwaitの注意事項\u003c/h4\u003e\n\n\u003cp\u003e同期コンテキストを保持しなくなる\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eオプションですが、一点気を付けたい部分があります。\u003cbr\u003e\nそれは、あるasyncメソッド内で一度\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eを使うと、もとの同期コンテキストを復活できないことです。\u003cbr\u003e\nコード例で見てみましょう。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"c#\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eConfigureAwait(false)で同期コンテキストを捨てると復活できない\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eButton_Click\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003esender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eRoutedEventArgs\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"Before await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"In task run1. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e)).\u003c/span\u003e\u003cspan class=\"nf\"\u003eConfigureAwait\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"After await1. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"In task run2. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e)).\u003c/span\u003e\u003cspan class=\"nf\"\u003eConfigureAwait\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"After await2. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e実行結果\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003eBefore await. Thread Id: 1\nIn task run1.Thread Id: 4\nAfter await1. Thread Id: 4\nIn task run2.Thread Id: 5\nAfter await2. Thread Id: 5\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e一つめのawait Task.Run()では\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eを使っているため、\"After await1\"のスレッドIdがメインスレッドと異なっているのは先ほどまでと同じです。\u003cbr\u003e\nただ、二つめのawait Task.Run()では\u003ccode\u003eConfigureAwait(true)\u003c/code\u003eとしているのに、await後の処理がメインスレッドに戻っていません。\u003c/p\u003e\n\n\u003cp\u003easyncメソッド内に\u003ccode\u003eawait\u003c/code\u003eが複数回ある場合、途中で同期コンテキストを捨ててしまって大丈夫か注意してください。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"continuewith\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#continuewith\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eContinueWith\u003c/h3\u003e\n\n\u003cp\u003e上で\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eを使うことによって同期コンテキストを保持しない方法について紹介しましたが、\u003ccode\u003eContinueWith\u003c/code\u003eオプションでも似たようなことができます。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"c#\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eContinueWithをオプションなしで使う\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eButton_Click\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003esender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eRoutedEventArgs\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"Before await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"In task run. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eContinueWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e_\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"Continue. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eTaskScheduler\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDefault\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e実行結果\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003eBefore await. Thread Id: 1\nIn task run.Thread Id: 5\nContinue.Thread Id: 10\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003eContinueWith\u003c/code\u003eの第二引数に\u003ccode\u003eTaskScheduler.Default\u003c/code\u003eを渡すと、第一引き数で渡したデリゲートがスレッドプール上で実行されます。（\u003ccode\u003eContinueWith\u003c/code\u003eの第二引数を省略した場合でも同じようにスレッドプール上で実行されます。\u003ccode\u003eTaskScheduler.Default\u003c/code\u003eが規定値なため）\u003cbr\u003e\n\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eと違って同期コンテキストを捨てているわけではないですが、このようにして、\u003ccode\u003eawait\u003c/code\u003e前のメインスレッドとは違うスレッドで実行することもできます。\u003c/p\u003e\n\n\u003cp\u003e逆に\u003ccode\u003eContinueWith\u003c/code\u003eを使って、\u003ccode\u003eawait\u003c/code\u003e前のスレッドに明示的に処理を戻すこともできます。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"c#\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eContinueWithをつかってawait前のスレッドに戻す\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eButton_Click\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003esender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eRoutedEventArgs\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003easync\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e \u003cspan class=\"nf\"\u003eMethodAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"Before await. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrentSynchronizationContextScheduler\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eTaskScheduler\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eFromCurrentSynchronizationContext\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"In task run. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eContinueWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e_\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"Continue. Thread Id: \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eManagedThreadId\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n            \u003cspan class=\"n\"\u003ecurrentSynchronizationContextScheduler\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e実行結果\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003eBefore await. Thread Id: 1\nIn task run.Thread Id: 4\nContinue.Thread Id: 1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e前に現在の同期コンテキストから\u003ccode\u003eTaskScheduler\u003c/code\u003eをつくっておき\u003ccode\u003eContinueWith\u003c/code\u003eの引数として渡すことで、\u003ccode\u003eawait\u003c/code\u003e前のスレッドで実行できていますね。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eContinueWith\u003c/code\u003eでは、このように\u003ccode\u003eTaskScheduler\u003c/code\u003eを使った柔軟なスレッドコントロールや、\u003ccode\u003eTaskContinuationOptions\u003c/code\u003eを使った処理フローのコントロールが可能です。\u003cbr\u003e\n同期コンテキストを捨てるだけなら\u003ccode\u003eConfigureAwait(false)\u003c/code\u003eで十分ですが、複雑な非同期処理フローが必要になる場合にはこちらを使うと良いでしょう。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.task.continuewith?view=net-5.0#System_Threading_Tasks_Task_ContinueWith_System_Action_System_Threading_Tasks_Task_System_Object__System_Object_System_Threading_Tasks_TaskContinuationOptions_\" rel=\"nofollow noopener\" target=\"_blank\"\u003eSystem.Threading.Tasks.Task.ContinueWith\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.taskscheduler?view=net-5.0\" rel=\"nofollow noopener\" target=\"_blank\"\u003eSystem.Threading.Tasks.TaskScheduler\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=net-5.0\" rel=\"nofollow noopener\" target=\"_blank\"\u003eSystem.Threading.Tasks.TaskContinuationOptions\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"おわりにまとめ\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB%E3%81%BE%E3%81%A8%E3%82%81\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eおわりに、まとめ\u003c/h3\u003e\n\n\u003cp\u003eこの記事では、\u003ccode\u003eawait\u003c/code\u003eを使う際の同期コンテキストの働きについて、実際のコード例とともにまとめました。\u003c/p\u003e\n\n\u003cp\u003e記事冒頭の問題の答えは、「④1,3が同じスレッドで、2だけ別スレッド」です。\u003cbr\u003e\nその理由は、以下です。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eWPFではメインスレッド（UIスレッド）に対して同期コンテキスト（\u003ccode\u003eSynchronizaitonContext.Current\u003c/code\u003e）が自動で設定される\u003c/li\u003e\n\u003cli\u003e同期コンテキストが設定されているスレッドで\u003ccode\u003eawait\u003c/code\u003eを使った場合、\u003ccode\u003eawait\u003c/code\u003e以後の処理に戻る際に同期コンテキストを保持する（≒実行スレッドを元に戻してくれる）\u003c/li\u003e\n\u003cli\u003eTask.Run()での処理はスレッドプール上で行われる（なので2は別スレッドで出力される）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eまた、GUIアプリケーションで\u003ccode\u003eTask.Wait\u003c/code\u003e, \u003ccode\u003eTask.Result\u003c/code\u003eの利用が推奨されない理由は以下です。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e「\u003ccode\u003eTask.Wait\u003c/code\u003e(\u003ccode\u003eTask.Result\u003c/code\u003e)のTaskの処理が完了するまでスレッドをロックする働き」と「\u003ccode\u003eawait\u003c/code\u003eの処理終了後に実行スレッドを元に戻して処理を完了させる働き」がぶつかり、デッドロックを起こすため\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"参考文献\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e参考文献\u003c/h3\u003e\n\n\u003cp\u003eこの記事は、await利用時の同期コンテキストの働きという点に注目してまとめました。\u003c/p\u003e\n\n\u003cp\u003e非同期処理をさらに理解して使いこなすには、複数の人の解説を読んで、色んな角度から見てみるのが良いと思いますので、自分が参考にさせてもらった記事のリンクをいくつか貼らせてもらいます。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\"https://qiita.com/acple@github/items/8f63aacb13de9954c5da#task%E3%81%AF%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%AE%E5%91%AA%E7%B8%9B%E3%81%8B%E3%82%89%E8%A7%A3%E6%94%BE%E3%81%95%E3%82%8C%E3%81%9F-\" id=\"reference-b087017875f52f5b4b90\"\u003eTaskを極めろ！async/await完全攻略\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003eTaskクラスを中心に非同期処理について解説された記事\u003c/li\u003e\n\u003cli\u003e非同期詳しくない人でもめちゃくちゃわかりやすい\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"https://ufcpp.net/study/csharp/sp_thread.html\" rel=\"nofollow noopener\" target=\"_blank\"\u003eufcpp\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003e排他制御とか含めた非同期処理全般についてまとまってる。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ufcpp.wordpress.com/2012/11/12/asyncawait%E3%81%A8%E5%90%8C%E6%99%82%E5%AE%9F%E8%A1%8C%E5%88%B6%E5%BE%A1/\" rel=\"nofollow noopener\" target=\"_blank\"\u003e同期コンテキストをテーマに書かれている部分はこちら\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"https://www.kekyo.net/2016/12/06/6186\" rel=\"nofollow noopener\" target=\"_blank\"\u003ekekyoの丼-できる！C#で非同期処理(Taskとasync-await)\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003eC#の非同期処理入門記事。\u003c/li\u003e\n\u003cli\u003e使い始めの人がやりがちな危ない処理について、\"なぜ使っては駄目か\"がわかりやすくまとまってる。\u003c/li\u003e\n\u003cli\u003e非同期処理を学びだす早い段階で呼んでおくとよさげ。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"https://www.kekyo.net/2015/06/04/4735\" rel=\"nofollow noopener\" target=\"_blank\"\u003ekekyoの丼-.NET非同期処理(async-await)を制御する、様々な方法\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003eより実践的な非同期処理の使い方の話\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"https://www.kekyo.net/2019/10/07/6995\" rel=\"nofollow noopener\" target=\"_blank\"\u003ekekyoの丼-“パターンでわかる! .NET Coreの非同期処理” と楽屋ネタ\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003eより実践的な非同期処理の使い方の話②\u003c/li\u003e\n\u003cli\u003e動画とスライド\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"https://qiita.com/hiki_neet_p/items/d6b3addda6c248e53ef0#synchronizationcontext\" id=\"reference-022971c0f67dfc5b31b9\"\u003eC# 非同期、覚え書き。\u003c/a\u003e\n\n\u003cul\u003e\n\u003cli\u003eC#の非同期処理で使うクラスやメソッドがよくまとまっている\u003c/li\u003e\n\u003cli\u003e非同期処理の基本的なことがわかってから読むとよさげ\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/ja-jp/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming\" rel=\"nofollow noopener\" target=\"_blank\"\u003eMicrosoftドキュメント-Async/Await非同期プログラミングのベスト プラクティス\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","createdAt":"2021-03-02T01:36:45Z","elapsedYearsFromLastModifiedAt":0,"encryptedId":"1JgVPBsduwMahtkbeqbWpV/Vm7bzxJwUWA==--RGmi5YgnWy6dQ3Ob--fABP9DtkHqWAPyDt2dWqHg==","isBanned":false,"isDeprecated":false,"isDestroyableByViewer":false,"isEditRequestReadableByViewer":true,"isEditRequestSendableByViewer":true,"isLikableByViewer":true,"isLikedByViewer":false,"isPublic":true,"isSlide":false,"isStockableByViewer":true,"isStockedByViewer":false,"isSubscribableByViewer":false,"isSubscribedByViewer":false,"isUpdatableByViewer":false,"isUpdated":true,"lastModifiedAt":"2021-03-03T07:16:50Z","likesCount":60,"linkUrl":"https://qiita.com/Kosei-Yoshida/items/7afe6c2f6158f36f50b1","organization":null,"originalId":1400094,"stockedCount":64,"title":"[C#]await利用時の同期コンテキストと実行スレッドの動きについてコードを動かして見ていく","toc":"\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\"#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB\"\u003eはじめに\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#%E6%83%B3%E5%AE%9A%E3%81%97%E3%81%A6%E3%82%8B%E8%AA%AD%E8%80%85\"\u003e想定してる読者\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\"#%E7%92%B0%E5%A2%83\"\u003e環境\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%A8%E3%81%AF%E4%BD%95%E3%81%8B\"\u003e同期コンテキストとは何か？\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#await%E3%81%A8%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88\"\u003eawaitと同期コンテキスト\u003c/a\u003e\n\u003cul\u003e\n\u003cul\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\"#%E3%81%9D%E3%82%82%E3%81%9D%E3%82%82synchronizationcontextcurrent%E3%81%AF%E3%81%A9%E3%81%93%E3%81%A7%E3%82%BB%E3%83%83%E3%83%88%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%8B\"\u003eそもそもSynchronizationContext.Currentはどこでセットされているのか\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#cui%E3%81%A8gui%E3%81%A0%E3%81%A8%E4%BD%95%E6%95%85%E6%8C%99%E5%8B%95%E3%81%8C%E5%A4%89%E3%82%8F%E3%82%8B%E3%81%8B\"\u003eCUIとGUIだと何故挙動が変わるか\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#await%E8%87%AA%E4%BD%93%E3%81%AB%E3%81%AF%E5%88%A5%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%AB%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%82%8B%E5%83%8D%E3%81%8D%E3%81%8C%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E3%81%AB%E6%B3%A8%E6%84%8F\"\u003eawait自体には、別スレッドに切り替える働きがないことに注意\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#await%E3%81%A8%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%AE%E5%83%8D%E3%81%8D%E3%81%AE%E3%81%BE%E3%81%A8%E3%82%81\"\u003eawaitと同期コンテキストの働きのまとめ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/ul\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cli\u003e\n\u003ca href=\"#taskwait-taskresult%E3%81%8C%E6%8E%A8%E5%A5%A8%E3%81%A7%E3%81%AA%E3%81%84%E7%90%86%E7%94%B1\"\u003eTask.Wait, Task.Resultが推奨でない理由\u003c/a\u003e\n\u003cul\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\"#%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E5%85%83%E3%81%8B%E3%82%89%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%8C%96%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6wait%E3%82%92%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84\"\u003e呼び出し元から非同期化することによってWaitを使わない。\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#wait%E3%82%92%E4%BD%BF%E3%81%84%E3%81%9F%E3%81%84%E3%81%AA%E3%82%89configureawait%E3%82%92%E4%BD%BF%E3%81%86\"\u003eWaitを使いたいならConfigureAwaitを使う\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\u003cli\u003e\n\u003ca href=\"#await%E3%81%A7%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%97%E3%81%AA%E3%81%84\"\u003eawaitで同期コンテキストを保持しない\u003c/a\u003e\n\u003cul\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\"#configureawaitfalse\"\u003eConfigureAwait(false)\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\"#configureawait%E3%81%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85\"\u003eConfigureAwaitの注意事項\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#continuewith\"\u003eContinueWith\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB%E3%81%BE%E3%81%A8%E3%82%81\"\u003eおわりに、まとめ\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\"\u003e参考文献\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n","totalPv":9398,"uuid":"7afe6c2f6158f36f50b1","banReason":null,"adventCalendarItem":null,"author":{"encryptedId":"872uAjGMuaY9jlBi5t8F3chLqTMG--NQ1ZEo395WXi+U8n--4W6Ocd/QZwdJL3ijr8B+Bw==","originalId":206591,"description":"","facebookUrl":null,"githubUrl":"https://github.com/KoseiYoshida","isBlockingViewer":false,"isFollowableByViewer":true,"isFollowedByViewer":false,"isTweetWebNotificationReceivable":true,"linkedinUrl":null,"name":"Kosei Yoshida","profileImageUrl":"https://s3-ap-northeast-1.amazonaws.com/qiita-image-store/0/206591/ec95458225498b3b38288ee72ca33adcecf2fa3c/x_large.png?1591664178","profileImageUrlW48":"https://qiita-user-profile-images.imgix.net/https%3A%2F%2Fs3-ap-northeast-1.amazonaws.com%2Fqiita-image-store%2F0%2F206591%2Fec95458225498b3b38288ee72ca33adcecf2fa3c%2Fx_large.png%3F1591664178?ixlib=rb-4.0.0\u0026auto=compress%2Cformat\u0026lossless=0\u0026w=48\u0026s=86877b9b4cd2763a0a490e4872252538","profileImageUrlW75":"https://qiita-user-profile-images.imgix.net/https%3A%2F%2Fs3-ap-northeast-1.amazonaws.com%2Fqiita-image-store%2F0%2F206591%2Fec95458225498b3b38288ee72ca33adcecf2fa3c%2Fx_large.png%3F1591664178?ixlib=rb-4.0.0\u0026auto=compress%2Cformat\u0026lossless=0\u0026w=75\u0026s=7f3c7a8d6eddffdfe19d431f7817743a","urlName":"Kosei-Yoshida","websiteUrl":"","twitterUrl":"https://twitter.com/H9mqVsEISnSFEEY","twitterUrlName":"H9mqVsEISnSFEEY","revealedOrganizations":{"edges":[{"node":{"encryptedId":"Gk417Lsk3jbSDvDpavO7WJ5InDBxcwHI5Dwq--K+mC4KOALr7UUB42--CluPjccFhQ1CG2535QHDTQ==","isBetaReleaseEnabled":false,"isFollowableByViewer":false,"isFollowedByViewer":false,"name":"株式会社Synamon","logoUrl":"https://s3-ap-northeast-1.amazonaws.com/qiita-organization-image/788a109cb689ab1b5028a547f7bf94e63c84be6b/original.jpg?1593083579","urlName":"synamon","description":"Synamonは「XRが当たり前の世界をつくる」ことをミッションに、未来づくりに挑戦しているXRスタートアップです。\r\n市場をつくっていくためには、日常で使われる仕組みを生みだしていくことが重要です。\r\nそのため、toB領域をメインに、未来への取り組みや事業づくりにチャレンジしている企業様への支援や、XR活用のユースケースづくり、継続的に使われるための仕組みづくりに取り組んでいます。","url":"https://synamon.jp/"}}]}},"tags":[{"name":"C#","urlName":"csharp"},{"name":".NET","urlName":".net"},{"name":"WPF","urlName":"wpf"},{"name":"非同期処理","urlName":"%e9%9d%9e%e5%90%8c%e6%9c%9f%e5%87%a6%e7%90%86"}],"followingLikers":{"edges":[]},"comments":{"totalCount":2}},"comments":[],"client":null,"ads_event_emitter":null}}</script>
