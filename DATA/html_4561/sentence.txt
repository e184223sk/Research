More than 1 year has passed since last update.話題に便乗して、C#でどのようにオブジェクト指向プログラミングするか、について書き殴ります。
途中で疲れるかもしれません。
間違っていれば教えてください。（型とデータが不安すぎる......）話題の元記事は↓です。
オブジェクト指向が5000%理解できる記事・C#のオブジェクトは、データと処理をひとまとめにした型のデータ
・C#のオブジェクト指向プログラミングの利点は、データと処理がひとまとめになって名前がついているため、後から探しやすい
・C#のオブジェクト指向プログラミングの利点は、オブジェクト内のデータを隠すことができるため、変更に強い以下では、型とデータ、クラスとオブジェクト、オブジェクト指向プログラミング、の順に説明をしていきます。
（ジェネリクスについては省略します。）型とは、データのあつまりです。
$bool$型は、$[true, false]$という2つの真偽を表すデータのあつまりです。
$int$型は、$[..., -1, 0, 1, 2, ...]$という整数を表すデータのあつまりです。（本当は範囲があるのですがここでは考えません）
$double$型は、実数を表すデータのあつまりです。(範囲があるのですが、考えません)関数もデータです。
簡便のため、「$int$型のデータを引数にとり、$int$型のデータを返す関数」の型を、$(int -&gt; int)$型と表記します。
与えられた整数をそのまま返す関数$IdInt$も$(int -&gt; int)$型です。
与えられた整数に1だけ加えたものを返す関数$SuccInt$も$(int -&gt; int)$型です。
(C#では非常に残念ながら、素直に関数を持ち運びすることができません。
しかし、デリゲートと呼ばれる、持ち運びしたい関数をオブジェクトで包んだ型はあります、が説明しません。
/追記
「素直に関数を持ち運びすることができません」は、「関数を受け取る型がFuncクラス型であるというのは、素直でない」という意味でしたが、僕の勝手な感覚の問題なので修正します。
デリゲートとラムダ式について、説明を追加したいかも。
追記終/)複素数型$Complex$は、2つの実数型$double$、両方のデータで構成されます。
このように、1つ以上の型のデータをすべて持つ型を直積型と呼びます。
C#では、複素数型$Complex$をクラスを用いて以下のように定義できます。(structとか知らん)C#では、構成されるデータに各々名前を付けることができます。(re, im)$bool$型を考えてみます。
$bool$型は、2つの$false$と$true$、どちらか一方のデータで構成されます。
このように、1つ以上の型のデータいずれかを持つ型を直和型と呼びます。
C#では、直和型を素直に定義する方法はありませんが、回りくどいやり方で似たようなことなら可能です。(Visitorパターンとか)
なので、説明しません。
直和型を素直に定義できない言語をモダンな言語といえるのか......直和型の直積型を代数的データ型と呼びます。
説明しません(怒)
C#8はよはよ型は、データのあつまり。関数も含む。
C#では、classキーワードで直積型をつくれる。クラスは1つ以上のデータを持つ直積型であり、オブジェクトはその直積型のデータです。
（もちろんフィールドもメソッドも0個のクラスを定義することはできますが、意味がないので考えません）クラスに属する関数をメソッドと呼びます。
クラスに属する関数以外のデータをフィールドと呼びます。つまり、クラスはメソッドおよびフィールドを持つ直積型で、オブジェクトはクラス型のデータです。メソッドは、CommandとQueryの2種類に分類されます。Commandは、フィールドを変更するだけの手続きです。
Commandの役目はフィールドにデータを再代入することだけです。なので返り値は必ずvoidとなります。Queryは、フィールドから計算して値を返すだけの関数です。
Queryでは、フィールドにデータを再代入することは許されず、また、フィールドのオブジェクトのCommandを呼び出すこともしてはいけません。この原則の利点は、バグの原因となりやすい内部状態(=フィールド)の更新(Command)を隔離し、確認できることです。
どのQueryも、間にCommandを挟まない限り、いくら呼び出しても、順序を変えて呼び出しても、返り値は同じです。
しかし、Commandは内部状態を変更するため、Command同士の順序を変えたり、CommandとQueryの順序を変えたりすると、Queryの返り値が予期せぬ値になることがあります。
使う側として、Commandが少なければ必然的にQueryの返り値も予想しやすく、バグも少なくなります。フィールドとメソッドには、アクセシビリティというものが設定できます。
基本的にpublicとprivateしか使わないので、それ以外は説明しません。
フィールドはprivateで、メソッドはpublicに設定します。privateなデータは外部から、クラス内で定義されたメソッド以外からアクセスすることができません。
つまり、privateなフィールドは、クラス外の関数からは読み書きできず、クラス内のメソッドからのみ読み書きできるのです。フィールドを隠すことでむやみな外部からの変更を防ぎ、状態の変更をオブジェクト内部に抑えてバグを防ぐことができます。説明しません。
OOPにおけるGoTo文。
インターフェイスの実装のためのキーワードをJavaのようにimplementsにわけてくれ......
クラスの継承は全て廃止してくれ。(継承を廃止することで、実現できない機能があるのか？)便利だけど、最初は必要ないです。
設計を考え初めて、その設計が本当に必要かをしっかり吟味して、他の人にも聞いてみて、初めて使うやつ。
依存性注入(Dependency Injection)で検索しよう！
全てのクラスに意味もなくインターフェイスを作るのは、インターフェイスを全く作らないより害になるので。


