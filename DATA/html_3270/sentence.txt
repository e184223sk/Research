More than 1 year has passed since last update.de:code が終わってからずっと Xamarin.Forms アプリでメモリリークするパターンについて考えています。
考えを吐き出すために、図が少ないですがだらだら書きます。「Xamarin.Forms の」と第を付けておきながら、それに限らない話な気もします。Xamarin.Forms アプリを作ると、現在では一般的には下図のようになると思います。私が作ったサンプルもこうなっています。ここで、図の箱と箱をつなぐ先の ◆ は保持(UML クラス図でいう Composition のような)関係を表しています。たとえば、Android.app.Application は MainActivity を保持しています。Xamarin.Forms アプリは、他の多くのクロスプラットフォームアプリと同様に、「Single Activity Application」であり、ただ一つのActivityを持ちます。その中に "Xamarin.Forms としての" Application があり、その下に Xamarin.Forms の世界での「画面」を示す xxxPage がぶら下がります。MVVM パターンで実装すると、Pageごとに ViewModel が作られ、両者はデータバインディングで相互に関連します。「依存」関係としては、View→ViewModel ですが、ViewModelの変更を監視するためにViewの一部(コールバック関数など)をViewModelに登録することになるため、「参照」関係としては「双方」です。iOS アプリなどの参照カウンタ方式を採用するプラットフォームでは、お互いに強い参照を持ってしまうと、循環参照となりどちらのオブジェクトも自動破棄されずリークしてしまうので、弱参照(Weak Reference)を使ってこれを回避します。Xamarin も採用するマーク・アンド・スイープ方式のガベージコレクタでは、循環参照していても、依存関係のより上位のオブジェクトが不要とマークされれば、ツリーの下位オブジェクトはすべて破棄対象になります。例えば、Xamarin.Forms.Application と FirstPage を結ぶ線が断たれれば、FirstPageViewModel もゴミと判定され破棄対象になります。しかし上図では、ViewModel は、ビジネスロジックが記述されるであろう Usecase クラスと循環参照でつながっています。
Usecase は Application の持ち物であるので、Application と Page の線を断っても、Usecase-ViewModel が循環参照したままでは、 Page も ViewModel も破棄されません。Usecase クラスは、xxxPage/xxxPageViewModel よりも生存期間が長い場合が多いでしょう。
私は Xamarin.Forms.Application で Usecase クラスを生成して保持させる実装をよく行いますが、DIコンテナを使う場合も Usecase は xxxPage/xxxPageViewModel とは異なる生存期間を持つ、ことになります。そして、Usecase を使用するのは xxxViewModel クラスになるでしょう。
単純に Usecase の同期/非同期メソッドを呼び出して結果を返値で得る、場合には問題になりませんが、「Usecase からの通知を待つ」場合には、Page-ViewModel の関係と同様に、循環参照になります。例えば、Usecase が次のような機能を提供している場合です。イベントに限らず、Rx の IObservable&lt;T&gt; でも同様です。
ViewModel で Usecase からの通知を受信するには、何らかのレシーバーを Usecase に登録しないといけないので、相互参照になります。なので、 ViewModel で Usecase からの通知を受信するための登録を行ったら、それは必ず解除してあげる必要があります 。
それはいつ・だれが行えばよいのでしょう？Android Architecture Component の ViewModel には、onCleard が用意されており、ここで解除処理をしてあげればよいのですが、Xamarin.Forms には、そのような用意されたものはありません。問題は、登録処理は ViewModel のコンストラクタで行うであろうが、それと対になる破棄タイミングが無い、ことです。ひとつのアイデアとしては Page.Disappearing のタイミングで破棄させる、というものがあります。
Page.Disappearing は、Page が破棄された(例： NavigationStackからPopされた)時に呼ばれるので、それを利用して次のように書けます。これで大丈夫そう…ですが注意しなければならない事もあります。
本来 Disappearing は Appearing と対になるライフサイクルイベントです。
ViewModel の生成はコンストラクタで行っているのに、破棄は OnDisappearing で行うのは 「いびつ」 です。これの弊害は、例えば Page のインスタンスをキャッシュしておく場合に表れます。こんな実装自体好ましくありませんが、生成と破棄のタイミングが「いびつ」になっていると思わぬ不具合を引き起こすかもしれない事は要注意です。Xamarin Profiler を使う手もあるのですが、アプリの動作が重くなるので、原始的な方法 「破棄されるべきオブジェクトのデストラクタでログ出力を仕掛けておき、GCを強制的に実行して確認する」 で行っています。対象クラスのインスタンスがもう不要になったと期待される箇所、例えば SecondPage ならば、FirstPage に戻ったとき（あるいは次回 SecondPage を表示したいとき）にブレークポイントで一時停止し、イミディエイトウィンドウで System.GC.Collect() を実行します(一度の GC では破棄されないかもしれないので何度か実行するとよいです  GC.Collect() のあとで GC.WaitForPendingFinalizers() を実行すると「ゴミが回収されるまで待つ」ことができます1)。期待通り破棄されていれば、以下のようにログに Finalizer が呼び出されたことが出力されます。ログに出力されなければ、それがリークです。冒頭でも言ったように、Xamarin.Forms アプリは 「Single Activity App」 なので、アプリに必要なオブジェクトは、全て MainActivity が保持しています。すなわち、MainActivity が破棄されれば、Xamarin.Forms の世界のオブジェクトはすべて破棄されるのが望ましい、という事です。
そして Android の世界において、MainActivity はまあまあ頻繁に破棄されます。他のアプリを前面に表示して利用し続けていると、裏側の Activity は OS によって勝手に破棄されることは、よく知られています。これは、Android 端末の開発者オプション - ✅アクティビティを保持しない で容易に再現できます。さて、MainActivity が破棄されたときに Xamarin.Forms の世界のオブジェクト、Page や Xamarin.Forms.Application は破棄されるのか、確認してみます。新しい Xamarin.Forms アプリのソリューションを作成し、 App.xaml.cs, MainPage.xaml.cs、そして Android 側の MainActivity.cs のそれぞれのコンストラクタと Finalizer でログ出力します。これ変更を加えただけのアプリを、MainActivity.cs の OnDestroy の Debug.WriteLine の行にブレークポイントを設定した状態で、事前に「アクティビティを保持しない」設定を有効にした端末やエミュレータでデバッグ実行します。ホームボタンを押して、アプリをバックグラウンドに退避させると、ブレークポイントで停止するので、そこでイミディエイトウィンドウから GC.Collect() を何度か実行します。何度 GC.Collect() を行っても、App や MainPage の Finalizer が呼び出されていないことに注目です。ここでこれらが破棄されることを期待していたのですが違ったようです。デバッグを続行し、背面に退避したアプリを再び前面に表示します。この時には初回起動と同じく、が出力されるはずです。つまり、この時点では、App と MainPage は2つのインスタンスが存在する、という事です。アプリが起動したらもう一度ホームボタンを押して退避させ、ブレークポイントで止めた状態で、GC.Collect() を数回呼び出します。すると、以下のように出力されるはずです。初回起動のときに生成されたオブジェクトが、このタイミングで破棄されました。「アクティビティを保持しない」設定によって、退避した時点で MainActivity はゴミとマークされ、次回新しい MainActivity が生成されます。ですが GC によってゴミが回収されるまでは、MainAcitivity, App, MainPage はそれぞれ複数のインスタンスが存在し得えます。これは仕方のないことなので、せめてリソースだけは MainActivity.OnDestroy で解放されるように、App を Disposable にしてみます。App を Disposable にして、MainActivity の OnDestroy でそれを呼び出すようにすれば、とりあえず「アプリが破棄される」ときに Xamarin.Forms 側のリソースを解放するトリガーとして使えそうです。しかしゴミとしてマークされた App や MainPage は、Dispose されつつも GC に掃除されるまで生きているので、その間に意図しない問題を引き起こす可能性に注意を払いましょう。
例えば、App.Dispose で DB 接続は閉じたものの、MainPage ではタイマーを使って定期的に DB から値を得ようとしている場合などです。それぞれが決められたライフサイクルの中で動作していれば問題は起こらないでしょうが、手を抜くと後でトラブルが発生しがちです。https://twitter.com/kekyo2/status/1136056968848728065  ↩


