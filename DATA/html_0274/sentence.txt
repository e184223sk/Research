使用したUnityのバージョン: 2019.2.10f1(2021/04/03追記 ) 汚い部分を修正したバージョンを上げましたMeshCutの実装をしました!3万頂点ある楕円体もOculusQuestでサクサク切れます(高速化を頑張りました)(須)#VR #MeshCut pic.twitter.com/WUTsG3J6Xw無印のOculusQuestで大体3万頂点・6万ポリゴンなら大きな遅延はなく切れています. 
また, 断面の形が中央から広がっているようなものであれば複数の断面があってもきれいに切れます(ドーナツを縦から切ることはできて横から切ると変になるという感じです)1000行を超えるコードを書くのは初めてなので, 何か間違いやまずいところがございましたら優しく指摘してもらえるとありがたいです.MeshCutは3Dモデル(つまりMesh)を切断する関数です.MeshCutの基本的な概要については以下の記事を見てください. (自分もこれを参考にして書きました. お二方に感謝...!)
[Unity] Mesh Cutのサンプルを読む（メッシュの切断）
[Unity] Oculus Goで3Dモデルの切断･メッシュカット(Mesh cut)改良版
簡単にまとめると, Meshを構成する各三角ポリゴンについて, 3つの頂点すべてが切断面に対して片側に寄っていた場合はそのまま振り分け, ポリゴンが切断面を跨いでいた場合には切断してから振り分けを行っています.今回は元の記事を参考にしつつ, ハイポリなモデルでも速度を出せるように重い処理を改善し, それでいてなるべく高機能になるようにMeshCutを実装しました.高速化を行う際に上で紹介した記事からの変更点をまとめていきますこれは必須です. むしろこれだけやっとけば後は誤差です.なぜMesh.verticesが重いのかというと、プロパティ内での処理が関係しています. 
Meshクラスを見ても定義だけで中身を見ることはできませんが, 各定義のコメントまでは見られるので見てみましょう.コピーを返すって書いてありますね. なのでこれを何回も呼ぶとそのたびに新しい配列が作られることになるので非常に遅くなります. 一番最初に配列に格納して, 後は配列から呼ぶようにすると良いでしょう.Meshデータでは, 1つの頂点に対して複数のポリゴンがついているのが普通だと思われます. なので頂点が平面のどちら側にあるのかの計算をポリゴンごとにやってしまうと同じ計算を何度もすることになって無駄が生じます.
先に頂点についての計算結果をboolの配列(表側か否か)に格納しておいて, ポリゴンごとの処理では配列から取り出して使うことで計算の無駄を省きます. また, 頂点座標や法線などもここで入れてしまうことで頂点が重複してMeshに登録されないようにします.これはGC対策です. 
ハイポリのオブジェクトを切る際に新しい配列を毎回生成しているとGarbage Collectionで無視できないレベルで遅延が発生します. どうしても使い回せないところ(Mesh.verticesなど)はしょうがないですが, 上で紹介した_isFrontなどは要素数が頂点数より大きい分には問題ないので使いわますようにしましょう(上のコードでは見やすいように頭で配列を宣言していますが, 本当はフィールドにstaticで宣言してあります.)これはもしかしたら怒られそうな気がするので最後に書いています. 
Listの中身は配列なので(https://ufcpp.net/study/dotnet/bcl_collection_algorithm.html), 中身の配列に直接書き込めたら高速化するはずです. 
そこで中身の配列とカウントを取り出せるUnsafeListクラスをつくり, 高速化しました.(定義は一番下に載せています) 上のコードで出てくるunsafe_arrayやunsafe_countはListの配列とCountにアクセスしていることになります.ただ保守性や可読性は下がっているので, それが嫌な人は自分でListに書き換えてもらえばと思います.
(2021/04/03追記 ) unsafeListを使わないバージョンも上げておきました切断したポリゴンの取り扱いは全体的に変更したので, 上に載せたコードの最後にある関数Sepalate()以降での実装を説明していきます.切断面を跨ぐポリゴンの情報はSepalate内でFragmentクラスのインスタンスに格納します. このとき3つの頂点がどの順番で入ってきても上の画像のように変数を当てていきます(こうすることで面の表裏を後から計算しなくてよくなる).同一平面上にあるポリゴンはまとめてしまって頂点数の増加を防ぎます.具体的にはポリゴンの分割にあるKEY_CUTLINE(切断辺のVector3から丸め誤差を落としてintに変えたもの)を用いて同一平面上にある可能性があるFragmentをまとめます. まとめられたFragmentの中から辺を共有しているものを見つけ, 結合しています.コード中のKEY_VERTEXは, 切断によって新しくできた頂点がどの点とどの点の間にあるのかという情報を持っています.また切断辺以外の頂点の情報はPointクラスというLinkedListのようなクラスでつながっていて, 一番左にあるのがfirstPoint, firstPoint.nextには次の頂点, 更にnextのnext...とたどっていくと最後はlastPointにつながっています.
結合の際にはPointクラスのつなぎ合わせも行っています.最後に切断面の形成方法です. 結合されたFragmentから切断で新規生成された頂点情報を取り出してRoopFragmentインスタンスを作ります(実際にはインスタンスを作る前にすでにあるものと結合できるか確認して, 結合できなければインスタンス作成). 
さらにRoopFragmentインスタンスをRoopインスタンスに格納し, ループの断片ができます.あとはRoop同士で始端(左手側), 終端(右手側)の頂点座標を比較して同じなら1つのRoopにまとめます. 
こうしていくことで最終的に切断面1つにつきRoopインスタンスは1つしか残らなくなり, 切断面ごとに別々のループを作ることができます.ただこの実装が面倒で, 具体的には左手リスト配列と右手リスト配列を作って1つのRoopインスタンスをその両方に入れています. 
そして他のRoopと結合する際にはそのたびに格納される場所を振り替えることで実装しています.新しい切断辺の情報(Vector3が2つ:leftとright)が入力されると, まずそのVector3に対応する場所を探します. 
このとき, 入力されたleftとrightに対応するのは他のRoopクラスのそれぞれ右手と左手なので, leftのVector3で右手リスト配列を探してrightでは逆を行います.rightでも同じことをして, 最後に新しいindexのListにRoopを移し替えて一回のサイクルは終了です. これを切断辺が追加されるごとに実行します.
ただ, leftとrightの両方が結合した場合はすでに登録されている2つのRoopが1つにまとまるのでまとめて片方を消します.改めてMeshSlicerの凄さを思い知りました... (MeshSlicerのリンクはこちら)コード中にコメントを書いた後で大幅な変更を何度もしたのでよくわからないコメント等あったら申し訳ないです面がどう貼られているかの確認に便利です



