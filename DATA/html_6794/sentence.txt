More than 3 years have passed since last update.この記事は、Xamarin Advent Calendar 2016の12日目の投稿です。わたしがC#を使っていていたく感動した点が、ネイティブライブラリ呼び出し(P/Invoke)の簡易さでした。
なんとなく関数の名前をあわせて、なんとなくDllImport属性をつければ、いいかんじにネイティブ呼び出しができる。それはとても良いことだと思うんですね。
ことXamarinにおいてもそれは変わらないので、そんなP/Invokeの良さを伝えたい！なにかサンプルを書こう！と思い立ちました。P/Invokeするからには、何かしらネイティブライブラリを用意しなければなりません。
ところが、私は諸般の事情によりC言語を書くことができない体になってしまいましたので、C言語の代わりにRustでネイティブライブラリを作成してみようかと思います。なお、やんごとなき事情によってiOSのみで動作確認をしています。また、なんとなく既視感のある記事かもしれませんが、ご容赦ください…。取り急ぎ結論です。CではなくRustで作ったライブラリだからといって、別段変わった点はなく、問題なくC#から呼び出すことができました。「Xamarinを採用しようか検討しているけれど、Rust製のソフトウェア資産が活用できるかどうかだけが気がかりだった」という皆様におかれましては、どうぞ安心してXamarinを採用いただければと思います。以下は作業記録です。ボタンを押すと足し算(1+2)をして、結果を表示するアプリです。
この足し算処理(1+2)をRustでかいてるんですよ！！！！！最新版をぜひ。Xamarin studioでもいいです。（むしろ、たぶんそのほうがよい）
（2016/12/12現在、まだPreview版です）手軽に、様々なプラットフォーム向けのRustのツールチェインをインストールできます。
（2016/12/12現在、まだBetaです）とても手軽にUniversal Libraryの作成ができるようになります。
インストール後は、cargo-lipoのREADMEに書いてあるように、以下のようにしてiOS向けのtargetを追加しておきます。まず、cargo newコマンドでプロジェクトの雛形を作ります。以下のファイルが生成されます。src/lib.rsを編集します。
こんなメソッドを用意してみます。ただの足し算です。ポイントは、[no_mangle]というAttributeをつけて、外向けのシンボルがメソッド名そのままとなるようにしています。また、staticlibを生成するため、Cargo.tomlに以下の記述も追加します。cargo lipoコマンドを実行します。
すると、target/universal以下にUniversal binaryが生成されているはずです。きちんとrust_sumメソッドがエクスポートされているか、nmコマンドで確認してみましょう。大丈夫そうですね。お好みのXamarinプロジェクトを作成します。サンプルではXamarin.Formsプロジェクト（Shared）としました。NativeMethodsクラスを作成し、その中に、先ほど作成したネイティブライブラリがエクスポートしているメソッドの定義を作成します。WindowsやAndroid環境では、これできちんとネイティブライブラリのメソッドを呼び出すことができます（たぶん）。
ところが、iOSではそうはいきません。rust_sumを呼び出すと例外が発生してしまいます。なんででしょう。困りましたね。DllImport属性にはdllNameというパラメータがあり、ここには呼び出すAPIを持つライブラリ名を指定します。例えば、先ほど定義したrust_sumメソッドを呼び出す場合の動作は、ざっくり以下のような感じです。ところがXamarin.iOSでは、参照するライブラリはビルド時に静的リンクしてしまうので、ライブラリ名もへったくれもありません。なので、DllImport属性のdllNameには"__Internal"を指定してね！というお約束になっています。じゃあ、dllImport("__Internal")するか…というと、今度はiOS以外で動かなくなります。Android向けにはきちんとdllNameを指定したいけど、iOSでは"__Internal"にしなければいけません。そんな悩みを解決するのがdllmapです。ネイティブライブラリを呼び出すアセンブリのプロジェクト（サンプルコードではAppWithRust.iOS）にconfigファイルを作成し、以下のように記述します。1すると、DllImport属性のdllNameに"rustlib"が指定されているとき、それを"__Internal"と読み替えてくれます。便利ですね。プロジェクトのNative Referencesに、先ほど生成したネイティブライブラリ(librustlib.a)を追加し、Propertyの「Force Load」をTrueにしておきます。staticクラスのstaticメソッドを呼ぶのと何ら変わりません。サンプルではこんな感じで呼び出しています。結果、ちゃんと3が返ってきました。素晴らしい足し算ですね。Rustの環境構築するのに右往左往したのでやたらと時間はかかってしまいましたが、
環境が整ってさえしまえば、あとはほとんど手間もなく、ハマることもありませんでした。足し算しかしてませんしね…。そもそも、言語がRustであろうが何だろうが、C形式のABIを提供するネイティブライブラリを生成できているわけですから、それに対するXamarin側からの呼び出しに問題がないのは、当たり前といえば当たり前なんですが…。あとは、構造体とか文字列の受け渡しとか、RustからのコールバックをC#側で受け取ったりとか、そこらへんまで確認できるといいですね。https://github.com/TimNN/cargo-lipo
https://www.rustup.rs/
rustup で Rust コンパイラーを簡単インストール
http://www.mono-project.com/docs/advanced/pinvoke/dllmap/ アプリのプロジェクトであれば、ファイル名は"app.config"でOKです。Dllのプロジェクトだったりすると、"&lt;&lt;アセンブリ名&gt;&gt;.config"だった気がします ↩


