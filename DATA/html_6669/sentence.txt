More than 1 year has passed since last update.この投稿は、C#についてあまり経験のない方がイベントの使い方について理解することを目的としている。
説明の範囲は、ようになることにある。以下については、説明の対象外になる。また、前提として、の知識があるものとしている。C#におけるイベントとは、一言で言えば、
「デリゲートによるコールバックメカニズムに、安全な購読と購読解除機能を追加するための文法」
ということになるだろう。
そのため、イベントを理解するには、まず、デリゲートやコールバックについておさえておく必要がある。ある処理に対し、処理そのものを渡したいことがある。int型の配列を持っているオブジェクトがあるとしよう。この_listの中には、何かの要素が含まれている。
そして、この_list内の要素のうち、奇数の要素を取り出す処理を考える。できた。
つづいて、3で割って余りが1になる数だけを取り出す処理を考える。
できたら、次は4で割って余りが1になる数、そしたら、5で割って、6で、7で…………こうした無限にわきでる要望を、ひとつひとつ別のメソッドを作成して満たすのは不可能である。
そこで、「要素を取り出すかどうかを判定する処理そのもの」を渡すことにしよう。この「要素を取り出すかどうかを判定する処理」は、int型の引数を取り、bool型を返すメソッドになるだろう。
この型のメソッドを渡すには、Func&lt;int, bool&gt;型の引数を使う。さあ、これがコールバックだ。
コールバックとは、ある処理(この例ではGetNumbers)に対し、そこから呼び出してほしい処理(この例ではMod3Equals1)を渡すことだ。GetNumbersは_listの内部を先頭から順に取り出し、その要素ごとに与えられた引数であるMod3Equals1を呼び出す。
これがtrueを返した場合のみ、その値を戻り値の一部として返すという動作をする。こうした、大きな処理に対して、その一部になる小さな処理を渡す場合もあるし、「ある処理がおこなわれたという通知処理」を渡す場合もある。
ほとんどのイベントが後者の形を実現するために用いられる。また、前者の形をイベントで実現することも可能だ。話が飛んでしまった。
C#において、こうした「処理を渡す」際に使用する、メソッドへの参照のことをデリゲートと呼ぶ。
C言語の関数ポインタなどと同様、C#のデリゲートもコールバックを実現するための機能になる。
ただ、C#の場合は、オブジェクト指向言語なので、
「静的メソッドなのか、インスタンスメソッドなのか。インスタンスメソッドだとすれば、どのオブジェクトのそれを呼び出すべきなのか」
という情報まで内部で渡している。デリゲートには、メソッドであれば何でも渡せるわけではなく、引数の数や型、戻り値の型が一致していなければならない。
前の例では、
「int型の引数を取り、bool型を返す」
という処理を渡すためにFunc&lt;int, bool&gt;という型を使用した。デリゲートには型があり、渡したい処理の引数の数や型、戻り値の組み合わせごとに別々の型として扱わなければならない。
そして、プログラマがその型を定義できるよう、delegate構文が用意されている。しかし、.NET Frameworkにはデリゲートの型が既にいくつも定義されている。
どんなものがあるかは、以下を参考にして欲しい。
http://www.atmarkit.co.jp/fdotnet/dotnettips/730dlgttype/dlgttype.htmlこの情報の
void Action&lt;T&gt;(T obj)
という形式は
「Action&lt;T&gt;型というデリゲートの型は、T型の引数ひとつを取り、戻り値がない」
という意味になる。
こうした型がいくつも用意されているおかげで、プログラマがデリゲートの型を新たに定義する必要は少なくなっている。
なるべく標準で用意されているデリゲートの型を使用しよう。運がいいと労働したときに昇給してもらえるProgrammerクラスを考える。このProgrammerは昇給するとその情報をうっかり外へ通知する。
通常は、昇給イベントを用意するのだが、今回はデリゲートだけを使用して、昇給を通知することを考えよう。Actionは、引数なし、戻り値なしの処理を渡すためのデリゲートの型だ。
ここでは、この型の変数(GetPayRiseフィールド)を公開することで、他のクラスからその参照を登録することを可能にしている。
そして、このGetPayRiseに()をつけることで、登録された処理を呼び出すことができる。事前にnullチェックしているのは、未登録の場合はこの値はnullになって処理の呼び出しが例外を引き起こすからだ。
これで、「とても高い確率」で昇給し、このとき、GetPayRiseに登録されているデリゲートを呼び出す仕組みができた。では、昇給が通知されたときに呼び出される処理を追加してみよう。このLeaderは、昇給を通知されると、彼への仕事量を増やす処理をおこなう。
コンストラクタの中で_Programmer101のGetPayRise変数に自分の処理(Programmer101_GetPayRise)を登録している。
これで、Programmer101のWorkを呼び出せば、ごく稀に昇給が通知され、彼への仕事量を増やすことができるようになった。こうしたプログラミングスタイルの一番のメリットは、ProgrammerがLeaderの存在にまったく左右されない点だ。
Leaderがいても、いなくても、いや、昇給を監視しているオブジェクトが何であっても、まったくいなくても、それを気にかける必要がない。
この結果、Programmerクラスの再利用性は向上する。次に、Newbieを考える。
Newbieは、ProgrammerのGetPayRiseの通知を受け取ったら、彼を食事に誘う処理をおこなう。もちろんお祝いをするためだ。このNewbieは、_Programmer101のGetPayRise変数に自分の処理を「追加」している。
デリゲートには、マルチキャストデリゲートという機能があって、すでに登録されている処理(LeaderのProgrammer101_GetPayRise)とあわせて、自分の処理(NewbieのProgrammer101_GetPayRise)も呼び出すように追加できるのだ。
呼び出し側(Programmerクラス)は、処理がいくつ登録されているか気にかける必要がない。
そして、追加のためには、+=演算子を用いる。そう、「追加」だ。
このNewbieのメソッドを「追加」するには、その前に何かが登録済みでなければならない。
そうなると、Leaderが_Programmer101にメソッドを登録してから、Newbieのメソッドが登録されなければならないことになってしまう。Newbieだけ見れば、とすることでこの問題を回避できる。
ところが、今度はLeaderが_Programmer101.GetPayRise = Programmer101_GetPayRiseとしているところが問題になる。
これはまったく新しい代入になるので、これ以前にNewbieのメソッドが登録されていても、それが消去されてしまうのだ。ここでの本当の問題は、
「Programmer101に登録されているデリゲートを、外部から初期化できてしまうこと」
であり、こうした抜け穴は塞がなければならない。
抜け穴と言えば、この形では、LeaderやNewbieが、Programmerに登録されているデリゲートを呼び出せてしまう点も問題だ。こうした、デリゲートの変数を公開することによる問題を解決するための機能。
これがイベントの存在理由だ。今までのポイントをまとめよう。ここで、語句を定義する。いろいろな流儀があるが、この投稿の中では、この語句を使うことにする。
この投稿外で使っても、支障のない語句を選択したつもりだ。Programmerの例では、ProgrammerクラスがSender役であり、Receiver役はLeader, Newbieクラスだ。さて、イベントを使ったとき、Programmerの例がどうなるか見てみよう。
まず、Sender役のクラスはどうなるか。まず、イベントを定義している。これは、ということの宣言である。
EventHandlerというデリゲート型は、.NET Frameworkに定義済みの型であり、という意味になる。
これにより、登録できるメソッドはvoid Xxxxx(object, EventArgs)という形で宣言されているものに限定される。そして、登録されているデリゲートを呼び出すメソッドを定義する。であることに注意して欲しい。
メソッドにこうした名前を付けるのは.NET Frameworkの慣例だ。
可視性と引数については、こうしなければならない理由を後述する。その内部の処理では、イベントと同名の変数として暗黙的に宣言されているGetPayRiseを使用する。
この変数はデリゲート型の値として扱うことができるので、nullでない場合にのみ、デリゲートを呼び出すようにする。
呼び出す際は、ひとつめの引数にはthis、ふたつめの引数には受け取った引数を渡す。
C#6.0以前には?.演算子がないので、という形になる。
スレッド安全性に注意する必要があるのならば、以下のようにする必要があって少々面倒だ。イベントを通知したい箇所(この例では、ProgrammerのWorkメソッドの内部になる)では、このOnGetPayRiseメソッドを呼び出すようにする。OnGetPayRiseを呼び出すとき、毎回、new EventArgs()としてインスタンスを生成してもいいのだが、このクラスにはEmptyという静的フィールドが用意されており、これをインスタンスの生成の代わりに用いることができる。
毎回インスタンスを生成するよりも、ほんの少しだけ早くなるかもしれない。重要なのは、Sender役のクラスにはsubscribeの記述は一切しないことだ。
なんらかの方法でReceiverをSenderに渡し、ここでsubscribeすることもできるのだが、これをしてしまうと前述のメリット、「クラス間の依存関係を少なくする」が完全に失われてしまう。
subscribeの記述はReceiver役のクラスにしよう。イベントの可視性とは、あくまで、subscribeとunsubscribeについてだけのものになる。
これがどんな可視性で定義されていようとも、登録されているデリゲートの呼び出し自体は、自分自身か、あるいはその内部クラスからのみ可能であることに注意してほしい。
外部からはもちろん、Programmerの派生クラスからも、直接、デリゲートを呼び出すことはできない。また、イベントの名前は動詞や動詞句にしよう。
イベント間で前後関係がある場合は、前のものにingをつけて進行形に、後のものは過去形にする。
例えば、ClosingとClosedのように。登録されているデリゲートの呼び出し自体は、自分自身か、あるいはその内部クラスからのみ可能と述べた。これこそが、OnGetPayRiseというメソッドが必要な理由になる。Programmerを継承したSuperProgrammerクラスを考える。
SuperProgrammerは技術が高いので、もう少し、昇給の確率を向上させたい。
ところが、SuperProgrammerからはGetPayRise変数からデリゲートを呼び出せない。もし、protectedなOnGetPayRiseメソッドがなければ、SuperProgrammerクラスには、GetPayRiseに登録されているデリゲートを呼び出す方法が一切ないことになる。
OnGetPayRiseがprotectedとして宣言されなければならないのは、こうした理由だ。また、EventArgs型にはまったく情報が含まれていないので、OnGetPayRiseメソッドを呼び出すたびにEventArgs.Emptyを使用する代わりに、OnGetPayRiseから引数を消しさりたくなる衝動にかられるだろう。こうした衝動にはあらがわなければならない。
なぜなら、このクラスを継承したSuperProgrammerでは、新たな給料の額を持たせたEventArgsの派生クラスのオブジェクトを通知に使用したくなるかもしれないからだ。OnGetPayRiseメソッドに引数がなければ、こうした拡張の芽をつんでしまうことになる。
引数がないメソッドを作りたければ別に定義し、その内部で引数がある方のメソッドを呼び出すようにしよう。なお、Sender役のクラスがsealedとして定義されている場合、このクラスを継承することはできないのだから、こうした気遣いは不要になる。Receiver役のクラスには、イベントのsubscribeとunsubscribe、そして呼び出してほしい処理を記述することになる。
Leaderクラスの例で説明しよう。_Programmer101.GetPayRiseはもはやデリゲートの変数ではない。
そのため、Receiver側から登録されているデリゲートを呼び出せてしまうという安全上の問題は解消されている。
デリゲートの変数ではないにもかかわらず、マルチキャストデリゲートにある、複数のメソッドを登録できるというメリットは保ったままなので、いくらでもsubscribeできる。subscribeはunsubscribeはと記述する。
他のメソッドへの参照が登録されているかどうかを気にかける必要はないし、既に登録されているデリゲートの初期化もできないようになっている。ところで、Programmer101_GetPayRiseのような、イベント用にデリゲートとして渡されるメソッドのことを「イベントハンドラ」と呼ぶ。
イベントの定義時に使用したEventHandlerというデリゲートの型は、まさにこれが理由で名付けられている。Receiverの寿命が、Senderとさして変わらず、イベントを常に通知して欲しいのであれば、unsubscribeは不要である。
しかし、Receiverの方が寿命が短い場合はちがう。
Senderは、subscribeしている間、Receiverへの参照を持ちづづける。
そのため、Recevierは不要なったとしても、ガベージコレクタがいつまでたってもReceiverをメモリから削除してくれない。
おまけに、不要なデリゲート呼び出しが積み重なる結果になる。
こうした場合、Receiverが不要になったらきちんとunsubscribeしよう。イベントのsubscribe, unsubscribeのとき、というように、new EventHandler()が必要だ、としている情報がある。
しかし、C#3.0からはこれは不要になった。もう付けなくてかまわない。プログラマも人間である。人間であるからには休みが欲しい。
そこで、プログラマは労働すると、ある確率で休暇を申請し、それを通知することにしよう。
休暇の申請には、「いつ休むか」の情報が必要だ。まず、「いつ休むか」の情報を含んだイベント引数の型を宣言する。
これは、EventArgsクラスの派生クラスとしなければならない。EventArgsを継承したクラスの名前の後ろにはEventArgsをつけて、イベント引数のための型であることを強調するとよい。
ここでは、休暇情報ということで、VacationEventArgsクラスとした。次はプログラマだ。注意するべき点は、以下の点ぐらいだろうか。.NET Frameworkに定義されているデリゲートの型であるEventHandler&lt;TEventArgs&gt;は、という意味になる。
そして、TEventArgsに与える型は、EventArgsか、その派生クラスでなければならない。
これが、VacationEventArgsをEventArgsを継承して実装した理由だ。ところで、「変更可能なオブジェクトの参照を漏らさない」という鉄則がある。
これは主にプロパティやメソッドの戻り値として言われがちなルールであるが、イベント引数にもあてはまる金言だ。上記のコードでは、ReceiverからProgrammerの_VacationHistoryの値を操作することが可能になっている。
ExVacationEventArgsが保持しているのはIEnumerable&lt;DateTime&gt;だから直接値を操作することはできないと言えばできないのだが、Receiverがキャストしてしまえば操作し放題になってしまう。
これでは、悪意のあるReceiverから、取得した覚えのない休暇が追加されてしまう恐れがある。
悪い上司から身をまもるために、イベント引数には_VacationHistoryのコピーやReadOnlyのコレクションを渡そう。さて、Receiver側だ。
LeaderはProgrammerが休暇を申請すると、スケジュールの調整をしなくてはならない。このイベントハンドラ(Programmer101_ApplyVacataion)のふたつめの引数がVacationEventArgsになっている。
イベントが通知されると、つまり、Programmer101_ApplyVacationが呼び出されると、が渡される。(もちろん、そうなるようにSenderを実装したからだ)
Programmer101_ApplyVacationの内部では、この渡された情報を利用して、自分自身のAdjustScheduleメソッドを呼び出している。次に、Newbieに再登場してもらおう。
Newbieは、Programmerが休暇を申請すると、何をするわけでもないが、ただうらやましがる。
彼はまだ有給休暇を取得していないので、自分も休むだとか、休んだ上でProgrammerを遊びに誘うといったことはできないのだ。Programmer101_ApplyVacationのふたつめの引数の型がEventArgsになっているところに注意して欲しい。
実のところ、このイベントハンドラのふたつめの引数の型はVacationEventArgsかその基底クラスでさえあれば、どんな型でもかまわない。Objectにしてもよいのだ。
Newbieの場合、うらやましがるのにはなんの情報も必要ないため、EventArgsとして通知を受け取っている。情報を渡すイベントを定義する場合は、というように、デリゲートを定義しよう、と書かれている情報がある。
C#2.0以降では、EventHandler&lt;TEventArgs&gt;がすでに定義されているので、こうした定義は不要になった。以前、イベントについてまとめた投稿について、
「混乱があるように見えるのだが、(何かの目的があって)わざとやっているのではないか」
というコメントをして、いたく投稿者の気分を害してしまったことがあった。
http://qiita.com/hibara/items/9fd56a5d594c000a5df0罪滅ぼしというわけでもないのだが、これでイベントについてスムーズな理解をしてもらえたらと思う。C#6.0時代のイベント実装方法
http://qiita.com/zakuro9715/items/107b9aa60b114beb206a++C++; // 未確認飛行C
http://ufcpp.net/


