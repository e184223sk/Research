C#にはパイプライン演算子が導入されていません。しかし拡張メソッドを用いることで似た書き味を実現することができます。この記事では最初に使用例を提示し、どのような書き味が実現されたか提示します。
次にパイプライン演算子とはどのようなもので、どのような要望に応える演算子かを説明します。
そしてパイプライン演算子もどきの拡張メソッドをどのように定義するか説明します。
最後に雑感を述べてから今回使用したコード全体を掲載します。以下は自前で定義したPipe拡張メソッドを用いたFizzBuzzの例です。と言う操作が、その順番通りに書けています。
記述量もそれほど多くなく、まあまあすっきりと書けているのではないでしょうか。F# や OCamlなどに採用されている演算子です。
今、「値vを関数funcFに渡して、返り値をその次に関数funcGに渡して、その返り値を関数funcHに渡して、その返り値を関数funcIに渡す」ことをしたいとします。素朴に書けばfuncI(funcH(funcG(funcF(v))))ですが、などにとっつきづらさを感じる人もいるかと思われます。
これを解決して、「vをfuncFして、funcGして、funcHして、funcIする」をその順番通り書くためにはなどと書くのも手です。しかしなどのトレードオフがあります。パイプライン演算子 |&gt; を持つ上述の言語たちでは、「vをfuncFして、funcGして、funcHして、funcIする」を以下のように言葉の順番通りに、かつシンプルに書くことができます。今回はPipeと言う名前で、以下のように定義しました。全ての型に対して見かけ上のメソッドを生やすものであるため、個人開発のプロダクトならまだしも複数人で開発するときに個人の判断でこんなメソッドをほいほい生やすのはためらわれますね...
標準ライブラリに梱包してくれれば安心して使えるのですが。返り値がvoid以外の場合と、voidの場合とで定義を分けなければならないのは億劫ですよね...今回定義したPipe拡張メソッドはまあまあ便利だと思っています。
今回用いた例で言うと「得られたデータを最後にWriteLineする」を.Pipe(Console.WriteLine))で表せているのはだいぶすっきりとした印象を受けます。
しかし、「listをJoinする」部分が.Pipe(l =&gt; String.Join("\n", l))となっているのは若干冗長な気がしないでもありません。
OCaml的なCurry化や部分適用の厚い構文上のサポートがあったら.Pipe(String.Json "\n")で済ませられそうですし、
Scala的なプレースホルダの記法があれば.Pipe(String.Json("\n", _)) みたいな書き方で済ませられそうです。
そういう構文上のサポートがない以上、C#においては今回のパイプライン演算子もどきの拡張メソッドを定義しても嬉しさが少し減っていそうです。比較今回用いたコードは以下の通りです。そのままOnline Compilerとかに貼り付ければ動きます。


