More than 1 year has passed since last update.こんな風に書いたらこんな結果になった。一見すれば、上記のコードはTask.Runメソッドは同期的に実行されるiも、問題なくインクリメントしていくように見えるが、実際は予想できない結果になった。
これは、Task.Runメソッド内でiをキャプチャしてるので、クロージャになっている。そのため、以下のように展開されてしまっているのだ。このように、匿名クラスのフィールドへいったん1度代入して、その後にそのフィールドをコンソールへ出力する形となる。
なので、従って、anony.iの更新と、Task内でのConsole.WriteLineの実行が制御されることなく行われるので、意図しない予見不可能な結果となる。何も難しいこと考えずに、@munielさんや、@acpleさんから頂いたご指摘の通り、
下記のように、ループブロック内で一時変数に代入すれば解決が出来る。なぜ一時変数に代入することで、問題なく動くようになったのかはデコンパイル結果を見ればわかる。
下記は、デコンパイルした結果を再構成したソース。最初と異なり、匿名クラスのインスタンスが、ループ毎に作成されそのフィールドに値が代入されてProcメソッドが呼ばれる。
従って、Procが見ているtmpフィールドは実行されるタスク毎に独立する形となり、齟齬無く実行されることになる。但し、匿名クラスがループ毎に作成されると言うことはループの数が大きい場合、GCが走りまくってパフォーマンスが悪化する恐れがあることは
意識しておかないとマズいかも知れない。λの中でクロージャを使用した場合、大体は意図通りに動くけど、時として上記のようにぱっと見、意図通り動くはずのものが動かないことがある。
なので、クロージャを試用したときはその変数はローカル変数とは別の性質を持つと言うことを意識する必要があると思う。また、ワークアラウンドのご指摘を頂いた@munielさんや、@acpleさん
有り難うございました!


