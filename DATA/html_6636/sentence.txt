More than 3 years have passed since last update.HotなObservableとは何なのかソースコードを読んで理解してみる書いてる間にソースコード読んでいたら割とColdの挙動もちゃんと把握していなかったことに気がついたのでこれについての読解記事です。UniRxのほうが本家より理解しやすいのでこっちを読みながら解説していきます。ColdなIObservableは今回次の二種類に分けて紐解いていきたいと思います。今回この二種類について解説を書いていきます。まず、とても理解しやすいのでこちらを解説します。一番簡単なReturnメソッドを読んでいきます。
このコードってどういう処理がされるの？という話です。以下Returnメソッドの抜粋ですScheduler.DefaultSchedulers.ConstantTimeOperationsとScheduler.Immediateは基本的に同じものを指しているので、また今回Schedulerの説明はしないのでここでは以下のImmediateReturnObservableが返されるとして話をすすめます。このクラスの抜粋が以下になります。コンストラクタはデータを保持しているわけですね。
SubscribeメソッドをみてみるとobserverにOnNextで値を入れてOnCompletedで完了通知して、キャンセルできないのでDisposable.Emptyという無意味なDisposableを入れます。このメソッドが呼ばれるたびに引数に毎回同じようにOnNextなどの操作をするわけですね。さて、よく見ると引数がFunc&lt;T&gt;とかではなくIObserver&lt;T&gt;になっています。
実はここは拡張メソッドで定義されていてIObservable&lt;T&gt;にはSubscribe(IObserver&lt;T&gt; observer)しか定義されていません。
というわけで、その拡張メソッドを見に行きます。この宣言を觀てもらえば分かる通りSubscribe(this IObservable source, Action onNext)はSubscribeというObserverを渡された引数のFunc&lt;T&gt;を使って作成してそれを返しています。じゃあ、こいつなんなの？と言うと以下です。Interlocked.Incrementはスレッドセーフなインクリメントなので、要するにOnNext,OnError,OnCompletedが呼ばれたら対応するメソッド呼んでるだけです。結局Observable.Return(1).Subscribe(Foo)はというながれになります。これでReturnの流れがわかりました。基本的な流れがつかめたところでもう一つTimerを読んでみます。SubscribeCoreはOperatorObservableBaseのSubscribeメソッドが呼び出されたときのメインメソッドです。
基本的にSubscribeメソッドだと思ってください。( cancelは今回無視でいいです)
これをみてみましょう。TimerクラスはOnNextされるたびに引数のobserverにobserver.OnNext(onNextした回数);をするObserverです。難しくないので気になるなら読みに行ってください。次の部分はdueTime後にtimerObserver.OnNext();とtimerObserver.OnCompleted();を実行するよという感じです。戻り値はおなじみのDisposeされたらキャンセルするやつです。まとめるとTimerメソッドのSubscribeはという感じです。
ここまで見るとわかるのですが、このクラスはSubscribeメソッドで渡されたobserverを記憶しません。
戻り値のIDisposableもtimerObserverも記憶しません。
つまり二回以上呼ばれたら何度も作り直すことになりますね。副作用はありません。
一回目のobserverでの戻り値と二回目のobserver'での戻り値に一切関係がありません。無関係のオブジェクトになります。またColdの性質であるのSubscribeされるまで確かに何もしていないことがわかります。
ふむなるほどこれがColdかというわけで次はオペレータタイプをみていきます。今回は簡単なWhereに登場してもらいます。こんな感じになってますこちらのタイプとジェネレータ型とで唯一の違いはIObservable sourceをコンストラクタが要求しているかどうかです。
こちらは入力を前のデータに依存しています。それ以外はほとんど同じことがわかると思います。SubscribeCoreはsourceにWhereというObserverを渡しています。
WhereはOnNextされるとフィルタ関数であるpredicateの結果をみてobserverのOnNextするか捨てるかを決めています。
これだけ！結局やっぱりSubscribeするまではsourceに何か値が入ってきても何もしてませんね。sourceがHotな・・・例えばReactivePropertyであってもたれながしになります。また、これもSubscribeしたときの情報を保持しません。ここまでみていくと
var observable = Observable.Return(1).Where()のobservableにはWhereクラス(source=Return)が入っていることになります。
ここでobservable.Subscribe(observer)とすると、WhereのSubscribeが呼ばれる-&gt;sourceはReturnだからReturnのSubscribeが呼ばれる-&gt;ReturnはWhereのOnNextを呼ぶ-&gt;WhereはobserverのOnNextを呼ぶという流れになることがわかりますね。これなんかいい例えないかなーと思ったんですけど
Subscribeするたびに専用のデータの通り道が一本一本できる感じかなぁと思います。
あと一本うどん想像しました。これで基本的なRxの流れはすべて追うことができたと思います。ColdなIObservableというのは接続されたタイミングでは何もしない。
上流のIObservableや必要な値を保持するだけ。Subscribeされたときに引数のobserverに値を流したり流す予約をしたり上流とSubscribeでつなげたりする。
このときデータを保持せずSubscribeが呼ばれるたびに新しくつなぎ直して使い回しはしない。


