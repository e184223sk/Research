More than 1 year has passed since last update.モチベーションも大事だと思うので覚書として使用します。
三週目の感想
　四週目は、演算子というだけあって記号の意味・用法を中心に学習。
画像はエルビス演算子というジョーク…ですよね？可変が効いてるのでスペースでセンターに置いた。

　学習の方は&amp;と&amp;&amp;の使い方に手こずった。
(&amp;&amp;の方が有能そうだが、変動的な場合は完全評価の&amp;が吉)
最終的にif((ch&gt;='a' &amp;&amp; ch&lt;='z') || (ch&gt;='A' &amp;&amp; ch&lt;='Z'))
このような複雑な処理も出来る事が分かった。
ワンライナーなら有能なa?b:Cもif文という事がわかった。(ただしビット演算は苦手…)

とりあえず動くアプリ作りたいならJavaでもよかったかもしれない。
わざわざXamarinで全部作る必要があるか、1から似たソース参考に見て(この時点で他言語必要)
それでも何とか設計やライフサイクル学習しVisualStudio(Xamarin)とにらめっこして自分のC#に変換しつつ、
依存注入でiOSとAndroidに適用していく作業。一方、Javaなら作例は沢山あるから調べる時間短縮するし1つの言語なのでシンプル。
もしアプリを複数人で拡張するとしたらC#だと特殊だけど、Javaなら沢山いるだろう。
色々分かってきて悩む。逆にC#で良かったんだと思う時期も来るかもしれない…たぶん。
　　　　　　　　　　　　　　　Operator (操作士、呪術師、演算子)、Operand  (演算項目)
演算子(=)やオペランド(a)が識別子(a)に影響を及ぼし値が評価される。
*/^(指数演算)等が先に評価される。・オーバーロード参考 引数異なる関数を複数定義できる(オーバーロード)上記コードのこと・進数参考 0x0c=12 (0x=16進数、A~F=10~12、16進×0(=0x0) ＋c=12)
　　　　　 2進数がbit単位2進数は8桁(101は1より左00000を省略)・ビット演算(bit演算)参考 bit は binary digitの略(=2進数の一桁) つまり0か1特殊▶ドット演算子 プロパティ等のメンバ変数(この場合mx)にアクセスしようとすると、既に定義されてるエラー。既にNew演算子で定義しているとき、mx.a等としアクセスそれぞれの意味
==  等しい
!=  等しくない
&gt;  より大きい
&lt;   より小さい
&gt;= 以上
&lt;=  以下&amp;&amp;  かつ
||  または
!   否定（例　!ａは、ａでなければ）
&amp;   論理積（例　1 &amp; 1のみ、真）
|   論理和（例　1 | 0 、0 | 1、1 | 1ならば真）
^   排他的論理和（例　1^ 0 、0 ^ 1 ならば真）is bool値返す。第二新しい型で第一から代入(varなら全True…何度も一時変数使える)、 equalsとしても使える
as      変換、キャストと違いnull返す。参照型のみ有効string、配列等。軽い+　-　*　/　%　++　--

+-より*/優先、データ型より文字列型優先、数字同士は大きい型優先

class OpeAdd
{
    public static void Main()
    {
        Console.WriteLine(3 + 6);// 9
        Console.WriteLine(3.0 + 6);// 9
        Console.WriteLine("3.5" + 6);// 3.56
        Console.WriteLine(3.5 + "6");// 3.56

        Console.WriteLine("(3.0+6)の型は{0}",(3.0+6).GetType());// (3.0+6)の型はSystem.Double
        Console.WriteLine("string 3.5+int 6の型は{0}",("3.5"+6).GetType());// string 3.5+int 6

        Console.WriteLine($"(3.0+6)の型は{(3.0 + 6).GetType()}");//文字列補間
        Console.WriteLine($"string 3.5+int 6の型は{("3.5" + 6).GetType()}");// 型はString
    }
}


class OpeDivision
{
    public static void Main()
    {
        Console.WriteLine($"10/3={10/3}");// 10/3=3 int/intなので小数点切捨(四捨五入ではない)で3と評価される
        Console.WriteLine($"10/3の型は{(10/3).GetType()}");// 10/3の型はSystem.Int32
        Console.WriteLine($"10/3.0={10/3.0}");// 3.333...int/doubleとなり評価も大きい方の型doubleで評価された
        Console.WriteLine($"10/3.0の型は{(10/3.0).GetType()}");//10/3.0の型はSystem.Double

        Console.WriteLine($"13.53%2={13.53%2}");// 13.53%2=1.53 %は余り(13.53÷2=6…1.53)
    }

}


++　--

評価前後1加算減算 ++a(先代入)/a--(あとから代入)


char c1 = 'A';
c1++; // c1 is 'B' now


==　!=　&lt;　&gt;　&lt;=　&gt;=　is　as

?a:bはワンライナー収まるならif文よりシンプル(諸説有)

== 等しい
!= 否定か等しい
&lt;=  以下 if (number &gt;= 1) timer = 10; &lt;と&lt;=は第一第二オペ等しい場合もあればこっち
is 「オブジェクト is 型」でbool値返す(AがBと同じ型かTrue/False)。同じ型であればtrue、そうでなければ false
GetType()などがあるが、GetType()はオブジェクトがnullの場合使えないので、IS演算子の方を使ったほうがいい
equalsとしても使えるas キャストし、それが失敗した場合はnullを返す 軽いしnull返すし便利(但し参照型のみ)is演算子の拡張[C#7]定数とのマッチング 従来 if (object.Equals(o1, 123)) C#7 if (o1 is 123) isで比較可能型判定と同時にキャスト if (o is string s) 
(オペランドが同じ型なら)True返し第二オペランド(string s)にo格納
(第二オペランドはここで宣言する新しい型の必要あり。以降よりスコープ発動)新しい変数に代入 上記、新しい型をvarにすると常に同じ型となるのでtrue返し第二オペランドに格納
何度も一時変数使える。らしいけどまだ分からない範囲あるので後に理解
if (DateTime.Today is var today
&amp;&amp; today.Day is 13 
&amp;&amp; today.DayOfWeek is DayOfWeek.Friday)
WriteLine("今日は13日の金曜日です");^　!　~　&amp;　&amp;&amp;　|　||e

短絡評価。第一オペの時点でTrue OR Falseなら結果どうせ変わらないし第二オペランド評価する必要ない。
条件 AND&amp;&amp;    左オペランドがfalseの場合、右オペランドは評価されません。
(Falseなら偽入った時点で真真にならないので左辺評価するだけ無駄で、逆にTrueなら第二段階として第二オペ評価する)
条件 OR|| 左オペランドがtrueの場合、右オペランドは評価されません。
(どちらかでいいのでTrueならもうこの時点でクリアなので評価終了、逆にFalseなら第二段階として第二オペ評価する)
条件演算子?:   第1項がtrueなら第2項のみ、falseなら第3項のみが評価されます。
(x=a?b:c三項のうち一項がif条件式、二項が実行する式と同じ。三項はelseその他の実行する式)
null 合体演算子?? 左オペランドがfalseの場合、右オペランドは評価されません。

^(完全評価)1110 ^ 1010// 0100 異なる時true 読み方キャレット~ビットごとの補数演算を実行し、各ビットを反転!否定の値返す
 x = a ? b : c
 x ?? y  //xがNullならx返す、null以外ならy&amp;(完全評価)1110 &amp; 1010// 0010 同じ時true 値変動的ならこっち
&amp;&amp;(左辺評価)どうせFalseなら評価せずFalse確定 ショートサーキット(短絡評価)
&amp;と&amp;&amp;の違い(&amp;&amp;の方が有能そうだが、変動的な場合は完全評価の&amp;が吉)|(完全評価)1110 &amp; 1010// 1110 どちらか同じ時true
||(左辺評価)ロード少なく済む=   *=   /=   %=   +=   -=   &lt;&lt;=   &gt;&gt;=   &amp;=   ^=   |=  &amp;&amp;=

byte a＝10とint b、で違う型だった場合b=aで代入すると両方intなる(暗黙の型変換)=　第1オペランドに第2オペランドの値を格納
+= 第2オペランドの値を足しその結果を第1オペランドに格納
-= 第2オペランドの値を引きその結果を第1オペランドに格納
*= 第2オペランドの値を掛けその結果を第1オペランドに格納
/= 第2オペランドの値で除算その結果を第1オペランドに格納
%= 第2オペランドの値で除算その余りを第1オペランドに格納&amp;= 第2オペランドの値でANDをbit単位で取得その結果を第1オペランドに格納
　　ステータス管理や乱数生成に使われる(ビットのクリアが可能となる)^= 第2オペランドの値でXOR(排他的OR)をbit単位で取得その結果を第1オペランドに格納|= 第2オペランドの値で包括的ORをbit単位で取得その結果を第1オペランドに格納&amp;&amp;=移動代入演算子 第2オペランドの値でそのリソースを第1オペランドに移動


