More than 3 years have passed since last update.自作したLINQメソッドが列挙されすぎていないか調べました。検証がはかどるのでSystem.Interactive(以下Ix)を事前にインストールしています。環境オレオレLINQメソッドを呼び出す前にローカル変数にアクセスし、列挙回数を記憶させておきます。
このときシーケンスには手を加えずそのまま次に流します。IxのDoメソッドを使うことで同様の処理が短く記述できます。列挙しすぎた場合の例としてオリジナルの集計メソッドMyAggregateを用意しました。
これを先程書いた確認方法を用いて何回列挙されたか調べます。例1ではEnumerable.Range(5, 100)という5始まり100要素のシーケンスを用いています。要素数が100のためここでの列挙回数も100であることが望ましいのですが、結果は10100という期待と異なる数値になっています。なぜこのように列挙回数が膨大なもの( $O(n^2)$ )になるのかというとforeach (var i in source)oreach、source.Sum()でそれぞれ列挙が行われているからです。foreachで処理が1回行われるたびにsource.Sum()で列挙が100回行われるため総合計が上記の数になります。次にforeachを使わない例を示します。オリジナルのグループ化メソッドMyGroupByを作成し、例1と同様に列挙回数を調べます。実行した結果、こちらも列挙回数100ではなく10590と膨大な数になっています。この例ではforeachを使わずにsource = source.Skip(1)でシーケンスを進めています。これによりシーケンス呼び出しが再帰的に行われることとなり、列挙回数が膨大になります( $O(n^2)$ )。このSkipメソッドに関してだけでも列挙は5150回発生しています。それに加えて.Skip(1)が行われるたびに.Take(5)が行われ上記の列挙回数になっています。自作しなければ列挙数が膨大になるようなメソッドは生まれにくくなるはずです。既存のメソッドで代用できそうならそちらを使うようにしましょう。例えば例2のオレオレLINQメソッドはIxのメソッドを利用して以下のように置き換えることができます(インターフェースは若干異なります)。自作メソッドの中でQueueやStackといったコレクションで要素を記憶しておく実装にすることで同じ要素が複数回列挙されることを防ぐことができます。またメソッドには手を加えずに自作メソッドを呼び出す前にキャッシュを持っておくという手もあります。IxのMemoizeメソッドを使うとコードを読んだときにメモ化が行われていることが理解しやすくなります。オレオレLINQメソッドの実装次第で思いがけずシーケンスが複数回列挙されてしまうことを確認しました。シーケンスが複数回列挙されてしまうことの問題点としては以下が挙げられます。知らないうちに複数回列挙されている事態にならないよう気をつけましょう。


