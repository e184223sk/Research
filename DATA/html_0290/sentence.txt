こんにちは！GxP2年目の笠井です。
この記事はグロースエクスパートナーズ アドベントカレンダーの12日目の記事となります。今回は業務でAzure CosmosDB(以下CosmosDB)のデータメンテナンスツールを作っている際にC#のdynamicで悩んだ話です。
テーマが「今年の学び」ということで、基礎的なところで躓いた話ではありますが自分への戒めとして書いていきます。CosmosDBから取得したデータ内の年月日等の日付に相当する値を結合し、新たにISO 8601形式の日付データとして要素を追加するツールを作る必要がありました。今回CosmosDBから取得するデータはJSONになっており、１つのドキュメントごとに要素数が異なる半構造化データに対応するためにdynamicで取得することにしました。CosmosDBはさまざまなタイプのデータモデルに対応可能なNoSQLデータベースで、Key-Value型、Graph型、Document型などのデータモデルとそれぞれのモデルに対応したAPIが提供されています。
今回はそのなかでもSQL API(Document型)を使用しました。Cosmosアカウントの要素は以下のような階層になっています。
dynamicがどういったものなのかざっくり説明します。実行時に型が決まります。
ですので、以下のようなクラスを定義したとして以下のように存在しないプロパティを参照するようなコードを書いた場合、コンパイルは通りますがRuntimeBinderExceptionが投げられます。また、dynamic 型というものではなく、実体はObjectです。
なので以下のようなコードはコンパイルエラーになります。今回は単純に「CosmosDBに接続、全件取得し更新する」というコードです。実行時に型が決まるのでコンパイルエラーが出ません。なのでちゃんと型を把握して使う必要があります。
コンパイルは通ってしまうのであまり意識が出来ておらず苦戦しました。以下のitem.idはNewtonsoft.Json.Linq.JTokenが想定されるのでToString()メソッドでstringに変換して引数に入れています。今回事前調査が足りず、CosmosDBから取得できるJSONがNewtonsoft.Json.Linq.JObjectであることが実装後にわかったので、結果としてdynamicを使う必要がありませんでした。
以下は修正後のコードです。本記事の件で自分の経験の浅さを思い知りました。
実行時に型が決まるという仕様上コンパイルしただけではエラーなのかが把握しきれないので、動的型付けや型推論を使う際はちゃんと型を把握して実装するよう注意したいと思いました。
どんな型のデータが入っているかを知る方法としてObject.GetType()がありますが、一番手っ取り早いのはちゃんと公式のドキュメントを読むことだと思います。また、dynamicやvarをむやみに乱用すると他の作業者や未来の自分がソースコードを見た時に理解しづらくなってしまうので型が容易に想定できる範囲で使うことを意識するといいと思いました。


