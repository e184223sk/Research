More than 1 year has passed since last update.　LINQ は便利ですよね。通常のループを書く時には、データがループの先頭から最後まで行ったり来たりするので、それを追って視線も思考もループ内をグルグル回ります。ところが LINQ だと、データは上から下へ一直線に降りていくので、流れに従ってキーボードを走らせることができ、視線も上から下へと降りるだけです。もう全部 LINQ で書きたい、ループは foreach だけでいい、と思うくらい楽です。　そんな中、for や while を使うと思うのです。「このデータ、ToList() したい！ Sum() したい！ Aggregate() したい！」と。もちろん、IEnumerable&lt;T&gt; を返すメソッドを作って yield return すればできるんですけれど、だったら素直に List.Add() の方が面倒がない。　for に関してでも、単純なカウンタなら Enumerable.Range() で行けるけれども、完全に置き換えることはできない。じゃあ、というのでこういう拡張メソッドを作ってみました。　例えばこのように使います。　これは以下の二つと全く同じ動作をします。　その通りです。では次はどうでしょう？　これを Enumerable.Range() を使って処理するのは少し面倒くさそうです。Rucur を使うと　まったく同じ手順でできました。　それでは今度は、フィボナッチ数列を作ってみましょう。　ニュートン・ラフソン法を用いて、3 の平方根を求めてみましょう。　ここまで見てきて気が付かれましたでしょうか？「フィボナッチ？　ニュートン-ラフソン？　それって漸化式を使うよね？」
Wikipedia - 漸化式数学における漸化式（ぜんかしき、英: recurrence relation; 再帰関係式）は、各項がそれ以前の項の函数として定まるという意味で数列を再帰的に定める等式である。　「再帰的に定める」とは難しい言い回しですが、i = i + 1 と言うのを見てください。ほら、i によって次の i が決まっています。再帰してますね？
　for ループの条件は、初期値、終了条件、漸化式から成り立っていて、そうでない場合も初期値、終了条件、漸化式として一般化できます。初期値は与えられ、終了条件は TakeWhile() もしくは Take() で決定できるとするなら、あとは漸化式さえ実装すれば for ループを置き換えることができることになります。これが Recur の役目です。


