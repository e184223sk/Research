GC 実行時にどのように Finalizer や Dispose が呼ばれるのかとか、IDisposable 継承クラスなどをどう扱うのかなどについて明確に整理できていなかったので、備忘録として整理することにした。ざっと以下を眺めた。中でも、特に以下がわかりやすかったです。ありがとうございます。一通り読んだら、知りたかったことが整理されており、ほとんどまとめることが無くなりました。（笑）これでは終われないので、追加的に書いておきます。Visual Studio で IDisposable を継承すると、「考えられる修正候補を表示する」の機能を利用して、コードを提案してもらえます（VS2015 からとのこと）。bool 値を引数に持つ仮想 Dispose メソッドを利用するパターンです。実際のコードが以下です。
そのままにしないで、TODO コメントをちゃんと読んで対応しましょう。明示的に呼び出さなくとも、Finalizer 呼び出し時には呼び出されます。
しかし、GC まではリソースの開放が行われないため、明示的に呼び出すべきです。※ using 構文は、コンパイル時に try...finally 呼び出しに置き換えられます。つまり、IL 的には等価なコードが生成されます。Finalizer を定義すべきではありません。
定義すると呼び出されるため、不要な呼び出しオーバーヘッドが生じてしまいます。アンマネージリソース自体には Finalizer がないので、必ずそれを保持するクラスの Finalizer にてアンマネージリソースを解放するようにします。これを行うのが Dispose パターンです。アンマネージリソースは 「可能な限り SafeHandle から派生したクラスでラップしてね（推奨）」だそうです。
SafeHandle は、IDisposable を実装したクラスとしてハンドルをラップすることにより、using 構文と組み合わせてハンドルを扱うことができるようにするものです。MS の技術文書を読むと、ファイナライザもデストラクタも一緒みたいな書き方になっているが、混在しているとかえってわかりづらい。「ファイナライザには頼らない」にも記載されているように、delete のように破棄を制御できる C++ などではデストラクタ、GC によって破棄される C# や Java などではファイナライザという言葉を使うほうがわかりやすいので、そのように使い分けたいと思います。以下のような入れ子になったクラスで、Test() の呼び出し後に GC が実行されると、hoge と _hogehoge はどちらの Finalizer が先に呼び出されるでしょうか？答えは 不定 です。（どちらの Finalizer が先かは決まっていません。）
これは頭に入れておきましょう。これが意味するところは、ファイナライザではそのクラスがメンバとして保持しているクラスオブジェクトにアクセスしてはいけないということです。やっちゃいけないのですが、やっちゃっても即時にアクセス違反で落ちたりしないので、潜在的な問題を検出できなかったりするのですが、、、。以下のどちらの環境で試しても、シンプルなサンプルコードでは落ちないんです。
やっちゃダメなのに。(ﾟдﾟ)！Release/Debug どちらでも落ちません。Test() を１回呼び出し、直後に１回 GC をループで回しても落ちないですし、Test() を複数回呼び出し、直後に１回 GC でも同様に落ちません。細かな説明や理解は前述の各種リンク先を見ていただくとして、クラス実装の際に使える指針としてフローを作ってみました。
参考になれば幸いです。


