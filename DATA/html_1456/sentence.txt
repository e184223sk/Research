More than 1 year has passed since last update.VS2019 Version 16.4.5
.NET Framework 4.7.2NuGetで優秀なライブラリが数多く配布されてはいますが、
ここでは基本的なDataContractJsonSerializerを使用して分かりやすく説明します。まずはSerialize/Deserializeするためのシンプルなコード例を示します。見て分かる通り、publicなプロパティとフィールドだけ出力されています。privateなメンバは出力されません。また[IgnoreDataMember]でマークすると、そのメンバだけSerialize/Deserializeできないようになります。プロパティの場合、プロパティ本体がpublic指定でも、get/setどちらかがpublic以外(internal/protected/private)になるとSerialize/Deserializeできなくなります。　
さて、出力できましたが改行されていないのでjsonコードが見づらいです。
段落及びインデントで整形してSerialize/Deserializeできるようにします。jsonWriterのDispose実行を忘れないよう気を付けてください。
（Dispose処理時にFileStreamを経由して書き込まれるため）usingで書き込めば安全に出力することができます。JsonReaderWriterFactory.CreateJsonWriterの第5引数がインデントに代わる文字です。
半角スペース4文字を設定しています。XmlDictionaryWriter（JsonReaderWriterFactory.CreateJsonWriterで生成したWriter）経由で出力したデータは、記載したコードのようにXmlDictionaryReader経由で読み取るようにしてください。それ以外の方法で読み込むと例外が発生します。先程Serialize/Deserializeするクラスには何もAttributeをマークしていませんでした。
よく、DataContractAttributeをマークしてSerialize/Deserializeする必要がある、と見聞きしますがそんなことはありません。DataContractはあくまで明示することにより、Serialize/Deserializeに便利な挙動を提供できる仕組みでしかありません。（Serialize/Deserializeするプロパティ名を変えたり、Serialize/Deserializeの順番を変えたり等）ここでは、DataContract及びDataMemberをマークした場合の挙動について説明します。[DataContract]でマークしたクラスは、[DataMember]でマークしたメンバのみSerialize/Deserializeされます。privateであっても、Serialize/Deserializeすることが可能です。その他、引数付きコンストラクタのみを実装したクラスでもSerialize/Deserialize可能になります。[DataContract]をマークしていない場合、
引数付きコンストラクタのみ実装されたクラスはSerialize/Deserializeできません。
（デフォルトコンストラクタを実装すればSerialize/Deserializeできます）[DataContract]でマークすると、引数付きコンストラクタのみでもSerialize/Deserialize可能でした。
逆に言えば、デフォルトコンストラクタが動作していないということが説明できます。これは[DataContract]でマークしたクラスは、Deserialize時に対象クラスをFormatterServices.GetUninitializedObject(Type)を使用してオブジェクト生成されるからです。Deserialize時に、ある特定の値に初期化しておきたい場合は、[OnDeserializing]をマークしたメソッドを実装します。基本的にコード上でクラス生成されるので、デフォルトコンストラクタが動作して初期化されるとは思います。
しかし、後述する未初期化ケースによって問題になることがあります。（ありました）Test.Valueは、エディター上で3の値に編集されて、test.jsonとして出力されたとします。仕様変更が入り、Test.Value→Test.Value2と名前が変更されたとします。
役割が同じということだったので、初期値は3が入るようにコードを修正します。この状態でtest.jsonをDeserializeするとどうなるでしょう。
test.jsonには、Valueというフィールドが存在しないため、Value2の読み込みは行われません。そしてデフォルトコンストラクタも動作しないので、
このValue2は3で初期化されず、intの規定値となる0で初期化されます。仕様変更後の型で仕様変更前のデータをDeserializeする際、こういった不具合の発生原因を作ってしまいます。この場合、対応方法は各種ありますが、DataContractを使用して仕様変更前のデータをDeserializeしたいのであればDataMember(Name = "") で以前のフィールド名（プロパティ名）指定してあげれば、Deserializeすることが可能です。このような部分が、DataContractのメリットでもあり、デメリットでもあります。では、下記のようなパターンはSerialize/Deserializeできるでしょうか。Rootとなる型だけ、DataContractをマークしておけばSerialize/Deserialize可能です。
　
では、継承を用いた少し複雑なパターンはどうでしょうか。
(説明に不要なコードは、使用しないように修正しています）残念ながら、例外が発生します。(System.Runtime.Serialization.SerializationException)
基底クラス（Super）としてSerializeするはずが、型を知らない派生クラス（Sub）でSerializeしているからです。もちろん、Sub intanceの宣言をSuper instanceにしても、例外は発生します。派生クラスの型さえ伝えられれば、たとえ基底クラスの型を指定していてもSerializeが可能になります。
（当たり前ですが、継承関係にあることが前提です）DataContractJsonSerializerSettings.KnownTypesに、継承関係にあるSubのTypeを配列で入れます。
これにより、DataContractJsonSerializerに基底クラスの型を指定しても、継承されたクラスのインスタンスをSerialize/Deserializeすることが可能になります。KnownTypes以外にも設定できる項目があります。
DataContractJsonSerializerSettings.EmitTypeInformationにEmitTypeInformation.Alwaysを指定すれば、型情報も出力されるようになります。型名:#名前空間という形で出力されます。DataContractJsonSerializerSettings.UseSimpleDictionaryFormatをtrueにすると、
Dictionary&lt;TKey,TValue&gt;をSerializeする時のデータ形式が変わります。trueの場合falseの場合(規定値）名前の通り、Key:Valueという形でシンプルにSerializeされるようになります。自分でもたまにDataContractについて混乱することがあったため、検証がてら記事にしてみました。
この記事が誰かの助けになれば幸いです。間違い等があれば、ご指摘していただけると助かります。


