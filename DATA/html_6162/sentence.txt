More than 3 years have passed since last update.WPFでアプリケーションを作成していると、弱いイベントパターンを利用する機会があると思います。弱いイベントパターン自体の詳細な解説は行いませんが、利用していてハマったので覚書を残しておきます。
弱いイベント パターン
https://msdn.microsoft.com/ja-jp/library/aa970850.aspx新規でWPFプロジェクトを作成し、Window上にボタンを一つ配置。ボタンのイベントハンドラを作成したところから始めます。IWeakEventListenerインターフェースを実装しているクラスを作成し、リスナーとします。イベントが発生するとReceiveWeakEventメソッドが呼び出されます。ここでは、INotifyCollectionChangedイベントを弱イベントパターンで利用してみます。CollectionChangedEventManagerクラスのAddListenerメソッドでイベントを購読し、RemoveListenerメソッドで購読を解除。通常のイベントとほぼ変わらない使い方ができているように見えます。Add1でリスナが2つとも登録されていることが確認できます。
また、Add2でリスナを正しく削除できてることがわかります。で、このRemoveListenerをAddListenerを行ったのと異なるスレッドから実行してみます。ソースコード内にもコメントで書きましたが、listener3が削除される場合とされない場合があります。Taskクラスは裏側でスレッドプールを利用しているので、たまたま同じスレッドで実行された場合は削除されるし、そうではない場合は削除されないのだと推測できます。実際にハマった不具合では以下のようになっていました。
これは大分簡易にしたものなので直接AddListenerを行っていますが、元はParallel.ForEachの内部で生成されているクラスの一部が内部的に弱いイベントを利用しているクラスに依存しているという状態でした。この場合、どのイベントリスナが削除されるか？というのは、神のみぞ知るという。そして、確実にイベントを削除する方法はありません。WeakEventManager.AddListenerおよびRemoveListenerは必ず同期Contextから呼び出しましょう。


