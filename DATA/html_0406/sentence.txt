もくじ
https://qiita.com/tera1707/items/4fda73d86eded283ec4fmutex関連
https://qiita.com/tera1707/items/4fda73d86eded283ec4f#cc-mutex%E9%96%A2%E9%80%A3C#のアプリとC++のアプリの2つのアプリから一つのリソース(例えばファイル)に読み書きするときに、同時に読み書きしてしまうといろいろ都合が悪いので、同時にアクセスしないように排他制御をしたい。Mutexを使う。基本的には、という流れでmutexを使う。下記が、WPFでmutexを使うサンプルコード。別途C++版も作成して両方からmutexを使う実験をする。今回は、「別々のユーザーで動いているC#とC++のアプリで、リソースを排他制御したい」という要件があった。
(具体的には、C++はサービスとして動いていて、C#はGUIをもつWPFアプリとして動く。)
そういう条件でmutexを作ったときに困ったのが下記のような点。つまり、そのままだと全然排他できてない、ということ。
(※同じユーザーが起動したものであれば、別のアプリであっても普通の名前で排他できていた)対処方法としては、名前の前にGlobal\をつけて「グローバルミューテックスにする」ということ。グローバルミューテックスにすれば、別のユーザーであっても同じ名前を付けていれば、排他制御に使える。その次に引っかかったのが、別ユーザーが作成したグローバルミューテックスは、そのままではアクセスできない様子。
対処方法としては、「グローバルミューテックスをフルアクセスできるようにして作成する」ということ。どのユーザーであってもアクセスできるようにしてやることで、グローバルミューテックスを通して複数ユーザーで排他できるようになった。通常、mutexを作って所有権を要求(WaitOne)して、処理が終わったらRelease、という流れになるが、
mutexを作るだけ作ってWaitOneせずにReleaseしたら、下記のような例外になる。非同期ブロックから呼び出すって何？と思うが、ともかくそういう例外になる。
対処としては、単純にWaitOneしてないものはReleaseしないようにする。
(これ起きるのはC#版だけかも？)上記を気にして作成すれば、C#版とC++版でmutexを通じて排他制御ができた。Mutexクラス(MSDocs)
https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.mutex?view=net-5.0


