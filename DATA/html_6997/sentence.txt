Unityでコードを書いたときにGC Allocが発生するパターンを調べた。GC Allocが少なくなるパターンをgoodとしたが、コードがわかりづらくなる場合もあるので必ずしも書き換えをする必要はない。Unity 2018.4 で動作確認string.Concatにobjectとして渡されてボックス化されてしまうので文字列にする。連結するごとに新しい文字列が生成されるが、4つまでの連結ならConcat(string, string, string, string)が呼ばれて一度に連結できる。ループでたくさん文字列連結することがある場合は、一回ごとに文字列が生成されないようにStringBuilderを使う。文字列の配列を連結する場合はJoinを使う。string.Formatよりも文字列補間($"")を使う。文字列補間のほうが見やすく、引数が文字列だけの場合は単純な文字列連結になりstring.Formatが呼び出されない。.NET Frameworkでは整数はToStringされて追加される。ToStringしたくない場合、1文字ずつ追加する必要がある。
https://gist.github.com/sapphire-al2o3/ba7d6a80836a2e5ee117abb4c3d75132.NET 4ならボックス化しないのでEnumをKeyにしてアクセスしてもGC Allocは発生しないが、低速なのでintをKeyにしたほうがいい。0を戻り値にした場合、ボックス化してGC Allocが発生する。foreachよりもforのほうが一時変数が少ないのでコルーチンのサイズが小さくなる。ListやDictionaryはあらかじめ追加するサイズが分かっている場合、生成するときにCapacityを指定する。たとえintの配列であってもラムダ式を指定しないと不要なキャストが発生してしまう。(.NET Coreだと大丈夫そう)何度も呼び出す関数はキャッシュする。listがnullの場合は何もしないがbadのほうは関数を呼び出しただけでGC Allocが発生する。
関数に入ったときに引数をキャプチャしたラムダ式が生成されてしまうので引数を内側のスコープにキャッシュしてキャプチャするとスコープに入らない場合はラムダ式が生成されない。インターフェース経由でforeachを使うとボックス化が発生するのでforを使う。Unityではclassでも自動で適切なメモリレイアウトにならないようなので無駄なパディングが入らないようにメンバー定義の順番を考慮する。GetEncodingを呼び出すと毎回クラスが生成されるのでキャッシュされるUTF8を使う。name プロパティにアクセスするたびにGC Allocが発生するのでキャッシュする。などもアクセスするたびに文字列が生成されてしまうのでキャッシュする。Renderer.materials はプロパティで配列を生成して返しているのでループで毎回アクセスしないようにする。こちらも配列を生成して返すので Input.GetTouch を使う。Animator.parameters は配列を返すAPIなのでキャッシュする。
Animator.GetParameter は Animator.parameters を内部で呼び出しているだけなので使わない。何度も呼び出す場合は、引数に配列やリストを渡して結果を受け取る関数を使う。


