More than 1 year has passed since last update.UnmanagedなC++のdllで、x64用とx86用を作って。dllを使う側に「64ビット環境ならx64用を、32ビット環境ならx86用を使ってください」というのをやめて、1つのdllファイルで、使う環境に合わせて自動でx64/x86を切り替えてくれるようにしたい。Costuraを使って、使う側にx64用、x86用のdll両方を組み込んで切り替えることで実現する。今回は、Costura.Fody4.0.0を使用して実験する。通常は、dllを使う側のexeと同じ階層に、使うdllが置いてあるイメージ。
(x64とx86があるdllがある場合は、必要な方のdllが置いてあるイメージ。)
Costuraを使った場合は、全部のdllをexeに組み込んで、x64とx86があるものに関しては自動で切り替えてくれるイメージ。

※各図のdllやexeの名前は、今回実験で作ったものを使用。今回の実験では、一番下のDLL(C++ x64/x86)の足し算をする関数を、一つ上のC#のDLLが呼び、さらにそのC#のメソッドをアプリが呼ぶ、という構成にする。
そのアプリが使う、C#とC++のDLLをexeにまるっと組み込んで、C++のDLLに関しては、x64とx86を両方組み込んで、自動で切り替える、ということをする。上の実験イメージにある、下記3つを作って実験する。Costura自体は、アプリのところ(アプリ(C#))で使用する。Costura周りだけ知りたいときは、そちら参照一つ上の層のC#のDLLで呼ばれる関数をつくる。
(C++のDLLの作り方は、以前の記事を参照)中身は、単に引数を足し合わせるだけ。特殊なプロジェクトの設定等もとくに無し。※.hファイルやその他のファイルは、サンプルコードを参照x64/x86のdllの計算関数を呼んで、結果を返すだけのメソッド。アプリから呼ばれるdll。このdllも、Costuraでexeに組み込まれる。やっていることは、C++のdllの関数をC#でラップしているだけ。特殊なプロジェクトの設定等もとくに無し。C#のdllのメソッドを呼んで、足し算を行う。このプロジェクトで、Costuraを使ってC#のdllとC++のdllをexeに組み込むということをする。Nugetで「Costura.Fody」と検索し、Costura.Fody v4.0.0をC#アプリのプロジェクトにインストールする。
備考
ここでやっているのは、C#アプリのプロジェクトに、x64、x86のdllを配置するためのフォルダを作るという作業。
Costuraが、そこに作成せよと指定している。詳細はこちら参照。
→「ネイティブライブラリを含めるには、ライブラリのビット数に応じて、costura32またはcostura64というフォルダを作成して、埋め込みリソースとして各ビット数のライブラリをプロジェクトに含める必要があります。」とのこと。(訳に自信なし)上記を行うと、このようになる。
呼び出し側のアプリのコードは共通で、x64とx86を自動で呼び分けられるように、dllの参照の名前に手を加える。これで、C++のdllを呼ぶ側からは共通のコードでx64,x86のdllを使えるようになる。そのコードの該当部分は下記。Costura.Fodyをインストールすると、自動的にソリューションフォルダにFodyWeavers.xmlが作成される。
デフォルトでは下記のようになっている。これを、下記のように修正する。各部分の意味は、下記の通り。他にも、exeに組み込まないようにしたりもできる。
FodyWeavers.xmlについての詳細は、Costuraのページの、Consiguration Optionsの部分を参照。FodyWeavers.xmlはVisualStudio上でプロジェクトに加えなくても、そこにあるだけでCostura的に動いてくれるが、dllを増やしたときなどにはメンテしないといけないものなので、見えやすいようにプロジェクトに加えておく。(必須ではない)以上で、exeの中にx64とx86のdllを組み込んで、アプリが動作する。とくに「FodyWeavers.xmlを修正する」あたりがややこしくて何をしているか最初の頃わからなくなっていたので、実施する際は今回のような仮のソリューションを作って練習した方がいいと思う。いろいろ調べているうちに、個人的によりよいと思えるやり方を見つけたので記載しておく。(参考)
元のやり方で「とくに「FodyWeavers.xmlを修正する」あたりがややこしくて...」と思っていたリンクを作る当たりの作業を行わなくて済む。こちらは基本的に同じことをするが、下記の点が異なる。という風にすると、元のやり方の方で、C#アプリの.csprojファイルをエディタで選んで直接編集してたような、変なことをしなくてよいので、やり方としてはこちらの方がきれいな気がする。(実体のdllがソリューション内に複数できてしまうのはデメリットといえばデメリット)一応、2.3.4を行ったときのバッチのサンプルやFodyWeavers.xmlの一部を上げておく。

※ただ、この&lt;Unmanaged32Assemblies&gt;と&lt;Unmanaged64Assemblies&gt;は、直さなくても、というか、何と書かれていても、もっと言うと、この2つがなくても、うまくexeにx64,86のdllは組み込まれてる気がする..(costura32/costura64フォルダにさえ入っていれば、組み込まれてくれる？？)ちょっと色々ごちゃごちゃ書いたので、コードを見た方がはやいかもしれない。下記を見て、別解を試すときは比較してやれば、何が変わったかわかりやすいと思う。■元のやり方
x64,86のdllをcostura32/64フォルダにリンクとして追加する方法
https://github.com/tera1707/WPF-/commit/71d0938d6c74b7190a423e418fd041fcff6e45fb#diff-cce630225d448987223f968060114623■別解
x64,86のdllをcostura32/64フォルダに実体コピーして使う方法
https://github.com/tera1707/WPF-/commit/4459dc07eea73d7d76813eb7bf2b3b6de61bbf0d#diff-cce630225d448987223f968060114623Costura Github
https://github.com/Fody/Costura【C++/C#】C++で作成したDLLをC#で呼ぶ
https://qiita.com/tera1707/items/81042abaa62dc97e26aePutting DLLs Into a Single WPF Exe
https://blog.jonstodle.com/putting-dlls-into-a-single-wpf-exe/


