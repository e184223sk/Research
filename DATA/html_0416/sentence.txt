生成対象のクラス定義(namespace は都合により ConsoleApp2 ) LINQ 登場以前に一般的だった手法。LINQ(というか Linq.Expression)を自分のものにするのはそこそこ手間がかかるので未だに現役だったりする。基本的には 対象の型をロードして、コンストラクタ探して作る。
System.Activator は型が分かっていればコンストラクタ呼出しを代行する。受け取ったインスタンスを IFoo にキャストしている。これにより欲しい処理が呼び出せる。Type.GetType() 呼出しで文字列を使っているので、同じインターフェースを実装した別のクラスに置き換えてもそれなりの動作をする。沼にようこそ。リフレクションのパターンと同様に型の取得やコンストラクタの取得を実行するのは同じだが、決定的に違うのは最終的に元のコンストラクタ呼出しと同じものが出来上がる事。expression() の部分がコンストラクタ呼出し。この呼び出しは事実上以下と等しい。あるいはこの呼び出しが1回だけならリフレクションパターンと大して差はないが、SQLクエリーからの結果行オブジェクト生成等だと圧倒的性能差が付く。「パラメータがあると使えない」とか言う人はいると思うけど、Expression.New() のオーバーロード調べてみると良い。当然それなりに複雑になるけれど。Pattern1 と同様、生成するクラスの名前を別の型にすることが可能。インスタンス生成を外部のクラスに隠蔽する。
コンストラクタ呼出しでもよいし、上二つのやり方を使っても良いし、他いろいろ使っても良い。
とにかくクライアントコードの中にインスタンス生成のための知識を持ち込まないことが重要。factory クラスの実装クライアントコードクライアントコードでは Factory についての知識と、  IFoo の知識があれば良い。
Factory が何かパラメータを使って IFoo を実装した別のインスタンスを返すようにしても良い。Pattern1、Pattern2 とは違い、呼び出す生成メソッドが実装クラスのコンストラクタを知っていなければならない
(もちろん Pattern1,Pattern2 と組み合わせて動的に生成しても良い.... あ、動的生成って言ってたけどこのパターンは基本的には静的な生成だった)各種 DI Container を使うパターン。コンテナによってはロードするアセンブリ自体を動的にロードして、読み込まれる型をごっそり置き換え…などという事も可能になる。ここでは Autofac 4.6.2 (だいぶ古いけど)を使ってみるまずはコンテナの構成コンテナに登録されたインスタンスの取得ここではサンプルコードの単純化のためにコンテナに登録する型を固定で書いているけれど、特定属性の付けられたクラスや特定 namespace のクラスをまとめて登録する、なんてこともできる。実行時のちょっとしたロジックの切り分け(一般ユーザーと特別会員の切り分けとか)だと Factory が活躍できる。
構成自体でロジックを切り替えたい場合(顧客ごとのカスタマイズコードの適用とか)なら DI がおすすめ。
(もちろんリフレクションを駆使しても良い。ただしそういう苦労をいろいろ肩代わりしてくれるのが DI)


