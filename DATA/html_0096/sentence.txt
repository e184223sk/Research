Azure Functions ホストの実装は　クラスローディングの塊なので、そろそろ仕組みをじっくり理解したくなってきた。そのために、その基礎のクラスの使い方を理解していきたい。今日はまず Create a .NET Core application with pluginsのチュートリアルを理解しながら流していきたい。C#のものにしては珍しく、コマンドラインから作成するようになっている。
折角なのでコマンドを調べてみよう。結構なテンプレートが使える感じだ。VSに出てくるのと近い感じだろうか。自動化するときに便利そう。早速つくってみる。-o オプションは、アウトプットを示すとヘルプに書いてあるが、ディレクトリがその名前で作成される。ごく基本的なアプリケーションが生成されている様子。
今作ると、net5 になる感じ。AppWithPlugin.csproj次のような sln ファイルが出来上がる。DependencyLoading.sln sln ファイルに、　次の箇所が追加されている。上記の作業が済むと、slnファイルに csproj ファイルが認識されるので、VS から開いてみる。Main のプログラムを書く。これはコマンドラインパーサーのようだ。プラグインが実装すべきインターフェイスを作成しておく。ICommand.csAppWithPlugin のプロジェクトが、このインターフェイスのプロジェクトを参照できるようにする。コマンドの実体は、AppWithPlugin.csproj のファイルにが追加されている。
VSで見ると次のイメージアセンブリローディングのコンテキストオブジェクトです。これが複数あると、同じライブラリの別バージョンもロードすることが可能です。カスタムの AssemblyLoadContext を作りたいときは、自分でオーバーライドして作成します。今回は AssemblyDependencyResolver という依存性解決のためのクラスを使っています。ResolveAssemblyToPath により、アセンブリ名から、アセンブリの存在するパスを取得しています。また、ResolveUnmanagedDllToPath によって、deps.json  に載っている、ネイティブライブラリをロードします。戻りが、IntPtr になっているのはよくわかっていないので継続して調査が必要です。** NOTE:** UnmanagedDll ネイティブライブラリロードの戻り値はなぜ IntPtr なのだろう？こちらは、typeof(Program).Assembly.Location によって、Program クラスが所属するアセンブリ (DLL) の場所を戻している。ちなみに Path はクロスプラットフォーム用のライブラリで、Path.GetDirecotryName はディレクトリ名を取得している。
PluginContext を取得して、アセンブリをそこから取得している。最初のパートはなぜそのようなコードになっているのかよくわからなかった。ぼんやりと、sln のいるプロジェクトルートを取得しているのはわかるが、Path.GetFullPath と Path.Combine の存在意義がよくわからない。ちなみに、こんなサンプルコードを書いて、Win10 と　Linux (WSL2 ubuntu) でテストしてみた。パスのデリミタなどはうまく対応できている。自分でパスをプラとフォームに合わせてめんどくさいコードを書く必要はない。ただ、GetFullPath と Path.Combine がある意図がよくわからない。なんでやろ。ドキュメントのサンプルのミス（もともと違うコードで、複数の文字を Combine してたなど。Privateは重要で、この設定だと、PluginBaseプロジェクトを参照していますが、この設定が無いと、ここでビルドしたディレクトリ(outputフォルダ)の配下にPluginBase.dll が作成されます。そうなると、PluginContext がそのアウトプットディレクトリからアセンブリをロードしてしまいます。ですので、HelloPlugin.HelloCommand の実装する ICommand は HelloPlugin の output ディレクトリの ICommand の実装となります。AppWithPlugin のデフォルトコンテキストからロードされたものになりません。ExcludeAssets の設定に関しては、このサンプルに限っては挙動は同じなのですが、プロジェクトが複雑になって、 PluginBase がPackageReferenceを持っている場合、false が参照の方に伝播しないので、そのワークアラウンドとして、設定が必要になります。めっちゃ単純です。HelloCommand.csHelloPlugin.deps.jsonHelloPlugin.deps.jsonパラメータや、実行ファイルの場所が記載されていなかったので、追加。パラメータで、読み込むアセンブリと、Plugin の名前を指定するようにした。


