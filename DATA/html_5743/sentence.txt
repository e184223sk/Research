More than 3 years have passed since last update.これはOpenCV Advent Calendar 2017の13日目の記事となります。本来はバーコード読み取り精度を高めた上で記事にする予定だったのですが、別の開発の遅れにより13日に間に合わなかったので、それは後々とします。
【2017/12/23追記】14日以降に幾つか分かったことを追記しました。お仕事でKEYENCEやDENSOなどの専用バーコードスキャナーを使っています。最近は、アスタリスク社のiPod Touchを使ったバーコードスキャナーの提案も受けます。今回、マイクロソフト Surface Pro 4 の内蔵カメラを使って、バーコードを読めないかという依頼がありました。Surfaceなら持ち歩けるので、その場で読みたい。バーコードスキャナーを一緒に持ち歩きたくない。QRコード（Quick Responce Code）は1994年にデンソーウェブの開発した、マトリックス型2次元コードの一種です。名前の通り、高速読取を目的に開発されました。マイクロソフト Surface Pro 4 バックカメラ 800万画素カメラ操作にOpenCVSharp 、バーコード読取りにZXing(ゼブラクロッシング)を使用します。
NuGetから現在バージョンとして、OpenCVSharp v3.3.1.20171117 と ZXing.Net v0.16.2 をインストールしています。Cameraクラスを別途作成し、Windowsフォーム側と分離するようにしています。
画像処理はMat型を受け渡ししています。バーコード解析処理もCameraクラスに内包しています。
※ソースコードを一部掲載していますが、掲載用に編集しているのでそのままでは動きません。CameraクラスからWindowsフォーム側にアクセスしたい場合、デリゲートを使っています。カメラ画像の読取りには、BackgroundWorkerクラスを使用しています。キャプチャー画像はPictureBoxIplコントロール(picMain)をCenterImageにして中央にQRコードを表示するようにしています。ユーザーがQRコードを中央の位置に合わせやすいように、赤色十字のターゲット枠を配置します。
キャプチャー画像にターゲット枠を直接描画すると解析上おかしなことになるので、別のPictureBoxにターゲット枠イメージ(png)を用意して、BackColor = Color.Transparent にした上で子コントロール化することでターゲット枠を重ね合せています。PictureBox上のLabelの背景が透明にならない問題の解決法タイマー(1000ms以内)を使って、ぶれ防止を兼ねてキャプチャー画像を一旦保存した上で、キャプチャー画像サイズが大きく、解析部分を減らすために中央に映っているある程度の範囲のみにトリミングしてから解析処理をしていきます。2cm以上のQRバーコードはなんなく読めたのですが、ユーザーから実際に使用するバーコードが送られてきたところ、ケーブルに付けられた8mmのQRコードでありました。それだとごくまれに読める程度で実用には程遠い状態です。
しかし、専用バーコードスキャナーはレーザーなのでなんなく読めるのです。ケーブルの紙は少し角度が付いていることもあり、8mmのQRコードを専用プリンタで印刷して平面状態にしたところ、少しは読めるようになったのですが、まだまだ実用には程遠い状態です。試行錯誤が始まりました。【2018/07/18追記】
8mmのQRコードはソフトウェアでの対応は難しく(カメラのピントが合わせ難いやQRコードが丸まってると読み取りできない)、結局ハードウェアの小型QRコードリーダーUSB対応(例 cubeQR)で対応することになりました。カメラ画像をグレースケール化します。気休めかも知れません。
【2017/12/23追記】2値化する上でグレースケール化は必須です。OpenCvSharpを使う　その3 (グレースケールに変換)先鋭化または2値化をやってみましたが、逆に読めなくなってしまいました。これは研究中です。【2017/12/23追記】
見た目では読めそうなQRコードを読めるようにするのに色々検討した結果、先鋭化は駄目でしたが2値化ではしきい値を調整すること読めるようになりました。
画像の閾値処理（2 値化）しきい値をどうやって決めるのかですが、256段階にグレースケール化して使用されている白色が一番多い値(周辺の明るさ)を算出します。
例えば算出値が209と明るめの場合、190～200の範囲で2値化して解析して読めるかを繰り返します。すると194でerrorの値となり、195で解析可能となりました。ちなみに196では解析不可でした。
同様に算出値が90と暗めの場合、70～80の範囲で2値化すると、75で解析可能となりました。手動(ボタンをクリックして解析)の場合には数秒は待ってもらえるので、2値化する範囲を広げてじっくり解析できます。自動(リアルタイム)では、2値化する範囲を狭めて解析します。その基準となるしきい値はトラックバーを用意してユーザー側である程度調整させるのと、手動で読めた際のしきい値を反映させます。
ここらへんはどうするのか検討中です。ソフトが駄目ならハードでってことで、100均ショップにスマホ用カメラにクリップで付けるマクロレンズが売っていたので購入しました。確かに付けることで少しは読めるようになるのですが、SurfaceとQRコードをかなり近づけることになるので、運用上あまりイケていない。あくまでソフト側で対応することにしました。【2017/12/23追記】
Surfaceは借り物だったので返してしまった。開発PCの内蔵カメラは性能が低いので、マクロレンズを使わないとボケてしまう。さすがにボケると滲んで2値化で調整しても読めないので今は必須です。TryHarderオプションの有効化と読み取るバーコードの種類をBarcodeFormat.CODE_39, BarcodeFormat.QR_CODEの２種類にしました。ZXing(.Net)のバーコード認識率を上げる方法ZXingはファインダパタンなどの座標を取得後に文字列のデコードを開始します。しかし、このデコードに失敗した場合に例え座標が取れていてもResultオブジェクトは生成されません。これは非常に勿体無い。
その為、QRコードの認識位置を取得するようにZXingライブラリを修正する。
座標が取れてデコードが失敗する場合、QRコードの部分を抜き出して、射影変換後に再度デコードさせる。これで少しは良くなりました。【2017/12/23追記】
2値化で読めるようになったので射影変換は止めました。ある程度、傾いていても誤り訂正で読んでくれたので、必要性に迫られたら再度検討します。【2017/12/23追記】
ResultPointは、左下→左上→右上の順の時と、右下→左下→右上の順の時がありました。
ResultPointはファインダパタンの中央点となるので、端までの差を決めてあげればQRコード部分のみの画像が取得できます。※射影変換をやめたので今は使っていません。左上、左下、右下、右上の順読めるQRコードと読めないQRコードの画像を比較しても、見た目に違いがないのに読めない。
その原因を探るにはZXing.Netのライブラリをデバッグしていけば何か分かるはず。ソースコードをダウンロードします。
https://github.com/micjahn/ZXing.Net今回のアプリケーションは.NET4.6を使用しているので、プロジェクトに.Net4.6用のzxing.net4.6.csprojを追加します。
これで、Decodeメソッドでステップインしていけば、ZXing.Netに入っていけます。14日あたりから、QRコード読み取りの研究に再度取り組むことになるので1週間後にまた記事を更新できると思います。【2017/12/23追記】
14日以降で分かった範囲を追記しました。OpenCVSharp自体は、日本の方が開発している。OpenCVの画像はMat型変数で表現されます。Matという名前は matrix で行列の略です。その為、行列なので(行、列)の順に指定されるため、一般の画像指定の(x, y)ではない。※x, yの順番が逆なことに注意!!※CV_8Uは0から255の整数
※1画素はB, G, Rの順に格納されている。ZXing(ゼブラクロッシング)はGoogle が開発して公開している、様々な一次元や二次元のバーコードの生成/操作ができるオープンソースライブラリです。


