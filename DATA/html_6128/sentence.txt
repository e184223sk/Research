More than 3 years have passed since last update.前回の投稿拡張メソッドを使って自力で、Map を実装するは、今回のイテレーターブロックを理解するための、ステップなのです（自分にとって。）早速イテレーターブロックに関して理解していきましょう。イテレータブロックとは、yield return や yield break を含むブロックのことです。特に前回紹介したような、イテレーターをゴネゴネしたいときにとても有効な書き方です。前回のおさらいをしてみましょう。オレオレ Map をこんな感じで実装しました。これだけで、次のようなコードをかくと、IEnumerable を実装したクラスが拡張されます。結果Map を実装してカッケーという感じですが、さらにおしゃれにかけます。今までは、Map の中で、List を作ってそこに、関数適用した結果を渡して、戻り値を作成していましたが、イテレーターブロックを使うとこんなに簡潔にかけます。おしゃれすぎる、、、つまり、yield return が呼ばれるたびに f(element) が イテレーターによって返却される感じです。じゃあ、それをつかったコードを書いてみますが、せっかくなのでちょっと変えてみましょう。実行結果。ううむいい感じ。ジェネリクス様様。さて、yield return の理解を深めるために、自分で自らでたらめな値を返却してみましょう。最初のリストなど関係ない。といったコードになっています。実行しましょう。予想通り、リストで定義された 1, 2, 3, 4 は無視され、yield return で指定した値が一つづつ返却されています。そして、yield break; が来た時点でイテレーターは終了します。ですので、20 はスルーされています。 さて、この仕組みを理解したかったのは、師匠が、Linq では遅延実行がつかわれているという話でそのサンプルを書いてくれたからです。師匠サンプルここで使われているテクニックが理解できなかったため２つのブログを書いて理解しようとしたわけです。今はりかいできます。もともと私が持っていた疑問は次のものです。こういうコードを書いたのですが、うまく動かなかったのです。関数を適用したかったわけではなく、foreach ではなく、Linq でワンライナーでループできないかなと思いました。これは、リフレクションで、取ってきたメソッド名と同名の環境変数の値をセットしようとしていました。Linq は遅延評価らしいです。
　しかし、これはうまくいきません。この書き方だと、この関数が実行されることはありません。なぜなら、properties.Select の戻り値が使われるときにはじめて、この関数が適用されるからです。この書き方だと、properties.Select の戻り値が捨てられているので、この関数適用が有効になることはありません。イテレーターブロックで書くと、遅延評価になるようなのでコメントを入れて違いを確かめてみましょう。
イテレータブロックを使っていないMap と、イテレーターブロックを使った CoolMap を使ってコードを書いてみました。実行結果を見てみましょう。Mapに渡された関数は、Map適用時に既に評価されているの対して、CoolMapに渡された関数は、foreachのタイミングで評価されているのがわかります。というわけでやっとすっきりしました。Linq の Select はこんなイメージに似ていて遅延評価なんですね。また一つ学びましたし、イテレータブロックも学んだので、ライブラリ作るときに役立ちそうです！


