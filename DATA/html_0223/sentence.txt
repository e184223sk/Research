タイトル名のようなことが簡単に出来るのでは？と思いトライしてみたが、残念ながら、次のようなエラーをもらった。プログラム的には、Parallel.ForEach を使って、32 ワーカー（仮）から、同じBlobを同時更新するようなコードを書いた。自分のイメージでは、その32 のワーカーは同時刻には同じ内容を返すはずなので、32のワーカーのどれが勝っても問題なく、楽観ロックすら必要ないので、楽勝と思っていたが違った。MD5のバリューがマッチしないと突然言われても「なんのMD５やねん」と思ってしまう。検索してみると、Blobのリファレンスを使いまわしているのが問題らしい。このMD５は何をしているか？というと、ファイルから、MD5を作成して、チェックサムとして使用している。しばやん先生のブログにも記事があった。ファイルをアップロードすると、たまに壊れるケースがあるので、MD5でチェックサムを作って送る機能があるようす。先の Exception が出たバージョンは次の通り。cloudBlockBlob は全く同じブロブなので、クラス変数にして、リファレンスを共有していた。上記のメソッドを呼び出す部分は、次のように、32並列で、同じ Blob を更新する。コードを次のように修正して、デバッグをしてみる。MD5 が生成されている。
ドキュメントを見ると、MD5 のチェックサムはデフォルトで有効なので、あのエラーがでた原因もうなづける。下記に面白そうなオプションが定義できるようになっている。BlobRequestOptions.DisableContentMD5Validation Propertyというオプションがあり、これがデフォルトで false なので、基本的にMD5のバリデーションをしてくれるのだろう。おまけだが、リトライポリシーも設定できる。何も設定していなので、こちらの値がデフォルト値なのだろう。ただ、ドキュメントに記述がないので、将来にわたってそうであるかはわからない。Blobのリファレンスは同時更新するのであれば、シェアしてはいけない。リファレンスを無くすことで、Exception が出ず、期待通り後勝ちの動作をしてくれるようになった。


