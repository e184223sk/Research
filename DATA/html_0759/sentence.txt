先日、下記記事を公開しました。【C#】インターフェイスの利点が理解できない人は「インターフェイスには３つのタイプがある」ことを理解しよう
https://qiita.com/yutorisan/items/d28386f168f2f3ab166dこの記事でIReadOnly系インターフェイスの役割と重要性について簡単に説明し、Listをそのまま渡すのではなく、IReadOnlyListとして渡すだけで、渡した先で勝手に書き換えられる危険性が皆無になりますと記述しましたが、これに対して「IReadOnlyListではIListにキャストされてしまうので、変更される危険性が皆無ではない。本当に皆無にしたければImuutableListで公開すべき」とのご意見をいただきました。ImmutableListのことは正直あまり知らなかったので、調べてみると「不変なコレクション」とのこと。
ReadOnlyCollectionとどう違うんだ…？と思ったので、それぞれ違いを整理しました。IReadOnlyList&lt;T&gt;は、ListのReadOnlyなインターフェイスです。定義は次のようになっています。IReadOnlyList&lt;T&gt;が継承1しているIReadOnlyCollection&lt;T&gt;の定義はこうです。つまり、インデクサによる値の取得と要素数の取得、それからIEnumerator&lt;T&gt;の取得（foreachで回す）だけができるコレクションというわけですね。
List&lt;T&gt;をIReadOnlyList&lt;T&gt;で渡すと、コレクション変更系メソッドが呼べなくなるので安全ですよ、というインターフェイスです。さて、ここからが本題で、冒頭で記述した「キャストされたら普通に変更されちゃう問題」についてです。IReadOnlyList&lt;T&gt;はList&lt;T&gt;のインターフェイス2なので、List&lt;T&gt;にキャストされてしまえば普通に変更できちゃうという問題です。以下の例をご覧ください。1,2,3でList&lt;int&gt;を初期化して、IReadOnlyList&lt;int&gt;にして渡しても、受け取った側が勝手にIList&lt;int&gt;にキャストすればAddできてしまうという例です。実行結果がこちら。IReadOnlyList&lt;int&gt;で渡したのに、100がAddされてしまっています。これは、IReadOnlyList&lt;T&gt;がインターフェイスであるがゆえ、必ず具象クラスが存在するので、もともとの具象クラス側で変更を許可しているならば無理やり変更できるという、悲しい問題です。しかし、普通のプログラマーであれば「IReadOnlyList」と書いてあれば、「あ、このコレクションは変更してはいけないんだな」と理解できるため、わざわざキャストしてまで無理やり変更されることは少ないと思います。
したがって、決してIReadOnlyList&lt;T&gt;では危険だ！と主張しているわけではありませんのでご留意ください。しかしながら、汎用的なライブラリとして公開するなど、どんな使い方をされるかわからない場合や、キャストによる変更される危険もなくしたいと言った場合は、次に紹介するReadOnlyCollection&lt;T&gt;クラスまたはImmutableList&lt;T&gt;クラスを使用すれば、この問題を解決することができます。ReadOnlyCollection&lt;T&gt;クラスは、List&lt;T&gt;をラップして読み取り専用なメンバのみ外部に公開するクラスです。このクラスを生成するにはAsReadOnly()メソッドを利用するか、IList&lt;T&gt;を引数にとったコンストラクタを利用します。IReadOnlyList&lt;T&gt;はインターフェイスで、実体としてはあくまでも具象クラスを参照しているため、具象クラスにキャストされればList&lt;T&gt;が変更される危険があります。
ところが、このReadOnlyCollecion&lt;T&gt;はインターフェイスではなく、元のList&lt;T&gt;とはまた別のクラスなので、キャストされる心配がありません。具体的には、元となるList&lt;T&gt;の参照を内部で持ち、読み取り専用のメンバのみを外部に公開しています。
そのため、内部のList&lt;T&gt;は完全にプロテクトされており、変更される危険がないのです。ちょっと分かりづらいかと思いますので図を用意しました。
IReadOnlyList&lt;T&gt;の場合は次のようになります。IReadOnlyList&lt;T&gt;はList&lt;T&gt;のうち読み取り専用のメンバのみを提供するインターフェイスです。
しかし、あくまでもList&lt;T&gt;に実装されたインターフェイスなので、キャストされればList&lt;T&gt;に直接アクセスされます。対して、ReadOnlyCollection&lt;T&gt;は次のようになります。
ReadOnlyCollection&lt;T&gt;は、インターフェイスではなく実体があるクラスで、内部に元となるList&lt;T&gt;の参照を持っています。
ReadOnlyCollection&lt;T&gt;はList&lt;T&gt;のメンバのうち読み取り専用メンバのみを外部に公開するため、List&lt;T&gt;自体は安全が保たれます。
さらに、外部からアクセスされるReadOnlyCollection&lt;T&gt;は内部のList&lt;T&gt;とは独立した存在なので、キャストによって内部のList&lt;T&gt;が変更される危険はありません。ImmutableList&lt;T&gt;クラスも、ReadOnlyCollection&lt;T&gt;と同様に、元となるList&lt;T&gt;を内部にラップします。このクラスを生成するには、ToImmutable()メソッドを利用するか、ImmutableList.CreateRange(IEnumerable&lt;T&gt;)ファクトリメソッドを利用します。コンストラクタによる生成はできません。ReadOnlyCollection&lt;T&gt;との違いは、参照ではなくコピーをラップすることです。
参照ではなくコピーをラップするため、ImmutableList&lt;T&gt;を生成したあとに元となるコレクションに変更を加えても、ImmutableList&lt;T&gt;の読み出し値は変わりません。以下のコードで、ReadOnlyCollection&lt;T&gt;とImmutableList&lt;T&gt;を両方生成したあとに、元のコレクションに変更を加えて、動作の違いを確認してみます。ReadOnlyCollection&lt;T&gt;のほうは、インスタンス生成後に元となるコレクションに変更が加えられた場合でも、その変更内容が反映されています。元となるコレクションの参照を内部にラップしているからですね。
対して、ImmutableList&lt;T&gt;のほうは、インスタンス生成後の変更内容が反映されていません。これは、元となるコレクションのコピーを内部にラップしているためです。言うならば、コレクションのスナップショットを撮影しているような感覚だと思います。ImmutableList&lt;T&gt;の場合は変更系メソッドが呼び出し可能です。
変更系メソッドを呼び出した場合、内部にラップされた元となるList&lt;T&gt;のコピーがまた生成され、そのコピーに対して変更内容が適用されて、メソッドの戻り値として返されます。したがって、変更系メソッドを呼び出した場合でも、元となるコレクションはもちろん、内部にラップしたコレクションにも変更が加えられることはありません。ImmutableList&lt;T&gt;の挙動を図で表すと次のようになります。
ReadOnlyCollection&lt;T&gt;と同様、キャストによる変更の危険性はなくなっています。IReadOnlyList&lt;T&gt;, ReadOnlyCollection&lt;T&gt;, ImmutableList&lt;T&gt;の違いをまとめると次のようになります。AsReadOnly()とToImmutable()のメソッド名をこうやって比べてみると、確かにAsの方は「オブジェクト参照はそのままで、型を変化させる」といったニュアンスが伝わりますし、Toの方は「オブジェクトを元にして別のインスンタンスを生成する」といったニュアンスが伝わります。細かなメソッド名の違いも、その挙動を正確に表現しているようです。メソッド名はきちんと考えて付けなければならないと感じました。実は、ReadOnlyCollection&lt;T&gt;クラスとImmutableList&lt;T&gt;クラスは、共にIList&lt;T&gt;インターフェイスを実装しています。
IList&lt;T&gt;インターフェイスを実装しているということは、AddやRemoveができるはずですよね？すごく疑問に思い調べてみると、インターフェイスの明示的な実装というものを使っているらしいです。詳しくはこのサイトを参考にしてほしいのですが、インターフェイスのメンバにあるけども、publicにしたくないメンバを隠すために使われることがあるようです。インターフェイスの明示的な実装を行うには下記のよう、インターフェイス名.メンバ名でインターフェイスメンバを実装します。このようにすると、MethodBはTestClassクラスのインスタンスから呼ぶことはできなくなり、メンバを隠すことができます。しかし、インターフェイスを実装している以上、メンバは呼べなければなりません。
ではどうすれば呼べるかと言うと、インターフェイス名.メンバ名で呼ぶことができます。
実装しているクラスのインスタンスから直接呼び出すことはできないけども、インターフェイス経由ならば呼び出せるようです。「インターフェイスの明示的な実装」、使う場面にはあまり出くわしたことがないですが、まだ知らないことがたくさんあると勉強になりました。では、ReadOnlyCollection&lt;T&gt;やImmutableList&lt;T&gt;でも、IList&lt;T&gt;インターフェイス経由であればAddやRemoveができるのかといえば、そうではないようです。両者のクラスは、IList&lt;T&gt;インターフェイス経由で変更系メソッドを呼び出すと、必ずNotSupportedExceptionがスローされるようです。この実装って正しいんですかね…？そこまでしてIList&lt;T&gt;インターフェイスを実装する理由は…？
まぁ、マイクロソフトのやることなので正しいのでしょう（適当）誰かReadOnlyCollection&lt;T&gt;やImmutableList&lt;T&gt;がIList&lt;T&gt;を実装してる理由知っていたら教えて下さい。以上、長くなってしまいましたがIReadOnlyList&lt;T&gt;とReadOnlyCollection&lt;T&gt;とImmutableList&lt;T&gt;の違いでした。ちなみにインターフェイスがインターフェイスを「継承」しているっていうんですかね？それとも「実装」？意味合い的には「継承」が正しい気もしますが。 ↩もちろんList&lt;T&gt;だけじゃなくて色々なクラスに実装されていますが代表として挙げました ↩


