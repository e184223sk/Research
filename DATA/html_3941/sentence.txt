More than 1 year has passed since last update.Unity上で、自分自身のウィンドウハンドルを取得する方法を５通り試しました。
結論としてはこの下の「方法 2」でどうかと考えています。
（製品にするなら「方法 5」が本命。）（Windowsでの話ですが）ウィンドウハンドルを取得できれば、Windows API を利用してリサイズや透明化など、色々なことができます。
ですが、Unityで作成したアプリが自分自身のウィンドウハンドルを取得する方法は元々は用意されていません。そこでスクリプトからWindows APIを呼び出すことによる取得方法をいくつか試しました。Windows API の GetActiveWindow() を用いると、アクティブなウィンドウのハンドルを取得できます。
Start()の中など起動直後に取得すれば、おおよそ自分のウィンドウがアクティブなはずなので大抵は動作しますが、そうは言っても起動は多少時間がかかるため、その間にデスクトップや他のウィンドウにフォーカスを移されて失敗することがよくあります。手軽割と失敗するそこで OnApplicationFocus() を用いて、自分がフォアグラウンドになったときに GetActiveWindow() を監視することを考えます。
自分がフォアグラウンドになった瞬間ならば、ほぼ GetActiveWindow() で自ウィンドウを取得できるだろうという考えです。ところが考え方はそれで良さそうなところ、なぜか起動時に自分にフォーカスがなかった場合、一度アクティブにしても OnApplicationFocus() が呼ばれませんでした。二回目以降にアクティブにすると OnApplicationFocus() が呼ばれます。そこで補助として、Input.anyKey の反応を見て何かマウスボタンやキー押下があれば、その時点で GetActiveWindow() を見るものも追加してみます。
どちらかというと[Alt]+[Tab]で切り替えるよりはウィンドウ内をクリックする人が多いと考えられるため、クリックした時点で反応すれば多少自然になります。さて、これでも動作はしそうですが、毎フレーム Input.anyKey に反応があればウィンドウハンドルを取り直すのでは無駄が多そうですので、フラグを設けてどうやら確実に自ウィンドウがとれていれば以降は監視しないようにもしてみます。以上をまとめたものが次のコードです。方法1に要素が追加された形となります。100%確実とは言えないかもしれないが、ほぼ実用上は十分そう。Windows API の FindWindow(クラス名, タイトル) を用いると、クラス名またはウィンドウタイトルが一致するウィンドウのハンドルを取得できます。
クラス名ではUnityのアプリがどれも同じになってしまいますので、タイトルからの取得の方が良いでしょう。特徴的なタイトルならば、ほぼ確実にウィンドウハンドルを取得できます。同じアプリケーションを複数起動することがあるようだと、困ります。
取得直後に Windows API の SetWindowText() を用いてウィンドウタイトルを書き換えてしまう、ということも考えられますが、まとめて複数起動されるとタイミングが合わない可能性もあるかもしれません。
またウィンドウタイトルは利用者にも見えるものですのであまり変に書き換えるのは良くないかと思われます。下記のような流れとなります。（コードは複雑になるため省略。）
1. 自分のプロセスIDは var process = System.Diagnostics.Process.GetCurrentProcess() でプロセスを取得した後 process.Id で得られる。
2. そして、Windows API の EnumWindows() でウィンドウ一覧を取得する。
3. それぞれのウィンドウに対して、Windows API の GetWindowThreadProcessId() を使って対応するプロセスIDを取得し、自分のプロセスIDと一致すれば、それが自ウィンドウだとする。確率的ではなく、確実に対象のウィンドウハンドルを取得できます。Unityでビルドしたスタンドアローンアプリケーションを、別のアプリケーションに埋め込むことができます。1
この場合、別途自分で作成したexeファイルが親のウィンドウとなるため、そのウィンドウハンドルを取得したり、子であるUnityのウィンドウハンドルを取得することは容易です。
こちら2にその話やサンプルプロジェクトへのリンクがありますので深くは解説しませんが、この方法ならばヒューリスティックではなく確実にウィンドウハンドルを取得できます。確率的にではなく、確実に対象のウィンドウハンドルを取得できます。
またこれならばウィンドウハンドルを使わなくとも、親となるウィンドウは自分で作成するため様々なことができます。別途exeファイルを用意するため、Unity外のプロジェクトが必要となります。私としては今のところ、Unityで完結させるなら方法2の GetActiveWindow()+監視 が扱いやすく、製品などできちんと作るならば方法5が最善かと考えています。Unity Manual. https://docs.unity3d.com/ja/2018.1/Manual/CommandLineArguments.html (accessed 2019-01-30). ↩Embed Unity3D app inside WPF application. https://stackoverflow.com/questions/44059182/embed-unity3d-app-inside-wpf-application Stack Overflow. (accessed 2019-01-30). ↩


