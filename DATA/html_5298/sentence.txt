More than 1 year has passed since last update.ラムダ式、LINQが全く分からなくて困っている方が、ラムダ式の仕組みを理解し、LINQを使えるようになるための記事です。
著者がラムダ式を勉強して理解するまでの過程をかみ砕いてわかりやすく説明していきます。ラムダ式について調べようと、「C# ラムダ式」で検索したら、以下のように書かれているサイトがヒットしました。ラムダ式は、 デリゲート 型または 式ツリー 型を作成するために使用できる 匿名関数 です。
ラムダ式を使用すると、引数として渡したり&gt;関数呼び出しの結果値として返すことができる
ローカル関数を記述できます。 ラムダ式は、LINQ クエリ式を記述する場合に特に便利です。引用元：ラムダ式 (C# プログラミング ガイド)「そもそもラムダ式が海のものとも山のものともわかってない私」にとって、これらのサイトを見ても全く理解できませんでした。
その他のサイトも色々見たものの、「LINQが登場する前のC#しか知らない・書けない」人向けのLINQの記事というのがあまりに少なすぎると感じました。（私が調べた2014年年末当時）
そこで、本記事は「ラムダ式の仕組みを理解し、LINQを使えるようになる」事を目標とする事にしました。
（厳密な定義等は他の記事・サイトに譲ります。また遅延実行の話や、式ツリーの話はばっさりと省略しています。それらはこの記事の内容を理解してからでも遅くないと考えるからです。）
記事自体は長めですが、大半はコードとなっています。
本記事で紹介するコードをコンソールアプリケーションのプロジェクトにコピペして、
実際にデバッグを行いながら記事を読み進めることを強くお勧めします。LINQは以下の３つの要素で成り立っています。本記事では、名前、数学の点数、物理の点数を保存するクラスのリストから、
数学と物理の平均点を求めるメソッドを作成しながら、上記３要素についてひとつずつ説明していきます。テスト受験者、数学および物理の点数を保存するTestResultクラスのリストがあります。
resultsには3人分の試験結果のデータ(TestResultクラスのインスタンス)が格納されています。
受験者全員の数学の平均点を求めるメソッドをProgramクラス内に作ってみましょう。Programクラスに以下のメソッドを追加しますMain関数を修正し、追加したメソッドを呼ぶこれで、数学の平均点を求めるメソッドが完成しました。
では、同様に物理の点数の平均点を求めるメソッドはどのようにして作ればよいでしょうか？double num = tr.Physics;以外の行は数学の平均点を求めるメソッドと全く同じです。
また、今後科目数が増えると、その都度コピペしてメソッドを追加するのでしょうか？
もしこのメソッドに修正が入った場合、コピペした全てのメソッドを修正しますか？
そんな事はしたくないですよね。
何かいい方法はないでしょうか・・・
そんな時に使えるのが「デリゲート」です。
この「デリゲート」を引数にすることによって、メソッド内部のロジックを外から変更する事が可能になります。デリゲートとは、「メソッドを参照する型」の事です。
代表的なものに、ActionとFuncがあります。
Actionは戻り値がvoid型のメソッドを参照するため、Funcは戻り値がvoid型以外のメソッドを参照するためのものです。
以下のサンプルソースをご覧ください。例１のメソッドは、引数も戻り値もないメソッドです。
戻り値がないメソッドなので、Action型を使います。例２のメソッドは、int型の数値を受け取り、int型の数値を返すメソッドです。
戻り値があるメソッドなので、Funcを、引数もひとつ存在するので、
Funcを用います。今回は引数がintなので、Tはint、戻り値もintなので、TResultもintとなります。
そのため、Func&lt;int, int&gt; add = AddOne;とすれば、addがAddOneを参照するため、addをメソッドのように使うことができます。例３のメソッドは、DateTimeとdouble型の値を受け取り、string型の値を返すメソッドです。
戻り値があるメソッドなので、Funcを、引数はふたつなので
Funcを用います。Funcは引数が多くなっても、最後が戻り値の型となります。メソッドの内部でもメソッドを定義することが書き方です。
デリゲートのサンプルソースでは、例１~例３までそれぞれメソッドを定義していましたが、
小さいメソッドをいちいち定義するのは大変です。メソッド名を考えるのも面倒ですよね。
なので、デリゲートのサンプルソースを修正して、メソッドをMainメソッド内部で定義してしまいましょう。いきなり=&gt;が出てきて面食らったと思います。順を追って見ていきましょう。まず例１について。修正前は
Action hello = Hello;
として、Helloメソッドを参照させていましたが、修正後は
Action hello = () =&gt; { Console.WriteLine("Hello, World!!"); };
と、Helloメソッドの中身まで一行で書いています。（参考）ラムダ式を使わない場合のHelloメソッドラムダ式の=&gt;の左側は引数、右側はメソッドで行う処理を書きます。
Helloメソッドは引数がないので、()としています。引数がある場合は例２、例３で見ていきます。例２について
Func&lt;int, int&gt; add = (n) =&gt; { return n + 1; };
int型の引数nを受け取って（=&gt;の左側）、n + 1を返す(=&gt;の右側)ラムダ式を、addに参照させています。
例２については、引数が１つだけなので、nについているカッコは省略できます。また、右辺も一行なので、括弧およびreturnは省略できるので、
Func&lt;int, int&gt; add = n =&gt; n + 1;
と書くこともできます。例３について
Func&lt;DateTime, double, string&gt; TodaysNikkei = (dt, price) =&gt; { return dt.ToShortDateString() + " の日経平均株価終値は" + price.ToString() + "円です。"; };
考え方は例２と同様です。引数が２つになったバージョンです。デリゲート・ラムダ式についてより詳しく学びたい方は、是非下の記事をご覧ください。デリゲートとラムダ式の説明が長くなりましたが、話を元に戻して、
数学と物理の平均点を求めるメソッドをどのように修正するかを再び考えてきましょう。double num = tr.Math;の部分を、デリゲートを使って処理を呼び元で変更したいんでした。
TestResultクラスから、double型の数値を抜き出すデリゲートを引数に追加しましょう。
（数学以外の平均点を求めることもできるようになったので、メソッド名を変更しました）併せて、呼び元も変更する必要があります。ここでのtr =&gt; tr.Mathは、以下のメソッドと同じ意味です。これで、数学も物理も今後追加される可能性のある科目も、全てCalcAverageメソッドを使う事によって
平均点を求めることができるようになりました。ラムダ式とデリゲードを使った結果、サンプルソースは以下のよう修正されましたdouble型であればどの変数でも平均が求められる便利なメソッドができましたが、このメソッドはあくまでTestResultクラスにしか使えません。
ジェネリックを用いて、TestResult以外のクラスでも使えるようにしましょう。
ジェネリックとは、クラスやメソッドを型を特定せずに使用したい場合に使います。
List&lt;T&gt;は一度は使ったことがあると思います。List&lt;T&gt;は、List&lt;string&gt;やList&lt;int&gt;、List&lt;TestResult&gt;等、あらゆるクラスで使用することができます。さっそく、CalcAverageメソッドをジェネリックに対応させましょう。
"TestResult"を"T"に置き換えてみます。すると、以下のようなエラーが発生します。エラー　型または名前空間名 'T' が見つかりませんでした。using ディレクティブまたはアセンブリ参照が不足しています。これだけでは不十分です。メソッド名の最後に&lt;T&gt;を付加しなければいけません。これでエラーが無くなりました。呼び元はTの型を自動的に推測するので、修正は不要です。
このメソッドはクラスに依存することなく、さまざまなクラスで使うことが出来ます。拡張メソッドを使うと、ある型に対して、その型自体を変更することなく、型に対してメソッドを追加することができます。
今回は、List&lt;T&gt;型に直接、平均を求めるメソッドを拡張メソッドを用いて追加します。
文章だけでは伝わらないと思うので、実際にプログラムを修正しながら見ていきましょう。拡張メソッドについてより詳しく学びたい方は、是非下の記事をご覧ください。せっかく作成した便利なメソッドも、このままではProgramクラス内でしか使えないので、別のクラスに移動させて、様々なクラスから使えるように修正しましょう。
今回は新たに、ListUtilという名前の静的クラスを作成し、その中に平均を求めるメソッドを移動することにします。同時に呼び元も修正しますこのままでもよいのですが、これだとListUtilクラスの存在を知らないとメソッドが使えないので、拡張メソッドにしてみましょう。
ソースを以下のように修正します静的クラス内の静的メソッドの第一引数の前に"this"をつけると、拡張メソッドになります。
呼び元はそのままでもよいのですが、以下のように変更することも可能ですまるで、List&lt;T&gt;クラスにあるメソッドのように使うことができます。
これだと、クラス名ListUtilを知らなくてもこのメソッドがIntelliSenseで表示されます。
(results. と打てば、候補にCalcAverageが出てきます)
第一引数のresultsが先頭に来るため、引数は一つだけとなります最初はTestResultクラスリストから、double型のプロパティ（数学と物理の点数）の平均点を求めるためのメソッドを作っていましたが、ラムダ式を使いdouble型であればどんなプロパティでも平均を求められるようにし、更にジェネリックを使いクラスを限定せずに様々なクラスから使用できるようにしました。最終的なソースコードは以下のようになりました。今回作成したCalcAverageメソッドはとても便利だと思いませんか？
平均を求めたい変数を外部から指定でき、どんなクラスでも使える。
こんな便利なメソッド、あらかじめ用意してくれていたらいいのに。・・・そんな要望を叶えてくれるのがLINQです。
System.Linqをusingし、Mainメソッドに以下の一行を追加してください
double mathAveLINQ = results.Average(tr =&gt; tr.Math);
今回作ったCalcAverageメソッドとほぼ同様のメソッドが、既にSystem.Linq.Averageとして存在しているのです。
（厳密にはLINQのAverageメソッドは第一引数がListではなくIEnumerableですが、今回は説明は省略します）
LINQには、その他最大値(Max)、最小値(Min)を求めるメソッドや、Listから特定の条件のものに絞り込むWhere等があります。
それらの紹介は別の記事で紹介するかもしれません。


