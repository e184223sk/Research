以下のようなことがしたいです。しかし、悲しいかな↑のソースコードはList&lt;SubClass&gt;をList&lt;BaseClass&gt;に変換できませんと言われエラーとなります。ところが、List&lt;T&gt;ではなくIEnumerable&lt;T&gt;で受けると↑のようなことが可能になります。List&lt;T&gt;で受けるとダメだったのに、なんでIEnumerable&lt;T&gt;で受けると型引数にポリモーフィズムが適用できるのか？それは、IEnumerable&lt;T&gt;が読み取り専用インターフェイスだからです。
IEnumerable&lt;T&gt;の定義を見てみましょう↓IEnumerator&lt;T&gt;を取得できるだけになっています。
じゃあIEnumerator&lt;T&gt;の定義はというと…Tを取得できるだけののようです。
非ジェネリックバージョンのIEnumeratorも継承していますが、型引数Tが含まれないので無影響ですね。同様に、IReadOnlyList&lt;T&gt;インターフェイスなんかも、名前の通り読み取り専用なので以下のように型引数にポリモーフィズムを適用できます。IEnumerable&lt;T&gt;で受けると型引数にポリモーフィズムを適用できるのは、IEnumerable&lt;T&gt;が読み取り専用だからということがわかりました。
じゃあなんで読み取り専用だと型引数にポリモーフィズムが適用できるのか？次の例を見てみましょう↓インスタンスの実体としてはList&lt;SubClass&gt;なのに、BaseClassのインスタンスや、BaseClassを継承した別のSubClass2のインスタンスをAddできてしまいます。このように読み取るだけなら何も問題は生じません。このようにジェネリックの型引数にポリモーフィズムを適用できる機能を、「ジェネリックの共変性」といいます。
対して、その逆となる「ジェネリックの反変性」という機能も存在します。
※ちなみに、共変性・反変性はインターフェイス、またはデリゲートの型引数にのみ適用できます。ジェネリックの共変性とは、ジェネリックの変数にその派生型の型引数をもつオブジェクトを代入できる性質のことです。
以下のように、型引数にoutキーワードを付与することで、そのインターフェイスやデリゲートに共変性を付与することができます。先に紹介したIEnumerable&lt;T&gt;やIReadOnlyList&lt;T&gt;も、定義を見るとout修飾子がついていることが確認できます。out修飾子を付けると、そのインターフェイスにはT型を入力するようなメンバ（T型プロパティのgetアクセサー、T型の引数）を含めることはできなくなります。
そのため、コンパイラによって読み取り専用であることが保証されるため、安全に派生型の型引数をもつインスタンスを代入できるようになるわけです。読み取り専用、つまり取り出し専用なので「out」と考えると分かりやすいですね。対して、ジェネリックの反変性とは、派生元の型引数を持つオブジェクトを代入できる性質のことです。ちょうど共変性の対となる性質です。
以下のように、型引数にinキーワードを付与することで、そのインターフェイスやデリゲートに反変性を付与することができます。out修飾子が読み取り専用であるのに対してin修飾子ときたら想像つくと思いますが、これは「書き込み専用」であることを保証します。
in修飾子を付けると、以下のようなことが可能になります。派生型の型引数を持つ変数に、その派生元の型引数を持つインスタンスを代入できるようになります。
派生型にその派生元のインスタンスを代入するというのは、とても不自然に感じます。なぜ、in修飾子をつけることによって「書き込み専用」が保証されると、このような事が可能になるのか？
以下のようなコードで考えてみます↓実体となるクラスは派生元のBaseClassなので、入力されるぶんには、別にさらに具体的なクラスを入力されても何も問題がありません。実体となるクラスは派生元のBaseClassであるにも関わらず、SubClassとして出てきてしまいます。
このように、読み取りには問題が生じることがわかります。ジェネリックの共変性と反変性はややこしくてこんがらがるので、簡単にまとめました。
なにかご指摘等ありましたらコメント頂けると嬉しいです！


