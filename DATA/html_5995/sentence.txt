More than 3 years have passed since last update.車輪の再発明
...ですが, ブラックボックスから脱出する良いきっかけになったので, 備忘録として記録しておきます.
MVVMパターンで使われている内部実装に興味がある方にとって, 理解の一助になれば幸いです.Livetに乗っかっておまじない的に使ってきたMVVMの中で何が起こってるのかをちゃんと理解したかったので, 一度自前で実装してみることに.
Livetが使えない環境でも同じようなコードを組めると色々嬉しい.ソースはこちら
プロパティ変更通知を発行します.C#にはすでに「PropertyChangedEventHandler」型のイベントが標準で用意されています.
このイベントを「PropertyChanged」というプロパティでもつように定めたのが「INotifyPropertyChanged」インタフェースです(using System.ComponentModelが必要)LivetのNotificationObjectは「RaisePropertyChanged」メソッドを呼び忘れるとプロパティ変更イベントが飛んできません.
それは嫌だったので, SetValueというメソッドを用意しました.
(これはPrismのパクり)このメソッド経由でプロパティを設定すると, 自動的にプロパティ変更イベントがInvokeされるようにしています.
また, [CallerMemberName]指定することで, 呼び出し「元」のプロパティ名が勝手に「caller」にセットされます(using System.Runtime.CompilerServices;が必要)プロパティの変更通知を行う側はできたので, 今度はプロパティ変更通知を受け取るためのクラスを作っていきます.コンストラクタでINotifyPropertyChangedを参照するようにして, プロパティ変更通知のイベント登録(handlerの登録)も行うようにしました.
NotificationObject側でプロパティの変更があれば, 登録しておいたHandlerがInvokeされます.
「もうプロパティの変更通知は受け取らなくて良いよ」というタイミングになったら, Disposeを呼び出してプロパティ変更イベントの登録解除をおこないます.「プレイヤー(プロパティ変更通知送信側)」と「HPゲージ(プロパティ変更通知受信側)」これでプレイヤーのHP変更を監視するUIプログラムを作ることができました.
MVVMのViewModelに相当しますね.単一のObjectについてはプロパティ変更を送受信する仕組みが整いました.
Collectionに関しても自作してみたので, 後編に続きます.
自前でC#の変更通知クラスを作って勉強になったことまとめ(後編)今回はここまで...


