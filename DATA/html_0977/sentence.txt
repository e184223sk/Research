この記事は 2020 年の ReactiveProperty のオーバービューの全 3 編からなる記事の 2 つ目の記事です。他の記事はこちらです。ReactiveProperty には MVVM アプリケーションを開発するときには必須のコマンドを提供しています。型引数の有無はありますが、大きくわけて非同期処理対応じゃないものと非同期処理対応のものの 2 種類のコマンドを提供しています。普通のコマンドです。特徴としては ICommand の実行可否を表す CanExecute と CanExecuteChanged イベントを IObservable&lt;bool&gt; から発行された値をもとに指定できるというものがあります。ReactiveCommand を作成するには IObservable&lt;bool&gt; に対して ToReactiveCommand() か 型引数ありの ToReactiveCommand&lt;T&gt;() を呼び出すことでコマンドの生成が出来ます。型引数がないものはコマンドパラメーターを受け取らないコマンドで、型引数を指定するとコマンドパラメーターを受けるコマンドになります。また、IObservable&lt;T&gt; を実装していて、コマンドの Execute が呼ばれると OnNext が実行されます。そのため Subscribe でコマンドの実行処理を書けたり、Where などの LINQ のメソッドで加工や合成が可能になります。Subscribe メソッドReactiveCommand の特徴についてまとめます。動きは以下のようになります。実行結果は以下のようになります。ToReactiveProperty の型引数を指定するとコマンドパラメーターありになります。
動作確認のコードは以下のようになります。実行すると以下のようになります。XAML プラットフォームでは、この ReactiveCommand を Button などの Command プロパティとバインドして使用します。
実際に ViewModel クラスで定義した例を以下に示します。XAML で使ってみましょう。実行してみると以下のように動きます。チェックボックスとボタンの活性非活性が ReactivePropertySlim&lt;bool&gt; から作られた ReactiveCommand の CanExecute 軽油で同期されます。そしてボタンのクリックを IObservable&lt;string&gt; に Select で変換して ToReadOnlyReactivePropertySlim で ReactivePropertySlim にしたものとバインドすることでコマンド実行と同時に一番下の TextBlock にメッセージが表示されます。この他に ReactiveCommand には WithSubscribe メソッドがが定義されています。これはコマンドのインスタンス生成から Subscribe までをメソッドチェーンで定義できる便利メソッドです。以下のように利用します。便利。最後に常に実行されていればいいコマンドは普通に new ReactiveCommand() で作成できます。次に非同期対応のコマンドです。このコマンドは、Subscribe に非同期メソッドが指定できます。そして非同期メソッドが実行している間は CanExecute が false を返してボタンなどが自動的に非活性になります。便利。
以下にコード例を示します。DataContext に設定して適当にバインドします。実行すると以下のようになります。ちゃんと非同期処理が実行中はボタンが非活性になっています。注意点としては、AsyncReactiveCommand は IObservable&lt;bool&gt; ではないので ReactiveCommand のように Select などは出来ません。Subscribe か WithSubscribe をするだけになります。非同期操作を行うコマンドが画面内に複数個あって、どれかが実行されている間は全部のボタンを押せないようにしないという要件は結構あると思います。
AsyncReactiveCommand は、その機能を組み込みでサポートしています。AsyncReactiveCommand を生成するためのメソッドやコンストラクターには IReactiveProperty&lt;bool&gt; を受け取るオーバーロードや IReactiveProperty&lt;bool&gt; 専用の ToAsyncReactiveCommand 拡張メソッドがあります。IReactiveProperty&lt;T&gt; は ReactiveProperty&lt;T&gt; クラスと ReactivePropertySlim&lt;T&gt; が実装しているインターフェースです。つまり ReactiveProperty&lt;bool&gt; か ReactivePropertySlim&lt;T&gt; を渡せるということです。IReactiveProperty&lt;bool&gt; を使って作った AsyncReactiveCommand は、実行可否の状態を、この IReactiveProperty&lt;bool&gt; を通して共有します。
例えば、コマンドの実行可否を共有する 2 つの AsyncReactiveCommand を作るようなコードは以下のようになります。この 2 つのコマンドをボタンにバインドしてみましょう。実行すると以下のようになります。コマンドの実行可否のステータスが共有化されていることがわかります。もう少し複雑な例を紹介したいと思います。例えば 2 つの入力項目があって、そこに入力エラーが無かったら押せる AsyncReactiveCommand に紐づいたボタンが複数個あって、それの実行可否を共有するようにしてみましょう。以下のようなコードになります。XAML で適当にバインドします。実行すると以下のようになります。エラーのないときだけ押せて、なおかつどちらかしか押せないボタンが出来ました。ReactiveProperty では、いくつかの便利なコレクションクラスを適用しています。以下の 3 つをよく使うことになると思います。ObservableCollection に UI スレッド上でのコレクション操作を行うメソッドを追加したものになります。
AddOnScheduler や RemoveOnScheduler などのように、普通のコレクション操作を行うメソッドに対して OnScheduler がついたメソッドが定義されています。このメソッドを呼び出すことで自動的に UI スレッド上でコレクション操作が行われます。通常はバックグラウンドのスレッドからコレクション操作を行うと、そのコレクションが UI 要素にバインドされているとアプリが落ちますが、ReactiveCollection の OnScheduler のついているメソッドを使うことでバックグラウンドスレッドからも割と気軽にコレクションが操作できます。例を以下に示します。これを適当に画面にバインドします。ボタンを押すと UI スレッド以外からコレクション操作が行われますが例外が起きることはありません。この他に IObservable&lt;T&gt; から ReactiveCollection&lt;T&gt; を生成する ToReactiveCollection メソッドも提供しています。このメソッドを呼ぶと IObservable&lt;T&gt; から値が発行されたらコレクションに要素が追加されます。
例えば先ほどの MainWindowViewModel を以下のように書き換えても同じ動作になります。ReactiveCollection のスレッドを自動で切り替える機能は便利ですが、スレッドを切り替えるということは追加や削除などのコレクション操作はメソッドを呼び出しても即座には行われないという点に注意が必要です。
例えば AddOnScheduler で 10 個の要素を追加して、そのままコレクションの Count を参照しても要素は増えていません。例えば、先ほどの ViewModel を以下のように書き換えてみます。コマンドでコレクションに 10 個の要素を AddOnScheduler で追加して Count プロパティを MessageBox で表示しています。素直に考えると 10 と表示されてほしいところですが、先ほど言った理由から 0 と表示されます。現状では、コレクションの操作の完了を待つ方法はありません。ObservableCollection のような変更通知の機能を持ったコレクションと同期する読み取り専用のコレクションが作成できます。また、ReadOnlyReactiveCollection では自動的にコレクションの変更通知イベントを UI スレッド上で実行します。ReadOnlyReactiveCollection を生成するには、元になるコレクションに対して ToReadOnlyReactiveCollection 拡張メソッドを呼び出します。ToReadOnlyReactiveCollection メソッドの引数にはラムダ式が指定できて、ここで元になるコレクションの要素に対する変換処理が指定できます。例えば Guid を保持する ObservableCollection を元にして Guid を表示用に加工した文字列を保持する同期した ReadOnlyReactiveCollection を作るコードは以下のようになります。XAML は以下のようになります。実行すると以下のようになります。元になるコレクションを UI スレッド以外から操作してもエラーにならないことが確認できます。ReadOnlyReactiveCollection から要素が削除されるタイミングで、ReadOnlyReactiveCollection は削除される要素が IDisposable を実装している場合に Dispose メソッドを呼び出します。何か要素の後始末が必要な場合は IDisposable を実装してください。今回は例のために ObservableCollection を UI スレッド外から更新しましたが、ObservableCollection はスレッドセーフなコレクションではないので複数スレッドから要素の追加や削除などを行うと中身が壊れる可能性があります。（というか壊れます）
気を付けましょう。複数スレッドからデータを追加する場合はロックをかけるなどの対策が必要です。IFilteredReadOnlyObservableCollection は INotifyPropertyChanged を実装したクラスの ObservableCollection に対してリアルタイムでフィルタリングを行うコレクションです。使い方は簡単で INotifyPropertyChanged を実装したクラスの ObservableCollection に対して ToFilteredReadOnlyObservableCollection をフィルタリングの条件のラムダ式と共に呼び出すだけです。例えば以下のように一定間隔で Value プロパティが変わる Sensor クラスがあるとします。このクラスの ObservableCollection と Value が 50 以上のみを表示する IFilteredReadOnlyObservableCollection を作成するコードは以下のようになります。これを XAML にバインドします。実行すると以下のように左側には全部の要素が表示されますが、右側には Value が 50 以上の要素しか表示されていないことが確認できます。ReactiveProperty の提供するクラスで以下のものは UI スレッドへの自動ディスパッチ機能があります。前編でも書きましたが、これは ReactivePropertyScheduler.SetDefault(IScheduler defaultScheduler) メソッドで任意のスケジューラーに置き換えることが出来ます。デフォルトが UI スレッドになっています。
各クラスのインスタンスが作られた時点の ReactivePropertyScheduler.Default が使用されます。アプリケーションのエントリーポイントで ReactivePropertyScheduler.SetDefault(ImmediateScheduler.Instance); のようなコードを指定することで UI スレッドへのディスパッチを辞めて即座に実行するように変更することが出来ます。また ReactivePropertyScheduler.SetDefaultSchedulerFactory メソッドを指定するとスケジューラーを取得する任意のロジックを指定できます。例えば WPF の App.xaml.cs の Startup イベントで以下のように設定しておくことで、ReactiveProperty などのインスタンスが生成されたスレッドに紐づく Dispatcher でイベントを発生させるようなスケジューラーを返すようにできます。グローバルに一括で設定するほかに各クラスのインスタンスを生成する際に IScheduler 型の引数を受け取るオーバーロードがあるので、それを使ってディスパッチ先を変えることが出来ます。
例えば ViewModel で以下のようにすることで、指定されたスケジューラーか現在のスレッドのスケジューラーを紐づいたスケジューラーを使用するといったことも出来ます。ReactiveProperty や ReactiveCommand や ReactiveCollection などの殆どのクラスは IDisposable インターフェースを実装しています。これらのクラスで Dispose を呼ぶと例えば ReactiveProperty が IObservable から作られている場合は、IObservable と切り離されます。また、ReactiveProperty を Subscribe している人たちへ OnCompleted を発行して切り離します。なので、不要になったタイミングで Dispose を呼び出しましょう。Reactive Extensions には IDisposable を一括で Dispose してくれる CompositeDisposable があります。この CompositeDisposable に対して ReactiveProperty や ReactivePropertySlim や ReactiveCommand などを Add することで、任意のタイミングで一括で Dispose 出来ます。また ReactiveProperty では IDisposable の拡張メソッドとして CompositeDisposable に簡単に登録できる AddTo 拡張メソッドを提供しています。これを使うことで ReactiveProperty や ReactiveCommand の生成のメソッドチェーンに CompositeDisposable への追加処理を自然に書くことが出来ます。コード例を以下に示します。一般的には ViewModel クラスのフィールドやプロパティで CompositeDisposable を保持して、不要になったタイミングで Dispose を呼んで一括で購読などを解除します。以下のようなコードになります。単純にずっと IObservable の処理がつながっていると、何かの値が発行されるたびに動く処理が多くなるので性能は悪くなるでしょう。もっと深刻な例では寿命の長いオブジェクトの発行する値を購読して ReactiveProperty や ReactiveCommand を作っているとメモリリークの原因になります。例えば寿命の長いオブジェクトに ObserveProperty をして ReactiveProperty への変換したとします。この時 ObserveProperty は寿命の長いオブジェクトの PropertyChanged イベントを購読しています。PropertyChanged イベントを購読しているということは、PropertyChanged イベントの発行先として寿命の長いオブジェクトに発行先として登録されるということです。これは ToReadOnlyReactivePropertySlim で作られた ReadOnlyReactivePropertySlim を Dispose するまで開放されません。なので、ライフサイクルの長いオブジェクトから作った ReactiveProperty などは必ず不要になったタイミングで Dispose しましょう。中編では主にコレクションや、コマンドについて説明しました。スレッドや後始末など意外と重要なことも入っているのでもしかしたらシリーズの中で一番重要なところかもしれません。残るはプラットフォーム固有機能と、便利クラスたちの紹介になります。


