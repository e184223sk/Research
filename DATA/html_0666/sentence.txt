SQLの経験がほぼない状態だけど、
Node.js、C#、Python3、HSP3でのSQLiteの扱い方を学んだ。
(一応SQL文のみでの動作も)Node.jsはなんとなくTypeScriptで書いているので、各自動かす場合は型表記を削除すること。
(多分まとめのPromiseだけ)node-sqlite3
下記でインストール。Microsoft.Data.SqliteSystem.Data.SQLiteとは派生の関係にあり、大よそのAPI機能は一致していそう。sqlite3
標準ライブラリなので追加インストール不要。sqlele
標準ライブラリなので追加インストール不要。データベースを開いて、
テーブルがなければテーブルを作って(CREATE)、
アイテムを追加して(INSERT)、
データベースを閉じる。「ID」列は自動採番(AUTOINCREMENT)を設定。データベースを開いて、
テーブルを全部表示して(SELECT)、
データベースを閉じる。データベースを開いて、
テーブルを変更して(UPDATE)、
データベースを閉じる。　データベースを開いて、
テーブルが存在すればテーブルを破壊して(DROP)、
データベースを閉じる。　関数化してここまでのデータベース操作をまとめた。
(SQL文除く。SQLiteでは関数を使えない?)　以上、SQLiteを試してみた結果でした。INSERTとかUPDATEはループで注ぎ込んだ方が見栄えが綺麗な気がするけど、動作の確認が主なので今回はひたすら愚直に。
最後のまとめも関数毎にデータベース開いて閉じているのも意味はないはず。言語に関する感想はライブラリの使用によるところが近い。多分。
特にSELECT文は返り値があるためライブラリの仕様の違いがよく目立つ。普通の手続き型言語と全然書き方が違って慣れない…
if文があってfor文があって関数があってというのが、普通の言語だけどSQLでは違う考え方を要求されるのが難しい。SQLにおけるSELECT文はprint文であり、foreach文のようである感じでよくわかってない。
多分、filterを掛けてmap処理してるのがイメージなのかな。非同期が最大の敵。
db.serialize()の外での取り扱いにしなければならない。
あとはdb.closeはdb.serialize()に突っ込んでも同期化されないっぽいので注意する。おそらく、SELECT文専用だと思われるdb.each()は便利。
どこかでbreakできないので不便といわれているのも見たけれど。
(その時はdb.all()を使うといいみたい)とにかく冗長。
SQL文の入力と実行が必ず分離されるのがしんどい。
あとはSQLに値を与える方法としてパラメーターという方法があるけど、
かえって冗長になりそうだったので今回は使うのをやめた。かなり簡潔で書きやすいと思った。
SELECT文の返り値の処理だけは最初戸惑ったけど…
(普通にやってるとタプルが返ってくる
db.commit()はなぜか使わなくても大丈夫だった。もしかしたら一番シンプル。
唯一オブジェクト指向でない言語なので同時に複数のデータベースを開くことができないのがおそらく難点。SELECT文は受け取った値を自力でイテレーターを回す感じ。
(VBA,VBSのDir()とかが近いかもしれない)あとは「#cmpopt init 1」を使うとコケるのでそれは注意。


