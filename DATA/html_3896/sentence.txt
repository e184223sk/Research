More than 1 year has passed since last update.(2019/02/09 更新)
C# 8.0を試してみましたが上手くいきませんでした(´･ω･｀)(2019/02/10 更新)
tangoさんよりアドバイス頂き、async/await で非同期的にCドラ以下のファイルを取得にボタンがマウスホバーでない場合にボタンが非ブロッキング状態になるように教えて頂きましたので追記しました。ありがとうございます！(2019/02/14 更新)
パフォーマンス改善を追記しました。(自称)最強のファイル検索ソフトであるEveryThingを愛用しているわけですが、このソフトだとネットワークドライブのファイルまで見に行きたいいけない！！そうだ！ネットワークドライブまで見に行けるファイル検索をつくろう！！！
んでもって、画面が固まらないように！！そして途中キャンセルできるようにしよう！！！！そう考えて作ってみると思ったよりも格段に難しかったのでメモとして残しておきます。マサカリ大歓迎！そしてツール完成間近、EveryThing がネットワークドライブのファイルまで見に行けることを知る事となるとはこの時、知る由もなかった。。。書いてみたら意外と長くなってしまったので、最初に結論というか最終成果物。
同期処理での記述から始めて、最終的にこれらの条件を満たしていくようにしていきます。C#ではDirectoryクラスにファイル列挙メソッドが用意されています。え、これだけでネットワークパスまでファイル取りに行ける！楽勝じゃん！
実際に上記を実行してみると
「C:\$Recycle.Bin\S-1-5-18」てなんぞ。
なんか知らんけど、存在しないフォルダにアクセスしようとしてみただけなのか？

ほう？

ほうほう…。
なにやら、Directory.EnumerateFilesメソッドでアクセス権限のないシステムフォルダなどを覗き見ようとした際にこのようになってしまうようだ。どうしたものか。キータ内でそれっぽい記事があったので拝借します。
【C#】ドライブ直下からのファイルリスト取得について検索元のディレクトリの指定「C:\」や「D:\」といったドライブ直下にした時、プログラムがコケるケースがあった。
原因は隠しフォルダの「RECYCLE.BIN」で、要は操作しているユーザのアクセス権が無いゴミ箱（他のユーザのゴミ箱だったりとか）を読み取ることができずに例外を吐いて死んでしまうことに気がついた。
これを回避するためには、再帰処理に読み取れなかった場合を考慮してちゃんとtry~catchしてあげればいいという単純なもの。ふむふむ、なるほどなるほど。
確かに再帰的にアクセスして例外が発生したものだけを無視すればよさそう。実際に測ってみた。また、計測にあたって明らかに不要かつどのPCにもありそうなフォルダに関しては検索段階で弾くようにする。
具体的には、以下のフィールド内のどれかにフォルダパスの接頭辞が該当した場合には検索対象外とした。Cドラ以下のファイルが無事に取得できる事は確認できました。
ただ私が作りたいのは、画面が固まらず、キャンセル可能なファイル取得です。
つまりこういういめーじ。上記のソースコードでいう、「1ファイル毎の～～」の部分を実現する為にIEnumerable型で取得してみました。また、計測するにあたって、以下の2パターンで計測してみます。まぁこんなもんだよね。
完全に蛇足だとは思いますが、念の為このメソッドを使ってUIを更新してみます。
はい、まあそらそうですね、、って感じの結果です。
全ての処理をシングルスレッドで行っているので画面は固まったまんまです。
Cドラ以下のファイルを全取得し終わるまでボタンも押せない。
ふつーに書いてたらまあこうなるよね。ここからようやく本題、非同期処理で画面を更新させていきます。
サクッと非同期にする。async voidはイベントハンドラにだけ許された特権( ˘ω˘)
やったー＼(^o^)／
これで非同期的にCドラ以下のファイルが取得出来たミッションコンプリート＼(^o^)／
…………
……………………
………………………
お気付きだろうか。
マウスカーソルがボタンから離れていてもマウスオーバー状態と変わらない事に……！
Task.Run内の処理は確かにスレッドプールに処理が投げられて晴れて非ブロッキング状態となりましたが、なぜかボタンがおせねぇ。ちょっと正直なところ、なんでこうなるのかは詳しくわかってないんですが非同期処理内で同期処理をしてしまっているのでになっているのだと考えています。Dispatcher.InvokeのオーバーロードにDispatcher.Priorityを受け取るものがありまして、これ、省略した場合はDispatcherPriority.Send(最高優先度)で実行されるんですよ。
なので、引数を明示的に指定してあげてテキストボックスのレンダリングの優先度をBackground(4)にしてボタン入力(Input:5)よりも優先度を下げてやるとボタンが押せるようになるかも。というコメントを頂きました。
実際にこの通りでしたので、これ以降の非同期的にforeachをしてやらなくても大丈夫そうですね( ˘ω˘)非同期処理内で同期処理をしてしまっていることが原因だとすれば、どうすれば非ブロッキング状態にできるのか明白ですね。
非同期処理内で非同期処理をしてやればいいじゃん！！ということで、ファイル取得メソッドを非同期にしてみました。非同期処理内で非同期処理をさせる事でこれで思い通りの処理になるはずだぜﾋｬｯﾊｰ＼(＾o＾)／

なんてこったい／(^o^)＼
確かにボタンは非ブロッキング状態になったけど、ボタンを押しても何もおきねぇ／(^o^)＼～ 2分後 ～

動き出したけどこんどは画面全体がブロッキング状態になってる／(^o^)＼
これ、非同期処理内で同期処理させた時よりも状況がひどくなってる／(^o^)＼これまでの流れを整理する。このことから考えてもうこれしかないと思った。
Foreachは非同期処理を同期的にしか展開してくれねぇ説！！！！！！！じゃあやってやろうじゃないの、ForeachAsyncってやつをよ。
いつもお世話になってます、neueさん、拝借させて頂きます。
ForEachAsync - 非同期の列挙の方法 Part2さて、ここで書かれてある拡張メソッドをコピっとペッで作ります。
作ったうえで、このForeachAsyncを使えるようにファイル取得メソッドを作り変えます。それがコチラ。ForeachAsyncはIEnumerable&lt;T&gt;の拡張メソッドなので、元々Task&lt;IEnumerable&lt;string&gt;&gt;だったところを
更にIEnumerableで包んであげて IEnumerable&lt;ConfiguredTaskAwaitable&lt;IEnumerable&lt;string&gt;&gt;&gt;型へと進化しました！！！！はい、じゃあ後は実行するだけ。
ちゃんとタスクにCancellationTokenを渡してThrowIfCancellationRequestedメソッド使って例外投げるだけでおｋ。おけまる。
これが……これが、やりたかった！！！！！
ということで、予想していたForeachは非同期処理を同期的にしか展開してくれねぇ説！はまあ大方合っていたのかな？
多分。さてさてさーて、欲しいものはできた。が、実際に上記のコードを動かしてみた方は分かると思いますが、パフォーマンスが死ぬ程わるい！！！！
比較してみた。比較条件ね、遅いよね。
この遅くなり方は何か致命的なミスをしているはず…。色々試していたら一個気付いた。
AsParallel邪魔なんじゃね！！！！！？？？？？AsParallelメソッドを使用した場合がどちらも遅い。というか絶望的に遅い。
もしかして、並列処理実行時に例外が発生した場合ってかなりコストがかかってる感じですか…？
とりあえず一つはAsParallelメソッドを使用しない事で大幅に上がりそう。（前に計測した時は倍速だった気が…。）幾つかのサイトを流し見していると何回かチラ見するこのTaskCreationOptions.LongRunningというやつ。
なんか明らかに長い時間タスクを実行するときに付けたほうがよさそうな名前。TaskCreationOptions
タスクの作成および実行に関するオプションの動作を制御するフラグふむ。詳しくはTaskCreationOptions Enum を参照してください。とりあえずやってみた。ほぼ誤差の範囲っぽい。このサイトに少し詳しく書いてあります。
タスク並列ライブラリ入門記-006 (TaskCreationOptions.LongRunning, 長時間実行されるタスクであることを示すオプション, オーバーサブスクリプション) 
スレッドの切り替えにかかる時間が若干軽減する、かも！？ぐらいな感じでしょうか。新ステージ、ForeachAsyncで更なる高みへで非同期なforeachを作った訳ですが、中身をちゃんと見るとSemaphoreSlimが使用されています。SemaphoreSlimについては以下の記事がとてもわかりやすいです。
たがわ製作所ブログ - 非同期処理におけるセマフォを用いた排他制御まあ要は、Taskの最大同時実行数に制限を掛けているわけなんですが、今回はCドライブ以下のファイルパスを根こそぎ持ってくるだけなので特に処理順序なんて必要ないですし求められているのはメモリをぶん殴ってでも速度が欲しい訳です。じゃあどうするか？SemaphoreSlimを消し去ってやればいいじゃない。1割程度は改善した感じ？
ちな、ForEachAsyncNoLockは後述するUI描画時のパフォーマンスにめちゃ役に立ちます。ロジック面で思いつくことは粗方やれたかな、と思います。
なので次はファイルパス取得 + UIへの描画に掛かる時間を図ります。
んで今更なんですが、非同期処理実行時にはDispatcherPriority.Backgroundを指定してあげないとフォームの移動とかさせられないですね。。さっそく計測してみる。えっ
実行上限数が設定されてないForEachAsyncNoLockの方が遅い。この結果を受けて考えました。なぜ、ForEachAsyncNoLockの方が遅いのか、と。
そこで一つの可能性として、UIスレッドの実行権限取得時に競合的な何かが起きているのでは？と考えました。どういうことかというとForEachAsyncに対してForEachAsyncNoLockの方が同時実行タスク数が多くなる可能性があり、UIを更新できるのはUIスレッドからのみ、という前提から考えればUIスレッドを奪い合う頻度の高いForEachAsyncNoLockの方が遅くなって当然なのかなと一旦理解しました。そこでふと、InvokeAsyncメソッドがあることを思い出し、これを使えば競合なくきちんと待ってからUIスレッドを効率的にタスクスケジュールしてくれるのでは？と考えて計測してみました。正直、草生えました。

結局、非同期処理をやりたいのって「ちゃんと処理してるんだぜなう」みたいなアピールが出来てればよくて、進捗状況まで律義に待ってやる必要なんてないですね。そういう理由でInvokeAsyncを意図的に同期処理させています。実行時間に若干のムラはありますが、思ったより納得いく所までパフォーマンスを上げられました。暫定版。C# 8.0 Async streams
実装されるみたいです！！気が向けば、VS2019をインストールして、追記しますね( ˘ω˘)追記 (2019/02/09)
非同期foreachを試してみましたが…。
うん、動かん。( ˘ω˘)
正式リリースを待つとします…。Cドラ以下のファイルパスを取得したかったというよりも、その過程での非同期処理の勉強の為にこういうことをやっていました。
なんとなくで非同期処理を書けてしまう、、それはそれでよい事ですがちゃんと理解してコーディングしたいですよね。
今回の記事を書くにあたって、非常に参考にさせて頂いたサイトを紹介して〆たいと思います。


