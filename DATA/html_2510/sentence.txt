More than 1 year has passed since last update.この記事は非常にニッチなケースだということを予めお伝えしておきます。例えばこのようなクラスがあります。このクラスを継承したクラス一覧を配列などで管理しようとしたことはありませんか？
そこで特に意識せずタイピングするとこうしたくなります。そして思います。
あれ？ちょっと待ってTは何？どこで決まるの？
変数でwhere使えない！そうです、Generic型の制約を持つGenericクラスを配列などで管理しようとするとできません。
これはそんな状況をどうやって解決するかについての記事になります。答えを最初に言ってしまうと、interfaceを使って解決します。
それでは実装を見てみましょう。何らかのFramework上のクラスです。
外部の何かかもしれませんし、自社製の何かかもしれません。
とりあえず自分では触れることができない前提です。こちらが実際の管理クラスになります。
Frameworkではなく、IHogeをベースとして管理しています。
使用しているのはDictionaryですが、Listなどでも一緒です。呼び出し側では、管理に扱っている何らかのパラメータを渡して制御する対象を変えます。
今回の例ではクラスの型を管理パラメータとして扱っています。本当はFramework&lt;THoge&gt;, IHogeの両方を継承してる基底クラスを一つ作って起き、管理対象となるクラスはそれを継承する方が良さそうですが、そうじゃない(HogeOtherのような)ケースも実際にはあったのでこのような作りになっています。基底クラスをにすれば良くね？と思われるかもしれませんが、その場合さらに基底にあるFrameworkが参照するTが、すべてHogeBaseになってしまいます。
最上層の型を対象とした何らかの処理がある場合にはそれだと都合が悪い場合があります。ExecuteFrameworkFunctionの制約は where THoge : IHoge だけだとダメです。
利用側で hogeManager.ExecuteFrameworkFunction&lt;IHoge&gt;(); とすることができてしまいます。例えば複数のウィンドウを管理するクラスがこのような作りだったとして、各ウィンドウから管理中のいずれかのウィンドウを呼び出す、といった場合に使える可能性があります。
例えばウィンドウを生成したり、前面に出したり、値を受け渡したり、そんな感じです。冒頭でもお伝えした通り、非常に稀なケースですが、やりたくなる場合があるかもしれません。
その時にこの記事を思い出して、それが少しでもお役に立てれば幸いです。


