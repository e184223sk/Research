More than 1 year has passed since last update.本投稿は10年以上前のブログ記事が元になっているため、技術の情報が古いです。ご注意ください作ったETロボコンシミュレーターが動いている様子はこれです。(注意：BGMつきの動画が開きます）12年前の自分がもっているスキルをフル動員してフルスクラッチでETロボコン(RCX時代)のPCシミュレーターを作りました。【技術】【シミュレータースペック】 UMLでロボットのソフトウェアを設計して戦うロボコンがあるという話を、同じプロジェクトの仲間のN女史から聞いた。
彼女の所属会社でETロボコンに参加するチームがあるということで、そのチームの仲間に入れてもらうことになった。ROBO-ONEなど、ロボコンには何度か参加したことはあったがUMLでロボットのソフト設計を競うというのは個人的に思いもよらなかった面白い視点。私が出場していたロボコンではたいていメカとか回路まわりに苦戦して、ソフトももちろん書くけど、ソフトの中身のつくりで勝負しようとは思っていませんでした。でも、このロボコンはソフトウェアの設計にフォーカスしているらしい。ロボットもソフトも好きな人間としてはとっても興味がわく。ロボコンの名前は「ETロボコン」と呼ばれている。古くは、ETソフトウェアデザインロボコンと呼んでいたそう。このロボコンの面白いところは、本来ロボコンの主役となるはずのロボットがあらかじめ規定されているということ。Webサイト http://www.etrobo.jp/その規定されているロボットというのがLEGO Mindstormで作ったパスファインダーと呼ばれる走行ロボット。LEGOでできた機構部分だけでなく、モーター、センサー、からマイコン、それらをつなぐ回路などまで、出場者みんなが同じ機体を使う。「何で勝敗・優劣を決めるのか？」機体が一緒なんだから、「当然、勝敗はソフトウェアで決まります。」ということだそう。勝敗、優劣の判定基準は大きく分けると、 ソフトウェアのモデルで競う、レースのタイムで競う、の２つの側面がある。参加にあたり、こんなコンセプトをたてた■モデル評価重視型アプローチ(1)アーキテクチャ方針
　・内部および外部品質特性を明示的にアピールできるようにする。→ISO9126の１つ１つに
すべてロジカルに答えられるようにする。　・アーキテクチャと品質特性の因果を明示したい。→○○を達成したいから、ここはこう
なっているという説明ができるように。(2)分析・設計
　・プロダクトライン（コアと変動性の層別）分析設計をやってみたい。→コアと変動部分の分析、例えば次回ルールが変わりそうなところはどこ？　・カタリシスによるコンポ分析をやってみたい。■タイムアタック重視型アプローチ(3)制御アルゴリズム
　・PID制御をきちっとSWで実装する。＆それをOOで設計する。
　・自機の相対ポジションを保持する。　→モータ電圧とステアリングと経過時間から計算
可能？
　・フィードフォワード制御をする。　→あらかじめすべての通路情報をインプットしてお
く。
　・シャトル多数決システムの採用　→同一アルゴリズムを意味的に異なる設計で多重につ
くり、多数決値を制御につかうスペースシャトル方式を使う。
　・学習システム搭載　→GA,強化学習,ニューラルネットとか。(4)シミュレーション
　・シミュレータを作成し、最適アルゴリズムを探す。(1)外乱に強いつくりにする
　　→光量の情報なども瞬間値でなく積分値、加重平均でとるなどの工夫。(2)実機の操作には薄いラッパーをはさむ。直接APIをたたかない。
　　→シミュレータも同じインタフェースで実装しておけば実機とシミュで同じ制御ロジックを使いまわせるでしょ。(3)タッチセンサーを活用する。チームは私ふくめて4人。チームといっても、それぞれのプロジェクトがあるので、ほとんど集まれないので
主担当をきめて、それぞれが自宅で各自進めるということになった。他のメンバーは所属会社のお金で実機を買ってもらっていた。彼らは業務としてロボコンに参加できるのだが、
私は所属会社もプロジェクトも違うので実機（パスファインダー）を持っていなかった。もちろん業務としての参加ではなかったので、
実機のアルゴを試せるシミュレーターを開発する役割を買って出た。うまくいくか不明だが、　最適アルゴリズムを探す　というミッションのもとシミュレーターを開発することにした。こんなステップでシミュレータをつくる。期間内にベストエフォートで。目的にあわせて、どのレベルの正確さを求めるか、が物理シミュレーター作りのポイント。STEP2:通称：LV2
少し動力学、運動学をいれてみる。各種パラメータ（たとえば慣性モーメントとか、テンソルとか）は物性値から計算してみる。2次元、3自由度（X,Y,yaw）の車両のシミュレーション。実時間シミュレーションの離散化はルンゲクッタで。 STEP3:通称：LV3
3次元、6自由度の運動シミュレーション。ぜんぶ自作プログラミングだと厳しいかも。まっとうな物理エンジンとか、最低でもMATLABくらいは使いたい。 実装よりにシミュレータへの要望を整理してみると、こんな感じWindowsプラットフォームで動作すること
みんなのPCがWindowsだから。昔つくった3Dライブラリあるので、DirectXつかう。今後のSTEP2,STEP3への物理計算拡張を考慮した設計とすること
物理計算処理も階層化したほうがよさそう。ソルバー単位になるかな。物理計算エンジン部分を取替え可能に設計すること
物理計算と描画の境界線は意識しましょう。学生の頃、物理計算用のPG組んだとき、これを混ぜて痛い目を見た。後から描画処理を追加するときに、計算処理に手をいれたくなるもの。パスファインダーをパーツのアセンブリとして表現すること
将来パスファインダーを構成する部品が変わってもいいように。3Dグラフィックスへの対応を考慮した設計とすること
いずれ3Dにも対応させたいので、スケール感をもって、2Dの計算をさせたほうが良い。複数台のパスファインダーの同時シミュレーションに対応すること
複数でアルゴリズム対決みたいなのをシミュレータ上でできたら楽しそう。C++で記述されたパスファインダー制御コードと連携できること
パスファインダーの制御コードはC++なので、薄いWrapperをかませるような使い方を想定します。もう少しイメージをふくらませてとりあえず、STEP1では以下のようなものを再現してみる。動きの再現
直進、バック
ステアリングによる旋回（円旋回） 動きの原因の再現
トラクションモーター
ステアリングモーターSTEP1では、パスファインダーの寸法をマニュアルで測る。
それにしても資料をさがしてもどこにも寸法が書いていないというのは不思議こんな計測方法なので精度がまったく保証されない。
しかし、物理シミュレーションのアバウトさ加減を考えると1mm,2mmずれてもどうってことは無い。実機の速度を測定する実験を行う。目的
プログラム内でのトラクションモータ制御値とパスファインダー（実機）の速度の関係を調査する。実験方法
一定距離の直線を走行させて、走破時間をストップウォッチで計測する。実験結果を以下に示す考察負荷トルクを無視できる、制御量がある程度大きいときには上式で近似する。ステアリング性能をみるため、ある角度にステアリングをきったまま同一速度で旋回運動をさせる実験をする。目的
舵角δと旋回半径Rの関係を調査すること実験方法
舵角と速度を固定し、定常円旋回運動をさせ、パスファインダーの走行軌跡を調べる 走行させたものを固定カメラで録画し画像解析して定常円旋回性能をしることができた。
下の図はステアリングを40°に固定したときの軌跡。きれいな円を描いている。**走行軌道より旋回半径旋回半径が判明上式よりAはスタビリティファクタとなる。実験結果を(2)式に代入ここでであるので パスファインダーは オーバーステア（OS) の特性をもった車両ということになる。目的
プログラムから指示する制御値に対するステアリングの回転数（角速度）の導出。
LEGOモータの定格とステアリングに力を伝達するギア比から計算してもいいが、結局のところ慣性モーメントその他の影響を考慮すると実際にタイアを地面につけたまま、制御の末端であるステアリングの回転数をはかったほうがより現実的だろうという判断をした。実験
ステアリングが90°回転するまでの所用時間を計測した実験データを対数近似でフィットさせた以下の式をステアリング角速度の計算に用いるx:制御値 (17～255)制御値&lt;16の場合、
まったく動作しない(モータ＋ギアのトルクが摩擦にまけて動かない）以下の２つについて計測する以前計測したものを、計算用の簡易寸法にしたこれまで導出してきたパスファインダー自身の動作に関する計算式の類を備忘録もかねてまとめておくパスファインダーの定常円旋回半径計算式よりある時間t1における舵角（ステアリングの角度)をδ1とすると、そこからΔt秒進んだ時間t2(=t1+Δt)における舵角δ2は以下のようになるここでなので、これをに代入するととなり、定常円旋回半径RはCstとCtrと経過時間Δtの関数として計算することができるここでは設計指針、機能要求、非機能要求、を要求と呼ぶことにして、再度やりたいことをまとめた。以下のような感じ1.Windowsプラットフォームで動作すること2.今後のSTEP2,STEP3への物理計算拡張を考慮した設計とすること3.物理計算エンジン部分を取替え可能に設計すること4.パスファインダーをパーツのアセンブリとして表現すること5.3Dグラフィックスへの対応を考慮した設計とすること6.複数台のパスファインダーの同時シミュレーションに対応すること7.C++で記述されたパスファインダー制御コードと連携できること8.新しい技術ネタを取り入れること
やるからには単なるソフトの設計作業でなくて、何か新しいことSomething Newが欲しい。9.とにかく動くこと
2007年のゴールデンウィーク中に動くものを作る10.見た目（も）重視
シミュレータでインパクトを与えるのも目的。見た目もダサくならないように注意。アーキテクチャとはソフトウェア構造のラフスケッチ、要求からラフスケッチをおこす責務Algorithm
パスファインダーのアルゴリズムを担当。シミュレータとは物理的にも完全に分離する。シミュレータに対するクライアントになる。シミュレータをCOMで作ってしまうのもありだ。Wrapper
スクラッチで作るので、実質インタフェースを定義して、インタフェースに対して実装しようねと言っている。Simulator
COMではなくて、.NETライブラリで実装する。実装レイヤーに近いほど覚えた知識があっというまに使えなくなる、時代の流れは早い。Draw
画面への描画を担当。RCX Simulatorと密接に関わる。要求から、アーキテクチャをすこし詳細化する。実装に入りたいので、もうパッケージを意識する□内の数字はアーキテクチャに対応する、要求番号となる2.今後のSTEP2,STEP3への物理計算拡張を考慮した設計とする3.物理計算エンジン部分を取替え可能に設計する
2と3はパスファインダーと物理計算の分離および、物理計算と外部環境（たとえばコースとのインタファクション）との分離を意識して設計せよ、ということになる4.パスファインダーをパーツのアセンブリとして表現すること
パスファインダーの形状は毎年変わるかもしれないので、パーツ（たとえば１つのLEGOブロック）を組んでパスファインダーの形状を再現できるように設計しておく必要がある。ルールが変わってもいいように、違う形状のパスファインダーを同時に走らせるなんてこともやりたい。5.3Dグラフィックスへの対応を考慮した設計とすること
パスファインダーを描画するグラフィックはとりあえず2Dで作るが、3Dでも使えるように設計しておく。つまり2Dでも3Dでも同じ操作体系で使えるように設計せよ、との方針になる。Factory MethodとかTemplate Methodとか「サブクラスさんおまかせ」系のデザパタがつかえる。6.複数台のパスファインダーの同時シミュレーションに対応すること
PathFinderクラスをnewしてaddして大量生産できるよに設計する。OOP的にはあたりまえかもしれないが、最初に考えておかないと苦労する「あるある」ポイント。二十歳そこらの頃、robo-one用のシミュレータを作ったときは、ここで泣いた（笑）もういちど考えを整理要求の整理Visual C# ExpressとVisual C++ Expressをダウンロード・インストールする。
http://www.microsoft.com/japan/msdn/vstudio/express/default.aspxSQL Server Express サーバは不要。Webからインストールするが、数時間かかった。無償で使えるUMLツールJUDEを使わせていただいた。とっかかりはグラフィックから。１つ１つのグラフィックパーツとなる。 2Dのパッケージ名は数字からはじめられないのでMisawa2Dで。。。
.NETのSystem.Drawingと同じクラス名だとまぎらわしいのでPrefix、M2Dを使う。.NET Frameworkに依存しないように書いてみる。C#はJavaに少し似ているので、後でAppletにも移植してみようという野心あり。モデルベースで書いておけば、苦労せずにJavaに持っていけそう。複数パーツを組み合わせてPathFinderを構成するクラスとなる。PathFinderの形状は今のところ１つだけ。3日かけてGraphicパッケージ（とその周辺）の0版実装が終わった。こんな感じモデルベースといいつつも、コードそのまま流用ももくろむ。こんな感じ。デフォルメされたパスファインダーが動いたC#でもGenericタイプが使えるようになった。Javaよりやや遅れて。コレクションではわかりやすくその恩恵にあやかることができる。型パラメータとしてM2DVertexを指定するので、このListはM2DVertex用のリストということになる。いちいちキャストしなくて済むのでとっても便利。パスファインダー、コース、論理的なモーターなどを設計すると最初はこうしたが、無意味に一般化してもしょうがないので、下のような現実案とすることにする。またSensorは分け合って独立事象にした。あとでC++用にさらにWrapperをかぶせる予定なので、あまりしつこい設計にしたくないというのが今回の現実案の理由となる。さらに、パスファインダーの動作を計算する運動学用（切り替え可能）のクラスを追加した。切り替え可能だが現状ではAggregateではなくNavigate扱いにしておく。設計をややこしくしたくないので、物理計算を切り替えたいときはこのクラスのサブクラスをつくっていって、PathFinderからつかうときは、クラス名そのものを書き換えることにする。
ModelBaseのModelは物理モデルを意識している。delegateを使ってトリッキーな継承をやってみた。
従来のC++ではオブジェクトを作ってから、メソッドの関数ポインタを取得してきて、それを使用側であてがって使ったりしたところが、delegateと親クラスをあらわすbaseの柔軟性により１つにまとめて書いた。実装したところの修正をかけていて、クラス図の修正をしたグラフィックパーツはそれぞれ子要素をもっており１つのモデルをくみ上げるときには複数のグラフィックパーツの親子関係を設定してツリーを作っていく。つまり、再帰的にツリーを構成していく部分(build())をcompositeパターンとして実現しているので、クラス図に少し補足をいれた。赤い点が旋回中心、円が定常円旋回軌道となる。ステアリングの角度に対して定常円旋回計算式は正常に動作した模様。
最後はステアリングの限界舵角を超えているので、旋回円は無効となる。物理シミュレーションを行うときには、必ず物理方程式の離散化を考えるが、今回は軽量シミュレータなので、運動方程式といっても一階微分方程式くらいのもの。微分方程式は、漸化式による差分方程式を作ってシミュレーションするが、ここで注意しなくてはならないのは、位置を更新する際の経過時間Δtとなる。一般にΔtは小さいほど精度良くシミュレーションできるがこのシミュレータでは、パスファインダーに入るセンサー情報のサンプリング周期とΔtを同期させている為、なるべくΔtはシミュレータのサンプリング周期にあわせたい。Δtが100msecとか、あんまり大きいとまずいなと思い実機でサンプリング周期をはかってみたところ5msecであった。
最高速度500mm/s程度のスケール感なら、まあいいかということで、Δtを5msecとした。あとはこの状態でシミュレーションをして実機との挙動があまりに違っていたらΔtの長さの変更や、Δtとシミュレータのサンプリング周期の同期をやめるなどの判断をしていきたい。最後は現物あわせコースは1mmにつき1pixelとして取り扱う。つまり1m×1mだと1000pixel x 1000pixelのコース画像を用意する。パスファインダーの先端部分にある光センサーの座標を計算し、その座標に対応するコース画像上の1pixel x 1pixelの色情報を取得して、LightSensorの値にセットするというシンプルなロジック。シミュレータ部分のコーディングはひとまず終わり。
リバースかけてみると。C++でパスファインダーに搭載するプログラムを意識して、プログラミングをしていく。
C++といっても.NET2.0のC++はちょっと違うので「H8用のコテコテのC++とVisual C++で同じコード使いたい」ときには色々と注しないといけない。こういうところが面白い。.NET Framework 2.0 のC++はC++/CLIに準拠していて、今までのC++とは文法の記法が違うところもあり注意が必要。.NET1.1から.NET2.0（C++/CLI)でポインタが*から^になったのにはちょっと驚いた。ほかにも、Visual C++ 6.0時代はnmakeでmakefileベースでビルドできたのに、VC2005みてたらどうやらMSBuildというツールに変わった模様。Apache ANTっぽい感じになっている。.NET時代のc++はUnmanagedとManagedの２つがあるが、C#でつくってきたシミュレータライブラリ(SimEtrLib.dllという名前にした)がこれをManagedなライブラリとしたので、C++もManaged C++を使う。また、C++/cliで導入された構文でなくて、C++の構文を使わないとパスファインダーのコードと連携ができなさそうなので、構文はC++を使う.NET Framework 2.0のManagedなコンパイラでは、デフォルトでC++/CLIとなっているので、オプションで古い構文(OldSyntax)を指定してやる必要がある。コード例は、イメージをつかむために掲載する。ヘッダ読めばわかるところなどは省略。走行アルゴリズム部分(RunningLogic)のコード
これはH8用のBrickOS APIのシグネチャを真似て作ったもので、これを使ってH8側とWindows側でアルゴリズム部分のソースコードを同一のものにすることができる。※クラスをnewするときの_gcキーワードは、ガベージコレクションの対象とするオブジェクトですよということを宣言している。そのため、オブジェクトを破棄するときに明示的にdeleteする必要は無い。シミュレータ部分のコード
PathFinderオブジェクトをCreateして、SimulatorPlatformにAddすると、コース上にパスファインダーが出現する。
何台でもCreateしてAddできる。
RunningLogicクラスでは、LightSensorの値（コースの白黒値）を読んで、TractionMotorやSteeringMotorを制御する。方向を変えて２台で。カラフルに4台で。にぎやか。これでシミュレータV1.0は完成
あとは、本番コースの画像で、ちゃんとしたシミュレーションロジックでシミュレーションをまわしてみる。5460mm×3640mm ETロボコンのサイトからコースのＰＤＦをダウンロードするETロボコン事務局から配布されるPDFをみてみると、なので、これは実際の縦横それぞれ1/2スケールになっている。シミュレータでは1mmあたり1pixelのコース画像を使う（ことにしました）のでこのＰＤＦ(2730mm x 1820mm)を5460pixel x 3640pixel　の画像に変換する。PostScriptオペレーションの定番GhostScriptをつかうと、PDFをPNG形式の画像に変換することができる。PNGファイルはサイズが10318 x 6879 ある。これは96DPIを指定したからなので、こうなっているが、これはGIMPで補完圧縮をし、さらに簡単なスクリプトを書いて変な色になっていた部分を変換して使えそうなコース画像を作った。最終的に 5260 x 3640 の画像となる。2007 ゴールデンウィークを使って開発したシミュレータ＋サンプルコードを同じチームのメンバーに初公開しましました。評判はまずまずで、最低限の役目は果たせたような気がする。本番コースでシミュレーションしてみた。2台で併走。全体像ちゃんと動いているようでひと安心。友人(工学博士、物理シミュレーション、運動学)にこのページ+ソースコードを見せて運動学の計算について読んでもらいましたが、当然いろいろとダメだしが。方程式、離散化、剛体か質点か、厳密にやろうとするといろいろ問題が。アカデミック軸ではなく、「モドキ」軸ということで貴重な意見を今後の改善に生かすとして今回はこのまま行こうということに。もともと3Dへの対応を考慮して設計していたので、特に今までの設計と変更はなし。Misawa2Dというのに加えてMisawa3Dというパッケージにする。3Dの実現には、Windowsのゲーム用APIのDirect3Dを使用する。
OpenGLでも良かったが昔作ったコードを流用したかったのでDirect3Dを使うことに。設計の構想は2Dのときとほぼ同じ。3Dのモデルは3Dモデラー(LightWave)を使ってモデリングする。Direct3Dを用いて実装を開始。LDRAWの3Dデータを組み合わせてログラムから操作できる3Dデータにする。3Dのプログラミングは純粋に楽しい。
過去のETロボコンのサイトを見ていたら、コース上にモアイのような置物がおいてあったのでLightWave3Dをつかってモアイ君をモデリングした。モアイ君をSimulator3D上に配置してグリグリ動かしてみた。せっかくモデリングしたのでどこかでこのモアイ君を使いたいなぁ。本番用のコースを印刷したものを会議室にならべてこれから実機を走行させてみた。数十枚を並べる作業はかなり手間がかかる。
1枚ならべると隣がずれたり、ずれを修正しているとまたほかがずれたり。やはり現実の世界は何かと”リアル”な問題が起こる。
これが楽しい。↓ようやくしきつめた、でもパスファインダーが走行するたびにズレる(笑)シミュレータで基本ロジックは確認したものの、結局現実世界へのあわせこみは実機を使ってTry&amp;Errorしかない。実機にプログラムを焼いちゃ消し、焼いちゃ消しという作業に明け暮れた。組み込み界隈ではよく見る光景。実機が動くと楽しいので、深夜までTry&amp;Errorは続く。計算モジュール(Misawat.Etrobo.Kinematics)と3Dの表示モジュール(Misawat.Graphics.Misawa3D)を連携させた。裏で物理演算モジュールが、コースの計算をしている。
3D上では、パスファインダーの代わりにモアイ君を走行させてみた。モアイがんばれ簡単に書くと、LDRAWにあるパスファインダーは頂点数が多すぎて使い物にならない(HAL使っても超ノロノロ描画)ことが判明。LightWaveでブーリアンを駆使して足し算引き算、その後、オリジナルスクリプトで面の向きをすべて外向きにし、そとから見えないところを削除し、頂点を減らして、くっつけて、構成しているパーツから重なっている面をとりのぞいて、、、と全部で３０ステップくらいフィルターをかましてやっと、プログラムからリアルタイムでレンダリングできる3Dモデルに変換できた3Dモデルを作ったので、モアイ君を卒業して、3Dモデル化したパスファインダーのタイアに差し替える。
タイアが転がった～。3Dモデルは以下のような親子のツリー構造になっている。パスファインダーはBody(本体部分＝ＲＣＸと機構部）,FrontWheel（前輪）,RearWheel(後輪),LightSensor(光センサーと機構部)をそれぞれ独立したパーツとした。2Dのときは、とても簡単なモデルだったので、頂点座標を計測して、それらを結んで多角形をつくってパスファインダーの外形にしたが、3Dでは構造がとても複雑なので、もっと大きな単位（たとえばBodyだけでも数千のポリゴンがある)で扱った。↑FrontWheelはLightSensorの回転と連動するので、LightSensorの子になっている。親子関係をつけた状態でパーツごとに適当に動かす。ちゃんとそれぞれ連携して動いている。前輪と後輪を速度から計算して回転させる、ここのロジックは単純で、なので、より計算するパスファインダーを、本番コースをセットしたシミュレータ上で実際に走らせて見た。
やはり、2Dよりも、モアイ君よりリアリティある3Dシミュレータのよい点は、簡単に好きなところにカメラを持ってこられる点これでカメラワーク演出が可能となるズームIN/OUTや固定視点、可動視点などいろいろと実装した。移動追跡カメラ固定カメラ車載カメラを搭載したどこに載せてもいいが(パラメータを変えるだけなので）、リアルでは不可能そうな場所ということで、光センターの後方の本体部につけてみた。もし実際ここにカメラがついていたら、こんなに左右にゆさぶられるものだった。めがまわりそー。でも走るレゴに乗った気分は楽しめる3Dで遊びすぎていてソフトウェアの設計そのものをないがしろにしつつあったが、、設計変更した。というか、実装してみてしっくりこなかったので、修正をかけてみた。よくありがちな、設計書のメンテナンス放棄ということに陥らないように常に設計書(JUDE)をふりかえるようにしたいクラスの意味も説明せずにやぶからぼうにBefore Afterだけを掲載しておくと、、、設計変更前
設計変更後
設計とソースコードは、連動しないもの。。。リバースしたものがこちら。レビュー不足。M3DFormは専用3Dウィンドウを出そうと思いつきで作ったが、これも使わないことにしたんだった、、、ということも忘れていた。リバースをして確認というのは、このレベルでも役に立つなぁ。ネットで本番のETロボコンの写真などをみていると、コース上にオブジェ（障害物？）がおいてある模様。非機能要件ということで、3Dシミュレータ上に、オブジェを配置できるようにしようかと。スケールをあわせながら3Dモデラーでモデリングしたスタート、中間ゲートにつかうポール
スフィンクス
ピサの斜塔（テクスチャあり）
ピラミッド（テクスチャあり）
凱旋門（テクスチャあり）
モアイ君 （テクスチャあり）
テクスチャ（3Dモデルの表面に貼り付ける画像）があると、質感がでてリアルになる。オブジェを配置できるようにするために、設計変更をしました。SimulatorPlatform3D#AddGadgetメソッドでオブジェを追加できるようになった。コース上にオブジェを配置した。ここまでプログラムが出来てくると箱庭をつくっているような感覚で楽しい。モアイ君も自分の居場所をみつけた。
モアイ君に石模様のテクスチャをつけたらちょっと怖かったので、テクスチャはつけないことにした。完全3Dプログラミング遊びになってきたが楽しいのでやめられない。箱庭コースの中を疾走！それぞれのパスファインダーの車載カメラ視点で走行させてみた。いよいよ明日が本番。
本番とは関東地区予選大会 第1日目のこと。まだ予選。シミュレーターを使ったアルゴリズム確認は各メンバーで行ってだいぶいい感じの動きをしていたとのフィードバックをもらう。ETロボコンの関東地区予選会第１日目に参加した日時 2007年6月30日(土) 8:50- 
場所 工学院大学（新宿)いよいよ本番コースでの、試走となる
別チームのパスファインダーが高速に追い抜いていたりするが、うちはうちの走りができればOK試走終了後、車検を行う。車検では、パスファインダーが設計図通りくみ上げられているか、不正改造が無いかなどがチェックされる。
車検に合格すると、競技時に使用する電池(Panasonic製)をもらうことができる。またもや、あるあるな解決法一安心してソフトウェアを書き込み1週目後半、悪夢が。。。突然のコースアウト。その後、道無き道を迷走して、谷底に落下という末路をたどることに。
司会の方は「あららー落下しちゃいましたね～」 パスファインダーを持って唖然としている仲間達。無念！後で分析したところ、ざっくりいうと、電池が強すぎたみたい。
(われわれが使っていた電池が弱かったみたい）KeepProblemBrickOSWrapper.h
実機とシミュレータでこのインタフェースを共通化してつかうRunningMethodManager.cpp
走行ロジックのマネージャRunningMethod_Normal.cpp*
状況ごとの走行ロジック（複数用意しても、１つでもＯＫ）シミュレータメイン(以前はフルソースコードを公開していましたが、10年以上前でビルドも通らない可能性があるので、需要があればまた公開検討します^^)


