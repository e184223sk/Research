More than 1 year has passed since last update.async/await による非同期処理に関する記事はたくさん存在していますが、うまくいかない結果からの逆引きスタイルの記事が見当たらなかったのでまとめてみました。Visual Studio から次のような警告が検出されます。この呼び出しを待たないため、現在のメソッドの実行は、呼び出しが完了するまで続行します。呼び出しの結果に 'await' 演算子を適用することを検討してください。実行してみると、HeavyActionAsync メソッドの終了を待たずに BtnHeavyAction_Click メソッドが終了していることが分かります。コンパイラがコーディングミスの可能性があると解釈するため。HeavyActionAsync メソッドの終了を待ちたいのであれば、警告の内容のとおり、await をつけます。BtnHeavyAction_Click メソッドには async をつけます。await 呼び出しを含むメソッドには async をつける必要があります。async はコンパイラに対して await 呼び出しを行うことを明示的に示すためのキーワードです。面倒だと感じることもありますが、コーディングミスを減らすためのものだと思います。HeavyActionAsync メソッドが終了してから BtnHeavyAction_Click メソッドが終了していることが分かります。HeavyActionAsync メソッドの戻り値である Task を変数で受け取るようにすると、コンパイラは呼び出しを待つ必要がないことが明示的に示されたと解釈し、警告として検出しなくなります。但し、この方法には HeavyActionAsync メソッドで例外が発生したときに呼び出し元でキャッチできないという問題があります。これについては後述します。実行結果は警告が表示されていたときと同じです。HeavyActionAsync メソッドの終了を待たずに BtnHeavyAction_Click メソッドが終了します。Task を返すメソッドが終了するまで待機しようとして Wait() を呼び出したとき、いつまでたってもそのメソッドが終了せずにアプリケーションがフリーズします。HeavyActionAsync メソッドが終了せず、アプリケーションがフリーズします。Task&lt;T&gt; を返すメソッドの場合、戻り値を Result で取得しようとしたところでフリーズします。HeavyFuncAsync メソッドが終了せず、アプリケーションがフリーズします。デッドロックが発生するため。Task.Wait() や Task.Result は Task が終わるまでスレッドをブロックします。その Task の内部で await 呼び出しを行っている場合、その呼び出しが終わるときに呼び出し元のスレッドに戻ろうとします。しかし、ブロックされているため戻ることができません。Task が終わらなくなり、フリーズします。前述のように await 呼び出しで待機しましょう。Task.Wait() や Task.Result は扱いが難しいです。この例のようなシンプルな非同期処理であればどのような結果になるかがわかりやすいですが、同時に複数の非同期処理が実行されるようなケースで安全にコントロールすることは難しいです。そもそも UI をブロックしないようにするために非同期処理を利用しているのに、その非同期処理が終わるまでブロックしてしまっては本末転倒です。HeavyActionAsync メソッドの内部の await 呼び出しに対して ConfigureAwait(false) をつけると、とりあえずフリーズすることは回避できます。ConfigureAwait(false) を簡単に説明すると、メソッドの終了後に呼び出し元に戻ってこなくてもよいということを指定します。ブロックされたスレッドに戻ろうとしなくなるため、HeavyActionAsync メソッドは終了し、BtnHeavyAction_Click メソッドに戻ってくるようになります。Task を返すメソッドを await をつけずに呼び出した場合、そのメソッド内で例外が発生しても呼び出し元でキャッチすることはできません。Visual Studio の出力コンソールには「例外がスローされました」と出力されますが、これはフレームワーク内部から出力されたものです。Task を用いた非同期処理では、発生した例外は一旦 Task で管理され、非同期処理が完了したときに呼び出し元へ排出される形でスローされます。await をつけない呼び出しでは Task から排出される機会がなくなり、結果的に例外は飲み込まれます。やはりこの場合も await 呼び出しを行いましょう。「この呼び出しを待たないため…」の警告を消す方法として Task を変数で受ける方法を紹介しましたが、Task には Wait, Result や IsComleted, IsFault など、タスクの完了を参照するメソッドやプロパティがあります。タスク内で例外が発生した場合、これらにアクセスしたタイミングで呼び出し元に例外が排出されます。catch 句の中で出力したデバッグメッセージが出力され、キャッチできていることが分かります。Wait や Result で完了を待っていた場合は、発生した例外が AggregateException にラップされてスローされます。これは Task クラスの仕様です。catch 句の中で出力したデバッグメッセージから、例外の型が AggregateException であることが分かります。発生した例外を取得するには、AggregateException の InnerExceptions を参照してください。非同期処理の中でコントロールにアクセスしたときに次のような例外がスローされます。有効ではないスレッド間の操作: コントロールが作成されたスレッド以外のスレッドからコントロール '' がアクセスされました。"HeavyActionAsync enter" は出力され、"HeavyActionAsync exit" は出力されていません。Task.Delay の後の btnHeavyAction.Enabled = true で例外が発生していることが分かります。例外メッセージの通り、フォームやコントロールは UI スレッド（≒アプリケーションのメインスレッド）以外からアクセスすることができません。この例では Task.Delay の呼び出しに対して ConfigureAwait(false) を指定しています。これがポイントです。Task.Delay の後は呼び出し元のスレッドには戻らずに別のスレッドで実行されますので、コントロールにアクセスすると例外が発生します。この例では ConfigureAwait(false) をつけなければ呼び出し元スレッドに戻りますので例外は発生しなくなります。ただ、複雑な非同期処理ではどのスレッドで実行されるかが分かりにくくなる場合があります。Control の InvokeRequired プロパティと Invoke メソッドを使用し、確実に UI スレッドで実行されるようにします。InvokeIfRequired メソッドを Control に対する拡張メソッドとして定義しておくと、簡潔に記述できるようになります。.NET Framework ではいくつかの非同期処理の仕組みが提供されています。.NET Framework 4.5 以降であれば、機能面や使い勝手から考えると async/await 一択になると思います。ただ、異なる仕組みを混在させると混乱のもとになります。もしあなたが関わっているプロジェクトで async/await 以外の仕組みで非同期処理を制御しており、それがプロジェクト標準ルールである場合、無理に async/await を使うことはお勧めしません。プロジェクトメンバーと十分に検討してください。インターネットなどの情報を参考にするとき、その説明に次のような型やメソッドが現れた場合は古い時代の仕組みである可能性が高いです。【Qiita】Taskを極めろ！async/await完全攻略
【Qiita】C# 今更ですが、await / async
【Qiita】C# Taskの待ちかた集
【SE（たぶん）の雑感記】async、awaitそしてTaskについて（非同期とは何なのか）
【kekyoの丼】できる！C#で非同期処理(Taskとasync-await)
【kekyoの丼】技術解説 – 非同期


