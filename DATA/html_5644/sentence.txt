More than 3 years have passed since last update.新年、あけましておめでとうございます！初投稿になります！皆様はじめまして、Rafkaと言います。
軽く自己紹介しますと、私は現在大学院生で、数値シミュレーションをやる研究室に所属しております。初めて触った言語はC#で、好きな言語もC#です。まぁ研究では使っていないんですけどね。最近LAPACKを触る機会があり、その時にその計算速度に感動したので、C#向けのパッケージとか無いかなと探したんですけど、LAPACKのコール名（getrfやgbtrs等）で呼び出せるものが見つからなかったので、自分でラッパーライブラリを作成しました。内部で使用しているライブラリは見つけたんですけどね。できれば同じような事をやりたい人に使ってもらいたいので、この記事では紹介も兼ねて、ライブラリの作成方法と作ったライブラリの使用例を書いていきます。この記事を纏めると以下の通りです。ラッピングの対象としたBLASやLAPACKの実装は、Intel® Math Kernel Library(Intel MKL)にしました。実行環境である私のマシンは以下の様な構成です。使用した環境はIDEはC++/CLI版を書く時はVisualStudio2017を、P/Invoke版を書く時はJetBrainsのRider2017.3を使用しました。Intelが自社製CPU向けに最適化したBLASやLAPACKの実装を含めた様々な数学ルーチンを含んだライブラリです。自分のとこのCPU向けに自前で最適化しているので、IntelのCPUで動かすならOpenBLASなどと比べて速いらしいです。どうせなら一番早くしたいので、今回のラッピングの対象にはMKLを選びました。MKLは以前は有料だったようですが、現在は無料で使用することが出来ます。一先ずココに飛んでもらえたら、ページの中央にFree Downloadっていうボタンが有ると思うのでそれを押してもらって、そこから先はページの案内通りにアカウントを登録した後にインストーラがダウンロード出来たと思います。
その後私の場合はPATHを通す必要がありました。システム環境変数に追記したのは以下の3つです。"~IntelSWTools"の部分は各々のインストールディレクトリに読み替えてください。MKLに限らず、C#からCやC++で作成されたネイティブコードを呼び出す方法は幾つかありますが、調べてパッとでてくるのは大体次の2つみたいです。せっかく呼び出し先のライブラリが高速なので、呼び出しのオーバーヘッドもなるべく少なくなるようにと思い、C++/CLIを用いてラッパーライブラリの作成を行いました。何しろ書いている時はMonoでも動くと思っていたので......基本的には、という方針でラッピングしていきました。
例として一般行列を倍精度でLU分解するdgetrf関数のラッピングを説明していきます。まず、MKLではlapack_int LAPACKE_dgetrf(int matrix_layout , lapack_int m , lapack_int n , double* a , lapack_int lda , lapack_int* ipiv);と宣言されています。引数はそれぞれ以下の様な意味です。int matrix_layoutはLAPACK_ROW_MAJORかLAPACK_COL_MAJORしか取り得ないので、こういうのは列挙体にした方がいいですね。以下の様な感じでラッピングしました。lapack_int m、lapack_int nやlapack_int ldaはそのままintで受け渡して大丈夫でしょう。因みにlapack_intは__int64で定義されており、__int64はlong longとなっているので、適切にラッピングするならlapack_intはlongが正しいと思います。
double* aは配列ですが、C#で普通に宣言するとdouble[] a(C++/CLIに渡すとarray&lt;double&gt; a)ですが、そのままでは渡せないので、ここでpin_ptr&lt;Type&gt;の出番です。pin_ptr&lt;double&gt; ptr_a = &amp;a[0]とすれば、配列aのGCによる回収を阻止して、ネイティブのポインタとして扱えるようになります。
最後にlapack_int* ipivですが、これはdgetrfの処理で初めて必要になる配列なので、できれば事前に宣言したりしないで使えたほうがいいと思いました。なぜなら(特にC#7.0以降なら)、と書くよりも、と書けたほうが便利じゃないですか？
ということでココまでを纏めた結果、ラッピングコードは以下のようになりました。こんな感じでラッピングを進めて、このC++/CLI版に関してはfloatとdoubleに限りますが、Level1~3のBLASとこのページのLAPACKの関数はラッピングが済んでおります。使用サンプルはココに書いてあります。ところで、上に書いたようにこのライブラリは、研究室のPCを使ってMonoで動かそうとした結果動かなかったので、P/Invokeを利用する方向でもラッピングをすることにしました。せっかく公式でオープンソース化、マルチプラットフォーム化が進んでいるC#なので、Windowsでしか使えないライブラリよりもLinuxやmacOSでも使えるライブラリのほうが良いともいました。色々方法を調べた結果、P/Invokeならどのプラットフォームでも大丈夫そうだったので、これを用いたライブラリも作ることにしました。こっちはLevel1~3のBLASとLAPACKの対称正定値帯行列向けのところまでのラッピングが済んでおります。それ以外にC++/CLI版と若干仕様が変わっており、floatとdoubleの使い分けをメソッド名ではなく、メソッドのオーバーロードで解決するようになっています。
例として、C++/CLI版でも示したgetrfは以下のようにラッピングしています。雑な説明になってしまい恐縮ですが、P/Invokeを利用するこちらのバージョンでは、研究室のLinux環境でも、我が家のWindowsの環境でも動作することが確認できました。無事にLinuxでも動作することが確認できたので、今後はこっちをメインに更新していこうと考えています。次の章で話す使用例も、P/Invoke版をメインに書いていきます。この章では実際に作成したライブラリの使用例と、BLASやLAPACKを利用することでどれぐらい速くなるかを、ベクトルの内積とポアソン方程式の求解を題材に調べたので、それらについて書いていきます。実行はRiderのデフォルトのReleaseの設定で行っています。私のラッパーでは、ddotは以下の文で呼び出せます。ここでnはベクトルの要素数で、xとyはベクトルを表す配列、incXとincYはそれぞれxとyのインクリメント幅を指定します。普通は1にします。これの比較対象となるC#のコードは以下のように書きました。これらを用いてそれぞれで計算速度を測定するプログラムを以下のように作成しました。このプログラムを、要素数を10・100・100000と変化させて実行した時の出力を以下に示します。表に纏めると以下の様な感じです。要素数が小さい内はラッピングのオーバーヘッドでBLASの方が遅くなっていますが、要素数が十分大きくなると効果がしっかり出ているようです。ポアソン方程式の詳細については省略させていただきます。LAPACKの速度を知るきっかけになった講義での課題だったので、ただ流用しやすかったというだけなんですけどね。ですのでこれから説明するプログラムには、ベースにしたプログラムがあります。さて、何においてもLAPACKの呼び出しと比較するためのC#のコードが必要です。ですのでLU分解を行うC#のコードを以下のように書きました。そして分解された行列を用いて方程式を解くプログラムを以下のように書きました。アルゴリズムを素直に実装しただけなので、あまり速度が出る書き方にはなっていないと思います。すみません。
一方LAPACKの呼び出しは、分解がで、解くのがです。これらは一般行列で利用できる関数なので、この他にも帯行列向けの解法と、対称正定値帯行列向けの解法も試しました。これらを用いてそれぞれの時間を測定するプログラムを以下のように作成しました。これを実際に実行した時の出力を以下に示します。表に纏めると以下の様な感じです。一応期待通りの速度がでているようで、満足です。
このベンチマークプログラムの全体はココにあります。いかがでしたでしょうか。思っていたより長い記事になってしまって、ここまで読んでいただいてありがとうございます。確かにC#から利用できるようになっていて、要素数が大きい行列やベクトルに対してはパフォーマンスが発揮できていると思います。ところでこういうライブラリってどの程度需要があるんでしょうかね。今後の開発の予定としては、というのを考えています。
他に現在の実装で気に入らない部分が幾つかありまして、1つ目については、例えばLinuxなら"libmkl_rt.so"なので、私が試した時は"mkl_rt.dll"の名前でシンボリックリンクを作成しました。後から調べてわかったのですが、DllImportのファイルパスはかなり柔軟に探索してもらえるらしいので、もしかしたらリンクを作成しなくてもうまくいくかもしれません？正月明けたら試してみようと思います。
2つ目については、一筋縄ではいかない気がしたので後回しにしているというのが現状です。できればC#に標準であるComplex構造体を利用したいのですが、メンバがfloatのものとdoubleの複素数構造体を用意して、それぞれにSystem.Numerics.Complex構造体へのキャスト演算子のオーバーロードを実装すれば行けるでしょうか。これもとりあえず試してみた方が良さそうですね。何にせよ自分にも需要があるので開発は続けていきます。もし「こういうの探してたんだよ～」って方が居ましたら是非使っていただいて、納得行くものでしたら嬉しいです。他にも「こういう書き方もあるぜ！」とか「ここはこう書いたほうが行儀が良い」等あれば指摘していただけると助かります。非常に勉強になるので。GitHubへのプルリクエストも大歓迎です！ネイティブコードのラッピングに際しては、以下のサイトを参考にさせていただきました。


