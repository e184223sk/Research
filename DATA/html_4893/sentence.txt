ReactiveExtensions（以下Rx）の鬼門はHot-Coldの概念とHot変換だと思います。等々はいろいろな記事で紹介されていますが、ではPublish()すると裏で一体何が起こるのか？Connect()すると何が起こる？というのは、あまり詳しく解説されている記事が少ない印象です。そこで、本記事ではRxの鬼門Publish()メソッドを「とりあえず」で使うのを卒業し、何が行われているかを「完全に理解」できるように解説していきます。まずは前提となるHotとColdの知識が必要です。
別記事で書きましたので、もしHotColdの知識が曖昧な方はご覧ください。
Subject&lt;T&gt;クラスの役割とHotColdとの関係性についても解説しています。↑の記事の内容を要約すると次の３つに言及しています。Subject&lt;T&gt;クラスは1つのObservableシーケンスを複数の購読者に対してマルチキャストする機能を持つ。HotなIObservableとは、Subject&lt;T&gt;クラスから出ているIObservableのことを指す。実体はSubject&lt;T&gt;クラスなので、複数の購読者に対してObservableシーケンスをマルチキャストできるという特徴を持つ。対して、それ以外の（Subject以外から出ているような）IObservableはColdと呼ばれる。
UniRxのオペレータから出てくるIObservableはほぼColdである。Observableソースとは、Observableシーケンスに流れてくる値の発生源のこと。これにもHotとColdがある。HotなObservableソースは、何回SubscribeされてもObservableシーケンスは１つ。Subscribeした時点以降の通知が届くようになる。
SubjectがObservableソースの場合は、HotなObservableソースとなる。対してColdなObservableソースの場合、Subscribeされたらその都度専用のObservableシーケンスが生成される。
専用のObservableシーケンスなので、いつSubscribeしてもすべての通知が届く。
主にファクトリメソッド等から生成される場合、ColdなObservableソースとなる。これらの内容を踏まえた上で、Publishオペレータについて解説していきます。前述したHot, Coldの定義と、Subject&lt;T&gt;クラスの特徴を踏まえて、ColdなIObservableをHotなIObservableに変換するにはどうすれば良いのかを考えます。
要は、Subjectクラスから出ているIObservableならば確実にHotなのですから、「ColdなObservableをSubjectクラスから再発信すれば良いのではないか」と考えることができます。具体的には、次の手順を踏みます。Subject&lt;T&gt;クラスから出ているIObservable&lt;T&gt;はHotなIObservable&lt;T&gt;なので、Hot変換が完了しました。Subject&lt;T&gt;クラスを使うことで、無事にHot変換を行うことができました。Hot変換する手順は上記の通り。じゃあPublishオペレータは上記のことをやっているんだね！と思ったら、実はそうではありません。なんと、PublishオペレータだけではObservableシーケンスに対してなんの影響も一切与えません。つまり、Publishオペレータをつけただけでは、Hot変換もまだ完了しないのです。じゃあPublishオペレータは何をしているのか？というと、いつでもHot変換ができるような「準備」をしています。Publishオペレータが実際に行っている処理は、次に示す「準備」のみに留まります。用意しているだけで、実際にSubject&lt;T&gt;やIObservable&lt;T&gt;に対して何らかの操作をしているわけではないことがポイントです。実際にHot変換が完了するには、あと残り2つの操作を行うことが必要です。これら2つの操作が完了したとき、はじめてHot変換が完了したことになります。
しかし、これらの操作はPublish内では行われず、次の工程に委託されます。具体的には、Publishオペレータの戻り値として、これら2つの操作のみが可能なインターフェイス返すことで、次の工程への委託を実現します。
そのインターフェイスこそが、IConnectableObservable&lt;T&gt;インターフェイスです。IConnectableObservable&lt;T&gt;インターフェイスとは、その名の通りConnectができるIObservable&lt;T&gt;インターフェイスです。
定義もまんま、ConnectができるようになったIObservable&lt;T&gt;です。つまり、IConnectableObservable&lt;T&gt;インターフェイスはConnectとSubscribeのみができるインターフェイスということになります。そして、前項で説明したHot変換に必要な2つの操作が、それぞれConnectとSubscribeに割り当てられています。
それぞれのメソッドを呼び出すことで、各操作が完了してHot変換が完了することになります。図で表すと次のようになります。次項から更に詳しく解説していきます。Publishオペレータの戻り値はIConnectableObservable&lt;T&gt;インターフェイスであるということ、そしてIConnectableObservable&lt;T&gt;インターフェイスはConnectとSubscribeの2つの操作が可能であることを説明しました。
まだピンとこないと思うので、まずはいくつかのHot変換の実例に則ってIConnectableObservable&lt;T&gt;インターフェイスの使い方を説明します。オペレータはColdなので複数回Subscribeされると無駄な処理が走ることになります。
それを防ぐためにHot変換を行う例です。複数回SubscribeしてもDoオペレータはOnNextの分だけ通過してることがわかるので、Hot変換が成功していることがわかります。ちなみにHot変換しないとこんな感じになります。
DoオペレータがSubscribeの数だけ呼ばれていることからも分かる通り、オペレータ処理が重複実行されてしまっています。ファクトリメソッドから生成されたIObservableは基本的にColdなので、Subscribeするたびに新しいObservableシーケンスが生成されます。
１つのObservableシーケンスを複数回Subscribeして使い回したいためにHot変換を行う例です。Hot変換することで、「最初からの購読者」、「2.5秒遅れの購読者」に対して、同一の値が発行されていることが分かります。したがって、1つのObservableシーケンスを共有できていることがわかります。Hot変換しないと、「2.5秒遅れの購読者」に対しては新しく0から値が発行されていることがわかります。つまり、それぞれObservableシーケンスが別個に生成されているということになります。ところで、上記の2例ではどちらもの順に操作しています。
であれば、Connectの存在意義とは一体何なのか？PublishしてConnectするのなら、Publish内で自動的にやっておいてくれれば良いのではないか？と思うかもしれません。
ところが、Connectを呼び出すタイミングには重要な意味があって、場合によってはConnectの呼び出すタイミングによって実行結果がまったく変わってくることがあります。例えば、以下のような例では、Connectを呼び出すタイミングが非常に重要になります。
①〜④のうち、どこでConnect()を呼び出すべきでしょうか？↓
↓
↓
↓答えは、3つのSubscribeにすべて値を通知させるためには、④の位置でConnect()を呼び出す必要があります。Connect()の効果は「Publish内のSubject&lt;T&gt;に、変換元のColdなIObservableをSubscribeさせる」でした。
この場合、「変換元のColdなIObservable」とはObservable.Rangeですので、Subscribeした瞬間に1~10までの値が即座に流れてきてしまいます。したがって、例えば①の位置でConnect()を呼び出すと、誰もSubjectをSubscribeしないまま1~10の値が流れてきてすぐにOnCompletedするので、結果としてObservable.Rangeが発行した値は虚無に消えます。
OnCompletedしたあとに3回Subscribeしていますが、もはやなんの値も流れてこないので、値がまったく通知されてこないことになってしまいます。②や③でConnect()した場合は、Connect()以前にSubscribeしていた購読先には値が届きますが、Connect()以降にSubscribeした購読先には値は届きません。④でConnect()すれば、きちんとすべての購読先がSubscribeを完了させ、準備万端な状態でObservable.RangeをSubscribeするので、すべての購読先に対してObservable.Rangeの発行値をマルチキャストすることができます。このように、ファクトリメソッドなどのColdなObservableソースをHot変換する場合は、Connect()を呼ぶタイミングが非常に重要になることが分かります。対して、Connect()を呼ぶタイミングが重要ではない場合もあります。それは、ObservableソースがHotである場合です。
ObservableソースがHotとは、Subjectから値が生成されている場合を指します。先ほどの例のObservable.Rangeファクトリメソッドの場合は、Subscribeしたタイミングで、値が生成されて発行されていくのでした。つまり、「購読側で値の発行タイミングを制御できている」と言えます。
これに対してSubjectから値が生成されているということは、値の発行タイミングがOnNextが呼ばれるタイミングに委ねられることになります。つまり、「購読側では値が発行されるタイミングを制御することができない」、と言えます。値の発行タイミングが制御できるのであれば、値の発行開始を示すConnect()呼び出しのタイミングは前述の通り非常に重要になりますが、Subjectのように値の発行タイミングが制御できないのであれば、もはやConnect()の呼び出すタイミングはいつでも良いです。いつSubscribeしようが、値が流れてくるタイミングはこちらでは制御できないためです。例えば、次のような例で考えてみます。SubjectSubscriberは、外部が公開しているSubjectを取得してHot変換をかけています。どこでConnectしようか迷っているようですが、この場合はどこでConnectしても結果は変わりません。
ObservableソースがSubjectの場合、いつSubscribeしようが単一のObservableシーケンスをSubscribeすることになるので、Subscribeのタイミングによって結果が左右されることがないのです。ただ、もちろんSubscribeのタイミングが大幅に遅れると、それまで発行された値は通知されなくなるので、例えば以下のようにするのは問題です。このようにすると、connectableObservableをSubscribeしてから10秒間に発行された値は購読先にマルチキャストされなくなってしまうため、このような極端な例はNGとなります。逆に、早くConnectする分にはまったく問題がありませんので、ObservableソースがHotであると分かっている場合は、IConnectableObservable&lt;T&gt;を即Connectしてしまっても問題ないでしょう。ところで、Connect()の戻り値はIDisposableとなっています。果たしてこのIDisposableは、Subscribeの戻り値のIDisposableと何が違うのでしょうか？前に掲載した図をもう一度見てみると、違いはすぐに分かると思います。この図を見ると、ConnectもSubscribeもどちらもやっていることは「Subscribe」ですね。したがって、Connectの戻り値のIDisposableとは、Subjectが変換元のIObservableをSubscribeしたときに出てきたIDisposableのことであるということがわかります。
IConnectableObservableのSubscribeの戻り値のIDisposableをDisposeすると、Subjectへの購読がDisposeされるのと同様に、Connectの戻り値のIDisposableをDisposeすると、ソースとなるColdなIObservableへの購読がDisposeされるということになります。ではどちらをDisposeすべきなのか。まず前提として、ただ単にDisposeしたいだけ、購読を解除したいだけならば、どちらをDisposeしても挙動は変わりません。
SubscribeのほうをDisposeすればSubject自体への購読が直接解除されるし、ConnectのほうをDisposeすれば、Subjectに入ってくるソースからの通知が遮断されるので、結果的に通知が来なくなります。挙動が変わってくるのは、ConnectをDisposeしたあとに、再びConnect（再接続）するような場合です。そして、これに関しても、ソースとなるColdなIObservableのObservableソースがColdなのかHotなのかで挙動が随分変わってきます。もし、ObservableソースがHot、つまりSubjectから値が生成されているならば、何度「切断/再接続」を行ったとしても、ただ単に接続されている場合は値が飛んでくる、切断した場合は値が飛んでこない、それだけの違いになります。
しかし、ObservableソースがCold、つまりファクトリメソッドなどから値が生成されている場合は、「切断/再接続」をするたびに、新しいObservableソースが生成されることになります。例えば、以下の例を見てください。
Observable.IntervalをPublishしてConnectしたあと、3秒後に切断/再接続を行う例です。実行結果は次のようになります。3秒経って「切断」を行うと、それまでのObservableシーケンスは破棄されます。そして、「再接続」を行うと、また新しいObservableシーケンスが生成されるため、インクリメントが0に戻っていることがわかります。次の例のように、Observableソース自体をHot化しておけば、「切断/再接続」を行ってもObservableシーケンスは破棄されず、再接続しても途中から始まります。ConnectのIDisposableとSubscribeのIDisposable、それぞれの挙動をまとめると次のようになります。長くなってしまいましたがまとめると次のようになります。自分の中でPublishの理解が曖昧だったので記事にまとめましたがだいぶしっかりした知識になった気がします。
あと基本、外部にIObservableを公開するときはHot変換して公開したほうが良さそうな気がします。外部からはこのIObservableがHotかColdか、はたまたObservableソースがColdなのかHotなのかなんてわかりませんから。外部に公開するときはHot、これを徹底しておけばハマる確率がかなり減らせるのではないかと思いました。もちろん意図的にColdで公開したい！って場合は、わかるようにしておけばそれはそれで良いと思いますけどね。では、最後までありがとうございました！
ご意見ご指摘等ありましたらコメントお願いします！


