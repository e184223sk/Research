More than 3 years have passed since last update.前に､こんなこと書いたわけですが､配列1に対しちゃ実際どーなのさ?
と言うこともキニナルでしょ?ってコトで追いかけた｡実行環境は､.Net Core 2.0とBenchMarkDotNet､
あと､コンパイル結果の解析などにはsharplabを使っている｡また､今回は比較的単純なケースのみを取り上げており､網羅的に取り扱ってるわけではないので､その点ご了承頂ければ幸い｡こんなコード書いたとき､コンパイラは､以下のような展開を行う｡IEnumerable&lt;T&gt;なのかIEnumerableなのか､パターンマッチした似たような何かなのかでコードの生成はビミョーに変わるのだけど､概ねこんな感じだと思って頂ければ｡流れとしては､てかんじになる｡では､本題の配列に対するforeachはどーなるのかというと､同様に以下のようなコードを書いたとする｡これはコンパイルすると以下のようになる｡先ほどとは違って､forを使ったアクセスに展開されている｡こうすることで､GetEnumeratorや､その先にあるMoveNextの呼び出しを抑止して高速なアクセスが出来るようになっている｡C#の配列は常に境界チェックが効いており､境界外にアクセスしようとするとSystem.IndexOutOfRangeExceptionが飛んできて不正な操作を許容しない様になっている｡こいつはとても便利で安全な反面､境界内に収まることが自明な処理を行う場合､余計な処理にもなり得る｡個人的には､安全で堅牢なプログラミングを行う上で必要なコストだとは思うけど､.NETのJITは条件を満たすことでこの境界チェックをすっ飛ばすNativeCodeを吐き出す｡それでは早速みていこう｡境界チェックを外すに、守るべき条件は以下の通り｢配列がローカルに存在する｣というのは､何もstackallocする必要があるというわけじゃ無く､var array=...のようにローカル変数に参照させるか､引数で受け取る必要があると言う意味となる｡これに従えば､と言うコードや､と言ったコードは､境界チェックを外した上で高速に処理が可能だ｡但し､以下のコードは境界チェックを外せないので注意｡こっちの方が高速だとか言われてるけど 2､C#書いてる上では完全に無意味でしかも遅い｡
この場合､境界チェックが発生してパフォーマンス的に不利になる｡先の例は引数で配列を受け取り処理を行っていた｡では以下のような場合どうなるだろうか?先の例に当てはめれば､どっちも変わらないでしょうと思われがちだけど､実はforeachを使った方は境界チェックが外れるけど､for使った方は境界チェックを外すことができない｡上記のコードをコンパイルして､デコンパイルすると､以下のようになる｡foreach使ってる方は､intArrayといローカル変数に一度代入されてそのローカル変数への操作を行っている形を取っている｡
他方forの方はデコンパイル前後で当たり前だけど変化はない｡実はここに大きな差があって､静的フィールドに有るIntArrayは別の処理が参照先の配列を変えてしまうことが出来る｡この事実とマルチスレッドが組み合わさると､ループ実行中に別の配列に差し替わって境界外アクセスが意図せず発生するというシナリオができあがる｡このケースを検知するために恐らく境界チェックを外すことができないのだ｡また､残念ながらreadonlyを付与してもこの状況は変わらない｡3今までありがちなケースにおける配列に対する列挙操作の最適化がどのように行われているのか検証した｡
ここでは最後に､実際どの程度差が出るのかみてみることにしよう｡検証コードは以下の通り｡で､結果が以下大幅に速くなってるわけじゃないけど､それなりには速くなってるのがわかる｡以上のことから､以下のようなことが言えるのではないかと思う｡当たりに注意すれば良いかと思う｡また､様々なケースはこれ以外にも当然考えられるので､その辺に関する考察は下記の参考としたページを見て頂ければと思う｡C#はunsafeの方が速いという幻想
Array Bounds Check Elimination in the CLR実際ここが､何を相手にしてるかで結構変化する｡ ↩"Some older programmers learned to write loops like this, because on some early architectures (e.g., DEC PDP-8, if memory serves) there was a hardware addressing mode that did auto-decrement, but not auto-increment. "だそうな。 ↩実際問題リフレクション使うとreadonlyを変更できる(やるべきでもないし､やっちゃいけない) ↩


