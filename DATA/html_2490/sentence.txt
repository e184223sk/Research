More than 1 year has passed since last update.前回のコンテンツASP.NET Core MVC 階層化アーキテクチャ Chap2 (Generic Repositoryで共通化を図る)では、個別repositoryのデータ操作処理を抽出して、Generic repositoryを作成しました。データ操作は共通化されたRipositoryできて完璧のように思えますが、業務システムではGeneric repositoryだけでは複雑な要件を満たすことはできません。今回はクラスごとの異なるデータ操作をしたいときに、Repositoryの実装方法を紹介したいと思います。前回の改修を終え、プロジェクトフォルダの構成はおそらく下記の図のようになっていると思います。Generic repositoryが既にあるため、個別Repository(CustomerRepository, SupplierRepository)とインターフェース(ICustomerRepository, ISupplierRepository)はすべて削除済みです。そして、クラスを取得するメソッドGetOneAsyncの引数はLinq Expressionを使っています。例えば、customersを取得するための引数をLinq Expressionではなく、主キー(CustomerId)で取得したい
となった場合、Generic Repositoryの機能だけではこの要件を満たせません。そうなると、当然このままでは取得条件が複雑になってくるデータ操作のロジックはControllerで書くことになり、
リクエストを制御する役割であるControllerにビジネスロジックとデータ操作をさせることは関心の分離にも違反します。更に、ControllerとRepositoryの両方は同じ人で実装する必要があり、複数人同時開発の効率も良くありません。このようなケースの場合、特別な操作は個別Repository、共通処理はGeneric Repositoryの構成になるように改修します。まずは、ICustomerRepositoryとISupplierRepositoryをもう一度作成し、
個別機能のメソッドのみ定義します。個別Repositoryを作成し、データ操作（CRUD）の共通処理はGeneric Repositoryを継承し、個別処理は実装します。Controllerは今までGeneric Repositoryのインターフェースから個別Repositoryのインターフェースに差し替えます。
id取得のメソッドを修正します。Startup.csに個別Repositoryの依存性注入を行います。このシリーズを最初から読んでいる人は今回のコンテンツで混乱するかもしれません。朝令暮改はいい加減にしろっと思うかもしれません。このような構成になったには理由がありまして、徐々にコード改修を通じて、階層化アーキテクチャを本質的に理解を深めるためです。徐々にコード改修することで、「なぜこの実装になったのか」 がより明確になります。もちろん、最初から完成版のコードを出してもいいですが、それでは途中経過がわからず、なんとなくの理解になってしまう恐れがあるからです。次回からはプロジェクトの責務をより分けるように、本格的にコードをWeb UI層、データアクセス層、ビジネスロジック層に分割していきたいと思います。今回作成したソースコードです。GitHubリポジトリでは！！( ｀ー´)ノ


