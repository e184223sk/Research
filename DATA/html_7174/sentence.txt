More than 3 years have passed since last update.C#:エラトステネスの篩を使った素数の計算という記事を書いたら、yone64さんからコメントがあって、列挙開始も速く、最大値を指定する必要もない「少しずつふるいにかけるメソッド」を提示してもらいました。でも、コードを読む力がない僕は30秒で挫折...(^^;;
リンク先のページを読んでおぼろげながら何をやろうとしているのかが分かりました。コード読むより自分で考えた方が面白そう、ということで、「少しずつふるいにかける」をヒントに自力でアルゴリズムを考え、C#のコードにしてみることにしました。以下、出来上がったC#のコードを示します。
結果的に、yone64さんのコードと同じことをしているコードになったような気がします。たぶん...(^^;;求める値は、intの範囲内です。long型まで対応するとなるとさらに工夫が必要になりますし、longよりも大きな素数も求めたいとなると、また違った工夫が必要になってきますが、今の僕にとっては、これが最良の素数を求めるメソッドだと思います。コードにコメント書いておきましたが、備忘のため、簡単にこのコードが何をやっているかを説明しておきます。まず、既知の素数 2 を使い篩にかけます。この時の篩の下限と上限は、2^2,  3^2-1 です。つまり、4~8までの素数を求めます。この時の 3^2-1 の3は既知の素数として扱っています。これで、素数 5,7が求まります。次に、篩に掛ける素数を一つ増やし、2,3で篩に掛けます。篩の範囲は、9 (3^2) ~ 24 (5^2-1) です。これで素数 11,13,17,19,23が求まります。次は、2,3,5で篩に掛け、29,31,37,41,43,47 が素数として求まります。この時の篩の範囲は、25 (5^2) ~ 48 (7^2-1) です。このステップを繰り返せば、どんどん素数が求まることになります。なお、下限、上限を指定できる配列もどきのクラスBoundedBoolArrayを作成しています。こうすれば、頭の悪い僕でも、篩にかける部分(trueをセットしているところと、素数を列挙しているところ）が苦労なく書くことができます。少しずつ篩に掛けるので、「1億以下の素数をすべて求めよ」という問いに対して、トータルの処理時間は通常のエラトステネスの篩のコードよりは、わずかに遅くなりますが、列挙開始までの待ちがほぼゼロ、篩のサイズを指定する必要が無いという大きな利点があります。
「100000番目の素数を求めよ」という問題があった場合、エラトステネスの篩を使った通常のやり方では、篩のサイズをいくつにしたら良いかわからないですから、今回作成したメソッドはとても有用であると思います。戻り値を、IEnumerable&lt;int&gt;にすれば、LINQ使って、とかとかとか書くことができます。以下のようなコードだと、永久に素数を求め続けようとしますので、このような書き方は基本的にできません。メモリオーバーになるか、オーバーフローするかしてしまいます。ちなみに、このプログラムでは、篩のサイズは、[4:8], [9:24], [25:48], [49:120]... と変化するわけですが、理論的には、としていくことも可能です。しかし、そうすると、あっというまに大きなサイズの配列が必要になり、必要のない大きな数の素数まで求めることになってしまいます。これでは、返って速度の遅いプログラムになってしまいすし、列挙を早くするという最初の趣旨にも沿いません。


