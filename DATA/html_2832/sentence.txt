More than 1 year has passed since last update.前回の記事(概念編)からの続きです。是非こちらもご覧ください。
CleanArchitectureを適用したBMI計算アプリの実装について解説します。
言語はC#、実行環境はUnityです。プログラムにおける依存とは主に「クラスAがクラスBに依存している」といった表現で使われます。この場合、「クラスBがクラスAの一部になっている」「クラスAはクラスBの中身を知っている」ということを表し、「クラスAはクラスBの上位モジュールである(＝クラスBはクラスAの下位モジュールである)」わけです。上位/下位という言葉を使うと上位は下位より偉いと捉えられますが、一概にそうとは言えません。クラスAがいないとクラスBの存在理由が無いのはそうなのですが、クラスAもクラスB無しでは自分の一部を失うことになります。「代わりはいくらでもいる」とはならないのです。「代わりはいくらでもいる」とクラスAがクラスBに対して強く言えるようになる方法に 抽象化 があります。クラスBの機能を整理して、インタフェースBに抽象化します。クラスAはそのインタフェースBに依存するようにすれば、クラスAはクラスBに対して「うちはインタフェースBを実現しているクラスなら誰でも良いんだ。代わりはいくらでもいる。」といえるようになります。抽象化を実現する方向には interface と abstract class を使う2つの方法がありますが、C#ではクラスの多重継承ができないので、interfaceを使う方が多いと思います。実装も共通化させたいなどの事情があればabstract classを使ってください。さて、CleanArchitecture以前に設計の原則として 依存性逆転の原則 1というものがあります。
抽象化前はクラスAからクラスBの右向きの矢印一本しかなかったですが、抽象化によってクラスBからクラスA(インタフェースB)に向かう左向きの矢印が出来ました。これが依存性逆転です。
今までは一方的にクラスAに使われる側だったクラスBもインタフェースBを 実現してやってる 上位の立場になったわけです。(クラスAに見捨てられても「私はインタフェースBを実現したクラスです」と宣伝すれば別のクラスに使ってもらえるかもしれません。)CleanArchitectureのルールとして、外側の層が内側の層に依存する というものがあります。
画像左側の3本の並んだ矢印がそれを表しています。
外側が内側を知るのはいいが、内側が外側を知るのはダメということです。前の記事でUseCaseについて数字の入力をPresenter経由で受け、BMI計算を呼び出し、結果をPresenterに返す実装をUseCaseで行います。という説明をしました。これではあたかもの様に BMIUseCase が BMIPresenter に依存した作りになっていると想像されたかもしれません。これは、「外から内に依存する(内から外に依存してはいけない)」という決まりに反しています。しかし、BMIを計算するというUseCaseをBMIUseCaseとして実装するためには数値入力のViewと接続したBMIPresenterが必要になります。この内側から外側への依存を回避するために依存性逆転というトリックを使います。IBMIPresenterというinterfaceを定義します。そして、BMIUseCaseからはIBMIPresenterを参照し、それをBMIPresenterで実現するようにします。
ここで留意すべきはinterfaceのIBMIPresenterは緑のInterface Adaptersではなく赤のApplication Business Rulesに属すると言う所です。2
理由はIBMIPresenterを決定するのはPresenterやViewではなく、UseCaseだからです。BMIの計算と表示を行うUseCaseで使うPresenterの定義がIBMIPresenterに現れていて、BMIPresenterはそれを実現したに過ぎないという訳です。これにより内側は外側を知らず、外側が内側の定義を知っているだけになり、「外から内に依存する(内から外に依存してはいけない)」というルールを守ることができます。このように、CleanArchitectureで境界を超えるときは抽象化による依存性逆転が便利な場面が多いです。
前記事のDomain/UseCase/Presenter/Viewをすべて表すと以下の図になります。
各層の外側から内側に矢印が向くように作ってあります。Domainにて抽象化を行っていない点が恣意的ですが、この層は変更が行われることが少ないことや、Domainは単にUseCaseから利用される層なのでこのようにしています。必要性を感じるなら抽象化を行ってください。※ Domain=CleanArchitectureの図で言う所のEntitiesです。本記事ではDomainという言葉を使っています。UseCaseを中心に考えて実装を行うとのような構造になります。
BMIUseCaseはIBMIPresenterに依存し、コンストラクタで外からIBMIPresenterを実装したクラスのインスタンスを受け取れるようになっています。
interfaceなどで抽象化した要素に具体的なインスタンスを渡して抽象を解決する処理を依存性の注入(Dependency injection)といいます。依存性の注入を行う人物が裏で糸を引いて、各層の実装を引き合わせることでBMIを求めるアプリが完成するのです。正に黒幕です。実際に依存性の注入を行う場合ですが、プログラムの起動時にMainでまとめて行う場合もあれば、DIライブラリを使って行う場合などがあります。Unityのバージョンは2019.1.14です。身長と体重を入力できる InputField とBMIの結果を表示する Text を配置します。
名前/年齢/性別の入力は何となく付けました。UIによるユーザへの入出力を行う部分です。Unityの都合による影響をモロに受ける部分でもあります。CleanArchitectureに則った構成であることを示すために定義したinterfaceです。別に定義しなくても実装できない訳ではありません。BMIの入力・出力を行うUIの要素群を定義したinterfaceです。Interface Adapters層の住人になります。IBMIViewを実現した具体的なクラスです。Unityで動かす都合上MonoBehaviourを継承しします。Frameworks &amp; Drivers層の住人になります。ViewとUseCaseを繋ぐ層です。という双方向のデータ処理を実現する必要があります。UseCaseへの通知を今回はUniRxを導入し、IReadOnlyReactivePropertyを使って実現しました。CleanArchitectureに則った構成であることを示すために定義したinterfaceです。無駄だと思うなら不要です。PresenterでViewの要素(Buttonとか)を公開するプロパティを持ってしまうとUseCaseがViewの要素にアクセスできてしまいPresenterの層が意味を為しません。ここでのusing UnityEngine.UIは禁止するのが吉です。BMI計算アプリUIのin/outを定義したinterfaceです。Application Business Rules層の住人になります。IBMIPresenterを実現した具体的なクラス。IBMIViewをコンストラクタで受け取り、そいつからのイベントを外部に公開するのと同時に、そいつへのデータの反映も行います。Interface Adapters層の住人です。業務ロジックの層です。BMI計算ロジックが含まれます。アプリケーションの挙動の実装を行います。Viewを直接参照せずにPresetnerから操作を行ったり、BMI計算処理などはDomainに任せたりするなどして、アプリケーションの挙動に集中させます。コンストラクタでIBMIPresenterを受け取り、Begin() にてIBMIPresenterが公開しているIReadOnlyReactivePropertyをすべて購読(Subscribe())します。UIの入力に応じてBMI計算ロジックを呼び出して画面に結果を反映させるなど、アプリの処理がすべてBegin()に記述されています。UseCaseには難しいことはさせず、子供でもできることだけを記述するのがいいでしょう。例えば入力のバリデーションをしたくなった場合にもBMIUseCaseにべた書きするのではなく、専用のDomainやUseCaseを新たに追加することを考えてください。今まで出てきたView/Presenter/UseCaseは全てコンストラクタで要素を受け取って依存性の注入ができるようになっています。必要なインスタンスを各自に渡して依存性の注入を行い、アプリの挙動を決定・開始させる役目をMainに任せます。
Unityの場合、MainにはMonoBehaviourを継承させてシーンに配置することで以下を行えるようにします。Mainに書くのはこれだけです(シンプルですね)。アプリのロジックは全てUseCaseを中心に構成されています。各クラスの関係を表したクラス図です。UseCaseは抽象化されたPresenterしか知らず、Presenterの先にView(MonoBehaviourなどUnityの世界)があることなど知りえないのです。Mainを全てを知る立場に添えて、裏で各要素を繋げてアプリを走らせる役割を任せています。他のCleanArchitectureの記事にある実装例とは合致していないかもしれませんが、私なりに腑に落ちるように噛み砕いてUnityの実装まで落とし込みました。作るScriptのファイルが多くなるのでいざ作ると大変ではありますが、MainやUseCaseに実装する処理が明確でシンプルになった手ごたえを感じています。また、各層が抽象化されているのでUseCaseなどをテストする場合も簡単にできそうです。naninunenoy/UnityViewPatterns/BMIApp
色々(シーン跨ぐ場合や複数UseCaseがある場合など)試したので、今は仮ログインや履歴表示の機能などが盛り込まれてます。Unity開発で使える設計の話＋Zenjectの紹介 素晴らしい資料なので是非読んでください ↩umm/cafu_core レイヤー定義 大いに参考にさせてもらいました ↩


