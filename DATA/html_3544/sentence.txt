More than 1 year has passed since last update.ConsoleAppFrameworkリリースしました！破壊的大変更でより便利に！なりました。 / “neue cc - ConsoleAppFramework - .NET Coreコンソールアプリ作成のためのマイクロフレームワーク（旧MicroBatchFramework)” https://t.co/CEXtQ4iJwpとのことで記事修正しました。ConsoleAppFrameworkを用いてAzure Functionsにアプリをデプロイしてみたのでその方法を紹介し、ConsoleAppFrameworkの良いところについても記載してみます。詳細は上記参照なのですが、GUIを作成するためのフレームワークとしてPrism等があるように、CUIを作成する際にもフレームワークを用いましょうという感じです。上図のように(定期的に)ネット上から情報取得して整形フィルタリングしてネット上のどこかに出力(通知)したいなと考えていました。
情報元の数だけコンソールアプリケーション(バッチスクリプト)を用意してcronにでも仕掛ければ実現できる内容です。MicroBatchFramework – クラウドネイティブ時代のC#バッチフレームワークから引用すでにC#にはコマンドライン引数の解析ツールはたくさんあります。とはいえ、そもそもそういうツールを使う時は「コマンドライン引数の解析」がしたいわけではなくて、「パラメータバインディング」をしたいのが一般的と思われます。ということで、『MicroBatchFramework』はウェブフレームワークのようにメソッドを呼び出してくれる仕様にしました。という点にとても共感しました。これを用いればひとつのコンソールアプリケーションで複数のユースケースを使い分けられると思いました。コンソールアプリのエントリーポイントに上記内容を記述するだけで使えます。cronのためだけにサーバを起動し続けるのももったいないのでサーバーレスアーキテクチャを採用してみることにしました。
Azure Logic Appsの繰り返しトリガーとHttpトリガーのAzure Functionの組み合わせでcronちっくことが実現できました。
デザイナーで見ると

こんな感じでjsonでコンソールアプリケーションに入力する内容を伝えれば済みます。コンソールアプリケーションといってもエントリーポイントは文字列配列を引数としたstaticメソッドなので外部から呼び出せます。
jsonで取得した情報を文字列配列に置きなおしてキックすれば動きます。
これの何がすごいかって、実装やテストはコンソールアプリケーションで行ってデプロイする際は軽くラップするだけで済むってところです。
いちいちサーバ上やローカルにAzure Functionとして配置して動作確認しなくても良いのです。さらに良かった点はMicrosoft.Extensions.Logging.ILoggerの使い回し。
Azure Functionのエントリーポイントで渡されるILoggerをMicroBatchFrameworkに設定しなおせばデフォルトではコンソールに出力していた情報もApplication Insights等に出力させることができます。
具体的には以下な感じConfigureLoggingにて(既存のプロバイダを削除して)MyLoggerProviderを追加してあげればAzure Functionで指定しているログ場所へ出力されるようになります。
これでコンソールアプリの時では発生しないAzure Function固有の問題の調査も容易になる思います。業務系だとみたいなのがちらほらあって、いざサーバをリプレースするぞって時に困るんですよね。(動作確認とか作り直しとか)
ConsoleAppFrameworkを採用してコンテナ化して運用すれば環境にもよらなくなるしソースもあるしひとつのアプリで済むので管理が楽になると思います。例えばGUIで実装していた機能(ユースケース)をCUIとして提供したいというときにを意識してちゃんと機能(ユースケース)単位で注入できるように設計していたならばConsoleAppFrameworkに乗せ換えることは容易だと思うんですよね。
逆も然りなんですけど。
簡単なバッチ処理でもちゃんとユビキタス言語を用い業務知識として蓄えておけば、いざというとき二度手間をしなくても良くなる気がします。CUI側にもフレームワークを導入することでGUIと機能の共通化が行えるのはとても魅力的です。
今後はConsoleAppFramework固有の機能についても紹介できればと思います。


