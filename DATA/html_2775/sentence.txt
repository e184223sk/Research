More than 1 year has passed since last update.今回の記事は一応以下の記事の続きです。
また、内容はすべてUnity上での話になります。初心者のためのTask.Run(), async/awaitの使い方前回の記事では、Task.Run()を使って、同期処理を非同期処理にする基本的な例を挙げました。今回はその補足としてもう少しだけ実践的な処理を書いてみようと思います。
内容としては、あとがきでチラッと書いた「Task.Run()を使う必要がない場面」として、ネットワーク処理やファイルのI/O処理の具体的な例を挙げていきます。想定する読者はC#での非同期処理を始めたての方々です。例えば、天気予報API(OpenWeatherMap)を使ってデータを取得し、それをJSONファイルに保存する処理を書くとします。
非同期&amp;非同期ですね。作るクラスはWeatherForecast, DataLogger, AsyncSampleの３つです。WeatherForecastクラスは、WebRequestクラスを使ってエンドポイントにアクセスし、データを取得する処理で書いてみましょう。あとで解説しますが、ここではあえてTask.Run()を使って処理を書いています。
URLやAPIキーはサイトのサンプルのものを使っています。DataLoggerはこんな感じ。WriteLine()はブロッキング処理なのでTask.Run()で囲ってあげています。最後に、それらを使うAsyncSampleクラス。これで表示されたボタンを押すと、メインスレッドは止まることなく問題なく処理が実行されます。しかし実は、今回やったことと同じ処理がTask.Run()を使わなくても書けちゃいます。天気予報で使ったWebRequestクラスですが、実はGetResponse()だけではなくGetResponseAsync()というメソッドを持っています。
このメソッドはawaitすることができるので、WeatherForecastクラスの処理を以下のように書き換えることができます。また、今回やりたいことに関しては、HttpClientクラスを使うことで、もっと簡単に処理を書くことができます。コードがだいぶ短くなりましたね。リソースの開放忘れも起きなさそうです。ではDataLoggerの方はどうでしょうか。
こちらも同様に、StreamWriterクラスにはWriteLineAsync()というメソッドがあるので、それを使うことができます。うん、いい感じにすっきりしましたね。
これで、書き換え前と同じように、メインスレッドをフリーズさせることなくI/O処理を行うことができます。
こんな感じで、普段よく使う非同期処理には、大体awaitできるメソッドが用意されています。特に理由がない場合は、そういったメソッドを優先的に使っていけばいいと思います。今までの話の流れで行くと、Task.Run()の使いどころはかなり限られてきそうです。
前回の記事にも書きましたが、正直思いつくのは非同期の無限ループ処理くらいでしょうか。ただ、状況によってはスレッドプールを意識し、Task.Run()を使うことで処理を効率化できる場面があるようです。
I/O待ちのためのTaskとバックグラウンド処理のためのTaskしかし基本的には、特に理由がない限りはTask.Run()を書く前に、やりたい処理に対応する非同期メソッドが存在しないかまずチェックしてみるのがいいと思います。この記事自体は1年前とかに書いていたのに、なぜか下書きのまま放っていたことに最近気づいたので投稿しました。
なんかOnGUI()とか使ってるよ......ま、まぁそこは本質じゃないから...（震え）正直今更感のある内容ですが、誰かの助けになれば幸いです。


