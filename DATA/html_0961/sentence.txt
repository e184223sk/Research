この記事は 2020 年の ReactiveProperty のオーバービューの全 3 編からなる記事の 3 つ目の記事です。他の記事はこちらです。WPF と UWP 限定の機能としてボタンのクリックなどのイベントが発生したら ReactiveProperty の値を更新したり、ReactiveCommand を呼び出すといった機能を提供しています。EventToReactiveProperty と EventToReactiveCommand を使用して、この機能が利用可能です。この機能を利用するにはプラットフォーム固有のパッケージをインストールする必要があります。上記パッケージをインストールすると Microsoft.Xaml.Behaviors.Wpf (WPF 用)、
Microsoft.Xaml.Behaviors.Uwp.Managed (UWP 用) パッケージもインストールされます。このパッケージ内にある EventTrigger と EventToReactiveProprety/EventToReactiveCommand を組み合わせて使うことでイベントをハンドリングして ReactiveProperty/ReactiveCommand に伝搬することが出来ます。また、イベント発生時のイベント引数を変換するための変換レイヤーも提供しています。DelegateConverter&lt;T, U&gt; と ReactiveConverter&lt;T, U&gt; を継承して作成します。型引数の T が変換元（普通は XxxEventArgs）で U が変換先 (ReactiveProperty の値の型やコマンドパラメーターの型) です。例えば WPF でマウスを動かしたときのイベント引数の MouseEventArgs を表示用メッセージに加工するコンバーターは以下のようになります。2 つのクラスは同じ処理をしています。ReactiveConverter は変換処理を Rx のメソッドチェーンで書けます。DelegateConverter は変換処理を普通の C# のメソッドとして書けます。
このコンバーターを使って View のイベントを ReactiveProperty や ReactiveCommand に伝搬させる先の ViewModel を作成します。今回は確認ようにシンプルに受け取ったメッセージを格納するための ReactiveProperty と、ReactiveCommand を用意しました。ReactiveCommand は実行されると受け取った文字を加工して MessageFromCommand という名前の ReadOnlyReactiveProperty に流しています。これを XAML にバインドします。EventToReactiveProperty と EventToReactiveCommand は EventTrigger の子要素として配置します。そして EventToReactiveProperty と EventToReactiveCommand の子要素としてコンバーターを指定します。実行すると以下のようになります。EventToReactiveProperty はコンバーターで変換した結果がそのまま表示されています。EventToReactiveCommand のほうは、コマンドで加工したメッセージが表示されていることが確認できます。Reactive.Bindings.Notifiers 名前空間には、いくつかの IObservable を拡張したクラスがあります。単品で見ると大したこと無いクラスですが、これらも IObservable なので ReactiveProperty や RreactiveCommand や ReactiveCollection とつないで使うことが出来ます。
とはいっても使用頻度は少なめなので、Notifier 関連の詳細はドキュメントを参照してください。Notifiers | ReactiveProperty documentここでは MessageBroker と AsyncMessageBroker を紹介します。この 2 つのクラスはグローバルにメッセージを配信して購読するための機能を提供します。Prism でいう IEventAggregator が近い機能を提供しています。他にはメッセンジャー パターンなどと言われている機能を Rx フレンドリーに実装したものになります。MessageBroker と AsyncMessageBroker は MessageBroker.Default と AsyncMessageBroker.Default でシングルトンのインスタンスを取得できます。ただ、これはグローバルにメッセージを配信するユースケースが多いので利便性のために提供しているもので独自に new を使ってインスタンスを生成して使うことも可能です。MessageBroker は ToObservable を呼ぶことで IObservable に変換できます。AsyncMessageBroker クラスは非同期処理に対応しています。AsyncMessageBroker は IObservable には変換できません。
使用方法を以下に示します。実行結果は以下のようになります。AsyncMessageBroker のほうは、2 秒ごとにログが出ているので await 出来ていることが確認できます。IObservable 向けの便利な拡張メソッドをいくつか用意しています。使う場合は Reactive.Bindings.Extensions 名前空間を using してください。ここでは特に使用頻度が高いと思うものだけを紹介します。完全なリストは以下のドキュメントを参照してください。Extension methods | ReactiveProperty documentIEnumerable&lt;IObservable&lt;bool&gt;&gt; に対して最後の値がすべて true かどうか、もしくは false かどうかを表す bool を後続に流す IObservable&lt;bool&gt; に変換します。
例えば複数の ReactiveProperty の ObserveHasErros が全て false (エラーなし) になったら実行できるコマンドの生成などで便利です。以下のようになります。ObservableCollection&lt;T&gt; の型引数 T が INotifyPropertyChanged の場合に利用できる拡張メソッドです。ObservableCollection&lt;T&gt; の全ての要素の PropertyChanged イベントを監視できます。コード例を以下に示します。実行すると以下のようになります。コレクションにある要素のプロパティの変更が監視できていることがわかります。またコレクションから削除した要素（この場合は okazuki 変数）は削除後は変更してもコールバックが呼ばれていないことも確認できます。コレクションの要素が POCO ではなく、ReactiveProperty を持つクラスの場合も ObserveElementObservableProperty 拡張メソッドを使うとコレクション内のオブジェクトの ReactiveProperty の監視を行えます。実行すると以下のようになります。Inverse 拡張メソッドを使うと ox.Select(x =&gt; !x) を ox.Inverse() のように書けます。それだけ。IObservable の拡張メソッドとして DisposePreviousValue があります。
これを使うと、最新の値以外を自動的に Dispose 出来ます。ReactiveProperty は Rx の機能を使ってメソッドチェーンが綺麗にきまると気持ちいいですが、やりすぎると可読性の低下や、知らない人にはトリッキーなコードになってしまうといった問題があります。
ReactiveProperty や async/await にも対応しているので、そちらを使って値の変更があったタイミングで処理を書くということも出来ます。ただ、現状まだちょっと非力です。WaitUntilValueChangedAsync メソッドで await で待つことが出来ます。コード例を以下に示します。実行すると以下のような結果になります。コマンドも同様に await が可能です。ということで前編・中編・後編終わりました。
適当機能強化とかがあったら、ここを更新していこうと思います。


