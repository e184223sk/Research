More than 1 year has passed since last update.MagicOnion についてはこちらをご覧ください。
非ストリーミング通信での共通処理の挟み方は以前の記事で紹介しました。
ストリーミング通信でも同じく gRPC Interceptor を用いて処理を挟むことができるのですが、
MagicOnion 特有のフォーマットで送受信されているためそれを理解する必要があります。Grpc.Core.Interceptors.Interceptor クラスを継承し、必要なメソッドを override します。
今回必要になるのは AsyncDuplexStreamingCall のみです。AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt; の定義は以下のとおりです。入出力はそれぞれ RequestStream, ResponseStream を通して行われているようです。
そのためこいつらを自前実装したクラスに差し替えてやれば入出力に対して処理を挟むことができるようになります。それぞれ、生データ(byte[])に対する処理と元のStreamを渡す構成にしておきます。これを適用してみましょう。これで一応リクエスト/レスポンスデータを見ることはできるのですが、なんだかよくわからないフォーマットになっています。
例えば SendStampAsync(3) というリクエストに対するデータは [2,1766806594,3] となりました。これがどういう構造なのかは StreamingHubClientBase.cs と StreamingHubClientBuilder.cs を頑張って読めばわかるのですが、[メッセージID, メソッドID, 引数のデータ本体] という3要素の配列になっています。
メッセージIDは自身が送ったメッセージ1個ごとに固有のIDが振られます。
メソッドIDはメソッド名のFNV1A32ハッシュ値です。(※MethodIdAttribute を付けることで任意のメソッドIDを付けられるようですが、ここでは付けてないものとします。)レスポンスは3種類のフォーマットがあります。どれが送られてきたかは配列の要素数で判別できるようです。
2要素: Receiverメソッドの呼び出し [メソッドID, 引数のデータ本体]
3要素: リクエストに対するレスポンス [メッセージID, メソッドID, 戻り値]
4要素: エラーレスポンス [メッセージID, ステータスコード, エラー詳細, エラー文言]メソッドIDじゃ分かりにくいのでメソッド名で出力してくれるように改造します。
そのため、初めにメソッドIDからメソッド名への変換テーブルを用意します。使う側はこんな感じです。これで以下のようなログが出力されるようになりました。gRPC 側の仕組みに頼らないフィルタの開発が予定されており、
そちらが実装されるとこんな面倒なことはする必要がなくなるかと思われます。


