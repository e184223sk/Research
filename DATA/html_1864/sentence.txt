More than 1 year has passed since last update.条件式というのは何かと複雑になってくるものです。
１つ１つはシンプルなはず。なのになぜ？
そこを複数の視点から解明して実用的に使っていたら3個に集約されました。例えば、stringを正の整数にする関数でint型で返すとします。
仕様としては数字のみで、小数点「.」があれば切り捨てる。「-」その他の文字があれば仕様外ということで常に -1 を返す、とします。また0は許容（OK）とします。
また、nullは-1で、""（空文字）は0とします。tryparse関数がありますが、あえてparse関数を利用するものとして、tryも利用しないこととします。順序としては
1. nullならreturn -1
2. 0と1~9と「.」以外の文字があればreutrn -1
3. 「.」があれば、stringの最初の「.」以降の右側を除去する。
4. 先頭に0があれば除去する
5. ""ならreturn 0上記1~5を行っておくことで、ここに処理が遷移してきた段階では数字のみで来ます。例外エラーが生じない状態で、parse関数を使えますし、万が一にも例外エラーが出るケースがあれば、それに対応できます。多くのケースではtry～catchでよいのですが、例外の内容によって細かく処理が分かれるようなケースでは
このように除外するケースを先に書いておく、というのがとても有用でした。VisualStudio2013の頃から、個人的には匿名関数が好きになってしまったのでご紹介します。
感覚としては関数の中に、その関数専用の特化チョイ関数を書く簡便さで使っています。今では（C#7からは）ローカル関数としてシンプルに記述できます。（コメントで教えて頂きました）のような感じです。yieldのおかげで複雑な処理を複数段に分けて、簡潔な処理記述にできるのですが、
匿名関数のときは IEnumerable  の中で匿名関数が使えずに「仕方ないな」と思っていました。
ですが、ローカル関数ではいけるのでもっと早くにあればよかった、という感じです。
（匿名関数が使えなくても専属のprivate関数を書いた程度の違いではありますが、数ヶ月後の可読性というか
思い出しやすさが違います（汗）ちなにみyieldは個人的には処理手順の段階化（レイヤーを分けられる）・単純化に有用だなと心底思っています。この機能のおかげでオフコン世代のインタープリタ記述のものをプリンタの独自命令にまで変遷させていく、というプログラムを書くことができました。（次の人に説明しやすい構成（のはず・・・）で書けました）


