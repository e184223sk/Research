公開鍵暗号、浪漫ですよね(個人の感想)。個人開発のソフトに組み込んだりとか、実用性は別にして愉快なことができそうです。しかしながら、ざっくりググって見る限り、自分みたいなスクリプトキディが嬉々としてコピペしたくなるシンプル側に極振りした実装がひとところに纏まっているというのが見当たらなかったため、練習のために作ってみました。5%位は実用性を考慮しても良いだろうと思ったので、PythonとC#の2つでシンプルに書いてみて、2者間で暗号データをやりとりしてみます。コレができれば、例えばクライアント側(C#)で暗号化したデータを、サーバ側(Python)で復号、とかができるので、ほんの少しですが実用に与することができます。もっと実用に良い手段があるとか言わない。Anacondaならだいたい全部入りで、暗号化モジュールも入ってるので楽です。Python単体から始める場合、pycryptoをインストールします。1一部の関数が.NET Standard 2.1の適用のため、.NET Core 3.0以上(.NET Frameworkは5.0 RC1)が必要です。これでキーが生成されます。変数key_lengthは1024以上を指定しますが、別の似たモジュールのマニュアルによれば、2048以上を推奨、1024,2048,3072のいずれかにすべき、とのお話。2 今回は長くする必要が無いので1024。生成されたキーは、秘密鍵と公開鍵の2つに分けて保存します。3Pythonで作成した公開鍵ファイルを読み込み、短文を暗号化してみます。サンプルはコンソールアプリ(.NET Core3.1)で作成しています。変数messageはこれから暗号化する文字列です。Python側で作成した公開鍵ファイルpublic.pemを読み込んだ後、ヘッダ、フッタを除いてからbyteに変換、RSACryptoServiceProvider型の変数rsaにImportSubjectPublicKeyInfo()で読み込んでいます。4あとは、バイト列に変換したmessageをEncrypt()で暗号化して、base64変換したテキストを保存します。変換しているのは、テキストファイルとして読めるようにするためです。Encrypt()の第2引数をfalseにすると、PKCS#1 v1.5のパディングを利用します。想定状況では暗号化はC#側で行いますが、Python上でも暗号化/復号化ができることを確認出来るよう、関数を作っておきます。実作業としては、です。最後は復号化です。最後のprint()で表示される文字列が、C#で作成したときのmessageと同一なら、復号化成功です。思った以上に短いコードでなんとかなるもんだ、と言うのが率直な感想です。エラー処理とか実際のセキュリティ面とか実用上の暗号強度とか、細かな設定をすっ飛ばせば、比較的簡単に言語を跨いで暗号化/復号化ができるのが分かってニッコリです。なお、コードは本当に適当なので、実用にしないでください。同種の機能を持つモジュールが複数存在していて(かつ、関数名が微妙に異なったりして)検索時等に混乱の元になってるようです。ここではAnacondaに標準で入っているものを使います。 ↩pycryptoのマニュアルが404になってるんですが、どこに正本があるんでしょう？ ↩実際には、秘密鍵ファイルの中には公開鍵のデータも入っているらしい(?) ↩ImportRSAPublicKey()という、いかにもな名前の関数があるが、こっちが正解。 ↩


