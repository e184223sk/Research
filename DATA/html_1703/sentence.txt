More than 1 year has passed since last update.あるようで、なかったので。Newtonsoft.Jsonの使い方です。DataContractJsonSerializerではありません。JsonConvert.SerializeObject() でシリアル化（オブジェクト → 文字列）、JsonConvert.DeserializeObject&lt;T&gt;() でデシリアル化（文字列 → オブジェクト）。※サンプルなので、Formatting.Indented を指定して、JSONを見やすく改行して出力するようにしていますが、実際には無くても良いです。出力C#では、enumは内部では数値なので、デフォルトでは数値で出力されてしまう。JsonConverterAttributeを使って、StringEnumConverterを指定すると、文字列にできる。出力なぜか、JsonConverterAttributeを付けていなくても、解釈できる。（しかし、シリアライズのことを考えると、JsonConverterAttributeを付けておいたほうが良いと思う）出力Jsonに enum に対応する属性がないと、enum は値型なので、null ではなく 0 に対応する値になってしまう。出力（Role が 0 に対応する Role1 になっている）Json の enum に対応する値が null だと、例外を throw してしまう。JsonSerializerSettingsのDateFormatHandlingプロパティでフォーマットを指定する。しかし、MicrosoftDateFormatとIsoDateFormat(+0900というオフセットが付く、ISO 8601の書式)しか無い。出力JsonConverterAttributeで指定する。出力フォーマット指定ができるConverterが無いので、自分でそういうConverterを作るしかない。IsoDateTimeConverterのDateTimeFormatプロパティでフォーマットを指定できるので、次のようにする。あとは、JsonConverterAttributeを付けるだけ。フォーマット文字列は第２引数で指定できる。ちなみに、フォーマット文字列は DateTime のものと同じです。出力ちゃんとソースコードを見てないが、おそらく内部では DateTime.Parse() が使われているっぽいので、多少ルーズな書式でも読んでくれる。出力ちゃんと書式を指定したい場合は、シリアライズで書いたように、DateTimeFormatConverter を自作して指定する。
※次のサンプルでは、書式を指定しないと、例外が出ます。出力特に何も考える必要はない。出力シリアル化するときに、次のように、DefaultContractResolverでSnakeCaseNamingStrategyを指定して、それをJsonSerializerSettingsに設定する。出力JsonPropertyAttributeの引数で指定する。出力JsonIgnoreAttributeを付ける。出力JsonExtensionDataAttribteを付ける。
※[JsonIgnore]が付いているプロパティでも、[JsonExtensionData]が付いているプロパティに含められる。出力Jsonが key-value 形式になっていて読み込む場合、いちいちクラスを作るのではなく、Dictionary に入れたいときがある。その場合も、JsonConvert.DeserializeObject&lt;T&gt; の T に Dictioanry&lt;string, object&gt; を指定すればいい。出力ファイルや外部のAPIからJsonを読み書きする場合、JsonSerializer を使うと、いちいち文字列を経由することなく、直接読み書きができる。出力json（見やすいように改行とインデントを入れていますが、実際は１行です）まだ不足しているパターンがありそうですが、そのときは追記します。ここに載せた機能以外には、コンストラクタを使ってデシリアライズ、エラーハンドリング、デバッグ出力などがあります。この辺の機能はマニアックなので、書く予定ないですが。


