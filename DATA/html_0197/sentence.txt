　Unityによって階層型タスクネットワークを実装し、以下のデモのようにプランニングと実行をできるようにします。

　Unityのバージョンは2020.2.0f1です。
　プロジェクトはGitHubに上げておきます。
　https://github.com/saragai/SimpleHTN
（イラストの再配布を防ぐために画像がMissingになっています）　英語ではHierarchical Task Networkと呼ばれます。以下HTNと呼びます。
　HTNはその名の通り、タスクを階層的に組み合わせて作られるネットワークのことです。
　HTNはゲームAIのプランニングに用いられます。　プランニングとは、何らかの目標に対して、どの行動をどの順序で行うべきかをあらかじめ考えることです。　例えば、現在家にいて、「新宿駅へ行く」という目標を立てたとします。
　この目標は、最寄り駅が池袋駅だとするとのような方法で実現できるとします。
　しかし、電車で行くとするとお金が必要ですが、お金が手元にないとしたらどうでしょうか。その場合は,とする必要があります。また、足を骨折していた場合はのような方法をとる必要があり、この場合はさらにお金が多く必要になります。　ゲームAIとしてよく用いられるFSMやBehaviorTreeなどは、行動を決定する際に現在の状況しか見ることができません。
　しかし、上の例のようにどのようなルートを通るかで、必要なお金は変わります。その場合、「お金が足りるか」という条件を確かめるだけでも今から行うであろう行動を想定して手動で設定しなければならず、条件分岐が大量に必要になります。　しかし、目標達成までに行うべき行動をあらかじめ列挙(=プランニング)できれば、「お金が足りるか」はおのずとわかるはずです。
　ここで、プランニングを行う際には、その行動に必要な条件と行動の影響がわかっている必要があります。例えば、電車に乗るのであれば、必要な条件は「運賃260円を持っている」であり、行動の影響は「所持金が260円減る・自分のいる場所が池袋から新宿にかわる」です。
　これらの条件を行動自体と合わせてまとめたものを、タスクと呼びます。　改めてまとめます。HTNにおいて、タスクは以下の情報を持ちます。　必要な条件と行動した際の影響がまさにプランニングに必要な要素です。この情報のおかげで実際に行動しなくても仮想的に行動の結果がわかってシミュレーションが可能になります。
　この二つは、どちらもWorldStateと呼ばれる世界の状態を参照します。
　プランニングの際は、現在のWorldStateのコピーを作成し、仮想的にタスクを実行してWorldStateのコピーを更新していくことでシミュレーションを行います。　タスクには様々な粒度があります。
　先ほどの例のように「新宿駅へ行く」はタスクですが、これは「家を出る」「池袋駅まで行く」「電車に乗る」などのタスクに分解できます。さらに「家を出る」は「靴を履く」「ドアを開ける」「鍵を閉める」へと分解できるでしょう。
　逆に言うと、「靴を履く」というような細かい具体的なタスクをまとめることによって「新宿駅へ行く」という抽象的なタスクにして扱いやすくできるのです。　また、抽象的なタスクには複数の表現方法があることも述べました。　この二つの方法の内容に差異はありますが、どちらの分解方法を選んだとしても最終的に目的は達成できるため、同一のタスクとして扱われるべきです。　このような前提から上で述べたタスクをまとめた複合タスクを考えることができます。
　複合タスクは、「目的を達成するための一連のタスク」と「一連のタスクを選ぶための条件」のセットを複数持つものとします。
　この『「目的を達成するための一連のタスク」と「一連のタスクを選ぶための条件」のセット』はMethodと呼ばれます。　この複合タスクも、以下のように確かにタスクの要件を満たすため、タスクと同様に扱うことが可能になっています。　この複合タスクを導入することによって、タスクを階層的に扱うことができるようになります。　ここまででHTNに必要な一通りの要素を解説しました。実装に移る前に用語を整理しておきます。Primitive Task: 最も基本的なタスクのことCompound Task: 複合タスクのことWorld State: 世界の状態。タスクの条件や影響で参照されるPlanner: タスクを一つ設定し、プランニングして実行する行動の順列を割り出すひとPlan Runner: プランを実行するひと　HTNを解説している記事はたくさんありますが、どれもGame AI Pro 12を参考にしているようです。
　以下に疑似コードを引用します。　これについて軽く解説をします。
　はじめに処理スタックにRootTaskを積み、以下の処理を処理スタックが空になるまで繰り返します。……なんかちょっと気になりませんか？
　気になるポイントは二点あります　個人的な理解としてはCompoundTaskはPrimitiveTaskの拡張なので、同じインターフェースによって統一的に扱えるのではないかと思いました。また、スタックに新たなタスクがどんどん積まれていく中で、「最後にCompoundTaskを展開した時まで戻す」がどういう挙動になるのかちょっと想像しにくい気がしました。　もちろんそのまま組んで悪いことは全然ないのですが、そのままの実装については他の記事でもたくさん実装例があるのでちょっと変えてみようと思います。
　気になるポイントへの対処としてはそれぞれ、です。　CompoundTaskとPrimitiveTaskはともにITaskインターフェースを実装します。　唯一のメソッドTryPlanTask()は、WorldStateを受け取ってタスクを実行できるか確認し、実行できるならPlanに追加していきます。このメソッドの中でWorldStateも更新していくことにします。　また、本筋ではないですが、Unityを使った開発ではTaskの設定のためにScriptableOjectを使うのではないかと思うので、ScriptableOjectを継承した抽象クラスも間に挟みます。それぞれ、以下のように実装します。　これは何のひねりもなく、ただConditionを満たしていたらWorldStateをEffectで更新し、プランにOperatorを加えているだけです。　ここで再帰が出てきます。
　階層はCompoundTaskがMethodを介してサブタスクのTryPlanTask()を呼んで再帰することで実現しています。
　再帰で実装すると、「現在の状況を保存する場所」と「その状況に戻す場所」が近く、二つの対応が一目でわかるようになります。　このようにすることでPlannerのコードはとてもシンプルになります。　ここでWorldStateではなくWorldStateHolderを介しているのは、WorldStateをMonoBehaviourにしたくないからです。WorldStateをMonoBehaviorにしてしまうとコピーを気軽にInstantiateできなくなってしまいます。Operatorを表すインターフェースIOperatorを要素とするQueueの簡素なラッパークラスになっています。ここからはデモ用の実装をしながら、ここまで解説なしで出していたクラスについても説明します。
そのため、少し具体的な実装になってしまっています。本来はまだもっと抽象化すべきだと思うのですが、デモを兼ねているということで少し手を抜きました。状態の種類とタスクについてはこのスライドを参考にしています
https://www.slideshare.net/dena_genom/gdm37aileft-aliveWorldStateの種類はenumで指定、値はboolのみとします。
ここでは状態はのみとします。Primitive TaskはCompound Taskはとして、どのような状況でも食べ物を食べるまで行きつくようにMethodを設定します。Operatorで指定される実際の行動は、移動のみとします。Conditionは、WorldStateの種類を指定して、その真偽を問い合わせます。
Effectは、WorldStateの種類を指定して、その真偽を設定します。　Operatorは、用途を考えると多種多様なものが必要になりそうなものなので、少し抽象化します。　OperatorをPlan Runnerが実行するとき、個々のOperatorが何をするかを考えたくはありません。しかし、Operatorには実行対象を渡さないといけないため、実行時はIOperatableというインターフェースを引数で渡すことにします。　また、OperatorはPlannerにおいてはプランニングのキューに入るだけですが、Plan Runnerが実行するときに実際に実行するときはある程度時間がかかるものが多いと思います。そのため、コルーチンで実装します。　行きたい場所を指定してそこまで直進するOperatorとします。
　場所はとりあえずPlaceManagerというシングルトンを作ってそこから取っていますが、細かいところなので適当です。PlannerにRoot Taskを渡して、受け取ったIOperatorのキューに入っているExecuteを順番に呼んでいきます。　上でPrimitive Taskはの3つと言いました。それぞれ以下のように設定します。
・働く
・食べ物を買う
・食べ物を食べる
　全て、実際の行動は指定の場所に行くこととしています。　余談ですが、Unity2020.2からリストがデフォルトでReorderableListになっています。便利です。
　参考：https://zenn.dev/ohbashunsuke/articles/1134c1615efc2b636769Compound Taskの食事をするは以下のように設定します。

これは3つのMethodからできており、それぞれとなっており、これが上から順に評価されて実行されます。　初めに貼ったgifの挙動になります。
　実は今、無限再帰を防ぐための処理を全くしていません。
　例えば、CompoundTaskにおいて、条件は常に真でSubTaskとして自分自身を指定すると無限ループが起きます。
　無限再帰を防ぐために、「同じ条件で同じタスクを与えられたときはスキップする」というような処理が必要です。　そのほかにも、デモでは本当に単純なことしかやっていないので実際にゲーム内で使用するともっと課題が出てくると思います。そのような課題はこちらのスライドなどが詳しいです。　HTNの解説は以前から見聞きしていましたし、Qiitaにもいくつか記事があります。　ですので完全に後追いなのですが、単純に自分で実装してみたかったことと、自分なりの解釈を書いておくことで誰かの理解の助けになればよいなと思ったので記事を書くことにしました。
　HTNのような綺麗な概念の実装は、ログを出して確認するだけだとすぐでも、実際使うことを考えると、どういうクラス構造にするか、データは誰が持つか、という複雑さがあるので、デモが動くところまで出来て良かったです。　ここはもっとこうした方がよい、のような意見があればコメントで教えていただけるとありがたいです。
　ご拝読ありがとうございました。


