More than 1 year has passed since last update.pythonにはnumpyという、数値計算と多次元配列を提供するライブラリがあります。
こいつがあったからこそpythonはデータサイエンスの中心的言語になったと言っても過言でないほどよくできており、numpy前提のライブラリも非常に多く存在しています。僕はC#が好きなのでこういうライブラリがあったらなーと思うんですが、あまりめぼしいものがありません。
多分ほっといてそれらしいものが落ちてくることもないだろうし、それならいっそ勉強半分で作ってみようではないか、と思いたち、開発してみました。そして挫折しました。GitHubのリポジトリはあるのですが、READMEだけだと書きたいことを書ききれないので、使い方、開発中どんな事を考えていたのか、といったことを備忘録の意味も込めてここにまとめます。件のライブラリはこちら
NeodymiumDotNet - GitHubライブラリがどのレイヤーで利用されるかにもよりますが、ユーザーフレンドリーなAPIは何にも増して重要な性能だと思います。使ってて苦痛なライブラリはどんなにパフォーマンスが良かろうと受けが良くないのではないかと思います。ここは譲れないスペックとして先頭に据え置きました。前項にも関連しますが、プログラミング言語のコミュニティが培ってきた文化に逆らったAPIは大抵まともに見れるものにはなりません。開発のきっかけであるnumpyは本当に素晴らしいライブラリですが、pythonの文化に合わせて作られたnumpyをC#にそのまま持ってくるのは文化的にも(何より僕のスキル的にも)無理があります。結局、numpyは参考程度にとどめ、フルスクラッチで開発することにしました。プログラムの実行環境は様々です。特にJITで実行されるC#は生成されたバイナリが多種多様なマシンで実行される可能性があります。そこで、ユーザーが自身の環境・目的に合わせてチューニングできる余地を残そうと考えました。プログラミングには落とし穴がつきものです。サンプル通りに書いたつもりでも些細なミスで動かなかったりやたら重かったり、何時間も悩む羽目になることもしばしばでしょう。本ライブラリではそのような落とし穴が可能な限り少なくなるよう作りたいと考えました。自分の実力では無理なので。とりあえず極端に遅くなければ良しとします。
とはいえ、性能評価はきっちりやっておきます。言語によっては表現の短さは非常に重要です。略語を導入したり、演算子を無理やりオーバーロードしたり、あの手この手の短縮手段が存在します。
しかしながらC#はIDEによるコーディング支援でガリガリ書いていく言語なので、多分そんなに短くしなくても問題ないでしょう・・・読みやすくなってれば。正直言ってこれバグの温床では？という思いが拭えないので。
LL向けの機能としてはなかなかありがたいんですけどね。LINQ to NdArrayにより、スカラ値の加減乗除算にブロードキャスティングの必要がなくなったというのも大きいです。LINQ to NdArrayですが、実は即時評価になっています。設計当初はto Objectと同様遅延評価になっていたのですが、パフォーマンス面で壁にぶつかったときに遅延評価だと詰んでしまうと判断し即時評価に作り直しました。まあ、キャッシュ取るせいでメモリの節約効果はまったくなかったのでその点では特に問題ないですが。イミュータブルなら即時でも遅延でも結果が変わらないですし多分許されるでしょう。基本設計はそのままなので遅延評価用の機構はそのまま残っている状態ですが、手を加えようとするとかなりの大改造なので据え置きにしています。行列演算ではシェイプが合ってないと計算できないケースが非常に多いので、契約プログラミングによる静的検証が適用されていれば非常に効果的にコーディングできると思われます。
そんな訳で、本当はちゃんと導入したかったんですけどね・・・。当初はCode Contractsを全体に仕込もうとしたんですが、やはりお亡くなりプロジェクトということで諦め。csharplangにはMethod Contractなるプロポーザルも上がっているんですが、全然音沙汰ない様子。
nullable reference type入ったから優先度落ちてるのかな・・・。行列演算では大量のメモリ領域を確保しては破棄するといったことが起こりえます。
場合によっては演算途中の一時変数として即使い捨てられるということもありえるでしょう。.Netでは、ある程度大きなオブジェクトはLOH送りとなりGCによる回収が大幅に遅延するという仕様があります。
これは、大きなオブジェクトは寿命も長い傾向にあるという事実に基づいた設計ですが、行列演算とは相性がよくありません。そこで登場するのが配列プールなのですが、これは借りた配列を明示的に返却しなければなりません。
かといって確保するNdArray&lt;T&gt;すべてをIDisposableにしていくというのはあまりに使い勝手が悪くなってしまいます。そして、最終的に以下のような実装に落ち着きました。はい、デストラクタです。
いまどきのC#でDisposeパターンでさえないデストラクタを使うことになるとは想像もしてなかったのですが、使い勝手まで考えるとこれが妥協点でした。NeodymiumDotNetで最も基本的な型はNdArray&lt;T&gt;です。
その名の通り型Tのジェネリックな多次元配列になっており、NdArray.Createメソッドで作ることが出来ます。
要素のアクセスは普通にインデックスを使ったり、平坦化インデックスを使ったり。スライスにも対応します。不変性の保証で性能向上の余地を取り1、また値変更に起因するバグのリスクを減らしたりするために、NdArray&lt;T&gt;はイミュータブルです。
要素を直接編集するならミュータブル版のMutableNdArray&lt;T&gt;に変換してやる必要があります。NdArray&lt;T&gt;はIEnumerable&lt;T&gt;を実装していません。意図せずLINQ to Objectに繋がって型が落ちたりパフォーマンスが落ちたりといったことを防ぐためです。LINQ to Objectにつなぎたいときは明示的にAsEnumerable()を呼んで変換する必要があります。
かわりに、NdArray&lt;T&gt;専用のLINQであるLINQ to NdArrayを用意したので大抵はそれで事足りると思います。LINQ to NdArrayは演算子適用の役割を含んでいます。
numpyの場合、次のように多次元配列同士に演算子を適用することで要素ごとに演算した結果を得ることが出来ます。しかしながら、静的型付け言語であるC#において総称性と演算子適用をどう両立するか非常に悩みました。
その結果、次のようにLinqのZipを用いるAPIを採用することにしました。これにより要素間の演算は厳密な型検査が入るようになり、また組み込み演算子のみならず任意のメソッドを流し込めるようになりました。特に下の書き方は対称性が良いため結構気に入っています。
何よりこれを導入した結果、numpyのように膨大な数学関数APIを用意する必要がなくなり非常に楽になりました。また、Linq演算子には反復手法を切り替えられるようなAPIも用意しています。ただここら辺はSIMDに対応できないのでParallel.ForかAlea GPUくらいしか適用先がないんですよね・・・。
もっとうまい方法を模索したいところです。集計関数や行列関数もある程度用意しました。
特に行列演算の方は、愚直な実装なのでクッソ遅いままですが・・・。これらの演算は、必要な演算子がTに用意されていれば型によらず適用可能です。最速のジェネリック特殊化を目指してで検証した結果2とリフレクションによる演算子オーバーロードの探索を駆使したトレイトが裏に仕込んであります。その他には乱数生成器があったり、.npyシリアライザがあったりしますが、ひとまずはここまで。多次元配列ライブラリである以上、あまりに遅いと使い物になりません。
そんな訳で、ここまで作ってベンチマークを取ってみました。比較用にnumpyも計測。
謎のベンチマークフレームワークを使っていますが、BenchmarkDotNetに似せた自作のなにかなので、あくまで参考値程度に見てください。$n$x$n$のdouble配列を加算。ネイティブ配列に対するオーバーヘッドは2～倍程度。
演算子をデリゲートに押し込んでforで回すのは流石にオーバーヘッドが大きいのか。次元数が小さいうちはパラレルのメリットは小さい模様。
総要素数10000くらいが並列化の目安かなぁ・・・。そしてこの時点ですでにnumpyが速い。
中身BLASなんだろうけど、やはりSIMD並列化あたりが入っているのか。100x100の行列式も評価。もう少し高度な行列演算では圧倒的に遅い。
実数についてはやっぱBLAS/LAPACKで差し替えたほうがいいのかなぁ・・・。
バックエンドの対応が不完全であろう四元数などが相手ならもう少し戦えるような予感はする。シグニチャの設計はそこそこがんばれたので一応は決着をつけられたという感じ。
やっぱりパフォーマンス上げるは僕の腕ではこれが限界でした。自分ひとりだとこれ以上どうにかなるとも思えないので、提案・指摘・改善策等いただけたら幸いです。遅延評価機構の名残ともいう。 ↩そもそも当該記事はこのライブラリを作成するための検証結果をまとめたものという側面もありました。 ↩


