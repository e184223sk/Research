More than 1 year has passed since last update.Azure素人の自分がMicrosoft AzureのBot FrameworkとCognitive Serviceと触れ合いながら、難易度も人への接し方も“やさしい”チャットボットを作ってみた際の備忘録の第3部です。どんなチャットボットを作るのかを含め、これまでの手順は第1部、第2部にございます。
PowerPointで記録していたものをQiita化してみたものになるので、そんな感じの画像が頻出します。
Qiita初心者なので、書き方が下手でも広い心で許してほしいです。そして全体的にゆるいです。以下の5部構成になります。この記事は第3部にあたります。なお、公式ドキュメントに沿って作りましたので、それらのリンクを張り付けつつ、辿った道筋通りに書いていきます。
その筋の方からすると遠回りだったり野暮ったかったりすると思いますが、ご容赦ください。これまで、第1部で作ったソースコードを、第2部でAzure（クラウド）上へデプロイしましたので、今回はユーザーから受け取ったコメントをAzure Cognitive ServiceのText Analyticsを使って、ネガティブorポジティブの判定をしてみたいと思います（図中の赤枠部分）。
今回の作業は公式ドキュメントのクイック スタート:Text Analytics クライアント ライブラリを使用するを参考にしています。
なお、最新のプレビュー バージョンは 3.0-previewとのことですが、今回は安定版である2.1を使ってみました。まずは上記リンク内の「前提条件」の部分に従って、以下を準備します。第2部で準備済みかと思いますので、それを使います。第1部で使ったVisual Studio 2019を使います。Azure portal を使用して Cognitive Services リソースを作成するのクイックスタートに沿って、Text Analyticsリソースを作成します。こちらは割とつまずくところもなく、公式ドキュメントそのままで作成可能なので、そちらを参照いただいても大丈夫かと思います。リンク先の新しい Azure Cognitive Services リソースを作成するのところで、単一サービスリソースのタブから、Text Analyticsを選択します。すると、AzurePortalへ自動で飛ばされ、TextAnalyticsリソース作成の画面に移りますので、それぞれ値を設定していきます。
全ての項目で設定ができたら、左下の作成ボタンをクリックします。少し待つと、デプロイが完了しました、という画面になりますので、リソースに移動ボタンをクリックします。
APIキーとエンドポイントが表示されます。後程使いますので、コピーしておいてください。
ここから先、コードを書いていきますが、筆者はコーディング力は皆無（とりあえず動くものを作るだけ）なので、清く正しく美しいコードを書けるようになりたい方は、参考にしすぎないようにしてください。ごめんなさい。公式ドキュメントだと、新しいアプリを作成するところからですが、第1部で作成済みなので、そちらを使っていきます。プロジェクトを開いて、ソリューションエクスプローラーからソリューション名を右クリックし、NuGetパッケージの管理を選択します。
NuGetパッケージマネージャーが開いたら、Microsoft.Azure.CognitiveServices.Language.TextAnalyticsと検索し、パッケージをインストールします。
公式ドキュメントではprogram.csへの追加の手順が記載されていますが、今回はEchoBot.csに全てまとめてしまおうと思うので、EchoBot.csの上の方（usingほげほげが書いてあるところ）に以下の通り追加します。これは、公式ドキュメントに書いてあるものと、EchoBot.csに元々書いてあったものの差分です。追加するとこんな感じになります。わかりやすいように、今回TextAnalytics連携のために追加したコードの上には、//for TextAalyticsと書いてあります。
次に、public class EchoBotに、先ほど作成したTextAnalyticsのAPIキーとエンドポイント（リソースのキーを取得するで表示されたもの）を以下の通り追加します。追加すると、こんな感じになります。
さて、いよいよ、TextAnalyticsとの連携部分を作っていきます。公式ドキュメントでは新しく.NET Core コンソールアプリを作った例になっているため、Mainメソッド（アプリを実行したらまず開始される部分）を書き換えるように書いてありますが、今回の場合はユーザーが話しかけてきたら発動するようにしたいので、以下の2行をOnMessageActivityAsyncのタスク内に追加します。各メソッドの処理内容としては以下の通りです。authenticateClient()
新しい Azure Cognitive Services リソースを作成するで作成したTextAnalyticsリソースを、このボットアプリから利用するための認証をする。sentimentAnalysisExample(client)
authenticateClient()で認証されたTextAnalyticsリソースを使って、任意のメッセージの感情分析をして、スコアを得る。追加するとこんな感じになります。この状態だと記載したメソッドの本体が存在しないため、赤い波線が出てエラーになってしまっていますが、一旦無視してください。
このボットアプリから、先ほど作ったTextAnalyticsリソースを使えるように認証をするため、authenticateClient()の中身を作っていきます。以下のクラスを追加します。クラスなので、public class EchoBotと同じレベル（クラス名の左側の深さを合わせる）で記載します。追加するとこんな感じになります。
次に、先ほどエラーになっていたauthenticateClientを呼び出せるようにしていきます。public class EchoBotに戻って、以下を追加します。既にpublic class EchoBot内にある、他のタスクと同じレベル（深さ）に記載します。追加するとこんな感じになります。
次に、もう一つエラーになっていた、SentimentAnalysisExample() というメソッドを作成します。ここで、感情分析をするテキストの指定と、その結果の受け取りをします。以下のコードをpublic class EchoBotに追加します。こちらも、既に存在している他のタスクと同じレベル（深さ）に記載します。ここでは、サンプルとして、「I had the best day of my life.」という英語の文章の感情分析をしてみています。追加するとこんな感じになります。
ここで、Debug.WhiteLineの部分にエラーが出ていることに気づくかと思います。これは、拡張機能が不足している（上の方でusingしているものが、Debug.WhiteLineを使うのには足りていない）ために起きています。Debug部分にカーソルを合わせて、考えられる修正内容を表示するを選択し、using System.Diagnosticsの追加の提案を受け入れてください。すると自動的にソースコード上部にusing System.Diagnosticsが追加され、エラーも消えます。さて、この状態で、一応ボットアプリ→TextAnalyticsリソースの利用はできるようになっていますので、一旦▶IIS Expressからローカルで実行し、Bot Framework Emulatorでボットに話しかけてみてください。
こんな感じで、出力画面にSentiment Scoreが出てきたら成功です。現時点では、ボットに話しかけたメッセージの分析ではなく、ソースコードに直接書いた「I had the best day of my life.」の分析結果ではありますが、きちんと値が返ってくれば、ボットアプリからTextAnalyticsリソースを利用し、分析結果を得ることができていることの確認ができます。次に、ユーザーのメッセージをTextAnalyticsで分析するように、ソースコードを変更します。ユーザーのメッセージが入っているのはOnMessageActivityAsync内のturnContext.Activity.Textの部分ですので、これをSentimentAnalysisExampleメソッドに渡すように、コードを変更します。具体的には、sentimentAnalysisExampleの引数に、turnContext.Activity.Textを追加します。このような感じになります。
次に、受け取るsentimentAnalysisExample側も変更が必要ですので、以下の通り変更します。このような感じになります。
ここまで変更したら、またアプリを実行して、ボットに話しかけてみましょう。今度は日本語で、意味のある言葉を投げかけてみてください。このように、話しかけた内容と、分析結果のスコアが返ってきていれば成功です！現時点でのEchoBot.csのソースコードはこのような状態になります。以降の工程はこのようになっています。
次回はTwitterと連携して、感情分析の結果がネガティブ判定だった場合、偉人さんのありがたいお言葉を返す部分を作ってみたいと思います。


