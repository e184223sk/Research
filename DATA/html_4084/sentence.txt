More than 1 year has passed since last update.本記事はconstとreadonlyとstatic readonlyの違いと使い方に対して解説したものとなります。また本記事は一度昔に個人ブログにあげていたものに修正を加えて再掲したものとなります。定数や、それに似た数を宣言する際に使用します。定数とはその名の通り、値が固定されて今後変更しないとわかっている数のことで、定数に格納された値は、アプリケーションの実行中に変わることはありません。なので、例えば時間が経つにつれて変更される可能性がある情報を表すために定数を使用するべきではないです。定数には、数字、bool、文字列などのプリミティブ型などが含まれています。また、定数を使用する目的としては、マジックナンバー・文字列定数入力ミスの削減があげられます。宣言をするに当たって、C#ではconst , readonlyが使用され、C++ではdefine , const , constexprが使用されます。今回はC#の機能にフォーカスを当てて解説を進めていきます。 
コンパイル時定数は、コードがコンパイルされる時点で計算されて値が決定されると規格によって定められた定数です。なので定数の型はコンパイル時に確定できる値でなければなりません（プリミティブ型や文字列型だけでnewはできない）。任意の参照型を定数にすることも可能ですが、インスタンスはコンパイル時に作成できないのでnull参照以外は定数にできません。主に固定長配列のサイズや列挙型の定義などに使用します。以下がconstの特徴です。メソッドのデフォルト値もconstと同じ挙動となります。こういったケースが困る場合は、オーバーロードを複数個定義したほうが幸せになれます。 
定数は宣言時に値が確定している必要があります。しかし、アプリの実行後の値を取得し、定期的に使いたい時にはreadonlyを用います。これは実行時まで確定はできないが、初期化後は不変な値となります。定数と意味合いも似ていますが、定数ではなく読み取り専用な変数なので特徴も異なります。以下がreadonlyの特徴です。ちなみにJITについては以下で解説しています。
Unity開発するにあたって知っておきたいコンパイラのすゝめ(Part0.7～JITとAOT概要編～) 
Effective C#では、バージョニング問題の観点からconstよりもstatic readonlyの使用が推奨されています。readonlyは読み取り専用であることを表明するのに使用すると良いです。constはconst対象がprivateである場合、又は高いパフォーマンスが求められていて、 なおかつ将来にわたって変更されることがないことが明らかな場合にのみ使用するべきでしょう。そうでなく、将来変更される可能性のある値を定数として公開する場合にはstatic readonlyの使用をお勧めします。


