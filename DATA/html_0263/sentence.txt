この記事はC# Advent Calendar 2020の16日目の記事です。
これはもともと.NET Core 3.1で作ってあったWPFアプリを.NET 5に移行して、nullableなどのC#8, 9の言語機能を実装してみた記録です。変更点はWPFとはあまり関係ないので、C#であれば他のフレームワークにも参考になるかもしれません。
WPFアプリの中身はファイルリネーマーです。アプリの詳細はこちらで。コード行数850行ぐらい、クラス数40個ぐらいのサンプルアプリに毛の生えたぐらいのコードサイズです。
修正点はたくさんありますので、全部の修正はCommit履歴の2020/12/13日のCommitを見てください。まずは.NET 5 👇何かエラーするかと思いきや特に問題はないですね。.NET Frameworkからだったら何か起きたかも？次にnullableを有効化します。警告がたくさん表示されます。nullableという名前とは裏腹にnullに対して非寛容なコーディングを心がける必要があるようです。これらを1つずつ潰していきます。警告ついたところにすべて ? をつけて回っても良いいですが、それではnullableにした意味がありませんので、できる限りそれ以外の方法でやります。その中で興味深かった点をいくつかあげてみます。指定したファイルパスのディレクトリを作成する処理で、以下のような警告が出ました。これは指定したパスのディレクトリパスを取得する Path.GetDirectoryName() がnullの可能性があるstring?なのに対し、ディレクトリを作成する Directory.CreateDirectory() はnullを許容しないために発生します。そこで、以下のように変更しました。すると警告が消えました。ただ Directory.CreateDirectory() に渡しているのは変わらず string? のままです。しかし、コンパイラがフロー解析することで、ifの内側ではnullでないことが保証されているわけです。以下のようにnull非許容型の配列にnullの可能性のある要素を入れると警告されます。
FileInfoは例として使っただけで、classならどれでも同じです。では、nullの要素をWhereでフィルタリングすれば、コンパイラさんも分かってくれるでしょ！としても。。。コンパイラには伝わらないようです。そこで以下の記事を参考にnullの可能性を無くすWhere、中身は OfType() の拡張メソッドを作りました。
nullを取り除くLINQ Where [null許容参照型]
OfType() を直接使っても良いですが、型を書くのを省略できますし、意味も明確です。これで警告がでなくなりました。ReactivePropertyはIObservableから生成しようとすると、nullの可能性があると警告が出ます。ReadOnlyReactiveProperty&lt;SettingAppViewModel?&gt; にしたら？という警告が出ますが、 model も Setting もnullの可能性がないため、settingVM1もそのValueもnullになることはありません。
コンパイラもmodel も Setting もnullの可能性がないことは把握していますが、
ToReadOnlyReactiveProperty() の返り値がnullの可能性があるとみなしているようです。型を明示的に非許容型にすれば、警告は無くなります。一方で確実にValueの初期値はnullになる以下のようなコードは警告が出ません。なかなか不思議な挙動ですが、今後のReactivePropertyの更新などで変わってくる可能性はありますね。上に書いたPath.GetDirectoryName()は定義をみると、返り値の型に?が付いていますので、null許容型であることがわかります。
逆にPath.GetFullPath()はnullでないことも保証されています。しかし、以下のようなコードは警告が出ませんが、実行するとNullReferenceExceptionが発生します。どこにも配置されていないTextBoxのParentはnullなので、これは間違い。この2つの違いはライブラリ自体がnullableかどうかですが、それを知るためにはクラス定義を見に行き、#nullable enableがあるか確認する必要があるようです。var の逆でコンストラクタの型名を省略できるものです。引数ありでも省略できます。
DictonaryやReactivePropertyなどのジェネリック型を使用する場合などは記述がスッキリして良いですね。👇上のパターンはよくサンプルとして挙げられますが、変わった例ではタプルを使わなくなったというケースがありました。元々はこんな感じに、引数を指定してnewした、クラスの配列を生成しているところがありました。これの型名を何回も書くのが、面倒だなと思って、列挙時はタプルにして、あとからクラスに変換していました。new 型推論が使えるなら、最初の型名が冗長という問題も無くなりますので、タプルなしで直接newした要素の配列を生成するようにしました。否定の条件を!ではなくてnotで表現する。ちょっとVBっぽい。
dがButtonBaseでなければreturnするコードです。👇より複雑なケースでは以下のようになりました。
parentのVisualTree上の親を順番に遡り、nullかDataGridCellsPresenter以外のItemsControlに到達したら、whileから抜けるコードです。👇比較対象のparentを書く回数が減りました。
is not null and notは見慣れればわかりやすいのかな？ちょっとまだ頭が追いつかないです。いくつかのプロパティが全て読み取り専用のクラスをレコード型に変更しました。👇かなり簡潔になりましたね。ただコンストラクタを自分で書かなくなったため、get-onlyプロパティの初期化はプロパティ初期化子にのみ限られます。したがってメソッドも使えません。またプロパティに対してXMLコメントをつけることもできません。
recordキーワードの上あたりに引数のコメントをつけられますが、これはプロパティのコメントではないので、プロパティのコメントとして表示はされません。いくつかのクラスをレコードに変更しましたが、元々get-onlyのプロパティだけのクラスであれば、使用側は何も変えなくても大丈夫でした。C#8, 9の知識がうっすらある状態で1日かければ修正することができました。
最も大変だったのはnullableですが、これもとりあえず?つけとく、みたいな対応ならすぐに終わると思います。
ただ1日やっただけでも、nullの可能性がないことが保証された状態でのコーディングは心理的安全性が高いことが分かります。そうするとよりnullの可能性を狭めたくなってきます。
new 型推論やレコード型など記述が簡潔になる構文が増えるのは嬉しいですね。パターンマッチングは名前通りいろいろなパターンがあって把握しきれていませんが、複雑な条件分岐などで威力を発揮しそうです。https://ufcpp.net/study/csharp/cheatsheet/ap_ver8/
https://ufcpp.net/study/csharp/cheatsheet/ap_ver9/VisualStudio 2019
C# 9
.NET 5
ReactiveProperty 7.5.1


