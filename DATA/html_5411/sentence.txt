More than 1 year has passed since last update.フィボナッチ数は再帰的に定義される数列で、次のように求められます。しかしこれをそのまま使うと、大きな index を渡した時に長大な時間がかかります。
計測してみましょう。結果は次のようになりました。Fibonacci(40) を求めるのに 3 秒かかっています。
次は Fibonacci(45) を求めてみます。約 37 秒かかってしまいました。40 から 45 になっただけなのに 3 秒から 37 秒への増加は多すぎるように思えますが、このように素直に実装すると時間は鼠算式にかかるようになります。
これは内部で同じ計算が何度も繰り返されていて無駄があるからです。メモ化とは、一度行った計算をメモしておいて次回からはその結果だけ返す方法のことです。
このようにとてつもない勢いで計算量が増えるアルゴリズムを実装する際に役立ちます。まずは何も言わずに次のソースを Memoization.cs という名前で保存し、プロジェクトに追加してください。
無駄に難しいので読まなくて結構です。さらに Program を書き換えます。
しかし、ほとんど変える必要はありません。
using Zuishin; が増えたのと Fibonacci() に [Memoization] 属性がついたのと、Main() の中身だけです。
おっと、Program は public にしておいてください。これを 40 で計測してみます。結果は劇的です。[Raw] は先ほどと同じ方法でメモ化を使わず演算しました。ほぼ変わらない 3.5 秒という数字が出ています。
[Memoized] の方はメモ化が有効になっていますが、0.005568 秒という結果になりました。Main() の中身を見てみましょう。memoized と raw の違いはオブジェクトの生成方法です。raw はコンストラクタを呼び出していますが、memoized の方は先ほど追加した Memoization クラスの Create メソッドを使っています。
たったこれだけでメモ化が有効になります。Memoization クラスを使ってメモ化できるメソッドには次の条件があります。以上の条件を満たすメソッドに [Memoization] 属性をつけることでメモ化が有効になります。
条件を満たさないメソッドは単に無視されます。メソッドが二回以上呼び出された時、すべての引数(今回は index の一つだけ)が以前と同じ値であれば、メソッド本体を呼び出さずメモした値を返します。


