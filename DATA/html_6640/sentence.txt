More than 3 years have passed since last update.詳細はネットのページを見て欲しい。（というのも自分がそんなに理解してないので説明できない）
「とりあえず処理を分割して、ちょっとずつ進めてくれる」という仕組みに見える関数内で大規模なfor文まわしたときに、フリーズに近い状態になり、進行状況が分からなくなる。
そのときにコルーチンを使うと、逐一updateされる。とりあえず戻り値にIEnumeratorを設定して、中にyield return nullを書いて
呼び出すときにStartCoroutine(関数呼び出し);とやればいい模様。以下はボタンを押すとfor文を回す処理。
for文の途中でcurrent_processを設定しており、そこで進行状況を逐一updateする。
ところがコルーチンを使わないと、画面上ではフリーズに近い状態になり、処理が終わるまで進行状況は出てこない。（つまりボタンを押すと、フリーズして、最後に終わったと教えてくれる。それでは意味がない）以下のようにコルーチンを使うと、進行状況が逐一報告されるようになる。for文に使ってみて気づいたが、入れる場所によって処理スピードがぜんぜん違う。外側のfor文(浅い)に入れるほど早くなる(呼び出される回数が減るから？）
内側のfor文(深い)に入れるほど遅くなる(呼び出される回数が増えるから？）「どのレベルまで更新情報が必要か」と
「どのレベルまで処理速度が必要か」の天秤なのかも。「yield return すると、「そのフレームでの処理」はそこで終了するので、外側の for に入れると 1フレームでの処理が増える事になって、早く処理が終わる事になります。ただ、逆にフレームに費やす時間は増えるので、固まった様に見えるかもしれません。
天秤ですね。
固定で yield return するの微妙なので、1フレームで何秒まで処理させていいかという値を決めておいて、それを超えそうだったら yield return する、みたいな形にすると安定すると思います。」コルーチンは連呼しないほうがいい。


