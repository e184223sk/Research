More than 1 year has passed since last update.これは、C# その2 Advent Calendar 2019の20日目の記事です。個人的にC#を使っていて、こんな機能有ったんだとか、こんなコトできたんだみたいなあんまり役に立たないけどクスリと笑えそうなモロモロをセレクトしてみました。なので、既知だよ～って言う突っ込みは無しの方向で一つ、ご笑覧頂ければ幸いさて、1つ目はconstに関するお話。constが引き起こすあれやこれやは別として、以下のように書けちゃったりする。このように、クラスや構造体のフィールドだけでは無く、メソッドやプロパティの中にも書ける。ちょっとしたベンチマークテスト書きたいときとか、constでパス指定とかしたり、iteration何かを定数化しておくと、わざわざ書き直す必要も無いし、変数と違って途中で書き換えが出来ないのでわりかし便利かも知れない。C++で完全修飾名にするときとか、std::coutみたいに書くけど、これに近いことが出来る…けどかなり用途先が限定されている。実例は以下の通り。かなり回りくどいけど、usingエイリアスディレクティブを使って作成した名前空間のエイリアスに限り::を使って修飾が可能になる。なので、System::Consoleみたいなことは書けないので注意。ただこれ、当然一般的なメンバアクセス演算子.使って、new txt.StringBuilder()でも全然イケてしまうので通常はそっち使った方が良いと思う。じゃあなんでこれが必要かというと、名前被っちゃったときの対策とのこと。実例は以下命名則としてどーよというのは激しくあるけど、早い話上記みたいなシナリオでどっちを呼ぶのか弁別する必要があるので、この演算子が必要だったとのこと。また、子細は以下に譲るけど、唯一この演算子でしか解決できないモノにglobal::ってものがある。ただ、繰り返しになるけどエイリアスはソースコードのファイル単位のスコープしか持ってないので、こんなことしなければならないって言うのは、割と問題があるケースが多いと思うし、書くなら書いたで書いた理由は説明できないとマズいかなとは思う。C#のver6から導入されたクラスや構造体の静的メソッド/プロパティを修飾無しで呼び出せるdirectiveだけど、実はこれ、それだけじゃ無く、指定されたクラスや構造体の入れ子になっているクラス/構造体も修飾無しで呼び出せる。下記のようなアセンブリがあったとしてこいつを、参照してるコンソールアプリあたりでこんな風に書ける。最初、文字通り、静的な諸々のみが修飾無しで呼び出せるだけだと考えていたので、ちょっとびっくりした。また、当然入れ子になったクラス/構造体に対してもusing staticは使える。使い道としては、割と局所的だし、こじつけっぽいけどメソッドの階層化とかにはちょっとだけ使えるかもとは思ったり。こんな風に書いておけばこんな感じ書ける。ただまぁ、何かそれほどありがたみが無いなぁって感じが強い。C#にはnew修飾子ってのがあり、有り体に言えば継承された諸々を明示的に隠蔽することが出来る。で、これ別にvirtualのついて無いメソッド/プロパティだけじゃ無くありとあらゆるモノが隠蔽できる。メソッドやらプロパティでも割と混乱するけど、フィールドになるとそいつに拍車がかかる。名前は一緒だけど別々に割りあてられてるメンバフィールドって言う扱いになるので、どー修飾されたかで結果が変わるという地獄絵図にw同様に、Nestedクラスに関してもBase.Nestedと、Derived.Nestedが別個の実体として存在するので、管理が面倒なことになる。この隠蔽に関しては、利用側が隠蔽されているのか否かをすぐにわかりずらく、また一般とは違うメンバールックアップが行われるので余程強い理由があるときに限り使うべきだと思う。特にフィールドに対する隠蔽は同名のフィールドが別々に存在するというどー見ても地雷踏みそうな状況を作るので、余程のことがあったとしても使うべきじゃないし、こんなことするなら設計が歪んでいる方をまず疑うべきじゃ無いかと思う。ローカル変数を初期化しないまま参照しようとした場合、コンパイルエラーになるけど、フィールドに限っては部分初期化に対応している。以下のように書いた場合13行目でコンパイルエラーになることは無い。但し、これはフィールドに限った話で、部分初期化しかされていない状態で、直接関係の無いメソッドやプロパティの呼び出しを行うと,いつも通りCS1065が発生する。用途としては、まさにさっきのタプルの例のように、一部を初期化して、初期化済みの値を使いつつ他のフィールドの初期化を行う時には少し使い道があるかな?と思える程度。ただ、とち狂ったことしても問題が局所化されやすいしコンパイルエラーになるので、危険性はそこまで無いかなとは思ったり。VisualStudioであれ、Riderであれ新たにソースコードファイルを作成すると、規定の名前空間に従った名前空間が作成されてその空間の中に各種実装を書いていくのが一般的じゃ無いかなと思う。それじゃ、名前空間にくるまず以下のようなモノを書いたとしてこいつを、同一プロジェクトの名前空間にくるまっている先から呼び出したり、参照している外部アセンブリからどのように見えるかというと、実はusingすら不要で可視になると、このように、名前空間の修飾無しで呼べてしまう。このように、名前空間に含まれていない実装はグローバル名前空間という名前空間に存在することになる。じゃあ、以下のようなシナリオはどうなるだろうか?名前が衝突してコンパイルエラーに成るのでは無く、同一名前空間へのルックアップが優先されて、修飾無しの場合はAdvent.NoEnveloped、Advent.OutOfNameSpaceと解釈される。それでは、名前空間の外にいる諸々を呼び出したい場合、先の::のくだりで出ていた、global::を使って修飾することで指定可能となっている。で、こんなことは現時点における自分の思慮では絶対にやっちゃいけないと思う。名前空間は多数のアセンブリを参照する上で、名前の衝突を防止する強力な手段なのにそいつをバイパスしちゃうのは極めてマズいし、global::で弁別可能とは言え、混乱の原因になるのでその観点からもマズいと思う。Advent Calendarにあわせて、C#で遊んでいておや?と思ったことをつらつらと書き連ねてみました。タイポしてたことに、コンパイル実行後に気づいてアレ通っちゃった?!となるパターンと、.NET Coreのコードリードしていて、あらまこんな書き方出来たんだってコトが今年結構有ったので、サクッと読んでクスリと笑ってもらえるかなって感じで書いてみました。とは言え、グローバル名前空間や、new隠蔽に関しちゃ結構危険な匂いがするので積極的に使うもんでも無いと思うし、逆にローカルconstあたりは知っていればもっと早くから使いたかったなんてこともあったりなかったり。来年も読んで頂いた皆様が素晴らしいコーディングライフを送れることを祈念しつつ、Merry Christmas!&amp;Happy New Year!


