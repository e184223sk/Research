More than 3 years have passed since last update.C#のforeachの仕組み(2)にコメントしようかと思ったけどこっちへCPU命令(機械語)やアセンブラで書いていた時代のスタイル。
今でもCPU命令レベルではこれに近いことをやっています。ループ処理は頻繁に使う割には原始的スタイルだとけっこうな長さを食うため、「初期化」「終了条件」「次へ進む処理」をまとめて書くfor文が考案されました。
たぶんFORTRANあたりから。foreach(のようなもの)はスクリプトが発祥だったと思います。1昔は処理が遅かったこともあって、スクリプトはインタプリタ処理なので速度が遅いため簡略化した記述が好まれ「リストを渡せばリストの要素数分だけループする」というカウンタ変数や終了条件を省いた記述法が生まれたのでしょう。普通のプログラミング言語でも「配列の中身を一つずつ取り出して処理」というのはよくあります。
ループカウンタは配列のインデックスと終了判定にしか使っていないことも珍しくないです。
なのでそういう処理のための省略記法としてforを簡略化したforeachを導入する言語も出てきました。「複数の要素を格納したデータ」は配列が多いけど他の形もあります。
ディクショナリ(ハッシュ)とかスタックとか二分木とかリングバッファとか。
そういうものに対しても「格納された要素を一回ずつ取り出し、全部の要素を取り出し終わったら終了」という統一された手法が使えると便利。
ループカウンタのかわりにイテレータを使うことで同じようにfor文のループで処理できます。「イテレータでぐるぐる回すfor文」というのはだいたい同じような書き方になります。
「次へ進む処理」と「終了条件」はイテレータが処理するので、for文はイテレータが「もうないよ」と言うまで「次の要素を渡して」というお願いを繰り返すだけだから。
だったらforeach文に要素のリストを渡すと勝手にイテレータを作り、繰り返し処理のたびにイテレータに次の要素をもらえばいいだけです。すっきり！でもこの時点でループカウンタ/イテレータの存在はソースコードから消えてしまうので、古典的なループ処理に慣れている人は「今どこまで処理したかを覚えてる変数がないのになんで『次の要素』がどれなのか把握できるの？」と戸惑います。
私も最初のころは気になってました。単に隠してるだけだったというオチ。リスト(コレクション)から内容を一つずつ取り出してそれに対して処理を行うなら、SQLクエリの結果リストと同じように処理できる、どんな形で格納されているかは気にする必要はない、必要なのはデータ集合から一つずつ要素を取り出し、全部取り出し終わったら終わることだけ。
つまりSQL文がテーブルの内容やサブクエリの結果データを集計したり加工して別の結果データを作るように、テーブルをコレクションに置き換えてもよく似た処理ができる、元データとなるコレクションに必要なのはアクセスするためのenumeratorを持っていることだけ。
という発想からLINQ to Objectsは生まれたんじゃないかなと思ってます。foreachでかなり便利になってfor文を使う機会は減ったけど、foreachやLinqは「元となるデータ集合ありき」なループ処理です。
ループカウンタを「データ集合のインデックス」以外の目的でも使う場合は、明示的な変数として見えていないと困ることもよくあります。
同じようなことをするのにたくさんの方法があるのは混乱するしめんどくさいですが、上手に使い分けたいですね。UNIXのBourne Shellの「for~in文」あたり？ ↩スクリプトの変数は式に応じて数値になったり文字列になるのでそれなりに重いです。インデックスを隠し変数にすることで整数型に固定できるだけでも高速化の効果はあるでしょう。 ↩


