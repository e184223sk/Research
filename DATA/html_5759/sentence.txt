More than 3 years have passed since last update.この記事は、XAML Advent Calendar 2017の10日目の記事です。ViewとViewModelをどうやって紐付けるかはMVVMでは一度は必ず悩む問題だと思います。
私はDataTemplateでViewModel→Viewの登録を行うことが多いです。
しかしVisualStudioでのデザイン時データコンテキスト(d:DataContext)ではその登録とは別に、ViewModelを指定する必要があります。そこでデザイン時にDataTemplateの情報を元に適切なViewModelを自動配置してくれるMarkupExtensionを作りました。題材とするデモアプリの実行結果です。MainWindowの中に2つのUserControlがあるだけです。今回のMarkupExtension導入前のコードです。
MainWindowではUserControlを直接指定せず、ContentControlに子ViewModelを指定しています。UserControlではVMのプロパティTitleとバインディングしています。MainWindowViewModelには2つのVMがプロパティとしてあります。UserControlに対応するViewModelには1つプロパティがあるだけです。App.xamlと別ResourceDictionaryでDataTemplateを使ってVM→Viewの登録を行います。
App.xaml直下と別ファイルに分けたのは単なる動作確認で普通は統一します。もう1つのUserControlと対応するViewModelは背景色と文字列の内容が違うだけなので省略します。UserControlにおいて、このままですとデザイナ画面にVM由来の文字列が表示されません。
そこでXAML内でデザイン時DataContextを指定します。
先程のMyUc1.xamlのUserControl句の最後に追加します。無事にデザイナ画面でもViewModel由来の文字列が追加されました。
しかしこのままですと重複があります。
つまり
・DataTemplateではViewModel→View
・各Viewのd:DataContextではView→ViewModel
の結びつけが行われており、内容が重複している。View⇔ViewModel間の組み合わせが変わったら両者を変更する必要があります。
DataTemplateだけ修正してd:DataContexがそのままの場合、
実行時エラーは何も出ませんが、デザイナ画面がエラーしたり、デザイン時と実行時で画面が異なってしまいます。
実は上のコードもUc1にUc2ViewModelを指定していますが、なかなか気づきづらいと思います。そこでDataTemplateを元にView型から対応するViewModelを供給するMarkupExtensionを使ってこの課題を解決します。ViewModelProviderの実装の説明はコード内に書いたので、そちらを参照下さい。
使用方法はViewModelProviderのコンストラクタにViewの型をわたして、d:DataContextに指定します。デザイナ画面も無事直りました。
必要性があるかはわかりませんが、実行時にも使用可能です。
先程のMainWindowを修正します。実行結果です
ContentControlがViewModelからViewを表示するように
ViewModelProviderがViewに対応したViewModelを供給します。デザイン時DataContextはVMの内容を反映したデザインを確認しながらViewを編集できるので便利です。
今回のViewModelProviderを使用するとViewに対応したViewModelが自動で供給されます。
これにより、DataTemplateと重複した記述が削れることと、実行時と違うViewModelを使用するのを防ぐことが出来ます。このMarkupExtensionは内部でDataTemplateにある全てのViewのインスタンス生成を行います。
ですのでViewが増えたり、特定のViewのインスタンス生成が重いとデザイナ画面が極端に重くなります。追伸：ViewTypeを書かずに済むように自動で取得する方法があったら教えてください。VisualStudio2017
.NET Framework 4.7
C#7.1


