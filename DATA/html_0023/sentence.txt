関数型プログラミングの詳細については、1冊の本が書けるほどだし、自分もきちんと読んでいない。が、(自分なりの)要点はテストが楽になるから。
なるはず。なればラッキー。
コード書くのは好き。テストは嫌い。テストなんてやりたくない。失敗しても気にしない。たまに成功すればそれでよい。失敗を恐れてやらないと、引き出しが多くならない。
たまにしか成功しなくても、だんだん再利用可能なコードが貯まってくれば、他の人がすぐにできないことを、驚くべき速さ・かつ高品質で(他の人からみれば、まるで魔法のように)対応できるようになってくる。十分に発達した科学技術は、魔法と見分けがつかない。
(A.C.クラーク)十分に発達した=十分に再利用可能なコードが蓄積された。プログラミング言語の「関数」と、数学で言うところの「関数」が違うものだと思っている人が多い。
同じなんだから同じ。「関数」型の「関数」とは、プログラミング言語の「関数」でもあるし、数学で言うところの「関数」でもある。$f_1(x)$という「数学的な」関数があったとして、その実装が、であれば、同じでしょ？ただし、やりにくいものを無理にやる必要はない。作成とテストを合わせて、楽になる(=拘束時間が短い、従ってコストも小さい)やり方を選ぶ。
そもそも、不変性を期待しない場合もある。例えば、何かを受信するReceiveという関数があったとして、これは引数が全く同じでも、同じ結果を期待していない。受信があればデータを返すし、無ければ返さない。こういうものに無理やり適用する必要はない。(部分的に出来るところはやるべきだが。)効果が発揮されるのは、テスト済みの$f_1(x)$や$f_2(x)$(成功例を参照)がたくさん貯まってきてからだが、やらないと貯まらない。たいていの場合は再利用されないゴミだが、それでもやらないと貯まらない。新しいファイルを作るのをためらわない。関数型プログラミング(同じ入力なら必ず同じ結果を返す)を標榜するにはどうすればよいか。
以下を守ってコードを書く。$f_1(x)$と$f_2(x)$というテスト済みの関数があった時、$f_1(x)$と$f_2(x)$を組み合わせた新たな$f_3(x,y)=f_1(x)+f_2(y)$を作っても、テストは1個やればOKでしょう、という目論み。


