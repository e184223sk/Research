本記事は @gushwellさんの C#リフレクションTIPS 55連発 に触発されて書きました。C#リフレクションTIPS 55連発 は、薄っすらとしか覚えていないリフレクションが網羅的にまとめられており、その便利さのおかげで 余計に リフレクションを覚えられなくなってしまった良記事です私は業務で画像を扱うことが多く、P/Invoke でメモリを受け渡したり、ポインタ越しにメモリを操作するのですが、その度に過去のコードを探ったり、ぐぐったりしています。ポインタに関わらず大体のことは ぐぐれば出てくるのですが、手間なので、未来の自分のため unsafeポインタ についてまとめました。これから示すコード（のほとんど）は、unsafe コンパイラオプションの有効化 と 下記usingディレクティブ が前提となっています。動作は .NET Core 3.1 で確認しています。System.IntPtr と void* は相互に変換できます。どちらでも結果は同じなので、お好みで使えば良いと思います。マネージドオブジェクトはヒープ領域で管理されているので、GCの再配置を防ぐため fixed を使う必要があります。ポインタから値を読み込む。ポインタから値を読み込む。ポインタに値を書き込む。ポインタに値を書き込む。Write() と Copy() が提供されていますが、参照渡しできる Copy() の方がパフォーマンスが良さそうです。ポインタから指定サイズ分だけ、値(byte)を書き込む。Unsafeクラスには存在しない書き込み先メモリの使用可能なバイト数を設定する引数が存在しますが、使う場面が分からないので、上の Unsafe.CopyBlock() を使っておけば良さそうです。動作は速いが、マルチプラットフォームで動作しません。AllocCoTaskMem() を使う方が良さげです。AllocHGlobalとAllocCoTaskMem どちらを使うべきか？ - Qiita30連発くらいにはなるかと思っていましたが、遠く及びませんでした…


