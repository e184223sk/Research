More than 1 year has passed since last update.C# 8 あたりからnull安全が導入される予定だそうです。C# では値型（intやstructなど）はnull値は取れません。
値型でnull値をとるにはnull許容値型（int?など?をつける）を使います。
一方、参照型（stringやclassなど）はデフォルトでnull許容型であり、null値の許容、非許容が区別されていません。ですので、以下のコードはコンパイルが通りますが、ユーザーオブジェクトを取得するTryGetUserメソッドが実行時にnullを返した場合、user.Nameはnull参照例外をスローします。参照型でもnull許容、null非許容の区別が付くようになった場合、null参照例外が発生するコードはコンパイル時に検出してくれるようになります。
つまり、実行時にnull参照例外がスローされる心配がなくなります。null安全が導入されると、コード上でnullかどうかを判断し処理を分岐させる必要が出てきますが、if文などの条件分岐を使うと冗長になります。そこで、既にある??（null合体演算子）、?. ?[]（null条件演算子）を使用すると簡潔に書くことができるようになります、??はnull合体演算子やnullカスケード演算子と呼ばれます。
左辺がnullでない場合は左辺を返し、nullである場合は右辺を返します。下記のコードは、TryGetUserがnullを返した場合、右辺のDefaultUserが評価されます。?. ?[]はnull条件演算子と呼ばれています。
?. ?[]はメンバーやインデックスのアクセスの前に、左辺がnullかどうかテストしnullでない場合、アクセスが行われます。
左辺がnullの場合、nullが返ります。下記のコードはuserがnull出ない場合、Nameの値が返り、nullの場合にはnullを返します。
userがnullでもNullReferenceExceptionは発生しません。また下記のコードもusers（Userのコレクションを想定）がnullでもNullReferenceExceptionが発生しません。if文や?:（三項演算子）を使った場合に比べて読みやすいと思います。?. ?? を組み合わせて使うこともできます。
userがnullの場合、"名無しの権兵衛"、nullでない場合Nameの値が返ります。2019/05/23追記。


