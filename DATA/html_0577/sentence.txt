TaskCompletionSourceを利用して、System.Timers.Timerにインターバル時間の経過を待機できるタスクを追加しました。開発・実行環境
Visual Studio 2019 Community
.Net Framework 4.7.2
C# 7.3一定の時間間隔で何らかの処理を行いたいとき、タイマーを利用することが多々あります。
私はこのような目的でよくSystem.Timers.Timerを利用します。このタイマーは、Intervalプロパティで指定したインターバル時間毎にElapsedイベントを発行することで、利用者に時間経過を通知します。イベントベースで処理する場合、例えば一定回数だけイベントが発行されたらタイマーを停止して処理をやめる、といったことを行いたい場合、コードが煩雑になりがちで、また処理の流れに沿った直感的なコーディングは難しいです。そこで、TaskCompletionSourceを利用してイベントをタスクに変換する方法をつい最近（今更）知ったので、Elapsedイベントを待機できるタスクを追加したAwaitableTimerクラスを作成してみました。例えば以下のように使います。この例では指定した時間間隔で、指定した回数だけ何らかの処理(ここではAsyncMethod)を行います。何らかの理由でインターバル時間内に処理が終わっていなかったらタイムアウトとし、ループを抜け出します。時間内に処理が終わったら、次のインターバルを待ちます。Elapsedイベントを利用したタイムアウト判定と、async/awaitを利用したインターバル時間経過の待機を併用しています。全てイベントベースで書くよりもいくらか簡単かつ直感的になった気がします。実行結果インターバル時間をミリ秒で指定
1000
繰り返し回数を指定
20
不具合の起こる確率を指定
0.1
ラップ001　経過時間(トータル)：1000.15 ms　経過時間(インターバル)：1000.15 ms
ラップ002　経過時間(トータル)：2000.73 ms　経過時間(インターバル)：1000.57 ms
ラップ003　経過時間(トータル)：3002.09 ms　経過時間(インターバル)：1001.36 ms
ラップ004　経過時間(トータル)：4002.23 ms　経過時間(インターバル)：1000.14 ms
ラップ005　経過時間(トータル)：5002.55 ms　経過時間(インターバル)：1000.32 ms
インターバル時間内に処理が終わりませんでした！
終了タスクとイベント ベースの非同期パターン (EAP)


