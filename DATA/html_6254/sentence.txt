More than 3 years have passed since last update.この記事では、Unity 上で UDP/IP データグラム・ソケットを使った簡単なクライアント・サーバー通信の仕組みを構築していきます。TCP と比較して、シンプルで高速な UDP では、小さいデータを頻繁にやりとりするオンラインゲームの用途に適しています。UDP には、シンプルが故に TCP にはない性質があります。パケットロス時の再送処理がありません。ただ、マップ上のプレイヤーの位置情報やモーションの同期など、多少のパケットロスが許容できれば問題なさそうです。今回は、パケットの断片化によるメッセージ全体のロストを最小限に抑えるため、DNS の仕様に倣い、メッセージの最大サイズを 512 バイトに制限していきます。send(a); send(b); が a = recv(); b = recv(); の順で受信できるとは限りません。順序立てられた複数回の送信を一度に行わなければ、問題なさそうです。送信前に相手が受信可能かどうかがわからないため、サーバーが返信不能に陥った際などに困ります。これだけは、代替案を用意する必要がありそうです。受信のためだけに別のスレッドを起動するのは、なるべく避けたいものです。今回は、自前のバイナリフォーマットの実装ですが、JSON や CSV, MessagePack, Protocol Buffers などのフォーマットの変更だけでなく、暗号化や難読化にも備えたいです。メッセージの送信タイミングと受信時のアクションは、呼び出し元によって異なります。後から追加する任意のコンポーネントの存在を考慮したいです。同じ言語で実装を使いまわせれば開発が楽です。さらに楽をするため、エディタで再生した時に自動で起動したいです。Socket.Poll (Socket.Select) をコルーチンにします。つまり、各フレームでタイムアウト 0 の Poll を行い、受信を確認します。シリアライズ・デシリアライズの処理を分離します。今回は、パフォーマンスを優先して、シンプルで小さなバイナリメッセージを実装します。任意の呼び出し元から通信結果に応じたコールバックを設定できるようにします。受信時だけでなく、通信が不安定になった際のコールバックも含めます。エディタの再生時に自動で起動させます。また、サイレントモード (batchmode) でも起動できるようにします。最新のソースコードはこちらです。
https://github.com/oshinko/unity-messengersプロジェクトの全体的な構成は下記のようになります。定期的に ping のような確認メッセージを送信し、時間内に応答がなければサービス停止状態とします。停止後も確認は継続されるため、実際のゲームでは、停止した時点でホーム画面などに戻してしまってもいいかもしれません。Socket.Poll カスタムコルーチンでメッセージの到着を待機しています。その後、呼び出し元で設定された Consumer に受信を通知します。インターフェースを定義して、フォーマットごとに実装していく形です。Start() は、サイレントモードでのみ、Start(IPAddress, int) は、エディタでの再生時にのみ、呼び出される想定です。エディタの再生時にサーバーを自動で起動するコンポーネントです。停止させたい場合は、Inspector から無効にします。Unity エディタは、同じプロジェクトを重複して開けないため、プロジェクトを閉じてから実行します。ログはファイルに吐かれているので以下のように読み出します。実際のゲームに組み込むとしたら、プレイヤーのメッセージを他のプレイヤーに送信する機構が必要になりそうです。そうすると、プレイヤーのエンドポイントをサーバーで管理することにもなるでしょう。また、描画できるオブジェクト数には限りがあるでしょうから、ルーム分けなどをして、同時接続数の管理もしないといけませんね。


