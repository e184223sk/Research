More than 3 years have passed since last update.私は定期的に Durable Functions のリポジトリに貢献している。特に DevOps に関する機能に関して貢献している。なぜそんなことをしているか？というと、プロジェクトが気に入っているのもあるし、プロジェクトのオーナーの Chris とも仲がいいし、貢献するととても学びになる。私の前職の以前のキャリアは、大手SI のSE/PM だったり、アジャイルや、超上流のコンサルでプログラマとしては三流。どうやって、スキルを引き上げるか考えた場合、こういった OSS の貢献はガチの本番環境を体験できるし、リリースまでのすべてを学べるし、リポジトリオーナーのレビューも最高なので、大変ありがたい。ただ、今までは、貢献しっぱなしで、特に振り返りなどをしていなかったので、大きめの貢献をしたら、学んだことを振り返っておこうと思う。大きな機能でいうと２つぐらいしかまだ貢献していない。大きく分けると EventGrid にオーケストレーションのステータスを送信するようにしたものと、Http/Client 経由でインスタンスの状態を取得できるようにしたものの２つ。Kanio とか 24 commitしていて２位だけど、私は 4 commit で５位だから、もうちょっと頑張ってみたいな。スピードを上げて楽に貢献できるようになりたい。今回のPR は、Get all instances status enhancements #358に対応したもの。前に、ステータスの取得を全件行うAPIを作成したけど、その当時からわかっていたことだけど、検索条件を付けたり、古いデータを削除したりということは当然必要になることはわかっていた。しかし、一気にインプリすると負荷も大きいので、プルリクエストを分けて実施することにした。今回は、条件検索のコードを追加することにした。むっちゃ簡単そうだ（実際そんなに難しくない）だが、ガチのプロダクトに貢献するとなると、そうは簡単にいかない。今回は２つのリポジトリを修正する必要がある。Durable Functions の本体は後者だが、DurableTask は、Durable Functions の内部で使われているライブラリで、Azure Storage へのアクセスを担っている。Durable Task はロングランニングな永続性のあるワークフローをサポートするライブラリで、Durable だけでなく、マイクロソフトの他のプロジェクトでも使われているもの。今回は、インスタンステーブルという、Durable Functions のオーケストレーションインスタンスの状態を CQRSパターンで保存する部分へのクエリを書くので、こちらのライブラリの修正が必要となる。Durable 側の実装は大したことなくて、今回のPRの最大のポイントはクエリーの組み立てと、そのデザイン部分と思う。だから、今回はクエリーをラップするクエリーオブジェクトというものをTDDで実装してみた。パラメータを雑に渡すと、TableQuery を組み立てて返してくれるので、それを単に実行すればいいようにしてくれる。もともとの発想の元は、J2EE パターンかなんかのQueryObject というパターンがあったので、それを参考にしている。コードは最終的にこんな感じになった。あとのロジックは、大体委譲なのだけど、Durable の HTTP API のインターフェイスからのパラメータのパースの部分が存在する。Query オブジェクトHttpのパース部分QueryのテストHttpのテストこうして振り返ると全然たいしたことないPRなのに、なんでこんなに時間がかかってるんだよ！というのがこのブログを書いて解明したいポイントではある。さて、この作成過程でかずき師匠や、Chris からいろいろ良いレビューをいただいたので、その辺を再度見直して、なぜ起こったのか、次回以降の対策を考えていきたい。最初に困ったのが、StorageTable のサンプル探しだ。そんなのとても簡単そうに思えるのだが、今のStorageTableは、SDKがかわっていて、コードの書き方が全部違っている。そして、今はなんと、Namespace が CosmosDBになっている。これが必要になってくる。ただ、Durable Functions の場合Microsoft.WindowsAzure.Storage.Table 7.2.1 を使っているので現在見れるサンプルとはコードの書き方が異なる。仕方がないので自分でスパイクしてサンプルを作ってみた。ここには、Queryオブジェクトの原型のプロトタイプがある。レビュー前なので、現在のと比べると面白い。ちなみに、Durable Functions の instance テーブルのデータを大量につくる簡単なサンプルも書いておいたこれは古いサンプルを基に実装している。
* How to write to and read from Windows Azure tables within Web Applications
* CloudStorageAccount Class どうせならLinq かっこよく書きたいところだが、調べると、.NET Coreでは、下記の Linq に書いているこのような書き方ができない。上記にある、CreateQuery メソッドが.NetCoreでは使えないからだ。なぜかというと、.NetCore用のライブラリ では、sync オペレーションがサポートされていないからの様子。According to this question: Missing syncronous methods for dotnet core?，NetCore/Netstandard support does not yet include Sync implementation of the APIs.となれば、Linq 無しで書くことになる。こんな感じ。このクラスには、TaskHubなど、Httpリクエストで使っているパラメータが全部ではないが格納されている。しかし、このクラスはキャッシュされるので、頻繁に変わるものに対しては使えないので、HttpApiHandler.csでパースの処理を実装。HttpManagementPayloadもなにか、URL系の値をもっているが、こちらは、インスタンスを作成したら取得できる３るのURLを保持するためのクラスなので、今回の修正には関係がない。API のデザインも、クリスからアドバイスをもらった。最初に考えていたデザインは次の感じ。クリス曰く、こんなデザインはみたことないし、こっちのほうがいいというコメント。たしかにこっちのほうがずっといい。ちなみに上の書き方は、RFCで定義されていないことを確認してから、日本語のブログを検索して採用したんだけど、やっぱり慎重にMicrosoft の他の REST API の書き方を勉強したほうが良かったのかもしれない。RESTAPIブラウザーを見ても１項目複数指定できるクエリーは見つけられなかった。他の項目としても、OrchestrationClient に実装されるメソッドのなまえとして、GetStatus にするのか、QueryStatus にするのかでも迷った。スタイルに合わせるということで、GetStatusになったが、Azure の API を見ても、Getか、List しかなくて、Queryというネーミングにはだれもしていないので、妥当と思われる。最初はこのような感じだったが、createdTimeTo をオプショナルにしたいという話になった。ちなみに、本当はクエリーオブジェクトは、すべてオプショナルでも動くようになっているので、問題ないのだが、API としては、作者の「意図」を明示的に示したいのだろう。勉強になる。さらに、runtimeStatus が複数指定できるようにとのことになった。status の複数形は、status/statuses のどちらでもいいので、同じ形を採用。しかし、IList はいまいちとのことで、IEnumerable に変更。最初は、配列にするか迷ったのだが、C# の場合は、Enumerable が良さげ。Linq も使える。が、IList だと要素の増減ができてしまうので、クエリーの戻り値としてはこちらが良さげ。かずき師匠にきいても次のような回答。私は特に理由がなければ引数も戻り値も複数件のときはIEnumerableですよこんな感じに最終的に、string はいまいちだろうということで、になった。こちらのほうが型が明確になっている。クリス曰くSystem.Web.HttpUtility.UrlEncodeを使わないでください。WebUtility.UrlEncodeを使ったほうがいいです。とのこと。これを読むと挙動の違いはわかるけど、なぜかは不明。聞いてみる。追記：facebookで尋ねてみるとWeb配下は ASP.NET に依存していて事実上Webプロジェクトじゃないと使えないからだったはず。
System.webには色々ありすぎだからエンコードするだけにはちょっと的な？
そですね。System配下のやつができるまでコンソールアプリでUri使うの大変でしたなるほど。ASP.NET 依存だったのですね。今回学んだことの一つとして、DurableTask と、Durable Functions 側でとても似たようなEnumがあった。意味はほぼ同等といってよくて、実装されている場所が違う程度。OrchestrationRuntimeStatus と、DurableTask.Core で実装されているOrchestrationStatus もっている項目も同じ。当初は自分で変換しないといけないと思っていたのだが、なんとキャストでいけるようす。みたいな感じ。これにはびっくり。クリスから上記のようなコメントがあり、どういうこと？と思ったんだけど、整理して考えると当たり前で、async/await は、なぜ待ち合わせできるか？というと、Taskを戻しているから。このコードの場合、途中でawait を使っている箇所がなくて、最後の戻りのところで、ほかのasync メソッドを呼び出して待ち受けをしている。でもそれだと、ここは、Task返ってくるだけなので、ここで、特にタスクの待ち受けをしても時間がかかるだけで、ここからTaskを返却してあげると、await の分だけ待たなくても、このメソッドを使う元で、待ち合わせがかかるので問題ないという仕組み。当初私は、Queryオブジェクトを、public で実装していたが、クリスの指摘を受けて、internal に変更した。なぜ私がpublic にしたかというと、Unit Testing をしたかったからなのだが、C# の機能で、internal はアセンブリ単位だけど、それを超えたい場合は、AssemblyInfo.cs クラスに参照可能なネームスペースを指定しておけば見れるようになる。下記も指摘をうけた。this.RuntimeStatus.Any() というメソッドがあり、これがあれば、要素があるか否かを検査してくれる。こっちのほうが素晴らしい。ちなみに、要素がなければというメソッドは存在しなかった。ちゃんと基本的な APIはスピードをあげるためには、一通りどんなメソッドがあるのか読んでおくとよさそう。最終的にAPI で、runtimeStatus=foo,bar を実装することになった。Request のパラメータは、string[] になっているので、ワンライナーで書くために、Scala でいうflatMapを使いたくなった。もちろんリンクにもあってSelectManyだった。まだ改良できそうだけど、Split()でカンマ区切りをコレクションに変えて、SelectMany で階層をフラットにする。いろいろ起こったエラーのメッセージと対処方法最初に実行しようとした出たエラー。実際のメッセージはちょっと違うが、DurableTask.Core の2.0.0.6 で PublicKeyTokenがnullのものが無いというエラーだった。普通のものはトークンがあるので、DurableTaskでPack を実行すると、DurableTask.Coreのpackageも作成されるので、そちらを使えばよい。おそらく、この方式だと、publicKeyTokenがnullのものができるのだろう。可能エラーがでると、ログがないので解析不可能。どうやったかというと、再現テストを、Durable Functions 側、DurableTask側で書いてみて、検証した。同じパラメータを、テストとして渡してみる。Durable側では問題ないので、Mock先だとわかる。今回は、DurableTask側のエラーだった。FunctionAppにデプロイしてもエラーは見ることができない。今回の問題は、Aggregateの箇所。ここで、RuntimeStatus.Select(...) が0件の場合、Aggregate はSequence Contains no element. エラーになる。今回はこの箇所の、件数０件チェックをAnyで行うので不要になったが、Aggregateで解決したい場合はといった具合に初期値を設定するとよい。ただ、今回は初期値を設定すると、それも、ORの対象になったので、外した。クソコードがあって、そこも、いろいろ相談してみました。みたいなものは、師匠曰くnullだったら何か別の値ってパターンは
createdTimeTo ?? default(DateTime) みたいにかけますよなるほど、、、このクソコードですがとのこと。string は IEnumerableなので、あとは、どうかなぁ。IEをparams string[] にして可変長引数対応のオーバーロードも作ってもいいかもですねぇ
Parse メソッドはオーバーロード追加してから、オブジェクト初期化子と??演算子で書くとすっきりするかもですね
あとは1ステートメントなので、メソッド本文を=&gt;で書けますね可変の書き方はためしてないけど、こんな感じでいいのかな。次回以降スピードアップするために、学んだことを記録してみたが、ブログを書くのに３時間ぐらいかかってしまった。もっとこまめにアウトプットするほうがよさそう。今回全体像として学んだのはこういうところ次はパージの機能いってみよう。


