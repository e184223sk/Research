More than 1 year has passed since last update.一般編に続き特殊編です。値型の等価判定が癖のある振る舞いをすることがあります。
以下の例で、Assert.IsTrue なら () 内が 真、Assert.IsFalse なら () 内が 偽です。ここまでは期待どおりです。ARGBをあわせたのに等価と判定されません。
なぜでしょう。
プロパティを見てみましょう。違いが表れました。
これらのプロパティ値は実際の色がどうであるかではなく、Color インスタンスがどのようにして生成されたかによって変わります。
内部的には state という private フィールドに区分が格納され、オーバーライドされた Equals メソッドで比較に使用されます。実際に表示される色が同じですので、ARGB値で比較すると等価と判定されます。double 型には非数を表す NaN という値があります。 
NaN (Not a Number) 自体は .NET 独自のものでなく、IEEE 754（浮動小数点数算術標準）で定められています。NaN は IsNaN メソッドを使って判定することができます。0 を浮動小数点型の 0 で割ると NaN になります。
（int や decimal の 0 で割ったときと異なり、DivideByZeroException は発生しません）ちなみに正の値を浮動小数点型の 0 で割ると PositiveInfinity に、負の値を割ると NegativeInfinity になります。非数に対する計算操作の結果もまた非数となります。非数は数ではありませんので、演算子は NaN 自身も含め、どの値とも等価でないと判断します。すべての演算結果が false になるというわけではありません。
非等値演算子は NaN 自身との比較においても true を返しますので注意が必要です。演算子と異なり、比較メソッドでは同値判定が可能です。float 型にも NaN があり、double.NaN と値は同じですが、通常の値の場合と同様、暗黙の型変換ができないと Equals が false を返します。浮動小数点型では精度も問題になります。書式 "R" をつけて最大17桁まで確認してみると、有効桁数が異なることがわかります。有効桁数が異なるため、等価にはなりません。有効桁数を Math.Round で揃えると等価と判定されます。メンバとして定義していない値が格納された場合の等価判定について、テストコード中のコメントで解説させていただきます。※FlagsAttribute 属性が付与されていない列挙型では、値ゼロのメンバを定義することが推奨されています。
《参考》コード分析（FxCop）
CA1008: Enums は 0 値を含んでいなければなりません[.NET] 値型 等価判定の思わぬ落とし穴（一般編）
[.NET] 値型 等価判定の思わぬ落とし穴（特殊編）
[.NET] 参照型 等価判定の思わぬ落とし穴（一般編）
[.NET] 参照型 等価判定の思わぬ落とし穴（特殊編）


