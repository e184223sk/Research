More than 1 year has passed since last update.いよいよ、最大の難関である「数式を解析する機能」を作成していきます。
今回は、BNF（バッカス・ナウア記法：Backus-Naur form）を定義し、そのBNFの定義に沿ってGoFのインタプリタ・パターン(Interpreter pattern)を使って機械的にコーディングすることで、数式を解析しようと思います。逆ポーランド記法を利用した数式の計算(1) 逆ポーランド記法の計算
逆ポーランド記法を利用した数式の計算(2) 数式をトークンに分割する
逆ポーランド記法を利用した数式の計算(3) ReversePolishNotationクラスを改良する
逆ポーランド記法を利用した数式の計算(4) Contextクラスを定義する
逆ポーランド記法を利用した数式の計算(5) Interpreterパターンで数式を解析する ← 当記事
逆ポーランド記法を利用した数式の計算(6) 最後の仕上げまずは、加減乗除を扱える数式を BNF（バッカス・ナウア記法）で定義します。BNFは、こんな感じ。BNFの正式な記法は良くわかってないですが、まああたらずとも遠からずかな。/ と * の優先順位が明確になるように　BNFを定義しています。{} は繰り返し、| は選択、[] はオプション　といったことがわかれば、読み解けるのではと思います。BNFの詳細は、どこかのサイトを見てください。数式を表す BNFとしては  "-(2 + 4) / 2" のように、先頭に符号があり、その直後に()が続くような数式に対応していませんが、そこはご容赦を。たぶん、このBNFをちょっと変更すれば対応できると思いますので、興味のある方は、チャレンジしてみてください。最初に触れたように、上記のBNFをInterpreterパターンを使って、機械的にコーディングすることで、数式を解析しようと思います。逆ポーランド記法への変換は、この解析処理の中で一緒にやってしまおうと思います。前述のBNFをInterpreterパターンで実装する訳ですが、&lt;&gt; で囲まれた&lt;exp&gt; &lt;factor&gt; などを、Interpreterパターンで言うところのノードクラスとして定義します。まずは、各クラスの継承元となるNodeクラスの実装です。Parseメソッドが、継承したクラスで実装するメソッドです。それ以外のメソッドは、式を解析する際に利用するユーティリティメソッドとなっています。最初に、&lt;exp&gt;に対応した、ExpressionNodeクラスを定義します。先ほどのNodeクラスを継承します。Parseメソッドは、BNFの右辺部分をそのままコード化することになります。Parseメソッドは、前回示したContextオブジェクトを受け取ります。最初に、ExpressionNodeのParseメソッドが呼ばれたときには、Contextには計算する数式が設定されています。上のコードを見ていただければ、BNFの定義と対応しているのがわかると思います。これで解析はできるのですが、問題は、逆ポーランド記法を表すReversePolishNotationオブジェクトの組み立てです。例えば、3 + 5 という式の場合は、3 5 + という順番にしないといけません。Parseメソッドの中で、この3 + 5という式がどう対応しているかを見てみると、最初のTermNodeのParse()で、3が処理され、whileのところで、+ が処理され、while文の中のTermNodeのParse()で5が処理されることになります。この時、3と5をReversePolishNotationオブジェクトにセットするのは、それぞれのTermNode.Parse()の中で行うことにし、このExpressionNodeのParse()では、+ だけをReversePolishNotationに追加することとします。どこでやるか、それは、2つめのTermNodeのParseが終わった後ですね。で、そのコードを追加したのが、以下のコードとなります。ExpressionNodeをどんな風に使うかですが、以下のようなコードになります。Parseメソッドの呼び出しから戻ってくると、context.Notationプロパティには、逆ポーランド記法オブジェクトであるReversePolishNotationオブジェクトが設定されています。同じような要領で、TermNode, DivTermNode, FactorNodeの３つのクラスを実装します。FactorNodeを他のクラスと比べてください。context.Notation.Add(token);がありません。これは、BNFの &lt;factor&gt;の定義において、演算子が現れていないからです。ここでもBNFの定義と対応づいているのがわかります。BNFの定義で、まだ実装していないのは、&lt;snumber&gt;と&lt;digit&gt; ですが、これをそのまま実装するのは、あまりにも馬鹿正直なので、C#のTryParseメソッドなどの力を借りて、SignedNumberNodeというクラスで&lt;snumber&gt;と&lt;digit&gt;の２つを賄ってしまいます。decimal.TryParse()で得た数値をcontext.Notation.Add(token);で、ReversePolishNotationオブジェクトに追加しています。なお、数値をReversePolishNotationオブジェクトに追加しているのは、このクラスだけとなっています。他のクラスでは、演算記号だけをReversePolishNotationオブジェクトに追加しています。
これで、RpnCalculatorクラス,　Tokenizerクラス, ReversePolishNotationクラス, Contextクラス, Nodeクラスとその具象クラスの定義が終わりました。数式（加減乗除の式）を入力して計算するためのすべてのピースが整ったことになります。いよいよ、次回は、Expressionクラスと、それを利用するMainメソッドを実装します。(続く)...この記事は、Gushwell's C# Programming Pageで公開したものを大幅に加筆・修正したものです。


