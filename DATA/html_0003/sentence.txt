ああ、サボりたい。みなさんこんにちは。
動的型付の言語で、あえて型付をするのは、インテリセンスでサボりたいから
可読性やメンテナンス性、データ型の保証などの理由からです。C#でいつも使っているList&lt;T&gt;って便利ですよね。
PowershellにあるPSCustomObject、なんとなく使いたくないです。
いつも使っている便利なものを持ちこんで、面倒なことはサボりたい。
自分の作業の効率化のためにも、どう使うのか見てみましょう。 「C#で書くと、Listはこうなりますけど、」 「う～ん、Powershellだとどう書くんでしょう？」
 「ふむふむ、こうやるのか。」※問題はここからです。 「初期化もできたし、追加してみましょう。」（なんだと？ありえない！）ピリオドを打った時点で入力候補が出ないではないですか！！
入力補完機能でサボりたいな。ラクしようと思ったのに逆効果ですよ。素早く入力できるといいですよね。 「他の書き方もあるらしいですね！」 「やってみましょう。」 「ああ、これもダメだ。」インテリセンスが効く書き方は無いのか探していたら、ありました。 「初期化しているので、さっそく要素の追加ですね。」 「入力候補が出ましたね！」「なんだかハッピー過ぎて、お星さまが出てしまいました。お恥ずかしい。」 「こんな書き方でも入力候補が出ました。」 「とてもハッピーになれそうです。」Listはインテリセンス使って上手くやれそうです。
それでは辞書も同じようにできるといいですね。C#だとこんな感じですね。「同じライブラリにあるクラスなので、当然のようにDictionaryも同じ書き方で大丈夫ですよね！」「きっとそうですよ！宣言して、次は…」 「入力候補、出ないじゃないですか！激おこですよ！」これはムズムズしますね。同じライブラリなのにどうして挙動が違うのでしょうか？
そういえば、Listの時、別の書き方でもインテリセンス効きましたよね？
 「試してみましょうか。」 「さあ、早く出して欲しいです。」 「んっ！これは！」 「いっぱい出ましたね。入力候補が！ハッピーになれそうです。」 「インテリセンスを効かせて書こうと思うと、これがベストなようですね。」C#の時って、Listの時には、List&lt;T&gt;って書けば使えましたよね。
あれって、あらかじめusing System.Collections.Generic;を書いていたからです。Powershellだと、毎回[System.Collections.Generic.List[T]]って長々書かなければいけないのでしょうか？
そんなのは嫌です。「アンパンマンマーチ」の「♪そ～んなのは　い～やだ！」の部分を歌いたいです。ググってみましょう！ぐぐらびりてぃ（Googlability）は最低ですが、何とか見つかりました！公式ドキュメントに書いてあるのは内緒。「これを、ps1ファイルの先頭に書いておけば、」「先ほどのロングスタイル初期化は、なんと！」「こんなに短く出来てしまいました！」本当に良かったです！これでみんなハッピー！「そうですか？それで満足なんですか？え？」
 「なんか聞こえるー。幻聴かなー。」
　「こういうのはどうするんだい？」 「ああ、見たくないものが見える。目を背けよう」
　「さあ、このC#のコードをPowershellで表現してみなさい。」
　「もしできなければ…お前のたま」
 「やめて！お嫁に行けなくなっちゃう！」
　「…」「めげずにやってみましょう。」 「インテリセンスは、」「効きました！」 「これ、初期化ってどうやると思う？」
 「C#だと、こう書くやつ」 「やべーわかんねー」
 「こんなのもあるよな」 「もうやだ！だれか助けてー！」
 「こんにちは！普通のGeneric Listはこうやって初期化するのよ」「うわ！マジ天使！」
「てことは、ネストするときはこんな感じかな？？」「やった！ちゃんと５が表示された！」
「ありがとう天使さん！…あれ？いない…。」 「どうやら、初期化までインテリセンスを効かせられたようだな」
 「はい！おかげさまで！スパルタ指導ありがとうございます。」
 「それじゃあ、Dictionaryの初期化はどうするかな？こんなやつ」 「もうつかれた！PSCustomObjectで代用するから許して～～～～～！」さて、続きはまたの機会に…。「インテリセンス」の事を、「入力補完」と言ったり、「入力候補」と言ったりして分かりにくいかもです。ご容赦ください。
また、「この書き方もあるよ！」みたいなものがございましたら、コメントにて教えていただけると、はしゃぎます。Excelsior!


