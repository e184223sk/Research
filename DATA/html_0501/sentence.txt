先日デザインパターンのProxyパターンを勉強したところ、お客様先（現在常駐している現場）の上司が記事を見てくださって「.NET FrameworkならRealProxy, .NET CoreならDispatchProxyを調べるとさらに勉強になりますよ～！」とアドバイスをいただいたので早速RealProxyから学んでみました。RealProxyについて知るために、まずはアスペクト指向というワードについて学ぶ必要があります。
Microsoftの以下の記事が分かりやすかったので引用させていただきます。適切に設計されたアプリケーションは独立した複数の層に分けられ、各層が異なる処理を担当し、必要以上にやり取りを行いません。疎結合型の保守しやすいアプリケーションを設計しているのに、開発も中盤に差し掛かったところでアーキテクチャにうまく適合しない次のような要件が提示されたとします。これらの要件はどれも、多くの作業が必要です。そのうえ、コードの重複が生じます。同じコードをシステムの多くの箇所に追加しなければならず、DRY (don’t repeat yourself: 同じことを繰り返さない) の原則に反し、保守が難しくなります。要件の変更は、プログラムの大幅な変更につながります。アプリケーションにこのような修正を加える必要があると、個人的には「複数の箇所で繰り返されるコードをコンパイラが自動的に追加できないはなぜだろう」、あるいは「[このメソッドにログ記録を追加する] オプションがあったらよいのに」と思います。このようなことを実現するのがアスペクト指向プログラミング (AOP) です。AOP は、一般的なコードと、アスペクト (オブジェクトや層の境界を横断する機能) を分離します。たとえば、アプリケーション ログはどのアプリケーション層にも結び付けられません。プログラム全体に適用され、どこにでも存在します。このようなものを「横断的な懸念事項」と呼びます。AOP とは「横断的な懸念事項の分離を可能にすることによって、モジュール性を高めることを目的としたプログラミング パラダイム」です (Wikipedia からの引用、英語)。AOP はシステムの複数箇所で行われる機能を取り出し、アプリケーションの中核から分離します。そして、このような懸念事項の分離を進めながら、コードの重複や結合を取り除きます。クラス間を横断するようなオブジェクト指向だけでは対処できないような処理をしたいときにアスペクト指向という考え方が必要なのですね。
そのような処理にたいしてデザインパターンのProxyパターン等がマッチするのですが、RealProxyクラスはさらにProxyの基本機能を提供してくれるクラスなのです。以下はRealProxyを用いてSample処理の処理前と処理後にログを入力するサンプルコードです。LogProxyのInvokeメソッドでSampleMethodの処理前、処理後のログを実装していることが分かります。
ここでログ処理をまとめつつ、LogProxyを使いまわすことで最初にMicrosoftドキュメントからの引用文に記載されていた以下の内容が満たせそうです。これらの要件はどれも、多くの作業が必要です。そのうえ、コードの重複が生じます。同じコードをシステムの多くの箇所に追加しなければならず、DRY (don’t repeat yourself: 同じことを繰り返さない) の原則に反し、保守が難しくなります。要件の変更は、プログラムの大幅な変更につながります。アプリケーションにこのような修正を加える必要があると、個人的には「複数の箇所で繰り返されるコードをコンパイラが自動的に追加できないはなぜだろう」、あるいは「[このメソッドにログ記録を追加する] オプションがあったらよいのに」と思います。今回のサンプルコード実装で何となくAOPの雰囲気は分かりましたが、正直なところ、まだまだ曖昧な感じは否めません(;´∀｀)
結構難しいですが個人的にはもっと知りたいなという欲求が出てきたので改めて勉強をしていこうと思います。
より深く理解したら記事に追記していこう～～＼(^o^)／


