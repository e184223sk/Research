More than 1 year has passed since last update.Rxの解説などを見ると、だいたい「イベントのLinq化」「断続的なメッセージをストリームとして」「フィルタ、合成、変換といったオペレータを」などなどの文言が並びます。初見ではなかなか理解が難しいかも知れません。私もそうでした。
ただ、下手くそながらも格闘ゲームを愛する1人として、ピンと来るモノがありました。これ、コマンドの入力判定に使えるんじゃね？思い立ったらやってみよう！ということで、Rxを駆使してコマンド入力判定処理を作ってみます。とりあえず、Windows環境でSharpDX + Reactive Extensionsという構成で作っていきます。Unityだったら、UniRxを使えば多分同じことはできるでしょう。まずはゲームパッドの入力をObserveできるようにします。入力の変化をKeyStreamというIObservableに通知することにします。通知を行うSubjectはバッキングフィールドとしてprivateにしておき、外部にはAsObservable()してプロパティとして公開します。通知する情報はKeyInfoという型で定義しました。どのキーの情報か(Key)、押されたのか離されたのか(State)、何フレーム目に発生したのか(Frame)の3つです。後で改修したくなりそうな気もしますが、とりあえずこれで行きましょう。Rxでは通知した値に対してタイムスタンプを付ける機能がありますが、格闘ゲームではフレーム数の方が信頼できる情報だろうということで、自前で持たせるようにしています。フレーム数のオーバーフローについてはケアする必要がありそうですが、今回は割愛します。JoyStickの初期化はコンストラクタあたりでやっておくとして、毎フレーム状態をポーリングしつつ、変化があったらKeyStreamに対して値を発行する処理はこんな感じです。イベントだったらInvokeしていたのがOnNextに変わるだけ、という理解でも最初は十分だと思います。レバー入力について若干変なことをしていますが、これはいわゆるテンキー表記への変換をやっています。ニュートラルを5として、左右方向の入力があったら+/-1して4か6にし、上下方向の入力があったら+/-3して789か123にする、という処理です。これにより、上下左右が8246、斜め方向を1379で表現するという、古き良き格ゲー攻略サイトなどではお馴染みの記法になります。    -&gt;  7 8 9
    -&gt;  4 5 6
    -&gt;  1 2 3ボタン数は、とりあえず4ボタンを想定しておきました。実用する際には、Unityなどにも存在するような、論理ボタンを介したアクセスになると思います。これで入力の変化を外部からObserveする仕組みが整いました。コマンドの代表例として、ストリートファイターシリーズの必殺技「波動拳」を考えてみます。と表現されるコマンドですが、これを前述したテンキー表記に直すと 236+パンチ です。とりあえずAボタンがパンチボタンだとして 236A という連続的な入力を検出することを考えます。格闘ゲームのコマンドはのんびり入力しても受け付けてくれません。ある程度素早く入力する必要があります。じゃあどの程度よ？という話ですが、カプコンさんの情報によれば、方向キーの入力完成からボタンを押すまでには10フレーム(166ms)ほど猶予があるようです。これを参考にして、コマンドの各ステップの間隔は10フレーム以内ということにしましょう。
（ゲームによってはもっと猶予のあるもの、厳しいものがあります）では入力の間隔をチェックしつつ、入力の順番が 236A で揃えばOKかというと、それだけでは厳しいゲームになってしまいます。
もう1つ、代表的なコマンドとして「昇龍拳」を考えてみます。というコマンドで、テンキー表記では 623P です。
格闘ゲーム初心者にとっては鬼門となりがちなこのコマンド、先ほどの波動拳とは違って、入力方向が連続的ではありません。
波動拳はぐるっと1/4回転すればいいのですが、昇龍拳は右(6)から下(2)に一気に持って行く必要があります。
この時、ニュートラル(5)や右下(3)を経由してしまったりして、綺麗に623とは行かないケースが多く出てきます。
プロゲーマーやいにしえからのゲーマーなら常に正確な入力ができるかもしれませんが、ただでさえ格闘ゲームのコマンド入力は敷居の高さの要因にされがちです。多少は判定を甘くしておいた方が良いと思います。余計な入力を許容するにはどうすればいいかですが、厳密な連続一致を取らず、1ステップごとの要素が順番に現れるかで判定するという方針にすれば実現できそうです。これなら、6523・6323・6123などの入力も許容できることになります。
余計な入力がたくさん挟まった場合も許容されてしまうのでは、と心配になるかもしれませんが、そこは前述した10フレーム以内の制限でふるい落とされるはずですので、気にしないことにしましょう。ではコマンドオブザーバーを組み立てていきましょう。KeyStreamにはレバーの方向変化とボタン全てのON/OFF情報が流れてきますので、特定の操作の変化だけ取り出します。こういうときはWhereです。これで「下方向に入力が入った瞬間に通知が飛ぶ」observerができました。次の入力は右下方向です。右下observerを作り、前のobserverとマージ(Merge)します。これで「下方向と右下方向に入力が入った瞬間に通知が飛ぶ」observerになりました。IObservableは、飛んできた複数の通知をまとめて評価することができます。いくつか手段はありますが、今は2ステップの順序と間隔を調べたいので、Bufferを使って2つの通知を取り出して比較します。メソッドチェーンを使って、ちょっとRxらしいコードになってきました。
Bufferの引数は(取り出す個数, 先頭をスライドする個数)なので、(2, 1)とすることで新しい通知が来るたびに1つ前の通知とセットで流れてくるようになります。Pairwiseでも同様のことができます。
Selectも多用するオペレータです。Bufferした時点で流れる値の型が IList&lt;KeyInfo&gt; になるため、そのままでは次の入力の IObservable&lt;KeyInfo&gt; がマージできません。そこで2つめの入力情報を単体で後続に流すようにし、次のステップも反復的に処理できるようにします。上記の手順2,3を繰り返すことで、コマンドが完成した時に通知が飛んでくるobserverになります。
というわけで、出来上がった関数がこちら。手順1~3の内容を手続き化したかたちになります。
1つ付け加えている処理として、コマンドの最初の方向に入れっぱなしの状態から残りのコマンドを入力するケースを許容するため、最初のステップは間隔チェックを無条件でパスするようにしています。これにより、しゃがみっぱなしの状態から波動拳、前に歩いてから昇龍拳、という状況に対応できます。楽ちんでいいですね！やはりRxで出来るんじゃないか？という直感は正しかったのだ……。
Doは流れてきた通知の値はスルーしつつ記述した処理を実行するためのオペレータです。デバッグ時のログ出力でよく用いられます。実用の際はSubscribeに渡す関数で技のトリガーを引くような処理を書くと思います。引数には最後のキー情報が送られてくるので、コマンド成立時のフレーム時間を取得して利用することもできます。Rxは実行コンテキストが不明瞭になりがちですが、普通にSubscribeする限りでは、実行スレッドはInputManager.Update()と同じになります。安心してご利用ください。またSubscribeの返り値は、判定が不要になったら必ずDisposeして、通知の購読を解除する必要がありますので、お忘れ無くお願いします。注意点として、重複するコマンドの優先順位などは、ハンドリングする側でよしなにしてやる必要があります。
真空波動拳は内部に波動拳と昇龍拳を内包しているので、優先度を高くする必要があります。
また、昇龍拳の勢いが良すぎて 6236 となってしまうことは良くあるため、波動拳より優先度が上になっているゲームが多いように見えます。
（そうなると前歩きからの波動拳が漏れなく昇龍拳になるので、それはそれでストレスかも……ここらへんは要調整ですね）いわゆる瞬獄殺・ダークネスイリュージョン系のコマンドです。
基本的な考え方は同じで行けますが、CreateCommandObserverにいくつか手直しが必要です。これでOKです。ただ、レバー入力主体のコマンドに比べて、間隔の猶予が10フレームだと若干厳しいかもしれないです。Rxの得意とするところです！ABCボタンの同時押しを判定してみます。同時押しを判定したいキーのみが通過するフィルタをWhereで作り、
Bufferで3つ取り出し、
ボタンが押されたフレームの最大値-最小値が規定フレーム(2)以内かどうかでフィルタし、
キー情報のみの配列に変換し、
対象とするキーが全て含まれているかを判定して、
以下判定時の処理、という具合です。RxとLinqの真骨頂ですね。同時押し猶予フレームを手軽に制御できるのも良い感じです。Rxの得意とするところです！(その2)30フレーム以内に4回以上連打して発動、であれば上記のようになります。
Buffer(4, 1)でボタン押し下げ4回分の通知を取り出し、先頭と末尾のフレーム差分が規定の時間内なら発動です。
これで書けるのは強いかと思います。キャラの方向が入れ替わるたびにObserverを作り直すのは効率悪いので……のどちらかが良さそうです。後者の方が効率良さそうですね。例えば41236を想定したコマンドを、426や16とすることで対応できますが、やりすぎると暴発しまくるので注意が必要です。
あるいは、上下左右(8246)の許容範囲を789,123,741,963にまで広げる(いわゆる左要素、下要素などでOKとする)ことで、やりやすくなるかもしれませんが、機械的に適用していいかどうかは、ゲーム性にもよるかと思われます。これまでの実装に拡張が必要なので、次節でまとめて解説します。InputManagerに拡張が必要なため、先に追加の下ごしらえを済ませます。KeyStreamには方向とボタンの入力が混ざっているため、このままでは「方向キーのみを取り出したい」といった場合の条件式が若干書きづらいです。また、方向のタメ入力では「左要素」「下要素」のように、7 or 4 or 1や1 or 2 or 3といった複数方向の入力を許容するケースが出てきます。それともう1点、現在ボタンを離した通知も飛んできますが、この時に「何フレーム継続して押されていたか」を含められると、タメ押し系のコマンドが楽に作れそうです。そこで、KeyInfo型を次のように拡張します。更にInputManagerを次のように拡張します。これでタメとレバー1回転への対応準備ができました。では早速書いてみましょう。若干ゴリ押し感ありますが。まず、方向キーの押し下げのみを取り出すために Where(k =&gt; k.IsDirection &amp;&amp; k.State) でフィルタします。そして判定基準ですが、昨今のタイトルでは「5/8回転で1回転とみなす」という若干甘めの設定が多いようなので、それを採用します。テンキー表記だと6個分の入力になるので、 Buffer(6, 1) で取り出します。入力間隔は、最初の方向は入れっぱなしでも良いことにして、2番目から最後の入力までがそれぞれ10フレーム以内ならOKというのを、まとめて50フレーム以内として判定しています。次に、6個分の入力が連続した方向変化（時計回り or 反時計回り）かどうかを判断する方法として、方向を表す文字を連結して履歴を文字列化し、それが時計回りか反時計回りを表す文字列に含まれるかどうか、という判定を行っています。若干雑な気もしますが、お手軽に書けることを重視しました。後は通常のコマンドと同じく、最後の入力を Select して後ろに流し、ボタンの入力をマージして、Buffer(2, 1) で間隔と順序をチェックして、パスしたらコマンド成立として扱います。Bufferでまとめた配列に対しては、添え字でアクセスしてもいいですが、先頭と末尾であることを明示するならFirstとLastを使った方が、配列の長さに影響されなくて良いかもしれません。タメ技といった場合、いわゆる タメ や タメ などのコマンドが代表的ですが、ボタンを長押しして離した時に発動するコマンドも存在します。ここではその両方を扱います。まずは簡単な方から。ボタン2つの同時押しの後、どちらかを離した時に発動するコマンドの例です。同時押しの押し下げ判定までは前述の通りですが、その後マージしている条件式が !k.State で離し通知でフィルタするようになっています。
更に、先んじて KeyInfo を拡張しておいたおかげで、k.Duration で何フレーム継続して押されていたかを取得することができます。これを使って、技の発動時に段階的に威力を変える、といったことが実現できます。では最後に、レバーのタメを使ったコマンドです。4タメ6Aを判定してみます。最後にもってきただけあって、なかなか複雑なことになっています。紐解いていきましょう。方向変化でも持続フレームを取れるようにしましたが、やっかいなことに一般的な方向タメではと表記されていたらやに入っていたフレームもカウントします。当初はInputManager内で、そういった要素ごとの持続フレームを持つことを考えましたが、あまりInputManagerにゲーム固有の仕様を意識させるのもうまくありません。Rxのオペレータで書き切る方針で考えます。やりたいことは「左要素を含む最初の通知を保持しつつ（その後左要素の方向をガシャガシャしたとしても無視して）左要素以外に入力が移った際の通知を捕まえて、タメ時間を判定できる」ところに持ち込むことです。要素単位でのキー指定には、以前に拡張したHasAttribute()を使って条件をシンプルに記述します。最初の入力のみを受け取るのはTake(1)を付けることで実現できます。これを行うと、通知を受け取った時点でストリームはいったん「完了」状態となります。Mergeは稼働中のストリームに別のストリームを合成するオペレータでしたが、完了したストリームにはConcatで後続のストリームをつなげることができます。ここで左要素以外の初回の入力を受け取り、いつものBuffer(2, 1)でまとめます。このままだと、1回のSubscribeで一度しかこのペアを受け取ることができませんので、Repeatでこの流れを繰り返すように指示します。後はタメ時間を判定して、次のレバー入力の判定……といきたいのですが、タメを解除した方向がぴったり次のコマンドの方向だった場合と、そうでない場合があり得るのをケアしないといけません。!k.HasAttribute('4')は 8,5,2,9,6,3 のいずれかで成立します。6 ならばその入力情報をそのままもう一度流し、そうでなければ 6 を待つストリームからの通知を待つようにする。これを実現するのが、Select内での3項演算子による分岐と、その後ろにあるSwitchの組み合わせです。Selectは値を変換して後続にパスするだけでなく、受け取った値を使って生成したIObservable自体を後続に投げる使い方もあります。その場合、Selectの後ろには引数を取らないMergeやSwitchを置いて合成を行うのがお決まりのパターンです。特にSelect&amp;Mergeの組み合わせはSelectManyと同様の効果を持ちます。最後の A ボタン入力待ちは、通常のコマンドと同様でOKです。コマンドオブザーバーのファクトリ関数を拡張する場合は、タメの後の方向までを1セットで扱うと、反復的に処理できて良さそうですね。かなり大更新になってしまいましたが、コードをきれいにしたらGitHubあたりで公開することも考えています。そうしたらまたここでお知らせします。また、どなたかこの記事を参考に格闘ゲーム作ったらご一報ください。遊びに行きます。
Reactive Fighters 2020、お待ちしております。


