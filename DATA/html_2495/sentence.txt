More than 1 year has passed since last update.Zenject Memory Poolsをなんとなくふわっと理解したくなった方へ　Zenjectでは、動的に生成したオブジェクトに対するInjectionを行うためにFactoryを用いることを推奨しています。*1 
　しかしながら、ゲーム内で動的にオブジェクトを生成破棄することは望ましくありません。通常このような場合は、あらかじめオブジェクトを必要数生成しておき、オブジェクトを再利用する「オブジェクトプーリング」*2を行います。
 Zenjectにも、オブジェクトプーリングのようにあらかじめ生成したオブジェクトをプールする「Memory Pool」という機能があります。今回はこの「Memory Pool」について解説します。まずは、Memory Poolを用いないFactoryでの一番単純な例を考えてみます。上記は、FooSpawnerがFoo.Factoryによって生成されたFooに対する参照を管理しています。この場合、RemoveFooが呼ばれるとFooSpawnerからFooに対する参照が失われていき、最終的にガーベージコレクタによって回収されます。この時スパイクが発生してしまい望ましくありません。
　今度はFactoryで書いたコードをMemoryPoolで書き直してみます。　　上記では、Fooを生成するときはFactoryと同じですが、Fooを破棄する際FooをPoolに戻すということを行っています。これにより、Foo.Pool,Spawn()を新たに呼び出したとき、以前に生成されたFooを再利用するので、ヒープに再割り当てが行われません。
　また、Fooに対する参照はPool内に残っているため、ガーベージコレクタによって使用済みのFooが回収されスパイクが発生することもありません。Memory PoolのBinding Syntaxは、Factoryとほぼ同じです。ただしWithInitialSizeやExpandByなどの、Poolingする初期値や最大値に関するメソッドがあります。・WithInitialSize - Bind時にあらかじめプールするオブジェクトの初期値を決定します。この値を設定することで、ゲーム中における生成時のヒープ割り当てを回避することができます。・WithFixedSize -　Bind時に設定された数のオブジェクトがプールされ、設定された数を超えるを例外がスローされます。・MaxSize - 設定された値以上のオブジェクトをプールせずに破棄します。使用されるオブジェクトの数があらかじめわかっている場合、メモリを節約することができます。・ExpandBy - プールサイズが最大に達したときに呼び出す動作を設定できます。ただしWithFixedSizeとの併用はできません。
　　-ExpandByOneAtATime - プールのサイズを1つずつ大きくします。
　　-ExpandByDoubling - 現在のプールのサイズの2倍のプールを新たに確保します。　Poolingを行う際、再利用するオブジェクトをリセットする必要があります。例えば「敵」の情報をリセットせずに再利用した場合、位置情報や体力など以前のまま再利用してしまうことになってしまいます。
　そのためにMemoryPoolの派生クラスに以下のメソッドを定義します。　上記のアプローチは、十分機能しますが、まだいくつか問題点が残っています。それは、クラスをPool可能にしようとするたびにReinitializeメソッドを追加しResetメソッドを呼び出すようにしなければなりません。また、FactoryからPoolに修正を行う際のコストも非常に高くなっています。
　PlaceholderFactoryとDisposeパターンを使用して、これらの問題を解決する方法が、Zenjectには用意されています。　PoolされるクラスにIPoolable、IDisposableを実装することで、上記が解決できるようになっています。ただし、IL2CPPビルドを行う際AOTエラーが発生する場合があるのでPoolクラスは明確に定義する必要があります。GameObjectsのMemory Poolも、MemoryPoolの代わりにMonoMemoryPoolの派生クラスを作成することで実装することができます。MonoMemoryPoolは、Poolにオブジェクトが追加されたときにゲームオブジェクトを自動的に有効、無効に切り替えてくれています。非GameObjectのPoolでも説明したIPoolable、IDisposableを実装したように、GameObjectのPoolでも同様のことが可能です。注意しなければならない点は、IL2CPP AOTを回避するためにPoolクラスを明示的に宣言したため、Bindする際、FromMonoPoolableMemoryPoolではなくFromPoolableMemoryPoolを使用します。　以上がZenjectMemory Poolsの概要です。今回解説した内容はDocumentationのIntroduction部分のみでAdvancedの部分は解説できていません。*3
 内容に誤りがありましたら、@sai_maple_にご連絡いただけると幸いです。*1 Zenject/Documentation/Factories 
*2 第01回 オブジェクトプーリング
*3 Zenject/Documentation/MemoryPools


