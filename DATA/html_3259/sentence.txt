More than 1 year has passed since last update.TODO:めっちゃ面白い導入部を考えるあるオブジェクトに対して「読み込みと書き込みをする」機能と「読み込みだけをする」機能をそれぞれ切り出して公開する（＝書き込みする必要のない人には読み込みする機能だけを公開する）ようにしておくと、オブジェクトの依存関係を（全部公開するのに比べて）減らすことができるようになります。「読み込みと書き込みをする」機能というのは一種の比喩で、かっこいい言い方をすると「副作用のあるインターフェース」ということになります。単純にプロパティにアクセス権の差をつけるだけでも、何もしない（全部public）よりは効果があります。大抵のケースではこれだけで十分です。コレクションを公開するプロパティをgetterだけに限定しても、コレクションを参照して副作用のあるインスタンスメソッドを呼ばれてしまっては元も子もないです。List&lt;T&gt;は読み取り専用のインターフェースだけをあつめたIReadOnlyList&lt;T&gt;を実装しているので、外から変更されたくないがコレクションは公開したい場合はIReadOnlyList&lt;T&gt;にキャストした状態で公開するといいです。もちろん、呼び出し元でList&lt;T&gt;に強制的にキャストすればいじれてしまいます。プログラム的にこれを制限する方法はないように思うので、悪いプログラマがチームに紛れ込まないようにするしかないです（悪いプログラマがチームに紛れ込むと設計や言語仕様ではどうにもならないのはC#に限った話ではない…）。List&lt;T&gt;はReadOnly版のinterfaceがありますが、ObservableCollection&lt;T&gt;（更新通知付きコレクション）にはありません。こちらの場合、interfaceではなく別途ReadOnlyObservableCollection&lt;T&gt;のインスタンスを作って元ネタのObservableCollectionを指定してやる、というのが必要になります。設計的に一番ごちゃごちゃしないのは「クラスの外部に副作用のあるインターフェース（プロパティ、メソッド）を公開しない」なんですが、それだと設計コストがめちゃ高くなるので徹底するのは難しいです。っていうか現実的に可能なんですかね？経験則として、あるオブジェクトの「状態を知りたい」人と、「状態を変更したい」人では、前者の方が数が多いので、オブジェクト自体は同じでも公開先に応じて公開するものを切り替えられるようになると小回りがきいて便利です。そういうときには、先に示したList&lt;T&gt;とIReadOnlyList&lt;T&gt;のように、同じクラスで読み取りの操作だけを公開するinterfaceと書き込み操作も公開するinterfaceの２つを実装するようにして、公開先に応じてどちらのinterfaceを見せるか切り替えればよいです。どっちのinterfaceで取得したかによって、呼び出せる操作の範囲が変わります。


