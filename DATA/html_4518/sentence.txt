More than 1 year has passed since last update.皆さんはテスト書いていますか？　テスト、特にユニットテストは品質を担保する上で避けては通れないものです。
そのため世には多くのテストフレームワークが普及していますが、果たしてそれでスマートにテストが書けるようになるのでしょうか。答えは NO です。
どんなに優れたテストフレームワークがあっても、テスト対象のモジュールがテストし易いように作られていなければ宝の持ち腐れ。テストフレームワークは銀の弾丸ではありません。
また、テストを不規則に書いてしまってもレビューやメンテナンスコストが跳ね上がってしまいます。そこで本記事では、C# におけるユニットテストの実装プラクティスを示したいと思います。
テストフレームワークに MSTest を用いますが、他のフレームワークでも問題ありません。テスト対象として、byte コレクションを 16 進文字列に変換するメソッドを考えてみましょう。引数に渡された byte コレクションを列挙し、それぞれを 16 進文字列に変換し繋げ合わせるだけのシンプルなロジックです。ですがこのテスト、一筋縄ではいきません。
実際に書いてみましょう。ToHexString() が大文字の 16 進文字列を返すのか、小文字の 16 進文字列を返すのかハッキリしません。
それもそのはず、どちらを返すかは AppSettings.ToLowerHexString に依存している為です（そしてそれは ToHexString() のシグネチャーからは読み取れない）。もちろん リフレクション等を使って AppSettings.ToLowerHexString の値を差し替えてテストを行う事も可能ですが、全然スマートじゃありません。 
元凶はロジック中で AppSettings.ToLowerHexString へ直接依存している事なので、この依存を外に出してしまいましょう。これで、戻り値の 16 進文字列が大文字なのか小文字なのかは ToHexString() の引数で与えられるようになりました。
これなら先ほど詰まったテストコードもスマートに書き直せますね。重要な事は、テスト対象のロジックに注力できるよう無関係な依存は極力排除することです。
DI とか DIP とかを使えばいいと思います（適当メンバーのドキュメントコメントに仕様を書いておく事もとても有効です。これには２つの利点があって、もちろん仕様書を別途アウトプットする事も有効ですが、ドキュメントコメントに仕様を記述する事に比べてといった点で弱いので、ドキュメントコメント上の仕様をマスターとし、必要なら仕様書をレプリカといった位置づけにするのが良いです。そもそも、仕様書の用途によっては記載する必要のないメンバーもあると思いますし。ドキュメントコメント上に仕様を書いておけば、Visual Studio ならインテリセンスに概要が表示されるので、とってもおススメです！あと、そこそこ大事な事だけど、ドキュメントコメント上に仕様を記述するのは公開メンバーだけでＯＫです。public とか protected とかの修飾子が付いているメンバーですね。逆に private とか internal とかついているメンバーはオブジェクトやモジュール内に閉じているのでそこまで重要じゃないです。特に private メンバーは仕様というより実装都合の産物である事が殆ど、というか全部じゃないかな。そもそも仕様が無いので書かなくて（書けなくて）いいです。テストもいらん。上記の ToHexChar() のような private メソッドには表明やらテストを書いても良さそうですが、ToHexString() の仕様に含まれているので ToHexString() のテストを書けば十分。他のメソッドに呼ばれることも無いので、ぶっちゃけローカル関数でいい。他のメソッドからも呼ばれる場合は、仕様を表明しておかないと後で割と面倒なことになるので、表明した方が良いです。でもそれ private じゃなくて public や internal なヘルパークラスの方が良いかもね。internal メンバーには仕様があるかも知れないので、ドキュメントコメントで仕様を表明する事も、それを元にテストを記述する事もできますが、公開メンバーほど厳密に取り組まなくてもいいです。だって非公開なのだから、後で仕様？実装？を変えるの容易だからね。ころころ変わる可能性が高ければ、逆に書かない方が良いまである。仕様と実装が乖離する悪夢は見たくない。なので、公開メンバーだけ抑えておけば必要十分です。さっきは適当にワンライナーで書きましたが、実務ではちゃんと構造化した方が良いです。
凡そのテストメソッドの流れはになると思うので、この構造を目に見える形（＝読み易い）にします。
コードで書くとこんな感じ。常にこの構造となるよう意識する事で、テストを書くことを単純化できますし、レビュアーのリードコストも低減できます。原則、テストメソッドはテスト対象のメンバー毎に１つ。理由は２つ。１つ目は上にも書いた通り、テストを書くことを単純化できる事。
ユースケース毎のテストが必要な場合でも、ユースケースをモデル化すればこのルールでテストを書けます。Clean Architecture とか使おう。２つ目は、同じテスト対象に対するテストメソッドは得てして同じようなコードになるので、その無駄を省くため。テストメソッドの個数も最適化されるので、総じてテストがメンテナンスし易くなります。なので、テストケースはまとめて単一のテストメソッドにぶち込もう！（次の項に続く）※ ちなみに、不具合 issue が立てられて、その確認用に別途テストメソッドを設けるのはアリだと思う。「テストケース毎にテストメソッドを分けて書くのは冗長で読むのも大変なので、なるべく纏めたい」というのが前項の内容。
実はこれ、多くのテストフレームワークがサポートしてくれます！詳細はそっちを参照してね。.
.
.でもいいんですが、ここではテストフレームワークによらない（かつ簡潔な）書き方をしてみます。テストケースは TestCases() ローカル関数にまとめています。それぞれの要素はを ValueTuple&lt;&gt; で固めたオブジェクトで構成しています。これを foreach で列挙して各テストケースのテストを 実施 -&gt; 検証 の流れで行うだけです。ね！簡単でしょ（）え？めんどくさい？
何がめんどくさいって、戻り値の検証と例外の検証がミックスされているテストコードを毎回書くのがめんどくさい、だるい、やってられない。
偉大なる三大美徳にも挙げられています。汝怠惰であれ！ってね。どーせ毎回同じパターンになるだろうコードを毎回書いたり読んだりするのは不毛です。なので見やすく、書きやすくしましょう。使い方はいたって簡単。これだけ。先の ToHexStringTest() に適用するとこれだけ（２回目もっと詳しく知りたい人は readme.md 読んで！５行にまとめた。Wishing you the best!


