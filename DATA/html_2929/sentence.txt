More than 1 year has passed since last update.自分が現在開発に携わっているゲームでは、作中に多くのシナリオが含まれています。
その数はデータにして200を超えていますが、このデータが増えるにつれて、ある問題が発生しました。それは、シナリオデータの数が多すぎて、不具合のあるデータがあることに気付けないということです。
（特定の選択肢を選ぶと、進行不能になるデータがいくつか見られました）これに対処するため、「全シナリオの動作チェックを行うUIのテストコードを書こう！」と思ったのが、事の始まりです。まさか、あんな苦肉の策を取ることになるとは、この時は考えてもいませんでした…自分がテストコードを書いて会得したTipsを紹介します。ちなみに、最強のTips(苦肉の策)は「6. テストの失敗が後続のテストにまで影響を与えないようにする」です。
それ以外は、まとも（のはず…）なTipsになります。1. Play Modeテストで使うAttributeとその注意点
2. テスト時間を短縮する
3. 手軽にUIテストをできるようにする
4. テストの失敗をハンドリングする
5. コード側からTest Runnerを制御する
6. テストの失敗が後続のテストにまで影響を与えないようにする
7. CommandLineからTest Runnerを実行するテストコードを書くにあたって、Unity上でテストできるというメリットから、Unityに標準で付属しているTest RunnerのPlay Modeテストを使用しています。Play Modeテストはコルーチンを使って記述され、このコルーチンが最後までエラーを吐かずに終了すればテストが成功扱いになるという、とてもシンプルなものです。これはUnityエディタから実行できるようになっており、実行すると自動的にUnityがPlay状態になり、直後にコルーチンを実行する仕組みとなっています。そしてもちろん、CommandLineからの実行にも対応しています。完璧ですね。　
これから紹介するTipsは、このTest RunnerのPlay Modeテストを行う際のTipsとなります。Test Runnerを使う際に覚えておきたいAttributeがあります。
また、Play Modeテストにおいて注意すべき点もあるので、それも交えて紹介します。ちなみにUnityエディタ上ではこう見えています。なお、Test RunnerにはNUnitと呼ばれるテストフレームワークが使われているため、もっと知りたい方はNUnitのドキュメントを参照ください。Play Modeテストでは、UnityをPlay状態にしてテストを実行するため、最速でも実プレイと同じ速度しか出ません。そこで、ゲーム内速度やFPSを上げることでスピードUPを図ります。これだけで、テスト時間を大幅に削減することができます。
Play Modeテストならではの手法ですね。シナリオの動作チェックのようなUIテストを行う場合、画面タップなどのUIの操作が必要となります。ただ、これを自前で実装するのは手間になるため、すでにあるUnity UI Test Automation Frameworkというフレームワークを使用することをオススメします。これを使えば、といったことが簡単にできるようになります。テストコードを書いていて、テストが失敗した場合のみ特定の処理をしたい、ということがあると思います。もし、[TearDown]で指定したメソッドに引数として情報が渡ってきたり、テスト失敗時に呼ばれるコールバックなどがあればよかったのですが、NUnitのドキュメントを見た限りなさそうでした。ではどうするか。
Play Modeテストはエラーログが出れば失敗となるので、Unityのログメッセージを取得することでハンドリングできるようになります。こうすれば、失敗時のみ処理をすることができます。Test RunnerがUnityエディタやCommandLineから実行できる術を用意しているとしても、やはり自前で拡張したい時はあります。そういった場合、コード側からTest Runnerを制御することになると思いますが、実はこれがかなり面倒です。
理由は単純。Test RunnerのAPIが公開されていないからです。そのため、リフレクションを使って無理やり実行することになります。正直「何やっているんだ、このコードは」状態になると思うので、dnSpyなどのデコンパイラを使ってTestRunner.dllの中身を見ることをオススメします。Play Modeテストでは、複数のテストを実行した場合も、同じPlay状態でテストを実行します。
そのため、変数などで状態を持っていれば、それは後続のテストにも引き継がれることになります。この特性は、途中のテストが失敗した時に厄介で、ということが起きてしまいます。これに対処するには、各テストが正しく初期化された状態で実行される必要があります。
ただ、もしstaticやDontDestroyOnLoadをよく使っているプロジェクトであれば、これは困難を極めます。シーンの再ロードなどでは初期化できず、しらみつぶしに初期化されていないところを探していくしかないからです。
自分が現在開発に携わっているゲームも同じ状況で、初めはしらみつぶしに探していましたが、途方もなく途中で断念しました。打開策はないか…そう思案して、考えついた最強のTips(苦肉の策)、それが一旦UnityのPlay状態を止めて再度Play状態にすれば、事実上初期化されたことと同義になる！！（スマホのタスクキルと同じ）というものでした。実際のコードを見てみましょう。やっていることは、以下の通りです。Test Runnerを実行すれば、UnityはPlay状態になるため、事実上の初期化が完成です。注意として、テスト情報が名前ではなくカテゴリーで管理されていることもあるため、その際は別の更新処理が必要です。
　
　
苦肉の策ではありますが、これで全シナリオのテストが可能となりました。ただ一点、この方法で問題になることがありました。
次のTipsに移ります。冒頭でも記述した、Test Runnerで用意されているコマンドで実行可能です。これに-quitが指定されていないことにお気づきでしょうか？実は、このコマンドを実行すると、テスト終了時にUnityが自動的に終了するようになっています。
逆に、-quitを付けると失敗してしまうためご注意ください。「6. テストの失敗が後続のテストにまで影響を与えないようにする」で紹介した方法だと、通常のケースと同じコマンドを実行しても上手くいきません。問題は2つあります。
解決策とともに、一つずつ紹介していきます。通常のケースにて紹介した、-quitを指定せずとも、テスト終了時にUnityが自動的に終了する機能。
本来であれば問題がないこの挙動ですが、先ほど紹介した一旦Play状態を止める方法だと厄介です。というのも、一旦Play状態を止めるという動作は、Test Runnerが不正終了したとみなされ、その機能が働かなくなってしまうからです。このままでは、CommandLineからの実行時、途中でテストに失敗すると、Unityが終了されません。そこで、batchmodeでの実行であれば、全テスト終了時にUnityを終了するようにしました。途中でテストが失敗しPlay状態が止められても、[OneTimeTearDown]は呼ばれないことが肝ですね。
（複数のクラスが存在する場合は、他のクラスのテストが終了しているかのチェックが必要になります）もしこの記事のコードをそのまま使っている場合、無限に同じテストが実行され続けてしまいます。これは、このコマンドで作成されるテスト情報は名前で管理されていないため、記事のコードのように、すでに実行したテストの名前を削除しても意味がないためです。もし、この記事のコードを使い回したい場合は、名前で管理されているテスト情報を作成しTest Runnerで実行するメソッドを、CommandLineから呼ぶことをオススメします。実行しているScenarioTestCommand.Executeメソッドは、「5. コード側からTest Runnerを制御する」で紹介しているコードを参照してください。
こちらのサンプルコードは、名前で管理されているテスト情報を作成し、実行しています。自分の開発しているゲームでは、この全シナリオ動作テストを毎朝走らせ、失敗すればslackに通知するようにしています。今回テストコードを入れたことで、シナリオデータの不具合が消えただけでなく、シナリオ再生用のコードを変更するハードルが下がったことも嬉しいポイントです。ゲーム開発だとテストコードを書く機会も少なかったですが、この機会に今後も積極的に取り組んでいきたいと思います。Twitter: @yukiarrr


