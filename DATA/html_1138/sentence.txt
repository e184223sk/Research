More than 1 year has passed since last update.C# 8.0で、Mutableな構造体にreadonly関数メンバーを追加できるようになりました。
それにより、readonlyな構造体のインスタンス(変数、または参照)の防御的なコピーがなくなりますが、ILやJIT Asmがどう変わるかのメモです。の差を見てみましょう。Program.RおよびProgram.Mの引数には inを付けているので、readonlyの参照になります。
readonlyの変数でも同様になるはずです。はじめに断って起きますが、わかりやすい結果になるようにサンプルコードは結構恣意的です。
例えば、構造体のサイズを変えたりするとJIT Asmの結果が結構変わります。CoreCLRのToString()には既にreadonlyが付いているので、直接呼び出すと思ったような結果にはなりません。sharplabで見るldobj Struct がありコピーしている感じがありますね。sharplabで見る非常にシンプルですね。コピーが発生してますね。readonlyな参照の構造体に対しては、readonly関数メンバーを使用すると効率的なアセンブリが生成されました。余談ですが、inを付けたreadonly参照ではなく単にコピーにしても、今回のサンプルコードでは効率的なアセンブリになっていました。構造体でリソースを管理するような設計では値渡しにできないので、readonly関数メンバーにする必要性はあるでしょう。
(もちろん、不意なメンバーの書き換えに対する予防という面もあります。)


