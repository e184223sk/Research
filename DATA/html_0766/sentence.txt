本記事はC# WPF.NetFlameworkを対象とした記事となります。非同期処理を実装するシステムにて、適切に非同期処理を破棄する終了処理のベストプラクティスを模索した時の記録(2020/9/13時点)を個人用にまとめます。  マネージドスレッドは以下の二つに分類されます。  これはUIスレッドで非同期処理を実行した場合、非同期処理実行中にUIスレッドを停止したときの動作の違いを意味します。「background thread」はUIスレッド終了に伴い終了しますが、「foreground thread」は終了しません。次に特定の非同期処理がどちらに該当するのかを確認します。
方法としては、実際に非同期処理実行中にUIスレッドを停止してみて確認することもできるかもしれませんが、Thread.IsBackgroundというプロパティを参照するのが最も容易です。
しかし、Threadオブジェクトを生成せずに非同期処理を実行する場合は、非同期処理内で以下の記述をすることでThread.IsBackgroundの規定値を確認することができます。  ちなみにThreadオブジェクトを生成した際の規定値はFalse、Task.Run()にて非同期処理を実行する場合はTureが規定値となります。  ここまでUIスレッドと非同期スレットとの関係性についての注意事項を述べましたが、本題であるApplication終了時の関係性について触れていきます。先に結論を言うと、Applicationが終了するとマネージドスレッドの種類に関係なく、非同期スレッドは終了します。では、Applicationの終了について詳しく見ていきます。基本的には、WPFアプリケーションテンプレートで作成したMainWindow.xaml.csにてClose()メソッドを呼び出すことでApplicationは終了します。ただしApp.xamlもしくはApp.xaml.csを編集した場合は、それに限りません。  厳密にいうとApplication.MainWindowに設定されたWindowインスタンスがClose()されたときに、Application.ShutdownModeがOnLastWindowCloseに設定されていたかどうかによります。Application.ShutdownModeが規定値であるOnLastWindowCloseに設定されていた場合、Application.MainWindowに設定されたWindowインスタンスのClose()時にApplicationは終了されます。しかしOnExplicitShutdownに設定されていた場合は、Close()＝Applicationの終了とはなりません。
※結果的にAppicationが終了することはありますが、Applicationが生きたままとなる危険性があります。したがって後者の場合は、Close()ではなく明示的にApplication.Shutdown()メソッドを呼び出す必要があります。ここでApplication.MainWindowにWindowインスタンスを設定する方法を見ていきます。Application.MainWindowにセットするには、App.xamlで行う方法とApp.xaml.csで行う方法の2通りあります。
テンプレートからWPFアプリケーションを作成した場合はApp.xamlのApplicationのStartupUriにて記述されています。  続いて、App.xaml.csでMainWindowを設定する方法を提示します。コチラの方法ではApp.xamlのStartupUriにて直接xamlを指定せずに、App.xaml.csのStartupイベント上にてWindowインスタンスを生成します。　　
　　
以上より、非同期処理を実装したアプリケーションは、以下に留意して実装することを結論としました。


