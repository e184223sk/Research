More than 1 year has passed since last update.C++を書いてた人が「C#はローカル変数を読み取り専用にできない」と嘆いていたので実現方法を考えてみました。C#の文法で分からない事があります｡ 
読み取り専用の参照型ローカル変数を作る方法はあるのでしょうか? 他の言語で例を示しますと 
・C++では my_class* const myc = new my_class(); 
・Javaでは final MyClass myc = new MyClass(); 
と書きますがC#ではどう書くのかが分かりません｡ 
ひょっとして方法がないですか !? 読み取り専用にしたい目的は 
(1)プログラムの読み手に、スコープを抜けるまで変更しない意志を伝える｡ 
(2)コンパイラーに変数の不変を保証させる｡ 
(3).NETランタイムの最適化を控えめに期待する｡ 
(4)僕の好み｡(^^;) 調べた内容 
・const ローカル変数には使えるのですが、参照型はstringとnullしか指定出来ません｡ 
・readonly ローカル変数には使えません。 
他に相当する予約語が見あたりませんでした｡ 他の言語には変数を読み取り専用化するためのキーワードがあるみたいです。いろいろ調べても「できない」という結論が多かったのですが、using()の副作用を使ったやり方を思いついたので紹介します。参照を書き換えできないラッパークラスを作ってusing()を使います。using()に渡した変数は再代入不可になります。再代入するコードはコンパイルエラーになるので、やりたいことは実現できています。なので推奨はしませんが、どうしてもやりたくなったときに実装コストとトレードオフで検討してみてください。ちなみに自分で実装したReadonly&lt;T&gt;クラスの代わりにUniRxのReactiveProperty,ReadOnlyReactivePropertyを使うこともできます。C# 8.0だとusingが1行で書けるので短く書けそうです。


