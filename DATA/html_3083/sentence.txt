More than 1 year has passed since last update.クオータービューゲームってご存知ですか？
自分はあんまり最近のゲーム知らなくて、古い例しか出てきませんが、「A列車で行こう4」とか「SimCity 2000」のような、等角投影図風に描いたドット絵を配置したゲームのことです。見下ろし型とか、2.5Dとか、鳥瞰図なんて言われる場合もありますね（これらは必ずしもクオータービューだけを指す言葉じゃないですが）。英語だと isometric view と呼ぶようです。3Dのような奥行きのある絵ですが、実体は二次元（Sprite）なので描画順(z-オーダー)で重なりを制御する必要があります。上に挙げた緑、橙、紫のドット絵それぞれから３つの Sprite を作って、下の画像を作るにはどういう描画順で描画すればいいでしょうか？答えは、「（※この問題の前提では）不可能」です。
それぞれの重なってる部分を見てください。橙＞紫、紫＞緑、緑＞橙となるようなｚオーダーの組み合わせは作れません。方程式で言うなら「解なし」です。こういう絵を作りたいときに、他の人たちはどうやっているかというと、Sprite をタイルなどに分割して描く（もちろん、その時分割部分ごとに適切な順番になるようにする）のが一般的のようです。https://gamedevelopment.tutsplus.com/tutorials/creating-isometric-worlds-a-primer-for-game-developers--gamedev-6511
https://blog.pocketcitygame.com/cheating-at-z-depth-sprite-sorting-in-an-isometric-game/
http://ashley.baldock.me/tilecutterクオータービューのドット絵ゲームを作るとき、 スプライトを分割せずに重なり順を解決したい。そのためにドット絵に深度バッファを適用したい。
そこで下記の図のように3Dオブジェクトにドット絵を正射影表示してやろうと思いました。

これができれば、重なり順解決だけでなく他の3Dオブジェクト（例えば Terrain）とドット絵を上手い具合に共存させることもできます。実は Unity ではないですが、既にこのアイデアを実現してる記事があります。上記の図もそこからの拝借です。今回はこれを Unity に移植してみました。Unity使ってる諸氏には釈迦に説法かもしれませんが、テクスチャを2の累乗サイズに調整しないといけません。普段はUnityが勝手にやってくれるのですが、それに任せてるとテクスチャ上のドット絵の切り出し位置指定がややこしくなるので、それを避けるためです。
シェーダーは透過ができてUnlitでTextureを指定できればよいので、 Sprite/Default か UI/Default を使えます。
ですが、将来の拡張を見越して、一応独自のシェーダーを用意しておきました。テンプレで生成されるUnlitシェーダーに透過処理を付け加えただけの単純なものです。スプライトに相当する役割のオブジェクトとして、メッシュ生成用コンポーネントをEmptyなgameObjectにつけて使います。
ちなみに Shed （シェド）は小屋という意味で名づけました。

上の図のように Mesh Renderer, Mesh Filter も追加してください。設定を弄る必要はありません。以下ソース#if UNITY_EDITOR~#endifブロックは、Sceneビューでもプレビューできるようにするためのものです。上のソースだと行間が伸びて若干見辛いですがVS上ではコメントの図はこんな感じです。

0番が pivot で、1番が手前上面、6番が最奥上面… という風に割り振ってます。
基本的に一方向から見ることしか想定してませんから、裏側のメッシュは作りません。
Unity に合わせて一部書き換えましたが、やってることは参照元記事にあるInitializeCubeメソッドとほぼ同じです。
（オリジナルはオブジェクトの配置位置を反映してましたが、Unityでは親のtransformで動かせば良いので０起点に固定してます。）
テクスチャサイズが2の累乗に拡大されているので、 ToUV() メソッドでは pivot に相当するピクセルから必要な範囲だけを取り出せるように補正しています。このためアトラス画像のように同じ画像に複数のドット絵を入れて使うことも可能になっています。これも2Dシーンなら基本中の基本、釈迦に説法かもしれませんが、パース(遠近法)を適用しないようにカメラを Orthographic に設定します。
Transform はお好みで調整してください、Clear Frags を Solid Color にしましたが、それ以外はデフォルト設定です。ここまでの段階でこうなります。ぱっと見た感じでは既にお題の絵は出来ていますが、ドット絵が綺麗に出ていません。
わざわざドット絵を使うからには、ドットが潰れたり引き伸ばされたりボヤけたりせず、元の品質を保って表示したいですね。（これを英語では PixelPerfect と言うようです。）
デフォルトだとテクスチャにアンチエイリアスがかかってぼやけてしまうので、上のように Filter Mode を Point に設定して解除します。
また、マッピングが適切に出来ていれば大差ないのですが、 Wrap Mode も Repeat から Clamp に変更しています。Bilinear [初期設定]
|Point(No filter)

※上記キャプチャはいずれも倍率２カメラのプロジェクション(射影)行列の調整を行う QuaterView コンポーネントを作成します。
個人的にはこれこそが元記事の肝だと思ってます。【以下引用】
ちょっと注意が必要なのは、xとzは直方体の辺に沿った長さではなく、画像の横幅に占めるドット数で指定すること。
例えば、右の絵(※上の絵)なら size = new Vector(24,18,20); となるだろう。なぜこんな仕様なのかというと、直方体の辺に沿った長さで指定すると x=20*√3, z=24*√3 になるわけだが、√3なんて無理数を使うと小数点誤差を避けようもなく、ドット絵が歪む原因になるから避けたいのだ。というわけで、ドット絵のピクセル単位でサイズ指定できて、スクリーンのドットに綺麗に射影するための変換行列を作ります。下の方に出てくる matrix は元記事のこの行列を Unity 用に変換したもので、z軸の符号を反転しています。また使用するクラスの違いからパラメーターの表記順が行と列入れ替わってることに注意してください。

参考: http://logicalbeat.jp/blog/929/この行列は camera の projectionMatrix ではなく worldToCameraMatrix にセットします。
projectionMatrix は標準的な Orthographic を使います。ピクセル等倍なサイズにするには、
camera.orthographicSize = camera.pixelHeight / 2;
に設定すればよいことがわかりました。
参考: http://light11.hatenadiary.com/entry/2019/04/17/012544元記事には具体的には書いてないですが、この変換行列は回転も含んでます。
上の方で貼ったカメラの Inspector は transform/rotation が x=22.5, y=45, z=0 となっていますが、 QuaterView を適用したカメラは回転は不要です。これも小数点丸め誤差をなくすのに有用だと思います。


なお、 worldToCameraMatrix をセットすると transform 自体が無効になるので、QuaterView の lookAt でワールドの表示目標位置を設定できるようにしています。Distanceはちょっとイジっただけだと見た目の変化はないですが、目標位置とカメラの距離を示します。 near/far plane の適用範囲をシフトさせる効果があります。ドットがわかるように表示倍率x2にしてます。
かなりいい感じですが、よく見るとまだドットの歪みがあるようです。
解りやすくするため、元記事のようにディザテクスチャを貼ってみました。
なぜか境界付近の色がおかしいですね。調べてみたところ、境界付近の色がおかしいのはテクスチャの圧縮によるものだとわかりました。
作成したばかりのテクスチャはデフォルトでは左のように Format が RGBA Compressed DXT5 になっています（最下部のグレーアウト部分）。これを右のようにRGBA 32 bitにしました。ついでにMax Sizeもテクスチャに合わせてます。色がおかしいのは直りましたが、よく見ると斜めの線が途切れ途切れになっています。

これは、左右側面のポリゴンの高さが足りないせいだと思われるので、ポリゴンを上下に 0.5f づつ拡張してみました。UVも同じように拡張しています。
これで綺麗に表示されました。文句なしの Pixel Perfect です。
元のシーンも調整してこのようになりました。ドットに歪みなく描画され、深度バッファを適用して適切な重なり順が実現できています。
深度バッファを適用してるので、他の３Dオブジェクトと混在させたシーンが作れます。
例えば地形(Terrain)と組み合わせたり。

イーサンくんと組み合わせたり。

↑足は紫の物体の向こう側にあるのに、右手は紫の物体の上にあるのがおわかりいただけるでしょうか。ところで、よく見ると３Dオブジェクトは若干縦に潰れた感じになります。
これはドット絵に都合のよいように強引な射影変形をしてるためですので、以下のようにアスペクト補正用のゲームオブジェクトの下に3Dオブジェクトを入れてやるとよいと思います。

ここで調整用オブジェクト(adjust3D)は縦を 1.155 倍にしていることに注目してください。
1.155という数値はまったく無根拠ではなくて、これはx,z軸方向のドットが本来 √3/2 の距離を１ピクセルに変換していることから、逆数である 2/√3 ≒ 1.155 をy軸方向に適用したものです。ご覧のように回転させても違和感ないですね！
プロジェクトファイル一式は GitHub にあります。【元ネタ】http://qoofast.blog76.fc2.com/blog-entry-23.htmlカスタムmesh作成
http://nn-hokuson.hatenablog.com/entry/2018/02/13/200114テクスチャ設定
http://baba-s.hatenablog.com/entry/2018/01/31/213000射影行列とカメラ周り
http://logicalbeat.jp/blog/929/
https://note.mu/fuqunaga/n/n08d81b185514
http://light11.hatenadiary.com/entry/2019/04/17/012544
https://github.com/cmilr/DeadSimple-Pixel-Perfect-Camera


