More than 3 years have passed since last update.やってみたかったこと！エンティティに対して特定の処理を行いたい！
エンティティには特定の情報(例えばint型の付加情報など)を持たせておく必要がある。ただし、プロパティ名は強制しない。
エンティティに特別な制限(インターフェースを実装させるなど)をかけたくない。そのためには、プロパティを動的に解決する必要があった。注意：ここでメモってる内容は、あくまで「趣味」の範囲です。ただの好奇心です。さらに複雑なクエリでは検証してません。
結局は標準ＳＱＬを使いましたが、つい遊び心に火がついてしまったのでメモしておきます。コードファーストで次のようなエンティティクラスを作成します。ついでにコンテキストも用意。レッツマイグレーション！
このようなテーブルが出来ます。初期化で以下のようなデータを突っ込んでます。
詳しくはこちらが参考になります。次のようなSQLを書くとします(実際にAgeなんてカラムは作らないと思いますが考えるの面倒なので許してください)まー、大体こんな感じで取得できます。このSQLと同じ処理をLINQで書くと大体こんな感じです。プロパティを見ても予想どおの結果が出てます。Entity Frameworkではこのようにも書けます。特にDbContext.Set()を使うとエンティティクラスを動的に変更出来ます。LINQがSQLに変換されたことを確かめるため、DbContext.Database.Logでコンソール出力出来るようにしました。↑コンソール画面に出力されたSQLこの辺の仕組みがよくわからない人は「式ツリー」や「クエリ式」を調べてください。式ツリーについてはこちらが参考になります。クエリ式についてはこちらを。さてここで、このLevelやAgeなどの名前を動的に変更する必要が出てきました。
エンティティクラスの型を意識しないようメソッドを作りたかったからです。User.Level / Character.Power  // レベルとかパワー、本人の能力を数値化したもの。
User.Age / Character.YearsOld // 年齢上記のUserとCharacter、意図は同じでもプロパティ名が異なります。
プロパティ名に依存しない、ライブラリ的なメソッドを作りたかったわけです。もちろんうまくいきません。
TEntityからはLevelやAgeなどのプロパティが認識できないのでコンパイルエラーになります。エンティティに特定のインターフェース(Level,Ageを定義したもの)を実装させてジェネリック型に制約かければ！？
それが私情で出来ないからこの記事が出来上がったわけでして、あとPOCO/POJO的にどうなのかなーと思いまして。
そもそもCharacterではそれさえ無理があります。LINQ的には問題ありません。
ところがEntity Frameworkで使ってしまうとエラーになってしまいます。
LINQ to Entitiesでは式に制限があって、クエリ中にラムダ式などは使えません。この辺りが参考になります。ToList()後に、コレクションを走査する分には(LINQ的には)問題ありませんが、
これはSQLに反映されるのではなく、一旦ＤＢからとってきたコレクションに対して行われるだけなので無意味です。動くには動くが、SQLには反映されません。Where()部分にカーソルを充ててよく見てみましょう。
LINQ to ObjectsはIEnumerable&lt;&gt;なのに対して、LINQ to EntitiesはIQueryable&lt;&gt;になっているのがわかります。↑LINQ to Objects↑LINQ to Entities引数にそれぞれのプロパティ名を渡し動的に作り出しますが、
とにかく見づらい、分かりにくい。式ツリー自体学習難易度若干高めだし、可読性が悪く現実的ではない。
さらに複雑な式になってしまうと地獄になってしまいます。コメントで簡潔な方法教えていただきました！　お騒がせしましたー！詳しくはコメント欄ごご覧ください！とすると良かったんですね。一応のこしておきます。アイデア的には一旦ラムダ式でクエリを書いた上で、目的の箇所だけ変更する方法です。大雑把に解説すると、↑を↑や(Userの時)↑に変換(Characterの時)DmyLevelの部分をp.Levelやp.Powerに、
DmyAgeの部分をp.Ageやp.YearsOldに、すり替えてしまえばいいよね！？
まるでテンプレートのように！ちなみに「Dmy」は「Dummy」を略しただけです。
もちろんダミーとなる変数はあらかじめ定義しておく必要があります。はたしてそんなことが出来るのか？？？探してみました。ExpressionVisitorというのがあるんですね！！！！？変更はできないけど、走査して再構築って感じですね。これをもとに、ライブラリ書きました。うんうん、いい感じ！注目すべき変数は、usrWhere/chrWhereと、usrItems/chrItemsです。
動的にクエリを作成し、さらにその結果を取得出来ていることが確認出来ます。
もちろんＳＱＬもきちんと意図したとおり生成されてます。これを修正します。登録時にパラメータを作成しません、一旦Dictionaryで文字列型のペアを作成します。Rewrite()を呼び出した時にExpressionVisitor派生インスタンスを生成します。
この時、すり替え用のパラメーターをもつ辞書を作成し、コンストラクタに渡します。特に厄介な点は、pParamがラムダ式全体で共通したインスタンスであることです。
このことに気づかずかなり苦戦を強いられました。ダミーの変数名をキーとして、辞書の中からキーを見つけたらパラメータにすり替えます、それ以外はそのままnodeを返します。すべてのコードを載せておきます。一旦没になりましたが、気まぐれな好奇心で実験しました。
ローカルにおいておくとすぐ紛失するのでメモとして残しておきます。今のところ、一見正しく動いているように見えます。
もう動けばいいや的に書いたコードで申し訳ないですが、欠陥が潜んでるかもしれないので遊びで使う以外はちょっと危険かもです。DiconEntityReaderでプロパティ名の違いを吸収してます。
もっといいほうほうありそうですが・・・orz内部ではエンティティの具体的な型について知る必要無し。アクセッサについても式ツリーで簡略化できそう。この辺が参考になりそう(まだ試してない)ですが、範囲外なのでやめます。以下のコードはエラーになります。System.InvalidOperationException: '型 'DiconExp.User' の変数 'p' がスコープ '' から参照されましたが、これは定義されていません'原因は、パラメータのインスタンスが違うから？
都度パラメータを作成するのではなく、一度作成したパラメータを使いまわします。
p =&gt; p.Level のpの部分を共通にしたわけです。ここにハマって２日を無駄にしました・・・。そのままだとあまり意味のないコードですが、以下でも同じエラーが出ます。expから最初のパラメータを取得し、それを再利用することで回避出来ます。いずれも実験中にハマった内容ですが、いつか必要になる日があるかもしれないのでメモしておきます。


