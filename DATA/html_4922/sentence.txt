More than 3 years have passed since last update.ASN.1は、SNMPプロトコルで使用されています。
SNMP通信を行うマネージドライブラリをC#で実装することを最終目的とします。
その前段階として、SNMPプロトコルで使用するASN.1のBERのエンコード、デコード処理をC#で実装します。
ここでは、さらに限定してASN.1のBERのObject Identifierのエンコードを実施します。
なぜ最初にObject IdentifierかというとSNMPではObject Identifier(以下、OIDと省略）を検索キーとしてネットワーク上のデバイスの情報収集を行うからです。ITU-TのX.690という文書でASN.1のBERについて定義されています。例えば「1.3.6.1.2.1.1.5」をエンコードすると、
「06 07 2B 06 01 02 01 01 05」となります。ASN.1では、TAG + Length + Valueでエンコードします。
TAGはValueの種類を表しています。「0x06」はOIDであることを表しています。
この他にも、「0x02」が整数、「0x13」が表示可能文字列などとなっています。
なお、TAGのエンコードルールはITU-T X.690の範囲のようですが、TAG番号自体はSNMPのルールとなっているようです。2バイト目は、ValueのLengthを表しています。ここではValueが7バイトです。
なお、Lengthが128を超える場合は、Lengthを2バイト以上を使って表します。
Lengthが128を超える場合は、1バイト目にLengthを表すのに必要なバイト数、2バイト目以降で実際のLengthを表します。
但し、1バイト目のビット8には1をセットします。例えば、Length = 200の場合、Lengthは「81 C8」となります。0xC8は10進で200です。
81は、2進数で「1000 0001」です。ビット8の1を取り除くと「0000 0001」でLengthのLengthが1バイトであることを表しています。もう1つ例を上げると、Lengthが「20000」の場合は「82 4E 20」となります。3バイト目以降がValueになります。
ここに、OID「1.3.6.1.2.1.1.5」のエンコードされた値が入っています。
OIDをエンコードする場合は1バイト目と、2バイト目について特殊な加工があります。「1バイト目 x 40 + 2バイト目」で算出した値をまとめて、1ﾊﾞｲﾄ目とします。
つまり、「1 x 40 + 3」= 「43」 = 「0x2B」となります。OIDの最初のバイトは0, 1, 2のいずれかであることが決まっているためバイト数圧縮のため1ﾊﾞｲﾄにまとめているものと思われます。OIDの3バイト目以降は基本的には数値をそのままバイトに変換していきます。
ただし、128以上の場合は1ﾊﾞｲﾄではなく複数バイトで表すことになっています。
128進数に分割して複数バイトに設定し、最終バイト以外には2進で「1000 0000」を足します。例えば、「56789」は「 3 x (128^2) + 59 x (128^1)  + 85 x (128^0)」となりますので、
128進数で表すと、「3 59 85」ですがそれぞれ16進数に直して「03 3B 55」となり更に最終バイト以外には「1000 0000」(0x80）を加算して、「83 BB 55」となります。まずは今後の拡張を考えて抽象クラスを1つ作成します。
エンコードされたバイトリストを返却する「GetBytes」
TAGを表すバイトを返却する「GetTag」を抽象メソッドとして持ちます。
また、TLVの「Length」をエンコードするメソッドを定義しておきます。「0b10000000」は2進数リテラル表記ですが、ビルドエラーになる場合は「0x80」で置き換え可能です。次にAsnValueを継承する「ObjectIdentifierValue」クラスを作成します。
ここまでのObjectIdentifierValueのエンコードの方法の説明と処理内容を照らし合わせていけば
理解出来ると思います。下記のように画面を作成します。button1のイベントで下記のように、ObjectIdentifierValueを生成して、GetBytesで取得したByteのリストを
画面に出力するコードでOIDのASN.1によるエンコードがうまくいくか試します。button2はついでに、TLVのLengthのエンコードがうまくいっているか試しています。それぞれ、実行してみます。とりあえずは想定通りのエンコードが出来ていることが分かります。SNMP通信で使用する場合は、取得したByteリストをByte配列に変換して送信することになります。
もっとも今回作成したのはSNMPで使用するデータの一部分ですのでこれだけではまだSNMP通信はできません。
この他に、SNMPのバージョン番号(v1, v2, v3など）、コミュニティ名(publicなど）、コマンド名（get-Request, get-NextRequest)などのデータをあわせて送信する必要があります。今後、これらのデータの作成方法も公開していく予定です。centos7上でsnmpgetnextコマンドでsnmpのパケットを送信し、tcpdumpでパケットを取得して送信されているパケットを確認します。取得したパケットを確認します。「1.3.6.1.2.1.1.5」の部分のバイト配列を確認すると、
「06 07 2B 06 01 02 01 01 05 05 00」となっています。最後の「05 00」は、ASN.1のNullValueです。snmpgetnextコマンドではOIDとNullValueをセットでMIB値の取得要求をしますので、最後にNullValueのバイトが付加されています。
最後のNullValueを除くと今回作成したプログラムの実行結果と一致していることが確認できます。Windows10では、SNMPを下記の通りまずは有効にします。次にサービスのSNMP Serviceで次の通りの設定を行うことによりSNMP通信に応答するようになります。Windows10での先ほどのOIDのレスポンスは下記の通り。「1.3.6.1.2.1.1.5」はMIBでsysNameと定義されています。
Windows10からはコンピュータ名が取得できるようです。
なお、応答メッセージのOIDのは、「1.3.6.1.2.1.1.5.0」となっていて最後に「.0」が付加されています。
これはインデックスです。送信メッセージではNullValueになっていたところに、ASN.1のOctetStringでコンピューター名が設定されていることが分かります。今回は、ASN.1で少し手こずる部分についてのエンコードをここでは実施しました。
特にTLVのLengthのエンコード、OIDの大きな数値のエンコードについては、あまり出てこないので
手こずるところです。
今後は、エンコードされたバイト配列から元の情報に戻すデコードについても実装して行く予定です。
SNMPは古典的な技術ですが今でもプリンタやサーバーなどの監視に使用しているところが残っています。
デバイスの種類やその他の情報を手軽に取得する手段としては共通化されているため、今後もしばらくは使用されることもあるかと思います。
.NETは気軽にネットワークツールの開発が出来るツールですので、SNMPプロトコルのマネージドライブラリを作っておいて、気軽にデバイスとのコミュニケーションを取れるようにしたいと考えています。C#でSNMPのGetNextメッセージをエンコードする


