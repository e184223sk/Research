More than 1 year has passed since last update.初投稿です（ガバガバ）。私はヴァーレントゥーガが好きです。ヴァーレントゥーガは、ななあし氏が制作した国取りタイプ戦略シミュレーションゲームです。敵軍の動きや地形を考慮しながら自軍の兵士をリアルタイムで動かす戦闘システムや、ファンタジー世界を舞台とした壮大なストーリーが数多くのプレイヤーから人気を得ています。
一方、ヴァーレントゥーガは、完成度の高い戦闘システムを引き継ぎながら、ユーザーが独自のシナリオを作り公開することが可能なゲーム制作ツールとして、作者のななあし氏が仕様を公開しています。
そこからは、多くの派生作品が生み出されてきました。その中には、ニコニコ自作ゲームフェス4でフリーゲーム夢現賞を受賞した「LostTechnology」や海外展開を準備中の「きのこ・たけのこ戦争IF」など、派生元であるヴァーレントゥーガに負けず劣らず高い評価を得ている作品も数多くあります。
高い完成度を誇る戦略シミュレーションゲームとして、また多くの派生作品を生み出したゲーム制作ツールとして、自作ゲームのコミュニティに偉大な貢献を残しており、まさにゲーム史における重要な存在であるといえます。
銃魔のレザネーションのヴァーレントゥーガ紹介ページより引用ヴァーレントゥーガは2018年に開発が終了しています。
（今後新たな機能が追加されることは）ないです。機能が安定したのを受け（）、私は数年前からUnity C#でヴァーレントゥーガ互換ソフトであるWahrenを開発しています。
ヴァーレントゥーガは作者の漏らしたコメントから推察するにVisual C++でDirectX9を使用して作成されているはずです。
故にユーザー作成の独自シナリオを実現している方法はよほど頭のおかしい技術を使用していない限りインタプリタであることは明白です。
インタプリタが遅いのは日本書紀にも書いてあるぐらい自明の理です。
故に私は.NETの特長であるJITを活かすべく、ユーザーのオリジナルシナリオのソースコードを動的に構文解析し、ILを吐いてAssemblyを作成することでPure C#並の速度を出そうと試みています。Unity 2018.1から新たに登場した機能であるBurst Compiler（記事執筆時点でバージョン0.2.4-preview.41）を使用することで高速な並列計算を実現することが可能です。
そこで、今回はBurst Compilerを利用する並列計算を行う構造体を動的に定義してみました。動的IL生成について私が今まで書いてきた記事はSystem.Reflection.Emit.DynamicMethodを利用してきました。
これはトリッキーなこと（privateメンバへのアクセス）を行うならば非常に重宝するのですが、メソッドしか作れず、構造体を作ることができません。今回はアセンブリから作っていきましょう。
アセンブリば大体DLLみたいなものと思っていただければ大丈夫です。動的に定義する場合AssemblyBuilder.DefineDynamicAssembly静的メソッドを使用します。
この第一引数には何故かstring型ではなくAssemblyName型でアセンブリ名を与えます。
第二引数はRunあるいはRunAndSaveを選びます。RunAndSaveの方がデバッガビリティが高いのでよいでしょう。アセンブリは必ず１つはモジュールを持ちます。
複数モジュールを持つことはできますが、MSBuildはその操作をサポートしていないので考慮せずともよいでしょう。
このModuleBuilder型のオブジェクトに対してクラスや構造体や列挙型をごりごり定義していくことで大規模IL動的生成を行うのが主流です。
static変数にでも持たせるのがいいのではないですかね。今回はUnity.Jobs.IJobParallelForを実装したBurstJobな構造体を定義していきます。
TypeBuilderでメソッドやフィールド、プロパティにインナークラスなど諸々全てを定義し終えた後、Type TypeBuilder.CreateType()インスタンスメソッドを呼び出すことでTypeオブジェクトを得られます。
そしてその戻り値のTypeオブジェクトを引数に取るobject System.Activator.CreateInstance(Type t)静的メソッドによって動的に定義された構造体のインスタンス（がBOX化されたもの）が得られるのです。JobParallelForを実装した構造体を第一引数に指定して、Unity.Jobs.JobHandle Unity.Jobs.IJobParallelForExtensions.Schedule&lt;T&gt;(T job, int arrayLength, int innerLoopBatchCount, Unity.Jobs.JobHandle) where T : struct静的メソッドを呼ぶことでマルチスレッドで良い感じに並列計算が実行されるようになります。よって、今回動的に生成するコードはC#で擬似コードを提示しますと次のような形である必要があります。いや、まあこれだけだとまともに動作できないのですが。
問題点は2つあります。よってこの２つの問題を解決するために新たに次のインターフェースを用意し、BURSTJOB構造体にこれを実装しましょう。こうすればActivator.CreateInsatnaceでインスタンス化したオブジェクトをIAccessorに型変換することでポインタPtrを設定し、かつIJobParallelForExtensions.Scheduleを呼び出すことが可能となります。
具体的には以下のようにUpdateマジックメソッド内から呼びます。さあ、事前の設計と擬似コードは以上で十分でしょう。これから構造体を定義しましょう。BURSTJOB型を定義しましょう。この型は構造体で、IAccessorを実装しています。故に以下のように記述して概形を定義します。public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
第一引数で型の名前を、第二引数で型の概形を、第三引数で基底型を、第四引数で実装するインターフェース（継承した基底インターフェースを含む）全てを指定することでTypeBuilderオブジェクトを戻します。
名前はそのまま"BURSTJOB"。
型の概形は一般的な構造体のそれを指定しています。読者の皆さんが構造体を動的に定義するならばこのTypeAttributesをそのままコピペして使うといいでしょう。
IAccessorインターフェースはIJobParallelForインターフェースを継承しているため、ModuleBuilder.DefineTypeメソッドの引数に継承元であるIJobParallelFor型を表すTypeオブジェクトを渡しています。
.NETにおける構造体は全てSystem.ValueType型から派生しているため基底型に指定します。
そしてTypeBuilder.SetCustomAttrbuteインスタンスメソッドを呼ぶことでこの型に対してつけられた属性を表現します。次にフィールドを定義してあげましょう。int*を表すTypeオブジェクトを結構いろいろな箇所で必要としているのですが、typeof(int*)という表記法はC#において認められていません。
そのため、Type.MakePointerTypeインスタンスメソッドを使用してint型を表すTypeオブジェクトからint*を表すTypeオブジェクトを作成します。ちなみに参照ref intを表すTypeオブジェクトを作るならばMakeByRefTypeメソッドを使います。
このフィールドには[NativeDisableUnsafePtrRestriction]属性を付与しなくてはならないので、BURSTJOB構造体に対して行ったように属性を付与しましょう。BURSTJOB構造体に定義されたメソッドは全てIAccessorとIJobParallelForインターフェースで定義されたメソッドです。
故にこの記事ではオーバーライドしか扱いません。では、一番単純なint* GetPtrメソッドをまずは見てみましょう。MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
第一引数はメソッドの名前で、第二引数にメソッドの性質を指定します。
今回はpublicで仮想メソッドをオーバーライドし、構造体なのでsealed(final)でこれ以上VTableを検索しない、と指定しています。（HideBySigとNewSlot？こまけえこたあいいんだよ！）
第三引数に戻り値の型を定義し、第四引数に引数の型を定義します。引数がないメソッドならばType.EmptyTypesを渡してあげましょう。（System.Array.Empty()でもよさげですが、EmptyTypesはstatic readonlyフィールドなので微々たる差ですが高速に動作します。）そして、ILGenerator MethodBuilder.GetILGenerator()でとうとうILをガリガリ書いていきましょう！
ILGenerator.Emitメソッドの第一引数にOpCodesオブジェクトを渡し、第二引数以後にその補足を足す、という形でILを動的に出力します。
OpCodes毎に補足が不要だったり、補足の型が千差万別なのにEmitメソッドばかりなのは実際バグの温床で使いにくいです。ここの辺りの辛さを大分緩和してくれるライブラリにSigilというものがあります。興味のある方は学んでみても良いと思います。IL部分でやっていることはメソッドの第一引数からフィールドptrの値をスタックに積んで戻り値としているだけです。次にvoid Execute(int index) =&gt; ptr[index] = index;を見てみましょう。
これはポインタ演算が絡むのでやや複雑性が高いですが、慣れればそんなでもありません。
戻り値がないvoidなメソッドの戻り値の型はtypeof(void)です。
IL部分の解説はコード中のコメントを読んでください。次にJobHandle Scheudle()メソッドを見てみましょう。LocalBuilderは初めて出てきましたね。
ILGenerator.DeclareLocalでローカル変数を宣言します。
しかし、ローカル変数に名前がありませんね。実は.NETではローカル変数は無名の存在で、インデックスナンバーで参照される存在なのです。たとえデフォルト値であったとしても構造体を作成するためには構造体を作成する先のアドレスを取得する必要があります。
今回はローカル変数をわざわざ定義し、ローカル変数のアドレスに対して構造体の初期化を行いました。
そして初期化後にローカル変数をロードしています。かなり回りくどく感じますがshoganai。
そして４つの引数（BURSTJOB, int, int, JobHandle）が揃ったらIJobParallelForExtensions.Schedule&lt;BURSTJOB&gt;を呼びます。
この時、Scheduleがジェネリックメソッドですので型パラメーターを与えるためにMakeGenericMethodメソッドを使いましょう。
これは、MethodInfo MethodInfo.MakeGenericMethod(params Type[] parameters)というメソッドシグネチャです。TypeBuilder型はType型を先祖に持つので問題なく渡せます。SetPtrは簡単なので解説しません。こうして全てのメソッドを実装して動的な構造体を定義し終えました。
さあ、実行してみましょう！「ガッシ！ボカッ！」
BurstCompilerは死んだ。スイーツ（笑）Burst CompilerがMono.Cecil.AssemblyResolutionExceptionを吐いて死にました。
どうやら動的に定義されたBurstJobをコンパイルすることができないようです。本当に、本当に残念でなりません。をコメントアウトするとBurstコンパイルされずにちゃんとマルチスレッドで動作しました。
実に惜しい話ですね。私の野心的試みは必ず失敗するという呪いでもあるのでしょうか？ここまでお読みいただきありがとうございました。ヴァーレントゥーガ互換のUnityゲームを現在作っています。
お手伝いいただける方はぜひご連絡ください。#ヴァーレントゥーガ をUnityに移植することでMacやLinuxでも動かせるようにするプロジェクト誰かやる気のある人いません？


