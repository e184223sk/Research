More than 1 year has passed since last update.かつて、インターレースという技術がありました。
https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%AC%E3%83%BC%E3%82%B9描画を１ライン置きに飛ばすことで、描画ピクセルを半分に抑える技術です。十分なスペックを持ったデバイスがあるなかで、もはやこんな技術を使ってるハードはもはや無いでしょう。しかし、UNITYでアンビエントオクリュージョンや、バンプマップなどピクセルシェーダーの負荷が大きい場合、ひょっとすると描画ピクセルが半分で済むインターレースの要素技術が生かせる可能性もなくはないです。ただチラつきの原因にもなるので、全然お勧めしません。
意図的に、レトロゲーム風にするのに使えるかもしれません。
あとそもそもピクセルシェーダー処理が重くない場合は、逆に重くなるかもしれません。
(ハードウェアの機能ではなく、ソフトウェアで疑似的に処理内容を似せているため)
さらに、UNITYはProjectionMatrix書き換えると、カメラからのレイキャストなど問題出るので、本当にお勧めしません。
という注意書きを入れつつ、やり方を説明します。まず、下記のような２つのファイルを作って下さい。
Ｃ＃コードと、シェーダーです。続いてシェーダーコード。今回のやり方では、カメラで撮った画像を加工して、RawImageに貼り付けるやり方をします。
なので、まずカメラ２つ用意して、一つは３Ｄ空間を描画するためのカメラ。
これには、InterlaceCameraコンポーネントを付けます。
そして、CullingMaskを３Ｄに関する部分だけに設定します。もう一つは、ＵＩだけを描画するカメラとします。
カメラのCullingMaskをＵＩだけにします。RawImageを作ります。画面全体の大きさにしましょう。
マテリアルを作って、先ほどのシェーダーを選択します。カメラ１を選択し、InterlaceCameraコンポーネント部分で、マテリアルとRawImageを設定します。あとは、３Ｄ空間にモデルを置いてカメラに映るようにして確認しましょう。
UseInterlaceのチェックを切り替えると、インターレースの使用の有無を切り替えられます。昔のゲームは、こういうのが理由でチラついていたんだなぁと感じていただければ幸いです。そして、本当に高速化されるのか。
確認しました。解像度2688x1242で、ポストエフェクトを掛けます。
インターレースなしだと、22FPSでした。
インターレースありだと、46FPSです。
このスクリプトをつけずにキャンバスも使わずカメラ１つで描画した場合、26FPSでした。

ということで、一応効果あります。
（当然ハード構成によっても、この辺りの効果は変わります。私はMacBook AirのIntel HD Graphics 6000 1536 MBというグラフィックスボードで検証しました。）しかし、そもそも解像度が低くてポストエフェクト無いなど、ピクセル処理が重く無い場合は逆効果でしたので、こ注意ください。以上になります。


