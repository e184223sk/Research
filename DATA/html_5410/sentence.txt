More than 3 years have passed since last update.UnityEventにはUnityAction型のリスナーを登録して使用します。
これらのリスナーは登録方法によって挙動が若干違います。
今回は、登録したリスナー数の取得が出来なかったこと、その原因、対策をまとめてみます。UnityEventには
* 永続的リスナー
* 非永続的リスナー
の2種類が存在します。永続的リスナーはインスペクタ上から登録します。
uGUIのButtonのOnClickとかで、登録したことがあるかと思います。

自分で作成したクラスでも、シリアライズされるUnityEventであればインスペクタ上から登録可能です。
引数付きUnityEvent(UnityEvent&lt;T0&gt;とか)を継承したクラスは、SerializableAttributeを付けるとOKです。
この永続的リスナーは実行中に登録・削除は出来ませんが、Stateが存在していて、それによってON/OFFしたりすることが出来ます。
https://docs.unity3d.com/jp/current/ScriptReference/Events.UnityEventCallState.html非永続的リスナーはスクリプトから登録します。
event.AddListener(action);
という形で登録します。
逆に
event.RemoveListener(action)
でリスナーを削除できます。スクリプトから登録されているリスナー数を取得し、リスナーが存在する時はリスナーの処理を、存在しない時は別の処理を行いたいと考えたのですが、常に0となり、リスナー数が取得できませんでした。。GetPersistentEventCountメソッドを使用することで、リスナー数を取得できますが、これは永続的リスナーの数を取得し、非永続的リスナーの数を取得することは出来ません。出来ません。無理です。どうしても取得したい場合は、UnityEventに登録する際に登録数をカウントするようなラップ関数やクラスを作成するのが良いかなと。
ただ、非永続的リスナーは登録する際は重複をチェックせず、削除する際は重複分全てを削除し、追加、削除の成功、失敗などを取得することも出来ないので、HashSet的に別途Actionを管理するような仕組みも必要になりそうです。無理やりリフレクションで取得してみました。
パフォーマンス的に自分のやりたかったことにはマッチしていませんが、Editor上で使うとかケースを絞れば使えなくも無い気もします。


