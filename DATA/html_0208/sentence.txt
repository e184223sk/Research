さて皆さん。次のコードはどんなふうにコンパイルされると思いますか。「うーん、こんな感じ？」正解です。
しかし、C#では違います。
結構違います。さっき知ったこの驚きを共有しようと思って書きました。
そんな記事です。
結論から言えば、単なる定数代入が7パターンにコンパイルされます。sharplab.ioも開きながら読めば分かりやすいかもしれません。
Cの逆コンパイルはCompiler Explorerを利用させていただきました。逆コンパイル結果一覧

C#: ソースコード

long value;
value=0;
value=1;
value=8;
value=9;
value=127;
value=128;
value=2147483647L;//0b1111111111111111111111111111111
value=2147483648L;//0b10000000000000000000000000000000
value=4294967167L;//0b11111111111111111111111101111111
value=4294967168L;//0b11111111111111111111111110000000
value=4294967294L;//0b11111111111111111111111111111110
value=4294967295L;//0b11111111111111111111111111111111
value=4294967296L;//0b100000000000000000000000000000000

value=-1;
value=-2;
value=-128;
value=-129;
value=-2147483648L;
value=-2147483649L;


MSIL: 逆アセンブル結果C言語: ソースコードx64アセンブラ: x86-64 gcc 10.2x64アセンブラ: x86-64 gcc 4.1.2同時公開のAdvent Calendar記事「【C#】 演算子のオーバーロードで遊ぶ」もどうぞ。パターン1: ldc.i4.*+conv.i81の代入はこうなります。よく分かりませんね。
1行目のldc.i4.1というのは、ldc.i4.1
Push 1 onto the stack as int32 (0x17)だそうです。つまり、「スタックにint32で1をプッシュする」という操作です。
つまりdotnetの中間言語、MSIL(共通中間言語)には、「1をスタックにプッシュする」なんて命令があるんです。
-1～8まであります。2行目はそれをint64に変換する命令。conv.i8
Convert to int64, pushing int64 on stack (0x6A)3行目はスタックから値を取り出して変数に代入する命令です。stloc.0
Pop a value from stack into local variable 0 (0x0A)変数の型と名前もきちんと残っています。これのおかげでdotnetの逆コンパイルはローカル変数まで見えます。最初は特定の値をスタックに積む専用命令があって、しかもわざわざ型変換をしてるのには驚きました。
おそらくメリットは即値にほぼ0の8バイトを消費するより容量が小さくて済むことでしょう。
実在のCPUでこんな命令はなさそうです(というかCPUが型を認識したりしない)。
さらに言えば、アセンブラっぽいのに変数という概念があるのも不思議ですが、MSILってのはこういうものみたいです。なお8の代入はこうなります。-1～8まで同様。ちなみにCでは最初に書いた通りこうなります(x64)。movqってのはMove Quadwordで8バイトの値のコピーです。
%rbpというのはベースポインタ、つまり「rbpは関数内においてスタック領域を扱う処理の基準」だそうです。
ヒープはプラス方向に、スタックはマイナス方向に延びるので+8ではなく-8。
普通ですね。ちなみにこの一行で8バイトの命令になります。
なぜ8バイトの値をコピーするのに8バイトで済むのか疑問ですが、-8(%rbp)みたいな場合の即値は4バイトだからのようです。2147483647までは特に面白い事は起きません。ちなみにC#のJITコンパイル結果 (x86)はこうなります。

ちなみにC#のJITコンパイル結果 (x86)はこうなります。
sharplab.ioでJIT Asmを選択した結果です。x64版は今のところなさそうです。

x86のmovはx64と引数の順序が逆なこと(2番目の引数を1番目の場所に代入)、リトルエンディアンなのでメモリアドレスが多い方に上位ビットが来ることに注意してください。
ebpはrbpの32ビット版です(x64にもあります)。4バイト程度ずれてるようですが気にしないでおきます。SARはShift Arithmetic Rightで算術右シフトのことです。すなわち正の場合は0で負の場合は1でシフトしたビットをセットするビットシフトです。
つまりsar edx, 0x1fは正の場合は0に、負の場合は0xffffffff(-1)になるわけです。
conv.i8の指示通り、律儀にintからlongに変換しているわけですね。
やたら行数が多いですし、わざわざメモリを経由する必要があるのか、定数なんだからsar使わずにxorとかで0を作れば良さそうですし、色々謎ですね。
まぁJITですし、ILを複数行見るような処理はやらない設定なんでしょう多分。intの場合は普通に1行になります。
32ビットCPUで64ビット型を使うのは、単なるストアの時点から命令が増えて遅いだろうなという話ですね。パターン2: ldc.i4.s+conv.i89からは即値を使います。ただし、即値は1バイトです。ldc.i4.sはint8の即値をint32としてスタックにプッシュする命令です。これは127まで続きます。
地味にメモリの節約になりそうです。ldc.i4.s
Push num onto the stack as int32, short form (0x1F )パターン3: ldc.i4+conv.i8128からはint32の即値をスタックにプッシュする命令を使うようになります。
これは2147483647(int.MaxValue)まで続きます。ldc.i4
Push num of type int32 onto the stack as int32 (0x20 )パターン4: ldc.i4+conv.u82147483648では負数が出てきます。可読性がぐんと下がります。たまたま符号のあるなしだけみたいになってますが、2147483649だと-2147483647です。
conv.u8はその名の通りunsigned int64に変換する命令です。
負数を符号なし整数型に変換することで大きな値を得ているわけですね。conv.u8
Convert to unsigned int64, pushing int64 on stack (0x6E)C言語ではコンパイラーによって結果が異なるようです。x86-64 gcc 4.1.24バイトずつ代入しています。直観的です。
ちなみにこの2行で14バイトになります。x86-64 gcc 10.2 / x86-64 clang 11.0.0EAXは、RAXに使っているレジスタの下位32ビットのことです。代入すると上位32ビットもクリアされる…のだと思います。
下位32ビットに代入し、64ビットコピーすることで目的の値を得ているわけですね。
この2行で9バイトです。上より5バイト節約、1を代入するだけより1バイト多いだけです。
コンパイラが進歩してるんだなぁと感じます。メモリの節約はCPUキャッシュなどでも大事です。ちなみにC#のJITコンパイル結果 (x86)はこうなります。

    L001f: mov eax, 0x80000000
    L0024: xor edx, edx
    L0026: mov [ebp-0xc], eax
    L0029: mov [ebp-8], edx


xor edx, edxは0を作っているだけです。
4バイトずつ書き込んでるだけですね。パターン5: ldc.i4.s+conv.u84294967168は何の変哲もない数字に見えます。どうなるか予想できますか。そうですldc.i4.sの復活です。
見た目が変わり、(コンパイル結果が)短くなるだけでそんなに意味はないですね。パターン6: ldc.i4.m1+conv.u8上で書きましたが、-1だけは特別な命令があるのでこうなります。ldc.i4.m1
Push -1 onto the stack as int32 (0x15)パターン7: ldc.i8これ以降は普通に8バイトの即値をストアするだけの簡単な作業です。ldc.i8
Push num of type int64 onto the stack as int64 (0x21 )C言語ではこうなります。x86-64 gcc 4.1.2こっちはいっしょ。x86-64 gcc 10.2 / x86-64 clang 11.0.0こちらはmovabsqという長い名前の命令が出てきます。
単純に64ビットの即値を取るmovですね。恐怖の10バイト命令です。
2行で14バイトも使います。では0からマイナス方向へ行きましょう。
ちなみに「-2～-128」のように絶対値の順に書きます。
基本、正数と同じなのでサクサク紹介していきましょう。パターン1: ldc.i4.*+conv.i8ldc.i4.m1という命令があります。-2以降はありません。
既に書きましたね。パターン2: ldc.i4.s+conv.i8「9～127」と同じ。
2の補数表現なので絶対値が1ずれます。パターン3: ldc.i4+conv.i8「128～2147483647」と同じ。パターン7: ldc.i8「4294967296～」と同じ。
負数をconv.u8にするテクニックが使えないので、8バイトの即値を持つ命令を正数より広い範囲で使わざるを得ません。単なる定数のストアにこんなに種類があるのは驚きでした。7パターンもあります。
出力されるILのサイズをかなり真剣に削っているようです。
さらに-1～8の為の専用命令ってのも不思議ですね。驚きました。
一方で、JITコンパイルの結果はちょっと見た限りではあまり洗練されていないように感じました。MSILはちょくちょく読みはするんですが、これくらい読み込む機会はないので新鮮でした。
普通のアセンブラもですね。
アセンブラ初心者なので用語とか知識とか間違っていれば申し訳ないです。以前似た話を(岩永さんの?)ツイートで見たような記憶があるので既出かもしれません。
ただ知ってる人が多いわけでもなさそうなので良いんじゃないでしょうか。これは元々Advent Calendar用の企画で演算子オーバーロードの調査をしている時に見つけたのですが、面白かったので記事にしたものです。
それなりの分量になったので、本題が間に合わなさそうならこっちを代わりにします。公開時期も遅らせときます。命令長/パターンは以下になります。C#上でILを手軽に触る方法もあります。


