More than 1 year has passed since last update.TaskのプロパティにResultを見つけて、安易に上記のようなことをしたらエディターが応答しなくなりました。こう書いても同じです。ドキュメントをきちんと読むと、Resultは、メソッドの処理が完了して結果が出るまでブロックされるようです。
つまり、以下のように書いても同じようにデッドロックが生じるのでしょうか。
やってみると、やはりエディタが応答しなくなります。これって、awaitとどう違うの?
以下のように、awaitを使って書けば、デッドロックは生じません。awaitとWait ()はどう違うのでしょうか?
無限に待つWait ()の代わりに、指定時間だけ待つWait (int millisec)ようにして、変化を探ります。この結果は以下のようになります。次に、内外の待ち時間を逆にして試します。この結果は以下のようになります。これらの試行から、次のようなことが解ると思います。以上によって、以下のような理解を得ることができました。こう考えると、時間指定なしのWait ()の使いどころが思いつかないですね。
…もしかして、終了待ちのループでコルーチンが止まらなければ使える?
以下のように別スレッドで走らせれば、デッドロックしないのでしょうか。確かにそのようです。
以下の結果が得られました。ただし、メインルーチンが最初から最後まで制御を戻さないので、ログは全て一息に表示されます。あるいは、これでもいけるようです。通常のawaitは、.ConfigureAwait (true)になっているようです。
ドキュメントを読むと、trueだと、続きの処理を大元の環境で実行しようとして、falseだと環境を戻さないということらしいです。
元の環境に戻りたくても、元の環境では終了待ちループ(Wait)が居座って制御を離さない、非同期処理が終わらないからWaitが終わらない、斯くしてデッドロックが生じるわけですね。この環境というのはスレッドなのでしょうか?
だとしたら、明示的に指示しなくても、別スレッドで実行される可能性があるということになりますが…。確かに、別スレッドで実行されたようです。別スレッドを明示した場合と比較してみましょう。おや?
.ConfigureAwait (false)していないのに、awaitの前後が別スレッドになっていますね。asyncとawaitだけならどうでしょうか。Task.Run ()を使わずに、asyncとawaitだけを使う分には、Taskクラスが完了待ちループawaitの中で例外を伝達してくれるようです。この結果は以下のようになります。しかし、メイン側で完了待ちループawaitしないと、例外が受け取れません。この結果は以下のようになります。Taskでなくvoidの場合も、もちろん、同じ結果です。
と、思いきや、違ってました。このように、voidの場合は例外が受け取れます。
どうやら、Taskを受け取った以上はawaitしなさいと言うことでしょうか。では、Task.Run ()の場合はどうでしょうか。Task.Run ()をawaitすれば受け取れるようです。
しかし、並列に動かそうとしてawaitを外すと…これだと、例外は受け取れません。
こちらは、voidにしてもだめなようです。
以下のようにしても同じです。でも、以下のようにすれば、ブロックされずに受け取れるようです。間接的にawait Task.Run ()を使うことで並列に処理しつつ、awaitがメインスレッドで処理されるので、例外を受け取ることもできるということでしょうか。じゃあ、これはどうでしょう?あれ?
別スレッドになるから、てっきりダメかと思ったけど、ちゃんと受け取れますね。
う～ん???まず、複数の非同期メソッドをawaitなしに呼び出して、ループさせてみます。シングルスレッドで実行されるので、一方のループが終わってから他方のループが始まります。同じことを、複数のTask.Run ()により別スレッドで走らせてみます。この場合は、ふたつのカウントが同時に進みます。
なお、task 1と2の処理順は、不確定になるようです。
また、エディタで実行を終了しても、カウントは継続します。
(カウント中にコンパイルが入るとエディタがフリーズします。)例外を発生させてみます。この結果は、以下のように例外を2回受け取ります。
メインスレッドでawaitすれば、別スレッドの例外も受け取れるようですね。相当するものは見つけられていません。
普通にループを書いてしまうと、そのスレッドをブロックしてしまいますよね。
スレッドを解放しつつ、時々ポーリングするような…。
ああ、そういうことですね。これでいけそうです。
直に書いても知れていますね。タスクの停止は、コルーチンのような外部からの強制停止ではなくて、外部からの要求を内部で監視して、都合の良いタイミングで自ら終わるという感じです。この例のようにポーリングするのでなく、トークンに対してコールバックを設定することもできます。簡単リモートアセット(Unity Addressable Asset System)を試してみた (その1) (Qiita) のコルーチンをタスクに置き換えると、例えば以下のようになります。これは問題なく動作します。
ここで、スライドショウが一巡するのを待って次の処理がしたいとして、以下のように書き直したものとします。具体的には、loaderに対して、.Wait ()できるようにTaskを返すようにして、デッドロックしないように、await毎に.ConfigureAwait (false)を付けます。
さらに、スライドのループが一巡で終わるようにしています。
しかし、コンパイルは通りますが、期待した動作はしません。
一番の問題は、Unityの機能であるAddressables.LoadAssetAsyncはメインスレッドでしか動作しないということです。
最初のawait Addressables.LoadAssetAsync～.ConfigureAwait (false)によって、以降の処理が別スレッドに飛ばされます。
その結果、次のawait Addressables.LoadAssetAsync～でエラーが生じます。以下のようなことならできますが、同期的に処理したい場合は難しいですね。コルーチンの場合でも、同様に以下のように書くことはできても、他の処理をブロックして待つのは難しいですね。yield return null; ⇒ await TaskEx.DelayOneFrame;
yield return new WaitUntil (() =&gt; flag); ⇒ await TaskEx.DelayUntil (() =&gt; flag);
yield return new WaitWhile (() =&gt; flag); ⇒ await TaskEx.DelayWhile (() =&gt; flag);今回はここまでにします。いろいろなことが解りました。
行きつ戻りつ書いたのと、きちんと見直せていないので、信頼性は低いです。
また、解らないことが出てきたら、手直ししたり、続きを書くかも知れません。試行の途中で拝読した下の記事は大変分かり易く参考になりました。
【図解】C#のasync/awaitの内部挙動を理解する (Qiita)この記事には出てきませんが、IProgress&lt;T&gt;を使った別スレッドの進捗をメインスレッドに伝達する仕組みについては、こちらを参考にさせていただきました。
Progressを使ってみた (ひょうろくだまらん)どうもありがとうございました。


