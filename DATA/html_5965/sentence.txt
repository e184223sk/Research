More than 3 years have passed since last update.久々に趣味コーディングでC#使ってたら、予想外の所でハマったので、ハマった所や調べた事、その他諸々を纏めてみます。まぁ普通。初歩的すぎて今更こんな所で躓くとは夢にも思ってなかったが、実際これを使って実装したら思いっきりバグってしまい、色々と調べる事に。。。大量にある画像ファイルをバッチ的に編集処理するツールを作ろうとしてて、編集した画像ファイルの保存先をオプション指定出来るようにしてたんだけど、その辺のパス関連処理で思いっきりバグりました。具体的には、編集した画像ファイルの保存先として、以下の３つの機能を設けていました。で、これを一つの「出力先パラメータ」設定でこの挙動を切り替えようとしていた訳です。擬似コードで示すと、以下のようなロジックです。で、この「絶対パスか否か」の判定に Path.IsPathRooted を、
「パスの連結」の処理に Path.Combine を、それぞれ使用した訳です。誰だってそーする、俺だってそーする。が、結果として「相対パス」のつもりで与えていたパラメータに対して、思った通りに動作してくれませんでした。ツールのコードでは問題が解り難くなるので、シンプルな検証コードを書いてきました。幾つかのパス文字列のパターンで検証。コメントに書いているのは実行結果ではなく 「期待する挙動」 です。
★マークが付いているのは 「実行結果が期待と異なるケース」 です。このコードの実行結果がこちら。上記の通り、★マークを付けた \moge と /moge のケースで、こちらの期待とは裏腹に true が返って来ています。そして、上記 IsPathRooted と同様に Combine の方でも非直感的な動作結果となります。ソース内コメントに書いてある通り、このテストケースの全てに於いて、ユーザの期待としては C:\Directory\Folder という同じ結果になって欲しいというのが 直感的な期待 となります。が、実行結果は以下のようになります。末尾の \ の有り無しはまぁ置いといて。★マークを付けた２ケースに於いて、期待とは異なる残念な結果 になっています。
（一応明記しとくと、バグッてる訳じゃなく、仕様通りの挙動だそうです）では、MSDNのリファレンスを確認してみましょう。メソッド概要：指定したパス文字列にルートが含まれているかどうかを示す値を取得します。戻り値：path にルートが含まれている場合は true。それ以外の場合は false。そうです。
「パスにルートが含まれているか否かを判定する」と書いてありますが、
「絶対パスか相対パスかを判定する」とは書かれていないのです。※ここで言う「ルート」ってのが具体的に何の事を意味しているのか、と言うのが重要になりますね。正直、定義が良く解りませんが。「パスが絶対パスか相対パスか調べたい」と言う要件でぐぐると、割りとすぐに「IsPathRootedメソッドを使え」と言う情報がヒットしますが、 このメソッドは絶対パスか相対パスかを判定するためのものではない と言うのが落とし穴になっている訳です。メソッド概要：2 つの文字列を 1 つのパスに結合します。戻り値：結合されたパス。
指定したパスの 1 つが長さ 0 の文字列の場合、このメソッドは別のパスを返します。 path2 に絶対パスが含まれる場合、このメソッドは path2 を返します。重要なのが、戻り値の説明に書かれた二文目の内容です。「絶対パスが含まれる場合」とあります。何となく動作結果から予想付いてましたが、ここでは IsPathRooted で判定している（若しくはそれと同等の判定処理がある）事が伺えますね。※せっかくIsPathRootedメソッドの説明では「絶対パスか否か」と言う名言を避けていたのに、それを使っているCombineメソッドの方で「絶対パスが」と言っちゃってるのは、何と言うかちょっとアレですねって言う話。これではどちらかの説明、或いは実装が誤っていると言わざるを得ない。Combineの備考欄に何やら重要っぽい事が書かれてるみたいなんですが、どうも機械翻訳がいまいちイケてないみたいなので、あとで英語の原文を読んでみようかと思います。予想だけで記事を書いてもしょうがないので、実際に実装コードを読んでみましょう。まず、問題の IsPathRooted 先生。という判定処理がありますね。ショートコーディング風でちょっと解り難いので、読み易く同等な処理として書き換えてみます。まずは単純にコード整形。if文の中身がぐちゃぐちゃして気に食わないので、等価なコードに書き換え。実装コード内の length に関しては、単に IndexOutOfRangeException に対するガードとしての機能しか無いので、ぶっちゃけ贅肉ですね。例えば拡張メソッドを使って以下のように書き換えちゃえばコードがスッキリします。（個人的な趣味）※拡張メソッドが有りなら普通に FirstOrDefault 使えばいいじゃーん、って言う話もある。次に、内部的に IsPathRooted を呼び出していると予想される Combine 先生。が、呼び出しているコア処理の CombineNoChecks さん。ハイ、予想通りいましたね。MSDNに記載されていた「path2 に絶対パスが含まれる場合、このメソッドは path2 を返します」は、このコードを和訳したようなものです。よりストレートに言えば IsPathRooted が true になる場合、このメソッドは path2 を返します、だ。繰り返しますが、 IsPathRooted の説明では「絶対パスか否か」を判定するとは言っておらず、「パスにルートを含むか否か」という表現でした。
しかし、これを利用しており、それ以外の条件が付与されていない実装である Combine の説明では「絶対パスが含まれる場合」と言っているので、間接的に IsPathRooted は絶対パスか否かを判定する（目的で使用される）と言っている訳です。うーん、、、これって一体・・・。^^;バグか否かという議論は一旦棚上げにしておくとしても、この IsPathRooted の挙動は 非直感的 であり 一般的な用途に対して不都合がある 実装だと思います。そして、これがIsPathRootedだけの話であれば良かった。
「絶対パスか否かを判定する」目的のユーティリティを普通に自作して Path.IsPathRooted の使用を開発規約で非推奨にしちまえば話は簡単。
しかし、Combineが内部でIsPathRootedを使用しているので、芋蔓でそっちも書き換えたくなると言うのが厄介な所。しかもCombineの方は実装が深い上に可変パラメータに対応する為に結構コテコテ書かれているので、代替するメソッドを用意するのも面倒くさい、というね。ぶっちゃけた話、IsPathRootedが業務開発で出て来る事なんて稀なんで、割りとどうだって良いかなって感じですが、Combineに関しては出て来ない方がむしろ珍しいまである頻出メソッドです。
こっちの方が問題としては結構厄介ですよね。冒頭でチラッと言いましたけど「C#でパス結合するならPath.Combineを使うのが常識だ」というのは良く言われる事だと思います。
数多くの入門サイトでも、この方法が強く推奨されていたり、この実装が一般的だからこれに合わせなさいと書かれていたりする事が殆どです。
あまりにも常識として定着し過ぎており、それを疑ったり検証する事すら稀なレベルなので、お恥ずかしながら自分も今日に至るまでこの問題に気付きませんでした。自分達の実装しようとしている「目的」に対して、Combine・IsPathRootedの「仕様」がマッチしているかどうか、「手段」として妥当かどうかをきちんと確認しましょう。そして、悲しいかなそれが手段として妥当でないという結論に至った場合、プロジェクト内の共通実装としてユーティリティを用意して、それを使うように周知徹底しましょう。※代替となる実装手段は幾つかヒットしますが、既存のライブラリ実装の組み合わせではどれも微妙なクセがあるので、素直に文字列操作として自作するのが良さそうです、、、。気になったので、JShellを起動してJavaだとどうなるか試してみた。相当機能としてはPaths#getだと思うのでこいつを使ってみる。期待通りにパスが連結されました。求めている挙動はこういう挙動なので、この目的ではPath.Combineは使えないですね。


