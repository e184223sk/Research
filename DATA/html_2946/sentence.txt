More than 1 year has passed since last update.EntityFrameworkCoreでLINQ to Entitiesのクエリを書いていたFilunK。取得するテーブルは以下のような構成。他にもいろいろカラムはありますが、それは置いておいて。このテーブルの役割は、ユーザ作成時の2段階認証用のために生成された一時アクセス用URIのパターンと有効期限を扱うもの。EXPIRE_LIMITには期限切れになる日時が登録されている、と。この中で期限切れになっているTEMP_URIを取得したいと考えたFilunKはこのようなLINQを組み立てました。さて、このコードを実行してみると、queryResultには1件も入ってきません。
ですが、実際にSQLをデータベースに投げてみると、複数件取れるではありませんか。
where文が怪しいというのは見当が付きます。そこで、tempUri.ExpireLimit &lt; DateTime.Now を　 tempUri.ExpireLimit &gt; DateTime.Now と不等号を逆さにしてみると、あら不思議、期待したデータが取得できているではありませんか？
これはもしや、DateTime.CompareToメソッドのバグなのかしら？　おいおい、怖いなあ……ということがありました。結論は簡単です。→ ロケールの違いで不等号が期待通りに動作しなかったのです今回使用しているのはHerokuの Heroku Postgresで、ロケールを確認したところen-USロケールでした。調査にあたっては、ネットの以下の記事を参考にしました。LINQ to Entities での DateTime.NowここではSQLiteでの事例でしたが、LINQ to EntitiesとDBで扱っているロケールが異なるため、同じことが言えそうです。つまり、 ロケールを合わせないとおかしなことになる と。確かに。こんなLINQを試してみました。where文の confirm.ExpireLimit を System.TimeZoneInfo.ConvertTimeToUtc(confirm.ExpireLimit)にしてみました。本来はen_USロケールにあったTimeZoneInfoでconfirm.ExpireLimitに変換したほうがいいのですが、どの標準時間でやればいいのかわからなかったのでとりあえずUTCにしてみました。UTCと米国時間ロケールがそもそも不一致という問題はさておき、このやり方はおすすめできないです。LINQとしてまずそうです。というのも、The LINQ expression 'where (ConvertTimeToUtc([confirm].ExpireLimit) &lt; DateTime.Now)' could not be translated and will be　evaluated locally.との警告がありました。これはつまり、System.TimeZoneInfo.ConvertTimeToUtc(DateTime)メソッドがSQLに変換できないと、もっと端折って言えば『EXPIRE_LIMITのWHERE文はSQLのWHERE句に変換しないで内部的に使うよ』と言っています。本来はみたいなSQLのつもりが、で全件取得の上、 CLRの上でEXPIRE_LIMITに対する処理をしてしまいます。期待したSQLにならない時点で使うべきじゃないですね。絞り込みがうまくできないので性能も出ないでしょうし。なので、安全なのはこちらです。参考にしたサイトでも使用している方法です。LINQの外でDateTime.Nowを変数に代入し、LINQの中でDateTime.Nowをとしていた箇所をLINQ外で宣言した変数を使用します。
このLINQでは以下のようなSQLに変換されます。プログラム側からEXPIRE_LIMITの絞り込み条件として変数currentTimestampを使用します。このばあい、DB側でNOW()が使用されないので、絞り込みがうまく行かない、という事象は起きなくなります。


