RxにつきもののHot Coldについて解説します。HotColdについてはすでに様々な記事で解説がなされているとは思いますが、直感的には理解ができても、本質的な部分については理解できないことがありました。
先日、ようやく納得がいくまで本質部分を理解できましたので、記事にしてまとめます。
一応、他の記事とは違った視点での説明になっていると思います。ちなみに、Hot変換については別記事で書いていますのでこちらを参照ください。ただし、本記事の知識が前提となっています。Hot-ColdとSubject&lt;T&gt;クラスには深い関係があります。
そのため、Hot-Coldの説明の前にSubject&lt;T&gt;クラスについてもう一度復習します。御存知の通り、Subject&lt;T&gt;クラスはIObserver&lt;T&gt;インターフェイスとIObservable&lt;T&gt;インターフェイスを両方実装したクラスです。
したがって、IObserverとしてもIObservableとしても振る舞うことができるという特徴があります。ここで重要なのは、Subjectクラスは、Subscribeしてきた購読者（つまりIObserver）を内部にリストとして保持するということです。購読者がSubjectクラスのSubscribeメソッドを呼び出すと、Subjectクラスが内部に持つIObserverのコレクション（購読者リスト）に、引数で渡されたIObserverを追加します。そして、SubjectクラスのOnNextやOnError、OnCompletedが呼ばれたときに、保持している購読者リストにあるすべての購読者に対して、同様の通知を発行します。つまり、Subjectクラスとは、1つのObservableシーケンスを複数の購読先に分配する、マルチキャストするという役割を持っているクラスなのです。まとめると、Subjectクラスの特徴は次のとおりとなります。このことを踏まえた上で、Hot Coldの説明をします。HotなIObservableとは、購読者を複数持つことができるIObservableのことを指します。
そして、HotなIObservableは「1つのObservableシーケンスを、すべての購読者に対してマルチキャストする」という特徴があります。「複数の購読者を持つ」「1つのObservableシーケンスを複数の購読先にマルチキャストする」と言えばもうSubjectクラスしかありませんね。実は、Hot Observableとは、Subjectクラスそのものを指します。文字で説明されても意味がわからないと思うので、次のコードを見てください。このHotObservableProviderクラスが提供するHotObservableプロパティから取得できるIObservable&lt;int&gt;インターフェイスは、その実体がまさにSubject&lt;int&gt;クラスそのものを指しています。
このように、実体がSubjectクラスそのものを指すIObservableは、Hotであると考えることができます。また、実体がSubjectそのものではなくとも、Subscribeしたときに実質的にSubjectをSubscribeしたのと同じような効果があるようなIObservableも、Hotと見做すことができます。これについても具体例を用意しました。先ほどの例と違って、HotObservableクラス自体がIObservableとなっています。UserがHotObservableクラスをIObservableとして使用するとき、当然このIObservableの実体はHotObservableでありSubjectではありません。しかしながら、HotObservableクラスは、Subscribeすると内部に持つSubjectをSubscribeするのと同じ効果となるように実装されています。したがって、この場合もHot Observableであると見做すことができます。まとめると、Hot Observableは、購読先がSubjectであるようなIObservableとも言えると思います。対してColdなIObservableとは、購読者を1つしか持つことができないIObservableのことを指します。ColdなIObservableは購読者を1つしか持てないので、1つの購読者に対して常に専属のIObservableが存在するということになります。HotなIObservableはObservable:Observer = 1:多であったのに対して、ColdなIObservableはObservable:Observer = 1:1となることが特徴です。なぜCold Observableが「購読者を1つしか持てない」のかというと、Subjectクラスを利用していないからです。Subjectクラスを利用していないので、複数の購読者を管理することができず、ただ1つの購読者に対して専属のObservableが必要になってしまいます。
1つのObservableシーケンスを共有しない（つまり購読者が1つだけ）ならばColdのままで問題ないのですが、共有したい（つまり購読者が複数存在する）場合はHot変換が必要になる場合がある、というのはこのためです。ちなみに、Rxのオペレータやファクトリメソッドから出てくるIObservableは、そのほとんどがSubjectを使っていません。そのため、普通にRxを使っている分には、ほとんどがColdなIObservableになります。これで終わりではなく、大事なObservableソースについてのお話があります。Observableソースとは、Observableシーケンスに流れてくる値の「発生源」です。
そしてこのObservableソースにもHotとColdが存在し、この違いを認識していないと思わぬバグの原因となりますので、Rxを使う上では必ず理解する必要がある知識です。ObservableソースはObservableシーケンスに流れてくる値の発生源などと言われてもいまいちピンとこないと思いますので、例を紹介します。Subject&lt;T&gt;クラスがObservableソースとなる例です。Subjectに対して直接値をOnNextによって送出しています。この場合、Observableシーケンスを流れる値の発生源はこのOnNextにあるので、ObservableソースはSubjectであることが言えます。続いて、ファクトリメソッドがObservableソースとなる例です。この場合、Observable.RangeからObservableシーケンスの値が送出されていることは言うまでもなく、Observableソースはこのファクトリメソッドということが分かります。ObservableソースにもHotとColdがあると書きました。
察しが良い方は勘付くかもしれませんが、上の例で紹介したSubject&lt;T&gt;がObservableソースのものがHotで、ファクトリメソッドがObservableソースのものはColdです。理由は、Subject&lt;T&gt;は複数の購読者を管理できるのでHot、ファクトリメソッドはSubject&lt;T&gt;を使っていない1ので複数の購読者を管理できずCold、ただそれだけです。では、ObservableソースのHotとColdが違うとどう影響してくるのかを説明します。HotなObservableソースとは、Subject&lt;T&gt;が発生源となるObservableソースのことを指します。HotなObservableソースには次のような特徴があります。これはまぁ、想像通りというか、詳しい説明はいらないと思います。
ところが、次のColdなObservableソースの場合、注意が必要です。ColdなObservableソースとは、HotではないすべてのObservableソースを指します。
Rxに用意されているファクトリメソッドから作られるIObservableは、そのほとんどが内部でSubject&lt;T&gt;を使用していないため、ColdなObservableソースとして動作します。ColdなObservableソースには次のような特徴があります。HotなObservableソースと決定的に違う点は、下図にように「Subscribeするたびに新しいObservableシーケンスが生成される」という点です。Hotの場合と違って、ColdなObservableソースはSubscribeするたびに、新しくObservableシーケンスが生成されています。一体なぜこのような動作になるのでしょうか？答えは、「内部にSubjectを使っていないから」となります。Subjectを使わないということは、購読者に対して「直接」値を発行することを意味します。ちょっと何を言っているのかわからないと思うので、コードで説明します。ここでは、Observable.Rangeファクトリメソッドの動作を簡易的に実装した独自のMyObservable.MyRangeファクトリメソッドを作成してみました。Subjectを使わずに値を発行するには、Subscribeの引数に渡されたIObserver（購読者）に対して直接OnNextするしかないのです。必然的に、このObservableシーケンスは、購読してきたIObserver専用となってしまうのです。したがって、複数回Subscribeされれば、その分新しくObservableシーケンスを生成せざるを得なくなります。これが、上記の図の説明となります。そして当然、このような仕様を理解していないと、想定とはまったく異なる動作をしてしまう危険性があります。例えば、以下のように1つのObservable.Intervalを時間差で複数回Subscribeした場合。「同じ変数observableTimerを2回Subscribeしてるんだから、Observableシーケンスは同じで、2個めのSubscribeには10,11,12,…って値が来るんでしょ」と思っていたら、大間違いです。
Observable.IntervalはColdなObservableソースなので、Subscribeするたびに新しく専用のObservableシーケンスが生成されるので、両方とも0,1,2,…と値が発行されます。
もし、前者のような動作をしてほしい場合はHot変換という作業が必要になります。このように、ObservableソースのHot-Coldを意識することは非常に重要で、これらの違いを理解しないままRxを使い込むと、バグの原因となりますので十分に注意が必要です。この記事では、IObservableのHot-ColdとObservableソースのHot-Coldを分けて記述しましたが、本質的には（おそらく）同じで、Subjectを使っているか、使っていないか、それだけの違いになります。
ただその小さな違いが、大きな違い（バグ）を生み出す原因になるので、十分に注意してRxを使うことが必要です。ご意見ご指摘等ありましたら是非コメント宜しくお願いします！[2021/4/2追記]
Hot変換の記事を書きましたので、ぜひこちらも参照ください！一部例外もあるようです。詳しくは@acple@githubさんのこちらの記事を参照ください。 ↩


