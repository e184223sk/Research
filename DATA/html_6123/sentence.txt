More than 3 years have passed since last update.3Dテレビで3D映像を使ったデモをすることになり，Unityで画像処理とも呼べなくもないことをしたのでそのときのことを備忘録として残します．また，今回の方法ではお金がなかったためOpenCV for Unity等のアセットを使用せず，画像をRenderTextureからTexture2Dに変換した上で処理を行なっているので動作が重いです．
一定の実行速度が必要な方はアセットを購入された方が良さそうです．Unity5.6.1f1
LG製3Dテレビ (借り物で詳細な型番は不明です)今回使用する3Dテレビではパッシブ方式が採用されています．
パッシブ方式とは簡単に言うと，左目用と右目用の映像が1行ずつ交互に並んでいる映像を偏光フィルタを通じて見ることで左目には左目用を，右目には右目用の映像を見えるようにすることで立体視する方法です．視差が生じるように適当に離した左目にあたるカメラと右目にあたるカメラを用意し，それぞれのカメラ映像を1行ずつ交互に並べるだけの非常にシンプルな流れになります．まずはじめに，カメラを2つ用意し，それぞれの映像をRenderTextureを用いて取得します．
RenderTextureのままだとpixelの取得ができないのでTexture2Dに変換します．
あとはfor文をpixel単位でMain CameraのSize分回しながら偶数回のときにy行目に左目画像の画像幅分の列を入れ，y+1行目に右目画像の画像幅分の列を入れます．
最後に作成した表示用のTexture2DをGraphics.Blitを使用してディスプレイに直接描画します．左目用のleftCamと右目用のrightCamを設置し，それぞれにRenderTextureを設定します．
RenderTextureのサイズはMain Cameraで表示するSizeの高さを半分にしたSizeで設定してください．
ディスプレイ表示用のMain Cameraもシーンに配置します．
あとは映像のテスト用に適当にCubeを配置しています．
cubeは映像の確認用に回転するようにしています．少し見辛いですが今回作成したシーンがこちらです．
そして各CameraのInspectorがこちら．
実行した結果がこちら．
これだけだといまいちわかりづらいのでScriptなしの実行結果がこちら．
視差画像になっているのがなんとなくわかるでしょうか．
やはりRenderTextureからTexture2Dに変換しているため，だいぶ動作が遅くなっています．[Unity] カメラ画像の輝度を取得する
http://ftvoid.com/blog/post/970
【Unity5】複数のカメラのレンダリング結果を1つのテクスチャに重ねて画面へ出力する方法メモ
http://qiita.com/r-ngtm/items/f8efedb6c81ae8b4c9ce


