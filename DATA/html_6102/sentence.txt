More than 3 years have passed since last update.結城浩氏著の「Java言語で学ぶデザインパターン【マルチスレッド編】」をC#で使用するにはどうするか？
ということで、C#で実際に実装してみた。
また、デザインパターンの自分なりの理解を備忘録として残しておく。こちらから移動ここに独断と偏見でまとめた一応、ここに書いているのは個人の解釈が主なので、正解じゃない可能性が高いです。
現に、かなりの頻度で修正を入れています。（現在進行形）クラスメソッドを以下の２パターンに分類する上記UnsafeMethodに対して、lockステートメントを使用してスレッドセーフにするクラスを以下の２パターンに分類する上記のImmutableクラスは、複数のスレッドから同時にアクセスしても問題ない
そのため、lockステートメントを使用しなくてもよい
クラスがImmutableであるかどうかを意識することが重要である
Immutableクラスは、外部フィールドはreadonlyまたは読み取り専用メソッドのみとし、メソッドもクラス内部を変更する処理は行わない値オブジェクトはImmutableなクラスであるといえるっぽい　
　→値オブジェクトは状態を持たないから
つまり、値オブジェクトはスレッドセーフであるといえる（はず）つまり、「条件が満たされるまでは待ちが発生するスレッド」を実現する
パターンの意図としては、条件付きのSingle Thread Execution パターンとして使用するChannelは、Producer向けとConsumer向けそれぞれのガード条件付きメソッドを持つ。
ProducerおよびConsumerは、Channelのメソッドを呼び出すだけなので、ガード条件の存在を知る必要がない。もっというとスレッドセーフであるかどうかを気にする必要もない。
→スレッドセーフの責務を負うのはChannelのみ以上より、排他制御には３種類存在する。以下、C#でのTask.Startとawaitを使用することで、非同期で処理をスタートし、処理の終了は同期をとれるかを確認してみた。
（処理結果を受け取ることはしていないが、Futureパターンの本質は上記のように処理開始は非同期だが、処理の終わりは待合せたいということだと解釈しています）上記FutureSampleAsyncを実行すると、以下のように出力された。
Await BEGINの前にTask BEGINが出力されたことで、task.Startですぐに制御が戻って、かつラムダ式内の処理が非同期に裏で実行されていることがわかる。 
最後、Task ENDの後にAwait ENDと出力されていることから、処理完了を待合せていることがわかる。本の中では、volatile修飾子が出てくる。本はjavaだが、たぶんC#でも本質は変わらないはず。
volatileの効果についてはこちらを参照。本ではjavaの同名クラスを紹介していたが、たぶん同じサンプルが複雑でかなりげんなりしたが、たぶん言いたいことは以下だと勝手に意訳つまり、勝手に解釈すると、FutureパターンとWokerThreadパターンの融合？個人的な解釈としては以下。WaitメソッドおよびPulseメソッドは、lockステートメント内で実行することが前提となる。Waitメソッドを実行すると、内部ではlockによる排他制御を開放してスレッドがwait状態に入る。これは、コード的には直感的でないように思えるんだけど、かなり重要なことだと思う。 ↩


