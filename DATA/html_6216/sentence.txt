More than 3 years have passed since last update.Azure のサーバーレスサービスである Azure Functions で、Durable Functionsという新しい機能が公開されました。もちろんまだ GA ではありませんが、自分的には相当熱い機能です。これを教えてくれた Kanio と、これあったら、もうサーバーイランのとちゃうん！と盛り上がりました。これもいつも通り、自分のためのメモとしてかいていきます。Durable Fucntions は Azure の extension で、ロングランニングで、ステートフルなFunction のオーケストレーターです。これだけではよくわからないと思うので、ユースケースを見てみましょう。今回は公開されたというレベルなので、発展途上ですが、既にこんな機能が実装されています。具体的な実装例が、ここで見れます。Function から Function を簡単に呼べる Function Chaining パターン並列実行して、それが全部終わったら、次のファンクションに流す。非同期実行を、最後で待ち合わせてくれるのがみそ。これはロングランニングの非同期 HTTP API の実行で役にたつパターン。ロングランニングの非同期実行のfunction のステータスを問い合わせられるAPIが作られる。これが自分的には熱いのですが、Service Fabric でもおなじみのActor を使える。つまりStateful を扱えます。 Service Fabric の実装とは異なってライトウェイトでシンプルな感じです。人が介入して承認とかするようなパターンです手始めに、自分で複数のfunction を並列実行させて、その戻り値を返すようなFunction を書いて、ローカル、Azure の両方で動かしてみたので、シェアしたい。Install Durable Functionsの指示通り、実施すればよい。現在のところ、C# のみであるが、Visual Studio 2017 Preview (2) がDurable Function サポートしている。大まかにいうと、Visual Studioという感じだ。ちなみに、local.setting.jsonのサンプルをあげておくとこんな感じ。Azure Functions はローカルで起動してデバッグできるが、その設定。Azure ちなみに、Visual Studio がなくても、Azure だけあれば、実施できる。その場合は下記の感じ。これも同じく先のページの手順でいける。これで、基本的な設定は終了だ。ちなみにサンプルソースは、ここに置いておいた。最初に、最初のリクエストを受け付けて、該当する Functions を実行する Function を作成する。このコードはほぼ定型になるだろう。ポイントは、アノテーションで、ファンクション名を指定しているところと、OrchestrationClientというアノテーションで、DurableOrchestrationClient をRun の引数にとっているところだ。　ここにわたってきた、functionName をもとに次のファンクションが実行される。今回の構造は、というシンプルな構成で、ParallelExec が EchoExec を３並列で走らせて、結果が戻って着しだい、呼び出し元に対して結果を返すというものだ。先のパターンでいうと。1.2.に該当する。次に ParallelExec Point 1 で、OrchestrationTriggerのアノテーションを指定して、Context を取得している。Point 2 context.CallFunctionAsync で、別のファンクションを実行している。ここでは、EchoExec である。そこに、引数を渡して、非同期実行している。awaitキーワードは非同期実行の待ち合わせをして、同期処理のようにかけるが、スレッドはブロックしないため並列処理の効率が良い。 Point 3 Task.Wait(tasks) によって、３つの非同期処理が、３つとも３並列で動いているが、それがすべて終わるまで await で待ち合わせている。
最後に、 Point 4 で、さらに次の Function の実行部のロジックが記述されて、いる。これを実行してみよう。F5 キーでローカルに Function が起動する。起動しおわったら、Postman などでアクセス可能になる。このコンソールの一番最後にアクセス先が出てくるので、リクエストをポストする。おそらくhttp://localhost:7071/controller/ParallelExec になる。動いた！この赤く囲ったURLをクリックしてみよう。これが結果を見るURLだ。しっかり予想通りの結果になっている。Visual Studio のプロジェクトここでは DFSample を右クリックすると、Publish が選択できる。ウィザードに従えば、Azure Functions がサーバーに送信されて動くようになる。先ほど書いたファイルがそれぞれUpload されている。ポイントは、ControllerFunction の1をクリックすると、このFunction にアクセスするURL が得られる。 2 もポイントである通常のAzure Functions だと、run.csx と、 function.json が少なくともあるのだが、ここにはない。function.json を見ると、最後にScriptFile で、dllを指定しているので、クライアントからは、dll 形式になってアップロードされていると思われる。実行してみるともちろん結果は同じさて、わたしは、Durable Functions を、Azure の Portal のみでも作ってみた。そのケースは、自分で、function.json を書く必要がある。例えばこんな感じ。将来はテンプレートが選択可能になるだろう。function.jsonrun.csx#r の指定、そして、アノテーションが無くなっていることに注意されたい。実はAzure Function を普通に書くケースはこのような感じで、クラスの形式になっていない。先のクライアントのコードは、Class でアノテーションがある。こちらのコードが先のような形式に変換されて実際はDLLに格納されるのかもしれない。ちなみに、Azure Portal 用のコードは、Gistに置いておいたのでよかったらどうぞ。Azure Functions の Durable Functions は自分的には相当可能性を感じる。相当な複雑な並列実行ワークフローも簡単に書けるし、シンプル。しかも、ロングランニングなものの考慮、アクターの実行までできる。ほんまこれがあれば、サーバーの御守が不要になる未来が近づいているのを感じる。今後も継続的に機能を試していきたい。


