もくじ
https://qiita.com/tera1707/items/4fda73d86eded283ec4f■連打防止関連
ボタン押したときに時間がかかる処理をawaitでやるときに、ボタン連打を防止したい
→https://qiita.com/tera1707/items/a6f11bd3bf2dbf97dd40
ボタン押したときに時間がかかる処理をawaitでやるときに、ボタン連打を防止したい その2
→https://qiita.com/tera1707/items/946116bf32d0f1203006以前、掲題の内容をやりたくて、prismのDelegateCommandクラスを使って連打防止をやってみた。
ただそのときのやり方だと、同じようなことを複数のボタンでやろうとしたときに、同じようなフラグを何個も作らないといけなくなるため、もう少しマシなやり方を探していたところ、その記事に、@unidentifiedexeさんに良いやり方のコメントを頂いた。コードのサンプルも書いて頂いて、そのまま使えそうな感じだったのだが、一応自分でも理解しておきたいということで、練習がてらコードを纏めてみたい。WPFの画面(xaml)、ViewModelと今回作成したコマンドのクラスのコードは下記の通り。(コードビハインドは省略)
UnRepeatableAsyncCommandが、今回作った連打防止Commandを実装したクラス。このコードの動きとしては、という動きなのだが、
連打防止コマンドクラスの中にあるpublic async void Execute(object parameter)の中の2か所のCanExecuteChanged?.Invoke(this, EventArgs.Empty);をコメントアウトすると、ボタンが無効にはなるのだが、見た目がグレーアウトしなくなる。自分の理解が足りてない部分なのだが、
ICommandのCanExecuteChangedイベントハンドラは、CanExecuteChangedにメソッドを入れておくと、WPFのフレームワークが、CanExecuteが変化したタイミングで勝手に入れたメソッドを呼んでくれる、というものではなかったか？？
(つまり、自分でそのイベントハンドラを呼ぶようなものではないと思っていた)サンプルコードのとおり、CanExecuteChanged?.Invoke(this, EventArgs.Empty);をしてやると見た目も変わってくれるが、なぜそのような動きになるのか？が現状わかっていない...
(が、とりあえず動くものにはなったのでメモ代わりに残す...)albireoさんからコメント頂いた内容をもとに、コードを直してみた。これで、思ったことはひと通り出来てるだろうか...CanExecuteChangedめんどくさい問題を調べてみた
https://qiita.com/204504bySE/items/0c7d5ac6913673dc10f5


