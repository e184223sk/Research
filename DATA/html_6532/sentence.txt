More than 3 years have passed since last update.重い処理に対して、どのくらいまで処理を行ったかを知りたい場合がある。ある人にバッチでコンソールに進捗表示をさせる処理の作成を頼んだ結果、サンプルコードのようなコードを作成していた。話を聞いてみると、オブザーバーパターンで実装したとのこと。実装はともかく考え方は参考になったので、サンプルコードで考察してみる。Somethingクラス内に進捗表示をするため、progressCounterを渡している。
進捗表示:ProgressCounter(ConsoleTestプロジェクト）
ビジネスロジック:Something.Do(Qiitaプロジェクト)
※ConsoleTestからQiitaプロジェクトを参照している。このコードはビジネスロジック側に暗黙的に影響を与えている。
ProgressCounerが処理件数を持っており、Something.Doと処理件数が一致していなければいけない。一ループ、一件の前提が必要でありcontiuneを入れてスキップをいれただけで件数が一致しなくなる。
処理件数はDoから渡すだけでよく、２重持ちをする必要はない。一方、インターフェースにしたことで、進捗表示はコンソール以外でも対応可能である。Windows FormのProgressBarを使用しても、ビジネスロジックには何の影響もない。この点は評価に値する。IProgressCounterを関数の引数にしているが、ビジネスロジックで使用する引数のみにするべきである。依存性の注入のほうが良い。明示的な開始と終了処理が必要だと思うので、Start,End関数を追加している。また、NullObjectパターンを前提にしているので、Nullチェックはしない。
コーディングの都合上、改良後のコードは別フォルダに配置しているので、Modfy.ProgressCounterやQiita.CounterOK.Somethingという名前空間にしている。
尚、マルチスレッド化は考えず、元のコードを活かすようにした。リファクタリングすることで、改良前よりはビジネスロジックへの影響は少なくなった。ビジネスロジック内に進捗表示処理が残ってしまうのは仕方ない。
本来は自由につけはずしができるようなクラス設計が望ましい。
つけはずしであれば、デコレーターでDecorator.DoをSomething.Doに被せることは可能だが、シグネチャを合わせないといけないので現実的ではない。目次


