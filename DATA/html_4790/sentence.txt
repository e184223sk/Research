More than 3 years have passed since last update.かずき師匠にいつもたすけてもらっているが、今日も自分で書いたコードをかずき師匠にレビューしてもらった。自分で学んだ新しいこともあるし、ここに記録していつでも実行できるようにしておきたい。こんな感じの Extension メソッドがあり、これがあると、同時実行数を制御しながら並列実行できる。ところが、お客様の要件としては、重い処理の大半が並列作業だが、順序実行が必要な軽い処理がある。どうするか？というお題を解く必要があった。最初に考えた方法はこんな感じ。ループにインデックスがあり、それをキーにして、ConcurrentDictionary にぶち込んであとで、そこから順序実行に必要な成果物を取得すればいいんじゃね？と思って書いたコード。こいつはくせぇ。げろ以下のにおいがプンプンしやがるぜ。しかし、三流プログラマの私はこれを書くだけでも調べる必要があり、例えば、Tuple の書き方ってどんなんだっけ？とか、インデックスをふるLinq はどんなんだっけ？という感じTuple の書き方はラベル付きでという感じ。ラベルなしでもかけてラベルなしの場合は、tuple.Item1 tuple.Item2 みたいな感じでアクセスします。という感じ。ちなみに、Tuple のジェネリクスの型を調べてみると、VS で見るとこんな型で行けそう。ちなみに、ValueTuple 型以外にも Tuple 型があります。こちらに、比較を書いている人がいました。通常のリストを Index 付きにする方法は、Linq の Select が使えました。Select の引数の関数にindex の第二引数をつけるだけです。これは楽ちん。スレッドセーフなコレクションには、キュー、スタック、バック（順番性保証なし）などがありますが、今回は Dictionary をチョイスしてみました。アウトのパラメータがTryGetValue ででてきます。これでしっかり思った通りの動作をするのですが、あきらかにコードがきな臭いです。何がきな臭いか？というと、index の付与の部分ですが、こんなんせんでも、インデックスをExtension の中で書けばええんちゃうの？というわけで、書き直してみました。これで、渡された関数に、インデックスがわたるので、思うがままです。渡される関数の部分ですが、にしました。最後の一つのみが戻り値で、それ以外が引数です。Funnc の仕様に関してはこちらがいい感じ。ここで悩みました。ちゃんと動作するのですが、きな臭いです。特にメソッド名が。IndexedParallelForEachAsync(...) は観たことないから絶対にこんな名前にするべきではない。だから、かずきせんせいにレビューをお願いしました。すると斜め上の回答が返ってきました。IndexedParallelForEachAsync の中で処理の戻り値をリストかなんかに入れればいいんじゃないんですかねぇ？そら、そうだよね、なんか途中でコンカレントディクショナリに入れてそれをまたループさせてとってとかダサすぎです。orz ダサさに気づいていませんでした。というわけで案３にトライです。メソッドの名前は同じですが、ジェネリクスの型が違うので共存できます。メソッドシグネチャを変更して、戻り値と二つの型を返すようにしています。ここで戻り値はにしています。Rが戻り値の型で、そのEnumerableをTaskにくるんで返します。すると、async メソッドの中で、IEnumerable が返ってくるはずなので、後続の処理をLinq でかけたりもするでしょう。Linq でつなげて書いてもよかったですが、お客さんにわかりやすいように２つのパートに分けて実施。かなりすっきりしました。ちなみに、すっきりして、こんな感じでやりましたーと報告したら、かずきさん曰くあと、こう書けるかもしれませんね
 return Task.WhenAll(items.Select(x =&gt; InvokeThrottledActionWithReturnValue(x, action, semaphore));おお、ということは、エクステンションメソッドの最初のメソッドがワンライナーになるやん！さすがでございます。ちなみに、以前かずきさんはエクステンションメソッドを最初にみたときに、RX ならこんな感じでかけるのでは？ともいっていました。師匠がいるのは本当にありがたいことです。今回のソース。コミットで過去の経緯が見れます。


