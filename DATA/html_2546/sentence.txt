More than 1 year has passed since last update.Python のリストや numpy ndarray の基本操作に対応する処理を、C# でどう書けばよいか？
毎回ウェブをあちこち探すのはとても時間がかかります。普段 Python を使っていてたまに C# で書くとき、すぐに対応が見つかるように、一通りまとめておきます。Python 3、C# 6.0 (.NET Framework 4.6) を前提にします。.NET Framework 3.5 でも一部を除き対応していると思われます。C# の配列とリストはどちらも IEnumerable を実装しているので、LINQ の説明の多くは配列でも使えます。（Python 標準ライブラリの array.array はあまり使われないと思いますので省略します。）オブジェクト名に以下の文字を入れておきます。
宣言や宣言時の型は、誤解がない範囲で省略します。この記事は、数値計算や機械学習の置き換え、パフォーマンスを目的とはしていません。あくまで、Python のリストや numpy.ndarray の基本操作に類似した操作を C# で書く場合の参考です。本来の numpy 的用途（速度重視）なら、BLAS や MKL など専用演算ライブラリがベースにあるモジュールやパッケージを使った方がもちろん高速なはず。たとえば Math.NET Numerics (MKL版) とか。Python3 の range （Python2 だと xrange）と C# の Enumerable.Range はどちらも遅延評価されます。range/Range もそうですが、Python では (開始値、終了値+1) とするのに対し、C# では (開始値、要素数) とするメソッドが多いようです。Python の range(start, stop, step) に合わせた実装を考えてみます。一般には、先の「(*1)を拡張してみる」の実装で、小数の場合でも行けるのではと思います。一方、先の MyRange を double 版の実装にして 0.1 ずつインクリメントなどしてしまうと、丸め誤差で大小比較の判定がうまくいかないです。decimal 版なら大丈夫でしょう。内包表現 (list comprehension) を使っていたところは、LINQ の Select で何とかなることが多いです。あとは、文脈をよく考えて、遅延評価をするかしないか判断が必要になります。
遅延評価した方がよいなら ToList() せず IEnumerable のままにします。要素の総和が1になるように正規化する方法をまとめておきます。確率計算でもよく使います。Python では、イテレータが欲しい、遅延評価したい、という場合はリスト内包表現ではなく map や filter を使えますが、これは LINQ だとそのまま Select と Where に対応しそうです。filter と map が組み合わさってくると、LINQ のようにメソッドチェーンで書く方が分かりやすいですね。リストや配列の値だけでなくそのインデックスも欲しい場合、Python では enumerate ですが、C# では Select を使えます。LINQ の Select は、value, index の順序が Python の enumerate と逆なので注意が必要です。LINQ の Zip は3つ以上のリストをとれないので、Zip を繰り返して使うことになるようです。一段目の Zip でペアをそのまま次段へ匿名型で渡せば、二段目の Zip でまとめることもできます。(*1) リストを入れ子で作る場合など、参照型で ’Repeat’ してしまうと、ひとつ変えるとすべて変わります。この落とし穴は Python の [値] * 要素数 と同じです。
https://qiita.com/yosizo@github/items/1adcff1fc974cde5256a「遅延評価せずリストや配列にする」の通り、Range を ToList() や ToArray() で連番の値を持ったリストや配列を作ることができます。Python で range から list や np.array を作るのに対応します。numpy の random.randint は、標準ライブラリの random.randint とは異なり（むしろ randrange と同じで）指定値未満の乱数を返すので注意！Next()の第一引数（最小値）は省略すると0以上となります。乱数生成アルゴリズム自体を変える方法はこちらで解説されています。空のリストにも対応するなら Aggregate の第一引数にシードを与えます。「特定のキーで Min() や Max() すると、そのキーの最小（最大）値だけが戻ってきてしまうが，要素のインデックスもしくは（キーを含む）オブジェクトそのものを取得したい」という質問は昔から StackOverflow でも何度も出ているようです。（Qiita でも。）別途実装せず LINQ でシンプルに書くには、例えば以下のやり方があります。n が小さければ、可読性重視で 2, 3 もありかも。
再利用性も考え、素直にループ（イテレータ）で実装しておくか、すでにある実装を使うのもよさそう（MoreLINQ の MinBy や MaxBy など）。よく使うリスト操作の対応です。リストが絡む文字列操作に限定して取り上げます。しばらく別の言語で書いていると、Python の join は書き方に迷います。C# の Split では、セパレータに char を渡すときは単純ですが、文字列を渡す場合は第二引数のオプション指定（StringSplitOptions.None など）が必要です。
Join は基本文字列を渡します・・・ややこしいですね。string.Join の代わりに Aggregate を使うとメソッドチェーンで書けますが、こちらの記事で議論されているようにいくつか問題があります。
まず、空のリストが渡されると例外が投げられます。初期値として空文字を渡すと例外を回避できますが、今度は先頭にもセパレータがついてしまうため、これを削除（上の例では TrimStart）する必要があります。StackOverflow では以下のような書き方も紹介されていました。パフォーマンスも string.Join 並みによいということです。ただ、いくつかの記事やスレッドを追った感じでは、あえて Aggregate にせず、素直に string.Join する方がよい、という結論が多いようです。List の内部は配列なのでソートのアルゴリズムは同じとか。
ソートアルゴリズムの安定性について：Reverse() はちょっと強引ですが、もともと Array.Sort() も安定ソートではないので、同じ値のデータの順序を気にしない場合はありでしょう。
一方で、LINQ の OrderBy() は安定ソートとのこと（Stack Overflow より）。安定なソートが欲しい場合は LINQ が手っ取り早いかも。ちなみに Python では list のソートは安定で、numpy でも 'stable' をオプションで渡すと安定性が保証されます。この Stack Overflow の記事を参考にしました。そろそろ Math.NET などパッケージを入れたほうがよいかもしれません。以下書きかけです。リストのリストを矩形行列としてみた操作（つまり内側のリストはすべて同じ長さと仮定）。Repeat ではなくそれぞれ実体化していく。いったん {val, j} を要素とする x へ平坦化したあとに、インデックス j でグルーピングして y とし、それぞれのグループで平均を計算している。参考: https://teratail.com/questions/76764


