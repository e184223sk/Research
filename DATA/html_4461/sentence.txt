More than 1 year has passed since last update.Unity 3DでUpdateとFixedUpdate間のタイミングを考慮したジャンプ（基礎）
Unity 3Dでアニメーションを考慮したジャンプ その1（単アニメーション）
の続きです。上記記事で設定したジャンプアニメーションをベースに改良していきます。前回記事 にて確認した通り、単アニメーションでのジャンプはジャンプの挙動が様々に変化するゲームには向いていません。なので、ジャンプの内容が変わってもきちんと対応出来るように変更します。アニメーションを分割し、アニメーション間の遷移をAnimatorとコードを使って行うことで、遷移のタイミングをずらしたり、遷移先のアニメーションを動的に変更できるようになります。アニメーションを持っているfbxファイルを選択するとInspectorに表示される、Animation から分割することが出来ます。
Clipsの欄の右下にある＋ボタンを押すことで、アニメーションを追加することが出来ます。
増やしたアニメーションは、そのままではJUMP00の丸コピーなので、まだ分割されていません。これを、以下4つのモーションに分割します。Inspectorの下にアニメーションを再生できる表示がありますので、これを使ってアニメーションを再生しながら、それぞれの区切りとなる時間で各モーションを分割していきます。

ジャンプ前のモーションの時間を指定したところです。どんなモーションなのか自分の分かりやすい名前に変更し、Lengthのところで分割するモーションの時間を指定します。また、Root Transform Position (Y) を feet （足元）に設定しています。
ここはアニメーション毎に最適な原点位置が違うので、モーションとして最も自然な形になるように、またコライダーの位置ともズレが起きないように調整が必要です。これをあと3回繰り返します。

上昇中からジャンプ頂点を越えて下降中に移行するモーションは、下降中モーションに含めたほうが自然な再生が出来ると思います。
なので、上昇中モーションはジャンプ頂点に入る少し前のところまでで切ります。

同様の理由で、下降中モーションも着地に入る手前のところで切ります。

これでアニメーションが分割出来ました。Inspectorをスクロールして一番右下のApplyボタンを押すと、分割したアニメーションがfbxに反映されます。
分割したアニメーションの制御のために、AnimatorにもStateを追加します。

パラメータはすべてBoolで追加し、Transitionでは同名のパラメータがONになったら遷移するように設定します。
今回、一連のジャンプ記事で筆者がやりたかった内容がこれです。ジャンプボタンを押している間ジャンプ力を溜めて、離したときに溜まっているジャンプ力でジャンプの強さを変更します。溜めたジャンプ力によって上昇中と下降中の状態の長さが変わるので、アニメーションの遷移をコードで制御します。コードでアニメーションの遷移をするので、遷移条件の判定と遷移処理を追加します。を実装します。一番ポイントになるところは、ジャンプの頂点を越えて下降中になるところの判定でしょうか。raycastで地面との距離をとれるようにしてあるので、前フレームとの差をとって、＋（上昇中）か、－（下降中）かで判断を行います。ただ、ジャンプ頂点の判定にraycastの距離を使っていて、測定できる距離に上限をとっているので、上限以上にジャンプしてしまうとモーションの遷移が行なえません。
raycastの測定距離上限は、ジャンプで想定される最大高さに多少のマージンを足した値にしておく必要があります。また、ジャンプキーの入力について、上記の仕様ではkey down、key upと書きましたが、使うメソッドとしては UnityEngine.Input.GetButton で変わりありません。最初は GetButtonDown と GetButtonUp で実装したのですが、ジャンプキーを押してから溜めモーションに移行するまでに本当に少しですが時間がかかるので、その間にジャンプキーを離すと、ジャンプキーが離されてから溜めモーションに移行して次の GetButtonUp が来るのを待ってしまうため、もう一度ジャンプキーを押さないとジャンプ出来ません。なので、押されている間trueになり、離されたらfalseになる GetButton のほうがここでは都合が良かったです。こういった特定の状態から条件によって行うべき内容が変化して次へ次へと移行していく形式のものは、バグが紛れ込みやすくなるのでその扱いには気をつけないといけません。一番単純な構造としてはと状態を定義し、遷移条件判定や各状態の内容処理の場合にそれぞれでswitchをかけるというものがありますが、同じswitch文が各所に出現したり、どこで何の処理をしているのか分かりづらくなるなど問題が多く、この形の処理は出来る限り避けた方が懸命です。ではどうするのかと言うと、前回までに書いてきた既存のコードは捨てて、一から定義し直すことになります。
ここまで来て書き直しとかめんどいやりたくない・・・と思うかもしれませんが、時間がかかっても最も正攻法なやり方をとるのが実は一番近道だと知っているのがプログラマですので、ここは我慢してゼロベースで考え直します。（と自分に言い聞かせている）とはいえ、外側の管理構造は変えますが、詳細な処理部分については流用が効く部分も多いので、本当に完全にゼロからというわけではありません。
ここまで作ってきた内容が無駄になるわけではありません。（と自分に言い聞かせている）さて、switch するのは良くないので、じゃあどうするかと言うと、各状態をクラスとして実装し Dictionary に置いておき、状態が変わるごとに必要なクラスを取り出して使う、という方法があります。使わないのはswitchの分岐処理だけなので、JumpStateはさっきのEnumがそのまま使えます。
Start() や FixedUpdate() でも処理が必要ですが、基本構造はこれで回せるはずです。これを実現するために、というインターフェイスを用意します。これは各状態を実装する際の基盤とするもので、インターフェイスを継承したクラスはインターフェイスにあるメソッドを全て実装しなければなりません。
管理クラスから見ると、このインターフェイスを継承しているクラスにはこれらのメソッドが実装されていることが保証される事になります。各状態の処理をそれぞれのクラスに記述し、上位の管理クラスでは各クラスの保持とどのクラスの処理を実行するのかだけを管理するようにします。入力待ちのアイドル状態を管理します。
ジャンプキー入力開始（key down）でジャンプ溜め状態に移行します。本来の Animator には animationStart というメソッドはありませんが、C#の拡張メソッド機能を使って追加してあります。animationStart 自体は一緒に追加した radioBool の呼び出しのみで、radioBool メソッドは引数で指定したBoolパラメータのみをtrueとし、他のBoolパラメータはすべてfalseに落とすメソッドです。同時に追加している isName は、現在進行中のアニメーションが指定したアニメーションかどうかを判定し、animationEnd は、アニメーションが終了したかどうかを判定するメソッドです。
後で使います。ジャンプ溜め中の状態を管理します。
ジャンプキーが離されたら（key up）上昇中状態に移行します。ジャンプキーを押している長さの分だけジャンプパワーを溜めますが、溜めるのはWaitingで使うのがRisingで、別クラスでの操作になるため、横串でデータのやり取りをするためのクラス JumpData を追加しました。毎フレーム毎に溜めるパワーの値と、溜められるパワーの上限を外部から与えられるようにしてあります。
管理クラスを通してInspectorで設定できるようにするとUnity的な使い方が出来ます。上昇中の状態を管理します。
初回のFixedUpdate()で、Rigidbody.AddForceを使って上方へのジャンプを行います。
また、ジャンプの頂点を過ぎて下降を開始したら下降中の状態へ移行します。ジャンプが下降に移る際の判定のために、新しく JumpDistance クラスを追加しました。
各状態がキャラと地面との細かい距離を知って判定する必要は無いので、判定処理を丸ごと任せて結果だけを貰います。isFalling は上昇中に、isLanding は下降中に毎フレーム呼ばれるので、check メソッドをここで呼ぶようにし、接地中はraycastの判定をしないようにしています。より負荷を軽減するなら、2フレームか3フレームに1回だけ check するような形にしても、動作上はそこまで影響はないかと思います。
1点気をつけるとすれば、実は今回の処理では isLanding の設定判定に使っている _ground_distance_limit の値を、ちょっと遠目にしています。
接地前からアニメーションを開始しておくことで、アニメーション上の着地と実際の着地が近いタイミングになるようにしているので、フレームを飛ばすならそこは再調整が必要になりそうです。また、今回は完全にジャンプ処理だけに注目しているコードなので isFalling 、isLanding の中で check するようにしましたが、実際に3Dゲームで使う際に、ジャンプではなく段差を降りるなどで下降モーションを起こしたい場合、ジャンプ中しか距離計測していないのではアクションが起こせないので、そういう場合も再検討が必要だと考えられます。下降中の状態を管理します。
着地したら着地状態へ移行します。着地の状態を管理します。
着地モーションが完了したらアイドル状態へ移行します。animationEnd は、animationStart と一緒に追加した拡張メソッドで、再生中のアニメーションが終了したかどうかをbool値で返してくれます。
また isName と同等の処理を animationEnd の中で行っているため、ここでは不要です。各状態を管理するクラスを作ってきたので、最後は状態の変遷を管理するクラスを作成します。基本構造は記事の最初の方で出てきた状態管理のものそのままです。初期化処理では、 JumpData と JumpDistance を生成し、情報が必要な状態にだけ渡しています。
それから状態とクラスのリストを作成し、最初の状態 JumpState.IDLE を設定、開始しています。FixedUpdate では、各状態の stayFixedUpdate を呼び出していますが、今回処理が行われているのは JumpStateRising だけです。
空メソッドの呼び出しだけならそこまで高コストにはならないので恐らく許容範囲と思いますが、必要であれば特定の状態のときだけ stayFixedUpdate を呼び出すような形にすることも考えられます。UnityちゃんにAttachするのは、このPlayerStateControllerだけです。
スペースキーを押すとジャンプ待機、離すとジャンプし、待機時間でジャンプの強さが変わります。アニメーションを分割してコードから操作するようにしたら、タイミング調整とか、今回はやってませんが途中でアニメーションを入れ替えたりとかも出来るのでめっちゃ便利になりますよね！っていう記事を3回に分けて書いてきたのですが、最終的に辿り着いたのは「状態管理って難しいしめんどくさいよね」でした。内容的には初心者はクリアした初級者向けあたりになるのかな？と疑問に思いつつ、意図的にUniRxの記述を避けてきたのですが、外部の誰かがジャンプの状態を知りたい状況でなければ使うメリットがそれほど無いのではと思っています。あるいは現在の状態をReactivePropertyにして、状態が切り替わったらアニメーションを切り替える形なら、現在の「状態がアニメーションを管理する」のではなく、「状態の変更条件のチェック」と「アニメーションの管理」を切り離すことは出来るかもしれません。もしくは、ジャンプキー入力やraycastで取っている地面との距離をReactivePropertyにすれば、必要なタイミングを教えてくれるように出来て、メソッドに起こさなくてもラムダでその時その時の処理を書けば良いだけに出来るかもしれませんね。
もっとコンパクトでスマートなコードになるのなら検討する価値は大いにありそうです。（手のひらクルーが速い）Rxもオブジェクト指向もDDDも、すべては関心の分離のために行われている気がしてきているので、そっちの方向でプログラミング出来るならより良いコードになりそうです。


