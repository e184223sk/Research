More than 3 years have passed since last update.すでに整列してある2つの配列を合併（マージ）して、整列された配列を作るのは比較的簡単です。
マージソートは、これを利用して、配列をソートする手法です。簡単にその手順を示します。手順２で、再帰的にこの処理を適用するわけですが、分割した後の要素が1個ならば、整列済みとなるので、再帰的な適用は行いません。このマージソートは、非常に速度が安定しており、最悪計算量が、O(n log n)です。また、整列データに対し、インデックスを指定してランダムにアクセスする必要がないのが特徴です。アルゴリズムの勉強のために、このマージソートをC#で書いてみました。以下、最初に書いたコードです。Sortメソッドは、汎用性を持たせるため、IEnumerable&amp;amp&lt;T&gt; を受け取り、IEnumerable&lt;T&gt;を返す仕様としました。後述のコードを見ていただければわかりますが、MergeSort.Sortメソッドがとても簡潔なのがお分かりになると思います。その下位ルーチンである、２つのソート済みシーケンスをマージするロジックの方が、複雑なアルゴリズムだというのがその簡潔さを物語っていますね。しかし、このプログラムは、LINQの遅延実行の関係でものすごく遅いです。使い物になりません。ということで以下のように途中で、ToArray()を呼び出すように、書き換えました。これで速くなりました。速くなったのはいいんですが、このMergeメソッド、ソートする要素数を多くして(7000個程度)動かしてみたら、途中でスタックオーバーを起こしてしまいました。なかなかいいコードだと思ったんだけどな...ということで、Mergeメソッドの再帰処理はあきらめて、ループ処理に書き換えることにしました。Sortメソッドは再帰処理のままです。以下に、C#のコードを示します。Mergeメソッドは、随分と複雑になってしまいましたが、背に腹はかえられません。これでスタックオーバーは回避できました。速度もさらに速くなりました。
すみません、正確に計測してません m(_ _)mところで、MoveNextとCurrentって、普段あまり使わないので、どっちから先に呼び出したら良いのか、わからなくなるんですよね。僕だけでしょうか？最後に、このクラスの動作を検証するために書いたコードを示します。LINQのOrderByでソートした結果とマージソートで並び替えた結果をEnumerable.SequenceEqualを使って比較しています。この記事は、Gushwell's C# Programming Pageで公開したものを加筆・修正したものです。


