
namespace OpenCvSharp
{
    using UnityEngine;
    using System.Collections;
    using OpenCvSharp;
    using UnityEngine.UI;
    using System;
    public class q9 : MonoBehaviour
    {
        public Texture2D texture;
        // Use this for initialization
        void Start()
        {
            Mat mat = Unity.TextureToMat(this.texture);
            Vector3[,] v = new Vector3[mat.Height, mat.Width];
            for (int yi = 0; yi &lt; mat.Height; yi++)
            {
                for (int xi = 0; xi &lt; mat.Width; xi++)
                {
                    Vec3b vyx = mat.At&lt;Vec3b&gt;(yi, xi);
                    v[yi, xi][0] = vyx[0];
                    v[yi, xi][1] = vyx[1];
                    v[yi, xi][2] = vyx[2];
                }
            }
            v = Gaussian(v, mat.Height, mat.Width);
            for(int yi = 0; yi &lt; mat.Height; yi++)
            {
                for(int xi = 0; xi &lt; mat.Width; xi++)
                {
                    Vec3b vyx = new Vec3b();
                    vyx[0] = (byte)v[yi, xi][0];
                    vyx[1] = (byte)v[yi, xi][1];
                    vyx[2] = (byte)v[yi, xi][2];
                    mat.Set&lt;Vec3b&gt;(yi, xi, vyx);
                }
            }
            Texture2D changedTex = Unity.MatToTexture(mat);
            GetComponent&lt;RawImage&gt;().texture = changedTex;
        }
        public Vector3[,] Gaussian (Vector3[,] target,int height,int width)
        {
            Vector3[,] result = target;
            for(int yi = 0; yi &lt; height; yi++)
            {

                for(int xi = 0; xi &lt; width; xi++)
                {
                    Vector3 sumColor = new Vector3();
                    int[,] multiply = { { 1, 2, 1 }, { 2, 4, 2 }, { 1, 2, 1 } };
                    if (xi == 0)
                    {
                        multiply[0,0] = 0;
                        multiply[1,0] = 0;
                        multiply[2,0] = 0;
                    }
                    else if (xi == width-1)
                    {
                        multiply[0, 2] = 0;
                        multiply[1, 2] = 0;
                        multiply[2, 2] = 0;
                    }
                    if (yi == 0)
                    {
                        multiply[0, 0] = 0;
                        multiply[0, 1] = 0;
                        multiply[0, 2] = 0;
                    }else if(yi == height-1)
                    {
                        multiply[2, 0] = 0;
                        multiply[2, 1] = 0;
                        multiply[2, 2] = 0;
                    }
                    int sum = 0;
                    foreach (int i in multiply)
                    {
                        sum += i;
                    }
                    for(int yj = -1; yj &lt; 2; yj++)
                    {
                        for(int xj = -1; xj &lt; 2; xj++)
                        {
                            if(multiply[yj+1,xj+1] != 0)
                            {
                                sumColor += multiply[yj+1,xj+1] * target[yi + yj,xi + xj];
                            }
                        }
                    }
                    sumColor /= sum;
                    result[yi,xi] = sumColor;
                }
            }
            return result;
        }
        // Update is called once per frame
        void Update()
        {

        }
    }
}

