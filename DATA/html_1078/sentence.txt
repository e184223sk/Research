More than 1 year has passed since last update.やっとコードよりの話になれる！！過去の 2 記事は言語ごとの事情や、その人の経験などで色々ちょっとずつ異なることがあるので「〇〇の場合は違う」とか「こういう側面もある」とか色々コメントしやすい感じだったのですが、そのおかげで初めての Qiita のデイリーで No1 取れました。やったね！ということで、自分の主戦場の C# での DI コンテナ事情について書いてみたいと思います。ASP.NET Core などで何も考えないと使うことになる、事実上の標準の DI コンテナです。非常にシンプルで DI コンテナとして最低限これくらいは持ってるだろうと思われる機能だけ持ってます。例えば、以下のようなクラスがあったとします。Microsoft.Extensions.DependencyInjection を使うと上記のクラスを組み立て可能なコンテナを作って IMyService を取得して Greet を呼び出すコードは以下のような感じになります。実行結果は Hello world と表示されるだけです。AddTransient で登録するとコンテナから取得するたびに別のインスタンスを返します。AddSingleton で登録すると毎回同じインスタンスになります。AddScoped で登録すると同じスコープ内だと同じインスタンスになります。
スコープを作るには ServiceCollection に BuildServiceProvider をした結果の ServiceProvider の CreateScope メソッドを使います。各クラスのコンストラクタが呼ばれたときにわかりやすいように標準出力にメッセージを出すように手を加えた後に以下のようにコードを書き替えてみました。MyService が AddScoped で残りは AddSingleton にしてみました。
実行すると以下のようになります。Singleton のものはスコープが変わってもインスタンスは新たに作られなくて、AddScoped で登録したものはスコープが変わると再生成されてることがわかります。AddScoped や AddTransient や AddSingleton はラムダ式を受け取るオーバーライドがあって、それを使うとオブジェクトの生成処理をカスタマイズできるようになっています。例えば MyService の生成ロジックを自前のものに置き換えたコードを以下に示します。ちなみに、このコードの場合は別に生成処理を変えたところで意味はありません。単純に new してるだけなので。実行結果は同じです。Microsoft.Extensions.DependencyInjection について深く知りたい人は、Microsoft.Extensions.DependencyInjection Deep Dive を見てみるといいと思います。とまぁ、こんな感じで必要最低限の機能セット（登録と取得とシンプルなライフサイクル管理とインスタンス生成のカスタマイズ）がある程度なのですが、もうちょっと高度な機能を持った DI コンテナを使いたいという要望に応えられるようになっています。以下にリストがあります。試しに Unity を使ってみましょう。Unity は昔は Microsoft がメンテナンスしてた OSS の DI コンテナで、今は完全に Microsoft から離れてメンテナンスされています。Unity.Microsoft.DependencyInjection パッケージを追加することで Unity が使えるようになります。ただの DI コンテナとして使うだけなら別に Unity をあえて使う必要はないので、追加で Unity.Interception パッケージも追加してみようと思います。ということでこんな感じで IMyService はログを出すような追加処理が入るようにしてみました。実行すると以下のような感じになります。内部的には ServiceCollection に登録されている情報を見て UnityContainer に登録処理をして、UnityContainer をラップする IServiceProvider が作られてる感じです。
なので、ServiceCollection で登録したやつも UnityContainer で登録したやつも同じコンテナにあるように（実際同じコンテナにあるので）インジェクション出来ます。ここら辺まで出来たら、あとは ASP.NET Core あたりのドキュメントを見ながらぽちぽちやってみるのがいいと思います。


