More than 1 year has passed since last update.名作の多い「なぜシリーズ」の書籍のひとつである、オブジェクト指向でなぜつくるのかを読みましたので、参考になった点や教育に使いたい点をまとめてみました。書籍のタイトルにもなっている疑問。色々ありますが、少し嚙み砕くとソフトウェアを楽に作るためと言えます。オブジェクト指向は難しく、とっつきにくいと言われることがあります。その理由としては、以下のような要因が挙げられます。「継承、スーパークラス、インターフェース、属性、オーバライド・・・」
たくさんの用語があるため、最初は覚えるのが大変になります。
しかし、オブジェクト指向は広い領域をカバーしているため、仕方ないことと言えます。寧ろ覚えないとまずいらしいです。「動物がスーパークラスで、犬がサブクラスで・・・」
「人オブジェクトに、年齢教えてくださいとメッセージを送って・・・」
といった例はよく見かけるかと思います。
しかし、比喩が強烈な印象として残ってしまい、実際の仕組みと学ぶ側の思い込みで間違って解釈されてしまいます。「人間、会社、コンピュータ、自動販売機、ペットボトル、イベント・・・」
この世に存在する以上全てモノ(オブジェクト)であると表現できます。
このような極端な抽象化により、現実世界をそのままプログラムに表現できるという勘違いが生まれてしまいます。オブジェクト指向は「現実世界をそのままソフトウェアに表現するもの」と捉えられることがあります。
その考えが、返って混乱を招いてしまいます。オブジェクト指向と現実世界は似て非なるものです。オブジェクト指向の場合
「鳴け！」とメッセージがきたら「ニャー」「ワン」と鳴きます。オブジェクト指向では命令には逆らいません。現実世界の場合
「鳴け！」とメッセージがきたら「ニャー」「ワン」と鳴く場合もありますが、無視することもあります。噛みつく場合もあるかもしれません。現実世界では命令に逆いまくりです。ソフトウェアは現実世界を表現するのではなく、人間の仕事の一部をカバーするためにあります。
コンピュータが得意な「覚えること」「決まった仕事」を、コンピュータに任せちゃおうぜってことです。プログラミング技術は何度も工夫、改良がされ、オブジェクト指向が誕生しました。
プログラミング技術の進化の歴史は以下のようになっています。コンピュータは機械語しか理解できません。黎明期には人間が機械語でプログラムを書いていました。機械語を少し分かりやすくするために、アセンブリ言語が登場しました。アセンブリ言語では、機械語を人間に分かりやすい記号に置き換えて表現します。さらに人間に親しみやすい表現にするために、高水準言語が登場しました。高水準言語の登場により、プログラミングの生産性や品質は大きく向上しました。
しかし、それ以上にコンピュータの普及が爆発的に進んだため、ニーズは収まりませんでした。これはソフトウェア危機と呼ばれました。ソフトウェア危機に対応するために、オランダのダイクストラ氏によって構造化プログラミングが登場しました。
構造化プログラミングの考え方は「正しく動作するプログラムを作成するためには、分かりやすい構造にすることが重要である」というものです。分かりやすくするために、具体的には以下のような方法が挙げられました。GOTO文を廃止
ロジックを逐次進行、条件分岐、繰り返しの3つの構造だけで表現します。このことから構造化プログラミング言語はGOTOレスプログラミング言語とも呼ばれます。サブルーチンの独立性を高める
サブルーチン自体はすでに発明されていましたが、サブルーチンを利用する際はグローバル変数を使って値を受け渡しすることが一般的でした。グローバル変数はプログラムの保守性やデバッガビリティを低下させます。
この問題に対応し、サブルーチンをもっと汎用的に利用するために、ローカル変数と引数の値渡しの仕組みが考案されました。構造化プログラミング言語はプログラマにとって常識になりましたが、構造化プログラミング言語では解決できない2つの問題が残りました。グローバル変数
ローカル変数はサブルーチンの呼び出しが終わると消えてしまいます。サブルーチンの実行機関を超えて保持する必要のあるデータはグローバル変数で扱わなければなりません。貧弱な再利用
計算や文字列処置など基本的な処理(サブルーチン)については再利用可能でしたが、それだけでは増大するアプリケーションの規模からすると微々たるものでした。グローバル変数や貧弱な再利用の問題に対応するために、オブジェクト指向が登場しました。
オブジェクト指向では、これまでにない3つの仕組み「クラス」「ポリモーフィズム」「継承」が追加されました。結びつきの強い変数やサブルーチンを1つのクラスにまとめる仕組みです。
この仕組みにより、1つのソースコード(部品)の行数を減らすことができます。
また、クラスとして1つのグループにまとめられているため、サブルーチンの名前付けが楽になります。クラスに定義した変数やサブルーチンを他のクラスから隠す(private)仕組みです。
隠すことより、外部から意図しない使われ方をすることを防ぎます。クラスを定義しておくことで、そこからいくつでもインスタンスを作ることができる仕組みです。
利用する側は、インスタンスを指定してサブルーチンを呼び出すため、どのインスタンスを処理対象とするかを特定できます。ポリモーフィズムは、「色々な形に変わる」という意味になります。
サブルーチンは呼び出される側のロジックを共通化する仕組みですが、ポリモーフィズムは呼び出す側を共通化する仕組みになります。
具体的には以下の例で見てみましょう。ポリモーフィズムの仕組みを使えば、HumanであってもMonsterであってもGetNameCount()やSpecialAttack()が使えます。また、新しい生き物が増えた場合もこれらのメソッドは一切修正する必要はありません。(ポリモーフィズムの例でもちらっと出ちゃいましたが)似た者同士のクラスの共通点をまとめて別のクラスを作る仕組みです。つまり、コードの重複を排除することができます。JavaやC#などのプログラミングでは、さらに進化した機能ができました。代表的なものが「パッケージ」「例外」「ガベージコレクション」です。クラスをまとめる仕組みで、フォルダのようなものです。パッケージを入れ子にして、階層構造を作ることも可能です。戻り値とは違う形で、メソッドから特別なエラーを返す仕組みです。
「ネットワーク障害」「ディスクアクセス障害」「DBデッドロック」などで例外が使われることが多いです。
従来はエラーコードを使う方法が一般的でしたが、以下のような問題がありました。例外の場合、例外の後処理(catch)を書き忘れた場合は実行時エラーになります。
また、後処理が必要のないメソッドでは、例外が発生する旨の宣言だけをしておくだけでよくなります。
例外の仕組みには、無駄を省くことと間違いを防止することの2つの効果があります。自動的に不要なインスタンスを削除し、メモリを解放してくれる仕組みです。JavaやC#に備わっています。
ガベージコレクションがない場合は、明示的にメモリを解放する必要があります。
誤って必要なインスタンスを削除してしまうとバグに繋がりますし、削除し忘れるとメモリリークに繋がります。
ガベージコレクションはこの辺のお助けをしてくれます。オブジェクト指向は2つの再利用技術をもたらしました。それが「ソフトウェアの再利用」と「アイデアの再利用」です。汎用的な機能をもつクラスを集めたものです。従来のプログラミング言語では、再利用できる部品はサブルーチンだけでしたが、オブジェクト指向により以下が可能になりました。アプリケーションの半完成品のイメージになります。ライブラリとは逆に、フレームワークからアプリケーションを呼び出すように使用します。基本的な流れはフレームワークで提供し、アプリケーションで固有の処理を組み込みます。優れた設計のアイデアをまとめたもとです。エリック(エーリヒ)・ガンマ、リチャード・ヘルム、ラルフ・ジョンソン、ジョン・ブリシディスによって作成されました。彼らはGoFと呼ばれ、彼らが出した23のデザインパターンはGoFのデザインパターンと呼ばれました。GoFのデザインパターンの詳細については以下をご覧ください。UMLはUnified Modeling Languageの略で、「統一モデリング言語」と訳されます。
グラディ・ブーチ、ジェームズ・ランボー、イヴァー・ヤコブソンによって作成されました。この3名は親しみをこめてスリーアミーゴと呼ばれています。
UMLは以下のように使われます。UMLはオブジェクト指向のプログラム構造や動作を表現するために使われます。
2次元の図を視覚で取り込むため、人間の頭脳に適しています。
つまり、UMLは形のないソフトウェアを見るための道具になります。
代表的な図としては、クラス図、シーケンス図、コミュニケーション図などがあります。※各図の詳細な説明はここでは割愛します。
ソフトウェア開発では、設計などで使われます。オブジェクト指向で表現できない情報もUMLで表現します。
代表的な図としては、ユースケース図、アクティビティ図、ステートマシン図などがあります。※各図の詳細な説明はここでは割愛します。
ソフトウェア開発では、業務分析(現実世界の仕事を整理)や要件定義(コンピュータに任せる仕事の範囲を決める)などで使われます。自然言語は人間同士のコミュニケーションに使われ、コンピュータ言語は人間がコンピュータに命令を与えるために使われます。
自然言語やコンピュータ言語は文字を使って表現するため、表現が複雑になったり、量が膨大になったりします。
一方でUMLは図を使って表現するため直感的に理解できるようになります。UMLは自然言語とコンピュータ言語の欠点を補うための言語とも言えます。
そのため、UMLで全てを表現しようとせず、コミュニケーションを助ける手段として気軽に使いましょう！保守性に強く、再利用しやすいソフトウェアを作るためのポイントは以下のようなものがあります。重複があるほど、プログラムの理解・修正・テストなどが大変になります。
重複があるとコピー＆ペーストが多くなる傾向があります。つまり、コピペが多い場合は注意が必要です。
設計の段階で重複がおきないように配慮すべきです。複雑なものを分かりやすくするコツは「分割すること」です。
独立性が高いと、部品の機能がハッキリするため、理解しやすくなります。独立性を高めるための考え方は以下です。凝集度
機能のまとまり度合いを示す。強いほど良い設計。結合度
部品間の結びつき度合いを示す。弱いほど良い設計。独立性を高めるためのコツは以下のようなものがあります。依存関係とは、ある部品が別の部品を利用していることを指します。
以下の例では、どれも単独コンパイルができません。また、どれかに手を加えた場合、他のComponent全てを確認する必要があります。
以下の例は、「Component C」は単独で利用できます。また、「Component A」を使用した場合は他のComponentの確認は不要です。
私はプロジェクトを通してオブジェクト指向を学んだタイプの人間ため、この書籍により基礎などが整理できました。
書籍では、メモリや開発プロセスについても分かりやすく記載されていますが、別途専用の記事にしたいと思い、ここでは割愛させて頂きました。
オブジェクト指向に興味のある方は、是非書籍の方もご覧ください。また、同じなぜシリーズの以下の記事も合わせてご覧頂けますと幸いです。


