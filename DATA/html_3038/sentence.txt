More than 1 year has passed since last update.Effective C#4.0 の項目１「アクセス可能なデータメンバの代わりに常にプロパティを使用すること」を読んだ。
読んで得た知識をアウトプットすることで、理解度を高める。publicなメンバよりもプロパティのほうが、挙動の変更が容易にできるからだ。アカウント作成を例になぜ変更が容易になるのか考えてみる。まずはプロパティを使わない、以下のようなクラスを定義したとする。現状、何の問題もない。
ただAccountクラスにIDとパスワードを設定するだけの処理だ。ここで、パスワードを強化するために、パスワードの長さに制限を加えたい。
という仕様変更があったとしよう。Validateという検証用のメソッドを追加し、メソッドを呼び出すように変更を加えた。
ここで、重要なのは検証用のメソッドを利用する側が必ず呼び出さなければならないということだ。
つまり、パスワードを設定している箇所すべてにおいて、この検証メソッドを追加しなければならない。
バグ混入の可能性が大きくなることは容易に想像できる。プロパティを使った例を見ていこう。この時点では何も大差はない。
AccountクラスのIDとパスワードをプロパティに変更しただけだ。ここに先程と同様の仕様変更を行う場合どうなるか。プロパティのsetアクセサに対し、検証ロジックを追加した。
ここで重要なのは利用する側は一切変更していないということだ。
つまり、修正箇所がクラス内に限定されるため、バグが混入するリスクは少なくなり、挙動の変更も容易となる。プロパティを使ったほうが、挙動の変更が容易にできることは分かった。
それではすぐにpublicのメンバをプロパティに変更してしまおう。と思うかもしれないがそこは注意が必要だ。
なぜなら、publicなメンバへのアクセスとプロパティを介したアクセスではソース上では互換性があるかもしれないが、バイナリ上では互換性がないため、必ず再コンパイルする必要性が生じるからだ。先程のコードが以下の構成で作られているとして、実験してみよう。
まずは、publicなメンバを持つ状態で実行してみる。何の問題もなく、実行できることが確認できた。
次に、publicのメンバであろうが、プロパティを使おうが利用する側のコードは変わらないため、実行ファイルはそのまま利用し、dll側をプロパティに変更して実行してみよう。MissingFieldExceptionが発生し、実行できなくなってしまった。
なぜこのような自体になってしまうのか、プロパティを使用した場合、実際どのようなコードを書いたことになるのか見てみよう。1&lt;○○&gt;k__BackingFieldというprivateなメンバが自動的に生成され、それにアクセスするためのsetアクセサ、getアクセサが定義されている。
つまり、プロパティはpublicなメンバを作成するのではなく、privateなメンバとそのアクセサを提供してくれるということだ。
そのため、再コンパイルせずに実行すると、publicなメンバであるIdが存在しないという自体が生じることになる。このような自体が起こる可能性があるため、別アセンブリから参照されているメンバをプロパティに変える際は十分に注意が必要だ。Effective C#4.0 の項目１「アクセス可能なデータメンバの代わりに常にプロパティを使用すること」を読んで得た知識をまとめてみた。
publicなメンバよりもプロパティを使うことのメリットが少しでも伝われば幸いだ。それではまた。
TomoProgSharpLabを利用した。IL（Intermediate Language：中間言語）からC#へのデコンパイルがブラウザ上で簡単にできる。 ↩


