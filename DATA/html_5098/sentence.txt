More than 3 years have passed since last update.UnityにはStartCoroutineという関数があります。
これはIEnumeratorを受け取って、MoveNext()を毎フレーム呼び出すようになっています。
これと同じような仕組みを自作します。基本の実装は上記で完了します。
引数として実行したいIEnumeratorを受け取り、毎フレームUpdate関数が呼び出されるものとします。実行が完了したかどうかをIsDoneに設定して確認できるようにしています。もう少し便利に利用するため以下の仕様を追加します。更新処理では、routineの型によって処理を分岐します。stackが空になっている場合は処理が完了しているので、IsDoneをtrueにします。IEnumeratorをコルーチンとして利用するとき、yield return nullによって
頻繁にnullを受け取るので、nullの場合の分岐を先頭に入れています。IEnumeratorの場合はエラーハンドリングをしつつMoveNextを呼び出します。yield returnで返された値がCurrentから取得できるので、stackにPushしてUpdateを再帰呼び出しします。IEnumeratorが完了していた場合はstackから取り除き、再帰呼び出しします。
この際stackが空になっていればDoneが呼び出されて処理が完了します。AsyncOperationを受け取った場合はstackの頭にAsyncOperationを残しつつ、
Currentにはnullを設定して処理を継続させます。完了していればstackから取り除き、Updateを再帰します。その他のオブジェクトの場合、Currentに設定して終わりです。CoroutineExをUnityのStartCoroutineに渡しても動作するように、IEnumeratorインターフェースを実装します。IEnumeratorインターフェースのうち、Currentは実装済みのため省略します。MoveNextは毎フレーム呼び出される処理なので、Updateを呼び出し、
処理を継続するかどうかのboolとして!IsDoneを返します。Resetはコルーチンとしては利用しない関数のため、実装は空です。ここまでの実装により完成したコードを貼ります。上記実装に加えてなど、Unity標準のCoroutineではできなかった処理が
拡張次第で書けるようになります。そもそも標準のCoroutineが何の変数も関数もないオブジェクトで
持ってても意味無いので、こういう拡張クラスがあると便利です。割と勢いで書いたので編集リクエスト歓迎です。


