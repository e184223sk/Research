※ この投稿で紹介するSourceGeneratorは、まだUnityじゃ使えません。将来的にこうできればいいなーって話さてまずは、C#のプロパティーの話をします。
C#では、フィールドをpublicにするのは良くなくて、プロパティーを使ってフィールドにアクセスするのが良いとされています。↓のコードは良くなくて↓な感じでプロパティーにするのがGoodです。さて、↑みたいなコードはわざわざフィールドを作らなくても、↓のような自動実装プロパティーで実現ができます。自動実装プロパティーを使うことで、C#のコードからは見えない次のようなフィールドとアクセッサが、"自動"で生成されます。自動実装プロパティー、便利ですね！さて次はUnityのシリアライズとフィールドとプロパティーの話。UnityにおいてMonoBehaviourのサブクラスやScriptableObjectのサブクラスなどで、次のようなpublicなフィールドに設定した値や参照は、シーンやプレファブにシリアライズされることがあります。ですが先にも説明したとおり、C#として↑のようなpublicなフィールドは良くなかったですね。
こういう場合は、SerializeField属性の出番です。SerializeField属性をつけたフィールドはpublicでなくても、シリアライズされます。さて、このフィールドに外部からアクセスするために、プロパティーを付けてあげましょう。（とりあえずゲッタープロパティーだけ）うん、よくあるパターンです。 このUnityで「シリアライズするフィールド」と「プロパティー」というよくあるパターンをもっと簡潔にしたいな！というのがこの投稿の趣旨です。先ほど説明した自動実装プロパティ、あれは使えないのでしょうか？自動で実装される内部的なフィールド（バッキングフィールド）に、SerializeField属性をつけることができたら、実現できそうです。なんと、これ実現できます。C# 7.3から自動実装プロパティの自動で実装される内部的なフィールド（バッキングフィールド）に属性を付与できるようになりました。うん、簡潔！めでたしめでたし！
とは、ならないいんです・・・自動実装プロパティのフィールド名は、「&lt;Speed&gt;k__BackingField」という名前です。困ったことに、この名前でシリアライズされてしまいます。次の画像みたいな感じで。
うーん、困った。さて、ここでC# 9.0から加わったSourceGeneratorの出番です。（まだUnityじゃ使えません。将来的にこうできればいいなーって話）C# Source Generatorは、ビルド時にC#のソースコードを生成する仕組みです。このC# Source Generatorを使うことで、プログラマティカルにコード生成をすることができます。C# Source Generatorを使うことで、ボイラープレートのコードは非常に簡単になります。さて、自分はC# Source Generatorをつかって、「フィールドに付与すると、そのフィールドのゲッタープロパティーを生成してくれるSource Generator」を作ってみました！ソースコードはこちら！ RyotaMurohoshi/PropertyGenerator↑みたいな感じで、idやnameというフィールドにGetterPropertyという属性をつけると、↓のようなプロパティが生成されます。このGetterPropertyを使って、次のようなボイラープレートなコードもC# Source Generator使ってすっきりさせてみましょう。↑が、↓こうなります！プロパティーがいらなくなりました！すっきり！あんまり嬉しくない？確かに1行だとそうですね。これが↓みたいにたくさんあったらどうでしょう？これが↑、↓こうなる！すっきりしましたね！
ちなみに↑は、一部実装が間違っている箇所にきがつきましたか！↑はうっかりミスをしてます。↓ならこういううっかりミスも防げますね！Unityで「シリアライズするフィールド」と「プロパティー」ですが、残念ながら自動実装プロパティはつかえません。そこで、Unityで「シリアライズするフィールド」と「プロパティー」を簡潔に書きたくて、SourceGeneratorを作ってみました。フィールドにつけるとゲッタープロパティーを生成するという非常に簡潔なものです！よかったらコードを見てみてください！ : RyotaMurohoshi/PropertyGeneratorこれがUnityで使えるようになるのが楽しみです！


