More than 1 year has passed since last update.本記事は C# でテストを記述する人を対象に、しばしば複合型の等値アサートで生じる「面倒さ」に対するソリューションの一つを紹介します。テストフレームワークはなんでも。その前に、先ずはシンプルな (そして理想的な) 等値アサートから：アサート対象が int や string といった基本型なら、たいてい困る事もなく素直に書けます。
しかし、対象がユーザー定義型のような複合型だとそうは問屋が卸さない。例えば Account というユーザー定義クラスと、それを返すクエリ サービス AccountQuery があったとします：次に、AccountQuery が返す Account が期待通りか調べるテストを書いてみます：等値アサートしたい actual は一つだけなのに、わざわざデータメンバーの数だけ Assert.AreEqual() を書くのは大変です。しかもデータメンバーの型に応じて専用の Assert メソッドを使い分ける必要もあったり。 Assert.AreEqual() で全部いい感じにやってくれYO更に問題なのが、Account に新しいプロパティが追加された場合でも、上記のテストは追加プロパティをアサートする事なく成功してしまうという事。これはマズイ。テストフレームワークによっては IEuqalityComparer&lt;T&gt; 等のカスタム等値性を Assert に与える事でフォローできる場合もありますが、あまりにも自明な等値アサートをしたいだけなのに新たに型を実装するとか面倒すぎます。このように、等値アサートの書き方に時間を取られるのはもうウンザリ PrimitiveAssert はテスト対象データをいくつかの基本型（プリミティブ データ）に分解し、個別に比較します。
API は基本的に次の拡張メソッド一つだけです。これで書き換えてみましょう：今度はいい感じに等値アサートしてくれます！ 見た目もシンプルになりました！！
データメンバーにコレクションがあっても要素に分解して等値アサートします。API も一つだけなので、基本的にはこれだけです。
そう、これぐらい簡単でいいんだよ Yes!
汎用的なコレクション (System.Collections 以下にあるような型) 同士であれば、型に関わらずコレクションとして等値アサートされます。Yes!
Tuple 同士、ValueTuple 同士はもちろん、Tuple と ValueTuple の等値アサートでも問題ありません。Yes!
ウロボロスに囚われる事はありません。という場合は、コンソールにログを出力してみることもできます。だいたい下記のような出力が得られます。Yes!
PrimitiveAssert は基本的に型を比較しません。代わりにターゲット型として指定した型のデータメンバーを全て満たしているか否かを検証します。その為、expected は匿名型でも、全く関係のない HogeHoge 型でも問題ありません。また、ターゲット型の指定は任意で、省略時には actual の型（ここでは Account）が設定されます。前述の通り、expected は型に縛られない代わりに、ターゲット型の全てのデータメンバーを満たす必要があります。
これにより、後々 Account に Enabled プロパティが追加された場合、expected にも Enabled が無いと失敗するようにもなりました。これでデータメンバーがアサートから漏れている状況を検知する事ができます。README.md には PrimitiveAssert の詳細とより多くの事例が載っています。ぜひ参照してみてください。PrimitiveAssert を使えばたいていの等値アサートは簡潔に書けます！


