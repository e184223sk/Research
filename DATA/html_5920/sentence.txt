More than 3 years have passed since last update.こんなさむしんぐがあったとして、こんな風にすると、なぜか④だけInvalidCastExceptionが飛んで来るから注意しましょうって話。動かすとわかるけど、①~③は想定通りTryConvertメソッドが呼ばれて動的に変換が解決されているコトがわかる。けど、④だけはTryConvertが呼ばれずInvalidCastExceptionが飛んでくる。これらの挙動はExplicit reference conversionsの、bullet 3みれば書いてあってFrom any class_type S to any interface_type T, provided S is not sealed and provided S does not implement T.と定義されてるから、まず明示的な型変換は可能であるのだけど、逆にPermitted user-defined conversionsのbullet 3に、Neither S0 nor T0 is an interface_type.とあって、任意の型にpublic static implicit operator &lt;interface_type&gt;　(...)やpublic static explicit operator &lt;interface_type&gt;(...)みたいなことは出来ないよと言うことになる1で、ここら辺の理由から、明示的な型変換を行った場合､interface-typeへのユーザー定義変換が動的型に対するコールサイト構築を行う際、全く考慮されてないんじゃないかなって。で、結局考慮されてないわけだから、Interface-typeへの明示的な型変換は、一般的なC#の文脈で行われるってコトだと思う。他方、暗黙の型変換が許容されるのは、右辺にある'd'が明示的な変換操作無しで変換可能であるかのように振る舞う必要があるため、コールサイト構築時にDynamicObject.TryConvertが呼ばれる様なコールサイト構築を行うのではと。答えはこれ以上無いほどシンプルで、変換したいinterfaceを付けてやれば良い。
先の例だとこんな感じこーすれば、一般的な型変換のコンテキストで動いて問題なく変換できる。DynamicObject.TryConvert not called when casting to interface typeOn Dynamic Objects and DynamicObject実際コンパイルエラーになる｡蛇足ながらこれで来ちゃうと色々とマズいとは思うので妥当じゃ有ると思う｡ ↩


