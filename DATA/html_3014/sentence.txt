More than 1 year has passed since last update.ぼんやりWikipediaの定義を眺めながらフィボナッチ数列を求める関数を書いていたら一般的なフィボナッチ関数とは違う関数を書いていました。これは問題なく結果を出力します。ループでフィボナッチ数列を求めるアプローチでもこんな感じになるのかな?ちなみに一般的なやつはこれ。再帰での関数呼び出し回数が非常に多くなるのでよくベンチマークに使われている印象です。次はフィボナッチ関数のメモ化を実装して高速化してみます。
キャッシュにはハッシュテーブルが使われることが多いようです。ということで過程をすっ飛ばして実装。キャッシュするハッシュテーブルはクロージャに閉じ込めて外部からは触れないようにして、クロージャの中で生成した関数をリターン。ちなみにCommon LispはLisp2であるので関数と変数が明確に区別されます。
変数に代入した関数は(funcall)や(apply)を通さないとアクセスできないので注意が必要です。
#'の記号の意味はシンボル化(評価させない)して関数オブジェクトとして評価する、です。※追記:
@htsignさんより、メモ化関数について改善案を頂きました。
後述の実装も全てそれで書き換えています。
CL的にはfuncallから解放されるのが大きいのでは。各言語でのfib(0)からfib(38)の表示にかかる時間(偽・真・メモ化)を比較しました。
この表で言えることはいかに普通のフィボナッチ関数が無駄な処理を挟んでいるのかということでしょうか。
言語間の時間差については順当ですね。以下、各言語の全実装です。@htsignさんよりコメントに実装を頂きました。


