dotnet ef migrationsコマンドでマイグレーションファイルを生成する際は、DBコンテキストをDIする必要があるため、実行形式のプロジェクトのディレクトリでコマンドを打つ必要があります。しかし、下記の用にソリューション構成のように複数のスタートアッププロジェクト（WebApi、WebSite）がある場合、WebApi、WebSiteのどちらかで行う必要がありますが、どちらか片方のプロジェクトにだけマイグレーションファイルがあるのは違和感があります。できれば共通で呼び出すInfrastructureプロジェクト直下にマイグレーションファイルを生成したいところです。しかし作成していたソリューション構成ではInfrastructureプロジェクトがクラスライブラリのプロジェクトでした。そのため、Infrastructureプロジェクト直下でdotnet ef migrationsコマンドをうってもエラーになってマイグレーションファイルを生成できません。そこでInfrastructureプロジェクトをクラスライブラリからコンソールアプリに変えてしまって、DIコンテナを起動できる用に変更します。NUGETから.NET汎用ホストとDI（依存性注入）のライブラリの参照をInfrastructureに追加します。さらにマイグレーションのためにエンティティフレームワークとDB（今回はSQLite）プロバイダも追加します。プロジェクトファイルに下記のように追加されるはずです。次にDBのモデルのクラスを作成します。私はドメインモデルとDBモデルを明確に分けるのが好みなのでInfrastructureプロジェクトに作成します。DBコンテキストを用意します。今回は通常のDBコンテキストとそれを継承したローカル開発用のSQLite用のDBコンテキストの２つを用意します。ここまで完了したらInfrastructureプロジェクトをクラスライブリからコンソールアプリ（実行ファイル）に変更します。&lt;OutputType&gt;Exe&lt;/OutputType&gt;を追加します。DIコンテナにDBコンテキストのDI設定を追加します。WebSiteやWebApiプロジェクトでも同じ用に設定すると考えると拡張メソッドで共通化しておくと便利かと思います。エントリーポイントを作成しホスティング構成をして上記のDI設定を呼び出します。これでマイグレーションファイルが生成できるようになりました。ただその前に、SQLiteのDBの実体.sqliteとSQL Client（DB Browser）で作成される一時ファイルはプロジェクトに追加されないようにし、git管理下からも外しておくと良いと思います。マイグレーションファイルを生成します。--contextでSQLite用のDBコンテキストを指定しています。--output-dirでマイグレーションファイルが生成されるフォルダを指定できます。他のDBのものと混ざらないようにフォルダを分けておくといいと思います。また、-vをつけるとターミナルへの出力が詳しくなり、生成失敗時に調査しやすくなります。下記のようにマイグレーションファイルが生成されます。実際にDBマイグレーションしてテーブルを作成します。今回は.sqliteファイルの生成になります。Infrastructureプロジェクト直下にECommerceSample.sqliteが生成されました。中身を覗くとテーブルが生成出来ていることが確認できました。これで数スタートアッププロジェクト構成のソリューションで、DBマイグレーションファイルをインフラ層のプロジェクトに生成する目的が達成できました。


