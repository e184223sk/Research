CefSharpでカスタムWebブラウザを作成します。
CefSharpはChromiumをコアとするOpenSourceのWebViewです。
CefはChromiumをコアとしているので、ほぼChromeと同等のWebブラウザを作成することができます。https://github.com/cefsharp/CefSharp.NET FrameworkのWPFとWinformsで利用可能なコントロールとして提供されていますが、今回はWinforms版でカスタムWebブラウザを作ります。言語はC#を使います。以下の流れでWinformプロジェクトを作成して、一番シンプルなカスタムWebブラウザを作成します。まだVisual Studioをインストールしていない場合は、以下のサイトからVisual Studio Express(無料)のインストーラをダウンロードして、インストールしましょう。
Visual Studio ExpressC#のWinformsのプロジェクトを新規作成します。
以下は、Visual Studio 2019 Expressでのやり方になります。作成されるプロジェクトのフォームの名称がデフォルトで「Form1.cs」とカッコ悪いので、「ソリューション エクスプローラ」で「Form1.cs」を選択して、コンテキストメニューから「名前の変更」を選択して、適当な名前に変更します。
ここでは、「SimpleBrowserFrame.cs」としました。
CefSharpは「AnyCPU」でビルドできないので、構成マネージャで「AnyCPU」を削除して「x64」と「x86」を追加します。
※「x64」と「x86」のいずれか1つでももちろんOKです。
ソリューションエクスプローラでソリューションを選択して、コンテキストメニューから「バッチビルド」を選択すると、以下のような構成に見えるはずです。
CefSharpのNugetパッケージを取り込みます。検索ボックスに「CefSharp」と入力して検索を実行すると、CefSharp関連のNugetパッケージが表示されます。
以下のNugetパッケージをインストールします。 
※CefSharp.WinFormsをインストールすると、芋ずる式にすべてインストールされます。表示されているバージョン「v85.3.130」は、chromiumのバージョンとほぼ一致しています。
もし特定のバージョンのchromiumを使いたい場合は、バージョンを指定してNugetを取り込みます。CefSharpのWebViewであるChromiumWebBrowserコントロールをフォームに貼り付けます。
ChromiumWebBrowserはツールボックスにも表示されますが、ツールボックスからはコントロールを貼り付けできないので、フォームのコード(SimpleBrowserFrame.cs)に直接以下を記述します。何も考えずに実行すると、以下の様な非常にシンプルなWebブラウザが表示されます。
  初期URLを以下のようにchrome://versionに変更して実行してみると、バージョンのページが表示されます。
このようにchromeのカスタムスキーマの一部も表示させることができます。ChromiumWebBrowserをnewして貼り付けるだけでも、Webコンテンツを表示することができますが、幾つかの最低限の設定をしておきます。
具体的には、以下の2つの方法で設定します。Cef.Initializeメソッドでは、以下の設定を行います。キャッシュ用ディレクトリは、ブラウザコンテンツのキャッシュのほかに以下の情報が格納されます。キャッシュ用ディレクトリを設定するには、CefSettingsBase.CachePathプロパティに絶対パスでキャッシュ用ディレクトリのパスを指定します。
nullを指定した場合は、キャッシュが作成されないインメモリモード(incognito mode)になります。インメモリモードの場合、indexedDB、localStorageおよびapplication cacheは、もちろん保存されなくなります。CefSettingsBase.UserAgentで、UserAgent文字列を自由に設定することができます。
しかし、デフォルトのUserAgent文字列を取得することはできません。
デフォルトのUserAgent文字列を確認するには、開発者ツールでHTTPリクエストヘッダを確認する必要があります。
ちなみに、デフォルトのUserAgent文字列はx86とx64で異なっています。CefSettingsBase.AcceptLanguageListに、受け入れる言語をカンマ区切りのリストで指定します
ここで指定した言語リストは、HTTPリクエストヘッダのAccept-Languageに指定されます。
chromeのリクエストヘッダを見ると、ja,en-US;q=0.9,en;q=0.8と設定されており、日本語とアメリカ英語と英語が重み付けを含めて指定されていることが確認できます。
ここではchromeと同じ設定にしてみます。  デフォルトでChromiumのデバッグログ(debug.log)が出力されます。
CefSettingsBase.LogSeverityでログのレベルを変更することで、ログ出力の内容を増やしたり、ログを出力しないようにすることができます。CefSettingsBase.CefCommandLineArgsに、Chromeのコマンドライン引数を追加することができます。ただし、Chromiumのコマンドラインオプションはあまりドキュメント化されておらず、また実際に機能するかは、試してみないと分からないです。
ここでは、MediaDevices.getUserMedia()メソッドで、カメラにアクセスできるようにするために、enable-media-streamオプションを設定します。以上の設定をまとめると、以下のようになります。バージョン73.1.xまでは、Cookie用のディレクトリはキャッシュ用フォルダと別に指定することができましたが、75.1.x以降はキャッシュ用ディレクトリ配下にCookieが作成されるようになり、cookie用ディレクトリは個別に設定することはできなくなりました。バージョン73.1.x以前を使用する場合は、ICookieManager.SetStoragePathを呼び出して、cookieのパスを指定します。呼び出しのタイミングはIBrowserProcessHandler.OnContextInitializedになります。
参考のために、設定例を以下に示します。※このメソッドは、75.1.x以降は使用できません。ChromiumWebBrowserインスタンスをnewした後、ChromiumWebBrowser.BrowserSettingsプロパティで主に以下の項目を設定することができます。これらを設定する例を以下に示します。なお、ドキュメントに書かれていても、実際には機能しない設定もあるので注意が必要です。
具体的には、以下は機能しませんでした。  デフォルトでは、システムのインターネットオプションで指定しているProxy設定が使用されますが、システムのインターネットオプションと別に、独自のProxy設定を行うことができます。Proxy設定の方法は、以下のいずれかの方法で行います。  CefSharpSettings.Proxyスタティックメソッドを使用します。
IP、Port、UserName、Password、BypassListを設定することで、自動的にProxyサーバの認証処理も行うようになります。
この方法の場合は、ユーザに認証情報の入力を求めることができません。
また、一度設定すると、プロセスが終了するまで変更することができません。以下のコマンドラインオプションを指定します。
これが一番簡単です。この方法の場合、ユーザに認証情報の入力を求める処理を実装することができます。
認証情報が必要になると自動的に認証処理が呼び出されます(詳細は「9. 認証」を参照)。
この方法も一度設定すると、プロセスが終了するまで変更することができません。WebViewのリクエストコンテキスト(IBrowserHost.RequestContext)に対して、IRequestContext.SetPreferenceメソッドを呼び出して、プロキシの情報を設定します。最も細かくProxyを設定できる方法で、複数のWebViewがある場合でも、それぞれのWebViewで別々のProxyを設定することができます。
この方法の場合も、ユーザに認証情報の入力を求める処理を実装することができます。
認証情報が必要になると自動的に認証処理が呼び出されます(詳細は「9. 認証」を参照)。
また、途中でプロキシ設定を変更することもできます。第一引数に"proxy"という文字列、第二引数に以下のKey&amp;Valueを持つDictionaryインスタンスを指定して、IRequestContext.SetPreferenceメソッドを呼び出します。※この部分はドキュメントが少ないです。なお、IRequestContext.SetPreferenceメソッドは必ずCef UI Threadのコンテキストで呼び出す必要があるため、Cef.UIThreadTaskFactoryスタティックメソッドを使って、呼び出しのコンテキストを強制する必要があります。(方式3)とほぼ同じですが、WebView単位ではなく、プログラム全体でのリクエストコンテキストに対して、Proxy設定を行う方法になります。プログラム全体のリクエストコンテキストはCef.GetGlobalRequestContextメソッドで取得することができます。取得したRequestContextに対して、(方法3)と同じ処理を行います。実験を行うには開発者ツールが便利です。
CefSharpではWebBrowserExtensions.ShowDevToolsメソッドを呼び出すだけで、Chromeでおなじみの開発者ツールを表示することができます。
ここでは、Chromeと同じように、F12キーが押下されると、開発者ツールを表示するようにします。  キー押下をハンドリングするためには、IKeyboardHandlerインタフェースを実装するクラスを作成する必要があります。Visual Studioのソリューションエクスプローラで、コンテキストメニューから「追加」ー「クラス」を選択します。
ここではクラス名をKeyboardHandlerにします。また、今後ハンドラが増えるので、ハンドラを実装するクラスを「Handlers」フォルダにまとめておきます。以下のように、IKeyboardHandlerを実装させます。  次に、IKeyboardHandlerの文字列を選択すると電球マークが出るので、電球マークをクリックして、コンテキストメニューから「すべてのメンバーを明示的に実装する」を選択します。これで、Visual Studioが自動でインタフェースのメソッドのスケルトンを実装してくれます。  IKeyboardHandlerインタフェースはOnKeyEventとOnPreKeyEventの2つのメソッドを持ちます。  作成したキー押下時のハンドラを、ChromiumWebBrowser.KeyboardHandlerプロパティに設定します。うまく行くと、以下の様なおなじみの開発者ツールが起動します。
  おー！表示されました。一般的なブラウジング操作として、戻る、進む、更新、ロードを実装します。
まず、最初にショートカットキーの処理を実装して、次にUI操作からの処理を実装します。ショートカットキーの処理を実装するには、「5. 開発者ツール」で説明したOnPreKeyEventに処理を追加します。以下は実装例です。  これで、戻る、進む、更新の操作がショートカットキーでできるようになりました。ショートカットと同じ処理を、UI操作からもできるようにします。
まず、ユーザ操作を受け付けるために、「戻る」「進む」「更新」「アドレスバー」を配置します。
GUIの編集ですので、以下で紹介するやり方にとらわれず、自由に作成しても問題ありません。フォームにツールボックスからTableLayoutPanelを選んでドラッグ&amp;ドロップします。WebViewを配置する部分に、コンテナ用のPanelを配置します。  アドレスバーを配置します。戻る、進む、更新のボタンを配置します。ChromiumWebBrowserの配置場所を、先ほど作ったPanelに変更します。以上で、戻る、進む、更新のボタンとアドレスバーを持つシンプルなWebブラウザのUIが完成しました。戻る、進む、更新のボタンクリックの処理を追加します。
フォームのデザインビューで、それぞれのボタンをダブルクリックして、click時のハンドラを追加します。アドレスバーでEnterキーが押下された時に、アドレスバーに入力されているURLをロードするようにします。
アドレスバーのKeyDownイベントのハンドラとして、addressBar_KeyDownメソッドを追加して、以下の処理を追加します。ビルドして実行してみます。
正しく実装されていると、以下のようなブラウザが表示されるはずです。
ALT＋[→]、ALT+[←]、F5のショートカットキーが有効になっていることも確認できます。
ボタンやアドレスバーも操作可能になっています。IKeyboardHandlerハンドラでの戻る、進む、更新の処理は、IWebBrowserではなくIBrowserに対して行っています。
IWebBrowserとIBrowserは同じWebViewを指しているように思われるかもしれませんが、window.openメソッドで開いた子ウィンドウの場合など、明示的にChromiumWebBrowserをnewして作成していないWebViewの場合は、IWebBrowserとIBrowserは同じWebViewを指していないので注意が必要です。ChromiumWebBrowserをnew作成した場合
以下の様にChromiumWebBrowser、IWebBrowser、IBrowserは同じWebViewと関連しています。
IKeyboardHandler等のCefSharpのハンドラのメソッドは、これらの引数にして呼び出されることになります。
この場合は、IWebBrowser、IBrowserのどちらを操作しても、結果は同じになります。a要素のクリックやwindow.openにより子ウィンドウが自動的に作成された場合
CefSharpにより自動作成されたWebViewでは、ChromiumWebBrowserやIWebBrowserは存在しておらず、参照を取得することができません。
IKeyboardHandler等のCefSharpのハンドラのメソッドでは、親ウィンドウのIWebBrowserインタフェースが引数として渡されます。
この場合は、IWebBrowserを操作すると親ウィンドウのWebViewが操作されてしまうことになります。まとめると、ChromiumWebBrowserを明示的にnewして作ったWebView以外のWebViewが存在する場合(子ウィンドをサポートする場合)は、WebViewに対する操作は、IWebBrowserに対してではなく、必ずIBrowserに対して行うようにします。なお、上の「6.3 ボタンクリック時の処理追加」と「6.4 アドレスバーでの処理追加」では、IBrowserではなくChromiumWebBrowserに対して、GoBack等のメソッドを呼び出しています。これらについては、「22. 子ウィンドウオープン」でILifeSpanHandlerを実装した後に、IBrowserインタフェースを操作する様に変更します。WebBrowserExtensions.SetZoomLevelメソッドを呼び出すことで、拡大率を適用します。
WebBrowserExtensions.GetZoomLevelAsyncメソッドを呼び出すことで、現在の拡大率を取得することができます。両メソッドともにdouble値のZoomLevelで拡大・縮小のレベルを使用します。
ZoomLevelと拡大率(等倍を1.0とする倍率)には、以下の関係があります。Chromの拡大率は以下のようになっています。
- 拡大は、110%、125%、150%、175%、200%、250%、300%、400%、500%
- 縮小は、90%、80%、75%、67%、50%、33%、25%これらの拡大率をZoomLevelに直すと以下のようになります。ショートカットキーをハンドリングするために、IKeyboardHandler.OnPreKeyEventに処理を追加します。以下の様なコードになります。
なお、[+][-][0]のキーはキーボード本体とテンキーの2つにあり、それぞれキーコードが区別されているで、複数の条件を指定する必要があります。以上で、拡大、縮小、等倍の操作がショートカットキーからできるようになりました。WebBrowserExtensions.Printメソッドを呼び出すことで、簡単にWebViewの印刷ができます。
ここでは、Ctrl+[P]ショートカットキーに、印刷処理を割りあてます。ショートカットキーをハンドリングするために、IKeyboardHandler.OnPreKeyEventに処理を追加します。ビルドして実行してみます。
Ctrl+[P]を押下すると、印刷ダイアログが表示されます。
なお、PDFに印刷したい場合は、WebBrowserExtensions.PrintToPdfAsyncメソッドを呼び出すことで、PDFファイルに保存することができます。Basic認証やDigest認証が求められる場合に、認証情報を入力するための仕組みを実装することができます。Proxyサーバで認証が必要な場合にも、この仕組みで認証情報の入力をユーザに求めることができます。
認証情報が必要になると、IRequestHandler.GetAuthCredentialsメソッドがCefSharpから呼び出されます。
なお、HTMLの仕様では一度Basic認証やDigest認証で認証に成功しても、それ以降同じホストに対するHTTPリクエストの度に認証が要求されます。一般的なブラウザはこの認証要求を、入力済みの認証情報を使って自動的に認証処理を行っています。 
CefSharpでも同様に一度認証に成功すると、それ以降同じホストからの認証要求は自動的に処理されるため、2回目以降はこのハンドラは呼び出されなくなります。IRequestHandlerインタフェースは、CefSharpを使うアプリケーションで最も重要なインタフェースです。
ここでは、このインタフェースを実装するクラスとして、RequestHandlerクラスを追加します。
「5. 開発者ツール」でのやり方と同様に、ソリューションエクスプローラでコンテキストメニューを出して、「追加」－「クラス」を選択して、クラス名にRequestHandlerを指定します。そして、以下のようにIRequestHandlerを実装させます。その後、IRequestHandlerを選択して電球マークのコンテキストメニューから、「すべてのメンバーを明示的に実装する」を選択します。Visual Studioで自動実装したメンバーは例外をスローするようになっているので、以下のデフォルト処理を実装します。ソリューションエクスプローラでコンテキストメニューから「追加」－「フォーム(Windows フォーム)」を選択して、新しいフォームを追加します。フォームの名前はここではAuthDialogとしました。
そして、以下のようにユーザ名とパスワードのTextInputとOKとCANCELボタンを持つダイアログボックスをデザインします。
※GetAuthCredentialsメソッドでは、認証を要求しているhostの情報、ポート番号、サーバが返却したrealm文字列等の情報も受け取るので、これらの情報も表示するようにすることもできます。また、AuthDialogクラスに以下を実装します。以下のようなコードになります。いよいよGetAuthCredentialsメソッドを実装します。
このメソッドはアプリケーションのUIスレッドとは異なるCEF IO threadと呼ばれるスレッドから呼び出されていますが、このスレッドを絶対にブロックしてはいけません。
そこで、WebViewの親コントロールのコンテキス(UIスレッドのコンテキスト)で、ダイアログを表示してユーザにユーザ名とパスワードの入力を促すようにして、このメソッド自体はすぐにtrueを返却するようにします。そして、ユーザが入力を確定した時点で、引数で指定されたIAuthCallbackインタフェースを使用して、入力されたユーザ名とパスワードをCefSharpに通知するようにします。  なお、「5. 操作対象についての注意」で説明したように、IWebBrowserではなくIBrowserを常に操作対象と考える必要があります。少し汚くなりますがPInvokeでWin32のGetParentを使って、IBrowserに関連したWebViewの親ウィンドウを取得します。この処理は今後も使うことになるため、以下のようなユーティリティ関数を作成します。具体的には、以下のようになります。このユーティリティメソッドを使用して、GetAuthCredentialsメソッドを実装します。作成したIRequestHandlerインタフェースをChromiumWebBrowser.RequestHandlerプロパティに設定します。認証が正しく実装できているか確認してみましょう。
BASIC認証を行う簡単なサーバを用意する必要があります。
ここでは、node.jsで動作するhttp-serverを使ってみます。よく使うので、グローバルにインストールしておきます。適当なディレクトリに移動して、以下のコマンドを実行すれば、BASIC認証を行うHTTPサーバが起動されます。
ポート番号を8081、ユーザ名をtest、パスワードをp@sswordとしています。これで、ポート8081でHTTPサーバが起動するので、さっそく確認してみましょう。
カスタムWebブラウザのアドレスバーにhttp://localhost:8081を入力してENTERを押下すると、作成した認証用ダイアログボックスが表示されます。正しいユーザ名とパスワードを入力するとページが表示されます。その後、F5キーでページを更新すると、認証ダイアログボックスは表示されないことが確認できます。これは一度認証に使ったユーザ名とパスワードの情報をCefSharpの内部で保持していて、二回目以降は自動で認証処理を行ってくれるからです。Webコンテンツが指定するタイトル文字列を表示します。
これを行うためには、IDisplayHandlerインターフェースを実装する必要があります。タイトル文字列が変更すると、CefSharpによってこのインタフェースのIDisplayHandler.OnTitleChangedメソッドが呼び出されます。まず、IDisplayHandlerインタフェースを実装するクラスを新規に作成します。 
リューションエクスプローラでコンテキストメニューを出して、「追加」－「クラス」を選択して、クラス名にDisplayHandlerを指定します。
そして、以下のようにIDisplayHandlerを実装させます。その後、IDisplayHandlerを選択して電球マークのコンテキストメニューから、「すべてのメンバーを明示的に実装する」を選択します。
自動実装されたメンバーは例外をスローするようになっているので、以下の様にデフォルト実装します。OnTitleChangedメソッドを実装します。
このメソッドの引数は、第一引数がIWebBrowserとなっていますが、実際にタイトル文字列が変更されたWebViewは第二引数のTitleChangedEventArgs.Browserプロパティで指定されるWebViewですので注意が必要です。
※「6.5 操作対象についての注意」で説明したように、第一引数のIWebBrowserと第二引数のプロパティで指定されるIBrowserが異なるWebViewを指している可能性があります。まず、第二引数のプロパティで指定されるIBrowserから、タイトルを変更する対象のウィンドウを特定します。タブ形式のブラウザにしている場合は、IBrowserを表示しているタブの文字列を変更することになるでしょう。
今回はタブ形式のブラウザでないため、メインウィンドウのタイトルを変更対象とします。
これには、「9.4 GetAuthCredentialsメソッドの実装」で実装してユーティリティメソッドを使って、IBrowserからWebViewを表示しているTopLevelのフレームを取得します。次に、対象ウィンドウのタイトルを変更しますが、IDisplayHandlerの各メソッドは、ブラウザのアプリケーションUIスレッドのコンテキストで呼び出されていないため、必ずメインウィンドウのコンテキストでタイトル文字列を変更されるようにします。以下は、実装例になります。作成したIDisplayHandlerインタフェースをChromiumWebBrowser.DisplayHandlerプロパティに設定します。以上でタイトル文字列がタイトルバーに表示されるようになりました。WebコンテンツのURLが変わったタイミングで、OnAddressChangedメソッドがCefSharpから呼び出されるので、ここで受け取ったURL文字列をアドレスバーに表示します。これだけです。「10. タイトルの表示」でIDisplayHandlerインタフェースを実装しているので、OnAddressChangedメソッドの中身を実装していきます。まず、メインフレームのクラスSimpleBrowserFrameにアドレスバー変更のメソッドを追加します。以下の様に、アドレスが変更になったIBrowserからSimpleBrowserFrameを取得して、アドレスバーの更新をします。
※今回はタブ表示でないためアドレスバーは１つしかないので、chromiumWebBrowserの親ウィンドウをたどってSimpleBrowserFrameを取得して操作するのと変わりませんが、複数タブを持つことを想定してこの実装にしています。以上でアドレスバーの文字列が更新されるようになりました。OnConsoleMessageメソッドは、Webコンテンツからconsole.logメソッドやconsole.errorメソッドでコンソールログを出力する時に呼びされるメソッドです。このメソッドを実装することで、コンソールログを保存するような処理を作ることができます。ログのライブラリは何を使ってもよいですが、ここでは人気にあるLog4netを使うことにします。以上で、Log4Netのパッケージ取り込み完了です。App.configに以下の定義を追加します。
この定義は以下の意味です。  AssemblyInfo.csファイルに以下の定義を追加する。OnConsoleMessageメソッドを実装して、Log4Netを使ってjavascriptのconsole.XXXメソッドの内容をログファイルに出力します。具体的には、以下の様に実装します。※OnConsoleMessageメソッドのドキュメントには、trueを返却するとコンソールにログを出力しなくなると書かれていますが、実際にはtrueを返却してもコンソールにログが出力されているようです（CefSharpのバージョンも関係するかもしれません）。プログラムを起動するとプログラムと同じディレクトリにconsole.logファイルができます。
中身を見ると、コンソールログが出力されていることが確認できます。ファイルのダウンロード機能を実装することができます。
download属性を持つa要素をクリックした場合など、ブラウザがダウンロードと判断した場合に、ファイルのダウンロードが行われます。まず、IDownloadHandlerインタフェースを実装するクラスを新規に作成します。 
リューションエクスプローラでコンテキストメニューを出して、「追加」－「クラス」を選択して、クラス名にDownloadHandlerを指定します。そして、以下のようにIDownloadHandlerを実装させます。その後、IDownloadHandlerを選択して電球マークのコンテキストメニューから、「すべてのメンバーを明示的に実装する」を選択する。
すると、IDownloadHandlerインタフェースの以下のメソッドが仮実装されます。OnBeforeDownloadメソッドは、ダウンロードするファイルの保存先やファイル名を決めるためのメソッドです。
プログラムで保存場所を決めることも、ユーザにファイルの保存先を問い合わせることができます。CefSharpのドキュメントにはダウンロードが開始される前に呼び出されると書かれています。
しかし、実際にはdownload属性のあるa要素をクリックすると、即座にダウンロードが開始され、最初にOnDownloadUpdatedメソッドが呼び出されます。そして、次にこのメソッドが呼び出されますが、バックグラウンドではダウンロード処理が進行しています。ここでは、ユーザに保存場所を問い合わせるようにします。
これを行うためには、引数で渡されるIBeforeDownloadCallbackインタフェースのContinueメソッドを呼び出します。以下の例では、デフォルトのファイル保存ダイアログが表示されます。
※第二引数をtrueにするとCefSharpがファイル保存ダイアログを出してくれます。もちろん以下の様に書けば、ユーザに問い合わせることなく、自動的に指定したファイルに保存することもできます。OnDownloadUpdatedメソッドはダウンロードが開始すると最初に呼び出され、その後ダウンロードの進捗に合わせて繰り返し呼び出されます。
このメソッドでは、ダウンロードのキャンセル・中断・再開ができます。
また、ダウンロードの進捗率が通知されるので、ユーザに進捗状況を表示する処理も実装可能です。ここでは、キャンセルも中断も行わないため、特に何も実装しません。最後にChromiumWebBrowser.DownloadHandlerプロパティに、実装したIDownloadHandlerインタフェースを設定することで、CefSharpがこのインタフェースを呼び出すようになります。具体的には、以下の様に指定します。例えばhttps://nodejs.org/en/にアクセスして、node.jsのインストーラをダウンロードしてみましょう。
正しく実装できていると「Save File」ダイアログが表示され、保存ボタンをクリックすると、指定した場所にファイルが保存されることが確認できます。faviconはHTMLで指定されているサイトのアイコンです。
ここでは、faviconの表示方法を説明します。faviconの仕様は少しゆるい仕様で、faviconの表示を厳密に実装するのは少し大変です。  指定できるイメージの形式は、W3CではPNG、GIF、ICOのいずれかとしていますが、実際にはJPEGやSVGもサポートしているブラウザも多いです。また、type属性でのファイルタイプの指定は強制ではないため、type属性を指定していないサイトも多くあります。また、複数のfaviconを設定することもできます。以下はHTMLでのfaviconの指定例です。以上の様にfaviconを扱うのは少し面倒ですが、ここでは以下の方針とします。まず、フォームのアイコンをfaviconに変更する処理を追加します。
以下の様にfaviconファイルのパスとMimeTypeを引数に持つメソッドを追加して、指定されたファイルパスのfaviconをフォームのアイコンとして表示します。CefSharpではfaviconが変わるタイミングで、IDisplayHandler.OnFaviconUrlChangeメソッドが呼び出されます。
しかし、faviconの取得はアプリ開発者に任されています。
faviconを取得するには、IBrowserHost.StartDownloadメソッドでダウンロードします。
※このメソッドを使うと任意のファイルをダウンロードすることができます。ダウンロードが行われると、「13. ダウンロード」で説明したように、IDownloadHandlerインタフェースのメソッドが呼び出されることになります。
このインタフェースはユーザがファイルのダウンロードを行う際にも呼び出されるため、ユーザがダウンロードしたファイルなのか、faviconとしてプログラムでダウンロードしたものなのかを判断する必要がでてきます。
このため、ダウンロード中のfaviconを管理するリストをもうけます。ダウンロード中のfaviconを管理するリストを以下の様に作成します。ダウンロードする前にダウンロード中のfaviconリストにfaviconのURLを追加して、その後faviconをダウンロードします。「13. ダウンロード」で実装したOnBeforeDownloadメソッドを、適当なパスにfaviconを自動保存するように変更します。以下の様に、ダウンロードしている対象のURLがダウンロード中のfaviconのリストに含まれている場合は、ランダムなファイル名で保存するように変更します。それ以外のURLの場合は、これまで通りファイル保存ダイアログを表示して、保存場所をユーザに問い合わせるようにします。「13. ダウンロード」で実装したOnDownloadUpdatedメソッドで、faviconのダウンロードが完了した時にフォームのアイコンを変更するように変更します。以下の様に、ファイルのダウンロードが完了した場合で、且つダウンロードした対象がfaviconの場合に、フォームのアイコンを更新するようにします。以上でfaviconが表示されるようになったはずです。

おー、faviconが表示されています。特に何もコードを書かなくても、pdfをロードすると、chromeのエクステンションによってPDFが表示されます。  特定のサイトのナビゲーションをブロックするには、IRequestHandlerインタフェースのOnBeforeBrowseメソッドでtrueを返却するだけです。このメソッドはフレームにURLがロードされることをブロックします。Webサイトの個々のリソース（image、javascript、css、ajaxで取得されるリソース等）のロードを個別にブロックする場合、IResourceRequestHandler.OnBeforeResourceLoadメソッドでブロックすることができます。ここでは、https://www.yahoo.co.jp/へのナビゲーションを禁止してみます。OnBeforeBrowseメソッドを実装します。
実装は非常に簡単です。 以下は実装例です。ビルドしてブラウザを起動して、アドレスバーにhttps://www.yahoo.co.jp/を入力してみます。
正しく実装できていると、ページがロードされないはずです。以上、非常に簡単だったと思います。Cookieは保存と送信をそれぞれ許可またはブロックすることができます。
ここでは、Cookieの保存と送信の制御の方法を説明します。まず、クッキーをコントロールするために、ICookieAccessFilterインタフェースを実装するクラスを新たに追加します。
ソリューションエクスプローラでコンテキストメニューを出して、「追加」－「クラス」を選択して、クラス名にCookieAccessFilterを指定します。そして、以下のようにICookieAccessFilterを実装させます。その後、ICookieAccessFilterを選択して電球マークのコンテキストメニューから、「すべてのメンバーを明示的に実装する」を選択します。するとICookieAccessFilterインタフェースのメソッドがすべて仮実装されます。CanSaveCookieメソッドは、レスポンスヘッダにSet-Cookieが設定されている場合に、cookieを保存するかどうかを判断するためにリソース毎に呼び出されます。
このメソッドではcookieを受け入れるかどうかを返却値で決定します。ここでは、すべてのサイトでCookieを保存しないようにしてみます。  CanSendCookieメソッドは、リソース毎にリクエストヘッダにCookieを設定するかどうか判断するために呼び出されます。
このメソッドではcookieを送信するかどうかを返却値で決定します。ここでは、すべてのサイトでCookieを送信しないようにしてみます。  先ほど作成したICookieAccessFilterインタフェースを実装したクラスを利用するために、IResourceRequestHandlerインタフェースを実装するクラスが必要になります。以下の流れで新しいクラスを追加します。ソリューションエクスプローラでコンテキストメニューを出して、「追加」－「クラス」を選択して、クラス名にResourceRequestHandlerを指定します。そして、以下のようにIResourceRequestHandlerを実装させます。その後、IResourceRequestHandlerを選択して電球マークのコンテキストメニューから、「すべてのメンバーを明示的に実装する」を選択します。するとIResourceRequestHandlerインタフェースのメソッドがすべて仮実装されます。GetCookieAccessFilter
独自のCookieの制御を行う場合はICookieAccessFilterを返却します。
今回はCookieを制御するため、先程作成したCookieAccessFilterクラスのインスタンスを返却するようにします。GetResourceHandler
独自のリソースハンドラを返却します。
ここでは独自のリソースハンドラは実装しないためnullを返却します。GetResourceResponseFilter
独自のリソースフィルタを返却します。
リソースフィルタはサーバからのレスポンスを変更するための機能で非常に便利です。
ここでは独自のリソースフィルタを実装しないためnullを返却します。OnBeforeResourceLoad
リソースがロードする前に呼び出されるメソッドです。
リソースのロードをブロックしたい場合は、このメソッドを実装します。
ここではリソースのロードをブロックしないため、CefReturnValue.Continueをリターンします。OnProtocolExecution
不明なプロトコルを持つURLが処理されるときに呼び出されます。
OSで登録されているプロトコルの呼び出しを試みる場合はtrueを返却します。
ここでは何もしないようにfalseを返却します。OnResourceLoadComplete
リソースのロードが完了した時に呼び出されます。
ここでは特に何もしません。OnResourceRedirect
リソースがリダイレクトされるときに呼び出されます。
ここでは特に何もしません。OnResourceResponse
リソースのレスポンスを受信したときに呼び出されます。
リソースをリダイレクトさせることができるようですが、この機能は将来廃止されるようです。
ここでは特に処理を行わないためfalseを返却します。以下に実装例を示します。作成したIResourceRequestHandlerインタフェースを実装したクラスが使われるように、IRequestHandler.GetResourceRequestHandlerメソッドを実装します。以下の様に、GetResourceRequestHandlerメソッドでIResourceRequestHandlerインタフェースを返却する様にします。以上の実装で全てのCookieがブロックされるようになりました。
確認のために、開発者ツールを起動してみます。Applicationを選択して「Clear Site Data」ボタンをクリックしてCookieを削除する。
F5でページをリロードする。レスポンスを確認する。
開発者ツールのnetworkを選択して、リクエストの内容を確認してみるとCookieがないことが確認できます。
つまり、Cookieは送信されていません。
Cookieを確認する。
ApplicationのCookieを選択すると、以下の様にCookieが保存されていないことが確認できます。
つまり、Cookieは保存されていません。
以上でCookieを保存と送信が制御できることが確認できました。表示しているWebページで任意のスクリプトを実行することができます。
例えば、ページのロードが完了した時点で、bodyの背景色を赤色にするスクリプトを実行することができます。
ここでは、まず初めにWebページのロード完了をハンドリングするために、ILoadHandlerインタフェースを実装します。
次に、ロード完了時にスクリプトを実行して、bodyの背景色を設定してみます。まず、ILoadHandlerインタフェースを実装するクラスを新規に作成します。 
リューションエクスプローラでコンテキストメニューを出して、「追加」－「クラス」を選択して、クラス名にLoadHandlerを指定します。そして、以下のようにILoadHandlerインタフェースを実装させます。その後、ILoadHandlerを選択して電球マークのコンテキストメニューから、「すべてのメンバーを明示的に実装する」を選択します。するとILoadHandlerインタフェースのメソッドがすべて仮実装されます。ILoadHandlerインタフェースの各メソッドを仮実装します。ILoadHandler.OnFrameLoadStart
ブラウザがフレーム(iframeやframeのこと)のロードを開始した時点で呼び出されます。
ここでは特に何もしません。ILoadHandler.OnLoadError
ナビゲーションの失敗やキャンセルによりエラーになった時点で呼び出されます。
ここでは特に何もしません。ILoadHandler.OnLoadingStateChange
ロードの状態が変化した時点で呼び出されます。
以下の「18.3 ILoadHandler.OnLoadingStateChangeメソッドの実装」で、ドキュメントのロード完了をハンドリングして、スクリプトを実行するようにしていきます。  引数で渡されるLoadingStateChangedEventArgsのIsLoadingプロパティを参照することでロードが完了したかどうかを判断することができます。そして、ロードが完了していれば、スクリプトを実行することにします。
スクリプトを実行するためには、IFrame.EvaluateScriptAsyncを呼び出します。以下は実装例です。最後にChromiumWebBrowser.LoadHandlerプロパティに、実装したILoadHandlerインタフェースを設定することで、CefSharpがこのインタフェースを呼び出すようになります。具体的には、以下の様に指定します。ビルドして実行してみます。
正しく実装できるていると、以下の様にbodyの背景色が赤色になっているはずです。
先ほどの例ではbodyの背景色を変更するスクリプトを実行するだけですが、Webページでスクリプトを実行して、その結果を受け取ることもできます。例えば、Webページのタイトル文字列を取得するスクリプトを実行する場合は以下の様に書きます。任意のクラスを作成してjavascriptから呼び出せるようにできます。 
ここでは、任意のコマンドを実行するクラスを作成して、javascriptから呼び出せるようにしてみます。任意のクラスを公開することができますが、以下の注意が必要です。callback無しですぐに完了するメソッドと完了時にcallbackを呼び出すメソッドの例を以下に示します。作成した独自クラスのインスタンスをjavascriptから利用できるように公開します。
これには、IWebBrowser インタフェースのJavascriptObjectRepositoryプロパティで公開されているIJavascriptObjectRepositoryインタフェースのRegisteメソッドを呼び出します。
IWebBrowserに対して操作していますが、ここで登録した独自オブジェクトは、子ウィンドウでも参照可能になります。以下の例ではTestという名称で、先ほどのTestクラスのオブジェクトを公開しています。javascriptでは、CefSharp.BindObjectAsyncメソッドを呼び出すことで、公開されたオブジェクトが使えるようになります。
このメソッドは非同期型(Promiseを返却する)ですので、完了を待つ必要があります。ビルド＆実行して、F12キーで開発者ツールを起動します。
次にコンソールを選択して、以下を入力して実行します。
これで、Testオブジェクトが参照可能になります。続いて、以下をコンソールに入力して実行します。
すると、電卓が起動することが確認できます。  続いて、callbackの確認として、以下をコンソールに入力して実行します。
すると、10秒後にコンソールにint型の配列が出力されます。このようにC#のオブジェクトをjavascriptに公開する機能は、CefSharpの非常に便利な機能です。CefSharpではHTTPのレスポンス内容をカスタマイズすることができます。
※レスポンスヘッダは変更することはできません。
この機能を使うことで、任意のスクリプトをレスポンスに埋め込むことなどができます。CefSharpは1つのリソースを受信する毎にIResourceRequestHandlerインタフェースのGetResourceResponseFilterメソッドを呼び出します。レスポンス内容のカスタマイズが必要な場合には、IResponseFilterインタフェースを返却するようにします。
そして、返却したIResponseFilterでレスポンスの内容を変更します。まず、IResponseFilterインタフェースを実装するクラスを新規に作成します。 
ソリューションエクスプローラでコンテキストメニューを出して、「追加」－「クラス」を選択して、クラス名にResponseFilterを指定します。そして、以下のようにIResponseFilterを実装させます。その後、IResponseFilterを選択して電球マークのコンテキストメニューから、「すべてのメンバーを明示的に実装する」を選択します。するとIResponseFilterインタフェースのメソッドがすべて仮実装されます。IResponseFilterインタフェースの各メソッドを実装します。コンストラクタ
コンストラクタは、ResponseFilterのインスタンスを作成するためにGetResourceResponseFilterメソッドが呼び出すことになります。このメソッドではレスポンスヘッダを参照することができるため、レスポンスの文字コードを取得することができます。
文字コードは後の処理で使用するために、コンストラクタの引数でを受け取るようにします。  Filter
このメソッドでレスポンス内容を変更しますが、バイト配列を操作する必要がるため、実装が少し複雑になります。
1つのリソースのレスポンスは分割されて受信する場合があるため、このメソッドは複数回呼び出されることになります。
基本的には、以下の流れになります。InitFilter
IResponseFilterを初期化するために、一回だけ(1つのリソースの処理で一回だけ)呼びだされます。
falseを返却するとIResponseFilterが使用されなくなります。
ここでは常にtrueを返却してIResponseFilterが使われるようにします。Dispose
解放が必要なリソースは特にありませんので、何も行いません。以下の例では、最初に現れた&lt;script&gt;タグの前に、以下のスクリプトを埋め込むことにします。  少し、複雑ですが参考にしてください。IResourceRequestHandler.GetResourceResponseFilterメソッドは1つのHTTPレスポンスを受信する度に呼び出されます。HTMLだけでなく、CSS、Javascript、PDF、イメージ等のすべてのリソースのHTTPレスポンスで呼び出されます。また、開発者ツールなどのカスタムスキーマ(devtools://など)の場合でも、このメソッドが呼び出されます。
したがって、レスポンス内容を変更する対象のリソースを絞る必要があります。例えば、以下の条件のレスポンスだけを編集対象とします。ほかにもMimeTypeを見る方法もあります。
以下は実装例です。ビルドして実行して開発者ツールを立ち上げてみます。
すると、コンソールにinjectedと出力されていることが確認できます。
また、Elementを確認すると、スクリプト要素が埋め込まれていることが確認できます。なお、上で実装したコードでは、最初のscriptとして追加されるようにしていますが、このように最初のscriptにならない場合があります。
これは、変更したWebコンテンツがブラウザにロードされた後に、内部のスクリプトによって追加のスクリプトがロードされてるためだと考えられます。また、Content-Security-Policy(CSP)を突破することはできないため、Content-Security-Policyのscript-srcの設定によっては、このように直接埋め込んだスクリプトは実行されないことにも注意が必要です。
CSPを突破するためには、IsCSPBypassingでCSPをバイパスする指定のカスタムスキーマ作成してスクリプトをロード必要があります。カスタムスキーマについては次章で説明します。カスタムスキーマとは、chromeでのchrome://versionのようなURLでのchrome://の部分のことです。http://やhttps://以外に独自のスキーマを提供することができます。
また、カスタムスキーマはContent-Security-Policy(CSP)を突破することができるため、「# 20. レスポンス内容の変更」で説明したレスポンスでscriptのsrcにカスタムスキーマのリソースを埋め込むと、任意のコードを実行できるようになります。
他にも通常のスキーマではできない、特殊なことを行うスキーマを提供することができます。ここでは、ローカルの任意のファイルの中身を取り出すスキーマを実装してみます。ISchemeHandlerFactoryインタフェースを実装するクラスを新規に追加します。ソリューションエクスプローラでコンテキストメニューを出して、「追加」－「クラス」を選択して、クラス名にLocalFileSchemeHandlerFactoryを指定します。そして、以下のようにISchemeHandlerFactoryインタフェースを実装させます。その後、ISchemeHandlerFactoryを選択して電球マークのコンテキストメニューから、「すべてのメンバーを明示的に実装する」を選択します。するとISchemeHandlerFactoryインタフェースのメソッドがすべて仮実装されます。ISchemeHandlerFactoryインターフェースにはCreateメソッドしかありません。
このメソッドでは、カスタムスキーマをサポートするために、IResourceHandlerインタフェースを返却する必要があります。
このIResourceHandlerインタフェースを実装するクラスを作成するのもよいですが、以下の便利なスタティックメソッドが用意されていますので、これを使うことで簡単にIResourceHandlerインタフェースを用意することができます。ここでは、FromFilePathメソッドとFromStringメソッドを使って、カスタムスキーマのメソッドを実装します。なお、カスタムスキーマは常に小文字として扱われます。
アドレスバーに大文字のカスタムスキーマ(LOCALFILE://xxx)と入れても、上のCreateメソッドには(localfile://xxx)と渡ってきます。カスタムスキーマを利用できるように登録します。
これには、CefSettingsBase.RegisterSchemeメソッドを使用します。
CefSettingsBaseクラスは、「3.1 Cef.Initializeメソッドによる初期化」で説明している初期化のためのCef.Initializeメソッドに指定するオブジェクトのクラスです。
CefSettingsBase.RegisterSchemeでは以下の項目を設定します。以下に実装例を示します。ビルドして実行してみます。アドレスバーに「localfile://temp/console.log」と入力して、ENTERキーを押下してみます。
※c:\temp\console.logがある前提。
すると以下の様にc:\temp\console.logファイルの内容が表示されるはずです。
アドレスバーに「localfile://aaaaa」と入力して、ENTERキーを押下してみます。
※c:\aaaaaがない前提。
すると以下の様にエラーメッセージが表示されます。
以上、カスタムスキーマはブラウザ独自の機能を作りこむときに非常に便利です。A要素のクリックやwindow.openメソッドで作成される子ウィンドウの管理はCefSharpで最も難しい部分です。
実はChromiumWebBrowserのインスタンスをフォームに張り付けただけの状態でも、必要に応じて子ウィンドウは自動的に作成されます。これはCefSharp内部の処理で行われていますが、自動作成される子ウィンドウではWebViewのコンテナであるウィンドウも自動作成されてしまいます。例えば、タブ表示で子ウィンドウを表示したい場合は、この動作は変えないといけないです。また、子ウィンドウが閉じられるタイミングもハンドリングして、すべてのウィンドウが閉じられたときに、アプリケーションを終了するような動作にする必要もあります。これを行うには、ILifeSpanHandlerインタフェースを作成して、自動作成されるWebViewも含めてインスタンスの管理を行う必要があります。このILifeSpanHandlerインタフェースは最も実装に気を使わなくてはいけないインタフェースです。ILifeSpanHandlerインタフェースを実装するクラスを新規に追加します。ソリューションエクスプローラでコンテキストメニューを出して、「追加」－「クラス」を選択して、クラス名にLifeSpanHandlerを指定します。そして、以下のようにILifeSpanHandlerインタフェースを実装させます。その後、ILifeSpanHandlerを選択して電球マークのコンテキストメニューから、「すべてのメンバーを明示的に実装する」を選択します。するとILifeSpanHandlerインタフェースのメソッドがすべて仮実装されます。ILifeSpanHandlerインタフェースには、次の4つのメソッドがあります。DoClose
WebViewが閉じられようとするときに呼び出されます。
ChromeなどのWebブラウザでは、タブの×ボタンでタブを閉じようとした場合、Webコンテンツでjavascriptのonbeforeunloadイベントハンドラが呼び出されます。そこで、preventDefault()が呼び出されると、このページを離れても良いかを確認するためダイアログを表示されて、ユーザが了承した場合にタブのクローズ処理が実行されます。そして、ユーザがタブを閉じることを了承すると、javascriptのonunloadイベントハンドラが実行されて、最終的にタブが閉じられれることになります。
これと同じ終了時の動作を実現するためは、WebViewのコンテナウィンドウが閉じられようとするときに、一旦ウィンドウを閉じる動作を拒否して、IBrowser.CloseBrowserメソッドを呼び出す様にします。すると、onbeforeunloadイベントハンドラが呼び出されるようになります。そして、最終的にウィンドウを閉じることが許可された場合に、本メソッドが呼び出されます。その後、本メソッドでfalseを返却すると、再度WebViewのコンテナウィンドウのクローズのために、OSからWM_CLOSEメッセージが通知されるので、フォームで終了処理を行うことになります。
今回は特に実装しませんが、onbeforeunloadの仕様を実現するためには、必ず実装が必要になります。OnAfterCreated
WebViewが作成されてIBrowserインタフェースが利用可能になった時点で呼び出されるハンドラです。
new ChromiumWebBrowser()で明示的にWebViewを作成した場合も、OnBeforePopupが呼び出された後にCefSharpが自動的にWebViewを作成した場合も、その後このメソッドが呼びされることになります。
ここでは、CefSharpが自動的にWebViewを作成する場合に、そのコンテナであるフォームに新たに作成されたWebViewの情報を設定する様にします。
この部分はこの後の章で実装していきます。OnBeforeClose
WebViewが閉じられるタイミングで呼び出されます。
タブ形式で表示している場合は、ここでWebViewのインスタンス数をデクリメントして、すべてのWebViewのインスタンス数がゼロになった時点でアプリケーションを終了するような実装にすることもできます。
今回は特に何も実装しません。OnBeforePopup
A要素のクリックやwindow.openにより子ウィンドウがオープンされる前に呼び出されます。ユーザ操作によるものかどうかを判断することができますので、ここでポップアップブロック機能を実現することもできます。
ここではCefSharpが自動的に作成するWebViewの親ウィンドウの情報を設定します。
この部分は以降の章で解説します。基本的にはfalseを返却してCefSharpにWebViewの作成を任せますが、trueを返却してCefSharpにWebViewを作成させない様にすることもできます。CefSharpにWebViewの作成を任せずに、自分でWebViewを作成する場合は、new ChromiumWebBrowser()を呼び出してWebViewを作成した後、trueを返却することになります。しかし、自動で作成されたWebViewと明示的にnewして作成したWebViewとでは、動作に大きな違いがあるので注意が必要です。  アプリケーションがwindow.open()メソッドで作成したウィンドウの場合、javascriptのpostMessageメソッドを使ってメッセージの送信ができたり、window.openerプロパティでオープンしたウィンドウの情報を子ウィンドウ側で取得するできる必要があります。しかし、明示的にnewして作成したWebViewの場合は、このようなウィンドウの親子関係がないため、これらの操作ができません。従って、このハンドラが呼び出される場合は、CefSharpにWebViewの作成をお任せすることをお勧めします。このメソッドでは、アプリケーションで新しいWebViewのコンテナとなるウィンドウを用意して、そのコンテナウィンドウの情報をCefSharpに通知します。もし、タブ形式のブラウザにする場合は、新しいタブを追加して、WebViewのコンテナとなるウィンドウを用意することになるでしょう。
ここでは、親ウィンドウと同じフォームを作成して、それをコンテナとする様にします。まず、コンテナとなるフォームSimpleBrowserFrameクラスのコンストラクタを変更して、WebView無しでフォームを作れるようにします。次に、OnBeforePopupメソッドを実装します。以上で、子ウィンドウが作成されるときに、アプリケーションで用意したコンテナ用のフォームにCefSharpが自動的に作成するWevViewが表示されるようになりました。このメソッドでは、新しく作成されたWebViewのIBrowserインタフェースをコンテナウィンドウであるフォームに設定します。次に、コンテナフォームであるSimpleBrowserFrameにIBrowserインスタンスを保持するためのプロパティを追加します。次に、コンテナフォームであるSimpleBrowserFrameのすべてのメソッドで、ChromiumWebBrowserではなくIBrowserを使用する様に変更します。
※CefSharpが自動的に作成したWebViewの場合、ChromiumWebBrowserインスタンスが存在しないため、戻るや進むといった操作はIBrowserを使用する様にする必要があります。以上で、新しく作成されたWebViewのインスタンスの情報を親フォームが受け取り、その後の各種操作ができるようになりました。ChromiumWebBrowser.LifeSpanHandler以上で、子ウィンドウの作成をコントロールできるようになりました。これまでの実装で子ウィンドウの作成ができるようになっていますが、現状では子ウィンドウをリサイズした時にWebViewのサイズがそのままになってしまっています。そこで、リサイズに対応させます。
具体的には、SimpleBrowserFrameフォームのResizeイベントのイベントハンドラを追加して、その中でWebViewのサイズを変更することになります。しかし、WebViewのウィンドウはNativeウィンドウですので、Pinvokeを使う必要があります。少し汚いですが、以下の様になります。ビルドして実行してみます。
ポップアップウィンドウの例として、Windows update catalogを使ってみます。
アドレスバーにhttps://www.catalog.update.microsoft.com/Search.aspx?q=KB4589208を入力してENTERを押下します。そして、適当なアップテートをクリックすると、新しい子ウィンドウが作成されることが確認できます。
その後、新しい子ウィンドウのアドレスバーでhttps://www.google.co.jp/を入力してENTERを押下した後、戻るボタンや進むボタンをクリックすると、子ウィンドウのナビゲートができていることが確認できると思います。ただし、現在の実装では、最初のウィンドウを閉じると、すべての子ウィンドウが閉じられる動作になっています。本格的なブラウザを作成する場合は、タブを収容するフレームを親ウィンドウにして、子ウィンドウをタブ表示にする方式が良いです。個人的な感想ですが、良い点と悪い点をまとめます。chromiumベースのWebViewアプリが簡単に作れる
少ないコードで完全なchromiumベースのWebViewを持つアプリケーションが作成できる。
chromiumベースなので、HTML5、CSS5の最新仕様に準拠している。  ブラウジングの様々な契機をハンドリングできるコンテンツの変更やscriptの埋め込みが簡単にできる独自機能を組み込んで、javascriptから利用させることができる開発者ツールも起動できる
F12キーで表示される開発者ツールも、簡単に表示することができる。
アプリケーションのデバッグもChromeと全く同じようにできる。chrome driverで試験もできる
seleniumもappiumも使用することができる。
テストに関してはchromeと同じようにすることができる。バージョンアップにより仕様が変わりすぎる
chromiumのバージョンに追従しているので、バージョンアップの頻度が非常に高い。
また、バージョンアップの度に、breaking changesという致命的な変更が行われるために、改造しないとビルドが通らなくなってしまう。ファイルサイズが大きい
chromiumのライブラリが含まれるため、小さく作っても150MB以上のファイルサイズになってしまう。
企業で使用する場合、端末へファイルを配布する方法を考える必要がある。動かないオプションがある
CefSharpのAPIマニュアルに書かれているオプションでも動作しないものがある。
実際に動作するかどうかは動かしてみないと分からない。コマンドラインオプションの仕様が明確でない
非公式なサイトに様々なコマンドラインオプションが紹介されていますが、実際に動作するかどうかは確認してみないと分からない。
また、バージョンによって、動作したり、動作しなかったりもする。geolocation APIや3rd-party Cookieのブロックなど、Chromeにあるのに利用できない機能がある
geolocation APIは、独自で作成して公開することで対応することはできる。
3rd-party Cookieは、自分で判断してブロックすることはできる。UWP用のEdgeのWebViewもありますが、Windowsで高度なカスタマイズを行えるWebViewとなると、今のところCefSharp一択ではないかと思います。最後まで読んでいただき、ありがとうございました。


