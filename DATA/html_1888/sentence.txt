みなさんSQLは書いていますか。僕は書きたくないです！(笑)先日、C#の.NET Framework MVCに触れる機会がありました。その中で、ORMとしてDapperを指定されました。通常、.NETを使う際はORMにEntity Framework(EF)を使うようです。EFにはそんなに詳しくないのですが、SQLをLINQっぽい文法で動的に組み立てて遅延実行ができるみたいです。しかし、Dapperは自らをmicro ORMと謳っていて、こいつはSQLのクエリを組み立てる能力はなく、自分でSQLを書かなければならないようです。一方で、使い勝手自体はかなりよく、マッピングしたいクラスを型引数に指定するだけで、プロパティに値を設定したインスタンスを返してくれます。使い方については公式リファレンスのほか以下のようなページでも分かりやすく書いてあるので目を通してみるといいでしょう。Dapper
https://dapper-tutorial.net/dapper
Dapperを使ったデータマッピングのはじめ方 │ Web備忘録
https://webbibouroku.com/Blog/Article/dapperしかし、EloquentやActive Recordの旨味を知ってしまった僕はSQLを書きたくないのです。よって、Dapperを内部に隠ぺいしつつ、SQLを自力で書かないで済むような仕組みを考えます。Dapperの基本的な使い方は次のような感じです。なるほど。どうやらConnection.Query&lt;マッピングしたい型&gt;(SQL文, バインド変数の匿名オブジェクト)のように使うらしいです。このQueryメソッドがDBConnectionの拡張メソッドとして定義されているみたいですね。というわけで、なんとかしてこのSQLを書かずに済む方法を考えましょう。たまにあるのはWHERE 1 = 1みたいなSQL文をあらかじめ作っておき、StringBuilderとかでSQLを伸長していくやつです。WHERE 1 = 1という常にtrueになる文言を加えておくことで、あとは機械的にAND WHERE...という句を付け足していけばいいという方法ですね。ただ、この方法だとやはり柔軟性に欠けますし、JOIN句を付け足したりということもできないし、そもそもWHERE1 = 1なんていう禅問答みたいな句がSQLに入っているというのもなんだか美しくないです。database/Builder.php at master · illuminate/database
https://github.com/illuminate/database/blob/master/Query/Builder.phpBuilderというクラスを見てみましょう。なにやらwhereやらjoinやらを変数を持っています。これらに句を追加していくのでしょうか。また、それぞれのメソッドは、return thisと自分自身を返しています。これでメソッドチェーンを可能にしているのでしょう。ということで真似してみたいと思います。しかし、もとのDapperの使い方を見てみましょう。うーん、バインド変数を用意しないと駄目みたいですね。が、よくよく考えてみると、別にすぐこのあとに変数に値が代入されるのです。変数の名前なんてhogeでもfugaでもどうでもいいでしょう。この部分はプログラムで機械的にparam0, param1, ...という感じで作ってしまいたいと思います。一方で、そのバインド変数に匿名オブジェクトを用意しないといけません。これは、機械的にバインド変数を作ると同時に作っていくことにしましょう。というわけでこれを参考にクラスを作っていきます。SQL文をバインド変数とともに組み立てるためのクラスと、実際にSQLを実行するクラスとに分けて作っていくことにします。SQL文を組み立てるSelectQueryExecuterでは、テーブル名、WHERE句の要素、OR WHERE句の要素などを保持しておくプライベートなフィールドを持っておきます。SQLを考えるときって、だいたいどのカラムからデータを取るかということ以前に、どのテーブルからデータを取るかということを考えると思うので、真っ先にこれを書くために、コンストラクタにそれを指定させるようにしました。Whereメソッドが呼ばれたときには、現在保持しているバインド変数の数を取得し、それをもとにparam0のようなバインド変数を作成し、バインド変数のオブジェクト(IDictionaryを実装していれば匿名オブジェクトである必要はないそうです)にそれを追加。WHERE句の要素を管理するリストにもそれを追加します。最後に自分自身を返し、メソッドチェーンが続けられるようにします。そして、ToQueryメソッドが呼ばれたときにSQL文を構築します。ここは、WHERE 1=1などに頼ることなく、最初の要素かそれ以外かで場合分けしながら愚直に構築していきます。プログラマーなんだからそれくらいは頑張ってやりましょう。最後にGetメソッドです。GetメソッドでSQL文を実際に実行します。型引数には、マッピングしたいクラスを指定します。今回は、結果を1件だけ取得したいときはGetOneメソッドを、リストで取得したいときはGetメソッドを呼ぶようにしました。これによって次のようにクエリーをメソッドチェーンで書くことができるようになりました。言うまでもないですが、と等価です。かなりEloquentやActive Recordみが出てきたんじゃないでしょうか。これが分かれば簡単です。この要領でJOINもできるようにしましょう。のようなプライベート変数を用意し、のようにメソッドを生やします。JOINの場合はWHEREで条件を絞ればそのレコードごと落ちますが、LEFT JOINの場合はレコードごと落ちると困るという場合があるので（論理削除のときなど）、conditionsで複雑な条件設定ができるようにしています。これにより次のようなクエリーをメソッドチェーンで書くことができるようになりました。だんだんQueryBuilderが立派になってきたので、さらに欲が湧いてきます。親も一緒にマッピングしたくなってきました。公式リファレンスを見ると次のようにしろと書いてあります。Result Multi Mapping
https://dapper-tutorial.net/result-multi-mappingあるいは、以下のようなQiitaの記事を見てもいいかもしれません。DapperのQueryを使ってマルチマッピングしてみる - Qiita
https://qiita.com/Tokeiya/items/dda1096d03dfbf5fe431子モデルのプロパティに親モデルを持たせて、マッピング時に代入していくわけですね。まず、SQLを実行するクラスであるDatabaseManagerに、複数の型引数を受け取れるようにメソッドを追加します。次にSelecuQueryExecuterにGetEagerWithParentというメソッドを追加して、公式リファレンスに書いてあるのと等価な処理をリフレクションを使って書きます。ほんとは親の数を可変長にしてもっと柔軟に書きたかったのですが、可読性がさらに悪化するのと、そこまで大量のマッピングを要求されることがないだろうと思ったのでべた書きにしました。GetEagerWithParentメソッドの引数は、(最終的にマッピングしたいクラスのインスタンス, 親としてマッピングしたいクラスのインスタンス, 親を代入するためのプロパティ名, ...)というふうにしました。これによって次のようにクエリーを書くことができるようになりました。いい感じですね。親のマッピングができれば次は子供のマッピングです。子供のマッピングはかなり厄介です。公式リファレンスには次のようなやり方が紹介されています。keyが親のid、valueが親のインスタンスとなるDicitonaryを用意しておき、SQLの結果レコードを1行走査するごとに、新たな親が見つかればDicitionaryに追加、既存の親ならそのインスタンスをDictionaryから取得。そのインスタンスのList型の子プロパティに子インスタンスを追加していくようです。とても面倒ですね。が、嘆いても仕方ないので、この処理をやはりリフレクションをもりもりに使いながら、ラップします。すなわちこうです。うんざりするほど長くなりましたが、これのおかげで次のようなクエリーが書けるようになりました。プログラマーは手抜きをするためなら全力で努力をする生き物です。ここまで行くと、さらにEloquentやActive Recordに寄せてみたくなります。つまりモデルから直接クエリーを発行するのです。SelectQueryExecuterにモデルを受け付けるようなメソッドを生やしておきます。そして次のような抽象基底クラスを定義します。Table名の実装を強制します。Modelクラス自体がジェネリックになっているのは、FindメソッドやAllメソッドでこのクラスを継承した具象クラスのインスタンスを返したいからです。これにより、次のようなクエリーを発行することができるようになりました。DefaultQueryには必要に応じて論理削除や並び順などの処理を書いておくといいでしょう。よくできたORMのGlobalScopeみたいなことができます。SelectQueryExecuterはGetメソッドを呼ばれない限りSQLは実行されず、順番に縛られずにQueryの状態を保持することができるので、頻繁にJOINするおきまりのテーブルがあるならばそれをあらかじめ定義したSelectQueryExecuterを返すメソッドをモデル内に作るのもいいでしょう。LocalScopeみたいなことができます。最後にUPDATEにも対応しましょう。まず、Dapperの公式リファレンスを見てみましょう。やり方はSELECTのときと全く同じで、Executeというメソッドの第一引数にSQL文、第二引数に匿名オブジェクトを指定するみたいですね。辻褄さえ合っていれば、第二引数は匿名オブジェクトである必要はなく実際のクラスのインスタンスでも全く問題ありません。DBがスネークケースで、C#のクラスのプロパティはパスカルケースということが多いでしょうから、スネークケースをパスカルケースに変換するstringの拡張メソッドを作っておきます。そしてUpdateQueryExecuterメソッドを作成します。UPDATE文はSELECTと比べて自由度が圧倒的に少なくシンプルです。これによって次のようなクエリーを書くことができるようになりました。いちいち毎回カラムを指定するのが面倒です。というわけでModel抽象クラスに次のようなフィールドとメソッドを追加します。具象クラスではこれを必要に応じてオーバーライドします。マスターデータならいらないと思いますが、たいていの場合はオーバーライドが必要でしょう。これで次のようにモデルがDBに保存できるようなりました。簡単ですね。SQLを書きたくないがゆえに、Dapperを使いつつSQLを書かずに済む方法を提案しました。初めからEF使えという話ではありますが。しかし、自分でこのようなQueryBuilderを一から実装すると、ブラックボックスにならず、また愛着も湧くというものです。必要に応じて拡張ができるのも嬉しいところです。今回は全ての紹介をすることはせず一部の紹介にとどめましたが、同様の手順で他のメソッドを追加したり、INSERTやDELETEも同じように実行することが可能です。皆さんも自分だけのQueryExecuterを作ってみてくださいね！　それではみなさん、よきORMライフを！


