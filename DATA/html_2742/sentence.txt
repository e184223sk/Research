More than 1 year has passed since last update.通常ありえないところで一日無駄にしたので備忘録。
実際、発生した問題とUnityとはあまり関係がありませんが、ゲームの開発中に同じ問題に直面した人のために残しておきます。恐らく私以外にはいないことを祈る。2019/09/29追記：コメントにてすごく尤もな指摘を受けたので少し加筆修正。あと記事内で「イテレータ」という言葉がありますが、用いられる意味としてはどちらかというと「カウンタ変数」が近いです。弾幕シューティング作ろう！
環境はPC想定でまあとにかく作るか。基本中の基本のプログラムは作ったぞ……性能にもこだわりたいから、いろいろ調べた結果Unity ECSとC# Job Systemsを使おう！……と、その前に性能比較用に弾数をだんだん増やすスクリプトを作った！　早速計測だ！(Ctrl+P)　突　然　の　死Ctrl+Shift+ESCでタスクマネージャで見てみるとエディタが応答なし。そして時間経過でメモリ使用量が増えていく。このままではメモリ圧迫してろくでもないことになるのは明白。慌てず騒がず落ち着いてタスクを終了。Unity関連でかなり色々と調べはしたものの問題は判明せず。これはもう無視してECSとか導入した方が良いのでは？　いやしかし問題を放置して新しい技術の勉強はちょっと気が引ける。どうしよう。と、あるものを見つけた。
フリーズした画面。エディタ内のInspectorに弾の発射数を眺めるためにSerializeFieldにしていた変数が、フリーズするときは必ず「361」の数値になっているじゃ、あーりませんか！しかし、「361」の数値は何を意味しているのか……。ん、待てよ？　361ということは、360度、つまり弾の数に合わせた発射角の計算をイテレータ(i)に反映しているコードに何か問題が！というわけで調べました。問題のコードがこちらC#プログラミング上級者の方に見せたら「そんなことでか」と言われそうなミスであります。この中のfor文
for (int i = 0; i &lt; 360; i += (360 / bullet))
に問題があります。最初は複合代入演算子+=か、イテレータの型int iか、floatとintの比較&lt;に問題があるのかと考えていました。今思えば、3つ目に関しては二重に勘違いしていますね。ということで順に勘違いを正していきましょう。ちなみに360のハードコーディングはテスト用のプラグラムなので問題ありません。この問題を詳しく調査して得た成果物。勘違いを粉微塵にする正しい知識集です。問題の解決法はこちらに。3/2、6/5、3/4はそれぞれ1、1、0となります。仮にfloat f = 3 / 2;であっても、整数同士の除算による計算結果がすべて整数になるので、代入しようがしまいがfの中身は1になります。そしてこの整数同士の除算の商は必ず小数点以下切り捨てとなります。これはマイナスの数値であっても同様です。ちなみにこれが私の知らなかった一番の事実です。これを知らずに間違った知識で致命的なバグを引き起こしました。intはfloatに対して暗黙的型変換が可能なので、内部的にfloat同士で比較することが可能というわけです。
というかintとfloatの入り混じった式は特に問題ありません。
ただし、floatの値は必ずしも正確ではないことに注意。一つ上の段落でintはfloatに暗黙的型変換が可能と述べましたが、対するfloatはdecimalに対してのみ暗黙的型変換が許されているのみで、float to intの変換は明示的、つまりキャストが必要です。代入でいえばメソッドでいえばこのような感じです。まあこのあたりは直面した問題とさして関係ありません。改めてこのコードの何が悪いのかを見ていきます。まず、i += (360 / bullet)の部分。
bulletが361以上になると、整数同士の除算の法則に基づき0が導き出されiに加算されます。
必然と0を足し続けることになるので、このfor文は無限ループと化します。
……だから応答なしになるし、内部的には際限なくInstantiateしていることになるのでメモリ使用量も増えるばかりなのです。これを回避するためには、単に整数同士でなくすればよいだけです。ただしbullet変数はintである必要があるので、360をfloat型にしましょう。するとint型のiにはfloat型を格納することになるので、iもfloat型に変更しなければなりません。ぁちょっと待ったァ！for文の初期化式は基本的にint型int i = 0;でfloat型は使うべきではないと、わりと昔から言われているようです。現に私は少しだけ既視感を感じています。for文にfloat型は望ましくないというなら、じゃあどうするのか教えてくれよキ○ベツ太郎と。
というかそもfor文の更新式で角度の計算も兼ねるとか横着すんじゃねえよと。
普通にfor文の基本形for(int i = 0; i &lt; something; i++)に沿えばいいだろう、というわけで。このように変更することで無限ループを回避しました。ちなみに360fのハードコーディングはテスト用のプログラムなので問題ありません。(2回目)……最初から横着しなければよかっただろうという至極尤もな意見は受け付けません。あしからず。そもfor文内にi += (360 / bullet)という処理があり、角度の計算も兼ねるのでもちろんのこと整数以上の精度が必要なのにもかかわらず、int型のまま放置しているという開発者にはありえないミスとはいえfor文の初期化式にfloat型の変数は使うべきではない。float型の計算はあまり精度良くないってわりとどこでも言っているだろう！
そも特別な理由がない限りfor文の()内の処理で別の処理を兼ねたりする横着はしないようにする。(戒め)
いやまあ発射角度が360度以下のならまあ想定通りにはなるか？
その場合はまた別の実装をしないと無限ループは避けられないな。for文の()内で余計なこと(横着)をしないとか。(余計なことしてました(小声))算術演算子 - C# リファレンス | Microsoft Docs


