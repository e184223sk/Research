<!DOCTYPE html><html><head><meta charset="utf-8" /><title>【C# 中級向け】「コンパイル時の型」と「実行時の型」を意識しよう - Qiita</title><meta content="width=device-width,initial-scale=1,shrink-to-fit=no,viewport-fit=cover" name="viewport" /><meta content="#55c500" name="theme-color" /><meta content="XWpkTG32-_C4joZoJ_UsmDUi-zaH-hcrjF6ZC_FoFbk" name="google-site-verification" /><meta content="telephone=no" name="format-detection" /><link rel="canonical" href="https://qiita.com/lobin-z0x50/items/f8421e046d96322250e2" /><link href="/manifest.json" rel="manifest" /><link href="/opensearch.xml" rel="search" title="Qiita" type="application/opensearchdescription+xml" /><link as="script" href="https://www.googletagservices.com/tag/js/gpt.js" rel="preload" /><link href="https://securepubads.g.doubleclick.net" rel="preconnect" /><script async="" src="https://www.googletagservices.com/tag/js/gpt.js"></script><meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="Wnq8Ck62heGjfNYmNKjq2vnosAf9uws2hT1zZFH9IAKoMeyzEBSwviOLapQRrkDQuQQ+pywflLtkY4jC1tfCyw==" /><link rel="shortcut icon" type="image/x-icon" href="https://cdn.qiita.com/assets/favicons/public/production-c620d3e403342b1022967ba5e3db1aaa.ico" /><link rel="apple-touch-icon" type="image/png" href="https://cdn.qiita.com/assets/favicons/public/apple-touch-icon-ec5ba42a24ae923f16825592efdc356f.png" /><link rel="stylesheet" media="all" href="https://cdn.qiita.com/assets/public/article-2eaa7dbedc42a8ea65c722cda46d0ebb.min.css" /><script src="https://cdn.qiita.com/assets/public/v3-article-bundle-63de2d91fef827269d3f6b958db2335b.min.js" defer="defer"></script><meta name="twitter:card" content="summary_large_image"><meta content="@Qiita" name="twitter:site" /><meta property="og:type" content="article"><meta property="og:title" content="【C# 中級向け】「コンパイル時の型」と「実行時の型」を意識しよう - Qiita"><meta property="og:image" content="https://qiita-user-contents.imgix.net/https%3A%2F%2Fcdn.qiita.com%2Fassets%2Fpublic%2Farticle-ogp-background-1150d8b18a7c15795b701a55ae908f94.png?ixlib=rb-4.0.0&amp;w=1200&amp;mark64=aHR0cHM6Ly9xaWl0YS11c2VyLWNvbnRlbnRzLmltZ2l4Lm5ldC9-dGV4dD9peGxpYj1yYi00LjAuMCZ3PTg0MCZoPTM4MCZ0eHQ2ND00NENRUXlNZzVMaXQ1N1NhNVpDUjQ0R1I0NENSNDRDTTQ0S3o0NE96NDRPUjQ0S2s0NE9yNXBtQzQ0R3U1WjZMNDRDTjQ0R280NENNNWE2ZjZLR001cG1DNDRHdTVaNkw0NENONDRLUzVvU1A2SzJZNDRHWDQ0S0k0NEdHJnR4dC1jb2xvcj0lMjMzMzMmdHh0LWZvbnQ9SGlyYWdpbm8lMjBTYW5zJTIwVzYmdHh0LXNpemU9NTQmdHh0LWNsaXA9ZWxsaXBzaXMmdHh0LWFsaWduPWNlbnRlciUyQ21pZGRsZSZzPTQ4OTJjNTdhY2IzZGViZjQyOTNkMTRmN2MwZDY4OTA2&amp;mark-align=center%2Cmiddle&amp;blend64=aHR0cHM6Ly9xaWl0YS11c2VyLWNvbnRlbnRzLmltZ2l4Lm5ldC9-dGV4dD9peGxpYj1yYi00LjAuMCZ3PTg0MCZoPTUwMCZ0eHQ2ND1RR3h2WW1sdUxYb3dlRFV3JnR4dC1jb2xvcj0lMjMzMzMmdHh0LWZvbnQ9SGlyYWdpbm8lMjBTYW5zJTIwVzYmdHh0LXNpemU9NDUmdHh0LWFsaWduPXJpZ2h0JTJDYm90dG9tJnM9ZDA5YzgwM2I4YjJmNDEwYjFjODMzOWRhZjlkNmVmOTc&amp;blend-align=center%2Cmiddle&amp;blend-mode=normal&amp;s=5b257806b1d02ecc5d36673149c2edfb"><meta property="og:description" content="

はじめに

この記事では、C# における コンパイル時の型 と 実行時の型 について説明する。また関連する概念としてオーバーライドとオーバーロードの違い、演算子とメソッドで呼び出し対象の決定タイミングの違いについて簡単に説明する。..."><meta content="https://qiita.com/lobin-z0x50/items/f8421e046d96322250e2" property="og:url" /><meta content="Qiita" property="og:site_name" /><meta content="564524038" property="fb:admins" /><meta content="C#,オブジェクト指向,型,オーバーライド,オーバーロード" name="keywords" /><script>!function(f,b,e,v,n,t,s)
{if(f.fbq)return;n=f.fbq=function(){n.callMethod?
n.callMethod.apply(n,arguments):n.queue.push(arguments)};
if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
n.queue=[];t=b.createElement(e);t.async=!0;
t.src=v;s=b.getElementsByTagName(e)[0];
s.parentNode.insertBefore(t,s)}(window, document,'script',
'https://connect.facebook.net/en_US/fbevents.js');
fbq('init', '668972150489891');
fbq('track', 'PageView');</script><style data-emotion-css="17jxvjw 11t2ec1 1dvr2p8 18lkoru 1g4cku8 1iupg5d ijvq0v 15cocm3 12rp90f 115f4t 1b8uj5v 79elbk 16hhh7b fcbn8c 1gj7nt 154zy0m yikrym 1jqivyb 1ode1bp le4d8r 1hbd3g7 1nzh4zz 38fzdi helsa7 8qb8m4 2imjyh he5w1s 70qvj9 3ojehk 100alwu 1dtnjt5 10ougpm 1ay9vb9 m19uds cgzq40 1wa99t2 1l3zk9f 4czcte 1yzj1fm 1uv1qiv 109dbrr 5jpx49 mnxgyc 1vlpknv fsjkhv 1b17vb0 7i7f4d"}>.css-17jxvjw{display:grid;display:-ms-grid;grid-template-columns:80px minmax(0,1fr) 300px;-ms-grid-columns:80px minmax(0,1fr) 300px;grid-template-rows:minmax(270px,auto) 1fr;-ms-grid-rows:minmax(270px,auto) 1fr;max-width:1280px;margin-right:auto;margin-left:auto;padding-top:24px;padding-right:24px;padding-left:24px;}@media (max-width:1200px){.css-17jxvjw{padding-bottom:0;padding-left:0;padding-right:0;}}@media (max-width:992px){.css-17jxvjw{grid-template-columns:80px 452px 300px;-ms-grid-columns:80px 452px 300px;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;}}@media (max-width:770px){.css-17jxvjw{display:block;}}@media (max-width:480px){.css-17jxvjw{padding-top:0;}}.css-11t2ec1{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;z-index:5;position:-webkit-sticky;position:sticky;top:calc(56px + 24px + 16px + 32px - 16px);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;padding:16px;width:80px;}.css-11t2ec1:after{content:'';display:table;}.css-11t2ec1:before{content:'';display:table;}@media (max-width:770px){.css-11t2ec1{display:none;}}.css-1dvr2p8{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;margin-bottom:16px;}.css-18lkoru{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border:2px solid #55C500;border-radius:50%;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:40px;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;padding:0;width:40px;background-color:#FFFFFF;}.css-1g4cku8{display:inline-block;vertical-align:middle;height:20px;width:20px;fill:#55C500;}.css-1iupg5d{color:#55C500;cursor:pointer;font-size:14px;font-weight:bold;}.css-ijvq0v{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;margin-bottom:16px;}.css-15cocm3{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#FFFFFF;border:2px solid #6E6F70;border-radius:50%;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:40px;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;padding:2px 0px 0px;width:40px;}.css-12rp90f{display:inline-block;vertical-align:bottom;height:17.77777777777778px;width:16px;fill:#6E6F70;}.css-115f4t{color:#6E6F70;font-size:14px;font-weight:bold;}.css-1b8uj5v{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:#6E6F70;cursor:pointer;font-size:20px;height:32px;outline:none;width:32px;margin-bottom:16px;padding:0;}.css-79elbk{position:relative;}.css-16hhh7b{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:#6E6F70;cursor:pointer;font-size:20px;height:32px;outline:none;width:32px;padding:0;}.css-fcbn8c{display:none;bottom:initial;left:initial;right:initial;top:initial;left:100%;top:calc(-8px - (14px * 1.8) - 16px - 4px);}.css-1gj7nt{color:rgba(0,0,0,0.6);font-size:14px;font-weight:bold;line-height:1.8;padding:8px 16px;}.css-154zy0m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:rgba(0,0,0,0.87);cursor:pointer;font-size:16px;font-weight:normal;line-height:1.8;padding:4px 16px;}.css-154zy0m:hover{-webkit-text-decoration:none;text-decoration:none;background-color:#F2F2F2;}.css-yikrym{width:20px;}.css-1jqivyb{color:rgba(0,0,0,0.6);font-size:13px;}.css-1ode1bp{background-color:rgba(0,0,0,0.12);height:1px;width:100%;margin:8px 0;}.css-le4d8r{display:inline-block;vertical-align:middle;height:13px;width:13px;fill:rgba(0,0,0,0.6);}.css-1hbd3g7{height:250px;}.css-1nzh4zz{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:16px 32px;background-color:#FBE69E;color:rgba(0,0,0,0.87);line-height:1.5;font-weight:600;}@media (max-width:770px){.css-1nzh4zz{padding:16px;}}.css-38fzdi{color:#CA832A;margin-right:4px;}.css-helsa7{background-color:#FFFFFF;padding:32px;margin-bottom:24px;}@media (max-width:992px){.css-helsa7{margin:0 auto 40px;}}@media (max-width:480px){.css-helsa7{margin:0 0 40px;padding:32px 16px;}}.css-8qb8m4{margin-bottom:48px;}.css-2imjyh{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.css-he5w1s{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;width:100%;}@media (max-width:770px){.css-he5w1s{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;}}.css-70qvj9{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.css-3ojehk{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin-right:4px;}.css-100alwu{display:inline-block;border-radius:50%;line-height:1;overflow:hidden;vertical-align:middle;}.css-1dtnjt5{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.css-10ougpm{color:rgba(0,0,0,0.87);font-size:14px;font-weight:600;line-height:1.8;margin-right:4px;text-wrap:break-word;word-break:break-all;}.css-1ay9vb9{margin-right:16px;}.css-m19uds{color:rgba(0,0,0,0.6);font-size:14px;line-height:1.8;}.css-cgzq40{color:rgba(0,0,0,0.87);font-size:32px;font-weight:bold;line-height:1.4;margin-top:8px;text-wrap:break-word;word-break:break-all;}.css-1wa99t2{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:rgba(0,0,0,0.6);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-top:8px;}.css-1l3zk9f{color:rgba(0,0,0,0.6);font-size:20px;margin-right:8px;}.css-4czcte{margin-right:4px;color:inherit;font-size:14px;line-height:1.8;}.css-4czcte:not(:last-child)::after{content:',';margin-right:4px;}.css-1yzj1fm{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-top:32px;}.css-1uv1qiv{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:#6E6F70;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;font-size:20px;height:32px;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;margin-right:16px;outline:none;padding:0;width:32px;}.css-109dbrr{background-color:#F9F9F9;border-top:1px solid rgba(0,0,0,0.12);bottom:0;box-shadow:0px 1px 4px rgba(0,0,0,0.14);display:none;height:calc(env(safe-area-inset-bottom,0px) + 56px);-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;padding-bottom:env(safe-area-inset-bottom);position:-webkit-sticky;position:sticky;width:100%;z-index:2000;}@media (max-width:770px){.css-109dbrr{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}.css-5jpx49{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:space-evenly;-webkit-justify-content:space-evenly;-ms-flex-pack:space-evenly;justify-content:space-evenly;width:100%;}.css-mnxgyc{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;}.css-1vlpknv{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border:2px solid #55C500;border-radius:50%;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:40px;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;padding:0;width:40px;margin-right:4px;background-color:#FFFFFF;}.css-fsjkhv{-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;}.css-1b17vb0{color:#6E6F70;font-size:14px;font-weight:bold;margin-left:4px;}.css-7i7f4d{display:none;bottom:initial;left:initial;right:initial;top:initial;bottom:32px;right:0;}</style></head><body><div class="allWrapper"><div><div id="GlobalHeader-react-component-2793ae6b-8636-47bf-973b-752b8b291632"><div class="st-Header"><div class="st-Header_container"><div class="st-Header_start"><a href="/" class="st-Header_logo"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 426.57 130"><circle cx="167.08" cy="21.4" r="12.28"></circle><path d="M250.81 29.66h23.48v18.9h-23.48z"></path><path d="M300.76 105.26a22.23 22.23 0 01-6.26-.86 12.68 12.68 0 01-5.17-3 14.41 14.41 0 01-3.56-5.76 28 28 0 01-1.3-9.22V48.56h29.61v-18.9h-29.52V3.29h-20.17v83.34q0 11.16 2.83 18.27a27.71 27.71 0 007.7 11.2 26.86 26.86 0 0011.43 5.62 47.56 47.56 0 0012.34 1.53h15.16v-18zM0 61.7a58.6 58.6 0 015-24.21A62.26 62.26 0 0118.73 17.9 63.72 63.72 0 0139 4.78 64.93 64.93 0 0164 0a65 65 0 0124.85 4.78 64.24 64.24 0 0120.38 13.12A62 62 0 01123 37.49a58.6 58.6 0 015 24.21 58.34 58.34 0 01-4 21.46 62.8 62.8 0 01-10.91 18.16l11.1 11.1a10.3 10.3 0 010 14.52 10.29 10.29 0 01-14.64 0l-12.22-12.41a65 65 0 01-15.78 6.65 66.32 66.32 0 01-17.55 2.3 64.63 64.63 0 01-45.23-18A62.82 62.82 0 015 85.81 58.3 58.3 0 010 61.7zm21.64.08a43.13 43.13 0 0012.42 30.63 42.23 42.23 0 0013.43 9.09A41.31 41.31 0 0064 104.8a42 42 0 0030-12.39 42.37 42.37 0 009-13.64 43.43 43.43 0 003.3-17 43.77 43.77 0 00-3.3-17A41.7 41.7 0 0080.55 22 41.78 41.78 0 0064 18.68 41.31 41.31 0 0047.49 22a42.37 42.37 0 00-13.43 9.08 43.37 43.37 0 00-12.42 30.7zM331.89 78a47.59 47.59 0 013.3-17.73 43.22 43.22 0 019.34-14.47A44.25 44.25 0 01359 36a47.82 47.82 0 0118.81-3.58 42.72 42.72 0 019.26 1 46.5 46.5 0 018.22 2.58 40 40 0 017 3.84 44.39 44.39 0 015.71 4.63l1.22-9.47h17.35v85.83h-17.35l-1.17-9.42a42.54 42.54 0 01-5.84 4.67 43.11 43.11 0 01-7 3.79 44.86 44.86 0 01-8.17 2.59 43 43 0 01-9.22 1A47.94 47.94 0 01359 119.9a43.3 43.3 0 01-14.47-9.71 44.17 44.17 0 01-9.34-14.47 47 47 0 01-3.3-17.72zm20.27-.08a29.16 29.16 0 002.17 11.34 27 27 0 005.92 8.88 26.69 26.69 0 008.76 5.76 29.19 29.19 0 0021.44 0 26.11 26.11 0 008.72-5.76 27.57 27.57 0 005.88-8.84 29 29 0 002.16-11.38 28.62 28.62 0 00-2.16-11.22 26.57 26.57 0 00-5.93-8.8 27.68 27.68 0 00-19.51-7.9 28.29 28.29 0 00-10.77 2.05 26.19 26.19 0 00-8.71 5.75 27.08 27.08 0 00-5.84 8.8 28.94 28.94 0 00-2.13 11.31zm-194.97-30.5h19.78v73.54h-19.78zm49.25 0h19.78v73.54h-19.78z"></path><circle cx="216.33" cy="21.4" r="12.28"></circle></svg></a><div class="st-Header_communitySelector" tabindex="0"><span class="fa fa-caret-down"></span></div><div class="st-Header_dropdown"><div class="st-Header_dropdownHeading">Qiita Teams that are logged in</div><div class="st-Header_dropdownItemNote">You are not logged in to any team</div><hr class="st-Header_dropdownDivider st-Header_dropdownDivider-shrink"/><a href="https://teams-center.qiita.com/find_team" class="st-Header_dropdownItem"><span class="fa fa-fw fa-sign-in st-Header_dropdownItemIcon"></span><div>Log in to Qiita Team</div></a><div class="st-Header_dropdownDivider"></div><div class="st-Header_dropdownHeading">Community</div><a href="/organizations" class="st-Header_dropdownItem">Organization</a><a href="/official-events/open" class="st-Header_dropdownItem">Event</a><a href="/advent-calendar" class="st-Header_dropdownItem">Advent Calendar</a><a href="https://qiitadon.com/" class="st-Header_dropdownItem" target="_blank">Qiitadon (β)</a><div class="st-Header_dropdownDivider"></div><div class="st-Header_dropdownHeading">Service</div><a href="https://jobs.qiita.com/?utm_source=qiita&amp;utm_medium=referral&amp;utm_content=header" class="st-Header_dropdownItem" target="_blank">Qiita Jobs</a><a href="https://zine.qiita.com/?utm_source=qiita&amp;utm_medium=referral&amp;utm_content=header" class="st-Header_dropdownItem" target="_blank">Qiita Zine</a><a href="https://blog.qiita.com/?utm_source=qiita&amp;utm_medium=referral&amp;utm_content=header" class="st-Header_dropdownItem" target="_blank">Qiita Blog</a></div><form class="st-Header_search" action="/search" method="get"><span class="fa fa-search st-Header_searchIcon"></span><input type="search" class="st-Header_searchInput" autoComplete="off" placeholder="Search" value="" name="q" required=""/></form><form class="st-Header_searchModal" action="/search" method="get"><input type="text" class="st-Header_searchModalInput" autoComplete="off" placeholder="Search" value="" name="q" required=""/></form></div><div class="st-Header_end"><div class="st-Header_searchButton"><span class="fa fa-search"></span></div><a class="st-Header_signupButton" href="/signup?redirect_to=%2Flobin-z0x50%2Fitems%2Ff8421e046d96322250e2">Signup</a><a class="st-Header_loginLink" href="/login?redirect_to=%2Flobin-z0x50%2Fitems%2Ff8421e046d96322250e2">Login</a></div><div class="st-Header_overlay"></div></div></div></div>
      <script type="application/json" class="js-react-on-rails-component" data-component-name="GlobalHeader" data-dom-id="GlobalHeader-react-component-2793ae6b-8636-47bf-973b-752b8b291632">{"unreadNotificationsCount":null,"realms":[{"humanName":"Qiita","isCurrentRealm":true,"isQiita":true,"isQiitaTeam":false,"loggedInUser":null,"teamId":null,"url":"https://qiita.com/"}],"teamFindUrl":"https://teams-center.qiita.com/find_team","isTeamOnlyUser":null,"currentUser":null}</script>
      
</div><div class="st-HeaderAlert st-HeaderAlert-warning"><div class="st-HeaderAlert_body"></div></div><script type="application/ld+json">{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"/","name":"Qiita"}},{"@type":"ListItem","position":2,"item":{"@id":"/tags/csharp","name":"C#"}}]}</script><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","datePublished":"2019-05-03T21:10:04.000+09:00","dateModified":"2019-05-18T18:54:21.000+09:00","headline":"【C# 中級向け】「コンパイル時の型」と「実行時の型」を意識しよう","image":"https://qiita-user-contents.imgix.net/https%3A%2F%2Fcdn.qiita.com%2Fassets%2Fpublic%2Farticle-ogp-background-1150d8b18a7c15795b701a55ae908f94.png?ixlib=rb-4.0.0\u0026w=1200\u0026mark64=aHR0cHM6Ly9xaWl0YS11c2VyLWNvbnRlbnRzLmltZ2l4Lm5ldC9-dGV4dD9peGxpYj1yYi00LjAuMCZ3PTg0MCZoPTM4MCZ0eHQ2ND00NENRUXlNZzVMaXQ1N1NhNVpDUjQ0R1I0NENSNDRDTTQ0S3o0NE96NDRPUjQ0S2s0NE9yNXBtQzQ0R3U1WjZMNDRDTjQ0R280NENNNWE2ZjZLR001cG1DNDRHdTVaNkw0NENONDRLUzVvU1A2SzJZNDRHWDQ0S0k0NEdHJnR4dC1jb2xvcj0lMjMzMzMmdHh0LWZvbnQ9SGlyYWdpbm8lMjBTYW5zJTIwVzYmdHh0LXNpemU9NTQmdHh0LWNsaXA9ZWxsaXBzaXMmdHh0LWFsaWduPWNlbnRlciUyQ21pZGRsZSZzPTQ4OTJjNTdhY2IzZGViZjQyOTNkMTRmN2MwZDY4OTA2\u0026mark-align=center%2Cmiddle\u0026blend64=aHR0cHM6Ly9xaWl0YS11c2VyLWNvbnRlbnRzLmltZ2l4Lm5ldC9-dGV4dD9peGxpYj1yYi00LjAuMCZ3PTg0MCZoPTUwMCZ0eHQ2ND1RR3h2WW1sdUxYb3dlRFV3JnR4dC1jb2xvcj0lMjMzMzMmdHh0LWZvbnQ9SGlyYWdpbm8lMjBTYW5zJTIwVzYmdHh0LXNpemU9NDUmdHh0LWFsaWduPXJpZ2h0JTJDYm90dG9tJnM9ZDA5YzgwM2I4YjJmNDEwYjFjODMzOWRhZjlkNmVmOTc\u0026blend-align=center%2Cmiddle\u0026blend-mode=normal\u0026s=5b257806b1d02ecc5d36673149c2edfb","mainEntityOfPage":"https://qiita.com/lobin-z0x50/items/f8421e046d96322250e2","author":{"@type":"Person","address":"兵庫県明石市","email":"lobin.z0x50@gmail.com","identifier":"lobin-z0x50","name":"lobin-z0x50","image":"https://qiita-user-profile-images.imgix.net/https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F11419109%3Fv%3D4?ixlib=rb-4.0.0\u0026auto=compress%2Cformat\u0026lossless=0\u0026w=75\u0026s=855c34f5fdd094abe9b5241d0799cde7","url":"https://qiita.com/lobin-z0x50","description":"株式会社ネオジニア 代表取締役、ITアーキテクト。\r\n大阪府岸和田市出身。\r\n組み込み開発から業務システム、スマホアプリ、Webまで幅広く開発プロジェクトに従事し、2012年に独立。\r\n従来型のSI開発に限界を感じ、変更に強いソフトウェアを日々研究し、SI業界の改革を夢見ている。\r\nいろんな言語を使うが、メインは Ruby と C#。","memberOf":[{"@type":"Organization","address":"大阪市浪速区元町1-9-9 津和九ビル7F","legalName":"株式会社ネオジニア","image":"https://s3-ap-northeast-1.amazonaws.com/qiita-organization-image/16459a59510f0e07fd263bcf4865d0ec31859b81/original.jpg?1596812707","logo":"https://s3-ap-northeast-1.amazonaws.com/qiita-organization-image/90bb8133c41e36c124364b7566b728fc85e44e2f/original.jpg?1596812707","identifier":"neogenia","description":"大阪のシステム開発会社です！"}]},"publisher":{"@type":"Organization","name":"Qiita","logo":{"@type":"ImageObject","url":"//cdn.qiita.com/assets/public/qiita-logo-c39ded593afa388e2e1ba435b110554e.png"}}}</script><style type="text/css">.wb-CampaignLink {
  background-color: #333333;
  width: 100%;
}

.wb-CampaignLink_container {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  max-width: 1100px;
  margin: 0 auto;
  font-size: 13px;
  padding: 0.8em;
}
.wb-CampaignLink_container > a {
  color: #fff;
}

.wb-CampaignLink_container > a:hover {
  text-decoration: underline;
}</style><div class="wb-CampaignLink"><div class="wb-CampaignLink_container"><a target="_blank" id="header_text_message_1" href="https://increments.connpass.com/event/211948/">Qiita創業者海野氏登壇！Qiita エンジニアフェスタ 2021 Online Meetupを9/9(木)に開催</a><a target="_blank" id="header_text_message_2" href="https://increments.connpass.com/event/211948/">詳しくはこちら</a></div><script>td.trackEvent(
  'front_events',
  {"query_parameters":{},"path_parameters":{"controller":"public/items","action":"show","user_id":"lobin-z0x50","type":"items","id":"f8421e046d96322250e2"},"user_id":null,"event_category":"Header Text Ads Banner","event_action":"Show","data":{"message":"Qiita創業者海野氏登壇！Qiita エンジニアフェスタ 2021 Online Meetupを9/9(木)に開催","url":"https://increments.connpass.com/event/211948/","sub_message":"詳しくはこちら"}}
)</script><script>document.getElementById('header_text_message_1').addEventListener('click', function() {
  td.trackEvent(
    'front_events',
    {"query_parameters":{},"path_parameters":{"controller":"public/items","action":"show","user_id":"lobin-z0x50","type":"items","id":"f8421e046d96322250e2"},"user_id":null,"event_category":"Header Text Ads Banner","event_action":"Click","data":{"index":1,"pos_id":"header_text_message_1","message":"Qiita創業者海野氏登壇！Qiita エンジニアフェスタ 2021 Online Meetupを9/9(木)に開催","url":"https://increments.connpass.com/event/211948/","sub_message":"詳しくはこちら"}}
  )
})</script><script>document.getElementById('header_text_message_2').addEventListener('click', function() {
  td.trackEvent(
    'front_events',
    {"query_parameters":{},"path_parameters":{"controller":"public/items","action":"show","user_id":"lobin-z0x50","type":"items","id":"f8421e046d96322250e2"},"user_id":null,"event_category":"Header Text Ads Banner","event_action":"Click","data":{"index":1,"pos_id":"header_text_message_2","message":"Qiita創業者海野氏登壇！Qiita エンジニアフェスタ 2021 Online Meetupを9/9(木)に開催","url":"https://increments.connpass.com/event/211948/","sub_message":"詳しくはこちら"}}
  )
})</script></div><script type="application/json" id="js-react-on-rails-context">{"railsEnv":"production","inMailer":false,"i18nLocale":"en","i18nDefaultLocale":"en","href":"https://qiita.com/lobin-z0x50/items/f8421e046d96322250e2","location":"/lobin-z0x50/items/f8421e046d96322250e2","scheme":"https","host":"qiita.com","port":null,"pathname":"/lobin-z0x50/items/f8421e046d96322250e2","search":null,"httpAcceptLanguage":null,"actionPath":"public/items#show","settings":{"analyticsTrackingId":"UA-24675221-12","assetsMap":{},"csrfToken":"C+F2sUqlgYpMRWYsg6a8/PIw9A5E5LZITJlk4CF4Tnz5qiYIFAe01cyy2p6moBb2stx6rpVAKcWtx59GplKstQ==","locale":"en"},"currentUser":null,"isLoggedIn":false,"recaptchaSiteKey":"6LfNkiQTAAAAAM3UGnSquBy2akTITGNMO_QDxMw6","serverSide":false}</script>
<div id="PersonalArticlePage-react-component-ba9f60af-dffe-4b78-b5e2-5fa3c94077b9"><div class="p-items_wrapper"><div class=" css-17jxvjw"><div class="css-11t2ec1"><div class="css-1dvr2p8"><button class=" css-18lkoru"><svg size="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 392.81 429" color="#55C500" class="css-1g4cku8 e31pr5q0"><path d="M14.19 5.4h53.86v149.45h90.05v44.87H14.19zM288.4 93.77h100.79q1.29 25-5.66 45.39a96.79 96.79 0 01-20.33 34.89 92 92 0 01-32.13 22.45 104 104 0 01-40.95 7.93 109.71 109.71 0 01-76-29.92 104.05 104.05 0 01-23-32.56 95.46 95.46 0 01-8.47-39.88 94.78 94.78 0 018.47-39.87 104.38 104.38 0 0123-32.42A107.71 107.71 0 01248.23 8a110.79 110.79 0 01118.48 22.49l-35.07 35.08a51.25 51.25 0 00-17.75-15 52.83 52.83 0 00-44.67-1.23 52.92 52.92 0 00-17 12 57.07 57.07 0 00-11.45 18.11 60 60 0 00-4.23 22.77 60 60 0 004.23 22.68 56.57 56.57 0 0011.45 18.19 52.62 52.62 0 0017 12 50.5 50.5 0 0020.9 4.36q20.19 0 31.07-7.51a35.75 35.75 0 0014.46-20.55h-47.39zM51.29 279.55H0v-44.86h156v44.86h-51.13V429H51.29zM283.36 381.71l-41.72-62V429h-53.86V234.69h47.47L290 312l55.9-77.29h46.9V429h-53.86V320.27l-42.43 61.44z"></path></svg></button><a href="/lobin-z0x50/items/f8421e046d96322250e2/likers" class="css-1iupg5d">13</a></div><div class="css-ijvq0v"><button class=" css-15cocm3"><svg size="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 353.02 398" color="#6E6F70" class="css-12rp90f e11v00bf0"><path d="M176.72 398c-67.52 0-130.16-29-171.84-79.69l-4.46-5.42V78.05H353v234.84l-4.45 5.42C306.88 369 244.24 398 176.72 398zm-137.2-99.34c34.17 38.37 83.78 60.25 137.2 60.25s103-21.88 137.21-60.25V117.14H39.52zM0 0h351.12v40.94H0z"></path></svg></button><span class="css-115f4t">16</span></div><div class="css-1b8uj5v"><span class="fa fa-twitter"></span></div><div class="css-1b8uj5v"><span class="fa fa-facebook"></span></div><div class="css-79elbk"><button class="css-16hhh7b"><i class="fa fa-ellipsis-h"></i></button><div class="css-fcbn8c"><div class="css-1gj7nt">Improve article</div><a href="/drafts/f8421e046d96322250e2/edit" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-code-fork css-1jqivyb" aria-hidden="true"></i></span>Send edit request</a><div class="css-1ode1bp"></div><div class="css-1gj7nt">Article information</div><a href="/lobin-z0x50/items/f8421e046d96322250e2/revisions" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-history css-1jqivyb" aria-hidden="true"></i></span>Revisions</a><a href="/lobin-z0x50/items/f8421e046d96322250e2/patches" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-inbox css-1jqivyb" aria-hidden="true"></i></span>Edit Requests</a><a href="/lobin-z0x50/items/f8421e046d96322250e2/likers" class="css-154zy0m"><span class="css-yikrym"><svg size="13" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 392.81 429" color="rgba(0, 0, 0, 0.6)" class="css-le4d8r e31pr5q0"><path d="M14.19 5.4h53.86v149.45h90.05v44.87H14.19zM288.4 93.77h100.79q1.29 25-5.66 45.39a96.79 96.79 0 01-20.33 34.89 92 92 0 01-32.13 22.45 104 104 0 01-40.95 7.93 109.71 109.71 0 01-76-29.92 104.05 104.05 0 01-23-32.56 95.46 95.46 0 01-8.47-39.88 94.78 94.78 0 018.47-39.87 104.38 104.38 0 0123-32.42A107.71 107.71 0 01248.23 8a110.79 110.79 0 01118.48 22.49l-35.07 35.08a51.25 51.25 0 00-17.75-15 52.83 52.83 0 00-44.67-1.23 52.92 52.92 0 00-17 12 57.07 57.07 0 00-11.45 18.11 60 60 0 00-4.23 22.77 60 60 0 004.23 22.68 56.57 56.57 0 0011.45 18.19 52.62 52.62 0 0017 12 50.5 50.5 0 0020.9 4.36q20.19 0 31.07-7.51a35.75 35.75 0 0014.46-20.55h-47.39zM51.29 279.55H0v-44.86h156v44.86h-51.13V429H51.29zM283.36 381.71l-41.72-62V429h-53.86V234.69h47.47L290 312l55.9-77.29h46.9V429h-53.86V320.27l-42.43 61.44z"></path></svg></span>Show all likers</a><a href="/lobin-z0x50/items/f8421e046d96322250e2.md" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-file-text-o css-1jqivyb" aria-hidden="true"></i></span>Show article in Markdown</a><div class="css-1ode1bp"></div><div class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-flag css-1jqivyb" aria-hidden="true"></i></span>Report article</div></div><div class="st-Modal"><div class="st-Modal_backdrop"></div><div class="st-Modal_body"><form><div class="st-Form"><span class="st-Form_label">Help us understand the problem. What is going on with this article?</span></div><div class="st-Form"><label><input type="radio" name="reason" value="illegal" required=""/>It&#x27;s illegal (copyright infringement, privacy infringement, libel, etc.)</label></div><div class="st-Form"><label><input type="radio" name="reason" value="inappropriate_content" required=""/>It&#x27;s socially inappropriate (offensive to public order and morals)</label></div><div class="st-Form"><label><input type="radio" name="reason" value="advertising" required=""/>It&#x27;s advertising</label></div><div class="st-Form"><label><input type="radio" name="reason" value="spam" required=""/>It&#x27;s spam</label></div><div class="st-Form"><label><input type="radio" name="reason" value="guideline_violation" required=""/>Other than the above, but not suitable for the Qiita community (violation of guidelines)</label></div><div class="st-Form st-Form-right"><input type="submit" class="st-Form_submit" value="Submit"/></div></form></div></div></div></div><div class="p-items_options"><div class="mt-2"><div class="css-1hbd3g7"></div></div></div><div class="p-items_toc"><div class="mt-2"><div class="css-1hbd3g7"></div></div></div><div class="p-items_main"><div class="css-1nzh4zz"><span class="fa fa-fw fa-warning css-38fzdi"></span><p>More than 1 year has passed since last update.</p></div><div class="css-helsa7"><div class="css-8qb8m4"><div class="css-2imjyh"><div class="css-he5w1s"><div class="css-70qvj9"><div class="css-3ojehk"><a href="/lobin-z0x50"><img class="css-100alwu eyfquo10" src="https://avatars0.githubusercontent.com/u/11419109?v=4" width="24" height="24" loading="lazy"/></a></div><div class="css-1dtnjt5"><a href="/lobin-z0x50" class="css-10ougpm">@<!-- -->lobin-z0x50</a><div class="css-1ay9vb9"><span><meta content="2019-05-03T12:10:04Z"/><time dateTime="2019-05-18T09:54:21Z" class="css-m19uds">updated at 2019-05-18</time></span></div></div></div></div></div><h1 class="css-cgzq40">【C# 中級向け】「コンパイル時の型」と「実行時の型」を意識しよう</h1><div class="css-1wa99t2"><span class="fa fa-tags mr-1of2 css-1l3zk9f" aria-hidden="true"></span><a href="/tags/csharp" class="css-4czcte">C#</a><a href="/tags/%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e6%8c%87%e5%90%91" class="css-4czcte">オブジェクト指向</a><a href="/tags/%e5%9e%8b" class="css-4czcte">型</a><a href="/tags/%e3%82%aa%e3%83%bc%e3%83%90%e3%83%bc%e3%83%a9%e3%82%a4%e3%83%89" class="css-4czcte">オーバーライド</a><a href="/tags/%e3%82%aa%e3%83%bc%e3%83%90%e3%83%bc%e3%83%ad%e3%83%bc%e3%83%89" class="css-4czcte">オーバーロード</a></div></div><section class="it-MdContent"><div id="personal-public-article-body"><div>
<h1>
<span id="はじめに" class="fragment"></span><a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB"><i class="fa fa-link"></i></a>はじめに</h1>

<p>この記事では、C# における <strong>コンパイル時の型</strong> と <strong>実行時の型</strong> について説明する。また関連する概念としてオーバーライドとオーバーロードの違い、演算子とメソッドで呼び出し対象の決定タイミングの違いについて簡単に説明する。</p>

<p>対象とする読者層は、C#プログラミング歴1年以上、中級者向け。</p>

<p>特に SIer やユーザー企業に所属（もしくは常駐）し、特に複数人チームでの開発に携わる若手プログラマ（俗に言う"IT土方"）に向けて、よくある <strong>ハマりポイント</strong> について分かりやすいように書いているつもり。</p>

<p>対象としている .NET のバージョンは 4.0 以降、もちろん .NET Core も対象だ。</p>

<h1>
<span id="クイズ" class="fragment"></span><a href="#%E3%82%AF%E3%82%A4%E3%82%BA"><i class="fa fa-link"></i></a>クイズ</h1>

<p>まず始めに、このコードの実行結果がどうなるか、考えてみてほしい。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">例1</span></div>
<div class="highlight"><pre class="with-code"><code><span class="kt">object</span> <span class="n">x</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="kt">object</span> <span class="n">y</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">x</span> <span class="p">==</span> <span class="n">y</span> <span class="p">?</span> <span class="s">"OK"</span> <span class="p">:</span> <span class="s">"NG"</span><span class="p">);</span>
</code></pre></div>
</div>

<p>出力結果は、以下の通り。（実際にIdeoneで試したい人は <a href="https://ideone.com/AlufFU" rel="nofollow noopener" target="_blank">こちら</a> ）</p>

<div class="code-frame" data-lang="">
<div class="code-lang"><span class="bold">例1の出力結果</span></div>
<div class="highlight"><pre class="with-code"><code>NG
</code></pre></div>
</div>

<p>なぜこうなるのか、あなたは正確に説明できるだろうか？</p>

<p>三項演算子がおかしいとか、記載されていないコードがあって変数が書き換えられているとか、そういう話ではない。</p>

<p>このコードの <code>x == y</code> の判定は、間違いなく偽になっており、そしてそれは言語仕様通りだ。</p>

<h2>
<span id="ヒント" class="fragment"></span><a href="#%E3%83%92%E3%83%B3%E3%83%88"><i class="fa fa-link"></i></a>ヒント</h2>

<p>以下のように書き換えると結果が変わる。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">例2</span></div>
<div class="highlight"><pre class="with-code"><code><span class="kt">object</span> <span class="n">x</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="kt">object</span> <span class="n">y</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">?</span> <span class="s">"OK"</span> <span class="p">:</span> <span class="s">"NG"</span><span class="p">);</span>  <span class="c1">// OK</span>
</code></pre></div>
</div>

<p><code>==</code> の代わりに <code>Equals()</code> を使うと結果が変わる。</p>

<p>面白いのは、次の例だ。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">例3</span></div>
<div class="highlight"><pre class="with-code"><code><span class="kt">dynamic</span> <span class="n">x</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="kt">dynamic</span> <span class="n">y</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">x</span> <span class="p">==</span> <span class="n">y</span> <span class="p">?</span> <span class="s">"OK"</span> <span class="p">:</span> <span class="s">"NG"</span><span class="p">);</span>  <span class="c1">// OK</span>
</code></pre></div>
</div>

<p>例1と違うのは、変数の型が <code>object</code> ではなく <code>dynamic</code> になっているという点だ。</p>

<p>なぜこのような結果になるのか、ちゃんと説明できる人はどれぐらいいるだろうか？</p>

<p>理解のポイントは、型の解釈のタイミングだ。</p>

<p>実は C# では <strong>コンパイル時の型</strong> と <strong>実行時の型</strong> という２種類の解釈があるのだ。</p>

<h1>
<span id="解説" class="fragment"></span><a href="#%E8%A7%A3%E8%AA%AC"><i class="fa fa-link"></i></a>解説</h1>

<p>例示したコードに於いて、出力が <code>"NG"</code> になるケースでは <code>object</code> クラスの <code>==</code> 演算子が呼び出されているためだ。<br>
特に C# では <code>string</code> の比較に <code>==</code> を使うのが一般的であるため、以下のような直感的でない挙動になる場合について知っておく必要がある。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">よくあるハマりケース</span></div>
<div class="highlight"><pre class="with-code"><code><span class="kt">object</span> <span class="n">expected</span> <span class="p">=</span> <span class="s">"1"</span><span class="p">;</span>
<span class="kt">object</span> <span class="n">obj</span> <span class="p">=</span> <span class="m">1.</span><span class="nf">ToString</span><span class="p">();</span>

<span class="c1">// 注意が必要なパターン</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">obj</span> <span class="p">==</span> <span class="n">expected</span><span class="p">);</span>  <span class="c1">// False</span>

<span class="c1">// こう書くとコンパイラの警告が出るので気が付く</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">obj</span> <span class="p">==</span> <span class="s">"1"</span><span class="p">);</span>  <span class="c1">// False</span>

<span class="c1">// 以下は大丈夫なケース</span>
<span class="kt">string</span> <span class="n">str</span> <span class="p">=</span> <span class="m">1.</span><span class="nf">ToString</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">str</span> <span class="p">==</span> <span class="s">"1"</span><span class="p">);</span>  <span class="c1">// True</span>
</code></pre></div>
</div>

<p>実務でもたまに遭遇する <strong>ハマりポイント</strong> でもある<sup id="fnref1"><a href="#fn1" title='ちなみに 1.ToString() としているのは、単純に "1" と書くと。'>1</a></sup>。</p>

<p>もしちゃんと理解できていないと思うなら、この機会に是非マスターしてほしい。</p>

<p>ハマらないためには、以下のように <code>object.Equals()</code> を使って比較することだ。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">これが正解</span></div>
<div class="highlight"><pre class="with-code"><code><span class="kt">object</span> <span class="n">x</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="kt">object</span> <span class="n">y</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="kt">object</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>  <span class="c1">// True     </span>
</code></pre></div>
</div>

<p>また、自作クラスで演算子をオーバーロードした時にも注意が必要だ。つまり、どのクラスの演算子が呼び出されるかは、実行時の型ではなく、<strong>コンパイル時の型によって決定</strong> される。</p>

<p>C# では、演算子のオーバーライドが出来ないようになっており、演算子をオーバーロードする際は <code>static</code> として宣言しなくてはならず、<code>virtual</code> 指定することも出来ない。従って演算子は実行時の型による動的ディスパッチ<sup id="fnref2"><a href="#fn2" title="ディスパッチ: 複数の関数の中から一定の規則によって呼び出すべき関数を引き当てて呼び出すこと">2</a></sup>が出来ない（ただし <code>dynamic</code> を使えば可能。後述）。</p>

<p>そもそも C# の世界に「演算子のオーバーライド」という概念はない。あるのは「メソッドの <strong>オーバーライド</strong> 」と「演算子の <strong>オーバーロード</strong> 」だ<sup id="fnref3"><a href="#fn3" title="もちろん「メソッドのオーバーロード」もある。ところで他のプログラミング言語では、演算子をオーバーライド可能なものもある。例えば Ruby では演算子は一般的なメソッド呼び出しの糖衣構文という言語仕様になっているため、オーバーライド可能だ。">3</a></sup>。</p>

<p>まずはその辺からキッチリ理解していこう。</p>

<h2>
<span id="オーバーライドとオーバーロードの違い" class="fragment"></span><a href="#%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89%E3%81%A8%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89%E3%81%AE%E9%81%95%E3%81%84"><i class="fa fa-link"></i></a>オーバーライドとオーバーロードの違い</h2>

<p>一応、オーバーライドとオーバーロードの違いをザックリおさらい。</p>

<h3>
<span id="オーバーロード" class="fragment"></span><a href="#%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89"><i class="fa fa-link"></i></a>オーバーロード</h3>

<p>オーバーロード (overload) とは、「 <strong>多重定義</strong> 」のことだ。メソッド名が同じで引数リストが異なるメソッドを作ることだ。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">オーバーロードの例</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">void</span> <span class="nf">Exec</span><span class="p">(</span><span class="kt">string</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// 同じ名前で引数の異なるバージョンを多重に定義。これがオーバーロード</span>
<span class="k">void</span> <span class="nf">Exec</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nf">Exec</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>
</div>

<p>このように同じ名前のメソッドを多重に定義することを「オーバーロード」と言う。<br>
処理は同じだが引数のバリエーションを増やして使い勝手を良くするような場合に多用される。</p>

<p>オーバーロードされたメソッドのうちどれを呼び出すかは、コンパイル時に決定される。</p>

<p>大事なことなので２回言います。</p>

<p><strong>オーバーロードされたメソッドのうちどれを呼び出すかは、コンパイル時に決定される。実行時に決定されるのではない。</strong></p>

<p>当たり前のことを言っているように聞こえるかもしれないが、こういうことを意識しながらプログラミングすることがとても大切だ。これが出来るようになると、確実にレベルアップしていると言える。</p>

<h3>
<span id="オーバーライド" class="fragment"></span><a href="#%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89"><i class="fa fa-link"></i></a>オーバーライド</h3>

<p>一方オーバーライド (override) は、クラス継承の際にメソッド名も引数リストも全く同じメソッドを定義し、基底クラスのメソッドを「 <strong>上書き</strong> 」することを指す。</p>

<p>C# では、<code>virtual</code> と <code>override</code> キーワードを用いる必要がある。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">オーバーライドの例</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">class</span> <span class="nc">ClassA</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">Exec</span><span class="p">(</span><span class="kt">string</span> <span class="n">arg</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ClassA を継承したクラス</span>
<span class="k">class</span> <span class="nc">ClassB</span> <span class="p">:</span> <span class="n">ClassA</span>
<span class="p">{</span>
    <span class="c1">// 基底クラスのメソッドを上書き。これがオーバーライド</span>
    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Exec</span><span class="p">(</span><span class="kt">string</span> <span class="n">arg</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>

<p>コンパイラは、<code>virtual</code> 指定されたメソッドの呼び出しがあると、コンパイル段階ではどのクラスのメソッドが呼び出されるか決定されない。というか決定することが出来ない。<strong>実行時でないとどの型なのか分からない</strong> ためだ。</p>

<div class="code-frame" data-lang="cs"><div class="highlight"><pre class="with-code"><code><span class="n">ClassA</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">GetInstance</span><span class="p">();</span>
<span class="n">c</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>   <span class="c1">// cはClassBのインスタンスかもしれない。コンパイル時には分からない。</span>
</code></pre></div></div>

<p><strong>オーバーライドされたメソッドのうちどれを呼び出すかは、実行時に決定される。</strong></p>

<p>コンパイル時に決定されることを「静的」、実行時に決定されることを「動的」と呼ぶ。</p>

<p>そして、実行時にメソッドが決定されることを「動的ディスパッチ」と呼ぶ。</p>

<h3>
<span id="virtual-指定がないメソッドのオーバーライド" class="fragment"></span><a href="#virtual-%E6%8C%87%E5%AE%9A%E3%81%8C%E3%81%AA%E3%81%84%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89"><i class="fa fa-link"></i></a>virtual 指定がないメソッドのオーバーライド</h3>

<p>ところで、<code>virtual</code> 指定がないメソッドに対してサブクラスで「上書き」しようとすると、<code>new</code> を付けると上書き可能になるが、実際それを試してみるとオーバーライドではなく、再定義になる。</p>

<p>従って、変数の型でどのメソッドを呼び出すかが決定される。</p>

<p>例: <code>new</code> で再定義すると変数の型（コンパイル時の型）で呼び出すメソッドが決まる。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">newで再定義した場合</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">class</span> <span class="nc">ClassA</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Exec</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ClassA を継承したクラス</span>
<span class="k">class</span> <span class="nc">ClassB</span> <span class="p">:</span> <span class="n">ClassA</span>
<span class="p">{</span>
    <span class="c1">// 基底クラスのメソッドをオーバーライド？ではなく再定義になる</span>
    <span class="k">public</span> <span class="k">new</span> <span class="k">void</span> <span class="nf">Exec</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"B"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ClassB</span> <span class="n">b</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ClassB</span><span class="p">();</span>
        <span class="n">b</span><span class="p">.</span><span class="nf">Exec</span><span class="p">();</span>  <span class="c1">// B</span>

        <span class="n">ClassA</span> <span class="n">c</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">c</span><span class="p">.</span><span class="nf">Exec</span><span class="p">();</span>  <span class="c1">// A  &lt;= 値の型は ClassB であるが、変数の型が ClassA であるため</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>

<p>このように、C#では <code>virtual</code> 指定がないメソッドをオーバーライドすることは物理的に不可能だ。理由は <code>virtual</code> 指定をしないと、実行時に動的ディスパッチするために必要な「仮想関数テーブル<sup id="fnref4"><a href="#fn4" title="仮想関数テーブル (V-Table) とは C++ から導入された、コンパイル結果に含められる内部データのことで、クラスの継承ツリーをたどってオーバーライドされたメソッドを実行時に引き当てる仕組みのためのものだ。通常、プログラマが意識する必要はない。オーバライドされていようがされていまいが、メソッド呼び出し時には仮想関数テーブルの処理が行われるため、負荷が生じる。この負荷を避けるためにデフォルトでは仮想関数テーブルが作られず、オーバライドするためには virtual 指定が明示的に必要という言語仕様を採用している。これは C++ から C# にそのまま引き継がれた考え方だ。">4</a></sup>」という内部データが作られないためだ。</p>

<h3>
<span id="演算子のオーバーロード" class="fragment"></span><a href="#%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89"><i class="fa fa-link"></i></a>演算子のオーバーロード</h3>

<p>さてそろそろ本題の演算子のオーバーロードの話に入ろう。</p>

<p>まずは演算子のオーバーロードの例を見てみよう。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">演算子のオーバーロード</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">class</span> <span class="nc">ClassA</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Value1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// コンストラクタ</span>
    <span class="k">public</span> <span class="nf">ClassA</span><span class="p">(</span><span class="kt">string</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">Value1</span> <span class="p">=</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// == 演算子を定義</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span><span class="p">==(</span><span class="n">ClassA</span> <span class="n">self</span><span class="p">,</span> <span class="n">ClassA</span> <span class="n">other</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">Value1</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">Value1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// == を定義するためには != もペアで定義が必要</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span><span class="p">!=(</span><span class="n">ClassA</span> <span class="n">self</span><span class="p">,</span> <span class="n">ClassA</span> <span class="n">other</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">!(</span><span class="n">self</span> <span class="p">==</span> <span class="n">other</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>

<p>このようになる。</p>

<p>ここでは <code>operator==()</code> を１つしか定義していないが、それでも「演算子をオーバーロードしている」状態になる。</p>

<p>なお、<code>operator!=()</code> の定義も必要なのは C# の仕様だ。中身は <code>==</code> の否定をとるだけでオッケーで、これが定石だ。これでコンパイルが通るが、実務で <code>==</code> をオーバーロードするのは注意が必要だ。多くの場合、<code>Equals()</code> をオーバーライドするのが適切だ。ここでは例示のための実験的なコードとして捉えておいてほしい<sup id="fnref5"><a href="#fn5" title="ここでは本筋とはズレるので詳細説明は省略するが == をオーバーライドする場合は無限ループに陥りやすいので注意が必要だ。また Equals() と GetHashCode() もオーバライドしておくべきだ。詳しくはMSDN Equals() と演算子 == のオーバーロードに関するガイドライン (C# プログラミング ガイド) および 方法: 型の値の等価性を定義する などを参照のこと。より実践的な実装例は ここ が一番分かりやすいと思います。">5</a></sup>。</p>

<p>ではこれを継承したクラスを作り、<strong>オーバーライド</strong> してみよう。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">演算子のオーバーライド？</span></div>
<div class="highlight"><pre class="with-code"><code><span class="c1">// ClassA を継承したクラス</span>
<span class="k">class</span> <span class="nc">ClassB</span> <span class="p">:</span> <span class="n">ClassA</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value2</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">ClassB</span><span class="p">(</span><span class="kt">string</span> <span class="n">val1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val2</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">val1</span><span class="p">)</span> <span class="p">{</span> <span class="n">Value2</span> <span class="p">=</span> <span class="n">val2</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// == をオーバーライド？（実は出来ていない）</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span><span class="p">==(</span><span class="n">ClassB</span> <span class="n">self</span><span class="p">,</span> <span class="n">ClassB</span> <span class="n">other</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">Value1</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">Value1</span> <span class="p">&amp;&amp;</span> <span class="n">self</span><span class="p">.</span><span class="n">Value2</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">Value2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// == を定義するためには != もペアで定義が必要</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span><span class="p">!=(</span><span class="n">ClassB</span> <span class="n">self</span><span class="p">,</span> <span class="n">ClassB</span> <span class="n">other</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">!(</span><span class="n">self</span> <span class="p">==</span> <span class="n">other</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>

<p>試しに上記クラスを利用するコードを書いて確かめてみよう。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">オーバーライド？した演算子を呼び出す</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ClassA のインスタンスを比較</span>
        <span class="kt">var</span> <span class="n">a1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ClassA</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">a2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ClassA</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>

        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">a1</span> <span class="p">==</span> <span class="n">a2</span><span class="p">);</span>  <span class="c1">// True</span>

        <span class="c1">// ClassB のインスタンスを比較</span>
        <span class="kt">var</span> <span class="n">b1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ClassB</span><span class="p">(</span><span class="s">"1"</span><span class="p">,</span> <span class="m">10</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">b2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ClassB</span><span class="p">(</span><span class="s">"1"</span><span class="p">,</span> <span class="m">20</span><span class="p">);</span>

        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">b1</span> <span class="p">==</span> <span class="n">b2</span><span class="p">);</span>  <span class="c1">// False  &lt;= Value2 の値が異なるので False</span>

        <span class="c1">// ClassA 型の変数に代入（キャスト）</span>
        <span class="n">ClassA</span> <span class="n">c1</span> <span class="p">=</span> <span class="n">b1</span><span class="p">;</span>
        <span class="n">ClassA</span> <span class="n">c2</span> <span class="p">=</span> <span class="n">b2</span><span class="p">;</span>

        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">c1</span> <span class="p">==</span> <span class="n">c2</span><span class="p">);</span>  <span class="c1">// True  &lt;= ここで、ClassAの==演算子が呼ばれている</span>

        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">c1</span><span class="p">.</span><span class="nf">GetType</span><span class="p">().</span><span class="n">Name</span><span class="p">}</span><span class="s">, </span><span class="p">{</span><span class="n">c2</span><span class="p">.</span><span class="nf">GetType</span><span class="p">().</span><span class="n">Name</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>  <span class="c1">// ClassB, ClassB  &lt;= 実体はどちらもClassB</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>

<p>案の定、これでは想定どおりに動かない。<code>static</code> だし、<code>virtual</code> 指定ができないし、基底クラスの <code>==</code> とは引数リストも異なるので、全くオーバーライドになっていない。完全に異なる別々のメソッドになっている。<a href="https://ideone.com/sDj64l" rel="nofollow noopener" target="_blank">Ideoneにコードを置いてあるので実際に試してみよう</a>。</p>

<p>「解説」で説明したとおり、C# では <strong>演算子をオーバーライドすることは出来ない</strong> のだ。<sup id="fnref6"><a href="#fn6" title="C# の static メソッドは、インスタンスに所属しておらず、そのクラスに名前空間的に配置される孤立したメソッドというような捉え方をすべきだ。演算子のオーバーロードを static で書くルールになっている以上、どうあがいてもオーバーライドすることは出来ない。">6</a></sup></p>

<h2>
<span id="コンパイル時の型と実行時の型" class="fragment"></span><a href="#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E6%99%82%E3%81%AE%E5%9E%8B%E3%81%A8%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AE%E5%9E%8B"><i class="fa fa-link"></i></a>コンパイル時の型と実行時の型</h2>

<p>これまで見てきたように、C# ではコンパイル時の型と実行時の型を区別して認識する必要がある。<br>
コンパイル時の型とは、言い換えると <strong>変数の型</strong> のことで、実行時の型とは、<strong>値の型</strong> （実体）のことだ。</p>

<p>では、演算子は必ずコンパイル時の型で評価されるのかというと、実は実行時に評価させる方法がある。</p>

<h3>
<span id="ジェネリックを使う場合" class="fragment"></span><a href="#%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%83%83%E3%82%AF%E3%82%92%E4%BD%BF%E3%81%86%E5%A0%B4%E5%90%88"><i class="fa fa-link"></i></a>ジェネリックを使う場合</h3>

<p>クラスやメソッドにジェネリックを使って任意の型に適用出来るようにした場合、実行時の型で評価されるように期待するかもしれないが、 <strong>そうはならない</strong> 。基本的にはコンパイル時の型で解決されるが、<code>where</code> 制約を付けない限り、<code>object</code> クラスの <code>==</code> を呼ぶようコンパイルされる。</p>

<p>先程の演算子オーバロードの説明で用いたコードを使って、ジェネリックを試してみよう。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">例4(ジェネリックを使う場合)</span></div>
<div class="highlight"><pre class="with-code"><code><span class="c1">// コンパイルエラー。whereなしではジェネリック型に演算子を適用できない。</span>
<span class="c1">//static void f&lt;T&gt;(T x, T y) {</span>
<span class="c1">//  Console.WriteLine(x == y ? "OK" : "NG");</span>
<span class="c1">//}</span>

<span class="c1">// where で参照型だけに制限すれば演算子が使えるが、object.== が呼ばれる</span>
<span class="k">static</span> <span class="k">void</span> <span class="n">f</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="k">class</span> <span class="err">{</span>
  <span class="nc">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">x</span> <span class="p">==</span> <span class="n">y</span> <span class="p">?</span> <span class="s">"OK"</span> <span class="p">:</span> <span class="s">"NG"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 明示的に ClassA に制約すれば、そのクラスの == が呼ばれる</span>
<span class="k">static</span> <span class="k">void</span> <span class="n">g</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">ClassA</span> <span class="p">{</span>
  <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">x</span> <span class="p">==</span> <span class="n">y</span> <span class="p">?</span> <span class="s">"OK"</span> <span class="p">:</span> <span class="s">"NG"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">x</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ClassA</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">y</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ClassA</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>

<span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>  <span class="c1">// NG  &lt;= objectクラスの == を呼ぶようコンパイルされるため</span>

<span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>  <span class="c1">// OK</span>
</code></pre></div>
</div>

<p>特性をまとめると以下のようになる。</p>

<ul>
<li>基本的には <code>where T: class</code> を付けないと、演算子は使えない。</li>
<li>付けたとしても、コンパイル時の <code>T</code> の型の演算子が呼ばれるわけではなく、 <code>object</code> の演算子が呼ばれる<sup id="fnref7"><a href="#fn7" title="C++のテンプレートのように型ごとにメソッドが作られてコンパイルされる訳ではないため。">7</a></sup>。</li>
<li>
<code>where T: ClassA</code> というように明示的に型制約をつけると、その型の演算子を呼ぶようになる。</li>
</ul>

<p>このように、ジェネリック型に対して演算子を使う場合は注意が必要だ。</p>

<h3>
<span id="dynamic-を使う場合" class="fragment"></span><a href="#dynamic-%E3%82%92%E4%BD%BF%E3%81%86%E5%A0%B4%E5%90%88"><i class="fa fa-link"></i></a>dynamic を使う場合</h3>

<p>C# の <code>dynamic</code> は実行時に該当する型を判別して動的にコードを生成してくれる凄い仕組みだ。<br>
ダックタイピングのような機能を提供する。</p>

<p><code>dynamic</code> として宣言された変数はその名前のごとく動的（つまりコンパイル時ではなく実行時）に、型が解決される<sup id="fnref8"><a href="#fn8" title="実行時に型を解決する仕組みとして、実行時にコード生成してコンパイルして実行しているような仕組みになっている。コンパイル結果に動的コード生成のためのコードが含まれるようになるためバイナリサイズが大きくなるし、初回実行時にそれなりのオーバヘッドがかかる。">8</a></sup>。実行時というか、なので、例3の場合だと <code>int</code> 型で実行時にコード展開され、実行される。</p>

<p>デメリットとして、コンパイル時に型情報が一切ないので、インテリセンスも利かないし、何より静的型付け言語の最大のメリット「タイプセーフ」でなくなってしまう。<br>
乱用は禁物だ<sup id="fnref9"><a href="#fn9" title="例えば Dictionary&lt;string, object&gt; を使って文字列をキーにした連想配列で大きなデータ構造を扱うようなコードを書くぐらいなら、そもそもタイプセーフもクソもないので、ExpandoObject を使う方がよっぽどマシかもしれない。">9</a></sup>。<br>
ここではこれ以上の詳細な説明は省略するが、興味があれば調べてみると良いだろう。</p>

<p>先程のジェネリックの例を <code>dynamic</code> で書き換えると以下のようになる。</p>

<div class="code-frame" data-lang="cs">
<div class="code-lang"><span class="bold">例5(dynamicを使う場合)</span></div>
<div class="highlight"><pre class="with-code"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">h</span><span class="p">(</span><span class="kt">dynamic</span> <span class="n">x</span><span class="p">,</span> <span class="kt">dynamic</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">x</span> <span class="p">==</span> <span class="n">y</span> <span class="p">?</span> <span class="s">"OK"</span> <span class="p">:</span> <span class="s">"NG"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">object</span> <span class="n">x</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ClassA</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
<span class="kt">object</span> <span class="n">y</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ClassA</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>

<span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>  <span class="c1">// OK</span>
</code></pre></div>
</div>

<p>ただし、実務でこのような <code>dynamic</code> の使い方をしてはいけない。<br>
正しくは「解説」で示したように、<code>object.Equals()</code> を使うべきだ。</p>

<p><a href="https://ideone.com/Ot2Amn" rel="nofollow noopener" target="_blank">上記ジェネリックと<code>dynamic</code>のコードサンプルを Ideone に置いてあります</a></p>

<h1>
<span id="まとめ" class="fragment"></span><a href="#%E3%81%BE%E3%81%A8%E3%82%81"><i class="fa fa-link"></i></a>まとめ</h1>

<p>「コンパイル時の型」と「実行時の型」という２つの解釈があることを認識しよう。</p>

<ul>
<li>オーバーライドされたメソッドは、実行時の型でディスパッチされる</li>
<li>オーバーロードされたメソッドは（演算子に限らず全て）、コンパイル時の型でディスパッチされる</li>
<li>ただし <code>dynamic</code> を使った場合は実行時にコンパイルされるため、オーバーロードされたメソッドでも実行時の型でディスパッチされることになる</li>
</ul>

<p>３つ目はエンタープライズ開発の現場ではほとんどお目にかかる事はないと思うので、例外的パターンぐらいの捉え方で十分と思う。</p>

<p>Java と比較すると、C# では文字列の比較にも <code>==</code> が使えるため、普段から <code>Equal()</code> メソッドを使うことはとても少ないと思われる<sup id="fnref10"><a href="#fn10" title="例えば Java では演算子のオーバーロードが言語仕様として存在せず、== は単にリファレンスの比較（ポインタの比較）となる。異なる型を == で比較しようとするとコンパイルエラーとなる。">10</a></sup>。</p>

<p>しかしながら変数の型が <code>object</code> ならば、<code>==</code> は想定どおりに動かない、ということを知っておくべきだ<sup id="fnref11"><a href="#fn11" title="実際の開発現場でよくあるのは、データグリッドビューにセットしたオブジェクトと == で比較してしまって想定通りに動かない、というパターンだ。">11</a></sup>。</p>

<p>特に Java から C# に来た人は、「<code>string</code> が <code>==</code> で比較できるので直感的でいいな～」 なんて安易に捉えていると、昔の僕のようにハマることになります（笑）。</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>ちなみに <code>1.ToString()</code> としているのは、単純に "1" と書くと。 <a href="#fnref1">↩</a></p>
</li>

<li id="fn2">
<p>ディスパッチ: 複数の関数の中から一定の規則によって呼び出すべき関数を引き当てて呼び出すこと <a href="#fnref2">↩</a></p>
</li>

<li id="fn3">
<p>もちろん「メソッドのオーバーロード」もある。ところで他のプログラミング言語では、演算子をオーバーライド可能なものもある。例えば Ruby では演算子は一般的なメソッド呼び出しの糖衣構文という言語仕様になっているため、オーバーライド可能だ。 <a href="#fnref3">↩</a></p>
</li>

<li id="fn4">
<p>仮想関数テーブル (V-Table) とは C++ から導入された、コンパイル結果に含められる内部データのことで、クラスの継承ツリーをたどってオーバーライドされたメソッドを実行時に引き当てる仕組みのためのものだ。通常、プログラマが意識する必要はない。オーバライドされていようがされていまいが、メソッド呼び出し時には仮想関数テーブルの処理が行われるため、負荷が生じる。この負荷を避けるためにデフォルトでは仮想関数テーブルが作られず、オーバライドするためには <code>virtual</code> 指定が明示的に必要という言語仕様を採用している。これは C++ から C# にそのまま引き継がれた考え方だ。 <a href="#fnref4">↩</a></p>
</li>

<li id="fn5">
<p>ここでは本筋とはズレるので詳細説明は省略するが <code>==</code> をオーバーライドする場合は無限ループに陥りやすいので注意が必要だ。また <code>Equals()</code> と <code>GetHashCode()</code> もオーバライドしておくべきだ。詳しくはMSDN <a href="https://docs.microsoft.com/ja-jp/previous-versions/visualstudio/visual-studio-2008/ms173147(v=vs.90)" rel="nofollow noopener" target="_blank">Equals() と演算子 == のオーバーロードに関するガイドライン (C# プログラミング ガイド)</a> および <a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type" rel="nofollow noopener" target="_blank">方法: 型の値の等価性を定義する</a> などを参照のこと。より実践的な実装例は <a href="https://dobon.net/vb/dotnet/beginner/operator.html" rel="nofollow noopener" target="_blank">ここ</a> が一番分かりやすいと思います。 <a href="#fnref5">↩</a></p>
</li>

<li id="fn6">
<p>C# の <code>static</code> メソッドは、インスタンスに所属しておらず、そのクラスに名前空間的に配置される孤立したメソッドというような捉え方をすべきだ。演算子のオーバーロードを <code>static</code> で書くルールになっている以上、どうあがいてもオーバーライドすることは出来ない。 <a href="#fnref6">↩</a></p>
</li>

<li id="fn7">
<p>C++のテンプレートのように型ごとにメソッドが作られてコンパイルされる訳ではないため。 <a href="#fnref7">↩</a></p>
</li>

<li id="fn8">
<p>実行時に型を解決する仕組みとして、実行時にコード生成してコンパイルして実行しているような仕組みになっている。コンパイル結果に動的コード生成のためのコードが含まれるようになるためバイナリサイズが大きくなるし、初回実行時にそれなりのオーバヘッドがかかる。 <a href="#fnref8">↩</a></p>
</li>

<li id="fn9">
<p>例えば <code>Dictionary&lt;string, object&gt;</code> を使って文字列をキーにした連想配列で大きなデータ構造を扱うようなコードを書くぐらいなら、そもそもタイプセーフもクソもないので、<code>ExpandoObject</code> を使う方がよっぽどマシかもしれない。 <a href="#fnref9">↩</a></p>
</li>

<li id="fn10">
<p>例えば Java では演算子のオーバーロードが言語仕様として存在せず、<code>==</code> は単にリファレンスの比較（ポインタの比較）となる。異なる型を <code>==</code> で比較しようとするとコンパイルエラーとなる。 <a href="#fnref10">↩</a></p>
</li>

<li id="fn11">
<p>実際の開発現場でよくあるのは、データグリッドビューにセットしたオブジェクトと == で比較してしまって想定通りに動かない、というパターンだ。 <a href="#fnref11">↩</a></p>
</li>

</ol>
</div>
</div></div></section><div class="css-1yzj1fm"><div class="css-1uv1qiv"><span class="fa fa-twitter"></span></div><div class="css-1uv1qiv"><span class="fa fa-facebook"></span></div></div><div class="apm-Content"><div class="apm-Content_title">Why not register and get more from Qiita?</div><ol class="apm-Content_list"><li>We will deliver articles that match you<div class="description">By following users and tags, you can catch up information on technical fields that you are interested in as a whole</div></li><li>you can read useful information later efficiently<div class="description">By &quot;stocking&quot; the articles you like, you can search right away</div></li><div><a class="apm-Content_help" href="https://help.qiita.com/ja/articles/qiita-login-user" target="_blank"><i class="fa fa-fw fa-arrow-circle-right"></i>What you can do with signing up</a></div></ol><a href="/signup?callback_action=login_or_signup&amp;redirect_to=%2Flobin-z0x50%2Fitems%2Ff8421e046d96322250e2&amp;realm=qiita" class="apm-Content_button apm-Content_button-signup">Sign up</a><a href="/login?callback_action=login_or_signup&amp;redirect_to=%2Flobin-z0x50%2Fitems%2Ff8421e046d96322250e2&amp;realm=qiita" class="apm-Content_button apm-Content_button-signin">Login</a></div></div><div class="css-helsa7"></div></div></div></div><div class="css-109dbrr"><div class="css-5jpx49"><div class="css-mnxgyc"><button class=" css-1vlpknv"><svg size="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 392.81 429" color="#55C500" class="css-1g4cku8 e31pr5q0"><path d="M14.19 5.4h53.86v149.45h90.05v44.87H14.19zM288.4 93.77h100.79q1.29 25-5.66 45.39a96.79 96.79 0 01-20.33 34.89 92 92 0 01-32.13 22.45 104 104 0 01-40.95 7.93 109.71 109.71 0 01-76-29.92 104.05 104.05 0 01-23-32.56 95.46 95.46 0 01-8.47-39.88 94.78 94.78 0 018.47-39.87 104.38 104.38 0 0123-32.42A107.71 107.71 0 01248.23 8a110.79 110.79 0 01118.48 22.49l-35.07 35.08a51.25 51.25 0 00-17.75-15 52.83 52.83 0 00-44.67-1.23 52.92 52.92 0 00-17 12 57.07 57.07 0 00-11.45 18.11 60 60 0 00-4.23 22.77 60 60 0 004.23 22.68 56.57 56.57 0 0011.45 18.19 52.62 52.62 0 0017 12 50.5 50.5 0 0020.9 4.36q20.19 0 31.07-7.51a35.75 35.75 0 0014.46-20.55h-47.39zM51.29 279.55H0v-44.86h156v44.86h-51.13V429H51.29zM283.36 381.71l-41.72-62V429h-53.86V234.69h47.47L290 312l55.9-77.29h46.9V429h-53.86V320.27l-42.43 61.44z"></path></svg></button><a href="/lobin-z0x50/items/f8421e046d96322250e2/likers" class="css-1iupg5d">13</a></div><div class="css-fsjkhv"><button class=" css-15cocm3"><svg size="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 353.02 398" color="#6E6F70" class="css-12rp90f e11v00bf0"><path d="M176.72 398c-67.52 0-130.16-29-171.84-79.69l-4.46-5.42V78.05H353v234.84l-4.45 5.42C306.88 369 244.24 398 176.72 398zm-137.2-99.34c34.17 38.37 83.78 60.25 137.2 60.25s103-21.88 137.21-60.25V117.14H39.52zM0 0h351.12v40.94H0z"></path></svg></button><span class="css-1b17vb0">16</span></div><div class="css-79elbk"><button class="css-16hhh7b"><i class="fa fa-ellipsis-h"></i></button><div class="css-7i7f4d"><div class="css-1gj7nt">Improve article</div><a href="/drafts/f8421e046d96322250e2/edit" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-code-fork css-1jqivyb" aria-hidden="true"></i></span>Send edit request</a><div class="css-1ode1bp"></div><div class="css-1gj7nt">Article information</div><a href="/lobin-z0x50/items/f8421e046d96322250e2/revisions" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-history css-1jqivyb" aria-hidden="true"></i></span>Revisions</a><a href="/lobin-z0x50/items/f8421e046d96322250e2/patches" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-inbox css-1jqivyb" aria-hidden="true"></i></span>Edit Requests</a><a href="/lobin-z0x50/items/f8421e046d96322250e2/likers" class="css-154zy0m"><span class="css-yikrym"><svg size="13" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 392.81 429" color="rgba(0, 0, 0, 0.6)" class="css-le4d8r e31pr5q0"><path d="M14.19 5.4h53.86v149.45h90.05v44.87H14.19zM288.4 93.77h100.79q1.29 25-5.66 45.39a96.79 96.79 0 01-20.33 34.89 92 92 0 01-32.13 22.45 104 104 0 01-40.95 7.93 109.71 109.71 0 01-76-29.92 104.05 104.05 0 01-23-32.56 95.46 95.46 0 01-8.47-39.88 94.78 94.78 0 018.47-39.87 104.38 104.38 0 0123-32.42A107.71 107.71 0 01248.23 8a110.79 110.79 0 01118.48 22.49l-35.07 35.08a51.25 51.25 0 00-17.75-15 52.83 52.83 0 00-44.67-1.23 52.92 52.92 0 00-17 12 57.07 57.07 0 00-11.45 18.11 60 60 0 00-4.23 22.77 60 60 0 004.23 22.68 56.57 56.57 0 0011.45 18.19 52.62 52.62 0 0017 12 50.5 50.5 0 0020.9 4.36q20.19 0 31.07-7.51a35.75 35.75 0 0014.46-20.55h-47.39zM51.29 279.55H0v-44.86h156v44.86h-51.13V429H51.29zM283.36 381.71l-41.72-62V429h-53.86V234.69h47.47L290 312l55.9-77.29h46.9V429h-53.86V320.27l-42.43 61.44z"></path></svg></span>Show all likers</a><a href="/lobin-z0x50/items/f8421e046d96322250e2.md" class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-file-text-o css-1jqivyb" aria-hidden="true"></i></span>Show article in Markdown</a><div class="css-1ode1bp"></div><div class="css-154zy0m"><span class="css-yikrym"><i class="fa fa-flag css-1jqivyb" aria-hidden="true"></i></span>Report article</div></div><div class="st-Modal"><div class="st-Modal_backdrop"></div><div class="st-Modal_body"><form><div class="st-Form"><span class="st-Form_label">Help us understand the problem. What is going on with this article?</span></div><div class="st-Form"><label><input type="radio" name="reason" value="illegal" required=""/>It&#x27;s illegal (copyright infringement, privacy infringement, libel, etc.)</label></div><div class="st-Form"><label><input type="radio" name="reason" value="inappropriate_content" required=""/>It&#x27;s socially inappropriate (offensive to public order and morals)</label></div><div class="st-Form"><label><input type="radio" name="reason" value="advertising" required=""/>It&#x27;s advertising</label></div><div class="st-Form"><label><input type="radio" name="reason" value="spam" required=""/>It&#x27;s spam</label></div><div class="st-Form"><label><input type="radio" name="reason" value="guideline_violation" required=""/>Other than the above, but not suitable for the Qiita community (violation of guidelines)</label></div><div class="st-Form st-Form-right"><input type="submit" class="st-Form_submit" value="Submit"/></div></form></div></div></div></div></div></div>
      <script type="application/json" class="js-react-on-rails-component" data-component-name="PersonalArticlePage" data-dom-id="PersonalArticlePage-react-component-ba9f60af-dffe-4b78-b5e2-5fa3c94077b9">{"authorAnalyticsTrackingId":null,"organizationAnalyticsTrackingId":null}</script>
      
<footer id="globalFooter" class="st-Footer"><div class="st-Footer_container"><div class="st-Footer_start"><div class="st-Footer_logo"><svg viewbox="0 0 426.57 130" xmlns="http://www.w3.org/2000/svg"><circle cx="167.08" cy="21.4" r="12.28" /><path d="M250.81 29.66h23.48v18.9h-23.48z" /><path d="M300.76 105.26a22.23 22.23 0 01-6.26-.86 12.68 12.68 0 01-5.17-3 14.41 14.41 0 01-3.56-5.76 28 28 0 01-1.3-9.22V48.56h29.61v-18.9h-29.52V3.29h-20.17v83.34q0 11.16 2.83 18.27a27.71 27.71 0 007.7 11.2 26.86 26.86 0 0011.43 5.62 47.56 47.56 0 0012.34 1.53h15.16v-18zM0 61.7a58.6 58.6 0 015-24.21A62.26 62.26 0 0118.73 17.9 63.72 63.72 0 0139 4.78 64.93 64.93 0 0164 0a65 65 0 0124.85 4.78 64.24 64.24 0 0120.38 13.12A62 62 0 01123 37.49a58.6 58.6 0 015 24.21 58.34 58.34 0 01-4 21.46 62.8 62.8 0 01-10.91 18.16l11.1 11.1a10.3 10.3 0 010 14.52 10.29 10.29 0 01-14.64 0l-12.22-12.41a65 65 0 01-15.78 6.65 66.32 66.32 0 01-17.55 2.3 64.63 64.63 0 01-45.23-18A62.82 62.82 0 015 85.81 58.3 58.3 0 010 61.7zm21.64.08a43.13 43.13 0 0012.42 30.63 42.23 42.23 0 0013.43 9.09A41.31 41.31 0 0064 104.8a42 42 0 0030-12.39 42.37 42.37 0 009-13.64 43.43 43.43 0 003.3-17 43.77 43.77 0 00-3.3-17A41.7 41.7 0 0080.55 22 41.78 41.78 0 0064 18.68 41.31 41.31 0 0047.49 22a42.37 42.37 0 00-13.43 9.08 43.37 43.37 0 00-12.42 30.7zM331.89 78a47.59 47.59 0 013.3-17.73 43.22 43.22 0 019.34-14.47A44.25 44.25 0 01359 36a47.82 47.82 0 0118.81-3.58 42.72 42.72 0 019.26 1 46.5 46.5 0 018.22 2.58 40 40 0 017 3.84 44.39 44.39 0 015.71 4.63l1.22-9.47h17.35v85.83h-17.35l-1.17-9.42a42.54 42.54 0 01-5.84 4.67 43.11 43.11 0 01-7 3.79 44.86 44.86 0 01-8.17 2.59 43 43 0 01-9.22 1A47.94 47.94 0 01359 119.9a43.3 43.3 0 01-14.47-9.71 44.17 44.17 0 01-9.34-14.47 47 47 0 01-3.3-17.72zm20.27-.08a29.16 29.16 0 002.17 11.34 27 27 0 005.92 8.88 26.69 26.69 0 008.76 5.76 29.19 29.19 0 0021.44 0 26.11 26.11 0 008.72-5.76 27.57 27.57 0 005.88-8.84 29 29 0 002.16-11.38 28.62 28.62 0 00-2.16-11.22 26.57 26.57 0 00-5.93-8.8 27.68 27.68 0 00-19.51-7.9 28.29 28.29 0 00-10.77 2.05 26.19 26.19 0 00-8.71 5.75 27.08 27.08 0 00-5.84 8.8 28.94 28.94 0 00-2.13 11.31zm-194.97-30.5h19.78v73.54h-19.78zm49.25 0h19.78v73.54h-19.78z" /><circle cx="216.33" cy="21.4" r="12.28" /></svg></div><div class="st-Footer_catchcopy">How developers code is here.</div><div class="st-Footer_socials"><a class="fa fa-twitter" href="https://twitter.com/qiita"></a><a class="fa fa-facebook-square" href="https://www.facebook.com/qiita/"></a></div></div><div class="st-Footer_end"><div class="st-Footer_qiita"><div class="st-Footer_label">Qiita</div><div class="st-Footer_list"><div class="st-Footer_column"><a href="/about">About</a><a href="/terms">Terms</a><a href="/privacy">Privacy</a><a target="_blank" href="http://help.qiita.com/ja/articles/qiita-community-guideline">Guideline</a><a target="_blank" href="https://help.qiita.com/ja/articles/others-brand-guideline">Design Guideline</a></div><div class="st-Footer_column"><a href="/release-notes">Release</a><a href="/api/v2/docs">API</a><a href="/feedback/new">ご意見</a><a href="https://help.qiita.com">Help</a><a target="_blank" href="https://qiita.com/ads?utm_source=qiita&amp;utm_medium=referral&amp;utm_content=footer">Advertisement</a></div></div></div><div class="st-Footer_increments"><div class="st-Footer_label">Increments</div><div class="st-Footer_list"><div class="st-Footer_column"><a href="https://increments.co.jp/company/">About</a><a href="https://increments.co.jp/jobs/">採用情報</a><a href="https://blog.qiita.com">Blog</a></div><div class="st-Footer_column"><a href="https://teams.qiita.com/">Qiita Team</a><a href="https://jobs.qiita.com?utm_source=qiita&amp;utm_medium=referral&amp;utm_content=footer">Qiita Jobs</a><a href="https://zine.qiita.com?utm_source=qiita&amp;utm_medium=referral&amp;utm_content=footer">Qiita Zine</a></div></div></div></div></div><div class="st-Footer_copyright">© 2011-2021 Increments Inc.</div></footer><div id="Snackbar-react-component-4ed20d88-b707-435a-b4aa-9f811eef1fea"></div>
      <script type="application/json" class="js-react-on-rails-component" data-component-name="Snackbar" data-dom-id="Snackbar-react-component-4ed20d88-b707-435a-b4aa-9f811eef1fea">{}</script>
      
<div id="LoginModal-react-component-2f2ad585-8867-46dc-aec9-3c3f4e6ee705"></div>
      <script type="application/json" class="js-react-on-rails-component" data-component-name="LoginModal" data-dom-id="LoginModal-react-component-2f2ad585-8867-46dc-aec9-3c3f4e6ee705">{}</script>
      
<div id="StockModal-react-component-578d9c24-6cac-4015-9862-5a755d5294bd"></div>
      <script type="application/json" class="js-react-on-rails-component" data-component-name="StockModal" data-dom-id="StockModal-react-component-578d9c24-6cac-4015-9862-5a755d5294bd">{}</script>
      
</div><div id="dataContainer" style="display: none;" data-config="{&quot;actionPath&quot;:&quot;public/items#show&quot;,&quot;settings&quot;:{&quot;analyticsTrackingId&quot;:&quot;UA-24675221-12&quot;,&quot;assetsMap&quot;:{},&quot;csrfToken&quot;:&quot;ibfjab7kXtjpunoWL0V4T2fAO91pJZYQxoI3cKpJthB7/LPQ4EZrh2lNxqQKQ9JFJyy1fbiBCZ0n3MzWLWNU2Q==&quot;,&quot;locale&quot;:&quot;en&quot;},&quot;currentUser&quot;:null}" /></body></html><script type="application/json" data-js-react-on-rails-store="AppStoreWithReactOnRails">{"snackbar":{"type":"","body":"","isActive":false},"article":{"article":{"body":"\n\u003ch1\u003e\n\u003cspan id=\"はじめに\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eはじめに\u003c/h1\u003e\n\n\u003cp\u003eこの記事では、C# における \u003cstrong\u003eコンパイル時の型\u003c/strong\u003e と \u003cstrong\u003e実行時の型\u003c/strong\u003e について説明する。また関連する概念としてオーバーライドとオーバーロードの違い、演算子とメソッドで呼び出し対象の決定タイミングの違いについて簡単に説明する。\u003c/p\u003e\n\n\u003cp\u003e対象とする読者層は、C#プログラミング歴1年以上、中級者向け。\u003c/p\u003e\n\n\u003cp\u003e特に SIer やユーザー企業に所属（もしくは常駐）し、特に複数人チームでの開発に携わる若手プログラマ（俗に言う\"IT土方\"）に向けて、よくある \u003cstrong\u003eハマりポイント\u003c/strong\u003e について分かりやすいように書いているつもり。\u003c/p\u003e\n\n\u003cp\u003e対象としている .NET のバージョンは 4.0 以降、もちろん .NET Core も対象だ。\u003c/p\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"クイズ\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%82%AF%E3%82%A4%E3%82%BA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eクイズ\u003c/h1\u003e\n\n\u003cp\u003eまず始めに、このコードの実行結果がどうなるか、考えてみてほしい。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e例1\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e?\u003c/span\u003e \u003cspan class=\"s\"\u003e\"OK\"\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003e\"NG\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e出力結果は、以下の通り。（実際にIdeoneで試したい人は \u003ca href=\"https://ideone.com/AlufFU\" rel=\"nofollow noopener\" target=\"_blank\"\u003eこちら\u003c/a\u003e ）\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e例1の出力結果\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003eNG\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eなぜこうなるのか、あなたは正確に説明できるだろうか？\u003c/p\u003e\n\n\u003cp\u003e三項演算子がおかしいとか、記載されていないコードがあって変数が書き換えられているとか、そういう話ではない。\u003c/p\u003e\n\n\u003cp\u003eこのコードの \u003ccode\u003ex == y\u003c/code\u003e の判定は、間違いなく偽になっており、そしてそれは言語仕様通りだ。\u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"ヒント\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%83%92%E3%83%B3%E3%83%88\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eヒント\u003c/h2\u003e\n\n\u003cp\u003e以下のように書き換えると結果が変わる。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e例2\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eEquals\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e?\u003c/span\u003e \u003cspan class=\"s\"\u003e\"OK\"\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003e\"NG\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// OK\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003e==\u003c/code\u003e の代わりに \u003ccode\u003eEquals()\u003c/code\u003e を使うと結果が変わる。\u003c/p\u003e\n\n\u003cp\u003e面白いのは、次の例だ。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e例3\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003edynamic\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"kt\"\u003edynamic\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e?\u003c/span\u003e \u003cspan class=\"s\"\u003e\"OK\"\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003e\"NG\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// OK\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e例1と違うのは、変数の型が \u003ccode\u003eobject\u003c/code\u003e ではなく \u003ccode\u003edynamic\u003c/code\u003e になっているという点だ。\u003c/p\u003e\n\n\u003cp\u003eなぜこのような結果になるのか、ちゃんと説明できる人はどれぐらいいるだろうか？\u003c/p\u003e\n\n\u003cp\u003e理解のポイントは、型の解釈のタイミングだ。\u003c/p\u003e\n\n\u003cp\u003e実は C# では \u003cstrong\u003eコンパイル時の型\u003c/strong\u003e と \u003cstrong\u003e実行時の型\u003c/strong\u003e という２種類の解釈があるのだ。\u003c/p\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"解説\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E8%A7%A3%E8%AA%AC\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e解説\u003c/h1\u003e\n\n\u003cp\u003e例示したコードに於いて、出力が \u003ccode\u003e\"NG\"\u003c/code\u003e になるケースでは \u003ccode\u003eobject\u003c/code\u003e クラスの \u003ccode\u003e==\u003c/code\u003e 演算子が呼び出されているためだ。\u003cbr\u003e\n特に C# では \u003ccode\u003estring\u003c/code\u003e の比較に \u003ccode\u003e==\u003c/code\u003e を使うのが一般的であるため、以下のような直感的でない挙動になる場合について知っておく必要がある。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eよくあるハマりケース\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003eexpected\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\"1\"\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003eobj\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e1.\u003c/span\u003e\u003cspan class=\"nf\"\u003eToString\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// 注意が必要なパターン\u003c/span\u003e\n\u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eobj\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eexpected\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// False\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// こう書くとコンパイラの警告が出るので気が付く\u003c/span\u003e\n\u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eobj\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"s\"\u003e\"1\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// False\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// 以下は大丈夫なケース\u003c/span\u003e\n\u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003estr\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e1.\u003c/span\u003e\u003cspan class=\"nf\"\u003eToString\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estr\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"s\"\u003e\"1\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// True\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e実務でもたまに遭遇する \u003cstrong\u003eハマりポイント\u003c/strong\u003e でもある\u003csup id=\"fnref1\"\u003e\u003ca href=\"#fn1\" title='ちなみに 1.ToString() としているのは、単純に \"1\" と書くと。'\u003e1\u003c/a\u003e\u003c/sup\u003e。\u003c/p\u003e\n\n\u003cp\u003eもしちゃんと理解できていないと思うなら、この機会に是非マスターしてほしい。\u003c/p\u003e\n\n\u003cp\u003eハマらないためには、以下のように \u003ccode\u003eobject.Equals()\u003c/code\u003e を使って比較することだ。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eこれが正解\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eEquals\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// True     \u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eまた、自作クラスで演算子をオーバーロードした時にも注意が必要だ。つまり、どのクラスの演算子が呼び出されるかは、実行時の型ではなく、\u003cstrong\u003eコンパイル時の型によって決定\u003c/strong\u003e される。\u003c/p\u003e\n\n\u003cp\u003eC# では、演算子のオーバーライドが出来ないようになっており、演算子をオーバーロードする際は \u003ccode\u003estatic\u003c/code\u003e として宣言しなくてはならず、\u003ccode\u003evirtual\u003c/code\u003e 指定することも出来ない。従って演算子は実行時の型による動的ディスパッチ\u003csup id=\"fnref2\"\u003e\u003ca href=\"#fn2\" title=\"ディスパッチ: 複数の関数の中から一定の規則によって呼び出すべき関数を引き当てて呼び出すこと\"\u003e2\u003c/a\u003e\u003c/sup\u003eが出来ない（ただし \u003ccode\u003edynamic\u003c/code\u003e を使えば可能。後述）。\u003c/p\u003e\n\n\u003cp\u003eそもそも C# の世界に「演算子のオーバーライド」という概念はない。あるのは「メソッドの \u003cstrong\u003eオーバーライド\u003c/strong\u003e 」と「演算子の \u003cstrong\u003eオーバーロード\u003c/strong\u003e 」だ\u003csup id=\"fnref3\"\u003e\u003ca href=\"#fn3\" title=\"もちろん「メソッドのオーバーロード」もある。ところで他のプログラミング言語では、演算子をオーバーライド可能なものもある。例えば Ruby では演算子は一般的なメソッド呼び出しの糖衣構文という言語仕様になっているため、オーバーライド可能だ。\"\u003e3\u003c/a\u003e\u003c/sup\u003e。\u003c/p\u003e\n\n\u003cp\u003eまずはその辺からキッチリ理解していこう。\u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"オーバーライドとオーバーロードの違い\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89%E3%81%A8%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89%E3%81%AE%E9%81%95%E3%81%84\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eオーバーライドとオーバーロードの違い\u003c/h2\u003e\n\n\u003cp\u003e一応、オーバーライドとオーバーロードの違いをザックリおさらい。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"オーバーロード\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eオーバーロード\u003c/h3\u003e\n\n\u003cp\u003eオーバーロード (overload) とは、「 \u003cstrong\u003e多重定義\u003c/strong\u003e 」のことだ。メソッド名が同じで引数リストが異なるメソッドを作ることだ。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eオーバーロードの例\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eExec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003earg\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// 同じ名前で引数の異なるバージョンを多重に定義。これがオーバーロード\u003c/span\u003e\n\u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eExec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003earg\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"nf\"\u003eExec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003earg\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eToString\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eこのように同じ名前のメソッドを多重に定義することを「オーバーロード」と言う。\u003cbr\u003e\n処理は同じだが引数のバリエーションを増やして使い勝手を良くするような場合に多用される。\u003c/p\u003e\n\n\u003cp\u003eオーバーロードされたメソッドのうちどれを呼び出すかは、コンパイル時に決定される。\u003c/p\u003e\n\n\u003cp\u003e大事なことなので２回言います。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eオーバーロードされたメソッドのうちどれを呼び出すかは、コンパイル時に決定される。実行時に決定されるのではない。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e当たり前のことを言っているように聞こえるかもしれないが、こういうことを意識しながらプログラミングすることがとても大切だ。これが出来るようになると、確実にレベルアップしていると言える。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"オーバーライド\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eオーバーライド\u003c/h3\u003e\n\n\u003cp\u003e一方オーバーライド (override) は、クラス継承の際にメソッド名も引数リストも全く同じメソッドを定義し、基底クラスのメソッドを「 \u003cstrong\u003e上書き\u003c/strong\u003e 」することを指す。\u003c/p\u003e\n\n\u003cp\u003eC# では、\u003ccode\u003evirtual\u003c/code\u003e と \u003ccode\u003eoverride\u003c/code\u003e キーワードを用いる必要がある。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eオーバーライドの例\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eClassA\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003evirtual\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eExec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003earg\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// ClassA を継承したクラス\u003c/span\u003e\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eClassB\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eClassA\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 基底クラスのメソッドを上書き。これがオーバーライド\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003eoverride\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eExec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003earg\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eコンパイラは、\u003ccode\u003evirtual\u003c/code\u003e 指定されたメソッドの呼び出しがあると、コンパイル段階ではどのクラスのメソッドが呼び出されるか決定されない。というか決定することが出来ない。\u003cstrong\u003e実行時でないとどの型なのか分からない\u003c/strong\u003e ためだ。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eClassA\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nf\"\u003eGetInstance\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eExec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003earg\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// cはClassBのインスタンスかもしれない。コンパイル時には分からない。\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003eオーバーライドされたメソッドのうちどれを呼び出すかは、実行時に決定される。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eコンパイル時に決定されることを「静的」、実行時に決定されることを「動的」と呼ぶ。\u003c/p\u003e\n\n\u003cp\u003eそして、実行時にメソッドが決定されることを「動的ディスパッチ」と呼ぶ。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"virtual-指定がないメソッドのオーバーライド\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#virtual-%E6%8C%87%E5%AE%9A%E3%81%8C%E3%81%AA%E3%81%84%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003evirtual 指定がないメソッドのオーバーライド\u003c/h3\u003e\n\n\u003cp\u003eところで、\u003ccode\u003evirtual\u003c/code\u003e 指定がないメソッドに対してサブクラスで「上書き」しようとすると、\u003ccode\u003enew\u003c/code\u003e を付けると上書き可能になるが、実際それを試してみるとオーバーライドではなく、再定義になる。\u003c/p\u003e\n\n\u003cp\u003e従って、変数の型でどのメソッドを呼び出すかが決定される。\u003c/p\u003e\n\n\u003cp\u003e例: \u003ccode\u003enew\u003c/code\u003e で再定義すると変数の型（コンパイル時の型）で呼び出すメソッドが決まる。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003enewで再定義した場合\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eClassA\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eExec\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\"A\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// ClassA を継承したクラス\u003c/span\u003e\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eClassB\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eClassA\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 基底クラスのメソッドをオーバーライド？ではなく再定義になる\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eExec\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\"B\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eProgram\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eMain\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003eargs\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eClassB\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassB\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eExec\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// B\u003c/span\u003e\n\n        \u003cspan class=\"n\"\u003eClassA\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eExec\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// A  \u0026lt;= 値の型は ClassB であるが、変数の型が ClassA であるため\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eこのように、C#では \u003ccode\u003evirtual\u003c/code\u003e 指定がないメソッドをオーバーライドすることは物理的に不可能だ。理由は \u003ccode\u003evirtual\u003c/code\u003e 指定をしないと、実行時に動的ディスパッチするために必要な「仮想関数テーブル\u003csup id=\"fnref4\"\u003e\u003ca href=\"#fn4\" title=\"仮想関数テーブル (V-Table) とは C++ から導入された、コンパイル結果に含められる内部データのことで、クラスの継承ツリーをたどってオーバーライドされたメソッドを実行時に引き当てる仕組みのためのものだ。通常、プログラマが意識する必要はない。オーバライドされていようがされていまいが、メソッド呼び出し時には仮想関数テーブルの処理が行われるため、負荷が生じる。この負荷を避けるためにデフォルトでは仮想関数テーブルが作られず、オーバライドするためには virtual 指定が明示的に必要という言語仕様を採用している。これは C++ から C# にそのまま引き継がれた考え方だ。\"\u003e4\u003c/a\u003e\u003c/sup\u003e」という内部データが作られないためだ。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"演算子のオーバーロード\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e演算子のオーバーロード\u003c/h3\u003e\n\n\u003cp\u003eさてそろそろ本題の演算子のオーバーロードの話に入ろう。\u003c/p\u003e\n\n\u003cp\u003eまずは演算子のオーバーロードの例を見てみよう。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e演算子のオーバーロード\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eClassA\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eValue1\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"k\"\u003eprotected\u003c/span\u003e \u003cspan class=\"k\"\u003eset\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// コンストラクタ\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassA\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003eValue1\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// == 演算子を定義\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"p\"\u003e==(\u003c/span\u003e\u003cspan class=\"n\"\u003eClassA\u003c/span\u003e \u003cspan class=\"n\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eClassA\u003c/span\u003e \u003cspan class=\"n\"\u003eother\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue1\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eother\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// == を定義するためには != もペアで定義が必要\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"p\"\u003e!=(\u003c/span\u003e\u003cspan class=\"n\"\u003eClassA\u003c/span\u003e \u003cspan class=\"n\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eClassA\u003c/span\u003e \u003cspan class=\"n\"\u003eother\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e!(\u003c/span\u003e\u003cspan class=\"n\"\u003eself\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eother\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eこのようになる。\u003c/p\u003e\n\n\u003cp\u003eここでは \u003ccode\u003eoperator==()\u003c/code\u003e を１つしか定義していないが、それでも「演算子をオーバーロードしている」状態になる。\u003c/p\u003e\n\n\u003cp\u003eなお、\u003ccode\u003eoperator!=()\u003c/code\u003e の定義も必要なのは C# の仕様だ。中身は \u003ccode\u003e==\u003c/code\u003e の否定をとるだけでオッケーで、これが定石だ。これでコンパイルが通るが、実務で \u003ccode\u003e==\u003c/code\u003e をオーバーロードするのは注意が必要だ。多くの場合、\u003ccode\u003eEquals()\u003c/code\u003e をオーバーライドするのが適切だ。ここでは例示のための実験的なコードとして捉えておいてほしい\u003csup id=\"fnref5\"\u003e\u003ca href=\"#fn5\" title=\"ここでは本筋とはズレるので詳細説明は省略するが == をオーバーライドする場合は無限ループに陥りやすいので注意が必要だ。また Equals() と GetHashCode() もオーバライドしておくべきだ。詳しくはMSDN Equals() と演算子 == のオーバーロードに関するガイドライン (C# プログラミング ガイド) および 方法: 型の値の等価性を定義する などを参照のこと。より実践的な実装例は ここ が一番分かりやすいと思います。\"\u003e5\u003c/a\u003e\u003c/sup\u003e。\u003c/p\u003e\n\n\u003cp\u003eではこれを継承したクラスを作り、\u003cstrong\u003eオーバーライド\u003c/strong\u003e してみよう。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e演算子のオーバーライド？\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// ClassA を継承したクラス\u003c/span\u003e\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eClassB\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eClassA\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eValue2\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"k\"\u003eprotected\u003c/span\u003e \u003cspan class=\"k\"\u003eset\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassB\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eval1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eval2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"k\"\u003ebase\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eval1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003eValue2\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eval2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// == をオーバーライド？（実は出来ていない）\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"p\"\u003e==(\u003c/span\u003e\u003cspan class=\"n\"\u003eClassB\u003c/span\u003e \u003cspan class=\"n\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eClassB\u003c/span\u003e \u003cspan class=\"n\"\u003eother\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue1\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eother\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue1\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue2\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eother\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// == を定義するためには != もペアで定義が必要\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"k\"\u003eoperator\u003c/span\u003e\u003cspan class=\"p\"\u003e!=(\u003c/span\u003e\u003cspan class=\"n\"\u003eClassB\u003c/span\u003e \u003cspan class=\"n\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eClassB\u003c/span\u003e \u003cspan class=\"n\"\u003eother\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e!(\u003c/span\u003e\u003cspan class=\"n\"\u003eself\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eother\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e試しに上記クラスを利用するコードを書いて確かめてみよう。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eオーバーライド？した演算子を呼び出す\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eProgram\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eMain\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003eargs\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// ClassA のインスタンスを比較\u003c/span\u003e\n        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ea1\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassA\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\"A\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ea2\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassA\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\"A\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n        \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea1\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ea2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// True\u003c/span\u003e\n\n        \u003cspan class=\"c1\"\u003e// ClassB のインスタンスを比較\u003c/span\u003e\n        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003eb1\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassB\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\"1\"\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"m\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003eb2\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassB\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\"1\"\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"m\"\u003e20\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n        \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eb1\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eb2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// False  \u0026lt;= Value2 の値が異なるので False\u003c/span\u003e\n\n        \u003cspan class=\"c1\"\u003e// ClassA 型の変数に代入（キャスト）\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eClassA\u003c/span\u003e \u003cspan class=\"n\"\u003ec1\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eb1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eClassA\u003c/span\u003e \u003cspan class=\"n\"\u003ec2\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eb2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n        \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec1\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ec2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// True  \u0026lt;= ここで、ClassAの==演算子が呼ばれている\u003c/span\u003e\n\n        \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e$\"\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003ec1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eGetType\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eName\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e, \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003ec2\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eGetType\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eName\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s\"\u003e\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// ClassB, ClassB  \u0026lt;= 実体はどちらもClassB\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e案の定、これでは想定どおりに動かない。\u003ccode\u003estatic\u003c/code\u003e だし、\u003ccode\u003evirtual\u003c/code\u003e 指定ができないし、基底クラスの \u003ccode\u003e==\u003c/code\u003e とは引数リストも異なるので、全くオーバーライドになっていない。完全に異なる別々のメソッドになっている。\u003ca href=\"https://ideone.com/sDj64l\" rel=\"nofollow noopener\" target=\"_blank\"\u003eIdeoneにコードを置いてあるので実際に試してみよう\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e「解説」で説明したとおり、C# では \u003cstrong\u003e演算子をオーバーライドすることは出来ない\u003c/strong\u003e のだ。\u003csup id=\"fnref6\"\u003e\u003ca href=\"#fn6\" title=\"C# の static メソッドは、インスタンスに所属しておらず、そのクラスに名前空間的に配置される孤立したメソッドというような捉え方をすべきだ。演算子のオーバーロードを static で書くルールになっている以上、どうあがいてもオーバーライドすることは出来ない。\"\u003e6\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"コンパイル時の型と実行時の型\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E6%99%82%E3%81%AE%E5%9E%8B%E3%81%A8%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AE%E5%9E%8B\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eコンパイル時の型と実行時の型\u003c/h2\u003e\n\n\u003cp\u003eこれまで見てきたように、C# ではコンパイル時の型と実行時の型を区別して認識する必要がある。\u003cbr\u003e\nコンパイル時の型とは、言い換えると \u003cstrong\u003e変数の型\u003c/strong\u003e のことで、実行時の型とは、\u003cstrong\u003e値の型\u003c/strong\u003e （実体）のことだ。\u003c/p\u003e\n\n\u003cp\u003eでは、演算子は必ずコンパイル時の型で評価されるのかというと、実は実行時に評価させる方法がある。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"ジェネリックを使う場合\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%83%83%E3%82%AF%E3%82%92%E4%BD%BF%E3%81%86%E5%A0%B4%E5%90%88\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eジェネリックを使う場合\u003c/h3\u003e\n\n\u003cp\u003eクラスやメソッドにジェネリックを使って任意の型に適用出来るようにした場合、実行時の型で評価されるように期待するかもしれないが、 \u003cstrong\u003eそうはならない\u003c/strong\u003e 。基本的にはコンパイル時の型で解決されるが、\u003ccode\u003ewhere\u003c/code\u003e 制約を付けない限り、\u003ccode\u003eobject\u003c/code\u003e クラスの \u003ccode\u003e==\u003c/code\u003e を呼ぶようコンパイルされる。\u003c/p\u003e\n\n\u003cp\u003e先程の演算子オーバロードの説明で用いたコードを使って、ジェネリックを試してみよう。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e例4(ジェネリックを使う場合)\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// コンパイルエラー。whereなしではジェネリック型に演算子を適用できない。\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//static void f\u0026lt;T\u0026gt;(T x, T y) {\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  Console.WriteLine(x == y ? \"OK\" : \"NG\");\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//}\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// where で参照型だけに制限すれば演算子が使えるが、object.== が呼ばれる\u003c/span\u003e\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eT\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;(\u003c/span\u003e\u003cspan class=\"n\"\u003eT\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eT\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003ewhere\u003c/span\u003e \u003cspan class=\"n\"\u003eT\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"err\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"nc\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e?\u003c/span\u003e \u003cspan class=\"s\"\u003e\"OK\"\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003e\"NG\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// 明示的に ClassA に制約すれば、そのクラスの == が呼ばれる\u003c/span\u003e\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eg\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eT\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;(\u003c/span\u003e\u003cspan class=\"n\"\u003eT\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eT\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003ewhere\u003c/span\u003e \u003cspan class=\"n\"\u003eT\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eClassA\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e?\u003c/span\u003e \u003cspan class=\"s\"\u003e\"OK\"\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003e\"NG\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassA\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassA\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"nf\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// NG  \u0026lt;= objectクラスの == を呼ぶようコンパイルされるため\u003c/span\u003e\n\n\u003cspan class=\"nf\"\u003eg\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// OK\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e特性をまとめると以下のようになる。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e基本的には \u003ccode\u003ewhere T: class\u003c/code\u003e を付けないと、演算子は使えない。\u003c/li\u003e\n\u003cli\u003e付けたとしても、コンパイル時の \u003ccode\u003eT\u003c/code\u003e の型の演算子が呼ばれるわけではなく、 \u003ccode\u003eobject\u003c/code\u003e の演算子が呼ばれる\u003csup id=\"fnref7\"\u003e\u003ca href=\"#fn7\" title=\"C++のテンプレートのように型ごとにメソッドが作られてコンパイルされる訳ではないため。\"\u003e7\u003c/a\u003e\u003c/sup\u003e。\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003ewhere T: ClassA\u003c/code\u003e というように明示的に型制約をつけると、その型の演算子を呼ぶようになる。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eこのように、ジェネリック型に対して演算子を使う場合は注意が必要だ。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"dynamic-を使う場合\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#dynamic-%E3%82%92%E4%BD%BF%E3%81%86%E5%A0%B4%E5%90%88\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003edynamic を使う場合\u003c/h3\u003e\n\n\u003cp\u003eC# の \u003ccode\u003edynamic\u003c/code\u003e は実行時に該当する型を判別して動的にコードを生成してくれる凄い仕組みだ。\u003cbr\u003e\nダックタイピングのような機能を提供する。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003edynamic\u003c/code\u003e として宣言された変数はその名前のごとく動的（つまりコンパイル時ではなく実行時）に、型が解決される\u003csup id=\"fnref8\"\u003e\u003ca href=\"#fn8\" title=\"実行時に型を解決する仕組みとして、実行時にコード生成してコンパイルして実行しているような仕組みになっている。コンパイル結果に動的コード生成のためのコードが含まれるようになるためバイナリサイズが大きくなるし、初回実行時にそれなりのオーバヘッドがかかる。\"\u003e8\u003c/a\u003e\u003c/sup\u003e。実行時というか、なので、例3の場合だと \u003ccode\u003eint\u003c/code\u003e 型で実行時にコード展開され、実行される。\u003c/p\u003e\n\n\u003cp\u003eデメリットとして、コンパイル時に型情報が一切ないので、インテリセンスも利かないし、何より静的型付け言語の最大のメリット「タイプセーフ」でなくなってしまう。\u003cbr\u003e\n乱用は禁物だ\u003csup id=\"fnref9\"\u003e\u003ca href=\"#fn9\" title=\"例えば Dictionary\u0026lt;string, object\u0026gt; を使って文字列をキーにした連想配列で大きなデータ構造を扱うようなコードを書くぐらいなら、そもそもタイプセーフもクソもないので、ExpandoObject を使う方がよっぽどマシかもしれない。\"\u003e9\u003c/a\u003e\u003c/sup\u003e。\u003cbr\u003e\nここではこれ以上の詳細な説明は省略するが、興味があれば調べてみると良いだろう。\u003c/p\u003e\n\n\u003cp\u003e先程のジェネリックの例を \u003ccode\u003edynamic\u003c/code\u003e で書き換えると以下のようになる。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"cs\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003e例5(dynamicを使う場合)\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"with-code\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eh\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003edynamic\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003edynamic\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e?\u003c/span\u003e \u003cspan class=\"s\"\u003e\"OK\"\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003e\"NG\"\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassA\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassA\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"nf\"\u003eh\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// OK\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eただし、実務でこのような \u003ccode\u003edynamic\u003c/code\u003e の使い方をしてはいけない。\u003cbr\u003e\n正しくは「解説」で示したように、\u003ccode\u003eobject.Equals()\u003c/code\u003e を使うべきだ。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://ideone.com/Ot2Amn\" rel=\"nofollow noopener\" target=\"_blank\"\u003e上記ジェネリックと\u003ccode\u003edynamic\u003c/code\u003eのコードサンプルを Ideone に置いてあります\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"まとめ\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%81%BE%E3%81%A8%E3%82%81\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eまとめ\u003c/h1\u003e\n\n\u003cp\u003e「コンパイル時の型」と「実行時の型」という２つの解釈があることを認識しよう。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eオーバーライドされたメソッドは、実行時の型でディスパッチされる\u003c/li\u003e\n\u003cli\u003eオーバーロードされたメソッドは（演算子に限らず全て）、コンパイル時の型でディスパッチされる\u003c/li\u003e\n\u003cli\u003eただし \u003ccode\u003edynamic\u003c/code\u003e を使った場合は実行時にコンパイルされるため、オーバーロードされたメソッドでも実行時の型でディスパッチされることになる\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e３つ目はエンタープライズ開発の現場ではほとんどお目にかかる事はないと思うので、例外的パターンぐらいの捉え方で十分と思う。\u003c/p\u003e\n\n\u003cp\u003eJava と比較すると、C# では文字列の比較にも \u003ccode\u003e==\u003c/code\u003e が使えるため、普段から \u003ccode\u003eEqual()\u003c/code\u003e メソッドを使うことはとても少ないと思われる\u003csup id=\"fnref10\"\u003e\u003ca href=\"#fn10\" title=\"例えば Java では演算子のオーバーロードが言語仕様として存在せず、== は単にリファレンスの比較（ポインタの比較）となる。異なる型を == で比較しようとするとコンパイルエラーとなる。\"\u003e10\u003c/a\u003e\u003c/sup\u003e。\u003c/p\u003e\n\n\u003cp\u003eしかしながら変数の型が \u003ccode\u003eobject\u003c/code\u003e ならば、\u003ccode\u003e==\u003c/code\u003e は想定どおりに動かない、ということを知っておくべきだ\u003csup id=\"fnref11\"\u003e\u003ca href=\"#fn11\" title=\"実際の開発現場でよくあるのは、データグリッドビューにセットしたオブジェクトと == で比較してしまって想定通りに動かない、というパターンだ。\"\u003e11\u003c/a\u003e\u003c/sup\u003e。\u003c/p\u003e\n\n\u003cp\u003e特に Java から C# に来た人は、「\u003ccode\u003estring\u003c/code\u003e が \u003ccode\u003e==\u003c/code\u003e で比較できるので直感的でいいな～」 なんて安易に捉えていると、昔の僕のようにハマることになります（笑）。\u003c/p\u003e\n\n\u003cdiv class=\"footnotes\"\u003e\n\u003chr\u003e\n\u003col\u003e\n\n\u003cli id=\"fn1\"\u003e\n\u003cp\u003eちなみに \u003ccode\u003e1.ToString()\u003c/code\u003e としているのは、単純に \"1\" と書くと。 \u003ca href=\"#fnref1\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\n\u003cli id=\"fn2\"\u003e\n\u003cp\u003eディスパッチ: 複数の関数の中から一定の規則によって呼び出すべき関数を引き当てて呼び出すこと \u003ca href=\"#fnref2\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\n\u003cli id=\"fn3\"\u003e\n\u003cp\u003eもちろん「メソッドのオーバーロード」もある。ところで他のプログラミング言語では、演算子をオーバーライド可能なものもある。例えば Ruby では演算子は一般的なメソッド呼び出しの糖衣構文という言語仕様になっているため、オーバーライド可能だ。 \u003ca href=\"#fnref3\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\n\u003cli id=\"fn4\"\u003e\n\u003cp\u003e仮想関数テーブル (V-Table) とは C++ から導入された、コンパイル結果に含められる内部データのことで、クラスの継承ツリーをたどってオーバーライドされたメソッドを実行時に引き当てる仕組みのためのものだ。通常、プログラマが意識する必要はない。オーバライドされていようがされていまいが、メソッド呼び出し時には仮想関数テーブルの処理が行われるため、負荷が生じる。この負荷を避けるためにデフォルトでは仮想関数テーブルが作られず、オーバライドするためには \u003ccode\u003evirtual\u003c/code\u003e 指定が明示的に必要という言語仕様を採用している。これは C++ から C# にそのまま引き継がれた考え方だ。 \u003ca href=\"#fnref4\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\n\u003cli id=\"fn5\"\u003e\n\u003cp\u003eここでは本筋とはズレるので詳細説明は省略するが \u003ccode\u003e==\u003c/code\u003e をオーバーライドする場合は無限ループに陥りやすいので注意が必要だ。また \u003ccode\u003eEquals()\u003c/code\u003e と \u003ccode\u003eGetHashCode()\u003c/code\u003e もオーバライドしておくべきだ。詳しくはMSDN \u003ca href=\"https://docs.microsoft.com/ja-jp/previous-versions/visualstudio/visual-studio-2008/ms173147(v=vs.90)\" rel=\"nofollow noopener\" target=\"_blank\"\u003eEquals() と演算子 == のオーバーロードに関するガイドライン (C# プログラミング ガイド)\u003c/a\u003e および \u003ca href=\"https://docs.microsoft.com/ja-jp/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type\" rel=\"nofollow noopener\" target=\"_blank\"\u003e方法: 型の値の等価性を定義する\u003c/a\u003e などを参照のこと。より実践的な実装例は \u003ca href=\"https://dobon.net/vb/dotnet/beginner/operator.html\" rel=\"nofollow noopener\" target=\"_blank\"\u003eここ\u003c/a\u003e が一番分かりやすいと思います。 \u003ca href=\"#fnref5\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\n\u003cli id=\"fn6\"\u003e\n\u003cp\u003eC# の \u003ccode\u003estatic\u003c/code\u003e メソッドは、インスタンスに所属しておらず、そのクラスに名前空間的に配置される孤立したメソッドというような捉え方をすべきだ。演算子のオーバーロードを \u003ccode\u003estatic\u003c/code\u003e で書くルールになっている以上、どうあがいてもオーバーライドすることは出来ない。 \u003ca href=\"#fnref6\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\n\u003cli id=\"fn7\"\u003e\n\u003cp\u003eC++のテンプレートのように型ごとにメソッドが作られてコンパイルされる訳ではないため。 \u003ca href=\"#fnref7\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\n\u003cli id=\"fn8\"\u003e\n\u003cp\u003e実行時に型を解決する仕組みとして、実行時にコード生成してコンパイルして実行しているような仕組みになっている。コンパイル結果に動的コード生成のためのコードが含まれるようになるためバイナリサイズが大きくなるし、初回実行時にそれなりのオーバヘッドがかかる。 \u003ca href=\"#fnref8\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\n\u003cli id=\"fn9\"\u003e\n\u003cp\u003e例えば \u003ccode\u003eDictionary\u0026lt;string, object\u0026gt;\u003c/code\u003e を使って文字列をキーにした連想配列で大きなデータ構造を扱うようなコードを書くぐらいなら、そもそもタイプセーフもクソもないので、\u003ccode\u003eExpandoObject\u003c/code\u003e を使う方がよっぽどマシかもしれない。 \u003ca href=\"#fnref9\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\n\u003cli id=\"fn10\"\u003e\n\u003cp\u003e例えば Java では演算子のオーバーロードが言語仕様として存在せず、\u003ccode\u003e==\u003c/code\u003e は単にリファレンスの比較（ポインタの比較）となる。異なる型を \u003ccode\u003e==\u003c/code\u003e で比較しようとするとコンパイルエラーとなる。 \u003ca href=\"#fnref10\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\n\u003cli id=\"fn11\"\u003e\n\u003cp\u003e実際の開発現場でよくあるのは、データグリッドビューにセットしたオブジェクトと == で比較してしまって想定通りに動かない、というパターンだ。 \u003ca href=\"#fnref11\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\u003c/div\u003e\n","createdAt":"2019-05-03T12:10:04Z","elapsedYearsFromLastModifiedAt":2,"encryptedId":"77n6Nz2ureGnI9zSEiX+o8nOo/nfkDE4--5SQIJ0kZWD5mZpw4--A2gXR1rdIxFKmQ3z0F7erQ==","isBanned":false,"isDeprecated":true,"isDestroyableByViewer":false,"isEditRequestReadableByViewer":true,"isEditRequestSendableByViewer":true,"isLikableByViewer":true,"isLikedByViewer":false,"isPublic":true,"isSlide":false,"isStockableByViewer":true,"isStockedByViewer":false,"isSubscribableByViewer":false,"isSubscribedByViewer":false,"isUpdatableByViewer":false,"isUpdated":true,"lastModifiedAt":"2019-05-18T09:54:21Z","likesCount":13,"linkUrl":"https://qiita.com/lobin-z0x50/items/f8421e046d96322250e2","organization":null,"originalId":884590,"stockedCount":16,"title":"【C# 中級向け】「コンパイル時の型」と「実行時の型」を意識しよう","toc":"\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\"#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB\"\u003eはじめに\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#%E3%82%AF%E3%82%A4%E3%82%BA\"\u003eクイズ\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\"#%E3%83%92%E3%83%B3%E3%83%88\"\u003eヒント\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#%E8%A7%A3%E8%AA%AC\"\u003e解説\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\"#%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89%E3%81%A8%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89%E3%81%AE%E9%81%95%E3%81%84\"\u003eオーバーライドとオーバーロードの違い\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\"#%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89\"\u003eオーバーロード\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89\"\u003eオーバーライド\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#virtual-%E6%8C%87%E5%AE%9A%E3%81%8C%E3%81%AA%E3%81%84%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89\"\u003evirtual 指定がないメソッドのオーバーライド\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AD%E3%83%BC%E3%83%89\"\u003e演算子のオーバーロード\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E6%99%82%E3%81%AE%E5%9E%8B%E3%81%A8%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AE%E5%9E%8B\"\u003eコンパイル時の型と実行時の型\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href=\"#%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%83%83%E3%82%AF%E3%82%92%E4%BD%BF%E3%81%86%E5%A0%B4%E5%90%88\"\u003eジェネリックを使う場合\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#dynamic-%E3%82%92%E4%BD%BF%E3%81%86%E5%A0%B4%E5%90%88\"\u003edynamic を使う場合\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ca href=\"#%E3%81%BE%E3%81%A8%E3%82%81\"\u003eまとめ\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","totalPv":3608,"uuid":"f8421e046d96322250e2","banReason":null,"adventCalendarItem":null,"author":{"encryptedId":"khR7VWCoqXhZEguvw4wkNrTIrnZt--9G/nHOtbjcLWwrLH--r/ad1u5o0fbInMHmGNVNIw==","originalId":205835,"description":"株式会社ネオジニア 代表取締役、ITアーキテクト。\r\n大阪府岸和田市出身。\r\n組み込み開発から業務システム、スマホアプリ、Webまで幅広く開発プロジェクトに従事し、2012年に独立。\r\n従来型のSI開発に限界を感じ、変更に強いソフトウェアを日々研究し、SI業界の改革を夢見ている。\r\nいろんな言語を使うが、メインは Ruby と C#。","facebookUrl":null,"githubUrl":"https://github.com/lobin-z0x50","isBlockingViewer":false,"isFollowableByViewer":true,"isFollowedByViewer":false,"isTweetWebNotificationReceivable":true,"linkedinUrl":null,"name":"Wataru Maeda","profileImageUrl":"https://avatars0.githubusercontent.com/u/11419109?v=4","profileImageUrlW48":"https://qiita-user-profile-images.imgix.net/https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F11419109%3Fv%3D4?ixlib=rb-4.0.0\u0026auto=compress%2Cformat\u0026lossless=0\u0026w=48\u0026s=39bb1e7bf936693cf88e0ce7fb7df741","profileImageUrlW75":"https://qiita-user-profile-images.imgix.net/https%3A%2F%2Favatars0.githubusercontent.com%2Fu%2F11419109%3Fv%3D4?ixlib=rb-4.0.0\u0026auto=compress%2Cformat\u0026lossless=0\u0026w=75\u0026s=855c34f5fdd094abe9b5241d0799cde7","urlName":"lobin-z0x50","websiteUrl":"http://architect-wat.hatenablog.jp/","twitterUrl":null,"twitterUrlName":null,"revealedOrganizations":{"edges":[{"node":{"encryptedId":"HqBDZd7GkuCIyRexiNbXBpReQApKdJCc9Knd--MBsfxTLFb762+l0y--u+6d9axbNzg5AjUvzqLxUQ==","isBetaReleaseEnabled":false,"isFollowableByViewer":false,"isFollowedByViewer":false,"name":"株式会社ネオジニア","logoUrl":"https://s3-ap-northeast-1.amazonaws.com/qiita-organization-image/90bb8133c41e36c124364b7566b728fc85e44e2f/original.jpg?1596812707","urlName":"neogenia","description":"大阪のシステム開発会社です！","url":"https://www.neogenia.co.jp/"}}]}},"tags":[{"name":"C#","urlName":"csharp"},{"name":"オブジェクト指向","urlName":"%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e6%8c%87%e5%90%91"},{"name":"型","urlName":"%e5%9e%8b"},{"name":"オーバーライド","urlName":"%e3%82%aa%e3%83%bc%e3%83%90%e3%83%bc%e3%83%a9%e3%82%a4%e3%83%89"},{"name":"オーバーロード","urlName":"%e3%82%aa%e3%83%bc%e3%83%90%e3%83%bc%e3%83%ad%e3%83%bc%e3%83%89"}],"followingLikers":{"edges":[]},"comments":{"totalCount":3}},"comments":[],"client":null,"ads_event_emitter":null}}</script>
