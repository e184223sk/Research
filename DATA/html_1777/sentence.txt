More than 1 year has passed since last update.C# DllExportでWindowスタイルなAPIをC#風に扱う - Qiita　という記事を見かけたので、コメントついでに関連ネタです。Win32APIで結果が文字列の場合、呼び出し側が確保した領域のポインタを渡してそこに書き込んでもらうという手段が一般的です。(代表例：GetWindowTextやGetTempPath)一方、C#の文字列(System.String)は基本的に不変であり、そのメモリ領域に書き込みを行ってはなりません。(参考 → String クラス (System) )そこで、C#からP/Invokeで書き換えが必要なAPIを呼び出すときは書き換え可能な領域を確保して渡し、そこからstringを作成するという手順が取られます。それぞれのパフォーマンスを比較してみました。実行可能なサンプルはこちらに上げました。
https://github.com/KageShiron/StringPinvokePeformance※解説のしやすさのために表の順番を入れ替えていますまず、StringBuilderを使う方法はググるとよく出てきますが、StringBuilder自体をヒープに確保する必要があるため論外に近いです。スタックに乗らないほど巨大なバッファが必要な場合には使える・・・といいたいところですが、その場合はおそらくArrayPoolからchar[]バッファをもらってくるのが正攻法でしょう。名前の通り、危険なやり方
new stringしたメモリ領域に直接書き込んでいます。無駄は無いのですが、new stringしたメモリ領域は本来不変なので別の状況では予期しない動作やクラッシュを招く可能性があるはずです。安全性を投げ捨てた割に、速度的にもメリットがでませんでした。String.Createは.NET Core 2.1から追加された新しいメソッドです。こちらはstringを作成し、そのバッファの中身をコールバックで直に書き換えられるという最近の.NETの方向性を示すかのようなメソッドです。うまく使うと非常に効率的に文字列を生成できます。ただ、今回の場合はあまり刺さる使い方になっておらず、ラムダ式を書くのが面倒な割に他と大差ありません。ラムダ式を使う分余分なヒープ確保があるかと思いましたが、その心配は無用のようです。やはり早くて楽ちんなのがスタックメモリを確保するstackallocを使う方法です。スタックメモリはヒープと違い解放が非常に低コストです。さらにC# 7.2からunsafeを使うことなくSpanで受け取れるようになりました。GetPinnableReferenceで参照を取得できるのも扱いやすいですね。new stringとToStringも比較してみましたが、どちらも処理は同じようです。メモリ確保が566Bytesなのは、ToStringした際にNULL文字も含まれてしまったためです。古来のC#から使えた方法です。unsafeを付ける必要があり、コンパイルオプションでも/unsafeが必要です。C#ではnew stringにchar*を受け取るオーバーロードがあるので、実は手軽に使用可能です。


