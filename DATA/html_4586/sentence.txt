More than 1 year has passed since last update.この記事がEntity Component System入門者の助けとなることを願って初透光です。ECSについて初歩的な知識を有していることが前提です。
わからないことがあれば入門記事を参照してください。
C#7.2でソースコードを書いていますので、文法的な不明点がある場合はufcppを参照してください。Unity1週間ゲームジャムに初参加してきました。
これは月曜0時にお題が発表され、それに沿ったゲームを日曜20時までに投稿するという催しです。
今回のお題は「あつい」でした。既に締切を過ぎて様々なゲームが発表されていますが、なかなか参加者の発想の幅が広くて楽しいゲームジャムでした。
きゅうりをできる限り薄切りしていくゲームや、村をうっかり（確信犯）焼き尽くすゲームなど色々ありますので是非遊んでみてください。あまり記事にするのが遅れるのもアレなので省ける解説は大分省いての投稿となりました。さて、私自身は 相変わらずヴァーレントゥーガ互換リアルタイムストラテジーを作る練習として 大量の敵に追いかけられながら敵を焼き殺すというゲームを作りました。
１週間でどのぐらい自分が作れるのか自分でも全く把握していなかったので当初の予定より大幅に機能を削ぎ落としましたが、なんとか遊べる程度に完成できて良かったです。Entity Component System（以下ECS）がWebGLに対応していないのでパッケージに手を加えて動かせるように自力でなんとかしました。
いやぁ…… 一週間ゲームShamu開始前に動かないことに気付けてよかったです。丸1日がこの対応作業で潰れましたからね。今回のゲームのリポジトリ
今回のゲーム「晩夏の昼の挽歌」へのリンクリポジトリをcloneしたらそのまま遊べます。ECSはUIやシーン管理、Audio周りに対して現在のところ残念ながら向いていません。その部分は伝統的なMonoBehaviour/Componentで実装しています。
インゲームのコアなロジックに対してECSを使用しています。シーン数は総計７つ
矢印はシーン遷移を表します。太い矢印はSingleシーン遷移、細い矢印はAdditiveなシーン追加を意味します。シーン間での情報の共有はScriptableObjectを使用しています。
具体的な方法は安定のテラシュールブログ記事を参照してください。
エディターでプレイするとScriptableObjectが勝手に書き換わる問題は気合でなんとかしました。Managerクラスはその名の短さが示すように最も中核で全ての依存を管理し、全てのパラメータを受付け、全てのゲーム進行を掌握していた。
人は余りの神威故partialクラスとしてManagerを９つに裂き、その力を減じさせんとした。ScriptableObjects名前空間は肥大化するSerializeFieldに抗うためにScriptableObjectを定義している空間です。
ScriptableObjects.TitleSettings titleSettingsとScriptableObjects.Result resultSettingsの2つがシーン間で共有するScriptableObjectsです。
他のScriptableObjectsはreadonlyとして扱うようプログラマーの良心に期待しています。
titleSettingsに関してはManagerクラスの所属するSCWRシーン内でreadonlyとして扱うようプログラマーの(ry
resultSettingsはSCWRシーン内からのみ書き込み可能であるという設定で良心あるプログラマーに扱(ryここら辺を厳密に良心や規約によらずコンパイラーに制限してもらう方法に心当たりはありますが、一週間ゲームジャムでやるには個人開発なので必要性が薄い＆時間が足りないのでやっていません。こんな感じで書けばCSWRシーンのinternalメンバーにTitleシーンからのみアクセスできるようになります。World.CreateManager(Type t, paramas object[] constructorArguments)は内部的にActivator.CreateInstanceを使用しています。
よって、ComponentSystemに対する依存性注入は純粋にコンストラクタ経由で行えます。
ECS標準のMeshInstanceRendererSystemはActiveCameraというフィールドを外部に露出して書き込んでもらうことを前提とした設計ですが、それなんて前時代
ComponentSystemから外部にフィールドを公開する場合もreadonlyフィールドなので勝手に書き換えられる心配をしなくてすみます。 readonlyが使えないMonoBehaviourとは違うのだよ！ちょっと残念なのは参照の依存関係上CreateManagerする順番が割と重要なことですね。大半のComponentSystemは他のComponentSystemに依存していないので初期化順番を気にしなくていいのですが……24個もComponentSystemをCreateManagerしていますが、この規模のゲームとしてはどうなのでしょうかね？
ComponentSystem個々の働きを確認してみましょう。このゲームはプレイヤー・敵、エフェクト等すべてをXW平面上に描画しています。
それをY軸上に存在するカメラが上から眺めている形になります。
ECSにおける一般的な描画方法については次の記事を参照するとよいでしょう。一番工夫がわかりやすいシステムから解説しましょう。 折角スケールするように設計しても対象が1つしかないので無駄とは言ってはいけない。
Graphics.DrawMeshInstancedIndirectが何故かWebGLで動かなかったので次善の策としてGraphics.DrawMeshInstancedを使用しています。
Graphics.DrawMeshInstancedIndirect関連は凡ミスが発生しやすい面倒なメソッドなので、何か私が気付かずにミスっているだけという可能性も高いですがね。
Graphics.DrawMeshInstancedは一度のBatchで描画できる対象数が1023個に制限されているため、数万個を描画しようとするとBatchCountがゴリゴリ増える欠点があります。このシステムではスプライトをgifのようにアニメーションさせつつ大量に描画しています。

今回ゲームで使用した素材（ぴぽや様より拝借しました）
ご覧のように一枚のテクスチャに８つの爆発画像が含まれています。InspectorでSplite ModeをMultipleに設定して8つにスプライトを分割、各SpriteからMeshを取り出して配列に入れています。
このMesh配列の要素をGraphics.DrawMeshInstancedの引数に適切に渡してあげればアニメーションができるのです。ECS 0.0.12-preview.11からの新機能としてChunk Iterationがあります。
使用法はComponentGroupに比べたらやや複雑ですが十分簡単です。
EntityArchetypeQuery型とNativeList&lt;EntityArchetype&gt;型のフィールドを用意します。
毎フレームOnUpdate内部でEntityManager.AddMatchingArchetype(EntityArchetype, NativeList&lt;EntityArchetype&gt;)を呼び出してNativeList&lt;EntityArchetype&gt;を最新の情報にアップデートしてあげます。
その後EntityManager.CreateArchetypeChunkArray(NativeList&lt;EntityArchetype&gt;, Allocator)を呼び出してNativeArray&lt;ArchetypeChunk&gt;を得ましょう。
今回のプロジェクトは対象プラットフォームがWebGLで完全にシングルスレッドで実行されるのでAllocatorにAllocator.Tempを使用していますが、本来ECSはマルチスレッドで実行されますのでAllocator.Tempだとエラー吐かれますので、Allocator.TempJob以上にしましょう。実際にEntityを処理する際はNativeArray&lt;ArchetypeChunk&gt;をfor文ぐるぐる回して処理します。
各ArchetypeChunkからEntityやComponentDataを得るにはArchetypeChunk.GetNativeArray(ArchetypeChunkEntityType), ArchetypeChunk.GetNativeArray&lt;T&gt;(ArchetypeChunkComponentType&lt;T&gt;を使用します。
引数に与えるArchetypeChunkComponentType&lt;T&gt;は毎フレームEntityManager.GetArchetypeChunkComponentType&lt;Position&gt;(bool isReadOnly)で生成します。
気を付けて欲しいのですが、GetNativeArrayの戻り値であるNativeArrayをDisposeしてはいけません。これは実質Span&lt;T&gt;みたいなものですので、所有権をプログラマーは有していません。ECSが生成し、破棄まで管理しています。さて、Chunk Iterationによりチャンク毎に効率的に処することができるようになりましたね。
今回このシステムは「EntityArchetypeQuery毎にアニメーションするスプライトが全く異なる」という前提のもとに動いています。
つまり、EntityArchetypeQuery, Mesh[], Materialがタプルとなっているわけです。そのためコンストラクタにはValueTuple&lt;EntityArchetypeQuery, Sprite[], Material, float&gt;を与えています。工夫した点は1023要素のMatrix4x4[]をMax(アニメーションのコマ数)個最初に用意し、以後配列をnewしないようにしてアロケーションを最低限にしたことですね。また、TransformSystemを介在させず直接Matrix4x4[]に書き込むことで無駄なコピーコストをなくしています。実行順制御についてはテラシュールブログの記事が詳しいのでそちらを参照してください。BombEffectは爆発を意味するComponentTypeです。
爆発の所属するマス目とその上下左右についてハッシュ値を計算し、NativeMultiHashMapから所属するEntityとその座標を得て衝突判定を行っています。
衝突する場合は破棄予定EntityとしてHashSet&lt;Entity&gt;にAddし、OnUpdateの最後の方にまとめてEntityManager.Existsで生存を確認しつつEntityManager.DestroyEntityしています。Unity.Mathematics.mathという数学クラスがあるのにどうしてベタベタと汚くコードを書いているのか疑問に思うでしょう。
それはUnity.Mathematics.mathのメソッドの大半がSystem.Mathのラッパーメソッドであるからです。しかもfloat&lt;=&gt;doubleの変換を一々伴うので効率が悪いです。
SIMD演算化されて高速に動作するという触れ込みですが、それはBurstでコンパイルされた時に限定されるため、Job Systemを使えないWebGLでは一切使わないのが一番です。弾幕とECSの相性は最高です。自然と大物量を扱うことになりますからね。
WebGLがシングルスレッド強制してくるのとComputeShader使用不可の縛りがもの凄くキツかったですが、unityroomにおける最大物量ゲームの記録を更新できたのではないかと思います。


