More than 3 years have passed since last update.ServiceFabricのWeb系プロジェクトのテンプレートがCoreのみになったので、ServiceFabricのAsp.Net WebApiのプロジェクトをCore化してみた。
ServiceFabric向けなので、.NetFramework上で動作するAsp.Net Coreです。ServiceFabric - Stateless Service
.NetFramework 4.5.2
Asp.Net Core 1.1.2
Asp.Net Mvc Core 1.1.3
MsTest(Unit Test用)
Mock(Unit Test用)web hostはWebListner(試してないですが、kestrelでもたぶん動きます。)主にフィルタ回り。他はほぼそのまま移行できました。① IAuthorizationRequirementを実装した条件設定用のクラスを作成します。
例：Permissionを設定できるRequirementを作成② 型パラメータに先ほどのPermissionRequirementを指定したAuthorizationHandlerを継承したエラーハンドラを作成しHandleRequirementAsyncメソッドを実装します。
例：HttpContextのHeaderから"x-access-token"を取得しIsValid()メソッドで認可する想定です。(IsValid()の実装例は省略)context.Succeedメソッドを実行すると認可されます。
context.Succeedメソッドを実行しないと後述するエラーハンドラにInvalidOperationExceptionが渡されます。
認可エラー時にInvalidOerationException以外のExceptionを投げたい時は認可エラー時に任意のExceptionを投げることで
エラーハンドラ側で取得することができます。
また、Service Fabric以外のアプリケーションでIISにバインドしているときはHandleRequirementAsync内で認可エラー用の
レスポンスを作成すればIIS側でよしなにやってくれます。IISにバインドしない場合はエラーとなるので、
エラーハンドラを実装し認可エラー用のレスポンスを作成する必要があります。③ Startupに認可ハンドラの設定
例：④ エラー時のレスポンスを返すエラーハンドラの設定
例：app.UseMvcより後ろにapp.UseExceptionHandlerを実装するとエラーがハンドルできないので注意
認可処理の時に独自のExceptionを投げてる場合はここで、そのExceptionに関する処理を追加してください。.Net Coreのアクションフィルタは抽象クラス/インタフェース、同期/非同期、DI等用途に応じてさまざまパターンがあります。
今回は抽象クラスを使って実装します。① ActionFilterAttributeを継承したクラスを作成します。await next()の前
　　アクション実行前の処理
await next()の後
　　アクション実行後の処理アクションフィルタのテストをするにはActionExecutionContextとActionExecutionDelegateを作成する必要があります。エラーフィルタもアクションフィルタ同様さまざまなパターンがあります。
今回はインタフェースを使ってグローバルフィルタとして設定します。
また、上記の認可NGの際のExceptionはこちらでは扱えませんので注意が必要です。① IExceptionFilterを実装したクラスを作成します② グローバルフィルタに作成したExceptionFilterを設定しますOnExecuteの引数に渡すExceptionContextのオブジェクトを作成します。
ExceptionContextのオブジェクトを作成する際にHttpContextのMockを作成する必要があります。
テスト対象の処理でHttpContextを利用する場合はSetupでMockの設定をします。.NetFrameworkで動くAsp.Net Coreなので、それほどインパクトはないように思えます。
エラーについてExceptionHandlerにすべてのパターンを実装すればExceptionフィルターの必要はありません。
なんとなくですが(まだ結論が見えてません)私が実装したアプリケーションでは今までIIS側でやってたであろうエラー処理はapp.UseExceptionHandlerで、.Net Mvc側でやってたであろうエラー処理はExceptionFilterで実装しています。


