More than 3 years have passed since last update.ずいぶん昔の科学雑誌『Quark』に載っていたパズルです。チェスのクィーンは、縦横斜めすべての方向に動けます。将棋の飛車と角を合わせた動き方ができます。このパズルでは、さらに盤の左と右をくるっと回してくっつけてクィーンが動けると仮定します。同様に、上と下もくるっとまわしてくっつけ、クィーンが動けると仮定します。このとき、７×７の盤上に、お互いに利き筋にあたらないように７つのクィーンを配置してください。という問題です。解のひとつを以下に示します。１行目にひとつの駒を置いたら、次は、２行目に条件を満たすようにおき、次に、３行目も条件を満たすように駒を置く... とこれを７行目まで続けることで解を求めています。もちろん、途中で条件に合わない場合がでてきますので、その際はひとつ前に状態を戻し、さらに探索を続けることをやります。これを再帰処理を使って実装しています。いわゆるバックトラック法ですね。Solverクラス(後述)でその処理をやっていますが、とても単純なものです。盤面に関する細かな処理をBoardクラス(後述)に委ねている効果ですね。なお、鏡像や回転像も含めて求めています。主要なクラスは、Solverクラスと、Boardクラスです。Solverクラスはパズルを解くクラスで、Boardクラスに駒を置きながらパズルを解いていきます。Boardクラスは、7*7の盤面を表すクラスです。ただし、7×7の盤以外にも対応できるよう、コンストラクタで盤面の幅を渡してもらっています。5, 11などの奇数の整数を与えれば、ちゃんと答えを出してくれます。このBoardクラスは、　他のパズル問題でも利用しているBoardBaseクラスから継承(後述)しています。Boardクラスは、HyperQueenパズルに特化した盤面クラスで、ルールに沿って駒を置けるかを判断したり、駒を置いたり取り除いたりする機能があります。Pieceクラスは、その盤面に置く駒クラスを表しています。HyperQueenを解くクラス。盤面操作の面倒なところはBoardクラスに隠蔽されているので、
Solveerクラスはとてもすっきりしたものになっています。実行結果です。ちょっと長いです。このBoardBaseクラスは、「騎士巡回問題」「ナイト(騎士)の最適配置問題」などで利用したものと同じものです。前述のBoardクラスの基底クラスです。X × Y の盤面を表し、基本的な操作を定義しています。これは似たようなパズルでも再利用できるような汎用的な機能に絞っています。このBoardBaseクラスは、コンソールアプリに依存しない作りにしています。UWP、WinFormsでもそのまま使えると思います。このBoardBaseを継承して、当パズル専用のBoardクラスを定義します。内部では1次元配列を使っていますが、インデクサを定義して、1次元配列、2次元配列としても扱えるようにしています。
ただし、すべてのメソッドで１次元対応と２次元対応のものを用意するのは面倒なので、どちらか一方にしています。まあこれは好み以外の何物でもありません。１次元のインデックスによるアクセスができるようにしている理由は、一重ループで処理が書けるので、コードが簡潔になるからです。LINQのコードも書きやすくなります。2次元配列として見た場合の、X座標、Y座標は、0 からではなく、1から始まります。
つまり、board[1,1] は、いちばん左上を示し、8×8の盤ならば、board[8,8]が右下を示すことになります。なお、盤の周りには番兵用の領域を用意しています。これにより範囲外かどうかの判断を簡単に出来るようにしています。チェスのナイト(騎士)の動きにも対応できるよう、番兵は二重にしています。上の図は 4×4の盤を表していますが、グレー部分が番兵が置いてある盤の周囲で、水色部分が実際の盤です。
盤面上の数値は、１次元配列のインデックスを表しています。なお、派生クラスや派生クラスを利用するクラスが、この番兵の存在に依存しないように、ToDirectionという関数を定義し、X方向、Y方向のペアで表す移動方向(ベクトル)をインデックスで表す方向に変換するようにしています。BoardBaseクラスはジェネリッククラスにしていて、そのパラメータの型は、盤面上に置けるクラスの型です。この記事は、Gushwell's C# Programming Pageで公開したものを大幅に加筆・修正したものです。


