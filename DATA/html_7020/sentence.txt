C++向けのインターフェースはあるのにC#向けのインターフェースがないSDKを使いたいと思っていたところ、Swigに出会いました。
去年にSwigの使い方が少し分かったので以下記事を書きましたが、あまり出来がよろしくありません。
C++で作成したdllをSwigで作ったWrapper経由でC#から呼び出す方法というか自分で言うのもなんですが、上記記事を見ても以下3つのことしか出来ないため、実用的な物を作ることが出来ません。C++で作ったdllをC#で使うことを考える際、最低限以下はサポートしたいと個人的には思っています。ようやく動かすことが出来ましたので、手順を本記事にまとめます。ソースコードはここに格納しています。
プロジェクトとしては以下2つです。
- MyDLL
　C/C++で作成するdllのプロジェクトです。
- CsharpApp
　作成したdllをC#から呼び出すことが出来るのかテスト用のプロジェクトです。今回の環境は以下です。ダイナミック リンク ライブラリ(DLL)のテンプレート選択して、プロジェクト名を入力してください。
今回はプロジェクト名をMyDLLとしています。Header.hというヘッダファイルに下記2のクラスを定義しています。CallbackBase
C#側がこのクラスを継承して、CppClassのSetCallback()で渡すことを想定しています。CppClass
文字列と配列のやり取りをするクラスになります。さっそく中身を見てみましょう。特に躓く部分はないと思います。
CppClassのPrivateで定義されている部分は、本来なら見せたくないのでCppClassを抽象クラスとしたいですが今回のテーマはSwigなので省いています。CallbackBaseは今回作るdllを使う側が継承して作ることになるので、作るのはCppClassということになります。
今回は下記のように実装しています。.hと.cppを作成で来たのでVisual Studio上でビルドしてください。
特に問題なくビルド出来ると思います。
このタイミングで、作成されたdllが公開しているAPIを見てみることにします。
Visual Studioに付属するDeveloper Command Prompt For VS2019を起動してください。
日本語環境下では名前が開発者プロンプトなどかもです。
プロンプト上で、作成されたdllがある場所までcdコマンドで移動して以下コマンドを打ってください。実行すると下の画像のようにCreateInstanceだけが表示されていると思います。
これはGetProcAddress()で取得できる関数のポインタがCreateInstance()しかないことを示しており、意図通りです。Swigを使うためにはインターフェースファイルと呼ばれる.iファイルを作る必要があります。
 書き方の詳細は本家のページを見ていただくとして、それ以外に参考になったページを挙げておきます。では早速.iファイルを作成していきます。最も基本的なインターフェイスファイルは以下になります。(1)には作成するDLL名を、(2)と(3)にはDLLを使う上で必要な情報が記載されているヘッダを書きます。
具体的に(2)(3)に何を指定するのかは 似非AC雑記 : 任意の型の使用に素晴らしい説明がありますので引用します。%{、%}で囲まれた部分は生成される*.cppファイルにそのまま出力される。ここでは型の名前解決のためにヘッダファイルを指定している。
%includeでSWIGが解析を行うファイルを指定する。
このようなインターフェイスファイルを作ったら、以下のようにSWIGに食わせるとラッパの.cppと.hとCSファイルが出力される。.iファイルの役割と書き方が分かったのでさっそく上記コマンドを実行して.cppと.hと.csを出力してみましょう。
(なお、swig.exeを実行するbatをexecSwig.batというファイル名でGithub上位置いていますので、それをダブルクリックしても良いです。)エラーが発生してしまいました。
どうやらHeader.hの31行目がまずいようです。
色々調べると公式ページに下記説明を見つけました。A common problem when using SWIG on Windows are the Microsoft function calling conventions which are not in the C++ standard. SWIG parses ISO C/C++ so cannot deal with proprietary conventions such as __declspec(dllimport), __stdcall etc. There is a Windows interface file, windows.i, to deal with these calling conventions though. The file also contains typemaps for handling commonly used Windows specific types such as __int64, BOOL, DWORD etc.上記に従って、windows.iをincludeするようにしましょう。これで再度swig.exeを実行するとエラーは発生しませんでした。先ほどWidnows.iを加えることで無事swig.exeを実行することが出来、以下ファイルが生成されます。CppClass.csを開くとCppClassが公開しているAPI名が見えます。
以下はCppClass.csの一部です。SetString()の引数がSWIGTYPE_p_std_stringという型になっています。
同様に、SetVector()の引数はSWIGTYPE_p_std_vectorT_float_t型になっています。
SetString()はstring型を使いたいし、SetVector()はListやfloat[]を使いたいのに、何その型？？？
このままでは使いにくいので、.iファイルを以下のようにします。これで再度swig.exeを実行するとCppClass.csで定義されているSetString()やSetVector()の引数が、stringやFloatVectorになっていることが分かります。
FloatVectorはListみたいなものです。
詳細な定義はFloatVector.csに書いてありますが、初見でも問題なく扱えると思います。現状の.iファイルを使ってswig.exeを実行するとファイルが作られました。これで.iファイルは完成だ！と思いきや実はコールバックをするためにはまだ細工が必要です。
公式のページに詳細の説明があるのでそちらを参照していただくとして、最終的な.iファイルは下記のようになります。上記.iファイルを使用してSwig.exeを実行すると以下のファイルが作られます。ではdllにC#向けインターフェースを追加してみます。
手順としては、先ほどSwig.exeを実行して作成されたSwig_wrap.cppをプロジェクトのソースファイルに追加して改めてビルドするだけです。
はい、これだけでC#向けのインターフェースが作成されます。
.iファイルさえ作ることが出来ればC#向けのインターフェースを作るのは簡単ですね！実際にビルドして作られたdllにdumpbinを実行して本当にAPIが増えたのか見てみましょう。実行すると下の画像のようにCreateInstance以外も表示されていると思います。
APIがすごく増えていますね。
C#側はこの増えたAPIを経由して、CppClassにアクセスすることになります。
増えたAPIですが、C++側でGetProcAddress()で取得することが出来るはずです。
やる意味ないですが...C#で作成するコンソールプログラムから作成したdllが呼び出せるか確認します。
プロジェクト名はCSharpAppです。することは3つだけです。特に説明も不要だと思いますのでコードを貼り付けます。では実際に動作するか見てみましょう！意図した通りに動いていますね！この記事ではSwigの使い方と、実際にdllにC#向けのインターフェースが追加されることを確認しました。
期待した通りに追加され、C#側で問題なく使用できることを確認しました。本当は配列を受け取る、配列を返すというものをやりたかったのですが配列を返す方法が分からなかったので断念しています。
誤字脱字や認識間違い等あればご指摘ください。


