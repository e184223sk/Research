More than 1 year has passed since last update.今回、このまとめを上梓するに当たり、多くの方からベンチマークデータの提供を受けました。これらの提供がない限りこのまとめを書くことは出来なかったので、ここで心からお礼申し上げます。とっても簡単。.NET Core上のC#で配列のループ処理に対して、for使うが速いかforeach使うが速いかどっちなの?と言う話。御託は良いから、結果よこせって人はこっからジャンプこのセクションでは以下の考察を行った。また、提供を受けた様々なCPUでベンチマークを実行した結果の提示を元に考察した。BenchmarkDotNetで以下のコードを書き、多くの方から、様々なCPUの結果を頂きました。使ってる配列のサイズがバカみたいにでかいのは、BenchmarkDotNetでIterationを1にしたかったからだけど、正直やりすぎたと思うし、もしかしたらこれが擾乱要因担ったかも知れないと反省。IntSumForメソッドをコンパイルした結果は以下の通り。また、IntSumForeachは以下の通り。ここで注目すべきなのは、IntSumForeachの方が、int32型のローカル変数が多い。これは、foreach(var i in _array)のiに相当していて、1度iに代入してからそれをaccumに加算している形になる。さて、ILを検証してきたけど、実際問題ILが直接解釈されて実行されるわけじゃなく、最終的にJITされた結果、x64アセンブリになる。ここでは、JITされた実際の実行コードを検証してみたい。IntSumForは以下の通り。また、IntSumforeachは以下の通り。さて、ここで、気になるのは、先のILであった、SumForeachのiへの代入が実際JITされたらどうなるのか?ってことだけど、実はしっかり残ってる。IntSumForを眺めると、add     edx,dword ptr [rax+r9*4+10h]で、直接配列の要素をedxレジスタに加算してる。他方、IntSumforeachの場合、mov     r9d,dword ptr [rdx+r9*4+10h]と、r9dレジスタに1度配列の要素を代入した後、add     eax,r9dでeaxレジスタに加算している。今回の考察には全く関係ないけど、forでもforeachでも、カウンタ相当のレジスタはecxとなってる。けれど、どちらの例でも、movsxc (r8/r9),ecxと他のレジスタへコピーされてから、コピー先の値を伴って配列の要素へのアクセスを行っている。このようなことをなぜするのか、知人と議論したところ、1度コピーしてそれをアドレス指定に使うことで、続く、inc ecxと操作が独立となって、パイプラインにうまく収まるコトを企図しているのではないかという知見を得た。従って、メモリへのアクセスはキャッシュにヒットするか否かで大きくアクセスコストが変化するので、レジスタ間のコピーコストを支払ってでも独立させておいた方が有利なのではなかろうかと考えた。このエントリを公開後、知人から、
ループカウンタは32bit、アドレスのインデックスアクセスは64bitなので、別管理にする必要があるのでは無いかと言う指摘を受けた。指摘を受けた後、確かにmovでは無く、movsxdになっているので1 、先の推測よりこちらの理由の方が確度が高いかと考えた。さて、このようにIntSumforeachの方が、レジスタへの代入とは言え、冗長な処理を行っている。それもこのベンチマークではその冗長な処理が900,000,000回も発生するので、IntSumForeachの方が遅く、IntSumForの方が速いのではないかと考えた2。次回以降で、先の通り、実際に提供を受けたベンチマークデータを元に考察していこうかと思います。そりゃ、ecxは32bit転送先のr~は64bitなので、拡張転送は必須じゃある。 ↩そして、その考えはもろくも崩れ去るわけだけどw ↩


