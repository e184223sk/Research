More than 3 years have passed since last update.ずっと昔の話なのですが、.net 2.0以前ではコレクションクラスの数が少なく、ソート済みリストをプログラムで使用するには SortedList しか選択肢がありませんでした。
SortedListは期待どおりソート済みのリストを提供してくれるのですが、如何せんデータ構造が配列であるため、ランダムな値の追加を繰り返すと、並び替え時に値が挿入、移動されてパフォーマンスの劣化がひどいものでした（当時は 1万件こえるなら、ArrayListにして追加後にソートとして処理していたほうが良かったと覚えています）
そのため、何か良いアルゴリズムはないものかと調査して、シーケンシャルアクセスの容易さから B+木を選択実装してみました。上記の理由のとおり、元々はずっと昔の Visual Basicのコードを焼き直したものになります。別に C/C++ 版もありますが、しばらく公開はしないでしょう。
当時の知識での実装であり、コンバートでもあるため、間違いもあるのでしょうが、許してください。
ソースは GitHub にアップロードしています（同梱されている Deckクラスは別の目的で用意したものなので本文章と無関係です）B+木はシーケンシャルな要素アクセスに強みを持っています。それは値を持つノードとノードを持つノードが区別されていて、値を持つノードがリンクリストで表現されているためです。{0,1,2,3,3,5,5,6,8,9,11,11} という値を格納した B+木は以下の図のようになります。値は〇で表現しています。図で示すとおり、値は木構造の最下層のみに紐付いており最下層のノードは同じ最下層のノードとリンクしています。リンクを辿ることでシーケンシャルなアクセスを表現できるのです。
詳細な B+木のアルゴリズムについてはWiki等参照いただければと思います。現在の .net 標準コレクションでは SortedList、SortedDictionary、SortedSet があります。
今回実装した B+木コレクションは上記のコレクションとは以下の違いを持たせています。性能について、簡単な比較を以下のコードで行ってみました。
（実際に使用する場合はメモリの使用量など別の要件もあるので、参照程度と意識してください）
（実行環境は core i5-8250U 1.6GHzです）追加と削除はSortedSet に負けてないですね。
効率的なアルゴリズムを調査、パフォーマンスチューンを行えば、もっと良くなるかもしれません。このようなデータ構造は、知識の引き出しとして幾つか持っておくと便利です。
記憶の片隅にとっておいて下さい。


