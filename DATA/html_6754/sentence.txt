C# Advent Calendar 2016の記事です。社内勉強会の資料をリライトしました。新人研修を終えてそれなりにC#が書ける程度の新人が想定読者です。LINQを自力で実装するために必要なC#の知識をまとめています。LINQの詳細な動作を知ると様々な応用がききます。ぜひ知っておきましょう。具体的には次のコードが理解できるようになるのが目標です。短いコードに様々な要素が詰め込まれています。このテキストを読むとこのコードの意味がわかるようになります。そのために以下の機能を順に紹介します。勉強会に参加したりWebで情報収集をしていると知らない単語や概念が頻繁に出てきます。一度に全て理解しようとするのは難しいと思います。まずはその技術で何ができるのかを大まかに覚えてください。それが必要になったときに「そういえばあんな機能があったな」と思い出せるようになりましょう。詳しい使い方はそのときに検索して調べれば大丈夫です。このテキストでもそれぞれの機能で何ができるかを中心に紹介しています。詳細な文法が必要になったら自分で調べてください。Genericsを使うと型をパラメータ化できます。それによって同じアルゴリズムを違う型に適用できます。具体的にClampメソッドを実装しながらGenericsを説明します。Clampメソッドは、指定された数値を最小値と最大値の範囲に丸めて返すメソッドです。第1引数に「範囲内に丸めたい数」、第2引数に「最小値」、第3引数に「最大値」をそれぞれ指定します。例えば以下のように使えます。まずはGenericsを使わずに実装してみます。例えば以下のようになります。このメソッドは引数がintの場合にしか使えません。doubleでも使うには、intをdoubleに変えただけのメソッドを別に定義しなければなりません。さらにfloatやdecimalなど他の型でも使おうとするたびに新しいメソッドが必要です。似たようなコードが何度も書かれていることは悪いコードの特徴です。このように、中身がほとんど同じコードをいろいろな型で使いたいときにGenericsを使います。Genericsを使った実装は以下になります。Clamp&lt;T&gt;のように&lt;&gt;で囲って型パラメータを書きます。ここではTを型パラメータとして使うことを宣言しています。これよって、このメソッドでTを抽象的な型として使えます。このTは実際にメソッドを呼び出す際にintやdoubleなどの具体的な型に置き換わると考えてください。where T : IComparable&lt;T&gt; はTの制約条件です。ただのTでは抽象的すぎて何もできません。Clampメソッドを実装するにはT型のvalue, min, maxの値の大きさを比較する必要があります。比較ができるように「TはIComparable&lt;T&gt;インターフェースを実装している」という制約条件をつけています。IComparable&lt;T&gt;を実装していない型ではClmapメソッドを使えなくなってしまいますが、intやdoubleなどC#組み込みの数値型はIComparalbe&lt;T&gt;を実装しているので問題ありません。メソッドの中では値を比較するためにCompareToを使っています。CompareToはIComparable&lt;T&gt;で宣言されているためT型のvalue, min, maxでも使えます。拡張メソッドはクラス、インターフェース、列挙型のような型の定義の外からメソッドを追加できます。拡張メソッドの使い方を説明するため、上下左右の方向を表すDirection列挙型と指定された方向から右を向くTurnRightメソッドを実装してみます。拡張メソッドを使わなければ以下のように実装できます。C#では列挙型にメソッドを定義できません。そのため、TurnRightメソッドをDirectionHandlerという別クラスに定義しています。これは以下のように使えます。右を向くだけのことにdir = DirectionHandler.TurnRight(dir)というのは長すぎます。もし列挙型にメソッドを定義できてdir = dir.TurnRight()と書ければ便利です。拡張メソッドを使うとそれが可能です。拡張メソッドを使った実装は以下になります。拡張メソッドなしの実装から変更したのは1箇所だけです。TurnRightメソッドの引数がthis Direction dirと先頭にthisがついています。これによって、TurnRightメソッドがDirection型の拡張メソッドになります。これは以下のように使えます。コードが短くわかりやすくなりました。拡張メソッドは「対象の型の定義の外にあるstaticメソッド」をインスタンスメソッドのように呼び出せるようになる機能です。先ほどの例ではTurnRightメソッドはDirection型の外に定義されています。しかしdir.TurnRight()とDirection型のメソッドのように呼び出せています。拡張メソッドの利点の1つとして、拡張メソッドはインテリセンスで補完できます。ここでは「dir.」を打ち込んだ時点でTurnRightが自動補完の候補として表示されます。Direction型を使うときは、本当はDirectionHandlerというクラスがあることすら知らずにすみます。また、TurnRight()メソッドを複数回呼び出す際に dir.TurnRight().TurnRight() のようにつなげて記述できます。拡張メソッドなしではDirectionHandler.TurnRight(DirectionHandler.TurnRight(dir))のようになります。さらにTurnLeft(左回り)やTurnAround(回れ右)のようなメソッドを追加したとしましょう。拡張メソッドではdir.TurnRight().TurnAround().TurnLeft()のように自然な形でメソッドを組み合わせられます。同じ処理を拡張メソッドなしで書くとDirectionHandler.TurnLeft(DirectionHandler.TurnAround(DirectionHandler.TurnRight(dir)))になります。拡張メソッドの方が短くわかりやすいはずです。メソッドが実行される順番とコード上で現れる順番が一致するのもわかりやすくなるポイントです。TurnRightしてからTurnAroundしてさらにTurnLeftする、ということがそのまま読み取れます。次はインターフェースの拡張メソッドの例です。Genericsの説明でも使ったIComparable&lt;T&gt;に拡張メソッドを追加します。IComparable&lt;T&gt;のCompareToメソッドは、自身と引数に与えられた値を比較して、自身の方が大きければ「0より大きい整数」、同じなら「0」、小さければ「0より小さい整数」を返します。なんだかわかりづらくないでしょうか。1わかりやすい名前を拡張メソッドで付けてみます。これは以下のようになります。この拡張メソッドは以下のように使えます。IComparable&lt;T&gt;の定義は全く変えず、外からメソッドを追加できました。デリゲートを使うとメソッドを変数に代入できます。説明のために掛け算の表と足し算の表を出力するプログラムを実装してみます。デリゲートを使うと以下のようになります。PrintOperationTableメソッドは第1引数にメソッドを受け取り、それを使って計算した結果を表として出力します。実行したときの出力もすぐ下に載せています。PrintOperationTableの引数にAddを渡すかMultiplyを渡すかでPrintOperationTableの出力結果が変わっています。public delegate int Operator(int x, int y); がデリゲートの宣言です。Operatorを「int x, int yという2つの引数を受け取ってintを返すメソッドのデリゲート」として宣言しています。この宣言したデリゲートをPrintOperationTableの引数に使ってメソッドを受け取ります。Operatorデリゲートに代入できるのは引数と戻り値が一致するメソッドのみです。例えば引数がint3つになれば他のデリゲートを宣言しなければなりません。デリゲートを使うたびにいちいち宣言するのは面倒です。そのため、よく使う種類のデリゲートはC#のライブラリで用意されています。これを使うと以下のように書き換えられます。変更点は2箇所です。Operatorの宣言がなくなり、PrintOperationTableの引数もOperatorからFunc&lt;int, int, int&gt;になっています。Func&lt;int, int, int&gt;はintの引数を2つ受け取りintを返すメソッドのデリゲートです。&lt;&gt;の中に引数と戻り値の型を指定して様々なデリゲートを定義できます。Func&lt;bool&gt;なら引数なしでboolを返すメソッド、Func&lt;double, float&gt;なら引数がdouble1つでfloatを返すメソッドのデリゲートになります。ここでは使ってませんが、Actionというデリゲートも用意されています。これはFuncの戻り値が無いバージョンです。Actionなら引数なし、Action&lt;int, bool&gt;なら引数にintとboolをとるメソッドのデリゲートです。PrintOperationTableにAddメソッドとMultiplyメソッドを渡していますが、実際に渡している箇所と定義部分が離れていて少しわかりづらいです。ラムダ式を使うとメソッドをインラインで書けるようになります。これを使うと以下のように書き換えられます。Add, Multiplyメソッドがなくなり、PrintOperationTableを呼び出すときにラムダ式を使っています。コードが短くなり、一連の処理が1箇所にまとまって読みやすくなりました。なお、(x, y) =&gt; x + y は最大限に省略した書き方です。これを省略せずに書くと以下のようになります。ここではFunc&lt;int, int, int&gt;として渡すことが分かっているので引数の型であるintは省略できます。省略すると次のようになります。さらに、ラムダ式の中身がreturnの一文だけの場合はブロックの{}とreturnを省略できます。すると(x, y) =&gt; x + yになります。IEnumerable&lt;T&gt;, IEnumerator&lt;T&gt;インターフェースではデータを順番に取り出すためのメソッドとプロパティが宣言されています。ListやDictinoaryのようなコレクションはIEnumerable&lt;T&gt;を実装しており、要素を取り出す処理を共通に使えるようになっています。IEnumerable&lt;T&gt;ではGetEnumeratorメソッドのみ宣言されています。このメソッドは引数なしで戻り値がIEnumerator&lt;T&gt;型のオブジェクトになります。詳しくは次のIEnumerator&lt;T&gt;と一緒に説明します。IEnumerator&lt;T&gt;には1つのプロパティと2つのメソッドが含まれます。簡略化すると次のような形です。IEnumerable&lt;T&gt;とIEnumerator&lt;T&gt;の機能を使うと、Listの要素を最初から順に出力するコードは以下のようになります。この例の通り、IEnumerable&lt;T&gt;, IEnumerator&lt;T&gt;は一般に以下の流れで使います。これはListに限らずIEnumerable&lt;T&gt;を実装しているクラスなら共通に使えます。foreachはこの1~4を自動的に実行してくれます。先ほどのListの要素を順に出力するコードをforeachで書き換えると以下になります。コード上に書かれてはいませんが、実際にはGetEnumeratorやMoveNextが呼び出されます。IEnumerable&lt;T&gt;とIEnumerator&lt;T&gt;のさらなる理解のため、簡単なコレクションクラスを実装してみます。仕様は以下の通りです。実装は以下になります。このクラスは以下のように使えます。IEnumerable&lt;T&gt;を実装すればforeachが使えるようになります。DozenIntegersクラスで実装してみましょう。しかし、実装する前にもう少しIEnumerable&lt;T&gt;とIEnumerator&lt;T&gt;について知らなければなりません。まず、IEnumerable&lt;T&gt;はIEnumerableを継承しています。そして、IEnumerator&lt;T&gt;はIEnumeratorとIDispose&lt;T&gt;を継承しています。つまりIEnumerable&lt;T&gt;を実装するにはIEnumerableも実装する必要があり、IEnumerator&lt;T&gt;を実装するにはIEnumeratorとIDisposeも実装する必要があります。これらのインターフェースについて説明します。IEnumerableはIEnumerable&lt;T&gt;と同じくGetEnumeratorメソッドのみが宣言されています。IEnumerable&lt;T&gt;.GetEnumeratorの戻り値はIEnumerator&lt;T&gt;でしたが、IEnumerable.GetEnumeratorの戻り値はIEnumeratorになります。IEnumeratorはIEnumerator&lt;T&gt;と同じくMoveNext, ResetメソッドとCurrentプロパティが宣言されています。IEnumerator&lt;T&gt;とIEnumeratorの唯一の違いは、Currentプロパティの型がIEnumerator&lt;T&gt;ではT、IEnumeratorではobjectになっている点です。IDisposeでは唯一Disposeメソッドが宣言されています。戻り値と引数はありません。Disposeはそのオブジェクトを使い終わったときに呼ぶことになっています。使用したリソースの解放のような後処理をするメソッドです。以上をまとめると、これから実装するforeach対応のDozenIntegersクラスは以下のようなクラス図として表せます。IEnumerator&lt;T&gt;はDozenIntegers.Enumeratorクラスとして実装します。GetEnumeratorとCurrentは戻り値の型が異なる2つのバージョンを実装する必要があります。実装は以下になります。必要なメソッドが多くコードが長いです。しかし内容は簡単なので読んでみてください。GetEnumeratorメソッドと、そこで返すためのEnumeratorクラスが追加されています。簡単に実装の説明をします。GetEnumeratorメソッドはEnumeratorクラスのオブジェクトを生成して返します。以降の処理はIEnumerator&lt;T&gt;を実装しているEnumeratorクラスの責任になります。IEnumerator.GetEnumeratorとしてIEnumeratorのGetEnumeratorも実装しています。このような定義の書き方をインターフェースの明示的実装といいます。動作はIEnumerable&lt;T&gt;のGetEnumeratorと同じなのでそのまま呼びます。Enumeratorクラスのコンストラクタでは生成元のDozenIntegersオブジェクトを受け取ります。ここからデータを取得します。MoveNextメソッドでは次の位置に移動します。現在の位置をindexに保持しているのでインクリメントします。Currentプロパティではindexの位置のデータを取得して返します。Disposeメソッドでは何もしません。Enumertorの中で解放するべきリソースなどを使っていればここで解放します。ResetメソッドはLINQ to Objectの範囲ではまず使いません。未実装にしてあります。foreachに対応したDozenIntegersは以下のように使えます。自作コンテナをforeachに対応するとコードが長くなり大変です。イテレータ構文を使うとforeachの対応が簡単になります。foreachに対応したDozenIntegersを改良すると以下のようになります。GetEnumeratorメソッドのyield returnがイテレータ構文です。Enumeratorクラスが丸ごと無くなりました。これでも先ほどのDozenIntegersと同じ動作をします。イテレータ構文(yield return)の動作を説明します。yield returnはIEnumerableを返すメソッドの中でしか使えません。ここではGetEnumerator()メソッドで使っています。GetEnumerator()が呼び出されたときにGetEnumeratorの中身は実行されません。その代わり、yield returnなしのバージョンのGetEnumeratorと同じことが起きると考えてください。つまりIEnumerator&lt;T&gt;を実装したDozenIntegers.Enumeratorクラスが生成されて返されます。しかし今回のコードではDozenIntegers.Enumeratorクラスを定義していません。実はyield returnの機能として、DozenIntegers.Enumeratorに相当するクラスが自動的に定義され使われています。この自動生成されたEnumeratorクラスのMoveNext()が呼ばれたときに初めてGetEnumeratorクラスの中身が実行されます。次のようなコードをVisual Studioのステップイン実行で追いかけると実際の動作がわかりやすいです。最初のe.MoveNext()でGetEnumerator()の中身が実行されます。しかしMoveNext()は次の要素があればtrue、なければfalseを返すメソッドのはずです。つまりGetEnumerator()の中身がそのままMoveNext()として実行されるわけではありません。GetEnumerator()の中身は、MoveNextが呼ばれたときに次の要素を生成するコードです。yield returnで返した値が次の要素として扱われます。yield returnを通らずメソッドの最後まで実行されると次の要素がないことを表します。yield returnには次の要素を返すほかに、もう1つ重要な役割があります。値を返した時の状態を記憶しておいて、次にMoveNext()が呼ばれたときに次の行から実行を再開する機能です。2回目以降のe.MoveNext()ではGetEnumerator()の最初からではなく、前回yield returnで戻った時の状態から再開されます。これによってe.MoveNext()を呼び出すたびに次の要素を順に取り出せます。実行の途中で中断したり、中断した状態から再開できるメソッドをコルーチンと言います。C#のイテレータ構文はコルーチンとしての機能と要素を列挙する機能が複合していて理解しづらいです。他の言語のコルーチン機能を調べてみると理解の助けになります。(参考:PHP のコルーチンを使ってみる)コルーチンは状態を持てるメソッドです。通常のメソッドは一度呼び出したら終わりで状態を持てません。クラスは状態を持てて何でもできます。コルーチンはメソッドとクラスの中間のようなものと考えられるかもしれません。特に「ひとまとまりの機能だが何回かにわけて実行される」ような機能を作るのに適しています。要素を順番に取り出す処理はその典型的な例です。コルーチンの簡単な例として以下のコードを見てください。RPG風のゲームで3ターンかけてスライムに切りかかります。要素を生成する機能としては使わないのでyield returnではnullを返します。実行すると以下のように出力されます。AttackメソッドをMoveNext()を呼ぶたびにyield returnの続きから実行できるメソッドとして使っています。イテレータ構文の機能は「MoveNext()で処理が再開するついでにyield returnの戻り値がCurrentプロパティに入る」程度のイメージの方がわかりやすいかもしれません。同じことをコルーチンなしで実装しようとするとモンスターの名前や現在の状態をメンバ変数に覚えておかなければなりません。この程度の機能にクラスを書くのは少し面倒です。これは簡単な例でしたが、普通に書くといくつかのメソッドに分かれてしまうような記述を1つのメソッドにまとめて書いたりできるようになります。LINQを理解するのに必要な機能は説明し終わりました。実際にLINQを実装してみます。Selectの実装は以下になります。このテキストの一番最初に載せたコードです。どのように動作するかわかるでしょうか。第1引数をthis IEnumerable&lt;TSource&gt; sourceとしてデータを取り出すIEnumerableを受け取ります。thisがついているのでIEnumerable&lt;TSource&gt;の拡張メソッドです。Genericsを使ってIEnumerable&lt;int&gt;やIEnumerable&lt;double&gt;など、いろいろな型に対して使えるようにしています。第2引数のFunc&lt;TSource, TResult&gt; selectorはTSource型を受け取ってTResult型を返すメソッドのデリゲートです。IEnumerable&lt;TSource&gt;の要素であるTSourceを受け取り、戻り値のIEnumerable&lt;TResult&gt;の要素であるTResultを返すためこうなっています。foreach (var item in source)ではsourceから順に要素を取り出してitemに入れています。IEnumerable&lt;T&gt;を実装していればforeachが使えることを思いだしてください。yield return selector(item);では取り出した要素をselectorに渡して呼び出します。その戻り値は変換されたTResultを次の要素としてそのまま返します。Whereの実装は以下になります。ほとんどSelectと同じです。selectorで変換するのではなくpredicateで条件に合う要素を取り出します。LINQのメソッドの多くは似たような形になっているので1つ理解できれば大体わかるようになります。SelectとWhereで返される値はIEnumerable&lt;T&gt;です。よってLINQやforeachが使えます。ここではわかりやすいようにメソッドごとに分けていますが、通常はlist.Where(x =&amp;gt; x % 2 == 0).Select(x =&amp;gt; x * 2)とつなげて書くことが多いです。このようにメソッドをつなげて使うことをメソッドチェーンと言います。このコードが実行されると次のシーケンス図のような流れで動作します。foreach (var item in doubledEnumerable)で最初の要素を取得する際の図になっています。SelectとWhereの動きがわかったところでLINQの機能を拡張してみます。例としてLINQの間に挟んで要素の内容を出力するTraceメソッドを実装します。例えば以下のように使えます。上記ではWhereでフィルタリングされた直後の値が出力されるので2,4,6,8が出力されます。実装は以下のようになります。次の値を取得したらConsole.WriteLineで出力しているだけです。値はそのままyield returnで返します。foreach - C# によるプログラミング入門
より正確なforeachの動作が説明されています。このテキストのforeachの説明はかなり簡略化しています。Reimplementing LINQ to Objects
WhereとSelectだけではなく全てのLINQのメソッドを解説しながら実装しています。エラー処理も含めてしっかり実装されています。LINQのメソッドはなかなか覚えきれませんが一度作れば忘れません。LINQの仕組み＆遅延評価の正しい基礎知識
LINQの動作について説明されています。このテキストだけでなく他の方による説明も読むとさらに理解が深まるはずです。実際の実装
C#のライブラリはオープンソースになっています。本物のLINQのコードもここから読めます。最後の0まで含めてメソッドの一部として覚えましょう。a.CompareTo(b) &gt; 0はa &gt; bという意味です。a.CompareTo(b) == 0はa == b、a.CompareTo(b) &lt;= 0はa &lt;= b として解釈できます。aとbの間に演算子がそのまま入ります。 ↩


