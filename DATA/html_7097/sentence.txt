More than 5 years have passed since last update.前回の記事で書いた「カスタムエディタ」は特定のクラス全体のインスペクタGUIを変更する方法でした。今回書くのは、それのプロパティ版です。
特定クラス全体ではなく、プロパティとして定義されたクラスのインスペクタ上の表現を変えるものです。今回これを作った経緯は、今作っているコンテンツで、エンジニアとプランナーで分担して作業をしたかったからです。
そのため、Prefab単位でオブジェクトを作ったり、あるいは汎用的なクラスを作ってそれをアタッチしてもらい、さらにそれを今回のプロパティに設定してもらうことで、各イベントとメソッドを橋渡ししたい、と思ったからです。具体的な実装例としては、2D UIのButton要素にある、イベントリスナを設定するやつを思い浮かべてもらうといいと思います。まさにあれを実現したい感じでした。↓これ
そして実際に実装したやつをアタッチした状態がこんな感じです↓
今回はあまり凝ったことはせず、該当オブジェクトにアタッチされているコンポーネントリストから、 public でかつ引数がないメソッドだけをリストするようにしています。具体的な使い方は、↑の画像で説明すると、Target となっているプロパティに、実行したいメソッドを持っている GameObject を設定します。
すると、対象となったオブジェクトに設定されているコンポーネントリストから、上記の条件にマッチしたメソッドを抜き出し、リスト化します。そしてそれを表示しているのがサンプル画像の選択されている部分です。
例では Door クラスの Open と Close がリストされている、というわけです。もちろん、もし仮にこれ以外のコンポーネントがアタッチされていて、かつそのクラスが引数なしの public メソッドを持っている場合は同じようにリストされます。実装についてはコードを全文載せておくのでそれを見てもらうといいと思いますが、今回実装した中でポイントとなる部分を。最初、Reflectionの機能を使ってメソッドを抜き出すまではすぐできたんですが、ポップアップ部分の階層構造（ネスト構造）を作る部分が分からず悩みました。
が、分かってみたらなんのことはなくて、階層構造を作りたい場合は / で区切ればいいみたいです。
（よくよく考えてみると、Unityはその他の部分でも / を使うことで階層構造を作れることが多いですよね）なので、↑の例では単純に Door/Open と Door/Close というふたつの要素を指定しているに過ぎません。
あとは勝手にUnityエンジン側でこれを階層構造と見なして制御してくれます。さて、最後に、今回作成したクラスとそのカスタムプロパティの実装コードをそのまま載せておきます。さて、まずはメインとなるクラスから。
これは、他の MonoBehaviour なクラスのプロパティとして利用されることを想定しているクラスです。（なので MonoBehaviour は継承していない）実装はそんなに複雑ではありません。
前述したように、ターゲットとなる GameObject を指定できるように public の Target メンバを定義します。
ここにアタッチされたオブジェクトからメソッドを抜き出すわけですね。さて、設定されたメソッドを実行するのは Invoke メソッドです。
ここではReflectionを使って該当コンポーネントを見つけ、さらにそのメソッドを実行しています。あまり行数もないので読んでもらうのが早いかなと思います。さて、今回の記事のメインとなる部分です。
上で書いた EventHandler クラスをプロパティに持つ、 MonoBehaviour なコンポーネントがインスペクタに表示された際に、それをどう表示するかを決める部分です。最初、形だけは思い通りの形になったんですが、左側の▼をクリックしても展開したり閉じたり、という状況が作れませんでした。
それを実現するには以下のような感じにするといいようです。
（ドキュメントとかからではなく、試行錯誤の結果なので正規のやり方ではないかも）


