More than 1 year has passed since last update.タイトルの通りですが、勉強のためC#からC++のDLLへデリゲートを渡すサンプルコードを作成してみました。仕様のイメージは以下の通りです。ようは、DLL内部の処理のプログレスを、都度、C#側にコールバック関数経由で通知するイメージです。実装を見れば分かるように、プログレス情報は文字列で渡されています。ここは整数で受け渡しするのが自然だと思いますが、おそらくハマるであろう「C#／C++間でワイド文字列を受け渡しする」勉強のために、不自然ながらもそのように実装しました。なお、DLLファイルは、32ビット／64ビットの両プロセスに対応させるため、それぞれに対応した「TestDll32.dll」「TestDll64.dll」の2種類をコンパイルして生成しています。これらはファイル名が異なるだけで、ソースファイルは共通です（詳細は「謝辞」を参照下さい）。登場人物を紹介します。登場人物を紹介します。C#側からC++側へワイド文字列を渡すのは簡単にできたのですが、C++側からC#側へ（コールバック関数の引数経由で）文字列を渡す所でハマりました。デリゲートを定義するさい、以下のように引数（string message）のマーシャリングを指示する必要があったようです。正直、マーシャリングの原理があまり理解できていないので、おいおい調べていきたいと思います。DLLの作成方法と、32ビット／64ビットの両プロセスへ対応するためのラッパー関数の実装は、こちらの記事とコメントを参考にさせていただきました。ありがとうございます。「C#からC/C++の関数をコールする方法　まとめ①」上記では、C#もC++もVisual Studio上で実装し、Windows上で動かしてみた実験ですが、今回はというのもやってみました。使用するソースコードは前述のもの（Program.cs）と一字一句同じです。
ビルド方法は以下の通り。bin\Release\netcoreapp3.1\linux-x64\publish\配下のアセンブリ一式を、Linux上の任意の場所に配置します。Windows版からの主な変更点として、LPWSTRをchar16_t *に変更しました。コンパイルしたdllは、.NET Coreのアセンブリ一式を配置したディレクトリにコピーしておきます。C++側での文字列型の扱い。精進します。


