角度を普通にfloatやdoubleで扱おうとすると、次のような問題が発生して扱いづらいです。これらの問題を専用の変換メソッド等を用意して解決しても良いのですが、グローバルなメソッドにすれば角度以外のfloat値に対して適切ではないメソッドが呼べてしまうし、必要な部分だけにスコープを限定したメソッドとして定義すれば再利用性が失われてしまいます。それに、「角度」のように何らかの意味のある数値として扱う場合は、プリミティブ型をそのまま代用するのではなく、専用のオブジェクトとして定義したほうが、専用の操作をオブジェクト内に隠蔽することができるため、可読性や保守性に富みます。というわけで、角度を表すAngle構造体を作りました。作成したAngle構造体の機能を紹介します。
今すぐコードが見たい方はこちら。度数法と弧度法を混同させないため、コンストラクタは隠蔽しています。
その代わりに各種ファクトリメソッドを用意しています。度数法の値からAngle構造体のインスタンスを取得します。周回数を指定することもできます。弧度法の値からAngle構造体のインスタンスを取得します。こちらも同様に、周回数を指定することもできます。角度が0のAngle構造体のインスタンスを取得します。角度が360°のAngle構造体のインスタンスを取得します。各種変換メソッドを提供します。
イミュータブルな設計とするため、変換メソッドを実行しても元のインスタンスは変更されず、新しいインスタンスを返すようになっています。角度を-180°&lt;θ&lt;=180°の範囲で正規化します。例えば、225°の角度は-180°&lt;θ&lt;180°の間には入っていないため、-135°に正規化されます。同様に、-450°は-90°に正規化されます。角度を0°&lt;=θ&lt;360°の範囲で正規化します。例えば、-135°を0°&lt;=θ&lt;360°の範囲に正規化すると、225°となります。同様に、-450°は270°に正規化されます。Reverseメソッドは、次のように見た目上の角度を変更せずに、方向のみを反転させます。SignReverseメソッドは、角度の符号を単純に反転させます。Absoluteメソッドは、SignReverseメソッドの正の方向への片道切符バージョンです。Angle構造体から角度情報を取得することができます。角度値を度数法で取得します。角度値を弧度法で取得します。Normalizeした角度値を度数法で取得します。NormalizedDegreeプロパティの弧度法バージョン。NormalizedDegreeプロパティのPositiveNormalizeしたバージョン。PositiveNormalizedDegreeプロパティの弧度法バージョン。角度が何周しているかを取得します。角度が1周以上回っているかどうかを取得します。角度が360°の倍数かどうかを取得します。正の方向への角度かどうか取得します。各種演算子をオーバーロードしており、プリミティブ型と同じように各種演算をすることができます。角度を加算/減算します。角度を実数で乗算/除算します。角度の大きさを比較します。次の2つのインターフェイスを実装しています。等価性比較のためにIEquatable&lt;Angle&gt;インターフェイスを実装しています。==演算子があるのにわざわざIEquatable&lt;Angle&gt;インターフェイスを実装するメリットはこの記事が参考になりますが、要約すると次のようになります。このような理由から、構造体の場合は基本的にIEquatable&lt;T&gt;インターフェイスを実装したほうが良いようです。LINQのOrderByメソッドやMax,Minメソッドを利用できるようにするためにIComparable&lt;Angle&gt;インターフェイスを実装しています。object型に定義されている次のメソッドをオーバーライドしています。周回数と残りの角度を返します。ToStringをオーバーライドしていると、VisualStudioのデータヒントにも同様のフォーマットで表示されるので便利です。
IEquatable&lt;Angle&gt;インターフェイスのEqualsメソッドも実装したのですが、objectクラスのEqualsメソッドもオーバーライドしています。
理由としては、前述の通りEquals(object o)メソッドの既定の動作が全フィールドの等価性比較であること、しかもそれがリフレクションによる比較であるためです。
Angle構造体は内部で持つ角度値を単純に比較するだけで良いので、リフレクションを使う既定の動作をオーバーライドして封印します。ちなみに、VisualStudioでは==演算子をオーバーロードするとEqualsメソッドとGetHashCodeメソッドもオーバーライドしなさいと警告が出ます。
==演算子をオーバーロードしている→自前で等価性比較処理が書けている→既定のEqualsを使う必要がない→だったらオーバーライドしろ、ということですね。
GetHashCodeメソッドはDictionaryのキーとして使うときに使われるようです。A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the Dictionary class, the Hashtable class, or a type derived from the DictionaryBase class. The GetHashCode method provides this hash code for algorithms that need quick checks of object equality.これをオーバーライドしないとDictionaryのキーとして使ったときに正しく動作しない可能性がある模様。VisualStudioがオーバーライドをおすすめしてくれたのでオーバーライドします。
しかも有能VisualStudioが中身も自動で実装してくれます。ぶっちゃけあまり詳しくない。上記機能を備えたAngle構造体のソースコードです。
そのままコピペで使えます。[追記]
編集リクエスト頂きライセンスを明記しました。
改変等自由ですので是非ご利用ください。Angle構造体はこれから長く使い続けられそうなので、きちんと単体テストを行いました。
次の記事を参考にしながら、xUnit と Chainning Assertionを使ってテストコードを記述しました。
xUnit.net でユニットテストを始める以下がテストコードです。
IComparable&lt;Angle&gt;インターフェイスを実装したことにより、OrderByによる並べ替えも成功しています。例外処理も可能な限りチェックしたかったのですが、Angle構造体は内部に単精度浮動小数点型(float)を使っているので、どうしても最大値・最小値の扱いが難しいです（例えばfloat.MaxValue+1000などとしても、floatの有効数字は7桁なので1000が丸め込まれてしまう）。
そのため明確にNaNもしくはInfinityまたはNegativeInfinityになった場合のみ例外の発生をチェックしました。
実際、3.40282347×10^38°なんて角度を使うことはほぼありえないため目をつむります。floatの仕様に依存すると言えば言い訳になるかも。すべて合格。
角度の扱いは簡単なようで地味に厄介でした。
その厄介な部分を全部隠蔽してきれいな部分だけを外部に公開したこのAngle構造体、少し使ってみたのですが普通に便利です。（自画自賛）
みなさんも自己責任でよかったらどうぞ。以下GitHubでも公開しています。DOTweenにAngle構造体を投入してTweenできるようにするDOTweenのPluginを作成しました。
下記記事を参照ください。Plugin本体は下記GitHubを参照ください。


