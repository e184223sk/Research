More than 1 year has passed since last update.※この記事は2018年01月15日に投稿された記事です。オブジェクト指向プログラムのポリモーフィズムについて学んだのでまとめてみたいと思います。
以下を参考にしました。ポリモーフィズムとはオブジェクト指向プログラミングの概念の一つです。
日本語では多態性・多様性などと訳されます。
簡単に言うと同じ名前のメソッドを複数のクラスで使用できるようにし、そのメソッドを通して、暗黙的に複数のインスタンスの動作を切り替えることができるようにします。例えば、JavaScriptでは以下のようなコードを書くことができます。３つキャラクタークラスがあるとします。
キャラクター達はそれぞれattack()メソッドを持っています。上記のクラスのインスタンスを配列に格納し順にattack()メソッドを実行してみます。ここで大事なのは定数characterのattack()メソッドが実行されていますが、実際に呼び出されているのはcharacterに格納されたSoldier、Wizard、Hunterのattack()メソッドであり、同じattack()メソッドでも動作が切り替わっていることです。これを静的型付け言語（C#）で書いてみるとどうでしょうか。動きません。まず、コンパイルが通らない。CS1061: Type 'object' does not contain a definition for 'Attack' and no extension method 'Attack' of type 'object' could be found.CS1061は、存在しないメソッドを呼び出そうとしたときや、存在しないクラス メンバーにアクセスしようとしたときに発生します。
配列にインスタンスを格納するところまでは良いのですが、「Object型にはAttack()メソッドがないよ」と怒られているようです。これを動くようにするには以下の２つ方法があります。順に見ていきたいと思います。まず最初に、CharacterBaseという基底クラスを定義します。
abstractが付加されたクラスは抽象クラスとなりnewによるインスタンス化ができないクラスです。
抽象クラスは継承しインスタンス化できるクラスを定義することが前提になっています。続いてCharacterBaseクラスを継承した各キャラクタークラスを定義します。各キャラクタークラスでは、overrideキーワードを使いAttack()メソッドを再定義しています。
これでAttack()メソッドを持っているクラスを統一的に扱うことができるようになりました。
それでは、実際に上記のクラスを使ったコードは以下のようになります。各キャラクタークラスのインスタンスを格納したList&lt;T&gt;の要素の型がそれぞれの継承元であるCharacterBaseになっています。
foreachブロックではSoldierもWizardもHunter同じCharacterBaseクラスとみなされています。
しかし、呼び出されるAttack()メソッドはCharacterBaseのAttack()メソッドではなく、実際のインスタンスのものとなります。
つまり、実際の型がSoldierならSoldier、WizardならWizard、HunterならHunterのAttack()メソッドが呼び出されています。抽象クラスを使うと、異なる型のオブジェクトを同一視し、そのオブジェクトの型によって動作が切り替えることができるようになります。
このようにポリモーフィズムでは静的型つけ言語の厳密性を保ったまま、動的型つけ言語の柔軟性を得ることができます。インターフェースを使っても抽象クラスと同じことが可能です。
インターフェースは製品の規格のようなものでプロパティやメソッドの呼び出し方だけを定めたものです。上記はICharacterを実装したクラスにはstringを返すAttack()メソッドを定義しなければならないと定められていることを表します。
インターフェースにはpublicと言ったアクセス修飾子は付けることはできません。それでは次に、ICharacterクラスを実装した各キャラクタークラスを定義します。
インターフェースのメソッドやプロパティの具体的な動作はここに書くことになります。これらのキャラクタークラスを利用するコードは以下のようになります。利用する側のコードはList&lt;T&gt;の要素の型がICharacterになっただけでCharacterBaseを継承した場合と同じです。抽象クラスのCharacterBaseは以下のように書くことでもできます抽象メソッドの修飾子がabstractの場合には実際の処理を記述しません。
メソッドの修飾子がvirtualの場合にはオーバーライドしなくても構いませんが、abstractの場合には必ずオーバーライドし具体的な処理を定義する必要があります。ポリモーフィズムについて実際いつどこで役に立つのかと考えると、入力値のバリデーションなどに使えそうかなと思いました。婚活サービスの登録フォームの検証で考えてみます。ユーザーの入力値は以下のモデルにバインドされるとします。基底の検証クラスを定義します。基底クラスを継承した各検証クラスを定義します。上記クラスを利用したコードを書いてみます。検証メソッドはModelに持った方が良いのかもしれません。
おそらく、あまり良い例ではないと思います。
アドバイスがありましたらよろしくお願いします。ポリモーフィズムは、抽象クラスとインターフェースを２つ方法で実現できました。
では、この２つはどのように使い分ければよいのでしょうか？調べると以下のようなことが書かれていました。抽象クラスと派生クラスは「継承」の関係はIS A関係と呼ばれている対して、インターフェースと実装クラスの「実装」の関係はCAN DO関係と呼ばれているそうです。鳥によっては鳴かない鳥、飛ばない鳥もいるでしょう。インターフェースが分かれているのと、インターフェースは多重継承できるという仕様上、継承するしない、複数継承といった使い分けができるのです。プライベートではJavaScriptよりTypeScriptを書く場面が多いのでTypeScriptで実装してみました。※追記 2019/11/04TypeScriptは構造的部分型（Structural Subtyping）ですのでCharacterBase抽象クラスは必要ありません。


