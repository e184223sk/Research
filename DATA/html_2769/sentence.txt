More than 1 year has passed since last update..NET (C#) のパフォーマンス改善に関する記事にて、クロージャを利用した場合 と そうでない場合 における
パフォーマンスの差異を指摘するような情報を拝見しました。
普段、コードを書く際には配慮しないような事項だったため、勉強の意味も込めて実際に測定してみました。匿名関数でローカル変数をキャプチャした (取り込んだ) 場合、その関数を クロージャ と呼びます。C#においてクロージャを作成した場合、コンパイル後に生成されるコード (IL = 中間言語) にて、
クロージャが取り込んだ ローカル変数 を保持するようなクラス構造が、暗黙的に生成されます。クロージャの外部 (呼び出し側) でローカル変数が変更された場合でも、
クロージャの内部でローカル変数の変更が共有出来るのは、このような仕組みによるものです。下記ページに非常に判りやすい解説があります。
https://ufcpp.net/study/csharp/sp2_anonymousmethod.html#staticサンプルコードを Github にアップしています。
https://github.com/tYoshiyuki/dotnet-core-benchmark-test尚、今回使用したプログラムサンプルは、下記スライド (41スライド目) を参考にさせていただきました。
https://www.slideshare.net/xin9le/dotnetperformancetips-170268354Linq の FirstOrDefault を例として、ローカル変数をキャプチャした場合 と そうでない場合 とでベンチマークを測定してみます。ポイントとなるコードは以下の通りです。変数をキャプチャするパターンを2つ、拡張メソッド経由で変数をキャプチャしないパターンを1つ実装しました。
実際のRepositoryでは、DBのようなデータストアからデータを取得しますが、今回はメモリ上より取得するようにしています。呼び出し側のコードを下記の通りです。それぞれのパターンで　10,000回 の呼び出しを行っています。
ベンチマークの測定には BenchmarkDotNet を利用しました。以下、測定結果を掲載します。やはり、ローカル変数をキャプチャしない方が パフォーマンス的に有利 であるようです。
実践では、コードの可読性やパフォーマンスをどこまで配慮すべきかという観点もあるとは思いますが、
実装上のポイントとして、認識しておいた方が良いかなと感じました。暗黙的に生成されたクラスを IL で確認してみました。
素人には読めるような内容ではないのですが、キャプチャされたローカル変数を保持するクラス構造が
生成されているという点は確認出来ます。


