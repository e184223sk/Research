仕事で、ILogger への移行をやることになったので、先に ILoggerのスパイクをしておこうと考えた。今回は２回に分けて書くつもりで、今回は Console App を使った ILogger の基本機能、そして、次回は、ASPNetCore とのインテグレーションを理解したいと思う。今回使用したのは、dotnet 5 を使用している。使っているライブラリのバージョンは次の通り。コンソールアプリケーションから、ILogger を使いたいときは、LoggerFactoryを使うとよい。コンソールへのロギングを実現したい場合、Microsoft.Extensions.Logging.Console を使えばよく、ILoggingBuilder に対して、AddConsole() もしくは、AddJsonConsole() を追加すればよい。今回はフォーマットを Json で出力したかったので、AddJsonConsole() を使用している。これは、dotnet 5 から使えるインターフェイスなので、今回、dotnet 5 をスパイクに使用している。 options の設定内容は後程説明したい。このようなログのフォーマットのサポートに関しては
Console log formattingを参照にすると良い。次のコードを見ると、なんで、Substituteを最新の形で書かないんだろうと思うかもしれない。$"{something} is substitution" の形式だ。それには理由があって、この形式で書くと、ログを出力した時に、Id = 1, Runtime = DateTime.Now として、個別の項目として認識される。これは、本番運用時に、ログを検索するときに便利になると思われる。尚、AppLogEvents.Details はカスタムクラスで、単にint を定義している。これは、最初のパラメータが、EventId というもので、ログのイベントの種別を区別するための項目だからだ。 次の実行結果で、"Id":1,"RunTime":"06/26/2021 23:26:07" という個別の項目が出来ているのが確認できるだろう。さて、ログを有効化するときに、スコープを定義したいときがある。特定のメソッドがどこのコールスタックの一部としてコールされたのか？が気になる場合がある。次のように記述する。このログを出力してみよう。"Scopes":["simple","start console"] が、各テレメトリに追加されている。ILogger はインターフェイスであり、１つのインスタンスから、複数のロギングのプロバイダに出力することができる。今回はコンソールを使ったが、Application Insights のプロバイダを使えるようにしてみよう。Microsoft.Extensions.Logging.ApplicationInsights をNuGet パッケージとして取得して、ILoggingBuilderに次の設定をするとよい。ちなみに、Microsoft.Extensions.Logging.ApplicationInsights は、最新でも 2.x であり dotnet 5 向けの5.xのバージョンは見当たらない。おそらく将来的にこのNuGetパッケージは違うものに移行するのかもしれない。 最近の Application Insights だと、InstrumentationKey より、Connection String を重視している感じがするが、こちらの記事を見ても、ASP.Net のパッケージのネームペースが変わっている。ASP.Net Core の場合は、Connection String を見るようにしているようだ。だた、先ほどのドキュメントによると、コネクションストリングは、新しいAzureのリージョンに必要なもののようなので、コンソールアプリでは必要ないとも言える。ここで、先ほどのスコープを有効にするために、options =&gt; { options.IncludeScopes = true; } を設定している。これを有効にしないと、スコープがログには出てこなくなる。コンソールより、より多くのメタデータが追加されているのがわかる。
実はコンソールアプリであっても、DIを使うほうがきれいに同じことを出来る。Microsoft.Extensions.DependencyInjectionパッケージのServcieCollection を使う。BuildServiceProviderの拡張メソッドによって、`IServiceProvider のインスタンスが取得でき、そこから、ILogger のインスタンスをとればよいのでさほど大変でもない。一つ面白いところは、services.Configure&lt;TelemetryConfiguration&gt;(config =&gt; config.TelemetryChannel = channel); によって、TelemetryConfiguration のチャネルがオーバライドされている。これは、のちに、　finally のセクションで、InMemoryChannel をフラッシュしている。これは、何か不慮のExceptionが起こったときでも、しっかりログをフラッシュ出来るためのコードである。オフィシャルドキュメントにこの説明が掲載されていた。今回はコンソールアプリなので、動作検証、もしくは、ユニットテストなどでの使用で使えそうな知識だったが、AspNetCore とのインテグレーションを見てみたい。今回紹介したコンセプトに加えて、ログをフィルタしたり、ログをアップデートしたりする方法を学びます。


