More than 1 year has passed since last update.Unity-DOTSで作る2D弾幕シューティングの例の五回目です。描画に関してですが、私がこのゲームを作り始めた時点ではEntity Component Systemに関連するパッケージの中に従来のSpriteRendererに相当するものが存在しなかったため、絵を表示する機能はGraphics関数を自前で叩く実装をしています。
SpriteRendererっていうのは便利だったんだなあ。Graphics.DrawMeshがいわゆるドローコールに相当するものですが、これを叩いて描画を行います。
が、せっかくDOTSの恩恵を得て大量のオブジェクトを並列Jobで回しているのに、ドローコールがEntityごとに一回ずつでは速度も何もあったものではないので、このゲームではマテリアルごとにドローコールをバッチングできるGraphics.DrawMeshInstancedのほうを使います。これによって多少なりとも速度は出るようになりますが、それでもレンダリング処理の負荷はかなり高いです。ここの速度を改善するためにいくつかつつましやかな努力をするわけですが、そのため若干機能が複雑化しています。現状は単一のSystemの中にすべての描画機能がおさまっているので、まだマシかもしれないですが。ちなみに、スプライトアニメーションを使いたかったため、今回使用するマテリアルにあたるシェーダも自前で用意します。暗黒大車輪？　はい。まあ趣味でやるぶんにはいいでしょう。自前のスプライトアニメーション描画機能に関しては、下記のような手順を踏みます。
1. シェーダの作成
2. シェーダコードの出力
3. マテリアルの作成
4. マテリアルの情報をデータ化
5. レンダリング用のComponentSytemを作成まずアニメーションさせたい画像を用意します。

この画像をソースとして設定でき、一枚ごとのスプライトのサイズと合計枚数からアニメーションできるようなシェーダを作成します。
下記のような感じです。

ダメージを受けた際に赤く光るティント表現を同じくシェーダ上で作っているのでそれが合流して少し広く見えますが、アニメーションをすること自体はFlipbookノードだけで事足るので便利です。ShaderGraphはすごい。ちなみにShaderGraphの元になったっぽいShaderForgeの開発者であるFreya Holmérという方が、彼女のYoutubeチャンネルでプログラミングにおける描画や、プログラミングにおける数学に関する動画をいくつも公開していて、かなりオススメです。ShaderGraphでFlipbookノードを使ったアニメーションを作成する方法としては、下記を参考にしました。
Controlling Flipbook Animation with Shader Graph - unity shader graph tutorial 4ちなみにスプライトティントのシェーダ実装については下記を参考にしました。
Sprite Tint - 2D Shader Graph Tutorialこうして作ったシェーダを使ってマテリアルを作成するわけですが、一つ落とし穴がありました。
私が作っていた時点で、Graphics.DrawMeshInstancedがまだShaderGraphに対応していなかったのです。なのでちょっと一手間加えます。
ShaderGraphのMasterノードからShow Generation Codeを選択し、シェーダコードをコピーします。
UnityEditor上の適当なところに、下記のような感じで新たにシェーダを作成します。

この中に、ShaderGraphからコピーしたコードを貼り付けます。
が、これだけだとまだ動きません。
コピーしてきたシェーダコードのうち、下記の二点を行う必要があります。
1. CBUFFERで定義されている変数を、UNITY_INSTANCING_BUFFERに書き換える。
2. 変数を使用している箇所を、UNITY_DEFINE_INSTANCED_PROPに書き換える。これを、変数を使用している箇所すべてに対して行っていきます。
正直なところこれがなぜ必要なのかよくわかっていませんが、まあ動いているしいいんじゃないか。下記が参考になりました。
Graphics.DrawMeshInstanced Material.SetFloatArrayマテリアルを作成し、さきほど作ったシェーダコードを設定します。
元になるアニメーションのスプライトシートを参考に、横に何枚あるのか、縦に何枚あるのか、というような情報を設定していきます。今のところ絵は正方形のものしか想定していません。
下記のような感じです。
このため、アニメーションが違うものは別マテリアルという扱いで作成していきます。アニメーションが違うなら、そもそも絵がまるまる違うのだしマテリアルも別でいいだろうという判断なのですが、このあたり実際ほかにいいやり方があるかもしれません。作ったマテリアルを、ゲーム内から読み出せるようにデータ化を行います。
このゲームでは、編集しやすさのためSQLiteにいったんデータを記載してから、それをScriptableObjectに変換したデータテーブルを使います。
このあたりの独自実装についてはこちらで記載しています。まずSQLiteのテーブルに、作ったマテリアルの一覧を記載します。これをScriptableObjectに変換したものが下記のようになります。このScriptableObjectはAddressableとして登録しておきます。
作成したマテリアルのファイルも、Addressableに登録しておきます。下記のような感じです。ScriptableObjectから、Nameに設定されているマテリアルファイル名を頼りに、マテリアルをロードしていきます。これはゲーム開始時の最初のロード時に行い、読み込んだマテリアルはstaticなDictionaryにデータのIDをキーとして書き込んで、保持しておきます。
下記のような感じです。すぐに使うわけではないマテリアルも全ロードしてしまっているので、ゲームの規模が大きくなってくるとこのあたりは少し問題になりそうです。
ともかく、これでゲーム内からIDを元にマテリアルのデータが引き出せるようになりました。いよいよレンダリング用の実装をしていきます。
まず、レンダリング対象のマーカーとなるIComponentDataを定義しておきます。いくつもパラメータがありますがまあそこまで深い意味はありません。sortingOrderなど、レンダリングの際に参照したい値をここに持たせておきます。本体となるComponentSystemですが、ほぼCode Monkey師匠の下記と同じものです。
100,000 Units Animated in Unity ECS!いったん下記に記載します。描画がバッチングできるDrawMeshInstancedですが、これにもバッチできる数が1023までという制限があり、これを超えるとエラーになります。また、自分でDrawMeshInstancedを発行する場合、Unityが裏で行ってくれていたソーティングやカリングの処理をすべてすっ飛ばすことになるので、本来透過してほしい部分が透過されなくなってしまったりということが起こります。
下記のような状態になるわけです。（上記のビデオ[100,000 Units Animated in Unity ECS!]より）これを回避するために、自前で描画の整合性を保つためにソーティングの処理を行う必要が出てくるのですが、そのソート処理もまた数によってボトルネックになってしまうため、いったん画面をY座標の値で分割してそれぞれの範囲内でソートを行う、というようなことを実現しようとした結果このようなコードになっています。一応動いています。まだ完璧とは言えない状態ですが、何かの参考になれば幸いです。


