More than 3 years have passed since last update.C#の文字列の扱いに関するよくある小ネタ２。（前回はインスタンス作成のお話でした）人間が書いたコードにはコンパイル後に最適化がかかるため、出力されるIL（中間言語）は実際に書いたコードと異なりより良いパフォーマンスが出るように書き換えられます。
C#の文字列連結で基本的な+演算子についても同様に最適化がかかります。不変型について知ったばかりだと「+する度にstringインスタンスが作られるのでは？」と考えるかもしれませんが、実はそうなりません。
すでにこちらの記事にもう書かれているのですが、ここでは実際にコードを書いて逆アセンブルしてみます。どんな最適化が行われるのかについては先に結論を。バージョンにもよりますが、
"C:\Program Files (x86)\Microsoft SDKs\Windows\v8.1A\bin\NETFX 4.5.1 Tools\ildasm.exe"
などの場所にあります。
起動してウィンドウに見たいexeファイルを放り込みましょう。このコードがコンパイルされると次のようになります。この通り、すでに"hogefuga"になっていますね。このコードがコンパイルされると次のようになります。+演算子による連結処理が[mscorlib]System.String::Concat(string,string)です。
これはstring.Concat(string,string)関数と同じもので、実際にstring.Concat(a,b)と書いても全く同じILコードが出ます。それでは３つの文字列連結はどうなるのでしょうか？
string.Concatが二回呼ばれるのでしょうか？　さてどうでしょう。もう前後は省略してきますが…。このように一回のString::Concat()で連結してくれるのでした。では４つ連結してみるとどうなるのでしょう？４つだって一度でやってくれました。では５つなら果たして…？String::Concat(string[])になりました。内部で勝手に配列化しているわけですね。ここまで来ても一度のConcatで済ませてくれるので、stringインスタンスが毎回作られるようなことはないということがわかると思います。ちなみにstring.Concat(a, b, c, d, e)と書いても全く同じILコードが出ます。+演算子の文字列連結はコンパイラがConcatに翻訳してくれているんですね。前回の空文字列とstring.Emptyのお話から、両者は同じ参照を持つことがわかりましたがILコードはどうなっているのでしょうかここで見る限り、string.EmptyはStringクラスのEmptyプロパティを取って来ています。
参照が同じになる、というのもこれだけ見てもわかりません。それは実行時の最適化や振る舞いによる結果なんですね。


