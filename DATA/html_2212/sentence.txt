More than 1 year has passed since last update.LLRP は RFIDリーダのネットワークインターフェースを標準化したプロトコルです.
仕様や詳細については下記のリンクを参照してください.
LLRP Toolkit
LLRP仕様タグのメモリ構造などは下記を参考にしてください
GS1 EPC/RFID標準
RFIDタグの構造について似た例(大体, 同じ例)が　Impinj Support にもあります.
Hello LLRP (Low-Level Reader Protocol)リーダに対して読込命令を発行し, 周辺にある RFID の EPC を取得します.下記のコードでは, IPv4 アドレス 192.168.100.64 のリーダに対して 5084(LLRP) で接続を行います.
既に何かしらのプログラムが LLRP に接続している場合は, エラーが発生します.暗号化された通信を使用する場合は, ポート番号を 5085, useTLS = true に変更します.Impinj 社製のリーダは 1つの ROSpec に対応していますが, リーダによっては複数の ROSpec を追加できるかもしれません.(そのようなリーダに対応したことがないため)
  そのため, ROSpec を追加する前に ROSpec を削除をすることをおすすめします. 削除方法については後述します.ROSpec の開始方法として下記の種類があります.リーダから発行するレポート(ROSpec のみの場合は, 検出したタグの情報)を設定します.
レポートを発行する方法として,の 2つのどちらかを指定することができます.
タグの個数 N は 0 を指定すると, タグの個数についての終了条件が無視されることになります. そのため, ROSpec もしくは AISpec が終了した際にレポートの発行されることになります.LLRP.Close 内で MSG_CLOSE_CONNECTION を使用して切断処理を行っています.上述した設定に対応したリーダであれば, 下図のような結果になると思います. 
この結果の例の FirstSeenTimestampUTC LastSeenTimestampUTC で取得された値は, Unix時間となっているため, そのままの値を DateTime に渡すと正しくない時間が取得されてしまいます.リーダによって対応するメッセージやパラメータが相違している場合があり,
例えば Impinj 社製のリーダを制御するプログラムを作成しても他社のリーダを動作させられないことがあります.サンプル例としたコード中にコメントにて // Success の場所がありますが, リーダによっては msgResp 内の LLRPStatus にエラーメッセージおよびステータスコートが含まれている可能性があります.
その場合, msgErr は常に null になります.(ほんと, やめてほしい)


