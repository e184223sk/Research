WindowsフォームアプリからWPFアプリに移行すると
MVVMの呪縛にかかり、コードビハインドに何も書けなくなる （※ 個人差があります）たとえば、フォーム（WPFではウィンドウ）を読み込んだ直後に何かの初期化処理をしたい場合など・・これは困ったことなので、どうしたらいいかを書く&lt;&lt; ゴール &gt;&gt;
WPFアプリにおいて、ウィンドウが読み込まれた直後になんらかの初期化メソッドを呼ぶ
（ただし、コードビハインドには何も追記しない）流れとしては、まずフォームアプリで所望の動作をさせてみる。
そのあと、WPFアプリで同じことをするおなじみのWindowsフォームアプリプロジェクトを立ち上げ直後は、まっさらなフォームが表示されるフォームの上でマウスを左ダブルクリックすると、メソッドが生成されるあとはこの関数の中に、初期化などの処理を書けばいいフォームアプリについては以上つづいてWPFアプリの2パターン
コードビハインドを使う場合と、使わない場合WindowタグにLoaded="Window_Loaded"を追加するコードビハインドに同名のメソッドを追加し、中身を書けば終わりViewでLoaded="まで入力すると、「新しいイベントハンドラー」ポップアップが表示される
このポップアップをクリックすると、コードビハインドにメソッドが自動で追加されるウィンドウのプロパティを開いて右上の⚡を押せば、使えるであろうたくさんのイベントが表示されるMVVMに従う場合、何はともあれViewModelのファイルを作成する
今回はMainWindowViewModel.csをプロジェクトに追加するものとするXaml.Behaviors.Wpfをインストールする
これはViewのイベントとViewModelに定義したコマンドを紐づけるためにつかう
詳しくは・・・System.Windows.Interactivity.dll から Xaml.Behaviors.Wpf へReactivePropertyをインストールする
これはコマンドを簡単に書くためのライブラリであるさきほどのLoaded=...イベントは削除する。
代わりにiに関わるものを追加する。新たに追加した行を見るとこのまま実行しても"Loaded !!"とは表示されないViewとViewModelをつなぐために、Viewを編集する
DataContextにMainWindowViewModelを指定するなお、MVVMの呪縛に囚われていない場合は
コードビハインドでthis.DataContext = new MainViewModel();としてもよい。ことLoadedイベントだけに関してみれば、WinFormのほうが何も考えずにできてよいかもしれないしかし、ひるがえってみれば、LoadedのためだけにNuGetを通してわざわざ2つのライブラリをインストールするWPFに対しては、なにかこの先大きなことをしてくれるのではないかと期待してしまうというまとめ。


