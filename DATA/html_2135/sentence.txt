More than 1 year has passed since last update.この記事は【unityプロ技②】 Advent Calendar 2019の25日目の記事です。
この記事は【Unity, C#】internalな型やメンバにアクセスするには、多分これが一番早いと思いますの続編です。先にこちらをご覧ください。
この記事におけるソースコードは、全てPublic Domainです。前回、こんな風に述べてました。ところが、その後の調査により、privateな型やメンバに対してもアクセスができることが判明しました。ちなみに、元記事にもキッチリ書いてありました。うっかりが過ぎる。internalな型やメンバにアクセスするモチベーションと同じです。
internal要素以上に、privateアクセス修飾子によって隠蔽されているメンバは多く、その中には有用なものもあります。また、例えば拡張メソッドを実装する場面において、そのクラスのprivateメンバを扱うことができると考えるとどうでしょうか。
パフォーマンス/機能面で強力なハックを提供できるかもしれません。前回のパッケージを使ってprivateアクセスしてみましょう。わーい、とっても面倒くさい。
いちいち手作業でコンパイルするのもナンセンスですね。
こんなことならリフレクション使ったほうが早いんじゃね。ちなみに、C#プロジェクトを生成しても、対応するAssemblyDefinitionFileが無効化されるとC#ソリューションから外れ、インテリセンスがご臨の終です。どうもありがとうございました。
新しくIDEのインスタンス立ててC#プロジェクト読み込めばなんとかなりますが、なんか釈然としません...なんとか良い感じに運用してみましょう。素直に実装すればこうでしょうか。運用するだけであればこの方法で十分そうですが、問題もあります。さらっと流しましたがOnGeneratedSlnSolutionは文書化されていないメソッドです。
その他、以下のようにソリューションやプロジェクト生成時コールバックが用意されています。
これらはstaticメソッドであることに注意してください。そもそも、こんなに手間が掛かるのは、コンパイラへの入力としてC#プロジェクトファイルを使っているからです。
では、UnityにおいてC#プロジェクトファイルってビルドに必要なんでしょうか？答えはノーです。プロジェクトディレクトリ内からソリューションファイルやプロジェクトファイルを全て削除したとしても、コンパイルは元気に走ります。
コンパイラへの入力は、実際には何が使われているんでしょうか？以下、Unityにおけるコンパイルのに関する話になりますが、長くなりますので興味ない方は「めんどくさいのでパッケージを使う」まで読み飛ばし推奨。UnityのC#コンパイラはcscで、unity_csc.batまたはunity_csc.shとしてプラットフォームごとのスクリプトにラップされています。
実際のところ、この辺の処理はUnityのバージョンによって異なりますが詳しくは割愛。
Unity 2019.3では、unity_csc.*に関する記述はMicrosoftCSharpCompiler.StartCompilerにあります。自作コンパイラをビルドパイプラインに載せるには、この部分がハックできれば良さそうです。
どうやってハックできるのか確認していきましょう。まず、MicrosoftCSharpCompilerはCSharpLanguage.CreateCompilerメソッドから参照されています。そして、CSharpLanguageはScriptCompilersのコンストラクタから参照されています。staticコンストラクタに行き着きました。
CSharpSupportedLanguageがこのタイミングで生成されていることがわかりますね。
SupportedLanguageがリストとして受けられるようになっているのは、C#以外の言語(懐かしのUnityScript、Boo)に対応していた名残でしょう。ここから先の参照は本題とズレるので省きますが、このCSharpSupportedLanguageをどうにかして書き換えることができれば良さそうです。IncrementalCompilerというパッケージを使ったことはありますか？
「ビルド時間が大幅に短縮できる」「C#7.2の機能が使える」という、Unity 2018.1〜2018.2向けの非常に強力なエディタ拡張パッケージで、実はUnity 2018.3以降では類似機能がビルトインされています。「自作コンパイラをビルドパイプラインに載せる」という意味では、IncrementalCompilerも同じことを行なっているはずです。
試しにパッケージを調べてみると、ScriptCompilers.CSharpSupportedLanguageとScriptCompilers.SupportedLanguagesの上書きがキーになっているようでした（調べ方については割愛）。さっそく、それらを上書きしてみましょう。なお、以下のコードはinternalアクセスを多用しているため、Unity.InternalAPIEditorBridgeDev.001等UnityEditorにinternalアクセスが許可されているアセンブリ名を持つAssemblyDefinitionFileが必要です。まずはエントリポイントからです。
InitializeOnLoad属性を使って、ロード時に自動的に実行されるようにしましょう。
ここではScriptCompilersのフィールドを書き換えるコードを用意します。これにより、C#のコンパイル時に、CSharpLanguageの代わりにCustomCSharpLanguageが選択されるようになりました。次に、CustomCSharpLanguageを実装していきますが、こちらはCSharpLanguage(ソース)を継承すれば最小限のコードで済みます。このように、CSharpLanguageは動的にコンパイラクラスのインスタンスを返せます。
Unity2019.2までは、この部分でmsc/cscの切り替えを行なっていました。
なお、Unity2019.3からはcsc(MicrosoftCSharpCompiler)のみです。最後に、コンパイラクラスを作成しましょう。
このクラスはresponse file(コンパイルオプションを記述したファイル)を生成し、それを入力としてコンパイラプロセスを起動することが責務です。
MicrosoftCSharpCompiler(ソース)を継承すればこちらも簡単です。継承元(MicrosoftCSharpCompiler)でcscを使ったコンパイルプロセスを作っているので、継承元のものは終了させましょう。response fileは、継承元のコンパイラクラスで作成され、Tempフォルダに保存されるので、最新のものをピックアップしましょう。
response fileの生成は継承元のコンパイラクラスに任せましょう、簡単に外部参照やシンボル等の整合性が取れます。
ちなみに、responsefileの中身はこんな感じです。
C#プロジェクトの内容をコンパイルオプションに置き換えたようなイメージですね。余談ですが、なんでわざわざresponse fileを作る必要があるんでしょうか？
正解はProcess.Startで引数が長すぎて死ぬからです。
あと、文字列がダブルクォーテーションで囲まれてるのも注意が必要です。
私はどちらの罠も踏み抜きました。長くなりましたが、これがUnity上で自作C#コンパイラを動かすための雛形となるコードです。
このコードを好きなように改造し、dllにコンパイルしてインポートすることで、csファイルのコンパイルが始まる前に自作C#コンパイラをビルドパイプラインに載せられます。前回のIgnoresAccessChecksToの下準備よりもめんどくさいですね。今回は、先述のコンパイラを同梱済みのUnity向けに公開しているパッケージをデモとして使います。
こちらからデモプロジェクト一式をダウンロードできます。機能検証に時間を取りすぎた結果、テストにあまり時間が取れませんでした...
「とりあえず、こういうことができる」事が分かったという段階ですね。今後に期待してください。internal/privateアクセスが手軽にできるようになりました。
正直、リフレクション憎しのエネルギーで結構ヤバいものを生み出してしまった感があります。
くれぐれも　じこせきにんで　おねがいします。そして、この記事を書いている間に「あれ？UnityEditor.Modules.ICompilationExtension使ったらもっと簡単にイケるんじゃね？」と気づきました。
そういうことに気を取られるから遅筆なんだぞ！
後でその検証もやります。
【追記】ダメでした。この場を借りて、様々な情報をご提供頂きました@pCYSl5EDgoさんにお礼を申し上げますm(_ _)m


