More than 1 year has passed since last update.一番最初に学んだプログラミング言語がJavaだった僕が、C#のプロパティという概念や書き方をあまりよく分かっていなかったので、整理してみたいと思います。オブジェクト指向の説明なんかでよくあるHumanクラスを考えます。Humanクラスは次のようなフィールドと可視性を持っているとします。この要件を実現するには次のようなクラスにする必要があります。さらに今回はインスタンス化時にそのフィールドも同時に設定できるコンストラクタも定義することにします。Javaの場合は書く量は多いですが、やることはシンプルです。愚直に持つべきフィールドはprivateの変数として定義し、getter / setterはそのままただのpublicメソッドとして定義します。制限をつけたい場合は、メソッドの中でそのロジックを書きます。そもそもアクセスされたくない場合は、メソッドを書かなければいいだけのことです。また、コンストラクタは順番に引数を受け取り、自分自身のフィールドに設定します。Humanクラス内でのコード量が多いですね。今回は条件や制限をつけているのでそこまで嫌な感じはないですが、実質全てのフィールドがアクセスし放題のクラスだったりすると、不毛感が半端ないです。Lombokというライブラリを使うともう少しすっきり書けたりする場合もありますし、IDEの機能を使えばgetter / setterメソッドを自動生成してくれる場合もありますが、それは他の方へ譲ります。そこで、最近の言語では自分自身のフィールド（アトリビュートなんて言ったりもしますが）getter / setterに関しては特別な書き方を実装していることが多いようです。C#もそのうちの一つです。C#では、外部からフィールドを書き換えたり取り出したりするにはプロパティという機能を使います。あたかもフィールドを直接書き換えているかのように見えます。しかし、実際はgetter / setterメソッドのようなものを介しているので、これはPascalケースで書きます（C#ではメソッド名はPascalケース）。プロパティを使うと、いちいちメソッドを介している感がなく、直接代入したり、直接参照したりしているように感じますね。readもwriteもできるプロパティを使いたいときは、プロパティ名の後ろに{ get; set; }と書けばいいです。read-onlyのプロパティを使いたいときは{ get; }にしてください1。setしたりgetしたりするときに内部で何らかの処理を行ってからreturnしたりsetしたりしたいときは、別途内部でフィールド（こっちは普通の変数なのでcamelケース）を用意しプロパティの宣言の後ろに次のように書きます。このときsetterの内部では、受け取った値は自動的にvalueという名前の引数で受け取ったことになります。なお、今回は一部のプロパティがread-onlyであるために、コンストラクタはJavaと同じような感じになりましたが、全てのプロパティにwrite権限がある場合は、コンストラクタをわざわざ用意せずとも、次のような感じに書くことができます。非常にすっきりとしていますね。getter / setterの是非はいろいろ言われていますが、それでもオブジェクト指向のカプセル化の話をするうえでは避けては通れないところでもあります。僕はJavaから入ったため、オブジェクトは変数とメソッドだけを持っているというところから理解しました。分かりやすい反面、冗長で面倒だなあという感想を持っていました。はじめてC#のコードを見たとき、プロパティという機能すら知らなくて、なんでこいつは変数をPascalケースで書いているんだ？　と思っていましたが、調べてみるとこんなに簡潔に書けるのかと感激しました。しかし、その一方でgetter/setterにロジックが入ったりすると、微妙に間延びして見にくい感じになったり、またC#はバージョンアップのたびにこのあたりの書き方が進化しているので、調べているうちに「こんなふうにも書けます」とか「かつてはこんなふうに書いていました」みたいな情報がたくさん出てきてかえって混乱したりと、むしろややこしいなという印象も抱いてしまいました。この記事はそんな自分に対するまとめでもあります。この記事があなたのC#ライフの向上に役立っていただければ幸いです。上の記事で書くのを忘れていたのですが、C#のプロパティには初期値を与えることができます。例えば、生まれたばかりのHumanオブジェクトに「名無し」というnameを与えたければ、わざわざフィールドを用意して初期化したりコンストラクタを定義したりせずとも、次のように書くことができます。これだけでも嬉しいのですが、例えばクラスの中に何らかのクラスのオブジェクトをプロパティとして持ちたいときなどに威力を発揮します。このようにしてやると、このクラスのオブジェクトの外側からいきなり、このプロパティを操作してやることができます。プロパティの初期化をしないままこれをやろうとすると、NullReferenceExceptionで落ちてしまいますからね。それを回避するためにはクラスの外でnewしてからつっこまなければなりません。（thx: 同じ会社のC#erの方）最初の記事ではwrite-onlyなプロパティは使えない、と書いたのですが、実際はprivate getなプロパティにしてあげると使うことができるそうです。内部ですら自分のプロパティを読み取れなくなってしまいますからね。よって、と書くことはできませんが、と書くことはできます。（thx: @munielさん）今回はsetterのところでなんらかの処理を行うという前提で書いたのでint型を用いましたが、uint型（Unsigned Int）という符号なし整数という型があるようです。int型では、-2147483648～2147483647を扱いますが、uint型では0～4294967295を扱います。しかしながら、uint型は基本的に負の数を扱えないため、例えば10 - 20が-10とならず、4294967286（ビット演算のため、ぐるっと回って大きいほうに突入する）となってしまうなど、思わぬ挙動によるバグの温床になりかねません。基本的に算術の対象になりうる値にuint型を使うべきではないようです。もっとも本当にHumanオブジェクトを作りたければ、ageをset / get可能なプロパティにすると1年ごとに年齢を更新するはめになりますので、たぶん内部に誕生日をプロパティとして持っておき、年齢はそれを元に計算して値を返す get 専用プロパティにするのが良さそうです。
（thx: @Tonbo0710さん、@tak458さん、@Zuishinさん）上の記事では、コンストラクタでも変な値が突っ込まれるのを防ぐためにif文を使っていますが、よくよく考えたらここで自分自身のプロパティを経由して値をsetしており、そのsetterの中で判定してくれているので、これは以下のように書いていいはずです2。さらにいうと、プロパティと受け取った変数名がPascalケースとcamelケースで衝突していないので、thisはあってもなくてもよいです。（thx: ヤマダ）実は、write-onlyのプロパティはC#ではサポートされていないようです。この場合は、別途普通にsetterメソッドとして実装することになります。　private getを用いることで、write-onlyなプロパティを使うことができます（追記参照）。 ↩private setを書かなくてもコンストラクタのときだけ外側からsetできちゃうみたいです。 ↩


