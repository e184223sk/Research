More than 1 year has passed since last update.「迷路を幅優先探索で解く」で示した迷路を解く問題を、今度は深さ優先探索を使い再帰的なコードで解を求めてみました。
なお、深さ優先探索では、幅優先探索とは異なり、見つかった解が最短距離のルートという保証はありません。深さ優先探索については、 Wikipedia 「深さ優先探索」を参照してください。「迷路を幅優先探索で解く」は神の視点で迷路を説いていましたが、こちらは、できるだけ人間が実際に迷路の中を（優先探索を使って）歩いて解くようなアルゴリズムにしてみました。まあ、実際に人間がこの方法で迷路を解くとなると、一歩の距離が正確にわかる必要がありますし、紙と鉛筆が必須だと思いますが…具体的には、迷路を探索するクラスは、迷路の全体像を事前に把握できないという制約条件を付けています。探索するオブジェクトは、自分のいる前後左右が道なのか壁なのかしか把握できないということです。さらに、スタート地点が迷路のどこに位置するのかも把握できないものとしています。つまり、迷路を２次元配列で表したときに、その２次元配列のどこからスタートするのかも分からないということです。そのため、自分のいる位置は、スタート位置からの相対的な位置で把握することとしました。当たり前ですが、ゴールにたどり着いたのかの判断はできるものとします。ちなみに、ここで採用したアルゴリズムが実際のロボットに応用できるかどうかの判断は、僕には経験がないのでなんとも言えません。コードを示す前に、実行した結果を載せます。コンソールに表示される記号の意味は以下の通りです。以下のスクリーンショットは、探索途中の状態です。.NET Coreで作成し、Macで動かしています。カーソルが動いて試行錯誤しているのをお見せできればいいのですが...そして、これは探索が終了した時の状態。なお、深さ優先探索は、場合によってはまったく見込みのない探索木を探す羽目になりなかなか解が見つからないということが起こりえます。かといって、幅優先が常に有利かというとそうとも言い切れないのところが この手のアルゴリズムの難しいところですね。幅優先は一般に迷路の分岐数が多いとメモリが大量に必要になってしまうという欠点がありますし、探索するオブジェクトが、迷路の全体像を事前に把握できないという状況では幅優先探索は使うのが難しいのではと思います。うまいアイデアが思いつきません。一方、深さ優先はスタックを食いつぶして実行時にエラーが出てしまうこともありえます。と言っても、.NETでスタックオーバーフローを起こした経験は覚えてる限りはないですが。まあ、それぞれ一長一短ですね。定義したクラス/列挙型は以下の通りです。Maze
    　迷路を表すクラス
MazeSolver
    　迷路を解くクラス
Position
    　位置を表す
Tracks
    　動いた経路を記録する
Viewer
    　探索状況を表示するクラス
Program
    　迷路探索を開始するメインクラス
Direction
    　方向を表す列挙型
Place
    　場所の種類(壁、道、ゴール、スタート位置)表す列挙型MazeSolverが迷路を解くクラスです。このクラスでは前述したように、迷路の全体像を見ることはしません。Mazeクラスの一部のメソッドだけを呼び出し、今いる場所の前後左右の状況を調べるだけです。この情報を使い、曲がるのか、進むのか、はたまた今来た道を戻るのかの判断をしています。それと、オブジェクトが迷路内をどう動いたのかをリアルタイムで分かるようにするために、ちょっと工夫をしています。そのためにIObservable&lt;T&gt; IObserver&lt;T&gt; インターフェースを使っています。発行者オブジェクトは、MazeSolverクラスでIObservable&lt;Direction&gt; インターフェースを実装しています。
これで、動くたびに現在の位置（相対位置）を購読者オブジェクトに発行しています。購読者オブジェクト(IObserver&lt;Direction&gt;)は、Viewerクラスです。Viewerクラスでは、状況をコンソール画面に表示させています。この記事は、Gushwell's C# Programming Pageで公開したものをソースコードも含め加筆・修正したものです。


