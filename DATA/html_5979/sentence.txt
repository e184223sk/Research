More than 1 year has passed since last update.IEnumerable&lt;T&gt;を指定件数で分割するという記事が何件か投稿されてたので自分でもやってみよう！という話
RxのBuffer使えばいいじゃん？と言うのはナシ。中身は参照してるけども。
記事の内容に誤りがあればバシバシ叩いてください。2017.10.17追記
幾つかの実装にガード節の誤りがあったので修正。
普通のListバッファを使った実装を2通り追加。なお本記事ではBufferという、また別のメソッド名を利用してるが、これは前述の通りReactive Extensionsの同名メソッドに倣うということで採用した。そもそもBufferにはどんな仕様が要求されるのか、関連インターフェースにはどんな制約があるのかを考えてみる。そのインスタンスに対するイテレータを公開する。
List&lt;T&gt;やDictionary&lt;TKey,TValue&gt;のような、.NetのコレクションはすべてIEnumerable&lt;T&gt;を実装している。
LINQのオペレータはIEnumerable&lt;T&gt;の拡張メソッドとして定義されている。IEnumerable&lt;T&gt;.GetEnumerator()メソッドにより取得できるイテレータの実体。
主に現在の要素を返すCurrentプロパティと、次の要素を検索するMoveNext()メソッドからなる。IEnumerator&lt;T&gt;の重要な性質として、もとのコレクションの変更を認めないという点があげられる。IEnumerator Interface (System.Collections.Generic) | Microsoft DocsAn enumerator remains valid as long as the collection remains unchanged. If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to MoveNext or Reset throws an InvalidOperationException.つまり、GetEnumerator()でIEnumerator&lt;T&gt;インスタンスを生成したあと、もとのデータソースを変更してしまうとIEnumerator&lt;T&gt;インスタンスは壊れてしまうということ。
後述するが、これはLINQの性質と密接に関係がある。C#ではIEnumerable&lt;T&gt;の実装、あるいはIEnumerable&lt;T&gt;を返すメソッドの実装にyieldキーワードによりコルーチンを利用できる。
例えば、次のように記述することができる。yieldはかなり複雑な糖衣構文で、コンパイラがステートマシンを自動生成する。
前述のコードから自動生成されたクラスを読みやすく書き直すと以下のようになる。
本来の生成コードはC#では認められない文法(ILレベルでは正当)を含んでいるが、ここではちゃんとC# 7.0でコンパイルが通るところまでいじっている。状態変数_stateフィールドで次にどのyield returnを返すのかを記憶し、その値に応じてMoveNext()メソッド内で_currentフィールドの値を書き換えている。
もとのコードでループを使っていればMoveNext()の中身はもっと複雑になる。注目してもらいたいのは_thisフィールドと_aフィールドだ。
これはもとのYieldSample.csのGetFooEnumerable(int a)メソッドの引数である。1
このように、コルーチンメソッドの引数やローカル変数は、自動生成されたEnumeratorのフィールドに転送される。統合言語クエリ。
データ集合に対する一律な問い合わせ手法をまとめた機能群のこと。
関数型プログラミングのエッセンスを取り入れており、データ加工を順序立てて表現できるというメリットがある。
.NetにおいてはIEnumerable&lt;T&gt;の拡張メソッドとして提供されている。LINQの重要な性質は、それが遅延評価されるということだ。
LINQオペレータを積み上げただけでは結果は確定せず、実際にイテレーションを開始することで最終的なデータが出来上がる。
これにより、LINQでは必要なデータだけが評価されるようになっている。
膨大なデータソース(場合によっては無限)に対して必要なデータが少ない場合にはパフォーマンスの観点からもパワフルなシステムなのだ。だが先述したIEnumerator&lt;T&gt;の性質のため、実際にすべての出力を評価し終えるよりも前に論理的な評価結果は確定している。
評価を開始した後はもとのデータソースを変更することができなくなるからである。
つまり、イテレーションを開始した時点でその出力は一意に決まるのだ。2
キャッシュを利用するならこのことを頭の片隅にでも置いておいたほうがいいだろう。これらLINQの仕様を踏まえた上でBufferの仕様を決めていきたい。シグニチャと制約
IEnumerable&lt;IEnumerable&lt;T&gt;&gt; Buffer&lt;T&gt;(this IEnumerable&lt;T&gt; source, int count)Bufferを実装するにあたり求められる最低限の仕様。ここは多分誰も異存ないだろうと思う。遅延評価さらっと言ったが実はここが結構複雑。というのも、Bufferが取り扱うべきIEnumerableは2通りあるからだ。
すなわち、次のようなコードがあったとき、(1)と(2)のどちらで出力が確定しているべきか、という点だ。
本記事で列挙した実装例でもこの部分の取り扱いはまちまちだ。
いずれにせよ、(0)のタイミングで即時評価はしない、という点では共通している。個人的には(1)のタイミングで評価完了している方が自然だと思う。
source.GetEnumerator()が実行されているし、RxのBufferも事実そのような実装になっている。戻り値の性質最後の項目は、元のソースが不変である限り何回評価しても同じであるということだ。
一度評価すると壊れてしまうと言った制約をつければより高効率化できるかもしれないが、そういった制約は設けないということである。ベンチマーク今回利用したベンチマーク用のメソッド。
ソースの要素数に対してどれほど計算時間を要するかを確認する。
ちゃんとGCも立ち上げてテスト間の依存性を減らすよう心がける。多分これが一番シンプルな実装。
中身も非常にLINQらしい仕上がりとなっている。
手元でさらっと実装して使うときにはこの実装を利用している人も多いと思う。
この実装では遅延評価の確定タイミングは(2)である。その1の実装は短くまとまっているが、パフォーマンス的によろしいとはいえない。
ベンチマークを取ってみると計算時間はソースの要素数に対して$O(n^3)$程度にもなっている。
原因はSkipオペレータが多段化してしまっていることにある。
後ろの方のイテラブルはSkipのネストが深くなりすぎてとても重くなる。
そこでスキップ数の方をカウントアップし、常にSkip1段のみになるよう書き直す。こちらは$O(n^2)$程度なので、前項のものと比べるとかなり速い。
ほんの僅かに記述量が増えたものの、パフォーマンス向上の恩恵に比べれば安いものじゃなろうか。こちらの実装でも遅延評価の確定タイミングは(2)である。先行記事で紹介されていた実装。
アルゴリズムの勉強と思って、一応丸コピペではなく自分流に書き直してある。分割後の各イテラブルが始まるタイミングで要素数countの配列を生成、シーケンスをインクリメントしながら配列を詰めていき、全て埋まったところでyield return。
評価タイミングは(1)。III.の実装をArrayからListに置き換えたもの。Addが使えるので若干表現が変わる。分割後の各イテラブルが始まるタイミングで要素数countの配列を生成、シーケンスをインクリメントしながら配列を詰めていき、全て埋まったところでyield return。
評価タイミングは(1)。Reactive Extensionsで用意されているアルゴリズム。
Rxを導入しているならこれ使っとけばええねんという感じだが、それはそれ。
RxのBufferは単純にシーケンスを分割するだけでなく、出力される各シーケンスがどのような間隔(skip引数)をとるかを指定するオーバーロード3を持っており、それを踏まえた実装になっている。方針としては、Arrayバッファの時と同様イテラブルの先頭要素に来たときに新しいバッファを生成し、要素が必要数溜まった段階で放流する。
異なっているのはListを使っていることと、Queueにより複数のイテラブルを並行的に生成できることだ。このアルゴリズムの評価タイミングは(1)。V.の実装はオーバーロードのためにQueueを用意しており、追加のコストを払っている。
今回話題にしている、count個ごとのシーケンスの分割だけを考えるならList一つで十分なはずだと指摘を受け、急遽実装。このアルゴリズムの評価タイミングは(1)。最後に自作のアルゴリズムを一つ。最初のfor文は、count個バッファに溜まっていない状態では放流を開始しないという条件分岐の計算コストを減らすためのもの。
2つ目のfor文とマージしてもよいが、どうせなら余計な計算コストは避けたいものだ。このアルゴリズムでは、バッファには単一のリストを利用している。
SubList&lt;T&gt;はIList&lt;T&gt;のデコレータで、startとcountという2つのパラメータを用いてインデックスにオフセットをかけた部分リストを表現する。あくまでデコレータなので自身にアロケーションコストはない。
区間を抽出できさえすればわざわざ新しいバッファを用意する必要がなく、またIListであれば区間抽出の計算コストが$O(1)$にできるという訳だ。
調子に乗ってクソでかいソースに対して使うとListの内部配列がLOH送りになってパフォーマンスに影響が出るかもしれないが・・・。このアルゴリズムも評価タイミングは(1)である。というわけでベンチマークを取ってみる。
とりあえず自分のマシンで回した結果は以下の通り。スペック
- CPU : Intel Core i7-6700K 4.00GHz (64bit)
- RAM : 32.0GB
- OS : Windows 10 Home
- 処理系 : .NET Framework 4.6.1 64bit※ X印はあまりの遅さにベンチマーク完走を断念したことを表します。遅すぎるわ！Skip &amp; Take その1、走らせてみるとこれはちょっと深刻に遅い・・・。
その2の方はその1に比べればかなりまし。下3つに比べればかなり不満な数字だが、評価タイミング(2)の実装でこれより速いのはちょっと思いつかない。評価タイミング(1)の実装だとBenchmark1の方ではArrayバッファが若干遅い。
しかし、これらの実装にとってBenchmark1は単にリストの末尾要素にアクセスするだけの操作になっているはず。
詳しくはよくわからないが、IEnumerable&lt;T&gt;としてアクセスする場合にはArrayよりListの方が速いみたいだ。Benchmark2ではArrayバッファが最速だった。
List 1とList 2の比較を見る限り、先行記事の実装は制御構造的にも速いようだ。RxのBuffer実装は存外速くない。
Queue &amp; ListとList 2の差が、Rxがオーバーロードのために払っているコストであり、それは決して小さくはないようである。今回実装したSingle ListはBenchmark1でListを返すものに比べごく僅かに遅い傾向があり、Benchmark2でもListには敵わない。
これは、デコレータを挟んだことでcallvirt命令が一つ余分に入っているせいなのではと思っている。
でも、オーバーロードに対応する前提でいえばQueue &amp; Listの実装よりもずっと速い。先行記事で紹介されていた実装はさすがの速さだった。
ArrayではIEnumerable&lt;T&gt;としてのアクセスに若干の不利があるようだが、Benchmark1のようなユースケースではそもそも即ToListなりするだろうから問題になりにくいだろう。
評価タイミング(1)の実装においてはBenchmark2の結果のほうが重要だ。
とは言えArrayバッファの実装はオーバーロードへの応用に難があるので、その点では単一Listバッファにもメリットがあるんじゃないかな。Skip &amp; Take その1の実装は色んなブログで見かけた記憶があるが、これはちょっと一考すべきパフォーマンスの悪さだと思う。
それほどシビアなユースケースでなくとも、可能な限りその2の実装に切り替えたほうがいい。
そのSkip &amp; Takeその2の実装もお世辞には高速と言えないが、分割後の各イテラブルにまで遅延評価がかかる実装はこれしかない。
もしもそういうユースケースがあるなら諦めて使わざるを得ないだろう。(正直そんなケースは思いつかないが)かなり関係ないところからスタートしてだいぶ遠回りしたが、ライブラリレイヤーではこういった厳密な仕様固めが大事だと思う。
ドキュメントを突き詰めてインターフェースの仕様をしっかり理解することに努めたのはいい経験になったかな。普通にコーディングしてる分にはRx使えばいいと思うよ。
ビバ、メジャーライブラリ。C#では、というよりILではthisは暗黙のarg.0 (0番目の引数)である。 ↩純粋でないオペレータを使っていればその限りではないが、そのようなケースは仕様外扱いで構わないと思う。 ↩Rx版(IObservable)では更に時間幅を引数に取るオーバーロードも存在するが、Ix版(IEnumerable)に同等の機能はない。IEnumerableの出力に時間的分布は考慮されない(もちろん、激遅コルーチンで無理やり時間差を付けることはできるが)ので当然といえば当然である。 ↩


