More than 1 year has passed since last update.本プログラムのソースコードは、github で公開してます。（MIT ライセンスです）
beziex/Beziex_Op [github] :  (https://github.com/beziex/Beziex_Op)2ヶ月ほど前に、「独自の高次元曲面パッチデータを WebGL 上でリアルタイムにテッセレーションし、ウェブブラウザに表示する 3Dモデルビューワ」を作ったということで、寄稿させていただきました。［前編］: WebGL でテッセレーションして、曲面パッチ間が滑らかに繋がった物体を表示（１）今回の投稿も「テッセレーション ビューワ」なのですが WebGL では無く、「OpenTK」で実装しています。よって、Web アプリではありません。（デスクトップアプリケーションです）
ちなみに WebGL 版では、ベースとなっている OpenGL のバージョンの制限からテッセレーションシェーダを使うことが出来ず、バーテックスシェーダとフラグメントシェーダだけでテッセレーションしていました。ジオメトリインスタンシングという方法です。（詳しくは、上記の記事をご参照ください）しかし OpenTK であれば、OpenGL のバージョン制限はありません。ということで、素直にテッセレーションシェーダを使う方法でプログラミングすることにしました。
でもそれだけだと、テッセレーションシェーダ使用の方が良いのかどうか分かりませんね。そこで、ジオメトリインスタンシング法にも切り替えれるようにして、さらにそれぞれの実行速度も表示できるようにしています。
実行速度の比較が出来れば、どちらが良いか一目瞭然でしょう。まずビルド環境／実行環境ともに、OS は 64bit 版 Windows のみ（Windows 10 以外は未確認）です。また使用言語は C# となっています。「WebGL 版テッセレーションビューワ」は一応マルチプラットフォームだったので、制限が加わり申し訳ないです。また WebGL 版では デモ を用意したので、即座に動きを見ることが出来ましたが、OpenTK 版ではセキュリティ上の観点から実行ファイルは置いていません。
そのため実行させるためには、前もってビルドが必要です。面倒くさくなってしまいましたが、ご容赦願います。まずビルドの為には、Visual Studio 2019 が必要です。ビルドについては、下記が参考になると思います。
Install environment for build / ビルド環境のインストールあとは普通にビルド＆実行できます。実行後の使用方法については、下記をご覧ください。
Usage ／ 使い方なお上記リンクのページにも書いてますが、起動しただけでは 3D モデルは表示されていないので、「General タブの "Open gzjson" ボタン」を押して、gzjson ファイルを選択します。
例えば「MascuteAzur001.gzjson」を選ぶと、下記のようなウインドウが現れるはずです。(スクリーンショット 左: "General" タブ選択時, 右: "Transform" タブ選択時)

ちなみにこの 3D モデルの元データは、WebGL 版の記事と同じく、クールなびじゅつかん館長さんのツイート を使わせていただきました。ということで、ユーザー寄りの説明はココまで。次項からは、技術的な説明に移りたいと思います。WebGL 版の記事と同じことはあまり書きたくないので、WebGL 版では使っていない本プログラム（OpenTK 版）独自の技術について記述します。具体的には、以下の技術です。ただし多少の前知識は必要なので、前もって WebGL 版記事の下記の項目を読んでおくと分かりやすいと思います。高次元曲面パッチ
曲面パッチと法線の関連性
シェーダ内での法線の計算この処理は、WebGL 版記事の下記の項目の前半と同様です。
コントロールポイント組み直し＆微分値用パラメータ生成の処理しかし WebGL 版記事にあるソースコードは TypeScript で書かれているので、本プログラム（C#）での該当箇所を以下に示しました。なおこれにより変換後の値は、1パッチ辺り「ベクトル値ベースで 80個」になります。WebGL 版ではパラメータ生成後、1パッチ毎に「80個の配列（配列要素はベクトル値）」に変換していました。
しかし OpenTK 版のテッセレーションシェーダを使う方法では少し違います。配列にすることに関しては同じなのですが、という形にします。
つまりこれにより $6\times14=84$ で、計84個の値となるわけです。なお必要な個数は 80個なので少し余ることになりますが、余った部分は使わなければ良いだけなので問題ありません。
ちなみに実際のコードでは、「テッセレーション関連の整数値（tessDenom）」も配列に入れてます。これについての詳細は割愛しますが、結果として配列に 81個の値を入れていることになります。そしてこの処理を行っているのが、同じく BxGlShadeVbo1 クラスの SetVertexBufferOne() 関数です。このコードを見ると、SetVertexBuffer0() ～ SetVertexBuffer5() という 6個の関数がありますが、この各関数はそれぞれ別の配列インデックスのオブジェクトに値をセットしています。
例えば SetVertexBuffer0() の中身を見てみると、下記のようになっていることが分かります。具体的には、pnt0 ～ pnt13 という 14個のメンバ変数に値を入れていますね。
なお vertexAry は 1パッチ辺りでは「配列 6個分」ですが、実際には全パッチの情報をすべて vertexAry に入れるので、「6$\times$パッチ数」の個数の配列となります。全パッチについて前項の GetPosDiff() と SetVertexBufferOne() を行い、vertexAry の情報を VBO に転送する処理を行っているのが、BxGlShadeVbo1.SetVertexBuffer() です。
そしてこの関数内の GL.BufferData() が、実際に転送を行っている箇所になります。前項で、GL.BufferData() により「vertexAry の情報を VBO に転送」しましたが、実際には vertexAry の各要素は、14個のメンバ変数から成るオブジェクトです。そのためバーテックスシェーダのコード内では、「14個の中の任意の値が、どのメンバ変数と対応しているか」を知っていなければなりません。
これを行うための OpenGL 上での仕組みが VAO で、本プログラムでは BxGlShadeVbo1.SetVAO() でこれを行っています。具体的には、ということにより、対応付けが成されるわけです。
なお上記コードを見ると「バーテックスシェーダ コード内の入力変数」として、vertPnt0 ～ vertPnt13 が定義されていることが分かります。そしてこの変数名は、この後バーテックスシェーダのコードを説明する際にも出てくることになります。CPU 側では、前項までで各種設定を行ってきました。そして最後にドローコールすることにより、実際に 3D モデルが表示されることになります。
これをやっているのが BxGlShaderBase クラスの DrawMain() 関数です。この中で重要なのは、OpenGL（OpenTK）の Draw 系関数である GL.DrawArrays() となります。
さらに GL.DrawArrays() の引数として PrimitiveType.Patches を指定していることにご注目ください。この指定により、テッセレーション系シェーダが使われることになります。ここでようやく GPU 側のプログラムに入ってきました。まずはバーテックスシェーダです。このバーテックスシェーダのコードは、上記を見てわかるように大したことは行っていません。入力変数である vertPnt0 ～ vertPnt13 の値を、出力変数の tescPnt0 ～ tescPnt13 に代入しているだけです。ただ vertPnt0 ～ vertPnt13 という変数名が、前述した VAO の項にも出てくることについては注目する必要があります。
すなわち CPU 側のバーテックスバッファである vertexAry 配列について、配列の各要素の 14個のメンバ変数が、GPU 側では vertPnt0 ～ vertPnt13 という変数になるわけです。次に実行されるのは「テッセレーション・コントロールシェーダ」ですが、これも大したことはしていません。以下のように、を行っているだけです。そして「テッセレーション・エバリュエーションシェーダ」のコードが実行されますが、これが GPU 側プログラムの要となります。
まずここでは、fromVbo() という関数を見てみましょう。この関数は、入力変数 tesePnt0[i] ～ tesePnt13[i]（i は 0～5）を、hPosBez0、vDiffBez3 等といった「3次または6次のベジェ曲線」「2次または5次の微分値用ベジェ曲線」に代入するためのものです。
なおこれら複数のベジェ曲線によって、独自高次元曲面パッチ（Beziex パッチ）が生成されるわけですが、これに関する式については下記を参照ください。
独自高次元曲面パッチの概要 ～ Beziex パッチの頂点位置に関する式
法線に関する おさらい ～ 曲面 A と曲面 B の偏微分値の混ぜ合わせ本プログラムでは、1個のパッチに対してということを行っています。このベクトル値はコントロールポイントと見なすことが出来るので、1個のパッチに 80個のコントロールポイントを使っているわけです。
しかし下記サイトを見てみると、1個のパッチの最大コントロールポイント数である GL_MAX_PATCH_VERTICES は、GeForce GTX 970M で「32」となっています。
Compute Performance of NVIDIA GeForce GTX 970M
（「OpenGL API : GeForce GTX 970M/PCIe/SSE2」を開いて検索してください）32 だと、80個のコントロールポイントは送り込めないですよね。ではどうすれば良いのでしょうか？
ヒントは、GL_MAX_PATCH_VERTICES の名前に VERTICES と書かれているというところにあります。VERTICES は頂点のことですが、例えばバーテックスシェーダで頂点を扱う際、1個の頂点には位置情報の他に法線／色／テクスチャ座標値等を付けたりしますね。すなわち 1個の頂点に複数のベクトル値を設定することが出来るわけです。テッセレーション・エバリュエーションシェーダでもそれは同じで、1個のコントロールポイント（頂点）に複数のベクトル値を置くことが出来ます。
実際上記サイトでは GTX 970M で、1頂点辺りの最大属性数である GL_MAX_VERTEX_ATTRIBS は「16」となっていました。つまり $32\times16=512$ で、1パッチ辺り最大 512個のベクトル値を置けるはずです（やったことは無いですが）。そのため 80個であれば、問題ないわけなのです。ただし「1個の頂点に設定する属性の数」は、すべての頂点で同じにしなければなりません。そこで、としています。「バーテックスシェーダ」の項で、vertPnt0 ～ vertPnt13 の値を tescPnt0 ～ tescPnt13 に代入していると書きました。つまりこれらの変数は、1コントロールポイントに設定する属性ということになります。
ということは、バーテックスシェーダの 1回の実行で処理されるのは、1個のコントロールポイントということです。1パッチ辺り 6個のコントロールポイントがあるので、1個のパッチで 6回バーテックスシェーダが実行されることになりますね。
もうここまで来ると、バーテックスシェーダの名前の由来である「頂点」とは関係が薄くなってきました。。また「テッセレーション・コントロールシェーダ」の項でも、tescPnt0[gl_InvocationID] ～ tescPnt13[gl_InvocationID] の値を tesePnt0[gl_InvocationID] ～ tesePnt13[gl_InvocationID] に代入するということについて書いています。
バーテックスシェーダとは異なり配列の一要素を代入する形になっていますが、これも 1回の実行で処理されるのは、1個のコントロールポイントです。テッセレーション・エバリュエーションシェーダの関数「fromVbo()」は、下記の関数からコールされます。これを見ると分かるように、fromVbo() の実行後、getPosition() や getNormalE() がコールされています。これらの関数は、分割後の頂点位置や法線を算定するためのものですが、詳細は下記リンクをご覧ください。
このリンクは WebGL 版の記事なので言語等が異なりますが、何となく分かるのではないでしょうか？
Beziex パッチの式（頂点位置）の実装
u 方向の偏微分値の式（曲面 A） ～ 曲面 A と曲面 B の偏微分値の混ぜ合わせちなみにテッセレーション・エバリュエーションシェーダでは、u および v の値を取得する際に gl_TessCoord を使います。本プログラムの UI の、General タブには「Tessellation algorithm」「Surface type」「GPU Benchmark (FPS)」という項目があります。Tessellation algorithm では、「Tessellation shader アルゴリズム」と「Instance geometry アルゴリズム」を切り替えることが出来ます。
このうち Tessellation shader は本稿でこれまで述べてきたアルゴリズムです。Instance geometry は WebGL版で使用しているアルゴリズムですが、本プログラムにも搭載されているので切り替えが可能なのです。
なお少し詳しい情報は、下記に載っています。
Tessellation algorithm ／ テッセレーション・アルゴリズム「Solid」はシェーディング面表示、「Wire」はワイヤーフレーム表示です。
Wire はオマケですが、ポリゴン分割の状態を見る際に分かりやすいと思います。本プログラムのベンチマークは「一つのフレームを作り上げるための全ての時間」を示すものでは無く、ドローコールの時間を計るものです。詳細は下記に述べています。
GPU Benchmark (FPS) ／ GPU ベンチマーク (FPS)以下に、「i7-6700HQ + GTX 970M + 64bit 版 Windows 10 Pro (1903)」上で、3D モデルとして「MascuteAzur001.gzjson」、分割数 8 で測定した実行例を載せました。ただし実際には Analyze ボタンを押す度に数値は変わるので、あくまでも目安と考えてください。上記の環境では、Wire 選択時のベンチマークがかなり遅いのですが、ゲーム等でワイヤーフレーム表示を行うことは少ないので、とりあえず無視しましょう。
そんなわけで Solid どうしで比較すると、ということが分かります。ちなみに分割数を上げると、さらに速度差が広がりますよ。ということで、WebGL 版テッセレーション ビューワに続いて、OpenTK 版も作ってみたのでした。
ちなみに本プログラム (C#) の UI は、で作っています。つまり MVVM パターンなのですが、これについては何も説明してませんでしたね。
何か機会がありましたらその時に、ということで。。。


