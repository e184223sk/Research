More than 1 year has passed since last update.かざぐるマウスからの乗り換え先を探してたのですが、要求条件を満たすものがなかったのでフルスクラッチで書きました。現時点(バージョン2.2)で僕が使うには不満のないデキになったので、紹介がてら、忘れないうちに開発のメモやポイントなどを書き綴ろうと思います。なお、C#で何かを書くのはこれが数回目で、かつ最新の文法書を通読したことがなく、逆引きでつまみ食い学習したため、C#的にはアレだったりするかもしれません。なにか変なところがあったら遠慮なくﾏｻｶﾘください。名前はCreviceAppで、2016年5月の第2週から6月の終わりまでを使って書きました。その後はドッグフーディングして、バグを見つけるたびに潰しています。信頼できるツールとして設計しました。取りこぼしなどがなく、高速で、イライラしません。
他のマウスジェスチャツールで標準的なものでも、僕が使わないであろう機能（GUIでの設定、ジェスチャ軌跡の描写機能など）はバッサリ切っています。
設定をC#スクリプト(csxファイル)として記述できるので、WindowsAPIを叩いたり、DLLをロードしたり、何でもできます。
ジェスチャとしてはストロークジェスチャ、ロッカージェスチャに対応します。
単純にボタンのクリックにアクションを割り当てたり、押下, 開放に直接フックを掛けることもできます。
オープンソース。MITライセンスです。
コア部分は2000行ほどとコンパクトなので、改造したりするのも簡単なのではと思います。zipファイルを適当な位置に解凍して、CreviceApp.exeを実行してください。
起動すると、自動的にデフォルトの設定ファイルが作られ、いくつかのジェスチャ定義が読み込まれます。デフォルトの設定ファイルには、ブラウザに対するジェスチャが一通り定義されています。タスクトレイにアイコンが出るので、それをクリックするとウィンドウが開きます。
「Open user directory」をクリックすると、エクスプローラーが%APPDATA%\Crevice\CreviceAppを開きます。default.csxが設定ファイルなので、後はそれを自由に書き換えて、アプリを再起動するだけです。Enjoy!まずジェスチャを定義するには@whenから始めます。フォアグラウンドアプリがChromeなときだけ発動するジェスチャを定義していきます。続いて、@on, @if, @doで一つのジェスチャが定義できます。RightButtonからのストロークジェスチャ↓→を定義しました。ここで発動するアクションはタブを閉じるになります。同様に@on, @if, @doを使って今度はRightButton + WheelDown, RightButton + WheelUpにタブの切り替えを割り当てます。これらはロッカージェスチャです。さてChromeはとりあえず置いておいて、コンテキストなしでX1Buttonにアクションを割り当ててみます。この@whenは常にtrueを返すので、ジェスチャはいつでも発動します。割り当てられたアクションはAlt + Tabです。よく使いますよね。ここで@onが指定されていないことに注意してください。つまりX1Buttonに直接アクションを割り当てたことになります。続いて、同様にコンテキストなしで、今度はX2ButtonのDown/Upにアクションを割り当てます。これでX2ButtonをCtrlキーとして使用することができます。@before, @afterはちょっと微妙な表現ですが、両者の間に@doを挟むことができるので、@doの前と後ということです。この@beforeと@afterが使えるのは、@ifがLeftButton, MiddleButton, RightButton, X1Button, X2Buttonのいずれかを引数に取るときだけであることに注意してください。@ifがWheelDown, WheelUp, WheelLeft, WheelRightを引数に取るときは@doのみが指定可能です。あるところに懐ゲーマニアがいました。彼は懐ゲーを愛し、毎日のようにプレイしていましたが、たったひとつだけ許せないことがありました。それはホイールコロコロでテキストを読み進められないゲームがあることでした。ホイールをクリックに変換してくれるようなツールもありますが、ゲームによっていちいちツールを設定し直すのが面倒なのでした。そこでCreviceAppです。RightButton + LeftButtonで機能のオンオフを切り替えることができます。ここで、設定中のグローバルな値であるWheel2Clickは、CreviceAppの起動から終了までの間を通じて保持されます。以上が簡単な説明になります。詳細な説明は適当な英語でプロジェクトページに書いています。@whenでの他のコンテキストの指定、Configでのパラメータの設定、WindowInfo, SendInput, Window, Tooltip, BaloonなどのAPIなど、ここでは割愛した内容を含んでいます。最新のリリースは2.2.153です。よかったら使ってみてください。rubyu/CreviceApp
Releases · rubyu/CreviceAppマウスジェスチャツールはマウス入力にフックを掛けて、飛んでくるマウスメッセージを解釈し、必要であれば何らかのアクションを実行し、最後にマウスメッセージに対する返答「よし通れ！」「通さぬぞ！」のどちらかを返します。このとき通過を許可されたマウスメッセージは、他のフックがあれば同様にその審査も経て、最終的にはアプリケーションに到達します。通過を拒否されたマウスメッセージは破棄され、他のフックやアプリケーションに渡ることはありません。エラー処理などは省いていますが、非常に簡単ですね。あとはアプリケーションの起動時にSetHook()し、終了時にUnhook()すれば、マウスジェスチャツールの骨組みはできあがりです。SetHook()した後にマウスメッセージが発生するたび、Callback()が呼ばれます。ここにキモとなるロジックを書き加えていくことになります。注意: 後述しますが、WH_MOUSE_LLなどのグローバルフックを掛ける場合、SetWindowsHookEx()をコールしたスレッドがメッセージループを持っていなければなりません。参考:
SetWindowsHookEx 関数
CallNextHookEx 関数
LowLevelMouseProc 関数例えば、右クリックから開始されたジェスチャがタイムアウトでキャンセルとなった場合、このRightButtonDownをマウスジェスチャツールから送信する必要があります。いろいろな方法がありますが、mouse_eventには後述する問題があるため、SendInputを使うのが無難ではないかと思います。実装例: CreviceApp/WinAPI.SendInput.cs at 2.0 · rubyu/CreviceAppリンク先の実装例では、キーボードメッセージ、及び複数個のメッセージの送信にも対応しています。keybd_event, mouse_eventには複数個のメッセージを、他の入力に妨げられることなく連続したものとして送信する機能がないため、SendInputをオススメします。注意: 後述しますが、SetWindowsHookEx()でグローバルフックをセットしたスレッドと同一のスレッドからマウスメッセージを送信すると、特定の環境で問題が発生します。このような場合は別スレッドからマウスメッセージを送信するようにしてください。参考:
SendInput 関数
INPUT structure (Windows)
MOUSEINPUT structure (Windows)その他のAPIとして、定番どころではSendMessage, PostMessageなどがあります。マウスジェスチャツール本体では使用しなくても、ユーザーアクションから呼び出せると便利でしょう。ウィンドウハンドルが絡むので、CreviceAppではカプセル化して簡単に扱えるようにしました。ざっくりとしたコードは以下のようなものです。実装例: CreviceApp/WinAPI.Window.cs at 2.0 · rubyu/CreviceAppユーザーアクションだけを隔離して、かつ実行順序を保証するために単一のスレッドで実行したいようなシーンでは、勝手TaskSchedulerを書くのがよさそうでした。バルーンメッセージやトーストで通知するのは大仰だというときに、任意の場所にツールチップを表示できるとよいのですが、スマートにやる方法にはたどり着けませんでした。とりあえず以下のように力技でどうにかしました。なお、座標についてはある程度、Windows側でよしなにやってくれます。例えば1920x1080のディスプレイ環境でTT.Show("どや！", 1920, 1080);としても、ツールチップはタスクバー上には表示されず、タスクバーを除いたエリアの右下隅にフィットするように表示されます。マウスジェスチャには様々な種類があります。ボタンを押したままマウスを動かすストロークジェスチャ、あるボタンを押したまま他のボタンを押すロッカージェスチャ、あるいは単にあるボタンを押すという動作もジェスチャとして扱いたいかもしれません。それらの全てをフラグで管理していたのでは大変ですし、とても保守できる気がしません。何かスマートな解決策が必要です。そこで同時に押すボタンは2つまでとして、という3つの状態を考えれば、これらは明らかに有限で、その遷移も明白なように見えます。有限状態マシンで実装するのがよさそうです。この2番目の状態を、「ジェスチャを開始したボタンを復元できるかどうか」でさらに2つに分けて、次のような合計4つの状態を考えました。実装としては次のようなものです。なお、シングルアクションボタンはWheelUp, WheelDown, WheelLeft, WheelRightのいずれか、ダブルアクションボタンはLeft, Middle, Right, X1, X2のいずれかです。後者にはボタンの押下と開放に対応した、セットとリリースの2種があるとします。どうでしょうか、状態ごとに分けて考えると、それほど難しくないと思います。全ての遷移を書き出して、それに対応するコードとテストを書いていくと安心です。遷移の例: CreviceApp/Core.FSM.Transition.cs at 2.0 · rubyu/CreviceApp多岐にわたるマウスジェスチャツールの用途を網羅するような、万能な設定をGUIで作り込むには途方もない時間がかかりそうです。CreviceAppの場合、1人しか使う予定がないマウスジェスチャツールのために膨大な人月をつぎ込むのは明らかに誤りでした。ここはスッパリとGUIを切り捨てて、テキストベースで設定を行えるようにしましょう。もちろん、テキストベースといっても、独自のスクリプトを作り込んだりするのも明らかに時間の無駄です。ちょうどMicrosoft Roslynの安定版がリリースされた頃だったので、これをマウスジェスチャツールに組み込みました。たったこれだけのコードで、csxファイルをコンパイルして実行できます。後は設定を表現するDSLを定義して、コードに書き下していけばいいだけです。あとはこの@whenから始まるDSLで記述された設定を、扱いやすいようにパースしていけばいいでしょう。パーサの実装例: CreviceApp/Core.DSLTreeParser.cs at 2.0 · rubyu/CreviceAppここまで簡単にマウスジェスチャツールの作り方を解説してきました。要するに、これだけです。ここまで読んでくれたあなたなら、きっとマウスジェスチャツールを実装できます。そしていざ、マウスジェスチャツールを実装するときに注意してほしいことがあります。それはレイテンシです。与えられたマウスメッセージは可能な限り迅速に処理しなければなりません。コールバック関数内でマウスメッセージを処理している間の時間が、ラグとしてユーザーのエクスペリエンスに影響を与えます。また、後述しますが、あまりにもラグが酷いと、フックがシステムによって外されてしまうこともあり得ます。低レイテンシを心がけてください。
CreviceAppが行っている低レイテンシのための対策としては、などがあります。SetWindowsHookEx()をコールしたスレッドはメッセージループを持っていますか？ c++ - Why must SetWindowsHookEx be used with a windows message queue - Stack OverflowもしかしてWH_MOUSEでフックを掛けようとしていませんか？ C#でやるにはかなり茨の道だと思われますので、必要がなければWH_MOUSE_LLを使ったほうがいいような気がします。C#でWin32 API(グローバルフック等)を使用してデバッグすると「指定されたモジュールが見つかりません」と表示されたとき。 - Code for final「Visual Studio ホスティング プロセスを有効にする」チェックをはずすと普通に動いた。恐らくCallback関数がGCに回収されてしまうことが原因です。前述のコードに以下の修正を加えてください。具体的には、delegateとして変数に保持していれば大丈夫です。もしかして、ロジックの実行に時間がかかりすぎたりしていませんか？Global hooks getting lost on Windows 7 – Decrypt my Worldマウス入力をフックして、マウスメッセージを解釈し、何らかのアクションを実行する。…あれ？ 例えば右クリックから開始されたジェスチャがキャンセルされたとき、右クリックをマウスジェスチャツールが復元するとします。マウスジェスチャツールが送信したマウスメッセージはフックを経由して、またマウスジェスチャツールに戻ってきてしまいます…。この問題に対する簡単な対処の仕方は次のようなものです。しかしこの実装には問題があります。マウスジェスチャツールが復元したマウスメッセージは期待通りにフックを通過しますが、フックを一時的に解除しているため、その間にマウスから発生したメッセージもフックを通過してしまいます。マウスジェスチャツールによくある漏れというのがこれです。この実装では結果的にユーザーのマウス入力を意図通りに解釈できず、ツールの信頼性は損なわれます。よりよい対処は、マウスジェスチャツールが発行したマウスメッセージには署名を埋め込むというものです。例えばペンデバイスからの入力かどうかは、dwExtraInfoを0xFFFFFF00でマスクした後に0xFF515700と比較することで確認できます。
参考: System Events and Mouse Messages (Windows)署名を埋め込むことにすれば、あとはマウスメッセージの署名を比較して、フィルタリングをするだけです。マウス入力にフックを掛けつつ、同時にマウスメッセージを送信すると、特定の環境で問題が発生することがあります。具体的にはWindows10環境で、ユニバーサルアプリが動いてるときのみ、何秒間か、アプリケーションがフリーズするというものです。調べると、StrokesPlusで似たような現象が過去に生じていたようです。StrokesPlus Forum - Free Mouse Gesture Utility for Windows XP/Vista/7/8この問題は別スレッドからマウスメッセージを送信することで解決します。その条件というのはWindows10でユニバーサルアプリが動作しているとき…。はい、お察しの通り前述の問題です。同様の対策をとるか、あるいはWindows10のユニバーサルアプリを全部終了させてからテストを実行してください。こんな通知ですら、この問題が発生するんです…。つらい。
Windowsは、ある程度自動的に、アプリケーションの表示をディスプレイのDPIに合わせてスケーリングしてくれます。ただし、アプリケーションの認識するカーソル位置までスケーリングされてしまうと、マウスジェスチャツールの動作は正常なものではなくなってしまいます。自動的にディスプレイのDPIにアプリケーションの表示を追随させつつ、正しいカーソル位置を取得するには…という問題は以前は難しいものだったのですが、Windows 10 Creators Update（バージョン1703、ビルド15063）から新しくPerMonitorV2が追加され、多くのアプリケーションで簡単に解決できるようになりました。WindowsのHigh DPI及びPer-Monitor DPIに対応するにはアプリケーションのマニュフェストに以下のような記述が必要になります。なお、上記の設定で、カーソル位置のスケーリングは無効になり、正しいものを取得できるようになりますが、2種のPer-Monitor API（PerMonitor, PerMonitorV2）が追加された前後、つまりWindows 8.1以前、Windows 10 CU以前、Windows 10 CU以降でそれぞれアプリケーションの表示スケーリングは異なります。そう、異なるのです…。CreviceAppではHigh DPI環境の人はWindows 10 CU以降を推奨しますよーということでお茶を濁します。dwExtraInfoに0xFFFFFF00のような雑なパターンを与えるとその他のブラウザでは正常に動作するが、Chromium Edgeだけで右クリックが効かなくなる不具合が生じます。


