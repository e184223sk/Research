ReactivePropertyのBooleanNotifierクラスに関する記事です。ToReactiveCommandしたときに、事故りそうなケースをまとめました。
長くなったので、最後のまとめを読んでいただければと思います。「なぜそうなっているのか」について、2011年の記事を引用して背景を詳しく説明されています。
BooleanNotifierをToReactiveCommandしたときの挙動、が思っていたのと違う理由
（@soi様から頂いたコメントより）（@okazuki様から頂いたコメントを受け追記）公式のドキュメントが増補されました。
日頃ReactivePropertyを使わせていただいている身としては恐れ多い限りです。先述のsoi様の記事にある通り、使いどころを考えて使うのが大前提でありつつ
もしつかうのであれば、引数にinitialValue: n.Valueとして変数のステータスを渡すのがシンプルかつ安全です。
キャプチャ画像出典：https://okazuki.jp/ReactiveProperty/features/Notifiers.html#booleannotifier私はC#のWPFアプリケーションを作っています。
使用しているライブラリの1つはReactivePropertyです。
ReactivePropertyはNuGetパッケージマネージャーからインストール可能です。
2020年12月18日現在の最新版は7.5.1です。先日、ReactivePropertyのBooleanNotifierクラスを使っていて、少し混乱することがありました。
よくよく調べてみると、混乱が解消されました。
この記事は、混乱したことと解消の経緯について書き残す目的があります。BooleanNotifierはIObservable&lt;bool&gt;を実装したシンプルなクラスです。
掃除機の電源ボタンのように、オン（True）とオフ（False）をスイッチする使い方ができます。真偽値のトグルを、ReactivePropertyとBooleranNotifierのそれぞれで書いてみます。BooleanNotifierの詳細な説明は、下記ドキュメントに記載されています。ReactiveProperty documentation - BooleanNotifierBooleanNotifierはIObservableを実装しているので、ReactiveCommandのソースにできます。It can use to source of ReactiveCommand.（引用元：ReactiveProperty documentation - BooleanNotifier）さっそく、ToReactiveCommand拡張メソッドでReactiveCommandをつくってみます。
比較参考のために、ReactiveProperty&lt;bool&gt;も使います。ビューモデルは以下のようになります。
Prismテンプレートを使っています。ビューは以下のようになります。
BooleanNotifierをソースにしたボタンを上方に、ReactivePropertyをソースにしたボタンを下方に配置してます。Visual StudioでF5キーを押して実行した直後の画面が以下のようになります。ビューモデルでは、ソースの初期値をfalseにしていました。ボタンのソースの初期値はどちらもinitialValuse: falseなのに、なぜ画面起動直後のボタンの状態に差があるのか？画面起動時はどちらのボタンも非活性な状態であることを期待していました。
しかし、実際はBooleanNotifierをソースにしたボタンは押せる状態でした。
ReactivePropertyは押せない状態であり、期待通りでした。画面起動時に、ボタン（ReactiveCommandバインド）を非活性にするためには、ToReactiveCommand拡張メソッドの引数に初期値falseを与えます。以上です。
これで期待通りに動きます。ToReactiveCommandに引数をあたえることで、確実にバインドしたボタンの初期状態を既定できることが分かりました。
しかし、若干の二度手間感が残りました。ソースのinitialValuseを踏襲してボタンの活性/非活性が決まるものと勝手に思い込んでいましたが、そうではないみたいです。ReactivePropertyはGitHubスター数500を超える超優良ライブラリです。
そんなソースコードが誰でも閲覧できます。BooleanNotifierがどういう経路をたどってReactiveCommandになるのかもソースコードを読めば分かります。第二引数のデフォルト引数はtrueです。
第二引数を指定しなければ、ボタンは活性化した状態になることが推定されます。（引用元：https://github.com/runceel/ReactiveProperty/blob/main/Source/ReactiveProperty.NETStandard/ReactiveCommand.cs）しかし、ReactivePropertyをソースにしたボタンは、ToReactiveCommandの第二引数を指定しなくとも、初期状態が非活性のボタンが生成されました。コマンドの活性/非活性はICommandのインターフェイスのCanExecute()の実装で決まります。ReactiveCommandの活性/非活性はprivateプロパティのIsCanExecuteで決まるようです。（引用元：https://github.com/runceel/ReactiveProperty/blob/main/Source/ReactiveProperty.NETStandard/ReactiveCommand.cs）（引用元：https://github.com/runceel/ReactiveProperty/blob/main/Source/ReactiveProperty.NETStandard/ReactiveCommand.cs）initialValuseはToReactiveCommandと同じ値をとるので、IsCanExecuteはtrueになります。ソースのcanExecuteSourceにはメソッドチェーンで処理がぶら下がっており、最後にお馴染みのSubscribeでIsCanExecuteプロパティにソースの値を代入しています。ソースであるBooleanNotifierとReactivePropertyの値が変更されたら、ボタンの状態も変わりそうです。BooleanNotifierもReactivePropertyもnewしかしていない。
ソース側のSubscribeで何かしている？参考）メソッドチェーンの途中の処理については本家okazuki殿の記事を参照ください。Reactive Extensions再入門 その２３「重複を排除するメソッド」
Reactive Extensions再入門 その４５「Scheduler」BooleanNotifierを購読すると、値がsetされたときにOnNextで通知がなされます。（引用元：https://github.com/runceel/ReactiveProperty/blob/main/Source/ReactiveProperty.NETStandard/Notifiers/BooleanNotifier.cs）一方、ReactivePropertyでは（引用元：https://github.com/runceel/ReactiveProperty/blob/main/Source/ReactiveProperty.NETStandard/ReactiveProperty.cs）念のためif条件がTrueになることも確認しました。Subscribeの中でOnNext()が記述されているため、ToReactiveCommandして購読した時点で現在の真偽値がバインド先に通達されていた
ということが分かりました。だんだん自分でも何が言いたいのか分からなくなってきました。
まとめます。BooleanNotifierの場合は、ソースの状態をボタンへ反映させるために、ToReactiveCommandの引数に初期状態を渡す必要があります。ReactivePropertyの場合は、ソースの状態は勝手にボタンに反映されます。裏を返せば、ToReactiveCommandの引数に渡す真偽値は意味を持ちません。（ソースの状態が優先されます）何か間違いがございましたら、指摘していていただければ幸いです。


