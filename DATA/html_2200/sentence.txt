この記事は React #2 Advent Calendar 2019 19日目の記事です。本職は、C#でWindows Formを使ったレガシーなアプリケーションを作っています。ただ、レガシーなアプリを作っていると、Webフロントエンドは、進化が早くて、活発で、
なんかキラキラしている感じがして、うらやましくなってきます。Reactは、趣味だけなのでまだまだですが、そんなC#エンジニア(以降、C#er)から見たReact入門を解説したいと思います。同僚がReactを勉強したいと言い出したので、そのための資料でもあります。React の Advent Calendar ということで他の方がReactのTipsを公開している中、
一人だけ空気を読まなくて申し訳ないです・・・。なお、Webフロントエンド界隈は進化や世代交代が早いので、
この記事の賞味期限もせいぜい半年～1年くらいだと思っています。(2020-09-02 Modified)
予想通りライブラリやツールのバージョンアップによっていろいろ変更なようです。
この記事は自分でも使っていて不便なので最低限問題ないように修正しました。
(もしかしたら抜けがあるかも？)(2020-10-04 Modified)
上の対応ではだめだったので、さらに追記しました。(2020-12-31 Modified)
なんかAdvent Calendar 2020の影響でPVが増えたのかストックされる方が増えたので
いろいろ動かないところを最低限アップデートしました。
* MobX ver.6.0.0 以降に対応
* .envファイルは不要になった
* Visual Studio Codeでnode_modules以下のTypeScriptを使用する設定Webアプリのフロントエンドを構築するためのJavascriptライブラリです。
最近の流行として、htmlのページ遷移無しで、1ページ内で完結させようという流行(SPA、Single Page Application)があり、ReactはSPAを実現するためのフレームワークの1つです。
主な役割はhtmlのレンダリングであり、C#でいうと、WPFにおけるXAMLや、WindowsFormsの*.Designer.csに相当します。レガシーなWebサイトの場合、htmlでコンテンツを管理して、 見た目はCSS、何か動かすならJavascriptという感じだったと思います。ただ、htmlで使えるのは決まったタグだけで、 部品化ができず、凝ったことをしようとすると作りこみが必要なわりに、それを他のページに展開するにはコピペが必要になってしまいます。Reactを使うと、独自のHTMLタグを増やすことができるようになります。
さらに、単なるhtmlの部品ではなく、Javascriptもセットになっているので、
部品化によってリッチなUIを簡単に作ることができるようになります。C#でいうなら、既定のButtonやLabelしか使えない状況から、UserControlが使えるようになったものです。公開されている部品を組み合わせてもいいですし、もちろん自分で部品を作ることもできます。例えば、次のようなブログのトップページをイメージしてもらうと、1つの記事のサマリーがAbstractContentという部品になっていれば、 それを並べればTopページが作れます。さらにAbstractContentも何かの部品を組み合わせているので 次のようなツリー構造になります。部品の例としては、material-uiのサイトを眺めるとこの部品化がイメージしやすいと思います。 Reactの部品はこんな感じで作ります。細かい説明は、他サイトを参考にしてもらったらよいと思いますが、
ポイントは次の2つです。BlogPartsPropsうんぬんは、C#のWindows Formで例えると、こんな感じで、外からセットされるプロパティに相当します。なお、Reactは、classで部品を作るパターン(Class Component)と、関数で部品を作るパターン(Functional Component)がありますが、C#erとしては、前者のほうがイメージしやすいです。
ただし、今の流行や推奨は後者のFunctional Componentです。React Hooksとかもこちらのようです。今回は、C#er向けということでClass Componentでいきます。Typescriptは、Javascriptに型を導入した言語です。
ビルド(トランスクリプトというらしい)するとjavascriptになります。
ビルド結果のjavascriptは人が読むことは想定されていないようなので
ビルドするとバイナリになるC#に近い使用感です。
生のJavascriptは型がなく、なんとなくで実装できてしまいますが、
C#をやっている身からすると型が無いのが恐ろしいです。ということで、Typescript、おすすめです。言語的にはC#に近い言語っぽいけど、Javascriptの制約を引きずっているのと、独自進化しているようで、
知らない仕様がけっこうあります。簡単なクラスを例にするとこんな感じです。React界隈でも問題になったようで、Flaxというアーキテクチャが生み出されています。参考: https://facebook.github.io/flux/簡単に解説すると、(1)内部状態(Store)は1か所に集約する、
(2)GoFのCommandパターンで状態を更新する(ActionとDispatcher)、
(3)Viewは内部状態をただ表現するだけ、のようです。
この発想自体は、Windowsアプリケーションでも参考になりそうですね。ただ、理念は良さそうですが、Flax実装の一つで一番人気のReduxは肌に合わなかったです。
単にReduxの実装がよくないだけかもしれませんし、
Commandパターンにありがちな、無駄に実装量が増えるあたりかもしれません。代替策を調べた結果、もう少し簡易的な状態管理ライブラリである、MobXが良さそうに思えました。
MobXは、上の(1)～(3)の中では、(2)はあきらめて、
DIとGoFのObserverパターンを追加した感じです。
WPFにMVVMパターンがありますが、それに似ています。すなわち、いろいろなViewModelは1か所で管理されて、Viewの定義に従ってDIされる、
ViewModelで状態が変わるとView側(React)に通知が来て、再描画される、という感じです。C#でMobXに似たような実装を書くとこんな感じ。参考: https://mobx.js.org/README.htmlさて、基礎知識はここまでとして、実際に手を動かしてみましょう。
思ったより長くなったので、興味ない方は、以降は読み飛ばして、まとめに行ってもらってもいいです。環境は、C#er前提なのでWindowsです(ほかの環境でも動きそうですが確認していません)。
また、次のアプリをインストールしておく必要があります。なお、React本体やTypescriptコンパイラは開発用フォルダにダウンロードされますので 上記以外ではOSを汚しません。(・・・はず)まずは開発環境を作ります。 次のコマンドで、create-react-appというReact開発環境のテンプレートを生成するツールをダウンロードします。なお、npmはC#でいうところのNugetです。ダウンロードしたモジュールはnode_modulesフォルダに入っており、実行モジュールはnode_modules/.binにあります。
それを使って、開発環境を生成します。
第一引数はフォルダ名(およびプロジェクト名)を、第二引数の--typescriptはJavascriptではなくTypescriptを使うことを指定しています。出来上がった開発環境のフォルダに移動して、実行してみましょう。&lt;&lt;2020-12-31 Deleted&gt;&gt;
この.envファイルは、最新のReactで不要になったようです。
一応、古いバージョンを使うこともあるので、記事はこのまま残しておきます。&lt;&lt;2020-10-04 Added&gt;&gt;
npm start で開発用サーバーとブラウザが立ち上がるはずですが・・・
次のようなエラーが出ることがあります。
eslintのバージョンが高すぎると出るようですが、
reactにeslintが含まれているのでエラーになってしまいます。対処方法は、エラー出力に書いてある通りで、一度eslintを消すのが正解ですが、
ここでは面倒なので、もう一つの方法であるエラー無視の方向にします。次のようなファイルを作ります。これで、 npm start でエラーが出なくなります。&lt;&lt;2020-10-04 Added終わり&gt;&gt;
&lt;&lt;2020-12-31 Deleted終わり&gt;&gt;&lt;&lt;2020-12-31 Added&gt;&gt;
Visual Studio CodeでApp.tsxを開いたときに次のようなエラーになることがあります。Cannot use JSX unless the '--jsx' flag is provided.エラーメッセージだけだと意味不明ですが、
Visual Studio Codeが使用するTypescriptのバージョンが古いと発生するようです。
Visual Studio CodeのステータスバーにTypeScriptのバージョンが表示されていますので、
それをクリックし、[Select TypeScript Version] → [Use Workspace Version]で
node_modules以下のTypeScriptを使用するように設定できます。上記の設定をすると、settings.jsonに以下のように記録されますので、直接settings.jsonを編集しても良いようです。&lt;&lt;2020-12-31 Added終わり&gt;&gt;出来上がった開発環境のフォルダに移動して、実行してみましょう。初期の画面が表示されます。 npm start は、Visual Studioのデバッグの開始のようなもので、
自動的にhttpサーバーが起動し、ソースがビルドされて、Webページが表示されます。この状態で、ソースコードを一部変更してみます。
Visual Studio Code等のテキストエディタでsrc/App.tsxを編集します。ソースコードを変更すると自動でビルドされ、Webページも更新されます。終了は、コマンドプロンプトでCtrl+Cです。開発環境のファイル構成はこんな感じです。
よく使うファイルは説明を付けました。このままでも開発可能ですが、コードチェックの設定を行って、楽をしましょう。
C#でいうと、Visual Studioのコード分析か、Resharperですね。必要なパッケージをダウンロードします。(2020-09-02 Modified)
reactをバージョンアップしたら、このやり方だとエラーが出るようになりました。eslintはすでに導入されているため追加でインストールしてはいけないようです。
参考: https://qiita.com/arakappa/items/9781556a8a67b6779a0eコードチェックのルール用ファイルを作成します。次のコマンドでソースコードのコードチェックが行われます。デフォルト状態では、大量にエラーが表示されます。次に、Visual Studio Codeでの警告表示と保存時の自動Fixを設定します。
Visual Studio Codeの設定ファイルに以下を追加します。ファイルやフォルダがなければ新規作成してください。(2020-09-02 Modified)
Visual Studio Codeをバージョンアップしたら動作しなくなりました。
新しいeslintプラグインの書き方に変更する必要があるようです。
参考: https://qiita.com/mysticatea/items/3f306470e8262e50bb70これで、Visual Studio CodeでJavascriptやTypescriptのファイルを開いた場合に以下のように警告が表示され、
上書き保存時に自動修正できる箇所は修正されます。eslintの出力に記載があるように--fixをつけると自動Fixできますが、ファイル数も少ないので、
Visual Studio Codeで1つ1つファイルを開いては上書き保存していきます。もう一度eslintを実行すると、自動解決できない警告だけになっています。 
ここでは、気にしない方向で無視します。
なお、@typescript-eslint/explicit-function-return-typeを無視するようにeslintrc.jsonに記載するか、serviceWorkerの関数の戻り値をちゃんと宣言すれば、警告を消せます。毎回、上記のeslintコマンドを入れるのは面倒なので、mpn scriptにします。 (なおnode_modules/.bin のパスは、npmコマンドで実行すると解決されるので不要です)これで、npm run lintで実行できるようになります。参考App.tsxのデフォルトは、Functional Componentです。
上で話した通り、C#er的にはClass Componentのほうがわかりやすいので、Class Componentに変更します。といっても、わりと機械的な作業で、 React.Componentを継承したclassを作って、
デフォルトで実装されていたApp関数をrender関数にします。ポイントは以下です。npm startしてみると、当然ですが、見た目は変わりません。参考: https://qiita.com/daikoncl/items/a3806d8a8bf35f086487Reactのデフォルトでは、標準のhtmlタグしか使えません。 デザインセンス無しでそこそこイケてるWeb画面を作るために、既存の部品を使います。
ここでは、上で紹介した、Material-UIです。まずパッケージをインストールします。そして、material-uiを使ったUIにApp.tsxをマルっと書き換えます。
Cardを使って、ブログのサマリーページ的な感じにしました。
Cardの使い方は、Material-UIの公式を参考に。
https://material-ui.com/components/cards/npm startしてみると次のようになります。
いろいろスタイルは手抜きですが、影とかアイコンとかそれっぽくなりました。参考: https://material-ui.com/現状、コンテンツはApp.tsxに埋め込まれています。 
普通のサイトを考えるとJsonをサーバーから取得すると思います。ざっくりJsonを想定するとこんな感じでしょうか。Webページの組み込みは、いったん後回しとして、 サーバーからJsonを取得して、このデータをWebページに渡すViewModelを作り、 単体テストで動作確認します。まずは、サーバーがないのでテスト時にHTTPリクエストを代替するパッケージfetch-mockを入れます。そして、ViewModelとユニットテスト用に2つのファイルを追加します。ついでに、上の変更ですでに壊れているので src/App.test.tsx を削除します。
(個人的にViewのテストは難しいわりにリターンが少ないので、あまりしません。
 Typescriptで型はチェックできていますし。)ユニットテストを実行してみましょう。成功しました。良さそうです。参考: http://www.wheresrhys.co.uk/fetch-mock/ViewModel AppStore はルートである Index.tsx の stores で管理し、App にインジェクトします。まずは必要なパッケージをインストールします。そして、MobXはデコレーターを使用するのでTypescriptのオプションを変更します。index.tsxでストア(stores)を作り、 状態を管理する&lt;Provider&gt;&lt;/Provider&gt;でAppを囲い、
Providerにはstoresを渡します。
これにより、Appの要求に従って、Providerから必要なViewModelを渡されます。ストアの appStore を受け取るように App で宣言します。ポイントは以下です。これで、index.tsxのstores内のappStoreがAppに渡されます。なお、当然ですが、見た目は変わりません。上までで、AppにViewModelであるAppStoreが渡されたので、AppStoreの状態を使ってWebページを更新するようにします。 App.tsxをマルっと書き換えます。ポイントMobXは、プロパティが変更されたことを検知して、Viewを再描画させる機能を持っています。
これを使って、データが取得されたときにViewを更新します。
そのために AppStore のメソッドとプロパティに属性を付けます。(2020-12-31 Add)
MobX ver.6.0.0以降では、属性を使用しない仕組みに変わったようです。
コンストラクタで makeAutoObservable(this); を呼ぶと
自動でメンバーに @observable を付けたことになるようです。
@observable は不要になったようですが、私はなんとなく毎回付けてしまっています。
参考: https://mobx.js.org/migrating-from-4-or-5.html#upgrading-classes-to-use-makeobservableこれでサーバーデータに応じた画面を作ることができましたが、
このままでは、サーバーは存在しないのでエラーになります。
ユニットテスト用のfetch-mockを流用してダミーデータを使うようにします。これで、 npm start すると以下のようになります。dummyDataをいろいろ変えてみるとWebページが変わると思います。Reactの部品化の練習のためにTOPページのサマリー要素部分を部品化してみます。上と同じようにReactコンポーネントのclassを作って、
renderでは、App.tsxで部品化したい部分を返すようにします。
必要なパラメータはPropsで上から渡してもらいます。
なお、Storesで状態管理するのはページごとで、部品ではViewModelは使わないほうが良いようです。App.tsxのほうは、上で作った部品を使うように書き換えます。
なお、部品の参照は、importです。
また、不要になったimportも消しておきましょう。相変わらず見た目は変わりませんが、
サマリー部分の部品化ができました。なお、この部品は再利用しないので、部品化はあまり意味はありません。SPAといえども、普通のHtmlのようにページ遷移がしたいことが多いです。
概要←→詳細 で行き来することもありますし、1ページいろいろ押し込むと使いにくいですし。ここでは、React-Routerを使ってページ遷移を作ります。まずページ遷移があるということはURLを設計しないといけません。
簡単ですが、以下のようにします。では作ってみましょう。まず、必要なパッケージを取得します。次にTOPページから詳細ページへのリンクを作ります。
React-Routerでのリンクは&lt;Link to="url"&gt;ラベル&lt;/Link&gt;を使いますので、
タイトル部分をリンクに置き換えます。
URLはPropsに追加して、親ページから渡してもらうことにします。親ページでは、URLを渡すように設定します。これでトップページからのリンクはできました。
では、詳細ページを作っていきます。作り方は、App.tsxと同じでページ(ContentPage.tsx)とViewModel(ContentPageStore.ts)を作って
MobXで連携させます。React-Routerの本番はここからです。
今までindex.tsxで&lt;App/&gt;と直接Reactコンポーネントを指定していたところを、
&lt;BrowserRouter&gt;で囲って、&lt;Route/&gt;を並べていきます。
&lt;Route&gt;のcomponent=にReactコンポーネントを、path=にURLを指定します。また、ViewModelもStoresに追加します。これで、/の場合はAppのページが、/contents/(id)の場合は、ContentPageのページが表示されるようになります。
URLのルートURLは、&lt;BrowserRouter basename=に指定します。昔ながらのCGIをやっていた方は、URLが違うなら別のhtmlが返ってくるのでは？という気がしますが、
SPAの場合は、バックエンド側で同じindex.htmlを返すように設定するようです。一応これで完成なのですが、相変わらずバックエンドがないので
ダミーデータを返すようにします。以上で、簡単ですがブログっぽいページができました。
TOPページからリンクをたどると、詳細ページに飛びます。
URLも変化していますので、F5を押しても元ページに戻ったりしません。ある程度アプリができたら、ビルドしてデプロイできるようにします。
次のコマンドを実行すると、buildフォルダに成果物が出来上がります。Javascript用にいくつかライブラリがあるようです。基本的には、言語ごとにJsonを用意して、キーとなる文字列を指定すると、
実行時には言語に応じたJsonから文字列が取れるようです。C#のResources.resxと比較すると、型がないので、インテリセンスが使えない分、ちょっと面倒です。以前やったときに、Typescript＋Jsonスキーマを使うといい感じに改善できそうだったので、
また記事を書くかもしれません。Node.jsもいいですが、C#erなら、過去のC#の資産を使えるASP.NET Coreを使いたいです。Visual Studioで[プロジェクトの新規作成]-[ASP.NET Core Webアプリケーション]→[React.js]で
テンプレートを作って、ClientApp以下を上と同じ手順で作ったReact開発環境で置き換えれば、
いいようです。普通にF5実行で、Reactのフロントエンド＋C#のバックエンドで起動しました。
なお、初回はビルドが走るのか重いようです。問題は、ASP.NET Coreを動かすサーバーを用意できるかどうか。htmlが不慣れとかいろいろ要素がありますが、
私の場合、Windows Formで作るほうが3倍くらい速いです。C# ←→ Typescriptの変換も面倒ですし、
画面レイアウトの作りこみも大変です。
というか、C#を振り返ると、Visual StudioのWindows Formのデザイナーはよくできているなぁと思います。
(壊れやすいのが難点ですが)割とがっつりReactの入門記事になってしまいましたが、
普段C#を使っている方の視点で、解説したつもりです。
Reactを使ってSPAを始めるための一通りを説明したつもりなので、
あとは応用を学んでいけば、そこそこのプロダクトが作れるのではないでしょうか。なお、上で作ったコードは、一応GitHubに公開しておきます。
(この記事の賞味期限が有効なあたりまでは残しておきます)
https://github.com/banban525/react-example-2019自分で打ち込むのが面倒な方はそちらを見てもらってもよいと思います。
個人的には写経はおすすめですが。


