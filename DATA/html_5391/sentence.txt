More than 3 years have passed since last update.二つのオブジェクトが等しいかどうかはどうやって確かめていますか？
最も多いのは次のように == 演算子を使うケースではないかと思います。文字列 a と b の内容を a == b で比較したところ、異なっているので False が出力されています。
しかし C# でのオブジェクトの比較法はこれだけではありません。大きく分けて次の三つがあります。この三つを混同しないよう、これから順に説明していこうと思います。
その前に次のクラスと構造体を用意しましょう。ExampleClass は参照型のクラス、ExampleStruct は値型の構造体です。
参照型と値型について詳しくは次の参考資料をご覧ください。参考資料: 2-3 値型と参照型大雑把に説明すると、参照型のオブジェクトを保持する変数にはオブジェクトのデータそのものではなく参照(メモリ上のアドレス)が入っていて、価型のオブジェクトを保持する変数にはオブジェクトのデータそのものが入っています。
あまり大きなデータを値型として宣言すると受け渡しに時間がかかるので、int, long, DateTime などのサイズが固定された比較的小さなオブジェクトが値型で実装されます。そして string などのどれだけデータがあるかわからない大きなオブジェクトは参照型で実装した方が良いでしょう。参照による比較には System.Object.ReferenceEquals() を使います。
これによって実際のメモリ上の位置によってオブジェクトが比較されますので、異なったインスタンスのもの(それぞれ別個に new したもの)を比較すると False と判定されます。一番わかりやすい比較ですね。
同じ遺伝子を持っていても別々に生まれたなら双子でも別人ということです。コメントで指摘を受けました。ReferenceEquals() は参照渡しでないので値型はコピーが渡され、同一インスタンスでも必ず False になります。値による比較には System.Object.Equals() を使います。classA と classB は別のものと判定されて False を返しましたが、structA と structB は同じものと判定されて True を返しました。
structA と structB は参照は違いますがどちらの Text プロパティも null で初期化されています。
値が同じなので Equals は True を返します。この続きで structA.Text のみを書き換えてみましょう。比較すると、False を返しました。
プロパティが異なるので値が異なったとみなされたからです。さて、class と struct で Equals が違う結果を出したわけです。
ここから導かれる結論は、「Equals は比較対象が参照型の場合は参照で比較し、値型の場合はプロパティで比較する」となり……ません！
大事なことなのでもう一度言います。
Equals は比較対象が参照型の場合は参照で比較し、値型の場合はプロパティで比較するのではありません。
なぜ二度も言ったかというと、そのような説明を読んだことがあるからです。
もう一度……もういいですか。そうですか。
デフォルトで参照型は参照を比較しますが、それはあくまでデフォルトの話なのです。では値による比較つまり Equals による比較は何をもとにしているかというと、ずばり Equals です。
何を言っているかわかりませんか。そうですか。先ほど紹介した Equals は二つの引数を取り、そこで与えられた二つのオブジェクトを比較するものでした。
Equals にはもう一つのオーバーロードがあります。
それは引数を一つだけ取り、自分とほかのオブジェクトを比較するものです。これを説明するために ExampleClass を書き換えてみましょう。Equals() と GetHashCode() をオーバーライドしました。ではこのクラスを使って同じように実験してみます。先ほどとは異なる結果が出ました。
両者とも同じ値として True を返しています。二つの引数を取る Equals は、そのクラスで実装された一つの引数を取る Equals を内部で呼び出し、その結果をもって比較しているのです。
つまり値による比較は比較されるオブジェクト自身が自分と他者を比較するというのが正解です。これが何を意味するかと言うと、次のような恐ろしい結論です。Equals() で比較するときには、そのオブジェクトが比較をどのように実装しているか、つまり何をもって値が等しいと判断しているかを知らなければならないということです。何が恐ろしいかですって？
決まってるじゃありませんか。
そのオブジェクトの仕様を知らなければ Equals は使えないということです。
参照による比較と最も大きな違いはここです。
参照による比較なら何も読まなくても簡単に結果がわかります。
しかし値による比較はソースかドキュメントを読む、または他のオブジェクトから類推するより他ないのです。
例えばこのように無茶苦茶な仕様で実装してみましょう。これを比較してみます。classA はどんなオブジェクトと比較されても true を返します。
structA はどんなオブジェクトと比較されても false を返します。
その結果、同じものを比較しているはずなのに順番によって結果が異なるという、このような狂った結果が出るようになってしまいました。このように実装次第でとんでもないことになってしまう値による比較ですが、「怖い怖い。もう参照でしか比較しない！」とは言わないでください。
例えば Dictionary&lt;,&gt; などはキーを参照ではなく値で比較しています。
だから異なるインスタンスでも辞書に入れることができるのです。
値による比較ができなくなればとても不便なことになります。ですから、値による比較を適切に実装するのは作者の責任です。
ソースやドキュメントを読まなくても使えるよう、ごく自然に「同じ値だね」と言えるような実装をしてください。次のクラスで試してみます。上記のように結果は、参照は異なり、値は等しく、== ではないという結果になりました。
同じことを string で行ってみましょう。おわかりでしょうか。
今度は == になりました。
以上のように、== は ReferenceEquals でも Equals でもありません。方法: 型の値の等価性を定義する (C# プログラミング ガイド) によると== 演算子と != 演算子は、オーバーロードされなくてもクラスで使用できます。 ただし、既定の動作として参照の等価性のチェックが実行されます。 クラスで Equals メソッドをオーバーロードする場合は、== 演算子と != 演算子をオーバーロードすることをお勧めしますが、必須ではありません。とあります。つまり Equals をオーバーライド(オーバーロード？ オーバーライドの間違いじゃないのかな)するならば == と != も併せてオーバーライドオーバーロードする方がいいということですが、同時に「必須ではない」というざっくり加減です。
警告も出ません。出ませんが、ここはきちんとオーバーライドオーバーロードして値の比較に合わせることにしましょう。※ 追記：コメントにより指摘をいただきました。ミュータブルな参照型については == 演算子 != 演算子のオーバーロードは避けるべきとのことです。以上、三種類の基本的な比較について説明しました。
他にも比較の方法がありますので、少し触れます。配列を比較してみます。はい、全部違います。
しかし要素がすべて同じなら同じものとみなしたいことがあると思います。
そんな時はこうします。シーケンス(複数の要素の連続)の比較は LINQ の SequenceEqual() を使います。
これは IEnumerable&lt;T&gt; を実装するものなら配列でも List でも Stack でも何でも使えます。
この時、各要素の比較に使われるのは Equals() です。CompareTo() を実装します。
このインターフェースは等しいか等しくないかだけの比較ではありません。
二つのオブジェクトのデフォルトの並び順を指示するものです。IComparable&lt;T&gt; と非常に紛らわしいですが、IComparable&lt;T&gt; がデフォルトの並び順を指示するのに対し、こちらはその時々に応じた並び順を指示します。
例えば数値や文字列はデフォルトの並び順を持っています。
何も指定されなければその順にソートされます。
IComparer&lt;T&gt; は実際にソートする時点でデフォルトでない並び順を指定したいときに使うものです。IComparer&lt;T&gt; と Comparison&lt;T&gt; の用途は同じで、並び順のカスタマイズに使います。
しかし前者がインターフェースなのに対して後者はデリゲートです。
インターフェースを実装するにはクラスを作らなければならないのに対してデリゲートはラムダ式で作ることができるので、後者の方が遥かに手軽です。
これらは使い分けをするものではなく、単に前者が古い方法で後者が新しい方法というだけですので、後者が使える時には後者を使いましょう。


