More than 1 year has passed since last update.RoslynのCodeAnalysisを使用し、渡されたインターフェースから実装クラス構築に関するメモ。
構築の様を見るため、nullを返すだけのスタブクラスにとどめていることに注意。Roslynが作るコードツリーを覗くと同じ手順の見極めのため、NUnitベースRoslyn APIのパッケージを加える以下のインターフェースに対する実装クラスを作成する。名前空間、クラス、メソッドについてのユニットテストを書くため、CompilationUnitRootを定数として保持。また、構文木の操作が何かと面倒なため、Syntaxクラスに対するExtensionおよびHelperを作成（内容は徐々に追記）ToClassDeclarationメソッドは、拡張クラスのメソッドとして用意アクセス修飾子や親クラスなど、直接構文木でやろうとするとかなり面倒。
string interpolationで構築した文字列をパーズすることで手を抜けそう。ToMethodStubメソッドはヘルパークラスに定義した注意点はインターフェースのメソッドに付与されたセミコロンを除去する必要があることのみまた、SyntaxTokenからSyntaxTokenListへの変換は、メソッドチェインで書けるよう拡張クラスに定義したToUsingDirectiveはヘルパクラスに定義した。Roslyn公式WikiのGetting Started C# Syntax Analysisでは、1パートずつQualifiedNameSyntaxを組み立てる方法が提示されているが、ドット繋ぎが多いとクソめんどくさいことこの上ないため、クラス定義の時同様、文字列からパーズするのが楽だと思われる（そこまで高コストでもなさそう）。最終行のコメントを外すと、テスト出力で構築されたクラスのコードが確認できる。CollectMethod、およびToSyntaxListメソッドは拡張クラスに定義し、メソッドチェインで書けるようにした。コード内でのコンパイラの起動は、こことか、ここを参考にした。ビルドする上で必要となるため、インターフェースおよび戻り値の実定義を用意した。ビルドに失敗した場合、Emitメソッドの戻り値であるEmitResultのDiagnosticsプロパティをにコンパイルエラーの内容が記録されている。ビルドにより生成したバイナリをAssemblyとして展開、リフレクションでインスタンス化、実行してるだけ。
テスト上、インターフェースの型が既知のため、静的キャストでお茶を濁す。Roslynいぢりをやろうと決心した翌日に、Source Generatorsが発表される。当初、コンパイル時コード生成をCodeGeneration.Roslynに頼るつもりであったけど、突然の電撃発表に心揺らぐ。ただし、まだファーストプレビューゆえのVisual Studioでとりあえず動くようにしましたレベルらしく、また生成結果も文字列でしか受け付けない模様なので、もう少し様子見するつもり。構文木から、ソースコードへの変換も、Trivia（インデントや改行）を適切に付与しておけば、`ToFullString()メソッドで行えるため、100%無駄にはならなさそう（と信じたい）。


