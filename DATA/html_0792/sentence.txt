もくじ
→https://qiita.com/tera1707/items/4fda73d86eded283ec4fPrism関連
https://qiita.com/tera1707/items/4fda73d86eded283ec4f#prism%E9%96%A2%E9%80%A3wpfxamlコード
https://github.com/tera1707/WPF-/tree/master/024_PrismSamplePrismの画面遷移をさせるうえで、
RegionManager.RequestNavigate("リージョン名",・・・);としているが、
その時に、画面のViewModelのクラスのインスタンスを一旦破棄して、再度遷移した際にもう一度作り直したい、というケースがあった。その際、「インスタンスを破棄」とかでやり方を調べていると、という二つのやり方が見つかった。簡単に試したところ、どっちも
画面Aから画面BにRequestNavigateで遷移した後、再度画面Aに戻った際、画面Aのコンストラクタが呼ばれている。つまり、どちらも画面Aは画面Bに遷移後、一旦破棄されてる？？まったく同じことに対してやり方が2通りあるのか？
でもそんなわけがない、何か違いがあるはず、と思ったので、何が違うのか調べてみる。結果、下記である、自分の中ではなった。つまり、両方ともコンストラクタが呼ばれる、イコール、新しいVMのインスタンスが作成されてるが、KeepAliveをfalseにする方は古い(別画面に遷移後の、元の画面の)インスタンスは破棄されてるが、IsNavigationTargetの戻り値をfalseにする方は、古いインスタンスが実は破棄されてない。そのため、②のほうは、画面遷移回数が増えると作成される画面１のインスタンスも増えることになるので、おそらくメモリリークにつながる。
⇒画面のインスタンスを毎回破棄して、次回遷移時に再作成したい、という目的のために、IsNavigationTarget  をfalseにする、ということを行ってはいけない！今回やりたい「画面遷移するたびに毎回画面のVMのインスタンスを破棄したい」ということをする場合は、KeepAliveをOFFしてからRequestNavigateで画面遷移させるのが良い。その上で、そうすると、下記のようなログが残る。そうすると、下記のようなログが残る。そうなると、画面遷移回数が増えると作成される画面１のインスタンスも増えることになるので、おそらくメモリリークにつながる。
⇒画面のインスタンスを毎回破棄して、次回遷移時に再作成したい、という目的のために、IsNavigationTarget  をfalseにする、ということを行ってはいけない！現状正直なところ、仕事で出会った流用元のコードでprismを使ってて、prismを理解しないまま出てきたとこだけを場渡り的に調べて乗り切っている状態なので(この記事はその時のメモ)、prismの全体的な理解が足りてないために、こういう部分で詰まってしまう感触を感じ出した。一度しっかりprismの基礎を勉強しなおした方が、結局は急がば回れで早いかもしれない。
(ただ年強するなら6.3.0ではなく新しいのを勉強したいが...)


