More than 1 year has passed since last update.Unity 公式チュートリアル「Space Shooter tutorial」をコードから理解してみる という投稿をしましたが、今回はこれをベースに拡張し、簡易的なゲームエンジン的なものとして汎用化し、それを用いて独自のシューティングゲームを作成してみます。【前編】 では、元のサンプルゲーム に対し、岩石に大きさと耐久度の差をつけ、真っすぐ高速に進んでくるミサイル、弾を斜めに発射する中ボス的な敵キャラ、赤い敵エース機などを追加し、敵の拡張を中心に実施しました。この後編ではステージごとの難易度の上昇や、タイトル画面を作成し、ゲームとして最低限の体裁を整えたいと思います。完成品は コチラ でプレイ可能。まずはステージを実装してみます。Done_GameController スクリプトを対象に、まずは private 変数 stage の追加と初期化。サンプルゲームでは内部的に wave の概念があるので、これをステージにそのまま利用します。つまり、wave ごとにステージを1つ進めることになります。そして画面表示ですが、ちょっと手抜きしてスコア表示とあわせて実施してしまいましょう。ただこれだと2行目になったステージ表示が画面に描画されないので、Score UIテキスト・オブジェクトのインスペクターから、高さを倍の 60 に変更しておきます。

これでゲーム実行時に、左上にのスコアの下に、ステージ数も表示されるようになりました。ゲームが進んでいくと、ステージ数も増加していきます。
最初から全ての種類の敵が出現すると難しすぎるため、最初のステージではサンプルゲームと同じ岩石と紫の敵だけ出現するようにし、ステージが1つ進むごとに新しい敵が1つ追加されるように修正します。試しプレイしたところ、各ステージが短すぎる気がしたので、Done_Game Controller オブジェクトの Hazard Count を倍の 20 に変更して、ステージ中に表示されるオブジェクトの数を増やして調節してみました。
上記の修正だけだと、ステージ4くらいで新キャラの登場がなくなり、難易度が変わらなくなってしまいます。もう少し調整してみましょう。まずは細かいですが、各ステージ中に登場する敵オブジェクトの数を、ステージが進むにつれて増やしてみます。修正(1)の部分です。また敵の出現待ち時間を、ステージが進むに従って少しずつ短くしていきます。これにより敵の出現量が多くなり、難易度が上昇します。ステージ25ぐらいで難易度が頭打ちになりますが、現時点ではこれが超絶難しいので、それ以上は不要に思われます。各ステージを長くした結果、ゲームオーバー時にリスタート待ちの時間が長くなってしまいました。すぐ表示されるように修正してみましょう。まず、wave の終了待ちをしていた部分の一部をコメントアウトし、同じ処理を gameover() 関数の中にコピーします。これで自機が破壊された直後にリスタートの表示が出るようになりました。Unity では PlayerPrefs クラスを用いて、ゲームデータの保持ができます。これを利用して、ハイスコアを記録する仕組みを実装します。まずは Done_GameController スクリプトに、ハイスコアの読み込み部分を実装します。保存キーは "hi-score" とし、初期値は 0 です。後は GameOver() 関数に、表示と保存のロジックを追加します。そうそう、gameOverText オブジェクトの高さも、忘れず倍にしておきましょう。

これでゲームオーバー時に、ハイスコアを獲得していれば「Hi Score!!」という文字列が画面中央に表示されるようになります。

なおハイスコアを削除するには、Unity エディタの編集メニューにある「すべてのPlayerPrefsを消去」を実行してください。ゲームとしての体裁も整ってきたので、いよいよタイトル画面を作成してみましょう。とはいえ、今回はお手軽に 公式アセット「Unity Samples: UI」Menu 3D シーンで uGUI の基礎を理解する で理解した宇宙っぽいメニューの部品を流用して楽しちゃいましょう！まずは新規にシーンを作成し、

Title という名前で Done_Main と同じフォルダに保存します。

Unity Samples: UI アセットから SF Scene Elements PreFab をエクスポートし、

今回のゲームで読み込んで、新しく作成した Title シーンに配置します。
まず新規で UI 要素の Canvas を追加します。インスペクターの設定はそのままで大丈夫でしょう。
そして Canvas の子要素として TextMeshPro - Text を追加します。初回は以下のようなポップアップが表示されるので、ボタンをクリックして必要なファイルを読み込んでおきましょう。

表示するテキストをゲームタイトル(今回は Space Shooter tutorial+)に変更し、色やフォントのオプションを好みで設定します。ついでにハイスコア表示用と、キー操作説明(Press 'S' for Start\nPress 'Q' for Quit)用に UI Text を二つ、その下に配置しておきましょう。シーンを実行して配置を確かめます。

さて、タイトル用のコードを書きましょう。SF Scene Elements のインスペクターで「コンポーネントを追加」から「新しいスクリプト」を選択して TitleScript と名前をつけます。

Done_GameController スクリプトのコードを参照して、以下のようにハイスコア読み込みと、キーに応じた処理を記述します。hiScoreText にはハイスコア表示用の UI Text をインスペクターで指定しておきます。

これでハイスコアの表示とタイトル画面からの遷移はokです。あとはゲーム画面からタイトル画面へ戻れるように修正する必要がありますね。Done_GameController スクリプトの GameOver 関数で表示メッセージを追加します。表示される行数が増えるので、例によって Restart テキストの高さを倍の 60 に変更しておきます。

ゲームオーバー時に右上に表示されるテキストが変更されていることを確認しておきましょう。

そして Done_GameController スクリプトに、ゲームオーバー時に Q キーを押した場合の処理を追加します。これでゲーム用の Done_Main シーンと、タイトル画面の Title シーンの間の遷移が設定できました。ゲームとしての体裁が整った感じですね。「さぁ、実験を始めようか。」と、いよいよビルドのフェーズです。今回は WebGL で「ビルドして実行」を実施してみます。

問題なくビルドできたようで、ローカルで Web サービスが立ち上がってWeb ブラウザでゲームをプレイすることができました。

Web ブラウザで実行される場合、PlayerPrefs データはブラウザの IndexedDB に格納されている模様。

ビルド結果は以下のように指定したフォルダに出力されており、サイズは13Mバイトぐらいでした。

生成されるのは通常の Web コンテンツなので、生成されたフォルダ内で webserv などのWeb サーバーを起動させれば、そちらでも動作確認が可能です。そして生成されたフォルダの中身をWeb サーバーにアップロードすれば、ゲームを公開可能です。実際に http://rinco.jp/unity/sst1/ に公開してみましたので、よろしかったらプレイしてみてください。
GW は過ぎちゃいましたが、公式チュートリアルをベースとして簡単なシューティングゲームを作成してみました。シンプルですが、ゲームとして必要な要素はだいたい揃っていると思いますので、独自ゲームを作成する際に参考にしていただければ嬉しいです。それではまた！


