プログラミングを進める上で、何度も似たような処理を書くのは非効率的であり、ソースコードの可読性を下げる要因にもなります。
その為、何度も必要とされる処理は1度だけまとめて書いておくことで、それを複数の箇所から呼び出せるようにすることができます。これを "メソッド" と呼びます。※他の言語では「関数」「サブルーチン」と呼ばれるものです。基本的なメソッドの書き方は次のようになりますメソッドは "パラメータ" として値を受け取ることができ、反対に "戻り値" として値を返すことができます。
また、 "return文" で戻り値として定義した型の値を返すことができます。上記Addメソッドはint型の値を2つ受け取り、その和を戻します。エントリポイントもメソッドであり、戻り値はなし(void)かつパラメータとしてstring型配列のargsを受け取っています。
※戻り値の前に付いている "static" は "修飾子" のひとつですが、これは "クラス" の話をするときにまとめて触れます。メソッドのパラメータとして値を指定する時、定義上のパラメータを "仮引数" 。メソッドの呼出し側が関数に渡す引数を "実引数" と呼びます。
※ただの用語で、あまり重要ではありません。上記のように単純にパラメータを指定した場合、 "値渡し" と言います。
この時、メソッド内部で仮引数の内容を変更したとしても、当然それは実引数側に反映されることはありません。上記に対してパラメータの前にin/out/refを付けることで "参照渡し" を使用することができます。
このin/out/refなどは "パラメータ修飾子" と呼ばれます。それぞれ少しずつ動作が異なるので表にまとめると以下のようになります。in修飾子in修飾子は呼出し側で最初に値を代入し、初期化しておかなければ使用することができません。
またメソッド内部ではin修飾子の付いたパラメータを変更することはできません。
これはメソッドの呼出し側に「値が書き換わらないこと」を保証することになりますが、これは先述の値渡しと同じ動作になります。
値渡しと違い、実引数→仮引数へのデータのコピーが発生しないので、巨大なデータを取り扱いやすいというメリットがあります。out修飾子out修飾子は呼出し側でのパラメータの初期化を必要としません（初期化しても問題ではありませんが、メソッド内部での代入を強制するので意味がありません）。
メソッド内部ではout修飾子のついたパラメータは何らかの値を代入する必要があり、その値をメソッドの呼出し側へ返却することになります。
つまり、return文による戻り値とは別に値を返したい場合などに使用されます。ref修飾子ref修飾子はメソッド呼出し側およびメソッド内部のどちらでも初期化や代入を強制することなく、自由に使用することができます。
使い勝手は一番いいですが、反対にメソッド内部と呼出し側でやり取りされるデータの管理が煩雑になりやすいことが挙げられます。上記は値型についての話でしたが、参照型についても同様に値渡しと参照渡しを行うことができます。
代表的な参照型のひとつである配列でその動きを見てみましょう。参照型は値型と違い、持っているデータはメモリ上の実体を指す参照アドレスである為、値渡しでも「アドレスのコピー」を渡すことになり、そのアドレスが指している実体は同じものになります。
なので、参照先の実体に対する変更は、値渡しと参照渡しのどちらでも同じような結果になります。しかし一方で、メソッド内部で新たに参照を割当てた場合、値型と似たような挙動になります。値渡しの時に参照アドレスをコピーしましたが、そこに新たに別の参照先を割当てることで、メソッド内部での仮引数には別の実体2が割当てられました。
しかし実引数の方は変わらず元の実体1を指したままになります。参照渡ししている方は値型と同様に、元の実引数に対して新たに参照先を割当てるため、メソッドの呼び出し側でも値が変更されていることが確認できます。メソッドに渡すパラメータはデフォルトの値を設定しておくことが可能です。これを "デフォルト引数" と呼びますデフォルト引数は呼出し側から指定しなかった場合にデフォルトの値となり、指定した場合にはその指定された値となります。
また、デフォルト引数はメソッド定義上、通常のパラメータよりも後ろにのみ設定することが可能です。基本的に同名のメソッドを複数定義することはできませんが、パラメータが異なれば別のメソッドとして認識されます。
これをメソッドの "オーバーロード" と呼びます。パラメータの型や個数が異なればオーバーロードが可能です。
ただし、戻り値のみ異なる同名のメソッドではオーバーロードとしては認識されません。メソッドについてはここまで。


