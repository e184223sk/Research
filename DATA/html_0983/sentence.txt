More than 1 year has passed since last update.前に書いた記事が 2015 年のものだったので 2020 年用に書き直していこうと思います。ReactiveProperty 7.1.0 を想定して書いています。また、WPF か UWP か Xamarin.Forms での MVVM 開発の基本的な知識と Reactive Extensions の基本的な知識があることを前提に記載しています。他の記事はこちらです。ReactiveProperty は Cysharp の @neuecc さんが開発したライブラリになります。
現在も、UniRx や UniTask などでの成果をたまにバックポートするプルリクエストをくれます。多謝。GitHub でソースコードは公開されています。WPF や UWP や Xamarin.Forms などの XAML を使用するクライアント サイドのアプリケーション開発でよく採用される MVVM パターンをサポートする機能やリアクティブ プログラミングとシームレスに繋ぐ機能が含まれています。主に XAML 系プラットフォームで MVVM を採用するときに省力化のために採用されることが多い ReactiveProperty ですが、特に MVVM の何かに依存しているクラスライブラリではないので、利用しようと思えば何処でも利用可能なライブラリになります。コア機能のターゲットフレームワークは .NET Standard 2.0 で、その他に WPF や UWP などのプラットフォーム固有機能は、それぞれのプラットフォーム向けのパッケージが提供されています。ReactiveProperty の基本機能は ReactiveProperty クラスと ReactivePropertySlim クラスになります。ReactiveProperty クラスと ReactivePropertySlim クラスは INotifyPropertyChanged インターフェースと IObservable インターフェースを実装した Value プロパティを持つクラスです。
以下のように使用できます。INotifyPropertyChanged インターフェースを持っているので PropertyChanged イベントを購読することで値に変更があったときに処理が行えますが、これは WPF や UWP などのデータバインディングで使用するためのものなので、値に変更があったときの処理は Reactive Extensions のメソッドを使用して行います。Subscribe メソッドを使うことで、簡単に値に変更があったときの処理が行えます。MVVM パターンのアプリケーションでは、プロパティに変更があったことを INotifyPropertyChanged インターフェースを実装して PropertyChanged イベントを発行することで View に伝えます。そのため、ViewModel クラスに INotifyPropertyChanged を実装してプロパティに変更通知の機能を実装します。
この変更通知のコードは以下のように同じようなコードの実装の繰り返しなので非常に冗長になります。基本クラスの導入などで若干省力化は出来ますが、書いていてあまり楽しいコードではありません。ReactiveProperty を使うとプロパティの定義は以下のようになります。この省力化が出来ることが ReactiveProperty の導入の 1 つの動機になります。XAML 側では以下のようにバインドします。上が普通の書き方で、下が ReactiveProperty の場合の書き方になります。ReactiveProperty を使った場合は実際の値を持っているのは ReactiveProperty の Value プロパティなので .Value が Binding のパスに必要になります。ReactiveProperty には ReactiveProperty クラスと ReactivePropertySlim クラスの 2 種類のクラスがあります。この後紹介する読み取り専用の ReadOnlyReactiveProperty も Slim と無印があります。原則としては Slim がついている方で良いケースではなるべく Slim を使うことを想定しています。Slim のほうが機能が少ないですが Slim のほうが性能が桁違いに良いです。Slim との機能面での差異は後程説明します。ReactiveProperty には ReadOnlyReactiveProperty や ReadOnlyReactivePropertySlim というクラスがあり、これは IObservable から作成できます。読み取り専用のプロパティとして動作する点が特徴です。
例えば 1 秒ごとに 1, 2, 3, 4, ... のようにカウントアップしていく IObservable&lt;int&gt; の変数 ox に対して ToReadOnlyReactiveProperty や ToReadOnlyReactivePropertySlim を呼び出すことで作成できます。この場合 IObservable&lt;int&gt; から新しい値が発行されると Value プロパティの値が更新される ReadOnlyReactiveProperty や ReadOnlyReactivePropertySlim が作成されます。コード例を以下に示します。ReactiveProperty や Reactive Extensions を使うと様々なものが IObservable として扱えます。つまり、様々なものを ReadOnlyReactiveProperty/ReadOnlyReactivePropertySlim にすることが出来ます。ReactiveProperty や ReactivePropertySlim や ReadOnlyReactiveProperty や ReadOnlyReactivePropertySlim は全て IObservable として扱えます。そのため以下のように Reactive Extensions の Select などのメソッドを使って加工した ReactiveProperty の値を ReadOnlyReactiveProperty に変換できます。例えば文字を大文字に変換して ReadOnlyReactiveProperty に変換する処理は以下のようになります。イベントのようにアプリが動いている間に、任意のタイミングで何かが起きるようなケースのものも IObservable と扱うことが出来ます。例えば INotifyPropertyChanged インターフェースの PropertyChanged イベントを IObservable として扱うための ObserveProperty 拡張メソッドが Reactive.Bindings.Etensions 名前空間に定義されています。ObserveProperty でラムダ式でプロパティを指定すると、そのプロパティの変更があるたびに値が発行される IObservable になります。それに対して ToReadOnlyReactiveProperty を呼ぶことで ReadOnlyReactiveProperty が生成されます。コード例を以下に示します。ReactiveProperty を使う上での一つの勘所として、IObservable に変換できるものを見極めて ReadOnlyReactiveProperty に変換するというのがあります。ReactiveProperty と ReadOnlyReactiveProperty は、Value プロパティが変わったときの PropertyChanged イベントを自動で UI スレッドで発行する機能があります。
WPF 以外の UWP や Xamarin.Forms では、UI スレッド以外で PropertyChanged イベントを発行するとアプリケーションがクラッシュする可能性があるので自動で UI スレッドでイベントが発行してくれる機能は便利な側面があります。ただし以下のようなデメリットがあります。ReactiveProperty のスレッド切り替えは ReactivePropertyScheduler.SetDefault メソッドで指定が可能です。指定しない場合は自動的にアプリケーションの UI スレッドに切り替えるスケジューラーが指定されます。デフォルトの挙動は以下のようになります。WPF アプリケーションのボタンクリックイベントで以下のようなコードを書くとデバッグコンソールに以下のように表示されます。この挙動を変えるにはアプリケーションの起動時の処理で ReactiveProperty が使用するスケジューラーを置き換えます。例えば WPF では App クラスの Startup イベントで置き換えが出来ます。以下のコードは即座に実行する ImmediateScheduler を設定しています。この変更をした後に実行すると以下のような内容がデバッグコンソールに表示されます。アプリケーションが単一の UI スレッドであることが保証されている場合は便利な機能ですが、挙動などを把握していないと意図したとおりに動かないと感じる原因になるので注意してください。ReactiveProperty には、入力された値のバリデーションを行う機能があります。ReactiveProperty の SetValidateNotifyError メソッドで入力値のチェック処理が書けます。エラーがある場合はエラーメッセージを返して、エラーがない場合は null を返します。例えば空文字の入力を許可しない ReactiveProperty は以下のようになります。これを WPF の Window の DataContext に設定して TextBox とバインドします。そうすると、以下のようにエラー時には赤枠が表示されて ToolTip でエラーメッセージが表示されます。ウィンドウの初期表示の段階でバリデーションエラーが出ていると見た目よろしくないので初回のバリデーションエラーをスキップする機能も提供しています。
ReactiveProperty のコンストラクタや ToReactiveProperty の mode で ReactivePropertyMode で指定可能です。列挙型で | 演算子で複数指定できます。デフォルト値は ReactivePropertyMode.Default なので、それに加えて ReactivePropertyMode.IgnoreInitialValidationError を追加します。以下のようなコードになります。初回実行時には、バリデーションエラーが起きません。何かを入力して、再度空文字にするとエラーが表示されます。また、バリデーションは DataAnnotations で指定可能です。DataAnnotations には必須入力を表す Required や特定の値の範囲にあることをチェックする Range や正規表現にマッチするかどうかをチェックする RegulerExpression など様々な属性が提供されています。
必要があれば独自のチェックロジックの属性を作成可能です。ReactiveProperty に対して属性をつけて SetValidateAttribute メソッドを使ってラムダ式で対象の属性がついたプロパティを指定することでバリデーションが有効になります。バリデーションエラーのメッセージは、ObserveValidationErrorMessage メソッドで IObservable&lt;string&gt; として取得できます。そのため以下のようなコードを書くことでエラーメッセージをハンドリングできます。実行結果は以下のようになります。最初のほうで ReactiveProperty は IObservable から作れるという説明をしました。なので、ObserveValidationErrorMessage の結果に対して ToReadOnlyReactivePropertySlim などを呼び出すとエラーメッセージを保持する ReadOnlyReactivePropertySlim などを作ることができます。
これを使って好きな場所にエラーメッセージを表示することができます。バリデーションでも登場しましたが、ReactiveProperty, ReactivePropertySlim, ReadOnlyReactiveProperty, ReadOnlyReactivePropertySlim の生成時に mode 引数で挙動を若干カスタマイズ可能です。mode は ReactivePropertyMode 列挙型で以下の値を指定できます。上記の値は | 演算子で区切って指定可能です。ReactiveProperty は、普通の C# のクラスのプロパティをもとにして作ることが出来ます。C# のクラスが INotifyPropertyChanged インターフェースを実装している場合は ToReactivePropertyAsSynchronized メソッドを使って特定のプロパティと同期した ReactiveProperty が生成されます。ToReactivePropertyAsSynchronized メソッドには、プロパティの値を変換するロジックを含めることが出来ます。この変換処理は単純なラムダ式による変換だけでなく、IObservable 型を受け取る変換ロジックを使うことで変換処理の他に任意の条件でのフィルターや、別の IObservable との合成などが可能になります。以下の例は特定の値が来た場合に ReactiveProperty から Person への反映を行わないようにした例になります。ToReactivePropertyAsSynchronized はバリデーションにも対応しています。デフォルトではバリデーションエラーがあっても元になったオブジェクトのプロパティに値を書き戻しますが、ignoreValidationErrorValue 引数に true を設定することでバリデーションエラーの値を自動的に元になったオブジェクトに書き戻さなくなります。以下の例は空文字の場合は、元になったオブジェクトに書き戻さないようにした例です。INotifyPropertyChanged を実装していないクラスには ReactiveProperty.FromObject(...) メソッドを使って ReactiveProperty から元になったオブジェクトへの書き戻しのみに対応した ReactiveProperty が作成できます。
元になったオブジェクトから ReactiveProperty への値の反映は ReactiveProperty を作成した時に一度だけ行われます。コード例を以下に示します。INotifyPropertyChanged を実装したクラスのプロパティの値を読み取り専用で ReactiveProperty にしたい場合は既に紹介した ObserveProperty メソッドから ToReadOnlyReactiveProperty/ToReadOnlyReactivePropertySlim を呼び出して ReadOnlyReactiveProperty/ReadOnlyReactivePropertySlim に変換してください。この方法は Slim がつく ReactiveProperty も対応しています。ということで、前編では ReactiveProperty というライブラリの名前にもなっている ReactiveProperty 系のクラスのよく使うであろう機能を紹介しました。
この後おそらく中編・後編の3本仕立てで残りの ReactiveProperty の機能を解説していきたいと思います。


