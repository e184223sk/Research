More than 1 year has passed since last update.2020年にもなってファイル名変更ソフトを新しく作りました。名前はFileRenamerDiffです。
この記事では、ソフトウェアの記述解説をします。ソフトウェアの内容やスクリーンショットは前回の記事を参照ください。ざっくりいうと、WPF on .NET Core by C#です。
MVVMライブラリはLivetとReactivePropertyを使用しています。
ソースコード全体はGitHubにあります。MVVMパターンですので、Model-ViewModel-Viewの3層に分割して、ViewとViewModelの間はBindingによってつながっています。メインとなるクラスだけ抜き出したクラス図は以下のようになっています。PlantUMLで書きました。各層ごとに解説します。Model層ではファイルの探索、正規表現を使ったリネーム、リネーム保存、設定ファイル読み書きといったことを行っています。指定されたパス以下のファイルパスを取得します。このとき設定によって、隠しファイルやフォルダ・（狭義の）ファイルの両方か片方だけリストにするか切り替えます。
探索されたファイルの情報をFileElementModelにまとめて、そこにリネーム後のファイル名もあとで加えます。設定はSettingAppModelにまとめてあり、このクラス全体をJSONにシリアライズして設定ファイルとして保存しています。設定には探索対象ディレクトリや複数の削除パターン・置換パターンが含まれています。リネームの実行は.NETのRegexに置換後の文字列を加えたReplaceRegexクラスで行います。複数のファイル名に対して行うのを想定しているので、RegexOptionはCompiledにしておきます。
ソフトウェアの設定では削除パターンと置換パターンで2種類がありますが、Regexを生成する際には、この削除パターンは全て|で結合した1つのRegexにし、置換後の文字列は""にしておきます。リネーム処理後に同じファイルパスが含まれていた場合、ファイルパスが重複しているとみなし、リネーム保存を禁止しています。なお、Windowsは大文字・小文字は同じとみなします。
リネーム後のファイルパスだけでなく、リネーム前のファイルパスとも重複していないかを判定しています。これは保存の順番によっては失敗する場合があるためです。
例）"A.txt", "B.txt"というファイル名が同じディレクトリにあり、"A"を"b"に、"B"を"c"に置き換えるリネームをした場合、先に"A.txt"→"b.txt"が保存されると既存の"B.txt"と重複して失敗してしまいます。リネーム保存時は深い階層のファイルから保存します。フォルダもリネームする場合、保存前のファイルが移動したことになり失敗してしまいます。
例）"/Main/Sub/"という階層のフォルダがあり、"/Main"と"/Sub"をリネームする場合、"/Main"を先にリネーム保存してしまうと、"/Main/Sub"が見つからなくなります。また、リネーム処理自体もファイルかフォルダかで処理が微妙に異なります。これは過去記事を参照ください。
C#で確実にファイル名を変更するシリアライズされるSettingAppModelクラス以外はViewModelから参照される可変プロパティはだいたいReactivePropertyにしてあります。
これにより、Modelでの変更がRxなストリームとしてViewModel・Viewに伝わります。基本的にはModelの上記機能を呼び出すためのReactiveCommandとModelの状態を反映するReactivePropertyがメインです。
ViewModelはなるべく薄く作るべきなのですが、差分表示(DiffPlex)やDataGrid用のCollectionViewなどで、ふくらんでいます。リネーム保存などの時間のかかる処理は非同期で行うべきですが、ViewにBindingされるプロパティはUIスレッド以外から変更すると例外が発生してしまいます。
こういった事情もReactivePropertyのSchedulerやRxのObserveOnUIDispatcher()を使うと解決できます。例えば、Modelでの非同期処理の結果、リネームファイル数プロパティCountReplacedが変更になり、それをViewにも表示するためViewModelで同名のプロパティを作る場合はこうします。これにより、Modelのプロパティ変更時のスレッドに関係なく、ViewModelのプロパティ変更はUIスレッドから行われます。DiffPlexというライブラリを使用して、リネーム前後のファイル名の差分情報を生成します。DiffPlexの詳しい解説は過去記事を参照ください。
WPFでGitのDiffっぽい差分表示をするDiffPlexライブラリ。～あるいは、あるジェダイの変遷ファイル名の性質上、1行全体のハイライトをしても意味がないので、ワード境界を細かく区切りました。
デフォルトの差分表示時のワード境界が全角文字などに対応していなかったので、追加しました。これにより、どこが変更されたかが分かりやすくなります。
$\style{background-color:pink;}{報告書「最終版」}$.txt 
→　$\style{background-color:LightGreen;}{報告書「最終手前版」}$.txt
👇
報告書「$\style{background-color:pink;}{最終版}$」.txt 
→ 報告書「$\style{background-color:LightGreen;}{最終手前版}$」.txtModelでのファイル情報クラスFileElementModelに対応したFileElementViewModelを作成し、上記差分情報もその中に含めています。
ただのDataGridにBindingするなら、これをObservableCollectionなどに入れればよいのですが、並び替えや行フィルタ処理に対応するためにはICollectionViewに変換する必要があります。
変換自体はCollectionViewSource.GetDefaultView()を呼ぶだけでよいですが、行フィルタを使用する場合はICollectionViewerのFilterプロパティに表示判定用コールバックを指定して、行フィルタ基準が変わるたびにRefresh()メソッドを呼ぶ必要があります。
実際のコードのうち関係する部分を抜き出すと以下のようになります。MahAppsとMaterialDesignThemesという2つのライブラリを使用して、見た目をカッチョイイ感じにします。
MahAppsはウインドウのタイトル部分とウインドウの周りにボヤッとした色をつける機能 GlowBrush を使用しています。ウインドウの周りがちょっと青いのがわかりますでしょうか。
それ以外のコントロールはMaterialDesignThemesのテーマが適用されています。今回はプリセット色は使わず、すべてカラーコードを指定したかったので、プリセットの色に上書きします。MaterialDesignThemesの詳しい内容は # 参考 を参照してください。Ligth/Darkテーマ切り替えをやってみたかったので、作ってみました。
MaterialDesignThemesのPaletteHelperを使ってデフォルトのテーマをGet、変更後にSetします。
メイン色と前景色のペアで設定します。両者はある程度の明暗差がないと見づらいです。ただし、各種色やBrushはStaticResourceで指定されているので、再起動後に反映されます。ViewModelのファイル情報クラスFileElementViewModelを含んだICollectionViewをDataGridにBindingしています。重複判定とリネーム有無の表示列のヘッダにはカウント数と行フィルタを切り替えるToggleSwitchを配置しておきます。
ディレクトリ表示列は中身をButtonにして、クリックされたらエクスプローラーで開くようにします。特定のファイルだけ手修正したい場合などに使用します。
DataGridで使用している細かい技術は以前の記事を参照ください。
DataGridやListBox内でクリックされたら自身の行を上下に移動するButton
DataGridやListBox内でクリックされたら自身の行を削除するButton
C#のColor関連の便利拡張メソッド＋α 24選（HSV色空間への変換も）
ViewModel内のDiffPlexで作成した差分情報をDataGrid内のRichTextBoxにBindingしています。独自のConverterを使用して、DiffPlexの差分情報からRichTextBoxの中身のFlowDocumentに変換しています。
差分情報内のワード境界ごとに無変更・削除(Deleted)・挿入(Inserted)・挿入前(Imaginary)・修正(Modified)のどれかに判定されます。ただし1行単位で比較していないため、挿入前・修正は実際には使われないようです。
削除の場合はピンク、挿入の場合は黄緑色を指定しています。RichTextBoxにFlowDocumentをBindingする方法は過去記事を参照ください。
WPFのRichTextBoxにBindingするLivet.Extensionsを使用しています。
ButtonのTriggerに設定することで、Viewだけでダイアログ処理を完結することができます。
ViewModelにはユーザーが指定したファイルパス等の必要な情報だけが伝わります。ResX Resource Managerを使用しました。
各言語を横に並べて入力できるので便利です。
デフォルトの言語はOSに合わせて変わります。ただし、日本語OS以外は持っていないので検証できていません。
設定メニューから変更することもできます。ただし、リソース文字列はx:Staticで取得しているので再起動後でないと反映されないです。アプリケーション情報ページではMarkdownを表示しています。
サードパーティライセンスのMarkdownファイルをリソースとして追加した上で、MarkDigライブラリで表示しています。
MarkDigの詳しい解説は以前の記事を参照ください。
C#でMarkdownを表示するライブラリMarkDigの紹介 ロギングはSerilogを使用しています。
メッセージテンプレートを使用して、以下の内容を保存しています。
現在時刻、ログレベル、スレッドID・名称、メッセージ本文、呼び出し元名前空間＋クラス名、呼び出し元メソッドシグネチャ、行番号、使用メモリ量、(あれば例外)より詳しくは過去記事を参照ください。
C#でSerilogとFody.Anotarを使って、全部盛りのログをとる
エラー時のログなどをMicrosoftStoreに送ったりも出来るらしいですが、やり方がわかっていません。パワーポイントでがんばりました。単一ファイルかつ、自己完結型で生成しました。
これにより、エンドユーザーは.NET Coreを事前にインストールする必要がありません。Microsoft Storeにアプリケーションを登録しました。
意外と簡単にできて、コストも2000円弱を初回に払うだけです。
有料アプリの場合は売上から割合で取るようです。詳しい内容は過去記事、、、ではなくてそのうち書く記事を参考にしてください（もはや登録方法を忘れつつある）。VisualStudio 2019
C# 8
.NET Core 3.1MVVMとリアクティブプログラミングを支援するライブラリ「ReactiveProperty v2.0」オーバービュー
 Livet/README.md 
方法: DataGrid コントロールでデータをグループ化、並べ替え、およびフィルター処理する - WPF | Microsoft Docs
自己完結型アプリケーションのトリミング - .NET Core | Microsoft Docs
MaterialDesignInXamlToolkit/README.mdクラス図のBindingの書き方はこれで良いか、あまり自信ありません。クラス図には書かないほうがよいのかな？でも書かないとViewとViewModelの対応関係わからんしな。
UML詳しい人いたら教えてほしいです。


