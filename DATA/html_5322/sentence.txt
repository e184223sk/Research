More than 3 years have passed since last update.ファイルやデータベース、ネットワークなどの外部リソースを使用する .NET Framework のクラスは使い終わったら Dispose() メソッドを呼び出してリソースを開放する必要があります。
Disposeを忘れるとファイルがオープンしたままになって他から利用できなくなったり、メモリリークが発生したりする危険があるため確実に Dispose() する必要があります。上記のように finally ブロックで確実に Dispose() を呼び出すこともできますが、
using ステートメント を使うともっと簡潔にスマートにコーディングできます。
（≠ 名前空間をインクルードする using ディレクティブ）using のブロック {} を抜けた際に自動で reader.Dispose() が呼ばれます。
名前も using なので try {...} finally {...} より意図が明確です。
また、万が一 Dispose() を忘れてしまったり、消してしまうこともなくなります。finally と同様に例外がスローされようが途中でリターンされようが {} を抜ける際に必ず Dispose() が呼ばれます。
（IL（.NET Framework の中間言語）を見ると try {...} finally {...} が生成されているようです。）同じ型の場合、リソースオブジェクトは１つの using で複数同時に宣言することができます。
区切りには , を使用します。
この場合、型推論 var は使用することはできません。ネストを作らず多段重ねすることができます。
一つ目の using の末尾には ; も { もついていません。以下のように、リソースオブジェクトをインスタンス化してから using ステートメントに渡すこともできますがこれは推奨されていません。
外部リソースへのアクセスがなくなっている可能性が高いですが、変数のスコープが残ってしまいます。
リソースオブジェクトの宣言は using ステートメント内で行うことが推奨されています。また、using を使用するリソースオブジェクトは IDisposable インターフェースの Dispose メソッドを実装している必要があります。
と言っても、 .NET Framework の外部リソースを扱うクラスは IDisposable が実装されているので特に気にする必要はありません。
自作する場合でも Visual Studio では リファクタリング機能 ctrl + . で一瞬でスケルトンコードが生成できるのでそれほど面倒ではないはず。ここまで読んでいただきありがとうございました。using ステートメント (C# リファレンス)
[C#]Usingを使え
C# Tips －usingを使え、使えったら使え(^^)－
C#のusingステートメントの機能


