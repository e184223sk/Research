More than 1 year has passed since last update.ChangeTracking を利用して POCO クラスに対する変更追跡を実装してみます。
ChangeTracking は Castle Dynamic Proxy を利用した AOP ライブラリで、トラッキング対象の POCO クラスを継承することによって変更追跡機能を追加します。利用した ChangeTracking のバージョンは 2.2.17 です。次のクラスを使ってトラッキングの動作を確認します。トラッキング対象インスタンスに対して AsTrackable メソッドを呼び出します。
AsTrackable メソッドの戻り値の型はトラッキング対象の型から継承されたプロキシであるため、透過的に利用することができます。変更追跡機能を利用する場合、プロキシを IChangeTrackable&lt;T&gt; インターフェースにキャストします。プロキシを生成した直後は「変更なし」を返します。プロキシ・オリジナルともにプロパティの値が変更され、変更ステータスが「変更あり」に変わります。プロキシから値を変更したときと結果は同じです。プロキシ・オリジナルともにリストから要素が削除され、変更ステータスが「変更あり」に変わります。
削除された要素の変更ステータスは「削除」に変わります。プロキシ・オリジナルともにリストから要素が削除されますが、変更ステータスは「変更なし」のままです。プロキシ・オリジナルともにリストに要素が追加され、変更ステータスが「変更あり」に変わります。
追加された要素の変更ステータスは「追加」に変わります。プロキシ・オリジナルともにリストから要素が削除されますが、変更ステータスは「変更なし」のままです。
プロキシではなく追加されたオブジェクトそのものがリストに格納されるため、IChangeTrackable&lt;SampleItem&gt; にキャストしようとすると InvalidCastException がスローされます。
リストに対する変更ステータスを取得しようとすると、TargetInvocationException がスローされます。プロキシからプロパティの値を変更し、破棄します。プロパティの値は元に戻り、変更ステータスも「変更なし」に戻ります。プロキシからリストの要素を削除し、破棄します。リストの要素数は元に戻り、変更ステータスも「変更なし」に戻ります。プロキシからリストの追加を削除し、破棄します。リストの要素数は元に戻り、変更ステータスも「変更なし」に戻ります。オリジナルに対して変更を行っとときとプロキシに対して変更を行ったときのパフォーマンスを比較します。
BenchmarkDotNet を使いました。やはりオーバーヘッドはかなり大きいですね。特にリストの要素に対するオーバーヘッドが大きいです。編集対象のインスタンスを編集画面に渡し、編集画面の中でプロキシを生成して操作するような場面では使い勝手がよいと思います。次の3つのプロパティのうち、プロキシ生成時に値が引き継がれるのは Name プロパティのみです。このサンプルの SampleChildItem.Parent プロパティの値はプロキシに差し換えられませんでした。プロパティの型が SampleItem クラス／SampleChildItem クラスとは関連性のないクラスである場合はプロキシに差し換わりました。差し換わっているかどうかがわかりにくいため、DoNoTrack 属性を付与してトラッキング対象外にしたほうがよいのではないかと感じました。トラッキングに利用する拡張メソッドの対象型は任意のクラスや IList&lt;T&gt; インターフェースなどであるため、非常の多くのクラスのインテリセンスにそれらの拡張メソッドがリストアップされます。多少煩わしく感じました。データエンティティを表すクラスには特定のインターフェースを実装させたり、基底クラスを継承させたりすることが多いと思います。それらの基底となる型を対象とした拡張メソッドを定義すれば必要最小限のクラスにのみ拡張メソッドを表示させることができると思います。
但し、ChangeTracking 名前空間を using 宣言しない分、IChangeTrackable&lt;T&gt; インターフェースなどの型に対して名前空間の修飾が必要になります。


