using UnityEngine;

[RequireComponent(typeof(MeshRenderer), typeof(MeshFilter))]
[ExecuteInEditMode]
public class CircleGauge : MonoBehaviour
{
    private const float TWO_PI = Mathf.PI * 2;

    private static readonly int[] Triangles = new int[]
    {
        4,3,5,  5,3,0,
        3,2,0,  0,2,1,
        5,0,6,  6,0,7,
        0,9,7,  7,9,8,
    };

    private static readonly int[]  TrianglesClockwise = new int[]
    {
        2,3,1,  1,3,0,
        3,4,0,  0,4,5,
        9,0,8,  8,0,7,
        0,5,7,  7,5,6,
    };

    private enum StartPosition
    {
        Right = 0,
        Top,
        Left,
        Bottom,
    }

    private Mesh _mesh = null;
    private Vector3[] _vertices = null;
    private Vector2[] _uv = null;

    [SerializeField, Range(0.0f, 1.0f)]
    private float _value = 0f;

    [SerializeField]
    private StartPosition _startPosition = StartPosition.Right;

    [SerializeField]
    private bool _clockwise = false;

    [SerializeField]
    private Texture2D _texture = null;

    [SerializeField]
    private bool _isUpdate = false;

    void Start()
    {
        CreateMesh();
    }

    void Update()
    {
        if (_isUpdate)
        {
            _value += Time.deltaTime / 5;
            if (_value &gt; 1)
            {
                _value = _value - Mathf.Floor(_value);
            }
        }

        UpdateMesh();
    }

    /// &lt;summary&gt;
    /// Mesh情報更新
    /// &lt;/summary&gt;
    private void UpdateMesh()
    {
        for (int i = 0; i &lt; _vertices.Length; i++)
        {
            if (i != 0)
            {
                var val = Mathf.Clamp(_value, 0, 0.125f * (i - 1));
                var rad = val * TWO_PI * (_clockwise ? -1 : 1) + Mathf.PI * ((int)_startPosition * 0.5f);

                // normalized rad
                rad = rad - TWO_PI * (int)(rad / TWO_PI);
                if (rad &lt; 0.0f)
                {
                    rad += TWO_PI;
                }

                // rad in top
                if (ValueInRange(rad, Mathf.PI * 0.25f, Mathf.PI * 0.75f))
                {
                    _vertices[i].y = 0.5f;
                    _vertices[i].x = _vertices[i].y / Mathf.Tan(rad);
                }
                // rad in left
                else if (ValueInRange(rad, Mathf.PI * 0.75f, Mathf.PI * 1.25f))
                {
                    _vertices[i].x = -0.5f;
                    _vertices[i].y = Mathf.Tan(rad) * _vertices[i].x;
                }
                // rad in bottom
                else if (ValueInRange(rad, Mathf.PI * 1.25f, Mathf.PI * 1.75f))
                {
                    _vertices[i].y = -0.5f;
                    _vertices[i].x = _vertices[i].y / Mathf.Tan(rad);
                }
                // rad in right
                else
                {
                    _vertices[i].x = 0.5f;
                    _vertices[i].y = Mathf.Tan(rad) * _vertices[i].x;
                }
            }

            _uv[i].x = _vertices[i].x + 0.5f;
            _uv[i].y = _vertices[i].y + 0.5f;
        }

        _mesh.vertices = _vertices;
        _mesh.uv = _uv;
        _mesh.triangles = _clockwise ? TrianglesClockwise : Triangles;
    }

    /// &lt;summary&gt;
    /// 値がmin～maxの範囲内にあるかチェック。
    /// value が min, max と同じ値の場合もtrue。
    /// &lt;/summary&gt;
    private bool ValueInRange(float value, float min, float max)
    {
        return min &lt;= value &amp;&amp; value &lt;= max;
    }

    /// &lt;summary&gt;
    /// 描画用Mesh生成
    /// &lt;/summary&gt;
    [ContextMenu("Reset Mesh")]
    private void CreateMesh()
    {
        var renderer = gameObject.GetComponent&lt;MeshRenderer&gt;();
        var meshFilter = gameObject.GetComponent&lt;MeshFilter&gt;();

        int length = 10;
        _vertices = new Vector3[length];
        _uv = new Vector2[length];

        var material = new Material(Shader.Find("Mobile/Particles/Alpha Blended"))
        {
            name = "material"
        };
        material.SetTexture("_MainTex", _texture);

        _mesh = meshFilter.sharedMesh = new Mesh();
        renderer.sharedMaterial = material;

        UpdateMesh();
    }
}

