More than 1 year has passed since last update.この記事ではC#の「ラムダ式」についてなんとなくわかったつもりになれるを目標に説明をします。
そのため多少端折ってたり、厳密じゃない説明もでてきます。ご了承ください。もし厳密な解説を知りたい方は、次の記事がオススメです。C#に限らず、プログラミングをしていると「ラムダ式」という用語を耳にすることがあります。
果たしてこの「ラムダ式」とは何をするためのもので、あるとどうして嬉しいのか、それぞれ解説していきます。「ラムダ式」という名前からしてかなりいかつい印象をうける人もいるでしょう。
ですがラムダ式自体はとても単純で、次の2つの機能を指しています。普段、ラムダ式といった場合は前者の「かんたん関数記法」のことを指しています。
そのため「式木」のことは忘れてもらって大丈夫です。諸説ありますが、由来としては「計算式を書く時に同じ式を何度も書くと大変なので、対象の関数をΛ（ラムダ）と置いて記述を省略する」というところから来ています。
数学では変数をxやyと置いて計算しますが、それの関数バージョンがΛだったということになります。つまり、「ラムダ」という記号に深い意味などはなく、単に習慣で決まっただけの名前ということです。たとえば次のような関数があったとします。これをラムダ式で書くと、このような記法となります。ラムダ式の記法は、最初は見てもよくわからないでしょう。
なぜなら、「ラムダ式は関数をサクッと手短に書くために、無駄なタイプ量を減らすために徹底的に簡略化された記法だから」です。省略している部分を省いて、もう少し丁寧に書くこともできます。こうなるとわかりやすいでしょう。元の関数Add()と比較してみましょう。という記法で構成されています。つまり=&gt;は「矢印（→）」を意味しています。元の関数記法と比べて、ラムダ式では次の点が異なります。関数名がつけられない理由としては、ラムダ式は使い捨ての関数をその場でサクっと定義するために使うものだからです。
「わざわざ名前をつけて関数定義したくない」、という怠惰なプログラマのニーズに答えた結果こうなっています。
（ちなみにこの「使い捨ての関数」、正確には「匿名関数/匿名メソッド」と呼んだりします）また型が省略できるのは「型推論」という機能がC#に備わっているためです。
つまりはコンパイラが空気を読んで型を推測してくれているからです。ちなみに、引数が空の関数をラムダ式で書く場合は次のように書きます。() =&gt;と、空の括弧を書けば引数無しという扱いになります。ラムダ式は使い捨ての関数をその場でサクっと定義するというのに向いています。「使い捨ての関数」がどのような場面で役に立つかというと、たとえば次のコードをみてください。たとえば、N秒待った後に別の関数を実行する場合は次のように書けます。WaitForAsync()メソッドを呼び出すことで、N秒後にDo()関数が実行されます。ただ、この記法には次の欠点があります。これらの問題を解決するのものが「ラムダ式」です（あとデリゲート）。ラムダ式を使うことで「関数の呼び出し時に即席で関数を作って登録する」ということができました。このように、「いちいち関数を定義するのが面倒くさい」というニーズに答えるための省略記法がラムダ式です。では、このラムダ式ですが、単体では使うことはできません。
必ずデリゲートとセットで扱う必要があります。ラムダ式とセットで扱うものがデリゲートです。
いったんラムダ式のことを忘れ、デリゲートの解説をします。デリゲートとは、「関数を代入できる変数」みたいなものです。
関数をデリゲートに登録しておいて、後からデリゲート経由でその関数を呼び出す、ということができるようになります。デリゲートを使うと、「登録する関数を自由に差し替えて、実行時に異なる関数を実行する」という処理が簡単に実装できることです。たとえば、さきほどのWaitForAsyncもデリゲート(Action型)を使っています。
Action型は「引数なし、返り値なし」の関数を登録することができるデリゲートです。このように、「関数の引数をデリゲートにする」ことで、「関数から別の関数を呼び出す」という処理を外から切り替えることができるようになります。C#の歴史上、デリゲートにはいろんな種類が存在します。ですが今日においてはジェネリック版のデリゲート(ActionとFunc)しかほぼ使いません。
そのため今回はこちらに絞って説明を行います。「引数なし、返り値なし」の関数を登録できるのがAction型のデリゲートです。「引数あり、返り値なし」の関数はAction&lt;T&gt;型のデリゲートを使います。なお、引数の数が増える場合はその分Action&lt;T&gt;のTの数が増えます。Func&lt;TResult&gt;は「引数なし、返り値あり」の関数が登録できるデリゲートです。
Func&lt;TResult&gt;と書いてあった場合、「TResult型の結果が返ってくるんだな」と理解してもらえればいいです。Func&lt;T, TResult&gt;は「引数あり、返り値あり」の関数が登録できるデリゲートです。
T型を引数にとり、TResult型を返す関数が登録できます。なお、引数の数が増える場合は手前のTの数が増えます。
たとえば、Func&lt;T1, T2, T3, TResult&gt;のように。この場合はT1型、T2型、T3型を引数にとり、TResult型を返すという意味になります。
ここで重要なのは、Funcの最後の型が返り値の型であることは固定であることです。ラムダ式を単体で使うことはなく、ラムダ式で生成した関数は必ずデリゲートに代入して使います。関数の引数として「デリゲート」を受けとれるようにおけば、ラムダ式を使って「その場で使い捨て関数を作って登録」ということができるようになります。便利なLINQですが、実はこれも引数はデリゲートになっています。
たとえば、よく使うSelect()ですが、これの引数は実はFunc&lt;T, TResult&gt;になっています。(型推論が効いて今はFunc&lt;int, float&gt;が適用されているとIDEに表示されている)別にラムダ式はLINQ専用のためのものではなく、単にLINQがデリゲートを使っているからラムダ式がうまく利用できて便利だったという話です。LINQはただのデリゲートを使っているだけなので、ラムダ式を使わずに普通の関数を登録することもできます。LINQのコードを書くたびに、ちょっとした関数を毎回定義していたのでは面倒くさすぎます。
それに処理が散らかるため可読性も悪くなってしまいます。このように、ラムダ式は「使い捨ての関数をその場で定義できる」という、とても画期的な機能ということでした。あと、たまに「ラムダ式を代入する」という表現を使う人がいるのですが、厳密には間違っています。
正確には「ラムダ式で生成された関数（匿名関数）をデリゲートに代入する」です。


