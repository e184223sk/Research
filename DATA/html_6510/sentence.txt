More than 3 years have passed since last update.　ジェネリックメソッドを作りました。対象は数値です。二つの引数を取り、それを足して返します。(実際作ったのはもちろん違う仕事をするんですが、ここでは話を簡単にするためにこういうことにしておいてください)　そりゃそうですよね。T が何かわからないんですから。文字列かもしれないしコントロールかもしれない。そんなものが足せるわけがありません。こういう時にはそう、型パラメータの制約です。　つまり、こう。　数値型はシールされたクラスなので使えないそうです。ならば、数値型の基底クラスに制約すればいいに違いありません。……int の基底クラスは System.ValueType つまり構造体の基底クラスですね。これで制約しても構造体すべてに該当します。役に立ちません。　まずジェネリック演算用のクラスを作りました。(あれ？)
　式木を組み立て、コンパイルしてメソッドにします。　このように使います。　できました。四則演算と剰余と比較ができます。でも、Add を二つ作ったとか言わないでください。初めに書いたように、本当に作りたかったのは Add じゃないんです。「dynamic でもいける」との情報をいただきました。なるほど盲点でした。これなら数値型以外でも + 演算子をオーバーロードしているクラスならすべて使えます。しかし、気になるのはパフォーマンス。そこで次のようにして計測してみました。　0 から 99 までの乱数を 100 万個作り、それぞれのメソッドで合計を出してみました。結果はこちら。　式木の方が 4 倍弱速いようです。あらかじめコンパイルする分だけ差が出たのでしょう。


