 Tinyhandというソースジェネレーターを使用したシリアライザを作りました。といっても、neueccさんとAArnottさんのMessagePack for C#を99％ベースに、ソースジェネレーター対応にして少し機能を追加しただけの代物です。本家はGitHub archi-Doc/Tinyhandにあります。MessagePack for C#からの変更点としては、といったところです。ソースジェネレーターなので、ターゲットフレームワークは .NET 5 以降です。まずはPackage Manager Consoleでインストール。サンプルコードです。protobuf-net と MessagePack for C# 相手のベンチマークです。protobuf-netはもちろん、本家よりも速いです。シリアライズ対象のお話。publicメンバーはデフォルトでシリアライズ対象で、Key または KeyAsName または IgnoreMember属性 のいずれかを指定する必要があります。protected/privateメンバーはシリアライズ対象外のため、属性を付ける必要はありません。KeyまたはKeyAsName 属性を付けると、明示的にシリアライズ対象に追加することが出来ます。readonly と getter-only property はサポートされません（シリアライズ対象外）。 技術的には可能ですが、アンセーフコードと動的コード生成が必要で、信条的にも readonly / getter-only をシリアライズする必要はなかろうと考えています。ご意見お待ちしています。Init-only property とrecord 型はサポートされます。IncludePrivateMembers を true にすると、private/protectedもまとめてシリアライズ対象にすることが出来ます。ExplicitKeyOnly を true にすると、Key 属性か KeyAsName 属性が付いたメンバーのみシリアライズ対象になります。Tinyhandは null許容参照型・非許容参照型を適切にデシリアライズします。つまり、空のデータや、バージョニングで対応するメンバーがないデータが来ても、null非許容参照型のインスタンスを自動で補完します。DefaultValueAttribute (System.ComponentModel) 属性を付加することで、デフォルト値を設定できます。クラス再構成の場合や、デシリアライズ時に該当するデータがない場合は、デフォルト値が使用されます。対象の型は、プリミティブ（bool, sbyte, byte, short, ushort, int, uint, long, ulong, float, double, decimal, string, char, enum）です。メンバーがデフォルト値の場合、シリアライズをスキップすることが可能です。クラス宣言の際に、[TinyhandObject(SkipSerializingDefaultValue = true)] と指定してください。デシリアライズ時にメンバーを再構築（自動でインスタンス補完）します。基本はOnですが、メンバーに [Reconstruct(false)] や [Reconstruct(true)] 属性を追加することで、挙動を変更できます。メンバー再構築の挙動をまとめて変更したい場合は、TinyhandObject の ReconstructMember を変更してください（[TinyhandObject(ReconstructMember = false)]）。デシリアライズ時に、新しいインスタンスを作成せずに、既存のインスタンスを使い回すことが出来ます。ただし、TinyhandObject 属性を持つクラスに限ります（プリミティブ型や配列型に適用すると、取り扱いが訳分からなくなるため）。メンバーに [Reuse(true)] や [Reuse(false)] 属性を追加することで、それぞれの挙動を変えることが出来ます。同じくReuseの挙動をまとめて変更したい場合は、TinyhandObject の ReuseMember を変更してください（[TinyhandObject(ReuseMember = false)]）。インターフェースや抽象クラスから派生したクラスを、インターフェースや抽象クラス経由でシリアライズ・デシリアライズします。MessagePack for C# や Tinyhandでは Union と呼んでいます。使い方は、まずインターフェース・抽象クラスを定義します。次に、TinyhandUnion 属性をそれぞれの派生クラス分だけ追加します。属性は、[TinyhandUnion(0, typeof(DerivedClassA))] という感じで、識別子（int）と派生クラスの型を指定します。バイナリではなく、テキスト形式でシリアライズすることも可能です。結果はこちら。JSONに似たノリです。もちろんテキストからデシリアライズも可能です。UTF-8版はこちら。結構頑張ったんですが、ObjectをBinaryにしてから（通常はここまで）、Binaryを解釈してTextに変換する、という余計な処理が多いので、遅いです。だいたい5-8倍。全然使えないほどではないですが、基本はバイナリを勧めます。バージョニング耐性は結構考慮しています。つまり、メンバー（Key）を追加しても削除しても、可能な限りシリアライズ/デシリアライズするような設計です。メンバーが追加されて、デシリアライズ時にデータがない場合は、初期値・デフォルト値が使用されます。逆にメンバーが削除されて、デシリアライズ時に余分なデータがある場合は、余分なデータは無視されます。例外は発生しません。シリアライズの前と、デシリアライズの後に処理を挟みたい場合は、 ITinyhandSerializationCallback interface を追加してください。シリアライズ直前に OnBeforeSerialize、デシリアライズ直後に OnAfterDeserialize が呼ばれます。サポートしている型の一覧：Primitives (int, string, etc...), Enums, Nullable&lt;&gt;, Lazy&lt;&gt;TimeSpan,  DateTime, DateTimeOffsetGuid, Uri, Version, StringBuilderBigInteger, ComplexArray[], Array[,], Array[,,], Array[,,,], ArraySegment&lt;&gt;, BitArrayKeyValuePair&lt;,&gt;, Tuple&lt;,...&gt;, ValueTuple&lt;,...&gt;ArrayList, HashtableList&lt;&gt;, LinkedList&lt;&gt;, Queue&lt;&gt;, Stack&lt;&gt;, HashSet&lt;&gt;, ReadOnlyCollection&lt;&gt;, SortedList&lt;,&gt;IList&lt;&gt;, ICollection&lt;&gt;, IEnumerable&lt;&gt;, IReadOnlyCollection&lt;&gt;, IReadOnlyList&lt;&gt;Dictionary&lt;,&gt;, IDictionary&lt;,&gt;, SortedDictionary&lt;,&gt;, ILookup&lt;,&gt;, IGrouping&lt;,&gt;, ReadOnlyDictionary&lt;,&gt;, IReadOnlyDictionary&lt;,&gt;ObservableCollection&lt;&gt;, ReadOnlyObservableCollection&lt;&gt;ISet&lt;&gt;,ConcurrentBag&lt;&gt;, ConcurrentQueue&lt;&gt;, ConcurrentStack&lt;&gt;, ConcurrentDictionary&lt;,&gt;Immutable collections (ImmutableList&lt;&gt;, etc)Custom implementations of ICollection&lt;&gt; or IDictionary&lt;,&gt; with a parameterless constructorCustom implementations of IList or IDictionary with a parameterless constructorLZ4による圧縮も可能です（MessagePack for C#丸パクリだから・・・）


