More than 1 year has passed since last update.C# 7からローカル関数が使えるようになりました。ローカル関数の使いどころの一つは、LINQライクなコレクションメソッドを書く時です。遅延実行のLINQライクメソッドを実装する際、適切に引数のnullチェック・nullだった場合の例外スローをする必要があります。それを実現するために、ローカル関数が登場するまでは、「nullチェック」と「メインの処理」を別のメソッドに分ける必要がありました。（詳しくは、「【ちゃんと投げよう】あなたの作ったオレオレLINQメソッドは間違ってるかもしれない！【ArgumentNullException】」を参照してください。）しかし、ローカル関数の登場で「メインの処理」をローカル関数として定義することで、単一のメソッドで遅延実行のLINQライクメソッドを実装することができるようになりました。そんな便利なローカル関数ですが、C# 8からもっと便利になります。が導入されるからです。特に、LINQライクなコレクションメソッドを書くとき、これがとても嬉しいです。次に示すLINQライクメソッド、Scanのコードを使ってその理由を説明します。まずは、「静的ローカル関数」のメリットを紹介します。先ほどのScanのコードにおいて、ローカル関数Implは外部の変数であるsourceとaccumulatorをキャプチャしています。できれば、キャプチャは避けたいです。そこでC# 8から導入された「静的ローカル関数」を使ってみます。設定をC# 8にしてローカル関数Implにstaticをつけてみましょう。Implは静的ローカル関数なのに、外部変数である、sourceとaccumulatorをキャプチャしているのでコンパイルエラーとなります。これを解決するために、変数をキャプチャしないように、引数としてsourceとaccumulatorを渡すようにコードを変更します。このように静的ローカル関数にすることで、外部変数のキャプチャに気づくことができます。うっかり外部変数をキャプチャすることを防ぐことができます。次に「変数シャドーイング」のメリットを紹介します。C# 8の話をする前に、C# 7で起きていたことを整理しましょう。最初に見せたコードでは、「外部変数のキャプチャが起きている」という説明をしました。「C# 7では静的ローカル関数は使えないけれど、C# 7でも引数として変数を渡せばよいのではないか？」と思った方もいるのではないでしょうか？できなくはないのですが、ちょっと面倒です。次のコードはコンパイルエラーになります。C#7では、ローカル関数内で、外側にすでに存在している変数や引数と同じ名前をつけることはできません。そのため、次のように引数名を変える必要があります。これはちょっと面倒ですさて、C# 8で導入される「変数シャドーイング」の話をしましょう。C# 8では、「変数のシャドーイング」が認められ、ローカル関数内で外側にすでに存在している変数や引数と同じ名前で、新たに変数・引数を定義できるようになりました。これにより、C# 7ではコンパイルエラーになる次のコードが、C# 8ではコンパイルが通るようになりました。このようにC# 8では、が導入され、LINQライクなコレクションメソッドを書く時に、さらにローカル関数が便利になりました。C# 8では、次のようなコードをかくことができます。について、さらに詳しい日本語情報は@ufcppさんの「ローカル関数と匿名関数」を参照してください。


