More than 3 years have passed since last update.C#をコンパイルすると中間言語（IL）というものに変換される。
コンパイルでどのような最適化がされるのか知りたいようなときにILを確認できると便利な気がしたので、その方法を調べた。
環境はmac。で必要なものは揃うはず。
この記事で試したmonoのバージョンは4.8.0。適当にC#のコードを書く。コンパイルする。これにより、Program.exeが作られる。
Program.exeの中身はオブジェクトコードと呼ばれ、バイナリなので、人が読める形のILにデコンパイルしたい。
これにはmonodisを使う。手元の環境では、以下のようなILが出力された。なんとなく、"hello"という文字列をロードして、System.Console::WriteLineという関数を呼んでいるというようなことが分かる。https://codezine.jp/article/detail/2624
が参考になった。
どんな命令があるかの一覧はどこを見ればいいか分からなかったが、
https://msdn.microsoft.com/ja-jp/library/system.reflection.emit.opcodes(v=vs.110).aspx
は参考になりそう。逆に、ILからオブジェクトコードに変換したい場合は、ilasmを使う。実は、helloを出力するILとしては、以下のようなもので十分そう（クラスすらなくても大丈夫らしい）。@neueccさんの記事で
http://engineering.grani.jp/entry/2017/02/20/175816
というのがあって、これが実際に手元のmonoでどうなるかを調べた。これのILを出力すると、以下のようになった。brfalseというのが独特という感じがするが、確かにifの羅列というようなコードになっている。
もう一つcaseを追加してみた。これは、以下のようになった。swtichという命令が使われていて、確かに効率的っぽい感じになっている。
他にも、試しに文字列のswitchのILを見てみたら、内部的にDictionaryが作られるようなコードになった。
これは、@neueccさんの記事とは違う結果であったが、文字列の比較を愚直に直列でやってなさそうということで一安心した。forの中で変数宣言すると、ループする度にオーバーヘッドが発生するから良くないとかいう都市伝説があったりするが、実際にILはどうなるかを調べた。
つまり、ではxの宣言にコストがあるので、と書こうという話である。それぞれ、ILに変換してみると、となった。
これを見ると、前者ではILのローカル変数V_0がC#の変数i、V_1がxに対応しているのに対して、後者ではその対応が逆になっている。
しかしそれ以外は全く同じILが生成されているため、実行速度に違いは生じないと考えられる。
この事から、xのスコープが小さくなり保守性が高まる前者の書き方を採用すればいいという事が分かる。
この都市伝説は何だったのか…。monoでC#のILを確認する方法をまとめた。
少しC#の事を知ることができた気がする。


