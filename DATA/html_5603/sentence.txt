More than 3 years have passed since last update.
C#スクリプトをアプリケーションに組み込むだけでなく、
上の画像のようにインテリセンスやハイライトが効くエディタを組み込んでみます。C#/VBのコーディングのサポート（インテリセンス、参照の検索等）や、コードを解析してコンパイルを行うAPIの総称です。Visual Studioの内部でも使用されており、さらにオープンソースで公開もされています。
ただ、Scripting APIの仕様がバージョンアップで変わっているため、数年前の記事で紹介されている方法では動かないことがありました。
今回この記事を書こうと思った理由の１つです。内部でRoslynを使用しているコードエディタです。単体のアプリとして公開されている他、WPFに組み込めるようにNugGetでも公開されています。しかし、これに関する日本語の記事が全く見当たらない上、サンプルが少し複雑で1行ごとにコンパイルしていくような汎用性がない？ものでした。本記事では最低限のサンプルも紹介しようと思います。C#をスクリプトのように実行できるようにした代物です。2015年末に発表されていますがあまり盛り上がってない気がします。試すだけなら、Visual Studioの上部メニューの表示→その他のウィンドウ→C# インタラクティブを選択することでインタラクティブなC#を使用できます。RoslynPadのコントロールはWPF仕様なので基本的にWPFのアプリにしか組み込むことはできません。
しかし、WinFormsにはWPFコントロールを組み込めるElementHostなるものが存在します。
コントロールのみであれば表示することができましたが、インテリセンスの機能を初期化する際にエラーが出でしまいました。同じパッケージを入れているはずなのにと不思議に思いつつ、検索しても情報はなく、
該当箇所のソース(Roslyn内部)を見て、呼び出しを遡ってみましたが手がかりは得られませんでした。
箇所がそもそもinternalクラスでRoslynPadが直接呼び出しているようなものではなかったのも一因です。正直、高校生の自分にはこれが限界です。
既存のWinFormsアプリに組み込むなら、別の実行ファイルにして連携するしか方法はないのかもしれません。
最も、新規で作るならそんなゴリ押ししないでWPFで作れという話ですが（^^;
（何か情報があれば教えてもらえるとうれしいです）前置きが長くなりましたが、初めは単純にTextBoxにC#スクリプトを書き、それを実行できるアプリを作ってみます。
「CSharp Scripting」で検索すると出てきます。
これ一つをインストールするだけで依存している大量のライブラリがインストールされます^^;
また、バージョンによって扱い方が異なるので注意してください。
（執筆時のバージョンは2.6.1）FormsでもWPFでもいいのでテキストボックスとボタンを用意し、ボタンのクリックイベントに以下を貼り付けます最低限これだけあれば動きます。テキストボックスにと入れてボタンを押してみましょう。

...でました、がかなり地味ですね。使いそうなものは予めusingしておくことができます。
先程のコードを以下のように修正してください。スクリプトを作成する時に実行時のオプションを指定できる、ScriptOptionsを一緒に渡すことができます。
ScriptOptions.Defaultでデフォルトを取得し、WithImportsでusingしておくものを指定できます。ここで落とし穴があります。
メッセージボックスはSystem.Windows.Formsにありますが、以下のようにしてもエラーが出ます。
（WPFではSystem.Windows.MessageBoxに読み替えてください）外部ライブラリを使用するとき、プロジェクトにdllの参照を追加すると言った場面があると思います。
普段意識しませんが、WinFormsプロジェクトを作成する際にもVSがSystem.Windows.Forms.dllを自動的に参照に追加しています。スクリプト環境で自動的に参照してくれるのはSystemのみなので、それ以外を使用するには参照に追加する必要があります。
そのためにはScriptOptionsを以下のようにします。WithReferencesにdllファイルなどのアセンブリを指定することで参照に追加できます。System.Windows.Forms.dllアセンブリを取得するにはいくつか方法があると思いますが、
dllのパスや完全名を調べるのは面倒なので以下のようにします。GetAssemblyは指定したクラスが属しているアセンブリを取得するメソッドです。
なので最後はMessageBoxでもFormでもなんでも良いです。
（もっと気持ちのよい書き方があれば教えてください）これでようやくメッセージボックスが出せました。

ちなみにScriptOptionsを何も指定しない場合でも以下のようにすることでメッセージボックスは出せます。#rが参照を動的に追加するC#スクリプト独自の方法のようです。この記事を読んでいる方の大半は、スクリプトエディタをを作るというより
アプリをスクリプト側から操作できるよう拡張したいと思っていると思います。
では実際にやってみましょう。
具体的にはでスクリプト側で使用したいオブジェクトをglobalsに指定します。
そうすることでそのオブジェクトをグローバルな要素としてアクセスできます。
また、globalsに渡すオブジェクトはpublicである必要があります。
初めに、実行ファイルのパスを返すだけの簡単なクラスを作ります。スクリプト実行部分を以下のように変更します。・CSharpScript.Createの引数３にtypeof(MyClass)が追加されています。
globalsに渡すオブジェクトのTypeを渡します。この状態でscript側でとして実行すると、実行ファイルのパスが表示されると思います。上のサンプルではスクリプトで操作した気になれない人は
globalsに自分自身（Form1)を渡してみてください。
そしてなど普通にFormのプロパティを操作する感覚でスクリプトを書いて実行してみてください。
なにが起こるか、想像はつくと思います。スクリプト内で使用するクラスや構造体を予め定義しておけます。
方法は大きく分けて２つあります。入れ子にしたものはスクリプト内で使用できます。別プロジェクトを作成し、dllをビルドし、参照に追加します。もしくは使いたいクラスがアプリ内にある場合、
アプリ自身を参照に追加することでも同じことが実現できますが、
アプリ内にある全てのpublicなクラスがスクリプト側で操作できてしまう危険があります。
例えばオプションに次のように指定します。WithImportsの最後に自身の名前空間を、で自身を参照に追加しています。
この状態で次のスクリプトを実行すると...今表示されているFormを複製できてしまいます。入れ子の方法が確実のように思いますが、
私はアセンブリを分離した上で後者をおすすめします。なぜならRoslynPadの実装時に自作のクラスを予測に表示する際、
自作のクラスが含まれるアセンブリを必ず参照しなければいけないからです。アプリにglobalsに渡すクラスが含まれていると、globalsのメソッドやメンバを予測に表示するために
アプリのアセンブリを参照することになり、結果的に後者の危険な方法と変わりなくなってしまいます。とは言ったものの、コードをシンプルにするために
本記事では分離しません。ご了承ください。最もRoslynPadを使わないのであれば、入れ子が一番ラクで安全です。WinFormsのテキストボックスも予約語に色付けをしていけば多少使えるかもしれませんが、
インテリセンスの存在は大きいです。
というわけでここからはWPFのみになりますが実装していきます。
WPFのプロジェクトを作成してください。
「RoslynPad」で検索するといくつか出てきますが、この中で必要なのは画像中の真ん中３つです。
依存関係的に真ん中をインストールすると必要なものはすべてインストールされます。
先程のCSharpScriptもインストールされます。
ボタンとRoslynCodeEditorを適当に配置してください。
xamlの頭に以下を追記する必要があります。xmlns:editor="clr-namespace:RoslynPad.Editor;assembly=RoslynPad.Editor.Windows"公式のサンプルを削りに削った結果こうなりました^^;
これで一応動きます。RoslynHostというインテリセンスなどの機能を提供するオブジェクトを初期化します。
（冒頭のWinFormsエラーはここで出ました）
additionalAssembliesに既に指定がありますが、これは必須のようです。エディタコントロールを初期化します。※RoslynCodeEditorのLoadedイベントに登録しておいてください。普通にエディタに入力されたテキストからスクリプトを作成、実行しています。
注目してほしいのがScriptOptionsにRoslynHostのDefaultReferencesとDefaultImports
が指定されていることです。これが次のキーになります。実行するとちゃんとエディタとして機能すると思います。
しかし、ここであることに気づきます。

これを見て何か気づきませんか...？そうです。
using Systemをしていないのにも関わらずConsoleが使用できています。
実行もできます。これは一体どういうことなのでしょうか？先程のScriptOptionsに次のように指定しました初めにusing担当のDefaultImportsの中身を見てみましょう。これらが初めから追加されていることがわかります。
便利！DefaultReferencesの中身は上記の他にエディタに必要な大量のdllが指定されていました。
多すぎるので割愛します。これには一手間必要です。まず、先程のMyClassを追加しておいてください。
そして、今まで使用してきたRoslynHostクラスに手を加えます。まずはRoslynHostを継承したCustomRoslynHostを作成します。
そして次のようにします。ここはどんな処理をしているか理解する必要はありません。
重要なのは下から９行目にあるという部分です。
ここにglobalsに渡したクラスのTypeを渡します。
これでglobalsにMyClassを指定したとRoslynPadに明示できます。ただこれだけでは、予測に表示されません。
クラスを含むアセンブリを参照に追加する必要があります。
次に説明します。RoslynHostの初期化部分を以下のように書き換えるだけです。referencesに表示したいクラスを指定します。
正確にはこれだけでMyClassを含むアセンブリが自動的に参照に追加されます。
そのアセンブリに別のpublicなクラスが含まれていた場合、そのクラスも自動的に使用できるようになります。また、今までScriptOptionsに参照の追加＆usingのオプションを指定していましたが
自動的にRoslynHostのDefaultReferencesとDefaultImportsに追加されます。
よってScriptOptionsに改めて指定する必要はありません。これで実行してみると、見事に表示されていることがわかります。
最終的なMainWindow.xaml.csは以下になります。注意すべき点としてCustomRoslynHostでMyClassを指定しておきながら、
gloablsに何も渡さなかった場合、予測に表示はされるのに実行時にエラーが出るという状態になってしまいます。RoslynPadの存在を知ることができたのは幸運でした。
が、RoslynPadの日本語の情報がなかったためかなり苦戦しました。
しかし、これで自分のアプリにどんどん利便性の高いスクリプティング機能を実装できそうです。この記事は英語記事や、サンプルを自分なりに解釈して書いていることが多いので
間違っている内容が含まれている可能性があります。
その場合はどんどん報告していただけると助かります。
では、最後まで読んでいただきありがとうございました。


