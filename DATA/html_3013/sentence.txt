More than 1 year has passed since last update.このテーマに関しては初投稿です。
８月２日はマケドニアの革命記念日です。この記事はUnityゆるふわサマーアドベントカレンダー 2019 #ゆるふわアドカレの2日目の記事です。
前日は@nkjzmさんのUnityのTimelineでオーディオの再生終了をループで待つでした。
翌日はぐるたかさんの【Unity】TextMeshProを導入してみる【エラー対応・ 日本語フォント作成あり】です。以下この文章は基本的にC#8に基づいている。
しかし、APIはNet Standard 2.0レベルであるためUnityでもどこでも問題なく使えるだろう。Jb Evainが主にメンテナンスを行っているILバイナリを編纂する為のライブラリである。基本的にECMA標準に従って構成されているDLLバイナリを読み込んでそこに含まれる全情報（型やフィールド、属性など）を供覧し、編集した後有効なDLLとして出力することができる。
UnityにおいてはBurst Compilerが内部的にMono.Cecilを利用している。そのため、実に珍しいことにupmでinstall可能な非Unity由来のパッケージとなっている。静的事前コード生成における競争相手はRoslynである。
また、動的コード生成も考慮せねばなるまい。その場合dynamic型、DynamicMethod, AssemblyBuilderが競合技術となるであろう。
Fodyは扱うのが面倒なMono.Cecilのラッパーである。
Mono.CecilはAPIがECMA標準にべったりでかなり低レイヤーであり、Fodyはそれを適切に隠蔽することでプログラマにかかる負担を低減する役目を果たしている。以上の対抗馬とMono.Cecilを比較し、いかなる場合に使うべきかを判断するべきである。元となるソースコード（からコンパイラの出力したDLL）を解析し、それに対応した適切な何かを生成する。これがコード生成の本懐である。
コード生成が必要とされる主な場面はやはりシリアライズであろう。シリアライズしたい型に対して高度に最適化されたシリアライザを生成することは必須である。
動的コード生成が許されているならばDynamicMethodやAssemblyBuilderを用いた方が実行時にしか知りえない情報を用いて極めてアグレッシブな最適化を行えるだろう。だが、動的コード生成が禁止された環境ならば事前コード生成であるMono.Cecilにも必要性が生じる。この場合は、基本的にRoslynの方が柔軟である。Roslynによるコード生成の最終成果物がC#ファイルであるのに対して、Mono.CecilのそれはDLLファイルである。
デバッガビリティは明らかにC#ファイルを扱うRoslynが優れている。ステップ実行やブレークポイントの挿入などはC#ファイルを相手にせねば到底なしえないからである。
この利点だけでMono.Cecilを使わない十分な理由となるだろう。では、Mono.Cecilの優越性とはなんであろうか？
それはILを扱うという点にある。
ILにはC#の許可されていない表現を扱える力がある。ILの持つ力の一部はSystem.Runtime.CompilerServices.Unsafeクラスに現れているが、それ以外にも様々なC#では不可能な表現がILでは合法的に存在するのだ。
Mono.Cecilをわざわざ扱うならばそれはIL暗黒魔術を必要としていると言えるだろう。Mono.Cecilは例外的にUPMでインストール可能である。Packages/manifest.jsonを開き、以下の１行をdependencies内に追記する。
Package Managerから追加することが可能であればそれでもよい。
Package Managerを見ると上のような表記になっていることだろう。そして、次に適当なAssembly Definition Fileに参照を追加する。

しかし、通常はMono.Cecilの参照を追加することは出来ない。
InspectorのGeneral/Override Referencesにチェックを入れるのである。

Assembly Referencesという項目が新たに生じるだろう。
とりあえず4つのDLLを参照しておけばおそらく間違いはない。
以上の工程を経てMono.CecilをUPM経由で利用できるようになった。最初の一歩として適切なものはやはりHello, worldであろう。
今回は一からアセンブリを作成し、そこにProgramクラスを定義し、簡単なコンストラクタとMainメソッドを定義している。
Mainメソッド内ではnetstandardDLLからSystem.Console.WriteLineメソッドを呼び出している。モジュールとはアセンブリであり、DLL/EXEファイルと理解すればおおよそ間違いは少ない。
補足ソースコードはコンパイルされるとDLLまたはEXEファイルとなる。
DLLあるいはEXEファイルはアセンブリを１つ含む。
アセンブリは基本的に１つのモジュールを含む。
複数のモジュールを持つことも理論的には可能であるが、MSBuildのサポートが薄いなどの理由で基本的にアセンブリ(DLLファイル)とモジュールは1対1関係にあると見なしてよい。通常Mono.Cecilを利用する場合複数（最低でも2つ）のアセンブリを利用することになるだろう。
本当に基本的な型はModuleDefinition.Typesインスタンスプロパティ（TypeSystem型）のプロパティとして入手できるが、DateTimeやDecimalなどその他の基本的な型を扱えないからである。
本例ではSystem.Consoleを使用するためにnetstandardアセンブリを読み込むことにした。既にあるアセンブリを読み込む場合はAssemblyDefinition AssemblyDefinition.ReadAssembly(string fileName)を使うことを奨励する。
他のオーバーロードにはStreamを読み込むものも存在するが、ファイルパス指定はかなり手軽である。（なお、読み込むファイルの拡張子は何でも良い。ファイルパス指定は内部でFileStreamを生成して読み込んでいるからである。）個人的な感想であるが、完全に一からアセンブリを構築するのは勉強目的以外ではオススメしない。ILSpyなどで覗いてみるとわかるが。コンパイラ製DLLには様々な情報が埋め込まれており、それを手作業でプログラミングして埋め込むのは苦行であろう。余談Mono.Cecilについて本記事以外を読むと例えば次のような記述を見掛けるかもしれない。
MethodReference reference = mainModuleDefinition.ImportReference(typeof(Console).GetMethod("WriteLine", new[] { typeof(string) }));
C#標準のリフレクションを使用してType型オブジェクトやMethodBase型オブジェクトを得、それを作業対象モジュールにImportReferenceすることで適切なMethodReferenceを得られる。
基本的にはこれでも何も問題はない。しかし、この方法で得られたMethodReferenceはそのプログラムの実行環境のものとなる。
つまり、netstandardではなくmscorlibやnetcoreappなどになるということである。netstandardを対象ランタイムとしてビルドされたライブラリを編集する場合にはリフレクションを利用してTypeInfoやMethodInfoを得てはならないのである。モジュールに対して新規に型を定義して追加することは簡単である。
TypeDefinition型のコンストラクタで新たにインスタンスを作成し、それをモジュールのTypesプロパティ(Mono.Collections.Generic.Collection)にAddすることで実現できる。
一応コンストラクタの動きを追いかけてみる。名前空間、型名、型の属性情報、基底型を設定している。さて、コンストラクタでTypeDefinitionを作成した後はその型にエントリポイントとなるメソッドとコンストラクタを定義した。
メソッドの定義はDefineMainとDefineConstructorと２メソッドに分割し、必要な要素を新たに加えた。具体的手順の解説については後述する。エントリポイントの設定方法はモジュールのEntryPointプロパティにMethodDefinitionを代入することである。
そして型にメソッドを追加する場合はTypeDefinition型のMethodsプロパティにMethodDefinitionをAddすることで実現可能である。MethodDefinitonコンストラクタのシグネチャはMethodDefinition(string name, MethodAttributes attributes, TypeReference returnType)である。
MethodAttributesの詳細設定についてはILSpyなどで答えを見て書くのが最も正確である。さて、本例においてはpublicでstaticで戻り値がvoidなMainメソッドを新規作成し、そのパラメータとしてstringの配列で名前がargsなものを追加した。
メソッド内の具体的処理内容についてはMethodBody型のBodyプロパティからGetILProcessor()を呼び、ILProcessorインスタンスを操作することで記述するのである。ILProcessorに対してはIL命令を表すInstruction型のインスタンスをAppendする。
Instruction型のインスタンスを作成するのはInstruction.Create静的メソッドまたはILProcessor.Createメソッド（実体は単なるInstruction.Createのラッパー）のどちらかが適切と思われる。
なお、Instruction.CreateはInstructionのコンストラクタのラッパーである。元となるコンストラクタのシグネチャはInstuction(OpCode code, object value)であり、使いにくいのでやはりCreate静的メソッドを使う方が賢明だろうか。各OpCodeの働きについてはECMAの仕様書や英語版Wikipediaの記事を参照してほしい。OpCodes.Callの引数にはMethodReferenceが必須である。故に上記のようにsystemModuleDefinitionからSystem.Console型を検索し、そこに含まれるメソッドからstring1つを引数に取るWriteLineメソッドのMethodReferenceを得、作業対象のモジュールであるmainModuleDefinitionにImportReferenceしたのである。
ImportReferenceの戻り値であるTypeReferenceをOpCodes.Callの引数として与えることでSystem.Console.WriteLine(string)の呼び出しを行うのだ。ILProcessorは.NETのILGenerator並に扱い辛いAPIである。Sigilのような便利なラッパーは私が調べた範囲では見当たらないので自作する他ない。
一応Mono.Cecil.RocksはUtility的クラスをまとめたアセンブリである。しかし、ILProcessor周りのUtilityとしては使いものにならないので無いと言ってもそこまで間違いはないだろう。この手の拡張メソッドは実際に使う範囲に対して少しずつ秘伝のタレのように成熟させながら作るようにしている。プロジェクト固有性がかなり高い上に網羅するには膨大すぎるからである。
本例では次のようなHelperクラスとなった。LdArgに関して補足をしよう。出力されるDLLのサイズを小さくすることでメモリに優しく最適化することができる。
そのためにILにはいくつか特別な命令が用意されている。第0引数から第3引数までは1byteでスタックにプッシュできるLdarg_0~3や、第4から第255引数までを2byteでプッシュできるLdarg_Sなどである。
こういう特別な短縮形ではないLdargは命令自体が2byte、命令の引数も2byteで合計4byteの長さとなる。（余談だが、このことから.NET CLRにおける引数の上限は第65535引数であるとわかる。）
統一的に扱うためにこうしてLdArgという拡張メソッドを定義したのである。また、ここで補足しておくべきことに、Mono.CecilのOpCodes.Ldarg〇〇はParameterDefinitionを引数に取る。元々のILの仕様ではbyteだったりushortだったりするが、引数の番地を表す数値型を受け取る。何故参照型にわざわざするのだろうか？初心者が犯しがちなミスについても補うならば、ParameterDefinitionやInstructionの使い回しは厳に慎むべきである。
特にInstructionはLd〇〇やSt〇〇など何度も何度も全く同じ内容をインスタンス化する故に無駄に見えるアロケーションが発生するだろう。
だが、使い回しをしてしまうと、後にif文などで制御構造で命令間を飛び回る時にエラーを吐いてしまう。
Mono.Cecilは事前生成であるのだから諦めて全く同じ内容のインスタンスを沢山生成しよう。この拡張メソッドを用いて書き直すとDefineMainは次のようになる。ModuleDefinitionのインスタンスメソッドWriteに出力先のファイルパスまたはStreamを与えることで書き出しを行える。だが、おそらくMono.Cecilについて他の記事を読まれた方はこの部分に引っかかりを覚えるだろう。
AssemblyDefinitionのWriteではないからである。
内部を覗いてみよう。ご覧の通り、内部的にMainModuleのWriteを呼び出している。
故に本例ではAssemblyDefinitionを保持するのも手間なのでModuleDefinitionのみを相手にしている。以上を以て最初のサンプルであるHello, worldの解説とする。このサンプルは4つのプロジェクトと2つのソリューションで構成されている。
[SerializeBase.Serialize]を付与された任意の型について、そのpublicフィールド全てをJSONを表すbyte列にシリアライズするシリアライザを生成するものである。
デシリアライザについては今回は無視している。基本的な実装方針については@neuecc先生のILをいじりつつの動的生成に関する記事を読むのが良い。このサンプルはソースコードを元にしてJSONシリアライザを生成している。
型TのシリアライザはTSerializerという名前で生成され、ISerializer&lt;T&gt;を実装する。T型を受け取り、それをbyte列に書き込むだけの単純なinterfaceである。
約束事としてbyte列のcapacityが足りない場合はバッファオーバーランを発生させずに負の数を戻り値とし、書き込み成功時は書き込んだbyte数を戻り値とする。私の想定する用途ではシリアライザはシリアライザリゾルバに登録される。
Register&lt;T&gt;で登録し、Get&lt;T&gt;で取得する。今回シリアライザを生成する型の名前はClass1。
シリアライザの名前はClass1Serializerである。 本来ならばClass1のネスト型としてSerializerとしたかったのだが、生成後のDLLを使用するとコンパイル時に筆者としてもよくわからないエラーが生じるので諦めた。InitializeModulesでモジュールを適切に読みこみ、CreateSerializersでシリアライザを生成してMainモジュールに追加し、ModuleDefinition.WriteでDLLとして出力している。
InitializeModulesの中身についてはソースコード全文を参照してほしい。第2章の内容とほぼ変わらない。Mainモジュールの全型を走査し、SerializeBase.SerializeAttribute型の属性を付与されたpublicフィールドを持つ型に対してCreateSerializerを呼び、シリアライザを生成している。
また、最初の段落はループの共通変数をループ外に出している。CreateSerializerではシリアライザ型を生成する。上記３つをそれぞれ定義・実装している。コンストラクタは.ctorという名前である必要がある。そして特別な名前であることを示すためにMethodAttributes.RTSpecialName | MethodAttributes.SpecialNameをMethodAttributesに含ませる必要がある。
コンストラクタでは必ず基底クラスのコンストラクタを呼び出さなくてはならない。new object()あるいはbase()を意味する。そして次の段落で第0引数(this)のresolverフィールドに第1引数resolverを代入する。ある型にインターフェースを新たに実装させるのは２つの工程からなる。interfaceのメソッドを実装する時は必ずMethodAttributes.NewSlot | MethodAttributes.VirtualをMethodsAttributesに加えるべきである。
MethodAttributes.Virtualはそのメソッドをvtableに加える（ポリモーフィズム）のに必須である。
MethodAttributes.NewSlotはC#コンパイラが混乱しないためのものである。シリアライズするフィールドの個数に応じてメソッドの中身を変更する。
0個ならば出力JSONが"{}"になるだけの単純な中身に、1個なら"{Hoge:0}"のようなそれに、2個ならば"{Hoge:0,Fuga:1}"のように場合分けが行われる。出力ILをC#にするとおおよそ次の通りである。ここで気を付けるべき陥穽としては、OpCodes.Ldc_I4_SとOpCodes.Ldc_I8の第2引数の型である。
それぞれ対応したsbyteとlongの値を第2引数にしないと例外を投げてしまうのだ。
筆者はbyteやint型の値を第2引数にしたりしたのでエラーになって結構な時間を無駄に費やした。フィールド1つのみをシリアライズするものである。
出力ILをC#コードで表すと以下のようになる。ローカル変数が6つあるように見えるだろう。しかし、実際の所は2つのみである。各ローカル変数はlong num;とbyte* ptr;を意味している。
byte* intPtr0~4はOpcodes.DupをC#として解釈するために生じた見掛け上のローカル変数である。long initialNeedLength = utf8.GetByteCount(fieldArray[0].Name) + 4L;　はフィールドの名前のバイト長さ+1byte(シリアライズしたら最低限1byte消費するため)+3byte("{:}")という意味である。firstFailInstructionsは第3引数capacityがinitialLength未満で書き込みできない時に飛ぶ先である。
secondFailInstructionsはフィールドのシリアライズに失敗した時に飛ぶ先である。LoadConstantInt64は俗に言うユーティリティ関数である。Int64型の定数をスタック上に最適な命令で置くことができる。
最適な命令が複数個の場合もあるので戻り値はInstruction[]としている。第2引数byte* destinationを読み込んで1文字目である"{"を書き込み、そしてフィールド名とフィールドのシリアライズ結果を書き込んでいる。WriteCharはASCII文字を対象のアドレスに書き込んでポインタを1つ進めるという働きを持っている。Encoding.GetBytesでフィールド名をbyte配列に変換し、WriteNameで書き込み、そしてセパレーターである":"を1字書き込む。第3引数capacityから書き込んだbyte数分減算をし、再代入する。
引数への代入操作はIL命令として短縮形があまり用意されていないので避けた方がよい。引数のロード操作はLdarg_0~3と1byte長命令があるのに対してストア操作は最短でも2byteなのである。第0引数（つまりthis）のフィールドISerializerResolver resolverをロードし、Get&lt;フィールドの型&gt;を呼び出している。
ISerializerResolver.Get&lt;T&gt;はジェネリックメソッドである。これの具象を呼び出すにはジェネリック型に対するGenericInstanceTypeよろしくGenericInstanceMethodオブジェクトを作成し、GenericArgumentsプロパティに型引数を埋めるのである。Get&lt;フィールドの型&gt;によりISerializer&lt;フィールドの型&gt;を得た。
フィールドをシリアライズするならばISerializer&lt;フィールドの型&gt;のTryWriteを呼び出さねばならない。追加で3つ引数を充足する。ジェネリック型ISerializer&lt;T&gt;を具象型ISerializer&lt;フィールドの型&gt;にして、TryWriteメソッドのMethodReferenceを得、呼び出しを行っている。
Mono.Cecilの不思議な点としては、ジェネリック型を具象型にするのも、ジェネリックメソッドを具象化するのも簡単であるのに、具象型からメソッドを得るのが非常に難しいということである。
TypeReferenceとGenericInstanceTypeにはMethodsプロパティがないのである。迂回策として次のメソッドを定義して利用した。かーなりダーティである。TryWriteの戻り値はlong型であり、それが負の数ならば書き込み失敗であるからjumpDestinationWhenFailの示す命令にジャンプする。そして書き込んだbyte数だけ第3引数capacityを減らし、残りの最低限書き込まねばならないbyte数（initialNeedLength）と比較し、書き込めなければ失敗へとジャンプする。FillOneFieldに戻るが、後は"}"を書き込んで、失敗時の処理をしているだけであり、容易に読み解けるだろう。複数個のフィールドをシリアライズする場合にFillFieldsを用いる。
およそFillOneFieldと同等のことをした後2番目以後のフィールドのシリアライズを繰り返している。今回のサンプルではフィールドの型に対して愚直にISerializer&lt;T&gt;をISerializerResolverから取得してTryWriteしている。
だが、intなど数値型, string, boolについてはフィールドの型を見て特殊化された処理を埋め込むことでより性能の向上が見込まれる。
また、フィールドの型が同一アセンブリ内に存在するなどして、シリアライザを得られる場合も処理をインラインで埋め込むことで性能を向上できる。更に、今回はフィールド名を1byteずつ代入しているが、4または8byteにまとめて書き込んだ方がよい。以上を以て2つ目のサンプルであるJSONシリアライザ生成についての解説とする。Mono.Cecilに関する日本語の情報は大体2~3年おきに散発的に記述されるに留まる。
この記事が数年後の誰かの役に立つことを願う。


