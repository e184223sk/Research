More than 1 year has passed since last update.前回の記事(実装編)からの続きになります。
Unity(C#)で私なりにCleanArchitectureの実装例を説明しました。CleanArchitectureのルールに従って、アプリケーションロジックからフレームワークを抽象化して切り離すことで、特定のフレームワークに依存しないアプリケーションロジックを実装することが出来ます。
つまり、フレームワークが無くても(≒決まってなくても)アプリケーションロジックのみを実装することが出来、フレームワークの都合を抜きにしてテストすることが出来る訳です。この記事ではUnityのシーンに実装したアプリケーションロジックが正しい仕様で動いているかをTest RunnerのPlay Modeテストする方法を解説します。GitHub:naninunenoy/UnityViewPatterns/BMIAppUIの実装を View に落とし仕込み、アプリケーションロジック( UseCase )からは View を直接参照させるのではなく、Presenter という中間層を定義し、それを介してUIの操作(ボタンのイベント受信やテキストの変更など)を行っていました。同様にデータの入出力(保存/読み来み)やログイン処理などでも UseCase からの利用を中間層を介してやることで、フレームワーク(詳細)にとらわれないアプリケーションロジックの実行が可能になります。これにより、クライアント側で一時的なデータ保存の実装を用意してやれば「データを保存するバックエンドが用意できていないからクライアント側の実装が進められない」という状況にも対応できますし、テスト用のログイン実装を用意すれば「ログイン画面のテストが通信状況の良し悪しで結果が変わってしまう」いった問題に対応できます。※DI(dependency injection): 依存性の注入肝になる考え方は、CleanArchitectureによってアプリケーションロジックである UseCase が詳細(UIやデータ保存や認証の方法)とは無関係でいられるので、製品コードとテストコードとの実行でそれら(詳細の実装)を切り替えてもアプリケーションロジックは問題ないということです。
本来のクラスの実装では内部変数やイベントが隠蔽されているので操作できない(良いことです!!)ところを、テスト用のクラスではそれらを外側(テスト実行のコード)から自由に操作できるようにし、操作した結果が画面やデータに反映されているかをテストすればOKという訳です。または、実装が特定のフレームワークに依存してしまっているので、依存せずテストに都合のいいクラスをテスト用に用意するなどの選択肢があります(こっちが本来の恩恵かも)。このために、実際とテストとの実行で UseCase にinterfaceで渡される中間層のクラスをDIで切り替える必要があります。Zenject(または Extenject)はDIのフレームワークですがテストによる実行もカバーしており、自動テストのための解説も載ってます。 自分でGoogle翻訳したやつその中に SceneTestFixtureというものがあります。本来はシーンのロードがエラー(例外)なく行えるかをテストするもののようですが、こいつでPlayModeテスト用のDIを行ってシーンを実行できないかを試してみました。(結果的に実現できましたが、前提として準備しておくことが多く、既存のプロジェクトに後の載せで行うにはかなり厳しいと思います汗)実装の前提ですが、UseCase に渡す Presenter などは Installer で準備します。そして、準備された Presenter などの中間層の要素を Main で受けとって UseCase を作成/実行します。Installer はZenjectの MonoInstaller を継承したものであり、実際にアプリケーション実行のためのDIを行うものになります。こいつは中間層も詳細も両方知っておいてよい存在になります。[SerializeField] などでUnityの要素を受け取るのもこいつに集約させると良いでしょう。Installer でDIされた実装が Main に渡り UseCase の材料になって実行されるわけです。Installer でDIされた実装が Main に渡り UseCase の材料になって実行されるわけです。つまり、テストではテスト用のDIを事前に行った状態でPlayModeテストでシーンを読み込めばテストのためのシーン実行が出来る訳です。さらっと(?)書いていますが、テスト実行のために解決すべきポイントがいくつかあったので解説します。シーンがロードとされる前にDIするので SceneContext がまだ存在しないためBindできなかったStaticContext に設定できます。
しかし、StaticContext のBindよりも Installer で SceneContext に改めてBindされるものの方が優先されてしまうので、Installer でのBind全てに .IfNotBound() を設定します。シーンがロードとされる前にDIしたい訳ですが、Presenter のコンストラクタには IView が必要であり View は シーン上のGameObject なのでシーンがロードするまで取得できない(テスト用に事前にDIするPresenter が生成できなかった)IPresenter を実装した TestPresenter を定義しました。こいつはコンストラクタに IView を持たず、シーンがロードされてから BMIView を GameObject.Find() などで見つけてきて改めて BMIPresenter を生成し、.InnerPresetner に後で設定することが出来ます。動作は本来の BMIPresenter と同じ振る舞いをします。IUseCase.Begin() が Main.Awake() に書かれているので、シーンロード直後に問答無用で実行されるため上のように .InnerPresenter を設定する暇がなかった(設定しても実行された後なので無意味だった)Main.Awake() のを任意のタイミングで実行するためにトリックを仕込みます。
まず、Installer全てを MainInstallerBase が親になるように継承させ、その中でテスト実行かを判別し Main の GameObject を非活性にするようにします。非活性( gameObject.activeSelf==false )な GameObject は Awake() が実行されず、活性化したタイミングで Awake() が実行されるという Unity の仕様があります。Zenjectも内部的にこの仕組みを利用しているらしいです。1そして、テストコードで Main を活性化すれば任意のタイミングで IUseCase.Begin() を呼ぶことが出来ます。BeginMain() がそれです。あとは View であるuGUIをコードから任意に操作したり、シーンをロードする前に DataStore に任意の設定しておくなどして想定通りの挙動になっているかを Assert でチェックしていって下さい。テストコードでの流れは
1. テスト用のDIを StaticContext.Container に行う
2. 目的のシーンを読み込む
3. シーンからテストに必要な要素( View など)を取り出して準備をする
4. 前述のトリックを解除し、UseCase を実行する
5. 挙動が想定通りかどうかをテストになります。テストの実現方法の説明にスペースを割きましたが、ここまで準備すれば外部に依存しているクラスを別のテスト用のクラスに入れ替えて、にUnity内の実装だけをテストすることが出来ます。「折角 UseCase が inerface に依存するようになったんやし、シーンテストするときに詳細の実装を入れ替えられたらええんちゃうんちゃうん？」
みたいなノリでやり始めたのですが、結構つまづきポイントが多く、結局はテスト都合の実装を製品コードに埋め込む必要があるという結果になってしまいました。それでもテストがあればデグレへの不安が大幅に減りますし、バグが見つかってもUnity側(クライアント側)で完結したテストが通っていれば原因切り分けの助けになるでしょう。TestPresenter は通常の Presenter はコンストラクタで IView を受け取る仕様になっていて、しかも readonly で書き換え不可能なのために仕方なく生まれたもので、外部に依存しているクラスを別のテスト用のクラスに入れ替えて、にUnity内の実装だけをテストという文脈とは本来的には無関係です。Play Modeで[Run All]するとZenjectのテストでコケる場合があります。エラーメッセージに書いてあるように、Scenes In Buildに TestSceneContextEvents シーンを追加してやれば通ります。
(Zenject/OptionalExtras/IntegrationTests/SceneTests/TestSceneContextEvents/ にあります)ZenjectはどうやってAwakeより先にInjectできるの？ ↩


