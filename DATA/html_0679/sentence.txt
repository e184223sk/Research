今まで、ListとDetailをその都度、ああでもない、こうでもないと試行錯誤して書いていたので、パターンにまとめてみました。.NET Core 3.1 + ReactiveProperty で構築します。で、DataGridのそれぞれの行に対応する、それぞれのDetailViewModelを作成しています。
MVVMを学び始めた当初、DataGridやListViewではこうする方法があることが分からなかったですね。ShowボタンのXAMLは次です。
Commandは、DataGridのDataContextつまり、WindowのDataContext（=ListViewModel）のButtonShowを呼び出します。
パラメータは、CommandParameter="{Binding}"によって、この行のDetailViewModelになります。その行のDetailViewModel自体をパラメータとしてうけとり（ここではxが、パラメータ）DetailViewModelが保持しているModel（infoVM.Model）を、ListManagerに渡して、Detailを表示します。従って、DataGridの行でもDetailでも、Modelは同じものを参照しますが、VMはそれぞれ異なります。DataGridの行で利用している、同じDetailViewModelを利用して、Detailを表示したいなら、の段階で、infoVMを利用して、ListViewModel.csから、DetailViewを表示してもいいかもしれません。そうすると、DataGridの行と新しく表示したDetailViewでのDataContextは、同じDetailViewModelを利用することになるでしょう。Showとほぼ同じです。Model　→　ViewModel 　→　View　の順序でnewしています。ViewとViewModelのnewは、ViewControllerのpublic staticのクラスで処理することにしました。View　 →　ViewModel　→　Model の方法もありますが、ここではModelが先です。
バックグラウンドでModelが動いていて、ある条件でViewを表示するなら、Modelを先にせざる得ないでしょうし、Modelが無くてVとVMだけあることはMVVMでは考えにくいので、Modelを先にnewするのがいいのではという考えです。ReactivePropertyで、よく分からないのはDisposeを呼び出すタイミングです。DataGridのClear・Removeは、ListManager.csのObservableCollection&lt;Info&gt; InfoListを、ClearしたりRemoveしています。
すると、ListViewModelの、ReadOnlyReactiveCollection&lt;DetailViewModel&gt; InfoListが変更されます。このコードでは、すぐに、DetailViewModelもDisposeされたので、ここでは明示的にはDetailViewModelのDisposeを呼び出していません。（これで良いのか？がよくわかりません。）DetailViewをCloseした時は、Disposeされるのかどうかが分からないので、明示的にDiposeしています。処理の流れがはっきりせず、デバッグしつつ追わないと、コードを見るだけでは分かりませんね。この点が、MVVMの難しいところだと思います。
ただ、パターン化しておくと、処理の流れの見当が少しつきやすくなりますね。


