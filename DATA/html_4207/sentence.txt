More than 1 year has passed since last update..NETCoreでSNSを作りたいと宣言したので口だけにならないように頑張って勉強します。
今回はEntityFrameworkCoreを用いてPostgreSQLに接続する方法を残しておきます。DbContextとEntityをまとめたプロジェクトにするのは別のアプリケーションを作成する際にコピペ流用がしやすいかなと思ったからです。PostgreSQLのサービスを起動し、そこにhello_dbというデータベースを作成します。テーブルはマイグレーションで作成したいので空っぽでよいです。Visual Studio 2017を起動します。[ファイル]→[新規作成]→[プロジェクト]で「新しいプロジェクト」ウィンドウが開きます。
左側で[Web/.NET Core]を選択して中央で[クラスライブラリ(.NET Core)]を選択します。
プロジェクト名とソースの保存場所を指定して[OK]をクリックします。
今回はEFCorePostgresAccessというプロジェクト名にしました。[OK]をクリックするとClass1.csだけのプロジェクトが作成されると思います。(このClass1.csは使いません。消してもOKです。)続きまして、NuGetにて必要なパッケージをインストールしていきましょう。
EntityFrameworkCoreでPostgreSQLを操作するにはNpgsql.EntityFrameworkCore.PostgreSQLというパッケージを使用します。[ソリューションエクスプローラー]のEFCorePostgresAccessプロジェクトの上で右クリック→[NuGetパッケージの管理]を選択するとNuGetタブが出現します。
「参照」タブにてNpgsql.EntityFrameworkCore.PostgreSQLを検索等で表示させて選択。そしてインストール。
「変更のプレビュー」ダイアログが表示されたら[OK]、「ライセンスへの同意」ダイアログは[同意する]をクリックしましょう。僕のPCにある.NETCoreがversion2.1なのでNpgsql.EntityFrameworkCore.PostgreSQL version2.1.2をインストールしました。
.NETCore 2.2が出ているのでそちらを使いたい場合は2.2.0を入れればいいと思います。Entityは、データベースの1テーブルをC#のオブジェクトに対応付けたクラスのことです。ソリューションエクスプローラーのEFCorePostgresAccessプロジェクト上で右クリック→[追加]→[新しいフォルダー]で、Entityというフォルダを作成します。
Entityフォルダの上でさらに右クリック→[追加]→[クラス]で「新しい項目の追加」ウィンドウが表示されます。
今回はアイドルユニットとその在籍メンバーを登録することを想定して下記の二つのEntityを追加しましょう。ユニットとメンバーは1対nの関係です。ナビゲーションプロパティとは、データベースのリレーションをEntityで表現したものです。
Memberクラスから見るとUnitは一つなので、プロパティとしてUnitを一つ持ちます。
Unitクラスから見るとMemberは複数あるので、プロパティとしてMemberのコレクションを持ちます。(List&lt;T&gt;にしましたがIEnumerable&lt;T&gt;ならなんでもいいと思います。たぶん。試してないけど。)テーブルを対応付けたクラスがEntityです。
そしてデータベースを対応付けたクラスがDbContextになります。(そんなイメージ)EFCorePostgresAccessプロジェクトの直下にHelloContext.csというファイルを作成しましょう。
Microsoft.EntityFrameworkCore.DbContextクラスを継承して独自のDbContextクラスを作成します。DbSet&lt;T&gt;プロパティを定義することでT型のテーブルをデータベースにCreateしていることになります。今回はDbSet&lt;Unit&gt; UnitsプロパティとDbSet&lt;Member&gt; Membersプロパティを定義しました。OnModelCreatingoverrideメソッドにてデータベースの詳細を設定していきます。そしてMemberのmodelBuilderの最後に注目。HasOneメソッドでMember.Unitはナビゲーションプロパティだよという指定をします。
それにぶら下げてWithManyメソッドを呼ぶことで逆のUnit.Membersもナビゲーションプロパティだよということを指定しています。
最後にHasForeignKeyメソッドにて、どのプロパティが外部キーなのかを指定します。
ここまで指定することで、UnitとMemberの1対nの関係を築くことができます。他にもカラムの初期値や明示的な型指定(未指定の場合はEntityのプロパティに合わせて自動指定)など、細かいテーブルへの設定はOnModelCreatingメソッドの中で行います。その他の設定方法はこのページから読み取ってください。(日本語訳がひどくて英語のままのほうがまだマシなので。。。)ご存知の方もいるかと思いますが、Entityクラスで属性(Attribute)を付与することで詳細設定することもできます。しかし複合キー指定など属性付与ではできないことがあるので今回はOnModelCreatingメソッドでの設定にしました。ここまででEntityFrameworkCoreの準備は終わりです。次からは使用する側を作成します。EntityやDbContextを利用するアプリケーションを作成していきます。ソリューションエクスプローラーの[ソリューション'EFCorePostgresAccess']で右クリック→[追加]→[新しいプロジェクト]でまたまたプロジェクトを追加します。
ASP.NET CoreWebアプリケーションを選択してください。
アプリケーションのプロジェクト名はHelloApplicationという名前にしました。
GUIまで作るのはめんどくさいのでJsonを投げ合うだけのRESTful APIを作成します。作成したEntityFrameworkを利用するためにHelloApplicationプロジェクトの[依存関係]で右クリック→[参照の追加]でEFCorePostgresAccessの参照を追加しましょう。チェックを入れて[OK]をクリックです。
HelloApplicationプロジェクト作成でappsettings.jsonが自動生成されています。それを下記のように編集しましょう。そしてStartUp.csのConfigureServicesメソッドにAddDbContextを追記しましょう。Configuration.GetConnectionStringによってappsettings.jsonから"ConnectionStrings"内の"HelloContext"の値を取得してきます。これでHelloContextインスタンスに対する操作はPostgreSQLに対する操作になります。
services.AddMvc().AddJsonOptionsでは循環参照をしているインスタンスをJson化する際に循環を無視するおまじないです。接続情報を指定できたところでマイグレーションを実行してみましょう。
メニューの[表示]→[その他のウィンドウ]→[パッケージマネージャーコンソール]を選択します。[既定のプロジェクト]がEFCorePostgresAccessであることを確認して、コンソールにて以下のコマンドを実行します。するとEFCorePostgresAccessプロジェクトにMigrationsというフォルダが作成され、(timestamp)_InitialCreate.csというファイルが作成されます。中を見てみると、SQLのCREATE TABLEに相当しそうなことが書かれています。この時点ではSQLが作成されただけでまだデータベースには反映されていません。さらにコンソールで以下のコマンドを実行してみましょう。すると、実データベースにSQLが発行されてテーブルが作成されます。
DbContextに保持したEntityに加えて__EFMigrationsHistoryというテーブルも作成されます。これはAdd-Migrationの度に作成されるデータベース変更用のファイルがどこまで反映されているかの履歴管理をするテーブルです。各テーブルを見ていきます。(A5:SQLという神ツールでデータベースを見ています)
Entityに定義したプロパティがそのままカラムに反映されているのがわかります。データ型もプロパティの型と一致しています。
memberも同様にプロパティがカラムに対応しています。
実はMember.JoinedDateはnull許容型で宣言していました。ですので[必須]にYesが入っていません。
そしてunit_idカラムは外部キーとしてunitテーブルを参照していることがわかります。下記の2つのControllersクラスを追加しましょう。F5を押すかメニューバーの[デバッグ]→[デバッグの開始]をクリックしてIIS Expressを起動します。(ValuesController.csを削除した人は404NotFoundが出ますが無視でOKです。煩わしいと思ったらここの一番下を参考)
自動で採番されるポート番号を覚えておきましょう。HTTPの検証はPostmanというツールで行います。HTTPのリクエストが送信できればなんでもよいのですが。まずはデータを登録します。

Sendボタンで実行するとunitテーブルにレコードが挿入されます。
同様にいくつかのユニットとメンバーのレコードを挿入しておきました。POSTしたデータをGETしましょう。
https://localhost:44317/api/member/1にアクセスすると下記のようなjsonが返ってきます。今度はhttps://localhost:44317/api/unit/1にアクセスします。Memberのjsonでは"unit"がnullになっています。一方Unitではぶら下がる"members"を同時に取得しています。
これはInclude(a =&gt; a.ナビゲーションプロパティ)メソッドの有無の違いです。データ取得の際にIncludeを挟むと指定したナビゲーションプロパティのインスタンスが生成された状態でデータが取得されます。続いて、既存データを更新するUPDATEです。
https://localhost:44317/api/unitに対して次のjsonをPUTします。「モーニング娘。'18」に名称が変更することができます。次はhttps://localhost:44317/api/member/1に対して"あんみぃ"という文字列をリクエストボディに詰めて投げるとmember_id == 1のレコードのmember_nameが"あんみぃ"に更新されます。2つの更新方法には違いがあります。
前者ではEntityを丸ごと渡すことですべてのプロパティ(カラム)を更新します。後者では一度Entityを取得して、特定のプロパティに値を代入してからSaveChages()を呼ぶことで、一部のプロパティのみ更新します。DELETEはシンプルですね。List&lt;T&gt;などの他のコレクションクラスと同じようにRemoveメソッドを呼んでいるだけです。(SaveChanges()はもちろん必要)現在の設定ではDELETEでUnitを削除すると、外部参照しているMemberも削除されます。
参照元を削除するCASCADEではなく被参照データの削除させないRESTRICTにする方法は調べておきます。(今後の課題ってやつ)めちゃくちゃ長い記事になってしまいました。が、この記事をあれやこれやと調べながら書いてるうちにかなりEntityFrameworkCoreの理解が深まった気がします。
誤字脱字や間違った内容を記述している場合は教えていただけると幸いです。最近MongoDBが気になっているすてぃんでした。終わり(オチ)


