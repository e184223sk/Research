More than 3 years have passed since last update.この記事は、SkyrimというゲームソフトのModファイルのバリナリ解析とそれを利用してModを生成するC#のコードについて記載していくシリーズ物です。趣味で作っているものなので、あまり役立つ情報ではないかもしれませんが、他にバリナリデータを扱う場合や、自分自身のために記事を書いて整理することで、色々と見直しをかけることや備忘録として役立てようと思っています。なお、SkyrimのModのファイルフォーマットについての解説などは、趣味のブログ（はてなブログ）で解説を書くようにしています。
これは、Skyrimの話の中心はブログで。
コードなど技術情報として共有できそうなことはQiitaで書くようにしているためです。
Skyrim Mod ファイルフォーマット解説 - 1 - RのSkyrim Mod開発日記SkyrimのModのファイルフォーマットの基本構造は次のようになっています。多少異なりますが、簡単には、先頭4byteがデータ内容を示す文字列、次の4byte(フィールドは2byte)がデータサイズを示しています。少し詳しく説明するとグループ、レコード、フィールドにはそれぞれ先頭にヘッダーがあります。グループとレコードは24byte、フィールドは6byteです。
この内、グループのデータサイズはヘッダーを含むサイズで、レコードとフィールドはヘッダーを含まないデータサイズとなっています。このため、グループは"GRUP"の後、4byteのデータサイズ分を取り込めばひと固まりとなり、これを繰り返すことになります。以下、それに対応するコードです。これだけでも、一応一通りのデータを取り込むことができるはずです。
しかし、使い勝手が悪いので、文字型や数値型などを扱うクラスを用意することにしました。文字型[System.Diagnostics.DebuggerDisplay("{Value}")]はデバッグ時に文字列がわかるようにするために設定しています。
また、SkyrimのModで扱う文字列はNULL終端であるものとないものとがあるため、終端のチェックをするようにしています。
通常はTesBytesを受け取って初期化するようにしますが、多くの場面で4バイトだけ読み取ることが多いため、Modのファイルリーダーを引数に受け取った場合、4バイトだけ読み取るようにしています。（あまり好ましい設計ではないかもしれませんが、楽なのでこうしています）
このようにクラス内に文字列の実体を持たせることで、文字列を書きかえても、ファイル出力時にToBytes()で書き出すことで、データの順序が狂わないようにしています。
ただ、読み取る際にValueプロパティを参照するのはやや面倒であったため、string型へ代入する際などは暗黙の型変換を利用するようにしています。続いて数値型です。デバッグ時の表示用に値とは別にバイナリエディタなどで確認している際にわかりやすくするように、バイト表示も加えています。
他のデータ型も同様の形で追加していきます。なお、バイト型と他のデータ型との変換はバイト型を扱うTesBytesで行うようにし、ファイルリーダーからの読み取りではそれ経由で変換するようにしました。GetString()やGetUint32()などを追加します。終端の判断などコードがちょっとアレですが・・・こんな感じでやっています。
ちなみに、一旦引数に入れていたり、戻り値用の変数名を一律resultとしているのは、デバッグで楽だからこのようにしています。
ネーミングなどもう少しちゃんとした方が良いのかもしれませんが、趣味のプログラムでそういったことに悩みたくないので、昔ながらのやり方から離れられないでいます。（最近頭が古いなと良く思います）その他の方も同じような感じで作っていきます。
先ほどのグループクラスを次のように変更しました。ちなみに、当初は各基本型にファイルリーダーを受け取ったら暗黙変換するようにして代入を楽するようにしていましたが、データが読まれているかがわかりづらいのでやめました。
先ほどまでの形の方が何バイト読み進めているかがわかりやすいですが、決まった形なので、これでよしとしています。以上。とりあえず、今回はここまでです。


