More than 3 years have passed since last update.C#を学習すると共変と反変という用語がでてきます。難しそうな用語ですが、その取っ掛かりとして戻り値と引数に的を絞って図によるイメージで説明します。数学的な知識は前提としませんし、コードも簡単なものしか出て来ません。型周りの知識を整理するのにも役立つでしょう。この記事で最終的に説明したいことは、次のようにデリゲートから参照するメソッドの戻り値や引数の型を変える規則についてです。この規則はイメージしにくく混乱を招きがちですが、図による直感的な説明を試みます。※ 具体例で用語に慣れることも目的としています。なるべく話を単純にするため、ジェネリックとの関係には触れません。例として、Aを継承したBというクラスを考えます。継承を包含関係で図示すれば、視点によって次の2種類が考えられます。まったく逆の図ですが、どちらかが正しいというものではなく、目的に応じて選択することになります。今回は型が話題の中心のため、「型」の図を使用します。先ほどの図にObjectとStringを追加してみます。図の見方というか、イメージが湧いたでしょうか。MSDN では次のように説明されています。（「」内の訳語を補っています）ジェネリックの共変性と反変性 より「強い」「弱い」は「狭い」「広い」とも表現されることがあります。ここでは当面必要な範囲で割り切って、継承に限定して話を進めます。便宜上、継承が進む方向と共通なのが「共変」と覚えておけば良いでしょう。図で考えれば、内側への矢印が共変、外側への矢印が反変となります。「狭い」「広い」というイメージも表現されています。※ これは説明のためのイメージに過ぎず、実際に何か物理的な広さを持っているわけではありません。イメージを補強するため、Rubyでの継承の書式を紹介します。※ この記事でRubyが出て来るのはここだけです。クラスの定義で、C#では継承関係を : で表しますが、Rubyでは &lt; で表します。&lt; は矢印として捉えて B は A から派生する（B ← A）というイメージが持てます。それが共変の方向です。※ この矢印はUMLのクラス図とは逆向きなのに注意してください。今回の図にこじつければ、B &lt; A はサイズ比較で A が広いとも解釈できます。図による型のイメージに慣れるため、ここからしばらくは基本的な言語仕様を図で説明します。説明には B を継承した C も使用します。インスタンスを生成して変数に代入する書式を示します。これを変化させて結果を観察します。左辺を B に固定して、右辺の型を変化させてみます。B が入るのは当然として、A はエラー、C はOKです。これを図で考えれば、大きい箱に小さいオブジェクトは入るのに対して、その逆はできないとイメージできます。B の通り口より大きな A は通り抜けができません。※ 実際には、参照型は値型と異なりインスタンス本体が代入されるわけではありません。あくまで説明のためのイメージです。次に右辺を B に固定して、左辺の型を変化させてみます。B が入るのは当然として、A はOK、C はエラーです。先ほどと同様に通路が通れるかどうかでイメージできます。A a = new B(); は左辺が A の型ですが、A は派生クラスの B を含むため、new B() が代入できます。このように左辺に注目して「A だから B もいける」と考えることは、普段のプログラミングでも感覚的に行っているのではないでしょうか。この考え方を形式的に A → B と表せば、継承が進む方向のため共変だと解釈できます。このように普段感覚的に行っていることに名前を付けたと捉えれば、少しは抵抗感が減るかもしれません。また右辺に注目すれば、暗黙で A a = (A)new B(); という B → A のキャストが行われているとも考えられます。このような基底クラスへのキャストをアップキャストと呼びます。左辺に注目するか右辺に注目するかで、型の変化が逆向きになっていることに注意してください。これは後でも出て来ますが、どこを基準に考えるかということが重要になります。メソッドを図にすれば、入力（引数）と出力（戻り値）のある箱として表現できます。※ ここでは簡単のため、戻り値がない（void）メソッドを除外します。引数と戻り値ともに B のメソッド Foo を考えます。Foo の引数に別の型を渡すことを考えます。代入と同様に A は通り抜けできず、C は通り抜けできるとイメージできます。引数 B b へ参照を代入していると考えれば、本質的には B b = new A(); と同じ条件だと分かります。今度は戻り値の方を変えてみます。やはり通り抜けでイメージできます。A は大き過ぎて外に出られません。メソッドの戻り値を受け取ることを考えます。メソッドから出て来たオブジェクトを漏れなく受け取るには、受け口はメソッドの戻り値と同じか広く取る必要があります。このように出入口をつなぐ場合、型の変化は進行方向に向かって広がること（暗黙のアップキャスト）しか許されないことが分かります。オブジェクトを変数に代入するように、メソッドはデリゲートに代入できます。※ マルチキャストデリゲートまで考えればこの言い方は不正確ですが、デリゲートにまつわる共変・反変の理解を優先するため、単純化して説明します。引数と戻り値ともに B のデリゲート Delg を考えます。デリゲートを図にすれば、メソッドと同じように入力（引数）と出力（戻り値）のある箱として表現できます。デリゲート単体で呼び出すことはできません。メソッドを割り当てれば呼び出せるようになります。※ 実際にはデリゲートからメソッドが参照されており、中に入るわけではありません。あくまで説明のためのイメージです。さて、ここまでは準備でした。いよいよここから先がこの記事の核心です。戻り値の異なるメソッドを用意します。※ 後で引数を変える都合上、戻り値と引数を接尾辞として追加しています。これを Delg に割り当てようとすると、FooAB はエラーになりますが、FooCB はOKです。メソッドから出て来た戻り値がデリゲートを通り抜けられるかどうかでイメージできます。メソッドの方が狭ければ通り抜けられます。デリゲートの型からメソッドの型を見れば B → C となり共変です。このようにデリゲートが共変の戻り値を受け付けることを共変戻り値と呼びます。進行方向に対して広がることしか許されないという原則を満たしています。戻り値をデリゲートから見ると進行方向とは逆になることに注意が必要です。今度は引数の型を変えてみます。これを Delg に割り当てようとすると、FooBA はOKですが、FooBC はエラーになります。戻り値と同様に、引数がデリゲートを通り抜けられるかどうかでイメージできます。外から見えているのはデリゲートの引数型 B であることに注意してください。※ 右の図は C なら通り抜けられそうですが、デリゲートは B を通すことを保証しないといけないため、B が通らないのは認められません。メソッドの方が広ければ通り抜けられます。デリゲートの型からメソッドの型を見れば B → A となり反変です。このようにデリゲートが反変の引数を受け付けることを反変引数と呼びます（あまり一般的な用語ではありません）。ここでも進行方向に対して広がることしか許されないという原則を満たしています。戻り値とは逆になっているのは、進行方向ではなくデリゲートを基準に見ているためです。戻り値では進行方向とは逆になっています。このように共変・反変を考えるときは、どこを基準に見ているのかを押さえておかないと混乱します。※ この図式を一般化して、入力に関係するものは反変、出力に関係するものは共変という図式を意識しておけば、この記事では言及しませんがジェネリックとの絡みも理解しやすくなるでしょう。派生クラスでメソッドをオーバーライドするケースを考えます。引数の型を変えるとメソッドのオーバーロードとして扱われてしまうため、引数の型を変えることはできません。戻り値も型を変えるとエラーになります。このようにオーバーライドでは型を変えることはできません。デリゲートの方が柔軟です。参考までにJavaのことを書いておきます。Javaでも引数の型を変えるとオーバーロードとして扱われる点は同じですが、共変戻り値は認められています。Javaのメソッドはデフォルトでオーバーライドが可能なため、C#と異なり virtual, override キーワードはありません。逆に、オーバーライドを禁止するとき final を明示します。


