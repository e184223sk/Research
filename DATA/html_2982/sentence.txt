More than 1 year has passed since last update.UiPath Developer Community 第12回ワークショップ で聞いてきた内容の覚え書き。。
いってきました。第12回。今回は LTへ登壇させてもらったり といろいろあったんですが、いちばん驚いたのが、、下記の例外処理について。コレです。「try/catchアクティビティは、try節、catch節、いずれかを最後まで実行しないと、finally節が呼び出されない」というナゾ仕様のはなし。

いやいや、、、ありえないっしょ、、、。ということでやってみました。

Tryで例外をスローするコード。Finally節がよばれれば「Finally.」が出力されるはずです。実行してみると、、
うん、ホントだ実行されてない。
ありえない仕様だと思います。。しりませんでした。try/finallyでなくてtry/catch/finally とした場合も、catchで再度例外をスローすると、try/catchいずれも最後まで実行できていないので、同じ結果となります。これは「例外を再度throw」でも「再スローのアクティビティ」でも「new Exception("hoge",exception)」など別の例外にWrapしてスローしても、結果は同じです。「try節、catch節、いずれかを最後まで実行しないと、finally節が呼び出されない」ってことは例外が発生しないで正常終了するか、発生しても上(呼び元)に投げない(ってつまり正常終了じゃん) 場合のみfinallyがよばれるってことですよね。。ちょっと意味が。。。ホントに残念なお知らせだと思います。ちなみに、たとえばJavaだと、try/catch のfinally節は基本的に try/catch節がどうなろうと、必ず呼び出されます。実行すると、うん、当然こうなります。実行すると、当然C#でも、Javaとおなじ。というわけでfinallyをちゃんと実行しつつ上(呼びだし元)にエラーを投げたいときは、catchで例外を投げるのではなく、例外のインスタンスを一旦変数に保管し、finallyもしくはさらにその後で、その例外をスローします。 
まずJavaで書くとこんな感じ。実行してみると、こういうことですね。UiPathでやるとこうです。try節は元のワークフローと同じ。トライキャッチのスコープであからじめexception変数を定義しておき、catchでスローされた例外 eを、その変数に格納します。
そしてfinally節で、その変数がnullでなければ「例外が発生していたはず」ということであらためて例外をスローします。
結果は、、、
よさそうですね。そういえば、Attended FrameworkもProcess.xaml をtry/catchで囲んでる箇所も、まったく同じ構造になっていました。Catchでは発生した例外を変数に入れておいて、
finallyで再度スローしてますね。
この処理の流れ、なんでこんなメンドイ流れなのかなー？？「正常終了と異常終了(業務とシステム例外)」の3パタンを一箇所に集めるためかなー？？って理解してたんですが、まさかfinallyをちゃんと呼べないバグの対応だったとは、、。。なるほど、色々勉強になりました。新しいユーザコミュニティをつくって、もっともっとユーザの声が届きやすくする動きがあるようですね！
まずは名前を決めましょうということで、名前を投票できるようです。下記のQRからいけるので興味がある方はアクセスしてみてください。以上です。。今回の記事は、、例外処理の件というUiPath本体外のところが中心になっちゃいました。。おつかれさまでした。 


