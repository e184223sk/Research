自分への備忘録もかねて逆引き辞典のような感じで記述します。
Emscriptenに関する知識はほとんどないため、Emscripten側から見た説明はほとんどありません。
Unity側のC#を単に"C#"、ブラウザー側のJavaScriptを単に"JS"、.jslibファイルまたはコードを"プラグイン"、コンパイルされて出力されるJSを"ビルドJS"と記述します。WebGL: ブラウザのスクリプトと通信を行う
を読むと大きくわけて2つの方法があるようです。今回はこの2番目のプラグイン形式による相互関数呼び出しに関する知見を少ないですが記載します。これ結構痛いです。ES2015(以降)で記述するとシンタックスエラーとなりビルドできません。
Emscriptenの仕様なのでしょうか？ブラウザー側で実行するJavaScriptのコードを記述したものをAssets/Plugins/WebGLのパスのフォルダを作成し、このフォルダの配下に.jslibという拡張子で保存すれば、ビルドするとこのコード(具体的にはプラグイン内の関数)がビルドJS内に展開されます。ビルドすると、プラグインの関数はビルドJS内に関数名の頭に'_'が追加されて展開されます。
ですので、JS側からこれらの関数を呼び出す場合は、頭に'_'をつけて関数を呼び出します。展開先ですが、5.5まではグローバルスコープに展開されるので外部のJSコードからでも簡単にアクセスできたのですが、5.6からはブロック内に展開されるため外部のJSコードからはアクセスできなくなりました。
ですので、外部JSコードからもアクセスできるようにするには、プラグイン内でグローバルオブジェクトのプロパティに設定するコードを記述する等の方法をとります。これは、WebGL: ブラウザのスクリプトと通信を行うを読めばほぼ済んでしまいますが、一応説明すると、戻り値がある関数も呼び出して戻り値を取得すことが可能です。
JSの関数を呼び出すには、DLLの関数呼び出しと同様にDllImport属性を使用して呼び出す関数を定義して呼び出します。以下の例のようにFuga()のみDllImportを記述してビルドを行うと、ちゃんとチェックされてPiyo()はビルドJSに展開されません。C#側では(直接)使用しない(DllImportしない)けどJSに展開したい関数や、または別途定義しておきたい配列やオブジェクトがある場合は、以下のコードのようにプラグイン内で頭に'\$'をつけたメンバー名でを記述しautoAddDeps()を行うことで、JS側に'\$'が取れた関数名または変数名でビルドJSに展開されます。ですので注意点として'_'の時と同様、JS側でこれらを使用する場合は、'\$'をとった名前で使用します。
ただ、boolや数値、文字列などのプリミティブなものはできないようです。具体的にはboolや数値の場合は展開されず文字列の場合はなぜか文字列が変数名となり、この変数にapply(null, arguments)を行うという関数として出力されます。bool型は0と1で渡されます。
stringはPointer_stringify()を使用しポインターからstringを取得します。
数値型(intやfloat等)配列を渡す場合は、配列自体のほかに配列の要素数を渡す必要があります。
ポインターから数値型配列取得はHEAP8、HEAPU8、HEAP16、HEAPU16、HEAP32、HEAPU32、HEAPF32、HEAPF64から行います。JS関数の引数の型にstringを設定して呼び出すと(具体的にはPointer_stringify()の戻り値が)""となります。想像に難くないですが、objectや数値型以外の配列は渡せません。ですのでもしこういった値を渡す場合は、JSONにシリアライズしJS側でデシリアライズする等の方法をとり渡します。C#は関数のオーバーロードができますが、JSは関数のオーバーロードというものが存在しません。
そこで、以下のようにC#側はオーバーロードで記述して、JS側は1つの関数で記述したコードを記述して試してみました。
ビルドが通り実行もできますが、期待した結果となりません。
具体的には、以下のコードを実行してみると、JSのconsole.log()結果がとなり、どうやら最初のDllImportのみ使用されているみたいです。ビルドは通りますが実行時にエラーとなります。
これはたぶんEmscriptenの仕様上仕方がないところだと予想します。数値型以外の場合はポインターを戻さなければなりません。_malloc()したものは_free()しなければならないですが、ポインターを戻すとなると_free()するタイミングがありません。ですが、マニュアルを読むとstringを戻す場合はIL2CPP側で開放してくれるそうです。Nullable型以外でnullに設定できる型がstringしかないため、戻り値の型をstringに設定している場合に限る話ですが、前述の通り戻り値を返す場合は基本的に_mallocしポインターを戻しますが、_mallocせずにそのままnullを戻すとC#側で受け取ってもnullとなります。まあこれはそもそもな話ですが、戻り値の型をIntPtrにしてMarshal.Copy()することで対応することは可能です。ただし、これでもまだ(C#側で)要素数を事前に知っておかなければならないという問題が残ります。JSから戻すときに配列の先頭に要素数の要素を追加し戻す。C#側でIntPtrで受け取り、次の要素のポインターから配列を取得することで、動的に戻り値の配列全体を取得することができます。ただし、これでもまだ新たに_malloc()したものを_free()するタイミングがないという問題が発生します．．．
(回避策その２は"Runtime.dynCall()の使い方"の次に記載します)今まではC#からJSの関数を呼び出す方法でしたが、ここからは逆にJSからC#の関数を呼び出す方法です。
マニュアルにはJSからC#の関数を呼び出す方法が書かれていませんが、ネットで調べると情報が少ないですが方法を見つけることができました。
MonoPInvokeCallback属性を設定したAction(delegate)をJSに渡すと、JSではその関数のポインターを取得することができます。
Runtime.dynCall()で取得した関数ポインター(と引数)を渡して実行することでC#の関数を呼び出すことができます。Runtime.dynCall()はEmscriptenの関数と思われます(自信ない)。
このRuntime.dynCall()の定義はとなっています。
Runtime.dynCall()の第1引数は、関数のシグネチャーを指定子の組み合わせ文字列を渡します。
指定できる文字は以下の4つです。
(この指定子に関するドキュメントが見当たらないため、この認識で正しいかどうかはわかりません)最初の文字は関数の戻り値の型の指定子を、それ以降は呼び出す関数の引数の順番に合わせて指定子を設定します。
例えば、
'vii'だと戻り値無しの関数で第1引数および第2引数ともにint型の関数という指定となり、
'if'だと戻り値がint型で、第1引数がfloat型の関数となります。
この組み合わせは自由に設定できるというわけではありません。
Runtime.dynCall()内部ではModuleのメンバーとして定義されたdynCall_で始まる関数が呼ばれます。この関数のパターン分の組み合わせでないといけません。かといってdynCall_で始まる関数の定義数が少ないわけではなく、123パターン定義されています。(Function Tableと呼ぶようです)

'i', 'f', 'd'しか引数の指定子がないことからわかるように、C#からJS関数を呼び出すのと同様に数値型はそのまま、それ以外の場合はポインターで渡します。(ポインターは'i'となります)
Runtime.dynCall()の第2引数は、C#関数のポインターを渡します。
Runtime.dynCall()の第3引数は、呼び出す関数に渡す引数を配列で渡します。これをここに持ってきたのは、JSからC#の関数を呼び出す方法を使用するためで、事前にC#の関数を呼び出す方法を解説したほうがいいという理由からです。
数値型を戻すには事前にC#側で要素数を把握しておかなければいけないという問題点がありましたが、配列と要素数を引数にしてJSからC#の関数を呼び出すことでも回避することができます。JSからC#の関数を呼び出すには
_malloc()⇒HEAP.set()⇒Runtime.dynCall()⇒_free()
というルーチンを実行しなければなりません。
C#の関数を呼び出すたびにいちいちこのルーチンを行わないといけないため、関数を作成して簡略化します。
ない頭振り絞って作成したC#の関数を呼び出すUtility関数が以下のUnityCallという関数です。
数値型配列の場合は、全要素をチェックして判定することも可能ですが、そうなると要素数が多くなるとそれだけ重くなってしまいますので、数値型配列を渡す場合はHEAPxxを添えて渡すことで手抜きします。


