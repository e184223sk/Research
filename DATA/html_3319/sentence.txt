More than 1 year has passed since last update.近年のInventorでは簡単にDockable Windowを作成できるのですが、EnterキーとESCキーが入力できずにハマるというパターンがあると思います。
これについて、回避方法を説明します。WinFormsを使って開発すると、それぞれのControlが特殊キー(EnterやESC)を受け取った時に、親Formにお伺いを立てるわけですが、その近辺の処理がうまく出来ないと、この問題が発生するようです。この問題が発生するのは、DocableWindowにControlを直接登録した場合です。
逆を言えば、ControlをいったんFormに配置して、そのFormを登録すれば、問題をひとまずは回避できます。しかし、この方法では、DocableWindowがInventorとは別のWindowとして振舞おうとするので、微妙にフォーカスがらみで挙動がおかしくなります。
具体的には、InventorのWindowが例えばメモ帳の後ろにある場合、このDocableWindowをクリックしてもInventorが前面に来ません。RichTextBoxでしか試していませんが、殆どの場合はこれで回避できると思います。技術的な詳細は割愛しますが、RichTextBoxの代わりに上記のMyRichTextBoxを使うと、Enterキーをキャプチャーできるようになります。
実際の場面では、UserControlに配置して使うのでしょうから、そのUserControl自体にこの方法を適用すれば良いのでは? と思い試してみましたが、駄目でした。
ですので、UserControl内の全てのControlは、それぞれに対策が必要です。(もちろん、必要がある場合は、ですけど)WM_GETDLGCODEに対応することで解決したかに思えたのですが、DataGridViewではうまく行きませんでした。
追いかけてみると、DataGridViewは、編集時にそのセルに重ねるように別のTextBoxを配置していたのです。
このTextBoxのWndProcに介入できないので、DataGridViewについては、大掛かりになりますがWindows自体のKey EventをHookします。
少しcodeが長いですが、お付き合いください。この対策をUserControlに適用すれば、全て解決するのでは? と思ったのですが、DataGridViewに対しては良かったものの、今度はRichTextBoxに対してうまく動作しませんでした。
もう少し突っ込んでいけば、UserControlだけの対応ですむ方法が見つかったのかもしれません。しかし、上述の通りRichTextBoxには既に回避策が見つかっていたので、個別対応することにしました。(この時点で、既に結構な日数を消費していたので、力尽きたのです)上記code内で、AddInがunloadされるときにHookを解放しようとしています。(HookObjectのデストラクター)
しかし、実際にはこの解放するcodeは呼ばれていないようです。Inventorが正しい手順を踏んでAddInのtheradを終了させていないのかもしれません。
現時点では何の問題も発生していないので、WindowsがAddInのtheradが終了するときにunhookしてくれているようです。通常は気にすることが無いのですが、今回の解決策のように標準のWinFormsではない自作Controlを使って開発しようとする場合は、対象プラットフォームにAny CPUではなくx64を指定していると、ハマります。
具体的には、Visual StudioのデザイナーでControlを配置できなくなります。
これは、デザイナーが実際にControlをロード(実行)して画面上に配置するからで、x32アプリケーションであるVisual Studioはx64のカスタムControlを読み込めないからです。
解決策としては、デザイナーで作業する前にAny CPUにしてリビルドすると良いです。デザイナーで作業しない限りは、x64で作業して問題ありません。Autodesk Inventor API Hacking (概略)


