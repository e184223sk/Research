More than 1 year has passed since last update.今日コードを読んでいるときに、理解できない部分があったので調べてみた。今日は２つのトピックで、JSON のシリアライズについての Tips です。[DataContract] というアトリビュートが使われていた。このアトリビュートをつけて、[DataMember]アトリビュートをプロパティにつけるとそれらがシリアライズ対象になる。つまり、つけないとシリアライズされない。こちらの公式リファレンスはこちらなのだが、JSON に対する記述がなくて混乱した。こちらを見ると、XMLのシリアライズしか書いていないので混乱したが、NewtonJsonのサンプルのページには記述があった。上記のクラスを実際にシリアライズしてみると、[DataMember] をつけていない Age が無視されているのがわかる。また、カスタムクラスの Context のクラス定義側には、[DataMember]をつけていないけど、使われている側で指定しておけばシリアライズしてくれる様子だ。私が呼んでいたコードでは、シリアライズ、デシリアライズする部分で、TypeNameHandler が使われていた。次のような記述をすると、シリアライズ・デシリアライズの時の振る舞いを設定できる。TypeNameHandling.Objects JSON オブジェクトをシリアライズするときに型名を追加する。クラスの定義がある場合、その型名が含まれています。他にも指定が可能です。一瞬何が違うのかわかりませんが、動かしてみると明確です。最初はこの機能が何がうれしいのかさっぱりわかりませんでしたが、実際のコードをいじっているときにわかりました。この使い出は、インターフェイスがプロパティとして定義されているようなクラスで有効です。一旦 JSON になってしまえば、型がわかりません。インターフェイスに対してデシリアライズしようとすると、具象型がわからないので、デシリアライズできません。ところが型情報があれば、デシリアライズ可能です。このことを念頭に置くと、Autoが存在する理由もわかるでしょう。今回は JSON に関するコードリーディングの内容をまとめてみました。


