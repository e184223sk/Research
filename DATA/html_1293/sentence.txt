More than 1 year has passed since last update.IDisposableなんて別にpublic void Dispose()を実装するだけでも事足りることばかり。でもどうせならDisposeパターンなんてより丁寧に書くための物があるんだから使いたくなるのが開発者の心情というもの。と言うわけでIDisposableを使うときの個人的なメモ。
「より安全で丁寧なコードを書くにはどうしたら良いだろう？」という考え方が、以前書いた「【Windows/C#】なるべく丁寧にDllImportを使う」に通じるものがあるかも・・・1C#でよくリソースを破棄するために使うIDisposableインターフェイス。
それを丁寧に扱うためのテンプレートとして有名なDisposeパターン。
Visual Studio 2019だとclass A : IDisposableと打ち込んで、右クリックメニューから「クイックアクションとリファクタリング...」から「破棄パターン2を使ってインターフェイスを実装します」を押すと自動的に生成してくれるアレ。自動生成されるコードでは、ファイナライザがコメントアウトされていて「アンマネージド リソースを解放するコードが含まれる場合にのみ、ファイナライザーをオーバーライドします」と書いてある。
またDisposeパターンの正しい実装を求めてグーグル先生に尋ねてみたけど、どの情報も「アンマネージドリソースを使う場合はファイナライザを実装する」みたいな書き方になってた。
本当にそれで安全なのかな？とvirtualを付けているくらいだから継承できるはず。
とすると、そのクラスでアンマネージドリソースを使わなかったとしても、継承先で使われる可能性は十分あり得るのでは・・・？
もしその時に継承元がファイナライザを実装していないとどうなるのかな？継承元のAクラス。継承先のBクラス。あと実験用のProgram.cs。単純にDisposeとファイナライザを呼び出したときにコンソール出力するだけのクラス。
それをわざとDisposeをすっぽかしてみる。結果当然BクラスのDisposeもFalseで呼ばれている。
ちなみにGC.Collect()を呼ばないと、ファイナライザを実装してても呼ばれなかった。アンマネージドリソースを使ってないからとAクラスのファイナライザは実装しない。継承先のBクラスでは、ファイナライザでDispose(false)を呼んでくれると信じて、アンマネージドリソースの破棄処理を実装したとする。そしてさっきと同じように実行。結果しーん・・・
やはり実行されなかった。少なくともsealedが付いていないクラス3でIDisposableを実装するときは、
「継承してもアンマネージドリソースを使うわけがないクラス」
「そもそも継承する予定のないクラス」
「Disposeは必ず呼ぶから大丈夫」
色々あるだろうけど、別にファイナライザを実装しても行数が増える程度で特に問題はないので、なにも考えずにファイナライザのコメントを解除して実装してしまうのが１番安全な気がする。
作成当時は「有り得ない」と思ってても、時間が経ってから継承してアンマネージドリソースを使うかもしれない。もちろん「アンマネージドリソースを使った側でファイナライザを実装する」というのもアリかもしれない。むしろ「アンマネージド リソースを解放するコードが含まれる場合にのみ、ファイナライザーをオーバーライドします」という説明的には、こっちの方が正しい気さえする。
でも継承先でDisposeをオーバライドしてもIDisposableのテンプレートみたいにファイナライザは自動生成されないし、絶っっ対にファイナライザの実装を忘れると思う。
なによりいちいち継承先で実装するのは面倒臭い。というわけで、IDisposableをDisposeパターンで実装するときは、自動生成のコメントに惑わされず常にファイナライザは実装していこうかなーって話でした。自動生成されるDisposeパターンのコードがいつの間にか微妙に変わってる？なんで引数にdisposing:をわざわざ付けるんだろう・・・
以前はGC.SuppressFinalize(this);もコメントアウトされてて、アンマネージドリソースを使う場合のみ呼び出す形だったような・・・書き出しを合わせてみたけど、シリーズ化する予定はない模様 ↩破棄パターン（笑）昔は「Disposeパターン」と表記されてたのに機械翻訳でこうなってしまったのかな・・・ ↩別にsealedとか気にせずファイナライザを実装して良い気もする ↩


