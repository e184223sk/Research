More than 3 years have passed since last update.Almir Vuk 氏による Xamarin.Forms and Realm: CRUD Example の日本語訳です。Realm 本家のサイトでも CRUD 操作を個別に解説していますが、1つのアプリにするチュートリアルのようなものは珍しいと思ったので、一応 Almir Vuk 氏に連絡をとった上で紹介することにしました。あくまでローカルの SQLite を置き換えるユースケースです。 Azure で Realm Object Server を使う、リアルタイム同期、認証、サーバープッシュするみたいなケースではないのでその点は注意が必要です。このブログ記事では、 Realm をモバイルデータベースとして使用して簡単なアプリケーションを作成し、 Xamarin.Forms の Realm で CRUD 操作を行う方法を示します。このプロジェクトのコードは私のGitHubページで利用できます。https://github.com/almirvuk/Xamarin.Forms_Realm_ExampleRealm に慣れていない方のために、公式の Web サイトからいくつかの文章を紹介します。 注意: 次のブログ記事で長所・短所について書きます。Realm モバイルデータベースはモバイルデバイス上で実行するように構築されています。従来のデータベースとは異なり、 Realm のオブジェクトはネイティヴオブジェクトです。オブジェクトをデータベースからコピーして変更し、保存する必要はありません。つまり、いつも本物のオブジェクトそのものを扱うことができます。あるスレッドまたはプロセスがオブジェクトを変更すると、他のスレッドやプロセスに即座に通知することができます。Realm モバイルデータベースはオープンソース（ Apache ライセンスを使用）でクロスプラットフォームであり、 Android、iOS、Xamarin（.NET）、React Native で利用可能なライブラリがあります。 Realm はプラットフォーム間で完全に互換性があります。Realm モバイルデータベースはすべて単独で使用できます。The Realm Mobile Platform より私が SQLite の代わりを探していて、初めて Realm を見つけたとき衝撃的でした。始めるのはとても簡単で、 Nuget パッケージをいくつか揃えればモバイルアプリでモデルとデータアクセス層をコーディングする準備は OK です。このチュートリアルでは、 Realm をモバイルデータベースとして使用してアプリケーションで CRUD を達成する方法を説明します。それでは始めましょう。新しく Xamarin.Forms アプリを作成してください。私の例では Sharedコードプロジェクト用に PCL を使います。普段通り標準的なフォルダを追加します。 Models、 Views、 ViewModelsです。アーキテクチャパターンとしてMVVMを利用します。訳注: 最近のテンプレートでは元々 Models、 Views、 ViewModels フォルダが準備されてますね。手順を同じように追う場合はで作るとよさげです。プロジェクト名は Xamarin.Forms_Realm にすると、サンプルコードをコピペしたくなったときに便利です。ふんだんにアイコンを使用しているのでとかしましょう。
（オリジナル記事より）Realm データベースを使用するには、 nuget パッケージを追加する必要があります。ソリューションの「 NuGet パッケージの追加...」に移動し、このように Realm の nuget を探します。
（オリジナル記事より）PCL とその他（ Android、UWP、iOS ）の全てのプロジェクトに忘れずにインストールします。少し待つとこのメインの nuget が依存する他の nuget もインストールし終わります。準備ができました。このアプリはチームと選手に関するものなので、 Models　フォルダーに Team とPlayers を表す2つのクラスを作成します。チームと選手には1:Nの関係があるので、 Player クラスでは Team 型のプロパティを「外部」プロパティとして持ち、 Team クラスでは Player 型の List を持ちます。このように設定すると、2つのクラス間に1対多の関係ができます。Realm をモバイルデータベースとして使用するには、データベースで「 create table 」する必要があります。そうするためにはテーブルになるクラスが RealmObject を継承する必要があります。2つのクラスは下記の通りです。（訳注: 記事に Player.cs なかったですが、リポジトリ見るとこうでした）ご覧の通り、プライマリーキーを宣言するために、 string 型のプロパティに [PrimaryKey] というデータアノテーションを使用していて、それは自動生成される GUID です。 Realmではまだプライマリーキーのオートインクリメントはサポートされていない 点が重要です。関係（リレーション）を持ったモデルの準備が整ったので、データの問い合わせを開始する必要があります。ここで、 TeamsListPage.xaml というビューフォルダ内に View / Page を1つ作成します。これは次のようになります。この xaml ページはほとんど説明することがありません。最上部には、新しいページを開き、データベースに新しいチームを追加するためのツールバーが1つあります。view　の主要部分は ListView コントロールであり、この ListView のアイテムソースはこのステップの後で作成する view model における List へのバインディングです。ItemTemplate では ListView アイテムの構造（List View アイテムの見た目）を作成します。グリッド内のラベルは、 Team 型のリストアイテムのプロパティにバインドされています。なぜならこの ListView はデータベースの Team を表示するためです。view model を作成する前に、 ViewModels フォルダに BaseViewModel クラスを追加します。このクラスはOnPropertyChangedメソッドを持ちます。すべての view model はそれを継承し、プロパティに対して OnPropertyChanged メソッドを呼び出すことができます。BaseViewModel は次の通りです。もう view があるので、 view model を作ることができます。 ViewModels フォルダに TeamListViewModel.cs を追加してください。（訳注: Realm context = Realm.GetInstance(); ）Realm 型の新しいオブジェクトを作成しています。このオブジェクトは基本的にはモバイルデータベースを表現しています。それを使うことで CRUD 操作することができます。（訳注: AllTeams = new ObservableCollection&lt;Team&gt;(context.All&lt;Team&gt;()); ）context.All() の結果から AllTeams という ObservableCollection を初期化しています。ALL メソッドの構文はとてもシンプルです。context.All&lt;TYPE_OF_CLASS_TO_GET&gt;():IQueryable を返すので、それに対して LINQ を使用できます。ご覧の通りデータの問い合わせは、同じではありませんが EntityFramework と似ています。このコースの後半ではリストに対して Where やその他の条件で問い合わせます。コンストラクターの最後で AddTeamCommand を初期化しています。ユーザがツールバーのアイテムをクリックすると次のステップで作成する AddTeamPage に遷移します。また、 view のコードビハインドから ViewModel に対するバインディングコンテキストを設定することを忘れないでください。空のリストビューしか取得できないですし意味がないので、アプリを実行しません。しかし、Realm部分が例外を投げないか確認する場合はリビルド・実行してください。コードの動作確認もできます。チームをリスト表示するページができました。次は新しいチームを追加する（ create ） view を作りましょう。Views フォルダで AddTeamPage.xaml という新しいページを作成します。これは次のようになります。ご覧の通り、　Team プロパティのデータ入力する Entry コントロールとデータベースでの save/create 操作をハンドルするツールバーのあるとてもシンプルな「入力フォーム」ページです。次のステップはいつものようにビューモデルを追加することです。規約に従えば
 AddTeamViewModel.cs になります。view model はとてもシンプルです。いくつかプロパティがありますが、セッター内に OnPropertyChangedOnPropertyChanged があります。標準的な
 MVVM アプローチではプロパティが変更されるとそれにバインドされる XAML のコントロールは更新された値を持ちます。私のブログには MVVM 記事がいくつかあるので、馴染みがなければチェックしてみてください。また、 view model の主要な部分には SaveTeam() メソッドを呼び出す Command があります。SaveTeam の中でまた Realm オブジェクトを呼び出し、 context と名付けています。その下では DB で挿入を行う2つの方法があります。context.Write() を使い、新しい delegate の中にはこのような挿入を行う主要部分があります。context.Add&lt;TYPE_OF_OBJECT_TO_INSERT&gt;(OBJECT_TO_INSERT);また、BeginWriteメソッドから取得する新しいトランザクションを作成する必要がある場合に使用する方法があります。変更を適用するには、トランザクションをコミットすることが重要です。データベースに新しいエントリーを追加した後、このページを閉じます。viewのコードビハインドにバインディングコンテキストを追加することを忘れないでください。もうアプリを実行してテストできます。
（オリジナル記事より）動きました！チュートリアルを続けましょう。次のステップでは、チームの詳細を表示し、チームにプレーヤーを追加し、必要に応じてチームを削除します。最初のステップは、Views フォルダに TeamDetailsPage.xaml を作成することです。上部には、次のステップで実装するアクションのためのツールバーアイコンが2つあります。そして Team のためのデータを保持するラベルがあり、その下には、そのチームの選手のためのシンプルなListViewがあります。アクションは、新しいプレイヤーを追加し、このチームを編集して削除します。ここでは、この詳細ビューの view model から始めましょう。とてもシンプルな view model で、チーム詳細のプロパティがいくつかと、チーム選手の ObservableCollection が1つと、コマンドがいくつかあります。view model のコンストラクターでは TeamsListPage.xaml.cs　の TeamTapped イベントから渡される teamID を渡しています。実装を見てみましょう。これは、 ListView のタップアイテムから値を取得する一般的な方法であり、
 TeamDetailsPage に移動して teamId の値を渡します。TeamDetailsPage.xaml.cs は次のようになります。ここでは OnPlayerTapped を実装しています。 EditPlayerPage を開きますが、次のステップで説明します。 TeamDetailsViewModel に戻りましょう。ObservableCollection の下にツールバーアイテム用のコマンドがいくつかあります。コンストラクターではプライベートフィールドに _teamId をセットし、コンストラクターの外でも使えるようにしています。再び　GetInstance メソッドで Realm オブジェクトを生成しています。team という名前をつけた新しいオブジェクトはデータベースから作られ、 Find というジェネリックメソッドを使ってフェッチします。構文はこの通りです。context.Find&lt;TYPE_OF_CLASS_TO_GET&gt;(PRIMARY_KEY);team が取得できたら　view model のプロパティをセットします。データベースから取得した observable collection を初期化し、 All メソッドを使用します。 All メソッドは IQueryable を返すので、問題なく LINQ が使えます。 そのチームのメンバーに絞るために Where を使用しています。最初にこのコードを書いたとき、このような条件をセットしようとしました。.Where(p =&gt; p.Team.TeamId == _teamId)しかし、コメントに書いたように「ネストした RealmObjects 属性で問い合わせするのは現在サポートされていません」。その下で、コマンドをいくつか初期化しています。最後に書いてあるオブジェクト削除用のコマンドはこのチュートリアルで説明したいものです。再び Realm の context インスタンスを生成し、この team を teamIdを引数にした Find メソッドで検索します。Write メソッドを開く必要があり、その中でとてもシンプルな Remove メソッドを使ってデータベースからオブジェクトを削除することができます。Remove メソッドはパラメタとして RealmObject をとり、このケースでは team が削除されます。必要ならばこの部分をテストすることができます（もちろん必要です）。次のステップでは、 Realm のオブジェクトを Edit / Update する方法を見ていきます。TeamDetailsViewModel の最後の部分では EditTeamCommand を初期化していました。 EditTeamPage を開き、 teamId の値を渡していることがわかるでしょう。 EditTeamPage は AddTeamPage と同じなのでコード量を減らすために AddTeamPage を使ってみましょう。このケースではそのページを次のように作ります。新しいものはありません。次に、新しい EditTeamViewModel を作成し、このコードをその内部に配置します。コンストラクターで teamId を取得し、 Id でデータベースからデータを取得し、 view model のプロパティをセットし、  team データの save / update 用のコマンドを初期化しています。ここでは特別なことは行なっていません。しかし、一方で SaveTeam はとても面白いのです。 SaveTeam メソッドはツールバーアイテムの「 Save 」をクリックした時に呼ばれます。SaveTeam では Id でオブジェクトを取得します。面白いのは、 Write メソッドを開き、 delegate ないで新しい値を team オブジェクトにセットしていることです。もし Write  メソッドの外かつ delegate の内側でセットしようとすると、次の例外が発生します。
Attempting to modify object outside of a write transaction.そのため、全ての更新操作は Write 内で行う必要があることを覚えておくことが重要です。新しい値をセットし終えたら変更をコミットする必要があります。 Realm では Add メソッドでデータベースのオブジェクトを更新できますが、 bool 型の2番目のパラメータ 「 update 」はここで何を行うべきかを自明に説明していて、
 true に設定するとオブジェクトが更新されます。テストしてみましょう。
（オリジナル記事より）LGTMこれで Team クラス/テーブルに関して Realm モバイルデータベースを使った CRUD 処理は完成です。次のステップでは、 Team に外部オブジェクトを追加するのと一緒に、新しい選手を追加したり既存の1人の選手を更新する方法について説明します。これら2つのクラスの1:Nの関係を思い出してください。自分でも挑戦できますし、このチュートリアルを追えば必要な知識は書いてあります。チームの詳細ページの中には、新しいプレーヤーを追加するためのツールバーアイテムが1つあります。 TeamDetailsViewModel を開いて AddPlayerPage を開くためのコマンドをセットし、 id に teamId を渡しましょう。上記の gist では実装済みです。もしまだであれば新しい AddPlayerPage を作成してください。 XAML は下記の通りです。このページのコードビハインドは下記の通りです。TeamDetailsPage と同様、 teamId の値を AddPlayerPage に渡し、 BindingContext のセット時に teamId を AddPlayerViewModel に渡しています。view model を見ていきましょう。バインドしたプロパティがいくつかあります。また、保存アクションのためのコマンドが1つあります。コンストラクターでは、このチュートリアルの前のステップから学んだ標準的な方法で context という実際のオブジェクトを作成しています。主要部分は SavePlayer メソッドです。最初に id で team をフェッチし、その team に対して新しい選手を追加します。ご存知の通り、 SaveMethod はツールバーのアイテムをクリックしたときに呼ばれます。71行目（訳注: context.Write(() =&gt; { ） では delegate と一緒に Write メソッドを呼び、新しい選手と外部プロパティの Team を追加しています。アプリを実行し、テストしてみましょう。
（オリジナル記事より）動きました！最後は選手用の update / edit ページです。TeamDetail.xaml.cs と同様、 OnPlayerTapped というイベントの中で EditPlayerPage を開き、 playerId を渡しています。EditPlayerPage は追加アクションを行うページととてもよく似ています。コードビハインドです。view model はこの通りです。このコードはとても明確でしょう。このブログで説明していない新しいことはありません。このサンプルはわたしの GitHub に上げてあります。https://github.com/almirvuk/Xamarin.Forms_Realm_Exampleこのチュートリアルが役に立つと嬉しいです。このチュートリアルのゴールは素晴らしい Realm モバイルデータベースを使用した CRUD の例を示すことです。将来わたしも Realm を使用するでしょう。もしわからないことがあればブログ記事のコメント欄にコメントしてください。有用であればあなたも使ってみて、友人に広めてください。よろしくお願いします！英語的な部分は、義務教育やオーストラリアの語学学校で習ったのとは違う感じで厳しかったです。というわけでコード読みながら雰囲気を察して訳した部分も多いので、気になる部分があればぜひ編集リクエスト送ってください。どこの国の方が書かれたんだろうと思ってよくよく見てみるとボスニア・ヘルツェゴビナの方でした。公用語でないけど英語で書いてくれてほんとありがたかったです。日本では最近エクセルソフトさんと Realm さんがパートナーシップ契約を結び、これまで以上に有料プランに手を出しやすくなるはずなので色々試してみたいですね！


