More than 3 years have passed since last update.プロパティの値が特定の場合は変更する、という処理は頻繁に発生すると思います。
これを簡略化するために、1つのラムダ式からプロパティの取得と変更を行う2つの式木を生成します。
これにより、1つのプロパティを指定するラムダ式を書くだけで値の取得と変更が出来るようになります。まず、下のようなClassを考えてみます。
2つのプロパティFirstNameとLastNameがあります。
ModifyIfNeedメソッドを実行すると2プロパティを検証して、空白だったら代わりの文字を代入します。動作には問題ありませんが、ModifyIfNeedメソッドの中身は重複しているので、これを解決していきます。まず思いつくのがプロパティを参照渡しですが、プロパティは参照渡しが出来ません。
このためこのコードはコンパイルできません。そこで、現在の値と代わりの文字列を代入するデリゲートを渡して、残りは共通化します。最初よりは短く、重複も軽減されていますが、メソッドの引数にプロパティ名を2回書いているため、冗長に見えます。そこでさらにこれをシンプルにするため、取得する式木だけ渡して、代入するデリゲートは中で生成してもらう方法を取ります。使用する記述は簡潔になりましたが、式木を使うため処理は複雑なったので別クラスに移動しました。上の方式ではデリゲートを使用していましたが、今度は直接デリゲートを使わず式木を使います。
式木からデリゲートへの変換は.Compile()だけなので、簡単です。
難しいのは式木の組み立てで、コードだけだと何をやっているかイメージはつかみにくいと思いますのでなるべくコメントをつけておきました。ポイントは概要にもあるように、取得する式木から代入する式木を組み立てるところです。
() =&gt; this.Name
↓Expressionであれこれ
x =&gt; this.Name = xこれにより使用時の記述を短くすることが出来ます。なおこのメソッド自体はプロパティだけでなく、フィールドやローカル変数に対しても使用可能です。式木からデリゲートを生成する部分は少し重いです。
パフォーマンスがネックになるのであれば、内部でデリゲートをキャッシュする必要があります。http://neue.cc/2011/04/20_317.html
http://blog.shos.info/archives/2013/06/csharp_expression4.htmlVisualStudio2017
.NET Framework 4.7


