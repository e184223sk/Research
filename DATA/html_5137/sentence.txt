More than 3 years have passed since last update.マルチスレッドでの非同期データ受け渡しライブラリのSystem.Threading.Channels(corefxlabにあったころはSystem.Threading.Tasks.Channels)が、corefxに統合され、この度4.5.0-rc1としてリリースされたので、
さすがに大きな変更はないだろうと踏んで使い方などを書く。非同期でのプロデューサー・コンシューマーパターンを作るのがより容易になる。特徴としては以下のようになる注意: 現在netcoreapp2.1で、ConcurrentQueueが特定のケースでnetcoreapp2.0よりも遅くなるという現象が発生しており、System.Threading.Channelsもこの影響を受けるとのこと。
具体的には読み込み側スレッドが複数いた場合に性能がかなり不安定になる。(平均自体は1-2倍遅くなる程度だが、分散はかなり大きい)
2.1.0ではおそらく修正されず、2.1.1以降に修正される見込みなので、使用する際は必ずパフォーマンスを計測し、許容範囲に収まるかどうか、確認することをお勧めする。
関連issue: https://github.com/dotnet/corefx/issues/29595MSによる解説こちらも同パターンを実現するためのもの、とされている。しかし、こちらはasyncで運用するのにやや難がある実装になっていること、また、パフォーマンスもやや劣っている。
ただし、ChannelsはFIFO固定なのに対し、任意のコレクションを扱うことができるという利点がある。こちらは単純なプロデューサー・コンシューマーパターンというよりは、よりデータの流れというものを意識した要求を実現するためのライブラリとなっている。ただし、こちらの方は処理ブロックを定義してつなげる処理が必要なことなど、やや準備が煩雑で、気軽に使えるかというとそうでもない。ConcurrentQueueを介して読み書きをする。ただし、待機処理等はないため、セマフォ等を使ってそれを実現する。
こちらは自分で実装する範囲が大きく、面倒ごとも多いため、それらをやってくれるChannelの方が便利である。導入はnugetで行う。パッケージ名はSystem.Threading.Channels以下二つのクラスを起点として使用するSystem.Threading.Channels.Channel.CreateBounded&lt;T&gt;あるいはSystem.Threading.Channels.Channel.CreateUnbounded&lt;T&gt;を使用する長さ上限無しのチャンネルを作成する。作成時に追加で以下のようなオプションを追加することができる多くの場合はこちらで問題ないが、それでも読み出し側の処理が追い付かないと、メモリ消費量が大変なことになるので、シビアな環境で使う場合は要注意長さ上限付きのチャンネルを作成する。上限値のみ渡すこともできるが、作成時に追加でオプションを渡すことができる。
この時に指定できるオプションには、UnboundedChannelOptionsで指定できるものに加え、以下二つが追加指定可能。仕様で動作が決まっているならばWait以外の選択肢もあるが、黙って値を破棄する動作になるので、基本的にはWait推奨生成されたインスタンスには、(ChannelReader&lt;T&gt;)Reader及び(ChannelWriter&lt;T&gt;)Writerがあるので、これを通して読み書きを行う。Writerメンバの以下のメソッドを使用するReaderメンバの以下を使用する一般的にどういう手順で処理するべきかを書く。なお、基本的にはWaitで待ち、Tryで一気に読み出すのが効率が良いらしい。リクエストは任意のスレッドから投げたいけど、実際の処理はシングルスレッドに集約するというやつ。
大して短くなってないじゃないかと思われるかもしれないけど、これでも結構考慮事項が減って楽になっていると思う。
後、複数タスクの処理もやろうと思えば簡単に移行できる。corefxlabにあったころと比べると、随分機能削ったなーという印象。まあ基幹に入る場合はなるべくシンプルな方が良いと思うのでこれはこれで。実際IOが絡むと、単一スレッドに集約みたいなことはよくやるので、このようなちょうどいいライブラリが出たというのは大変うれしい。
Spanみたいに、どうしてもこれでなければ実現できない機能という事でもないけど、やっぱり便利なツールは使っていきたい。パフォーマンス等の話はこちらの記事で後、より重要な機能と思われるSystem.IO.Pipelinesも4.5.0-rc1が出たけど、これは誰か他の人がより詳しい解説を書いてくれると思う。


