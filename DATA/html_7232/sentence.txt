More than 1 year has passed since last update.・Unityで物理演算ゲーム（なぞった形にオブジェクトが作られる。まぁ言ってしまえば「Q (https://www.youtube.com/watch?v=E4RNuXFU9ww) 」のようなもの）の作り方が有りそうで無くて。
試しに作ってみたらそれっぽく出来たので、軽く晒してみます。１．なぞった形でMeshが生成される
２．Meshの形に沿った当たり判定（Collider）を設定
３．Rigibody2Dを付ける事であとは動きを物理演算に委譲する。これが出来れば大体完成なのです。　簡単そうに見えますね？まず、指が通った位置を毎フレーム保存していきます。ちなみにposはVector3型ですがVector2に代入すると勝手にzが消されるので好都合です。仮に曲線を描いたとしても、あるフレームとその次のフレームのマウスの位置は直線です。この「直線の連続」を元に自由曲線な幅のあるMeshを作成していきます。仮にこのドラッグされたポイントがABCDの4点だとして
描いた線に太さが必要なので、点a→点b,点b→点c、点c→点d…のそれぞれの直線に対して直行する長さwidthのvを求めます。
直行するということは90度回転したものになるのでcos90=0,sin90=1なので、xとyを入れ替えて、yに-1をかければ良いだけです。そうして得られたvecを正規化（長さを1に)して、widthをかけてあげたものをドラッグ位置に引いたものと足したものをMeshの頂点として追加していきます。これを順に頂点配列に入れていくと、実際になぞった線に対して、（便宜上）左が0,2,4,6...と偶数番目に入り、右が1,3,5,7...と奇数番目に入ります。Meshとして成り立たせる為にはさらに、1ポリゴンを何番目の頂点で構成するか。が必要になります。これをindexやindicesと呼びます。通常はtriangles（三角形）の集まりとしてindexを設定していくんですが、MeshクラスのSetIndicesのパラメータにMeshTopology.Quads(四角形）というのがあったので試しに使ってみたところ上手く行ったので今回はそれを使っています。このindexには面（昔はFaceって呼んでたね？）として構成したい頂点四つを時計周り(
両面ぽいので逆時計でも良さそう）に指定する必要があります。最初は点a→点b0の四角で0→2→3→1で1つ作成、次は一つずれて点b→点cで、2→4→5→3・・・
とやっていくと、(n+0)→(n+2)→(n+3)→(n+1)で、nを2ずつ増やせば良さそうな事がわかります。あとは、この頂点配列とindex配列をmeshにセットするだけです。これでMeshは作成されました。次に、このMeshにピッタリハマるColliderを付ける必要があります。
前述の通り曲線も細かい多角形でしかないのでPolygonCollider2Dというのが使えそうです。このPolygonColliderに用意されているSetPathメソッドで構成する頂点を渡すことが出来るのですが、この頂点の渡し方が多角形をぐるりと一筆書きでなぞる形式である必要があります。なので、（仮に）作ったMeshの左下側からスタートして、右上側から返ってくる一筆書きを考えると0,2,4,6,8,10...と偶数が小さい順で通り、次は帰りで逆に11,9,7,5,3,1と逆に奇数の大きい順で通れば良さそうです。
３．Rigibody2Dを付ける事であとは動きを物理演算に委譲する。
は見たままなので特に解説ありません。
強いて言うなら
rigibody.useAutoMass = true;
とすることで、Objectの重さを自動計算しているので、小さいオブジェクトは軽く、大きい（長くなぞった）オブジェクトは重くなっています。それらを踏まえて、無理やり１クラスにまとめたコードが以下になります。１クラスに収める為にAddComponentしまくったりと無理がありますが、普通に作るならある程度ComponentをアタッチしたPrefabを作っておいて、InstantiateしてからMeshを生成したほうが筋が良いと思います。明らかにMesh生成に無駄があります。（毎回vertices,indicesを作る必要は無いはず）マジックナンバー多いね冒頭に置いたサンプルのprojectは
https://github.com/divide-by-zero/UnityPhysixGameSample
に置きましたので興味がある方はどうぞ。


