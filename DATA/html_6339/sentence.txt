More than 3 years have passed since last update.UnityのWebGL出力に簡単に無料でグローバルランキングを実装できる仕組みを考えてみた の続きになります。GoogleSpreadSheetをバックエンドに使うことでWebGLでもそこそこ簡単・無料にランキング処理を実装してみるという試みです。そのために作ったんですが、当の本人がまだランキングを実装しているサンプルを作っていないという体たらく・・・。というわけで、作りました。https://github.com/divide-by-zero/GSSA
の
Samples/Complete/Sample2_2mu2mu
になります。
※SpreadSheetSettingのSpreadSheetUrlは自分のSpreadSheetのURLを貼ってくださいね。実際に動くデモとしてはhttps://unityroom.com/games/line2mu2mu になります。既にローカルではハイスコア保持できている！
ぐらいの状態からなら・・・。　2～30分でグローバルランキングができるんじゃないかと思います。GameMain.csの50行目～ private IEnumerator ScoreSendIterator()が送信処理（＋送信中のステータス表示や、ボタンの有効・無効処理）です。この処理はIEnumeratorな事からも推測できる通り、StartCoroutineで呼び出される事前提にしてあります。毎回バックエンドに登録されているハイスコアと今回のスコア突き合わしてもよいですが、通信の無駄（だし、そもそものアクセスが遅いのであまりやってられないと思う）なので、ハイスコアが更新されていると判断したときに限りハイスコアデータを送信しています。また、その際に何も考えずにSaveAsyncしていくと、一人のユーザーが100回ハイスコア更新したらデータが100出来てしまいます。
時にそういう形式が望ましい場合もありますが、今回は微妙なユーザー管理（風）に同一ユーザーと分かった場合はバックエンドのデータは新規追加じゃなくて更新にしています。　以下、該当ソースなお、同一ユーザーかどうかのチェックにidに入れてあるSpreadSheetSetting.Instance.UniqueIDを使っています。
前回記事にも書きましたが、これはguidを保存してあるだけなので、もっと良い手があるならそれを送信すればよいです。
ただ、WebGLではSystemInfo.deviceUniqueIdentifierもnullが返ってきますし、端末のmacアドレスを取得～なんてのもうまくいかなさそうなので（やってませんが）これくらいゆるくてもなんだかWebGLなら許される気がしています。WebGLの不思議。また、作り方次第ではあるんですが、CoroutineでSave処理を走らせている間にシーン遷移が走ったりして、元のGameObjectが破棄されたりすると、Coroutineは終了してしまいます。
そのため、ハイスコアを出してもすぐRetryしてしまうと（今回のサンプルは自分自身のシーンを再読み込みする形式なので）ちゃんとスコアが登録されなかったりします。
そうならないよう、スコア登録が終わるまでリトライボタンを無効化するなどの涙ぐましい小細工等もしています。さて。これで、ユーザー毎のハイスコア送信管理が出来ました。次に上位スコアとライバル（自分のスコアの近傍）の取得をします。
実際に取得、表示をしているのはLeaderBoard.csの23行目～private IEnumerator _LoadLeaderBoardIterator(int hiscore)になります。まず、単純にTOP5を取るのは簡単で、この部分です。複数行に渡って以下のように書いてもよいですが、メソッドチェイン方式で書いたほうが簡潔で見やすい場合もあるで好き好きで。そして今回はユーザー名などは送っていないので、どれが自分のスコアかよくわかりません。
そのため自分のスコアだけは赤くしたいと思います。
これは、uguiのTextにはRitchTextという概念があり、HTMLの様に決められたタグで挟むことでフォントサイズや色を設定する事ができるので簡単に出来ます。これで、TOP5の表示。かつ自分のスコアを目立たせる工夫が出来ました。
しかし、自分が必ずTOP5にいるとは限りません。　しかし、ランク外だとしても自分のスコアが惜しいのか、それとも全然足りていないのかを知るために、ライバル（自分のスコアの近傍だけ表示）を作ります。
しかし、「自分のスコアの近辺のランキング情報だけくれ」なんて都合のいいメソッドは用意してないので、1手間必要になります。まず、自分の順位を知りませう。ただ、スコアの順位を知りたいだけなら、rankに1足した値が順位になります(1位のスコアは自分より高いスコアが無い＝0が返却されるので）例えば、このrank分だけ単純にSkipをしてあげると、自分のスコアが先頭になって、5人分表示ができます。
では、5人分表示の中、自分のスコアが中心（上から3番目、下から3番目）に来るようにするためには、そう。-2をする必要があるんですね。なので、実際にライバルランクを取得するQueryはとなっています。非常に細かいところなんですが、このスコアアップロード処理やランキングデータのダウンロード処理の進捗を画面に表示するのが意外と大事です。
人は2秒でも画面が止まっていると不具合に思うもんです。特に、このGoogleSpreadSheetのバックエンドは性質上ものすごく速度が出ないです。
ただでさえ遅いのにライバルランク取得のように2回サーバーに情報取得が走ってたりするとより顕著に遅さが際立つので、通信中は画面に「通信中」と出すだけでも良いですし、ちょっと凝った感じで画面中心にくるくるするエフェクトを置くなど、ともかく工夫が必要になります。
細部にこそ神は宿るので気を付けてみるとよいと思います。　ではでは。


