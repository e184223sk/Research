More than 3 years have passed since last update.外部モジュールの静的メソッドを呼んでいるメソッドを, 単体テスト可能にする.この記事は, C#入門者向けなので, C#の言語仕様自体の説明も入る...かもしれない.次のようなコードがあるとする.
テスト対象のSampleMethodメソッドは, 何か処理した後, 液晶画面に"Hello World!"と出力するだけの, しょうもないメソッドである.このコードはPC上じゃなくて, 液晶画面が付属している特別なハードウェア(以降, "実機"と呼ぶ)上で動作させるものとする.
(イメージはMindstorm-EV3.)
ここで, LcdConsole.WriteLineメソッドは, System.Console.WriteLineみたいな感じで, string型の引数を1つとり, 液晶画面に文字列を出力する静的メソッドである. 戻り値は無いとする.このSampleMethodメソッドのテストを作成し, CIツール(Travis CIとかAppVeyorとか)で自動テストさせたい.
でも, CIツールの環境では, 液晶画面がないのでLcdConsole.WriteLineメソッドは動作しない.
しょうもないメソッドにも関わらず, 単体テストをするにはひと工夫いるようだ.以降で, LcdConsole.WriteLineをスタブメソッドに置き換えて, SampleMethodをテストできるようにしてみる.スタブメソッドに置き換える方法を説明する前に, "メソッドを格納できる型"について説明する. (デリゲートという)
C#では, 変数に値やクラスだけでなく, メソッドも格納することができる.
そのような変数の型として, .NetではSystem.Action型やSystem.Func型が用意されている.こんな感じで, いろんなAction型とFunc型が存在する.
delegateについては詳しく説明しないが, ようは"メソッドを格納できる型"を表す.
例を次に示す.Func&lt;int, int, int&gt;型は, int型の引数を2つとり, int型の戻り値を返すメソッドを格納できる.
そのFunc&lt;int, int, int&gt;型の変数calculateMethodに, addメソッドやsubメソッドを格納している.
格納したメソッドを実行するには, その変数名を使って, calculateMethod(a, b)のように書く.スタブを使ってメソッドをテストするときには, そのメソッドのコードはそのままで, 呼ばれるメソッドを変更できるようにする必要がある.
つまり, LcdConsole.WriteLine("Hello World!");と書いてはダメだ.
これだとどう頑張ってもLcdConsoleクラスのWriteLineメソッドが呼ばれてしまう.ここで, 前節で述べた"メソッドを格納できる変数"に注目する.
前節で挙げた例にもあるように, そのような変数を使うと, 異なるメソッドを同じ記述で実行することができる.早速, LcdConsole.WriteLineメソッドを, 変数を通して呼ぶようにしてみよう.LcdConsole.WriteLineメソッドを直接呼ぶ代わりに, 変数LcdConsoleWriteLineを用意して, その変数を通してメソッドを呼んでいる.
変数の型はAction&lt;string&gt;型である.
これは前節で述べたように, "string型の引数を1つ取り戻り値が無いメソッドを格納できる型"である.
すなわち, LcdConsole.WriteLineメソッドを格納することができる.では, 実際にSampleMethodのテストで, スタブメソッドに入れ替えてみよう.
テストコードを次に示す. テストフレームワークはMSTestである.SampleMethodを実行する前に, 変数LcdConsoleWriteLineにWriteLineStubを格納して, 動作を変更している.
ここでは, 実機上でしか動作しないLcdConsole.WriteLineメソッドの代わりに, テスト環境で実行しても問題の無いWriteLineStubメソッドに入れ替えている.これで, テストの時だけLcdConsole.WriteLineメソッドの代わりにWriteLineStubメソッドを実行させることができ, CIツールでの単体テストが可能となる.ここまでで, 当初の目的は達成できた.
ここからは, コードのさらなる改善を検討する.今, メソッドを格納する変数LcdConsoleWriteLineは, インスタンスフィールドとしてSampleClassが持っている.
これにより, 次のような気になる点がある.というわけで, 変数の持ち方を見直してみる.
staticな変数として, SampleClass以外が持つことにする.SampleMethodメソッドの中身は, 次のようになるだろう.もともとの, LcdConsole.WriteLine("Hello World!");という書き方に近くなった.
このメソッドのテストコードは次のようになる.さて, 前節でコードが少し改善され, もともとのLcdConsole.WriteLineメソッドと同じように静的メソッドで文字列表示ができるようになった.
しかし, staticにしたがゆえに, 注意しなければならない点もある.例えば, 次のように, 新たなテストコードを追加したとする.今度はテストメソッドが2つある.
ここで, SampleMethodTestの次にSampleMethodTest2が実行された場合を考える.
静的な変数ということは, SampleMethodTestが終わっても, 変数の値はそのままということである.
そのため, SampleMethodTest2が始まった時点で, 変数LcdConsoleWrapper.WriteLineの値はスタブメソッドに入れ替わった状態である.テストは次のことに気を付けて書くべきである.今回は, 実機でしか動かないメソッドを, "何もしない"スタブメソッドに入れ替えているだけなので, そのままの状態で別のテストを実行しても問題はないかもしれない.
しかし, 問題のあるケースもある.
例えば, bool型を返すメソッドを"必ずfalseを返す"スタブメソッドに入れ替えたままにすると, 別のテストがうまく通らなくなってしまうかもしれない.というわけで, 次のように修正する.これで, Actが終わったときに, LcdConsoleWrapper.WriteLineがもとのメソッドに戻るようになる.これまでの説明でできたコードには, まだまだ気になる箇所がある.これらは,などを用いて改善できる.
とても記事が長くなった &amp; ちょっと記事の概要からずれてきたので省略する(気が向けばまた記事を書くかもしれない)が, 最終的にコードは次のようになる.テスト対象のコードは変わらず,そしてテストコードは,となる.おしまい.


