More than 3 years have passed since last update.今回は、前回のジェネリクスの続きなのですが、自分がある師匠が書いてくれたプログラムを理解するためのポストです。具体的には C# のリフレクションを使ったアプリを作ります。今回のお題は、リモート（本当は Azure KeyVault) にあるシークレットを取ってきて特定のクラスに格納するというものです。ただし、格納する先のクラスは、どんな属性があるかはまちまちです。こういう時は、クラスのメソッドの一覧をとってきたり、文字列から、メソッドを実行したり、クラスのインスタンスを生成できたりするリフレクションが有効です。リモートから、アクセスする先のデータは、今は Dictionary で表現しておきます。そして、それを Foo クラスに詰めるための、コードはこんな感じ。これは師匠の考えてくれたインターフェイスです。こんな感じで型を指定したら、型の情報（メソッド名）を元に、それに該当する値を詰めてくれるというメソッドです。凄くカッコいいしシンプルですね。ポイントは、最初に、前回やった、ジェネリクスで、型を指定できるようにしています。where で、Tに指定できる型は、引数なしのコンストラクタを持ったものに決定されています。まず、T の型情報を取ってきて、そのGetProperties を取得して、プロパティの一覧をとってきています。インテリセンスに聞いてみると、メソッドやコンストラクタなどクラスのメタ情報がいろいろ取れます。通常、ジェネリクスの型はインスタンス化したり、メソッドを読んだりできませんが、where を書いておけば一部可能です。ここでは、引数なしのコンストラクタがあることを、T の条件にしています。ハイライトですが、SetValue メソッドで、オブジェクトに値をセットしていきます。値を代入したい先のオブジェクトのメソッドではなく、System.Reflection.Propertyinfo のメソッドであることがポイントです。該当のメソッドのメタ情報を表すインスタンスのSetValue で、値をセットしたい先のインスタンス, 設定する値　をセットしています。実行結果は予想通りうまくいっています。ただ、これだと、問題があります。例えば、Foo に、本当はデータの移送に関係ない型があったらどうなるでしょう？ こんな感じで違う型のメソッドを書くと、コンパイル時はOKですが実行時にエラーになります。実行結果エラーになります。このコードのは、ディクショナリにそんなものはないからです。たとえあっても、型が違えばエラーになります。そんな時は、何らかのロジックで、Property を書くときに、制限してあげればいいことになります。師匠が書いてくれたフィルタのコードです。プロパティを、インスタンスタイプで、Public のもの。読み書きができるもので、string の型に限定しています。こう変えれば、先ほどのメソッドは、int なのでフィルタにかかり、不要なメソッドが実行されませんので、無事うまく実行されます。ともかく、師匠の書いたコードは理解できるようになったので、本番コードにこれから挑んでみます。実際のものは、Async の呼び出しがあるので、Async のコードなので、おそらく、直列で await してしまう問題が出ると思うのでそのあたり対処してがんばってみます。


