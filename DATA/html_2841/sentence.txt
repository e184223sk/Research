　こんな感じの仕組みを作りたい。
　こういうのが出来たら、変更できる部分と変更できない部分が明確に変えられるので、インタフェースの線引きをするのに重宝しそうです。Qiitaでは連載記事１０件以下とマイナーなAutoMapperですが、世界を見渡すとよく使われていて、定期的にアップデートされています。
今後、.NET ASP Core 6/8へのLTS移行に向けてもメンテナンスは長く行われるでしょう。Windows固有コードはないはずなので、Mac, Linuxでも可能なはず。
そう考えると、Visual StudioをIDEとして使う環境としては、(現在も十分広まっていますが)今後より活躍するライブラリだと思います不人気な理由としては、ASP.NET専用のライブラリだと思われているからというのが大きいと思います。
確かに、MicrosoftとしてはASP .NETに向けて開発する方向性を示していますが、これ以外の環境でも十分に活躍できるライブラリだと思います。　例えば、こんなクラスがあったとして・・・と新たな中間クラスと出力クラスを定義して、と書くわけですが、こんなん書いてたらコード量も増えるし、面倒すぎる！
sample_objとinternal_sample_objがごっちゃになるのも美しくありません。こんなことするくらいなら、SampleStructOutをstructではなく、classにして定義して、IdとFlavorの両方を消して、SampleClassも使わずに、として素直に書きますよねｗ　けれど、こうしてしまうと、DateはInとOutでダブるし、SampleStructInとSampleStructOutを両方管理しないといけないしで、Update以外のメソッドが美しくないコードになるわけです。この課題をAutoMapperで解決します。nugetマネージャーコンソールでと入力してダウンロードします。こんな感じでクラスを構成しておきます。ポイントは、BaseClassのところで、Tに変換前のクラスを定義することがポイントです。このSourceには、SampleStructInの内容が入るので、この部分でgetterのみという定義が可能になります。中間クラスSampleClassは次のように定義します。　こうしてしまえば、IdやFlavorNameはgetterとして定義され、内部メソッドに渡しても変更される危険性が低くなります。低くなります、と言っているのは、クラス内部からは一応Sourceとして変えられてしまうので、メソッドを定義した場合はSource変更に対してSafeな処理に必要があります。Profileというクラスを継承して、新たにコンストラクタを定義します。この中に、CreateMapを定義して、変換前と変換後の関係を定義します。途中にForMember、AfterMapという表記がありまして、これがSourceのgetterを完全にやるためのポイントです。ForMemberと書くことで、変換後にSampleStructInをSampleClassに代入しています。AfterMapと書くことで、型変換の処理を終了したときの処理を書いていて、それ以降にSourceを設定しようとしたらInvalidOperationExceptionを出力するようにしています。したがって、外部からはSourceを書き換えることが出来ません。 SampleStructInが値クラスなので、getterを使って操作することも出来ない状態です。とりあえずコンソールアプリで、次のように書きますコンソールアプリで実行して可能なので、automapperさえあればどのようなC#の開発環境でも実行できるのがポイントですね。出力結果：

Vanilla
Saturday
　上記のようなコードにすれば、struct_inに対して、struct_outは「DayOfWeekだけが増えている」ものとして受け入れることが出来ます。これは非常に管理しやすいもので、「メソッドを実行した前」「メソッドを実行した後」というオブジェクトになっていますので、
　上位の最終的な処理はstruct_outのみを使って管理する、みたいなことが出来るようになります。　LINQ(List)とも簡単に連携できます。
　そういう意味では、きちっと型定義してくれるのってすごくいいなと思いました。　(Dictionaryでも試したいけど、今回はやっていません)IEnumerableで書いてますが、ListでもArrayListでも構いません。IEnumerableで書く最大の特徴は、入力側からの変更が発生しないことですね。NumberOfResponseが追加されるItemsのDayOfWeekが追加されるItemsのDateが変更されるこのくらいになってくると、実際の開発でも想定される話になると思います。LINQでのジェネリクス内のクラスの内部の変数を変更したいというのは普通にあると思うので。日付や数がちゃんと入っていることが示されました。


