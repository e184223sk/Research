More than 1 year has passed since last update.以前、こんな記事を書いたことがあります。
色々な方法でWindowsのGUIの自動操作を行う方法を記載しましたが、PowerShellで画像認識を利用した自動操作については逃げました。今回は宿題として残っていたPowerShellとOpenCVを使用して画像認識での自動操作を行ってみます。考え方としてはスクリーンキャプチャした内容をMatに変換してTemplate Matchingを行うだけです。OpenCVには.NET用のラッパーとしてOpenCvSharpが存在します。
https://github.com/shimat/opencvsharp/releasesこのライブラリをNugetまたは上記のページからダウンロードしてください。
注意点として、ネイティブのDLLを使うことになるので32bit、64bitのどちらのプロセスで動作しているか、意識してDLLを利用してください。VisualStudio 2019の.NET Framework4.0で作成したサンプルは以下のようになります。このサンプルはスクリーン上に存在するtarget.bmpの画像を検索してクリックするものとなっています。
やっている内容としてはOpenCvのチュートリアルのTemplate Matchingと似たようなことです。
MatchTemplateは複数の類似画像の位置を取得できるようにFloodFillを実施してループしていますが、常に最も一致した画像だけを取得するならループは不要です。あとは、取得した位置をもとにマウスを移動してクリックしています。
なお、マルチディスプレイを考慮しているので、ClickImgのScreenNoを変更することで別のスクリーンを検索することが可能です。スクリーン上の画像の取得は.NETのよくあるキャプチャ処理で、取得したBitmapオブジェクトはOpenCvSharp.Extensions.BitmapConverter.ToMatで行っています。OpenCvSharpは.NET2.0でも動作するのですが、どうも.NET2.0ではOpenCvSharp.Extensions.dllを提供していないようです。
自前でBitmapConvert.csと同様な処理を実装すればできるかもしれませんが、.NET3.5までは簡単にできましたが、.NET2.0ではうまくいきませんでした。Windows10 Home + PowerShell5.1でもC#と同様のことが行えます。まず、DLLを以下のように配置します。
OpenCvSharpExtern.dllは使用するPowerShellがx86の場合はx86,x64の場合はx64を使用してください。次に以下のようなスクリプトを記述して実行します。target.bmp
画面の状態
難しいです。
理由として初期状態のWindows7では.NET3.5とPowerShell2.0が入っていますが、このPowerShell2.0はどんな新しい.NET Frameworkが入っていても.NET2.0を使用してしまいます。PowerShellでdllを読み込む際の注意点
https://qiita.com/icoxfog417/items/e0d29bed109071888f19このため、BitmapConvert.csと同様の処理が、うまく実装できませんでした。やるなら、.NET Framework3.5でコマンドラインツールを作成して、PowerShellから呼び出す用な形になると思います（当然、起動時にオーバーヘッドがかかります）画像認識とかいうと難しく考えがちですが、OpenCvを利用すれば、わりと簡単に画像を利用した自動操作を自前でつくれます。
ただし、あまり古すぎる環境だと辛いです。


