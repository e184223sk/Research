More than 1 year has passed since last update.C#のDI Containerはいろいろ (https://github.com/danielpalme/IocPerformance) 存在します。一部のコンテナでは自動DisposeのためにIDisposableインスタンスへの参照が保持(Tracking)され、注意しないとMemoryOverflowExceptionが発生することがあります。Trackingするコンテナとそうでないコンテナを調査してみました。各種DI Containerをできるだけデフォルト状態で調査したところ、以下のようになりました。AutofacとGraceがIDisposableをTrackingするようです。DryIocは２つありますが、DryIocだとどちらの挙動がよいか設定で選択できます。なにも選択しない状態だとIDisposableを実装する型を登録するとエラーが発生し、Trackingするかどうかを指示するように警告されるので、結構親切ですね。なお、調査したときのバージョンは以下のとおりです。ここからは余談ですが、C#アプリでAutofacを使用していたのですが、バッチ処理とかで大量のクラス生成を繰り返す処理を実行すると、アプリ内ではどこからも参照されていないのに、インスタンスが解放されず、OutOfMemoryExceptionが発生する問題に遭遇しました。検索すると以下の記事がヒットします。Autofac holds references to all the disposable components it creates「Autofacは生成したすべてのIDsposableインスタンスへの参照を保持する」ので、以下のようにLifetimeScopeで囲ってあげないとMemoryLeakしてMemoryOverflowExceptionになる。lifetimeScope.Resolve&lt;IMyResource&gt;();をcontainer.Resolve&lt;IMyResource&gt;();と書いてしまうとMemoryLeakになるということですね。Don’t resolve from the root container. Always resolve from and then release a lifetime scope.「常にlifetime scopeからインスタンスを生成し、タスク完了時にscopeをdisposeしなければならない」Autofacの思想としては、大量データの生成、破棄をともなう繰り返し処理はコンテナに依存するようにし、厳密にLifetime管理せよ、ということなのでしょう。Autofacは参照しているIDisposableインスタンスのDispose()を自動で呼び出してくれるようで、それも便利なケースもありそうですね。Autofacより後発のLightInjectではこのようなメモリリークは発生しません。前掲の記事によると、TrackingなDI ContainerとそうでないDI Containerがあるようです。そこで、C#のDI ContainerをTrackingなDI Containerとそれ以外で分類してみました。InnerRunメソッドのスコープ内でResolveしたオブジェクトのFinalizeをcallbackで通知を受け、GC.Collect()後にFinalizeされたかどうかを返します。Finalizeを監視する対象のBaseクラスは以下のようにしました。これを通常のオブジェクト(Normal)とIDisposableを実装したオブジェクトそれぞれに継承させるようにしています。ソースコードはこちらです。.NET Core 2.2で動作確認しました。
https://github.com/youmts/dicontainer-tracking-checker/


