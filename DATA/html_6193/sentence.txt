プログラム間でデータのやり取りする時に、まだまだ CSV を使うことが多くあります。そんな時、c# なら CSVHelper が非常に役立ちます。ただ、バージョンアップのスピードが速く仕様の変更も多いので、現時点での最新版 25.0 でのサンプルを挙げておきます。
参照元は こちら です。Visual Studio のパッケージマネージャーコンソールからインストールします。.NET CLI Console の場合は、シェルでプロジェクトパスに移動し、次のコマンドを実行します。　まずは、クラスマッピングを利用した CSV ファイルの読み込み方です。読み込み対象の CSV ファイルの中身は次の通りです。CSVHelper は、CSV ファイルの先頭行をヘッダとみなし、ヘッダ名から Foo のどのプロパティ名に格納するかを判断します。このため、次のような CSV ファイルでも読み込むことができます。CSVHelper では、ヘッダ名の大文字小文字を区別します。デフォルトは Pascal Case です。もし、Pascal Case でない場合、たとえば全て小文字の場合は、コンフィグで指定することで読み込みが可能になります。config の PrepareHeaderForMatch で ToLower() を仕込んでおくことで、次のような CSV を読み込むことができます。CSV ファイルの１行目にヘッダがない場合は、次のように修正します。　CSVファイルのヘッダと、格納用クラス（例では Foo）のプロパティ名を一致出来ないケースがあると思います。この場合は、格納用クラスのプロパティに属性を設定して指定することが出来ます。この際、CsvHelper.Configuration.Attributes を using で定義しておいてください。
また、Index で指定する場合、初番は 0 ですのでご注意下さい。　以前のバージョンからあった方法で、格納先クラスをベースにマップクラスを定義し、読み込み順序を定義します。サンプルでは、Foo に対応する FooMap を定義しています。
なお、ClassMap クラスは CsvHelper.Configuration に定義されていますので、using で宣言しておきます。　csv.GetRecords() を使うと CSV を丸ごと読み込むことができました。しかし、業務プログラムなんかだと、１行読み込む毎にコンソールに出力したり、チェックをかけたりすることが多いと思います。この場合は、GetRecords() ではなく GetRecord() を使います。　次に配列に格納されたデータを CSV ファイルに出力します。データは records にあるとします。records は Foo クラスの配列です。これを CSV ファイルに出力します。　ヘッダなしの CSV ファイルを読み込む時と同様に、ヘッダを出力しないように config で指定し、WriterRecords()を実行します。　こちらも上の読み込みの時と同様に、格納先クラス「Foo」に属性を指定します。Index 属性だと番号で指定できます。Name 属性だと、ヘッダ名で指定できます。Index 属性の場合のサンプルは次の通りです。　こちらも読み込み時と同様です。ClassMap を使って Mapクラスを定義します。全データを出力するなら Index や Name 属性の方が便利でお勧めです。
　読み込みと書き込みで列の位置が異なるなら、読み込み用のクラスマップと書き込み用のクラスマップを用意することで実現できます。　WriteRecords() だと一気に CSV データを出力できました。行ごとに処理を行う場合は、WriteRecord() を使います。読み込みの場合と同じですね。CSVHelper の Getting Start はここまでです。
 ２種類の列レイアウトのある複雑な CSV を読んだり、データを bool 値として読み込むなど、様々な機能があります。また、読み込んだデータを配列ではなく、DataTable に格納する事もできます。DataTable に格納できれば、そのまま BulkCopy を使って SQL Server のに高速にインポートできます。興味がわいた方は、下のリンクをたどってください。CSVHelper の Example のページ


