More than 3 years have passed since last update.この記事は、Unity 2 Advent Calendar 2016 の10日目の記事です。
9日目の記事は@Marimoiroさんの Unityでテスト用にインスペクタ上にメソッドを実行してくれるボタンを作ろう でした。↓動画（クリックでYoutubeへ）
今回は、AppendStructuredBuffer/ConsumeStructuredBufferを使ったGPUパーティクルのサンプルを作ってみました。
ComputeBuffer.CopyCountは、Unity5.3以前ではバグっていて正常にカウントが取得できなかった為、AppendStructuredBuffer/ConsumeStructuredBufferを使ったGPUパーティクルが作れませんでした。
5.4になってからようやくバグが修正されました。
開発環境は、Unity5.5、Windows10です。
今のところUnityのComputeShaderはMacでは動きません。今回作ったGPUパーティクルのサンプルのプロジェクトはこちらにアップしております。
https://github.com/kaiware007/UnityGPUParticleSampleGPUを使って描画以外に汎用的な処理をさせることができるプログラムです。
GPUを使うメリットは、大量のデータを並列で高速に処理できるところにあります。
ComputeShaderの詳細は、下記の記事が非常に分かりやすかったです。
Unity : ComputeShader のシンプルなサンプル(1)ComputeBufferとは、ざっくりいうとGPU上に置けるデータの配列です。
いろんな型が指定でき、intやfloatだけじゃなく自作の構造体も指定できます。
通常のComputeBufferは、RWStructuredBuffer(RWはReadWriteの略)などとして使う事が多いと思います。
AppendStructuredBufferは、Append()関数で末尾にデータを追加できます。逆に言うと追加しか出来ません。
ConsumeStructuredBufferは、Consume()関数で末尾からデータを取り出すことが出来ます。逆に言うと取り出すことしか出来ません。
同じComputeBufferをAppendStructuredBufferとConsumeStructuredBufferで指定することで、LIFOとして使うことが出来ます。今回のGPUパーティクルは、前述のAppendStructuredBufferとConsumeStructuredBufferを使ってパーティクルの生死を管理しています。
無効になったパーティクルのインデックスをAppendStructuredBufferに追加、パーティクルを発生させるときはConsumeStreucturedBufferから取得して使います。
画面上でマウスをクリックした位置にパーティクルを生成されます。
パーティクルは、一度に256個ずつ放出されます。
放出されたパーティクルは、移動しながら暗くなって行き、10秒で完全に見えなくなって消えます。同一のものをComputeShaderやレンダリング用のShaderにも定義します。THREAD_NUM_XはComputeShaderのスレッド数と同じ値です。InitParticle()の中身は下記です。
ComputeShader側で初期化しています。終了時にComputeBufferを明示的に解放しないとリークします。ComputeBufer.FindKernelで検索されるカーネルIDは上述の順番0,1,2という感じで返ってきます。C# のコードと同じ構造になっています。
Vector3がfloat3、Colorがfloat4など微妙に型が変わってますがデータのバイト数的には同じです。_Particlesが、パーティクルデータの構造体配列になっています。
_DeadListと_ParticlePoolは、それぞれAppend～とConsume～のバッファですが、同一のComputeBufferを参照しています。
uintなのは、_Particlesのインデックスを保持するためです。THREAD_NUM_Xはnumthreadsの値として使ってます。C#側でも同じ値にしています。
numthreadsの数分並列に処理が走るため、パーティクルの総数をTHREAD_NUM_Xの倍数にすることで処理されない余りが発生しないようにしています。レンダリング用のShaderでComputeBufferを使うときは、を定義します。こちらでもパーティクルデータの構造体の定義が必要です。
面倒くさい場合は.cgincなどでまとめてincludeするといいかも？こちらのパーティクルデータは、Readのみなので通常のStreucturedBufferとして定義しています。ComputeBufferのパーティクルデータの数が頂点数として頂点シェーダーに流れてきます。
頂点シェーダでは、SV_VertexIDから頂点インデックスを受け取るようにしています。
それをパーティクルデータのインデックスとしてそのまま使っています。
有効フラグが立っていないパーティクルは、サイズを０にして描画処理は走っているけど実質見えないようにしています。頂点シェーダからのデータはただの頂点なので、頂点座標の周囲に頂点を追加してビルボードを作成します。Unity : ComputeShader のシンプルなサンプル(1)
[Unity]コンピュートシェーダ(GPGPU)で1万個のパーティクルを動かす
Unity で Compute Shader を使ったスクリーンスペース衝突有りの GPU パーティクルを作ってみた


