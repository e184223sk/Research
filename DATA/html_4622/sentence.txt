More than 1 year has passed since last update.ざっくりと説明すると「アプリ外部から素材などをダウンロード〜ロードする仕組み」+「ロードする素材群をパック（まとめる）するための仕組み」です。アプリ内部に一部リソースを持たなくていいためなんらかの事情でパッケージ導入がダメな人はここから一緒に頑張りましょう（悲しみ）AssetBundleで最低限必要なこととしてはだと思います。AssetBundle のDownload ~ Unload までの流れはCEDECの講演でとてもわかりやすく解説されているのでぜひ見て見てください。
https://creator.game.cyberagent.co.jp/?p=4791これらが出来た上で実装したい項目としてはあたりが候補として上がってくると思います。最低限必要な「Download」「Cache管理」「Load」を踏まえると、フローとしては以下のような感じになります。
Downloadといっても「ManifestのDownload」と「AssetBundleのDownload」とでは少し話（やコード）が変わってくるので順を追って説明していきます。AssetBundleを使うためにも、その情報が記載されているManifestが無いと始まりません。
Manifestに関しては特に制約とかが無いのでUnityWebRequest.GetAssetBundle()　でとってくればOKです。一方AssetBundleに関してはこんな感じUnity にCachingクラス というものがありますが、2015年頃まではUniteのコロプラさんセッションで話題になっていたUnityのCacheシステムは運用系のゲームではとてもじゃないですが使いづらかった状態でした。（数万AssetがあるとisReady がいつまでもReady になってくれなかったり、Cacheの削除は全削除しかできない→全Assetの再ダウンロードを強要してしまうなど）
しかし2017 からは、UnityWebRequestを使うとAssetBundleに関しては自動的にCache 管理をしてくれるという魔法の仕組みがAPIでは提供されていたり、個別削除APIが追加されたりして、こちらをはじめ、様々なブログ等でUnity2017で「Caching周りが改善された」という記事をよく目にしました。
当時は自分も「やったぜ」と思っていましたが、検証を行なった結果、怒りで頭がおかしくなりそうでした。
そうです。「Cachingシステムがまともに動作していない」 のです。
（ちゃんと個別削除APIとか動いてますよという方は報告いただけると嬉しいです。）APIを叩くもののCacheファイルはいつまでたっても削除されず、削除は全削除しか出来ないので１個ファイルに更新があるたびに全AssetBundleの落とし直しを余儀なくされます。ということでCachingに関しては using System.IO; して普通にファイル操作を行わないとダメ(つまり自前で実装する)です。@k7a さんから情報を頂き再度検証を行いました。
基本的には k7a さんの記事 [Unity 2018.2] AssetBundleのキャッシュを完全に理解する で記載の通りでした。（k7aさん、情報提供ありがとうございます）
※検証環境：Unity2018.4.8f1 自動キャッシュ, 削除に関しては CachedAssetBundle 経由で行うこと（もしくは同等の値を直接設定）で動作の確認が取れました。ただし、検証の結果Caching.IsVersionCached に関しては動作に問題がありました。
いつの間にか公式リファレンス がobsolete になっていた 通りで、CachedAssetBundle.name, CachedAssetBundle.hash の組み合わせでも uri, hash128 の組み合わせそれぞれのパターンで応答を見た所、Cacheされているにも関わらずIsVersionCached が常にfalse を返していました。対象のAssetBundleがCacheされているかどうかは現状知るすべが無いという感じですね。
（何かご存知の方は教えていただけますと助かります。）削除機能を実装するならこんな感じになるかと思います。Saveに関してはFile.WriteAllBytes とかFileStreamを使って書き出せばOK。
LoadはAssetBundleクラスのLoadFromFileAsyncメソッドを使えばOK。AssetBundle のロード処理は少し厄介です。
というのも同一のAssetBundleを２回ロードしようとするとエラーになります。
なのでロードリクエストはしっかり自前で管理しないと簡単にロードリクエストが重複してエラーになって進行不能になったり・・・よって
- ロード済みのAssetBundleは需要がなくなるまでは保持していた方がいい
- ロードが重複しないようにリクエストをしっかり管理することが大事になってきます。迂闊に破棄をしてしまうと、同一フレームの後続の処理でロードしようとすると死んだりするので、
「完全に需要がなくなったタイミングで破棄」するのが退治になります。
なので、自前で参照カウントを管理して、参照カウントが0になったタイミングで破棄してあげればOK。こんな感じでAssetBundleを管理するクラスを作って、管理Unity謹製ツールのAssetBundleBrowserの導入を強くオススメします。リンクのGithubから落としてくるか、UnityPackageManagerからDLで導入出来ます。
ただ、導入するときはEditor以下のみで、それ以外は削除してしまった方がいいです。
特にTest以下のコードは不要なのとusing Boo.Lang.Runtime; という見たく無いコードが紛れてビルドがこけたりするので要注意です（Unityさん、メンテお願いします）導入メリットとしてはなど色々とメリットがあるので非常にオススメです。基本的にはBuildPipeline.BuildAssetBundle を叩いてあげれば一応はAssetBundleは焼けます。また、Manifestをちゃんと読み込めれば「更新のあったアセットのみビルド」が行われるインクリメンタルビルドが行われるので、ビルド時間の短縮も自動的にやってくれます。ここに関しては割と運用スタイルによって異なってくるので割愛します。@midnightSuyama さんのApple規約解説記事（いつもお世話になってます）でも紹介されている通り、追加リソースのダウンロード時にダウンロードサイズを明記する必要がでました。If your app needs to download additional resources, disclose the size of the download and prompt users before doing so. Existing apps must comply with this guideline in any update submitted after January 1, 2019.WTF!!
既存アプリは対応猶予期間がありますが、新規アプリはマスト対応です。
はい。Unityの既存の機能じゃどうしようもありません。AssetBundleManifestには「Bundle名」「依存関係」の情報があるので、ここに「サイズ」を追加できると嬉しいですね。方針としては
- AssetBundleManifest にサイズの項目を追加して読めるようにする
- 独自Manifestを作成して対応するになります。データを加工したAssetBundleManifestを読むのは技術的に辛かったので、独自マニフェスト実装に逃げましたをすることにしました。というワークフローになります。個人的にはShellScriptがいいのですが、たまたま他の人から反発を受けたので他を検討したところ
こちら を見つけてしまったため、「あ、Pythonならクッソ簡単に行けそう」と判断してPythonで実装していくことにしました。早速homebrew でpython3, pip, PyYAML を入れて環境を設定します。正直python を書くのって指で数える程度しか無いですが、こんな感じで生成しました基本的にはAssetBundleManifestで実装しているAPIを作りつつ、サイズを返すAPIを生やしていきます。
Interface 的には以下のような感じで実装していけば問題ないはずです。実際に作って遭遇した問題などを書いていきます非同期でロードリクエストを出す際、コールバックが呼ばれる前に呼び出し側がDestroyされるパターンがあり、それでエラーになることが頻発したので、リクエスト発行時にハンドラを返して、呼び出し元がDestroyされるときに、ハンドラを介してコールバックを実行させないように制御しないとダメでした。Unity2018.2 〜が使えるなら頑張ってAdressable Assetsを使って見た方が今後のためにも良いと思います。
出来ることなら、もう2度と作りたくないですね（白目


