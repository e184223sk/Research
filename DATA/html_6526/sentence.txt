More than 3 years have passed since last update.今までなんとな～くでやれてきちゃったけど、とうとう逃げられなくなって明日までにデリゲートとイベントハンドラ使えるようにしなきゃいかん！という人向けの、復習記事です。
こいつらのポイントを理解して、
①何故コードが動かないのか
②どうしたらコードが動くようになるのか
上記二点の仮説を立てられる位になることを目指します。・今までイベントハンドラやる機会なかったけど、明日やらなきゃいけなくなった
・イベント周りの処理よくわかってないけど動くからいいや～って気持ちでいたら、とうとう何やっても動かなくなった
・全部気合で乗り切ってきたけど、気合だけでは乗り切れなくなった
そんなあなたのための記事です。delegate：委譲、譲渡
用語の意味なんかどうでもいいですね。
デリゲートは、メソッドをオブジェクトの一種として使うことができる機能です。この時、同じ型と引数を持つメソッドをいくつでも、このデリゲートの中に入れ込むことができます。コンソールに表示される文字列　3よくあるC#基礎の本「これでデリゲートが使えるぞ！よくわかったか？」
私「わからねえ」
よくあるC#基礎の本「はい」これは持論なんですけど、本で学習するだけでは、使い所がピンとこないからだと思ってます。
と、いうわけで今回はデリゲートの使いどころとして2つあげました。
①データ処理の汎用化
②イベント発生時に特定の処理を行うため、イベントハンドラに渡す①の場合は、ネックになるのはデリゲートだけだと思うので、多分気合で何とかなります。※ならなかったらすいません
問題は②です。こっちはデリゲートに加えてイベント処理も入ってくるのでもう何が何やら。
それこそ、何がわからないのかもわからない状態。
のでここではデリゲートは同じ戻り値の型/同じ引数の型を持つメソッドを代入できるという所だけ押さえて、次のイベントハンドラに移りましょう！event handler：イベントを取り扱うもの
私は言葉から入りたい人なのでスルーしてください。
イベントハンドラとは、イベントが発生した時に行う処理のことです。
イベントハンドラに処理を渡すときは、先に出てきたデリゲートを渡してやります。
するとそのイベントが発生したときに、デリゲートで渡した処理が勝手に走ってくれます。すご～い！①今すぐVisual Studio立ち上げてWindowsフォームアプリケーションを新規作成してください
②Form1の適当なところをダブルクリックしてください
③自動生成されたメソッド右クリックしてすべての参照を確認してください
④今のcsファイルじゃない方（Designer.cs）に行ってください
はい！そこにあるのがイベントハンドラです！おめでとう！なんででしょうね～、というわけで、イベントハンドラの定義を見てみましょう。そう！イベントハンドラの本質はデリゲートなんですね！
先に出てきたポイントの通り、デリゲートは同じ戻り値の型/同じ引数の型を持つメソッドを代入できるので、イベントハンドラと同様の型のメソッド作って、それを代入すればイベント発生時にその処理を実行してくれるというわけです。よくわかったかな？わかったら天才です！
明日は上司に100回褒められることでしょう。おめでとう！
ぶっちゃけWindows Formを軽くいじるくらいなら、これくらいの知識で十分だと思います。
例えば、10個のボタンを押したときに、似たような処理をさせたいとか。
電卓アプリ作成なんかにはありがちですね。
でも違うんだ！これは仕事なんだ！電卓作成なんてそんな生ぬるいもんじゃねえんだよ！という方。握手。
というわけで、そんな上っ面じゃどうしようもない人向けにもう少し詳しく見ていきましょう。正直いまだにはっきりわかってません。助けてくれ。このobject senderとEventArgs eです。みんな大好きMSDNを見てみると「イベントのソース」と出てきます。はぁ。
更に読み進めると「イベントを発生させるインスタンスを参照します」とも出てきます。はぁ。
色々なブログを読み漁ると、どうやらイベントの発生元のコントロールオブジェクトが格納されているようです。例えば、ボタンクリックイベントが発生した場合、発生元のボタンコントロールが入ります。
フォームクローズイベントが発生した場合、発生元のフォームコントロールが入ります。
そんな感じ。ここでもやっぱりMSDN。「イベント データを格納している」「型 EventArgs から派生し、イベント データを保持します」はぁ…。
またもや検索しまくると、どうやらこっちは補足情報のようで…。うーん。よくわからないので自分でも確認してみました。結果

一つ目の引数に、イベントの発生元コントロールが入るのは本当のようです。
二つ目の引数はFormClosedEventArgsですね。
発生したイベントの情報が入るというのは、発生したイベントが、EventArgsクラスを継承したクラスのインスタンスが入ってくるようです。
EventArgsクラス：https://msdn.microsoft.com/ja-jp/library/system.eventargs(v=vs.90).aspxつまり、コード上でイベントを無理くり発生させたいなら、上記のものたちを引数として渡せば、イベント発生させられるのでは…？仮説がたったなら、実際にやってみましょう。結果
フォーム閉じる時の処理を呼び出せました！わーい！
ちなみに、これだけではフォーム閉じません。
ので、閉じるボタンとか押すとまたダイアログ開きます。楽しい。
なんとなくイベントハンドラに使われている引数の正体がわかりました。
一つ目の引数は、イベントの発生元コントロールが入る。
二つ目の引数は発生したイベントの情報が入る。その情報というのはEventArgsクラスを継承したクラスのインスタンスである。デリゲートとは同じ戻り値の型/同じ引数の型を持つメソッドを代入できるもの。
イベントハンドラとはデリゲートの一種でありイベントが発生した時に行う処理のこと。
Visual Studioで自動生成されたコード
引数の一つ目にはイベントの発生元コントロール
二つ目には、発生したイベントの情報が入る
その情報というのはEventArgsクラスを継承したクラスのインスタンスであるもしエラーが出る場合は
①デリゲートに入れるメソッドの型は、デリゲートの型と一致しているか？
②イベントハンドラの引数に、イベント発生元のコントロールオブジェクトが入っているか？
③発生したイベント情報（EventArgsクラスを継承したクラス）は意図していたイベント情報になっているか？
このあたりをチェックしてみてください。デリゲートとイベントハンドラの復習はできたでしょうか？
実は私が何に詰まっていたかというと、Timerクラスを使って定期的なイベントを発生させるところでした。なんかうまくエラー出る。
というわけで、まずは基礎の基礎のデリゲートとイベントハンドラ復習しよう！ってことで書きました。
問題が解決しなければ次回はこのTimerクラスについての記事を書こうと思います。
私自身が超初心者なので、間違った情報や補足情報があれば、ガンガンいただきたいです。以上、ここまで読んでいただきありがとうございました。


