More than 3 years have passed since last update.MVVM は ソフトウェアを Model-View-ViewModel の三つに分けて実装する設計パターンです。
Model はデータを、View はユーザーインターフェースを、ViewModel は View と Model の橋渡しをそれぞれ受け持ちます。
MVC との相違点は、View と ViewModel がデータバインディングされる、データの可視化とも言うべき設計をする事です。
この設計パターンを用いることにより、ソフトウェアの外観とロジックが入り混じった従来の Windows Forms の設計に比べて部品化の進んだ整ったソースを書くことができます。Windows Forms は Windows アプリを作成するためのプラットフォームです。
学習コストが低く資産も豊富で、技術も枯れて安定しています。
半面、Windows に依存しており、将来を見据えると不安が残ります。WPF は Windows Forms に代わる次世代の UI フレームワークです。
Windows Forms より Windows への依存度が低く、マルチプラットフォーム開発に向いています。MVVM は Windows Forms のユーザーインターフェースが主導する設計の反省から生まれました。
WPF では MVVM が推奨されています。
そのため Windows Forms では従来の手法で、WPF では MVVM で開発することが多いようです。しかし、MVVM は WPF の専売特許ではありません。
Windows Forms でも十分にその恩恵を得ることができます。
また Windows Forms で MVVM パターンに慣れておけば WPF への移行も容易になるでしょう。

作成したのは上図のようなカウンターです。
▲ボタンを押すと数字が増え、▼ボタンを押すと減ります。
数字は 0 から 10 までの値を取り、その範囲を超えそうな時にはボタンが使用不能になります。
これを実現するのが次の二つのソースです。Form1.csViewModel.csクリックイベントでカウンタを増減させる従来のプログラミング手法とはかなり違うことがおわかりになると思います。
Form1.cs では ViewModel を作成してバインドしているだけで、実際にデータを操作しているのは ViewModel です。
ユーザーインターフェースはロジックのことを気にしないし、ロジックはユーザーインターフェースを気にしません。
これによって再利用性が高まり、開発やメンテナンスが容易になります。もちろん、上のソースだけでは動きません。
コンパイルも通りません。
記述が簡単になるようにヘルパークラスをいくつか作成しています。Reactive Extensions はマイクロソフトの作成した、イベントを LINQ で扱えるライブラリです。
現在はまだオプション扱いですが、将来は標準ライブラリに組み込まれるものと思われます。
プロジェクトを作成して保存し、[ツール]→[NuGet パッケージマネージャー]→[パッケージマネージャーコンソール] でパッケージマネージャーコンソールを開き、「Install-Package System.Reactive」とコマンドを実行してください。PropertySetter.csPropertySetter は INotifyPropertyChanged を簡単に実装するためのクラスです。
Prism では ViewModel は BindableBase という専用のクラスから派生させますが、それだと他のクラスから派生させた ViewModel を使いにくいので、ここではプロパティのセットとイベントの送出に特化させています。
PropertySetter は次のように使います。まずここまで打ち込み、[Alt]+[Enter] を押します。
するとコンテキストメニューが出てくるので「インターフェースを実装します」を選択します。
コードは次のようになるはずです。ここにイベントを発生させるためのメソッドと PropertySetter を保持するためのプロパティを追加します。
#region で囲んでおけば折りたたむことができて見た目がすっきりします。なぜ PropertySetter プロパティを public にしているかと言うと、ほかのクラスから ViewModel のプロパティの変化を簡単に監視できるようにするためです。
必要なければ Protected で構いません。
ここにプロパティを追加し、コンストラクタで PropertySetter のインスタンスを作れば完成です。これでプロパティ Counter の値が変化した時に INotifyPropertyChanged が発行されるようになりました。Command.csCommand はボタンを押した時などに実行するロジックを保持します。
CanExecute プロパティはコマンドが実行可能な時に true を、不可能な時に false を返します。
Execute() メソッドは紐づけられたアクションを実行します。
また簡単に作成できるように拡張メソッドを定義しています。Command は次のように作成します。第一引数の () =&gt; MessageBox.Show("Hello World!") がコマンドを実行した時のアクションです。
この場合はメッセージボックスを表示しています。
第二引数の true が、コマンドが実行可能か否かを示す値です。
この場合は true を指定しているので、コマンドは実行可能です。
また IObservable&lt;bool&gt; を指定することもできます。さらに IObservable&lt;bool&gt; から簡単に作れるよう拡張メソッドが作られています。Counter が 0 より大きい時だけ実行できる Command を作るには次のようにします。または拡張メソッドを使って次のようにします。Binder.csBinder はコントロールとデータとのバインドを容易にします。
例えば Button の Text と Label の Text をバインドするには次のようにします。ボタンとコマンドをバインドするにはもっと簡単な拡張メソッドが容易されています。これで button1.Enabled と command1.CanExecute が同期し、ボタンクリックでコマンドが実行されます。以上のように簡単なヘルパークラスを用意するだけで容易に MVVM パターンが実装できました。
今回は理解を深めるために車輪の再発明のようなことをしましたが、ReactiveProperty など WPF 用と思われているものでも Windows Forms で十分使えますので利用してみてはいかがでしょうか。


