More than 3 years have passed since last update.LINQ で最小値を求めるには次のようにします。要素が IComparable を実装している集合はこのように簡単に最小値を求めることができます。
文字列でも可能です。Max() も全く同じ使い方ができ、こちらは最大値を求めます。このように簡単に最小値・最大値を求めることができるのですが、時々不満があります。
Min() には引数を与えることができますが、この引数が selector という名前にも関わらず結果まで書き換えてしまうことです。
例えば次のコード絶対値が最小となる数を求めて欲しいのですが、得られる値は -1 でなく 1 です。
変換するなら selector ではなく converter という名前にして欲しい。
いや変換していいなら次のようにすればいいだけなのでそもそも必要ありません。私が欲しいのは元の値なのです。以下のソースは古いものです。その次のソースを使ってください。コメントで指摘を受け、OrderBy, OrderByDescending で Min(), Max() の代わりになると教えていただきました。
その時に思ったのが、「集合全体のソートは計算量 O(log N) で、最小値・最大値を求めるのは O(N) であろうから上記ソースの方が速度では勝るはず」ということでした。
ところが実際に計測してみると、条件にもよりますがほとんどの場合でソートの方が速いという結果になりました。
おそらく Lookup の作成に時間がかかっているのだろうと検討をつけ、以下のように再実装したところ、ソートに圧勝できるようになりました。
勉強になりました。Min() と MinBy()、Max() と MaxBy() の仕様は二点違います。
引数が必須になったことと、戻り値が IEnumerable&lt;T&gt; になったことです。したがって、戻り値が一つだけ欲しい時には上記のように First() をつけなければなりません。
一見不便になったようにも見えますが、たとえば次の結果を見てください。標準の Min() の場合は値を書き換えてしまうので複数返す必要はありません。
どちらも 1 になるので複数返しても 1 が二つ並ぶだけです。
しかし、値を書き換えないなら複数返すべきなのです。


