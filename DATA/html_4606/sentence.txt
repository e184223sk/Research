More than 1 year has passed since last update.この投稿は、カプセル化を保ったまま、値の集合を外部へ公開する方法を述べる。
特に、外部から値の変更を許してはいけない場合、どうやって値を外部からの修正から保護するかについてまとめている。
経験があさい方にもわかりやすいよう書くようにつとめた。Qiitaで以下のようなコードを推奨しているコメントを見る機会があった。
(そっくり同じコードではないが、そのままだとそもそもコンパイルを通らなかった)こういうコードを書いてはいけない。この配列、Messagesの各要素は外部から容易に入れ換えられてしまう。このコードの実行結果は以下のようになる。message2と表示されるべき部分が変化してしまった。
「すべてのメッセージを列挙する」という機能を外部から破壊できてしまうのだ。
守るべき配列を直接公開してはいけないのはこうした理由だ。ところで、どうして書き換えできたのだろう。Messagesにreadonlyとつけたではないか。と考えた人はreadonlyの効果を正しく理解できていない。参照型のフィールドをreadonlyとして宣言した場合、その変数が参照しているオブジェクトを変更することはできない。
しかし、そのオブジェクトが持つ値を変更することはできるのだ。
だから、readonlyによって、以下のコードからデータを守ることはできる。しかし、配列の要素の変更からはデータを守れないのだ。ときおり、以下のようなコードを見ることがある。IEnumerable&lt;T&gt;を使用することで値の変更から身を守ろうとしているのだが、残念ながら、以下のようなコードからデータを守ることはできない。このコードの実行結果は以下のようになる。ずるいではないか。外部からしかクラスを参照できないユーザが、どうして内部データを配列で持っていることがわかるのか。
という人がいるかもしれないので、もうひとつの方法を紹介しておこう。このコードも先程と同じ結果になる。Messagesが指すデータ構造がIList&lt;string&gt;を実装している場合、このコードで書き換え可能1だ。string[]はIList&lt;string&gt;を実装するデータ構造のひとつだし、List&lt;string&gt;、Collection&lt;string&gt;も同様なので、よく使用される変更可能なコレクションはこのキャストで値を書き換えられる。守るべき変更可能なコレクションを直接公開してはいけない。たとえ、書き換え不可能なインタフェース経由だったとしても。では、どうやって値の集合を公開したらいいのだろうか。
安全にコレクションを公開する方法を3つあげる。今回のサンプルコードの場合、必要なことは外部から値の列挙をする手段を提供することだけだった。
だから、IEnumerable&lt;T&gt;を返しさえすれば要件は完全に満たすことができる。これ以上の機能の追加もないことが予想できる。先程は直接IEnumerable&lt;T&gt;型として参照を返してはいけないということを述べたばかりではあるが、この型のデータを公開しても問題が発生しないやりかたももちろんある。このMessagesはIList&lt;string&gt;にキャストできない。以下の式はnullを返してくれる。ところが、このMessagesを以下のようにすると途端に変更可能になってしまう。このコードの場合、でキャストできてしまう。
これは、配列のAsEnumerable()メソッド2は自分自身を返すだけだからだ。
編集可能な型へのキャストを許可しないという目的ではAsEnumerable()メソッドは使用できない。コレクションを外部からの編集から守るために、ReadOnlyCollection&lt;T&gt;というクラスを利用できる。あるいは、以下のようにも書ける。Array.AsReadOnly&lt;T&gt;(T[])メソッドは、その配列をラップするReadOnlyCollection&lt;T&gt;クラスのオブジェクトを返す。
List&lt;T&gt;クラスのAsReadOnly&lt;T&gt;()メソッドも同様である。とも書ける。このクラスからは値の閲覧のみが可能であり、もはや、以下のようなコードで値を入れかえることはできない。このクラスのオブジェクトはインデクサ(OKSample.Messages[1]という表現)が使用できるので、クラスの外部から便利に使える。列挙以外のつかいみちがありそうであれば、この型で返すことをおすすめする。ReadOnlyCollection&lt;T&gt;型のオブジェクトは、コンストラクタで指定されたIList&lt;T&gt;型の引数のオブジェクトを参照しつづける。そして、そのオブジェクトのビューとして動作する。
だから、最初に内部で扱うコレクションを引数で指定してReadOnlyCollection&lt;T&gt;オブジェクトを生成しておけば、何度も生成しなおさなくてよい。上記のコードでは、Collectionプロパティをいつ取得しても、最後にAddされた最新のListの内容を取得することができる。コンストラクタで指定されたオブジェクトのビューとして働くとはこういうことだ。これを少しだけ変更した下記のコードには問題がある。
おわかりだろうか。おそらくは、このコードを組みながら作成したテストコードはすべて通過するだろう。
そして、いつの日か以下のようなバグレポートを受け取ることになる。いちいちプロパティの値を変数に保存しないでくれ、と言いたくもなるが、ReadOnlyCollection&lt;T&gt;型のプロパティを返す場合、そのオブジェクトが変数に保存されることを意識する必要がある。
「ReadOnlyCollection&lt;T&gt;はIList&lt;T&gt;のビューとして働く」ということを知っているプログラマからしてみれば、Clear()すれば以前取得したCollectionプロパティが返したオブジェクトが返す値もクリアされるはずである、と想定してしまうからだ。実データであるListが参照するオブジェクトが置きかわらないよう、readonlyをつけたフィールドとして定義するか、読み取り専用の自動プロパティとして定義するとよい。
以下が修正したコードだ。ReadOnlyCollection&lt;T&gt;そのものを返すのではなく、それを継承した型でデータを公開する方法がある。この方法は、に使用する。そうではない場合は、KISSの原則を思い出そう。ReadOnlyCollection&lt;T&gt;が実装しているインタフェースの型、例えばIReadOnlyList&lt;T&gt;型としてオブジェクトを公開するやりかたもあるだろう。
あまりいいやり方とは思わないが、積極的に反対する理由もない。3ただ、C#5.0(.NET4.5)以降のIReadOnlyList&lt;T&gt;インタフェースが定義された環境であれば、互換性以外の理由でIReadOnlyCollection&lt;T&gt;型を使うのはやめよう。
この型はあつかいづらい。実行時のコストはともかく、プログラミングのコストについてはIEnumerable&lt;T&gt;で返されるのとあまり変わりない。ただし、繰り返しになるが、配列を直接IReadOnlyList&lt;T&gt;やIReadOnlyCollection&lt;T&gt;にキャストして返してはいけない。
配列(List&lt;T&gt;も)はIReadOnlyList&lt;T&gt;やIReadOnlyCollection&lt;T&gt;を実装しているのでこうしたことができてしまうのだ。
逆に言えば、プロパティの戻り値の型がIReadOnlyList&lt;T&gt;だからと言って、実際に返されるオブジェクトがReadOnlyCollection&lt;T&gt;やその派生クラスとは限らないということだ。配列を求められる度にコピーして返すやりかたもある。以下のようなコードで書き換えが可能に見える。しかし、元のデータである_Messagesは書き換えられないので、値は正しく保たれる。このやりかたは、速度の面でも、メモリの面でもReadOnlyCollection&lt;T&gt;を使う方法よりも不利だ。
不恰好におもうかもしれないが、には有効に働く。
そうでない場合だったとしても、データの保護が不完全なコードよりはずっといい。ただし、大量のデータをコピーしなければならないのであれば、プロパティではなくメソッドの形で値を公開すべきだろう。もし、あなたがC#6.0(.NET4.6)以降を使っているのであれば、公開しているフィールドをreadonlyで定義する代わりに、読み取り専用の自動プロパティを利用しよう。
コンパイラが、裏で自動的に宣言されるフィールドに対しreadonlyとして定義してくれるから、readonlyと同じ効果が得られる。つまり、コンストラクタより後では値の再代入は許可されない。
もう、readonlyとタイプする必要はないし、そのまま値を公開するよりも拡張性に優れている。たとえば、配列をそのまま返してしまうプロパティを含むプログラムをリリースしてしまったとする。このようにプロパティとして公開していれば、以下のように修正することができる。これは、直接フィールドを公開していてはできない芸当だ。
というのは、フィールドをプロパティにすると外部からのバイナリ互換性は失われ、そのライブラリを使用しているプログラムの再コンパイルが必要になってしまうのだ。配列やList&lt;T&gt;といった変更可能なコレクションをそのまま公開してしまうと、外部からデータを破壊できてしまう。
その代わりの手段として、という3つの方法を述べた。
また、読み取り専用の自動プロパティは、readonlyフィールドをそのまま公開するのとほとんど同じタイプ量でより高い拡張性が得られる。C#6.0以降で使用できる。ここでは配列やList&lt;T&gt;に焦点をしぼって記述してきたが、他のコレクションについても応用できるだろう。4また、こうしたデータの保護が必要なのは、コレクションだけではない。変更可能な参照型オブジェクトについてはどれも同じことが言える。
こちらの問題の場合は、といった手段で対応するのだが、後者のふたつはここで述べた内容そのものだ。System.Runtime.CompilerServices名前空間にReadOnlyCollectionBuilder&lt;T&gt;というクラスがある。
もちろんこれは、ReadOnlyCollection&lt;T&gt;クラスのオブジェクトを生成するために存在する。
しかし、どういったときに便利なのかまったく思いつかない。
ご存知の方はコメントでこっそり教えてください。ただし、後述するが、そのオブジェクトがデータの変更を許可しない場合は書き換えできず、実行時に例外をスローする。また、これはIEnumerable&lt;T&gt;に限った話ではない。IReadOnlyCollection&lt;T&gt;やIReadOnlyList&lt;T&gt;だったとしてもまったく同じことが言える。 ↩正確にはIEnumerable&lt;T&gt;の拡張メソッド ↩ReadOnlyCollection&lt;T&gt;型でのデータの公開は、内部データをIList&lt;T&gt;で管理しているという点に強く依存してしまっているので、これを嫌うというケースはあるかもしれない。 ↩そしてHashSet&lt;T&gt;型のときに読み取り専用のラッパクラスをさがし、ReadOnlySet&lt;T&gt;クラスが用意されていないことに気付いて首をかしげることだろう。 ↩


