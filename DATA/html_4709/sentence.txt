More than 3 years have passed since last update.例えばカレンダーを作っているとして予定テーブルがあるとしてます。ユーザーが1億ユーザーになっても耐えられるように複数のDBに水平分割してテーブルがあるとします。順番にデータの取得処理を実行するとDBの数だけ時間がかかってしまいます。非同期呼び出しでI/O待ちの間はスレッドを開放しているにせよ、3回待ちが発生します。1回当たり0.4秒-0.5秒待つとすると平均でだいたい1.5秒くらい待つことになります。なんとかもっと早くデータを取得したいところです。Task.WhenAllを使用するとこんな感じで書けます。こう書くとこんな感じで並列実行され最大で0.5秒で結果が取得できます。この図だと真ん中が一番遅かったので真ん中の実行時間でデータが取得できます。水平分割の良い点はDBの数が100個になったとしても0.5秒でデータが取得できるという点です。順番に実行すると50秒もかかってしまいます。もちろん前提としてDBがある程度均等に分割されている必要があります。多くのDBが100万レコードなのにあるDBだけ1億レコードとかだと時間がかかってしまうことになります。さて予定テーブルの他にタスクテーブルがあるとします。タスクの取得のクラスをこんな感じで作ったとしてこの場合、取得するのがList&lt;ScheduleRecord&gt;とList&lt;TaskRecord&gt;になり戻り値が異なるのでTask.WhenAllのジェネリック版が使えません。工夫が必要です。このような時に使用できる戻り値が違っても使えるクラスを設計するとこんな感じになります。ParalellExecutionContextのTaskListにタスクを追加して実行し、GetResultsで指定したクラスのリストを取得できます。タスクの取得は0.3秒前後だとすると予定の一番遅い処理時間でデータを取得できることになります。これで戻り値が異なっても非同期で並列に処理を実行して値を取得することができました。このような設計にしておくと
・予定DBの数が増えても大丈夫
・新しく種類のDB（タスクDB）が増えても大丈夫
ということで大規模システムでも大丈夫なシステムになっていきます。あとはDBをどう分割するのかという話になってきますが、ユーザー毎、日付（2018年8月DBとか）毎とかシステムによってという感じになります。データ量＆アクセス数などが自然と均等になるように水平分割できると良いですね。非同期＆並列実行でパフォーマンスを大幅に向上させることができます。積極的に使っていきましょう。


