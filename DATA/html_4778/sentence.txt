More than 3 years have passed since last update.上のコードは、Unityにいくつかある「はまりポイント」や「なんじゃこりゃってなるポイント」の一つです。変数targetがオブジェクトを参照していてnullじゃないのに、target == nullがtrue。GameObjectやComponentを==オペレーターを使って、target == nullのように評価する際、変数がオブジェクトを参照しているのにも関わらず、trueと評価されることがあります。これらの親クラスであるUnityEngine.Objectには、==や!=、boolのオペレーターが定義されています。そして、その挙動が「対象のGameObjectやComponentが、生存していないならば、==でnullと比較するとtrueを返す」という仕様になっています内部でこんなメソッドを作って生存しているかチェックをしています。この挙動は、私はあまり好きではありません。「コードは、利用者の期待や予測に対して、驚きが最小であるべき」と思っています。この挙動は、==に対して利用者が予期しない「生存チェックもする」という驚きを与えてしまっています。覚えておかないと、予期せぬバグを発生させることがあるので、注意が必要ですね。（多分、ごくまれに発生するめんどいバグを生み出す原因になりそう）次のコードを見てみることもオススメします。変数が参照するオブジェクトが破壊されるケースがあり、純粋にnullと比較したい場合System.Object.ReferenceEqualsを使うことをオススメします。関連記事 : Reshaper/Riderの「Possible unintended bypass of lifetime check of underlying Unity engine object」って何ぞや？


