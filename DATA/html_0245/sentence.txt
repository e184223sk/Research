Observerパターンとは、「クラスから通知を発行する仕組み」と、「他のクラスから発行された通知を受け取る仕組み」を実現するためのデザインパターンです。
このデザインパターンは、主にクラス間のデータのやり取りをするときに使われますが、以下のような状況において特に有用です。特に1番はObserverパターンの必須要件で、双方向のデータのやり取りには使用できません。このデザインパターンでは、「データを受け取るクラス」と「データを発行するクラス」を明確に分けて考えます。
このうち、「データを受け取るクラス」のことを「Observer」、「データを発行するクラス」のことを「Observable」と呼びます。Observerとは、「監視者」や「観察者」といった意味の英単語で、データを発行するクラス（Observable）からの通知を受け取る（つまり、通知を観察する、監視する）ことからその名が付けられています。
対してObservableとは、Observerの-able系なので、「観察可能」といった意味になります。
Observableは「観察者」であるObserverにデータを発行するので、Observerから「観察されることができる」、「観察可能」といったことから、この名がつけられています。ObserverとObservableは非常に重要なので、以下のようにまとめます。Observerパターンの基本的な仕組みは、次の3ステップとなります。次の項から詳しく説明します。Observer（値を受信したいクラス）は、欲しい値を発行しているクラス（Observable）に対して、「僕に値を発行・通知してください」と自分自身を通知先として登録します。
この「配信登録」することを、「購読(Subscribe)する」と言います。現実世界で「AさんはS社の雑誌を定期購読する」といった表現はよく使われます。
この場合も、AさんはS社に対して「僕に雑誌を定期的に送ってください」と自分自身を送付先として登録しますね。それと同じような意味になります。そして、一つの値の発行元（Observable）に対して、複数のObserverが値の発行先として登録することができることも、Observerパターンの特徴の一つです。Observable（値を発行するクラス）は、発行する値ができると、値の発行先として登録されたすべてのObserverに対して一斉に値を発行します。
こうして、ObserverはObservableからの通知（値）を受け取ることができます。
Observableから発行された値を受け取ったObserverは、受け取った値を使用して任意の処理を実行することができます。このようにして、ObservableからObserverへとデータの受け渡しが実現されます。Observerパターンの基本的な仕組みの大枠は理解頂けたかと思います。
それでは、これらの仕組みを実際にどのように実装するかを説明していきます。Observerパターンは、「データを受け取るクラス」と「データを発行するクラス」を明確に分けて考えるデザインパターンと書きました。
実は、.NET Framework4.0以降には、Observerパターンで使えるIObserver&lt;T&gt;インターフェイスとIObservable&lt;T&gt;インターフェイスがSystem名前空間に標準で用意されています。
Observerパターンを実装したい場合、これらのインターフェイスをデータの受信側、データの発行側のクラスにそれぞれ実装すれば良いことになります。これらのインターフェイスの定義は次のようになっています。IObserver&lt;T&gt;インターフェイスのOnNextメソッドは、データを新しく通知する際に呼び出すメソッドです。
OnCompletedメソッドは、データの発行がすべて完了し、これ以上通知するものがない場合に呼び出します。
万が一、データの発行元で何らかの例外が発生してしまった場合は、OnErrorメソッドを呼び出して、エラーが発生したことを通知します。IObservable&lt;T&gt;インターフェイスのSubscibeメソッドは、データの発行元からの通知を受け取りたいときに呼び出します。
引数には、通知の発行先となるIObserver&lt;T&gt;オブジェクトを指定します。ここで、以下のような違和感を覚える方がいらっしゃるかもしれません。IObserver&lt;T&gt;はデータを受け取るクラスが実装するのに、なぜデータを発行する系のメソッドを実装するのか？
逆にIObservable&lt;T&gt;はデータを発行するクラスが実装するのに、なぜデータの発行を購読するメソッドを実装するのか？その答えは、これらのメソッドは、実装するクラス自身が使用するのではなく、お互いに相手が使用するものだからです。例えば、「データを受け取るクラス(Observer)」が実装したIObserver&lt;T&gt;インターフェイスのOnNextメソッドは、データを発行するクラス(Observable)が呼び出すことで、Observerに対して値を通知することができます。
逆に、「データを発行するクラス(Observable)」が実装したIObservable&lt;T&gt;インターフェイスのSubscribeメソッドは、データを受け取るクラス(Observer)が呼び出すことで、自分自身をデータの発行先として登録することができます。まだ違和感が拭えないかもしれませんが、実際に実装してみると理解が深まるかもしれません。
それでは、実際にIObserver&lt;T&gt;インターフェイスとIObservable&lt;T&gt;インターフェイスを用いて、Observerパターンを実装してみます。まずはObserver（通知を受け取るクラス）を作成します。このクラスはObserverなので、IObserver&lt;T&gt;インターフェイスを実装します。
型引数Tには受信したい値の型を指定します。ここでは、int型とします。あとは、各メソッドにそれぞれ通知が来たときに実行したい処理を自由に記述します。
例なので、ここでは次のようにコンソールにメッセージを出力するだけの処理を実装しました。これだけでObserverの実装は完了です。冒頭にも書きましたが、Observerパターンでは、発行された値を複数のクラス（Observer）が同時に受け取ることができます。
これを試すために、次のようにObserverの名前をコンストラクタで指定するようにして、どのObserverがメッセージを受け取ったかを識別できるようにしておきます。次にObservable（通知を発行するクラス）を作成します。このクラスはObservableなので、IObservable&lt;T&gt;インターフェイスを実装します。
型引数Tには発行したい値の型を指定します。ObserverとObservableの型引数は合致している必要があるため、ここでもTはintとします。Observableの役目は、値の発行先として登録された（購読された、Subscribeされた）IObserver&lt;T&gt;を記憶しておき、発行する値が生じたときに、そのすべてのIObserver&lt;T&gt;に対して値を発行することです。
※「値を発行する」とは、具体的にはIObserver&lt;T&gt;のOnNext、OnCompleted、もしくはOnErrorメソッドを呼び出すことですしたがって、ObservableなクラスにSubscribeで指定されたIObserver&lt;int&gt;を覚えておける仕組みを作成する必要があります。
とはいっても、単にList&lt;IObserver&lt;T&gt;&gt;に溜めておくだけで十分です。これで、Subscribeで指定されたIObserver&lt;int&gt;を覚えておくことができるようになりました。ところで、Subscribeメソッドの戻り値はIDisposableになっています。
今まで説明しませんでしたが、Observerパターンは、値の発行先として登録するSubscribeの対となる機能として、値の発行を停止してもらう「購読解除」も可能となっています。Subscribeメソッドの戻り値として返すIDisposableは、SubscribeしたObserverが、「もう値はいらないです」と購読を解除するときに使用するものです。
ご存知の通り、IDisposableインターフェイスの中身はDisposeメソッドただ一つのみであり、購読を解除したいObserverはこのIDisposableをDisposeすることによって購読を解除することができます。したがって、Disposeされたときに購読を解除する仕組みを作成する必要があります。
「購読を解除する」とは、Observableなクラス視点で言えば、値の発行先リストであるList&lt;IObserver&lt;T&gt;&gt;から購読を解除したいIObserver&lt;T&gt;をRemoveすることに他なりません。では、どのように実装すればよいでしょうか？まず、IDisposableインターフェイスを返さなければなりませんから、当然、IDisposableインターフェイスを実装したクラスが必要になります。
そこで、以下のように「購読を解除する責務を持ったIDisposableなクラス」を作成します。そして、このDisposeメソッドの中に、購読者リストからRemoveする処理を書けば完成です。
具体的には、発行先リストList&lt;IObserver&lt;T&gt;&gt;とDisposeされたときにRemoveするターゲットとなるIObserver&lt;T&gt;を、コンストラクタで引き渡して、以下のように実装します。そして、この新しく作った購読解除用のIDisposableなクラスのインスタンスを、Subscribeの戻り値として返します。こうすることで、このIDisposableを受け取ったObserverは、値が要らなくなった時点でDisposeメソッドを呼び出すことで、自分自身を発行先リストから削除することができるようになります。ところで、このUnsubscriberクラスは、Observableクラス以外から生成されることはありません。
したがって、下記のようにObservableクラスの内部クラスにしてしまいます。最後に、発行したい情報や値があった場合に通知を発行する処理を記述します。
ここでは例として、SendNoticeメソッドが呼ばれたときに“int”型の1,2,3を連続で通知を発行するようにします。値を発行するには、OnNextメソッドを呼び出します。
すべての発行先に対してOnNextメソッドを呼び出すので、以下のようにforeachを使用すればOKです。これまで作成したObserverとObservableを使用して、実際に値の購読と発行、受け取りの流れを実演します。ここでは、以下のようなコンソールアプリケーションを作成しました。やっている内容としては、コードを見たとおりですがとなります。これを実行すると、次のような出力が得られます。Observerパターンが期待通りに動作していることが確認できます。以上、少し長くなってしまいましたがObserverパターンの解説を行いました。僕自身としては、Observerパターンをこのようにそのまま利用することは少なく、ReactiveExtensionsというObserverパターンをベースとした非常に強力なライブラリを通じて利用することがほとんどです。
もともとは、このReactiveExtensionsの記事を書いていたのですが、ベースとなるObserverパターンの説明がとても長くなってしまったため、別記事として抜き出しました。
またReactiveExtensionsの記事も書いたらリンクを貼るのでそちらも良ければ御覧ください。[2020/12/22追記]
ReactiveExtensionに関する記事書きました。よろしければ参照ください。
【C#】なぜReactiveExtensionsを導入すると幸せになれるのか何か間違いやご指摘、ご質問あればコメントにお願いします。


