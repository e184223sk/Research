More than 3 years have passed since last update.RYUJitが、末尾再帰の最適化をどのように行うのか行わないのか調べてみた。下記のようなコードはWraparoundして結果は正しくないけど。とりあえず動く。1で、これを桁あふれ対策で下記のように書き換えたらStackOverflowExceptionが飛んできた。ので、その条件とどーすれば回避できるかユルくまとめていこうかと思いますので、お付き合い頂ければ幸い。は、以下の通り@acple@githubさんが、.NET4.6で末尾再帰するとしぬかもな話と言うエントリを上げてるので、ご覧頂ければと思います。また、先日本件をTwitterにてTweetしたところ、ご本人様からこのようなリプライを頂いたので、これを参考にしつつ色々とわかったことをユルくまとめようって言うさむしんぐです。色々と試行錯誤してみたのは以下の通り先のやりとりで、クラスやインターフェース使えばうまく行く的なアドバイスを頂いたので、以下のように書き換えてみた。メンバにしてしまえばうまく行くかと思ったけど。。。結果はあえなくProcess is terminating due toStackOverflowException.がDumpされて終了。どーもこー言うことじゃないらしい。なので、次に、そもそも、Envelopeがダメなのか、それともメンバのBigIntegerがやっぱりダメなのか、切り分けるため、冗長だけど以下のようなコードを書いてみた。これは、結果は正しくないけど、StackOverflowExceptionが飛んでくることもなく、普通に動いた。このことから、Envelopeが問題ではなく、メンバのBigIntegerがどーも悪さしてるかなぁって仮定した。で、上記の結果と、頂いたアドバイス、先行する知見から、Primitive4意外の値型を利用した場合は末尾再帰の最適化が行われず、StackOverflowExceptionが発生してしまうのではと仮定して、classにしてたEnvelopeをstructにして挙動を見てみた。結果は、予想通りStackOverflowExceptionでこけた。てことで、今回わかったことは以下の通り。大体、こんな感じじゃないかと思います。次回は、末尾再帰の最適化が行われる条件を検証してみようかと思います。これ書いてるウチに、藤井聡太七段になってた。
当然、桁があふれてWraparoundする。ここではStackOverflow起こらない予定度に見て頂ければ。 ↩ただ、C#のVersionはあんまり今回関係ないと思う。 ↩Ryujitでの挙動なので、この条件は割と必須。 ↩typeof(T).IsPrimitiveが、trueの型と言うことで一つ。 ↩


