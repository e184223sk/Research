More than 3 years have passed since last update.この記事はC# Advent Calendar 2017の19日目の記事です。18日目は@usamik26さんの「Moq : Mocking Framework for .NET - Qiita」でした。C#は2002年に.NET Frameworkとともにバージョン1.0がリリースされ1、既に15年ほどの歴史があり、2017年12月19日現在はバージョン7.2まで進化しています2。その歴史の中では、当然言語機能も増え、エラーハンドリングのやり方も徐々に種類が増えてきました。そこで、C#に置けるエラーハンドリングの実装を一度ここで整理し、特徴をまとめてみます。このリストはもちろん完全ではありません。誤字脱字から認識の齟齬、他にもこんなやりかたがあるよ、特徴にこんなものがあるよ、などありましたら、遠慮なく編集リクエストやコメントにてお知らせください。ここで「エラー」と呼んでいるのは例外(Exception)ではなく、ロジックのエラー(いわゆる業務エラー)のことを指しています。エラーの種類については、赤間さんのエントリ.NETの例外処理の定義に倣います。業務エラーと判定する処理がない場合、エラーハンドリングを端折ることもあるでしょう。処理結果を返す際、エラーがあった場合は処理結果の型の既定値(例：intなら0、参照型ならnull)を返します。ただ、本Advent Calendar 9日目の猪股さんによる「Null 非許容な参照型 - Qiitaにある通り、今後は参照型でもnullを排除していく方向ですので、注意が必要です。ひとつ前と戻り値と同じ型でエラーを表すのは同じですが、既定値ではなくあらかじめ決めて置いた値をエラーとして扱います。エラーかどうかと処理結果を分けます。成功/失敗のような単純なケースでは有用です。
C# 7.0で追加された出力変数宣言を使えば、すっきりと書くことができます。ひとつ前と異なり、エラー有無をエラーコードで返します。現在のところ、最も現実的な実装方法の一つです。ひとつ前とほぼ同じですが、C# 7.0で導入されたValueTupleを使って処理結果とエラーを一度に返します。C# 7.0から導入された型スイッチを活用する方法です。エラーを表すのに独自の型を作成するのでなく、既存の例外を再利用します。※エントリ公開後に@kazukさんに教えてもらいました。エラー値としてのenumはexceptionを使うのも割と選択肢として悪くないreturn new indexoutofrangeexception業務エラーも例外を使って表します。いわゆる「部品」における引数の検証などではよく使われます。現時点ではいずれの実装でも完全とは言えません。個人的には「小ネタ チェック例外とUnion型 | ++C++; // 未確認飛行 C ブログ」でも言及されているような、Union型があればいいなーとは思いますが、今のところ導入されそうな様子はありません。しかし現実は待ってくれません。与えられた材料や条件を元に、それぞれのメリット、デメリットを天秤に掛け、最適と思えるやり方を選ぶことになります。本エントリーが少しでもその助けとなれば幸いです。20日目は@4_mio_11さんの視て、わかる！C#7.1までの言語機能(スライド)です。本エントリのサンプルコードは、みんな大好きLINQPadの*.linqファイルとしてGitHubにアップしてあります。https://en.wikipedia.org/wiki/C_Sharp_(programming_language)#Versions ↩VS 15.5で正式サポート開始 https://blogs.msdn.microsoft.com/visualstudio/2017/12/04/visual-studio-2017-version-15-5-visual-studio-for-mac-released/ ↩


