More than 3 years have passed since last update.C# の OR マッパー Entity Framework Core では　LINQ to Entities を使用してオブジェクトを操作するようにデータストア(例えばリレーショナルデータベース)にアクセスすることができます。クエリ変数の型がIQueryable&lt;Book&gt;であることから分かるように、クエリ変数は結果を保持しておらず、代わりにクエリのコマンドが格納されるだけです。IQueryable&lt;T&gt;からクエリが実際に実行されるタイミングはの3つです。※追記：いただいたコメントによると以下の方法で簡単に見分けられるそうです。LINQメソッドが即時実行か遅延実行か見分ける簡単な方法は、返り値の型を見ることです。
返り値の型がIEnumerableかSystem.Linq名前空間のインターフェイスなら遅延実行。IQueryable&lt;T&gt;（のExspressionプロパティ）に格納されたコマンドは、foreachによってループ処理されるときに実際に実行されます。１つの値だけを返すクエリは即時に実行されます。
Average Max Min Count First FirstOrDefault Single...などです。ToList ToDictionary ToArray などシーケンス(IEnumerable&lt;T&gt;)を返すメソッドはクエリを即時実行します。
（※追記AsEnumerableは即時実行ではありませんでした。コメントありがとうございます。）クエリの実行を遅延できるので、クエリを合成することも可能です。
以下の例ではforeachまでクエリの実行が遅延されるのでWhereによるフィルタリング処理も含んだクエリが実行されます。上記のように便利な LINQ to Entities ですが、クエリが実行されるタイミングを把握していないと、うっかり非効率なクエリを書いてしまうことがあります。以下はC#をタイトルに含む書籍のタイトル一覧を取得するクエリです。クエリに途中にAsEnumerableが入るとどうでしょうか。
以下の例ではforeachによる列挙でクエリが実行される際に、DB から書籍のタイトルを全て取得するクエリが実行されAsEnumerable()以降のフィルタリングは LINQ to Objects によってメモリ内でが行われます。
（※追記：記事内で「遅延実行と即時実行」と「LINQ　to Entities と LINQ to Objectsが切り替わるタイミング」がごっちゃになっていましたので表現を修正しました。詳しくはコメント欄をご確認ください。）通信量が増え、1つ目のクエリと比べ、はるかに遅くなる可能性が高いです。
上記の例では途中にAsEnumerableが挟まっているのでわかりやすいですが、クエリが複雑になったりメソッドが分割されているときは注意が必要です。また、それ以外でも、データストアからデータを取得するメソッドを定義した際、結果を返すのではなく、IQueryable&lt;T&gt;を返してしまい、実際にクエリが実行されるときにはデータストアとの接続が切れていて例外をスローすることも起こります。(実体験)
やはり、LINQ to Entities でいつクエリが実行されるかを把握しておくことは重要だと思います。2年目プログラマーです。
エンジニアの方とつながれるととても嬉しいです！twitter: のさ@nosa_programmer


