More than 1 year has passed since last update.世の中には大量にUniRxに関する
最強にわかりやすい資料が転がっているのですが、
どうやら私は人より完全に理解した気になるのが早いらしく、
悪い勘違いをしたまま、完全に理解した気になっていたようです。現時点でもその可能性は否定できませんが、
実際のサンプルを用いて人に説明するつもりで学んでいけば、
より理解が深まるのではないかと思い、メモを残すことにしました。実際のサンプルがこちらです。右の黒い柱のようなオブジェクト(この記事内では"壁"とします)に
球体(この記事内では"ボール"とします)が衝突すると
ライトの色がボールの色と同じ色に変化します。この程度ならUniRxを使わずとも簡単に実装可能なので
行われている処理をイメージしやすいと思いサンプルに選びました。では実際にUniRxを使った場合はどうなるのか見ていきます。図の通りです。
と言いたいところですが
自分でも嫌になるくらいごちゃごちゃしてしまったので、
コードを追って説明する上での補足として見るぐらいがいいと思います。では実際にコードを追っていきます。CollisionNotifyクラス内ではIObservable,Subject,OnNextが書かれています。しかし、実際にObserverパターンの中の具体的な処理を担っているのは
ここではSubject,OnNextのみです。IObservableは外部に公開しており、
他のクラス内でやってほしい処理を登録する役割を担います。次に先ほど具体的な処理を担っていなかった
IObservableに対して別クラスにて役割を与えます。コード内のコメントにもある通り、
発行された値(OnNextの引数に指定した値)を受け取って、
Subscribe内の処理を実行します。なのでSubscribe(collisionObjectColor =&gt; {})のcollisionObjectColorにはcolorSubject.OnNext(otherObjColor);で
発行したメッセージの中身のotherObjColorが入っています。つまり、
①オブジェクトが壁にぶつかる
②メッセージが発行される
③メッセージの中の値を受け取る
④登録した処理が実行される(値を利用できる)
となります。ここまでのメモを振り返って改めて最初の図を見ると、
最初に見た時よりはマシに見えてきました。Subjectをreadonlyにして、OnNextを発行するクラスを制限していました。 設計の観点から、メッセージを発行するクラスは、
不用意に外部のクラスに公開するのはよろしくないそうです。これは別にprivateでも問題ないのですが、
"外では使わないよ"というのを強調するために使っています。先ほどの図で説明した一連の流れをストリームソースと呼びます。ただ、Unityには既にいろんなコールバックイベント(Button押したら...衝突したら...とか)が存在しています。そこで、既存のコールバックイベントを活用してストリームソースを作りたい。。。という願いに答えてくれる機能が既にあります。例えば、先ほど例に挙げた、OnCollisionEnterを検知しOnNextメッセージを発行するサンプルは下記のように書き換えできます。いろんなのがある(特にUI関連)ので実際に触ってみると便利さがわかるかと思います。【参考リンク】：UniRx.TriggersQ. UniRxって結局何がすごいの？という疑問。
その答えとしては、いろいろあるのでしょうが、A. MVPパターンを簡単に実装できるが一番大きな利点でしょうか。(特にお仕事で利用する場合は)
　　
　　それに伴ってまた疑問となるのが、Q. MVPパターンって何がすごいの？ですが、A. 規模が大きくなっても比較的楽に拡張ができるが答えでしょうか。
(私もあまり詳しくないので、もっと他に理由があれば教えてください)【参考リンク】：Unityで学ぶMVPパターン ~ UniRxを使って体力Barを作成する ~もうちょっと踏み込んだ理解をしようと試みたんですが、
今の自分ではまだ難しかったです。これから学習する方の入門書の入門書となれば幸いです。今後はそもそもの理解度を深めつつ、Hot、Cold等の話もインプットして自分なりのメモを残そうと思います。UniRx(ユニアールエックス)の基本的な使い方と具体的な利用例【Unity】【UniRx】UniRx入門 その1ObserverパターンからはじめるUniRxUniRx入門 その3 -ストリームソースの作り方作りながら理解するUniRxデザインパターン「Observer」


