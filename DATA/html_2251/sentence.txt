More than 1 year has passed since last update.この記事は【unityプロ技】 Advent Calendar 2019の13日目の記事です。
この記事におけるソースコードは、全てPublic Domainです。※12/13 15:00 訂正あり
※12/26 続編でましたC#にはアクセス修飾子と呼ばれる、型やメンバのアクセスを制限する仕組みがあります。
例えばクラスAからクラスBのprivateメソッドを呼ぼうとすると、コンパイルの時点で怒られますし、VisualStudioやVisualStudio Code、Rider等といったIDEのインテリセンスには、候補すら出てきません。今回取り上げるinternalアクセスレベルは同一アセンブリ（=同じdll）内からのみアクセスできるアクセスレベルです。
このアクセスレベルを持つ型やメンバは、異なるアセンブリ（=別のdll）からは基本的にはアクセスできません。internalな型やメンバにアクセスする必要があるの？
公開されている(publicな)APIだけで十分では？
苦労してinternalな型やメンバにアクセスして、何がうれしいの？internalな型やメンバは、ライブラリ製作者がライブラリ利用者に対して隠蔽したい項目であり、APIやドキュメントは一般的に非公開です。
例えば、Unityに何らかのエディタ拡張を加えたい場合は、以下のようなUnityが公開しているAPI(publicなAPI)の利用が基本です。御存知の通り、公開されているAPIだけでも「出来ないことなんて何も無いんじゃないの？」と思えるほど大量の項目が見つかります。
しかし、公開されていない（=非publicな）APIに目を向けると、さらに多くの事が実現可能なことに気づきます。例えば、【Unity】UIElements で Game ビューにテキストやボタンを追加するエディタ拡張のサンプル(@baba_s様)では、リフレクションを利用して、Unityが公開していないGameViewクラスへアクセスし、GameビューにオリジナルのGUIを追加しています。このように、非publicなUnityの世界を知ることは、新しい気づきや便利な拡張機能のヒントになります。
そして、あなたが発見した気づきや便利な拡張機能は、ほかの誰かのヒントになるかもしれません。ただし、大事なことなので二回言いますが、internalな型やメンバは、ライブラリ製作者がライブラリ利用者に対して隠蔽したい項目であり、APIやドキュメントは一般的に非公開です。
ググって得られる情報は限定的ですし、無慈悲にもAPIは通告なく変更されます。
IL化や難読化されていることは日常茶飯事で、誤って使えばフリーズする可能性すらあります。
ライブラリのライセンスによっては、明確に逆コンパイルやリバースエンジニアリングが禁止されています。ありがたいことに、Unityは公式でGitHubにソースコードを公開しています。internal要素も探し放題です。太っ腹だね！さあ、実現したいことをキーワードにソースコードを検索し、それっぽい名前の APIを見つけ、注意深くソースコードを読み、拡張機能の幅をくれぐれも自己責任で広げましょう！本記事では以下の環境でデモプロジェクトを開発しました。デモプロジェクトは以下のリポジトリで公開しています。
https://github.com/mob-sakai/MainWindowTitleModifierForUnity今回は、Unityエディタのタイトルバーのテキストを変更してみたいと思います。 
タイトルバーに現在のブランチ名やゲームサーバの接続先環境名(sand/stag/prod等)を表示できると素敵ですよね。
ソースコードを見たところ、Unity2019.2から追加されたinternalな型とメンバを使えば簡単に実現できそうです。
具体的には、EditorApplication.updateMainWindowTitleイベントに新しいコールバックを追加し、EditorApplication.UpdateMainWindowTitle()を呼び出せば、タイトルバーのテキストを変更できそうです：updateMainWindowTitle、UpdateMainWindowTitle、ApplicationTitleDescriptorは全てinternalな型とメンバであり、このままでは当然コンパイルエラーになります。なんとかしてアクセスしてみましょう！publicでない型やメンバにアクセスするための方法として、まず思いつくのはReflection(リフレクション)です。
リフレクションにより、文字列を使ってpublicでない型やメンバにも動的にアクセスできます。リフレクションの利点は、internalな型やメンバだけでなく、privateな型やメンバにもアクセスできることです。
また、有名であるが故にググれば情報がたくさんあり、リフレクションだからこそできる事も多くあります。
C#リフレクションTIPS 55連発(@gushwell様)という一読すべき記事もあります。実際にやりたいことは4行で済む内容でしたが、リフレクションで表現するとどうなるでしょうか？うーん、つらみ。。。
やりたいことは単純なはずなのに、どうしてこうなった！って感じですね。ともあれ、MainWindowTitleModifier &gt; Solution1_Reflectionを実行すればタイトルバーのテキストを変えられるようになりました。
リフレクションの欠点は生産性が低いことと、実行速度が遅いことです。
やりたいことに対してやるべき準備が多く、IDEによるインテリセンスも効かないため、生産性はお世辞にも良くありません。
なぜリフレクションは遅いのか(POSTD様)によると、静的な呼び出しと比べて2〜3桁オーダーで実行速度が遅いようです。単純なメソッド呼び出しやsetter/getterについて、リフレクションを使う分には悩むことも少ないでしょう。
ジェネリック、コンストラクタ、in/out/ref/paramsキーワード、関数のオーバーロード、非publicな型を含むAction&lt;T&gt;やFunc&lt;T&gt;、event等、要素が複雑になると、だんだんと長く、ツラくなってきます。めげずに頑張ってググりましょう。InternalsVisibleToAttributeは、特定のアセンブリに対して、自身のinternalアクセスを許可させる属性です。
アセンブリに対する単体テストや、機能拡張に使うことが多く、そういったアセンブリはフレンドアセンブリと呼ばれます。
この属性の強力なところは、internalな要素をそのまま記述でき、VisualStudioやVisualStudio Code、Rider等のIDEでインテリセンスやブレークポイントが有効になることです。
テストコードを書くに当たり、IDEのサポートが得られるのはありがたいですね！
さて、InternalsVisibleToAttributeは、UnityEngine.dllやUnityEditor.dllといったUnity公式のライブラリにも存在します。
例えばUnityEditor.dllのAssemblyInfo.csには次のように定義されています。これらの名前を持つアセンブリは、UnityEditor.dllのフレンドアセンブリです。
よって、上記の名前を持つアセンブリを生成できれば、UnityEditor.dllに対してinternalアクセスできます。すっごーい！Unityでアセンブリを生成するための仕組みといえば、AssemblyDefinitionFileです。
AssemblyDefinitionFileについては@toRisouP様がUnity Assembly Definition 完全に理解したにて詳しく解説されております。(こちらも【unityプロ技】 Advent Calendar 2019の記事です)なお、AssemblyDefinitionFileによって生成されるアセンブリ名は、インスペクタ内のNameフィールドで設定します。
アセット名ではないことに注意しましょう。適当なAssemblyDefinitionFileを作成し、インスペクタビューからNameを変更しましょう。
ここでは、Unity.InternalAPIEditorBridgeDev.001という、実にそれっぽい名前(おそらくUnityの中の人がテストするためのアセンブリ名)を指定します。
次に、Unity.InternalAPIEditorBridgeDev.001.asmdefがあるディレクトリ以下に、次のようなスクリプト(Solution2_InternalsVisibleToAttribute.cs)を追加し、Unity.InternalAPIEditorBridgeDev.001アセンブリに組み込みましょう。
リフレクションが完全に消え、イメージしたようなスッキリしたコードになりました！
直接呼び出しになるので、実行速度も申し分ありませんし、IDEのサポート(インテリセンスやブレークポイント)によって格段に生産性が上がりました。
MainWindowTitleModifier &gt; Solution2_InternalsVisibleToAttributeを実行すれば、同様にタイトルバーのテキストを変えられます。
AssemblyDefinitionFileとInternalsVisibleToAttributeを使ったinternalアクセスは、非常に手軽な方法です。
しかし、残念ながら、全てにおいて完璧とは言えません：難儀な欠点が多いですが、逆に言えば、クローズドな環境でエディタ向けの機能を実装するのであれば、この方法だけでも十分に使えそうです。IgnoresAccessChecksToAttributeは、ほとんど情報が出回っていない（MSDNにも載ってない）ミステリアスな属性です。
私はNo InternalsVisibleTo, no problem – bypassing C# visibility rules with Roslynで偶然知りました。
要約すると：つまり、どんなライブラリに対してもinternalアクセスができるようになる、夢のような属性ってことですね！
さっそく、この属性を使ってみましょう。先述の記事にある通り、IgnoresAccessChecksToAttributeを使うにはcsc.exeやMsBuildを使わずに、自力でコンパイルする必要があります。
自力でコンパイルする方法を紹介しますが、正直めんどくさいです。
興味のない方は「IgnoresAccessChecksToの準備がめんどくさいのでなんとかする」まで読み飛ばし推奨。まず、C#プロジェクトに以下のコードを追加します。
こうすることで、「UnityEditorアセンブリに対するアクセスレベルのチェックを無視する」ようにコンパイラが解釈できます。次に、C#プロジェクトとは別に、「アクセスチェックを無視できる」コンパイラのプロジェクトを作ります。コードは以下の通りです。なお、このコードはコンパイル対象がUnityが生成したC#プロジェクトであることを前提にしています。
他のジェネレータで生成されたC#プロジェクトをコンパイルできないかもしれません。
（きっと、おそらくMSBuildパッケージを使えばたぶん解決できます。）dotnetを使って実行し、以下のようにC#プロジェクトファイルと出力パスを指定すると、internalアクセス可能なdllを生成できます。なお、このコンパイラはnuget toolとしても公開しています。（オプションが若干違います）

https://www.nuget.org/packages/InternalAccessibleCompiler/IgnoresAccessChecksToをUnityで使うには準備がめんどくさいです。
今回は、先述のコンパイラを同梱済みのUnity向けに公開しているパッケージを使います。
（デモプロジェクトには既にインストールされています。）AssemblyDefinitionFileやソースコードは、【方法2】InternalsVisibleToとアセンブリ名やクラス名が被らないようにする以外、ほとんど同じです。
コンパイルが完了すると、MainWindowTitleModifier.dllが生成されます。
このままでは同じ名前を持つMenuItemが衝突してしまうので、MainWindowTitleModifier.asmdefのDefine Constraintsに適当な文字列を入力して、インポートされないようにしておきましょう。
MainWindowTitleModifier.dllのインポート後、MainWindowTitleModifier &gt; Solution3_IgnoresAccessChecksToAttributeを実行すれば、タイトルバーのテキストを変えられます。
どんなアセンブリに対してもinternalアクセスができるため、この方法は非常に強力です。
【方法2】InternalsVisibleToの欠点も少し克服していますが、それでも完璧ではありません：今回は外部アセンブリからinternalアクセスする方法を3つ紹介しました。以下は、パッケージマネージャのUIを拡張するパッケージ、UpmGitExtensionを実装した際のワークフローです。
（実際にはdll生成の工程を自動化したり、AssemblyDefinitionFileの参照関係を整理したり、dllを生成するために使ったディレクトリをパッケージからパージしてます。）UpmGitExtensionの実装において、internal要素へのアクセスは必須事項でした。
UnityやPackageManagerUIのAPIが日々アプデされる状況において、リフレクションのみで対応を続けるのは苦しいものでした。
製作者が見ても意味のわからないコード、名前か引数が変わりエラーを吐き続けるAPI、直ったと思いきや別ベクトルから迫りくるデグレ...
UnityやPackageManagerUIがマイナーアップデートする度にAPIは変更され、どこからか不具合が起き、改修を迫られ、心が折れかけました。2019.3なんて中身ほとんど別モンやんけ！そんな中、今回紹介した方法を使うことで、手軽にinternalにアクセスできるようになり、テストやソースコードの使いまわし（UnityEditor内部のMiniJsonを使ったり）が容易になり、生産性やコードの見通しが格段に改善され、お肌の調子も良くなりました。
もし、あなたの近くでC#のリフレクションに苦しんでいるエンジニアを見かけましたら、そっと本記事のリンクをDMしてあげてください。最後に、本当に大事なことなので三回言いますが、internalな型やメンバは、ライブラリ製作者がライブラリ利用者に対して隠蔽したい項目であり、APIやドキュメントは一般的に非公開です。
ライブラリ製作者は、決して意地悪でinternalを使っているのではありません。
不用意にその型やメンバを扱うと、とんでもない結果になるかもしれないからinternalで隠蔽しているのかもしれません。
internalな型やメンバは、「そうあるべき正当な理由があってinternalになっている」ということを理解した上、くれぐれも自己責任で活用してください。皆様、よいUnityライフを！まぁ私もこないだまで知らなくて教えてもらったのですがが。vs-mefとかで投下されてて効果大らすぃ。 https://t.co/w6AzJoxK4yTwitterで@neuecc様からリプライをいただいたのですが、リンク先の「*AllowPrivate」というワードが引っかかりました。
参照しているソースコードを読む限り、IgnoresAccessChecksTo以上のことはしていない様子...
これらの事実から導き出される答えは...
IgnoresAccessChecksToはprivateアクセスもできるということです！
よく見たら元記事でもprivateアクセスしてた...軽くテストしてみたところ、確かにIDE上ではprivateアクセスがエラーとして表示されましたが、InternalAccessCompilerではエラーなくコンパイルできていました。
もちろん動作も問題ありませんでした。具体的なワークフローの更新については別記事でまとめますので、もう少々お待ちくださいm(_ _)m。※12/26 続編でました


