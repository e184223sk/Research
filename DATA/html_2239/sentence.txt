More than 1 year has passed since last update.非同期というのは並列処理の一種。
例えば、コンビニで例えると店員二人で客の対応を行うのがマルチスレッド。
対して、お弁当温めてくださいと言われたときに電子レンジに温めるのを任せ、他の客の対応を行うのが非同期。コードで例を見てみよう。
その前に準備C#にはデフォルトで時間を測るStopwatchクラスが存在する。
stopWatch.Startが時間計測スタート。実行結果メソッドにasyncをつけるとそのメソッドは非同期メソッドになる。
awaitをつけると非同期メソッドが終了するまで待機する。
Task.Delay(1)はダミー行。asyncメソッドの中でawaitがないと同期で実行されてしまうため入れている。
戻り値のTaskというのはjavascriptでいうところのresolve。
Taskは非同期メソッドの状態を返す。実行結果これでawait Task.Delay(1)の行がなければ同期実行されるので3秒待つことになる。実行結果実行結果実行結果Thread.SleepとTask.Delayはどちらも待機なのでTask.Delayを使っていく。
Task.WhenAll(list)はlist内のtaskが全て終了するまで待機する。WPFのイベントで非同期メソッドを使うことによって、UIを妨害することなくイベントの実行ができる
まずは非同期を使わない場合実行すると、3秒経った後メッセージボックスが表示される、3秒の間はWPFを操作することはできない。
このように重い処理がイベントに入ってしまっている場合ユーザーの利用を阻害してしまうことがあるので、その場合非同期を使うのが有効となる。非同期を使った場合。この場合メッセージを出すのはボタンをクリックしてから3秒後になるが、その間操作はできる。
戻り値がTaskではなくvoidになっているのはメソッドの登録を行うときにvoidでないといけないから。実はawaitを使わなくても待機する方法がある。実行結果しかし、このメソッドにはデメリットがありWPFなどで使うとデットロックが発生し動かなくなってしまう。実行して、Button_Clickイベントと紐づいているボタンをクリックすると、デットロックを起こし動かなくなる。Task.Delay(1000).ConfigureAwait(false)というようにConfigureAwait(false)をしてあげるとデットロックは起こらない。実行してボタンをクリックしてみるとデットロックは起こらない。WaitAllメソッドを使うと複数のTaskをawaitなしで待機することができる。実行結果Genericを使うことによって戻り値を指定することができる。
例えば、stringが戻り値である場合非同期メソッドの時はTaskとすればよい。実行結果Task型の変数があったとき、Resultフィールドによって値を見ることができる。実行結果


