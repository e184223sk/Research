以下のような確率分布があるとして、これに従ってランダムに要素を1つ決定したい。実装のソースコードは記事の最後に記載する。運用先としてUnity等が真っ先に思い付いたため、C#での実装とした。
この機能に名前があるのか知らないが、近年ソーシャルゲームで流行しているガチャに似ているため、ガチャシステムと呼ぶ。入力として、$N$ 個の要素からなる確率分布の数列 $A_1,A_2,⋯,A_N$ を与える。まず、$[0, \sum_{i=1}^{N} A_i]$ の範囲でランダムな実数 $r$ を1つ決定する。次に、$\sum_{i=1}^{k} A_i \leq r &lt; \sum_{i=1}^{k+1} A_i$ となる整数 $k$ を求める。
簡単に思いつく方法は線形探索だが、今回は高速化を試みて二分探索で実装してみる。　※二分探索の説明は割愛する。
なお、確率分布の部分和を計算しなければいけないため、実装全体としては $O(N)$ である。$O(\log N)$ ではない。とりあえず関数のシグネチャを定義。
引数として、先ほどの確率分布 $A_1,A_2,⋯,A_N$ 、そしてランダムに決定した値 $r \; (0 \leq r \leq \sum_{i=1}^{N} A_i)$ を取る。
戻り値は $r$ に対応するインデックス $k$ にすればよい。この部分の実装は、一般的な二分探索とあまり変わらないため説明を割愛する。
考え方としては以上のような形になる。BinarySearchInOdds() メソッドが、先ほど省略した「確率分布から、rの値に対応するインデックスを返す機能」を実装されているものである。
Draw() メソッドに確率分布を渡すことでお手軽にガチャを引くことができる。
仕様が分かるように Main() を書いたので、実行結果も含めてぜひ見ていってほしい。実行結果実行速度も計測した。$N=10^5$ 程度までは処理時間のオーダーがほぼ変わらない模様。二分探索による高速化が多少活きた...かな？これでいつでもガチャ引き放題。


