More than 1 year has passed since last update.結構自作しちゃうことが多かったんですが、それなりに実装難易度が高い上にちょっと時間がないので何かないか困っていたら、良いものを教えていただいたので簡単な使い方をまとめておきます。あえとすさんいつもありがとうございます！マルチスレッドプログラミングの一般的なデザインパターンのひとつ、生産者・消費者パターン（最近だとPub/Subパターンといった方が伝わりが良い？）の実装を助けてもらえるMicrosoft謹製のライブラリです。async/awaitとの親和性が高く、簡単に使えて高速に動作します。とくに1.の記事は、ほかのライブラリとの比較もされていて、一読することを強くお勧めします。まずは一番簡単な例から。生産者も消費者もひとりなんですが、生産者はキューにアイテムを突っ込んだら、消費者に非同期で処理してもらいたいときに利用する実装です。こちらはほぼ参考資料のままです。シンプルで素晴らしいサンプルです。まず最初にキュー（＋α）に該当するChannelオブジェクトを生成しています。CreateUnboundedはサイズ制限のないキューを作成します。CreateBoundedを利用するとサイズ制限のあるキューを作成できます。またUnboundedChannelOptionsのSingleReaderとSingleWriterをtrueとして制約をかけることで性能がやや向上するようです。デフォルトはfalseです。つづいて、キューに登録されたアイテムを処理する消費者（Consumer）を作成します。WaitToReadAsyncメソッドでChannelが閉じられる（すべての処理が完了している）かどうかチェックし、ReadAsyncでアイテムを取得して処理しています。ではつぎは生産者（Producer）側を見てみましょう。Randomに3秒以内のディレイを挟みつつ、WriteAsyncでアイテムを登録しています。5つのアイテムを書き込んだらCompleteでチャネルを閉じています。最後は生産者と消費者の処理を待って終了します。参考資料の例だとキューに入れられたアイテムの処理時間が均等であれば良いのですが、アイテムによって処理時間が異なるような場合は不適切です。その場合、つぎのように利用しましょう。CreateUnboundedでWriter側だけSingle制約をかけていることに注意してください。まず最初に複数の消費者を生成します。ここで重要なのは、アイテムの取得にReadAsyncではなくTryReadを使っている点です。Channelでは消費者はWaitToReadAsyncでキューにアイテムが登録されるのを待ちますが、アイテムがひとつ登録されると、一旦すべての生産者が「起こされ」ます。ReadAsyncを使った場合、2番目以降にアイテムを取りに行った消費者は、アイテムがないため例外がスローされてしまいます。そこでTryReadを利用することで、まだアイテムがあった場合だけ処理するように実装してあげる必要があります。あとはすべての消費者と生産者の処理の終了を待機して完了です。参考資料の例では、複数のChannelを作ってマージする方法が紹介されていますが、元々Channel自体が複数からの入力をサポートしているので必ずしもChannelを複数作る必要はありません。ということで以下がシンプルな例になります。CreateUnboundedでReader側だけSingle制約をかけていることに気を付けてください。Consumer側の生成は1:1の場合と変わりありません。違いはProducer側の実装です。1:1の時はforループ前後が次のように実装されていました。
forループの外でWriterをCompleteして閉じていましたが、これでは最初に処理が完了したProducerが閉じてしまい、以後のProducerの処理でエラーになってしまします。そのため、つぎのようにすべてのProducerの処理が完了してからCompleteするようにします。ここは実際の実装はケースによって異なりますが、生産者の処理を全て待つ必要がない場合は、つぎのようにWriteAsyncではなくTryWriteを使うこともできます。Completeも閉じられる場所が一つではない場合は、TryCompleteを使うようにしましょう。以上です。


