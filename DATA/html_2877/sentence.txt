More than 1 year has passed since last update.本記事は2012年末頃に、社内向けに作成した説明資料をQiita向けに編集したものです。
最新の仕様とは異なる場合があるので注意してください。　.NET Frameworkには「COM相互運用1」と呼ばれる機能があり、COMコンポーネント2を手軽に呼び出すことができます。一方、ExcelをはじめとするOffice製品は、その機能をマクロ（VBA）などからも活用できるようにCOMコンポーネントとして実装されています。このため、COM相互運用を使えば.NETアプリケーションから容易にExcelやWordのファイルを開き、それをさまざまに操作することが可能です。　本記事ではC#で作成されたサンプルアプリケーションのソースコードを基に、COM相互運用機能を用いてExcelファイルを操作する方法を説明します。
　使用しているVisual Studioのバージョンは” Microsoft Visual Studio Express 2012 for Windows Desktop”です。ただし、Visual Studioの旧バージョンとの差は見た目ぐらいですので、特に問題はないと思います。
　.Net Frameworkのバージョン、およびC#のバージョンに依存している記述などについては、その都度言及して、補足を行なっていきます。　以降の章では、サンプルアプリケーションのうち、Excelファイルを操作している部分に着目して説明を行なっていきます。ファイルの存在チェックや出力のフォーマットに関しては、本書の目的とそれるので割愛します。サンプルプロジェクトのソースファイルを見てください。　本章では、C#からExcelを操作する上で一般的に使用される「事前バインディング」方式を用いて、Excelファイルを操作する手順を説明します。
　「事前バインディング」方式とは、文字通り事前に必要なDLLの参照設定を行なっておき、そのDLL使用する方式です。参照を追加するため、コードの補完機能などが使用出来るので、Excelを操作するコーディングを行う上でも一番やりやすい方法となります。
　以下に、「事前バインディング」方式によるExcelファイルを操作する手順を示していきます。　まずは、事前バインディングの名の通り、Excelファイルを操作するためのDLL参照を設定します。
　[プロジェクト]メニュー – [参照の追加]をクリックし、参照マネージャーを起動してください。ソリューションエクスプローラーから見える参照設定の右クリックメニューからでも同様の操作が行えます。
　参照マネージャーの[COM]タブをクリックし、表示されるライブラリーの一覧から「Microsoft Excel XX Object Library」を選択します。インストールされているExcelのバージョンによって、XXの部分に表示されるライブラリーのバージョン番号が異なります。
　参照の追加が行われたら、ソリューションエクスプローラーの参照設定に「Micorosoft.Office.Core」と「Microsoft.Office.Interop.Excel」が追加されるのが見て取れます。

　最後に、バインドした参照のうち、使用するクラスが含まれている名前空間を追加します。追加する名前空間は「Microsoft.Office.Interop.Excel」になります。

　名前空間の追加が正しく行われると、コーディング時にコードサジェストが行われます。
　ここからは、サンプルコードを元に、C#からどのようにExcelを操作するかを説明します。
　操作は主に5ステップ存在します。
　　　1. ファイルオープンなどの前処理
　　　2. シート、セルの領域指定
　　　3. 選択したセル領域から値の取得
　　　4. 取得した値の詰め替え
　　　5. ファイルクローズなどの後処理
　以下、ステップごとに行う処理について説明します。
　サンプルコードの全文はAppendix. 「事前バインディング」を参照してください。　なお、C# 4.0 (Visual Studio 2010)からはデフォルトパラメータを省略できるようになったので、4行目のExcelファイルのオープン処理は、以下のように記述することが可能です。　ExcelのCOMオブジェクト構成は、となっており、操作対象となるセルオブジェクトに到達するまで、上位のオブジェクトから順次取得して行く必要があります。上述の前処理で行ったのは、この内上位3階層分のオブジェクトの取得処理に当たります。　領域オブジェクトを取得する操作は、上記の他にget_Range()メソッドが存在します。
　しかし、get_Range()には後方互換性の不備があり、.NET Frameworkのある特定の更新に限り正常に動作しないというバグが存在します。
　領域オブジェクトを取得する際には、Range[]アクセサーからの取得を推奨します。　領域オブジェクトから、値を二次元配列に格納するという手法は、Excel VBAでもよく使われる高速化テクニックの一つです。領域内のセルをループで取得するのに比べ、格段に早くすることができます。
　なお、たとえ一列しか選択していなくても二次元目の深さが１である二次元配列になります。
　また、配列の添字は１が最初です。要素0へアクセスすると例外が発生するので、注意してください。　ReleaseComObject()／FinalReleaseComObject()メソッドは、COMオブジェクトの参照カウントを1／すべて減らすメソッドです。
　参照カウント絡みの話は割りと深く面倒くさいものですので、今はあまり時間がないけどとにかく使えるようになりたい方は、「COMは、メモリーのalloc()/free()と同様に、使用者が管理するもの」という程度に理解していただければまず十分です。詳しく知りたい方はAppendix. 「COMの仕組み」をお読みください。
　なお、COMオブジェクトが正しく解放されなかった場合、Excelのプロセスが残り続けてしまいます。オブジェクトの解放忘れには十分に注意してください。　以下に、解放を忘れるパターンを示します。この記述を行うとCOMオブジェクトの解放し忘れにつながるため、使用してはいけません。この記述を見つけた場合、速やかに指摘してあげてください。　その他、COMオブジェクトを返すプロパティを、変数へ格納せずに使用している箇所はすべて解放忘れにつながります。発見次第、修正してください。COMオブジェクトを返すプロパティについては、Appendix.「COMオブジェクトを返すプロパティ」を参照してください。　「遅延バインディング」方式とは、DLLやCOM内のクラス・関数を、必要になったときに、必要な分だけ実行時に読み込む機能です。実行時に読み込まれるということは、プログラマーはそのDLLの存在やバージョンについて、実装時に意識する必要がなくなるということになります4。
　バージョンを意識する必要がなくなるため、事前バインディングの時のように、Excelのバージョンに応じてライブラリーを読み込む必要がなく、将来新しいバージョンのExcelが出てきたとしても、プログラムに改変を加えることなくサポートできる可能性が高いということになります。
　以下に、「遅延バインディング」方式によるExcelファイルを操作する手順を示していきます。　サンプルコードを元に、遅延バインディングを使用してC#からExcelを操作する方法を説明します。
　操作自体は事前バインディングと同じ5ステップで、ステップごとに行っている処理も同様のため省略し、ここでは、遅延バインディング独特の構文について説明します。
　サンプルコードの全文はAppendix.「遅延バインディング」を参照してください。
　以下に例として、前処理で行うExcelファイルオープン処理を、遅延バインディング形式で記述したものを示します。　突然摩訶不思議な記述になりましたが、処理の内容自体は事前バインディングの時と何らかわりがありません。Applicationオブジェクトを作成し、Workbooksプロパティを取得し、Workbookをオープンしているだけです。ここでは、その摩訶不思議な部分であるActivator.CreateInstance()、Type.GetTypeFromProgID()、Type.InvokeMember()メソッドの解説を行います。　上述の例のように、基本的にはCOMオブジェクトを操作する処理をInvokeMember()メソッドに書き換えることで、遅延バインディング方式の記述となります。　Excelのバージョンに寄らず記述できる遅延バインディングですが、以下の様なデメリットが存在します。　C# 4.0で導入された、動的言語との連携の仕組みの1つが動的型付け変数（dynamicキーワード）です。動的型付け変数を使うことで、動的な（コンパイル時にメンバー情報がわからない型の）メンバーアクセスが可能になります。このdynamicキーワードを用いると、先ほど指摘した遅延バインディングのデメリットがほぼ解消されます。早速、前処理で行うExcelファイルオープン処理を、dynamicキーワードを用いた記述で見てみましょう。2行目だけ遅延バインディング形式と同じで、あとは事前バインディング方式の時とほぼ同じです。違うのは、変数の型がdynamicになっているだけです。このことから、
1. 事前バインディング形式でExcel操作クラスを実装し、動作確認を行う。
2. COMオブジェクトを格納する変数の型をdynamicへ変更する。
3. DLLの参照を削除する。
という手順を踏めば、Excelのバージョンに依存する事前バインディングの記述を、バージョンに依存しない遅延バインディングに変換できます。　.NET から COM オブジェクトを扱うということは、マネージドからアンマネージにアクセスするということであり、すなわちマーシャリングが必要となります。これは、ランタイム呼び出し可能ラッパー（RCW: Runtime Callable Wrapper）なるしくみによって行われています。

　通常、.NET クライアント（アプリケーション）が直接的に扱うのは、生身の COM オブジェクトではなく、そのラッパーたる RCW です。ランタイム（.NET Framework）によってサポートされるため意識しづらいですが、RCW というプロキシを挟んで COM オブジェクトにアクセスしているのです。これは重要な事実であり、認識しておかなければなりません。
　COMの規定によれば、COMオブジェクトたるもの「自分のメモリーは自分で解放する責任がある」とのこと。そして、それを実現するためには、参照カウントというテクニックが用いられます。参照カウントとは、その COMオブジェクトが他からどれだけ参照されているかを示す数値です。COMオブジェクトは、自分が使ったメモリーを自分で解放するために、自身への参照数を自分で管理していて、参照数が"0"になったら他からの参照がなくなった（＝用済み）と判断して、自分自身のメモリーを解放してくれます。だけどもそれ故に、いま誰が必要とし、必要としなくなったのかは、使う側から通達しなくてはなりません。
　.NETでメモリー管理といえばガベージコレクション（GC）です。COMオブジェクトを内包するRCWは、マネージドであり、もちろんGCの管理対象です。しかし、COMオブジェクトは、自分のメモリーは自分で解放する責務を負っています。ここに、メモリー管理のアプローチの違いからくるミスマッチが生まれています。RCWはGCの管理下にありますが、内包するCOMオブジェクトがGCの対象ではないので、結局、アプリケーション作成者が RCW を通じてCOMオブジェクトが使用するメモリーを、参照カウントというしくみで管理しなければならない、ということになっています。
　管理するとは、つまり、RCWをすべて変数に保持しておくということであり、そしてその参照カウントをデクリメントするのがReleaseComObject()メソッドです。VBScriptだとこれだけですむのに…C#だとごらんの有様だよ！上記例を見ればわかるように、処理の本質ではないコード、タイプ量が激増しています。これだけでも十分面倒くさいのに、実は例外発生時にも確実にデクリメントを行うためには、RCWを生成するごとにtry～finallyをしてやらなければいけません。詳しくはこちらの記事を参考にして頂きますが、こうなると、超絶ネスト構造の一丁上がりです。意味がわかりません。しかし、COM相互参照を使用するということは、本来はこういうことを行う必要があると理解してください。簡単に言うと、アプリを外から操作する技術 ↩COMを使用して開発されたソフトウェア ↩「13」は忌み数なので欠番 ↩実行時にDLLが存在しないと行けないし、バージョン依存の記述もあるでしょうから、一概にすべて意識する必要がなくなるという訳でもないですが…… ↩


