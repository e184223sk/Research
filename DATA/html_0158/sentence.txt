C#では通常、コンパイル時にすべての呼び出しがチェックされ、無効なものがあればコンパイルエラーとなります。
例えば、object型にはToStringメソッドが含まれますが、GetStringのように書き間違えてしまった場合などはこのチェックによってコンパイル時に発見することができます。
一方でJavaScriptやPythonのような動的な言語では、コンパイル時に呼び出しが間違っていてもスルーされてしまいます。というかそもそもコンパイル言語ではないですが…（IEDなどではエラー表示になるかもしれませんがそれとは関係なく、「実行」することはできてしまします）これはC#をはじめ静的な言語が安全といわれる要素の一つであり、非常に有難い機能なのですが、時にこれが邪魔になってしまうことがあります。そこでdynamic型を使うと、（見かけ上）コンパイル時のチェックをスルーすることができます。しかし、これはあくまでC#の機能であり、コンパイラが良しなに「文字列によるアクセス」に変換してくれているだけにすぎません。
具体的にどのような変換がなされ、プログラマはそれをどのように制御すればよいのか見ていきます。普通のオブジェクトインスタンス実体をdynamic変数に入れたときの挙動です。（実体がDynamicObjectの派生オブジェクトではない）機能としては、メンバの名前チェックをスルーし、実行時リフレクションによる文字列解決されます。メンバが特定されると、アクセス処理が動的に生成され（DLR）それでアクセスされるとのことです。（ちなみに、動的生成は最初の一度のみで、二回目からはキャッシュされるとのことです。）dynamic変数へアクセスするとコンパイラにより、以下のような変換が行われます。Binder.InvokeMemberでCallSiteBinderという、リフレクションでいうMemberInfoのようなものを構築し、CallSite&lt;TFunc&gt;.Createでデリゲート化しています。
Binder.cs#L156 CallSite.cs#L192CallSite&lt;TFunc&gt;.Create では、CreateCustomUpdateDelegateが呼び出され、Expression APIでDelegateのILコードが動的に生成されキャッシュされます。どのようなコードに対応するデリゲートを生成しているかは、コメントに記載されています。
CallSite.cs#L358二段構えのキャッシュになっているのと、最適化のためなのか分かりませんが結構読みづらい処理になっていますが、要約すると…つまり、ここまでは前座ということで、実際の呼び出しの部分をどうするかはこの先ということになります。ここで出てくるthis.Binderが、★マークのbinderになります。そしてこれはRuntimeが提供するNativeのAPIのようです。
Dynamicが呼び出し部分のコードをキャッシュしてくれるというのは「この先（C++）でキャッシュされている」ということでしょう。
該当のCppコードはこちらになると思われます。（本当にキャッシュする処理が入っているかは未確認）
Binder.cs,22C#のdynamic変数は、中身のオブジェクトが特定の型やインターフェースを実装していることで任意のふるまいをさせることができます。
詳しくはこのPDFにかかれています。DynamicObjectとIDynamicMetaObjectProviderというのがあるのですが、単純なDynamicObjectについてみてみましょう。デフォルトと同じです。これらが空の仮想メソッドとして実装されているので、必要なものについてオーバライドすることで任意のふるまいをさせることができます。例えば、デフォルトのdynamicはプライベートメンバにアクセスすることはできませんが、上記をプライベートを貫通するリフレクションで実装しプライベート貫通式dynamicを作ることができます。（実装例）dynamicの内部実装と、カスタマイズの仕方を見てみました。とはいえ、コンパイラチェックを回避してしまうのでIDEの支援をうけられない、実行するまでtypoに気が付けないなどのデメリットがあります。
使うべきところはテストや普段書き換えが発生しないようなコードに限定するべきで、できるだけインターフェイスやコード生成で代替しておくのがベターだと思います。


