More than 1 year has passed since last update.C#で複数のTaskを待つ時はTask.WhenAnyを使用します。これでもできなくはないのですが3個以上のタスクを待ちたくなった場合や戻り値がある場合は少し面倒です。golangの場合、複数のchannelを待つ場合は以下のように書けます。重い処理が完了するのを待ちつつ100ミリ秒ごとに定期処理をする場合は以下のように書けます。C#でも似た使い勝手でC#らしさを残した書き方ができないか考えました。
最終的に以下のようになりました。すこし奇妙なコードですがgolangとだいたい同じになりました。
awaitを使用しているのがC#らしさでしょうか。動くコードはここのサンプルにあります。
(テストしていないのでバグってるかもしれませんが…)この機能を解説する上で重要なポイントは非同期メソッドとAwaiterの連携です。C# 7.0から非同期メソッドの戻り値として任意の型を返すことができるようになりました。
MochiTask.Switchに渡す非同期メソッドの戻り値の型がSwitchCase&lt;T&gt;になっています。
SwitchCase&lt;T&gt;はメンバ変数として非同期メソッド内で初めてawaitされたISwitchCaseCondition型の変数を持っています。
ISwitchCaseConditionはc.Caseの戻り値であり任意の一つのタスクを持ちます。
また、外部から継続を実行/キャンセルを差し込む機能を持っています。MochiTask.Switchは複数のSwitchCase&lt;T&gt;からISwitchCaseConditionを取り出し、完了しているISwitchCaseConditionには継続を、完了しなかった側にはキャンセルを差し込みます。
これによって複数のタスクから一つだけを選択して継続を実行するということを実現しています。実用的かと聞かれると微妙ですがなかなか面白いのではないでしょうか。
サンプルを見てすぐに実装が思い浮かんだ人はとても強いと思います。
(あまり需要がないと思うので)解説は適当に書きましたが興味があれば以下のソースを見てみてください。


