More than 3 years have passed since last update.本エントリーは某社内で実施するデザインパターン勉強会向けの資料となります。
本エントリーで書籍「Java言語で学ぶデザインパターン入門」をベースに学習を進めますが、サンプルコードはC#に置き換えて解説します。
なお過去分はこちら第一回：Iteratorパターン
第二回：Adapterパターン
第三回：Template Methodパターン
第四回：Factory Methodパターン
第五回：Singletonパターン
第六回：Prototypeパターン
第七回：Builderパターン
第八回：Abstract Factoryパターン
第九回：Bridgeパターン
第十回：Strategyパターン
第十一回：Compositeパターン
第十二回：Decoratorパターン
第十三回：Visitorパターン
第十四回：Chain of Responsibilityパターン
第十五回：Facadeパターン
第十六回：Mediatorパターン
第十七回：Observerパターン
第十八回：Mementoパターン
第十九回：Stateパターン
第二十回：Flyweightパターン
第二十一回：Proxyパターン
第二十二回：CommandパターンInterpreterとは、英語で解釈者、説明者、通訳者といった意味を持ちます。
Interpreterパターンは、実装言語とは異なる何らかのフォーマットで記載された命令を解析して、言語の文法をオブジェクトで表現するパターンです。主に二つの方向性があると考えます。典型的なInterpreterパターンの構造は以下の通りです。Contextが「実装言語とは異なる何らかのフォーマット」で記載された実態を表します。
それをAbstractExpressionのConcreteクラスであるInterpreterが解析しつつ実行します。
Clientは処理を呼び出し元になります。逆ポーランド記法を利用した四則演算などをよく見かけますが、ここではXMLで記載された四則演算を実行する例を紹介しましょう。
なぜXMLか？文字列のパースが楽だからです。今回のパターンの本質は難しいインタープリター言語の実装ではないため、パースはできるだけ楽をします。次が実際のXMLで書かれた四則演算です。普通に+-書いた方が圧倒的に短いだろうという突っ込みは禁止です。四則演算がXMLでツリー上に定義されており、ツリーを下から遡りながら演算します。演算はElementの名称が表します。つまり上のXMLは次の計算を表します。
(3 - 1) + ((6 / 2) * 5)
17が計算できれば成功です。という訳で、次がそのクラス図になります。CalcExpressionがコンポジットパターンになっているのが見て取れます。XMLからContextを読み込み、ContextからIExpressionを生成します。
その後、IExpressionを実行して結果をコンソールへ出力しています。
XMLからオブジェクトへのデシリアライズにはXmlSerializerを利用しています。XMLで表現された四則演算言語のオブジェクトに解釈するクラスです。
BuildExpressionメソッドでXMLの構文を解析してIExpressionを構築しています。計算方法を表すメソッドです。四則演算を実施するクラスです。
引数で渡されたCalcMethodに従って計算を実施します。定数以下に公開しています。https://github.com/RJ-DesignPattern/DesignPattern/tree/master/InterpreterPattern


