More than 5 years have passed since last update.C++経験者がC#を書くためのチートシート（自分用）
Unityを意識してるので基本的にはC#ver4まで対応オブジェクトは、誰からも参照されなくなったらガベージ コレクションの対象になる
この時点をもって、オブジェクトの寿命は尽きるC#の型には大きく分けて値型、参照型のタイプがある値型 = その型の値を直に保持参照型 = 値の参照を保持特定の値しか取らない型を表現var キーワードを用いて型を自動判別して暗黙的に型付けされたローカル変数を定義
あくまで型の自動判別であって、 任意の型の値を代入できる万能な変数を作れるわけではない
したがって、初期値を伴わない宣言は（型の自動判別ができない）エラー文字どおり名前の無い型(クラス)
クラスを定義せずに、その場でインスタンスを生成できる
内部的には型が自動生成されている
自動設定された型のプロパティには set アクセサーは無いので読み取り専用になる他のクラスのプロパティを初期化子に渡す場合は「プロパティ名 =」の部分を省略できる
（初期化子で渡したプロパティの名前がそのまま匿名クラスでも使われる）値型の型名の後ろに ? を付ける事で、元の型の値または null の値を取れる型になる値が null かどうかを判別し、null の場合には別の値を割り当てる動的型付け変数を定義dynamic 型を使うことでダックタイピングが可能
同じ名前のプロパティやメソッドを持っているなら何でも同列に扱える静的な型の情報（名前）は typeof 演算子を用いて取得することができる動的な型の情報（名前）は GetType メソッドを用いて取得することができる文字列に対して + 演算子を用いることで文字列の連結を行える指定された形式に基づいてオブジェクトの値を文字列に変換し、別の文字列に挿入書式指定'' や "" の前に @を付けると \ とそれに続く文字がエスケープシーケンスとはみなされず、
普通に \ 記号として解釈されるnew で配列の実体を作成配列の初期化時の、「new 型名[]」の型名を省略することが可能
配列の型は、{} の中身から推論される「四角い多次元配列」は全ての行の列数が同じ「配列の配列」は各行で列数が異なっていても構わない配列と同じような初期化記法を、任意のコレクションクラスに対して行うことができる
（内部的にはAddメソッドが呼ばれている）IDictionary のような辞書クラスに対しても可能foreach を使うことでコレクションのすべての要素を1回ずつ読み出すことができるforeach 文は実際にはこのような形に展開されている
IEnumerable インターフェースを介して要素へのアクセスを行っているforeach で利用可能なコレクションを返すメソッドやプロパティを簡単に実装できる
yield return、yield break を含むブロックをイテレーター ブロックと言う戻り値の型が以下のうちのいずれか
・System.Collections.IEnumerator
・System.Collections.Generic.IEnumerator
・System.Collections.IEnumerable
・System.Collections.Generic.IEnumerablefor 文や while 文を使わず、ベタに yield return を並べても OKデリゲートとは、メソッドを代入するための変数の型（関数ポインタに近い）
メソッドを変数に代入したり、関数の引数や戻り値にすることができる
述語やイベントハンドラ等に利用するインスタンス（非static）メソッドの場合複数のメソッドを代入すると全てのメソッドが呼び出されるデリゲートを使う際にメソッドを定義しなくても名前のないメソッドを記述できる匿名メソッドを簡単に書くことが出来るメソッドを呼び出す際に値の参照情報を渡す
メソッドの引数に ref を付けることでその変数は参照渡しになるout を付けることで出力用の参照引数であることを明示する関数呼び出し時に引数名と値を指定する事で任意の順番で引数を指定できる
デフォルト引数で任意の箇所を省略可能にする事ができるparams というキーワードを使って可変個の引数を取るメソッドを定義することが出来るC# では、基底クラスを指定せずに作成した型は全て自動的に object 型を継承される
object 型には Equals、ToString などの機能があるC#のクラス継承では、1つのクラスしか継承できない（多重継承を認めていない）仮想メソッド virtual 修飾子をつける
オーバーライドする際には override を明示的に付ける必要がある抽象メソッド（C++での純粋仮想関数）は abstract 修飾子をつけるインスタンスを作成できない抽象クラスクラス外部から見るとメンバー変数のように振る舞い、内部から見るとメソッドのように振舞うユーザー定義型のオブジェクトでも、 配列と同じように a[i] という形での要素の読み書きができるconst 以外に、もう1つ定数のようなものを実現する方法がある
readonly というキーワードを用いて、読取り専用（read only）の変数を定義できるconst との違いクラス定義時に sealed をつけることで、 継承を禁止することができる静的メンバーしか定義できないクラスを作ることができる静的フィールドの初期化には、通常のコンストラクターではなく、静的コンストラクターを使う
static キーワードを付ける以外は通常のコンストラクターの定義の仕方は同じ
静的コンストラクターは1度だけ呼び出される（そのクラスのメンバーに初めてアクセスした時）拡張メソッドを使用すると、既存の型に変更を加えることはなく、型にメソッドを追加できる
拡張メソッドは、インスタンスメソッドと同じ形式で呼び出せすことができる列挙型 にも使用可能インターフェースにも使用可能オブジェクトと、指定した型との間に互換性があるかどうかをチェックするオブジェクトと、指定した型との間に互換性がある場合はダウンキャストを行う
互換性が無い場合にキャスト演算子は例外を発生させるが、as 演算子は　null を返す属性（attribute）とはクラスやメンバーに追加情報を与えるもの
C# では自分で属性を定義し、クラスやメンバーに付加することができる
属性を用いることで、コンバイラに対する指示を行ったり、クラスに情報を残すことができる属性の情報は、以下のような場面で使われる属性は [] でくくり、 クラスやメンバーの前に付ける例として、Conditional 属性を使用
Conditional 属性は、特定の条件下でのみ実行されるメソッドを定義するために使用される, で区切るか、複数の [] を並べることで複数の属性を指定することができる標準ライブラリによって提供されている定義済み属性
コンパイラへの指示になっていて、コンパイル結果に影響を及ぼす属性を付ける場所によって属性の対象は変わるしかし、属性を付ける位置によっては属性の対象が曖昧になることがある
曖昧さを解決するため、 明示的に属性の対象を指定する構文があるSystem.Attribute クラスを継承することで新しい属性を自作することができるリフレクション機能を用いて属性情報を取得することができる++C++; // 未確認飛行 C


