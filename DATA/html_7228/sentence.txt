More than 5 years have passed since last update.こんにちはー！ニアです。今回は、IEnumerable&lt;T&gt;型のシーケンスから、任意の要素数ごとに分割したIEnumerable&lt;T[]&gt;型のブロックシーケンスを作成する方法を紹介していきます。※この記事で登場する「T」は、ジェネリクスにおける要素の型です。オーソドックスな方法としては、シーケンスを配列に変換しておき、for文を使って配列の先頭から順に要素を取り出し、ブロックに代入していきます。ブロックの代入先で指定するインデックスは、シーケンスのインデックスからブロックの長さで割った余りとなります。ブロックの各要素に値を全てセットした or インデックスがシーケンスの末尾に達した時、yield return文でブロックを返し、ブロックシーケンスを生成します。注：配列は参照型なので、yield return文でブロックを返した後、次のブロック用に配列を再作成する必要があります。「C#でコレクションの列挙にfor文だなんて、センスないZE！」というナウでヤングなアナタに、LINQはいかがでしょう。Selectメソッドには、シーケンスの各要素にインデックスを付けて射影する機能があるのでそれを利用して、インデックスをブロックの長さで割った値をキーに、要素の値とのペア（KeyValuePair&lt;int, T&gt;型）を生成します。次にGroupByメソッドでキーの値ごとにグループ化し、各グループに属する要素の値を抽出して、それらをSelectメソッドで配列に変換します。例えば、以下のような問題が出たとしましょう。「長さが不定のシーケンスを、n個ずつに分割したブロックシーケンスに変換せよ」1.1.にあるToArrayメソッドや、1.2.にあるGroupByメソッドでは、実行時にシーケンス内のすべての要素を列挙するので、長さが分からないシーケンスを扱うには、呼び出し側から必要なブロック数に応じてシーケンスの要素を列挙できるようにひと工夫が必要です。そこで、Selectメソッドでシーケンスの各要素に付加したインデックスをブロックの長さで割った余りをキーに、要素の値とのペア（KeyValuePair&lt;int, T&gt;型）を生成します。次にforeach文で各要素を列挙し、要素のキーをブロックのインデックスとして指定し、要素の値を代入します。要素のキーがブロックの末尾のインデックスと等しい時、ブロックを返します。しかし上の方法では、シーケンスの要素数が1ブロック当たりの要素数で割り切れない場合、末尾のブロックは切り捨てられてしまいます。そこで、ブロック内の現在のインデックスを格納する変数を1つ作成し（初期値はブロック内の末尾のインデックス）、foreach文を実行後、その変数の値がブロック内の末尾のインデックスより小さい時は、ブロックを返します。これで末尾側の要素を含むブロックももれなく返すことができます。さらにbool型引数を1つ追加し、利用者のニーズに合わせて、ブロックの長さに満たない末尾のブロックを「含める or 切り捨てる」かを選択できるようにすると、使い勝手が向上します。逆に、IEnumerable&lt;T[]&gt;型ブロックシーケンスからIEnumerable&lt;T&gt;型のシーケンスに平坦化したい時は、SelectManyメソッドを利用し、各ブロック内の要素を1つずつ取り出します。RNAの塩基配列からコドンに変換し、コドン表を利用して対応するアミノ酸を求めるプログラムです。文字列で表したRNAの塩基配列から、3つずつ要素を分割して（IEnumerable&lt;char&gt; ⇒ IEnumerable&lt;char[]&gt;）コドンへ変換し、コドン表に従ってアミノ酸に変換していきます。◆ 実行結果
Codon      : AUG-AUG-GAG-CUU-CGG-AGC-UAG
Amino acid : Met-Met-Gln-Leu-Arg-Ser-[E]今回は、IEnumerable&lt;T&gt;型のシーケンスから、任意の要素数ごとに分割したIEnumerable&lt;T[]&gt;型ブロックシーケンスを作成する方法を紹介しました。3.のサンプルプログラムでは、タンパク質の分野で例に示しましたが、他にも情報セキュリティの分野にて、「ブロック暗号で暗号化するためにbyte型配列の平文を8バイト（64ビット）や16バイト（128ビット）ごとに分割する」という用途に応用することができます。それでは、See you next!


