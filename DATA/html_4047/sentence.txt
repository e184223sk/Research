More than 1 year has passed since last update.List＜T＞クラスについて、あれやこれや書きたいと思います。「普段何気なく使ってるけど、言われてみれば中身とか全然知らんわ。」「でも改めて考えると、すごく気になってきた。」っていうちょっと変わった人向けです。ほぼ全部独学で書いたので、間違ってたら指摘してください。CからC#に移って来た人間が一番最初に感動するやつ(私が証明です)ざっくり言うと、サイズの管理をしなくてもいい配列(多少の語弊あり)C#でそれなりの規模のプログラムを組んでいれば絶対に1度はお世話になる(はず)mscorlib.dll → System.Collections.Generic名前空間の下にあります。ソースコードは↑でも見れるし、デコンパイルしても見れるよ。ジェネリクス（ジェネリック）と呼ばれている凄いヤツです。型だけ違っていて、中身は同じであるような一連の処理があったときに、型をパラメータにとり、さまざまな型に対応したクラスや関数を作るためのものになります。List&lt;string&gt;とかList&lt;int&gt;とかList&lt;MyClass&gt;とかやると思いますが、このstringとかintとかMyClassとかが型をパラメータにとりの部分。どれも複数の値をまとめるものなので、型だけ違っていて、中身は同じ。配列です。private T[] _itemsで中身を管理してます。なのに簡単に要素を増やせるし、減らせる。素晴らしいですね。厳密に言えばしなくていい訳ではないです。List側で勝手にやってます。なので、利用者はあまり気にすることなく使えます。具体的には_items.Lengthと private int _sizeとpublic int Capacityの3つの要素でサイズを管理しています。Listを使うときによく使うCount(プロパティ)ですが、となっているので、_sizeと同じです。ちなみにCountメソッドってのもありますが、Listクラスに定義は存在しません。拡張メソッドと呼ばれる機能を使って、Enumerableクラスに定義されてます。こいつの話をしだすと、IEnumerable&lt;T&gt;とか、Funcデリゲートとか、ラムダ式とか、LINQとか、色々話が広がりすぎるので今回は割愛します。ソースコードは、System.Core.dll → System.Linq名前空間の下にいます。こっちはGitHubにおいてあります。[]で要素を取得・設定する処理のコードです。このメソッド自体はインデクサーと呼ばれるC#で用意されている機能です。indexがsizeより大きい場合や0以下の場合、ArgumentOutOfRangeExceptionが発生します。要素追加用メソッドAddです。こいつは4段階の構成になっています。4段階目のArray.Copyは、配列をコピーするメソッドです。後で詳しく説明しますので、この段階ではそんなもんかと思っていてください。つまりListは「サイズを無視して要素を追加できる配列」ではなく、「サイズが足りなくなったら自動で作り直してくれる配列」なんです。実に優秀なお方ですね。上記の理由から、Addを大量に呼び出す場合は、あらかじめCapacityを自分で設定しておいたほうがパフォーマンスに優れます。(配列の新規作成や要素のコピーには時間がかかる)というわけで、早速測ってみました。リストに0から1億個数字を追加した時の差がこれくらいでした。これを大きいと見るか、小さいと見るかは人それぞれですが、個人的にはそんなに大きくないと思います。1億もデータがあったらもっと遅い処理がどこかにあるはずなので、誤差レベルじゃないかと。ですが、シビアなパフォーマンスを求められる局面に出会ったら思い出してください。要素削除用メソッドRemoveAtです。こいつの構成は2段階です。ぱっと見て、分かりにくい処理です。(1)から順に追っていきましょう。ここは特に言うこともありません。indexがsizeより大きい場合や0以下の場合、ArgumentOutOfRangeExceptionが発生します。_size--でListのサイズを1つ小さくします。問題はその次です。Array.Copyの中身はCopyですが、このCopyの中身は見ることができません。こいつはC++で書かれてるDLLを参照しています。仕方がないので、皆大好きMicrosoft公式リファレンスにて、Array.Copyの仕様を調べます。Copy(Array, Int32, Array, Int32, Int32)Copies a range of elements from an Array starting at the specified source index and pastes them to another Array starting at the specified destination index. The length and the indexes are specified as 32-bit integers.指定されたコピー元インデックスから始まる配列から要素の範囲をコピーし、指定されたコピー先インデックスから始まる別の配列にそれらを貼り付けます。 長さとインデックスは32ビット整数として指定されます。ArrayThe Array that contains the data to copy.Int32A 32-bit integer that represents the index in the sourceArray at which copying begins.ArrayThe Array that receives the data.Int32A 32-bit integer that represents the index in the destinationArray at which storing begins.Int32A 32-bit integer that represents the number of elements to copy.パラメーター
sourceArray
アレイ
コピーするデータを含む配列。sourceIndex
Int32
コピーが開始されるsourceArray内のインデックスを表す32ビット整数。destinationArray
アレイ
データを受け取る配列。destinationIndex
Int32
保存が始まるdestinationArray内のインデックスを表す32ビット整数。長さ
Int32
コピーする要素の数を表す32ビット整数。日本語部分がGoogle翻訳にぶん投げた結果です。つまり_itemsの index + 1インデックス目から_size - index個の要素を、_itemsのindexインデックス目を開始位置としてコピーする処理ってことですね。そして最後に、隙間をdefaultで埋めて終わりです。表を使って詳しく説明します。List＜string＞の中身だと思ってください。この時_sizeは6です。このListからcを消したいと思います。RemoveAt(2)を実行します。indexは2です。index &lt; _sizeなので(1)で例外は発生しません。(2)の最初で_sizeが5になります。よって、index+1 =&gt; 3_size - index =&gt; 3となるので、_itemsの3インデックス目から3個の要素を、_itemsの2インデックス目を開始位置としてコピーします。このままでは最後に不要なデータが残ってしまうので、一番最後をdefault(string)、空文字で埋めます。無事に、cを消すことができました。ちなみに(2)でif (index &lt; _size)と判定してます。これはindexと_sizeが同じ(=一番最後の要素を削除したい)場合、一番最後をdefault(T)で埋めるだけでいいからです。ここで1つ大事(かもしれない)事です。要素を削除した時、配列のサイズは変わらないんです。なので、大量の要素を削除した時、配列の後ろに大量の空の部分が出来上がります。中身は空でもメモリは消費するので、気をつけてください。今どきそれほどシビアなメモリ管理が必要なことはあまり無いとは思いますが。Listクラス内で発生する可能性のある例外たちです。出現頻度は、1 &gt;= 2 &gt; 3 &gt;&gt;&gt;&gt; 4 &gt;&gt;&gt;&gt; 5です。(当社調べ)ここでは出現頻度の低い4,5は割愛します。要素の取得時や削除時に、_sizeより大きな値や0未満の値を設定すると発生します。よく初心者が「要素が6なんだから最後は6番目やん、list[6]っと」と言って踏み抜くやつです。引数にnullを設定して一部のメソッドを呼び出すと、発生します。「いちいちAddなんてやってられんわ、AddRange使ったろ」と言ったときに、引数を初期化し忘れて踏むことがあります。上2つはそのままですが、こいつは少しややこしいです。直訳すると「無効な操作による例外」です。無効な操作ってなんやねん。良く見るパターンはこんな感じのやつです。foreachの中でListに手を加えてしまったパターンです。”コレクションが変更されました。列挙操作は実行されない可能性があります。”と言われてしまいます。列挙操作、つまり1つ1つ数え上げている途中で変えられてしまうと、どこまで処理を行ったか分からなくなってしまいます。もしこれを許可してしまった場合、このように確認されない部分が出てしまいます。これでは困るので、foreachの中では要素の変更ができないようになっています。InvalidOperationExceptionの説明の中に、”コレクションが変更されました。列挙～”とありました。コレクションの変更をどうやって管理してるのかもついでに解説します。とはいえ、実は答えの半分は既に出ていたりします。要素の取得・追加・削除の解説内に_version++という処理がありました。こいつを使っています。ForEachメソッドです。一般的に広く使われているforeachとは別物になります。色々と分からない箇所があるとは思いますが、コメントのすぐ下の行だけ見てください。これによりAddやRemoveAt等が実行されると_versionとversionにズレが生じる仕組みになっております。foreachも似たようなことをやっています。(詳細を解説しようとすると長くなるので割愛)2019/01/15 この辺について書いて見ました。「Enumerator構造体ってなに？」の辺りで触れています。ここまで大量に書いておいてなんですが、C#でプログラミングする上で、ここに書いてあることの9割は不要です。プログラミング言語ってのは、「何か」を作るための道具の1つです。道具の仕組みを知らなくても、使い方さえ知っていればその「何か」は作れるわけです。ボールペンからインクが出る原理がわからなくても字は書けるし、どうやって電話が音を伝えているか知らなくても遠くの誰かとお話できるわけです。ちなみにこの考え方はオブジェクト指向でよく出てくるカプセル化と呼ばれるものです。複雑なもの(配列の長さの管理等)は中に隠し、外に見えるのは簡単な操作(取得・追加・削除等)のみにすることで誰でも利用可能になっています。もちろん知っておいて損することはありません。シビアなメモリ管理やパフォーマンスを求められた場合に役立つ可能性はありますし、こうやって長々と記事を書いて暇を潰すことも出来ます。ただ費用対効果に見合っているかと言われると......疑問ですね。よくプログラミングの世界では「おまじない」とか「動いてるからよし」とか「そういうものです」とか言われることがあります。自作の機能だとマズいですが、C#にはじめから用意されている機能だったらそれでいいと思います。でも中には「いや、そんな事言われても納得できんぞい。」と考える変わり者がいてもいいでしょう。そんな変わり者が僕以外にいるかどうかはわかりませんが、「いたら嬉しいなぁ」というのが動機です。人は生まれながらに、知ることを欲する。　アリストテレス(古代ギリシア)かっこつけてアリストテレスとか言ってますが、元ネタはトリビアの泉です。もし次回以降があれば、今回割愛したIEnumerable&lt;T&gt;とか、Funcデリゲートとか、ラムダ式とか、LINQとかその変の話もしたいと思ってます。


