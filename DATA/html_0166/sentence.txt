C#のラムダについて勉強したことをまとめる。
Java8での場合についても記載する。以下の例題でラムダへの経緯について記述する。例題：Stringの配列に対して、文字列の長さでデータを抽出する。上記の例ではサイズが2より大きいものを抽出しているが、3以下の場合を抽出したい場合に、対応できない。
「if (val.Length &gt; 2)」の2を引数にすることはできるが、以上、以下、などの等号を変更することができない。delegateを使うことにより式を渡すことができるようになった。
そのため、3以下を抽出したい場合は以下の用にCheck2メソッドを作成して、それを渡せばよい。上の例では、メソッドを作る必要があり、メソッド名を考える必要がある。
また、呼び出している「GetData(values, Check2)」と実際の宣言が離れているので、何をやっているかがわかりにくいという問題がある。その問題を解決したのが匿名メソッド。匿名メソッドは.NET 2.0で導入された。.NET 2.0でジェネリックが導入され、その結果、bool Predicate&lt;in T&gt;を使えばdelegateの宣言も不要になった。匿名メソッドで「delegate(string s) { return s.Length &lt;= 3; }」と書いていたのをラムダ演算子「=&gt;]
で書くと以下の用になる。ラムダ式は.NET 3.0で導入された。
ラムダ演算子は「Goes to」(ゴーズ・トゥ)と読む。
左側がパラメータで右側が式or文今回のサンプルについては、以下のコードでも同じ結果になる以前は「delegate(string s) { return s.Length &lt;= 3; })」のように「delegate」と「string」を書いていたが不要になった。
「GetData(values, s =&gt; s.Length &lt;= 3)」の第二パラメータは「private string[] GetData(string[] values, Predicate check)」とstring型であることがわかるため。なお、以下の用に書いてもエラーにはならない。パラメータが0個の場合は()が必要。パラメータが1個の場合は()は不要。あってもOK。パラメータが複数の場合は()で囲ってカンマで区切る。Funcは戻り値あり、Actionは戻り値なし。Func&lt;T,T,Tresult&gt;で山かっこの最後が戻り値の型。パラメータの数は上限が16個。
Funcが出来たので、Predicateは使わなくなった。重たいメソッドに対して、開始と終了のログを出力して、非同期で動かすサンプル。Linqは遅延実行だが、ちょっとわかりにくくてバグに繋がる可能性もあるので整理する。サンプルとして、１～１０の数値を５倍して、偶数だけを抽出し、その合計を出すプログラムを作成した。ループの中でConsoleに出力するようにしているが、「最初に値を５倍にする処理を行って、それが終わってから抽出する処理を行って・・・」という動きになっていない。
SumNumber処理で必要になってから処理が実行されている。（遅延実行）即時実行するためにはToArrayやToListを付ければよい。直観的にわかりにくい。以下の例では2,4,6,8という値が入ったリストに対して5以上のものを抽出している。
6と8だけ抽出されるのではなく、そのあとに追加された7も抽出されるので注意。5-1にあるnumber5やevenは実体を持っていない。必要になったときに呼ばれて値を返すだけ。


