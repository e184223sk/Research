More than 3 years have passed since last update.　運用者はシステムでエラーが発生した際に、プログラムから出力されたログを見て原因の特定作業を行います。このとき重要となるのが例外処理です。適切な例外処理が行われていれば、原因の特定が容易になります。
　ここでは、こんなことをされたら運用者が困るという例を見ていきます。使用している言語はC#です。　例外メッセージはエラーの内容を表す重要な情報です。どのような問題が発生したかがひと目で分かるような情報を記述しましょう。「例外が発生しました。」「処理エラー」「Fatal」といったメッセージではどのような例外が発生したを知ることはできません。
　「良い例」では手書きでメッセージを記述していますが、throw new ArgumentNullException("name");と書いても同じようなメッセージが出力されます。出力されるメッセージのフォーマットが整っていると、ログが把握しやすくなる場合があります。　「悪い例」では発生した例外に対して処理を何も行っていません。本来は例外内容のログを残すか、上位層に例外を再スローしログ処理を任せるかの、どちらかの処理を行わなければいけません。ログがなければどのようなエラーが起きたのか分かりません、ログは必ず残してください。　「悪い例」は一見問題なさそうに見えますが、この処理ではキャッチした例外のStackTraceが消えてしまうという問題点があります（C#の仕様です）。StackTraceが消えてしまうと例外がどこで発生したのかが分かりません。「良い例」のようにthrow;と書くとStackTraceを消さずに再スローすることができます。　"throw;"の記述はCatch句でしか行なえません。Catch句外で例外を再スローするとスタックトレースが消えます。.NetFrameWork4.5以降ではExceptionDispatchInfoクラスを上記のように利用することでスタックトレースを保持したまま例外の再スローが行えます。　catch (Exception ex)はすべての例外をキャッチします。そのため本来はシステムを止めなければいけない例外が発生した場合でも、処理が続行されることとなり、リカバリが難しい状況におちいることがあります。　改善方法の一つとして、例外を再スローする方法があります。より上位のCatch句に例外処理をゆだねることで、エラーが出たまま処理が続行されることを防ぎます。　他の方法として、特定の例外しかキャッチしないという手があります。こうすることで、続行不能な例外は上位のCatch句で処理されます。　例では例外が発生するメソッドがcatch句に書かれています。ここでprocess.Kill()において例外が発生した場合、try句で発生した例外が上書きされ、本来の例外発生原因が上位の例外処理部分にうまく伝わりません。
　基本的に例外が発生する可能性のあるメソッドはcatch句、finally句に記述してはいけません。　catch句は本当に必要な箇所以外には書かないようにしましょう。
　運用時に負担にならないよう気をつけましょう。


