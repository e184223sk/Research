More than 3 years have passed since last update.ILのこねかたについて、多少は実用的な例を題材に入門してみます。多少は実用的ということで、よくあるケースとして高速なリフレクション用のインターフェースを実装してみます。具体的には次のようなインターフェースを用意しておき、その実装クラスのコード生成を行います。とりあえず今回はIActivatorの方について。黒魔術師の弟子達よ！！(ILによる動的なコード生成に興味はあるけど、どこからはじめていいかわからないみなさん)ConstructoInfoも元に、高速なオブジェクト生成を行う処理を動的に生成します。ILを使った動的なコード生成処理を作成する場合、お勧めの方法は完成形のコードをC#で書いてみてそれを逆アセンブルして内容を確認し、その再現を行うという方法です。例として、以下のような生成対象のDataクラスとそれを生成するIActivatorをサンプルとして書いてみます。SampleDatactivatorはDataクラスをnewして生成しているだけなので、当然リフレクションを使うよりも高速に動作します。このSampleDatactivator相当の内容を動的に作れれば、高速なリフレクションを実現できると言うことになります。サンプルコードをビルドしてその内容をildasm.exeを使用して確認します。この内容を参考にしてに、SampleDatactivator相当の型を動的に生成する処理を書いていきます。まず、動的に生成する型を定義するためのモジュールを用意します。ここで作成したモジュールに型を定義してその実装のILを生成し、最終的にはリフレクションでその型のインスタンスを生成すること形で動的生成されたIActivatorの実装を取得する、っということを行います。型の定義はModuleBuilder.DefineType()で行いますが、その引数に何を指定すればいいのかという話があります。クラス名についてはここでは「生成する対象のクラス名_DynamicActivator」の形にするとして、TypeAttributeにはildasmで確認したのと同じ値を設定します。ildasmでSampleDatactivatorのクラス定義の部分をダブルクリックして開くと、次のような内容が確認できます。public～beforefieldinitまでが型の属性であり、また、この型はIActivatorを実装していることがわかります。ここまでの内容を踏まえて、型の定義部分と、IActivator作成処理全体のコードイメージを記述すると以下のようになります。なお、メンバを実装していないこの時点でコードを実行すると、IActivatorに必要な実装がされていないためCreateTypeInfo()でTypeLoadExceptionとなります。次に、IActivator.Sourceプロパティの定義を行います。ildasmで確認すると、Sourceプロパティに関する内容として以下の項目が定義されていることがわかります。SampleDatactivatorではSourceを自動実装プロパティで記述しています。そのためバッキングフィールドが作成されていますが、ここではわかりやすくするために、自動実装プロパティを使わない形でサンプルを書いて、その内容をidlasmで確認してみます。バッキングフィールドの代わりにsourceフィールドが定義されていることが確認できました。Sourceプロパティの定義では、これらのフィールドの定義、プロパティの定義、プロパティのgetメソッドの定義という3つの定義を行います。型の定義で確認した時の同じように、フィールドの定義を開くと次のような内容を確認できます。この情報を元にフィールドの定義を記述すると次のようになります。これでConstructorInfo型のsourceフィールドが定義できました。フィールドと同様に、プロパティの定義も確認して実装します。プロパティはその定義だけでは駄目で、そのget/setメソッドの定義を行ってプロパティに設定してあげる必要があります。get_Sourceの定義を開くと以下のような内容が確認できます。ここではじめてILが出てきましたが、まずはget_Sourceメソッドの定義とプロパティへの設定を行ってしまいましょう。そしてやっとILの生成の話になりますが、ここでの処理は単純で、this.sourceを返しているだけです。っというわけで、そのままコード化してしまいます。以上で、Sourceプロパティの取得に関する処理はできました。Sourceプロパティはgetオンリーなプロパティなので、コンストラクタでその取得元となるsourceフィールドを初期化してあげる必要があります。これまでと同様に、ildasmでコンストラクタの定義を開くと以下の内容を確認できます。そしてこの内容を元にコンストラクタを定義します。次にIL部分ですが、やっていることはベースクラスであるobjectクラスの呼び出しと、引数へのメンバ変数への保存です。ILの生成コードへ変換すると以下の形になります。そしてIActivatorのメインとなるCreateメソッドの実装についてです。まず、ildasmで内容を確認してみます。とりあえず、これまでと同様にメソッドの定義だけをしてしまいましょう。DefineMethodOverrideでは、このメソッドはIActivator.Createの実装であることを定義しています。そしてILの生成コードは以下になります。やったー、一通りの定義ができたぞ(?)、っというわけで、とりあえず使ってみましょうか。はい、確かにactivator.Create()でDataのインスタンスを取得することが確認できると思います。ただし、Createの引数が無し？、っということで気がつきますが、ここまでの実装だけだとデフォルトコンストラクタにしか対応していません。っというわけで、コンストラクタの引数にも対応するため、新たに以下のようなサンプルを追加してビルドし、逆アセンブルして結果を見ていくことにします。SampleData2Activatorの逆アセンブル結果については、CreateメソッドのIL以外はこれまでと同じなので、ildasmからIL部分だけを抜粋してみます。これだとわかりづらい？、っということで、処理を区切って内容を補足してみます。こからどこまでが何の処理かということについては、ILの知識が十分になくても、引数の数や型を変更してその逆アセンブル結果を比較していくと、なんとなくあたりがつくようになってくるのではないかと思います。更に引数の処理部分を見ていくと、以下の部分は繰り返しになっていることがわかります。unbox.anyとcastclassについては、ValueTypeならUnboxが必要で、ValueType以外は(object型以外は)コンストラクタ引数の型へのキャストが必要だということがわかってくると思います。これをIL生成コードにしていくわけですが、以下の点を考慮してコードを書きたいところです。ILに関する処理については、他でも同様の処理が必要になることが想定されるため、以下のようなILGeneratorの拡張メソッドを用意して記述を行いやすくしたいと思います。ldc.i4の使い分けについては、設定する値によって使用するオペコードを使い分ける拡張メソッドを用意します。型の変化については、下記のような拡張メソッドを用意することで分岐部分の記述を容易にします。拡張メソッドを使用し、コンストラクタの引数に対応したCreateメソッドのILは以下のようになります。以下のようなコードが動作することを確認できると思います。動的生成した型のインスタンスは生成できるが、処理を呼び出してみると動作がおかしかったり、例外が発生したりすることがあるかもしれません。どこかILが間違っているのかもしれないと思った時には、型を定義したモジュールをファイルに保存して、その内容をildasmでサンプルで作ったコードのILとの差異を確認すると問題の把握が容易になると思います。定義したモジュールをファイルに保存したい場合、モジュールの定義は以下のように変更します。また、型の定義が完了後に以下のようにしてファイルに保存します。っということで、こんな風に進めていけば、みんなILの先生になれることがわかったのではないかと思います(｀・ω・´)なお、全体のソースについてはサンプルのEmitFactory.csを参考にしてくださいな。動的コード生成、それも一種の麻疹( ˘ω˘ )そしてコンパイルタイムコード生成もいいもんですよ(・∀・)


