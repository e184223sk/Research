More than 1 year has passed since last update.映画「メイズ・ランナー」を見ていたら、ふと経路探査アルゴリズムを作りたくなってしまいました。2Dでブロックを描画できればよかったので、ぱっと思い浮かんだのはUnityエンジンでした。
しかし、

ご覧の通り、僕のPCにはもうUnityが入る隙がありませんでした。
そこで、致し方なくWinFormに描画することにしました。具体的には、WinFormにPictureBoxを配置してBitmapに描きます。今回は2Dで描画するので、各タイルのとりえる座標は x, y です。
これをより扱いやすくする為に2次元ベクトルとしてクラス化しました。また、例えば2つのベクトルを計算したい時に、とハードコーディングするのはしんどいですし、ミスも誘発しそうです。
ということで、演算子をオーバーロードしました。完全なコードはGithubにもあります。
Github | Vector2.cs思ったよりソースコードが巨大になってしまったので、簡易的に書きます。
完全なコード: Github | World.csタイルは配列に保持しておきます。タイルを保持するための配列のメモリ確保と
ビットマップ上におけるタイルサイズの定義を行います。
そして、空のタイルを敷き詰めておきます。タイルには座標だけでなく探索する際に使用するデータやその他色々な値を格納しておきたかったので、
構造体と挙列型を用意しました。完全なコード: GitHub | TileBlock.csデータ構造:
まず初めに、今回使用するビットマップのサイズ$BS$は360×360です。
また、タイルの最大座標$MS$は25×25です。このときビットマップ上に於けるタイルの縦/横描画サイズ$S$はマップの周りの余白$w$はタイルの位置(左上角)$L$、余白$w$はです。
これを関数で表すととなります。ビットマップ上のマウス座標x,yからタイル座標x,yを算出します。結果のタイル座標$cx,cy$はであると言えます。
これを関数で表すととなります。
コッチの方が美しいですね可読性を求めていたらいつの間にかハードコーディングしてました。データ処理フロー:

ご覧の通り、最短ルートは保証されてません。アルゴリズム(笑)です。
なぜこうなっているかというと、

進んでいる彼は左右上下1ブロックとスコアしか見えてません。
したがって、より良いスコアである右に進んでしまうのです。
しかしながら、全体で見れば左に進むのが明らかに最短ルートです。
こういった場合、左に進んでゴールに辿り着いた場合と
右に進んでゴールに辿り着いた場合の総タイル数を比較してルートを定める必要があります。
また、直線移動しかしません。行き止まりにも対応してません。「最短コースは保証されていないが、最低限の分析でゴールに辿り着ける」
という側面で見れば、ダイクストラ法とAスター法のいいとこ取りだと思います。(言い訳)
また改めて時間があれば、最適化します。といった感じで、中途半端ではありますが経路探査アルゴリズムを作ってみました。
ソースコードはGithubにあります。


