D言語から、C#のソースコードやライブラリを利用したい場合について、その利用方法を考えてみました。D言語からC#の関数を呼び出す際、C++（C++/CLI）を経由するのが簡単だと思っています。
以前の記事でも、１つの実装例を紹介しましたが、他にも連携方式を考えてみましたので、ここにまとめます。EXEファイルやDLLファイルの作成方法で、４つのパターンに分類しました。以下のソースコードは、以下の環境でコンパイルしています。C++、C#のソースコードごとにDLLを作成、D言語のソースコードでEXEファイルを作成するパターンです。C#のソースコードstr.csをD言語から呼び出したいと仮定します。C++（C++/CLI）のintermediate1.cppは、D言語からの呼び出しを中継する役割です。C#のChar型が、Dのwchar型に対応してします。
Dのwstringを変換して、C#に渡すように実装しました。コンパイルは「VS2019用 x64 Native Tools コマンドプロンプト」から実行します。
コンパイルは、以下の順序で進めます。
コンパイルの結果、str.dll、intermediate1.dll、case1.exeが作成されます。C++、C#のソースコードをあわせて１つのDLL、D言語のソースコードでEXEファイルを作成するパターンです。C#のソースコードstr.csは、パターン１と同じものを使用します。
パターン１C++のソースコード１行目は#using &lt;str.dll&gt;でしたが、パターン２では#using &lt;str.netmodule&gt;とします。D言語のソースコードは、パターン１とpragma行以外は同じです。コンパイルは「VS2019用 x64 Native Tools コマンドプロンプト」から実行します。
コンパイルは、以下の順序で進めます。
コンパイルの結果、intermediate2.dll、case2.exeが作成されます。パターン１と同じ実行結果となりました。C#のソースコードでDLL、C++、D言語のソースコードをあわせてEXEファイルを作成するパターンです。C#のソースコードstr.csは、パターン１と同じものを使用します。
C++のcallMyStringClass関数は、VC_DLL_EXPORTSからextern "C"になっています。Dのソースコードはpragma行から、extern (C)ブロックで関数宣言しています。コンパイルは「VS2019用 x64 Native Tools コマンドプロンプト」から実行します。
コンパイルは、以下の順序で進めます。
コンパイルの結果、str.dll、case3.exeが作成されます。mscoree.dllは、C++/CLIから.NETランタイムを呼び出すためのDLLで、mscoree.libはそのライブラリです。
D言語とC++とのABI互換により、mscoree.libをそのまま使用できました。DMDでのコンパイル時の注意事項として、-L=/NODEFAULTLIB:libcmt.libオプションの指定とmscoree.libの指定が必要です。-L=/NODEFAULTLIB:libcmt.libオプションを指定しない場合、warningメッセージと共にEXEファイルは生成されますが、実行時エラーが発生しました。また、mscoree.libを指定しない場合、リンク時エラーとなります。パターン１と同じ実行結果となりました。D、C++、C#のソースをあわせて、１つのEXEファイルを作成するパターンです。C#のソースコードstr.csは、パターン１と同じものを使用します。
C++のソースコードは、パターン２と同じく#using &lt;str.netmodule&gt;とします。パターン４では、C++コンパイラでEXEファイルを作成するため、PhobosライブラリではなくC標準ライブラリを使用するようコーディングしています。コンパイルは「VS2019用 x64 Native Tools コマンドプロンプト」から実行します。
コンパイルは、以下の順序で進めます。
コンパイルの結果、case4.exeが作成されます。Dコンパイラでstr.netmoduleを処理できなかったため、C++コンパイラでEXEファイルを作成する方法をとりました。
D言語からCのprintf関数を使用する場合の注意事項として、legacy_stdio_definitions.libを指定する必要があります。
Visual Studio 2015以降、printf、scanf系の関数がinline化されていて、回避手段としてlegacy_stdio_definitions.libが提供されています。参照情報(英語)パターン１と同じ実行結果となりました。４つのパターンを実装してみた結果、パターン３が私のお気に入りです。
パターン３であれば、C#のソースコートが手元になく、DLLのみの提供であっても対応できます。パターン４は、１つのEXEファイルにまとめられるというアイデアは面白いと思いました。
ただ、D言語を使う上でPhobosライブラリが使えない等の制約があるため、私にとっては実用的ではないと思いました。


