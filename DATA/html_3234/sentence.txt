More than 1 year has passed since last update.C#初心者です。特別扱い、という言い方は正しいかはわかりませんが、私はそう読み取りました。詳しく調べてないので。try-catchの中でawait Task.WhenAllをしたときにAggregateExceptionではなくTaskで発生したExcepotionが発生します。ちなみに、時間的に最初に起きたExceptionではなく、WhenAllの順番的に先頭に近いTaskで起きたExceptionが発生します。どうしてもAggregateExceptionを得てちゃんと処理したい場合、以下の2つの方法があります。PDFのここの文面から特別扱いしてないか？と読み取ってますWhen you use await, the code generated by the compiler unwraps the AggregateException and throws the underlying exception.確認したときのコード（長いので省略）--- Case4AwaitTaskWhenAll ---
Wandbox.FooException--- Case5AwaitTaskWhenAll_Order ---
Wandbox.BarExceptionここの動きがなんでや？ってなったので。よくよく考えればTask.WhenAllはTaskを返すだけなので、Wait()すればAggregateExceptionが起きるのは分かるし、awaitすればawaitの都合によって処理されるんだろう。でも直感的にはawaitでもAggregateExceptionが起きてほしくないですか？そうしないと2つ以上の例外が起きても1つしか処理できないので。awaitと例外処理について触れている記述はあまり見かけなかったのですが、上記のPDFの最後の方でコンパイラがそのようなコードになるように書き換えているといった記述があります。
ただ、なぜこういう処理をしているのかはちょっと追い切れてないです。詳しい方教えてください。記事分けろって感じもしますが、近い内容なのでいいでしょう。まず、AggregateExceptionについてのAPIドキュメントをみたが、なんのこっちゃ？という感じ。こういう時は書いて覚えようということで、実際に動かしたのが以下のコード。出力AggregateExceptionが持つメソッドやフィールドは邪魔者というわけではなく、ちゃんと例外処理を扱う上では使いこなす必要がある代物と感じます。という感じです。HandleかInnerExceptionsか、Flattenを使うか否か、という2点は考える必要はありそうです。HandleかInnerExceptionsか、については、扱う例外の内容によるでしょう。
Flattenについては、AggregateExceptionを考慮したい（ネストしたタスクの例外を意識したい）か否かになるでしょう。ネストしたタスクの情報が無くなると困る場合は使わないで1個1個処理する形になるでしょう。細かいところだと、Flattenしたときに2-2が3-1より先に出ているので、ネストしているAggregateExceptionに対してFlattenを行うとネストを含んだ順序性は壊れそうです。ちなみに、Handleの処理で例外を起こすと、AggregateExceptionに含まれるわけでもなく、そのままその例外が発生します。
当たり前という感じですが、その前までに処理できなかった例外(falseを返した例外)は失われ、以降の例外は処理されません。なので、Handleの処理で例外を起こさない方が良さそうです。wandboxには感謝しかない


