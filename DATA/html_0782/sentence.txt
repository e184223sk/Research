C#を始めとするオブジェクト指向言語には「インターフェイス」という機能があります。
これを使うと良い設計になるというのはよく言われていますが、具体的にインターフェイスを使うとどう良いことがあるのか、というのは実感しづらい人も多いと思います。僕もC#学びたての頃はほんとうにインターフェイスの利点が理解できず苦しみました。しかし、この記事で説明する「インターフェイスには３つのタイプがある」ことを理解して以来、もうインターフェイスが便利すぎて、インターフェイスなしではコーディングできない体質になってしまいました。そこでこの記事では、インターフェイスを使う利点がいまいち理解できていない人が、インターフェイスを使いたくて使いたくて仕方がなくなるようにすることを目的として書きました。注意点として、僕はC#の開発者でもなければ指導者でもないので、あくまで個人的な意見として参考にしていただけるとうれしいです。
間違っていたり、意見がお有りの方は、ぜひコメントでお知らせください。インターフェイスについて、以下のような間違いがよくされています。僕もC#学びたての頃はよくこのような勘違いをしていて、そのせいでまったく理解が進みませんでした。
しかし、これらは間違いです。インターフェイスは、これによってポリモーフィズムが実現されなくても大きな意味があるし、たった一つのクラスにしか実装されないインターフェイスにも、重要な意味があります。これらの混乱が生じる原因として、一言に「インターフェイス」と言っても３つのタイプが存在するからではないかと考えました。インターフェイスは、以下の３つのタイプに分けられます。1. 疎結合を目的としたインターフェイス
2. クラスの機能を保証することを目的としたインターフェイス
3. クラスへの安全なアクセスを提供することを目的としたインターフェイスコードだけを見ていると、どのインターフェイスも同じように使われているように見えますが、実はその目的は全く異なることがあるわけです。また、インターフェイスの説明は分かりづらいものが多すぎます。
「C# インターフェイス　とは」などで調べると出てくるよくある説明に次のようなものがあります。「インターフェイスは、実装するクラスにメソッドの実装を強制するものです」これがよくわからないんですよね。
メソッドの実装を強制されるとどんないいことがあるのかわかりません。また、「インターフェイス」という名前からも想像がつかない機能というか。
なぜ「メソッドの実装を強制する」という機能に「インターフェイス」という名前が付けられているのかわかりません。これは、上記の「インターフェイスは、実装するクラスにメソッドの実装を強制するものです」という説明が、インターフェイスの本質を説明したものではないから、混乱が生じるんだと思います。インターフェイスとは「インターフェイス」です。
「ユーザーインターフェイス」とかの「インターフェイス」と同じ意味です。では何のインターフェイスかというと、クラスのインターフェイスです。
もっと言うと、「クラスにアクセスするためのインターフェイス」といえます。「クラスにアクセスするためのインターフェイス？別にインターフェイスがなくても普通にインスタンス名.メンバ名でアクセスできるが？」と思うかもしれません。
ところが、インターフェイスがないと大きな問題となる場合がたくさんあります。例えば以下のような、Qiitaの記事を表すQiitaPostクラスを考えてみます。Qiitaはまず記事がなきゃ始まりません。
記事を書く人がこのQiitaPostクラスのインスタンスを生成しました。これをQiitaのサーバーにアップロードします。これで晴れてみんなに読んでもらえます。Qiitaの記事を読む人は、QiitaServerから記事を取得してタイトルと本文を確認します。記事を読んだあとに良かったと思ったのでLGTMもしちゃいました。さて、このQiitaPostクラスの問題点は、次のようなことができてしまう点です。なんと、読み手が勝手に人の書いた記事を消せてしまいます。
そりゃそうですよね、何しろQiitaPostクラスにはDeleteメソッドがpublicで定義されているのですから…。また、次のような問題も発生します。自分の記事に自分でLGTMできちゃいます。なぜこのような問題が起きるのかというと、ズバリ「QiitaPostクラスにアクセスするための適切なインターフェイスが定義されていないから」に尽きると思います。確かに、インターフェイスがなくてもQiitaPostクラス自体にはインスタンス名.メンバ名でアクセスできます。
アクセスできますというか、誰でも彼でもフリーでアクセスし放題です。自販機で言えば、「売上金をすべて排出する」ボタンが客が触れられる場所に配置してあるようなものです。
普通の自販機は客用のインターフェイスと管理者用のインターフェイスが完全に分けられ、客は「売上金をすべて排出する」ボタンを押すことはできません。それと同じで、クラスにも使用者に応じて適切なインターフェイスが定義されていないと、あとあと問題が発生することがあります。これが、C#の「インターフェイス」の本質的な意味です。
…と僕は思います。では、実際にQiitaPostクラスのインターフェイスを定義して、先ほどの問題が発生しないようにしてみます。記事を投稿する人には次の機能が必要でしょうか。記事を閲覧する人には次のようなインターフェイスを用意しました。おっと、ここで被っているメンバがありますね。
被っているメンバは更に抽象的なIQiitaPostインターフェイスにまとめてしまいましょう。それに伴って、IAuthorQiitaPostインターフェイスとIReaderQiitaPostインターフェイスも次のように変更します。とてもすっきりしました。では早速、作成したインターフェイスをQiitaPostクラスに実装させます。
といっても、すでに内部実装はされているのでクラス定義のところにインターフェイス名を書くだけですね。今回はインターフェイスに定義されたすべてのメンバが、すでにQiitaPostクラスに実装されているのでエラーが出ませんが、一つでも実装されていないメンバがあるとコンパイルエラーになります。
これが冒頭で説明した「インターフェイスは、実装するクラスにメソッドの実装を強制するものです」という説明に通じるわけですね。それでは、インターフェイスを作成したので、「Qiitaの記事を作成する人」と「Qiitaの記事を読む人」にはQiitaPostクラスに直接アクセスするのをやめてもらい、きちんとインターフェイス経由でアクセスしてもらいましょう。postをIAuthorQiitaPost型で定義していますので、自分で自分の記事にLGTMできません。
なぜなら、IAuthorQiitaPostインターフェイスのメンバに、LGTMメソッドが存在しないからです。これで、記事を書いた人は自分でLGTMするとか余計なことができなくなり、おかしな使い方をされることはなくなりました。続いて、記事を読む人にもインターフェイス経由で読んでもらいます。きちんと読む人専用のIReaderQiitaPostインターフェイス経由で読んでもらうことで、勝手に人の記事を消すなどという酷いことはできなくなりました。このように、クラスを作るときには「誰に、どのように使ってほしいか」を意識した上で、適切にインターフェイスを用意することがとても重要です。
適切なインターフェイスを用意し、使う側がきちんと然るべきインターフェイス経由でクラスにアクセスするようにすることで、想定外の使い方をされて不具合が発生することを防ぐことができます。もっと言えば、クラスを作成する前にまずインターフェイスから設計することが好ましいと思います。クラスの使い手と使い方を意識して、まずクラスのインターフェイスを作ります。
それが終わったあとに、クラスに実装させて、エラーが出なくなるまで内部の実装を書くという流れを心がけると、うっかりクラスに直接アクセスされてしまった！なんてことが少なくなると思います。また、インターフェイスの設計は、クラス内部でどうやって実装しようかなどと考えることもなく、必要な機能をただ列挙していくだけなので、必要な機能を抜かりなく記述することができるというメリットもあります。たとえば、今回の例だとIAuthorQiitaPostインターフェイスを設計するときに、「あれ、削除するだけじゃなくて編集する機能もいるな」と気づきやすくなると思います。さて、ここからが本題です。
タイトルで、「インターフェイスには目的に応じて３つのタイプがある」と書きました。
もう一度書くと次の３タイプです。1. 疎結合を目的としたインターフェイス
2. クラスの機能を保証することを目的としたインターフェイス
3. クラスへの安全なアクセスを提供することを目的としたインターフェイス前項で扱ったインターフェイスは、このうちどれにあたるでしょうか？もうおわかりですね、「3.クラスへの安全なアクセスを提供することを目的としたインターフェイス」にあたります。では、他の２つはどんなインターフェイスなのかを解説していきます。１つ目は疎結合を目的として作られるインターフェイスです。
例えば次のようなものがあります。この例のITestReaderインターフェイスは、疎結合を目的として作られたインターフェイスです。使い手が、クラスに直接アクセスせずにインターフェイス経由でアクセスさせることで、クラス同士の結合度を下げることが目的です。
このようにしておくことで、たとえTextReaderクラスに変更が生じたとしても、TextReaderクラスがITextReaderインターフェイスを実装している限り、User側の変更は不要になります。例えば、実際にテキストファイルを読み込むのではなく、デバッグ用に用意したダミーデータを読み込ませたいとします。
このとき、ITextReaderインターフェイスがあるおかげで、以下のようにすることができます。ITextReaderインターフェイスを実装したDebugTextReaderクラス新たに登場しています。
しかし、ユーザー側はあくまでITextReaderインターフェイスにアクセスしています。User側はただITextReaderだけを知っていて、その参照先が具体的にどのクラスなのかは知りませんから、これまたUser側の変更は不要になるのです。以下のように、インターフェイスを用意せずにクラス同士をダイレクトにアクセスさせると、UserクラスがTextReaderクラスの変更の影響をダイレクトに受けるようになります。
例えば、TextReaderクラスのReadメソッドの名前がLoadに変わったとします。これだけで、TextReaderクラスを使っているUser側はRead→Loadへの変更を余儀なくされます。
一つのクラスなら良いですが、これがたくさんのクラスから依存されていた場合、影響するすべてのコードを変更しなければなりません。このようなことにならないよう、インターフェイスを用意しておくことで、TextReaderクラスは必ずITextReaderインターフェイスに準拠した実装にならなければなりません。
つまり、ITextReaderクラスを実装してさえいれば、ITextReaderインターフェイス経由でアクセスしている他のクラスへの影響はまったくなくなるのです。どうでしょう。このタイプのインターフェイスの利点がおわかりいただけたでしょうか。どのようなクラスにも必ずアクセス用のインターフェイスを用意しておくことが理想と思います。
面倒と思わずに、インターフェイスを用意しておくだけで、万が一の変更があったときに大いに役立ってくれるでしょう。続いて、「クラスの機能を保証することを目的としたインターフェイス」について説明します。このタイプのインターフェイスは、記事の序盤で「よくあるインターフェイスの説明」として挙げた「インターフェイスは、実装するクラスにメソッドの実装を強制するもの」という説明を受けたとしても最も納得しやすいタイプです。要は、インターフェイスを実装したクラスは、そのインターフェイスに定義されたメソッドは必ず実装されるのだから、特定の機能があることが保証されますよ、ということですね。このタイプのインターフェイスとして、有名なものがいくつかありますので列挙します。例えば、IEnumerable&lt;T&gt;インターフェイスを実装したクラスは、IEnumerator&lt;T&gt;を返すGetEnumerator()メソッドの実装を強制されるので、foreachステートメントで回すことができることが保証されます。
IEquatable&lt;T&gt;インターフェイスを実装したクラスは、bool Equals(T other)メソッドの実装を強制されるので、他のオブジェクトとの等価性を比較できることが保証されます。このように、クラスに一定の機能があることを保証するために使われるインターフェイスが、このタイプです。また、クラスの使い手側も、「あ、このクラスはIEnumerableだからforeachで回せるな」「このクラスはIDisposableだから使い終わったらDisposeしなくちゃいけないんだな」などと、クラスの定義を見ただけでそのクラスの性質を簡単に理解できることも利点の一つですね。もちろん、利点はそれだけではなく、ポリモーフィズムを利用した利点もあります。例えばIEnumerable&lt;T&gt;インターフェイスは、List&lt;T&gt;, Dictionary&lt;TKey, TValue&gt;, T[]など、様々なクラスが実装しているので、IEnumerable&lt;T&gt;型の変数には、それを実装した様々なクラスを受けることができます。例えばメソッドの引数として、IEnumerableで受けておけば、使う側はそこに代入できるインスタンスの選択肢が大幅に増えるわけです。
逆に、メソッドの引数をListなどの具象クラスにしてしまうと、使う側はListのインスタンスしか代入できなくなってしまいます。1このように、ポリモーフィズムによるメリットも享受することができます。最後に、記事中盤でも解説した「クラスへの安全なアクセスを提供することを目的としたインターフェイス」です。このインターフェイスの利点はもうお分かりいただけたと思うので、このタイプで有名なインターフェイスを紹介します。見ての通り、ただ単にアクセスを制限させるものばかりですね。
しかし、これが非常に重要な役割を持ちます。Listをそのまま渡すのではなく、IReadOnlyListとして渡すだけで、渡した先で勝手に書き換えられる危険性が皆無23になりますから、これを使わない手はありません。
詳しくは下記記事で詳しく解説されているので、参考にしてください。自分も大変お世話になった記事です。
https://qiita.com/lobin-z0x50/items/248db6d0629c7abe47dd以上、「インターフェイス」の本質的な意味と、それからインターフェイスの３つのタイプを解説しました。すごく長くなってしまいましたが、一口に「インターフェイス」と言っても、目的に応じて３つのタイプが有ることをご理解いただけたでしょうか。
インターフェイスの利点があまり良くわかっていない方も、「インターフェイスには３つのタイプがある」ことを意識するだけで、ぐっと理解度が深まると思います。ただ、冒頭でも書きましたがこの記事の内容は一個人の持論です。
もし説明がおかしい、間違っている等の他、ご意見ご感想などありましたら、ぜひぜひコメントください。すごく喜んで返信します。もちろん、メソッド内でListの固有メソッドを使う場合は素直にListで受けるべきです。 ↩[2020/09/10追記]@htsign さんにご指摘いただきました。IReadOnlyListとして渡しても、IListにキャストされてしまえば普通に追加削除可能なので、危険性が「皆無」というわけではないようです。ただ、IReadOnlyListとあからさまに「リードオンリーなリスト」をわざわざ書き換え可能となるようにキャストするというのは、あまり考えられない行為と思いますので、IReadOnlyListとして渡す有用性は十分にあると感じます。もし本当に書き換えられるのを阻止したい場合、ImmutableListもしくはReadOnlyCollectionを使えば実現可能です。 ↩[2020/09/15追記]自分なりに理解してImmutableList&lt;T&gt;とReadOnlyCollection&lt;T&gt;の記事書きました。よろしければどうぞ。 ↩


