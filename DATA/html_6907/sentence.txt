UniRx入門シリーズ 目次はこちら前回、OnNext,OnError,OnCompledおよび、IDisposableの用途について説明し、ストリームの寿命管理の方法についても解説しました。
今回は「ストリームソースの作り方」についてざっくりと紹介したいと思います。UniRxにおけるストリームとは、次の3つで構成されています。特にUniRxを使い始めて間もない人は、「1」のストリームソースを用意する方法がわからず途方に暮れてしまうパターンがあるかと思います。今回はこのストリームの発端となるストリームソースの作り方を紹介したいと思います。ストリームソースを用意する方法はいくつか存在します。UniRxが用意してくれているストリームソースを利用してもよいですし、もちろん自分でストリームソースを作ることもできます。UniRxを利用する場合、次のような方法でストリームソースを用意することができます。それぞれ順番に解説していきましょう。第1回から何度も登場しているSubjectですが、これを利用するパターンが最も基本形となります。
自分でストリームを作って自由にイベントを発行したいと思った時はこのSubjectを使ってひとまず問題はないでしょう。そしてこのSubjectですが、派生がいくつか存在しそれぞれ異なる挙動をとります。用途に合わせて適切なものを利用するとよいでしょう。今回は表として紹介するにとどめ、各Subjectの詳細な説明は次回以降に行いたいと思います。AsyncSubjectはまんまFutureやPromiseみたいなものです。非同期で処理を走らせて結果が終わったころに取り出したいという時に利用できます。ReactiveProperty&lt;T&gt; は普通の変数にSubjectの機能をくっつけたものです。（実装もそんな感じになってます）
変数の感覚で定義して利用できるのでわかりやすく、初心者にオススメです。また、ReactivePropertyはスペクタービューに表示して利用することも可能です。この場合はジェネリクス版ではなく、それぞれの型の専用のReactivePropertyを使う必要があります。また、ReactivePropertyは次回以降に解説する予定のMV(R)Pパターンでその真価を発揮することになります。それまでにしっかりマスターしておいて下さい！なお、enumもReactiveProperty化してインスペクタービューに表示することも可能ですが、こちらは一工夫必要です。こちらについてはUniRxの作者のneueccさんがブログの方で解説していますのでそちらを参考にされるとよいでしょう。
UniRx 4.8 - 軽量イベントフックとuGUI連携によるデータバインディングReactiveCollection&lt;T&gt;はReactivePropertyと同じようなものであり、状態の変化を通知する機能が内蔵されたList&lt;T&gt;です。ReactiveCollectionは普通のListと同じように使うことができるうえ、状態の変化をSubscribeすることができるようになっています。用意されているイベントは次の通りです。ReactiveDictionaryのDictionary版です。ReactiveCollectionとほとんど挙動が同じなので省略します。ファクトリメソッドとは、UniRxが提供しているストリームソース構築メソッド群のことです。
Subjectだけでは表現できないような複雑なストリームを簡単につくることができる場合があります。UnityでUniRxを利用する場合はファクトリメソッドを利用する機会はそんなにないかもしれませんが、どこかで役に立つことがあると思うので覚えておいてもいいでしょう。ただしファクトリメソッドは数が多いので、利用頻度が高いものを抜粋して紹介したいと思います。もし全てのファクトメソッドを知りたい場合、ReactiveXのOperatorsの項目を参考にされるとよいでしょう。
ReactiveX Creating Observablesの項目Observable.Create&lt;T&gt; は自由に値を発行するストリームをつくることができるファクトリメソッドです。例えば、一定の手続きで処理の呼び出しルールをこのファクトリメソッド内部に隠蔽してしまい、結果だけをストリームで取り出すといった使い方ができます。Observable.Createは引数にFunc&lt;IObserver&lt;T&gt;, IDisposable&gt; (IObserver&lt;T&gt;を受け取ってIDisposableを返す関数) を引数にとります。実際に使い方をみてもらった方がわかりやすいと思います。Observable.Start は与えられたブロックを別スレッドで実行し結果を1つだけ発行するファクトリメソッドです。非同期で何か処理を走らせ、結果が出たら通知してほしい時に利用することができます。1つ注意しなくてはいけない点があります。Observable.Startは処理を別スレッドで実行しそのスレッドからそのままSubscribe内の関数を実行します。 これはスレッドセーフではないUnityにおいて問題を引き起こすことがあり注意する必要があります。
もしメッセージを別スレッドからメインスレッドに切り替えたい場合、ObserveOnMainThreadというオペレータを利用しましょう。このオペレータを挟むことで、このオペレータ以降がUnityのメインスレッドで実行されるように変換されます。Observable.Timer は一定時間後にメッセージを発行するシンプルなファクトリメソッドです。
実時間で指定する場合はTimerを、Unityのフレーム数で指定する場合はTimerFrameを利用しましょう。Timer TimerFrameは引数によって挙動が変化します。1個しか指定しない場合はOneShotな動作で終了し、2個指定した場合は定期的にメッセージを発行する挙動になります。また、スケジューラを指定することで実行するスレッドを指定することも可能です。また、似たファクトリメソッドしてObservable.Interval/IntervalFrameが存在します。こちらはTimer/TimerFrame の2個引数を指定する場合の省略版みたいなものとなっています。Interva/IntervalFrameではタイマを起動するまでの時間(第一引数)を指定することができなくなっています。Timer TimerFrameを定期実行に利用する場合、Disposeのし忘れに十分注意する必要があります。停止するのを忘れて放置しているとメモリリークやNullReferenceExceptionの原因となります。UniRx.Triggersは、using UniRx.Triggers;を行うことで利用可能になるストリームソースです。UnityのコールバックイベントをUniRxのIObservableに変換して提供してくれるます。UniRxではこれが一番重要かつ便利だと思います。Triggersは数が多いためとても紹介しきれませんので、GitHubのwikiを参考にしてください。
GitHub - UniRx.TriggersUnityが提供するほとんどのコールバックイベントをストリームとして取得可能になっており、またGameObjectがDestroyされた時にOnCompletedを自動で発行してくれるしくみになっているため、寿命管理も心配ありません。Triggersを使ってUnityのコールバックをストリームにしてしまうと、全てをAwake/Start内にまとめて記述することが可能になります。このあたりのメリットは次回以降に詳しく解説したいと思います。実はUnityのコルーチンとUniRxはとても相性がよく、IObservableとコルーチンは相互に変換して利用することが可能になっています。コルーチンからIObservableに変換するにはObservable.FromCoroutineを利用することで実現することができます。オペレータチェーンでゴリ押しで複雑なストリームを構築するより、コルーチンを併用して手続き的に書いた場合の方がシンプルでわかりやすく書ける場合も存在します。 コルーチンは悪と決めつけず、むしろコルーチンとUniRxと併用したほうが便利であるということを覚えておいて下さい。UniRxとコルーチンを組み合わせる解説は次回以降に詳しく行いたいと思うので、今回は簡単なサンプルだけ紹介しておくだけにとどめます。UniRxはuGUIとも相性がよく、前述のReactivePropertyと組み合わせることでViewとModelの関係をものすごくキレイに記述することが可能になります(MV(R)Pパターンと呼んでいます)。
今回はMV(R)Pパターンの説明はせず、uGUIイベントから変換する方法だけを紹介します。と言っても、細かく紹介するところは無く、UniRxをusingしていればuGUIコンポーネントのuGUIイベントとしてそのまま取得することができるようになっています。UniRxはこれ以外にも便利なストリームソースを用意してくれています。そのうちのいくつかを紹介します。ObservableWWWはUnityのWWWをストリームとして扱えるようにラップしてくれたものです。呼び出すことでUniRxがコルーチンを実行してWWWを処理し、結果だけ通知してくれます。(UniRxは内部にコルーチンを持っています。その実体となるGameObjectはMainThreadDispatcherという名前でシーン上に存在しています。このMainThreadDispatcherを止めてしまうとUniRxが正しく動作しなくなるのでこのGameObjectに手を加えるのは避けるのが賢明です。)名前の通り、次のフレームでメッセージを発行してくれるストリームを作ることができます。メッセージの発行のタイミングはUpdateではなくコルーチンのタイミングとなるので、実行タイミングがシビアな場合は注意が必要です。
参考:Unityドキュメント イベント関数の実行順Observable.EveryUpdate は毎Updateのタイミングを通知してくれるストリームソースです。
UniRx.TriggersのUpdateAsObservableと似ていますがあちらはGameObjectに紐付いておりDestory時にOnCompletedが発行されるのに対し、Observable.EveryUpdateは自分で停止しない限りシーンをまたいでも動き続けるストリームとなります。FPSカウンタのような、どのシーンでもずっと使い続けるようなストリームを構築する時に使うといいでしょう。
参考 UniRxでFPSカウンタを作ってみるObserveEveryValueChangedはストリームソースの中でも異色な存在であり、classそのもの(?)の拡張メソッドとして定義されています。。機能としては、任意のオブジェクトのパラーメタを毎フレーム監視して変化があった時に通知するストリームを作成することができます。ストリームの根源（ソース）を作る方法は複数ある「UniRx.Triggers」「ReactiveProperty」「uGUIから変換」が個人的には最優先で覚えるべきものだと思います。この3つさえ覚えていればとりあえずUniRxを使った開発で8割くらいはなんとかなると思います。


