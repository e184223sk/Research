More than 3 years have passed since last update..Net Framework 4.5.2のガベージ・コレクタの挙動を調べるために、C#のコードで実験してみた記事です。初心者向け。筆者も初心者。※ 本記事のサンプルコードは、川俣晶氏の以下記事を参考にさせていただきました。以下コードでは、Queue&lt;string[]&gt;型のオブジェクトをローカル変数として宣言します。キューに巨大データを詰め込んで拡張した後、GC.Collect()でマネージドヒープのゴミ回収をしますが、GC.Collect()前後でのメモリ使用量（近似値）を出力しています。リリースモードで実行すると、結果は以下となりました。GC.Collect()によって7.7MBのメモリが解放されたのは分かるのですが、GC.Collect()の呼出し時点ではqはスコープを抜けてないのだから、メモリ解放されるのおかしくね？と思いました。ですが、これってGC.Collect()からqのスコープ末尾「}」までの間に、qが使用されていないから解放されたのかなあと思います。試しに、qを使用するコードを追加してみました。qの使用を追加した上記コードをリリースモードで実行してみると、ライフタイムが延長されたのか、メモリ解放されませんでした。ちなみにデバッグモードで実行すると、最適化されないせいか、qを使用しなくてもライフタイムが延長せず、メモリも解放されていませんね。GC.KeepAlive()は、オブジェクトのライフタイムを延長します。このメソッドは「この時点までライフタイムを延長します」とマーカするものです。ライフタイムが延長され、予想通りガベコレの回収対象になりませんでした。ブロックで閉じてオブジェクトのライフタイムをexpiredさせれば、デバッグモードでもガベコレに回収されんじゃね？と思い、以下のコードを書いてみました。オブジェクトqを{}内に閉じ込めています。あれ、解放されませんね…。デバッグモードってそういうものなんですね。qをstatic変数にしてみました。するとどうでしょう。qはガベコレに回収されませんでした。まあ、staticなのだからそりゃそうですね。qがガベコレの対象になるように、ガベコレ直前にq = null;を追加してみました。おお、ガベコレに回収されてる。やったね。次はnullを代入する代わりに、キューの全要素をDequeue()で空にしてみます。解放されますね。要素数が大きいときは、Queue.TrimExcess()で空きスロットをshrinkすれば、よりオーバーヘッドが減ると思います。Clear()でも同じく、ガベコレに回収されるですね。q.Clear();の代わりに、q = new Queue&lt;string[]&gt;();に変更したところ、やはりガベコレに回収されました。newによる再割当て前の領域はダングリング参照とはならずに、ちゃんとガベコレに回収されるんですね（それがガベコレの仕事なのだが…）。キュー（static領域）をメンバにもつクラスのインスタンス変数にnullを代入したケースです。インスタンスにnullを代入しても、メンバが参照するリソースはstatic領域にあるため、リソースはガベコレに回収されませんね。staticメンバにnullを代入してstatic領域のリソースへの参照を断つと、やっとガベコレに回収されました。くぅ疲です。「ガベージ・コレクタ」というと、高度なアルゴリズムで武装された、頭の良い人だけが意識する近代兵器というイメージがあったのですが、こうやって実コードで動作を確認してみると、意外と身近なものに思えてくるものですね。筆者はガベコレのことが、ちょっと好きになりました。


