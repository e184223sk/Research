More than 3 years have passed since last update.このパズルの名前「Less Than Three」は僕が勝手につけた名前です。以下のような問題です。この問題の解き方ですが、まず、横方向だけに注目して考えて見ることにします。どの直線にも３個以上置いてはいけないのですから、必ず横一列（１行） に2個ずつ置いていく必要があります。そうしないと12個の石を置くことができません。２つの石を横一列（１行）のどこの置くかは、6個の要素から2個を取り出す組み合わせとなりますね。ですので、まずは組み合わせを求める必要があります。これは、「n個の要素からk個を選ぶ組合せを列挙する」で示しCombinationというクラスをそのまま利用します。このCombinationクラスで得られた結果を元に、石を横一列ごとに２つずつ置いていきます。

その際、石を置いた点を通る８つの直線すべてで、同じ色の石が２つ以内かを調べ、すべてが２つ以内ならば、次の行に石を置いていきます。同じ色の石が３つ以上の直線があれば、失敗なのでバックトラックします。6行すべてに石を置き終わったら、同じように白石を１行目、２行目、３行目...と石を置いていき、最後の行まで行けば、解が求まったことになります。解が求まった時点で、その解をプリントしています。
ひとつの解が求まっても終わりとせず、すべての解を求めています。ただし、回転、鏡像などは除外していません。なお、このプログラムは、IObserver&lt;T&gt; / IObservable&lt;T&gt;インターフェースを利用しています。Solverクラスには、解が見つかったことを通知する機能を持たせています。これをIObservable&lt;T&gt;を使って実装しています。ジェネリックの型パラメータTは、オブザーバーへの通知情報を示すクラスであり、解の状態を保持しているBoardクラスのオブジェクトです。IObservable&lt;T&gt;の具象クラス(Solver)が実装すべきメソッドはSubscribeです。 Subscribe メソッドは、オブザーバー・オブジェクト(通知を受け取るオブジェク ト)を受け取り、オブザーバーを登録します。複数のオブザーバーを登録可能にするために、Listコレクションクラスでオブザーバーを保持します。といっても、このプログラムでは一つで十分なんですが、この手のプログラムのパターンにあわせてListにしています。解が見つかったときに、OnNextメソッドを呼び出し、オブザーバーオブジェクト(購読者オブジェクト)に、解が見つかったことを知らせます。購読者クラスは、ResultViewerクラスで、IObserver&lt;Board&gt;を実装しています。 OnNextメソッドで、結果をコンソールに出力しています。 以下 C#のコードを示します。プログラムの実行を司るクラスです。解を求めるクラスです。IObservable&lt;Board&gt;を実装しています。盤面を表すクラスです。BoardBase&lt;T&gt;から派生しています。ResultViewerが表示全体をつかさどるクラスで、IObserver&lt;Board&gt;を実装しています。ResultViewerが表示全体をつかさどるということを考え、Boardクラスではなく、このクラスにPrintメソッドを定義しました。組み合わせを求めるクラスです。想像以上に解が多かったです。一部だけを掲載しています。このBoardBaseクラスは、「騎士巡回問題」「ナイト(騎士)の最適配置問題」などで利用したものと同じものです。前述のBoardクラスの基底クラスです。X × Y の盤面を表し、基本的な操作を定義しています。これは似たようなパズルでも再利用できるような汎用的な機能に絞っています。このBoardBaseクラスは、コンソールアプリに依存しない作りにしています。UWP、WinFormsでもそのまま使えると思います。このBoardBaseを継承して、当パズル専用のBoardクラスを定義します。内部では1次元配列を使っていますが、インデクサを定義して、1次元配列、2次元配列としても扱えるようにしています。
ただし、すべてのメソッドで１次元対応と２次元対応のものを用意するのは面倒なので、どちらか一方にしています。まあこれは好み以外の何物でもありません。１次元のインデックスによるアクセスができるようにしている理由は、一重ループで処理が書けるので、コードが簡潔になるからです。LINQのコードも書きやすくなります。2次元配列として見た場合の、X座標、Y座標は、0 からではなく、1から始まります。
つまり、board[1,1] は、いちばん左上を示し、8×8の盤ならば、board[8,8]が右下を示すことになります。なお、盤の周りには番兵用の領域を用意しています。これにより範囲外かどうかの判断を簡単に出来るようにしています。チェスのナイト(騎士)の動きにも対応できるよう、番兵は二重にしています。上の図は 4×4の盤を表していますが、グレー部分が番兵が置いてある盤の周囲で、水色部分が実際の盤です。
盤面上の数値は、１次元配列のインデックスを表しています。なお、派生クラスや派生クラスを利用するクラスが、この番兵の存在に依存しないように、ToDirectionという関数を定義し、X方向、Y方向のペアで表す移動方向(ベクトル)をインデックスで表す方向に変換するようにしています。BoardBaseクラスはジェネリッククラスにしていて、そのパラメータの型は、盤面上に置けるクラスの型です。この記事は、Gushwell's C# Programming Pageで公開したものを大幅に加筆・修正したものです。


