More than 3 years have passed since last update.C# のプロジェクトに参加することになりそうなので、C# の DI の仕組みである Autofac について調べてみた。今回は、Autofac のスコープについて調べてみた。全てのサンプルコードはAutfacSampleに置いておいた。Autofac は　.NET 用の IoC コンテナだ。アプリケーションに対して簡単に、Dependency Injection が可能になる。最初の例から見てみよう。Backend.csSingleSample.csProgram.csポイントになる部分について解説していこう。DI(Dependency Injection) を実施したいクラスをContainer Builder に登録していく。ここでは、Backend クラスを、IBackend インターフェイスの実体として登録している。そして、スコープとして、SingeInstance つまり、何回 IBackend の実体を取得しようとしても、同じインスタンスが返される。Singleton パターンのようにふるまってくれる。ちなみに、最初のコードでは、Backend クラスのインスタンスを、IBackend の実体として登録しているだけだが、オブジェクトを組み合わせて返却するということも実施してくれる。後ほどサンプルで出てくるのでお楽しみに。ここで、登録したクラスを使いたいときは次のようなコードで実行する。ビルダに登録したクラスを取得するときには下記の通り。インターフェイスをしか、参照していないので、ビルダを切り替えると、簡単に処理をMockに切り替えたり、別のインターフェイスの実装クラスを参照させることができる。上記のプログラムを実行してみるSingleSample の Exec() メソッドでは、 Backend を２回取得しているが、実行結果で分かる通り、インスタンス番号は同じになっている。これを少しだけ変更してみよう。SingleSample の Exec() メソッドを変えてみる。もともとだったのをに変えて実行する。すると、シングルインスタンスが保証されなくなるので、すると、違う Backend のインスタンスが使われていることがわかる。次に、インスタンス毎のインスタンススコープを試してみる。InstancePerLifetimeSample.csポイントとしては、次のように、インスタンス毎のインスタンススコープを指定している。その後、scope 1 として、IBackend を２回取得しており、scope 2 として、2回。そして、scope2 の子スコープとして、scope3 で１回取得している。実行してみよう。スコープの内部で、取得した IBackend が同一のインスタンスになっている。スコープが変わると変わるようだ。ちなみに、最後の write 05 は、scope2 の子として、scope 3を作成しているが、scope 2 とは違うインスタンスになっている。先ほどの例で、scope 2 と、 scope 3 は scope 2 の内部なので同じインスタンスを返してほしい場合はどうすればいいだろうか？その場合は、Instance Per Matching Lifetime のスコープを使うとよい。GetData() の中身を変更してみた。Container.BeginLifetimeScope("aRquest") といったように、名前を指定してスコープを始めている。このようにすると、scope2 の子のスコープであるscope3 でも、同じインスタンスが使われているのがわかる。ちなみに、同じものを２回連続で、名前を変えて登録すると、より下で定義したほうのみが有効になる様子。この場合、bRequestのみが有効になり、aRequestで参照するとエラーになる。Autofac で管理しているインスタンスで、Command が IBackend を持っているようなケースで、IBackend のスコープを、Command の生存範囲に合わせたいという場合に使われる。ちなみに、このスコープの場合、オブジェクトの取得のやり方が少し変わる。ここでは、Command と、IBackend を登録しており、IBackend を、Command 毎に作成するように指定している。ちなみに、Command のコンストラクタは次のようになっている。特に指定していないが、IBackend Inject されて、インスタンスが生成される。取得するときも、一工夫必要でインスタンスは、Owned オブジェクトにラップして返却されるので、Command のメソッドを使いたければ、Value プロパティ経由になる。また、Command のインスタンスのライフタイムを明確にコントロールするため Command の使用が終わったら、Dispose() メソッドを呼ぶ。たしかに、Command の生存範囲と、Backend のインスタンスの生存スコープは同じになっている。ちなみに、をに変更して、にしても、結果は変わらない。じゃあ何がいいかというと、command の生存期間を、Dispose で明確化できることらしい。がどういうケースでそれが有効なのかがよくわかっていない。もしご存知の方がおられたら是非コメントいただきたい。Thread 毎に IBackend が生成されてほしいというケースでは、Instance Per Lifetime のスコープを使うと、想定通りの動作を実現することができる。スレッド毎に、スコープを生成すればよい。
コメントにご注目いただきたい。実行結果スレッド毎にきれいにインスタンスが分かれている。次は、Owin や、Api への DI の組み込みについて見ていきたい。近い将来 Moq を調べて、Test Drive Development を、 C# で常時可能なようにしていきたい。


