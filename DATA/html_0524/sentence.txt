javascriptでUInt32な数値を扱いたかったんです
ん？
いや、とっ掛かりはやはりXorShiftな訳で、ある乱数列にデータを重畳してプログラム間で受け渡ししたいな、と
まぁその様に思った次第ですでも今回のプログラム間、ってのがC# ⇔ javascriptなんです
ここで問題になるのがjavascriptの乱数はseedを必要としません、ってか「受け付けません」
それでは乱数列の共有など出来るハズもありませんから、何かseedを指定できる簡便な乱数発生器はないかな？と思って行き当たったのがXorShiftなんですこれはググって頂ければすぐ分かりますが、すんごい軽量ながらseedを元に結構ガチな乱数列を捻り出してくれる（らしい）疑似乱数発生器ですおーっ！
こいつぁ御誂え向き…なんて思ったのも束の間
そこそこの周期を期待するなら、unsigned intな数値を扱える必要があるぅ？いやいやいやー
御冗談を
javascriptの扱える数値に型なんて概念ありませんぜ
なんなら、整数と小数どころか数値列と文字列の境だって曖昧だっちゅーのま、それはさておき、やってみましょにまずはC#からですねこんな感じですかね？
uintを返してしまう処が本家Randomと違う処ではありますが、メソッドの構成などは合わせてみましたここでポイントとなるのは、Next()の最後でw - 1を返している処ですね
実は問題として指摘されているのが、XorShiftはzeroを返さないよね？　と…うーん、そうなんだー
でも、zeroを返さない（かも知れない）けど、１は返す可能性があるよね？
じゃぁ、１引いちゃえばいいじゃん…
なんてね実はNextDouble()の仕様から考えると、その方が健全かなと云う結論になります
つまり、最後に１を減ずる事でNext()の定義域が0 &lt;= Next() &lt; uint.MaxValue - 1となって、必然的にNextDouble()の定義域は0.0 &lt;= NextDouble() &lt; 1.0になる、と云う訳です
逆に云うと、Next()はuint.MaxValueを返さないよね？
なんですけど、そこは目を瞑る事で７方位は丸く収まるので良いのではないでしょうかで、実行！みたいな感じで、こうこれをベースにしてjavascriptの実装が同じ乱数列を返せば目的は達成！
と云う事で…あ！
ここに来てなんですが、私の云っている「javascript」はwindows shellで使われる方です
IEとかChromeとかEdgeで実行できる方のjavascriptではなくて…つまり、ちょっとばかり古いjavascriptと云う事
聞く処に因ると、新しい奴は、class定義ができたり、部分的に型の定義ができるらしい…
とか、そんな便利なんじゃない方です勿論、スクリプトエンジンを指定すれば新しい方で動いたりする訳なんですが、起動時に１枚噛ませないといけなくなるので面倒臭いでしょ？さて、そんな訳で取り敢えずC#をjavascriptに書き直してみる事にしましょうかこんな感じ？
（一部のオーバロードは諸事情で割愛しました）で、実行！う～～～ん…
全然違う、どころかマイナスになっちゃうよ（uintであって欲しいのだが…）えーっと、何でうまくいかないか、って云うのを－だって、javascriptはuint表現できないんだもんの一言で片づけるのは安直です何故ならjavascriptの整数の有効桁数って53bitくらいあるんですよ?
高々32bitで表わされるビット列を11bit程度左シフトしたところで、msbまで侵食して符号反転しちゃうとは考えられません
符号は別の論理が働いて反転させられてしまっていると考えるのが合理的です一つ実験してみましょうほら、所謂int.MaxValueに1を足してもint.MinValueにならずにuint領域に踏み込んでしまっているでしょ？
工夫すればuintの計算だってできる可能性があるって事じゃないでしょうか？ところで、さっきのjavascriptの実行結果、よ～く見てみるとマイナス符号が付かない奴はC#と結果が一致してますね…
でもマイナスの方は全然違う感じお！
そうだマイナス符号付いちゃってるんで、ビット反転してみるってのはどうでしょう？あれ？
ほぼ同じだ…
あー、0xffffffffが符号反転の原因になってるのかなぁ
じゃぁ、取敢えずこう大分近くなった（C#ではdca345e9）
乱数列の正符号側がずっーっと一致しているのと考え合わせると、ビット列は保存されている様です
今回の仮実装での表示の仕方（され方？）が問題なんでしょうとなると、マイナス表示されない様にするにはどうしたら良いか？
を探れば良いと云う事ですねんー
肝はやっぱり「符号（サインビット）」かと思います
そもそもjavascriptって+0と-0が表現できてしまう（らしい）ので、サインビットは数値とは別に存在すると云う事ですよねで、ここでもう一回テストですマイナスになったりプラスになったりしますね
10進だと良く分からないので16進で表現してみましょうか4ビット左シフトまではプラスの数値ですが、5ビットシフトすると負数になってしまいます
つまり、4ビットシフトまでは32ビット数値として考えた時のmsbはゼロなので正数を表しているけど、5ビットシフトした時にmsbに1が立ってしまうので負数と認識してしまうのではないでしょうか？
その結果、どこか違う所に管理されている「サインビット」が立ってしまうんじゃないのかなぁ…と云う事で75bcd150の方を左シフトした結果から5ビットシフトの数値を考えてみましょう
ここでjavascriptの力を借りてしまうと話がややこしくなるので、手作業ですシフトしたうえで2の補数をとると5ビット左シフトの結果と一致しました！
つまり、数値としてはeb79a2a0として表現されているんですが、サインビットが立っているので表示させると2の補数形式で解釈されている、と考える事が出来ます
？？　あれ？　普通じゃん………じゃぁ、ビット列としては期待通りになっているけど、何かのタイミングで立ってしまっているどこか違うところにある「サインビット」をクリアすることができればuintの数値として表現してくれるのでは？！！
ここで閃きました
サインなし右シフトって演算があるじゃないですか！
いや、何の論理的な根拠もないですけど、実験実験ほら、綺麗に5ビット左シフトの結果が得られました
何でこうなるのかはjavascriptの中の人に詳しい説明を聞きたい気分ですが、取敢えずサインなし0ビット右シフトを行う事でどっかにあるサインビットはクリアされるようですビット列演算の結果は常に保存されていた様なので、returnの値だけuint補正を掛ければ良い筈結果は、こうなりましたC#の結果と合いましたねREPLは役に立ちました


