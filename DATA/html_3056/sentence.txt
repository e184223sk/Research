More than 1 year has passed since last update.pythonnetを使って、.NETからpython(cpython)コードを呼び出す方法。
例えば、「Chainerで作ったAI処理を、.NETでつくったGUIから叩きたい！」とかいうときに有用。python -&gt; .NET(C#)の資料はたくさんあるのに、.NET -&gt; pythonの資料がほとんどない1ので作成。この記事は以下の知識があることを前提に作成した。作業目標は、「Windows(x64)環境で、VS2017を使い、C#からpython3.7(x64)のコードを呼び出すサンプルを作る」とする。
なお、pythonnetは、本記事執筆時点(2019/07)で、python 3.7まで対応している。pythonnetをビルドするための設定を行う。
※nugetにビルド済のパッケージがあるが、あまり更新されていないようなので使用しない。pythonnetのgithubリポジトリから最新コードをcloneし、pythonnet.slnを開く。
VS2015の場合はpythonnet.15.slnを使う。vs2019以降を使う場合は適当に変換してがんばる(未確認)。ソリューションのビルド構成がいろいろあるので、適切なものを選ぶ。
構成名は、(Debug|Release)(Mono|Win)(|PY3)という構造になっている。
※ただし、この設定を廃止し、実行時に動的に選択可能にする改善が検討されているようなので、このあたりの手順は、そのうち大きく変わるかも。Debug|Release
おなじみの、Debug/Releaseビルドの選択。Mono|Win
Mono(Linux)用か通常のWindows用か。|PY3
なにも付かないほうはpython2系向け、PY3はpython3系向けにビルド。今回はWindows環境でpython3.7を呼び出すのが目的なので、ReleaseWinPY3を選ぶ。
なお、プラットフォーム(x86/x64)はどちらでもよい(今回ビルドしたいPython.RuntimeプロジェクトはAnyCPU設定になっているため)。選んだら、プロジェクトPython.Runtimeのプロジェクト プロパティを開き、コンパイルシンボルを確認する。
PYTHON3;PYTHON37;UCS2のような文字列が定義されているので、狙ったpythonバージョンになっているか確認する。今回はpython3.7を動かすのでPYTHON37でよいが、python3.5にしたい場合はPYTHON35のように書き換える。
有効な設定値は、src/runtime/runtime.csの#if節を参照するとわかる。設定を済ませたプロジェクトをビルドする。src/runtime/bin以下にPython.Runtime.dllが出力されるので、回収しておく。同時に、Python.Runtime.pdb(デバッグ情報)とPython.Runtime.xml(ドキュメントコメントの情報)も回収しておくと、あとで少し幸せになれるかも。pythonコードの呼び出し元となるプロジェクト / ソリューションを作る。サンプルでは、.NET Framework 4.6.1向けのC#コンソール アプリとした。※pythonnetは.NET Framework 4をターゲットに作られているので、それを呼び出せる設定にすること。64bit用のPythonのDLLを呼び出すには、呼び出し元のexeも64bit向けにビルドされている必要があるため、その設定を行う。作成したソリューションの構成マネージャーを開く。プロジェクトのプラットフォームがAnyCPUとなっているので、x64を新規作成する。
※このとき、"新しいソリューション プラットフォームを作成する"にチェックを入れておくこと。作成したら、プロジェクト プラットフォームとソリューション プラットフォームの両方から、AnyCPU設定を削除しておく。
※残しておくと、うっかりAnyCPU設定を使ってしまってドハマリする場合があるため。


pythonnetのビルド時に回収しておいたDLLを、作成したプロジェクトのディレクトリにコピーする。プロジェクトの参照設定から、コピーしたDLLに参照を設定する。

※見逃しがちだが、右下に参照ボタンがある。
追加されるとこうなる。以下を実装する。ただし、このままではまだ動かない。python環境を導入する。今回は、Anacondaで、"pythonnet_test"という名前のpython3.7環境(64bit)を作り、利用する。
よって、python環境のルートディレクトリは%userprofile%\anaconda(最近はminicondaかも?)\envs\pythonnet_testとなる。また、C#からpythonの追加パッケージが利用できることを確認するため、numpyを追加インストールした。python環境を別の方法で導入する場合は、ルートディレクトリのパスを確認し、numpyもインストールしておくこと。自作pythonコードが呼び出せることを確認するため、呼び出し先となるpythonプログラムを準備する。以下コードを、&lt;任意のディレクトリ&gt;\my_awesome_lib\my_math.pyに配置する。※配置したディレクトリは後で使うので覚えておくこと。サンプルではC:\foo\bar\my_packages\my_awesome_lib\my_math.pyに置いた。作成したpython環境にパスを通す。これが一番難しい(というか情報がない)。ソースコード中、"python環境の設定"というコメント以降がこの設定に相当するので、コードを修正する。pythonnetがpython本体のDLLを見つけられるよう、環境変数(PATH)にディレクトリを追加する。サンプルでは、ユーティリティ関数AddEnvPath()によって、以下を設定している：python環境のルートpythonXX.dll(python3.7ならpython37.dll)のあるディレクトリ。python環境のルート\Library\binこのディレクトリに、pythonXX.dllが依存しているDLLの一部が格納されていた。
python環境の作り方によっては必要ないか、別のディレクトリを指定する必要があるかも。パスの通し方には複数の方法があるが、この例と同様、プログラム中(コード)で設定することをお勧めする。プログラム中(コード)で設定きちんと設定されていることを保証できる。おすすめ。
ただし、サンプルではパスをハードコードしているが、普通は設定ファイルとかから読むようにすべき。Windowsのシステム環境変数に設定システム全体に効くため楽だが、複数のpython環境が運用できなくなる。exe起動前に(bat等で)事前設定するデバッグ実行などがやりにくい。python本体に、pythonのモジュールを探索するパスを設定する。これが正しく設定されていないと、pythonの標準ライブラリやpip等で入れたライブラリ、自作コードを見つけることができない。設定すべき項目は2種類ある。PYTHON_HOMEpython環境のルート。PYTHON_PATHpythonモジュールの探索場所。セミコロンで区切って指定する。PYTHON_PATHには、デフォルトで以下が設定されている：サンプルでは、これらに加え、以下を設定している。必要なら、さらに追加することもできる。ここまで設定すると、サンプルが動くようになる(はず)。ビルドして実行してみて、以下のように出力されれば成功。Pythonの関数やクラスが呼び出せ、値をやり取りできていることが分かる。よくあるトラブル。pythonモジュールを見つけられていない。おそらく、PythonPathの設定をミスしている。見つからないと怒られたモジュールの実体(ファイル)がどこにあるか調べ、PythonPathが適切に設定されているか確認する。DLL関連の問題は、だいたい何でもこの例外になる。原因が多岐にわたるので調査が難しいが、以下のどれかが原因のことが多い。pythonのDLLがあるディレクトリにパスが通っていないpythonnetのビルド時に、適切なpythonバージョンを指定しなかった
python3.5の環境で動かしたいのにpython3.7向けにビルドしてしまった、など。
pythonnetが探しに行くDLL名はビルド時に決まるので(python3.7向けにビルドした場合はpython37.dllを探しに行く)、ビルド時の環境と実環境が不一致だとDLLの読み込みに失敗する。pythonのDLLが依存しているDLLにパスが通っていない(見つからない)
DLLが見つかっても、そのDLLが依存しているDLLが見つからない場合は、やはり読み込みエラーとなる。呼び出し元プロジェクト・python本体のプラットフォーム(x86/x64)が一致してない
特に、 呼び出し元のプロジェクトをAnyCPU設定にするのは混乱の元になるので避けたほうがよい(もともとの挙動がややこしい上、.NET 4.5以前と以後での挙動が異なる)。
※pythonnet本体は、AnyCPUでビルドされるため、呼び出し元プロジェクトの設定に従う。この手の問題が発生してしまった場合は、以下のような調査手段で何とかする。DependenciesでDLLの依存関係を追っかけるdumpbinコマンドで各DLLのプラットフォーム(x86/64)を確認する
e.g. dumpbin /headers hoge.dllProcess Monitorでロードに失敗したDLLを特定する
IRP_MJ_CREATEが何度も失敗しており(DLLの探索先パスを全て探すため)、最後までLoad Imageが実行されていない(= DLLが見つからなかった)DLLが犯人。
また、Load Imageした結果がSUCCESSでないDLLも怪しい。
フィルタ設定を以下にするとわかりやすい。なお、IRP_MJ_CREATEはFiler -&gt; Enable advanced outputを有効にしていないと表示されない。ちょっと難しいことをやろうとするとハマること。C#で、複数のスレッド(pythonnetを初期化した以外のスレッド)からPythonコードを呼び出す場合には、注意が必要。Python(CPython)は、設計上、GILを採用している(GIL自体の説明は本題とずれるので割愛)。
また、明示的に開放処理を行わない限り、pythonnetはメインスレッド(= pythonnetを初期化したスレッド)でGILを保持したままにする。
よって、C#の別スレッドからPythonのコードを実行しようとした場合、GILの取得(using(Py.GIL())でデッドロックする。これを回避するには、pythonnetの初期化後(PythonEngine.Initialize()の呼び出し後)に、PythonEngine.BeginAllowThreads()を呼び出し、明示的にGILを解放する。
これにより、他スレッドからもGILが取得できるようになり、C#の複数スレッドからPythonのコードが呼び出せるようになる。
ただし、GILで排他されることには変わりがないことには注意が必要。
Python側コードの並列実行はされず、単に複数スレッドから呼び出せるようになるだけ。なお、pythonnetのBeginAllowThreads()メソッドが何をやっているのかは、PythonのC APIのドキュメントを読むとイメージがつかめる。C#からPythonに巨大な配列やリストを単純に渡すと、要素全てが個別にpythonのオブジェクトに変換されるため、とてつもなく遅くなる。
※ためしに4k解像度の画像データ(uint8の画素値)が入った配列を渡したら、なにもしないpython関数を呼び出すだけでも、秒単位の時間がかかった…こういう場合には、ポインタ経由での引き渡しが有効。
たとえば8bit グレースケールの画像を受け渡す場合、以下のようにする。C#からは、以下のように呼び出す。画像ではなく配列やリストを渡したい場合は、Marshalクラスを使ってIntPtrにさえ変換してしまえば、同じように渡せる。
unsafeコードを使えるなら、fixedを使っても、もちろんよい。pythonnetを使わない方法としては、以下のような方法での呼び出し方が考えられる。データのやりとりは、標準入出力やファイルを経由して行う。pros:cons:python側をサービスにしてしまう。
WebAPIサーバにしてもよいし、Apache ThriftやgRPCのようなRPCフレームワークを使ってもよい。pros:cons:cpythonと決別する。
「既存のpythonコードをC#から叩きたい」という用途には、おそらく茨の道。pros:cons:※動かなかった…という記事はあったのでそっとリンク。 ↩


