More than 1 year has passed since last update.C#というか.NETの世界では、外部プロセスを起動する際にSystem.Diagnostics.Processを使用するということになっている。
このProcessクラスには非同期イベントベースで標準出力をやり取りするためのAPIが存在するが、意図しない動作になる場合があるので要注意という話。非同期で標準出力、エラー出力を受け取り、かつ非同期でプロセス終了を待ちたい場合、以下のようにする。コードに直すと以下のようになる。さて、上記コード、一見問題ないように見える。
しかし、出力が全て表示される場合もあるが、途中で途切れてしまう場合もある。これはなぜかというと、Exitedイベントが発生した時でも、Processにある標準出力の内部保持データが残っている場合があるからである。
内部バッファデータを確実に全て消化させるには、Process.WaitForExit()を実行する必要がある。プロセスは全て終わっているので、ほとんどすぐ終わるはず。例えば、のようなコードを書いた場合、正しく終了した後にも関わらず、稀に不定期なタイミングでキャッチされない例外が発生する場合がある(ObjectDisposedExceptionあるいはNullReferenceException)。
これは、usingブロックを抜けた後にイベントが発生する場合があるからである。なぜそうなるか、という所は未解明だが、コールバックの中でキャッチするか、あるいは終了後にProcess.CancelOutputRead()とProcess.CancelErrorRead()を呼び出すことで回避ができる。Exitedイベントが、完全にプロセスが終了し、各種オブジェクトが破棄された後に起こる場合があり、その時に当然ほとんどのオブジェクトは破棄されているので、ObjectDisposedException、あるいはNullReferenceExceptionが発生して、キャッチされない例外になる場合がある。これに関しては、BeginOutputReadLine等と組み合わせると発生するようだが、詳しい条件は不明。全く起きない環境もあったりする。
.NET Frameworkでも、.NET Coreでも起きたりするので、もしかしたらOS側のAPIの使い方に原因があるのかもしれない。回避策は、コールバック内でキャッチするか、あるいはBeginOutputReadLine等を使用しないようにすれば、ほぼ起きなくなる。
その場合の標準出力の受け取りは、別スレッドで受け取り処理を行えば良い。プロセスが終わらないと、StandardOutputからのRead(Async含む)が戻ってこないため、かならず子プロセス含めてkillする必要がある。Processクラス自体は昔からあるクラスなので、イベントベースのAPIが用意されているが、終了イベントはともかく、標準出力に関するイベントはもう使わない方が良いのかもしれない。
ただし、長期に渡るプロセスの実行時は終わるまで制御が戻らない可能性があるため、この辺りは難しいところだ。


