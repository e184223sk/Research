MessagePipe解読第３回目1回目、２回目は以下以下の環境で実行しています
- MacOS
- Unity2021.2.0b2
- MessagePipe v1.6.1
- Zenject※ DIContainerはビルドインで用意されているので、Zenjectを入れていないプロジェクトでも
UniTask、UniRxに加えてMessagePipeを入れましょう！
今回はMessagePipeの非同期処理(async/await)が使用できるということで、どのような使い方が出来るのかを記事にしましたしかし処理が大きく変わるというわけではなく非同期用のインターフェイスにするだけで使用感が変わるということはありませんでしたIPublisher → IAsyncPublusher
ISubscriber → IAsyncSubscriber非同期処理についていくつかテストをしてみたいと思います
(今回は並列処理については書いていません。追記で書くかも）とする※最後にテストコードを貼ってあるのでそれをUnityTestRunnerで実行してみてくださまずはイベントを送る側(Publisher)にasync/awaitを適用させてみます。
Publisherのイベント送信処理が終了するまでawaitするケースイベント受ける側のクラスは前回と同じISubscriberで受けて、イベントが来たらSubscribeのラムダが反応しますIPublisher が IAsyncPublisher になっています。前回はPublishでイベントを送っていましたが、PublishAsyncになっています。そしてPublishAsyncにawaitがついていますが
PublishAsyncでイベントを送ることにより、イベント送信処理が終わるまで awaitされ続けます。後はPublisherクラスを作成してSendAsyncメソッドを呼び出すだけです使い方は以前とほぼ変わっていません。インターフェイスを変えてawaitを書いただけ
これで待機処理にできました。しかし今回の例、「イベント処理終わるまで待機...?」　というところに疑問を持たれると思います。
上記の例はイベント受け取るほう（Subscriber)が特に何も変わったことをしていないため、イベントを送ってSubscribeが反応して終わり。
つまりawaitも何もせずに先に進みます。特に意味がない例しかしIPublisherをIPublishAsyncにするだけで async/await が使用できるということがわかったと思います。次はイベントを受信する側(Subscriber)のクラスでasync/awaitを適用させるパターンを考えます。イベントを受信したら１秒待機して、ログを出したいケース。イベント受け取る方を変えました。送る方はさっきと同じです。ISubscriberをIAsyncSubscriberに変えました。
これだけで非同期処理が使用可能になってますそして、_asyncSubscriberのSubscribeのラムダに async がついていることがわかると思います。つまり ラムダの中で await が使用できるということ。ラムダの中で UniTask.Delay を使用して１秒待機し、その後ログを出すようにしました。流れとしては以下ですここでひっそりと6番目が追加されていますが、
新しくコードを追加したのではなく元々PublisherクラスはIAsyncPublisherを使用して「イベントの送信処理がすべて終了した時先に進む」というawait処理がありました。(最初の例）今回はSubscribeの中で１秒待機してログを出すようにしています。
Subscribeがasyncで動いている中、PublishAsyncはawaitし続け、5番目の 「Subscribe終了」 が来たときにawaitが解除されて先に進むようになりますイベント受信側がasync/awaitが使用できること、そしてイベント送信側でawaitする理由は受信側でasync/awaitされた結果、その処理が終わるまで待つために使える
ということがわかりました。※ IAsyncSubscriberのSubscribeは二番目の引数にCancellationTokenを受け取ります。
これを各種非同期処理に渡してあげるとSubscribeのasyncが途中で強制的に破棄された場合、渡した非同期処理も破棄してくれます（便利)特定のイベントを一度だけ待機したいケースは割と多いんじゃないかと思います。Subscirbe (() =&gt; .... ); でラムダの中に処理を書いても問題ありませんが awaitを使用してもう少しモダンに処理をさせたい。
そこで使用するのが IAsyncSubscriber.FirstAsync↓ ここが今回のお話Subscribeで購読処理を書くのではなくFirstAsyncを書くことで「MyEventが送られてくるまで待機する。」というawait処理が可能になっています。
(イベントが来たらawait終わって先に進む)一度だけ処理したい場合はこちらのほうが見やすく、直感的ではないでしょうかしかしこの処理はイベントが来るまでawaitで待ち続けてしまいます。
これは途中で購読をやめたい時には不便です。この為に引数で CancellationToken を受け取るようになっています。
これによりトークンをいつでもCancelすることでawaitの待機処理を破棄することができますこのあたりも開発元であるCyshapのUniTaskとの協調性が高く、とても使いやすいと感じます。
（UniTaskを使っていれば理解できる）MessagePipeの真骨頂はこのUniTaskと連動した非同期処理にあるものだと言っても過言じゃないと思います。async/awaitが使用できることによりイベントの送受信だけに収まらず、待機処理まで一連の流れで行えることで処理が分散されません。
結果視認性が高くなり、更にはバグが出にくいコードにもなると考えます
UniTaskを使用してる方はasync/awaitを使えることによる利便性がわかると思います。MessagePipeを使っていくうち、今後はMessagePipeを入れないとゲーム開発ができない(したくない)体になっていきそう...
今回テストで作成したUnityTestコードも貼っておきます。
自分でも実際にコードを見た、書いたほうがわかりやすかったので↓のコードをコピペしてUnityTestRunnerで実行して結果を見たほうが理解が早いかもしれません。(PlayModeTestのほう）
GlobalMessagePipeを使用してIAsyncPublisher, IAsyncSubscriberを作成する処理も書いています


