More than 1 year has passed since last update.汎用ホスト（GenericHost）におけるログ出力の構成についてまとめます。このドキュメントの内容は .NET Core 3.1 で確認しています。Host クラスの CreateDefaultBuilder メソッドの既定の動作では、Microsoft.Extensions.Logging.ILogger&lt;T&gt; 型のロガーが注入されます。T は注入先のサービスなどの型です。このロガーインスタンスには次の4つのログプロバイダが格納されており、ロガーに対して出力したログはこれらのプロバイダを経由してそれぞれの出力先に出力されることになります。既定のログプロバイダを削除したり、任意のログプロバイダを追加するには、IHostBuilder.ConfigureLogging メソッドに実装します。動作オプションを設定できるオーバーロードが定義されています。出力先とフィルタを設定できるオーバーロードが定義されています。AddEventSourceLogger メソッドにはオーバーロードは定義されていません。独自のイベントソースに出力するような場合はプロバイダを自作する必要があります。ILoggerProvider インターフェースを実装したプロバイダを定義し、AddProvider メソッドを使って登録します。ILoggerProvider に定義されているメソッドは CreateLogger メソッドのみです。
IDisposable インターフェースから派生していますので、Dispose メソッドも実装する必要があります。
プロバイダクラスに対して ProviderAliasAttribute を定義しておくと、既定のプロバイダ同様、JSON構成ファイルでプロバイダに対するログレベルを設定できるようになります。ILogger インターフェースには BeginScope, IsEnabld, Log の3つのメソッドが定義されています。IsEnabld, Log はその名のとおりです。
BeginScope メソッドはある一連の処理のログを出力するときにその開始と終了にログを出力するための仕組みだと思うのですが、ヘッダー・フッターを出力する、インデントするなどの例しか思いつきませんでした。
参考：Using The ILogger BeginScope In ASP.NET Core上の SampleLogger のスコープを使ったログ出力の例です。スコープが閉じられるまでの間はインデントされます。なお、このような場合は ILoggingBuilder インターフェースに対する拡張メソッドを定義することが一般的です。こうすることによって本来外に見せる必要がないプロバイダクラスを見せないようにすることができます。Microsoft.Extensions.Logging.LogLevel 列挙体には次の7つの値が定義されています。一般的なロガーのログレベルとほぼ同じです。ロガーのログレベルは出力対象の最小レベルを意味し、例えば Information が設定されている場合は Information ～ Critical が出力対象になります。ILoggingBuilder.SetMinimumLevel メソッドを使って既定のログレベルを設定することができます。application.json や任意のJSON構成ファイルを使って、ログレベルを含むロガーの設定を行うことができます。既定のログレベルの他、Microsoft.Extensions.Logging で提供されている各ログプロバイダごとのログレベルを設定することができます。この例の "GenericHostSample" のようにカテゴリ（≒注入先の名前空間＋型名）ごとのログレベルを設定することもできます。これは後述するフィルタに相当します。既定で登録される4つのログプロバイダのうち、ConsoleLogger と DebugLogger と EventLoglogger にはログレベルが反映されました。EventSourceLogger には適用されませんでした。ILoggingBuilder.AddFilter メソッドを使ってログフィルタを設定することができます。ログレベルを設定する際に "Default" の代わりにカテゴリを設定すると、カテゴリに対してフィルタを設定したのと同じ意味になります。前述のログレベルの記述例を参照してください。EventLogLogger にもフィルタが適用されました。EventSourceLogger にもフィルタが適用されました。ログレベルは適用されませんでしたが、フィルタは適用されるようです。LoggingEventSource クラスのページに EventListener を使ったログの取得方法が説明されています。EventListener クラスを継承したリスナークラスを実装します。次のコードは上記のリスナーを使ってアプリケーションのログを取得する簡単な例です。ETW の最も大きなメリットは out-process なログ出力（ログを発生させるプロセスとログを記録するプロセスを分離する）ができることだと思うのですが、残念ながらこの EventListener を使った方法は out-process には対応していないようです。
out-process なログ出力を実現する方法には EtwStream があります。私も以前に EtwStream の動作確認をしたことがあり、C# ETW（Event Tracing for Windows）からログを取得する で紹介しています。ログプロバイダとログレベル／フィルタを柔軟に構成できることがわかりました。ただ、EventLogger と EventSourceLogger 関連のやや不可解な挙動については情報の整理が必要であるとも感じました。


