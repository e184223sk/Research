More than 1 year has passed since last update.この記事はVRChatにおけるUdonおよびUdonSharp(U#)を使った際の備忘録です。
これからUdonを使い始める人のために書き連ねておきます。この記事は2020/5/26現在のVRChatを前提に書いています。Udonは実質、UnityのAPIをラップして呼び出しているだけにすぎません。
そのためUnityでプログラミングをするときと同じ様にパフォーマンスにもこだわる必要があります。Unityには標準でProfilerという機能が備わっています。
1フレーム単位でどのような処理が実行され、それにどれくらいの時間がかかっているかをチェックすることができます。詳しい使い方はこちらを参考にしてください。なお、プロファイラで動作を監視すること自体がかなりの負荷となります。
プロファイラを使っている間はfpsがガタ落ちしますが、しょうがないと割り切ってください。
（普通のUnity開発なら回避策があるのですが、VRChatだと仕様上どうしようもできないです）プロファイラの表示をRaw Hierarchyに切り替えて時間がかかっている順にソートすると何がボトルネックか調査することができます。
とくにこのモードだとUdon VMの中身の実行順も見ることが出来ます。Udonの仕様上、どのスクリプトであるか名前はわからないのですが、メソッド呼び出しの様子からどのスクリプトかあたりをつけることはできます。とくに負荷の原因となりやすいものはGC Allocと表示されているものです。
これはUnity上で、プログラムを実行するために必要なメモリを確保する動作を表しています。
（GCアロケートと呼ぶ）そしてこの確保したメモリですが、解放される瞬間にVRChatが一瞬フリーズしてしまいます。
（GC（ガベージコレクタ）が実行される、と呼びます）GCが実行される頻度は少ないほどfpsに与える影響は小さくなります。
逆に高頻度でGCが実行されると、体感できるレベル（ひどいと数十fps）で影響がでてきます。
そのためGCの実行をさける、つまりGC Allocの頻度を下げる工夫が必要となります。C#にはプリミティブ型（組み込み型）というものがあります。たとばintやfloatなど。
これらはC#に最初から定義されている型であり、基本的にGCを気にせずノーコストで利用することができます。そしてUdonですが、プリミティブ型以外の型を触るとボックス化されてGCアロケートが起きます。
たとえVector3やQuaternionといった構造体であってもGCアロケートします。このあたりは回避不可能なので、仕様と割り切って付き合っていくしか無いとは思います。C#の仕様上、string（文字列）は定義するだけでかなりのGC Allocを引き起こします。
そのためUpdate()で毎フレーム文字列を生成するなどしていると、パフォーマンスにかなりの悪影響を及ぼします。極力stringは使わない、使うにしても必要なタイミングで必要なだけ生成する工夫が必要です。非常に便利なUdonSharpですが、見えないところでコストがかかります。
それはUdonSharpBehaviourから別のUdonSharpBehaviourなオブジェクトのメソッドを呼びだす時です。たとえば、次のようなU#スクリプトがあったとして。これのObserver.cs側をUdon Assemblyにトランスパイルした結果をみるとこうなっています。注目して欲しいところは、他のUdonSharpBehaviourへのメソッド呼び出しがSendCustomEventとGetProgramVariableに変換されているところです。
（メソッドに引数を渡すとSetProgramVariableも追加される）そしてこのSendCustomEventとGetProgramVariableですが、なぜかGC Allocします。
（Udon内部実装の問題なのでおそらく回避不可）ということで、U#を用いた場合、気軽にメソッド呼び出しを実行するとそれだけでGC Allocが発生します。
普通のUnity開発ではノーコストな操作が、U#ではコストがかかる点はかなり罠な気がします。UdonBehaviourにはOnTriggerStayが定義されています。
そのため「VRC_Pickup + UdonBehaviourなオブジェクト」を一箇所に大量にまとめて配置するとOnTriggerStayが暴走します。
（50個ほど重ねて配置した例）数個程度なら問題ないですが、数十個レベルで一箇所にまとめるとfpsがガタ落ちするレベルで影響がでてきます。
アイテムを一箇所にまとめておいて擬似的な「無限湧き」を作るようなことはやめておきましょう。結論からいうとUdon Synced Variablesはパフォーマンスのために 「使わない」 が正解です。UdonにはUdon Synced Variablesという機能があります。
こちらは指定したプリミティブな変数をネットワークをまたいで同期する機能です。
（U#でいうところの[UdonSynced]）ですがこのUdon Synced Variables、挙動が結構ヤバイです。同期するオブジェクト、変数の数が増えるとDeath Run Detected: dropped N eventsというエラーが大量に出てきます。
これが発生してしまうと、変数同期の成功率が極端に下がってしまいます。
(大量にパケロスしている様子)そのため、Udon Synced Variablesで大量のデータを同期することはまったくオススメできません。たとえば、オブジェクトの位置と姿勢（Vector3 + Quaternion）をUdon Synced Variablesで同期するのは止めたほうがいいでしょう。
私が試した場合ではオブジェクト数が20個を超えたあたりからパケロスが発生しました。
さらにVRChatの通信にかなりの負荷をかけるためか、Playerの挙動までもが不安定になりました。ちなみに、この仕様ではほぼ使い物にならないのでフィードバック報告済みではあります。VRChatのフォーラムのこちらの投稿では次のように報告されています。とのことなので、Udon Synced Variablesを使う場合はオブジェクト数が少ない場合のみにした方が無難でしょう。また、とある場所で「オブジェクトの状態をstringにエンコードしてUdon Synced Variablesで同期する」という手法が提案されていました。Udon Synced Variablesで配列が同期できないのを回避するために編み出された手法ですが、こちらかなりコストが高いです。そのため本当にどうしようもないときの最終手段としとっておいて、常用はしないほうが無難でしょう。
（とはいえどこれしか方法が無いならば使わざるを得ないのがUdonのツライところなのですが…。）オブジェクトの位置を同期する方法ですが、次の2とおり（実質1とおり）があります。Aのパターンは前述の問題があるのでオススメできません。
ということで実質的にBの「Synchronize Position」一択になります。このSynchronize Positionはちゃんと差分同期してくれるため、大量にオブジェクトがあってもネットワークへの負荷は小さいです。Synchronize Positionは差分同期してくれるためネットワーク負荷は小さいのですが、大量にオブジェクトがある場合、後からワールドに参加した人には正しく位置と姿勢が同期されない場合があります。
こちらはワールドにいるプレイヤー数とオブジェクト数によりますが、「5人以上かつ20個くらいオブジェクトを動かした」あたりから発生してきます。原因はハッキリとはしていないのですが、どうも次の複数の問題が絡んでいるっぽいです。前者についてはバグ報告済みですが、後者についてはいまいち挙動がつかめていないため報告していません。対処療法として、次の対策をいれましょう。
実際にモノレールワールドで実施している対策がこれです。触れていないPickupオブジェクトはすべてMasterが所有権をもつ強制的に位置を同期する仕組みをいれる
（同期ズレの発生をゼロにはできないので、同期ズレが起きる前提で対策した方が早い）かなりツラミがある仕組みですが、現状これくらいしか大量のオブジェクトを安定して同期する方法がありません。Udonつらいし、UdonSharpも結構ツライです。
それなりのUnity開発経験と、Unityでパフォーマンスチューニングをできるスキルが求められますね。


