この記事は C# Advent Calendar 2020 21日目の記事です。僕はとある会社で働いているのですが、頑なにReactiveExtensions（以下Rx）に拒否反応を示す先輩がいます。
Rxの使い方と導入の利点を説明したのですが、なかなか理解してもらえず…。
そこで自分自身もRxの利点をきちんと理解し、胸を張って説明できるのか？と不安になってきたため、ここに整理してみます。いきなり本題ですが、「なぜRxを導入すると幸せになれるのか」。
幸せになれるというのはただのキャッチフレーズであり言いすぎですが、なぜRxを導入するべきなのか。それは、RxとはC#標準機能であるeventの完全上位互換1となる機能を提供するライブラリであるからです。つまり、Rxを導入すると標準のeventではできなかった、あんなことやこんなことが簡単にできるようになり、結果的にソースコードの可読性・保守性が飛躍的に高めることができます。
また、コード全体でRxを導入することで、イベント駆動型2のコーディングスタイルとなり、結果的にクラス同士が疎結合となるような設計がしやすくなります。ここで重要なのは、eventに対してRxが追加で提供する機能が、とんでもなく強力であるということです。
具体的には、eventに比べて以下のような機能が追加で提供されます。一つずつ簡単な例を示します。この機能がRxのメインというか、要となる機能です。
IEnumerable&lt;T&gt;でおなじみのLINQメソッド群を、ほぼそのままeventの発行値に対して適用することができます。具体的には、以下のような事が可能になります。Subscribeというのは後で詳しく説明しますが、イベントを購読するという意味です。
要は、発行されたイベントをそのまま購読するのではなく、WhereやSelectといったLINQメソッドチェーンを自由に適用し、都合の良い形に変形した上で、イベントを購読することができるというわけです。これを同じことをeventでやろうとすると、LINQメソッドチェーンが使用できないため、次のようになります。LINQメソッドチェーンを利用した場合に比べ、ひと目でなにをやっているのかを理解することができず、可読性が低くなっています。
また、LINQのように処理がブロックごとに分離されていないため、変更に対して弱いという欠点もあります。これは簡単な例なのでまだ良いのですが、複雑な処理になればなるほど、イベントの発行値に対してLINQオペレータが適用できるというRxの利点は、極めて大きく重要なものとなってきます。C#標準のeventはオブジェクトではないため、イベントを購読できる人はイベントに直接アクセスできる人だけとなります。
ところが、Rxの場合はイベントの購読権をIObservableというオブジェクトとして表現されるため、イベントの購読権を自由に別のクラスに引き渡したりすることができます。具体例を見てみます。
まず、標準のeventの場合。eventがオブジェクトではないため、eventを購読できるのはそのイベントを発行するクラスのインスタンスを保持しているクラスのみとなります。次に、Rxの場合。
Rxの場合は購読する権利をIObservableというオブジェクトとして表現されるため、購読権を他のクラスに引き渡すことで、イベントを発行するクラスのインスタンスを直接保持していなくてもイベントの購読が可能となります。C#標準のイベントの場合、一度登録したイベントを解除するには-=演算子を利用して、登録したときと全く同じメソッドを指定する必要があります。
つまり、ラムダ式を登録した場合は解除できなくなってしまうのです。一方、Rxの場合はSubscribeしたときに出てくるIDisposableをDisposeするだけで済みます。具体的には以下のような感じになります。Rxでは、イベントの購読権がIObservableというオブジェクトとして表現されるのと同様に、イベントの解除権もIDisposableというオブジェクトで表現されることもポイントです。
例えば、複数のイベントを購読して出てきたIDisposableをListにためておき、後でまとめて購読解除するといったことも容易に実現可能です。ちなみに、上記のようなことが容易に行えるCompositeDisposableクラスやAddToメソッドもあります。詳しくはググってみてください。このように様々な利点があるRxですが、どのような場面で利用できる・効果を発揮するのでしょうか？
大きく分けて、次の２つの場面で役立てることができると考えています。１つ目は、クラス間でメッセージ（データ）のやり取りを行いたい場面です。
これはつまるところ、eventの代わりとして利用できますという意味です。
Rxはeventの完全上位互換なので当然ですね。すでに説明したように、Rxはeventに比べて非常に強力な機能が追加で利用できるため、わざわざeventを利用する意味はありません3。Rxを使いましょう。２つ目は、一定、または不定の時間間隔である処理を行いたい場合です。
いわゆるタイマー処理です。Rxはこの場合にも、その威力を存分に発揮します。というのも、Rxには一定、または不定の時間間隔でイベント（IObservable）を発行するクラスを生成するファクトリメソッドが、予め用意されているのです。
そのため、時間間隔で何かをしたい場合、利用者はただ、その用意されたファクトリメソッドを呼び出し、イベントを購読して処理を登録するだけで済みます。System.Windows.Forms.TimerとかSystem.Threading.Timerは不要です。Unityの場合はTime.deltaTimeをアレコレしたり、WaitForSecoundsをどうこうする必要はもうありません。具体的には後で説明しますが、簡単に書くと次のように非常に簡潔に一定の時間間隔で処理を行うことができます。やっていることとしては「『一定間隔でイベントを発行するクラス』からのメッセージを受け取って一定の処理を実行する」のと同じであるため、本質的には「1.クラス間でメッセージのやり取りを行いたいとき」に帰着します。Rxの利点と使い所がわかったところで、実際にどのように使うのかを説明したいところですが、その前にRxを使用する上で最低限必要な知識をここで紹介します。Rxはデザインパターンの一つであるObserverパターン が基礎になっています。Observerパターンについて詳しく知りたい方は、別記事を書きましたので↓を参照してください。C#でObserverパターンをきちんと理解して実装するところが、実際にRxを使う上ではObserverパターンそのものを意識する必要はあまりありません。
その上で、どうしてもRxを使う上で必要となる次の3つのクラスとインターフェイス、それからSubscribeメソッドのオーバーロードについて簡単に説明していきます。
※一部↑の記事と内容が重複しています※この記事では必要最低限の解説のみ行います。詳しい説明は↑の記事を参照ください。IObserver&lt;T&gt;インターフェイスは、発行された値を受け取るクラスが実装するインターフェイスです。定義は次のようになっています。IObserver&lt;T&gt;に値を通知したい人は、このOnNextメソッドの引数に通知したい値を乗せて呼び出すことで、値を通知することができます。
また、「もう発行する値がない」ことを伝えるOnCompletedメソッドや、値の発行元で何らかの例外が発生してしまったことを伝えるOnErrorメソッドも用意されています。IObservable&lt;T&gt;インターフェイスは、値を発行するクラスが実装するインターフェイスです。定義は次のようになっています。このクラスが発行する値を受け取りたいクラスは、このSubscribeメソッドに自分自身を引数で引き渡して呼び出すことで、発行先として登録することができます。
※値を受け取るクラスはIObserver&lt;T&gt;である必要があります発行先のIObserver&lt;T&gt;を受け取ったObservableなクラスは、値を発行するタイミングで、受け取ったIObserver&lt;T&gt;をOnNextすることによって、値を通知することができます。ここまでが、ベタなObserverパターンの簡易的な説明になります。
繰り返しになりますが、きちんとObserverパターンを理解したい場合は下記記事を参照ください。
C#でObserverパターンをきちんと理解して実装するベタなObserverパターンでも値の発行と受け取りは可能なのですが、次のような問題が発生してしまい使い勝手が悪いです。値を発行する側のクラスは、同じ型の値を複数種類発行することができません。例えば「キーボード」を例にとって考えてみます。
キーボードは、押されたキーをPCに送信します。このとき、同時押しを考慮すると、「押されたキー」だけではなく「離されたキー」の情報もPCに送信しなければなりません。
つまり、「押されたキー」「離されたキー」の２種類の値をPCに発行したいことになります。これをそのまま実装しようと思っても、、このように、押下されたキーの通知と、押下状態を解除されたキーの通知が混ざってしまい、それぞれを分けて通知することができません。この問題は受け取る側（Observer側）にも発生します。
理由は、IObserver&lt;T&gt;インターフェイスを複数個実装できないため、受け取り口が同じになってしまい、これまたすべての通知が混ざってしまうからです。例えば、次のようにPCにに2台のキーボードを接続し、キーボードからの入力を購読したとします。
しかし、両方のキーボードからの通知が同じOnNextに来るので、どちらのキーボードからの入力なのか判別できません。これらの問題を解決するために、Rxには次に紹介するSubject&lt;T&gt;クラスが用意されています。Subject&lt;T&gt;クラスは、 IObservable&lt;T&gt;インターフェイスとIObserver&lt;T&gt;インターフェイスを両方実装したクラス です。
つまり、Subject&lt;T&gt;は、「値を受け取る機能」と「値を発行する機能」を併せ持ったクラス、ということになります。これがどう役立つのかというと、ちょうど 値の発行側と受け取り側の仲介役 のような役割を果たしてくれます。今までのベタなObserverパターンでは、ObserverがObservableに自分自身を値の発行先として登録して、Observableは登録されたObserverに値を渡す…といったように、ObserverとObservableが直接繋がっていました。
直接つながっているが故、お互いが言わば密結合のような状態になり、ObserverはSubscribeしたただ1種類の値しか受け取れないし、Observableも自分が発行する値をただひとつに定めなければなりませんでした。そこへ、仲介役となるSubject&lt;T&gt;クラスを登場させることにより、互いの密結合を解消させることができます。
しかも、Subject&lt;T&gt;クラスはIObserver&lt;T&gt;とIObservable&lt;T&gt;の機能を持っているので、もはや元の「値を受け取るクラス」と「値を発行するクラス」がそれらの機能を持つ必要はありません。
購読者の管理、発行された値の通知といった煩雑な処理は、全部Subject&lt;T&gt;が担ってくれるので、元のクラスはそのクラス本来の責務に専念することができるようになります。しかも！Subject&lt;T&gt;クラスは完全に独立した存在なので、発行したい値のぶんだけ、好きなだけ仲介役を生成することができます！
これによって、ベタなObserverパターンのデメリットとして挙げた「ただ一つの種類の値しか発行・購読ができない」を解消させる事が可能となります。以下にSubject&lt;T&gt;クラスによる利点を整理しておきます。実際にどのようにSubject&lt;T&gt;クラスを使用するのかは、「Rxを使ってみる」の章で説明します。Subject&lt;T&gt;クラスの登場により、値を受け取るクラスはIObserver&lt;T&gt;である必要がなくなりました。
そのため、Subscribeメソッドの引数で指定するIObserver&lt;T&gt;をどうするかという問題が発生します。ここで、IObserver&lt;T&gt;インターフェイスの役割について考えてみると、ただ「値を受け取ったときに任意の処理を実行できる」ということでした。
であれば、次のように任意の処理を直接指定できてもよいのでは？と考えることができます。Rxには、このSubscribeメソッドのオーバーロードが用意されているため、値を受け取るクラスはIObserver&lt;T&gt;である必要はなく、値を受け取ったときのコールバック処理を直接指定することができるようになっています。実際にどのようにSubscribeメソッドのオーバーロードを使用するのかは、「Rxを使ってみる」の章で説明します。Rxを使う前に、Rxを使えるように開発環境を用意する必要があります。
とはいっても、大したことは有りません。VisualStudioによるWindowsアプリケーション開発の場合、VisualStudioのNuGetを使ってSystem.Reactive.Linq System.Reactive4をインストールすれば完了です。

↑画像はSystem.Reactive.Linqを指していますが、System.Reactiveをインストールしてください。Unity開発の場合はAssetStoreからUniRxをインストールすれば完了です。それでは、IObserver&lt;T&gt;インターフェイス, IObservable&lt;T&gt;インターフェイス, Subject&lt;T&gt;クラス、Subscribeメソッドのオーバーロードについて理解したところで、実際にRxを使ってみます。値を発行したいクラスが値を発行するには以下のようにします。具体的なソースコードは以下のようになります。AsObservableはなくても良いのですが、つけておくとIObservable&lt;T&gt;をSubject&lt;T&gt;にキャストされるのを防ぐことができます。値を受け取りたいクラスが値を受け取るには以下のようにします。具体的なソースコードは以下のようになります。上記の例では、ReceiveClassがPublishClassのインスタンスを直接参照しています。
この方法でももちろん値の受け取りは可能なのですが、下記のようにIObservable&lt;T&gt;を引き渡す専用のインターフェイス経由でアクセスするように設計すると、ReceiveClassからPublishClassへのアクセスが読み取り専用であることが保証され5、より良い設計となります。このように、値の購読のみが可能な読み取り専用インターフェイス経由でアクセスさせることで、例えPublishClassに読み取り専用ではないメンバが存在したとしても、ReceiveClassからは読み取り専用であることが保証されるため、保守性の向上に繋がります。インターフェイスを利用する利点については、下記記事に詳しく記載していますので、適宜参照ください。【C#】インターフェイスの利点が理解できない人は「インターフェイスには３つのタイプがある」ことを理解しようここからがRxの本領発揮です。
これまで紹介した「値の発行・受け取り」は、C#標準のeventでも全く同じことができます。
しかし、Rxを使うと、以下のようにLINQを利用して受け取ったデータを自分の都合の良いように自由に加工することができます 。LINQオペレータがIEnumerable&lt;T&gt;を受け取ってIEnumerable&lt;T&gt;を返すように、RxオペレータもIObservable&lt;T&gt;を受け取ってIObservable&lt;T&gt;を返すように設計されているため、このようなことが可能となります。他にもいろいろなオペレータが用意されています。詳しくは @toRisouPさんの下記のような記事が役立つと思いますので参照ください。UniRx オペレータ逆引き今までは、自作クラスの内部にSubject&lt;T&gt;を持って値を発行したいタイミングでOnNextを行うように、「値の発行側」を自前で作っていました。
しかしRxには、便利な「値の発行側」があらかじめ用意されています。これらは、IObservableを生成することから、「ファクトリメソッド」と呼ばれています。ここでは、Rxに搭載されているいくつかのファクトリメソッドのうち、個人的にもっともよく使用するObservable.IntervalファクトリメソッドとObservable.FromEventファクトリメソッドを紹介します。Observable.Intervalファクトリメソッドは、一定時間間隔で値を発行するIObservable&lt;T&gt;を生成するファクトリメソッドです。
引数にTimeSpan構造体を入れるだけで、その指定した時間間隔で値を発行してくれるIObservable&lt;T&gt;が手に入ります。
発行される値は、0から順にインクリメントされたものになります。次のように使用します。このコードを順に追って説明します。出力結果は次のようになります。このように、1秒間隔で値が発行されていることがわかります。Observable.Intervalファクトリメソッドを使うと、このように簡単に一定時間間隔で値が発行されるIObservable&lt;T&gt;を作り出すことができるので、一定周期で一位の処理を行いたい場合などに非常に便利です。ちなみに、一定間隔ではなく「任意の時間間隔」で値を発行することもできます。
少しやり方が複雑になるのですが、興味がある方は下記記事も参照ください。
【ReactiveExtensions】任意の時間間隔で値を発行する2つの方法Observable.FromEventファクトリメソッドは、その名の通り「C#標準のイベント」をIObservable&lt;T&gt;に変換するファクトリメソッドです。
記事の冒頭で説明した「イベントのオブジェクト化」を実現するファクトリメソッドでもあります。このファクトリメソッドを利用して、例えばクラスライブラリから提供されるeventをIObservable&lt;T&gt;に変換することで、LINQオペレータを適用する、eventのオブジェクト化により別のクラスに購読権を引き渡すといった、Rxの利点を活用することが可能になります。例えば、System.Windows.Forms.ButtonのClickイベントをIObservable&lt;Unit&gt;に変換するには以下のようにします。引数が複雑なのですが、簡単に書くと第一引数には「eventから発行された値をどのようにIObservable&lt;T&gt;シーケンスに伝達するか」、第二引数には「Subscribeされたときの処理」、「第三引数にはDisposeされたときの処理」を記述します。本当はもう少し詳しく書きたいのですが、アドベントカレンダーの公開まで時間がないので割愛させていただきます（残り5時間あまり。。）Rxには他にも多数のファクトリメソッドが用意されています。詳しくは、@okazukiさんの下記記事などを参考にすると良いと思います。
Reactive Extensions再入門 その３「IObservableのファクトリメソッド」長くなってしまったので、以下にRxを導入する利点をまとめます。Rxを導入するとソースコードの可読性の向上に繋がります。
具体的には、次の2つの要因が可読性の向上に寄与します。これはもう言わずもがなと思いますが、RxのLINQ機能を利用することで、可読性の向上が期待できます。C#標準のイベントを使い続け、以下のようなコードになっていたら目も当てられません。RxとLINQを利用すると、以下のように簡潔に分かりやすく記述できます。
どちらが可読性が高いかは一目瞭然です。Rxをプロジェクト全体に導入すると、自然とイベント駆動型のコーディングスタイルとなります。
そのため、「情報を欲しい人が取りに行く」という自然なソースコードになるため、可読性の向上が期待できます。例えば、「情報を持っているクラス」と「その情報がほしいクラス」があるとします。
Rxを導入しない場合、「情報を必要とするクラス」は情報をもらう口となるようなメソッドを用意しておき、情報の獲得に関し受動的であるようなコードになることがあります。しかし、このようなコーディングスタイルはいささか不自然に感じます。
本来、「情報は必要とする人が取りに行く」というのが自然であると考えるからです。Rxは、まさにこの「情報は必要とする人が取りに行く」コーディングスタイルが実現されるため、各クラスが自然な行動になり、可読性が向上します。前項で紹介した「情報を欲しい人が取りに行く」という自然なコーディングスタイルは、変更に対しても強いです。「情報を欲しい人」が情報の獲得に対し受動的なコーディングスタイルの場合、「情報を欲しい人」が増えた場合に、情報の発信元にも変更が必要になってきます。
ところが、「情報を欲しい人が取りに行く」場合、「情報を欲しい人」が増えたとしても、情報の発信側には何も影響がありません。
前述した通り、Rxを導入するとイベントをIObservable&lt;T&gt;オブジェクトとして扱えるようになります。
IObservable&lt;T&gt;オブジェクトは「情報の購読権」として自由に引き渡しが可能であるため、情報の発信ソースを直接知らないクラスでも、IObservable&lt;T&gt;オブジェクトを引き渡すことで情報の購読が可能になります。Rxを導入しなかった場合、イベントをオブジェクトとして扱えないため、情報を購読するためには、その情報を発信しているクラスを直接知る必要が出てきます。
それ故、本来関わる必要がなかったクラス同士が関わってしまい、クラス同士の結合度が高くなる恐れがあります。
学習コストが高いと思われがちなRxですが、この記事で紹介したような「値の発行」「値の購読」「LINQの適用」などの基本的な部分だけならそこまで学習コストは高くありません。
以下の通り再掲しておきます。IEnumerable&lt;T&gt;のLINQと全く同じように利用可能です。
一部IEnumerable&lt;T&gt;にはあるけどIObservable&lt;T&gt;にはないオペレータや、その逆もありますが、調べながら使っていくうちにだんだん覚えていくと思われます。ただ、Rxを本格的に使い込んでいくならば、IObservable&lt;T&gt;のHot-Coldの違いなど、少し踏み込んだ部分の理解も必要になってきます。
この章で言いたいのは、「学習コストが高そう」という理由だけで、Rxを導入する多大なメリットを捨てないでほしいということです。[追記]
RxのHot-Cold関係の記事を書きましたので、Rxを少し使い慣れてきた頃にご覧ください！アドベントカレンダーの投稿期限ぎりぎりになってしまったため、最後駆け足な感じになってしまいましたが、Rxを導入する利点の説明になっているでしょうか。
普段Rxを多用していますが、「なぜ、Rxを導入するべきなのか？」という点について、他人にきちんと説明できるかが不安で整理してみました。色々ツッコミどころがあるかと思いますが、もしよければコメント残していただけると幸いです。また、下記に参考にさせて頂いた記事、及びRxの理解に役立った記事のリンクを掲載させていただきます。「Rxはeventの完全上位互換」というフレーズは@toRisouPさんのこの記事から学ばせていただきました。 ↩イベント駆動型という表現が適切かどうかあまり自信がありません… ↩Rxの利点をすべて利用しない（event標準機能だけで事足りる）ことが確定している場合はこの限りではありません。 ↩@soi様より指摘いただきました。System.Reactive.Linqは互換性のために残っているパッケージだそうで、今はSystem.Reactiveをインストールすれば良いそうです。 ↩IObservable&lt;T&gt;はSubscribeのみができるインターフェイスなので、IObservable&lt;T&gt;は読み取り専用です。したがって、IObservable&lt;T&gt;しか公開しないインターフェイスは、読み取り専用となります。 ↩Timestamp()を通過すると、流れてきた値はTimestamped&lt;T&gt;という構造体にラップされます。この構造体はT型のValueプロパティとDateTimeOffset型のTimestampプロパティを持ち、それぞれラップされた値とタイムスタンプを取得できるようになっています。 ↩


