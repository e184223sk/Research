とりまやってみましょう。
Azure Communication Services は Azure 上に必須なので作ります。これは Functions で行います。こちらにある通り。Azure Functions を使用して、信頼できる認証サービスを構築する今回は以下のような感じでいこうかなと思います。URL のクエリに id という名前のパラメーターがあるときは、それをユーザー ID としてトークンを取得。id 指定がない場合はユーザーを作成してトークンを取得といった感じにします。id は、適当な値を設定しても Azure Communication Services ではじかれるので、初回は id 無しで呼び出して 2 回目以降は id 指定で行く感じです。戻ってくる JSON はこんな感じでAzure Functions のプロジェクトを作って local.settings.json に Azure Communication Services の接続文字列を追加します。Microsoft.Azure.Functions.Extensions と Azure.Communication.Administration (preview) パッケージを追加して以下のように Startup.cs を作ります。では、Token を作成する関数を作ります。HttpTrigger の関数で CommunicationIdentityClient を使ってトークンを生成して返します。まずは、戻り値のクラスを定義して…関数本体を実装します。次に人が集まって会話するスレッドを作成する関数を追加します。このスレッド ID が一緒じゃないと一人チャットになるので、スレッド ID は皆で共有できないといけません。
実は先ほど作ったユーザーの ID も、システムで管理してる（もしくは外部の ID プロバイダーの）ユーザーとの紐づけの管理とかは自分で作りこまないといけません。今回はユーザー管理は毎回ユーザーを作るという手抜き実装ですがスレッド ID は共有しないとみんなでチャット出来ないので頑張って作ります。ただ、 Cosmos DB とかに保存する処理とかを作るのはだるいのでメモリ上に保持するようにします。なので、Azure Functions がスケール アウトやスケール インすると不都合が起きますが、ちゃんと DB を使えばうまくいくはずです。今回はグローバルで 1 つのスレッドという感じになるべくなるように実装していきます。Server のプロジェクトに Azure.Communication.Chat パッケージを追加して GetToken メソッドでスレッドが無ければ作るように変更します。local.settings.json にスレッド ID を作るために必要なエンドポイントの設定も追加します。そして、GetToken.cs にスレッドも作る処理を追加しておきます。こうすると GetToken 関数の結果に threadId が追加されます。最後にローカルデバッグ時用の CORS の設定を追加します。local.settings.json に CORS の設定を以下のように追加しておきます。次にクライアント側です。Blazor のプロジェクトを作りましょう。そして Azure.Communication.Chat (preview) パッケージを追加します。とりあえずローカル実行時は、Azure Functions のローカルサーバーを見に行くようにします。Program.cs を以下のようにします。wwwroot フォルダーの下に appsettings.Development.json という名前で以下のファイルを置いたら構成は完了です。ではつないでいきます。繋ぐためにはエンドポイントが必要なのでクライアントの構成ファイルに書いておくようにします。appsettings.Development.json に以下のように設定を追加します。追加した設定を保持するためのクラスを定義します。そして Program.cs に、設定をクラスに読み込んでおく処理を追加します。そして、チャットのやり取りをするクラスを定義します。ここらへんは ChatClient や ChatThreadClient を使ってサクッと作れます。Program.cs にコンテナに登録する処理も追加しておきましょう。仕上げに Index.razor です。async foreach で脳死で読み込めばいい感じにメッセージがくるたびに読み込んでくれるかと思ったら、ダメだったので泣く泣くメッセージの重複管理を自前でやってます。これチャットが長くなると毎回データとってくるのつらいのでは…。そのうち API がいい感じになるのかな？？ローカルで動かしてみましょう。起動直後名前を入力したところ（複数ブラウザで試してみてる）メッセージうってみたGitHub にリポジトリを作ってお約束の手順でデプロイしてみました。今回はこんな感じのレイアウトなのでそれにあわせて、こんな感じで作りましたデプロイが完了したら構成に Azure Communication Services 関連の設定を追加しておきます。クライアント側にも appsettings.Development.json しかなかったので appsettings.json を足しておきます。Azure Communication Services 関連の設定だけ引っ越ししましょう。以下のようにStatic Web Apps にデプロイしてもとりあえずは動きました。ということで Azure Communication Services で一番とっつきやすいチャット機能を Blazor + Functions で試してみました。デプロイ先は Static Web Apps です。試してみた感じ、Azure Communication Services は ID は発行してくれるけど、それが実際に誰なのかということは自分で管理しないといけないなという感じでした。あと、ちゃんと作るときは Azure AD や Azure AD B2C か、それに準ずる何かしらでログイン機能も実装しておかないとフリーダムなチャットになりそうだなと思いました。
後は誰がどんなスレッドを持ってるのかとかも、おそらくアプリ側で管理することになる気がします。あくまで Communication Services が提供するのは作成と ID 指定での検索だけっぽいです。
なのでちゃんと作るとしたら最低でも以下のような雰囲気になる気がします。仕様なのかバグなのかわかりませんが C# SDK は今のところポーリングしてメッセージとってくるのですが、毎回メッセージが全部返ってくるので、誰か差分だけいい感じにとってくる方法を教えてください。startTime 引数と AsPages で continueousToken を指定しても、全部返ってきました orz現状、C# SDK でメッセージのポーリングをするときは、受信したメッセージの最後のタイムスタンプの１秒後から取得するようにすると、一応続きからとれるみたいです。内部的にミリ秒まで持ってたらロストするメッセージもあるかもしれませんが…。
startTime 引数に前回取得したメッセージの一番大きなタイムスタンプ + 1 秒したものを渡すようにしましょう。JavaScript の SDK には、チャットメッセージがきたらコールバックが呼ばれるというタイプのものがあるみたいなので、そのうち C# にも来るといいな。まぁまだプレビューですしね。音声チャットも試してみたいな。


