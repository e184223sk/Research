More than 1 year has passed since last update.IT未経験者が学んだことをアウトプットします
分かりにくいと思いますが宜しくお願いします。
今回はC#です。配列の中に配列があるもの。
定義するときは [][]を2つつけます。出力はforやforeachを2重で使うiで2次元配列teamsのインデックス番号を指定します。
teams[i]と記述して
teams[0]なら、{"aさん","bさん","cさん"},の配列
teams[1]なら、{"dさん","eさん","fさん"},の配列
teams[2]なら、{"gさん","hさん","iさん"},の配列です。
配列の数だけループを繰り返すため、for文の条件ではi&lt;teams.Length;としています。jで2次元配列の中に入っている配列の要素を指定しています。
teams[i][j]と記述し
teams[0][1]なら、teamsのインデックス番号0の要素(配列)は、{"aさん","bさん","cさん"}です。
{"aさん","bさん","cさん"}のインデックス番号1の要素はbさんです。
なので になったときはbさんが出力されます。2次元配列なので、ループの中のループであるjの全てのループが終わるまでiのループは実行されない。
jの繰り返す条件は、j&lt;teams[i].Length;なのでjが3回ループされるまでiのループは実行されないiのループに入りjのループに入って
teams[0][0] teams[0][1] teams[0][2]　が出力される
jが3回ループし、ループの条件を満たさなくなったのでjのループを抜ける
iのループの条件はまだ満たすので再びiのループに入りjのループに入る
teams[1][0] teams[1][1] teams[1][2]　が出力される
jが3回ループし、ループの条件を満たさなくなったのでjのループを抜ける
iのループの条件はまだ満たすので再びiのループに入りjのループに入る
teams[2][0] teams[2][1] teams[2][2]　が出力されるiのループの条件も満たされなくなったのでiのループを抜けて出力処理終了です。ご精読ありがとうございました。
コロナウイルスには気をつけましょう


