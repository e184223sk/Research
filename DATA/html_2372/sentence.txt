More than 1 year has passed since last update.特殊な状況下なので、万人に役にたつかは微妙。
あ、たぶん。役に立たないです。
リフレクション使えば、例外回避して設定できるのかーぐらいかな。
（そもそも、リフレクション使う人は、それぐらい知ってると思うが）DataGridViewを使いスプレッドシートの入出力画面を作成した。
カラムヘッダは独自に直接セル結合を行っていてFixed設定をしている。
※カラムヘッダは非表示(ColumnHeadersVisible = false)
ロウヘッダは行選択をするため残している。(RowHeadersVisible = true)DataGridViewの縦スクロール時に、上下端からスクロールする場合のスピードが顕著に遅い（カクカクする）DataGridViewはDataSourceを切り替えて使いまわしているが、遅いのは特定の場合で、すべてが遅いわけではない。データ量の問題かと、表示レイアウトはそのままにDataSourceのみ変更したところ変化が無いことがわかった
⇒ つまり、データ量、DataSouceは関係ない遅いところと、そうでないところの違いを調べたところ、
RowHeadersVisible の違いがあることがわかり、非表示にしたところパフォーマンスが改善した。これが問題か？RowHeadersVisible の設定でのパフォーマンス有無についてネットで調べたが特に有益な情報は得られず。
パフォーマンス改善について、ダブルバッファリングの手法があることがわかった。
以下、対応内容と採用可否である。RowHeadersの非表示
時間があれば、独自実装して１カラム目をヘッダーのように扱うことは可能だが、ナイーブな（お察し下さい）実装のため残念ながら採用できない。ダブルバッファリング
ネットで多くみかけたのですが、実際に試してみると、
早くはなるものの、結合セルの部分の再描画が行われる黒くなり使い物にならない。ここで手詰まりかと思っていたが、天からのひらめき。
RowHeadersVisibleのtrue/falseで、スピードが変わるならColumnHeadersも効果あるのでは？ということで、第三の方法として　3. ColumnHeadersの「表示」
本来、非表示であるカラムヘッダを表示してみたところ、パフォーマンスが改善されたのである。結局原因自体は、よくわからんが、カラムヘッダを表示した場合、パフォーマンスが改善された。
ちなみに、検証結果は以下の通り。
ピンポイントの組み合わせで遅かったよ・・・（多くの人は、この事象に出会わないのでは？）というわけで、ヘッダの高さをゼロにして非表示扱いにしてみよう。
というのが今回のまとめになる。ところが、ゼロを実際に設定してみたところ例外が発生した。MSDN(DataGridView.ColumnHeadersHeight プロパティ)を見ると３以下は設定できないようだ。じゃあ、リフレクションを使ってみようと試してみるが、プロパティはあってもフィールドが見つからない。(NonPublicを指定しているのに)
プロパティ(PropertyInfo)のSetValueを使ってみると例外が発生する・・・と、しばらく格闘していたが、わかってみればなんのことはない。
使っているクラスが、CommonFramework.Forms.DataGridViewでなく、それを継承したクラスだったからだ。
なまじpublicのプロパティが見えるので気づくのに時間がかかった。というわけで、以下のコードで対応。なるほど。インスタンスからGetTypeするから混乱の元になったのか。
完全に動的に操作する必要ないから以下で大丈夫だった。
※とはいえ、フィールド名 columnHeadersHeight を特定するのが大変だったわけだが。.Netのバージョンだったり、そもそも継承の有無で役に立つ可能性は、わからないがメモとして残しておく。


