More than 3 years have passed since last update.『System.Lazyはスレッドセーフのためにどれほどコストを払っているのか？』ということを疑問に思い、ベンチマークを取ってみることにしたときのこと。以下のような2つのLazySlimをつくり、BenchmarkDotNetで初期化コストと値アクセスのコストを比較した。で、以下がその結果。Lazy&lt;T&gt;のスレッドセーフ化コストはどうやら初回アクセスのときだけ生じるらしい(約1.5倍)・・・
ということがわかったのはいいとして、注意を引くのがAccessValue_LazySlim1とAccessValue_LazySlim2の差。
AccessValueはValueプロパティにアクセスするだけなので、if文でHasInitializedを判定するコストしかないはずである。
にもかかわらず、初期化処理をgetter内にベタ書きしたLazySlim1は2倍近く遅くなってしまった。結局、その答えはリリースビルドのJITアセンブリを見なければわからない。違いはL005E以降。LazySlim2を使っている方はValueプロパティのアクセスにインライン化が効いている。
このインライン化のおかげで2倍もの速度差が出ていたわけである。こういった、ほとんどは値を返すだけだが極稀に処理をする系のプロパティでは積極的にメソッド分割していこう。
式表現と三項演算子を意識して使っていけば自ずとインライン化が効くコードサイズに収まるはずだ。C#ではインライン化の制御にMethodImpl属性が利用できるが、プロパティアクセサには適用できない。
潔くコードサイズで勝負しよう。冒頭のLazyについて、コンストラクタにLazyThreadSafetyMode.Noneを渡してやればスレッドアンセーフで高速な遅延初期化オブジェクトにできることを後で知った。わざわざLazySlimを実装する必要はなかったというオチ。


