Java8とC#でマルチスレッドとマルチプロセスの勉強をする。マルチプロセスとマルチスレッドの簡単なイメージは以下になる。マルチプロセスの場合は、メモリ空間が別になるので、データのやり取りにはプロセス間通信が必要になる。逆にマルチスレッドでは、メモリ空間が同じなため、複数スレッドが同時に同じデータにアクセスして、「レースコンディション」のバグがでないように、排他制御を行い、「スレッドセーフ」にする必要がある。マルチスレッドのメリットを２つ記載する。
・「フリーズ」状態にならず、すぐに応答する
　→非同期処理（並行）
・パフォーマンスが良くなる
　→並列処理Java8でGUIアプリケーションを作成しながらマルチスレッドの学習を行う。
以下の画面のアプリケーションを作成する。STARTボタンを押すと、1秒毎に画面中央に数値を表示する。本来はボタンを押した後は「0, 1, 2, 3 ,4」と表示されてほしいが、ボタンを押した後画面が固まり、最後に「4」だけが表示される。doInBackgroundの中でtextField.setText("" + i);がエラーにならないのはなぜだろう？
ワーカースレッドからUIを操作したらエラーになるのでは？ボタンを押した場合に、押された回数とカウンタを画面に表示するプログラム。
インスタンス変数のiはボタンを押される度にカウントアップする。
ボタンを押された後にiの値をjに格納している。画面にはjの値とカウンタkを結合して表示しているが、ボタンを連打した場合に、以下の用に表示されるが、その理由について確認する。メインスレッド(UIスレッド)でsleepを別スレッドで動かしているので、非同期になるので、処理が終了する前に画面操作ができるようになるのは理解できるが、処理が終わる前に再度ボタンを押したときの動きが理解できなかった。
jの値を何個も同時(上の例では0,1,2,3,4)に保持される仕組みがわからない。別スレッドを作って、スレッドの中にその変数を保持するのなら理解できる。async/awaitは糖衣構文(シンタックスシュガー)なのは知っていたので、実際のコードがどうなっているかを確認した。
確認するために、ILSpy(https://github.com/icsharpcode/ILSpy/releases)をダウンロードした。
exeファイルをILSpyにD&amp;Dしてソースコードを確認したが、元のコードのまま。(async/awaitが表示されている)
ILSpyのOption設定で、C#5以降のチェックを外したら実際のコードが表示された。
JavaDocにある「アンバウンド形式のキューなしで動作する～」などのアンバウンドとはunboundedで、無制限を表す。「サイズ制限のないキュー」という意味。future.cancel(true)を行うことで、cancelのフラグが立つ。
InterruptedExceptionをキャッチするか、Thread.currentThread().isInterrupted()でフラグを確認して、自分で処理する必要がある。cancel(false)は実行中の処理が中断されるわけではないので、どのように使うのか調べてみた。submitは遅延実行になるので、予約されているだけで実際に動くのはgetを呼ばれた時になる。
getを呼ぶ前にcancel(false)を実行すると、get時にCancellationException例外になる。別スレッドで発生した例外をメインスレッドで使用する方法について調べてみた。ExecutionExceptionが発生するので、getCause()を行うとRuntimeExceptionが、さらにgetCause()を行えば元の例外を取得できる。クラス変数として例外を定義し、例外発生時に、そこに発生した例外をセットする。


