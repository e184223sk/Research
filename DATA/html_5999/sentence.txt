More than 3 years have passed since last update.脳死でDisposeで解放してたら思わぬところで躓いたのでメモCompositeDisposableは簡単に言うとまとめてDisposeするためのクラスです
Rxライブラリより提供されています
IDisposableCollectionであり、自身がIDisposableであるところが特徴で、自身をDisposeすることで登録されている要素をまとめてDisposeします、便利ですね
もちろんRemoveなどすると要素ごとの削除に紐づいてその要素をDisposeしてくれますまず2つのソースを見比べます
違いとしてはDisposeの場合は内部でDisposeされたかどうかを記憶しているところだけです（個人的には変数でこうやって管理しているだけってところに驚きました）
disposeされた状態ではAddやRemoveを通らなくなります
Summaryでも書いてある通り、自身をDisposeするかどうか、の差です2つのCompositeDisposableを用意し片方を定期的にDispose、もう片方を定期的にClearして回数をカウントしつつ挙動を見ようというコードです
結果はこちら
Clearだけがしっかりと反映されており、Disposeに関しては一回呼んだ後は動作していません
これは1回目のDisposeで既に_compositeDisposale1自体がDisposeされてしまっているため、即座に解放されてしまっているというからくりですCompositeDisposableを引数としたAddTo自体がそもそも引数としてコンテナを指定し、Addをするという挙動なので上で書いた通りDispose済みであるため結果としてAddをすり抜けます
えっ、すり抜けるなら解放されないのでは…？とは行かないのですちゃんとAddのなかではDispose判定をし、shouldDispose、つまり解放済みのものにAddされた場合はすり抜けてDisposeを行います
なのでAddToが実質即座にDisposeを行ってしまっているので結果的にTest1とTest2が動作しないということですね自分はなんとなくClearのほうがいいとかは聞いたことがある程度で内部理解までには至ってませんでした、すごく単純なんですけど意外とハマってしまいました
1回きりならまだいいんですけど、基本的にはDisposeせずにClearしましょう


