More than 1 year has passed since last update.C#にはイテレータ（IEnumerator）が簡単で直感的に記述できる構文があります。
代表的な使い方の一つに、Unityではコルーチンを記述するために使用されていますが、元々はリストのような値を順番に取り出せるものを記述するためにあります。
このイテレータ構文が実際にはどのような動作をするのか、C#とILを実際に見比べながら確かめてみます。（コンパイルは.NETCore3.0）これを反復子（yield return）を使用せずに記述しようとすると、新しくクラスを作成し、この三つのメンバを実装しなければなりません。
一方で、反復子を使ったメソッドでは、returnするのはobject型であり（Generic版であればT型）IEnumeratorをreturnする記述はしません。
ILには反復子の命令はありませんので反復子で記述されたメソッドを上記のインターフェイスを実装するクラスに書き下す必要があります。（コンパイラがやってくれます）例えば次のような例を見てみましょう。これをコンパイルすると次のようになります。ILで書くと長いので、C#に書き起こしています。MoveNextは想像に難くない感じですが、Resetは使えなくなっているのですね。さらにメソッドを複雑にしてみます。次のメソッドでは、引数とローカル変数を使用しています。また、先ほどのとは異なり終了までの回数があらかじめわかっていません。これをコンパイルすると次のようになります。ILで書くと長いので、C#に書き起こしています。引数や、ローカル変数はクラスのメンバにキャプチャされます。反復子をまたぐローカル変数を使いまくるとモリモリとヒープが肥大化するので注意が必要です。
イテレータの回数が決まっていないので、switchによるジャンプはできず、条件式を評価するようになりました。しかし、一度終了した後は条件式を評価せず、終了したことがキャッシュされるようです。usingの方が単純なのでusingを使うことにします。lockやcheckもスコープを抜ける際に特定の（.Netの）メソッドコールがされるので実質的には同じものと思われます。
コンパイルすると次のように書き下されます。&lt;&gt;7__wrap1.Disposeや、&lt;Iterator1&gt;d_1.Disposeを経由してややこしくなっています。MemoryStream.Disposeはイテレータが終了する時のMoveNextまたは、毎MoveNextで例外が出たときに呼ばれます。つまり、必ず呼ばれる仕組みになっています。イテレータがちゃんと最後まで実行されれば…という前提ですが。C#の反復子は便利でちゃんと直感的な挙動をしてくれるようになっているようです。ファイルを一行づつ読んでいって…（using(StreamReader)）なども安心して使えます。
また、メソッドはクラスにコンパイルされるので、&lt;&gt;c__Iterator0.MoveNext null refarence exceptionみたいな知らないメソッドでエラーが出ても&lt;&gt;c_Iterator0…？反復子のメソッドから生成されたクラスだな、元のメソッドを見てみることができます。ちなみに、fixedやstackalloc、つまりunsafeとyield returnは併用できませんので検証していません。
try-catch-finallyはILレベルでサポートされています。これもそれぞれのMoveNextでtryされるようになります。


