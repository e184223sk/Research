More than 1 year has passed since last update.ソース生成時にたまにお世話になるBuildalyzerだが、実際に使う上でいくつか躓いた点があったので、書いておくBuildalyzerは、msbuildのビルド結果からプロパティやプロジェクトアイテムを組み立てるという仕組みになっている(2.x時点)。
また、Buildalyzer.Workspacesを使うことにより、この結果からRoslynワークスペースを作成し、アセンブリのシンボル等を取得することができる。Buildalyzer.Workspacesから作成した結果は、必ずしもdotnet buildの結果と一致するとは限らないという場合がある。
これはMSBuildとRoslynは互いに独立する概念であり、相互変換が必要になるために起きる問題であるということを踏まえる必要がある。例えば、Roslynワークスペースへの変換クラスを見てみると、一つ一つMSBuildプロパティからRoslynプロジェクトへの変換を行っていることがわかる。このため、AllowUnsafeBlocks等の、MSBuildプロパティで指定されるコンパイルスイッチは無視される場合もある(2.1.0まではDefineConstantsも渡されていなかった)。大抵のプロジェクトでは問題はないが、一部の特殊ケースでは問題になる場合もある。以下のように、GetWorkspaceなどで変換後、コンパイルオプションを再セットする。Buildalyzerは、プロジェクト解析のため、msbuildの実行結果を解析している。
そのため、ある程度のビルドが走るのは致し方ないが、時にビルド後に特殊なステップを導入していると、予期しない動作を招いてしまう場合がある。以下のようにビルドするステップを絞る。具体的に何をTargetsToBuildに指定すればいいかという点は、 dotnetのプロジェクトシステムのドキュメントや、ビルドログ等が参考になると思う。何のタスクを最低限指定すればいいかという点に関しては、テキストログ等から解析するのもいいが、バイナリログから構造的に解析するのもいいかと思う。さて、Buildalyzerは2.x現在cscの実行ログを元に、参照するドキュメントリストの取得を行っている。そのため、実際にコンパイルが実行されないと、空のRoslyn workspaceができてしまうことがある。そのため、Cleanタスクでファイルが消えることを避けるために除外すると、Build済みのプロジェクトで解析を行ったとき、空のRoslyn Workspaceができてしまうことがある。これを回避するには、IntermediateOutputPathにテンポラリのパスを設定し、実行前後で消すという対策が考えられる。なお、IntermediateOutputPathは、末尾に必ずディレクトリセパレータが入っていることが期待されているため、注意すること。
また、IntermediateOutputPathには$(TargetName)-AssemblyInfo.csが含まれているので、そのまま消さないでおくと、本体のビルド時に重複エラーが出てしまうので、プロジェクトツリー内に一時ディレクトリを作る場合、解析終了時には必ず消しておく必要がある。通常は凝ったビルド設定をすることもないと思うが、ハマるときはハマるので、この辺りは注意しておきたい。


