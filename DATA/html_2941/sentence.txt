.NET 4.0以降には、TaskCompletionSource&lt;T&gt;という非同期処理用のユーティリティがあります。イベントベースのAPIをラップしてasync/awaitの中に組み込むために使うもので、Future的な物です。Task&lt;T&gt; Task { get; }とvoid SetResult(T result);を持っており、tcs.SetResult("hoge")した結果を別タスクでstring result = await tcs.Task;として受け取るという調子で使います。The danger of TaskCompletionSource class という記事がMicrosoft Devblogsに載っています。
結論だけ抜き出すと「TaskCompletionSource.Taskがデフォルト設定ではシングルスレッド寄りで、デッドロックすることがあるのでTaskCreationOptions.RunContinuationsAsynchronouslyを指定したほうがよい」という記事です。解説がawaitの実装内部まで踏み込んでいて、面白い記事です。記事中にサンプルがあるのですが、断片的な感じでコピペして実行ができなかったので、補いました、というのがこの投稿です。TaskCompletionSourceより後発のユーティリティとしてChannelがあります(初出は .NET Core 3.0)。名前の表す通りキューの長さが指定できて、無限もOKという、TaskCompletionSourceの上位互換です。こちらも上と同様、AllowSynchronousContinuations
というタスク生成オプションがあります。デフォルトはfalseで、TaskCompletionSourceと逆です。つまり、taskCompletionSource.SetResultはデフォルト設定ではスレッドが一本に戻りますが、await channel.WriteAsync(...)では戻りません。この点があるのでChannelでデッドロックしないことはわかっているのですが、一応試しました。これもソースを載せます。まず、デッドロックするサンプルです。元記事になかったPrint関数を補って実行できるようにしました。以下、ログ行頭の番号はスレッドIDです。記事で解説されているように、TaskCreationOptions.RunContinuationsAsynchronouslyを指定するとデッドロックしなくなります。上記サンプルでTaskCompletionSourceを使っているところに代わりにChannelを使うとこうなります。1標準でTaskCreationOptions.RunContinuationsAsynchronously相当の動作をするようです。
シングルスレッド寄りの動作にするオプション(new BoundedChannelOptions(1) { AllowSynchronousContinuations = true })を渡したところ、しっかりデッドロックしました。ChannelのデフォルトオプションはTaskCompletionSourceより安全寄りになっており、性能を追求したいときにオプションを指定して安全装置を外すという思想のようでよくできていると思います。あと、よく使うConfigureAwait(false)はこのケースでは役に立たないようでした(たぶん問題はGetConsumingEnumerableやSetResultにあるため)。TaskCompletionSourceだけでなくBlockingCollectionもChannelで置き換えできますが、今回確認したい点については無関係だったのでなるべく元記事の形のままにしました ↩


