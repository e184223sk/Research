More than 1 year has passed since last update.本記事は、3年前に書いた以下の記事を大幅に見直して書き改めたものです。PrismとReactivePropertyで簡単MVVM！上記の記事は、私の古い認識のもとに書き上げられました。
私の当時の認識で、Prismの機能のごく一部を使ってWPFアプリケーションを構成することが「簡単」だと思っていましたが、時が過ぎ、その認識が変化しました。
即ち、Prismの機能にもう少し乗っかった方が、結果的に「簡単」だと思い直したのです。
また、当時の未熟さから、誤った考えのもとに書かれた部分も見受けられます。
古い記事に「いいね」をいただく度、そのことをお伝えし直したいという気持ちになっていましたが、この度、執筆するやる気を確保できましたので、本記事を投稿するに至りました。Prismの機能は多彩ですが、本記事では覚えておくと開発が簡単になる、効果の高い部分のみをピックアップしてお伝えできればなと思います。今まで、WPFは.NET Framework固有のものでした。
しかし、2019年秋にリリースされるであろう.NET Core 3.0には、新たにWPFの機能が乗せられており、.NET Frameworkと同じようにWPFアプリケーションを作成できるようになります。世間では、Javascriptを中心に、新たなGUIフレームワークが台頭しつつありますが、まだWPFの人口も残っているのではないでしょうか。本記事の執筆時点では正式リリースがまだですが、以下では.NET Core 3.0-previewを使用し、簡単なWPFのサンプルアプリの作成を通して、PrismとReactivePropertyの使用方法をご紹介します。Nugetを見ると、Prism関連のパッケージがたくさんあります。
ここで、各パッケージの意味を見てみましょう。Prism.Coreは前提パッケージで、プラットフォーム共通の機能が入っています。
Prism.WpfとPrism.Formsは、それぞれWPF用とXamarin用です。
その下の6つのパッケージはWPF用で、DIコンテナとしてそれぞれの外部パッケージを使用するものです。
最後の3つはXamarin用で、DIコンテナとしてそれぞれの外部パッケージを使用します。WPFアプリを作るうえでは、WPF用でコンテナありの6つの中から選択することになります。
今回は、.NET Core対応ありで公式サンプルにも使用されている、Prism.Unityを使用します。Prism.UnityはPrism.Wpfに依存し、Prism.WpfはPrism.Coreに依存するので、Prism.Unityだけインストールすれば大丈夫です。UnityはDI（依存性の注入）ライブラリです。
Unityという同名のゲームエンジンが存在しますが、全く関係はありません。
DIライブラリは沢山ありますが、C#においてはこのUnityが有名どころです。Prism.UnityはUnityに依存するので、Prism.Unityだけインストールするようにしましょう。Prism.Unityを使用した、公式サンプルです。Prism-Samples-Wpf29種類のサンプルがあり、各サンプルは非常に小さなプロジェクトから構成されているので、簡単に機能の把握ができます。正直、このサンプルを見れば本記事で説明することはあまりありませんが、本記事では、重要な機能をかいつまんでご紹介するようにします。DIコンテナの補助RegionNavigationEventAggregatorDialogMVVMの補助Module前章の「MVVMの補助」の部分は、PrismよりもReactivePropertyに任せるほうが簡単だという認識です。Reactiveとは、Observerパターンによる、時系列データ（イベントなど）の監視、およびそのデータ群に対する演算（LINQのような）を扱うものです。
System.Reactiveという外部ライブラリに依存しています。GUIアプリはイベントに対処しなくてはならないので、このReactiveの考え方は有効です。
ReactivePropertyは、主にMVVMにおけるViewModelのプロパティとコマンドを、Reactiveに扱うことを可能とします。これから作るアプリの画面を以下に示します。
数値を入力すると、2乗を計算するアプリです。入力は即座に反映されます。入力のバリデーションも行います。ボタンを押すと、ダイアログが表示されます。プロジェクト群を以下のように作成しました。
プロジェクトを小分けにしない方が作るのは簡単ですが、今回は分けて作成しました。.NET Core 3.0に対応させるため、下記のように修正しました。ビルドの警告が出なければ成功です。以下では、Visual Studio Codeにより編集を行ないます。
執筆時点では、C#の拡張機能に不具合があり、シンタックスエラーの赤が表示される場合がありますが、コンパイルが通れば問題ありません。
また、XAMLの編集機能は現時点で無いため、便利に開発したい場合はVisual Studioを使用した方が良いかもしれません。標準のApplicationクラスをPrismApplicationクラスに置き換えています。
また、StartupUriが不要になっています。この作業により、ビルド時に自動生成されるAppクラスがPrismApplicationを継承するように変化します。標準のApplicationではなく、Prism.Unity.PrismApplicationを継承します。CreateShellメソッドは、アプリケーション開始時に起動するWindowを返す必要があります。
コンテナからMainWindowを生成して返しておきます。
ここで、何もしていないのにMainWindowがDIコンテナに登録されているのがポイントです。
同じアセンブリ（プロジェクト）内のViewとViewModelが自動的に登録されるのです。
Prismの便利さの本質はここに集約されるのではないでしょうか。その下にあるRegisterTypesメソッドは、コンテナに手動でクラスやインスタンスを登録する際に使用します。うまくMainWindowが表示されました。PrismSample.App.MainのMainWindow.xamlとMainWindow.xaml.csを削除します。PrismSample.Lib.Viewsに、以下のMainWindow.xamlとMainWindow.xaml.csを作成します。Viewのprism:ViewModelLocator.AutoWireViewModel="True"という記述は、関連付けられたViewModelがDIコンテナ内に存在する場合、自動的にDataContextとして登録することを指定しています。
これを行なうのはViewModelLocatorというものです。ViewのTextBlock.TextのBindingをText.Valueとしている点に注意してください。
以下で登場するReactivePropertyから値を取得するには、Valueプロパティを参照する必要があります。PrismSample.Lib.ViewModelsに、以下のMainWindowViewModel.csを作成します。ViewModelにはPrism.Mvvm.BindableBaseを継承させるのを忘れないでください。TextはReactive.Bindings.ReactiveProperty型にしています。
ReactivePropertyはINotifyPropertyChangedを実装しているため、双方向バインディングが可能です。App.xaml.csに以下の記述を追加します。ConfigureViewModelLocatorメソッド内で、ViewとViewModelを関連付けています。MainWindowとMainWindowViewModelが関連付けられています。前述のN^2を求めるための表示領域を用意します。
Nの値を入力するほうをOperandView、計算結果を表示するほうをAnswerViewとします。上で作成したViewに対応するViewModelを作成します。まだ計算機能はありません。
SetValidateAttributeメソッドは、System.ComponentModel.DataAnnotationsの属性から、対応するエラーが存在するかどうかを検出可能にします。先程のViewを表示するためのRegionをMainWindowに作成します。prism:RegionManager.RegionNameにRegionの名前を指定します。MainWindowのコードビハインドを修正します。Regionの追加に必要なPrism.Ioc.IContainerExtensionとPrism.Regions.IRegionManagerを、DIにより取得しています。
これは、セッターインジェクションという手法で、Unity.Attributes.Dependency属性をセッターに付加することで実現します。先程と同様に、App.xaml.csのConfigureViewModelLocatorメソッドでViewとViewModelを関連付けを行ないます。Regionに2つのViewが表示されました。EventAggregatorは、PubSubパターンでイベントの通知と購読を管理することで、ViewModel間の通信を実現します。
EventAggregatorは、ViewModelが自動生成される際にDIにより取得可能です。
先程と同様、セッターインジェクションで取得できますが、ここではコンストラクタインジェクションで取得してみましょう。OperandViewModelとAnswerViewModelを改変します。コンストラクタの引数にEventAggregatorが注入されます。GetEvent&lt;PubSubEvent&lt;double&gt;&gt;メソッドにより、double型のイベントを取得し、Publishで値を発行、Subscribeで発行された値を購読します。
ここではdouble型を使用していますが、EventAggregatorは複数のViewModelで共有されるため、通信用に独自の型を定義した方が良いかもしれません。このSubscribeはちょっとくせ者で、購読メソッドを弱参照するという特徴があります。
なぜなら、強参照を持ってしまうと参照の依存関係が生じ、後々解放する必要が出てくるからです。
弱参照にしておけば、その手間が省けるのですが、代わりに注意すべきことがあります。以下のように、と、ラムダ式を使って購読した場合、このラムダ式はこの場で生成され、誰も参照を持っていない宙ぶらりんの状態になります。
そうすると、GCにより回収の対象になってしまいます。
結果、イベントが通知されない！ ということになります。
ですから、ここはラムダ式を使わず、メソッドへの参照を直接指定しましょう。ViewModel間で値のやり取りができています。N^2の計算をModelに持たせるようにしてみましょう。
テスト可能なコードにするために、インターフェイスも用意しておきます。IModelとModelを関連付けておきましょう。IModelをインジェクションします。Modelによる計算ができています。Dialogの表示に関しては、Prism 7.2以降ではPrism.Services.Dialogs.IDialogServiceを使用します。
しかし、メッセージダイアログをちょっと表示したいだけ、という場合、使い勝手は良くないです（DialgのViewとViewModelを自分で書かなくてはいけない）。本記事では利便性を重視して、WPF標準のMessageBoxを使用する方法をご紹介します。Dialogの表示は思いっきり副作用なので、インターフェイスを定義しておきます。
今回はPrismSample.Lib.Views内に上記2つを定義しましたが、インターフェイスを別プロジェクトに分けることで、ViewModelsからViewsへの参照を無くすることもできます。Dialogを表示するコマンドを、Reactive.Bindings.ReactiveCommandを使用して書きます。OperandViewModel内でReactiveCommandのコンストラクタに渡しているのは、IObservable&lt;bool&gt;です。
これは、WPFのICommandにおけるCanExecuteとCanExecuteChangedを制御し、コマンドが実行可能かどうかを自動的に反映するようにしてくれるものです。AnswerViewModelでは、ReactiveCommandのコンストラクタに引数を渡していませんが、これは常に実行可能なコマンドを生成します。IDialogHelperとDialogHelperの関係性を登録します。Dialogが表示できました。無駄に長文になってしまいました。
本記事の内容をまとめます。以上です。
ありがとうございました。


