等価性判定のためのインターフェースIEquatable&lt;T&gt;についてガイドラインを示し、完全に理解できるよう解説します。ref.
IEquatable Interfaceクラス・構造体は可変型と不変型に分けられます。クラスは参照型であり、既定のEquals()では同一性判定が行われます。（= ReferenceEquals()）構造体は値型であり、既定のEquals()では同値性判定が行われます。Visual Studio 2017ではIEquatable&lt;T&gt;.Equals(T)・Object.Equals(Object)のオーバーライド・GetHashCode()・==/!=演算子を全て自動生成できるようになりました（ReSharperでもできます）。バグを埋め込まないよう、原則として手書きではなく自動生成するのが良いでしょう。本記事では自動生成する前提で、詳細なコーディングについては省略します。※VSCodeでの生成方法がもしあれば教えてください。等価性判定のカスタマイズを考えた時、そもそも全てのクラス・構造体にはObjectクラスで定義されたObject.Equals(Object)が既にあります。これを単にオーバーライドするだけと、IEquatable&lt;T&gt;.Equals(T)を実装するのとでは何が違うのでしょうか。念のためこちらのコードでパフォーマンス比較してみました。5構造体・クラス共にIEquatable.Equals(T)直接呼出しが最も速く、次いでIEquatable&lt;T&gt;.Equals(T)インターフェース呼び出し、Object.Equals(Object)仮想メソッド呼び出しの順となり、構造体の既定実装であるリフレクションは2桁遅い結果となりました。このようにパフォーマンス上の理由があるため、Dictionary&lt;TKey, TValue&gt;やList&lt;T&gt;といった多くのクラスの等価性判定を伴う処理では、IEquatable&lt;T&gt;を実装している型についてはObject.Equals(Object)ではなくIEquatable&lt;T&gt;.Equals(T)を呼ぶように最適化されています。IEquatable&lt;T&gt;を実装するデメリットは特にないので、Equals()をオーバーライドしたいなら常にIEquatable&lt;T&gt;を実装することをお勧めします。なお、IEquatable&lt;T&gt;を実装する場合、以下のようにObject.Equals(Object)は定型パターンでオーバーライドしてIEquatable&lt;T&gt;.Equals(T)を呼び出すようにします（自動生成されます）。本記事中ではこれらを特に区別せずEquals()と表現します。ref.
What's the difference between IEquatable and just overriding Object.Equals()?辞書等に入れないなら可変型クラスにIEquatable&lt;T&gt;を実装していいのか？値を表す不変型はプリミティブ型のように簡単に扱うことができ、値オブジェクトと呼ばれます。ここまでをまとめると、値オブジェクトにはIEquatable&lt;T&gt;を実装し、値オブジェクトでなければIEquatable&lt;T&gt;は実装しない方が無難ということになります。例えばStringBuilderクラス6を考えると一方で、参照型であっても値を表す不変なクラスであれば、値型と同等に==/!=演算子で比較できると直感に一致します。例えば構造体であるGuidとクラスであるVersionは同じ感覚で使えます。ref.
Operator Overloads
方法: 型の値の等価性を定義する (C# プログラミング ガイド)
==演算子とEqualsメソッドの違いとは？［C#］MyBaseクラスと、その派生クラスMySubがあったとします。Equals()に期待される動作は何でしょうか。基底クラスの情報だけで同値性判定すべきなのか、派生クラスの情報も含めるべきなのか、クラスの意味と等価性判定する文脈によって異なり、そのどちらを期待するかも人によって異なるでしょう。継承関係にあるクラスの同値性判定には意味が自明ではないケースがあります。IEquatable&lt;T&gt;を実装するかわりにEquals()よりも説明的な名前のメソッドを別に用意することを検討してください。例えば配列をメンバに含むクラスの場合、Equals()はどう判定すべきでしょうか。配列の各要素それぞれについての同値性判定が期待されるはずです。しかしVisual StudioもReSharperも自動生成されたEquals()はそのような実装になっておらず、配列自体を比較してしまいますので、配列の要素が同値であってもfalseになってしまいます。これを解決するには手で書き換える必要があります。配列に限らずIEnumerable&lt;T&gt;を実装するあらゆる型について言えることです。Visual Studioが生成したコードはシンプルにこうなっています。一方、MSDNやEffective C#のサンプルやReSharperが生成したコードはこんな感じです。nullチェックと同一性判定は良いとして、GetType()で実行時の型チェックしているところがVisual Studioの生成したコードと大きく違います。以下のコードで動作が異なります。Visual Studio版では実行時の型チェックをしないのでtrueになりますが、MSDN版ではfalseになります。ただ、どちらが正しいと言い切るのは難しく、同値性判定で実行時の型チェックが期待されるか？という問題です。これは前項の継承の話と同類の問題なので、そもそもこのコードの違いが動作の違いとして現れる設計は避けたいところです。GetHashCode()はよく分散したハッシュ値を素早く返すことが求められます。XORハッシュ（Value1.GetHashCode() ^ Value2.GetHashCode()みたいなの）を目にしたことがあるかもしれませんが、例えばValue1とValue2の値が同じ場合、値に関わらず計算結果はすべて0になり、結果が偏ってしまうので良くありません。Visual Studioが生成するGetHashCode()のハッシュアルゴリズムはBernsteinハッシュです。ReSharperならFNVハッシュです。ちなみにValueTupleの内部実装ではHashHelpers.Combine()が使われており、Modified Bernsteinハッシュで実装されています。いずれも十分に分散したハッシュ値を比較的素早く得られるアルゴリズムのようです。ref.
http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx
What is the best algorithm for an overridden System.Object.GetHashCode?
Why is '397' used for ReSharper GetHashCode override?Object.Equals Method
ValueType.Equals(Object) Method
等価比較 (C# プログラミング ガイド)「2つのインスタンスの」等価性・同一性・同値性という書き方が正確だが、IEquatable&lt;T&gt;は2つのインスタンスを比較するためのインターフェースであり本記事中では文脈から明らかと思われるので省略する。 ↩Object.Equals MethodやEffective C#によると、Equals()をオーバーライドしたとしても==/!=演算子をオーバーロードすべきケースは非常に少ないと説明されている。一方、方法: 型の値の等価性を定義する (C# プログラミング ガイド)では==/!=演算子をオーバーロードすることが推奨されている。矛盾しているようにも思え非常に混乱するが、前者は値オブジェクト以外でEquals()をオーバーライドすることを想定しているように読める。値オブジェクト以外ならば本記事中で説明しているように==/!=演算子をオーバーロードすべきでないが、そもそも値オブジェクト以外でEquals()をオーバーライドすべきでなく、良い設計へ導くためのガイドラインとしては不適切ではないだろうか。 ↩ボックス化とは、値型のインスタンスを参照型の入れ物にコピーして、参照型として扱えるようにすること。値型を参照型の変数に代入したりキャストしたりすると発生する。 ↩リフレクションとは、型自体の情報を取得すること。参照型のメンバを含まない場合リフレクションは発生せず高速に動作するが、メンテナンス性の観点からもIEquatable&lt;T&gt;を実装しておいた方が良いだろう。また、リフレクションによる同値性判定ではすべてのフィールド・プロパティの比較が行われるが、構造体が意味する値に期待される挙動とは異なる可能性がある。 ↩生成されたIEquatable&lt;T&gt;.Equals(T)のnullチェックが!=演算子を使用しているため、!=演算子も生成してあると同値性判定になってしまい遅いのでis nullに書き換えて計測した。修正依頼済みで、マイルストーンに含まれているのでそのうち直る？（Issue #31283）。 ↩StringBuilderにはEquals()があり内部の文字列の同値性を比較できるが、これを悪い例として紹介する。可変型なのでIEquatable&lt;T&gt;は実装されていないしObject.Equals()もGetHashCode()もオーバーライドされていないのでルール違反ではないが、この挙動が直観と一致する人はどれだけいるのだろうか。例えばValueEquals()という名前だったらはるかに分かりやすく混乱しなかっただろう。 ↩2つのインスタンスのハッシュ値が同じであってもEquals()がtrueを返すとは限らない。ハッシュ値の等価性はインスタンスの等価性を表すわけではない。 ↩


