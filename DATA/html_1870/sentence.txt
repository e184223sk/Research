Unity 標準機能のパッケージ化によって、#if UNITY_2018_4_OR_NEWER 等、バージョンだけ見れば良いという状況から、「インストールされているか？」「バージョンは？」など、パッケージのインストール状況やバージョン、クラスの有無で処理を切り替えたい、というのは結構あるあるなシチュエーションになってきましたね。方法は様々あると思いますが、ここでは、という点に主眼を置いています。--結局よくある形の実装に着地したので、なんだこの内容って感じで書き捨てていたんですが、以下に示す Assembly Definition &gt; Version Defines を Unity 2019 のマニュアルで見かけて掘り起こしました。Version Defines でまかなえない場合の手法も合わせて紹介していますよ。Unity 2019 以降かつパッケージ化されている機能であれば、Assembly Definition にプリプロセッサーシンボルを設定する機能が追加されているので、その機能を利用して実現可能です。設定箇所は Assembly Definition のインスペクターですが、対象の機能に Assembly Definition が設定されていれば良いだけではなく、package.json が存在し Packages/ 以下に読み込まれている必要があります。※アセットストア由来のモノだとパッケージ化されていない事が殆どなので使いどころが難しいですね。上に示した Assembly Definition &gt; Version Defines ではまかなえない場合にどうするか。VRM Tool Kit というパッケージで Pose Editor と連携する機能を実現した際の手法は以下の通りです。VRM Tool Kit（連携元アセット）Pose Editor Plugin（このフォルダーがあれば連携する）Pose Editor--この構成でユーザーが行うインストール作業は、どのように使う場合でも、どんなユーザーでもミスが起きにくい状態です。--開発する上でも恩恵があって、連携するパッケージのバージョンによって変更が必要な部分があっても、プラグインだけを複数バージョン用意すれば良いので手間を最小限に抑えられます。※ Unity 公式パッケージと連携する場合、プロジェクト都合で使用するバージョンが選べない状況がある。連携元は以下の通り。※ Unity 依存の Action や Event ではなく delegate でも大丈夫。みんな大好き InitializeOnLoadMethod / RuntimeInitializeOnLoadMethod で連携機能を登録。VRM Tool Kit では考えすぎていて、実際のところ複雑な連携はしなかったのでプラグインも本体に同梱してしまっています。↓ ↓ ↓パッケージとして読み込まれているとは限らない、または必要に応じて .asmdef を削除している可能性も考慮して、手あたり次第に対象クラスを探して対象パッケージが存在すれば連携機能を登録します。Unity 2017 LTS が EOL でサポート対象外になって、現行の Unity はすべて C# 7.3 以上を採用という情勢です。が、現行バージョンよりも古い Unity にも対応する場合、?.（null条件演算子）や ??（null合体演算子）は C# バージョン６で追加された演算子なので修正する必要があります。この構成で開発を進めた場合、連携元と連携プラグインだけがある状態や、プラグインだけを読み込んだ場合にエラーが出ます。が、「プラグインを削除してください」でユーザーは対応可能なので許容しています。※上で示したように文字列ベースで処理をすればエラーを防げますが、入力補完など開発環境の恩恵を受けることが出来なくなるデバフがかかってしまいます。そもそもそういう状態になりにくい構成＆エラー対応に必要な操作もファイルの追加や削除だけなのであまり問題とはならず、また、ユーザーもフォルダー構成や名前から容易にエラーの原因を特定できるので大丈夫でしょう。Bridge、Adapter、Provider 等々（？）界隈的には適切な命名規則があると思いますが、エンドユーザーに馴染みのある「プラグイン」としているのもそのあたりが理由です。Unity に限らず C# 界隈でもクラスの有無でプリプロセッサーシンボルの定義をしたがってる人、結構いるみたいですね。調べても方法は見つかりませんでしたが。。。C# はそもそもプリプロセッサーにあまり機能を持たせたくない、という設計思想があるようで、今後もそんな機能が実装されることは無さそうです。Unity の Assembly Definition &gt; Version Defines は必要だけど C# にその機能がない、という問題に対処するために追加された感じがしますね。こういう機能ないと困る！ という人は多かったハズ。--以上です。お疲れ様でした。


