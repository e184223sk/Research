時間のない人は1.、6.、7.を読んで下さい。前回に引き続き、HTMLソースをまだ見れないうちに自動操作を記述するケースです。
ページ中の1番目の入力欄(input type="text")は、XPathで"(//input[@type='text'])[1]"で手に入ります。2番目なら[2]です。2021/05/06追記：//input[@type='text']を()で囲みました。()なしだと、兄弟要素が[1]、[2]、…となり、兄弟以外が[1]で複数マッチしてしまうのと、兄弟要素でない2番目が[2]でマッチしないためです。下記のようなHTMLの場合に、「氏名」「住所」の「文字列の右」という指定をして、tableを含むかどうか分からない場合にも要素を取得できないかがんばったのですが、できませんでした。
//[contains(text(),'氏名')]
でformを見つけられ、
//[contains(text(),'氏名')]//input[@type='text']
で氏名の入力欄も見つけられますが、「住所」にそのまま置き換えてもだめで、
//[contains(text()[2],'住所')]
とする必要がある上に、これで手に入るのもformなので、結局inputにも[2]が必要になり、
//[contains(text()[2],'住所')]//input[@type='text'][2]
となります。
inputに[2]を指定するのであれば、
//*[contains(text()[2],'住所')]
自体が必要ありません。
また、tableを使用せずにform直書きと分かっていないとtext()に[2]を使えません。上のHTMLだと見出しがずれるので使われないで、下記のようにtableが使われてtdでそれぞれ別になれば、
//[contains(text(),'氏名')]/..//input[@type='text']
でいけそうな気がしてきました。
上の記述だと、「氏名」の兄弟タグであれば左側のinputも取得してしまうので、さらに厳密にすると、
//[contains(text(),'氏名')]/following-sibling:://input[@type='text']
となります。
//[contains(text(),'氏名')]/following-sibling::[1]//input[@type='text']
で、次の兄弟タグのみになります。
//[contains(text(),'氏名')]/following-sibling::*//input[@type='text'][1]
で、次の兄弟タグに限らず、兄弟タグの中で最初のinput type="text"になります。HTMLが見れるようになれば、素直にname属性で探せばよいですが。下記のXPathで見つけられました。
inputが階層下にある場合は未対応です。同じXPathでテーブルなしとテーブルあり両方に対応したいですが、このXPathだとテーブルありのHTMLでは見つけられませんでした。単純に「|」で結合しました。following-sibling::*//
と無駄なことをせずに、
following::
でいけました。//text()[contains(.,'住所')]
で「住所」を含むテキストノードを取得し、
/following::
を追加してそれ以降の兄弟ノードとそれらの子孫ノードを対象とし、
input[@type='text']
を追加してinput type="text"を複数取得し、
[1]
を追加してその複数のうちの1番目を取得しています。containsのため、入力欄の見出し以外にもけっこうマッチするのが要注意です。メニュー項目や、注釈のテキストなどとマッチすることがあります。その場合は、単純に1.の方法を使うか、
(//text()[contains(.,'住所')])[2]/following::input[@type='text'][1]
などと2番目の「住所」を指定したりする方法があります。Google Chromeの開発者ツール(F12)のコンソールで$x("＜XPathの内容＞")を入力して確認できます。
結果のinputの左の三角を開けば、nameを確認できます。


