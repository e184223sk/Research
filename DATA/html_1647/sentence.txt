More than 1 year has passed since last update.Atcoderに取り組んだ際のメモです。
問題はこちらPoint : 600
Performance : 522
■A[完答 21:03:31]   ABC Swap
■B[完答 21:19:22]   Popular Vote
■C[完答 21:39:11]   Replacing Integer
■D[TLE + バグ]  Lunlun Number
■E[未着手] Yutori
■F[未着手] Division or Substraction■問題内容
　隣り合うどの 2 つの桁の値についても、差の絶対値が 1 以下になる整数をルンルン数とする。
整数Kが与えられた時、小さい方から数えてK番目のルンルン数を求めよ。
制約：1≤K≤10^5　そんなに単純ではなかった。そのまま実装したが、テスト段階でTLEが発生した。小さい方からK番目のルンルン数なので、探索する数がKという訳ではないことに気づく必要があった。　小さい数から順に探索する場合、次のルンルン数までたどり着くのに無駄な数をチェックすることが多い。その無駄な探索回数を極力減らせないかというアプローチで探索高速化のロジックを実装した。　i桁目の数とi+1桁目の数の差が1より大きい時が異なる時、次にルンルン数となるのはi桁目に8を足した数の時でないかと推測した。例えば、11,12,…と探索すると13はルンルン数でないことが分かる。この時、13 +8→ 21 から次のルンルン数の候補に21が挙げられ、21はルンルン数なので、再び22,23,…と探索していく。別の例として、124の時、124 +8 → 132 より132となる。これはルンルン数ではないので、再度 132 +80 → 212 より次のルンルン数候補を得、そして212はルンルン数である。　しかし、この方法ではルンルン数の探索は確かに早くなるが、このD問題を解く為には不十分であった。　このD問題では、小さい方から数えてK番目のルンルン数を求める必要がある。しかし、先ほどのロジックでは小さい順にルンルン数を算出することが出来なかった。　正しくない例として、124の場合があげられる。先ほどのロジックでは212が次のルンルン数として挙げられる。しかし、次に来るべきルンルン数は、210である。単純に違ってた桁に8を足すだけではうまくいかないようである。　キューを使って、ルンルン数の条件を満たす数字を昇順に列挙する。
1. キューに1,2,3,4,5,6,7,8,9を投入する。
2. キューから数字を1つ取り出して、その数字を左にシフトして作れる数字をキューに投入する。
　　例えば、1を取り出し多場合は、10の位が1になり、1の位に使用可能な数字は0,1,2なので、10,11,12をキューに投入する。
3. K回繰り返すと出てくる数が解答となる。　私の解法と解説されていた解法では明らかに違う点が、ルンルン数探索へのアプローチの方法である。
　解説されていたものではルンルン数のみを列挙していたことに対し、私の解法ではルンルン数への探索を減らすことを前提としていた。私の解法でもあるルンルン数と次のルンルン数への規則性を利用しようとしていた。しかし、その規則性を突き詰めぬまま、探索ありきの考えに固執していた為、上記のようなロジックとなってしまった。　キューを使用することでこんなにもシンプルに実装することが出来た。キューを使った実装は初めてだったので、新鮮で面白かった。今後はキューを使用するという発想も持てるようにしたい。


