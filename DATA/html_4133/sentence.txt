ステートマシンよりも前に、状態制御とはなにかを書いていたのですが、思った以上に長くなりそうだったので、状態制御については別記事にします。
今回は、シノア氏が開発しているOSSである IceMilkTea という、Unityゲームエンジン向け開発サポートライブラリの「サブセット」である ImtStateMachine を紹介（語り尽く）したいと思います。殆どのUnityゲームクリエイターがステートマシンと聞いたら次のアセットを思い浮かべるのではないのでしょうかなにも、状態制御はステートマシンだけが実装方法ではありません。解決方法は違えど状態制御が可能なものもあります。
Unityにおいてもステートマシンを使わずとも状態制御は可能です。本題と少しずれてしまいますが、他のアセットも見てみましょう。殆どのインディーズ系Unityゲーム開発であれば、上記で紹介したアセットで事足りますし
実際、非常にエディタとしても強力でそれなりのパフォーマンスが得られます。
では、それでもその恩恵を捨てながらも ImtStateMachine を使う理由とは何でしょうか。近年では、スマートフォンゲームでも珍しくなくなってきた、リアルタイムオンライン通信によるマルチプレイゲームが流行ってきています。
そのため、サーバーサイド側の開発事情も変わってきています。殆どの通信は1度のリクエストで1度のレスポンスで済むものです、それも今も変わりません。
しかし、リアルタイム通信で同期型のオンライン通信となると、ガラッと変わりサーバーが今までステートレスな処理からステートフルな処理へ大変貌を遂げました。それを解決するには、ステートマシンによる状態制御が必要です。
そこで、可能ならばUnityで実装しているような状態制御をサーバーサイド側のプログラムでもやりたい！
しかも、サーバー側コードなので、ただ状態制御が出来るだけでなく、パフォーマンスも保証し安定して動作しなければなりません。
そんな理由もあり、それを実現出来るのが ImtStateMachine でした。では、サーバーサイドでもUnityでも使えるステートマシンといわれる ImtStateMachine はどんなステートマシンなのか箇条書きで簡単ですが、以下にまとめました。ステートマシンと言うからには状態の定義が必要です。
ImtStateMachine は、どのステートマシンの状態なのかという実装の仕方になります。この例では、1ソースコードで状態を実装していますが、C#にはpartialという型の分割定義が可能なので、メンテナンス性を考慮し状態クラスごとにソースコードを分けると良いです。
partial 型 (C# リファレンス)
もちろん、コード規模によっては1ファイルで書いたほうが良い場面もあるので、適切な分量で書き分けましょう。殆どのケースでは有限状態機械として実装することが多いので、その遷移テーブルを記述してみます。
ImtStateMachine では AddTransition, AddAnyTransition, AddTransitionRange の3つの関数でテーブルを構築し、SetStartState で開始状態を定義する事ができます。遷移テーブルは状態クラスの型を使って from -&gt; to : input といった形で関数を呼びます。上記の呼び出しを行うと、次のような状態遷移テーブルが構築されます状態クラスの定義、遷移テーブルの構築、をここまでやったら後はステートマシンを動かすだけです。
ImtStateMachine では Update 関数がステートマシンの起動と更新を担います。
通常、Unityでは、コンポーネントの更新ループ関数で状態の更新を行うので、コンポーネントの Start 関数で起動し Update 関数で更新するのが常套手段になります。
また、サンプルコードを見ていただけたら分かりますが ImtStateMachine は Update 関数を呼び出すだけで状態更新を行えます。
業務アプリケーションなどのフォームアプリケーション、コンソールアプリケーションなどで動かす場合は、OSのメッセージループ内で呼び出したり、タイマやボタンのクリック等の特定イベントなどでのタイミングでの更新も可能です。
ご自身の希望するタイミングで、更新タイミングを実行することが可能です。ステートマシンへ状態の遷移をするための指示をするには、入力が必要です。
ImtStateMachine では SendEvent 関数で状態の遷移をする事が出来ます。
入力する値は、遷移テーブルを構築する時に Add～Transition 関数に渡した引数の値になります。本当は、もっともっと ImtStateMachine を使ったテクニックを紹介したいのですが、今回はカレンダー記事ということで基本中の基本という「語り尽くす」とはと何だと思ってしまいます。
代わりと言ってはなんですが、たった一つの ImtStateMachine のソースコードファイルをインポートしたUnityプロジェクトで簡単なサンプルを作ってみたので、ご参照下さい。
ImtStateMachine を使ったテクニック集なども、いずれ記事にしたいと思います。では、早速 ImtStateMachine を使ってUnityで簡単なサンプルを作ってみます。今回作るゲームは、ブロック崩しを作りたいと思います。
要件は次の通りです。今回の使用するUnityエンジンバージョンは 2018.3.0f2 です。
早速Unityプロジェクトを新規作成し、シノア氏の IceMilkTea のリポジトリに含まれる ImtStateMachine のソースコードだけ、コピペするかリポジトリをチェックアウトしてきた所から頂戴します。
https://github.com/Sinoa/IceMilkTea/blob/develop/Program/Runtime/Core/UnitCode/PureCsharp/StateMachine.cs

このように、ポンっとPluginsディレクトリに置くだけの簡単な作業です。今回作るゲームはブロック崩しの為ボールが確実にバウンドするように、物理エンジンのバウンドするかどうかの閾値を0にします。
全てプリミティブなオブジェクトで組んでしまいます。もちろん物理エンジンのコンポーネントも付けていきます。

いい感じです。それでは、まずプレイヤーとして存在するバーの操作クラスを作ってみましょう。
プレイヤーが行える状態は次の構造になりますね。

では、この構造をソースコードに落とし込んでいきます。次にブロックの状態をコントロールするクラスを作ってみましょう。
ブロックが起こりうる状態は次の構造になりますね。

では、この構造をソースコードに落とし込んでいきます。次にゲームの流れをコントロールするシーンのクラスを作ってみましょう。
シーンが起こりうる状態は次の構造になりますね。

では、この構造をソースコードに落とし込んでいきます。
完成しました。完成プロジェクトに関しては、GitHubにて公開しました。
https://github.com/BelColo/ImtStateMachineUseSample当初より予定していた、記事の長さを遥かに超える事になってしまいましたが、いかがでしたでしょうか。
サンプルコードはパフォーマンスや実装方法について、ステートマシンの動かし方を重点的に説明するため、犠牲になっていますが、それでもステートマシンを使ったことによって遥かに実装が楽になっていることがわかるはずです。今回使ったImtStateMachineは、Unityだけに留まらずサーバーサイドのプログラムにも使われており、実際使わせてもらっています。
ImtStateMachineが流行ることを願いつつ今回は、これでしめさせて頂きます。ImtStateMachineを使ったテクニック集などもいつの日か、書ける日が来たら書こうと思います。


