ASP.NET MVC（及びASP.NET MVC Core）にて、JsonResultを返すコントローラアクションがあったとします。この時、返されるオブジェクトのプロパティにEnumがある場合、数値ではなく列挙型名でシリアル化する方法をまとめます。ResultType.OK という列挙型が、"1" ではなく "OK"という文字でシリアル化できるようになります。個別のまとめはよく見るのですが、ASP.NET MVCでの方法と、ASP.NET MVC Coreでの方法が混在している為、ASP.NET MVCアプリケーションをCoreに置き換える時などの参考用に両方のやり方をまとめておきます。またその過程でそのまま使用できるアクションフィルタやJsonResult派生クラスなども提供します。いいねたくさん頂けましたら、動作するサンプルをGitHubで共有したいと思います。.NET 5では、JSONシリアライザーとして標準のSystem.Text.Jsonが用意されており、ASP.NET MVC 5 Coreでも規定としてSystem.Text.Jsonが使われます。列挙型の値を列挙型名（文字列）で返すには、その列挙型の定義か、列挙型を使用しているプロパティにJsonConverter属性を付与するだけです。列挙型に限りませんが、ASP.NET MVC Coreで使用されるSystem.Text.Jsonは、標準でプロパティ名を小文字から始まるキャメルケース（ロワーキャメルケース）で置き換えます。その為、上記のResultプロパティは"result"のように先頭が小文字のプロパティ名に置き換えられます。
ErrorMessageプロパティも、"errorMessage"のように先頭が小文字のプロパティ名に置き換えられます。これが困る場合、システム全体の設定として、キャメルケースをオフにすることもできます。もし、システム全体の設定として一律に列挙型の値を列挙型名にしたい場合は次のようにすることもできます。
が、あまり使うことはないでしょう。同じく列挙型に限りませんが、個々のプロパティ名をJsonPropertyName属性で指定することもできます。
システム全体の設定で指定したPropertyNamingPolicyと被った場合、個々の設定が優先されます。ASP.NET MVC 5では、System.Web.Script.Serialization.JavaScriptSerializerがシリアライズを担当しますが、その呼び出しはJsonResult自身が内部で直接行っています。その為、その挙動を利用者が変更するにはJsonResultを置き換えるか、JsonResultを使わずに直接JSON文字列を返すしかありません。ASP.NET MVCで一般的に利用されているJSONシリアライザは、JSON.NETと呼ばれるNewtonsoft.Jsonパッケージです。NuGetからインストールできます。まずコントローラ側で対応するプリミティブなやり方を紹介し、次にそれをシステム全体に適用するやり方を紹介します。
その後、新しいJSONシリアライザであるSystem.Text.Jsonを使う方法も紹介します。基本的には、システム全体に適用するやり方でいくことになると思います。
順を追って説明していきます。モデルクラスや列挙型の定義にNewtonsoft.Json.JsonConverter属性を指定する方法です。
ASP.NET MVCはNewtonsoft.Jsonを知らないので、この属性を指定するだけでは何も起こりません。そこで、コントローラアクションにてJsonメソッドではなくContentメソッドを使ってNewtonsoft.Jsonで変換した結果の文字列を直接返すようにします。コントローラアクションの戻り値はJsonResultではなくActionResultにする必要があります。Resultプロパティに直接JsonConverter属性を指定するやり方でも可能です。モデルクラスに個々に属性を指定するのではなく、全てのモデルクラスの列挙型を文字列に変換する方法です。
あまりこういうことはやらないと思いますが、プロパティ名の変換ルールをシステム全体で統一したい時など、属性指定以外にもこういうプリミティブな方法があると知っておくと便利です。注意事項として、StringEnumConverterの生成時にNamingStrategyを指定しないと、変換が行われず数値が出力されてしまいます。規定値はnullとなっています。前述の方法で、設定のみをGlobal.asaxに記述する方法です。
Newtonsoft.Json.JsonConvert.DefaultSettings に共通の設定を保存します。
こうすることで、システム全体で設定を共有できます。この方法がこの記事の本命ですが、少々複雑です。これまでのやり方だと、コントローラー側で個々にJsonConvert.SerializeObjectを明示的に呼び出す必要がありました。戻り値もJsonResultでなくなっています。そうではなく、コントローラ側は標準的なJsonメソッドを利用してJsonResultを返すだけで、裏側で自動的にNewtonsoft.Jsonを使ってJSONシリアライズしてくれると便利です。ここでは、そのやり方を紹介します。こちらで紹介されていたやり方になります。
https://stackoverflow.com/questions/7109967/using-json-net-as-the-default-json-serializer-in-asp-net-mvc-3-is-it-possible手順としては、JsonResultをこっそり置き換える為のJsonNetResultというクラスを、JsonResultを継承して作り、その内部でNewtonsoft.Jsonを使ってシリアライズするようにします。そして、カスタムアクションフィルタを使ってOnActionExecuted（アクション実行後フィルタ）でfilterContent.ResultをJsonResultからJsonNetResultに置き換えます。まず、JsonNetResultの説明です。上記の内容はどういうものかというと、元となるJsonResultのExecuteResultの実装を（オープンソースなのでGitHubから）そのまま持ってきて、JavascriptSerializerを使っている箇所をNewtonsoft.JsonのJsonSerializerに置き換えているだけです。次に、このJsonNetResultを使うようにするカスタムアクションフィルタ、JsonHandlerAttributeを作ります。これはコントローラアクションの後処理フィルタで、JsonResultをJsonNetResultに置き換えます。コントローラの戻り値がJsonResult以外の場合には何も行いません。そして、FilterConfigにて、JsonHandlerAttributeフィルタをグローバルフィルタとして登録します。
こうすることで、全てのコントローラアクションの後処理としてこのJsonHandlerAttributeが呼ばれるようになります。コントローラアクションの方は、以下のように普通にJsonResultを返します。普通のASP.NET MVCのJSONを返すアクションの書き方です。そして、変換したいプロパティや列挙型に、通常通りJsonConverter属性を指定します。FilterConfigに指定せず、以下のように個別にコントローラアクションに属性を指定することもできます。
システム全体への影響を抑えながら局所的に対応したい場合はこちらの方が便利でしょう。Newtonsoft.Jsonでは、EnumMemberAttributeを使って列挙型の値に自由に文字列を指定することができます。
あまり使う事はないかもしれませんが、場合によっては便利かもしれません。「将来的にASP.NETからASP.NET Coreへ移行する予定だが、現行のASP.NETシステムに手をいれなければならず、将来の互換性確保の為にNewtonsoft.JsonよりもSystem.Text.Jsonを使いたい」という人もいるかもしれません。その場合は、NuGetからSystem.Text.Jsonをインストールして使用することができます。System.Text.Jsonでは、現在のところまだ先ほどのEnumMemberAttributeに相当するものがサポートされていませんが、拡張ライブラリが存在しており、同様にNuGetから取得できます。
https://github.com/Macross-Software/core/tree/develop/ClassLibraries/Macross.Json.Extensions#enumerationsNewtonsoft.JsonではなくSystem.Text.Jsonを使うには、先ほどのJsonNetResultを次のように置き換えたSystemTextJsonResultを作ります。JsonHandlerAttributeは次のように、JsonNetResultではなくSytemTextJsonResultを使うように変更します。FilterConfigで、同様にJsonHandlerAttributeをグローバルフィルタとして登録します。列挙型の定義には、System.Text.Json.Serialization.JsonConverter属性を使ってJsonStringEnumConverterを指定します。System.Text.Jsonのシリアライズ設定を行うには、JsonSerializerOptionsを生成してJsonSerializer.Serializeの第二引数に指定します。2021年8月24日現在の所、グローバルな設定を行う方法は用意されていないようです（あったら教えて下さい。将来的に用意される方向のようです）。ですので、シリアライズ設定は、SystemTextJsonResultの中で行うのがとりあえず手っ取り早いでしょう。主な変更点を以下に抜粋します。Settingsプロパティを追加し、コンストラクタで設定を生成してプロパティに保存しています。
この設定を行うと、全ての列挙型を一律に文字列に変換します（モデル側に属性の指定は要りません）。以下のようにすると、プロパティ名をロワーキャメルケースにします。上記ではJsonSerializerOptionsのコンストラクタ引数にJsonSerializerDefault.Generalを指定していますが、これは今のところ（2021年8月20日現在）何もしないオプションです。ここにJsonSerializerDefault.Webを指定すると、Web用のおすすめ設定を生成してくれます。
どんなお勧め設定か見る為に、JsonSerializerOptionsのソースコードから引用します。以下をセットでやってくれています。JsonSerializerDefault.Webを使うには、以下のようにJsonSerializerOptionsのコンストラクタ引数に指定します。もし、NumberHandling（数値項目のシリアライズ方法）を規定以外にしたかったら、次のように書けます。SystemTextJsonResultが出来たら、あとはそれをJsonHandlerAttributeから呼び出すように修正するだけです。
変わっている個所は、JsonNetResultをSystemTextJsonResultに置き換えただけです。ただ、実際のところ、そのシステムの規定のJSONシリアライズ設定がSystemTextJsonResultのようなライブラリクラスの中に記述されるのは少々問題がありますよね。できればそのような設定は外部から指定できるようになっていると嬉しいです。そこで、JsonHandlerAttributeのコンストラクタからJsonResultのファクトリ（インスタンス生成関数）を受け取って使うようにします。そうすることでグローバルな設定をFilterConfigで記述することができるようになります。また、JsonHandlerAttribute自身がJsonResult派生の具象クラスに依存することもなくなります。属性指定の場合でも使えるよう、スタティックプロパティとしてグローバルなデフォルトファクトリも指定できるようにしましょう。Func&lt;JsonResult&gt; JsonResultFactory と、static Func&lt;JsonResult&gt; DefaultJsonResultFactory を追加します。FilterConfigではJsonHandlerAttributeをグローバルフィルタとして登録するだけにして、Global.asax.csにデフォルトのオプション設定を記述します。上記でJsonSerializerOptionsのインスタンスをファクトリ関数の中で毎回生成せずにシステム全体で共有しているのは、マイクロソフトのドキュメントに以下のように書かれている為です。同じオプションで JsonSerializerOptions を繰り返し使用する場合、使用のたびに新しい JsonSerializerOptions インスタンスを作成しないでください。どうやらJsonSerializerOptionsは内部でメタデータを生成する為、使うたびに生成するとコストがかかるようです。このメタデータのキャッシュはスレッドセーフなようなので、共有することにも問題はなさそうです。ちなみに上記はSystem.Text.Jsonを使ってシリアライズ設定を外部に出していますが、Newtonsoft.Jsonの場合でもまったく同じJsonHandlerAttributeを使って以下のように設定できます。Newtonsoft.Jsonの場合、そもそもDefaultSettingsプロパティを使えば簡単にグローバル設定が行えるので、簡単ですね。多くのASP.NET(.NET Framework版)システムではVB.NETが使われているでしょうから、JsonNetResult、SystemTextJsonResult、JsonHandlerAttribute、FilterConfig、列挙型の各定義について、VB.NET版も掲載します。


