More than 3 years have passed since last update.※個人的な備忘録とし記述します。が、一応他の人にも見られてもいいように記述する予定です。
下図のような処理を実行するプログラムを作成します。以下のサンプルアプリケーションを実行した結果「SampleClass.SampleMethod」メソッドを実行前後にログを出力（今回はコンソール出力ですが）することが最終目標です。アプリ実装は「MyAspect」属性をつけ、「ContextBoundObject」クラスを継承する必要がありますが、それ以外に特別なことをする必要はありません。「MyAspect」属性クラスは「ProxyAttribute」クラスを継承します。この属性はProxyを使いますよ～ってことを表す属性です。Proxyとは「代理」の意味です。上記「SampleClass」クラスのメソッドを、後述のProxyクラスが代理で実行しますって考えていればよいかと。
「MyAspect」属性クラスの実装は以下の通り「MyAspect」属性クラスの「CreateInstance」メソッド内で「MyProxy」クラスをNewしています。ここでNewしている「MyProxy」クラスが対象のMethodを実行します。「MyProxy」クラスが「SampleClass」クラスのメソッドの実行を「代理」しているのです。ということは、「SampleClass」クラスのメソッドの実行している処理の前後にログ出力処理を実装すればよいのです。上記のサンプルプログラムでは単純なログ出力だけですが、呼び出したメソッドの引数や戻り値、発生したException等も取得できます。また今回のログ出力のような処理をManaged Extensibility Framework (MEF) を使って拡張できるようにすることも可能です。自分的にアスペクトとMEFは相性がいいと思っています。（性能的にどうなの？ってのはありますが。）
そんなわけで、MEFを使って拡張していきます。イメージ的には下記の感じです。まずはアスペクトから呼び出すPartsのインターフェースを定義します。インターフェースには実行対象のメソッドが呼び出し前に実行されるメソッド「PreProcessing」と呼び出し後に実行されるメソッド「PostProcessing」を定義します。「MyCompositionContainer」クラスは以下のような感じ。
コンストラクタでカレントディレクトリのDLLファイル内のPartsクラスを検索し、「CompositionContainer」に登録。「PreProcessing」メソッド「PostProcessing」メソッドを呼び出した時に、「CompositionContainer」に登録されているクラスの「PreProcessing」メソッド「PostProcessing」メソッドを呼び出します。
※各メソッド内の処理については今後追記したいと思います。追記されるまではGoogleさんやBingさんで検索でもしてください。次はPartsクラスの実装です。「IMyParts」インターフェースを実装ます。「IMyParts」インターフェースを実装することで、アスペクトが動的に読み込みます（カレントディレクトリにアセンブリを配置する必要がありますが）。
で、上記の「MyProxy」クラスで実装したログ出力処理をPartsクラスに記述します。最後に「MyProxy」クラスをMEF版に変更します。「MyCompositionContainer」クラスをコンストラクタでNewし、実行対象メソッドを呼び出す前後に「MyCompositionContainer」クラスの「PreProcessing」メソッド「PostProcessing」メソッドを呼び出すだけです。


