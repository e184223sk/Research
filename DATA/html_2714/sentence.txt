More than 1 year has passed since last update.12個の形の違ったピースを四角の枠にぴっちりとはめ込むパズルで、子供の頃、皆さんもきっとやったことのあるパズルだと思います。詳しくは、Wikipediaのページペントミノを参照してください。ここでは、５×12の長方形に収めることにします。ほかにも、6x10、4x15、 3x20 の長方形に収めるパターンもあります。この手のプログラムでは、ピースデータをどのように表現するかで、作成するプログラムコードは大きく変わってきます。ここでは、ひとつのピースをchar型の２次元配列として表現しています。ピースがあるところには、ピースの形を顕わす文字を入れています。空白文字の部分は、ピースが無いことを示しています。例えば、Ｌ 字型のピースでは、T字型だとI字型だと
cs
new char[,] {
    { 'I','I','I','I','I' },
}),
このように保持します。
この配列は、Pieceクラス内に保持するものとします。このようにしているのは、このプログラムは、コンソールアプリとして作成しているので、配列の内容をそのまま出力すれば、ピースの形がわかるようにするためです。そのため、WPFやWindowsFormsでグラフィカルに表示する場合は、ピース毎に配列の要素の文字を変える必要はありません。これを、以下のようにして、12個のピースをリストに格納します。実際のパズルと同じようにピースは、回転や反転ができるようにします。Peiceクラスに、R90, Mirror, AllCandidates  というメソッドを定義しています。その抜粋を示します。これらはprivateメソッドとしています。実際には、Pieceを利用するクラスは、AllSeries というプロパティを利用して、回転や反転したピースすべてを列挙しています。なお、一つのピースは、回転／反転させることで、最大で８つの置き方が存在します。
回転／反転後に、重ね合わせて同じ形になる場合は、それを除外するようにしています。ピースのデータ構造が決まれば、あとは、再起的な処理でピースを箱にはめていき、すべてのピースが箱に収まるまで試行を繰り返すことになります。もちろん、ピースが箱に入らなくなった時点で試行を中止し、別の置き方を試します。
この部分は、他のパズルと同様に、深さ優先の探索で再帰的に処理しています。以下に、探索をしてるSolveメソッドを抜粋します。
長方形の枠のサイズは、このメソッドの引数で渡すようになっているので、ここを変えれば、3x20 などの解も求めることができます。
このメソッドの中で、いろんなメソッドを呼び出していますが、その詳細は、この記事の最後に載せるソースコードを見てください。解が一つ求まったら、処理を終了しています。もう少し工夫すれば、全ての解を得るように変更することも可能だと思います。このコードだと、IObservableとIObserver 使うのが良いかな。 戻り値をIEnumerable&lt;Board&gt;として、yield return 使って、複製したBoardインスタンスを返すようにする方法もありますね。画面上の日時は、探索開始時刻と探索終了時刻です。別のサイズでも実行してみましたでは、すべてのソースコードを掲載します。(GitHubでも公開しています)ソースコードにはコメントを書いておきましたので、詳しくはそちらを見てください。


