More than 1 year has passed since last update.移動や連発にも対応してようやく納得いくものが出来た色々妥協してる部分もあるけど個人的には満足 pic.twitter.com/hWVOqxVhAw3Dアクションゲームなどで良くある、
「敵を攻撃したらパーティクルが発生して、UI上のゲージに向かって飛んでゲージが溜まる。」
というものを実装してみました。
(割と需要あると思っているのですが、どこにもサンプルが無かったので自作することに)以下のGithubに上げてあります
https://github.com/madoramu/ParticleHorming
※サンプル動画は別プロジェクトの物なので、上記URLのプロジェクトは少し内容が異なります。Unity2018.3
WindowsとAndroidで動作確認済み
重要：ScreenSpaceCamera設定のCanvasのみ対応していますサンプルプロジェクトの中身を抜粋して説明していきます。
細かい部分などはプロジェクトを閲覧してください。こちらはキャラクターの追尾、およびUI以外の描画を担当。UIの描画のみ担当。上記二つのカメラ設定により、メインカメラの描画の後にUIレイヤーの情報が上に描画されます。UI表示用・座標変換用で2つのScreenSpaceCamera設定Canvasを用意します。※何故設定カメラ以外同じパラメーターのCanvasを二つ使用したのかは感想に記載しています。ここは好みに合わせて弄って問題ありませんが、以下の2点は必須です。今回は以下のように設定しました(プロジェクトから抜粋)
「何故World設定か？」「Rederer→Order in Layerについて」ParticleSystem.Emitを使用して、意図的にパーティクルを発生させることが出来ます。
https://docs.unity3d.com/ja/current/ScriptReference/ParticleSystem.Emit.html以下コード抜粋普段パーティクルをスクリプト側で操作することは余り無いですが、今回は特定位置に収束させたかったのでググった結果、公式サイトで以下のページが出てきました。
https://docs.unity3d.com/ja/current/ScriptReference/ParticleSystem.GetParticles.htmlこのページを参考に以下の様な処理で更新させることにしました。今回は指数関数を使って、等速直線移動ではなく少しアレンジをしています。
ここに関しては書き方によって幾通りも表現が出来ると思います。当初はScreenSpaceCameraのCanvas一つで解決できないか試行錯誤していましたが、キャラを追尾する = Canvasが移動する関係上、パーティクルが毎フレームぶれたり座標がおかしなことになったりした結果、今の形に落ち着きました。
冒頭でも言った通りScreenSpaceOverlay設定のCanvasには対応できないので、結構使いどころは限定的かも。
ですが、ParticleSystem上でパーティクルをいつも通り設定できるメリットは大きいので、個人的には満足度高めです。


