Microsoftは、ローカルで使えるストレージライブラリのFASTERというものを開発している。
このFASTER、最初はキーバリューストアであるFasterKVのみ提供していた。しかし、バージョン2019.10.31.1より、FasterLogという、データの追記に特化した機能が追加された。
少し触ってみると、今自分が実現したい機能を丁度良くカバーしてそうなので、使い方や注意点を書いておく。FasterKVは論文も発表されているので、特徴や理論的な裏付け等が知りたければそちらも参照のこと。今回紹介するFasterLogは、FasterKVで使用しているストレージ機能のベース部分を利用した、追記と範囲検索に特化したものとなる。なお、FasterLogは今もなおインターフェイスの更新が行われており、この記事で書かれていることと微妙に差異があるかもしれないので注意が必要。
この記事では1.9.5をベースに解説を行う。普通にnugetパッケージとして公開されているので、PackageReference等で追加すればOK。他に、Microsoft.FASTER.Serverや、Microsoft.FASTER.Clientも存在するが、これは FasterKVをクライアントサーバー形式で利用したい場合に使うフレームワーク なので、今回は導入しない。まず、以下のコードでログを格納するディスク領域を作成する。なお、deleteOnCloseというオプション引数が使用可能だが、これを使用すると、後でデータを開こうとした時に挙動がおかしくなるので、検証またはテスト目的以外では設定しないこと。
また、オプション引数でpreallocateFile=trueとすると、後でFasterLogを生成する時に最初から2^SegmentSizeBitsのファイルを確保してから、そこに書き込むという動作になる。
パフォーマンスを重視する場合はtrueにするのも手だが、その場合突然大きなファイルが作成されることになるため、注意が必要となる。ここで生成したIDeviceは、必ずプログラム終了時にlogDevice.Dispose()するか、またはusingで囲むこと。他のIDeviceの実装として、LocalMemoryDeviceというものもあるが、コンストラクタにConsole.Write等が仕込まれている等、テスト目的で作ったような印象なので、リファレンス実装あるいはテストのためのデバイスと思った方が良い。また、Azure Storage(page blob)を使うIDeviceの実装もある。ただし、こちらの性能等は未検証ストレージデバイスインスタンスを生成したら、以下のようにして、FasterLogインスタンスを生成する。FasterLogSettingsのその他項目は以下のようになる。FasterLogをnewした時点で、以下のファイルが生成されるデータの追加は以下のように行うCommitした時点でディスクに書き出される。
戻り値として、追加したデータの論理アドレスが取得できる。例ではEnqueueを使用したが、これは内部的にEnqueueを成功するまで繰り返すという挙動のため、タイミングが悪いと時間がかかる場合もある。
一定回数追加を試みて、だめならエラーを出すか後でやり直すという挙動をしたい場合、bool FasterLog.TryEnqueue(byte[] data, out var logicalAddress)というAPIを使用する。
Enqueueも実は内部的にTryEnqueueを使っている。データの読み出しは、C#8.0とそれより前でやり方が異なる。下記のように、FasterLog.Scan([開始アドレス], [終端アドレス])を使用する。ここでいう開始アドレスと終端は、コミット済みの全てのログを見るならFasterLog.CommittedBeginAddressとFasterLog.CommittedUntilAddressをそれぞれ指定すると良い。
全てのログを見たくない場合は、終端アドレスに、[開始アドレス] + [適当なバイト数]を指定する。走査中に、現在見ているログの論理アドレスを知りたい場合は、FastLogScanIterator.CurrentAddress、次のエントリのアドレスを知る場合は、FastLogScanIterator.NextAddressを使用する。IAsyncEnumerableを使用する。FastLogScanIterator.GetAsyncEnumerable(CancellationToken ct = default)では、foreachの要素に単純にnewされたbyte[]を受け取るが、代わりにSystem.Buffers.MemoryPool&lt;byte&gt;のインスタンスを渡すと、メモリプール経由でバッファの確保を行うため、アロケーションが減らせる。
ただし、IMemoryOwner&lt;byte&gt;自体のアロケーションは避けられないため、ゼロではない。
また、使い終わったIMemoryOwner&lt;byte&gt;はDisposeを行わないと、メモリリークの原因になる。FastLogScanIterator.[GetNext,NextAddress,WaitAsync]等を駆使するデータの削除には、FasterLog.TruncateUntil(long untilAddress)またはFasterLog.TruncateUntilPageStart(long untilAddress)を使用する。TruncateUntilはデータの開始アドレス(BeginAddress)から、指定されたアドレス直前までのデータを削除するという挙動である。
注意点として、レコード境界ではない中途半端なアドレスを指定すると、次回のScan時にエラーが出るという仕様がある。回避するには、末尾アドレス(FasterLog.TailAddress)を指定するか、下記のようにScanの途中で得たNextAddressで、正確なレコード境界を取得して指定するというやり方があるより安全に、かつ大雑把に消したい場合は、後述のTruncateUntilPageStartを使用するTruncateUntilPageStartはデータの開始アドレスから、指定されたアドレスに紐づくページの直前までを消去するという挙動である。
レコードはページをまたぐことは仕様上ないため、TruncateUntilで起こったような問題は起きない。
ただし、正確な消去はできないため、大雑把にログローテーション等をしたい場合に使うと良いだろう追記、削除する時は、操作後にコミットを行い永続化する必要があるが、コミットはFasterLogの中で最もコストのかかる処理だという事を念頭に置いた方が良い。しかし、コミットしないとデータが永続化されないので、信頼性が下がる。悩ましいところである。
つまり、より高速にデータを処理したい場合は、信頼性を下げずにいかにコミット回数を減らすかということを考える。ではどうすればいいか。以下のようなやり方を一例として示そうと思う。箇条書きにすると以下のような動作になるタスク間のデータ受け渡しは、System.Threading.Channelsが使えると思う。さて、このやり方では、追記とコミットが別タスクで行われる状態になる。しかし、要件によっては、データ消失を可能な限り避けるため、自分で追加したデータが、確実に永続化されたかどうか確認する必要が出てくる。
そこで、FasterLog.WaitForCommitAsync(long address, CancellationToken ct)を使用する。
引数にはFasterLog.Enqueueで得たアドレスを指定する。
これを使うと、指定されたアドレスがコミットされたと判断されるまで(address &lt;= CommittedUntilAddressになるまで)待機が発生する。具体的には、少々長くなるが以下のようなコードになる。バージョン2019.11.18.1より前のバージョンでは、CommitAsyncするとWaitForCommitAsyncとスレッドプールの消費が競合して、デッドロック状態になる場合があるので注意すること。(該当github issue)今回はログ向けストレージ機能を持つFasterLogを紹介した。実際制約もあるので、あらゆる場面で使用できるわけではないが、それでも他には無い特徴を持っているため、役に立つ場面では役に立つと思われる。
機会があれば、コミット回数や並列数を変えて性能テスト等を行ってみたい。また、データ検索についてはComplete周り等、もう少し掘り下げられそうな所があるので、別記事にするか、あるいはこの記事に追記したい。


