More than 1 year has passed since last update.なんとなく.NETの勉強をしていたのですが、ふとUnityがCommandLineArgumentsを読めるのならUnity製アプリケーションデフォルトのランチャー(Display Resolution Dialog)を使わなくても外部からUnityをCommandLineArgumentsを代入しながら起動すれば起動時設定をUnity側で受け取れる実質的なランチャーを作れるってことなんじゃないかと思い立ったので、その実装をしてみました。
.NETで値を渡しつつUnityを起動する自前ランチャ―を作りました。 pic.twitter.com/I0NzPEQPBaランチャー部分を担当。C#だったしxamlで雑にUI組めるので採用しただけでGUI生成出来るなら別にpythonとかでも良さそうランチされる側担当。起動時のコマンドライン変数をstringの配列で返す。例えばUnity.exe -hoge1 hoge2 -hunyaA hunyaBで起動すると
{"-hoge1", "hoge2", "-hunyaA", "hunyaB"}って返ってくる。.NET側、パスを渡してアプリケーションを起動することができる。第一引数がpath、第二引数でCommandLineArgsをstringで指定する。今回はサンプルとして簡単に「ランチャーに入力した文字をUnityアプリ上で表示するランチャー」を作ってみようと思います。まず、通常のNew SolutionからDesktop Applicationを作ります。今回は最小構成でMainWindow.xamlとMainWindow.xaml.csを書き換えていきます。こんな感じになります。TextBoxに入れられた文章をコマンドの引数としてUnityを起動します。
TextBoxに入れる文字列に半角スペースが入ると最初のスペースまでの文字列しか対応するArgumentとして解釈されないので注意しましょう。
起動時のCommandLineArgumentsを取得して、それをText.textに反映します。以下のC#を生成してシーン上のゲームオブジェクトにアタッチします。CommandLineArgumentの中から "-text"を取得して次の文章をText.textに反映しています。
CanvasとTextを生成してインスペクタのTextの部分に代入しましょう。結果としては以下のようになります。Unity側で起動時に特定のコマンドがなかった時にアプリケーションを終了する処理を加えるとランチャー以外からの起動を阻止できそうです。また、うまくUnityアプリを起動できないときはパスが正しいかどうかを確認しましょう。これを使えばUnity公式のランチャーに頼らずにゲームの個性を活かしたランチャーを作ることができそうです。トリプルAタイトルなんかはランチャーも凝ってるイメージがあるので、これでランチャーをイケてるモノにすればゲームもちょっと高級に見える…かも。


