More than 1 year has passed since last update.UnityのゲームをWebGLとしてビルドし、進行状況を保存したいのです。
やり方としては4つ考えられて、自前のサーバはめんどいので最後の手段として、外部サービスを利用するような（ランキングとかの）仕様も含んでいません。となるとPlayerPrefsかlocalStorageかなんですが、PlayerPrefsの解説を読むと「ブラウザのIndexedDB API使ってるで」と書いてありました。
つまりlocalStorageより良いもの使っていて、そこを自前で作るのも車輪の再開発になってしまうので、おべんきょするには良いと思うのですが開発が最終段に近付いていて今はリリースを優先したいので今回はパス。
となるとPlayerPrefsしか選択肢ないのではとなりました。しかしPlayerPrefsはどうにも使いにくいのです。
プリミティブ型しか保存できないし、一個一個ちまちま保存展開処理を書かないといけないし。
PlayerPrefsXも見たのですが、プリミティブ型を配列にして一括保存で効率良くなるのは分かりましたが、でもやりたいことではない。クラスのインスタンスを丸ごとシリアライズして保存したいし、それを取り出してデシリアライズして使いたい。ので、Unity用のシリアライザをいくつか試して、StringにしてPlayerPrefsに保存/取り出しが一番速いのはどれか調べました。一つ注意点として、どうもPlayerPrefsは非印刷文字をうまく保存してくれないようで、シリアライズ後のバイト列を直接ToString()した文字列は保存できませんでした。
エラーも出ず保存自体は成功しているように見えて、取り出すと最初の非印刷文字の部分で情報が途切れているとしか思えない文字列しか取得できませんでした。
（13バイト保存して1バイトしか取り出せないなど）
PlayerPrefsXでもBASE64にエンコードして保存しており、おそらく仕様であろうということで今回はテストから省きました。
なのでPlayerPrefsへの保存はすべてJSONまたはBASE64としています。Quoted-Printableっていう手もあるかなーと思ったんですが、Unity C#ではあんまり良いライブラリが出てこなかったのでこれも今回は無しとしています。速くて使いやすいシリアライザに絞って確認しようと思ったら、@neueccさんのものばっかりになってしまって、でもまぁそうなるよなーと思ってこれでいくことにしました。結論を先に書けと方方からよく聞きますので先に書きます。Windowsビルド（UWPでない）でのテスト結果（各回ループ10,000回、単位はms）WebGLビルドでのテスト結果（各回ループ10,000回、単位はms）太字にしている箇所は、save/load別でそれぞれ最速値のものです。
また、JsonUtilityだけ使っているデータクラスの形式が本当に少しだけですが違う（後述）ので、JsonUtilityの結果は参考記録としておきたいです。まずはWindowsビルドのほうですが、綺麗に傾向が分かれて、save最速はUtf8json / BASE64で、load最速がMessagePack-CSharp / BASE64でした。
non Serializeは期待通りの遅さで、JsonUtilityはだいぶ健闘しているけどもやっぱり遅め、他はどれを選んでもだいたい速いですが、MessagePack-CSharp / BASE64はload最速かつsave速度も2位でバランスが良く総合点は一番高そうです。WebGLビルドではまた結果が違っていて、non Serializeのloadが最速でこれインメモリのキャッシュがかなり効いているのでは？といった印象です。しかしsaveが死ぬほど遅いのでやはり候補には出来ません。non Serializeを除くと、JsonUtilityがやはり健闘はしてるけども遅め、次がMessagePack-CSharp / JSON で、その他はどれを選んでもあまり大差が無さそうです。
一番バランスが良いのはZeroFormatter / BASE64 でしょうか？
ただ数値のバラ付きが大きく誤差範囲内の気がするので、好みで選んでもだいたい大丈夫そうです。という結果になりました。Windowsビルドのほうがsave/load共に速いのかと思っていましたが、WebGLビルドのほうはsaveが遅くloadが速い傾向があって、これも新たな発見でした。保存の対象とするクラスですが、速度差が比較出来れば良いので、あんまり複雑にする意味はなく、ただ多少複雑な程度ならそのままシリアライズ/デシリアライズ出来るくらいは確認したい、ということで、クラス内に別クラスを一つ内包する、程度の形を作りました。MessegePack-CSharpとZeroFormatterの属性が両方ついています。
また、ZeroFormatterはシリアライズ出来るデータとしてプロパティを要求するため、プロパティとして実装してあります。@neueccさんのシリアライザは、どれもResolverが型ごとに最適な処理を選んで自動でシリアライズしてくれるようになっているのですが、Utf8jsonの標準のResolverがSystem.Reflection.Emitを利用する設定になっており、UnityのiOSビルドとWebGLビルドはSystem.Reflection.Emitが使われているとUnsupportedエラーで動きません。ただ、ちゃんとやり方は用意してもらってあって、Utf8Json.UniversalCodeGeneratorを使って事前にPre Code Generationすると、特製Resolverのソースコードを自動生成してくれるので、こちらで生成したコードなら利用可能です。で、ZeroFormatterもMessagePack-CSharpも類似のResolver自動生成ツールを用意してもらっているので、条件をあわせるためにすべて事前コード生成を利用しています。その結果がMessegePack-CSharpとZeroFormatterの属性が両方ついているという今回のこの謎コードなのですがテスト用なのでお許しください。JsonUtilityはプロパティをシリアライズ対象とすることが出来ないので、プロパティでなくメンバ変数としたクラスも用意しました。
プロパティかメンバ変数かでシリアライズ速度に影響が出るのか定かではありませんが、使ったデータクラスが一応別物なので、JsonUtilityの結果は参考記録とします。絞ったつもりなんですが、JSON / BASE64 との組み合わせでパターンが増えてしまって長くなってしまいました。テストは、各シリアライザについて、保存処理を10,000回ループして時間計測、取り出し処理を10,000回ループして時間計測、その後に保存前と取り出し後のデータの一致チェック（これは時間計測なし）を行っています。
一致チェックは仮のもので本来は1回ずつで正しい数値が取れていればいいのですが、これでもコードは通るけど結果が正しくないものの抽出に役立ちました。あとは、ZeroFormatterでシリアライズ後のバイト列をJSON化したかったんですが、これもバイト列からのJSON化のライブラリがうまく探せてなくて無しにしました。バイト列からJSON化はシリアライザとセットじゃないと原理的に出来ない気がするので仕方ないところかなぁとも思います。IndexedDBとWebStorage(localStorageとsessionStorage)のざっくりまとめ - Qiitaneuecc/ZeroFormatter: Fastest C# Serializer and Infinitely Fast Deserializer for .NET, .NET Core and Unity.neuecc/Utf8Json: Definitely Fastest and Zero Allocation JSON Serializer for C#(NET, .NET Core, Unity, Xamarin).neuecc/MessagePack-CSharp: Extremely Fast MessagePack Serializer for C#(.NET, .NET Core, Unity, Xamarin). / msgpack.org[C#][Unity] JsonUtility vs ZeroFormatter vs FlatBuffers (ローカルデータの永続化) - QiitaUnityでセーブデータをSerialize保存する 〜現状〜 - QiitaデータをJSON形式でPlayerPrefsに保存する - Qiita


