　こんにちは、九島茶にゃです。
　今回の記事は開発者向けになります。
　ILかアセンブリ言語についての知識があるといいでしょう。　簡単に言えば、以下のコードがあったとします。　次に、Sample.csと全く同じ動作をする、以下の様なコードがあるとします。　もしコードに対し逐次的に処理が行われる（コンパイラ、仮想マシン、CPU等での改変がない）としたら、明らかに10 * 5の計算や変数aへのstore/loadを行っていないImprovedSample.csの方が速いに決まっていますよね？　ちなみに、Sample.csをDebug/Releaseでコンパイルするとこう解釈されます。（処理の部分のみ抽出します。assembly等の属性の付加も見たい人はこちら）　以上のコードを見ると、Debugでは領域が確保され、代入の処理が行われるのに対し、Releaseでは領域が確保されず、WriteLineメソッドに直接値が渡されている（不要な処理が省かれている）事がわかります。そのため、Releaseでは一部ブレークポイントをつけても認識されない所があります。ただし、不要な処理が省かれるので明らかに速いです。　一般的に、Debug/Releaseには最大スタック数(サイズ)、ローカル変数のサイズ、コードサイズにて以下のような関係性があります。　最大スタック数は基本的に同じです（1,2か引数の数だけ確保される）。しかし、ローカル変数を用いないときはデフォルトのサイズ(8 Bytes)が確保されるので、以上のようになります。
　ローカル変数はReleaseSample.csの通り、最適化によって領域が確保されない可能性があるからです。
　コードサイズは、DebugコンパイラはDebugSample.csのようにコードを逐次的にILに変換し、（ブレークポイントのため？）nopをいくつか追加します。Releaseコンパイラは出来るだけ軽く、短いコードを生成します。勿論、基本的にnopは生成しません。そのため、以上のようにDebugの方がコードサイズが大きくなります。


