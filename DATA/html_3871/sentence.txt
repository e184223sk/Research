More than 1 year has passed since last update.「人はわかりあえる！　だからコメントはあんまり書かなくていい！」1
とごねていたのですが、自分が書いたPhotonのRaiseEventのラッパーの使い方がみんなよくわからなかったっぽいので、反省して説明を書きます。
PUN22です。PUN1でも要領は一緒なので適宜読み替えてください。継承元のSingletonMonoBehaviourはみんな知ってるとこからコピペしてきたやつ。
gistにも置いておきました3
これだけでわかる人は使い方のコツだけ読んでください。RPCでいいじゃん、と思う人もいるかと思いますが、なんかやばいこと書いてあるのでRaiseEvent使ったほうがいいと思います。そもそもRPCめんどくさい。4
やばいこと


最適化のヒント
ターゲットGameObjectのあらゆるコンポーネントはRPCを実装することができるので、PUNはリフレクションを使用して適切なメソッドを見つけます。
これをそのままやるとたいへんめんどくさいです。実際にどう動くかを見たほうが早いと思うのでコード書きます。こんなシーンです。押したボタン毎にCubeの色が変わります。その色の変更がRaiseEventを通じて相手に共有されます。
ちなみにですがPhotonViewはこのシーン内に存在していません。5

GameManagerに以下の管理スクリプトを貼り付けます。
どこでもいいですが、RER/RSRも同じオブジェクトに貼り付けておきます。変化させた色が共有されます。

CachingOption = EventCaching.AddToRoomCache,
Roomにキャッシュしているため、後から来た人にもRaiseEventが届いています。
ボタンがどのように押されたかを見たいため、右側にログを出します。シーンはこんな感じ。
右の白いところに操作ログが文字で出ます。

RER/RSR（イベント送受信者）にもPunSampleManager（イベント受信側）にもいっさい変更を加えることなく、イベントを受信するクラスを増やすことができました。せっかくなのでCubeを回転させましょう。回転を共有できました。
既存のCubeの色を変更する箇所には影響がありません。送信側を例にすると、RER/RESでCubeの回転を他クライアントに送信した後に自分でCubeを回したりしない、ということ。イベント受信時に実行する操作はイベント受信時のみに行ってください。
来ないかもしれない？　遅いかもしれない？　
PUN2を信じろ。objectはシリアライズできるものならなんでもいいです。PUN1の時代は一部のStringが文字化けしてたような気がしたので気をつけたほうがいいかも。
画像のような大きめのデータを送受信していて速度が気になる場合はMessagePackで圧縮かけると少しマシかもしれません。6
パフォーマンスチューニングは百人百様なので各自がんばりましょう。Actionに登録されたオブジェクトのライフサイクルの管理めんどくさいすぎるので想定していません。RER/RESはシーンのオブジェクトとして使い捨てする運用でよいと思います。
それでも複数のシーン間で使いたいとかだったら、インスタンス破棄時にOnDestroyでリスナ解除とかUniRxでうまいことするとか。RaiseEventOptionsによるキャッシュの話は長くなりすぎるので割愛。ここ極めるとPUN2の自由度がぐっと上がります。
インタレストグループに対応するのもそう難しくないので需要がある人はてきとうに改造してください。で、記事書き終わって気がついたんですけどコードにまったくコメント書いてなくて反省の色がねえなって思いました。おしまい。全ての人が刺身にタンポポを乗せなくてよくなる時は遠い……。余談ですがこの記事を書いた人ってすごく初学者にやさしく接した人ですよね。「他人がなにを考えてそうしているのか」を言語化するためには辛抱強く話を聞いてあげる必要があります。自分はそんなに優しくはできない。 ↩これ英語圏でも「パンツ」っぽく発音すると思うんですけどIT系ってむちむちのおっさんが多いですけどむちむちのおっさんたちが「パンツ」って言いまくることになると思うんですけど！！！！？！！？？！？！？ ↩使ってみたかっただけ ↩サンプルをチラ見して「は？　だっる」とか思って使ってなかったんですけど改めて読んだらほんっっとめんどくせえ！ ↩パフォーマンスを気にするならできるだけPhotonViewを削減すべし ↩そもRaiseEventはそういう用途で使うものではないです ↩


