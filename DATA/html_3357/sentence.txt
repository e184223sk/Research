More than 1 year has passed since last update.Unityのネットワーク機能として提供されていたUNetが廃止されるとのことで、
その代わりになるであろうUnityのGithubで公開されているmultiplayerを少し触ってみたところ、
書かれている部分が最新のコードと一致していなかったので修正した部分をメモしていく。Unity multiplayerはUNetの低レベル部分を置き換えるものになるそうだ。GithubからリポジトリをクローンしてUnityプロジェクトのPackages/manifest.jsonに以下のものを追記すればOK。相対パスとして指定しているのでリポジトリのクローンする場所に合わせてパスも変更すること。
(以下のだとクローンしたリポジトリとUnityプロジェクトは同じディレクトリにある)クライアントがサーバーに数値を送って、サーバーが適当な数を足してクライアントに返すという処理を作成する簡単なチュートリアル。Unity.Networking.Transport.BasicNetworkDriverがUnity.Networking.Transport.GenericNetworkDriverに置き換わったのでそこを書き換える。
Unity.Networking.Transport.GenericNetworkDriverは最新版で新しく導入されたpipelinesをテンプレート引数に指定する必要がある。
コードを検索したところUnity.Networking.Transport.DefaultPipelineStageCollectionが妥当そうだったのでそれを指定している。pipelinesはレイヤーを使ってソケット実装のふるまいを指定できるものとかないとか。信頼性があるReliableSequencedPipelineStageと高レイテンシー環境をシミュレーションするためのSimulatorPipelineStageなどがあらかじめ用意されている。
ReliableSequencedPipelineStageなどを使うときはUnity.Networking.Transport.GenericNetworkDriverを作成時にパラメータを渡す必要がある。が、NullPipelineStageも提供されているので今回はこれを使っている。あと、System.NetはUnity.Networking.Transport.NetworkEndPointを使うようになっているので必要なくなっている。上で見たように使用しているクラスが変わったので処理も少し変わる。といっても使うクラスが変わっただけで処理内容は変わらない。multiplayerはUnity Job Systemを内部で利用しているので、チュートリアルでは同期待ちを行っている。Update関数内では修正部分はあまりなかったが、クライアントへデータを送信するときにpipelineを指定する必要がある。
(NetworkPipeline.NullでもOK)
pipelinesについてはこちらサーバーサイドはこれで完成。次はクライアントサイドを作る。といってもStart()内でNetworkEndPointを使うようにする、pipelineを使うぐらいであまり修正点はなかった。ちなみにNetworkConnection.Sendでpipelineを渡さなくてもいい。そのときはNetworkPipeline.Nullを指定したのと同じになる。GenericNetworkDriverとNetworkPipeline、NetworkEndPointが新しく追加されたのでその周りを修正するだけという感じでした。


