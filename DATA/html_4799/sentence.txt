More than 3 years have passed since last update.たまたま、SemaphoreSlim を使った並列実行の制御をするコードを読んだので、ちゃんと理解するために、サンプルコードを書いて調べてみたので、ブログに書いておく。Semaphore という概念はこちらのブログがとってもわかりやすい。つまるところ、並列実行をするときに、並列実行数を制御できる仕組みだ。数が付いたロックのようなもの。どのような時に使うかというと、並列実行をして処理速度を上げたいんだけど、あまりたくさんの数で並列実行させてしまうと、受け手がパンクする、、、とかいうユースケースが考えられる。この概念を表す Semaphore と SemaphoreSlim というクラスが存在する。Semaphore の方は、このセマフォの仕組みがWin32セマフォオブジェクトのラッパである。SemaphoreSlim シンプルな実装の方で、ローカル（つまり自分のアプリ内）のみのセマフォをサポートし、Semaphore の方はシステムワイドなNamed Semaphore という概念を実装しているので、システムワイドにセマフォを共有してそれに名前を付けたりできるようだ。.NET でプログラミングするなら大抵の人は SemaphoreSlim で事が済む気がする。詳しくはこちら。ちなみに非同期：awaitを含むコードをロックするには？（SemaphoreSlim編）［C#、VB］こちらの記事では、async メソッドを使いながらロックを書けるのに使うといわれていたが、個人的には目的が違う気がする。ただ確かにセマフォを１に設定すると、実質ロックをかけているのとかわらないので興味深い。今回は SemaphoreSlim のオフィシャルページにのっていたサンプルがわかりやすかったのでちょっとだけ変えて実装してみた。リファレンス実装はこちらから見れるちなみに、リファレンス実装にでてくるContract クラスはアサーション。契約による設計というやつでしょうか。とてもシンプルで、セマフォを生成する。第一引数は、初期値で、第二引数は最大値。つまり最初のセマフォは０なので、一切新しいタスクを実行できないが、増やしたら３まで並列実行できるようになる。そして、並列実行させている箇所で次のように書く。Wait/WaitAsync() の箇所でセマフォが待ち状態に入る。上記のリファレンス実装を見ると内部で lock を使って自分で管理して実装していた。セマフォが使える状態になったら、以降の処理を実行する。Release() でそのセマフォをリリースする。つまり次の並列実行している関数などがセマフォのWait で待っているものが、処理をスタートできるようになる。単純にこれだけ。じゃあ実際にコードを書いてみてみよう。これがどんな処理をしているかというと、最初はセマフォが使えない（初期値０なので）Task.Run の中でマルチスレッドもしくは、並列で async メソッドを実行する。そして、semaphore.Wait()/WaitAsync() でストップする。セマフォで使えるのがゼロなので。の箇所に来るとセマフォが３つリリースされる。つまり、セマフォが使える最大値になる。そしたら、セマフォでブロックされていた３つぶんのスレッドもしくは、async メソッドが動き出す。５つのTaskがあるが同時に動くのは３つまで。それらが終わるのをまって、次のスレッドが動き出すという挙動になる。途中で Interlocked というクラスのメソッドが出てくる。これは、ロックをかけるのだが、lock よりもずっと負荷を小さくできるやり方で、中で参照されている変数にロックを書けることができる。実際にロックの方式を比較されている方がいます。思った通りの動きをしている。ちなみに、async バージョンを書いてみると、同じように動くが、Task.CurrentId がnullになるのはなんでだろう？実行結果は同じだが、Task.CurrentId が最初の beginsのところ以降、つまり、Semaphore の有効範囲内では null になっているので表示されない。他に参考になりそうなリソースかずき師匠のエントリ。理解するために await クラスを自作するという素晴らしいセンス！公式のスレッド関係の一覧が載っている今回のサンプル


