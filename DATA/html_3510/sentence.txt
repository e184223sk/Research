More than 1 year has passed since last update.gRPC アプリケーションの開発で proto ファイルを使用したくない／使用する必要がないケースもあります。ProtocolBuffers 以外のデータフォーマットを使用したいプラットフォーム間の相互運用性を考慮しないこのドキュメントでは実装手順を説明します。★がついている章が proto ファイルを使用しないときに必要になる部分です。なお、Grpc.Tools で生成される C# のソースコードについては次のエントリで説明しています。【Qiita】Grpc.Tools で生成される C# ソースコードの解説
【Qiita】C# Protocol Buffers メッセージモデルクラスの難点RPCメソッドのリクエスト／レスポンスとして使用する型を定義します。サーバーアプリケーションとクライアントアプリケーションを同一プラットフォームで開発する場合、実装を共有できるようにするとよいです。
この例では ProtocolBuffers ではなく MessagePackを使用しています。サーバーアプリケーションとクライアントアプリケーションのプラットフォームが異なる場合、相互運用性があるデータフォーマットを使用する必要があります。【GitHub】neuecc/MessagePack-CSharpサービスクラスを実装します。リクエスト／レスポンスオブジェクトのシリアライズとデシリアライズを行う Marshaller&lt;T&gt; を生成します。リクエスト／レスポンスの型の数だけ生成することになりますので、通常は汎用ジェネリックメソッドとして実装します。
Marshaller は、この後の Method&lt;TRequest, TResponse&gt; を生成するときに必要になります。RPCメソッドのシグネチャにあたる Method&amp;lt;TRequest, TResponse&amp;gt を生成します。サーバーアプリケーションとクライアントアプリケーションを同一プラットフォームで開発する場合、実装を共有できるようにするとよいです。資格証明を生成します。
特に何も使用しない場合は Grpc.Core に定義されている ServerCredentials.Insecure を使用します。
SslServerCredentials については、【Qiita】C# gRPC v1.16.0 SSLに関する仕様変更 を参照してください。RPC通信に使用するポートの定義を生成します。RPCサービスメソッドの定義を生成します。
ServerServiceDefinition.Builder の AddMethod メソッドは、戻り値としてメソッド追加後の ServerServiceDefinition.Builder を返します。複数のメソッドを追加する場合、fluent スタイルで記述するのが一般的です。サーバーオブジェクトを生成し、ServerPort と ServerServiceDefinition を登録します。サーバーサイドの実装の説明を参照してください。
サーバーアプリケーションとクライアントアプリケーションを同一プラットフォームで開発する場合、実装を共有できるようにするとよいです。サーバーサイドの実装の説明を参照してください。
サーバーアプリケーションとクライアントアプリケーションを同一プラットフォームで開発する場合、実装を共有できるようにするとよいです。サーバーサイドの実装の説明を参照してください。
サーバーアプリケーションとクライアントアプリケーションを同一プラットフォームで開発する場合、実装を共有できるようにするとよいです。資格証明を生成します。
特に何も使用しない場合は Grpc.Core に定義されている ChannelCredentials.Insecure を使用します。
SslCredentials については、【Qiita】C# gRPC v1.16.0 SSLに関する仕様変更 を参照してください。チャネルを生成します。呼び出しオブジェクトを生成します。RPCメソッドを呼び出すには、RPCメソッドの定義を引数で CallInvoker に渡す必要があります。アプリケーションコードからRPCメソッドを呼び出しやすくするため、ショートカットメソッドを持つクライアントクラスを実装します。gRPC サーバーやクライアントを XML ファイルの定義に従って構成する方法についても紹介しています。【GitHub】XmlSerializer を使用して gRPC を構成する


