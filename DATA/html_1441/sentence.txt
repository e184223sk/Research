More than 1 year has passed since last update.以下のすべての点を満たすソート処理を作ります。例えば、以下のようなListをソート対象と仮定します。実行したいソートに応じて、以下のようにソート処理を呼び出せるものとします。汎用性を持たせたいので、（理論上）どれだけ深い階層のプロパティでもソートキーとして指定できるメソッドとして作成します。.NET Core等で「リクエストに応じて何らかのリストを生成して返すWebAPI」を作る場合、リクエストで指定されたキーでソートされたリストを返したい、という場面が生じることがあります。
.NETでソートを行う際の定番はLinqのOrderBy句やThenBy句等々ですが、これらを素直に使う場合、ソート対象のプロパティは静的に指定することになります。
なので、想定されるソートキーの数だけif、else ifを連結してOrderBy等を実装する、などというゴリ押しな手段を採ることになりかねません。そこで、このソートキーを動的に指定できるソート処理の出番となります。例えば、リクエストボディの中にという要素が積まれるとして、これらをソート処理の呼び出しに使うようにする、という寸法です。上記のソート処理用メソッドを持つNuGetパッケージを作り、公開してみました。
https://www.nuget.org/packages/MagicSort/対応フレームワーク・対応バージョンは以下の通りです。ソースはGitHubにて公開しています。
https://github.com/microwavePC/MagicSort詳細な使い方は、GitHubのREADMEを参照してください！この処理の肝となる部分を簡潔に紹介します。処理の全体はGitHubにupしたソースをご覧ください。このソート処理の中では、LinqのOrderBy OrderByDescending を使用しています。
複数のキーが指定される場合は、加えてThenBy ThenByDescendingも使用しています。
これらの引数となるラムダ式を、処理内部で動的に生成しています。単一キーによるソート処理では、以下のように動的ソートを実現しています。ラムダ式を生成するメソッド AssembleOrderFunc では、以下の処理を行っています。実行する環境にも拠るとは思いますが、この1024件のデータを持つ多階層リストを対象に以下のような5重のソート処理を実行したところ、デバッグ実行における処理時間は5～10ミリ秒前後でした。


