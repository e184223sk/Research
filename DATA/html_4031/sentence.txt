More than 1 year has passed since last update.個人の勉強メモです。本業は組み込みなのですが、業務補助ツールなどでWPFアプリを作成することがあります。
MVVMインフラには Livet を使っているのですが、規模の大きいアプリでは、Viewの遅延読み込みやDIコンテナを使いたいことがあり、少し物足りないと感じることがありました。そこでPrismの習得に向けて、公式のWPFサンプルを順に勉強していきます。
タイトル横の記号は理解度の印象で、深い意味はありません。真っ白なウィンドウが表示されるだけ。次の 02-Regions と同じ内容っぽいし、こちらは IntelliSense に旧型式って表示されるので、重要でなさげ。Prismを使って真っ白なウィンドウを表示するサンプル真っ白なウィンドウが表示されるだけ。App.xaml のコードビハインド CreateShell() にて、コンテナを使って MainWindowクラスを探して起動してる感じ。
全てのソリューションで必要そう。Appの継承元が、System.Windows.Application でなく、Prism.Unity.PrismApplication になっている点がポイントで、App.xaml のクラスも通常とは異なっている。何のサンプルか分からない…真っ白なウィンドウが表示されるだけ。これで何が出来ているのかが分からない。
新たに PrismApplicationBase.ConfigureRegionAdapterMappings() や、class RegionAdapterBase&lt;T&gt; が出てきた。コードビハインドから xaml で命名した Region に 自作UserControl を表示するサンプル。ViewAが表示される。Region名を付けているだけViewAを登録するために、MainWindowコンストラクタに IRegionManager が渡されている。明示的にMainWindowのコンストラクタをコールしている記述はなく、コンテナがええ感じでインターフェスを渡していると思われる。インジェクションと言われるやつ？シンプルなコードであっても、コードビハインドにコードを書くことに抵抗がある…Button の Clickイベントで、自作UserControl を読み出すサンプル
UserControl の登録の実装が 04-ViewDiscovery と異なる。ボタンが1つ配置されており、クリックするとViewAが読み込まれる。ボタンを複数回クリックしても View の見た目は変わらないが、内部では ViewA が複数追加されていると思われイマイチ。MainWindow のボタンClickイベントにより、コードビハインドから UserControl を読み出している。
これは View の遅延読み込みに使えそう。上記対応のために、MainWindowのコンストラクタに引数 IContainerExtension が増えた。やはり明示的にMainWindowのコンストラクタをコールしている記述はなく、コンテナがええ感じで解決していると思われる。自作UserControl のアクティブ/非アクティブを切り替えるサンプル。（破棄ではない）ボタンが4つ配置されており、ViewAが表示されている。各ボタンは、ViewA/ViewBの読み込みと破棄に割り当てられており、ボタンに応じてViewの見た目が変化する。MainWindow の ContentControl に対して、登録済み UserControl の表示/非表示を行う。表示の切り替えなので、05-ViewInjection のように View が複数個登録されることはない。Viewの表示は、先にRegionに登録した方(ViewA)が、優先して表示されるルールっぽい。
MainWindow のコードビハインドに UserControl の実体を定義してることに違和感を感じる。07-Modules は子モジュールを読み込むサンプル。
AppConfig / Code / Directory / LoadManual の4項目が用意されている。
2つめの Code が最も広く使われているっぽい。ViewAが表示される 。 (07-Modules共通)ContentRegionの名前で ContentControl を配置しておく。子モジュールのProject直下に ModuleAModule.cs を追加して、親モジュールの Region名を string で指定する。（07-Modules共通）親モジュール側のコードに、ModuleA を直接記述している箇所は App.configのみ。App.xamlのコードビハインド CreateModuleCatalog() にて、App.configに記載されたジュールを自動で配置しているっぽい。07-Modules は子モジュールを読み込むサンプルの２つめ。
見たことあるパターンで、以降のサンプルでも度々登場する。ViewAが表示される 。 (07-Modules共通)07-Modules - AppConfig と同内容なので割愛（07-Modules共通）App.xaml のコードビハインド ConfigureModuleCatalog() で、ModuleAプロジェクトのクラス ModuleAModule を直接指定して、Viewに配置している。07-Modules は子モジュールを読み込むサンプルの３つめ。
dllが含まれるディレクトリを指定する。機能拡張などに使えるかも。ViewAが表示される 。 (07-Modules共通)07-Modules - AppConfig と同内容なので割愛（07-Modules共通）App.xaml のコードビハインドで、子モジュール.dll が格納された DirectoryPATH を指定して読み出している。
dll が存在しなければ何も読み込まれないので、機能拡張などに使えるかも。07-Modules は子モジュールを読み込むサンプルの４つめ。ViewAが表示される 。 (07-Modules共通)07-Modules - AppConfig と同内容なので割愛（07-Modules共通）親モジュールのUIイベント（Windowのコードビハインド）で子モジュールを読み出している。UserControl を読み出してたやつ（05-ViewInjection）のモジュール版。
こちらも遅延読み込みに使えそう。子モジュールの指定は、子モジュールクラス名の文字列により行われているが、nameof() 演算子を使った方が安全そう。Viewに対応する ViewModel を自動で配置するサンプル。
ViewModel が初登場！真っ白なウィンドウが表示されるだけだが、Windowタイトル が ViewModel で指定された文字列になっている。xaml に1行書いとけば、対応する ViewModel が自動で読み込まれる。
DataContext で指定する必要がない。Prism.Mvvm.BindableBase を継承しており、BindableBase は INotifyPropertyChanged を継承している。
ViewModel は必ず BindableBase を継承しておけば良さげ。Viewのxamlファイルに ViewModel を含めたような記述ができるっぽい。08-ViewModelLocatorと同じ
真っ白なウィンドウが表示されるだけだが、Windowタイトル が ViewModel で指定された文字列になっている。Viewのxamlファイルに ViewModel を含めたような記述ができるっぽい。（xamlに2つの*.csがぶらさった構成を初めて見た）
MVVM記法から外れている気がするので使わなさそう。08-ViewModelLocator で出てきた、自動で名前解決される ViewModel のクラス名を指定できるっぽい。
サンプルでは、View の MainWindow.xaml に対して、ViewModel の CustomViewModel.cs を割り当てている。
どのような場面で使うかが想像できないので使わなさそう。08-ViewModelLocatorと同じ。
真っ白なウィンドウが表示されるだけだが、Windowタイトル が ViewModel で指定された文字列になっている。App.xaml.cs で View に対応する ViewModel を指定している。
いくつかの方法があるっぽく、サンプル時点でコメントアウトされていた。xaml の Button.Command に応じた ViewModel 処理。チェックボックスを有効にすると各ボタンが有効になり、各ボタンを押すと下部に現在時間が表示される。複雑で文字で説明できなくなってしまったので、図を貼ってみる。

ICommand を継承した Prism.Commands.DelegateCommand を使って、Action / CanExecute を指定してる。4つのボタンそれぞれで実装が異なる。使い慣れた ReactiveCommand で代替できそうなので使わなさそう。
最後までサンプルをやった結果、DelegateCommand がゴリゴリ出てくるので、ちゃんと使えるようになるべきと考えを改めました。複数の DelegateCommand を1つに集約するサンプル。
集約されたCommandを実行したら、各Commandを全実行した動作になる。3つのTabが存在し、各Tabがチェックボックスを持っている。各Tabのチェックボックスが有効なら、自Tabのボタンが有効になる。全てのTabのボタンが有効なら、上部の Saveボタンが有効になる。各TabのSaveボタンを押下すると、自タブに現在時刻が表示される。上部のSaveボタンを押下すると、全てのタブに現在時刻が表示される。（=全タブのボタンを押した動作）
この辺りから理解が難しくなってきた。親Moduleの xaml で TabControl を定義し、Region名を付けておくUserControl をベースに TabItem  を作成する（TabView.xaml）子モジュールの fogeModule.OnInitialized() にて、作成した TabItem を登録していく。
TabView から TabViewModel の取得法が力業で引いた…
ViewModelのコンストラクタにTitleを渡すような実装はできないのでしょうか。各Tab が保持する ICommand を結合して、上部のSaveボタンに割り当てているっぽい。登録された全ての ICommand が CanExecute == true なら、統合された CompositeCommand が実行可能となる。CompositeCommand が実行されると、登録されたすべての ICommand が実行される。親と子モジュールが参照できるところに（サンプルでは別プロジェクト）、ApplicationCommands クラスを定義する。
ApplicationCommands の中身は Prism.Command.CompositeCommand のみ。親Module の App.xaml.cs にて、上記自作クラスのインターフェースと実装をコンテナに登録する。
サンプルでは Singleton で登録。MainWindow の ViewModel のコンストラクタ引数に対して、上記自作クラスが自動で注入されるので受け取る。各TabItem の ViewModel も同様にコンストラクタで自作クラスを受け取り、自クラスの UpdateCommand(ICommand) を登録していく。
自クラスの UpdateCommand は自クラスのチェックボックスにバインドされたフラグを監視している。(2行目)12-UsingCompositeCommands と同様に複数の DelegateCommand を1つに集約するが、アクティブなコントロールを参照するサンプル。12-UsingCompositeCommands と同じ View。動作は少し違って、こちらはActiveなTabの チェックボックスに応じて上部ボタンの IsEnable を切り替えている。
コマンドが実行されるのもActiveなタブのみ。各Tabのチェックボックス状態と上部ボタン状態　TabA： CheckBox.IsEnable=True　（Viewで選択中のTab）
　TabB： CheckBox.IsEnable=False
　TabC： CheckBox.IsEnable=False
　　12-UsingCompositeCommands　⇒　TopButton.IsEnable=False
　　13-IActiveAwareCommands　⇒　TopButton.IsEnable=TrueCompositeCommand が Active な Control を判別するために、下記対応をしてるっぽい（抜けてるかも）Prism.Commands.CompositeCommand のコンストラクタ引数を true にする。TabItem の ViewModel にて、IActiveAware インターフェースを継承する。継承した IActiveAware  に対応するコードを書き、IsActiveプロパティを更新する。サンプルには出てこないが、IsActiveChanged にイベントを登録しておけば、IsActiveの変化時に処理ができる。モジュール間で情報の受け渡しをするサンプルボタンをクリックすると、テキストボックスに入力された文字列が、右のリストボックスに表示される
左右でModule(プロジェクト)が分かれている。各プロジェクトが参照できるところに MessageSentEvent.cs を定義する。(サンプルでは別プロジェクト）MessageSentEvent.cs は、Prism.Events.PubSubEvent&lt;TPayload&gt; を継承してるだけの空クラス。定義しなくても対応できると思うが、使用時にジェネリックの型パラメータのネストが深くなり見辛いのかも。MainWindowを左右に分割して、リージョン名を付けてるだけ。親モジュールへの配置は、07-Modules と同じ手法なので割愛。ViewModelのコンストラクタで IEventAggregator を受けており、ボタンクリック時に DelegateCommand で SendMessage() がコールされている。情報発行は、デリゲートコマンド引数のActionがポイント左側の子モジュールと同様に、コンストラクタで IEventAggregator を受ける。情報取得は、コンストラクタ内のメソッドがポイントEventAggregator にて、情報取得側が取得する情報のフィルタリングを行うサンプル14-UsingEventAggregator と同じView。機能差分は情報の取得側のフィルタリングで、文字列に "Brian" が含まれる場合のみ情報を取得している。※情報の発行側は、14-UsingEventAggregator と同じで、文字列に関わらず発行する。14-UsingEventAggregator からの変化点である 右側モジュール（ModuleB）についてのみまとめる。フィルタリングは、ModuleB の ViewModel に実装されており、判定は Predicate&lt;T&gt; なので、色々と差し替えできそう。引数の " ThreadOption threadOption" と "bool keepSubscriberReferenceAlive" については未調査。初の複数Region。上下で分かれている。上下に分かれており、上部リストボックスで選択した情報が、下部テキストブロックに表示される。リッチUIアプリの頻出パターン。Prism特有のクラスとかは使ってなさげで、特別難しいことはないと思う。特別なことはしてない。子モジュールを読み込むだけ。（07-Modules - Code）ListBox の選択情報を SelectedItem で取得し表示している。下部コントロールの配置をリージョン名から行っており、こーゆー雰囲気でUIコントロールを細分化して管理するのかなと思った。Navitgation を使って、表示する自作UserControl を切り替えるサンプルボタンが二つ配置されており、各ボタンを押すと、ウィンドウ下部に ViewA もしくは ViewB が読み込まれる。起動時は ViewA も ViewB も読み込まれていない状態。コンテナに ViewA/ViewB を登録している。重要なのは親モジュール。親モジュールでは、View(xaml)のButtonの CommandParameter で 子モジュールの UserControl名 (ViewAorViewB) を指定している。ViewModel の DelegateCommand で、子モジュールの UserControl を読み込んでいる。試しに存在しない UserControl名 (ViewC) を指定したところ、画面に "System.Object" と表示された。例外は発生しなかった。Navigation の完了時に Callback(Action) を行うサンプル。17-BasicRegionNavigation と同じ見た目。差分としては、ボタンのクリックにより、子モジュールの View が読み込まれたあとに、ポップアップウィンドウが表示される。モジュール読み出し完了のタイミングで処理を行っている。UserControl の呼び出し時に、Callbackとして Action&lt;NavigationResult&gt; を登録している。先ほどと同様に存在しない UserControl の指定を試したところ、読み込めていないのに complete. と表示された。NavigationResult には、Errorプロパティ が存在するので、読み込めない場合は、Errorに何か情報が入るかと期待したが、モジュールが見つからない場合でも Error は null だった。（いつErrroが入るか謎…）自作UserControl に INavigationAware を継承することで、Navigationの遷移時に処理を行うサンプルボタンが二つ配置されており、ボタンを押すと各ボタンに対応した UserControl がタブに読み込まれる。ボタンをクリックするたびに、UserControl 内のカウンタがインクリメントされていく。また、ボタンクリック時に対応する UserControl が表示されていなければ、対応するタブにフォーカスが移動する。 17-BasicRegionNavigation と同じ。xaml で UserControl名 を指定して、DelegateCommand で読み込み。17-BasicRegionNavigation からの差分として、ViewModel が Prism.Regions.INavigationAware を継承している。INavigationAware には 3つのメソッドが存在し、カウントアップなどを実現している。下記コメントは勝手に書いています。19-NavigationParticipation の応用サンプル。
特定条件で 自作View を使い回さずに新規追加する。19-NavigationParticipation と同じ見た目。差分としては、ボタンを一定回数クリックすると、新規タブが作成されて増えていく。先ほど少し出てきた INavigationAware.IsNavigationTarget() の戻り値をカウンタに応じて変えているだけ。16-RegionContext とほぼ同じ見た目。差分としては、リストアイテムのクリックにより、下部にタブが追加されて情報が表示される。複雑で少し付いていけない…
実現してることに比べて実装が難しすぎる気がする…特に目新しいことはしてないListBox の SelectionChanged イベントで 選択されている Personインスタンス を DelegateCommand の Action&lt;Person&gt; に渡すAction&lt;Person&gt; では、Tabのリージョン("PersonDetailsRegion") に PersonDetail.xaml を登録する初回の PersonDetailViewModel では、インスタンスが作成されて、OnNavigatedTo() で SelectedPerson が更新される初回以降は、IsNavigationTarget() で 選択された Person に対応するViewModelインスタンスが存在するかがチェックされて、存在しなければ新たなインスタンスが作成され増えていく。Navigation に遷移するかどうかをダイアログで切り替えるサンプル17-BasicRegionNavigation と同じ見た目で、機能もほぼ同じ。差分としては、ViewAを表示中にボタンBを押下すると、Navigate するかどうかを Yes/No 形式のメッセージボックスで質問される。
Yes を選択すると ViewB の表示に切り替わる。
No を選択すると ViewA の表示のまま変化しない。17-BasicRegionNavigation と同じで、目新しいことはないViewA の ViewModel のみ Prism.Regions.IConfirmNavigationRequest を継承している。ViewAViewModel の実装Viewの非アクティブ時にインスタンスを保持するかどうかを IRegionMemberLifetime により指定するサンプル17-BasicRegionNavigation と同じ見た目。動作だけ見ても意味が分からないが、コードを見るに、水色パネルはViewのインスタンスを可視化している。ViewAは非アクティブ時にインスタンスを保持しない造りにしているので、ViewA→ViewB と操作すると、ViewAパネル（インスタンス）が消える。水色パネルは、ObservableCollection&lt;object&gt; を ItemsControl により表示してる。ObservableCollection&lt;object&gt; だが string しか格納されないので、ObservableCollection&lt;string&gt; でも問題ない。CollectionChangedイベントにより実現されている。サンプルで初めて出てきた。ほぼ 19-NavigationParticipation と同じ。差分は、ViewAViewModel が Prism.Regions.IRegionMemberLifetime を継承している点だけ。ViewAViewModel の実装（非アクティブ時は常にインスタンスを保持しない）ブラウザの戻る進むのように画面遷移するサンプル16-RegionContext と同じ Person選択系。リストボックスが表示されており、選択すると詳細表示に画面が遷移する。GoBackボタンで戻れて、GoForwardボタンで進める。画面遷移が初めて出てきた。特に目新しい点はなしListBoxのSelectionChangedイベントで、ViewModelからUserControlのPersonDetailを読み出す。PersonDetailViewModel は INavigationAware を継承しており、ナビゲートが移った際に IRegionNavigationJournal を保持する。
この Prism.Regions.IRegionNavigationJournal を使って画面遷移を制御する。Go Backボタンが押されたら、IRegionNavigationJournal.GoBack() により、最初のViewModelに戻る。
ここでも INavigationAware.OnNavigatedTo()  で IRegionNavigationJournal を取得し、Forward に使用する。ポップアップウィンドウ（OKのみ）を表示するサンプルボタンが1つ配置されており、クリックするとポップアップウィンドウが表示される。
ポップアップウィンドウの OK ボタンを押すと、タイトル文字列が変化する。ポップアップウィンドウ（OKボタンのみ）を出す方法ViewModel に InteractionRequest&lt;INotification&gt;  プロパティを定義し、Buttonコマンドなどをトリガにして Raise() する。
Raise() は Action&lt;T&gt; で callback を指定できるので、OKボタン押下後の処理はそちらで行う。xaml側にも下記対応が必要CenterOverAssociatedObject：ポップアップウィンドウを親ウィンドウの中央に表示するポップアップウィンドウ（OK/Cancel）を表示するサンプル25-NotificationRequest に、OK/Cancel 形式のポップアップウィンドウを表示するボタンが追加されたサンプル。ポップアップウィンドウ（OK/Cancelボタン）を出す方法ViewModel対応
25-NotificationRequest とほぼ同じ。OK/Cancelは Confirmed(bool型) で取得できる。xaml対応
先ほどと全く同じ。SourceObjectの指定を変えているだけ。ポップアップウィンドウ（自作View）を表示するサンプル26-ConfirmationRequest に、カスタムポップアップを表示するボタンが追加されたサンプル。カスタムポップアップを出す方法ViewModel対応
26-ConfirmationRequest とほぼ同じ。xaml対応
PopupWindowAction.WindowContent に、自作UserControl (CustomPopupView) を指定する。
ポップアップウィンドウの初期サイズなどは、PopupWindowAction.WindowStyle から指定できます。ポップアップウィンドウ（自作Viewで結果を戻す）を表示するサンプルポップアップウィンドウで選択した情報を親ウィンドウに戻している。
Cancel（非選択）も判別できる。
アイテム選択後に ×ボタンでウィンドウを閉じた場合も、ちゃんと Cancel として扱われる。親ウィンドウのViewModel対応InteractionRequest&lt;T&gt; の ICustomNotification がポイント。ICustomNotification は 自作クラスで（Prism名前空間でない）、26-ConfirmationRequest で出てきた Prism.Interactivity.InteractionRequest.IConfirmation を継承している。SelectedItemプロパティだけを持っており、ポップアップウィンドウで選択されたアイテムを設定/取得できる。親ウィンドウのView対応27-CustomContent と同じ。ポップアップウィンドウの View 指定が異なるだけ子ウィンドウのViewModel対応ViewModel は、Prism.Interactivity.InteractionRequest.IInteractionRequestAware を継承している。ポイントは、IInteractionRequestAware の Notificationプロパティを定義しつつ、バックフィールド(?) ではINotificationを継承した自作の ICustomNotification で受けている点やと思う。プロパティとバックフィールドの型が異なる実装を初めて見たので勉強になった。以下は、各ボタン(Select/Cancel)に応じたコマンド情報の設定後に IInteractionRequestAware インターフェースの Actionである FinishInteraction を実行することで、ポップアップウィンドウを閉じている。子ウィンドウのView対応見た目通りの実装なので割愛。Viewでちらっと出てきたのでメモ。AutomationProperties.AutomationIdは、UIコントロールを一意に識別するためのIDのようです。検索すると色々ヒットしましたが、Microsoft Docs以外の日本語解説が見つからず…Microsoft Docsって少し理解してる状態で読まないと、理解できないイメージがあり敬遠しちゃう…Prism機能ではないので今回は置いときます。UserControlのEventトリガでコマンドを実行するサンプルListBoxが表示されており、選択したアイテム名が下部に表示される。View の InvokeCommandAction によって、ListBox の SelectionChanged 時に ViewModelのコマンドを実行している。TriggerParameterPath で指定されている AddedItems は、SelectionChangedEventArgsクラスのプロパティで、選択された項目を含むリストが格納されている。サンプルでは ListBox の SelectionMode が Single なので、AddedItems は長さ1の配列となるが、SelectionMode を Extended にして Shiftボタン＋クリックなどで複数アイテムを選択すると、選択分のアイテム配列となる。ViewModel の DelegateCommand、配列先頭の要素名を表示している。全部で32項目もあったが『Prismは任せろ！』までの理解度にはならなかった。学習開始前から、モジュールのDisposeについて知りたいと思っていたが、サンプルでは出てこなかった。基本的な操作（子モジュールの配置、画面遷移、ポップアップ）については知れたので、何となくは使えそう。
出力しつつ勉強していこうと思う。Qiitaのおかげで、Markdownの書き方を学べた。


