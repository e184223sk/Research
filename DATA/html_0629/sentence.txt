.NET 5には新しい機能「関数ポインタ」を追加されました。これは、ネイティブ相互運用を改善し、パフォーマンスを上げるために作られました。関数ポインタは下位レベルのデリゲートで、関数呼び出しのより効率的な方法を提供します。既知の方法にSystem.Action&lt;&gt;, System.Func&lt;&gt;といい、System.Delegateといい、どちらもオーバーヘッドがたくさんあります。でも関数ポインタはそういうオーバーエンドがありません。さらに関数ポインタはマネージ関数のみをサポートすることではなく、アンマネージ関数もサポートされています。だからこそ、ネイティブ相互運用を行う場合は、関数ポインタを使用すると非常に便利になります。じゃ、早速始めましょう。関数ポインタの型の形式は delegate* + managed/unmanaged + [呼び出し規則（ネイティブのみ）]+&lt;パラメータリスト（void を使えます）&gt;です。
例えば：[Cdecl] のみならず、[Stdcall]と[Fastcall]と[Thiscall]も使えますよ。まずはネイティブ相互運用を紹介しましょう。C++コードを書けます：関数ポインタを使用する場合は、不安全なコードを許可するが必要です。そのために、プロパティファイル*.csprojに次のコードを追加してください：C#コード：上記のコードは、C# の関数を C++ に渡して、C++ は C# から渡された関数を呼び出します。最後はコードをコンパイルして実行します：出力：ここまで関数ポインタでネイティブ相互運用を使う方法は紹介しました！これはアンマネージ関数と大体同じで、より簡単ですよ。C# コード：コンパイルと実行：出力：Bravo！デリゲートと比較して、なぜ関数ポインタがより効率的ですか？コンパイルされた IL コードを見てみましょう。C# コード：IL コード：IL を見れば理解できるはずです。関数ポインタは冗長オブジェクトSystem.Func&lt;&gt;を作成する必要はなく、関数はcalli 命令を介して直接呼び出すことができます。シンプルなテストコード：結果：予想通り！関数ポインタを使用するとネイティブインターロップはすぐに簡単になります。
さらに、これはデリゲートよりもっと効率的です。こんなに素晴らしい機能があるし、早速.NET 5をダウンロードして新しい関数ポインタの機能を試しようぜ！Improvements in native code interop in .NET 5.0


