More than 1 year has passed since last update.　「Dependency Injection: 依存性の注入」 って、とっても分かりづらくないですか？
　色んなところに解説記事があって、Qiitaでも検索すると沢山見つかりますが筆者は文章を読んだだけでは全然分かりませんでした。
　「直接呼び出すのではなく、インターフェースを介して実装する？」「制御の反転(inversion of control)？ 中から外ではなく外から中？」「サンプルを真似てみたけど複雑な実装している。これ何が嬉しいの？」そんな疑問ばかりでした。言葉は知っているけど使えないってやつです。　ようやく理解できたのは、実際に「あれ？困ったぞ」となって「ここでDIを使うと便利なのか！」と実感してからでした。
　「ここで便利なんだ！」や「こういう時に使うといいんだ！」という使い所が分かると応用が効き、これが本当に理解することなんだなと思いましたので、それを書いてみたいと思います。
　あくまで「使い所の例」ですので、そもそもの概念的なところは他の記事を参照されると良いかと思います。
例：　なお、サンプルはC#で書いていますが、何か一つでもオブジェクト指向言語を学ばれている方でしたら問題なく理解できると思います。
　　それでは明日の天気に応じて出力するメッセージを変えるという機能を例にしていきたいと思います。素直に書くとこんな感じでしょうか。天気の情報の取得はWeatherService()が担当しています。　これのテストコードを書くとすると次のようになりますが、このままですとテストをするタイミングによって結果が変わってしまいます。明日が晴れの時にはテストは成功しますが、雨の時にはテストは失敗します。実行するタイミングで結果が変わるなんて嫌ですね。　また、もし仮にタイミングを合わせられたとしても、GetTomorrowWeather()が出来ていないとテストができません。一人で作っているなら「GetTomorrowWeather()の作成から優先しよう」で解決できますが、大抵の開発プロジェクトは複数人で作っているわけで、「GetTomorrowWeather()の担当者が早くしてくれないと、Messenger()担当者の仕事が進まないんだけど…」という状態になるのは宜しくありません。　何故テストできないのか。
　それはGetMessage()が、WeatherService()に依存しているからです。こいつがいなかったらテストできるのです。「あーあ、いなくならないかな、WeatherService()のやつ」と思いますよね。それを実現する手法が「Dependency Injection: 依存性の注入」になります。　それではWeatherService()にいなくなってもらいます。依存性の解消です。
　もちろん完全にいなくなられると困りますから、直接WeatherService()を呼び出すのではなくインターフェースを通じて結びつけます。　WeatherService()用のインターフェースを作って継承しましょう。　次にこれを使用するMessenger()クラスのコンストラクタにて、外からIWeatherServiceを実体化したクラスを「注入」できるようにします。そしてそれをGetMessage()で使うように変更します。　これでクラス同士が直接の結びつきがなくなり、インターフェースを通しての関係性になりました。もうどこにもWeatherService()クラス自体は出てきていません。いなくなってもらいました。　これでテストが出来るようになります。テストに必要な「偽物(Mock)」を作って外から注入してあげればいいのです。たとえば常に晴れが返ってくるSunnyWeatherService()クラスを作ってみます。もちろんこのクラスは本番のプロジェクトではなく、テストプロジェクト内で作成します。　先ほど作った「偽物(Mock)」クラスを外から注入します。すると、このテストはどんな時でも成功するようになります。　あとは曇りや雨の場合の時のテストも同様に「偽物」のWeatherService()を作成すればテストが可能になります。　ここで「そういう偽物(Mock)を使ってテストになるのか」と思うかもしれませんが、ここではあくまでMessenger()クラスのGetMessage()のテストをしたいだけであり、このメソッドの役割は天気によってメッセージを作り出しているだけですので、これで十分テストになります。GetTomorrowWeather()が信頼が出来るかどうかは、GetTomorrowWeather()のテストで判断すればいいからです。　実際に使用する場合もWeatherService()をMessenger()に注入して使用します。Dependency Injectionの日本語訳は「依存性の注入」ですが1 、個人的には「機能の注入」といった方がしっくりきます。メソッドの中ではインターフェースだけで実装しておいて、実際の機能を外から注入するというイメージです。　かつて疑問符だらけだったと冒頭で紹介した「制御の反転(inversion of control)」ですが、確かにこうしてみると、GetMessage()から呼び出していたWeatherService()が、外から中へという構造になって「反転」しています。　「それじゃあ、テストをしない場合は意味ないのか」と思われるかもしれませんが、それだけではありません。（テストはあった方がいいと思いますが）
　「依存していない」ということは他のコードの変更の影響を受けにくいということになります。　たとえば気象情報を取ってくるサービスを任意で変えたいとします。今までは気象庁から取ってきていましたが、GoogleさんだったりYahooさんだったり、色んなところから取得できるようにしたいというパターンです。
　そういう時はIWeatherService()を継承してそれぞれのサービスを作成します。機能が増えた形ですが、GetMessage()のコードを変える必要はありません。　呼び出す方で、どのサービスを使うかを決定してあげる必要がありますが、GetMessage()の変更は必要ありません。　もし一番最初のコードのように直接参照していたら、次のコードのように呼び出す方とGetMessage()の両方を変える必要があるため、影響が大きくなってしまいます。　機能を増やしたりといった他のコードの変更を受けにくい。つまり変化に強い。これがDIの特徴の一つになります。割と色んなところで訳語が分かりにくいって論争を見かけます ↩


