アルゴリズムは有効な入力に対して、計算能力によって求められた結果を有限な時間のうちに出力することができる、定義の明確な一連の手順のことです。それはつまり有効なアルゴリズムはどのプログラミング言語においても再現することができますし、逆にアルゴリズムを実際の計算機で再現することをプログラミングということもできるわけです。擬似コードはプログラミング言語ごとの特性などを無視して普遍的な理解を共有するためのものでアルゴリズムを抽象化するものです。正しく書かれた有効な擬似コードはどの言語においても再現できます。擬似コードの記法は様々あり、これは一例です。例として、与えられた値の出現回数を数えるコードを書いてみましょう多くの場合アルゴリズムは多くのデータ入力があるため計算能力とその効率の分析はとても重要です
アルゴリズムの効率は二種類あります時間的効率は計算にかかる時間における効率性で入力量に対しての経過時間を分析するものです
それにたいして空間的効率は入力量が記録機器において占める量を分析するものです擬似コードにおける時間的効率は計算処理が行われる単位にコードを分割してそれを計上します$T(n) = c1+(c2+c3)(n-1)+c4 $もちろん擬似コードをプログラミング言語に落とし込んで処理時間を計算することができますが、それは実行する計算機の影響をうけますアルゴリズムを分析するということはアルゴリズムの効率を求めることで、その手法は主に2つあります。入力の大きさは用いられたデータ構造によります。複合的なデータ構造が用いられている場合は要素の数を数えます。離散数学のグラフ理論においてみれば辺や接点を数えます。そのため変数が一つでない場合も多々あります。基本的な関数というのはアルゴリズムにおいて総計算時間に最も影響を与える命令のことです。ソートにおける大小の比較、検索における一致の真偽、などなどアルゴリズムによっては一つでない場合もあります。以下の、配列における最大値と最小値を求めるアルゴリズムがあるとしてこのケースでの入力の大きさは配列Aの長さnであり、基本的な関数は最大比較と最小比較の2つあることになり、その基本的な関数は双方ともに同じ反復の中で行われるということが定義できます。このアルゴリズムにおいての最悪のケースは配列の最初の要素がすでに最大の値だった場合です。その場合2つ目の最小比較がすべての反復で行われるからです。逆に通常のケースは最小比較が行われる回数とそうでない回数が等しい場合です。あるクラス$O(g(n))$が$c\times g(n)$の場合あらゆる関数に対して上界であるとき、関数$f(n)$がクラス$O(g(n))$に含まれていて、そのグラフが$cg(n)$に最も近い場合それが最悪のケースとなります。
漸近記法を用いたMaxMinアルゴリズムの効率性は以下のように書くことができます。たとえば単なる反復のみのアルゴリズム、ただ配列の要素をすべて足すだけなどのものの場合、$O(n)$に含まれていることが想定できます。
もし反復の中にさらに反復があり、それが比較を用いるなど複雑な場合は記述計算が必要になりますが、基本的には内包されている関数から外包の関数へと分析していきます。$O(n) \in O(n^2)$
またif elseの分岐においてはifの方の関数が$O(n)$で、elseの方が$O(m)$の場合、それを外包する反復のアルゴリズムの最悪のケースは$O(Max(n, m))$になります。現実の実行環境ではメモリやCPUの問題で予測とは違う動きをすることは実にありえます。コンパイラの仕様によっては予測より早くなることも珍しいですがありえることですので、実証的な分析もぜひ行いたいところです。実証的なアプローチには様々な目的を設定することができます。主に2つの測定基準が考えられます。論理的分析と同じように入力される変数のサイズと傾向を決定し、基本的な関数を定義します。まず言語を決定し、アルゴリズムをもとにプログラムを作成します。
プログラムの挙動が擬似コード通りになっているかテストを忘れないのが肝要です。
また、経過時間測定用のコードと、基本的な関数を数えるコードは別々で組まれるべきです。
基本的な関数を数えるためのカウンターは適切な位置で宣言されなければなりませんし、それは基本的な関数の数だけ用意しなければなりません。
また、時間測定ようのコードは基本的な関数が実行される直前にタイマーが宣言され実行終了直後と比較されなければなりません。サンプルの入力されるサイズ、変数の値の範囲、関数の実行回数などを考慮して作成しなければなりませんし、プログラムでランダムな入力データを作成する必要があります。サンプルデータによるアルゴリズムの実行結果を記録します。
基本的な関数の実行回数や、経過時間の平均を計算します。結果は表やプロットとしてわかりやすく可視化するのが理想的で、特に散分図プロットとして表されれば、漸近線をにゅうりょくして比較するのが容易です。


