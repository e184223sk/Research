More than 1 year has passed since last update.public static int Add(int cx, int dx, int r8, int r9, int s1, int s2, int s3, int s4) 1のような割とアレなメソッドが有ったとき、cx～r9に対する処理とs1～s4に対する処理で、前者の方がわずかに速かった。但し、今回の検証は、逆アセンブリ眺めていて、ホントに差が出たら楽しいな的な、完全に逆側からのアプローチしてみて、ホントに差が出たね～。うれし～な✨って意味しか無いので、その辺ご了承の程こいつを試してみて差が出るか?と言うことで試したら、以下の結果を得たえらく微妙だけど差が出てるは出てる。ぱっと見た感じ、AddRegの方は、前半分の4つの引数を加算してるし、AddStackの方は、後ろ半分の4つを加算してるので、本来差が出そうにはない。これがなんで差が出てしまうかというと、x64 calling conventionに書いてあるThe first four integer arguments are passed in registers. Integer values are passed in left-to-right order in RCX, RDX, R8, and R9, respectively.　Arguments five and higher are passed on the stack. の通り、引数が整数の場合、最初の4つはレジスタ渡し、それ以降はスタック渡しになるので。で、スタック渡しよりレジスタ渡しの方が速くなるんじゃなかろうか?と適当に考えて適当に試してみたら本当に速かった。今回の検証というか重箱の隅つついてみた結果は重箱の隅つついたらやっぱり差が出た程度の意味しかやっぱり無い。推測も含むけど、この程度の極めて単純な処理であれば、概ね全てかL1キャッシュに乗るのでメモリとのやりとりにはならないだろうし、実際ならないからこそこの程度の差しか出なかったと考えられる。そして、[MethodImpl(MethodImplOptions.NoInlining)]こいつを付けないと、実は全く同じ処理になるwこれは、NoInlining処理しないと極めて単純すぎるためInliningされて未使用変数の除去が発生し、結果同じバイナリになってしまう。逆に、属性無しでもInliningされない程度に複雑な処理であれば、この程度の差は実処理の処理時間のノイズに紛れて多分差異が見いだせないかと。なので、今回の件は、逆アセンブリで推測されることが実際差異として出てくるの?って気になって試したら実際目に見える形で差異が出てきたよていどの話にしかならないんじゃないかなと思います。見る人が見ればこれ見ただけで何やりたいのか、どー言う結論なのかすぐわかっちゃう程度のネタばらしではあるw ↩


