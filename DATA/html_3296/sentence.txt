More than 1 year has passed since last update.C++/CLI はフェードアウトな雰囲気が非常に漂っていますが、過去の資産を継続して使わなくてはいけないなど避けられないケースもまだまだありそうに思います。実際、ネイティブとのバインディングには便利ですからね・・・一方 C# は現在においても革新が続いており、特に C# 7 以降はその改善速度が非常に上がってきています。 C++/CLI は C# (マネージ側) ～ネイティブとのバインディングに使う事が主な用途だと思いますので、実際に使う C# 側から扱いやすいように便利な記述に対応したいと考えるわけです。特に値型の参照渡し関連はパフォーマンスにも影響があるので是非使いたい。ということでどこまで対応できるかやってみました。C# 7 、としていますが C# 7 以上 8 未満のものを扱います。C# の言語拡張は絶えず続いていますが、実際にビルドして出力されるバイナリ (IL) のフォーマットは変わってきていません。 (C# 8 で導入されるインターフェースのデフォルト実装で IL の拡張が入る予定のようです)では言語拡張はどのように行われているかというとといった形で行われています。前者は Awaitable パターンなどです。今回は後者の属性による拡張です。 C# の拡張された言語機能の多くはコンパイルされた結果に属性が付与され、属性が付与されたアセンブリを参照している側からは属性があると、その新しい文法で記述されたものと認識できるので、新しい文法に対応した処理を行うという形になります。有名な例として C# の拡張メソッドを C++/CLI で記述する、というものがあります。 C# で拡張メソッドを定義するには次のように書きます。これを C++/CLI で記述するとこうなります。ExtensionsAttribute という属性が指定のメソッドが拡張メソッドであることを表しているわけです。C# の拡張メソッドに関する予約語のうち IL で表現できないものが属性による付加情報の形で付け足されるので、それと同じ事を C++/CLI で記述すると C# 側もそれに沿った形で参照できるようになります。in 修飾子をつけると指定の引数が参照渡しになります。巨大な構造体を扱う場合、コピーが発生しなくなるのでパフォーマンス面で有利になります。.NET Framework は 4.7.1 以降にしてください (旧バージョンの .NET Framework で使えるようにするのは後述) 。例えば C# でと同じものを C++/CLI で書くには次のようにします。IsReadOnlyAttribute は .NET 4.7.1 で追加された属性です。System.Runtime.CompilerServices.InAttribute と System.Runtime.CompilerServices.IsReadOnlyAttribute を付与し、 C++/CLI のマネージド型への参照を表す % を付けた型にすると C# の in 修飾子と同じ効果になります。戻り値型の ref readonly 修飾子も同じだったのですが、戻り値型に InAttribute の付与が (私が試した限りでは) できませんでした。少々残念。C++/CLI では仮想メソッド (interface, abstract, virtual) でのパラメーターに in 修飾子はつけられないようです。上記のように InAttribute と IsReadOnlyAttribute をつければ一見いけそうに見えますが、 C# からは存在しないメソッドとして扱われます。これは何故かというと、仮想メソッドに in 修飾子をつける場合、そのメソッドには属性に加えて modreq(InAttribute) をつけなくてはならないのですが、 C++/CLI ではこれを付与することができません。は次のようになっています。C# 7.2 の proposal に記載されていました。In addition, if the method is abstract or virtual, then the signature of such parameters (and only such parameters) must have modreq[System.Runtime.InteropServices.InAttribute].C++/CLI で仮想メソッドについては仕様に沿ったコードが出力されないため C# から見る事はできない、ということです。ご注意をは次のようになります。IsByRefLikeAttribute も .NET 4.7.1 以降のようです。readonly ref struct は "IsByRefLikeAttribute" と "IsReadOnlyAttribute" の両方を指定すれば OK です。.NET Framework は 4.7 以降にしてください (私が試した限りでは C++/CLI に NuGet の System.ValueTuple の追加ができなかったため) 。ValueTuple のメンバーは Item1, Item2, ... といった通し番号的で意味のわからないものですが、 C# では名前を付けることができます。下記の場合、 x と y がそれぞれのメンバー名です。C++/CLI で同じことはと記述します。TupleElementNamesAttribute の引数に文字列配列でメンバー名を順番に指定します。お手軽感が完全に損なわれているのとパフォーマンス面で優位性もないので、ここまでするくらいなら C++/CLI でこのようなケースでは専用の構造体を定義した方がベターな可能性が高いと思います。これはあくまで C++/CLI での実装で C# コンパイラが付与するのと同じもの相当の属性を付与することで C# 側から拡張された言語機能として認識させる、というものです。C# であればコンパイラがチェックをした上で属性を付与するわけですが、 C++/CLI はそのような事を理解できないので実装者が正しく記述する必要があります。一方で C++/CLI は文法的にパラメーター定義で明示的に参照かどうかの区別がつくので構造体の防衛的コピーが自動で行われることはないのはいいことかもしれません。これまで挙げた IsReadOnlyAttribute などの新しい属性は .NET 4.7 ないし 4.7.1 で追加されたものです。一方、 C# 7 は .NET 4.6 でも使用可能で、その場合でも in 修飾子は使用可能です。 4.7 じゃないと存在しない属性を使って 4.6 向けのコンパイルができているということになります。では C# コンパイラはどうやっているのかというと、 internal な属性クラスをアセンブリ内に組み込んで、それを参照するようにしているようです。同じことを C++/CLI でもやれば .NET 4.6 世代でも C++/CLI で対応可能になります。C++/CLI の現状、一番つらいところはあたりですね。特に後者はつらい。今後 .NET Core 3 に移行するにあたって、 C++/CLI の mixed mode アセンブリの対応 もする方向のようなので、ビルドしたバイナリの動作は継続できそうですが、コンパイラ等の開発環境はどうなるのかが不透明です。このまま .NET Framework ベースのまま現状維持が有力かな・・・C++ とのネイティブバインディングは C++/CLI に頼らないやり方を確立しておくのがよいと思います。以前書いた記事 (C#からC++のインスタンスメソッドを呼び出す) も是非ご一読ください。


