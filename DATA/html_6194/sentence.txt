More than 3 years have passed since last update.MCP試験 70-483 Programming in C# の学習材料。目次はこちらリソースリークを起こさないプログラムを書く。.NET にはガベージコレクション(GC)機能がある。GC は使われなくなった(どこからも参照されなくなった)オブジェクトを自動的に破棄・開放してくれる。そのためプログラマは通常、リソースの確保・開放を意識する必要はない。外部プログラムと相互運用するために、メモリや Windows オブジェクト(ハンドル)などのリソースを明示的に確保することもできる。ただし、プログラマが明示的に確保したリソースはプログラマ自身が開放する必要がある。もし開放を忘れてしまうとそのリソースはリーク(leak)し、プロセスが終了するまで残り続けてしまう。このプログラマが明示的に確保したリソースのことをアンマネージリソース(Unmanaged Resource)という。通常の .NET オブジェクトはマネージリソース(Managed Resource)という。マネージリソース
- str と str が参照する string オブジェクト
- fs と fs が参照する FileStream オブジェクト
- ptrアンマネージリソース
- fs が参照する FileStream オブジェクト が持っているファイルハンドル
- ptr の値が指しているアドレスに確保されたメモリGC は自動で実行されるが、明示的に実行させることもできる。ただしGCはプログラマより賢いので、特別な理由がない限り実行させる必要はない。アンマネージリソースを確実に開放するための仕組みに、IDisposable インタフェースとデストラクタがある。プログラマが明示的にリソースを開放するためのDispose()メソッドを持つインタフェース。ちなみにDispose()メソッドは、複数回呼ばれても問題が発生しないように実装しなければならない。デストラクタは、オブジェクトがガベージコレクタによって破棄される際に自動的に実行される処理を定義する。この処理のことをファイナライズと言う。内部的には、デストラクタは Object.Finalize() をオーバライドする。なお、Finalize() メソッドをプログラマが明示的に呼ぶことはできない。ファイナライズの実行はコストが大きので、プログラマが明示的にDispose()を実行した場合はファイナライズ処理を実行させたくない。GC.SuppressFinalize()を使うと、ファイナライズの実行を抑制できる。デストラクタと IDisposable の両方を実装すると、下記のようになる。（お決まりのパターン）この Dispose パターンを実装することで、アンマネージリソースのリークを防止できる。
- プログラマが Dispose() を呼ぶと、アンマネージリソースが開放される。ファイナライズは実行されない。
- プログラマが Dispose() を呼び損ねた場合、ファイナライズが実行されてアンマネージリソースが開放される。オブジェクトを使い終わったら破棄したい。例外が発生したとしても確実に。ちなみに Stream や TextReader/Writer の Dispose() は Close() と等価。オブジェクトが IDisposable インタフェースを実装している場合は、上記の try-finally と等価なコードを using ステートメントで短く書ける。基本的には using ステートメントを使うべきだが、もしサードパーティのライブラリが IDisposable を実装していない場合は try-finally ステートメントで書くことになる。Fundamentals of Garbage CollectionCleaning Up Unmanaged ResourcesSafeHandleusing ステートメント (C# リファレンス)メモリ管理 - ++C++; // 未確認飛行 CIDisposable とデストラクタを正しく実装したクラスを使用する場合、必要のないリソースは GC が開放するのでリークは発生しない。これは本当？アンマネージリソースを持たないクラスはデストラクタを定義すべきか否か。また、その理由。下記のうち、GCが実行されても解放されないリソースはどれか。


