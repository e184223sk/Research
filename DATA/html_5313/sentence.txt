More than 3 years have passed since last update.UnixTimeは1970年1月1日0時0分0秒からの秒数なので、C#からUnixTimeへの変換は1970/1/1 00:00:00を引いてから秒に変換すれば良い。C#の時間は単位が100ナノ秒なので、10000000(=10*1000*10000)で割る。UnixTimeからの変換は逆の操作になる。解説はこれですべてなのですが、C#で日時を扱うとき何クラスを使うべきか、という問題があります。結論は常にDateTimeOffsetを使っておけ、です。理由はDateTimeは機能が不足していて使えないからです。という感じなので、いちいちKindプロパティの値を気にして使用しなけらばならないし、Kind.Unspecifiedのときどう扱ってよいか分からないし、特に最大の問題はKindプロパティの認知度が低くて、バグを誘発しやすい、ということです。そういう訳で、DateTimeOffsetを使おう、ということです。プログラムで日時を扱うとき、一番多いのは現在時刻をどう取得するかですが、次に多いのは文字列から/への変換でしょう。文字列 → DateTimeOffset が、Parse()メソッドとParseExact()メソッドがあります。Parse()は書式を自動的に判別して解析してくれるのですが、日本で一番使われているだろう、年月日を数値で並べた書式（たとえば、20180102131415）は、判別してくれませんでした。そのため、ParseExact()を使うのですが、例のごとく引数に書式指定をします。書式一覧については、コピペしてもしょうがないので、MSのドキュメントを参照してください。（そのうち表で書くかも）ちなみに年が２桁の場合は、29(2000年扱い)と30(1900年扱い)で境界があります。ToString()の引数で、書式指定ができます。書式についてはMSのドキュメントを参照してください。※「午後12時」になってしまう。「午後0時」にはできない。もはやUnixTimeとなんら関係もないですが、うるう秒についても補足をしておきます。まずC#のプログラム内では、うるう秒を考慮する必要はありません。なぜなら、Windowsにはうるう秒が無いからです。DateTimeOffsetのドキュメントを見ても、秒がとりうる値は0～59になっています。（ちなみにWindowsの世界でうるう秒がないのは、多分MSがうるう秒導入反対の立場をとっているからだと思います）では、実際うるう秒があった場合どうなるでしょううか。これはコンピューター間の時刻同期がどうなされるか、で決まるのですが、時刻同期はたいていNTPを使って行われます。そしてNTPはNTPサーバーとNTPクライアントの２つの立場があります。NTPサーバーに合わせるだけ。NTPサーバー1時間を加える、という処理を例にすると、Windowsの世界ではうるう秒が無いので常に1時間＝3600秒であり、問題がありません。むしろJava(Linux系)の場合、3600秒と3601秒の場合があって、困ることになります（そのため、仕様書に「1時間後」ではなく「3600秒後」と書くようにする）。WindowsとLinuxが混在しているシステムでは、１秒ずれることがあるかもしれない、ということを意味します。これはNTPサーバーがLinuxの場合だけ考慮すれば良い、ということでは無いです。例えば、１時間後にファイルを送信する、という処理があった場合、Windowsでは3600秒後に送信するが、Linuxでは3601秒後を期待していた、ということがあるからです。とは言うものの、現実に問題が発生するかと言われると、タイムスタンプが超重要なシステムでも無い限り、私の経験では問題が発生したことはありませんでした。ただし今後はどうなるかは分かりません。現在は、まだ１秒のずれがシステムに大きな問題を起こすほど、シビアな時間管理が必要ないのですが、未来については、もしかしたら１秒がシステムにとって重要になるかもしれません。日付について書かれたサイトは数多いですが、多分このスライドショーが一番分かりやすいです。


