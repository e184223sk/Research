More than 1 year has passed since last update.出張で無事死んでいました...
記事いっぱい書いていかないと...オセロって使うもの自体は少ないんだけど、満たす要件だったりロジックが複雑だったりするのでわりと頭の体操によくやったりします。(書くことないのでこれを書きます。)オセロの説明は言うまでもないと思うので省略まずは、xaml側から。
こちらは8×8の緑に黒線のボードを用意してあげて、Passボタンと現在のターン表示と一応黒と白の現在の数を用意してあげましょう。コード側でやってあげたほうがよかったかもしれないですが、面倒なのでxaml側でばーっとやっちゃいました。
コード側ターンの状態と、ボードの情報をMainWindowクラスで保持。ボードの情報に関してはint型で保持し、
1は黒、0はなし、-1は白とする。InitではBoardInfoにすべて0を入れてから、4,4に黒、4,5に白、5,4に白、5,5に黒を入れてやる。SetBoardInfoは4,4,1であれば[4,4]に黒を入れてやる、の意。
わざわざメソッド化をしてあげる理由は配列が0から始まるが、見かけ上は1からはじまるため。
(ここは別にTag付けを0から始めればよかったか)
ReflectBoardInfoToXamlメソッドはBoardInfoの情報をxaml側に反映させてあげるメソッド。基本的に最初のforeachの終わりまでが反映作業。
foreachのところのChildrenに関しては子要素を取得。
なので、全体のStackPanelの子要素を取得して、8枚のStackPanelを取り出す。
その後、各StackPanelからButtonを取り出してそこのContentに情報を入れていく。
その後の勝ち負けの処理を入れるのはforeachですべての情報を回してるここでやると便利なため。オセロのボタンをクリックしたときの処理。CheckValidBoardInfoは挟めることができたらtrueを返し、できなければfalseを返す。
まぁなので名前としてはTryAndReverseみたいなの方が妥当だろうか。
そして、無事ひっくり返すことができたあとに、Row,Colに自分の石を置き、ターンを変える。そしてオセロを実装する上で一番の面倒なところが石を挟んだらひっくり返す処理だろう。
石を挟むという言葉もなかなか抽象的である。なので、より具体的な言葉で言ってあげるならば座標(x, y)がzであり、(x + a * 1, y + b * 1)から(x + a * (n - 1), y + b * (n - 1))が-zで(x + a * n, y + b * n)がzである場合(x + a * 1, y + b * 1)から(x + a * (n - 1), y + b * (n - 1))をzに変更する。(0 &lt;= x &lt;= 8, 0 &lt;= y &lt;= 8, a,b は1,0,-1のいずれか。2 &lt;= n &lt;= 7)という言葉になる。
まぁ簡単に言えば方向と挟む数と挟む回数の順番でfor文を回してやり適宜チェックを行ってやればよい。
それをコードで表すとという風になる。
全体のコードを示すとという感じになる。


