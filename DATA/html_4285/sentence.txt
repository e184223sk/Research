More than 1 year has passed since last update.仕事をしている中でとても気になるのが「いま話をしたい人が席にいるかどうか」だと思います。弊社では Slack を使って仕事のやり取りをしていますが、問いかけになかなか反応しないときに、反応できない状態なのか、そもそも席にいないのかわからないままもやもやすることってよくあるんじゃないかなと思います。そこで、「いま席にいるか」を問いかけると返事してくれるシステムを作りました。サーバー プログラミングのお勉強もかねてます。Olkar (おるか) っていいます。名前付けは適当です。
状態管理と Slack BOT を兼ね備えたサーバー システム、状態を通知するクライアント システムの 2 つをあわせたものです。サーバーは ASP.NET Core + SignalR + C# で作っていて、OS は Debian Stretch です。

クライアントとサーバーとの間で SignalR によるリアルタイム通信が実装されています。何も考えずに ASP.NET Core Web アプリケーションとしてプロジェクト作りました

SignalR での実装に参考にしたのは Microsoft の公式ドキュメントですが、チュートリアルでは Web ページでも動作するための準備も含まれていて、今回はページとしてリアルタイムで何か見ることはしないので、unpkg での SignalR クライアント ライブラリの追加は省略します。あとはしこしこと実装するだけです。
Hub には状態を変更するためのメソッドと、現在の状態を知るためのメソッドを用意しました。ここで OlkarStatusModel は状態を管理するクラスのことをさします。このままだと、接続しているインスタンスがいなくなると状態が破棄されてしまうので、DI として登録しておき、いつでも状態を呼び出せるようにしておきます。
登録は Startup.cs でできます。呼び出したいときは、コントローラーとなったクラス (今回は OlkarHub) のコンストラクター引数に、呼び出すクラスを書いておくとインスタンスを挿入してくれます。SignalR を有効にするため、Startup.cs にいくつか追記します。これで SignalR 側の実装はだいたい終わり。Nginx と連携したリバースプロキシの設定や、https 接続の有効化、実行の方法はだいたい Microsoft のドキュメントを見るとわかるので省略します。めっちゃめんどくさかった
実装には この記事がいろいろ参考になりました。Slack に対してお伝えするためのルーティングは、「属性ルーティング」と呼ばれる仕組みで実装しています。Slack が呼び出し先として認知させるためのベリファイを実装します。送られてきたデータのうち Challange を何らかの形で返すようにします。JSON のパースはおなじみ Json.NET です。request にやってくるデータが時と場合によってバラバラなので、JsonConvert.DeserializeObject&lt;T&gt;(string) ではなく JObject として拾って処理しました。中身が確定したらその都度変換しています。あとは参考にした記事通り、追加したい Workspace に対して App を新規追加し、Event Subscriptions の Request URL にアドレスを記述して問題ないかを確認します。「Verified」が出れば OK

今後はこのアドレスに対していろいろとメッセージが降ってくるようになります。さきほどの SlackRequest メソッドにたくさんのメッセージがくる中、type が event_callback になっているものに対して処理を掛けます。
BOT に対してのメンションが取りたいので、Request URL を入れたページの下の方にある「Subscribe to Bot Events」で、メンションを受け取るための app_mention を有効にしておきます。DM でも何か欲しい場合は message.im も有効にしておくとよいでしょう。
event_callback としてやってきたデータには、event と呼ばれる階層ができています。そこの type を見て処理を書けば OK です。さきほど app_mention を有効にしたので、 "type": "app_mention" と書かれたデータがやってきます。message.im も有効であれば、"channel_type": "im" も飛んできます。あとはパースして処理してやれば OK です。BOT の応答にも返事しないように、 "subtype" : "bot_message" は排除します。Slack へのメッセージの送信は chat.postMessage に POST すれば OK です。「OAuth &amp; Permissions」で拾ってきた BOT 用 OAuth Token をパラメーターに入れておくことで BOT の投稿として処理されます。
ユーザーへの返事は &lt;@USER0123&gt; のように、ユーザー名ではなく専用のユーザー ID に置き換えますが、その辺は処理するときに受け取った情報でどうにかなるのであまり気にしなくていいでしょう。これであらかたおわったはず。記事を書いてたらだんだん疲れました
常駐させておきたかったので WPF で実装し、通知領域に生きてもらうようにしています。
クライアントには SignalR をどこからか入れる必要があるので、Nuget で Microsoft.AspNetCore.SignalR.Client を探して入れておきます。Microsoft.AspNet.SignalR.Client もありますが、こっちは今回使いません。今回は「PCがロック状態になったかどうかで在席・離席を管理」したかったので、ロック状態を検知できるようにします。
Microsoft.Win32.SystemEvents.SessionSwitch イベントでそれを拾うことができます。あとは Microsoft のドキュメントを見ながら Hub を実装すれば OK です。サーバーでは状態の更新のために SetStatus を準備したので、というように実装しておきます。
状態のコールバックは Status として用意しているので、などと書いておけば OK です。 Status は列挙型で、状態を表す値を入れています。SignalR で実装しているので、ほかのデバイスとも連動して状態をリアルタイムで表示できるようにしたいです
今は PC がロックされたかどうかでしか見ていませんが、ほかの状態を検知して、完全自動化を目指したいですお粗末様でした


