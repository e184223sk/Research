More than 3 years have passed since last update.これは C# Advent Calendar 2017 の17日目の記事です。
昨日は @nitacore さんの C#でのRPCのインターフェース表現の一例 でした。TaskとReactiveExtensions(Rx)は共に非同期処理を実現するための機能として各所で紹介されています。
特にUnity3DにおけるC#だとUniRxのお陰で非同期処理といえばRxという印象が強いです。
しかし、Unity2017では.NET Framework4.6が使えるようになり、Taskの利用もできるようになりました。
そこで今回はTaskとRxを組み合わせ、より便利に使う方法を考えてみたいと思います。まずTaskとRxそれぞれの特徴を簡単に確認してみましょう。語弊アリアリの状態で端的に言い表すとすれば、
Taskは処理の流れを記述し、Rxは処理のトリガーを作成できます。
勘違いされやすい(と個人的に感じている)のですが、
TaskとRxは択一的なものではなくそれぞれ別の役割のものなのです。
つまり、組み合わせると最強！TaskとRxを組み合わせるにあたり、それぞれの相互変換を行う必要があります。
それを行ってくれるのがTaskObservableExtensionsです。
(UniRxにももちろんあります)他のクラスでのイベントがIObservableの状態で公開されていることは多々あると思います。例えばデータの更新を待ちたい場合には以下のように記述できます。
(ctはCancellationToken)IObservableでイベントを公開しているものとしてはUIクラスが多いでしょう。
例えばキャンセルボタンによる処理のキャンセルを行いたい場合は以下のように記述できます。スレッドセーフでない処理を行いたい場合にlockやSemaphoreSlimで排他制御を行うことがあると思います。
しかし、何らかのRxのイベントをSubscribeした中でそれを行いたい場合など、
async/awaitな処理を記述するわけにはいきません。
(asyncなラムダを渡すことは可能だが、例外のハンドリングができなくなるため)
そんな場合には処理をキューイングする部分と、それを受け取って処理する処理ループに分割することで
同期的なデリゲートの中からでも非同期な処理をキューイングすることができます。例えば以下のようなクラスを用意します。使う側では以下のような感じで呼び出せば簡単に排他制御することができます。ライブラリを使用する際にコールバック(デリゲート)を登録する必要があるものが存在します。
特にiOS上のプラグイン(ネイティブDLL)の呼び出し時などは
MonoPInvokeCallbackAttributeの指定とともにstaticメソッドである必要があるため
Taskの途中で処理を待ち合わせするのが困難です。
そこで、コールバックメソッドでイベントを発行してそれを待ち合わせすることにより
async/awaitな処理の記述をすることができます。例えば以下のようなDLLがあったとします。ここで渡すコールバックはstaticである必要がある場合は以下のようなコードを記述する必要があります。使う側では以下のようにasync/awaitなコードが記述可能です。ちなみに単純にデリゲートを渡すだけであればTaskCompletionSourceを使えばどうにでもなりますが、
GCによって解放されてしまう可能性がある点に注意する必要があります。このようにTaskとRxを組み合わせることにより、多彩な操作を行うことができます。
ぜひ組み合わせて使ってみてください。明日は @usamik26 さんの Moq : Mocking Framework for .NET です。


