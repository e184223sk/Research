More than 1 year has passed since last update.dotnetプロジェクトを作るにあたり、多くの人はIDEを用いて開発していると思う。しかし、以下のように、IDEでは面倒な作業はどうしても存在する。また、CI/CD等を使用する場合に、シェルスクリプトの直接実行に頼ると、プラットフォームの違いを意識する部分が多くなり、ビルドスクリプトが複雑になりがちになる。
dotnetならMSBuildがあるじゃないかという意見もあるだろうが、MSBuildはスクリプトを書くのに向いていないツールなので、複雑なことをすると非常に辛くなる。そこで、それらの問題を解決するために、Cake Buildというツールを紹介する。
F#erな人のために、FAKEなるツールもあり、アドベントカレンダーで記事にもなっているようなので、
興味のある人はこちらも見てみるといいかもしれない。以下のような特徴を持つ以下のいずれかが必要まず、cakebuildの実行ファイルをプロジェクトに導入する。
インストールはいくつかの手段がある。公式推奨の方法で、shスクリプトで実行可能なbuild.sh、またはpowershellで実行可能なbuild.ps1が公式より提供されている。
やっていることとしては、CakeBuild実行ファイル本体のDLと、実行ファイル本体に引数を整理して渡す等。利点としては、辺りだろうか。後述するdotnet toolとは別に衝突しないので、開発マシンはbuild.ps1、CI/CDではdotnet toolというように両方併用するのもいいかもしれない。欠点としては、辺り。開発環境であればほとんど障害にならない程度ではある。以下のURLから実行スクリプトをcurl等でDLする。やってることはあくまで本体のDLと実行ファイルへのラッパーで、サイズも大きくはないので、ソース管理に追加することを推奨する。なお、build.ps1については、monoとpowershell6以降があればlinuxでも動いたりする(macでは未検証)。build.sh,build.ps1を導入する方法は、OSごとに実行スクリプトが異なることになるので、CI/CDで回すときには面倒な場合も多い。
そこで、dotnet global toolを導入して実行するやり方がある。
なお、実行にはdotnet-sdk 2.1以降が必要。上記dotnet global toolの導入の応用で、プロジェクト配下のフォルダにdotnet global toolの実行ファイルを入れる。
実行にはdotnet-sdk 2.1以降が必要。dotnet-sdk-3.0から新しく導入された機能で、dotnet global toolをプロジェクトローカルに導入する方法。
実行時コマンドが冗長になるが、以下の利点がある。なお、実行にはdotnet-sdk 3.0以降が必要。初回インストールは以下のように行うことができる2回目以降、例えばCI/CDで使う場合は、を実行することで、dotnet tool run dotnet-cakeが可能になる。
なお、dotnet-sdk 3.1以降ではtool run部分の省略ができるようになったようなので、の三通りの実行の仕方ができるようになった。build.ps1やbuild.shを使う場合、実行時にアセンブリをダウンロードして展開する。
その時にデフォルトで格納領域に使われるのがtoolsフォルダなので、ソース管理ツールを使用している場合、必ずtools/*は除外パスに指定しておこう。
ただし、後述するが、補完はtools/packages.configが必要なので、tools/packages.configは除外から外しておこう。
まとめると、以下のような設定となるcakebuildが実行できる状態になったら、実行スクリプトを記述する。
実行スクリプトは、通常.cakeという拡張子で、更にbuild.cakeがデフォルトで最初に解釈されるファイルになるので、最初はbuild.cakeファイルを作成する。
例として以下のように記述する。詳しい構文は、公式ドキュメントを参照CakeBuildでは、#で始まるプリプロセスディレクティブで外部スクリプトの読出しや、外部パッケージの使用ができる。
詳しくはプリプロセッサディレクティブに関する公式ドキュメントを参照。以下、よく使うものについて記述する。大規模なビルドに対応するため、cakebuildではスクリプトファイルの読出しもサポートしている。
cakeファイルに以下のような記述を追加する。なお、ロードは書かれた順に上から実行されるので注意。
面白いところでは、nugetパッケージからの読出しもサポートしている。
以下のように記述する。cakebuildでは、nugetパッケージを使って拡張を実現している。
拡張を使用するには、以下のように記述する。具体的に何を指定できるかについては、CakeBuild公式リファレンスが詳しい。
また、Jil等の通常のnugetパッケージをスクリプトの中で使う場合も、#addinディレクティブを使用する。チュートリアルにもあるように、実行時に引数を受け取る場合、
var arg = Argument(argname, defaultValue);をグローバルに追加するのが手軽と言えば手軽で、チュートリアルでも使われている。
しかし、規模が大きくなり、複数ファイルに分割する状態になった場合、グローバルに変数が存在するのは都合が悪いと言えば悪い。そこで、Setup&lt;T&gt;(Func&lt;ICakeContext, T&gt; f)で、渡すパラメーターを初期化すれば、Task("t1").Does&lt;T&gt;(p =&gt; Information($"{p}");のようにして、パラメーターを外部から受け取ることができ、かつグローバルにインスタンスを置くこともなくなる。コード例は以下スクリプトを作成したら、cakebuildのコマンドを実行する。
build.ps1であれば、./build.ps1 -Target [ターゲット]のように実行する。
dotnet-cakeで実行する場合は、dotnet-cake -Target=[ターゲット]のように指定する。
build.ps1と若干仕様がことなるので注意。
読み込む.cakeファイルは、デフォルトではカレントディレクトリのbuild.cakeが使われるが、ファイルを指定する場合は、
dotnet-cake path/to/script.cake ....のように指定する。個人的に筆者が良く使っている機能について記述する例えばSystem.IO.Path.Combineのようなもの。cakebuildではFilePathとDirectoryPathでクラスが分かれているので注意。
FilePath.FromString(path)またはDirectoryPath.FromString(path)でインスタンスを作成し、Combineでつなげていく。
例:また、フォルダ以下全てのファイルのリストを取得したい場合、GetFilesを使用する。Processモジュールを使用する。
基本的には実行ファイルパスと引数を使うことになるだろう。DotNetCoreモジュールを使用する。大体DotNetCore[コマンド]という構成になっている。MSBuildモジュールを使用する。オーバーライドがいくつかあるが、
結局MSBuildSettingsを渡す所に集約するので、今回はこれについて書く。VS付属のものか、msbuildコマンドにパスが通っていれば、そちらを使用する。
dotnet-sdkに付属のmsbuild(dotnet msbuild)を使用したい場合は、DotNetCoreMSBuildを使用する。パラメーターは多いが、よく使うのは以下。ビルド成果物等をzipに纏めたい場合は、Cake.Compressionモジュールを使用する。とりあえず良く使うのはフォルダごとアーカイブするパターンだろうか。
ただし、これで作成したアーカイブはルートディレクトリを取り除いた状態で作成されるので、うっかり展開するとカレントディレクトリにファイルをぶちまけてしまう可能性があるので要注意以下の条件を満たすことにより、vscodeで補完を効かせることもできる。普段はIDEで開発してれば良いのでそれほど使う部分もないかもしれない。
また、やはりシェルスクリプト等に比べると冗長になる部分は否めないため、
単独のcsprojしかないような場合だと、割に合わない部分もあるかもしれない。
それでも、ある程度の規模でCI/CDを回す時などは、プラットフォーム間の差異をある程度吸収できるため、非常に役に立つツールだと思う。機能的には基本的な部分しか書いていないため、気が向いたらまた別の記事を書きたいと思う。


