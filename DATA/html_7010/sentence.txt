More than 3 years have passed since last update.まずは、与えられた数(long型)を力ずくで強引に素因数分解するプログラムを書いてみました。Enumerateを呼び出すと、素因数分解した結果である素因数が列挙できます。しかし、このコード、大きな素数を与えた場合、めちゃくちゃ遅いです。
そこで、少し改良したのが次のコードすこし工夫して、単に、2,3,4,5,6,7...と順番に割り算をするよりは効率よく素因数分解するようにしています。まず、31までの素数で割り、それ以降は、30m+7, 30m+11, 30m+13, 30m+17, 30m+19, 30m+23, 30m+29, 30m+31 の数で割っています。mは整数です。30m+2, 30m+3, ..., 30m+8, 30m+9, 30m+10, 30m+12 などは、素数でないことが明らかなので対象から除外しています。そのため、素数でない数でも割ることにはなりますが、単純なコードよりもすこし効率良く素因数分解できます。ただ、大きな素数が含まれる数に対しては、無意味な試し割りが何べんも行われるため、ほんのわずかに速度向上しただけでした。ちなみにこのロジックは、ミラー・ラビン素数判定法による素数判定メソッドの中で示した力技のメソッドIsPrimeBruteforceと同じ考えで書いたコードです。もっと、速くする方法は無いのかと思って調べたら、ポラード・ロー素因数分解法というのがあることを知りました。そこで、wikipediaのポラード・ロー素因数分解法 のページに書いてある通りに書いてみたのですが、どうも結果が正しくありません。良く良く読むと、与える値は素数以外が大前提で、素数以外を与えても失敗する(素数でない因数を見つけてしまう)場合があると書いてあります。ということで、そのあたりを改善したコードが次のコードです。
前の２つの方法に比べると、圧倒的な速さです。IsPrimeメソッドを、ミラー・ラビン素数判定法による素数判定メソッドで示した最終版のメソッドに置き換えれば、もっと速くなると思います。使い方はこんな感じ以下、実行例です。この記事は、Gushwell's C# Programming Pageで公開したものを加筆・修正したものです。


