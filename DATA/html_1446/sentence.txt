More than 1 year has passed since last update.初めて書く記事ですのでお見苦しい点があると思います。
そのため温かい目でご覧ください。自分が認識しているのは標準ライブラリはこんな感じです
今回は 1 のRefrection.Emitを使いますこのようにRefrection.Emitでは古いバージョンで動かしたい！.netの技術を深めたい！自作の言語を作りたい！コンパイラを作りたい！といった方にお勧めです。しかしながら、簡単にコード生成をしたい！速度はどうでもいいからコードを生成を手っ取り早くやりたい！といった方にはCodeDOM、Expression.Treeをおすすめします。今回は初回ですので、HelloWorldをしてみます
今回生成するファイルは以下の構文と同じ意味になります環境はVS2019 .NET Freamwork4.7.2で、コンソールアプリケーション(.NET Freamwork)です
.net coreについては一部動かないため方法が見つかるか、機能が追加されるまでおまちくださいこれでHello Worldを出力するexeファイルを出力します
出力先は実行ファイルを置いたパスに出力されます
8行目AssemblyBuilderを宣言するとき、引数にパスを追加することで出力先を指定できます。当たり前のようにプッシュとかポップとかって言ってますが、.netはレジスタではなくスタックで実装されています。またILはそのまま変数から呼び出すことができず、スタックに入れてから使う必要があります。
pushではスタックに上から入れます
popではスタックの値を上から取り出します
イメージでは本を積んで下から取り出せないようになっている感じです。
また、CILの命令はOpCodesというClassに含まれているフィールドで構成されています。それに、CILではスタックにポップ、プッシュするとき型によって変わります。また、実行命令については以下のサイトをご参照ください
OpCodes クラスDeveloper Command Promptでを実行することでIL Dasmが開かれます
そこに実行ファイルをドラッグアンドドロップで置くことでCILを見ることができますCIL構文こうなってたらちゃんとできてます。今回はConsole.ReadLine()を追加していないので、結果を見ることができないので
コマンドプロンプトで実行する必要があります。
実行したら以下のように表示されます。
これが表示されたら成功です。最後まで読んでいただきありがとうございます。
今回は初回ですが気が向いたら第二回以降も書こうと思います。
次回をするとしたら、staticメソッドの生成と、呼び出しについてやります。
また、番外として命令表をわかりやすくまとめたいと思います。


