More than 1 year has passed since last update.複数のドット絵オブジェクトで構成されたゲームシーンで、マウスでクリックした指定座標位置にあるオブジェクトを、ピクセル単位で正確に判定したいと思いました。また判定で見つけたオブジェクトをハイライト表示（色フィルターや輪郭を付けたり）したいと思いました。これまでの記事で、ドット絵を深度バッファ付きで描画して、Deferredをカスタマイズして昼夜画像をそれぞれ異なるRenderTargetに同時に書き出し、夕方アニメーションが出来るようになりました。
この時ついでに、オブジェクトごとにIDColorなるものを割り当て、それを別のRenderTargetに書き出して、IDカラーマップ画像を作りました。このIDカラーマップ画像から指定座標の色を読みだして、IDColorが一致するオブジェクトを見つければ、ピクセル単位で正確な判定ができるはずです。
ご存知の方には今更ですが、Unityでマウスでオブジェクトを選択したい場合などには Ray/Raycast とColliderを使うのが一般的だと思います。
参考：【Unity】オブジェクトをタッチしたことを判定する方法【2D・3D】しかし、この方法だとテクスチャの透過ピクセルを無視できないので、複数のオブジェクトが重なっている場合には正確な判定が出来ません。もしやるなら、Raycastで見つけたオブジェクトからテクスチャのUV座標を逆算して、その位置のテクスチャーが透過色かどうかを調べる必要があります。もし透過色だったらさらに奥のオブジェクトにRayを飛ばしていって、透過色でないテクスチャに当たるか、何も当たらなくなるまで繰り返す必要がありそうです。これはどう考えても面倒くさい実装になりそうだし、テクスチャのピクセルを読むためにはテクスチャをRear/Write Enadableに設定する必要があるし、パフォーマンスも悪そうだと思いました。先に書いたように、描画オブジェクトごとにIDColorを割り当て、それをメインのフラグメントシェーダーで通常映像と同時に別のRenderTargetに書き出して、IDカラーマップ画像を作れば、そこから指定座標の色を読み込んで、スクリプト側でIDColorに一致するオブジェクトを探す方が、必ず一度で済むし、コードも単純で正確で速い（※計測してないので、憶測ですが）でしょう。さらにIDカラーマップ画像は、特定のオブジェクトをハイライト表示（明るく色をつけたり、輪郭線を付けたり）するときにも使えて一石二鳥です。IDカラーマップを描きだす部分は、冒頭にもリンクを張った前回の記事で詳しく説明してますので、よろしければご覧ください。 Deferred レンダリングをカスタマイズして昼夜画像をそれぞれ異なるRenderTargetに同時に書き出すついでにIDカラーマップも描きだしてます。参考までに、カメラに表示されるシーンの色を取得するのは、下記リンク先の内容ほぼそのままで出来ました。
unity　マウスクリックした部分の色を抽出する｜teratail問題はどうやって特定の G-Buffer の内容を取り出すか・・・
ヒントは前回の記事でも引用したこちらの記事にありました。
UnityのDeferredでCommandBufferを利用してGBufferをいじってみるCommandBuffer なるものを使えば、G-Buffer を RenderTarget に指定するのは容易そうです。しかも CopyTexture などという、まさにうってつけのメソッドがありました。二つの記事を参考にできたのがこちらです。色が取得できたなら後は難しいところはありません。シーン中のゲームオブジェクトから同じIDカラーを持つShedオブジェクトを見つけます。本格的に使うなら、毎回全検索せずにハッシュテーブルなどでIDカラーとオブジェクトの紐づけを管理する方がいいのでしょうが、今はとりあえず妥協してます。ところが、これでは上手く同じIDカラーを見つけられない場合があることがわかりました。
なぜ見つからないかと言えば、シェーダーに指定した色と、RenderTarget から取得した色が違うからで、どうやらガンマ補正が影響してることがわかってきました。そこで、ガンマ補正を元に戻す方法を検討してみました。前述の公式ドキュメントを見るとリニアライティングに変更すればいいのかな？とも思いますが、設定が面倒で制約も多そうなので躊躇われます。
そこで、ググって見つけた記事（※１、※２）を参考に試行錯誤した結果、以下のようにしたら（少なくとも今までうまく一致しなかったケースにおいては）色の違いがなくなりました。ファイル全体うーん、なんでガンマからリニアの変換だけじゃ足りないんですかね？sRGBってなんなの？なんか直感にそぐわない変換式で困惑しました。
それでなくとも、IDとしての性質上、少数部を超える誤差は致命的なので、powとか使ったややこしい計算が本当にどんな色も誤差なく逆変換できるのか心配です。・・・しばらく思い悩んでいたら、はたと気づきました。
そういえば法線マップはVectorを画像化しています。別にVectorを色として描きだしてもいいんじゃないの？そうすればカラースペース変換から逃れられるんじゃないの？まず、シェーダーのプロパティを Color から Vector に変更しました。視覚的に確認したり、16進数で指定するのに都合がいいのでゲームオブジェクトにつける Shed コンポーネントに Color32 型の IDColor フィールドを追加して、 Start() でシェーダープロパティーを設定するようにしました。このクラスはエディタ拡張使ってるので、あわせてエディタクラスも修正（単にフィールド追加しただけ）。#000001 とか #FFFFFE みたいな極端？な値も試してみましたが、うまく判定できてるようです。
次に、選択されたオブジェクトをゲーム画面上で色や輪郭を付けて、わかりやすく目立たせるようにしたいと思います。IDカラーマップを参照して、指定した値に一致する場合にのみピクセルの色を加工したり、境界部分をハイライトカラーで塗りつぶしたりしてみます。とりあえず、マウスクリックしたオブジェクトをハイライト表示させてみますが、仕組み的には目立たせたいIDカラーをシェーダー渡すだけなので、応用すればゲームイベントが発生してるオブジェクトは別の色でハイライト表示したり（しかも同時に複数選択も）、できるようになるはずです。ハイライト効果の描画はビルトインの Deferred Lighting を置き換えたシェーダーでやりますので、通常の方法ではプロパティー設定ができません（少なくとも私が調べた範囲では）。ですのでちょっとオーバヘッドが気になりますが、SetGlobalVectorで全シェーダーからアクセス可能な変数として登録します。ファイル全体最初の行は、初期化時に無選択状態にリセットするものです。黒#00000000はIDカラーとして使わないという自分ルールを設けました。idCol と normal の取得先のGBufferが変わってるのは、元々指定を間違ってただけです（まだ使ってないので気づかなかった）。それ以外の重要なところを以下に説明します。まず、選択したIDカラーを受け取る HighlightID と、ハイライトカラーを設定する HighlightColor 変数の追加です。ビルトインを置き換えたシェーダーのプロパティーをスクリプトから設定する方法はわかりませんが、初期値を入れておくことができるのでプロパティーにも記述してます。
他方 HighlightID は SetGlobalVector から設定するので、プロパティーに宣言してはいけません。プロパティーに宣言した変数は SetGlobalXxx 系メソッドによって反映されませんので注意。次にIDカラーマップの指定色との境界検知のメソッドです。 IsHighlightEdge は境界の外側1pixel 以内だったら1、それ以外だったら0を返します。そして上記メソッドを使って、出力カラーを調整する部分は以下のようになります。ファイル全体highlight 変数は idCol と HighlightID がほぼ同じ（※float演算なので誤差を許容する）なら 0.25、それ以外なら IsHighlightEdge() の結果、境界ピクセルなら1、そうでなければ0が入ります。
あとは、result にハイライト適用前の出力カラーが履いていますので、 lerp関数を使ってhighlight 変数の値に応じて HighlightColor と混ぜ合わせています。 冒頭の画像のようになりました
本来ならテクスチャが透明なだけで、手前に mesh が存在するようなオブジェクト同士の境界付近でも正確に奥のオブジェクトを選択できていますね！さて、せっかく深度バッファが手近(?)にあるので、深度バッファを使ってオブジェクトの輪郭を強調してみたいと思います。
以前書いた「綺麗なアウトラインシェーダーを作る」の超簡易版ですね。DayNightPixelArtsGBuffer.shaderでG-Bufferと一緒に深度バッファも書き出してるので、G-Bufferを読みだしてるDayNightPixelArtsLit.shaderで同じように深度バッファも読み出せる・・・と思ってましたが甘かったです。DayNightPixelArtsLit.shader でも普通に深度バッファにアクセスできるのですが、中身は空っぽになってしまている（正確にはグレーの小さなテクスチャになってる）ようです。以前 FrameDebugger で見た時、 CopyDepth っていうシェーダーが挟まってましたが、この前後で失われてしまうようです。
CopyDepth シェーダーは置き換え可能なビルトインシェーダーではないし、そもそも何かしら技術的に制約があるからコピーしてるんだろうと思われますから、DayNightPixelArtsGBuffer.shader で書いた深度バッファそのものにアクセスするのは諦めたほうがよさそうです。そこで、深度バッファは１チャネルあれば十分なので、昼画像用G-Bufferのアルファチャネルを使うことにしました。
こちらは各ゲームオブジェクトのシェーダーです。既存の深度バッファの書き出しに加えて、gBuffer0 にも position.z を書き込んでいます。そして、こちらが Deferred Lighting シェーダー側です。境界線を描くということで、上で紹介したハイライト表示の輪郭線の時とよく似たメソッドを追加してます。ただしこちらは 0/1 ではなく smoothstep 関数を利用して、ある程度深度差に応じた値を返しています。ファイル全体CalcEdgeStrength() を使って現在のピクセルのエッジ強度を edge 変数に代入し、colDay のリニア焼きこみ処理時についでに edge をかけて、エッジ強度が強ければ暗くなるようにしてます。ピクセル等倍だとわかり辛いので、ビフォーアフターを切り替えたgifアニメーションさせてみました。控えめながら、建物と建物の境界がより明瞭になったのではないでしょうか。
深度差が大きいほどエッジ強度が強くなってるということがわかりやすいように、昼画像の代わりに深度＋アウトラインを描きだしてみました。
ところで、カメラには Quater View という自作コンポーネントが付いていて、１ピクセルを何倍で描画するか指定できるようになってるんですが、拡大処理はG-Bufferへの書き出し時に行われるので、深度アウトラインは影響されません。ですからピクセル倍率を上げても、アウトラインは常に1ピクセル幅で描画されます。
（ちなみにハイライトの輪郭も同じ仕組みなので、常に1ピクセル幅です）
ピクセル倍率:4 での描画結果はこんな感じです。
アウトラインまで4倍になると画面がうるさくなりそうなので、これぐらいで良いかなと思ってます。元々この手法のメリットの一つとして ドット絵と通常の3Dオブジェクトの共存 が挙げられたのですが、今回作成した機能を3Dオブジェクトにも適用できるように、追加拡張を行いました。DayNightPixelArtsGBuffer.shader をベースに 3D メッシュ用のシェーダーを作ります。主なポイントは、1. 昼用・夜用テクスチャの区別がない事、2. フラグメントシェーダーで 簡易ライティング処理 をしてることです。ファイル全体Deferred レンダリングを独自にカスタマイズしてるので、本来の Deferred ライティングは適用できません。フラグメントシェーダー(frag) の冒頭で NdotL に照明と法線の内積を計算して、colDay に掛けることで、法線ベクトルに応じた簡単な陰影を付けています。
ドット絵と共存させるような3Dオブジェクトに、そこまで高度なライティングは要求されないだろうし、夕焼けアニメーションにいい感じに調和させるためにも、必要な処理です。
なお陰影は光源ベクトルに依存するので、ドット絵の仮想的な光源方向に合わせる必要があります。今回は下記のように設定してみました。一方C#スクリプト側ではIDカラーマップ対応のために、もともと Shade4Sprite にだけあった IDColor を3Dメッシュにも関連付けるための基本クラスを用意します。Shade4Sprite はこのクラスを継承するようにします。CaptureGBuffer クラスの FindObjectByIDColor() メソッド では検索対象として Shade4Sprite ではなく HasIDColor クラスを取得するように変更します。これで、3DオブジェクトにもIDカラーを割り当て、クリックで選択できるようになりました。



