TwainDotNetでグレースケールをスキャンすると、内部で32ビットBitmapが生成され、保存した時にファイルサイズが大きくなります。このため、グレースケールの場合には8ビットで保存できるようにTwainDotNetを改造してみました。1ビット、24ビットにも対応しています。スキャンアプリケーション ITScan - Qiitaに含めています。TwainDotNetバージョン1.0.0を元にしています。
BitmapコンストラクタにPixelFormatの指定がなく、必ず32ビットのBitmapが作成されるようになっています。元データが32ビット以外の場合にビット数に合わせたビットマップを構築しています。詳細は後述します。32ビットの場合は元の処理を行っています。32ビットの場合も新しい処理で大丈夫かもしれませんが、TWAIN機器から32ビットのデータが来るケースのテストができないため、安全のために元の処理にしています。既存のBitmapInfoHeader.csを元に、下記のファイルを同じように作成しました。変更前は下記のようにBitmapコンストラクタにPixelFormatの指定がなく、必ず32ビットのBitmapが作成されるようになっています。ここの前に、ビット数が32ビット以外の場合に分岐を加えます。24ビット以下向けの対応ですが、64ビットの場合にもここへ来ます。(64ビットビットマップを見たことありませんが)但し、BitmapコンストラクタにPixelFormat.Format8bppIndexedを指定してGraphics.FromImage()を行うと例外が発生してGraphicsオブジェクトを作成できません。
このため、GraphicsオブジェクトからgetHdc()を行ってhDCを取得し、SetDIBitsToDevice()を行うという手が使用できません。これを回避するため、MemoryStreamからBitmapを作成しています。但し、元データにBitmapFileHeaderがないため、自前で作成しています。
BitmapFileHeader作成、byte配列の先頭にコピーします。BitmapInfoHeaderとカラーテーブル(ある場合のみ)とビットイメージをBitmapFileHeaderの次にコピーします。MemoryStreamを作成し、そこからBitmapを作成します。それを呼び出し元で保存すると、グレースケールの場合には8ビットのBMPやPNG等で保存できます。
但し、これだけだとMemoryStreamを解放していないのでメモリリークします。MemoryStreamをusing等で解放すると、画像の保存時(Image.Saveメソッド実行時)に「GDI+で汎用エラーが発生しました」が発生します。これを回避するため、Bitmapを元にBitmapオブジェクトを作り直してそれを返却しています。但し、単純に Bitmap bitmap = new Bitmap(bmp) とすると、32ビットBitmapになってしまいます。この回避のために、LockBits()をして、PixelFomatかつビットマップイメージの引数があるコンストラクタを呼んでいます。それだけだとカラーテーブルがコピーされないため、24ビット未満の場合にはカラーテーブルもコピーしています。24ビットの場合にコピーすると例外が発生します。
但しこれだとbmpがメモリリークします。Bitmap bmp = new Bitmap(ms)にusingをつけてDispose()をすると、呼び出し元のBitmap利用で例外が発生します。このため、bmpDataのScan0をそのまま使用するのではなく、コピーして利用します。これでグレースケールでスキャンしたものが8ビットBitmapになります(Canon DR-G1130で確認)。それをPNGで保存すると8ビットPNGになります。1ビット、24ビットもそれぞれのビット数になります。下記の作業を行うと、TwainDotNet自体は改造せずに済みます。DataSouceManager内のnew BitmapRenderer 1箇所をnew MyBitmapRendererに変更するためだけにこれだけ変更が必要です。1) 自分のプロジェクトに上記 BitmapFileHeader.cs を追加。
2) TwainDotNetの下記のファイルを自分のプロジェクトにコピーしてリネームする。　　BitmapRenderer.cs → MyBitmapRenderer.cs
　　DataSource.cs → MyDataSource.cs
　　DataSourceManager.cs → MyDataSourceManager.cs
　　Kernel32Native.cs → MyKernel32Native.cs
　　Twain.cs → MyTwain.cs
　　TwainConstants.cs → MyTwainConstants.cs3) 上記BitmapRendererの改造をMyBitmapRendererに対して行う。
4) それぞれのクラスの使用箇所に「My」を追加し、念のためnamespaceを変更する。
5) 自分のプロジェクトのTwainの部分をMyTwainに変更する。継承でもっと短くならないか試したのですが、一部privateメンバやinternalメンバがあるため、ここまでコピーしないと無理でした。また、中途半端に継承すると、どこか失敗したのか、Canonスキャナのダイアログがのっぺらぼうになって操作不能になりました。ITScan 1.03 20200522(旧版)に対して、TwainDotNetを通常版にしてこの変更を行ったソースを下記の場所に置きました。
ITScan_src_1.03_TwainDotNet無変更版_20200523.zipITScan 1.04以降はこの変更を行っていて、かつ、MyDataSourceManagerに手を入れています。(スキャンが終了してもスキャナのダイアログが閉じないように変更)上記の方法の場合、メモリリークを回避しつつTransferImageEventArgsでBitmapを返却するために、新たなBitmapを作成して中身をコピーするため、非常にメモリを食います。32ビットTWAINを使用するため呼び出し元が32ビットアプリケーションのため、巨大な画像を読み込むとメモリ不足でnew Bitmapが「使用されたパラメータが有効ではありません。」となります。これを回避するため、スキャンアプリケーション ITScan - Qiita 1.06以降では、MyTransferImageEventArgsを作成してBitmapオブジェクトではなくHBITMAP(ハンドル)を返却しています。呼び出し元でMyBitmapRendererのコンストラクタとRenderToBitmap()の処理を行い、Bitmapのコピーをしないようにしてメモリ使用量を削減しています。


