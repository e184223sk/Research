More than 1 year has passed since last update.C# でデータを可視化したいとき、Python の matplotlib や Matlab のような普段使いのグラフプロットライブラリがないのが困りものです。ざっと調べたところ、商用ライセンスを使わない場合は、選択肢としては次のようなものがあるようです。（数年前からあまり活発に更新されていないものが多いですが・・）（参考 電子工作専科-C#プロットライブラリ）ここでは、(1) 標準Chartコントロール、(2) OxyPlot、(3) LiveCharts の使い方を比べてみます。性能比較ではなく、導入方法のメモとして。Windows フォーム標準の Chart コントロールは WPF から使うことも可能なようです（WPFでChartコントロールを使う）。ただし、WindowsFormsHost を使うため描画に問題が起こることがあるとか。OxyPlot や LiveCharts は WPF, UWP, Xamarin 含め広くサポートしていますし、MITライセンスなので使いやすそう。この記事ではサンプルを Windowsフォームとしますが、WPF 等でもプロットまわりのコーディングの流れは大きくは変わらないようです。LiveCharts は WPF版も簡単にまとめておきます。クリックイベントによってデータと棒グラフを更新するようなプログラムにします。環境：仕様：
↑ LiveCharts プロット例（LiveCharts は下から出てくるアニメーションがつきます）（以下のサンプルコードでは、インデントは読みやすさのために減らしているため参考程度ということで。）ChartAreas["ChartAreas1"] や Series[0] など、添え字と名前のどちらでもOK。chart1 のクリックイベントハンドラを作成します（chart1 プロパティの稲妻マークから見つかるClick，もしくは Form1.cs [デザイン] の chart1 の表示範囲をダブルクリック）。これでグラフをクリックするたびに棒グラフが更新されます。データを追加するときは AddXY などの関数を使いますが、これら Add系（の関数でデータ追加を行うと、自動でグラフがリフレッシュされます。一方、データの値だけ設定するには SetValueXY や SetValueY などを使いますが、これら SetValue系でデータを置きかえた時や Points.ElementAt(1).YValues に直接代入したとき、Points.Clear() としたときなどは、自動ではグラフが更新されません。上記のコードのように chart1.Refresh() を明示的に呼ぶ必要があります。http://docs.oxyplot.org/en/latest/getting-started/hello-windows-forms.html が参考になります。ただ、ツールボックスでのコントロール追加は説明が省略されているので、ほかの記事も参考にします。WPF なら、以下の手順のうち「ツールボックスへコントロールの追加」が「XAMLの編集」になりますが、ウェブでいろいろ見つかるようなので省略します。ここでは Windows Forms を前提としています。plotView1 のクリックイベントハンドラを追加し、クリックするたびにデータ更新とグラフ再描画を行うようにします。データを直接置きかえる方法が分からなかったので、いったん Clear() しています。
グラフを再描画させるためには、Model.InvalidatePlot(true) が必要なようです。LiveCharts も、OxyPlot と同様に、NuGet でパッケージを導入します。参考（LiveChartsドキュメント）：いったんデータを紐づけておけば、再描画は自動で行われるようです。あとで使いやすいようにプロパティにしておきます。グラフの軸や背景色の設定などは，(*1) のように、cartesianChart1 から AxisX などのプロパティを介して行っています。また、(*2) の cartesianChart1.Series は SeriesCollection型ですが、LiveCharts では複数の Series (データ系列) をこの SeriesCollection クラスで管理します。図の様々なプロパティをまとめて管理するのが Windowsフォーム版特有の CartesianChartクラスで、cartesianChart1 はそのオブジェクトです（namespace は LiveCharts.WinForms）。つまり、Windowsフォーム版は、WPF版の様々なプロパティを CartesianChart がラップする形です。CartesianChart 以外にもいくつかのタイプの Chart があります。
一方で、後述のように 、WPF 版ではこれらのプロパティを直接 XAML で Binding していきます。Labels や DataValues のデータを更新すると、グラフも自動で再描画されます。ChartValues の Add を何度も呼ぶことは望ましくなく、先に配列に値を入れておいて AddRange などで一度に ChartValues にいれる方がよい (Performance Tips) というので、いったん配列に入れています。（上のコードでは AddRange ではなくコンストラクタで渡しています。）なお、グラフ全体にタイトルをつける方法は見当たりませんでした。LiveCharts cartesianChart1 のクリックイベントは取れないようだったので、データをクリックした際に発生する DataClick イベントを追加し、クリックするたびにデータ更新とグラフ再描画を行うようにします。棒グラフをクリックすると、たしかに自動でリフレッシュされます。毎回、にょきっと下からグラフが伸びてくるアニメーションです。乱数配列の生成は LINQ の Select にしています。以下のように、Values[i] に順次代入しても動くようですが、パフォーマンス的にはよろしくないのかも（このくらいのデータサイズなら許される？）最後に LiveCharts を WPF で使う方法を簡単にまとめておきます。NuGet パッケージのインストールを行った後に、XAMLを編集します。
AxisX や SeriesCollection などの各種プロパティを Binding しておきます。C# のコードですが、Windows Forms 版のコードに対する差分を示します。(*1) は XAML側で行ったので削除できます。一方で (*2) は SeriesCollection も自分で用意しておきます。SeriesCollection のプロパティも追加します。自分では未検証なので以下は参考情報として。LiveCharts はデータ点が1000点ぐらいならいけるが1万点は重く、一方で OxyPlot ではいけるという Qiita の記事があります。ただ、パフォーマンスチューニング前の結果のようでした。LiveCharts の作者自身が書いているように、LiveCharts は、OxyPlot をよりモダンな UI にしたいというモチベーションから作成されているので、見た目も凝っていて、アニメーションも豊富なようです。
したがって、パフォーマンスを上げるためには、（先の Qiita の記事にもリンクがありますが）ドキュメント (Performance Tips) に従って、いくつか設定変更するのがよいでしょう。
アニメーションの Disable を含め、どのプロパティをオフにするとよいかや、何度も Add しないなど、チューニングの Tips がいろいろ紹介されています。さらには、有料版ならば1千万点でも問題ないとか（LiveCharts Geared・・70ドル弱なので他の商用ライブラリよりはだいぶ良心的かな）。パフォーマンスを気にするなら、LiveCharts はデフォルトのままではなく設定を工夫と・・普段使いのチャートライブラリはどれがよいか、悩ましいところです。OxyPlot と LiveCharts は、GitHub のフォーク数では LiveCharts がやや高く、一方で Google trends では OxyPlot の方がやや高めようです。ドキュメントの充実度では LiveCharts でしょう。適当なライブラリは目的次第かと思いますが、個人的には LiveCharts は相性が良い感じ。Windows に限定した場合は、標準Chartコントロールで行けるところまでいって、ズームとかヒートマップとかアニメーションとか必要になってから OxyPlot もしくは LiveCharts を考えるのもよさそう。


