プログラミングを学ぶ方が壁にぶつかるポイントは、いくつかあります。
条件分岐と繰り返し。
配列。
そして、クラスとメソッド。特にクラスとメソッドは、「概念は分かるけど、一体なにが便利なんだ！？」という風に思う方がほとんどだと思います。例えば、・・・なんて言われても、「なんのこっちゃ！？」となるに決まっています。この説明だと、分かるわけがないんですね。
もう少し身近な例で、かつ用途が分かる例での解説が、必要になってくるわけです。
そこで今回は、誰もが一度はやったことがあるであろう、「ポケモン」を使用して、解説していきます。この記事は、「一度はクラス・メソッドを勉強したことがある人」「でも、あんまりよくわからなかった人」がターゲットです。まだクラス・メソッドを勉強したことがない人は、一度は教材などから、勉強することをオススメします。この記事は、ポケモンをやったことがない方が読んでも、さっぱりな内容になってます。
ポケモンをやったことがない方は、ぜひこちらのリンクに飛んでください。
https://www.pokemon.co.jp/ex/sword_shield/
https://www.pokemon.co.jp/ex/VCAMAP/ポケモンは、基本的に初代仕様です。なるべくわかりやすくするため、一部無理やりな実装部分があります。また、あえて説明していないところもいくつかあります。
以下の内容より良い実装、リファクタリングできる場所は、非常に多数あります。細かい事は気にせず、ざっくりとした概念を捉えていただけると嬉しいです。突然ですが、「ポケモンをプログラミングしてください」と言われたとき、皆さんはどのように実装しますか？もし、クラスをちゃんと理解していない方が頑張って実装しようとすると、以下のように書くんじゃないかと思います。・・・もうこの時点で、どこかで必ず破綻するのは、火の中水の中草の中、あの子のスカートの中を見るよりも明らかですね。では、どのように実装するのがいいでしょうか？一緒に考えていきましょう。ポケモンは多種多様います。その数、全部で151匹です。（byおじいちゃん博士）それだけたくさんのポケモンがいますが、すべてのポケモンが、共通してもつ情報があります。まずはそれについて、考えていきましょう。どんなポケモンの種類でも、以下のような情報は、共通で持っています。このような情報は、すべてのポケモンが持っています。例外はありません。レベルの持たないポケモンなんていませんよね。遊戯王じゃあるまいし。この内容を実装すると、以下のようになります。すべてのポケモンには、HP、攻撃力、素早さといった情報を持っています。バトルで使用するパラメータですね。
これらのパラメータも、同じようにすべてのポケモンが持っているのですが、このパラメータの持ち方は、ちょっとややこしいです。ポケモンのHPなどのパラメータは、「種族値」「個体値」「レベル」といった要素（ステータス）で決まってきます。
レベルはさておき、種族値、個体値は以下の内容です。といったといった内容で、ゲームには表示されない、隠しパラメータになります。
（※本当は努力値とか性格とかも絡んでくるのですが、ここでは割愛します）そのため、ゲーム画面で表示される「攻撃力：150」「素早さ：200」というステータスは、実際には「種族値」「個体値」「レベル」といった要素の計算式で、決まってきます。※「？？？」となってしまった方がいるかもしれません。これらの内容は説明したい内容の本筋じゃないので、「攻撃力とかのステータスは、色んな値の組み合わせで決めるんだ！」とだけ理解してください。これらの内容を、以下の図、コードでまとめてみます。※ステータスは、最大HP、攻撃力、素早さのみ記載してます。防御力、特殊は割愛してます。攻撃力などのステータスが、計算式で出されていますね。そう、これがメソッドです。
例えば「攻撃力をゲーム画面に表示する」という状況になったとき、このGetKougekiメソッドを実行します。それにより、それぞれのポケモンが持つ他の値を使用して、攻撃力を求めて画面表示するわけです。
この計算式は、基本的にどのポケモンでも共通して使用されます。すべてのポケモンが共通してもつ情報を定義しました。
今度はそれぞれのポケモンの種類が持つ情報を定義したり、セットしていきます。例えば、「プリン」というポケモンを考えていきます。ちなみに僕は小学生時代、プリンが大好きすぎて、周りからドン引きされてました。ぴえん。プリンというポケモンは、以下のような情報が固定で決まっています。いつ、どこで捕まえたプリンでも、この情報は固定です。
この「プリン」というポケモンを実装する場合、きっと以下のような、Purinクラスで、実装を行います。「class Purin : Pokemon」という書き方をしています。
これが、継承です。上記で作成した「Pokemon」というクラスをベースに、Purin用のクラスを作成しているわけですね。他にも、ライチュウ、カイリキーといったポケモンも、以下のような実装となるはずです。つまり、これらのクラスは、ポケモンの数だけ作成されていきます。
図に書くと、以下のようなものになります。ここまでが、クラスの説明で、いわゆる「設計書」と呼ばれる部分です。
ここから、いよいよ実体化、インスタンス化していきます。3番道路の草むらを歩いていると、草むらからプリンが飛び出してきます。
「あ！　やせいの　プリンが　とびだしてきた！」
この瞬間、プリンが実体化します。
Purinクラスという設計書をもとに、実際にプリンが飛び出してくるわけです。そして、このタイミングで、そのポケモンの「レベル」、「個体値」、「覚えている技」といった値が決定します。
レベルは、どの草むらで出会ったかによって、ある程度の範囲でランダムに決められます。
個体値の、一定の範囲でランダムに決められます。これを実装すると、以下のようになるでしょうか。Pokemonクラスのコンストラクタで、「とびだしてきた！」時の処理を実装しています。
Program.csで、3番道路でプリンがとびだしてきた時に、インスタンス化します。
そのタイミングで、初期レベル、個体値、覚えている技が決定します。これらの値は、草むらで出会ってから、ずっと使用されます。
「あるタイミングで急にレベル１になる」とか、「あるタイミングでは急に攻撃力の個体値がめっちゃ強くなった！」ということは、基本的には無いわけです。この「とびだしてきた！」をきっかけにして、どんどんポケモンがインスタンス化していきます。
Purinクラスという設計書をもとに、どんどんプリンが量産化されていきます。桃源郷ですね。
イメージとしては、以下のようになるでしょうか。ここからは、もう少し別のケースを見て、クラスのメソッドを理解していきましょう。ポケモンバトルによってレベルが上がると、ポケモンは技を覚えていきます。
その技について、「手持ちの技は4つまで」というルールがあります。
そのため、以下のような流れとなります。なので、「技を覚える」というメソッドを実装するとしたら、こんな内容になるはずです。上記のコードで、「技」について触れました。string wazaNameとして、技名文字列として実装しています。
でも、本当に「技」情報を、文字列として実装して、いいのでしょうか？「そのポケモンが覚えている技」というものを、単に「技の名前文字列」（ハイドロポンプとか、かえんほうしゃとか）で管理しようとすると、ポケモンバトルの際に、やっぱり破綻します。プログラミング始めたての方が陥る現象です。ポケモンには、さまざまな種類の「技」があります。
そして、その「技」には、さまざまな共通の情報があります。例えば、以下のような内容です。そして、例えば「はたく」という技は、以下のような効果があります。「うたう」という技は、以下のような効果があります。そう、つまり何が言いたいかというと、ポケモンの種類と同様に、技についても、クラスで実装できるということです。Wazaクラスを実装するのであれば、以下のようになるでしょうか。ポケモン側の実装も、このようになります。わざ1～4が、string型から、Wazaクラスに変わりました。そのポケモンが持っている技の型も、Wazaクラスになるわけです。
こちらの方が、ポケモンバトルで技を使用する際に、圧倒的に使いやすくなります。
他にも、上記で書いた、「技を覚える」というメソッドも、Wazaクラスに変わることで、圧倒的に実装しやすくなるでしょう。このように、「クラスで実装した方がいい」ものは、他にも非常に多数あります。
例を挙げれば、以下のようなものでしょうか。これらの内容を、どう実装すればいいだろう？ということを、プログラミングはしなくても、設計して考えてみることをオススメします。これまでの説明で、「攻撃力などのステータスは、種族値や個体値やレベルなどで計算して決まる」「計算式は、すべてのポケモンで共通している」と書きました。
しかし、初代のポケモンではないのですが、ここで例外となるポケモンがいます。「ヌケニン」というポケモンです。ヌケニンは、「レベルや個体値などに関わらず、HPが常に1」というポケモンです。HP1なんですよ。とんでもないポケモンですね。では、このヌケニンを実現するために、どのような実装を行えばいいでしょうか？
ヌケニンの実装には、「オーバーライド」という方法が非常に役立ちます。このように、NukeninクラスのGetHPメソッドで、"return 1;"だけする処理を記載します。
そうすることで、ゲーム画面やバトルでHPを使用するとき、全ポケモン共通の計算式を使用せず、「常に1」ということを実現できます。これが、オーバーライドです。共通のものがあっても、独自の処理を実装できるので、非常に便利です。このような「独自の処理」が必要なものは、ポケモンには多数ありそうです。
例えば、以下のようなものです。それらの処理をどうやって実装するか？という所を、考えてみると良さそうです。以上で、ポケモンについての解説は終了です。
「よく分かった！」という人もいれば、「やっぱりさっぱり！」という人もいるかもしれません。大切なのは、「自分で設計して、自分で実装してみる」ことです。まずは設計だけでも構いません。
そして、クラスやメソッドの実装の練習を行うためには、身近な、自分が愛着を持っている内容がオススメです。
「これらの内容を、自分でプログラミングするなら、どうやって設計するかな・・・？」ということを、自分で考えてみるのが、すごく大切です。
例を挙げれば、こんな内容でしょうか。そして、ここまで自分が書いたコードも、かなりの勢いで改善点があります。例えば、以下のような内容です。対戦機能、セーブデータから読み込み機能・・・といった機能を実装していくうちに、こういった問題にぶち当たることは、よくあります。そのたびにリファクタリングして、都度対応していく必要があります。以前、入門者向けにブラックジャックの記事も書いたのですが、分かりやすい・取っつきやすい例から、自分で手を動かして、「あーでもないこーでもない」を繰り返し、理解・定着していくことが、何よりも重要です。この記事を読んだ方が、少しでもクラスとメソッドについて理解が進んでくれていたら、すごく嬉しいです。THE   END


