More than 1 year has passed since last update.既存資産であるJavaアプレットを .Net Framework上のC#で実装しなおすこととした。元々のプログラムはこてこての描画アプリであり、移植のための調査を色々実施したところ、一番ネックになりそうなのがXORModeというものであった。今回これをC#で実現するために調べたことをメモっておく。XORModeについて、まずはYahoo知恵袋の「javaのGraphicsクラスにあるsetXORModeとは何ですか」を参照してほしい。恐らく何のことかよくわからないと思う。自分もよくわからなかった。こういう時は、目的から理解するに限る。
例えば、マウスを使った描画プログラムで線を引くとしよう。ユーザの操作としては、線を開始したい位置でマウスクリックし、線を終了する位置でマウスアップするはずだ。その場合JavaだろうがC#だろうが、大体以下のような実装になると思う。1 　マウスクリックのイベントハンドラで、クリックされた座標(x0, y0としよう)を記録する。
2 　マウスムーブのイベントハンドラで、マウスが移動した座標と、(x0, y0)をつなぐ線を描画する。これは、まだどこに線を引くかは確定しておらず、線の終了位置を決めるためにユーザがマウスを移動している状態であり、仮の線を引いている状態だ。
　（注) この時、マウスムーブする度に、前回のマウスムーブの時に描画した線は消去する。
3　マウスアップのイベントハンドラで、マウスアップされた座標(x1, y1としよう)を取得し、(x0, y0)と(x1, y1)をつなぐ線を描画する。これによって線の描画が確定する。ここで、（注）に記載している、「前回のマウスムーブの時の線を消去する処理」がなかった場合は、下のようにマウス移動する度に線が増えていってしまう状態になる。さて、「前回のマウスムーブの時に描画した線の消去」はどうしたらよいだろうか。
前回と同じ線を、今度は色を変えて背景色（この場合は白）で上書きしてあげればよいと思うかもしれない。確かにそれで前回の線は消えるのであるが、線を引く前に元々グラフィックオブジェクトに描画していたものまで白い線で上書きされてしまうのだ。
以下は、この方法で線を何回か描画したものだ。過去に引いた線がかすれているのが分かるだろう。そこで、XORModeの登場である。XORModeにした状態で同じ内容（同じ色、同じ位置、同じ形等）で2回描画すると、あら不思議、線を引く前に描いていた内容も含め、完全に元の状態に戻るのである。「反転描画」ともいうようである。即ちマウスムーブ、マウスドラッグなどにより、移動するオブジェクトを描画する際の必須のテクニックといえる（さっきまで知らなかったが(笑))。そういえば元々のJavaのプログラムを見ると、移動中のオブジェクトを描画する度に、前回描画したオブジェクトをXORModeで上書きする処理がしつこいくらいに繰り返されている。さて、XORModeが何かイメージが大体の分かったところで、以下、これをC#で実現するために四苦八苦した記録を書くこととしよう。今回は以下の環境で調査した。
- Windows 10
- Visual Stuido 2017
- Java 1.8 (アプレット)まずは.Net FrameworkでXORModeがないか調べたところ、表示色を反転して線を引くを発見。「ControlPaintクラスのDrawReversibleLineメソッドを使うことで、表示色を反転して線を引くことができます。また、同じくControlPaintクラスのDrawReversibleFrameメソッドで枠を、FillReversibleRectangleメソッドで塗りつぶされた四角を描くことができます。」と書かれている。これを元に以下の通り実装してみた。動かすにはユーザーコントロールで実装しているので、フォームに張り付ける必要がある。また、 UserControl1_MouseDownをMouseDownイベントに、UserControl1_MouseMoveをMouseMoveイベントに、UserControl1_MouseUpをMouseUpイベントに、それぞれVisual Studioで紐づける必要がある。このソースにおいて、 ControlPaint.DrawReversibleLineで線の描画を、ControlPaint.FillReversibleRectangleで塗りつぶした四角形の描画を行っている。どちらもMouseMove時に、前回の描画の消去用と、今回の描画用に2回処理を記載しているのがポイントだ。線、四角形どちらもマウスの移動に追従して問題なく表示される。しかしながら、ControlPaintには、円や多角形に関するメソッドが用意されていない。今回移植するソースには、JavaのGraphicsオブジェクトにおいて、円を描くdrawOvalメソッドや、多角形を描くdrawPolygonメソッドも含まれているため、このままでは実現できないことが分かった。そこで、さらに調べた結果、 https://github.com/EWSoftware/ImageMaps/blob/master/Source/WinForms/UnsafeNativeMethods.csに、gdi32.dllを呼び出して円や多角形で反転描画を実現する例が用意されていた。このソースをプロジェクトに取り込み、以下の通り実装してみた。そうすると確かに円や多角形を反転描画することができた。ただし、このライブラリは塗りつぶしが用意されていないのだ。まぁ、必要なかったので実装していないだけだろう。とはいえ、もうこのライブラリにすがるしかないので、何とか塗りつぶしを実現せねば。引き続きGoogleで思いつく限りのキーワードで検索しまくった。どう探したかは覚えていないが、取り急ぎ円については、ライブラリの UnsafeNativeMethods.DrawReversibleCircleメソッドのIntPtr oldBrush = SelectObject(hDC, GetStockObject(NULL_BRUSH));のところで色が指定されていないので、ここを
IntPtr oldBrush = SelectObject(hDC, CreateSolidBrush(ColorTranslator.ToWin32(backColor)));
に置き換えてあればbackColorで指定したColorオブジェクトの色で塗りつぶされることが分かった。最後の難関は多角形の塗りつぶしだ。ライブラリのDrawReversiblePolygonはLineを何回か引いて多角形を作成していた。これだと原理的に中身を塗りつぶすことは難しそうだ。そこで、再度Googleで検索したところ、http://wisdom.sakura.ne.jp/system/winapi/win32/win29.html
にPolygonというまさにドンピシャのネイティブAPIが用意されており、SetPolyFillModeを設定して呼び出すと塗りつぶせそうだった。そこで、次の通りやってみた。まずは、ライブラリのソースを修正し、PolygonとSetPolyFillModeをインポートする設定を追加した。またPolygon関数に多角形の座標を与えるためのPOINTAPIの構造体も定義した。そして以下のFillReversiblePolygonメソッドを実装した。ポイントは、SetPolyFillMode(hDC, 2);で全部塗りつぶすよう指示をしているところと、.NetのListに入ったPointを、POINTAPIの配列に変換して、Polygon関数の引数に設定しているところだ。さあ、お膳だてはととのった。ユーザーコントロールから呼び出してみよう。先ほどのソースのUnsafeNativeMethods.DrawReversiblePolygonの呼び出しのところを以下のように変えてみる。Color.Blackは塗りつぶし色を示している。そうすると多角形についても、黒に塗りつぶされた状態で、マウスに追従して問題なく表示された。ふぅー、やっと終わった。たかがマウスムーブの間のオブジェクトの表示という、描画処理のメインではないところの技術的な調査に、大幅な時間を要してしまったが、開発とはそんなものであろう。最大の懸念事項がクリアされたので、いよいよ様々なオブジェクトたちの描画処理を移植するというメインディッシュをいただくとしよう。UnsafeNativeMethods.DrawReversiblePolygonメソッドにおいて、CreateSolidBrushで作成したBrushをDeleteObjectで削除する処理をいれていなかったため修正。これをしないと、長時間使った場合に、グラフィックリソースを使い果たしてしまう恐れがある。


