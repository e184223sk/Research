More than 3 years have passed since last update.ん～～
ハッシュコードが欲しかったんです。
でも、MD5とかSHA1とか、そこまで長いのはちょっとねー
もっと手軽なハッシュコード…
あー、CRC！
って訳一応断っておくと、C#のGetHashCode()はダメっすよ。
物凄く偏ったコードを返すので。で、忘れてはならないのは、CRCの検算ですねと云うのも、検算できないと自分の実装が正しいか分からないじゃないですか実装はkadzusさんとこのを踏襲して、HashAlgorithmのサブクラスとします！検算系は七誌さんの資料を参考に手探ってみました！えーと、多項式に詳しい訳でもないので解説は他の方にお願いせざるを得ません…
とか思ったら、もうソースを載せるくらいしかないですね。てな訳で、まずは定義部分CRCpolynomialの定義が、wikipediaの主な標準CRCに対応している事が分かるかと思います。で、これをこんな形で使えると良いかなぁ、と…そんなこんなでこうなりました。
ざっくり説明すると—で使い方。実行すると、こんな感じ。実は、最初のusing内でマスクの値をどう変えても、検算メソッドはきちんと判断してくれます。
と云うか、そういう風に作ってみました。元データにCRCを合体させた全体でCRC計算を行うと、一定値になりまっせー
と云う事らしいです。この一定値をマジックナンバーと呼ぶ、と…ここで気を付ける点は、CRCは内部的にはuintで表されていたものをバイト反転して配列として返しているので、合体させるときにもう一回反転してあげないといけないところですね。で、検算！
確かに、21-44-DF-1Cってなってますね。でも、このマジックナンバーが一定であるとは限らないすよね。
何ちゃらマスクが二つあるので、少なくとも４パターンのマジックナンバーがある筈。で、剣山！
何とかマスクは両方ともfalseにしてみましょう。おや？
マジックナンバーがゼロだ。そういえば、どこかの記事でcrcくっつけて新たなcrcを計算するとそれはゼロになりまーす、と云う記事を見た記憶もあるなぁ…じゃぁ、さっきのマジックナンバーはどこから来た？
って、そりゃーマスクの関係でしょう。どう繋がってくるかは良く分からないけど、計算過程が異なるから結果も変わってくるんでしょうね。

じゃ、ここを起点に色々考えてみましょう。まず手始めにInitialMaskがtrueでFinalMaskがfalseの場合。問題なし、ゼロになりました。お次はInitialMaskがfalseでFinalMaskがtrueの場合。ありゃ？
所謂マジックナンバー…んんんー…
お！
crcがFinalMaskでビット逆転しているので、そいつを元に戻せばいいのでは？
よし、じゃぁ見参！ん？
微妙…あー、結果の方もFinalMaskでビット反転してるからだ。
じゃぁ、こう。では最後にInitialMask・FinalMaskともにtrueの場合。よし！
これで、全パターンの検算結果をゼロで取得することができました。で、この４パターンの検算を一気に詰め込んだのがConsistencyCheck()メソッドです。
与えられたcrc値がどんなマスク指定で作成されたものであっても、全パターンのチェックを若干効率的に行ってくれると云う…と、此処にきて思っちゃったんですが、ビット送り方向指定によってもcrc値は変わるなぁ。
例えば—crc値は異なりますね。
でも、検算結果はゼロになっているので実装上の問題はなさそうですが、CRCクラスをインスタンス化する際のBitFeed方向の選択を間違えると、正しく判定できないって事になっちゃうかぁ…そこまでの自動判定を実現させるならCRCクラスにConsistencyCheck()を実装するんじゃなくて、CRCconsistencyCheckクラスにするとかが必要っぽいですね。と云うような辺りが心残ってしまいました。

最後にCRC長を変えたパターンのテスト結果を載せて締め括りたいと思います。よしよし、検算結果もゼロなので、実装に問題はないと云う事で良いですね。
では。


