C# その2 Advent Calendar 2019 の8日目枠です。初参加になります。マイクラ自動化といっても経験値トラップやレッドストーン回路を組むわけではありません。コードをガリガリ書いていきます。C#を使ってマイクラをリモート操作できますよという内容です。マイクラ自動化をC#でやっている方があまりおらず、いい機会なのでこのテーマにしました。ここに書いている内容は私のブログをまとめたものですが、ブログよりも丁寧？に書いていますので長文になっております。サーバは起動できる状態を想定しています。起動するまでの手順はここでは省きます。また、ゲーム設定でチートモードをONにし、プレイヤーの権限レベルを4に設定しておいてください。この設定がないと、そもそもコマンドを使えません。サーバ起動ファイルのディレクトリ内に "server.properties" があるのでこれを次のように編集します。上から順番にRCON接続の許可、接続パスワード、接続ポートを指定しています。この記述がないと外部からコマンドを投げることができません。できたら保存を忘れずに。Visual Studio でコンソールアプリケーション(.NET Core)のプロジェクトを作成します。作成したらパッケージマネージャコンソールにてCoreRCONを導入します。RCONは簡単に言えば「マイクラのコマンドをリモートで通信するためのプロトコル」です。これがないとコマンドを投げられないので忘れずに導入しましょう。まずは簡単なコマンドを投げてみましょう。簡単なコマンドと言えば "time set 0" や "weather clear" などの自然現象設定コマンドですかね...。
手順に沿ってコマンドを投げる方法を書いていきます。RCON自体が非同期なので、まずは非同期メソッドを作ります。名前空間とクラスは省略して書くので、環境に合わせてご利用ください。これでメソッドは書けました。次にRCONへ接続するための準備を行います。必要な情報は次の通りです。これらは先ほど"server.properties" で設定した値をそのまま使います。RCONを上記の情報を使ってインスタンス化します。これでRCONを使う準備ができました。RCONインスタンスにはコマンドを投げるメソッドがあるので、これに投げたいコマンドを引数にいれて実行します。このコマンドを実行すると天気を雨にすることができます。すごく簡単ですね。
コマンドの種類についてはこちらを参考にしてください。SendCommandAsync()メソッドの返り値はMinecraftのログなので、適当な変数を用意してそこに代入させればログを表示することができます。では、ここまでの内容をまとめてコードに書いてみます。これでコマンドの送信と結果（ログ）の表示までできるようになりました。
ただし、ゲーム自体が日本語でも返ってくる文字列は英語なので注意が必要です。
残念ながらプレイヤー自身の座標を得るコマンドがありません。自身の座標がないと色々と不便だと思いますので、どのようにして取得したかをまとめます。座標を得るためにはテレポートコマンドを投げるしかありません。テレポートするには対象となるユーザ名が必要なので追加します。コマンドを投げると、結果としてこのように返ってきます。ご丁寧に、英文つきで値が返ってくるのです。
このままでは座標ごとに値で保存できなくて辛いので、ここから数値データだけを抜き出します。まずは数値だけが欲しいので、数値以外の文字列を除外します。除外した文字列は一度変数に保存しておきます。Ragexは正規表現に関するクラスです。今回はその中の Replace() メソッドを用いました。Replace は正規表現に一致するものへ置換して返すメソッドです。このままだと一致するものになってしまうため、指定した文字以外[^ ]を使って除外します。
つまり、0 ~ 9とカンマ以外は除外されます。これで余計な英文を除去できました。除外した文字列はカンマ区切りになっているので、カンマごとに各座標の値を保持していきます。確認のために、みんな大好き foreach でぶん回して保持された座標を見てみます。しかし、このままでは文字列型で不便なので double型にパースしていじれるようにします。foreach をfor文に書き換えます。これでプレイヤー座標 (x, y, z) を得ることができました。プレイヤー座標を得られたことで、for文をぶん回して座標を進め、そこにブロックを配置できるようになります。
配置コマンド： /setblock X Y Z ブロック名またはIDこれはfor文1つで実行可能です。オリジナルの座標をいじると再利用できないので、これをコピーした変数をいじくります。これで実行すると、X方向へ5個の石ブロックが配置できます。

ブロック名やIDはこちらを参考にしてみてください。これは2重for文で実装すればできますが、ここで注意です。地面と平行な方向へ2次元に配置したい場合は Y に j を足すと高さの方向へブロックが積まれてしまうので、Z に加算するようにします。実行結果です。
3重for文を使います。もし、水平方向から積み上げていくようにしたい場合は、一番外側にY座標に対するfor文を書いていきます。どのように積み上げていくかはfor文を入れ替えるか変数を入れ替えるかして工夫します。この例では変数を入れ替えています。実行結果です。
ここまでで座標位置のいじりかたとブロックの配置方法が分かったので、次は建築を自動化してみます。設計図はExcelを使います。行と列はX座標とZ座標、シートはY座標として扱えばわかりやすいと思います。まずはExcelファイルを読み込むところから始めていきます。COM参照する方法があるそうなのですが、こちらの記事によると、この方法は良くないとのこと。ということで、Nugetのパッケージにお世話になります。
Excelの読み込みに使うパッケージはNPOIです。新しくクラスを作ります。クラス名はExcelReadにしました。その中にファイルオープン用のメソッドと、Excelシートの各セルの値を読み込むメソッドを作ります。
また、Excelを格納するディレクトリを作成し、その中にHouse.xlsxファイルを作りました。値を受けとるメソッドです。文字列にパース指定しています。先ほど得られた値（文字列）をswitch文で分岐させて、ブロックIDを指定することにしました。この値をもとにsetblockコマンドを送れば建築できます。新しくConvertFromExcelクラスを作り、その中にConvertメソッドを書きました。
対応付けで代入している値（文字列）はブロックのIDです。例えば値が0だと空気ブロック、1だと石というようにブロックにはそれぞれIDが割り振られています。なので、setblockコマンドを投げるとき、ブロック名の部分をIDで指定することもできます。これはオプションですが、読み込めているかの確認で表示用メソッドも作りました。これらのメソッドを順番に読み込んで実行します。ファイルを開く、ブロックの関連付け、配置コマンド実行の順です。まずは配置コマンドを投げるための非同期メソッドを作ります。そのときに、関連付けメソッドのあるクラスのインスタンスも生成します。また、プレイヤーの座標を取得しておきたいので、GetPosition()メソッドを先に追記しておきます。そしてこのメソッドを呼び出すためにMainメソッドに追記します。Excelの内容はswitch文で決めたような数値で、ブロックとの対応付けを考えながら適当に調整します。

そして動かしてみます。
これでC#を使って建築することができました。
コンソールに表示される Warning はプログラム的な意味ではなくて、ブロックIDを指定しているのが問題のようです。IDを使ったブロックの指定は今後サポートされないという内容です。くらでべチャンネルでPython, Docker, Azureなどを用いてリモート操作し、湧き潰しの自動化をしていました。これを自分のローカル環境上で動かしてみます。Minecraftの世界では暗い場所でモンスターが湧きます。モンスターが湧くと、プレイヤーや村人を襲うようになるので非常に危険な状態となります。そこで、光源となるようなもの（主に松明）を置いて暗い場所をつぶしていくことで、モンスターの発生を防ぎます。これを湧き潰しと言います。さて、問題はどのようにして湧き潰しを行うかです。こちらのサイトによると、6マス間隔で置くのが効率が良いとのことなので、これに則ってプログラムを書いていきます。6マス間隔に置くので、0ブロック目を置いたとすると次は6マス開けて7マス目に置きます。その次は6マス開けて14マス目...というように7の倍数で置きます。余剰演算子7で割り、あまりがない場合は置くことにします。
とりあえず、自分を基準にX座標とZ座標の方向へ等間隔に松明を設置してみます。これで実行してみると、プレイヤーのいる高さの平面上に松明が配置されます。
ただし、その高さでブロックが存在すると置き換えてしまうので、穴が開いてしまうのが残念です。そこで、地表判定を行うようなロジックを考えます。上記の方法だけでは平面にどんなブロックがあっても強制的に松明に置き換えてしまいます。このままでは村のブロックを破壊しながら湧き潰ししてしまうことになるので、ちょっとした工夫が必要です。
松明がブロックを置き換えることの無いよう、地表にだけ設置するようにします。
また、松明を置くとき、そのブロックに草が生えていると設置できません。なので、空気ブロックかどうかを調べて空気でないなら置き換えるような処理を書いていきます。プレイヤーの高さを基準に空へ向かって線形探索を行い、空気ブロックだったらそこに松明を置くようにします。
先に作成した二重for文の一番内側にこのロジックを実装すれば平面上7マスごとに探索が行われるので、計算量が少なくなります。ブロックを調べるコマンドは /testforblock X Y Z ブロック名 です。また、このコマンドの返り値としてブロック名に条件が一致すれば "Successfully" と表示され、条件に合わない場合は見つかったブロック名でログを返してくれます。なので、これを基準に条件分岐を行って判定していきます。高さはプレイヤーの初期位置にして最高高度からその高さを引いた間で探索を行うようにします。このロジックを先ほどの二重for文に組み込みます。実行してみるとこんな感じになりました。ここではプレイヤーよりも高い位置での探索を行いましたが、プレイヤーよりも下の位置に松明を置くことも可能です。例えば初期値をプレイヤーよりも20マス下にすれば、20マス低い土地に対しても湧き潰しすることができます。この辺は個々のさじ加減ですね。上記以外にも、コマンドが使える範囲であればなんでもできると思います。
私のブログでは、指定範囲内で最も高い位置にあるブロックの座標の表示、整地の自動化、ブロックの種類別数え上げなど様々なことをやっています。今後も色々検証しながら、できることを探していきたいですね。Minecraftはゲームではありますが、使い方次第ではとてもいい勉強ツールになります。
個人的には、このようなツールを使ってプログラミングを学べるような環境を作るのも一つの手かなと考えております。
特に、Minecraft Educationだけでは満足できない人にはオススメです。今回作ったコードはこちらにあります。参考にどうぞ。また、Minecraft自動化について解説した専用サイト Minecraft with Code を作りました。自動化の詳しい内容はこちらからご覧いただければと思います。


