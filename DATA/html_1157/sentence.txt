More than 1 year has passed since last update.windows10
Unity 2019.3.15f1⇒高精度を求めるならCoroutine一択！※
理由は下記の記事になります。※2020/06/30 FPSに依存するようです。高精度ではなく、Updateと同じ精度と考えるのが良さそうです。「Unity 指定時間後」で調べるとこの二つが出てきます。【Unity】スクリプトの処理の実行タイミングを操作する
↑こちらの記事がわかりやすいです。「BPM200の16分音符を鳴らしたい=音を出してから75ms後に音を止めたい」
これが私にとっての課題です。InvokeもしくはCoroutineはこの課題を解決してくれるのでしょうか。測定にはStopwatchクラスを使用します。今回の測定を行うには十分に高精度です。
どちらも「スペースキー」が押されるとタイマースタート、
一定時間後にタイマーストップをするプログラムです。Invoke(xxx, Time); の第二引数で時間を決めます。yield return new WaitForSecondsRealtime(Time);の第一引数で時間を決めます。Timeの値を変えて、各条件で100回実行した結果になります。　Invokeの誤差は、＋に8ms, －に20msが最大です。
　Coroutineの誤差は、＋に15ms, -に0msが最大です。
　偏差を比べてもCoroutineの方が小さい傾向にあります。
　1ms単位とは言いませんが、±10ms程度のタイマーとしては有効ではないでしょうか。　Coroutineでは最小値が設定値を下回る事がありません。タイマーの時間が過ぎたら実行するプログラムと考えると納得がいきます。しかし、Invokeの最小値は設定値を下回っています。おおよそ60Hzの1フレーム分くらい早めに判定される事があるようです。(理由はよくわからないので、詳しい方補足をお願いします。)　Time=10msではInvokeの最小値が0になる、Coroutineの誤差も最大+15ms(つまり、目標値の2.5倍)となり、正確な値が取れているとは言い難い状況です。Coroutineの方が精度が良いとはいえ、Time=50msでも約15%の誤差がありますので、過信は禁物です。どちらの誤差も総時間によらない固定値にも思えますので、長時間になればなるほど誤差率は下がりそうです。　Invokeでもシビアじゃない環境では十分に使える精度で動作しますが、Coroutineの方が精度よく引数も使えると利点があります。私の課題「75ms音を出す」は「誤差+10ms以内」で達成出来そうです。「この精度で十分かどうか」、それはもちろん使う用途によりますが、このデータが判断の手助けになれば幸いです。


