More than 1 year has passed since last update.この記事ではを使用している VRMのキャラを複数読み込むと、CPU負荷が大きく上がる
Profilerを動かすと、揺れ物として使われているVRMSpringBoneの処理負荷が大きいことが分かる
特にVRoidで作られたキャラは髪の毛の揺れなどに結構ふんだんに使っているため顕著だ
そこで、VRMSpringBoneのC# Job System対応をしてみるオリジナルはとてもJob化しやすいコードなので、特に説明なくJob化したコードを以下に示す上記ソースをVRMSpringBoneOptimizer.csという名前で保存し
VRMSpringBoneOptimizerコンポネントをVRMのルートのGameObjectに追加しておくと機能するランタイムで動的にVRMモデルを読み込んだ場合、VRMSpringBoneOptimizer.Attach(ルートのgameObject);と書けば機能するオリジナルのVRMSpringBoneの単位でJob化しても、一つの処理単位が小さすぎてあまり高速化されない実際のVRMモデルの特徴を見てみると、ColliderGroupは同じものが割り当てられてるケースが多い
そこに着目し、同じColliderGroupを持つVRMSpringBoneを集めてそれを一つのJobの単位としているJobはトランスフォームからrotationを取り出すだけのJob
コライダーの位置を更新するJob
物理計算を行うJobの三つに分け、上の二つが終わったら下の一つが動くようになっているひゃ～めっちゃ綺麗に並列化するようになったぞ。オラおでれぇたぞ pic.twitter.com/s6mxIuMKIlオリジナルの実装から、C# Job Systemで書き直した揺れ物実装に途中で差し替えるデモ10fpsが40fps以上になるただ、C# Job Systemに当てはめづらいパラメータ(Transform m_center)を消去し、gravityなどの値は動的に変更できないようになってるので、あくまで追い風参考値 pic.twitter.com/DoL7PxJtsD(このツイートではm_centerを無視していると書いてるが、今は対応した)Profilerを見るとコア数に応じて綺麗に並列化されていることがわかる
また、実際にWinのIL2CPPビルドでオンとオフを比べるとかなり高速化していることがわかるm_stiffnessForceなどのフィールドはオリジナルだと毎回参照しているが
今回のJob化したプログラムでは最初しか参照しないため、動的に変化させても動作に反映されないTransformへの参照・反映のタイミングがオリジナルと違い、貫通が多く発生している可能性がある初期化部分はかなり適当に書いているのでそこそこ重い処理となっている
今のままだとキャラが出た最初のフレームでかなり処理落ちするかも複数体のモデルに大して適用しないとあまり並列化できないかももっと細かく説明を書きたいところだけど、どっからどう説明したらいいのかわからなくなったのでソースだけ示すことをお許しくださいまた、パッと見はそれっぽく動いてるだけで、そもそもちゃんと実装できてない可能性もあるので、何か問題点などありましたらご指摘くださいMIT LicenseかApache 2.0 Licenseのお好きな方で


