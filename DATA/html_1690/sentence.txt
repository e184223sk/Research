More than 1 year has passed since last update.プログラミングにおける変数のコピーには
・ディープコピー
・シャローコピー
の2種類があります。
それぞれを一言でいうとディープコピー：コピー先の変数を変更しても、コピー元には影響がない上の例では、bを変えてもaには影響が出ていませんシャローコピー：コピー先の変数を変更すると、コピー元にも変更が適用されるbを変えると、aも変わってしまっています。上の例を見て頂ければわかる通り、C#においては「=」で代入すると
int、doubleなどの値型：ディープコピー
配列、Listなどの参照型：シャローコピー
となるようです。そもそものコピーの目的として
「元のデータを変えたくないからコピーしてるんだ！」
という理由が相当数を占めていると思うので、
基本的には
ディープコピーの需要が高い
と思っています。
しかしC#の標準ライブラリには汎用的にディープコピーするメソッドがないので、
実装してみました。
2通りの方法で実装しています。こちらを参考にさせて頂きました。
参考というよりほぼコピペです。
ディープなコピペをしてしまい申し訳ない、、bを変更してもaは変わっていないので、正常にディープコピーできていそうです。コンストラクタを適切に定義すれば、newによりディープコピーができるようです。
ただし、多重に参照している場合、値型にたどりつくまで下層を走査する必要があります。
詳しくは下記参考をご参照くださいbを変更してもaは変わっていないので、正常にディープコピーできていそうです。どんな場合がシャローコピー、どんな場合がディープコピーとなるか調べてみました上の例を見ると、newすればコンストラクタが勝手にディープコピーしてくれるように見えます。
実行例を下記します。bを変更してもaは変わっておらず、ディープコピーされているようです次のような多重リストではどうでしょう？bと一緒にaまで変更されてしまっており、シャローコピーとなっているようです。
直下のリストはディープコピーされるが、そのリストが示す参照先はコピー元と共通、
といった感じと思われます。データベース的な使い方をよくする、自作クラスListに対して、
よくありそうな3パターンに分けてコンストラクタによるnewの挙動を、
調べたいと思います。
パターン1：コンストラクタ定義なし中身が値型だろうが容赦なしでシャローコピーされています
パターン2：コンストラクタ + foreachでコピー値型はディープコピー、参照型（List）はシャローコピーされています
パターン3：パターン2 + コンストラクタのリスト部分のみforeachで1要素ずつ代入ついにディープコピーが実現できました（bを変えてもaは変わらない）
このパターン3は、上の実装例2と同じものです。
結論としては、参照型が内部に存在する場合、値型にたどり着くまで内部を辿ってから代入しないといけないみたいです。
複雑な自作クラスになるとどこが値型なのか探索するのも、コンストラクタの実装の手間も大きそうなので、
実装1の方法がシンプルでよさそうです。※自作リストの場合は上記参照くださいforeachやgroupbyは、逆にディープコピーだとループ内での変更ができず困る場面もありそうなので、
シャローコピーで助かる面も多いかと思います。


