More than 1 year has passed since last update.マイナンバーカードの検証の話です。
#1からの続きです。利用者証明用電子証明書に関するFILEを検証します
公開鍵の取得、秘密鍵で署名、署名の検証です。１．認証用証明書の取得
２．認証用証明書から公開鍵を取り出す
３．署名
４．検証認証用証明書をSELECTして証明書を読み出します。この証明書はPINのロックがないので簡単です。
以下のおまじない(APDU)をSCardTransmitで送信していきます。認証用証明書へのSELECT FILEが成功したら証明書の読み出し(READ BINARY)となります。
証明書はDER形式のバイナリデータで私のカードの場合1,583byteありました。
READ BINARYのポイントは二つDER証明書はASN.1という形式になっており、これが[Tag]-[Length]-[Value]構造の繰り返しになっています。なので、まずは、LengthをGETしてDER証明書全体のサイズを求めます。
結論を言うと最初の4byteをREADすればおｋ。APDUの0x04が4byte READ する、ということです。
Responseの後方0x90, 0x00が成功した、という意味で、0x30, 0x82, 0x06, 0x2BがREADした4byteのBINARYです。READしたBINARYをANS.1の形式でパースします。この部分は[Tag]-[Length]の部分。0x30, 0x82, 0x06, 0x2Bbitにすると0011-00000x82 = Lengthbitにすると1000-00100x06, 0x2B = Lengthブロックサイズが256byteでブロック単位でしか読めないというきわめてハード的なお約束があります。
なんで、何回かに分けてREADします。READするブロックNoを指定するため、APDUを少し変えて何発も送信する必要があります。・・・APDUの3byte目に0～のブロック番号を指定します。こんな感じで256byteずつREADしていきます。
こうしてDER形式の証明書をGETします。ちゃんとGETできたかどうか、確認したいですね。
OpenSSLで証明書の中身を見ることができます。署名検証では公開鍵が必要になります。公開鍵は先ほどGETした証明書の中に入っています。
証明書の中から公開鍵だけを取り出さねばなりません。C#ではSystem.Security.Cryptography.X509Certificates.X509Certificate2クラスのGetPublicKeyメソッドで簡単に公開鍵を取り出すことができます。
しかしトラップがあります。GetPublicKeyでGETした公開鍵はOpneSSLでは取り扱うことができません。
GetPublicKeyメソッドではPKCS#1形式という形式で取り出すようで、OpenSSLで取り扱うにはPKCS#8形式でないとダメなようです。これは非常に不便です。PKCS#1⇒PKCS#8変換の方法を調べてWebを彷徨いましたがよい方法が見つからず、あきらめて思考停止手段を用いることにしました。PKCS#1とPKCS#8の公開鍵のDiffをとって差分を固定で埋める。すなわちPKCS#1のデータに
30820122300d06092a864886f70d01010105000382010f00
という謎のヘッダを付加する。
これでうまくいく。なぜうまくいくかは知らない。ソースはこちらWebを彷徨っていてみつけた手掛かり⇒RSA公開鍵のファイル形式とfingerprintちなみにOpenSSLで DER形式 のPublicKeyを確認するコマンドついでに PEM形式 の場合『とある電子データについての電子署名を作成する』ことです。マイナンバーカードではそれができるのです。自分のハンコを押すみたいなものです。
電子署名に自分の個人情報が入ることはありませんので安心してください。今さっき「マイナンバーカードでは電子署名を作成することができる」としましたが、厳密には間違いです。
マイナンバーカードでできるのは、「与えられたデータを秘密鍵で暗号化する」ことだけです。
認証用鍵にSELECT FILEしてからCOMPUTE DIGITAL SIGNATUREコマンドで認証用鍵で暗号化します。
ただし、認証用鍵にアクセスするにはPINロックの解除が必要です。先にPINロックを解除してから認証用鍵にSELECT FILEしましょう。※PINが1234の場合※1＝PINのバイト数、※2＝PINデータを指定します。
成功するとPINロックが解除されて認証用鍵にアクセスできるようになります。
PINが間違っている場合はResponse=0x63, 0xC?といった値が返ってきます。このとき?にロックまでのリトライ回数が返ってきます。認証用PINのリトライは3回です。3回間違うとロックされてしまいます。復旧は役所に行って申請書書かないといけいないので注意してください。
ちなみに認証成功するとまたリトライが3回に戻ります。リトライ回数だけ知りたいですね。その場合はPINデータをセットしないでVERIFYします。この場合リトライ回数を減らさずにリトライ回数がGETできます。このコマンドでデータを暗号化します。
直前にSELECT FILEしている認証用鍵で暗号化します。※1＝対象データのバイト数(1byte)、※2＝対象データを指定します。
※3＝暗号化されたデータCOMPUTE DIGITAL SIGNATUREで暗号化しますが、いわゆる電子署名にするにはPKCS #1 (RFC 3447)の仕様の通りにする必要があります。
これがまためんどくさいのですが、仕方ありません。以下の手順でRFCに準拠したDigestInfoを作成します。DigestInfoなるデータの構造この構造でバイナリデータを作成します。ASN.1のことを多少知っとく必要があります。
説明すると大変なので、以下の説明を参照ください。かなり端折ってしまいましたが、こうして生成されたDigestInfoをCOMPUTE DIGITAL SIGNATUREコマンドに指定してGETしたデータが電子署名です。署名は検証(Verify)するためにあります。検証してみましょう。「とっても大事な文書.pdf」というファイルの署名を前述の手順で作成し、「とっても大事な文書の署名.sig」というファイルで保存します。
さらに、前述の手順で取り出した公開鍵を「Authentication_PublicKey.der」というファイルで保存します。これらの情報があれば、Verifyの準備は完了です。
Verifyにはマイナンバーカードは必要ありません。コマンド2発です。
1発目でDER⇒PEM変換、2発目でVERIFYです。RSACryptoServiceProviderクラスのVerifyHashメソッドです。
手順をここで書くとまた長くなるので以下のソースを参照ください。
GitHubのソース
↑
public static bool VerifySignature(byte[] publicKeyDER,byte[] signature,string targetFile)
がエントリポイントです。として見てください。参考
C#でRSA暗号を使って署名や暗号化するもうすこしつづく
⇒#3


