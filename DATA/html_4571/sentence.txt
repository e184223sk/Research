More than 1 year has passed since last update.2018/10/10追記
記事を大きく修正しました。
変更箇所は、お手数ですが「編集履歴」を参照してください。本記事の答えに辿り着くまでに、色々な方にご指摘をいただき、大変助かりました（コメント欄をご覧ください）。特に @sumim 氏には、問題と解答を提供していただきましたが、これがなければ本記事を仕上げることは叶いませんでした。深く感謝いたします。試行錯誤する中で、私にとって勉強になることは多く、良い経験になりました。ありがとうございました。本記事は、@sumim 氏が改変して紹介したインディアン・ポーカーに関するプログラミング問題の解法を説明しながら、オブジェクト指向プログラミングに触れてみるものです。私がこの問題を目にしたのは、@gorillab 氏による以下の記事を読んだときでした。オブジェクト指向が5000%理解できる記事
オブジェクト指向が5000%理解できる記事(実践編)両記事は大きな反響を生んだため、ご存知の方も多いと思います。この「実践編」にて、インディアン・ポーカー問題が取り上げられていました。この問題は非情に難しく、また奥が深い問題です。しかし、上記事では大変雑に取り上げられていました。オブジェクト指向の初心者向け解説記事を謳いながら、実質的に何の解決にもならない曖昧な説明で終わっています。対照的に、コメント欄は盛り上がりました。問題の紹介者である @sumim 氏が登場し、解法を示してくださいました。しかし、そこで示された解法が不完全であることに気がついたので、私なりにこの問題を解き、本記事を書こうと思いました。リクルートコミュニケーションズのコーディング試験で過去に出題された問題を、@sumim 氏が改変したものです。問題はこちら → https://twitter.com/sumim/status/1043665621433470977カード { 1, 2, 3, 4, 5 }
プレイヤー { A, B, C }A=1, B=4, C=5 の場合A=1, B=2, C=4 の場合こちらです↓インディアン・ポーカー・ソルバー.NET Core 2.1、C#7.3 です。上記 5 3 の部分には、それぞれカード枚数、プレイヤー人数を指定してください。
（大きな数を指定すると計算時間がかかる場合があります）配るカードを指定する場合はこちらです。私の書いたコードは 5 つのプロジェクトに分割されています。このうち、IndianPoker.Lib だけが重要なので、以下ではこのプロジェクトについて説明します。クラスをどのように分けるかというのは、一種のパズルです。各クラスがどのような意図を持つのか、想像しながら見ていただけると嬉しいです。※ 私のコードの書き方で、アクセス修飾子が internal または private のシンボルに _ アンダースコアのプレフィックスをつけています。ゲームの進行を担います。最初にコンストラクタで、全てのカードに書かれた数字、プレイヤーに配られるカードの数字、全てのプレイヤーの名前、を受け取ります。その情報をもとに、まず _Deck を生成します。_Deck は _Card を生成し、その _Card を _Player コンストラクタに渡します。このとき渡す _Card は、他の _Player が掲げているカードです（このゲームでは、自分のカードを見てはいけない）。Solve メソッドでゲームをシミュレートし、ゲーム中にプレイヤー達が宣言した答えを返します。プレイヤーの名前と、プレイヤーが宣言した答えです。答えの内容です。カードです。カードに書かれた数字を取得できます。デッキです。DeckCards は、プレイヤーに配られるカードがプレイヤー順に格納されています。対して SortedCards は、全てのカードが昇順に格納されています。DeckCards と SortedCards で共通の数字を持つカードは、同一のインスタンスです。プレイヤーです。推論に関する情報である _Inference を内部に持っています。
SayAnswer で、自分の答えを宣言します。プレイヤーが額にかざしているカードです。プレイヤーの名前とカードがセットになっています。今回のソルバーの推論に関わる、アルゴリズムをまとめたものです。各プレイヤーがこの _Inference を 1 つずつ持ちます。自プレイヤーが持つ推論情報は、当然自分のカードを知らない状態にあります。与えられた他プレイヤーのカード情報をもとに、最善手で答えを導きます。答えを導出する Infer メソッドは、orderIndex を受け取りますが、これは、プレイヤーの手番の順序列を生成する _PlayerOrder のインデックスです。次章では、このクラスがどのようにインディアン・ポーカー問題を解決するのかを見ていきます。プレイヤーの手番の順序どおりに、プレイヤー名をイテレートする列挙子を生成します。ルールをもう一度確認します。プレイヤーには、自分以外のカードが見えており、自分の手番が回ってきたとき、自分のカードを予想します。このとき、嘘を言ってはいけません。宣言内容は以下のとおりです。話を簡単にするため、カードを { 1, 2, 3, 4, 5 } 、プレイヤーを { A, B, C } とします。プレイヤー B の答えが確定するのはどのようなときでしょうか。では、A=2, C=5 のときはどうでしょうか。これは、「MIN」の可能性と「MID」の可能性がありますので、分からない「?」と答えます。本当にそうでしょうか。B の手番が回ってくる直前、A は「?」と答えました。もし B=1 だったら、A から見て B=1, C=5 なので、A は「MID」と答えたはずです。そうならなかったということは、B=1 はありえません。ありえないカードを X で表すと、現在の状態は X=1, A=2, C=5 です。これで B の答えは「MID」に確定しました。このとき答えを確定できたのは、ありえないカードである X の存在があったからです。可能性のあるカードから、ありえないカードを除外してゆくことが、アルゴリズムの要となります。話を戻しまして、答えが確定する条件を以下のように決めます。以下、カードとプレイヤーの対応を、次のように表記します。以上の記号をこのように表記します。ここで、B は推論対象プレイヤーです。この表記を「推論テーブル」と呼ぶことにします。この節では、カードを { 1, 2, 3, 4, 5, 6, 7 } 、プレイヤーを { A, B, C } とします。A=3, B=4, C=5 のとき、C がどのように推論するのか考えてみましょう。前述の推論テーブルの表記を用いると、プレイヤー C の推論の初期状態は以下のようになります。ここでは、1 つ前の手番である B に着目することにします。B のカードは 4 です。覚えておきましょう。Possible であるカードを推論の対象とします。Possible であるカードは 1、2、5、6、7 ですが、ここでは 1 と 2 だけに注目してみましょう。推論対象プレイヤー C のカードは 1 である、もしくは 2 である、と考えるのです。ここでは、1 を選択してみましょう。C のカードは 1 である、と仮定します。すると、推論テーブルはいかのようになります。この推論テーブルは、まだ答えの確定条件を満たしていません。次の推論に進みます。B の推論について想像してみましょう。プレイヤー C が想像する、プレイヤー B の推論テーブルはどうなっているでしょうか。今、C のカードは 1 であると仮定しています。そして、B からは B 自身のカードは見えません。推論テーブルは以下のようになります。ここで、C -&gt; B とは C の想像する B の推論テーブルである、という意味です。先程 C で行なったプロセスを再度やってみましょう。前の手番のプレイヤーは A=3 です。Possible なのは 2、4、5、6、7 ですが、ここでは 2 に着目します。B のカードは 2 であると仮定してみましょう。推論テーブルはこうです。今度は、答えの確定条件を満たしています。それは「誰の」確定条件かというと、A ですね。この推論テーブルは B のものなので、前の手番のプレイヤーである A の推論に移ります。そろそろ、ややこしくなってきたと思いませんか。私は思います。こんな難しい問題（しかし解ける）、よく考えつくなーと感心しきりです。今回考えるのは、「「C の想像する B」の想像する A」の推論テーブルです。この条件であれば、答えの確定条件を満たしています。A=&gt;MAX ですね。しかし、思い出してみてください。そもそも、この節で議論を始めたときの前提は A=3, B=4, C=5 でした。A は「MAX」ではありませんし、A 自身、それを分かっています。ですから、A は最初の手番で「?」と答えます。推論テーブルの推論が崩れました。仮定が間違っていたのです。前の推論に戻る必要があります。1 つ前の推論はこうです。ここでの仮定 2:B が間違っていたのですね。ですから、正しい推論テーブルはこのようになります。すると、この推論テーブルは確定条件を満たしています。B=&gt;MAX です。しかし、ここでも推論は正しくありません。前提は A=3, B=4, C=5 でした。B は手番で答えられず、「?」と宣言します。仮定が崩れました。前に戻りましょう。この 1:C が間違っていたことになります。正しい推論テーブルはこうです。これで最初に戻ってきました。やってみると分かるのですが、これも B が「?」と答えた時点で、2:X となります。ですから、C の手番が回ってきた時点での推論テーブルは以下のようになっています。これは、確定条件を満たしています。今度こそ、C は「MAX」と答えることが可能になります。ということで、答えは「A=&gt;?, B=&gt;?, C=&gt;MAX」でした。前節の考え方をすると、最初の状態から次の推論へと移ってゆく際に分岐が発生するため、データ構造としては木構造を形成します。本記事の投稿当初の方法では、推論テーブルを持つノードを木構造の形で保持する、という愚直な実装でした。しかし、@sumim 氏が示した再帰呼び出しによる方法が、よりスマートでした（木構造を構築する方法では、結局正答に至らず）。アルゴリズムのコア部分となるメソッドを掲載します。処理の流れはコメントの通りです。計算量が多いため、メモ化により高速化を図っています。最後に、カード 5 枚、プレイヤー 3 人の場合の出力例をお見せします。順列の生成は IndianPoker.Lib.Utils に含まれています。また、各行の最後に付加された OK ですが、これはデバッグのため、宣言された答えが配られたカードと比較して正しいかどうかを出力したものです。コメント欄で議論となりましたが、答えが出るまでのターン数は結局求まりませんでした。Impossible の条件が複雑で追いきれませんでした。実装したプログラムでは、前述の通りのやり方で必ず収束するため、ターン数は不要となりました。計算量が膨大なため、実行時間がかかります。本物のインディアン・ポーカーはカード数 53 枚ですが、プレイヤー数 2 のときは答えを導けるものの、それ以上の人数では 53 枚に対応することはできませんでした。LINQ を多用しているため、元々速度は最適化されていませんが、計算量のオーダー自体に問題があると思います。オブジェクト指向は大変難しいです。特に、このような難解な問題を解こうとする場合、答えが分かっていないと、確固たる設計をするのは不可能です。しかし、オブジェクト指向はまた、このようなケースに対してアルゴリズム部分をブラックボックス化する力も持っています。ですから、最初に設計を決めることは可能で、しかし作り込んでゆくうちに設計が変化してゆく場合がほとんどだと思います。よく、コードを書かない SE の存在を耳にしますが、コードを書かずに設計なんてできないというのが私の考えです。コードを書いてオブジェクト指向力を磨きましょう。私も精進します。


