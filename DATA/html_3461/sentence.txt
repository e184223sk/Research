More than 1 year has passed since last update.DisplayPort接続でウィンドウ位置やアイコン位置が変わることに対して文句を述べる輩がいる。
それ自体は別に構わないが、思考停止して解決策を考えなかったり、
Displayportをこき下ろして映像コンテンツ協会がゴリ押しするHDMIに魂を売り渡したりするのはよろしくない。
Displayportは正しく使えばとっても便利なんだ。
あと(無償な)ソフトウェアじゃなくて(有償な)ハードウェアで解決するってのもプログラマとしては納得いかないことだろう。解決策?
簡単さ。解決しない。
位置がずれたら戻せばいいのさ。
これはコロンブスの卵でも何でもない。ソフトウェアの名前はDisplayPortをもじってDisplayQortにした。
全てのコードはgithubで見てもらうとして、
自分で解読できなくなる前にコードの抜粋とメモを残しておく。とりあえずC#で書いてみたのだが、普段ライトに書くC#と違って仰々しい構文が続く。enum SWは明らかにWindows APIに与える引数っぽい。
初心者が言うところのおまじないとして使ってる[StructLayout(LayoutKind.Sequential)]文字列。
おそらく構造体の中でのメモリ配置の順番を書き順通りに強制するみたいな意味だろうが(仕様を調べる気はないので間違ってるかもしれん)
そんなことまで考慮しないといけないとか頭が痛くなるばかりだ。ここが今回の一番の深淵。C++で書けばここへのアクセスは楽なんだろうが、
その先のGUIまでが果てしなく遠いのでC#のが無難かと。hwnd恐怖症になりそうです。
c++11なんてなかった頃のWindowsアプリのプログラミングはこんな感じだったけど、
これを見て初心者にプログラミングするならc++はいいぞなんて言えるだろうか。
私は無理だ。なんだこのクソ言語はと思う。
(c++はASCII以外の文字列を扱うのも壊滅的なので実用的なアプリなんて無理だ)
pythonはいいぞ。(当時pythonはなかったけど)先のAPIを直接叩くのは筋が悪いのでC#で使いやすい形にラップしよう。これは難しくない。コンストラクタはただ値を代入してるだけだし。Screenは確かusing System;で使えたはず。
Screen.AllScreensで全てのモニタのリストになるからsは一つのモニタを表す。
それをforeachで先程のScreenObj構造体
(classで書いているけどデータを入れるという概念としての構造体)に入れてリスト化している。
つまりコンストラクタを呼べばその時点での全モニタの状態を取得できるコード。これは等号演算子のオーバーロードだ。
全モニタの状態が等しいとはどういう状態を意味しているのか。
それを考えると、まずモニタの数が等しいことを確定させてから
各モニタの座標をチェックする。全て等しい時のみ等しいとする。
こんな感じのロジックとなるだろう。
GetHashCode()はよくわからんけど必要だったような。これもただの構造体ですね。
型は怪しげなものが入っているけど。ラップしているとはいえ、モロWindows APIなコード。
どこかのコードをコピーしてきてうまく動いたものを採用している。
コールバックだからモニターの変更に対して関数が呼ばれる機構を作っているのだろうが、
このコードの意味は正直わからん。本来やりたかったことはこの部分のはずだ。
なのにそれを実現するためにどれだけの下準備コードが必要になったのか。
OSが絡んだりc, c++でハードウェアをいじろうとすると大体こうなる罠。モニターとウィンドウの状態を定期的に保存してモニターの変更を検知すればダイアログを出し、
モニターの状態を元に戻した上でウィンドウの復元をすればよいはずという考え。私自身がDisplayportでのトリプルモニタ環境で不自由しない状態になったので
これ以上このソフトに手を加えるつもりはないが、
複数のモニタの着脱や物理的な位置移動を頻繁にするならば、
ウィンドウセットの概念を入れてウィンドウ集団のモニタ移動を容易にしたい。
GUIをもう少しリッチにとか。


