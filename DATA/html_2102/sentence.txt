WPFでPrism 使うと ViewModel は自動紐づけしてくれるけど、そのままだとメソッド単位のトレースとか自前でやる必要がある。そうするとメソッド本体のロジックに無関係の物が紛れてしまうし、早期リターンとかするたびに logger.Trace("exit") と書き続けなければならないので少々面倒。そこで ViewModel も Interceptor注入対象にしてトレースやらトランザクションやらを勝手に組み込めるようにしたい。ここでは .NET Framework 4.6.1 + Prism.WPF 6.3 が対象。単純にメソッド実行前後でトレースをしゅうWPFでPrism 使うと ViewModel は自動紐づけしてくれるけど、そのままだとメソッド単位のトレースとか自前でやる必要がある。そうするとメソッド本体のロジックに無関係の物が紛れてしまうし、早期リターンとかするたびに logger.Trace("exit") と書き続けなければならないので少々面倒。そこで ViewModel も Interceptor注入対象にしてトレースやらトランザクションやらを勝手に組み込めるようにしたい。ここでは .NET Framework 4.6.1 + Prism.WPF 6.3 が対象。単純にメソッド実行前後でトレースを収集するような InterceptorBootstrapper では DIコンテナを設定する。
(Prism 7以降では DIコンテナの設定は App.xaml.cs に移動している)ここでは単純に数値をインクリメント、デクリメントするだけのViewを使う。SampleView のViewModelReactivePropertyとトレース対象メソッドは virtual にしないと Interceptor が認識できない。RegisterForNavigation だけだと最初のViewのロードがうまくできないらしいので、最初のViewへの移動を MainWindow.xaml.cs で行う。まあ、いつも使う設定でよい。単純に実行してボタンを押してみる。Prism 7 以降だと Autofacが使えない。Unityでは Interceptor の作り方が違うので、同じ Interceptor を使いたい場合は DryIoc に移行することになる。ここのサンプルではすべての ViewModel が Interceptor 組み込み対象になっているが、クラスやメソッドに属性を追加してIntercept対象かどうか判定したほうが良い。このサンプルだとうまくいっているはずだが、 ReactiveProperty を使わないでバッキングフィールド付きのプロパティにした場合などにプロパティの更新がうまくいかないように見える場合がある。この場合はなどしてみると良い。


