以前DiagnosticSourceについて記述したが、DiagnosticSourceはあくまでもイベントの発生と、そのイベントの捕捉の仕組みしか提供しないので、最終的にどのように出力するかどうかはユーザーの裁量に大きく任される。DiagnosticListener.AllListenersをSubscribeして出力するのが標準のやり方だが、ここではEventSourceを通して出力する方法について書いておく。なお、この記事は.NET 5.0-rc1を元にして記述しているため、今後のリリース等で仕様が変わるかもしれないことに注意。DiagnosticSourceの記事でも触れているが、DiagnosticSourceの先輩のようなもので、.NETFramework時代から存在するもの。
元々ETWに乗っかった仕組みではあったが、クロスプラットフォームにするため、EventPipeという仕組みを.NET Core 3.0より使用するようになり、OS問わずに制限なく使用できるようになった。DiagnosticSourceよりも優れている点として、外部から情報を収集するための仕組みがあるため、後付けで情報収集を行うことが可能となっている。(例: dotnet-trace、Application Insights(Azure)等)EventPipe等の仕組みについて、ずばりこういうものであるという資料は無いものの、個別のIPCプロトコル等については dotnet/diagnosticsリポジトリのdocumentationに記述があるので、詳細を知りたい人はこちらで(winでは名前付きパイプ、linuxではunixドメインソケットを介して接続できるらしい)。
頑張れば自分で出力機構を自作することも可能。
この辺りは、dotnet/diagnosticsのクライアントライブラリのドキュメントと、perfviewが提供しているパーサーに関するドキュメントが参考になるかもしれない。DiagnosticSourceについては直接収集することはできないが、DiagnosticSourceはEventSourceでイベント出力する機能があるので、それを通してイベント情報を取得することができる。まず、下記のようなDiagnosticSourceがあるとするこのようにすると、C1.A()の実行時にイベント"ev1"が発生するようになる。そして、このC1.A()を実行するような処理を netcoreapp3.0以降のアプリ側で作成する。準備としてはこれだけである。特に追加の実装はアプリ側には必要はない。DiagnosticSourceのイベントは、全てMicrosoft-Diagnostics-DiagnosticSourceというプロバイダ(内部的にはEventSource.Name)から出力される。
なので、収集ツール側はEventPipe Providerとして、この名前を指定して収集を行う。監視開始時に指定できるパラメータとしては、がある。
イベントレベルについては、EventLevel.Informationalに固定となっている。
イベントキーワードについては後述。
追加パラメーターとして、イベントのフィルタリング等を行う"FilterAndPayloadSpec"があるが、これは仕様が複雑なので後述する。収集するイベントに設定されるビットフラグで、16進数の数字を入れる(最大8桁)
Microsoft-Diagnostics-DiagnosticSourceには以下のようなキーワードフラグが存在する通常使う分にはEventsを含めておけば問題はない。この書式については後述の"FilterAndPayloadSpecについて"を参照この書式については後述の"FilterAndPayloadSpecについて"を参照今のところFilterAndPayloadSpecのみだが、これが結構複雑。特に指定しない限り、"全てのDiagnosticSourceイベントを捕捉し、ActivitySourceは捕捉しない"という意味になる。どのイベントを監視するか、また、イベントできたデータをどのように解釈するか、という事を設定する。
特に指定しない限り、"全てのDiagnosticSourceイベントを捕捉し、ActivitySourceは捕捉しない"という意味になる。
ここで紹介するのはごく基本的なことなので、詳細が知りたい場合は、実際のDiagnosticSourceEventSourceのソースを確認するのが良いだろう。どのようなイベントを捕捉するか、また、捕捉したイベントのパラメーターをどのように解釈するかを指定する
書式は、DiagnosticSourceの場合、[DiagnosticSourceの名前]/[イベント名]@[EventSource名]:[変換先パラメーター名]=[変換元パラメーター名];[変換先パラメーター名]=[変換元パラメーター名]のように指定する。
全て書くと長いが、必須なのはDiagnosticSourceの名前のみ。[DiagnositicSourceの名前]で指定したものを捕捉対象に入れる。ここにはDiagnosticSource.Nameの名前を使用する。ここにはDiagnosticSource.Writeで指定する名前を入れる。[EventSource名]の部分は少々わかりにくいが、Activity1Startなどと記述することによって、同イベントをActivity1Startとして捕捉するという意味である。この辺りの記述が無い場合は、イベントは全てイベントID=2の、イベント名="[Activity名].[StartまたはStop]"として処理される。これを、DiagnosticSourceごとに CRLF区切り で記述する。
つまり、Diag1とDiag2の両方を検出したい場合は、のようにパラメーターを設定する。プログラム上であればStringBuilderで設定可能だが、コマンドラインで指定したい場合などは注意が必要。また、デフォルトではActivitySourceのイベントが捕捉できないが、ActivitySourceのイベントを追加したい場合は、同パラメーターの頭に[AS]を追加する。
この時、特別な記法として[AS]*を指定すれば、全てのActivitySourceのイベントを捕捉することが可能。
例として、Act1なるActivitySourceを追加したい場合は、のように記述する。今回紹介するMicrosoft-Diagnostics-DiagnosticSourceのイベントレベルはInformational固定だが、
一応他にもどのようなものがあるか、以下に列挙する。正確なリファレンスは公式ドキュメントを参照EventSourceの出力を捕捉する方法は色々あるが、ここではdotnet-traceによる方法を紹介するdotnet toolとして提供されているので、dotnet-sdkをインストールして、dotnet tool install -g dotnet-traceでインストール可能($HOME/.dotnet/toolsにパスを通す必要がある)以下のようにして情報を収集する。以上で、イベント情報を記録したトレースファイルが生成される(デフォルトはtrace.nettrace)。
なお、アプリを起動したと同時に監視を開始する、という機能はないため、スタートアップ時のイベントログ等は取得できない場合があることに注意追加オプションの書式は、[イベントキーワード]:[イベントレベル]:[K=V形式で指定される追加パラメーター]となるFilterAndPayloadSpecsは改行を含むため、シェルによっては値を渡し辛い場合がある。
dotnet-traceはアプリ実行基盤にSystem.CommandLineのフレームワークを使用しているため、応答ファイルを用いて読み込ませることができる。
まず、下記のようなテキストファイルを用意するなお、改行は、\r\nで表現できる。
ファイルが用意出来たら、以下のようにして実行する。イベント情報の閲覧は、Perfviewで閲覧可能。PerfviewはWindows専用だが、chromiumのトレースファイル形式(Chromium)や、SpeedScopeの形式に変換することも可能なので、Linux上でのログ閲覧も可能。ただし、一次フォーマットはnettraceなので、他二つの形式は情報が欠落する可能性があることに注意。実際はDiagnosticSourceとActivitySourceは、直接どうこうするよりもopentelemetry等、よりユーザーフレンドリなライブラリを通して間接的に利用していくことになると思うが、それでも何かあったとき、アドホックに情報を得られる手段があるのは良いことだと思う。
後、個人的にはActivitySourceは別個のEventSourceを持った方が良かったとは思う。


