恥ずかしながら未だにWinForms案件ばかりでWPF、ましてやMVVMなんて使ったことがない時代遅れなプログラマーです。恥ずかしい・・・そんな私の元にも遂にWPF案件が舞い降りてきてしまった。
ここ数日「WPFでどうやって作るねん」から調べ始めて、今さらMVVMという存在を知り、「MVVMってなんやねん」をずっと調べているけど・・・なんだかよく分からない！「View-ViewModel-Modelに分けて作りましょう」
「テストしやすくなるよ」
とかざっくりとは分かる。
でも具体的なその分け方が調べていても人によって微妙に違って何が正解か分からない。1
そもそも正解なんて無いのかもしれない。で、考え込みすぎて訳が分からなくなってきたので、自分なりの考えを整理するためにも、MVVMについて書いてみることに。WinForms脳な人間がMVVMについて数日調べただけの内容なので間違えてる部分が多々あるかもしれません。その時は優しく教えてくれると嬉しいです。優しく・・・ V-VM-Mの分け方について調べているだけだと明確な物が見えてこないので、視点を変えて
「なんでMVVMに分けるのだろう？」
という目的から考えてみることにした。画面とコードがくっついてるとユニットテストがし辛い。
そこで画面(View)とコード(ViewModel/Model)に分離してやるとやりやすくなる。なるほど、たしかに。画面(View)とコード(ViewModel/Model)が分離してると、デザイナは画面(View)、プログラマはコード(ViewModel/Model)と明確に分業できる。もっともウチにはデザイナなんていない。画面(View)とコード(ViewModel/Model)が分離してると、画面(View)を用意するだけで他のプラットフォームに対応できる・・・かもしれない。
と言うのも、これについて触れられている情報を殆ど見かけなくて、あくまで勝手なイメージ。
ただ理論上は可能なはず・・・2恐らく大まかにこの３つが目的で、特にテスタビリティ向上が重要っぽい。
あれ？これらの目的って、とりあえず画面さえ分離しちゃえば一応は満たせる？
そのせいでV-VM-Mの分け方が曖昧なんだろうか。↑に挙げた目的を元に、まずはどんなプロジェクト構成が理想的かを大まかに考えてみる。あくまで最小の基本構成。DIコンテナとか画面遷移とか考え出すと多分これじゃあ足りない。Viewとアプリケーションを定義・実装するプロジェクト。
ViewをMvvmTest.Viewsプロジェクトに分けるのも有りかも。意味があるかは謎。
あとこれをMvvmTest.NetCoreにして、XamarinでMvvmTest.iOSとか作れると幸せ。ViewModel と Model を定義・実装するプロジェクト。
.Net Standardにしたい！！3
MVM・・・もう少し良い名前はないものか。
MvvmTest.ViewModelsとMvvmTest.Modelsに分けるのも有りかも。意味があるかは謎。
ViewModel と Model は同じ階層で近い位置にいた方が便利のような？次にView、ViewModel、Modelそれぞれの役割を大まかに考えてみる。画面。それ以上でもそれ以下でもない。
ViewModelが提供するプロパティに沿って画面を定義する。
デザインに関すること(XAML)以外は書きたくない。ロジック。やるべき処理をやる人。
ViewModelからパラメータを貰って処理を行う。
どんなデザインの画面かは知らない。4画面とロジックを結ぶ橋渡し役。
画面からどんな情報が欲しいか定義して、ロジックの求める形で情報を渡して、ロジックから結果を貰って、結果を画面に渡してあげる。
大体どんな画面か知っていて5、画面寄りの処理（入力チェックとか）はこの人がやるべき？（不明瞭）↑の役割をふまえて、View、ViewModel、Modelがそれぞれ持つべきもの（やるべきこと）を大まかに考えてみる。今まで考えたことをふまえて、実際にコードを書いてみる。
数値を２つを渡して実行すると足し算した結果が返ってくる超単純なアプリをMVVMで作ってみた。まずは画面は気にせずやるべき処理を書いてみる。２つの数字を受け取って足し算するだけ。ややこしいのでパラメータエラーはなし。
因みにViewModelBaseクラスにプロパティ変更通知が実装されていて、Property&lt;T&gt;のSetValueで良い感じに通知してる。
IMainModelは、MainModelの定義そのまま。次に画面を想像しつつModelと繋ぐViewModelを書いてみる。
数字を入力するテキストボックス２個(ParamA,ParamB)と、実行ボタン１個(SumCommand)と、結果を表示するラベルが１個(Answer)かな。Viewからデータを受け取って、Modelに渡せるデータかチェックして、SumCommandの有効・無効を制御。
SumCommandの処理でModelにパラメータを渡して実行。
Modelのプロパティ変更通知で結果を取り出してViewModelに通知。独自のクラスが多くて分かりにくい・・・
ひとまずProperty&lt;T&gt;には検証機能もあって、Commandクラスには指定したProperty&lt;T&gt;のエラー状態と連動して有効・無効が勝手に切り替わる・・・くらいのイメージで・・・8最後に画面。
ViewModelに従って数字を入力するテキストボックス２個と、実行ボタン１個と、結果を表示するラベルが１個。画面のデザインと、ViewModelが誰かと、コントロール毎のバインディングを定義するだけ。生成されたコードそのまま。絶対に触らない（鉄の意志）mitsu-at3/MvvmTest: Mvvm Test Project
仕事でGitLabは使っているけど、GitHubは初めて使った・・・（今さら）色々と調べたりMVVMの目的を考えると、この分け方が１番しっくり来るけど、合ってるのか分からない・・・
特にViewModelに定義するViewからデータを受け取るためのプロパティの型を、例えば数値入力でもテキストボックスならstring型みたいに、Viewのコントロールの都合を考慮した型にするのが正しいのかどうかが謎。
調べても明確にそういう考え方してる情報に出会えなかった。ただViewModelのプロパティをintにしてしまうと、Viewの段階で入力エラーが出てしまって、そのままだとViewModel側でエラーを検知できないから、ViewからViewModelに伝える仕組みが必要になってしまう。
でもViewにはなるべく余計なものは書きたくない。
って考えると、ViewModel側はとりあえずstringで受け入れて、入力チェックはViewModel側でやるのがベター？9最後に調べてるときに見かけた情報で「それ合ってるの？」と気になったことなど。
あちこちの情報をひたすら漁ってる中で見かけた情報なのでどこで見たのかは覚えてない・・・10Modelの意味を勘違いしてるのか、ロジックはこれから実装するつもりだったのか・・・必ずしも同じ必要は無いのではなかろうか？
同じだとViewModelが架け橋する意味も薄くなっちゃう。
ViewModelとModelの関係が崩れなければ、違っていても良い気がする。↑と似ているけど・・・入力チェックも何もない画面なら有りなのかもしれないけど、ここまで来るとVMとMを分ける意味がないような・・・
超小規模なプロジェクトならModelなしも有り？なんやかんやの仕組みがあって自動的に依存性注入で渡ってくるならこれも良いと思う。コードビハインドには書きたくない！！！ViewModelがModelに依存するのは間違いじゃないので、素直にこっちの方が良いような。これが正しいのかが１番分からない。
今までの考えからすると、View-ViewModel-Modelは１つのセットと見なして、生存期間は同じにしておく方が自然のような気がする。
シングルトンで扱いたい機能は、Modelよりも下に定義して、Modelの中でそのシングルトンクラスを使った方がMVVMの関係性が明確で分かりやすくない？でも厳密には「ViewとViewModel以外全てがModel」らしいから11、シングルトンでも間違いではないのかな・・・
個人的には少なくともViewModelが参照するModelは、生存期間を同じにしておきたいなあ。長々と書いていて「こう考えるのが正しいのではないか？」というのはところまでは来たけども、まだ確信を持って「この考えで正しい！」とは言えない・・・
しっくりは来てるんだけどなあ。
でも序盤に挙げた「目的」を明確に認識しておくだけでも「その形が間違ってるか？」の判断材料にはなりそう。
少しは最新の開発スタイルに近付けただろうか・・・？あと画面遷移とかダイアログ表示とかDIコンテナとか調べだすと、Prismとか外部フレームワークに頼りたくなる理由が分かってきた・・・
何となく自力でも実装できそうな雰囲気だけど、かなり面倒そうな印象。MVVMについて調べる中で初めて「DIコンテナ」を知ったのだけど（今さら）、解説を読んだときに真っ先にあいつを思い出した・・・取得したいInterfaceの情報を渡すとインスタンスが返ってくるってこれじゃん。
そう思うと急に親しみが湧いてきたのでした。おしまい。理解力が足りないだけかもしれない。 ↩Xamarinを使えば出来たりしないかな？（Xamarin未経験） ↩.Net Standard大好き ↩何をする画面かは知ってる。じゃないと何の処理をすれば良いのか分からない。あくまでデザインを知らないだけ。 ↩このパラメータはテキストボックス的なやつで、このパラメータはチェックボックス的なやつで・・・みたいな。 ↩Viewがバインディングするところでエラーが出ないようにするべき？（数値入力前提のテキストボックスでも、とりあえずstring型のプロパティで受け取るとか） ↩Modelの処理に依存するエラーは知らない。あくまで「渡せるかどうか」だけ。 ↩INotifyPropertyChangedやINotifyDataErrorInfoはどういう実装が便利だろう？とお試しで作ったクラス。実際にこれで良いかは分からない。（全容はGitHubで・・・） ↩stringにしておけばどんな入力でも受け入れられるテキストボックスだからってだけで、どんな型にしてもエラーが発生しうるコントロールの場合は、View→ViewModelの通知は避けられない？ ↩ただその情報のせいで余計に混乱した ↩混乱の素 ↩


