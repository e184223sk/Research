More than 3 years have passed since last update.Genericは大変便利ですが欠点もあります。Genericな変数に対して四則演算などができないという欠点があります。このコードはコンパイルエラーになります。Tにどんな型がくるかわからないので当然といえば当然です。しかしTが＋演算子に対応している場合（Int,Decimal,独自のVectorクラスとか）は値を足してその結果を返して欲しいです。対応していない場合（例えば独自のPersonクラスとか）は例外を投げてほしいです。ExpressionTreeを使うと動的にAdd演算を行うことが可能です。任意の型2つをAddするFuncを作成するには以下のように記述します。これでAdd演算をGenericに対して実行できるようになりました。TがAdd演算子に対応していない場合は例外が発生します。作成したメソッドを使うとという形でAddができるようになりました。Subtract演算用のも作ってみます。Expression.AddがExpression.Subtractになるだけなので簡単です。コードをよく見ると共通化できそうです。Expressionを引数で受け取るようにしてメソッドを共通化します。これによりExpressionを渡せばやりたい演算が可能になります。次のセクションでは二つの型が違う場合について解説します。2つの型が違う場合のAdd演算としてDateTime型とTimeSpan型のAdd演算があります。Expressionを使うとという形になります。今度はInt16とInt32でやってみます。例外が発生します。これはInt32とInt16を足し合わせる演算子が定義されていないためです。しかしInt16からInt32への変換は安全であり、暗黙的なキャストも定義されているのでこれを使用してうまいことやってほしいところです。そこで以下のようにCreateExpressionメソッドを改良します。これでTResultに変換可能な場合はうまいことやってくれるようになりました。Expression.Lambda&lt;&gt;.CompileによるILコードの動的生成でのFuncの作成はかなり重い処理になり、何回も呼ぶとパフォーマンスが低下します。今回の場合、TArg1, TArg2, TResultごとでキャッシュしておけばよいのでキャッシュ用のクラスを作成します。Dictionaryを使用する方法が思い浮かびますがもっと高速なGenericクラスのstaticプロパティでのキャッシュを行います。Dictionaryだと実行時にキーの走査が必要ですが、Operator&lt;...&gt;クラスを定義することでコンパイル時に使用する型の分だけ動的にクラスが生成され、そのクラスを直接呼び出すILコードが生成されます。ですのでこっちのほうが高速です。staticコンストラクタにコンパイル処理を書いています。このクラスへの初回アクセス時に動的にILコードを生成しキャッシュします。使用するにはこんな感じです。これで四則演算するGenericなメソッドを作って活用できるようになりました。using staticを利用すればより簡潔に記述できます。Operator.csをコピーすれば動きます。ご利用は自由にどうぞ。
Operator.cs以外は脳内デバッグしかしてないのでうまく動かないよとか認識違いなどありましたらまたコメントください。修正します。以上です。


