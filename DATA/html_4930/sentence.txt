.NET 6の開発進展を伴い、C# 10の最終機能もようやく決定され、デイリービルドに実装されました。今回の更新は主にタイプシステムの改善ために出来ました。じゃあ早速見に行こう。まずはstructレコードです。C# 10以前はレコードをstructに適用できませんでしたが、C# 10以降は可能になりました。例えば、ある点の定義は以下のような書き方は可能です:そうすれば、ToStringやGetHashCodeやEqualsは自動的に実装され、とても便利です。レコードの型でToStringをオーバーライドするときにsealed修飾子を追加できます。ToStringをsealedにすると、コンパイラで派生レコード型に対してToStringメソッドを生成できなくなります。 C# 10では、Structのコンストラクターはパラメータなしでも構いません。が、new Foo()とdefault(Foo)も同じではなくなりました。上記の例には、new Foo().Xは1であり、default(Foo).Xは0です。withを使用して、新なオブジェクトを作成できます。global usingを使用すると、プロジェクト全体の使用が可能になり、各ファイルを書き込む必要がなくなります。 たとえば、Import.csを作成して次のように書き込むことができます：そして、プロジェクト全体でusing Systemは必要がなくなり、i32を使用できるようになります。 以前は、名前空間を書き込むために括弧のレイヤーを配置する必要がありました。C# 10ではファイルに名前空間が1つしかない場合は、それを直接先頭に書き込むだけは可能です。例えば：C# 10では、すべてのプレースホルダー自体が定数文字列の場合、文字列補間を使用してconst文字列を初期化できます。文字列補間では、アプリケーションで使用される定数文字列を構築するときに、より読みやすい定数文字列を作成できます。この改善は非常に大きいと言えますので、複数のポイントで紹介します。関数は暗黙的にデリゲートに変換できるため、関数はファーストクラスになります。C# 10では、lambdaはデリゲート型を自動的に作成するようになったので、型を書き出す必要はもうありません。属性CallerArgumentExpressionがついに実装されました。この属性を使用すると、コンパイラは呼び出しパラメータの式文字列を自動的に入力します。Foo(4 + 5)を呼び出すと、4 + 5 = 9が出力されます。この変更により、以前のバージョンのC#からの制限がなくなります。以前は、分解ですべての値を既存の変数に代入したり、新しく宣言された変数を初期化したりすることができました。この機能は、.NET 6でプレビュー機能としてリリースされます。つまり、デフォルトでは有効になっていません。&lt;LangVersion&gt;preview&lt;/LangVersion&gt;と&lt;EnablePreviewFeatures&gt;true&lt;/EnablePreviewFeatures&gt;を設定して、nugetパッケージSystem.Runtime.Experimentalを追加すると、この機能は有効になります。 そして、インターフェイスは抽象静的メソッドを定義でき、.NET型システムは仮想静的メソッドを遣う機能を備えています。たとえば、+演算子がありゼロを持つインターフェイスIMonoid&lt;T&gt;を定義するとします。MyIntとして実装：次に、IMoniod&lt;T&gt;を合計するメソッドの実装：使用：System.Runtime.Experimentalには.NETの基本型の改善が含まれています。すべての基本型は、数値型のINumber&lt;T&gt;の実装など、対応するインターフェイスで実装されます。インターフェイスの静的抽象メソッドのサポートは、将来C#に追加されるシェイプ機能を補完します。その時点で、C#はインターフェイスとシェイプを使用してHaskellのclassとRustのtraitような機能をサポートし、型システムを大きく改善しますのでご期待を。属性はジェネリックをサポートしました。が、この機能は.NET 6でプレビュー機能としてリリースされますので、&lt;LangVersion&gt;preview&lt;/LangVersion&gt;は必要です。使用：C# 10では、特定のタスクのような型を返すすべてのメソッドに対してメソッドビルダー型を指定するだけでなく、1つのメソッドに対して別の非同期メソッドビルダーを指定することもできます。 これにより、特定のメソッドでカスタムビルダーのベネフィットが得られる高度なパフォーマンスチューニングシナリオが可能になります。以前は、#lineはファイル内の行を指定するためにのみ使用できましたが、行、列、および範囲を指定できるようになりました。これは、コンパイラーやコードジェネレーターを作成する人にとって非常に便利です。以前：C# 10：以前は、C#の文字列補間はstring.Formatであり、値型パラメーター用に直接ボックス化されていました。これは、パフォーマンスに影響を与えるだけでなく、有用性も限られていました。C# 10では、文字列補間が改善されました：上記のコードは次のようにコンパイルされます：上記のDefaultInterpolatedStringHandlerは、InterpolatedStringHandler属性を使用して、それを独自の補間ハンドラーに置き換えて、補間の実行方法を決定することもできます。そのため、パフォーマンスも機能も大幅に強化されています。


