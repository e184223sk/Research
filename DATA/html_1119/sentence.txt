More than 1 year has passed since last update.フェイクデータを表示するHeroesコンポーネントを作成しました。
リファクタリングします。テストのしやすさから考えると、アプリを構成する部品はそれぞれ関心が分離している方がよいです。
コンポーネントがデータの保存方法について関知しないようにします。サービスクラスを作成するにあたり、プロジェクトをどのようにするかが悩ましいです。今は以下の2つのプロジェクトがあります。WASMプロジェクト以外からも使うのであれば、別プロジェクトを用意しないとですね。
今はプロジェクトを分けずに進めます。テスト時にモック化しやすいように、インターフェースとコンクリートクラスを作成します。実際には、WebサービスやLocalStorageからデータを返します。
ここではモックです。コンポーネントヘインジェクトできるように、DIコンテナへ登録します。DIコンテナへの登録は、Program.csファイルの中で行います。作成したサービスを使うようにコンポーネントを更新します。インスタンス変数を宣言のみにします。DIコンテナへ登録したHeroServiceをコンポーネントで使用できるようにします。@inject の引数ひとつめが型、ふたつめが変数名です。サービスからヒーロー達を読み込むメソッドを追加します。コンポーネントの準備が整うと OnInitialized メソッドが呼ばれます。このなかでヒーロー達を読み込むようにします。現実世界のアプリでは、ヒーロー達の読み込みがいつ終わるかわかりません。
いつ終わるかわからないものを待つことはできないので、非同期化します。GetHeroesメソッドを変更してTaskを返すようにします。GetHeroesをGetHeroesAsyncに書き換えて、awaitするようにします。OnInitializedの非同期版であるOnInitialiedAsyncを使うようにします。ここでは次のことを行います。dotnetコマンドを使ってMessageコンポーネントを作成します。Indexページを編集して、Messageコンポーネントを表示するようにします。インターフェースとコンクリートクラスを作成します。DIコンテナへ登録します。コンポーネントではない場合は、コンストラクタインジェクションになります。GetHeroesメソッドを変更します。Messageコンポーネントを変更してメッセージを表示するようにします。OnInitializedの中で、MessageServiceの状態変化を受け取るハンドラStateHasChangedを登録しています。
登録を解除できるように、IDisposableを実装しています。ヒーロー選択時に、メッセージを追加するようにします。Heroesコンポーネントからメッセージを追加していますが、Messageコンポーネントに反映されません。
これを解決するには、2つやることがあります。状態変化を通知するイベントを定義します。状態が変化したとき、イベントハンドラを起動するようにします。OnInitializedのなかで、StateHasChangedハンドラを登録します。
コンポーネント廃棄時にハンドラを登録解除するため、IDisposableを実装します。
Disposeのなかで登録解除します。


