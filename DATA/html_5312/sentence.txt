More than 3 years have passed since last update.以下のような○を組み合わせた逆三角形に「横に並んだ２つの数の差(正数)をその下の○に入れる」という条件を満たして、1～ｎまでの数字を配置します。
例えば、3段の三角形の場合は、以下のように 1～6までの数を入れれば、条件を満たせます。では、5段の三角形の場合は、どのように配置すれば良いのか考えてください。データをどのよに表現するかが問題になりますが。ここでは三角形を以下のように変形させています。○○○○○
○○○○
○○○
○○
○かつ、これを一次元のList&lt;int&gt;で表現し、C#のインデクサの機能を使い、2次元配列のようにアクセスできるようにしています。
例えば、this[0,0]は、一番左上の○を示し、this[1,3]は、2段目の一番右の○を示します。解を求める方法ですが、まず一番上の5つの○に数字を入れます。1段目の数字が決まれば、残りの段の○は引き算をして埋めていくことができます。これで得られた15個の数字が、1～15で成り立っているかを調べています。ようは１～15の中から5つを選ぶ順列の応用といった感じですね。
今回のプログラムでは、深さ優先の探索で再帰的処理で順列を求めて、5つを選んだらそこから三角形を作って、条件を満たしていたら正解とし、yield returnでその答えを列挙しています。１～15の中から全て使った順列をつくり、それが条件を満たしているかを調べるという方法もありますね。ただ、この方法での実装は試していません。Solverクラスの_Solveメソッドが、実質的な解を求めているメソッドとなります。以下のような流れで処理が進みます。4段(stps==4)の場合は、_baseLineは以下のように変化します。_baseLineに格納されている数が、_Solveを再帰的に呼び出している深さと一致します。LINQ、IEnumerator、yield returnなどを使ってるので、これらに慣れていない方はちょっと分かりにくいかもしれませんね。C#のコードは、任意の段(2段以上)に対応できるようにしていますが、6段以上の三角形で解を求めようとするとかなりの時間がかかります。２つの解が求まりました。ただし、解が鏡像なので実質的に一つですね。でも、ちゃんと解があるってことがすごい不思議というか面白いです。steps = 6 以上だと時間がかかりすぎるので、改良の余地はありますね。この記事は、Gushwell's C# Programming Pageで公開したものをに加筆・修正したものです。


