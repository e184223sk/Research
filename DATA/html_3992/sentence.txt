More than 1 year has passed since last update.前回はforeachについて色々書いてみました。そろそろネタが切れそうですが、今回はLINQについてです。特にWhereの仕組みとパフォーマンス関連の話が中心です。というかそれでほぼ全てです。過去最高レベルでマニアックな話になってしまいました。かなりの変態向けの記事です。マニアック過ぎて文献とか全然見つからなかったので、間違ってる可能性大です。ガンガン指摘してください。今回色々調べて分かった事は以上になります。0から99_999_999までの整数から、4の倍数の個数を求めます。テストパターンは以下の3*4です。フィルタ方法フィルタ対象こうなりました。フィルタ方法は、1 &lt; 2 &lt; 3の順です。フィルタ対象は、3 &lt; 2 &lt; 1 &lt; 4の順です。どうしてこうなったのかは、「パフォーマンに差が出る理由は？」で説明します。Language INtegrated Queryの略。(日本語にすると、統合言語クエリ)C# 3.0の頃の機能なので、実は結構古株なお方。「SQLっぽくて何かヤダ」とか「LINQって遅いんでしょ？」とか言って敬遠する人が多い。(当社調べ)LINQと一言で言っても、色々なメソッドがあります。その数なんと約200個！とは言っても、メソッドのオーバーロードを含めてなので実際は50～60個くらいです。全てについて書いていたらキリがないので、前述のWhereを中心に書いて行きます。以下が、Where&lt;TSource&gt;の定義です。これだけみてもよくわからないので、公式リファレンスを見に行きましょう。https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.where?view=netframework-4.7.2 よりFilters a sequence of values based on a predicate.述語に基づいて一連の値をフィルタリングします。となっています。やっぱりよくわからないので、順を追って説明していきたいと思います。Whereの説明の前に、「そのthisってなんだよ？」って思う方も多いでしょう。始めてみた時、僕は思いました。こいつは拡張メソッドです。自作のメソッドをインスタンスメソッドかのように呼び出せます。見た目上、クラスに新たなメソッドを追加したかのような動作をさせることが出来ます。自作のクラスに対して使うメリットはあまりありません。(どちらかと言うとデメリットのほうが大きい。)最大のメリットは、インターフェースや他人が作ったクラスにインスタンスメソッドっぽい物を足せる事です。IEnumerable&lt;T&gt;に対して、インスタンスメソッドを実装することは出来ません。(インターフェースの仕様)そんな時でも拡張メソッドを用いて、あたかもインスタンスメソッドを持っているかのように振る舞う事が可能なのです。Funcとはデリゲートの一種です。今回使用されているのは、Func&lt;T,TResult&gt;とFunc&lt;T1,T2,TResult&gt;です。C# 3.0の頃に追加された機能です。それ以前はdelegateクラスを使用して作成していたものを、ジェネリクスを用いて(比較的)簡単に作れるようになりました。Whereはこのデリゲートで渡された条件に従って、フィルタリングを行います。先述の述語ってやつです。本当はもっと詳しく書くべきなんですが、面倒なので本題からそれてしまうので今回はカットです。いきなりデリゲートとか言われても困る方も多いでしょう。初めて聞いた時、僕は困りました。簡単に言うと、「メソッドを変数として扱うための機能」って感じですかね。C言語に触れたことが有る人なら、関数ポインタをイメージすると良いかもしれません。C#の勉強をしていた人間が、つまづきやすい所No.1です。(当社調べ)こいつも本当はもっと詳しく書くべきなんですが、面倒なので書ききれないのでカットです。Whereメソッドですが、2つあります。違いは引数のデリゲートです。1つ目はFunc&lt;TSource, bool&gt; predicateです。こいつはそのままフィルタリングするだけ。2つ目はFunc&lt;TSource, int, bool&gt; predicateです。こいつもフィルタリングするのは同じなんですが、インデックスを持てます。0から始まり、1ずつインクリメントされて行きます。大きな違いはありません。......と言いたいところですが、実はかなり大きな違いがあります。この記事では、1つ目のWhereをメインで解説します。2つ目は後々出てきますので、存在だけ覚えておいてください。突然謎の単語が出てきました。遅延評価です。Whereに限った話ではありませんが、LINQは遅延評価と呼ばれる評価の方法を採用しているメソッドが多いです。読んで字のごとく、評価を遅らせる機能です。「宣言されたときではなく、必要になった時に計算する」んです。ちょっとした例を書いてみました。ちなみにCountは要素数を返すメソッドです。条件を指定することも可能です。oddが宣言されたタイミングでは、何も起こりません。Countで数える時に初めて評価します。この場合、50_000_000が戻り値になります。今回説明の都合上、intListに対してToListを実施しています。本来であれば、Count実施時に評価されるので不要です。パフォーマンスが落ちるので止めましょう。Whereですが、System.Core.dll → System.Linq名前空間の下にあります。Enumerableクラス内で拡張メソッドとして定義されています。if文が5個出てきます。上2つは簡単です。元データやデリゲートがnullであれば例外を出力して終了。問題はその下で、イテレータの名を冠する謎のクラスが4つ出てきます。彼らはEnumerableクラス内に定義されているprivateなクラスです。なんとなく分かるかもしれませんが、2,3,4のクラスは、1を継承しています。まずは1.Iterator&lt;TSource&gt;から行きたいと思います。abstractなので抽象クラスです。メソッドの約半数もabstractです。IEnumerable&lt;TSource&gt;を実装しているので、foreachや各種LINQにも対応しています。このクラスは抽象クラスなので、インスタンスは作成されません。既にWhere等でイテレータが作成済みの物に対して、再度Whereを行なった場合、Where内でキャストされます。Where(hoge).Where(huga)とかです。この場合、拡張メソッドの優先順位の関係で、オーバーライド先のWhereが呼ばれます。その後は、各メソッドのオーバーライド内容に従います。次に2.WhereArrayIterator&lt;TSource&gt;です。SelectメソッドとWhereSelectArrayIteratorクラスが出てきましたが、今回Selectは扱わないので無視してください。(これ以降のクラスも同様です。)このクラスのインスタンスが作成されるのは2パターンあります。1つ目が、配列に対してWhereでフィルタリングを行なった場合。(2)のケースです。コンストラクタの引数で、sourceとpredicateを設定します。元データが配列なので、sourceも配列です。そして配列のアクセス用にindexを持っています。Whereの処理はこれで終わりです。遅延評価なので、評価対象データと評価方法だけ保存すればOK。後は必要になったら取り出します。(これ以降のクラスも同様です。)2つ目が、オーバーライドされたWhereが呼ばれた場合。(1)のケースで、元々が配列だった場合です。このときもやはり、コンストラクタの引数で、sourceとpredicateを設定します。その際にCombinePredicatesメソッドが実行されます。こいつは後の2つにも出てくるので、最後に説明します。次に3.WhereListIterator&lt;TSource&gt;です。このクラスのインスタンスが作成されるのは2パターンあります。1つ目が、Listに対してWhereでフィルタリングを行なった場合。(3)のケースです。やはりコンストラクタの引数で、sourceとpredicateを設定します。元データがListなので、sourceはListです。そしてindexの代わりに、List&lt;T&gt;.Enumerator構造体を持っています。前回、foreachで僕が間違えていたお方です。このお方が出てくる時は、パフォーマンスの話が出てくる時です。2つ目が、オーバーライドされたWhereが呼ばれた場合。(1)のケースで、元々がListだった場合です。CombinePredicatesメソッドは後ほど。最後、(4).WhereEnumerableIterator&lt;TSource&gt;です。このクラスのインスタンスが作成されるのは2パターンあります。1つ目が、Listでも配列でも無いIEnumerableに対してWhereでフィルタリングを行なった場合。(4)のケースです。こいつもコンストラクタの引数で、sourceとpredicateを設定します。元データがIEnumerableなので、sourceはIEnumerableです。そしてindexの代わりに、IEnumerator&lt;TSource&gt;構造体を持っています。2つ目が、オーバーライドされたWhereが呼ばれた場合。(1)のケースで、元々がListでも配列でも無い場合です。名前のまんまです。PredicatesをCombineする、つまりPredicatesを合体させるメソッドです。引数で2つのpredicateを受け取り、「順番に実行するデリゲート」を返します。このメソッドはデリゲートを作成するだけなので、この段階では何も実行されません。何がパフォーマンに影響を与えているかを説明する前に、関数のパフォーマンスに関する話を少し。C#では、関数化するとその分だけパフォーマンスが下がってしまいます。関数を呼び出した時や戻る時のジャンプにかかるコストや、最適化が行えなくなることによる無駄な処理が原因です。なので関数化せずに、全てmainメソッドに押し込んでしまいましょう。......なんてことは出来ませんよね。死人が出ます。これじゃ不便なので、誰かがせっせと関数化した部分を元に戻してくれます。(C#コンパイラではなく、JIT(Just in time:必要になったら)コンパイラがやっているらしい)この元に戻す行為をインライン展開と呼びます。この便利な機能ですが、仮想呼び出しされている関数はインライン展開できません。なので、インターフェースを介している時はこいつは働かないのです。(原理的に無理らしい)前回の記事で、こんなコードがありました。foreachのコンパイル後の姿です。(1)でIEnumerator&lt;string&gt;ではなく、List&lt;string&gt;.Enumeratorに展開されています。List&lt;string&gt;.Enumeratorは構造体なので、インライン展開できます。IEnumerator&lt;string&gt;にしてしまうとインライン展開できません。パフォーマンスに影響するのでこういう形になっています。順番に説明してきましょう。一番最初に上げた例で、説明します。Whereメソッドと、WhereListIteratorクラスです。必要な部分だけ抜き出してます。今回sourceは(当たり前ですが)、Listです。なので、WhereListIteratorのインスタンスが作成されます。元クラスのコンストラクタも実行されますが、マルチスレッドの時くらいしか関係しないので割愛。Whereが実行された時点では、コンストラクタの引数からsourceとpredicateをローカルに保存して終了です。次にCount(条件なし)ですが、以下のようになっています。引数のsourceはWhereListIteratorなので、一番下のusingまで来ます。このusingから先は前回お話した、foreachのコンパイル後の姿と同じです。現在、sourceはWhereListIterator&lt;TSource&gt;です。改めてWhereListIteratorのMoveNextを見てみると、こうなってました。改めてソースを見ると、WhereListIterator&lt;T&gt;.MoveNext()の内部で、再度enumerator.MoveNext()を行なっています。ここでのenumeratorは、List&lt;TSource&gt;.Enumeratorです。そしてCount内のenumeratorは、IEnumerator&lt;TSource&gt;です。なので、Countの中ではインライン展開されず最適化できませんが、そのさらに内側のWhereListIteratorの中では、インライン展開され最適化できるようになっています。一方、Count(条件なし)ですが、以下のようになっています。この場合、ListをIEnumerable&lt;TSource&gt; で受け取っています。なので、foreachを行う際に、List&lt;TSource&gt;.Enumeratorに展開できず、IEnumerator&lt;TSource&gt;として展開されてしまいます。結果、インライン展開されず最適化できないので、およそ2倍の時間が掛かってしまいます。配列に関しても同様です。First,Last,Single,Any(条件なし)の、ソースコードです。そして、First,Last,Single,Any(条件あり)の、ソースコードです。ものすごく長くなってしまいましたが、全てCountと同じことが言えます。しかし、FirstとAnyは、見つけた段階で即時returnです。なので、最初の方で見つかった場合、ほとんど変わらない影響を受けません。そして、LastとSingleはFirstに比べると使われる頻度が少ないと思います。(そんなことなかったらごめんなさい)なので、(有効な局面は少ない)とさせていただきました。index付きのWhereは、以下のようになっています。通常のWhereは、Listや配列に対して最適化されていました。しかし、Index付きWhereは最適化されていません。何も解説がいらないくらいシンプルです。この場合も、ListをIEnumerable&lt;TSource&gt; で受け取っています。なので、IEnumerator&lt;TSource&gt;として展開されてしまい、インライン展開されず最適化できません。その上、インクリメント処理も行なっており、更に遅くなってしまいます。Whereは複数回呼び出した場合、CombinePredicatesによって条件が結合されます。デリゲートもインライン展開出来ないです。なので、Whereを使えば使うほどジャンプする回数が増えパフォーマンスが落ちてしまうのです。どうしてもWhereを減らすのが難しい場合は、より厳しい条件を前に持ってくることで改善できます。以上です。とても長くなってしまいましたが、最後までお付き合いくださいありがとうございました。過去2回分よりは実用性があるんじゃないかと思ってます。が、それでもたかが知れている気もします。ちなみに次回の予定はSelectです。が、Whereほど書くことが無いので書かないかもしれません。参考にしたページを書く脳みそが付いたらしいです。[雑記] インライン化 - C# によるプログラミング入門 | ++C++; // 未確認飛行 CIEnumerator の別実装 | ++C++; // 未確認飛行 C ブログ


