More than 1 year has passed since last update.本記事は C# の Realm でできる基本的なこと／Realm の特徴的なところをコードを交えながら解説します。完全なソースコードは以下で参照できるようにしています。Realm とはアプリでの利用を主目的としたデータベースです。同じ目的で使えるデータベースには SQLite や Apache Derby などがあります。Realm はモバイルアプリを強く意識して作られたもので速度が早いらしいです。私が Realm を覚える一番の動機です。C# の Realm は Xamarin 限定のものという印象が強かったですが、少なくとも現時点ではどこでも自由に使えるようです。私は WPF アプリで使ってみようとしています。この記事でのサンプルは余計な複雑さを排除するためコンソールアプリを主体にしています。一部 WPF アプリ（≒GUI アプリ）固有の話題も挙げます。Realm にはアプリで使う単なるデータベースの機能だけではなく、専用サーバーを使ってクラウド越しに内容を同期するという機能がありますが、存在のみしか知らないので本記事では扱いません。本記事執筆時点の Realm.NET のバージョンは、3.3.0 です。本記事は、Realm 本家のページと合わせて読むことをお勧めします。本記事執筆時点の日本語の説明ページは 1.6.0 のものです。バージョンは古いですが、十分通じる内容だと思います。最新の情報が知りたい場合は英語のページを読みましょう。また、本記事には筆者の解釈や想像が含まれている点をあらかじめご了承ください。Realm はオブジェクトデータベースです。クラスの定義がスキーマになり、オブジェクトを直接入れたり出したりできます。入れたり出したりできます。CREATE TABLE などの DDL はありません。代わりに RealmObject を継承したクラスがテーブルの定義になります。プロパティがテーブルの項目です。主キーやインデックスなどの細かい設定はクラスのフィールドに専用の属性を設定します。INSERT/SELECT などの SQL もありません。オブジェクトの追加・取得・削除は専用のメソッドを使い、オブジェクトを直接入れたり、出したり、消したりします。WHERE など複雑なものは LINQ を使います。UPDATE は取得したオブジェクトのプロパティを直接書き換えます。※ 本文中の realm 変数は、Realms.Realm.GetInstance によって取得した Realms.Realm クラスのインスタンスです。Realm.All などで Realm が返す System.Linq.IQueryable オブジェクトは LINQ の一部機能をサポートしていないようです。以上の事例では Where を使っていますが、Select を使うと実行時例外が発生します。どうしても必要な場合は ToList などで一度リストにしてから Select するなどの回避方法があります。リレーショナルデータベースを閲覧する汎用ツール群は使えません。専用の Realm Studio を使って閲覧します。Realm は他の一般的なライブラリと同じように NuGet でライブラリをプロジェクトに追加して使います。Realm を入れると追加で Fody が入ります。Fody に馴染みのない方もいるでしょう。ビルドしたアセンブリに追加の処理を書き込む強力な能力を持った AOP ツールです。FodyWeavers.xml はどういった追加処理を書き込むかを決定するための Fody の設定ファイルです。Realm を入れたプロジェクトをコンパイルするにはこの FodyWeavers.xml が必要になります。Fody で有名なものに PropertyChanged.Fody があります。これは MVVM の実装を助けてくれるもので、プロパティの定義から INotifyPropertyChanged 向けの実装を組み込んでくれるスグレモノです。Realm も Fody で RealmObject のプロパティにデータベースの遅延読み込みや更新処理などを組み込んでいます。ILSpy でコンパイル後の dll を見ると組み込まれたコードを確認できます。以下は Table1 クラスに埋め込まれたコードの一部です。自分が実装した覚えのない動作をするのは Fody が組み込んだ処理が裏にあるということを覚えておくと良いでしょう。Realm にもトランザクションの概念があります。オブジェクトの変更は専用のブロックで囲う必要があります。ブロックで囲わないと実行時例外になります。ブロック内の変更は確定するまで外（別スレッド）からは見えません。Realm オブジェクトは Realm.GetInstance を実行したスレッド内でしか利用できません。別スレッドにインスタンスを渡してそのまま使うと実行時例外になります。そのためスレッドの中では別途 Realm オブジェクトを取得して書き込みを行っています。また、別スレッドで書き込んだ内容は既に作成済みの Realm オブジェクトからは取得できません。再度 Realm.GetInstance で新しく取得しなおした Realm オブジェクトを使う必要があります。Realm オブジェクトはデータベースへのアクセス毎に Realm.GetInstance で取得するのが基本パターンになると想像できます。事例ではトランザクションの効果を確認するために Thread を使いましたが、Realm で書き込みを非同期に行うには Realm.Write の代わりに Realm.WriteAsync を使うのが一般的です。ただし、この Realm.WriteAsync は UI スレッドで実行した場合にのみ非同期処理になります。UI スレッド以外で実行した場合は Realm.Write と同様に同期処理になります。従ってコンソールで非同期に書き込みを行うにはスレッドを自分で作成する必要があります（この制約はいったい何のためのものなんだろう？）。RealmObject 間のリレーションは単方向/双方向・一対一/一対多/多対多を問わずに設定できます。自己参照や循環参照にも特別な制約はなく自由に設定できます。リレーションを作るには RealmObject を継承したクラスをプロパティにします。
リレーションを作るためだけに主キーを設ける必要はありません1。主キーは明示的に主キーアクセスでオブジェクトを取得できるようにしたいときに設けます。プログラム上のオブジェクトの参照関係はそのまま維持されます。同一のオブジェクトを複数のオブジェクトのプロパティに設定して参照の共有もできます。これらのリレーションはアクセスするまで解決が遅延されます。そのため１つのオブジェクトを取得したことによってリレーションでつながったオブジェクトネットワークがいきなり全て読み込まれるということはなく、小さい初期オーバーヘッドで読み込めます。また、双方向リレーションをサポートする特殊な機能として [Backlink] 属性を使うこともできます。[Backlink] 属性は IQueryable&lt;T&gt; 型のプロパティに設定します。[Backlink] 属性の引数には逆参照元のプロパティ名を指定します。RealmObject は２つの状態を持ちます。Standalone(=Unmanaged) と Managed の２つの状態です。状態によって RealmObject の挙動は大きく変わります。単にインスタンスを自分で new した場合は Standalone です。この状態のオブジェクトは単なるデータクラスとして振る舞います。プロパティに制約はなく自由にアクセスできます。Standalone のオブジェクトをデータベースに書き込むとその瞬間から Managed になります。データベースから取得したオブジェクトは最初から Managed です。この状態のオブジェクトは永続化された値を参照するようになります。また、プロパティの変更が永続化されるようになります。それに起因してプロパティのアクセスに以下の制約が発生します。トランザクションの制約とは、プロパティの変更にトランザクションが必要になるという制約です。トランザクション外でプロパティへの値の設定を行うと実行時例外になります。スレッドの制約とは、取得時と異なるスレッドからプロパティにアクセスできなくなるという制約です。取得時と異なるスレッドからプロパティにアクセスすると実行時例外になります。以上が Managed オブジェクトに発生する制約です。Standalone から Managed への状態遷移はデータベースへの書き込みを行うことによって起こりますが、Managed から Standalone への逆の状態遷移はできません。現在のオブジェクトの状態を確認するには IsManaged を使います。Managed オブジェクトが持っている制約はとても強いものです。特に GUI アプリを作る場合には事前に知っておくべきことです。それを考慮して作る必要があります。RealmObject は INotifyPropertyChanged を実装しており、変更通知を受け取ることができます。この機能は MVVM で GUI を構築する際に利用できる機能です。変更通知機能は Standalone でも Managed でも使えます。Managed の場合、変更の通知はトランザクションが確定したタイミングで行われます。Realm.Find で別個にオブジェクトを取得したものでもデータベース内で同一のオブジェクトへの参照であれば変更通知が届きます。以下は WPF での事例です。Managed オブジェクトのプロパティを Binding で表示しています。対象オブジェクトを別途 Realm.Find で取得して更新すると、INotifyPropertyChanged を通じて変更が伝わり即座に表示が切り変わります。Managed オブジェクトにはトランザクションの制約があるため、双方向バインディングはできないことに注意してください。アプリのバージョンアップにともなって、既存テーブルのスキーマが変わることがあるでしょう。アプリを作るにあたり、データベースのマイグレーションコードが実装できることは必須事項と言えます。Realm にも旧データを新データに適合させるためのマイグレーションコードを簡単に組み込む手段がちゃんと用意されています。詳細については本家サイトを参照してください。１つ１つのオブジェクトに Realm が内部的な主キーを独自に設定しているのではないかと想像しています。 ↩


