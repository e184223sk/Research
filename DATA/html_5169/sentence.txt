More than 3 years have passed since last update.こういうことをやろう、という話です。※コピペ利用は自由ですが、自己責任でお願いします。やり方は、他のサイトにも書かれている「選択されたセルにテキストボックスを貼り付けて、あたかもセルが編集できているかのように見せかける」と同じです。ListViewを継承して、ListViewExクラスを作成します。処理のポイントを並べると、
①マウスクリックした位置のセル座標を求める
②セルの幅や高さに合わせてテキストボックスを貼り付ける
③テキストボックスの編集が確定したら、セルに値を反映させる
となります。文字で書くと普通のことをするだけなのですが、実際の処理は結構面倒な上、細かい注意点もあります。では、各プログラムの解説に入ります。ListViewに限らず、マウスクリックの位置の座標を取得するには HitTest()メソッドを使います。DataGridViewやTreeViewでも、マウスクリック位置のセルやノードの位置が欲しい場合があるので、このメソッドの存在を知っておくと便利です。ダブルクリックでテキストボックスを表示します。ListViewExに定義した、ShowTextBox()メソッドでテキストボックスを表示を行います。ShowTextBox()メソッドの中は、セル編集用TextBoxをインスタンス化して表示するだけです。セル編集用TextBoxは、TextBoxから継承してListViewTextBoxクラスを作ります。細かいことですが、外部から使わせたくないので、internalにしておきます。ListViewTextBoxのコンストラクタで、テキストボックスのサイズや位置を設定します。まず、テキストボックスのサイズです。subItem(セル)の位置や高さ幅に合わせればいいのですが、注意点が２つあります。１つ目は、ListViewのふちの幅を考慮する必要があり、何もしないと、微妙に大きいテキストボックスになってしまいます。そのため、HeightとLeftにborderの分だけ足し引きしています。borderの値は次のように求めています。多分、定数がC#のライブラリ内に定義があると思うのですが、調べるのが面倒になりました。。。２つ目の注意点は、WidthにsubItem.Widthの値を使用すると、一番左の列は列全体の幅になってしまう、ということです。なぜそういう値になるのか分からないのですが、仕方ないので幅だけListView#Columns[]から算出しています。次にテキストボックスの体裁を整えます。フォントは親ウィンドウのListViewExに合わせておいたほうがよいでしょう。テキストボックスの初期値は、当然セルの値です。また、セルを選択状態にしているように見せかけるので、表示は最前、テキストを全選択にしておきます。これでテキスボックスの表示は完了です。「テキストボックスの編集が確定したら～」と、さらっと書きましたが、これはユーザーどういう操作を行ったときでしょうか？　TextBox自体に「編集の確定」というものはありません。ですので、プログラムを書く人間が、ユーザーがXXという操作をしたら「編集を確定する」と決めるしかありません。ルールが無いので慣習で決めることになるのですが、今回のケースでは、Enterキーを押したら確定、として良さそうです。キーの入力ハンドラーはPreviewKeyDownです。HideTextBox()メソッドでテキストボックスの内容反映とテキストボックス自体の非表示をします。HideTextBox()メソッドの中身です。ListViewTextBoxの表示は毎回newしているため、非表示はDispose()で後始末するようにしています（ListViewTextBoxのインスタンスは１つだけ生成して、それを表示・非表示だけで使いまわす、という実装もアリだと思います）。セルへの値の反映は、AfterTextEditingイベントを送信してListViewExへ通知することにしました。このハンドラーは、ListViewExのShowTextBox()メソッド内で登録しています。1列目が空文字列であった場合、行削除にしているのは、ListViewは1列目(ラベル)を空にできないからです。骨格は①～③を実装すれば動きますが、GUI上実装しておきたいことがいくつかあります。Enterで編集確定としましたが、編集をやめたいときもあります。これもプログラムを書く人間の決めの問題ですが、まぁEscapeでキャンセルでいいでしょう。ListViewTextBoxのPreviewKeyDownイベントに追加しておきます。いるのか？という疑問もありますが、Tabで進む、Shift+Tabで戻るも実装しておきましょう。更にPreviewKeyDownイベントに追加します。TabMovedイベントは、ListViewに次のセルを編集状態にするために通知するために作ってあります。ListViewTextBoxはListViewTextBox自体の表示や値のみの管理にすべきであり、ListViewの操作はしないほうが良いでしょう。そのため、TabMovedイベントでListViewに処理を委譲することにしました。TabMovedイベントハンドラーは、長いですが特に変わったことはしていません。セル座標の計算が面倒なだけです。上の説明ではマウスダブルクリックにしていましたが、普通はクリックだろ、と考える人もいると思います。ExcelのようにF2で編集開始にしたい人もいるかもしれません。そういうことを設定できるようにしておいたほうが良いでしょう。ActivationEditingプロパティで指定できるようにしてあります。当たり前ですが、列編集できるListViewは詳細Detail表示の場合だけです。その他自動的に決まってしまうプロパティがあります。コンストラクタで設定してしまいましょう。行選択は、本当はセル１つだけ選択状態にできればよかったのですが、ListViewではそういうものはありませんでした。また複数行が選択されると、編集開始が意味不明になるので単一行選択にしておきます。LabelEditは当然、自分で編集できる仕組みを用意したわけですから、falseにしておきます。最後に、この実装の問題点を上げておきます。固定プロパティ値は、変更を禁止にできない
詳細表示や、単一行のみ選択、といったプロパティは、列編集できるListViewでは固定プロパティ値なので、変更されても困るのですが、それを外部から変更禁止にできません。ListViewから継承で作ったからです（オブジェクト指向の観点から言うと、違反している）。完全に禁止したいなら、継承ではなく包含で実装するしかありません。編集セルの型はstringしか対応できていない
チェックボックス(bool型)にしたい場合もあると思いますが、テキストボックス固定の実装となってしまっています。ListViewTextBoxがリソースリークしているかも
ちゃんと調べていないので。ざっと見た感じでは大丈夫そうですが、リソース解放するHidenTextBox()メソッドが呼ばれない処理があるかもしれません。ある程度柔軟な設定ができるようにしたかったのですが、難しいです。MS製ライブラリは昔から道から外れたことをしようとすると、とたんに難易度が跳ね上がるのですが、C#でも変わってないようです。本当に列編集したいなら、多分DataGridViewを使え、ということのように思いますが、DataGridViewもデータソースありきのインターフェースになっているため、使いにくいんですよね。


