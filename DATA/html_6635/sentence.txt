More than 3 years have passed since last update.比較的分かりやすいし、それなりに速いし、実装も楽。みんな大好き k-means 法。
今回はそんな k-means 法を、 C# の LINQ(+MoreLINQ) で書いてみました。簡単に言うと、各データ点の、自分が所属するクラスタ中心との二乗誤差の総和を、勾配法的に最小化する手法です。クラスタ数 $k$ 、あるクラスタ $i$ に所属するデータ点の集合 $S_i$ として、式で書くとこんな感じ。もう少し詳しく知りたい人には、神嶌先生の資料が分かりやすいです。
イメージをつかむなら、「K-means 法を D3.js でビジュアライズしてみた」が k-means 法を step-by-step で実行できて理解の助けになるかと思います。計算の流れは、以下の通り。今回対象とするデータは、簡単のため double 型の 1 次元データとします。
データ構造は以下のようにします。n はデータ点の数、 k はクラスタ数です。加えて、 data と assignments については、同じ添字は同じデータ点を指すこととします。ソースコードはこんな感じ。括弧、コメント、関数の呼び出し・戻り値を除いた、純粋にアルゴリズムに関係している部分は 8 行で書けています。それぞれについて説明していきます。まず、上記の部分ではクラスタ平均の初期値を取っています。
具体的には、まず data.OrderBy(v =&gt; rand.Next()) で、ランダムな値についてソートすることで、元の data の要素をシャッフルをした配列（正確には IEnumerable オブジェクト）を得ます。次に、 .Take(k) でその最初の k 個を取ることで、疑似的に「データ点からランダムに k 個の点をクラスタ中心の初期値として取る」という処理を再現しています（完全にはランダムになっていないですが、 k-means 法ではそれほど気にする必要はないでしょう）。(2017/2/7 追記) @ozwk さんよりご指摘を受けましたが、乱数の生成に Guid を使うと、乱数のジェネレータを変数に持っておく必要がないので、以下のように 1 行で書くことができます。今回はデータ点に対するクラスタへの割り当て (assignments) が変化しなくなったら収束したとみなすので、収束判定のためにループ外で assignments を宣言しています。 means を収束判定に使用してもよいのですが、そうすると判定のときの式が厳密ではなくなるのでこちらの方が良いでしょう。繰り返し部分です。今回は、 while ループを回して収束したら break する形にします。収束判定の準備です。単純に代入しただけだと shallow copy になってしまう (assignments を変更すると prevAssignments も変更される) ので、 deep にするために .Select(v =&gt; v) を挟んでいます。こうすることで、 assignments とは別の配列のインスタンスが作られます。各データ点について、 means.IndexOf(means.MinBy(m =&gt; Math.Pow(v - m, 2))) で、中心との距離が最小になるようなクラスタの means 配列内でのインデックスを取得しています。 MinBy には MoreLinq パッケージが必要です。収束判定の部分です。全てのデータ点について、どの点でも割り当てられるクラスタが変化していなかったら (収束していたら) 、ループを抜けます。最後に、 means.Select((m, i) =&gt; で、各クラスタの中心 m と添字 i について、data.Where((v, j) =&gt; i == assignments[j]) で i 番目のクラスタに割り当てられているデータ点を抽出し、 .Average() で平均を取り、新たなクラスタ中心とします。 .DefaultIfEmpty(m) は、もしどの点も割り当てられないようなクラスタ中心ができてしまったら、そのクラスタ中心については 1 つ前の値をそのまま保持するという設定をしています。上記のようなコードで、ひとまず double 型についてはクラスタリングができるようになりました。さっそく実行してみましょう。以下のような結果が出ました。 value がクラスタリング対象の実数値、 cluster が割り当てられるクラスタのインデックスを指します。一応きちんとクラスタリングできていそうです。1 次元データだけだとやはり映えないので 2 次元の System.Numerics.Vector2 型のものも載せておきます。この場合、自分で拡張メソッドを書く必要があるので、 8 行ではなくなってしまいますが……。以下の条件でクラスタリングした結果は下図のような感じ。
- データ数: 200
- クラスタ数: 5問題なさそうです。というわけで、 8 行で k-means 法の実装でした。
おかしなところ等あればご指摘いただけると幸いです！


