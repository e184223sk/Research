More than 1 year has passed since last update.BayesServerをプログラムから使っていて、ちょっとこのデータはスパースだからスパースデータ形式で読み取りたいというあります。標準のAPIではデータベースに対するDataReaderである
BayesServer.Data.DatabaseDataReaderCommand
クラスがスパース列をサポートするようなので、DBを介せば大丈夫のようです。
https://docs.microsoft.com/ja-jp/sql/relational-databases/tables/use-sparse-columns?view=sql-server-2017IEvidenceReaderというインターフェイスでカスタムの事例リーダーの例がサンプルにあります。Custom evidence reader (Json) C#これはJSON形式のデータを読むためのものですが、IEvidenceReaderはを実装しさえすれば良いので、中はいかようにでもなります。このReadで事例の属性を要素にもつevidenceにデータをセットすれば良いわけです。このサンプルの場合ReadはJSONデータを受け取ってEvidenceにマップするという以下の関数（Action）を呼んでいるだけです。この関数はEvidenceReaderのコンストラクタで、指定されていますが、 JsonEvidenceMapper というクラスに実装されています。中身はJSONからデコードされてオブジェクトにマッピングされたデータから、Evidenceへの代入が行われています。JSONですとオブジェクトへのマッピングから、行への展開まで一筋縄ではいけないので、このようなややまどろっこしい実装になっているのか知りませんが、真似するには少々しんどい。やりたいのは、他のサンプルのように一度メモリに読み込まれたDataTable（通常は別途CSVから読み込んでいます）のあるカラムにスパースな列名の列挙（ある／なしのデータboolean）を入れているという仮定です。
sparseVarialbeリストに該当する列に達した場合は、要素を再パースして、分割して、それぞれを列として認識させるということをやっています。（ここでは;が内部の区切り記号）
Booleanに限定しており、カラムの番号などを指定する必要がないのですが、そうすると、出来上がりの（密な）データフレームの列構成がわかりません。これは、結局BNのノード以上のカラムが来ないという仮定のもとに、一度ノードのリストであるVariableReferencesというリストを仮定しています。
そうすれば、事前に集計して、カラムを構成したりする必要がありません。（よって、最初のネットワーク構築の時などはこの技は使えない）setEvidenceですが、おそらくBayesServer内部にはこのようなユーティリティ関数があるだろうということで、想像で書いてみたいのですが、やはり条件分岐などを完全再現とはいきません。ノードタイプ、あるいは入力のカラムの型などにより、場合分けをするのですが、GUIの構成などを見ながら、この場合変数型の場合はこの値しか無い、という関係を読み取って、書いてみました（この辺はいろいろ勉強になる）。開発元にも、こういう実装でいいのか、もしよかったらsetEvidence関数を教えてくれ、と言ってみたのですが、回答として、「同じことは、EvidenceReaderいじらなくてもDataReaderの改造で十分出来るよ。」と帰ってきました。そのサンプルもくれヨとも思いましたが、あくまで標準の.NETのしきたりで書けばよいので、それを聞くのはお門違いかと思い、自作しました。考え方としては、標準の（普通に列が来ると思っている）IEvidenceReaderに対して行のデータにアクセスさせてあげれば良いだけです。
DataTableを入力として、DataTableDataReaderの派生のような形で実装しました。
Readに関しては、すでにデータテーブルにパース済みの行データをイテレートするだけです。currentRowに現在のRead対象の行が格納されます。元がDataTableなので、スパース行はすでにcurrentRowとして読み込まれており、そのうちsparseVariablesにある列を再展開するのはさっきと同じ。スパース列の文字列リストにその指定した列名が存在すればその列はtrueということにしています、
スパース列内の要素が少ない場合は、これでもそこまで性能劣化は無いと思われます。IDataReaderの派生で実装した方が、カスタムの!EvidenceReaderの実装をしなくてよい、またその結果IEvidenceReaderと組み合わせて使うオプションが使いまわせるなどがありますので、この程度の特殊な事例はIDataReader側で吸収するのが良いようですね。


