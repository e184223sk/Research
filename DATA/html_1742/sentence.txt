More than 1 year has passed since last update.脆弱性が報告されてから修正が完了するまでに、Webアプリケーション開発者(またはテスター)ができることをセキュリティテストを中心に書く。セキュリティテストってどうやればいいの？とか、セキュリティベンダの脆弱性診断高すぎ内製化したる！とか、そんな人たちの参考になればいいなあ。※本記事のサンプルコードは C# + Entity Framework だが、プロセスは他の言語やフレームワークでも通用する。※注意：再現行為を本番環境でやるのは危険すぎるので、検証環境でやるのがよい脆弱性が報告されたら、通常のバグ修正と同じように、まず脆弱性を再現させる。（TDD風に言うなら、レッドになるテストを作る）SQLインジェクションの場合、主にHTTPリクエスト（URL、ヘッダ、本文など）が再現手順になる。あらかじめ Web サイトへのログインが必要な場合は、それも再現手順に含めておく。再現手順を確立しておくことで、修正後に再現しなくなる（テストがグリーンになる）＝修正できたことを確認できるようになる。また、この時点で脆弱性スキャナを実行して脆弱性が検出されることを確認しておくのもよい。理由は後述の 脆弱性スキャン に記載。SQL インジェクションの原因は、たとえば次のようなケースが考えられる。原因がわかったら、報告を受けた箇所だけではなくほかにも同様の問題がないかも確認する。今回は自分たちが書いたコードに問題がある場合を想定して話を進める。SQLインジェクションの対策について詳しく知りたい場合は、IPA が公開している 安全なSQLの呼び出し方 を参照。たとえばこんなコードをこんな感じに修正する1.再現手順の確立 で確立した脆弱性の再現方法を修正箇所に試し、問題が再現しないことを確認する。これで対策完了！ではない。4.修正の確認は「正しくできた」ことを確認するテスト。対して「正しくできていない」ことを発見するのがセキュリティテストの役割になる。「正しくできていない」とは、間違った対策や中途半端な対策のこと。セキュリティテストは、通常のテストと同様、コストと網羅性のバランスが必要。修正完了までコードの変更とテストが何度も繰り返されることも多いので、フィードバックの早さも重要。すべてを満たすテスト手法は多分ないので、複数の手法を組み合わせるのが良い。SQLインジェクションの問題は、コードを見ればある程度問題の有無を判断できることと、自動テストを書きやすそうなことから、次の３つの手法を採用することにする。プロジェクトによっては下記のような選択肢もあるかもしれない。コードインスペクションは静的なホワイトボックステストの１つ。あるルールに基づいて人（または機械）がコードを精査し、欠陥を発見する手法。コードさえ見れれば、デプロイどころかコンパイラすらしなくてもテストできるため、実行コストが低くフィードバックがとても早いという利点がある。ただし精度はテスターのスキルに依存する。コードインスペクションではセキュリティの問題を発見することにのみ集中する。SQL インジェクション対策のインスペクションであれば、「パラメータを文字列操作してSQL文を作成していないこと」のようなルールをあらかじめ定めたうえで精査する。ルールは言語やフレームワークによって異なる点に注意。C# + Entity Framework の場合、下記のようなルールになる。※例では SELECT のみ挙げたが INSERT, UPDATE, DELETE 等ほかのSQL文のルールも必要コーディング規約がない場合はいろんなSQL発行パターンがわいてくるので、判断基準を作りながらテストするか、いっそ標準を定めて標準以外の書き方はNGとしてしまってもよいかもしれない。コードインスペクションのアウトプットは、テスト対象となったファイルとその結果の一覧になる。（例）この結果を受けて、例えば次のような判断ができる。どうするかは、テストの独立性やコストパフォーマンス等のバランスを見て決めればよい。ファジングは動的なブラックボックステストの１つで、「変なデータ」を入力しまくって欠陥を見つける手法。詳しくは IPA の 脆弱性対策：ファジング を参照。ファジングはWebサイトに対して実行することもできるし、SQLを発行している関数・メソッドに対しても実行できる。テストは小さい単位でやるほうがコストパフォーマンスがよくフィードバックも早いので、可能なら関数・メソッドに対してやるのがお勧め。もちろん Web サイトにやってもよい。「変なデータ」はランダムに作っても良いが、今回は fuzzdb で公開されている SQL インジェクションを発見するための入力パターン集を使う。関数・メソッドに対してテストする場合、ユニットテストフレームワークを使うのが楽。（ユニットテストか？という疑問は気にしないことにする）以下は C# + ASP.NET Core + SQL Server + xUnit.net の例こんな脆弱なコードに対してこんなテストコードを書くユニットテストの入力データに使う fuzz.txt はこんな感じ。上記の例では BlogPostsController クラスの SearchByAuthor メソッドに対してファジングしているが、同様に他のテスト対象のメソッド・パラメータに対してもテストを作り、実行すればよい。SQL 文を正しく作れている（脆弱性が無い）ならすべてのテストがグリーンになるはず。テスト実行結果の例（脆弱性を修正する前）
ユニットテストが困難な場合や、ミドルウェア・フレームワークのバグも心配な場合は、稼働している Web サイトを対象にファジングする。ファジングの方法は IPA が公開している ファジング実践資料 第2版 を参照。ただし、ファジングを Web サイトにするのは、ユニットテストの場合と比較すると下記の点で不利。最後に独立性の高いテストとして、脆弱性スキャンを実行する。上2つのテストが成功していればこのテストも成功する可能性が高いが、万が一の抜け漏れを見つけてくれるかもしれない。注意点は、スキャナの性能や設定値によっては脆弱性を検出できないことがあること。そのため、次の2点を確認するのがよい。下記は Nessus を使った例。Nessus の使い方は説明しない。※Nessus を選んだ理由はたまたま手元にあったから、というだけで、Nessus を推奨しているわけではない。修正前：CGI Generic SQL Injection という脆弱性が報告されている

修正後：SQL Injection とそれに関連する脆弱性の報告が消えている
このテストの成功をもって脆弱性対策を完了とする。ただし↓脆弱性を修正したら機能が使えなくなった、では意味がないので忘れずに。
（セキュリティテストではないけど）SQLインジェクションが発見されてから修正完了まで、Webアプリケーション開発者（またはテスター）ができることの流れを書いた。セキュリティテストの内製化の参考になれば。IPAが公開しているガイドライン。開発者以外（PM/POとかセキュリティ担当とか）にも役立つ情報あり。Entity Framework 関連


