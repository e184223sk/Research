More than 1 year has passed since last update.下記内容の続き、ウィンドウを最前面に表示しフォーカスが奪うに対応した経緯です。お仕事で外部アプリケーションが出力するログを監視し、ある条件なら警告画面を前面に表示させる要望がありました。
前面ならTopMostにして最前面にすればいいと思ったのですが、指定のダイアログ画面や指定のボタンまたはラベルが表示されている場合には前面を解除したいということになり、タイマーで外部アプリケーションの表示状態を監視して前面表示を解除するようにする予定です。
【.NET】外部アプリケーションの画面上すべてのタイトル(キャプション)を取得する【2020/0７/1６追記】
この記事って意外とアクセス数があるんですが、皆さんの読む目的って強制的にアクティブする方だと思うので下記の記事の方がいいかと思います。
【.NET】フォームを強制的にアクティブにする開発PCではWindows 7(64bit)を使用しています。
テスト環境では古め(5年前くらい)のPCでWindows 7(32bit)の2台となります。ウィンドウを常に最前面に表示するにはTopMostプロパティをtrueにすればいいだけです。今回は常に最前面ではなく、条件によっては最前面でなくす必要があったので、タイマーを使って条件以外の場合に最前面にするという方法を取りました。最初はWindows APIを使用して一時的に最前面(TopMostを有効後に解除)しました。
これで、ウィンドウが最前面にすることが出来ました。上述の方法でウィンドウが最前面になることは出来たのですが、警告画面にボタンのみある状態で最前面になった場合、Enterキーを押したら警告画面が閉じると思ったのですが、実際には直前にアクティブなアプリケーション側にフォーカスがある状態になっているのです。例えば、メモ帳にフォーカスがある状態で警告画面を最前面にした場合、Enterキーを押すとメモ帳側に改行が入力されるのです。ネットで調べていくと下記サイトを見つけました。
Form の this.Activate() についてこれで警告画面が最前面に表示された際に、Enterキーを押すと警告画面を閉じることが出来ました。また、Windows APIも不要で済んだわけです。ところが開発PCでは正常に動作するものの、テスト環境のPCではフォーカスが奪えない状態になりました。
ネットの記事などを参考にWindows API(AttachThreadInputやSetForegroundWindowやBringWindowToTopなど)を駆使してみるのですが、一向に解決しないのです。SetForegroundWindowはフォーカスを奪うことになっており、失敗する特定のケースがあります。
SetForegroundWindow関数は、指定されたウィンドウを作成したスレッドをフォアグラウンドに置き、ウィンドウをアクティブにします。 キーボード入力はウィンドウに向けられます
SetForeGroundWindow、SetActiveWindow、およびBringWindowToTopの違いは何ですか？ あたかも同じことをするかのように見えます。
MSDNによると、SetForeGroundWindowはウィンドウをアクティブにし、キーボードフォーカスをウィンドウに表示します。 これは、プロセスがバックグラウンドであっても動作します。 SetActiveWindowはSetForeGroundWindowと同じことを行いますが、アプリケーションが最前面のアプリケーションでない場合は何も行いません。 最後に、BringWindowToTopはウィンドウを一番上に移動させ、キーボードのフォーカスを変更しません。
c# - Win32 APIを使用してC＃でウィンドウを前面に表示しかし、マウスで警告画面をクリックすればアクティブになるのは分かっていました。時間も無かったし無理矢理ではあるのですが、自動でマウスをクリックするという方向に舵を切りました。参考：ユーザ入出力＞マウスの自動操作 - 緑のバイク※MOUSE動作のイベントのみであればdx,dyフィールドの設定は不要とのことで削除しました。また、SetCursorPos(x, y)を使わなくても、MOUSEEVENTF_MOVEを使えばdx,dyフィールドでマウス移動ができるとのこと、注意としてマウスロケーションをスクリーン座標から32bit座標に変換する必要がある。WPF側で警告画面の表示位置から少しずらした(+10)ところでマウスを自動クリックさせてフォーカスを奪うようにしました。(マウス位置は保持してクリック後に元に戻します)
自身がアクティブの場合は何もしないようにしています。そうしないとタイマーで実行しているので警告画面の位置を移動したりサイズを変更しようとしてもマウス位置が意図しない方向になり変な動作をしてしまうのです。この方法ならフォーカスを奪うことができ、目的は達成できました。マウスでウィンドウをクリックする方法は、一時的なら問題ないがタイマーの間隔が短いと別アプリケーションをマウスで移動やサイズ変更などさせようとすると、マウスが変な動作をしてしまい正常な動作ができなくなる問題が発生する。再度、Windows APIを駆使して実現を試みる。先ずはフォーカスを奪えない原因を知ることから始める。Win95/NT4までは、SetForegroundWindowだけでフォアグラウンドウィンドウを
切り替えられましたが、Win98/2000移行では、切り替え可能なプロセスは、
システムにより制限されるようになっています。
メニュー選択や文字の入力中に、勝手にウィンドウが切り替えられてしまい、
作業中の処理が中断してしまうことを防ぐための仕様変更だそうです
SetForegroundWindow で指定したウィンドウがアクティブにならない場合には？「SystemParametersInfo 関数」のSPI_GETFOREGROUNDLOCKTIMEOUTの説明によると、「ユーザーが何かを入力した後、システムは一定の時間にわたって、アプリケーションが自らをフォアグラウンドにすることを禁止します」ということです。よって、この時間（ForegroundLockTimeout）を0にするという対策も考えられます。
ForegroundLockTimeoutの値を0にする - 外部アプリケーションのウィンドウをアクティブにするC#でAttachThreadInputとSystemParametersInfoを使う下記サイトを参考にしてみた。
[C#]フォームをフォアグラウンドまたはアクティブにするこの方法でフォーカスを奪うことができるようになったのですが、SystemParametersInfoで設定変えるので好ましいとは思えなかったので、試しにコメントアウトしてみたところ、それでもフォーカスを奪うこと出来ました。呼び出し側です。WPFで作成した画面はタスクトレイで常駐しており、インスタンスを使いまわしています。Topmostプロパティの設定を再度行っているのは、最初は最前面に表示されたのですが閉じた後の2回目以降が最前面にならなかったためです。画面を使いまわすと例外エラーが発生したので、下記サイトにて対応しました。
Visual Studio / WPF &gt; Form &gt; 閉じたウィンドウを再度ShowModal()したとき &gt; Error:System.InvalidOperationException: 'Window が閉じた後で、Visibility の設定や、Show、ShowDialog、およびWindowInteropHelper.EnsureHandl の呼び出しを行うことはできません。 &gt; 対処これでマウスの自動クリックを使うことなくフォーカスを奪うことができ、目的は達成できました。最前面に表示について、2回目以降だと最前面にならず背面に隠れてしまう。Topmostプロパティを最前面にした後に解除することで前面化させている1 、昨日テストした時点では確認画面が最前面に表示されたままで他アプリケーションに制御が移れば背面に隠れる想定通りの動作だったのに、今日実行したら駄目でした。Windows制御は難しいね。確かに理屈的には他アプリケーションが表示されたら確認画面が背面になる、よって最前面表示されたらタイマーで1秒後に最前面を解除するように修正した。またTopmostプロパティではなくWindows APIのSetWindowPosを使うようにした。警告画面なので最初は最前面表示し、タイマーを使い設定したミリ秒後に背面にする。もう１つ、再現性は不明だがまれにタスクバーで点滅してフォーカスをが奪えないことがあった。このため、SystemParametersInfo を復活させるようにしました。このくらいしか対処できぬ。小手先な方法ではなく、きちっとした方法で解決できれば良かったんですけどね。レジストリは絶対いじりたくないし、非推奨な方法でもやりたくない。出来ればWindows APIもあまり使いたくなかったんですよね。マウスの自動クリックでWindows APIが必要になるとは思わなかった。【2018/01/18追記】
やはり、マウスの自動クリックという小手先な方法は使わない方がいい。今回は時間を頂いたので取り組むことが出来たのですが、この解決に到るまで結構かかってしまいました。【2018/01/19追記】
結局、Windows API使いまくりになってしまった。TopmostプロパティがTrueのままだと常に最前面になるため、Topmostプロパティをfalseにすることで最前面が解除され、他アプリケーションに制御が移れば背面に隠れるようになる。 ↩


