自分は業務でC#を書いているのですが、今までかなりあやふやな知識で例外処理を使っていました。そこで、一度学びなおし、現時点での自分の中での「例外処理の利用方針」を固めておこうと思いました。学びなおすために色々調べた結論としては、自分の知りたかった例外処理の利用方針は「++C++;」の「[雑記]例外の使い方」のページにとてもわかりやすくまとまっていました。ただ上のページを読んだうえで自分の言葉でもまとめておきたかったので、上のページを大幅に参考にさせてもらいつつ、自分なりの解釈やコード例などを付け加えてまとめたのがこの記事となります。「++C++;」では大体以下のような方針での例外処理の利用が提案されていました。（自分の選択で抜粋 + 解釈を加えさせてもらってるので、原文そのままの引用になっていません。ちゃんと見たい方は元ページを参照ください。）例外処理利用の基本ルール例外3パターンとその対策方針（※）「catchしない」というのはcatchして握りつぶしたり、処理の方向を捻じ曲げたりしないという意味。一度catchし、処理途中のもののロールバックやログ出力を行った後、再throwするのは有り。一言で方針をまとめるなら、「throwは遠慮なくして良いがcatchをするかどうかは状況をしっかり見て決めよう」、といったところでしょうか。上で見た例外処理3パターンについて、それぞれポイントや具体例などを見ていきます。利用者側が正しい使い方をしていれば回避できる例外です。
このパターンのポイントは、「catchしない」ことです。コード例を示します。上の例で、メソッド"SayHelloTo()"では、nullを渡して欲しくない引数"name"にnullが入っていた場合に例外をthrowしています。しかしメソッド利用側でcatchはしていません。
catchを書いてないとなんとなくアプリケーションが止まりそうで怖い感じがしますが、ビビッてcatchを書いてはいけません。不正なパターンが起きなくなるまで、しっかりテストを行います。さらに、このパターンに限らずですが、呼び出される側のメソッド（SayHelloTo()）は特に呼び出す側の事を意識する必要はありません。メソッドの処理を正常に行うための前提条件が整っていないなら遠慮なく例外を投げてよいです。
（ただし、頻繁に例外が起きることが予想される場合は、処理コストが高くなるのを避けるため、後述するTry-Parseパターンの実装が好ましいです。）また、どうしても変数"name"にnullが入る可能性を排除できない場合もcatchは書きません。以下のように、事前チェックをして回避します。この際、例外を出さないための事前チェック（上のコード例でいう、!(name is null)）がメソッド利用側では難しい場合があります。その場合は、後述のTester-Doerパターンのように、事前チェックをするためのメソッドを用意します。例えば簡単なRequestを送るメソッドを考えてみます。上の例では、"client.GetStringAsync()"でHttpRequestExceptionがthrowされる可能性がありますが、多くの場合これは呼び出す側で事前に予期して避けづらい例外です。しかしこのエラーは、単にリクエストに失敗したことを表示すれば問題ないので、復帰できるものです。
以下のように復帰しましょう。特に難しいところはないですね。HttpRequestExceptionを指定でcatchし、それに対する復帰処理（上の例だと失敗メッセージの表示）を行うだけです。一つポイントとしては、基本的に具体的な例外の種類（Exception派生クラス）を指定してあげることです。
なぜなら、"catch (Exception ex)"とのように派生元のExceptionクラスを丸ごとcatchしてしまうと、メソッド内でどんなエラーが起きたかがわからず、きちんと復帰できているとは言えないからです。
（ただし、catch句内でExceptionを再throwする、別の種類の例外に変換する（元のExceptionはinnerExceptionにする）といった場合は、派生元のExceptionクラスを丸ごとcatchしてもOKです。）また、このパターンの悩みどころは、どこで復帰処理を書くかが選べるところです。
上の例では、"Main()"の中でcatchを使い復帰処理を書きましたが、以下のように"GetMessageAsync()"の中で復帰処理を書くこともできます。上の例では、"GetMessageAsync()"の中で、catchを使い復帰処理を書いています。このように、このパターン②における復帰処理は、コード中のどの部分でcatchをするかある程度選べてしまいます。メソッドの責務（行いたい処理は何か）を明確にし、適切な呼び出し箇所でcatch,復帰処理を行いましょう。ちなみに今回の例だと、"Main()"側でcatchを書く方が良いかなと個人的には思います。
なぜなら、上の例で、復帰処理として"Failed ~"という文字列を返していますが、これではメソッド呼び出し側から見て処理が成功したかどうか判別しづらいからです。、
（もし、"GetMessageAsync()"側で復帰処理を行いたい場合は、後述のTry-Parseパターンをつかうなどして処理の成功or失敗をメソッド呼び出し側にわかりやすくする工夫をした方が良いでしょう。）このパターンは特に意識して対処する必要ないと思います。
自分はあまり良い例が思い浮かばないのですが、++C++;-例外の使い方では.NET Framework自体のエラーが例としてあげられていました。ここまでで基本的な方針は書きました。ただ実践では理論通り書けない部分も多く、方針があったとしても例外処理の書き方に迷う部分もあると思います。そこでここからは、例外処理に関連して使うテクニックや、理想通りいかない現実的なコードの話などを、つらつらと書きます。（あまり書く項目に一貫性はないです。）自分の経験・上の方針をもとに自分が昔書いたコードを修正してみて気づいたこと・C#の有名OSSであるJson.NETのコードを観察して気づいたこと、の3つを内容のベースとして書いています。パターン①で利用法上の例外（≒業務エラー）はcatchせず、メソッド呼び出し側でエラーパターンの事前チェックをすると書きました。しかし、そもそも例外は基本的には発生しない方が望ましいです。
なので、事前チェック用のメソッドを用意してやるのも一つの手です。そのような実装の仕方をTester-Doerパターンと言います。（Tester=事前チェック用メソッド、Doer=実行したいメソッド）この例のnullチェックぐらい簡単な確認ならTesterを用意するまでもないですが。.NETのクラスでも、このTester-Doerパターンは見られますね。  この記事のはじめの方に「メソッドの定める結果を達成できないなら例外を投げる」と書きました。
しかし例外は重い処理なので、それなりの発生頻度が予想される場合には使いたくありません。その場合は、Try-Parseパターンが使えます。Try-Parseパターンは、メソッドとしては例外をthrowせず、boolで結果を返す方法です。"TryGetFileData()"メソッドでは、処理が成功したかどうかを、例外を投げて知らせる代わりに、戻り値のboolで知らせています。
また、本来なら戻り値として受け取っていた結果はout引数として受け渡します。（処理失敗時は、null or 適当な失敗を表す値を代入。）上述したように、Try-Parseパターンには、例外を投げるのと比較して、処理失敗時のコストが低いというメリットがあります。ただし、Try-Parseパターンには、メソッド呼び出し側に例外処理を強制できないというデメリットもあります。それを理解した上で、例外を投げるのか、Try-Parseパターンを使うかどうか判断しましょう。Try-Parseパターンにはメリット・デメリットがある。場合によって例外を投げるのと使い分けるとよい。Try-Parseパターンは、.NETのクラスだと、以下でも使われていますね。
このパターンの場合は、Try~という名前のメソッドにするのが慣習ですね。非同期メソッドの場合、out引数が使えません。
その場合は、タプルで結果を返すなどして工夫しましょう。catch句では、対象となるException派生クラスを指定できる一方で、以下のように全ての例外クラスの継承元となるExceptionクラスも指定できてしまいます。（強制的に全ての例外をcatchすることができてしまう。）
これは場合によっては、適切な処理が行われず例外の発生が見えにくくなり、不具合の原因特定を難しくすることにつながってしまいます。なので方針としては、派生大元のExceptionは基本的にそのままcatchしない。catchする場合は特定の場合のみとします。
では、catchしてよいのはどのような場合かを見ていきます。派生大元のExceptionクラスをcatchしてよいときそれぞれコード例を見てみます。ログ出力などの任意の処理を行った後、再度throwします。このとき、"throw ex"と書くとStackTraceが消えてしまうため、"throw"とだけ書きます。そもそもExceptionをそのままcatchすることは例外が握りつぶされてしまうことが一番の問題なので、別の例外に変換するのはOKです。ただし、変換前の例外情報も貴重なため、InnerExceptionとして残しておきます。
このパターン使われるのは以下の場合が多いかなと思います。多くの場合は全ての例外をカバーすることは難しいため、このやり方は推奨ではないです。
ただし、開発プロジェクト内でエラーハンドリングのやり方が統一されている場合などには使われることがあるかもしれません。C#では、Exceptionクラスを継承することによって、独自の例外クラスを作成できます。独自例外クラスを作成するべきタイミングについては、Microsoftの公式ドキュメント-ユーザー定義の例外を作成する方法に書いているものそのままです。.NET では、基底クラス Exception から最終的に派生した例外クラスの階層構造を提供します。 ただし、定義済みの例外のいずれも要件を満たさない場合は、Exception クラスから派生することによって、独自の例外クラスを作成できます。つまり、独自の例外クラスは、積極的につくるものではなく、.NET標準で用意されてる例外クラスに該当するものがない場合のみ作成すると覚えておけば大丈夫です。
その他、独自例外を定義した方が、明らかに利用者側の復帰処理などに役立つ場合、あるいは一塊のコード内（ライブラリなど）で一貫した例外を使用したい場合などは独自例外をつくることを検討しましょう。ちなみにですが、C#でJsonを簡単に取り扱えるライブラリJson.NETでは、"JsonException"という独自例外クラスが定義されており、ライブラリ利用側には"JsonException"（実際にはいくつかあるその派生クラス）が渡されるようになっています。独自例外クラスの使われ方について実際のコードが見たいかたは、参照してみると良いと思います。（JsonExceptionクラス)また、独自例外作る際は、作法として定義しておくべきメソッドがいくつかあります。ドキュメントを参考にして定義しましょう。C#では、メソッドやクラスなどに対してXML形式でドキュメントコメントを書けます。
メソッドのコメントでは、発生する可能性のある例外を示すためのタグ"&lt;exception&gt;"が用意されています。
メソッド利用側の実装の助けになるので積極的に書きましょう。Try-Parseパターンのように、例外処理構文を使わなくてもメソッド処理の成功・失敗を伝える方法はあります。
ただしその場合には、メソッド固有のルール（例えばTry-Parseパターンでは、成功・失敗を戻り値とするいうルール）を決めていることによるデメリットがあります。
この点についても、++C++;-例外の使い方で簡潔にまとめられているので引用させていだきます。（原文では、文書で書かれているものを私の言葉で少し書き直し、表形式にしています。）このように、例外処理構文を使うことにより、メソッド固有のルールによるデメリットを大きくカバーすることができます。
なので実装の際は、まずは例外処理構文を使うことを検討、何か特別な理由があるならメソッド固有のルールを使うという方針でよいでしょう。例外処理の利用方針パターン①で、利用法上の例外について説明しました。
ただ例外の利用方法について調べていると、「業務エラー（≒利用方上の例外）には例外処理を用いてはいけない」という記述をよく見かけます。個人的には「業務エラーでもthrowはしてよい、ただしcatchはしない」という方針で良いと思います。
というのも、前節で書いた、throwを使わない場合に発生する「メソッド呼び出し側に例外処理を強制できない」といデメリットを避けるためです。Json.NETではどのように例外処理が使われているか軽く調べてみました。
以下は、ソリューション内のNewtonsoft.Jsonプロジェクトで使われいてる、throw, catchの大体の数になります。（grepでコード内のコメントも拾ってしまっているので、正確な数ではないです。）見てわかるように、新しい例外をthrowしている数に対してcatchしている数が少ないです。
実際のコードを見てみても、概ね「業務エラーでもthrowはしてよい、ただしcatchはしない」という方針で書かれているのかなぁという印象を受けました。例外処理を利用方針について、自分の勉強用に調べた内容をまとめました。
同じようなことを知りたがっている人のお役に立てれば幸いです。もし内容の間違いや改善点などあれば、ご指摘いただけると嬉しいです。


