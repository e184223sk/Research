More than 1 year has passed since last update.最初にクイズです。
True か False か、すべて自信をもって答えられる方はこの記事を読む必要がありません。答えは最後にあります。参照型の等価比較には、大きく分けて参照の比較と値の比較があります。Object.ReferenceEquals メソッドや VB.NET の Is 演算子を使うと参照の比較になります。
等価演算子 '=='、Equals メソッドは Object 型の既定実装は参照の比較ですが、等価演算子はオーバーロード、Equals メソッドはオーバーライド／オーバーロード（もあることに注意）という方法で型独自の振る舞いを実装することができますので、注意が必要です。
Microsoft Docs（「参照型のガイドライン」）では、型がイミュータブルな（変更できない）値を表現する場合、Equals メソッドのオーバーライドを検討することが推奨されていますが、ほとんどの場合において等価演算子 '==' はオーバーロードすべきでない、とされています。ここでは String クラスと StringBuilder クラスを例に、等価判定の動作を検証してみます。※以下、Assert.IsTrue なら () 内が 真、Assert.IsFalse なら () 内が 偽です。
※★印の箇所は注意が必要です。等価演算子がオーバーロードされています。等価演算子は Object 型のものが使用されます。String 型引数のオーバーロードが使用されます。Object.Equals(object) のオーバーライドが使用されます。中からオーバーライドされた Equals(object) メソッドが呼ばれます。「インターンプール」というテーブルに保持されます。※「インターンプール」については特殊編であらためて解説しています。ガイドラインに沿って等価演算子がオーバーロードされていません。
下の Equals メソッドとの違いに注意が必要です。StringBuilder 型引数のオーバーロードが使用されます。
Equals(object) メソッドが呼ばれているわけではないことに注意しましょう。Object.Equals(object) メソッドはオーバーライドされていません。
上のオーバーロードとの違いに注意が必要です。
まさに落とし穴的ですが、StringBuilder の表す値はミュータブル（変更可能）ですので、オーバーロード定義の是非はともかく、Equals(object) メソッドをオーバーライドしないこと自体はガイドラインに沿っています。型が違ってもコンパイルが通ってしまい、常に false を返すことになります。中からオーバーライドされていない Equals(object) メソッドが呼ばれます。
上の Equals(StringBuilder) オーバーロードとの違いに注意が必要です。いずれも参照比較です。True
False
True
False
False※弊社サイトにて2013年に公開したものを若干整理して転載しています。[.NET] 値型 等価判定の思わぬ落とし穴（一般編）
[.NET] 値型 等価判定の思わぬ落とし穴（特殊編）
[.NET] 参照型 等価判定の思わぬ落とし穴（一般編）
[.NET] 参照型 等価判定の思わぬ落とし穴（特殊編）


