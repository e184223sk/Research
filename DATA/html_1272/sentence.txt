More than 1 year has passed since last update.Unity-DOTSで作る2D弾幕シューティングの例の一回目です。早速Dotsから脱線しますが、このゲームでは敵のステータスやスポーン情報、
効果音のファイル名などの情報を全部ScriptableObjectで持たせます。
改竄対策としてデータ類はAssetBundleの形にして、
Addressableを利用して要所で読み出しするような形をとっています。
（枠を作ってあるだけで、実際にリモートからAssetBundleをダウンロードする実装までは作れていないですが）ScriptableObjectにするのはそれがおそらく一番読み込みが早かろうという理由からです。
例えば、敵のステータス情報は下記のような感じになります。
敵のスコアや耐久値、アニメーションのID値というようなものをここでデータとして持っておきます。
が、このままだとデータが増えていったとき、インスペクターが地獄のように長くなりますし、
変更したいデータを探すのも大変になってくるので、
編集のしやすさのため元になるデータはSQLiteデータベースで管理しています。さきほどの敵のデータは、DB上で下記のように設定してあります。
(データの編集はDB browser for SQLiteを使用しています)
まあ縦に長いよりは見やすいような気がしないでもない。
これをEditorスクリプトでScriptableObjectに変換しますが、
その際のSQLiteDBの読み込みにはSQLiteUnityKitを使用しています。
あくまで編集用であって、このデータベースファイル自体をゲームアプリ内に持つわけではないので、他のものでもいいかもしれません。データ変換を実行する契機になるボタンを持つScriptableObjectを下記のような感じで別に作っておき、

このボタンを押すと各テーブルが変換されて指定のパスに保存されるという感じです。
SQLiteからScriptableObjectに変換するコードは下記のような感じになっています。
ここでデータ変換を担う奴のことを、Creatorと呼んでいます。これをやってからしばらくデバッグ実行するとUnityがクラッシュする現象が多発して悩まされました。
原因はScriptableObjectの定義が別のファイルについでに書いてあったことでした。
わざわざこの定義のためにファイル用意するのめんどくせーなと思って一箇所にまとめていたのがよくなかったようです。
単独のファイルに下記のように定義を書くようにすると解消しました。これも頻発して何なんだと思いながらしばらく素直に再生成を繰り返していましたが、アセットデータベースへの配慮が足りていなかったようです。
DBファイルを更新してScriptableObjectを再生成する場合、生成したオブジェクトにDirtyフラグをつけておかないとこの事象が発生するようです。
この設定は、下記のように実行します。下記が参考になりました。
Scriptable Object resets after Unity is closed


