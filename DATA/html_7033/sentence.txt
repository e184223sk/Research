More than 5 years have passed since last update.C#に2種類ある日時の型（DateTime型とDateTimeOffset型）の違い、およびTimeZoneInfoを使った日時の正しい変換方法について書きます。C#にはDateTime型とDateTimeOffset型という2つの型があります。
前者は日時を表現するための型、後者は『日時＋協定世界時（UTC）からのオフセット値』を表現するための型です。DateTime型は『2016年8月29日 15時30分11秒』というところまでしか表現できない1ので、それが日本時間なのかアメリカ時間なのかによって、そのデータが指す時刻の解釈に揺らぎが出てきます。
※正確にはDateTimeインスタンスが指している時刻が、UTC時刻か、ローカル時刻か、それ以外の時刻か、のいずれかを指し示すことはできます。詳細は「捕捉: DateTime型のKindプロパティーについて」を参照下さい。対して、DateTimeOffset型では『2016年8月29日 15時30分11秒。なお、この時刻は協定世界時から+9時間された時刻』という一意に特定出来るところまで表現できるので、DateTimeOffset型で表現された日時は必ずある一点を指し、解釈は揺らぎません。なので、タイムゾーンを気にするようなシステムを構築するのであれば、基本的にDateTimeOffset型を使うことになります。2
また、データベースに日時データを保存するときにもDateTimeOffset型で保存しておくと日時の解釈に揺らぎが出ないので後から困りません。DateTimeOffsetとTimeZoneInfoを組み合わせて変換するのが一番楽です。
TimeZoneInfoは、あるタイムゾーンが世界協定時に対してどれぐらいオフセットがあるのかや、夏時間の有無やその変換ルールなど、タイムゾーンをまたいだ日時変換に必要となるデータを持っています。コードの前半部分では、DateTimeOffsetとTimeZoneInfoを組み合わせてタイムゾーンをまたいだ日時変換をしています。コードの後半では、DateTime型を使ったときに陥りがちな残念なこと（夏時間や冬時間の扱いが上手くいかずに日時表現がおかしくなる）の例を4つ並べました。DateTime型にはKindプロパティーがあり、そのプロパティーでDateTime型のインスタンスが保持している時刻の意味合いを下表の通り持たせることができます。
なので、時刻系のデータを扱うときは、必ず時刻が一意に特定出来るUTCにして扱う（KindがDateTimeKind.Utcになるようにする）というようにプログラムを組めば、DateTime型でも時刻変換に悩まされることは少なくなります。コメントで@yuba さんに指摘いただいたとおり、DateTime型だけで頑張るのであれば、具体的には以下のような点に気をつけてコードを書く形になります。協定世界時からのオフセット値が持てないだけで、DateTime型の分解能はミリ秒まであります ↩もちろん、データベースに保存するときには必ずUTCに変換した上で保存する、というようなことを強制すればDateTime型でもよいのかもしれませんが。 ↩


