More than 3 years have passed since last update.縦6×横6の升目の中に、10円玉6個、5円玉6個を入れてください。
そのとき、縦6列、横6列、対角線2列の合計14列の、どこも合計が15円になるようにしてください。解の一つを以下に示します。オリジナルの問題(出典不明)は、100円玉と50円玉を使うパズルだったのですが、画面に表示する関係で、10円玉と5円玉に変更しています。今回解いたプログラムでは、まずは、最上位の横の列（1行目）に、10円玉と5円玉を置き、次に2行目、次に3行目、...6行目と順にコインを置いてゆくという方法をとっています。
もちろん、途中で条件を満たさなく成ったら、試行をやめて、次の場所にコインを置きます。
これを再帰処理で求めています。2次元配列を用意して、ゴリゴリ組んでいっても良いのですが、ここでは、盤面クラス(Boardクラス)にパズルを解くのに必要な盤面を操作する機能を定義しています。
パズルを解くSolverクラスでは、このBoardクラスを操作して解を求めています。Coinクラスは、その名の通り盤面に置くことのできるコインを表しています。
implicit operator intでintへの型変換は暗黙の型変換ができるようにしています。Boardクラスはこのパズル専用のクラスで、後述のBoardBaseクラスを継承しています。
盤面の状態をコンソール画面に表示する機能は、このクラスに実装しています。まあ、これはProgramクラスに実装してもよかったかもしれません。そうすれば、コンソールアプリに依存するのは、Programクラスだけにすることができます。Solverクラスは、このパズルを解くクラスです。Boardクラスに定義したメソッドを使いながら、探索をおこない解を求めています。まず、1行目に10円と5円を置き、次に（再帰呼び出しして）2行目に10円と5円を条件に合うように置き、次に... と最後の行まで再帰処理すれば答えが見つかります。鏡像は、ほんの一部分だけを省いています。一部だけというのは、簡単に鏡像や回転を除くロジックが思いつかなかったというお恥ずかしい理由からです。僕が考え付くのは、解いた答えを覚えておいて、新たな答えが鏡像か回転に当てはまるかをいちいち調べるという誰でも思いつく力技。でも面倒なので実装していません。これ以外に良いやり方ってないのかなー。プログラムを制御するProgramクラスは、Solverクラスで解を求め、その解を表示するだけのとても単純なクラスです。このBoardBaseクラスは、「C#でパズルを解く - 碁石拾い」で利用したものと同じものです。前述のBoardクラスの基底クラスです。X × Y の盤面を表し、基本的な操作を定義しています。これは似たようなパズルでも再利用できるような汎用的な機能に絞っています。このBoardBaseクラスは、コンソールアプリに依存しない作りにしています。UWP、WinFormsでもそのまま使えると思います。このBoardBaseを継承して、当パズル専用のBoardクラスを定義します。内部では1次元配列を使っていますが、インデクサを定義して、1次元配列、2次元配列としても扱えるようにしています。
ただし、すべてのメソッドで１次元対応と２次元対応のものを用意するのは面倒なので、どちらか一方にしています。まあこれは好み以外の何物でもありません。１次元のインデックスによるアクセスができるようにしている理由は、一重ループで処理が書けるので、コードが簡潔になるからです。LINQのコードも書きやすくなります。2次元配列として見た場合の、X座標、Y座標は、0 からではなく、1から始まります。
つまり、board[1,1] は、いちばん左上を示し、8×8の盤ならば、board[8,8]が右下を示すことになります。なお、盤の周りには番兵用の領域を用意しています。これにより範囲外かどうかの判断を簡単に出来るようにしています。これが成功したがどうかは微妙ですが...上の図は 4×4の盤を表していますが、グレー部分が番兵が置いてある盤の周囲で、水色部分が実際の盤です。
盤面上の数値は、１次元配列のインデックスを表しています。BoardBaseクラスはジェネリッククラスにしていて、そのパラメータの型は、盤面上に置けるクラスの型です。想像以上に解の数が多かったですね。
答えの数が多いので、先頭の5個と最後の5個だけを掲載します。この記事は、Gushwell's C# Programming Pageで公開したものを大幅に加筆・修正したものです。


