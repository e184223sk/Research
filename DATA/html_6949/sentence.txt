More than 3 years have passed since last update.Enumerable.Repeat()の使い方ではまりんぐしたので、備忘録として投稿します。まずはこのメソッドついて。効能
elementで指定した要素をcount分繰り返したシーケンスを返してくれる。
戻り値そままだとIEnumerableだからクソの役にも立たない扱い辛い。
なのでチェーンメソッドでToList()やToArray()を呼び出し、指定した要素で初期化された
配列やらリストをゲットするのが定石かと。つまり、ということですな。
for文をゴリゴリ書かずとも初期化された配列を得られる。いいね！さて、このめっぽう便利でうま味なEnumerable.Repeat()君に早速ひと仕事してもらうと
しましょう。初期化のターゲットとして以下のクラスを作りました。
人間を表現するクラス（ここフリ）です。なお、職業選択の自由は保障されるべき
ものとしてJobプロパティは設定可能としました。で、↑のクラスを使う側のコードが以下です。いささか非人道的なコードですが、細かいことを気にしてはいけないのです。
Ctrl+F5を押下して、各分野で活躍しているヒーローたちに自己紹介をしてもらいましょう。残念ながらコンパイラが腐っているようです調査します。
と、意気込んだのはいいですが、persons[0]～[4]の指し示す先のアドレスが確認できませんでした。小一時間格闘しましたが、もういいや（投げやり）おそらく下の図の様な事になっちまっているんでしょう。
persons[0]～[4]の指し示しているオブジェクトは同一なので、
あたかも最後に加えた変更が全てに反映されているように見えます。
（注：そう見えるだけ）2016/10/12修正
コメント欄にて、Enumerable.Repeat()の実装を教えて頂きました。下記に引用させていただきます。
なお、.NET クラスライブラリの実装は下記サイトでガッツリ公開されておりました…
https://referencesource.microsoft.com/
結果を見るにつけ、Enumerable.Repeat()は以下のような実装になっていると思われ。（↑以前掲載していた妄想コードはプーなので削除）そりゃTResultが参照型なら同一オブジェクトを指す「参照のコピー」がポコポコできますわな・・・。
やりたいことは下の通り異なるオブジェクトへの参照を取得する事なのですが。てぃやあー！！（唐突）そもそも、書いてる人のおつむがアレターゲットが参照型であることに
起因する問題なので、値型に修正してリトライしてみます（強引）。
これなら異なるオブジェクトのコピーが生成されるはずです。無事、生成されているようですとはいえ、既に実装済みのクラスが他のクラスを継承しているとか、
引数無しのコンストラクタを必須としている場合は、上記の手抜き修正は適用できません。で、for文を使わずに参照型の配列を正しく得られるコードがないかと
ネットの海をプカプカと浮かんでいたところ、以下のようなコードを発見。ぐ、Range()とSelect()本来の使い方から逸脱しているような書き方ですが、
これなら別々の異なるオブジェクトへの参照を得られます。2016/10/12追記
コメント欄にてより良い代替案を頂きました。（コードは、少し変更しています）別途、Repeat()メソッドを作成。引数activatorに参照型の複数の異な(ryを
取得するメソッドを指定する方法です。上記の例ではラムダ式 
i =&gt; new Person( "クローン人間", 20, "無職" )
がこれに該当します。もちろん、値型もいけます。・Enumerable.Repeat()は値型専用。参照型に使ってはいけない（戒め）
・LINQで参照型の配列を得たいときは、Range()とSelect()の合わせ技でゲットすべしか
別途それ用のメソッドを定義して対処する。こんなんだったらEnumerable.Repeat()にstruct制約つけりゃ良かったのに・・・。
ﾌﾞﾂｸｻﾌﾞﾂｸｻ


