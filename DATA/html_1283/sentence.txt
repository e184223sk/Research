筆者は業務中、ASP.NET MVCを使い、リストをバインドした入力ビューを作成していました。コードとしてはこんなものです。さて、これを実際に動かしてみると、データは確かに表示されるのですが、HTMLが危険です。香ばしいにおいがプンプンします。idとnameが丸被り1のため、更新のとき、Hoge1の更新なのかHoge2の更新なのか区別がつきません。
また、データ属性が2列目以降省略されてしまうため、このままでは取り返しがつかなくなるでしょう。ここで、Modelの各要素をitem変数経由ではなく、直接Model.ElementAt(i)経由で読み出しても、idやnameがHogeとかになるだけでむしろ悪化しています。そこで、モデルの型をIList&lt;Product.Models.FooModel&gt;に変えてみたらどうなるでしょうか。まず、この変更の際にしておかなければならないことがあります。それは、@Html.DisplayNameForの引数のラムダ式を(model =&gt; model.firstOrDefault().Hoge)と変更することです。なぜIEnumerable&lt;Product.Models.FooModel&gt;だと@Html.DisplayNameForの引数がProduct.Models.FooModelと解釈してくれるのかは不明です。
item変数に値を取る形式の場合、IEnumerable&lt;Product.Models.FooModel&gt;を指定した場合と同じく、idやnameの値にitemが頭につきます。
直接Model[i]でリストを作成した場合、ようやく2列目以降にもデータ属性が追加されますが、idが生成されず、name="[0].Hoge"となり、すごく怪しい雰囲気です。
モデル自体をitemという変数に移し替えてみたらうまく行きそうな気がしますが、これもid="CS___8__locals1_item_0__Hoge" name="CS$&lt;&gt;8__locals1.item[0].Hoge"と変換されてしまう2ので使い物になりません。コントローラー「大丈夫だ、問題ない。IList&lt;Product.Models.FooModel&gt;でModel[i]を頼む」コントローラー側で次のように設定すれば、nameが少々変でも値を受け取ってもらえます。ここで、FooクラスはEntity FrameworkのFooModelに対応するDB上のモデルです。name属性が意味不明なものでも、各値の区別さえできればリストを受け取ることができます。ただ、もしかしたら素直にモデル定義の段階でIList&lt;T&gt;を内部に含むViewModelを作ってしまった方がいろいろと分かりやすい気もしなくは無いです。何らかの手段（ajaxやhtmlの&lt;template&gt;要素+JavaScript）を使用して動的に要素を追加する場合、nameを[n].hoge（ここでnは任意の整数）にしましょう。そうしないと追加された要素が同一のモデルであるとASP.NET MVCが認識してくれません。この辺りの面倒も、独自ViewModelを使うほうが設定の管理がしやすいですね。特にidの被りはhtmlの規則違反のため致命的です。 ↩nameがジェネリック型の定義に使われる&lt;&gt;を含んでいることからわかるように、これはC#内部で使われる値と思われるので、環境などによりitem前の名前は変わると思われます。 ↩


