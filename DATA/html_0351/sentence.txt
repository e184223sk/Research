本記事はC# Advent Calendar 2020の5日目の記事です。競技プログラミング用ライブラリについての記事ですが、競技プログラミングの記事ではなくソースジェネレーター開発記事です。
競技プログラミングのテクニックや知識については記述していません。あらかじめご了承ください。通常のC#開発では、NuGetからダウンロードするだけでライブラリを扱うことができます。しかし、単一のソースコードを提出する競技プログラミングにおいては、ライブラリへの参照を提出できないため、ライブラリのソースコードを提出ファイルにコピペする必要があります。これではNuGet配布もできませんし、依存関係も含めてコピペが必要となり非常に扱いづらくなってしまいます。それを解決するためライブラリ SourceExpander を作成しました。AtCoderで使用できるC++用のライブラリ ac-library の移植プロジェクトのac-library-csからフォークしてac-library-csharpを作成しました。このライブラリでは、SourceExpander を使用することで下記の動作を実現しています。でNuGetからインストールして、を実行すると、とライブラリのソースコードと合体したソースコードが出力されます。Sample Projectソースジェネレーターを使ってソースコードの埋め込み・利用を行うライブラリです。ac-library-csharpに限らず、ソースコードを埋め込みたいライブラリがあるならば使用できます。大きく3つのパッケージに分かれています。以下、それぞれについて解説します。ソースジェネレーターを作成する際は公式のドキュメントが非常に参考になるので合わせて見ることを推奨します。
https://github.com/dotnet/roslyn/blob/master/docs/features/source-generators.cookbook.mdとソースコード情報を AssemblyMetadataAttribute で埋め込みます。Assembly.GetExecutingAssembly().GetName().Versionで取得できるSourceExpander.EmbedderのAssemblyVersion。
ライブラリでソースコード埋め込みに使用したSourceExpanderのバージョンがライブラリ利用側のバージョンより低い場合に警告を出すなどの用途に使用します。ライブラリのC#バージョン。
ライブラリ利用側のバージョンがこれより低い場合に警告を出すなどの用途に使用します。ライブラリがunsafeを許可してビルドされている場合はtrueが設定されます。
ライブラリ利用側がunsafeを許可していない場合に警告を出すなどの用途に使用します。上記の例ではコメントアウトしていますが、SourceExpander.EmbeddedSourceCode.GZipBase32768と対応しています。のような型の配列を埋め込んでいます。例で示したSourceExpander.EmbeddedSourceCode.GZipBase32768はSourceExpander.EmbeddedSourceCodeのJSONと同等の情報を保持しています。としたものを埋め込んでいます。これを採用することで埋め込む文字列のサイズを1/10程度まで圧縮できました(ac-library-csharpの場合)。base32768 はバイナリデータをUTF-16文字列に変換するアルゴリズムです。C#の文字列はUTF-16であることやAssemblyMetadataに埋め込めるバイナリデータを埋め込むのに適していることから採用しました。C#実装が存在しなかったので移植しました。埋め込むためのSourceFileInfoを作成する流れについて説明します。GeneratorExecutionContext(ソースジェネレーターに渡される引数)のCompilation(コンパイル情報)に含まれるSyntaxTreesが埋め込まれるソースコードの本体になります。つまり、Microsoft.CodeAnalysis.SyntaxTreeがSourceFileInfoに対応します。SyntaxTreeはFilePathプロパティでファイルのパスを取得できるのでそれを使用します。入力されるSyntaxTreeが1つの場合はディレクトリ名を削除したもの、2つ以上の場合は最も上位の共通祖先ディレクトリまでを削除したものをファイル名とします。そして、それぞれのファイル名にアセンブリ名を合わせて{アセンブリ名}&gt;{ファイル名}としたものがFileNameプロパティの値になります。例：というファイル構成ならば、埋め込まれるファイルのFileNameプロパティはTestProject&gt;Root.cs, TestProject&gt;Extra\Ext.csになります。で取得します。各操作の説明というコードがある場合はFooの部分がSyntaxNodeです。namespaceの情報などは含まれません。一方、GetDeclaredSymbolではFooのSyntaxNodeがSpace.Fooという型情報を持っていることを取得できます。そのためSymbolが必要です。SyntaxTree.GetRoot()は実際にはCompilationUnitSyntax型です。CompilationUnitSyntaxはUsingsプロパティでusingディレクティブの定義が取得できるのでそこから取得できます。まずはSyntaxTreeで呼び出されている型の一覧を取得します。でシンボル情報を取得します。シンボル情報が何かはわかりませんが、型情報っぽいものを総当たりして呼び出されている型を列挙します。大量に重複する結果が出るのでDistinctしておきましょう。競技プログラミング的に考えると、SyntaxTreeの数を$N$として計算量が $O(N^2)$ とかになりそうでちょっと不安になりますが、$N$はせいぜい100とかなので実用上問題はなさそうです。別のソース埋め込みされたライブラリへ依存がある場合もここで解決しておきます。参照しているアセンブリのAssemblyMetadataAttributeはコンパイル情報から取得できます。あとは埋め込んだソースコードをパースしてSourceFileInfoとして扱えます。SyntaxTreeからusingディレクティブとスペースを削除したものを埋め込みます。CSharpSyntaxRewriterで削除します。スペース、タブ、改行、コメントなどのコード本体ではない箇所をすべて半角スペース(SyntaxFactory.Space)に置き換えることでコードを圧縮します。関連記事: 【ネタ】スペースも改行も使わずC#のコードを書くusingディレクティブを削除します。
node.Parent.IsKind(SyntaxKind.CompilationUnit)で親がRootであることを確認しているのは、namespace内にもusingディレクティブを書くことができ、その場合は削除しないようにするためです。C#のソースコードを生成する際には文字列リテラルとして埋め込む必要があります。たとえばのような感じです。文字列置換で実現しても良いのですが、Roslynへの参照があるのでRoslynで文字列リテラルを生成してしまうことにします。SourceCodeクラスは SourceExpander.Core パッケージでも定義しており、その参照がある場合はその型を使い、参照がない場合はSourceCodeクラスのコードも追加します。FromDictionaryで初期化しているのは、SourceExpander.CoreとSourceExpander.Generatorのバージョンが異なるせいでコンパイルエラーになるといったことにならないようにするためです。
こうすることで、コンストラクタ引数を増やしても破壊的変更にならずにすみます。基本的にはSourceExpander.Embedder-Dependenciesの生成)と同じ方針です。存在しないnamespaceをusingしているとコンパイルエラーになってしまいます。「ソースコードは使わないが、usingは書かれている」という状況で起こりうるので対処が必要です。元のコンパイル設定にかかわらず、CS8019,CS0105がエラーとなるコンパイル情報に置き換えます。そうすると、不要なusingのDiagnosticsが取れるので該当するusingディレクティブのSyntaxNodeを取得できます。SourceExpander.Generatorで埋め込んだソースコードを出力するだけです。Assembly.GetCallingAssembly()で呼び出し元のアセンブリが取得できるので、SourceExpander.Generatorで埋め込んだで埋め込んだSourceExpander.Expanded.ExpandedContainerをリフレクションで取得し、ファイルに書き出したり、文字列を返したりします。SourceExpander.ExpanderクラスはSourceExpander.Generatorパッケージに依存していたりと、提出できるようなソースコードにはなっていません。そこで、AssemblyMetadataを直接記述して実際とは異なるダミーのソースコードを埋め込みます。埋め込んでいるソースコードは以下になります。これで提出先ではなにもしないメソッドとして扱われるため安全です。いくつか特殊な対応が必要でした。ソースジェネレーター(およびアナライザー)をNuGetで公開する場合にはいくつか特殊な手順が必要です。NuGetに公開したときにPackageReferenceがとアナライザー用の設定になるよう、と入れるようにします。NuGetパッケージへの依存がある場合は、DLLをパッケージに含める必要があると公式ドキュメントにも記載があります。としてnupkgにBase32768.dllも含まれるようにしておきます。同一のソリューションにあるので、でジェネレーターとしては動作させずに、SourceExpander.Generatorへの依存だけを持たせられます。これによって、SourceExpanderを利用しているライブラリにSourceExpander.Generatorの動作を強制できます。これが別ソリューションだった場合にジェネレーターとして動作させずにパッケージの依存関係をもたせるならば、nuspecファイルを手書きする必要があります。xunitとxunit.analyzersの関係に近いので興味があるならば調べてみてください。自作ライブラリで活用しているテクニックを紹介しておきます。のように、引数でexpandモードだと判定したらexpandとして、そうでなければ普通に実行するようなコードにします。csprojのPostBuildでexpandモードで実行すれば、ビルド時に出力可能です。と設定すればのように明示的に設定したビルドのときだけソースコードが展開されます。別途ファイルを監視するなどすれば有効に使えるかもしれません。競技プログラミングライブラリ用のソースジェネレーターを作成してみました。もし良ければ、ac-library-csharpを利用したり、自作ライブラリにSourceExpanderを組み込んだりしてみてください。などを検討しています。


