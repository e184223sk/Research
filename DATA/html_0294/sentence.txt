はーい、よーいスタート(小声)めんどくさいことしたくないからRPA始めたのにパスワード管理でめんどくさいことし始めているRTA、はーじまーるよー。
今回走っていくのはRSAで暗号化したパスワードをRPAで利用するためのシステム作りです。みんな大好きWinActorは国産RPAツールとして導入率ナンバーワンとして人気を博しています。
しかし、WinActorはRPA(Robotic Process Automation)というよりはRDA(Robotic Desktop Automation)としての趣が強く、各個人のタスクを自動化するには十分ですが、導入から時間が立ち、全社展開など大規模化してきたときに管理能力の無さが目立ちます。
そこで今回はWinActorの控えめに言ってｳﾝﾁｰｺﾝｸﾞちょっと足りない管理能力を補うため、パスワードの登録・更新・取得を行うためのシステムを自作したいと思います。もっとも、WinActor以外の主要5大RPAソフトウェアはパスワードの保管方法を標準で持ってるんですけどね、初見さん。
参考：【RPA】ログイン情報の保管方法/ツール別比較WinActorには変数にマスクをかけて外部から見えないようにする機能があり、これで見えてほしくない値を管理してくださいと言ってます。
これ幸いと、ログイン処理を必要とする業務を自動化するように依頼されたときにこれでパスワード管理、ヨシ！　とされた方、1年後に「どうしてあの時ヨシ！って言ったんですか？」となるかもしれません。
各社の管理形態にも依りますが、弊社ではこのようなことが起こりました。だから以下の要件をすべて満たすパスワード管理ソフトを用意する必要があったんですね。RSA暗号鍵を作成するアプリ？です。
コマンドラインでopensslと入力し、以下のメッセージが表示される場合はWebからインストーラをダウンロードしましょう。
Win32/Win64 OpenSSLRSA暗号鍵を利用してパスワードの暗号化・復号を行うアプリケーションを作成します。
インストール方法や使い方は腐るほどページがあります。ググりましょう。管理できるならAccessでもExcelでも、最悪csvでも良いです。
ストアドプロシージャや制約を使える利便性を考えればRDBを使うのが一番だと思います。古の作法に則り、暗号化・復号を行うアプリ君と、更新時期警告アプリ君に名前をつけた時点から始めます。
入力速度を考慮してhomo.exe,les.exe,yajuu.exeでもいいですが、そんなことしたら保守する人に怒られちゃうだろ！となるのでわかりやすい名前にしましょう。タイマーストップはアプリケーションのコーディングが終了し、以下の要件をすべて満たすシステムが完成したところです。それでは計測開始です。先駆者様が詳しく説明して頂いてます。是非LGTMしましょう。
C#でRSA暗号を使って署名や暗号化するコマンドラインに以下を打ち込み、2048bitの秘密鍵を作り、それを参照して公開鍵を作ります。これによりprivate-key.pemとpublic-key.pemができました。
.pemは見慣れない拡張子だと思いますが、これをメモ帳で開くと以下の形のテキストファイルになっています。このBase64エンコードされた文字列が暗号鍵になっており、これをDER(バイナリー形式)に変換して利用します。
先駆者様はC#でPEMファイルをBase64デコードして、DER(バイナリー形式)にするチャートを採用していますが、私は初めからPEMをDERに変換した状態でコーディングするチャートにしました。試走ではPEMファイルを使うチャートでしたが、PEMをそのままの内容で読み込むとエラーとなります(環境によるかもしれませんが)。
詳しくはこちらをご覧ください。私はこれで4時間溶かすガバをしました。
OpenSSLで作成したRSA暗号鍵をC#で読み込む方法 4. 実行結果上記のようにPEMファイルのまま利用するにはbyte変換コードを加える必要があるのですが、今回のレギュレーションはPEM縛りではないのでDERに遠慮なく変換します。テスト用プロジェクトを作成し、秘密鍵private-key.derと公開鍵public-key.derをリソースファイルにぶち込んで、暗号化と復号が問題なく行えることを確認しましょう。
リソースファイルは名前をそれぞれprivate_key,public_keyに設定し、FileTypeにBinaryを指定します。
以下のコードを打ち込みます。これでPlaneTextがCipherTextを経由してDecryptTextになっていることを確認できました。
あとは暗号化部分のコードとpublic-keyをRPA_Password_Uploaderに、復号コードとprivate-keyをRPA_Password_Decrypterに移植すれば工事完了です...安定を取ってテスト用プロジェクトを挟みましたが、再送するならここがタイム短縮ポイントになると思います。SQL Serverの構築方法も公式ドキュメントが充実しています。読みましょう。RPA管理者と現場の担当者の両方がアクセスできるサーバーにデータベース[rpa_db]を作ります。
ローカルで作ってテストしてから移すのが安パイです。以下のマスタを作ります。今回のパスワード管理で最低限必要なテーブルです。
これらをJOINしたビュー(v_password)を作っておくと後々の開発に役立ちます。
あとは任意で以下の設定をするとより強固になります。新しいデータベースダイアグラムから作ると関係がわかりやすいです。@person_id, @system_id, @cipher_textを引数に、t_passwordにパスワードを新規登録、または更新するストアドプロシージャを作ります。
このストアドプロシージャの振る舞いは、であることが求められるため、MERGE構文を使いましょう。ここまでくれば後は消化試合です。
Uploaderは社員番号、システム名、パスワードを入力してもらい、パスワードを暗号化してs_update_passwordを起動するフォームアプリに、
Getterは社員番号、システム名を引数にパスワードを復号するコンソールアプリにしましょう。実際のコードは自分で打って確かめてくれよな！！自分で作ったはいいものの、主要な部分だけを抜き出すのが難しいコードになってしまい、コードを載せることができませんでした。ﾕﾙｼﾃ･･･c#でメールを送信する場合、.NETのSmtpClientを利用する記事は多いですが、SmtpClientは廃棄予定らしいです。
NuGetでMailKitをインストールし、MailKitからメール配信を行います。
今回は本文の装飾にもこだわり、HTMLで文字の強調やリンクを付けるようにしました。メールサーバーを持たない会社の場合、Outlookを起動して送信するプログラム等にしましょう。
もしTeamsやSlackでBotを作れるなら、Botに発言させるのもいいと思います。ここでタイマーストップ！
記録は・・・30時間弱ですかね（体感）さて、完走した感想ですが（激うまギャグ）、
自分で0から仕組みを考え、環境を作り、コーディングする作業はやりがいがあるものの、RPAでは味わえないコーディングの楽しみを覚えました。
しかし、C#の経験が薄いせいか、もう少し詰めたコーディングができたかと思ってます。
データベースが用意できるならDataSetを使えば簡潔にコードを書けたし、UploaderやGetterのコードも載せることができたかとおもいます。
あとは、仮にもRTA実況風解説を冠するなら、動画とは言わずとも写真とかうまく使えれば面白く作れたかと思います。技術記事は難しいですね。今回の記事はここまでとします。ご視聴、ありがとうございました。
皆さんのRPA (Robotic Process Automation) Advent Calendar 2020記事、楽しみにしております。


