More than 1 year has passed since last update.前回「【.NET】進捗ダイアログ画面で動的DLLの進捗状況を表示する」を作成しましたが、メイン画面(EXE)を閉じないでクラスライブラリー(動的DLL)を差し替えようとすると下記のエラーが発生します。
今回はこの問題を解消して、メイン画面(EXE)を閉じないでもクラスライブラリー(動的DLL)を差し替え出来るようにします。.NET(マネージド)では、Win32の時のFreelibrary関数(DLLを呼び出しプロセスの アドレス空間から切り離す)のようなものはなく、一旦DLLをロードしたらプロセス(Default AppDomain)を終了するまでメモリに残り続けます。通常のDefault AppDomainにロードされている場合において
AppDimainとは、単一プロセス内で分離された複数の実行領域(domain)を提供します。
具体的には、単一プロセスの中に型やセキュリティを管理する単位としてアプリケーション・ドメイン(AppDomain)という器を作成し、その中で処理を実行させます。AppDomainは、CreateDomainを使用してユーザードメイン(User AppDimain)を複数作成することができます。各AppDomainは小型のプロセスのようなもので、同じプロセス内にあるドメイン間通信は本物のプロセス間通信より高速ですが、Remoting境界を越えた往来が必要となるため、パフォーマンスは多少の影響が出ます。ユーザードメインを生成し、そこにアセンブリをロードして実行します。終了時にユーザードメインをアンロードすることで解放が可能になります。
参照:動的ＤＬＬの解放について言葉通りなら上記でも良さそうですが、実際にはこれではDLLを解放することが出来ません。普通にユーザードメイン(User AppDimain)を生成して遅延バインディングをしてしまうと、.NETのメタデータ(≒ 型情報)などのアセンブリがメインのAppDomainにロードされることになり、動的なアンロードができなくなります。
これを避けるには、ドメイン間通信で参照(アドレス)だけ渡したり値をシリアライズして渡したりする必要があります。具体的にはプロキシークラスを使う方法とインターフェースクラスを使う方法があります。
ネット上にあるサンプルの多くは、インターフェースクラスを作成してます。インターフェイスを使うと静的リンク時と同様の記述でプロパティやメソッドを利用出来るので分かりやすいです。プロキシクラスではパラメータがSystem.Stringでシリアライズ可能なら、他から購入したライブラリなどをアンロードしたいときに利用できる可能性があります。一方、インターフェイスではロードしたいアセンブリのソースに手を加える必要があります。取込バッチ処理のクラスライブラリー(DLL)は動的な参照とします。
進捗状況をイベントで受け取りプログレスバーに進捗状況を表示することにしました。今回は進捗ダイアログ画面をクラスライブラリー(DLL)に分離し、メイン画面からプロキシークラスを使用して進捗ダイアログ画面(DLL)をAppDimainを作成して実行します。理由として、最初は取込バッチ処理のクラスライブラリー(DLL)をAppDimainを作成して実行したのですが、実行はできたもののAppDimainをアンロードしても解放できなかったのです。どうもイベント(OnUpdate)を関連付けた際にメインのAppDomainに参照が残ってしまうのが原因のようです。バックグラウンド処理にはBackgroundWorkerコンポーネントを使用しています。
前回頂いたコメントを反映して「ProgressChangedEventArgs」を使用しています。今回は別のスレッドからForm上のコントロールにアクセスしたことにより「有効ではないスレッド間の操作」の例外エラーとなったため、コントロールに対してはInvoke((Action)delegate (){}) で囲んでいます。 実行ボタンで進捗ダイアログ画面を表示するfrmMain.cs内に追加しています。クラスライブラリー(DLL)で、進捗状況のイベントを発生させ進捗値を渡します。
処理内容はサンプルなので適当です。今回は[Serializable]属性ではなく、MarshalByRefObjectを継承しています。
参照:MarshalByRefObjectとSerializableのちょっとした違い (アプリケーションドメイン, 境界越え, Assembly, AppDomain, CreateInstanceAndUnwrap)SubProccess70()の戻り値を true -&gt; false に変更。
今回これを作成するにあたり、プラグイン作成関連を調べました。System.AddInとMEFは調べるまで知らなかったです。
これから拡張機能を作成するならMEF2を使用していくのがいいでしょう。System.Addin(MAF - 管理アドインフレームワークとも呼ばれる)は、バージョン3.5以降、.NETに存在します。アプリケーションにアドインとかプラグイン機構を作りこむためのライブラリ。
System.Addinでは、使用されなくなったAppDomainを自動的にアンロードし、メモリを再利用できるように管理している。
フォルダ構造が決まっちゃってるなど、かなり面倒くさい。2008年のリリース以来変更が加えられていません。MEFはプラグイン的な動的ローディングをサポートするためのフレームワーク。
MEFは、.NET Framework 4からは標準ライブラリに取り込まれ、System.ComponentModel.Composition名前空間以下のクラスがMEFの実体となります。
MEF2は、.NET Framework 4.5以降で使用できる。今回「進捗ダイアログ画面で進捗状況を表示する」シリーズを作成して、知らなかった知識を得られました。
今回作成するにあたり参照した記事はどれも古いものが多く、それだけ需要がないんでしょうね。メイン画面を終わらせれなかったり、Windows サービスや常駐プログラムのように常時稼働しているタイプのプログラムで、停止や終了をせずに参照しているプログラムを入れ替えたいという要望がどのくらいあるのか分かりませんが、何かの役には立つと思います。


