仕事でMonobit Unity Networkingについて調べる機会があったので，備忘録がてら記事にしました。
チュートリアルの内容のまとめと，ちょっと使うときに便利かなと思った実装法を中心に書きます。
サーバとかの設定は公式が結構ちゃんとドキュメント出してくれてるので（参考），この記事では基本的にコードとかの実装方面をまとめていきます。
かなりふわふわしてる記事なので，間違い等あればコメントで指摘していただけると幸いです。
あと掲載コードについては申し訳ないんですが，全部について動くかの検証はしてないです。動いたコードに近いコードを載せるように努力してますが，動かなかったら文句言ってください。気力や時間があったら検証します。Monobit Unity Networking(MUN)とは，モノビットエンジンが提供する国産Unity用通信ミドルウェアです。つまりUnityでマルチプレイとか通信とかをやるためのアセットです。
通信量に合わせて課金されるタイプなので，全機能を使うのにお金はかかりません。
基本的にはUnityで作ったクライアント間のP2P通信で，この記事では取り上げませんが，オンプレミス版も提供されています。
詳しくはここUnity 2020.3.5f
MUN 2.8.0ルーム：プレイヤーが実際に通信している部屋
ロビー：ルームの集まり，ここではプレイヤー間の通信はできないMunを使う上で，MonoBehaviorの代替クラスがあります。主にMonobitEngine.MonoBehaviorとMonobitEngine.MunMonoBehaviorがあります。後者は接続やルームの入室のコールバックが定義されてます。
MonobitEngine.MonoBehaviorはMonobitEngine.MunMonoBehaviorを含めた大体のMonobitで定義されるコンポーネントの基底クラスになってるという特徴がありますが，多分ユーザで使う分にはMonobitEngine.MunMonoBehaviorを継承しとけば十分だと思います。だって継承されてるからMonobitEngine.MonoBehaviorの全機能使えるし。ちなみにちょくちょく出てくるMonobitEngine.MonobitNetworkは静的クラスなのでMunを導入しておけばどこでも呼べます。公式記事（サーバへの接続）
公式記事（サーバからの切断）この際，MonobitEngine.MonobitNetwork.autoJoinLobbyを事前にtrueにしておくとデフォルトのロビーに入ってくれます。公式記事（ロビー入室）
公式記事（ロビー退出）
前述したMonobitEngine.MonobitNetwork.autoJoinLobbyのフラグを立てて入室してやるとここら辺の処理は省略できます。LobbyInfoにはNameとKindのプロパティがありますが，Kindはドキュメントにも詳しい仕様が書いてなかったので正直よくわかりません。誰か見つけたら教えてください（他力本願）公式記事（ルーム一覧の取得）
また，ロビーの中からは公開ルームの一覧を取得できます。公式記事（ルーム作成）
公式記事（ルーム入室）
公式記事（ルーム退出）roomSettings周りが結構複雑です。これには次のプロパティを設定できます。特にcustomRoomParametersがよーわからないと思います。これはつまりHashtable型のいろんなタグパラメータをつけられるっていう感じで，JoinRandomRoomとかの絞り込みに影響します。
詳しくはこちら（公式記事）
例を示します。というルームを作ると，でそのルームにマッチングできるようになるはずです。
公式記事ではroomParametersに対してインデックスを指定して書き込む方法で例が示されていますが，自分の環境ではそれをやると「roomParametersの中身なんもねぇよ！」って怒られたので，こちらでは自分で作ったHashtableで上書きしています。こちらだと通ることも確認しています。参考公式記事
こちらはほぼスクリプトなしで実装できます。同期したいオブジェクトにMonobit Viewを追加し，
位置ならばMonobit Transform View，アニメーションならMonobit Animation Viewのスクリプトを追加して，
Monobit ViewのObserved Component Registration ListにMonobit Transform ViewやMonobit Animation Viewを追加します。
これでとりあえず位置の同期は完了です。公式記事（オブジェクト生成）
公式記事（オブジェクト破棄）
ネットワーク越しで生成や破棄を同期させたいオブジェクトに関しては，UnityEngine.Instantiateするとうまくいきません。（どううまくいかないかは検証して追記するかもしれないです）MonobitEngine.MonobitNetwork.InstantiateはResources.Loadを使ってるようなので，生成するプレファブはResourcesフォルダにないといけません。あと指定するのがプレファブのGameObjectではなくプレファブ名なのも注意。公式記事（オブジェクトの所有権）
参考公式記事
さて，ここまでの作業でとりあえずオブジェクトの生成と位置やアニメーションの同期はできますが，操作キャラだけはもうちょっと作業が要ります。というのも，同期された相手のオブジェクトはこちらのシーンに召喚される都合上，何も対策をしないと同期されてきた相手のオブジェクトも操作できてしまうため，位置の同期とこちらの操作で干渉してなんか変なことになります。
そのため，自分が所有権をもつオブジェクト以外は操作しないというスクリプトを書いてやらないといけなくなります。
具体的には，自分がオブジェクトの所有権をもつかは，MonobitEngine.MonoBehavior（またはMunMonoBehavior）内のmonobitView.isMineプロパティで判定できます。これを使って操作スクリプトを無効化してやればいいです。実装例は下の方にあります。公式記事
MonobitEngine.MonoBehavior（またはMunMonoBehavior）なら，ネットワーク越しでRPCという手法によってメソッドを呼び出してやれます。
まず，呼び出したいメソッドに[MunRPC]を指定します。
MonobitViewを適当なオブジェクトにアタッチしてやり，MonobitViewIDを0以外の適当な正の整数値にしてやります。
それを[SerializedField]なりGetComponentなりで取得してやって，MonobitViewのRPC()メソッドを呼べばOKです。
なんのこっちゃってなってると思うので例を示します。サーバに繋いだ時や，ルームに入った時など，いろんな時に対してコールバックが用意されています。数が多いのでここでは紹介せずこちらを参照していただきたいですが，一つだけハマりそうな部分なんですが，コールバックの利用はMunMonoBehaviorを継承する必要があります。逆に言うと，MonobitEngine.MonoBehaviorではコールバックが利用できません。
理由はコールバックはMunMonoBehaviorのメソッドをオーバーライドする形で実装されてるため，MonobitEngine.MonoBehaviorではそもそものメソッドが定義されてないんですよね。もうMunMonoBehaviorだけでいいんじゃないかな。公式のチュートリアルでは操作スクリプトに直接所有権の判定を組み込んでいますが，操作スクリプト一個一個に組み込んでるとキリがないですし，基本的にゲーム自体の開発してる時は通信のことなんて考えたくないと思うので，個別に管理してくれるコンポーネントを作った方が管理しやすいと思います。これでインスペクタに所有権があるときに有効/無効にするリストができてくれるので設定してやればいいです。MUNはルームに対してパスワードを設定できたりはしないんですが，こちらのPhotonの記事のようにカスタムパラメータをつけて，RandomJoinをやってやればそれに近いことをできます。
簡易的な実装例ただ，これだと同じルーム名・パスワードが同時に発生した場合に対応ができないので，外部に認証サーバを設けてルーム名を管理してやらないと実用に足るものはおそらく作れないと思います。MUNでできること
・ネットワーク越しのオブジェクトの位置やアニメーションの同期
・ネットワーク越しでのメソッド呼び出し
ちょっとよくわからない部分がなくもないですが，使ってる感じは問題ないような感じがします。MUNチュートリアル
MUNのAPIリファレンス
パスワードのかけかたとか：Photonのドキュメント
ランダム文字列


