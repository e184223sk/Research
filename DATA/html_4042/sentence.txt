 ソースジェネレーターと Arc.Collection を使用したC#ライブラリです。オブジェクト間に複数のリンクを張って、柔軟に管理したり検索したり出来ます。よく分からない？オブジェクトT に対して、カスタムList&lt;T&gt; を作成します。しかも、普通のジェネリックコレクションより柔軟で拡張性があり、なおかつ高速です。一言で言えば、速くて便利！オブジェクトを扱うプログラムでは必須です！ええ、こんな説明じゃ分からないでしょう。下のサンプルコードをみてください。ソースジェネレーターなので、ターゲットフレームワークは .NET 5 以降です。まずはPackage Manager Consoleでインストール。サンプルコードです。パフォーマンスは最優先事項です。CrossLinkは、ジェネリックコレクションより込み入った処置を行っていますが、実際はジェネリックコレクションより高速に動作します（主にArc.Collectionのおかげです）。SortedDictionary&lt;TKey, TValue&gt; と比べてみましょう。H2HClass という簡単なクラスを作成します。ジェネリック版。クラスを作成し、コレクションに追加していきます。こちらはCrossLink版。同じような処理をしています。こちらが結果。 なんとSortedDictionary&lt;TKey, TValue&gt; より高速です。Id を変更すると、当然コレクションの更新（値の削除・追加）が必要です。CrossLinkは断然高速で、SortedDictionary の約3倍のパフォーマンスです（CrossLinkは内部でNodeを保持しているので、当然と言えば当然ですが）。CrossLinkは既存のクラスに、GoshujinClassという内部クラスと、いくつかのプロパティを追加することで動作します。実際には、という流れです。用語実際に、ソースジェネレーターでどのようなコードが生成され、どのようにCrossLinkが動作するのか見てみましょう。まずは TinyClass という非常にシンプルなクラスを作成します。メンバーは id 一つだけです。プロジェクトをビルドすると、CrossLinkはまず GoshujinClassという内部クラスを作成します。GoshujinClass は TinyClass を操作・管理するクラスです。次のコードでは Goshujin インスタンス/プロパティを追加します。最後に、メンバーに対応する Link と プロパティを追加します。inally, CrossLink adds a link and a property which is used to modify the collection and change the value.Chainはオブジェクトのコレクションクラスのようなもので、CrossLinkでは以下のChainを実装しています。こーゆーChainが欲しい的な要望ありましたらご連絡ください。複雑にリンクされたオブジェクトのシリアライズは結構面倒です。しかし、Tinyhand との合わせ技で簡単にシリアライズできます！やり方は簡単。Tinyhand パッケージをインストールして、TinyhandObject 属性を追加して、Key 属性を各メンバーに追加するだけです！テストコード：Link 属性の AutoNotifyプロパティを true にすると、CrossLinkは INotifyPropertyChanged を自動で実装します。テストコード：生成コード：デフォルトの動作では、オブジェクトのGoshujinが設定されると自動でオブジェクトをリンク（GoshujinのChainに登録する）します。自動でリンクしたくない場合は、AutoLink プロパティを false に設定してください。MVVM？バインディング？面倒なことばかりでしょう。ObservableChain を使うと、簡単にバインディングできます。コンストラクタに [Link(Type = ChainType.Observable, Name = "Observable")] を追加するだけです。テストコード：


