More than 1 year has passed since last update.　2019年は、設計の年でした！・UniRx *1
・UniTask *2
・Zenject *3(Extenject *4)これらがないと開発できない体になってしまった。　UniRxといえばこれ！というくらいよくある書き方。去年から学び始めて今年の5月くらいまではずっとこの書き方をしていました。　ViewとModelを独立させるだけもそこそこ書けていた。ただ、ScriptableObjectがやったら多くなったりInspectorでポチポチしたり、Presenterが肥大化したりと問題点も何かとあったり。。。
　このあたりでZenjectを知って本格的に設計について考えだすようになった。　いざ設計について考えだすと言っても、知識皆無だったのでどこに踏み出せばいいかわからず・・・。巷で噂のClean Architectureからとりあえず、と手をつけ始めたのが全ての始まり。いろんなサイトをみて回るもみんな書いてることが違う・・・＾ｐ＾　とにかくいろんな記事を読んで試してふわふわした知識をひたすら身につけていた。7月あたりにお勧めされていた「Clean Architecture 達人に学ぶソフトウェアの構造と設計」を購入して知識を整理しだした(この本には大変お世話になりました)。そして2019年での最終的な理解は以下のように。
各レイヤーは、Assembly Definitionによって１つ上のレイヤしか参照できないように制限してあります。Applicationへの参照は特に制限していない。本を買う少し前までは依存性逆転の原則をよく理解していなくて、IOutputPortやらがViewレイヤにあったりした。　Domaiは、最上位のレイヤーで、ロジックは全てここに書かれています。Entityは、状態の管理、数値計算を行います。このレイヤはどのレイヤにも依存せず、基本的に変更も行わない。そして全ての処理は必ずこのレイヤを通過する。　Entityに実装するinterfaceは、メソッドやプロパティを持ちすぎないように気を付けています。ここが肥大化すると以下のクラスで責務が集中したり、クラスによって使わないメソッドがあったりと全体に影響が出てしまいます。個人的な目安は、２つ以上のメソッドやプロパティを持ち始めたら、実際に使うシチュエーションを考えて見直すようにしています。　UseCaseは、各Entityを用いてロジックをゲーム内で使える形に変換して提供します。時にはDataレイヤからDBにアクセスしてEntityに書き込んだりもします。　しょっちゅう肥大化するUseCase君。この辺はまだまだ慣れてなくてうまく設計できない。。。
EntityのReactivePropertyやSubjectをそのまま流すだけになることもあるのでこのレイヤはいらない子なのではとなることも。　表示やら入力やら、ユーザが触れる部分がこのレイヤになります。　全ての起点、Zenjectへの依存、Subscribeを許可しているのはこのレイヤーのみ(一部例外が・・・)。必ずIInitializable、IDisposableが実装されている。逆にこれ以外の実装を持つことはほとんどない。　Viewが増えるたびにPresenterがどんどん増えていくので管理が結構大変になる。上手な管理方法や整理方法を考え中。。。　MonoBehaviourを継承するレイヤ。IPoolableを実装する場合のみ、Zenjectへの依存を許可している。　Dataレイヤは通信やらUnity外のデータアクセスを担当します。小中規模だとこの辺あまり使わないのであんまり自信なし。。。　Gadewayは、通信もしくはRepositoryへのアクセスを担当します。　通信系はここに書くべきなのかなぁと思いつつ。ここには書いてないが、CancellationToken渡そうとすると結構エグい。　ローカルのJsonやExcelを読んだり、ScriptableObjectにしたり。Applicationレイヤは上記のレイヤとは独立していて、レイヤの参照は特に制限していない。　Value Objectは、各レイヤ間で受け渡すデータ構造を定義している。　Factoryの定義は全部ここ。FactoryのみDiContainerをInjectすることを許可している。　UIの遷移にはScreenFactoryを作って、画面をStackで管理する方法をよく使ったり。　外部から受け取るデータの構造はここに書く。[Serializable]を書かなきゃいけないことをよく忘れる。　Signalは、Presenter → UseCase → Entity → UseCase → Presenter という流れを省略する意図で使っている。例えば音など、画面遷移など、１つのクラスに依存が集中することが多い割に中身は単純なクラスなど。なんか使いこなせてる感じがしない。　Domain、Dataレイヤは、大体最上位シーンのSceneContextにBindしている。その他はPlefab単位でInstallerを作って1Prefabに1GameObjectContextという形にしてある。GameObjectContextをやたらめったら使う方法がいいのかは謎。特に画面遷移では、画面を生成破棄しているので、パフォーマンスよくない気がしてる。NestedPrefabをゴリゴリに使う。UIではPrefabの集合をScreenと定義して、画面の切り替えをScreenの生成破棄、表示非表示で管理している。
　基本的に１Prefabにつき１InstallerになるのでInstaller以下とPrefabs以下のディレクトリ構成は同じになる。　約半年間Clean Architectureを勉強してきたが、結局これが最適解かと言われるとなんか違うよなぁとなる。アウトゲームではうまく機能するが、インゲームではUIとオブジェクトのScopeが噛み合わないような気がしてならない。今のところインゲーム用のGameObjectContextを用意して、それに専用のCanvasを生成させたりしている。
　レイヤの切り方もまだ冗長かなと思うこともしばしば。特にEntityからPresenterに繋ぐだけのUseCaseがいらない子のように感じたり。オニオンアーキテクチャなり別のレイヤの切り方も勉強しなきゃなぁというのが来年の課題。　半年、設計の勉強をしてきたけど奥が深すぎてズブズブと沼に・・・。このへんは慣れなのかなぁ。まだまだ小中規模の開発でしか試してないのでなんとも言えなさ。
　来年は他の設計にも軽く触ってみようかな。全てのきっかけをくれた知見の塊「Unityゲーム開発者ギルド」はいいぞ。*1 UniRx
*2 UniTask
*3 Zenject
*4 Extenject
　


