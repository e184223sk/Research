More than 1 year has passed since last update.型を修了. 演算子/制御構文についてやっていく用語の解説. オペレーターこと演算子に対してオペランドこと被演算子が存在.X(operand) =(operator) 3(operand) +(operator) 2(operand)c#においては, 何かしらの値を返すもののことを式といい, 式から構成されて";"で占められる構造を文(値を返さずともよい)というんだってあるあるのやつら. インクリメントとデクリメント久しぶりに見た.インクリメントとデクリメントに関しては前置か後置の違いで副作用が変わる."+"は文字列結合も表す. 数値と文字列における暗黙的な型変換のルールを確認するちなみに文字列ではなくて'a'+2を実行してみたら99と返ってきた.
そういえばcharは数値だったね...基本的に文字列型に優先して変換される模様.
DateTime.Nowみたいなものも内部でToStringが呼ばれるみたい.ただしよく覚えておこうちなみにJuliaという言語で文字列結合が"*"扱われている理由が, 文字列結合は可換ではないから積だ! というのを思い出した. 次いこう　+ による文字列結合はimmutableなstringに対しては非効率なので, 5~6文字程度の連結じゃなくループ内での連結の時はmutableなstringを使おうとのこと
`StringBuilder'クラスというのがそのmutable stringらしい.
中で大き目のメモリを確保するらしい.あらかじめあらかたの文字列サイズが決まっている場合はStringBuilder(1000)という風にサイズを指定したほうが良いらしい.
オーバーヘッドしたときの処理が大き目なのだそうな前置, 後置演算での挙動の確認がはいった.
基本的に意識する必要はないが, 変数の代入の際に気を付けたほうが良いとな1++などはできないらしい.
つまり, (m++)++もできない. (式評価の値が返るため?)mに二回インクリメントをしたいのであれば, m+=2を使おうとのこと.また代入の操作が入ってしまうため, constに対する操作もきかない少数に対して暗黙型変換が発生する.
個人的に double result = 3/4 // 0 というのが, たしかに, ポイントだった整数だとError, 少数だと除算の場合∞が, 剰余の場合はNaNが帰るらしい.数学においてはゼロ徐算は定義不可能となるはずなんだけれど...なぜこうなるんだw浮動小数点は0.1をうまく表現することができないから, 一部の実行をするときは丸めないとだめだよという内容
float/doubleでは内部ではこの誤差はカバーできてないため, decimal型を使おうただし, decimalは計算は遅いし, 扱える範囲も狭い. そのため, 整数計算をした後で10で除算する方法も追記.2*3 / 10d == 0.6 // true今までつかってきた代入演算子と, 算術なりビット演算と代入を一括でやる演算子.任意の演算子をXとしたとき, 複合的な代入演算子はi X= j &lt;=&gt; i = i X j と互換を持つ.毎度毎度ビット系の演算子, 把握するはいいけど使ったことはないから挙動を知らないんだよなぁ...
勉強をしなければ参照渡しの話っぽい.
参照型の変数を別の変数に代入したとき, その変数に代入されるのはリテラルではなくてアドレスのため, 後者の変数に値を再代入するとアドレス先の値が変更されるため, 同じアドレス先を参照している前者の値も変更されるとかそういうやつtrue/falseを返す演算子たち. 比較演算子のほうが聞き馴染みがある要するに, ==の演算子を使うとき, 参照型をただ単にA==Bのように比較させてしまうと, 参照型はアドレスを返すため, 同じ値をA, B両辺持っていたとしても異なるアドレスを持っているのならばfalseを返してしまう.その場足はEqualsメソッドを使おうただし文字列型のstringだけは参照型にもかかわらず, デフォルトでEqualsメソッドを呼び出すようにしてあるらしい.
Equalsメソッドは型安全を保証してないので逆に非推奨なのだとか.==が型安全な言語ってなんか新鮮だ...本質的に十進法の表記に向いていない浮動小数点は比較の際に丸めをするなり, decimalを使用しようねというもの.また, 丸め単位を指定してやる古典的な方法もあるこうすることで, 誤差EPSILONまでの範囲でxとyの同値性が担保できる.
ただ個人的にはMath.Roundでいいのでは...とも思えてしまう.
切り捨てる部分の問題なのだろうな配列の比較は==は参照型のため使えないけれどequalsメソッドも同様に比較する先がさらなる参照なので使えない.
要素数が1の時も, 空配列の時でもダメだった.EnumクラスのSequenceEqualメソッドを使えばいいらしい.いわゆるの三項演算子. score &gt;= 70 ? "pass!" : "fail" みたいにして使うと, それぞれの値がかえってくる.コードゴルフでよくifの代わりに使われるイメージ. 確認してみたら処理はスキップみたい.
以下のような挙動をする.A?:B:Cと表記したとき意外と面倒なのだな...a??bで, aがnullではなければa, nullならbを返す.
rubyとかでいう, ||=を思い出す長くなるので次回に回します. 論理演算子からです.


