More than 1 year has passed since last update.デスクトップアプリを作る上で、Node.jsからC#コードの結果を取得することが目的です。
色々調べると、Edge.jsというライブラリが見つかり、使ってみました。
もちろんインラインコードなど書きたくなかったので、DLLを読み込む方式にしたのですが、私のやり方が悪いのかVisual Studioでのコードデバッグができず、途方に暮れていました。
また、Edge.jsの場合、C#コンパイラーがすでにnpmパッケージにBundleされているようで、.NET4.5に依存しているようでした。
Node.js -&gt; C#の呼び出し部分のオーバーヘッドが少ないようですが、私の目的としては、C#で作ったデータをもらって、Node.js（実際は、ElectronやCarlo）で扱う程度のものだったので、C#で作った関数を、秒間何千何万と呼び出したいわけではなかったのです。
そこでIPC通信を使うことにしました。まず、Clientサイド（Node.js）ですが、node-ipcを使わせて頂きました。
node-ipcのIPCソケットには、いくつかタイプがあります。結論からいうと、1.を採用しました。
なぜかというと、ネットワーク上の別のPCのプロセスと通信したいわけでもなく、localhost上のポートを使ってまで動かしたくはなかった為です。
また、C#から送られてくるデータは欠損が許されない為、UDPは使えないだろうと。
その中で、最も高速と思われる1.を採用した次第です。
node-ipcが提供しているExampleがあります。
その中から、基本的なクライアントコードを参考にさせていただきました。サーバーに対して、"ping"を送信しています。
この部分を見ると書いてありますが、windowsの場合は、NamedPipeのpipe名に変換されます。
上記コードの場合、connectToの第2引数に文字列で指定した場合のPathパラメータが省略されています。
そのため、Unix Domain Socketのパスだと、/tmp/app.worldになり、
名前付きパイプの場合、\\.\pipe\tmp-app.worldに変換されます。
C#でNamedPipeServerStreamを生成する際は、tmp-app.worldとなります。それを踏まえ、サーバーサイドのコードを書きます。
C#側のコードはこんな感じにしてみました。
※ ちなみに今回は、サーバーもクライアントも同一PCである為、名前付きパイプに伴うimpersonationのようなセキュリティ対策は考慮していません。まずは、サーバーを作成し、接続時に送られてくる"ping"という文字列を取得します。
node-ipcのDefaultのメッセージ終端である\fが来るまでループし、メッセージを取得します。
メッセージは、JSONになっているので、適宜Json.NETを用いて、パースしましょう。
対して、"pong"メッセージを送り返す際は、下記の構造のデータをJSON文字列にシリアライズし送信する必要があります。
typeは、node-ipcにおける、メッセージIDに当たります。
dataは、もちろんオブジェクトでもよく、JSONであれば何でもいいです。稚拙なMyサンプルゆえに、サーバーが１回のメッセージ送受信しかしてくれない為、接続後リトライエラーが多発しますが、通信は可能です。
是非お試しを。


