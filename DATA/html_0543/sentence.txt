以下が気になり、色々ソースコードを追ってみた結果の副産物になります。
https://qiita.com/hiki_neet_p/items/e04b5ac692aa18df0968ここで、何もしていないのにMainWindowがDIコンテナに登録されているのがポイントです。
同じアセンブリ（プロジェクト）内のViewとViewModelが自動的に登録されるのです。
Prismの便利さの本質はここに集約されるのではないでしょうか。実際にどのようなロジックになっているかは、以下のUTを実行してみるとわかります。
https://github.com/PrismLibrary/Prism/blob/master/tests/Wpf/Prism.Wpf.Tests/Modularity/AssemblyResolverFixture.Desktop.cs#L71本記事では、上記の実装を単純化したサンプルコードで紹介します。
※ 以下の通り、C#では元々Assemblyの読み込みは遅延で行われるため、自分で実装する必要はありません。ただし、フレームワークとして凝った実装をしたい場合には必要なテクニックなのだと思われます。
https://docs.microsoft.com/ja-jp/cpp/build/reference/linker-support-for-delay-loaded-dlls?view=vs-2019以下、サンプルコードです。指定したパス以下のAssemblyInfoを収集し、Type.CreateInstanceします。失敗すると、イベントハンドラでAssemblyInfoで名前が一致するものを探し、実際にAssemblyを読み込みます。
Prismの本体コードをサンプルとして取り出しただけですので、本体コードを参照したい場合はこちらを参照ください。以下は上記で読み込むダミーのクラスです。オープンソースであるPrismフレームワークから、Assemblyの遅延ローディングについて学ぶことができました。
活用どころがあるかはわかりませんが、こういったテクニックを利用することでフレームワークの下支えになっていると学べました。
引き続き、当初の不明点を解消できるように学習を進めたいと思います。


