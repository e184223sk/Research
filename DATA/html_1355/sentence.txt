More than 1 year has passed since last update.つい最近正式版がリリースされた、Blazor WebAssemblyですが、
そのBlazorのコンポーネント向けのテストフレームワークのbUnitを試した際のメモです。bUnit公式
サンプルコード※今回はBlazor WebAssemblyを使用しています。
(Server-sideは未検証ですが恐らく動くと思います。)Visual Studioもしくはdotnetコマンドから、Blazor WebAssemblyの新規プロジェクトを作成してください。下記のコマンドでテンプレートをインストールします。
バージョンは2020/5/22時点で1.0.0-beta-7ですが、下記を参照して適宜最新バージョン等をインストールしてください。
https://www.nuget.org/packages/bunit.template/なお、上記のテンプレートを使用せずに、既存のNUnitやMSTest用のプロジェクトにも導入可能なようです。
詳細は公式ＨＰの下記を参照ください。
https://bunit.egilhansen.com/docs/create-test-project.html?tabs=xunit#create-a-test-project-with-bunit-template現時点ではVisual StudioからＧＵＩでプロジェクトテンプレートとして選択ができないようなので、
最初に作成したBlazorのプロジェクトにカレントディレクトリを移動して、下記のコマンドを実行します。テストＰＪ名は任意ですが、よく見かけるUnitTestの例ですと、
&lt;テスト対象のＰＪ名.Test&gt;
とする事が多いかと思います。BlazorのプロジェクトをVisual Studioから立ち上げて、
ソリューションエクスプローラから　追加　→　既存のプロジェクト　で作成したテストＰＪを追加します。
追加すれば、下記のようにBlazorのＰＪとUnitTest用のＰＪが表示されているはずです。追加したテストＰＪ側の依存関係にプロジェクトの参照追加で、テスト対象となるBlazorのプロジェクトを追加します。テンプレートで作成したテストＰＪには、単体でも動くようにテスト用のコンポーネントが同じＰＪ内に含まれています。（Counter.razor）
同じコンポーネントがBlazorアプリ側の初期状態にも含まれていますので、そちらを参照するように変更します。
※下記の操作はすべて、テストＰＪ側の操作です。まずは、この状態でテストが動くか確認してみましょう。
ツールバーから　テスト　→　全てのテストを実行　を選択します。
下記のようにテストが実行されてパスすれば成功です。以上で、セットアップは完了です。
次からはテストの内容を確認していきます。bUnitのテンプレートではCounterコンポーネントのテストがサンプルとして実装されています。
Counterコンポーネントは下記のような、ボタンを押下すると数値がインクリメントされる機能が実装されているコンポーネントです。早速ですが、テストコードを見ていきます。見ればすぐわかる内容ですが、RenderComponentメソッドで対象のコンポーネントを描画し、
その後、ＵＩを操作や表示内容の確認を実施しています。
サンプルでは下記の２パターンのテストが実装されています。2.にテストケースを追加してみます。
再度ボタンを押下した場合に、カウンタの数が2になっていることを確認することとします。その後、テストを再度実行してパスする事を確認しましょう。先ほどはC#コードベースのテストを確認しましたが、次はrazorコードベースのテスト手法を確認します。
(CounterRazorTest.razor)
このファイルには２種類のテストが実装されいるので順に説明します。SnapshotTestタグで囲まれた要素が１つのテストケースになります。
TestInputタグ内に、テスト対象のコンポーネントを定義し、ExpectedOutputタグ内に実際に出力されるhtmlタグを記載してアサーションするといった形になります。
Setup,SetupAsyncでラムダ呼び出し可能なようなので、でDIのモックも可能なようですが、ボタン操作などはできなさそうに見えるのでどちらかというと、コンポーネントに渡すパラメータを色々と変えた場合のテスト用途として使えそうです。こちらは最初に紹介したC#コードベースのテストとスナップショットテストを合わせたようなテストです。
Fixtureタグが１つのテストケースとなり、ComponentUnderTestにテスト対象のタグを定義し、
Fragmentに期待されるHTMLの部分要素を定義します。C#コードとしてはTest属性でメソッドを紐づけることでrazorタグ内の要素を操作することができます。
やっていること自体は,C#コードのサンプルと同様にボタンを１度クリック後にpタグの文言がインクリメントされているかをチェックしているだけです。Fragmentタグにはidを付与することで何個も定義してケースごとに使い分けることができます。
下記は２つのFragmentを定義して、ボタンを１度押したケースとその後、再度押したケースで結果がインクリメントされていることを検証しています。ちなみに敢えてテストケースを失敗させた場合には、下図のように表示されます。
実際の値と期待値のタグが表示されるのでわかりやすいかと思います。これまではCounterコンポーネントのテストケースを確認しましたが、次はより実践的なAPI等によるデータ取得が絡むコンポーネントのケースを考えてみます。初期状態で作成されているFetch dataの天気読み込み部分を書き換えたうえでテストケースを追加してみます。元のコードはコンポーネント内でHTTPクライアントを使ってサーバ側に設置されたjosnを読み込む形となっていますが、
下記のようなインターフェス及びダミーデータを返す形にサービス化します。作成したサービスをDIできるように登録します。コンポーネント内でサービスを呼び出してデータを取得するように変更します。以上で実装は終了です。
実際に動かしてデータ取得ができていることを確認しましょう。次に実装した機能に対するテストを作成していきます。テスト時には実際にＡＰＩ等にアクセスせずに、任意の応答が取得できるように下記のようなモッククラスを作成します。
これを使用することで、各テストケースで任意のテストデータを設定ができます。モックを使用して、取得データが０件の場合と３件の場合のケースを実装します。
各テストケースでモックにデータを準備して設定しています。データの取得処理は非同期になるので、取得が完了するまで待機しないと、結果をアサーションできません。
そのための仕組みとして、WaitForStateメソッドが用意されています。
下記の例では、データの取得が完了してtableタグが描画されてるまで待っています。テストを流してパスする事を確認します。
簡単なサンプルパターンだけにはなりますが、Blazorのコンポーネント向けテストフレームワークのbUnitの紹介をしました。
紹介したもの以外にもJS側のモック化や様々なアサーション機能など、色々と機能が提供されいますので、
興味のある方は公式ページを参照してみください。bUnit自体はまだbetaということで、破壊的な変更が加わる可能性等がありますが、従来のC#ロジックとは別にGUIに近いrazorコンポーネントのテスト自動化が可能なことが確認できました。
HTMLの出力内容が隠蔽されるようなUIライブラリを使う場合には使いづらいですが、自分で制御できる場合には、有用かもしれません。


