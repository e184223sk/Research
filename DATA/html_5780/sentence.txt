More than 3 years have passed since last update.ワールド自体がランダム生成される無限に移動できるオープンワールド風のサンドボックスゲーム遊びたい・・・遊びたくない？
ということで、まずはフィールドを作成中です。概要設計は プレイヤーキャラの移動にあわせたリアルタイムTerrain生成破棄 で行っているので、
未読であれば先にそちらをご確認ください。ただし、本記事では上記の記事と矛盾した記述がある可能性があります。本記事のほうが後から再検証したものなので、その場合は本記事の記述を優先してもらえればと思います。Terrainを操作する必要があるのは大きく以下の2箇所だけです。・初期生成
　　初期生成の範囲を生成
    生成したTerrainを保持管理するための入れ物を生成
　　初期生成の範囲のTerrainを生成
　　Terrain生成とは主に、ハイトマップを作成して割当、SetNeighborsで周辺のTerrainと接続、テクスチャ貼り付け、の3つを指す・プレイヤー移動時のアップデート
　　基本的には生成済みのTerrainの有効/無効の切り替えだけにしたい
　　でも初期生成の範囲外は新しく生成したいチャンク - この記事ではTerrain1つ分のことを1チャンクとして扱います。
チャンクサイズ - Terrainの一辺の長さをチャンクサイズと読んでいます。Terrainは正方形のものとして扱っています。そこまで大層な規模のものでもないので、今のところ切り分ける必要を感じず、登場するクラスの全部をsgffu.Terrainに置いてあります。sgffuは自作の Sandbox game foundation for Unity の略称で、今回のTerrain周りの処理はそのうちの機能の1つとして作成しています。例によってコードはGitHubにあります。https://github.com/mkgask/sgffu/tree/master/Assets/Scripts/Terrain前回記事に貼ったツイッターの動画のように、前の段階で動くものとしては一応出来ていましたが、手を加え直してもう一回動くところまで持ってこれたので、一旦ここまでで何を作ったのか書いていきます。登場するクラス一覧こちらこういうコードって処理の下流から見せるか上流から見せるか迷いますね。
個人的には大まかに分かっていれば下流からのほうが理解しやすいので、今回は下流からです。途中で飽きたら途中から雑になるかもしれないので先に謝っておきます。申し訳ありません。あ、あとコードはUnity5.6で動くようにC#4.0相当です。コードを書ききった後に後付けで書いたクラス図です。
このクラス図を見ることによって、気分の悪さ、嫌悪感、吐き気や怒り、憤りを感じるなどの症状が起きても私は責任を持てません。赤矢印が依存、白矢印はis-aなどクラス図のルールがあるようですが、
見た目の問題で白矢印にしただけなので実際にはだいたい全部依存です。Terrainを生成するための情報を保持するデータクラス主にハイトマップをファイルにキャッシュしておくためのクラスです。
Terrain位置からTerrainEntityを生成する時には使わず、生成したTerrainEntityをJSONファイルとして保存する時に、このクラスにアップキャストして、このクラスにある情報だけを保存するようになっています。
あと保存したJSONからTerrainEntityに再展開する際も、一旦このクラスを経由します。Terrainを保持するGameObject1つを外部から管理TerrainEntityは宣言通り、Terrain1つ分の管理を行ってもらっています。
今のところTerrainに期待することは、の5つで、このうちハイトマップ生成だけは、TerrainEntityやTerrain、GameObjectの生成の前に作成処理をしておきたいところで、Terrain1つに収まらないワールド座標を利用するものなので、TerrainServiceのほうで行っています。
なので残りの4つをTerrainEntityにメソッドとして実装しています。TerrainEntityの配列を保持前回記事では「実装のポイント 4 Terrain管理」の通り、TerrainEntityを二次元配列[,]で保持していたのですが、
配列のキーはマイナス値を持てないので、0,0を中心としたTerrain位置と整合性がとれず、
オフセットを入れたところを世界の中心とすると、オフセット値が世界の限界値になってしまい、
世界の果てをどうしても作りたくない今回の仕様とは非常に相性が悪いので、
Dictionary&gt;で保持するように変更しました。pos_xとpos_zを持っているので、Listで、FirstOrDefaultあたりで引っ掛ければ拾えるなーとかも考えたんですが、Listの内部実装を見る限り普通に総当りで検索かけてるように見受けられたので、それならDictionaryでハッシュで拾ってもらったほうがおそらく速いだろう、となりました。（実測は出来てません）Terrain生成用のパラメータを保持これもただのデータクラスです。
JSON保存・読み込み用で、JSONを書き換えればこのクラスとして読み出されて、Terrainの生成に影響を与えることが出来るようになっています。TerrainEntityの生成を担当このクラスの外で生成されたパラメータを与えることで、TerrainEntityインスタンスの生成、そこに持たせるTerrainコンポーネントの生成、それをアタッチするGameObjectの生成まで行ってもらっています。
GameObject parentにはTerrainControllerをアタッチしたGameObjectが入ってくるので、各TerrainはそのGameObjectの子として生成されていきます。C#の仕様上、ダウンキャストに一部制限があるので、TerrainEntityCoreからTerrainEntityにキャストじゃなくて生成するようcreateFromCoreメソッドを持っています。TerrainCollectionの生成を担当いよいよ書くことが無くなってきたような・・・
というかこのcreateメソッド、今見返すとTerrain初期生成用のパラメータをアレコレ作ってるんですが、ここでやる必要が・・・？あるんだろうか・・・？
TerrainConfigに持たせておいたほうがよほど健全なようなというかTerrainCollectionの中身詰める直前に作ればいいだけで変数に取っておく必要は・・・？とりあえずは動いているので、あとで気が向いたら直していきましょう。（こういうのばっかり）TerrainConfigをファイルに保存、ファイルから再生成を行うTerrainConfigのいわゆる永続化を担当する予定です。
今のところ初期生成後はJSONからの値の読み出ししかしないので、編集した値をJSONに再保存する機能がまだありません。
JSONの値を書き換えれば反映されるので、だいぶ後回しになりそうです。前回記事で「実装のポイント 3 Terrainのサイズと位置」で書いていた、TerrainData.sizeに指定した値と実際のTerrain一辺の長さがズレている件について、このクラスでcalcurate_actual_chunk_sizeメソッドを使って調整後の値を生成しています。TerrainEntityをファイルに保存、ファイルから再生成を行うsetにTerrainEntityを渡してJSONに保存、getJSONからTerrainEntityを再生成してくれる予定です。（まだちゃんと動いてない）
TerrainEntityCoreのところでも少し触れましたが、TerrainEntityを直接保存や読み出しせず、間にTerrainEntityCoreを挟んでいます。JSONのファイル入出力にはUtf8Jsonを利用させていただいていますが、このライブラリはネットワーク通信用な気がして仕方がないので、のちのち別のものも検討する必要がありそうです。beautifier欲しい。（2017/12/09追記）
Utf8Jsonには、JsonSerializer.PrettyPrintというBeautifierがあるとコメントでご指摘とコード例をいただきました。ありがとうございました。Terrain機能をサービスとしてゲームに提供する窓口やだ、このクラスデカ過ぎ・・・？
今更見返してみると、ゲームとサービスのインターフェースになる窓口クラスのわりにビジネスロジックばっかり書いてあるように見えます。
Terrain機能内部クラスへの命令出しとそのための準備をしているだけのはずなんですが。
もう一枚、間に立つレイヤーとしてのクラスを作って挟んだほうがすっきり綺麗なコードに見えるかもしれませんね。SetNeighborsでのTerrain接続は、接続先のTerrainが存在していないと接続出来ないので、Terrainの生成だけを先に行っておいて、後から生成済みのTerrainに対してSetNeighborsしていく処理になっています。
が。
確か接続する両方のTerrainからSetNeighborsしないといけないみたいな記述をどこかで見かけた気がするのですが、今の処理では、一旦生成と接続を行った後に、その外側に生成したTerrainに対して内側から再接続をかける処理が無く、外側のTerrainを生成した際に内側のTerrainに片側からSetNeighborsするだけしか出来ていません。
一定範囲のTerrainを生成後に、その外周を回ってTerrainが存在するならSetNeighborsし直す、みたいな処理が必要なのかもしれません。Terrain生成処理のエントリポイントこのTerrainFactory.create()をゲーム初期化時に呼び出すことでTerrain処理を開始し、初期生成とプレイヤー移動時のTerrainアップデートの待ち受けを行います。後述と書いたメソッドが2つほどあるので、そちらを紹介します。なんかここだけsummary書いてありました。
あと別の名前空間切ってあったのでそこも入れてあります。
ファイルパスからTexture2D作るのはInstantiateでは出来ないのでメソッドを捏造しました。入力してもらったワールド名からランダムなシード値を生成するのにxorshiftを使っています。
それとMathf.PerlinNoiseに渡すための引数を作るcalucurate_perlin_valueメソッド。
calucurate_perlin_valueはterrain_seedを渡せるようにしてあるのですが、Mathf.PerlinNoiseは0～10までの値であれば処理してくれるので、xorshiftで作ったシード値を更に加工してから渡します。
加工処理が何故かWorld機能側に置いてあるのもこれは改善項目としてカウントしたほうがいいのでしょうか。seedにはxorshiftで作ってもらった確か7～8桁くらいの整数が入っていて、小数点位置を移動して1以下の値にし、calucurate_perlin_valueでは単純な足し算しかしていないので上限である10からは遠い方の値がTerrain用のシード値になるようにしてあります。
微調整入れずにゼロ付近が中心でいいのではという案もあったんですが、プレイヤーキャラの出現位置を0, 0にしてあるので、そこを挟んでプラスマイナスが逆転するだけだと、おそらく、前と後ろ、左と右で同じ地形が見えてしまうのではと考えてこういう処理を入れたような覚えがあります。
あと数学力の無さ。他にも、Terrainはバイオームと密接に紐付いていて欲しいので、将来的にバイオームの情報を使って地形生成や装飾オブジェクトの有無なんかを切り替えていきたいところです。


