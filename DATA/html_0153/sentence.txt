UniTask にはあらゆるものを UniTask に変換する .ToUniTaskというメソッドがあります
同じものを変換するときでもオーバーロードがあったりでややこしいので備忘録としてまとめてみました
GetAwaiter や WithCancellation なども書いておきます(実装を書くのは省きます)UniTask/Github以下の環境で動作していますこんな感じで変数tokenは何かしらのCancellationTokenが、
変数uniTaskには何かしらのUniTaskが入っていると考えてくださいCancellationToken を UniTask に変換できますCancellationToken がキャンセル状態になるまで await される UniTask が返ってきます
返り値は (UniTask, CancellationTokenRegistration) というタプルですUniTask型ではありませんが、awaitableなCancellationTokenの型が返ってきますUniTask を CancellationToken に変換できますUniTask では StartCoroutine を使わずにコルーチンを起動することができます
ただし、UniTaskはコルーチンの yield return new WaitForEndOfFrame()を再現できないので注意が必要です。下記は MonoBehaviour を引数に渡すことで内部でStartCoroutineが走ります。なので yield return new WaitForEndOfFrame()も正常動作しますし、寿命もゲームオブジェクトと結びついてくれます。UniTask を IEnumerator に変換できますエラーハンドリングや結果を得るためのデリゲートを渡せるオーバーロードが用意されてますAsyncOperation を UniTask に変換できますUniTask には 様々な AsyncOperation が awaitable になっています。シグネチャは拡張メソッドのthisキーワードが付いた引数の型の違いしかなく、使い方は全部一緒なので省きます。SceneManager.LoadSceneAsync の例です。
.ToUniTaskに Progress を入れて進行状況を取ることができます。UniTask に用意されている AsyncLazy型です。ToUniTask ではなく .Taskプロパティ から取得できますUniTask から AsyncLazy に変換できますIObservable を UniTask に変換できます。第一引数をtrueにすると、次に発行される最初のメッセージだけを待機できます。UniTask を IObservable に変換できます。ジョブの実行が終了するまで待機できます実装を見ればどれも違うのがわかりますが、自分はJobHandleに詳しくないので有識者の方、コメントや編集リクエストをお願いします！AsyncGPUReadbackRequest を UniTask に変換できます。UniTask を AsyncGPUReadbackRequest に変換できます文章書くの下手すぎて読みにくいかもです。すいません。
間違いがあったら優しく教えてください。IEnumerator.ToUniTask()は何も指定しないと「コルーチンっぽく動く」だけなので yield return new WaitForEndOfFrame(); は正しく動かない。IEnumerator.ToUniTask(MonoBehaviour)は内部でStartCoroutineするから本物のコルーチンが起動するのでちゃんと動作する。とりすーぷさんからご指摘をいただきコルーチンの項目を少し書き換えました！ありがとうございます！


