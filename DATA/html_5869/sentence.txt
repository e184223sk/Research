More than 3 years have passed since last update.Niigata.NET 3.0に参加して、forと比較して、foreachをブラックボックスに感じたので、少し整理します。
Niigata.NET 3.0に参加してきました手始めに、言語仕様は以下の通り。8.8.4 foreach ステートメント
foreach ステートメントはコレクションの要素を列挙し、コレクションの要素ごとに埋め込みステートメントを実行します。foreach ステートメントの type および identifier で、ステートメントの "反復変数" を宣言します。local-variable-type として var 識別子が指定されている場合、スコープ内に var という名前の型がないと、反復変数は "暗黙的に型指定された反復変数" となり、その型は次に示すように foreach ステートメントの要素型となります。反復変数は、読み取り専用のローカル変数に対応し、スコープはその埋め込みステートメント全体です。foreach ステートメントの実行中は、反復変数は、現在実行中の反復のコレクション要素を表します。埋め込みステートメントが、代入または ++ 演算子と    演算子で反復変数を変更しようとしたり、反復変数を ref パラメーターまたは out パラメーターとして渡そうとしたりすると、コンパイル エラーが発生します。
以下では、説明を簡単にするために、IEnumerable、IEnumerator、IEnumerable、および IEnumerator は、System.Collections および System.Collections.Generic 名前空間のそれぞれに対応する型を参照します。
foreach ステートメントのコンパイル時の処理では、最初に式の "コレクション型"、"列挙子型"、および "要素型" が決定されます。この決定は次のように処理されます。上記の手順が成功すると、コレクション型 C、列挙子型 E、要素型 T が明確に生成されます。foreach ステートメントは次の形式になります。これは次のように展開されます。変数 e は、式 x、埋め込みステートメント、またはプログラムのその他のソース コードからは、参照もアクセスもできません。変数 v は、埋め込みステートメントでは読み取り専用です。T (要素型) から V (foreach ステートメントの local-variable-type) への明示的な変換 (6.2 を参照) がない場合は、エラーが発生し、以降の手順は行われません。x が null 値を持つ場合、実行時に System.NullReferenceException がスローされます。
実装では、動作に上記の展開との整合性がある限り、パフォーマンス上の理由などから、異なる方法で foreach ステートメントを実装してもかまいません。
while ループ内への v の配置は、embedded-statement 内の匿名関数でどのようにキャプチャされるかに大きく影響します。
次に例を示します。v が while ループの外側で宣言された場合、すべてのイテレーションで共有され、for ループの後の値が最終値 13 になります。これが f の呼び出しによって出力される値です。代わりに、各イテレーションには独自の変数 v があるため、最初のイテレーションで f によってキャプチャされた v は引き続き値 7 を保持し、この値が出力されます (メモ: 旧バージョンの C# では while ループの外側で v を宣言しました)。
finally ブロックの本体は、次の手順に従って構築されます。E から System.IDisposable インターフェイスへの暗黙的な変換がある場合、次の処理が実行されます。ただし、E が値型または値型にインスタンス化される型パラメーターである場合は、e を System.IDisposable にキャストしてもボックス化は発生しません。それ以外の場合、E がシール型であれば、finally 句は空のブロックに展開されます。ローカル変数 d は、ユーザー コードから参照もアクセスもできません。特に、finally ブロックをスコープに含んでいる他の変数と衝突することはありません。
foreach が配列の要素を走査する順序は、次のように定義されます。1 次元配列の場合、要素はインデックス 0 から始まってインデックス Length – 1 で終わるインデックスの昇順に走査されます。多次元配列の場合、要素は、最初に右端の次元のインデックスが増加し、次にその左側の次元のインデックスが増加し、さらにその左側の次元のインデックスが増加する、という順序で走査されます。
2 次元配列のそれぞれの値を要素順にプリント アウトするコード例を次に示します。生成される出力は次のとおりです。
1.2 2.3 3.4 4.5 5.6 6.7 7.8 8.9
次に例を示します。n の型は、numbers の要素型である int と推論されます。C# 言語仕様 Version 5.0より引用
おそらく最新は、https://github.com/dotnet/csharplang/blob/master/spec/statements.md#the-foreach-statement
色々書いてありますね。


