More than 3 years have passed since last update.Task、async/awaitの話をする際、非同期とスレッドを切り分けて説明した方がスッキリします。ここでは非同期に絞って紹介します。unity 2018.1以降、C＃6が正式にサポートされるようです。Updated scripting runtime in Unity 2018.1: What does the future hold? – Unity Blog業務ではUnity2017を使用していますが、一足先にasync/awaitを使っています。unity2017で async/awaitを使うには PlayerSettings &gt; Scripting Runtime Version を .NET 4.6 Equivalent にする必要があります。ゲーム制作でありそうな例です。これらを上から順に実行します。async/awaitもCoroutineも使わない場合、callbackを使う事になります。下記のようにネストが深くなりがちです。
ネストを嫌ってメソッドを分割すると、今度は実行順と記述順がバラバラになり、順番の把握が難しくなります。callbackが大量に連鎖する場合、callback地獄と呼ばれるような事になり、非常に読みづらくメンテしにくいコードになってしまいます。このように記述できます。記述した順に実行されるため、非常に読みやすいものになります。
コールバック関数もなく、ネストも必要ありません。同期風に書くのはCoroutineでも可能です。Coroutineにも色々な使い方があると思いますが、ここで扱うのは同期風に書く用途でのCoroutineの話です。しかしCoroutineには下記のような欠点があります。値を返すのが面倒ry-catch内にyieldを入れることはできないので、例外を処理することが出来ない例外が発生した場合、スタックトレースは例外がスローされたCoroutineを通知するだけ何もしなくても、yield returnしたら 1フレーム待つasync/awaitは上記をカバーできます。Unity3dAsyncAwaitUtilというユーティリティが公開されています。https://github.com/svermeulen/Unity3dAsyncAwaitUtil例えばここ。yield return する箇所を、そのまま awaitで置き換え可能です。
これにより、過去に作成したメソッドをそのまま活用でき、置き換えが容易になります。拡張メソッドを使い、既存クラスも簡単にawaitに対応させる事が可能です。非同期メソッドの内部実装 - C# によるプログラミング入門 | ++C++; // 未確認飛行 C 下記拡張メソッドを用意します。これによりと記述できるようになります。(実際はTweenerとSequence同時に使うとコンパイラのwarningが出てしまうため、もうちょっと工夫する必要があります。)Taskを返しているのに awaitしていない場合、処理中に例外が起きてもunity editorのlogに出力されません。awaitしない場合、awaitするか、戻り値を async void にする必要があります。これはコンパイラがwarningで指摘してくれます。これは良し悪しありますが、Coroutineと同じように止めたい場合は面倒です。C# Riderを使用していますが、問題なくブレークポイントを張りデバッグ出来ています。他にはチュートリアルなど、順に実行されるものなどが楽に記述できそうな予感がします。下記blog記事を非常に参考にしています。この記事の半分は下記blogの紹介です。How to use Async-Await instead of coroutines in Unity3d 2017 | Steve Vermeulen[雑記] 非同期制御フロー - C# によるプログラミング入門 | ++C++; // 未確認飛行 C非同期メソッド - C# によるプログラミング入門 | ++C++; // 未確認飛行 Casync/await と SynchronizationContext (2) - 鷲ノ巣


