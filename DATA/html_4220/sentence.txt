More than 1 year has passed since last update.今さらながらQiitaに登録したので、お試し投稿。
こんなので良いのだろうか・・・？C#にてバックグラウンドで動作する常駐アプリケーションを開発する際に、Program.csのMainメソッド内にDoEventsとSleepでメインループさせるコードをよく目にするけど、もう少し綺麗に書きたい。
もっと言えば、Program.csの中身は・・・この形を維持して、メッセージループは標準のものを利用したい。
環境：Visual Studio 2017 / .Net 4.6 / C# 7.3Application.RunメソッドにFormクラス以外で渡せるApplicationContextクラスを使って、便利なクラスを作ってみた。
FormlessApplicationクラス: 実際に行う処理を実装する基底クラス
FormlessApplicationContextクラス: FormlessApplicationクラスを制御するクラスFormlessApplicationクラスを継承して、必要な処理を書くだけ。Program.csの中身はシンプルにApplication.Runの引数を変えるだけ。これなら標準の処理を極力活かしつつループ処理ができる。FormlessApplicationクラスのコンストラクタで初期化処理を行うと、エラーなどで終了したいときに困るので、初期化関数を別で用意した。（上手くやればコンストラクタで初期化する形でもいける気がする）
またコンストラクタ内でExitThread()を呼んでも終了できないようなので、Idleイベントで呼ばれるように工夫。ループ処理中にダイアログをShowDialogすると、更にIdleイベントが呼ばれてダイアログが無限に表示される現象が発生。
モーダル状態に入ったときはIdleイベントを一時的に解除することで回避。溜まったメッセージを処理し終わったときにIdleイベントが「１度だけ」発生する。逆に言うとメッセージが溜まって処理されないとIdleイベントが発生しない。それを利用して、起動時のメッセージ処理後のIdleイベントでループ処理を行い、メッセージが来たら処理を返してあげて、そのメッセージ処理後のIdleイベントで再びループ処理を行い、メッセージが来たら・・・ｒｙ（無限ループ）
メッセージが溜まってるかどうかを判断するためにWinAPIのPeekMessage関数を使用。（メッセージの処理自体は標準の処理にお任せ）メインループほどの頻度が必要なければ、TimerとNotifyIconを利用するようなComponentクラスを作って、ApplicationContextクラスから使えば、WinAPIやIdleイベントを使うことなく、お手軽に通知領域に表示する常駐アプリが作れたりもする。


