C#/WPFでライフゲームを作る第2弾。
前回（ライフゲームを作ってみるver1）では、
WPFで作っておきながら、全ての実装をxaml.csに詰め込むという暴挙に出たため
全く持ってWPFである意味はありませんでした。折角なので勉強中のMVVMパターンで組みたいし拡張性を持たせたいと思うので
改めて設計しなおして書き直しました。まずは構成。View→ViewModel→Modelの依存関係を前提として、
今回はライフゲームで世代更新→画面更新したいのでの２つが必要になります。ライフゲームの管理はModel側に任せるとして、
非同期で画面にアクセスすることは単純にはできないので
ライフゲーム用のコントロールであるDataGridを扱うクラスを仲介役として設けました。InteractionRequests名前空間内にいろいろとViewModel→Viewの方向で行いたい処理(クラス)を別個に定義しています。
これについては[WPF]MVVMパターンでViewModelからViewへのリクエストを参照してください。
なお、ソースコード全部載せると長いので全容はGithubに置いておきます。
https://github.com/MtBigYashi/LifeGameViewでは、イベントを掴まえていい感じに処理したいのでNuGetでWPF.Interactivityをインストールしています。
xamlは以下の通り。今回、ViewModel側とバインディングしているのは4つのButtonそれぞれのコマンドに加え
1つのDataGridのItemsSourceおよびMouseUpイベントをコマンドに繋げています。
名前はサンプルで作った時のままなので適当です。ライフゲームの世代更新、DataGridのセルをクリック、Randomボタンによる初期化などされた時、
画面を更新するために以下のDataGrid操作クラスを作成しています。コードの内容はver1の頃からほぼ変わっていませんが、非同期で画面にアクセスするためのディスパッチャを定義しています。
TriggerActionsに関しては冗長になるので割愛。ViewModel側のPropertyChangedイベントを受けてから、
このDataGridAccessorを経由して画面を更新していきます。MainViewModelは画面とライフゲーム管理の仲介役としての働きを持たせます。先ほどの構成図では省略しましたが、ViewModelの基底クラスとしてViewModelBaseクラスを定義し、
InteractionRequests名前空間内のクラス型プロパティを定義しています。こちらも省略します。Modelはライフゲーム管理クラスのみですだいぶいい感じになってきました。ただDictionaryのコピーが無駄が多い感じがして改善したいですね。
今はDictionaryにしてますが、ILookupにすると早いんでしょうかね？あと、次元数やランダム初期化時の密度(Density)、過疎・過密の条件変更など
画面から動的に変更できるようにアップデートできるといろいろと実験しやすくて面白そうですね。それは次回のver3で実施しましょう。今回はここまでです。


