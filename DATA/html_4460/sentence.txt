More than 1 year has passed since last update.この記事のエンティティクラスとは、Entity Framework Coreにおいてデータベースにマッピングされるクラスのことを指します。Entity Framework Core 2.1からエンティティクラスのプロパティを読み取り専用にできるようになりました。
これまで、Entity Framework Coreでエンティティクラスを定義する場合、以下のように書き込みもpublicなプロパティが必要でした。Entity Framework Core 2.1からは以下のようにセッターをprivateにできるようになりました。インスタンスを外部から書き換えられないので、初期化はプロパティ初期化子1でなくコンストラクターで明示的に行います。
プロパティが書き込み専用ならインスタンスの状態が不変になり、内部のデータを外部からの意図せぬ変更から守ることができます。※ C# 6 から、コンストラクターでのみ値を代入可能なgetアクセサーだけのプロパティを定義できましたが、Entity Framework Coreではprivate setがないとマッピングが行われません。
※ ただし、OnModelCreatingのフックで明示的にマッピングするとprivate setも不要になります。後半に書きます。サンプルプロジェクトを作成しプロパティが読み取り専用なエンティティクラスを使用した CRUD 処理の説明したいと思います。最終的なソースは以下のリポジトリにおきました。
https://github.com/sano-suguru/readonly-model-propsエンティティクラスは 「はじめに」 と同じ書籍エンティティを使用します。
クラス外部からはプロパティが読み取り専用になっています。データベースはマイグレーションを省略するためインメモリデータベースを使います。
今回は最初からシードデータを持たせておきます。プロパティが読み取り専用の場合、インスタンスに対しbook.Title = "FooBar"のように書き換えることができません。
そのため、通常のEntity Framework Coreの CRUD 処理と勝手が変わってくる部分があります。プロパティが読み取り専用でも特別な処理はありません。データベースのデータがすべて抽出されました。上記ではIQueryable&lt;Book&gt;に対しAsNoTracking付いています。
通常、インスタンスは Entity Framework Coreによって追跡され、エンティティ内で検出された変更はすべてSaveChangesメソッドを呼んだときデータベースに保存されます。
AsNoTrackingによって追跡されない場合、変更追跡の情報を設定する必要がないのでクエリが高速化されます。プロパティ初期化子が使えないので、Bookインスタンスの初期値はコンストラクタに渡されます。データベースに書籍が追加されているのが確認できます。データベースから抽出した更新対象のインスタンスを直接書き換えることができないため、少し特殊です。
新規にBookのインスタンスを作成し、その際に更新するプロパティ以外を更新対象のプロパティで初期化します。
作成したインスタンスで更新をかけますが、Entity Framework CoreではIdは自動で主キーになっているため、一致するIdのデータを更新されます。対象（Id == 3が）のデータが更新されていることが確認できます。抽出クエリと同様、プロパティが読み取り専用でも特別な処理はありません。ID == 1のデータがデータベースから削除されているのが確認できます。public ~ { get; private set }の場合、クラス内部からはデータを書き換えることが可能でしたが、getのみの場合はコンストラクタでの初期化のみ可能です。
「はじめに」で触れたprivate setもなくgetアクセサのみプロパティを持つエンティティクラスを定義したいと思います。まず、エンティティクラスのプロパティからprivate setを除きます。このままではEntity Framework Coreでマッピングが行われないため、
データベースコンテキストのOnModelCreatingで明示的にプロパティのマッピングを定義します。これでエンティティクラスのプロパティをgetのみにすることができました。今回、エンティティクラスではコンストラクタの引数にIdを初期値として渡せるようにしました。
本来Entity Framework CoreではIdは自動でインクリメントされ採番されます。
自動で採番されるIDにはコンストラクタから値を渡す必要がありません。DbContext.OnModelCreatingではIDのマッピングの定義は不要です。
（エンティティクラス側でprivate setがあるため）IDが自動採番されているのを確認します。ただし、Idをコンストラクタから取り除いた場合、OnModelCreatingのフックでシードデータを設定することはできません。
modelBuilder.Entity&lt;TEntity&gt;().HasDataでシードデータ生成する際、IDは自動採番されないためです。ASP.NET Core MVCやWeb APIでは以下のようにProgram.csでシードデータを採番するコードを自分で書くとよいと思います。セッターもpublicならnew Book { Id = 1, Title = "Scala本", Author = "ゴンタロウ" }のように初期化できる。 ↩


