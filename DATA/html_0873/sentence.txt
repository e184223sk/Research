More than 1 year has passed since last update.WindowsAPIのソースコードは調べられなかったので、実験ベースでの検証になります。
コード例はC#です。「コードはよ」というかたは、最後の章へ。
マルチモニタでの挙動は未検証です。現在のマウスカーソル位置とは関係なくデスクトップ上の指定の座標にマウスカーソルを移動させたいとき、MOUSEEVENTF_ABSOLUTEを指定してSendInput(Windows API)を使ってマウスを制御します。
※移動させるだけなら Cursor.Position に座標を設定してもやれるようです。マウスボタン操作を合わせてやりたい場合はSendInputを使うことになるかと思います。巷（ちまた）には下記のような変換をしているコードがあふれていますが、これらを使うと、丸め誤差により、もともとの意図した座標(x, y)からずれます。
（例2や例3は、ズレは1ピクセルとかになると思うので通常は気にならないレベルですが、シーンによっては問題になり得ます。）NG例1については、C言語やC#等は/が整数除算になるので、係数(65535 / Screen.PrimaryScreen.Bounds.Width) を計算した時点で、モニタのWidth,Heightに依存した誤差をもってしまいます。1勘の良い方なら、NG例2を使うでしょう。もしくは、分子が(65536から)1引いているのだから、分母も同じく1を引いて、下記を使う方もいると思います。NG例2やNG例3をみて、「いやいや、Microsoftの公式サイトに書いてあるし、あってるでしょ？」と思う方もおられるかと思います。（自分もそう思ってました。）公式サイトの記載を抜粋します。If MOUSEEVENTF_ABSOLUTE value is specified,
 dx and dy contain normalized absolute coordinates between 0 and 65,535.
 The event procedure maps these coordinates onto the display surface.
 Coordinate (0,0) maps onto the upper-left corner of the display surface;
 coordinate (65535,65535) maps onto the lower-right corner.
 In a multimonitor system, the coordinates map to the primary monitor.これを見ると、あたかも(65535,65535)とプライマリモニタの(Width,Height)もしくは(Width-1,Height-1)が対応しているように見えます。ですが、実際にNG例2やNG例3のコードでやってみるとずれます。
ずれるケースの実験は本記事では省略しますが、この記事のコードを使えば確認できます。3章では、指定した座標に対しSendInput実行後のマウスカーソル座標がどこになるのかを調べます。
この章で、SendInputの世界の座標系(0,0)-(65535(?),65535(?))  から  ピクセル単位の座標系を取得する式を得ます。最終的に得たいのは、これと逆方向の変換です。それについては4章で扱います。実験により検証したところ、(0,0)-(65536,65536)とプライマリモニタの(0,0)-(Width,Height)が対応関係にあります。丸め方向は切り捨てです。
つまり、SendInput APIは、内部で Cursor.Position.X = (absX * Width) / 65536; に相当する計算（整数除算）をしているようです。AbsXが、SendInputに指定した x の値。
ResultXが、.NetのCursor.Positionプロパティで取得した実際のマウスカーソル座標です。（行挿入等の操作をしてしまったので数式のセル参照がメモとずれてます）高解像度による座標系変換の影響を受けると問題がややこしくなるので、SetProcessDPIAware (Windows API)で高解像度対応させています。3章で得られた関係性 Cursor.Position.X = (absX * Width) / 65536;の
逆計算をすることでマウスカーソルの座標系から0～65536の座標系に変換する。
というアプローチで行きます。整数除算の際の丸め処理2は、大雑把にいうと、小数点以下を切り捨てているのと同じなので、床関数と同じと考えることができます。床関数のグラフの描くとこんな感じになります。（白抜きの〇は、含まない。）
モニタのWidth, Heightが65536以下である仮定のもと、実際の例 Width = 1920 のときの逆計算のイメージをグラフで描くと下図のようになります。
カーソル位置x=1に動かしたい場合は、35～68の範囲に収まる値をSendInputのabsXに設定してやる必要があります。3
なので、グラフ上の各線分●ー○よりも内側を貫く直線で逆計算の式を構築する必要があります。（語彙力・・・）
ちょっと雑ですが、下図のイメージです。話がとびますが、直感に頼って式の案を出すと、天井関数を使ってabsX = ceiling((Cursor.Position.X * 65536) ÷ Width) として計算すればイケそう（4.2.章の内容を満たせそう）な気がします（超乱暴）。（ここでの÷は実数での除算を表しているとします。）
Excelで検算をしたところ、Width=1920, Height=1080の環境では誤差がでないようです。イメージこんな感じ。
4.3章の変換式をソースコード(C#)にすると、下記のようになります。
下記の「正確に変換できるであろうコード」は、最終的に4.3章にて直感で出しており、4.2章で言及した変換ができているかどうか数学的な証明もしていないので、参考扱いとしてください。注：  x または y が 30000くらいの大きな値をとりえるならば、long型にキャストすること。完全に自己満足の世界だが、証明しておかないと落ち着かないので、証明してみた。65536の代わりに一般化して $ N $ と置きます。モニタの幅Widthを $ W $ と置きます。 $ N \geq W $ と仮定します。と置きます。 $ x $ を カーソルのx座標とします。
このとき、4.3章で案として挙げた式は天井関数 $ \lceil x\rceil $ を使って下記と書けます。また、SendInputの座標系からカーソルのx座標に変換する関数を $ g $ と書くと、床関数 $ \lfloor x\rfloor $ を使って下記で表せます。以降で $ f(x) $ が、「4.2章最下部のグラフの各区間の左端の出力値を取ることを示します。
つまりが成立することを証明します。
上記を4.2章のグラフのイメージで描くと下記のようになります。①の $ g $ を展開すると、$ \lfloor y \rfloor = C $ なら $ C \leq y &lt; C+1 $ なので、すべての辺に $ p $ を乗算し、さらに $ f(x) $ を展開すると、$ x \cdot p $ を $ z $ と置き、すべての辺に $ 1 $ を加算すると、$ p - 1 \geq 0  $ なので、上記は常に成立する。以上で証明できた。プライマリモニタのWidthが1920だとすると、係数は34.1328125が丸められて34になります。xが1919のとき、実数上の除算だとabsXは65,500.8671875ですが、係数は34に丸められておりabsXは65,246となります。その差は-254.8671875となり、65535に対して約0.4%の誤差であることが分かります。この0.4%(=0.004)とWidth-1(=1919)を乗算すると、7～8ピクセルほどのズレになります。 ↩ここでは負の数はとりあえず考えないようにします。 ↩公式のAPIの説明上の名称はabsXではなくdxです。dxだと微分やDifferenceの略のイメージから「差分」を連想するので、記事中では絶対座標をイメージしやすいようにabsXとしています。 ↩


