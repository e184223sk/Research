More than 3 years have passed since last update.会社にあった「.NETのエンタープライズアプリケーションアーキテクチャ第２版」がなかなか興味深いし勉強になるので読書メモ。
本当は、本に書き込みたい派なんだけど、会社のものに書き込むわけにはいかないので、読書メモとして残しておく。内容としては、オブジェクト指向の基礎や、DDDについてのことなど、個人的に興味を引く内容の本です。
ただ、高い！技術書って高い！基本、備忘録として残すのを前提としているので、メモの順番には規則性がない可能性があります。Code Contract ライブラリ（3.4.2 ソフトウェア契約）については必読！！
VS2017では Code Contract ライブラリが非対応とのこと1。もちろん .NET Core でも非対応2。
こんな素晴らしい機能がなんで非対応になってんの・・・。
ってことで、後半部分は、2017/09現在では事実上役に立ちません。当たり前だけど、クラスの呼び出し元とクラスの呼ばれた側の間には依存関係が生まれる。
ログ機能などの横断的関心事については、依存関係が発生しないようにしたほうがいい。横断的関心事とは・・・  クラスに設定された要件に対して厳密には関係のない機能のこと。
例えばログ、エラー処理、など。要はいろいろなクラスで共通的に使われるものが該当すると思う。依存関係が発生しないようにする手段として、DI や Service Locator パターンを使用して、インターフェイスに依存するようにして依存性を解消する方法がある。クラスの再利用の手段として、合成（ブラックボックス）と継承（ホワイトボックス）がある。
継承では、基底クラスと最強度の密結合になる。
対して、合成では、基底クラスのインスタンスを保持する新しいクラスを作る。こちらのほうが依存関係はあるが、疎結合になる。（たぶん委譲による結合）
基本的には、クラスを再利用する場合は、継承するよりも合成にしたほうが、リスクが低い。ソフトウェアデザインのための基本原則。これは最低限覚えておきたい。クラスを変更する理由は常に１つでなければならないただしこれを突き詰めると貧血クラス（プロパティだけで振る舞いがないデータクラス）になるので、程ほどに。モジュールは、拡張に対して開いていなければならず、修正に対して閉じていなければならないサブクラスをその基底クラスと置き換えることができなければならない継承に関する原則。LSPの本質は、派生クラスが基底クラスの実行条件を制限できないことにある。↑どゆこと？
基底クラスが持つ事前条件に、派生クラスが事前条件を追加するようなことはNG。
ここは、言っていることはわかるが、なんでなのかがよくわかってないので勉強する必要がある。クライアントが使用しないインターフェイスにクライアントを強制的に依存させてはならないインターフェイスを肥大化させないようにする。
つまり、インターフェイスも機能ごとに分離させましょうねっとこと。上位モジュールを下位モジュールに依存させるのではなく、両方のモジュールを抽象化に依存させるべきである。まんまその通り。対応方法には DI パターンや Service Locator パターンがある。前にまとめたのでこちらを参照。防御的プログラミングの一環で、引数チェックをして、以上なら例外を返すという方法がある。ここでもやはり、契約による設計が言及されている.NET Framework 4 で追加された Code Contracts ライブラリでソフトウェア契約が作成できるらしい。ソフトウェア契約の実装では、構文の詳細に関係なく、クラスメソッドを記述する際は常に以下の質問に答えられるようにする必要がある。
・どのような条件下でメソッドを呼び出せるか（事前条件）
・メソッドの終了後にどのような条件が検証されるか（事後条件）
・メソッドの実行の前と後で変化しない条件は何か（不変条件）事前条件とは、メソッドの実行を開始する前に検証しなければならない Boolean 条件のこと。
以下の２つのこと。
・入力パラメータに対する条件
・メソッドが定義されているクラスの現在の状態に対する条件
概念的には、事前条件は If-Then-Throw パターンと同じ。以下のように、Contract.Requires&lt;T&gt;(bool 事前条件)という構文で、事前条件を表現できる。
事前条件が満たされない場合、&lt;T&gt;で指定した例外がスローされる。Code Contracts ライブラリの表現方法によるメリットは以下がある事後条件とは、メソッドによって生成される出力と、オブジェクトの状態に対する変更のこと。
メソッドから制御を戻すときに Boolean 条件で表現される。以下のように、 Contract.Ensures と Contract.Result&lt;T&gt; メソッドで表現することができる。メソッドの最初に事後条件を表明することができる。
また、もし事後条件を満たせなかった場合は、 ContractException 例外がスローされる。不変条件とは、コンストラクタやセッターなど、パブリックメソッドの実行中に変化しないクラスメンバーに適用される Boolean 条件のこと。
オブジェクトが論理的に矛盾した状態になるのを絶対に避けなければならないシナリオでは、常に不変条件が使用される。以下のように、 Contract.Invariant メソッドで表現することができる。と、ここまで書いてきたが、 Code Contract が VS2017 に非対応ということがわかった。
なんやねんそれ・・・
こういう機能こそ、求められてるものだと思うんだけど。C# 7.1 なんて作ってる(ryhttps://github.com/Microsoft/CodeContracts/issues/476 ↩https://stackoverflow.com/questions/42706669/code-contracts-in-net-core ↩


