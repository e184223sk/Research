.NET Framework上で動作するオブジェクト指向言語System.Consoleのメソッドを使用する配列と異なり、宣言時に要素数の上限を決める必要がないRandomクラスを使用してランダムな数字を取得する0以上の数値をランダムに生成する
Nextメソッドで生成される数の範囲の指定は以下の通り構文引数を設定する際は、データ型も指定する戻り値を設定する場合、データ型を指定するメソッド内で定義された通常の変数(ローカル変数)のスコープはメソッド内ブロックの中で宣言された変数のスコープはブロック内
(ブロック =&gt; {}で囲まれた部分)LINQを使うとデータの集まりに対する処理を簡単に行えるようになる・最初内を求める
LINQのMax、Minメソッドを用いると、配列内の数値について、最大値、最初内が求められるクラスに定義されている変数
オブジェクトが存在する限り値が保持される名前がその型の名前(クラス名)と同じメソッド
クラスからオブジェクトを作るために呼び出されるメソッドpublic =&gt; プログラム中のどこからでも呼び出せる
private =&gt; 定義されているクラスの中でのみ呼び出せる
internal =&gt; 同じプロジェクト(同じアセンブリ内の任意のコード)から呼び出せる
他にも、などがあるクラス内で定義されているもののアクセス修飾子を省略すると、privateとして扱われる
クラス自体のアクセス修飾子を省略すると、internalとして扱われるstaticがついた変数やメソッドは、全てのオブジェクトで共通して利用できる
オブジェクトを作らなくてもアクセスできるプライベートフィールドの読み書き及び計算をする際に利用する機能
プライベートフィールドは、クラスの外からアクセスできないため、そのフィールドにアクセスするパブリックのメソッドや、プロパティが必要となる 基底クラス =&gt; 派生クラス
継承したクラスのメソッド、変数を使用できるclass Class1 {
    public string Value {get; private set;}}class Class2 : Class1 {
    public Class2(string value) : base(value) {
    }}
```同名のメソッドを、引数の数、引数の型によって区別する
=&gt; 引数の違いで処理を分けることができる複数のクラスを管理するまとまり一般的に使用されるクラスなどデータやッファイルの入出力等に関連するクラスなど2の実行時エラーに対応するために例外処理を記述する例外処理を記述していないと`Unhandled Exception’エラーが発生し、発生時点で強制終了する例外ごとに例外ハンドラを記述する基底クラスであるExceptionのハンドラを派生クラスである個別例外のハンドラより前に記述するとコンパイルエラーが発生するので注意例外処理が正常に動くか確認できる呼び出したメソッド等の中で発生した例外は、呼び出し元に伝わり、処理される派生クラスのExceptionは自身以上の基底クラスで捕捉可能


