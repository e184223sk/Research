More than 1 year has passed since last update.この記事ではOOP、TestFirst、SRP(Single Responsibility Principle)について実際にDAL Generatorを作りながら解説していきます。
※OOP→オブジェクト指向、SRP→単一責任の原則、DAL→データアクセスレイヤーDbSharpというツールは実は5年くらい前に作って海外サイトで記事にして非常に高い評価を貰いました。（4.97/5.0が満点)
CodeProjectのDbSharpの記事Nugetでのダウンロードは7600ダウンロードくらいいきました。私の各アカウントは以下になります。
GitHub account
HigLabo.NetStandard on GitHub
Higty on Nuget (15万ダウンロード！)
TwitterCodeProjectの記事は今のバージョンと若干違いがあります。あまり日本ではSNSとかで活動してなかったのですが、日本語でも記事を書いた方がいいよと言われたので最新版について日本語記事を書きます。DbSharpはDALのC#コードを自動で生成するツールです。DbSharpApplicationを使用してDBに接続し、ストアドプロシージャのスキーマからストアドプロシージャを呼び出すC#のソースコードを自動で生成します。5年前くらいに海外サイトで紹介記事を書いて今はNugetで7600ダウンロードくらいです。GitHubのリンク
Download以下のように直感的にDBのストアドを実行できるコードが生成されます。またテーブルのCRUD用のストアドを自動で生成する機能（アルファ版）もあります。基本的にはストアドプロシージャの実行を簡単に出来るようにするためのツールです。業務アプリケーションでストアドプロシージャを使用する場合、C#でストアドプロシージャを呼び出すコードを書かないといけません。それをボタン一つで簡単に生成できるのが一番のメリットになります。・DbSharpApplicationの使い方
・テストファーストでの開発
・単一責任の原則を適用する
・StringBuilder vs TextWriter
・StoredProcedureクラスの設計
・データベースからスキーマデータを取得する(SqlGeometry,SqlGeography,HierarchyIdなども含む)
・Enumのサポート
・UserDefinedTypeについて
・複数の結果セットを返すストアドプロシージャ
・Asyncについて
・Indentity列、RowGuid、Timestamp列について
・高度な使い方
・その他のORM、DALレイヤーのライブラリの紹介
・まとめDbSharpはORMのようなマッピングの機能はなく、単純にストアドプロシージャの呼び出しのためのC#コードを自動生成します。ORMを使用している人でマッピングが辛くなった人は是非検討してみてください。DbSharpApplicationをお試しで使うための目次です。
・Sample Databaseのセットアップ
・DbSharpApplicationの起動
・DatabaseTypeの選択（SQLサーバー、MySQL）と接続文字列の設定
・ストアドプロシージャとユーザー定義型のインポート。メニューバー→編集→インポート
・C#コードの生成。メニューバー→編集→C#ファイルの生成
・VisualStudioでのクラスライブラリプロジェクトの作成とDLLへコンパイル
・DLLを自分のアプリケーションで使用するDbSharpSample on GitHubGitHubにサンプルプロジェクトがあります。サンプルプロジェクトの構成は以下になります。
・DbSharpSample.MySql.CSharp
・DbSharpSample.SqlServer.CSharp
・DbSharpSampleApp.MultiDatabase
現状、作成済みなのはSqlServerとMySqlのみです。DbSharpSample.MySql.CSharpとDbSharpSample.SqlServer.CSharpのプロジェクトは全て自動生成されたC#のクラスで構成されています。Extensionsフォルダだけ自分で定義したEnumクラスがあります。Generatedフォルダ以下は自動生成です。以下、これらのプロジェクトと同じプロジェクトを自分で作るためのチュートリアルです。SQLサーバーを例に解説していきます。
※MySQLもほぼ同じ手順でできます。SQLサーバーにデータベースを作成しManagementStudioでDbSharp_SqlServer.sqlを実行します。Azureの場合はDbSharp_SqlServer_Azure.sqlを実行してください。
※DbSharp_SqlServer.sqlはhttps://github.com/higty/higlabo.netstandard/tree/master/Tools/DbSharp/HigLabo.DbSharp.Sample/DbSharpSample.SqlServer.CSharp
にあります。DbSharpApplicationを起動しSqlServerを選択します。
メニューバー→ツール→オプションからテーブル機能を使用にチェックをします。メニューバー→編集→接続先の管理から接続文字列を追加します。
メニューバー→編集→インポートからDBに作成済みのストアドプロシージャをインポートします。
接続ボタンをクリックしてDBのオブジェクトを読み込みます。読み込んだオブジェクトのチェックして実行ボタンを押します。
テーブル、ストアドプロシージャ、ユーザー定義型がインポートされます。
インポートしたオブジェクトのデータはファイル→保存でXML形式で保存できます。保存したXMLファイルはファイル→開くで開くことが可能です。インポートしたストアドプロシージャはタブを切り替えることで確認できます。
インポートしたユーザー定義型はタブを切り替えることで確認できます。
テーブル機能を有効にしてテーブルをインポートした場合、以下の5つのストアドプロシージャがインポートされているのが確認できます。
・SelectAll
・SelectByPrimaryKey
・Insert
・Update
・Deleteこれらのストアドプロシージャが作成されているのもタブを切り替えることで確認できます。
ストアドプロシージャに渡す引数や結果セットの列の値をEnumにしたい場合、EnumNameにEnumの名前を入力することでEnumで値をやり取りできるようになります。
テーブルのEnumを変更すると対応するストアドプロシージャの引数のEnumNameも自動的に同期されているのが確認できます。
Usp_SelectMultiTableを見ると複数の結果セットを返しているのが確認できます。
結果セットの名前は自由に変更できます。
ここまで必要な設定（Enum,ResutSetの名前など）をしたらC#コードの生成をしてみましょう。
・OutputDirectoryPath = フォルダパスを設定します。
・RootNamespaceName = 生成されるファイルの名前空間を指定します。
・DatabaseKey = 後で解説します。実行ボタンを押して指定したフォルダにファイルを生成します。クラスライブラリプロジェクト以下のGeneratedFilesフォルダの下にファイルが生成されます。
MyEnumを定義します。クラスライブラリにMyEnumを追加します。
必要なDLLを追加します。
・HigLabo.Core
・HigLabo.Data
・HigLabo.DbSharp
SqlGeometry, SqlGeography, HierarchyIdを使用するならMicrosoft.SqlServer.Typesも必要です。コンパイルしてこのプロジェクトをコンソールアプリケーションから参照します。これで以下のようなコードで簡単にDBへアクセスできます。詳しい使用方法は後のセクションで解説します。このセクションでは「テストファースト」での開発手法について実際の開発を例にして解説していきます。このセクションでは以下のようなC#のクラスを生成することをゴールにして順番に説明していきます。自動生成するC#の構成要素を以下のように分類して設計しました。
・TypeName
・Field
・AccessModifier
・MethodAccessModifier
・FieldModifier
・ConstructorModifier
・Constructor
・MethodModifier
・MethodParameter
・Method
・PropertyBody
・Property
・ClassModifier
・Class
・InterfaceProperty
・InterfaceMethod
・Interface
・Namespace
・SourceCodeTypeNameは型の名前の部分を生成するためのクラスになります。Int32,Person,List,Dictionary&gt;といったクラス名を生成します。最初にこのTypeNameのテストケースを考えてみましょう。以下のようなテストケースを作ってみます。これらのテストケースをパスするようにTypeNameクラスを作成します。テストを実行し全てのテストがパスされることを確認します。同様にテストケースを作成しそれからクラスを作成してテストをパスしていきます。C#のソースコードを生成するのはDbSharp以外の場所でも利用できるのでHigLabo.CodeGeneratorプロジェクトに置いてあります。HigLabo.Test on GitHubこのセクションでは単一責任の原則を適用し、複数の言語（C#,VB.NET）に対してソースコードを生成するクラスの設計について解説します。上記のクラスでVB.NETのソースを生成しようとした場合、設計上の問題が発生します。VB.NETのソースを生成しようとした場合、以下のようにVB.NET用のメソッドを追加する必要があります。もし他にもJavaやF#やPythonのGeneratorを追加しようとした場合、その度にWriteXXXメソッドをTypeNameクラスに追加する必要があります。C#の担当者とVBの担当者が同じファイルに対して作業をすることになります。最近のソースコード管理の充実から同じファイルでもそんなに問題ないとはいえ、可能であれば別のファイルに対して作業ができるとマージ作業などをする必要がないのでベターです。さて以上を踏まえクラスのデザインを見直します。TypeNameクラスはクラスの情報のみをもち、ソースコードの生成機能を持たないように変更します。新たにSourceCodeGeneratorクラスを作成し、こちらでソースの生成とソースのフォーマットの設定などをできるように設計します。これが単一責任の原則で
・TypeNameクラス→クラスの情報を持つEntityクラス
・SourceCodeGeneratorクラス→ソースコードの生成
という形でそれぞれが単一の責任を持つように設計します。変更前はTypeNameがクラスの情報＋ソースコードの生成という二つの役割を持っていたためどうしてもクラスが肥大化してしまいがちになります。このように責任を単一にして分割することですっきりとした設計になります。さて分割し終わったところで新たにテストファーストでテストを作成します。CSharpSourceCodeGeneratorクラスの内部実装は以下のようにあるでしょう。TypeNameにあったメソッドを移してきた形になります。VisualBasicSourceCodeGeneratorは以下のようになります。TypeNameクラスは以下のようになります。ソース生成部分が無くなったおかげで簡単になりました。以上の設計の改善により、TypeNameとSourceCodeGeneratorクラスでファイルが分割され、さらに各言語ごとでSourceCodeGeneratorクラスを分割でき非常に作業がしやすくなりました。新しい言語やフォーマットを追加する際に、TypeNameなどのクラスに一切手を入れずに変更が可能です。これにより変更に強く、拡張もしやすいという形になっています。例えばクラスの定義をHTMLに表示するためのHTML Generatorなどを作成しHigLabo.HtmlGenerator.dllのようなDLLを作成することも既存コードを破壊することなく簡単に作成できます。このセクションではTextWriterを使ってStringBuilderを使った時よりもより良いパフォーマンスを実現する方法について解説します。その為にCSharpSourceCodeGeneratorの設計を変更します。実際の業務アプリケーションでは大量のストアドプロシージャからソースコードの生成を行う可能性があります。パフォーマンス、メモリの使用量などはしっかりと考慮したいところです。StringBuilderを使用するとStringの使用時よりは遥かに良いパフォーマンスを実現できます。しかしToStringメソッドを読んだ瞬間にStringBuilderはメモリを浪費してしまいます。TextWriterを使用することでファイルシステムに直接データを書き込むことが可能です。SourceCodeGeneratorクラスをTextWriterに対応した形に設計を改善してみます。
CSharpSourceCodeGeneratorは以下のようになります。VisualBasicSourceCodeGeneratorの実装です。SourceCodeGeneratorに共通のメソッドを定義しCSharpSourceCodeGenerator,VisualBasicSourceCodeGeneratorで実装することにします。上記の完全な実装はGitHubにあります。
HigLabo.CodeGenerator on GitHub自動生成されたC#のソースコードは以下にあります。
HigLabo.DbSharp.Sample on GitHub実は時間がなくてVB.NETバージョンはありません。（誰かに作ってくれる人なんていないかな…）このセクションではストアドプロシージャを呼び出す時のAPIの設計について解説します。ストアドプロシージャは2つのタイプに分けられます。
・結果セットを返さないストアドプロシージャ（insert,updateなど）
・結果セットを返すストアドプロシージャ（select * from...）
この二つと複数データベース、トランザクションを直感的に利用できるAPIについて考えます。以下のスクリプトでデータベースにサンプルのテーブルとストアドプロシージャを作成します。ストアドプロシージャを使用する場合、C#でストアドプロシージャを呼び出すコードを書かなければなりません。呼び出しやすいコードについて設計します。例えば以下のような形で呼び出せると分かりやすく感じます。ストアドの名前でプロパティに引数の値をセットしてメソッド実行という形で非常に直感的に使えそうです。SqlCommandのParameterだと引数名を入力しなければなりませんが、自動生成でプロパティが生成されていればインテリセンスが利いて仕様書を見る必要もなく、型も適切に定義されていて安全に使用できそうです。複数の同じスキーマのDBへストアドプロシージャを実行するには以下のように書けると良いです。トランザクションについては以下のように実行できると直感的に使えそうです。時には複数のトランザクションを並列に実行したい場合もあるかもしれません。その時は以下のように書けると分かりやすく実行できそうです。データベースが複数の場合は以上のような書き方で良いけれども、小規模なシステムでは毎回DBを渡すのは少し面倒かもしれません。例えば以下のようにデフォルトのDBを設定してそれを使用してくれる形になっているとさらに使いやすくなりそうです。ここでDbSharpApplicationで設定したDatabaseKeyの値が使われることになります。自動生成されたストアドプロシージャクラスのDatabaseKeyの既定値が設定した値になっています。そのキーの値でDatabaseFactory.Current.SetCreateDatabaseMethodでHigLabo.Data.SqlServerDatabaseオブジェクトを生成するように設定します。そうすることでアプリケーション全体でこの既定のデータベースが使用されることになります。DatabaseKeyとTransactionContextを直接渡すのが混在した場合は、TransactionContextのほうが優先されることになります。実際に実装するに当たってのクラスの設計はこんな感じで設計してみました。StoredProcedureクラスはストアドプロシージャ（結果セット無し）の共通の処理を定義することになります。具体的には
・ExecuteNonQuery()
・ExecuteNonQueryAsync()
になる。さらに子クラスで実装するべき抽象メソッドとして
・GetStoredProcedureName()
・CreateCommand()
・SetOutputParameterValue()
が定義されます。GetStoredProcedureName()はストアドの名前を返すメソッド、CreateCommand()はプロパティにセットされた値からDbCommandを生成するメソッドになります。ExecuteNonQuery()を呼ぶとストアドが実行されます。SetOutputParameterValue()の内部ではOutputパラメータの値がプロパティにセットされます。このメソッドはTimestamp、Identity列などを使用した際に内部で使われ、ExecuteNonQuery()を実行後にDB上で生成された値をStoredProcedureクラスのプロパティにセットしてくれます。これらは結果セットのクラスの基底クラスになります。MultiPkTableSelectByPrimaryKey.ResultSetクラスの親クラスがStoredProcedureResultSetになります。MultiPkTableSelectByPrimaryKey.ResultSetクラスはいわゆるPOCOクラスで結果セットの各値をプロパティとして持つクラスです。StoredProcedureWithResultSetクラスはストアドプロシージャ（結果セット有り）の共通の処理が定義されています。
・GetDataTable()
・GetResultSets()
・EnumerateResultSets()
に共通ロジックが実装されています。ただこのままでは戻り値はStoredProcedureResultSetとなり、自動生成されてResultSetクラスではないので使い勝手が悪い状態です。StoredProcedureWithResultSet&lt;T&gt;クラスはStoredProcedureWithResultSetクラスの戻り値をより具体的な型として返す機能を提供するクラスになります。このクラスには
・SetResultSet()
・CreateResultSet()
が定義されていて、これらの抽象メソッドは自動生成される子クラスで実装するべき抽象メソッドになります。StoredProcedureWithResultSetクラスを自動生成されたストアドプロシージャクラスで継承することで共通処理を1か所に定義しつつ、より具体的な型でメソッドが使用でき、保守性と利便性を両立させることができるようになります。このクラスは複数の結果セットを返すストアドプロシージャクラスが継承する基底クラスになります。
MARSに対応したストアドプロシージャの共通処理がこのクラスに定義されることになります。MultiPkTableInsertは実際にDBに存在するストアドプロシージャに1対1対応して自動生成されるクラスになります。ストアドプロシージャの引数がプロパティとして定義され、プロパティに値をセットしてExecuteNonQuery()メソッドを呼び出せばストアドプロシージャが呼び出せます。このクラスにGetStoredProcedureName, CreateCommand, SetOutputParameterValueの具体的な実装が定義されることになります。MultiPkTableSelectByPrimaryKeyクラスは主キーで結果セットを取得するクラスになります。結果セットの1レコードを表すクラスはMultiPkTableSelectByPrimaryKey.ResultSetクラスとして定義されています。それぞれのクラスが単一責任を持っていて処理は1か所に書かれ保守がしやすくなっており、ほとんどの処理がHigLabo.DbSharp.dll側で定義されることになります。結果として自動生成で考えなければいけないのは
・CreateCommand()
・SetOutputParameterValue()
・SetResultSet()
・CreateResultSet()
の内部実装だけということになります。上記のクラス設計により
・CreateCommand（常に必要）
・SetOutputParameterValue（Output引数があれば）
・SetResultSet（結果セットがある場合）
・CreateResultSet（結果セットがある場合）
を生成すればほぼ自動生成部分が完了することになります。マイクロソフトのSQLサーバーの一般的な型は以下になります。さらにSQLサーバーにはユーザー定義型という機能がありこれもサポートすることにしましょう。ユーザー定義型を利用すると複数のレコードを1回のラウンドトリップで一括で更新するなどの処理が実行できるようになります。さらにC#のEnumにマッピングする機能も提供することにします。まとめると以下のリストの機能がサポートされます。
・一般的な型
・Udt(SqlGeometry,SqlGeography,HierarchyId)
・EnumこのセクションではUsp_Structureストアドプロシージャを例に解説していきます。CreateCommandメソッドの内部実装は以下のようになるはずです。SetOutputParameterValueメソッドの内部実装は以下のようになります。結果セット無しのストアドプロシージャの自動生成コードは主にこの2か所と各プロパティで済みます。設計がうまくいったので最小限の自動生成コードで済みました。結果セットがある場合はCreateResultSetメソッドとSetResultSetメソッドを生成する必要があります。AllDataTypeTableSelectAllの内部実装を例に解説します。CreateResultSetメソッドはこのStoredProcedureクラスの結果セットに対応するResultSetクラスを生成するメソッドで以下のようになります。SetResultSetの内部実装は以下のようになります。全ての型を適切に変換するコードを自動生成するだけです。このコードを生成するにはデータベースのスキーマ情報が必要です。例えばCreateCommandメソッドを生成するには以下のスキーマ情報を取得する必要があります。
・ColumnName
・Type
・Length
・Precision
・Scale
・IsOutput parameter
・UserTableTypeName
・UdtTypeName上記の情報を取得するためのスクリプトは以下になります。以下のような情報が取得できます。
SetResultSetメソッドのスキーマ情報は適当なパラメーターを与えてストアドを実行し、DataReaderクラスのGetSchemaTableメソッドから取得します。これで自動生成のための情報が全て揃い、後はコードを生成するだけとなります。DbSharpApplicationは現状SQLサーバーとMySQLに対応しています。PostgresとOracleには対応していません。どこかに
・スキーマデータを取得するSQLスクリプト
・全ての型のメソッドの実装コード（CreateCommand,SetResutSet,SetOutputParameter）
を作ってもいいよ、なんて人を探してます。実装コードはを作っていただけるとPostgresとOracle対応ができそうです。PostgresとOracleのプロフェッショナルな方、お待ちしております。特定の値のみ許可する場合、Enumのサポートがあると便利です。Enumサポートの仕様は以下のようにデザインします。
・C#上でプロパティがEnumになり、強く型付けされた形で扱える
・Enumの値は文字列になってデータベースへ保存される。
・データベースの列の型はテキストを格納できる型のみEnum機能によりデータベースに間違った値が挿入されることを防ぐことが可能です。データベースへ値を送るときはCreateCommandメソッドの中で以下のように変換されます。データベースから取得された文字列はEnumに変換されます。変換には以下のメソッドが使用されます。このメソッドを使用してSetResutSetメソッドで以下のようにテキストからEnumへ変換されます。データベースにEnumへ変換ができない不正な値が含まれている場合、InvalidEnumDataExceptionがスローされます。このセクションではユーザー定義型について解説します。サンプルプロジェクトの中にMyTableTypeというユーザー定義型を作成するコードがあります。TimeStamp,Geometry,Geography,HierarchyIdとSqlVariantは対応しません。作成したユーザー定義型をストアドプロシージャの引数で使用できます。引数で使用する際にはreadonlyキーワードをつける必要があります。引数でユーザー定義型を使用することでレコードのリストをデータベースに送ることができます。例えば100件のUPDATEする処理を1回のラウンドトリップでデータベースに送れるのでラウンドトリップを100回繰り返す場合に比べパフォーマンスが大幅に向上します。DbSharpApplicationでユーザー定義型を使用する場合は以下のように書けます。ユーザー定義型に関係するクラスを以下のように設計しました。
・UserDefinedTableType
・UserDefinedTableType
・MyTableType
・MyTableType.Record
ストアドの時と同様に単一責任、共通処理をまとめるなどを設計で行い、自動生成部分のコードを最小限に抑えます。クラスダイアグラムは以下のようになります。
ほぼ全ての共通処理はUserDefinedTableType,UserDefinedTableTypeに定義されています。自動生成されたクラスは以下のようになります。ユーザー定義型はDbSharpApplicationにおいてはストアドプロシージャの引数のみで使用されます。使用できるようにするためにCreateCommandメソッドを生成する必要があります。内部実装は以下のようになります。ユーザー定義型をOUTPUT引数に定義することはできないのでSetOutputParameterValueメソッドを生成する必要はありません。また結果セットでユーザー定義型を使用することはできないのでGetResultSetsメソッドも生成の必要はありません。SQLサーバーにはMARSという機能があり、一度の呼び出しで複数の結果セットを取得することが可能です。DbSharpApplicationは複数の結果セットも対応しており以下のように書いて利用できます。ResultSet1,ResultSet2,ResultSet3という名前は自由に変更可能です。
このセクションではIndentity,RowGuid,Timestampについて解説します。これらの列の特徴として2つの特徴があります。
・実行時にデータベースで値が生成される
・実行後に生成された値を取得したいRowGuid,Timestampについても同様にExecuteNonQueryの実行後にプロパティにアクセスすると値を取得できます。DbSharpApplicationはデータベースアクセス回りのツールです。データベース回りのツールは他にもたくさんのライブラリがあります。
・NHibernate
・Entity Framework
・Dapper
・Repository patternDbSharpが良い点は以下になります。メインの機能は
・直感的なAPI
・SqlServer,MySqlのサポート(Oracle,PostgreSqlはそのうち...)
・トランザクションのサポート
・Timestamp,Identityのサポート
・ユーザー定義型,RowGuid,Geometry,Geography,HierarchyIdの対応(SqlServer)
・Table機能でのBulkInsertのサポート(SqlServer)
・Enumのサポート
・Setのサポート(MySql)
・パフォーマンスペナルティが無い
・No LINQ何か足りない機能があれば気軽にTwitterまでDMください。
HigLabo on Twitter


