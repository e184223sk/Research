More than 1 year has passed since last update.前回 はList＜T＞について、色々と書いて見ました。今回は前回割愛したもののうち、foreachついて色々書きたいと思います。おまけ程度にVisual Studioのおかしな挙動についても少し書いてます。C#が用意している構文の中身について知りたいちょっと変わった人向けです。今回も独学で書いている部分が多いので、間違ってたらガンガン指摘してください。タイトルは特に思いつかなかったので前回と同じなのは秘密。Listや配列等の要素を1つずつ取り出すための構文。「C#入門」とか「初心者向けC#」とか読んでも必ず出てくる。実は内部で結構複雑なことをやってるけど、それをおくびにも出さない凄いお方。最近はLINQに出番を奪われることもあるが、まだまだ現役バリバリ。まずはソースコードから。Listを使ったことがあるのに、foreachを使った事が無い人はいないと思います。forで書いていた、がいらないので、非常に便利です。勝手に最初から最後までやってくれます。でも、いらないと言っても誰かが条件を設定しなければならないはずです。誰がやってくれてるんでしょうかね？その秘密はforeachの真の姿に隠されています。2019/01/17大嘘でした。(2回目)インターフェース越しに展開すると仮想呼び出しのコストが掛かるので、List&lt;T&gt;内部の構造体に展開されます。(情報ありがとうございます。)foreachはコンパイルするとこんな感じに展開されます。突然大量の見たこともないメソッドやらプロパティやらが溢れてきて面食らいますが、一つ一つ解説していきますので安心(?)してください。話がそれますが、今回のように「実際に利用者が書いたコード」と「コンパイラの展開結果」が一致しないことは多々あります。これはシンタックスシュガーと呼ばれる機能で、糖衣構文なんて呼んだりもします。話を戻して、まずは(1)を見てください。GetEnumeratorは、Listクラスのメソッドです。突然出てきました。IEnumerable&lt;T&gt;インターフェースとIEnumerator&lt;T&gt;インターフェース、そしてEnumerator構造体です。順番に解説してきましょう。実は、foreachが受け入れる事が出来る変数は、必ずIEnumerable&lt;T&gt;を継承している必要があります。2019/01/16
大嘘でした。正しくは、上記2つを満たしている必要があります。(情報ありがとうございます。)I(インターフェース) + Enumerate(...を数え上げる) + able(出来る)なので、「数え上げる事が出来る(ことを規約する)インターフェース」といった感じの意味になります。(英語は苦手なので間違ってるかもしれません)メソッドは1つのみです。ジェネリクスで指定された型のIEnumerator&lt;T&gt;を返すメソッドです。ここで、改めてListクラスの定義を見てみます。Listクラスが直接継承しているインターフェースは、IList&lt;T&gt;, IList, IReadOnlyList&lt;T&gt;の3つです。そして、IList&lt;T&gt;はICollection&lt;T&gt;を、ICollection&lt;T&gt;はIEnumerable&lt;T&gt;を、IEnumerable&lt;T&gt;はIEnumerableを継承しています。さらに、IListはICollectionを、ICollectionはIEnumerableを継承しています。最後に、IReadOnlyList&lt;T&gt;はIReadOnlyCollection&lt;T&gt;を、IReadOnlyCollection&lt;T&gt;はIEnumerable&lt;T&gt;を、継承しています。継承祭りですね。てんやわんやなので少し整理すると、Listクラスが継承しているインターフェースは、となります。先述の通り、IEnumerable&lt;T&gt;を継承してるので、foreachはListを受け入れる事が可能です。また少し話がそれますが、&lt;T&gt;はジェネリクスだよ。って事は前回お話しました。「IList&lt;T&gt;とIListって何がちゃうねん、コラ」と思う方もいると思います。C#にジェネリクスの機能が追加されたのは、2005年、C#の2.0からです。(僕がまだギリギリランドセルを背負ってたくらい昔の話です。)IList、ICollection、IEnumerableはそれ以前からC#に存在している方々です。ジェネリクスが存在しないので、当然List&lt;T&gt;も存在しません。このころはList的な物を使いたい場合、取り扱う型ごとに違うクラス、もしくはobjectで全てを受け入れるクラスを作っていたんだと思います。(推測です。このころの事は全然知らないので詳しい方、教えてください。)これでは不便だろうと言うことで、ジェネリクスが誕生しました。そして、IList&lt;T&gt;、ICollection&lt;T&gt;、IEnumerable&lt;T&gt;、そしてList&lt;T&gt;も合わせて生まれます。誕生した所までは良かったんですが、「じゃあ今まで使ってたジェネリクスしてない(非ジェネリクス)コードはどうするんだ？」問題が発生します。過去のコードが使用できなくなるような変更を破壊的変更と言いますが、C#は破壊的変更を避けるようにかなり慎重に機能の追加・修正を行っています。(破壊的変更を避けるのは、C#に限った話ではありませんけども)そんな経緯があるので、非ジェネリクスインターフェースは残っています。IReadOnlyList&lt;T&gt;は、.Net Framework 4.5で追加された機能です。2012年、C#は5.0のなのでこんな話とは無縁です。なので、非ジェネリクスなインターフェースはいません。(僕が社会人になる3年くらい前です。ずいぶんと最近な気がしますね。)IEnumerable&lt;T&gt;はListが継承していました。では、IEnumerator&lt;T&gt;はどこにあるんでしょうか？こいつはEnumerator構造体が継承しています。まず先に、IEnumerator&lt;T&gt;の定義から。I(インターフェース) + Enumerate(...を数え上げる) + or(もの)なので、「数え上げる処理をする(ことを規約する)インターフェース」といった感じの意味になります。(英語は苦手なので以下略)IEnumeratorには2つのメソッドと1つのプロパティが、IEnumerator&lt;T&gt;には1つのプロパティがあります。foreachはIEnumeratorのMoveNextメソッドとIEnumerator&lt;T&gt;のCurrentプロパティを使用しています。(本当はIDisposableのDisposeも使用しているのですが、Listの場合、処理なしで実装されているので割愛)このEnumerator構造体ですが、Listクラスの内部に定義されているローカル構造体です。Enumeratorは、IEnumerator&lt;T&gt;とIEnumeratorを継承しています。そして、IEnumerator&lt;T&gt;は、IDisposableとIEnumeratorを継承しています。なのでEnumerator構造体が継承しているインターフェースは、となります。説明し終わったところで、改めて(1)に戻ります。GetEnumeratorが呼び出された時、Enumeratorのコンストラクタを実行しています。引数はthisなので、List自身ですね。Enumeratorのコンストラクタとフィールドはこうなっています。順を追ってみると、これで終わりです。とてもシンプルですね。次に(2)です。ループ処理の終了条件です。Enumerator内の実装はこうなっています。まず、コンストラクタで保存したversionとlocalList._versionが一致していて、indexが0以上かつ、localList._size未満であるか確認しています。条件を満たしていた場合は、currentフィールドの値を書き換えて、indexをインクリメント。次に進むことが出来たのでtrueを返して終了です。条件を満たしていない場合は、versionとlocalList._versionを確認し、一致していなければInvalidOperationExceptionを発行。そうでない場合は、`currentを初期化。次に進めなかったので、falseを返して終了です。つまり、こうやってループの終了を判定しているんですね。(優先順位は上から)前回の記事の「コレクションの変更ってどうなってるの？」で割愛した「foerachも似たようなことをやっています。」がこの部分になります。最後に(3)です。ただのゲッターなので、特に言うこともありません。(2)で設定した値を取得しています。自作のクラスをforeachに渡す事が出来るようになります！おそらく意味はない正直面倒くさいだけで実用性は皆無ですが、勉強としては意味がある...んじゃないですかね。多分。実際に作ってみました。満たすべき要件この2つだけです。なので、取り出し時は入れた時とは逆順で出てきます。削除もインデクサでの取り出しも出来ません。それでいいんです、自作なので。まずはListModokiの作成です。IEnumerable&lt;T&gt;の部分です。(説明用にクラスをpartialで分割してますが、本来は不要です。)先頭位置を記憶するためのheadを持っています。ListValue&lt;T&gt;は、値と次の要素を持ったクラスです(詳細は後述)。IEnumerator&lt;T&gt;の部分です。内部クラスとして定義してます。Currentで値を取得する時についでに、次に進めています。今回は面倒なのでここでしか使わないのでCurrentに副作用を持たせていますが、かなり危険な行為です。理由は一番最後におまけで書いておくので、読んでください。最後にListModokiの中身、ListValueです。自分の値と次の中身を持っています。実際に0から9まで値を追加した後、順番に取り出していきます。最初に言い訳したとおり、入れた時とは逆の順番で出てきます。さらに、インデクサでのアクセスが出来ないので、forは使用できません。(超不便)既存のクラスでは実現できない要求が来た時に、覚えておくと役に立つ可能性は否定出来ないんじゃないかと思います。(超弱気)前回書けなかった部分のうちIEnumerable&lt;T&gt;について書こうと思ってたらforeachの話になってました。自作のListModokiを要求されることはまず無いと思います。どう考えてもListの方が万能です。次の内容は未定です。次があるかどうかも未定です。ゲッターに副作用を持たせた状態で、Visual Studioでデバックを行うとバグります。ウォッチ式やマウスオーバーした時に出るアレ(名前を知らない)で値を確認するたびに、その副作用が実行されます。今回の場合、勝手にcurrentが進んでいきます。結構深刻なバグの元になりかねないので、ゲッターに副作用を持たせるのは止めましょう。簡単なテストを行なった画像を下に貼っておきます。(Visual Studio 2017です。)


