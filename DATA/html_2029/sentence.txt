Windows上でタッチパッドのタッチ位置を捕捉する機能は、.NETでは標準で提供されていませんが、これをWin32のRaw Input APIで.NETから捕捉できるようにします。内容的には、TouchpadGestures AdvancedのC++のコードに基本的にならって、C#のP/Invokeで実行するようにしたものです。
タッチパッド（タッチパネルにあらず）からの入力は、.NETではマウスの動きに変換された後に扱うようになっていて、タッチパッドの入力を直接扱えるようにはなっていません。それで実用的に困ることはないですし、タッチ操作用のデバイスとしてはタッチスクリーンの方が優れているので、タッチパッドにこだわる必要もないです。ただ、入力デバイスの選択肢としてあって困ることはなく、その一方で先行例が見つからず手が出なかったのですが1、@kamektxさんのTouchpadGestures Advancedを見かけてC++での方法は分かったので、C#でも書けるかなと。ノートPCのタッチパッドでタブを切り替えるソフトウェアを作りました ～TouchpadGestures Advanced～その途中で@mfakaneさんのRawInput.Sharpを知り、既にライブラリ化されていたわけですが、いずれにせよこの二つを非常に参考にさせていただきました。タッチパッドからの入力を捕捉するには、WM_INPUTメッセージが送られてくるように登録が必要ですが、ここは難しくないので省きます。問題はWM_INPUTメッセージを受けて、このデータからタッチ位置などの情報をどう取得するかですが、基本的にTouchpadGestures AdvancedのHidManagerの手順にならっています。大まかな流れは、以下のようになります。始めに、タッチ位置などのコンタクトの値を格納するためのTouchpadContact構造体を作成。ContactIdはタッチ中に各コンタクトに継続的に振られる番号で、これでどのコンタクトかを判別します。XとYはタッチパッドの左上角を原点とした座標。次に、TouchpadContactを生成するためのTouchpadContactCreatorクラスを作成。これはTouchpadContact中の値は一遍に取得できず、順番に一時保存してから生成する必要があるためです。最後に、lParamからTouchpadContactを配列で取得するParseInputメソッド。基本的には粛々とP/Invokeを書けばいいのですが、少し難しいのはRAWHID構造体で、Win32の定義は以下のようになっています。この1番目のdwSizeHidは各HID inputのデータの長さ、2番目のdwCountはHID inputの数で、3番目のbRawDataが実際のデータですが、byte配列でありながら長さは1になっています。RemarksによればdwSizeHidとdwCountの積がbRawDataの長さになるということですが、Surface Pro 4で実際に実行してみると、dwSizeHidが30、dwCountが1だったので、この積は30となり、計算が合いません。ではどういうことかというと、これはWin32では時々ある、構造体の後ろにbyte配列が続いている形式で、bRawDataはこの配列の先頭byteを指しています。つまり、Surface Pro 4の例ではRAWINPUT構造体の長さは62だったので、RAWINPUTHEADERの長さが24（16 + 8）で、dwSizeHidとdwCountの長さがそれぞれ4なので、差し引き62 - 24 - 4 - 4 = 30がbRawDataの本当の長さということになります。これは、dwSizeHidとdwCountの積とも符合します。ちなみに、30でコンタクト5つ分のデータがありました。もしこの長さが30で固定であれば、[MarshalAs(UnmanagedType.ByValArray, SizeConst = 30)]を付ければいいわけですが、固定ではないのでしょうから、これはなし。したがって、RAWINPUT構造体を取得するときに、先にこのサイズを取得した後、IntPtrにメモリを確保し、このIntPtrにGetRawInputDataのデータを格納し、このIntPtrからRAWINPUT構造体に変換してbRawData以外の値を取得し、さらに同じIntPtrから直接byte配列を取得して、この後半のbRawDataに当たる部分を取り出すということをやっています。2上記のコードのレポジトリはRawInput.Touchpadです。テスト環境は以下のとおりです。タッチパッドに指を同時に5本当てたところ。5つのコンタクトで各指のタッチ位置が示されています。

タッチ中は非常に短い間隔でWM_INPUTメッセージが送られてきますが、指が浮くとその指のコンタクトは途切れてしまうので、動きを自然にトレースするには同じIDのコンタクトを追う必要があります。ちなみに、Surface Pro 4の例ではタッチパッドの左上角が原点の0,0で、右下角が1956,997だったので、物理的なサイズ(101 × 53mm)に対比して結構細かいです。以上のとおり、もし必要が出てくれば使えるのではないかと思います。Synapticsのタッチパッド用のものは以前から存在しますが、こちらは汎用的なRaw Input APIを使うので、高精度タッチパッド（Precision Touchpad）であれば動くはず、というのも利点です。 ↩RawInput.Sharpではunsafeにしてポインターでスマートに処理しています。 ↩


