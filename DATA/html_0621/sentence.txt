Webアプリケーションの開発で、HttpContextから情報を取得するメソッドがあったとする。このメソッドのテストはIISが必要となるため、通常であれば結合テストフェーズにならないとテストができない。しかしどうしても単体テストを行いたい場合には、Visual Studio Enterpriseで利用可能なMS Fakesを利用することで、何とか単体でのテストが可能であるということを、この記事で述べていきたいと思う。概要では、HttpContextから値を取得するメソッドのテストについて記述すると書いたが、本来であればテスト対象となるようなメソッドがHttpContextからじかに値を取得するような設計があまりよくないと思われる。
つまり、ブラウザから入力した値をコードビハインドやハンドラーで取得せずに後続処理に投げていたり、もしくはセッション状態に常にアクセス可能なオブジェクトを保持し続けるといった実装はクラス間の結合が密になってしまうため、改修やテストの際に扱いにくくなってしまうということである。またレガシーナコードなどでは、ビジネスロジックとしてオブジェクト(モデル)に移譲すべき処理をコードビハインドに直接記述しいるケースも考えられる。正しく対応するのであれば、サーバー処理に必要な引数はコードビハインドで変数として抜き出して業務ロジックに引き渡すようにする。また、セッションにオブジェクトを保持しなくていいような設計にする。コードビハインドに業務ロジックがあった場合はリファクタリングして別のクラスに処理を委譲するなどプロジェクトのクラス構成から設計しなおした場合が良いことが多いだろう。だが、レガシーなアプリケーションや、複雑な状態を保持するオブジェクトを何らかの理由(工期やプロジェクトのチーム構成の問題など)で保持する理由ケースが存在することは確かなので、そのようなメソッドをテストしたい場合もあるのが実情である。
では、どうすれば単体テストを実施することが可能なのだろうか。※ここでは本当にHttpContextを必要としている場合を想定している。HttpContextから抜き出した値を保持している別のクラスからその値を取得する場合などは、その別クラスをインターフェース化しテスト用のスタブを作成するだけで十分テストを実施できる場合が多い。Microsoft Fakesは2020年10月現在Visual StudioのEnterprise版でしか利用できないが、アプリケーションの一部の機能(プロパティ、メソッド)をテスト実施時に自分の好きなふるまいをするように置き換えることができるツールである。
(参考:https://docs.microsoft.com/ja-jp/visualstudio/test/isolating-code-under-test-with-microsoft-fakes?view=vs-2019 )
このツールを用いて、HttpContextの返す様々なオブジェクトや値をテスト実施の際に偽装してしまえば、今問題になっているメソッドのテストが行える。今、適当なWebアプリを作成してみる。Visual Studio 2019だと、空のソリューションに対してC#&gt;Windows&gt;Webでプロジェクトの種類を絞り込んで、ASP.NET Webアプリケーション(.NET Framework)を選択し、空のプロジェクトを選択作成したうえで、default.aspxとエラーのリダイレクト先のerropage.htmlを追加して作っている。それぞれのファイルの中身は以下のような感じフォームに入力した文字を加工して表示するだけの単純なアプリで、「例外発生」という文字列が送られてきた時だけエラーページに飛ばすような作りである。
では、このdefault.aspx.csにあるPage_Loadで、本当に「例外発生」という文字列が送られてきた時にApplicationExceptionをスローしているかをテストするにはどうすればいいだろうか。ソリューションに空のテストプロジェクトを追加して、以下の手順でテストクラスを作成します。Page_Loadのタイミングで例外を投げることをテストしたいので、以下のようなテストコードを記述してみるが、このままだとフォームからの入力がないため文字列を渡すことができないうえに、HttpContext.Currentが存在していないためプロパティにアクセス時に例外発生するという問題が発生する。
ここで本題であるMicrosoft Fakesを利用することで、本来存在しないはずのHttpContext.Current及びその先のプロパティを偽装することができるのである。Fakesで偽装をしたい対象がHttpCotextクラスのCurrentプロパティなので、このクラスを含むSystem.Web.dllをFakesアセンブリに追加する
すると、Fakesというフォルダがテストプロジェクトに追加され、このdllに含まれるクラスのクラスを偽装できることがわかる。
次に、HttpContextを偽装していくわけだが、偽装の定義はShimContextのスコープ内でしか利用できないので、テストの最中だけShimContextを用いるようusing節の内部にテストコードを書くことになる。もちろんusing節を必ずしも用いる必要はないのだが、その場合自分でShimContextを破棄しなければならないので注意が必要である。偽装の実装法は、ラムダ式で定義するのが一般的なため以下のようなコードになる。ここで、DummySessionStateクラスはSessionの偽装用クラスでどのように実装してもいいのだが、一例としては以下のような実装が考えられる。Visual Studioでは、インターフェース(今の場合IDictionary)の継承クラス内に、そのインターフェースを実装したクラスをフィールド(今の場合innerDic)として保持していると、そのフィールドを通じてクラス実装のコードを自動生成してくれる機能があるので、このような実装も簡単に行うことができる。多少コードが長くなったが、内容はシンプルなので少し読んでみれば簡単にわかる内容となっているはずである。
この程度のコーディングでテストを可能にするFakesはテストの適用範囲を広げてくれる可能性を感じさせてくれるのではないだろうか。今回の例では、本来RequestのItemsのみを偽装すればテストには十分だったが、よくHttpContextからアクセスする可能性のあるFormやQueryStringなどのプロパティに関しても偽装を実装してみた。Fakesを用いれば、今回のような静的プロパティを偽装してテストを実施できることを示したが、冒頭にも記したようにグローバルオブジェクトのように振舞えるHttpContextへのアクセスは限定的にし、テスト可能なクラス設計を行うことが正攻法なので、何でもかんでも偽装をすればよいとクラス構成をおろそかにしてはならないことに注意しよう。


