More than 3 years have passed since last update.この記事はライフゲーム Advent Calendar 2017の17日目の記事です。
ギリギリ（23時30分ぐらい）間に合いました。C#＋WPFでMVVMにライフゲームを作ってみました。WPFとMVVMについて使ったことない人向けにものすごくざっくりとした説明をします。WindowsGUIアプリケーション用のフレームワークです。
画面部分はXAMLというXML拡張言語を使って、それ以外はC#またはVisualBasicを使います。アプリケーションをModel/View/ViewModelの3層構造に分けるアーキテクチャです。
まぁMVCとかのMV◯系統の1種です。
とりあえず、この記事では以下のように分けます。
Viewは直接のUIの記述、つまりボタンやコンボボックスの配置とViewModelへのバインディングのみです。
ModelはGUIに依存しない部分、つまりライフゲームのセルの状態や登録されたパターンの管理、ゲームルールなどです。
例えばアプリケーションのコンソール版を作ろうとした場合にはModelは全て使いまわせるのが理想です（理想なんですが。。。）。
ViewModelはModelとViewの橋渡しです。今回はModelをほぼそのまま渡しているのであまり仕事をしていません。緑色が生きているセル、黒が死んでいるセルです。
ライフゲームでの有名なパターン"パルサー"が表示されています。基本操作は以下の4つ
「Start」でゲーム開始
「Stop」でゲーム停止
「Random」で全セルの状態をランダムに変更
マウスクリックで任意のセルの生死を変更加えて、更新間隔[msec]を左のテキストボックスで変更できます。
またセルの状態パターンを名前を付けて管理できます。
右下のコンボボックスで登録されたパターンを選択すると、セルの状態が変更されます。
中央のテキストボックスでパターンの名前を入力
「Save」で現在のパターンを保存
「Remove」でパターンの登録を解除ItemsControlのItemSourceがセルのコレクションCellsとバインディングされています。
ItemsControlのPanelはUniformGridになっており、列数がCountRowColumnとバインディングされています。
これにより1次元配列のCellsが強制的に列数ごとに改行され、2次元のように見えます。
ItemsControlのItemはToggleButtonになっており、チェック状態がセルの生死にバインディングされています。コードビハインドには何も書いていないので省略します。ViewModelでは基本的にModelと結びつけているだけです。全体モデルをModel
個別のセルがCell
セルの中の位置がPosition
特定のセルのパターンをWorldState
としてクラス化します。WPF:LifeGame(ライフゲーム)  - Gushwell's C# Programming PageVisualStudio2017
.NET Framework 4.7
ReactiveProperty3.6


