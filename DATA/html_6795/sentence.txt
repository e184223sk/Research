More than 3 years have passed since last update.UnityでリアルタイムテクスチャペイントするアセットUnityTexturePaintを作ったので、リアルタイムペイントを行うノウハウについて書き残そうと思います。UnityTexturePaintはから入手できます。Asset Storeでは有料ですが、GitHubから誰でもFreeで持ってこれるので気に入ったらご購入お願いします。タイトル通り、リアルタイムでのTexturePaintを可能にするアセットです。
UnityTexturePaintで何が出来るかというと好きな場所に好きな色塗ったり
応用して塗った場所を凹ませてみたり
アルファ値だけペイントして近未来な床を作ったり
一部鏡面反射するようなモノを作ったり
アイデア次第で色々できます。詳しくはブログで。ドキュメントはこちらです。おおまかな流れはこんな感じです。実行時にのみ書き込みを行うため、Awakeあたりで初回のみ、ペイント対象のテクスチャをRenderTextureに差し替えます。以下はその差し替え部分のC#コードです。mainTextureが元々オブジェクトに貼られていたテクスチャ、paintMainTextureが新しく生成したRenderTextureです。Unityでオブジェクト表面上のどこかしらの点を取ってきたい場合、一番簡単なのがRaycastを使う方法です。Raycastの出力するRaycastHit構造体には、ヒット位置のUV座標を取ってくるtextureCoordプロパティが定義されています。
しかし、コライダーがMeshColliderではなかった場合RaycastHitのTexcoordは常にVector2.zeroを返します。これだと、キャラクターモデルなどの頂点数の多いモデルなどにペイントを行いたい場合にもMeshColliderを使わなくちゃいけなくなったりして都合が悪くなります。具体的にどんなときに都合が悪いかというとなどなど、かなり使いにくくなってしまいます。そこで、UnityTexturePaintではMeshColliderを使わなくてもペイントが行えるようにするため、メッシュの頂点やそれに対応するUV座標から求めたいUV座標を補間する方法を使っています。以下のアルゴリズムではサーフェスが全て三角形であることを前提としていますが、Unityでは気にする必要はありません。入力する点pは、オブジェクト表面上の塗りたい場所です。詳細は以下を参照してください。UVさえ求まればあとは単純な画像処理です。
UVとブラシの大きさから現在参照しているピクセルに対して色を合成するかどうかを判断して書き込みを行います。以下は書き込みを行うシェーダーの重要な部分(ピクセルシェーダーと補助関数、マクロ)のみを抜粋したものです。_BrushScaleがブラシサイズ、_MainTexが元々オブジェクトに貼られていたテクスチャ、_Brushがブラシテクスチャです。あとはこのシェーダーを使ってC#側から必要な値をセットし、レンダリングしてやればペイント完了です。paintMaterialは先程のシェーダーを適用したマテリアルです。
SetPaintMainDataでは、ブラシのスケールや色、テクスチャ、求めたUV座標などをマテリアルにSetしています。法線マップやハイトマップへペイントを行う場合、色のブレンディングアルゴリズムがメインテクスチャで必要なケースと多少変わってくるので、別の処理が必要になってきますが、大枠は大して変わりません。UnityTexturePaintの強みは、MeshColliderやRaycastを使わず、リアルタイムでペイントを実現できること、法線マップやハイトマップなどのペイントも行えること、応用次第で色々なことが実現可能なことです。現在開発中の機能では、液体が流れる表現を作っています。興味がありましたら触って感想などいただければ幸いです。© UTJ/UCL
この記事内で使っている一部の画像ではユニティちゃんを利用させていただいてます。


