More than 1 year has passed since last update.私はWPFでアプリを開発していたんですが、Process.Exitedが作動しませんでした。
一応、解決策が見つかったので載せておきたいと思います。(ただし安全だとは決して思いませんが)
あと、注意点を書いているのでそちらもご覧ください。2020/07/07「代替案2-α」「代替案3」の追加をしました。1
　　　　　「代替案1」「代替案2」のコード修正と注記をしました。2TextBlockとButtonがある単純なUIで、ボタンを押すと外部アプリケーションが起動する。
外部アプリケーション起動中はTextBlockに「外部プログラム起動中」と表示され、終了すると「外部プログラム終了」と表示される。まずは簡単なほうから。
コードビハインドで非同期メソッドを記述してDispacherを使うといけました。
TextBlockはTextBlock1、ButtonはButton1でコードを書いてます。私にはなんでこれで動いてしまったのかわからないので、有識者の方の解説をお待ちしてます。
※追記
このコードが動作した理由は「await Task.Run(() =&gt; process.WaitForExit());」が非同期で呼び出されているため、usingブロックを抜けてもprocessが保持されるのでOnExitedが呼び出されたようです。つぎに本題のMVVM(もどき)での解決法はこちら。
解説などはコードの下になります。このコードでは、TextBlockのTextプロパティにTextをバインドし、Buttonが押されたらActivateExcuteが呼び出されるようになっています。ちなみに、なんでこんなコードになったのかというと、MicrosoftのDocsでProcessについて調べたら、Note that the Exited event is raised even if the value of EnableRaisingEvents is false when the process exits during or before the user performs a HasExited check.引用元:Process.EnableRaisingEvents Propertyという記述を発見しました。そして、私はこう考えたわけです。
　　「非同期で外部アプリケーションが終了するまでHasExitedを呼び続ければExitedイベントを起こせるのでは？」
ということで、実際に非同期で上のコードのように呼び出し続けてみました。
すると、成功してしまうという奇跡？が起きたわけです。
奇跡でも何でもありません。代替案1が動いた理由と同じ原理です。コメントの方からのご指摘を受けて代替案2よりか安全なコードをご提案いただきました。
そのコードは代替案2のusingブロックを以下のように書き換えますはい、代替案1のようにすればよいだけです。こちらもコメントの皆さんのご指摘ですが、今までのコードはawaitで外部アプリの終了を待っているだけなので、awaitの後にアプリ終了後に実行してほしいコードを書けばいいのではということです。
ということで、この意見を反映するために代替案2を改造して以下のようになります。では注意点を。
解決法1はまだしも、解決法2ではTaskのエラー処理をやっていないのでこのままこれらコードを使うのはやめてください。
あと何かほかにもあればコメントお願いします。ここで紹介した代替策をもってしても外部プログラムの終了を検知できない環境があると思います。
そういう方は起動したプロセスをProcess.GetProcessesで検索し続けるという究極の解決方法が考えられるので試してみてください。
ちなみに、私は最初こうしてました。コメントの皆さんのご指摘の反映です。 ↩代替案の旧コードでtask.Start()を書いていなかったのを修正。これがなかったら使用メモリが増大します。 ↩


