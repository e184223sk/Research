More than 1 year has passed since last update.ついにUnityでもIncremental Compilerを有効にすることでasync/awaitが使用することができるようになりました。
これは大変うれしいことではありますが、async/awaitが何をやっているかわからないと実行速度や効率の面で不安になるかもしれません。
そこで今回はasync/awaitが裏で何をやっているのか、async/awaitをUnityで便利に使用することができるUniRx.Asyncが裏で何をやっているのかについて解説していきます。
async/awaitの使い方や詳細についてはすでに色々記事があるとは思うのでそちらも参考にしてください。async/awaitを使用すると以下のような書き方ができます。上記のプログラムを実行すると1と表示された1秒後に2と表示されます。
このようにasync/awaitを書くと非同期処理をあたかも同期処理のように書くことができます。C#においてawaitはコンパイラでのコード生成によって実現されており、特殊なランタイムの機能を使用しているわけではありません。
これはawaitキーワードを使用しなくても自分の手でawait相当のことを記述できることを意味しています。
(厳密には無理ですが、それっぽいことができるということです。また、下記のものはコンパイラによって生成されるものとは内容が異なりますが同じような意味になります。)awaitを自分の手で記述するためには関数をawait以前、await以降に分ける必要があります。
最初の例でいうと以下のような感じです。次にawait部分です。
awaitはタスクからAwaiterを取り出し、Awaiterに対して後続の処理を依頼します。
Awaiterは自身のタスクが完了したときに渡された後続の処理を実行します。awaitで戻り値を受け取る場合もほぼ同じです。
違うのはAwaiter.GetResultの戻り値を後続に渡すようになっているくらいです。asyncもawait同様、コンパイラでのコード生成によって実現されており、特殊なランタイムの機能を使用しているわけではありません。
例によってasyncと同様の処理を自分の手で書くことができます。
asyncはすべての処理が終わった時に完了になるタスクを返す関数を作成します。
分かりにくいかもしれませんが以下のようになります。async/awaitで使用するTaskクラスは大変便利なのですが様々な問題を抱えています。
それはTaskクラスがとても複雑であること、クラスなので必ずアロケーションが発生してしまうことなどです。
普通のアプリケーションであれば絶対にどうにかしなければならないレベルではないと思いますが、
Unityにおいては使うのをためらってしまうレベルです。(個人差があります。)
この問題を解消するのがtask-likeです。
task-likeはTaskクラスっぽくふるまえる型のことを指し、task-likeであればasyncメソッドの戻り値として使用できます。
task-like型を自分で実装することでasync/awaitを使用しつつパフォーマンスにも配慮することができます。
UniRx.Asyncはこのtask-like型の実装とそれらについての便利メソッドを提供しています。UniRx.Asyncで一番基礎となるtask-likeな型です。
asyncメソッドを使うときはこのUniTaskを戻り値にすることでTaskを戻り値にするよりパフォーマンスに優れています。
ソースを見ればわかりますが、この型自体はとてもシンプルな作りになっています。
参考:UniRx/UniTask.cs at master · neuecc/UniR上記の処理でawaitしている部分で何が起きているかを見ていきます。前述の通り、awaitはAwaiterを取得してOnCompletedを呼んでいました。
UniTaskのGetAwaiterを見てみましょう。Awaiterを作って返しているだけなので、AwaiterのOnCompletedを見てみましょう。task.awaiterのOnCompletedを呼んでいるようです。
少し調べるとtask.awaiterはUniTaskのコンストラクタで渡しているIAwaiter型のインスタンスであることがわかります。よって、UniTaskをawaitしたときの処理はUniTask本体ではなくそれを作る際に使用したIAwaiterにあるといえます。
UniTask.Yieldの場合を見てみます。YieldPromiseが本体っぽいです。このクラスにはOnCompletedがないので継承先のクラスを探します。
するとReusablePromiseにOnCompletedが見つかりました。色々やっていますが、結局は渡されたアクションを内部に保持しているだけです。
なのでOnCompletedを呼んだだけでは何も起こらないことが分かります。ではawaitをしても何も起こらないかというとそうではありません。
awaitをしたときに、OnCompleted以外にもIsCompletedが呼ばれているのでした。
IsCompletedの中を見てみましょう。
IsCompletedはPlayerLoopReusablePromiseBaseの中にあります。重要なのはPlayerLoopHelper.AddActionです。
詳しくは書きませんがこれはUnityのPlayerLoopSystemを使って所定のタイミングで所定のメソッドを呼んでもらう機能です。
これによって次のフレームのUpdateのタイミングでYieldPromiseのMoveNextが呼ばれるようになります。
YieldPromiseのMoveNextを再掲します。おそらくTrySetResultの中で後続の処理が呼ばれているのだろうと予想がつきます。
ReusablePromiseを見てみます。予想通り、TrySetResultを呼ぶと最終的に継続処理が呼ばれているようです。
まとめると以下のようになります。awaitを実行したフレームではPlayerLoopHelperを使用して処理を登録する。
次のフレームでPlayerLoopHelperに登録した処理が実行される。
これによってタスクが完了扱いになりそのスレッド上で後続処理が呼ばれる。今回はYieldを見ましたがDelayなども大体同じです。
UIButtonのOnClickAsyncの用にUnityのイベントなどが元になっているものについてはPlayerLoopHelperを使用せずに、イベント登録などが使用されます。注意点としてawaitをするとPlayerLoopに登録されるということです。
PlayerLoopに登録されてしまうと、awaitを行ったときのGameObjectがDestroyされても後続処理が実行されてしまいます。上記の処理を実行したとき、Debug.Log(2)も実行されてしまいます。
回避するためには必ずCancellationTokenを渡しましょう。async/awaitは便利な機能なのでUnityでも使えるのはとてもうれしいです。
正しく理解して快適なasync/await生活を送りましょう。コンパイラが生成するasync/awaitのコードはもっと複雑です。
気になる方はAsyncMethodBuilderとかAsyncStateMachineについて調べてみたりILSpyなどのツールで生成されたコードを調べてみてください。以前書いた記事ですが、async/awaitを使えば以下のようなこともできます。
async/awaitを使って継続の力を手に入れる


