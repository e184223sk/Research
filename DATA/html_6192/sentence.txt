More than 3 years have passed since last update.C#6.0時代のUnity の続きとして、書く書く詐欺だったUnityでのTask(async~await)についてになります。
（さすがにUnity2017.1が正式リリース されたので・・。）なお、UnityでTaskを使うにあたっての事前準備はそちら を先に見てくださいまず、前提知識としてTaskってなんぞや？　という事なんですが、まんま和訳した「仕事」ってのがしっくりくると思います。
やってほしい仕事＝タスク。
スレッドと混同されがちですが、スレッドは仕事をする側で、仕事そのものでは無いんじゃないかなーと（ざっくり）そして、Task(async,await)を扱うにあたってあたりを分かった気でいる必要があります。しかし、先に言っておきたいんですがTaskは難しいです。
覚えることが多く、制約も多く、苦労して使えるようになっても、
「それコルーチン（UniRX）で出来るよね？」
「なんでそんなわざわざ面倒な方法で・・・？」
「なんだ。C#分かってますアピールか。」
と言われたりします。絶対。（偏見）なので、Unity2017でTaskが使えるようになったからって、無理してTask使わなくてもいいと思っています（特に業務・複数人でUnity使っているような環境の方は）Unity年表上ってだけ、選択肢が増えただけ。それぐらいの立ち位置がまだいいんじゃないかなぁと個人的には思います。
（とは言え時代は動き出してしまったし、TaskにはTaskの便利な使い方があるので、難しいところ。ぐぬぬ。）では。まずジャブから。Task.Delayは指定ミリ秒(もしくは指定TimeSpan)だけ待ってから完了するTaskです。例としてという課題があるとします。例えばこんな感じでさて。これでボタンをクリックすると、ログはどのような出力になるかわかりますでしょうか。これは見ての通り、Start→Count0～9→Endまで瞬にして出力されます。　全然Delayしてない。と、いうのも、Taskはそもそも非同期に実行されるものなので、Task.Delayは正しく非同期的に1秒待っているんですが、非同期が故にその次の行のLog出力にそのまま進んでしまいます。すなわちTask.Delayの完了を待つ処理が入っていないのでこうなってしまいます。
（スレッド自体を寝かせるThread.Sleepとは意味・振る舞いが違う！）「Taskの完了を待って、続きの処理を書きたい場合にはContinueWithを使うのがいいとばっちゃが言ってた。」じゃぁ、こうかな？と結果はひどいもんです。あちゃー。これはが一塊のTaskとして、10連続で呼ばれるので、1秒に1回Logが出るという事にはならず、1秒待ってから。しかもラムダ式がfor文のiをキャプチャするので、全部Count:10になってしまいます。　悪化しとるがなちがう。違うんだ。
なんで今までUnityでコルーチン使えばで、StartCoroutine(CountIterator());するだけだったのに！Taskってなんなんだよ！貴方は裏切られた気持ちでいっぱいになります（なりません）コルーチン方式で書けるんであれば、じつはasync～await方式に変えるのは簡単です。１．終了を待ちたいTaskにawaitを付ける。awaitを付けたTaskは完了待ち＋結果取り出しになります。（結果取り出しについては後述）これで、Task.Delayの終了をそこで待つので、1秒間隔でCount:0～9が表示されそうです。
まぁ、これじゃビルド通らないんですけどというのも、awaitはasync付きのメソッド(またはラムダ式)の中にしか書けないという制約があるんですね。
なので、
２．awaitを付けたからには、async をメソッド(ラムダ式)に付けるおや。簡単ですね。　これで完成！！？　いや、あともうちょっと。３. async void は良いこと無いので基本async Task に変える詳しいことはまたいつか書きますが、世の中にはasync void 警察がいて、軽い気持ちでasync voidを残しておくとすごく叱責されるので注意してください。さておき、最終形としてはボタンを押すと、ようやくCount0～9が1秒間隔で出力されました。さて。このFunc3は非同期処理っぽいですが、スレッド的にはどうなっているんでしょうか。実のところ、メインスレッド以外で処理されているのは Task.Delay(1000)だけです。
1000ミリ秒を別のスレッドで休んでるだけで、全体的にはメインスレッドで処理されています。
LogOutput処理をちょっと改造してThread.CurrentThread.ManagedThreadIdも出力してみるとよくわかります
(ついでにTask.DelayにContinueWithを使った後続処理でもLogを出力してみました。)Count:0～9はすべてThreadID:1(メインスレッドIDと同じ）で、
逆にContinueWithでの後続処理のThreadIDはすべて異なるという結果に。メインスレッドで動いているということはどういうことかというと、重い処理を走らせたら画面が止まるということです。　async付けたら非同期、メインスレッド外だと思っている人も時々いるようですが、そうではないです。
でも・・え。止まっちゃダメじゃん。　何のためのTask,非同期なのさ。では、明示的に何か処理をメインスレッド以外で動かしたいとなった場合にどうすればよいかというと、Task.Runを使うと別スレッドで（しかもスレッドプールというイカした仕組みで）動くようになります。テストのために重い処理を持ってきました。
大分昔に書いた記事ですが、
Unityでブラー画像動的生成
の、アルファチャンネルをブラー化したTexture2Dを作成する処理です。そして、このブラー処理を呼び出す処理も用意しました。ボタンをクリックすると、同じ場所に重ねてある片方のSpriteのTextureをアルファチャンネルをブラー化したテクスチャに変更するというものです。
　　↓

（オーラをまとった！！）しかしながら、これは全てメインスレッドで動いているので、僕のPC環境だとボタンを押してから２～３秒UnityEditorそのものが固まります。では。この処理を非同期(別スレッドで並列処理）できるように変更します。このブラー化する処理で明らかに重そうなのはこの、恐怖の3重ループ*2で全てのピクセルの近傍ピクセルを走査しまくっているところです。なので、この処理をTask.Runで別スレッド処理に逃がしてあげます。このTaskの終了を待たずにdstを使う後続処理を走らせるわけにはいかないので、awaitキーワードを追加します。awaitを使うからには、asyncをメソッドに付けます（2回目）asyncメソッドは戻り値がTaskにする必要があるので、Taskに。　しかもこれはもともとTexture2Dを返すメソッドなので、
Task&lt;Texture2D&gt;に変更します(あと、非同期処理にするので、メソッド名にAsync等を付けるのが一般的です。）これで、ブラー処理自体のTask化が完了しました。
もちろん、呼び出し元にも変更が必要です（メソッド名も変えちゃったし）まず、メソッド名が変わってますし、非同期処理なので、awaitで待つようにしてあげる必要があります。そしてawaitを使うにはasyncキーワードが必要になります（3回目）
しかし、これはラムダ式・・・。　どこにasyncを・・・。　となりがちですが、ラムダ式への引数の前、今回は引数無しなので()の手前でOKです。これで、呼び出し元も修正完了です。
なんとこれだけの修正でTask化され、無事UnityEditorが固まらなくなるのです！！「完了？あれ？　でもCreateBlurTextureAsyncの戻り値はTexture2DからTask&lt;Texture2D&gt;に変更してたよね？変数btexにはTask&lt;Texture2D&gt;が入っているのでは？」という当然の疑問が残りますが、これで問題はありません。これがawaitの機能。　終了を待つと同時に、Taskの結果を取り出してくれるのです。　（伏線回収)
本来、Taskから結果(T)を取得するにはTaskのResultプロパティを参照する必要があるのですが、awaitはそのResultを勝手に取り出してくれるのでした。　超便利。どうでしょう。Task化。そんな難しくないですね！？（しかし、本当の沼はこれからなのでした）さて。先ほどのCreateBlurTextureのTask化（Async化）ですが、あえてちょっとミスリードさせました。このブラー化する処理で明らかに重そうなのはこの、恐怖の3重ループ*2で全てのピクセルの近傍ピクセルを走査しまくっているところです。
...
なので、この処理をTask.Runで別スレッド処理に逃がしてあげます。はい。ここですね。
さも、「ボトルネックなのでTask.Runで別スレッドに逃がしましたよ」的な感じで書きましたが、実際にはそこぐらいしかTask.Runで逃がせられなかったのです。と、いうのも、Task.RunやTask.Delay、それらをContinueWithした後続処理なんかは、別スレッドで動いています。
そして、Unity固有の処理はメインスレッド以外からアクセスするとエラーになるという制約があります。例えばたったこの1行でアウトです。ログには
get_transform can only be called from the main thread.こんな感じで「transformはメインスレッドからしか呼ばせないよ！！」と言われちゃいます。transform取るくらい・・・って思わなくもないんですが。同じように例えばTexture2Dの横幅(Width)をTask.Runの中で取得したりすると同じく

超怒られます。なので、今回はUnityに関係ない、配列操作部分だけをTask.Runで非同期化したわけです。でも、なんとかしてTask.Run（やTask.Delayの後続タスク等）でもUnityの処理が呼びたい！！そんな時に使うのがSynchronizedContext(同期コンテキスト)です。方法は２つこれはエラーになりません。
javaのrunOnUiThread的な使い方ですね。
なお間違ってもSynchronizationContext.CurrentをTask.Runの中で取得したりしないように。　多分nullが入ってます。
そして、Postした処理は即時実行されるわけでもなく、さらにPost終了を待機できるわけでもないので要注意です。　Postなので、通知専用。　非同期処理の進捗表示ぐらいにしか使えなさそう。Task.RunやTask.Delayなんかは別スレッドで処理されているというのは既に何度も出てきてるんですが、awaitで別スレッドの結果を待って何事もなかったようにスレッドがメインスレッド（というか、await前のスレッド)に戻るのはこのawaitがTaskを呼び出した瞬間のSynchronizedContextをキャプチャしておいて、終了後、キャプチャしておいたSynchronizedContextのPostを使って後続処理を走るように上手くやっているからとかなんとか・・・（あってるのかな・・・？）なので先に自分でSetSynchronizationContextを呼んでセットしてあげれば、await後にはUnityの処理を呼んでもよいという寸法。うーん、ややこしやややこしや。どちらにせよ、Task.Runの中でUnity絡みの操作を行うのは面倒ですが・・・そのTask.Run要りますか？
今回の例ではもちろん必要ないですが、世の中には不要なTask.Runで溢れかえっている可能性が高いです。
無駄なTask.Runによるラップが無ければ、SynchronizedContextを使ったり、特別意識する必要も（そんなに）ないんじゃないかなーと。いつか書きます。
あと、ボタンのクリックを待つTaskを作る拡張メソッドだったり、それを組み合わせて
「10秒経過かその間にボタンがクリックされたら次の処理」
みたいなコルーチンでやると意外と面倒というか、状態を保持する必要がある処理があっさり書けたりするので、実例交えて紹介したかったんですが。すでにそこそこな長さになってきたので、それらも含めまたおいおい・・・。


