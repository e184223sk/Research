More than 1 year has passed since last update.最近見つけたコードでArray.Resizeを覚えたので使っていたが、List.Addとの違いや、処理効率がどうなのか気になったので調べた。可変長の配列を扱いたい場合、
Array.Resizeで1要素ずつ増やすよりは、List.AddとToArrayの組み合わせのほうが効率的。
（ここでは、最終的に余分要素のない配列[]を作りたい場合を想定している。
AddするたびにToArrayしたい場合はこの結論の限りではない。）Windows10でILSpyでソースを調べて机上で検討した。処理時間の実測はしていない。
ILSpy上の表示は C#7.3 / VS2017.7 となっている。Addメソッドが間接的にCapacityプロパティにsetアクセスして、内部のフィールド_items(T[]型)をリサイズ(new T[リサイズ後の要素数]してArray.Copy)しています。
Capacityプロパティのコードをみると、初期値は4で、リサイズするときは2倍ずつ確保しているようです。Array.Resize(ref 配列[], 新たなサイズ);
Microsoft docsサイズが変わると、増減によらずnew T[]してArray.Copyを呼んでいます。
単純にArray.Copyの計算量が要素数nに比例する（仮にnとおく）とすると、
1要素ずつResizeメソッドで要素を1からnまで増やすと、計算量は1+2+3+...+n = n*(n+1)/2となるので計算量はn^2に比例します。List.Addの場合のArray.Copyの発生コストを単純計算で考えると、1,2,4,8,16,32,...,n/4,n/2,nのときにArray.Sizeが呼ばれるので1、その和は2n-1となり、計算量はnに比例するはず（細かいことは考えていないのでちょっと怪しいが）。1要素ずつ要素数をnまで増やした場合について、単純計算で考えるとそのため、Listを使うほうが計算量的には優位と判断できる。■計算量のオーダーついての注意：
実用上のnの範囲では、単純にオーダーだけでは議論できない場合がある。2nが2の指数とし、細かいことは考えない。 ↩マージソート(n*log(n))と挿入ソート(n^2)では、nが小さい場合は挿入ソートのほうが高速とか、多項式時間の素数判定アルゴリズムは現時点の実用上の範囲では遅いとか。（話がそれますが、多項式時間で素数判定できるアルゴリズムが発表されたのは、計算量の理論においては結構有名なできごとだった気がします。） ↩


