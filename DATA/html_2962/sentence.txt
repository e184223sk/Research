本項にて説明しているよりも確実な方法があります。末尾を参照してください。Dotnetでデータベースを扱うとき、EntityFrameworkは楽チンでいいですね。
特にCode Firstは先にデータベースのテーブル設計を行わなくても、テーブルに対応するPOCOとDbContextを実装しておけば、それに合わせてテーブルを作成してくれるから楽ちん。NoSQLなくても十分やっていけるレベル。しかし、EntityFrameworkにはちょいと問題がありまして。いや、開発においては全く問題ないのですが、後々のことを考えると、ね。カラムが思ったとおりに並んでくれない!例えば、ユーザ情報を保持するUserクラスがあったとします。Userクラスはエンティティ全てに共通するカラムを保持するEntityBaseクラスを継承します。このとき、期待しているテーブルの定義は以下のようなイメージでした。
※実際には文字列長を設定したりするので、厳密にこのSQLになるわけではありません。擬似的なSQLコードと見てもらえればと思います。ですが、実際には以下のようなSQLのイメージになってしまいます。ええ、カラムがの並びがぐちゃぐちゃですね。 
プログラム視点では、DbContext経由でアクセスするのでクラス定義の通りに操作できるのであまり気になりません。
ですが、データベースの保守をしようとしたときにDBクライアント(DBeaverやA5SQL Mk2など）で見たときにはぐちゃぐちゃでたまったものではないですね。どうやったらいい感じになるのだろう、と、[Column("COLUMN_NAME", Order = 1)]といったふうなことも試してみましたが、最も確実なのは以下の方法でした。
※ColumnAttibuteクラスのOrderプロパティは、キーが複数ある場合の優先順位を指定するもので、Code-FirstでDBを生成する際のカラム順を設定するものではありません。EntityFrameworkCoreでは、dotnet efコマンドでデータベース作成コードの作成・実際のデータベース作成ができます。（.Net Framework EntityFrameworkではどうやるか分かっていないです）。このコマンドで、Migrationsディレクトリ配下に以下のファイルができます。それぞれがなんの役割なのかはよく分かっていません。詳しい人教えて！ですが、この中の&lt;&lt;タイムスタンプ&gt;&gt;\_&lt;&lt;Migration名&gt;&gt;.csのUpメソッドの中に注目です。
この中で記述されている、migrationBuilder.CreateTableメソッドの引数にcolumnsがまさにテーブルのカラム順に影響しています。
ここの順序がちぐはぐな状態になっているため、最終的なデータベースのカラムもちぐはぐになります。
ここの並びを変更することで、期待したカラムの並びに変更することができました。DbContext::OnConfiguringでテーブル構成を実装する
注脚ペースでの実装の場合、カラムの並びはEntityFrameworkCore任せに鳴ってしまいますが、DbContext::OnConfiguringの場合、実装順にテーブル項目が決定される模様。これから動的に更新されるMigrationファイルをいじる必要もなく期待したとおりのカラム順となります。というところでしょうか。


