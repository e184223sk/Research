More than 1 year has passed since last update.Androidからのタッチ信号を受け取って、Windowsネイティブのタッチにアサインする機会があったので、その時にハマった事などをまとめていきます。今回は以前の記事で書いた方法でAndroidからタッチを取得し、UDPでWindowsで待機しているアプリに送りました。
送信方法はUDPでもTCPでも、なんでも良いと思います。とりあえず今回はPCまで何らかの方法で信号が届いている前提で話を進めます。Win32のAPIに、InitializeTouchInjectionとInjectTouchInputという関数があります。
この関数を使う事で、Windowsのタッチをシミュレートすることが出来るのですが、いかんせんCなコードなので、C#で使おうと思うと扱いは結構面倒です。色々探しているうちに、NuGetで便利なラッパーライブラリを発見しました。使い方はこのStackOverflowが参考になります。CのライブラリをC#で使おうとすると、DLLから直接ネイティブな関数を呼ぶだけじゃなく、自分で必要な構造体を定義しないといけなくて中々面倒なのですが、このライブラリなら全部やってくれているので楽です。NuGetが使えるなら↑の方法で良いと思いますが、自分で定義する方法もあります。
InitializeTouchInjectionとInjectTouchInputのページで記載されている構造体を定義してdllから関数を呼び出すのですが、構造体が別の構造体を含んでいたりして、結構面倒です…僕は自分で構造体を一つ一つ作っていったのですが、それだけではうまく動かず、最終的にGitHubで公開されていたこちらのコードを参考にして、コードを修正しました。最終的に、関数と構造体の呼び出し部分は以下のようになりました。実際にハマった個所と、先人の知恵ではまらずに済んだ個所がありますが、全部挙げていきます。つまり、直前のイベントがdownなら、downした時と同じ座標が、moveなら、moveした時と同じ座標が入っていないとエラーになるようです。
ここは先人の知恵により回避できました。InjectTouchInput(int count, PointerTouchInfo[] info);とあるように、アップデート時には複数のタッチを同時にアップデートする必要があるのですが、例えば指Aと指Bがあった時に、という挙動だったとします。※の個所で、Aはまだ存在しているけど動いていない、という状況が発生していますが、InjectTouchInputを実行する時はAもアップデートする必要があります。ここは割とハマりポイントなんじゃないかなと思います。ちなみに、down状態のままアップデートすると何度もdownが飛ぶので、downではなくmoveとしてアップデートする必要があります。実際にはアプリを作る上でハマった個所はもっとあるのですが、TouchInjection関連ではこんなところかなと思います。
僕は諸事情があって自分で実装しましたが、先程も紹介したこちらのコードや、ラッパーライブラリを使えば比較的簡単に実現できると思います。先人の知恵をまとめただけになってしまいましたが、同じ事でハマっている方の助けになれば幸いです。


