LINQでよく使うクエリ演算子（WhereとかSelect、CountとかToArray）について、遅延実行と即時実行の
違いを意識して使っていかないとどこかで痛い目を見そうだと思い、簡単な備忘録を残そうと思いました。参考書籍：実戦で役立つ c#プログラミングのイディオム/定石&amp;パターンよくLINQで使うクエリ演算子の実行形態と説明
引用元：実戦で役立つ c#プログラミングのイディオム/定石&amp;パターン※上記以外のクエリ演算子については、ネットから調べるか実戦で役立つ c#プログラミングのイディオム/定石&amp;パターン
を買って見てください！遅延実行での処理を確認するために、武器の一覧をListに格納し、攻撃力が１００以上のものを表示するプログラムで
確かめていく実行結果
普通なら、Strong_WeaponsにWhereメソッドを代入した後にList：weaponsに新しい武器を追加しているので、
Strong_Weaponsの出力結果は変わらないと思うのですが、実行して確かめると２つの結果は違って表示されます。これは、実行形態が【遅延実行】であるWhereメソッドが呼び出されたその時はまだ実行されていないこと、
そしてそのデータ（Strong_Weapons）が本当に必要になった場面（Foreachで要素を取り出したとき）で
クエリが実行されていることが確認できます。クエリを明示的に実行したい場合は実行形態が【即時実行】のものを使うことで可能！↑を↓のように、【即時実行】であるToArryメソッドを呼び出すことで、その時にクエリが実行され
結果が配列に格納されるため同じ結果を得ることができる
・遅延実行：メソッドが呼び出されたタイミングでは実行されず、データが必要になったタイミングで実行される
・即時実行：呼び出されたその瞬間にクエリが実行される
・その時点で明示的にクエリを実行したい場合は即時実行のクエリ演算子を使えばいい例えばCSVのファイルを取り込んで、いろいろデータを加工しようとしたときに遅延実行・即時実行を考えずに
LINQ使っているといつかやらかしそうだと思ったので備忘録にした次第です。
その時点で明示的にクエリを実行したいのかどうかを意識しておけば大丈夫、ですかね・・・？
とりあえずわかんないけど先輩がそう書いているからTolistやToArrayしちゃえ！っていうよりかはマシになったかなと思います。


