More than 3 years have passed since last update.前回の記事「UMLとスレッド」では、
オブジェクトは自律的な性質を持っていると認識できることに触れ、
その認識に基づいてUMLのモデルを描き、実装すれば、スレッドが分かりやすくなるということを書きました。
今回は、オブジェクトのアクティブな性質を意識したUMLモデリングと、それを実装につなげる例を挙げたいと思います。以前、書いた「オブジェクト指向分析の基本的な思考法」の洗濯機の例を使おうと思いましたが、
今回は、もっと簡単な例を使って分かりやすくします。洗濯機の例は、乞うご期待とさせてください。検査技師と扇風機がいるモデルです。
どちらも、アクティブな存在です。
技師は人間で自律したオブジェクトです。
扇風機も電気で動く自律したオブジェクトです。
技師がテストを始めると、扇風機をスタートさせます。
20秒後に扇風機をストップさせます。
ただこれだけです。自律したオブジェクトにそれぞれ単一のスレッドを割り当てて動作させるために、
自作のタスクスケジューラを利用しています。
詳細は、後述＋参考サイトの紹介をしていますので、読み進めてください。コンソールアプリです。
Program.csで、インスタンスの生成と処理全体の流れを実装しています。
コード内のコメントを読んで理解してください。検査技師のクラスは、検査技師自身のスレッドで動作するようにしています。
スレッドプールではなく指定スレッドで動かすため、
TaskをRunSynchronously()させるときに、自作タスクスケジューラ（QueTaskScheduler）を使います。
QueTaskSchedulerは、Taskを単一のスレッドにキューイングさせて実行させるタスクスケジューラです。
自作なのでコードは下に載せます。
技師の処理自体は、Task( () =&gt; {} ); 内にラムダ式で書いてあります。扇風機も検査技師と同様で、
扇風機自身のスレッドで動作させるため、QueTaskSchedulerを使います。
こちらは非同期処理なので、Task.RunSynchronously()ではなく、Task.Start()を呼び出します。
Stopさせるときのキャンセレーショントークンについては、説明を「参考」に委ねます。以下は、自作のタスクスケジューラです。
以下は自作と言っても、「参考」のページを見て作成したものですので、説明はそちらをご覧ください。
扇風機をスタートして、20秒後に止まります。以上の例は、
自律的なオブジェクトである　技師　に、1つQueTaskSchedulerを割り当て、
もう一つの自律的なオブジェクトである　扇風機に、別の1つQueTaskSchedulerを割り当てています。
このようにして、現実世界のオブジェクトの「自律的である（＝独自のスレッドで動いている）という状況」を実装しています。
このようなスレッドの割当てができていると、想定外の動きになることがほぼ無くなったり、
想定外の動きをしてもデバッグしやすいのではないか、と思いませんか？
少なくとも、スレッドの動きが雲をつかむような話にはならなくなると思いませんか？Building your own task scheduler in C#
タスクスケジューラの自作について書かれています。こちらを参考にしてQueTaskSchedulerを作成しました。
英語サイトですが、ウェブブラウザの翻訳機能を使えば、ほぼ日本語として読むことができます。C# タスクのキャンセル方法
タスクのキャンセルのコードは、こちらを参考にさせて頂きました。


