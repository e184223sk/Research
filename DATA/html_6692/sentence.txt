More than 1 year has passed since last update.C#やJavaScript（ES2015）と比較しながらF#の文法を説明します。手続型の延長線上で取っ掛かりをつかむことを目的とします。関数型については深追いしません。この記事は以前開催していたF#入門のテキストを改訂したものです。この記事には姉妹編があります。F#を手っ取り早く試すために、私が常用している環境を紹介します。F#の構文は見慣れないものだと思います。この記事ではC#/JavaScriptと比較しながら構文に慣れることに重点を置きます。F#が分かりにくいと感じる原因は、主に以下の2種類ではないでしょうか。今回は前者の壁に的を絞ります。両者は完全に分離しているわけではないため、後者の領域も多少は言及します。個人的にはF#は構文が簡潔で短く書けるのが良いと思っています。触り始めの頃は関数型のことはあまり意識しませんでした。F#はC#と同様に.NET Frameworkで動く言語です。クラスを定義したり使ったりなど、基本的にはC#でできるのとほぼ同じことができます。※ これは大雑把な説明で、細かい点で違いはあります（protectedや入れ子にされた型など）。それに対してJavaScriptは出自が異なりますが、C#よりもJavaScriptで説明した方が分かりやすいケースもあるため、説明に取り入れました。※ 横幅の関係上、インデントはスペース2つとします。F#のprintf/printfnはopenも何もなくいきなり使える標準の出力用関数です。関数名の接尾辞nは"\n"と同様に New line に由来して、改行を意味します。複数の引数はコンマではなくスペースで区切ります。（詳細は次のセクションで解説します）printfはコンパイラがフォーマット文字列を認識して、引数の型をチェックします。F#では複数の引数の扱い方が二系統あり、F#ネイティブの関数と.NETのメソッドとで異なります。※ F#の2.は2.0のことで、浮動小数点数であることを示します。（後述）複数の引数はコンマではなくスペースで区切ります。コンマを付けると警告されてうまく動きません。（後述のタプルとして扱われます）括弧で囲む必要はありません。付けるとエラーになります。引数で計算や関数呼び出しを行う場合、引数としてまとめるため括弧で囲む必要があります。タプルと呼ばれる複数の値を組み合わせた型として扱われます。C#と同じスタイルで、引数はコンマで区切って括弧で囲みます。括弧を省略すると警告されてうまく動きません。.NETのメソッドでも1引数の場合は括弧が省略可能です。以後の例では、F#はネイティブの関数（printfnなど）があれば、.NETのメソッド（Console.WriteLineなど）よりも優先して使用します。F#では数値型を自動的にキャストしてくれないためsqrt(2)はエラーになります。
C#/JavaScriptから見ると不親切ですが、型推論を優先するための言語設計です。浮動小数点数型はC#とは型名が異なるため注意が必要です。倍精度が浮動小数点数の基本で、単精度がオプショナルという解釈だと思われます。LISPを知っていれば、最上位の括弧が省略されていると考えればしっくり来るかもしれません。括弧で囲んでも動きます。F#の変数はデフォルトで再代入できないという特徴があります。そのことについての説明は後に回して、まずは単純に変数を定義するケースを取り上げます。変数はletで定義します。型推論されるため、C#のvarに相当します。JavaScriptではvarは関数スコープとなるため、ES2015で追加されたブロックスコープのletに相当します。型を明示的に指定する方法もあります。JavaScriptはasm.jsで型で示します。F#では可能な限り型推論に任せるスタイルを推奨します。F#はデフォルトでは変数に入れた値は変更できません。変数と値の結び付きが強く、「代入」ではなく「束縛」と表現します。F#では=と==を書き分けずにどちらも=です。let以外の=は比較として扱われます。F#で値が変更できるようにするにはmutableを付けます。値の変更には&lt;-を使います。mutableを付けずに宣言した変数に再代入する方法はありません。複数の変数を一度に定義する書式を示します。※ C#ではvarを使うと複数の変数を一度に定義できません。F#の書式は括弧で囲めば数学に近くなり、座標の表記に似たものだと理解できます。括弧の有無で意味は変わりません。ちょっとした実験は対話的に実行した方が便利です。F# Interactive (fsi) と呼ばれるREPLがあります。Windows では fsi.exe ですが、Mono 環境では fsharpi コマンドで呼び出します。fsiではセミコロンを2つ付けると、評価されて値が表示されます。※ valは値（value）の意味です。変数の値を見るには変数名だけでOKです。itは直前に評価された値が束縛されている変数で「それ（it）」の意味です。;;を付け忘れると複数行入力として扱われます。次の行で付ければ評価されます。電卓としても使えます。letなしの=が比較になっているのを確認します。等しくないのを表すのは&lt;&gt;です。終了は#q;;と入力します。ifは構文が少し違うだけで基本的に同じです。F#はインデントでブロックが構成されるので、C#のように複文での中括弧に相当するものはありません。F#のifはそのまま三項演算子としても使えます。（ifは文ではなく式のため）F#では最後に評価された値が返されるため、処理と代入を混ぜることができます。これは慣れると便利な技です。条件分岐の結果、複数の値を代入するような処理を一気に書けます。うまくハマるととても簡潔になります。この構文が分かりにくければ、括弧を付けて考えると良いかもしれません。説明の都合上、F#は冗長な構文から先に紹介します。F#は変数の束縛と同じ構文で、関数が束縛されています。右辺の fun x -&gt; x + 1 は左辺に束縛されて名前が付くことから、単体では名前が無く、無名関数などと呼ばれます。F#の書き方は、C#のラムダ式やJavaScriptのアロー関数式に相当します。C#のFuncは冗長ですが、型推論が効かないため省略できません。ちなみにVB.NETでは匿名デリゲート型に型推論されます。※ C#では引数や戻り値の型が同じデリゲート間でもキャストできませんが、VB.NETではできることから、匿名デリゲート型に割り当てても問題がないという判断だと思われます。funを省略して引数を左辺に記述できます。通常はこちらを使います。funなしの方が便利です。最初に見せなかったのは、関数が値と同じように束縛されていることを示したかったためです。F# Interactiveで色々な書き方を動作確認します。この手の簡単な確認にREPLは便利です。※ 最後の例は関数を束縛せずにインラインで使っています。funを省略した構文では表現できません。C#でのvoidに相当するのがunitです。値としては()と表現します。ラムダ式などで書いてみます。変数（test3）と関数（test4）を比べてみます。F#では関数の戻り値を捨てると警告されます。警告を抑えるため、ignore関数で明示的に無視します。C言語でvoidにキャストする流儀に似ています。※ gccには戻り値を無視したときに警告する __attribute__((warn_unused_result)) があります。引数と関数を分離するパイプライン演算子というものがあります。ネストした引数の括弧を外してフラットに記述するのに使います。戻り値の警告を受けてignoreを追加するときに便利です。右向きのパイプライン演算子は、シェルのパイプのような感覚で関数の多重呼び出しに使えます。左向きはHaskellの$に似ていますが、連続して使うと$とは意味が変わるため（後述）、連続させるときは&lt;&lt;演算子による関数合成と併用します。&lt;|を連続して使用すると、複数の引数を個別に適用する意味となります。C#/JavaScriptでラムダ式を使わずに再帰で階乗を求めます。これをラムダ式で書きます。C#では自分自身が参照できなくなるため、一度nullで初期化するという小手先の技が必要となります。JavaScriptは参照が動的に処理されるため問題ありません。F#では自分自身を参照するために専用のrecキーワードが用意されています。※ デフォルトで再帰可能になっていないのは、同名の変数で覆い隠すシャドウイングを考慮した言語設計のようです。F#の元になったOCamlについての記事を紹介します。一般論として用語を解説します。パーサは上から下にコードを読み進めます。進行方向に沿って下が「前方」と表現されます。前方で定義されている関数にアクセス（参照）することを「前方参照」と呼びます。下の例ではtest()が前方参照されています。※ 直感的には「上が前」のように感じられるので注意が必要です。C言語の前方宣言は呼び出し元から見て「前方にある宣言」ではなく、「前方参照を可能にするための宣言」という意味だと解釈できます。F#は前方参照ができません。他の言語でもラムダ式だけで記述すると似たような状況になりますが、それと同じだと考えてください。F#に前方宣言はありません。必ず後方（上）で定義する必要があります。これは強い制限のようにも感じられますが、コードを読んだり部分的に引用したりするときは、そこより上だけを見ておけば良いという利点があります。前方宣言はありませんが、相互に再帰する場合は特別な構文があります。F#ではrecとandを使います。C#ではラムダ式を使わなければ特に問題はなく、JavaScriptでは動的に参照されるためアロー関数式でも特に意識する必要はありません。どうしても相互再帰が避けられないケースはありますが、その場合はクラスタとしてひとまとめに定義することが必要です。離して定義することはできません。C#ではクラス直下のメソッドと、メソッド内のラムダ式の書式が大きく異なります。※ C# 7ではローカル関数という機能が追加され、この制限が緩和されます。F#やJavaScriptでは関数の中でも関数が定義できます。関数型で必ず話題になるカリー化を説明します。※ とりあえずF#を使うだけなら必須というわけではありません。分かりにくければ飛ばしても構いません。必要に応じて次の記事を参照すると良いでしょう。以下の3種類はすべて同じ意味です。2と3は1の糖衣構文です。1をC#/JavaScriptに翻訳して呼び出してみます。ラムダ式がネストしています。初見では分かりにくいですが、括弧を付けてみます。JavaScriptではfunctionで記述した方が分かりやすいかもしれません。C#/JavaScriptでは引数を1つずつ渡していますが（add(1)(2)）、引数を片方だけ渡すこともできます。こうして得られた中間的な関数に残りの引数を渡すと最終的な結果が得られます。このように引数を途中まで渡して関数を得ることを部分適用と呼びます。部分適用できるように関数の中に関数を入れる形式をカリー化と呼びます。※ 部分適用が誤ってカリー化と呼ばれることがあるので注意が必要です。F#では冒頭で挙げた1～3のすべてがカリー化された関数で部分適用できます。カリー化されない関数を定義するには、引数をコンマで区切りタプルとします。引数をタプルで取る関数でもラムダ式でラップすれば擬似的に部分適用は可能です。最初の方で.NETのメソッドの呼び方がネイティブ関数とは異なると述べましたが、引数がタプルとして扱われカリー化されていないためです。C#ではサイズを指定して配列を作るとゼロで初期化されます。JavaScriptではTypedArrayで同様の処理が可能です。F#では専用の関数を使用します。初期値を指定して配列を作成する方法を示します。F#では要素の区切りはセミコロンなのに注意が必要です（コンマ区切りはタプルを意味するため）。また、F#では配列アクセスで添字の前にドットが必要です。F#では配列をスライスできます。末尾の指定方法がJavaScriptとF#では異なるのに注意します。C#では言語サポートがないため地道にコピーします。JavaScriptとF#は文字列の切り出にもスライスが使用可能です。F#にはwhileとforはありますが、continueとbreakはありません。再帰で書き直す方法を覚えておくと潰しが効きます。考え方としてはループ変数を引数に見立てて、条件を満たせば再帰的に自分を呼び出します。※ 再帰呼び出しはcontinueに相当して、明示的にcontinueを書かないとループから抜けてしまうと解釈できます。ただしcontinueと違って後続の処理が打ち切られるわけではないため、再帰呼び出しの後に処理が来ないように注意する必要があります。後に処理が来ない再帰を末尾再帰と呼びます。再帰を使わずにwhileで無理やり実装することもできます。うまく書けないときはこの手で逃げることがあるかもしれません。※ この記事では取り上げませんが、F#にはループの代用となる様々な関数が用意されており、本来そちらを使うことが推奨されます。しかしそういったものがうまく適用できないときは、最終手段としてここで説明したような方法でどうにかすることもあるでしょう。標準入力から文字列を読み取り、先頭から連続する数字だけを抜き出して表示する例を示します。C#では代入した値をそのまま評価できますが、F#ではできないため工夫が必要です。JavaScriptはNode.jsで示します。※ Windowsで標準入力読み切り型プログラムを終了させるには [Ctrl]+[Z] [Enter] と操作しますが、Node.jsでは [Ctrl]+[D] です。Node.jsでの標準入力の扱いは次の記事を参考にしました。F#ではmutableの親戚のような参照という型があります。参照はrefというキーワードを指定するとその場でインスタンスが作られます。※ C#で引数を参照で渡すためのrefとは別物です。値へのアクセスはプロパティによる方法と演算子による方法があります。演算子の方がよく使われます。! は参照剥がし（デリファレンス）演算子で、C#の否定演算子とは無関係です。参照への代入は := です。C#よりもC++で説明した方が分かりやすいかもしれません。比較の都合上、C++は参照ではなくポインタで示します。C#でもポインタは使えますが、1要素の配列で表現する方が簡単なのでその方法で示します。※ C++でも *b = 2; は b[0] = 2; に書き換えられます。関数内関数から外のローカル変数にアクセスできます。これをレキシカルスコープと呼んで、変数への参照をキャプチャと表現します。キャプチャを伴った関数をクロージャと呼びます。上の例ではC#やJavaScriptでは値が変更可能な変数をキャプチャしていますが、F#ではmutableな変数はキャプチャできません。Javaでもラムダ式（匿名クラス）からfinalを指定した変数しか参照できないのと似ています。※ Java 8では初期化以外で値を触らなければ事実上のfinalとしてコンパイルが通ります。下のコードでは意図的にiの値を変更しています。F#では参照で回避します。Javaではfinalを付け、中身を変更可能にするため配列で包む回避策があります。ローカルのmutable変数はスタックに確保されるのに対し、参照の実体はヒープに確保されます。スタックに確保された変数はスコープアウト時に破棄されます。しかしクロージャにキャプチャされた変数の寿命はスコープに縛られないため、参照によりヒープに確保して解放はGCに任せることで、スコープアウト問題を回避しています。C#ではキャプチャされる変数はコンパイラが自動的に扱い方を変えるためこの制限がありません。F#では敢えてエラーにしていると思われます。F#とC#で構文がかなり違いますが、protectedや入れ子にされた型がない以外はほぼ同じことが表現できます。JavaScriptは色々な書き方ができますが、ここではF#との対比の都合上classを使わない古い書き方で示します。※ JavaScriptはfunctionとアロー記法ではthisの扱いが異なります。メソッド内でthisを使う場合はfunctionを使用します。F#でアクセス制御を省略したときのデフォルトは、letがprivate、memberがpublicとなります。type名の後の()はコンストラクタの引数を表しています。JavaScriptは関数の引数がそのままコンストラクタの引数として使われていて、F#と書き方が似ていることに注目してください。F#ではインスタンス生成にnewは不要です。IDisposableを実装したクラスではnewを付けないと警告されますが、それ以外ではnewを付けると警告されます。※ IDisposableかどうか毎回調べると面倒なので、個人的にはデフォルトで省略して、警告されたら付けるという運用をしています。コンストラクタで引数を処理する例を示します。JavaScriptで引数をそのままキャプチャしているのに注目してください（thisを使用しないためアロー記法）。クロージャをクラスの代わりに使って比較してみます。F#は一旦参照で受けるため冗長になっていますが、C#やJavaScriptはその必要がないため単純です。JavaScriptとF#はクラスの書き方とよく似ているのに注目してください。数字と足し算のAST（抽象構文木）の例を示します。JavaScriptは継承ではなくダックタイピングで実装します。F#には多態を簡潔に表現する判別共用体というものがあります。クラスごとの評価関数を個別にオーバーライドするのではなく、一箇所にまとめて書くスタイルです。判別共用体がうまくハマるパターンではものすごく簡潔になります。JavaScriptで雰囲気を真似た例を示します。C#では冗長になるため省略します。今回と同じような視点の記事を紹介します。この記事の元になった記事です。C#的なオブジェクト指向構文を中心にまとめています。限定された範囲内でC#をF#に変換するトランスレータです。JavaScriptで実装されているため、ブラウザ上で動きます。C#とF#との対比記事です。引用されているF# Tutorialはプロジェクト作成のときに選択できます。


