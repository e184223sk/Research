More than 1 year has passed since last update.C#はstructを使用するとスタック領域に確保されるのでヒープ領域からメモリアロケーションを避けることができます。ただし、structにインターフェースを実装したうえでそのインターフェースのオブジェクトとして扱うとメモリアロケーションが発生してしまいます。これを回避するためにはメソッドをジェネリックなものに変更する必要があります。メソッドをジェネリックなものに変更すると型引数を明示的に指定しなければならなくなります。
これは引数にTStoreしか現れておらずTの型が分からないためです。
(理論的にはわかる気もしますがこの記事を書いている時点では無理でした。)今回書いたサンプルでは型引数がintなのでまだ書けないこともないですが、以下のような場合は真面目に書いていられません。これは極端な例ですがすべてをstructで済ませつつアロケーションを回避するためにはこんなことになってしまいます。
できればこんな型引数は書きたくないものです。
こんなことになるのは引数からTを推論できないからなので引数から推論できるようにすると書かなくてもよくなります。
ただしTを引数に入れてしまうとスタックを多く消費する、そもそもT型の値をどうやって取得するのか、という問題があります。そういう場合は型情報を提供するためだけのstructを用意します。これを引数にします。複数の型パラメータを持つメソッドを作る場合も同様です。ちなみに最後のメソッドの型引数は以下のようになります。
(スクロールがあるので全部見えていません。)おすすめはしません。
素直にインターフェースとして扱ったほうが便利だとおもいます。
ふと思いついたので記事にしました。


