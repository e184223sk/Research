More than 1 year has passed since last update.Case1とCase2でどっちが早いのか試してみたそしたら、Case2の方が速かった。
これがちょっと予想外だった。
で、ついでに言うなら次回以降のネタだけど、これがコーナーケースだった。下記のような簡単なベンチマークプログラムを組んで試してみた。なおベンチマークフレームワークは安心と信頼のBenchmarkDotnetを使った。で、その結果が下記の通り5.5倍くらいUseClosureの方が速くなっている。これが個人的に予想外だった。なんでこの結果が自分にとって予想外だったのかというと、上記メソッドを各々展開するとわかる。Case1の場合、割と単純に以下のようにコンパイラはローカル関数を展開する1ローカル関数がエンクロージャの変数/引数をキャプチャしてないので別々の関数呼び出しとして処理される。Case2の場合は、コンパイラはローカル関数を下記のように展開する。ローカル関数内で、エンクロージャの引数をキャプチャしているので、コンパイラが作成したPlaceFolderに格納された上で、その構造体の参照を変数として渡す形になっている。このように、Case1とCase2を比較すると、Case1の方が、やっていることが単純だし、余計なこともしていないので、高いパフォーマンスを出せるのではないかと予想していた。実際には、余計なことをしているCase2の方が先の通り5.5倍くらい速くてなぜそんなことが起きてしまったのか気になったので、沼に会えてハマってみたら、なんとなく説明できそうになったのと、割とこれがコーナケースだった。また、逆アセンブリの結果の考察において、語彙が揺らいでいたり不正確な可能性があるので、その点はご指摘ください。では最初に、Case1をばらしてみる。で、先の検証の通り、C#のコンパイラは上記のように展開するので、単純化して、ばらす対象として下記のようなコードを書いた。で、こいつのReleaseBuildを実行した際の、逆アセンブラが下記ここから、取得した逆アセンブリの結果を検証してくけど、行数指定は下4桁とするのでご了承の程さて、上記コードの1930～195EまでがMainメソッド+GetDistanceメソッドになる。これは、GetDistanceメソッドは極めて単純なので、Inliningされて、Mainメソッドの中に展開されちまっているから。で、1930～195Eまでが、GetDistメソッドの中身になっている。このセクションは、GetDistメソッドを呼ぶまでの仕込み担っている。抜粋するとと言う流れになる。で、こっちはGetDistの処理。こっちも抜粋するととなる。その後、Console.WriteLineの処理になるけど個々じゃ関係ないので省略。rcxレジスタに32bit整数をパッキングして格納した上でcallしてるのがちょっとびっくりしたけど、元のコード通り、ValueTupleを値渡ししていることになる。それでは次にCase2をばらしてみる。Case1同様、意味を壊さないようにしながら単純化して下記のようなコードをこさえたで、こいつの逆アセンブリの結果は下記の通り。で、こいつも、1930～196Aまでが、Mainメソッドと、Case2.GetDistanceメソッドの処理となり、1980～19A4がCase2.GetDistの処理となっている。ここは、先のCase1と同様、GetDist呼び出すための仕込みとなってる。抜粋して何をしてるのか見てみると、と言う流れになる。こちらも抜粋してみてみるこちらは、Case1とは異なり、参照情報を引数にしてGetDistを呼び出していることになる。ここまで、Case1とCase2が中で何をやっているのかざっくりと検証してみた。Case1では、ValutTupleがecx及びeaxにロードされて、スタックフレームに展開されて、それをまとめてrcxに積み込んでGetDistを呼び出す。呼び出されたGetDistはrcxをスタックフレームに展開して、それをeaxとedxにロードして整数演算を行っている。Case2ではecx及びeaxにロードされて、スタックに展開されるところまでは一緒だけど、rcxには元フレームのアドレスをロードしてGetDistを呼び出す。呼び出されたGetDistはrcxに入ってるアドレスを元にeaxとedxに値をロードして整数演算を行っている。このことから、Case1では値渡しのためにメモリとレジスタのやりとりにひして、Case2では元フレームに展開されたデータをGetDistでも使えるのでこの辺が速度に差が出る原因になっているような気がする。とは言え、疑問は結構残っている。レジスタとメモリのやりとりをざくっと数えた結果はこのようになり、さして差は無い。けれど、実行結果に結構差が出ている。なので、Case2で、rdxへの操作が何か必要以上に複雑なことになっているので、この辺がもしかするとまとまってxor rdx,rdxになっているのかなと推測したりも出来るけど2、いつもどおり、実際の所はわからなかった。次回以降のネタになるけど、これはコーナーケースで、例えば、(long x,long y)とかになると、完全に様相がことなることになる。この辺は次回以降と言うことで。但し、コンパイラの命名則はあれなので、名前だけは変えてある ↩そう考えないと、手数が多い方が速くなる理屈が成り立たない ↩


