More than 1 year has passed since last update.gRPC の標準シリアライザは Protocol Buffers です。Grpc.Tools を使えば proto ファイルからソースコードを生成することができるのですが、この Grpc.Tools で生成される C# メッセージクラスの実装には癖があります。RPC メソッド呼び出しに限定して使うのであればよいかもしれませんが、アプリケーションロジックで使うにはやや難があると感じる点を挙げてみます。Grpc.Tools 1.16.0 を使ってこのような proto ファイルから C# ソースコードを生成しました。Protobuf の string フィールドは C# では System.String 型のプロパティとして定義されますが、そのプロパティの setter には null を許可しないアサーションが組み込まれます。プロパティに null を設定すると、ArgumentNullException がスローされます。Protobuf の bytes フィールドは C# では Google.Protobuf.ByteString 型のプロパティとして定義されます。この場合も String 型と同様のアサーションが組み込まれます。残念ながら Putorobuf では日付を意味するスカラー型はサポートされていません。Protobuf の公式リポジトリには google.protobuf.Timestamp という日付型があります。これを使用すると C# では Google.Protobuf.WellKnownTypes.Timestamp 型のプロパティとして定義されるのですが、この型は値型ではなく参照型です。参照型であると理解した上で利用するのであればよいのですが、やや危険な感じがします。Nullable に相当する値型はサポートされていません。次のようなメッセージを定義すれば見た目だけは Nullable のような型を作ることはできますが、これも値型ではなく参照型になります。 proto ファイルに記述した Message はクラスとして定義されますが、Equals や GetHashCode などのメソッドには一般的な値型に近い内容が実装されています。Grpc.Tools で生成される C# ソースコードの解説 にも書いている内容です。一般的な値型の実装に近い内容でオーバーライドされています。ValueEquals メソッドのような名前で実装されていてほしい内容です。オーバーロードされていません。そのため、Equals メソッドとは異なる挙動になります。一般的な値型の実装に近い内容でオーバーライドされています。いずれの方法も現実味は薄いです。ProtoBuf モデルクラスを内包するラッパーを定義し、アプリケーションロジックからはラッパーを介してアクセスするようにします。全てのプロパティに対するアクセス手段を実装する必要があり、ラッパーのソースコードを自動生成する仕組みを用意する必要があると思います。ProtoBuf を採用するメリットの一つに proto ファイルからのソースコード自動生成があると思いますが、さらに自動生成の仕組みが必要になるというのは本末転倒な気がします。アプリケーションロジックからアクセスするメンバをインターフェースとして定義し、ProtoBuf モデルクラスに実装します。アプリケーションロジックからはインターフェースを介してアクセスするようにします。ラッパークラスに比べれば実装量は減るものの、これもソースコードを自動生成する仕組みを用意する必要があると思います。実体は ProtoBuf モデルクラスそのものですので、ProtoBuf モデルクラスにキャストされて直接アクセスされる可能性も考慮する必要があります。ProtoBuf モデルクラスの利用を RPC メソッド呼び出しに限定します。アプリケーションロジックで使用するモデルクラスは別途定義し、RPC メソッドを呼び出すときに ProtoBuf モデルクラスと値を受け渡します。アプリケーションロジックから ProtoBuf モデルクラスの存在が見えると誤用や意図しない場面での利用が発生しますので、RPC メソッドをラップしたほうが安全と言えます。モデルクラスに加えてラッパーメソッドも実装しなくてはならず、実装量はかなり多くなります。以上の点から、proto ファイルから生成されたモデルクラスをアプリケーションロジックで積極的に利用するのは、私は難しいと思います。異なる言語間でデータのやり取りを行わなければならず、proto ファイルによる IDL 共有が有効であるシナリオに限って使うことになりそうです。
ソースコードを自動生成する仕組みが必要であるなら、ProtoBuf にこだわる必要はありません。


