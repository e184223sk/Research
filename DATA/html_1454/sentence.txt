More than 1 year has passed since last update.本記事は、私が最近ハマった罠について調べたものです。
クロージャについて面白いことが分かったので、ちょっと記事にしてみました。ラムダ式の変数束縛に注意しよう！以下のGitHubに置いてあります。以下のように、for文でTaskを生成したところ、結果がおかしくなります。本来なら1 〜 10が表示されてほしかったのですが、うまくいきませんでした。理由は単純なことで、for文のカウンターをラムダ式が直接束縛しているからです。このため、Taskが生成されたタイミングではなく、Taskのスレッドが走ったタイミングにおけるiの値が返されてしまっています。なるほど、iの変数が複数のスレッドで使いまわされているのね。iはint型なので、「値型」です。値型なので、異なるコンテキストから値を変更することは基本的にはできません。ラムダ式の束縛って、どうやって実現されているんでしょうか？まず、以下のようなコードを書いてみました。束縛されたiが、ちゃんとインクリメントされていますね。このコードのIL（中間言語）を解析してみました。すると、以下のコードと大体等価であることが分かりました。ふむふむ、束縛って変数のポインタを使っているのかと思っていましたが、単純にフィールドへの代入と書き戻しによって実現されていたんですね。最初の例で使用していたyieldは、どのようなコードに変換されるか見てみましょう。まずは元のコードです。これは、次のコードと大体等価です。以上のように、MoveNextをステートマシンでうまく作っていますね。これは、次のコードと大体等価です。これは、おかしくなって当然ですね。これは、次のコードと大体等価です。ローカル変数を導入した途端、クロージャの初期化位置が変化しました。これは私の予想でしかないのですが、おそらく、変数のコンテキストがfor文に対してグローバルかローカルかによって、クロージャを使いまわせるかどうかが変わってくるためでしょう。クロージャの内部の動きを見てみました。ラムダ式は、束縛変数のポインタを保持しているわけではなく、クロージャのクラスのフィールド変数に書き込み/書き戻しをしていました。これは、私の直感とはだいぶ異なる動作だと感じました。以上、ありがとうございました。


