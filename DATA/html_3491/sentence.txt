More than 1 year has passed since last update.画面に一度に大量のオブジェクトを出す時、Instantiate()とDestroy()を使ってインスタンスの生成と破棄を行うと重いらしいので、そういう時は事前にある程度のオブジェクトをいくつか生成しておいて、それを使いまわすという方法が良いとのことらしいです。
なので今回はオブジェクトプーリングの概要がわかったので実際に作ってみました。ランチャーについてるスクリプトです。
Start関数で配列にBulletインスタンスを格納してます。
ついでにランチャーの子オブジェクトにしてます。
今回は円形弾幕を10フレームに一発出す感じで、弾幕の弾は144方向に放ちます。//弾インスタンスからスクリプト取得
のコメントアウトの下にあるpoolBullet関数が、
今回のInstantiate()の代わりです。poolBullet関数です。GameObject型？っていっていいのかわかりませんが、戻り値でGameObjectを返します。
for文でプールしてるオブジェクトのアクティブ、非アクティブを確認し、非アクティブなオブジェクトがあれば、そのオブジェクトをアクティブにして返します。Obj_No変数についてですが、ループを抜け出す前に何番のオブジェクトをアクティブにしたのか記録する役目を持ちます。"-1"が入っているのは下のif文に入るためです。if文はObj_Noが"-1"、つまり非アクティブなオブジェクトが見つからずループを抜けてきた場合に入ります。こちらはInstantiate()で足りない弾インスタンスを生成して配列に格納しています。Instantiate()で生成してたときはStart関数が必ず呼び出されるので、そこで加速度を与えていましたが、今回のやり方だと毎回Start関数を呼び出せないので、これまでの加速度を与えてた処理がUpdate関数の中に移動してます。アクティブになる時に一度だけ入るようになってます。Object_false関数について
今回の弾インスタンスの削除(非アクティブ)になる条件はランチャーとの距離にしてます。また、非アクティブになる前に再びランチャーの場所から弾が出るよう座標もリセットしてます。ちなみに、OnEnable()、OnDisable()というアクティブ、非アクティブになった時に入る関数があるのでそちらを使おうと思ったのですが、うまくいかなかったのでこの形になってます。今回のオブジェクトプーリングで円形弾幕
FPSはGameウィンドウのStatus表示で見てみました。
大体高くて63FPS～低くて42FPSぐらいみたいです。
こちらはまったく同じ弾幕に対して、
生成と破棄をInstantiate()とDestroy()を使ってやってみました。
オブジェクトプーリングと比較して60FPSを越えることはなく、50FPSを切ることがやや多いです。
なかなか、こういう弾幕系のものに対してのオブジェクトプーリングがなかったので作成してみました。何かしら役に立ちそうなところがあれば幸いです。
オブジェクトプーリング初めて作ってみましたが、なんともいえないできになってしまいました。
使ってないものと比べてもっと劇的に処理の差が出るかと思ったのですが、比較の仕方が悪い可能性もあります。というか今の仕様だと使える弾インスタンスを探すために上から順に探して言ってるので、あそこをどうにかすればもう少し軽くなるかもしれません。
今回は配列に弾インスタンスを格納してプールしてますが、C#にはListなる機能があるらしく、読んでみた限りそちらを使えばループ処理をせずとも、プールから使えるオブジェクトを探してこれる感じがしてます。改良の余地ありです。


