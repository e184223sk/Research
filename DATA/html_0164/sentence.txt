Apache Kafka を使った簡単な Pub/Sub メッセージングを実装してみます。Docker を使用して Kafka の動作環境を構築することにしました。2020/12/31 時点のバージョンは ver 2.6.0 です。docker-compose.yml を作成します。docker-compose.yml が格納されているフォルダで powershell コンソールを開き、次のコマンドを実行します。正常に起動できたかどうかは次のコマンドで確認できます。docker-compose.yml が格納されているフォルダで powershell コンソールを開き、次のコマンドを実行します。docker desktop のダッシュボードで Kafka の状態を確認します。正常に起動できている場合、次のようなログが表示されているはずです。CLIを開きます。Kafka のインスタンスページのアイコンから起動することができます。登録されているトピックの一覧を表示するには、次のコマンドを実行します。トピックが存在しない場合は何も表示されません。ここでトピックを登録するには、次のコマンドを実行します。.NET Core 3.1 コンソールアプリケーションとして実装します。
Kafka ライブラリには Confluent.Kafka ver 1.5.3 を使用しました。完全なソースコードは GitHub にアップロードしてあります。次のキーとメッセージをアプリケーション間で連携します。Kafka に対して一定間隔でメッセージを発行するコンソールアプリケーションです。
発行先のブートストラップサーバーとトピックはコンソール入力から受け取ります。シンプルなファクトリーパターンを採用しました。パブリッシャーは Kafka に対するプロデューサー（IProducer&lt;TKey, TMessage&gt;）を内包し、指定されたメッセージを Kafka に送信します。Kafka からメッセージを購読するコンソールアプリケーションです。
購読先のブートストラップサーバーとトピックはコンソール入力から受け取ります。
ReactiveExtensions（System.Reactive）を使用した observable パターンを採用しました。シンプルなファクトリーパターンを採用しました。サブスクライバーは Kafka に対するコンシューマー（IConsumer&lt;TKey, TMessage&gt;）を内包し、指定されたトピックに対して発行されたメッセージを Kafka から受信します。パブリッシャーとサブスクライバーを多重起動し、どのようにメッセージの送受信が行われるかを確認します。ログに出力されている "[Topic-A:0]" は、トピックとそのトピックのオフセット値（メッセージを発行するたびにインクリメントされる連番）を表しています。二つのプロセスから Tobic-B に対してメッセージを発行しています。オフセット値が重複することなくインクリメントされていることがわかります。コンシューマーグループ Group1 で Topic-A のメッセージを購読するプロセスを二つ起動すると、何れか一つのみがメッセージを受け取ります。メッセージを受け取っていたサブスクライバーを停止させると、他方のサブスクライバーがメッセージを受け取るようになります。コンシューマーグループが異なれば全てのメッセージを受け取ります。Topic-B には二つのプロセスからメッセージが発行されています。発行された順番で受け取ることができています。サブスクライバーが存在しない間に発行されたメッセージを受信できることを確認します。前述の検証から Kafuka のインスタンスを稼働させ続けているため、Topic-A のオフセット値は 20 から始まっています。サブスクライバーの起動直後、Kafka に保持されている未購読のメッセージ（20, 21）がまとめて受信されています。サブスクライバーの起動直後、Kafka に保持されている未購読のメッセージ（25, 26, 27, 28）がまとめて受信されています。簡単に Pub/Sub を実装することができました。
プロダクトで利用するには足りない機能がありますが、パーティションやレプリカの動作検証に使おうと考えています。


