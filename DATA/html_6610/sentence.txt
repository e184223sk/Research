More than 3 years have passed since last update.　ファイル読み込み処理を例に、長い繰り返し処理を複数のメソッドに分割する方法を説明します。
　「yield return」の説明が主なので拡張メソッドやLinqの話はあまりでてきません。ご容赦ください。　上記コードを元にリファクタリングをしていきます。このコードはテキストファイルを一行づつ読み込み、読み込んだ行ごとに何らかの処理を行なうプログラムです。InfoPrinterは何らかの処理を表すために作った架空のクラスです。
　この程度ではリファクタリングは必要ではないのでは？と思われるかもしれませんが、現実のプログラムではもっと複雑なことが行われており、これはそれを単純化しただけのものだとお考えください。
　While文の中ではファイル読み込み、フィルタリング、一行ごとの処理の3種類のことを行っています。私は一つの繰り返し文の中では一つのことだけをやらせたいのでまずこの繰り返し文を3つに分割したいと思います。　最初のwhile文を3分割するとこのようなコードとなります。リファクタリング前と違いファイルをすべて読み込んでから処理するようになりました。「ファイルサイズが10ギガあったらどうするんだ？」と思われるかもしれませんがメモリ管理のことはいったん忘れてください、後述します。
　ここではWhile文とforeach文を用いていますが、最初の繰り返し文はなんでも構いません。2つ目以降の繰り返し文はforeachを用いたほうが後々楽になります。　つづけてメソッド抽出を行います。ここで重要なのはメソッドの戻り値にIEnumerable&lt;string&gt;を用いること、リストの各要素を返す際にyield return 変数;と書くこと、の2つです。詳しい文法はMSDNのリファレンスに書いてあります。yield (C# リファレンス)
https://msdn.microsoft.com/ja-jp/library/9k7k7cf0.aspx　メソッドの引数としてIEnumerable&lt;string&gt;を持つ場合、foreachループを用いて要素を取り出す必要があります。
　戻り値として要素を返す際に、返したくない要素がある場合はcontinue;を、メソッドを途中で中断したいときはyield break;を用います。
　　10MBのテキストファイルを処理した後のプロセスメモリ使用量を測定しました。　"リファクタリング途中のプログラム"は読み込んだすべての文字列を一旦メモリ上に置くだけあって、メモリ使用量が多いことがわかります。一方"リファクタリング後のプログラム"はそれほどメモリ使用量が多くありません。何故でしょうか？
　yeid return が実行されると一度処理が中断され次のメソッドに処理が移ります。再び中断されたメソッドが呼び出された場合は最後に実行されたyeid returnの次の行から再開されます。そのため、今回のCreateSequenceメソッドは実行されてもテキストファイル全てがメモリに格納されるわけではありません。一要素づつ処理が行われ、処理順序がリファクタリング前とほとんど同じになります。
　またCreateSequenceメソッド呼び出し時はファイル読み込み処理が行われず、実際の処理が行われるのはPrintForAllメソッド呼び出し時です。呼び出しはforeachループでIEnumerable&lt;string&gt;が参照されたときに発生します。　何回も終端部分に当たる処理を呼び出す場合は、途中結果をメモリ上にキャッシュしておいたほうが良い場合もあります。例えば以下のようにPrintForAllを呼び出す場合、CreateSequenceメソッド、StrFilterメソッドはそれぞれ5回実行されます。これを防ぐには、StrFilterメソッドでyeid returnを使わずにただのListにして返す、LinqのToListメソッドを用いる、System.InteractiveというパッケージのMemoizeメソッドを用いると言った方法が考えられます。　これでメモリの制約が発生しそうな状況でも繰り返し文のメソッド分割ができるようになりました。
　言わずもがなですがLinqと組み合わせることでさらに処理を簡単に書けそうですね。　IEnumerable&lt;T&gt;を返すメソッドは繰り返し文を含んでいなくても構いません。例えば以下のようなメソッドでも大丈夫です。このメソッドは1回目の呼び出しの際にストリームのオープンを行い、3回目の呼び出しの際にストリームのクローズをして終了します。


