More than 1 year has passed since last update.C#の Spracheというパーサーコンビネータライブラリの紹介記事です。C#のパーサーコンビネータライブラリです。Spracheを使うとパーサーコンビネータ方式で簡単にパーサーを作ることができます。今回はSpracheを使ってML風言語のパーサーを実際に作ってみました。今回実装したソースコードはこちらです。
ちなみにSpracheという単語は「ことば」を意味するドイツ語で、ʃpʁaːxə（シュプラーヘ/シュプラーハ）と読みます。文字列を受け取って構文解析した結果を返すプログラムです。
たとえば、1+x*3 という５文字の文字列を受け取り、 トップ... +
トップ左... 定数1
トップ右... *
トップ右の*の左...変数x
トップ右の*の右...定数3といったような分析をします。パースすべき式の仕様が大きくなるにつれて、式全体をパースするパーサーを書くことは困難になっていきます。そこで、大きなパーサーを作る手法として、小さなパーサーを組み合わせて作るパーサーコンビネータという仕組みがあります。整数をパースするパーサーIntParserと、booleanをパースするパーサーBoolParserと、変数をパースするVarParserが書けているとします。Spracheにおいて、パーサーの型はParser&lt;T&gt;です。Parse&lt;T&gt;型のパーサーは、文字列を受け取ってそれをパースした結果のT型の値を返すParseメソッドを備えています。
今、整数定数かbool定数か変数のいずれかが起こりうる式Primaryが定義されているとします。PrimaryのパーサーはIntParser, BoolParser, VarParserを使って次のように書けます。さらに、この Primaryを踏まえてexprが次の用に定義されているとします。このexprのパーサーは、先ほど定義したPrimaryParserを用いて次のように書けます。このように、より小さい単位のパーサーを組み合わせてより大きい単位のパーサーを作れる仕組みがパーサーコンビネータです。試しにSpracheを使って自作ML言語風トイ言語、YuchiKaml のインタプリタを作ってみました。YuchiKamlの式は以下のBNFで定義します。上のxは変数を、nは整数を表します。文法の詳細はこの記事の本質ではないのでここでは詳しく語りませんが、気になる人のためにこちらのpdfに文法の詳細を記しました。YuchiKamlの式をC#でどう表現しましょう？
式は式でも、その実はbool定数であったり、整数定数であったり、式+式、式-式の形であったり、 様々です。この色々な形をひっくるめて式として扱うために、継承を使います。
まず、式全体を表す抽象クラスExprを定義します。次に、それぞれの形をExprの子クラスとして定義します。これで様々な形を式として扱えるようになりました。
式全体の定義はこちらにあります。ソースコード中では、プリティプリントの関係や二項演算子の定義の共通化などの関係で、上に示した形と少し形が異なっています。Spracheを使ってパーサーを作ります。SpracheのAPIと実装はここから確認できます。
整数定数をパースするパーサーを例に取ります。まず、クエリ構文一行目のinの右側を解説します。
上に出てくるParse.Digitは、0から9の数字一文字を得るパーサーです。
その他の拡張メソッドは、引数のパーサーから別のパーサーを作るメソッドです。すなわち、上の例のfromの右側のパーサーは以下のようなパーサーになります。クエリ構文from t in Pでは、tはパーサーPのパース結果を表しています。
すなわち、以下のdigitsは数字列を表す文字列です。この次の行のでは、digitsをint型に変換し、 更に new CInt()で 整数定数を表す式に変換したものをselectしています。
クエリ式全体では、CInt型の値を得るパーサー、Parser&lt;CInt&gt;になっています。
CIntはExprの子クラスなので、Parser&lt;CInt&gt;型の値はParser&lt;Expr&gt;型の変数 IntParserに格納できます。式全体をパースするパーサーMainParserを定義したとき、
(e)を読むパーサーは次のように書けます。開きカッコと閉じカッコを読まれはするものの無視され、単純に中身の式を結果とするパーサーになっています。補助関数BinOpParserを定義し、以下のようにパーサーを作成しました。
Expr.Fooは引数を２つ受け取りFoo型の式を作る関数です。補助関数BinOpParserは演算子の優先順位に気を付けつつ、左再帰除去をしつつ、二項演算子たちのパーサーをまとめて構築する関数です。
まず、同一優先順位の演算子たちについて左再帰除去をしたパーサーを組み立てる補助関数BinOpParserを定義します。上の補助関数BinOpParserをオーバーロードし、複数の優先順位の演算子に対応した補助関数BinOpParserを定義します。これを用いて、左結合の二項演算子のパーサーをまとめて定義しています。
補助関数を用いることによりボイラープレートを減らせています。今回のパーサーにインタプリタ＋数個の組み込み関数を組み合わせ以下のようなコードが実行できるようになりました。gcdは２数の最大公約数を求める関数です。競技プログラミングのコンテスト、第114回AtCoder Beginer's ContestのA問題の解答プログラムです。競技プログラミングのコンテスト、第114回AtCoder Beginer's ContestのB問題の解答プログラムです。Spracheは今回初めて使ったのですが、非常に直感的で使いやすかったです。
みなさんもぜひ使ってみてください。他にもSpracheの紹介をしている記事はいくつかありますので紹介いたします。C#のパーサコンビネータライブラリSpracheを使ってみるSpracheを使ったパーサー開発の流れがよくわかる記事です。Spracheでコメントを飛ばしてパースしてみるコメントの読み飛ばしもしてくれるToken関数を作成しています。
SpracheにはCommentParserもあるので、この記事の手法と組み合わせればかなり楽にコメントを扱えそうです。例のキヨシチェックを Sprache で書いてみるズン・ズン・ズン・ズン・ドコの並びを検知する遊びが流行った頃の記事のようです。
ズンとドコの並びをパーサーで検出する面白い記事です。Sprache 使って Parser 書いたけどすごく戸惑ったって話そう！Spracheの公式サンプルって結構読むのが難しいんですよ！
こちらの記事では公式サンプルにわかりやすいコメントを入れてくださっています。よろしかったら是非いいねを押してくださいませ！


