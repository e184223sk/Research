そんな超便利なのにあまり知られていないパラメトリック曲線こと「κ-Curves」。
Adobe ResearchとテキサスA&amp;M大学のYan氏らがSIGGRAPH 2017で発表した研究で、Adobe Illustratorに実装されており、Adobeが特許を取っています（無断の商用利用はNG）。
新しめなせいか、検索しても情報があまり出てきません。
この論文と同じ流れを、前提知識や行間を補いつつ日本語で追っていきます。C#で実際に実装もしていきます。
論文に忠実に実装するとちょっとバグるので、それについても少し。※本記事では、上記論文から一部画像や式を引用しています。
これは論文から引用した図で、他の様々なパラメトリック曲線とκ-Curvesの比較。
左から順に、Interpolatory subdivision curve, Catmull-Romスプライン、Cubic B-スプライン、κ-Curvesです。WebGL(JavaScript)で実装したものをGlitchに公開しました。注意：簡単のため、本記事ではxy平面上の曲線のみを考えます。
高校レベルの数学＋行列の基礎知識で理解できる内容のはずです。パラメトリック曲線とは、X座標、Y座標がそれぞれパラメータ$t$によって決まる曲線です。世の中には様々なパラメトリック曲線があります。いくつか雑に紹介すると、と、他にもいろいろありますが、とにかくどれもこれも融通が効きません。
イラストソフトなどでポチポチクリックした場所をいい感じになめらかに繋いで曲線を作ってほしい場合、どれも力不足。κ-Curvesは、曲率を制御することでこれを実現します。
※ベースはベジェ曲線なので、ベジェ曲線以外のことは忘れて大丈夫です。κ-Curvesは、「ユーザー制御点の曲率の絶対値が極大になる」という特徴を持つ曲線です。
曲率（Curvature）とは、曲線上のある点の周りの微小区間を円弧に近似したときの円の半径の逆数（符号付き1）です。
要は、曲線上のある点の周囲がいかに急カーブかを示す値ですね。絶対値が大きいほど急になります。具体的には、2Dパラメトリック曲線においては以下の式で表される値です。軽く導出しておきましょう。
平面曲線$f:\mathbb{R}\rightarrow\mathbb{R}^2$において、ある微小区間$f(t)$～$f(t+\Delta t)$の長さを$\Delta s$、それが円弧だとしたときの中心角を$\Delta\theta$、半径を$r$とすると、$\Delta s=r\Delta\theta$が成り立ちます。これより、点$f(t)$における曲率$\kappa(t)$は、と表されます。ここで、$\dot{x}=\frac{dx}{dt},\ \dot{y}=\frac{dy}{dt}$とすると、点$f(t)$における傾きはですが、この両辺を$t$で微分すると、が得られます。ドット２つは$t$での二階微分です。
また、$\Delta s$は微小区間の長さなので、であり、以上からが導かれます。κ-Curvesは、ユーザ制御点上でこの値（の絶対値）が極大値を取るような曲線である、ということです。先程少し触れましたが、κ-Curvesはベジェ曲線がベースになっています。
というか、曲線の式自体はベジェ曲線そのものなのです。
というわけで、まずはベジェ曲線について。いくつものベジェ曲線を連結して一本の曲線にすることを考えます。
この各ベジェ曲線をセグメントと呼ぶことにし、それぞれの$t$の変域を$[0,1]$とします。一般の$d$次ベジェ曲線の$i$番目のセグメントは、$c_{i,j}$をそのセグメントのベジェ制御点とするとで表されますが、κ-Curvesにおいては次に示す2次ベジェ曲線を前提とします。$d$のことは忘れてください。二階微分まで求めておくと、となります。$i番目の$セグメントの各点$c_i(t)$における曲率を$\kappa_i(t)$とすると、となります。ここで$\triangle(c_{i,0},c_{i,1},c_{i,2})$は３つの制御点を結んだ三角形の符号付き面積で、つまり定数です。……何ともよく分からん式変形なので、図解します。
同じ色の線分は平行です。

$c_{i,0},c_{i,1},c_{i,2}$を３点とする平行四辺形の残りの点（$c_{i,1}$の対角位置）を$P$とし、
$c_{i,0},c_{i,1},P$を３点とする平行四辺形の残りの点（$c_{i,1}$の対角位置）を$R$とします。$c_{i,0}$を原点としたときに、$\frac{1}{2}c_i'(t)=(1-t)(c_{i,1}-c_{i,0})+t(c_{i,2}-c_{i,1})$がどこを示す位置ベクトルになるかというと、見たまんま内分点なので図の点$Q$です。同じように、$\frac{1}{2}c_i''(t)=(c_{i,0}-c_{i,1}) + (c_{i,2} - c_{i,1})$は点$R$を示します。よって、これらの外積$\frac{1}{4}c_i'(t)\times c_i''(t)$の絶対値は、以下の領域の面積になります。

これは、以下の領域の面積と等しいことが等積変形によってわかります。

よって、$t$の値によらず、であることが分かります。初等幾何は楽しいですね。というわけで再掲すると、２次ベジェ曲線の$i$番目のセグメント上の点$c_i(t)$における曲率は、で求められます。※面積の符号については、最終的に絶対値で吸収されるのであまり気にしなくて大丈夫です。曲率の絶対値が極大になるときの$t$を$t_i$とすると、$\kappa'(t_i)=0$より、というわけでとなります。
$c_{i,1}$から見たローカル座標として、$c_{i,0}'=c_{i,0}-c_{i,1},\ c_{i,2}'=c_{i,2}-c_{i,1}$とおけば、とそこそこ綺麗な形になります。このように、与えられたベジェ制御点から曲率極大点を求めるのは簡単です。
κ-Curvesはこの逆、与えられたユーザ制御点を曲率極大点$c_i(t_i)$とし、それを満たすベジェ制御点を逆算するシステムです。いよいよκ-Curvesを構成していきます。
問題の大枠は以下の通り：入力：$n$個のユーザ制御点$p_i\ (0\le i&lt;n)$
出力：$3n$個のベジェ制御点$c_{i,j}\ (0\le i&lt;n,\ j=0,1,2)$制約１：ユーザ制御点で極大曲率
制約２：$C^0$連続
制約３：$G^1$連続
制約４：ほぼ$G^2$連続４つの制約を順に見ていきましょう。※ベジェ制御点$c_{i,j}$の添字$i$については、ひとまずはループしているものとみなし、$\rm{mod}\ n$で考えます。
　範囲制限をつけずに$i+1$とか$i-1$とか書きますが怒らないでください。非ループ版への拡張は簡単です。$p_i=c_i(t_i)$を、$c_{i,1}$について整理してみます。※$t_i=0, 1$のときはそれぞれ$p_i=c_{i,0}, c_{i,2}$のときなので、個別に簡単に考えることができます。
これを先程導出した$t_i$の式：に代入して気合で整理すると、以下の$t_i$の三次方程式が得られます。ただの３次方程式なので、解の公式（カルダノの公式）で解くことができます。
係数がごちゃごちゃしていますが、$c_{i,0}$から見たローカル座標で $c_{i,2}'=c_{i,2}-c_{i,0},\ p_i'=p_i-c_{i,0}$ と書き直せば、少し短くなります。もっと綺麗に整理するために、$p_i$から見たローカル座標で考えてみましょう。
$v_0=c_{i,0}-p_i,\ v_2=c_{i,2}-p_i$とすると、ですが、これは以下のように変形できます。対称的な形になりました。
２つ目、３つ目の係数を調整すれば３次のバーンスタイン多項式として扱えます。ところでこの方程式は、必ず$[0,1]$内にただ１つの実解を持ちます。
さすがに自明ではなく、論文にもAppendixに証明があります。概略は以下のとおり：曲線全体の位置が連続であることを保証する制約です。
各セグメント内が連続なのは自明として、隣り合うセグメントが端点で互いに接続していればよいので、
任意の$i$について、が満たされればよいですね。簡単。次に行きましょう。セグメントの接続点の傾きが連続であることを保証する制約です。
これがないと、セグメントとセグメントの間で線が折れてしまいます。任意の$i$について、ある$\lambda_i\in(0,1)$があって、が満たされれば、$c_{i,2}=c_{i+1,0}$における接線は$c_{i,1}$と$c_{i+1,1}$を結ぶ直線に定まります。
κ-Curvesにおいてベジェ制御点は入力ではなく出力なので、これで全ての場合が網羅されています。またこの制約のもとでは、ユーザ制御点の位置$p_i=c_i(t_i)$を、$c_{i,0}, c_{i,2}$を使わずに以下のように表現可能です。何でそんな変形を？　と思うかもしれませんが、後で使います。セグメントの接続点の曲率が（ほぼ）連続であることを保証する制約です。で、任意の$i$について$\kappa_i(1)=\kappa_{i+1}(0)$であればいいので、より（最後の式変形は図を書いて面積比に着目するとすぐ分かります）、が得られます。ところで、ベジェ曲線の曲率が０になることはないので、隣り合うセグメントの凹凸が逆である場合、曲率は必ず不連続になります。
このとき、$\triangle(c_{i,0},c_{i,1},c_{i+1,1}),\triangle(c_{i,1},c_{i+1,1},c_{i+1,2})$の符号が異なるので、$\lambda_i$は実数ではなくなります。一致させられないのであれば、せめて絶対値の差を０にしましょう。
つまり$|\kappa_i(1)|=|\kappa_{i+1}(0)|$を解くわけですが、$\kappa_i(1)$と$\kappa_{i+1}(0)$の符号は逆なので、$\kappa_i(1)=-\kappa_{i+1}(0)$を解けばいいことがわかります。
すると、曲率が連続の場合とほぼ同様の手順で、以下が求まります。これは先程の式も包含できているので、制約式としてはこちらのみを使えばよさそうです。制約とその関連式をまとめると、が満たされるようにベジェ制御点$c_{i,j}$を定めればよいことになります。
が、これをこのまま解析的に解くのは困難です。式(1)～(4)を使ってできることを並べてみると、となります。
これらをうまく組み合わせて、全ての$p_i$から全ての$c_{i,j}$を出力したいわけです。適当な初期値から始めて、何度も式を適用することで正解に近づけていく方針を取ります。各ステップに分けて見ていきましょう。以下のように初期化します。つまり、ユーザ制御点と中央のベジェ制御点が同じ場所にあり、
その他のベジェ制御点は隣接制御点の中点にある状態から始まります。

これは論文から引用した図で、初期化時の状態の例です。
黒い四角がユーザ制御点$p_i$で、$c_{i,1}$と一致しています。緑色の点は各セグメントの曲率極大点$c_i(t_i)$です。
今はまだ$p_i$と$c_i(t_i)$が離れていますが、この後のStep1～4のイテレーションを回すことで近づけていきます。

左から順に、初期状態、１ループ後、２ループ後、３０ループ後（完全収束）です。
ループ数は誤植ではなく、本当に数ループでほとんど完全収束と同じような形になります。式(4):を適用します。やるだけ。式(2):を計算します。これもやるだけ。式(1):を解きます。カルダノの公式（三次方程式の解の公式）を組みましょう。
実解がただ一つ$[0,1]$に存在することが分かっています。式(3):を、全ての$c_{i,1}$について解きます。n元連立１次方程式ですね。
中学・高校の数学の範囲でも気合で解くことはできそうですが、行列を使うと簡単になります。まず、係数を$\alpha_i, \beta_i, \gamma_i$として見やすく書き直しておきます。これは、以下のように行列表示の連立方程式にまとめることができます。行列部分は三重対角行列＋角なので、高速にLU分解でき、解を$O(n)$で求めることができます。
さらに、これを上下に（行列は上下左右に）１つずつ拡張してという形にすれば、行列部分はただの三重対角行列になるので、さらに計算が楽になります。また、$n\ge5$の場合はメモリ的にも有利になります。
角つき三重対角行列はLU分解のためにメモリを$n\times n$要素分、頑張って削減しても$5\times n$要素分くらい食うのに対し、上下に伸ばした三重対角行列は$3\times (n+2)$要素分で済むのです。LU分解については記事の最後の付録で解説します。実際に実装していきましょう。
言語はC#で、座標表現やfloatの各種演算にUnityのVector2クラス、Mathfクラスを借りています。
Unity特有の何かがあるわけではないので、適宜好きな言語、好きなベクトル表現・数学ライブラリに置き換えてください。ただの配列のラッパーです。計算結果の出力もこのインスタンスで。
ベジェ制御点は隣接セグメント間で重複するので、配列サイズは重複を除いた最低限の$2n+1$とします。
ただ分かりにくいので、ここまでの解説に合わせて[i,j]でアクセスできるようにしておきます。
また、$n&lt;3$の場合は点か直線を表示することが予想されるので、セグメント数を1とします。ユーザ制御点が移動する度に描画を更新するわけなので、計算空間は事前に確保して使い回しましょう。
制御点が増減すると確保し直しになりますが、その辺りを考慮するとコードが煩雑になるのでここでは妥協。
Step4の行列計算時に使うメモリは三重対角部分だけで済むので、配列は$3(n+2)$要素だけ確保します。Step4の行列計算時にユーザ制御点ベクトルとベジェ制御点ベクトルを上下拡張しますが、その際のメモリ確保をなくしつつちゃんと配列っぽく扱えるようにするためのラッパー構造体です。
コンストラクタで上下拡張時の値の初期化もやっています。
本質部分ではないしC#の人じゃないとたぶん意味が分からないので適当に読み飛ばしてください。処理の根本になる部分を作ります。を受け取り、Step0で初期化し、Step1～4でイテレーションを回し、最適化の結果を返します。
ただしユーザ制御点が２つ以下の場合は、それぞれ点や直線となるように制御点を配置して返します。では、各Stepの実装をしましょう。
ループしない場合の対応も一緒にやっていきます。初期化内容はこうでした。非ループの場合、始端と終端はユーザ制御点であってほしいので、初期化時に固定してしまいましょう。非ループの場合、終端→始端のカーブは必要なくなるので、ループの場合よりセグメントが２つ減ることに注意してください。その結果、$\lambda_{n-1}$は参照されなくなります。セグメントが１つではなく２つ減るのは直感的ではありませんが、実際に見れば納得できるでしょう。

黄色・水色・ピンクの線が各セグメントのベジェ制御点を結んだものです。
非ループの場合、水色とピンクの線が潰れているのが分かるでしょうか。ついでに、Step4で使う行列（の三重対角部分を保存するためのメモリ）の両端部の初期化もしてしまいます：非ループの場合、$c_{0,1}=p_0,\ c_{n-1,1}=p_{n-1}$となればよいので、とします。コードはこんな感じ。三角形の面積を求める解説は必要ないでしょう。外積の半分です。
非ループ時は始端と終端のλは更新しません。Sqrt計算を減らすために一応有理化して、分母がほぼ0のときは計算させず0.5にしています。なおκ-Curvesは３次元曲線にしても全く同じアルゴリズムで使えますが、外積の定義を３次元版（の絶対値）に変えるのを忘れないようにしましょう。やるだけです。
$\lambda_i$の方で非ループ対応はしているので、ここでは特に何もしません。※BezierControlsの実体は最後以外の$c_{i,2}$を削った配列なので、最後以外は片方だけに代入しています。三次方程式：を解きます。
三次方程式には解の公式（カルダノの公式）があるので、それを組みましょう。
複素解や$[0,1]$範囲外の実解は無視します。なお、実解の範囲が分かっているので二分探索などをしてもよいですが、全体の計算時間が５倍くらいに跳ね上がります。オススメしません。$ax^3+bx^2+cx+d=0$の$[0,1]$内の実解のみを返すカルダノの公式：参考：このページこれを使って、全ての$i$について三次方程式を解きます。ただし、そもそも三次方程式にならない場合の例外処理を忘れずに。
セグメントが潰れている場合に$a=b=c=d=0$となり不定解となります。ここでは$0.5$を入れておきます。
また、ユーザ制御点がセグメントの端にある場合には計算せずに$0,1$としましょう。これらのフィルタリングの下では、$a$（と$d$）が非零であることが保証され、カルダノの公式が使えます。
ただし桁落ちでたまに破綻するので、実数の精度に気をつけましょう。余談ですが、上のカルダノの公式が例外を吐く場合は大体、範囲外ではなくNaNになっています。
不定解の例外処理を忘れているか、次のStep4でランク落ちを見過ごして発生したNaNがループで伝播してきている可能性が高いので、確認してみてください。を解きます。ただし、です。
なお非ループの場合、$i=0,n-1$についてはStep0で初期化したようにで固定なので、上書きしないようにします。まずは三重対角行列の連立方程式を解く関数を作っておきます。
三重対角行列のLU分解について、詳細は記事の最後に付録として載せてあります。あとはAを組み立ててユーザ制御点・ベジェ制御点を上下拡張して実行するだけです。が、一つ注意点として、上のアルゴリズムで解くためには$A$はフルランクである必要があります。
アルゴリズムに例外処理を加えてもいいですが、ここでは面倒なので$A$を微調整する方針でいきます。
$t_i=1\wedge t_{i+1}=0$の場合にランクが落ちるので、少しだけずらしてしまいましょう。
なおループしない場合、$t_{n-2}=1$や$t_1=0$でも同じことが起きます。これでκ-Curvesのシステムは完成ですが、まだベジェ曲線の制御点が算出できただけなので、描画する必要があります。
実際に画面に映すのは各描画ライブラリにやってもらうとして、そのための点群を用意しなければなりません。とは言っても、各セグメントについて、↓これにtを順番に突っ込めばいいだけです。計算スペースのときのように、プロット用のスペースも確保しておきましょう。
セグメント数は非ループ時は２つ少なくなることに注意。
ユーザ制御点が２つ以下の場合の例外処理も忘れずに。あとはプロッティングしていくだけ。
ベジェ曲線のちゃんとしたプロッティング手法としては、de Casteljauのアルゴリズムを使って曲率に応じて適応的に密度を変えるものが挙げられますが、ここでは面倒なので等間隔プロットとします。以上を全てKCurvesクラスに実装したとして、以下のようにすれば描画用の点群を取得できます。お疲れさまでした。Unity上で、１セグメントにつき20ステップで描画してみた結果です。
ベジェ制御点も表示してみるとこんな感じ。
同じ配置でループさせるとこうなります。
はい、まだ終わってません。
ここまでの実装で実際に描画してみて、ユーザ制御点をめちゃくちゃ動かしまくってみると分かりますが、特定の状況下において適切な場所に収束しません。

なんか、飛び出しています。よく見ると接続点の傾きも不連続になっています。
尖った領域かつユーザ制御点が近接している場合に起こりがちです。この問題は、実は全ての条件を満たす解が存在しない場合がある（＝各条件を順番に解くだけでは収束しない）ことに起因します。実用上はことで解決しますが、真の最適解に収束しているわけではないことに注意しましょう。結果：
具体的には、極薄極小のセグメントの存在が問題のようです。
例えばこんな場合。
これはもう何というか、曲線ツールで鋭角を描こうとしているのが悪いです。
超鋭角の部分を検知して、その点で切断して２つのκ-Curvesに分けるといいかもしれません。記事公開から１年以上経ってもまだちょくちょく通知が来るので、新しい関連情報を少し追記します。通常の二次ベジェ曲線で定義できるなら、有理二次ベジェ曲線でもできるのでは？　と考えるのが自然です。
これは同じ筆頭著者の論文(Yan et al., 2019)で後に導入されています。
有理二次ベジェ曲線は円錐曲線全体をカバーするので、正確な円を描くこともできます（なので論文タイトルがCircle Reproduction～）。
またこちらの実装では最適化を全条件をまとめた式のエネルギー最小化で定義しており、前項で挙げた不安定性への対処もされています。
有理二次ベジェ曲線の（ほぼ）曲率連続な連結体なので、表現力はCAD等の用途でよく採用されるNURBS（非一様有理Bスプライン）と（ほぼ）同等と言えます。SIGGRAPH2020で、全く新しいスプライン曲線のクラスが提示されました。(Cem Yuksel, 2020)
ざっくりまとめると、隣接する３制御点$P_{i-1},P_{i},P_{i+1}$を繋ぐ曲線$F_i$を三角関数を使ってブレンドすることで、$F_i$によらず「至る所$C^2$連続かつ全ての制御点を通る」ことが保証された曲線を出力するものです。$F_i$を適切に選ぶことで、曲率極大点を制御点に近づけることもできます（一致させるのは相当難しく、もしできたら論文が一本書けると思います）。
$F_i$としてκ-Curvesを用いるのが好例で、論文中でも紹介されています。Yukselさんはこのクラスに特に名前をつけてくれておらず、論文等で引用する時に取り回しづらいのがちょっと難点。Adobeが特許を取っているので、無断の商用利用はNGです。
何かに使う場合、特許権侵害にあたらないかは確認しておきましょう。κ-Curvesの実装は、大学で出た発展課題の一つでした。
そこで存在を知ったわけですが、非常に便利なので趣味のゲーム開発（非営利）にも流用しています。
修論のテーマにも影響したりと、個人的になかなか深く関わることになった曲線でした。
なお同じ講義を受けてググってこの記事に辿り着いた各位へ、脳死コピペはやめましょう。私はその講義の元TAです。パラメトリック曲線界隈、最近ちょっと活発になった気がします。この間のVisual Computing 2020でもκ-Curves派生の新しいアイデアが発表されていましたね。
興味のある方は研究テーマにしてみてはいかがでしょうか。まずLU分解とは、正方行列を下三角行列$L$と上三角行列$U$の積に分解する操作です。
$Ax=b$という連立方程式があるとき、$A=LU$とLU分解することで、$Ly=b$と$Ux=y$という２つの連立方程式に分離することができます。
三角行列の連立方程式は簡単に$O(n^2)$で解ける（前進代入・後退代入）ので、$A$がLU分解されていれば、ガウスの消去法を使った$O(n^3)$の解法より速くなります。
一般のLU分解は$O(n^3)$かかってしまうので、これは同じAを何度も利用する際にのみ有効な手段ですが、
$A$が三重対角行列の場合、LU分解もその後の計算も全て$O(n)$になります。 $L$の対角成分を1に固定しましょう。このとき、三重対角行列のLU分解$A=LU$の最初の様子は以下のように表せます。成分を比較すると、なので、としてを再帰的にLU分解していけばよいことが分かります。
$O(1)$の$n$回ループなので$O(n)$です。この計算では分解し終わった部分が後で必要になることはなく、さらに$L$の対角成分は全て1なので、$L$と$U$を重ね合わせることで$A$のメモリのみを使って分解できます。元が三重対角行列なので、$L,U$は共に各行２つ以下の要素しか持ちません。
そのため、前進代入・後退代入の計算量も$O(n)$となります。右上と左下に角がついている場合（行列サイズを拡張しない場合）も、少し複雑にはなりますが$O(n)$で分解できます。成分を比較すると、なので、となり、再帰的に分解できます。
ただし、$A'$のサイズが1のときはこの四隅は同じ位置を指すので、重複して引いてしまわないよう注意が必要です。また、前進代入・後退代入も変わらず$O(n)$ではありますが、$L$は最下一行、$U$は最右一列が追加で埋まっています。
$L$も$U$も左からかけるので、この追加行・列の扱いは非対称的です。
$4\times 4$行列くらいの具体例で実際に手を動かしてみると実感できると思います。具体例：なお、一般の場合のLU分解や前進代入・後退代入についてはこちらのページなどに詳しく載っています。私の環境でのパフォーマンス計測結果です。時間は10000回の平均値（四捨五入）で、CalcBezierControls()の時間のみを計測しています。はい。$O(n\times \rm{iteration})$です。イテレーションは実用上は5～10回くらいで充分なので、C#実装でこれならそこそこ実用的な速度が出るかなと。一応計測用コード（要Unity）：元論文Zhipei Yan, Stephen Schiller, Gregg Wilensky, Nathan Carr, and Scott Schaefer.
κ-curves: Interpolation at local maximum curvature.
ACM Transactions on Graphics, 36(4):129:1–129:7, 2017.
http://people.tamu.edu/~yanzp/projects/kCurves/kCurves.pdf特許（Google Patents）Fitting a parametric curve using maximum curvature
https://patents.google.com/patent/US9501848B2関連Zhipei Yan, Stephen Schiller, and Scott Schaefer.
Circle reproduction with interpolatory curves at local maximal curvature points.
Computer Aided Geometric Design, 72:98 – 110, 2019.
http://people.tamu.edu/~yanzp/projects/ratkappa/ratk.pdfCem Yuksel. 
A class of c2 interpolating splines. 
ACM Transactions on Graphics, 39(5):160:1–160:14, jul 2020.
http://www.cemyuksel.com/research/interpolating_splines/わかりやすいNURBS解説
https://www.unisys.co.jp/tec_info/tr114/11403.pdfSolving Cubic Equations
http://www.1728.org/cubic2.htm3D曲線の場合、曲率は絶対値を取って扱うことが多いようです。2D曲線でも絶対値つきで定義されていることがあるかもしれませんが、ここではκ-Curvesの論文に倣って符号付きとします。 ↩


