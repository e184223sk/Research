smileBASICから始まり
pythonを学校で習い
luaで遊んで
C#を知るこの知るを使いこなすまで行けられればいいのだが。おっと、失礼。
タイトルが動的とか静的とか、プロパティとかメソッドとか、そういうのをはっきりさせたいだけのくせに
前回触れたのはプロパティとは何か、そしてメソッドとは何か、だけだ。一切本質に触れてすら、かすってすらいない。
あ、いや、かすってはいるが、擦り傷程度にすらならない。今回はとにかく
前回のまとめと、動的変数とプロパティの違い、動的が出るならその対になる概念、静的について、
さらに動的と静的の違い、=&gt;演算子をはっきりさせていこうと思う。バニラとModやMod同士の競合などの問題を防ぐため、
どのコンテンツのものなのかを表すものであり、
それ以上の役割は存在しない。class内に書かれる、変数やメソッド、プロパティなどのこと。
つまり、classの要素を表す&lt;アクセス修飾子&gt; &lt;型&gt; &lt;名前&gt; { get; set; }のこと&lt;アクセス修飾子&gt; &lt;返す値の型&gt; &lt;名前&gt;([&lt;引数1の型&gt; &lt;引数1の名前&gt;[,&lt;引数2の型&gt; &lt;引数2の名前&gt;[,... ]]]) { }のこと
関数のこと(多分)public, private, internal, protectedのこと&lt;型&gt; &lt;変数名&gt; = new &lt;型&gt;();のことコンパイルされてできた、アプリケーション(.exeファイル)や、Dynamic Link Library(.dllファイル)のことを指す
少なくともコードのことではない追記 (ピンと来ない人向け)

おそらくなのだが、ピンと来ていない人もいるのではないのかと。
Mod製作をしたことがある人なら、アクセス修飾子と多少関わることに関しては絶対分かると思う。

.dllファイルのdllはDynamic Link Librariesと言い、
使い方の１つとして(?) 他のコードからusingを使って、
dllファイルの中身(コード)にアクセスして使用できるのだ。
exeファイルは基本アプリケーションだが、dllファイルと同じように、アクセスできるものもある。
そしてそのようなexeファイルやdllファイルをまとめてアセンブリと言うらしい。

生のコードの状態で参照(アクセス)するか、
コンパイルされた後のものを使うかってところかな

こんなところであろう。まだ前回のが完全に終わっていなかったな。
これをはっきりさせてしまおう。上の単語がきちんと理解できているのなら、次の文章も難なく読めるのではないのだろうか。public: この型またはメンバーには、同じアセンブリ内の他のコードや、そのアセンブリを参照する別のアセンブリ内の任意のコードからアクセスできます。
private:この型またはメンバーには、同じ class 内または同じ struct 内のコードからのみアクセスできます。
protected:この型またはメンバーには、同じ class 内のコードか、その class から派生した class 内のコードからのみアクセスできます。
internal:この型またはメンバーには、同じアセンブリ内の任意のコードからアクセスできますが、別のアセンブリからはアクセスできません。
(C# 公式リファレンス より)「型」や「struct」など不明瞭なものが多少あるものの、理解はできる。
ここに載せなかった２つも含めて、要約しよう。どこからでもアクセスして使えるよ！
(classから別のclassで使える dllファイルから別のclassで使える 継承先で使える)同じclass内じゃないとアクセスできないよ！
(classから別のclassで使えない dllファイルから別のclassで使えない 継承先で使えない?)同じclass内じゃないとアクセスできないよ！
ただし、継承先ではアクセスできるよ！
(classから別のclassで使えない dllファイルから別のclassで使えない 継承先で使える)同じアセンブリだったらいいよ！
= コンパイルされた後は、外部からのアクセスを拒否するよ！
(classから別のclassで使える dllファイルから別のclassで使えない 継承先で使える)同じアセンブリだったらいいよ！
そして、別アセンブリでも継承先ではアクセスできるよ！
(classから別のclassで使える dllファイルから別のclassで使えない? 継承先(別アセンブリ含む)で使える)これがいまいち分からない
(classから別のclassで使えない? dllファイルから別のclassで使えない 継承先で使える?)
あぁ、そうだ。
readonlyというのもあったな。
これはまた今度だな。そしてもう１つ、
「アクセス」というのはどこまでを表すんだ？
特に継承先で使用できるのか、それともoverrideまでできるのかと言うのも気になった。これは実際に試してみた方が速そうだね。
やってみよう！...と思ってのだが...
継承元は必ずabstract classやvirtual voidなどでないといけないのか、
まだそこがはっきりしていないので
abstractやvirtualの理解を深めてから
詳しい実験をしたいと思う。ともあれ、private protectedを除けば理解した。
後半の２つだが、私には経験が浅く、まだ見たことのない深淵であった。
それにsealed(継承禁止)を正しく理解すれば、
その深淵を照らすことができるかもしれない...さて、本題だ。
大分長くなってしまったのように思えるな...私が一番理解したいもの、それは
&lt;アクセス修飾子&gt; &lt;型&gt; &lt;変数名&gt;; または &lt;アクセス修飾子&gt; &lt;型&gt; &lt;変数名&gt; = &lt;値&gt;; と
&lt;アクセス修飾子&gt; &lt;型&gt; &lt;プロパティ名&gt; { get; set; }または&lt;アクセス修飾子&gt; &lt;型&gt; &lt;プロパティ名&gt; =&gt; &lt;値&gt;;
の違いである。早速調べていこう。C# 変数 プロパティ 違い　検索ヒットしたのは公式リファレンスではなかった。
あの最初の意味の分からなさを実感したかったのだが。ふむふむ...１つ気づいたことがある。
変数と初回から言ってきたのだが、
どうやら変数のことをフィールドまたはメンバ変数というようだ。
メンバ変数というのならば、もしかしたら別に変数が存在するのかもしれない。
C#では(私のレベルでは)必ずクラス宣言から始まる。
PythonやLuaなどにはなかった概念である。
おそらく、変数と関数は、別に存在するのかもしれない。
私の知っているプログラム(プログラミング)が崩れ去った。崩れ去ったものを片付ける前に
とりあえず気になったのを見てみる。
そして瓦礫から必要であれば引っ張てくる。
関数は残念ながら拾い上げることはできなかった。だがしかし！
もう納得した！
一度これについて調べたという記憶の断片が、瓦礫を再構築していくような感じだった。まとめよう。プロパティに関してだが、
私はよく のような形を見ることが多かったが、実際はこれは省略形であり、本来はこのようになっている。さて、get及びsetの中はどうなっている？
まるでメソッドを書くような感じで書くのだ。さぁ！
答えはもう間近だ！！classのデータを担う、PythonやLuaで言うところの変数である。
値を格納しておくもの。classの振る舞いを担う(ちょっと何言ってるのか分からない)、PythonやLuaで言うところの関数である。
フィールドを変換したり、表示したりするなどの、
ステートメント(;までの１文のことらしい)の塊。
値を処理するもの。フィールドとメソッドの２つを足して２で割ったようなもの。
主にフィールドへの代入やフィールドの取得の役割を担う。
正直プロパティなどなくても良さそうに思えるが、あるからには意味があり、
場面によってはプロパティを用いた方が最適だったり正確であったりするのだろう。このプロパティに関しては使い方も学んだ方が絶対いいと思うのだが
今は一旦置いておく。本来であれば、さらにコンストラクタも説明した方がいいのだろう。
だがしかし、知っていました。
ざっくり言えばpythonで言うところのdef __init__(self)のようなものだ。先に全ての本題を済ませておこう。「かえりち」と打って、その最初の予測変換を見てみよう！
「返り値」と出たかな？おめでとう！君はプログラマだ！
いたぞ 連れていけ
#プログラマ狩り
(架空のツイート)みたいな感じで もうこんなに静的って書いてたら
予測変換の１番最初に「静的」が出るようになったよ！
連れてかれそう(小並感)

えぇと、、、
静的だな、実はクラスについて調べた時(公式リファレンス)に、
静的についても書いてあって、さらに詳細のリンクがあった。読んでみよう。静的クラスは基本的には非静的クラスと同じですが、静的クラスはインスタンス化できないという点が異なります。 つまり、new 演算子を使用して、そのクラス型の変数を作成することはできません。 インスタンス変数がないため、静的クラスのメンバーにアクセスするには、クラス名自体を使用します。
(C# 公式リファレンス より)え。
分かってしまうのだが。そしてどうやら、動的のことを非静的と言うようだ。
理解...してしまった...いや！ちょっと待ってくれ！
ここで書かれているのは静的クラスだ！メンバーは？static修飾子について書かれているページにとんだ。static 修飾子は、静的メンバーの宣言に使用します。静的メンバーは、特定のオブジェクトではなく、型自体に属するメンバーです。 static 修飾子は static クラスの宣言に使用できます。 クラス、インターフェイス、構造体では、static 修飾子をフィールド、メソッド、プロパティ、演算子、イベント、コンストラクターに追加できます。 static 修飾子はインデクサーおよびファイナライザーと併用できません。 待ってました！意味が分からない単語！！
あああああああ！最高！だけど！やめて！と歓喜という名の発狂をしつつ読んだのだが、これ現時点でそもそも「静的」がどのようなものなのか、一切説明がなされていない正解はわりと近くにあった。
ページを戻して、少し下にスクロールしたところに。静的クラスは、入力パラメーターに対してのみ処理を行い、内部のインスタンス フィールドを取得したり設定したりする必要のない一連のメソッドを格納する、便利なコンテナーとして使用できます。静的クラスの主な特徴を以下に示します。
静的メンバーだけが含まれます。
・ インスタンス化できません。
・シールされています。
・インスタンス コンストラクターを含めることはできません。したがって、静的クラスを作成することと、静的メンバーとプライベート コンストラクターのみを含むクラスを作成することは、基本的に同じです。 プライベート コンストラクターは、クラスのインスタンス化を防ぎます。 静的クラスを使用する利点は、インスタンス メンバーが誤って追加されないことをコンパイラで確認できるという点です。 コンパイラによって、このクラスのインスタンスを作成できないことが保証されます。(C# 公式リファレンス より)少し分かりづらさがあるものの、もう分かりつつある。
...知らない単語を除いて。一回深呼吸をして...よし、まず、静的クラスについて一旦まとめよう静的クラスとは
インスタンスの作成を必要とせず、主にメソッドによるフィールドの演算処理などをまとめたクラスうーむ...うまく言えないし、少しニュアンスが違う気がする。
Qiita的にはよくないのだが、自分がわかる表現をしてみよう静的クラスとは
主にモジュールのような役割を持つ。おっけぇい！
いわゆるpythonで言うところのモジュールだ！そうだよ！よっしゃ！この勢いで静的メンバーにも触れるぞ！非静的クラスには、静的メソッド、フィールド、プロパティ、またはイベントを含めることができます。 静的メンバーは、クラスのインスタンスが作成されていない場合でも、クラスで呼び出すことです。 静的メンバーには、必ずインスタンス名ではなくクラス名でアクセスします。 クラスのインスタンスの作成数に関係なく、静的メンバーのコピーは 1 つしか存在しません。はい！もう完璧よ！正直なところ、静的ってなんだ？と聞かれたら静的なやつだよとしか答えられない。というものの、私の語彙力不足と頭の中でいろんな概念が渦巻いているからであろう。だが、動的と静的について、次の表現ができそうだ。動的はゲーム内のアイテム、静的はゲームの状態どういうことかと言うと、まず、Terrariaというゲームを想像してほしい...のだが
日本人あまりTerraria知らないからなぁ...(ﾅｶﾏﾎｼｲ)Minecraftでいい！
Terrariaでもそうなのだが、Minecraftにも雨などの天候が存在する。MinecraftのModを作ったことはないから知らないが(しかもC#じゃなくてJavaだし)
Coreというゲームのシステムを担うクラスがあって、そのメンバとしてbool(Javaだとbooleanかな？)のrainingがあるものとする。ここで、雨が降っているか降っていないかは、ワールドによって決ま...らねぇじゃねぇかぁあぁぁぁぁあ！あれ絶対チャンクで降るか降らないか設定してそうや！
やめやめ！Terrariaでいきます！！！！(Terraria知らない人ごめん)
(めっちゃくちゃザックリに言うとMinecraftを2Dにして、いろんなコンテンツ増やして、サバイバルとクリエィティブを合わせたゲーム!(本当はMinecraftとは全く別物))Terrariaにはゲームの中核を担うクラスが存在し、
そのクラスにrainingというブール値が存在する。Terrariaでは雨は１ワールド全体で降る。
Minecraftと同じように、２つ以上のワールドを同時にアクセスはできない。
(一度処理落ちでアプリが複数開いたことがあるのだが、１つを除き全てエラーを吐いた)１ワールドにつき、雨が降るか降らないか。
ワールドごとに必要に思えるかもしれないが、
プレイヤーが同時にアクセスできるのは１ワールドしかない！つまりrainingフィールドは１つで足りるだろう？故にこうだ。Q.E.D.さらに言えば、
rainingしかメンバーがないなら
クラスも静的でもいいだろう。Terrariaでは１ゲームで雨が降るか降らないか なので
静的で正確なのだが、
アイテムはどうだろう。
ツルハシ、オノ、剣、ハンマー、杖...アイテムという概念自体は１つだが、
アイテムは複数の種類が存在するため
１ゲームに１つの状態に定まらない。全てのアイテムのデータに関して、全てフィールドで定義するのか?
否、自作の変数型を作るように、アイテムを定義する。
そっちの方が、分かりやすいしパッと見、配列用意するなら Itemクラスいらなくね？と思うかもしれないが、
クラスはメソッドも追加できる利点がある。さて、まとめたいところなのだが、
このような例をださないと正直、要約できないのだ。うーむ...少し寝不足が...これを終わるまではとりあえず寝ない！
いこう！１アセンブリにおいて、何らかの１つのデータを記録、保持、変更したい場合は静的クラス、もしくは静的メンバを利用する。つまり動的はその逆、１アセンブリにおいて、何らかの複数のデータを記録、保持、変更したい場合は動的メンバを利用する。うーむ...動的に関しては少ししっくりこないのだが、仕方ない。最後に=&gt;演算子を見て寝るとしよう。=&gt;演算子に関して公式のリファレンスがあたった。あぁ～！
もういいやこちらに関しては説明しない。
もうこの３文字「ラムダ」が全てを教えてくれた。ラムダ強し！...だれだよ本当は、私無名関数はよくわからず断念していたのだが、
今まで書いてきたModのコード的にもう理解した。
そういうことか。眺めてみたら
もちろん不明瞭なものもあった。これだけ付け加えておこうはこれはちょっとなんか引っ掛かる
getとsetどこいったし本当に「はっきり」したかというと
そうではない。このタイトルの後には(2/?)とついている。これは、
C#が完全に理解するか、途中であきらめるか、Qiitaに備忘録として書き忘れるまで続く
ということだ。私はTerrariaのコミュニティフォーラム以上にQiitaに出没しない。
十中八九忘れるであろう。感覚ははっきりした。あとは使ってみてだ。
使わなければ、その感覚は知識に変わらないであろう。そして知らなかったが、ちょっと気になった単語をメモとして置いておく。
オーバーロード最後に
PythonやLuaを使っていた私から、このC#を見て思ったことをつづろう。使いづらい言語だな！
でも、とても便利そうだ！以上
第二回C#備忘録
終了します。おやすみ～ぐぅ
追記 2021/05/14getとsetどこいったし()を見逃していました誤認識についてのコメント(ありがとうございます)を含め、↓第三回C#備忘録でまとめ治してます


