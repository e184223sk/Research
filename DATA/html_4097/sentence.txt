More than 1 year has passed since last update.入社して4年ほどjavaによる開発ばかりやってきましたが、次のプロジェクトでC#を触ることになりました。
同じオブジェクト指向型言語なので基本的には同じところが多かったのですが、勉強してここはjavaと違うんだなと感じたところを纏めます。
javaはわかるけどこれからC#を勉強したいという人の助けになればと思います。まず初めに感じたのは文字列クラスの型の書き方です。
javaならクラスの型は先頭が大文字の"String"で記述しますが、C#の場合、”string”が正解になります。C#でもusing System;を宣言していればStringと書いてもエラーにはなりませんが、
公式の回答としてstringと書くべきと発表されているので
C#を書く時には大人しく従って小文字から始めたほうがいいでしょう。
StyleCopというマイクロソフトが出しているコーディングスタイルチェックツールではStringは指摘対象だそうです。これはもしかしたらC#を学んだうえで最も違和感を感じたところかもしれません。
変数を定義したりインスタンスを作成する際にはstringやintなど、型を定義しますが、
C#ではそれらをvarというキーワードで纏めることができます。
例えば下記のようなコードではstringやHuman(独自に定義したクラスです)などの方を明示的に指定する方法で書くこともでき、2行目のようにvarキーワードを使用して暗黙的に型を指定する方法で書くこともできます。ただし、変数の型としてvarを使用する場合には変数宣言時に初期化をする必要があり、下記のようなコードは
コンパイルエラーになります。また、varで定義した変数にはどのような型をいれることもできますが、
下記のように場合によって入れる型が変わるということもできません。これはユーザに1か2を入力してもらい、varで宣言した変数valueに
* 1の場合はint型の数値
* 2の場合はstring型の文字列
をそれぞれ代入するコードです。
このようなコードを書いた場合は
'int' と 'string' の間に暗黙的な変換がないため、条件式の型がわかりません。
というコンパイルエラーが発生します。
つまりvarで宣言した変数はObject型のようなどんな型でも入れられる万能な型ではなく、
初期化した型に自動で変換してくれるだけのものというわけです。
では明示的な型指定とvarを使った暗黙的な型指定のどちらを使えばいいのかというとマイクロソフトが出しているプログラミングガイドによると基本的にはvarを使った暗黙的な型が推奨されているそうです。
例外として、下記のコードように呼び出し先のコードを確認しないと型が分からない場合は明示的に型指定するお方がいいとされています。javaではオブジェクトがnullでない場合のみ処理を行う場合、下記のように書きます。
(getNameメソッドはnullを返却する可能性がある。)C#だとこんな書き方ができます。勿論C#でもifを使った書き方も可能です。
"?"をつけるだけでいいので楽ですね。javaをやっている人なら参照型とプリミティブ型の違いは理解していてintやcharなどの値型なら変数に格納されている値を比較する"=="を使う、StringやDoubleなど、変数にアドレス値が格納される参照型ならそのアドレスが示すメモリに格納されている値を比較する".equals()"メソッドを使用する。これはよく知られている話だと思います。
上記の参照型とプリミティブ型の話はC#でも同じなのですが、文字列の比較に関しては"=="が推奨されています。javaで==メソッドを使った場合、下記のようになります。
(new Stringを使うことで異なる参照先を持つオブジェクトを生成しています。)ところが、C#で同様の処理を書くと下記のようになります。
(string.Copr()メソッドを使うことで異なる参照先を持つオブジェクトを生成しています。)なぜ上記のような結果になるのかというと、C#ではstringクラスを"=="で比較した場合、暗黙的に"equals()"メソッドに置き換えられて処理されるそうです。
どっちを使っても結果は一緒ってこと？それなら使い慣れて誤解を産みにくい"equals()"メソッドを使ったほうがいいじゃん！って思いますが、C#ではむしろ"=="が推奨されています。
それはなぜかというと下記のコードで説明します。このように型が異なる変数の比較をしようとした際に、
"=="だとコンパイルエラーが発生するのですが、"equals()"の場合はコンパイルエラーは発生せずに実行までできてしまいます。(型が違うと必ずfalseになりますが)型が異なるものの比較は通常おかしい処理になりますのでバグを実装時に検知できるという観点から"=="が推奨されているそうです。javaにはなくてC#にはあるものの一つとしてrefキーワードとoutキーワードがある。まず、下記のコードを実行してみるこの実行結果はもちろん下記のようになります。次に、refキーワードを追加してみます。add1という関数の引数にrefキーワードをつけた以外は先ほどのコードと同じです。
これで実行すると下記の結果が得られる。3つ目の出力が2になっていることからint型なのに呼び出し先の影響を受けていることが分かる。
これがref関数を使うことによる値型の参照渡しです。
ちなみにrefキーワードは呼ぼ出し先と呼び出し元の両方に記述する必要があります。
これは参照渡しには自分が意図しないところで変数の内容が書き換えられる危険性があるため、使う側にここでは参照渡しをしていると意識させるためにコンパイラがチェックしているそうです。まず、下記のコードを見てください。変数numを参照渡しでgetNumberメソッドに渡して初期化するコードです。
しかし、このコードでは下記のようなコンパイルエラーが発生します。これはrefキーワードをつける場合、その変数は初期化済みである必要があるというエラーです。
呼び出し先のメソッドで初期化したいのに事前に初期化しろと言われるのはちょっと面倒だし余分なコードが増えますよね。
そんな時に使用するのがoutキーワードです。
先ほどのコードのrefキーワード部分をoutキーワードに置き換えてみます。これならコンパイルエラーは発生しません。
実行結果も下記のようになります。ちなみに、outキーワードで指定していてもgetNumberメソッドの中で引数を初期化しないとコンパイルエラーになります。
例えば、下記のコードはコンパイルエラーです。上記のoutキーワードは複数の変数の初期化や最小値と最大値を一緒に取得したいなどのケースでやりたくなることが多いと思います。
しかし、そのようなケースでは参照渡しを使うのではなく、タプル型を使用するほうがいいです。
※ タプル型はC#7(.NET FrameWork4.7)以降に追加された機能です。タプル型を使用するとこのように複数の変数を戻り値として受け取ることができます。javaで同様のことをしようとするとMapやリスト等に格納して返却する必要がある処理です。
値を返すためだけにインスタンスを作成しなくていいので少しスッキリしますね。javaやC#などのオブジェクト指向型言語ではクラスのカプセル化のためにクラスフィールドを隠蔽し、
アクセサーと呼ばれるgetterやsetterなどのメソッドを通してアクセスします。
こうする事で読み込み専用にしたりクラスフィールドにセットされる値の入力チェックが可能になります。この書き方がC#では省略した形で書くことができ、それをプロパティと呼びます。まずはjavaでの書き方。上記のコードのようにLanguageクラスのフィールドであるexperienceとnameに値を設定したり取得したりする際にsetterやgetterを使用します。これをC#ならこのように焼灼した形で書くことができます。上記のl.Experienceようにまるでpublicのフィールドに値を設定するような書き方で記述が可能になります。それを可能にするためにLanguageクラスではpublic int Experienceとpublic string Nameのようなプロパティコードを記述します。
このプロパティの書き方のほうが呼び出し側、呼び出される側ともに記述する量が少なくて済みます。


