　Zenject/Extenjectを使った方がなんか良いらしい。じゃぁ使い方を調べよう。そんな具合でそこから入ったものの、だいぶ飲み込むのに苦労した経験があります。特にZenject/Extenjectは多機能ですので、余計に要点を把握しにくいのではないかと思う所があります。
　ですんで、そういったものを使う前の具体的な話からしていって、意義を書き留めておきたいなと思います。　Dependency Injection。依存性の注入。詳細は後述。　DIをしてくれるフレームワーク。Zenject/Extenject、VContainer等。　DIをしてくれるフレームワークの一種。基本的にZenjectもExtenjectも同じものだが、政治的要因でZenjectからExtenjectが分離した歴史を持つ。現在はExtenjectが本流だが、そういう経緯からExtenjectのことも含めてZenjectと呼称することが多い。本稿ではZenject/Extenjectと表記する。　DIをしてくれるフレームワークの一種。最近リリースされた。Zenject/Extenjectよりもシンプルで軽いらしい。　ゲーム制作も順調です。次のことを実装しようと思います。　サーバーはまだ選定すら済んでいません。とりあえず、PlayerPrefsを使って保存することにしましょう。1ゲーム終了時にはGameControllerクラスのOnFinishedが実行されるとします。まずはこんなコードになるでしょう。　慣れた方ならGameControllerというネーミングに警戒心を覚えるでしょう。しかもそこに保存するコードを直接書くなんて！実際にここは今後書き換える可能性が非常に高いです。将来的にサーバーに保存したい所ですから。ハイスコアの保存に関することは一つのクラスにまとめておきましょう（単一責任の原則）。　Repositoryというのは永久保存する場所という意味です。HDDやサーバーなどです。これで少しは安眠できるでしょう。　サーバーが決まり、契約も済ませました。いつでも使える状態です。じゃぁHighScoreRepositoryを書き換えましょう。ただ、開発中はPlayerPrefsの方が便利なので、前のコードも残しておきたい所です。コメントアウトしておきましょうかね。コメントアウトする場所をちょっと弄れば、切り替えられます。　ちょっと不細工ですね。GameControllerを弄って、if文で切り替えられるようにしましょうか？それもまたリスクがあります。今はOnFinishedだけですが、今後他の場所でHighScoreRepository.Saveを実行する可能性はないでしょうか？そこでちゃんと忘れずにifで切り替えられるでしょうか？怖いですね。
　GameControllerがHighScoreRepositoryに依存している状態です。HighScoreRepositoryやその周辺をいじるときは、GameControllerもうまく歩調を合わせてやらないといけません。面倒ですね。　ここで出てきます。依存性の注入。GameControllerでは依存するHighScoreRepositoryを次のように書いていました。これをGameControllerの外でやります。外で作るだけではあまり状況は変化しないので、HighScoreRepositoryをInterfaceにして、外で切り替えられるようにします。例えばこうします。　HighScoreRepositoryはInterfaceにしました。これは上述通り。で、注目するところはGameControllerのコンストラクタ。ここでIHighScoreRepositoryをもらうようにします。HighScoreRepositoryに依存していたわけですが、これを外から注入、つまり入れてやります。これが依存性の注入です。GameControllerにとってはPlayerPrefsかサーバーかどこかよく分からんけど、とりあえず良い所に保存される、という認識になります。
　
　したがってGameControllerを作るときはこんな感じになります。　そういえば、せっかくハイスコアランキングに登録するのに名前が表示されないなんてちょっと寂しいですね。PlayerPrefsには必要ない要素でしたが。どうしましょうか？
　IHighScoreRepository.Saveの引数に追加するのも一つです。しかし、PlayerPrefsには不要で、サーバー保存時のみに必要です。GameControllerも書き直さなきゃいけません。面倒ですね。じゃぁこうしましょう。　GameControllerを書き換えなくても済みました。HighScoreRepositoryServerの生成時に直接文字列を入れても良いのですが、将来はサーバー保存時に名前入力ダイアログを出したいので、またInterfaceにしました。今はサーバー保存の実装に注力して後で切り替えます。　割とシンプルなプログラムですが、GameControllerLoaderは割と大きくなってきます。これからもどんどん大きくなるでしょう。単一責任の原則にしたがってクラスを作っていけば、それなりの数になります。この生成を管理するとなると面倒です。
　はい、お待たせしました。ここで出てくるのがDIコンテナです。　Zenject/Extenjectをインポートした後、SceneContextを作ります。で、MonoInstallerのスクリプトを作成、それを空のGameObjectにアタッチして、SceneContextのMonoInstallerにアタッチします。※この辺りの詳しい利用方法は検索すれば出てくると思います。
　スクリプトは以下のようになります。　先ほどと同じように動くはずです。GameControllerLoader.StartがInstaller.InstallBindingsに移ったような感じです。
　詳しく見ていきましょう。まず_gameControllerに[Inject]という属性がついています。Zenject/Extenjectはこれを探してきます。見つかったら、ここにインスタンスを放り込みます。
　この放り込まれるインスタンスの型は予めZenject/Extenjectに伝えておかねばなりません。それがInstaller.InstallBindingsのです。AsSingle()はインスタンスを1個だけ作るという意味です。今回はGameControllerのInjectが１カ所しかありませんが、複数書かれる場合もあります。そのとき、常に同じ一つのインスタンスが挿入される、という意味です。
　このようにZenject/ExtenjectはGameControllerのインスタンスを作ってくれる訳ですが、GameControllerのコンストラクタには引数がありました。IHighScoreRepositoryです。これについても何を挿入したら良いか、予めZenject/Extenjectに伝えておかねばなりません。それがです。
　debugMode==trueの時、IHighScoreRepositoryを挿入しなければいけない時はHighScoreRepositoryPlayerPrefsを作ってそれを入れて、という意味になります。
　debugMode==falseだとHighScoreRepositoryServerになりますが、このコンストラクタでさらにINameGetterが要りますので、INameGetterをNameGetterConstに指定します。　まずVContainerをインポートします(manifest.jsonに「"nuget.mono-cecil": "0.1.6-preview"」を追加するのを忘れずに)。で、下記のスクリプトを作って、空のGameObjectにアタッチします。InspectorにGameControllerLoader欄ができてるので、そこに上述のGameControllerLoaderのGameObjectを放り込んでおきます。　やってることはZenject/Extenjectと同じです。唯一違うのがこいつです。　これはHierarchyにあるGameObjectについて、インジェクションをして欲しい対象を指定しなければいけません。Zenject/Extenjectはこれを自動でやってくれてたんですね。　[Inject]属性のあるフィールドやコンストラクタで必要なインスタンスを放り込んでくれることをそれぞれ、フィールドインジェクションやコンストラクタインジェクションと言います。メソッドインジェクションというのもあります。　Zenject/Extenject、VContainer共通です。
　原則的にはコンストラクタによるインジェクションを基本とします。そもそも何かに依存するのを避けるために、DIコンテナを使わない方法から出発しました。なのにDIコンテナがないと動かないというのはちょっと矛盾します。
　とはいえ、MonoBehaviourはコンストラクタを持てないので、代わりにフィールドインジェクションやメソッドインジェクションを使います。　まぁ重いとは言われます。リフレクションと言って、ソースコードの文字列を解析して、インジェクションが必要な所があれば、都度そこにインスタンスを放り込むという処理を行っているためです。そのためゲームを立ち上げるときなんかにちょっと時間がかかるようになるかもしれません。支障が出るほど重くなるのはちょっと考えにくいとは思います。　おおよそのやり方は上述の通りです。これで何がしやすくなるのか。例えばテストがしやすくなります。サーバーが無くてもハイスコア関係の仮実装が可能で、それによってGameControllerも動かせるようになったのは見ての通りです。
　また複数人で作るのにも有効ではないでしょうか。HighScoreRepositoryServerができていないから、GameControllerのOnFinishedが完成しない、といった事態も避けられます。
　設計にお悩みの方は是非試してみてください。


