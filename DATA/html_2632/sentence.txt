会社でプロジェクトにUniTaskを導入しはじめて数か月ほど経過して、利用した感触や、いろいろなケースの使い方がおぼろげながらまとまってきたのでこちらで紹介することとします。既存のコードはコルーチンやコールバック方式で書かれていたため、そういったコードからの切り替え・相互呼び出しなどが必要になりましたので、そういった点についても紹介します。常に意識するべき基本的な機能や、既存コードの移行に必要なことを書きますが、応用的な使い方や細かい機能については今回はカバーしません。また、生のTask の利用についても記述しません。Unityで堅牢な非同期コードを書きたい場合は、UniTaskを使うのが良いです。
導入には一定の知識が必要ですが、この記事でそういった点について紹介します。コルーチンUniTaskメソッドUniTask簡単に触れておきます。スライド「Deep Dive async/await in Unity with UniTask(UniRx.Async)」（neueccさん） 注意点簡単にだけ書きますが、基本的な仕組みとしては、書き方の違いを除けば、UniTask/Task は、コルーチンと極めて似たものです。非同期処理を直列的、手続き的に書くことができます。しかしいくつかの点で仕様が異なっているため、適用できる用途が違ってきます。このあとそのような違いについて書きます。
なお、TaskとUniTaskの違いなどは「Deep Dive async/await in Unity with UniTask(UniRx.Async)」に詳しいです。コルーチンでは、実行終了後に値を返す良い手法がなく、コールバックが利用されていたと思います。あるいは、IEnumerator.Current を利用して yield return 値; としてからコルーチン終了することで、Currentから値を取り出すような手法もありますが、記述量が多い手法で、見た目にも複雑で、さらに型を制約できないなど問題がありました。UniTaskでは return 値 のように、通常のメソッドと同様の記法で値を返すことができ、返り値の型も通常のように制約されます。コルーチンの場合、ネストして実行時に例外を起こすとそのコルーチン内で終了してしまい、呼び出し元のコルーチンには伝播しません（※）。例外を利用したい場合、コルーチンごとにtry~catchを書いたうえで、コールバックによって呼び出し元に伝えるといった手法が通常かと思います。IEnumerator.Currentを利用して呼び出し元に返す手法もありますが、かなり記述量が多くおすすめできません。UniTaskでは、通常のメソッドと同様に呼び出し元に伝播しますので通常のメソッドのように書けます。ただし、注意点があり、キャンセル時に投げられる OperationCanceledException をむやみにキャッチしてしまわないための配慮は必要です。（「例外処理の注意点」の項目参照）※一度もyieldする前に発生した例外については呼び出し元に伝播するケースがありますが、特殊な条件なので、この挙動に頼ることはできないでしょう。終了処理が必要なコードがあった場合、コルーチンの場合は、ネスト実行時、前項で書いたように例外が伝播しないためfinallyブロックが動作しませんでした。また、MonoBehaviourが破壊された場合などもその場で停止してしまうために、finallyブロックが呼ばれません。UniTaskではfinallyブロックが必ず呼ばれるので、リソースの開放が必須な場合などに、より安全なプログラムを書くことができます。また、IDisposable と using ステートメントを利用した場合でも、UniTaskであれば必ずDispose()が呼ばれます。finally 利用時の例IDisposable 利用時の例UniTaskは（C#標準のTaskと違って）通常はメインスレッドで動作しますが、await時の指定で実行スレッドを切り替えることができます。
 await UniTask.SwitchToThreadPool() のようにするとそこから別スレッドで動かすことができ、さらに await UniTask.SwitchToMainThread() とすればそこから再度メインスレッドに戻ることができます。非常に簡潔な形で別スレッドを利用できるのが便利です。※ただし、UnityのAPIはほとんどが別スレッドでの動作に対応していないのでご注意ください。コルーチンではMonoBehaviourが破壊された場合に動作が止まりますが、これをUniTaskで実現するにはCancellationTokenの実装が必要で、このために引数リストが長くなってタイプ量が増えます。コルーチンをUniTaskですべて置き換えることも可能ではありますが、GameObjectがらみのウエイトやアニメーションのようなケースでは、コルーチンで十分なことも比較的多いと思いました。シンプルなケース（コルーチン）シンプルなケース（UniTask）Unityのコンソールのコールスタックを見ても、どこから呼ばれたUniTaskかなどはわかりにくいです。これはコルーチンでも同様のはずですが、UniTaskのほうがコールスタックの数が多くがややこしい感じはします。（本質的ではないですが）なお、Unity Editor上であれば、Windowメニューから起動できる UniTask Tracker で Enable StackTrace をONにして実行することで、今実行中のUniTaskについて、呼び出し関係のスタックトレースを表示できるようです。例外が伝播せず、finally や usingステートメント が有効に利用できないコルーチンに比べて、UniTaskを使うと堅牢なコードが書きやすいといえます。コールバック方式と比べても、例外処理などを利用してより簡潔に書けるように思います。コルーチンでは書きづらいので、コールバックなどを利用していたと思いますが、そういったケースで直列的に書くことができ、よりシンプルに記述することができます。コルーチンの場合、StartCoroutineを実行したMonoBehaviourが破壊されたり、GameObjectが非Activeになるとコルーチンの実行が止まります。UniTaskでは、何もしなければMonoBehaviourやGameObjectとかかわりなく動き続けることができ、停止タイミングはCancellationTokenの指定によってコントロールすることができます。コルーチンでも、ずっと生き続けるGameObjectを利用することで長い寿命は実現できますが、そのようなGameObjectを作成せずに実現することができます。コルーチンはMonoBehaviour.StartCoroutine() を呼ぶことで起動しますが、このMonoBehaviorの寿命がコルーチンの寿命と直結しています。以下のケースでコルーチンは自動的に停止します。
  * コルーチンを起動したMonoBehaviourが破壊された場合
  * コルーチンを起動したMonoBehaviourのあるGameObjectが非Activeになるか、破壊された場合ちなみに、MonoBehaviourがdisabledになった場合は、コルーチンは止まらないようですコルーチンの側からみると、上記の条件が成立すると、yieldしたっきり処理が再開しない、という挙動になります。このため、終了処理の機会はありません。なにかのリソースを使いはじめた後、確実に後処理をしないといけないケースなどでは、使いにくいといえます。UniTask は、MonoBeheviour.StartCoroutine() で実行されているわけではないので、MonoBehaviour の寿命とは関係がありません。何もしなければ、途中で停止することはなく、動きつづけるというのがUniTaskの性質になります。しかし、UIを扱う場合など、MonoBehaviour が破壊された場合は、そのまま動いてほしくないケースが多いと思います。たとえばウエイトした後Textコンポーネントの文字列を書き換えるタスクだった場合、この GameObject が破壊されていれば、実行する意味はないことになりますし、NullReferenceException の発生にもつながります。
このような場合に CancellationToken を利用することで、コルーチンと同様のタイミングでキャンセルしたり、任意のタイミングでキャンセルを行うことができます。CancellationTokenとは何かということですが、「キャンセルしたかどうか」を伝えることができるオブジェクト(実際はstruct)ぐらいに思ってもらえると問題ないと思います。CancellationTokenを利用して、おおよそコルーチンの場合と同様の破壊タイミングにするには、以下のようなコードにします。ちょっと長くなって書くのが面倒になった、と思うかもしれませんが、これがUniTaskの基本形と考えてもらったほうが良いと思います。※同等と書きましたが、実際には、GetCancellationTokenOnDestroy() で返されるトークンは、GameObjectが非Active化したときには影響を受けないので、コルーチンの場合とは少し異なります。UniTaskの呼び出しがネストする場合は、以下の例のように、引数で得られたtokenを必ず渡していくことが重要です。手動でのキャンセル方法は以下のように、CancellationTokenSourceを利用します。
基本的にはUniTaskの呼び出しごとにCancellationTokenSourceごと作りなおすのが良いと思われます。
GetCancellationTokenOnDestroy() と同様の挙動を実現するには、OnDestroy() で Cancel() を呼びます。以下のように、CancellationToken の実体ののかわりにdefaultを渡すと良いです。これは、struct CancellationToken のデフォルト値、つまり new CancellationToken() の値が渡されます。以下でも同じです。また、CancellationTokenを利用しないケースが考慮されたメソッドを書く場合は、 CancellationToken token = default と、デフォルト値を設定しておけば、トークンを指定せずに実行することができます。もちろんこの場合（トークンの引数を省略した場合）、実行を途中でキャンセルされることがなくなります。上記で書いたように、CancellationToken は、ネストして呼び出すUniTaskメソッドの呼び出しにも同じトークンをつけることで伝播していくものです。伝播させることで、ネストが深くても、キャンセル時に実行を中止することができます。一方で、CancellationToken を受け取らない非同期メソッドもありえます。このような非同期メソッドをawaitしたとき、await中にキャンセルのフラグがONになっていても、それに気が付くことはできません。キャンセルしないことで、単に実行時間を消費するだけならさほど大きな問題がないケースもありますが、キャンセル後に実行してはいけない処理があった場合、問題が出ますので、以下のように自前でのキャンセルチェックが必要になります。自前でのキャンセルチェックこのように手間が増えるため、UniTaskメソッドでは、通常はできるだけ引数で CancellationToken を受け取れるようにしておき、ほかのUniTaskメソッドからの呼び出しに備える、というのが基本戦略と考えられます。また、キャンセルへの応答が難しいケースで CancellationToken を受け取るべきかは悩ましいところです。しかし、上記のように自前のキャンセル判定をしないですむようにするには CancellationToken に対応しているほうが望ましいので、ほかのUniTaskメソッドから呼び出されることが想定される場合は、やはり CancellationToken を受け取れるようにしておくほうが便利と考えられます。UniTaskでは、通常のメソッドのように try ~ catch で例外処理ができるのが利点、と書きましたが、実は常に考慮すべき点があります。これもキャンセルがらみです。
というのは、キャンセルの処理が OperationCanceledException という例外によって行われることから、適当に Exception 型を指定して try ~ catch などしてしまうと、キャンセルがそこで止まって、呼び出し元に伝播しません。これは通常は望まない挙動ですので、UniTaskメソッド内での try~catch は OperationCanceledException をスルーする必要があり、ほぼ常に以下のようにするのが良い、というか、このようにする必要があります。
もちろん、 OperationCanceledException が呼び出し元にきちんと伝播する書き方であれば問題ありません。書いたコードにtry~catch がない場合、UniTask内で発生した例外って結局どこまで遡るのでしょうか？UniTaskメソッドは最初は非asyncのメソッドから呼ばれているので、非asyncのメソッドからさらに上位に伝播するのでしょうか・・・？
実は、Forget()のところで例外をキャッチして、ログに出力するようになっています。
ですので、Warningを無視してForget() を書かないと、例外はログに出ずに消えてしまう・・・と考えていましたが、そうでもないケースがあるようなので、恐縮ですが、要調査です。まず最初にUniTaskじゃないところからUniTaskをどう呼び出すか、ということです。＜UniTaskメソッド名＞().Forget(); のように書くことで値を返さないUniTask、あるいは値を返すUniTaskであっても返却値を無視する形で呼び出すことができます。これが実はちょっとややこしいです。なぜなら、普通のメソッドは非同期的に値を受け取らないからです。ですので、値を受けとりたければ以下のように、まず別のUniTaskで結果を受け取ってそこで値をハンドリングする必要があります。※ 「値を返すUniTask」を変更できない場合について書いています。多少簡潔に書く方法もあります。普通に &lt;&gt; のないUniTaskを書けばよいです。上記、返り値がないUniTaskと混同しがちなのがUniTaskVoidです。
UniTaskVoidとは、終了を待つ「ことができない」UniTaskです。
UniTaskVoidを返すメソッドに対してawaitを書くとシンタックスエラーです。ですので、終了を待つ可能性がほぼ考えられないケースに利用しましょう。
後から処理の終了を待ちたくなることは結構あるので、UniTaskVoidを使いたいケースはそう多くないはずです。処理の終了を待ちたいことがありそうであれば、&lt;&gt; のない UniTask を利用しましょう。
UniTaskVoidの場合、Forget() は実際には何もしないメソッドになっていますが、現状では書かないとWarningが出ます。UniTaskVoidは、.Forget() を呼ばなくても、.Forget() を呼んだのと同じ処理になります。これを利用して、MonoBehaviourの Start() メソッドを非同期メソッドとして書くことが可能です。※ Start()を async UniTask Start() のように書いた場合に問題があることを予想しましたが、実際にやってみると同様の挙動となったので、違いは不明です。公式サイト では Start() には UniTaskVoid の利用が推奨されています。UniTask内のawaitでコルーチンを待つことができます。WithCancellation メソッドを併用することで、CancellationTokenを利用してキャンセル時の処理を行うことができます。UniTaskから呼ばれたコルーチンは、通常のUnityの処理と異なり、UniTaskが駆動しているため、GameObjectがDestroyされたときに自動的に止まるということはありません。そのような挙動にしたい場合は、GetCancellationTokenOnDestroy() で取得したトークンを渡すなど、CancellationTokenの適切な利用が必要になります。
WithCancellation() を利用してCancellationTokenを渡している場合、キャンセル時には、通常コルーチンと同様に、コルーチン内の yield のところでCoroutineの実行が止まります。UniTaskには ToCoroutune() というメソッドがあり、これを利用することができます。特にキャッチするべき例外がない場合は、以下のような簡潔な記法も利用できます。ただし、CancellationToken利用時のキャンセル時にはエラーログが出てしまう問題があるようです。ログが出る以外の実害はないですが、キャンセルしないケースで利用するのが良いと思われます。コルーチンには例外を伝播させる方法がありませんので、例外についてはUniTask内で処理する必要があります。このため、現実的には、以下のような形で例外処理するのが良いと思われます。UniTask.Action を利用することで、コールバック方式のメソッドからUniTaskを呼び出すことができます。※この例ではキャンセルしないケースになっています。コールバック側にキャンセル機構がある場合は、CancellationTokenSource を利用しましょう。また、例外が発生する可能性がある場合は例外処理も必要です。AutoResetUniTaskCompletionSource を利用することで、コールバック方式のメソッドをUniTaskに変換することができます。成功時に TrySetResult を呼ぶことで結果を返し、待ちを終了させることができます。失敗時には TrySetException で例外を渡すことができます。※ AutoResetUniTaskCompletionSource.Create() のかわりに new UniTaskCompletionSource() とする方法でも動作はほぼ変わりませんが、 AutoResetUniTaskCompletionSource.Create() のほうがアロケーションが少ないのでこちらを利用すると良いです。Psychic VR Lab ではUnityエンジニアを募集しています！
https://www.wantedly.com/projects/603605


