P/Invokeで、固定長サイズ配列を含む構造体を受け渡す場合、主に下記の2つの方法を用いると思います。
GetMonitorInfoとMONITORINFOを例にすると、下記のような定義です。ネイティブの定義(UNICODEビルド前提で簡略可)この後、unsafeコンテキストでMONITORINFOEX.szDeviceから文字列などにコピーする必要があります。※MONITORINFOEX.szDeviceはstring/ByValTStrにしたほうが扱いやすいですが、対比のためchar[]/ByValArrayにしています。unsafeを使った方がヒープにオブジェクトを作成しない分効率がいいんですが、呼び出し元でもunsafeコンテキストが必要になるので、取り扱いづらいです。
(まぁP/Invokeを使う時点でパフォーマンスを気にしないほうがいいんですが。)ここからが本題です。
昔からですが、StructLayout属性にはSizeフィールドがあり、構造体のサイズを設定出来ます。ただサイズを設定できるだけで、中身を参照しようとするとunsafeステートメントが必要なので、この構造体を使う意義がありませんでした。そこでrefとSpan構造体です。
フィールドの参照からSpan構造体を構築すれば、後はToStringなりインデクサーでアクセス出来ます。
unsafeコンテキストも要らないので扱いやすいです。残念ながら.Net Standard 2.0(.NET Framework)だとMemoryMarshal.CreateReadOnlySpanが無いので、相当するメソッドをunsafeコンテキストで実装する(もしくはライブラリを使用する等の)必要があります。配列の型とサイズ毎に構造体を用意する必要があり定型コードが多いので、自動生成などをしたほうがいいでしょう。
T4テンプレート等で作成してみたバージョンはこちら。


