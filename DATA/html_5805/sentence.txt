More than 3 years have passed since last update.この記事はC# Advent Calendar 2017の4日目の記事です。今年はASP.NETのカレンダーが無かったので、C#枠を一つお借りして書いてしまおうと思います。
去年投稿したASP.NET MVCのフィルターを触ってみたの続編みたいな話しです。MVCのFilterは色々な所で宣言することが可能です。ところで、複数宣言された場合はどうなるのか。後勝ち？追加？？順番は？？？
気になったので実際に実装して検証してみました。まず初めに、Traceログを出力するだけの簡単なFilterを作りました。Controller自体がFillterAttributeを継承している為、直接オーバーライドで各フィルターを実装することが可能です。
このController内に存在するアクション全てに適用されるフィルターになります。FilterAttributeの継承と実装したいフィルターのインターフェースを実装したカスタムクラスを用意します。
（今回は検証の為にAllowMultipleを True にしていますが、同じフィルターを複数回適用させない場合は不要です。）続いてフィルターをControllerやActionに適用させていきましょう。Controllerに直接実装するタイプのフィルターについては、記述と宣言が一緒になっているようなものなので
改めて宣言する必要が無い為、省略しています。Global.asaxから呼び出されるRegisterGlobalFiltersで宣言するパターンです。実際にフィルターを使用したいControllerやActionの属性としてフィルタークラスを宣言するパターンです。通常のパターンと例外発生するパターンの両方を実行してみました。
Traceログを見やすくする為に、改行とコメントは後からいれてます。以下の項目を上から順に判定して決められている。ただし、昇順 or 降順についてはメソッド毎に異なる。昇順と降順については以下のような特徴があるように見える。
メイン処理の「前」に実行されるフィルター処理 → 昇順
メイン処理の「後」に実行されるフィルター処理 → 降順Actionメソッド内で例外が発生した場合でも、例外発生後にIActionFilter.OnActionExecutedメソッドは実行される為、
ここでActionが成功している前提の処理は書かないほうが無難。IResultFilterの処理は実行されない為、「結果が返る！」と分かったときの処理はここに集約する。IExceptionFilter.OnExceptionは実装されている全てが呼び出される。
（今回の実験結果には含まれてないが）Resultの値は後勝ちになるので、注意が必要。


