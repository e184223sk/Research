More than 3 years have passed since last update.Dependency Injection は Autofac を使っていたのだけど、.NET Core を使い始めると、Microsoft製のMicrosoft.Extensions.DependencyInjection がシンプルでよいという話を同僚から聞いたので、その基本をまとめておきたい。公式ページはこちら実際に私はASP.NET というより、Azure Functions で使うことを想定していますので生の基本的な挙動を理解したいと思っています。次のようなクライアントとそのインターフェイスがあるとします。DI コンテナにISomeClient インターフェイスをキーに、SomeClient のインスタンスを返却するには次の通り。DIの情報が格納されるコンテナはServiceCollectionクラスです。これが主要なパーツになります。そこに登録していきます。ここでは、Singleton というスコープで登録していますが、スコープに関しては次に説明します。AddSingleton&lt;ISomeClient, SomeClient&gt;() によって、ISomeClient でインスタンスを要求されたら、SomeClinet が返却されるという作りです。利用する側は次のとおりです。BuildServiceProvider() メソッドを実行してIServiceProvider を獲得し、GetRequiredService もしくは、GetServiceメソッドを使って登録したインスタンスを獲得します。GetRequiredService の場合、もしインスタンスがなければ Exception がスローされ、GetService の場合は、nullが返ってきます。とても簡単でした。依存性を注入する場合、３つのスコープを使うことができます。上記のことをテストしてみましょう。OtherClient の方は、SomeClient と全く同じつくりにしています。ちなみにOtherClient の方は書き方を変えていますが、意味は同じで、このように、返却したいインスタンスを作るファクトリの関数を持たせることもできます。呼び出してみましょう。Scoped は ASP.NET がないと検証が厳しいので省いて、今回は２つに絞ってやっててみました。Singleton の場合は、インスタンスが一つですね。ちなみに、スコープの他に、TryAdd... 系のメソッドも用意されていて、もし、すでに登録されていたら登録をスキップ的な使い方をするようです（試してませんが）実際にDI のコードを書いていると、ある特定の時に、コンフィグレーションオプションを使いたくなる時があります。そのようなときのための機構も用意されています。　ご覧の通り、登録する時に使うオプションをコンフィグできて、BuildServiceProvider()が実行される前にコンフィグを注入しています。複数のクラスがあって、それを組み合わせてインジェクションするのも簡単です。例えば、SomeClient をもった SomeService をインジェクションしたい場合、コンストラクターインジェクションは何も意識せず実行できます。上記のようにコンストラクタにISomeClient をしておいて普通に登録します。すでに、ISomeClientが登録ずみならこれでOK. 名前の解決結果次のような形で自分独自のメソッドを定義したい場合はServiceCollection の拡張メソッドを使います。ちょっとかっこいい！特に、複雑なインジェクションをしたい場合、それを隠蔽するために、特別なメソッドを書いたりすると利用するほうが便利です。拡張メソッドを定義しましょう。今回は単にSingletonにデリゲートしているだけです。基本的な ServiceCollection の使い方は大体カバーできているのではないでしょうか？ASP.NET もDIを基本的に使うようになっているので、テスタビリティの向上が期待できます。（本当は Azure Functions もそうしてよと思いますw）ちなみに、このライブラリを拡張して、もっと便利にインジェクションできるようにしたライブラリもあります。というものです。海外のイケメン系の人はだいたい次にこれに流れるっぽいですが、次の機会に。また、英語ですが、ちょっと凝ったユースケースに出会ったので、そのやり方もブログに書いておきました。


