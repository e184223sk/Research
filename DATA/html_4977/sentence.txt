More than 1 year has passed since last update.RESTfulサービスが流行っているせいか、アプリケーションからHTTPのリクエストを投げたいことが多くなりました。HTTPリクエストと言えばHttpClientですが、使い方をすぐ忘れてしまうんですよね。まとまって書かれたサイトもない気がするので、まとめを兼ねて載せておきます。HTTPメソッドに対応したメソッドがあるので、それを呼べば良いです。HTTPメソッドは、TRACEやOPTIONSもあるのに、なぜかPATCHがありません。（WebDAV系のメソッドもありません）HttpRequestMessaageを使い、SendAsync()を呼ぶ方法もあります。URLエンコードは FormUrlEncodedContentを使ってしまうのが早いです。実際に送られるリクエスト：（UTF-8でエンコードされる）POSTやPUTで普通にリクエストパラメータを送る場合は、FormUrlEncodedContentを使えば良い…　のですが、スペースが + にエンコードされてしまいます。(クエリストリングは + で、それ以外は %20 でエンコードされるのが正しいらしいですが、大抵のWebサーバーはどちらでも解釈してくれると思います)実際に送られるリクエスト：（Content-Typeが自動的に設定される）文字列をそのまま送りたい場合は、StringContentを使えば良いですが、Content-Typeは text/plain になります。実際のリクエスト：Content-Typeを application/json や application/xml にしたい場合は、StringContentコンストラクターの第３引数で指定します。実際のリクエスト：文字列ではなく、バイナリーデータ（byte配列）を送りたい場合は、ByteArrayContent を使います。Content-Typeは次のように設定します。実際のリクエスト：スペースが + でエンコードされるのがどうしても気に喰わない人は、自分でエンコードしてStringContentを使えば良いです。StringContentの第３引数やヘッダーに設定（すぐ後で説明します）すると、System.FormatExceptionが発生してしまいます。ByteArrayContentを使いつつ、HttpContent.Headers.TryAddWithoutValidation()で無理矢理設定します。実際のリクエスト：ヘッダーを送りたい場合は、HttpRequestMessage.Headers.Add()で設定すれば良いです。実際のリクエスト：不正なヘッダーを送りたい場合は、HttpRequestMessage.Headers.Add() を使うと System.FormatException が出るので、TryAddWithoutValidation()を使います。ただし、これを使っても付けられないヘッダーがあるので、実際に設定できたかどうかは戻り値の bool を確認したほうが良いでしょう。実際のリクエスト：普通にAuthorizationヘッダーを送ればよいだけです。実際のリクエスト：単にステータスコードが欲しい場合は、StatusCodeプロパティで取得できます。400以上はエラーなど、範囲で比較したい場合は、intにキャストすれば良いです。200 OK や 403 Forbidden のようなステータスコードに対する文字列が欲しい場合は、ReasonPhraseプロパティで取得できます。HTTPのバージョンは、Versionプロパティです。Contentプロパティにボディが入るので、文字列(ReadAsStringAsync())、byte配列(ReadAsByteArrayAsync())、ストリーム(ReadAsStreamAsync)、別ストリームへコピー(CopyToAsync)で取得できます。Headersプロパティで取得できますが、型はHttpResponseHeadersで実体はIEnumerable&lt;string, IEnumerable&lt;string&gt;&gt;となっています。次のコードは、X-Hogeヘッダーを取得する例です。ValueがstringではなくIEnumerable&lt;string&gt;となっているのは、同一のヘッダー名が複数ある場合（例えば Set-Cookie）があるからです。また、ヘッダー名は大文字・小文字を区別しないので、string.Compare()を使ったほうが良いでしょう。かなり面倒です。HttpClientの同一インスタンスでクッキーを自動的に（ブラウザがやるように）受信・送信をするなら、HttpClientHandlerのUseCookieプロパティをtrueにするだけです。クッキー自体はHttpClientHandlerのCookieContainerにあります。HttpClientHandlerのCookieContainerでもいいですが、（UseCookie = falseやHttpClientインスタンスを毎回生成しているため）自分でリクエストヘッダーにクッキーを設定する方法もあります。逆にクッキーをレスポンスから取得する場合も、生ヘッダーから取得できます。Timeoutプロパティで指定します。デフォルトは100秒です。（次の例は、５秒に設定する場合）System.Net.ServicePointManager.ServerCertificateValidationCallbackで設定します。HttpClientHandlerのAllowAutoRedirectプロパティでfalseにします。HttpClientHandlerのProxyプロパティで指定します。HttpClientインスタンス毎に指定する場合は、DefaultRequestHeaders.ExpectContinueで設定します。すべてのリクエスト（すべてのドメイン）に対して共通に設定して良いなら、System.Net.ServicePointManagerで設定します。Connectionヘッダーを付けないようにすることはできないようなので、Connection: closeを送るようにします。ちなみに System.Net.ServicePointManager.SetTcpKeepAlive()メソッドのkeep-aliveは、別物です。デフォルトでTLSの何のバージョンが有効になっているかは、.NETのバージョンに依るため、古い.NETのバージョンではTLS1.1やTLS1.2が有効になっていない場合があります。古い.NETのバージョンで定数(enum)が定義されていない場合は、数値を直接指定すれば良いです。ServicePointManager.DnsRefreshTimeoutプロパティで設定します（ミリ秒）。デフォルトは２分。-1を指定すると無制限になります。ちなみに、ServicePointのConnectionLeaseTimeoutは関係ありません。コネクションプールの話は、これだけで１回分になりそうなので、この記事には含めませんでした。それ以外については、よく使いそうなものは大体書いたつもりです。


