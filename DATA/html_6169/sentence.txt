More than 3 years have passed since last update.C# で Generics を触る必要があったので、しょぼーいプログラムを書いてみた。Generics を体にしみこませるためには、まだまだやけど、最初の一歩としては悪くないだろう。C# の Generics に関しては非常にディープな解説がここにある。素晴らしい。何も付け加えるものが無い。このブログはいつもそうだけど、自分がプログラミングの勉強用に書いているものなので、あまり、参考とかではないと思うけど、自分のために書きます。ジェネリクスの目的は型に依存しないコードを抽象化するというところだと思います。本来型の種類ごとに書かないといけない処理を、一つのコードで書くことができます。もちろん何にでも書けるわけではありません。先ほどのブログを見ると、C# の Generics はかなりイケているらしく、コードによっては、インターフェイスを使った抽象化より、処理が高速だったりするケースもあるようです。今回、ジェネリクスを調べている動機は、先日から作っているコードで、どうしてもカッコいい API が作れないところがあったので、それを何とかしたいと、師匠に相談したら、ジェネリクスと、リフレクションを使った超カッコいい解決策をしめしてくれました。　単にマネするのではなく、師匠の教え通り、自分で試して簡単なブログを書いて、自分にしみこませてからコードを書こうと思っています。ジェネリクスのコンセプトは、「知って」いましたが、利用する以外に自分がコードを書く場面がありませんでした。全然ちがった２つのクラスがあって、その属性が全部値が入ったら、Completed() メソッドが true になるというコードを書いてみます。対象のクラスの属性数は違うので、リフレクションは次にとってあるので、そのままだと、インターフェイスでプログラミングを考えてもできるのですが、強引にジェネリクスのコードを書いてみました。C# では、default という、型に対して、デフォルト値をとるというメソッドがあるみたいなので使ってみます。参照型はnull 数値型は0になります。各属性をしらべて、値が未代入ということは、default になっているということだろうということで、default の値と、引き渡された値が違っていれば trueを返します。
ここでポイントは、where T: IComparable という指定で、型はなんでもいいけど、IComparable インターフェイスを実装しているものという制約をつけています。それを where で制約をかけれます。通常ジェネリクスだと、型に対してメソッド呼び出しできませんが、こうやって、制約をかけると、メソッド呼び出しができます。ただ、このコードの場合は、結局 null があったら、うまく CompareTo() が動かないので、null チェックをしないといけないので、あまり default とか、CompareTo とかのうまみがありませんね。でも、最初のジェネリクスプログラムとして、各要素を学びました。全体では各クラスは、Base のスーパークラス内の、ジェネリックメソッド IsNotDefault(T a) を利用しています。各属性の数が違うので、今は手書きで、このメソッドを呼んでいます。実行結果思いっきり車輪の再発明ですが、勉強のためにはいいでしょう。バブルソートをジェネリクスで自分で実装してみます。使っているのはさっきのテクニックを超えたものではありません。IComparable をもった要素のリストならソートしますという内容です。内容がスワップとかそんなレベルなので十分ジェネリクスでコーディングできます。実際にコードを書いているときは、最初は Select を使ったディープコピーをしようとしましたが、普通に考えてシャローコピーでいいのでこの方法に落ち着きました。そういう試行の過程がいいですね。実行結果


