More than 3 years have passed since last update.　NUnitもバージョン3になって、気づかないうちにメソッドが色々追加されていました。特にテストコードのモデルが新旧で区別されていたらしく、旧モデルしか書いていなかった自分への戒めとしてこの記事を残します。
　旧モデルは互換性を保つためにそのまま残されているみたいですが、コードのメンテはほとんどされなくなるみたいです。今、旧モデルでテストを書いてる人がいたら新モデル1への移行も検討したほうがいいと思います。　今回検証した環境はVisual Studio2015、NUnit 3.4.1です。記事の対象はテストコードを書いたことがある人です。　旧モデルと新モデルの違いは実際に見てみるのが一番早いと思います。　一例　 旧モデルでもシンプルに書けますし、あらゆるテストを書くことができます。実際、私も旧モデルでテストを書いてきました。グーグルで「NUnit 入門」で調べると「Assert.AreEqualが使えればOK」といった内容がゴロゴロ出てくるので、多くの方にとって馴染みのある形だと思います。
　では、なぜ新モデルを使うのかというと以下の3つが理由として挙げられます。　1に関してはこれから使い方を見ていくうちにわかると思います。2に関しては次章のAssert.Thatの使い方を見てもらえればわかると思います。　余談ですが、Assert.ThrowsはNUnit2.5からの追加要素で、Assert.Thatより後に考案されたものなのですが、既に旧モデルに分類されているようです。　基本的にこの構成さえ覚えておけば多種多様なテストコードを書くことが可能になります。　制約では以下の4つのクラスを用いて、期待する結果の記述を行います。いずれもNUnit.Framework名前空間3のクラスです。　実際の使用例を使って、どのような記述ができるのかを見ていきます。これまで挙げた例では単一の制約のみを扱っていましたが、複数の制約を合成することが可能です。　NUnitには新モデル1と旧モデルがあることがわかりました。
　従来、複数のメソッドを使い分けて行っていたアサーション2をAssert.Thatメソッド一つで行うことができるようになりました。正確には2016年9月時点のモデルです。このモデルもいつまで続くかわからないので。 ↩テスト対象の状態を確認すること、検証 ↩流し読みすると.NetFrameWorkと読んでしまいそうですね。 ↩ver2.9.1のときはなかったので最近と書きました ↩


