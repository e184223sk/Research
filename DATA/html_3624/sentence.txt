More than 1 year has passed since last update.Linq書いてみたくなった。
というのも、マスタ系の静的なデータだったら、都度DBにアクセスするよりも保持しておいてもいいよね。
あと、更新したかどうかを照合するために持っておくとか。
で、それをC#のDataTable型で保持しておいて、それ同士にjoinかけないかな、と。
で、欲張って複数項でjoinが必要な場合まで想定してみて・・・と思ったらはまったという話。反省は文末にするとして、具体的な話に続く。。。※追記ありです※
コメントいただいたおかげで、泣き言言ってたり妥協してた個所がだいぶ改善している・・・はず。
※も1個追記いただきました※
文末に追記です。Windows 8 Pro x64
PostgreSQL 9.6.11
Visual Studio 2017
.netframework 4.6.1
Npgsql 4.0.5項目1つでJoinできる間柄と、項目2つでJoinできる事柄を想定して以下のようなダミーデータを作った。まずは商品マスタ(m_item)で名称と値段を持つ。
販売の実績をレシートデータ(t_receipt)に持ち、販売数量を持つ。
併せて、性別{1, 2}と年代{1,2,3}を持つ。
で、性別年代別にアットランダムに割引するような感じで、割引対象(target)を
割引対象選択(t_coupon)にもつ。だから、商品マスタとレシートデータが商品IDでJoinする。
また、レシートデータと割引対象が性別と年代でJoinする。まずは、1項目のjoinだけを対象。
tbl.AsEnumerable()
と、
tbl.Rows
の二通りの書き方があるみたいだからそれぞれ書いてみた。
それがquery1とquery2。ここまではまあよし。で、そのままだと2項目でのjoinの書き方が分からなかったので別な書き方で書いた。
それがquery3とquery4。ぐだぐだ。出力はまあ・・・適当にMessageBox.Showしてみたくらい。うーん・・・query1とquery2に関して、目的が「簡単に書きたい」なので、そういう意味ではquery2が優勢。
ただ、途中でcase書かないといけなかったのでちょっと微妙。
長くてもIntellisenceが助けてくれるんだから、そういう意味ではquery1がいい気がするわ。で、query3とquery4は・・・ないな。
やむを得なかったら使うかもだけど、ここまで煩雑に書かないといけないのなら直接SQL書きたい。。。改めて、query1を見てみると・・・うーん・・・そんなに冗長でもないよね?
「AsEnumerable」の表現にちょっと面喰っちゃったけど、改めて考えてみると妥当な気がしてきた。
・・・いや、「妥当」というか、「自分の理解の範囲内に落ちる」という感じ。だって、DataTable形でtblを持っているとして、(書き方A) foreach row in tbl
(書き方B=query2) foreach row in tbl.Rows
(書き方C=query1) foreach obj in tbl.AsEnumerable本音は書き方Aで書きたいところだけど、tblは繰り返し構造を持つけど繰り返し構造そのものではないからNG。
だから、テーブルの繰り返し構造を示すと、書き方Bになる。だから、r["amount"]とかはDataRow型で、int型じゃないので直接掛け算はできない。
じゃあ、となると、Asである意味型変換した感じで書き方Cになる。
まあ・・・castを嫌わなければ文字数減らせるから書き方Bがいいかも?あと、query3,query4はお手上げ。
そもそもあんな冗長な書き方をしている時点で理解できてない気がする。
まあ・・・当面、query1かquery2の書き方で書いてみて、見えてきたら改めてこの記事書き直そうかな。
その時のタイトルは、「C#手遊び(Linqもっとまじめに書いてみた)」とかで。。。コメントいただきました。ありがとうございます。■Join by using composite keys
https://docs.microsoft.com/ja-jp/dotnet/csharp/linq/join-by-using-composite-keys正直言うと、このページ、query3とかquery4を書くとき一度見ました。
でもその時は・・・よくわからなかった!
というか、「into deatils」という表現自体が全然別の目的の話だと思って違う件だと理解(誤解)してた。で、せっかくいただいたコメントみて、「あっ、違ってないってことね?」と。
で、写経していじってみて・・・なるほど、と。
で、できたのがこれ。タプルで行けましたね。あと、これいいですね。書いてて思った。
C#のメリットはかなり強い型付けだと思っていて、直感的には「多少ミスってもコンパイラが見つけてくれる」って感じ。
ただ、(int)とかってcastしてしまうとコンパイラに対して、「君、チェックしなくていいから!」って言っている感じ。
なのでそのメリットが失われてしまう。正直ヤだ、そんなのできれば書きたくない。
ホントいうと、row["項目名"]もヤなんだけど、よく考えたら一度通過テストをするとミスがあっても絶対拾えるから・・・じゃ、いいか、と。
だったら、query3,query4のような中途半端な書き方ではなく、これがいいね。教訓：ちゃんと公式読めるようになろう！本音：munielさんありがとうございます！albireoさんありがとうございます。
一部抜粋して要点だけ。ですよね～迷走中に、にゅーにゅーいってて、なんかヤだな・・・って思ってました。
どう考えても、今どきの洗練された言語の書き方じゃない・・・
けど、その時点(この記事の初版書いた時点)で、あたしのベストだったので、「あ～これ、ぜったい書き方わかってないわ～」とおもってました。すみません。。。なるほど。そりゃそうですね。ここら辺はSQL書く時の考え方に通じるところありますね。ごもっとも。この点はこの投稿では端折ったところでした。
動的に任意のテーブルを相手にできることを目的にしたかったということもあります。
しかしこの記事を通してみると、そこに意固地になるより素直にクラスを作ったほうがいい気もしますね。やっぱ、Listとかやって使うとVisual Studioがかなり助けてくれるのが心地いですよね!


