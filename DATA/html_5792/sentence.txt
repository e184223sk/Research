More than 3 years have passed since last update.処理の委譲とかDIについての記事をいくつか読んだので、具体的な実装を追って理解を深めてみたいと思います。
DIについては軽く触れる程度となります。例として、APIを呼び出してその結果を取得する処理を書いてみましょう。戻り値のJsonをパースして、最初の記事のタイトルを出力する処理ができました。さて、ここで戻り値の型がMessagePackの場合もあるとします。シンボルを定義して処理の書き分けをしてみましょう。なんと、本番環境では戻り値をgzip圧縮して暗号化することにする、と連絡がありました。対応してみましょう。……往々にして、このようなコードが出来上がることは良くあります。さて、ここで処理の委譲を活用していきましょう。
WWWを引数にresultを取り出す処理が複雑になってしまっていたので、そこをインターフェース化します。戻り値がJsonの場合、MessagePackの場合、本番環境の場合の3通りのDeserializerを作ってみます。IDeserializerを利用して、先ほどの処理を書き直してみましょう。#ifによる処理の分岐が消えてスッキリしました！
また、JsonやMessagePack、gzip展開などの処理はIDeserializerが行うことになったため、GetItems()はそれらに依存しなくなりました。先ほどの例ではdeserializerの初期化が省略されていました。これはどこかで定義しておく必要があります。
deserializerを代入する処理まで書いた例を見てみましょう。deserializerを外部から代入できるようにして、初期化時に利用するIDeserializerを選択して代入しています。
実はこれはDIパターンとして成立していて、フレームワークなどは利用していませんがDIを実現しています。このように、場合によって処理が変わる、依存関係をなくして疎結合にするといったことを実現するためにDIが利用されます。
Unityの場合DIフレームワークとしてZenjectというものがあり、単純なDIの他にも便利な機能があるので使い方を覚えてみるのも良いと思います。


