More than 1 year has passed since last update.PhotonUnityNetworking2を使う機会があり、そこで実際に触って色々知ったことを書きました
この記事を見て何かの足しになれば幸いです
※普通にRPCやRaiseEventなどの用語を出すのでPhoton触ったことある人向けです・Unity2019.3.3f1
・PUN2 v2.15RPCを使って同期処理を行う場合、引数に送信先を指定する部分がある
ここで「All」「AllBufferd」を指定すると自分のローカル環境で即座に実行された後、他のクライアントに同期通信を飛ばすようになっているが、実は処理速度的にはあまり良くは無いこれはPhotonNetworkPart.csにあるRPC関数の中身を見ると分かるが、通信同期用の情報をハッシュテーブル化した後に自分の環境で即時実行するため、わざわざハッシュテーブル化した情報を分解して処理を実行している
※下記コードのrpcEventがハッシュテーブル、ExecuteRpcが実行関数シンプルな対処法としては同期処理を飛ばす前に、一度その同期処理を自分の環境で実行してから「Others」「OtherBufferd」を呼び出すと、無駄がなくなってスッキリする但し上記のやり方だとRPC呼び出し前に自分の環境で同期処理を呼び出し忘れる危険性もあるので、何かしらラッパー関数を用意する、もしくはPhotonView.csのRPC関数を拡張する、などをした方が安全性が上がる
もしくは「AllViaServer」「AllBufferedViaServer」を使うという方法もあるが、送信者自身も通信を介して処理が実行されるので一長一短ではあるRPCはPUNのコードを見ていくと分かるがRaiseEventのラッパーになっており、基本的にPhotonViewがGameObjectにアタッチされていれば気軽に同期処理が行えるようになっている。そこまで同期処理でパフォーマンスを気にしない、PhotonServerを使用しないなどの条件に該当するのであれば、RPCだけ使うという方法でも十分と言える
しかしPhotonViewの数が多くなるほど、処理負荷が顕著になっていくRPCは同期処理を実行する際にGetPhotonViewという関数を内部で実行しているが、これはシーン上にあるPhotonViewコンポーネントがアタッチされているオブジェクトを全て取得して、その中でIDが一致するものを返すという処理を行っている
これがRPCが実行されるたびに毎回呼ばれるので、PhotonViewが多いほどかなり負荷がかかる上記処理の後はMethodInfo というReflection機能を使用して指定した関数を取得して実行処理を行っている。こちらに関しては一度呼び出されたものはキャッシュして使い回す機構にはなっているものの、ランタイム上でリフレクションはあまりよろしくないこの事からPhotonServerを使用する、パフォーマンスチューニングをがっつりやらないといけないなどの理由がある場合、手間は掛かるが拡張性やカスタマイズしやすいRaiseEventを使った方が結果的に良いと思われる
※PhotonServerとのやり取りは基本的にRaiseEventベースになっているため、RPCでPhotonServerと連携するのは難しい？結論：適用されました
(RaiseEventの自作カスタムタイプ周りがどこにも載っていなかったので出来ないものだと思ってた)CustomType.csと同じような形式でシリアライズとデシリアライズを定義して、PhotonPeer.RegisterTypeで登録処理を実行すると、RaiseEventを使用してデータを送受信した後の型変換処理も問題なく通る間違っているところがあれば指摘お願いします
Photonは結構奥が深いのでまた何かあったら追記予定です


