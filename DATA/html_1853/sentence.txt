C#の単体テストで期待値の確認は「Chaining Assertion」というライブラリがとても便利でお勧めです。
Chaining Assertion の公式サイトはこちらテスト記述ライブラリで有名なものとして「Fluent Assertions」があります。
Fluent Assertions の公式サイトはこちら
それを用いてテストする場合、以下のように書きます。
（標準のAssertクラスよりも書きやすいので、こちらのライブラリもとても素晴らしいと思います）これに対して、Chaining Assertion は、Should().Be() でなく Is() だけで確認できるため、よりシンプルに記述できます。Fluent Assertions は期待値を確認するためのメソッド(BeNull、HaveLengthなど)をたくさん提供しています。これは一見すごく多機能で便利なのですが、実際にテストコードを書くときには適切なメソッドを調べることになるので意外と手間がかかります。
例えば、値が0以上10以下であることを確認しようと思った時に、範囲指定のメソッドがあるので、以下のように記述します。Fluent Assertions の数値型の確認メソッドはこちらそれに対して Chaining Assertion は、シンプルに Is メソッドのみで期待値を確認します。Is の引数にラムダ式を書くことで、Is だけでどんな期待値も確認できます。以下のような感じです。C#開発者は、ラムダ式を書き慣れているので、確認したい内容に合わせてメソッドを探すよりも、全部ラムダ式で書く方が楽だと思います。
（これに関しては個人の感想ですが、私のチームで両方のライブラリをそれぞれ一定期間使ってみたところ、いずれのメンバーも Chaining Assertion の書き方の方が気に入りました）コレクションに関しては、Fluent Assertions はコレクション用のメソッドもいっぱいあります。適切なメソッドを探すのが少し手間です。Chaining Assertion 作者の河合さんが以下の記事で解説されているように、コレクションは慣れ親しんだ Linq to Objects で結果まで絞って True/Falseを判定する方が楽だと思います。
neue cc - メソッドチェーン形式のテスト記述ライブラリChaining Assertion の便利機能を紹介します。期待値を確認するときに、privateメンバーにアクセスしたい場合があります。
その場合、PrivateObjectクラスを利用してアクセスします。ただ、PrivateObjectの実装は、PrivateObjectのインスタンスを作ってからそれを通してアクセスする必要があり、少し面倒です。
PrivateObjectクラスの実装例Chaining Assertion なら、privateメンバーへのアクセスを簡潔に実装できます。
具体的には、object型の拡張メソッドであるAsDynamic()メソッドを利用することでprivateメンバーにアクセスできます。
例を以下に示します。あるインスタンスを複製するメソッドを作った場合、その複製されたインスタンスのフィールド値および、そのインスタンスが保持しているオブジェクトが複製元と一致するか確認したい場合があります。
Chaining Assertion なら IsStructualEqualメソッドを呼び出すだけで、複製したオブジェクトのフィールド値およびそれが保持するオブジェクトについて、参照をたどって再帰的に確認できます(publicなフィールドまたはプロパティを確認します)。
以下に例を示します。ただし、相互参照している場合は無限ループとなるため注意が必要です。
そのあたりの挙動を変更することも可能です。Chaining Assertion はインストールするとDLLを参照するのでなく、ソースコードを1ファイル追加するだけなので、そのソースコードを変更することで、自前で挙動をカスタマイズすることもできます。Chaining Assertion は便利なのでお勧めです。ちなみにこの記事の投稿時点で、更新が止まっているライブラリですが、素晴らしいライブラリだと思うので投稿しました。リツイート元の通り、更新が止まっているライブラリですが、素晴らしいライブラリなので、以下の記事をQiitaに投稿しました。C#の単体テストは「Chaining Assertion」が便利https://t.co/BpyFILQMKb https://t.co/MbL8FCygVqTwitterでも開発に役立つ情報を発信しています → @kojimadev


