More than 3 years have passed since last update.または私は如何にして数学的手法を止めて力ずくで文字列差分を取得するようになったか二つの文字列の差分を抽出したかったんです。
最終的な目的はさておき、まぁやるならうーさんのアルゴリズムを使うことになるんだろう、位に軽く考えていました。結果—
うーさん、良く分からないよ…あっちこっち解説サイト（限る日本語）探して読み漁るもイマイチ腑に落ちない。
いや、えー、全体的な流れは大丈夫、きっと分かってる筈。何がやりたいのかイマイチぴんと来ない。すっごい細かい処の説明に終始していて、それらがどいう風に繋がっているのか伝わって来ない。
それらを最初にきちんと説明して下さいよー、うーさん。あ、うーさんは説明してくれているのかも知れない。
私、英語不自由な身なので、そこに当たれていないだけ。日本語解説してくれている人たちはそんな事は充分すぎるほど分かってるんで説明する必要性を感じていないのかも知れない。うん、きっとそうに違いない…尚これ以降、多分に感覚的な説明が中心になります
数学的・論理的に厳密な話がお好きな方はごめんなさい取り敢えず最初に、うーさんの方法の目的をおさらいしておこう。文字列１に対して、「１文字削除」「１文字挿入」を繰り返して、文字列２に変形する方法を計算する。ルールは以下の通り。と云う問題ですね。

そこで、うーさんは考えた…
文字列１は文字列２よりDelta文字だけ長いから少なくとも「１文字削除」をDelta回は行う必要があるのは明らか。
逆の表現をすると、コストDeltaで進むためには、以下の図の黄色いマスの格子辺・対角線（ごめん、破線はDelta説明用の補助線として引いただけで、対角線じゃないんです）からはみ出さずに進めた場合だけである。（はみ出さなかったからと云って、コストDeltaで進めるとは限らないけどね）そこで、最小コストはいくつであるかを以下の手順で探っていこう！
と云うのがうーさんの方法である（筈なのである）。上記がうーさんの論理構成じゃないかと理解した。

そして可動範囲を絞りながら、そこに許されたコストで進める範囲を上手い事判定するナイスな方法が存在する！　と云うのがうーさんアルゴリズムの肝。で、そのナイスな方法ってのは先達の皆さんが解説して下さっている。
例えばこちら。
その方法の解説に関してはそちらにお任せしよう。

実は、私が今分かっている所はここまで。
という事が分かったよ。（ナイスな方法ってのが充分理解できていない事も含めて）
ふー致し方ないので、うーさんのアルゴリズムを実装。各種状態をトレースして確認作業をしていこう。以降、例としては基本的にうーさんの論文にある文字列を使う。
これね↓（この表の作成法に関しては前述のサイトなどを参照して下さい）
で、こんな感じのコードでテストをしたと思ってね。
※ VArrayについては別稿を参照のこと。（これがやりたかったのだよ）おー、ここで思い出した。うーさんの論文では、縦軸をx・横軸をyで表すと云う変態グラフが使われているんですが、何とも取っ付き難いので本稿では一般的な数学グラフと同じyを縦軸・xを横軸になる様に表現しておりま…あれ？　数学グラフでもないぞ…
Windowsディスプレイの座標系だfp[]の値が気になるところなので、そこを中心に攻めてみる。

で、こっちから法則性を検証してみるという事で。

ふむふむ、あぁ～、なるほど。
ここで、例の図が出てくる訳ね。

fp[]はこの赤破線群に対応している訳だ。そしてその中身は「最遠点」って言われてるxの値だな。ただここでは最遠点が何であるかは置いとこう。いずれ明らかにするつもりで…そう云う事でkの値はこのラインの識別子で、取り敢えずpの方は「寄り道レベル」とでも名前を付けちゃって、k=0のラインを「スタートライン」、k=Deltaのラインを「ゴールライン」、全体を纏めて「Ｋライン」と呼ぶ事にしよう。
もう一つ、最初に(0,0)位置に赤丸を置いて、これを「カレントポジション」って名前を付けましょうか。
そこで、既出のルールを改めてここにマッピングすると、やりたい事は次の様になるかな。一応確認までにここで再掲するが、カレントポジションの移動方向についての制約が存在する事と、寄り道レベルに応じて許容されるコストに上限がある事を忘れてはいけない。なので、ゴール判定ってのが次の式で表される。つまり—fp[]表を寄り道レベル毎に評価を繰り返して、最終的にゴールライン上にあるfp[Delta]の値が文字列１.Lengthになった時が終着点って事になる。で、最遠点の意味が分かった。各寄り道レベルにおける許容コストで進めるx方向の最大値だ！
って、何だそのままじゃん。

さて、ここからが正念場。
fp[]の値はどうやって導かれるか、だ。
上手く説明できるかな…寄り道レベルpにおけるfp[n]の値は、寄り道レベルp-1におけるfp[n-1]とfp[n+1]の値から導かれる—
ってのが、うーさんの云いたい事だ。何故ならば、k=nのライン上にカレントポジションを移動させるという事は、取り敢えず隣のＫラインから移ってくるしか方法はないからね。（対角線に関しては後述するので、ここでは対角線はない状態だけを考えてください）カレントポジションの移動制限と考え合わせると、k=n-1ラインから移ってきたときにはx方向には１マス分進めるが、k=n+1ラインから移ってきた場合にはx方向への進展はない。また、k=nラインへの移動が行われるパターンが二つ存在する（k=n ± 1）けど、k=nの評価としてはそのうちのより値の大きい方を採用すれば良い、と云うのは特に問題ないよね。ところで、fp[n]ラインを評価した結果、その位置に対角線があったらどうなるだろう？
「そりゃぁ思わず脚踏み外して滑り落ちていくよねー」って云うのがうーさんのSnake関数だ。（私的にはSlopeとかSliderとかそういう名前にしたい所だな）結果、落ちるところまで落ちた先のx値が最終的な評価結果になるって訳。上での結果を文章に起こすと—寄り道レベルpにおけるfp[n]は、寄り道レベルp-1におけるfp[n-1] + 1とfp[n+1]のうち、大きい方の値をSnake関数で評価した結果となる
さて、ここから最後の仕上げ。
各々の寄り道レベルにおけるfp[]値を、「具体的に」どうやって算出していくかだ。計算のゴールを再確認しておこう。ゴールライン上のfp[Delta]の値が文字列１.Lengthの値に等しくなったときつまり、下の図のピンク色の所を計算で求めよう！
ってのが目的だな。で、前述したように、fp[Delta]の値はfp[Delta ± 1]から導かれる。
こういう事（下図）。ちゅー事は、fp[Delta]の値を求める前には、まずはfp[Delta - 1]の値が判明していなくてはならない。で、fp[Delta - 1]の値を求める前にはfp[Delta -2]の値が確定していなくてはならない。fp[Delta - 2]の値が（以下繰り返し）…結局、こういう事。だから、fp[-p]からfp[Delta - 1]までfp[]値を確定させていく。つまりゴールラインに向かってfp[]値を確定させていく訳ですね。ゴールラインの右側も同様にゴールラインに向かって確定させていけばいいので、fp[Delta+p]から始めてfp[Delta + 1]までfp[]値を確定させていく。そこまで行って最後のダメ押し、fp[Delta ± 1]の値を使ってfp[Delta]の値を決定すれば、寄り道レベルpにおけるfp[]値が全て確定する。この一連のfp[]値決定プロセスを繰り返して、fp[Delta]の値が文字列１.LengthになればComplete、繰り返した回数が「寄り道レベルp」って事だ。

ふー、長かったけど達成感よしっ、じゃぁ早速文字列の差分を計算してみよう！
って、あれ？今まで解き明かしてきた方法で分かったのは、寄り道レベルだけだぞ。
上の例では寄り道レベルp=2だったので、文字列変換をするのにp * 2 + Delta = 6 回の１文字削除・１文字挿入が必要になるよー、ってのが判明しただけ。うん、識者の方々も変換手順を実装するには、それ用のコードが必要だと仰っておられる。ルート探索に一番メモリが必要だとも言っている。
うーん…と云うのが、第一のタネ。

ま、それはちょこっと横に置いといて、力技でルート探索しましたよ。ただ余りにも力技過ぎて恥ずかしいのでソース掲載は控えたい。で、ルートを結んで出てきたのが下図。違和感満載…なんで、最後の３文字セットを採用しないかなぁ…
人間の感覚には合わないよね。所詮、LCSを求めるための数学的アルゴリズムであって、自然なルートを探索するアルゴリズムではない…
んだろうなと激しく思った。と云うのが、第二のタネ。

そんじゃ、うーさんアルゴリズムを改良して、上記悩みを解決しよう！
って意気込んではみたものの、それ無理ですから。結局、うーさんのSnake関数の呪いですね。だって坂道踏んだら必ず滑りこけてしまうんだもん。その先にもっと良い手があるかも知れない、何てTry&amp;Errorしてたら、折角の綺麗なアルゴリズムが台無しになってしまう。

早い話が、うーさんのアルゴリズムはLCS求める以外には使い出がない、って事になるんですかねぇ…
全探索をする訳でもなく最小の手数だけで答えを探索しているからね。
綺麗なアルゴリズムなんだけどなーそこで、私は考えた…
これは虱潰すしかないな。（安直）しかし、虱潰すっても効率の良い潰し方がある筈。
うむうむ、折角うーさんが良い表を作ってくれてるし、あれを利用しない手はないよ。方針としては、うーさんのアルゴリズムでは思わぬ伏兵であった「スライダー」。あの一覧を作って、その総当たりって事で如何でしょう？対象としては、マス一辺ずつ相手にするより遥かに少ないよね。
しかも、連続する対角線はそれを１スライダーとして扱う、となると横入りはなくなるので、人間っぽいルートが常に提示される筈。つまり、抜き出したスライダー全てに対して総当たりを行って、例えば下図の様な順番でスライダーが選ばれたとしたらその間を横・縦のマス移動で補完することにより、全体のルートを確定させるという寸法だ。でも、これだけではまだ効率が悪い。ここでうーさんのアイディアをパクっ参考にさせて頂いて、更に探索対象を絞っていこう。勿論ここで採用すべき考え方は「寄り道レベル」だ。
つまり、寄り道レベルp=0なら、この黄色い範囲のスライダーのみ対象とする。寄り道レベルp=1ならば、上下に一マスずつ拡張したこの色付きの部分に含まれるスライダーのみ対象とする…ってな感じでね。
見るからに対象が絞られる感満載でしょ？でもまだまだ。進行方向に向かって、９０度の範囲にあるスライダーだけを対象にすれば事足りる。
これに先の寄り道レベルが組み合わされる訳で、ぐぐっと対象が絞られる。もう一つ言うと、それぞれのスライダーが選ばれる毎に許容されるコストが消費されるので、コストが底を尽きたタイミングで探索を中断する事も有効な対策であるし、残りコストから許容コストを動的に絞る事も可能だ。あー、感覚的過ぎる…
つまり、寄り道レベルp=0の場合許容されるコストはDeltaだけだから、下図の①の様にいきなりコストDeltaを使い切ってしまった場合は、青線で示されるように、ゴールに向かって滑り落ちていくルートしか残されていない。この（①のコストを使い切った）時点で黄色い許容範囲は青い線上に収束してしまう、と言える訳だ。この手順の全体的なイメージを表現すると、下図の様に探索範囲が狭められていく筈（なんだろう）。
ところでこれ以上話を進める前に、横入りナシと云う制限を設けても横入りアリよりコストが掛かるケースが存在しない事を保証しなければならない。そこをここで確認しておこう。とか言いながら実は、こんな文字列だったら…今更だけど、横入りしないと最小コストでゴールできないなぁ…これは困った。
「最小コスト」ってのと「イイ感じの手順」ってのが両立しないぞ。ま、それはそれとして色々出揃ったので、今後の方針を纏めてみよう。「最小コスト」と「イイ感じ」が両立しないのであれば、解法も二階層にならざるを得ない。色んな二階層があると思うんですが—
んんんー、今回は次の手法で行きましょう。ナイスっ！全ルートを求めるのは、スライダーの総当たり作戦で。
イイ感じ度は以下の様にして図れば良いかな。まずはメイン部分から。
こんな感じで書くと結果が表示されると云う寸法。うーさんのサンプル文字列の比較では、以下の４パターンが導き出された。
何れも6文字分の寄り道をしているので、寄り道レベルは2って事で先の例と一致。
類似度に関しては絶対値だと良く分からないので、相対比較ができるように0.0～1.0の範囲での評価結果を得られるように調整してみた。（適当ですけど）
先で気になった点に関して云えば、期待通り3文字削除の方が評価結果が高いという事に落ち着いて一先ずは意図した通りの動きをしているんだろうなぁ、という感想。
気に入った点は、比較対象と被比較対象の文字列の長さの制約がない処。ま、総当たりで探索しているからね、当たり前っちゃ当たり前。それでは、以下細かい処へ…サポートクラス尚、類似度最大の候補を一つだけ受け取ればよい場合は、Main()を以下の様にすれば良い。ん～～～
やっぱり力ずくはイマイチ美しさが足りないかなぁ…
そして、色んな意味で分かり難くて申し訳ない。タイトルに関していえば、ただ単に「う」を一杯使ってみたい衝動に抗えなかったのです…


