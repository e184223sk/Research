More than 1 year has passed since last update.あけましておめでとうございます。2019年は個人的にクリーンアーキテクチャの年でした。
Webアプリケーションにクリーンアーキテクチャを適用するため試行錯誤をした結果、ようやっとまとまりだしたので、自分用のメモという意味も含め、Qiitaに初記事を投下しようという試みです。
至らない点を許すことなくお付き合いいただけますと幸いです。この記事ではタイトルに書いたこと以外は極力説明を省きます。
クリーンアーキテクチャの概要や実装方法については尊敬する先達の記事を参照ください。実装クリーンアーキテクチャ - @nrslib
https://qiita.com/nrslib/items/a5f902c4defc83bd46b8ソースコードで理解するクリーンアーキテクチャ - Sansan Builders Box
https://buildersbox.corp-sansan.com/entry/2019/07/10/110000.Net Framework 4.6.1Simple InjectorEntityFramework等のORMは使用していません。なお、とあるBtoBアプリケーションのユーザ情報に関する処理という前提で説明します。前置きが長くなりましたがここから本題です。クリーンアーキテクチャの概念を自社のサービスに取り入れるにあたって様々な困難がありました。
その中でも頭を悩ませたのがビジネスロジックとデータの永続化を分離する部分で、大きく以下の2点です。今回はこのうち、マルチテナントサービスにおけるデータベースアクセスのDIに対する実装例をご紹介します。はじめ、クリーンアーキテクチャで実装をしようと思ってさくっと調べ、見よう見まねで以下のような構成をとろうとしました。
ユーザのIDでユーザ名を取得するような処理を例とします。今回の問題点として、マルチテナントの構成をとっている場合、UserRepositoryが使用する接続文字列が単一ではなく、リクエスト単位で異なります。そうなるとリクエストに紐づいた接続文字列をUserRepositoryまで渡してやる必要があります。また、毎回コネクションを開く処理を書くのも冗長です。どげんかせんといかん。まず、データベースへのアクセスはそれ自体が一つの関心ごとになると言えます。
UserRepositoryが複数の関心ごとにとらわれないよう、UserRepositoryから接続の関心ごとを分離しましょう。以下のような接続に関する処理をまとめたクラスを作成し、処理を委任します。すっきりしました。今回はマルチテナントの想定なので、リクエストに基づいた接続文字列をDataAccessContextに渡す必要があります。
ログイン時にセッションへ接続文字列を保存してある想定とすると、現在のセッション情報をもとにオブジェクトを生成することができます。以上でマルチテナントサービスでもデータベースアクセスをDIすることができました。振り返ってみると解決法自体はシンプルですね。
今回主につまづいたのはStep3に関する部分であり、なぜつまづいたかをまとめてみました。どちらにも共通して言えることは、使用するフレームワークに対する知識の浅さが要因ということです。
採用した技術に関して理解を深めるというのは技術を使用する立場としての当然の心得ですが、それを強烈に認識できたことはいい経験になったなぁと思います。あと、今回書いたコードはQiita用に雑にこしらえたものでありそのままコピペとかでは動かない恐れがあります。ごめんなさい。
余裕があればトランザクションも含めたソースコードも公開したいなと…思って…います…。次回は複数のリポジトリにまたがったトランザクションについて書きます。


