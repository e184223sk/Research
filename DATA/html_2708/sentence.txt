More than 1 year has passed since last update.C#8.0でnull許容性が追加されたことで、総称型制約にも機能が追加されました。
動作を検証している中で、既存のキーワードの動作の認識が間違っていた箇所があったので、復習の意味も含めて記事を書いてみます。C#8.0で新しいキーワードnotnullが追加されました。null不許容の参照型または値型を示すことができます。また、従来class制約だったものが、class,class?の両制約に役割が分かれることになります。ここで「おや？」と思ったのが、この記事を書いたキッカケです。何かというと「struct?という制約ってあったっけ？」という疑問でした。結論から言えばこの制約はありません。null許容性の話においては、参照型と値型では全く違うということをきちんと認識しておくことが必要です。値型で、かつnull許容も不許容も受け入れる場合を考えてみます。この場合、struct制約を利用して、型引数をnull不許容に指定した上で、null許容したい箇所だけ?(Nullable&lt;T&gt;)を指定すれば良いのです。null許容値型とnull不許容値型は違う型として認識されるので、必要な場合はオーバーロードを書くことができます。参照型の場合はというと、型引数でclass?制約を利用する方法と、型引数ではclass制約を使用したうえでnull許容したい箇所だけ?を指定する方法の二通りが考えられます。また、参照型ではnull許容性が違っても同じ型として認識されますので、オーバーロードとして書き分けることはできません。notnull制約の時、T?型を指定することはできません。これは値型と参照型でnull許容性の扱いが全く異なるからです。使用頻度は高くないですが、特殊な制約についても調べてみます。デリゲート型制約もnull許容性を指定できるようになっています。null許容性に応じて、Delegate,Delegate?を指定できます。挙動も直感的で、例えばAction?を受け入れるか受け入れないかが変わります。列挙型制約もnull許容性を指定できるようになっています。null許容性に応じて、Enum,Enum?を指定できます。ただし、Enum?については、あまり直感的な挙動ではないことを覚えておきましょう。MyEnumという列挙型を定義したとして、Enum?型制約のついた型引数にMyEnum?を指定することはできません。これはstruct制約と同じ理屈です。総合的に考えると、Enum制約はstruct制約と組み合わせて使ったほうが扱いやすいように思います。C#8.0からunmanaged 制約の挙動が変わっています。これは入れ子のunmanaged型もunmanaged型と扱われるように改善されたためです。例えばunmanaged制約した型引数に対して、C#8.0からは(int,int) を扱うことができるようになっています。C# 8.0 の目玉機能であるnull許容性の指定は総称型の利便性にも大きく貢献します。理解を深めてより利便性を享受したいと思います。


