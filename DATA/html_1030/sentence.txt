More than 1 year has passed since last update.List&lt;T&gt;は配列と違い、動的に要素を追加したり削除したりできることは誰でも知るところだろう。筆者のようなC#初心者は、恥ずかしながら今までのその仕組みを考えたことは一度もなく、ただ何となく便利なコレクションクラスとして使っていたわけだが、あるときList&lt;T&gt;についてちゃんと調べようと思って、Microsoft.Docsを読んでいたら、以外と単純な仕組みで実装されていることを知ったので、簡単な検証を行ってみた。Microsoft.Docsを読めばクラスの全機能が分かるし、ご丁寧にコードサンプルまで書いてあるので非常にありがたいのだが、如何せん書き方が小難しくて敵わないし、表現に統一性がないのはどうにかならないのだろうか。まずは下記プロパティを見てほしい。List&lt;T&gt;.Capacity プロパティ内部データ構造体がサイズ変更せずに格納できる要素の合計数を取得または設定します。
Capacityは、サイズ変更が必要になる前にList&lt;T&gt;が格納できる要素の数であり、Countは実際にList&lt;T&gt;内にある要素の数です。
Capacityは、常にCount以上です。要素の追加中にCountがCapacityを超えた場合は、古い要素をコピーして新しい要素を追加する前に、内部配列が自動的に再割り当てされ、容量が増加します。すなわち、List&lt;T&gt;は内部的に要素数の固定された配列をラップしていて、アイテムの追加で限界値Capacityを超えそうになったら、自動的に要素数の大きい配列を作り直して元データをコピーしているということらしい。
さらに、下記メソッドの注釈部分を見てみる。List&lt;T&gt;.Add(T) メソッドCountが既にCapacityに等しい場合は、内部配列が自動的に再割り当てされ、既存の要素が新しい配列にコピーされてから、新しい要素が追加されるまで、List&lt;T&gt;の容量が増加します。
CountがCapacityより小さい場合、このメソッドは $O(1)$ 操作になります。 新しい要素に対応するために容量を増やす必要がある場合、このメソッドは $O(n)$ 操作になります。ここで、$n$ はCountです。つまり、通常の値の追加であれば、既に確保されたメモリへの書き込みなので $O(1)$ 操作で済むが、Capacityが足りなくなったら配列の作成とコピーの手間が発生するので、$O(n)$ 操作になるということらしい。ここで、実際どのようにサイズ変更が行われているのか検証してみたいと思う。List&lt;T&gt;に対してAddメソッドを繰り返したときに、Capacityがどのように変更されるかを観測するため、以下のメソッドを用意した。List&lt;T&gt;には下記のコンストラクタが用意されているので、各パターンでCapacityの変化を観測する。以上の観測から、サイズが最初から判明している場合は、明示的にCapacityを指定した方が内部的再定義の時間を短縮できるのでは、という推測が浮かんでくる。通常の初期化と明示的にCapacityを指定した初期化で、その後Addメソッドを繰り返した時の処理速度がどのくらい変わるか比較するため、下記のメソッドを用意した。今回の計測だけで言えば、やはり明示的にCapacityを指定した方が処理速度は速くなることが分かった。闇に包まれていたList&lt;T&gt;の真の姿が見えてきて、少し親近感が湧いた気がする、、
処理速度計測はPCのスペックにもよるところなので、各々試されたい。
また他の言語、例えばc++でいうVectorの内部構造はどのようになっているのかも興味深いところである。2020.07.22
@koturn 氏から教わりましたが、リファレンスソースでList&lt;T&gt;の内部実装を確認しました。随所で下記メソッドが呼ばれ、二倍量のCapacityが確保されていると分かりますね。情報ありがとうございました！


