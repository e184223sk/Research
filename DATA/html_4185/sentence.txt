More than 1 year has passed since last update.C# 7.3から自動実装プロパティのバッキングフィールドに属性をつけられるようになりました。前半はこれについて解説し、後半はこれを用いてUnityでこんなことできればよかったのにな、ということを紹介します。まずC#におけるプロパティ。こんなやつですね。つづいて、こちらは自動実装プロパティ。さて、こちらの自動実装プロパティ。コード上にフィールドはありません。しかし、内部的にコンパイラーがフィールドを生成しています。MyPropertyというプロパティがある場合、コンパイラーはC#のコードからは見えないフィールドとメソッドを作成します。現在のRoslyn Compilerは、というフィールドとメソッドを生成します。「自動実装プロパティのバッキングフィールド」とは、コードからは見えない、コンパイラーが生成した、プロパティを実現するうえで必要なフィールドです。ちなみにバッキングフィールドは、「&lt;」という名前で始まります。C#のフィールド名としては、「&lt;」は無効です。ILとしてのフィールド名としては、「&lt;」は有効です。「自動実装プロパティのバッキングフィールド」とは、コードからは見えない、コンパイラーが生成した、プロパティを実現するうえで必要なフィールドでしたね。C# 7.3より前では、この「自動実装プロパティのバッキングフィールド」に対して、属性（アトリビュート）を付与することができませんでした。これができるようになって何がうれしいのか。例えば、次のコードはC# 7.3でより簡潔に書けるようになります。これがC# 7.3より前のコード。となっています。これはシリアライズされるExampleクラスの内、fieldをシリアライズ対象から外したいためにこのような実装にしています。このコードが、C# 7.3からより簡潔に書けるようになりました。C# 7.3からは次のように記述することができます。C# 7.3からは、自動実装プロパティのバッキングフィールドに対して属性を付与することができるため、MyPropertyで使っている内部のフィールドをシリアライズ対象から外すことができるようになりました。C# 7.3より前では、自動実装プロパティのバッキングフィールドに属性を付与することはできませんでした。そのため、自動実装プロパティをあきらめて普通のプロパティにするしかないことがありました。ちなみに、[field: XxxAttribute]という記法ですが、これはC# 1.0のころからevent用に存在していたらしいです。ここまではC# 7.3で自動実装プロパティのバッキングフィールドに属性をつけられるようになった話。ここからは「これを使って、Unityでこんなことができたらよかったのに」という話。次はUnityでよくあるSerializeField属性を付与したフィールド、そしてそれを使ったプロパティというコードです。
これでlevelフィールドはシリアライズされ、プロパティとしてPlayerの外部からアクセスすることができます。これがよく書くんだけど、長い。もう少し短くしたい。「C# 7.3で自動実装プロパティのバッキングフィールドに属性をつけられるようになった」のだから、できれば次のように書きたい！ただ、残念ながらうまくいかない。理由は、そのため次の画像のように、データ(YAML形式)は次のような名前でシリアライズされます。そして、Unityのエディター上では次のように表示されます。うまくいかない。さて、やっぱりこんな感じで書きたいわけです。短く。そこで取れる方法は2つですね。1つ目。Unityにシリアライズする際の名前を指定する機能を入れてもらう。
そして、こんな感じで書けるようにしてもらう。もしくはこんな感じ。ちなみに、こちらはUnity Feedbackにもう上げています。もし、賛同してもらえる方は投票をお願いします。Unity Feedback : FEATURE THAT SPECIFIES SERIALIZED NAME NOT WITH FIELD NAME.2つ目。C#の方に、自動実装プロパティのバッキングフィールドの名前を指定する機能を入れる。これはプロポーザルを上げるとか、プルリクエストを送ればいいはず。ただ、これあんまり需要がなさそう。実現性高くないかも。


