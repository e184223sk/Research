この記事はUnity #3 Advent Calendar 2020の9日目の記事です。この記事では高速フーリエ変換(FFT)を使った海洋シミュレーション、FFT Oceanについて書いていこうと思います。Unityに限らずいろんなゲームエンジンで再現できるよう理論サイドも俯瞰しつつ、私が実装を通して理解したことをまとめさせていただければと思います。まずはこんな感じの絵を出すところまでを目標にします。
次に発展として、法線ベクトルの算出や、より波を尖らせてそれっぽくすることをやっていこうと思います。
最終的にはこんな絵ができあがります。
音声信号などの波形はフーリエ変換することで周波数を得ることができます。逆に周波数情報から波形を求めることができます(逆フーリエ変換)。FFT Oceanは海面の高さを周波数から逆フーリエ変換で求めてしまおうというものです。すなわち周波数スペクトルが大事になってきます。この周波数スペクトルをTessendorfの書いた手法で生成します。
https://evasion.imag.fr/Membres/Fabrice.Neyret/images/fluids-nuages/waves/Jonathan/articlesCG/simulating-ocean-water-01.pdf一部のゲームや映画(タイタニック)などいろんなところに使われている有名(?)な手法のようです。CUDA Sampleの中にもあったりします。
https://docs.nvidia.com/cuda/cuda-samples/index.html#cuda-fft-ocean-simulation
(画像はNVIDIAのOceanCSのpdfより)
１、まずは事前計算で左の画像をCPUで計算しGPU上のメモリに載せておく
２、それをベースに毎フレーム真ん中の画像をGPU上で生成(tはtime)。これが周波数に相当
３、GPU上で逆フーリエ変換をして右の画像(=海面の高さ)を生成
４、右の画像から実際の位置にレンダリング※数式上、最初から最後まで複素数がでてきますが、画像でいうと左の画像と中央の画像ではr,gが実数,虚数に対応、右の画像は実数を白で表現してい(ると思われ)ます。CUDA Sampleでも海面の高さには実数のみを使っていました。ここで求めたいのは
です。
正直最初ほとんどの記号が意味ワカンナイ状態でしたが、他人のコードを見ながらちょっとずつ理解していった感じです。ひとつずつ見ていきましょう。早速難しそうですが、kはN×Mの二次元配列みたいなもんです。画像の各ピクセルにkの各要素が対応している感じです。今後FFTで実装することを考慮し2のべき乗とし、今は$N=256$,$M=256$くらいで考えておけばよいです。
また$L_x,L_z$は海面サイズです。
こちらに関しては、スケールの問題なので何でもいいと最初思ってましたが論文にはこうありました。
・$dx=L_x/N &gt; 2$
・$dz=L_z/M &gt; 2$
・$dx,dz=2.5$  が最も良い (←自信ないのですが間違ってたらコメントしてください)$\xi_r$と$\xi_i$はランダムな数です。具体的には正規分布する乱数が必要です。なんでこう難しそうな記号を使うのか・・・
コードではボックス＝ミュラー法を使っています。これは標準正規分布する乱数を生成する手法です。
参考
JavaScriptでBox-Muller法による正規分布からのサンプリング最後に残った$P_h(\vec{k})$の中身はこれです。？？？？？？？？？
えー、これも一つずつ見ていきましょう。$A$：これは定数です。最終的な波の高さのスケールだと思ってください。
$e$：これはさすがに自然対数の底でいいでしょう。
$k$：$\vec{k}$ の長さ。sqrt(k.x*k.x+k.y*k.y)とかで求められますね。
$L$：$L=V^2/g$ ここで$V$は風速 つまり定数、$g$は重力定数で$g=9.81$です。
$\vec{\omega}$：風向きの単位ベクトル(風がないと波が起きません)これですべてそろいました。
なお、この式の意味するところですが理論的に導き出されたというよりは、テッセンドルフさんが必死に海を観察し導き出された"経験的"な式らしいです。なのであまり細かいことを気にせずに、こういうものだと思ったほうがいいです、精神衛生上。で、ここまではまぁいいのですが、論文にはさらにこうあります。
多分ですが|k|が大きいとなにかがダメなようで、ちょっと修正しろと言ってるんですね。
他のコードも参考に下記のような修正を加えるようにしました。これでCPU上で$h_0(\vec{k})$を計算することができました。後のコードに含まれていますが、GPUに転送するコードの一部を載せておきます。余談ですが、Phillips Spectrumの計算でw_dot_kを2乗ではなく6乗でやる流派もあるようです。6乗にすることで、風の方向に応じた波が今まで以上に際立つそうです。これも余談ですがPhillips Spectrumを求めた後、Donelan-Banner方向拡張?(中国語の翻訳なのでわかりませんが)という謎の計算をしてかけているコードも見かけたので一応書いておきます。
https://zhuanlan.zhihu.com/p/96811613
(もう一つ別の人のコードでDonelan-Bannerを計算しているのを見つけたがどっかいった)次に求めるべきはこれです。
ここで$ \tilde{h}_0^*$は$ \tilde{h}_0$の共役複素数です。※虚部を−1倍した複素数のことを共役複素数と言います。
あとhの上に乗ってる波線はチルダと読みますが特に深い意味はないので無視してください(なんか"似てる"的な意味合いがあるようです)
$\omega(k)=\sqrt{gk}$
$g$は重力定数 $=9.81$
$k$は$\vec{k}$の長さです。
$t$はtimeです。毎フレーム動的にh(k,t)が変わるということが分かります。あと$e$の肩に虚数$i$が乗っています。高校数学でここまで習わないかもしれませんが、この計算は有名なヤツです。オイラーの公式
$$ e^{i\theta} = \cos\theta + i\sin\theta $$プログラム実装的にはどうすればよいかと言うと
「実数xが与えられるので$e^{ix}$を求めてください、cosとsin関数を駆使してね」
ということなので四則演算とsin,cosが書ければ実装できることがわかります。したがってこんなコードになります。
GPU上にあるデータに対しての計算なのでCompute Shaderのコードになります。難しい点としては$ \tilde{h}_0(-\vec{k}) $のメモリアクセスかなと思います。コードでいうとin_mindexの計算についてです。ちょっと考えてみましょう(自分のメモ代わりにもなるので)ここで h0[y*N+x] というように配列変数にアクセスし$\tilde{h}_0(\vec{k})$の値を取り出せたとします。そのときx,yを使って$\tilde{h}_0(-\vec{k})$を取り出すにはどうしたらいいでしょう、という問題になります。なのでマイナスはここからつまりとしてx' y'を使ってh0[y'*N+x'] というようアクセスすることで$ \tilde{h}_0(-\vec{k}) $が得られることがわかりました。ただしx=0 や y=0のときx'=N y'=Mとなり範囲外のアクセスになるのでx'=Nのときはx'=0(y'のときも同様)の値を使って計算してしまっています。ここは目を瞑ります。このCompute Shaderコードでは
id.x id.yが0～255になることを想定しているので、C#のDispatch側でもこのようにグループ数を指定する必要があります。さきほど求めた画像$\tilde{h}(\vec{k},t)$をもとに逆2DFFTをかけ海面の高さを算出します。
式で書くとを求めたいです。
その計算の仕方ですが、ちょっと長めの説明をしたいので先に結論だけ言います。

まずこの画像を普通に2次元逆FFTで変換します。そのあと
・計算結果全体を(N/2,M/2)ずらす
・要素のindex x,zが(x+z)%2==1となる要素に-1をかける
をすればよいです。まずは普通の方法からおさらいしましょう。(普通ってなんだよ)2DFFTのやりかたはまず横方向にそれぞれFFTを実行し

その結果を今度は縦方向にFFTします。

iFFT(逆フーリエ変換)でも同様です。また縦→横の順にやっても答えは変わりません。
FFTの具体的な計算方法についてはわかりやすいサイトがたくさんあるのでここでは割愛させてください。またDFTからFFTで計算量が削減される話もこの記事では割愛させてください。投げっぱなしなのもあれなので参考になりそうな記事をいくつかピックアップしてみました。Compute Shaderで2DFFTしているコード
下町のナポレオン Compute ShaderでFFTと畳み込み演算でブラーCompute Shaderではないが、ループ型のFFT計算のコードが乗ってる記事
任意要素数の高速フーリエ変換
高速フーリエ変換FFTを理解する
FFT(Fast Fourier transform)をC++で実装するDFTから理解する
離散フーリエ変換(DFT)の仕組みを完全に理解する先ほどの式を再掲します。ここで$\vec{k}$と$\vec{x}$の定義はこうなっています。
ベクトルを成分別に分けて書くと上記の式はこうなります。n,m,x,zがマイナスから始まっていることに注意です。なので普通にFFT(iFFT)の計算を適応しただけだと間違った答えになります。画像をみればわかるとおり、中心に周波数0成分がきていますね。
普通にFFT(iFFT)の計算を適応しただけだと間違った答えになるので、さっき太文字で書いたやり方でやる必要があります。
本当にそれでいいのか証明させてください・・・
まずは0オリジンで考えたいのでこうします。するとx,z,n,mはこう書けます。続いて式簡略化のため${h'}$と$\tilde{h'}$を定義あとは求めたい$h()$についてゴリゴリ式変形するとここでN,Mは256としていたのでなので消すことができと置き換えられなのでまとめるとあとは$x'$と$x''$を入れ替え、$z$も同様にしてこれでやっとよくあるFFTの形になりました(ほんとか)。。。
普通と違うところは・$h'$の添え字 ： →計算結果の書き込み先を(N/2,M/2)ずらせばよい
・$(-1)^{x''}$と$(-1)^{z''}$ : →計算結果の書き込み先index x,zが(x+z)%2==1となる要素に-1をかければよいということでやはりよさそうです。これらの要素を盛り込むことでこのようなコードになります。
ここでは横方向のfftと縦方向のfftを同じコードで実現しています。横方向を計算した後 縦方向を計算するので合計2回実行される前提のコードです。Dispatch側のコードカーネルプログラムFFT2Dfunc256invはコメントにもあるよう
・iFFTを普通に計算し(Cooley-Tukeyなので最後にbit逆順がある)
・書き込み先indexが奇数なら-1をかけ
・N/2ずらして
・行列転置(縦横入れ替え)してメモリに書き込みしています。
文字だけだとわかりにくいのでプログラムの動作を画像化してみました。カラーが最初のメモリの位置に相当します。色味が落ちてるところは-1がかかっているという意味です。
これによって
・計算結果全体を(N/2,N/2)ずらす
・要素のindex x,zが(x+z)%2==1となる要素に-1をかける
が実現していることがわかります。
(と、偉そうにのたまいましたが皆さんの好きなように2D逆フリーエ変換を実装すればいいと思います。)いろいろ大変な実装でしたが画面に描画してうまくいったとき疲れが全部吹き飛びます！あと一歩です。
すでに高さ情報はComputeBufferに格納されているので
Graphics.DrawProceduralNow
などで手軽に描画することができます。一番簡単なPointsの描画をしてみます。
CPU側コードとShaderはこんなかんじ
これだけでも十分綺麗ですね～！
ここまでのコードは
github
https://github.com/toropippi/OceanFFT/tree/main/OceanFFT1_points
にUPしてます。さてせっかく綺麗な絵が出そうな雰囲気なので法線も計算してみましょう。お手軽な方法として、すでに計算してある海面の高さを利用して中心差分で勾配を計算します。だんだん数値計算 Advent Calendarみが増してきました
x,z方向の勾配が求まれば、海面と垂直なベクトルがでます。この計算のところだけピックアップします。雰囲気だけでもわかってもらえれば幸いです。法線ベクトル情報x,y,zをr,g,bで出力

できました。あとは煮るなり焼くなり法線情報でうまくライティングすればきれいな絵ができるでしょう。github
https://github.com/toropippi/OceanFFT/tree/main/OceanFFT2_normal念のためですが、法線が本当に正しいか、Aを100倍にして出力してみました。

x方向に向いている面は赤く、z方向に向いている面は青くなっています。面の法線ベクトルのx,z成分がr,bに対応しているので正しそうです。ところでせっかく難しい式を計算をしてスペクトルを出してきたので、法線も式から求められないでしょうか。
これも結論から言うとできます。
これで偏微分が計算できます。$\tilde{h}(\vec{k},t)$は「2.それをベースに毎フレームh(k,t)をGPU上で生成」で求めたやつです。これに$i\vec{k}$がかかっていますが、各要素の計算時に求めていた$kx,kz$を使うだけです。
x方向の偏微分ならkxをz方向の偏微分ならkzのみを使います。そしてそれを逆フーリエ変換することで海面の高さの勾配(偏微分)が求まります。ここで、手元には複素数の状態で結果があると思いますが、使うのは実数成分のみです。海面の高さには実数のみを使用しているので勾配情報も実数のみを使う必要があります。
あとはさっきと同じように法線を計算しできました。
さっきと見た目かわんないですが、中心差分よりは精度よくできてると思います。
これもgithubにupしてるので参考にしてください。
github
https://github.com/toropippi/OceanFFT/tree/main/OceanFFT3_analyticalNormal正直Compute Shader以外のシェーダーやレンダリングは詳しくないのでたいしたことは書けません。
一応、法線から反射ベクトルを計算してフレネル反射とか実装したりしなかったり・・・
コードを見ればわかりますが視線ベクトル決め打ちのレイトレーシングみたいなことをしています、、、だからカメラ動かしても絵は変わらないというひどいコード。誰かレンダリング教えて・・・
github
https://github.com/toropippi/OceanFFT/tree/main/OceanFFT4lightingまぁかつてないほど海っぽくなったのでいいでしょう。NVIDIAのスライドを見るに、さっきの偏微分にすごい似た、でもちょっと違う式で計算されたDx,Dyというのを求めています。これは法線を計算するためのものではなく、波をより尖らせたChoppy waveを作るために必要なようです。
今までの波はあくまで有限個のsin,cosの足し合わせでできた波で、ちょっと滑らかになりすぎてるという問題があったようです。それをアーティスティックな謎テクで解決するのが今から説明する方法です。いや滑らかすぎるならもっと離散点を増やして細かいsin,cosを足し合わせばいいじゃないかと個人的には思いましたが、そう書いてあるので仕方ありません。
まぁおそらく離散点を増やすと計算負荷が上がるからダメなんでしょうね。Choppy waveの計算手順はというと、まずDx,Dyを計算します。数式では $\vec{D}$ と書いてあります。そしてこの$\vec{x}'$を新しい座標として使います。今まで$\vec{x}=(x,z)$としてx,z座標は固定でやってきてましたよね。でy座標だけが動いていたと。今度は$\lambda$に2.0とか-3.4とか適当な値をいれることでx,zもリアルタイムに動いて、見た目が激しくなるというイメージです。
今までと違い、x,z方向にもうねうねしていますね。の求め方ですが、偏微分を求めるときに書いたコードにちょっと付け足すだけです。これでの部分まで求まったので、あとは3の手順でiFFTして完成です。これで新しい座標$\vec{x}'$を求めることができましたが、これがどんな意味があるのか少し考えてみましょう。
上でも書いたよう、$\vec{D}(\vec{x},t)$の式は偏微分の式に酷似しています。違うのはマイナスがかかっていることと、ベクトルの長さkで割っているところです。
kで割っても正負は反転しないのでここはざっくり"(偏微分×-1)に近い値"として思考を進めてみます。簡単に1次元として、x座標を移動させるということは、こんな形の波があったときに青丸が矢印の方向に移動することが想像できます。
ということは移動後は
となります。あれ、波が尖がるどころかなだらかになってるじゃないか・・・次sinカーブでも同じように考えてみます。

これが$\lambda=1$のとき

やっぱりなだらかになってる。じゃあ$\lambda=-1$にしたらどうだろう・・・
これが正解では？？？実は論文にもほかの参考になりそうなサイトにも、λの決め方についてほとんどなにも書かれていません。まぁ適当にいじって決めてねってことなんだと思いますが、数式のお気持ちを察するに、これはマイナスの値を入れないといけないのではないでしょうか。実際にやってみました。まずはコントロール

表面が丸くなってる？
これだよこれ！
これはなんですか？
何事もやりすぎはよくないということですねλはマイナスの数字を入れることで波を尖がらせることができ、プラスの値をいれると滑らかにすることができます。と私は理解しています。さて、x,zの位置がずれたことで海面の傾きが変わったので法線も今までの値を使うことはできません。今のところchoppy waveを実装して海面の法線をまじめに計算しているコードは中国語の https://zhuanlan.zhihu.com/p/96811613 ここで紹介されてる https://github.com/Straw1997/FFTOcean にupされてるコードしか確認できませんでした (探せばほかにもあるかもしれませんが)。この方のコードをみると、x,z座標を動かあした後 中心差分で求めているようでした。しかしそもそも海面の高さをhtの実数じゃなくて複素数の絶対値で求めていたり、ちょっと私のやり方とは違うので参考にはできませんでした。そこで私オリジナルのやり方になりますが、下記のような方法で実装してみました。考え方としてはこんな感じ。解説図では$\lambda=1$として省略してます。

displaceXの分だけ点が動いて線の傾きかたが圧縮、拡張されるというイメージです。これらを適応して$\lambda=-2$としたコードがこちら。github
https://github.com/toropippi/OceanFFT/tree/main/OceanFFT5ChoppyWaveちなみに見た目はほとんど変わりませんでした。
ま、十分綺麗なのでいいでしょう。ここで、波のポリゴンが交差してるのが見えるでしょうか。画面左と、左奥の2か所です。これがchoppy waveの恩恵で、今回の実装で相当リアルになってきたのがわかると思います。
実際自分も実装していて、この絵が作れた時はかなりテンションあがりました。それまでは確かにのぺっとしていて、ちょっとおかしいなって感じはありました。
ここまでくるとFFT Oceanの実装で一番重要なのってここなんじゃ・・・？とすら思います。さっき波ポリゴンが重なるといいましたが、今度はこの重なりを検出して泡を表現しようという話です。この検出にも$\vec{D}(\vec{x},t)$を使います。(プログラムでいうとdisplaceX,displaceZ)このJの正負がマイナスのとき、その場所で重なり(反転)が起きていることになります。
したがってこんなコードになります。レンダリング側結果github
https://github.com/toropippi/OceanFFT/tree/main/OceanFFT6Bubbles波のてっぺん付近が白く着色されているのがわかります。波の先端、特にとがっているところは海面が90度以上傾いていることがあります。それを先ほどの計算で検出し、泡としてレンダリングしたということになります。論文のFigureがわかりやすいかなと思ったのですが、Choppy Surfaceと書いてある波はよく目を凝らしてみるとPosition=15付近でぐるっと回っているのがわかります。これに対しMinimum E-value(最小固有値)がそこで0を下回っているというのが読み取れます。
論文では、最大固有値は常に正で最小固有値は図のように負になるから、最大固有値×最小固有値がマイナスなのを確認できれば検出できるよねと言ってます。プログラムでは$Jxx,Jxz,Jzx,Jzz$の2*2の行列の行列式を求めることで、この最大固有値×最小固有値がマイナスかどうかを判定しています。(というか参考にしたコードがそういうコードだった)以上です。お疲れ様でした。・Shaderの要修正の部分はそのうち修正してgithubに
・泡のレンダリングもうちょっと頑張れるはず
・Donelan-Banner調べる
・海面をループさせて無限海面に、遠くはLODで・FFTの計算部分は2倍高速化できる。海面の高さはFFTの計算結果のうち実数しか使わないので、実数FFTの逆の手順を行うことで1/2のサイズのFFTで済む。円周率.jpの実数FFTの説明を参考に複素数→実数FFTのC++コードを書いたのでこれを参考に。ただ並列化しにくい部分があるのでComputeShaderへの適応はよく考える必要がある。一番参考にした中国語の解説
https://zhuanlan.zhihu.com/p/96811613
https://zhuanlan.zhihu.com/p/64414956
https://zhuanlan.zhihu.com/p/95482541
https://github.com/Straw1997/FFTOcean論文pdf
https://evasion.imag.fr/Membres/Fabrice.Neyret/images/fluids-nuages/waves/Jonathan/articlesCG/simulating-ocean-water-01.pdfNV_OceanCS_Slides
http://www-evasion.imag.fr/~Fabrice.Neyret/images/fluids-nuages/waves/Jonathan/articlesCG/NV_OceanCS_Slides.pdfUE4で海面シミュレーションと描画を行う at Qiita
https://qiita.com/monguri/items/3ad184c3316343c635f5その他英語スライドなど
http://developer.download.nvidia.com/assets/gameworks/downloads/regular/events/cgdc15/CGDC2015_ocean_simulation_en.pdf
http://evasion.imag.fr/~Fabrice.Neyret/images/fluids-nuages/waves/Jonathan/articlesCG/waterslides2001.pdf
https://www.slideshare.net/Codemotion/an-introduction-to-realistic-ocean-rendering-through-fft-fabio-suriano-codemotion-rome-2017参考にしたコード
https://github.com/nobnak/FftUnity
https://github.com/gasgiant/FFT-Ocean


