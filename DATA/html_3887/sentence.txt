More than 1 year has passed since last update.みなさんログは出してますか？自分は割と出しています。だってお客さんからクレーム来た時に何が起きたか、証言だけじゃ理解できないし、人間の記憶なんて適当ですもんね。ということでこのボタン押したとかコンボボックスを選択したとかの操作ログはうまいこと仕組み作って自動的にログに出るようにしてます。で、今回は操作ログではなくて計測系ログの話。開発末期に「（他人の書いたコードの）パフォーマンスの最適化」という名の汚れ仕事を任されたりするんですが、そういう時にどこの処理が重いかを見極めるために自分がまず行うのが、原始的ですが計測ログを仕込んでいくこと。プロファイラだとノイズが多すぎて見極めにくいので。。（いつもプロファイラを使う→うーんわからん→ログ仕込むという流れになってます。。XAMLの最適化の場合はVS標準のプロファイラは必須だけどそれはまた別の話）。ということでどんな感じで実装しているかを紹介してみたいと思います。ご存知の通りC#にはusing({Disposable})構文があり、usingブロックを抜けたときにDisposeが実行されるという特性を使います。アイデアはReactive Extensionsのイベント購読関数Subscribeの戻り値がIDisposableになっていて、それをDisposeするとイベントが解除されるというところから。ということでコード例。まず下準備としてSystem.ReactiveをNugetからインポートする、もしくは以下のようなクラスを作ります。
要はActionを渡せばDispose時に実行してくれるクラスです。さて、Disposableができたら以下のようなメソッドを定義してみます。機能※ System.Reactiveを参照している場合、Disposableを生成する方法が以下のようにDiposable.Create(Action)となります。これ以降この記事ではnew DisposableActionの方を使います。上記関数は以下のように使います。↓コンソール出力というようにメソッドをusingを使って計測ログ関数で包むことにより、その間の経過時間が計測できます。CallerMemeberNameを使用することにより、呼び出し元のメソッド名が自動的に入るので、多くの場合引数を渡す必要も無い！上記例ではアイデアの肝を示すためにシンプルな機能しかありませんが、実際に自分がどんな感じのメソッドを定義して使っているかを紹介します。まず下準備としてロガーインターフェースがあって、例としてコンソール出力するロガーを実装してみます。このロガーインターフェースに拡張クラスとして計測ログ出力関数を実装します。
キモはWriteLogAsDisposable関数で、この第一引数に文字列を引数に取ってログ出力する関数を渡せば使いまわせるようになっています。
以下のような機能を追加しています。実際の使用例は以下のような感じこのTestMethod1を実行すると、以下のようにコンソール出力されます。こんな感じの仕組みを作っておいて計測ログを基本デバッグログとして仕込んでいき、必要な部分は情報ログとして出力するようにしています。
書式は好みなので自由にすればいいと思います。キモはあくまでDisposable-usingを使うこと、あとはCallerMemberName等使って引数無しでもある程度使えるようになっていること。
なおログを仕込むときはResharperのサラウンドテンプレートを使えば楽ちん。
(TODO:ファイルテンプレート、サラウンドテンプレートの使い方、作り方のチュートリアル作成。)それでは良いプログラミングライフをﾉｼ


