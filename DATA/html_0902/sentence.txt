More than 1 year has passed since last update.Newtonsoft.JsonというC#向けのJson入出力ライブラリがありますね。
クラスのプロパティを勝手に読み込んで、Jsonファイルの属性に関連付けて相互変換をしてくれます。好き。さて、クラスの属性設定にJsonConverterがあります。
既定の動作とは違ったシリアライズ/デシリアライズをさせるための属性指定です。例えばこんなjsonファイルがあります。variablesの値が2つあり、別の構造となっています。
しかしプログラム上では同じ基底クラスで扱い、@classの値に応じて別の派生クラスでインスタンス化したい、そんなケースです。これをNewtonsoft.Jsonで実装しようとした場合、次のようになります。
なお、これら、画像の初期化方法の識別として作ったものなので、そんな感じの命名にしてます。全プロパティにいちいちPropertyNameを指定していますが、この指定がない場合、属性名はプロパティ名と同じものとして扱われます。これではまだ足りません。
基本の属性構造は作れましたが、デシリアライズするとき、どのクラスでインスタンス化すればいいかという情報がありません。
これを指定するのがJsonConverterの役割であり、次のように実装します。これに合わせ、JsonPixelInitializerクラスの方も改造します。基本的な実装はこれでいいのですが、ちょっと問題というか不器用な点がありまして、
クラスにJsonConverterを指定すると、クラス内のプロパティがシリアライズ/デシリアライズ時に出力/入力されてくれません。
JsonConverterを指定しなかった場合には、各プロパティが勝手に出力/入力されてくれましたが、指定した場合には、（上記例で言うところの）ReadFromJObjectとWriteToWriterで各プロパティに対する処理を追加しなければいけません。
プロパティ数が1個や2個ならまあ我慢できますが（そんなん個別オブジェクトにするのも煩わしくなりますし）、プロパティ数が増えたら、ましてや階層構造が増えたら非常に面倒になります。
ので、JsonConverterを指定しない場合と同じように、勝手にプロパティをJson要素に出力/入力してくれる方法を探していました。結論から言うと、対策はできます。
特にデシリアライズは簡単なもので、ConverterのReadJsonメソッドを以下のようにJsonSerializer.Populate()で書き換えればOKです。シリアライズにも同じようなメソッドがあればよかったのですが、どうも見つかりませんでした。
あるかもしれませんが、どうにもリフレクションで全プロパティ見ていく方法が確実なようです。
WriteJsonメソッドを以下のように書き換え、メソッドとクラスを1つ追加します（WriteJsonに全部書いてもいいけど）。attributes.FirstOrDefaultを何度も実行してるのが鬱陶しいのでなんとかしたいですが、まあこんな感じです。
対応している属性はJsonIgnore、JsonProperty、JsonConverterのみですが、他に必要であればまた追記しなければいけません。さて、これで解決なわけですが、Converterが必要なクラスが増える度にこれを実装するのかと言われれば、まあ共通化したくなりますね。
というわけで最後に、Converterが必要なクラスのinterfaceおよびConverterの基底クラスを以下に書きます。JsonConveterを継承した側は、GenerateObjectを実装します。クラスの識別子が与えられるので、それに応じたインスタンスを作成すればOKです。
クラスの識別子に@classを使っていますが、@つきの属性名なんてそうそう使わないだろう、程度で採用しています。多数のオブジェクトに関わる名称となるので、それを踏まえて重複しない名称に気をつければなんでもいいと思います。こちらに該当するソースがあるので、よければどうぞ。


