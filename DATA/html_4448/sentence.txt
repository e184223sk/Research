More than 1 year has passed since last update.前回の記事では、Application Insights のデータモデルについて説明した。第二回は、Activity について整理してみたい。TelemetryClient と Activity の挙動を理解する (1) - データモデル Activity User Guide (原典)このドキュメントは Actvitiy について説明します。Actvitiy は、診断コンテキスト diagnostic context をストアしたり、アクセスしたりできるようにするクラスです。ロギングによって、使われます。このドキュメントは、Activity のアーキテクチャオーバービューと使い方について説明します。アプリケーションが、オペレーションを実行するとき、例えば HTTPリクエストや、Queue からのタスクなど、アプリケーションは、Activity を生成します。Activity は、リクエストの実行が、システム間でトラックできるようにします。Activity に保存されているContext の例としては、HTTPのリクエストパスだったり、メソッドだったり、user-agent だったり、correlation id だったりします。すべての重要な詳細は、すべてのトレースと共にログされます。詳細は[Activity Reference](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md#activity-reference)にあります。Activity は、Tagsを提供しています。それは、ロギングのみに使われるコンテキストを示しています。Baggage は、外部の依存先に伝搬するためのコンテキストを表します。すべての Activity は Id をもっています。特定のアプリケーションのリクエストを定義しており、Activity が開始されたときに生成されます。Activity(root のものは除く) はParentを持っています。in-process もしくは、外部のものです。例えば、アプリケーションがリクエストを受け取って、外部依存サービスを呼び出した場合、外部サービスを呼び出すための Activity が存在し、それは、親の Activity すなわち、リクエストの受け取りを表す Parent Activity を持ちます。外部依存呼び出しの Activity Id は、リクエストと共に送信されて、おそらく、外部依存サービスのActivityの、ParentId として使われます。これにより、子と親の間のユニークなマッピングが可能になります。Parent は、Activity がスタートしたらアサインされます。Activities は、プラットフォームやフレームワークのコードの中で、おそらく、作られたり、開始/終了したりします。アプリケーションは、アクティビティのイベントを通知する必要があり、実行された Current Activity にアクセスする必要があります。ですので、Activity を作ったコードは、該当イベントを、DiagnosticSource に書いてあげる必要があります。:Current Activity は、スタティックの変数で公開されています。Activity.Current そして、すべてのcall context を流れます。async 呼び出しも含みます。ですので、すべての、Start/Stop イベントのコールバックで利用可能です。アプリケーションは、Activity.Current にコードのどこからでもアクセスする可能性があり、Activity の Context に保存されているコンテキストとともに、イベントのログ出力をどこからでも行うかもしれません。アクティビティは、オペレーション名と一緒に作られる必要があります。これは、大きめの名前で、グルーピングやログのフィルタに使われます。アクティビティが作られた後、詳細を追加することができます。Start time, Tags, そして Baggage一度アクティビティが作られたら、スタートするときです。そして、リクエストの実行を実施しましょう。Start() と Stop() メソッドは、Activity.Current を維持します。これは、async の呼び出しや、リクエストの処理の間有効です。もし、activity が開始されたら、Activity.Current は Id と Parent を持ちます。NOTE
* Activity.Start()やStop()メソッドの代わりに、上のサンプルでは、DiagnosticSource.StartActivity() と StopActivity() メソッドを呼んでいます。それは、DiagnosticSource にイベントを書き込みます。
* Activity の作成は、DiagnosticSource.IsEnabled の呼び出しでガードされます。もし、だれも、DiagnosticSource をリスニングしていない時のパフォーマンスインパクトを削減できます。アプリケーションが、外部呼出しをするとき、例えば、外部の Web サービスを呼び出すとき、新しい Activity が作成されるべきです。この子の Activity が既存のアクティビティの一部である場合、Parent が　Start() 時に自動的にアサインされます。子の Activity は、自動的に Baggage を親から引き継ぎます。上記のサンプルは、どのように、baggage が下流のWebサービスに HTTP request ヘッダを使って伝搬されうるかということも示しています。
前のサンプルにあるとおり、Activity の生成は、DiagnosticSource.IsEnabled() でガードされるべきです。このケースでは、ツールベースのリクエストプロパティを防ぐことができます。例えば URI などです。他の DiagnosticSource がincoming と outgoing のHTTP アクティビティで違うものが使われているのに注意してください。このことは、あなたに、イベントのフィルターで分離できることを意味します。アプリケーションは、Activity Event をリッスンして、ログを出力しているかもしれません。アプリケーションは、Activity.Current にアクセスいｓて、現在のアクティビティの情報を取得することができます。DiagnositcListener convensionに従っています。アプリケーションは、tags と baggage を アクティビティの Start コールバックの時に、Activity.Current に足すかもしれません。Incoming Request Sampleの中にかいています。私たちは、HttpContext を DiagnosticSource に渡しています。それによって、アプリケーションは、リクエストプロパティにアクセスできて、現在のアクティビティをよりリッチにすることができます。Activity Id がすべてのイベントで、ログ出力されていることが必須。ParentId, Tags, Baggage　が、すべてのアクティビティで少なくとも１度ログ出力されるのが必須です。すべてのテレメトリイベントをクエリーと、アグリゲーションをシンプルにするためにログ出力されるかもしれません。Duration は、SetEndTimeが呼ばれた後に有効です。そして、Activity Stop イベントが発生したときに、ログ出力されます。NOTE: アクティビティは、Tags や Baggage には、重複するキーを認めています。Activity の主なゴールは、テレメトリイベントをユーザリクエストを紐づけることです。Activity.Id は、この機能のキーパーとです。アプリケーションは、Activity を開始して、終えるべき仕事の論理的なピースを表します。一つの Activity は、ほかの Activity の子としてスタートされることがあります。全体のオペレーションは、Activity のツリーとして表現されるかもしれません。すべてのオペレーションは、分散システムで、実施されて、Activity ツリーの森として表現されるかもしれません。Id は、Activity を森の中でユニークに識別します。それは、階層的な構造をもっており、効果的に Activity のツリーを表現します。Activity.Id は、HTTP Correlation Protocol のhierarchical Request-Idを表します。|root-id.id1_id2.id3_id4.たとえば
|a000b421-5d183ab6.1.8e2d4c28_1.| で開始されて、root-id が続き.が続き、そして、全てのローカルのアクティビティの識別子が、. か _ で区切られます。
Root-idは、すべてのオペレーションを識別し、Id は、特定のアクティビティが含まれているオペレーションを識別します。
| は、Id が階層構造になっていることを表しており、ロギングシステムには有効な情報です。アクティビティを最初にスタートさせたとき、あなたは、Activity.SetParentId(string) で、ルートIdをオプションでセット可能です。もし、セットしなければ、アクティビティは、root-id を生成します。例えば a000b421-5d183ab6もし、他のプロセスからの、ParentId がなくて、生成したいなら、Root-Id に関して次のようなことを心にとめておいてください。root id を取得するには、Activity.RootId を使いましょう。ただし、ParentId がわたされるか、Activity が開始された後で。子アクティビティは、親と同じプロセスでスタートします。Parent.Id を取得して、自分の Id を適切な Parent.Id にInt型のサフィックスをつけて作成します。例えば &lt;Parent.Id&gt;.1. サフィックスは、Int型で、同じ親からスタートした子アクティビティの番号です。アクティビティは、Id を生成して、parent-id.local-id のフォーマットに従います。親が別プロセスのアクティビティの場合、Parent-Id をStart する前に、アサインする必要があります。Activity.SetParentId(string) を使います。Activity は、ほかのサフィックスを Id に使うかもしれません。Root Id で説明したとおり、_ のデリミタが、親が、ほかのプロセスから来たことを表します。もし、外部の ParentId が、| からスタートしていないなら、アクティビティは、| と自分のId を先頭につけて、ParentIdをキープします。同じように、最後が . で終わっていないなら、追加します。アクティビティは、Id を生成して、parent-id.local-id_ というフォーマットに従います。local-id を Parent.Id に足すことは、長さの制限を超えてしまう可能性を意味します。オーバーフローした場合、Parent.Id の最後のバイトは、削除されて、32-bit のランダムな、小文字の16進数でエンコードされた整数型と#デリミタで埋められます。これは、オーバーフローを表します。&lt;Beginning-Of-Parent-Id&gt;.local-id#がっつり翻訳してみましたが、Activity は、コリレーションの内容を、保持、更新してくれて、親子の関連付けなども行ってくれる便利クラスのようです。ただ、これが、自動でテレメトリを送信することはなさげなので、それは、DiagnosticListener の役割のようです。Id も自動で振ってくれるようすなので、なかなかいい感じです。ただ、W3C TraceContextには対応してなさげですが、ローカルで試したところ、&lt;PackageReference Include="Microsoft.ApplicationInsights.DependencyCollector" Version="2.8.0" /&gt; を足すとW3CActivityExtensions.csが追加されて、W3C の Traceparent や Tracestate が使えるようになるようです。次は、TelemetryClient と Activity の関係を見ていきたいと思います。intact adj: complete and in the original state:
*Cambridge dictionary


