More than 3 years have passed since last update.CosmosDB のマルチパーティションのコレクションで、集計関数を使おうとして結構はまったので、自分のために記録しておく。パーティションを持ったクエリの方法は、複数ある。一つは、パーティションキーを含んだ Where 句を持つこと。もう一つが EnableCrossPartitionQuery を True に設定すること また、クエリの方法として、単純に SQL を指定する方法と、Linq を使う方法があるので、それぞれ試してみよう。次のようなコレクションがある。この形を持ったコレクションをマルチパーティションで作る。TeamId がパーティションキーになる。この場合、SQL べた書きの場合は次のように書ける。通常だと、client.CreateDocumentQuery&lt;T&gt; を使いたくなるところだが、残念ながら、このSum() を使うに当たってはいくつの制約があった。クエリの先頭に VALUE 句を指定しないと Sum が動作しなかった。指定しないと次のようなエラーに遭遇する。VALUE を指定しろと言われる。にするとこれはこれでエラーになる。as Downtime の指定がだめ。ほかにもみたいに返すのもNG だった。メモメモ。上記のような生SQLはかっこ悪いし、SQLインジェクション出来そうであまりやりたくない。Linq で書こう。でもどうやって書くのだろう？試してみるととても簡単だった。ただし、マニュアルにはサンプルなども書いていないので、VS のIntellisense を見ながら書くのが良いだろう。クロスパーティションクエリーになると、パフォーマンスがどうなるんだろうか？とかはとても心配になるポイントなので、実際に１万パーティションにそれぞれ２つのドキュメントを持つようなデータを作成して、クエリしてみた。私の理解がただしければ、PartitionKey を指定すれば、一発で検索に行くので、コストは高くなくて、リクエストをパーティションに投げることもないはずだ。結果として両者のパフォーマンスは同じ程度だった。次の結果を見てみると、一瞬 Linq のほうが優秀に見えるが、そうではなく、先に実行したほうがあのスコアになるので、キャッシュの関係と思われる。Fiddler でどのようなリクエストが送られているか見てみた。実際に発行されているSQLはそれぞれ２つづづ。/ にリクストを投げています。データベースの基本設定をとってきている雰囲気レスポンスこちらは、具体的なコレクションへのクエリで設定をとってきています。Cosomos にデータベースや、Collectionの名前を指定していますが、こういうフローになるのですね。次のクエリはパーティションキーのハッシュに対してクエリがされています。パーティションのレンジなどパーティション情報が返ってくる様子。最後に、SQL もしくは、Linq のクエリです。上記のクエリは、SQL と Linq の２回クエリをかけていますが、１回のみでした。つまり必要なときのみクエリされるということでしょう。だから最初の１回のクエリは遅いのですね。Linq のクエリはほぼ同じなので省略します。パーティションに対する集計のクエリをかいて、１００００パーティションに分散させてみましたが、クエリ自体は一発で終了しているようで快適でした。パフォーマンスチューニングなどは一切していませんが、今回のユースケースに関しては問題なさそうです。(CosmosDBトリガーを使ったバッチ処理)サンプルを GitHub に置いておきました。Cosmos DB Client SpikeSQL queries for Azure Cosmos DBQuerying partitioned containersBug: Unexpected behaviour of aggregates in Query Explorer VALUE が必要になることについて


