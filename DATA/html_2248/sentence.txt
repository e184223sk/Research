Blazorにおけるログイン認証の手法の個人的なまとめです。
下記のようなログイン画面を実装する際のメモです。デモ
ソースコード.NET Core SDK 3.1.100
Microsoft.AspNetCore.Blazor.Templates::3.1.0-preview4.19579.2
Visual Studio 2019 16.4.0その他、記事内で使用しているパッケージ
Microsoft.AspNetCore.Components.Authorization 3.1.0
Blazored.LocalStorage 2.1.1
FirebaseAuthentication.net 3.4.0
MatBlazor 2.0.0WebAssembly版(Client版)での話となります。過去VueやNuxtで作成したSPAは下記のような流れで実装を行いました。
(どこまで一般的か不明ですが…)今回も、上記のような考え方で実装を行います。BlazorのWebAssembly版(Client版)のテンプレートからプロジェクトを作成後、
認証関係のモジュールのインストールが必要です。
Nugetから下記のモジュールをインストールしてください。Microsoft.AspNetCore.Components.Authorizationインストール後、_imports.razorに下記の参照を追加
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Authorizationまた、Program.csに下記を追記します。
builder.Services.AddOptions();
builder.Services.AddAuthorizationCore();まずは、UI側に関する説明を行います。ページ内の特定の要素だけ認証時に表示させたい内容には、下記のようにAuthorizeViewタグを付与することで実現できます。
@context.User.Identityでユーザ名等を使用することが可能です。ページ全体を認証時にのみ表示を行いたい場合には、[Authorize]属性を付与します。
なお、未認証時にログイン画面にリダイレクトさせたい場合の方法は下記で紹介しています。
https://qiita.com/nobu17/items/d43b18b8d42e7d0b4535先ほど、紹介したUI要素が認証及び未認証といった状態を認識するための仕組みとして
AuthenticationStateProviderといった抽象クラス提供されています。
このクラスを実装することで認証の仕組みが実現できます。認証が必要となったタイミングでこのメソッドが呼び出されます。
戻り値に返されるAuthenticationStateの値により認証されたかどうかを判断します。ログイン/ログアウト等で認証状態が変化した場合にこのメソッドを呼び出すことで状態変更がAuthorizeViewなどに通知されます。AuthenticationStateProviderを継承した認証プロバイダを作成します。
前述のとおり、ローカルストレージに認証情報を保存するために、Blazored.LocalStorageを使用します。
Nugetからインストールしてください。
インストール後。Program.csにbuilder.Services.AddBlazoredLocalStorage();を追記します。。ILocalStorageService及びHttpClientをコンストラクタからDIします。
HttpClientをDIする理由は、認証用のトークンをヘッダに設定するためです。
(HttpClientはインスタンスが共有される。)ローカルストレージに認証情報を保持することで画面をリロードしてもトークンが期限切れになるまで再度ログインする必要がなくなります。
また、外部のサービスから認証変更を通知するためのメソッドを追加します。認証するWEBAPIと連携してAuthenticationStateProviderに認証場を渡すクラスを作成します。
まずは下記のようなログイン用のインタフェースとモデルを定義します。実際のAPIをコールせずにダミーの応答を返すような場合は下記となります。最後にStartup.csにおいてクラスの指定を行います。
AddAuthorizationCoreメソッドも追加してください。作成したDummyAuthServiceをログイン画面から呼び出すことで認証処理を行います。
下記に例を示します。
(UIはMatBlazorを使用しています。)先ほどはダミーの認証サービスを使用しましたが、FirebaseAuthenticationを使用した場合の例になります。予め、FirebaseAuthentication.netをNugetからインストールしてください。
認証APIを呼び出して、結果からトークンを取得しています。Firebase自体の細かい仕組みなどは、下記などが参考になります。
http://kmycode.hatenablog.jp/entry/2017/02/09/205655認証の仕組みによっては、ユーザ毎に権限を設定して、権限に応じて表示があると思います。
(例:管理者だけが操作可能な画面)
Blazorでは以下の2種類の権限の仕組みを提供します。下記のようにRolesで表示を許可するRoleを指定します。下記にAuthenticationStateProviderにRoleを認識させる場合の例にを示します。トークンと同じく、認証サービス側から取得した情報をローカルストレージに保存しておいて使用するといった形になります。PolicyはRoleを発展させたもので、複数のRoleをまとめて扱ことが可能です。
複数のロールがある場合に、纏める場合に便利です。(例:IsAdminポリシーはAdminロールとSuperUserロールに対して割り当てる)UIへの割り当てはRoleと違いはありません。StartupのAddAuthorizationCoreメソッド内で、ポリシーに対して対応するRoleを指定します。後はRoleの場合と同様に、認証のタイミングでユーザに割り当てるロール設定を行います。認証状態をコンポーネント内の独自のロジックに組み込みたい場合、CascadingAuthenticationStateを使用します。
下記のようにCascadingAuthenticationStateタグで要素を囲むことで使用可能となります。App.razorを囲むことで全てのコンポーネント内で使用可能になりますが、特定のコンポーネント内で使用することで部分的に有効化することも可能です。各コンポーネント内で、状態を取得するには下記のようにします。CascadingParameter属性を付与したTask型の変数を定義することで、認証情報が取得可能になります。BlazorのWebAssembly版における認証の方法を紹介しました。
VueやNuxtを利用していると、自前でVuexのStoreでログイン状態の管理を自前で実装する必要があったりと手間でしたが、フレームワーク側で定義されているとある程度、楽ができていいですね。当初はFirebaseAuthenticationではなく、Cognitoでの認証を考えていました。
Client版のBlazorの場合、HttpClientはそのままでは使用できず、ブラウザ用のHttpClientとしてinjectする必要があるので、内部でHttpClientが使用されていると動きません。下記を参考にCognitoのSDK内で使用しているHttpClientを置き換えることで認証まではできましたが、非同期処理なのにリクエスト中に画面がフリーズしてしまい、スピナーによるローディング画面が表示できず諦めました。
将来的に使えるようになると良いのですが・・・。一応ですがCognitoの場合に試したコードも下記にいれてあります。
ソースコードhttps://docs.microsoft.com/ja-jp/aspnet/core/security/blazor/?view=aspnetcore-3.1&amp;tabs=visual-studio
https://gunnarpeipman.com/client-side-blazor-authorizeview/
https://gist.github.com/SteveSandersonMS/175a08dcdccb384a52ba760122cd2eda
https://chrissainty.com/securing-your-blazor-apps-configuring-role-based-authorization-with-client-side-blazor/
https://chrissainty.com/securing-your-blazor-apps-configuring-policy-based-authorization-with-blazor/


