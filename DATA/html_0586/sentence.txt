来月（2020年11月）に、「.NET Framework」「.NET Core」を統合させた「.NET 5」がリリース予定です。
「.NET 5」ではC#も新バージョン「9.0」となり、新機能が幾つか追加されています。C# 9.0 の新機能その中の機能の一つとして、新たな型「レコード（record）」が追加されました。
「レコード」の概要は以下のように説明されています。C# 9.0 には "レコード型" が導入されています。これは、等価性の値のセマンティクスを提供するための合成されたメソッドを提供する参照型です。 既定では、レコードは変更できません。※.NET 5のバージョンは「5.0.100-rc.2.20479.15」にて確認LastNameとFirstNameというプロパティを持った「PersonClass」と「PersonRecord」というオブジェクトを定義し、
実行してみます。PersonClass同士のEqualsの結果はfalseです。
これはObject.Equalsの機能は既定では以下となっているからです。参照型(class)の場合
二つの参照型オブジェクトが同一のオブジェクト(=参照先のオブジェクトが同一)である場合にtrue、そうでなければfalseを返すオブジェクトが同一 = インスタンスが同じかどうかを比較するだけ、ということですね。
personClass1とpersonClass2はそれぞれnewされていて別のインスタンスなので、結果はfalseということです。一方、PersonRecord同士は別のインスタンスとなっているにも関わらずEqualsの結果はtrueとなっています。これは、前述の公式ドキュメントの記載のとおりです。レコード定義によって、FirstName と LastName の 2 つの読み取り専用プロパティを含む Person 型が作成されます。 Person 型は参照型です。 IL を見た場合は、それはクラスです。 どのプロパティも作成後に変更できないので、それは変更できません。レコード型を定義すると、コンパイラによって他のいくつかのメソッドが自動的に合成されます。recordはコンパイルされるとclassとなり、定義されている全プロパティの値ベースの比較を行うEquals、GetHashCodeが自動で生成される、ということですね。classと比べてrecordを使うと何がおトクなのかというのは、class（参照型）で値ベースの比較を行わせるようにするには、
自前でEqualsやGetHashCodeをoverrideする必要がありましたが、
recordはそれらを自動で実装してくれる=実装の手間が省けるということですね。参考：型の値の等価性を定義する方法 (C# プログラミング ガイド)また、classではToStringも既定ではそのclassの名称を出力するだけですが、recordではToStringもOverrideされてプロパティ名、その中の値も出力してくれるようになっています。構造体（struct）は値型なので、structのEqualsでも値ベースの比較を行ってくれます。ですが、前述通りrecordはコンパイルされるとclassとなるので、継承も使用することが出来ます。レコードによって、継承がサポートされます。 構造体は継承を使用することは出来ません。
レコードはクラスの特性を持ちつつ値ベースの比較を行ってくれるということですね。参考：C#のクラスと構造体の違い・使い分け方※@Zuishin さん、コメントありがとうございました。さらにレコード特有の機能「with式」により、一部のプロパティのみ値の違う複製オブジェクトを作る事が簡単に行えるようになりました。with式を使う場合、こちらも9.0における新機能「init専用セッター」をプロパティに指定する必要があります。
↑
※@Zuishinさんに再びコメントで補足いただきました。
レコードの場合は以下のように宣言すると、デフォルトで init セッターが使用されます。参考：init 専用セッター想像ですが、ドメイン駆動開発におけるバリューオブジェクトに適用できるのではないかと考えています。参考：.NETでドメイン駆動開発～ValueObject後編～ValueObjectとは、
・・・
全プロパティ値が同じなら、同じオブジェクトである。例えオブジェクトのアドレスが異なっていても同じオブジェクト、として認識される。Javaでは14で既に対応されていたようですね。参考：Java14が出たので、とりあえずrecordを試してみた※参考の記事を読んでしまうと、「C#のレコード型はJava14で追加されたRecordと同じです」で説明が済んでしまう気がしてきた・・・


