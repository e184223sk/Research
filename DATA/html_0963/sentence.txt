More than 1 year has passed since last update.　様々なツールの登場によって、ソフトウェアテストの自動化がどうも容易になってきたらしい。つまり、作業者が退社して出社する間にテストをPCにやらせることが出来る。とは言っても時間は有限である。
社員「このボタンを押せば全てのテストが完了します」
社長「時間はどのくらい掛かる？」
社員「10年です」
は流石にあほ（実際、自動テストは人間の代わりにテストの大部分をやってくれますが、人間よりは遅い印象。あくまで省力化であって時短テクではないですね）。
時間短縮出来る部分は短縮すべきだろう。特に、対象のソフト内の要素（ボタンであったりマス目であったり）を取得するステップは1つのテスト内で大きな時間を要するだろう。
　この要素取得はおおまかに分けて3通り考えられる。　探索範囲で見れば、案1＞案3＞案2の順に大きいだろうから、案2が最速な気がする。では実際どうか？
　この記事では、Windows Application Driver (WinAppDriverとも)による自動テストの大部分を占めるソフトの要素取得に要する時間が、その取得法によってどう変化するかを調べた結果を示す。試した結果、中間の要素を1段ずつ取得する案2は案1よりわずかに遅くなり、案3が圧倒的に最速なことが分かった。案2では所要時間を改善できない上に細かすぎるため、ソフトのアップデートで中間要素が変わった場合にメンテナンスが苦行になるという点で有用と言えない。また、GUIのアップデートに対応するのがそんなに苦ではないラインを見極めて案3を取るのが良いだろう。GUIのアップデートが激しい開発中の段階ならば、開発チームにAutomationIDの付与をお願いして案1を取るのが良いだろう。（飲酒執筆をしているので文体の統一が出来ていません）
2020年8月1日 : 初稿
2020年8月2日 : ほぼ全部変えた　ぶっちゃけMicrosoft.WinAppDriver.Appium.WebDriverはAppium v.3系を使ってて古いです。ですが環境構築が楽なのでそこはご愛敬。
　コード作成と実行はVisual Studioを使用した。　ソフトウェアテストのデモとして、Excelの「中央揃えボタン」を取得してクリックするテストを実行する。
その取得法を上記の3種類で行った。所要時間を比較するため、要素取得のステップを10回繰り返している。
　テストを行うためのセッション形成はSession.cs、テストの実体はTest.csである。コードは後に示す。
　実は上の図が、今回実験で行う実際の要素取得手順である。Testメソッド名も案1~3にしてある。　Excelとのセッション形成は、WinAppDriverのサンプルコードを参考にしてとした。
そしてテスト実行のコードはである。ConstTest()は案n()（$n=1, 2, 3$）の動作時間から共通部分に掛かる時間を差し引くための物である。　実行時間はVisual Studioのテストエクスプローラーに表示された物を使用した。結果は下表の通り。試行回数は3である。単位は秒である。　つまり、予想に反して案3が1桁少ない高速さを誇り、案2がわずかな差ではあるが最も遅かった。　やはり最初に探索範囲を絞ってから要素を取得した案3が爆速であった。だからといって、Findの度に中間要素を細々取得する案2は改善しない上に保守性が劣悪なので悪手だろう。多分FineBy系のメソッドはそれ自体が時間を食うから案2がダメだったんでしょうね。案1は確かに遅いが、AutomationIDがあったり、Nameが奇跡的にuniqueで多言語対応しなくて良いならGUIの変更に対して最強である（このNameに関する仮定は万に一つ無いだろうが）。
　しかし、案2を取らざるを得ない状況が存在する。目的要素にAutomationIDが無く、その他の値でも一意に取得できない時である。そんなときはさっさとAutomatinIDを付けましょう。たとえその要素の使用頻度が低くても。　要旨のセクションにも書いたが、中間要素をいっぱい取る気遣いをしたところで、そのボタンの場所が階層レベルで変更されたら即死するので使い物にならなくなる。ソフトのGUIはバンバン変更される物だろうから、メンテに時間を掛けなくて良いようにやっていきましょう。この塩梅をうまく見極めて案3を使えるのが理想だろう。それでも仕様変更が盛んだがテストもやらなきゃいけない佳境（やさいいことば）において役立つのがAutomationIDだ。このメリットに言及している記事は星の数ほどありますが、1要素に1つずつ設定できること、Nameとは違ってlocalization対応をしなくて良いこと、この二つだけで多くの人命が救われる。そう、多くの。。。ヤバいときはまずAutomationID頼りで案1で行くのが堅いだろう。案3をとって日々最新版に合わせる作業をするか、落ち着いた頃に案3に切り替えるの、どっちが楽でしょうね。でも自動テストコードのデバッグが激烈遅いと生産性も集中力もそがれるからな。。。
　ということで、実行速度は
　案3&gt;&gt;案1＞案2 の順で速く、
　保守性は
　案1&gt;&gt;案3&gt;&gt;案2 の順で良いと考えられる。　以上、非常に簡単ではありますが報告とさせて頂きます。この記事が一人でも多くの「要素を一段階ずつ拾った方が速いんじゃね？」と考えた人の出鼻をくじき、実証実験の（無駄）手間を省ければ幸いです。その人こそが私なんですけどね。


