More than 1 year has passed since last update.cf. 不動点コンビネータを用いた無名再帰関数の実行まとめすごく簡単に言うと、「再帰じゃない関数を引数にとって、再帰関数と同じ動きをする関数に作り替えてくれる高階関数」です。再帰関数の例として、例えばフィボナッチ数を返す関数をJavaScriptで書いてみるとと書いてもいいわけですが、記事の都合で末尾再帰の形にしてとまあこんな感じの末尾再帰にしたfibonacciを、さらにカリー化して例にします。上のfibonacciはfunctionで定義されていますが、これをカリー化したアロー関数（匿名関数）で書きたい場合はこんな感じで、再帰するには一旦fibonacciという名前の変数を作っておいてから書き換えてやらないといけないと思ったがそんなことはなかったぜ。ここに不動点コンビネータであるfix関数があればこんな感じで、再帰してないアロー関数（匿名関数）fを使って再帰関数fibonacciができあがります。不動点コンビネータがあると嬉しい、というようなものではないのですが、まあ計算理論として興味深い、というぐらい。不動点コンビネータ - Wikipediaも読んでおくといいでしょう。fixの方を再帰定義にしてよければ、割と簡単です。ただし、引数を名前呼び（遅延評価）する言語と値呼び（正格評価）する言語でちょっと書き方が変わります。C# と F# はどちらも後者になります。fixの型を疑似的に表すと ((T1 =&gt; T2) =&gt; (T1 =&gt; T2)) =&gt; (T1 =&gt; T2) です。C#の例です。Fixをスタティックメソッドにしておきました。
Fixを呼び出しているところの型引数Fix&lt;int, Func&lt;int, Func&lt;int, int&gt;&gt;&gt;がうっとうしいですが、C#のラムダ式には型がなく、外から与えてやる必要があるので、仕方ありません。型引数を省略しようとすると、今度はラムダ式をキャストして、型を明示しないといけません。F# はOCamlベースで、カリー化されていて、型推論も強力なのですっきりしています。不動点コンビネータ―fixの方も再帰なしで定義する例として、有名なのはYコンビネーターですが、静的型付け言語だとYコンビネーターにはうまく型が付けられないので、代わりにZコンビネータ―を定義します。Zコンビネータ―は、関数は再帰しませんが、型の定義が再帰します。C# や F# では、独自のデリゲート型を定義することで、型の定義が再帰するような関数やメソッドの型を用意できます。ただ、デリゲート型をF#で扱うのはちょっとだけぎこちなくなります。C# はこちら。Zの定義の中でラムダ式をRecursive&lt;T1, T2&gt;デリゲート型にキャストする形で型を明示しています。F# はこちら。デリゲート型をインスタンス化し、呼び出しにInvokeメソッドを使うなど、オブジェクト指向的なデリゲート型の扱いがC#よりもあからさまになっています（C# もバージョン1の頃はnewでデリゲート型をインスタンス化していました）。


