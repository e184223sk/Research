More than 1 year has passed since last update.Unityでは特定のゲームオブジェクトの処理を呼び出すメッセージング機能としてが存在します。
どちらもイベント送信元が送信先ゲームオブジェクトを指定して処理を呼び出すものです。
直接メソッドを呼び出すわけではないので、送信元→送信先は疎結合？なのかもしれないですが
送信先を意識せずにイベントをブロードキャストしたい場合に使いづらいな…と感じました。そのためExecuteEvents.Executeの仕組みを利用しつつ、送信先を意識せずにイベント配信できるように拡張モジュールを作成しました。通常のメッセージシステムでは[受信側]
　特定のインターフェースを継承して処理を実装
[送信側]
　イベント送信先(受信側)のゲームオブジェクトを取得した上で
　特定のインターフェースを指定して実行ですが、以下のように利用できるようにしました。[受信側]
　特定のイベント種別を指定してもらうように自身(別ゲームオブジェクトも可)を事前登録
[送信側]
　イベント送信先(受信側)を指定せずにイベント送信
　　→事前登録されたゲームオブジェクトにイベントがブロードキャストされる諸々の処理をラップ・共通化している拡張イベントハンドラがこちらです。
各種イベント情報クラスのインスタンスを生成して送信すると
最終的にはExecuteEvents.Executeで、事前に受信登録(AddLitner)されているゲームオブジェクトすべてにイベント送信されます。
そしてfunctorに指定している関数(Callback)で、各イベント情報に対応したインターフェースが呼び出されるようになっています。実際に上記モジュールを用いてイベント送受信する際は以下のようにします。上記例では受信用インターフェースは1種類(IEventReceiverEx)ですが
通常、メッセージシステムを使用する場合は恐らくイベントの種類に応じてインターフェースを分けた上で、受信側で必要に応じてインターフェースを(多重)継承するのだと思います。
(そうすることで必要なインターフェースの実装だけ行う)今回作成した拡張モジュールは、あくまでも1種類のみのインターフェースを想定しているので
イベントの種類が増えた場合に使い勝手が悪いかもしれません。C# 8.0ではインターフェースのデフォルト実装が可能なので、このあたりの不都合も解消されることを期待しています。。。
UnityでのC# 8.0は開発環境によってサポートされていたりいなかったり？うちの環境では未サポートだったため今後に期待です。以上です。


