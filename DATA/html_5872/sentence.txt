More than 3 years have passed since last update.前回の続きとして、PropertyInfoをもとに高速なプロパティアクセスの動的生成を行います。基本的なやりかたは前回と同様、以下の手順で行います。まずは単純そうなところからということで、以下のようなstring型のプロパティを持つDataクラスと、そのアクセスを行うIAccessorをサンプルとして書いてその再現からはじめてみます。SampleDataStringValueAccessorで行っているのはプロパティへの直接アクセスであり、必要なコストはキャストだけなため、リフレクションを使うよりも高速に動作します。サンプルコードをビルドして、その内容をildasm.exeを使用して確認します。今回はこのSampleDataStringValueAccessor相当の内容を動的に作成していきます。なお、内容から類推できますが、プロパティ及びコンストラクタの定義については扱っている型がConstructorInfoからPropertyInfoになっているだけで、構造は前回のIActivatorの実装と同様です。よって、その部分は前回の内容を参照する形都市、今回はGetValueメソッド及びSetValueメソッドの実装についてのみ絞って記述します。例によって、まずはildasmでメソッド定義の内容を確認します。この内容をもとにしたメソッドの定義は前回のIActivator.Createと同様で、以下のようになります。ILも特に難しい点はなく、キャストしたプロパティの値を取得しているだけです。特に難しい点はないので、さくさく進めていきます。まずはildasmの結果から。メソッドの定義もGetValueと同様で、以下のような感じで。ILについても、C#で書いたコードのイメージそのままなので難しい点はないと思います。とりあえず使ってみましょうか。このような感じで、プロパティへのアクセスが確認できると思います。では、ここでstring型以外の型に使ったらどんな結果になるでしょうか？まずは以下のような、int型のプロパティを対象にしてみます。現時点でのコードを上記のようなプロパティに対して適用すると、正しい値で処理されないことを確認できると思います。現時点ではValutTypeに対応していないため、このような結果となっています。ValueTypeに対応したILを生成するため、int型のプロパティを処理するサンプルを作って逆アセンブルしてみます。サンプルのGetValue及びSetValueは以下のよう実装とし、nullが指定されたら0を設定するようにしています。この結果をildasmで確認すると、GetValueとSetValueはそれぞれ以下のようになっていることが確認できます。さて、ここでGetValueはstringの時と比べてboxが追加されているだけなので単純ですが、SetValueの方はぱっと見わかりづらいと思います。そこで、サンプルソースを以下のような形で、nullかどうかで分岐するような記述に変更してみます。そうすると、ildasmの結果は以下のようになりました。更に、処理毎に区切ってコメントを入れると、以下のような内容だということがわかります。このように、サンプルの記述によって生成されるILも変わってくるので、生成されるILのわかりやすさと効率を考慮しながらサンプルを修正していきます。そして生成されるILが望ましい形となったら、その内容で生成コードを書いていきます。GetValueについては、元のコードにboxの対応を入れれば良いだけなので、既存のコードへ処理を追加して以下のような形となります。SetValueについてですが、既存のコードへの処理追加を考えた場合、まずValueTypeかどうかで処理を分岐した方がわかりやすくなると考えられます。そこで、まずは以下の用な形として、コメントの部分にValueTypeの時のコード生成処理を追加していきたいと思います。ValueTypeの時のコードについては、ILの内容を確認すると下記のように最初にnullかどうかの分岐がある内容となっています。まずはこの構造を再現するため、ValueType用のアウトラインを以下のように作り、nullの時とnull以外の時の処理を埋めていく形にしたいと思います。まずは簡単なnull以外の時のコードについて、サンプルのILを抜粋して再度確認してみます。この部分だけ見ると内容はstringの処理と比べてunbox.anyが増えているくらいなので、以下のようにIL生成コードにすることは難しくないと思います。次にnullの時の処理ですが、null以外の時と比べて考慮が必要な点があります。まずはサンプルのILを抜粋して再度確認してみます。考慮が必要なのは、上記の初期値のスタックの部分で、型によって設定する初期値の値が異なるため、その対応が必要となります。初期値について、まずはプリミティブ型への対応のみを考えて、それ以外のValueTypeへの対応は次章以降に記述します。プリミティブ型への対応については、下記のようなテーブルを用意して処理を行いたいと思います。このテーブルを使うと、ValueTypeにnullを設定されたときの処理は以下のように記述できることになります。プリミティブ以外への対応を行うため、以下のようなサンプルを作ってその結果を逆アセンブルしてみます。なお、GetValueについては生成されるILは既存の処理と同じになるため省略しています。SetValueの逆アセンブル結果から初期値による設定部分を抜粋すると、以下のようなILになっていることがわかります。ローカス変数にValueTypeを初期化して、それを設定する処理となっています。これで、プリミティブ以外の構造体への対応もできました。さて、これまでの処理でValueTypeの初期値に関する処理は完成かというと、Enumへの対応が正しくありません。まず、Enumを扱うサンプルを作って、その逆アセンブル結果を見てみます。SetValueの逆アセンブル結果から初期値による設定部分を抜粋すると、以下のようなILになっていることがわかります。初期値はldc.i4.0で設定され、これはMyEnumの基となっているint型の初期値の設定処理に同じです。Enum型の基となっている型はGetEnumUnderlyingType()で取得できるので、これまでのコードを以下の形に変更することでEnumへの対応もできることになります。他に考慮漏れの処理がないかというと、プロパティが読み取り専用/書き込み専用の場合の考慮が漏れています。プロパティが読み書きの処理に対応していない場合には、NotSupportedExceptionをスルーする形にしたいと思います。この処理のILについては、以下のような形で生成します。一通りの考慮ができたと思うので、GetValue及びSetValueのIL生成部分について完成形を確認しておきます。前回と今回の内容で、ILのこねかたについてのイメージが出来たのではないかと思います。逆アセンブル結果を再現する方法であれば、正解があるわけですから動的生成コードの実装も容易となります。また、interfaceを用意してその実装クラスを動的に作成するという方法については、動的生成がサポートされない環境において、コンパイルタイムのコード生成に切り替えるといった事も容易となるため、お勧めの方法だと考えます。なお、前回と今回の内容に関して、ソース全体についてはEmitExampleのコードを参考にしてください。ILがこねられるようになれば、もうなにも怖くない(｀・ω・´)魔力は満ち、運命の扉は今開かれた。いざ約束の地へ！(これでみなさんもILの先生です。Let's enjoy IL life)


