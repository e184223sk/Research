More than 1 year has passed since last update.追記 (2019/10/5)Slice して CopyTo したらええやん？とのことでした。たし🦀
しかもバグってるっていうね。どんまい。
この記事は記録のため残しておきます。配列をコピーする場合、.NET には以下の API が用意されている。
- Array.Copy(Array, int, Array, int, int)
- Buffer.BlockCopy(Array, int, Array, int, int)引数が示す通り、上記は Array にしか対応していないが、昨今の C# 界隈では Span を使った配列操作が目玉になっているので、Span に対応したコピーメソッドを作ることにした。手始めに、Buffer.BlockCopy のソースコードを見たところ、以下のようにコメントされていた。意訳一つのプリミティブな配列から別のプリミティブな配列に型を無視してコピーします。内部的には memmove を呼び出しています。count と offset のパラメータはここではバイトです。伝統的な配列のインデックスやカウントを指定したい場合 Array.Copy を使用してください。ということで、memmove を検索してみると gcc のソースコードが出てきました。見た感じただ配列の要素をコピーしてるだけっぽいので、C# で実装してみました。実装的にはほぼ同一です。
ベンチマークをしてみました。.NET Core 2.1.12 だと他と比べるとだいぶ遅いですが、.NET Core 3.0.100 だと一番早くなってます。Span 周りに最適化があったのかな？ しかし .NET Core 3.0.100 で stackalloc した配列への書き込みが遅いのはなんでだろう。。コピーが走っていると思って dest を ref にしてみましたが変わらず。引き回す Span は stackalloc しないほうが良いのかも？


