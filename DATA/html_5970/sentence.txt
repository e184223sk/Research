More than 3 years have passed since last update.Unityは基本的に回転をクォータニオンで管理しています。
その他のエンジンも、おそらくクォータニオンで回転を制御していると思います。
というのも、オイラー角では「ジンバルロック」などの問題があるため、制御するのに不安定さがあるためです。しかし、場合によってはオイラー角で値を求めたい場合があります。Unityであれば、クォータニオンから簡単にオイラー角を取得することができますが、では内部ではどういう処理が行われているのか。
それを色々な記事を参考にまとめてみたいと思います。まずはクォータニオンから回転行列を取り出します。
回転行列の要素から、オイラー角を推測するためです。まるぺけさんのこちらの記事（その58 やっぱり欲しい回転行列⇔クォータニオン相互変換）を参考にさせてもらうと、クォータニオンの各成分から回転行列を求めることができるようです。まず、任意軸の回転行列は以下のように構成されます。
$n$は回転の軸ベクトルの各成分です。クォータニオンの各成分は、回転軸ベクトル$\vec N$と角度$\theta$を用いて以下のように構成されます。行列の位置を明確化するために、行列を以下のようにナンバリングしておきます。※ m03, m13, m23, m30, m31, m32はすべて0、m33は1です。さて、ではまずはじめに、m00の値（$n_x^2(1 - cos \theta) + cos \theta$）を見てみましょう。
これを、クォータニオンの成分から表すと$1 - 2y^2 - 2z^2$となるようです。一瞬、「なんでやねん」と思うかもしれませんが（自分は思いました）、倍角の公式などを使って展開してやるとしっかりとその値が出現します。ちなみに三角関数の公式などは前にまとめた記事があるのでそちらも参照してみてください。（[数学] 三角関数について整理する）倍角の公式は以下になります。試しにやってみましょう。まずは$-2y^2$から展開してみましょう。なので、2乗すると、となります。
さて、ここで「$cos(\theta) = 1 - 2sin^2(\frac{\theta}{2})$」を使います。
上記にこれを代入すると、となります。同様に、$-2z^2$を展開して以下を得ます。さてここで、各$n$成分は正規化したベクトルなので以下が成り立ちます。つまり、求めたい値は$1 - 2y^2 - 2z^2$です。現状の状態で整理すると以下のようになります。これに「$nz^2 = 1 - nx^2 - ny^2$」を代入すると、ゴールが見えてきました。
これを展開すると、最初に示したm00の値が出てきました！ なんともすばらしいですね。あとは、他の要素もこうして算出していくと、最終的に以下のようになります。回転行列からオイラー角を求める部分についてはこちらの記事（回転行列からオイラー角のパラメータ抽出を行う | It_lives_vainlyの日記）を参考にさせてもらいました。そして、Unityでの回転行列の作り方（各軸の回転行列のかける順番）は、上記記事と同じくZXYです。
ドキュメント→ Unity DOCUMENT | Transform.eulerAngles実際に行列をそれぞれ合成していくと以下のようになります。
※ CnはCos、SnはSinを表し、それぞれの添字はどの回転行列のものか、を示しています。さて、ここで$m21$を見ると$Sin(x)$となっています。
ここから、が導き出されます。
次に、を利用して、として、$\theta z$が求まります。同様にして、と、$\theta y$が求まります。これで無事、各値が求まった・・と思いきや、特殊なケースが存在します。
それが、$cos(\theta x) = 0$のときです。$cos$が$0$の場合、そう、$\theta x$が$\frac{\pi}{2}$と$\frac{-\pi}{2}$のときですね。
Cxが0の場合、すべての値0になってしまって答えを求めることができなくなってしまいます。そこで、その特殊なケースを場合分けして以下のように考えます。
まず、$cos(\theta x) = 0$のとき、回転行列がどうなっているかを見てましょう。Cxを使っている部分がすべて0となり、Sxの部分が$±1$になります。※ cos(θx) = 0のとき、sin(θx) = ±1 ... $θx$ = 90° or 270°さて、ここで三角関数の加法定理を持ち出すと、これを使って上の行列は以下のように整理することができます。なんともきれいに加法定理の形になってますねｗ
さて、これだけでは加減算された形での値しか求まっていないので、一意に角度を求めることができません。そこで、適当に$\theta y = 0$と置くと、となります。つまり、ですね。問題点として、適当に$\theta y = 0$とおいているため、回転を表すオイラー角としては正しい姿勢になるものの、もともと設定した$y$と$z$の値が復元できないことが分かります。とはいえ、$\theta x = 90° or 270°$という限定された状態のみなので、だいたいの場合は問題にならないでしょう。つまり、$m21 = 1$の場合は$\theta x = \frac{\pi}{2} = 90°$、$m21 = -1$の場合は$\theta x = \frac{-\pi}{2} = 270°$となります。
この状態のときだけ条件分岐してやればいいわけですね。ここまでをまとめると、$sin(\theta x) = ±1$以外のとき、$sin(\theta x) = 1$のとき（$m21 = 1$のとき）、$sin(θx) = -1$のとき（$m21 = -1$のとき）、となります。これを元に、実際にUnity上で実行してみました。
実行したコードは以下になります。これを実行すると無事、同じ回転を設定することができました。
が、実はよーく見てもらうと上で求めた式とは若干違う部分があります。引数に与えている成分のマイナス記号が逆になっているんですね。
そして、なぜここが逆転するのかは分かりませんでした・・。
ただ、マイナスを逆転したら正常に回転がコピーできました。このあたりがもしかしたら逆転している理由かもしれません。
が、値としては想定した値になっていたので、ひとまずはOKとしました・・。
もしなにかご存知の人いたら教えてください(´・ω・`)これについてはコメントで指摘をもらって、以下に追記しました。[追記]
コメントで指摘してもらいましたが、そもそも参考にした記事が、座標変換のための回転行列と、位置ベクトルの回転行列による話で、そもそも対象としているのが違うためでは、ということでした。
「教えて！goo」に似た質問とそれに対する回答があったので追記しておきます。見てもらうと分かりますが、まさに符号だけが逆転しているのが分かります。最初間違えてUnityのつもりで違う順番で行列を計算しちゃったけどメモとして残しておきますｗ


