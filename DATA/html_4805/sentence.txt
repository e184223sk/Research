More than 3 years have passed since last update.わたしのコーディングの師匠かずきさんに、私のクソコードをレビューしてといったらオシャレなコードになって帰ってきたので、その学びを書き留めておきたい。私は Durable Functions というリポジトリに貢献しているのだが、前回実装した全件取得のメソッドに対して、検索条件を追加するメソッドを書きたいと思った。検索条件を表すオブジェクトをつくれば多分テストもしやすくていい感じのはず。最初に作ったクソコードはこんな感じ Builder 的な感じで作ってみた。TDDを使ってやってるのでテストもある。レビューをしてもらおうと思ったのは、もっときれいなコードを書きたいというのもあるし、Query の Condition オブジェクトを ServiceCollection のBuilderをこの前触ったのが頭にあったのか、似たような実装をしてみた。ただ、Builder にしちゃったのはどうなんだろう、もっと単純に Condition のオブジェクトにして、属性も隠蔽しなくてもよかったのでは？という設計的な判断に悩んで、悩んでも答えはでないので、自分の師匠のかずきさんにレビューしてもらうことにした。なぜかずきさんに師匠をお願いしているか？というと、昔一緒に彼とお客さんとモブプログラミングをやったことがあるのだが、彼は何のリファレンスも検索もすることなく、高度で美しいコードを目の前で一瞬で書き上げて、尚且つそのインサイドを高度理解しながらその場で解説しているのを見て衝撃を受けたからです。師匠のコードを書くスピードと完成度は目を見張るばかり。そこで師匠をお願いしてみました。かずきさんにURLをはってしばらくすると、なんとかずきさんは、私が結構時間をかけて書いたコードを一瞬でリファクタリングして送り返してくれた。彼が解説してくれたポイント、私が質問した内容と、回答に関して整理しておくいろいろオシャレな感じになっているがポイントを解説していきたい。かずきさんは、Condition をチョイス。確かにこっちのほうが良さげです。次のようにコメントをいただいたのですがC# はオブジェクトのインスタンス組みたてるだけの Builder 系クラスってあんまり有意義じゃないんですよねぇ
あ、今回の TableQuery のような組み立てるのがめんどくさいクラスを組み立てるための Builder は有意義だと思いますよ
そういうのじゃなければオブジェクト初期化子で行けるので後で気づくのですが、初期化子で行けるほうがこのユースケースではよさげです。私がCreatedTimeFrom, CreatedTimeTo をつかっていると、何気にさっとオブジェクトを作っていてセンスがいいなと思いました。何故作ったかを聞いてみました。因みに牛尾さんの Builder のメソッドがFrom, Toの日付をまとめて受け取るようになってたので、FromとToは必ずセットで設定されるという風に読み取ったので、こういう風にしましたわたしのコードだとそういう風に読み取れるのか、、、実際はFrom だけとか、To だけとかあるんですけど、、、コードがちゃんと表現できていないポイントですね。そのことをかずきさんにいうとその場合だと牛尾さんのコードでも
Builder の AddCreatedTime メソッドもfrom, to を受け取るシグネチャなので
不便そうですねあー、今回のユースケースは、Builder だめだわ。いろんなパターンの、Addxxx メソッド実装しなくてはならなくなるので面倒だわ。絶対初期化子のほうがいい！つまり、今回は Condition 一択で納得しました。私のコードはスパイクなので単なる書きなぐったコードになっていますが、かずきさんのコードをみるとしれっとリポジトリができています。こんなちょっとしたコードでもさっとそれを作るセンスが素敵です使用こういうちょっとしたところでもさくっとこういう整理を手が勝手に動くようにやるのがおしゃれですが、自分もそうなりたいので、彼に何故これを作ったかきいてみました。名前も、わたしのしょぼこーどから、それぽっぽいネーミングをしっかりするところもさすがです。この処理呼びたい人がみんなTableClientとか作るのめんどそうだなと思ったので、何かしらのクラスにラップしたいなって思った感じです別に static なメソッドが1つあるだけでもいいですこういうのを思いつくのもしびれるあこがれるポイントです。私のクソださコードだとこんなのを書いているところもLinq をつかってさらっと直してくれています。Aggregate に相当するのは、Ruby でも関数型言語をやったときもありましたが、Linq での使い方はしりませんでした。やっぱり Linq は一通りマスターしておくほうが良さげです。このメソッドはリファレンスを見るとかなりよくわからないですが、ブログで事例から学ぶほうがよさげ。(a, b) のうち、最初のものが、Aggregate をとおして共有される変数で、bのほうが、各エレメントを表します。こんな単純なサンプルですが、よく見ると、CloudTable のところに Lazy がついています。なぜでしょうか？newで作ってたらインスタンス生成が重そうなので
あと、自分でif文書いて、初回実行だったらCloudTable作るとか書くのがめんどくさかったとかですかねぇ
今回は指定してないですがLazyの第二引数にtrue指定すると、マルチスレッド環境でも、いい感じに動いてくれるようになりますプログラマは怠惰重要。ここも思いつきもしなかったポイントです。最後に.NET のネーミングについて知りたかったので、この名前が標準なのか聞いてみました。BuilderならBuildだけど、そうじゃないならToListやToArrayにならってそうしてますねー
でも、この処理はConditionにいるのは少し疑問を感じながら書いてます
例えばAzure Storageじゃなくてもイケるようにインターフェース切ったのに、引数がそもそもテーブル前提の処理持ってるのはいただけないなーとなので、拡張メソッドにするかRepositryに押し込んでもいいかもしれませんただ、Repositryに押し込むとテストしたかったらpublicにしますが、そうなるとRepositryにはふさわしくない感じになるので、拡張メソッドかなぁ…なるほど、C# で拡張メソッドがでてくるのですが、テスタビリティが良くないので好きじゃないのですが、やっとみんな使う理由がわかってきました。一般的なものがあり、その拡張的なメソッドがあります。今回は StorageTable を使いますが、他の実装にもConditionを対応させたいなと思ったときに、ToTableQuery はStorageTable に依存しすぎです。だからといって、このメソッドを抽象化することもできませんし、あればStorageTable 的にはうれしいのは間違いない、、、、というケースで Extension メソッドを書けばいいのでしょう。実装するとしたらこんな感じでしょうか。こんな小さなプログラムでもイケてる人にレビューをしてもらうとめっちゃくちゃ違うことがよくわかりました。もっと勉強しなくては、、、私は、かき捨てのプログラムを書くときはべたっとやってしまいがちですが、師匠のように普段からそういうセンスでやっていると普段からもっといいコードが書けるのかもしれません。ちなみに、今実際にコントリビュート中ですが、Pull Request はこんな感じにしました。Accept されるかはしらんけどｗ


