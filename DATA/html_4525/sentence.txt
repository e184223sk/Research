More than 1 year has passed since last update.@Zuishinさんより教えていただいた方法だと、ビルドアクションにResourceを設定したファイルに非常にスマートにアクセスできます。@Zuishinさんありがとうございます。さて、ファイルの追加、ビルドアクションの設定の仕方は僕の書いたほうを読んでいただくとして、スマートな方法は以下のとおりです。波括弧を除けば3行でファイルの中身を取得できます。スマートです。頑張って説明してみます。Application.GetResourceStream()メソッドでファイルへのストリームを取得、と思いきやこのメソッドの返り値はStreamResourceInfoです。が、この返り値がファイルへのStreamを持っていますので、それを使ってStreamReaderでファイルの中身を取得します。さて、GetResourceStream()メソッドですが、引数に目的のファイルの位置をUriで受け取ります。Uriの部分は、下のようにソリューションエクスプローラにおいて、プロジェクトフォルダを起点としたパス文字列を構成し、UriKind.Relativeで「相対パスですよ」と指定します。後は前述のとおりStreamReaderを使ってファイルの中身を取得します。素晴らしくお手軽ですね。
以上です。
この方法を追加したプロジェクトはこちらVisual Studioでアプリケーションのプロジェクトにフォルダやファイルを追加できますが、プログラム中からそれらのファイルにどうやってアクセスするか、の第2弾です。
ファイルのプロパティでビルドアクションを設定できるのですが、埋め込みリソースやResource、コンテンツと設定することでプログラムからそれらのファイルにアクセスすることができます。
以前に埋め込みリソースなファイルへのアクセスの仕方について説明しましたが、今回はResourceなファイルへのアクセスの仕方について説明します。TextFilesフォルダを追加して、その中にTextFile1.txtを追加します。TextFile1.txtに何か適当なものを書き込んでおきます。ソリューションエクスプローラ上でTextFile1.txtのプロパティを開いて、ビルドアクションをResourceに設定します。

通常、ファイルを追加した場合はデフォルトでResourceになっています。ビルドアクションにResourceを設定したファイルはコンパイルされてアプリケーション名.g.resourcesというファイルにバイナリデータとして書き込まれます。
このファイルはビルドすると作成されるので、まずは一度ビルドしてみましょう。
ビルドが正常終了したら以下のフォルダ内に先ほどのアプリケーション名.g.resourcesファイルができていることが確認できます。

ソリューションフォルダ\プロジェクトフォルダ\obj\Debug

この中にResourceに指定したテキストファイルがバイナリデータで入っているはずです。何はともあれ、ファイルがあればそこへのストリームを開きます。
このプロジェクトに含まれるファイルへアクセスする場合、まずはアセンブリ（今書いているプロジェクトがコンパイルされて出来上がるexeやdllのこと）へアクセスる手段を取得します。GetExecutingAssembly()わかりやすいメソッド名ですね。実行中のアセンブリを取得しろ、と。そして、アプリケーション名.g.resourcesへのストリームを開きます。ここまででアプリケーション名.g.resourcesファイルへアクセスできるようになりました。
では、このファイルの中に入っているだろうテキストファイルへはどのようにアクセスしたらよいのでしょうか。
ここで使用するのがSystem.Resources.ResourceReaderクラスです。
このクラスを使用してアプリケーション名.g.resourcesファイル内のリソースへアクセスするためのストリームを開きます。この変数rrがアプリケーション名.g.resourcesファイル内のリソースファイルへアクセスするための手段となるわけです。
このResourceReaderというクラス、名前からしてさぞResourceなファイルへのアクセスを楽にしてくれそうですね。インテリセンスによると、やはりそのものずばりといったメソッドがあります。GetResourceData()。
もうゴールは目の前な気がします。
GetResourceData()を使う場合、以下のようになります。
resourceNameにはフォルダ名とファイル名を全部小文字にしてリソースへのパスを作って入れておきます。
ここで気を付けることはもう一つあって、フォルダ名とファイル名を「.」でつなぐのではなく「/」でつなぐということ。GetResourceData()に必要な引数を渡して呼び出すと、resourceDataの中に指定したファイルの中身がbyte配列で入ります。
今回はテキストファイルなのでそれを文字列に変換すると以下のような値が取得できます。
あれ？
ファイルの中身は取得できているようですが、なんだか様子がおかしいです。
取得した文字列の先頭にJ\0\0\0がついています。
これが何なのかはわかりませんが、ほしいのはこの4バイト分を除いた文字列なので、その場合は以下のようにして先頭4バイトを除いたデータを文字列に変換するとよいかもしれません。おあつらえ向きと思ったGetSourceData()ですが、それほど使いやすくはないように感じました。rrはResourceReaderのインスタンスですが、これをforeachで回すと、DictionaryEntryクラスのデータを順に取得することができます。
このDictionaryEntryクラスのデータがキー/バリューのペアになっているので、Keyプロパティが目的のファイルと同じパス文字列かをチェックし、そうであればValueプロパティがStreamクラスのデータなので、StreamReaderと合わせてReadToEnd()で中身のテキストを取得できます。全然お手軽ではないですね。ビルドアクションに埋め込みリソースを指定して、ここの手順でファイルを扱ったほうが楽な気がしました。なんだか思ってたんと違う感じになってしまいましたが、ビルドアクションにResourceを設定したファイルへのアクセス方法の一つはわかりました。
しかし、これだけ面倒ということは、まず間違いなく僕のアプローチが間違っているはずです。
正しい方法があれば、それを書きたいと思います。今回使ったプロジェクトはこちら


