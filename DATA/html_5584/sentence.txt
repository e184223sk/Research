More than 3 years have passed since last update.C#でSQLite3を使ってみたのでまとめ。DBが1つのファイルで完結するって何かと便利ですよね。このへんの記事が参考になりました。ここが問題。NuGetで「SQLite」で検索すると、

まずどれを使っていいかわかりません。大抵「System.Data.SQLite」をインストールするのですが、これはEntity Frameworkや、SQLiteのLINQ拡張（これを入れなくてもLINQ to SQLが使える謎）など全部入った欲張りセットで、気づけば実行ファイルのディレクトリが大変なことになります。

SQLiteちょっと使いたいたいだけなのにライブラリ5MBは全然"Lite"ではないので、「System.Data.SQLite.Core」のみをインストールします（フルセットの場合はCoreも自動的にインストールされます）。SQLクエリを直に書いていくような場合はCoreだけで十分かと思います。ライブラリもかなりすっきりします。
注意：C#にはLINQを用いてSQLを実行するLINQ to SQLという機能（System.Data.LinqやSystem.Data.Linq.Mapping）があるのですが、SQLiteでTEXT型で定義したカラムに対して、LINQ経由のクエリで文字列をWHEREで比較するとNotSupportedExceptionが飛ぶという、ちょっといただけない現象があります。VisualStudio Community 2017、.NET4.6、System.Data.SQLite 1.0.106.0で確認済み。
カラム定義をNVARCHARに変えると発生しないとのこと（詳細は下記記事参照）ですが、そもそもSQLiteのデータ型にNVARCHARはなくて文字列はTEXTになるし、他言語においてTEXT型で作ったSQLiteを読ませることを考えると、ちょっとどうなの？とは思います。このTEXT型のカラムに対する例外は、LINQ経由ではなく、SQLクエリを直接書いて実行し、WHERE比較すると発生しませんでした（それはそう）。なので、入力補完が効かないデメリットはあるものの、SQLクエリを直接書くメリットはあります。参考：System.Data.Linq.dll で NotSupportedException（解決） : http://shinta0806be.ldblog.jp/archives/9084461.htmlSystem.Data.SQLiteで使われているSQLiteのバージョンを確認します。実行結果は（System.Data.SQLite.Coreのバージョンは1.0.106）無事、SQLite3の最新版でした。DataSourceの項目を「:memory:」にするとメモリ上に、「test.db」などにするとファイル上にデータベースを作成します。SQLクエリをゴリゴリ書いていく場合はこうなります。文字列の結合が面倒なので独自の拡張メソッドを用意します。値がnullの場合はオーバーロード用意しないとちょっと面倒かもしれません。nullの場合、闇雲に'{変数名}'とやってしまうと、空文字（''）が代入されてしまいnullにはなりません。実行結果は次のようになります。SQLiteのGUI管理ツールとして「DB Browser for SQLite」があります。上記のテーブルのDataSourceをdenco.dbとしてファイルに保存し、このソフトで見てみます。
SQLクエリを直接書く場合は、REAL型のカラムで指数表記が大丈夫かな？と気になって試してみました。別にテーブルを作ります。これはエラー起きませんでした。指数表記と非指数表記が混在しても大小比較できています。DB Browser for SQLiteで見てみると、

指数表記のまま格納されています。なぜなら、SQLiteの公式ドキュメントのDataTypeを見ると、REAL. The value is a floating point value, stored as an 8-byte IEEE floating point number.とあり、IEEEの規格自体に指数表記が含まれるからです。当たり前といったら当たり前ですね。ただし、調子に乗ってInfinityやNaNを格納しようとしたらエラーになりました。±Inf,NaNに対するdouble.ToString()がよろしくなく、クエリ内で計算させるようにしたら格納できました。ちゃんと大小比較できます。SQLクエリ内で±Infを作り出すには、指数表記の桁を8バイト浮動小数点数の範囲外の値にしてしまえばいいので。NaNを手っ取り早く作るには.NETだと0で割るのですが、SQLite3で同様の計算をするとNaNではなくNULLで格納されるようです。したがって、NaNを許容するようなカラムを作りたい場合は、NOT NULL制約を外す必要があります。実行結果は次の通り。追記：プリペアドステートメントを使うとそこまで特殊な値に苦労しません。3.の例をLINQ to SQLを使って.NETっぽく書き直してみます。自分の環境では、NuGetパッケージは相変わらずSystem.Data.SQLite.Coreのみで十分で、プロジェクトの「参照の追加」からSystem.Data.Linqのアセンブリを追加します。usingはSystem.Data.SQLiteの他に、System.Data.LinqとSystem.Data.Linq.Mappingが必要です。（System.Data.SQLite.Linqの必要性とは一体）しかしこれには罠があって、1.で前述の通り、SQLiteのTEXT型のカラムに対してLINQ to SQLで=比較すると「NotSupportedException」の例外が発生します。string.Compareやstring.Equalsを使っても不可能。StartsWithやEndsWithは通ります。なので、StartsWithとEndsWithのあわせ技で擬似的に（怪しい）Equalsを作るということはできますが、余計な判定をやっているので多分遅いです。さらに「aaaHOGEaaa」のように前後で回文になっている場合、aaaと等しいと誤検出されますので、おすすめしません（インデックスである程度絞ったのちToArray等で一旦SQLから分離し、そこで文字列比較をするのが無難かも？）。また、3.でやったように、SQLクエリを直接入力するのはもちろんOKです。結果は次のようになります。テーブルをファイルに保存し、DB Browser for SQLiteで見てみると、

SkillがNULLのところはちゃんとNULLで記録されています。データのInsertでは変に意識しなくて良くていいかもしれませんね。4.の例でもやってみます。AUTOINCREMENTがAUTOではないじゃないか！？と突っ込まれそうですが、そうです。Idを省略して実行しようとしたらエラーになって投げました。Idを直に指定したら特にエラーもなく実行されました。NaNは相変わらずNULLに変換されます（なのでNOT NULL制約はダメです）。±∞やNaNのような特別な値に対して、事前に手動で処理を施さなくてよいのがメリットですが、相変わらずAUTOINCREMENTができないのが釈然としない…。実行結果とファイルへの書き出しは次のようになります。以上、LINQ to SQLになります。個人的にはSQLiteで使うとなると相当癖のある機能だなと思いました。実直にSQLクエリを書いたほうがいいかはちゃんと見極めたほうがよさそうです。SQLiteで大量にデータを扱うときは、トランザクションを使ったほうが高速になることが一般的に多いです。ロールバックの機能もあるのですが、わかりやすい速度面から見てみます。ただし、速度について考える場合、トランザクション以外の要素も切り離して考えなければなりません。ざっと4点、つまり条件は2^4=16です。3点目については、LINQ to SQLの場合は1個ずつInsertするInsertOnSubmitか、複数InsertするInsertAllOnSubmitか、SQLクエリの場合は1行のINSERT文で1行追加するか、複数の行を追加するかでそれぞれ直交できます。それぞれ、みんな大好き（？）ぐるぐるループで勝負します。HDDかメモリかの部分は省略しているけど別にいいよね。IDを変えて6000レコード追加します。ケースAメモリに書き出すときはほぼ変わらないが、HDDの場合はトランザクション使わないと明らかに遅い。ケースBケースAのとほぼ変わらない。InsertOnSubmitだろうがInsertAllOnSubmitだろうが、要はSubmitChanges()の段階で反映されているから差がないという間抜けな結果に。次は、直にSQLクエリを実行させた場合の結果です。ほとんど変わり映えしないソースですが、LINQ to SQLは一切使っていません。ケースC突っ込み満載の結果になりました。まず、HDD－トランザクションなしの結果に注目。堂々の10分半です。こんなウンコード絶対書いちゃいけません。
メモリに書き出した場合は、トランザクションの有無にかかわらず似たような結果になっていて（これはSQLクエリ、LINQ to SQL関わらずそう）、LINQ to SQLの場合は22秒もかかっていましたが、直接クエリを書いた場合は0.09秒になりました。メモリに書き出したときの時間は、いくらいいSSD使おうが下回ることができない（転送速度が2桁ぐらい違う）ので、IOの軸で見た場合の極小値になります。この極小値が、LINQ to SQLを切り捨てたことで22秒から0.09秒、すなわち1/250になったわけです。本当LINQ to SQLの存在意義とは何なんでしょう？実はさらに速くなります。6行まとめてINSERTします。SQLite3.7.11以降この「INSERT INTO table(column) VALUES (row1),(row2),(row3)」のように、わかりやすく複数行INSERTできるようになりました。1.で調べた通り、現在、NuGet経由で最新版のSystem.Data.SQLite.Coreをインストールすると、SQLite3.21.0が落ちてくるのでこの表記は使うことができます。もうやめて！LINQ to SQLのライフはゼロよ！という感はありますが、
ケースDメモリの場合は、複数行（6行）INSERTすることで、0.09秒から0.06秒と約2/3になりました。LINQ to SQLを使ってINSERTした例と比べると約1/360です。HDDでうっかりbegin～commitを忘れちゃったとしても、1分半とケースA,Bのトランザクションなしの場合の2分オーバーより、30秒短くて済みます。現実的には、HDDに書き出すことが多いので、ケースA,Bのトランザクションあり、HDDのケースと比較しますと、22.5秒対0.23秒でざっと1/100を達成できました。LINQ to SQLの存在意義とは一体……。
一応、LINQ to SQLの名誉のために補足しておきますが、今まで比較したのはINSERTのパフォーマンスのみです。置き換えや検索のパフォーマンス、LINQとのつなげやすさ等は全く考慮していません。なので、ここまで多くINSERTしない場合や普段使いでは、まだまだLINQ to SQLの出番はあると思いますよ。自分は使う気失せましたが。かなり脱線してしまいましたが、ここまでの結果をまとめます。トランザクションを明示的に管理する大きなメリットとして、データ挿入/変更時にエラーが発生した場合、ロールバック（巻き戻し）ができるようになります。具体例を見てみます。UPDATEを2回かけ、それぞれのトランザクションに対してエラー時にロールバックするようにさせています。1回目のUPDATEは、新居浜ありすのmaxapを270から280に変えるもので、データベース上これは何も問題ありません。2回目のUPDATEは、新居浜いずなのattributeをnullに変えるものですが、テーブル定義からattributeカラムは「NOT NULL制約」があるので、これは失敗します。したがってロールバックが発動し、1回目のUPDATE完了時のデータに戻ります。最後に"SELECT * FROM denco"で参照しているのは、ロールバック後のデータです。実行結果は次のようになります。ここからは他言語間との連携を見てみます。その例として、SQLiteと親和性の高いPHP（SQLiteが付属でついてくる）との連携を考えます。主に共用サーバーなど、PHPは使えるものの、MySQLが使えなかったり数に制限があったりする場合にSQLiteは重宝することが多いです。例はこれまでさんざん出したdencoのテーブルを使います。C#側で「denco.db」として保存しておきます（何度も出ているのでソースは省略）。これをPHPのプログラム（index.phpとします）と同一のディレクトリに置きます。PHPの実行環境はPHP7.2.1、WindowsのXAMPPで起動し、ブラウザからPHPファイルを読み込ませています。この実行結果は以下の通り。特に問題なく読み込めています。今度は7.の逆です。PHPでDBファイルを作ってから、C#に読み込ませます。同種のDBをPHPで作ると次のようになります。ファイル名は"denco_php.db"として保存します。ダンプ結果は以下の通り。
INSERT時のNULLの扱い方がC#より全然楽そうですね。ここでは扱いませんでしたが、PHPのSQLiteでももちろんトランザクション管理はできます。
これをC#のプログラムのあるディレクトリにコピーして読み込ませます。読み込むだけじゃつまらないので、MaxAp降順でソートしてみましょうか。DumpQuery()は以前定義した拡張メソッドです。ダンプしたときに5行目と6行目の間に謎のスペースが入っていますが、DB上は特に問題ないようです。無事読み込むことができました。これで、C#←→PHPのSQLiteを通じた（擬似的な）相互のデータなやり取りができるようになったので、例えばPHPプログラム＝サーバー、C#プログラムをクライアントとして、データのやり取りをSQLiteファイルで行うということもできるようになります。実は似たようなことを考えている方が既にいました。参考：アプリとサーバーの通信にJSONではなくSQLiteを使うと幸せになれるかも知れない条件まとめ　http://animane.hatenablog.com/entry/2015/10/12/152533今回はこれで終わりにしますが、C#でSQLiteを使う、もといSQLiteの日本語情報がまだまだ少ないので、もっとSQLite使う人増えたらいいかなと思います。大変長い投稿になってしまいましたが、ここまで読んでいただきありがとうございました。8.のPHPプログラムでSQLite3::prepare(…)と使ったの、プリペアドステートメント（PreparedStatement）という機能です。調べたらC#のSystem.Data.SQLiteでも使えました。これを使うとnullやInfなど特殊な値について苦労することが減りそうです。例を示します。Parametersを追加のたびにClearすることに気をつけていれば特に難しいことはなさそうです。以下のdecimal2.dbが出来ます。

特に事前処理を施すことなく、nullや±∞, NaNの値もそのままInsertすることができました（相変わらずNaNはnullに置き換えられます）。パフォーマンスはどうでしょうか？6.1で比較した複数行の例（ケースD）と比較します。ケースDのコードとほとんど変わらないので、コードは一部のみで。トランザクションはどうせ切ったところでHDDで激遅になるのがわかりきっているので、使う（独自に管理する）ものとします。ケースDのInsertAllをInsertAllWithPreparedに変えただけです。このInsertAllWithPreparedは独自に定義した拡張メソッドで、これをHDD、メモリの両方で試し、ケースD（プリペアドステートメント無）の場合と処理速度を比較します。以下のプリペアドステートメント無しの値はケースDの再掲です。メモリに書き出した場合のみ、処理時間がおよそ倍になっています。プリペアドステートメントの内部実装までは知らないのですが、素人目的に見てライブラリ側のParametersコレクションに追加したり、プリペアドステートメントの文字列結合で遅くなっているのかなと想像。HDDに書き出した場合ではほぼ誤差レベルなので、この程度ならIOの転送速度の差で吸収できるレベルだと思います（追加するレコードの件数によりけりですが）。プリペアドステートメントを使うと、nullや∞など特殊な値について事前処理を施さなくてよいメリットを考えると、これはかなりアリなのではないでしょうか。全く同じ目的でLINQ to SQLを使うよりかははるかに速いです。


