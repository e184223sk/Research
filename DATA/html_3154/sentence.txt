More than 1 year has passed since last update.「【C#】List&lt;T&gt;を任意の値・要素数で初期化する」という記事に対してコメントしていた内容を記事として起こしました。  半分お遊びみたいな内容なので、気楽に読んでいただければと思います。元記事としては、「capacity を指定して List&lt;T&gt; を new したときに、インデクサでその capacity 分の範囲を自由にアクセスしたい」という要件がありました。  基本的には、「capacity = 内部バッファのサイズ」であり、インデクサでアクセスする場合には capacity ではなく Countプロパティ をもとにアクセス可能かのバリデーションをします。  つまり、Countプロパティ さえ書き換えてしまえば、要件をクリアできると考えました。ただ、ここで一つ問題があります。Countプロパティ は readonly なわけです（当然といえば当然なのですが...）。こういうときは、だいたいリフレクションを使えば何とかなります。今回も例に洩れずどうにかなるパターンだったので、リフレクションを利用していきます。List&lt;T&gt; は _items という内部バッファ領域(= 配列)と、 _size という要素数フィールドを持っています。List&lt;T&gt; は capacity を指定して new すると、capacity分の長さをもつ配列を生成し _items を初期化します。その際、_size は要素を追加されていないため 0 のままとなります。つまり、今回は _size フィールドをリフレクションで強制的に書き換えてしまえば、インデクサで各要素に対してアクセスすることが可能になるわけですね。この GenerateList&lt;T&gt; を使えば、以下のようにインデクサを使ってまだ追加していない要素番号に対してもアクセスすることができるようになります。元記事では「任意の値で初期化したい」という要件もあったため、これも実現してみます。これはお遊びの領域ですが、並列化すればもっと高速にできます。また、Func&lt;int, T&gt; を受け取るようにすることで、各インデックスに対して任意の値で初期化することが可能になります。今回のコードを配列の拡張メソッド化することで、もう少し便利になります。ただ ToList&lt;T&gt; という名前は使われている上に挙動が違うため、今回は AsList&lt;T&gt; という名前で作っていきます。上記のようなコードを用意してあげることで、高速に配列を List&lt;T&gt; に変換することが可能となります。  では実際にはどの程度の高速化となっているのでしょうか？元記事で利用されているコードを拝借して速度比較をしてみたいと思います。「圧倒的ではないか、我が軍は！」という結果となりました。Func&lt;int, T&gt; 版は遅くなることが想定されていたので、許容範囲です。注目すべきは、A() と AsList001() の箇所です。
同じ処理内容で圧倒的な速度差を見せつけてくれています。そして、AsListParallel版 を見てみると、並列処理の威力を垣間見ることができます。
たかだか List&lt;T&gt; の初期化のためだけに並列処理を利用するというスーパーリッチなことが許容されるならば、（要素数が多い場合に）多大な恩恵を受けることができるでしょう。今回はお遊び半分でコードを考えてみましたが、実用の許容範囲のものができたと思います。そして、やはりリフレクション機能は強力ですね。使い方を間違わなければ素晴らしい武器となると思います。他にも高速化の手立てはいくらでもあると思いますので、何か考え付いた方がいらっしゃいましたらご教示をお願いいたします。


