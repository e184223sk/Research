C#の超入門本を読み、オブジェクト指向で出てくる用語がいくつかあったため、内容を整理しアウトプットするためにこの記事を書きました。
そのことから、オブジェクト指向の概要（クラス・インスタンス・カプセル化・継承・ポリモーフィズムなどの）説明は省きます。メンバ変数・・・クラス内で宣言した変数のことメンバメソッド・・・クラス内で定義したメソッドのことコンストラクタは、インスタンス生成時にnewの後ろに記述するあれです。コンストラクタは、インスタンス生成と同時にメンバ変数の初期値を代入してくれる仕組みです。
クラスには、以下のようにコンストラクタを書くことができます。
例えば、Personクラスがあったとして・・・コンストラクタは必ずしもクラスに書かなければならないわけではなく、書かなくてもOK。
その場合、コンパイラさんがインスタンス生成時に
「引数も初期値もないデフォルトコンストラクタを作ればいいのね」
と、自動で判断してくれるのです。（ありがたいですよね。）そして、何も書かれていないコンストラクタをデフォルトコンストラクタと呼びます。
もちろん引数ありバージョンで書くなら、インスタンス生成時に引数を渡してあげればOKです。アクセス修飾子は以下３種類。
どれをクラスで使用するかによって、インスタンス生成後にどこからアクセスできるかが決まってきます。
また、これらを使い分けることで、メンバ変数に意図しない値が入れられないようにしたり、使ってほしい機能だけを使ってもらえるようにコントロールしています。そのまんまの意味ですが、すべてのクラスからアクセスできる。自分のクラス、もしくは派生したクラスだけアクセスできる。
英語の意味は、保護されるや守られるという意味があるので、
身内以外からアクセスできないように保護しているんだなと私は覚えるようにしました。こちらもそのまんまの意味ですが、自分のクラス内でしかアクセスできません。
ほかのクラスは一切アクセスできないプライベートな場所書き方は、以下のようになります。アクセス修飾子をprivateにして、変数宣言されたメンバ変数にはほかのクラスから一切アクセスできないようになりました。
これはアクセスできないようにしたかったので問題ないのですが、正しい値を代入したい場合もアクセスできなくなってしまうようです。そこで、メンバ変数へアクセスできるようにするためのメソッドを用意することになるのですが、これをアクセサと呼びます。上記のようにメソッドを通じてメンバ変数にアクセスすることができます。アクセサを作る仕組みのことです。
privateで書かれているメンバ変数は直接的にアクセスできないため、メンバ変数へアクセスしようとするとどうしてもコードが冗長になってしまいます。
冗長になることを防ぐ機能としてプロパティがあるようです。書き方は、以下のようになります。プロパティ名は先頭大文字で書きます。引数の数と型が違っていれば、同じ名前のメソッドを複数定義することができます。
このことをメソッドのオーバーロードと呼びます。
また、コンストラクタもオーバーロードすることができます。以下に例となるコードを記述します。引数なしでインスタンスが生成されたときは、引数なしのコンストラクタが実行されます。
引数ありでインスタンスが生成されたときは、引数ありのコンストラクタが実行されます。基本クラスから継承したメソッドを派生クラスで定義し直すことができるのが、メソッドオーバーライドです。オーバーライドするときはvirtual修飾子を基本クラス側で使う必要があります。
また、override修飾子が派生クラス側では必要となります。派生させることを前提とした中身がないメソッドを定義することもでき、実装する際はabstractキーワードを付ける。【C#の基礎】override修飾子でオーバーライドをする方法
書籍：確かな力が身につく C# 超入門
こちらの書籍結構わかりやすかったので、おすすめです！


