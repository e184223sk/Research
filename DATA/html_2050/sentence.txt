More than 1 year has passed since last update.8bitで表現される任意の値が設定されたバイト列を、安全に通信するためにテキストで表現できる形式に変換すること。8bitのバイト列を6bitずつ取り出し、[a-zA-Z0-9+/] に割り当て直す。 つまり、24 bit = 8 bit * 3 のバイト列は 24 bit = 6 bit * 4 のバイト列に変換される3バイトに満たない列には'='を埋める割り当て直す [a-zA-Z0-9+/] のうち、[a-zA-Z0-9] はどういう環境でも安全に扱えるが、のこりの [+/] については環境によってはそのまま使えず別途エンコードする必要がある。たとえば '/' はパス区切りには使えず、URL表現だと問題が発生するし、'+' も同様にURL表現で問題が発生する可能性がある。ゆえに[+/]を別の安全に使えそうな文字に置き換えるとかする必要がある(典型的にはURLEncodeによって数値参照形式にするなど)似たロジックはSMF(Standard MiIDI Format)における8bitの列から7bitずつを取り出す方法だが、SMFだとC#のバイト列とはエンディアンが逆なのでそのままは使えない。参考: https://qiita.com/ringorou/items/5e2384f7cf226d9e648a変換対象のバイト列の長さは不定だが、8bit から 6bit ずつ取り出せばよいので 24bit のみ考えればよい。1．第1バイトを2ビット右シフトした値と 0b111111 の積 a を格納
2. 第1バイトを4ビット左シフトした値と 0b111111 の積 b を格納
3. 第2バイトを4ビット右シフトした値とbの和を 0b111111 の積をとった値 c を格納
4. 第2バイトを2ビット左シフトした値と 0b111111 の積を d を格納
5. 第3バイトを6ビット右シフトした値とdの和を 0b111111 の積をとった値 e を格納
6. 第3バイトと 0b111111の積 f を格納
7. 格納した値 a, c, e, f の列を変換表を使って変換する
8. 余った位置には'=' を追加する以下はそれぞれ Convert.ToBase64String, それの'+/'をReplaceで変換するもの、この記事のロジックでのベンチマーク結果。


