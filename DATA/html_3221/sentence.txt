More than 1 year has passed since last update.数千とか数万とかの比較的小さなファイルをネットワーク越しにコピーするのには思いの外時間がかかります。うそー、そんなにかかるのー、ぐらい。なんとか出来ないものかと思い、高速化をいろいろ試してみました。
nkojimaさんに意見いただきまして、Zipファイル圧縮を使った場合も追加しました。この記事はC#で書いてます。Windows7です。VisualStudio 2017を使っています。
プログラムの速度評価には1個あたり4kB未満のファイル13,000個のセットを使っています。
ローカルからリモートフォルダへのコピーを想定しています。srcPathで指定したディレクトリ以下の全ファイルをdstPathにコピーします。サブフォルダは作りません。
結果は141秒。遅い。これが問題。高速化といえばまず思いつくのは並列処理です。複数のスレッドを使って並列処理でコピーしてみます。
プログラムではforeachをParallel.ForEachに変えるだけです。スレッドの数などシステム側で最適に決めてくれるはず。C#のこういうお手軽さがいいですね。結果、30秒でした。普通コピーの約5倍。多数のファイルを転送するため時間がかかるのだったら、1個のファイルにまとめてしまおう、ということで試してみました。
ただし、連結してしまうと本来のファイルの切れ目がわからなくなるので、ファイルの名前と位置を示す目次ファイルが別途に必要になります。準備としてファイル名とバイトデータを組で記録するクラスを定義します。これを使って目次を作ります。次に連結してコピーする関数本体です。コピー対象ファイル全部をメモリに読み込んで、コピー先フォルダに全部を連結して書き出します。
連結したファイルを書き出す際にファイル名とファイル容量を目次ファイルに書き出します。
連結したファイルはコピー先で分解してもとに戻さないといけませんが、今回はコピーできたところで終わりにします。結果は30秒でした。
内訳は、読み込みに30秒、転送に0.4秒。
コピー自体は圧倒的に速いですが、読み込みに時間がかかっています。読み込みが遅いのならば、並列処理で読み込みめばどうなるか、試してみました。
先ほどの並列処理を使ったコピーと同様に読み込むところでParallel.ForEachを使うだけです・・・と思ったのでしたが、そううまく行きませんでした。単純にforeachをParallel.ForEachに置き換えたコードは動作しません。Parallel.ForEach の中に indexList.Add( indexItem ); が書かれており、マルチスレッドでList&lt;Index&gt;へのList要素のAddが行われています。Listコレクションはマルチスレッドに対応していないため、ここで動作不良が起こってしまいます。マルチスレッドで使えるコレクション、つまりスレッドセーフなコレクションとしてConcurrentBagがあります。これを使えばParallelの中でも動作不具合は起こりません。Listと同様にAddしてforeachでアクセスできます。ただし、どうも要素の順序が定まっていないみたいです。Microsoft Docsを見ると"unordered collection of objects"：順序付けられていないオブジェクトのコレクション、とあります。
今回は目次ファイルを作るので、順不同でも特に問題はありません。結果は12秒。
内訳は読み込み11.5秒、目次ファイルを含めたコピーが0.5秒。Zipを使ってファイルを１個にまとめて転送してみました。Zipを使うと目次ファイルがいらなくなるし、ファイルの結合・分解を自前でやる必要がありません。
圧縮する・しないでファイル容量に大きな差がなかったので圧縮はしません。なんと１行で書けます。
実行時間は55秒。速度向上の効果が大きかった「ファイルを読み込むときに並列処理・・・」とZip転送を組み合わせてみます。ファイルを並列処理で読み込んでから、メモリ上でZip圧縮書庫作成を行い転送します。
ziplib（SharpZipLib）を使っています。実行時間は28秒でした。私の思いつく方法はこんなところです。頑張って10倍強達成です。
並列処理で単純結合が一番速いですが、目次ファイル必要、分割処理必要と手間がかかります。Zipは幾分遅いですが手間が省けて実用的かなとも思います。
数値はネットワーク環境によってかなり左右されると思います。あくまで気がするレベルなのですが、IEnumerableで速くなるみたいな気がするので試してみました。しかし、IEnumerableは、Parallelとは相性がよろしくないようです。ラムダ式の内部からyield returnは使えません、とコンパイラに怒られました。残念。仕方ないので並列処理を使わない「3. 転送するファイルを連結してコピーしてみる」でIEnumerableを使ってみるとどうなるか試してみました。
IEnumerableを使うと、コピーするファイルのデータを保存するListが不要になります。読み込んだデータをすぐに書き込みに行くような処理になります。結果、30秒。変わりませんでした。ちゃんちゃん。


