前回のMessagePipe入門では、初投稿にも関わらず反響をいただけたので、味をしめた私は、続編を書くことを決定しました。
MessagePipeは布教したいですし、こうなったら主要な機能は一通り解説しておきたいですね。
今回は、前回残したEventFactoryと、RequestHandler機能を主にご紹介したいと思います。その名の通り、（MessagePipeによる）eventを作るものです。
通常のPub/Subでは、DIにより、型でワイヤリングされていますが、EventFactoryからイベントの個別のインスタンスを作り出すことが出来ます。使い方は様々だと思いますが、このような状況であっても、MessagePipeに統一することが可能であるということを覚えておけば良いのではないかな～と思っています。これは、Mediatorパターンの実装に有効な機能なようです。実は筆者、デザインパターンに明るくなく、Mediatorパターンについては知識が浅かったりします。また、GoFデザパタに関しては、実際に必要となる状況に当たり、実装を通して理解した概念に後から名前を付け、他のエンジニアとの会話を楽にするものだと思うぐらいがちょうど良いと思っていますので、Mediatorの説明は他の方におまかせしたいと思います。とは言え、用途は検討がつきます。
またですが、メッセージアプリを作りたいとしましょう。まず、MessagePipeにおけるRequest/Responce機能の実装とは、以下のようにIRequestHandler&lt;TMessage,TResponse&gt;を実装することです。次に、MessageをAPIから送るコントローラーが有るとしましょう。
（※妄想フレームワークです）この例はSendMessageがコールされたときに、送られたメッセージをハンドリングしてレスポンスを返すというケースで、MessageHandlerがあることにより、API側はそれを呼んで返すだけ、となっています。メッセージのやり取りを経由するシンプルなサーバーであっても、ユーザー情報や、グループの情報など、多くの依存やビジネスロジックが絡んでくるかと思います。それらを隠蔽しつつ、「リクエストからレスポンス」と単純なインターフェースへ統一出来ることには価値があるのでは思います。なるほど、これがMediatorパターンか（多分違う）非同期版のAsyncについてはPub/Subの場合とほとんど同じ流れでいけます。名前にAsyncが付き、Requestの戻り値はValueTask&lt;TResponse&gt;になります。ですが、RequestAllHandlerというものがあり、これについては言及しておいた方が良さそうです。複数のハンドラを実行したい場合、I(Async)?RequestAllHandlerとしてインスタンスを受け取ることで、DIに登録されているすべてのハンドラを実行することが出来ます。インターフェースは以下のようになっています。IRequestHandler自体の実装は変わりませんが、複数のインスタンスが必要なので、以下のようなハンドラもあったとしましょう。例の用途はともかくとして、このようなケースはあるはずでしょう。
これらを、使用側で、IRequestAllHandlerとして受けます。呼び出し箇所で、InvokeAllまたは、InvokeAllLazyを呼び出すことが出来ます。Lazyの方はその名の通り遅延実行でforeachで回すまで実行されません｡ちなみにAsyncの方だと、レアキャラの（？）AsyncEnumerableを使うことが出来ます！同じインターフェースの実装を複数DIに登録するパターンに慣れない方もいるかも知れません（私がそうでした）
複数を登録した場合にどうなるのか、気になって調べてみたところ（これはDIの実装に依るのですが）私の知る限りではMSのDIとVContainerは最後に登録されたものが渡されるようです。結果は未定義では無いということですね。RequestAllHandlerに関しては、実行順序はおそらく関知するところでは無いのでしょう。Pub/Subと同様、RequestHandlerにもFilterを挟むことが出来ます｡
文字列のリクエストをすべて反転させてしまうはた迷惑なフィルターなら以下のように作れるでしょう。Async版。ValueTaskとCancellationTokenが加わる。RequestHandlerのFilterは、アトリビュートが基本となります。Asyncの場合は、
[AsyncRequestHandler]をつかいます。今回はここまでです。
MessagePipeの主要な機能として、他にもRedisを使ったPub/Subなどが出来ます！
続編は書く、鴨！です。鴨。 ここまで読んでいただきありがとうございました。


