　AutoMapperとタイトルにあるので、ASP.NET MVCのことを最後に書きますが、
　途中までは、他のC#の開発言語でも対応可能です。
　意識すると、プロパティの設定漏れなどを防げると思います。　外部のファイル、セッションなどを使うとき、getter, setterを次のように何か具体的な処理を入れて書くことがある。
　（割と誇張して書いてます）　このコードはプロパティの本来のgetter, setterの意味合いを崩しているので、実は良くないコード。
　というのは、例えばSomeObjectのクラスにAddTextというメソッドがあったとしてと書かれると、MainClassにはAddTextの結果が反映されないし、C:\Config.txtにも結果は反映されない。これを避けるには、という風に、再度代入する必要があるのだが、これは認識違いによるバグが起きやすいコードである。・・・とまあ、ファイル処理一つくらいならば、これを回避する処理は何とでもなると思いますが、あるとき「データベースから参照したオブジェクトをgetter/setterでいじりたい」とか、「自分の持っているオブジェクトをList型で渡したい、setterも欲しい」とか、明確にgetter, setterが使えそうだけど内部参照で実装できないケースというのが出てきます。そういうコードを作ると、不具合が起きやすいんですね。このコードの最大の問題点はですね一見、４行目が問題に見えるんですが、２行目が最大の問題です。SomeObjectはプロパティとして「オブジェクト」として渡されるがために、オブジェクト内部の操作が許されるかのような表記をしてしまっているのです。だから、３行目でAddTextを入れたら、参照を通じて文字列を足してくれるはずだ、という考えになりがちなのです。ちなみに、これはC++とかだと、関数にconstを適切に指定する、部分的にポインタを渡すなどである程度防げるのですが、C#ではプロパティとして渡すオブジェクトに規制がないので、つい楽をしてこの問題を起こしがちなコードを書きたくなります。これを防ぐには、PropertyClassクラスの仕様を明確にすることですが、それが面倒なことも往々にあります。この場合、一番、単純明快な方法は、PropertyClassをクラスとして定義するのではなく、構造体(値クラス)で定義するということになります。値クラスで定義すれば、となるので、値クラスとすることで、そもそも代入しないといけないことを意識付けできます。値クラスであることを条件分岐などで代入を自動でやってくれるメソッドを作ることもそんなに難しくないでしょうしね。　例えば、次のような値クラスを考えましょう。値クラスSampleStructDtoを使おうとして、という書き方が出来ないのです。したがって、値クラスの定義をすべてフィールドとして書く必要が出てきます。ちなみに、これはこれで悪くないです。個人的には、Webを意識したプログラミングならこちらも使い勝手が良いと思います(Modelにべったりのコードを書かない限り)。一方で、値クラスの一部のフィールドを使ってgetterやsetter依存のコードを書くことは別に禁止されていないので、もうちょっと工夫出来ないかと思うわけです。私はASP .NET MVCを使った経験は薄いのですが、それでもC#のコーディングにおいて、このAutoMapperを使った概念は今までのコーディングスタイルを思いっきり変えたような気がします。そして、ここでは、AutoMapperを使って、値クラスと参照クラスを結合します。
Viewで値クラスにして、Controllerで変換して、Modelで参照クラスにすればよいのです。Viewはクライアントから来た情報を加工することがないので、値クラスで管理できれば十分で、Modelは値から値の変更を使って加工する使い方を想定しているので、向いているのかな？と思います。このコードの書き方は初めて見た人には違和感にしかなさそうですよねｗ　ChildStruct1DtoとChildClass1Dtoとか、実質内容が変わらんものを入れているので、無駄のように感じます。しかし、注目すべき点があります。　この場合の参照クラスって、一つのChildStruct1Dtoに対して、複数のChildClass1Dtoを定義できるんです。
　したがって、ControllerからModelに渡すときに、使うプロパティだけをピックアップして、Modelに渡すことが可能になります。
　
　AutoMapperは、独自クラスであるProfileをオーバーライドして、次のように定義します。　そして、StartUp.csの途中を次のように書きます。
　色々冗長な処理は入っていますが、デフォルトの.NET Core 5から変化しているところは、AutoMapperとSessionのみです。　つまり、UserProfileのおかげで、値クラスと参照クラス間で、同名のプロパティを勝手に変換してくれるわけです。　　AutoMapperがあるので、参照クラスに関係ないフィールドのことを考える必要がなく、Viewに影響あるであろうパラメータだけの変更だけ考えたらよいです。　使い方としては、　こんな感じですが、上の例では、値として変更される部分は、class_dtoだけを参照として渡せばよく、Controllerはその状況を感知しません。　なお、ChildStruct2Dtoのように可変配列を使用する場合はこんな感じですかね・・・。
　この場合は、ChildStruct2Dtoの中身とChildClass2Dtoの中身が完全対応している必要がありますね。もう少し、改善の余地があるかと思います。　メリットをまとめるとこんな感じですかね。C#を使用するすべての開発環境で対応できる値クラスとして定義した状態でデータを渡すので、値クラスの中身が書き換えられているかどうかを気にする必要がないModelで参照渡し、Viewで値渡しという定義が出来る。例えば値渡し側はIEnumerableにして、参照渡し側でListのようにするなど、Model側のみ柔軟に変更できるようなデータ構造に出来るgetter, setterを使うことが出来る(単にget; set;以外のものも可)


