More than 1 year has passed since last update.IDisposable インターフェースの実装に焦点を絞った記事です。
using 構文による自動開放や、Finalizeや、GCのメカニズムについては、本記事末尾の資料をはじめとして、ネット上に良記事が沢山あるのでそちらを参考にしてください。https://referencesource.microsoft.com/#mscorlib/system/idisposable.cs,1f55292c3174123d より抜粋とてもシンプルです。
IDisposable が求めているのは、void Dispose() を実装することのみです。
disposeパターンで述べられている void Dispose(bool disposing) は実装を要求されていません。void Dispose() は次の条件を満たす必要がありますここで言うリソースとは、ファイルストリームやデータベースコネクションなどの、OSや外部DLLが管理するハンドルに紐づいたものです。
そして、C#のCLRの管理下にあるものをマネージドリソース、管理外にあるものをアンマネージドリソースと呼びます。
この両者の区別については細々とした議論がありますが、IDisposable の実装に際しての分類は次の通りです。IDisposable インタフェースを実装したクラスのインスタンスです。IntPtrなどCLR外部(OSやDLLなど)のAPIから得たハンドル値です。それらのハンドル値は、SafeHandle のサブクラスでラップすることで、マネージドリソースに変換できます。
処理中の例外発生に対して安全になるので、特別な理由がない限りマネージドリソースに変換したほうが良いです。disposeパターンに従って、マネージドリソースとアンマネージドリソースを開放します。
ベースクラスはIDisposableを継承し、Dispose() と Dispose(bool disposing) と ファイナライザ(デストラクタ)を実装します。
開放処理は Dispose(bool disposing) で行い、、Dispose() と ファイナライザ(デストラクタ) はそれを呼び出します。
サブクラス側は、Dispose(bool disposing) のみをオーバライドします。なぜ、このような面倒な仕組みが必要なのでしょうか。
それは、プログラムがDispose()を呼ぶ前にGCがインスタンスを廃棄すると、インスタンスが持っているアンマネージドリソースが永遠に開放されない（リソースリーク）問題を避けるためです。
Dispose() と ファイナライザ(デストラクタ) の二か所でアンマネージドリソースの開放処理を行うことでも回避できますが、二か所に同じ処理を書くのは保守性が悪いので、一か所でまとめて処理するための仕組みなのです。
※ こういう仕組み（disposeパターン）を必要とするのは、C#言語がリソース管理の初期設計に失敗したからだと思います。disposeパターンに従って、マネージドリソースを開放します。
ベースクラスはIDisposableを継承し、Dispose() と Dispose(bool disposing) を実装します。
サブクラス側は、Dispose(bool disposing) のみをオーバライドします。bool _disposed フラグを省略するコーディングも可能です。
処理対象のマネージドリソースが少ない場合は、このコーディングの方が簡潔で良いでしょう。複数回呼び出しの際に base.Dispose(disposing); の呼び出しが冗長になるのが欠点ですが、ベースクラス側も安全に複数回呼び出し可能であれば動作上の問題はありません。アンマネージドリソースを持たない場合は、もっと単純に Dispose を実装するだけでＯＫです。ただしサブクラスもふくめて絶対にアンマネージドリソースを持たないという保証が必要です。
もしもアンマネージドリソースを持ちたくなったら、SafeHandle のサブクラスでラップしてマネージドリソースに変換することをルール化しましょう。ただし、サブクラス側で Dispose() を上書きしても、using 文で呼ばれるのはベースクラス側の Dispose() です。厳密にいえば IDisposable を実装したクラス階層の Dispose() が呼ばれます。 これでは都合が悪いので下記のいずれかの対策が必要です。対策1と対策2はusing文に対して期待通りに動作しますが、このような小細工を必要とするならば簡易版とは言えず、FxCopを入れるとCA1063警告が出るので素直にdisposeパターンを使う方がましです。結局のところ、簡易版として意味があるのは対策3のみです。C#8.0以後では、ref 構造体に限定されますが、 IDisposable を宣言しなくても Dispose() メソッドがあれば、using文でそれが呼ばれます。using文の言語定義を最初からそのように設計しておけば、IDisposableインタフェースも、disposeパターンも要らなかった気がしますが、後の祭りです。不要です。何もしなくて良いです。Reader/Writerクラスは、一般的にコンストラクタでストリームを受け取り、それに対して加工処理を施します。
ストリームの全体をReader/Writerクラスで処理する場合は問題ありませんが、ストリームの一部をReader/Writerクラスで処理する場合は、Reader/WriterクラスのDisposeでストリームを解放すると、以後の処理が出来なくて困ります。
そこで C#標準クラスの BinaryReader ではコンストラクタにストリームを渡すときに、bool leaveOpen を同時に渡して、Disposeでストリームを解放するかどうかを指定できます。自作のReader/Writerクラスにて、同様に leaveOpen を受け取る場合の Dispose パターン実装は次のようになります。ちなみに C#標準クラスの BinaryReader のサンプル実装は、こうなっています。
https://referencesource.microsoft.com/#mscorlib/system/io/binaryreader.cs頑張ってフィールドに null を設定していますが、#nullable enable な時代において、この辺りの処理は null に代わって Stream.Null を設定してゆく流れになるのかと思います。


