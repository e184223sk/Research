More than 3 years have passed since last update.GYAOのtsです。
我々のチームは、オールパブリッククラウドで、Microservice Architectureを採用した次期バックエンドを設計中です。チームが変わったりやなんやらで前回の投稿　から結構時間が空いてしまった。
引き続き我々のチームは戦陣切ってクラウド化を推進していこうと思う。
（なんでもクラウドにすればいいという意味ではなく、自由度を高め、視野を広げ、普通の力をつけようという意味で）今回はfunctionを軸に構築する。
全ての主要クラウドベンダーから出ているサーバーレスアーキテクチャという代物だが、流行ってますね。
先日Azureの方とお話しましたが、pushされていらっしゃいました。Azureとしても力を入れていく領域なのかなと個人的には感じている。
というのも、使い始めた頃よりだいぶ進化していて、認証やらswaggerドキュメントの生成やら細かい便利そうな機能が追加されていてmicro serviceのIFを作ってくださいと言わんばかりな形になってきているので、我々もそれに乗っかろうかなと。「LogicAppsでもFunctionでも実装できない複雑なビジネスロジックがあった場合のみコンテナでrestを作ってそれをFunctionsやLogicAppsから呼ぶ」みたいなスタンスでいくとシンプルかなと。今回はCosmosDBに以下の形で入った複数のドキュメントをクエリ検索するrestサービスを作成する。上記をidで検索して、「該当のコンテンツを保有しているのは誰か」を検索する。
クエリは下記の通りちなみにクエリの構築はこちらを使うと便利です。様々実装方法はあると思うが、今回はC#で構築。
まずはリソースの作成。

気をつけるのは、ApplicationInsightsをonにすること（後々監視でlogを拾えるようにするため）。次は関数の作成だが、テンプレートでC#のHttp triggerがあると思うので、それを使用する。
関数名は下記のようにしてみた。まずは基本的な挙動の設定をしないといけないので、「統合」画面に行く。
AzureFunctionsはトリガ、入力、出力の基本項目をまず設定する。その基本項目の設定でコードとのバインドを作成し、それが関数の構築画面で使えるという流れ。
入力はトリガ以外の入力があれば設定（今回の場合はCosmosDBから検索結果の入力があるので設定）する。今回のトリガ、入力、出力は下記の通り。

各項目を説明していく。オフィシャルドキュメントはこちらCosmosDBに名前が変わったはずだけど、ここはまだみたい。

オフィシャルドキュメントはこちら関数の戻り値をそのまま使用する。以上で基本設定は終わり。次に関数の構築画面にいって、ここで定義したバインドを使用して関数を作っていく。
関数は下記の通り。超簡素。引数をみてみると、先程定義した名前と同名で定義してあると思う。各引数に関して説明をしていく。実行してみる。

おかわりさんが引っかかった。API Definition（現在はpreview）からGenerate API Definition Templateを押すと、
contentsIdとかも含め情報を読み取って雛形を作成してくれる。なんて便利。
プロトタイプを作成して、同時にドキュメント作成、ある程度固まったらステークホルダにドキュメント渡す
みたいなスムーズなコミュニケーションがとれる。ApplicationInsightsを使用して、logを一元管理していきたいと思う。
最初にApplicationInsightsをonにしたので、あとは下記を行って、紐付けていく。日に日にパワーアップするAzureFunctionsをいじってて普通に楽しい。エンジニアがクリエイティブな部分に集中できるように痒いところに手が届いてきた気がします。ドキュメントが若干読みにくいのと、リソース横断的なusageドキュメントが少ない印象のAzureですが、紐解いていくこと自体も楽しいのでよしとします。今回の体験を経て、全体的にこんな感じにしようと思いました。チームメンバーの了承を得たらこれで行きます。
Eventhubに関して書いていこうと思います。


