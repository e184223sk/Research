大きく２つのメリットがあります。例えば戦闘中のゲームのキャラクターの状態を示す以下のフラグ（bool型変数）があったとします。ビット演算を使えば、全て１つの変数だけで制御できます。
ドラクエだとキャラクターの状態変化は数十もあるので１つ１つbool変数にしていたら面倒です。そして回復魔法でマイナスの状態だけ（攻撃力・防御力アップ以外）を回復させるなど一括操作も簡単にできます。このページの目的は、最後に載せているゲームのキャラクターの状態を管理するビット演算のコードを理解できるようにする事です。0001の眠りと、0010の毒を足すと、0011の毒に侵されて眠ってる状態が表現できます。
ただビット演算では、+や-ではなく、|や&amp;や~などを使います。ビット演算するには２進数の書き方を覚えた方が便利です。ついでに１６進数の書き方も覚えましょう。１０進数で返されたビット演算の結果は、２進数で確認した方がフラグの状態を理解しやすいです。
Convert.ToStringメソッドの第２引数に２を指定すると、第１引数を２進数に変換されます。
ちなみに１６だと１６進数に変換されます。
PadLeftメソッドは第１引数の桁になるまで、第２引数で文字列の左側を埋めます。２つの数値をビット演算子を使って計算します。１＋１＝２の＋みたいものです。
特に良く使う　|　と　&amp;　はどっちがどっちか分からなくなるので、自分は次のイメージで覚えています。ビット演算はかなり特殊なので、最初は分からなくても実際に使う段階で理解出来ます。こういうものかと深く考えずに暗記するのが早いです。左からn番目にフラグを立てる　i | (1 &lt;&lt; n)同じ値をXOR 演算子　^を使ってゼロクリアする。左からn番目のフラグを消す　i &amp;= ~(1 &lt;&lt; n)左からn番目のフラグが立っているか確認する　i &amp; (1 &lt;&lt; n)複数のフラグをまとめて、マスクビットを作るビット演算は便利ですが、フラグを数値だけで管理すると分からなくなりそうです。（0B_0100は「毒」で、0B_1000は「混乱」など自分で決めても間違えそうです‥）
enumの前に、FlagsAttribute属性を指定することで、列挙型の名前でビット演算のフラグを管理出来ます。（Flagsを外すと数値に対してビット演算しません[Flags]をコメントにすると違いが分かります）ちなみに赤と緑をかけ合わせると黄色になり、赤と青をかけ合わせると紫色になり、赤、緑、青、全てをかけ合わせると無色になります。三原色をビット演算で組み合わせる事で虹色を表現する事が出来るわけです。１つ具体例として、Taskのオブションで使うフラグの例を見てみましょう。
TaskCreationOptions.LongRunning | TaskCreationOptions.PreferFairnessは、列挙型のフラグです。TaskCreationOptions 列挙型列挙型の説明を見ると、フィールド毎に番号がふってありますが、全て２の倍数になっています。
この整数値をビット演算で組み合わせて、１つの引数で複数のフラグを立てる事を可能にしています。番号だけだと分かりにくいので列挙型にして名前を付けている訳です。ビット演算の締めくくりに、ゲームの戦闘中のキャラクターの状態を次々と変化させていきましょう。


