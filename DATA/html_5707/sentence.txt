More than 3 years have passed since last update.Moq は、テストダブル（＝単体テスト用の代役オブジェクト）を簡単に作るためのライブラリです。単体テストにおける問題のひとつとして、以下のようなことがあります。テスト対象の依存オブジェクトが・・・など、外部に依存する場合、そのままでは単体テストを作りにくいです。これを解決するために、実際のオブジェクトの代わりを用意します。テスト用の代役オブジェクトをテストダブルと呼びます。テストダブルはその役割に応じて、スタブ、モック、フェイク、などと呼称されます（それらの違いについては、本記事の主題と直接は関係がないので割愛します）。テストダブルはあくまで代役なので、本物と同じ振る舞いはしません。単体テストが動けば良いと割り切ります。ただ、このときの問題として、本物と同じ I/F を実装するのって結構めんどくさいです。特に、I/F が多い場合や、開発中で I/F が変化する場合がつらいです。単体テストのためだけにそこまで頑張らなくてはいけないのか？そこで、実装をサポートしてくれるライブラリがあると嬉しいです。いくつか代表的なものを挙げます（他にもありますが）。この記事では、Moq について書きます。発音は「もっく」か「もっきゅ」らしいです。「q」は「k」の発音になることが多いと思いますが（「Linq」とか）、「Mock」と「Moq」で発音が同じというのはつらいので個人的には「もっきゅ」がいい気がします。ついでに、カタカナでなくひらがなで書くのがいい感じ？とりあえずこれだけで、実装クラスを書かなくても全ての interface を勝手に実装してくれます。置き換えたいオブジェクトの interface を定義しておく必要があります。これは設計に影響を与えるので注意が必要です。どちらかといえば設計が改善されるのですが、複雑度が上がるきらいもあります。なお参考として、本物の class を継承してテストダブルにする手もあります。これだと interface を定義しなくてすみます。ただ、これはテストダブルの挙動が本物と混ざってよくわからないことになりがちで、避けた方が良いように思います。まずは、欲しいテストダブルを作るための基本を押さえます。実際の使い方としては、以下のようになります。まず事前準備としてテストダブルの実装をします。そして、単体テストコードでは、実際のオブジェクトの代わりに mock.Object を使います。本物のオブジェクトをテストダブルに差し替えられるようにしておく必要があります。手段は何でもよくて、単にコンストラクタで渡しても良いですし、DI コンテナを使っても良いです。ひとつ大事な点として、テスト対象は class ではなく interface に依存するようにしておきます。そうしておかないと、自由に差し替えるのが難しくなります。基本編だけでだいたい足りますが、以下のような点も気になるところです。それらの例を挙げます。Moq の機能はたくさんあって、凝りだすといろいろできます。しかし、やりすぎには注意が必要です。あくまでテスト用の代役オブジェクトであって、単体テストのときだけ使えればいい、本物になる必要はないと割り切ります。テストダブルを楽に作るのに Moq のようなライブラリは便利です。ただ、テストダブルを実装していくと、ソースコードの記述量は案外多くなります。そのため、最初は楽だったけどだんだん大変になってきた、なんてことも起こります。場合によっては、ライブラリなしでテストダブルを実装する方が楽になるかもしれません。そのため、いつでもライブラリを使うのがベターであるとは言い切れません。一方、ライブラリを使うメリットとしては、テストダブル実装コードを一箇所に（1メソッドに or 1ファイルに）まとめやすいという点があります。テストコードやテストダブル実装コードは、テストの内容ごとにまとまって書かれているのが良いかと思います。ライブラリを使うことで、そのようなテストコードを書きやすくなります。外部に依存するものの単体テストをそもそも本当に書くべきかどうか、ということも気にしておいた方が良いかもしれません。その外部オブジェクト自身が単体テストすればすむという場合もあるでしょう。もちろん、それではすまない場合もあって、そんなときの手段のひとつとしてテストダブルの活用が考えられます。Moq : Mocking Framework for .NET
（Mobile Act Osaka #2 で、この内容について LT をした際の発表資料）本記事は、上記の LT の内容を元に、補足や修正を加えたものです。


