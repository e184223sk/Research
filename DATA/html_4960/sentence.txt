More than 3 years have passed since last update.かくかくしかじかによりIPC(プロセス間通信)を使用する事にしました。
で、色々調べまして一旦はNetNamedPipeBindingを検討しました。
その後 System.IO.Pipes を見つけまして、こちらを採用。
自分のためのメモとしても記事にまとめました。サーバーとクライアント双方に共通となる項目を抜き出しました。
が、あまり多くはありませんでした。_PipeName はサーバーとクライアント共通で使用する名前付きパイプの名前です。サーバ回線を使用するプロセスでNamedPipeServerMng のオブジェクトを作成します。
Start()関数で回線を開き、Stop()で回線を閉じます。
回線を開いている間にクライアントがデータを送信してきた場合に_ReceiveMsg に設定したデリゲートに転送することでその後自由に処理することが出来ます。ConnectionTimeout()関数はサーバー回線の待ち受けタイムアウト処理を行います。
クライアントからの接続を待ち受け中に_TimeoutCount で設定した時間（秒）接続がなかった場合、一旦回線を閉じます。
閉じている間にIsListen をチェックし、終了の判定を行います。
このあたりの処理は、こちらNamedPipeServerStreamのConnectタイムアウトの記事を大いに参考にいたしました。クライアント側もサーバー側と同様、クライアント回線を使用するプロセスでNamedPipeClientMng のオブジェクトを作成します。
オブジェクト作成後SendMessage()関数で送信したい文字列を送信します。
あとは勝手に回線を開き送信、回線を閉じるところまで行います。NamedPipeClientMng ではサーバー回線のNamedPipeServerMng と違いWakeupPipeServerProc()関数とShutdownPipeServerProc()関数の二つの静的関数を持たせています。
クライアントプロセス起動時などにWakeupPipeServerProc()関数を使用してサーバープロセスを起動します。
これで、送信先のプロセスが起動され、（恐らくは）パイプが待ち受けていると期待できます。
合わせてクライアントプロセス終了時にShutdownPipeServerProc()関数を読んでサーバープロセスを終了させます。3つのプログラムをまとめてライブラリ(DLL)にしました。
でサーバープロセスとクライアントプロセスで共通に使用することで、パイプの名前を合わせることが出来ます。
相互通信する場合には、プロセスＡ、Ｂともにサーバー回線とクライアント回線を両方をインスタンス化します。
お互いに自分のクライアント回線から相手のサーバー回線にデータを送信する事で、相互通信を実現できます。
この場合パイプの名称が重複しない様注意してください。
です！


