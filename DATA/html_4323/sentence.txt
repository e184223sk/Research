お仕事で機器からの数十点の計測値を100ms周期で取り込み、それぞれ別の計算式で物理値に変換してチャートに表示するというのがありました。
計算式は機器の型式などで変更になるため文字列で以下のように定義ファイルに記述します。
"para1 / 360 * 100 + 1"
文字列はExpressionの式木を使って関数に変換し結果をバイナリで返します。
para1は計測値を示すパラメータでdouble型で与えられ、結果もdouble型で返します。
これ自体は数十ステップのプログラムで実現できたのですが、もう少し高機能にできないものかと、勉強を兼ねてプライベートで作ったのが本記事で紹介するコード（FormulaConverter）です。
計算式は以下のように記述します。
"Func&lt;int,int,double&gt;(x,y)=(int)x/2 + 5 - 10 * 2.3333d + (int)0.5f+Math.Pow(Math.Abs(y),2)"特長としては、
・パラメータを渡せる
・カッコで計算順序を制御できる
・明示的な型変換(キャストができる
・System.Math関数が使える
・ラムダ式をコンパイルするのでそれなりに高速である
などです。
基本的に他のコードは流用していませんので完全フリーですが、極端に言うと掲載した計算結果しか確認していませんので使用する場合は自己責任でお願いします。FormulaConverterとラムダ式で同等の式を作成し実行してみました。
以下のようなコードを自動生成して試しました。実行した結果です。FormulaConverterとラムダ式、念のためハードコーディングした関数でそれぞれ100万回実行してみました。測定結果です。
まあ想定内ですがラムダ式が一番早いみたいです。・文字列の解析処理を簡略化しているため"1++1"はエラーにならず"1+ +1"と同じ結果になります。
また、"-1"のようなリテラル値はExpression.Constant(-1)ではなく、Expression.Constant(1)を Expression.Negateに変換します。
・型は数値型とSystem.Mathなどをサポートしています。
・Math関数はMath.PIとかMidpointRounding.ToEvenとか使えるようにしました。引数にも渡せます。enumのORは試していません。
・float型を使ったときラムダ式と違いがでます。
・当初エラー処理はほとんどやっていなかったのですが例外メッセージを追加しています。2018/11/28
投稿したばかりなのですがやっぱりMath.PIなど使えないといやですよね。
という訳で、やっちゃえリフレクション、Math.PIなどのフィールド値を使えるようにしました。No.19が追加のサンプルです。
2018/11/30
演算子の優先順序が思いっきり違っていたので%演算子の追加と合わせて修正しました。
2018/12/2
一応数値型全てに対応しました。No20と21を追加しています。
またこれを機に型の変換優先度などを定義した間に合わせの辞書は廃止しました。
2018/12/15
Math関数以外の対応と"1/-5"のように割り算と符号の組み合わせが記述できない不具合を対策しました。
合わせてフォーマットエラーについて極力意図した例外を発行するようにコードを見直しました。
2019/4/9
コードが長いので最後尾に移動しました。内容は変わっていません。
2020/10/7
適用例（画像）を追加しました。


