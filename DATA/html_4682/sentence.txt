More than 3 years have passed since last update.C#でプログラムを書くときは当たり前のように名前空間を使用していると思います。例えば以下のような場合、System名前空間を使用しています。プログラムの先頭にusing System;を書いている場合は毎回Systemを書きませんがこれは先頭部分で名前空間を使用しています。
今回は名前空間を全く使用せずにプログラミングができるかどうかを検証していきます。レギュレーションは以下の通りです。上記以外のことなら何をしてもです。
dynamicを使用しないというレギュレーションは特に意味ありませんがdynamic無しのほうが面白そうなのでつけました。.NET Core 2.0文字列を画面に表示する。全く名前空間を使わないのはなかなか難しいです。
基本的に標準ライブラリのクラスに直接アクセスすることはできません。
名前空間を書かなくてもアクセスできるものは以下の通りです。これ以外のものは使いたくても使えません。
例えばListもDictionaryも何一つとして使用することができません。
既存のインターフェースを実装した型を作成することもできません。画面に文字を表示するためにはSystem.Console.WriteLine(System.String)を呼び出す必要があります。
何とかしてこれをリフレクション経由で呼び出します。リフレクションと聞くとtypeof(System.Console)と行きたいところですがこれはできません。
どうにかしてSystem.ConsoleのSystem.Typeを取得しなければなりません。今回はSystem.Reflection.Assemblyを通してSystem.Consoleを取得する方法を考えてみます。
通常System.Reflection.AssemblyはSystem.Reflection.Assembly.GetEntryAssemblyやSystem.AppDomainを通して取得します。
今回はこの手法は使用できないため、typeof(XXX).Assemblyを使用することにしました。
typeof(XXX).Assemblyではそのタイプが定義されているSystem.Reflection.Assemblyのインスタンスを取得することができます。アセンブリからタイプ情報を探すためにはどうしたらいいでしょうか。
アセンブリのメンバ関数にはGetTypesという関数があります。
この関数はアセンブリに含まれるタイプ情報を列挙する関数なのでこれを使用すればタイプ情報を探すことができそうです。
しかし、GetTypesで取得できるのはアセンブリ内のクラスのみです。
今回の場合ではSystem.Consoleが含まれるアセンブリへの参照が取得できなければなりません。
なのでタイプを探す前にまずアセンブリを探す必要があります。もう一度アセンブリのメンバ関数を見てみるとGetReferencedAssembliesという関数があります。
この関数はアセンブリが参照しているアセンブリの名前を返すというものです。
名前が分かってもアセンブリへの参照が取得できなければ意味がありません。
そこでアセンブリの名前からSystem.Reflection.Assembly.Loadを使用してアセンブリをロードしアセンブリの参照を取得するという方法をとります。
(本当はSystem.Consoleだけでよいなら存在するアセンブリはバージョンごとに固定なのでGetReferencedAssembliesは必要ないですが汎用的にするためにこの手法をとりました。)アセンブリのロードも簡単ではなく、ここでもリフレクションをフル活用する必要があります。
まずSystem.Reflection.Assembly.GetEntryAssemblyのMethodInfoを取得するのですが、
そのためにはSystem.Reflection.Assemblyのタイプ情報が必要です。
System.Reflection.Assemblyのタイプ情報を取得はSystem.Reflection.AssemblyのインスタンスからGetType関数で取得することができます。と言いたいところですが実際にはtypeof(Program).Assembly.GetType()で帰ってくるクラスはSystem.Reflection.RuntimeAssemblyのインスタンスになっています。
このままではGetMethodsを呼び出しても目的のMethodInfoを取得することができません。System.Reflection.RuntimeAssemblyはSystem.Reflection.AssemblyのサブクラスなのでBaseTypeを取得して使うことにします。MethodInfoの検索は文字列比較で行います。これで好きにアセンブリのロードができます実はまだ問題があります。
.NET Core 2.0でこのコードを実行すると例外が発生します。TargetExceptionでググるとインスタンスのメソッドを第一引数nullで呼んでいるなどの情報が見つかるのですが、今回の場合は確実にスタティックなメソッドです。
スタックトレースを見るとRuntimeMethodInfo.InvokeArgumentsCheckが例外を投げていることが分かりました。
ソースコードを参考にするとどうやらm_invocationFlagsにINVOCATION_FLAGS_NO_INVOKEが入っていると例外が投げられるようです。打つ手がなくなった気がするのですがとりあえずm_invocationFlagsのINVOCATION_FLAGS_NO_INVOKEをリフレクションを使って削除できるかどうか試してみます。ただしこれも簡単ではありません。
m_invocationFlagsはフィールドなのでGetField関数を使うのですが、パブリックではないためSystem.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublicフラグを指定しなければなりません。
フラグの論理和はとても難しいです。
単一のフラグでいいならGetEnumValuesで何とかなりますが論理和の場合はそうもいきません。
これを作るためにはEnum.ToObjectを使用する必要があります。
またリフレクションです。
Enumのタイプ情報の取得は既存のEnumのインスタンスからGetTypeで取得します。
あまりに面倒なので詳細は省きます。
下記の実装を参考にしてください。もうすでに何をやっていたか忘れかけてきましたがアセンブリのロード時にエラーが出ていたのでした。
正直このm_invocationFlagsを書き換えられないと思っていたのですが実行しても特にエラーが起きずに書き換えられてしまいました。
これによってアセンブリのロード時のエラーもなくなりました。ここまで来たら後はもう消化試合です。
再帰しながらアセンブリをロードして目的のタイプを探すだけです。ネームスペースが書けないので引数が全部objectになってたりしますが些細な問題です。
すべての関数はリフレクション経由で呼び出せばいいだけです。
これで終了です。????????よくわからないですが、実際にプログラム中でSystem.Consoleが使用されていないと参照アセンブリに含まれないようです。
仕方ないのでGetReferencedAssembliesを捨てて直接System.Consoleを読み込みます。今度こそ終わりですとても大変だった割にはあんまりおもしろくなかったかもしれません。
私の知識不足で微妙な感じになってしまいました。
今回は文字列表示だけでしたがリフレクションを駆使すればもっと高度なこともできるのではないでしょうか。
通常の方法では例外のキャッチを実現することはできないと思いますが、ILの動的生成を使えば解決可能なのかなという気がします。
(やる気はないので他の人に任せます。)ちなみにターゲットを.NET Frameworkに変更するとSystem.Consoleがmscorlibに含まれるためGetReferencedAssembliesの手法で動きます。
またSystem.Consoleアセンブリロードができないため.NET Core用のコードのままでは失敗してしまいます。今回書いたソースコードは以下にあります。
yaegaki/CSharp-HelloWorld-WithoutNamespace


