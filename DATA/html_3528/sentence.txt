久しぶりの投稿です。しばらく何も書いてなかったのは、やる気が出なかったお仕事が忙しかったからです。Selectに関して書こうと思ったけど面倒くさくなって書くことがなく、とりあえずLINQ全体についてダラダラ書こうと思ってたら、なんだか長くなってしまいました。定期的に見直して、書き直す予定です。(予定は未定)System.Core.dllのSystem.Linq名前空間の Enumalableクラスにあるメソッドの解説を並び立てる記事です。対象 は .Net Framework 4.7.2です。なので、SkipLastとTakeLastは対象外です。SkipLastTakeLastアイドルマスターです。わっほ～い独断と偏見で10種類に分類しました。とりあえずMicrosoftの公式ドキュメントから説明を引っ張ってきました。射影操作 (C#) 射影とは、オブジェクトを、必要なプロパティだけで構成された別の形式に変換する操作のことをいいます。 つまり、「もとのデータ」を「今使いたいデータ」に変換して取り出すメソッド達です。射影系の中でも一番シンプルなやつです。そして、シンプルだけに一番人気候補です。Microsoftも分かってるようで、Selectと、もう一つの一番人気候補Whereに関してはパフォーマンスのための最適化がかなりかかっています。少しわかりにくいメソッドですが、やっている事はそんなに難しくないです。もとのデータから新たなIEnumerableを取り出し、それを1つに結合します。射影系なのかどうかと聞かれると、よくわかりませんが、他に入れるところも思いつかなかったので入れちゃいました。各データに対して、ジェネリックで渡された方にキャストします。が、後述のOfTypeと異なりキャストに失敗すると例外を吐くので、あまり使われてない気がするメソッドです。読んで字のごとく、フィルタリングするメソッド達です。フィルタ系の基本です。データリストに対して何か処理をする前に不都合なデータを弾くために使うことが多いと思います。こいつもかなり最適化されているので、興味がある人は昔書いたやつを読んでみてください。各データに対して、ジェネリックで渡された方にキャストします。が、前述のCastと異なりキャストに失敗した要素はスキップされるので、使い勝手が良いメソッドです。メソッドの実行後に全体のデータ数が減るので、フィルタ系ってことになってます(僕の中では)。重複削除メソッドです。組み込み型だったら特に何も考えなくて良いんですが、自作クラスの重複削除だとちょっと面倒です。1の方が実装が1つにまとまるので良いと思います( こんな感じ )が、必ずしも自分で弄れるクラスばかりではないので2の出番もあるかと思います。(他にも方法はあるんですかね？僕は知りません。)※追記(コメントにて頂いたアドバイス)「IEqualityComparerを提供するプロパティ」と「IEqualityComparerを継承しているクラス」を元のクラス内に定義すると、実装を1つにまとめつつ、複数の比較方法を使い分けられます。(これ以降のメソッドも同様です。)また、タプルや匿名型等の比較を行いたい場合、IEquatableインターフェイスを実装できないので、IEqualityComparerを使用する事になります。指定した条件を満たしていたらture、そうでなければfalseを返すメソッド達です。データリスト内に、指定した条件を満たすものが1つでもあればtrue、1つもなければfalseです。条件を指定しない場合、何でも良いから要素が1つでもあればtrueです。Count() == 0とかやっちゃうとLINQ警察が飛んできて、こいつを投げつけてきます。データリスト内の、すべてが指定の条件を満たすせばtrue、1つでも満たさなければfalseです。Anyと違って条件なしはありません。「なんでも良いから要素が全て入っている」→意味がわからないので。データリスト内に、引数で渡したデータと同一の物があれば、true、なければfalseです。Distinctと同様で、自作クラスの判定だとちょっと面倒です。isBlank1とisBlank3はtrueですが、isBlank2はfalseになります。基本的にはAnyの方が使い勝手が良いですが、ラムダ式の中で呼ぶ時にこっちを使うことがあります。今までのとは少し違います。2つのデータリストに対して要素を順番に比較し、全て一致していたらtrue、そうでなければfalseです。意外と使い勝手の良いメソッドで、2つのデータリストの型が違っても比較可能です。(今回の例だとIEnumarableとList。)ただし、自作クラスの判定だとやっぱりちょっと面倒です。いろいろな計算をしてくれるメソッド達です(適当)。平均値を求めます。こいつに限った話でないですが、算術系は大量のオーバーロードがあります。(Averageだけで20個)とは言っても、これら5種類の変数と、それぞれのnull許容型(?がつくやつ)、およびその両方のラムダ式に対応したメソッドなので、特にビビる必要はないです。合計を求めます。こいつもオーバーロードが20個あります。内訳はAverageと同様です。最大値を求めます。こいつはオーバーロードが22個あります。内20個は、Averageと同様です。残り2つの内の1つです。(もう1つはラムダ式を用いて、これと同じものを作成するメソッド)Averageで上げた5種類の変数以外のリストでも、MaxとMinは使用可能です。ただし、そのままでは実行時に例外を吐いて死にます。データリストの中身がIComparableかIComparable&lt;T&gt;を継承している場合、比較が可能です。一番大きい値を取得しつつ、他のパラメータも参照したい時にこの方法が使えます。最小値を求めます。こいつもオーバーロードが22個あります。内訳はMaxと同様です。要素数の合計を求めます。条件を指定することも可能です。2つともほぼ同じなので、基本はCountで十分です。その名の通りLongCountは戻りがLongなので、アホみたいに大きなデータの塊を扱う場合のみこっちを使ってください。今まで出てきた算術系メソッドは(理論上)こいつですべて置き換え可能(なはず)です。ただし、面倒。少し複雑なので、しっかり解説したいと思います。オーバーロードは全部で3つです。(上の3つの例と対応してます。)まずは1つ目から。Aggregateの実装内容を引っ張り出してきました。「Aggregateの引数で指定するラムダ式」は「引数が2つ」です。ややこしい日本語ですが、Aggregate((x, y) =&gt; x + y)のxとyの事です。xはいままで計算してきた結果、yは各要素の値です。分かりづらいので、置き換えてみます。↓こうして合計を求める事ができました。また、戻り値の型はデータリストの要素の型です。(今回はSelectで取り出したdouble)次は2つ目。1つ目ほぼ同じですが、初期値を指定することができます。なので今回のケースで置き換えると、↓ここで少し注意事項ですが、Aggregateの第2引数のラムダ式は、1つ目の引数は初期値と同じ型で、2つ目の引数はデータリストの要素と同じ型です。第2引数はFunc&lt;TAccumulate, TSource, TAccumulate&gt; funcです。TAccumulateは第1引数から推論されます。TSourceはデータリストから推論されます。そして戻り値はTAccumulateになり、これはラムダ式の戻り値から推論されます。推論だらけですね。最後に3つ目です。2つ目とほぼ同じですが、戻り値に対して最終処理を行えます。例によって置き換えてみます。↓ここでの注意事項として、最終的な戻り値は、Aggregateの第3引数のラムダ式の戻り値です。また第2引数のラムダ式に関しては2つ目と同じです。C#でそれなりの量のコードを書いてきましたが、今の所一度も使った事はありません。データリストの中から、1つだけ要素を取り出す事ができるメソッド達です。また、大して変わらない大人の事情で、2つ同時に解説します。条件に一致した最初の要素を取り出します。特に条件を指定しない場合、1つ目の要素が取り出せます。2つの違いですが、条件を満たす要素が見つからなかった時の挙動で、Firstは例外が発生し、FirstOrDefaultは既定値を返します。単体取得系の中では一番人気だと思います。条件に一致した最後の要素を取り出します。特に条件を指定しない場合、最後の要素が取り出せます。2つの違いですが、条件を満たす要素が見つからなかった時の挙動で、Lastは例外が発生し、LastOrDefaultは既定値を返します。たまに使います。条件に一致した唯一の要素を取り出します。条件を満たす要素が複数あった場合、例外が発生します。特に条件を指定しない場合、ちょっと特殊な挙動をします。2つの違いですが、条件を満たす要素が見つからなかった時の挙動で、Singleは例外が発生し、SingleOrDefaultは既定値を返します。SingleOrDefaultも、条件を満たす要素が複数あった場合、例外が発生します。使った事は1度もないです。インデックスで指定した場所の要素を取得します。特に条件とは設定できません。2つの違いですが、領域外(0未満や要素数以上の値)を設定した時の挙動で、ElementAtは例外が発生し、ElementAtOrDefaultは既定値を返します。IEnumerableのままインデックスで取得可能なので、便利な気がします。が、使った事はありません。データリストをまるっと別の形に変えてしまうメソッド達です。IEnumerableに変換します。外部クラス等からListや配列で受け取ったデータをIEnumerableで公開したい時に使います。今の所、そんな局面に出会った事はないですが。主な使いみちは2つあるそうです。1つ目は、隠蔽されてしまった拡張クラスのメソッドを呼び出すとき。拡張メソッドは、インスタンスメソッドよりも呼び出しの優先順位が低いです。なので、こんなクラスを作って、Anyを実装してしまうと、LINQのAnyが呼び出せなくなります。こんな時にこいつの出番です。2つ目は、LINQ to SQL、つまりデータベースとデータをやり取りするときに使います。詳しくはこちらをご覧ください。ちなみに驚くほどシンプルな実装です。Listに変換します。注意事項ですが、必要になるまで実行しないようにしてください。いろいろな人がいろいろな所で言ってるので理由は割愛。(面倒だし)わりとよく見るコードですが、LINQ警察の大好物です。こうやってLINQ警察を追い返しましょう。配列に変換します。注意事項はToListと同じです。Dictionaryに変換します。取り出す形式は特に指定しなければ元のデータ、指定した場合はその型です。注意事項ですが、重複する値をキーに指定すると例外が発生します。(アイマスに同姓同名のキャラはいないが、年齢が同じキャラはいる)ILookupに変換します。Dictionaryに似ていますが、Dictionaryが一致する単一の要素を取り出すのに対して、ILookupは一致する要素のコレクションを取り出します。HashSetに変換します。やっている事自体はDistinctと同じです。なので、注意事項も同じ。何が違うかというと、ToHashSetはHashSetクラスに変換します。なので、ここで評価が実行されます(即時評価)。一方DistinctはIEnumerableのままなので、評価は実行されません(遅延評価)。使い分けの基準としては、でいいと思います。ソートするメソッド達です。以上です。指定されたキーでソートします。IComparerインターフェイスによってソート方法を指定することも可能です。OrderBy とOrderByDescendingを実行後のみ、呼び出せるメソッドです。OrderByやOrderByDescendingで同一だった場合の副条件を設定できます。当然IComparerインターフェイスによってソート方法を指定することも可能です。データリストから範囲を指定して取得するメソッド達です。引数で指定した数だけ飛ばして、残った要素を返します。この時、要素数よりも大きな数を指定しても例外は発生しません。引数で指定した条件に一致する要素が出てくるまで飛ばして、残った要素を返します。この時、最後まで一致しなくても例外は発生しません。引数で指定した数だけ取得して、残った要素を飛ばします。この時、要素数よりも大きな数を指定しても例外は発生しません。引数で指定した条件に一致する要素が出てくるまで取得し、残った要素を飛ばします。この時、最後まで一致しなくても例外は発生しません。見れば分かると思いますが、と対応する関係になってます。複数のデータリストを様々な方法でくっつけるメソッド達です。この辺から、結構説明が面倒くさいやつが増えてきます。元のデータリストの後ろに、引数で指定したデータリストをくっつけます。ただの結合なので、重複してても関係ありません。2つのデータリストから1つのデータリストを作ります。第1引数で指定したデータリストと元のデータリストを、第2引数のラムダ式で変換して1つのデータリストにまとめます。注意事項ですが、最終的な要素数は2つのデータリストのうち少ない方と同じです。今回の場合は、上のリストの方が長いので、後ろ2人は無視されます。元のデータリストと、引数で指定したデータリストの和集合を求めます。和集合なので重複は削除されます。元のデータリストと、引数で指定したデータリストの積集合を求めます。積集合なので、重複したもののみが残ります。元のデータリストから、引数で指定したデータリストを引いた差集合を求めます。「元のデータリストにない要素」が、「引数のデータリストにある」状態でも例外は発生しません。結合系では無いような気もしますが、他に場所が無かったのでここで説明します。変換系で説明したToLookupとほぼ同じです。違いは評価のタイミングです。ToLookupはILookupインターフェイスに変換します。なので、ここで評価が実行されます(即時評価)。一方GroupByはIEnumerableのままなので、評価は実行されません(遅延評価)。ToHashSetに対するDistinctと同じです。なので、使い分けもそちらと同様です。元のデータリストに、引数で指定したデータリストを結合します。引数を順番に説明すると、こんな感じです。結合した後に、指定したキーでグループ化します。引数を順番に説明すると、こんな感じです。Joinとほとんど同じです。どこに入れたら良いかわからないもの達です。データリストをひっくり返します。ただひっくり返すだけなので、上記の2つが同一のデータリストを返すとは限りません。先頭や末尾に新たな要素を追加します。注意事項ですが、Addと異なり、元の要素は変更されません。あくまで新しいIEnumerableを返すメソッドです。要素数が0の時、代わりに返す値を設定できるメソッドです。検索結果が見つからなかった時に返すメッセージを設定しておくと、捗るかもしれませんね。新たなIEnumerableを作り出してくれるメソッド達です。Rangeは初期値と回数を指定します。初期値から1ずつインクリメントされたIEnumerableが返ってきます。Repeatは設定値と回数を指定します。Rangeとは異なり、設定値を回数分繰り返したIEnumerableが返ってきます。Emptyは空っぽのIEnumerableが返ってきます。引数がなにもないので、ジェネリックで型を指定します。有効活用できる場面が思いつかなかったので、誰か教えてください。一気呵成に書き上げました。左手が攣りそうです。JoinとGroupByとGroupJoinはそのうち個別に何か書こうかと思ってます。(思ってるだけ)「その説明間なんかオカシイで」とか「このメソッドもっと詳しく」とか「何いってんだか分かんねーぞ」とかあったらコメントとか編集リクエストとかでお願いします。


