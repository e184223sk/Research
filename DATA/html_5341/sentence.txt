More than 3 years have passed since last update.sh_akira さんの INotifyPropertyChangedの実装をなるべく簡略化したい に触発されました。データバインディングに必須なのが INotifyPropertyChanged の実装ですが、これをいちいちやるのが面倒くさい。
それで色々な工夫がなされています。対策としてはが主に挙げられるようです。
しかし、継承したのでは他のクラスからの継承ができなくなるし、セッターを変えるのはせっかく簡単にプロパティが記述できるよう進化してきた C# の素の機能がもったいない。ReactiveProperty は便利だけど Value が気になる。と、些細なことではありますが不満はあります。
その中で IL を使ったことのない sh_akira さんがほんの数時間で作ったものは ViewModel の見た目の簡略さと記述のしやすさに於いて画期的だと思いました。それに触発されて私も書いてみました。IL を使うか Roslyn を使うか迷ったのですが、結局 CodeDom を使うことにしました。
せっかくあるものだからオワコンになる前に一度使ってみようという気持ちです。そして継承が使えるよう、任意のクラスに INotifyPropertyChanged を実装する仕様にしました。以下のソースを PropertyNotifier.cs という名前で保存してプロジェクトに追加してください。まず INotifyPropertyChanged を実装したいクラスを書きます。説明の必要はないと思いますが、単に string 型の Name プロパティと int 型の Age プロパティを持つだけのクラスです。
プロパティはそれぞれ Alice, 10 で初期化され、表示に便利なように ToString() をオーバーライドしています。
これを次のようにインスタンス化します。そして INotifyPropertyChanged が実装されていることを確かめるためにイベントハンドラを記述します。INotifyPropertyChanged にキャストしているのは、もともとの ViewModel が INotifyPropertyChanged を実装していないためです。
キャストしなければコンパイルできません。さて、このようにイベントハンドラを書きましたので PropertyChanged イベントが起こると (property Name) is changed to (new value). のようにコンソールに出力されます。実行してみましょう。次のように表示されました。viewModel は { Name = Alice, Age = 10 } と初期化されていることがわかります。
Name と Age を変更するとちゃんと変更通知が届きました。通知されるプロパティは以下の条件を満たしている必要があります。上記の条件を満たしているプロパティは自動的に通知されます。
しかし中には通知しなくて良いプロパティもあるかと思います。
その場合には次のように属性を使います。実行結果は以下のようになります。Name と Age が変更されましたが、通知されたのは Name のみです。
このように、NotifyPropertyAttribute を使うとデフォルトでプロパティの変更は通知されなくなり、その属性のついているプロパティのみ通知されるようになります。
通知したくないプロパティに属性を付与するのではなく、通知したいプロパティに付与することに注意してください。次のようにコンストラクタに引数を与えることができます。結果は次のようになります。ちゃんと指定されたコンストラクタが呼ばれているのがわかります。CodeDom の良いところは C# のソースに変換できるところです。次のようなソースが作られました。System.Windows.Forms.Form.Tag は virtual ではないのでそのままでは通知されません。
これを通知させるには以下のように new キーワードを使って同名のプロパティで上書きします。
しかしながらこれは Form1 に同名のプロパティを作ったというだけで、Form のプロパティではありません。
したがって、Form 型の変数に代入した場合には使うことができません。
Form1 には Tag というプロパティが二つあって新しく作った方をデフォルトで使うという扱いです。Program.csForm1.cs


