More than 1 year has passed since last update.HoughCircleを使うなら以下パラメータの意味についてはこちらが分かりやすかったです。しかし、私の検出したかった円がうまく検出できません。パラメータを調整しながら様子を見ましたが、検出しすぎるか、足りないか、と言った結果になりました。
検出数を多くしてフィルタリングすれば・・・！と思ったのですが、処理に結構な時間がかかったり、期待した円と違う結果になったりします。そこで自前で円検出を作って目的に近いものが出来るか、やってみました。コード中のベタ書きの数字は対象画像によってかなり変わります。
今回の対象はといった画像です。
普通の風景写真などから検出しようとする場合、この数値のままでは厳しいと思います。まだ実験用の為見苦しい点が多いですがご容赦ください。円弧から半径、中心点を計算する為に、まず計算式を調べます。
最小二乗法で近似円計算すれば良いんでしょ？位の知識から調べました。
ここで丁寧に説明されてます。上の参考のページに一部間違いがある様です。
下の方のコード中でmatrix2としている部分の符号がマイナスでなくプラスの様です。・・・行列の反転、積を計算しなければならないんですね。そういえば今までC#で行列演算をしてこなかったような。
.NetにはDirectX向けか何かのMatrixクラスは有りましたが、どうも今回の目的には使えない模様。Math.Net Numericsを使うのが楽そうですが、
訳有ってこれが使いづらい状況ですので自作してみることにします。OpenCVにはCircleSegmentと言う構造体が有り、円の情報を持たせるにはこれが良さそうです。
しかし、と思い自作クラスを作りました。
このあたりは状況次第でしょうか。結構な行数になってしまいました。
最初1000点超えのPointを計算したらLINQのSumでOverflowExceptionが発生したり、時間がかかったりと紆余曲折有りました。
Overflowは久々に直面しましたね。コレクションの要素の2乗3乗の総和があるのでこの辺りが結構桁が大きくなります。これに渡す点数は最低3点。
上手く取れていれば5点でかなり近い円が取れました。
現在10点でやってますが、
Overflow対策で点数を絞るなり、要素の数値が余りにも大きい場合は一旦小さくするなどの工夫が必要かもしれません。OpenCvSharpで輪郭検出しました。
ここは自前より数段いいですね。色々と調整項目が有りました。
領域を限定してしまえば2値化してしまうのが楽そうです。
が、それがちょっとやりづらかったので輪郭検出の肝はCannyで行いました。対象画像では割と思った通りの輪郭が取れました。


