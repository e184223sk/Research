More than 3 years have passed since last update.自前でC#の変更通知クラスを作って勉強になったことまとめ(前編)
の続きです.「ブラックボックス的にMVVMフレームワーク使うんじゃなくて, ちゃんと自分で理解したい」という所から話はスタートしました.これを踏まえ, 前編ではプロパティの変更通知・受信を自前で実装しました.今回はちょっと踏み込んで, Modelの配列の影となるViewModelの配列をどう作れば良いのかを見ていきましょう.前回に比べてかなり面倒臭いので, お茶でも飲みながら見てくださいLivetには「CreateReadonlyDispatcherCollection」という神ヘルパー関数があるのですが, このパチモンを目指します.今回は簡単のため, UIスレッドに通知を送信するDispatcherは気にしないことにして, ただの「自動的に対象配列と同期する読み取り専用配列」を作ってみましょう.そもそも「配列の変更」をC#でどのように扱っているのか調べたところ, 「ICollectionChanged」というインタフェースが提供されています.実は「ObservableCollection」はこのインタフェースを実装したクラスで, 要素数や中身に変更があった場合, 「CollectionChanged」イベントを発行します.
(興味がある人は, ObservableCollectionの「CollectionChanged」に自前のイベントを登録して, 配列要素に変更を加えてみてください)あくまでModelの「影」でいたい訳ですから, 配列要素の書き換えはご法度です.
読み取り専用の配列は「ReadonlyCollection」が標準でサポートされているので, これを継承するクラスを作ればOKです.
ただし, 読み取り専用として利用するViewModel側での運用を考えているので, 配列の各要素と配列それ自体はIDisposableを実装するクラスとします.本題です.
ModelのObservableCollectionで呼び出された「CollectionChanged」イベントに, ViewModelの配列の中身を追加・削除するラムダ式を登録してあげます.↑のソースコメントにも書いていますが, 「CollectionChangedEventArg」の種類に応じた処理を仕込んでいます.前回と今回で, MVVMインフラストラクチャがやってくれていた事を, 自分で実装しようと試みました.大雑把にまとめるとという事になります.車輪の再発明を毛嫌いせず, 自分でやってみるもんですね :)
MVVMインフラの考え方はもちろん, C#のインタフェースやイベントにも詳しくなれた気がします.


