More than 3 years have passed since last update.Lチカ編では、Visual Studio によるリモート開発環境から GPIO へ接続したLEDを点滅させるプログラムを作成しました。
今回は「.NET Lチカ編」として、同じ機能を持つプログラムを .NET Core 環境で動く C# プログラムとして作成します。本稿のすべての内容について、どのような被害・損害が生じても利用者が一切の責任を追うものとし、本稿の投稿者や記載内容の著作者は一切の責任を負わないものとします。アプリケーションプロジェクトの作成やビルドを行うには .NET Core SDK が必要です。
この SDK は64bitモードでなければ導入できませんが、現行の Raspberry Pi (Raspbian OS) は 32bit モードで動作しているため、同 SDK を利用することができません。よって、64bit モードで動作する Windows や Mac OSX などの別環境が必要となります。

【残念なお知らせ】
2018年6月現在、ARMプロセッサ向けの .NET Core 2.0 環境では、Visual Studio からのリモートデバッグ機能は正常に動作しません。
リモートデバッグ不可となれば開発効率の大幅な低下を招きます。
.NET Core 2.1 では状況が改善される可能性もありますが、現時点では Raspberry Pi 向けの .NET Core アプリケーションの作成には大きなコストが必要と言わざるを得ない状況です。
同じ回路を利用するので、詳細は Lチカ編 を参照してください。.NET Core プラットフォームで動く「コンソール アプリ」プロジェクトを作成します。自動生成された「Program.cs」は「Hello World!」と表示するだけの単純なプログラムです。
流用できる内容ではないので、Lチカ用に大幅に作り直します。1. wiringPi を利用する DllImport 宣言を用意する
/usr/include 下の「wiringPi.h」を参考に、GPIO 操作用の wiringPi ライブラリを呼び出すための DllImport 宣言を作成します。[参考サイト]
　Microsoft: ネイティブ相互運用性2. wiringPi API 用の定数値を用意する
こちらも /usr/include 下の「wiringPi.h」を参考に、必要な定数（enum/const）宣言を作成します。3. Main関数を Lチカ編 と同様の構造にする
C/C++ と C＃ は言語仕様が近い上に、呼び出す wiringPi API の名前や引数にも違いはありません。
Lチカ編 のプログラムを、ほぼそのまま流用することが可能です。下記が修正後の「Program.cs」となります。Windows 上で Visual Studio を使用している場合、「発行」機能を利用すれば Raspberry Pi 向けバイナリファイルを簡単に作成することができます。
また、必要なファイルが「publish」フォルダへすべて出力されるため、Raspberry Pi への配布作業が非常に簡単という利点もあります。出力先フォルダを変更できるので、ビルド後に手動でファイルコピーする手間も省けて良いことづくしのようにも見えますが、認証が必要な共有フォルダを指定するとアクセスエラーが発生するという問題も抱えています。開発作業に直接関係のない無用なトラブルを避けるため、ここでは「ビルド後の実行ファイルを認証が必要な共有フォルダへ格納する」ためのバッチファイルを作成し、それを Visual Studio の外部ツールとして登録・実行することにします。バッチファイルには以下の機能を組み込みます。以下が、これらの機能を組み込んだバッチファイルです。
（set PASSWORD=******** には共有フォルダのパスワードを指定してください）上記のバッチファイルをプロジェクトフォルダの直下に格納した上で、Visual Studio の外部ツールとして登録します。
ビルド構成はバッチファイルの引数で切り替えるので、必要に応じて Debug用 や Release用 の外部ツール登録を実施してください。下表は、Release 用として外部ツールを登録する場合の設定内容です。
Debug 用として設定する際は、最初の引数を "Debug" に変更してください。「準備編：共有フォルダの作成」を参照し、共有フォルダ「pi_projects」を作成してください。Visual Studio 上のプロジェクト名が発行先のフォルダ名となるので、「pi_projects」の直下に同じ名前のフォルダを作成してください。
　　発行先フォルダ名の例：　DotNetBlink1作成した外部ツールを選択し、ビルド および Raspberry Pi への配置を実行します。
[ツール] メニューに登録された外部ツールをクリックしてください。[Release/Debug 両方の外部ツールを登録したメニューの例]
Mac版の Visual Studio には  Windows版 Visual Studio の「発行」に相当する機能が無く、ビルド＆配置を行うには Windows 環境でのバッチファイルに相当するシェルスクリプトが不可欠です。
ここでは、「ビルド後の実行ファイルを共有フォルダへ格納する」ためのシェルスクリプトを作成し、それを Visual Studio の外部ツールとして登録・実行することにします。Windows 環境でのバッチファイルには共有フォルダへの接続処理が組み込みました。
しかし、Mac OSX 環境でのシェルスクリプトに同様の処理は必要ありません。
OS が標準で提供する「automount」機能を利用し、共有フォルダへのアクセスを契機に自動的に接続するように設定します。　[参考サイト]
　　OSXでSambaの共有ディスクを起動時にマウントしておく共有フォルダへの接続は、対象のフォルダへのアクセス（正確には、それをマウントしたマウントポイントへのアクセス）時に実施され、一定時間アクセスがなければ自動的に切断されます。1. マウントポイントの指定
マウント先のフォルダと設定ファイル名を「/etc/auto_master」に追記します。
　[書式]
　　{マウント先} {設定ファイル名}ファイルの末尾にマウント先の情報を追記します。
上記の例では、ルート直下に作成した「mnt」フォルダを、マウント先フォルダとしています。2. マウント情報の設定
定義ファイル（ここでは「auto_smb」）を新たに作成し、マウント情報を設定します。
　[書式]
　　{マウント名}　-fstype=snbfs,soft ://{ユーザ名}:{パスワード}@{Raspberry Piのホスト名 または IPアドレス}/{共有名}このファイルには複数のマウント情報を記述可能です。
上記の例では、認証付き共有フォルダへ接続するためのマウント情報を設定しています。
（******* には、共有フォルダへアクセスする際のパスワードを指定します）3. マウント情報の反映
ルート直下に「mnt」フォルダを作成してから、「automount」コマンドを実行してマウント情報を即時反映します。4. 共有フォルダへの接続確認
マウント先のフォルダへアクセスし、共有フォルダへアクセス可能であることを確認します。
環境にも依存しますが、初回アクセス時はフォルダの内容が表示されるまで数秒以上かかる場合があります。なお、共有フォルダを公開している Raspberry Pi がシャットダウンしている場合、下記のように一見異なる事象が発生したかのようなメッセージが表示されるので注意が必要です。シェルスクリプトには以下の機能を組み込みます。以下が、これらの機能を組み込んだシェルスクリプトです。上記のシェルスクリプトをプロジェクトフォルダの直下に格納した上で、Visual Studio の外部ツールとして登録します。
ビルド構成は Visual Studio で選択中の内容（Release/Debug）によって切り替わるので、Debug用 や Release用 という形で外部ツールを登録する必要はありません。下表は、外部ツールを登録する際の設定内容です。「準備編：共有フォルダの作成」を参照し、共有フォルダ「pi_projects」を作成してください。Visual Studio でのプロジェクト名が発行先のフォルダ名となるので、「pi_projects」の直下に同じ名前のフォルダを作成してください。
　　発行先フォルダ名の例：　DotNetBlink2作成した外部ツールを選択し、ビルド および Raspberry Pi への配置を実行します。
[ツール] メニューに登録された外部ツールをクリックしてください。[外部ツールを登録したメニューの例]
Windows/Mac OSX のどちらでビルドしても実行方法に違いはありません。
実行権(X)を付けてから、通常のプログラムやシェルスクリプトのように起動してください。Windows/Mac OSX 共に、Lチカのプログラムソースに違いはありません。
言語も C#/.NET で統一できるため、「環境・機器構成の統一」や「一定水準のスキルを持つ作業要員の確保」が容易くなるなど、業務面での大きなメリットが期待できます。その反面、現時点ではリモートデバッグをサポートしていないという重大なデメリットも存在します。
実業務で広く受け入れられるまで、あと一歩というところです。次版.NET Core 2.1 に期待しましょう。


