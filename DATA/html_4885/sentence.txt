More than 3 years have passed since last update.OpenSSLで生成した鍵（PEM）ファイルをC#で読み込んで、署名とか暗号化とかする方法の話です。RSA暗号のアルゴリズムの話はしません。なお、この記事中のコード断片は、エラー処理が省略してありますので、コピペ使用したい人は、適当にエラー処理を追加してください。また、プログラムのコピペ利用は自由にして構いませんが、自己責任でお願いします。.NETのSystem.Security.Cryptographyには、PublicKeyやPrivateKeyといった公開鍵や秘密鍵を直接扱うクラスやインターフェイスがありません。代わりにRSACryptoServiceProviderを使うのですが、このクラスには鍵をファイルから読み込むメソッドが、FromXmlString(String)というくっそ使えないメソッドしか あまり一般的ではない方法しかありません。そのためPEMから読み込むには、ちょっと面倒な手順になります。パスフレーズは外しておきます。できたファイル（private.key）は次のようなPEM形式になっています。PEMファイルを読み込み、ヘッダーとフッターを取って、Base64デコードして、DER(バイナリー形式)に変換します。（DERに変換しているなら、最初からOpenSSLでDERで出力しておけば？　と思うかもしれませんが、その通りです。しかし大抵の場合、ファイルの形式はPEMであることが多いので、PEMから読み込めるようにしておいたほうが便利だと思います）DER(バイナリー形式)にできたら、RSAの各鍵パラメータを読み込んで、RSAParametersに値を設定します。注意点としては、この処理はRSA秘密鍵限定となっていることです。Read()メソッドの中の処理が意味不明だと思いますが、処理の内容に興味がない人は、こういうことするんだと思ってください。興味ある人は、ASN.1バイナリー変換規則でルール（仕様）を見てください。本当は、汎用的なASN1Valueのようなクラスを作るほうが良いのですが、真面目に作ると結構大変なので（Qiita記事１回分になるので）、今回はRSA秘密鍵限定処理にさせてもらいました。RSA秘密鍵は数値が並んでいるだけなので、各パラメータを順にRSAParametersに設定していくだけです。RSAParametersが作れれば、あとはRSACryptoServiceProvider#ImportParameters()でパラメータを読み込んで、署名や復号をするだけです。実は、公開鍵だけ生成する、ということは出来ず、秘密鍵から取り出します…　と言うより、秘密鍵は鍵データ全部であり、公開鍵は秘密鍵の一部のデータです。鍵のパラメータ数が少ないだけで、秘密鍵とやることは一緒です。Read()メソッドの中は秘密鍵と同じです。秘密鍵と同じように、この処理はRSA公開鍵限定です。RSA公開鍵のパラメータはモジュラス(N)と公開指数(E)だけなので、この２つをRSAParametersに設定します。読み込みでエラーになる場合、PEMの中身が想定しているものと違っているかもしれません。今回読み込むPEMの中身は、こんな風になっていると想定しています。エラーになっているのはこんなファイルでしょうか？確かにこれはRSA公開鍵で正しいのですが、OpenSSLで公開鍵を生成すると、PKCS#1という汎用の公開鍵の形式になります。汎用、といっても鍵の種類と鍵自体が入っているだけですが。RSA公開鍵（ヘッダーがBEGIN RSA PUBLIC KEYとなっている）を扱いたい場合は、CreateParameter()メソッド内のsequence3がRSA公開鍵に相当するので、そこから処理すれば良いです。秘密鍵と同様、RSAParametersが作れれば、あとはRSACryptoServiceProvider#ImportParameters()でパラメータを読み込んで、署名の検証や暗号化をするだけです。鍵のデータをJSON形式で表す仕様です。JWKであっても、RSA鍵に必要なパラメータを読み込んでRSAParametersに設定し、RSACryptoServiceProvider#ImportParamerts()で取り込めばOKです。例えば、次のJWKからRSA公開鍵を取り込んでみます。JSONのパーズにはNewtonsoft.Jsonを使います。使用する鍵は、今回の例ではアルゴリズム(kty)がRSA、鍵用途(use)が署名検証用(sig)とします。（もしOpenID ConnectでIDトークンの署名検証用の公開鍵を取得するなら、IDトークンのJWTのヘッダーから、鍵ID(kid)が一致、アルゴリズム(alg)が一致、用途(use)が"sig"に一致、が鍵の選択条件になります）鍵パラメータは、n(モジュラス)とe(公開指数)の値がBase64エンコードされているので、デコードしてbyte[]をそのままRSAParametersに設定すればよいです。ただ少し面倒なのは、JWKはBase64のパディング文字(=)がstripされており、.NETのConvert.FromBase64String()は厳密にパディングを要求するという気が利かない実装になっているので、ちょっと処理を追加してやる必要があります。RSAParametersが生成できてしまえば、後は公開鍵でやったのと同じようにRSACryptoServiceProvider#ImportParamerts()で取り込んで、署名の検証と暗号化をすればOKです。本当は楕円曲線暗号の扱い方にしたかったのですが、調べ切れませんでした。次回から本気出す。日本語で読める数少ないページです。まぁ、あまりASN.1を知りたいという需要はないでしょうが。JWKはすべての鍵（公開鍵と秘密鍵、共通鍵）をJSONで表す仕様のため、秘密鍵や共通鍵など普通は外部に公開しない鍵の仕様で定められています。RSA鍵自体のフォーマットが知りたい場合。ただ後半はASN.1を知らないと、よく分からないかも。ASN.1マニアにしか需要があるとしか思えませんが。


