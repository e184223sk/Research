More than 1 year has passed since last update.　　
　　
　　
この記事は『プログラミング完全未経験からUnityでの開発現場に迎え入れてもらえた世界一の幸せ者』の記事です。そのつもりでお読みください。
　　まず、ターゲットとなるゲームオブジェクトと追尾するゲームオブジェクトを用意します。イメージとしては、ターゲットとなるゲームオブジェクトのポジションに向かって
追尾するゲームオブジェクトのポジションが一定の速度で更新(プラス・マイナス)されるといった感じです。まずはコードです。
追尾するゲームオブジェクト がthis.gameObjectです。(つまり追尾するゲームオブジェクトにAdd Componentする)今回はコルーチンで二点間の距離（x,y,z座標すべて）が0になるまで追尾させています。
【コルーチンはこちら】なので、二点間の距離を求める必要があります。
しかし、3D空間内を自由に動き回れるという前提があれば、
お互いの座標が必ずしも正の値を示すとは限らないので、二点間の距離を絶対値で求める必要があります。そこでMathf.Abs(float f)を利用しました。
また、この値は追尾するオブジェクトのポジションが変わるとともに変化するので
常にUpdate内で監視する必要があります。x,y,z座標それぞれの絶対値どれか一つでも0以上がコルーチン内のループの条件になっています。追記：2019/02/01
絶対値など使わなくてもよかった。まあこんな日もあるよね。次はこの処理の中のVector3.MoveTowardsの解説です。使い方は
追尾(移動)したいオブジェクトのポジション = Vector3.MoveTowards(追尾(移動)したいオブジェクトのポジション,ターゲットのポジション,移動速度)です。私が最初よくやりがちだったのは、this.gameObject.transform.positionを仮のVector3型変数を入れて使うことです。たとえば、このような感じ↓です。見やすくなってますが、動きません。
仮の入れ物の値が変わっただけで、動かしたいゲームオブジェクトの値は変わりません。【参考リンク】
↑ここによくわかる解説があります。もし、ターゲットが移動するプレイヤーであればプレーヤーの座標の値も変化するので、
MoveTowardsの第二引数も仮のVector3型変数に入れっぱなしで使うべきではないです。もちろん、仮の入れ物に代入して、再度代入し直すことできれいに書くことはできます。重なったらAssetStoreで適当にパクってきたフリーの爆発エフェクトのアクティブをオンにして
衝突した二つのオブジェクトのメッシュをオフにしてます。GIF画像がチカチカするやつの直し方誰か教えてください。


