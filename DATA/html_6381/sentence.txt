More than 3 years have passed since last update.NuGetで参照するだけで、ビルドプロセスに介入し自動生成機能を付加するNuGetパッケージを作成します。インターフェースから実装を生成するような黒魔術を使いたいけど、ランタイムの生成だとAOTが問題になる環境があったりして、コンパイルタイム自動生成のような代替手段を探している人を想定しています。NuGetで配布するパッケージにtargetsファイルを含めると、ビルドプロセスに介入することができます。
この機能を使用して、ライブラリ(DLL)と共にtargetsファイルとRoslynを使ったコード生成ツールを配布することで、NuGetでパッケージを参照するだけで自動生成ツールが動作するようにビルドプロセスを構成できます。インターフェースから実装を自動生成する処理サンプルを以下に用意しています。よくあるRESTクライアントライブラリのような、インターフェースだけ定義すればそこから実装を生成してくれるようなものをイメージしてもらえれば良いです。
なお、サンプルで行っているのは呼び出し内容のログ出力のみです。サンプルは以下の3プロジェクトで構成しています。サンプルでは次のようなインターフェースからコンパイルタイムで実装の自動生成を行っています。
実際に生成されるコードについては後述します。また、自動生成されたコードは次のように使用します。処理は定義したインターフェース経由で呼び出し、自動生成したコードを直接使用しない形となっています。ソース中のbuild.batを実行するとnupkgファイルが作成されます(nuget.exeにパスが通っている必要あり)。ローカルのパッケージ用フォルダ(例 C:\NuGetPackages)を作成してそこに配置し、Visual Studio上で[ツール]-[オプション]から[NuGet パッケージ マネージャー]-[パッケージ ソース]を選択、[利用可能なパッケージ ソース]そのフォルダを登録して、Example.Client.slnを開いてビルドしてください。ビルドできたらExample.Clientを実行すると、自動生成されたコードの呼び出し(ログ出力)を確認できます。自動生成ツールExample.Library.CodeGeneratorは.NET Coreのコンソールアプリとして作成しています。ソースの主要部分を抜粋すると以下になります。Roslyn(CSharpSyntaxTree)を使ってソースの解析を行い、自動生成コードで必要とするusingの一覧と、生成するクラス及びそのメンバ一覧の元になる情報を収集しています。
自動生成のための情報が収集できたら、後はGenerate()メソッドでその情報を元にソースの生成を行います。なお、サンプルではStringBuilderを使ってソースを生成していますが、本来はテンプレートエンジン等を使って処理すべきものだと考えます。自動生成されるソースの例を以下に示します。自動生成するのはメソッドのメタデータを使用したラッパーコードのみで、実際の処理はライブラリ(Engine)に委譲する形にしています。
これは、自動生成部分は簡略にしてデバッグしやすくするためです。Engineクラスの詳細は省略しますが、サンプルではメソッドのメタデータからメソッド呼び出しのログ出力(どのメソッドがどの引数で呼び出されたかについて)を行っているだけです。例えば、この部分を実際にHTTP呼び出しのようなものにすれば、実用的なソースコードの自動生成になるかと思います。targetsスクリプトは以下のような形になっています。ビルドプロセスのCoreCompile前に自動生成ツールを起動し、自動生成コードを生成してそれもコンパイル対象に含める設定にしています。IntermediateOutputPathでは自動生成するツールの出力先を設定しています。
デフォルトではobj\Debug\netcoreapp1.1\ExampleLibrary.g.csに生成するように設定しています。自動生成ツールはdotnetコマンドで実行しています。
ツールの第1引数は生成するソースの指定で、第2引数は解析対象のフォルダの指定です。
デフォルトでは、NuGetパッケージを参照したプロジェクトのフォルダ下のソースを解析して自動生成を行う設定にしています。
また、自動生成ツール実行後にでメッセージ出力を行っています。生成されたソースはの指定により、コンパイル対象に含まれるような設定にしています。これらの設定により、コンパイル前のソースの生成と、それも含めた形でのコンパイルを実現しています。ライブラリとtargetsスクリプト、自動生成ツールを配布するNuGetパッケージの定義は以下のようになります。lib\netstandard1.1に対してbuild\netstandard1.1にtargetsスクリプトを配置すると、その内容がビルドプロセスに統合されます。クライアントはNuGetパッケージを参照しているだけです。
それだけでcsprojを手で編集するといった事なしに、自動生成処理をビルドプロセスに統合することが可能になります。その他、サンプルについて何点か補足です。解析対象のフォルダにgenerator.jsonファイルが存在する場合、その設定を元に自動生成ツールが動作する形にしています。プロジェクト毎に自動生成の挙動を変更したいような場合を想定していて、解析対象フォルダの明示的指定、対象フォルダの除外指定、対象とするファイルパターンの指定ができるようにしています。これらの設定は、いずれも無駄なファイルの解析を抑止するためのもので、Example.ClientプロジェクトではNetworkフォルダ内のソースのみを自動生成の対象としているため、他のフォルダにインターフェースを作成しても処理の対象とはなりません。自動生成ツールの動きとして、生成されたコードが既に生成済みのコードと同一内容だった場合にはファイルの更新を行わないようにしています。
これは自動生成されたコードのコンパイルが都度行われるのを抑止するためのものです。自動生成機能を作成する場合は、このような処理時間短縮の仕掛けを用意した方が良いと考えます。Xamarinで黒魔術っぽいことをしたい時にどうするかと考え、調査したのが今回の内容となります。Android開発ではアノテーションプロセッサを使いまくっているわけで、Xamarinでもコンパイルタイムの自動生成を活用しまくっても良いよね(・ω・)？


