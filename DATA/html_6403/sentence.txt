More than 3 years have passed since last update.パート2では、パート1で作成したマスタデータをゲーム上で扱えるようにします。
ざっくりとした手順は下記のとおりです。データは、JSONのフォーマットになっているので「MiniJSON」を用いて読み込みます。
※使い方は後述で説明いたします。
とりえあずUnityのAssetsフォルダにインポートしましょう。
（Pluginsなど適当なフォルダを作るといいかもです）まずはJSON形式のデータを読み込みます。
さきほどインポートしたMiniJSONを試してみます。単純に、データを読み込んだ後、MiniJSONのDeserializeを読んでみました。
（読み込めないときはパスや、文字コードを見直してみてください）読み込んだデータはリスト型で格納されています。
パート1で登録した件数が正しくとれているかデバッグで確認しておきましょう。
また、table[0] にアクセスすることで、Dungeon.xlsmのカラムがはいっていると思います。
これも値が正しいか確認しておくと良いと思います。データの値を扱えるようにしていきます。
クラスを用意して、マスタデータのカラムと同じ型の変数を準備しましょう。
ダンジョンのマスタデータ（Dungeon.xlsm）ならIDと名前が必要なので、下記のようになると思います。パート1でも見ましたが、JSONのデータはいくつものデータが配列に格納されています。
そして、1つあたりのデータはカラムの名前と値が対になっております。
"id" : "10001"
のような感じですね。
MiniJSONを用いることにより、これらは下記のように取得できます。これで各変数にマスタデータの値を格納できるようになりました！他の量産したマスタデータクラスでDeserialize関数は毎回用いるので、インターフェースを用意しておきましょう。
これでマスタデータクラスは必ずDeserializeを所持します。
（後ほどの初期化処理で便利です）上記のようなインターフェースを用意しました。それを継承したマスタデータのインターフェースも用意します。
これを各マスタデータクラスに継承しておきましょう。完成したDungeonクラスのサンプルです。必要なマスタデータは同じようにIMasterData.csを継承させて量産すれば大丈夫です。ここまででファイルの読み込みと、クラスへの格納が可能になりました。
それらを組み合わせて、指定したマスタデータを取得する関数を作成します。まずはざっくりとした関数のイメージです。ジェネリックなマスタデータの型を指定し、そのデータを取得する関数を用意します。また、先程インターフェース（IMasterData.cs）を継承しましたので、where句で型の制約条件を指定しておきます。
後で説明がありますが、引数なしのコンストラクタをnewすると怒られるのでnewの制約も加えます。では、1つ1つのデータに対して、先程のDeserializeインターフェースを呼び出し、カラムの値を初期化していきます。
（上記関数の3番目の箇所です。）
これでクラスを増やした分毎回読み込み処理を書かずに量産できます！最後にいままでの処理を組み合わせたサンプルコードを記載しておきます。以上でマスタデータ取得関数ができました！
余力があればUnityのコルーチンやasync/awaitで非同期な処理に拡張したり、
Promiseパターンなどで例外処理を入れたりしておくと幸せになれるかもしれません。
（ここで色々するとアレなのでいつか取り扱いたいです…！）長くなってしまってすみません。
次回はいよいよダンジョンを生成する予定です。（予定です！）
お疲れ様でした！いままでの処理をもうちょっと便利になるように拡張してみます。
1. パース処理を拡張する
2. 指定したIDのデータだけを取得する
3. マスタデータをキャッシュして処理を高速化してみる
上記について例を記載してみました。各マスタデータクラスにて、Deserialize関数内でParse処理を毎回書くのが億劫なので、簡単な拡張メソッドを用意してみました。Dungeon.csも下記のように変更しました。こちらのほうがスッキリしていると思います。先ほどの関数は全てのマスタデータを取得しておりましたので、IDが一致したものだけ取得するバージョンも用意してみました。
指定したIDでデータをフィルタリングして渡すイメージです。IMasterData.csを拡張します。全マスタデータクラスにIDを持たせます。続いて、フィルタリング処理を作成します。単純な実装ですが、できました。
各マスタデータクラスは必ずIdを所持しますので、ジェネリックな型での検索が可能です。上記関数を用いまして、GetMasterData関数を拡張します。こうしてみました。
欲しいデータだけの取得や、他のマスタデータからの参照が容易になると思います。
（DungeonFloorからDungeonIdで該当のDungeonを検索など）毎回テキストデータをパースしているので、2回以上呼び出された場合にキャッシュしておいたデータを渡して、ある程度効率よくしておきます。以下は単純な例です。上記のようにキャッシュ処理を追加してみました。以上、余談でした！


