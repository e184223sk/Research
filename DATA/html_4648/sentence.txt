More than 1 year has passed since last update.C#にはBigIntegerという多倍長整数型が扱えるライブラリがあります。
大学の授業の延長でBigIntegerを使ってRSA暗号のアルゴリズムを書く機会があったのでいろいろ書いてみました。
今回は数学系クラスということで、暗号化や復号や鍵生成等は省きます。
というわけでメモ程度にまとめようと思います。
なお、数学の難しいことはよくわからないのでこの記事では扱いません。なお、タプル型を使っているので、C#7以上の環境が必要になります。[github]https://github.com/euglenach/CsharpBigInteger-Math/blob/master/MathB.cs素数判定いろいろ - フェルマーテスト・ミラーラビン素数判定法
拡張ユークリッドの互除法 〜 一次不定方程式 ax + by = c の解き方 〜
http://smdn.jp/programming/netfx/mathematics/2_biginteger/これは、BigIntegerクラスのメソッドにすでに実装されているのを知らずに作ったものです。
RSAアルゴリズムの中でちょくちょく使いました。最大公約数はユークリッドの互除法で求めています。
SwapNumメソッドは2数を入れ替えます。秘密鍵を生成する計算で使いました
最小公倍数は、最大公約数のアルゴリズムを使えば容易に求めることができます。これも、BigIntegerクラスのメソッドにすでに実装されているのを知らずに作ったものです。SpecialLIEメソッドは、
こちらの記事のアルゴリズムをお借りさせていただき、
とても奇麗なコードだったのでそれにあわせてこのメソッドを作りました。(x=?+?t),(y=?+?t)という二つの値をstring型で返します。
正直このやり方で良かったのか、と今でも疑念が残ってますが、作ったソフトウェアの仕様上問題なかったので放置してます。
このメソッドはなにかの計算に使うことはなかったので。一次合同式は、総当たりで1ずつ判定しています。
後述しますが、これだと問題がありますが一旦置いておきます。今回のメインになるところです。
目標としては、100桁の素数を生成することでした。
やり方は、ランダムな100桁の数字を素数かどうか判定し、それを繰り返すことで100桁の素数を取得します。先ほどの一次合同式の計算方法では、100桁の素数を使うのでさすがにコンピュータがパンクしちゃいます。
なので実際は別の方法で実装しました。とりあえずここでは無視します。では素数を生成していきます。まずは乱数を生成します。ランダムな数字を100個生成し数値に変換する方法です。次は、a～bまでの乱数を取得する、みたいなメソッドです。桁数を決める→その桁数の乱数を生成という実装の仕方にしましたがいまいち腑に落ちませんでした。(使えてるしいいや！)GetDigitメソッドはBigInteger型の桁数を調べます。素数判定はこちらの記事を参考(ほぼコピペ)にして作りました。最後に素数生成のメソッドです引数に桁数を入れることで素数を生成します。
100桁であれば、1秒もかからず素数を取得できました。なんか変なとこがあれば優しく教えてください。拙い文章でしたが、少しでも役に立てれば幸いです。
コードをまとめたものはgithubをご覧ください。
閲覧ありがとうございました。


