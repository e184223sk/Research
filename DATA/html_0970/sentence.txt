More than 1 year has passed since last update.これは「C#によるPOS開発入門（的な）」と称して連載している記事の1つです。他はこちらSystem.Drawing.Bitmapを渡すとサーマルプリンターで印刷してくれるPrintMemoryBitmapメソッドというものがあります。Graphicsを使って生成した画像を渡すことが出来るのは便利ですね。……と思いきや、なんとこのPrintMemoryBitmapメソッド、Graphicsで汚染されたBitmapは受け付けてくれないのです。Graphicsが使えないとこのメソッドの魅力が大幅に減ってしまいます。
そこで、無理やりPrintMemoryBitmapメソッドにGraphics由来の画像を突っ込む方法を調べました。Microsoftが定めた、POS機器を扱うための共通規格です。機器メーカーにPOS for .NETを通じて動作させるドライバーを作らせることで、使用する機器を他メーカー製のものに入れ替えても今までのコードをそのまま使えるのがポイントです。
POS for .NETによるPOS機器の制御の基礎は別の記事にまとめました。良ければそちらも参考にして下さい。以下の全てのサンプルコードの前には、以下のコードがあるものとします。これだと例外を吐いて駄目なんですね。Bitmapを複製し、新しいものを渡してみます。これでも駄目です。new Bitmap("fileName")したままのものを渡すと正常に動作するので、一度生成したBitmapをファイルとして保存し、それを読み込み直せば動くのでは？と思いやってみました。（コードはありません）勿論これで動くことは動きます。が、一度ファイルにするのは……なんかやだ。パフォーマンスの問題もありますし、何よりスマートじゃない。new Bitmap("fileName")したままのものを渡すと正常に動作することから、元のBitmapからbmp形式のファイルのバイナリを生成し、それをnew Bitmap()の引数に渡すと上手くいくんじゃないかと予想しました。
そこで、自前でbmp形式のファイルのヘッダーバイナリを作成し、そこに元のBitmapのビットマップ部分をLockBitsで取得したものをくっつけて渡してみます。これだと上手くいきました。かなり抜け道的な解法ですが……まあ動いたし、そこまで見た目も汚くないので良いでしょう(?)正直私の解決方法も綺麗とは言い難いです。もしもっと良い方法をご存知でしたら教えて頂けると嬉しいです。
元々C++等向けだったのを.NET向けに実装したものなので、この辺りの仕様がこうなっているのは理解出来ますが、やはり使いづらいです。この記事以外にもPOS開発関連の記事を投稿しています。もし良ければこちらからどうぞ。


