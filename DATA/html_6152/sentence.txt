More than 3 years have passed since last update.VisualStudioを標準で生成する認証処理では、認証に使用するユーザー・テーブルのIDがstring型になります。
開発しているシステムではstring型では都合が悪いので認証処理をカスタマイズしました。認証処理のカスタマイズは次の記事が参考になります。
ASP.NET Identityで独自の認証処理を行うユーザー情報の登録、編集、削除処理を行うUserStoreクラス, ユーザー管理を行うUserManagerクラス、
ロール情報の登録、編集、削除処理を行うRoleStoreクラス, ロール管理を行うRoleManagerクラスを独自で作成したユーザー・テーブル(エンティティ)に合わせて実装します。ユーザーのロールはSingInした時に、正常に認証処理のカスタマイズができていればCookieに保存されます。
[Authorize(Roles="XXXX")]をコントローラー内のアクション名の前に書いておくと、
ソフトウェアは、アクションが実行される前にCookieを参照しCookie内に該当するロールが存在する場合、そのアクションを実行します。ロールXXXXのユーザーでログインして、[Authorize(Roles="XXXX")]を適用したアクションにアクセスすると
ログイン画面に飛ばされてしまいました。
(独自でアクション・フィルターを実装？アクションが実行される前に毎回DBアクセス？
ありえん・・なんてことを考えていました。)上記のようにClaimを追加してみたところ、先程までログイン画面に飛ばされてしまった画面にアクセスできるようになりました。
(なるほど、Claim情報はCookieに保存されるのかと納得しました。)Identityでロールを管理する仕組みが用意されているのだから、自動でClaimにロールが登録されるようになってるだろうと、Identityライブラリのソースコードを読んでみました。UserManagerクラスにはSupportsUserRoleフラグが定義されています。
IUserRoleStoreインターフェースを継承してUserStoreクラスが作成されている場合にSupportsUserRoleフラグがTrueになります。SupportsUserRoleがフラグがTrueの場合に、SignIn処理が実行されるとIdentityライブラリ内でロールをClaimに追加する処理が実行されます。UserStoreクラスを実装する時に、IUserRoleStoreインターフェースとIRoleStoreインターフェースを継承していました。
IRoleStoreインターフェースはRoleStoreクラスを実装するためのインターフェースです。
IRoleStoreインターフェースを継承していたために、IUserRoleStoreインターフェースを継承しているか判定する処理で、IUserRoleStoreインターフェースは継承されていないと判定されていました。
従って、UserManagerクラスのSupportsUserRoleフラグがFalseになり、SignIn時にロールがClaimに追加されていませんでした。ライブラリの中身を追わないと実装に使えないライブラリって・・・


