More than 1 year has passed since last update.複雑な SQL を発行する場合、LINQ to Entities で頑張るよりも、
生の SQL をそのまま書きたい場合があります。
EF Core で生SQLクエリを流すにはFromSql拡張メソッドを使用します。生のクエリを流す場合は SQL インジェクションの対策が必須です。
実際に環境を構築してSQL インジェクションを発生させ、その対策をしてみます。モデルはブログの投稿とします。データベースコンテキストでロガーや DB 接続を設定します。
今回は最初からシードデータを持たせておきます。以下のコマンドでマイグレーションファイルをスキャフォールディングし、データベースを生成します。ブログサービスで公開されている投稿を一覧を取得する処理があったとします。
以下の例では、公開されている記事をカテゴリで検索する SQL を文字列結合で組み立てています。dotnet runすると以下のログが流れます。
条件通り、公開記事でカテゴリが C# のレコードが取得できました。それでは SQL インジェクションを実際に起こしてみます。
検索条件として1' or 1 = 1 --を渡します。dotnet runで動かしてみると非公開記事まで取得できてしまいました。／(^o^)＼1' or 1 = 1 --が検索条件として渡された場合、ログを確認すると以下の SQL が発行されていました。まず、1 = 1は常に真となります。
また、-- 以降のand IsPrivate = 0はコメントとして無視されます。
1 = 1は'or'で指定されているため、Category = '1'は無視されます。
結果、テーブルのすべてのレコードが取得できてしまいます。SQLにパラメータを渡すときは文字列結合を使ってはいけません。
今まで触れませんでしたが、今どきの Visual Studio は賢いので警告を出しています。

ログにも警告が出ています。
一般的に、シングルクォートなどの特定の文字列をエスケープする対策が知られていますが、EF Core には対策が用意されています。DbParameter・プレースホルダ・文字列補完式を使うと、パラメータ化クエリに置き換えてくれます。直感的で、IDE の支援も受けやすい文字列補間式がよさそうです。文字列補間式でなぜSQL インジェクションが防げるかちょっと不思議です。
文字列結合した場合と同じ SQL が発行される気がします。Stack Over Flow でも同じ疑問を持った方がいたようで、回答を読むとFromSqlの引数は文字列でなくFormattableStringで、SqlParameterに置き換えられるそうです。
Stack over flow の質問と回答
RelationalQueryableExtensions.FromSqlSQL インジェクションを起こすコードを文字列補完式で置き換えてdotnet runしてみます。SQL を見るとのパラメータに置き換えられています。不正なクエリは発行されなくなりました。
今回の場合、条件に一致するレコードはないので一軒も取得されません。検索条件のカテゴリにC#を指定すると正常に取得できます。この記事のコードは以下のリポジトリに置いてあります。
https://github.com/sano-suguru/RawQueryスキルアップを目指して毎日猛勉強中です。
エンジニアやエンジニア志望の方と繋がりたいです( ´∀`)
のさ@nosa_programmer


