More than 1 year has passed since last update.この記事はC# Advent Calendar 2017の14日目の記事です。
n番煎じですが、INotifyPropertyChangedの実装について、今さらながらにまとめてみます。
ネットで調べると既に数限りない実装方法の説明がありますが、それ故に初心者の方は結局どれがいいんだがわかんねー、となることも多いと思います。
そこで実行結果は全て同じにした上で、C#3~C#7記法、さらにライブラリの継承やAOPなどちょっと変わったやつまで含めて、色々な方法で実装して独断と偏見で比較します。まず最初に全部で共通の実行結果について説明します。
TextBoxとTextBlockが並べてあるだけです。上のTextBoxを変更すると、下のTextBlockに反映されます。なお、Jは発音しませんが必要です。(参考画像）ViewはReactiveProperty以外は全て同じです。
ReactivePropertyのみ、プロパティ名に.Valueを付けます。
コードビハインドは何も書いていないので省略します。ViewModelでは各スタイルで書いたPersonクラスをプロパティとして公開しています。1つのクラスで閉じているパターンです。
INotifyPropertyChangedの基本的な解説ではここから始めるのが多いですが、プロダクトコードでは使われることは多くないかも？
C#のバージョンごとに書いていきます。長いです。
変更通知するプロパティ名が文字列なのでVisualStudioの名前変更で解決するのが難しいです。メリット（◯）／デメリット（✖）
◯ C#3で書ける
◯ 継承の必要なし
✖ 変更通知するプロパティ名の指定が文字列
✖ 長い
✖ 個別のクラスごとに実装する必要があるC#4は特に変化ないので、飛ばします。
長さはC#3と変わらないです。
CallerMemberNameを使用して、呼び出し元プロパティ名だけは省略できます。メリット（◯）／デメリット（✖）
◯ C#5で書ける
◯ 継承の必要なし
✖ 変更通知するプロパティ名の指定が一部文字列
✖ 長い
✖ 個別のクラスごとに実装する必要がある参考
C# 5.0 の新機能 - C# によるプログラミング入門 | ++C++; // 未確認飛行 Cnameof演算子のおかげでプロパティ名を文字列で指定するのを回避できます。
他にもNull条件演算子やGet-Onlyプロパティのラムダ式化などで、記述が簡潔になっています。メリット（◯）／デメリット（✖）
◯ C#6で書ける
◯ 継承の必要なし
◯ C#5版よりは短い
✖ それでも長い
✖ 個別のクラスごとに実装する必要がある参考
C# 6 の新機能 - C# によるプログラミング入門 | ++C++; // 未確認飛行 C
[C# / WPF] 最新のC# 6.0でMVVMパターンを実装する
C#6.0での実装パターンまとめC#6とほとんど同じです。
プロパティのGet部分をラムダ式にできます。メリット（◯）／デメリット（✖）
◯ 継承の必要なし
◯ C#5版よりは短い
✖ それでも長い
✖ 個別のクラスごとに実装する必要がある
✖ C#7が必要参考
expression-bodied な関数  C# によるプログラミング入門 | ++C++; // 未確認飛行 CC#6のコードスニペットはありましたが、C#7版は無かったので置いておきます。
NotifyProperty_CSharp7.snippet -GitHubショートカットは「propn」です。式木を使えば、C#3でも文字列を使わずプロパティ名を指定できます。
C#3版よりも更に長くなりますが、Typoなどを防げるのでより安全です。
nameof演算子が使えないC#5までは有効な方法です。メリット（◯）／デメリット（✖）
◯ 継承の必要なし
◯ C#3で書ける
✖ さらに長い
✖ 個別のクラスごとに実装する必要がある参考
https://tpodolak.com/blog/2014/01/19/implementing-inotifypropertychanged-without-lambda-expressions-and-magic-strings/
よねやんさんに教えていただきました。
情報ありがとうございます。これ以降は基本的にC#7の記法で書きますが、C#3などでも書けます。毎回同じのを書くのは面倒くさい場合、INotifyPropertyChangedを実装した基底ViewModel的なものを作り、それを継承します。ついでに同値判定部分とプロパティ変更イベント発行を同時にやるメソッドを定義しました。注意点として、多重継承を認めないというC#の仕様上、必ずこのMyViewModelクラスを継承する必要があるというのは状況によっては大きな制約になる場合があります。メリット（◯）／デメリット（✖）
◯ （子クラスは）けっこう短い
✖ 継承が必要
✖ 基底クラスが別に必要今までのプロパティは基本的にバッキングフィールドが別に必要でした。
このバッキングフィールドを無くすために、基底クラスに代わりの値の置き場所を作り、取得・変更のメソッドを公開します。
上記独自ViewModelをさらに継承して基底クラスを作ります。これにより、以下の2つの利点があります。
・バッキングフィールドがいらない
・クラス内部からの変更であっても必ずset句を通る
特に後者の点は、誤ってクラス内部からプロパティではなくバッキングフィールドを直接変更して通知が飛ばないことによる混乱を招くのを防ぐことができます。
ただし取得・変更時にアンボクシングを伴う操作を行っているので、パフォーマンスは少し落ちます。また注意点として、Getterより先にSetterが呼ばれると指定した初期値（GetPropertyValue(initialValue:...）が無視されます。メリット（◯）／デメリット（✖）
◯ （子クラスは）けっこう短い
◯  バッキングフィールドが不要
✖ 継承が必要
✖ 基底クラスが別に必要
✖ アンボクシングが発生する参考：
INotifyPropertyChanged (2 of 3) – without the backing fields継承をしたくない、だけど毎回同じコードを書くのは嫌だ、という時は拡張メソッドで解決できます。
PropertyChangedEventHandler(INotifyPropertyChangedではなく)に対する拡張メソッドを作ります。
(2018/02/21更新 プロパティ名が正しく伝わらないバグ修正）メリット（◯）／デメリット（✖）
◯ 継承の必要なし
◯ （本体クラスは）けっこう短い
✖ 拡張メソッドを含んだ静的クラスが別に必要参考
イケテルINotifyPropertyChangedの実装の改善 - かずきのBlog@hatenaMvvmLightなど、他のライブラリのViewModelBaseを継承して作るともっと簡潔に書けます。独自のViewModelクラスの代わりにライブラリ内の基底クラスを継承しています。
独自ViewModel継承版と同様にSet～部分に同値判定や呼び出し元プロパティ通知などが含まれています。メリット（◯）／デメリット（✖）
◯ けっこう短い
✖ 継承が必要
✖ MVVMライブラリの導入が必要MVVMライブラリの1つReactivePropertyを使用する場合、Prism等と異なり基底クラスの継承は必要ありません。かなり雰囲気が変わりますね。
Personクラスの代わりに、ReactiveProperty自体がINotifyPropertyChangedを実装しています。
そのため、基底クラスもINotifyPropertyChanged自体も継承が必要がありません。
ただしこれのみViewを変更する必要があり、プロパティ名の後に.Valueが必要です。またReactivePropertyの特徴として、プロパティの変更をObservableなStreamとして扱え、ReactiveExtensionの多様な拡張メソッド群を使用できます。
上記コードでもNameプロパティの変更Streamを加工したものをReadOnlyReactivePropertyに変換、それをFullNameプロパティとして公開しています。
同じ実行結果であっても、その内部の動き他の方式とは異なります。メリット（◯）／デメリット（✖）
◯ 継承は必要ない
◯ 短い、単純なプロパティであれば1行で書ける
◯ ReactiveExtensionsの力で色々できる
◯ バッキングフィールドが不要
✖ MVVMライブラリの導入が必要
✖ 他とは雰囲気が違うので慣れが必要
✖ View側に.Valueを追加する必要がある参考
MVVMをリアクティブプログラミングで快適にReactivePropertyオーバービュー - かずきのBlog@hatena2017/12/31追記
WPFでDataContextに指定する場合、INotifyPropertyChangedを継承していないとメモリーリークするそうです。
http://mobile.aridai.net/article/?p=15AOP（アスペクト指向プログラミング）ライブラリのFody(PropertyChanged.Fody)を使用すると、こんな何の通知も書いていないクラスが上記コードと同じ動きをします。出力ウインドウで何やらやっているのが見て取れます。かなり黒魔術感ありますが、コードはめっさ簡潔。
注意点として、プロジェクトにFodyを導入していると、すべてのINotifyPropertyChangedを実装したクラスが自動で加工されます。
Fodyで加工してほしくない場合はDoNotNotify属性を付与する必要があります。ブレークポイントで止めたりすると書いた覚えのないメソッドがあったりして面白い。
IL書くのは怖くない！
ILSpyで中間言語（IL）からC#に再変換して、読みやすくしたのが以下です。
やはりコンパイル時にINotifyPropertyChangedを実装しています。◯ 継承は必要ない
◯ 短い、ダントツ短い
✖ Fodyライブラリの導入が必要
✖ 実際にどう実装されたかはILから読み直さないとわからない参考
Fody-PropertyChanged
C# の素晴らしさを語る会 で喋ってきました。 - 亀岡的プログラマ日記いかがでしたでしょうか。思いつく限りのINotifyPropertyChanged実装のパターンを並べてみました。
どれを導入するべきかの判断材料として、このアクティビティ図を参考にしてください。他にもこんなパターンもあるぜ！というのがあったら教えてください。C#の開発予定を見る限り、特にINotifyPropertyChanged実装に関わる機能は無さそう？
ただCommunity内で議論自体は上がっていて、こんなのが提案されていたりします。fieldをキーワードとしてバッキングフィールドの代わりに使うようです。
独自ViewModel継承 バッキングフィールド無し版と同様のメリットがあり、
うっかりクラス内部からバッキングフィールドを変更して通知が飛ばないことで混乱した経験がある身としては使ってみたくなります。参考
https://github.com/dotnet/csharplang/issues/140岩永さんいわく、C#デザインチームはやるつもり無かったけど、あまりに要望が来るので(笑)、検討しているそうです。C# vNext 始動！ Visual Studio 16.6 Preview 2 / .NET 5 Preview 2 - YouTube 1:04:19から今回の完全なソースコードをGithubにおいておきます。
https://github.com/soi013/INotifyPropertyChangedImplementationsVisualStudio2017
.NET Framework 4.7
MvvmLight 5.3.0
ReactiveProperty 4.2.0
Fody 2.4.1
PropertyChanged.Fody 2.2.5


