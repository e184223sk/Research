More than 1 year has passed since last update.Instantiateなどで生成したコンポーネントを、その場ですぐに初期化する場合、大きく分けて2つの方法があると思います。どちらにもそれぞれのメリットがあります。
例えばAwakeはいつ呼ばれるのか単純明快ですし、生成側とコンポーネントが依存しない造りにできます。
一方メソッドを作るのなら引数を自由に変えられますし、Unity独特の仕様に依存しない造りにできます。
パフォーマンスも、InstantiateやAddComponentそれそのものに比べたら差はないも同然です。というわけで、引数もなくて同じ所で呼ぶなら、様式以外は大差ない――――と思っていました。その違いは例外処理にありました。
次の2つのコードは、上で説明した2パターンを再現したものの組み合わせです。
Managerを配置すると、1ではGame Startに到達していますが、2では到達しませんでした。C#の仕様上は、2のような挙動をするはずです。
つまりは「1は例外が起きたはずなのに止まっていない」ということです。
きっとUnityがAwakeを呼ぶとき何かしているに違いありません。
例ではAddComponentですが、もちろんInstantiate中に呼ばれるAwakeでも同じです。試しにtryで囲ってみました。この他の部分はさっきと同じです。
なんと前者は例外をキャッチできません。囲ってない状態と全く同じです。
別に、初期化が遅れて実行されているわけではないということは、ログからもスタックトレースからもわかりますが……。これは「全てのメッセージは最初からtry-catchで囲まれている」ということか、もしくは同様の何かでしょう。プログラムを書くときにはわざわざ例外が起きたときの止まり方まで意識はしないでしょうが、もしリリースビルドで明らかに例外が起きているっぽい状態に出くわしたら、何が動いていて何が止まったかから原因を特定するような時には役立つ知識かもしれません。それにしても、UpdateのようにPlayerLoopから呼ばれるメッセージは当然こういう仕組みなんだろうとは思っていましたが、Awakeなどが途中で呼び出される場合でも同じというのは意外でした。


