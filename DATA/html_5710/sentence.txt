More than 3 years have passed since last update.ドラッグでシークできるようになっています。
今回は凝ったことはしないのでWinFormsを使います。自分でゴリゴリ書くこともできますが、簡単に扱えるように設計された素晴らしいライブラリが存在するのでそちらを使います。NAudio
NAudio.WaveFormRendererパッケージマネージャーコンソールでInstall-Package NAudio -Version 1.8.4と入力するか管理画面から検索してインストールします。波形処理部分が分離されているので別途インストールします。こちらはNuGetが準備されていないので、自分のパソコンに落としてWaveFormRendererLibフォルダの中身をプロジェクトに追加します。・ playButton　という名のPictureBox
・ pictureBox1　黒い波形を表示する
・ pictureBox2　オレンジの波形を表示する。pictureBox1と同じサイズにして、上に重ねておく
・label1　タイトル
・label2　再生位置の表示
・label3　総再生時間の表示
・openToolStripMenuItem　音声ファイルを開くのに使用
・Timer1　pictureBox2の幅を再生位置に応じて変更黒とオレンジの波形を２つ準備します。そして再生位置に合わせてオレンジの波形を重ねていきます。
なお幅を変更しても画像がスケーリングされないようにpictureBox1,2のBackgrounImageLayoutはNoneにしておいてください。オブジェクトの破棄や例外処理は実装していません。ファイルを選択した後、オレンジと黒の波形をレンダリングしpictureBoxに画像を設定します。
その後、Timerを使って、pictureBox2の幅を変化させ、左からオレンジの波形を再生位置まで重ねます。
また、pictureBox1,2には共通のMouseDown,Move,Upイベントを設定し、そこでシーク処理をします。レンダラに渡す設定を生成します。
ライブラリにはいくつかのテンプレートがあり、今回はSoundCloudBlockWaveFormを使用しています。ほかのテンプレートはGitHubのREADMEを参照してください。また、自分で作ることもできます（後述）。WaveFormRendererは名前の通り波形画像を生成するクラスです。Renderメソッドを実行するとImageを返します。PeakProviderは音声ファイルから、時間毎に描画するバーの高さを計算するクラスです。
今回はAveragePeakProviderを使用しています。コンストラクタの引数には倍率を指定します。プレーヤーの状態によって分岐処理をしています。今後必要になる値を求めておきます。
今回使用するライブラリには、曲の長さを取得したりシークをする際などに秒単位は使えず、バイト単位でしか操作できないっぽいので、まず１秒あたりのバイト数を求めておきます。音声ファイルの仕組みがわかっていると理解は容易かと思います。具体的には
audioFile.WaveFormat.BitsPerSample / 8　で１サンプルあたりのバイト数を
それに１秒あたりのサンプル数とチャンネル数をかけて算出しています。曲の長さ（秒）を計算します。全体の長さを１秒あたりのバイト数で割ります。再生、一時停止とボタンの画像を差し替えています。現在の再生位置はストリームの位置（バイト単位）で取得されるので秒数に変換したのち、表示しています。
そして、再生位置までオレンジ波形を上から重ねます。
ドラッグしてシークできるようにしてあるので、ドラッグ中は変更しないようにします。MouseMoveでフラグがtrueのときのみオレンジ波形の幅を変更しています。
MouseUpでカーソルの座標から曲の位置を計算してシークしています。
本家のようなホバー時のエフェクトは実装していませんがそれっぽいものができました。
画像を生成する処理が重いため、音声ファイル読み込み後に少し固まります。別スレッドで処理するといいかもしれません。本題から外れますが、今後カスタマイズするかもしれないのでメモとして残しておきます。
①　PeakProviderを初期化します。その際にファイル名から生成したISampleProvider(音声ファイルのストリーム)を渡します。
また何バイトごとにストリームを処理するかの値も渡します。
(何秒を1ブロックとしてバーの高さを計算するのかの値を渡します。)
②　描画処理の本体があるstaticメソッドを呼びます。①で生成したPeakProviderとレンダリング設定を渡します。
③　GetNextPeakを呼び出します。
④　②で指定した範囲の音声ストリームの音の強さを処理して、上に伸びるバーと下に伸びるバーの長さをそれぞれ求めます。
作品で使用したAveragePeakProviderは範囲内の音の強さを平均化してバーの長さとしています。
⑤　値を返します。
⑥　返された値を使用してバーを描画します。①でしらっと音声のストリームを渡しています。当たり前ですが、このストリームはデコード済みのものです。NAudioのAudioFileReaderは自前のデコーダやWindowsのMediaFoundationを利用して圧縮音源をデコードしてくれるすぐれものです。⑥をカスタマイズすることで自分で描画をすることができます。音声処理は、OpenCV用いての画像処理といった直感的なものに比べ、目に見えにくくとっつきにくい部分があると思います。しかし、内部の処理を覗いてみるとこちらも直感的に操作できることが分かった(気がした)ので、音声処理に挑戦する良いきっかけになったと思います。あと初投稿なので記事を書く大変さもわかりました。
では、最後までご覧下さりありがとうございました。


