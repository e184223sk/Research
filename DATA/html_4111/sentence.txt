C#でWindowsのソフトウェアを開発しているとWindows APIを呼び出すためによく使うDllImport属性。意外と適当に書いても呼び出せたりするけど、なるべく丁寧に書いてあげたくなるのが開発者の心情というもの。と言うわけでDllImportするときの個人的なメモ。昨今のVisual Studioでは、DllImportの定義は「NativeMethods」「SafeNativeMethods」「UnsafeNativeMethods」という名称のクラス内に定義しないとコード分析でCA1060の警告が出てくる。
クラスの中に定義したクラスでも良いので、こんな感じにする。システムに影響を与える可能性があればUnsafeで、そうじゃなければSafeらしいけど、どっちか悩むやつも結構あるので大人しくNativeMethodsで良いような気がする。Windows APIで頻出するBOOL型。書く意味は薄そうだけど、ちゃんと定義してあげる。「return:」って、BOOLでしか使ったことがない。Windows APIに文字列を渡すときは、UnmanagedType.LPWStrを付ける。
そして文字列や構造体を渡すときはIn属性を書く。文字コードを明示しないとトラブルの元。今どきならUnicode前提で良い気がする。Windows APIから文字列を受け取るときは、StringBuilderクラスを使うのがベターらしい。
文字列や構造体を受け取るときはOut属性を書く。StringBuilder → stringの変換が発生するのは気になる・・・
一応もし取得する文字数が分かる場合は、stringに直接突っ込むことも出来なくはない模様。これなら直接string型で文字列が受け取れる。果たしてこの実装はアリなのか？Windows APIだとdefineで定義された定数を渡すことがある。
constで定義しているサンプルをよく見掛けるけど、enumの方がインテリセンスにも出てきて便利だと思う。Windows APIで構造体が出てきたときに、単純にstructで定義して、refで渡すサンプルをよく見掛けるけど、本当にそれで良いのか一考の余地がある。クラスで定義すると参照型になるので、refもoutも付けずにポインタが渡せる。
構造体のポインタをやり取りするときは、とりあえずUnmanagedType.LPStruct。classなら初期化子が使えるので、メンバ変数に初期値を仕込める。
またrefやoutを付けるとnullが指定できないので、オプションパラメータなどにnullを渡したいときにclassにしておくとnullにできるメリットも。
それにrefやoutが無ければ、引数の中で直接newして渡すこともできる。C# 7.0からoutで呼び出すときに、変数の宣言も同時にできるようになったので、構造体で結果を受け取る系のAPIはoutにした方がスッキリすることも。outの呼び出しと変数の宣言が同時にできると知ったときの感動たるや・・・
ちなみにRECTやPOINTは、.NetのRectangleやPointと互換性があるので、System.Drawingを参照設定しているなら使える。たまに出てくるGUID構造体は、System.Guid構造体がそのまま使える。
しかしポインタで渡すときにrefを付けると、readonlyが付けられない問題・・・refを付けずにUnmanagedType.LPStructで定義すると、ポインタとして渡してくれる。~~
【追記：2019/11/6】
コメントにてC#7.2以降では、in修飾子が使えるとの情報をいただきました。
in パラメーター修飾子 (C# リファレンス)inのときはref/outみたいに呼び出し側に修飾子を書く必要なし？
まだまだ知らない機能がたくさん・・・
~~かなり特殊なケースだけど稀にあるみたい。
こんなやつ。dbcc_name[1]と言いつつ、実際にはメモリ上に文字列が繋がって存在する。
最大文字サイズが分かっている場合は、UnmanagedType.ByValTStrで対応可能。これならMarshal.PtrToStructureなどで受け取り可能。
~~
【追記：2018/12/27】
pinvoke.netに載ってるDEV_BROADCAST_DEVICEINTERFACE構造体の定義に「SizeConst = 255」って書いてあるから使ったけど、そもそもdbcc_nameが最大255文字って根拠がない気がする・・・。
~~問題は可変長。
SetupDiGetDeviceInterfaceDetail関数でSP_DEVICE_INTERFACE_DETAIL_DATA構造体を受け取りたいときに困った・・・。
C++なら↓みたいな感じで受け取れる。色々と悩んだ末、どうにもならないので無理矢理・・・構造体を定義せずに直接受け取ってしまう。
綺麗ではないけど１番シンプルで分かりやすい。IntPtrでも問題なく動くけど、HandleRefを使う方が丁寧らしい。CloseHandle関数などで閉じる必要のあるハンドルを受け取るときは、IntPtrではなくSafeHandleクラスを使うべき。IDisposableが実装されてるので、usingが使えたり何かと便利。
Microsoft.Win32.SafeHandlesに用意されていないハンドル型でも実装が単純なので自力で用意するのもアリ。DllImportにSuppressUnmanagedCodeSecurity属性を付けると、APIの実行が速くなる。ただしセキュリティを犠牲にしてるので、何も考えずに常に付加するのは危険？WinAPIに、C#のメソッドを関数ポインタとして渡すときについて書かれてないことに今さら気付いた。
例えば、キー入力のグローバルフックをしたいときに、コールバック関数としてC#のメソッドを登録したいときとか。まず渡したい関数の定義を、delegateとしてNativeMethodsクラスの中に用意。
ついでにコールバックで渡される構造体も。注意すべきは、C#は標準の呼び出し規約がstdcallだけど、C/C++の呼び出し規約はcdeclのため、そのまま渡してしまうと合わないので、cdeclを指定すること。
構造体のポインタが渡されるときは、このようにしておくとコールバック関数でも直に受け取れて便利。次にDllImportの定義。UnmanagedType.FunctionPtrで、関数ポインタであることを指定してあげる。
フックのハンドル（HHOOK）は、↑で書いたSafeHandleを定義してあげると、より安全。
↑で「定数はenumにしちゃう」と書いたけど、使うのが１つに限られてるならconstの方がシンプルで良い。そしてAPIの呼び出し。HINSTANCEの値は、WinAPIを使わずに、でも取得できるけど、いちいち配列を取ったり回りくどくて無駄だし、そもそも既に他でWinAPI使っちゃってるし、素直にGetModuleHandle(NULL)で取っちゃった方がスッキリして良いと思う。あと、ここ要注意！
引数の型がdelegateだから、ついつい↓みたいにメソッドを直接渡したくなる。しかし、これだと渡したdelegateが、C#側で誰も保持してないので自然消滅する・・・
つまり、フック開始してから数秒間は上手く動くのに、少し時間が経つとコールバック関数が消失してしまい、System.ExecutionEngineExceptionという意味の分からない例外を吐いて落ちるようになる。
必ず、渡した関数ポインタが呼び出される間は生存するところで、delegateを保持すること！
ハマりやすいので、お気を付けて。（ハマった）過去のソースを漁って思い出した物を書いたけど、他にもあった気がする。また思い出したら追記するかも。


