More than 1 year has passed since last update.Unityのユーザ定義PropertyDrawerの描画を毎フレーム自動更新する方法。EditorWindowを継承していればUpdateがあるし、Editorを継承していればRequiresConstantRepaintがあります。
でもPropertyDrawerにはなくて不便なので頑張ってどうにかしました。記事の下の方に基底クラスとして汎用化したものを置いてあります。一部Reflectionを使用、Unity2019.3.0f3にて動作確認済。タイムラインと再生機能つきのPropertyDrawerを作りたかったのです。
現在位置を表示したいわけですが、マウスを動かしたりクリックしたりしないとRepaintが呼ばれないので、常に適切に表示するには別途Inspectorを拡張してoverride RequiresConstantRepaint() =&gt; true;する必要があります。
何もしなくても、あるいはAttributeをつけるだけで手軽に拡張できるのがPropertyDrawerの良さだというのに、これではあんまりです。過程はいいからモノを出せという方は飛ばしてどうぞ。PropertyDrawerそのものにはRepaintという概念がないので、Repaintするためには親であるEditorのRepaintを呼ぶ必要があります。
アクティブなEditorはActiveEditorTracker.sharedTracker.activeEditorsでアクセスできるので、以下のように定義してRepaint()すればよいですね。ではこれをどこから呼ぶかですが、EditorWindowと違ってPropertyDrawerにはUpdateがありません。そこで出てくるのが、EditorのUpdateをフックするためのこのevent。
EditorApplication.update += Repaint;とすれば、毎UpdateごとにRepaint()が実行されるようになります。これを使っていきましょう。eventのadd/removeは大抵の場合OnEnabled/OnDisabled的な部分に書きますが、PropertyDrawerにはその類の「最初と最後に一度だけ呼ばれる」イベント、virtualメソッドが存在しません。
仕方がないのでOnGUI内に書きます。OnGUIは何度も呼ばれるので、addの前にremoveするのを忘れずに。これで、とりあえず毎フレームRepaintはされるようになりました。addの前にremoveを挟むことで同一PropertyDrawer内での増殖は防いでいますが、開き直したPropertyDrawerは別のインスタンスになるようで、このままでは「選択しているGameObjectを変えて再び元のGameObjectを選択し直す」を繰り返すことでリークします。これを防ぐため、選択項目が変わったらRepaintをremoveするようにしましょう。選択中のObjectの変化をフックするためのeventです。これで大丈夫な気がしますね。nullチェックもバッチリです。
早速PropertyDrawerを表示した状態で、別のGameObjectを選択してみましょう。

ダメみたいですね……
_unity_selfなるものがnullだそうです。知らんがな。VisualStudioでエラー箇所を確認してみると、

なんとparentSerializedObjectにまだ実体があり、しかしそのプロパティにアクセスできない状態。
targetObjectのget内でエラーが出てるみたいですね。
これは……Unityのバグかなあ。気が向いたらバグレポートでも出しますかね。バグレポート出しました。上のスクショを見ると、parentSerializedObjectのうち、ただ一つだけ正常にアクセスできているメンバがあります。
m_NativeObjectPtr、型はSystem.IntPtr。publicでないフィールド。選択解除時の値は0。
targetObjectのアドレスを保有するための内部フィールドだと考えられますね。
この値が0ならnullだと見なせばよさそうです。Reflectionしましょう。また、同スクリプトを載せた他のObjectを選択するときや選択解除するときも同様にm_NativeObjectPtrは0だったので、選択中オブジェクトの比較は不要そうです。
nullチェックもいらなさそうですが、ちょっと怖いのでこっちは一応入れておきます。これでエラーは出なくなりました。
本当にリークしていないかどうかは、OnGUI()あたりにとでも書いておけばConsoleで確認できます。いくら選択し直しても数字が増えていかなければOK。コンパイルやUndo/Redoのフック、Updateフレームレートの変更、その他諸々追加して基底クラス化したものがこちら。
カスタムインスペクタ上で表示する場合はカスタムインスペクタ側でRequiresConstantRepaintするはずなので、二重にRepaintが走らないようフィルタリングしています。リーク確認漏れとかバグとかあったらぜひ教えてくださいませ。同じGameObject上でこのPropertyDrawerが複数回表示されている場合、その回数分Repaintが無駄に走ります。
PropertyDrawerが載ってるserializedObjectをどこかに保持しておけば比較でどうにかなりそうな気がしますが、めんどい。
あと複数選択時の挙動は未確認です。デフォルトEditorもRequiresConstantRepaintをtrueにできればもうちょっと単純にできるのになぁと思いました。
あれは基底クラス（Editor）のvirtualメソッドの中身がreturn false;なのでReflectionじゃどうにもならないやつ。
メソッドの中身を動的に書き換える手段とか、実はどこかにあったりするんだろうか。


