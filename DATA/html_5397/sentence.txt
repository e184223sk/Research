More than 3 years have passed since last update.Wikipediaを参照してください。簡単に言うと、値の取りうる範囲が決まっている場合に高速なソートを実現するものです。とりあえず、値の取りうる範囲は与えられるものとします。keySelectorはOrderByなどと同じでソートのキーを選択するためのものです。keyDomainが取りうる値の範囲で、0と10しかとらない場合などはnew[] { 0, 10 }とか渡しても大丈夫です。
以上、非常に簡単に実装できました。と、それで終わるのであればわざわざ記事を作ったりしないですよね。
C#で使うならLINQなんかに絡めて使いたいわけです。上の実装を拡張メソッドにしてしまえば「ほぼ」完了です。ええ。「ほぼ」です。BucketSortの後に別のキーでソートしたい場合を考えてみましょう。Item1をキーにしてソートした後にItem2でソートするため、やりたい順番とは逆になります。そのためにLINQにはThenByがあります。というわけで、ThenByのような処理も実装しましょう。OrderedEnumerableのソースを参考に実装しました。しれっとLINQっぽい名前に変えました。で、肝心の使い方ですが、2通りあります。
まずは最初の方でやっていた、keyDomainを指定する方法。こんな感じでItem1で昇順に並べた後、Item2で降順に並べます。
昇順や降順というのはkeyDomainの並びに依存して、Reversedがつかない方はkeyDomainの順番で、つく方は逆順でということになります。もう1つの方はkeyDomainを指定しない方法。値の範囲がわからない場合に使えますが、バケットソートの性質上、あまり使わない方がいいと思います。IBucketComparerを実装したクラスを作り、KeyDomainをnullで返すと、ソートの際に一度sourceを走査してキーを洗い出し、Compareに従って並べ替えてkeyDomainを作成します。
想定外にbucketsの数が増える可能性もあるのでご利用は計画的に。もしかしたらこの実装は厳密に言うと鳩の巣ソートかもしれません。
あと、軽くググって見つからなかったので作ってみた（そして、結局使わなかったのでここに供養することにした）のですが、こんな感じのものは太古の昔に誰かが作ってそうなんですが、どうでしょう？


