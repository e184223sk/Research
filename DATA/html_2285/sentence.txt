More than 1 year has passed since last update.この記事は DeNA Advent Calendar 2019 の12/9(月)の記事です。この記事ではC#でProtocol Buffers(以下、protobuf)の中身を解析していくための機能について紹介します※本題に入るまで少し前置きがあるので、そういうのは飛ばしたいという方はこちらの本編へ直接どうぞ普段はゲームのクライアントエンジニアとしてUnityによるゲーム開発の仕事をしている人間なのですが、とある案件でUnityでprotobufを扱いたいというニーズが発生し、C#でゴリゴリprotobufのデータを弄ることになりましたその際に調べながら実装を進めていたところ「C#でprotobufを扱う内容ってあまり深堀りされていないなぁ」と感じ、今回の記事公開に至りましたprotobufがどういったものなのかを知っている前提で話を進めていきます「C#(Unity)でゴリゴリにprotobufを扱いたいんじゃ〜」という人がドンピシャなメインターゲットですが、中々に稀有な存在だと思われるので、実際にそういう人ではなくても「そういうこともできるんだ」と思ってもらえたら幸いですまた、今回取り扱うprotobufはproto3のバージョンを対象としていますそれぞれに関連する用語の詳細な解説は省いていきますので予めご了承ください今まであまり語られることがなかったGoogle.Protobuf.Reflectionの機能について学ぶことができますUnityのEditor拡張を使って直接protobufのデータを弄りたいというのが具体的な要件でしたが、Editor拡張の部分はとくに目新しいことはしていないため、今回はGoogle.Protobuf.Reflectionを使ってprotobufのデータを汎用的に読み書きする部分(非Unity依存・PureなC#コード)をメインに解説していきますhttps://developers.google.com/protocol-buffers/docs/csharptutorial
公式のチュートリアルにサンプルコードが載っていますこれらは抜粋ですが、全体のコードを確認したい場合は以下のリンクから辿ることができます
https://github.com/protocolbuffers/protobuf/tree/master/csharp/src/AddressBookこのようにして各スキーマごとにprotobufのデータをロードして、プロダクトコードでゴリゴリにデータ弄ってそれをまたセーブをすればOK！はい、ここからが本題ですスキーマ定義が少ないうちは個別にゴリゴリ実装をしていってもそこまで問題はないのですが、ガッツリ使い込んでスキーマ定義が増えていくとそのスキーマ定義に依存した実装のメンテナンスが非常に大変になってきます新しくスキーマの定義を増やしたり、スキーマの内容を変更したりするたびにメンテナンスをすることになるので、なるべく依存するコードは最低限に留めて汎用的に取り扱えるような実装にしたいです今回の要件では、UnityEditor上からパラメータの調整をできるようにしたいというものがあり、スキーマごとに入力エディタを作るのは現実的ではありませんでしたここで登場するのがGoogle.Protobuf.Reflectionのnamespace下にある機能ですprotobufがスキーマ定義に対応して自動生成してくれるC#コードは、スキーマ定義ごとにGoogle.Protobuf.IMessageを継承したクラスになっています
(以下、スキーマ定義に対応したprotobufが自動生成するC#クラスをメッセージと呼びます)Google.Protobuf.IMessageの定義に着目するとGoogle.Protobuf.Reflection.MessageDescriptor Descriptor { get; } というプロパティが存在しますこのGoogle.Protobuf.Reflectionにある機能を使うことで、メッセージの具体的な型に依存せずにそのメッセージの中身を調べることができます
※要するにprotobufの仕様に限定させたC#のReflection機能のようなものですこれを使えばメッセージの具象型に依存した実装をある程度省略することができそうですではどのようにしてGoogle.Protobuf.Reflectionの機能を使っていくのか
protobufはメッセージ単位でデータを扱うので、メッセージから掘り下げていきましょう下記のようなスキーマ定義を例にどのような内容が取れるのかを解説していきます先程も紹介したように、IMessageには MessageDescriptor Descriptor { get; } というプロパティが定義されています
ここからメッセージの内容を解析していくことができます
メッセージ内に定義されている内容が整理された状態でこのMessageDescriptorに詰まっています以下に今回のケースで利用するものを列挙しますEnumは宣言されている定数の情報がメインになるため、今回の要件では解析することは必須ではありません
一応どのような情報が入っているか確認しましょう繰り返しになりますが、今回の要件ではメッセージの型に依存せずに中身を読み書きしたいので、実際の値が入っているフィールドの中身が最重要です
詳しく掘り下げていきましょうまず初めに、protobufのフィールドには大きく分類すると以下の種類が存在しますOneofと呼ばれるものも存在しますが、これはGoogle.Protobuf.Reflectionでは厳密にはフィールドという扱いではないので別枠で解説します
1つずつ見ていきたいところですがまずはどのフィールドでも共通の内容を見ていきますフィールドの情報は FieldDescriptorで知ることができます
この中身を調べることによって対象のフィールドが前述のどの種別に値するのかを判断することができますフィールドの種別を判断するために必要な情報が分かったのでそれぞれ具体的な種別ごとに掘り下げていきましょうScalar Value Typesにどのようなものが含まれるのかは下記の公式ドキュメントにまとまっています
https://developers.google.com/protocol-buffers/docs/proto3#scalarまた、これらは前述で紹介したFieldDescriptor.FieldTypeで判断することができます実体にアクセスするためにはFieldDescriptor.Accessorを使います
Scalar Value TypesなFieldTypeの場合、SingleFieldAccessorが使われており、GetValue()/SetValue()メソッドで値の読み書きができますEnumの場合もSingleFieldAccessorが使われているため、Scalar Value Typesと同じ方法で値の読み書きができますここで取り出した値はSystem.Enum型として扱うことができるので、今回の要件のようなUnityEditorで取り扱う際には下記のようにして標準のEditor拡張コードに組み込む事ができますMessageの場合も前述の2種同様SingleFieldAccessorが使われています
IMessageを継承したメッセージクラスが格納されているため、IMeesageにキャストした上で更にDescriptorで掘り下げることによって更に中身を1つずつ操作することが可能ですprotobufは任意でメッセージの入れ子を連続させて定義することができる仕様になっているので汎用的に対応するためにはメッセージに対する処理は再帰的に行う必要がありますFieldDescriptor.IsRepeatedがtrueだった場合、そのフィールドはRepeated属性があることになります
Repeated属性のフィールドはRepeatedFieldAccessorが使われますが、これはSetValue()に対応していません
値を書き換えるには少し工夫が必要になりますこのようにして取得したIListやRepeatedField&lt;T&gt;のインスタンスに対してAdd（）やRemove()などをしてあげることでRepeatedなフィールドの中身も書き換えることが可能になりますIListを継承しているのでUnityEditorInternal.ReorderableListをそのまま使うことができます(結構便利です実はmap&lt;key,value&gt;として宣言したものもRepeatedなフィールドとして扱われます
内部的にはMapFieldEntryなメッセージ型にRepeated属性を付けているという扱いになっているのです
https://developers.google.com/protocol-buffers/docs/proto3#mapsなので、フィールドごとに処理を分岐させる場合はRepeatedなフィールドよりも前にMapかどうかを判断する必要がありますMapなフィールドにはMapFieldAccessorが使われますが、これもRepeatedFieldAccessorと同様にSetValue()に対応していません
自分で中身を掘り下げていく必要がありますMapの仕様としてはkeyに設定できる型がint32,int64, sint32,sint64, uint32,uint64, fixed32,fixed64, sfixed32,sfixed64, bool,stringに限定されてはいるものの、真面目にIDictinary&lt;TKey, TValue&gt;の形式にキャストしようとするとかなり骨が折れます扱うデータの仕様によってはMapの解析は対象外としてしまうのもアリでしょうフィールドの種別の話でOneofはGoogle.Protobuf.Reflectionでは厳密にはフィールドの扱いになっていないと話しました
これは、Oneofの定義に対しては専用のOneofDescriptorが存在し、そのOneof内で宣言されているフィールドに対してそれぞれFieldDescriptorが存在しているという仕様になっているためですこのようにOneofには専用のOneofDescriptorが用意されていますが、値を読み書きする方法は少し特殊ですC#上ではOneof内に宣言されているフィールドに対応したプロパティに対して値を設定することで内部的にOneofの仕様に沿った状態で値を更新してくれるようになっています
また、各フィールドに対応したプロパティへはFieldDescriptorからアクセス可能になっていますこれにより、新しくOneofとして扱いたいフィールドに対して値を設定することでOneofとしての値も書き換わったことになりますOneofDescriptorの項目で紹介したコードにもある通り、Oneofの中に定義したフィールドはそのOneofを定義したメッセージのフィールドとしても扱われているため、MessageDescriptor.FieldsとOneofDescriptor.Fieldsのどちらにも存在していることになります
下記のようにしてContainingOneofをチェックすることで処理の重複を防ぎましょうGoogle.Protobuf.Reflectionを使ってメッセージの基本的な中身を掘り下げるコードをズラーッと紹介しました今回紹介した以外にもまだReservedやOptionsなど、応用的な使い方がたくさん残っていますので、今後も別途それらの機能についても掘り下げていきたいと思います最後まで読んでいただきありがとうございました


