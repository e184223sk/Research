More than 1 year has passed since last update.インターフェースを利用すると何がうれしいのかを簡単解説している記事です.
ただし, 「インターフェースの使い方の入門記事」ではありませんので, ご注意ください.インターフェースとは, 平たく言うと設計書 / 仕様書のことです. もう少し言うならば, クラスや構造体が必ず実装していなければならないルールや規約, 契約, 規格などをまとめているもののことをいいます.
すなわち, インターフェースを実装するということは, その契約や規格に同意したということであり, そのクラスや構造体は必ずその規格に準じていることが保証されます.これは, クラス図レベルの設計に対応しています. 
クラス図レベルの設計の場合, 詳細実装ベースではなく, INPUTとOUTPUTベースのより粒度の粗いやりとりに興味があるわけです. つまり, クラス同士がどう関わりあうかに主眼が置かれるわけです.その際に, 何を利用して関わらせるのかが重要になります. それを定義するのがインターフェースなのです.
インターフェースは,「何かと何かを関わらせるために定義しているもの」であるため, 規格やルールを定義していると言えるわけです.たとえば, ICarというインターフェースが以下のような宣言になっていた場合を考えてみます.ICarには, 「3つのプロパティ」と「1つのメソッド」が宣言されています.
しかし, その中身については定義されていません.そこで, Carクラスを作成してみたいと思います.Carクラスには, まだ何も定義がありません. が, ICarインターフェースを実装しています(正確には, 実装していることになっています). ICarインターフェースに準拠しているとも言い換えることができます(正確には, 準拠している(ry).
このとき, Carクラスには以下のようなエラーが発生しています.これは, ICarインターフェースで宣言されているプロパティ/メソッドが, その実装先であるCarクラスで, "まだ実装されていない", つまり未定義であるために発生しているものです.
このエラーは, CarクラスがICarインターフェースで宣言されているプロパティ/メソッドを実際に実装するまで解消されません. つまり, インターフェースで宣言したものの実装をクラス(または構造体)に強制することができるということです.これを利用することによって, たとえば設計時に実装しなければいけないと決めたインターフェース(= プロパティやメソッド)の実装漏れを回避することが可能になるわけです.
コードベースで仕様の実装漏れが回避できるなんて, すばらしいですね！実際にインターフェースで宣言されているプロパティ/メソッドを実装することで, エラーを解消することができます.
たとえば, 以下のような実装をすることでエラーを解消することが可能です.IDEからエラーが消えていることを確認することができます.

次のようなIAdd&lt;T&gt;インターフェースと, 類似している2つのクラスについて考えます.
2つのクラスは, 一方がIAdd&lt;T&gt;を実装しているクラスで, もう一方がIAdd&lt;T&gt;を実装していないクラスとなります. それ以外については, 両クラスは非常に似ているクラスとなっています.ここで, 2つの値を足し合わせるSum()メソッドを考えます. 上記のコードは, 以下のようなエラーが発生しています.
これを回避するために, IAdd&lt;T&gt;インターフェースのAdd()メソッドを利用して, Sum()メソッドを実現しようとすると以下のようなコードを真っ先に思いつくかもしれません.しかし, このコードはいつもうまく動作するとは限りません. なぜなら, T型は必ずしも IAdd&lt;T&gt;インターフェース を実装しているとは限らないからです.
これを回避するために, 「インターフェース制約」という仕組みを利用します.この仕組みを利用することによって, パラメータに渡せる型をある程度制限することが可能になっています. 
また, インターフェース制約を利用することによって, インターフェースで宣言されているプロパティやメソッドを利用することが可能になります. 以下はそれを確認するためのスクリーンショットです.インターフェース制約なしの場合
当たり前ですが, Add()メソッドは候補に出てきません.

もちろん, Add()メソッドを利用してもエラーになります.
インターフェース制約ありの場合
Add()メソッドが候補として表示されるようになります.
これは, 「1. プロパティ/メソッドの実装を強制できる」で紹介したように, プロパティやメソッドの実装を強制できるからこそ, この制約が成立するわけですね.
サンプルコードは以下のようになります.ここで, IAdd&lt;T&gt;を実装していないNumber型を渡せるか気になりますよね？
IAdd&lt;T&gt;を実装していないとはいえ, 実際にAdd()メソッドは実装しています. このSum()メソッドを利用できるか確認してみましょう.Add()メソッドを実装していてもエラーとなってしまいました. 
これは, 当然といえば当然で, インターフェース制約 という名前からもわかるとおり, インターフェースを実装しているかどうかが重要なわけです. C#やF#のように強い静的型付け言語においては, さまざまな場面において型によって解決をはかります. その機能のひとつとして, インターフェース制約があるわけですね.これは, ジェネリクスのインターフェース制約を利用することによって, 単体テストを作成することが非常に容易となります.
特に, DBやネットワーク通信など, 外部とやりとりするような箇所についての単体テストで威力を発揮します. もちろん, 通常の単体テストを作成する上でも非常に役立ちます.これについては part2 で詳しく紹介しようと思います.ここまで長い文章をお読みいただき, ありがとうございました.
part2 は近日中に公開したいと思いますが, いつになるかはわかりませんので, あしからず....もし, この記事をお読みいただいて, 単体テストのくだりに興味をもっていただいた方につきましては, part2 までお待ちいただくか, Youtube Liveの方で直接ご質問いただければと思います.
Youtube Liveはこちらからチャンネル登録していただければ幸いです.また, この記事ではF#についてもご紹介してみました.
もし, F#に少しでも興味がわいたかたがいらっしゃいましたら, Youtube Liveの方にお越しいただければと思います.
私自身, F#のリファレンスサイトを現在作成中なので, そちらを参考にしていただいても問題ございません.
ぜひ, 来ていただければなと思います.今回の記事の参考になりそうなページは以下になります.
|&gt; F# | クラス
|&gt; F# | インターフェース
|&gt; F# | パイプラインと関数合成以上です.


