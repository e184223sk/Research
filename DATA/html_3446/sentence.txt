More than 1 year has passed since last update.令和元年おめでとうございます。新時代は弾幕系STGを作りたいので、なんとか納得のいくオブジェクトプーリングシステムを作ります。タイトルの改は前回からの改良ということで改です。前回のオブジェクトプーリング
https://qiita.com/nuruoki86/items/a1ae99427e632caaacf6
では配列を使って、オブジェクトのプールをしてました。
C#にはListなるものがあり、1次元配列で何かを管理するならList使ったほうがいいようなので、こちらの方法でやって見ます。ラムダ式([=&gt;]こういうの)を使って、Listの中から条件にあうモノの番号をint型で返してくれます。条件に合うものがなければ-1を返してくれます。
今回の条件はListにはいってるそのオブジェクトが非アクティブであるかどうかです。ラムダ式を使ってる部分はこんな感じ。Bullet_Listが今回GameObjectを格納してるListです。
ラムダ式で使ってる"b"という部分、型宣言もせずいきなり文字だけ打つのにすごく違和感を感じるのですが、Listにいれてるデータの型になってるみたいです。変数みたいなので"b"である必要はなく、自分の好きなように変えてもいいみたいです。hogeとか
今回はGameObject
今回は前回のn-way弾(https://qiita.com/nuruoki86/items/2c92a0d7f105eb1d81ad)
をサンプルとして使います。

ヒエラルキーはこんな感じです。Targetオブジェクトは完全にターゲットで何もしないので、
今回は「Object_Pool」と「Luncher」についてだけ説明します。前回は弾を撃つ処理と一緒に書いてましたが、今回はオブジェクトプールだけで独立させました。適当なオブジェクト(今回はObject_Poolオブジェクト)にくっつけて、poolBullet関数を呼び出せば大丈夫です。
最初にループ文等使って、いくつかプールするオブジェクトの確保はせず、足りなくなったらそのつど生成するようになってます。弾についてるコードはこんな感じです。画面外で非アクティブにする条件がかなりごり押しなのは目をつぶってください。後で何とかしておきます。オブジェクトプール動作の様子
オブジェクトプールの説明は上までで終わりました。ここからはLuncherの説明です。
Luncher.csとShotMenu.csという二つのコンポーネントを持ってます。前回までずっとループの処理も直接書いてましたがShotMenuコンポーネントを作ってまとめました。しかるべき場所でn_way_Shot関数を呼び出してもらえれば、弾が撃てます。今回は10フレームに1回です。引数は前から順に(弾速, way数, 何度の範囲で出すか, ランチャーの座標)です。引数の各型はこんな感じ。ちなみにオーバーロードできます。5つ目の引数にターゲットの座標を渡せば自機狙いになります。

ターゲットの座標に関しては、Luncher.csの下のほうにあるTargetPos関数がタグ検索で座標を返してくれます。全体が長くなったので今回使ってる関数の部分を載せます。
オブジェクトプールへのアクセスはShotMenuコンポーネントが行ってます。ランチャー側から呼び出して、計算した角度とともに、速度と座標をBulletfunc関数に渡してます。やっとオブジェクトプールを使います。poolBullet関数はここで呼び出してます。List.FindIndexをつかって、前回に比べるとだいぶすっきりしたと思います。
長くなったのでわかりづらいところがあったり、変なところがあれば教えていただくとありがたいです。
あと、n-way弾の自機狙いはこんな感じです



