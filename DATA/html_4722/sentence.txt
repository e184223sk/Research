More than 3 years have passed since last update.Google 公式の C# 実装である Grpc.Core では、Unary, ClientStreaming, ServerStreaming, DuplexStreaming の4つのメソッドタイプの戻り値は、それぞれ AsyncUnaryCall&lt;TResponse&gt;, AsyncClientStreamingCall&lt;TRequest, TResponse&gt;, AsyncServerStreamingCall&lt;TResponse&gt;, AsyncDuplexStreaming&lt;TRequest, TResponse&gt;型になります。これらの型のメソッドやプロパティの定義は似ていますが、共通の基底型を持ちません。そして sealed クラスです。IDisposable以外のインターフェースも実装していません。そのため、汎用処理を実装しようとするとそれぞれの型に対して実装することになり、ソースコードが冗長になりがちです。透過的に処理を実装する手段を考えます。インターフェースを使って透過的な実装を行います。まず、リクエスト送信とレスポンス受信に関する機能をインターフェースとして定義します。全てのメソッドタイプに共通する機能を定義します。全ての AsyncCall 型に当てはまります。ストリーム形式でリクエストを送信するのに必要な機能を定義します。AsyncClientStreamingCall&lt;TRequest, TResponse&gt;とAsyncDuplexStreaming&lt;TRequest, TResponse&gt;に当てはまります。単一のレスポンスを受け取るのに必要な機能を定義します。AsyncUnaryCall&lt;TResponse&gt;とAsyncClientStreamingCall&lt;TRequest, TResponse&gt;に当てはまります。ストリーム形式でレスポンスを受け取るのに必要な機能を定義します。AsyncServerStreamingCall&lt;TResponse&gt;とAsyncDuplexStreamingCall&lt;TRequest, TResponse&gt;に当てはまります。次に、これらのインターフェースを実装し、AsyncCall オブジェクトをラップするラッパークラスを実装します。ラップ対象の AsyncCall オブジェクトを内包して同名のプロパティとメソッドの戻り値を返すだけの実装ですので、ここでの説明は割愛します。各 AsyncCall 型に対する拡張メソッドとして定義すると、アプリケーションコードからの呼び出しが簡単になります。これらのインターフェースを用いて汎用処理を実装します。
次の例は単純に全てのリクエストを送信した後で完了を通知するだけの内容です。ClientStream, DuplexStream の両方から利用できます。
いろいろな送受信アルゴリズムを実装しようとすると例外処理などの汎用処理を局所化したくなります。そのとうなとき、各インターフェースの基底型である IAsyncCall を引数とするメソッドとして実装することができるようになります。メソッド名が長すぎたかな。C# 4.0 以降では dynamic を使ってダックタイピングができます。今回の4つの AsyncCall クラスは同じ名前のメソッドやプロパティを持っていますので、ダックタイピングによって共通処理を実装することもできます。
私は VB.NET の option strict off の低品質ソースコードに苦しめられたのでこの手のテクニックはあまり使わないようにしていますが、メリット／デメリットを理解した上で使う分にはよいのではないかと思います。【@IT】連載：C# 4入門 第1回 dynamic型
【mxProject】VB.net で開発するときは Option Strict On で　←私のブログです


