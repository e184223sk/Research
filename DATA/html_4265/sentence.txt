More than 1 year has passed since last update.この記事は NSSOL Advent Calendar 2018 の6日目の記事です。業務で最新のASP.NET Coreで認証付きREST APIを実装し、それをSwaggerで利用できるようにしました。
Swaggerを使えるようにするためのページはQiitaにも色々ありますが、認証の話はまとまったものが見当たらなかったので、この場を借りて実装手順をまとめます。認証はクライアントとサーバ間でJWT認証を使い、サーバではKerberosやLDAPなど、外部システムと通信を行うような構成です。基本的な流れは以下。Startup.csと仲良くなる必要があります。（正直、結構めんどい）Visual Studio で空の ASP.NET Core Web APIプロジェクトを作成します。プロジェクトの作成時に認証方式を選択できますが、今のVisual Studioでは、Azure/AzureAD/Windows認証しか選べないので、一旦は認証無しで作って、後からLDAP等を追加します。また、簡単化のため、Docker/HTTPSはOFFにしてます。プロジェクトを作成すると、デフォルトで ValuesController が生成され、以下のAPIが利用可能になっています。今回はこれをそのまま例に使います。続いてswaggerを追加します。本家記事に従い、NugetでSwashbuckle.AspNetCore をプロジェクトに追加し、Startup.csを編集します。（usingは省略してます）ここまででSwaggerUIからAPIが参照・実行できるようになりました。Startup.csを拡張して、JWTトークンの処理を追加します。JWTトークンについては、Web上に大量の情報があるので、ここでは省略します。
この節の実装を通じて、以下を実現します。まず、トークンの生成に使う各種設定情報を定義しなければいけないので、以下のクラスを追加します。
共通鍵については、リクエストの度にインスタンスを作るのは効率が悪いので、シングルトンにしています。ウチで実際に使ってるときは、ハードコードでなくappsettings.jsonなどからとってきてます。特に共通鍵の元になるkeyは保存元をしっかり検討した方が良いと思います。ConfigureService に認証を追加します。REST APIなので、認証失敗したときのエラーもJson形式で返さないといけません。毎回書くとメンドイので、JsonResultを拡張させたクラス CustomJsonResult を作って、共通化してます。詳細は過去記事の ASP.NET CoreでREST APIを作る際のJsonResult拡張クラス を参照してください。JwtBearerEvents.OnTokenValidated の中で認可処理もやってしまって良いんですが、今回は認可をASP.NET内でやることにして、何もしません。Startup.cs内のConfigureメソッドに以下を追加します。UseSwaggerUIとUseMvcの間にこれを差し込むだけです。こっちは簡単。これでリクエストにJWTトークンが入っていないと401が出るようになりました。この状態のSwagger UIにはJWTトークンを入力/送信する機能がありません。
あらゆるAPIが401になるだけで、swaggerの便利さを著しく落としてしまっているので、UIから使えるようにします。まず、SwaggerUIを拡張するために、以下のクラスを追加します。リフレクション使っちゃってますが、SwaggerUIを表示したときだけ実行される処理なので、実際のREST API実行へのパフォーマンス的な影響はありません。続いて、ConfigureSerivcesメソッドの AddSwaggerGen の中に、以下を追加します。これでAuthorizeボタンが表示され、トークンを埋め込めるようになりました。
また、認証しないと使えないAPIは、右側に鍵のマークが表示されています。
このAuthorizeボタンか鍵マークのどちらかをクリックすると、トークンを入力するためのUIが表示されます。ユーザ名＆パスワードで認証して、成功したらJWTトークンを発行する処理を実装します。トークン発行機能をAPIに持たせる（＝パスワードを送らせる）となると、HTTPS化は必須な気がしますが、今回は省略してます。新しいAPI "POST /api/Account/Login" を作って、トークンを発行可能にします。コードでは、認証＆認可の処理はダミーを入れています。これで完成です！
Swagger上にLogin用のAPIが現れ、トークンを取得できるようになります。GoogleとかTwitterでは認証失敗しても200とか204とか返しますが、今回は400 BadRequestが出ます。適宜API仕様を決めていただければと。実際に、SwaggerからJWTトークンを使って、認証必須なAPIを実行してみます。Authorizeボタンを押して、トークンを「Bearer トークン」のフォーマットで入力します。そのあとで、適当なAPIを叩くと、リクエストヘッダにトークンが挿入され、認証済みとして実行が可能です。変な文字列をトークンに入れても、401 Unauthorizedではじかれます。トークンが設定されている際は、HttpContextにクレーム情報が自動で格納されるようになっています。このクレームを確認したい場合は、以下のコードで取得可能です。適宜認可用のFilterを作るよろし。この記事で作ったプロジェクトのソースコードは、GitHubに置いています。単にSwaggerを使うだけなら簡単なのに、認証付きだとそれなりに実装手順が多くてツラいここまでの手順で、認証付きのAPI開発にSwaggerが使えるようになります。
API開発する上でSwaggerはめっちゃ便利なので、うまく活用しましょう。まだ改良点はいろいろありますが、時間と心の余裕があったら追加で記事書きます。それなりに大きいシステム作ると認証は避けて通れないと思うので、誰かのお役に立てば幸いです。


