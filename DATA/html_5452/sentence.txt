More than 3 years have passed since last update.唐突に発生したプロジェクトでMiFareという規格のスマートカード使って別の製品とお話しなきゃいけなくなった。
用意されたリーダーライターはntt-comのACR1251CL
前提知識はゼロでレディーファイッ!('A`) ﾝﾓｰその結果Windows10のPCにACR1251CLを接続して(カードを載せて)デバイスマネージャで見るとこんな感じに見える。WindowsからはWinSCardというインターフェースでやり取りすればいいらしいというのはわかったので調べてみる。おおよそのところという流れのようだ。
そしてカードに対する処理そのものであるAPDUデータはISO7816 part 4 section 6 with Basic Interindustry Commands (APDU level) で定義されている。コマンド体型としてはというバイト配列になっていて 0xFFB00005101みたいなコマンドを送るとコマンドに応じた返答が返ってくるようだ。･･･。そ う い う こ と が し た い ん じ ゃ な い ん だ よ !!!
スマートカードの中のデータにアクセスして、目的の場所を書き換えれらればそれでいいんだよ。SmartCard だけにとか思ったらさすがのgithub。なんでもあるぜ。onovotny/MiFare: MiFare Classic support for Windows Phone 8.1, Windows Store 8.1 and Windows Desktop appsサンプルも完備 MiFare/MainWindow.xaml.cs at master · onovotny/MiFareonovotny先生のお陰でデータアクセスできるようになったとはいえ、データ読み書きするためには内部のデータ構造がある程度分かってないとつらいのでまとめてみる。AN1304 NFC Type MIFARE Classic Tag OperationMifareの内部はセクターと呼ばれる64バイトごとの領域が並んでいる。各セクターは16バイトごとの3つのデータブロックと、16バイトの権限ブロックからなる。権限ブロックは6バイトのKeyAと3バイトのパーミッションマスク、1バイトのユーザーエリア、6バイトのKeyB で成り立っている。
この例ではblock 0-2まではKeyA KeyBともに読み書き可能で、権限ブロックのBlock 3はKeyAでだいたい読み書き可能になっているようだ。MiFare Classic 1K/4K ではデータの読み書きをする前に対象のセクターに対しログインをする必要があり、その際に対象のキー(KeyAまたはKeyB)と一致したバイト列を指定する必要がある。
ログインしたキーとキーの権限で読み書き可能になっていなければオペレーションが失敗する、というセキュリティ構成になっている。2要するにMiFareカードのデータを読み書きするためにはが揃っていればOKなわけだ。(ライトな暴論)アクセス権限はこのへんで計算しよう。 
MIFARE Classic 1K Access Bits Calculatorバグっちぃコードを何箇所か直したのがこちら。
qyen/MiFareちょうどいいサンプルが入ってた。セクターに対するキーの配列を作ってCreateMiFareCard()に渡してやればいいと。ということでみたいな。Sector#FlushTrailer() でいける。サンプル見ながら組んだらいけた。onovotny先生ありがとう。カードの中身を参照するのにちょうどいいツールが見当たらなくてすげぇ苦労した。
やっとのことで探し当てたこれ(Cardpeek)がもう最高で手放せないので使ってみると良いよ。ちなみに0xFFB0000510で 0x05番目のセクタを0x10バイト分読み込む(0xB0)という意味。わかるかこんなもん。 ↩どうやらこの辺の仕組みは既に割られていてあんまり意味ないという話もあるみたいだけど。 ↩


