最適解を見つけました！！！ではなく、という内容になっています。このアプリは×ボタンを押してもアプリが終了しないような、常駐アプリを想定しています。
すなわちShutdownModeがOnExplicitShutdownに設定してあります。この設定以外の場合、アプリを終了してもウィンドウが残り、ゾンビ化してしまう場合があります。
別途対応が必要ですので適宜対応してください。WPFアプリにおいてMVVMアーキテクチャを採用している場合
メインウィンドウに設置したボタンを押したときにサブウィンドウを開くという単純な処理の実装が地味に面倒だったりします。MVVMアーキテクチャの設計思想として、ViewとViewModelはDatacontextでのみ情報を共有しており、ViewModelはViewの情報を能動的に知ることができません。
ましてや、ViewModelがバインディングされていないViewの情報を知る・操作することはなおさら設計思想に違反するもの(と個人的には思っています。)この思想を考えないのであれば、メインウィンドウのViewModelからサブウィンドウのViewを参照して、Window.Show()としてあげれば新しいサブウィンドウを開くことが可能です。
実装としてはエラーも発生しないかと思いますし、これが許される組織等であればこの形がシンプルかと思います。ただ、個人的にはちょっと気持ち悪い部分があったので、どうにかならないかなと模索してみました。同じ状況で困っている人はたくさん居るはずで、ググれば解決策が見つかるだろう。
と思い色々調べると以下のような感じでずらずらと。
Opening new window in MVVM WPF
Open a new Window in MVVMただ個人的にしっくりくるものがありませんでした。
自分なりに考えた方法が以下の通り。1.App.XamlのStartUpイベントを実装し、StartUpが呼ばれるようにする2.App.xaml.csのSutartup内において、SubWindowのViewのインスタンスを作成する。ただしShow()は実行しない
3.SubWindowのViewを、MainWindowのViewインスタンス生成時にコンストラクタに渡す。4.MainViewのViewModelにおいてSubWindowのViewのインスタンスから自作のOpenSubWindowServiceのインスタンスを作成
MainViewのButtonのデータバインディングに紐づけたICommandの中身においてOpenSubWindowService.Show()を実行一度サブウィンドウを×ボタンで閉じて、再度メイン画面より開こうとするとExceptionが発生します。
理由としては、Windowが閉じた状態でWindownに対してShow()操作を行っているためです。ただ、今回の実装においてはWindowを生成しているのがApp.xaml.csの部分になるため
再度Windowを生成することが難しくなります。対策としては、サブウィンドウのClosingイベントにおいてClosingをキャンセルし、Hide()します。
そうすることによって見えなくなっているだけなので再度Show()することが可能となります。ただし、この実装では元のWindowの情報が残っているので再表示時にClearする必要が出てきたり
膨大な量のWindowをShowする場合はすべてインスタンスが残っている状態になるため注意が必要です。他にもいろいろと気づけていない制約はあるかもしれません。MVVMを利用したWPFで新たにサブウィンドウを開く方法を自分なりに考えてみました。
メインウィンドウのViewModelがサブウィンドウのViewのことを意識せずShow()できているので、MVVMの設計思想には沿えているのではないかなと思います。
ただ完全にすっきりする実装かといえばそうではないので、まだまだいい方法があるかもしれません。という内容でした。
誤りがある場合や、よりいい方法がある方はコメント頂けると嬉しいです。


