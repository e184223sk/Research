　前回はTensorクラスの一部とTensorを加工するIFunctionインターフェースの実装を行いました。今回は、四則演算を行う関数を定義し、それを用いてTensorの四則演算を実装していきたいと思います。　関数クラスはこのライブラリにおいて、Tensorを加工する重要なクラスとなります。関数クラスは全てIFunctionから派生したBaseFunctionを継承するようにしてその下に入力と出力の関係から分類した抽象クラスを実装して最後に具体的な関数のクラスを実装します。下の図のような構成です。UnaryFunctionは一つの入力に対して一つの出力が得られるような関数に対して定義しようと考えています。
SetFunctionは集合に対する関数(minやmax, sum, meanなど)の基底クラスとなる予定です。これらの他にもTensorのShapeを操作したりTensorを二つに分けたりする関数なども考えています。　ここではIFunctionでForwardやBackwardを呼び出された際の具体的な動作を実装していきます。これによって子クラスでは勾配の伝播のための処理を省くことができます。　ここでは、さらに入力を二つ出力が一つであるような関数の処理を求めています。BaseFunctionで定義したFunctionForwardとFunctionBackwardに対して、二つの入力と一つの出力を行うBinaryForwardとBinaryBackwardを追加し、継承したクラスで実装しやすいようLeft(演算子の左), Right(演算子の右), Outの三つを定義しています。　正直四則演算のクラス同士にそこまで差異はありません。一つ実装できたら他も簡単に実装できると思います。二項演算においては二つの入力を持つ関数を考えます。最終的な出力を$E$とすると$E.Backward()$を行った際にはそれぞれのTensorに対する$E$の勾配が計算されていくので　しかし、実際は$L$を入力とするのは$O$だけとは限らないので、$O$に対して添字$i=(1, 2, 3, ..., n)$がつき、　よって二項演算において実際に行う計算は　足し算の場合　実際にはTensorの配列に対して行うので、　さらに微分は　したがって実装は　引き算の場合　微分は　実装は　掛け算の場合　微分は　よって実装は　割り算の場合　微分は　$O_i$については$Forward$で計算しているので上のようにすることで計算回数を抑えられる。
　これを用いて実装を行うと　Tensorクラスは割と処理の内容が多くなってくると思うので前回使用したファイルとは別のファイルに四則演算を実装します。(そのために前回partialでTensorクラスを実装しました)
　演算子の実装では、それぞれの関数のコンストラクタを呼び出すことで計算グラフを構築しながら演算を行うことができるようになりました。　最後のTensor[]$\rightarrow$Tensorへの変換は実装するか悩みました。しかしこれが無いと出力一つの関数(minやmaxなど)を使用するたびにインデックス0を指定しないといけなくなるので(IFunctionではTensor[]で数値のやりとりを行うため)利便性のためにこれを追加することにしました。　ここまでのコードはhttps://github.com/aokyut/Rein/tree/v0.0.2で公開して居ます。現時点では使い物になりませんが、続きを実装してみたい方やこれまでの実装を確認したい方は見てみてください。　ということで今回は関数の基底クラスの定義とTensorクラスの四則演算の定義を行いました。機械学習の実用に使えるようなものではありませんがTensor同士で計算できるようにはなりました。次は多次元配列の演算として多用されるドット演算や単項演算あたりを定義したいと思います。


