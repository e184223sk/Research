More than 1 year has passed since last update.金子みすゞ氏が今日生まれたので初投稿です。この記事を読む前に @mao_ さんの 【Unity】UnsafeUtilityについて纏めてみるをお読みください。
タイトルに反してUnsafeUtility.Mallocについてのみ解説していますが、良い資料であると思われます。なぜNativeContainerを自作しなければならないのかBurst Job内部では参照型をnewすることはできません。故に参照型をフィールドに持つ構造体をnewできません。
Blittableな構造体のみが内部でnewできるのです。
NativeArray&lt;T&gt;はどうでしょうか？　これはランタイム実行時には内部的にはポインタと配列長を持っていますのでBlittable型です。
しかし、エディタ上ではメモリリークを監視するためにDisposeSentinelという参照型のフィールドを把持しているため非Blittable型なのです。
故に我々はBurst Job内でNativeArrayをnewできません。
NativeContainerを自作することでのみ我々はBurst Job内でコレクションを扱えるようになります。Unity.Collections.LowLevel.UnsafeUtilityの持つ様々な便利機能を概説していきます。
MallocとFreeは @mao_ さんの記事を読んで、どうぞ。以下の関数毎に性能測定コードを作成しましたが、そのコードはgistを参照してください。そして関数毎に推奨するか非推奨であるかを記載していますが、これは個人の見解です。
ご意見を歓迎いたします。これは与えられた参照を元にしてそのポインタを得るメソッドです。
つまり純C#で記述すると以下のような擬似コードとなります。実際の所void*が返されてもあまり使い途はありません。IntPtrまたはT*型であってほしいものです。
ならばもうfixedステートメントを素直に記述したほうが良いのかもしれませんね。
性能を比較してみましょう。
測定コードを以下に記載します。結果としてとなりました。
性能的にあまり推奨できません。C++11のalignof演算子相当のAPIです。
メモリアライメントは効率的なメモリアクセスを実現するために知るべき値ですので存在価値はあります。このメソッドはボックス化された構造体またはPin留めされた参照型について、その中身をdestの指す先に書き込みます。そもそもボックス化を起こすなという話ではありますが、PUN2など既存のUnityのアロケーションに無頓着なライブラリを使う限りに置いてボックス化は避けられません。これは必要悪と言えるでしょうが、C#コードベタ書きの方が早いので使わないほうがよろしいでしょうね。
性能測定コードは以下の通りです。このAPIはポインタの内容を構造体にコピーします。素のC#で書く方が倍以上に早いです。構造体をポインタの指す先にコピーします。このAPIはジェネリクスで表現された列挙型を数値に変換することができます。元となる列挙型が具象型としてわかっている場合を対照例として記載しました。
具象型に対して直接(int)するのは当たり前ですが最速です。
それに対してジェネリクスに列挙型を数値に変換する手法を比べてみます。
BOX化してからintに変換する手法はボックス化分性能の劣化が激しいですね。
ConvertクラスのToInt32は輪をかけて遅いです。
全ての列挙型が暗黙のうちに実装しているIConvertibleインターフェースのメソッドToInt32(IFormatProvider)もかなり遅いです。
それに対してUnsafeUtility.EnumToIntは流石に直接int型変換に比べると桁一つ遅いですが、他の手法よりは圧倒的に速いです。間違いなくUnity環境ではEnumToIntメソッドを使用するべきです。
と思っていた時期が私にもありました。
詳しくはコメント欄をご覧いただきたいのですが @kraihd 氏のご指摘の通り unmanaged型制約を指定してポインタを取得、そしてキャストするのが速いです。
故にこのメソッドは仕様を不推奨に推奨レベルを変更します。構造体のフィールドについてその先頭からのバイトオフセットを返します。なぜ文字列からリフレクションしているSystem.Runtime.InteropServices.Marshal.OffsetOfに対して既にFieldInfoの段階までリフレクションを済ませているUnsafeUtility.GetFieldOffsetが負けるのでしょうかね？型引数がBlittable型であるかどうか判別します。私の知る限りに置いて.NETのAPIでその型がBlittable型であるかどうかを調べる方法はないはずです。型引数がunmanagedな構造体であるかどうか判別します。.NET Coreと.NET Standard 2.1に存在するSystem.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferencesメソッドを使用すればunmanaged型であるか判別できます。
しかし上記APIはUnity環境では現在使用できません。NativeArrayをnewするために必要な列挙型Allocatorについて、その種類によっては実際にはメモリアロケーションが行われません。
メモリアロケーションが起きるかどうかを判別するメソッドです。Allocator.NoneとAllocator.Invalidはfalseを返します。
思いっきり糖衣関数ですね。C++領域からメモリを切り出してきます。はやいです。AllocHGlobalとAllocCoTaskMem　どちらを使うべきか？を参考にしつつSystem.Runtime.InteropServices.MarshalクラスのAllocHGlobalとAllocCoTaskMemを使用した例も性能比較コードに追加しています。Mallocについてメモリ領域確保についてはAllocator毎の差はあまり見られません。
わずかにAllocHGlobalが遅いですが、大した差はないと言えるでしょう。Freeについて大きく差が着いたのはメモリ解放に於いてです。この結果は個人的には予想外でした。
Allocator.TempのFreeは爆速です。
２桁速いです。
そしてHGlobalはおよそMallocと同程度の時間を掛けてFreeしています。あまり使わないほうがよろしいでしょう。ポインタの指す先のsize分の領域を0クリアします。Array.Clearは型を見て0クリアしているためかそこまで速くありません。
素直にMemClearを使うのが一番でしょう。メモリ領域のbyte単位での大小比較を行います。実際は等値性比較で使うことが多いと思います。かなり高速に動作するので役立ちます。コピー元とペースト先の領域に被りが存在しない前提でコピーを行います。
領域が重なる場合はMemMoveを使用してください。C#大統一理論で知られる @neuecc 氏の以前行ったパフォーマンステストをご参考までにどうぞ。256KBを1024回コピーするだけのテストですが、その差は歴然たるものです。
いやはやどうしてここまで差がついたのでしょうね？
やはりC++レイヤでコピペを行うのが最速ということなのでしょうか。
そしてlongコピーがMemoryCopyより速いのにもかなり困惑しています。
なんにせよUnsafeUtility.MemoryCopyが最速ではあります。ポインタの指す先の領域にコピー元からcount回size分コピーを行います。細かいデータの反復的コピーを行う場合UnsafeUtility.MemCpyだとオーバーヘッドが大きすぎるとわかりました。現時点でUnity公式リファレンスに堂々と間違いが記載されていますので気を付けましょう！
あとなぜかUnity2018.1とか2で動作しないことがありました。このメソッドは良い感じにスライドしながら要素をコピペしていきます。
具体的には巨大構造体配列の一部のフィールドを別の巨大構造体配列の一部のフィールドにコピペする時に使えるでしょう。これはちょっと対応する.NETのAPIが思い当たりませんでしたので使用例を示します。PinGCArrayAndGetDataAddressは引数に与えた配列を固定し、その配列の先頭要素のポインタを返り値にします。
PinGCObjectAndGetAddressは引数に与えたオブジェクトを固定し、そのポインタを戻り値にします。
この固定状態を解除するにはgcHandleに対してReleaseGCObjectを行ってください。比較対象のAPIとしてSystem.Runtime.InteropServices.GCHandleを使用しました。
配列内部のポインターを今回は利用できるようにするため、GCHandle.Allocの第2引数にGCHandleType.Pinnedを渡すのがミソです。
しかし、Unity環境ではUnsafeUtilityの方が速いのでGCHandleを使う必要は薄いです。Pin留めReleaseUnsafeUtility.ReadArrayElement要素ベタコピペUnsafeUtility.ReadArrayElementWithStride要素ベタコピペUnsafeUtility.WriteArrayElement要素ベタコピペUnsafeUtility.WriteArrayElementWithStride基本的に構造体のフィールドに関して複数の型で共通のフィールドを持つよう言語的に強制することはC#7.3の現時点ではできません。
ゆえに今回のようなフィールドの読み取りは個別的具象型に対して行うと見做して良いでしょう。
その場合べた書きが速いですね。特にUnsafeUtilityを使わずともよいでしょう。型引数で指定した型のサイズを返します。unsafeコンテキストではsizeof演算子がジェネリクス型引数に対して使用可能です。
特に使う必要はないでしょう。以上！
全UnsafeUtilityメソッドの解説と性能検証でした！
案外性能出ていないAPIも沢山ありますが、それでも絶対に使うべき有能APIもありましたね。
Unity Technologiesは良い仕事をしたと思います。


