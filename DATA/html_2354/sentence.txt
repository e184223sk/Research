More than 1 year has passed since last update.浮世の変化には疎いのですが、なんか流行ってるらしいですねRust。
実はUnityのネイティブプラグインを作ってみたかったのですが、CもC++もやったことない上に勉強する気もないため踏み切れないでいました。
いい機会なのでRustで作ってみます。スマホ開発がメイン
CとC++は未経験
値渡しと参照渡しはわかるけどぽいんた？　とかいうのはわからんとりあえずインプットします。Rustの日本語ドキュメント/Japanese Docs for Rust
プログラミング言語 Rust, 2nd Edition/ The Rust Programming Language, Second Edition
プログラミング言語Rust
The Rust Programming Language必修言語Rustの他己紹介
Rust についてのメモ
Rustのポインタ（所有権・参照）・可変性についての簡単なまとめ
Rustはこうやって勉強するといいんじゃないか、という一例
Rustのクレート・ツールを探すための情報源コンパイル通るまで殴ればいい！　かんたん！
こんなにやさしいコンパイラ初めて見ました。cargoによる依存関係の管理もよく練れていていい感じです。
Kotlinなんかもそうですが近代の言語はユーザ獲得のため、チュートリアルがおそろしく充実していていいですね。
あとプロジェクト新規作成したらgit作ってくれるのすごい。Rustで実装したアルゴリズムをUnityから使う
C#からC++(DLL)に配列を渡す
How do I get Rust FFI to return array of structs or update memory?
How to return an array of structs from Rust to C#プラグイン更新のたびにUnityEditorの再起動が必要とかつらい。intellij製品じゃないともうなにも書けない。
MEET INTELLIJ RUSTひとまず手始めとして、C#から渡されたVector3をRust側で100倍して返します。さっそく実行してみましょう。……なんか……なんだろう、よくないことが起こっているようですね。というわけで、Rust側を修正します。引数のv: Vector3をうっかり拝借していましたが、Rust内で完結するならばともかくC#から借りてくるのはあまりにも無茶な話でした。というわけでそのまま渡してみます。……またよくないことが……いや、よく見たら四捨五入してそうな数字です。Rider先生にデコンパイルしてもらってVector3のToStringを覗いてみます。nicely formatted string${\Large なに言うとるがじゃ！！！！！}$しょうがないのでこんな感じの拡張メソッド定義してありのままの姿を見せてもらうことにします。できました。気になるのは借用をやめた修正です。
C#側では「もともとのVector3」「引数としてコピーされたVector3」の2つがあります。
「もともとのVector3」はC#が管理しているからいいとして、Rustの借用ではないということは「引数としてコピーされたVector3」をRust側で開放しちゃってそうな気がしますが、これってC#側の扱いはどうなっているのでしょうか。externだとそのあたり忖度されるんでしょうか。もしくはstructなのでC#から渡すときに値をコピーしてるから大丈夫なのか。まあいいか。ようやくNative Pluginを使いたい理由に入ります。
Meshの頂点座標を基準点からの相対位置に変換する処理ですが、この処理がやや重い……ような気がします。そう頻繁に行う処理でもないので無理に高速化する必要もないのですが、今回はやってみることそのものが目的です。
というわけで、以下のC#で書かれた関数をRust側へ計算処理を逃がす関数にするのが今回のゴールです。C#からMatrix4x4を受け取るため、Rust側で同じ構造体を定義します。
本来ならありものを使うのではなく、C#側でも自分でちゃんと受け渡すための構造体を定義するべきですが、Vector3もそのまま渡せたんだからMatrix4x4も行けるやろ！　の精神です。ちゃんとRust側で受け取れているか試すために、以下の関数を作ってC#と突き合わせてみます。最初だけ合っている。ということはつまり構造体のメンバの定義されている順番が違うのでしょう。
再びRider先生にデコンパイルしてもらいます。十の位から増えてるの……？
なんか感覚と違いますが、そう定義されている以上はしょうがありません。Rust側の構造体の定義の順番を変えます。一致しました。Matrix4x4はちゃんとC#からRustに渡せています。肝心のMultiplyPointの処理です。
デコンパイラの結果というのもあると思いますが、なかなかにカオスな計算処理。
float -&gt; double -&gt; floatとキャストしている部分をRustでも再現するかは悩みどころですが、いったんは心を無にしてRustでも同様の処理を書きます。Infinity...数回繰り返したところ正負は合っているので、キャストに失敗して無限の彼方に辿り着いているようです。
こんなもんの原因追求する気はさらさらないのでRustのコードをきれいに書き直します。なんかもっときれいに書けるような、そうでもないような。
ともあれこれを実行してみます。一致しました。これでようやく完成です。さっそくC#と比べて早いのか遅いのか実験してみます。これがプロファイラの結果です。C#が一番速い……。
Rustのリリースビルドとデバッグビルドで差が出ている以上、NativePluginだからプロファイラがおかしくなっているわけでもないようです。f32が溢れるようなことはまずないので、Rust側でキャストを止めてみます。ちょっとはやくなってる。仮説1が一番大きいと思います。わたしが戦っていたのはキャストしまくりのC#ではなくバチバチにチューニングされたC++だったのです……たぶん。なので自分で実装した重い処理とかだったら違う結果が出るかもしれません。仮説２の解決としてVector3[]の配列を受け渡しできればいいのですが、ポインタがわからないからマーシャリングもわからないので諦めました。Rust側でポインタを復元する方法もわからないです。仮説3もわりとありそうな気がしています。いちいち変換している分のコストはかなり大きい……はず。あと、いくらVector3とはいえこの数なら結構なGCを誘発していると思うのですが、プロファイラのGC Allocはみんないっしょです。NativePlugin部分に対するプロファイラの動作もいまいち情報がないのでよくわからん。今更ですがeditionは2018です。
Rustの学習ですが、ヤバいと噂の所有権は自分はそんなにひっかかりませんでした。でもライフタイムは微妙にまだよくわかってないかもしれない。
あと、エラー処理と並列プログラミングはちらっと読んだだけで何言ってるかまったく理解してないので改めて読もうと思います。
Rustの学習コストは確かに高いですが、コンパイラさんが徹底的にチェックしてくれることで実行時に吹っ飛ぶのを防止してくれるのはとても好きです。Unity+C#+Rustの知識を要求されるのつらい。プログラミングぢからは高まった気がしますが、結果が出せていません。
しかし現在の自分ではこれ以上は手が出ない……。ポインタを理解するためにCを諦めてやってみるべきか……。
なにはともあれ今回はここで敗北します。誰かなんか強い人がなんとかしてくれたら嬉しいな！　サヨナラ！とりあえず書いた分は置いておきます。
gist


