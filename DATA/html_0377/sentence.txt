この記事は C# Advent Calendar 2020 の 2 日目の記事です。1 日目は @RyotaMurohoshi さんの C# 9.0で加わったC# Source Generatorと、それで作ったValueObjectGeneratorの紹介 でした。私の記事では、.NET Framework 1.0 の頃の C# 1.0 と今の .NET 5 時代の C# 9.0 で同じお題をもとにプログラムを書いてみて比べてみようと思います。これを書くにあたって事前に xin9le さんと 岩永さんに色々見てもらいました！感謝！ではやってみましょう！
記事を書く前の感覚では LINQ の有無と async/await の有無が大きいだろうな…と思ってます。Windows 10 に .NET Framework 1.1 SDK を入れようと思えば入れることが出来るみたいなのですが、サポートが切れた SDK を入れる勇気がなかったのでサポートされている .NET Framework 4.5 系のプロジェクトで LangVersion 1 を設定したものを .NET Framework 1.0 の頃の気持ちで書いていこうと思います。なので無意識に .NET Framework 1.X の時代には無かった便利クラスを使ってしまっている可能性がありますが、気持ちとしては使わないようにしています。C# 9.0 は .NET 5 のプロジェクトにします。こんな感じのものをイメージしています。C# 1.0 の頃にはジェネリクスはありません。当時は全部 object 型で格納する System.Collections.ArrayList を使います。ただ、それじゃぁあんまりなので System.Collections.Specialized 名前空間に型指定されたコレクションがいくつかあります。今回のような文字列は、よく使われるので StringCollection クラスがあります。それを使って書いてみましょう。うん…まぁこんなもんかな。やはり LINQ が追加されたあたりで追加された機能が強い…。あと、こういう小さなコンソールアプリにおいてはトップレベルステートメントが強い。ローカル関数で Console.ReadLine() を無限シーケンスにして、あとは LINQ で TakeWhile で end まで取得して反転して foreach でループを回して表示しています。LINQ 以降は色々なものを IEnumerable&lt;T&gt; にして LINQ で処理するという考え方でプログラムが組めるようになりました。今回も標準入力を IEnumerable&lt;string&gt; として扱って LINQ で処理することで簡単にかけてますね。このお題で出てきた StringCollection のような型指定されたコレクションですが自作のクラスに関してはもちろん型指定されたクラスは用意されていません。なので自作します。自作といってもコレクションの機能を全部作りこむのは大変なので、System.Collections.CollectionBase というクラスがあって、基本的にはこれを継承して作ります。このクラスの定義部分は以下のような感じになっています。型指定されたコレクション用ってちゃんと書いてありますね。このクラスを継承して、特定のクラス用のコレクションを自作します。とてもめんどくさいです。使う側は普通に使うだけですが、定義する人は辛いです。余談ですが、OSS の .NET 用の IDE の SharpDevelop では、型指定されたコレクションを生成するためのアイテムテンプレートがあったりした記憶があります。もう15年近く前の話なので、うろ覚えになりますが…。アイテムテンプレートが準備されるくらいにはめんどくさい作業でした。今は List&lt;T&gt; って書いたら完了なのは神がかってますね。文字列を追加する AddMessage というメソッドを持ったクラスで "こんにちは"　か "おはようございます" か "こんばんは" が追加されたら Greet という名前のイベントを発火するようなクラスを作って。イベント引数は、その時追加されたメッセージを Message プロパティで取得できるような感じで デリゲートの取り回しもちょっとめんどくさいし、デリゲートを自分で定義するのが当たり前の世界だった。細かいところで便利になってる。冗長な表現が結構消えてる。デリゲートの定義やラムダ式やらなんやら。これを書いてて思ったのは昔は何でもきちんと書いてたなぁということです。
恐らく、この冗長な書き味のせいで当時からライトにかけたスクリプト言語の流行につながっていって、C# や Java のような非スクリプト言語も型を保ったままスクリプト言語ライクにかけるようになる機能が拡充していって今のような感じになったんだろうなぁと思ってます。非同期で https://example.com の HTML をダウンロードする感じです。
プログラムはダウンロードが終わって結果が表示されるまでは終了したらダメです。例外が出たら例外のメッセージを出す感じで。async/await なんてなかった。BeginXXXX で始まるメソッドにコールバックを渡して呼ぶ。コールバックでは EndXXXX というメソッドを呼んで結果を取得するという感じです。Main メソッドは非同期処理が終わるのを待機しないといけないので…セマフォ使いました。久しぶりに使ったよ！
セマフォと、BeginXXXX メソッドを呼んだオブジェクトをコールバックに渡さないといけないけど、コールバックに渡せるステートはオブジェクト1つだけなので、持ちまわりたいものをまとめたクラスも定義しないといけない。
クラスのプロパティには、今みたいな public string Hoge { get; set; } のように簡単に書く方法はなく、必ずフィールドを定義して、それを自前でラップするようなプロパティを定義してあげないといけませんでした。今改めて書くとめんどくさいね！HTTP レスポンスが取れたら、今度は Body を読む処理を非同期でやらないといけない…ワンモアコールバック…。ここでもコールバックにセマフォと、バッファーと Stream を渡したいので、それらをまとめるクラスを定義して…辛い。ということで、以下のようなコードになりました。長い…、実行すると example.com の HTML が標準出力に表示されます。async/await 神かよ…async/await で同期処理と同じように非同期処理が書けるのは神がかってますね。あと HttpClient クラスが便利。C# 9 では、JSON を送受信することを想定したメソッドとかも追加されていて、より使いやすくなってます。.NET Framework 1.0 が出た当初は、コアが複数あるパソコンは一般人が使うものとしてはレアで、モンスターマシンを組むような人の中でも稀に物理的に CPU が 2 個ついてるものがあるかもしれないとかくらいだった気がします。
なので、今回のような IO 待ちに非同期処理を行うのは当時も効果はあったと思うのですが、得られるメリットに対してコードが凄い大変なので、そこまで非同期処理がカジュアルに書かれる感じではなかった印象です。.NET framework 2.0 で重たい計算処理をするような処理を簡単に書くための BackgroundWorker というクラスが提供されましたが、これも IO 待ちの場合は最適な選択なのかどうかは微妙な気がする。その後 Task などが追加されメソッドチェーンで非同期処理を書けるようになったあとに async/await が追加されて今のような形になりました。今じゃぁカジュアルに非同期処理かけていいね！こちらのお題ですが、出来れば GUI アプリケーションから呼んだ時に IO 待ちで UI がブロックされるようなことは避けてほしいという考慮を求められているという感じで行こうと思います。ここで書くのはコンソールアプリですが。ついでに、全サイトを読み込んでから結果を通知ではなく、なるべく 1 サイトのソースをダウンロードするたびに結果が取れるようにしてほしいという感じです。Downloader というクラスにこの機能を実装していきます。C# 1.0 で呼び出し元スレッドをブロックしないようにしようと思ったら別スレッドで処理する方法をとっちゃうと思います。例えそれが IO 待ちで計算が重たいとかではないとしても…。1 つ前の非同期でのダウンロードを C# 1.0 で書いてて心が折れたので妥協します。ということで以下のような感じになりました。urllist.txt は以下のような内容のテキストです。実行してみましょう。ちゃんと取れてますね。こういう非同期処理で複数の値を返すようなものは非同期イテレーターが活きてくる。あと、ちゃんと IO 待ちは IO 待ちでスレッドを無駄にブロックはしない。やっぱ非同期処理系は圧倒的に便利になってますね。ユーザーが入力した 2 つの文字列を、それぞれ整数かどうか判定し条件に応じて以下のようにメッセージを出しわける。今回は非常にシンプルだけど、イメージとしては特定のデータが来た時にルールによって振り分けるありがちな処理です。愚直に書いてみた。おしいね…ルートは共通化できたかもしれないけどいいや。switch 式でパターンマッチが使えるようになったおかげで、事前に判断に必要な情報を整理しておいて、switch 式で分岐が簡単に出来るようになってるのが強い。ちなみに下のコードは、自分が書いたコードを岩永さんに手直ししてもらいました。多謝！if 文になくて switch 式にある特徴としてきちんと条件が網羅されているかどうか、抜け漏れがないかというのをコンパイラがチェックしてくれるというものがあります。
上のプログラムでも、最後を _ =&gt; "まだまだだね" にせずに明示的に (null, null) =&gt; "まだまだだね" にすることで、ちゃんと条件に抜け漏れがないということをコンパイラにチェックしてもらってます（岩永さん談）。なるほどね switch 式便利。ということで、昔を思い出すために C# 1.0 の頃と C# 9.0 の頃とで同じお題をもとにいくつか処理を書いてみました。
ぱっと書いた感想としては、ジェネリクス、LINQ, async/await あたりが結構大きな変化だったのかなと感じました。他にも細かな ?. 演算子や、今回は登場していない ?? や ??= などのような null の時によくやる処理を短く書けるようにしてくれていたり、タプル（値型のほうのタプル）も疑似的に戻り値を複数にしたりとか出来たりなどなど、沢山ありますが今回 C# 1.0 の機能だけに絞ってコードを書いてみて、暫くは書きたくないかな…と思うくらいには不便でした。ということで 12/2 のアドベントカレンダーは以上になります。ありがとうございました。


