Youtubeで"sort algorithms visualized"などと検索すると、
ソートの様子を描いた綺麗なアニメーション動画がヒットします。
今回は、それを真似てコンソールでソートの様子が見えるプログラムを作りたいと思います。
言語はC#ですが、固有の機能（WPFでデータバインドが～とか）は使用せず、
枠組みからムニムニ作りますのでオブジェクト指向型言語であれば同じように作れるかと思います。端的には、コンソールで動くこれ（↓）を作ります（バブルソートしてますね）
ソート処理にて要素の交換が発生した時、その時点の配列の内容を画面に表示、
また要素の交換が発生したら画面をクリアして再び配列の内容を表示・・・。
という処理をソート完了まで繰り返していけば上にあるようなアニメが出来そうです。・・・こう書いてみると、ソートアルゴリズムの中に画面表示の処理を組み込んだら
それで一発完成しそうな雰囲気ですが、折角なのでオブジェクト指向の考え方で作っていきたいと思います。
（何が折角なのかは不明）これっす👇
https://ja.wikipedia.org/wiki/Observer_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3
またはQiitaで検索検索ゥ！！諸先輩方の大変分かりやすい記事がヒットしますヨ。上のリンク内の説明に従うと、
ソートする人　→　通知する側（配列内容を交換する度にその状態をお知らせ）
画面表示する人 →　通知を受ける側（お知らせ内容に従い画面表示）
と置けそうです。左側が通知を受ける側、右側が通知する側になります。
また水色が根幹の仕掛けとなる枠組み（フレームワーク部）で、
黄色が具体的な処理を書く部分（アプリケーション部）になります。
こうして俯瞰的に見てみると、通知する側・される側が相互参照していて
こんがらがりそうなんですがそれは・・・。
まぁ、フレームワーク部から順次作っていきます。。。
各クラスの説明は次章にて♨

クラス図初めて書いたんだけど合ってるんかなこれSystem.ValueTapuleを使用可能にする
すみません。冒頭でC#固有の機能は使わないと書きましたが微妙にウソつきました（ﾍｹｯ！）
何かというと、ソートなので要素の交換は必須処理なのですが、
なぜか.NETの標準にはSwap&lt;T&gt;( ref T a, ref T b )のようなメソッドがなく、
自前で作ったことがある方も多いかと思います。
がしかし、C#7.0から使用可能になったSystem.ValueTapleを使えば
Swap(ryを自前で用意しなくても簡単に要素の交換ができるので、
今回はこれを使って下のように書きたいと思います。使用するためにはNugetからゲトってインストールする必要があります。
画面表示用のメソッドを作成する
Observerパターンとは直接関係ないので切り離してここに記載しました。
アニメーションでの一コマ相当を画面に表示する静的クラス＆メソッドです。
一旦画面をクリアしてから描きたいものを表示、それからちょっとタイム。
以降も呼び出される度にクリア→表示→タイムでアニメの再現・・・ってとこです。
タイムを設けているのは、これが無いと目視不可能な程の爆速でアニメが終了し
ﾎﾟｶｰﾝ(　ﾟдﾟ)となってしまうからです。クラス同士の関係を分かりやすくするため共通の絵文字をタイトルに付けました。
同じ絵文字がついているものは派生元・派生先同士、
インターフェースの定義・実装同士ってことです。
 ： 通知する側
 ： 通知を受ける側通知する側が備えておくべき機能を持たせた抽象クラスです。
ここから具象クラスをﾆｮｷﾆｮｷ派生させてそこへやりたい処理を書きます。
通知を受ける側への参照をリスト(observers)で複数持っているのは、
例えばGUIなら複数のコントロールに一斉に状態変更を知らせたい時があるためです。
今回は通知する相手が一人なので死に機能なんですけどね（ﾍｹｯ！）
細けぇこたぁ(ryソースコード中のコメントをご参照くださいませ。m(_ _)mインターフェースの定義なのでこれだけです。
読んでも「で？」って感じなので次ィ・・・。すみません、また微妙にウソついてます（ﾍｹｯ！）具体的な処理を書くということで、
👆のObservableクラス（抽象）から直接バブルソートにあたるクラス（具象）を
派生させてもよかったのですが、例えばXXXソートを増やしたい場合、
同じ処理を何度も書くのはダルいし読んでいてうざいので共通化出来るプロパティ・
メソッドを抽出しここに抽象クラスとしてまとめました。
（抽象クラスにしたのはこいつをnew()!!でインスタンス化されてもしょーもない為）ただ、単に処理を共通化したいからという理由で上位クラスに抽出し派生させるのは
良くない説もあり（is-a関係がとれているか？など継承は本当に難しい）、
この時点でほのかに糞の香りがしていますが、かといって
合成で実現するのも違和感があるためもうこれで押し通します。
これにて通知する側は三段階派生することになりました。Observableクラス（抽象）
　　↓
SortExecutableクラス（抽象）←今ココ
　　↓
XXXSortExecutableクラス（具象）んでソースコードです。例により細けぇこたぁ(ryコメントで書いていますが、
肝はItemsプロパティのSetにてNotifyObservers()を呼んでいる箇所で、
これが自分自身の状態変更を知らせる＝通知を受け取る側に仕事をさせるトリガーです。
NotifyObservers()内で登録している全IObserverにUpdate()（仕事しろ)の指示を出しています。これが最終派生クラスになります。通知する仕組みは派生元に定義済みなので、
あとはSort()メソッド内にバブルソートのアルゴリズムを書くだけでおｋ。
要素の交換が発生した直後にItemプロパティを更新することにより交換直後の配列の状態を
通知を受け取る側へお知らせしています。
（★ココ！で通知を受ける側へ状態変更を知らせるのコメントの箇所）👆のBubbleSortExecutableから間接的にUpdate()をぶっ叩かれて
画面表示をするクラスです。
これ自体は大したことをしていないので、通知側する側からの処理の流れをまとめると、…とこんな感じです。各メソッドの定義が色んなファイルに散っているので
パッと見で処理を追いづらいですね。複雑な仕掛けは各クラスの裏側に隠れているので、呼び出し側はこんなあっさり風味です。
今回は直接オブジェクトをnew()!!して生成していますが、
通知を受ける側sortObserverのDataSourceに通知する側bubbleSortを設定し忘れると、
「何も動かねぇ・・・」状態になるので、一連の生成処理をファクトリメソッドにまとめても良いかもしれません。「Ctrl」+「F5」で実行すると、冒頭でお見せしたバブルソートのアニメーションが
コンソールに表示されるハズです。
・・・が、けっこうチラつきます。調べたところConsole.ほにゃらら()を駆使すれば
回避出来るっぽいのですが、今回はこれで許し亭♨GitHubにプロジェクトを丸ごと置きました。もしよければ弄ってやって下さい。
SortVisualizer〇〇〇ソートを追加する
SortExecutableクラスから派生させた先でソートのアルゴリズムを書くだけで
容易に追加が出来そうです。GUIアプリとして作る
コンソール表示からフォームへの表示になるため、通知を受け取る側は
ゴミ箱逝き不可避ですが、通知する側は再利用できそうです。
もっとも、C#には変更通知の機能が備わっているためそちらを使うのが正道でしょうが。。。記事が無駄に長くなってしまった感が。
今回はぷちプログラムのためやってる内容に対して
ソース全体が大げさになってしまいましたが、
ある程度の規模以上になるとオブジェクト指向の良さが表れてくると思いました。小生は、実務経験はほぼほぼ素のC言語でやってきたので、
オブジェクト指向の考え方、実装としておかしい点、説明不足などあれば
ご指摘・アドバイス頂けると大変うれしく存じます。それでは、アディオス！！


