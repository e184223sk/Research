More than 1 year has passed since last update..NET用の2-way SQLライブラリを作ってみた系の記事だよ。まず、データベースに対するクエリの構築にどんな手法を用いるかについて考えてみます。っというわけで、.NET以外の世界ではOuteside/2-way SQLなライブラリがよく使用されていたりもすると思います。
.NETの世界でも、自分達だけで使うものを個々に作っている例は観測できますが、定番品というのはないように思います。以上のような背景を踏まえ、自分も作ってみることにしました。
どうせなら、自分なりに偏った方針でやってみたろ、っということで、以下のような方針で実装をしてみました。以下のようなinterfaceとSQLファイルを用意します。SQLファイルのは名称はクラス名+メソッド名ベースで、interfaceのソースファイルがあるフォルダのSqlサブフォルダ下に配置します。
なお、InsertメソッドについてはSQLファイルがありませんが、これはInsertAttributeが定型SQLを自動生成するためです。あと、クエリの実行結果用の入れ物を用意しておきます。使用例は以下のようになります。以下の種類のコメントをサポートしています。IList型のIN句への展開にも対応しています。生パラメータ部分は、C#の引数がそのままSQLの文字列として展開されます。コードブロックはC#で記述します。コードブロックで使用するC#のコード用に以下のようなプラグマを用意しています。/*!using */を使用するとその名前空間のクラスが使用できるようになります。
標準ではSystemとSystem.Linq名前空間のクラスが使用できるようになっています。/*!using */を使用するとusing staticの意味になります。
コードブロックの記述が行いやすいように、ヘルパークラスのインポートに使用します。標準で以下のヘルパークラスがビルトインされています。DataAccessorAttributeを付加したinterfaceが自動生成の対象となり、メソッドに付加した属性により処理の実装が構築されます。メソッドの属性としては以下のものを用意しています。QueryAttributeは戻り値がListの場合は即時評価、IEnumerableの場合は遅延評価になります。メソッドの戻り値がTaskの場合、処理は非同期処理として構築されます。また、メソッドの引数にCancellationTokenを追加すると、非同期処理内ではそのCancellationTokenが使用されます。処理で使用されるコネクションは設定で登録されたIDbProviderが使用されます。以下のようにIDbProviderSelectorを登録することで、複数のコネクションを使い分けることも可能です。どのIDbProviderを使用するかはProviderAttributeで指定しますまた、メソッドの引数にDbConnectionを追加すると、そのコネクションが使用されるようになります。同様にDbTransactionを追加すると、そのトランザクション(コネクションはトランザクションのコネクション)が使用されます。TimeoutAttribute付きの引数を追加すると、CommandTimeoutにその値が設定されます。引数ではなくメソッドにCommandTimeoutAttributeを付加することで固定値の設定もできます。クエリ結果のオブジェクトへのマッピングについて、標準の実装ではオブジェクトの名称が一致(完全一致を優先)するプロパティに対して値が設定されます。プロパティ単位でルールを変更したい場合にはNameAttributeを付加します。
また、マッピング対象にしたくない属性にはIgnoreAttributeを付加します。なお、対象となるプロパティを選択するIPropertySelectorの実装を差し替えることで、名称のマッチングルール自体を変更することも可能です。また、IResultMapperFactoryの実装を用意することで、クエリ結果の処理自体のカスタマイズも可能になっています。ParameterBuilderAttribute派生クラスを使用することでDbParameterに設定されるプロパティをカスタマイズすることができます。標準ではDbType.AnsiString/DbType.AnsiStringFixedLengthを設定するAnsiStringAttribute等を用意しています。また、以下のように型に対する標準ルールの変更も可能です。実行結果の型の変換についてはResultParserAttribute派生クラスを使用することカスタマイズが可能です。また、ITypeHandlerの実装を登録しておくことでDbParameterの作成と実行結果の型変換の標準ルールを変更することもできます。なお、現在の実装の制限事項として、パラメータ/戻り値の型ハンドルが適用されるのは、メソッドの引数またはメソッドの引数のプロパティまでとなっています。ProcedureAttributeをメソッドに指定すると、ストアドプロシージャの実行ができます。ProcedureAttributeではSQLファイルは不要です。引数をrefやoutにすることでストアドプロシージャのIN/OUTに対応できます。
また、InputAttribute等をプロパティに付加したパラメータクラスを使用することもできます。Outside SQLを使うとしても、INSERT文などの定型文まで全てSQLファイルを用意するのは面倒くさいです。
そこで、定型SQLを自動生成する仕組みを用意しています。MethodAttribute派生クラスを用意し、GetNodes()メソッドで以下のような実装を行うことでMethodInfoを元にしたSQLの自動生成が可能です。このような形で実装したMethodAttribute派生クラスは、メソッドに対して以下のように適用するだけでよく、SQLファイルの作成は不要となります。なお、標準では基本処理としてInsertAttribute、CountAttribute、SelectAttribute、SelectSingleAttribute等を用意してあります。
また、対象DBMS毎の方言に対応したUPSERT等の実装もオプションで用意してあります。以下のように使用できるMicrosoft.Extensions.DependencyInjection連携機能も用意しています。Microsoft.Extensions.DependencyInjectionを使用する代わりに自前のResolverとの連携機能も用意しています。自前Resolverとの連携機能を使用して、複数のデータソースを扱う場合の例は以下のようになります。自前Resolverとの連携を使用する場合のメリットは以下になります。まあ、まだ実験的な面の強いライブラリです(´・ω・`)
実用的かどうかはこれから検証してみるぽ。それと、このライブラリのコード生成に使用している仕組みについてもまとめておきたいです。
っというか、この記事はその前段階として書いてみたものだったりして( ˙ω˙)立派な建前はさておき、このライブラリを作ってみることにした出発点の一つとして、コード生成のメタ情報取得にRoslyn(SemanticModel)やMono.CecilのAPIを覚えるのも面倒くさいから、使い慣れたリフレクションAPIを使えないかな？、っというのがあったりするんですが。
その他、ビルド時の成果物生成のカスタマイズ方法について、調査した内容がコード生成用ビルド設定の基盤になっていたり、Dapperの代わりにXamarin.Formsで使う事を目的として用意したMicro-ORMの応用だったりだとか、色々な調査や応用のまとめとして生まれたのがこのライブラリなのでした。


