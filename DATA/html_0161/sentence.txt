Prism.Unity の環境で アプリ終了時に DIコンテナ の登録インスタンスを Dispose したく、UnityContainer のライフサイクル について調査した記事です。ゲームエンジンの "unity" とは全く関係ありません。本記事の大半は Prism.Unity 限定ではなく、UnityContainer で共通の内容です。私は業務で稀に WPF アプリを作る機会があり、その際は Prism + UnityContainer をベースに開発しています。Prism では UnityContainer 以外にもいくつかの DIライブラリ（Autofac, Ninject, DryIoc）  をサポートおり、特別 UnityContainer に拘っていないのですが「Microsoft が関わっていた」との理由から なんとなーくで選んでいます。と言っても私の場合は、ModelクラスのいくつかをDIコンテナに登録する程度のライトな用途なので、Prism が提供してくれているインターフェイス越しの操作で十分でした。先日、アプリ終了時に DIコンテナに登録したインスタンスを Dispose したい 機会があり、Prism提供の共通インターフェイス に物足りなさを感じましたので、正月休みを利用して UnityContainer の ライフサイクル を調査してみました。かずき先生が Prism 7.x で DI コンテナ固有の機能を使いたい にて詳しくまとめて下さっていますので、そちらに案内させて頂きます。毎度お世話になっております🙇‍♂️UnityContainer への登録方法は大きく分けて 3つ あります。何れもDIコンテナの一般的な概念だと思いますので詳細は割愛します。今回は最もベタな登録方法だと思われる 『1.型からの登録』のライフサイクルのみを調査しました。型登録時のライフサイクルは、RegisterType&lt;T&gt;() の引数 ITypeLifetimeManager lifetimeManager から指定できます。以降は  ITypeLifetimeManager の取得メソッドを提供する static class TypeLifetime のメソッド名でまとめてみました。(TypeLifetimeクラスのソースコード)丸括弧は取得メソッドから返却される実クラス名です。それでは順に見ていきましょう。Resolve&lt;T&gt;() の呼び出しの度に、新しいインスタンスが生成されて返却されます。RegisterType&lt;T&gt;() のデフォルトのライフタイムで、ライフタイムを管理しないことと同義です。ガチのシングルトンです。後続の Resolve&lt;T&gt;() の呼び出し や コンストラクタインジェクションなどのインスタンス挿入で 同一インスタンスが返却されます。RegisterType&lt;T&gt;() の登録結果は コンテナの親子ツリー全体に反映されます。（子コンテナ に登録した場合、ルート親コンテナに登録されます。）コンテナが生成したインスタンスの参照を保持します。インスタンスが IDisposable を継承している場合、コンテナ自体の Dispose() 時に保持インスタンスを Dispose してくれます。登録済みの型を再登録した場合は、新しい登録が優先されます。Singleton と同じ挙動です。こちらが Singleton の基底クラスであり、Singletonクラスは実装がほぼ空なので (ソースコード)、迷った場合はこちらを使用しましょう。ちなみに、RegisterSingleton&lt;T&gt;() のライフタイム にも Singleton ではなく、こちらが指定されています。(ソースコード)Transient と同様に Resolve&lt;T&gt;() の呼び出しの度に、新しいインスタンスが生成されて返却されます。Transient の違いとして（PerContainer と同様に）コンテナが生成したインスタンスの参照を保持します。同一のコンテナであれば PerContainer と同じ挙動です。（シングルトン、参照保持）PerContainer との違いとして、親コンテナ と 各子コンテナ で情報が共有されません。Resolve&lt;T&gt;() を呼び出したコンテナに対応するインスタンスが返却されます。1回の解決呼び出し中だけインスタンスへの参照を保持します。文字での説明が難しいのですが、下記の依存関係の場合に ClassC を生成した場合、"ClassB 内の ClassA"  と "ClassC 内の ClassA"  を同一インスタンスにしてくれます。スレッドごとのシングルトンです。参照は保持されません。コンテナを Dispose() しても各インスタンスは Dispose されません。Prism の DIコンテナ インターフェイスである IContainerRegistry を使用して登録した場合に、UnityContainer のどの Lifetime が使用されるかを整理しました。ソースコードここまでのライフサイクル調査のおかげで、RegisterSingleton&lt;T&gt;() と RegisterScoped&lt;T&gt;() の場合、アプリ終了時に DIコンテナ自体 を Dispose() することで、参照を保持しているインスタンス達 を Dispose してくれることが分かりました。少しやっつけですが、以下の実装で良いかと思われます。Register&lt;T&gt;() （Transient）の場合は DIコンテナが何もしてくれないので、Resolve&lt;T&gt;() でインスタンスを取得した人が Dispose を行う必要があります。Prism.Unity の環境で アプリ終了時に DIコンテナ の登録インスタンスを Dispose するため、UnityContainer のライフサイクル について調査しました。もう少し詳しく調べたい部分もあり 後ろ髪を引かれましたが、年内に完了させてスッキリしたく公開しました。それでは良いお年を🎍VisualStudio 2019 16.8.3.NET 5.0 + C# 9.0Prism.Unity 8.0.0.1909Unity.Container 5.11.9Lifetime - UnityContainerUnity Container - GitHubDisposing needed in Unity? - stackoverflowPRISM/Unity IDisposable - stackoverflowPrism 7.x で DI コンテナ固有の機能を使いたい


