More than 3 years have passed since last update.WindowsにおけるHIDデバイスの扱いに関する話題です。
結論だけまとめると「Windows10 IoT Core向けにC#でHIDデバイスを扱うコードを書いたけど、デスクトップ上ではHIDが開けなかったのにRaspberry Pi3上では開けた ｲﾐﾌ」という話です。
個人的な振り返りとして記録したいと思います。通常、WindowsのアプリケーションでHIDを扱う場合、setupapi.dllとhid.dllをリンクして、
いてこますのが普通だと思います。
なので win32API アプリとしてC/C++で開発することになります(以下、便宜上VC++アプリと表現します)。P/Invoke とかいう仕組を使えば .NET アプリからもこれらDLLのAPIを呼び出して使えました。
HIDを扱うためのAPIをC#クラスでラップした ライブラリ も存在します。
通常の Windows PC 上であれば互換性などを特に気にすること無く使うことができました。ところで、Windows 10 IoT Core が登場しました。大雑把に言えば、ラズパイでC#コードが動くようになりました。
基本的にアプリケーションは Universal Windows Platform という基盤のうえで作成するようです。
UWPアプリからのネイティブ関数コールが果たして可能なのかどうなのか、ちょっと調べただけではよく分かりませんでした。
仮に出来たとしてもおそらく Universal なものにならないだろうとは予想できます。前置きが長くなりましたが、UWP のライブラリAPIにははじめからWindows.Devices.HumanInterfaceDevice名前空間が定義されていて、許可されているものに限り(後述)HIDデバイスにアクセスできるようになっています。
UWP 上で HIDデバイスを扱うにあたり、VC++ との比較や、注意点などを記録したいと思います。Raspberry Pi3 に Windows 10 IoT Core をインストールしてみたので、UWPアプリケーションから接続されたHIDデバイスにアクセスしてみたいと思います。先に、VC++でHIDデバイスにどのようにアクセスしていたか、おさらいします。
まずはデバイスパスを列挙します。tchar.h 絡みの部分は適当に読み替えて下さい。
ほとんどの場合は内製ライブラリの中に押し込んでしまうのでいちいち意識することはありませんが、ここでやっているのはsetupapi.dll にお願いしてHIDインターフェースを列挙してもらう処理です。
GUID部分を置き換えてやれば「USBホストコントローラのパスのみを列挙」などといったことも出来ます。取得したデバイスパスからファイルハンドルを開きます。ファイルハンドルが開けたら、ココ に挙げられた関数を経由してHIDデバイスへのアクセスが可能になります。
  HidD_* 関数は主にデバイスの制御や情報取得を、HidP_* 関数は主にHIDレポートのパース処理をそれぞれ行います。では開いたHIDデバイスの VendorIDとProductID や トップコレクションのUsagePageとUsageを確認してみます。パスを列挙したHIDデバイスについては、それらが目的のものかどうかこれらの上記のデバイス情報を確認してから具体的な操作を行うことになります。それと HidD_* 関数はすべて同期処理であるため、HidD_GetInputReport 、HidD_SetOutputReport 関数の代わりに普通のファイル操作APIの Read , Write 関数を使うことの方が一般的なようです。では、UWPで同じことをやってみたいと思います。「久々のC#、変わり過ぎ・・・」「XAMLぜんぜんわからん・・・」「MVVMってどういうこと・・・」
といった個人的な戸惑いや苦しみがありましたが、ここでは割愛します。まずはHIDを列挙してみます。
最初にSelectorという文字列を生成します。HidDevice.GetDeviceSelector は目的とするHIDデバイスを探すための呪文を生成するstatic関数で、むりやりhid.dllから似た関数を挙げるとしたらHidD_GetHidGuidあたりになるでしょうか。 戻り値の文字列の中身は「GUIDがコレコレで、現在接続されていて、基本情報がコレコレのデバイスをおくれ」というクエリ状の何かです。
文字列を直接書いても使えますが、UWP特有の事情(後述)によりHIDに限って言えばSelectorの中身を気にしてもあまり面白いことはなさそうです。SelectorをDeviceInformationクラスに渡すと、ファイルパス(UWPではIDと呼ぶ)も含むデバイス情報を列挙してくれます。これはsetupapi.dllでいうところのSetupDiEnumDeviceInterfaces 関数にあたるでしょうか。
なぜか非同期呼び出しです。理由を考えるに、引数なしの DeviceInformation.FindAllAsync() が「これまでPCに接続されたことのあるすべてのデバイスの情報」を列挙するため、とても時間がかかるからではないかと。とまあ、これだけの記述でデバイスパスが列挙できてしまったことになります。デバイスを開いて、先程のデバイス情報を確認してみます。なんと、たったこれだけの記述でHIDのAttributesやCappabilitiesに相当する情報が取得できてしm・・・・・・うまくいきません。UWPでは無条件にHIDデバイスにアクセスできるわけではなかったのです。
どうやらソリューション内に自動生成される Package.appxmanifest ファイルを編集する必要が有るようです。HID デバイスにアクセスする Windows ランタイム アプリでは、そのマニフェストの Capabilities ノードに特定の DeviceCapability データが含まれている必要があります。参考: HID のデバイス機能を指定する方法 (Windows ランタイム アプリ)さらに、Capabilities に追記すれば何でもかんでも使えるようになるわけでもないようです。他の Windows API や OS の動作との競合を避けるために、次の利用状況ページで表される最上位のアプリケーション コレクションをブロックします。
- HID_USAGE_PAGE_UNDEFINED
- HID_USAGE_PAGE_GENERIC
- HID_USAGE_GENERIC_KEYBOARD
- ...(以下略)参考:ヒューマン インターフェイス デバイス (XAML) のサポート基本的に、DeviceCapability には VendorID, ProductID, UsagePage, Usage の4つすべての値を指定する必要がありそうです。
&lt;Device Id="any"&gt; や &lt;Function Type="usage:ff00 *"/&gt; といった指定が可能とは書いてありますが、
具体的にどのような条件においてこのようなワイルド指定が有効になるのか分かりません(ビルドしても実行できない)。いちおうデバッグ用のトレース処理や例外処理も追記してみました。さて、これでどうでしょう・・・？・・・？？？？Raspberry Pi3 上で同じコードを実行するとすんなり開けました。これで当初の目的は果たせたのカモしれませんが、デスクトップでも同じコードが同じように走ってくれないとデバッグの効率が悪いです。Windows.Devices.HumanInterfaceDeviceのバグなのかなあ、解せないなあ・・・。


