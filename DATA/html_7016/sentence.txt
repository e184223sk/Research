More than 3 years have passed since last update.Rxが流行っています。
UnityにもUniRxという移植があります。
こちらかAssetStoreから簡単に入れることができます。
https://github.com/neuecc/UniRxグラニのCTOの人が作ったのできっと内部ではバリバリ使われているのでしょううらやましい。最新は5.4.0かな
http://neue.cc/2016/08/03_536.htmlRx自体つかいこなせるなら何も考えることなく脳死で突っ込めばOKなんですけれど、慣れていない場合どこから使い始めればいいの？
という問題があります。概念も難しいしスキルキャップが高いのでとても便利なのですが反面導入を躊躇してしまうこともあるでしょう。
ただ、やっぱり使いこなせると最高に便利なツールの一つなので是非もなく導入してほしいという気持ちがあります。というわけですぐ使えるUniRxの使い方をいくつか紹介したいと思います。この記事の趣旨は
使おうと思ってるけど使い方がわからない人向けに簡単にできる置き換えをいくつか紹介する
ことです。取り合えず食べてみて！おいしいから！っていう試食みたいな記事です。このセクションではすぐに使えるUniRxの使い方を紹介します。コルーチンをIObservable化(Rxの基本のインターフェイス)するといくつかのメリットがあります。
普通コルーチンはこんな感じで使うのかなと思います。この書き方だといくつか気になる部分があります。このような問題に対してUniRxは一つの解決策になります。もしも使う側が慣れていないのであればObservable.FromCoroutine(Coroutine)をメソッド化してしまうのもよいと思います。
この場合CoroutineAsyncとかが名前としてはお勧めです。チュートリアルなどで、実装の課題となるポイントの一つにある機能を封印したいなということがあるかと思います。
逆に、機能の開放などで機能を追加したいときもあるでしょう。（そして未開放の時は何章開放したら見れるよ！みたいな）
つまり動的にボタンの機能を変えたいパターンというのがあります。いくつかの方法はあると思うのですが、一番素直な方法はif文を使って分岐することでしょう。
例えばこんなメソッドを作ってuGUIのボタンに登録するわけです。これの問題はこんなところでしょうかこれの解決策もやはりいくつかあるのですがUniRxでの解決策はこんなところです。
これをStartメソッドか呼び出します。これだけならeventでできるのですが、ほかにもいろいろなタイミングを登録できます。
（毎アップデート事とかボタンがenableになったときとかUnityが用意しているタイミングならほぼ網羅しています）初期化の関係メソッドの数秒後に何かをしたいです。
でもコルーチンはちょっとめんどくさい…というときにUniRxだと簡単に数秒後の処理を書くことができます。アップデートメソッドの最初の1フレーム目だけ何かをする
たまーにタイミングの関係でどうしてもやらなくてはいけなくなるこんな処理
どう頑張ってもStartとかだとうまく動かないどうしてもUpdateがいいんだ！普通に書くとこんな感じ
やっぱりアップデート事のif文って気持ち悪いし…可読性もよくない気がする…UniRxだとStart時にアップデートの最初の一回だけ処理をすることを登録するということもできますちなみに
Observable.EveryUpdate().Subscribe(～)だと毎回アップデート事に～が実行されます。基本的にRxはイベント処理の上位互換にあたるライブラリだと考えてください。
そのうえで上記のように最初の一回だけや、最初のn回はスキップするなどのフィルターをかけることができます。
そしてその記述方法はLINQのよくあるメソッド+Rxならではのいくつかのメソッドになります。実はこの用途には「Observable.NextFrame」という専用ものがあるみたいです。
とりあえず例ということでおいておきますこれ個人的にはすごい利点なんですけれど、Rxではすべて先頭のIObservableを作成するメソッド自体は違ってもそのあとの書き方は一緒です。
基本的にはこの形になります。この形さえ覚えてもらえればいろいろな応用が利きます。ですので、特に話し合いなどしなくても書き方が統一されるというメリットがあります。UniRxのちょっと変わった使い方になりますが地味に便利な機能としてSchedulerというものがあります
　※内部ではバリバリ使ってるんですよこれの使い道ですが、例えば入力データなどの状況によって同期的にやるか別スレッドで実行するかを選択したい場面があるかもしれません。
そういったときにこのScheduler は「いつ」「どのように」処理を実行するかを指定できるものです。Scheduler.ThreadPoolなどはISchedulerのオブジェクトなので引数にもできますし、if文で分岐させることも簡単です。
もちろんIObservableと一緒に使われることが想定されているので組み合わせると強力です。ObservableWWWというのがあります。（ただしWWWをいまからつかうべきかは）細部は違ってもいろいろな言語にRxは移植されていますのでいろいろな言語で同じシステムが使えます。使い方によってはこんなことが普通に書くより少し簡単にできますゲームのカウントダウン⇒スタートの制御
アイテムを選んだらその説明が説明欄に出てくる
ファイルの読み込み時の定型文(using)とかを省略できるようにする
HPが25%を切ったらHPバーを赤くするUniRxはとても便利で強力なのですが一つだけ注意しなければいけないことがあります。
それはUniRxが少しだけ重い処理だということです。1Frameに何度もObservableのインスタンスが生成されるような感じで使うと死にます。
オペレータ一回でインスタンス一つ生成するパターンもあるのでバチバチにチューニングしたいところでは注意が必要かもしれません。一方で得意な部分はUIなどのメッセージパッシングや1frameに1回などのあまり大きな処理をしない部分。非同期処理をしたい通信やIOなどの部分、などある程度UniRx自身の重さが無視できる部分では強力なツールになりえます。UniRx入門 その1
http://qiita.com/toRisouP/items/2f1643e344c741dd94f8Rx再入門
http://blog.okazuki.jp/entry/20111031/1320072227UniRxのシンプルなサンプルの取扱説明書（自分が書いたやつだから入れたくなっただけ）
http://qiita.com/Marimoiro/items/b0c66c6c22cf58bde049


