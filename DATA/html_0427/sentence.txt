自学でデザインパターンや設計を勉強してもなかなか定着しなかったのですが、お客様先（常駐している現場）の上司に教えてもらって一気に理解が進んだので備忘録として残しておこうと思います。OCPとはSOLID原則の1つであり、「クラスは拡張に対して開かれており、修正（変更）に対しては閉じていなければならない」という考え方です。つまり「新しい機能を追加する（拡張）場合は既存の機能のことを考える必要なく（それぞれの機能が独立している）、既存機能を修正・変更する際は他に依存しないような作りにする」ということです。と言っても言葉だけではやはり理解ができません。。。
そこでサンプルコードを書いてみました。
以下はASP.NET Core コンソールアプリで渡されたアプリケーション引数によって犬か猫の鳴き声を表示させるプログラムです。一見、よく見るパターンです。
僕もよくこんな感じで書いちゃっていましたが、これだと例えば鳥の鳴き声を表示する機能を作る際にAnimalクラスに鳥の鳴き声の関数を、ProgramクラスのSwitchの中に鳥の場合を足していかなければいけません。
このサンプルだと「それくらい余裕でしょ！」といけますが、実際に業務で扱うプログラムはこんなに単純ではないのでミスが増える可能性が高まります。そこで、OCP原則に基づいたコードに変えてみましょう。
インターフェースを用いて以下のように作成します。（DIやFirstOrDefaultのデフォルト時にDogServiceとなっているのは一旦置いておきましょう）こちらではDIで配列として渡ってきたanimalServicesのPatternとアプリケーション引数を比較してサービスを求めています。
"Pattern"はDogServiceクラス、CatServiceクラスでそれぞれ定義しています。このプログラムだと先ほどと同じように新しく鳥の鳴き声を表示させる機能を作る場合にProgramクラスをいじる必要はありません。
IAnimalServiceインターフェースを継承して鳥のサービスクラスを作るだけでOKです。
(DIコンテナに鳴き声クラスを登録する必要はありますが...)日々の仕様変更に耐えるためにも保守性を意識したプログラムは大切だなと思うのでしっかり理解を深めていきたいところです。


