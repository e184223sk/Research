More than 1 year has passed since last update.世界のパスワード問題を解決し、パスワードのない世界 を目指して策定されたFIDO規格。
FIDO2のWebAuthn-JavaScriptを各社のウェブブラウザが実装したことでWeb認証はもはやFIDOがスタンダードです。
FIDO2のセキュリティキーは 堅牢 かつ パスワードがいらないシンプルな操作 でログインすることができます。一方で　デジタルガバメント を目指して策定されたGPKI、JPKI。
マイナンバーカードは券面に個人情報印刷しまくりで、人に見せてはいけない、という意味不明のアナウンスで絶賛普及推進中。
・・・何やっても全く普及せず、ひたすら残念な状況のマイナンバーカードですが、ICカードの中の仕組みはちゃんとしていて、認証だけでなく電子署名の機能も備えています。つまりログインだけでなく、電子文書へのデジタル署名（電子的な実印）を作成することができます。カード中の秘密鍵はセキュアに保護されており、外に出すことのできる公開鍵はスキャンされても問題ない、マイナンバーカードの機能は携帯する個人認証デバイスとしてはとってもいいものなのです。こうやって見るとFIDO2セキュリティキーで電子署名ができれば最強では。というわけで、この投稿ではFIDO2セキュリティキーで電子署名をする、というツッコミどころ満載な試みにトライしてみました。要はFIDO2セキュリティキーを使った電子署名のプログラムを作成する、ということです。
セキュリティキーは指紋スキャナの付いたBioPassを使いますが、BioPassでないといけない、ということはありません。YubikeyなどFIDO2のAuthenticatorであればOKです。OSはWindows、言語はC#、暗号化ライブラリはBouncy Castle、セキュリティキーの制御はWebAuthnModokiDesktopを使います。おおざっぱに以下の構成です。Phase
- Administrator-Register
- User-Register
- Signature
- VeriyActor
- システム管理者
- ユーザー
- マネージャ株式会社GEBOは三文判による紙の社内文書の運用から電子署名運用に切り替えました。という体で。
- システム管理者＝社内システム担当：下暮田
- ユーザー＝新入社員：ゲボ子
- マネージャ＝ゲボ子の上司：毛保川情報処理室の社内システム担当：下暮田さんは本日入社する社員のゲボ子さんに渡すセキュリティキーを作成します。
セキュリティキー(BioPass）は新品のものを使いますが、念のために初期化しておきましょう。
初期化はBio Pass FIDO2 Managerというメーカー提供のツールでリセットしておきます。(Microsoft StoreからGETできます）
登録はGeboSigRegisterというアプリで行います。RSA-1024bitキーペアを生成します。
Bouncy CastleのAPIを使います。
※Bouncy Castleはusingの追加がたくさん必要なので、Alt+Enterでどんどん追加していきましょう。Bouncy CastleのPemWriterを使えば簡単です。少しでもサイズを小さくしたいのでDERにします。これはBouncy CastleのAPIが見つからず、定番の方法(?)でやります。Bouncy Castleを使います。
こちらの素晴らしいサンプルをコピペさせていただきました
https://kagasu.hatenablog.com/entry/2017/01/04/213533keyとivは普通はオープンにしてはいけませんよ。初期PINをセットします。
USBにセキュリティキーを挿してから、WebAuthnModokiDesktopのAPIで一発です。さて、登録のヤマ場です。
FIDO2セキュリティキーにどうやって秘密鍵を書き込むのか、ですが、ResidentKeyの機能を利用します。
ResidentKeyはRPのユーザー情報を書き込むための機能で、秘密鍵などというものを書き込むための機能ではありません。 なのですが、やってみましょう。※注意※
この制限はFIDOとかCTAPの仕様によるものではないと思われますので、モノによってこの通りでないと思われます。実際に試したところ、1回で書き込める情報は以下の通りでした。
- UserID領域に64byte（byte型）
- UserName領域に64文字（string型）
- DisplayName領域に64文字（string型）これ以上のデータを書き込もうするとエラーになります。string型は1byteを2文字のHEXにすればいいか、ということで、64byte+32byte(64文字)+32byte(64文字)の合計128byteを1回で書き込むことができます。
でありますため、何回かに分けて書き込むことにします。1回に書き込むデータを1レコードとして、レコードの構造は以下の通り。先ほど作成した秘密鍵(AES256で暗号化したもの）は640byteでした。
これだと6レコードになります。
6回に分けて書き込みます。書き込み自体はWebAuthnModokiDesktopのAPIを使えば簡単です。
- 引数pinはさっき設定した初期PINを指定します。
- 引数recはこんなかんじ
- BioBassだと1回の書き込みにつきUser Presenceのチェックが走るのでキーがピカピカ光ってタッチが必要です、つまり、6回タッチしないいけないです。
- これがNFCタイプ(例えばYubikey5）だとUser Presenceがされないのでいちいちタッチする必要がなく快適です。最後に秘密鍵のペアとなる公開鍵の処理です。
公開鍵のままでも別にいいんですけど、せっかくなので(?)X.509形式の証明書にしておきましょう。
Bouncy CastleのAPIなら簡単です。
※自己署名なんで、証明書の意味はないです。
- 証明書のCNには対象者のゲボ子さんの情報を入れておきます。
- 証明書は本日より10年間有効です。
- 証明書に今作成したキーペアの公開鍵を格納し、自分自身の秘密鍵で署名します。
- 証明書はPEM形式で作成します。
- 作成した証明書は保管しておきます。本ユースケースでは社内のRepositoryで保管することにします。下暮田さんの作業です。
- 生成されたゲボ子さん用の証明書(geboko.crt）は社内のRepositoryにしまいます。
- 初期化が済んだセキュリティキーをゲボ子さんに渡します。システム管理者：下暮田さんから自分用のセキュリティキーを受け取ったゲボ子さんは自分用の初期設定をします。
- PINの変更
- 指紋登録PINの変更はGeboSigChangePINというアプリで行います。WebAuthnMODOKIDesktopのAPIで一発です。指紋登録はBio Pass FIDO2 Managerというメーカー提供のツールで行います。(Microsoft StoreからGETできます）
これでこのセキュリティキーのPINを知っているのはゲボ子さんだけす。指紋もゲボ子さんのものを登録しているので、セキュリティキーを使えるのはゲボ子さんだけ、ということになります。ここからが通常運用です。
ゲボ子さんは社内用の報告書を作成しました。上司に電子署名付きのファイル（報告書）を送ります。署名はGeboSigSignatureというアプリで行います。セキュリティキーの中から(暗号化された)秘密鍵を取り出します。
セキュリティキーのアクセスはUV-指紋認証です。つまり ゲボ子さん本人 しかアクセスできません。
非常用でPINでのアクセスもできるようにしとかないといけないですが、PINも本人しか知らないはずです。秘密鍵はセキュリティキーの中に複数レコードに分割して書き込みました。
セキュリティキーからレコード情報を取りだすのはWebAuthnModokiDesktopのAPIで一発です。
取り出したデータのUserID、UserName、DisplayNameを格納時と逆の方法でつなぎ合わせてbyte配列にします。
- 戻り値ReadDataはこんなかんじ
- credentialid は使わないので空です。
- 指紋認証なのでuserVerification : 'preferred'にしますさて、取り出した秘密鍵はAES256で暗号化されているので復号します。
復号するときのkeyとivは暗号化するときと同じものを指定しましょう。keyとivは普通はオープンにしてはいけませんよ。ここが今一つわからなかったのですが、AESの復号ではパティングデータが付いたままでモドされるようです。PaddingMode = Zeroなので後ろに0x00が何個かひっついてきます。
これがあると非常に具合が悪いので除去します。
幸いなことにDERは先頭SEQにデータレングスがあるので、その情報をもとにパディングデータをとっぱらいます。
これでちゃんとしたDERになります。さてさて、Bouncy Castleで署名するためにPEMにしないといけないです。
めんどくさいなぁ、Bouncy CastleってほんとにDERつかえないのかなぁついにこのときが来ました。ファイルの署名を作成します。
Bouncy Castleで署名を作成します。
なにやら色々手順がありますが、思考停止のおまじないということで。
- pemPrivateKeyはPEM形式の秘密鍵。
- targetfilepathは署名対象のファイルのパスとファイル名です。
- ReadAllBytesしているんでファイルを一回全部取り込むっぽいです。巨大なファイルだとヤバいです。ターゲットファイルと署名を一つのzipにして固めてデスクトップに吐き出すだけです。
- .netFrameworkのSystem.IO.Compressionで簡単です。
- 署名はsig.sigというファイル名にします。ゲボ子さんの作業です。
- デスクトップに署名付き報告書ファイル(zip)ができるので、それを上司に送り付けます。このフェーズではセキュリティキーは使いませんゲボ子さんの上司：毛保川はゲボ子さんからメールを受け取りました。添付を見ると署名付きzipです。これが本当に本物かどうか検証アプリでチェックします。とあるデータのVerifyには
- 署名
- 署名した人の公開鍵
が必要になります。検証はGeboSigVerifyというアプリで行います。.netFrameworkのSystem.IO.Compressionで簡単です。
- ディスクにワークファイルを残したくないのでstreamでやってます。ここで、Administrator-Registerフェーズで作成したゲボ子さんの証明書が必要になります。
社内のRepositoryからゲボ子さんの証明書を探してきてその中から公開鍵をGETします。いよいよVerifyです、署名は検証するためにあります。
VerifyはBouncy Castleでやります。
以下のメソッドでtrueとなれば検証OKです。
Verifyによって間違いなくゲボ子さんが書いたものであり、改ざんされていないということが確認できるのです。Bouncy Castleめちゃ楽ちなみにVerifyはこのアプリでなくともできます。
openSSLでやる場合は以下のコマンドでVerifyできます。毛保川の作業です。
- ゲボ子さんから送られてきた報告書を確認し、保管します。
- 電子署名がついているzipのまま保管すればOKFIDO2セキュリティキーに署名の機能を追加することによって、認証と署名ができるようになります。
認証の機能で社内への入退室をしたり、システムにログインし、署名の機能を使って社内文書の署名したりすることができますね。
生体認証もできるのでいい感じでは。今回はかなり簡易的なやり方でやっているので、このような方法で作られた電子署名がどの程度信頼できるものなのか、ちょっとわかんないんですけど。
しかし署名まわりのいい勉強になりました。おわり。


