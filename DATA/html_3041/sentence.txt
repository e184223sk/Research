More than 1 year has passed since last update.よく、文字列やバイト列の圧縮で用いられるBase64。
C# であれば System 空間の ConvertクラスにてBase64 エンコード/デコードのメソッドが提供されています。
MSドキュメント(エンコード)
MSドキュメント(デコード)Base64は64種類の文字を利用するため、エンコード後は１文字あたり6bit( 64=2^6) の情報を持ちます。
このBase64ですが利用する文字は
- 大文字英字
- 小文字英字
- 数字
- + , / or -, _(URL and Filename safeの場合)
という構成になっています。(詳しくはこちらへRFC4648)全部機械で入出力する場合は何でもないのですが、もしBase64エンコードされた値を手動入力する場合、この+ , /などの記号がやっかいだったり、そもそも i, I, l, L, 1 とかはフォントによっては見分けるのが至難の業だったりします。(http://e-words.jp/w/RFC.html より引用)このRFCで4648ではBase64 についての仕様が載っています。
https://tools.ietf.org/html/rfc4648このドキュメントを読んでみるとBase64 の他、
- Base32
- Base16
というものも見つけられるかと思います。RFC4648のBase32の構成要素ですが
- 大文字英字
- 2,3,4,5,6,7
というように、大文字小文字の見間違えや1 とi, I, l, L の見間違え防止のために対策がされています。Base64 に比べ１文字あたりのBit数が減ってしまいます（32=2^5 →5bit)が、人間フレンドリーな内容になっています。実装したスクリプトが置いてあるリポジトリはこちらです。
https://github.com/Cova8bitdots/Base32（MITライセンスなのでご自由にお使いください）エンコード使うテーブルはあらかじめ埋め込んでおきます

private static readonly char[] encode_table =
{ 
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', '2', '3', '4', '5', '6', '7',
};
またデコードですが、毎回入力文字をエンコードテーブルでチェックしようとするとコストがかかるので、
エンコードテーブルの文字をアスキーコードに変換し、その値をIndexとしたデコードテーブルにエンコードテーブルの該当文字のIndexを入れておきますこれで事前準備は完了です。実装したメソッドについてはこちらです。ポイントとしては、コメントにもある通りBase32は１文字あたり5bitのため
1byte=8bit との最小公倍数である40bit 毎に変換をかけていきます。
そのため5byte ずつ読み取ってそれぞれ順番にBase32エンコードをします。実装したメソッドについてはこちらです。こちらもエンコードと同様、1文字あたり5bit のためbyte列を作るにはやはり
最小公倍数の40bit ずつとって、5byte 分変換するというプロセスをとることにしました。また、事前準備の項目でも説明した通り、デコードテーブルを予め作っておくことで、
都度Encodeテーブル内の文字と一致するかというForLoopによるチェックを行わないで済むようになっています。どうしてもBase64使えないとか、人間に記号を入力させたくないという事情があればBase32を使うのもまた一つの解決策でしょう。まぁBase64使えればBase64使えばいいと思います。はい。


