More than 3 years have passed since last update.ミニゲームを作ってUnityを学ぶ！[ひつじコレクション編]前回はフォロワーを作成し、一定時間毎にポップアップする仕組みを実装しました。
今回はUnityのナビゲーションシステムを使ってフォロワーにプレイヤーを追従する機能を実装していきます。Unity公式サイトでは「ナビゲーションシステムによって、シーンのジオメトリから自動で生成されるナビゲーションメッシュを使用して、ゲーム世界の中を知的に動くキャラクターを作成することができます」と記述されています。参考： Unity公式-ナビゲーションと経路探索これを別の言葉に言い換えると「オブジェクトを目的地まで最短距離で移動させるよ！」です。つまりこのシステムを利用してフォロワーの目的地をプレイヤーの位置に設定しておけば、フォロワーは常に最短距離でプレイヤーに近づき、あたかも追従しているかのように見せることができます。ナビゲーションシステムは以下4つの要素から成り立っています。Unityの上部メニューにあるWindow - Navigationを選択するとインスペクタの横にナビゲーションビューが表示されます。ナビゲーションシステムの設定は基本的にこのビューを介して行われます。ナビゲーションシステムの使い方を見るために簡単なサンプルを作成してみます。シーンビューでは画像のようにPlaneの端以外が水色に変更されます。
この水色の部分がNavMeshで定義された移動できる面となります。次に障害物を配置してみます。Cubeが障害物と認識されて周囲が白色になり、移動可能な面から除外されました。
続いてOffMeshLinkを設定してみます。左右のCylinderの間に矢印が表示されました。
目的地までの移動ルートを計算する際にこの矢印を通るルートが最も距離が短いと判断された場合には、矢印のルートを通って移動不可能なエリアを飛び越える（無視する）ことができます。最後にNavAgentをアタッチしたオブジェクトを使って、実際に移動をさせてみます。プロジェクトを実行するとSphereが移動不可エリアを飛び越えて目的地のCylinderまで移動していきます。ナビゲーションシステムの基本を理解したところで早速ゲーム内の処理を実装していきます。
サンプルではあらかじめ生成されているステージに対してBakeを行っていましたが、今回はゲームが開始されてからステージが生成されますので、Bakeをその後に実行する必要があります。このNavMeshの動的なBakeについてはUnityの開発元「Unity Technologies」が大変使いやすいサンプルを公開していますので、今回はこちらのスクリプトを流用していきたいと思います。参照：　NavMeshComponents準備が出来たらナビゲーションビューを開いた状態でプロジェクトを実行します。するとSceneビューの表示が上画像のように、ステージ全体に青みがかったような状態になります。
この青色になっている部分がナビゲーションシステムでいうところの移動可能な面となり、動的なBakeが行われていることを確認できます。参考： HoloLensで実現する動的経路探索LocalNavMeshBuilderとNavMeshSourceTagについては上記のページで非常にわかりやすく解説されていますので、ご紹介させていただきます。動的なBakeはできましたが現段階ではステージのほとんどが移動可能な状態となっていて、Bushオブジェクトが障害物としての役割を果たしていません。これはBakeの際に障害物であるBushの高さが足りずに、飛び越えられると判定されていることが原因です。
この問題を解決するために、ナビゲーションビューからAgent typesの設定を行います。下画像のようにナビゲーションビューのBakeタグにもこの条件を設定する場所があります。この場合は直下のBakeボタンが押されたときのみに使用される条件となっていますので、今回のようにスクリプトからBakeするような場合にはコード上でどのAgentを条件にするか指定しなければなりません。LocalNavMeshBuilderでそれに当たるのが以下の部分です。NavMesh.GetSettingsByID(0)によってAgentTypesの0番 = Humanoidに定義された条件を取得しています。AgentTypeを設定してからプロジェクトを実行すると、Bushが障害物として認識されたことが確認できます。LocalNavMeshBuilderはフレーム毎に処理を行っていますので、プロジェクト実行中にAgentType-Humanoidの値を変えることでリアルタイムにNavMeshの形状が変更されるのを確認することができます。NavMeshを生成する部分が出来上がりましたので、次はフォロワーにNavMeshAgentを使った移動処理を実装していきます。フォロワーはFollow()によって追従する対象が渡されると、UpdateFollow()によって対象の追従を行います。
UpdateFollow()ではその都度、追従対象の現在の位置を目的地に設定し、目的地までの距離を取得してそれが近すぎればAgentを停止、遠すぎればAgentを再開しています。また、前回設定したアニメーションについてもそれを制御するコードを追加しています。続いて、プレイヤー側からフォロワーに対してFollowerModel#Follow()を呼び出し、自身を追従させる仕組みを実装していきます。フォロワーを追従させるためには対象のフォロワーに接触する。
という条件が最もわかりやすいのですが、今回はポップアップポイントに接触した際にその場所にフォロワーが出現しているならば、対象のフォロワーを追従させるという仕組みで実装します。新しくDeleverFollower()を追加しました。
このメソッドはプレイヤーがポップアップポイントに接触した際に呼ばれ、出現中のエフェクトを消すと同時に自身の持っているフォロワーの参照を返します。次に、プレイヤーからPopupPoint#DeleverFollower()およびFollowerModel#Follow()を呼び出す仕組みを実装します。ポップアップポイントに接触したタイミングでTakeFollower()が呼ばれ、接触したポップアップポイントにフォロワーが出現している場合はそのフォロワーに対してFollow()を呼び出して追従を開始させています。このとき、すでに他のフォロワーが追従している場合は一番後ろのフォロワーを追従の対象として渡すことで移動したときにフォロワー同士がきちんと順番を守るように付いてきます。さらにプレイヤーの速度を追従しているフォロワーの数によって再設定していますが、このときにフォロワーの速度がプレイヤーより早くなってしまうと、プレイヤーがずっと移動しているにもかかわらずフォロワーが移動しては止まり、また移動しては止まるといったひどい挙動になってしまうため、全ての追従フォロワーの速度をプレイヤーと同じになるよう再設定しています。プロジェクトを実行して、RPGでいう一列パーティー状態になっていることを確認します。次のページに進む
イントロダクションに戻る

この作品はユニティちゃんライセンス条項の元に提供されています


