More than 3 years have passed since last update.【Unity】LitJsonを使用してデータを超カンタンにセーブする を書いてから、はや2年半。↑の手法は私自身がゲームを作るときにも活用していたのですが、最近つかいづらさが目立つようになってきました。自身で記事を書いといて何ですが、コレがホントに痛いのです。ゲームの規模が大きくなってくるとセーブデータの内容も膨らんできます。
セーブデータの内容が膨らんでくると、フィールドへ直アクセスさせずプロパティを噛ませたい場合もしばしば出てくるのですが、残念ながら「LitJsonはシリアライズ対象のフィールドが必ずpublicである」必要があります。publicのフィールドを残したままプロパティを定義するとクラスが汚くなっちゃいますし、本来フィールドに直アクセスさせたくないのに出来ちゃうってことで、あとあとバグの原因にもなり得るワケで。幸いなことにUnity5.3からUnity公式の「JsonUtility」が使えるようになり、実質的にLitJsonが不要になりました。
私も最近はLitJsonを卒業し、常にJsonUtilityのお世話になっています。!!注!!: JsonUtilityは少々クセがある（後述）ため、LitJson版のセーブデータをまるっとJsonUtility版に移すと一部のデータが復元できなかったりします。
ご注意をば！Unity5.3以降であれば初期状態で使えるので、準備は不要です。LitJson版とほとんど一緒です。
以前はPlayerPrefsにJSON文字列を保存していましたが、セーブデータのバックアップをサーバに保存したい場合があったので、よりカンタンに扱えるようファイルに保存する形に変えました。なお、後述の使用例のようにインスタンス自体を意識させずstaticプロパティとstaticメソッドのみ使用する場合、Instanceフィールドはprotectedにしちゃった方が良いです。使い方に関しては、LitJson版よりチョット気を遣う必要があります。基本的には、publicまたは[SerializeField]が付いたフィールドがシリアライズ対象になります。
フィールドにオブジェクトを持たせ、一緒にシリアライズしちゃうことも可能です。
シリアライズしたいクラスには[Serializable]を付与しましょう。その他 https://qiita.com/keidroid/items/24e03f82d74560dc557a でまとめてくださっていますので、ぜひご一読をば。中でも特に注意すべきことを書き出しておきます。フィールドをprivateにしておいて、プロパティでアクセス制御しましょう。列挙型はクラスのフィールドとして持たせてあげましょう。しょうがないので、文字列に直してあげましょう。こちらも残念ですが、LinqとListの組み合わせで何とかしましょう。セーブデータじゃなくてキャラのマスタデータですが、使い方はこんな感じ。
フィールドはすべて隠蔽してますので、意図しない使われ方をされちゃうことはまず無いでしょう。前作ったゲームもJsonUtility版に置き換えたい・・・！


