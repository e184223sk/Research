More than 1 year has passed since last update.クライアント側にVue.jsをSPA（シングルページアプリケーション）ではない方法で利用することについて記述していきます。全体
　・Vue.jsとblumaの設定
　・cssをblumaに変更
　・バリデーションの変更
　・Vue.jsでのコンポーネントの利用（本稿）「ASp.Net Core でPostgreSQLを利用してIdentityで認証を使えるようにする」で作成した環境にVue.jsを組み込み、cssフレームワークをblumaに変更します。
- VisualStudio2019 Ver.16.2.3
- ASP.NET Core 2.2
- PostgreSQL 9.6 インストール済み、接続用のアカウント作成済み
- EntityFramework
- Vue.js 2.6.10
- bluma 0.7.5　すいません、タイトルに偽りありでした。ようやくVue.jsの記述にたどり着きました。本当はRazorPageでクライアントコンポーネントにVue.jsが使いたかっただけなのですが。
　事の発端はJQuery使いにくい、クライアント動作の為のHTMLはサーバーサイドで作っているのでソースが分かれてしまうのがいや、RazorPageの利点を生かしたままクライアント側のコンポーネントを再利用可能な状態で整理して作りたいという思いから、どうせやるなら.Net Core、それならLinuxで動かそう、それならDBもMySQLかPostgresだよねー、JQueryやめるならBootstrapも変えちゃえと思ってたらこんなことに...。　そんなに大きなものは作れないので、ボタンを押すとページをロックしてページが変わるか一定時間ロック状態にするボタンを作ります。　とりあえず、画面ロックのJavaScriptとして、「wwwroot/js/utilities.js」を作り「_Layout.cshtml」のどこかで作ったスクリプトを読み込ませておきます。　見ての通り、画面全体を覆う「div」を作っているだけです。画面が切り替わる場合は解除不要ですがページを更新しない場合は「unlockScreen」を呼び出してロックを解除した方がいいです。（タイムアウトするはずですが、それはちっと...）　「wwwroot/vue/compornents」フォルダを作成し、その下に「button-with-lock.js」を以下のように作成します。　最初の「button-with-lock」はコンポーネント名で、使う場合にはタグ名となります。
　「props」はタグ内の属性として外部から設定できるものです。
　「template」は、挿入されるHTMLにvue独自の味付けをしたものです。ここでは「v-on:click」でonclickイベントで後述の「methods」の「lockOnClick」を実行させます。また、propで設定した「label」に入っている文字列をボタンのテキストとなるように「{{label}}」（二つの中かっこでくくる）と、その内容に置き換わります。
　最後の「methosds」はスクリプトを記述しています。ここでは下ごしらえで作成した「lockScreen」に引数として「prop」に設定されている「lockmessage」を渡しています。　なお、ES6のみを対象とする場合、「template」ではテンプレート文字列(「`」でくくり、改行も利用できる文字列)のほうが書きやすいです。IE11もサポートしたいので文字列にしていますので、改行を使いたい場合は行末に「\」を入れる必要があります。　作成したコンポーネントをログイン画面で利用してみます。
　「Areas/identity/Pages/Account/Login.schtml」の記述を以下のようにします。　最初に作ったコンポーネントを読み込んでいます。（多分後のvueインスタンス作成）直前でも大丈夫）
　全体の「div」の「id」を「vueTarget」としました。これはvueを使う目印になります。（名前は何でもいいです）
　最後のほうのログインボタンを作ったコンポーネントで置き換えています。このように「props」に設定している値を属性として指定できます。
　最後にvueインスタンスを作成すると、コンポーネントが実装されます。この時「el」で対象となる「div」の「id」を「vueTarget」指定したことで、この「div」内が対象となります。（つまり作ったコンポーネント「button-with-lock」が設定した「div」の範囲外なら何もしないということです。）
　これでデバッグを実行すると、ボタンをクリックするとロックされます。（見やすいように、サーバーの「login」の実装に数秒の待ち時間を入れたほうがわかりやすいです）　上記のボタンはそれなりに使えると思います。
　ただ、実際には作ったコンポーネントにRazorPageのモデルから値を連携させたい場面があるので、ここではとりあえずロックメッセージをモデルから取得するように変更します。（実際にはすることはないと思う）　まずはビューモデルである「Areas/identity/Pages/Account/Login.cshtml.cs」にロックメッセージのプロパティを追加します。　ログイン中のメッセージとして「TestLockMessage」を追加しています。　次にモデルをvueインスタンスの作成時に「data」で与えるのですが、この時ひと工夫が必要でした。（結構調べるのに手間取った）。
　ビューモデルを@Json.Serialize(Model)でシリアライズして渡そうとしたのですが、単純なビューモデルではなく「PageModel」を継承しているためにこのクラスのメンバが大きいうえに循環参照していたりしてエラーになってしまいます。循環参照は無視させると、時間がかかりすぎて帰ってきませんでした。何をしようとしているのやら...。
　調べていくと「Json.Serialize」の第2引数で与える「JsonSerializerSettings」の「ContractResolver」のメソッド「GetSerializableMembers」をオーバーライドしてシリアライズする対象を選別すればいいことがわかりました。「Utility」フォルダを作って「JsonConverterExceptPageModel.cs」を以下のように作成しました。　「GetSerializableMembers」のところで「PageModel」のメンバを除外するようにしています。使う環境によってはもう少し工夫がいるかもしれません。　で、「Areas/identity/Pages/Account/Login.schtml」」を以下のように変更します。　作成したシリアライズ用のクラスを利用する為に、最初に「@using WebApplication1.Utility」を追加。
　ログインボタン「lockmessage」プロパティーは「vue」の「data」の「item.TestLockMessage」を参照させています。参照させる場合はこのように、「v-bind:prop名」の形になります。　これで実行すればロックメッセージが関西弁に変わります。　これで当初の目的であったRazorPageの利点も生かしながらクライアントサイドのコンポーネントをvue.jsで記述することができるようになったので、ひとまずこのシリーズは終わりかな。
　まあ、これを使って使えそうなコンポーネントができればどこかで公開するかもしません。　C#.Net coreもvueも本格的には使っていないので、つたない部分があるかと思います。
　もっとすっきり記述する方法もあるかと思いますので、こうした方がいいのではとかありましたらご指摘ください。


