More than 1 year has passed since last update.コルーチンはMonoBehaviourを継承していればStartCoroutineで動かすことができます。しかし、MonoBehaviourを継承していなくても使いたい場面は割と多いです、多分。
MonoBehaviourなしでコルーチンを動かす方法は調べるとそれなりに出てきますが、そもそもコルーチンで使われているIEnumeratorとはなんぞ？から始めたい所存です。MSDNを見てみるとシンプルに書かれています。非ジェネリック コレクションに対する単純な反復処理をサポートします。IEnumeratorインターフェースは反復処理を実現するためのインターフェースになります。
コルーチンはUnityが反復処理をいい感じに実行してくれてる仕組みというわけですね。とりあえず物は試しということでUnityで適当な反復処理を作ってみます。
わかりやすくデバッグログも出してこんな感じに。こいつをこんな感じで動かしてみますおもったよりかんたん！まずは反復処理についてです。何気なく使っているyieldですが、yieldを含むブロックのことをイテレータブロックと言います。
大雑把に説明すると「1回の処理でここまでやってね」というブロックになります。yieldには値を返すreturnと処理を抜けるbreakの2つのキーワードがあります。次にMoveNextです。これはイテレータを次に進ませます。イテレータが進んだ場合はtrueを返すため、whileを使うとイテレータを全て進めることができます。Currentは反復処理が返した値を保持しているプロパティです。yield returnで返した値がそのまま入ってくる感じですね。
object型なので色んなものを返せます。また、Resetに関してですが、こちらは自前で実装する必要があります（実装してないとNotSupportedExceptionがスローされます）。
単純にIEnumeratorインターフェースで実装した反復処理メソッドをやり直したい場合は対象のメソッドを再び取得して動かします。思ったよりシンプル！これならStartCoroutineなしでもなんとかなりそう・・・？注意点としてWaitForSecounds等は単純にyield returnしただけではうまくいかないです。
よくあるのがyield return WaitForSecondsでカウントをするコルーチンですが、単純にMoveNextをしただけではできません。
MoveNextは1フレーム毎にイテレータを進めるというイメージが良いと思います。この辺はStartCoroutineがいい感じに処理してくれてる部分です。反復処理から反復処理を実行するような形にすればできます。実はIEnumeratorインターフェースを調べ始めたきっかけでもあります。何気なく使っていたコルーチンとIEnumeratorインターフェースですが、思ったよりシンプルでした。
これでもまだ触りの部分だと思いますが、当初の目的を達成しつつある程度は分かった気がしたのでとりあえずOKとしましょう。何かあったらコメントください。++C++; // 未確認飛行 C イテレーター
WisdomSoft 処理の分割（コルーチン）
Qiita:[C#]IEnumeratorとIEnumerableを調べた


