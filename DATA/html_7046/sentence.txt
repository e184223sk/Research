More than 5 years have passed since last update.時代は変化し、いろいろな通信プロトコルやデータハンドリング手段が登場しています。
SOAP やら RESTful やら WebAPI やら WebSocket やら MQTT やら。
.NETフレームワークでも WebAPI やら WCF やら SingleR といった通信フレームワークがあります。
こういったフレームワークが存在しない時代は、Socket通信APIをつかってゴリゴリ実装していたわけです。
Socket通信なんて死ぬほど書いてきたので慣れては居ますが、やっぱり面倒なんです。
非同期にしたり、再接続できるようにしたり、要件によっては暗号や認証を入れ込んだり。
最近はシングルスレッドの非同期実行イベント駆動の方がパフォーマンスいいよねーとか考えて実装してみたり。でもね。
自分や社内で実装したものほど、どこにバグが潜んでいるか心配なわけで。。。
標準で高機能な通信フレームワークがあると、余計な実装をせずに済みます。するとビジネスロジックの設計や実装に集中できますよね。しかしながら、TCP/IP通信であっても、通信相手がそんな最新の通信プロコトルを採用していないことなんでザラです。
制御系と連携するシステム開発を受注すると、昔ながらの電文プロコトルの仕様書をありがたく頂けます。こういうのね。※データ長＝データ部＋チェックサム部＋ETX部こういう電文プロコトルは何者かといいますと、RS-232Cなどでシリアル通信していた時の名残なんです。
通信速度も遅く、大量の電文を送受信できないわけで、必要最低限なバイト数で通信できるように考えた訳ですね。
これはもう今時の通信フレームワークとは無縁なので、ごりごり実装するしか無いわけです。非同期、再接続、コマンド解析、コマンド作成、暗号・複合なんかを。
※遡れば、STXとかETXとかENQといった制御文字は紙テープの時代にまで至りますけど。ちなみに最近みた案件では、送受信方向と通信コマンドによって利用するTCPポートを分けていました。
サーバー→機器のコマンドA：ポート1035
サーバー→機器のコマンドD：ポート1037
機器→サーバーのコマンドB：ポート1039
なんでこんな事してんのかな～と思ったら、機器側がもともと232Cで対応していて、単にTCPに置き換えているせいだ！！と思う。前置きが長くなりましたが、標準で使えるフレームワークはないので TcpListenerクラス や TcpClientクラス で、Listenを開始し、Acceptで接続し、ストリームで送受信するようなコードは Winsockの時代とあまり変わらない「ザ・ソケット通信」ならでは実装です。
もう飽きたので、どこかに適切なフレームワークは無いものかと探しました。
.NET では SuperSocket というOSSが一番利用されているようなので、これでサーバープログラムを作ってみましょう。いつまでメンテナンスされるか心配なので長期間利用するようなプロダクトでは躊躇するなぁ、とは思いつつ。ちなみにちょっと前はJavaを使っていたので Netty の一択でした。SuperSocket で実装してしまった後で Netty をフォークした DotNetty というのを見つけてしまって、ちょいと失敗。次にソケット通信を作るときには使おうと思ったのでした。SuperSocket
http://supersocket.net/
DotNetty
https://github.com/Azure/DotNetty準備はNuGetパッケージでSuperSocketの参照を追加するだけです。
以下は一番ベーシックな実装方法です。通信ポートの確立やクライアントとの接続などソケット通信の基本なところは良しなにしてくれるので、何も実装することはありませんね。デフォルトですとなぜかTelnetサーバーなので、受信が StringRequestInfo の Key と Value に分割されて入っています。
これでは通信プロトコルに合わないのでバイナリデータを受け取るように変更します。何を継承するのか分かりにくかったので、理解するまでちょっと大変でしたけど、出来上がりはシンプルです。サイトのDocumentにも書いてありますが、幾つかのテンプレートがあります。要件に合わせて選択しましょう。


