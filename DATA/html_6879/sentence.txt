More than 3 years have passed since last update.コントローラー以外でもDI連携する方法について完全版も記述したので、そちらも参照してくださいASP.NET CoreではDependency Injectionが標準機能として組み込まれていますが、それでは機能不足な事も多いと思います。そこで、他のDIコンテナとASP.NET Coreを連携させる方法について記述します。通常、各種DIコンテナについては、その拡張としてASP.NET Coreとのインテグレーション機能が提供されると思いますが、今回は自作のDependency Resolverを使用して、連携方法の仕組み自体について記述します。この方法と同じやり方をすることで、インテグレーション機能が提供されていないコンテナについても、ASP.NET Coreとの連携が可能となります。ASP.NET Core Web Applicationを作成し、NuGetでUsa.Smart.Resolverを追加しておきます。IControllerActivatorの派生クラスとして、以下のような実装を用意します。なお、IResolverはSmart.ResolverのDependency Resolverインターフェースになります。StartupクラスでStandardResolverをメンバに定義し、ConfigureServices()でSmartResolverControllerActivatorの設定を行います。IControllerActivatorが設定されると、コントローラーのインスタンスはその実装経由で行われるようになります。この例では、実際のインスタンスの生成をSmart.ResolverのDependency Resolver実装であるStandardResolverに委譲することで、ASP.NET CoreとSmart.Resolverの連携を実現しています。実際に動くサンプルを以下に用意しました。このサンプルは、用途毎に複数のDB接続があるようなアプリケーションを想定したものです。接続を生成する複数のIConnectionFactoryのインスタンスについて、ASP.NET Coreの標準ではサポートされない条件付きバインディングを行っています。なお、SQLiteとDapperを使用し、実際にデータアクセスまで行っています。サンプルで、StandardResolverにインスタンスの生成/管理を委譲する主なクラスについて以下に記述します。Resolverの初期化コードを以下に抜粋します。CallbackConnectionFactoryについては、接続情報の異なる2つのインスタンスを、Named()メソッドにより異なる名称で登録しています。2つのServiceクラスについては、Singletonスコープとして登録し、インスタンス生成時のコンストラクタ引数connectionFactoryについて、名称指定でResolverから取得して設定するようにしています。なお、Named()及びWithConstructorArgument()によって条件付きバインディングを行っていますが、名称による条件付きバインディングはNamedAttributeを使う事でも可能です。また、Smart.Resolverでは明示的に情報を登録しないクラスについてはPrototypeスコープとして扱われるため、コントローラーについてはResolverへの情報登録は不要となっています。IControllerActivatorの他に、IViewComponentActivatorとかもありますでよ(・ω・)


