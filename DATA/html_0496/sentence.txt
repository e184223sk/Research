MVVMパターンでWPFをコーディングしている時、どうしても処理の途中でオペレータの判断を仰いだりしたいこともあるし、
ViewModel内のコマンドから画面を出したいor閉じたい要望が出てくる。コードビハインドを増やしたくはなく、当然ViewModelから参照するわけにはいかない時、"メッセンジャー"という仕組みを用いるこのメッセンジャーという仕組みを使って以下の３つを実現してみるいろいろと調べてみるとPrismライブラリというものを使えば楽に実装できるようだが、そこは天邪鬼なので使わない。（おい）
ただし、Viewプロジェクトに対してNuGetで下記ライブラリをインストールしている。まずMainViewから。ポイントはSystem.Windows.Interactivityインストールして使用可能になった下記xmlnsxmlns:iy="http://schemas.microsoft.com/expression/2010/interactivity"
xmlns:is="http://schemas.microsoft.com/expression/2010/interactions"これを使用してViewModel側の特定のプロパティが発火した時に紐づけたクラス・メソッドを呼び出せるようにしている。
ボタンとラベルについては特に説明することは無い。次にProgressBar用のViewを見てみる。MainView.xamlと同様にイベントを紐づけている。こちらについてはウィンドウを閉じる為の処理。
イベントキャッチ時に実行される肝心の処理については以下の通り。TriggerAction&lt;FrameworkElement&gt;を継承することでイベントの発火をトリガにInvokeメソッドの実行に入るようになっている。
プロパティ変更イベントの為、引数として渡されているparameterにはDependencyPropertyChangedEventArgsが込められている。
そして、変更後プロパティの値をキャストすることでその中身を取り出すという流れ。まず最初にViewModelが２つあるので、共通のViewModelBaseを書いておくOnPropertyChangedはよくある実装。それ以外のプロパティに関しては上記View側でも見た通り。
その中身については簡単なメンバのみ持つ（あるいは何も持たない）クラスMessageBoxRequestメッセージボックスに表示する内容やキャプション、アイコンなど定義できるプロパティクラスShowProgressBarRequestプログレスバーを表示する為のViewModelのみ持つクラスCloseWindowRequestウィンドウ非表示リクエスト用のクラスこれらInteractionRequest.csで定義された各クラスが、先述のInteractionRequestReceiver.csで参照されている。さて、いよいよViewModelを見てみるボタンからのコマンドにバインドしているRelayCommandはICommandを継承したよくある実装なので割愛。
このコマンドでは上記〇〇Requestクラスをインスタンス化し、ViewModelBaseに記載されているプロパティに代入している。
プロパティへの代入（Setterへのアクセス）時にPropertyChangedイベントが発火し、View側の処理が始まるという仕組み。MessageBox.Showや、Window.ShowDialogは子ウィンドウの終了を同期待ちする為、閉じるまでこのコマンド内部の処理は止まることになる。
次に、ProgressViewModelを見ていくが、MainViewModel内でProgressViewModelに渡しているSampleSequencerについてはModel部のクラスなので後述ProgressBarを表示する部分に関してはコンストラクタの最後にExecuteメソッドを呼び、その中でタスクを開始しているだけ。
コンストラクタの中でいろいろ書かれているのはModel側でシーケンス進行時に進捗更新イベントを受け取る為の初期化。必要なシーケンスを実行したのち、CloseWindowRequestのプロパティを更新することでウィンドウを閉じる処理を開始させている最後に、Model側の実装。ViewModel側でいろいろ書かれていたが、Model側の実装は少ないわざわざ抽象クラスを作る必要もなかったかもしれないが、一応そこは汎用性の為作ってみた。
これによりMainViewModel側でProgressViewMdoelインスタンス化の際に、MonitorableSequencerクラスを継承した複数のSequencerを別個に定義することができ、
それら各Sequencerの中身でUpdateProgressを呼び出すことでProgressBarの表示が更新されるという仕組み。ちなみに、ProgressValueについては0~100固定にしていて、ProgressViewModel側で値のチェックはしているものの、
進捗度更新の際に0~100までの値を注意して入れなければならないのは少し気になる。もう少しいい方法があるかもしれない。
（少なくともMin/Maxは定義時に動的に変えてもいいかもしれない）長ったらしく書いたが、自分なりに嬉しいのは*.xaml.csに全く手を加えていないこと。
View-&gt;ViewModel-&gt;Modelの依存関係は全く崩さずにViewModel-&gt;Viewへの流れが作れるのはとても嬉しい


