More than 1 year has passed since last update.Windowsでは古来よりDLLインジェクションと呼ばれる手法で他プロセスに任意のコードを実行させることができます。DLLインジェクション - WikipediaDLLインジェクションはその名の通りDLLを他プロセスに読み込ませてDLLのエントリーポイント(DllMain)を実行させるという仕組みです。
仕組み上ネイティブのDLLを用意する必要があり、残念なことにマネージドなDLLを使用することはできません。マネージドなDLLを使用することができれば以下のようなメリットがあります。全てをC#で書きたい人には圧倒的なメリットですね今回はどうにかしてマネージドなDLLをインジェクトする方法について解説します。
解説する手法を実装したコードは以下のリポジトリにあります。
yaegaki/Mogu最終的に以下のようなことができるようになります。先に述べた通り通常の方法ではマネージドコードを他プロセスに実行させることができません。
そこで今回は他プロセスに.NET Coreをホストさせるコードを実行させてその.NET CoreにマネージドDLLを読み込ませるという手法をとります。参考: カスタム .NET Core ランタイム ホストを作成する - .NET Core | Microsoft Docsコード: Mogu/Injector.cs通常のDLLインジェクションと同様にWriteProcessMemoryでDLLのパスを書き込みCreateRemoteThreadDLLをロードさせます。1
注意が必要な点として相手プロセスが32ビットか64ビットかでLoadLibararyのアドレスが異なるということです。
ホストプロセスと同じビット数のプロセスにインジェクトする場合は特に気にする必要はなく、ホストプロセスでLoadLibaryのアドレスを取得すればそれを使用することができます。
違う場合はめんどくさいのでここを参考にしてください。
簡単に解説すると既にメモリ上に読み込まれたPEイメージから対象の関数のアドレスを取得しています。ホスト側はDLLをインジェクトするだけではなくインジェクトしたDLLに対象プロセス上で実行するマネージドメソッドを伝える必要があります。
様々な方法が考えられますが今回はメモリーマップドファイルを使用します。
メモリーマップドファイルに必要な情報を書き込み、インジェクトされた側はその情報を読み込みます。Mogu/Injector.cs#L88-L96コード: MoguHost/dllmain.cpp.NET CoreをホストするアンマネージドなDLLです。
このDLLはアンマネージなものなので32ビット版と64ビット版を用意する必要があります。
アンマネージドのコードはあまり書きたくないのでここでは.NET CoreをホストしマネージドDLLのメソッドを実行までを担当します。
メモリーマップドファイルの内容を読み込んで指定されたメソッドを実行などは全てマネージド側で行います。公式のドキュメントを参考にコードを書きます。
coreclr_delegates.hとhostfxr.hは以下から取得できます。nethost.dllは以下の場所にあります。参考までに自分の環境では以下の場所です。実行するマネージドDLLはアンマネージドDLLと同じパスに固定の名前で配置されているという前提でコードを書きます。
例えばアンマネージドDLLがC:\XX\MoguHost_x64.dllにおいてあればアンマネージドDLLはC:\XX\Mogu.dllという風にします。
これによって簡単にロードすべきマネージドDLLのパスを取得することができます。MoguHost/dllmain.cpp#L113-L116.NET Coreがホストできれば次はマネージドなコードを実行します。MoguHost/dllmain.cpp#L191-L199
MoguHost/dllmain.cpp#L63-L64これでアンマネージドDLL側のコードの主要部分は終了です。
注意すべき点として既に.NET Coreがmuxerモードで実行されている場合はどうやってもホストに失敗するので諦めましょう。
また二度以上同じプロセスでホストさせる場合は通常の方法ではできません。
最初にホストさせたときに取得したポインタをプロセスに残しておきましょう。
ポインタをプロセスに残すのは少し面倒です。
DLLのグローバル変数として確保している場合、DLLがアンロードされると消えてしまいます。
そこでポインタを保持するだけのDLLを作成し、そのDLLに情報を保持させておきます。MoguHost/dllmain.cpp#L129-L142Mogu/Injector.Injected.csやることは単純で以下のことを実行します。実際にコードを見ていただければわかると思いますが非常にシンプルです。
.NET CoreにはAppDomainが実質存在しないので少し注意が必要です。C#でDLLインジェクションをしたい人なんていない需要は未知数ですが今回の内容を実装するにあたって.NET Coreについての知見が深まりました。
ソースコードを拾ってきて自分でビルドするというのはハードル高めに思っていましたが、.NET Coreの各種ツールは意外と簡単にビルドできて驚きました。
一度自分でやってみるとなかなか面白いのではないかと思います。
DLLインジェクションだけでは全く意味がないのでフックする処理もC#で書けるようにしたかったのですが、安定して動かず記事にするのは一旦諦めました。
残骸は以下に置いています。Mogu/Hooker.csグローバルフックを用いた手法のほうが安全ですが簡単にするためにこの手法を使いました ↩


