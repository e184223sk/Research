More than 1 year has passed since last update.Blazor は、WebAssembly を使用してブラウザで実行される、.NET上に構築されたシングルページ Web アプリケーションフレームワークです。@jsakamoto さんのC# で Single Page Web Application が書ける Blazor が凄かった件 にとても詳しく載っています。大まかな仕組みとしては C# をコンパイルした IL（.NET の中間言語）を WebAssembly にコンパイルすることでブラウザで .NET が実行できます。
TypeScript やその他 AltJS のように JavaScript にトランスパイルされるわけではなく、本当に C# のコードがブラウザで動きます。
このような技術は、今は無き Microsoft Silverlight を連想させますが、そうではなく、オープンな Web 標準を使用してブラウザで実行される HTML と CSS に基づく.NET Web フレームワークです。
プラグインは不要で、モバイルデバイスや古いブラウザでもasm.jsによるフォールバックで動作します。Blazor はまだ実験段階ですが、次のような最新の Web フレームワークのすべての機能を備えています。今回行ったチュートリアルはこちらです。
Get started with Blazor
Github の公式リポジトリはこちらです。
aspnet/Blazorgoogle翻訳先生の力を借りながらチュートリアルを行いました。
もし何か間違いがあったらコメントで教えてください。ファイル &gt; 新規作成 &gt; プロジェクト &gt; ASP.NET Core Web アプリケーションを選択します。
.NET Core ASP.NET Core 2.1を指定し Blazor を選択して OK をクリック。
Visual Studio の場合、Ctrl + F5を押します。.NET Core Cli の場合dotnet runを入力します。ブラウザの開発者ツールを開くと*.dllが読み込まれています！
Blazor は Visual Studio または 任意のエディタ + .NET Core Cli で開発ができます。
ただ、IDE の支援機能をフルに受けられる Visual Studio のほうがより快適です。アプリの3つのページ、[Home]、[Counter]、[FetchData] の各ページを表示してみます。
これらのページはそれぞれindex.cshtml Counter.cshtml FetchData.cshtmlのコンポーネントで構成されています。
Blazorコンポーネントは、ブラウザでコンパイルおよび実行されます。Counter ページ開きClick meボタンを押します。
ボタンが押されるたびに、ページは更新されずにカウンターがインクリメントされます。

このようなクライアント側の動作は通常 JavaScript で処理されます。
しかし、Blazor の場合、C# と .NET によるCounterコンポーネントによって実装されています。Pages/Counter.cshtmlを開きます。
（※Qiitaのシンタックスハイライトにcshtmlが対応していないので分割していますが実際は1つのファイルです。）Counterコンポーネントの UI は、通常の HTML を使用できます。
動的レンダリングロジック（ループ、条件式、式など）は、Razor 構文でマークアップに C# コードを埋め込むことで実現できます。
また、HTML と C# のコンポーネントは、ビルド時に C# のクラスに変換されます。
生成された .NET クラスの名前は、ファイルの名前と一致します。ボタンが押されると、Counterコンポーネントの登録されたonclickハンドラでIncrementCountが呼び出され、Counterコンポーネントはレンダリングツリーを再生成します。
Blazor は新しいレンダリングツリーを前のものと比較し、ブラウザの DOM に変更を適用します。
そして表示されたカウントが更新されます。
DOM の差分更新は React などの仮想 DOM と同じように効率的です。以下のように編集します。ブラウザをリロードし変更を確認します。
定義したコンポーネントは他のコンポーネントのマークアップで HTML タグのように使用できます。index.chtmlにCounterコンポーネントを追加します。ブラウザを更新しHomeページにCounterコンポーネントが追加されているのを確認します。

CounterページとHomeページ上のCounterは別のインスタンスです。
CounterコンポーネントのcurrentCountをインスタンス変数からクラス変数に変更する(int currentCount = 0; =&gt; static int currentCount = 0;)と値が共有します。コンポーネントは外部から渡されるパラメーターを持つことができます。
カウンターの増分をパラメータとして定義してみます。Homeページ(index.cshtml)に追加したCounterコンポーネントにIncrementCount属性を設定します。
CounterコンポーネントのIncrementCountはアクセスレベルはprivateですが、[parameter]属性がついているため外部から設定できます。
React の Propsっぽいですね。ブラウザをリロードし変更を確認します。
Homeページ上のカウンターは 10 ずつ増えますが、Counterページでは 1 ずつ増えます。
.cshtmlファイルの先頭の@pageディレクティブはコンポーネントがルーティングできるページであることを表します。
Counterコンポーネントの場合、@page "/counter"と定義されているので/counterでアクセスできます。
@pageディレクティブがない場合、ルートリクエストをハンドルしませんが、先ほどの例のようにほかのコンポーネントで使用することは可能です。依存オブジェクトの注入によって、コンポーネントはアプリケーションサービスプロバイダに登録されているサービスを利用できます。
@injectディレクティブを使用してコンポーネントにサービスを注入できます。FetchData.cshtmlのFetchDataコンポーネントの実装を見てみます。
@injectディレクティブは、HttpClientのインスタンスをコンポーネントに注入するために使用されます。FetchDataコンポーネントは、注入されたHttpClient使用して、コンポーネントが初期化されたときに、サーバーから JSON データを取得します。@foreach ループで、取得した天気予報オブジェクトのインスタンスをレンダリングします。単純な ToDo リストを実装する新しいページをアプリケーションに追加します。空のテキストファイルをPagesフォルダにTodo.cshtmlという名前で保存します。
最初にページにマークアップを追加します。Shared/NavMenu.cshtmlを編集して、Todoページをナビゲーションバーに追加します。ブラウザを更新してTodoページに遷移できることを確認します。プロジェクトのルートに ToDo 項目を表すTodoItem.csを追加します。
以下のように編集します。Todoコンポーネント(Todo.cshtml)に戻り、@functionsブロック内に Todo リストを保持するフィールドを追加します。foreachループを追加して、各 Todo 項目をリストとしてレンダリングします。アプリには、Todo リストを追加するための UI 要素が必要です。
リストの下にテキストボックスとボタンを追加します。ブラウザを更新して変更を確認します。
ボタンにイベントハンドラが接続されていないため、Add todo ボタンが押されても何も起こりません。
コンポーネントにAddTodoメソッドを追加し、ボタンのonclick属性に登録します。新しい ToDo 項目のタイトルを取得するには、newTodoフィールドを追加し、bind属性を使用してテキスト入力の値にバインドします。AddTodoメソッドを編集して Todo リストに Todo を追加できるようにします。ブラウザを更新し Todo リストが追加できることを確認します。
Todo リストにチェックボックスを追加し終わらせたかどうかをチェックできるようにします。
また、リストの各 Todo の内容を変更できるようにします。終わらせていない Todo の数を表示します。ブラウザを更新して変更を確認します。
WebAssembly で SPA を開発するの面白そうだな、でもちょっと難しいかも...と思っていましたが、拍子抜けするほど簡単でした。
まだまだ足りないところも多いですが、後発なだけあって React、Vue、Angular などのいいとこどりしようという気概を感じます。
Visual Studio の支援はすごいので C#er にとっては JS のフレームワークを使うより快適に SPA の開発ができそうです。
文字列すら入力補完や型チェックが働いて HTML テンプレートがゴリゴリ書けます。Visual Studio の拡張機能には AI がコーディング支援してくれる Visual Studio IntelliCode1 、開発者生産性向上ツール Jet Brains ReSharper などがありますが、これらと Visual Studio の機能を合わせると、もはや、少しの入力とCtrl+spaceによる補完やCtrl+.によるリファクタリング機能だけで SPA 作れちゃいそうな感じさえします(笑)また、現在 Blazor は簡単なアンケートを行っているので、試してみた方はぜひ答えてみてはいかかでしょうか...！？Github のスターが多いリポジトリで機械学習した入力支援人工知能です。ただの補完ではなくコードの文脈に沿った提案をしてくれます。現在 C# のみが対応していますが、ほかの言語も提供予定です。 ↩


