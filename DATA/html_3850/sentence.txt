More than 1 year has passed since last update.この記事は、「【Unity】音ゲーの仕組みを学び「〇〇の達人」をUnityで作る　パート2」の続きです。読んでない方は、先にパート1、パート2から読んでください。【Unity】音ゲーの仕組みを学び「〇〇の達人」をUnityで作る　パート1【Unity】音ゲーの仕組みを学び「〇〇の達人」をUnityで作る　パート2今回でラストです。
UIの精錬(タイトル表示、スコア表示など...)、スコアのロジックを実装していきます。パート2では曲の再生、ノーツをタイミングよく弾いたかチェックするロジック、ノーツを弾いたときのエフェクトを実装しました。DキーとKキーでノーツは弾けるようにし、エフェクトとして「不可」と「良」の表示、「ドン」と「カッ」の効果音を鳴らせるようにしましたね。忘れてしまった方は、さらっとパート2を復習しましょう。タイトル、コンボ、スコアを表示するテキスト、コンボとスコアを表示する背景を設置していきます。まずキャンバスの設定を変更します。ディスプレイの解像度の違いでキャンバスに設置したUIObjectの大きさがかわらないように、UI Scale ModeをScale With Screen Sizeにします。※パート1でPlayとSetChartボタンを作成しているので、UIObjectはあるはずです。ヒエラルキー内でTitleTextという名前でTextObjectを作成しましょう。アンカーを右上になるように設定してから位置を微調整しましょう。ヒエラルキー内でScoreAreaという名前で空のGameObjectを作成しましょう。
その子要素として、背景画像を入れるためのImageObject(TaikoBackground、Taiko)とComboText、ScoreTextという名前でTextObjectを作成しましょう。ScoreAreaのアンカーを左中央になるように設定してから、子要素含め位置を微調整しましょう。〇〇の達人のスコアの集計方法として、通常モードど真打モードというものがあります。
通常モードはコンボ重視の集計方法、真打モードは精度重視の集計方法ならしい。今回は、通常モードを採用します。通常モードでは、天井点(いわゆる満点)と言われる点数が存在します。通常の配点方式で天井点は105万点だそうです。はじめは配点が少ないが、コンボ数が増える配点が増加していきます。ここから先は数学の話になるため、理解しなくてもいいってかたは結論のみで大丈夫です。※理解したい方、難しくはないので心配はいりませんよ 笑配点は簡単な関数で表現できます。y = a * x + bコンボ補正は、コンボ数に応じて増加していきます。つまり、初項50の公差30の設定において、14コンボ目でノーツを弾いた場合、コンボ補正が1となるので加算されるスコアは30 * 1 + 50で80となる。次に、天井点との関係を考慮して初項と公差を決める。天井点はいわゆる満点なので、フルコンボ時のスコアが105万点になるに初項と公差を設定する。コンボ補正が定数なら楽なのだが、変数なので場合分けが必要です。
曲で出現するノーツの総数をmとします。必要に応じて初項はこちらで任意に決めることにします。（ⅰ）mが9以下の時1050000 = amつまり、初項は1050000/m、公差は使わないのでなんでもいい。（ⅱ）mが10以上29以下の時1050000 = am + (m - 9)b初項を300とすると、公差は(1050000 - 300m)/(m - 9)になります。（ⅲ）mが30以上49以下の時1050000 = am + (29 - 9)b + (m - 29)b * 2
1050000 = am + 2 * (m - 19)b初項を300とすると、公差は(1050000 - 300m)/(2 * (m - 19))になります。（ⅳ）mが50以上99以下の時1050000 = am + (29 - 9)b + (49 - 29)b * 2 + (m - 49)b * 4
1050000 = am + 4 * (m - 34)b初項を300とすると、公差は(1050000 - 300m)/(4 * (m - 39))となります。（ⅴ）mが100以上の時1050000 = am + (29 - 9)b + (49 - 29)b * 2 + (99 - 49)b * 4 + (m - 99)b * 8
1050000 = am + 4 * (3m - 232)b初項を300とすると、公差は(1050000 - 300m)/(4 * (3m - 232))となります。mを曲で出現するノーツの総数、aを初項、bを公差とする。
m &gt;= 10 において、aは300とする。Q.E.DGameManager(Script)でスコアの管理をさせます。
CheckTimingIndexを基軸にして、コンボが続いているかを判断し、コンボ数、スコアの加算を制御させています。曲のタイトルとスコアとコンボ数を表示させるために、TitleText、ScoreText、ComboTextを作成する。TitleText ・・・ 曲のタイトルのTextObject
ScoreText ・・・ スコアのTextObject
ComboText ・・・ コンボのTextObjectスコアとコンボ数を管理するために、ComboCount、Score、ScoreFirstTerm、ScoreTorerance、ScoreCelingPoint、CheckTimingIndexを作成する。ComboCount ・・・　コンボ数
Score ・・・ スコア
ScoreFirstTerm ・・・ スコア加算処理に必要な初項
ScoreTorerance ・・・ スコア加算処理に必要な公差
ScoreCeilingPoint ・・・ スコアの天井点
CheckTimingIndex ・・・ 弾くべきノーツのインデックスゲームマネージャー読み込み時に、天井点と弾くべきノーツのインデックスに初期値をセットする。譜面読み込み時に、曲のタイトルを表示させ、ノーツの総数がわかったタイミングで、初項と公差を先ほどの求めた計算式(〇〇の達人のスコアの仕組みで求めた式)で出し、セットしておく。コンボ数、スコアの更新を行うupdateScore関数を作成する。
引数にノーツを弾いた時の結果を入れることで、コンボ数とスコアを計算している。この関数を、ノーツを弾いたタイミングとノーツを見逃したタイミングで発火させることでスコアシステムが完成します。ノーツを弾いたかチェックしているのはbeat関数なので、goodとfailure時、updateScore関数を発火させます。ノーツを見逃したタイミングもfailureとして認識させないと、コンボが続いてしまいます。ノーツを見逃しているのかチェックさせるためにはCheckTimingIndexとNoteTimingsを使用します。※NoteTimingsはパート2で作成した、ノーツの弾かせるタイミングを入れたリストです。ノーツの見逃しが確定する条件は、ノーツが弾いた判定処理つまりbeat関数が実行されておらず、ノーツを弾ける領域外に移動してしまったときです。上のオブザーバーでは、弾くべきノーツがbeat関数によって判定済みであれば、弾くべきノーツを次のノーツに更新しています。下のオブザーバーでは、弾くべきノーツがbeat関数によって判定済みでなく、弾ける領域外に移動してしまった場合、updateScore関数をfailureで発火させ、弾くべきノーツを次のノーツに更新しています。GameManager(Script)にUIオブジェクトをドラッグアンドドロップでセットしましょう。ここまで実装できれば、動かしてみましょう。
スコアとコンボ数が表示されているはずです。これで音ゲーのコアな部分の実装はできていると思います。あとは自分なりにノーツの種類を増やしたり、エフェクトにアニメーションを追加したりしてリッチに仕上げてあげてください。これで君も自称音ゲークリエーターだ！


