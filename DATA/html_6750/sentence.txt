More than 3 years have passed since last update.C# Advent Calendar 2016 16日目の記事です。
http://qiita.com/advent-calendar/2016/csharpListと配列のコピー速度について、何度も記事が出ていますが、自分でもやってみました。.NETのヒープとスタック、クラスと構造体の関係は扱いやすい反面、実行してみないとわからないこともあり、速度面での挙動を感覚的につかんでおくことは重要だと思います。サンプルコードはまとめてGistにあげているので、良かったら使ってください。個別の環境で実行してみると体感出来ると思います。以下の結果は、.NET Framwork 4.5.2、Visual Studio 2015、AnyCPU(32bit優先OFF)　Releaseモードで計測しています。以下のクラスと構造体を用意しました。X, Y, Zの3つのプロパティがあるだけの単純な型です。まず、コピー速度です。List と List&lt;構造体の型&gt;と、classの型[] と 構造体の型[] のコピーではどれが一番速いのでしょうか。
コピーはDeep Copyを想定しています。参照だけコピーするならクラスが一番早いに決まっているので。大きな配列を作成して、何回かループして時間を計測し平均を取ります。このような形で、4パターン試します。
1. List&lt;クラスの型&gt;, List&lt;class&gt;
2. クラスの型の配列, class[]
3. List&lt;構造体の型&gt;, List&lt;struct&gt;
4. 構造体の型の配列, struct[]コード全体はココに置きました。
https://gist.github.com/leetmikeal/e4b1ab9bfff2af245a996bb00bed1f38要素の数が10,000 (約240kB+α)、試行回数100回でやってみました。クラスはClone()メソッドでコピーしていることや余計なメモリを使うので、予想通り構造体の方が明らかに早いですね。List&lt;T&gt;と配列では配列の方が高速です。構造体だとあまり変わらない、もしくは配列の方が遅くなるようです。何度やっても大体このような結果でした。構造体の場合は中身もそのままコピー出来るので、のように簡潔に書けます。
そこで、中の挙動を知るためにソースコードを見てみます。ICollection&lt;T&gt;かどうかをチェックして処理を分けています。CopyToを使用して内部で持っている配列を更新しています。で、今回のテストプログラムで比較対象の配列はどうコピーしているかというと、なので、全く同じはずですが、なぜかListが微妙に早くなります。メモリの扱いの問題なのでしょうか…。何かわかったら追記したいと思います。もう一つ、試してみたかったのがリストと配列の相互変換です。可変データを扱うとき、配列で扱ったほうがいいのか、Listで扱ったほうがいいのか、相互変換の頻度はなるべく少ないように考慮すべきなのか、よくわかっていませんでした。LINQでToArray()やToList()を行う頻度を少なくするべきなのはわかっていますが、複雑巨大なシステムでは各方面の都合でListだったり配列だったりと、扱いが統一出来ていない場合もあり、そのコストは見積もっておきたいと考えていました。クラスの型について、この4パターンを速度計測しました。サンプルコードは先ほどのものを使用して予めリストと配列を作成した後に、LINQでToArray()とToList()を行っています。コピーはShallow Copyを想定しています。計測するのは4パターンですが、必ず最初のケースが遅延するので、実際にテストする際はダミーで1回多く回しています。コード全体はココに置きました。
https://gist.github.com/leetmikeal/7c3fd61e5affeb0cd7e64ba7f9a13757はい。差がありません。変換やShallow Copyのことを気にしてListか配列かを判断しなくても良いということです。最初のテストで行った、Deep Copyの比較を、Listや配列のサイズを変えていったらどのようになるのかを確かめてみました。要素数10から初めて、10刻みで10000まで増やして計算しました。繰り返し回数は10回です。コード全体はココに置きました。
https://gist.github.com/leetmikeal/69d6d18caed6ba52a4d478a5c01a3c38不思議な形になりました。Listの結果がばらついています。常に構造体の方が早いのは当然ですが、要素数が大きくなるとListと並ぶこともあるようです。ただし、構造体は3000要素辺りまでは明らかに高速です。それより多くなると急にListと同じ程度になりました。LOHの影響？上手い説明が思いつかず。大方は予想通りの結果でしたが定量的に説明できるようになると安心感があります。ただ「？」な部分もあるので、標準ライブラリの中身の挙動やGCの影響など、まだまだ理解しなければならないことがありそうです。余裕があれば都度このような簡単なテストプログラムでパフォーマンス評価を続けて行きたいです。あとは高速な処理はC++/CLIでやるべし。


