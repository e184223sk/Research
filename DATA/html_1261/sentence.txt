More than 1 year has passed since last update.もくじ
→https://qiita.com/tera1707/items/4fda73d86eded283ec4fある自作ライブラリのメソッド中で、Taskをawaitをしているところがあったので、当然そのメソッドを.Wait()したらデッドロックするのだろうな、と思っていたら、いざやってみるとデッドロックしなかった。「どんなTaskを.Wait()したらデッドロックするのか」を、MS公式の文書から見つけられなかったので、なんでデッドロックしなかったのか？またデッドロック回避のための方法は？をいろいろ試した＆ほかの方の記事を見て調べた結果のメモ。【お願い】
Taskに関する
「こういう書き方をするとデッドロックしますよ」
「こういう書き方をすると、デッドロック回避できますよ」の
Microft公式ドキュメントのありかをご存知の方、ぜひ教えてください。TaskをWaitしてはいけない
https://qiita.com/acple@github/items/8f63aacb13de9954c5da#task%E3%82%92wait%E3%81%97%E3%81%A6%E3%81%AF%E3%81%84%E3%81%91%E3%81%AA%E3%81%84どのスレッドで処理が実行されているのか？
https://qiita.com/rawr/items/5d49960a4e4d3823722f#%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%EF%BC%94%E3%81%A9%E3%81%AE%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%A7%E5%87%A6%E7%90%86%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%8Basync/awaitと同時実行制御
https://ufcpp.wordpress.com/2012/11/12/asyncawait%E3%81%A8%E5%90%8C%E6%99%82%E5%AE%9F%E8%A1%8C%E5%88%B6%E5%BE%A1/CA2007: Do not directly await a Task
https://docs.microsoft.com/ja-jp/visualstudio/code-quality/ca2007?view=vs-2019という、ざっくり知識はあったので、たぶんこの戻ろうとするスレッドが動いてるかどうか、がポイントなんだろうな、と当たりをつけて、そのあたりを調べるために下記のコードを書いて実験。UIスレッドは、スレッドNo.1。
Taskの中も、await Task.Delayの前まではUIスレッドと同じスレッドNo.1でうごいている。
一度、await Task.Delayを行うと、そのあとからTaskを抜けるまで、スレッドNo.が変わる。(No.3)
Taskを抜けると、もとのUIスレッドNo.に戻ってくる。
（ただし、taskが処理をしている間、UIはフリーズした状態になっている！）
→ちゃんとしたアプリでは使えなさそう。Taskの中の、最初のawaitを行った時点で、デッドロックする。
awaitでUIスレッドに戻ろうとしたが、func1().Wait();でUIスレッドが待ちに入っているので戻ることができず、デッドロックしたと思われる。※たぶん、冒頭で書いていた、中でawaitしてるライブラリのメソッドなのに、そいつを.Wait()してもデッドロックしない奴、は、このパターンだったのでは？と思う。(まだ未確認)taskの中で、一回awaitした後のスレッドNo.が、UIとは別のスレッドになる。実験４と、ログが出力されるタイミングはまったく同じだが、
taskの中で一回awaitした後の戻り先のスレッドNo.が異なる。
つまり、UIスレッドから呼ばれてawaitした処理はUIスレッドに戻ろうとする、ということだと思われる。・実験２のawaitするTaskの中に、awaitする処理が一つもないと、デッドロックしない
　→最初に挙げた動きの原因は、間が抜けているが、これだった。・async/awaitが階層になっていて、一番上で.Wait()する場合、
　間に挟まるawaitするタスクは、一つでも.ConfigureAwait(false)が抜けていると、デッドロックする。


