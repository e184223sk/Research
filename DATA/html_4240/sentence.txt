More than 1 year has passed since last update.旬をすぎてしまった感がありますが Visual Studio 2019 Preview 1 が公開されたようなので null 許容参照型（Nullable reference types）を手元のプロジェクトで試してみました。「気になってるけど自分で試すのは面倒くさい」「自分以外の人がどう感じたか知りたい」「手元に程よい規模のソースがないから試しづらい」みたいな人は読んでみてください。Visual Studio 2019 Preview 1 はこちらからダウンロードできます（たぶん時期が過ぎたらこのリンクは機能しなくなります）。null の可能性があるにも関わらず考慮していなかった箇所がさっそく見つかりました。
元々「この機能（Nullable reference types）、ぶっちゃけ微妙では…」と感じていたところがあった自分としては、「お、役に立つのでは」と印象が変わりました。Kotlin なんかでも似たようなまどろっこしさがありますが、当然のことながら Non-nullable なフィールド・プロパティはコンストラクタやイニシャライザで初期化されなければいけません。それはわかる、わかるのですが、POCO なプロパティの多いクラスですべてのプロパティをコンストラクタの引数として受け取るのは正直ツラく、また、API の戻り値としてデシリアライズによってインスタンス化されるクラスなんかの場合は「常に null はこないプロパティだけどコンストラクタは別に定義したくないんだよなぁ」となりモニョります。定義側ではなく利用側に初期化の責務を負わせて、オブジェクト初期化子を使いたい（デシリアライズの場合はまぁ諦める。元々すべてを網羅することは諦めている機能だと思っているので）みたいな要望。匿名型のように「不変（immutable）だけどコンストラクタパラメーターではなくオブジェクト初期化子で初期化したい」というのは以前から思ってはいたことで、調べてみたら Implement property initializers for immutable types #322 で既に提案されているようですね。私が今回遭遇したケースにおいては Records を使うのが正しいアプローチのような気がします。C# よくわからないですが。結局、 #pragma warning disable CS8618 // Non-nullable field is uninitialized. をつけて回ることで一旦回避しました。元々 = null と書かないといけないのが微妙だなぁとは思っていましたが、当然のことながら？ Caller Info 属性は考慮されませんでした。
この辺は遭遇してみて初めて「あぁなるほど、こういうケースもあるのか」と思いましたね。仕方ないので ! をつけます。Anonymous type display mismatch for nullable vs non-nullable #25348  として報告が挙がっていました。私が遭遇したのは↓のケースで、Select で匿名型を作ると問答無用で nullable なプロパティにされる様子？今回はほとんどのケースにおいてタプルでよかったためタプルに修正して回避しました。
タプルかわいいよタプル。これはよくわかりませんでした。if (value == null) return ""; で弾いてるつもりなのに警告が出ます。引数を object? にしても同じ模様。とりあえず value! にしました……Task&lt;Foo?&gt; に対して Task.FromResult を使うときになんとも微妙な挙動をします。型が合わないと警告が出るので、型引数の明示が必要なのですが、実際に書くと「不要」としてグレーアウトされます。
また、フロー解析がそこまで賢くないためかキャストでは警告が消えません。
プレビュー版だからでしょうか。Where で null を除外してもフロー解析が働きません。
Where だけ特別扱いできないので、仕方ないといえば仕方ないですが結構ツラいです。同じ理由により、UT なんかで null じゃないことをアサーションしたあとでもフロー解析は働きません。Kotlin 1.3 では Contracts によって解決を図っているので C# も頑張ってほしいですね。もはや Non-null reference type あんまり関係ないですが、TaskCompletionSource.SetResult(null) していたところが警告になったので System.Void as a first-class type #1603 が早く欲しくなりました。月並みですが次のような点は「あった方がいいな」と感じました。事前に思ってたより問題にならなそうだと思った点は以下でした。一方で、実際にやってみてツラかったのは以下の点でした


