使ってみて精度が良さげだったのでこのライブラリを選定。
ほかにはSuperPowererdSDKを試したが、libKeyFinderのほうが良さそうだった。
ほかの有償アプリと比べて遜色のない性能を持っているらしい。(キー推定のアルゴリズムについてはできたら今度。
ピッチ推定はこのあたりか？倍音成分の除去がメイン？)Audioは非常にデータが大きいので、スタック領域に確保してはいけない。
(スタック領域はWindowsで2MBなので、2~3秒のデータでさえ乗り切らない)　　
動的に確保するか、staticをつけて静的領域で確保するようにする。
(スタック/ヒープ領域の仕組みはいまだに完全理解できない)また、ライブラリ側でもメモリ制限があるため、長いデータを一気に解析しようとしてはいけない。注：BeatSaberは64bitで動作するので64bitのライブラリを作成すること。FFTWは高速フーリエ変換のライブラリで、libKeyFinderから参照されている。
ココからFFTWをダウンロードしてきて項目タイトルのリンクの方法(Create the import libraryまで)でlibファイルを作成する。なお、途中で開発者用コンソールの使用を求められるが、Windowsのフォルダ検索から辿れる。
WindowsコンソールアプリでC#からC++の関数を呼ぶ方法を参考にしてdllファイルを作成し、
C#から呼び出しテストをする。
C++ライブラリを出力する場所がVisualStudioのバージョンによって若干違うので注意。Visual Stdio2019では、以下の3つの場所にパスを通す必要がある。※libfftw3-3.dllはexeのあるフォルダに入れるか、パスを通す必要があるので注意。また、libKeyFinderのサンプルコードは若干間違っているので注意。正しくは下記。native code debuggingをONにするブレークポイントを貼ってデバッグ実行できる。(ただし配列外参照は止まらないでランタイムエラーを出す)最初にUnityで実験するステップを踏んだほうが組み込み難易度が下がるので、この項目を追加。
UnityでC++の関数を呼ぶには、Asset直下にPlugins/x86_64フォルダを作成し、その下にdllを置く。以下にlibKeyFinder.dllを設置する。
\&lt;Beat Saber Folder&gt;\Beat Saber_Data\Plugins\デフォルトで入っている楽曲は圧縮された状態でロードされてしまうため解析できない。
そのため、CustomLevel限定。(無理やり読もうとするとこんなエラーが出る)
まずは、CustomLevelで追加されている楽曲のファイルパスを取得する。CustomLevelPathの取得はココを参考に以下のようにした。
下記実装でCustomLevelのときのみ処理が実行されるようになっている。ファイルパスからAudioClipに読み込むときには、UnityWebRequsetを使う。www.result == UnityWebRequest.Result.ConnectionErrorは構文エラーが出たので取ってしまった。
AudioClipのLoadStatusがLoadedになっていることを確認すればとりあえずはOKのはず。(ちなみにWebRequestでLoad中は、LoadStatusはUnloadのまま。
yield return www.SendWebRequest();でLoadを待ってあげないといけない。
したがってコルーチンの使用が必須になるが、MonoBehaiviourを継承すればよいだけ)波形データが得られれば、libKeyFinderに渡してやればおしまい。AudioClipの読み込み方法をプログラム内で動的に設定する方法があるらしい(AudioImporter)デフォルト楽曲をどうにか読めないか検索しているとき、譜面自動生成ライブラリを発見した。
ここを参考にすればもしかしたらデフォルト楽曲も読めるようになる？BeatSaberに組み込むときのサンプルコード全体はコチラ


