More than 1 year has passed since last update.以前CakeBuildについて全体的な記事を書いたが、Taskについてあまり掘り下げていなかったと思うので、この記事でもう少し詳しく書きたいと思う。一言でいうと、CakeBuildにおける処理の一塊のこと。
CakeBuildではこのTaskを単位に成功、失敗判定を行う。まず初めにしなければならないことは、TaskをCakeBuildのコンテキストに登録することである。
これは、Task("TaskName");とすることで、TaskNameというTaskを登録できる。
登録しただけでは何もしないので、Task("TaskName")の後にメソッドチェーンの形でどんどん設定を追加していく。Taskの名前に文字種制限は特にないので、グループ化したい場合は"."や"/"で区切ることもできる。タスクのリストを取得したい場合、ICakeContext.Tasks経由で取得が可能で、グローバルで暗黙的に使用可能。cake --showtreeで、依存関係等も含めてタスクが一覧表示される。例えばTask1を実行した後にTask2を実行したい等、タスク間で依存関係を作りたい場合は、IsDependentOnとIsDependeeOfの二つの方法がある。指定した名前のTaskが成功した後に、Taskを実行するという設定を追加する。上記のようにすれば、Task1が成功した後、Task2を実行する、という動作になる。
Task1が失敗した場合、それ以降のTask(Task2)は実行されない。IsDependentOnとは逆の動作をする。つまり、指定したタスクの前に実行し、失敗すればそれ以後のタスクを行わなくなる、というような動作になる。上記のようにすれば、Task2がTask1の前に実行され、失敗すればそれ以降のタスクは行わないという動作になる。
使用場面としては、何か特定のタスクにフック的に動作させたい場合だろうか。タスクが増えてくると、下記のように同じタスクが依存ツリーに重複して出てくる場合がある。上記のようになった場合も、cakebuildの方で関係を整理してくれるので、実行はTask1→Task2→Task3となり、Task1は重複して実行されない。また、下記のように循環依存になった場合は、実行時エラーとなる。Taskに実際の動作を登録するには、DoesをTask("TaskName")の後に続ける。
この時、指定できる形は以下のようになる。最も単純な形は、Does(Action act)となる。具体的には以下また、Does(Func&lt;System.Threading.Tasks.Task&gt; act)という形も取れるため、async awaitも可能なお、System.Threading.Tasks名前空間はデフォルトでusingされてないので注意。また、他のDoesにも言えることだが、以下のように複数繋げることも可能。
複数繋げた場合、書かれた順番に実行がされる。また、自分で設定した型を取ることができる。その場合は以下のような手順となる。コードは以下のようになる。なお、SetupとTaskを書く順番は、前後しても問題ないが、同じ型で二回Setup&lt;T&gt;()すると実行時にエラーになる。スクリプト全体の状態を保持するICakeContextを引数に取ることもできる。DoesForEachを使用することにより、IEnumerable&lt;T&gt;の個別の要素について、タスクが実行できる。例えばあるフラグが渡された場合や、特定のファイルがある場合等、条件によってタスクを実行する/しないを決定したい場合がある。
そういう時はWithCriteriaを使用する。
これもDoes同様、型付引数をとれるもの、ICakeContextをとれるオーバーライドが存在する。上記の通りにすれば、dotnet cake -IsRelease -Target=Task2とされた場合のみTask1が実行される。ただし、RunTargetで指定したターゲットそのものがCriteriaがfalseになってスキップされると、cakebuildはタスク全体を失敗とみなすので注意が必要。よって、WithCriteriaを使うTaskは、直接Targetに指定しない方が良い。try - finallyのように、エラー如何に関わらずTaskの最後に実行したい処理がある場合、Finallyを使用する。ただし、依存元のTaskが失敗した場合は実行されずに終わるので注意。上記の場合、Task2のFinallyが実行されずに終了する。Errorを使えば、Task内で例外が起こった場合、ブロック内でキャッチして無視することもできる。ただし、これは同一Task内でのみ有効な設定なので、依存元のTaskの中でエラーが出た場合は、そのまま終了してしまうので注意上記の場合、Task2のOnErrorまでは来ないで、Task1の実行完了時点で止まる。ログ出力のみして継続したいのであれば、ContinueOnErrorを指定するだけで良い。エラーを受け取ってログ出力するだけで、そのまま終了させたい場合、ReportOnErrorを使用する。エラーが起こった場合、同一タスク内のアクションは通常スキップされるが、そうしたくない場合は、DeferOnErrorを使う。上記のようにすると、.Does(() =&gt; Information("1")と.Does(() =&gt; Information("2")の部分が実行されてからエラーとして処理される。ReportOnError()またはOnError()と併用することも可能。RunTarget("TaskName")とすることで、コンテキストに登録されたタスクを実行する。
固定で引数を指定することもできるが、大抵の場合引数で分けたいはずなので、RunTarget(Argument("Target", "Default"))のような形になる。
この時、コンソールにログは出るが、更に実行結果をXMLに出力したいなどの特殊な処理をしたい場合、戻り値としてCakeReportを受け取ることができるので、これを元にカスタム出力を行うことができる。
ただし、エラーの場合は例外が送出されるため、結果が受け取れないことに注意CakeBuildは、大まかにの順で処理が実行される。Setupは全てのTaskが実行される前に、全体で一回だけ実行される処理で、主に型付きパラメーターの登録等を行う。
逆にTeardownは、全てのTaskが実行された後に一回だけ実行される処理となる。
TaskSetup/TaskTeardownは、各Taskが実行される前と後で実行される。
Teardown/TaskTeardownは、Setup及びTaskが失敗したとしても実行される。コード例は以下のようになる。なお、全てのSetup,Teardown,TaskSetup,TaskTeardownの登録は、RunTargetの前に行う必要があるので注意。これで一通りのTaskに関する記述は出来たと思う。色々書いたけど、まあTask()、IsDependentOf()、Does()だけでそれなりに書けたりする。
後は気が向いたら自分なりのベストプラクティスなんか書ければいいかなと思っている。


