More than 3 years have passed since last update.Kafkaを使うことになりそうなのでいくつかの言語ごとにProducerとConsumerを記述してみる。前々回はGolang、前回はScalaを試してみました。今回はC#編です。C#ではGolang編で試せなかったconfluent製のconfluent-kafka-dotnetを利用してみます（こちらはNuGetで組み込まれるためlibrdkafkaの直接インストールが不要です）。＊今回もKafka自体の解説はしません。VisualStudio: 2017
.NET Framework: 4.5
confluent-kafka-dotnet: 0.11
Newtonsoft.Json: 11.0まずは標準のコンソールアプリを新規作成し、NuGetパッケージの管理から「Confluent.Kafka」とメッセージのシリアライズ・デシリアライズ用に「Newtonsoft.Json」をインストールします。送受信メッセージを定義しておきます。中身は前回までと一緒です。まずはプロデューサーからexampleを参考に書いてみます。前回までと違い、Kafkaのアドレスはコンソールから受け付ける形にしています。
プロデューサーの動作をTask化して10秒に一度メッセージを送信しています。コンソールのCtl+Cを待ってCancellationTokenSourceからCancelを通知します。
久しぶりにC#を書いたんですがクロージャーの扱いってどうなんだっけって感じです・・・。続いてコンシューマーを同じくexampleを参考に書いてみます。大まかにはプロデューサーと似たような感じですが、コンシューマーの方が拾えるイベントが多いみたいです。
consumer.Consume(out msg, TimeSpan.FromMilliseconds(100))が受信部分です。前回まで同様にプロデューサーとコンシューマーを組み合わせて実行してみます（Program.cs）。
どうもプロデューサーの処理結果の出力より、コンシューマーの受信処理の方が早く出てしまうこともあるみたいです。
＊Your.Kafka.Server:9092はダミーです。これまで同様に閉じた世界でやってますが、外につなげたい時、C#ではどうすればいいだろうか？RXあたりを使ってObservableなプロデューサー・コンシューマーを作ってみるのも有りかも・・・。


