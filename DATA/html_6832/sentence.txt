More than 3 years have passed since last update.たとえば、{ 1, 2, 3 } が与えられた場合は、与えられた要素をすべてつかった順列は、の６通りが求められます。順列は、見方を変えると、Tree構造になっていますので、基本的にTreeを辿るのと同じ構造でプログラムが書けます。つまり再帰処理が使えるってことですね。以下に示すのが、最初に作成したC#のコードです。ジェネリックメソッドにしていますので、要素の型は、int以外の任意の型にも対応できます。メインとなるのは、Enumerateメソッドの下請けである _GetPermutationsメソッドです。このメソッドで再帰処理をしています。
第1引数には、現在注目している順列がわたります。再帰するたびに、この順列に、ひとつ要素が加わります。
第2引数には、まだ使われていない数のリストが渡ります。こちらは、再帰呼び出しされるたびに、ひとつずつ要素が減っていきます。このリストが空になったら、ひとつの順列が求まったので、yield return で結果を返しています。
第2引数のリストが空でない場合は、これまで求まった順列に、第2引数のリストの要素を一つ後ろに加えて、_GetPermutationsメソッドを再帰的に呼び出しています。最初に書いたコードは、２つのメソッドに分かれているのがどうも気に入りません。そこで順列について再考。{1, 2, 3}の3つの要素からすべての要素を取り出す(重複を許さない)順列を考えます。
求める順列は、1が先頭に来るもの、2が先頭に来るもの、3が先頭に来るものの3つのパターンがあります。という3つです。
{1, x, y}の場合について考えてみると、1を除いた{2,3}から生成される順列が、x,yに当たるわけですから、を求めればよいことになります。つまり、再帰処理が書けます。なお、集合の要素がひとつだったら、その要素だけの順列を返せばよいので、ここで再帰処理が終わります。これをコードに落としたのが、次のコードです。コードは、GitHubで公開しています。
こちらのほうが理解しやすいかな。速度もこちらのほうが、速くなっているようです。ところで、内側のforeachの中でToArrayを呼び出していますが、これをしないと遅くなってしまいます。再帰的メソッド　+ yield return + LINQ to Objects使う際に注意しないといけない部分かと思います。最初に示した確認用コードを実行した結果です。
1,2,3,4すべてをつかった順列を列挙しています。この記事は、Gushwell's C# Programming Pageで公開したものを加筆・修正したものです。


