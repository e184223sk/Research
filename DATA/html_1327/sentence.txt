More than 1 year has passed since last update.ちゃんとやったことなかった（存在は知ってた）ので覚書です。
ASP.NET Core で Controller を作ったけど、結合テストしないとなぁ…と思ってたけど、単体テストしてるしなぁめんどくさいなぁ…とも思ってたりしてたけど、便利な機能なのでやります！やりますよ。ASP.NET Core の API のプロジェクトテンプレートを作成します。
認証は個別のユーザー アカウント（Azure AD B2C を使うやつ）を設定しました。
前はここにアプリ内でユーザー管理するやつがあった気がするけど…、変わったのかな？
今回はテスト用なので、ドメイン名やアプリケーション ID などは適当なものを入れました。Entity Framework Core 系の以下のパッケージを追加して DB 操作のコードを追加します。とりあえず DbContext は以下のようにしました。Startup.cs に追加しましょう。最後に WeatherForecastController を DB を使うように書き換えます。これで下準備完了です。テストプロジェクトを作ります！xUnit にしましょう（なんとなく
追加するパッケージは以下のパッケージです。最初のものは、ASP.NET Core MVC のテスト時に使うもので、2 つ目のものは結合テスト時に SQL Server ではなく InMemory の DB を今回使おうと思ったので追加しています。SQL Server の localdb とかでやるなら追加しなくてもいいです。今回は本番コードが SQL Server を想定しているのに、テスト用に別 DB を使うケースを試したかったのでそうしています。では、結合テストで起動する Web サーバーを構成していきましょう。
WebApplicationFactory クラスを継承して ConfigureWebHost をオーバーライドします。では、コードを追加していきましょう。追加するコードは WeatherContext を InMemory のものに置き換える処理と、DB にテストデータを追加する処理です。ざくっと追加しました。では、テストコードを追加していきます。
認証されてないと呼べないコードなので、普通に呼んだら Unauthorized になるはずです。まずは、それを試してみます。先ほどの CustomWebApplicationFactory クラスを使って xUnit のテストを書くと以下のようになります。IClassFixture で CustomWebApplicationFactory を作ってもらって下準備をしてもらいます。そして CustomWebApplicationFactory から HttpClient を作って、そいつに対して GetAsync などを呼ぶことで Web API が呼び出せます。以下のようなコードになります。このテストを実行すると GREEN!!いいですね。認証通らないと機能のテストが出来ないので、そこの対応をしていきましょう。まず、テスト用の認証情報を作って返すクラスを AuthenticationHandler を継承して作成します。
中味は、基本クラスのコンストラクタに引数をそのまま渡すためのコンストラクタと、ダミーのテスト用認証情報を返す処理だけで大丈夫です。今回は名前だけ設定していますが、追加のクレームを足したい場合は、ここに足すといいでしょう。以下のようになります。では、テストを書いていこうと思います。先ほど作った認証用のハンドラーを仕込んで HttpClient を作成してから `/WeatherForecast の URL を叩けば OK です。やってみましょう。実行すると GREEN!!!ついでにレスポンスの中身も思った通りの結果かどうか確認しましょう。DB には Tokyo が 2 件、Hiroshima が 2 件あるのでそういうアサーションを書かないといけないのですがメンドクサイ。
そんな時楽させてくれるライブラリとして neuecc さん作の ChainingAssertion があります。NuGet 上での最新は jsakamoto さんがメンテしているバージョンがあるので、そちらを使いたいと思います。アサート処理が凄くシンプルになります。ついでに都市での絞り込みのテストも追加して最終的にはテストコードは以下のようになりました。ということで、結合テストをしてみました。
やってみるとテストまで、きちんと考えられて作られてるんだなぁということを感じました。ということで、意外と低コストで出来るので是非みんなやってみてね！完全なソースコードのリポジトリーはこちら。


