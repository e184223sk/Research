More than 1 year has passed since last update.c#始めて1年が経ちました。
最初にやったのがChartコントロールで、その時は普通の使い方で済んだのですが、最近関係したChartプログラムは思い切り性能の問題がありました。
例えば10msごとに変化する10種類のデータを過去5分間分表示すると、プロット数は30万個になります。これを100msに1回表示更新するとどうなるか。
標準Chartだとたぶんダメなのでサンプリングを10回に1回にするとプロット数は3万個。
妥協も必要ですが、精度を落とした上これで本当に大丈夫と言えるでしょうか？ここで実装するスクロールチャートとは以下のようなものです。最終的な実装だけ知るのであれば途中経過は必要ないかも知れませんね。
プロット数が1万点のときの描画時間です。
プロット数が30万点でも問題なく描画できました。
時間は目安です。描画量や描画面積により大きく変動します。ChartType=LineのときDataPointで指定したX,Yの値でプロットされます。線以外にマーカーが指定できます。
ChartType=FastLineでもX,Yの値を指定できますがXの値を0以外にしない限りデータ並びで等間隔にプロットされるようです。
また同じデータでも描画の感じが異なります。
定周期でデータを取得するなど、時刻が厳密な意味を持たない場合FastLineを利用した方が良いと思います。
ただFastLineでもプロット数が多いと描画に時間がかかるため、Graphicsでの直接描画を試すことにしました。Graphicsで描画するためにはChartのプロット領域を割り出す必要があります。
当初簡単に取得する方法が判らなかったので以下のように計算しましたが、現在はChartPaintEventArgsから求める実装に変更しました。
DrawPathを使用しても所詮データ量が多いと遅くなります。
そこで毎回全点を描画しない方法を考えてみました。
以下のような感じです。
(1)N回に1回全点描画し背景が透明なBitmapに保存する
(2)プロットデータを更新するごとにBitmapを水平移動してDrawImageで描画する
(3)(1)以降に更新されたプロットデータを描画する
(4)プロットデータがN回更新されたら(1)から繰り返す

最終的に掲載のソースコードでは(1)のBitmap生成時、その前のBitmapを平行移動して重ねることで全点描画しない実装としました。
何も指定しないと以下の図（左側）のようにImageを移動して重ねるごとにぼやけてきます。
これについてはGraphics#InterpolationModeをNearestNeighborとすることで解決しました。
ただ移動量の合計はfloatの誤差と思いますが多少縮んでいます（series1の左端）。
今回のアイデアは実際には採用されていません。個人的に試してみただけのものです。
途中間引きによる高速化も検討しました。
「Largest Triangle Three Bucketsアルゴリズム」というものです。
ノイズなど特異点を捨てないという利点があり、欠測もfloat.MaxValueとかに置き換えれば機能します。
しかしながら最初のデータが毎回変わると結果も変わるため、スクロールチャートには不向きであることが判りました。但し起点を変えない工夫をすれば実用になると思います。
またソースは取りあえずひとまとめにして動作確認したというだけで、コンポーネントとしてはまったく不十分ですよね。
MsChartのカスタマイズは（私には）ほとんど無理だということが判りましたが、それ以前に公開されている情報も十分活用できていません。
それでもこの記事がどなたかのお役に立てれば嬉しいです。2019/7/12
系列の処理などを見直しました。
(1)プロットは常に右側からとしました。左からプロットするコードも残っています。
(2)X値を時間軸などとしてXY値でプロットすることも可能としました。
(3)ChartType=Pointとしてマーカーを使えるようにしました。2019/12/2
アクセスが多いので使用例をもう少し判りやすくしようと思ったのですが、結果的にバグ対策を含め色々手を加えてしまいました。
(1)スクロール方向（右→左、左→右）を指定できるようにしました。
(2)描画エリアのサイズ変更などが無い限り全点のLINE描画をしないモードをほぼ実用にしました。
(3)その他実装を見直しました。呼び出し方法も変更になっています。2019/12/6
暇なので少しずつ修正しています。
(1)プロット領域をChartPaintEventArgsから求めるように変更しました。
(2)直接描画をChart#OnPostPaintで行うことで標準系列とスクロール系列が混在しても系列の表示順序が正しくなるように修正しました。PC --- Windows7（Intel Core i5-2300,メモリ8GB）           Windows10（Intel Core i7-2600,メモリ16GB）開発環境 --- Visual Studio Community 2017, 2019ターゲットフレームワーク --- .NET Fremawork 4.6.1, 4.7.2


