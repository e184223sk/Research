※ PostGraphileのトップページに「No N+1 problem」と書かれています。いいですね～
※ HasuraもPostGraphileと類似のプロダクトと認識していますが、本記事では私が利用経験のあるPostGraphileを使用しました。
※ 私はTelerikの回し者ではありません。GitHubに置きました。C#（ASP.NET Core）で GraphQL API を提供するVisual Studio 2019のプロジェクト新規作成画面で、以下のようにBlazorアプリのテンプレートを選択します。プロジェクト名を「SamplePostGraphile」、ソリューション名を「SamplePostGraphile_sol」にしましたが、名前は何でも良いです。Blazor WebAssembly Appを選択します。今回はhttpsは外しました。以下のファイルが自動生成されました。
ソースコードを読むと、データソースとしてwwwroot\sample-data\weather.jsonが使用されています。このままビルドして動かしてみます。
左メニューから「Fetch data」を選択すると、以下のように右側にjsonファイルのデータが一覧表示されました。この時点でgit commitしました。
手順は、Visual Studioのgitメニューからgitリポジトリを作成し、GitHubにpushしました。
以下のコミットメッセージは、Visual Studioが自動生成したものです。ERモデリングツールはA5:SQL Mk-2を使用します。それでは、BlazorアプリのデータソースをPostGraphileに置き換えます。
以下のjsonファイルの中を見ながら、これと類似のテストデータをPostgreSQLに用意します。以下のER図を描きました。エンティティ1つだけですね。ER図メニューから「DDLを作成する」を選択します。RDBMS種類でPostgreSQLを選択し、DDL生成ボタンを押します。以下のDDLが生成されました。本記事ではLinux上のPostgreSQLを使用します。
psqlを起動します。データベースを作成します。名前を「sample_db」にしましたが、何でも良いです。カレントデータベースを、作成したsample_dbに切り替えます。先ほどERモデリングツールが生成したDDLをpsqlにコピペして実行します。以下のINSERT文を流して、2000年1月1日から150日分のテストデータを作成します。
テーブルにはidの降順でINSERTしてみます。以下のSELECT文を流して、データが作成されたか確認します。以下のようにidの降順で表示されましたが、順番に意味はありません。psqlから抜けます。本記事ではPostGraphileをPostgreSQLと同じLinuxホストにインストールします。
このページを参考にして、PostGraphileをインストール＆起動します。
Dockerを使う方法もあります。インストール起動コマンド例起動画面本記事ではBlazorアプリでのCORSエラーを避けるために、単に「--cors」オプションを付けてPostGraphileを起動しましたが、本番環境では安全な方法でCORSエラーを回避してください。postgraphileコマンドを起動するだけで、PostgreSQLのスキーマを読み取ってGraphQLエンドポイントを自動生成してくれます。
とても楽で、これもノーコードと言えるかもしれません。起動画面によれば、URLはとなっています。
本記事では、このLinuxホストのIPアドレスは「192.168.1.7」です。
GraphQLエンドポイントのURLの「localhost」を「192.168.1.7」に書き換えて、後ほどBlazorアプリで使用します。ここでブラウザからGraphiQLにアクセスして、クエリーを発行したりドキュメントを見たりしてみましょう。クエリー例ブラウザ画面レスポンスpsqlからSELECT文を実行したときはid列の降順で表示されましたが、今回のレスポンスを見ると昇順になっていますね。
この順番は気にしないことにして、先に進みます。Visual Studioでの作業に戻ります。Blazorアプリのデータソースは「wwwroot\sample-data\weather.json」でしたが、もう使用しませんのでsample-dataディレクトリごと削除します。
削除後のファイルは以下の通り。NuGetで以下の3パッケージをインストールします。GraphQL APIのレスポンスデータを格納するデータ構造を作成します。
Sharedディレクトリ配下に「WeatherForecast.cs」を追加します。以下の内容にします。GraphQLクエリーを発行して、そのレスポンスからデータを取り出してリターンするメソッドを持つクラスを作成します。
本記事では、CRUDのうちR（Read）のみ実装しました。
プロジェクト配下に「Services」というディレクトリを作成します。Servicesディレクトリ配下に「WeatherForecastService.cs」を追加します。以下の内容にします。プロジェクト内でWeatherForecastServiceクラスを使えるようにします。
変更内容は以下の通りです。データソースをjsonファイルからPostGraphileに置き換えるようにソースコードを変更します。
変更内容は以下の通りです。ビルドして動かしてみます。
左メニューから「Fetch data」を選択すると、以下のように右側にPostgreSQLデータベースから取得したデータが一覧表示されました。以上でデータソースの置き換えは完了です。
この時点でgit commitしました。ここまでのソースコードは、Telerikのコンポーネントがなくてもビルド／実行できます。これ以降は、Telerikのプロダクトがインストールされた環境で作業します。以下のように、Visual Studioの拡張機能メニューからTelerikアプリケーションにコンバートします。NuGetパッケージの管理画面で、Telerik.UI.for.Blazorがインストールされたことを確認します。コンバート完了時点で、一旦git commitしました。TelerikのGridコンポーネントを使用して、データを一覧表示するページを作成します。
Pagesディレクトリ配下に「Grid.razor」を追加します。以下の内容にします。実行時の左メニューにGridを追加します。
変更内容は以下の通りです。ビルドして動かしてみます。
以下のように左メニューに「Grid」が追加されました。これを選択すると、右側にTelerikのGridコンポーネントでデータが一覧表示されました。CRUDのうちRしか実装していませんが、試しに任意の行のEditボタンを押してDate列の右端をクリックしてみます。以下のようにカレンダー入力が出てきました。以上で作業が完了しましたので、git commitしました。GitHubにもpushしました。TelerikのGridコンポーネントは機能がリッチだそうですので、深堀りしてみたいですね。
サードパーティーのコンポーネントに習熟すれば、ノーコードに劣らないスピード感でアプリを開発できそうです。
むしろ、数多あるNoCodeから適切なものを選ぶ→NoCodeで開発する→場合によってはYesCodeで作り直す、というステップを踏むより負担が少ない気がします。以上です。


