Cysharpが公開したMessagePipeですが「個人的にUniTask, UniRx同様に使いこなしたい！」
ということで調べた内容を少しずつ記事にしていきます以下の開発環境でMessagePipeを使用していますMessagePipeとは？
という所は他の方が素晴らしい記事を挙げられているのでここでは書きません
Zenjectについても同じく以下の記事がMessagePipeについて詳しく載せられています！今回はZenject, Unity環境でとりあえずイベントを送受信を行う。
という部分のみの記事ですいきなりですが「覚えるためには実践する」ということで
とりあえずUnityTestRunnerでいじって見ることにしますMessagePipeとZenjectの組み合わせでUnityTestRunnerを実行してみましたこれで テストメッセージ という文字列がログに表示されました
流れ
1. ZenjectのDIContainerを生成する
2. BindMessageBroker&lt;MyEvent&gt;(_container.BindMessagePipe()); でMyEventイベントを送受信できるようにする
3. _container.Instantiate でPublisherとSubscriberを生成しながらInjectもしてもらう
4. Publisherでメッセージを送ればSubscriberが反応してDebugLogが表示されるめちゃめちゃシンプルですがこのコードだけでイベントの送受信ができました。MyEventというものをもう少し現実味があるやにして、このイベントを送受信出来るようにします。実際にイベントを送受信するクラスなどなど..
少しずつコードに組み込んでいくことで
イベント駆動を使用する場面も徐々に思い浮かんでいくかと思いますZenjectを使用してMessagePipeを利用するのでイベントの範囲もZenjectがInject出来る範囲と同一である。
と考えられます。
つまりSceneContextがイベントが送受信できる範囲。SceneContextによらずプロジェクト全体でイベントを送受信できるようにする場合はProjectContext内のInstallerでBindMessageBrokerを使用すると良いということになります。そしてもう少し手軽にメッセージの送受信を出来るようGlobalMessagePipeを使用してみます。GlobalMessagePipeとはその名の通りグローバル空間で使用できるものです。これでGlobalMessagePipeが使用可能になります。
使用するためにはGlobalMessagePipeにDIContainerのServiceProviderを登録する必要があるのですが、ここで登録するのがProjectContextProjectContextはシーンによらず生きているものなのでGlobalMessagePipeに登録するものとしては適切かと考えました。登録した後はGlobalMessagePipeの静的メソッドで気軽にメッセージの送受信ができます。これで更に気軽にメッセージの送受信が出来るようになりました。
イベントは場所を気にせず瞬間的に発行したいことがあるので割とこちらのほうが実際には使うケースが多いのではないでしょうかDisposeやフィルター機能などその他便利機能については取り上げていません。
メッセージを送受信するだけではなくMessagePipeに備わっている機能を使いこなすことで更にゲーム開発効率の向上が出来ると思います。また実際に使用して気づいたことや便利な内容は記事にしていきます。次 Disopose周りについての記事


