コードリーディングしている時にBlockingCollection というものが出てきてよくわからなかったので、調べてみました。主にBlockingCollection in C# - Introduction and Examplesを参考にさせていただいて、自分のコードを書いてみました。BlockingCollection はProducer-Consumer パターンの実装です。IPublisherConsumerCollection&lt;T&gt; というインターフェイスがありますが、そのスレッドセーフの実装です。つまり、コンカレントな状況においてもちゃん動いてくれるものです。デフォルトでは内部的にConcurrentQueue を用いているようですが、コンストラクタでIProducerConsumerCollection&lt;T&gt; を実装したクラスを渡すことで、そちらのクラスを使用するように変えることもできるようです。インターフェイスは次のものになっています。IProducerConsumerCollection実際に挙動を確認してみましょう。BlockingCollection クラスを単純にインスタンス生成します。boundedCapacity を渡すことで、このコレクションの最大値を指定することができます。先ほど述べた通り、ここで、ConcurrentQueue 以外の実装を渡すことも可能です。コンカレントOKとの事なので、スレッドを生成して、そこで、Add を使って要素を足していきます。ここでは、コンソールから入力したものを渡しています。挙動としてのポイントは、上記のコンストラクタで指定した、boundedCapacity を超えると、Add メソッドがブロックして、Consumer がアイテムを取得してくれるのを待ちます。この待ち受けの挙動が好きではない場合、TryAdd メソッドもあります。このメソッドの場合、一定の時間ブロックされたら、「失敗した」とみなして処理をさせることも可能です。CancellationToken を持つオーバーロードもあります。Take メソッドにより、１件のアイテムを取得することができます。もし、BlockingCollection のインスタンスに１件もなかったら、ここでブロックされます。blockingCollection.IsComplete メソッドで、BlockingCollection が終了したことの通知を受け取ることができます。ちなみにこのサンプルで、.GetAwaiter().GetResult() みたいなクソださなことをしているかというと、Task.Factory.StartNew(async () =&gt; {} にすると、async のため labmda　の実行がブロックされて、すぐに終了したとみなされて、後に出てくる WaitAll メソッドでこのスレッドの終了を待ち受ける処理がうまく動作しなくなるからです。正直もっといいやり方がありそう。本番では、async/await を使うので直接スレッドを起動していないので、問題にはなっていませんが、、ダサさを何とかしたい。TryTake メソッドは、ブロック中に、一定の時間がたつと失敗させてくれるメソッドです。TryXXX メソッドは、CancellationTokenをサポートしているので、活用することもできます。CancellationToken が発行されたら、OperationCanceledException がスローされます。プログラムの全体像をシェアしておきます。実行して、何かを入力すると、ProducerがBlockingCollection にアイテムを代入していきます。Producer , ConsumerA, ConsumerB のブロッキングの振る舞いを観察することができます。cancel とタイプすると、CancellationToken が発行されて終了します。もしくは、quit で終了します。今回のサンプルです。
* Sample


