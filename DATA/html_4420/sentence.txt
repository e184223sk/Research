今回はアラームを作りながら正規表現やファイル読み書きなどを学びます。
入力チェックなどもして今までよりも少しまともなアプリケーションを作ります。キーワード：正規表現, ファイル入出力, ファイル保存ダイアログ, タイマー,  Dictionary, スタイル, Null条件演算子[注意]
これまでの回で説明済みの操作方法等は、説明を省略したり簡略化している場合があります。新しいプロジェクトで Visual C# - Windows デスクトップ - WPF アプリで任意の名前でプロジェクトを作成します。ここでは PoorAlarm と入力しました。
そして以下のように画面を作成します。Gridを横3×縦2に分割し、上段にLabel, TextBox, Button, ListBoxを、下段にRadioButtonを配置します。Gridの分割は 連載4回目 や 連載5回目 でやりましたね。
GridのFocusManager.FocusedElementは初期フォーカスを時刻のテキストボックスに設定しています。WindowのResizeModeプロパティを変更してサイズ変更グリップを表示するようにしています。
Window.Resourcesの中はLabel, TextBox, RadioButtonの既定のスタイルを設定しています。
連載10回目 ではスタイルに任意の名前を付けて、各コントロールのStyleプロパティでその名前を指定して適用していました。いったん実行してみます。こんな感じ。
時刻とメッセージを入力して追加ボタンを押すと右側の一覧に登録され、
指定した時刻が来たら（アラームがONになっている場合）メッセージが表示される。
というものにします。
追加した時刻とメッセージの一覧は終了時にテキストファイルに保存し、次回起動時に読み込むようにします。アラームON/OFFラジオボタン選択値と、時刻・メッセージ一覧ファイルのパスを記録しておく設定項目を用意します。
これは 連載10回目 でやりました。
ソリューションエクスプローラーでSettings.settingsをダブルクリックし、AlarmEnabledというbool型の設定項目と、SaveConfigPathというstring型の設定項目を用意します。設定のSaveConfigPathに値が設定されているか、設定されている場合はそのファイルが存在するか確認するメソッドを作成します。
このメソッドは後で使います。アプリのタイトルを文字列リソースとして登録します。
ソリューションエクスプローラーでResources.resxをダブルクリックし、「アクセス修飾子」をPublicにし、
「名前」にAppTitle、
「値」にこのアプリの名前、
「コメント」にこの文字列リソースをどこで使うのか等の説明を入力します。コメントは後で見た時に分かりやすくするためのものなので空欄でも構いません。文字列リソースは英語版や日本語版など、多言語対応時に活きてくるものです。
本来は画面のラベルやメッセージボックスのメッセージ内容なども文字列リソースとして登録しますが、今回は使い方の紹介なのでタイトルだけ登録します。ここまでで一度ビルドしておきましょう。Xamlにxmlns:prop="clr-namespace:PoorAlarm.Properties"を追加します。
これでPropertiesがpropという識別子でアクセス可能になったので、
Titleプロパティの値を {x:Static prop:Resources.AppTitle} に書き換えます。メッセージボックスを表示するためのメソッドを作成します。
連載1回目 のメッセージボックスと違い、メッセージボックスタイトルとアイコンも指定しています。
ここでもタイトル部分にリソース文字列を使用しています。追加ボタンのイベントハンドラを記述します。まず、正規表現というものを使って入力された時刻が「数字2桁」 + 「:」 + 「数字2桁」になっているかチェックしています。
条件に合致していればRegexクラスのIsMatchメソッドはtrueを返します。
"^[0-9]{2}:[0-9]{2}$" の^は行頭、[0-9]は0～9のいずれか、{2}は直前（左）の文字を2回繰り返す、$は行末を意味します。
"^あいう"という正規表現は、「あいう」から始まる"あいうえお"にはヒットしますが"ああいうえお"にはヒットしません。
"^いよ$"という正規表現は"いよ"にはヒットしますが、"いいよ"、"いよかん"、"たいよう"にはヒットしません。しかしこのままでは25:99なんてものもチェックを通ってしまいます。
そこで次にDateTimeクラスのTryParseメソッドを使って日付型に変換できるか確認しています。
日付型への変換が成功すれば戻り値にtrueが返り、2番目の引数に変換後の日付オブジェクトが設定されます。が、今回は日付に変換できるか知りたいだけなのでd変数はこの先使いません。メッセージが入力されていることを確認したらリストボックスに時間とメッセージをタブ区切りで追加します。\tはタブ文字です。
途中のチェックでエラーがあればエラーメッセージを表示します。ここまでで一度実行してみましょう。正しくない時刻を入力して追加ボタンを押してみると、エラーメッセージが表示されます。正しい時刻とメッセージを入力して追加ボタンを押すと右の一覧に追加されます。ウィンドウ起動時と終了時のイベントハンドラを用意します。アプリケーション終了時に呼び出す、一覧に追加した内容をファイルに保存するメソッドを作成します。
using { } で囲った部分が終了すれば開かれたファイルは自動的に閉じられます。
StreamWriterクラスを生成する部分は、コードを見ただけでパラメータの意味が分かるよう、パラメータ名も書いています。
ここは Properties.Settings.Default.SaveConfigPath, false, Encoding.UTF8 と記述することもできます。
2番目の引数falseは追記しない、つまり毎回ファイルを作り直すという意味です。保存するファイルパスを指定するためのダイアログを表示する処理です。
ファイルが指定されたら上で作成したファイル保存の処理を呼んでいます。ウィンドウ終了イベントに処理を記述します。
Properties.Settings.Default.AlarmEnabled = alarmOn.IsChecked == true;の部分は、アラームONのIsCheckedプロパティがtrueの場合にAlarmEnabledにtrueを、その他（nullかfalse）の場合にAlarmEnabledにfalseを設定しています。
Settingsの変更をファイル保存するにはSaveメソッドを呼びます。色々と変数を用意します。初期化用のメソッドを作成します。
Dictionaryクラスはキーと値のセットを格納できます。
Dictionaryの後ろの&lt;&gt;の意味は&lt;キーの型, 値の型&gt;です。
今回はキーに時刻の文字列、値にメッセージの文字列を格納します。
タイマーは 連載2回目 でも使用しましたが、タイマーイベントの登録を別パターンで書いています。こちらがタイマーイベントの処理です。
timeAndMsgsというのは先ほど用意したDictionaryです。
現在時刻の文字列を取得し、それがtimeAndMsgsの中にあればメッセージを表示します。
200ミリ秒ごとにこのイベントが発生するようにしているので、そのままだと分が変わるまで何度もメッセージが出てしまいます。
その対策でメッセージを表示したらshowTime変数に時刻を保存し、同じ分に連続してメッセージが出ないようにしています。
メッセージ表示部分の timeAndMsgs[time] は、Dictionary変数にキーを渡すことで対応する値を取得できます。
つまり時間文字列を渡して対応するメッセージを取得しています。そして初期化処理をコンストラクタで呼ぶようにします。追加ボタンを押したときに、同じ時刻を登録できないようにDictionaryを使って重複チェックをし、
リストボックスへの追加と同時にDictionaryへも追加するようにします。ウィンドウ起動時の処理を作成します。
ファイルの読み込みはStreamReaderを使います。ラジオボタンのCheckedイベントを作成します。
2つともalarmOnOff_Checkedを呼ぶようにします。
複数のコントロールに同じ処理を設定するのは 連載5回目 でやりました。アラームONがチェックされたらタイマーを起動し、OFFがチェックされたらタイマーを停止します。アラームONのラジオボタンが選択されているときに、右の一覧に登録されている時間が来たらメッセージが表示されるようになりました。
時間が来てもアラームOFFが選択されている場合はメッセージは出ません。アプリケーションを閉じると、ファイル保存ダイアログが表示され、一覧ファイルの保存先を聞かれます。
次回起動時はそのファイルを読み込み、一覧を画面に復元します。追加ボタンを押したときの処理が、if文が入り組んでいて分かりづらいので少し整理します。
エラーチェックしてエラーになったらreturnですぐ処理を抜けるようにし、if文のネストが深くならないようにしました。ラジオボタン選択時の処理を修正します。
timer変数が初期化される前にイベントが動いてしまうとStartやStopメソッドを呼ぶときにエラーになってしまうため、nullチェックをしていました。
これをNull条件演算子「?.」を使うやり方に変えます。
nullチェックしていたif文を削除し、timer.Start() を timer?.Start() に変えます。Stopも同様です。
?.の左側のオブジェクトがnullの場合は右側は参照されず、nullを返します。今回の例で言えばStartやStopメソッドは実行されません。
?.の左側がnull以外の時は右側が実行されます。
Null条件演算子は連続して使うこともできます。
A?.B?.C()は、オブジェクトAとBがnullではないときに、メソッドCが実行されます。おしまい＜＜ 最初の記事 　 ＜ 前の記事 　 次の記事 ＞


