More than 1 year has passed since last update.C++(≠C++/CLI)からC#のメソッド1を呼び出すには次の方法があります。.NET Core用のC++/CLIが無いので対象は.NET Frameworkです。C++/CLIではマネージド/アンマネージドの区別が重要になります。C++/CLIで作成するDLLにはマネージドコードとアンマネージドコードを共存させることができます。
それぞれ#pragma managedと#pragma unmanagedで切り替えられます。ハンドルはマネージドクラス専用のポインターのようなもので、T* ではなくT^という型名を持ちます。アンマネージドクラスはハンドルを直接メンバー変数に持つことができません。
ただしgcrootというクラステンプレートでラップすることでメンバー変数にできます。C++/CLIの最もよくある使われ方は、C++のライブラリをC#(.NET)で使えるようにするために使う事でしょう。この時は、C++クラスのラッパーをマネージドクラスで作成することになります。逆はもうひと手間掛かります。これらの制限を超えるため、2つのラッパーを作成します。2.はC++側に見せるため、1.の実装に依存できません。2.を基本クラスとし、1の実装は隠蔽します3。簡単のため、以下のシンプルなC#のクラスを作成します。これをC++から呼び出します。まずC++にエクスポートするクラスを作成します。ヘッダーファイルがC++とC++/CLIの両方でコンパイルできるように注意します。ファクトリーメソッドも宣言しました。生のnewは邪悪ですからunique_ptrを使用します。次にC#のメソッドを呼び出すクラスを作成します。最後に次の簡単なアプリケーションでラッパーを利用してみましょう。C++/CLIではなくC++でコンパイルします。実行結果WrapperImpl::managedObjectはクラス内メンバーイニシャライザで初期化したいところですが、デフォルトコンストラクタを{}ではなく=defaultで実装したところ、アンマネージドコードでgcnewは使用できない(C3821)と言われてしまいました。ハマりそうなので普通にコンストラクタ内で初期化しています。正確には.NET Frameworkのアセンブリに格納されているメソッド ↩IDLを書かなくても.NETのアセンブリさえあればTLBファイルが生成できる ↩アンマネージドクラスならポインターは見えてもよいので、pimplパターンも使える ↩


