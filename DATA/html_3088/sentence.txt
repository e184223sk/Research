More than 1 year has passed since last update.Unityでこんな機能をつけたい、といったときのコードへの落とし方をまとめました。
Unityを利用し始めの人向けです。
全部書くのは大変なのでurlベタ張り気味ですが...ProjectのCreateからC# Scriptを選びましょう。
ここで注意が必要なのが、名前の変更です。
生成時の名前付けは問題ないのですが、あとから名前を変える場合
名前を変えてもスクリプト上のクラス名は変わりません。
必ずスクリプト上でも名前を変更しましょう。エディタ上からスクリプトをダブルクリックすると自動的にIDEが開かれます。
標準だとVisual Studioですね。
スクリプトを変更して保存すれば、自動的にUnity上に反映されます。
IDEなどで実行する必要はありません。オブジェクトにスクリプトを追加することをスクリプトをアタッチするといいます。
ドラッグ＆ドロップでもできますし、インスペクタのAdd Componentからもできます。Start、Update、Awakeってなんや！FixedUpdateとUpdateどう違うねん！
みたいな人へ
https://docs.unity3d.com/ja/2018.2/Manual/ExecutionOrder.htmlUpdateは1フレーム毎に呼ばれます。呼ばれる間隔は一定ではありません。
FixedUpdateは一定時間ごとに呼ばれます。
Inputなど入力はUpdate、RigidBodyなどの物理演算はFixedUpdateを使った方がいいとか。
https://gametukurikata.com/basic/updateDebug.Log()を使いましょう。
実行されたタイミングでConsoleに表示されます。
変数の値はもちろん、ifなどの条件が通っているかなど確かめられます。自身のクラスから他のアタッチされたComponentを参照したい場合があると思います。
そんなとき使うのがGetComponentです。
例えばEnemyオブジェクトにRigidBodyと、
自作クラスEnemyControllerとEnemyが存在するとき。オブジェクトの移動方法は様々です。
transform.positionの値を直接書き換える、RigidBodyを使う、CharacterControllerを使う、Vector3を使う。
私はCharacterControllerを主に使っています。
RigidBodyにて、FreezePosition,FreezeRotationで動けるベクトルを制限できるので便利です。簡単なのはtransform.Rotateでしょうか。
こちらもいろんな方法があるので模索してみてください。
https://docs.unity3d.com/jp/current/ScriptReference/Transform.Rotate.htmlInstantiateを使いましょう。
引数として、生成するオブジェクト、生成する位置、生成する角度(、親となるオブジェクト)を渡します。生成したオブジェクトを変数として扱いたい場合や、削除する場合などは、かならずInstantiateで生成するときに変数に代入しましょう。Destroyメソッドを使います。
引数に消したいオブジェクトを入れましょう。prefabそのものを消すことはできません。あくまでインスタンス化されたものです。オブジェクトを消したくはないけど、無いものとみなしたい。
インスペクタでいうところの、左上のチェックを外したいというとき。SetActiveを利用しよう。
もちろん非アクティブからアクティブにすることも可能。オブジェクトのグループ化としてタグは便利です。
CompareTagを利用することで特定のタグであるかどうか判断できます。これがとてもよく使います。
よく使う上になにかと間違います。
オブジェクトにBoxColliderなりコライダーがついているもの同士がぶつかる、
つまりコライダーがぶつかることで衝突判定をおこなっています。OnTriggerEnter, OnCollisionEnterはコライダー同士が触れた瞬間、
OnTriggerStay, OnCollisionStayはコライダー同士が触れ続けている間、
OnTriggerExit, OnCollisionExitはコライダー同士が離れた瞬間
に呼ばれます。CollisionとTriggerの違い等はサイト参照
物理演算をさせたいときはCollision、非物理的なものやセンサー的なものはTriggerを使うらしい(私は専らTriggerばかり)
ちなみにこの2つは引数も違うので注意が必要。https://gametukurikata.com/program/collisiontrigger
https://docs.unity3d.com/ja/2017.4/ScriptReference/Collider.OnTriggerEnter.html
https://docs.unity3d.com/ja/2017.4/ScriptReference/Collider.OnCollisionEnter.htmlTime.deltaTimeを利用する。
これは前回のフレームから何秒経ったかを示すので、
毎フレーム呼ばれるUpdate関数と組み合わせることで経過時間を計ることもできる。Inputクラスを利用。
愚直に何のキーが押されたかを判断してもいいが私は好まない。
UnityのProject SettingsからInputの設定ができる。
そこでキーボードやコントローラーの対応付けができる。例えばFire1をマウス左クリック、Enter、とあるコントローラの〇ボタンに対応させたとする。
そのとき以下のスクリプトでは3つの入力どれでも反応する。https://docs.unity3d.com/ja/2018.1/Manual/ConventionalGameInput.html
https://qiita.com/yando/items/c406690c9ad87ecfc8e5GameObject.Findで名前で検索。
GameObject.FindWithTagでタグ検索。
たくさん使うと重くなるので注意。
Transform.Findを使うことで、特定オブジェクトの子オブジェクトから探すことも可能。https://docs.unity3d.com/ja/2017.4/ScriptReference/GameObject.Find.html
https://docs.unity3d.com/ja/current/ScriptReference/GameObject.FindWithTag.html
https://docs.unity3d.com/ja/2018.1/ScriptReference/Transform.Find.htmlTime.timeScale = 0;
ただしFixedUpdateなど一部止められないものもあるらしい。なにかとよく使いたい遅延したあとの実行。
コルーチンを利用して解決しました。
waitTime後に実行されます。SceneManager.LoadScene(シーン名)で可能using UnityEngine.SceneManagement;
忘れずにPhysics.Raycastを利用
重いので頻繁に呼ばない方がいいらしい。予めRaycastHit型の変数を用意しておく。
Physics.Raycastはbool型。trueならRaycastHitの変数に検知した情報を代入といった具合。layerMaskを引数で加えることで、特定のレイヤーのオブジェクトのみの検知ができます。http://kan-kikuchi.hatenablog.com/entry/RayCast1
http://kan-kikuchi.hatenablog.com/entry/RayCast2
https://docs.unity3d.com/ja/2018.2/ScriptReference/RaycastHit.htmlひとつのSceneに複数のCanvasを配置することがあると思います。
そんなときにCanvasの絵画順(どのCanvasを画面手前に配置するか)を指定するのは、CanvasコンポーネントのSortOrderの値を変更することでできます。SortOrderの値が大きいCanvasが手前に絵画されます。


