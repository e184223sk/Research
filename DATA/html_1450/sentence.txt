More than 1 year has passed since last update.いい加減終わらせないと気持ちが悪いし、ここまで進めてきて、機能的にはほぼ実装が完了したのでこれにて終了することにしました。
【できたこと】
・元のアプリの機能を実装する
・当初目標である画面解像度によりフォームのボケについてはおおむね解消
・追加機能としていたアプリのアイコン化表示モードについても実装
【できなかったこと・わからなかったこと】
・画像化リソースを利用している部分については、結局ぼけたりしてる
・DragMoveでのWindowのちらつき
・起動中の解像度変更への対応、解像度の異なるマルチディスプレイへの移動時の自動対応左から、Forms版（画面解像度125％）WPF版（画面解像度125％）、WPF版（画面解像度100％）。
いろいろトピックスまとめると、、・WPF NotifyIconを利用
・NuGetで上記のHardcodet.NotifyIcon.Wpfを導入
（プロジェクトメニューからNuGetパッケージの管理を選択し、参照タブでHardcodet.NotifyIconと入れると出てきます）
・デザイナで作業する場合、Hardcodet.NotifyIcon.Wpfの導入で追加される「TaskbarIcon」をウインドウ上の好きな場所に配置
・詳しくは上記サイトのチュートリアルを参考。
・固定アイコンならICONリソースや画像ファイルからデータをセット
・アイコンに対してのイベントは「Trayxxx」で記述
・ICONリソースを出すだけなら以下でOKSystem.Windows.Threadingを利用。DispatcherTimerとして新規タイマーを定義し、TimeSpanでインターバルを設定。
設定したタイマーに定期的に呼び出したい処理をイベント設定する。
設定ができたらタイマーをStartする。(7)でのロジックを変更。当初Window上に描画したCanvasをそのままNotifyIconに入れてましたがNotifyIcon用には別にメモリ上にCanvasを作成してそちらを入れてあげてます。最終的に以下のように変更しました
本体側CS↓定番のXML形式で設定を記述することとしそれ用のPrefクラスを作成してそこのREADとSAVEをまとめた例。保存先は固定でドキュメントフォルダ直下としています。（Prefをドキュメントフォルダってのも安直ですが）CSV形式のログファイルをStreamで作成、リードしています。
取り込みはまとめてBuffに格納し、後の処理　MakeListView　で行に分解していきます。ReadLogで作成されたBuffを受け取って、改行で行分割、さらにカンマでフィールド分割し、曜日を文字列変換して専用クラスに格納し、ListViewにAddしていきます。当ツールのメイン機能であるログの更新処理です。１分ごとに呼びだされ、現在の時分（HHMM）でウインドウ上ListViewの該当日付の起動時化及び終了時刻を更新し続け、毎回、更新後のListViewのアイテムをもとにログファイルを再作成することでログの更新も行います。リスト内のスタイルをデータに応じて変化させる場合、XAML上でStyleにTrigger設定しDataTriggerでバインド対象となる項目名とデータ内容条件を設定しておきます。またセレクトによるスタイルの制御もTrigger Property="IsSelected" Value="True" により可能。コード側は特に何も記述しなくてもOK。デザイナでベースを作る場合の手順は、
①デザイナで、CMSを設定したいコントロール上のプロパティ内の「その他の指定」内のContextMenuで新規作成ボタンを押す
②ContextMenuのプロパティが下に展開表示されるので、その中のItemsの右の「...」ボタンを押す
③コレクションエディタが表示されるので、普通のメニューアイテムであれば下のプルダウンを「MenuItems」にして追加ボタンを押す
④追加されたMenuItemのプロパティが右側に表示されるので、「Header」にメニュー表示文字列を入力する。
⑤アイテム選択ごとに起動するルーチンはXAML上で適宜定義できる。同一ルーチンにまとめて処理分岐させる場合はTagなどを使ってコード側で判定し、適切な処理に分岐させる
という方法を取りました。
NotifyIconの種類を選ばせるCMS　XMAL側の記述↓C#処理側記述↓
アイコンの選択処理は設定画面からだけでなくノティファイアイコンのCMSメニューからも呼び出しで使うので、ルーチンにくくりだしています。Windowのクリック透過を実装することで、アナログ時計をガジェット的にクリック反応しない背景として表示しっぱなしにしたいなあということで実装しました
User32系をまとめたCS側でGet/SetWindowLongを定義↓メイン側の記述でクリック受けと無視時の値を保存しておき↓NotifyIconのCMSメニューでの設定変更の際に、TopMostを考慮の上設定を行ってます↓(14)で書いた通りで実装。せっかく作った画面右上・右下それぞれの隅っこへの飛ばし機能ですが、IF的にどう組み込んでいいのかなかなかいい案が思いつかなかったので、Windowの右上、右下の縁に三角形のボタンとして入れることにしました。また画面の最小化（というかHide）のボタンも欲しかったので右上への飛ばしボタンの下の三角をNotifizeボタンとして入れてあります。
ボタンの体裁定義はXAML側ResourceDictionary内で行ってます。ポリゴンの座標を記述。Polygon x:Name="ButtonTriangle" Points="0,0 16,16 16,0 0,0"　のところですね。で本体側のXAMLでこのようにStyleを呼び出し。時報の画面は別Windowクラスで作成。また時報画面で表示するアナログ時計は、メインウインドウ側でアナログ時計を描画するルーチンを使いまわしてます。
まずは親からの時報画面の呼び出し。時報画面となるsignalクラスのウインドウを作成してshowしてます。毎回newで作るべきか、最初だけnewで作って、以降は持ちまわるべきか少し迷いましたが、シンプルに毎回作成して毎回クローズする手順を取りました。ちなみにSetWindowPosはshowした後でないと効果がない。全部準備できたらSignalStartで子側のタイマーを起動させてます（newしたsigwin側でSignalStartを受け取る準備が完了しているか確証がないので、正確性に欠けてます）。時報WINDOW側の記述は自分自身これまでプロセスをベタで記述する手法に慣れてしまっていることもありWPFらしさが全くない単なるVB→C#コンバージョンになってしまった気がします。WPFは特にクラスの最低限の知識がないと難しいという印象。XAML・データのBindingあたりがハードルが高い。逆に全体構造を正確に理解できていればFormsで実現が難しかったことが高い自由度でスマートに実現できるんだろーなという予想。


