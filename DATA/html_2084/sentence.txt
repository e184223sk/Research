More than 1 year has passed since last update.私は勉強がてらGithubにてHandbrakeBatchRunnerという、オープンソースのHandbrakeを使った動画をバッチ変換を行うソフトを作っています。その開発中に覚えたTips集などを、Qiitaで今後記事にしていきたいと思っています。
今回のはその第一弾となっています。前提環境
VisualStudio 2019
.NET Core 3.1
WPF(C#)動画変換をする際に、他のウインドウで既に変換中の場合は完了を待ちたいなというのを思い実装していました。「んん～～～～動画を２重に変換したところで遅いし待ち合わせしないとなあ」
「ほかプロセス待つんだったら、やっぱしMutexだよね！」
～Mutexを使うプログラミング中～
「ぐああああ！DisposeしてもReleasMutexしないと残ってめんどくせえええ！」
「しゃーない。ラッパー自分で作って自動開放しよう。」
～ラッパー作り作り～
「よしよしusingで開放されるようにしたし。取得できるまで長いからawaitしちゃお♪」実行System.ApplicationException : Object synchronization method was called from an unsynchronized block of code「ホーリーシット ！！！」はい。
MutexってWIN32APIのラッパーなので色々特殊な上に古いんですよね。
開放がReleaseMutexを明示的に呼ばないとされなかったり、なかなか曲者です。開放用にラッパークラス作って、今回は変換中を長く待ったりするしawaitしようかなと思った結果が前項のApplicationExceptionになります。※そもそもApplicationExceptionってユーザの例外用のクラスなんですが、これみたいにフレームワーク内からでちゃったりで現在は非推奨になってますが、こんなところで出くわすとは…Mutexは取得したスレッドからでないとReleaseMutexできない仕様のため、awaitを使うとスレッドが別になり、今回の問題にぶちあたりました。時間がかかる処理の割にawaitとは相性が悪いです。プロセスまたいで待合せをやろうと思うことも少ないためか、海外フォーラムのCodeProjectやStackOverFlowでも解決策が出てなかったんで、今回記事にしてみようかなと思い書いています。「まじか。こんなことやろうとする変態は自分ぐらいなんや…」
「おっしゃ自分で解決しよ！」ウキウキ※予め種明かししておくと、作りが無理があって実用的ではないかも…
※他こうしたほうがいいじゃない？などあればどしどし頂きたいです！それではソースで見ていきましょう。普通に書くとこうなります。ReleaseMutexを別でやらないといけないし、本当はTry-finallyでやらないと実行されないケースもあってめんどくさいです。なおMutexは継承禁止クラスのため委譲パターンで作るよりないです。使う方はこう。開放がusingに任せられるようになったのでスッキリしました。
ここまでは他の記事、ブログなどでよくありますね。ラッパーにこんなのを足します。使う方はこう。UIをブロックしなくなって更に良い！と思いきや、これだとawaitでWaitOneを実行するので、Mutexの取得時と開放時の実行スレッドが異なることになりMutex的には駄目です。この問題を解決どうするのか。黒魔術で対応します。メンバ変数に以下の変数を足して非同期取得メソッドはこう変えてMutexの取得から開放まで１スレッドで処理します。開放時の処理(Disposeメソッド)はこう。全て繋げるとこうなります。う～～～ん。クレイジー！
（誰もやらないわけだ）※追記
awaitやるために、内部でスレッド走らせてローレベルなシグナル処理したり
ぶっちゃけ本末転倒な感じだと思います。ただ意地で実現したかったんです(・ω・)GitHubに動かして試せるようにサンプルを入れました。リンク：サンプルソース
01_MutexAndAwait.NET Core 3.1 + WPF　C#で作っています。


