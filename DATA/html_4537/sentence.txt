More than 1 year has passed since last update.以前はRSA暗号について書きましたが、今回はOpenSSLで作った鍵を使って楕円曲線暗号で署名と検証をします。C#の標準ライブラリが楕円曲線に対応したのは、.NET 4.7(C# 7.0, Visutal Studio 2017)以降のようであり、しかもこれを使ってもプログラムが難しそうなので、楕円曲線暗号のライブラリとしてBouncyCastleを使うことにしました。BouncyCastleのインストールは、いつもどおりNuGetから行えばよいです。使用バージョンを整理しておくと、今回の記事では次のバージョンを使用しました。ちなみに BouncyCastleのライセンスは MIT Licence となっています。OpenSSLのバージョンによって、使用できる楕円曲線の種類が違うので、最初に確認しておきます。今回使ったOpenSSLのバージョンでは、４種類の曲線が使えるようです。楕円曲線は何を指定しても処理方法は同じなので、この記事では適当に secp256k1 を指定しておきます。できたもの
secp256k1.privatekey：秘密鍵（鍵ペア）
secp256k1.publickey：公開鍵秘密鍵（鍵ペア）について補足しておくと、公開鍵暗号で「鍵ペア」と言うと「公開鍵」＋「秘密鍵」をイメージしている人が多いと思しますし、大雑把にはその理解でいいのですが、実際の中身は、秘密鍵は鍵全部のデータで、公開鍵は秘密鍵の（公開できる）一部のデータです。そのため、秘密鍵は公開鍵を含んでいるので、公開鍵としても使うことができますし、秘密鍵から公開鍵を取り出すこともできます。（もちろん、技術的に秘密鍵を公開鍵としても使用できるといっても、秘密鍵を相手に渡してよいという意味ではありません。念のため）PEMの中身を少しだけ見ておきます。OpenSSLで楕円曲線の鍵を生成すると、２パートに分かれています。楕円曲線暗号はRSA暗号よりパラメータ数が多いはずなのですが、PEMのサイズはすごく小さいです。これは、パラメータとして、楕円曲線名が書かれているだけだからです。楕円曲線名から各パラメータの値（AとかQとか）を知りたい場合は、参考サイトに載せた「楕円曲線のパラメータ一覧」から調べる必要があります。ちなみに、BouncyCastleは、このPEMファイルを読み込めて欲しいのですが、現在のバージョンでは読み込めませんでした。UnitTestのコードには、TODOとなっていたので、将来のバージョンでは対応されるかもしれません（しかし、C#版のBouncyCastleはほとんど更新がないため、望みはないかも）。仕方が無いので、BoucyCastleで読み込めるようにするため、秘密鍵（secp256k1.privatekey）と公開鍵（secp256k1.publickey）を取り出します。秘密鍵を取り出す、と言っても、２パートあるうちの下のパートの部分になるだけです。opensslのコマンドを使わなくても、テキストエディタでコピペしてもOKです。実はこの中にも楕円曲線名が入っているため、これだけでも十分だったりします。ちなみに、PEMの中身を見るアプリケーションを使うと、こんな感じになっています。Object Identifier(OID)に楕円曲線のOIDが入っています。今回使うのは、この４つだけでよさそうでした。System.Security.Cryptography は不要でした。PEMファイルなので、Org.BouncyCastle.OpenSsl.PemReader で TextReader から読み込みます(①)。鍵情報は、ReadObject() で取り出せますが、戻り型が object となっているため、非対称鍵ペア(AsymmetricCipherKeyPair)にダウンキャストしておきます(②)。Org.BouncyCastle.Crypto.Signers.ECDsaSigner#Init() で署名インスタンスを初期化します(①)。第１引数は署名するので true、第２引数は署名用の秘密鍵を指定します。署名インスタンスが初期化したら、後は GenerateSignature() で署名するだけです(②)。なお、楕円曲線の署名の値は、整数値が２つ（RとS）あるため、戻り値は BigInteger の２要素の配列となっています。ただ、実際に署名として使いたい値は、（用途にもよりますが）byte配列だと思いますので、もう少し加工します。JWTの署名として使う場合、この２つの値をオクテット（byte配列）にして連結するだけなのですが、オクテットはビッグエンディアンで、先頭の値がゼロのバイトはstripする必要があります。そのため、署名の長さは必ず64オクテットになります。C#は、というかWindowsはリトルエンディアンであるため、BigInteger#ToByteArray()でbyte配列を得るだけではダメで、反転させなければなりません。うへぇ。②で得た署名の値（RとS）を、ToByteArray()でbyte[]にし、SkipWhile(b =&gt; b == 0x00)で先頭にあるzeroバイトを削除し、Reverse()で反転します(③)。ここまでできれば、後は結合するだけです(④)。基本的には署名と反対のことを行えばよいです。署名をbyte配列で受け取ったら、まず32byteずつに分割し、RとSに分けます（その前に、署名の長さが 64byte であることをチェックします）。その後、それぞれをBigIntegerにしたいのですが、C#はリトルエンディアンなので Reverse() で反転する必要があります(①)。さらに最初のbyteの最上位bitが1である場合、マイナスになってしまうので、先頭にzeroのバイトを追加してやらないとなりません(②)。まじすか。BigIntegerにできれば、あとは署名と同様に、Org.BouncyCastle.Crypto.Signers.ECDsaSigner#Init() で署名インスタンスを初期化します(③)。第１引数は検証なので false、第２引数は署名検証用の公開鍵を指定します。署名の検証は VerifySignature() メソッドで行い、第１引数に署名元データ、第２・３引数に署名の値、RとSを指定します(④)。 C#標準ライブラリで楕円曲線暗号を使うのは難しそうだったので、BouncyCastleを使いましたが、どういう訳かBouncyCastleにはC#のドキュメントが全くありません。C#版の更新頻度もそんなに高くないので、正直コレを使っても大丈夫か、という一抹の不安はあります（ライセンス的には問題なさそうですが）。さらにドキュメントが無いので、暗号/復号の方法が分からず、今回は触れることができませんでした。どうもUnitTestを見るしか情報源がなさそうなのが、BouncyCastleを使うのが厳しいところです。アルゴリズムの話は全くしなかったのですが、楕円曲線をざっくり知るには、このスライドショーがいいと思います。楕円曲線のパラメータ（AとかGとかいうやつ）一覧です。今回はライブラリを使ったので、自分で楕円曲線(ECCurve)を実装する、という必要は無かったのですが、そうでない場合は、楕円曲線名からここで各パラメータをコピペする必要があります。楕円曲線の署名って数値２つなのに、JWTの署名の値はどうするんだ、と思ったのですが、ちゃんと仕様書に書いてありました。ちなみに、BoucyCastleにはC#のドキュメントが全く無いので、リンクは張らないでおきます。


